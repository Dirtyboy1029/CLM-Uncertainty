{"code": "char *Hub::inflate(char *data, size_t &length) {\n    dynamicInflationBuffer.clear();\n    inflationStream.next_in = (Bytef *) data;\n    inflationStream.avail_in = length;\n    int err;\n    do {\n        inflationStream.next_out = (Bytef *) inflationBuffer;\n        inflationStream.avail_out = LARGE_BUFFER_SIZE;\n        err = ::inflate(&inflationStream, Z_FINISH);\n        if (!inflationStream.avail_in) {\n            break;\n        }\n        dynamicInflationBuffer.append(inflationBuffer, LARGE_BUFFER_SIZE - inflationStream.avail_out);\n    } while (err == Z_BUF_ERROR);\n    inflateReset(&inflationStream);\n    if (err != Z_BUF_ERROR && err != Z_OK) {\n        length = 0;\n        return nullptr;\n    }\n    if (dynamicInflationBuffer.length()) {\n        dynamicInflationBuffer.append(inflationBuffer, LARGE_BUFFER_SIZE - inflationStream.avail_out);\n        length = dynamicInflationBuffer.length();\n        return (char *) dynamicInflationBuffer.data();\n    }\n    length = LARGE_BUFFER_SIZE - inflationStream.avail_out;\n    return inflationBuffer;\n}", "target": 1}
{"code": "int qcow2_snapshot_load_tmp(BlockDriverState *bs,\n                            const char *snapshot_id,\n                            const char *name,\n                            Error **errp)\n{\n    int i, snapshot_index;\n    BDRVQcowState *s = bs->opaque;\n    QCowSnapshot *sn;\n    uint64_t *new_l1_table;\n    int new_l1_bytes;\n    int ret;\n    assert(bs->read_only);\n    snapshot_index = find_snapshot_by_id_and_name(bs, snapshot_id, name);\n    if (snapshot_index < 0) {\n        error_setg(errp,\n                   \"Can't find snapshot\");\n        return -ENOENT;\n    }\n     sn = &s->snapshots[snapshot_index];\n     new_l1_bytes = sn->l1_size * sizeof(uint64_t);\n     new_l1_table = g_malloc0(align_offset(new_l1_bytes, 512));\n        return ret;\n    }", "target": 1}
{"code": "sctp_disposition_t sctp_sf_ootb(struct net *net,\n\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\tvoid *arg,\n\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sk_buff *skb = chunk->skb;\n\tsctp_chunkhdr_t *ch;\n\tsctp_errhdr_t *err;\n\t__u8 *ch_end;\n\tint ootb_shut_ack = 0;\n\tint ootb_cookie_ack = 0;\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\tch = (sctp_chunkhdr_t *) chunk->chunk_hdr;\n\tdo {\n\t\tif (ntohs(ch->length) < sizeof(sctp_chunkhdr_t))\n \t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n \t\t\t\t\t\t  commands);\n\t\tif (SCTP_CID_SHUTDOWN_ACK == ch->type)\n\t\t\tootb_shut_ack = 1;\n\t\tif (SCTP_CID_ABORT == ch->type)\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\tif (SCTP_CID_COOKIE_ACK == ch->type)\n\t\t\tootb_cookie_ack = 1;\n\t\tif (SCTP_CID_ERROR == ch->type) {\n\t\t\tsctp_walk_errors(err, ch) {\n\t\t\t\tif (SCTP_ERROR_STALE_COOKIE == err->cause) {\n\t\t\t\t\tootb_cookie_ack = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n \t\t\t}\n \t\t}\n\t\tch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));\n\t\tif (ch_end > skb_tail_pointer(skb))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n \t\tch = (sctp_chunkhdr_t *) ch_end;\n \t} while (ch_end < skb_tail_pointer(skb));\n\tif (ootb_shut_ack)\n\t\treturn sctp_sf_shut_8_4_5(net, ep, asoc, type, arg, commands);\n\telse if (ootb_cookie_ack)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\telse\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n}", "target": 1}
{"code": " pch_write_line (lin line, FILE *file)\n {\n  bool after_newline = p_line[line][p_len[line] - 1] == '\\n';\n   if (! fwrite (p_line[line], sizeof (*p_line[line]), p_len[line], file))\n     write_fatal ();\n   return after_newline;\n}", "target": 1}
{"code": "bool ID3::removeUnsynchronizationV2_4(bool iTunesHack) {\n size_t oldSize = mSize;\n size_t offset = 0;\n while (mSize >= 10 && offset <= mSize - 10) {\n if (!memcmp(&mData[offset], \"\\0\\0\\0\\0\", 4)) {\n break;\n }\n size_t dataSize;\n if (iTunesHack) {\n            dataSize = U32_AT(&mData[offset + 4]);\n } else if (!ParseSyncsafeInteger(&mData[offset + 4], &dataSize)) {\n return false;\n }\n if (dataSize > mSize - 10 - offset) {\n return false;\n }\n uint16_t flags = U16_AT(&mData[offset + 8]);\n uint16_t prevFlags = flags;\n if (flags & 1) {\n if (mSize < 14 || mSize - 14 < offset || dataSize < 4) {\n return false;\n }\n            memmove(&mData[offset + 10], &mData[offset + 14], mSize - offset - 14);\n            mSize -= 4;\n            dataSize -= 4;\n             flags &= ~1;\n         }\n        if (flags & 2) {\n size_t readOffset = offset + 11;\n size_t writeOffset = offset + 11;\n for (size_t i = 0; i + 1 < dataSize; ++i) {\n if (mData[readOffset - 1] == 0xff\n && mData[readOffset] == 0x00) {\n ++readOffset;\n --mSize;\n --dataSize;\n }\n                 mData[writeOffset++] = mData[readOffset++];\n             }\n            memmove(&mData[writeOffset], &mData[readOffset], oldSize - readOffset);\n            flags &= ~2;\n         }\n         if (flags != prevFlags || iTunesHack) {\n             WriteSyncsafeInteger(&mData[offset + 4], dataSize);\n             mData[offset + 8] = flags >> 8;\n            mData[offset + 9] = flags & 0xff;\n }\n        offset += 10 + dataSize;\n }\n    memset(&mData[mSize], 0, oldSize - mSize);\n return true;\n}", "target": 1}
{"code": "pxa3xx_gcu_write(struct file *file, const char *buff,\n\t\t size_t count, loff_t *offp)\n{\n\tint ret;\n\tunsigned long flags;\n\tstruct pxa3xx_gcu_batch\t*buffer;\n\tstruct pxa3xx_gcu_priv *priv = to_pxa3xx_gcu_priv(file);\n\tint words = count / 4;\n\tpriv->shared->num_writes++;\n\tpriv->shared->num_words += words;\n\tif (words >= PXA3XX_GCU_BATCH_WORDS)\n\t\treturn -E2BIG;\n\tif (!priv->free) {\n\t\tret = pxa3xx_gcu_wait_free(priv);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tspin_lock_irqsave(&priv->spinlock, flags);\n\tbuffer = priv->free;\n\tpriv->free = buffer->next;\n\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\tret = copy_from_user(buffer->ptr, buff, words * 4);\n\tif (ret) {\n\t\tspin_lock_irqsave(&priv->spinlock, flags);\n\t\tbuffer->next = priv->free;\n\t\tpriv->free = buffer;\n\t\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\t\treturn -EFAULT;\n\t}\n\tbuffer->length = words;\n\tbuffer->ptr[words] = 0x01000000;\n\tspin_lock_irqsave(&priv->spinlock, flags);\n\tbuffer->next = NULL;\n\tif (priv->ready) {\n\t\tBUG_ON(priv->ready_last == NULL);\n\t\tpriv->ready_last->next = buffer;\n\t} else\n\t\tpriv->ready = buffer;\n\tpriv->ready_last = buffer;\n\tif (!priv->shared->hw_running)\n\t\trun_ready(priv);\n\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\treturn words * 4;\n}", "target": 1}
{"code": " accept_ice_connection (GIOChannel           *source,\n                        GIOCondition          condition,\n                        GsmIceConnectionData *data)\n {\n        IceListenObj    listener;\n         IceConn         ice_conn;\n         IceAcceptStatus status;\n        GsmClient      *client;\n        GsmXsmpServer  *server;\n        listener = data->listener;\n        server = data->server;\n         g_debug (\"GsmXsmpServer: accept_ice_connection()\");\n        ice_conn = IceAcceptConnection (listener, &status);\n         if (status != IceAcceptSuccess) {\n                 g_debug (\"GsmXsmpServer: IceAcceptConnection returned %d\", status);\n                 return TRUE;\n         }\n        client = gsm_xsmp_client_new (ice_conn);\n        ice_conn->context = client;\n        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));\n        g_object_unref (client);\n         return TRUE;\n }", "target": 1}
{"code": "sync_create_state_control(Slapi_Entry *e, LDAPControl **ctrlp, int type, Sync_Cookie *cookie)\n{\n    int rc;\n    BerElement *ber;\n    struct berval *bvp;\n    char *uuid;\n    Slapi_Attr *attr;\n    Slapi_Value *val;\n    if (type == LDAP_SYNC_NONE || ctrlp == NULL || (ber = der_alloc()) == NULL) {\n        return (LDAP_OPERATIONS_ERROR);\n    }\n    *ctrlp = NULL;\n    slapi_entry_attr_find(e, SLAPI_ATTR_UNIQUEID, &attr);\n    slapi_attr_first_value(attr, &val);\n    uuid = sync_nsuniqueid2uuid(slapi_value_get_string(val));\n    if ((rc = ber_printf(ber, \"{eo\", type, uuid, 16)) != -1) {\n        if (cookie) {\n            char *cookiestr = sync_cookie2str(cookie);\n            rc = ber_printf(ber, \"s}\", cookiestr);\n            slapi_ch_free((void **)&cookiestr);\n        } else {\n            rc = ber_printf(ber, \"}\");\n        }\n    }\n    if (rc != -1) {\n        rc = ber_flatten(ber, &bvp);\n    }\n    ber_free(ber, 1);\n    slapi_ch_free((void **)&uuid);\n    if (rc == -1) {\n        return (LDAP_OPERATIONS_ERROR);\n    }\n    *ctrlp = (LDAPControl *)slapi_ch_malloc(sizeof(LDAPControl));\n    (*ctrlp)->ldctl_iscritical = 0;\n    (*ctrlp)->ldctl_oid = slapi_ch_strdup(LDAP_CONTROL_SYNC_STATE);\n    (*ctrlp)->ldctl_value = *bvp; \n    bvp->bv_val = NULL;\n    ber_bvfree(bvp);\n    return (LDAP_SUCCESS);\n}", "target": 1}
{"code": "void sqlite3Fts5UnicodeAscii(u8 *aArray, u8 *aAscii){\n  int i = 0;\n  int iTbl = 0;\n  while( i<128 ){\n    int bToken = aArray[ aFts5UnicodeData[iTbl] & 0x1F ];\n    int n = (aFts5UnicodeData[iTbl] >> 5) + i;\n    for(; i<128 && i<n; i++){\n      aAscii[i] = (u8)bToken;\n    }\n    iTbl++;\n  }\n}", "target": 1}
{"code": " init_copy(mrb_state *mrb, mrb_value dest, mrb_value obj)\n {\n   switch (mrb_type(obj)) {\n     case MRB_TT_CLASS:\n     case MRB_TT_MODULE:\n       copy_class(mrb, dest, obj);\n      mrb_iv_copy(mrb, dest, obj);\n      mrb_iv_remove(mrb, dest, mrb_intern_lit(mrb, \"__classname__\"));\n      break;\n    case MRB_TT_OBJECT:\n    case MRB_TT_SCLASS:\n    case MRB_TT_HASH:\n    case MRB_TT_DATA:\n    case MRB_TT_EXCEPTION:\n      mrb_iv_copy(mrb, dest, obj);\n      break;\n    case MRB_TT_ISTRUCT:\n      mrb_istruct_copy(dest, obj);\n      break;\n    default:\n      break;\n  }\n  mrb_funcall(mrb, dest, \"initialize_copy\", 1, obj);\n}", "target": 1}
{"code": "bool extractPages (const char *srcFileName, const char *destFileName) {\n  char pathName[4096];\n  GooString *gfileName = new GooString (srcFileName);\n  PDFDoc *doc = new PDFDoc (gfileName, NULL, NULL, NULL);\n  if (!doc->isOk()) {\n    error(errSyntaxError, -1, \"Could not extract page(s) from damaged file ('{0:s}')\", srcFileName);\n    return false;\n  }\n  if (firstPage == 0 && lastPage == 0) {\n    firstPage = 1;\n    lastPage = doc->getNumPages();\n  }\n  if (lastPage == 0)\n    lastPage = doc->getNumPages();\n  if (firstPage == 0)\n   if (firstPage == 0)\n     firstPage = 1;\n   if (firstPage != lastPage && strstr(destFileName, \"%d\") == NULL) {\n    error(errSyntaxError, -1, \"'{0:s}' must contain '%%d' if more than one page should be extracted\", destFileName);\n     return false;\n   }\n   for (int pageNo = firstPage; pageNo <= lastPage; pageNo++) {\n     snprintf (pathName, sizeof (pathName) - 1, destFileName, pageNo);\n     GooString *gpageName = new GooString (pathName);\n\t{\n\t  printUsage (\"pdfseparate\", \"<PDF-sourcefile> <PDF-pattern-destfile>\",\n\t\t      argDesc);\n\t}\n      if (printVersion || printHelp)\n\texitCode = 0;\n      goto err0;\n    }\n  globalParams = new GlobalParams();\n  ok = extractPages (argv[1], argv[2]);\n  if (ok) {\n    exitCode = 0;\n  }\n  delete globalParams;\nerr0:\n  return exitCode;\n}", "target": 1}
{"code": "int qeth_snmp_command(struct qeth_card *card, char __user *udata)\n{\n \tstruct qeth_cmd_buffer *iob;\n \tstruct qeth_ipa_cmd *cmd;\n \tstruct qeth_snmp_ureq *ureq;\n\tint req_len;\n \tstruct qeth_arp_query_info qinfo = {0, };\n \tint rc = 0;\n\tQETH_CARD_TEXT(card, 3, \"snmpcmd\");\n\tif (card->info.guestlan)\n\t\treturn -EOPNOTSUPP;\n\tif ((!qeth_adp_supported(card, IPA_SETADP_SET_SNMP_CONTROL)) &&\n\t    (!card->options.layer2)) {\n\t\treturn -EOPNOTSUPP;\n\t}\n \tif (copy_from_user(&req_len, udata + sizeof(int), sizeof(int)))\n \t\treturn -EFAULT;\n \tureq = memdup_user(udata, req_len + sizeof(struct qeth_snmp_ureq_hdr));\n \tif (IS_ERR(ureq)) {\n \t\tQETH_CARD_TEXT(card, 2, \"snmpnome\");\n\t\treturn PTR_ERR(ureq);\n\t}\n\tqinfo.udata_len = ureq->hdr.data_len;\n\tqinfo.udata = kzalloc(qinfo.udata_len, GFP_KERNEL);\n\tif (!qinfo.udata) {\n\t\tkfree(ureq);\n\t\treturn -ENOMEM;\n\t}\n\tqinfo.udata_offset = sizeof(struct qeth_snmp_ureq_hdr);\n\tiob = qeth_get_adapter_cmd(card, IPA_SETADP_SET_SNMP_CONTROL,\n\t\t\t\t   QETH_SNMP_SETADP_CMDLENGTH + req_len);\n\tcmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\n\tmemcpy(&cmd->data.setadapterparms.data.snmp, &ureq->cmd, req_len);\n\trc = qeth_send_ipa_snmp_cmd(card, iob, QETH_SETADP_BASE_LEN + req_len,\n\t\t\t\t    qeth_snmp_command_cb, (void *)&qinfo);\n\tif (rc)\n\t\tQETH_DBF_MESSAGE(2, \"SNMP command failed on %s: (0x%x)\\n\",\n\t\t\t   QETH_CARD_IFNAME(card), rc);\n\telse {\n\t\tif (copy_to_user(udata, qinfo.udata, qinfo.udata_len))\n\t\t\trc = -EFAULT;\n\t}\n\tkfree(ureq);\n\tkfree(qinfo.udata);\n\treturn rc;\n}", "target": 1}
{"code": "inline int ComputeOutSize(TfLitePadding padding, int image_size,\n                          int filter_size, int stride, int dilation_rate = 1) {\n  int effective_filter_size = (filter_size - 1) * dilation_rate + 1;\n  switch (padding) {\n    case kTfLitePaddingSame:\n      return (image_size + stride - 1) / stride;\n    case kTfLitePaddingValid:\n      return (image_size + stride - effective_filter_size) / stride;\n    default:\n      return 0;\n  }\n}", "target": 1}
{"code": "static void gic_dist_writel(void *opaque, hwaddr offset,\n                            uint32_t value, MemTxAttrs attrs)\n{\n    GICState *s = (GICState *)opaque;\n    if (offset == 0xf00) {\n        int cpu;\n        int irq;\n        int mask;\n        int target_cpu;\n        cpu = gic_get_current_cpu(s);\n        irq = value & 0x3ff;\n        switch ((value >> 24) & 3) {\n        case 0:\n            mask = (value >> 16) & ALL_CPU_MASK;\n            break;\n        case 1:\n            mask = ALL_CPU_MASK ^ (1 << cpu);\n            break;\n        case 2:\n            mask = 1 << cpu;\n            break;\n        default:\n            DPRINTF(\"Bad Soft Int target filter\\n\");\n            mask = ALL_CPU_MASK;\n            break;\n        }\n        GIC_DIST_SET_PENDING(irq, mask);\n        target_cpu = ctz32(mask);\n        while (target_cpu < GIC_NCPU) {\n            s->sgi_pending[irq][target_cpu] |= (1 << cpu);\n            mask &= ~(1 << target_cpu);\n            target_cpu = ctz32(mask);\n        }\n        gic_update(s);\n        return;\n    }\n    gic_dist_writew(opaque, offset, value & 0xffff, attrs);\n    gic_dist_writew(opaque, offset + 2, value >> 16, attrs);\n}", "target": 1}
{"code": "status_t MediaPlayerService::Client::setNextPlayer(const sp<IMediaPlayer>& player) {\n     ALOGV(\"setNextPlayer\");\n     Mutex::Autolock l(mLock);\n     sp<Client> c = static_cast<Client*>(player.get());\n     mNextClient = c;\n     if (c != NULL) {\n if (mAudioOutput != NULL) {\n            mAudioOutput->setNextOutput(c->mAudioOutput);\n } else if ((mPlayer != NULL) && !mPlayer->hardwareOutput()) {\n            ALOGE(\"no current audio output\");\n }\n if ((mPlayer != NULL) && (mNextClient->getPlayer() != NULL)) {\n            mPlayer->setNextPlayer(mNextClient->getPlayer());\n }\n }\n return OK;\n}", "target": 1}
{"code": "static __inline__ void scm_set_cred(struct scm_cookie *scm,\n\t\t\t\t    struct pid *pid, const struct cred *cred)\n{\n\tscm->pid  = get_pid(pid);\n\tscm->cred = cred ? get_cred(cred) : NULL;\n\tscm->creds.pid = pid_vnr(pid);\n\tscm->creds.uid = cred ? cred->euid : INVALID_UID;\n\tscm->creds.gid = cred ? cred->egid : INVALID_GID;\n}", "target": 1}
{"code": "static int asf_read_marker(AVFormatContext *s, int64_t size)\n{\n    AVIOContext *pb = s->pb;\n    ASFContext *asf = s->priv_data;\n    int i, count, name_len, ret;\n    char name[1024];\n    avio_rl64(pb);            \n    avio_rl64(pb);            \n     count = avio_rl32(pb);    \n     avio_rl16(pb);            \n     name_len = avio_rl16(pb); \n    for (i = 0; i < name_len; i++)\n        avio_r8(pb); \n     for (i = 0; i < count; i++) {\n         int64_t pres_time;\n         int name_len;\n         avio_rl64(pb);             \n         pres_time = avio_rl64(pb); \n         pres_time -= asf->hdr.preroll * 10000;\n        avio_rl16(pb);             \n        avio_rl32(pb);             \n        avio_rl32(pb);             \n        name_len = avio_rl32(pb);  \n        if ((ret = avio_get_str16le(pb, name_len * 2, name,\n                                    sizeof(name))) < name_len)\n            avio_skip(pb, name_len - ret);\n        avpriv_new_chapter(s, i, (AVRational) { 1, 10000000 }, pres_time,\n                           AV_NOPTS_VALUE, name);\n    }\n    return 0;\n}", "target": 1}
{"code": "static MagickBooleanType IsWEBPImageLossless(const unsigned char *stream,\n  const size_t length)\n{\n#define VP8_CHUNK_INDEX  15\n#define LOSSLESS_FLAG  'L'\n#define EXTENDED_HEADER  'X'\n#define VP8_CHUNK_HEADER  \"VP8\"\n#define VP8_CHUNK_HEADER_SIZE  3\n#define RIFF_HEADER_SIZE  12\n#define VP8X_CHUNK_SIZE  10\n#define TAG_SIZE  4\n#define CHUNK_SIZE_BYTES  4\n#define CHUNK_HEADER_SIZE  8\n#define MAX_CHUNK_PAYLOAD  (~0U-CHUNK_HEADER_SIZE-1)\n  ssize_t\n    offset;\n  if (stream[VP8_CHUNK_INDEX] != EXTENDED_HEADER)\n    return(stream[VP8_CHUNK_INDEX] == LOSSLESS_FLAG ? MagickTrue : MagickFalse);\n  offset=RIFF_HEADER_SIZE+TAG_SIZE+CHUNK_SIZE_BYTES+VP8X_CHUNK_SIZE;\n  while (offset <= (ssize_t) (length-TAG_SIZE))\n  {\n    uint32_t\n      chunk_size,\n      chunk_size_pad;\n    chunk_size=ReadWebPLSBWord(stream+offset+TAG_SIZE);\n    if (chunk_size > MAX_CHUNK_PAYLOAD)\n      break;\n    chunk_size_pad=(CHUNK_HEADER_SIZE+chunk_size+1) & ~1;\n    if (memcmp(stream+offset,VP8_CHUNK_HEADER,VP8_CHUNK_HEADER_SIZE) == 0)\n      return(*(stream+offset+VP8_CHUNK_HEADER_SIZE) == LOSSLESS_FLAG ?\n        MagickTrue : MagickFalse);\n    offset+=chunk_size_pad;\n  }\n  return(MagickFalse);\n}", "target": 1}
{"code": "compile_string_node(Node* node, regex_t* reg)\n{\n  int r, len, prev_len, slen, ambig;\n  OnigEncoding enc = reg->enc;\n  UChar *p, *prev, *end;\n  StrNode* sn;\n  sn = NSTR(node);\n  if (sn->end <= sn->s)\n    return 0;\n  end = sn->end;\n  ambig = NSTRING_IS_AMBIG(node);\n  p = prev = sn->s;\n  prev_len = enclen(enc, p);\n  p += prev_len;\n  slen = 1;\n  for (; p < end; ) {\n    len = enclen(enc, p);\n    if (len == prev_len) {\n      slen++;\n    }\n    else {\n      r = add_compile_string(prev, prev_len, slen, reg, ambig);\n      if (r) return r;\n      prev  = p;\n      slen  = 1;\n      prev_len = len;\n    }\n    p += len;\n  }\n  return add_compile_string(prev, prev_len, slen, reg, ambig);\n}", "target": 1}
{"code": "INST_HANDLER (cpse) {\t\n\tint r = (buf[0] & 0xf) | ((buf[1] & 0x2) << 3);\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tRAnalOp next_op;\n\tavr_op_analyze (anal,\n\t\t\t&next_op,\n\t\t\top->addr + op->size, buf + op->size, len - op->size,\n\t\t\tcpu);\n\tr_strbuf_fini (&next_op.esil);\n\top->jump = op->addr + next_op.size + 2;\n\top->cycles = 1;\t\n\tESIL_A (\"r%d,r%d,^,!,\", r, d);\t\t\t\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t\n}", "target": 1}
{"code": "struct bpf_map *bpf_map_meta_alloc(int inner_map_ufd)\n{\n\tstruct bpf_map *inner_map, *inner_map_meta;\n\tstruct fd f;\n\tf = fdget(inner_map_ufd);\n\tinner_map = __bpf_map_get(f);\n\tif (IS_ERR(inner_map))\n\t\treturn inner_map;\n\tif (inner_map->map_type == BPF_MAP_TYPE_PROG_ARRAY ||\n\t    inner_map->map_type == BPF_MAP_TYPE_CGROUP_STORAGE ||\n\t    inner_map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-ENOTSUPP);\n\t}\n\tif (inner_map->inner_map_meta) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tinner_map_meta = kzalloc(sizeof(*inner_map_meta), GFP_USER);\n\tif (!inner_map_meta) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tinner_map_meta->map_type = inner_map->map_type;\n\tinner_map_meta->key_size = inner_map->key_size;\n\tinner_map_meta->value_size = inner_map->value_size;\n\tinner_map_meta->map_flags = inner_map->map_flags;\n\tinner_map_meta->ops = inner_map->ops;\n\tinner_map_meta->max_entries = inner_map->max_entries;\n\tfdput(f);\n\treturn inner_map_meta;\n}", "target": 1}
{"code": "AcpiDsCreateOperands (\n    ACPI_WALK_STATE         *WalkState,\n    ACPI_PARSE_OBJECT       *FirstArg)\n{\n    ACPI_STATUS             Status = AE_OK;\n    ACPI_PARSE_OBJECT       *Arg;\n     ACPI_PARSE_OBJECT       *Arguments[ACPI_OBJ_NUM_OPERANDS];\n     UINT32                  ArgCount = 0;\n     UINT32                  Index = WalkState->NumOperands;\n     UINT32                  i;\n    ACPI_FUNCTION_TRACE_PTR (DsCreateOperands, FirstArg);\n    Arg = FirstArg;\n    while (Arg)\n    {\n        if (Index >= ACPI_OBJ_NUM_OPERANDS)\n        {\n            return_ACPI_STATUS (AE_BAD_DATA);\n        }\n        Arguments[Index] = Arg;\n        WalkState->Operands [Index] = NULL;\n        Arg = Arg->Common.Next;\n        ArgCount++;\n        Index++;\n    }\n    ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,\n        \"NumOperands %d, ArgCount %d, Index %d\\n\",\n        WalkState->NumOperands, ArgCount, Index));\n     Index--;\n     for (i = 0; i < ArgCount; i++)\n     {\n        Arg = Arguments[Index];\n        WalkState->OperandIndex = (UINT8) Index;\n        Status = AcpiDsCreateOperand (WalkState, Arg, Index);\n        if (ACPI_FAILURE (Status))\n        {\n            goto Cleanup;\n        }\n        ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,\n            \"Created Arg #%u (%p) %u args total\\n\",\n            Index, Arg, ArgCount));\n        Index--;\n    }\n    return_ACPI_STATUS (Status);\nCleanup:\n    AcpiDsObjStackPopAndDelete (ArgCount, WalkState);\n     ACPI_EXCEPTION ((AE_INFO, Status, \"While creating Arg %u\", Index));\n     return_ACPI_STATUS (Status);\n}", "target": 1}
{"code": "static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,\n\t\t\t\tsize_t msg_len)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tint err = 0;\n\tlong current_timeo = *timeo_p;\n\tDEFINE_WAIT(wait);\n\tpr_debug(\"%s: asoc:%p, timeo:%ld, msg_len:%zu\\n\", __func__, asoc,\n\t\t *timeo_p, msg_len);\n\tsctp_association_hold(asoc);\n\tfor (;;) {\n\t\tprepare_to_wait_exclusive(&asoc->wait, &wait,\n\t\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (!*timeo_p)\n\t\t\tgoto do_nonblock;\n\t\tif (sk->sk_err || asoc->state >= SCTP_STATE_SHUTDOWN_PENDING ||\n\t\t    asoc->base.dead)\n\t\t\tgoto do_error;\n\t\tif (signal_pending(current))\n\t\t\tgoto do_interrupted;\n\t\tif (msg_len <= sctp_wspace(asoc))\n\t\t\tbreak;\n \t\trelease_sock(sk);\n \t\tcurrent_timeo = schedule_timeout(current_timeo);\n\t\tBUG_ON(sk != asoc->base.sk);\n \t\tlock_sock(sk);\n \t\t*timeo_p = current_timeo;\n\t}\nout:\n\tfinish_wait(&asoc->wait, &wait);\n\tsctp_association_put(asoc);\n\treturn err;\ndo_error:\n\terr = -EPIPE;\n\tgoto out;\ndo_interrupted:\n\terr = sock_intr_errno(*timeo_p);\n\tgoto out;\ndo_nonblock:\n\terr = -EAGAIN;\n\tgoto out;\n}", "target": 1}
{"code": "static int local_name_to_path(FsContext *ctx, V9fsPath *dir_path,\n                              const char *name, V9fsPath *target)\n {\n     if (dir_path) {\n         v9fs_path_sprintf(target, \"%s/%s\", dir_path->data, name);\n    } else {\n         v9fs_path_sprintf(target, \"%s\", name);\n     }\n     return 0;\n }", "target": 1}
{"code": "void update_process_times(int user_tick)\n{\n\tstruct task_struct *p = current;\n\taccount_process_tick(p, user_tick);\n\trun_local_timers();\n\trcu_sched_clock_irq(user_tick);\n#ifdef CONFIG_IRQ_WORK\n\tif (in_irq())\n\t\tirq_work_tick();\n#endif\n\tscheduler_tick();\n\tif (IS_ENABLED(CONFIG_POSIX_TIMERS))\n\t\trun_posix_cpu_timers();\n}", "target": 1}
{"code": " static OPJ_BOOL bmp_read_rle4_data(FILE* IN, OPJ_UINT8* pData,\n                                    OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n {\n    OPJ_UINT32 x, y;\n     OPJ_UINT8 *pix;\n     const OPJ_UINT8 *beyond;\n     beyond = pData + stride * height;\n     pix = pData;\n    x = y = 0U;\n     while (y < height) {\n         int c = getc(IN);\n         if (c == EOF) {\n            break;\n        }\n        if (c) { \n            int j;\n            OPJ_UINT8 c1 = (OPJ_UINT8)getc(IN);\n             for (j = 0; (j < c) && (x < width) &&\n                     ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                 *pix = (OPJ_UINT8)((j & 1) ? (c1 & 0x0fU) : ((c1 >> 4) & 0x0fU));\n             }\n         } else { \n             c = getc(IN);\n            if (c == EOF) {\n                break;\n            }\n            if (c == 0x00) { \n                x = 0;\n                y++;\n                pix = pData + y * stride;\n            } else if (c == 0x01) { \n                break;\n            } else if (c == 0x02) { \n                c = getc(IN);\n                x += (OPJ_UINT32)c;\n                c = getc(IN);\n                y += (OPJ_UINT32)c;\n                pix = pData + y * stride + x;\n            } else { \n                int j;\n                OPJ_UINT8 c1 = 0U;\n                for (j = 0; (j < c) && (x < width) &&\n                        ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                    if ((j & 1) == 0) {\n                         c1 = (OPJ_UINT8)getc(IN);\n                     }\n                     *pix = (OPJ_UINT8)((j & 1) ? (c1 & 0x0fU) : ((c1 >> 4) & 0x0fU));\n                 }\n                 if (((c & 3) == 1) || ((c & 3) == 2)) { \n                     getc(IN);\n                 }\n             }\n         }\n     }  \n     return OPJ_TRUE;\n }", "target": 1}
{"code": "void yajl_string_decode(yajl_buf buf, const unsigned char * str,\n                        unsigned int len)\n{\n    unsigned int beg = 0;\n    unsigned int end = 0;    \n    while (end < len) {\n        if (str[end] == '\\\\') {\n            char utf8Buf[5];\n            const char * unescaped = \"?\";\n            yajl_buf_append(buf, str + beg, end - beg);\n            switch (str[++end]) {\n                case 'r': unescaped = \"\\r\"; break;\n                case 'n': unescaped = \"\\n\"; break;\n                case '\\\\': unescaped = \"\\\\\"; break;\n                case '/': unescaped = \"/\"; break;\n                case '\"': unescaped = \"\\\"\"; break;\n                case 'f': unescaped = \"\\f\"; break;\n                case 'b': unescaped = \"\\b\"; break;\n                case 't': unescaped = \"\\t\"; break;\n                case 'u': {\n                    unsigned int codepoint = 0;\n                    hexToDigit(&codepoint, str + ++end);\n                    end+=3;\n                    if ((codepoint & 0xFC00) == 0xD800) {\n                        end++;\n                        if (str[end] == '\\\\' && str[end + 1] == 'u') {\n                            unsigned int surrogate = 0;\n                            hexToDigit(&surrogate, str + end + 2);\n                            codepoint =\n                                (((codepoint & 0x3F) << 10) | \n                                 ((((codepoint >> 6) & 0xF) + 1) << 16) | \n                                 (surrogate & 0x3FF));\n                            end += 5;\n                        } else {\n                            unescaped = \"?\";\n                            break;\n                        }\n                    }\n                    Utf32toUtf8(codepoint, utf8Buf);\n                    unescaped = utf8Buf;\n                    if (codepoint == 0) {\n                        yajl_buf_append(buf, unescaped, 1);\n                        beg = ++end;\n                        continue;\n                    }\n                    break;\n                }\n                default:\n                    assert(\"this should never happen\" == NULL);\n            }\n            yajl_buf_append(buf, unescaped, (unsigned int)strlen(unescaped));\n            beg = ++end;\n        } else {\n            end++;\n        }\n    }\n    yajl_buf_append(buf, str + beg, end - beg);\n}", "target": 1}
{"code": "static int vmci_transport_dgram_dequeue(struct kiocb *kiocb,\n\t\t\t\t\tstruct vsock_sock *vsk,\n\t\t\t\t\tstruct msghdr *msg, size_t len,\n\t\t\t\t\tint flags)\n{\n\tint err;\n\tint noblock;\n\tstruct vmci_datagram *dg;\n\tsize_t payload_len;\n\tstruct sk_buff *skb;\n\tnoblock = flags & MSG_DONTWAIT;\n \tif (flags & MSG_OOB || flags & MSG_ERRQUEUE)\n \t\treturn -EOPNOTSUPP;\n \terr = 0;\n \tskb = skb_recv_datagram(&vsk->sk, flags, noblock, &err);\n\tif (err)\n\t\treturn err;\n\tif (!skb)\n\t\treturn -EAGAIN;\n\tdg = (struct vmci_datagram *)skb->data;\n\tif (!dg)\n\t\tgoto out;\n\tpayload_len = dg->payload_size;\n\tif (payload_len != skb->len - sizeof(*dg)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (payload_len > len) {\n\t\tpayload_len = len;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\terr = skb_copy_datagram_iovec(skb, sizeof(*dg), msg->msg_iov,\n\t\tpayload_len);\n \tif (err)\n \t\tgoto out;\n\tmsg->msg_namelen = 0;\n \tif (msg->msg_name) {\n \t\tstruct sockaddr_vm *vm_addr;\n\t\tvm_addr = (struct sockaddr_vm *)msg->msg_name;\n\t\tvsock_addr_init(vm_addr, dg->src.context, dg->src.resource);\n\t\tmsg->msg_namelen = sizeof(*vm_addr);\n\t}\n\terr = payload_len;\nout:\n\tskb_free_datagram(&vsk->sk, skb);\n\treturn err;\n}", "target": 1}
{"code": "static x3f_huffnode_t *new_node(x3f_hufftree_t *tree)\n{\n  x3f_huffnode_t *t = &tree->nodes[tree->free_node_index];\n  t->branch[0] = NULL;\n  t->branch[1] = NULL;\n  t->leaf = UNDEFINED_LEAF;\n  tree->free_node_index++;\n  return t;\n}", "target": 1}
{"code": "bool PDFDoc::setup(const GooString *ownerPassword, const GooString *userPassword) {\n  pdfdocLocker();\n  if (str->getLength() <= 0)\n  {\n    error(errSyntaxError, -1, \"Document stream is empty\");\n    return false;\n  }\n  str->setPos(0, -1);\n  if (str->getPos() < 0)\n  {\n    error(errSyntaxError, -1, \"Document base stream is not seekable\");\n    return false;\n  }\n  str->reset();\n  checkHeader();\n  bool wasReconstructed = false;\n  xref = new XRef(str, getStartXRef(), getMainXRefEntriesOffset(), &wasReconstructed);\n  if (!xref->isOk()) {\n    if (wasReconstructed) {\n      delete xref;\n      startXRefPos = -1;\n      xref = new XRef(str, getStartXRef(true), getMainXRefEntriesOffset(true), &wasReconstructed);\n    }\n    if (!xref->isOk()) {\n      error(errSyntaxError, -1, \"Couldn't read xref table\");\n      errCode = xref->getErrorCode();\n      return false;\n    }\n  }\n  if (!checkEncryption(ownerPassword, userPassword)) {\n    errCode = errEncrypted;\n    return false;\n  }\n  catalog = new Catalog(this);\n  if (catalog && !catalog->isOk()) {\n    if (!wasReconstructed)\n    {\n      delete catalog;\n      delete xref;\n      xref = new XRef(str, 0, 0, nullptr, true);\n      catalog = new Catalog(this);\n    }\n    if (catalog && !catalog->isOk()) {\n      error(errSyntaxError, -1, \"Couldn't read page catalog\");\n      errCode = errBadCatalog;\n      return false;\n    }\n  }\n  extractPDFSubtype();\n  return true;\n}", "target": 1}
{"code": "int cap_bprm_set_creds(struct linux_binprm *bprm)\n{\n\tconst struct cred *old = current_cred();\n\tstruct cred *new = bprm->cred;\n\tbool effective, has_cap = false;\n\tint ret;\n\teffective = false;\n\tret = get_file_caps(bprm, &effective, &has_cap);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!issecure(SECURE_NOROOT)) {\n\t\tif (has_cap && new->uid != 0 && new->euid == 0) {\n\t\t\twarn_setuid_and_fcaps_mixed(bprm->filename);\n\t\t\tgoto skip;\n\t\t}\n\t\tif (new->euid == 0 || new->uid == 0) {\n\t\t\tnew->cap_permitted = cap_combine(old->cap_bset,\n\t\t\t\t\t\t\t old->cap_inheritable);\n\t\t}\n\t\tif (new->euid == 0)\n\t\t\teffective = true;\n \t}\n skip:\n\tif ((new->euid != old->uid ||\n\t     new->egid != old->gid ||\n\t     !cap_issubset(new->cap_permitted, old->cap_permitted)) &&\n\t    bprm->unsafe & ~LSM_UNSAFE_PTRACE_CAP) {\n\t\tif (!capable(CAP_SETUID)) {\n\t\t\tnew->euid = new->uid;\n\t\t\tnew->egid = new->gid;\n\t\t}\n\t\tnew->cap_permitted = cap_intersect(new->cap_permitted,\n\t\t\t\t\t\t   old->cap_permitted);\n\t}\n\tnew->suid = new->fsuid = new->euid;\n\tnew->sgid = new->fsgid = new->egid;\n\tif (effective)\n\t\tnew->cap_effective = new->cap_permitted;\n\telse\n\t\tcap_clear(new->cap_effective);\n\tbprm->cap_effective = effective;\n\tif (!cap_isclear(new->cap_effective)) {\n\t\tif (!cap_issubset(CAP_FULL_SET, new->cap_effective) ||\n\t\t    new->euid != 0 || new->uid != 0 ||\n\t\t    issecure(SECURE_NOROOT)) {\n\t\t\tret = audit_log_bprm_fcaps(bprm, new, old);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\tnew->securebits &= ~issecure_mask(SECURE_KEEP_CAPS);\n\treturn 0;\n}", "target": 1}
{"code": "ZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)\n{\n \tGC_REFCOUNT(ht) = 1;\n \tGC_TYPE_INFO(ht) = IS_ARRAY;\n \tht->u.flags = (persistent ? HASH_FLAG_PERSISTENT : 0) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;\n\tht->nTableSize = zend_hash_check_size(nSize);\n \tht->nTableMask = HT_MIN_MASK;\n \tHT_SET_DATA_ADDR(ht, &uninitialized_bucket);\n \tht->nNumUsed = 0;\n \tht->nNumOfElements = 0;\n \tht->nInternalPointer = HT_INVALID_IDX;\n \tht->nNextFreeElement = 0;\n \tht->pDestructor = pDestructor;\n }", "target": 1}
{"code": "static plist_t parse_string_node(const char **bnode, uint64_t size)\n{\n    plist_data_t data = plist_new_plist_data();\n     data->type = PLIST_STRING;\n     data->strval = (char *) malloc(sizeof(char) * (size + 1));\n     memcpy(data->strval, *bnode, size);\n     data->strval[size] = '\\0';\n     data->length = strlen(data->strval);\n    return node_create(NULL, data);\n}", "target": 1}
{"code": "void MidiManagerUsb::DispatchSendMidiData(MidiManagerClient* client,\n                                           uint32_t port_index,\n                                           const std::vector<uint8>& data,\n                                           double timestamp) {\n  DCHECK_LT(port_index, output_streams_.size());\n   output_streams_[port_index]->Send(data);\n   client->AccumulateMidiBytesSent(data.size());\n }", "target": 1}
{"code": "char *rfbProcessFileTransferReadBuffer(rfbClientPtr cl, uint32_t length)\n{\n    char *buffer=NULL;\n    int   n=0;\n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, NULL);\n    if (length>0) {\n        buffer=malloc((uint64_t)length+1);\n        if (buffer!=NULL) {\n            if ((n = rfbReadExact(cl, (char *)buffer, length)) <= 0) {\n                if (n != 0)\n                    rfbLogPerror(\"rfbProcessFileTransferReadBuffer: read\");\n                rfbCloseClient(cl);\n                if (buffer!=NULL) free(buffer);\n                return NULL;\n            }\n            buffer[length]=0;\n        }\n    }\n    return buffer;\n}", "target": 1}
{"code": "xmlParseNCNameComplex(xmlParserCtxtPtr ctxt) {\n    int len = 0, l;\n    int c;\n    int count = 0;\n    const xmlChar *end; \n#ifdef DEBUG\n    nbParseNCNameComplex++;\n#endif\n    GROW;\n    end = ctxt->input->cur;\n    c = CUR_CHAR(l);\n    if ((c == ' ') || (c == '>') || (c == '/') || \n\t(!xmlIsNameStartChar(ctxt, c) || (c == ':'))) {\n\treturn(NULL);\n    }\n    while ((c != ' ') && (c != '>') && (c != '/') && \n\t   (xmlIsNameChar(ctxt, c) && (c != ':'))) {\n\tif (count++ > XML_PARSER_CHUNK_SIZE) {\n            if ((len > XML_MAX_NAME_LENGTH) &&\n                ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n                xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, \"NCName\");\n                return(NULL);\n            }\n\t    count = 0;\n\t    GROW;\n            if (ctxt->instate == XML_PARSER_EOF)\n                return(NULL);\n\t}\n\tlen += l;\n\tNEXTL(l);\n\tend = ctxt->input->cur;\n\tc = CUR_CHAR(l);\n\tif (c == 0) {\n\t    count = 0;\n\t    ctxt->input->cur -= l;\n\t    GROW;\n\t    ctxt->input->cur += l;\n            if (ctxt->instate == XML_PARSER_EOF)\n                return(NULL);\n\t    end = ctxt->input->cur;\n\t    c = CUR_CHAR(l);\n\t}\n    }\n    if ((len > XML_MAX_NAME_LENGTH) &&\n        ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n        xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, \"NCName\");\n        return(NULL);\n    }\n    return(xmlDictLookup(ctxt->dict, end - len, len));\n}", "target": 1}
{"code": "static int komeda_wb_connector_add(struct komeda_kms_dev *kms,\n\t\t\t\t   struct komeda_crtc *kcrtc)\n{\n\tstruct komeda_dev *mdev = kms->base.dev_private;\n\tstruct komeda_wb_connector *kwb_conn;\n\tstruct drm_writeback_connector *wb_conn;\n\tu32 *formats, n_formats = 0;\n\tint err;\n\tif (!kcrtc->master->wb_layer)\n\t\treturn 0;\n\tkwb_conn = kzalloc(sizeof(*kwb_conn), GFP_KERNEL);\n\tif (!kwb_conn)\n\t\treturn -ENOMEM;\n\tkwb_conn->wb_layer = kcrtc->master->wb_layer;\n\twb_conn = &kwb_conn->base;\n\twb_conn->encoder.possible_crtcs = BIT(drm_crtc_index(&kcrtc->base));\n\tformats = komeda_get_layer_fourcc_list(&mdev->fmt_tbl,\n\t\t\t\t\t       kwb_conn->wb_layer->layer_type,\n\t\t\t\t\t       &n_formats);\n\terr = drm_writeback_connector_init(&kms->base, wb_conn,\n\t\t\t\t\t   &komeda_wb_connector_funcs,\n\t\t\t\t\t   &komeda_wb_encoder_helper_funcs,\n\t\t\t\t\t   formats, n_formats);\n\tkomeda_put_fourcc_list(formats);\n\tif (err)\n\t\treturn err;\n\tdrm_connector_helper_add(&wb_conn->base, &komeda_wb_conn_helper_funcs);\n\tkcrtc->wb_conn = kwb_conn;\n\treturn 0;\n}", "target": 1}
{"code": "static u32 apic_get_tmcct(struct kvm_lapic *apic)\n{\n\tktime_t remaining;\n\ts64 ns;\n\tu32 tmcct;\n \tASSERT(apic != NULL);\n\tif (kvm_apic_get_reg(apic, APIC_TMICT) == 0)\n \t\treturn 0;\n \tremaining = hrtimer_get_remaining(&apic->lapic_timer.timer);\n\tif (ktime_to_ns(remaining) < 0)\n\t\tremaining = ktime_set(0, 0);\n\tns = mod_64(ktime_to_ns(remaining), apic->lapic_timer.period);\n\ttmcct = div64_u64(ns,\n\t\t\t (APIC_BUS_CYCLE_NS * apic->divide_count));\n\treturn tmcct;\n}", "target": 1}
{"code": "static int atalk_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n \t\t\t size_t size, int flags)\n {\n \tstruct sock *sk = sock->sk;\n\tstruct sockaddr_at *sat = (struct sockaddr_at *)msg->msg_name;\n \tstruct ddpehdr *ddp;\n \tint copied = 0;\n \tint offset = 0;\n\tint err = 0;\n\tstruct sk_buff *skb;\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tlock_sock(sk);\n\tif (!skb)\n\t\tgoto out;\n\tddp = ddp_hdr(skb);\n\tcopied = ntohs(ddp->deh_len_hops) & 1023;\n\tif (sk->sk_type != SOCK_RAW) {\n\t\toffset = sizeof(*ddp);\n\t\tcopied -= offset;\n\t}\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n \t}\n \terr = skb_copy_datagram_iovec(skb, offset, msg->msg_iov, copied);\n\tif (!err) {\n\t\tif (sat) {\n\t\t\tsat->sat_family      = AF_APPLETALK;\n\t\t\tsat->sat_port        = ddp->deh_sport;\n\t\t\tsat->sat_addr.s_node = ddp->deh_snode;\n\t\t\tsat->sat_addr.s_net  = ddp->deh_snet;\n\t\t}\n\t\tmsg->msg_namelen = sizeof(*sat);\n \t}\n \tskb_free_datagram(sk, skb);\t\nout:\n\trelease_sock(sk);\n\treturn err ? : copied;\n}", "target": 1}
{"code": "check_shellsize(void)\n{\n    if (Rows < min_rows())\t\n\tRows = min_rows();\n    limit_screen_size();\n}", "target": 1}
{"code": "static int rndis_set_response(struct rndis_params *params,\n\t\t\t      rndis_set_msg_type *buf)\n{\n\tu32 BufLength, BufOffset;\n\trndis_set_cmplt_type *resp;\n\trndis_resp_t *r;\n\tr = rndis_add_response(params, sizeof(rndis_set_cmplt_type));\n\tif (!r)\n\t\treturn -ENOMEM;\n\tresp = (rndis_set_cmplt_type *)r->buf;\n\tBufLength = le32_to_cpu(buf->InformationBufferLength);\n\tBufOffset = le32_to_cpu(buf->InformationBufferOffset);\n#ifdef\tVERBOSE_DEBUG\n\tpr_debug(\"%s: Length: %d\\n\", __func__, BufLength);\n\tpr_debug(\"%s: Offset: %d\\n\", __func__, BufOffset);\n\tpr_debug(\"%s: InfoBuffer: \", __func__);\n\tfor (i = 0; i < BufLength; i++) {\n\t\tpr_debug(\"%02x \", *(((u8 *) buf) + i + 8 + BufOffset));\n\t}\n\tpr_debug(\"\\n\");\n#endif\n\tresp->MessageType = cpu_to_le32(RNDIS_MSG_SET_C);\n\tresp->MessageLength = cpu_to_le32(16);\n\tresp->RequestID = buf->RequestID; \n\tif (gen_ndis_set_resp(params, le32_to_cpu(buf->OID),\n\t\t\t((u8 *)buf) + 8 + BufOffset, BufLength, r))\n\t\tresp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);\n\telse\n\t\tresp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n\tparams->resp_avail(params->v);\n\treturn 0;\n}", "target": 1}
{"code": "static long madvise_willneed(struct vm_area_struct *vma,\n\t\t\t     struct vm_area_struct **prev,\n\t\t\t     unsigned long start, unsigned long end)\n {\n \tstruct file *file = vma->vm_file;\n #ifdef CONFIG_SWAP\n \tif (!file) {\n\t\t*prev = vma;\n \t\tforce_swapin_readahead(vma, start, end);\n \t\treturn 0;\n \t}\n \tif (shmem_mapping(file->f_mapping)) {\n\t\t*prev = vma;\n \t\tforce_shm_swapin_readahead(vma, start, end,\n \t\t\t\t\tfile->f_mapping);\n \t\treturn 0;\n\t}\n#else\n\tif (!file)\n\t\treturn -EBADF;\n#endif\n\tif (IS_DAX(file_inode(file))) {\n \t\treturn 0;\n \t}\n\t*prev = vma;\n \tstart = ((start - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n \tif (end > vma->vm_end)\n \t\tend = vma->vm_end;\n\tend = ((end - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\tforce_page_cache_readahead(file->f_mapping, file, start, end - start);\n\treturn 0;\n}", "target": 1}
{"code": "parse_device(dev_t *pdev, struct archive *a, char *val)\n{\n#define MAX_PACK_ARGS 3\n\tunsigned long numbers[MAX_PACK_ARGS];\n\tchar *p, *dev;\n\tint argc;\n\tpack_t *pack;\n\tdev_t result;\n\tconst char *error = NULL;\n\tmemset(pdev, 0, sizeof(*pdev));\n\tif ((dev = strchr(val, ',')) != NULL) {\n\t\t*dev++ = '\\0';\n\t\tif ((pack = pack_find(val)) == NULL) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Unknown format `%s'\", val);\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t\targc = 0;\n\t\twhile ((p = la_strsep(&dev, \",\")) != NULL) {\n\t\t\tif (*p == '\\0') {\n\t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n \t\t\t\t    \"Missing number\");\n \t\t\t\treturn ARCHIVE_WARN;\n \t\t\t}\n\t\t\tnumbers[argc++] = (unsigned long)mtree_atol(&p);\n\t\t\tif (argc > MAX_PACK_ARGS) {\n \t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n \t\t\t\t    \"Too many arguments\");\n \t\t\t\treturn ARCHIVE_WARN;\n \t\t\t}\n \t\t}\n \t\tif (argc < 2) {\n \t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Not enough arguments\");\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t\tresult = (*pack)(argc, numbers, &error);\n\t\tif (error != NULL) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"%s\", error);\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t} else {\n\t\tresult = (dev_t)mtree_atol(&val);\n\t}\n\t*pdev = result;\n\treturn ARCHIVE_OK;\n#undef MAX_PACK_ARGS\n}", "target": 1}
{"code": "mrb_ary_shift_m(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a = mrb_ary_ptr(self);\n  mrb_int len = ARY_LEN(a);\n  mrb_int n;\n  mrb_value val;\n  if (mrb_get_args(mrb, \"|i\", &n) == 0) {\n    return mrb_ary_shift(mrb, self);\n  };\n  ary_modify_check(mrb, a);\n  if (len == 0 || n == 0) return mrb_ary_new(mrb);\n  if (n < 0) mrb_raise(mrb, E_ARGUMENT_ERROR, \"negative array shift\");\n  if (n > len) n = len;\n  val = mrb_ary_new_from_values(mrb, n, ARY_PTR(a));\n  if (ARY_SHARED_P(a)) {\n  L_SHIFT:\n    a->as.heap.ptr+=n;\n    a->as.heap.len-=n;\n    return val;\n  }\n  if (len > ARY_SHIFT_SHARED_MIN) {\n    ary_make_shared(mrb, a);\n    goto L_SHIFT;\n  }\n  else if (len == n) {\n    ARY_SET_LEN(a, 0);\n  }\n  else {\n    mrb_value *ptr = ARY_PTR(a);\n    mrb_int size = len-n;\n    while (size--) {\n      *ptr = *(ptr+n);\n      ++ptr;\n    }\n    ARY_SET_LEN(a, len-n);\n  }\n  return val;\n}", "target": 1}
{"code": "static inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_esn,\n\t\t\t\t\t struct nlattr *rp)\n{\n\tstruct xfrm_replay_state_esn *up;\n\tint ulen;\n\tif (!replay_esn || !rp)\n\t\treturn 0;\n \tup = nla_data(rp);\n \tulen = xfrm_replay_state_esn_len(up);\n\tif (nla_len(rp) < ulen || xfrm_replay_state_esn_len(replay_esn) != ulen)\n \t\treturn -EINVAL;\n \tif (up->replay_window > up->bmp_len * sizeof(__u32) * 8)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "check_offset(char *memory, int total_size, char *name, void *offset, int size)\n{\n\tptrdiff_t need_size = (char *) offset - memory + size;\n\tif (need_size < 0 || need_size > total_size) {\n\t\twarn(_(\"%s: premature end\"), name);\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "Status ValidateInputs(const Tensor *a_indices, const Tensor *a_values,\n                      const Tensor *a_shape, const Tensor *b) {\n  if (!TensorShapeUtils::IsMatrix(a_indices->shape())) {\n    return errors::InvalidArgument(\n        \"Input a_indices should be a matrix but received shape: \",\n        a_indices->shape().DebugString());\n  }\n  if (!TensorShapeUtils::IsVector(a_values->shape()) ||\n      !TensorShapeUtils::IsVector(a_shape->shape())) {\n    return errors::InvalidArgument(\n        \"Inputs a_values and a_shape should be vectors \"\n        \"but received shapes: \",\n        a_values->shape().DebugString(), \" and \",\n        a_shape->shape().DebugString());\n  }\n  if (a_shape->NumElements() != b->dims()) {\n    return errors::InvalidArgument(\n        \"Two operands have different ranks; received: \", a_shape->NumElements(),\n        \" and \", b->dims());\n  }\n  const auto a_shape_flat = a_shape->flat<Index>();\n  for (int i = 0; i < b->dims(); ++i) {\n    if (a_shape_flat(i) != b->dim_size(i)) {\n      return errors::InvalidArgument(\n          \"Dimension \", i,\n          \" does not equal (no broadcasting is supported): sparse side \",\n          a_shape_flat(i), \" vs dense side \", b->dim_size(i));\n    }\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "void ArthurOutputDev::drawImage(GfxState *state, Object *ref, Stream *str,\n\t\t\t\tint width, int height,\n\t\t\t\tGfxImageColorMap *colorMap,\n\t\t\t\tint *maskColors, GBool inlineImg)\n{\n  unsigned char *buffer;\n  unsigned int *dest;\n  int x, y;\n  ImageStream *imgStr;\n  Guchar *pix;\n  int i;\n  double *ctm;\n   QMatrix matrix;\n   int is_identity_transform;\n  buffer = (unsigned char *)gmalloc (width * height * 4);\n   imgStr = new ImageStream(str, width,\n\t\t\t   colorMap->getNumPixelComps(),\n\t\t\t   colorMap->getBits());\n  imgStr->reset();\n  is_identity_transform = colorMap->getColorSpace()->getMode() == csDeviceRGB ||\n\t\t  (colorMap->getColorSpace()->getMode() == csICCBased && \n\t\t  ((GfxICCBasedColorSpace*)colorMap->getColorSpace())->getAlt()->getMode() == csDeviceRGB);\n  if (maskColors) {\n    for (y = 0; y < height; y++) {\n      dest = (unsigned int *) (buffer + y * 4 * width);\n      pix = imgStr->getLine();\n      colorMap->getRGBLine (pix, dest, width);\n      for (x = 0; x < width; x++) {\n\tfor (i = 0; i < colorMap->getNumPixelComps(); ++i) {\n\t  if (pix[i] < maskColors[2*i] * 255||\n\t      pix[i] > maskColors[2*i+1] * 255) {\n\t    *dest = *dest | 0xff000000;\n\t    break;\n\t  }\n\t}\n\tpix += colorMap->getNumPixelComps();\n\tdest++;\n      }\n    }\n    m_image = new QImage(buffer, width, height, QImage::Format_ARGB32);\n  }\n  else {\n    for (y = 0; y < height; y++) {\n      dest = (unsigned int *) (buffer + y * 4 * width);\n      pix = imgStr->getLine();\n      colorMap->getRGBLine (pix, dest, width);\n    }\n    m_image = new QImage(buffer, width, height, QImage::Format_RGB32);\n  }\n  if (m_image == NULL || m_image->isNull()) {\n    qDebug() << \"Null image\";\n    delete imgStr;\n    return;\n  }\n  ctm = state->getCTM();\n  matrix.setMatrix(ctm[0] / width, ctm[1] / width, -ctm[2] / height, -ctm[3] / height, ctm[2] + ctm[4], ctm[3] + ctm[5]);\n  m_painter->setMatrix(matrix, true);\n  m_painter->drawImage( QPoint(0,0), *m_image );\n  delete m_image;\n  m_image = 0;\n  free (buffer);\n  delete imgStr;\n}", "target": 1}
{"code": "static void cirrus_invalidate_region(CirrusVGAState * s, int off_begin,\n\t\t\t\t     int off_pitch, int bytesperline,\n\t\t\t\t     int lines)\n{\n    int y;\n    int off_cur;\n    int off_cur_end;\n    for (y = 0; y < lines; y++) {\n\toff_cur = off_begin;\n\toff_cur_end = off_cur + bytesperline;\n\toff_cur &= TARGET_PAGE_MASK;\n\twhile (off_cur < off_cur_end) {\n\t    cpu_physical_memory_set_dirty(s->vram_offset + off_cur);\n\t    off_cur += TARGET_PAGE_SIZE;\n\t}\n\toff_begin += off_pitch;\n    }\n}", "target": 1}
{"code": "_gdata_service_build_session (void)\n{\n\tSoupSession *session = soup_session_sync_new ();\n#ifdef HAVE_GNOME\n\tsoup_session_add_feature_by_type (session, SOUP_TYPE_GNOME_FEATURES_2_26);\n#endif \n\tif (_gdata_service_get_log_level () > GDATA_LOG_MESSAGES) {\n\t\tSoupLoggerLogLevel level;\n\t\tSoupLogger *logger;\n\t\tswitch (_gdata_service_get_log_level ()) {\n\t\t\tcase GDATA_LOG_FULL_UNREDACTED:\n\t\t\tcase GDATA_LOG_FULL:\n\t\t\t\tlevel = SOUP_LOGGER_LOG_BODY;\n\t\t\t\tbreak;\n\t\t\tcase GDATA_LOG_HEADERS:\n\t\t\t\tlevel = SOUP_LOGGER_LOG_HEADERS;\n\t\t\t\tbreak;\n\t\t\tcase GDATA_LOG_MESSAGES:\n\t\t\tcase GDATA_LOG_NONE:\n\t\t\tdefault:\n\t\t\t\tg_assert_not_reached ();\n\t\t}\n\t\tlogger = soup_logger_new (level, -1);\n\t\tsoup_logger_set_printer (logger, (SoupLoggerPrinter) soup_log_printer, NULL, NULL);\n\t\tsoup_session_add_feature (session, SOUP_SESSION_FEATURE (logger));\n\t\tg_object_unref (logger);\n\t}\n\treturn session;\n}", "target": 1}
{"code": "static int aac_sync(uint64_t state, AACAC3ParseContext *hdr_info,\n        int *need_next_header, int *new_frame_start)\n{\n    GetBitContext bits;\n    AACADTSHeaderInfo hdr;\n     int size;\n     union {\n         uint64_t u64;\n        uint8_t  u8[8];\n     } tmp;\n     tmp.u64 = av_be2ne64(state);\n    init_get_bits(&bits, tmp.u8+8-AAC_ADTS_HEADER_SIZE, AAC_ADTS_HEADER_SIZE * 8);\n    if ((size = avpriv_aac_parse_header(&bits, &hdr)) < 0)\n        return 0;\n    *need_next_header = 0;\n    *new_frame_start  = 1;\n    hdr_info->sample_rate = hdr.sample_rate;\n    hdr_info->channels    = ff_mpeg4audio_channels[hdr.chan_config];\n    hdr_info->samples     = hdr.samples;\n    hdr_info->bit_rate    = hdr.bit_rate;\n    return size;\n}", "target": 1}
{"code": "dbus_g_proxy_manager_filter (DBusConnection    *connection,\n                             DBusMessage       *message,\n                             void              *user_data)\n{\n  DBusGProxyManager *manager;\n  if (dbus_message_get_type (message) != DBUS_MESSAGE_TYPE_SIGNAL)\n    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;\n  manager = user_data;\n  dbus_g_proxy_manager_ref (manager);\n  LOCK_MANAGER (manager);\n  if (dbus_message_is_signal (message,\n                              DBUS_INTERFACE_LOCAL,\n                              \"Disconnected\"))\n    {\n      GSList *all;\n      GSList *tmp;\n      all = dbus_g_proxy_manager_list_all (manager);\n      tmp = all;\n      while (tmp != NULL)\n        {\n          DBusGProxy *proxy;\n          proxy = DBUS_G_PROXY (tmp->data);\n          UNLOCK_MANAGER (manager);\n          dbus_g_proxy_destroy (proxy);\n          g_object_unref (G_OBJECT (proxy));\n          LOCK_MANAGER (manager);\n          tmp = tmp->next;\n        }\n      g_slist_free (all);\n#ifndef G_DISABLE_CHECKS\n      if (manager->proxy_lists != NULL)\n        g_warning (\"Disconnection emitted \\\"destroy\\\" on all DBusGProxy, but somehow new proxies were created in response to one of those destroy signals. This will cause a memory leak.\");\n#endif\n    }\n  else\n    {\n      char *tri;\n      GSList *full_list;\n      GSList *owned_names;\n       GSList *tmp;\n       const char *sender;\n      if (dbus_message_is_signal (message,\n \t\t\t\t  DBUS_INTERFACE_DBUS,\n \t\t\t\t  \"NameOwnerChanged\"))\n \t{\n\t  DBusError derr;\n\t  dbus_error_init (&derr);\n\t  if (!dbus_message_get_args (message,\n\t\t\t\t      &derr,\n\t\t\t\t      DBUS_TYPE_STRING,\n\t\t\t\t      &name,\n\t\t\t\t      DBUS_TYPE_STRING,\n\t\t\t\t      &prev_owner,\n\t\t\t\t      DBUS_TYPE_STRING,\n\t\t\t\t      &new_owner,\n\t\t\t\t      DBUS_TYPE_INVALID))\n\t    {\n\t      dbus_error_free (&derr);\n\t    }\n\t  else if (manager->owner_names != NULL)\n\t    {\n\t      dbus_g_proxy_manager_replace_name_owner (manager, name, prev_owner, new_owner);\n\t    }\n\t}\n \t    }\n \t}", "target": 1}
{"code": "int zgfx_decompress(ZGFX_CONTEXT* zgfx, const BYTE* pSrcData, UINT32 SrcSize, BYTE** ppDstData,\n                    UINT32* pDstSize, UINT32 flags)\n {\n \tint status = -1;\n \tBYTE descriptor;\n \twStream* stream = Stream_New((BYTE*)pSrcData, SrcSize);\n \tif (!stream)\n \t\treturn -1;\n\tif (Stream_GetRemainingLength(stream) < 1)\n\t\tgoto fail;\n\tStream_Read_UINT8(stream, descriptor); \n\tif (descriptor == ZGFX_SEGMENTED_SINGLE)\n\t{\n\t\tif (!zgfx_decompress_segment(zgfx, stream, Stream_GetRemainingLength(stream)))\n \t\t\tgoto fail;\n \t\t*ppDstData = NULL;\n \t\tif (zgfx->OutputCount > 0)\n \t\t\t*ppDstData = (BYTE*) malloc(zgfx->OutputCount);\n\t\tif (!*ppDstData)\n\t\t\tgoto fail;\n\t\t*pDstSize = zgfx->OutputCount;\n\t\tCopyMemory(*ppDstData, zgfx->OutputBuffer, zgfx->OutputCount);\n\t}\n\telse if (descriptor == ZGFX_SEGMENTED_MULTIPART)\n\t{\n\t\tUINT32 segmentSize;\n\t\tUINT16 segmentNumber;\n \t\tUINT16 segmentCount;\n \t\tUINT32 uncompressedSize;\n \t\tBYTE* pConcatenated;\n \t\tif (Stream_GetRemainingLength(stream) < 6)\n \t\t\tgoto fail;\n\t\tStream_Read_UINT16(stream, segmentCount); \n\t\tStream_Read_UINT32(stream, uncompressedSize); \n\t\tif (Stream_GetRemainingLength(stream) < segmentCount * sizeof(UINT32))\n\t\t\tgoto fail;\n\t\tpConcatenated = (BYTE*) malloc(uncompressedSize);\n\t\tif (!pConcatenated)\n\t\t\tgoto fail;\n\t\t*ppDstData = pConcatenated;\n\t\t*pDstSize = uncompressedSize;\n\t\tfor (segmentNumber = 0; segmentNumber < segmentCount; segmentNumber++)\n\t\t{\n\t\t\tif (Stream_GetRemainingLength(stream) < sizeof(UINT32))\n\t\t\t\tgoto fail;\n\t\t\tStream_Read_UINT32(stream, segmentSize); \n \t\t\tif (!zgfx_decompress_segment(zgfx, stream, segmentSize))\n \t\t\t\tgoto fail;\n \t\t\tCopyMemory(pConcatenated, zgfx->OutputBuffer, zgfx->OutputCount);\n \t\t\tpConcatenated += zgfx->OutputCount;\n \t\t}\n \t}\n \telse\n\t{\n\t\tgoto fail;\n\t}\n\tstatus = 1;\nfail:\n\tStream_Free(stream, FALSE);\n\treturn status;\n}", "target": 1}
{"code": "bool ChromeDownloadManagerDelegate::IsDangerousFile(\n    const DownloadItem& download,\n    const FilePath& suggested_path,\n     bool visited_referrer_before) {\n   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n  if (download.GetTransitionType() & content::PAGE_TRANSITION_FROM_ADDRESS_BAR)\n    return false;\n  if (extensions::FeatureSwitch::easy_off_store_install()->IsEnabled() &&\n      download_crx_util::IsExtensionDownload(download) &&\n      !extensions::WebstoreInstaller::GetAssociatedApproval(download)) {\n    return true;\n  }\n  if (ShouldOpenFileBasedOnExtension(suggested_path) &&\n      download.HasUserGesture())\n    return false;\n   download_util::DownloadDangerLevel danger_level =\n       download_util::GetFileDangerLevel(suggested_path.BaseName());\n  if (danger_level == download_util::AllowOnUserGesture)\n     return !download.HasUserGesture() || !visited_referrer_before;\n   return danger_level == download_util::Dangerous;\n }", "target": 1}
{"code": "static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)\n {\n     const char *perm = \"add\";\n    if (uid >= AID_APP) {\n         return 0; \n     }\n return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;\n}", "target": 1}
{"code": "DECLAREcpFunc(cpDecodedStrips)\n{\n\ttsize_t stripsize  = TIFFStripSize(in);\n\ttdata_t buf = _TIFFmalloc(stripsize);\n\t(void) imagewidth; (void) spp;\n\tif (buf) {\n \t\ttstrip_t s, ns = TIFFNumberOfStrips(in);\n \t\tuint32 row = 0;\n \t\t_TIFFmemset(buf, 0, stripsize);\n\t\tfor (s = 0; s < ns; s++) {\n \t\t\ttsize_t cc = (row + rowsperstrip > imagelength) ?\n \t\t\t    TIFFVStripSize(in, imagelength - row) : stripsize;\n \t\t\tif (TIFFReadEncodedStrip(in, s, buf, cc) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read strip %lu\",\n\t\t\t\t    (unsigned long) s);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFWriteEncodedStrip(out, s, buf, cc) < 0) {\n\t\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t\t    \"Error, can't write strip %lu\",\n\t\t\t\t    (unsigned long) s);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\trow += rowsperstrip;\n\t\t}\n\t\t_TIFFfree(buf);\n\t\treturn 1;\n\t} else {\n\t\tTIFFError(TIFFFileName(in),\n\t\t    \"Error, can't allocate memory buffer of size %lu \"\n\t\t    \"to read strips\", (unsigned long) stripsize);\n\t\treturn 0;\n\t}\nbad:\n\t_TIFFfree(buf);\n\treturn 0;\n}", "target": 1}
{"code": "void net_checksum_calculate(uint8_t *data, int length)\n{\n    int hlen, plen, proto, csum_offset;\n    uint16_t csum;\n    if ((data[14] & 0xf0) != 0x40)\n\treturn; \n    hlen  = (data[14] & 0x0f) * 4;\n    plen  = (data[16] << 8 | data[17]) - hlen;\n    proto = data[23];\n    switch (proto) {\n    case PROTO_TCP:\n\tcsum_offset = 16;\n\tbreak;\n    case PROTO_UDP:\n\tcsum_offset = 6;\n\tbreak;\n    default:\n\treturn;\n    }\n    if (plen < csum_offset+2)\n\treturn;\n    data[14+hlen+csum_offset]   = 0;\n    data[14+hlen+csum_offset+1] = 0;\n    csum = net_checksum_tcpudp(plen, proto, data+14+12, data+14+hlen);\n    data[14+hlen+csum_offset]   = csum >> 8;\n    data[14+hlen+csum_offset+1] = csum & 0xff;\n}", "target": 1}
{"code": "gdImagePtr gdImageScaleTwoPass(const gdImagePtr src, const unsigned int src_width, const unsigned int src_height, const unsigned int new_width, const unsigned int new_height)\n{\n\tgdImagePtr tmp_im;\n\tgdImagePtr dst;\n\tif (!src->trueColor) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\ttmp_im = gdImageCreateTrueColor(new_width, src_height);\n\tif (tmp_im == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageSetInterpolationMethod(tmp_im, src->interpolation_id);\n\t_gdScaleHoriz(src, src_width, src_height, tmp_im, new_width, src_height);\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (dst == NULL) {\n\t\tgdFree(tmp_im);\n\t\treturn NULL;\n\t}\n\tgdImageSetInterpolationMethod(dst, src->interpolation_id);\n\t_gdScaleVert(tmp_im, new_width, src_height, dst, new_width, new_height);\n\tgdFree(tmp_im);\n\treturn dst;\n}", "target": 1}
{"code": "GetNumWrongData(const byte * curPtr, const int maxnum)\n{\n    int count = 0;\n    if (1 == maxnum) {\n        return (1);\n    }\n    while (*(curPtr + count) != *(curPtr + count + 1) && maxnum > count) {\n        count++;\n    }\n    return (count);\n}", "target": 1}
{"code": "    void publish(Topic *iterator, size_t start, size_t stop, std::string_view topic, std::pair<std::string_view, std::string_view> message) {\n        if (numTriggeredTopics == 64) {\n            drain();\n        }\n        for (; stop != std::string::npos; start = stop + 1) {\n            stop = topic.find('/', start);\n            std::string_view segment = topic.substr(start, stop - start);\n            if (segment.length() == 1) {\n                if (segment[0] == '+' || segment[0] == '#') {\n                    return;\n                }\n            }\n            if (iterator->terminatingWildcardChild) {\n                iterator->terminatingWildcardChild->messages[messageId] = message;\n                if (!iterator->terminatingWildcardChild->triggered) {\n                    triggeredTopics[numTriggeredTopics++] = iterator->terminatingWildcardChild;\n                    iterator->terminatingWildcardChild->triggered = true;\n                }\n            }\n            if (iterator->wildcardChild) {\n                publish(iterator->wildcardChild, stop + 1, stop, topic, message);\n            }\n            std::map<std::string_view, Topic *>::iterator it = iterator->children.find(segment);\n            if (it == iterator->children.end()) {\n                return;\n            }\n            iterator = it->second;\n        }\n        iterator->messages[messageId] = message;\n        if (!iterator->triggered) {\n            triggeredTopics[numTriggeredTopics++] = iterator;\n            iterator->triggered = true;\n        }\n    }", "target": 1}
{"code": "bt_status_t btif_dm_pin_reply( const bt_bdaddr_t *bd_addr, uint8_t accept,\n                                uint8_t pin_len, bt_pin_code_t *pin_code)\n {\n     BTIF_TRACE_EVENT(\"%s: accept=%d\", __FUNCTION__, accept);\n    if (pin_code == NULL)\n         return BT_STATUS_FAIL;\n #if (defined(BLE_INCLUDED) && (BLE_INCLUDED == TRUE))\n if (pairing_cb.is_le_only)\n {\n int i;\n        UINT32 passkey = 0;\n int multi[] = {100000, 10000, 1000, 100, 10,1};\n        BD_ADDR remote_bd_addr;\n        bdcpy(remote_bd_addr, bd_addr->address);\n for (i = 0; i < 6; i++)\n {\n            passkey += (multi[i] * (pin_code->pin[i] - '0'));\n }\n        BTIF_TRACE_DEBUG(\"btif_dm_pin_reply: passkey: %d\", passkey);\n        BTA_DmBlePasskeyReply(remote_bd_addr, accept, passkey);\n }\n else\n {\n        BTA_DmPinReply( (UINT8 *)bd_addr->address, accept, pin_len, pin_code->pin);\n if (accept)\n            pairing_cb.pin_code_len = pin_len;\n }\n#else\n    BTA_DmPinReply( (UINT8 *)bd_addr->address, accept, pin_len, pin_code->pin);\n if (accept)\n        pairing_cb.pin_code_len = pin_len;\n#endif\n return BT_STATUS_SUCCESS;\n}", "target": 1}
{"code": "static struct sock *sctp_v6_create_accept_sk(struct sock *sk,\n\t\t\t\t\t     struct sctp_association *asoc,\n\t\t\t\t\t     bool kern)\n{\n\tstruct sock *newsk;\n\tstruct ipv6_pinfo *newnp, *np = inet6_sk(sk);\n\tstruct sctp6_sock *newsctp6sk;\n\tstruct ipv6_txoptions *opt;\n\tnewsk = sk_alloc(sock_net(sk), PF_INET6, GFP_KERNEL, sk->sk_prot, kern);\n\tif (!newsk)\n\t\tgoto out;\n\tsock_init_data(NULL, newsk);\n\tsctp_copy_sock(newsk, sk, asoc);\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\tnewsctp6sk = (struct sctp6_sock *)newsk;\n\tinet_sk(newsk)->pinet6 = &newsctp6sk->inet6;\n\tsctp_sk(newsk)->v4mapped = sctp_sk(sk)->v4mapped;\n \tnewnp = inet6_sk(newsk);\n \tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n \trcu_read_lock();\n \topt = rcu_dereference(np->opt);\n\tif (opt)\n\t\topt = ipv6_dup_options(newsk, opt);\n\tRCU_INIT_POINTER(newnp->opt, opt);\n\trcu_read_unlock();\n\tsctp_v6_to_sk_daddr(&asoc->peer.primary_addr, newsk);\n\tnewsk->sk_v6_rcv_saddr = sk->sk_v6_rcv_saddr;\n\tsk_refcnt_debug_inc(newsk);\n\tif (newsk->sk_prot->init(newsk)) {\n\t\tsk_common_release(newsk);\n\t\tnewsk = NULL;\n\t}\nout:\n\treturn newsk;\n}", "target": 1}
{"code": "static int copy_to_user_tmpl(struct xfrm_policy *xp, struct sk_buff *skb)\n{\n\tstruct xfrm_user_tmpl vec[XFRM_MAX_DEPTH];\n\tint i;\n\tif (xp->xfrm_nr == 0)\n\t\treturn 0;\n\tfor (i = 0; i < xp->xfrm_nr; i++) {\n \t\tstruct xfrm_user_tmpl *up = &vec[i];\n \t\tstruct xfrm_tmpl *kp = &xp->xfrm_vec[i];\n \t\tmemcpy(&up->id, &kp->id, sizeof(up->id));\n \t\tup->family = kp->encap_family;\n \t\tmemcpy(&up->saddr, &kp->saddr, sizeof(up->saddr));\n\t\tup->reqid = kp->reqid;\n\t\tup->mode = kp->mode;\n\t\tup->share = kp->share;\n\t\tup->optional = kp->optional;\n\t\tup->aalgos = kp->aalgos;\n\t\tup->ealgos = kp->ealgos;\n\t\tup->calgos = kp->calgos;\n\t}\n\treturn nla_put(skb, XFRMA_TMPL,\n\t\t       sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr, vec);\n}", "target": 1}
{"code": "archive_strncat_l(struct archive_string *as, const void *_p, size_t n,\n    struct archive_string_conv *sc)\n{\n\tconst void *s;\n\tsize_t length;\n\tint i, r = 0, r2;\n\tif (_p == NULL || n == 0) {\n\t\tint tn = 1;\n\t\tif (sc != NULL && (sc->flag & SCONV_TO_UTF16))\n\t\t\ttn = 2;\n\t\tif (archive_string_ensure(as, as->length + tn) == NULL)\n\t\t\treturn (-1);\n\t\tas->s[as->length] = 0;\n\t\tif (tn == 2)\n\t\t\tas->s[as->length+1] = 0;\n\t\treturn (0);\n\t}\n\tif (sc == NULL) {\n\t\tlength = mbsnbytes(_p, n);\n\t\tif (archive_string_append(as, _p, length) == NULL)\n\t\t\treturn (-1);\n\t\treturn (0);\n\t}\n\tif (sc->flag & SCONV_FROM_UTF16)\n\t\tlength = utf16nbytes(_p, n);\n\telse\n\t\tlength = mbsnbytes(_p, n);\n\ts = _p;\n\ti = 0;\n\tif (sc->nconverter > 1) {\n\t\tsc->utftmp.length = 0;\n\t\tr2 = sc->converter[0](&(sc->utftmp), s, length, sc);\n\t\tif (r2 != 0 && errno == ENOMEM)\n\t\t\treturn (r2);\n\t\tif (r > r2)\n\t\t\tr = r2;\n\t\ts = sc->utftmp.s;\n\t\tlength = sc->utftmp.length;\n\t\t++i;\n\t}\n\tr2 = sc->converter[i](as, s, length, sc);\n\tif (r > r2)\n\t\tr = r2;\n\treturn (r);\n}", "target": 1}
{"code": "START_TEST(test_tm_adopt_ispidowner)\n  {\n  fail_unless(TRUE == ispidowner(getpid()));\n  fail_unless(FALSE == ispidowner(1));\n  }", "target": 1}
{"code": "vmod_append(VRT_CTX, VCL_HEADER hdr, VCL_STRANDS s)\n{\n\tstruct http *hp;\n\tstruct strands st[1];\n\tconst char *p[s->n + 2];\n\tconst char *b;\n\tCHECK_OBJ_NOTNULL(ctx, VRT_CTX_MAGIC);\n\tp[0] = hdr->what + 1;\n\tp[1] = \" \";\n\tAN(memcpy(p + 2, s->p, s->n * sizeof *s->p));\n\tst->n = s->n + 2;\n\tst->p = p;\n\tb = VRT_StrandsWS(ctx->ws, NULL, st);\n\thp = VRT_selecthttp(ctx, hdr->where);\n\thttp_SetHeader(hp, b);\n}", "target": 1}
{"code": "SProcXIBarrierReleasePointer(ClientPtr client)\n{\n    xXIBarrierReleasePointerInfo *info;\n    REQUEST(xXIBarrierReleasePointerReq);\n    int i;\n    swaps(&stuff->length);\n     REQUEST_AT_LEAST_SIZE(xXIBarrierReleasePointerReq);\n     swapl(&stuff->num_barriers);\n     REQUEST_FIXED_SIZE(xXIBarrierReleasePointerReq, stuff->num_barriers * sizeof(xXIBarrierReleasePointerInfo));\n     info = (xXIBarrierReleasePointerInfo*) &stuff[1];\n        swapl(&info->barrier);\n        swapl(&info->eventid);\n    }", "target": 1}
{"code": "static int ssl_parse_server_psk_hint( mbedtls_ssl_context *ssl,\n                                      unsigned char **p,\n                                      unsigned char *end )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n    size_t  len;\n    ((void) ssl);\n     len = (*p)[0] << 8 | (*p)[1];\n     *p += 2;\n    if( (*p) + len > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                    \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n    *p += len;\n    ret = 0;\n    return( ret );\n}", "target": 1}
{"code": " static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,\n                                                 size_t mincodes, size_t numcodes, unsigned maxbitlen)\n {\n   unsigned error = 0;\n   while(!frequencies[numcodes - 1] && numcodes > mincodes) numcodes--; \n   tree->maxbitlen = maxbitlen;\n   tree->numcodes = (unsigned)numcodes; \n  tree->lengths = (unsigned*)realloc(tree->lengths, numcodes * sizeof(unsigned));\n   if(!tree->lengths) return 83; \n   memset(tree->lengths, 0, numcodes * sizeof(unsigned));\n  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);\n  if(!error) error = HuffmanTree_makeFromLengths2(tree);\n  return error;\n}", "target": 1}
{"code": "int install_user_keyrings(void)\n{\n\tstruct user_struct *user;\n\tconst struct cred *cred;\n\tstruct key *uid_keyring, *session_keyring;\n\tkey_perm_t user_keyring_perm;\n\tchar buf[20];\n\tint ret;\n\tuid_t uid;\n\tuser_keyring_perm = (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_ALL;\n\tcred = current_cred();\n\tuser = cred->user;\n\tuid = from_kuid(cred->user_ns, user->uid);\n \tkenter(\"%p{%u}\", user, uid);\n\tif (user->uid_keyring) {\n \t\tkleave(\" = 0 [exist]\");\n \t\treturn 0;\n \t}\n\tmutex_lock(&key_user_keyring_mutex);\n\tret = 0;\n\tif (!user->uid_keyring) {\n\t\tsprintf(buf, \"_uid.%u\", uid);\n\t\tuid_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(uid_keyring)) {\n\t\t\tuid_keyring = keyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t\t    cred, user_keyring_perm,\n\t\t\t\t\t\t    KEY_ALLOC_IN_QUOTA, NULL);\n\t\t\tif (IS_ERR(uid_keyring)) {\n\t\t\t\tret = PTR_ERR(uid_keyring);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tsprintf(buf, \"_uid_ses.%u\", uid);\n\t\tsession_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(session_keyring)) {\n\t\t\tsession_keyring =\n\t\t\t\tkeyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t      cred, user_keyring_perm,\n\t\t\t\t\t      KEY_ALLOC_IN_QUOTA, NULL);\n\t\t\tif (IS_ERR(session_keyring)) {\n\t\t\t\tret = PTR_ERR(session_keyring);\n\t\t\t\tgoto error_release;\n\t\t\t}\n\t\t\tret = key_link(session_keyring, uid_keyring);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_release_both;\n\t\t}\n\t\tuser->uid_keyring = uid_keyring;\n\t\tuser->session_keyring = session_keyring;\n\t}\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = 0\");\n\treturn 0;\nerror_release_both:\n\tkey_put(session_keyring);\nerror_release:\n\tkey_put(uid_keyring);\nerror:\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}", "target": 1}
{"code": "void kvm_mmu_invpcid_gva(struct kvm_vcpu *vcpu, gva_t gva, unsigned long pcid)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.mmu;\n\tbool tlb_flush = false;\n\tuint i;\n\tif (pcid == kvm_get_active_pcid(vcpu)) {\n\t\tmmu->invlpg(vcpu, gva, mmu->root.hpa);\n\t\ttlb_flush = true;\n\t}\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++) {\n\t\tif (VALID_PAGE(mmu->prev_roots[i].hpa) &&\n\t\t    pcid == kvm_get_pcid(vcpu, mmu->prev_roots[i].pgd)) {\n\t\t\tmmu->invlpg(vcpu, gva, mmu->prev_roots[i].hpa);\n\t\t\ttlb_flush = true;\n\t\t}\n\t}\n\tif (tlb_flush)\n\t\tstatic_call(kvm_x86_flush_tlb_gva)(vcpu, gva);\n\t++vcpu->stat.invlpg;\n}", "target": 1}
{"code": " int CLASS ljpeg_start (struct jhead *jh, int info_only)\n {\n  int c, tag, len;\n   uchar data[0x10000];\n   const uchar *dp;\n  memset (jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  fread (data, 2, 1, ifp);\n  if (data[1] != 0xd8) return 0;\n  do {\n    fread (data, 2, 2, ifp);\n    tag =  data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00) return 0;\n    fread (data, 1, len, ifp);\n    switch (tag) {\n      case 0xffc3:\n\tjh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n      case 0xffc0:\n\tjh->bits = data[0];\n\tjh->high = data[1] << 8 | data[2];\n\tjh->wide = data[3] << 8 | data[4];\n\tjh->clrs = data[5] + jh->sraw;\n\tif (len == 9 && !dng_version) getc(ifp);\n\tbreak;\n      case 0xffc4:\n\tif (info_only) break;\n\tfor (dp = data; dp < data+len && (c = *dp++) < 4; )\n\t  jh->free[c] = jh->huff[c] = make_decoder_ref (&dp);\n\tbreak;\n      case 0xffda:\n\tjh->psv = data[1+data[0]*2];\n\tjh->bits -= data[3+data[0]*2] & 15;\n\tbreak;\n      case 0xffdd:\n\tjh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (info_only) return 1;\n  FORC(5) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c];\n  if (jh->sraw) {\n    FORC(4)        jh->huff[2+c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1+c] = jh->huff[0];\n  }\n  jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);\n  merror (jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}", "target": 1}
{"code": "void dname_pkt_copy(sldns_buffer* pkt, uint8_t* to, uint8_t* dname)\n{\n\tsize_t len = 0;\n\tuint8_t lablen;\n\tlablen = *dname++;\n\twhile(lablen) {\n\t\tif(LABEL_IS_PTR(lablen)) {\n\t\t\tdname = sldns_buffer_at(pkt, PTR_OFFSET(lablen, *dname));\n\t\t\tlablen = *dname++;\n\t\t\tcontinue;\n\t\t}\n\t\tlog_assert(lablen <= LDNS_MAX_LABELLEN);\n\t\tlen += (size_t)lablen+1;\n\t\tif(len >= LDNS_MAX_DOMAINLEN) {\n\t\t\t*to = 0; \n\t\t\tlog_err(\"bad dname in dname_pkt_copy\");\n\t\t\treturn;\n\t\t}\n\t\t*to++ = lablen;\n\t\tmemmove(to, dname, lablen);\n\t\tdname += lablen;\n\t\tto += lablen;\n\t\tlablen = *dname++;\n\t}\n\t*to = 0;\n}", "target": 1}
{"code": "static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* serial)\n{\n\tcac_private_data_t * priv = CAC_DATA(card);\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_NORMAL);\n        if (card->serialnr.len)   {\n                *serial = card->serialnr;\n                SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n         }\n \tif (priv->cac_id_len) {\n \t\tserial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);\n\t\tmemcpy(serial->value, priv->cac_id, priv->cac_id_len);\n \t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n \t}\n \tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);\n}", "target": 1}
{"code": "int net_get(int s, void *arg, int *len)\n{\n\tstruct net_hdr nh;\n\tint plen;\n\tif (net_read_exact(s, &nh, sizeof(nh)) == -1)\n        {\n\t\treturn -1;\n        }\n\tplen = ntohl(nh.nh_len);\n \tif (!(plen <= *len))\n \t\tprintf(\"PLEN %d type %d len %d\\n\",\n \t\t\tplen, nh.nh_type, *len);\n\tassert(plen <= *len); \n \t*len = plen;\n \tif ((*len) && (net_read_exact(s, arg, *len) == -1))\n        {\n            return -1;\n        }\n\treturn nh.nh_type;\n}", "target": 1}
{"code": "ImagingPcxDecode(Imaging im, ImagingCodecState state, UINT8* buf, Py_ssize_t bytes)\n{\n    UINT8 n;\n    UINT8* ptr;\n    if (strcmp(im->mode, \"1\") == 0 && state->xsize > state->bytes * 8) {\n        state->errcode = IMAGING_CODEC_OVERRUN;\n        return -1;\n    } else if (strcmp(im->mode, \"P\") == 0 && state->xsize > state->bytes) {\n        state->errcode = IMAGING_CODEC_OVERRUN;\n        return -1;\n    }\n    ptr = buf;\n    for (;;) {\n\tif (bytes < 1)\n\t    return ptr - buf;\n\tif ((*ptr & 0xC0) == 0xC0) {\n\t    if (bytes < 2)\n\t\treturn ptr - buf;\n\t    n = ptr[0] & 0x3F;\n\t    while (n > 0) {\n\t\tif (state->x >= state->bytes) {\n\t\t    state->errcode = IMAGING_CODEC_OVERRUN;\n\t\t    break;\n\t\t}\n\t\tstate->buffer[state->x++] = ptr[1];\n\t\tn--;\n\t    }\n\t    ptr += 2; bytes -= 2;\n\t} else {\n\t    state->buffer[state->x++] = ptr[0];\n\t    ptr++; bytes--;\n\t}\n\tif (state->x >= state->bytes) {\n        if (state->bytes % state->xsize && state->bytes > state->xsize) {\n            int bands = state->bytes / state->xsize;\n            int stride = state->bytes / bands;\n            int i;\n            for (i=1; i< bands; i++) {  \n                memmove(&state->buffer[i*state->xsize],\n                        &state->buffer[i*stride],\n                        state->xsize);\n            }\n        }\n\t    state->shuffle((UINT8*) im->image[state->y + state->yoff] +\n\t\t\t   state->xoff * im->pixelsize, state->buffer,\n\t\t\t   state->xsize);\n\t    state->x = 0;\n\t    if (++state->y >= state->ysize) {\n\t\treturn -1;\n\t    }\n\t}\n    }\n}", "target": 1}
{"code": " WORD32 ih264d_create(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)\n {\n     ih264d_create_op_t *ps_create_op;\n     WORD32 ret;\n     ps_create_op = (ih264d_create_op_t *)pv_api_op;\n     ps_create_op->s_ivd_create_op_t.u4_error_code = 0;\n     ret = ih264d_allocate_static_bufs(&dec_hdl, pv_api_ip, pv_api_op);\n    if((IV_FAIL == ret) && (NULL != dec_hdl))\n     {\n        ih264d_free_static_bufs(dec_hdl);\n         ps_create_op->s_ivd_create_op_t.u4_error_code = IVD_MEM_ALLOC_FAILED;\n         ps_create_op->s_ivd_create_op_t.u4_error_code = 1 << IVD_FATALERROR;\n return IV_FAIL;\n }\n return IV_SUCCESS;\n}", "target": 1}
{"code": "void gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quantization)\n{\n\tuint8_t *argb;\n\tint x, y;\n\tuint8_t *p;\n\tuint8_t *out;\n\tsize_t out_size;\n\tif (im == NULL) {\n\t\treturn;\n\t}\n\tif (!gdImageTrueColor(im)) {\n\t\tzend_error(E_ERROR, \"Paletter image not supported by webp\");\n\t\treturn;\n\t}\n\tif (quantization == -1) {\n \t\tquantization = 80;\n \t}\n \targb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));\n \tif (!argb) {\n \t\treturn;\n\t}\n\tp = argb;\n\tfor (y = 0; y < gdImageSY(im); y++) {\n\t\tfor (x = 0; x < gdImageSX(im); x++) {\n\t\t\tregister int c;\n\t\t\tregister char a;\n\t\t\tc = im->tpixels[y][x];\n\t\t\ta = gdTrueColorGetAlpha(c);\n\t\t\tif (a == 127) {\n\t\t\t\ta = 0;\n\t\t\t} else {\n\t\t\t\ta = 255 - ((a << 1) + (a >> 6));\n\t\t\t}\n\t\t\t*(p++) = gdTrueColorGetRed(c);\n\t\t\t*(p++) = gdTrueColorGetGreen(c);\n\t\t\t*(p++) = gdTrueColorGetBlue(c); \n\t\t\t*(p++) = a;\n\t\t}\n\t}\n\tout_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quantization, &out);\n\tif (out_size == 0) {\n\t\tzend_error(E_ERROR, \"gd-webp encoding failed\");\n\t\tgoto freeargb;\n\t}\n\tgdPutBuf(out, out_size, outfile);\n\tfree(out);\nfreeargb:\n\tgdFree(argb);\n}", "target": 1}
{"code": "tc_dump_action(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct nlmsghdr *nlh;\n\tunsigned char *b = skb->tail;\n\tstruct rtattr *x;\n\tstruct tc_action_ops *a_o;\n\tstruct tc_action a;\n\tint ret = 0;\n\tstruct tcamsg *t = (struct tcamsg *) NLMSG_DATA(cb->nlh);\n\tchar *kind = find_dump_kind(cb->nlh);\n\tif (kind == NULL) {\n\t\tprintk(\"tc_dump_action: action bad kind\\n\");\n\t\treturn 0;\n\t}\n\ta_o = tc_lookup_action_n(kind);\n\tif (a_o == NULL) {\n\t\tprintk(\"failed to find %s\\n\", kind);\n\t\treturn 0;\n\t}\n\tmemset(&a, 0, sizeof(struct tc_action));\n\ta.ops = a_o;\n\tif (a_o->walk == NULL) {\n\t\tprintk(\"tc_dump_action: %s !capable of dumping table\\n\", kind);\n\t\tgoto rtattr_failure;\n\t}\n\tnlh = NLMSG_PUT(skb, NETLINK_CB(cb->skb).pid, cb->nlh->nlmsg_seq,\n\t                cb->nlh->nlmsg_type, sizeof(*t));\n\tt = NLMSG_DATA(nlh);\n\tt->tca_family = AF_UNSPEC;\n\tx = (struct rtattr *) skb->tail;\n\tRTA_PUT(skb, TCA_ACT_TAB, 0, NULL);\n\tret = a_o->walk(skb, cb, RTM_GETACTION, &a);\n\tif (ret < 0)\n\t\tgoto rtattr_failure;\n\tif (ret > 0) {\n\t\tx->rta_len = skb->tail - (u8 *) x;\n\t\tret = skb->len;\n\t} else\n\t\tskb_trim(skb, (u8*)x - skb->data);\n\tnlh->nlmsg_len = skb->tail - b;\n\tif (NETLINK_CB(cb->skb).pid && ret)\n\t\tnlh->nlmsg_flags |= NLM_F_MULTI;\n\tmodule_put(a_o->owner);\n\treturn skb->len;\nrtattr_failure:\nnlmsg_failure:\n\tmodule_put(a_o->owner);\n\tskb_trim(skb, b - skb->data);\n\treturn skb->len;\n}", "target": 1}
{"code": "static void rds_tcp_kill_sock(struct net *net)\n{\n\tstruct rds_tcp_connection *tc, *_tc;\n\tLIST_HEAD(tmp_list);\n\tstruct rds_tcp_net *rtn = net_generic(net, rds_tcp_netid);\n\tstruct socket *lsock = rtn->rds_tcp_listen_sock;\n\trtn->rds_tcp_listen_sock = NULL;\n\trds_tcp_listen_stop(lsock, &rtn->rds_tcp_accept_w);\n\tspin_lock_irq(&rds_tcp_conn_lock);\n \tlist_for_each_entry_safe(tc, _tc, &rds_tcp_conn_list, t_tcp_node) {\n \t\tstruct net *c_net = read_pnet(&tc->t_cpath->cp_conn->c_net);\n\t\tif (net != c_net || !tc->t_sock)\n \t\t\tcontinue;\n \t\tif (!list_has_conn(&tmp_list, tc->t_cpath->cp_conn)) {\n \t\t\tlist_move_tail(&tc->t_tcp_node, &tmp_list);\n\t\t} else {\n\t\t\tlist_del(&tc->t_tcp_node);\n\t\t\ttc->t_tcp_node_detached = true;\n\t\t}\n\t}\n\tspin_unlock_irq(&rds_tcp_conn_lock);\n\tlist_for_each_entry_safe(tc, _tc, &tmp_list, t_tcp_node)\n\t\trds_conn_destroy(tc->t_cpath->cp_conn);\n}", "target": 1}
{"code": "void __kvm_migrate_pit_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pit *pit = vcpu->kvm->arch.vpit;\n\tstruct hrtimer *timer;\n\tif (!kvm_vcpu_is_bsp(vcpu) || !pit)\n \t\treturn;\n \ttimer = &pit->pit_state.timer;\n \tif (hrtimer_cancel(timer))\n \t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS);\n }", "target": 1}
{"code": "get_futex_key(u32 __user *uaddr, int fshared, union futex_key *key, int rw)\n{\n\tunsigned long address = (unsigned long)uaddr;\n\tstruct mm_struct *mm = current->mm;\n\tstruct page *page;\n\tstruct address_space *mapping;\n\tint err, ro = 0;\n\tkey->both.offset = address % PAGE_SIZE;\n\tif (unlikely((address % sizeof(u32)) != 0))\n\t\treturn -EINVAL;\n\taddress -= key->both.offset;\n\tif (unlikely(!access_ok(rw, uaddr, sizeof(u32))))\n\t\treturn -EFAULT;\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\tif (!fshared) {\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\t\tget_futex_key_refs(key);  \n\t\treturn 0;\n\t}\nagain:\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\terr = get_user_pages_fast(address, 1, 1, &page);\n\tif (err == -EFAULT && rw == VERIFY_READ) {\n\t\terr = get_user_pages_fast(address, 1, 0, &page);\n\t\tro = 1;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\telse\n\t\terr = 0;\n\tlock_page(page);\n\tmapping = compound_head(page)->mapping;\n\tif (!mapping) {\n\t\tint shmem_swizzled = PageSwapCache(page);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tif (shmem_swizzled)\n\t\t\tgoto again;\n\t\treturn -EFAULT;\n\t}\n\tif (PageAnon(page)) {\n\t\tif (unlikely(should_fail_futex(fshared)) || ro) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->both.offset |= FUT_OFF_MMSHARED; \n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\t} else {\n\t\tkey->both.offset |= FUT_OFF_INODE; \n\t\tkey->shared.inode = mapping->host;\n\t\tkey->shared.pgoff = basepage_index(page);\n\t}\n\tget_futex_key_refs(key); \nout:\n\tunlock_page(page);\n\tput_page(page);\n\treturn err;\n}", "target": 1}
{"code": "inline StreamWriteResult StreamBase::Write(\n    uv_buf_t* bufs,\n    size_t count,\n    uv_stream_t* send_handle,\n    v8::Local<v8::Object> req_wrap_obj) {\n  Environment* env = stream_env();\n  int err;\n  size_t total_bytes = 0;\n  for (size_t i = 0; i < count; ++i)\n    total_bytes += bufs[i].len;\n  bytes_written_ += total_bytes;\n  if (send_handle == nullptr) {\n    err = DoTryWrite(&bufs, &count);\n    if (err != 0 || count == 0) {\n      return StreamWriteResult { false, err, nullptr, total_bytes };\n    }\n  }\n  HandleScope handle_scope(env->isolate());\n  if (req_wrap_obj.IsEmpty()) {\n    req_wrap_obj =\n        env->write_wrap_template()\n            ->NewInstance(env->context()).ToLocalChecked();\n    StreamReq::ResetObject(req_wrap_obj);\n  }\n  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(GetAsyncWrap());\n  WriteWrap* req_wrap = CreateWriteWrap(req_wrap_obj);\n  err = DoWrite(req_wrap, bufs, count, send_handle);\n  bool async = err == 0;\n  if (!async) {\n    req_wrap->Dispose();\n    req_wrap = nullptr;\n  }\n  const char* msg = Error();\n  if (msg != nullptr) {\n    req_wrap_obj->Set(env->error_string(), OneByteString(env->isolate(), msg));\n    ClearError();\n  }\n  return StreamWriteResult { async, err, req_wrap, total_bytes };\n}", "target": 1}
{"code": "static int clie_5_attach(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *port;\n\tunsigned int pipe;\n\tint j;\n\tif (serial->num_ports < 2)\n\t\treturn -1;\n \tport = serial->port[0];\n\tport->bulk_out_endpointAddress =\n\t\t\t\tserial->port[1]->bulk_out_endpointAddress;\n\tpipe = usb_sndbulkpipe(serial->dev, port->bulk_out_endpointAddress);\n\tfor (j = 0; j < ARRAY_SIZE(port->write_urbs); ++j)\n\t\tport->write_urbs[j]->pipe = pipe;\n\treturn 0;\n}", "target": 1}
{"code": "netdutils::Status XfrmController::ipSecSetEncapSocketOwner(const android::base::unique_fd& socket,\n int newUid, uid_t callerUid) {\n    ALOGD(\"XfrmController:%s, line=%d\", __FUNCTION__, __LINE__);\n const int fd = socket.get();\n struct stat info;\n if (fstat(fd, &info)) {\n return netdutils::statusFromErrno(errno, \"Failed to stat socket file descriptor\");\n }\n if (info.st_uid != callerUid) {\n return netdutils::statusFromErrno(EPERM, \"fchown disabled for non-owner calls\");\n }\n if (S_ISSOCK(info.st_mode) == 0) {\n return netdutils::statusFromErrno(EINVAL, \"File descriptor was not a socket\");\n     }\n     int optval;\n    socklen_t optlen;\n     netdutils::Status status =\n         getSyscallInstance().getsockopt(Fd(socket), IPPROTO_UDP, UDP_ENCAP, &optval, &optlen);\n     if (status != netdutils::status::ok) {\n return status;\n }\n if (optval != UDP_ENCAP_ESPINUDP && optval != UDP_ENCAP_ESPINUDP_NON_IKE) {\n return netdutils::statusFromErrno(EINVAL, \"Socket did not have UDP-encap sockopt set\");\n }\n if (fchown(fd, newUid, -1)) {\n return netdutils::statusFromErrno(errno, \"Failed to fchown socket file descriptor\");\n }\n return netdutils::status::ok;\n}", "target": 1}
{"code": "static __be32 nfsd3_proc_setacl(struct svc_rqst * rqstp,\n\t\tstruct nfsd3_setaclargs *argp,\n\t\tstruct nfsd3_attrstat *resp)\n{\n\tstruct inode *inode;\n\tsvc_fh *fh;\n\t__be32 nfserr = 0;\n\tint error;\n\tfh = fh_copy(&resp->fh, &argp->fh);\n\tnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);\n\tif (nfserr)\n \t\tgoto out;\n \tinode = d_inode(fh->fh_dentry);\n\tif (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {\n\t\terror = -EOPNOTSUPP;\n\t\tgoto out_errno;\n\t}\n \terror = fh_want_write(fh);\n \tif (error)\n \t\tgoto out_errno;\n\terror = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);\n \tif (error)\n\t\tgoto out_drop_write;\n\terror = inode->i_op->set_acl(inode, argp->acl_default,\n\t\t\t\t     ACL_TYPE_DEFAULT);\nout_drop_write:\n \tfh_drop_write(fh);\n out_errno:\n \tnfserr = nfserrno(error);\nout:\n\tposix_acl_release(argp->acl_access);\n\tposix_acl_release(argp->acl_default);\n\tRETURN_STATUS(nfserr);\n}", "target": 1}
{"code": "static bool acl_group_override(connection_struct *conn,\n\t\t\t\tgid_t prim_gid,\n\t\t\t\tconst char *fname)\n{\n\tSMB_STRUCT_STAT sbuf;\n\tif ((errno != EPERM) && (errno != EACCES)) {\n\t\treturn false;\n\t}\n\tif (lp_acl_group_control(SNUM(conn)) &&\n\t\t\tcurrent_user_in_group(prim_gid)) {\n\t\treturn true;\n\t}\n\tif (lp_dos_filemode(SNUM(conn)) &&\n\t\t\tcan_write_to_file(conn, fname, &sbuf)) {\n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "static bool access_pmu_evcntr(struct kvm_vcpu *vcpu,\n\t\t\t      struct sys_reg_params *p,\n\t\t\t      const struct sys_reg_desc *r)\n{\n\tu64 idx;\n\tif (!kvm_arm_pmu_v3_ready(vcpu))\n\t\treturn trap_raz_wi(vcpu, p, r);\n\tif (r->CRn == 9 && r->CRm == 13) {\n\t\tif (r->Op2 == 2) {\n\t\t\tif (pmu_access_event_counter_el0_disabled(vcpu))\n\t\t\t\treturn false;\n\t\t\tidx = vcpu_sys_reg(vcpu, PMSELR_EL0)\n\t\t\t      & ARMV8_PMU_COUNTER_MASK;\n\t\t} else if (r->Op2 == 0) {\n\t\t\tif (pmu_access_cycle_counter_el0_disabled(vcpu))\n\t\t\t\treturn false;\n \t\t\tidx = ARMV8_PMU_CYCLE_IDX;\n \t\t} else {\n\t\t\tBUG();\n \t\t}\n \t} else if (r->CRn == 14 && (r->CRm & 12) == 8) {\n \t\tif (pmu_access_event_counter_el0_disabled(vcpu))\n \t\t\treturn false;\n \t\tidx = ((r->CRm & 3) << 3) | (r->Op2 & 7);\n \t} else {\n\t\tBUG();\n \t}\n \tif (!pmu_counter_idx_valid(vcpu, idx))\n\t\treturn false;\n\tif (p->is_write) {\n\t\tif (pmu_access_el0_disabled(vcpu))\n\t\t\treturn false;\n\t\tkvm_pmu_set_counter_value(vcpu, idx, p->regval);\n\t} else {\n\t\tp->regval = kvm_pmu_get_counter_value(vcpu, idx);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static __inline__ int scm_check_creds(struct ucred *creds)\n{\n\tconst struct cred *cred = current_cred();\n\tkuid_t uid = make_kuid(cred->user_ns, creds->uid);\n\tkgid_t gid = make_kgid(cred->user_ns, creds->gid);\n\tif (!uid_valid(uid) || !gid_valid(gid))\n \t\treturn -EINVAL;\n \tif ((creds->pid == task_tgid_vnr(current) ||\n\t     ns_capable(current->nsproxy->pid_ns->user_ns, CAP_SYS_ADMIN)) &&\n \t    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||\n \t      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&\n \t    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||\n\t      gid_eq(gid, cred->sgid)) || nsown_capable(CAP_SETGID))) {\n\t       return 0;\n\t}\n\treturn -EPERM;\n}", "target": 1}
{"code": "int64_t LineBasedFrameDecoder::findEndOfLine(IOBufQueue& buf) {\n  Cursor c(buf.front());\n  for (uint32_t i = 0; i < maxLength_ && i < buf.chainLength(); i++) {\n    auto b = c.read<char>();\n    if (b == '\\n' && terminatorType_ != TerminatorType::CARRIAGENEWLINE) {\n      return i;\n    } else if (terminatorType_ != TerminatorType::NEWLINE &&\n               b == '\\r' && !c.isAtEnd() && c.read<char>() == '\\n') {\n      return i;\n    }\n  }\n  return -1;\n}", "target": 1}
{"code": " void buffer_slow_realign(struct buffer *buf)\n {\n       if (buf->i) {\n               int block1 = buf->i;\n               int block2 = 0;\n               if (buf->p + buf->i > buf->data + buf->size) {\n                       block1 = buf->data + buf->size - buf->p;\n                       block2 = buf->p + buf->i - (buf->data + buf->size);\n               }\n               if (block2)\n                       memcpy(swap_buffer, buf->data, block2);\n               memmove(buf->data, buf->p, block1);\n               if (block2)\n                       memcpy(buf->data + block1, swap_buffer, block2);\n        }\n        buf->p = buf->data;\n }", "target": 1}
{"code": "ssize_t qemu_deliver_packet_iov(NetClientState *sender,\n                                unsigned flags,\n                                const struct iovec *iov,\n                                int iovcnt,\n                                void *opaque)\n{\n    NetClientState *nc = opaque;\n    size_t size = iov_size(iov, iovcnt);\n    int ret;\n    if (size > INT_MAX) {\n        return size;\n    }\n    if (nc->link_down) {\n        return size;\n    }\n    if (nc->receive_disabled) {\n        return 0;\n    }\n    if (nc->info->receive_iov && !(flags & QEMU_NET_PACKET_FLAG_RAW)) {\n        ret = nc->info->receive_iov(nc, iov, iovcnt);\n    } else {\n        ret = nc_sendv_compat(nc, iov, iovcnt, flags);\n    }\n    if (ret == 0) {\n        nc->receive_disabled = 1;\n    }\n    return ret;\n}", "target": 1}
{"code": "static int do_remount(struct path *path, int flags, int mnt_flags,\n\t\t      void *data)\n{\n\tint err;\n\tstruct super_block *sb = path->mnt->mnt_sb;\n\tstruct mount *mnt = real_mount(path->mnt);\n\tif (!check_mnt(mnt))\n\t\treturn -EINVAL;\n\tif (path->dentry != path->mnt->mnt_root)\n\t\treturn -EINVAL;\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_READONLY) &&\n \t    !(mnt_flags & MNT_READONLY)) {\n \t\treturn -EPERM;\n \t}\n \terr = security_sb_remount(sb, data);\n \tif (err)\n \t\treturn err;\n\tdown_write(&sb->s_umount);\n\tif (flags & MS_BIND)\n\t\terr = change_mount_flags(path->mnt, flags);\n\telse if (!capable(CAP_SYS_ADMIN))\n\t\terr = -EPERM;\n\telse\n\t\terr = do_remount_sb(sb, flags, data, 0);\n\tif (!err) {\n\t\tlock_mount_hash();\n\t\tmnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;\n\t\tmnt->mnt.mnt_flags = mnt_flags;\n\t\ttouch_mnt_namespace(mnt->mnt_ns);\n\t\tunlock_mount_hash();\n\t}\n\tup_write(&sb->s_umount);\n\treturn err;\n}", "target": 1}
{"code": "int snmp_helper(void *context, size_t hdrlen, unsigned char tag,\n \t\tconst void *data, size_t datalen)\n {\n \tstruct snmp_ctx *ctx = (struct snmp_ctx *)context;\n\t__be32 *pdata = (__be32 *)data;\n \tif (*pdata == ctx->from) {\n \t\tpr_debug(\"%s: %pI4 to %pI4\\n\", __func__,\n \t\t\t (void *)&ctx->from, (void *)&ctx->to);\n\t\tif (*ctx->check)\n\t\t\tfast_csum(ctx, (unsigned char *)data - ctx->begin);\n\t\t*pdata = ctx->to;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": " static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData,\n                                    OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n {\n    OPJ_UINT32 x, y;\n     OPJ_UINT8 *pix;\n     const OPJ_UINT8 *beyond;\n     beyond = pData + stride * height;\n     pix = pData;\n    x = y = 0U;\n     while (y < height) {\n         int c = getc(IN);\n         if (c == EOF) {\n            return OPJ_FALSE;\n        }\n        if (c) {\n            int j, c1_int;\n            OPJ_UINT8 c1;\n            c1_int = getc(IN);\n            if (c1_int == EOF) {\n                return OPJ_FALSE;\n            }\n            c1 = (OPJ_UINT8)c1_int;\n             for (j = 0; (j < c) && (x < width) &&\n                     ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                 *pix = c1;\n             }\n         } else {\n             c = getc(IN);\n            if (c == EOF) {\n                return OPJ_FALSE;\n            }\n            if (c == 0x00) { \n                x = 0;\n                ++y;\n                pix = pData + y * stride + x;\n            } else if (c == 0x01) { \n                break;\n            } else if (c == 0x02) { \n                c = getc(IN);\n                if (c == EOF) {\n                    return OPJ_FALSE;\n                }\n                x += (OPJ_UINT32)c;\n                c = getc(IN);\n                if (c == EOF) {\n                    return OPJ_FALSE;\n                }\n                y += (OPJ_UINT32)c;\n                pix = pData + y * stride + x;\n            } else { \n                int j;\n                for (j = 0; (j < c) && (x < width) &&\n                        ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                    int c1_int;\n                    OPJ_UINT8 c1;\n                    c1_int = getc(IN);\n                    if (c1_int == EOF) {\n                        return OPJ_FALSE;\n                     }\n                     c1 = (OPJ_UINT8)c1_int;\n                     *pix = c1;\n                 }\n                 if ((OPJ_UINT32)c & 1U) { \n                     c = getc(IN);\n                    if (c == EOF) {\n                        return OPJ_FALSE;\n                    }\n                }\n             }\n         }\n     }\n     return OPJ_TRUE;\n }", "target": 1}
{"code": "void __qdisc_run(struct net_device *dev)\n{\n\tdo {\n\t\tif (!qdisc_restart(dev))\n\t\t\tbreak;\n\t} while (!netif_queue_stopped(dev));\n\tclear_bit(__LINK_STATE_QDISC_RUNNING, &dev->state);\n}", "target": 1}
{"code": "int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,\n                      const unsigned char *in, int inl)\n{\n    int fix_len, cmpl = inl;\n    unsigned int b;\n    if (ctx->encrypt) {\n        EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_INVALID_OPERATION);\n        return 0;\n    }\n    b = ctx->cipher->block_size;\n    if (EVP_CIPHER_CTX_test_flags(ctx, EVP_CIPH_FLAG_LENGTH_BITS))\n        cmpl = (cmpl + 7) / 8;\n    if (inl < 0\n            || (inl == 0\n                && EVP_CIPHER_mode(ctx->cipher) != EVP_CIPH_CCM_MODE)) {\n        *outl = 0;\n        return inl == 0;\n    }\n    if (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER) {\n        if (b == 1 && is_partially_overlapping(out, in, cmpl)) {\n            EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_PARTIALLY_OVERLAPPING);\n            return 0;\n        }\n        fix_len = ctx->cipher->do_cipher(ctx, out, in, inl);\n        if (fix_len < 0) {\n            *outl = 0;\n            return 0;\n        } else\n            *outl = fix_len;\n        return 1;\n    }\n    if (ctx->flags & EVP_CIPH_NO_PADDING)\n        return evp_EncryptDecryptUpdate(ctx, out, outl, in, inl);\n    OPENSSL_assert(b <= sizeof(ctx->final));\n    if (ctx->final_used) {\n        if (((PTRDIFF_T)out == (PTRDIFF_T)in)\n            || is_partially_overlapping(out, in, b)) {\n            EVPerr(EVP_F_EVP_DECRYPTUPDATE, EVP_R_PARTIALLY_OVERLAPPING);\n            return 0;\n        }\n        memcpy(out, ctx->final, b);\n        out += b;\n        fix_len = 1;\n    } else\n        fix_len = 0;\n    if (!evp_EncryptDecryptUpdate(ctx, out, outl, in, inl))\n        return 0;\n    if (b > 1 && !ctx->buf_len) {\n        *outl -= b;\n        ctx->final_used = 1;\n        memcpy(ctx->final, &out[*outl], b);\n    } else\n        ctx->final_used = 0;\n    if (fix_len)\n        *outl += b;\n    return 1;\n}", "target": 1}
{"code": "read_packet(int fd, gss_buffer_t buf, int timeout, int first)\n{\n\tint\t  ret;\n\tstatic uint32_t\t\tlen = 0;\n\tstatic char\t\tlen_buf[4];\n\tstatic int\t\tlen_buf_pos = 0;\n\tstatic char *\t\ttmpbuf = 0;\n\tstatic int\t\ttmpbuf_pos = 0;\n\tif (first) {\n\t\tlen_buf_pos = 0;\n\t\treturn -2;\n\t}\n\tif (len_buf_pos < 4) {\n\t\tret = timed_read(fd, &len_buf[len_buf_pos], 4 - len_buf_pos,\n\t\t    timeout);\n\t\tif (ret == -1) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n \t\t\t\treturn -2;\n \t\t\tLOG(LOG_ERR, (\"%s\", strerror(errno)));\n\t\t\treturn -1;\n \t\t}\n \t\tif (ret == 0) {\t\t\n\t\t\tif (len_buf_pos == 0)\n\t\t\t\treturn 0;\n \t\t\tLOG(LOG_INFO, (\"EOF reading packet len\"));\n\t\t\treturn -1;\n \t\t}\n \t\tlen_buf_pos += ret;\n\t}\n\tif (len_buf_pos != 4)\n\t\treturn -2;\n\tlen = ntohl(*(uint32_t *)len_buf);\n \tif (len > GSTD_MAXPACKETCONTENTS + 512) {\n \t\tLOG(LOG_ERR, (\"ridiculous length, %ld\", len));\n\t\treturn -1;\n \t}\n \tif (!tmpbuf) {\n \t\tif ((tmpbuf = malloc(len)) == NULL) {\n \t\t\tLOG(LOG_CRIT, (\"malloc failure, %ld bytes\", len));\n\t\t\treturn -1;\n \t\t}\n \t}\n \tret = timed_read(fd, tmpbuf + tmpbuf_pos, len - tmpbuf_pos, timeout);\n \tif (ret == -1) {\n \t\tif (errno == EINTR || errno == EAGAIN)\n \t\t\treturn -2;\n \t\tLOG(LOG_ERR, (\"%s\", strerror(errno)));\n\t\treturn -1;\n \t}\n \tif (ret == 0) {\n \t\tLOG(LOG_ERR, (\"EOF while reading packet (len=%d)\", len));\n\t\treturn -1;\n \t}\n \ttmpbuf_pos += ret;\n\tif (tmpbuf_pos == len) {\n\t\tbuf->length = len;\n\t\tbuf->value = tmpbuf;\n\t\tlen = len_buf_pos = tmpbuf_pos = 0;\n\t\ttmpbuf = NULL;\n\t\tLOG(LOG_DEBUG, (\"read packet of length %d\", buf->length));\n\t\treturn 1;\n \t}\n \treturn -2;\n }", "target": 1}
{"code": "void RenderLayerCompositor::frameViewDidScroll()\n{\n    FrameView* frameView = m_renderView->frameView();\n    IntPoint scrollPosition = frameView->scrollPosition();\n    if (!m_scrollLayer)\n        return;\n    bool scrollingCoordinatorHandlesOffset = false;\n    if (ScrollingCoordinator* scrollingCoordinator = this->scrollingCoordinator()) {\n        if (Settings* settings = m_renderView->document().settings()) {\n            if (isMainFrame() || settings->compositedScrollingForFramesEnabled())\n                scrollingCoordinatorHandlesOffset = scrollingCoordinator->scrollableAreaScrollLayerDidChange(frameView);\n        }\n    }\n    if (scrollingCoordinatorHandlesOffset)\n        m_scrollLayer->setPosition(-frameView->minimumScrollPosition());\n    else\n        m_scrollLayer->setPosition(-scrollPosition);\n    blink::Platform::current()->histogramEnumeration(\"Renderer.AcceleratedFixedRootBackground\",\n        ScrolledMainFrameBucket,\n        AcceleratedFixedRootBackgroundHistogramMax);\n     if (!m_renderView->rootBackgroundIsEntirelyFixed())\n         return;\n     blink::Platform::current()->histogramEnumeration(\"Renderer.AcceleratedFixedRootBackground\",\n         !!fixedRootBackgroundLayer()\n             ? ScrolledMainFrameWithAcceleratedFixedRootBackground\n            : ScrolledMainFrameWithUnacceleratedFixedRootBackground,\n        AcceleratedFixedRootBackgroundHistogramMax);\n}", "target": 1}
{"code": "static bool new_idmap_permitted(const struct file *file, \n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *new_map)\n{\n\tif ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {\n \t\tu32 id = new_map->extent[0].lower_first;\n \t\tif (cap_setid == CAP_SETUID) {\n \t\t\tkuid_t uid = make_kuid(ns->parent, id);\n\t\t\tif (uid_eq(uid, current_fsuid()))\n \t\t\t\treturn true;\n \t\t}\n \t\telse if (cap_setid == CAP_SETGID) {\n \t\t\tkgid_t gid = make_kgid(ns->parent, id);\n\t\t\tif (gid_eq(gid, current_fsgid()))\n \t\t\t\treturn true;\n \t\t}\n \t}\n\tif (!cap_valid(cap_setid))\n\t\treturn true;\n\tif (ns_capable(ns->parent, cap_setid) &&\n\t    file_ns_capable(file, ns->parent, cap_setid))\n\t\treturn true;\n\treturn false;\n}", "target": 1}
{"code": "writepid (const char* pidfile, pid_t pid)\n{\n\tFILE* f;\n\tif ((f = fopen(pidfile, \"w\")) ==  NULL ) {\n\t\tlog_err(\"cannot open pidfile %s: %s\", \n\t\t\tpidfile, strerror(errno));\n\t\treturn;\n\t}\n\tif(fprintf(f, \"%lu\\n\", (unsigned long)pid) < 0) {\n\t\tlog_err(\"cannot write to pidfile %s: %s\", \n\t\t\tpidfile, strerror(errno));\n\t}\n\tfclose(f);\n}", "target": 1}
{"code": "getln(int fd, char *buf, size_t bufsiz, int feedback,\n    enum tgetpass_errval *errval)\n{\n    size_t left = bufsiz;\n    ssize_t nr = -1;\n    char *cp = buf;\n    char c = '\\0';\n    debug_decl(getln, SUDO_DEBUG_CONV);\n    *errval = TGP_ERRVAL_NOERROR;\n    if (left == 0) {\n\t*errval = TGP_ERRVAL_READERROR;\n\terrno = EINVAL;\n\tdebug_return_str(NULL);\t\t\n    }\n    while (--left) {\n\tnr = read(fd, &c, 1);\n\tif (nr != 1 || c == '\\n' || c == '\\r')\n\t    break;\n\tif (feedback) {\n\t    if (c == sudo_term_eof) {\n\t\tnr = 0;\n\t\tbreak;\n\t    } else if (c == sudo_term_kill) {\n\t\twhile (cp > buf) {\n\t\t    if (write(fd, \"\\b \\b\", 3) == -1)\n\t\t\tbreak;\n\t\t    --cp;\n\t\t}\n\t\tleft = bufsiz;\n\t\tcontinue;\n\t    } else if (c == sudo_term_erase) {\n\t\tif (cp > buf) {\n\t\t    if (write(fd, \"\\b \\b\", 3) == -1)\n\t\t\tbreak;\n\t\t    --cp;\n\t\t    left++;\n\t\t}\n\t\tcontinue;\n\t    }\n\t    ignore_result(write(fd, \"*\", 1));\n\t}\n\t*cp++ = c;\n    }\n    *cp = '\\0';\n    if (feedback) {\n\twhile (cp > buf) {\n\t    if (write(fd, \"\\b \\b\", 3) == -1)\n\t\tbreak;\n\t    --cp;\n\t}\n    }\n    switch (nr) {\n    case -1:\n\tif (errno == EINTR) {\n\t    if (signo[SIGALRM] == 1)\n\t\t*errval = TGP_ERRVAL_TIMEOUT;\n\t} else {\n\t    *errval = TGP_ERRVAL_READERROR;\n\t}\n\tdebug_return_str(NULL);\n    case 0:\n\tif (left == bufsiz - 1) {\n\t    *errval = TGP_ERRVAL_NOPASSWORD;\n\t    debug_return_str(NULL);\n\t}\n    default:\n\tdebug_return_str_masked(buf);\n    }\n}", "target": 1}
{"code": "static void credential_write_item(FILE *fp, const char *key, const char *value)\n{\n\tif (!value)\n\t\treturn;\n\tfprintf(fp, \"%s=%s\\n\", key, value);\n}", "target": 1}
{"code": "   Send an email message */\nPHP_FUNCTION(imap_mail)\n{\n\tchar *to=NULL, *message=NULL, *headers=NULL, *subject=NULL, *cc=NULL, *bcc=NULL, *rpath=NULL;\n\tint to_len, message_len, headers_len, subject_len, cc_len, bcc_len, rpath_len, argc = ZEND_NUM_ARGS();\n\tif (zend_parse_parameters(argc TSRMLS_CC, \"sss|ssss\", &to, &to_len, &subject, &subject_len, &message, &message_len,\n\t\t&headers, &headers_len, &cc, &cc_len, &bcc, &bcc_len, &rpath, &rpath_len) == FAILURE) {\n\t\treturn;\n\t}\n\tif (!to_len) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"No to field in mail command\");\n\t\tRETURN_FALSE;\n\t}\n\tif (!subject_len) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"No subject field in mail command\");\n\t\tRETURN_FALSE;\n\t}\n\tif (!message_len) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"No message string in mail command\");\n\t\tmessage = NULL;\n\t}\n\tif (_php_imap_mail(to, subject, message, headers, cc, bcc, rpath TSRMLS_CC)) {\n\t\tRETURN_TRUE;\n\t} else {\n\t\tRETURN_FALSE;\n\t}", "target": 1}
{"code": "static int cbs_av1_read_uvlc(CodedBitstreamContext *ctx, GetBitContext *gbc,\n                             const char *name, uint32_t *write_to,\n                             uint32_t range_min, uint32_t range_max)\n{\n    uint32_t value;\n    int position, zeroes, i, j;\n    char bits[65];\n    if (ctx->trace_enable)\n        position = get_bits_count(gbc);\n    zeroes = i = 0;\n    while (1) {\n        if (get_bits_left(gbc) < zeroes + 1) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"\n                   \"%s: bitstream ended.\\n\", name);\n            return AVERROR_INVALIDDATA;\n        }\n        if (get_bits1(gbc)) {\n            bits[i++] = '1';\n            break;\n        } else {\n            bits[i++] = '0';\n            ++zeroes;\n        }\n    }\n    if (zeroes >= 32) {\n        value = MAX_UINT_BITS(32);\n    } else {\n        value = get_bits_long(gbc, zeroes);\n        for (j = 0; j < zeroes; j++)\n            bits[i++] = (value >> (zeroes - j - 1) & 1) ? '1' : '0';\n        value += (1 << zeroes) - 1;\n    }\n    if (ctx->trace_enable) {\n        bits[i] = 0;\n        ff_cbs_trace_syntax_element(ctx, position, name, NULL,\n                                    bits, value);\n    }\n    if (value < range_min || value > range_max) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"%s out of range: \"\n               \"%\"PRIu32\", but must be in [%\"PRIu32\",%\"PRIu32\"].\\n\",\n               name, value, range_min, range_max);\n        return AVERROR_INVALIDDATA;\n    }\n    *write_to = value;\n    return 0;\n}", "target": 1}
{"code": "static int br_multicast_add_group(struct net_bridge *br,\n\t\t\t\t  struct net_bridge_port *port,\n\t\t\t\t  struct br_ip *group)\n{\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tunsigned long now = jiffies;\n\tint err;\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) ||\n\t    (port && port->state == BR_STATE_DISABLED))\n\t\tgoto out;\n\tmp = br_multicast_new_group(br, port, group);\n\terr = PTR_ERR(mp);\n\tif (IS_ERR(mp))\n \t\tgoto err;\n \tif (!port) {\n\t\thlist_add_head(&mp->mglist, &br->mglist);\n \t\tmod_timer(&mp->timer, now + br->multicast_membership_interval);\n \t\tgoto out;\n \t}\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p->port == port)\n\t\t\tgoto found;\n\t\tif ((unsigned long)p->port < (unsigned long)port)\n\t\t\tbreak;\n\t}\n\tp = kzalloc(sizeof(*p), GFP_ATOMIC);\n\terr = -ENOMEM;\n\tif (unlikely(!p))\n\t\tgoto err;\n\tp->addr = *group;\n\tp->port = port;\n\tp->next = *pp;\n\thlist_add_head(&p->mglist, &port->mglist);\n\tsetup_timer(&p->timer, br_multicast_port_group_expired,\n\t\t    (unsigned long)p);\n\tsetup_timer(&p->query_timer, br_multicast_port_group_query_expired,\n\t\t    (unsigned long)p);\n\trcu_assign_pointer(*pp, p);\nfound:\n\tmod_timer(&p->timer, now + br->multicast_membership_interval);\nout:\n\terr = 0;\nerr:\n\tspin_unlock(&br->multicast_lock);\n\treturn err;\n}", "target": 1}
{"code": " struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,\n \t\t\t\t\t\tint port)\n {\n\tunsigned long flags;\n\tstruct snd_seq_client_port *new_port, *p;\n\tint num = -1;\n\tif (snd_BUG_ON(!client))\n\t\treturn NULL;\n\tif (client->num_ports >= SNDRV_SEQ_MAX_PORTS) {\n\t\tpr_warn(\"ALSA: seq: too many ports for client %d\\n\", client->number);\n\t\treturn NULL;\n\t}\n\tnew_port = kzalloc(sizeof(*new_port), GFP_KERNEL);\n\tif (!new_port)\n\t\treturn NULL;\t\n\tnew_port->addr.client = client->number;\n\tnew_port->addr.port = -1;\n\tnew_port->owner = THIS_MODULE;\n\tsprintf(new_port->name, \"port-%d\", num);\n \tsnd_use_lock_init(&new_port->use_lock);\n \tport_subs_info_init(&new_port->c_src);\n \tport_subs_info_init(&new_port->c_dest);\n \tnum = port >= 0 ? port : 0;\n \tmutex_lock(&client->ports_mutex);\n\twrite_lock_irqsave(&client->ports_lock, flags);\n\tlist_for_each_entry(p, &client->ports_list_head, list) {\n\t\tif (p->addr.port > num)\n\t\t\tbreak;\n\t\tif (port < 0) \n\t\t\tnum = p->addr.port + 1;\n\t}\n \tlist_add_tail(&new_port->list, &p->list);\n \tclient->num_ports++;\n \tnew_port->addr.port = num;\t\n \twrite_unlock_irqrestore(&client->ports_lock, flags);\n \tmutex_unlock(&client->ports_mutex);\n\tsprintf(new_port->name, \"port-%d\", num);\n \treturn new_port;\n }", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& val = ctx->input(0);\n    int64 id = ctx->session_state()->GetNewId();\n    TensorStore::TensorAndKey tk{val, id, requested_device()};\n    OP_REQUIRES_OK(ctx, ctx->tensor_store()->AddTensor(name(), tk));\n    Tensor* handle = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({}), &handle));\n    if (ctx->expected_output_dtype(0) == DT_RESOURCE) {\n      ResourceHandle resource_handle = MakeResourceHandle<Tensor>(\n          ctx, SessionState::kTensorHandleResourceTypeName,\n          tk.GetHandle(name()));\n      resource_handle.set_maybe_type_name(\n          SessionState::kTensorHandleResourceTypeName);\n      handle->scalar<ResourceHandle>()() = resource_handle;\n    } else {\n      handle->flat<tstring>().setConstant(tk.GetHandle(name()));\n    }\n  }", "target": 1}
{"code": "  void Compute(OpKernelContext* c) override {\n    const Tensor& tag = c->input(0);\n    OP_REQUIRES(c, TensorShapeUtils::IsScalar(tag.shape()),\n                errors::InvalidArgument(\"tag must be scalar\"));\n    const Tensor& tensor = c->input(1);\n    const Tensor& serialized_summary_metadata_tensor = c->input(2);\n    Summary s;\n    Summary::Value* v = s.add_value();\n    v->set_tag(string(tag.scalar<tstring>()()));  \n    if (tensor.dtype() == DT_STRING) {\n      tensor.AsProtoField(v->mutable_tensor());\n    } else {\n      tensor.AsProtoTensorContent(v->mutable_tensor());\n    }\n    ParseFromTString(serialized_summary_metadata_tensor.scalar<tstring>()(),\n                     v->mutable_metadata());\n    Tensor* summary_tensor = nullptr;\n    OP_REQUIRES_OK(c, c->allocate_output(0, TensorShape({}), &summary_tensor));\n    CHECK(SerializeToTString(s, &summary_tensor->scalar<tstring>()()));\n  }", "target": 1}
{"code": "htmlParseComment(htmlParserCtxtPtr ctxt) {\n    xmlChar *buf = NULL;\n    int len;\n    int size = HTML_PARSER_BUFFER_SIZE;\n    int q, ql;\n    int r, rl;\n    int cur, l;\n    xmlParserInputState state;\n    if ((RAW != '<') || (NXT(1) != '!') ||\n        (NXT(2) != '-') || (NXT(3) != '-')) return;\n    state = ctxt->instate;\n    ctxt->instate = XML_PARSER_COMMENT;\n    SHRINK;\n    SKIP(4);\n    buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));\n    if (buf == NULL) {\n        htmlErrMemory(ctxt, \"buffer allocation failed\\n\");\n\tctxt->instate = state;\n\treturn;\n    }\n    q = CUR_CHAR(ql);\n    NEXTL(ql);\n    r = CUR_CHAR(rl);\n    NEXTL(rl);\n    cur = CUR_CHAR(l);\n    len = 0;\n    while (IS_CHAR(cur) &&\n           ((cur != '>') ||\n\t    (r != '-') || (q != '-'))) {\n\tif (len + 5 >= size) {\n\t    xmlChar *tmp;\n\t    size *= 2;\n\t    tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));\n\t    if (tmp == NULL) {\n\t        xmlFree(buf);\n\t        htmlErrMemory(ctxt, \"growing buffer failed\\n\");\n\t\tctxt->instate = state;\n\t\treturn;\n\t    }\n\t    buf = tmp;\n\t}\n\tCOPY_BUF(ql,buf,len,q);\n\tq = r;\n\tql = rl;\n\tr = cur;\n\trl = l;\n\tNEXTL(l);\n\tcur = CUR_CHAR(l);\n\tif (cur == 0) {\n\t    SHRINK;\n\t    GROW;\n\t    cur = CUR_CHAR(l);\n\t}\n    }\n    buf[len] = 0;\n    if (!IS_CHAR(cur)) {\n\thtmlParseErr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n\t             \"Comment not terminated \\n<!--%.50s\\n\", buf, NULL);\n\txmlFree(buf);\n    } else {\n        NEXT;\n\tif ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&\n\t    (!ctxt->disableSAX))\n\t    ctxt->sax->comment(ctxt->userData, buf);\n\txmlFree(buf);\n    }\n    ctxt->instate = state;\n}", "target": 1}
{"code": "String StringUtil::Implode(const Variant& items, const String& delim,\n                           const bool checkIsContainer ) {\n  if (checkIsContainer && !isContainer(items)) {\n    throw_param_is_not_container();\n  }\n  int size = getContainerSize(items);\n  if (size == 0) return empty_string();\n  req::vector<String> sitems;\n  sitems.reserve(size);\n  int len = 0;\n  int lenDelim = delim.size();\n  for (ArrayIter iter(items); iter; ++iter) {\n    sitems.emplace_back(iter.second().toString());\n    len += sitems.back().size() + lenDelim;\n  }\n  len -= lenDelim; \n  assert(sitems.size() == size);\n  String s = String(len, ReserveString);\n  char *buffer = s.mutableData();\n  const char *sdelim = delim.data();\n  char *p = buffer;\n  String &init_str = sitems[0];\n  int init_len = init_str.size();\n  memcpy(p, init_str.data(), init_len);\n  p += init_len;\n  for (int i = 1; i < size; i++) {\n    String &item = sitems[i];\n    memcpy(p, sdelim, lenDelim);\n    p += lenDelim;\n    int lenItem = item.size();\n    memcpy(p, item.data(), lenItem);\n    p += lenItem;\n  }\n  assert(p - buffer == len);\n  s.setSize(len);\n  return s;\n}", "target": 1}
{"code": "otError Commissioner::GeneratePskc(const char *              aPassPhrase,\n                                   const char *              aNetworkName,\n                                   const Mac::ExtendedPanId &aExtPanId,\n                                   Pskc &                    aPskc)\n{\n    otError     error      = OT_ERROR_NONE;\n    const char *saltPrefix = \"Thread\";\n    uint8_t     salt[OT_PBKDF2_SALT_MAX_LEN];\n    uint16_t    saltLen = 0;\n    VerifyOrExit((strlen(aPassPhrase) >= OT_COMMISSIONING_PASSPHRASE_MIN_SIZE) &&\n                     (strlen(aPassPhrase) <= OT_COMMISSIONING_PASSPHRASE_MAX_SIZE),\n                 error = OT_ERROR_INVALID_ARGS);\n    memset(salt, 0, sizeof(salt));\n    memcpy(salt, saltPrefix, strlen(saltPrefix));\n    saltLen += static_cast<uint16_t>(strlen(saltPrefix));\n    memcpy(salt + saltLen, aExtPanId.m8, sizeof(aExtPanId));\n    saltLen += OT_EXT_PAN_ID_SIZE;\n    memcpy(salt + saltLen, aNetworkName, strlen(aNetworkName));\n    saltLen += static_cast<uint16_t>(strlen(aNetworkName));\n    otPbkdf2Cmac(reinterpret_cast<const uint8_t *>(aPassPhrase), static_cast<uint16_t>(strlen(aPassPhrase)),\n                 reinterpret_cast<const uint8_t *>(salt), saltLen, 16384, OT_PSKC_MAX_SIZE, aPskc.m8);\nexit:\n    return error;\n}", "target": 1}
{"code": "static int rc4_hmac_md5_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg,\n                             void *ptr)\n{\n    EVP_RC4_HMAC_MD5 *key = data(ctx);\n    switch (type) {\n    case EVP_CTRL_AEAD_SET_MAC_KEY:\n        {\n            unsigned int i;\n            unsigned char hmac_key[64];\n            memset(hmac_key, 0, sizeof(hmac_key));\n            if (arg > (int)sizeof(hmac_key)) {\n                MD5_Init(&key->head);\n                MD5_Update(&key->head, ptr, arg);\n                MD5_Final(hmac_key, &key->head);\n            } else {\n                memcpy(hmac_key, ptr, arg);\n            }\n            for (i = 0; i < sizeof(hmac_key); i++)\n                hmac_key[i] ^= 0x36; \n            MD5_Init(&key->head);\n            MD5_Update(&key->head, hmac_key, sizeof(hmac_key));\n            for (i = 0; i < sizeof(hmac_key); i++)\n                hmac_key[i] ^= 0x36 ^ 0x5c; \n            MD5_Init(&key->tail);\n            MD5_Update(&key->tail, hmac_key, sizeof(hmac_key));\n            OPENSSL_cleanse(hmac_key, sizeof(hmac_key));\n            return 1;\n        }\n    case EVP_CTRL_AEAD_TLS1_AAD:\n        {\n            unsigned char *p = ptr;\n            unsigned int len;\n            if (arg != EVP_AEAD_TLS1_AAD_LEN)\n                return -1;\n            len = p[arg - 2] << 8 | p[arg - 1];\n            if (!EVP_CIPHER_CTX_encrypting(ctx)) {\n                len -= MD5_DIGEST_LENGTH;\n                p[arg - 2] = len >> 8;\n                p[arg - 1] = len;\n            }\n            key->payload_length = len;\n            key->md = key->head;\n            MD5_Update(&key->md, p, arg);\n            return MD5_DIGEST_LENGTH;\n        }\n    default:\n        return -1;\n    }\n}", "target": 1}
{"code": "static void coroutine_fn mirror_wait_on_conflicts(MirrorOp *self,\n                                                  MirrorBlockJob *s,\n                                                  uint64_t offset,\n                                                  uint64_t bytes)\n{\n    uint64_t self_start_chunk = offset / s->granularity;\n    uint64_t self_end_chunk = DIV_ROUND_UP(offset + bytes, s->granularity);\n    uint64_t self_nb_chunks = self_end_chunk - self_start_chunk;\n    while (find_next_bit(s->in_flight_bitmap, self_end_chunk,\n                         self_start_chunk) < self_end_chunk &&\n           s->ret >= 0)\n    {\n        MirrorOp *op;\n        QTAILQ_FOREACH(op, &s->ops_in_flight, next) {\n            uint64_t op_start_chunk = op->offset / s->granularity;\n            uint64_t op_nb_chunks = DIV_ROUND_UP(op->offset + op->bytes,\n                                                 s->granularity) -\n                                    op_start_chunk;\n            if (op == self) {\n                continue;\n            }\n            if (ranges_overlap(self_start_chunk, self_nb_chunks,\n                               op_start_chunk, op_nb_chunks))\n            {\n                if (op->waiting_for_op) {\n                    continue;\n                }\n                self->waiting_for_op = op;\n                qemu_co_queue_wait(&op->waiting_requests, NULL);\n                self->waiting_for_op = NULL;\n                break;\n            }\n        }\n    }\n}", "target": 1}
{"code": "static inline long div_ll_X_l_rem(long long divs, long div, long *rem)\n{\n\tlong dum2;\n\tasm(\"divl %2\":\"=a\"(dum2), \"=d\"(*rem)\n\t    : \"rm\"(div), \"A\"(divs));\n\treturn dum2;\n}", "target": 1}
{"code": "void TensorSliceReader::LoadShard(int shard) const {\n  CHECK_LT(shard, sss_.size());\n  if (sss_[shard] || !status_.ok()) {\n    return;  \n  }\n  string value;\n  SavedTensorSlices sts;\n  const string fname = fnames_[shard];\n  VLOG(1) << \"Reading meta data from file \" << fname << \"...\";\n  Table* table;\n  Status s = open_function_(fname, &table);\n  if (!s.ok()) {\n    status_ = errors::DataLoss(\"Unable to open table file \", fname, \": \",\n                               s.ToString());\n    return;\n  }\n  sss_[shard].reset(table);\n  if (!(table->Get(kSavedTensorSlicesKey, &value) &&\n        ParseProtoUnlimited(&sts, value))) {\n    status_ = errors::Internal(\n        \"Failed to find the saved tensor slices at the beginning of the \"\n        \"checkpoint file: \",\n        fname);\n    return;\n  }\n  status_ = CheckVersions(sts.meta().versions(), TF_CHECKPOINT_VERSION,\n                          TF_CHECKPOINT_VERSION_MIN_PRODUCER, \"Checkpoint\",\n                          \"checkpoint\");\n  if (!status_.ok()) return;\n  for (const SavedSliceMeta& ssm : sts.meta().tensor()) {\n    TensorShape ssm_shape;\n    status_ = TensorShape::BuildTensorShapeBase(ssm.shape(), &ssm_shape);\n    if (!status_.ok()) return;\n    for (const TensorSliceProto& tsp : ssm.slice()) {\n      TensorSlice ss_slice(tsp);\n      status_ = RegisterTensorSlice(ssm.name(), ssm_shape, ssm.type(), fname,\n                                    ss_slice, &tensors_);\n      if (!status_.ok()) return;\n    }\n  }\n}", "target": 1}
{"code": "static int l2tp_ip_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n\t\t\t   size_t len, int noblock, int flags, int *addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;\n\tstruct sk_buff *skb;\n \tif (flags & MSG_OOB)\n \t\tgoto out;\n\tif (addr_len)\n\t\t*addr_len = sizeof(*sin);\n \tskb = skb_recv_datagram(sk, flags, noblock, &err);\n \tif (!skb)\n \t\tgoto out;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto done;\n\tsock_recv_timestamp(msg, sk, skb);\n\tif (sin) {\n\t\tsin->sin_family = AF_INET;\n \t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n \t\tsin->sin_port = 0;\n \t\tmemset(&sin->sin_zero, 0, sizeof(sin->sin_zero));\n \t}\n \tif (inet->cmsg_flags)\n \t\tip_cmsg_recv(msg, skb);\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err ? err : copied;\n}", "target": 1}
{"code": "char *enl_ipc_get(const char *msg_data)\n {\n \tstatic char *message = NULL;\n\tstatic unsigned short len = 0;\n \tchar buff[13], *ret_msg = NULL;\n \tregister unsigned char i;\n \tunsigned char blen;\n\tif (msg_data == IPC_TIMEOUT) {\n\t\treturn(IPC_TIMEOUT);\n\t}\n\tfor (i = 0; i < 12; i++) {\n\t\tbuff[i] = msg_data[i];\n\t}\n\tbuff[12] = 0;\n\tblen = strlen(buff);\n\tif (message != NULL) {\n\t\tlen += blen;\n\t\tmessage = (char *) erealloc(message, len + 1);\n\t\tstrcat(message, buff);\n\t} else {\n\t\tlen = blen;\n\t\tmessage = (char *) emalloc(len + 1);\n\t\tstrcpy(message, buff);\n\t}\n\tif (blen < 12) {\n\t\tret_msg = message;\n\t\tmessage = NULL;\n\t\tD((\"Received complete reply:  \\\"%s\\\"\\n\", ret_msg));\n\t}\n\treturn(ret_msg);\n}", "target": 1}
{"code": "tiff12_print_page(gx_device_printer * pdev, gp_file * file)\n{\n    gx_device_tiff *const tfdev = (gx_device_tiff *)pdev;\n    int code;\n    if (gdev_prn_file_is_new(pdev)) {\n        tfdev->tif = tiff_from_filep(pdev, pdev->dname, file, tfdev->BigEndian, tfdev->UseBigTIFF);\n        if (!tfdev->tif)\n            return_error(gs_error_invalidfileaccess);\n    }\n    code = gdev_tiff_begin_page(tfdev, file);\n    if (code < 0)\n        return code;\n    TIFFSetField(tfdev->tif, TIFFTAG_BITSPERSAMPLE, 4);\n    tiff_set_rgb_fields(tfdev);\n    TIFFCheckpointDirectory(tfdev->tif);\n    {\n        int y;\n        int size = gdev_prn_raster(pdev);\n        byte *data = gs_alloc_bytes(pdev->memory, size, \"tiff12_print_page\");\n        if (data == 0)\n            return_error(gs_error_VMerror);\n        memset(data, 0, size);\n        for (y = 0; y < pdev->height; ++y) {\n            const byte *src;\n            byte *dest;\n            int x;\n            code = gdev_prn_copy_scan_lines(pdev, y, data, size);\n            if (code < 0)\n                break;\n            for (src = data, dest = data, x = 0; x < size;\n                 src += 6, dest += 3, x += 6\n                ) {\n                dest[0] = (src[0] & 0xf0) | (src[1] >> 4);\n                dest[1] = (src[2] & 0xf0) | (src[3] >> 4);\n                dest[2] = (src[4] & 0xf0) | (src[5] >> 4);\n            }\n            TIFFWriteScanline(tfdev->tif, data, y, 0);\n        }\n        gs_free_object(pdev->memory, data, \"tiff12_print_page\");\n        TIFFWriteDirectory(tfdev->tif);\n    }\n    return code;\n}", "target": 1}
{"code": "static __inline__ int scm_check_creds(struct ucred *creds)\n{\n\tconst struct cred *cred = current_cred();\n\tkuid_t uid = make_kuid(cred->user_ns, creds->uid);\n\tkgid_t gid = make_kgid(cred->user_ns, creds->gid);\n \tif (!uid_valid(uid) || !gid_valid(gid))\n \t\treturn -EINVAL;\n\tif ((creds->pid == task_tgid_vnr(current) || nsown_capable(CAP_SYS_ADMIN)) &&\n \t    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||\n \t      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&\n \t    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||\n\t      gid_eq(gid, cred->sgid)) || nsown_capable(CAP_SETGID))) {\n\t       return 0;\n\t}\n\treturn -EPERM;\n}", "target": 1}
{"code": "vhost_user_check_and_alloc_queue_pair(struct virtio_net *dev,\n\t\t\tstruct VhostUserMsg *msg)\n{\n\tuint16_t vring_idx;\n\tswitch (msg->request.master) {\n\tcase VHOST_USER_SET_VRING_KICK:\n\tcase VHOST_USER_SET_VRING_CALL:\n\tcase VHOST_USER_SET_VRING_ERR:\n\t\tvring_idx = msg->payload.u64 & VHOST_USER_VRING_IDX_MASK;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_NUM:\n\tcase VHOST_USER_SET_VRING_BASE:\n\tcase VHOST_USER_SET_VRING_ENABLE:\n\t\tvring_idx = msg->payload.state.index;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_ADDR:\n\t\tvring_idx = msg->payload.addr.index;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (vring_idx >= VHOST_MAX_VRING) {\n\t\tVHOST_LOG_CONFIG(ERR,\n\t\t\t\"invalid vring index: %u\\n\", vring_idx);\n\t\treturn -1;\n\t}\n\tif (dev->virtqueue[vring_idx])\n\t\treturn 0;\n\treturn alloc_vring_queue(dev, vring_idx);\n}", "target": 1}
{"code": " static int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)\n {\n\tstruct sockaddr_rc *sa = (struct sockaddr_rc *) addr;\n \tstruct sock *sk = sock->sk;\n\tint chan = sa->rc_channel;\n\tint err = 0;\n\tBT_DBG(\"sk %p %pMR\", sk, &sa->rc_bdaddr);\n \tif (!addr || addr->sa_family != AF_BLUETOOTH)\n \t\treturn -EINVAL;\n \tlock_sock(sk);\n \tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\tif (sk->sk_type != SOCK_STREAM) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n \twrite_lock(&rfcomm_sk_list.lock);\n\tif (chan && __rfcomm_get_listen_sock_by_addr(chan, &sa->rc_bdaddr)) {\n \t\terr = -EADDRINUSE;\n \t} else {\n\t\tbacpy(&rfcomm_pi(sk)->src, &sa->rc_bdaddr);\n\t\trfcomm_pi(sk)->channel = chan;\n \t\tsk->sk_state = BT_BOUND;\n \t}\n\twrite_unlock(&rfcomm_sk_list.lock);\ndone:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 1}
{"code": " static byte parseHexByte(const char * &str) {\n     byte b = parseHexChar(str[0]);\n    if (str[1] == ':' || str[1] == '\\0') {\n        str += 2;\n        return b;\n     } else {\n         b = b << 4 | parseHexChar(str[1]);\n        str += 3;\n        return b;\n     }\n }", "target": 1}
{"code": "void LanLinkProvider::newConnection()\n{\n    qCDebug(KDECONNECT_CORE) << \"LanLinkProvider newConnection\";\n    while (m_server->hasPendingConnections()) {\n        QSslSocket* socket = m_server->nextPendingConnection();\n        configureSocket(socket);\n        connect(socket, &QAbstractSocket::disconnected,\n                socket, &QObject::deleteLater);\n        connect(socket, &QIODevice::readyRead,\n                this, &LanLinkProvider::dataReceived);\n    }\n}", "target": 1}
{"code": "static void add_password(AUTH_HDR *request, unsigned char type, CONST char *password, char *secret)\n{\n\tMD5_CTX md5_secret, my_md5;\n\tunsigned char misc[AUTH_VECTOR_LEN];\n\tint i;\n\tint length = strlen(password);\n\tunsigned char hashed[256 + AUTH_PASS_LEN];\t\n\tunsigned char *vector;\n\tattribute_t *attr;\n\tif (length > MAXPASS) {\t\t\t\t\n\t\tlength = MAXPASS;\n\t}\n\tif (length == 0) {\n\t\tlength = AUTH_PASS_LEN;\t\t\t\n\t} if ((length & (AUTH_PASS_LEN - 1)) != 0) {\n\t\tlength += (AUTH_PASS_LEN - 1);\t\t\n\t\tlength &= ~(AUTH_PASS_LEN - 1);\t\t\n\t}\t\t\t\t\t\t\n\tmemset(hashed, 0, length);\n\tmemcpy(hashed, password, strlen(password));\n\tattr = find_attribute(request, PW_PASSWORD);\n\tif (type == PW_PASSWORD) {\n\t\tvector = request->vector;\n\t} else {\n\t\tvector = attr->data;\t\t\t\n\t}\n\tMD5Init(&md5_secret);\n\tMD5Update(&md5_secret, (unsigned char *) secret, strlen(secret));\n\tmy_md5 = md5_secret;\t\t\t\t\n\tMD5Update(&my_md5, vector, AUTH_VECTOR_LEN);\n\tMD5Final(misc, &my_md5);\t\t\t\n\txor(hashed, misc, AUTH_PASS_LEN);\n\tfor (i = 1; i < (length >> 4); i++) {\n\t\tmy_md5 = md5_secret;\t\t\t\n\t\tMD5Update(&my_md5, &hashed[(i-1) * AUTH_PASS_LEN], AUTH_PASS_LEN);\n\t\tMD5Final(misc, &my_md5);\t\t\t\n\t\txor(&hashed[i * AUTH_PASS_LEN], misc, AUTH_PASS_LEN);\n\t}\n\tif (type == PW_OLD_PASSWORD) {\n\t\tattr = find_attribute(request, PW_OLD_PASSWORD);\n\t}\n\tif (!attr) {\n\t\tadd_attribute(request, type, hashed, length);\n\t} else {\n\t\tmemcpy(attr->data, hashed, length); \n\t}\n}", "target": 1}
{"code": "static void record_init(node_t * n)\n{\n    field_t *info;\n    pointf ul, sz;\n    int flip, len;\n    char *textbuf;\t\t\n    int sides = BOTTOM | RIGHT | TOP | LEFT;\n    flip = NOT(GD_realflip(agraphof(n)));\n    reclblp = ND_label(n)->text;\n    len = strlen(reclblp);\n    len = MAX(len, 1);\n    textbuf = N_NEW(len + 1, char);\n    if (!(info = parse_reclbl(n, flip, TRUE, textbuf))) {\n\tagerr(AGERR, \"bad label format %s\\n\", ND_label(n)->text);\n\treclblp = \"\\\\N\";\n\tinfo = parse_reclbl(n, flip, TRUE, textbuf);\n    }\n    free(textbuf);\n    size_reclbl(n, info);\n    sz.x = POINTS(ND_width(n));\n    sz.y = POINTS(ND_height(n));\n    if (mapbool(late_string(n, N_fixed, \"false\"))) {\n\tif ((sz.x < info->size.x) || (sz.y < info->size.y)) {\n\t}\n    } else {\n\tsz.x = MAX(info->size.x, sz.x);\n\tsz.y = MAX(info->size.y, sz.y);\n    }\n    resize_reclbl(info, sz, mapbool(late_string(n, N_nojustify, \"false\")));\n    ul = pointfof(-sz.x / 2., sz.y / 2.);\t\n    pos_reclbl(info, ul, sides);\n    ND_width(n) = PS2INCH(info->size.x);\n    ND_height(n) = PS2INCH(info->size.y + 1);\t\n    ND_shape_info(n) = (void *) info;\n}", "target": 1}
{"code": " int __glXDispSwap_CreateContext(__GLXclientState *cl, GLbyte *pc)\n {\n     xGLXCreateContextReq *req = (xGLXCreateContextReq *) pc;\n     __GLX_DECLARE_SWAP_VARIABLES;\n     __GLX_SWAP_SHORT(&req->length);\n     __GLX_SWAP_INT(&req->context);\n     __GLX_SWAP_INT(&req->visual);\n    return __glXDisp_CreateContext(cl, pc);\n}", "target": 1}
{"code": "void kvm_io_bus_unregister_dev(struct kvm *kvm, enum kvm_bus bus_idx,\n\t\t\t       struct kvm_io_device *dev)\n{\n\tint i;\n\tstruct kvm_io_bus *new_bus, *bus;\n\tbus = kvm_get_bus(kvm, bus_idx);\n\tif (!bus)\n\t\treturn;\n\tfor (i = 0; i < bus->dev_count; i++)\n\t\tif (bus->range[i].dev == dev) {\n\t\t\tbreak;\n\t\t}\n\tif (i == bus->dev_count)\n\t\treturn;\n\tnew_bus = kmalloc(struct_size(bus, range, bus->dev_count - 1),\n\t\t\t  GFP_KERNEL_ACCOUNT);\n\tif (!new_bus)  {\n\t\tpr_err(\"kvm: failed to shrink bus, removing it completely\\n\");\n\t\tgoto broken;\n\t}\n\tmemcpy(new_bus, bus, sizeof(*bus) + i * sizeof(struct kvm_io_range));\n\tnew_bus->dev_count--;\n\tmemcpy(new_bus->range + i, bus->range + i + 1,\n\t       (new_bus->dev_count - i) * sizeof(struct kvm_io_range));\nbroken:\n\trcu_assign_pointer(kvm->buses[bus_idx], new_bus);\n\tsynchronize_srcu_expedited(&kvm->srcu);\n\tkfree(bus);\n\treturn;\n}", "target": 1}
{"code": " void ServerWrapper::OnHttpRequest(int connection_id,\n                                   const net::HttpServerRequestInfo& info) {\n   server_->SetSendBufferSize(connection_id, kSendBufferSizeForDevTools);\n   if (base::StartsWith(info.path, \"/json\", base::CompareCase::SENSITIVE)) {\n    BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,\n                            base::BindOnce(&DevToolsHttpHandler::OnJsonRequest,\n                                           handler_, connection_id, info));\n    return;\n  }\n  if (info.path.empty() || info.path == \"/\") {\n    BrowserThread::PostTask(\n        BrowserThread::UI, FROM_HERE,\n        base::BindOnce(&DevToolsHttpHandler::OnDiscoveryPageRequest, handler_,\n                       connection_id));\n    return;\n  }\n  if (!base::StartsWith(info.path, \"/devtools/\",\n                        base::CompareCase::SENSITIVE)) {\n    server_->Send404(connection_id, kDevtoolsHttpHandlerTrafficAnnotation);\n    return;\n  }\n  std::string filename = PathWithoutParams(info.path.substr(10));\n  std::string mime_type = GetMimeType(filename);\n  if (!debug_frontend_dir_.empty()) {\n    base::FilePath path = debug_frontend_dir_.AppendASCII(filename);\n    std::string data;\n    base::ReadFileToString(path, &data);\n    server_->Send200(connection_id, data, mime_type,\n                     kDevtoolsHttpHandlerTrafficAnnotation);\n    return;\n  }\n  if (bundles_resources_) {\n    BrowserThread::PostTask(\n        BrowserThread::UI, FROM_HERE,\n        base::BindOnce(&DevToolsHttpHandler::OnFrontendResourceRequest,\n                       handler_, connection_id, filename));\n    return;\n  }\n  server_->Send404(connection_id, kDevtoolsHttpHandlerTrafficAnnotation);\n}", "target": 1}
{"code": "bool ID3::removeUnsynchronizationV2_4(bool iTunesHack) {\n size_t oldSize = mSize;\n size_t offset = 0;\n while (mSize >= 10 && offset <= mSize - 10) {\n if (!memcmp(&mData[offset], \"\\0\\0\\0\\0\", 4)) {\n break;\n }\n size_t dataSize;\n if (iTunesHack) {\n            dataSize = U32_AT(&mData[offset + 4]);\n } else if (!ParseSyncsafeInteger(&mData[offset + 4], &dataSize)) {\n return false;\n }\n if (dataSize > mSize - 10 - offset) {\n return false;\n }\n uint16_t flags = U16_AT(&mData[offset + 8]);\n uint16_t prevFlags = flags;\n if (flags & 1) {\n if (mSize < 14 || mSize - 14 < offset || dataSize < 4) {\n return false;\n }\n            memmove(&mData[offset + 10], &mData[offset + 14], mSize - offset - 14);\n            mSize -= 4;\n            dataSize -= 4;\n            flags &= ~1;\n }\n if ((flags & 2) && (dataSize >= 2)) {\n size_t readOffset = offset + 11;\n size_t writeOffset = offset + 11;\n for (size_t i = 0; i + 1 < dataSize; ++i) {\n if (mData[readOffset - 1] == 0xff\n && mData[readOffset] == 0x00) {\n ++readOffset;\n                     --mSize;\n                     --dataSize;\n                 }\n                mData[writeOffset++] = mData[readOffset++];\n             }\n             if (readOffset <= oldSize) {\n                memmove(&mData[writeOffset], &mData[readOffset], oldSize - readOffset);\n } else {\n                ALOGE(\"b/34618607 (%zu %zu %zu %zu)\", readOffset, writeOffset, oldSize, mSize);\n                android_errorWriteLog(0x534e4554, \"34618607\");\n }\n }\n        flags &= ~2;\n if (flags != prevFlags || iTunesHack) {\n WriteSyncsafeInteger(&mData[offset + 4], dataSize);\n            mData[offset + 8] = flags >> 8;\n            mData[offset + 9] = flags & 0xff;\n }\n        offset += 10 + dataSize;\n }\n    memset(&mData[mSize], 0, oldSize - mSize);\n return true;\n}", "target": 1}
{"code": "SProcXSendExtensionEvent(ClientPtr client)\n {\n     CARD32 *p;\n     int i;\n    xEvent eventT;\n     xEvent *eventP;\n     EventSwapPtr proc;\n    REQUEST(xSendExtensionEventReq);\n    swaps(&stuff->length);\n    REQUEST_AT_LEAST_SIZE(xSendExtensionEventReq);\n    swapl(&stuff->destination);\n    swaps(&stuff->count);\n    if (stuff->length !=\n        bytes_to_int32(sizeof(xSendExtensionEventReq)) + stuff->count +\n        bytes_to_int32(stuff->num_events * sizeof(xEvent)))\n        return BadLength;\n    eventP = (xEvent *) &stuff[1];\n    for (i = 0; i < stuff->num_events; i++, eventP++) {\n        proc = EventSwapVector[eventP->u.u.type & 0177];\n        if (proc == NotImplemented)     \n            return BadValue;\n        (*proc) (eventP, &eventT);\n        *eventP = eventT;\n    }\n    p = (CARD32 *) (((xEvent *) &stuff[1]) + stuff->num_events);\n    SwapLongs(p, stuff->count);\n    return (ProcXSendExtensionEvent(client));\n}", "target": 1}
{"code": "int ssl3_get_new_session_ticket(SSL *s)\n{\n    int ok, al, ret = 0, ticklen;\n    long n;\n    const unsigned char *p;\n    unsigned char *d;\n    n = s->method->ssl_get_message(s,\n                                   SSL3_ST_CR_SESSION_TICKET_A,\n                                   SSL3_ST_CR_SESSION_TICKET_B,\n                                   SSL3_MT_NEWSESSION_TICKET, 16384, &ok);\n    if (!ok)\n        return ((int)n);\n    if (n < 6) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n    p = d = (unsigned char *)s->init_msg;\n    n2l(p, s->session->tlsext_tick_lifetime_hint);\n    n2s(p, ticklen);\n    if (ticklen + 6 != n) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n    if (s->session->tlsext_tick) {\n        OPENSSL_free(s->session->tlsext_tick);\n        s->session->tlsext_ticklen = 0;\n    }\n    s->session->tlsext_tick = OPENSSL_malloc(ticklen);\n    if (!s->session->tlsext_tick) {\n        SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    memcpy(s->session->tlsext_tick, p, ticklen);\n    s->session->tlsext_ticklen = ticklen;\n    EVP_Digest(p, ticklen,\n               s->session->session_id, &s->session->session_id_length,\n# ifndef OPENSSL_NO_SHA256\n               EVP_sha256(), NULL);\n# else\n               EVP_sha1(), NULL);\n# endif\n    ret = 1;\n    return (ret);\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n err:\n    s->state = SSL_ST_ERR;\n    return (-1);\n}", "target": 1}
{"code": "void Magick::Image::read(MagickCore::Image *image,\n  MagickCore::ExceptionInfo *exceptionInfo)\n{\n  if (image != (MagickCore::Image *) NULL &&\n      image->next != (MagickCore::Image *) NULL)\n    {\n      MagickCore::Image\n        *next;\n      next=image->next;\n      image->next=(MagickCore::Image *) NULL;\n      next->previous=(MagickCore::Image *) NULL;\n      DestroyImageList(next);\n    }\n  replaceImage(image);\n  if (exceptionInfo->severity == MagickCore::UndefinedException &&\n      image == (MagickCore::Image *) NULL)\n    {\n      (void) MagickCore::DestroyExceptionInfo(exceptionInfo);\n      if (!quiet())\n        throwExceptionExplicit(MagickCore::ImageWarning,\n          \"No image was loaded.\");\n    }\n  ThrowImageException;\n}", "target": 1}
{"code": "static RList *symbols(RBinFile *bf) {\n\tRList *res = r_list_newf ((RListFree)r_bin_symbol_free);\n\tr_return_val_if_fail (res && bf->o && bf->o->bin_obj, res);\n\tRCoreSymCacheElement *element = bf->o->bin_obj;\n\tsize_t i;\n\tHtUU *hash = ht_uu_new0 ();\n\tif (!hash) {\n\t\treturn res;\n\t}\n\tbool found = false;\n\tfor (i = 0; i < element->hdr->n_lined_symbols; i++) {\n\t\tRCoreSymCacheElementSymbol *sym = (RCoreSymCacheElementSymbol *)&element->lined_symbols[i];\n\t\tht_uu_find (hash, sym->paddr, &found);\n\t\tif (found) {\n\t\t\tcontinue;\n\t\t}\n\t\tRBinSymbol *s = bin_symbol_from_symbol (element, sym);\n\t\tif (s) {\n\t\t\tr_list_append (res, s);\n\t\t\tht_uu_insert (hash, sym->paddr, 1);\n\t\t}\n\t}\n\tif (element->symbols) {\n\t\tfor (i = 0; i < element->hdr->n_symbols; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = &element->symbols[i];\n\t\t\tht_uu_find (hash, sym->paddr, &found);\n\t\t\tif (found) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRBinSymbol *s = bin_symbol_from_symbol (element, sym);\n\t\t\tif (s) {\n\t\t\t\tr_list_append (res, s);\n\t\t\t}\n\t\t}\n\t}\n\tht_uu_free (hash);\n\treturn res;\n}", "target": 1}
{"code": "ReadNextFunctionHandle(mat_t *mat, matvar_t *matvar)\n{\n    int err;\n    size_t nelems = 1;\n    err = Mat_MulDims(matvar, &nelems);\n    matvar->data_size = sizeof(matvar_t *);\n    err |= Mul(&matvar->nbytes, nelems, matvar->data_size);\n    if ( err )\n        return 0;\n    matvar->data = malloc(matvar->nbytes);\n    if ( matvar->data != NULL ) {\n        size_t i;\n        matvar_t **functions = (matvar_t **)matvar->data;\n        for ( i = 0; i < nelems; i++ ) {\n            functions[i] = Mat_VarReadNextInfo(mat);\n            err = NULL == functions[i];\n            if ( err )\n                break;\n        }\n        if ( err ) {\n            free(matvar->data);\n            matvar->data = NULL;\n            matvar->data_size = 0;\n            matvar->nbytes = 0;\n        }\n    } else {\n        matvar->data_size = 0;\n        matvar->nbytes = 0;\n    }\n    return 0;\n}", "target": 1}
{"code": "create_bits (pixman_format_code_t format,\n             int                  width,\n             int                  height,\n             int *\t\t  rowstride_bytes,\n\t     pixman_bool_t\t  clear)\n{\n    int stride;\n    size_t buf_size;\n    int bpp;\n    bpp = PIXMAN_FORMAT_BPP (format);\n    if (_pixman_multiply_overflows_int (width, bpp))\n\treturn NULL;\n    stride = width * bpp;\n    if (_pixman_addition_overflows_int (stride, 0x1f))\n\treturn NULL;\n    stride += 0x1f;\n    stride >>= 5;\n    stride *= sizeof (uint32_t);\n     if (_pixman_multiply_overflows_size (height, stride))\n \treturn NULL;\n    buf_size = height * stride;\n     if (rowstride_bytes)\n \t*rowstride_bytes = stride;\n    if (clear)\n\treturn calloc (buf_size, 1);\n    else\n\treturn malloc (buf_size);\n}", "target": 1}
{"code": "char **XListExtensions(\n    register Display *dpy,\n    int *nextensions)\t\n{\n\txListExtensionsReply rep;\n\tchar **list = NULL;\n\tchar *ch = NULL;\n\tchar *chend;\n\tint count = 0;\n\tregister unsigned i;\n\tregister int length;\n\t_X_UNUSED register xReq *req;\n\tunsigned long rlen = 0;\n\tLockDisplay(dpy);\n\tGetEmptyReq (ListExtensions, req);\n\tif (! _XReply (dpy, (xReply *) &rep, 0, xFalse)) {\n\t    UnlockDisplay(dpy);\n\t    SyncHandle();\n\t    return (char **) NULL;\n\t}\n\tif (rep.nExtensions) {\n\t    list = Xmalloc (rep.nExtensions * sizeof (char *));\n\t    if (rep.length > 0 && rep.length < (INT_MAX >> 2)) {\n\t\trlen = rep.length << 2;\n\t\tch = Xmalloc (rlen + 1);\n\t    }\n\t    if ((!list) || (!ch)) {\n\t\tXfree(list);\n\t\tXfree(ch);\n\t\t_XEatDataWords(dpy, rep.length);\n\t\tUnlockDisplay(dpy);\n\t\tSyncHandle();\n\t\treturn (char **) NULL;\n\t    }\n\t    _XReadPad (dpy, ch, rlen);\n \t    chend = ch + rlen;\n\t    length = *ch;\n \t    for (i = 0; i < rep.nExtensions; i++) {\n \t\tif (ch + length < chend) {\n \t\t    list[i] = ch+1;  \n \t\t    ch += length + 1; \n\t\t    length = *ch;\n \t\t    *ch = '\\0'; \n \t\t    count++;\n \t\t} else\n\t\t    list[i] = NULL;\n\t    }\n\t}\n\t*nextensions = count;\n\tUnlockDisplay(dpy);\n\tSyncHandle();\n\treturn (list);\n}", "target": 1}
{"code": "unsigned char *cipso_v4_optptr(const struct sk_buff *skb)\n{\n\tconst struct iphdr *iph = ip_hdr(skb);\n\tunsigned char *optptr = (unsigned char *)&(ip_hdr(skb)[1]);\n\tint optlen;\n\tint taglen;\n\tfor (optlen = iph->ihl*4 - sizeof(struct iphdr); optlen > 0; ) {\n\t\tif (optptr[0] == IPOPT_CIPSO)\n\t\t\treturn optptr;\n\t\ttaglen = optptr[1];\n\t\toptlen -= taglen;\n\t\toptptr += taglen;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "void OneHotComputeImpl(const OneHotContext& op_context) {\n  int prefix_dim_size = 1;\n  for (int i = 0; i < op_context.axis; ++i) {\n    prefix_dim_size *= op_context.indices->dims->data[i];\n  }\n  const int suffix_dim_size = NumElements(op_context.indices) / prefix_dim_size;\n  const int depth = *op_context.depth->data.i32;\n  const T on_value = *GetTensorData<T>(op_context.on_value);\n  const T off_value = *GetTensorData<T>(op_context.off_value);\n  T* output = GetTensorData<T>(op_context.output);\n  const TI* indices = GetTensorData<TI>(op_context.indices);\n  for (int i = 0; i < prefix_dim_size; ++i) {\n    for (int j = 0; j < depth; ++j) {\n      for (int k = 0; k < suffix_dim_size; ++k, ++output) {\n        *output = static_cast<int>(indices[i * suffix_dim_size + k]) == j\n                      ? on_value\n                      : off_value;\n      }\n    }\n  }\n}", "target": 1}
{"code": "long keyctl_join_session_keyring(const char __user *_name)\n{\n\tchar *name;\n\tlong ret;\n\tname = NULL;\n\tif (_name) {\n\t\tname = strndup_user(_name, PAGE_SIZE);\n\t\tif (IS_ERR(name)) {\n\t\t\tret = PTR_ERR(name);\n\t\t\tgoto error;\n\t\t}\n\t}\n\tret = join_session_keyring(name);\n error:\n\treturn ret;\n} ", "target": 1}
{"code": "void usb_ep_combine_input_packets(USBEndpoint *ep)\n{\n    USBPacket *p, *u, *next, *prev = NULL, *first = NULL;\n    USBPort *port = ep->dev->port;\n    int totalsize;\n    assert(ep->pipeline);\n    assert(ep->pid == USB_TOKEN_IN);\n    QTAILQ_FOREACH_SAFE(p, &ep->queue, queue, next) {\n        if (ep->halted) {\n            p->status = USB_RET_REMOVE_FROM_QUEUE;\n            port->ops->complete(port, p);\n            continue;\n        }\n        if (p->state == USB_PACKET_ASYNC) {\n            prev = p;\n            continue;\n        }\n        usb_packet_check_state(p, USB_PACKET_QUEUED);\n        if (prev && prev->short_not_ok) {\n            break;\n        }\n        if (first) {\n            if (first->combined == NULL) {\n                USBCombinedPacket *combined = g_new0(USBCombinedPacket, 1);\n                combined->first = first;\n                QTAILQ_INIT(&combined->packets);\n                qemu_iovec_init(&combined->iov, 2);\n                usb_combined_packet_add(combined, first);\n            }\n            usb_combined_packet_add(first->combined, p);\n        } else {\n            first = p;\n        }\n        totalsize = (p->combined) ? p->combined->iov.size : p->iov.size;\n        if ((p->iov.size % ep->max_packet_size) != 0 || !p->short_not_ok ||\n                next == NULL ||\n                (totalsize == (16 * KiB - 36) && p->int_req)) {\n            usb_device_handle_data(ep->dev, first);\n            assert(first->status == USB_RET_ASYNC);\n            if (first->combined) {\n                QTAILQ_FOREACH(u, &first->combined->packets, combined_entry) {\n                    usb_packet_set_state(u, USB_PACKET_ASYNC);\n                }\n            } else {\n                usb_packet_set_state(first, USB_PACKET_ASYNC);\n            }\n            first = NULL;\n            prev = p;\n        }\n    }\n}", "target": 1}
{"code": "  tt_sbit_decoder_init( TT_SBitDecoder       decoder,\n                        TT_Face              face,\n                        FT_ULong             strike_index,\n                        TT_SBit_MetricsRec*  metrics )\n  {\n    FT_Error   error;\n    FT_Stream  stream = face->root.stream;\n    FT_ULong   ebdt_size;\n    error = face->goto_table( face, TTAG_CBDT, stream, &ebdt_size );\n    if ( error )\n      error = face->goto_table( face, TTAG_EBDT, stream, &ebdt_size );\n    if ( error )\n      error = face->goto_table( face, TTAG_bdat, stream, &ebdt_size );\n    if ( error )\n      goto Exit;\n    decoder->face    = face;\n    decoder->stream  = stream;\n    decoder->bitmap  = &face->root.glyph->bitmap;\n    decoder->metrics = metrics;\n    decoder->metrics_loaded   = 0;\n    decoder->bitmap_allocated = 0;\n    decoder->ebdt_start = FT_STREAM_POS();\n    decoder->ebdt_size  = ebdt_size;\n    decoder->eblc_base  = face->sbit_table;\n    decoder->eblc_limit = face->sbit_table + face->sbit_table_size;\n    {\n      FT_Byte*  p;\n      if ( 8 + 48 * strike_index + 3 * 4 + 34 + 1 > face->sbit_table_size )\n      {\n        error = FT_THROW( Invalid_File_Format );\n        goto Exit;\n      }\n      p = decoder->eblc_base + 8 + 48 * strike_index;\n      decoder->strike_index_array = FT_NEXT_ULONG( p );\n      p                          += 4;\n      decoder->strike_index_count = FT_NEXT_ULONG( p );\n       p                          += 34;\n       decoder->bit_depth          = *p;\n      if ( decoder->strike_index_array > face->sbit_table_size             ||\n           decoder->strike_index_array + 8 * decoder->strike_index_count >\n             face->sbit_table_size                                         )\n         error = FT_THROW( Invalid_File_Format );\n     }\n  }", "target": 1}
{"code": "PHP_FUNCTION(imagetruecolortopalette)\n{\n\tzval *IM;\n\tzend_bool dither;\n\tzend_long ncolors;\n\tgdImagePtr im;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rbl\", &IM, &dither, &ncolors) == FAILURE)  {\n\t\treturn;\n\t}\n\tif ((im = (gdImagePtr)zend_fetch_resource(Z_RES_P(IM), \"Image\", le_gd)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tif (ncolors <= 0) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Number of colors has to be greater than zero\");\n\t\tRETURN_FALSE;\n\t}\n\tgdImageTrueColorToPalette(im, dither, ncolors);\n\tRETURN_TRUE;\n}", "target": 1}
{"code": "ConfirmInfoBar::ConfirmInfoBar(std::unique_ptr<ConfirmInfoBarDelegate> delegate)\n     : InfoBarView(std::move(delegate)) {\n   auto* delegate_ptr = GetDelegate();\n   label_ = CreateLabel(delegate_ptr->GetMessageText());\n   AddChildView(label_);\n   const auto buttons = delegate_ptr->GetButtons();\n  if (buttons & ConfirmInfoBarDelegate::BUTTON_OK) {\n    ok_button_ = CreateButton(ConfirmInfoBarDelegate::BUTTON_OK);\n    ok_button_->SetProminent(true);\n    if (delegate_ptr->OKButtonTriggersUACPrompt()) {\n      elevation_icon_setter_.reset(new ElevationIconSetter(\n          ok_button_,\n          base::BindOnce(&ConfirmInfoBar::Layout, base::Unretained(this))));\n    }\n  }\n  if (buttons & ConfirmInfoBarDelegate::BUTTON_CANCEL) {\n    cancel_button_ = CreateButton(ConfirmInfoBarDelegate::BUTTON_CANCEL);\n    if (buttons == ConfirmInfoBarDelegate::BUTTON_CANCEL)\n      cancel_button_->SetProminent(true);\n  }\n  link_ = CreateLink(delegate_ptr->GetLinkText(), this);\n  AddChildView(link_);\n}", "target": 1}
{"code": "ReverbConvolverStage::ReverbConvolverStage(const float* impulseResponse, size_t, size_t reverbTotalLatency, size_t stageOffset, size_t stageLength,\n                                           size_t fftSize, size_t renderPhase, size_t renderSliceSize, ReverbAccumulationBuffer* accumulationBuffer, bool directMode)\n    : m_accumulationBuffer(accumulationBuffer)\n    , m_accumulationReadIndex(0)\n    , m_inputReadIndex(0)\n    , m_directMode(directMode)\n{\n    ASSERT(impulseResponse);\n    ASSERT(accumulationBuffer);\n    if (!m_directMode) {\n        m_fftKernel = adoptPtr(new FFTFrame(fftSize));\n         m_fftKernel->doPaddedFFT(impulseResponse + stageOffset, stageLength);\n         m_fftConvolver = adoptPtr(new FFTConvolver(fftSize));\n     } else {\n         m_directKernel = adoptPtr(new AudioFloatArray(fftSize / 2));\n        m_directKernel->copyToRange(impulseResponse + stageOffset, 0, fftSize / 2);\n         m_directConvolver = adoptPtr(new DirectConvolver(renderSliceSize));\n     }\n     m_temporaryBuffer.allocate(renderSliceSize);\n    size_t totalDelay = stageOffset + reverbTotalLatency;\n    size_t halfSize = fftSize / 2;\n    if (!m_directMode) {\n        ASSERT(totalDelay >= halfSize);\n        if (totalDelay >= halfSize)\n            totalDelay -= halfSize;\n    }\n    int maxPreDelayLength = std::min(halfSize, totalDelay);\n    m_preDelayLength = totalDelay > 0 ? renderPhase % maxPreDelayLength : 0;\n    if (m_preDelayLength > totalDelay)\n        m_preDelayLength = 0;\n    m_postDelayLength = totalDelay - m_preDelayLength;\n    m_preReadWriteIndex = 0;\n    m_framesProcessed = 0; \n    size_t delayBufferSize = m_preDelayLength < fftSize ? fftSize : m_preDelayLength;\n    delayBufferSize = delayBufferSize < renderSliceSize ? renderSliceSize : delayBufferSize;\n    m_preDelayBuffer.allocate(delayBufferSize);\n}", "target": 1}
{"code": "static ssize_t bat_socket_read(struct file *file, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct socket_client *socket_client = file->private_data;\n\tstruct socket_packet *socket_packet;\n\tsize_t packet_len;\n\tint error;\n\tif ((file->f_flags & O_NONBLOCK) && (socket_client->queue_len == 0))\n\t\treturn -EAGAIN;\n\tif ((!buf) || (count < sizeof(struct icmp_packet)))\n\t\treturn -EINVAL;\n\tif (!access_ok(VERIFY_WRITE, buf, count))\n\t\treturn -EFAULT;\n\terror = wait_event_interruptible(socket_client->queue_wait,\n\t\t\t\t\t socket_client->queue_len);\n\tif (error)\n\t\treturn error;\n\tspin_lock_bh(&socket_client->lock);\n\tsocket_packet = list_first_entry(&socket_client->queue_list,\n\t\t\t\t\t struct socket_packet, list);\n\tlist_del(&socket_packet->list);\n\tsocket_client->queue_len--;\n \tspin_unlock_bh(&socket_client->lock);\n\terror = copy_to_user(buf, &socket_packet->icmp_packet,\n\t\t\t     socket_packet->icmp_len);\n\tpacket_len = socket_packet->icmp_len;\n \tkfree(socket_packet);\n \tif (error)\n\t\treturn -EFAULT;\n\treturn packet_len;\n}", "target": 1}
{"code": " LIBOPENMPT_MODPLUG_API unsigned int ModPlug_InstrumentName(ModPlugFile* file, unsigned int qual, char* buff)\n {\n \tconst char* str;\n\tunsigned int retval;\n\tsize_t tmpretval;\n \tif(!file) return 0;\n \tstr = openmpt_module_get_instrument_name(file->mod,qual-1);\n\tif(!str){\n\t\tif(buff){\n\t\t\t*buff = '\\0';\n\t\t}\n\t\treturn 0;\n\t}\n\ttmpretval = strlen(str);\n\tif(tmpretval>=INT_MAX){\n\t\ttmpretval = INT_MAX-1;\n \t}\n\tretval = (int)tmpretval;\n \tif(buff){\n\t\tmemcpy(buff,str,retval+1);\n\t\tbuff[retval] = '\\0';\n \t}\n\topenmpt_free_string(str);\n\treturn retval;\n }", "target": 1}
{"code": "QPDFWriter::enqueueObject(QPDFObjectHandle object)\n{\n    if (object.isIndirect())\n    {\n        if (object.getOwningQPDF() != &(this->pdf))\n        {\n            QTC::TC(\"qpdf\", \"QPDFWriter foreign object\");\n            throw std::logic_error(\n                \"QPDFObjectHandle from different QPDF found while writing.\"\n                \"  Use QPDF::copyForeignObject to add objects from\"\n                \" another file.\");\n        }\n\tQPDFObjGen og = object.getObjGen();\n\tif (obj_renumber.count(og) == 0)\n\t{\n\t    if (this->object_to_object_stream.count(og))\n\t    {\n\t\tint stream_id = this->object_to_object_stream[og];\n\t\tenqueueObject(this->pdf.getObjectByID(stream_id, 0));\n\t    }\n\t    else\n\t    {\n\t\tobject_queue.push_back(object);\n\t\tobj_renumber[og] = next_objid++;\n\t\tif ((og.getGen() == 0) &&\n                    this->object_stream_to_objects.count(og.getObj()))\n\t\t{\n\t\t    if (! this->linearized)\n\t\t    {\n\t\t\tassignCompressedObjectNumbers(og);\n\t\t    }\n\t\t}\n\t\telse if ((! this->direct_stream_lengths) && object.isStream())\n\t\t{\n\t\t    ++next_objid;\n\t\t}\n\t    }\n\t}\n    }\n    else if (object.isArray())\n    {\n\tint n = object.getArrayNItems();\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t    if (! this->linearized)\n\t    {\n\t\tenqueueObject(object.getArrayItem(i));\n\t    }\n\t}\n    }\n    else if (object.isDictionary())\n    {\n\tstd::set<std::string> keys = object.getKeys();\n\tfor (std::set<std::string>::iterator iter = keys.begin();\n\t     iter != keys.end(); ++iter)\n\t{\n\t    if (! this->linearized)\n\t    {\n\t\tenqueueObject(object.getKey(*iter));\n\t    }\n\t}\n    }\n    else\n    {\n    }\n}", "target": 1}
{"code": "static void get_sem_elements(struct sem_data *p)\n{\n\tsize_t i;\n\tif (!p || !p->sem_nsems || p->sem_perm.id < 0)\n\t\treturn;\n\tp->elements = xcalloc(p->sem_nsems, sizeof(struct sem_elem));\n\tfor (i = 0; i < p->sem_nsems; i++) {\n\t\tstruct sem_elem *e = &p->elements[i];\n\t\tunion semun arg = { .val = 0 };\n\t\te->semval = semctl(p->sem_perm.id, i, GETVAL, arg);\n\t\tif (e->semval < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETVAL)\");\n\t\te->ncount = semctl(p->sem_perm.id, i, GETNCNT, arg);\n\t\tif (e->ncount < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETNCNT)\");\n\t\te->zcount = semctl(p->sem_perm.id, i, GETZCNT, arg);\n\t\tif (e->zcount < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETZCNT)\");\n\t\te->pid = semctl(p->sem_perm.id, i, GETPID, arg);\n\t\tif (e->pid < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETPID)\");\n\t}\n}", "target": 1}
{"code": "IW_IMPL(int) iw_get_input_density(struct iw_context *ctx,\n   double *px, double *py, int *pcode)\n {\n \t*px = 1.0;\n \t*py = 1.0;\n\t*pcode = ctx->img1.density_code;\n\tif(ctx->img1.density_code!=IW_DENSITY_UNKNOWN) {\n\t\t*px = ctx->img1.density_x;\n\t\t*py = ctx->img1.density_y;\n\t\treturn 1;\n \t}\n\treturn 0;\n }", "target": 1}
{"code": "static int elo_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct elo_priv *priv;\n\tint ret;\n\tstruct usb_device *udev;\n\tif (!hid_is_usb(hdev))\n\t\treturn -EINVAL;\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tINIT_DELAYED_WORK(&priv->work, elo_work);\n\tudev = interface_to_usbdev(to_usb_interface(hdev->dev.parent));\n\tpriv->usbdev = usb_get_dev(udev);\n\thid_set_drvdata(hdev, priv);\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto err_free;\n\t}\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto err_free;\n\t}\n\tif (elo_broken_firmware(priv->usbdev)) {\n\t\thid_info(hdev, \"broken firmware found, installing workaround\\n\");\n\t\tqueue_delayed_work(wq, &priv->work, ELO_PERIODIC_READ_INTERVAL);\n\t}\n\treturn 0;\nerr_free:\n\tkfree(priv);\n\treturn ret;\n}", "target": 1}
{"code": "static int ssl_parse_supported_elliptic_curves( ssl_context *ssl,\n                                                const unsigned char *buf,\n                                                size_t len )\n{\n    size_t list_size, our_size;\n    const unsigned char *p;\n    const ecp_curve_info *curve_info, **curves;\n    list_size = ( ( buf[0] << 8 ) | ( buf[1] ) );\n    if( list_size + 2 != len ||\n        list_size % 2 != 0 )\n    {\n        SSL_DEBUG_MSG( 1, ( \"bad client hello message\" ) );\n        return( POLARSSL_ERR_SSL_BAD_HS_CLIENT_HELLO );\n    }\n    our_size = list_size / 2 + 1;\n    if( our_size > POLARSSL_ECP_DP_MAX )\n        our_size = POLARSSL_ECP_DP_MAX;\n    if( ( curves = polarssl_malloc( our_size * sizeof( *curves ) ) ) == NULL )\n        return( POLARSSL_ERR_SSL_MALLOC_FAILED );\n    memset( (void *) curves, 0, our_size * sizeof( *curves ) );\n    ssl->handshake->curves = curves;\n    p = buf + 2;\n    while( list_size > 0 && our_size > 1 )\n    {\n        curve_info = ecp_curve_info_from_tls_id( ( p[0] << 8 ) | p[1] );\n        if( curve_info != NULL )\n        {\n            *curves++ = curve_info;\n            our_size--;\n        }\n        list_size -= 2;\n        p += 2;\n    }\n    return( 0 );\n}", "target": 1}
{"code": "static int intel_vgpu_mmap(struct mdev_device *mdev, struct vm_area_struct *vma)\n{\n\tunsigned int index;\n\tu64 virtaddr;\n\tunsigned long req_size, pgoff = 0;\n\tpgprot_t pg_prot;\n\tstruct intel_vgpu *vgpu = mdev_get_drvdata(mdev);\n\tindex = vma->vm_pgoff >> (VFIO_PCI_OFFSET_SHIFT - PAGE_SHIFT);\n\tif (index >= VFIO_PCI_ROM_REGION_INDEX)\n\t\treturn -EINVAL;\n\tif (vma->vm_end < vma->vm_start)\n\t\treturn -EINVAL;\n\tif ((vma->vm_flags & VM_SHARED) == 0)\n\t\treturn -EINVAL;\n\tif (index != VFIO_PCI_BAR2_REGION_INDEX)\n\t\treturn -EINVAL;\n\tpg_prot = vma->vm_page_prot;\n\tvirtaddr = vma->vm_start;\n\treq_size = vma->vm_end - vma->vm_start;\n\tpgoff = vgpu_aperture_pa_base(vgpu) >> PAGE_SHIFT;\n\treturn remap_pfn_range(vma, virtaddr, pgoff, req_size, pg_prot);\n}", "target": 1}
{"code": "static pj_status_t decode_errcode_attr(pj_pool_t *pool, \n\t\t\t\t       const pj_uint8_t *buf,\n\t\t\t\t       const pj_stun_msg_hdr *msghdr, \n\t\t\t\t       void **p_attr)\n{\n    pj_stun_errcode_attr *attr;\n    pj_str_t value;\n    PJ_UNUSED_ARG(msghdr);\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_errcode_attr);\n    GETATTRHDR(buf, &attr->hdr);\n    attr->err_code = buf[6] * 100 + buf[7];\n    value.ptr = ((char*)buf + ATTR_HDR_LEN + 4);\n    value.slen = attr->hdr.length - 4;\n    pj_strdup(pool, &attr->reason, &value);\n    *p_attr = attr;\n    return PJ_SUCCESS;\n}", "target": 1}
{"code": " static int sh_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\n \tut8 op_MSB,op_LSB;\n \tint ret;\n\tif (!data)\n \t\treturn 0;\n \tmemset (op, '\\0', sizeof (RAnalOp));\n \top->addr = addr;\n \top->type = R_ANAL_OP_TYPE_UNK;\n\top->jump = op->fail = -1;\n\top->ptr = op->val = -1;\n\top->size = 2;\n\top_MSB = anal->big_endian? data[0]: data[1];\n\top_LSB = anal->big_endian? data[1]: data[0];\n\tret =  first_nibble_decode[(op_MSB>>4) & 0x0F](anal, op, (ut16)(op_MSB<<8 | op_LSB));\n\treturn ret;\n}", "target": 1}
{"code": "static int kvm_ioctl_create_device(struct kvm *kvm,\n\t\t\t\t   struct kvm_create_device *cd)\n{\n\tstruct kvm_device_ops *ops = NULL;\n\tstruct kvm_device *dev;\n\tbool test = cd->flags & KVM_CREATE_DEVICE_TEST;\n\tint ret;\n\tif (cd->type >= ARRAY_SIZE(kvm_device_ops_table))\n\t\treturn -ENODEV;\n\tops = kvm_device_ops_table[cd->type];\n\tif (ops == NULL)\n\t\treturn -ENODEV;\n\tif (test)\n\t\treturn 0;\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tdev->ops = ops;\n\tdev->kvm = kvm;\n\tmutex_lock(&kvm->lock);\n\tret = ops->create(dev, cd->type);\n\tif (ret < 0) {\n\t\tmutex_unlock(&kvm->lock);\n\t\tkfree(dev);\n\t\treturn ret;\n\t}\n\tlist_add(&dev->vm_node, &kvm->devices);\n\tmutex_unlock(&kvm->lock);\n \tif (ops->init)\n \t\tops->init(dev);\n \tret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);\n \tif (ret < 0) {\n \t\tmutex_lock(&kvm->lock);\n \t\tlist_del(&dev->vm_node);\n \t\tmutex_unlock(&kvm->lock);\n \t\tops->destroy(dev);\n \t\treturn ret;\n \t}\n\tkvm_get_kvm(kvm);\n \tcd->fd = ret;\n \treturn 0;\n }", "target": 1}
{"code": " MagickExport int LocaleLowercase(const int c)\n {\n  if (c < 0)\n     return(c);\n #if defined(MAGICKCORE_LOCALE_SUPPORT)\n   if (c_locale != (locale_t) NULL)\n    return(tolower_l((int) ((unsigned char) c),c_locale));\n#endif\n  return(tolower((int) ((unsigned char) c)));\n}", "target": 1}
{"code": "static int complete_emulated_mmio(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tstruct kvm_mmio_fragment *frag;\n\tunsigned len;\n\tBUG_ON(!vcpu->mmio_needed);\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];\n\tlen = min(8u, frag->len);\n\tif (!vcpu->mmio_is_write)\n\t\tmemcpy(frag->data, run->mmio.data, len);\n\tif (frag->len <= 8) {\n\t\tfrag++;\n\t\tvcpu->mmio_cur_fragment++;\n\t} else {\n\t\tfrag->data += len;\n\t\tfrag->gpa += len;\n \t\tfrag->len -= len;\n \t}\n\tif (vcpu->mmio_cur_fragment == vcpu->mmio_nr_fragments) {\n \t\tvcpu->mmio_needed = 0;\n\t\tif (vcpu->mmio_is_write)\n\t\t\treturn 1;\n\t\tvcpu->mmio_read_completed = 1;\n\t\treturn complete_emulated_io(vcpu);\n\t}\n\trun->exit_reason = KVM_EXIT_MMIO;\n\trun->mmio.phys_addr = frag->gpa;\n\tif (vcpu->mmio_is_write)\n\t\tmemcpy(run->mmio.data, frag->data, min(8u, frag->len));\n\trun->mmio.len = min(8u, frag->len);\n\trun->mmio.is_write = vcpu->mmio_is_write;\n\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\treturn 0;\n}", "target": 1}
{"code": "static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)\n{\n\tint rlen, remain;\n\tdpIOCtxPtr dctx;\n\tdynamicPtr *dp;\n\tdctx = (dpIOCtxPtr) ctx;\n\tdp = dctx->dp;\n\tremain = dp->logicalSize - dp->pos;\n \tif(remain >= len) {\n \t\trlen = len;\n \t} else {\n\t\tif(remain == 0) {\n\t\t\treturn 0; \n\t\t}\n\t\trlen = remain;\n\t}\n\tmemcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);\n\tdp->pos += rlen;\n\treturn rlen;\n}", "target": 1}
{"code": "static int dccp_error(struct net *net, struct nf_conn *tmpl,\n\t\t      struct sk_buff *skb, unsigned int dataoff,\n\t\t      enum ip_conntrack_info *ctinfo,\n\t\t      u_int8_t pf, unsigned int hooknum)\n{\n\tstruct dccp_hdr _dh, *dh;\n\tunsigned int dccp_len = skb->len - dataoff;\n \tunsigned int cscov;\n \tconst char *msg;\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n \tif (dh == NULL) {\n \t\tmsg = \"nf_ct_dccp: short packet \";\n \t\tgoto out_invalid;\n\t}\n\tif (dh->dccph_doff * 4 < sizeof(struct dccp_hdr) ||\n\t    dh->dccph_doff * 4 > dccp_len) {\n\t\tmsg = \"nf_ct_dccp: truncated/malformed packet \";\n\t\tgoto out_invalid;\n\t}\n\tcscov = dccp_len;\n\tif (dh->dccph_cscov) {\n\t\tcscov = (dh->dccph_cscov - 1) * 4;\n\t\tif (cscov > dccp_len) {\n\t\t\tmsg = \"nf_ct_dccp: bad checksum coverage \";\n\t\t\tgoto out_invalid;\n\t\t}\n\t}\n\tif (net->ct.sysctl_checksum && hooknum == NF_INET_PRE_ROUTING &&\n\t    nf_checksum_partial(skb, hooknum, dataoff, cscov, IPPROTO_DCCP,\n\t\t\t\tpf)) {\n\t\tmsg = \"nf_ct_dccp: bad checksum \";\n\t\tgoto out_invalid;\n\t}\n\tif (dh->dccph_type >= DCCP_PKT_INVALID) {\n\t\tmsg = \"nf_ct_dccp: reserved packet type \";\n\t\tgoto out_invalid;\n\t}\n\treturn NF_ACCEPT;\nout_invalid:\n\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\tnf_log_packet(net, pf, 0, skb, NULL, NULL, NULL, \"%s\", msg);\n\treturn -NF_ACCEPT;\n}", "target": 1}
{"code": "static int drff_init(struct hid_device *hid)\n{\n\tstruct drff_device *drff;\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput = list_first_entry(&hid->inputs,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct list_head *report_list =\n\t\t\t&hid->report_enum[HID_OUTPUT_REPORT].report_list;\n\tstruct input_dev *dev = hidinput->input;\n\tint error;\n\tif (list_empty(report_list)) {\n\t\thid_err(hid, \"no output reports found\\n\");\n\t\treturn -ENODEV;\n\t}\n\treport = list_first_entry(report_list, struct hid_report, list);\n\tif (report->maxfield < 1) {\n\t\thid_err(hid, \"no fields in the report\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (report->field[0]->report_count < 7) {\n\t\thid_err(hid, \"not enough values in the field\\n\");\n\t\treturn -ENODEV;\n\t}\n\tdrff = kzalloc(sizeof(struct drff_device), GFP_KERNEL);\n\tif (!drff)\n\t\treturn -ENOMEM;\n\tset_bit(FF_RUMBLE, dev->ffbit);\n\terror = input_ff_create_memless(dev, drff, drff_play);\n\tif (error) {\n\t\tkfree(drff);\n\t\treturn error;\n\t}\n\tdrff->report = report;\n\tdrff->report->field[0]->value[0] = 0xf3;\n\tdrff->report->field[0]->value[1] = 0x00;\n\tdrff->report->field[0]->value[2] = 0x00;\n\tdrff->report->field[0]->value[3] = 0x00;\n\tdrff->report->field[0]->value[4] = 0x00;\n\tdrff->report->field[0]->value[5] = 0x00;\n\tdrff->report->field[0]->value[6] = 0x00;\n\thid_hw_request(hid, drff->report, HID_REQ_SET_REPORT);\n\thid_info(hid, \"Force Feedback for DragonRise Inc. \"\n\t\t \"game controllers by Richard Walmsley <richwalm@gmail.com>\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "int ssh_bind_accept_fd(ssh_bind sshbind, ssh_session session, socket_t fd){\n    int i, rc;\n    if (session == NULL){\n        ssh_set_error(sshbind, SSH_FATAL,\"session is null\");\n        return SSH_ERROR;\n    }\n    session->server = 1;\n    session->version = 2;\n    for (i = 0; i < 10; ++i) {\n      if (sshbind->wanted_methods[i]) {\n        session->opts.wanted_methods[i] = strdup(sshbind->wanted_methods[i]);\n        if (session->opts.wanted_methods[i] == NULL) {\n          return SSH_ERROR;\n        }\n      }\n    }\n    if (sshbind->bindaddr == NULL)\n      session->opts.bindaddr = NULL;\n    else {\n      SAFE_FREE(session->opts.bindaddr);\n      session->opts.bindaddr = strdup(sshbind->bindaddr);\n      if (session->opts.bindaddr == NULL) {\n        return SSH_ERROR;\n      }\n    }\n    session->common.log_verbosity = sshbind->common.log_verbosity;\n    if(sshbind->banner != NULL)\n    \tsession->opts.custombanner = strdup(sshbind->banner);\n    ssh_socket_free(session->socket);\n    session->socket = ssh_socket_new(session);\n    if (session->socket == NULL) {\n      ssh_set_error_oom(sshbind);\n      return SSH_ERROR;\n    }\n    ssh_socket_set_fd(session->socket, fd);\n    ssh_socket_get_poll_handle_out(session->socket);\n    rc = ssh_bind_import_keys(sshbind);\n    if (rc != SSH_OK) {\n      return SSH_ERROR;\n    }\n#ifdef HAVE_ECC\n    if (sshbind->ecdsa) {\n        session->srv.ecdsa_key = ssh_key_dup(sshbind->ecdsa);\n        if (session->srv.ecdsa_key == NULL) {\n          ssh_set_error_oom(sshbind);\n          return SSH_ERROR;\n        }\n    }\n#endif\n    if (sshbind->dsa) {\n        session->srv.dsa_key = ssh_key_dup(sshbind->dsa);\n        if (session->srv.dsa_key == NULL) {\n          ssh_set_error_oom(sshbind);\n          return SSH_ERROR;\n        }\n    }\n    if (sshbind->rsa) {\n        session->srv.rsa_key = ssh_key_dup(sshbind->rsa);\n        if (session->srv.rsa_key == NULL) {\n          ssh_set_error_oom(sshbind);\n          return SSH_ERROR;\n        }\n    }\n    return SSH_OK;\n}", "target": 1}
{"code": "    StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,\n                                                     size_t xTriggerLevelBytes,\n                                                     BaseType_t xIsMessageBuffer )\n    {\n        uint8_t * pucAllocatedMemory;\n        uint8_t ucFlags;\n        if( xIsMessageBuffer == pdTRUE )\n        {\n            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;\n            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );\n        }\n        else\n        {\n            ucFlags = 0;\n            configASSERT( xBufferSizeBytes > 0 );\n        }\n        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );\n        if( xTriggerLevelBytes == ( size_t ) 0 )\n        {\n            xTriggerLevelBytes = ( size_t ) 1;\n        }\n        xBufferSizeBytes++;\n        pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); \n        if( pucAllocatedMemory != NULL )\n        {\n            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory,         \n                                          pucAllocatedMemory + sizeof( StreamBuffer_t ),  \n                                          xBufferSizeBytes,\n                                          xTriggerLevelBytes,\n                                          ucFlags );\n            traceSTREAM_BUFFER_CREATE( ( ( StreamBuffer_t * ) pucAllocatedMemory ), xIsMessageBuffer );\n        }\n        else\n        {\n            traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );\n        }\n        return ( StreamBufferHandle_t ) pucAllocatedMemory; \n    }", "target": 1}
{"code": "status_t MyOpusExtractor::readNextPacket(MediaBuffer **out) {\n if (mOffset <= mFirstDataOffset && mStartGranulePosition < 0) {\n MediaBuffer *mBuf;\n uint32_t numSamples = 0;\n uint64_t curGranulePosition = 0;\n while (true) {\n status_t err = _readNextPacket(&mBuf, false);\n if (err != OK && err != ERROR_END_OF_STREAM) {\n return err;\n             }\n             if (err == ERROR_END_OF_STREAM || mCurrentPage.mPageNo > 2) {\n                 break;\n             }\n             curGranulePosition = mCurrentPage.mGranulePosition;\n            numSamples += getNumSamplesInPacket(mBuf);\n            mBuf->release();\n            mBuf = NULL;\n }\n if (curGranulePosition > numSamples) {\n            mStartGranulePosition = curGranulePosition - numSamples;\n } else {\n            mStartGranulePosition = 0;\n }\n        seekToOffset(0);\n }\n status_t err = _readNextPacket(out, false);\n if (err != OK) {\n return err;\n }\n int32_t currentPageSamples;\n if ((*out)->meta_data()->findInt32(kKeyValidSamples, &currentPageSamples)) {\n if (mOffset == mFirstDataOffset) {\n            currentPageSamples -= mStartGranulePosition;\n (*out)->meta_data()->setInt32(kKeyValidSamples, currentPageSamples);\n }\n        mCurGranulePosition = mCurrentPage.mGranulePosition - currentPageSamples;\n }\n int64_t timeUs = getTimeUsOfGranule(mCurGranulePosition);\n (*out)->meta_data()->setInt64(kKeyTime, timeUs);\n uint32_t frames = getNumSamplesInPacket(*out);\n    mCurGranulePosition += frames;\n return OK;\n}", "target": 1}
{"code": "e1000_send_packet(E1000State *s, const uint8_t *buf, int size)\n{\n    static const int PTCregs[6] = { PTC64, PTC127, PTC255, PTC511,\n                                    PTC1023, PTC1522 };\n    NetClientState *nc = qemu_get_queue(s->nic);\n    if (s->phy_reg[PHY_CTRL] & MII_CR_LOOPBACK) {\n        nc->info->receive(nc, buf, size);\n    } else {\n        qemu_send_packet(nc, buf, size);\n    }\n    inc_tx_bcast_or_mcast_count(s, buf);\n    e1000x_increase_size_stats(s->mac_reg, PTCregs, size);\n}", "target": 1}
{"code": "ProcXkbSetMap(ClientPtr client)\n{\n    DeviceIntPtr dev;\n    char *tmp;\n    int rc;\n    REQUEST(xkbSetMapReq);\n    REQUEST_AT_LEAST_SIZE(xkbSetMapReq);\n    if (!(client->xkbClientFlags & _XkbClientInitialized))\n        return BadAccess;\n    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixManageAccess);\n    CHK_MASK_LEGAL(0x01, stuff->present, XkbAllMapComponentsMask);\n    tmp = (char *) &stuff[1];\n    rc = _XkbSetMapChecks(client, dev, stuff, tmp, TRUE);\n    if (rc != Success)\n        return rc;\n    DeviceIntPtr master = GetMaster(dev, MASTER_KEYBOARD);\n    if (stuff->deviceSpec == XkbUseCoreKbd) {\n        DeviceIntPtr other;\n        for (other = inputInfo.devices; other; other = other->next) {\n            if ((other != dev) && other->key && !IsMaster(other) &&\n                GetMaster(other, MASTER_KEYBOARD) == dev) {\n                rc = XaceHook(XACE_DEVICE_ACCESS, client, other,\n                              DixManageAccess);\n                if (rc == Success) {\n                    rc = _XkbSetMapChecks(client, other, stuff, tmp, FALSE);\n                    if (rc != Success)\n                        return rc;\n                }\n            }\n        }\n    } else {\n        DeviceIntPtr other;\n        for (other = inputInfo.devices; other; other = other->next) {\n            if (other != dev && GetMaster(other, MASTER_KEYBOARD) != dev &&\n                (other != master || dev != master->lastSlave))\n                continue;\n            rc = _XkbSetMapChecks(client, other, stuff, tmp, FALSE);\n            if (rc != Success)\n                return rc;\n        }\n    }\n    rc = _XkbSetMap(client, dev, stuff, tmp);\n    if (rc != Success)\n        return rc;\n    if (stuff->deviceSpec == XkbUseCoreKbd) {\n        DeviceIntPtr other;\n        for (other = inputInfo.devices; other; other = other->next) {\n            if ((other != dev) && other->key && !IsMaster(other) &&\n                GetMaster(other, MASTER_KEYBOARD) == dev) {\n                rc = XaceHook(XACE_DEVICE_ACCESS, client, other,\n                              DixManageAccess);\n                if (rc == Success)\n                    _XkbSetMap(client, other, stuff, tmp);\n            }\n        }\n    } else {\n        DeviceIntPtr other;\n        for (other = inputInfo.devices; other; other = other->next) {\n            if (other != dev && GetMaster(other, MASTER_KEYBOARD) != dev &&\n                (other != master || dev != master->lastSlave))\n                continue;\n            _XkbSetMap(client, other, stuff, tmp); \n        }\n    }\n    return Success;\n}", "target": 1}
{"code": "void arch_pick_mmap_layout(struct mm_struct *mm)\n{\n\tunsigned long random_factor = 0UL;\n \tif (current->flags & PF_RANDOMIZE)\n \t\trandom_factor = arch_mmap_rnd();\n\tmm->mmap_legacy_base = mmap_legacy_base(random_factor);\n \tif (mmap_is_legacy()) {\n \t\tmm->mmap_base = mm->mmap_legacy_base;\n\t\tmm->get_unmapped_area = arch_get_unmapped_area;\n\t} else {\n\t\tmm->mmap_base = mmap_base(random_factor);\n\t\tmm->get_unmapped_area = arch_get_unmapped_area_topdown;\n\t}\n}", "target": 1}
{"code": "static int udp_v6_push_pending_frames(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n \tstruct udphdr *uh;\n \tstruct udp_sock  *up = udp_sk(sk);\n \tstruct inet_sock *inet = inet_sk(sk);\n\tstruct flowi6 *fl6 = &inet->cork.fl.u.ip6;\n \tint err = 0;\n \tint is_udplite = IS_UDPLITE(sk);\n \t__wsum csum = 0;\n \tif ((skb = skb_peek(&sk->sk_write_queue)) == NULL)\n \t\tgoto out;\n\tuh = udp_hdr(skb);\n\tuh->source = fl6->fl6_sport;\n\tuh->dest = fl6->fl6_dport;\n\tuh->len = htons(up->len);\n\tuh->check = 0;\n\tif (is_udplite)\n\t\tcsum = udplite_csum_outgoing(sk, skb);\n\telse if (skb->ip_summed == CHECKSUM_PARTIAL) { \n\t\tudp6_hwcsum_outgoing(sk, skb, &fl6->saddr, &fl6->daddr,\n\t\t\t\t     up->len);\n\t\tgoto send;\n\t} else\n\t\tcsum = udp_csum_outgoing(sk, skb);\n\tuh->check = csum_ipv6_magic(&fl6->saddr, &fl6->daddr,\n\t\t\t\t    up->len, fl6->flowi6_proto, csum);\n\tif (uh->check == 0)\n\t\tuh->check = CSUM_MANGLED_0;\nsend:\n\terr = ip6_push_pending_frames(sk);\n\tif (err) {\n\t\tif (err == -ENOBUFS && !inet6_sk(sk)->recverr) {\n\t\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\t    UDP_MIB_SNDBUFERRORS, is_udplite);\n\t\t\terr = 0;\n\t\t}\n\t} else\n\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t    UDP_MIB_OUTDATAGRAMS, is_udplite);\nout:\n\tup->len = 0;\n\tup->pending = 0;\n\treturn err;\n}", "target": 1}
{"code": " INLINE void impeg2d_bit_stream_flush(void* pv_ctxt, UWORD32 u4_no_of_bits)\n {\n     stream_t *ps_stream = (stream_t *)pv_ctxt;\n    if (ps_stream->u4_offset < ps_stream->u4_max_offset)\n     {\n         FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)\n     }\n     return;\n }", "target": 1}
{"code": "static int is_git_directory(const char *suspect)\n{\n\tchar path[PATH_MAX];\n\tsize_t len = strlen(suspect);\n\tstrcpy(path, suspect);\n\tif (getenv(DB_ENVIRONMENT)) {\n\t\tif (access(getenv(DB_ENVIRONMENT), X_OK))\n\t\t\treturn 0;\n\t}\n\telse {\n\t\tstrcpy(path + len, \"/objects\");\n\t\tif (access(path, X_OK))\n\t\t\treturn 0;\n\t}\n\tstrcpy(path + len, \"/refs\");\n\tif (access(path, X_OK))\n\t\treturn 0;\n\tstrcpy(path + len, \"/HEAD\");\n\tif (validate_headref(path))\n\t\treturn 0;\n\treturn 1;\n}", "target": 1}
{"code": "ext_get_plugin(const char *name, const char *module, const char *revision)\n{\n    uint16_t u;\n    assert(name);\n    assert(module);\n    for (u = 0; u < ext_plugins_count; u++) {\n        if (!strcmp(name, ext_plugins[u].name) &&\n                !strcmp(module, ext_plugins[u].module) &&\n                (!ext_plugins[u].revision || !strcmp(revision, ext_plugins[u].revision))) {\n            return ext_plugins[u].plugin;\n        }\n    }\n    return NULL;\n}", "target": 1}
{"code": "bool format_go_output(const string& file_path) {\n  const string command = \"gofmt -w \" + file_path;\n  if (system(command.c_str()) == 0) {\n    return true;\n  }\n  fprintf(stderr, \"WARNING - Running '%s' failed.\\n\", command.c_str());\n  return false;\n}", "target": 1}
{"code": "aodv_extension(netdissect_options *ndo,\n               const struct aodv_ext *ep, u_int length)\n {\n \tconst struct aodv_hello *ah;\n \tswitch (ep->type) {\n \tcase AODV_EXT_HELLO:\n \t\tah = (const struct aodv_hello *)(const void *)ep;\n \t\tND_TCHECK(*ah);\n \t\tif (length < sizeof(struct aodv_hello))\n \t\t\tgoto trunc;\n \t\tND_PRINT((ndo, \"\\n\\text HELLO %ld ms\",\n \t\t    (unsigned long)EXTRACT_32BITS(&ah->interval)));\n \t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"\\n\\text %u %u\", ep->type, ep->length));\n\t\tbreak;\n\t}\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \" [|hello]\"));\n}", "target": 1}
{"code": "renderCoTable(struct table *tbl, int maxlimit)\n{\n    struct readbuffer obuf;\n    struct html_feed_environ h_env;\n    struct environment envs[MAX_ENV_LEVEL];\n    struct table *t;\n    int i, col, row;\n    int indent, maxwidth;\n    for (i = 0; i < tbl->ntable; i++) {\n\tt = tbl->tables[i].ptr;\n\tcol = tbl->tables[i].col;\n\trow = tbl->tables[i].row;\n\tindent = tbl->tables[i].indent;\n\tinit_henv(&h_env, &obuf, envs, MAX_ENV_LEVEL, tbl->tables[i].buf,\n\t\t  get_spec_cell_width(tbl, row, col), indent);\n\tcheck_row(tbl, row);\n\tif (h_env.limit > maxlimit)\n\t    h_env.limit = maxlimit;\n\tif (t->total_width == 0)\n\t    maxwidth = h_env.limit - indent;\n\telse if (t->total_width > 0)\n\t    maxwidth = t->total_width;\n\telse\n\t    maxwidth = t->total_width = -t->total_width * h_env.limit / 100;\n\trenderTable(t, maxwidth, &h_env);\n    }\n}", "target": 1}
{"code": "void CharCodeToUnicode::addMapping(CharCode code, char *uStr, int n,\n\t\t\t\t   int offset) {\n  CharCode oldLen, i;\n  Unicode u;\n  char uHex[5];\n  int j;\n  if (code >= mapLen) {\n    oldLen = mapLen;\n    mapLen = (code + 256) & ~255;\n    map = (Unicode *)greallocn(map, mapLen, sizeof(Unicode));\n    for (i = oldLen; i < mapLen; ++i) {\n      map[i] = 0;\n    }\n  }\n  if (n <= 4) {\n    if (sscanf(uStr, \"%x\", &u) != 1) {\n      error(-1, \"Illegal entry in ToUnicode CMap\");\n      return;\n    }\n    map[code] = u + offset;\n  } else {\n    if (sMapLen >= sMapSize) {\n      sMapSize = sMapSize + 16;\n      sMap = (CharCodeToUnicodeString *)\n\t       greallocn(sMap, sMapSize, sizeof(CharCodeToUnicodeString));\n    }\n    map[code] = 0;\n    sMap[sMapLen].c = code;\n    sMap[sMapLen].len = n / 4;\n    for (j = 0; j < sMap[sMapLen].len && j < maxUnicodeString; ++j) {\n      strncpy(uHex, uStr + j*4, 4);\n      uHex[4] = '\\0';\n      if (sscanf(uHex, \"%x\", &sMap[sMapLen].u[j]) != 1) {\n\terror(-1, \"Illegal entry in ToUnicode CMap\");\n      }\n    }\n    sMap[sMapLen].u[sMap[sMapLen].len - 1] += offset;\n    ++sMapLen;\n  }\n}", "target": 1}
{"code": "service_info *FindServiceEventURLPath(\n\tservice_table *table, const char *eventURLPath)\n{\n\tservice_info *finger = NULL;\n\turi_type parsed_url;\n\turi_type parsed_url_in;\n\tif (table &&\n\t\tparse_uri(eventURLPath, strlen(eventURLPath), &parsed_url_in) ==\n\t\t\tHTTP_SUCCESS) {\n\t\tfinger = table->serviceList;\n\t\twhile (finger) {\n\t\t\tif (finger->eventURL) {\n\t\t\t\tif (parse_uri(finger->eventURL,\n\t\t\t\t\t    strlen(finger->eventURL),\n\t\t\t\t\t    &parsed_url) == HTTP_SUCCESS) {\n\t\t\t\t\tif (!token_cmp(&parsed_url.pathquery,\n\t\t\t\t\t\t    &parsed_url_in.pathquery)) {\n\t\t\t\t\t\treturn finger;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinger = finger->next;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static struct dentry * real_lookup(struct dentry * parent, struct qstr * name, struct nameidata *nd)\n{\n\tstruct dentry * result;\n\tstruct inode *dir = parent->d_inode;\n\tmutex_lock(&dir->i_mutex);\n\tresult = d_lookup(parent, name);\n\tif (!result) {\n\t\tstruct dentry * dentry = d_alloc(parent, name);\n\t\tresult = ERR_PTR(-ENOMEM);\n\t\tif (dentry) {\n\t\t\tresult = dir->i_op->lookup(dir, dentry, nd);\n\t\t\tif (result)\n\t\t\t\tdput(dentry);\n\t\t\telse\n\t\t\t\tresult = dentry;\n\t\t}\n\t\tmutex_unlock(&dir->i_mutex);\n\t\treturn result;\n\t}\n\tmutex_unlock(&dir->i_mutex);\n\tif (result->d_op && result->d_op->d_revalidate) {\n\t\tresult = do_revalidate(result, nd);\n\t\tif (!result)\n\t\t\tresult = ERR_PTR(-ENOENT);\n\t}\n\treturn result;\n}", "target": 1}
{"code": "void Ogg::XiphComment::parse(const ByteVector &data)\n{\n  uint pos = 0;\n  int vendorLength = data.mid(0, 4).toUInt(false);\n  pos += 4;\n  d->vendorID = String(data.mid(pos, vendorLength), String::UTF8);\n  pos += vendorLength;\n  uint commentFields = data.mid(pos, 4).toUInt(false);\n  pos += 4;\n  if(commentFields > (data.size() - 8) / 4) {\n    return;\n  }\n  for(uint i = 0; i < commentFields; i++) {\n    uint commentLength = data.mid(pos, 4).toUInt(false);\n    pos += 4;\n    String comment = String(data.mid(pos, commentLength), String::UTF8);\n    pos += commentLength;\n    if(pos > data.size()) {\n      break;\n    }\n    int commentSeparatorPosition = comment.find(\"=\");\n    if(commentSeparatorPosition == -1) {\n      break;\n    }\n    String key = comment.substr(0, commentSeparatorPosition);\n    String value = comment.substr(commentSeparatorPosition + 1);\n    addField(key, value, false);\n  }\n}", "target": 1}
{"code": "static void hci_extended_inquiry_result_evt(struct hci_dev *hdev,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct inquiry_data data;\n\tstruct extended_inquiry_info *info = (void *) (skb->data + 1);\n\tint num_rsp = *((__u8 *) skb->data);\n\tsize_t eir_len;\n\tBT_DBG(\"%s num_rsp %d\", hdev->name, num_rsp);\n\tif (!num_rsp)\n\t\treturn;\n\tif (hci_dev_test_flag(hdev, HCI_PERIODIC_INQ))\n\t\treturn;\n\thci_dev_lock(hdev);\n\tfor (; num_rsp; num_rsp--, info++) {\n\t\tu32 flags;\n\t\tbool name_known;\n\t\tbacpy(&data.bdaddr, &info->bdaddr);\n\t\tdata.pscan_rep_mode\t= info->pscan_rep_mode;\n\t\tdata.pscan_period_mode\t= info->pscan_period_mode;\n\t\tdata.pscan_mode\t\t= 0x00;\n\t\tmemcpy(data.dev_class, info->dev_class, 3);\n\t\tdata.clock_offset\t= info->clock_offset;\n\t\tdata.rssi\t\t= info->rssi;\n\t\tdata.ssp_mode\t\t= 0x01;\n\t\tif (hci_dev_test_flag(hdev, HCI_MGMT))\n\t\t\tname_known = eir_get_data(info->data,\n\t\t\t\t\t\t  sizeof(info->data),\n\t\t\t\t\t\t  EIR_NAME_COMPLETE, NULL);\n\t\telse\n\t\t\tname_known = true;\n\t\tflags = hci_inquiry_cache_update(hdev, &data, name_known);\n\t\teir_len = eir_get_length(info->data, sizeof(info->data));\n\t\tmgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00,\n\t\t\t\t  info->dev_class, info->rssi,\n\t\t\t\t  flags, info->data, eir_len, NULL, 0);\n\t}\n\thci_dev_unlock(hdev);\n}", "target": 1}
{"code": "  t1_parse_font_matrix( T1_Face    face,\n                        T1_Loader  loader )\n  {\n    T1_Parser   parser = &loader->parser;\n    FT_Matrix*  matrix = &face->type1.font_matrix;\n    FT_Vector*  offset = &face->type1.font_offset;\n    FT_Face     root   = (FT_Face)&face->root;\n    FT_Fixed    temp[6];\n    FT_Fixed    temp_scale;\n    FT_Int      result;\n     result = T1_ToFixedArray( parser, 6, temp, 3 );\n    if ( result < 0 )\n     {\n       parser->root.error = FT_THROW( Invalid_File_Format );\n       return;\n    }\n    temp_scale = FT_ABS( temp[3] );\n    if ( temp_scale == 0 )\n    {\n      FT_ERROR(( \"t1_parse_font_matrix: invalid font matrix\\n\" ));\n      parser->root.error = FT_THROW( Invalid_File_Format );\n      return;\n    }\n    root->units_per_EM = (FT_UShort)FT_DivFix( 1000, temp_scale );\n    if ( temp_scale != 0x10000L )\n    {\n      temp[0] = FT_DivFix( temp[0], temp_scale );\n      temp[1] = FT_DivFix( temp[1], temp_scale );\n      temp[2] = FT_DivFix( temp[2], temp_scale );\n      temp[4] = FT_DivFix( temp[4], temp_scale );\n      temp[5] = FT_DivFix( temp[5], temp_scale );\n      temp[3] = temp[3] < 0 ? -0x10000L : 0x10000L;\n    }\n    matrix->xx = temp[0];\n    matrix->yx = temp[1];\n    matrix->xy = temp[2];\n    matrix->yy = temp[3];\n    offset->x = temp[4] >> 16;\n    offset->y = temp[5] >> 16;\n  }", "target": 1}
{"code": "get_cdtext_generic (void *p_user_data)\n{\n  generic_img_private_t *p_env = p_user_data;\n  uint8_t *p_cdtext_data = NULL;\n  size_t  len;\n  if (!p_env) return NULL;\n  if (p_env->b_cdtext_error) return NULL;\n  if (NULL == p_env->cdtext) {\n    p_cdtext_data = read_cdtext_generic (p_env);\n    if (NULL != p_cdtext_data) {\n      len = CDIO_MMC_GET_LEN16(p_cdtext_data)-2;\n      p_env->cdtext = cdtext_init();\n       if(len <= 0 || 0 != cdtext_data_init (p_env->cdtext, &p_cdtext_data[4], len)) {\n         p_env->b_cdtext_error = true;\n        cdtext_destroy (p_env->cdtext);\n         free(p_env->cdtext);\n         p_env->cdtext = NULL;\n       }\n      }\n      free(p_cdtext_data);\n    }\n  }", "target": 1}
{"code": "static inline long object_common1(UNSERIALIZE_PARAMETER, zend_class_entry *ce)\n {\n \tlong elements;\n \telements = parse_iv2((*p) + 2, p);\n \t(*p) += 2;\n\tif (ce->serialize == NULL) {\n\t\tobject_init_ex(*rval, ce);\n\t} else {\n \t\tzend_error(E_WARNING, \"Erroneous data format for unserializing '%s'\", ce->name);\n\t\treturn 0;\n \t}\n \treturn elements;\n}", "target": 1}
{"code": "void pb_controller::play_file(const std::string& file) {\n\tstd::string cmdline;\n\tstd::string player = cfg->get_configvalue(\"player\");\n\tif (player == \"\")\n\t\treturn;\n\tcmdline.append(player);\n\tcmdline.append(\" \\\"\");\n\tcmdline.append(utils::replace_all(file,\"\\\"\", \"\\\\\\\"\"));\n\tcmdline.append(\"\\\"\");\n\tstfl::reset();\n\tutils::run_interactively(cmdline, \"pb_controller::play_file\");\n}", "target": 1}
{"code": "static int shmem_remount_fs(struct super_block *sb, int *flags, char *data)\n{\n\tstruct shmem_sb_info *sbinfo = SHMEM_SB(sb);\n\tstruct shmem_sb_info config = *sbinfo;\n \tunsigned long inodes;\n \tint error = -EINVAL;\n \tif (shmem_parse_options(data, &config, true))\n \t\treturn error;\n\tspin_lock(&sbinfo->stat_lock);\n\tinodes = sbinfo->max_inodes - sbinfo->free_inodes;\n\tif (percpu_counter_compare(&sbinfo->used_blocks, config.max_blocks) > 0)\n\t\tgoto out;\n\tif (config.max_inodes < inodes)\n\t\tgoto out;\n\tif (config.max_blocks && !sbinfo->max_blocks)\n\t\tgoto out;\n\tif (config.max_inodes && !sbinfo->max_inodes)\n\t\tgoto out;\n\terror = 0;\n\tsbinfo->max_blocks  = config.max_blocks;\n \tsbinfo->max_inodes  = config.max_inodes;\n \tsbinfo->free_inodes = config.max_inodes - inodes;\n\tmpol_put(sbinfo->mpol);\n\tsbinfo->mpol        = config.mpol;\t\n out:\n \tspin_unlock(&sbinfo->stat_lock);\n \treturn error;\n}", "target": 1}
{"code": "static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)\n{\n\tstruct fsck_gitmodules_data *data = vdata;\n\tconst char *subsection, *key;\n\tint subsection_len;\n\tchar *name;\n\tif (parse_config_key(var, \"submodule\", &subsection, &subsection_len, &key) < 0 ||\n\t    !subsection)\n\t\treturn 0;\n\tname = xmemdupz(subsection, subsection_len);\n\tif (check_submodule_name(name) < 0)\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_NAME,\n\t\t\t\t    \"disallowed submodule name: %s\",\n\t\t\t\t    name);\n\tif (!strcmp(key, \"url\") && value &&\n\t    looks_like_command_line_option(value))\n\t\tdata->ret |= report(data->options, data->obj,\n \t\t\t\t    FSCK_MSG_GITMODULES_URL,\n \t\t\t\t    \"disallowed submodule url: %s\",\n \t\t\t\t    value);\n \tfree(name);\n \treturn 0;\n}", "target": 1}
{"code": "bool GetNetworkList(NetworkInterfaceList* networks, int policy) {\n  int s = socket(AF_INET, SOCK_DGRAM, 0);\n  if (s <= 0) {\n    PLOG(ERROR) << \"socket\";\n    return false;\n   }\n  uint32_t num_ifs = 0;\n  if (ioctl_netc_get_num_ifs(s, &num_ifs) < 0) {\n    PLOG(ERROR) << \"ioctl_netc_get_num_ifs\";\n    PCHECK(close(s) == 0);\n    return false;\n   }\n  for (uint32_t i = 0; i < num_ifs; ++i) {\n    netc_if_info_t interface;\n    if (ioctl_netc_get_if_info_at(s, &i, &interface) < 0) {\n      PLOG(WARNING) << \"ioctl_netc_get_if_info_at\";\n      continue;\n    }\n    if (internal::IsLoopbackOrUnspecifiedAddress(\n            reinterpret_cast<sockaddr*>(&(interface.addr)))) {\n       continue;\n    }\n    IPEndPoint address;\n    if (!address.FromSockAddr(reinterpret_cast<sockaddr*>(&(interface.addr)),\n                              sizeof(interface.addr))) {\n      DLOG(WARNING) << \"ioctl_netc_get_if_info returned invalid address.\";\n       continue;\n    }\n    int prefix_length = 0;\n    IPEndPoint netmask;\n    if (netmask.FromSockAddr(reinterpret_cast<sockaddr*>(&(interface.netmask)),\n                             sizeof(interface.netmask))) {\n      prefix_length = MaskPrefixLength(netmask.address());\n    }\n     int attributes = 0;\n    networks->push_back(\n        NetworkInterface(interface.name, interface.name, interface.index,\n                         NetworkChangeNotifier::CONNECTION_UNKNOWN,\n                         address.address(), prefix_length, attributes));\n   }\n  PCHECK(close(s) == 0);\n   return true;\n }", "target": 1}
{"code": " status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\"CameraDeviceClient[%d] (%p) PID: %d, dump:\\n\",\n             mCameraId,\n            getRemoteCallback()->asBinder().get(),\n            mClientPid);\n    result.append(\"  State: \");\n    mFrameProcessor->dump(fd, args);\n return dumpDevice(fd, args);\n}", "target": 1}
{"code": "static int nfs_readlink_req(struct nfs_priv *npriv, struct nfs_fh *fh,\n\t\t\t    char **target)\n{\n\tuint32_t data[1024];\n\tuint32_t *p;\n\tuint32_t len;\n\tstruct packet *nfs_packet;\n\tp = &(data[0]);\n\tp = rpc_add_credentials(p);\n\tp = nfs_add_fh3(p, fh);\n\tlen = p - &(data[0]);\n\tnfs_packet = rpc_req(npriv, PROG_NFS, NFSPROC3_READLINK, data, len);\n\tif (IS_ERR(nfs_packet))\n\t\treturn PTR_ERR(nfs_packet);\n\tp = (void *)nfs_packet->data + sizeof(struct rpc_reply) + 4;\n \tp = nfs_read_post_op_attr(p, NULL);\n \tlen = ntoh32(net_read_uint32(p)); \n \tp++;\n \t*target = xzalloc(len + 1);\n\treturn 0;\n}", "target": 1}
{"code": "PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_rpsi(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length,\n\t\t\t\t\tpjmedia_rtcp_fb_rpsi *rpsi)\n{\n    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;\n    pj_uint8_t *p;\n    pj_uint8_t padlen;\n    pj_size_t rpsi_len;\n    PJ_ASSERT_RETURN(buf && rpsi, PJ_EINVAL);\n    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL);\n    if (hdr->pt != RTCP_PSFB || hdr->count != 3)\n\treturn PJ_ENOTFOUND;\n    rpsi_len = (pj_ntohs((pj_uint16_t)hdr->length)-2) * 4;\n    if (length < rpsi_len + 12)\n\treturn PJ_ETOOSMALL;\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    padlen = *p++;\n    rpsi->pt = (*p++ & 0x7F);\n    rpsi->rpsi_bit_len = rpsi_len*8 - 16 - padlen;\n    pj_strset(&rpsi->rpsi, (char*)p, (rpsi->rpsi_bit_len + 7)/8);\n    return PJ_SUCCESS;\n}", "target": 1}
{"code": "static int raw_cmd_copyout(int cmd, void __user *param,\n\t\t\t\t  struct floppy_raw_cmd *ptr)\n{\n \tint ret;\n \twhile (ptr) {\n\t\tret = copy_to_user(param, ptr, sizeof(*ptr));\n \t\tif (ret)\n \t\t\treturn -EFAULT;\n \t\tparam += sizeof(struct floppy_raw_cmd);\n\t\tif ((ptr->flags & FD_RAW_READ) && ptr->buffer_length) {\n\t\t\tif (ptr->length >= 0 &&\n\t\t\t    ptr->length <= ptr->buffer_length) {\n\t\t\t\tlong length = ptr->buffer_length - ptr->length;\n\t\t\t\tret = fd_copyout(ptr->data, ptr->kernel_data,\n\t\t\t\t\t\t length);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "header_cache_t* imap_hcache_open (IMAP_DATA* idata, const char* path)\n{\n  IMAP_MBOX mx;\n  ciss_url_t url;\n  char cachepath[LONG_STRING];\n  char mbox[LONG_STRING];\n  if (path)\n    imap_cachepath (idata, path, mbox, sizeof (mbox));\n  else\n  {\n    if (!idata->ctx || imap_parse_path (idata->ctx->path, &mx) < 0)\n      return NULL;\n    imap_cachepath (idata, mx.mbox, mbox, sizeof (mbox));\n    FREE (&mx.mbox);\n  }\n  mutt_account_tourl (&idata->conn->account, &url);\n  url.path = mbox;\n  url_ciss_tostring (&url, cachepath, sizeof (cachepath), U_PATH);\n  return mutt_hcache_open (HeaderCache, cachepath, imap_hcache_namer);\n}", "target": 1}
{"code": "int dccp_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tconst struct dccp_sock *dp = dccp_sk(sk);\n\tconst int flags = msg->msg_flags;\n\tconst int noblock = flags & MSG_DONTWAIT;\n\tstruct sk_buff *skb;\n\tint rc, size;\n\tlong timeo;\n\ttrace_dccp_probe(sk, len);\n\tif (len > dp->dccps_mss_cache)\n\t\treturn -EMSGSIZE;\n\tlock_sock(sk);\n\tif (dccp_qpolicy_full(sk)) {\n\t\trc = -EAGAIN;\n\t\tgoto out_release;\n\t}\n\ttimeo = sock_sndtimeo(sk, noblock);\n\tif ((1 << sk->sk_state) & ~(DCCPF_OPEN | DCCPF_PARTOPEN))\n\t\tif ((rc = sk_stream_wait_connect(sk, &timeo)) != 0)\n\t\t\tgoto out_release;\n\tsize = sk->sk_prot->max_header + len;\n\trelease_sock(sk);\n\tskb = sock_alloc_send_skb(sk, size, noblock, &rc);\n\tlock_sock(sk);\n\tif (skb == NULL)\n\t\tgoto out_release;\n\tskb_reserve(skb, sk->sk_prot->max_header);\n\trc = memcpy_from_msg(skb_put(skb, len), msg, len);\n\tif (rc != 0)\n\t\tgoto out_discard;\n\trc = dccp_msghdr_parse(msg, skb);\n\tif (rc != 0)\n\t\tgoto out_discard;\n\tdccp_qpolicy_push(sk, skb);\n\tif (!timer_pending(&dp->dccps_xmit_timer))\n\t\tdccp_write_xmit(sk);\nout_release:\n\trelease_sock(sk);\n\treturn rc ? : len;\nout_discard:\n\tkfree_skb(skb);\n\tgoto out_release;\n}", "target": 1}
{"code": "static netdev_features_t bnx2x_features_check(struct sk_buff *skb,\n\t\t\t\t\t      struct net_device *dev,\n\t\t\t\t\t      netdev_features_t features)\n{\n\tfeatures = vlan_features_check(skb, features);\n\treturn vxlan_features_check(skb, features);\n}", "target": 1}
{"code": "TfLiteStatus ExpandTensorDim(TfLiteContext* context, const TfLiteTensor& input,\n                             int axis, TfLiteTensor* output) {\n  const TfLiteIntArray& input_dims = *input.dims;\n  if (axis < 0) {\n    axis = input_dims.size + 1 + axis;\n  }\n  TF_LITE_ENSURE(context, axis <= input_dims.size);\n  TfLiteIntArray* output_dims = TfLiteIntArrayCreate(input_dims.size + 1);\n  for (int i = 0; i < output_dims->size; ++i) {\n    if (i < axis) {\n      output_dims->data[i] = input_dims.data[i];\n    } else if (i == axis) {\n      output_dims->data[i] = 1;\n    } else {\n      output_dims->data[i] = input_dims.data[i - 1];\n    }\n  }\n  return context->ResizeTensor(context, output, output_dims);\n}", "target": 1}
{"code": "dtls1_buffer_record(SSL *s, record_pqueue *queue, unsigned char *priority)\n\t{\n\tDTLS1_RECORD_DATA *rdata;\n\tpitem *item;\n \tif (pqueue_size(queue->q) >= 100)\n \t\treturn 0;\n \trdata = OPENSSL_malloc(sizeof(DTLS1_RECORD_DATA));\n \titem = pitem_new(priority, rdata);\n \tif (rdata == NULL || item == NULL)\n\t\t{\n\t\tif (rdata != NULL) OPENSSL_free(rdata);\n\t\tif (item != NULL) pitem_free(item);\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\treturn(0);\n\t\t}\n\trdata->packet = s->packet;\n\trdata->packet_length = s->packet_length;\n\tmemcpy(&(rdata->rbuf), &(s->s3->rbuf), sizeof(SSL3_BUFFER));\n\tmemcpy(&(rdata->rrec), &(s->s3->rrec), sizeof(SSL3_RECORD));\n\titem->data = rdata;\n#ifndef OPENSSL_NO_SCTP\n\tif (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&\n\t    (s->state == SSL3_ST_SR_FINISHED_A || s->state == SSL3_ST_CR_FINISHED_A)) {\n\t\tBIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SCTP_GET_RCVINFO, sizeof(rdata->recordinfo), &rdata->recordinfo);\n\t}\n#endif\n\ts->packet = NULL;\n\ts->packet_length = 0;\n\tmemset(&(s->s3->rbuf), 0, sizeof(SSL3_BUFFER));\n\tmemset(&(s->s3->rrec), 0, sizeof(SSL3_RECORD));\n \tif (!ssl3_setup_buffers(s))\n \t\t{\n \t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n \t\tOPENSSL_free(rdata);\n \t\tpitem_free(item);\n\t\treturn(0);\n \t\t}\n \tif (pqueue_insert(queue->q, item) == NULL)\n \t\t{\n \t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n \t\tOPENSSL_free(rdata);\n \t\tpitem_free(item);\n\t\treturn(0);\n \t\t}\n \treturn(1);\n\t}", "target": 1}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_line_number_table_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tut64 curpos, offset = 0;\n\tRBinJavaLineNumberAttribute *lnattr;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\toffset += 6;\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_LINE_NUMBER_TABLE_ATTR;\n\tattr->info.line_number_table_attr.line_number_table_length = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.line_number_table_attr.line_number_table = r_list_newf (free);\n\tut32 linenum_len = attr->info.line_number_table_attr.line_number_table_length;\n\tRList *linenum_list = attr->info.line_number_table_attr.line_number_table;\n\tif (linenum_len > sz) {\n\t\tfree (attr);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < linenum_len; i++) {\n\t\tcurpos = buf_offset + offset;\n\t\tlnattr = R_NEW0 (RBinJavaLineNumberAttribute);\n\t\tif (!lnattr) {\n\t\t\tbreak;\n\t\t}\n\t\tlnattr->start_pc = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlnattr->line_number = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlnattr->file_offset = curpos;\n\t\tlnattr->size = 4;\n\t\tr_list_append (linenum_list, lnattr);\n\t}\n\tattr->size = offset;\n\treturn attr;\n}", "target": 1}
{"code": "GF_Err hdlr_dump(GF_Box *a, FILE * trace)\n {\n \tGF_HandlerBox *p = (GF_HandlerBox *)a;\n \tgf_isom_box_dump_start(a, \"HandlerBox\", trace);\n\tif (p->nameUTF8 && (u32) p->nameUTF8[0] == strlen(p->nameUTF8+1)) {\n \t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8+1);\n \t} else {\n \t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8);\n\t}\n\tfprintf(trace, \"reserved1=\\\"%d\\\" reserved2=\\\"\", p->reserved1);\n\tdump_data(trace, (char *) p->reserved2, 12);\n\tfprintf(trace, \"\\\"\");\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"HandlerBox\", a, trace);\n\treturn GF_OK;\n}", "target": 1}
{"code": "static inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsigned int src_size, double scale_d,  const interpolation_method pFilter)\n{\n\tdouble width_d;\n\tdouble scale_f_d = 1.0;\n\tconst double filter_width_d = DEFAULT_BOX_RADIUS;\n\tint windows_size;\n\tunsigned int u;\n\tLineContribType *res;\n\tif (scale_d < 1.0) {\n\t\twidth_d = filter_width_d / scale_d;\n\t\tscale_f_d = scale_d;\n\t}  else {\n\t\twidth_d= filter_width_d;\n\t}\n\twindows_size = 2 * (int)ceil(width_d) + 1;\n\tres = _gdContributionsAlloc(line_size, windows_size);\n\tfor (u = 0; u < line_size; u++) {\n\t\tconst double dCenter = (double)u / scale_d;\n\t\tregister int iLeft = MAX(0, (int)floor (dCenter - width_d));\n\t\tint iRight = MIN((int)ceil(dCenter + width_d), (int)src_size - 1);\n \t\tdouble dTotalWeight = 0.0;\n \t\tint iSrc;\n\t\tres->ContribRow[u].Left = iLeft;\n\t\tres->ContribRow[u].Right = iRight;\n \t\tif (iRight - iLeft + 1 > windows_size)  {\n \t\t\tif (iLeft < ((int)src_size - 1 / 2))  {\n\t\t\t\tiLeft++;\n\t\t\t} else {\n\t\t\t\tiRight--;\n \t\t\t}\n \t\t}\n \t\tfor (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n \t\t\tdTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc)));\n \t\t}\n\t\tif (dTotalWeight < 0.0) {\n\t\t\t_gdContributionsFree(res);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (dTotalWeight > 0.0) {\n\t\t\tfor (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n\t\t\t\tres->ContribRow[u].Weights[iSrc-iLeft] /= dTotalWeight;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}", "target": 1}
{"code": "int dccp_send_reset(struct sock *sk, enum dccp_reset_codes code)\n{\n\tstruct sk_buff *skb;\n\tint err = inet_sk_rebuild_header(sk);\n\tif (err != 0)\n\t\treturn err;\n\tskb = sock_wmalloc(sk, sk->sk_prot->max_header, 1, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOBUFS;\n\tskb_reserve(skb, sk->sk_prot->max_header);\n\tDCCP_SKB_CB(skb)->dccpd_type\t   = DCCP_PKT_RESET;\n\tDCCP_SKB_CB(skb)->dccpd_reset_code = code;\n\treturn dccp_transmit_skb(sk, skb);\n}", "target": 1}
{"code": "static int rfcomm_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)\n{\n\tstruct sockaddr_rc *sa = (struct sockaddr_rc *) addr;\n\tstruct sock *sk = sock->sk;\n \tBT_DBG(\"sock %p, sk %p\", sock, sk);\n \tsa->rc_family  = AF_BLUETOOTH;\n \tsa->rc_channel = rfcomm_pi(sk)->channel;\n \tif (peer)\n\t\tbacpy(&sa->rc_bdaddr, &bt_sk(sk)->dst);\n\telse\n\t\tbacpy(&sa->rc_bdaddr, &bt_sk(sk)->src);\n\t*len = sizeof(struct sockaddr_rc);\n\treturn 0;\n}", "target": 1}
{"code": "TfLiteStatus ResizeOutput(TfLiteContext* context, const TfLiteTensor* input,\n                          const TfLiteTensor* axis, TfLiteTensor* output) {\n  int axis_value;\n  if (axis->type == kTfLiteInt64) {\n    axis_value = static_cast<int>(*GetTensorData<int64_t>(axis));\n  } else {\n    axis_value = *GetTensorData<int>(axis);\n  }\n  if (axis_value < 0) {\n    axis_value += NumDimensions(input);\n  }\n  TfLiteIntArray* output_dims = TfLiteIntArrayCreate(NumDimensions(input) - 1);\n  int j = 0;\n  for (int i = 0; i < NumDimensions(input); ++i) {\n    if (i != axis_value) {\n      output_dims->data[j] = SizeOfDimension(input, i);\n      ++j;\n    }\n  }\n  return context->ResizeTensor(context, output, output_dims);\n}", "target": 1}
{"code": "void fz_init_cached_color_converter(fz_context *ctx, fz_color_converter *cc, fz_colorspace *is, fz_colorspace *ds, fz_colorspace *ss, const fz_color_params *params)\n{\n\tint n = ss->n;\n\tfz_cached_color_converter *cached = fz_malloc_struct(ctx, fz_cached_color_converter);\n\tcc->opaque = cached;\n\tcc->convert = fz_cached_color_convert;\n\tcc->ds = ds ? ds : fz_device_gray(ctx);\n\tcc->ss = ss;\n\tcc->is = is;\n\tfz_try(ctx)\n\t{\n\t\tfz_find_color_converter(ctx, &cached->base, is, cc->ds, ss, params);\n\t\tcached->hash = fz_new_hash_table(ctx, 256, n * sizeof(float), -1, fz_free);\n\t}\n\tfz_catch(ctx)\n\t{\n                fz_drop_color_converter(ctx, &cached->base);\n                fz_drop_hash_table(ctx, cached->hash);\n                fz_free(ctx, cached);\n                fz_rethrow(ctx);\n        }\n }", "target": 1}
{"code": "int ipc_addid(struct ipc_ids *ids, struct kern_ipc_perm *new, int size)\n{\n\tkuid_t euid;\n\tkgid_t egid;\n\tint id;\n\tint next_id = ids->next_id;\n\tif (size > IPCMNI)\n\t\tsize = IPCMNI;\n\tif (ids->in_use >= size)\n\t\treturn -ENOSPC;\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_init(&new->lock);\n\tnew->deleted = false;\n \trcu_read_lock();\n \tspin_lock(&new->lock);\n \tid = idr_alloc(&ids->ipcs_idr, new,\n \t\t       (next_id < 0) ? 0 : ipcid_to_idx(next_id), 0,\n \t\t       GFP_NOWAIT);\n\tidr_preload_end();\n\tif (id < 0) {\n\t\tspin_unlock(&new->lock);\n\t\trcu_read_unlock();\n\t\treturn id;\n\t}\n \tids->in_use++;\n\tcurrent_euid_egid(&euid, &egid);\n\tnew->cuid = new->uid = euid;\n\tnew->gid = new->cgid = egid;\n \tif (next_id < 0) {\n \t\tnew->seq = ids->seq++;\n \t\tif (ids->seq > IPCID_SEQ_MAX)\n\t\t\tids->seq = 0;\n\t} else {\n\t\tnew->seq = ipcid_to_seqx(next_id);\n\t\tids->next_id = -1;\n\t}\n\tnew->id = ipc_buildid(id, new->seq);\n\treturn id;\n}", "target": 1}
{"code": "void CLASS parse_qt (int end)\n{\n  unsigned save, size;\n  char tag[4];\n  order = 0x4d4d;\n  while (ftell(ifp)+7 < end) {\n    save = ftell(ifp);\n    if ((size = get4()) < 8) return;\n    fread (tag, 4, 1, ifp);\n    if (!memcmp(tag,\"moov\",4) ||\n\t!memcmp(tag,\"udta\",4) ||\n\t!memcmp(tag,\"CNTH\",4))\n      parse_qt (save+size);\n    if (!memcmp(tag,\"CNDA\",4))\n      parse_jpeg (ftell(ifp));\n    fseek (ifp, save+size, SEEK_SET);\n  }\n}", "target": 1}
{"code": "size_t zmalloc_size(void *ptr) {\n    void *realptr = (char*)ptr-PREFIX_SIZE;\n    size_t size = *((size_t*)realptr);\n    if (size&(sizeof(long)-1)) size += sizeof(long)-(size&(sizeof(long)-1));\n    return size+PREFIX_SIZE;\n}", "target": 1}
{"code": "eval_js(WebKitWebView * web_view, gchar *script, GString *result) {\n     WebKitWebFrame *frame;\n     JSGlobalContextRef context;\n     JSObjectRef globalobject;\n    JSStringRef var_name;\n     JSStringRef js_script;\n     JSValueRef js_result;\n    JSStringRef js_result_string;\n    size_t js_result_size;\n    js_init();\n    frame = webkit_web_view_get_main_frame(WEBKIT_WEB_VIEW(web_view));\n     context = webkit_web_frame_get_global_context(frame);\n     globalobject = JSContextGetGlobalObject(context);\n    var_name = JSStringCreateWithUTF8CString(\"Uzbl\");\n    JSObjectSetProperty(context, globalobject, var_name,\n                        JSObjectMake(context, uzbl.js.classref, NULL),\n                        kJSClassAttributeNone, NULL);\n     js_script = JSStringCreateWithUTF8CString(script);\n     js_result = JSEvaluateScript(context, js_script, globalobject, NULL, 0, NULL);\n    if (js_result && !JSValueIsUndefined(context, js_result)) {\n        js_result_string = JSValueToStringCopy(context, js_result, NULL);\n        js_result_size = JSStringGetMaximumUTF8CStringSize(js_result_string);\n        if (js_result_size) {\n            char js_result_utf8[js_result_size];\n            JSStringGetUTF8CString(js_result_string, js_result_utf8, js_result_size);\n            g_string_assign(result, js_result_utf8);\n        }\n        JSStringRelease(js_result_string);\n     }\n    JSObjectDeleteProperty(context, globalobject, var_name, NULL);\n    JSStringRelease(var_name);\n     JSStringRelease(js_script);\n }", "target": 1}
{"code": "status_t SampleTable::setSyncSampleParams(off64_t data_offset, size_t data_size) {\n if (mSyncSampleOffset >= 0 || data_size < 8) {\n return ERROR_MALFORMED;\n }\n uint8_t header[8];\n if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n if (U32_AT(header) != 0) {\n return ERROR_MALFORMED;\n }\n uint32_t numSyncSamples = U32_AT(&header[4]);\n if (numSyncSamples < 2) {\n        ALOGV(\"Table of sync samples is empty or has only a single entry!\");\n }\n uint64_t allocSize = (uint64_t)numSyncSamples * sizeof(uint32_t);\n if (allocSize > kMaxTotalSize) {\n        ALOGE(\"Sync sample table size too large.\");\n return ERROR_OUT_OF_RANGE;\n }\n    mTotalSize += allocSize;\n if (mTotalSize > kMaxTotalSize) {\n        ALOGE(\"Sync sample table size would make sample table too large.\\n\"\n \"    Requested sync sample table size = %llu\\n\"\n \"    Eventual sample table size >= %llu\\n\"\n \"    Allowed sample table size = %llu\\n\",\n (unsigned long long)allocSize,\n (unsigned long long)mTotalSize,\n (unsigned long long)kMaxTotalSize);\n return ERROR_OUT_OF_RANGE;\n }\n    mSyncSamples = new (std::nothrow) uint32_t[numSyncSamples];\n if (!mSyncSamples) {\n        ALOGE(\"Cannot allocate sync sample table with %llu entries.\",\n (unsigned long long)numSyncSamples);\n return ERROR_OUT_OF_RANGE;\n }\n     if (mDataSource->readAt(data_offset + 8, mSyncSamples,\n             (size_t)allocSize) != (ssize_t)allocSize) {\n        delete mSyncSamples;\n         mSyncSamples = NULL;\n         return ERROR_IO;\n     }\n for (size_t i = 0; i < numSyncSamples; ++i) {\n if (mSyncSamples[i] == 0) {\n            ALOGE(\"b/32423862, unexpected zero value in stss\");\n continue;\n }\n        mSyncSamples[i] = ntohl(mSyncSamples[i]) - 1;\n }\n    mSyncSampleOffset = data_offset;\n    mNumSyncSamples = numSyncSamples;\n return OK;\n}", "target": 1}
{"code": "user_change_icon_file_authorized_cb (Daemon                *daemon,\n                                     User                  *user,\n                                     GDBusMethodInvocation *context,\n                                     gpointer               data)\n{\n        g_autofree gchar *filename = NULL;\n        g_autoptr(GFile) file = NULL;\n        g_autoptr(GFileInfo) info = NULL;\n        guint32 mode;\n        GFileType type;\n        guint64 size;\n        filename = g_strdup (data);\n        if (filename == NULL ||\n            *filename == '\\0') {\n                g_autofree gchar *dest_path = NULL;\n                g_autoptr(GFile) dest = NULL;\n                g_autoptr(GError) error = NULL;\n                g_clear_pointer (&filename, g_free);\n                dest_path = g_build_filename (ICONDIR, accounts_user_get_user_name (ACCOUNTS_USER (user)), NULL);\n                dest = g_file_new_for_path (dest_path);\n                if (!g_file_delete (dest, NULL, &error) &&\n                    !g_error_matches (error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {\n                        throw_error (context, ERROR_FAILED, \"failed to remove user icon, %s\", error->message);\n                        return;\n                }\n                goto icon_saved;\n         }\n         file = g_file_new_for_path (filename);\n         info = g_file_query_info (file, G_FILE_ATTRIBUTE_UNIX_MODE \",\"\n                                         G_FILE_ATTRIBUTE_STANDARD_TYPE \",\"\n                                         G_FILE_ATTRIBUTE_STANDARD_SIZE,\n                return;\n        }", "target": 1}
{"code": "void\nyyerror(YYLTYPE *yylloc, void *scanner, struct yang_parameter *param, ...)\n{\n  free(*param->value);\n  if (yylloc->first_line != -1) {\n    if (*param->data_node && (*param->data_node) == (*param->actual_node)) {\n      LOGVAL(param->module->ctx, LYE_INSTMT, LY_VLOG_LYS, *param->data_node, yyget_text(scanner));\n    } else {\n      LOGVAL(param->module->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, yyget_text(scanner));\n    }\n  }", "target": 1}
{"code": "snd_seq_oss_synth_make_info(struct seq_oss_devinfo *dp, int dev, struct synth_info *inf)\n{\n\tstruct seq_oss_synth *rec;\n\tif (dp->synths[dev].is_midi) {\n\t\tstruct midi_info minf;\n\t\tsnd_seq_oss_midi_make_info(dp, dp->synths[dev].midi_mapped, &minf);\n\t\tinf->synth_type = SYNTH_TYPE_MIDI;\n\t\tinf->synth_subtype = 0;\n\t\tinf->nr_voices = 16;\n\t\tinf->device = dev;\n\t\tstrlcpy(inf->name, minf.name, sizeof(inf->name));\n\t} else {\n\t\tif ((rec = get_synthdev(dp, dev)) == NULL)\n\t\t\treturn -ENXIO;\n\t\tinf->synth_type = rec->synth_type;\n\t\tinf->synth_subtype = rec->synth_subtype;\n\t\tinf->nr_voices = rec->nr_voices;\n\t\tinf->device = dev;\n\t\tstrlcpy(inf->name, rec->name, sizeof(inf->name));\n\t\tsnd_use_lock_free(&rec->use_lock);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void Lua::setParamsTable(lua_State* vm, const char* table_name,\n\t\t\t const char* query) const {\n  char outbuf[FILENAME_MAX];\n  char *where;\n  char *tok;\n  char *query_string = query ? strdup(query) : NULL;\n  lua_newtable(L);\n  if (query_string) {\n    tok = strtok_r(query_string, \"&\", &where);\n    while(tok != NULL) {\n      char *_equal;\n      if(strncmp(tok, \"csrf\", strlen(\"csrf\")) \n\t && (_equal = strchr(tok, '='))) {\n\tchar *decoded_buf;\n        int len;\n        _equal[0] = '\\0';\n        _equal = &_equal[1];\n        len = strlen(_equal);\n        purifyHTTPParameter(tok), purifyHTTPParameter(_equal);\n        if((decoded_buf = (char*)malloc(len+1)) != NULL) {\n          Utils::urlDecode(_equal, decoded_buf, len+1);\n\t  Utils::purifyHTTPparam(tok, true, false);\n\t  Utils::purifyHTTPparam(decoded_buf, false, false);\n\t  FILE *fd;\n\t  if((decoded_buf[0] == '.')\n\t     && ((fd = fopen(decoded_buf, \"r\"))\n\t\t || (fd = fopen(realpath(decoded_buf, outbuf), \"r\")))) {\n\t    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Discarded '%s'='%s' as argument is a valid file path\",\n\t\t\t\t\t tok, decoded_buf);\n\t    decoded_buf[0] = '\\0';\n\t    fclose(fd);\n\t  }\n\t  lua_push_str_table_entry(vm, tok, decoded_buf);\n          free(decoded_buf);\n        } else\n          ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");\n      }\n      tok = strtok_r(NULL, \"&\", &where);\n    } \n  }\n  if(query_string) free(query_string);\n  if(table_name)\n    lua_setglobal(L, table_name);\n  else\n    lua_setglobal(L, (char*)\"_GET\"); \n}", "target": 1}
{"code": "int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *a, ASN1_BIT_STRING *signature,\n\t     void *asn, EVP_PKEY *pkey)\n\t{\n\tEVP_MD_CTX ctx;\n\tconst EVP_MD *type;\n        unsigned char *buf_in=NULL;\n        int ret= -1,i,inl;\n        EVP_MD_CTX_init(&ctx);\n        i=OBJ_obj2nid(a->algorithm);\n        type=EVP_get_digestbyname(OBJ_nid2sn(i));\n\tif (!EVP_VerifyInit_ex(&ctx,type, NULL))\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);\n\t\tret=0;\n\t\tgoto err;\n\t\t}\n\tinl = ASN1_item_i2d(asn, &buf_in, it);\n\tif (buf_in == NULL)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t\t}\n\tEVP_VerifyUpdate(&ctx,(unsigned char *)buf_in,inl);\n\tOPENSSL_cleanse(buf_in,(unsigned int)inl);\n\tOPENSSL_free(buf_in);\n\tif (EVP_VerifyFinal(&ctx,(unsigned char *)signature->data,\n\t\t\t(unsigned int)signature->length,pkey) <= 0)\n\t\t{\n\t\tASN1err(ASN1_F_ASN1_ITEM_VERIFY,ERR_R_EVP_LIB);\n\t\tret=0;\n\t\tgoto err;\n\t\t}\n\tret=1;\nerr:\n\tEVP_MD_CTX_cleanup(&ctx);\n\treturn(ret);\n\t}", "target": 1}
{"code": "static void do_free_upto(BIO *f, BIO *upto)\n\t{\n\tif (upto)\n\t\t{\n\t\tBIO *tbio;\n\t\tdo \n\t\t\t{\n\t\t\ttbio = BIO_pop(f);\n \t\t\tBIO_free(f);\n \t\t\tf = tbio;\n \t\t\t}\n\t\twhile (f != upto);\n \t\t}\n \telse\n \t\tBIO_free_all(f);\n\t}", "target": 1}
{"code": "MagickExport MagickBooleanType SetImageProfile(Image *image,const char *name,\n  const StringInfo *profile,ExceptionInfo *exception)\n{\n  char\n    key[MaxTextExtent],\n    property[MaxTextExtent];\n  MagickBooleanType\n    status;\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    image->profiles=NewSplayTree(CompareSplayTreeString,RelinquishMagickMemory,\n      DestroyProfile);\n  (void) CopyMagickString(key,name,MaxTextExtent);\n  status=AddValueToSplayTree((SplayTreeInfo *) image->profiles,\n    ConstantString(key),CloneStringInfo(profile));\n  if ((status != MagickFalse) &&\n      ((LocaleCompare(name,\"iptc\") == 0) || (LocaleCompare(name,\"8bim\") == 0)))\n    (void) GetProfilesFromResourceBlock(image,profile,exception);\n  (void) FormatLocaleString(property,MaxTextExtent,\"%s:sans\",name);\n  (void) GetImageProperty(image,property,exception);\n  return(status);\n}", "target": 1}
{"code": "void Document::open(Document* entered_document,\n                    ExceptionState& exception_state) {\n  if (ImportLoader()) {\n    exception_state.ThrowDOMException(\n        kInvalidStateError, \"Imported document doesn't support open().\");\n    return;\n  }\n  if (!IsHTMLDocument()) {\n    exception_state.ThrowDOMException(kInvalidStateError,\n                                      \"Only HTML documents support open().\");\n    return;\n  }\n  if (throw_on_dynamic_markup_insertion_count_) {\n    exception_state.ThrowDOMException(\n        kInvalidStateError,\n        \"Custom Element constructor should not use open().\");\n    return;\n  }\n  if (entered_document) {\n    if (!GetSecurityOrigin()->IsSameSchemeHostPortAndSuborigin(\n            entered_document->GetSecurityOrigin())) {\n      exception_state.ThrowSecurityError(\n          \"Can only call open() on same-origin documents.\");\n      return;\n    }\n    SetSecurityOrigin(entered_document->GetSecurityOrigin());\n    if (this != entered_document) {\n       KURL new_url = entered_document->Url();\n       new_url.SetFragmentIdentifier(String());\n       SetURL(new_url);\n     }\n     cookie_url_ = entered_document->CookieURL();\n  }\n  open();\n}", "target": 1}
{"code": "status_t Parcel::appendFrom(const Parcel *parcel, size_t offset, size_t len)\n{\n const sp<ProcessState> proc(ProcessState::self());\n status_t err;\n const uint8_t *data = parcel->mData;\n const binder_size_t *objects = parcel->mObjects;\n size_t size = parcel->mObjectsSize;\n int startPos = mDataPos;\n int firstIndex = -1, lastIndex = -2;\n if (len == 0) {\n return NO_ERROR;\n }\n if ((offset > parcel->mDataSize)\n || (len > parcel->mDataSize)\n || (offset + len > parcel->mDataSize)) {\n return BAD_VALUE;\n }\n     for (int i = 0; i < (int) size; i++) {\n         size_t off = objects[i];\n        if ((off >= offset) && (off < offset + len)) {\n             if (firstIndex == -1) {\n                 firstIndex = i;\n             }\n            lastIndex = i;\n }\n }\n int numObjects = lastIndex - firstIndex + 1;\n if ((mDataSize+len) > mDataCapacity) {\n        err = growData(len);\n if (err != NO_ERROR) {\n return err;\n }\n }\n    memcpy(mData + mDataPos, data + offset, len);\n    mDataPos += len;\n    mDataSize += len;\n    err = NO_ERROR;\n if (numObjects > 0) {\n if (mObjectsCapacity < mObjectsSize + numObjects) {\n int newSize = ((mObjectsSize + numObjects)*3)/2;\n binder_size_t *objects =\n (binder_size_t*)realloc(mObjects, newSize*sizeof(binder_size_t));\n if (objects == (binder_size_t*)0) {\n return NO_MEMORY;\n }\n            mObjects = objects;\n            mObjectsCapacity = newSize;\n }\n int idx = mObjectsSize;\n for (int i = firstIndex; i <= lastIndex; i++) {\n size_t off = objects[i] - offset + startPos;\n            mObjects[idx++] = off;\n            mObjectsSize++;\n            flat_binder_object* flat\n = reinterpret_cast<flat_binder_object*>(mData + off);\n            acquire_object(proc, *flat, this);\n if (flat->type == BINDER_TYPE_FD) {\n                flat->handle = dup(flat->handle);\n                flat->cookie = 1;\n                mHasFds = mFdsKnown = true;\n if (!mAllowFds) {\n                    err = FDS_NOT_ALLOWED;\n }\n }\n }\n }\n return err;\n}", "target": 1}
{"code": "Status ImmutableExecutorState::BuildControlFlowInfo(const Graph* g,\n                                                    ControlFlowInfo* cf_info) {\n  const int num_nodes = g->num_node_ids();\n  cf_info->frame_names.resize(num_nodes);\n  std::vector<Node*> parent_nodes;\n  parent_nodes.resize(num_nodes);\n  std::vector<bool> visited;\n  visited.resize(num_nodes);\n  string frame_name;\n  std::deque<Node*> ready;\n  for (Node* n : g->nodes()) {\n    if (n->in_edges().empty()) {\n      visited[n->id()] = true;\n      cf_info->unique_frame_names.insert(frame_name);\n      ready.push_back(n);\n    }\n  }\n  while (!ready.empty()) {\n    Node* curr_node = ready.front();\n    int curr_id = curr_node->id();\n    ready.pop_front();\n    Node* parent = nullptr;\n    if (IsEnter(curr_node)) {\n      TF_RETURN_IF_ERROR(\n          GetNodeAttr(curr_node->attrs(), \"frame_name\", &frame_name));\n      parent = curr_node;\n    } else if (IsExit(curr_node)) {\n      parent = parent_nodes[curr_id];\n      frame_name = cf_info->frame_names[parent->id()];\n      parent = parent_nodes[parent->id()];\n    } else {\n      parent = parent_nodes[curr_id];\n      frame_name = cf_info->frame_names[curr_id];\n    }\n    for (const Edge* out_edge : curr_node->out_edges()) {\n      Node* out = out_edge->dst();\n      if (IsSink(out)) continue;\n      const int out_id = out->id();\n      bool is_visited = visited[out_id];\n      if (!is_visited) {\n        ready.push_back(out);\n        visited[out_id] = true;\n        cf_info->frame_names[out_id] = frame_name;\n        parent_nodes[out_id] = parent;\n        cf_info->unique_frame_names.insert(frame_name);\n      }\n    }\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "  explicit HashContext(const HashContext* ctx) {\n    assert(ctx->ops);\n    assert(ctx->ops->context_size >= 0);\n    ops = ctx->ops;\n    context = malloc(ops->context_size);\n    ops->hash_copy(context, ctx->context);\n    options = ctx->options;\n    key = ctx->key ? strdup(ctx->key) : nullptr;\n  }", "target": 1}
{"code": "BGD_DECLARE(void *) gdImagePngPtr (gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx (2048, NULL);\n\tif (out == NULL) return NULL;\n\tgdImagePngCtxEx (im, out, -1);\n\trv = gdDPExtractData (out, size);\n\tout->gd_free (out);\n\treturn rv;\n}", "target": 1}
{"code": "  static bool TryParse(const char* inp, int length,\n                       TypedValue* buf, Variant& out,\n                       JSONContainerType container_type, bool is_tsimplejson) {\n    SimpleParser parser(inp, length, buf, container_type, is_tsimplejson);\n    bool ok = parser.parseValue();\n    parser.skipSpace();\n    if (!ok || parser.p != inp + length) {\n      tvDecRefRange(buf, parser.top);\n      return false;\n    }\n    out = Variant::attach(*--parser.top);\n    return true;\n  }", "target": 1}
{"code": "int fcntl_dirnotify(int fd, struct file *filp, unsigned long arg)\n{\n\tstruct dnotify_struct *dn;\n\tstruct dnotify_struct *odn;\n\tstruct dnotify_struct **prev;\n\tstruct inode *inode;\n\tfl_owner_t id = current->files;\n\tint error = 0;\n\tif ((arg & ~DN_MULTISHOT) == 0) {\n\t\tdnotify_flush(filp, id);\n\t\treturn 0;\n\t}\n\tif (!dir_notify_enable)\n\t\treturn -EINVAL;\n\tinode = filp->f_path.dentry->d_inode;\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn -ENOTDIR;\n\tdn = kmem_cache_alloc(dn_cache, GFP_KERNEL);\n\tif (dn == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock(&inode->i_lock);\n\tprev = &inode->i_dnotify;\n\twhile ((odn = *prev) != NULL) {\n\t\tif ((odn->dn_owner == id) && (odn->dn_filp == filp)) {\n\t\t\todn->dn_fd = fd;\n\t\t\todn->dn_mask |= arg;\n\t\t\tinode->i_dnotify_mask |= arg & ~DN_MULTISHOT;\n\t\t\tgoto out_free;\n\t\t}\n\t\tprev = &odn->dn_next;\n\t}\n\terror = __f_setown(filp, task_pid(current), PIDTYPE_PID, 0);\n\tif (error)\n\t\tgoto out_free;\n\tdn->dn_mask = arg;\n\tdn->dn_fd = fd;\n\tdn->dn_filp = filp;\n\tdn->dn_owner = id;\n\tinode->i_dnotify_mask |= arg & ~DN_MULTISHOT;\n\tdn->dn_next = inode->i_dnotify;\n\tinode->i_dnotify = dn;\n\tspin_unlock(&inode->i_lock);\n\tif (filp->f_op && filp->f_op->dir_notify)\n\t\treturn filp->f_op->dir_notify(filp, arg);\n\treturn 0;\nout_free:\n\tspin_unlock(&inode->i_lock);\n\tkmem_cache_free(dn_cache, dn);\n\treturn error;\n}", "target": 1}
{"code": "xfs_acl_from_disk(struct xfs_acl *aclp)\n{\n\tstruct posix_acl_entry *acl_e;\n\tstruct posix_acl *acl;\n\tstruct xfs_acl_entry *ace;\n \tint count, i;\n \tcount = be32_to_cpu(aclp->acl_cnt);\n \tacl = posix_acl_alloc(count, GFP_KERNEL);\n \tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (i = 0; i < count; i++) {\n\t\tacl_e = &acl->a_entries[i];\n\t\tace = &aclp->acl_entry[i];\n\t\tacl_e->e_tag = be32_to_cpu(ace->ae_tag);\n\t\tacl_e->e_perm = be16_to_cpu(ace->ae_perm);\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\tcase ACL_GROUP:\n\t\t\tacl_e->e_id = be32_to_cpu(ace->ae_id);\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tacl_e->e_id = ACL_UNDEFINED_ID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}", "target": 1}
{"code": "entry_guard_obeys_restriction(const entry_guard_t *guard,\n                              const entry_guard_restriction_t *rst)\n{\n  tor_assert(guard);\n   if (! rst)\n     return 1; \n   return tor_memneq(guard->identity, rst->exclude_id, DIGEST_LEN);\n }", "target": 1}
{"code": "gostdsa_vko (const struct ecc_scalar *priv,\n\t\tconst struct ecc_point *pub,\n\t\tsize_t ukm_length, const uint8_t *ukm,\n\t\tuint8_t *out)\n{\n  const struct ecc_curve *ecc = priv->ecc;\n  unsigned bsize = (ecc_bit_size (ecc) + 7) / 8;\n  mp_size_t size = ecc->p.size;\n  mp_size_t itch = 4*size + ecc->mul_itch;\n  mp_limb_t *scratch;\n  if (itch < 5*size + ecc->h_to_a_itch)\n      itch = 5*size + ecc->h_to_a_itch;\n  assert (pub->ecc == ecc);\n  assert (priv->ecc == ecc);\n  assert (ukm_length <= bsize);\n  scratch = gmp_alloc_limbs (itch);\n#define UKM scratch\n#define TEMP (scratch + 3*size)\n#define XYZ scratch\n#define TEMP_Y (scratch + 4*size)\n  mpn_set_base256_le (UKM, size, ukm, ukm_length);\n  if (mpn_zero_p (UKM, size))\n    UKM[0] = 1;\n  ecc_mod_mul (&ecc->q, TEMP, priv->p, UKM, TEMP); \n  ecc->mul (ecc, XYZ, TEMP, pub->p, scratch + 4*size); \n  ecc->h_to_a (ecc, 0, TEMP, XYZ, scratch + 5*size); \n  mpn_get_base256_le (out, bsize, TEMP, size);\n  mpn_get_base256_le (out+bsize, bsize, TEMP_Y, size);\n  gmp_free_limbs (scratch, itch);\n}", "target": 1}
{"code": "nfssvc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_writeargs *args)\n{\n\tunsigned int len, hdr, dlen;\n\tstruct kvec *head = rqstp->rq_arg.head;\n\tint v;\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp++;\t\t\t\t\n\targs->offset = ntohl(*p++);\t\n\tp++;\t\t\t\t\n\tlen = args->len = ntohl(*p++);\n\tif (len > NFSSVC_MAXBLKSIZE_V2)\n\t\treturn 0;\n \thdr = (void*)p - head->iov_base;\n \tdlen = head->iov_len + rqstp->rq_arg.page_len - hdr;\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = head->iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}", "target": 1}
{"code": "folly::Optional<TLSMessage> PlaintextReadRecordLayer::read(\n    folly::IOBufQueue& buf) {\n  while (true) {\n    folly::io::Cursor cursor(buf.front());\n    if (buf.empty() || !cursor.canAdvance(kPlaintextHeaderSize)) {\n      return folly::none;\n    }\n    TLSMessage msg;\n    msg.type = static_cast<ContentType>(cursor.readBE<ContentTypeType>());\n    if (skipEncryptedRecords_) {\n      if (msg.type == ContentType::application_data) {\n        cursor.skip(sizeof(ProtocolVersion));\n        auto length = cursor.readBE<uint16_t>();\n        if (buf.chainLength() < (cursor - buf.front()) + length) {\n          return folly::none;\n        }\n        length +=\n            sizeof(ContentType) + sizeof(ProtocolVersion) + sizeof(uint16_t);\n        buf.trimStart(length);\n        continue;\n      } else if (msg.type != ContentType::change_cipher_spec) {\n        skipEncryptedRecords_ = false;\n      }\n    }\n    switch (msg.type) {\n      case ContentType::handshake:\n      case ContentType::alert:\n        break;\n      case ContentType::change_cipher_spec:\n        break;\n      default:\n        throw std::runtime_error(folly::to<std::string>(\n            \"received plaintext content type \",\n            static_cast<ContentTypeType>(msg.type),\n            \", header: \",\n            folly::hexlify(buf.splitAtMost(10)->coalesce())));\n    }\n    receivedRecordVersion_ =\n        static_cast<ProtocolVersion>(cursor.readBE<ProtocolVersionType>());\n    auto length = cursor.readBE<uint16_t>();\n    if (length > kMaxPlaintextRecordSize) {\n      throw std::runtime_error(\"received too long plaintext record\");\n    }\n    if (length == 0) {\n      throw std::runtime_error(\"received empty plaintext record\");\n    }\n    if (buf.chainLength() < (cursor - buf.front()) + length) {\n      return folly::none;\n    }\n    cursor.clone(msg.fragment, length);\n    buf.trimStart(cursor - buf.front());\n    if (msg.type == ContentType::change_cipher_spec) {\n      msg.fragment->coalesce();\n      if (msg.fragment->length() == 1 && *msg.fragment->data() == 0x01) {\n        continue;\n      } else {\n        throw FizzException(\n            \"received ccs\", AlertDescription::illegal_parameter);\n      }\n    }\n    return std::move(msg);\n  }\n}", "target": 1}
{"code": "bool ATSParser::PSISection::isCRCOkay() const {\n if (!isComplete()) {\n return false;\n }\n uint8_t* data = mBuffer->data();\n if ((data[1] & 0x80) == 0) {\n return true;\n }\n     unsigned sectionLength = U16_AT(data + 1) & 0xfff;\n     ALOGV(\"sectionLength %u, skip %u\", sectionLength, mSkipBytes);\n     sectionLength -= mSkipBytes;\n uint32_t crc = 0xffffffff;\n for(unsigned i = 0; i < sectionLength + 4 ; i++) {\n uint8_t b = data[i];\n int index = ((crc >> 24) ^ (b & 0xff)) & 0xff;\n        crc = CRC_TABLE[index] ^ (crc << 8);\n }\n    ALOGV(\"crc: %08x\\n\", crc);\n return (crc == 0);\n}", "target": 1}
{"code": "dvi_document_file_exporter_end (EvFileExporter *exporter)\n{\n\tgchar *command_line;\n\tgint exit_stat;\n\tGError *err = NULL;\n\tgboolean success;\n\tDviDocument *dvi_document = DVI_DOCUMENT(exporter);\n\tcommand_line = g_strdup_printf (\"dvipdfm %s -o %s \\\"%s\\\"\", \n\t\t\t\t\tdvi_document->exporter_opts->str,\n\t\t\t\t\tdvi_document->exporter_filename,\n\t\t\t\t\tdvi_document->context->filename);\n\tsuccess = g_spawn_command_line_sync (command_line,\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     &exit_stat,\n\t\t\t\t\t     &err);\n\tg_free (command_line);\n\tif (success == FALSE) {\n\t\tg_warning (\"Error: %s\", err->message);\n\t} else if (!WIFEXITED(exit_stat) || WEXITSTATUS(exit_stat) != EXIT_SUCCESS){\n\t\tg_warning (\"Error: dvipdfm does not end normally or exit with a failure status.\");\n\t}\n\tif (err)\n\t\tg_error_free (err);\n}", "target": 1}
{"code": "static void get_socket_name(SingleInstData* data, char* buf, int len)\n{\n    const char* dpy = g_getenv(\"DISPLAY\");\n    char* host = NULL;\n    int dpynum;\n    if(dpy)\n    {\n        const char* p = strrchr(dpy, ':');\n        host = g_strndup(dpy, (p - dpy));\n        dpynum = atoi(p + 1);\n     }\n     else\n         dpynum = 0;\n     g_snprintf(buf, len, \"%s/.%s-socket-%s-%d-%s\",\n                 g_get_tmp_dir(),\n                 data->prog_name,\n                 host ? host : \"\",\n                 dpynum,\n                 g_get_user_name());\n }", "target": 1}
{"code": "asmlinkage long sys_oabi_semtimedop(int semid,\n\t\t\t\t    struct oabi_sembuf __user *tsops,\n\t\t\t\t    unsigned nsops,\n\t\t\t\t    const struct timespec __user *timeout)\n{\n\tstruct sembuf *sops;\n\tstruct timespec local_timeout;\n \tlong err;\n \tint i;\n\tif (nsops < 1)\n \t\treturn -EINVAL;\n \tsops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);\n \tif (!sops)\n\t\treturn -ENOMEM;\n\terr = 0;\n\tfor (i = 0; i < nsops; i++) {\n\t\t__get_user_error(sops[i].sem_num, &tsops->sem_num, err);\n\t\t__get_user_error(sops[i].sem_op,  &tsops->sem_op,  err);\n\t\t__get_user_error(sops[i].sem_flg, &tsops->sem_flg, err);\n\t\ttsops++;\n\t}\n\tif (timeout) {\n\t\terr |= copy_from_user(&local_timeout, timeout, sizeof(*timeout));\n\t\ttimeout = &local_timeout;\n\t}\n\tif (err) {\n\t\terr = -EFAULT;\n\t} else {\n\t\tmm_segment_t fs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t\terr = sys_semtimedop(semid, sops, nsops, timeout);\n\t\tset_fs(fs);\n\t}\n\tkfree(sops);\n\treturn err;\n}", "target": 1}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_constant_value_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 6;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_CONST_VALUE_ATTR;\n\t\tattr->info.constant_value_attr.constantvalue_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}", "target": 1}
{"code": " static void smp_task_done(struct sas_task *task)\n {\n\tif (!del_timer(&task->slow_task->timer))\n\t\treturn;\n \tcomplete(&task->slow_task->completion);\n }", "target": 1}
{"code": "rend_service_intro_established(origin_circuit_t *circuit,\n                               const uint8_t *request,\n                               size_t request_len)\n{\n  rend_service_t *service;\n  rend_intro_point_t *intro;\n  char serviceid[REND_SERVICE_ID_LEN_BASE32+1];\n  (void) request;\n  (void) request_len;\n  tor_assert(circuit->rend_data);\n  const char *rend_pk_digest =\n    (char *) rend_data_get_pk_digest(circuit->rend_data, NULL);\n  if (circuit->base_.purpose != CIRCUIT_PURPOSE_S_ESTABLISH_INTRO) {\n    log_warn(LD_PROTOCOL,\n             \"received INTRO_ESTABLISHED cell on non-intro circuit.\");\n    goto err;\n  }\n  service = rend_service_get_by_pk_digest(rend_pk_digest);\n  if (!service) {\n    log_warn(LD_REND, \"Unknown service on introduction circuit %u.\",\n              (unsigned)circuit->base_.n_circ_id);\n     goto err;\n   }\n   intro = find_intro_point(circuit);\n  if (intro == NULL) {\n    log_warn(LD_REND,\n             \"Introduction circuit established without a rend_intro_point_t \"\n             \"object for service %s on circuit %u\",\n             safe_str_client(serviceid), (unsigned)circuit->base_.n_circ_id);\n    goto err;\n  }\n  intro->circuit_established = 1;\n   service->desc_is_dirty = time(NULL);\n   circuit_change_purpose(TO_CIRCUIT(circuit), CIRCUIT_PURPOSE_S_INTRO);\n  base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32 + 1,\n                rend_pk_digest, REND_SERVICE_ID_LEN);\n   log_info(LD_REND,\n            \"Received INTRO_ESTABLISHED cell on circuit %u for service %s\",\n            (unsigned)circuit->base_.n_circ_id, serviceid);\n  pathbias_mark_use_success(circuit);\n  return 0;\n err:\n  circuit_mark_for_close(TO_CIRCUIT(circuit), END_CIRC_REASON_TORPROTOCOL);\n  return -1;\n}", "target": 1}
{"code": "eval0_retarg(\n    char_u\t*arg,\n    typval_T\t*rettv,\n    exarg_T\t*eap,\n    evalarg_T\t*evalarg,\n    char_u\t**retarg)\n{\n    int\t\tret;\n    char_u\t*p;\n    char_u\t*expr_end;\n    int\t\tdid_emsg_before = did_emsg;\n    int\t\tcalled_emsg_before = called_emsg;\n    int\t\tflags = evalarg == NULL ? 0 : evalarg->eval_flags;\n    int\t\tcheck_for_end = retarg == NULL;\n    int\t\tend_error = FALSE;\n    p = skipwhite(arg);\n    ret = eval1(&p, rettv, evalarg);\n    expr_end = p;\n    p = skipwhite(p);\n    if (in_vim9script() && p > expr_end && retarg == NULL)\n\twhile (*p == '#')\n\t{\n\t    char_u *nl = vim_strchr(p, NL);\n\t    if (nl == NULL)\n\t\tbreak;\n\t    p = skipwhite(nl + 1);\n\t    if (eap != NULL && *p != NUL)\n\t\teap->nextcmd = p;\n\t    check_for_end = FALSE;\n\t}\n    if (ret != FAIL && check_for_end)\n\tend_error = !ends_excmd2(arg, p);\n    if (ret == FAIL || end_error)\n    {\n\tif (ret != FAIL)\n\t    clear_tv(rettv);\n\tif (!aborting()\n\t\t&& did_emsg == did_emsg_before\n\t\t&& called_emsg == called_emsg_before\n\t\t&& (flags & EVAL_CONSTANT) == 0\n\t\t&& (!in_vim9script() || !vim9_bad_comment(p)))\n\t{\n\t    if (end_error)\n\t\tsemsg(_(e_trailing_characters_str), p);\n\t    else\n\t\tsemsg(_(e_invalid_expression_str), arg);\n\t}\n\tif (eap != NULL && skipwhite(p)[0] == '|' && skipwhite(p)[1] != '|')\n\t    eap->nextcmd = check_nextcmd(p);\n\treturn FAIL;\n    }\n    if (retarg != NULL)\n\t*retarg = p;\n    else if (check_for_end && eap != NULL)\n\tset_nextcmd(eap, p);\n    return ret;\n}", "target": 1}
{"code": "static int ati_remote2_probe(struct usb_interface *interface, const struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(interface);\n\tstruct usb_host_interface *alt = interface->cur_altsetting;\n\tstruct ati_remote2 *ar2;\n\tint r;\n\tif (alt->desc.bInterfaceNumber)\n\t\treturn -ENODEV;\n\tar2 = kzalloc(sizeof (struct ati_remote2), GFP_KERNEL);\n\tif (!ar2)\n\t\treturn -ENOMEM;\n \tar2->udev = udev;\n \tar2->intf[0] = interface;\n \tar2->ep[0] = &alt->endpoint[0].desc;\n \tar2->intf[1] = usb_ifnum_to_if(udev, 1);\n \tr = usb_driver_claim_interface(&ati_remote2_driver, ar2->intf[1], ar2);\n \tif (r)\n \t\tgoto fail1;\n \talt = ar2->intf[1]->cur_altsetting;\n \tar2->ep[1] = &alt->endpoint[0].desc;\n \tr = ati_remote2_urb_init(ar2);\n \tif (r)\n\t\tgoto fail2;\n \tar2->channel_mask = channel_mask;\n \tar2->mode_mask = mode_mask;\n \tr = ati_remote2_setup(ar2, ar2->channel_mask);\n \tif (r)\n\t\tgoto fail2;\n \tusb_make_path(udev, ar2->phys, sizeof(ar2->phys));\n \tstrlcat(ar2->phys, \"/input0\", sizeof(ar2->phys));\n\tstrlcat(ar2->name, \"ATI Remote Wonder II\", sizeof(ar2->name));\n \tr = sysfs_create_group(&udev->dev.kobj, &ati_remote2_attr_group);\n \tif (r)\n\t\tgoto fail2;\n \tr = ati_remote2_input_init(ar2);\n \tif (r)\n\t\tgoto fail3;\n \tusb_set_intfdata(interface, ar2);\n \tinterface->needs_remote_wakeup = 1;\n \treturn 0;\n fail3:\n \tsysfs_remove_group(&udev->dev.kobj, &ati_remote2_attr_group);\n fail2:\n \tati_remote2_urb_cleanup(ar2);\n \tusb_driver_release_interface(&ati_remote2_driver, ar2->intf[1]);\n  fail1:\n \tkfree(ar2);\n\treturn r;\n}", "target": 1}
{"code": "PerformanceNavigationTiming::PerformanceNavigationTiming(\n    LocalFrame* frame,\n     ResourceTimingInfo* info,\n     TimeTicks time_origin,\n     const WebVector<WebServerTimingInfo>& server_timing)\n    : PerformanceResourceTiming(info ? info->InitialURL().GetString() : \"\",\n                                \"navigation\",\n                                time_origin,\n                                server_timing),\n       ContextClient(frame),\n       resource_timing_info_(info) {\n   DCHECK(frame);\n  DCHECK(info);\n}", "target": 1}
{"code": "id3_skip (SF_PRIVATE * psf)\n{\tunsigned char\tbuf [10] ;\n\tmemset (buf, 0, sizeof (buf)) ;\n\tpsf_binheader_readf (psf, \"pb\", 0, buf, 10) ;\n\tif (buf [0] == 'I' && buf [1] == 'D' && buf [2] == '3')\n\t{\tint\toffset = buf [6] & 0x7f ;\n\t\toffset = (offset << 7) | (buf [7] & 0x7f) ;\n\t\toffset = (offset << 7) | (buf [8] & 0x7f) ;\n\t\toffset = (offset << 7) | (buf [9] & 0x7f) ;\n\t\tpsf_log_printf (psf, \"ID3 length : %d\\n--------------------\\n\", offset) ;\n\t\tif (offset < 0)\n\t\t\treturn 0 ;\n \t\tpsf->fileoffset += offset + 10 ;\n\t\tpsf_binheader_readf (psf, \"p\", psf->fileoffset) ;\n\t\treturn 1 ;\n \t\t} ;\n \treturn 0 ;\n} ", "target": 1}
{"code": "static Image *ExtractPostscript(Image *image,const ImageInfo *image_info,\n  MagickOffsetType PS_Offset,ssize_t PS_Size,ExceptionInfo *exception)\n{\n  char\n    postscript_file[MaxTextExtent];\n  const MagicInfo\n    *magic_info;\n  FILE\n    *ps_file;\n  ImageInfo\n    *clone_info;\n  Image\n    *image2;\n  unsigned char\n    magick[2*MaxTextExtent];\n  if ((clone_info=CloneImageInfo(image_info)) == NULL)\n    return(image);\n  clone_info->blob=(void *) NULL;\n  clone_info->length=0;\n  (void) AcquireUniqueFilename(postscript_file);\n  ps_file=fopen_utf8(postscript_file,\"wb\");\n  if (ps_file == (FILE *) NULL)\n    goto FINISH;\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  (void) ReadBlob(image, 2*MaxTextExtent, magick);\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  while(PS_Size-- > 0)\n    {\n      (void) fputc(ReadBlobByte(image),ps_file);\n    }\n  (void) fclose(ps_file);\n  magic_info=GetMagicInfo(magick,2*MaxTextExtent,exception);\n  if(magic_info == (const MagicInfo *) NULL) goto FINISH_UNL;\n   if(exception->severity != UndefinedException) goto FINISH_UNL;\n   if(magic_info->name == (char *) NULL) goto FINISH_UNL;\n  (void) strncpy(clone_info->magick,magic_info->name,MaxTextExtent);\n  FormatLocaleString(clone_info->filename,MaxTextExtent,\"%s\",postscript_file);\n  image2=ReadImage(clone_info,exception);\n  if (!image2)\n    goto FINISH_UNL;\n  (void) CopyMagickString(image2->filename,image->filename,MaxTextExtent);\n  (void) CopyMagickString(image2->magick_filename,image->magick_filename,MaxTextExtent);\n  (void) CopyMagickString(image2->magick,image->magick,MaxTextExtent);\n  image2->depth=image->depth;\n  DestroyBlob(image2);\n  image2->blob=ReferenceBlob(image->blob);\n  if ((image->rows == 0) || (image->columns == 0))\n    DeleteImageFromList(&image);\n  AppendImageToList(&image,image2);\n FINISH_UNL:\n  (void) RelinquishUniqueFileResource(postscript_file);\n FINISH:\n  DestroyImageInfo(clone_info);\n  return(image);\n}", "target": 1}
{"code": "void *enc_untrusted_realloc(void *ptr, size_t size) {\n  MessageWriter input;\n  input.Push(reinterpret_cast<uint64_t>(ptr));\n  input.Push(static_cast<uint64_t>(size));\n  MessageReader output;\n  asylo::primitives::PrimitiveStatus status =\n      asylo::host_call::NonSystemCallDispatcher(\n          asylo::host_call::kReallocHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_realloc\", 2);\n  void *result = output.next<void *>();\n  int klinux_errno = output.next<int>();\n  if (!result && size != 0) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n  return result;\n}", "target": 1}
{"code": " create_response(const char *nurl, const char *method, unsigned int *rp_code)\n {\n       char *page, *fpath;\n        struct MHD_Response *resp = NULL;\n        if (!strncmp(nurl, URL_BASE_API_1_1, strlen(URL_BASE_API_1_1))) {\n                resp = create_response_api(nurl, method, rp_code);\n        } else {\n                fpath = get_path(nurl, server_data.www_dir);\n               resp = create_response_file(nurl, method, rp_code, fpath);\n                free(fpath);\n        }\n}", "target": 1}
{"code": " int DH_check_pub_key(const DH *dh, const BIGNUM *pub_key, int *ret)\n {\n     int ok = 0;\n    BIGNUM *q = NULL;\n     *ret = 0;\n    q = BN_new();\n    if (q == NULL)\n         goto err;\n    BN_set_word(q, 1);\n    if (BN_cmp(pub_key, q) <= 0)\n         *ret |= DH_CHECK_PUBKEY_TOO_SMALL;\n    BN_copy(q, dh->p);\n    BN_sub_word(q, 1);\n    if (BN_cmp(pub_key, q) >= 0)\n         *ret |= DH_CHECK_PUBKEY_TOO_LARGE;\n     ok = 1;\n  err:\n    if (q != NULL)\n        BN_free(q);\n     return (ok);\n }", "target": 1}
{"code": "struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,\n\t\t\t\t   const struct sk_buff *skb,\n\t\t\t\t   int flags, pol_lookup_t lookup)\n{\n\tstruct rt6_info *rt;\n\trt = lookup(net, net->ipv6.fib6_main_tbl, fl6, skb, flags);\n\tif (rt->dst.error == -EAGAIN) {\n\t\tip6_rt_put_flags(rt, flags);\n\t\trt = net->ipv6.ip6_null_entry;\n\t\tif (!(flags | RT6_LOOKUP_F_DST_NOREF))\n\t\t\tdst_hold(&rt->dst);\n\t}\n\treturn &rt->dst;\n}", "target": 1}
{"code": " static void recalculate_apic_map(struct kvm *kvm)\n {\n \tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\tnew = kzalloc(sizeof(struct kvm_apic_map), GFP_KERNEL);\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\tif (!new)\n\t\tgoto out;\n\tnew->ldr_bits = 8;\n\tnew->cid_shift = 8;\n\tnew->cid_mask = 0;\n\tnew->lid_mask = 0xff;\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tu16 cid, lid;\n\t\tu32 ldr;\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n \t\tif (apic_x2apic_mode(apic)) {\n \t\t\tnew->ldr_bits = 32;\n \t\t\tnew->cid_shift = 16;\n\t\t\tnew->cid_mask = new->lid_mask = 0xffff;\n \t\t} else if (kvm_apic_sw_enabled(apic) &&\n \t\t\t\t!new->cid_mask  &&\n \t\t\t\tkvm_apic_get_reg(apic, APIC_DFR) == APIC_DFR_CLUSTER) {\n\t\t\tnew->cid_shift = 4;\n\t\t\tnew->cid_mask = 0xf;\n\t\t\tnew->lid_mask = 0xf;\n\t\t}\n\t\tnew->phys_map[kvm_apic_id(apic)] = apic;\n\t\tldr = kvm_apic_get_reg(apic, APIC_LDR);\n\t\tcid = apic_cluster_id(new, ldr);\n\t\tlid = apic_logical_id(new, ldr);\n\t\tif (lid)\n\t\t\tnew->logical_map[cid][ffs(lid) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\tkvm_vcpu_request_scan_ioapic(kvm);\n}", "target": 1}
{"code": "  bool HasOverflowed() const {\n    StackGuard* stack_guard = isolate_->stack_guard();\n    return (reinterpret_cast<uintptr_t>(this) < stack_guard->climit()) &&\n           stack_guard->IsStackOverflow();\n  }", "target": 1}
{"code": "static int ldb_kv_index_dn_attr(struct ldb_module *module,\n\t\t\t\tstruct ldb_kv_private *ldb_kv,\n\t\t\t\tconst char *attr,\n\t\t\t\tstruct ldb_dn *dn,\n\t\t\t\tstruct dn_list *list,\n\t\t\t\tenum key_truncation *truncation)\n{\n\tstruct ldb_context *ldb;\n\tstruct ldb_dn *key;\n\tstruct ldb_val val;\n\tint ret;\n\tldb = ldb_module_get_ctx(module);\n\tval.data = (uint8_t *)((uintptr_t)ldb_dn_get_casefold(dn));\n\tval.length = strlen((char *)val.data);\n\tkey = ldb_kv_index_key(ldb, ldb_kv, attr, &val, NULL, truncation);\n\tif (!key) {\n\t\tldb_oom(ldb);\n\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t}\n\tret = ldb_kv_dn_list_load(module, ldb_kv, key, list);\n\ttalloc_free(key);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (list->count == 0) {\n\t\treturn LDB_ERR_NO_SUCH_OBJECT;\n\t}\n\treturn LDB_SUCCESS;\n}", "target": 1}
{"code": "lzw_decoder_feed (LZWDecoder *self,\n                  guint8     *input,\n                  gsize       input_length,\n                  guint8     *output,\n                  gsize       output_length)\n{\n        gsize i, n_written = 0;\n        g_return_val_if_fail (LZW_IS_DECODER (self), 0);\n        if (self->last_code == self->eoi_code)\n                return 0;\n        for (i = 0; i < input_length; i++) {\n                guint8 d = input[i];\n                int n_available;\n                for (n_available = 8; n_available > 0; ) {\n                        int n_bits, new_bits;\n                        n_bits = MIN (self->code_size - self->code_bits, n_available);\n                        new_bits = d & ((1 << n_bits) - 1);\n                        d = d >> n_bits;\n                        n_available -= n_bits;\n                        self->code = new_bits << self->code_bits | self->code;\n                        self->code_bits += n_bits;\n                        if (self->code_bits < self->code_size)\n                                continue;\n                        if (self->code == self->eoi_code) {\n                                self->last_code = self->code;\n                                return n_written;\n                        }\n                        if (self->code == self->clear_code) {\n                                self->code_table_size = self->eoi_code + 1;\n                                self->code_size = self->min_code_size;\n                        } else {\n                                if (self->last_code != self->clear_code && self->code_table_size < MAX_CODES) {\n                                        if (self->code < self->code_table_size)\n                                                add_code (self, self->code);\n                                        else if (self->code == self->code_table_size)\n                                                add_code (self, self->last_code);\n                                        else {\n                                                self->last_code = self->eoi_code;\n                                                return output_length;\n                                        }\n                                        if (self->code_table_size == (1 << self->code_size) && self->code_size < LZW_CODE_MAX)\n                                                self->code_size++;\n                                }\n                                n_written += write_indexes (self, output + n_written, output_length - n_written);\n                        }\n                        self->last_code = self->code;\n                        self->code = 0;\n                        self->code_bits = 0;\n                        if (n_written >= output_length)\n                                return output_length;\n                }\n        }\n        return n_written;\n}", "target": 1}
{"code": "bool DownloadItemImpl::CanOpenDownload() {\n   const bool is_complete = GetState() == DownloadItem::COMPLETE;\n   return (!IsDone() || is_complete) && !IsTemporary() &&\n         !file_externally_removed_;\n }", "target": 1}
{"code": " void add_param_to_argv(char *parsestart, int line)\n {\n\tint quote_open = 0, escaped = 0, param_len = 0;\n\tchar param_buffer[1024], *curchar;\n\t\t\tparam_buffer[param_len++] = *curchar;\n\t\t\tif (param_len >= sizeof(param_buffer))\n\t\t\t\txtables_error(PARAMETER_PROBLEM,\n \t\tcase ' ':\n \t\tcase '\\t':\n \t\tcase '\\n':\n\t\t\tif (!param_len) {\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t\tbreak;\n \t\tdefault:\n\t\t\tparam_buffer[param_len++] = *curchar;\n\t\t\tif (param_len >= sizeof(param_buffer))\n\t\t\t\txtables_error(PARAMETER_PROBLEM,\n\t\t\t\t\t      \"Parameter too long!\");\n \t\t\tcontinue;\n \t\t}\n\t\tparam_buffer[param_len] = '\\0';\n\t\tif ((param_buffer[0] == '-' &&\n\t\t     param_buffer[1] != '-' &&\n\t\t     strchr(param_buffer, 't')) ||\n\t\t    (!strncmp(param_buffer, \"--t\", 3) &&\n\t\t     !strncmp(param_buffer, \"--table\", strlen(param_buffer)))) {\n \t\t\txtables_error(PARAMETER_PROBLEM,\n \t\t\t\t      \"The -t option (seen in line %u) cannot be used in %s.\\n\",\n \t\t\t\t      line, xt_params->program_name);\n \t\t}\n\t\tadd_argv(param_buffer, 0);\n\t\tparam_len = 0;\n \t}", "target": 1}
{"code": "int SafeMulDims(const matvar_t *matvar, size_t* nelems)\n{\n    int i;\n    for ( i = 0; i < matvar->rank; i++ ) {\n        if ( !psnip_safe_size_mul(nelems, *nelems, matvar->dims[i]) ) {\n            *nelems = 0;\n            return 1;\n        }\n    }\n    return 0;\n}", "target": 1}
{"code": "static gboolean udscs_server_accept_cb(GSocketService    *service,\n                                       GSocketConnection *socket_conn,\n                                       GObject           *source_object,\n                                       gpointer           user_data)\n{\n    struct udscs_server *server = user_data;\n    UdscsConnection *new_conn;\n    new_conn = g_object_new(UDSCS_TYPE_CONNECTION, NULL);\n    new_conn->debug = server->debug;\n    new_conn->read_callback = server->read_callback;\n    g_object_ref(socket_conn);\n    vdagent_connection_setup(VDAGENT_CONNECTION(new_conn),\n                             G_IO_STREAM(socket_conn),\n                             FALSE,\n                             sizeof(struct udscs_message_header),\n                             server->error_cb);\n    server->connections = g_list_prepend(server->connections, new_conn);\n    if (server->debug)\n        syslog(LOG_DEBUG, \"new client accepted: %p\", new_conn);\n    if (server->connect_callback)\n        server->connect_callback(new_conn);\n    return TRUE;\n}", "target": 1}
{"code": "static bool ndp_msg_check_valid(struct ndp_msg *msg)\n{\n\tsize_t len = ndp_msg_payload_len(msg);\n\tenum ndp_msg_type msg_type = ndp_msg_type(msg);\n \tif (len < ndp_msg_type_info(msg_type)->raw_struct_size)\n \t\treturn false;\n\treturn true;\n }", "target": 1}
{"code": "userauth_gssapi(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tgss_OID_desc goid = {0, NULL};\n\tGssctxt *ctxt = NULL;\n\tint r, present;\n\tu_int mechs;\n\tOM_uint32 ms;\n \tsize_t len;\n \tu_char *doid = NULL;\n\tif (!authctxt->valid || authctxt->user == NULL)\n\t\treturn (0);\n \tif ((r = sshpkt_get_u32(ssh, &mechs)) != 0)\n \t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\tif (mechs == 0) {\n\t\tdebug(\"Mechanism negotiation is not supported\");\n\t\treturn (0);\n\t}\n\tdo {\n\t\tmechs--;\n\t\tfree(doid);\n\t\tpresent = 0;\n\t\tif ((r = sshpkt_get_string(ssh, &doid, &len)) != 0)\n\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\tif (len > 2 && doid[0] == SSH_GSS_OIDTYPE &&\n\t\t    doid[1] == len - 2) {\n\t\t\tgoid.elements = doid + 2;\n\t\t\tgoid.length   = len - 2;\n\t\t\tssh_gssapi_test_oid_supported(&ms, &goid, &present);\n\t\t} else {\n\t\t\tlogit(\"Badly formed OID received\");\n\t\t}\n\t} while (mechs > 0 && !present);\n\tif (!present) {\n\t\tfree(doid);\n\t\tauthctxt->server_caused_failure = 1;\n \t\treturn (0);\n \t}\n \tif (GSS_ERROR(PRIVSEP(ssh_gssapi_server_ctx(&ctxt, &goid)))) {\n \t\tif (ctxt != NULL)\n \t\t\tssh_gssapi_delete_ctx(&ctxt);\n\t\tfree(doid);\n\t\tauthctxt->server_caused_failure = 1;\n\t\treturn (0);\n\t}\n\tauthctxt->methoddata = (void *)ctxt;\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_GSSAPI_RESPONSE)) != 0 ||\n\t    (r = sshpkt_put_string(ssh, doid, len)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\tfree(doid);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, &input_gssapi_token);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, &input_gssapi_errtok);\n\tauthctxt->postponed = 1;\n\treturn (0);\n}", "target": 1}
{"code": "PHP_FUNCTION(imagegammacorrect)\n{\n\tzval *IM;\n\tgdImagePtr im;\n\tint i;\n\tdouble input, output;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rdd\", &IM, &input, &output) == FAILURE) {\n \t\treturn;\n \t}\n \tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n \tif (gdImageTrueColor(im))\t{\n\t\tint x, y, c;\n\t\tfor (y = 0; y < gdImageSY(im); y++)\t{\n\t\t\tfor (x = 0; x < gdImageSX(im); x++)\t{\n\t\t\t\tc = gdImageGetPixel(im, x, y);\n\t\t\t\tgdImageSetPixel(im, x, y,\n\t\t\t\t\tgdTrueColorAlpha(\n\t\t\t\t\t\t(int) ((pow((pow((gdTrueColorGetRed(c)   / 255.0), input)), 1.0 / output) * 255) + .5),\n\t\t\t\t\t\t(int) ((pow((pow((gdTrueColorGetGreen(c) / 255.0), input)), 1.0 / output) * 255) + .5),\n\t\t\t\t\t\t(int) ((pow((pow((gdTrueColorGetBlue(c)  / 255.0), input)), 1.0 / output) * 255) + .5),\n\t\t\t\t\t\tgdTrueColorGetAlpha(c)\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tRETURN_TRUE;\n\t}\n\tfor (i = 0; i < gdImageColorsTotal(im); i++) {\n\t\tim->red[i]   = (int)((pow((pow((im->red[i]   / 255.0), input)), 1.0 / output) * 255) + .5);\n\t\tim->green[i] = (int)((pow((pow((im->green[i] / 255.0), input)), 1.0 / output) * 255) + .5);\n\t\tim->blue[i]  = (int)((pow((pow((im->blue[i]  / 255.0), input)), 1.0 / output) * 255) + .5);\n\t}\n\tRETURN_TRUE;\n}", "target": 1}
{"code": "mrb_obj_clone(mrb_state *mrb, mrb_value self)\n{\n  struct RObject *p;\n  mrb_value clone;\n  if (mrb_immediate_p(self)) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"can't clone %S\", self);\n  }\n  if (mrb_type(self) == MRB_TT_SCLASS) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't clone singleton class\");\n  }\n  p = (struct RObject*)mrb_obj_alloc(mrb, mrb_type(self), mrb_obj_class(mrb, self));\n  p->c = mrb_singleton_class_clone(mrb, self);\n   mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)p->c);\n   clone = mrb_obj_value(p);\n   init_copy(mrb, clone, self);\n  p->flags = mrb_obj_ptr(self)->flags;\n   return clone;\n }", "target": 1}
{"code": "char* engrave_tombstone(pid_t pid, pid_t tid, int signal, int original_si_code,\n uintptr_t abort_msg_address, bool dump_sibling_threads,\n bool* detach_failed, int* total_sleep_time_usec) {\n log_t log;\n   log.current_tid = tid;\n   log.crashed_tid = tid;\n  if ((mkdir(TOMBSTONE_DIR, 0755) == -1) && (errno != EEXIST)) {\n    _LOG(&log, logtype::ERROR, \"failed to create %s: %s\\n\", TOMBSTONE_DIR, strerror(errno));\n  }\n  if (chown(TOMBSTONE_DIR, AID_SYSTEM, AID_SYSTEM) == -1) {\n    _LOG(&log, logtype::ERROR, \"failed to change ownership of %s: %s\\n\", TOMBSTONE_DIR, strerror(errno));\n  }\n   int fd = -1;\n  char* path = NULL;\n  if (selinux_android_restorecon(TOMBSTONE_DIR, 0) == 0) {\n    path = find_and_open_tombstone(&fd);\n  } else {\n    _LOG(&log, logtype::ERROR, \"Failed to restore security context, not writing tombstone.\\n\");\n  }\n   if (fd < 0) {\n     _LOG(&log, logtype::ERROR, \"Skipping tombstone write, nothing to do.\\n\");\n *detach_failed = false;\n return NULL;\n }\n  log.tfd = fd;\n int amfd = activity_manager_connect();\n  log.amfd = amfd;\n *detach_failed = dump_crash(&log, pid, tid, signal, original_si_code, abort_msg_address,\n                              dump_sibling_threads, total_sleep_time_usec);\n  ALOGI(\"\\nTombstone written to: %s\\n\", path);\n  close(amfd);\n  close(fd);\n return path;\n}", "target": 1}
{"code": "check_vim9_unlet(char_u *name)\n{\n    if (name[1] != ':' || vim_strchr((char_u *)\"gwtb\", *name) == NULL)\n    {\n\tif (*name == 's' && !script_is_vim9())\n\t    return OK;\n\tsemsg(_(e_cannot_unlet_str), name);\n\treturn FAIL;\n    }\n    return OK;\n}", "target": 1}
{"code": "static int rds_ib_laddr_check(__be32 addr)\n{\n\tint ret;\n\tstruct rdma_cm_id *cm_id;\n\tstruct sockaddr_in sin;\n\tcm_id = rdma_create_id(NULL, NULL, RDMA_PS_TCP, IB_QPT_RC);\n\tif (IS_ERR(cm_id))\n\t\treturn PTR_ERR(cm_id);\n\tmemset(&sin, 0, sizeof(sin));\n\tsin.sin_family = AF_INET;\n\tsin.sin_addr.s_addr = addr;\n \tret = rdma_bind_addr(cm_id, (struct sockaddr *)&sin);\n\tif (ret || cm_id->device->node_type != RDMA_NODE_IB_CA)\n \t\tret = -EADDRNOTAVAIL;\n \trdsdebug(\"addr %pI4 ret %d node type %d\\n\",\n\t\t&addr, ret,\n\t\tcm_id->device ? cm_id->device->node_type : -1);\n\trdma_destroy_id(cm_id);\n\treturn ret;\n}", "target": 1}
{"code": "void uverbs_user_mmap_disassociate(struct ib_uverbs_file *ufile)\n{\n\tstruct rdma_umap_priv *priv, *next_priv;\n\tlockdep_assert_held(&ufile->hw_destroy_rwsem);\n\twhile (1) {\n\t\tstruct mm_struct *mm = NULL;\n\t\tmutex_lock(&ufile->umap_lock);\n\t\twhile (!list_empty(&ufile->umaps)) {\n\t\t\tint ret;\n\t\t\tpriv = list_first_entry(&ufile->umaps,\n\t\t\t\t\t\tstruct rdma_umap_priv, list);\n\t\t\tmm = priv->vma->vm_mm;\n\t\t\tret = mmget_not_zero(mm);\n\t\t\tif (!ret) {\n\t\t\t\tlist_del_init(&priv->list);\n\t\t\t\tmm = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&ufile->umap_lock);\n\t\tif (!mm)\n\t\t\treturn;\n \t\tdown_write(&mm->mmap_sem);\n \t\tmutex_lock(&ufile->umap_lock);\n \t\tlist_for_each_entry_safe (priv, next_priv, &ufile->umaps,\n \t\t\t\t\t  list) {\n\t\t\tstruct vm_area_struct *vma = priv->vma;\n\t\t\tif (vma->vm_mm != mm)\n\t\t\t\tcontinue;\n\t\t\tlist_del_init(&priv->list);\n\t\t\tzap_vma_ptes(vma, vma->vm_start,\n\t\t\t\t     vma->vm_end - vma->vm_start);\n \t\t\tvma->vm_flags &= ~(VM_SHARED | VM_MAYSHARE);\n \t\t}\n \t\tmutex_unlock(&ufile->umap_lock);\n \t\tup_write(&mm->mmap_sem);\n \t\tmmput(mm);\n \t}\n}", "target": 1}
{"code": "asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,\n \t\t\t\t unsigned long arg)\n {\n\tstruct oabi_flock64 user;\n \tstruct flock64 kernel;\n\tmm_segment_t fs = USER_DS; \n\tunsigned long local_arg = arg;\n\tint ret;\n \tswitch (cmd) {\n \tcase F_OFD_GETLK:\n \tcase F_OFD_SETLK:\n \tcase F_OFD_SETLKW:\n \tcase F_GETLK64:\n \tcase F_SETLK64:\n \tcase F_SETLKW64:\n\t\tif (copy_from_user(&user, (struct oabi_flock64 __user *)arg,\n\t\t\t\t   sizeof(user)))\n\t\t\treturn -EFAULT;\n\t\tkernel.l_type\t= user.l_type;\n\t\tkernel.l_whence\t= user.l_whence;\n\t\tkernel.l_start\t= user.l_start;\n\t\tkernel.l_len\t= user.l_len;\n\t\tkernel.l_pid\t= user.l_pid;\n\t\tlocal_arg = (unsigned long)&kernel;\n\t\tfs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t}\n\tret = sys_fcntl64(fd, cmd, local_arg);\n\tswitch (cmd) {\n\tcase F_GETLK64:\n\t\tif (!ret) {\n\t\t\tuser.l_type\t= kernel.l_type;\n\t\t\tuser.l_whence\t= kernel.l_whence;\n\t\t\tuser.l_start\t= kernel.l_start;\n\t\t\tuser.l_len\t= kernel.l_len;\n\t\t\tuser.l_pid\t= kernel.l_pid;\n\t\t\tif (copy_to_user((struct oabi_flock64 __user *)arg,\n\t\t\t\t\t &user, sizeof(user)))\n\t\t\t\tret = -EFAULT;\n\t\t}\n\tcase F_SETLK64:\n\tcase F_SETLKW64:\n\t\tset_fs(fs);\n \t}\n\treturn ret;\n }", "target": 1}
{"code": "ResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,\n                         xkb_mod_mask_t *mods_rtrn, CompatInfo *info)\n{\n    if (expr == NULL) {\n        *pred_rtrn = MATCH_ANY_OR_NONE;\n        *mods_rtrn = MOD_REAL_MASK_ALL;\n        return true;\n    }\n     *pred_rtrn = MATCH_EXACTLY;\n     if (expr->expr.op == EXPR_ACTION_DECL) {\n         const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);\n        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn)) {\n             log_err(info->ctx,\n                     \"Illegal modifier predicate \\\"%s\\\"; Ignored\\n\", pred_txt);\n             return false;\n        }\n        expr = expr->action.args;\n    }\n    else if (expr->expr.op == EXPR_IDENT) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->ident.ident);\n        if (pred_txt && istreq(pred_txt, \"any\")) {\n            *pred_rtrn = MATCH_ANY;\n            *mods_rtrn = MOD_REAL_MASK_ALL;\n            return true;\n        }\n    }\n    return ExprResolveModMask(info->ctx, expr, MOD_REAL, &info->mods,\n                              mods_rtrn);\n}", "target": 1}
{"code": "static int do_session_handshake (lua_State *L, int status, lua_KContext ctx) {\n    int rc;\n    struct ssh_userdata *sshu = NULL;\n    assert(lua_gettop(L) == 4);\n    sshu = (struct ssh_userdata *) nseU_checkudata(L, 3, SSH2_UDATA, \"ssh2\");\n    while ((rc = libssh2_session_handshake(sshu->session, sshu->sp[0])) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 3, \"filter\");\n        lua_pushvalue(L, 3);\n        assert(lua_status(L) == LUA_OK);\n        lua_callk(L, 1, 0, 0, do_session_handshake);\n    }\n    if (rc) {\n        libssh2_session_free(sshu->session);\n        return luaL_error(L, \"Unable to complete libssh2 handshake.\");\n    }\n    lua_settop(L, 3);\n    return 1;\n}", "target": 1}
{"code": "bool_t xdr_nullstring(XDR *xdrs, char **objp)\n{\n     u_int size;\n     if (xdrs->x_op == XDR_ENCODE) {\n\t  if (*objp == NULL)\n\t       size = 0;\n\t  else\n\t       size = strlen(*objp) + 1;\n     }\n     if (! xdr_u_int(xdrs, &size)) {\n\t  return FALSE;\n\t}\n     switch (xdrs->x_op) {\n     case XDR_DECODE:\n\t  if (size == 0) {\n\t       *objp = NULL;\n\t       return TRUE;\n\t  } else if (*objp == NULL) {\n\t       *objp = (char *) mem_alloc(size);\n\t       if (*objp == NULL) {\n\t\t    errno = ENOMEM;\n \t\t    return FALSE;\n \t       }\n \t  }\n\t  return (xdr_opaque(xdrs, *objp, size));\n      case XDR_ENCODE:\n \t  if (size != 0)\n\t       return (xdr_opaque(xdrs, *objp, size));\n\t  return TRUE;\n     case XDR_FREE:\n\t  if (*objp != NULL)\n\t       mem_free(*objp, size);\n\t  *objp = NULL;\n\t  return TRUE;\n     }\n     return FALSE;\n}", "target": 1}
{"code": "void * CAPSTONE_API cs_winkernel_malloc(size_t size)\n{\n\tNT_ASSERT(size);\n#pragma prefast(suppress : 30030)\t\t\n\tCS_WINKERNEL_MEMBLOCK *block = (CS_WINKERNEL_MEMBLOCK *)ExAllocatePoolWithTag(\n\t\t\tNonPagedPool, size + sizeof(CS_WINKERNEL_MEMBLOCK), CS_WINKERNEL_POOL_TAG);\n\tif (!block) {\n\t\treturn NULL;\n\t}\n\tblock->size = size;\n\treturn block->data;\n}", "target": 1}
{"code": "static UINT drdynvc_process_capability_request(drdynvcPlugin* drdynvc, int Sp,\n        int cbChId, wStream* s)\n{\n\tUINT status;\n \tif (!drdynvc)\n \t\treturn CHANNEL_RC_BAD_INIT_HANDLE;\n \tWLog_Print(drdynvc->log, WLOG_TRACE, \"capability_request Sp=%d cbChId=%d\", Sp, cbChId);\n \tStream_Seek(s, 1); \n \tStream_Read_UINT16(s, drdynvc->version);\n \tif ((drdynvc->version == 2) || (drdynvc->version == 3))\n \t{\n \t\tStream_Read_UINT16(s, drdynvc->PriorityCharge0);\n \t\tStream_Read_UINT16(s, drdynvc->PriorityCharge1);\n \t\tStream_Read_UINT16(s, drdynvc->PriorityCharge2);\n\t\tStream_Read_UINT16(s, drdynvc->PriorityCharge3);\n\t}\n\tstatus = drdynvc_send_capability_response(drdynvc);\n\tdrdynvc->state = DRDYNVC_STATE_READY;\n \treturn status;\n }", "target": 1}
{"code": "void CLua::init_libraries()\n{\n    lua_stack_cleaner clean(state());\n    cluaopen_kills(_state);\n    cluaopen_you(_state);\n    cluaopen_item(_state);\n    cluaopen_food(_state);\n    cluaopen_crawl(_state);\n    cluaopen_file(_state);\n    cluaopen_moninf(_state);\n    cluaopen_options(_state);\n    cluaopen_travel(_state);\n    cluaopen_view(_state);\n    cluaopen_spells(_state);\n    cluaopen_globals(_state);\n    execfile(\"dlua/macro.lua\", true, true);\n    execstring(\"chk_startgame = { }\", \"base\");\n    lua_register(_state, \"loadfile\", _clua_loadfile);\n    lua_register(_state, \"dofile\", _clua_dofile);\n    lua_register(_state, \"crawl_require\", _clua_require);\n    execfile(\"dlua/util.lua\", true, true);\n    execfile(\"dlua/iter.lua\", true, true);\n    execfile(\"dlua/tags.lua\", true, true);\n    execfile(\"dlua/init.lua\", true, true);\n    if (managed_vm)\n    {\n        lua_register(_state, \"pcall\", _clua_guarded_pcall);\n        execfile(\"dlua/userbase.lua\", true, true);\n        execfile(\"dlua/persist.lua\", true, true);\n    }\n}", "target": 1}
{"code": "static int ext4_destroy_inline_data_nolock(handle_t *handle,\n\t\t\t\t\t   struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct ext4_xattr_ibody_find is = {\n\t\t.s = { .not_found = 0, },\n\t};\n\tstruct ext4_xattr_info i = {\n\t\t.name_index = EXT4_XATTR_INDEX_SYSTEM,\n\t\t.name = EXT4_XATTR_SYSTEM_DATA,\n\t\t.value = NULL,\n\t\t.value_len = 0,\n\t};\n\tint error;\n\tif (!ei->i_inline_off)\n\t\treturn 0;\n\terror = ext4_get_inode_loc(inode, &is.iloc);\n\tif (error)\n\t\treturn error;\n\terror = ext4_xattr_ibody_find(inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\tBUFFER_TRACE(is.iloc.bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, is.iloc.bh);\n\tif (error)\n\t\tgoto out;\n\terror = ext4_xattr_ibody_inline_set(handle, inode, &i, &is);\n\tif (error)\n\t\tgoto out;\n\tmemset((void *)ext4_raw_inode(&is.iloc)->i_block,\n\t\t0, EXT4_MIN_INLINE_DATA_SIZE);\n\tif (ext4_has_feature_extents(inode->i_sb)) {\n\t\tif (S_ISDIR(inode->i_mode) ||\n\t\t    S_ISREG(inode->i_mode) || S_ISLNK(inode->i_mode)) {\n\t\t\text4_set_inode_flag(inode, EXT4_INODE_EXTENTS);\n\t\t\text4_ext_tree_init(handle, inode);\n\t\t}\n\t}\n\text4_clear_inode_flag(inode, EXT4_INODE_INLINE_DATA);\n\tget_bh(is.iloc.bh);\n\terror = ext4_mark_iloc_dirty(handle, inode, &is.iloc);\n\tEXT4_I(inode)->i_inline_off = 0;\n\tEXT4_I(inode)->i_inline_size = 0;\n\text4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);\nout:\n\tbrelse(is.iloc.bh);\n\tif (error == -ENODATA)\n\t\terror = 0;\n\treturn error;\n}", "target": 1}
{"code": "static int ne2000_buffer_full(NE2000State *s)\n {\n     int avail, index, boundary;\n     index = s->curpag << 8;\n     boundary = s->boundary << 8;\n     if (index < boundary)\n        return 1;\n    return 0;\n}", "target": 1}
{"code": "int snd_usb_pipe_sanity_check(struct usb_device *dev, unsigned int pipe)\n{\n\tstatic const int pipetypes[4] = {\n\t\tPIPE_CONTROL, PIPE_ISOCHRONOUS, PIPE_BULK, PIPE_INTERRUPT\n\t};\n\tstruct usb_host_endpoint *ep;\n\tep = usb_pipe_endpoint(dev, pipe);\n\tif (usb_pipetype(pipe) != pipetypes[usb_endpoint_type(&ep->desc)])\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "static void get_socket_name( char* buf, int len )\n{\n    char* dpy = g_strdup(g_getenv(\"DISPLAY\"));\n    if(dpy && *dpy)\n    {\n        char* p = strchr(dpy, ':');\n        for(++p; *p && *p != '.' && *p != '\\n';)\n            ++p;\n         if(*p)\n             *p = '\\0';\n     }\n     g_snprintf( buf, len, \"%s/.menu-cached-%s-%s\", g_get_tmp_dir(),\n                 dpy ? dpy : \":0\", g_get_user_name() );\n     g_free(dpy);\n }", "target": 1}
{"code": "static void llc_cmsg_rcv(struct msghdr *msg, struct sk_buff *skb)\n{\n\tstruct llc_sock *llc = llc_sk(skb->sk);\n \tif (llc->cmsg_flags & LLC_CMSG_PKTINFO) {\n \t\tstruct llc_pktinfo info;\n \t\tinfo.lpi_ifindex = llc_sk(skb->sk)->dev->ifindex;\n \t\tllc_pdu_decode_dsap(skb, &info.lpi_sap);\n \t\tllc_pdu_decode_da(skb, info.lpi_mac);\n\t\tput_cmsg(msg, SOL_LLC, LLC_OPT_PKTINFO, sizeof(info), &info);\n\t}\n}", "target": 1}
{"code": "int socket_create(uint16_t port)\n{\n\tint sfd = -1;\n\tint yes = 1;\n#ifdef WIN32\n\tWSADATA wsa_data;\n\tif (!wsa_init) {\n\t\tif (WSAStartup(MAKEWORD(2,2), &wsa_data) != ERROR_SUCCESS) {\n\t\t\tfprintf(stderr, \"WSAStartup failed!\\n\");\n\t\t\tExitProcess(-1);\n\t\t}\n\t\twsa_init = 1;\n\t}\n#endif\n\tstruct sockaddr_in saddr;\n\tif (0 > (sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP))) {\n\t\tperror(\"socket()\");\n\t\treturn -1;\n\t}\n\tif (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) {\n\t\tperror(\"setsockopt()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n \tmemset((void *) &saddr, 0, sizeof(saddr));\n \tsaddr.sin_family = AF_INET;\n\tsaddr.sin_addr.s_addr = htonl(INADDR_ANY);\n \tsaddr.sin_port = htons(port);\n \tif (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {\n\t\tperror(\"bind()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\tif (listen(sfd, 1) == -1) {\n\t\tperror(\"listen()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\treturn sfd;\n}", "target": 1}
{"code": "int hidp_connection_add(struct hidp_connadd_req *req,\n\t\t\tstruct socket *ctrl_sock,\n\t\t\tstruct socket *intr_sock)\n{\n\tstruct hidp_session *session;\n\tstruct l2cap_conn *conn;\n\tstruct l2cap_chan *chan = l2cap_pi(ctrl_sock->sk)->chan;\n\tint ret;\n\tret = hidp_verify_sockets(ctrl_sock, intr_sock);\n\tif (ret)\n\t\treturn ret;\n\tconn = NULL;\n\tl2cap_chan_lock(chan);\n\tif (chan->conn)\n\t\tconn = l2cap_conn_get(chan->conn);\n\tl2cap_chan_unlock(chan);\n\tif (!conn)\n\t\treturn -EBADFD;\n\tret = hidp_session_new(&session, &chan->dst, ctrl_sock,\n\t\t\t       intr_sock, req, conn);\n\tif (ret)\n\t\tgoto out_conn;\n\tret = l2cap_register_user(conn, &session->user);\n\tif (ret)\n\t\tgoto out_session;\n\tret = 0;\nout_session:\n\thidp_session_put(session);\nout_conn:\n\tl2cap_conn_put(conn);\n\treturn ret;\n}", "target": 1}
{"code": "static int rm_read_multi(AVFormatContext *s, AVIOContext *pb,\n                         AVStream *st, char *mime)\n{\n    int number_of_streams = avio_rb16(pb);\n    int number_of_mdpr;\n    int i, ret;\n    unsigned size2;\n    for (i = 0; i<number_of_streams; i++)\n        avio_rb16(pb);\n    number_of_mdpr = avio_rb16(pb);\n    if (number_of_mdpr != 1) {\n        avpriv_request_sample(s, \"MLTI with multiple (%d) MDPR\", number_of_mdpr);\n    }\n    for (i = 0; i < number_of_mdpr; i++) {\n        AVStream *st2;\n        if (i > 0) {\n            st2 = avformat_new_stream(s, NULL);\n            if (!st2) {\n                ret = AVERROR(ENOMEM);\n                return ret;\n            }\n            st2->id = st->id + (i<<16);\n            st2->codecpar->bit_rate = st->codecpar->bit_rate;\n            st2->start_time = st->start_time;\n            st2->duration   = st->duration;\n            st2->codecpar->codec_type = AVMEDIA_TYPE_DATA;\n            st2->priv_data = ff_rm_alloc_rmstream();\n            if (!st2->priv_data)\n                return AVERROR(ENOMEM);\n        } else\n            st2 = st;\n         size2 = avio_rb32(pb);\n         ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,\n                                        size2, mime);\n         if (ret < 0)\n             return ret;\n     }\n    return 0;\n}", "target": 1}
{"code": "static void atusb_disconnect(struct usb_interface *interface)\n{\n\tstruct atusb *atusb = usb_get_intfdata(interface);\n\tdev_dbg(&atusb->usb_dev->dev, \"%s\\n\", __func__);\n\tatusb->shutdown = 1;\n\tcancel_delayed_work_sync(&atusb->work);\n\tusb_kill_anchored_urbs(&atusb->rx_urbs);\n\tatusb_free_urbs(atusb);\n\tusb_kill_urb(atusb->tx_urb);\n\tusb_free_urb(atusb->tx_urb);\n\tieee802154_unregister_hw(atusb->hw);\n\tieee802154_free_hw(atusb->hw);\n\tusb_set_intfdata(interface, NULL);\n\tusb_put_dev(atusb->usb_dev);\n\tpr_debug(\"%s done\\n\", __func__);\n}", "target": 1}
{"code": "file_check_mem(struct magic_set *ms, unsigned int level)\n{\n\tsize_t len;\n\tif (level >= ms->c.len) {\n\t\tlen = (ms->c.len += 20) * sizeof(*ms->c.li);\n\t\tms->c.li = CAST(struct level_info *, (ms->c.li == NULL) ?\n\t\t    emalloc(len) :\n\t\t    erealloc(ms->c.li, len));\n\t\tif (ms->c.li == NULL) {\n\t\t\tfile_oomem(ms, len);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tms->c.li[level].got_match = 0;\n#ifdef ENABLE_CONDITIONALS\n\tms->c.li[level].last_match = 0;\n\tms->c.li[level].last_cond = COND_NONE;\n#endif \n\treturn 0;\n}", "target": 1}
{"code": "void ip6_input(struct mbuf *m)\n{\n    struct ip6 *ip6;\n    Slirp *slirp = m->slirp;\n    if (!slirp->in6_enabled) {\n        goto bad;\n    }\n    DEBUG_CALL(\"ip6_input\");\n    DEBUG_ARG(\"m = %p\", m);\n    DEBUG_ARG(\"m_len = %d\", m->m_len);\n    if (m->m_len < sizeof(struct ip6)) {\n        goto bad;\n    }\n    ip6 = mtod(m, struct ip6 *);\n    if (ip6->ip_v != IP6VERSION) {\n        goto bad;\n    }\n    if (ntohs(ip6->ip_pl) > slirp->if_mtu) {\n        icmp6_send_error(m, ICMP6_TOOBIG, 0);\n        goto bad;\n    }\n    if (ip6->ip_hl == 0) {\n        icmp6_send_error(m, ICMP6_TIMXCEED, ICMP6_TIMXCEED_INTRANS);\n        goto bad;\n    }\n    switch (ip6->ip_nh) {\n    case IPPROTO_TCP:\n        NTOHS(ip6->ip_pl);\n        tcp_input(m, sizeof(struct ip6), (struct socket *)NULL, AF_INET6);\n        break;\n    case IPPROTO_UDP:\n        udp6_input(m);\n        break;\n    case IPPROTO_ICMPV6:\n        icmp6_input(m);\n        break;\n    default:\n        m_free(m);\n    }\n    return;\nbad:\n    m_free(m);\n}", "target": 1}
{"code": "krb5_ldap_get_password_policy_from_dn(krb5_context context, char *pol_name,\n                                      char *pol_dn, osa_policy_ent_t *policy)\n{\n    krb5_error_code             st=0, tempst=0;\n    LDAP                        *ld=NULL;\n    LDAPMessage                 *result=NULL,*ent=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n    krb5_clear_error_message(context);\n    if (pol_dn == NULL)\n        return EINVAL;\n    *policy = NULL;\n    SETUP_CONTEXT();\n    GET_HANDLE();\n    *(policy) = (osa_policy_ent_t) malloc(sizeof(osa_policy_ent_rec));\n    if (*policy == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n    memset(*policy, 0, sizeof(osa_policy_ent_rec));\n     LDAP_SEARCH(pol_dn, LDAP_SCOPE_BASE, \"(objectclass=krbPwdPolicy)\", password_policy_attributes);\n     ent=ldap_first_entry(ld, result);\n    if (ent != NULL) {\n        if ((st = populate_policy(context, ld, ent, pol_name, *policy)) != 0)\n            goto cleanup;\n     }\n cleanup:\n     ldap_msgfree(result);\n    if (st != 0) {\n        if (*policy != NULL) {\n            krb5_ldap_free_password_policy(context, *policy);\n            *policy = NULL;\n        }\n    }\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    return st;\n}", "target": 1}
{"code": "static int tsc210x_load(QEMUFile *f, void *opaque, int version_id)\n{\n    TSC210xState *s = (TSC210xState *) opaque;\n    int64_t now = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n    int i;\n    s->x = qemu_get_be16(f);\n    s->y = qemu_get_be16(f);\n    s->pressure = qemu_get_byte(f);\n    s->state = qemu_get_byte(f);\n    s->page = qemu_get_byte(f);\n    s->offset = qemu_get_byte(f);\n    s->command = qemu_get_byte(f);\n    s->irq = qemu_get_byte(f);\n    qemu_get_be16s(f, &s->dav);\n    timer_get(f, s->timer);\n    s->enabled = qemu_get_byte(f);\n    s->host_mode = qemu_get_byte(f);\n    s->function = qemu_get_byte(f);\n    s->nextfunction = qemu_get_byte(f);\n    s->precision = qemu_get_byte(f);\n    s->nextprecision = qemu_get_byte(f);\n    s->filter = qemu_get_byte(f);\n    s->pin_func = qemu_get_byte(f);\n    s->ref = qemu_get_byte(f);\n    s->timing = qemu_get_byte(f);\n    s->noise = qemu_get_be32(f);\n    qemu_get_be16s(f, &s->audio_ctrl1);\n    qemu_get_be16s(f, &s->audio_ctrl2);\n    qemu_get_be16s(f, &s->audio_ctrl3);\n    qemu_get_be16s(f, &s->pll[0]);\n    qemu_get_be16s(f, &s->pll[1]);\n    qemu_get_be16s(f, &s->volume);\n    s->volume_change = qemu_get_sbe64(f) + now;\n    s->powerdown = qemu_get_sbe64(f) + now;\n    s->softstep = qemu_get_byte(f);\n    qemu_get_be16s(f, &s->dac_power);\n    for (i = 0; i < 0x14; i ++)\n        qemu_get_be16s(f, &s->filter_data[i]);\n    s->busy = timer_pending(s->timer);\n    qemu_set_irq(s->pint, !s->irq);\n    qemu_set_irq(s->davint, !s->dav);\n    return 0;\n}", "target": 1}
{"code": "static void buffer_pipe_buf_get(struct pipe_inode_info *pipe,\n \t\t\t\tstruct pipe_buffer *buf)\n {\n \tstruct buffer_ref *ref = (struct buffer_ref *)buf->private;\n \tref->ref++;\n }", "target": 1}
{"code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n \t\tgoto out_free;\n \t}\n \tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf)\n \t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\n out_ok:\n \tret = res.acl_len;\n out_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}", "target": 1}
{"code": "static inline Status ParseAndCheckBoxSizes(const Tensor& boxes,\n                                           const Tensor& box_index,\n                                           int* num_boxes) {\n  if (boxes.NumElements() == 0 && box_index.NumElements() == 0) {\n    *num_boxes = 0;\n    return Status::OK();\n  }\n  if (boxes.dims() != 2) {\n    return errors::InvalidArgument(\"boxes must be 2-D\",\n                                   boxes.shape().DebugString());\n  }\n  *num_boxes = boxes.dim_size(0);\n  if (boxes.dim_size(1) != 4) {\n    return errors::InvalidArgument(\"boxes must have 4 columns\");\n  }\n  if (box_index.dims() != 1) {\n    return errors::InvalidArgument(\"box_index must be 1-D\",\n                                   box_index.shape().DebugString());\n  }\n  if (box_index.dim_size(0) != *num_boxes) {\n    return errors::InvalidArgument(\"box_index has incompatible shape\");\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "static void do_client_file_xfer(VirtioPort *vport,\n                                VDAgentMessage *message_header,\n                                uint8_t *data)\n{\n    uint32_t msg_type, id;\n    UdscsConnection *conn;\n    switch (message_header->type) {\n    case VD_AGENT_FILE_XFER_START: {\n        VDAgentFileXferStartMessage *s = (VDAgentFileXferStartMessage *)data;\n        if (!active_session_conn) {\n            send_file_xfer_status(vport,\n               \"Could not find an agent connection belonging to the \"\n               \"active session, cancelling client file-xfer request %u\",\n               s->id, VD_AGENT_FILE_XFER_STATUS_VDAGENT_NOT_CONNECTED, NULL, 0);\n            return;\n        } else if (session_info_session_is_locked(session_info)) {\n            syslog(LOG_DEBUG, \"Session is locked, skipping file-xfer-start\");\n            send_file_xfer_status(vport,\n               \"User's session is locked and cannot start file transfer. \"\n               \"Cancelling client file-xfer request %u\",\n               s->id, VD_AGENT_FILE_XFER_STATUS_SESSION_LOCKED, NULL, 0);\n            return;\n        }\n        msg_type = VDAGENTD_FILE_XFER_START;\n        id = s->id;\n        g_hash_table_insert(active_xfers, GUINT_TO_POINTER(id), active_session_conn);\n        break;\n    }\n    case VD_AGENT_FILE_XFER_STATUS: {\n        VDAgentFileXferStatusMessage *s = (VDAgentFileXferStatusMessage *)data;\n        msg_type = VDAGENTD_FILE_XFER_STATUS;\n        id = s->id;\n        break;\n    }\n    case VD_AGENT_FILE_XFER_DATA: {\n        VDAgentFileXferDataMessage *d = (VDAgentFileXferDataMessage *)data;\n        msg_type = VDAGENTD_FILE_XFER_DATA;\n        id = d->id;\n        break;\n    }\n    default:\n        g_return_if_reached(); \n    }\n    conn = g_hash_table_lookup(active_xfers, GUINT_TO_POINTER(id));\n    if (!conn) {\n        if (debug)\n            syslog(LOG_DEBUG, \"Could not find file-xfer %u (cancelled?)\", id);\n        return;\n    }\n    udscs_write(conn, msg_type, 0, 0, data, message_header->size);\n    if (message_header->type == VD_AGENT_FILE_XFER_STATUS) {\n        g_hash_table_remove(active_xfers, GUINT_TO_POINTER(id));\n    }\n}", "target": 1}
{"code": "static int snd_seq_ioctl_remove_events(struct snd_seq_client *client,\n\t\t\t\t       void __user *arg)\n{\n\tstruct snd_seq_remove_events info;\n\tif (copy_from_user(&info, arg, sizeof(info)))\n\t\treturn -EFAULT;\n\tif (info.remove_mode & SNDRV_SEQ_REMOVE_INPUT) {\n\t\tif (client->type == USER_CLIENT)\n \t\t\tsnd_seq_fifo_clear(client->data.user.fifo);\n \t}\n\tif (info.remove_mode & SNDRV_SEQ_REMOVE_OUTPUT)\n\t\tsnd_seq_queue_remove_cells(client->number, &info);\n\treturn 0;\n}", "target": 1}
{"code": "BOOL update_recv(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc = FALSE;\n\tUINT16 updateType;\n\trdpContext* context = update->context;\n\tif (Stream_GetRemainingLength(s) < 2)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 2\");\n\t\treturn FALSE;\n\t}\n\tStream_Read_UINT16(s, updateType); \n\tWLog_Print(update->log, WLOG_TRACE, \"%s Update Data PDU\", UPDATE_TYPE_STRINGS[updateType]);\n\tif (!update_begin_paint(update))\n\t\tgoto fail;\n\tswitch (updateType)\n\t{\n\t\tcase UPDATE_TYPE_ORDERS:\n\t\t\trc = update_recv_orders(update, s);\n\t\t\tbreak;\n\t\tcase UPDATE_TYPE_BITMAP:\n\t\t{\n\t\t\tBITMAP_UPDATE* bitmap_update = update_read_bitmap_update(update, s);\n\t\t\tif (!bitmap_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_BITMAP - update_read_bitmap_update() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\trc = IFCALLRESULT(FALSE, update->BitmapUpdate, context, bitmap_update);\n\t\t\tfree_bitmap_update(update->context, bitmap_update);\n\t\t}\n\t\tbreak;\n\t\tcase UPDATE_TYPE_PALETTE:\n\t\t{\n\t\t\tPALETTE_UPDATE* palette_update = update_read_palette(update, s);\n\t\t\tif (!palette_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_PALETTE - update_read_palette() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\trc = IFCALLRESULT(FALSE, update->Palette, context, palette_update);\n\t\t\tfree_palette_update(context, palette_update);\n\t\t}\n\t\tbreak;\n\t\tcase UPDATE_TYPE_SYNCHRONIZE:\n\t\t\tif (!update_read_synchronize(update, s))\n\t\t\t\tgoto fail;\n\t\t\trc = IFCALLRESULT(TRUE, update->Synchronize, context);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\nfail:\n\tif (!update_end_paint(update))\n\t\trc = FALSE;\n\tif (!rc)\n\t{\n\t\tWLog_ERR(TAG, \"UPDATE_TYPE %s [%\" PRIu16 \"] failed\", update_type_to_string(updateType),\n\t\t         updateType);\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "  FT_Stream_EnterFrame( FT_Stream  stream,\n                        FT_ULong   count )\n  {\n    FT_Error  error = FT_Err_Ok;\n    FT_ULong  read_bytes;\n    FT_ASSERT( stream && stream->cursor == 0 );\n    if ( stream->read )\n    {\n      FT_Memory  memory = stream->memory;\n      if ( count > stream->size )\n      {\n        FT_ERROR(( \"FT_Stream_EnterFrame:\"\n                   \" frame size (%lu) larger than stream size (%lu)\\n\",\n                   count, stream->size ));\n        error = FT_Err_Invalid_Stream_Operation;\n        goto Exit;\n      }\n#ifdef FT_DEBUG_MEMORY\n      stream->base = (unsigned char*)ft_mem_qalloc( memory, count, &error );\n      if ( error )\n        goto Exit;\n#else\n      if ( FT_QALLOC( stream->base, count ) )\n        goto Exit;\n#endif\n      read_bytes = stream->read( stream, stream->pos,\n                                 stream->base, count );\n      if ( read_bytes < count )\n      {\n        FT_ERROR(( \"FT_Stream_EnterFrame:\"\n                   \" invalid read; expected %lu bytes, got %lu\\n\",\n                   count, read_bytes ));\n        FT_FREE( stream->base );\n        error = FT_Err_Invalid_Stream_Operation;\n      }\n      stream->cursor = stream->base;\n      stream->limit  = stream->cursor + count;\n      stream->pos   += read_bytes;\n    }\n    else\n     {\n       if ( stream->pos >= stream->size        ||\n           stream->pos + count > stream->size )\n       {\n         FT_ERROR(( \"FT_Stream_EnterFrame:\"\n                    \" invalid i/o; pos = 0x%lx, count = %lu, size = 0x%lx\\n\",\n                   stream->pos, count, stream->size ));\n        error = FT_Err_Invalid_Stream_Operation;\n        goto Exit;\n      }\n      stream->cursor = stream->base + stream->pos;\n      stream->limit  = stream->cursor + count;\n      stream->pos   += count;\n    }\n  Exit:\n    return error;\n  }", "target": 1}
{"code": "void vmacache_flush_all(struct mm_struct *mm)\n{\n\tstruct task_struct *g, *p;\n\tcount_vm_vmacache_event(VMACACHE_FULL_FLUSHES);\n\tif (atomic_read(&mm->mm_users) == 1)\n\t\treturn;\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (mm == p->mm)\n\t\t\tvmacache_flush(p);\n\t}\n\trcu_read_unlock();\n}", "target": 1}
{"code": "setElementTypePrefix(XML_Parser parser, ELEMENT_TYPE *elementType)\n{\n  DTD * const dtd = parser->m_dtd;  \n  const XML_Char *name;\n  for (name = elementType->name; *name; name++) {\n    if (*name == XML_T(ASCII_COLON)) {\n      PREFIX *prefix;\n      const XML_Char *s;\n      for (s = elementType->name; s != name; s++) {\n        if (!poolAppendChar(&dtd->pool, *s))\n          return 0;\n      }\n      if (!poolAppendChar(&dtd->pool, XML_T('\\0')))\n        return 0;\n      prefix = (PREFIX *)lookup(parser, &dtd->prefixes, poolStart(&dtd->pool),\n                                sizeof(PREFIX));\n      if (!prefix)\n        return 0;\n      if (prefix->name == poolStart(&dtd->pool))\n        poolFinish(&dtd->pool);\n       else\n         poolDiscard(&dtd->pool);\n       elementType->prefix = prefix;\n     }\n   }\n   return 1;\n}", "target": 1}
{"code": "recv_and_process_client_pkt(void )\n{\n\tssize_t          size;\n\tlen_and_sockaddr *to;\n\tstruct sockaddr  *from;\n\tmsg_t            msg;\n\tuint8_t          query_status;\n\tl_fixedpt_t      query_xmttime;\n\tto = get_sock_lsa(G_listen_fd);\n\tfrom = xzalloc(to->len);\n\tsize = recv_from_to(G_listen_fd, &msg, sizeof(msg), MSG_DONTWAIT, from, &to->u.sa, to->len);\n\tif (size != NTP_MSGSIZE_NOAUTH && size != NTP_MSGSIZE) {\n\t\tchar *addr;\n\t\tif (size < 0) {\n\t\t\tif (errno == EAGAIN)\n\t\t\t\tgoto bail;\n\t\t\tbb_perror_msg_and_die(\"recv\");\n\t\t}\n\t\taddr = xmalloc_sockaddr2dotted_noport(from);\n\t\tbb_error_msg(\"malformed packet received from %s: size %u\", addr, (int)size);\n\t\tfree(addr);\n \t\tgoto bail;\n \t}\n \tquery_status = msg.m_status;\n \tquery_xmttime = msg.m_xmttime;\n\tmsg.m_ppoll = G.poll_exp;\n\tmsg.m_precision_exp = G_precision_exp;\n\tmsg.m_rectime = d_to_lfp(G.cur_time);\n\tmsg.m_xmttime = d_to_lfp(gettime1900d()); \n\tif (G.peer_cnt == 0) {\n\t\tG.reftime = G.cur_time;\n\t}\n\tmsg.m_reftime = d_to_lfp(G.reftime);\n\tmsg.m_orgtime = query_xmttime;\n\tmsg.m_rootdelay = d_to_sfp(G.rootdelay);\n\tmsg.m_rootdisp = d_to_sfp(G.rootdisp);\n\tmsg.m_refid = G.refid; \n\tdo_sendto(G_listen_fd,\n\t\t &to->u.sa,  from,  to->len,\n\t\t&msg, size);\n bail:\n\tfree(to);\n\tfree(from);\n}", "target": 1}
{"code": "struct sctp_chunk *sctp_assoc_lookup_asconf_ack(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\t__be32 serial)\n{\n\tstruct sctp_chunk *ack;\n \tlist_for_each_entry(ack, &asoc->asconf_ack_list, transmitted_list) {\n \t\tif (ack->subh.addip_hdr->serial == serial) {\n \t\t\tsctp_chunk_hold(ack);\n \t\t\treturn ack;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)\n{\n \tint r;\n \tstruct kvm_vcpu *vcpu, *v;\n \tvcpu = kvm_arch_vcpu_create(kvm, id);\n \tif (IS_ERR(vcpu))\n \t\treturn PTR_ERR(vcpu);\n\tpreempt_notifier_init(&vcpu->preempt_notifier, &kvm_preempt_ops);\n\tr = kvm_arch_vcpu_setup(vcpu);\n\tif (r)\n\t\tgoto vcpu_destroy;\n\tmutex_lock(&kvm->lock);\n\tif (!kvm_vcpu_compatible(vcpu)) {\n\t\tr = -EINVAL;\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\tif (atomic_read(&kvm->online_vcpus) == KVM_MAX_VCPUS) {\n\t\tr = -EINVAL;\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\tkvm_for_each_vcpu(r, v, kvm)\n\t\tif (v->vcpu_id == id) {\n\t\t\tr = -EEXIST;\n\t\t\tgoto unlock_vcpu_destroy;\n\t\t}\n\tBUG_ON(kvm->vcpus[atomic_read(&kvm->online_vcpus)]);\n\tkvm_get_kvm(kvm);\n\tr = create_vcpu_fd(vcpu);\n\tif (r < 0) {\n\t\tkvm_put_kvm(kvm);\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\tkvm->vcpus[atomic_read(&kvm->online_vcpus)] = vcpu;\n\tsmp_wmb();\n\tatomic_inc(&kvm->online_vcpus);\n\tmutex_unlock(&kvm->lock);\n\tkvm_arch_vcpu_postcreate(vcpu);\n\treturn r;\nunlock_vcpu_destroy:\n\tmutex_unlock(&kvm->lock);\nvcpu_destroy:\n\tkvm_arch_vcpu_destroy(vcpu);\n\treturn r;\n}", "target": 1}
{"code": "static void DetectRunCleanup(DetectEngineThreadCtx *det_ctx,\n        Packet *p, Flow * const pflow)\n{\n    PACKET_PROFILING_DETECT_START(p, PROF_DETECT_CLEANUP);\n    PacketPatternCleanup(det_ctx);\n     if (pflow != NULL) {\n        if (p->proto == IPPROTO_TCP && pflow->protoctx != NULL) {\n             StreamReassembleRawUpdateProgress(pflow->protoctx, p,\n                     det_ctx->raw_stream_progress);\n            DetectEngineCleanHCBDBuffers(det_ctx);\n        }\n    }\n    PACKET_PROFILING_DETECT_END(p, PROF_DETECT_CLEANUP);\n    SCReturn;\n}", "target": 1}
{"code": "xmlDocPtr soap_xmlParseMemory(const void *buf, size_t buf_size)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\tctxt = xmlCreateMemoryParserCtxt(buf, buf_size);\n\tif (ctxt) {\n\t\tzend_bool old;\n\t\tctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n\t\tctxt->sax->comment = soap_Comment;\n\t\tctxt->sax->warning = NULL;\n\t\tctxt->sax->error = NULL;\n#if LIBXML_VERSION >= 20703\n\t\tctxt->options |= XML_PARSE_HUGE;\n#endif\n\t\told = php_libxml_disable_entity_loader(1);\n\t\txmlParseDocument(ctxt);\n\t\tphp_libxml_disable_entity_loader(old);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "int LibarchivePlugin::extractionFlags() const\n{\n    int result = ARCHIVE_EXTRACT_TIME;\n    result |= ARCHIVE_EXTRACT_SECURE_NODOTDOT;\n    return result;\n}", "target": 1}
{"code": "int ssl3_get_new_session_ticket(SSL *s)\n{\n    int ok, al, ret = 0, ticklen;\n    long n;\n    const unsigned char *p;\n    unsigned char *d;\n    n = s->method->ssl_get_message(s,\n                                   SSL3_ST_CR_SESSION_TICKET_A,\n                                   SSL3_ST_CR_SESSION_TICKET_B,\n                                   SSL3_MT_NEWSESSION_TICKET, 16384, &ok);\n    if (!ok)\n        return ((int)n);\n    if (n < 6) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n     }\n     p = d = (unsigned char *)s->init_msg;\n     n2l(p, s->session->tlsext_tick_lifetime_hint);\n     n2s(p, ticklen);\n    if (ticklen + 6 != n) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n    OPENSSL_free(s->session->tlsext_tick);\n    s->session->tlsext_ticklen = 0;\n    s->session->tlsext_tick = OPENSSL_malloc(ticklen);\n    if (!s->session->tlsext_tick) {\n        SSLerr(SSL_F_SSL3_GET_NEW_SESSION_TICKET, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    memcpy(s->session->tlsext_tick, p, ticklen);\n    s->session->tlsext_ticklen = ticklen;\n    EVP_Digest(p, ticklen,\n               s->session->session_id, &s->session->session_id_length,\n               EVP_sha256(), NULL);\n    ret = 1;\n    return (ret);\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n err:\n    s->state = SSL_ST_ERR;\n    return (-1);\n}", "target": 1}
{"code": "static unsigned int tun_chr_poll(struct file *file, poll_table * wait)\n{\n\tstruct tun_file *tfile = file->private_data;\n\tstruct tun_struct *tun = __tun_get(tfile);\n\tstruct sock *sk = tun->sk;\n\tunsigned int mask = 0;\n\tif (!tun)\n\t\treturn POLLERR;\n\tDBG(KERN_INFO \"%s: tun_chr_poll\\n\", tun->dev->name);\n\tpoll_wait(file, &tun->socket.wait, wait);\n\tif (!skb_queue_empty(&tun->readq))\n\t\tmask |= POLLIN | POLLRDNORM;\n\tif (sock_writeable(sk) ||\n\t    (!test_and_set_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags) &&\n\t     sock_writeable(sk)))\n\t\tmask |= POLLOUT | POLLWRNORM;\n\tif (tun->dev->reg_state != NETREG_REGISTERED)\n\t\tmask = POLLERR;\n\ttun_put(tun);\n\treturn mask;\n}", "target": 1}
{"code": " void InputMethodBase::OnInputMethodChanged() const {\n   TextInputClient* client = GetTextInputClient();\n  if (client && client->GetTextInputType() != TEXT_INPUT_TYPE_NONE)\n     client->OnInputMethodChanged();\n }", "target": 1}
{"code": "static int rsi_send_beacon(struct rsi_common *common)\n{\n\tstruct sk_buff *skb = NULL;\n\tu8 dword_align_bytes = 0;\n\tskb = dev_alloc_skb(MAX_MGMT_PKT_SIZE);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tmemset(skb->data, 0, MAX_MGMT_PKT_SIZE);\n\tdword_align_bytes = ((unsigned long)skb->data & 0x3f);\n\tif (dword_align_bytes)\n\t\tskb_pull(skb, (64 - dword_align_bytes));\n\tif (rsi_prepare_beacon(common, skb)) {\n\t\trsi_dbg(ERR_ZONE, \"Failed to prepare beacon\\n\");\n\t\treturn -EINVAL;\n\t}\n\tskb_queue_tail(&common->tx_queue[MGMT_BEACON_Q], skb);\n\trsi_set_event(&common->tx_thread.event);\n\trsi_dbg(DATA_TX_ZONE, \"%s: Added to beacon queue\\n\", __func__);\n\treturn 0;\n}", "target": 1}
{"code": "static gint conv_sjistoeuc(gchar *outbuf, gint outlen, const gchar *inbuf)\n{\n\tconst guchar *in = inbuf;\n\tguchar *out = outbuf;\n\twhile (*in != '\\0') {\n\t\tif (IS_ASCII(*in)) {\n\t\t\t*out++ = *in++;\n\t\t} else if (issjiskanji1(*in)) {\n\t\t\tif (issjiskanji2(*(in + 1))) {\n\t\t\t\tguchar out1 = *in;\n\t\t\t\tguchar out2 = *(in + 1);\n\t\t\t\tguchar row;\n\t\t\t\trow = out1 < 0xa0 ? 0x70 : 0xb0;\n\t\t\t\tif (out2 < 0x9f) {\n\t\t\t\t\tout1 = (out1 - row) * 2 - 1;\n\t\t\t\t\tout2 -= out2 > 0x7f ? 0x20 : 0x1f;\n\t\t\t\t} else {\n\t\t\t\t\tout1 = (out1 - row) * 2;\n\t\t\t\t\tout2 -= 0x7e;\n\t\t\t\t}\n\t\t\t\t*out++ = out1 | 0x80;\n\t\t\t\t*out++ = out2 | 0x80;\n\t\t\t\tin += 2;\n\t\t\t} else {\n\t\t\t\t*out++ = SUBST_CHAR;\n\t\t\t\tin++;\n\t\t\t\tif (*in != '\\0' && !IS_ASCII(*in)) {\n\t\t\t\t\t*out++ = SUBST_CHAR;\n\t\t\t\t\tin++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (issjishwkana(*in)) {\n\t\t\t*out++ = 0x8e;\n\t\t\t*out++ = *in++;\n\t\t} else {\n\t\t\t*out++ = SUBST_CHAR;\n\t\t\tin++;\n\t\t}\n\t}\n\t*out = '\\0';\n\treturn 0;\n}", "target": 1}
{"code": "static void sungem_send_packet(SunGEMState *s, const uint8_t *buf,\n                               int size)\n{\n    NetClientState *nc = qemu_get_queue(s->nic);\n    if (s->macregs[MAC_XIFCFG >> 2] & MAC_XIFCFG_LBCK) {\n        nc->info->receive(nc, buf, size);\n    } else {\n        qemu_send_packet(nc, buf, size);\n    }\n}", "target": 1}
{"code": "bool SharedMemory::Create(const SharedMemoryCreateOptions& options) {\n  DCHECK_EQ(-1, mapped_file_);\n  if (options.size == 0) return false;\n  if (options.size > static_cast<size_t>(std::numeric_limits<int>::max()))\n    return false;\n  base::ThreadRestrictions::ScopedAllowIO allow_io;\n  FILE *fp;\n  bool fix_size = true;\n  FilePath path;\n  if (options.name == NULL || options.name->empty()) {\n    DCHECK(!options.open_existing);\n    fp = file_util::CreateAndOpenTemporaryShmemFile(&path, options.executable);\n    if (fp) {\n      if (unlink(path.value().c_str()))\n        PLOG(WARNING) << \"unlink\";\n    }\n  } else {\n     if (!FilePathForMemoryName(*options.name, &path))\n       return false;\n    fp = file_util::OpenFile(path, \"w+x\");\n    if (fp == NULL && options.open_existing) {\n      fp = file_util::OpenFile(path, \"a+\");\n       fix_size = false;\n     }\n   }\n   if (fp && fix_size) {\n    struct stat stat;\n    if (fstat(fileno(fp), &stat) != 0) {\n      file_util::CloseFile(fp);\n      return false;\n    }\n    const size_t current_size = stat.st_size;\n    if (current_size != options.size) {\n      if (HANDLE_EINTR(ftruncate(fileno(fp), options.size)) != 0) {\n        file_util::CloseFile(fp);\n        return false;\n      }\n    }\n    requested_size_ = options.size;\n  }\n  if (fp == NULL) {\n#if !defined(OS_MACOSX)\n    PLOG(ERROR) << \"Creating shared memory in \" << path.value() << \" failed\";\n    FilePath dir = path.DirName();\n    if (access(dir.value().c_str(), W_OK | X_OK) < 0) {\n      PLOG(ERROR) << \"Unable to access(W_OK|X_OK) \" << dir.value();\n      if (dir.value() == \"/dev/shm\") {\n        LOG(FATAL) << \"This is frequently caused by incorrect permissions on \"\n                   << \"/dev/shm.  Try 'sudo chmod 1777 /dev/shm' to fix.\";\n      }\n    }\n#else\n    PLOG(ERROR) << \"Creating shared memory in \" << path.value() << \" failed\";\n#endif\n    return false;\n  }\n  return PrepareMapFile(fp);\n}", "target": 1}
{"code": " static void queue_delete(struct snd_seq_queue *q)\n {\n \tsnd_seq_timer_stop(q->timer);\n \tsnd_seq_timer_close(q);\n \tsnd_use_lock_sync(&q->use_lock);\n\tsnd_seq_prioq_delete(&q->tickq);\n\tsnd_seq_prioq_delete(&q->timeq);\n\tsnd_seq_timer_delete(&q->timer);\n\tkfree(q);\n}", "target": 1}
{"code": "get_cdtext_generic (void *p_user_data)\n{\n  generic_img_private_t *p_env = p_user_data;\n  uint8_t *p_cdtext_data = NULL;\n  size_t  len;\n  if (!p_env) return NULL;\n  if (p_env->b_cdtext_error) return NULL;\n  if (NULL == p_env->cdtext) {\n    p_cdtext_data = read_cdtext_generic (p_env);\n    if (NULL != p_cdtext_data) {\n      len = CDIO_MMC_GET_LEN16(p_cdtext_data)-2;\n      p_env->cdtext = cdtext_init();\n      if(len <= 0 || 0 != cdtext_data_init (p_env->cdtext, &p_cdtext_data[4], len)) {\n        p_env->b_cdtext_error = true;\n        free(p_env->cdtext);\n        p_env->cdtext = NULL;\n      }\n      free(p_cdtext_data);\n    }\n  }\n  return p_env->cdtext;\n}", "target": 1}
{"code": "struct xt_table_info *xt_alloc_table_info(unsigned int size)\n{\n \tstruct xt_table_info *info = NULL;\n \tsize_t sz = sizeof(*info) + size;\n \tif ((SMP_ALIGN(size) >> PAGE_SHIFT) + 2 > totalram_pages)\n \t\treturn NULL;\n\tif (sz <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER))\n\t\tinfo = kmalloc(sz, GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (!info) {\n\t\tinfo = vmalloc(sz);\n\t\tif (!info)\n\t\t\treturn NULL;\n\t}\n\tmemset(info, 0, sizeof(*info));\n\tinfo->size = size;\n\treturn info;\n}", "target": 1}
{"code": "static INLINE BOOL ensure_capacity(const BYTE* start, const BYTE* end, size_t size, size_t base)\n{\n\tconst size_t available = (uintptr_t)end - (uintptr_t)start;\n\tconst BOOL rc = available >= size * base;\n\treturn rc;\n}", "target": 1}
{"code": " bool CSPSourceList::matches(const KURL& url, ContentSecurityPolicy::RedirectStatus redirectStatus) const\n {\n    if (m_allowStar)\n         return true;\n     KURL effectiveURL = m_policy->selfMatchesInnerURL() && SecurityOrigin::shouldUseInnerURL(url) ? SecurityOrigin::extractInnerURL(url) : url;\n     if (m_allowSelf && m_policy->urlMatchesSelf(effectiveURL))\n         return true;\n    for (size_t i = 0; i < m_list.size(); ++i) {\n        if (m_list[i].matches(effectiveURL, redirectStatus))\n            return true;\n    }\n    return false;\n }", "target": 1}
{"code": "static char ** split(const char *arg, const char *delim) {\n  char *copy = dupstr(arg);\n  char **result = NULL;\n  int i = 0;\n  for (char *cptr = strtok(copy, delim); cptr; cptr = strtok(NULL, delim)) {\n    char **tmp = realloc (result, sizeof *result * (i + 1));\n    if (!tmp && result) {\n      while (i > 0) {\n\tfree(result[--i]);\n      }\n      free(result);\n      free(copy);\n      return NULL;\n    }\n    result = tmp;\n    result[i++] = dupstr(cptr);\n  }\n  free(copy);\n  if (i) {\n    char **tmp = realloc(result, sizeof *result * (i + 1));\n    if (!tmp) {\n      while (i > 0) {\n\tfree(result[--i]);\n      }\n      free(result);\n      free(copy);\n      return NULL;\n    }\n    result = tmp;\n    result[i++] = NULL;\n  }\n  return result;\n}", "target": 1}
{"code": "disable_priv_mode ()\n{\n  int e;\n  if (setuid (current_user.uid) < 0)\n    {\n      e = errno;\n      sys_error (_(\"cannot set uid to %d: effective uid %d\"), current_user.uid, current_user.euid);\n#if defined (EXIT_ON_SETUID_FAILURE)\n      if (e == EAGAIN)\n\texit (e);\n#endif\n    }\n  if (setgid (current_user.gid) < 0)\n    sys_error (_(\"cannot set gid to %d: effective gid %d\"), current_user.gid, current_user.egid);\n  current_user.euid = current_user.uid;\n  current_user.egid = current_user.gid;\n}", "target": 1}
{"code": "  char * unescape(char * dest, const char * src)\n  {\n    while (*src) {\n      if (*src == '\\\\') {\n\t++src;\n\tswitch (*src) {\n\tcase 'n': *dest = '\\n'; break;\n\tcase 'r': *dest = '\\r'; break;\n\tcase 't': *dest = '\\t'; break;\n\tcase 'f': *dest = '\\f'; break;\n\tcase 'v': *dest = '\\v'; break;\n\tdefault: *dest = *src;\n\t}\n      } else {\n\t*dest = *src;\n      }\n      ++src;\n      ++dest;\n    }\n    *dest = '\\0';\n    return dest;\n  }", "target": 1}
{"code": "void ScanLineInputFile::initialize(const Header& header)\n{\n        _data->header = header;\n        _data->lineOrder = _data->header.lineOrder();\n        const Box2i &dataWindow = _data->header.dataWindow();\n        _data->minX = dataWindow.min.x;\n        _data->maxX = dataWindow.max.x;\n        _data->minY = dataWindow.min.y;\n        _data->maxY = dataWindow.max.y;\n        Compression comp = _data->header.compression();\n        _data->linesInBuffer =\n            numLinesInBuffer (comp);\n        int lineOffsetSize = (dataWindow.max.y - dataWindow.min.y +\n                              _data->linesInBuffer) / _data->linesInBuffer;\n        if (lineOffsetSize > gLargeChunkTableSize)\n        {\n            Int64 pos = _streamData->is->tellg();\n            _streamData->is->seekg(pos + (lineOffsetSize-1)*sizeof(Int64));\n            Int64 temp;\n            OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*_streamData->is, temp);\n            _streamData->is->seekg(pos);\n        }\n        size_t maxBytesPerLine = bytesPerLineTable (_data->header,\n                                                    _data->bytesPerLine);\n        if (maxBytesPerLine*numLinesInBuffer(comp) > INT_MAX)\n        {\n            throw IEX_NAMESPACE::InputExc(\"maximum bytes per scanline exceeds maximum permissible size\");\n        }\n        for (size_t i = 0; i < _data->lineBuffers.size(); i++)\n        {\n            _data->lineBuffers[i] = new LineBuffer (newCompressor(comp,\n                                                 maxBytesPerLine,\n                                                 _data->header));\n        }\n        _data->lineBufferSize = maxBytesPerLine * _data->linesInBuffer;\n        if (!_streamData->is->isMemoryMapped())\n        {\n            for (size_t i = 0; i < _data->lineBuffers.size(); i++)\n            {\n                _data->lineBuffers[i]->buffer = (char *) EXRAllocAligned(_data->lineBufferSize*sizeof(char),16);\n                if (!_data->lineBuffers[i]->buffer)\n                {\n                    throw IEX_NAMESPACE::LogicExc(\"Failed to allocate memory for scanline buffers\");\n                }\n            }\n        }\n        _data->nextLineBufferMinY = _data->minY - 1;\n        offsetInLineBufferTable (_data->bytesPerLine,\n                                 _data->linesInBuffer,\n                                 _data->offsetInLineBuffer);\n        _data->lineOffsets.resize (lineOffsetSize);\n}", "target": 1}
{"code": "static void ati_cursor_define(ATIVGAState *s)\n{\n    uint8_t data[1024];\n    uint8_t *src;\n    int i, j, idx = 0;\n    if ((s->regs.cur_offset & BIT(31)) || s->cursor_guest_mode) {\n        return; \n    }\n    src = s->vga.vram_ptr + s->regs.cur_offset -\n          (s->regs.cur_hv_offs >> 16) - (s->regs.cur_hv_offs & 0xffff) * 16;\n    for (i = 0; i < 64; i++) {\n        for (j = 0; j < 8; j++, idx++) {\n            data[idx] = src[i * 16 + j];\n            data[512 + idx] = src[i * 16 + j + 8];\n        }\n    }\n    if (!s->cursor) {\n        s->cursor = cursor_alloc(64, 64);\n    }\n    cursor_set_mono(s->cursor, s->regs.cur_color1, s->regs.cur_color0,\n                    &data[512], 1, &data[0]);\n    dpy_cursor_define(s->vga.con, s->cursor);\n}", "target": 1}
{"code": " ip_printts(netdissect_options *ndo,\n            register const u_char *cp, u_int length)\n {\n\tregister u_int ptr;\n\tregister u_int len;\n\tint hoplen;\n\tconst char *type;\n \tif (length < 4) {\n \t\tND_PRINT((ndo, \"[bad length %u]\", length));\n\t\treturn;\n \t}\n \tND_PRINT((ndo, \" TS{\"));\n \thoplen = ((cp[3]&0xF) != IPOPT_TS_TSONLY) ? 8 : 4;\n \tif ((length - 4) & (hoplen-1))\n \t\tND_PRINT((ndo, \"[bad length %u]\", length));\n \tptr = cp[2] - 1;\n \tlen = 0;\n \tif (ptr < 4 || ((ptr - 4) & (hoplen-1)) || ptr > length + 1)\n \t\tND_PRINT((ndo, \"[bad ptr %u]\", cp[2]));\n \tswitch (cp[3]&0xF) {\n \tcase IPOPT_TS_TSONLY:\n \t\tND_PRINT((ndo, \"TSONLY\"));\n\t\tbreak;\n\tcase IPOPT_TS_TSANDADDR:\n\t\tND_PRINT((ndo, \"TS+ADDR\"));\n\t\tbreak;\n\tcase 2:\n\t\tND_PRINT((ndo, \"PRESPEC2.0\"));\n\t\tbreak;\n\tcase 3:\t\t\t\n\t\tND_PRINT((ndo, \"PRESPEC\"));\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"[bad ts type %d]\", cp[3]&0xF));\n\t\tgoto done;\n\t}\n\ttype = \" \";\n \tfor (len = 4; len < length; len += hoplen) {\n \t\tif (ptr == len)\n \t\t\ttype = \" ^ \";\n \t\tND_PRINT((ndo, \"%s%d@%s\", type, EXTRACT_32BITS(&cp[len+hoplen-4]),\n \t\t       hoplen!=8 ? \"\" : ipaddr_string(ndo, &cp[len])));\n \t\ttype = \" \";\n\t}\ndone:\n\tND_PRINT((ndo, \"%s\", ptr == len ? \" ^ \" : \"\"));\n\tif (cp[3]>>4)\n \t\tND_PRINT((ndo, \" [%d hops not recorded]} \", cp[3]>>4));\n \telse\n \t\tND_PRINT((ndo, \"}\"));", "target": 1}
{"code": "pcx_write_rle(const byte * from, const byte * end, int step, gp_file * file)\n{\t\t\t\t\n#define MAX_RUN_COUNT 15\n    int max_run = step * MAX_RUN_COUNT;\n    while (from < end) {\n        byte data = *from;\n        from += step;\n        if (data != *from || from == end) {\n            if (data >= 0xc0)\n                gp_fputc(0xc1, file);\n        } else {\n            const byte *start = from;\n            while ((from < end) && (*from == data))\n                from += step;\n            while (from - start >= max_run) {\n                gp_fputc(0xc0 + MAX_RUN_COUNT, file);\n                gp_fputc(data, file);\n                start += max_run;\n            }\n            if (from > start || data >= 0xc0)\n                gp_fputc((from - start) / step + 0xc1, file);\n        }\n        gp_fputc(data, file);\n    }\n#undef MAX_RUN_COUNT\n}", "target": 1}
{"code": "   ExtensionBookmarksTest()\n      : client_(NULL), model_(NULL), node_(NULL), folder_(NULL) {}", "target": 1}
{"code": "static int MP4_ReadBox_String( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_string_t );\n    p_box->data.p_string->psz_text = malloc( p_box->i_size + 1 - 8 ); \n    if( p_box->data.p_string->psz_text == NULL )\n        MP4_READBOX_EXIT( 0 );\n    memcpy( p_box->data.p_string->psz_text, p_peek, p_box->i_size - 8 );\n    p_box->data.p_string->psz_text[p_box->i_size - 8] = '\\0';\n#ifdef MP4_VERBOSE\n        msg_Dbg( p_stream, \"read box: \\\"%4.4s\\\" text=`%s'\", (char *) & p_box->i_type,\n                 p_box->data.p_string->psz_text );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}", "target": 1}
{"code": "int agp_generic_insert_memory(struct agp_memory * mem, off_t pg_start, int type)\n{\n\tint num_entries;\n\tsize_t i;\n\toff_t j;\n\tvoid *temp;\n\tstruct agp_bridge_data *bridge;\n\tint mask_type;\n\tbridge = mem->bridge;\n\tif (!bridge)\n\t\treturn -EINVAL;\n\tif (mem->page_count == 0)\n\t\treturn 0;\n\ttemp = bridge->current_size;\n\tswitch (bridge->driver->size_type) {\n\tcase U8_APER_SIZE:\n\t\tnum_entries = A_SIZE_8(temp)->num_entries;\n\t\tbreak;\n\tcase U16_APER_SIZE:\n\t\tnum_entries = A_SIZE_16(temp)->num_entries;\n\t\tbreak;\n\tcase U32_APER_SIZE:\n\t\tnum_entries = A_SIZE_32(temp)->num_entries;\n\t\tbreak;\n\tcase FIXED_APER_SIZE:\n\t\tnum_entries = A_SIZE_FIX(temp)->num_entries;\n\t\tbreak;\n\tcase LVL2_APER_SIZE:\n\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tnum_entries = 0;\n\t\tbreak;\n\t}\n\tnum_entries -= agp_memory_reserved/PAGE_SIZE;\n\tif (num_entries < 0) num_entries = 0;\n\tif (type != mem->type)\n\t\treturn -EINVAL;\n\tmask_type = bridge->driver->agp_type_to_mask_type(bridge, type);\n\tif (mask_type != 0) {\n\t\treturn -EINVAL;\n\t}\n\tif ((pg_start + mem->page_count) > num_entries)\n\t\treturn -EINVAL;\n\tj = pg_start;\n\twhile (j < (pg_start + mem->page_count)) {\n\t\tif (!PGE_EMPTY(bridge, readl(bridge->gatt_table+j)))\n\t\t\treturn -EBUSY;\n\t\tj++;\n\t}\n\tif (!mem->is_flushed) {\n\t\tbridge->driver->cache_flush();\n\t\tmem->is_flushed = true;\n\t}\n\tfor (i = 0, j = pg_start; i < mem->page_count; i++, j++) {\n\t\twritel(bridge->driver->mask_memory(bridge,\n\t\t\t\t\t\t   page_to_phys(mem->pages[i]),\n\t\t\t\t\t\t   mask_type),\n\t\t       bridge->gatt_table+j);\n\t}\n\treadl(bridge->gatt_table+j-1);\t\n\tbridge->driver->tlb_flush(mem);\n\treturn 0;\n}", "target": 1}
{"code": "struct nft_flow_rule *nft_flow_rule_create(struct net *net,\n\t\t\t\t\t   const struct nft_rule *rule)\n{\n\tstruct nft_offload_ctx *ctx;\n\tstruct nft_flow_rule *flow;\n\tint num_actions = 0, err;\n\tstruct nft_expr *expr;\n\texpr = nft_expr_first(rule);\n\twhile (nft_expr_more(rule, expr)) {\n\t\tif (expr->ops->offload_flags & NFT_OFFLOAD_F_ACTION)\n\t\t\tnum_actions++;\n\t\texpr = nft_expr_next(expr);\n\t}\n\tif (num_actions == 0)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\tflow = nft_flow_rule_alloc(num_actions);\n\tif (!flow)\n\t\treturn ERR_PTR(-ENOMEM);\n\texpr = nft_expr_first(rule);\n\tctx = kzalloc(sizeof(struct nft_offload_ctx), GFP_KERNEL);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\tctx->net = net;\n\tctx->dep.type = NFT_OFFLOAD_DEP_UNSPEC;\n\twhile (nft_expr_more(rule, expr)) {\n\t\tif (!expr->ops->offload) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto err_out;\n\t\t}\n\t\terr = expr->ops->offload(ctx, flow, expr);\n\t\tif (err < 0)\n\t\t\tgoto err_out;\n\t\texpr = nft_expr_next(expr);\n\t}\n\tnft_flow_rule_transfer_vlan(ctx, flow);\n\tflow->proto = ctx->dep.l3num;\n\tkfree(ctx);\n\treturn flow;\nerr_out:\n\tkfree(ctx);\n\tnft_flow_rule_destroy(flow);\n\treturn ERR_PTR(err);\n}", "target": 1}
{"code": "gst_vorbis_tag_add_coverart (GstTagList * tags, const gchar * img_data_base64,\n    gint base64_len)\n{\n  GstBuffer *img;\n  guchar *img_data;\n  gsize img_len;\n  guint save = 0;\n  gint state = 0;\n  if (base64_len < 2)\n    goto not_enough_data;\n  img_data = g_try_malloc0 (base64_len * 3 / 4);\n  if (img_data == NULL)\n    goto alloc_failed;\n  img_len = g_base64_decode_step (img_data_base64, base64_len, img_data,\n      &state, &save);\n  if (img_len == 0)\n    goto decode_failed;\n  img = gst_tag_image_data_to_image_buffer (img_data, img_len,\n      GST_TAG_IMAGE_TYPE_NONE);\n  if (img == NULL)\n    goto convert_failed;\n  gst_tag_list_add (tags, GST_TAG_MERGE_APPEND,\n      GST_TAG_PREVIEW_IMAGE, img, NULL);\n  gst_buffer_unref (img);\n  g_free (img_data);\n  return;\nnot_enough_data:\n  {\n    GST_WARNING (\"COVERART tag with too little base64-encoded data\");\n    return;\n  }\nalloc_failed:\n  {\n    GST_WARNING (\"Couldn't allocate enough memory to decode COVERART tag\");\n    return;\n  }\ndecode_failed:\n  {\n    GST_WARNING (\"Couldn't decode bas64 image data from COVERART tag\");\n    g_free (img_data);\n    return;\n  }\nconvert_failed:\n  {\n    GST_WARNING (\"Couldn't extract image or image type from COVERART tag\");\n    g_free (img_data);\n    return;\n  }\n}", "target": 1}
{"code": "static void __dvb_frontend_free(struct dvb_frontend *fe)\n{\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\tif (fepriv)\n\t\tdvb_free_device(fepriv->dvbdev);\n\tdvb_frontend_invoke_release(fe, fe->ops.release);\n\tif (fepriv)\n\t\tkfree(fepriv);\n}", "target": 1}
{"code": "int32_t PPB_Flash_MessageLoop_Impl::InternalRun(\n    const RunFromHostProxyCallback& callback) {\n  if (state_->run_called()) {\n    if (!callback.is_null())\n      callback.Run(PP_ERROR_FAILED);\n    return PP_ERROR_FAILED;\n  }\n  state_->set_run_called();\n  state_->set_run_callback(callback);\n  scoped_refptr<State> state_protector(state_);\n   {\n     base::MessageLoop::ScopedNestableTaskAllower allow(\n         base::MessageLoop::current());\n     base::MessageLoop::current()->Run();\n   }\n  return state_protector->result();\n}", "target": 1}
{"code": "  void MakeDataset(OpKernelContext* ctx, DatasetBase** output) override {\n    const Tensor* indices;\n    OP_REQUIRES_OK(ctx, ctx->input(\"indices\", &indices));\n    const Tensor* values;\n    OP_REQUIRES_OK(ctx, ctx->input(\"values\", &values));\n    const Tensor* dense_shape;\n    OP_REQUIRES_OK(ctx, ctx->input(\"dense_shape\", &dense_shape));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(indices->shape()),\n                errors::InvalidArgument(\n                    \"Input indices should be a matrix but received shape \",\n                    indices->shape().DebugString()));\n    const auto num_indices = indices->NumElements();\n    const auto num_values = values->NumElements();\n    if (num_indices == 0 || num_values == 0) {\n      OP_REQUIRES(ctx, num_indices == num_values,\n                  errors::InvalidArgument(\n                      \"If indices or values are empty, the other one must also \"\n                      \"be. Got indices of shape \",\n                      indices->shape().DebugString(), \" and values of shape \",\n                      values->shape().DebugString()));\n    }\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(values->shape()),\n                errors::InvalidArgument(\n                    \"Input values should be a vector but received shape \",\n                    indices->shape().DebugString()));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(dense_shape->shape()),\n                errors::InvalidArgument(\n                    \"Input shape should be a vector but received shape \",\n                    dense_shape->shape().DebugString()));\n    int64_t previous_batch_index = -1;\n    for (int64_t i = 0; i < indices->dim_size(0); ++i) {\n      int64_t next_batch_index = indices->matrix<int64_t>()(i, 0);\n      OP_REQUIRES(\n          ctx, next_batch_index >= previous_batch_index,\n          errors::Unimplemented(\"The SparseTensor must be ordered in the batch \"\n                                \"dimension; handling arbitrarily ordered input \"\n                                \"is not currently supported.\"));\n      previous_batch_index = next_batch_index;\n    }\n    gtl::InlinedVector<int64_t, 8> std_order(dense_shape->NumElements(), 0);\n    sparse::SparseTensor tensor;\n    OP_REQUIRES_OK(\n        ctx, sparse::SparseTensor::Create(\n                 *indices, *values, TensorShape(dense_shape->vec<int64_t>()),\n                 std_order, &tensor));\n    *output = new Dataset<T>(ctx, std::move(tensor));\n  }", "target": 1}
{"code": "static void flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\tif (tsk != current)\n \t\treturn;\n \tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&(tsk->thread));\n\t}\n}", "target": 1}
{"code": "GF_Err dinf_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = gf_isom_box_array_read(s, bs, dinf_AddBox);\n\tif (e) {\n \t\treturn e;\n \t}\n \tif (!((GF_DataInformationBox *)s)->dref) {\n \t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing dref box in dinf\\n\"));\n\t\t((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);\n \t}\n \treturn GF_OK;\n }", "target": 1}
{"code": "static int i2c_ddc_rx(I2CSlave *i2c)\n{\n    I2CDDCState *s = I2CDDC(i2c);\n    int value;\n    value = s->edid_blob[s->reg];\n    s->reg++;\n    return value;\n}", "target": 1}
{"code": " void AppCacheGroup::RemoveCache(AppCache* cache) {\n   DCHECK(cache->associated_hosts().empty());\n   if (cache == newest_complete_cache_) {\n    CancelUpdate();\n     AppCache* tmp_cache = newest_complete_cache_;\n     newest_complete_cache_ = nullptr;\n     tmp_cache->set_owning_group(nullptr);  \n   } else {\n     scoped_refptr<AppCacheGroup> protect(this);\n    Caches::iterator it =\n        std::find(old_caches_.begin(), old_caches_.end(), cache);\n    if (it != old_caches_.end()) {\n      AppCache* tmp_cache = *it;\n      old_caches_.erase(it);\n      tmp_cache->set_owning_group(nullptr);  \n    }\n    if (!is_obsolete() && old_caches_.empty() &&\n        !newly_deletable_response_ids_.empty()) {\n      storage_->DeleteResponses(manifest_url_, newly_deletable_response_ids_);\n      newly_deletable_response_ids_.clear();\n    }\n  }\n}", "target": 1}
{"code": "seamless_process(STREAM s)\n {\n \tunsigned int pkglen;\n \tchar *buf;\n \tpkglen = s->end - s->p;\n\tbuf = xmalloc(pkglen + 1);\n\tSTRNCPY(buf, (char *) s->p, pkglen + 1);\n\tstr_handle_lines(buf, &seamless_rest, seamless_line_handler, NULL);\n\txfree(buf);\n}", "target": 1}
{"code": " next_line(struct archive_read *a,\n     const char **b, ssize_t *avail, ssize_t *ravail, ssize_t *nl)\n{\n\tssize_t len;\n\tint quit;\n\tquit = 0;\n\tif (*avail == 0) {\n\t\t*nl = 0;\n\t\tlen = 0;\n\t} else\n\t\tlen = get_line_size(*b, *avail, nl);\n\twhile (*nl == 0 && len == *avail && !quit) {\n\t\tssize_t diff = *ravail - *avail;\n\t\tsize_t nbytes_req = (*ravail+1023) & ~1023U;\n\t\tssize_t tested;\n\t\tif (nbytes_req < (size_t)*ravail + 160)\n\t\t\tnbytes_req <<= 1;\n\t\t*b = __archive_read_ahead(a, nbytes_req, avail);\n\t\tif (*b == NULL) {\n\t\t\tif (*ravail >= *avail)\n\t\t\t\treturn (0);\n\t\t\t*b = __archive_read_ahead(a, *avail, avail);\n\t\t\tquit = 1;\n\t\t}\n\t\t*ravail = *avail;\n \t\t*b += diff;\n \t\t*avail -= diff;\n \t\ttested = len;\n\t\tlen = get_line_size(*b, *avail, nl);\n \t\tif (len >= 0)\n \t\t\tlen += tested;\n \t}\n\treturn (len);\n}", "target": 1}
{"code": "hook_process_child (struct t_hook *hook_process)\n{\n    char *exec_args[4] = { \"sh\", \"-c\", NULL, NULL };\n    const char *ptr_url;\n    int rc;\n    close (STDIN_FILENO);\n    close (HOOK_PROCESS(hook_process, child_read[HOOK_PROCESS_STDOUT]));\n    close (HOOK_PROCESS(hook_process, child_read[HOOK_PROCESS_STDERR]));\n    if (dup2 (HOOK_PROCESS(hook_process, child_write[HOOK_PROCESS_STDOUT]),\n              STDOUT_FILENO) < 0)\n    {\n        _exit (EXIT_FAILURE);\n    }\n    if (dup2 (HOOK_PROCESS(hook_process, child_write[HOOK_PROCESS_STDERR]),\n              STDERR_FILENO) < 0)\n    {\n        _exit (EXIT_FAILURE);\n    }\n    rc = EXIT_SUCCESS;\n    if (strncmp (HOOK_PROCESS(hook_process, command), \"url:\", 4) == 0)\n    {\n        ptr_url = HOOK_PROCESS(hook_process, command) + 4;\n        while (ptr_url[0] == ' ')\n        {\n            ptr_url++;\n        }\n        rc = weeurl_download (ptr_url, HOOK_PROCESS(hook_process, options));\n        if (rc != 0)\n            fprintf (stderr, \"Error with URL '%s'\\n\", ptr_url);\n    }\n    else\n    {\n        exec_args[2] = HOOK_PROCESS(hook_process, command);\n        execvp (exec_args[0], exec_args);\n        fprintf (stderr, \"Error with command '%s'\\n\",\n                 HOOK_PROCESS(hook_process, command));\n        rc = EXIT_FAILURE;\n    }\n    fflush (stdout);\n    fflush (stderr);\n    _exit (rc);\n}", "target": 1}
{"code": " static int pagemap_open(struct inode *inode, struct file *file)\n {\n \tpr_warn_once(\"Bits 55-60 of /proc/PID/pagemap entries are about \"\n \t\t\t\"to stop being page-shift some time soon. See the \"\n \t\t\t\"linux/Documentation/vm/pagemap.txt for details.\\n\");\n\treturn 0;\n}", "target": 1}
{"code": " static bool r_bin_mdmp_init_directory(struct r_bin_mdmp_obj *obj) {\n \tint i;\n\tut8 *directory_base;\n\tstruct minidump_directory *entry;\n\tdirectory_base = obj->b->buf + obj->hdr->stream_directory_rva;\n \tsdb_num_set (obj->kv, \"mdmp_directory.offset\",\n \t\t\tobj->hdr->stream_directory_rva, 0);\n\tsdb_set (obj->kv, \"mdmp_directory.format\", \"[4]E? \"\n\t\t\t\"(mdmp_stream_type)StreamType \"\n \t\t\t\"(mdmp_location_descriptor)Location\", 0);\n \tfor (i = 0; i < (int)obj->hdr->number_of_streams; i++) {\n\t\tentry = (struct minidump_directory *)(directory_base + (i * sizeof (struct minidump_directory)));\n\t\tr_bin_mdmp_init_directory_entry (obj, entry);\n \t}\n \treturn true;\n}", "target": 1}
{"code": "return_enc_padata(krb5_context context, krb5_data *req_pkt,\n                  krb5_kdc_req *request, krb5_keyblock *reply_key,\n                  krb5_db_entry *server, krb5_enc_kdc_rep_part *reply_encpart,\n                  krb5_boolean is_referral)\n{\n    krb5_error_code code = 0;\n    assert(reply_encpart->enc_padata == NULL);\n    if (is_referral) {\n        code = return_referral_enc_padata(context, reply_encpart, server);\n        if (code)\n            return code;\n    }\n    code = kdc_handle_protected_negotiation(context, req_pkt, request, reply_key,\n                                            &reply_encpart->enc_padata);\n    if (code)\n        goto cleanup;\ncleanup:\n    return code;\n}", "target": 1}
{"code": "regional_alloc(struct regional *r, size_t size)\n{\n\tsize_t a = ALIGN_UP(size, ALIGNMENT);\n\tvoid *s;\n\tif(a > REGIONAL_LARGE_OBJECT_SIZE) {\n\t\ts = malloc(ALIGNMENT + size);\n\t\tif(!s) return NULL;\n\t\tr->total_large += ALIGNMENT+size;\n\t\t*(char**)s = r->large_list;\n\t\tr->large_list = (char*)s;\n\t\treturn (char*)s+ALIGNMENT;\n\t}\n\tif(a > r->available) {\n\t\ts = malloc(REGIONAL_CHUNK_SIZE);\n\t\tif(!s) return NULL;\n\t\t*(char**)s = r->next;\n\t\tr->next = (char*)s;\n\t\tr->data = (char*)s + ALIGNMENT;\n\t\tr->available = REGIONAL_CHUNK_SIZE - ALIGNMENT;\n\t}\n\tr->available -= a;\n\ts = r->data;\n\tr->data += a;\n\treturn s;\n}", "target": 1}
{"code": "static void BenchmarkOpenCLDevices(MagickCLEnv clEnv)\n{\n  MagickCLDevice\n    device;\n  MagickCLEnv\n    testEnv;\n  size_t\n    i,\n    j;\n  testEnv=AcquireMagickCLEnv();\n  testEnv->library=openCL_library;\n  testEnv->devices=(MagickCLDevice *) AcquireMagickMemory(\n    sizeof(MagickCLDevice));\n  testEnv->number_devices=1;\n  testEnv->benchmark_thread_id=GetMagickThreadId();\n  testEnv->initialized=MagickTrue;\n  for (i = 0; i < clEnv->number_devices; i++)\n    clEnv->devices[i]->score=MAGICKCORE_OPENCL_UNDEFINED_SCORE;\n  for (i = 0; i < clEnv->number_devices; i++)\n  {\n    device=clEnv->devices[i];\n    if (device->score == MAGICKCORE_OPENCL_UNDEFINED_SCORE)\n      RunDeviceBenckmark(clEnv,testEnv,device);\n    for (j = i+1; j < clEnv->number_devices; j++)\n    {\n      MagickCLDevice\n        other_device;\n      other_device=clEnv->devices[j];\n      if (IsSameOpenCLDevice(device,other_device))\n        other_device->score=device->score;\n    }\n  }\n  testEnv->enabled=MagickFalse;\n  default_CLEnv=testEnv;\n  clEnv->cpu_score=RunOpenCLBenchmark(MagickTrue);\n  default_CLEnv=clEnv;\n  testEnv=RelinquishMagickCLEnv(testEnv);\n  CacheOpenCLBenchmarks(clEnv);\n}", "target": 1}
{"code": "static int tcf_add_notify(struct tc_action *a, u32 pid, u32 seq, int event,\n                          u16 flags)\n{\n\tstruct tcamsg *t;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\tstruct rtattr *x;\n\tunsigned char *b;\n\tint err = 0;\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\tb = (unsigned char *)skb->tail;\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*t), flags);\n\tt = NLMSG_DATA(nlh);\n\tt->tca_family = AF_UNSPEC;\n\tx = (struct rtattr*) skb->tail;\n\tRTA_PUT(skb, TCA_ACT_TAB, 0, NULL);\n\tif (tcf_action_dump(skb, a, 0, 0) < 0)\n\t\tgoto rtattr_failure;\n\tx->rta_len = skb->tail - (u8*)x;\n\tnlh->nlmsg_len = skb->tail - b;\n\tNETLINK_CB(skb).dst_groups = RTMGRP_TC;\n\terr = rtnetlink_send(skb, pid, RTMGRP_TC, flags&NLM_F_ECHO);\n\tif (err > 0)\n\t\terr = 0;\n\treturn err;\nrtattr_failure:\nnlmsg_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1}
{"code": "  void Inspect::operator()(Complex_Selector_Ptr c)\n  {\n    Compound_Selector_Obj      head = c->head();\n    Complex_Selector_Obj            tail = c->tail();\n    Complex_Selector::Combinator comb = c->combinator();\n    if (comb == Complex_Selector::ANCESTOR_OF && (!head || head->empty())) {\n      if (tail) tail->perform(this);\n      return;\n    }\n    if (c->has_line_feed()) {\n      if (!(c->has_parent_ref())) {\n        append_optional_linefeed();\n        append_indentation();\n      }\n    }\n    if (head && head->length() != 0) head->perform(this);\n    bool is_empty = !head || head->length() == 0 || head->is_empty_reference();\n    bool is_tail = head && !head->is_empty_reference() && tail;\n    if (output_style() == COMPRESSED && comb != Complex_Selector::ANCESTOR_OF) scheduled_space = 0;\n    switch (comb) {\n      case Complex_Selector::ANCESTOR_OF:\n        if (is_tail) append_mandatory_space();\n      break;\n      case Complex_Selector::PARENT_OF:\n        append_optional_space();\n        append_string(\">\");\n        append_optional_space();\n      break;\n      case Complex_Selector::ADJACENT_TO:\n        append_optional_space();\n        append_string(\"+\");\n        append_optional_space();\n      break;\n      case Complex_Selector::REFERENCE:\n        append_mandatory_space();\n        append_string(\"/\");\n        c->reference()->perform(this);\n        append_string(\"/\");\n        append_mandatory_space();\n      break;\n      case Complex_Selector::PRECEDES:\n        if (is_empty) append_optional_space();\n        else append_mandatory_space();\n        append_string(\"~\");\n        if (tail) append_mandatory_space();\n        else append_optional_space();\n      break;\n      default: break;\n    }\n    if (tail && comb != Complex_Selector::ANCESTOR_OF) {\n      if (c->has_line_break()) append_optional_linefeed();\n    }\n    if (tail) tail->perform(this);\n    if (!tail && c->has_line_break()) {\n      if (output_style() == COMPACT) {\n        append_mandatory_space();\n      }\n    }\n  }", "target": 1}
{"code": "resolve_iffeature(struct lys_iffeature *expr)\n{\n    int index_e = 0, index_f = 0;\n    if (expr->expr) {\n        return resolve_iffeature_recursive(expr, &index_e, &index_f);\n    }\n    return 0;\n}", "target": 1}
{"code": "static int msg_parse_fetch (IMAP_HEADER *h, char *s)\n{\n  char tmp[SHORT_STRING];\n  char *ptmp;\n  if (!s)\n    return -1;\n  while (*s)\n  {\n    SKIPWS (s);\n    if (ascii_strncasecmp (\"FLAGS\", s, 5) == 0)\n    {\n      if ((s = msg_parse_flags (h, s)) == NULL)\n        return -1;\n    }\n    else if (ascii_strncasecmp (\"UID\", s, 3) == 0)\n    {\n      s += 3;\n      SKIPWS (s);\n      if (mutt_atoui (s, &h->data->uid) < 0)\n        return -1;\n      s = imap_next_word (s);\n    }\n    else if (ascii_strncasecmp (\"INTERNALDATE\", s, 12) == 0)\n    {\n      s += 12;\n      SKIPWS (s);\n      if (*s != '\\\"')\n      {\n        dprint (1, (debugfile, \"msg_parse_fetch(): bogus INTERNALDATE entry: %s\\n\", s));\n        return -1;\n      }\n      s++;\n      ptmp = tmp;\n      while (*s && *s != '\\\"')\n        *ptmp++ = *s++;\n      if (*s != '\\\"')\n        return -1;\n      s++; \n      *ptmp = 0;\n      h->received = imap_parse_date (tmp);\n    }\n    else if (ascii_strncasecmp (\"RFC822.SIZE\", s, 11) == 0)\n    {\n      s += 11;\n      SKIPWS (s);\n      ptmp = tmp;\n      while (isdigit ((unsigned char) *s))\n        *ptmp++ = *s++;\n      *ptmp = 0;\n      if (mutt_atol (tmp, &h->content_length) < 0)\n        return -1;\n    }\n    else if (!ascii_strncasecmp (\"BODY\", s, 4) ||\n      !ascii_strncasecmp (\"RFC822.HEADER\", s, 13))\n    {\n      return -2;\n    }\n    else if (*s == ')')\n      s++; \n    else if (*s)\n    {\n      imap_error (\"msg_parse_fetch\", s);\n      return -1;\n    }\n  }\n  return 0;\n}", "target": 1}
{"code": "SYSCALL_DEFINE6(move_pages, pid_t, pid, unsigned long, nr_pages,\n\t\tconst void __user * __user *, pages,\n \t\tconst int __user *, nodes,\n \t\tint __user *, status, int, flags)\n {\n\tconst struct cred *cred = current_cred(), *tcred;\n \tstruct task_struct *task;\n \tstruct mm_struct *mm;\n \tint err;\n\tnodemask_t task_nodes;\n\tif (flags & ~(MPOL_MF_MOVE|MPOL_MF_MOVE_ALL))\n\t\treturn -EINVAL;\n\tif ((flags & MPOL_MF_MOVE_ALL) && !capable(CAP_SYS_NICE))\n\t\treturn -EPERM;\n\trcu_read_lock();\n\ttask = pid ? find_task_by_vpid(pid) : current;\n\tif (!task) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\tget_task_struct(task);\n\ttcred = __task_cred(task);\n\tif (!uid_eq(cred->euid, tcred->suid) && !uid_eq(cred->euid, tcred->uid) &&\n\t    !uid_eq(cred->uid,  tcred->suid) && !uid_eq(cred->uid,  tcred->uid) &&\n\t    !capable(CAP_SYS_NICE)) {\n \t\trcu_read_unlock();\n \t\terr = -EPERM;\n \t\tgoto out;\n\t}\n\trcu_read_unlock();\n \terr = security_task_movememory(task);\n \tif (err)\n\t\tgoto out;\n\ttask_nodes = cpuset_mems_allowed(task);\n\tmm = get_task_mm(task);\n\tput_task_struct(task);\n\tif (!mm)\n\t\treturn -EINVAL;\n\tif (nodes)\n\t\terr = do_pages_move(mm, task_nodes, nr_pages, pages,\n\t\t\t\t    nodes, status, flags);\n\telse\n\t\terr = do_pages_stat(mm, nr_pages, pages, status);\n\tmmput(mm);\n\treturn err;\nout:\n\tput_task_struct(task);\n\treturn err;\n}", "target": 1}
{"code": "hb_ot_layout_build_glyph_classes (hb_face_t      *face,\n\t\t\t\t  uint16_t        num_total_glyphs,\n\t\t\t\t  hb_codepoint_t *glyphs,\n\t\t\t\t  unsigned char  *klasses,\n\t\t\t\t  uint16_t        count)\n{\n  if (HB_OBJECT_IS_INERT (face))\n    return;\n  hb_ot_layout_t *layout = &face->ot_layout;\n  if (HB_UNLIKELY (!count || !glyphs || !klasses))\n    return;\n  if (layout->new_gdef.len == 0) {\n    layout->new_gdef.klasses = (unsigned char *) calloc (num_total_glyphs, sizeof (unsigned char));\n    layout->new_gdef.len = count;\n  }\n  for (unsigned int i = 0; i < count; i++)\n    _hb_ot_layout_set_glyph_class (face, glyphs[i], (hb_ot_layout_glyph_class_t) klasses[i]);\n}", "target": 1}
{"code": "do_bid_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap __attribute__((__unused__)), uint32_t namesz, uint32_t descsz,\n     size_t noff, size_t doff, int *flags)\n {\n \tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"GNU\") == 0 &&\n\t    type == NT_GNU_BUILD_ID && (descsz == 16 || descsz == 20)) {\n \t\tuint8_t desc[20];\n \t\tuint32_t i;\n \t\t*flags |= FLAGS_DID_BUILD_ID;\n\t\tif (file_printf(ms, \", BuildID[%s]=\", descsz == 16 ? \"md5/uuid\" :\n\t\t    \"sha1\") == -1)\n \t\t\treturn 1;\n \t\t(void)memcpy(desc, &nbuf[doff], descsz);\n \t\tfor (i = 0; i < descsz; i++)\n\t\t    if (file_printf(ms, \"%02x\", desc[i]) == -1)\n\t\t\treturn 1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "INST_HANDLER (sbrx) {\t\n \tint b = buf[0] & 0x7;\n \tint r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x01) << 4);\n\tRAnalOp next_op;\n\tavr_op_analyze (anal,\n\t\t\t&next_op,\n\t\t\top->addr + op->size, buf + op->size, len - op->size,\n\t\t\tcpu);\n\tr_strbuf_fini (&next_op.esil);\n\top->jump = op->addr + next_op.size + 2;\n\top->cycles = 1;\t\n\tESIL_A (\"%d,1,<<,r%d,&,\", b, r);\t\t\t\n\tESIL_A ((buf[1] & 0xe) == 0xc\n\t\t\t? \"!,\"\t\t\n\t\t\t: \"!,!,\");\t\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t\n}", "target": 1}
{"code": "header_cache_t *imap_hcache_open(struct ImapData *idata, const char *path)\n{\n  struct ImapMbox mx;\n  struct Url url;\n  char cachepath[PATH_MAX];\n  char mbox[PATH_MAX];\n  if (path)\n    imap_cachepath(idata, path, mbox, sizeof(mbox));\n  else\n  {\n    if (!idata->ctx || imap_parse_path(idata->ctx->path, &mx) < 0)\n      return NULL;\n    imap_cachepath(idata, mx.mbox, mbox, sizeof(mbox));\n    FREE(&mx.mbox);\n  }\n  mutt_account_tourl(&idata->conn->account, &url);\n  url.path = mbox;\n  url_tostring(&url, cachepath, sizeof(cachepath), U_PATH);\n  return mutt_hcache_open(HeaderCache, cachepath, imap_hcache_namer);\n}", "target": 1}
{"code": "archive_wstring_append_from_mbs(struct archive_wstring *dest,\n    const char *p, size_t len)\n{\n\tsize_t r;\n\tint ret_val = 0;\n\tsize_t wcs_length = len;\n\tsize_t mbs_length = len;\n\tconst char *mbs = p;\n\twchar_t *wcs;\n#if HAVE_MBRTOWC\n\tmbstate_t shift_state;\n\tmemset(&shift_state, 0, sizeof(shift_state));\n#endif\n\tif (NULL == archive_wstring_ensure(dest, dest->length + wcs_length + 1))\n\t\treturn (-1);\n\twcs = dest->s + dest->length;\n\twhile (*mbs && mbs_length > 0) {\n\t\tif (wcs_length == 0) {\n\t\t\tdest->length = wcs - dest->s;\n\t\t\tdest->s[dest->length] = L'\\0';\n\t\t\twcs_length = mbs_length;\n\t\t\tif (NULL == archive_wstring_ensure(dest,\n\t\t\t    dest->length + wcs_length + 1))\n\t\t\t\treturn (-1);\n\t\t\twcs = dest->s + dest->length;\n\t\t}\n#if HAVE_MBRTOWC\n\t\tr = mbrtowc(wcs, mbs, wcs_length, &shift_state);\n#else\n\t\tr = mbtowc(wcs, mbs, wcs_length);\n#endif\n\t\tif (r == (size_t)-1 || r == (size_t)-2) {\n\t\t\tret_val = -1;\n\t\t\tif (errno == EILSEQ) {\n\t\t\t\t++mbs;\n\t\t\t\t--mbs_length;\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t\tif (r == 0 || r > mbs_length)\n\t\t\tbreak;\n\t\twcs++;\n\t\twcs_length--;\n\t\tmbs += r;\n\t\tmbs_length -= r;\n\t}\n\tdest->length = wcs - dest->s;\n\tdest->s[dest->length] = L'\\0';\n\treturn (ret_val);\n}", "target": 1}
{"code": "int hfsplus_find_cat(struct super_block *sb, u32 cnid,\n\t\t     struct hfs_find_data *fd)\n{\n\thfsplus_cat_entry tmp;\n\tint err;\n\tu16 type;\n\thfsplus_cat_build_key(sb, fd->search_key, cnid, NULL);\n\terr = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));\n\tif (err)\n\t\treturn err;\n\ttype = be16_to_cpu(tmp.type);\n\tif (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {\n\t\tprintk(KERN_ERR \"hfs: found bad thread record in catalog\\n\");\n\t\treturn -EIO;\n\t}\n\thfsplus_cat_build_key_uni(fd->search_key, be32_to_cpu(tmp.thread.parentID),\n\t\t\t\t &tmp.thread.nodeName);\n\treturn hfs_brec_find(fd);\n}", "target": 1}
{"code": "_XcursorThemeInherits (const char *full)\n{\n    char    line[8192];\n    char    *result = NULL;\n    FILE    *f;\n    if (!full)\n        return NULL;\n    f = fopen (full, \"r\");\n    if (f)\n    {\n\twhile (fgets (line, sizeof (line), f))\n\t{\n\t    if (!strncmp (line, \"Inherits\", 8))\n\t    {\n\t\tchar    *l = line + 8;\n\t\tchar    *r;\n\t\twhile (*l == ' ') l++;\n \t\tif (*l != '=') continue;\n \t\tl++;\n \t\twhile (*l == ' ') l++;\n\t\tresult = malloc (strlen (l));\n \t\tif (result)\n \t\t{\n \t\t    r = result;\n\t\t    while (*l)\n\t\t    {\n\t\t\twhile (XcursorSep(*l) || XcursorWhite (*l)) l++;\n\t\t\tif (!*l)\n\t\t\t    break;\n\t\t\tif (r != result)\n\t\t\t    *r++ = ':';\n\t\t\twhile (*l && !XcursorWhite(*l) &&\n\t\t\t       !XcursorSep(*l))\n\t\t\t    *r++ = *l++;\n\t\t    }\n\t\t    *r++ = '\\0';\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n\tfclose (f);\n    }\n    return result;\n}", "target": 1}
{"code": "void ChromeContentRendererClient::RenderThreadStarted() {\n  chrome_observer_.reset(new ChromeRenderProcessObserver());\n  extension_dispatcher_.reset(new ExtensionDispatcher());\n  histogram_snapshots_.reset(new RendererHistogramSnapshots());\n  net_predictor_.reset(new RendererNetPredictor());\n  spellcheck_.reset(new SpellCheck());\n  visited_link_slave_.reset(new VisitedLinkSlave());\n  phishing_classifier_.reset(safe_browsing::PhishingClassifierFilter::Create());\n  RenderThread* thread = RenderThread::current();\n  thread->AddFilter(new DevToolsAgentFilter());\n  thread->AddObserver(chrome_observer_.get());\n  thread->AddObserver(extension_dispatcher_.get());\n  thread->AddObserver(histogram_snapshots_.get());\n  thread->AddObserver(phishing_classifier_.get());\n  thread->AddObserver(spellcheck_.get());\n  thread->AddObserver(visited_link_slave_.get());\n  thread->RegisterExtension(extensions_v8::ExternalExtension::Get());\n  thread->RegisterExtension(extensions_v8::LoadTimesExtension::Get());\n  thread->RegisterExtension(extensions_v8::SearchBoxExtension::Get());\n  v8::Extension* search_extension = extensions_v8::SearchExtension::Get();\n  if (search_extension)\n    thread->RegisterExtension(search_extension);\n  if (CommandLine::ForCurrentProcess()->HasSwitch(\n          switches::kDomAutomationController)) {\n    thread->RegisterExtension(DomAutomationV8Extension::Get());\n  }\n  if (CommandLine::ForCurrentProcess()->HasSwitch(\n           switches::kEnableIPCFuzzing)) {\n     thread->channel()->set_outgoing_message_filter(LoadExternalIPCFuzzer());\n   }\n   WebString chrome_ui_scheme(ASCIIToUTF16(chrome::kChromeUIScheme));\n   WebSecurityPolicy::registerURLSchemeAsDisplayIsolated(chrome_ui_scheme);\n   WebString extension_scheme(ASCIIToUTF16(chrome::kExtensionScheme));\n   WebSecurityPolicy::registerURLSchemeAsSecure(extension_scheme);\n}", "target": 1}
{"code": "struct net *get_net_ns_by_id(struct net *net, int id)\n{\n\tstruct net *peer;\n\tif (id < 0)\n\t\treturn NULL;\n\trcu_read_lock();\n \tspin_lock_bh(&net->nsid_lock);\n \tpeer = idr_find(&net->netns_ids, id);\n \tif (peer)\n\t\tget_net(peer);\n \tspin_unlock_bh(&net->nsid_lock);\n \trcu_read_unlock();\n\treturn peer;\n}", "target": 1}
{"code": "static inline int init_new_context(struct task_struct *tsk,\n\t\t\t\t   struct mm_struct *mm)\n{\n\t#ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS\n\tif (cpu_feature_enabled(X86_FEATURE_OSPKE)) {\n\t\tmm->context.pkey_allocation_map = 0x1;\n\t\tmm->context.execute_only_pkey = -1;\n\t}\n\t#endif\n\tinit_new_context_ldt(tsk, mm);\n\treturn 0;\n}", "target": 1}
{"code": "int rds_rdma_extra_size(struct rds_rdma_args *args)\n{\n\tstruct rds_iovec vec;\n\tstruct rds_iovec __user *local_vec;\n\tint tot_pages = 0;\n\tunsigned int nr_pages;\n\tunsigned int i;\n \tlocal_vec = (struct rds_iovec __user *)(unsigned long) args->local_vec_addr;\n \tfor (i = 0; i < args->nr_local; i++) {\n \t\tif (copy_from_user(&vec, &local_vec[i],\n\t\t\t\t   sizeof(struct rds_iovec)))\n\t\t\treturn -EFAULT;\n\t\tnr_pages = rds_pages_in_vec(&vec);\n\t\tif (nr_pages == 0)\n\t\t\treturn -EINVAL;\n\t\ttot_pages += nr_pages;\n\t\tif (tot_pages < 0)\n\t\t\treturn -EINVAL;\n\t}\n\treturn tot_pages * sizeof(struct scatterlist);\n}", "target": 1}
{"code": "static int pptp_bind(struct socket *sock, struct sockaddr *uservaddr,\n\tint sockaddr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_pppox *sp = (struct sockaddr_pppox *) uservaddr;\n\tstruct pppox_sock *po = pppox_sk(sk);\n \tstruct pptp_opt *opt = &po->proto.pptp;\n \tint error = 0;\n \tlock_sock(sk);\n \topt->src_addr = sp->sa_addr.pptp;\n\tif (add_chan(po))\n\t\terror = -EBUSY;\n\trelease_sock(sk);\n\treturn error;\n}", "target": 1}
{"code": "static int huft_build(const unsigned *b, const unsigned n,\n\t\t\tconst unsigned s, const unsigned short *d,\n\t\t\tconst unsigned char *e, huft_t **t, unsigned *m)\n{\n\tunsigned a;             \n\tunsigned c[BMAX + 1];   \n\tunsigned eob_len;       \n\tunsigned f;             \n\tint g;                  \n\tint htl;                \n \tunsigned i;             \n \tunsigned j;             \n \tint k;                  \n\tunsigned *p;            \n \thuft_t *q;              \n \thuft_t r;               \n \thuft_t *u[BMAX];        \n \tunsigned v[N_MAX];      \n \tint ws[BMAX + 1];       \n \tint w;                  \n \tunsigned x[BMAX + 1];   \n\tint y;                  \n\tunsigned z;             \n\teob_len = n > 256 ? b[256] : BMAX;\n\t*t = NULL;\n \tmemset(c, 0, sizeof(c));\n\tp = (unsigned *) b; \n \ti = n;\n \tdo {\n \t\tc[*p]++; \n\t} while (--i);\n\tif (c[0] == n) {  \n\t\t*m = 0;\n\t\treturn 2;\n\t}\n\tfor (j = 1; (j <= BMAX) && (c[j] == 0); j++)\n\t\tcontinue;\n\tk = j; \n\tfor (i = BMAX; (c[i] == 0) && i; i--)\n\t\tcontinue;\n\tg = i; \n\t*m = (*m < j) ? j : ((*m > i) ? i : *m);\n\tfor (y = 1 << j; j < i; j++, y <<= 1) {\n\t\ty -= c[j];\n\t\tif (y < 0)\n\t\t\treturn 2; \n\t}\n\ty -= c[i];\n\tif (y < 0)\n\t\treturn 2;\n\tc[i] += y;\n\tx[1] = j = 0;\n\tp = c + 1;\n\txp = x + 2;\n\twhile (--i) { \n\t\tj += *p++;\n\t\t*xp++ = j;\n\t}\n \t}", "target": 1}
{"code": "nfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct nfs4_acl *acl)\n{\n\t__be32 error;\n\tint host_error;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tstruct posix_acl *pacl = NULL, *dpacl = NULL;\n\tunsigned int flags = 0;\n\terror = fh_verify(rqstp, fhp, 0, NFSD_MAY_SATTR);\n\tif (error)\n\t\treturn error;\n \tdentry = fhp->fh_dentry;\n \tinode = d_inode(dentry);\n\tif (!inode->i_op->set_acl || !IS_POSIXACL(inode))\n\t\treturn nfserr_attrnotsupp;\n \tif (S_ISDIR(inode->i_mode))\n \t\tflags = NFS4_ACL_DIR;\n\thost_error = nfs4_acl_nfsv4_to_posix(acl, &pacl, &dpacl, flags);\n\tif (host_error == -EINVAL)\n\t\treturn nfserr_attrnotsupp;\n \tif (host_error < 0)\n \t\tgoto out_nfserr;\n\thost_error = inode->i_op->set_acl(inode, pacl, ACL_TYPE_ACCESS);\n \tif (host_error < 0)\n\t\tgoto out_release;\n \tif (S_ISDIR(inode->i_mode)) {\n\t\thost_error = inode->i_op->set_acl(inode, dpacl,\n\t\t\t\t\t\t  ACL_TYPE_DEFAULT);\n \t}\nout_release:\n \tposix_acl_release(pacl);\n \tposix_acl_release(dpacl);\n out_nfserr:\n\tif (host_error == -EOPNOTSUPP)\n\t\treturn nfserr_attrnotsupp;\n\telse\n\t\treturn nfserrno(host_error);\n}", "target": 1}
{"code": "bool SharedMemory::Create(const SharedMemoryCreateOptions& options) {\n  DCHECK(!options.executable);\n  DCHECK(!mapped_file_);\n  if (options.size == 0)\n    return false;\n   uint32 rounded_size = (options.size + 0xffff) & ~0xffff;\n   name_ = ASCIIToWide(options.name == NULL ? \"\" : *options.name);\n   mapped_file_ = CreateFileMapping(INVALID_HANDLE_VALUE, NULL,\n       PAGE_READWRITE, 0, static_cast<DWORD>(rounded_size),\n      name_.empty() ? NULL : name_.c_str());\n  if (!mapped_file_)\n    return false;\n  created_size_ = options.size;\n  if (GetLastError() == ERROR_ALREADY_EXISTS) {\n    created_size_ = 0;\n    if (!options.open_existing) {\n      Close();\n      return false;\n    }\n  }\n  return true;\n}", "target": 1}
{"code": "static struct clock_source *dce120_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(*clk_src), GFP_KERNEL);\n\tif (!clk_src)\n\t\treturn NULL;\n\tif (dce112_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\t\t     regs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 1}
{"code": "GC_API GC_ATTR_MALLOC void * GC_CALL GC_calloc_explicitly_typed(size_t n,\n                                                        size_t lb, GC_descr d)\n{\n    word *op;\n    size_t lg;\n    GC_descr simple_descr;\n    complex_descriptor *complex_descr;\n    int descr_type;\n    struct LeafDescriptor leaf;\n    GC_ASSERT(GC_explicit_typing_initialized);\n    descr_type = GC_make_array_descriptor((word)n, (word)lb, d, &simple_descr,\n                                          &complex_descr, &leaf);\n    switch(descr_type) {\n        case NO_MEM: return(0);\n        case SIMPLE: return(GC_malloc_explicitly_typed(n*lb, simple_descr));\n        case LEAF:\n            lb *= n;\n            lb += sizeof(struct LeafDescriptor) + TYPD_EXTRA_BYTES;\n            break;\n        case COMPLEX:\n            lb *= n;\n            lb += TYPD_EXTRA_BYTES;\n            break;\n    }\n    op = GC_malloc_kind(lb, GC_array_kind);\n    if (EXPECT(NULL == op, FALSE))\n        return NULL;\n    lg = SMALL_OBJ(lb) ? GC_size_map[lb] : BYTES_TO_GRANULES(GC_size(op));\n    if (descr_type == LEAF) {\n       volatile struct LeafDescriptor * lp =\n           (struct LeafDescriptor *)\n               (op + GRANULES_TO_WORDS(lg)\n                - (BYTES_TO_WORDS(sizeof(struct LeafDescriptor)) + 1));\n       lp -> ld_tag = LEAF_TAG;\n       lp -> ld_size = leaf.ld_size;\n       lp -> ld_nelements = leaf.ld_nelements;\n       lp -> ld_descriptor = leaf.ld_descriptor;\n       ((volatile word *)op)[GRANULES_TO_WORDS(lg) - 1] = (word)lp;\n   } else {\n#    ifndef GC_NO_FINALIZATION\n       size_t lw = GRANULES_TO_WORDS(lg);\n       op[lw - 1] = (word)complex_descr;\n       if (EXPECT(GC_general_register_disappearing_link(\n                                                (void **)(op + lw - 1), op)\n                  == GC_NO_MEMORY, FALSE))\n#    endif\n       {\n            return GC_malloc(lb);\n       }\n   }\n   return op;\n}", "target": 1}
{"code": "  virtual void SetUpCommandLine(CommandLine* command_line) {\n    GpuFeatureTest::SetUpCommandLine(command_line);\n    command_line->AppendSwitch(switches::kEnableThreadedCompositing);\n  }", "target": 1}
{"code": "get_uncompressed_data(struct archive_read *a, const void **buff, size_t size,\n    size_t minimum)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\tssize_t bytes_avail;\n \tif (zip->codec == _7Z_COPY && zip->codec2 == (unsigned long)-1) {\n\t\t*buff = __archive_read_ahead(a, 1, &bytes_avail);\n \t\tif (bytes_avail <= 0) {\n \t\t\tarchive_set_error(&a->archive,\n \t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Truncated 7-Zip file data\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tif ((size_t)bytes_avail >\n\t\t    zip->uncompressed_buffer_bytes_remaining)\n\t\t\tbytes_avail = (ssize_t)\n\t\t\t    zip->uncompressed_buffer_bytes_remaining;\n\t\tif ((size_t)bytes_avail > size)\n\t\t\tbytes_avail = (ssize_t)size;\n\t\tzip->pack_stream_bytes_unconsumed = bytes_avail;\n\t} else if (zip->uncompressed_buffer_pointer == NULL) {\n\t\tarchive_set_error(&(a->archive),\n\t\t    ARCHIVE_ERRNO_MISC, \"Damaged 7-Zip archive\");\n\t\treturn (ARCHIVE_FATAL);\n\t} else {\n\t\tif (minimum > zip->uncompressed_buffer_bytes_remaining) {\n\t\t\tif (extract_pack_stream(a, minimum) < 0)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tif (size > zip->uncompressed_buffer_bytes_remaining)\n\t\t\tbytes_avail = (ssize_t)\n\t\t\t    zip->uncompressed_buffer_bytes_remaining;\n\t\telse\n\t\t\tbytes_avail = (ssize_t)size;\n\t\t*buff = zip->uncompressed_buffer_pointer;\n\t\tzip->uncompressed_buffer_pointer += bytes_avail;\n\t}\n\tzip->uncompressed_buffer_bytes_remaining -= bytes_avail;\n\treturn (bytes_avail);\n}", "target": 1}
{"code": "PHP_XML_API zend_string *xml_utf8_encode(const char *s, size_t len, const XML_Char *encoding)\n{\n\tsize_t pos = len;\n\tzend_string *str;\n\tunsigned int c;\n\tunsigned short (*encoder)(unsigned char) = NULL;\n\txml_encoding *enc = xml_get_encoding(encoding);\n\tif (enc) {\n\t\tencoder = enc->encoding_function;\n\t} else {\n\t\treturn NULL;\n\t}\n\tif (encoder == NULL) {\n\t\tstr = zend_string_init(s, len, 0);\n\t\treturn str;\n\t}\n\tstr = zend_string_alloc(len * 4, 0);\n\tZSTR_LEN(str) = 0;\n\twhile (pos > 0) {\n\t\tc = encoder ? encoder((unsigned char)(*s)) : (unsigned short)(*s);\n\t\tif (c < 0x80) {\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (char) c;\n\t\t} else if (c < 0x800) {\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0xc0 | (c >> 6));\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0x80 | (c & 0x3f));\n\t\t} else if (c < 0x10000) {\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0xe0 | (c >> 12));\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0xc0 | ((c >> 6) & 0x3f));\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0x80 | (c & 0x3f));\n\t\t} else if (c < 0x200000) {\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0xf0 | (c >> 18));\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0xe0 | ((c >> 12) & 0x3f));\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0xc0 | ((c >> 6) & 0x3f));\n\t\t\tZSTR_VAL(str)[ZSTR_LEN(str)++] = (0x80 | (c & 0x3f));\n\t\t}\n\t\tpos--;\n\t\ts++;\n\t}\n\tZSTR_VAL(str)[ZSTR_LEN(str)] = '\\0';\n\tstr = zend_string_truncate(str, ZSTR_LEN(str), 0);\n\treturn str;\n}", "target": 1}
{"code": "void ath_tx_aggr_sleep(struct ieee80211_sta *sta, struct ath_softc *sc,\n\t\t       struct ath_node *an)\n{\n\tstruct ath_atx_tid *tid;\n\tstruct ath_atx_ac *ac;\n\tstruct ath_txq *txq;\n\tbool buffered;\n\tint tidno;\n \tfor (tidno = 0, tid = &an->tid[tidno];\n \t     tidno < IEEE80211_NUM_TIDS; tidno++, tid++) {\n\t\tif (!tid->sched)\n\t\t\tcontinue;\n \t\tac = tid->ac;\n \t\ttxq = ac->txq;\n \t\tath_txq_lock(sc, txq);\n \t\tbuffered = ath_tid_has_buffered(tid);\n \t\ttid->sched = false;\n\t\tlist_del(&tid->list);\n\t\tif (ac->sched) {\n\t\t\tac->sched = false;\n\t\t\tlist_del(&ac->list);\n\t\t}\n\t\tath_txq_unlock(sc, txq);\n\t\tieee80211_sta_set_buffered(sta, tidno, buffered);\n\t}\n}", "target": 1}
{"code": "static int cirrus_bitblt_videotovideo_copy(CirrusVGAState * s)\n{\n    if (s->ds->dpy_copy) {\n\tcirrus_do_copy(s, s->cirrus_blt_dstaddr - s->start_addr,\n\t\t       s->cirrus_blt_srcaddr - s->start_addr,\n\t\t       s->cirrus_blt_width, s->cirrus_blt_height);\n    } else {\n    if (BLTUNSAFE(s))\n        return 0;\n\t(*s->cirrus_rop) (s, s->vram_ptr +\n                (s->cirrus_blt_dstaddr & s->cirrus_addr_mask),\n\t\t\t  s->vram_ptr +\n                (s->cirrus_blt_srcaddr & s->cirrus_addr_mask),\n\t\t\t  s->cirrus_blt_dstpitch, s->cirrus_blt_srcpitch,\n\t\t\t  s->cirrus_blt_width, s->cirrus_blt_height);\n\tcirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\t\t\t\t s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\t\t\t\t s->cirrus_blt_height);\n    }\n    return 1;\n}", "target": 1}
{"code": "int qcow2_snapshot_load_tmp(BlockDriverState *bs,\n                            const char *snapshot_id,\n                            const char *name,\n                            Error **errp)\n{\n    int i, snapshot_index;\n    BDRVQcowState *s = bs->opaque;\n    QCowSnapshot *sn;\n    uint64_t *new_l1_table;\n    int new_l1_bytes;\n    int ret;\n    assert(bs->read_only);\n    snapshot_index = find_snapshot_by_id_and_name(bs, snapshot_id, name);\n    if (snapshot_index < 0) {\n        error_setg(errp,\n                   \"Can't find snapshot\");\n        return -ENOENT;\n    }\n     sn = &s->snapshots[snapshot_index];\n    new_l1_bytes = s->l1_size * sizeof(uint64_t);\n     new_l1_table = g_malloc0(align_offset(new_l1_bytes, 512));\n     ret = bdrv_pread(bs->file, sn->l1_table_offset, new_l1_table, new_l1_bytes);\n    if (ret < 0) {\n        error_setg(errp, \"Failed to read l1 table for snapshot\");\n        g_free(new_l1_table);\n        return ret;\n    }\n    g_free(s->l1_table);\n    s->l1_size = sn->l1_size;\n    s->l1_table_offset = sn->l1_table_offset;\n    s->l1_table = new_l1_table;\n    for(i = 0;i < s->l1_size; i++) {\n        be64_to_cpus(&s->l1_table[i]);\n    }\n    return 0;\n}", "target": 1}
{"code": "int nf_ct_frag6_gather(struct net *net, struct sk_buff *skb, u32 user)\n{\n\tstruct net_device *dev = skb->dev;\n\tint fhoff, nhoff, ret;\n\tstruct frag_hdr *fhdr;\n\tstruct frag_queue *fq;\n\tstruct ipv6hdr *hdr;\n\tu8 prevhdr;\n \tif (ipv6_hdr(skb)->payload_len == 0) {\n \t\tpr_debug(\"payload len = 0\\n\");\n\t\treturn -EINVAL;\n \t}\n \tif (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0)\n\t\treturn -EINVAL;\n \tif (!pskb_may_pull(skb, fhoff + sizeof(*fhdr)))\n \t\treturn -ENOMEM;\n\tskb_set_transport_header(skb, fhoff);\n\thdr = ipv6_hdr(skb);\n\tfhdr = (struct frag_hdr *)skb_transport_header(skb);\n\tfq = fq_find(net, fhdr->identification, user, &hdr->saddr, &hdr->daddr,\n\t\t     skb->dev ? skb->dev->ifindex : 0, ip6_frag_ecn(hdr));\n\tif (fq == NULL) {\n\t\tpr_debug(\"Can't find and can't create new queue\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tspin_lock_bh(&fq->q.lock);\n\tif (nf_ct_frag6_queue(fq, skb, fhdr, nhoff) < 0) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\tret = -EINPROGRESS;\n\tif (fq->q.flags == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&\n\t    fq->q.meat == fq->q.len &&\n\t    nf_ct_frag6_reasm(fq, skb, dev))\n\t\tret = 0;\nout_unlock:\n\tspin_unlock_bh(&fq->q.lock);\n\tinet_frag_put(&fq->q, &nf_frags);\n\treturn ret;\n}", "target": 1}
{"code": "static int read_public_key(RSA *rsa)\n{\n\tint r;\n\tsc_path_t path;\n\tsc_file_t *file;\n\tu8 buf[2048], *p = buf;\n\tsize_t bufsize, keysize;\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tsc_format_path(\"I1012\", &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r) {\n \t\tfprintf(stderr, \"Unable to select public key file: %s\\n\", sc_strerror(r));\n \t\treturn 2;\n \t}\n\tbufsize = file->size;\n \tsc_file_free(file);\n \tr = sc_read_binary(card, 0, buf, bufsize, 0);\n \tif (r < 0) {\n\t\tfprintf(stderr, \"Unable to read public key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tbufsize = r;\n\tdo {\n\t\tif (bufsize < 4)\n\t\t\treturn 3;\n\t\tkeysize = (p[0] << 8) | p[1];\n\t\tif (keysize == 0)\n\t\t\tbreak;\n\t\tif (keysize < 3)\n\t\t\treturn 3;\n\t\tif (p[2] == opt_key_num)\n\t\t\tbreak;\n\t\tp += keysize;\n\t\tbufsize -= keysize;\n\t} while (1);\n\tif (keysize == 0) {\n\t\tprintf(\"Key number %d not found.\\n\", opt_key_num);\n\t\treturn 2;\n\t}\n\treturn parse_public_key(p, keysize, rsa);\n}", "target": 1}
{"code": "struct edid *drm_load_edid_firmware(struct drm_connector *connector)\n{\n\tconst char *connector_name = connector->name;\n\tchar *edidname, *last, *colon, *fwstr, *edidstr, *fallback = NULL;\n\tstruct edid *edid;\n\tif (edid_firmware[0] == '\\0')\n\t\treturn ERR_PTR(-ENOENT);\n \tfwstr = kstrdup(edid_firmware, GFP_KERNEL);\n \tedidstr = fwstr;\n \twhile ((edidname = strsep(&edidstr, \",\"))) {\n\t\t\tif (strncmp(connector_name, edidname, colon - edidname))\n\t\t\t\tcontinue;\n\t\t\tedidname = colon + 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (*edidname != '\\0') \n\t\t\tfallback = edidname;\n\t}", "target": 1}
{"code": "static int ttusbdecfe_dvbs_diseqc_send_master_cmd(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd *cmd)\n{\n\tstruct ttusbdecfe_state* state = (struct ttusbdecfe_state*) fe->demodulator_priv;\n\tu8 b[] = { 0x00, 0xff, 0x00, 0x00,\n \t\t   0x00, 0x00, 0x00, 0x00,\n \t\t   0x00, 0x00 };\n \tmemcpy(&b[4], cmd->msg, cmd->msg_len);\n \tstate->config->send_command(fe, 0x72,\n\t\t\t\t    sizeof(b) - (6 - cmd->msg_len), b,\n\t\t\t\t    NULL, NULL);\n\treturn 0;\n}", "target": 1}
{"code": " int extract_status_code(char *buffer, size_t size)\n {\n\tchar *buf_code;\n\tchar *begin;\n \tchar *end = buffer + size;\n\tsize_t inc = 0;\n\tint code;\n\tbuf_code = (char *)MALLOC(10);\n\twhile (buffer < end && *buffer++ != ' ') ;\n\tbegin = buffer;\n\twhile (buffer < end && *buffer++ != ' ')\n\t\tinc++;\n\tstrncat(buf_code, begin, inc);\n\tcode = atoi(buf_code);\n\tFREE(buf_code);\n \treturn code;\n }", "target": 1}
{"code": "u32 h264bsdInitDpb(\n dpbStorage_t *dpb,\n  u32 picSizeInMbs,\n  u32 dpbSize,\n  u32 maxRefFrames,\n  u32 maxFrameNum,\n  u32 noReordering)\n{\n    u32 i;\n    ASSERT(picSizeInMbs);\n    ASSERT(maxRefFrames <= MAX_NUM_REF_PICS);\n    ASSERT(maxRefFrames <= dpbSize);\n     ASSERT(maxFrameNum);\n     ASSERT(dpbSize);\n     dpb->maxLongTermFrameIdx = NO_LONG_TERM_FRAME_INDICES;\n     dpb->maxRefFrames        = MAX(maxRefFrames, 1);\n     if (noReordering)\n        dpb->dpbSize         = dpb->maxRefFrames;\n else\n        dpb->dpbSize         = dpbSize;\n    dpb->maxFrameNum         = maxFrameNum;\n    dpb->noReordering        = noReordering;\n    dpb->fullness            = 0;\n    dpb->numRefFrames        = 0;\n    dpb->prevRefFrameNum     = 0;\n    ALLOCATE(dpb->buffer, MAX_NUM_REF_IDX_L0_ACTIVE + 1, dpbPicture_t);\n if (dpb->buffer == NULL)\n return(MEMORY_ALLOCATION_ERROR);\n    H264SwDecMemset(dpb->buffer, 0,\n (MAX_NUM_REF_IDX_L0_ACTIVE + 1)*sizeof(dpbPicture_t));\n for (i = 0; i < dpb->dpbSize + 1; i++)\n {\n        ALLOCATE(dpb->buffer[i].pAllocatedData, (picSizeInMbs*384 + 32+15), u8);\n if (dpb->buffer[i].pAllocatedData == NULL)\n return(MEMORY_ALLOCATION_ERROR);\n        dpb->buffer[i].data = ALIGN(dpb->buffer[i].pAllocatedData, 16);\n }\n    ALLOCATE(dpb->list, MAX_NUM_REF_IDX_L0_ACTIVE + 1, dpbPicture_t*);\n    ALLOCATE(dpb->outBuf, dpb->dpbSize+1, dpbOutPicture_t);\n if (dpb->list == NULL || dpb->outBuf == NULL)\n return(MEMORY_ALLOCATION_ERROR);\n    H264SwDecMemset(dpb->list, 0,\n ((MAX_NUM_REF_IDX_L0_ACTIVE + 1) * sizeof(dpbPicture_t*)) );\n    dpb->numOut = dpb->outIndex = 0;\n return(HANTRO_OK);\n}", "target": 1}
{"code": "static void iriap_getvaluebyclass_indication(struct iriap_cb *self,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct ias_object *obj;\n\tstruct ias_attrib *attrib;\n\tint name_len;\n\tint attr_len;\n\tchar name[IAS_MAX_CLASSNAME + 1];\t\n\tchar attr[IAS_MAX_ATTRIBNAME + 1];\t\n\t__u8 *fp;\n\tint n;\n\tIRDA_DEBUG(4, \"%s()\\n\", __func__);\n\tIRDA_ASSERT(self != NULL, return;);\n\tIRDA_ASSERT(self->magic == IAS_MAGIC, return;);\n\tIRDA_ASSERT(skb != NULL, return;);\n\tfp = skb->data;\n \tn = 1;\n \tname_len = fp[n++];\n \tmemcpy(name, fp+n, name_len); n+=name_len;\n \tname[name_len] = '\\0';\n \tattr_len = fp[n++];\n \tmemcpy(attr, fp+n, attr_len); n+=attr_len;\n \tattr[attr_len] = '\\0';\n\tIRDA_DEBUG(4, \"LM-IAS: Looking up %s: %s\\n\", name, attr);\n\tobj = irias_find_object(name);\n\tif (obj == NULL) {\n\t\tIRDA_DEBUG(2, \"LM-IAS: Object %s not found\\n\", name);\n\t\tiriap_getvaluebyclass_response(self, 0x1235, IAS_CLASS_UNKNOWN,\n\t\t\t\t\t       &irias_missing);\n\t\treturn;\n\t}\n\tIRDA_DEBUG(4, \"LM-IAS: found %s, id=%d\\n\", obj->name, obj->id);\n\tattrib = irias_find_attrib(obj, attr);\n\tif (attrib == NULL) {\n\t\tIRDA_DEBUG(2, \"LM-IAS: Attribute %s not found\\n\", attr);\n\t\tiriap_getvaluebyclass_response(self, obj->id,\n\t\t\t\t\t       IAS_ATTRIB_UNKNOWN,\n\t\t\t\t\t       &irias_missing);\n\t\treturn;\n\t}\n\tiriap_getvaluebyclass_response(self, obj->id, IAS_SUCCESS,\n\t\t\t\t       attrib->value);\n}", "target": 1}
{"code": "void phar_add_virtual_dirs(phar_archive_data *phar, char *filename, int filename_len TSRMLS_DC) \n{\n\tconst char *s;\n        while ((s = zend_memrchr(filename, '/', filename_len))) {\n                filename_len = s - filename;\n               if (FAILURE == zend_hash_add_empty_element(&phar->virtual_dirs, filename, filename_len)) {\n                        break;\n                }\n        }\n}", "target": 1}
{"code": "ga_concat_shorten_esc(garray_T *gap, char_u *str)\n{\n    char_u  *p;\n    char_u  *s;\n    int\t    c;\n    int\t    clen;\n    char_u  buf[NUMBUFLEN];\n    int\t    same_len;\n    if (str == NULL)\n    {\n\tga_concat(gap, (char_u *)\"NULL\");\n\treturn;\n    }\n    for (p = str; *p != NUL; ++p)\n    {\n\tsame_len = 1;\n\ts = p;\n\tc = mb_ptr2char_adv(&s);\n\tclen = s - p;\n\twhile (*s != NUL && c == mb_ptr2char(s))\n\t{\n\t    ++same_len;\n\t    s += clen;\n\t}\n\tif (same_len > 20)\n\t{\n\t    ga_concat(gap, (char_u *)\"\\\\[\");\n\t    ga_concat_esc(gap, p, clen);\n\t    ga_concat(gap, (char_u *)\" occurs \");\n\t    vim_snprintf((char *)buf, NUMBUFLEN, \"%d\", same_len);\n\t    ga_concat(gap, buf);\n\t    ga_concat(gap, (char_u *)\" times]\");\n\t    p = s - 1;\n\t}\n\telse\n\t    ga_concat_esc(gap, p, clen);\n    }\n}", "target": 1}
{"code": "static int tc_fill_qdisc(struct sk_buff *skb, struct Qdisc *q, u32 clid,\n\t\t\t u32 pid, u32 seq, u16 flags, int event)\n{\n\tstruct tcmsg *tcm;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char\t *b = skb->tail;\n\tstruct gnet_dump d;\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*tcm), flags);\n\ttcm = NLMSG_DATA(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm_ifindex = q->dev->ifindex;\n\ttcm->tcm_parent = clid;\n\ttcm->tcm_handle = q->handle;\n\ttcm->tcm_info = atomic_read(&q->refcnt);\n\tRTA_PUT(skb, TCA_KIND, IFNAMSIZ, q->ops->id);\n\tif (q->ops->dump && q->ops->dump(q, skb) < 0)\n\t\tgoto rtattr_failure;\n\tq->qstats.qlen = q->q.qlen;\n\tif (gnet_stats_start_copy_compat(skb, TCA_STATS2, TCA_STATS,\n\t\t\tTCA_XSTATS, q->stats_lock, &d) < 0)\n\t\tgoto rtattr_failure;\n\tif (q->ops->dump_stats && q->ops->dump_stats(q, &d) < 0)\n\t\tgoto rtattr_failure;\n\tif (gnet_stats_copy_basic(&d, &q->bstats) < 0 ||\n#ifdef CONFIG_NET_ESTIMATOR\n\t    gnet_stats_copy_rate_est(&d, &q->rate_est) < 0 ||\n#endif\n\t    gnet_stats_copy_queue(&d, &q->qstats) < 0)\n\t\tgoto rtattr_failure;\n\tif (gnet_stats_finish_copy(&d) < 0)\n\t\tgoto rtattr_failure;\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\nnlmsg_failure:\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1}
{"code": "PHP_FUNCTION( msgfmt_parse_message )\n{\n\tUChar      *spattern = NULL;\n\tint         spattern_len = 0;\n\tchar       *pattern = NULL;\n\tsize_t      pattern_len = 0;\n\tconst char *slocale = NULL;\n\tsize_t      slocale_len = 0;\n\tchar       *source = NULL;\n\tsize_t      src_len = 0;\n\tMessageFormatter_object mf;\n\tMessageFormatter_object *mfo = &mf;\n\tif( zend_parse_parameters( ZEND_NUM_ARGS(), \"sss\",\n\t\t  &slocale, &slocale_len, &pattern, &pattern_len, &source, &src_len ) == FAILURE )\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t\"msgfmt_parse_message: unable to parse input params\", 0 );\n\t\tRETURN_FALSE;\n\t}\n\tmemset(mfo, 0, sizeof(*mfo));\n\tmsgformat_data_init(&mfo->mf_data);\n\tif(pattern && pattern_len) {\n\t\tintl_convert_utf8_to_utf16(&spattern, &spattern_len, pattern, pattern_len, &INTL_DATA_ERROR_CODE(mfo));\n\t\tif( U_FAILURE(INTL_DATA_ERROR_CODE((mfo))) )\n\t\t{\n\t\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t\t\"msgfmt_parse_message: error converting pattern to UTF-16\", 0 );\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tspattern_len = 0;\n\t\tspattern = NULL;\n\t}\n\tif(slocale_len == 0) {\n\t\tslocale = intl_locale_get_default();\n\t}\n#ifdef MSG_FORMAT_QUOTE_APOS\n\tif(msgformat_fix_quotes(&spattern, &spattern_len, &INTL_DATA_ERROR_CODE(mfo)) != SUCCESS) {\n\t\tintl_error_set( NULL, U_INVALID_FORMAT_ERROR,\n\t\t\t\"msgfmt_parse_message: error converting pattern to quote-friendly format\", 0 );\n\t\tRETURN_FALSE;\n\t}\n#endif\n\tMSG_FORMAT_OBJECT(mfo) = umsg_open(spattern, spattern_len, slocale, NULL, &INTL_DATA_ERROR_CODE(mfo));\n\tif(spattern && spattern_len) {\n\t\tefree(spattern);\n\t}\n\tINTL_METHOD_CHECK_STATUS(mfo, \"Creating message formatter failed\");\n\tmsgfmt_do_parse(mfo, source, src_len, return_value);\n\tmsgformat_data_free(&mfo->mf_data);\n}", "target": 1}
{"code": " bittok2str_internal(register const struct tok *lp, register const char *fmt,\n \t   register u_int v, const char *sep)\n {\n        static char buf[256]; \n        int buflen=0;\n         register u_int rotbit; \n         register u_int tokval;\n         const char * sepstr = \"\";\n\twhile (lp != NULL && lp->s != NULL) {\n            tokval=lp->v;   \n            rotbit=1;\n            while (rotbit != 0) {\n \t\tif (tokval == (v&rotbit)) {\n                    buflen+=snprintf(buf+buflen, sizeof(buf)-buflen, \"%s%s\",\n                                     sepstr, lp->s);\n                     sepstr = sep;\n                     break;\n                 }\n                rotbit=rotbit<<1; \n            }\n             lp++;\n \t}\n        if (buflen == 0)\n             (void)snprintf(buf, sizeof(buf), fmt == NULL ? \"#%08x\" : fmt, v);\n         return (buf);\n}", "target": 1}
{"code": " xsltGenerateIdFunction(xmlXPathParserContextPtr ctxt, int nargs){\n     xmlNodePtr cur = NULL;\n     long val;\n     xmlChar str[30];\n     xmlDocPtr doc;\n     if (nargs == 0) {\n \tcur = ctxt->context->node;\n     } else if (nargs == 1) {\n\txmlXPathObjectPtr obj;\n \txmlNodeSetPtr nodelist;\n \tint i, ret;\n\tif ((ctxt->value == NULL) || (ctxt->value->type != XPATH_NODESET)) {\n\t    ctxt->error = XPATH_INVALID_TYPE;\n\t    xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n\t\t\"generate-id() : invalid arg expecting a node-set\\n\");\n\t    return;\n\t}\n\tobj = valuePop(ctxt);\n\tnodelist = obj->nodesetval;\n\tif ((nodelist == NULL) || (nodelist->nodeNr <= 0)) {\n\t    xmlXPathFreeObject(obj);\n\t    valuePush(ctxt, xmlXPathNewCString(\"\"));\n\t    return;\n\t}\n\tcur = nodelist->nodeTab[0];\n\tfor (i = 1;i < nodelist->nodeNr;i++) {\n\t    ret = xmlXPathCmpNodes(cur, nodelist->nodeTab[i]);\n \t    if (ret == -1)\n \t        cur = nodelist->nodeTab[i];\n \t}\n\txmlXPathFreeObject(obj);\n     } else {\n \txsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n \t\t\"generate-id() : invalid number of args %d\\n\", nargs);\n\tctxt->error = XPATH_INVALID_ARITY;\n\treturn;\n    }\n    if (cur->type != XML_NAMESPACE_DECL)\n        doc = cur->doc;\n    else {\n        xmlNsPtr ns = (xmlNsPtr) cur;\n        if (ns->context != NULL)\n            doc = ns->context;\n        else\n            doc = ctxt->context->doc;\n     }\n     val = (long)((char *)cur - (char *)doc);\n     if (val >= 0) {\n       sprintf((char *)str, \"idp%ld\", val);\n    } else {\n      sprintf((char *)str, \"idm%ld\", -val);\n    }\n    valuePush(ctxt, xmlXPathNewString(str));\n}", "target": 1}
{"code": "static bool MR_primality_test(UnsignedBigInteger n, const Vector<UnsignedBigInteger, 256>& tests)\n{\n    ASSERT(!(n < 4));\n    auto predecessor = n.minus({ 1 });\n    auto d = predecessor;\n    size_t r = 0;\n    {\n        auto div_result = d.divided_by(2);\n        while (div_result.remainder == 0) {\n            d = div_result.quotient;\n            div_result = d.divided_by(2);\n            ++r;\n        }\n    }\n    if (r == 0) {\n        return n == 2;\n    }\n    for (auto a : tests) {\n        ASSERT(a < n);\n        auto x = ModularPower(a, d, n);\n        if (x == 1 || x == predecessor)\n            continue;\n        bool skip_this_witness = false;\n        for (size_t i = 0; i < r - 1; ++i) {\n            x = ModularPower(x, 2, n);\n            if (x == predecessor) {\n                skip_this_witness = true;\n                break;\n            }\n        }\n        if (skip_this_witness)\n            continue;\n        return false; \n    }\n    return true; \n}", "target": 1}
{"code": "static int propagateConstantExprRewrite(Walker *pWalker, Expr *pExpr){\n  int i;\n  WhereConst *pConst;\n  if( pExpr->op!=TK_COLUMN ) return WRC_Continue;\n  if( ExprHasProperty(pExpr, EP_FixedCol) ) return WRC_Continue;\n  pConst = pWalker->u.pConst;\n  for(i=0; i<pConst->nConst; i++){\n    Expr *pColumn = pConst->apExpr[i*2];\n    if( pColumn==pExpr ) continue;\n    if( pColumn->iTable!=pExpr->iTable ) continue;\n    if( pColumn->iColumn!=pExpr->iColumn ) continue;\n    pConst->nChng++;\n    ExprClearProperty(pExpr, EP_Leaf);\n    ExprSetProperty(pExpr, EP_FixedCol);\n    assert( pExpr->pLeft==0 );\n    pExpr->pLeft = sqlite3ExprDup(pConst->pParse->db, pConst->apExpr[i*2+1], 0);\n    break;\n  }\n  return WRC_Prune;\n}", "target": 1}
{"code": "status_t ESDS::parseESDescriptor(size_t offset, size_t size) {\n if (size < 3) {\n return ERROR_MALFORMED;\n }\n    offset += 2; \n    size -= 2;\n unsigned streamDependenceFlag = mData[offset] & 0x80;\n unsigned URL_Flag = mData[offset] & 0x40;\n unsigned OCRstreamFlag = mData[offset] & 0x20;\n ++offset;\n     --size;\n     if (streamDependenceFlag) {\n         offset += 2;\n         size -= 2;\n     }\n if (URL_Flag) {\n if (offset >= size) {\n             return ERROR_MALFORMED;\n         }\n         unsigned URLlength = mData[offset];\n         offset += URLlength + 1;\n         size -= URLlength + 1;\n     }\n     if (OCRstreamFlag) {\n         offset += 2;\n         size -= 2;\n if ((offset >= size || mData[offset] != kTag_DecoderConfigDescriptor)\n && offset - 2 < size\n && mData[offset - 2] == kTag_DecoderConfigDescriptor) {\n            offset -= 2;\n            size += 2;\n            ALOGW(\"Found malformed 'esds' atom, ignoring missing OCR_ES_Id.\");\n }\n }\n if (offset >= size) {\n return ERROR_MALFORMED;\n }\n uint8_t tag;\n size_t sub_offset, sub_size;\n status_t err = skipDescriptorHeader(\n            offset, size, &tag, &sub_offset, &sub_size);\n if (err != OK) {\n return err;\n }\n if (tag != kTag_DecoderConfigDescriptor) {\n return ERROR_MALFORMED;\n }\n    err = parseDecoderConfigDescriptor(sub_offset, sub_size);\n return err;\n}", "target": 1}
{"code": "vips_foreign_load_gif_scan_image( VipsForeignLoadGif *gif ) \n {\n \tVipsObjectClass *class = VIPS_OBJECT_GET_CLASS( gif );\n \tGifFileType *file = gif->file;\n\tColorMapObject *map = file->Image.ColorMap ?\n\t\tfile->Image.ColorMap : file->SColorMap;\n \tGifByteType *extension;\n \tif( DGifGetImageDesc( gif->file ) == GIF_ERROR ) {\n\t\tvips_foreign_load_gif_error( gif ); \n\t\treturn( -1 );\n\t}\n\tif( file->Image.Left < 0 ||\n\t\tfile->Image.Width < 1 ||\n\t\tfile->Image.Width > 10000 ||\n\t\tfile->Image.Left + file->Image.Width > file->SWidth ||\n\t\tfile->Image.Top < 0 ||\n\t\tfile->Image.Height < 1 ||\n\t\tfile->Image.Height > 10000 ||\n\t\tfile->Image.Top + file->Image.Height > file->SHeight ) {\n\t\tvips_error( class->nickname, \"%s\", _( \"bad frame size\" ) ); \n\t\treturn( -1 ); \n\t}\n \tif( !gif->has_colour &&\n \t\tmap ) {\n \t\tint i;\n\t\tfor( i = 0; i < map->ColorCount; i++ ) \n\t\t\tif( map->Colors[i].Red != map->Colors[i].Green ||\n\t\t\t\tmap->Colors[i].Green != map->Colors[i].Blue ) {\n\t\t\t\tgif->has_colour = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\tdo {\n\t\tif( vips_foreign_load_gif_code_next( gif, &extension ) ) \n\t\t\treturn( -1 );\n\t} while( extension != NULL );\n\treturn( 0 );\n}", "target": 1}
{"code": "check_1_6_dummy(kadm5_principal_ent_t entry, long mask,\n                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)\n{\n    int i;\n     char *password = *passptr;\n    if (!(mask & KADM5_ATTRIBUTES) ||\n         !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))\n         return;\n    for (i = 0; (unsigned char) password[i] == i + 1; i++);\n    if (password[i] != '\\0' || i != 255)\n        return;\n    *passptr = NULL;\n}", "target": 1}
{"code": "static int snd_compr_allocate_buffer(struct snd_compr_stream *stream,\n\t\tstruct snd_compr_params *params)\n{\n \tunsigned int buffer_size;\n \tvoid *buffer;\n \tbuffer_size = params->buffer.fragment_size * params->buffer.fragments;\n \tif (stream->ops->copy) {\n \t\tbuffer = NULL;\n\t} else {\n\t\tbuffer = kmalloc(buffer_size, GFP_KERNEL);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t}\n\tstream->runtime->fragment_size = params->buffer.fragment_size;\n\tstream->runtime->fragments = params->buffer.fragments;\n\tstream->runtime->buffer = buffer;\n\tstream->runtime->buffer_size = buffer_size;\n\treturn 0;\n}", "target": 1}
{"code": "create_worker_threads(uint n)\n{\n\tcomp_thread_ctxt_t\t*threads;\n\tuint \t\t\ti;\n\tthreads = (comp_thread_ctxt_t *)\n\t\tmy_malloc(sizeof(comp_thread_ctxt_t) * n, MYF(MY_FAE));\n\tfor (i = 0; i < n; i++) {\n\t\tcomp_thread_ctxt_t *thd = threads + i;\n\t\tthd->num = i + 1;\n\t\tthd->started = FALSE;\n\t\tthd->cancelled = FALSE;\n\t\tthd->data_avail = FALSE;\n\t\tthd->to = (char *) my_malloc(COMPRESS_CHUNK_SIZE +\n\t\t\t\t\t\t   MY_QLZ_COMPRESS_OVERHEAD,\n\t\t\t\t\t\t   MYF(MY_FAE));\n\t\tif (pthread_mutex_init(&thd->ctrl_mutex, NULL) ||\n\t\t    pthread_cond_init(&thd->ctrl_cond, NULL)) {\n\t\t\tgoto err;\n\t\t}\n\t\tif (pthread_mutex_init(&thd->data_mutex, NULL) ||\n\t\t    pthread_cond_init(&thd->data_cond, NULL)) {\n\t\t\tgoto err;\n\t\t}\n\t\tpthread_mutex_lock(&thd->ctrl_mutex);\n\t\tif (pthread_create(&thd->id, NULL, compress_worker_thread_func,\n\t\t\t\t   thd)) {\n\t\t\tmsg(\"compress: pthread_create() failed: \"\n\t\t\t    \"errno = %d\", errno);\n\t\t\tpthread_mutex_unlock(&thd->ctrl_mutex);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tfor (i = 0; i < n; i++) {\n\t\tcomp_thread_ctxt_t *thd = threads + i;\n\t\twhile (thd->started == FALSE)\n\t\t\tpthread_cond_wait(&thd->ctrl_cond, &thd->ctrl_mutex);\n\t\tpthread_mutex_unlock(&thd->ctrl_mutex);\n\t}\n\treturn threads;\nerr:\n\tmy_free(threads);\n\treturn NULL;\n}", "target": 1}
{"code": "ut32 armass_assemble(const char *str, ut64 off, int thumb) {\n\tint i, j;\n\tchar buf[128];\n\tArmOpcode aop = {.off = off};\n\tfor (i = j = 0; i < sizeof (buf) - 1 && str[i]; i++, j++) {\n\t\tif (str[j] == '#') {\n\t\t\ti--; continue;\n\t\t}\n\t\tbuf[i] = tolower ((const ut8)str[j]);\n\t}\n\tbuf[i] = 0;\n\tarm_opcode_parse (&aop, buf);\n\taop.off = off;\n\tif (thumb < 0 || thumb > 1) {\n\t\treturn -1;\n\t}\n\tif (!assemble[thumb] (&aop, off, buf)) {\n\t\treturn -1;\n\t}\n\treturn aop.o;\n}", "target": 1}
{"code": "int is_ntfs_dotgit(const char *name)\n{\n\tsize_t len;\n\tfor (len = 0; ; len++)\n\t\tif (!name[len] || name[len] == '\\\\' || is_dir_sep(name[len])) {\n\t\t\tif (only_spaces_and_periods(name, len, 4) &&\n\t\t\t\t\t!strncasecmp(name, \".git\", 4))\n\t\t\t\treturn 1;\n\t\t\tif (only_spaces_and_periods(name, len, 5) &&\n\t\t\t\t\t!strncasecmp(name, \"git~1\", 5))\n\t\t\t\treturn 1;\n\t\t\treturn 0;\n\t\t}\n}", "target": 1}
{"code": "void ApplyBlockElementCommand::formatSelection(const VisiblePosition& startOfSelection, const VisiblePosition& endOfSelection)\n{\n    Position start = startOfSelection.deepEquivalent().downstream();\n    if (isAtUnsplittableElement(start)) {\n        RefPtr<Element> blockquote = createBlockElement();\n        insertNodeAt(blockquote, start);\n        RefPtr<Element> placeholder = createBreakElement(document());\n        appendNode(placeholder, blockquote);\n        setEndingSelection(VisibleSelection(positionBeforeNode(placeholder.get()), DOWNSTREAM, endingSelection().isDirectional()));\n        return;\n    }\n    RefPtr<Element> blockquoteForNextIndent;\n    VisiblePosition endOfCurrentParagraph = endOfParagraph(startOfSelection);\n    VisiblePosition endAfterSelection = endOfParagraph(endOfParagraph(endOfSelection).next());\n    m_endOfLastParagraph = endOfParagraph(endOfSelection).deepEquivalent();\n    bool atEnd = false;\n    Position end;\n    while (endOfCurrentParagraph != endAfterSelection && !atEnd) {\n        if (endOfCurrentParagraph.deepEquivalent() == m_endOfLastParagraph)\n            atEnd = true;\n        rangeForParagraphSplittingTextNodesIfNeeded(endOfCurrentParagraph, start, end);\n        endOfCurrentParagraph = end;\n        Position afterEnd = end.next();\n        Node* enclosingCell = enclosingNodeOfType(start, &isTableCell);\n        VisiblePosition endOfNextParagraph = endOfNextParagrahSplittingTextNodesIfNeeded(endOfCurrentParagraph, start, end);\n        formatRange(start, end, m_endOfLastParagraph, blockquoteForNextIndent);\n        if (enclosingCell && enclosingCell != enclosingNodeOfType(endOfNextParagraph.deepEquivalent(), &isTableCell))\n            blockquoteForNextIndent = 0;\n         if (endAfterSelection.isNotNull() && !endAfterSelection.deepEquivalent().inDocument())\n             break;\n        if (endOfNextParagraph.isNotNull() && !endOfNextParagraph.deepEquivalent().inDocument()) {\n            ASSERT_NOT_REACHED();\n             return;\n        }\n         endOfCurrentParagraph = endOfNextParagraph;\n     }\n }", "target": 1}
{"code": "static void adjust_branches(struct bpf_prog *prog, int pos, int delta)\n{\n\tstruct bpf_insn *insn = prog->insnsi;\n\tint insn_cnt = prog->len;\n\tint i;\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (BPF_CLASS(insn->code) != BPF_JMP ||\n\t\t    BPF_OP(insn->code) == BPF_CALL ||\n\t\t    BPF_OP(insn->code) == BPF_EXIT)\n\t\t\tcontinue;\n \t\tif (i < pos && i + insn->off + 1 > pos)\n \t\t\tinsn->off += delta;\n\t\telse if (i > pos && i + insn->off + 1 < pos)\n \t\t\tinsn->off -= delta;\n \t}\n }", "target": 1}
{"code": "static int hwsim_new_radio_nl(struct sk_buff *msg, struct genl_info *info)\n{\n\tstruct hwsim_new_radio_params param = { 0 };\n\tconst char *hwname = NULL;\n\tint ret;\n\tparam.reg_strict = info->attrs[HWSIM_ATTR_REG_STRICT_REG];\n\tparam.p2p_device = info->attrs[HWSIM_ATTR_SUPPORT_P2P_DEVICE];\n\tparam.channels = channels;\n\tparam.destroy_on_close =\n\t\tinfo->attrs[HWSIM_ATTR_DESTROY_RADIO_ON_CLOSE];\n\tif (info->attrs[HWSIM_ATTR_CHANNELS])\n\t\tparam.channels = nla_get_u32(info->attrs[HWSIM_ATTR_CHANNELS]);\n\tif (info->attrs[HWSIM_ATTR_NO_VIF])\n\t\tparam.no_vif = true;\n\tif (info->attrs[HWSIM_ATTR_RADIO_NAME]) {\n\t\thwname = kasprintf(GFP_KERNEL, \"%.*s\",\n\t\t\t\t   nla_len(info->attrs[HWSIM_ATTR_RADIO_NAME]),\n\t\t\t\t   (char *)nla_data(info->attrs[HWSIM_ATTR_RADIO_NAME]));\n\t\tif (!hwname)\n\t\t\treturn -ENOMEM;\n\t\tparam.hwname = hwname;\n\t}\n\tif (info->attrs[HWSIM_ATTR_USE_CHANCTX])\n\t\tparam.use_chanctx = true;\n\telse\n\t\tparam.use_chanctx = (param.channels > 1);\n\tif (info->attrs[HWSIM_ATTR_REG_HINT_ALPHA2])\n\t\tparam.reg_alpha2 =\n\t\t\tnla_data(info->attrs[HWSIM_ATTR_REG_HINT_ALPHA2]);\n \tif (info->attrs[HWSIM_ATTR_REG_CUSTOM_REG]) {\n \t\tu32 idx = nla_get_u32(info->attrs[HWSIM_ATTR_REG_CUSTOM_REG]);\n\t\tif (idx >= ARRAY_SIZE(hwsim_world_regdom_custom))\n \t\t\treturn -EINVAL;\n \t\tparam.regd = hwsim_world_regdom_custom[idx];\n \t}\n\tret = mac80211_hwsim_new_radio(info, &param);\n\tkfree(hwname);\n\treturn ret;\n}", "target": 1}
{"code": "int blk_init_allocated_queue(struct request_queue *q)\n{\n\tWARN_ON_ONCE(q->mq_ops);\n\tq->fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, q->cmd_size);\n\tif (!q->fq)\n\t\treturn -ENOMEM;\n\tif (q->init_rq_fn && q->init_rq_fn(q, q->fq->flush_rq, GFP_KERNEL))\n\t\tgoto out_free_flush_queue;\n\tif (blk_init_rl(&q->root_rl, q, GFP_KERNEL))\n\t\tgoto out_exit_flush_rq;\n\tINIT_WORK(&q->timeout_work, blk_timeout_work);\n\tq->queue_flags\t\t|= QUEUE_FLAG_DEFAULT;\n\tblk_queue_make_request(q, blk_queue_bio);\n\tq->sg_reserved_size = INT_MAX;\n\tif (elevator_init(q))\n\t\tgoto out_exit_flush_rq;\n\treturn 0;\nout_exit_flush_rq:\n\tif (q->exit_rq_fn)\n \t\tq->exit_rq_fn(q, q->fq->flush_rq);\n out_free_flush_queue:\n \tblk_free_flush_queue(q->fq);\n \treturn -ENOMEM;\n }", "target": 1}
{"code": "static void ctrycatchfinally(JF, js_Ast *trystm, js_Ast *catchvar, js_Ast *catchstm, js_Ast *finallystm)\n{\n\tint L1, L2, L3;\n\tL1 = emitjump(J, F, OP_TRY);\n\t{\n\t\tL2 = emitjump(J, F, OP_TRY);\n\t\t{\n\t\t\tcstm(J, F, finallystm); \n\t\t\temit(J, F, OP_THROW); \n\t\t}\n\t\tlabel(J, F, L2);\n\t\tif (F->strict) {\n\t\t\tcheckfutureword(J, F, catchvar);\n\t\t\tif (!strcmp(catchvar->string, \"arguments\"))\n\t\t\t\tjsC_error(J, catchvar, \"redefining 'arguments' is not allowed in strict mode\");\n\t\t\tif (!strcmp(catchvar->string, \"eval\"))\n\t\t\t\tjsC_error(J, catchvar, \"redefining 'eval' is not allowed in strict mode\");\n\t\t}\n\t\temitline(J, F, catchvar);\n \t\temitstring(J, F, OP_CATCH, catchvar->string);\n \t\tcstm(J, F, catchstm);\n \t\temit(J, F, OP_ENDCATCH);\n \t\tL3 = emitjump(J, F, OP_JUMP); \n \t}\n \tlabel(J, F, L1);\n\tcstm(J, F, trystm);\n\temit(J, F, OP_ENDTRY);\n\tlabel(J, F, L3);\n\tcstm(J, F, finallystm);\n}", "target": 1}
{"code": "static MagickOffsetType TIFFSeekCustomStream(const MagickOffsetType offset,\n  const int whence,void *user_data)\n{\n  PhotoshopProfile\n    *profile;\n  profile=(PhotoshopProfile *) user_data;\n  switch (whence)\n  {\n    case SEEK_SET:\n    default:\n    {\n      if (offset < 0)\n        return(-1);\n      profile->offset=offset;\n      break;\n     }\n     case SEEK_CUR:\n     {\n       if ((profile->offset+offset) < 0)\n         return(-1);\n       profile->offset+=offset;\n      break;\n    }\n    case SEEK_END:\n    {\n      if (((MagickOffsetType) profile->length+offset) < 0)\n        return(-1);\n      profile->offset=profile->length+offset;\n      break;\n    }\n  }\n  return(profile->offset);\n}", "target": 1}
{"code": "static int ep_loop_check_proc(void *priv, void *cookie, int call_nests)\n{\n\tint error = 0;\n\tstruct file *file = priv;\n\tstruct eventpoll *ep = file->private_data;\n\tstruct eventpoll *ep_tovisit;\n\tstruct rb_node *rbp;\n\tstruct epitem *epi;\n\tmutex_lock_nested(&ep->mtx, call_nests + 1);\n\tep->visited = 1;\n\tlist_add(&ep->visited_list_link, &visited_list);\n\tfor (rbp = rb_first_cached(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tif (unlikely(is_file_epoll(epi->ffd.file))) {\n\t\t\tep_tovisit = epi->ffd.file->private_data;\n\t\t\tif (ep_tovisit->visited)\n\t\t\t\tcontinue;\n\t\t\terror = ep_call_nested(&poll_loop_ncalls,\n\t\t\t\t\tep_loop_check_proc, epi->ffd.file,\n\t\t\t\t\tep_tovisit, current);\n\t\t\tif (error != 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (list_empty(&epi->ffd.file->f_tfile_llink))\n\t\t\t\tlist_add(&epi->ffd.file->f_tfile_llink,\n\t\t\t\t\t &tfile_check_list);\n\t\t}\n\t}\n\tmutex_unlock(&ep->mtx);\n\treturn error;\n}", "target": 1}
{"code": "static int rndis_query_response(USBNetState *s,\n                rndis_query_msg_type *buf, unsigned int length)\n{\n    rndis_query_cmplt_type *resp;\n    uint8_t infobuf[sizeof(oid_supported_list)];\n    uint32_t bufoffs, buflen;\n    int infobuflen;\n    unsigned int resplen;\n     bufoffs = le32_to_cpu(buf->InformationBufferOffset) + 8;\n     buflen = le32_to_cpu(buf->InformationBufferLength);\n    if (bufoffs + buflen > length)\n         return USB_RET_STALL;\n     infobuflen = ndis_query(s, le32_to_cpu(buf->OID),\n                             bufoffs + (uint8_t *) buf, buflen, infobuf,\n    resplen = sizeof(rndis_query_cmplt_type) +\n            ((infobuflen < 0) ? 0 : infobuflen);\n    resp = rndis_queue_response(s, resplen);\n    if (!resp)\n        return USB_RET_STALL;\n    resp->MessageType = cpu_to_le32(RNDIS_QUERY_CMPLT);\n    resp->RequestID = buf->RequestID; \n    resp->MessageLength = cpu_to_le32(resplen);\n    if (infobuflen < 0) {\n        resp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);\n        resp->InformationBufferLength = cpu_to_le32(0);\n        resp->InformationBufferOffset = cpu_to_le32(0);\n        return 0;\n    }\n    resp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n    resp->InformationBufferOffset =\n            cpu_to_le32(infobuflen ? sizeof(rndis_query_cmplt_type) - 8 : 0);\n    resp->InformationBufferLength = cpu_to_le32(infobuflen);\n    memcpy(resp + 1, infobuf, infobuflen);\n    return 0;\n}", "target": 1}
{"code": "vhost_user_set_log_base(struct virtio_net **pdev, struct VhostUserMsg *msg,\n\t\t\tint main_fd __rte_unused)\n{\n\tstruct virtio_net *dev = *pdev;\n\tint fd = msg->fds[0];\n\tuint64_t size, off;\n\tvoid *addr;\n\tif (validate_msg_fds(msg, 1) != 0)\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\tif (fd < 0) {\n\t\tVHOST_LOG_CONFIG(ERR, \"invalid log fd: %d\\n\", fd);\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\tif (msg->size != sizeof(VhostUserLog)) {\n\t\tVHOST_LOG_CONFIG(ERR,\n\t\t\t\"invalid log base msg size: %\"PRId32\" != %d\\n\",\n\t\t\tmsg->size, (int)sizeof(VhostUserLog));\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\tsize = msg->payload.log.mmap_size;\n\toff  = msg->payload.log.mmap_offset;\n\tif (off > size) {\n\t\tVHOST_LOG_CONFIG(ERR,\n\t\t\t\"log offset %#\"PRIx64\" exceeds log size %#\"PRIx64\"\\n\",\n\t\t\toff, size);\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\tVHOST_LOG_CONFIG(INFO,\n\t\t\"log mmap size: %\"PRId64\", offset: %\"PRId64\"\\n\",\n\t\tsize, off);\n\taddr = mmap(0, size + off, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n\tclose(fd);\n\tif (addr == MAP_FAILED) {\n\t\tVHOST_LOG_CONFIG(ERR, \"mmap log base failed!\\n\");\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\tif (dev->log_addr) {\n\t\tmunmap((void *)(uintptr_t)dev->log_addr, dev->log_size);\n\t}\n\tdev->log_addr = (uint64_t)(uintptr_t)addr;\n\tdev->log_base = dev->log_addr + off;\n\tdev->log_size = size;\n\tmsg->size = 0;\n\tmsg->fd_num = 0;\n\treturn RTE_VHOST_MSG_RESULT_REPLY;\n}", "target": 1}
{"code": "static PixelChannels **AcquirePixelThreadSet(const Image *images)\n{\n  const Image\n    *next;\n  PixelChannels\n    **pixels;\n  register ssize_t\n    i;\n   size_t\n     columns,\n    number_threads;\n  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  pixels=(PixelChannels **) AcquireQuantumMemory(number_threads,\n    sizeof(*pixels));\n   if (pixels == (PixelChannels **) NULL)\n     return((PixelChannels **) NULL);\n  (void) memset(pixels,0,number_threads*sizeof(*pixels));\n  columns=images->columns;\n   for (next=images; next != (Image *) NULL; next=next->next)\n     columns=MagickMax(next->columns,columns);\n  for (i=0; i < (ssize_t) number_threads; i++)\n   {\n     register ssize_t\n       j;\n    pixels[i]=(PixelChannels *) AcquireQuantumMemory(columns,sizeof(**pixels));\n    if (pixels[i] == (PixelChannels *) NULL)\n      return(DestroyPixelThreadSet(pixels));\n    for (j=0; j < (ssize_t) columns; j++)\n    {\n      register ssize_t\n        k;\n      for (k=0; k < MaxPixelChannels; k++)\n        pixels[i][j].channel[k]=0.0;\n    }\n  }\n  return(pixels);\n}", "target": 1}
{"code": "static int ep_loop_check_proc(void *priv, void *cookie, int call_nests)\n{\n\tint error = 0;\n\tstruct file *file = priv;\n\tstruct eventpoll *ep = file->private_data;\n\tstruct eventpoll *ep_tovisit;\n\tstruct rb_node *rbp;\n\tstruct epitem *epi;\n\tmutex_lock_nested(&ep->mtx, call_nests + 1);\n\tep->visited = 1;\n\tlist_add(&ep->visited_list_link, &visited_list);\n\tfor (rbp = rb_first_cached(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tif (unlikely(is_file_epoll(epi->ffd.file))) {\n\t\t\tep_tovisit = epi->ffd.file->private_data;\n\t\t\tif (ep_tovisit->visited)\n\t\t\t\tcontinue;\n\t\t\terror = ep_call_nested(&poll_loop_ncalls,\n\t\t\t\t\tep_loop_check_proc, epi->ffd.file,\n\t\t\t\t\tep_tovisit, current);\n\t\t\tif (error != 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (list_empty(&epi->ffd.file->f_tfile_llink)) {\n\t\t\t\tget_file(epi->ffd.file);\n\t\t\t\tlist_add(&epi->ffd.file->f_tfile_llink,\n\t\t\t\t\t &tfile_check_list);\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&ep->mtx);\n\treturn error;\n}", "target": 1}
{"code": "static void tm_reclaim_thread(struct thread_struct *thr,\n\t\t\t      struct thread_info *ti, uint8_t cause)\n{\n\tunsigned long msr_diff = 0;\n\tif (test_ti_thread_flag(ti, TIF_RESTORE_TM)) {\n\t\tmsr_diff = thr->ckpt_regs.msr & ~thr->regs->msr;\n\t\tif (msr_diff & MSR_FP)\n\t\t\tmemcpy(&thr->transact_fp, &thr->fp_state,\n\t\t\t       sizeof(struct thread_fp_state));\n\t\tif (msr_diff & MSR_VEC)\n\t\t\tmemcpy(&thr->transact_vr, &thr->vr_state,\n\t\t\t       sizeof(struct thread_vr_state));\n\t\tclear_ti_thread_flag(ti, TIF_RESTORE_TM);\n \t\tmsr_diff &= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;\n \t}\n \ttm_reclaim(thr, thr->regs->msr, cause);\n\tthr->regs->msr |= msr_diff;\n}", "target": 1}
{"code": "int simple_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n \tint error;\n \tif (type == ACL_TYPE_ACCESS) {\n\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\tif (error < 0)\n\t\t\treturn 0;\n\t\tif (error == 0)\n\t\t\tacl = NULL;\n \t}\n \tinode->i_ctime = current_time(inode);\n\tset_cached_acl(inode, type, acl);\n\treturn 0;\n}", "target": 1}
{"code": "Status ShapeRefiner::InferShapesForFunctionSubNode(\n    const Node* node, InferenceContext* outer_context) {\n  TF_RETURN_IF_ERROR(AddNodeInternal(node, outer_context));\n  InferenceContext* node_context = CHECK_NOTNULL(GetContext(node));\n  if (StringPiece(node->type_string()) == kArgOp) {\n    int index;\n    TF_RETURN_IF_ERROR(GetNodeAttr(AttrSlice(node->def()), \"index\", &index));\n    if (index < 0 || outer_context->num_inputs() <= index) {\n      return errors::Internal(\n          \"Function instantiation included invalid input index: \", index,\n          \" not in [0, \", outer_context->num_inputs(), \").\");\n    }\n    if (outer_context->input(index).SameHandle(ShapeHandle())) {\n      VLOG(1) << \"Function instantiation has undefined input shape at \"\n              << \"index: \" << index << \" in the outer inference context.\";\n      node_context->set_output(0, node_context->UnknownShape());\n    } else {\n      node_context->set_output(0, outer_context->input(index));\n    }\n    auto* resource = outer_context->input_handle_shapes_and_types(index);\n    if (resource) {\n      node_context->set_output_handle_shapes_and_types(0, *resource);\n    }\n  } else if (StringPiece(node->type_string()) == kRetvalOp) {\n    int index;\n    TF_RETURN_IF_ERROR(GetNodeAttr(AttrSlice(node->def()), \"index\", &index));\n    if (index < 0 || outer_context->num_outputs() <= index) {\n      return errors::Internal(\n          \"Function instantiation included invalid output index: \", index,\n          \" not in [0, \", outer_context->num_outputs(), \").\");\n    }\n    ShapeHandle handle;\n    TensorShapeProto proto;\n    node_context->ShapeHandleToProto(node_context->input(0), &proto);\n    TF_RETURN_IF_ERROR(outer_context->MakeShapeFromShapeProto(proto, &handle));\n    outer_context->set_output(index, handle);\n    auto* resource = node_context->input_handle_shapes_and_types(0);\n    if (resource) {\n      outer_context->set_output_handle_shapes_and_types(index, *resource);\n    }\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "GURL SanitizeFrontendURL(const GURL& url,\n                         const std::string& scheme,\n                         const std::string& host,\n                         const std::string& path,\n                         bool allow_query_and_fragment) {\n  std::vector<std::string> query_parts;\n  std::string fragment;\n  if (allow_query_and_fragment) {\n    for (net::QueryIterator it(url); !it.IsAtEnd(); it.Advance()) {\n      std::string value = SanitizeFrontendQueryParam(it.GetKey(),\n          it.GetValue());\n      if (!value.empty()) {\n        query_parts.push_back(\n             base::StringPrintf(\"%s=%s\", it.GetKey().c_str(), value.c_str()));\n       }\n     }\n    if (url.has_ref())\n       fragment = '#' + url.ref();\n   }\n   std::string query =\n      query_parts.empty() ? \"\" : \"?\" + base::JoinString(query_parts, \"&\");\n  std::string constructed =\n      base::StringPrintf(\"%s:\n                         path.c_str(), query.c_str(), fragment.c_str());\n  GURL result = GURL(constructed);\n  if (!result.is_valid())\n    return GURL();\n  return result;\n}", "target": 1}
{"code": "static rfbBool MallocFrameBuffer(rfbClient* client) {\n  if(client->frameBuffer)\n    free(client->frameBuffer);\n  client->frameBuffer=malloc(client->width*client->height*client->format.bitsPerPixel/8);\n  return client->frameBuffer?TRUE:FALSE;\n}", "target": 1}
{"code": "char *get_56_lenc_string(char **buffer,\n                         size_t *max_bytes_available,\n                         size_t *string_length)\n{\n  static char empty_string[1]= { '\\0' };\n  char *begin= *buffer;\n  if (*max_bytes_available == 0)\n    return NULL;\n  if (*begin == 0)\n  {\n    *string_length= 0;\n    --*max_bytes_available;\n    ++*buffer;\n    return empty_string;\n  }\n  *string_length= (size_t)net_field_length_ll((uchar **)buffer);\n  DBUG_EXECUTE_IF(\"sha256_password_scramble_too_long\",\n                  *string_length= SIZE_T_MAX;\n  );\n  size_t len_len= (size_t)(*buffer - begin);\n  if (*string_length > *max_bytes_available - len_len)\n    return NULL;\n  *max_bytes_available -= *string_length;\n  *max_bytes_available -= len_len;\n  *buffer += *string_length;\n  return (char *)(begin + len_len);\n}", "target": 1}
{"code": "WebGLObject::WebGLObject(WebGLRenderingContext* context)\n     : m_object(0)\n     , m_attachmentCount(0)\n     , m_deleted(false)\n{\n}", "target": 1}
{"code": "int blkcg_init_queue(struct request_queue *q)\n{\n\tstruct blkcg_gq *new_blkg, *blkg;\n\tbool preloaded;\n\tint ret;\n\tnew_blkg = blkg_alloc(&blkcg_root, q, GFP_KERNEL);\n\tif (!new_blkg)\n\t\treturn -ENOMEM;\n\tpreloaded = !radix_tree_preload(GFP_KERNEL);\n\trcu_read_lock();\n\tspin_lock_irq(q->queue_lock);\n\tblkg = blkg_create(&blkcg_root, q, new_blkg);\n\tspin_unlock_irq(q->queue_lock);\n\trcu_read_unlock();\n \tif (preloaded)\n \t\tradix_tree_preload_end();\n\tif (IS_ERR(blkg)) {\n\t\tblkg_free(new_blkg);\n \t\treturn PTR_ERR(blkg);\n\t}\n \tq->root_blkg = blkg;\n \tq->root_rl.blkg = blkg;\n\tret = blk_throtl_init(q);\n\tif (ret) {\n\t\tspin_lock_irq(q->queue_lock);\n\t\tblkg_destroy_all(q);\n\t\tspin_unlock_irq(q->queue_lock);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static int check_passwd(unsigned char *passwd, size_t length)\n{\n\tstruct digest *d = NULL;\n\tunsigned char *passwd1_sum;\n\tunsigned char *passwd2_sum;\n\tint ret = 0;\n\tint hash_len;\n\tif (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {\n\t\thash_len = PBKDF2_LENGTH;\n\t} else {\n\t\td = digest_alloc(PASSWD_SUM);\n\t\tif (!d) {\n\t\t\tpr_err(\"No such digest: %s\\n\",\n\t\t\t       PASSWD_SUM ? PASSWD_SUM : \"NULL\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t\thash_len = digest_length(d);\n\t}\n\tpasswd1_sum = calloc(hash_len * 2, sizeof(unsigned char));\n\tif (!passwd1_sum)\n\t\treturn -ENOMEM;\n\tpasswd2_sum = passwd1_sum + hash_len;\n\tif (is_passwd_env_enable())\n\t\tret = read_env_passwd(passwd2_sum, hash_len);\n\telse if (is_passwd_default_enable())\n\t\tret = read_default_passwd(passwd2_sum, hash_len);\n\telse\n\t\tret = -EINVAL;\n\tif (ret < 0)\n\t\tgoto err;\n\tif (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {\n\t\tchar *key = passwd2_sum + PBKDF2_SALT_LEN;\n\t\tchar *salt = passwd2_sum;\n\t\tint keylen = PBKDF2_LENGTH - PBKDF2_SALT_LEN;\n\t\tret = pkcs5_pbkdf2_hmac_sha1(passwd, length, salt,\n\t\t\tPBKDF2_SALT_LEN, PBKDF2_COUNT, keylen, passwd1_sum);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tif (strncmp(passwd1_sum, key, keylen) == 0)\n\t\t\tret = 1;\n\t} else {\n\t\tret = digest_digest(d, passwd, length, passwd1_sum);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tif (strncmp(passwd1_sum, passwd2_sum, hash_len) == 0)\n\t\t\tret = 1;\n\t}\nerr:\n\tfree(passwd1_sum);\n\tdigest_free(d);\n\treturn ret;\n}", "target": 1}
{"code": "static int hva_to_pfn_remapped(struct vm_area_struct *vma,\n\t\t\t       unsigned long addr, bool *async,\n\t\t\t       bool write_fault, bool *writable,\n\t\t\t       kvm_pfn_t *p_pfn)\n{\n\tkvm_pfn_t pfn;\n\tpte_t *ptep;\n\tspinlock_t *ptl;\n\tint r;\n\tr = follow_pte(vma->vm_mm, addr, &ptep, &ptl);\n\tif (r) {\n\t\tbool unlocked = false;\n\t\tr = fixup_user_fault(current->mm, addr,\n\t\t\t\t     (write_fault ? FAULT_FLAG_WRITE : 0),\n\t\t\t\t     &unlocked);\n\t\tif (unlocked)\n\t\t\treturn -EAGAIN;\n\t\tif (r)\n\t\t\treturn r;\n\t\tr = follow_pte(vma->vm_mm, addr, &ptep, &ptl);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\tif (write_fault && !pte_write(*ptep)) {\n\t\tpfn = KVM_PFN_ERR_RO_FAULT;\n\t\tgoto out;\n\t}\n\tif (writable)\n\t\t*writable = pte_write(*ptep);\n\tpfn = pte_pfn(*ptep);\n\tkvm_get_pfn(pfn);\nout:\n\tpte_unmap_unlock(ptep, ptl);\n\t*p_pfn = pfn;\n\treturn 0;\n}", "target": 1}
{"code": "static char *lxclock_name(const char *p, const char *n)\n{\n\tint ret;\n\tint len;\n\tchar *dest;\n\tchar *rundir;\n\tlen = strlen(\"/lock/lxc/\") + strlen(n) + strlen(p) + 2;\n\trundir = get_rundir();\n\tif (!rundir)\n\t\treturn NULL;\n\tlen += strlen(rundir);\n\tif ((dest = malloc(len)) == NULL) {\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\tret = snprintf(dest, len, \"%s/lock/lxc/%s\", rundir, p);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(dest);\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\tret = mkdir_p(dest, 0755);\n\tif (ret < 0) {\n\t\tint l2 = 33 + strlen(n) + strlen(p);\n\t\tif (l2 > len) {\n\t\t\tchar *d;\n\t\t\td = realloc(dest, l2);\n\t\t\tif (!d) {\n\t\t\t\tfree(dest);\n\t\t\t\tfree(rundir);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tlen = l2;\n\t\t\tdest = d;\n\t\t}\n\t\tret = snprintf(dest, len, \"/tmp/%d/lxc/%s\", geteuid(), p);\n\t\tif (ret < 0 || ret >= len) {\n\t\t\tfree(dest);\n\t\t\tfree(rundir);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = snprintf(dest, len, \"/tmp/%d/lxc/%s/%s\", geteuid(), p, n);\n\t} else\n\t\tret = snprintf(dest, len, \"%s/lock/lxc/%s/%s\", rundir, p, n);\n\tfree(rundir);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(dest);\n\t\treturn NULL;\n\t}\n\treturn dest;\n}", "target": 1}
{"code": "setup_secureChannel(void) {\n    TestingPolicy(&dummyPolicy, dummyCertificate, &fCalled, &keySizes);\n    UA_SecureChannel_init(&testChannel, &UA_ConnectionConfig_default);\n    UA_SecureChannel_setSecurityPolicy(&testChannel, &dummyPolicy, &dummyCertificate);\n    testingConnection = createDummyConnection(65535, &sentData);\n    UA_Connection_attachSecureChannel(&testingConnection, &testChannel);\n    testChannel.connection = &testingConnection;\n    testChannel.state = UA_SECURECHANNELSTATE_OPEN;\n}", "target": 1}
{"code": "RCMS *r_pkcs7_parse_cms (const ut8 *buffer, ut32 length) {\n\tRASN1Object *object;\n\tRCMS *container;\n\tif (!buffer || !length) {\n\t\treturn NULL;\n\t}\n\tcontainer = R_NEW0 (RCMS);\n\tif (!container) {\n \t\treturn NULL;\n \t}\n \tobject = r_asn1_create_object (buffer, length);\n\tif (!object || object->list.length != 2 || !object->list.objects[0] || object->list.objects[1]->list.length != 1) {\n \t\tr_asn1_free_object (object);\n \t\tfree (container);\n \t\treturn NULL;\n\t}\n\tcontainer->contentType = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length);\n\tr_pkcs7_parse_signeddata (&container->signedData, object->list.objects[1]->list.objects[0]);\n\tr_asn1_free_object (object);\n\treturn container;\n}", "target": 1}
{"code": "status_t GraphicBuffer::unflatten(\n void const*& buffer, size_t& size, int const*& fds, size_t& count) {\n if (size < 8*sizeof(int)) return NO_MEMORY;\n int const* buf = static_cast<int const*>(buffer);\n if (buf[0] != 'GBFR') return BAD_TYPE;\n     const size_t numFds  = buf[8];\n     const size_t numInts = buf[9];\n     const size_t sizeNeeded = (10 + numInts) * sizeof(int);\n     if (size < sizeNeeded) return NO_MEMORY;\n    size_t fdCountNeeded = 0;\n     if (count < fdCountNeeded) return NO_MEMORY;\n     if (handle) {\n        free_handle();\n }\n if (numFds || numInts) {\n        width  = buf[1];\n        height = buf[2];\n        stride = buf[3];\n         format = buf[4];\n         usage  = buf[5];\n         native_handle* h = native_handle_create(numFds, numInts);\n         memcpy(h->data,          fds,     numFds*sizeof(int));\n         memcpy(h->data + numFds, &buf[10], numInts*sizeof(int));\n         handle = h;\n } else {\n        width = height = stride = format = usage = 0;\n        handle = NULL;\n }\n    mId = static_cast<uint64_t>(buf[6]) << 32;\n    mId |= static_cast<uint32_t>(buf[7]);\n    mOwner = ownHandle;\n if (handle != 0) {\n status_t err = mBufferMapper.registerBuffer(handle);\n if (err != NO_ERROR) {\n            width = height = stride = format = usage = 0;\n            handle = NULL;\n            ALOGE(\"unflatten: registerBuffer failed: %s (%d)\",\n                    strerror(-err), err);\n return err;\n }\n }\n    buffer = reinterpret_cast<void const*>(static_cast<int const*>(buffer) + sizeNeeded);\n    size -= sizeNeeded;\n    fds += numFds;\n    count -= numFds;\n return NO_ERROR;\n}", "target": 1}
{"code": "CompositeDeepScanLine::setFrameBuffer(const FrameBuffer& fr)\n{\n    _Data->_channels.resize(3);\n    _Data->_channels[0]=\"Z\";\n    _Data->_channels[1]=_Data->_zback ? \"ZBack\" : \"Z\";\n    _Data->_channels[2]=\"A\";\n    _Data->_bufferMap.resize(0);\n    for(FrameBuffer::ConstIterator q=fr.begin();q!=fr.end();q++)\n    {\n        string name(q.name());\n        if(name==\"ZBack\")\n        {\n            _Data->_bufferMap.push_back(1);\n        }else if(name==\"Z\")\n        {\n            _Data->_bufferMap.push_back(0);\n        }else if(name==\"A\")\n        {\n            _Data->_bufferMap.push_back(2);\n        }else{\n            _Data->_bufferMap.push_back(static_cast<int>(_Data->_channels.size()));\n            _Data->_channels.push_back(name);\n        }\n    }\n  _Data->_outputFrameBuffer=fr;\n}", "target": 1}
{"code": "static int key_verify(pam_handle_t *pamh, int flags, PKCS11_KEY *authkey)\n {\n \tint ok = 0;\n \tunsigned char challenge[30];\n\tunsigned char signature[256];\n\tunsigned int siglen = sizeof signature;\n \tconst EVP_MD *md = EVP_sha1();\n \tEVP_MD_CTX *md_ctx = EVP_MD_CTX_new();\n \tEVP_PKEY *privkey = PKCS11_get_private_key(authkey);\n \tEVP_PKEY *pubkey = PKCS11_get_public_key(authkey);\n\tif (1 != randomize(pamh, challenge, sizeof challenge)) {\n\t\tgoto err;\n\t}\n\tif (NULL == pubkey || NULL == privkey || NULL == md_ctx || NULL == md\n\t\t\t|| !EVP_SignInit(md_ctx, md)\n\t\t\t|| !EVP_SignUpdate(md_ctx, challenge, sizeof challenge)\n\t\t\t|| !EVP_SignFinal(md_ctx, signature, &siglen, privkey)\n\t\t\t|| !EVP_MD_CTX_reset(md_ctx)\n\t\t\t|| !EVP_VerifyInit(md_ctx, md)\n\t\t\t|| !EVP_VerifyUpdate(md_ctx, challenge, sizeof challenge)\n\t\t\t|| 1 != EVP_VerifyFinal(md_ctx, signature, siglen, pubkey)) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"Error verifying key: %s\\n\",\n\t\t\t\tERR_reason_error_string(ERR_get_error()));\n\t\tprompt(flags, pamh, PAM_ERROR_MSG, NULL, _(\"Error verifying key\"));\n\t\tgoto err;\n\t}\n \tok = 1;\n err:\n \tif (NULL != pubkey)\n \t\tEVP_PKEY_free(pubkey);\n \tif (NULL != privkey)\n\t\tEVP_PKEY_free(privkey);\n\tif (NULL != md_ctx) {\n\t\tEVP_MD_CTX_free(md_ctx);\n\t}\n\treturn ok;\n}", "target": 1}
{"code": "uint8_t smb2cli_session_security_mode(struct smbXcli_session *session)\n{\n\tstruct smbXcli_conn *conn = session->conn;\n\tuint8_t security_mode = 0;\n\tif (conn == NULL) {\n\t\treturn security_mode;\n\t}\n\tsecurity_mode = SMB2_NEGOTIATE_SIGNING_ENABLED;\n        if (conn->mandatory_signing) {\n                security_mode |= SMB2_NEGOTIATE_SIGNING_REQUIRED;\n        }\n        return security_mode;\n }", "target": 1}
{"code": "static int mailimf_group_parse(const char * message, size_t length,\n\t\t\t       size_t * indx,\n\t\t\t       struct mailimf_group ** result)\n{\n  size_t cur_token;\n  char * display_name;\n  struct mailimf_mailbox_list * mailbox_list;\n   struct mailimf_group * group;\n   int r;\n   int res;\n   cur_token = * indx;\n  mailbox_list = NULL;\n  r = mailimf_display_name_parse(message, length, &cur_token, &display_name);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_display_name;\n  }\n  r = mailimf_mailbox_list_parse(message, length, &cur_token, &mailbox_list);\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    break;\n  case MAILIMF_ERROR_PARSE:\n    r = mailimf_cfws_parse(message, length, &cur_token);\n    if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n       res = r;\n       goto free_display_name;\n     }\n     break;\n   default:\n     res = r;\n    goto free_display_name;\n  }\n  r = mailimf_semi_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_mailbox_list;\n  }\n  group = mailimf_group_new(display_name, mailbox_list);\n  if (group == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_mailbox_list;\n  }\n  * indx = cur_token;\n  * result = group;\n  return MAILIMF_NO_ERROR;\n free_mailbox_list:\n  if (mailbox_list != NULL) {\n    mailimf_mailbox_list_free(mailbox_list);\n  }\n free_display_name:\n  mailimf_display_name_free(display_name);\n err:\n  return res;\n}", "target": 1}
{"code": "jp2_box_t *jp2_box_get(jas_stream_t *in)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len;\n\tuint_fast64_t extlen;\n\tbool dataflag;\n\tbox = 0;\n\ttmpstream = 0;\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\tgoto error;\n\t}\n\tbox->ops = &jp2_boxinfo_unk.ops;\n\tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n\t\tgoto error;\n\t}\n\tboxinfo = jp2_boxinfolookup(box->type);\n \tbox->info = boxinfo;\n \tbox->ops = &boxinfo->ops;\n \tbox->len = len;\n \tif (box->len == 1) {\n \t\tif (jp2_getuint64(in, &extlen)) {\n \t\t\tgoto error;\n\t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");\n\t\t\textlen = 0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n\t} else {\n\t\tbox->datalen = box->len - JP2_BOX_HDRLEN(false);\n\t}\n\tif (box->len != 0 && box->len < 8) {\n\t\tgoto error;\n\t}\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n \t\t\tgoto error;\n \t\t}\n \t\tif (jas_stream_copy(tmpstream, in, box->datalen)) {\n \t\t\tjas_eprintf(\"cannot copy box data\\n\");\n \t\t\tgoto error;\n \t\t}\n\t\tjas_stream_rewind(tmpstream);\n\t\tif (box->ops->getdata) {\n\t\t\tif ((*box->ops->getdata)(box, tmpstream)) {\n\t\t\t\tjas_eprintf(\"cannot parse box data\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\tif (jas_getdbglevel() >= 1) {\n\t\tjp2_box_dump(box, stderr);\n\t}\n\treturn box;\nerror:\n\tif (box) {\n\t\tjp2_box_destroy(box);\n\t}\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "asmlinkage long sys_setrlimit(unsigned int resource, struct rlimit __user *rlim)\n{\n\tstruct rlimit new_rlim, *old_rlim;\n\tunsigned long it_prof_secs;\n\tint retval;\n\tif (resource >= RLIM_NLIMITS)\n\t\treturn -EINVAL;\n\tif (copy_from_user(&new_rlim, rlim, sizeof(*rlim)))\n\t\treturn -EFAULT;\n\tif (new_rlim.rlim_cur > new_rlim.rlim_max)\n\t\treturn -EINVAL;\n\told_rlim = current->signal->rlim + resource;\n\tif ((new_rlim.rlim_max > old_rlim->rlim_max) &&\n\t    !capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\tif (resource == RLIMIT_NOFILE && new_rlim.rlim_max > NR_OPEN)\n\t\treturn -EPERM;\n\tretval = security_task_setrlimit(resource, &new_rlim);\n\tif (retval)\n\t\treturn retval;\n\ttask_lock(current->group_leader);\n\t*old_rlim = new_rlim;\n\ttask_unlock(current->group_leader);\n\tif (resource != RLIMIT_CPU)\n\t\tgoto out;\n\tif (new_rlim.rlim_cur == RLIM_INFINITY)\n\t\tgoto out;\n\tit_prof_secs = cputime_to_secs(current->signal->it_prof_expires);\n\tif (it_prof_secs == 0 || new_rlim.rlim_cur <= it_prof_secs) {\n\t\tunsigned long rlim_cur = new_rlim.rlim_cur;\n\t\tcputime_t cputime;\n\t\tif (rlim_cur == 0) {\n\t\t\trlim_cur = 1;\n\t\t}\n\t\tcputime = secs_to_cputime(rlim_cur);\n\t\tread_lock(&tasklist_lock);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\tset_process_cpu_timer(current, CPUCLOCK_PROF, &cputime, NULL);\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tread_unlock(&tasklist_lock);\n\t}\nout:\n\treturn 0;\n}", "target": 1}
{"code": " void usb_serial_console_disconnect(struct usb_serial *serial)\n {\n\tif (serial->port[0] == usbcons_info.port) {\n \t\tusb_serial_console_exit();\n \t\tusb_serial_put(serial);\n \t}\n}", "target": 1}
{"code": "bool IsIdentityConsumingSwitch(const MutableGraphView& graph,\n                               const NodeDef& node) {\n  if ((IsIdentity(node) || IsIdentityNSingleInput(node)) &&\n      node.input_size() > 0) {\n    TensorId tensor_id = ParseTensorName(node.input(0));\n    if (IsTensorIdControlling(tensor_id)) {\n      return false;\n    }\n    NodeDef* input_node = graph.GetNode(tensor_id.node());\n    return IsSwitch(*input_node);\n  }\n  return false;\n}", "target": 1}
{"code": "vcard_apdu_new(unsigned char *raw_apdu, int len, vcard_7816_status_t *status)\n{\n    VCardAPDU *new_apdu;\n    *status = VCARD7816_STATUS_EXC_ERROR_MEMORY_FAILURE;\n    if (len < 4) {\n        *status = VCARD7816_STATUS_ERROR_WRONG_LENGTH;\n        return NULL;\n    }\n    new_apdu = g_new(VCardAPDU, 1);\n    new_apdu->a_data = g_memdup(raw_apdu, len);\n     new_apdu->a_len = len;\n     *status = vcard_apdu_set_class(new_apdu);\n     if (*status != VCARD7816_STATUS_SUCCESS) {\n        g_free(new_apdu);\n         return NULL;\n     }\n     *status = vcard_apdu_set_length(new_apdu);\n     if (*status != VCARD7816_STATUS_SUCCESS) {\n        g_free(new_apdu);\n         new_apdu = NULL;\n     }\n     return new_apdu;\n}", "target": 1}
{"code": "GF_Err url_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\tif (ptr->size) {\n\t\tptr->location = (char*)gf_malloc((u32) ptr->size);\n\t\tif (! ptr->location) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->location, (u32)ptr->size);\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "void ConnectDialog::on_qaUrl_triggered() {\n\tServerItem *si = static_cast<ServerItem *>(qtwServers->currentItem());\n\tif (! si || si->qsUrl.isEmpty())\n\t\treturn;\n\tQDesktopServices::openUrl(QUrl(si->qsUrl));\n}", "target": 1}
{"code": "managesieve_parser_read_string(struct managesieve_parser *parser,\n\t\t\t\t   const unsigned char *data, size_t data_size)\n{\n\tsize_t i;\n\tfor (i = parser->cur_pos; i < data_size; i++) {\n\t\tif (data[i] == '\"') {\n\t\t\tif ( !uni_utf8_data_is_valid(data+1, i-1) ) {\n\t\t\t\tparser->error = \"Invalid UTF-8 character in quoted-string.\";\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tmanagesieve_parser_save_arg(parser, data, i);\n\t\t\ti++; \n\t\t\tbreak;\n\t\t}\n\t\tif (data[i] == '\\\\') {\n\t\t\tif (i+1 == data_size) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (parser->str_first_escape < 0)\n\t\t\t\tparser->str_first_escape = i;\n\t\t\ti++;\n\t\t\tif ( !IS_QUOTED_SPECIAL(data[i]) ) {\n\t\t\t\tparser->error =\n\t\t\t\t\t\"Escaped quoted-string character is not a QUOTED-SPECIAL.\";\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif ( (data[i] & 0x80) == 0 && !IS_SAFE_CHAR(data[i]) ) {\n\t\t\tparser->error = \"String contains invalid character.\";\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\tparser->cur_pos = i;\n\treturn ( parser->cur_type == ARG_PARSE_NONE );\n}", "target": 1}
{"code": "static int IntensityCompare(const void *x,const void *y)\n{\n  PixelPacket\n    *color_1,\n    *color_2;\n  ssize_t\n    intensity;\n  color_1=(PixelPacket *) x;\n  color_2=(PixelPacket *) y;\n  intensity=(ssize_t) PixelPacketIntensity(color_1)-\n    (ssize_t) PixelPacketIntensity(color_2);\n  return((int) intensity);\n}", "target": 1}
{"code": "static void tty_set_termios_ldisc(struct tty_struct *tty, int num)\n{\n \tdown_write(&tty->termios_rwsem);\n \ttty->termios.c_line = num;\n \tup_write(&tty->termios_rwsem);\n }", "target": 1}
{"code": "static void uv__process_child_init(const uv_process_options_t* options,\n                                   int stdio_count,\n                                   int (*pipes)[2],\n                                   int error_fd) {\n  int close_fd;\n  int use_fd;\n  int fd;\n  if (options->flags & UV_PROCESS_DETACHED)\n    setsid();\n  for (fd = 0; fd < stdio_count; fd++) {\n    close_fd = pipes[fd][0];\n    use_fd = pipes[fd][1];\n    if (use_fd < 0) {\n      if (fd >= 3)\n        continue;\n      else {\n        use_fd = open(\"/dev/null\", fd == 0 ? O_RDONLY : O_RDWR);\n        close_fd = use_fd;\n        if (use_fd == -1) {\n        uv__write_int(error_fd, -errno);\n          perror(\"failed to open stdio\");\n          _exit(127);\n        }\n      }\n    }\n    if (fd == use_fd)\n      uv__cloexec(use_fd, 0);\n    else\n      dup2(use_fd, fd);\n    if (fd <= 2)\n      uv__nonblock(fd, 0);\n    if (close_fd != -1)\n      uv__close(close_fd);\n  }\n  for (fd = 0; fd < stdio_count; fd++) {\n    use_fd = pipes[fd][1];\n    if (use_fd >= 0 && fd != use_fd)\n      close(use_fd);\n  }\n  if (options->cwd != NULL && chdir(options->cwd)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"chdir()\");\n     _exit(127);\n   }\n   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {\n     uv__write_int(error_fd, -errno);\n     perror(\"setgid()\");\n    _exit(127);\n  }\n  if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"setuid()\");\n    _exit(127);\n  }\n  if (options->env != NULL) {\n    environ = options->env;\n  }\n  execvp(options->file, options->args);\n  uv__write_int(error_fd, -errno);\n  perror(\"execvp()\");\n  _exit(127);\n}", "target": 1}
{"code": "struct resource_pool *dce100_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc  *dc)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\tif (!pool)\n\t\treturn NULL;\n\tif (construct(num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 1}
{"code": "int LibuvStreamWrap::DoWrite(WriteWrap* req_wrap,\n                             uv_buf_t* bufs,\n                             size_t count,\n                             uv_stream_t* send_handle) {\n  LibuvWriteWrap* w = static_cast<LibuvWriteWrap*>(req_wrap);\n  int r;\n  if (send_handle == nullptr) {\n    r = w->Dispatch(uv_write, stream(), bufs, count, AfterUvWrite);\n  } else {\n    r = w->Dispatch(uv_write2,\n                    stream(),\n                    bufs,\n                    count,\n                    send_handle,\n                    AfterUvWrite);\n  }\n  if (!r) {\n    size_t bytes = 0;\n    for (size_t i = 0; i < count; i++)\n      bytes += bufs[i].len;\n    if (stream()->type == UV_TCP) {\n      NODE_COUNT_NET_BYTES_SENT(bytes);\n    } else if (stream()->type == UV_NAMED_PIPE) {\n      NODE_COUNT_PIPE_BYTES_SENT(bytes);\n    }\n  }\n  return r;\n}", "target": 1}
{"code": "AP4_VisualSampleEntry::ReadFields(AP4_ByteStream& stream)\n{\n    AP4_Result result = AP4_SampleEntry::ReadFields(stream);\n    if (result < 0) return result;\n    stream.ReadUI16(m_Predefined1);\n    stream.ReadUI16(m_Reserved2);\n    stream.Read(m_Predefined2, sizeof(m_Predefined2));\n    stream.ReadUI16(m_Width);\n    stream.ReadUI16(m_Height);\n    stream.ReadUI32(m_HorizResolution);\n    stream.ReadUI32(m_VertResolution);\n    stream.ReadUI32(m_Reserved3);\n    stream.ReadUI16(m_FrameCount);\n    char compressor_name[33];\n    compressor_name[32] = 0;\n    stream.Read(compressor_name, 32);\n    int name_length = compressor_name[0];\n    if (name_length < 32) {\n        compressor_name[name_length+1] = 0; \n        m_CompressorName = &compressor_name[1];\n    }\n    stream.ReadUI16(m_Depth);\n    stream.ReadUI16(m_Predefined3);\n    return AP4_SUCCESS;\n}", "target": 1}
{"code": "void Ogg::XiphComment::parse(const ByteVector &data)\n{\n  int pos = 0;\n  int vendorLength = data.mid(0, 4).toUInt(false);\n  pos += 4;\n  d->vendorID = String(data.mid(pos, vendorLength), String::UTF8);\n  pos += vendorLength;\n  int commentFields = data.mid(pos, 4).toUInt(false);\n  pos += 4;\n  for(int i = 0; i < commentFields; i++) {\n    int commentLength = data.mid(pos, 4).toUInt(false);\n    pos += 4;\n    String comment = String(data.mid(pos, commentLength), String::UTF8);\n    pos += commentLength;\n    int commentSeparatorPosition = comment.find(\"=\");\n    String key = comment.substr(0, commentSeparatorPosition);\n    String value = comment.substr(commentSeparatorPosition + 1);\n    addField(key, value, false);\n  }\n}", "target": 1}
{"code": " void BnCrypto::readVector(const Parcel &data, Vector<uint8_t> &vector) const {\n     uint32_t size = data.readInt32();\n    vector.insertAt((size_t)0, size);\n    data.read(vector.editArray(), size);\n }", "target": 1}
{"code": "static int verify_newpolicy_info(struct xfrm_userpolicy_info *p)\n{\n\tint ret;\n\tswitch (p->share) {\n\tcase XFRM_SHARE_ANY:\n\tcase XFRM_SHARE_SESSION:\n\tcase XFRM_SHARE_USER:\n\tcase XFRM_SHARE_UNIQUE:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tswitch (p->action) {\n\tcase XFRM_POLICY_ALLOW:\n\tcase XFRM_POLICY_BLOCK:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tswitch (p->sel.family) {\n\tcase AF_INET:\n\t\tif (p->sel.prefixlen_d > 32 || p->sel.prefixlen_s > 32)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase AF_INET6:\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tif (p->sel.prefixlen_d > 128 || p->sel.prefixlen_s > 128)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n#else\n\t\treturn  -EAFNOSUPPORT;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tret = verify_policy_dir(p->dir);\n\tif (ret)\n\t\treturn ret;\n\tif (p->index && ((p->index & XFRM_POLICY_MAX) != p->dir))\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "static void cil_reset_perm(struct cil_perm *perm)\n{\n\tcil_reset_classperms_list(perm->classperms);\n}", "target": 1}
{"code": "std::string controller::bookmark(\n\t\tconst std::string& url,\n\t\tconst std::string& title,\n\t\tconst std::string& description,\n\t\tconst std::string& feed_title)\n{\n\tstd::string bookmark_cmd = cfg.get_configvalue(\"bookmark-cmd\");\n\tbool is_interactive = cfg.get_configvalue_as_bool(\"bookmark-interactive\");\n\tif (bookmark_cmd.length() > 0) {\n\t\tstd::string cmdline = strprintf::fmt(\"%s '%s' %s %s %s\",\n\t\t                                       bookmark_cmd,\n\t\t                                       utils::replace_all(url,\"'\", \"%27\"),\n\t\t                                       quote_empty(stfl::quote(title)),\n\t\t                                       quote_empty(stfl::quote(description)),\n\t\t                                       quote_empty(stfl::quote(feed_title)));\n\t\tLOG(level::DEBUG, \"controller::bookmark: cmd = %s\", cmdline);\n\t\tif (is_interactive) {\n\t\t\tv->push_empty_formaction();\n\t\t\tstfl::reset();\n\t\t\tutils::run_interactively(cmdline, \"controller::bookmark\");\n\t\t\tv->pop_current_formaction();\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\tchar * my_argv[4];\n\t\t\tmy_argv[0] = const_cast<char *>(\"/bin/sh\");\n\t\t\tmy_argv[1] = const_cast<char *>(\"-c\");\n\t\t\tmy_argv[2] = const_cast<char *>(cmdline.c_str());\n\t\t\tmy_argv[3] = nullptr;\n\t\t\treturn utils::run_program(my_argv, \"\");\n\t\t}\n\t} else {\n\t\treturn _(\"bookmarking support is not configured. Please set the configuration variable `bookmark-cmd' accordingly.\");\n\t}\n}", "target": 1}
{"code": "static void voutf(struct GlobalConfig *config,\n                  const char *prefix,\n                  const char *fmt,\n                  va_list ap)\n{\n  size_t width = (79 - strlen(prefix));\n  if(!config->mute) {\n    size_t len;\n    char *ptr;\n    char *print_buffer;\n    print_buffer = curlx_mvaprintf(fmt, ap);\n    if(!print_buffer)\n      return;\n    len = strlen(print_buffer);\n    ptr = print_buffer;\n    while(len > 0) {\n      fputs(prefix, config->errors);\n      if(len > width) {\n        size_t cut = width-1;\n        while(!ISSPACE(ptr[cut]) && cut) {\n          cut--;\n        }\n        if(0 == cut)\n          cut = width-1;\n         (void)fwrite(ptr, cut + 1, 1, config->errors);\n         fputs(\"\\n\", config->errors);\n         ptr += cut + 1; \n        len -= cut;\n       }\n       else {\n         fputs(ptr, config->errors);\n        len = 0;\n      }\n    }\n    curl_free(print_buffer);\n  }\n}", "target": 1}
{"code": "PrimitiveStatus TrustedPrimitives::UntrustedCall(uint64_t untrusted_selector,\n                                                 MessageWriter *input,\n                                                 MessageReader *output) {\n  int ret;\n  UntrustedCacheMalloc *untrusted_cache = UntrustedCacheMalloc::Instance();\n  SgxParams *const sgx_params =\n      reinterpret_cast<SgxParams *>(untrusted_cache->Malloc(sizeof(SgxParams)));\n  Cleanup clean_up(\n      [sgx_params, untrusted_cache] { untrusted_cache->Free(sgx_params); });\n  sgx_params->input_size = 0;\n  sgx_params->input = nullptr;\n  if (input) {\n    sgx_params->input_size = input->MessageSize();\n    if (sgx_params->input_size > 0) {\n      sgx_params->input = untrusted_cache->Malloc(sgx_params->input_size);\n      input->Serialize(const_cast<void *>(sgx_params->input));\n    }\n  }\n  sgx_params->output_size = 0;\n  sgx_params->output = nullptr;\n  CHECK_OCALL(\n      ocall_dispatch_untrusted_call(&ret, untrusted_selector, sgx_params));\n  if (sgx_params->input) {\n    untrusted_cache->Free(const_cast<void *>(sgx_params->input));\n  }\n  if (sgx_params->output) {\n    output->Deserialize(sgx_params->output, sgx_params->output_size);\n    TrustedPrimitives::UntrustedLocalFree(sgx_params->output);\n  }\n  return PrimitiveStatus::OkStatus();\n}", "target": 1}
{"code": "static int vrend_decode_create_ve(struct vrend_decode_ctx *ctx, uint32_t handle, uint16_t length)\n{\n   struct pipe_vertex_element *ve = NULL;\n   int num_elements;\n   int i;\n   int ret;\n   if (length < 1)\n      return EINVAL;\n   if ((length - 1) % 4)\n      return EINVAL;\n   num_elements = (length - 1) / 4;\n   if (num_elements) {\n      ve = calloc(num_elements, sizeof(struct pipe_vertex_element));\n      if (!ve)\n         return ENOMEM;\n      for (i = 0; i < num_elements; i++) {\n          ve[i].src_offset = get_buf_entry(ctx, VIRGL_OBJ_VERTEX_ELEMENTS_V0_SRC_OFFSET(i));\n          ve[i].instance_divisor = get_buf_entry(ctx, VIRGL_OBJ_VERTEX_ELEMENTS_V0_INSTANCE_DIVISOR(i));\n          ve[i].vertex_buffer_index = get_buf_entry(ctx, VIRGL_OBJ_VERTEX_ELEMENTS_V0_VERTEX_BUFFER_INDEX(i));\n          ve[i].src_format = get_buf_entry(ctx, VIRGL_OBJ_VERTEX_ELEMENTS_V0_SRC_FORMAT(i));\n       }\n    }\n   return ret;\n}", "target": 1}
{"code": "static int spk_ttyio_ldisc_open(struct tty_struct *tty)\n{\n\tstruct spk_ldisc_data *ldisc_data;\n\tif (!tty->ops->write)\n\t\treturn -EOPNOTSUPP;\n\tspeakup_tty = tty;\n\tldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);\n\tif (!ldisc_data)\n\t\treturn -ENOMEM;\n\tinit_completion(&ldisc_data->completion);\n\tldisc_data->buf_free = true;\n\tspeakup_tty->disc_data = ldisc_data;\n\treturn 0;\n}", "target": 1}
{"code": "int button_open(Button *b) {\n        char *p, name[256];\n        int r;\n        assert(b);\n        b->fd = safe_close(b->fd);\n        p = strjoina(\"/dev/input/\", b->name);\n        b->fd = open(p, O_RDWR|O_CLOEXEC|O_NOCTTY|O_NONBLOCK);\n        if (b->fd < 0)\n                return log_warning_errno(errno, \"Failed to open %s: %m\", p);\n        r = button_suitable(b);\n        if (r < 0)\n                return log_warning_errno(r, \"Failed to determine whether input device is relevant to us: %m\");\n        if (r == 0)\n                return log_debug_errno(SYNTHETIC_ERRNO(EADDRNOTAVAIL),\n                                       \"Device %s does not expose keys or switches relevant to us, ignoring.\",\n                                       p);\n        if (ioctl(b->fd, EVIOCGNAME(sizeof(name)), name) < 0) {\n                r = log_error_errno(errno, \"Failed to get input name: %m\");\n                goto fail;\n        }\n        (void) button_set_mask(b);\n        r = sd_event_add_io(b->manager->event, &b->io_event_source, b->fd, EPOLLIN, button_dispatch, b);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to add button event: %m\");\n                goto fail;\n        }\n        log_info(\"Watching system buttons on /dev/input/%s (%s)\", b->name, name);\n        return 0;\nfail:\n        b->fd = safe_close(b->fd);\n        return r;\n}", "target": 1}
{"code": "_rsvg_node_poly_build_path (const char *value,\n                            gboolean close_path)\n{\n    double *pointlist;\n    guint pointlist_len, i;\n    GString *d;\n    cairo_path_t *path;\n    char buf[G_ASCII_DTOSTR_BUF_SIZE];\n    pointlist = rsvg_css_parse_number_list (value, &pointlist_len);\n    if (pointlist == NULL)\n        return NULL;\n    if (pointlist_len < 2) {\n        g_free (pointlist);\n        return NULL;\n    }\n    d = g_string_new (NULL);\n    g_string_append (d, \" M \");\n    g_string_append (d, g_ascii_dtostr (buf, sizeof (buf), pointlist[0]));\n    g_string_append_c (d, ' ');\n    g_string_append (d, g_ascii_dtostr (buf, sizeof (buf), pointlist[1]));\n    for (i = 2; i < pointlist_len; i += 2) {\n        g_string_append (d, \" L \");\n        g_string_append (d, g_ascii_dtostr (buf, sizeof (buf), pointlist[i]));\n        g_string_append_c (d, ' ');\n        g_string_append (d, g_ascii_dtostr (buf, sizeof (buf), pointlist[i + 1]));\n    }\n    if (close_path)\n        g_string_append (d, \" Z\");\n    path = rsvg_parse_path (d->str);\n    g_string_free (d, TRUE);\n    g_free (pointlist);\n    return path;\n}", "target": 1}
{"code": "    kssl_keytab_is_available(KSSL_CTX *kssl_ctx)\n{\n    krb5_context\t\tkrb5context = NULL;\n    krb5_keytab \t\tkrb5keytab = NULL;\n    krb5_keytab_entry           entry;\n    krb5_principal              princ = NULL;\n    krb5_error_code  \t\tkrb5rc = KRB5KRB_ERR_GENERIC;\n    int rc = 0;\n    if ((krb5rc = krb5_init_context(&krb5context)))\n        return(0);\n    if (kssl_ctx->keytab_file)\n    {\n        krb5rc = krb5_kt_resolve(krb5context, kssl_ctx->keytab_file,\n                                  &krb5keytab);\n        if (krb5rc)\n            goto exit;\n    }\n    else\n    {\n        krb5rc = krb5_kt_default(krb5context,&krb5keytab);\n        if (krb5rc)\n            goto exit;\n    }\n    krb5rc = krb5_sname_to_principal(krb5context, NULL, \n                                     kssl_ctx->service_name ? kssl_ctx->service_name: KRB5SVC,\n                                     KRB5_NT_SRV_HST, &princ);\n    krb5rc = krb5_kt_get_entry(krb5context, krb5keytab, \n                                princ,\n                                0 ,\n                                0 ,\n                                &entry);\n    if ( krb5rc == KRB5_KT_NOTFOUND ) {\n        rc = 1;\n        goto exit;\n    } else if ( krb5rc )\n        goto exit;\n    krb5_kt_free_entry(krb5context, &entry);\n    rc = 1;\n  exit:\n    if (krb5keytab)     krb5_kt_close(krb5context, krb5keytab);\n    if (princ)          krb5_free_principal(krb5context, princ);\n    if (krb5context)\tkrb5_free_context(krb5context);\n    return(rc);\n}", "target": 1}
{"code": "bool DependencyOptimizer::SafeToRemoveIdentity(const NodeDef& node) const {\n  if (!IsIdentity(node) && !IsIdentityN(node)) {\n    return true;\n  }\n  if (nodes_to_preserve_.find(node.name()) != nodes_to_preserve_.end()) {\n    return false;\n  }\n  if (!fetch_nodes_known_) {\n    return false;\n  }\n  if (node.input_size() < 1) {\n    return false;\n  }\n  const NodeDef* input = node_map_->GetNode(NodeName(node.input(0)));\n  CHECK(input != nullptr) << \"node = \" << node.name()\n                          << \" input = \" << node.input(0);\n  if (IsVariable(*input) || IsRecv(*input)) {\n    return false;\n  }\n  for (const auto& consumer : node_map_->GetOutputs(node.name())) {\n    if (node.input_size() > 1 && (IsRetval(*consumer) || IsMerge(*consumer))) {\n      return false;\n    }\n    if (IsSwitch(*input)) {\n      for (const string& consumer_input : consumer->input()) {\n        if (consumer_input == AsControlDependency(node.name())) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}", "target": 1}
{"code": "  t42_parse_font_matrix( T42_Face    face,\n                         T42_Loader  loader )\n  {\n    T42_Parser  parser = &loader->parser;\n    FT_Matrix*  matrix = &face->type1.font_matrix;\n    FT_Vector*  offset = &face->type1.font_offset;\n     FT_Face     root   = (FT_Face)&face->root;\n     FT_Fixed    temp[6];\n     FT_Fixed    temp_scale;\n    (void)T1_ToFixedArray( parser, 6, temp, 3 );\n     temp_scale = FT_ABS( temp[3] );\n    matrix->xx = temp[0];\n    matrix->yx = temp[1];\n    matrix->xy = temp[2];\n    matrix->yy = temp[3];\n    offset->x = temp[4] >> 16;\n    offset->y = temp[5] >> 16;\n       temp[2] = FT_DivFix( temp[2], temp_scale );\n       temp[4] = FT_DivFix( temp[4], temp_scale );\n       temp[5] = FT_DivFix( temp[5], temp_scale );\n      temp[3] = 0x10000L;\n     }", "target": 1}
{"code": "static void setup_format_params(int track)\n{\n\tint n;\n\tint il;\n\tint count;\n\tint head_shift;\n\tint track_shift;\n\tstruct fparm {\n\t\tunsigned char track, head, sect, size;\n\t} *here = (struct fparm *)floppy_track_buffer;\n\traw_cmd = &default_raw_cmd;\n\traw_cmd->track = track;\n\traw_cmd->flags = (FD_RAW_WRITE | FD_RAW_INTR | FD_RAW_SPIN |\n\t\t\t  FD_RAW_NEED_DISK | FD_RAW_NEED_SEEK);\n\traw_cmd->rate = _floppy->rate & 0x43;\n\traw_cmd->cmd_count = NR_F;\n\tCOMMAND = FM_MODE(_floppy, FD_FORMAT);\n\tDR_SELECT = UNIT(current_drive) + PH_HEAD(_floppy, format_req.head);\n\tF_SIZECODE = FD_SIZECODE(_floppy);\n\tF_SECT_PER_TRACK = _floppy->sect << 2 >> F_SIZECODE;\n\tF_GAP = _floppy->fmt_gap;\n\tF_FILL = FD_FILL_BYTE;\n \traw_cmd->kernel_data = floppy_track_buffer;\n \traw_cmd->length = 4 * F_SECT_PER_TRACK;\n \thead_shift = (F_SECT_PER_TRACK + 5) / 6;\n\ttrack_shift = 2 * head_shift + 3;\n\tn = (track_shift * format_req.track + head_shift * format_req.head)\n\t    % F_SECT_PER_TRACK;\n\til = 1;\n\tif (_floppy->fmt_gap < 0x22)\n\t\til++;\n\tfor (count = 0; count < F_SECT_PER_TRACK; ++count) {\n\t\there[count].track = format_req.track;\n\t\there[count].head = format_req.head;\n\t\there[count].sect = 0;\n\t\there[count].size = F_SIZECODE;\n\t}\n\tfor (count = 1; count <= F_SECT_PER_TRACK; ++count) {\n\t\there[n].sect = count;\n\t\tn = (n + il) % F_SECT_PER_TRACK;\n\t\tif (here[n].sect) {\t\n\t\t\t++n;\n\t\t\tif (n >= F_SECT_PER_TRACK) {\n\t\t\t\tn -= F_SECT_PER_TRACK;\n\t\t\t\twhile (here[n].sect)\n\t\t\t\t\t++n;\n\t\t\t}\n\t\t}\n\t}\n\tif (_floppy->stretch & FD_SECTBASEMASK) {\n\t\tfor (count = 0; count < F_SECT_PER_TRACK; count++)\n\t\t\there[count].sect += FD_SECTBASE(_floppy) - 1;\n\t}\n}", "target": 1}
{"code": "static int originates_from_local_legacy_unicast_socket(AvahiServer *s, const AvahiAddress *address, uint16_t port) {\n    assert(s);\n    assert(address);\n    assert(port > 0);\n    if (!s->config.enable_reflector)\n        return 0;\n    if (!avahi_address_is_local(s->monitor, address))\n        return 0;\n    if (address->proto == AVAHI_PROTO_INET && s->fd_legacy_unicast_ipv4 >= 0) {\n        struct sockaddr_in lsa;\n        socklen_t l = sizeof(lsa);\n        if (getsockname(s->fd_legacy_unicast_ipv4, (struct sockaddr*) &lsa, &l) != 0)\n            avahi_log_warn(\"getsockname(): %s\", strerror(errno));\n        else\n            return lsa.sin_port == port;\n    }\n    if (address->proto == AVAHI_PROTO_INET6 && s->fd_legacy_unicast_ipv6 >= 0) {\n        struct sockaddr_in6 lsa;\n        socklen_t l = sizeof(lsa);\n        if (getsockname(s->fd_legacy_unicast_ipv6, (struct sockaddr*) &lsa, &l) != 0)\n            avahi_log_warn(\"getsockname(): %s\", strerror(errno));\n        else\n            return lsa.sin6_port == port;\n    }\n    return 0;\n}", "target": 1}
{"code": "writefile(const char *name, struct string *s)\n{\n\tFILE *f;\n\tint ret;\n\tf = fopen(name, \"w\");\n\tif (!f) {\n\t\twarn(\"open %s:\", name);\n\t\treturn -1;\n\t}\n\tret = 0;\n\tif (fwrite(s->s, 1, s->n, f) != s->n || fflush(f) != 0) {\n\t\twarn(\"write %s:\", name);\n\t\tret = -1;\n\t}\n\tfclose(f);\n\treturn ret;\n}", "target": 1}
{"code": "dhcpv6_print(netdissect_options *ndo,\n             const u_char *cp, u_int length, int indent)\n{\n    u_int i, t;\n    const u_char *tlv, *value;\n    uint16_t type, optlen;\n     i = 0;\n     while (i < length) {\n         tlv = cp + i;\n         type = EXTRACT_16BITS(tlv);\n         optlen = EXTRACT_16BITS(tlv + 2);\n        value = tlv + 4;\n        ND_PRINT((ndo, \"\\n\"));\n        for (t = indent; t > 0; t--)\n            ND_PRINT((ndo, \"\\t\"));\n         ND_PRINT((ndo, \"%s\", tok2str(dh6opt_str, \"Unknown\", type)));\n         ND_PRINT((ndo,\" (%u)\", optlen + 4 ));\n         switch (type) {\n             case DH6OPT_DNS_SERVERS:\n            case DH6OPT_SNTP_SERVERS: {\n                if (optlen % 16 != 0) {\n                    ND_PRINT((ndo, \" %s\", istr));\n                    return -1;\n                }\n                for (t = 0; t < optlen; t += 16)\n                    ND_PRINT((ndo, \" %s\", ip6addr_string(ndo, value + t)));\n            }\n                break;\n            case DH6OPT_DOMAIN_LIST: {\n                const u_char *tp = value;\n                while (tp < value + optlen) {\n                    ND_PRINT((ndo, \" \"));\n                    if ((tp = ns_nprint(ndo, tp, value + optlen)) == NULL)\n                        return -1;\n                }\n            }\n                break;\n        }\n        i += 4 + optlen;\n    }\n    return 0;\n}", "target": 1}
{"code": "static void handle_PORT(ctrl_t *ctrl, char *str)\n{\n\tint a, b, c, d, e, f;\n\tchar addr[INET_ADDRSTRLEN];\n\tstruct sockaddr_in sin;\n\tif (ctrl->data_sd > 0) {\n\t\tuev_io_stop(&ctrl->data_watcher);\n\t\tclose(ctrl->data_sd);\n\t\tctrl->data_sd = -1;\n\t}\n\tsscanf(str, \"%d,%d,%d,%d,%d,%d\", &a, &b, &c, &d, &e, &f);\n\tsprintf(addr, \"%d.%d.%d.%d\", a, b, c, d);\n\tif (!inet_aton(addr, &(sin.sin_addr))) {\n\t\tERR(0, \"Invalid address '%s' given to PORT command\", addr);\n\t\tsend_msg(ctrl->sd, \"500 Illegal PORT command.\\r\\n\");\n\t\treturn;\n\t}\n\tstrlcpy(ctrl->data_address, addr, sizeof(ctrl->data_address));\n\tctrl->data_port = e * 256 + f;\n\tDBG(\"Client PORT command accepted for %s:%d\", ctrl->data_address, ctrl->data_port);\n\tsend_msg(ctrl->sd, \"200 PORT command successful.\\r\\n\");\n}", "target": 1}
{"code": " static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)\n {\n    FILE *fp = fopen(dest_filename, \"w\");\n     if (!fp)\n         return false;\n    unsigned fd = 0;\n    while (fd <= 99999) \n    {\n        sprintf(source_filename + source_base_ofs, \"fd/%u\", fd);\n        char *name = malloc_readlink(source_filename);\n        if (!name)\n            break;\n        fprintf(fp, \"%u:%s\\n\", fd, name);\n        free(name);\n        sprintf(source_filename + source_base_ofs, \"fdinfo/%u\", fd);\n        fd++;\n        FILE *in = fopen(source_filename, \"r\");\n        if (!in)\n            continue;\n        char buf[128];\n        while (fgets(buf, sizeof(buf)-1, in))\n        {\n            char *eol = strchrnul(buf, '\\n');\n            eol[0] = '\\n';\n            eol[1] = '\\0';\n            fputs(buf, fp);\n        }\n        fclose(in);\n    }\n    const int dest_fd = fileno(fp);\n    if (fchown(dest_fd, uid, gid) < 0)\n    {\n        perror_msg(\"Can't change '%s' ownership to %lu:%lu\", dest_filename, (long)uid, (long)gid);\n        fclose(fp);\n        unlink(dest_filename);\n        return false;\n    }\n    fclose(fp);\n    return true;\n}", "target": 1}
{"code": "    int MemIo::seek(int64 offset, Position pos )\n    {\n        int64 newIdx = 0;\n        switch (pos) {\n            case BasicIo::cur:\n                newIdx = p_->idx_ + offset;\n                break;\n            case BasicIo::beg:\n                newIdx = offset;\n                break;\n            case BasicIo::end:\n                newIdx = p_->size_ + offset;\n                break;\n        }\n        if (newIdx < 0)\n            return 1;\n        p_->idx_ = static_cast<long>(newIdx);   \n        p_->eof_ = false;\n        return 0;\n    }", "target": 1}
{"code": "void gf_av1_reset_state(AV1State *state, Bool is_destroy)\n{\n\tGF_List *l1, *l2;\n\tif (state->frame_state.header_obus) {\n\t\twhile (gf_list_count(state->frame_state.header_obus)) {\n\t\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_pop_back(state->frame_state.header_obus);\n\t\t\tif (a->obu) gf_free(a->obu);\n\t\t\tgf_free(a);\n\t\t}\n\t}\n\tif (state->frame_state.frame_obus) {\n\t\twhile (gf_list_count(state->frame_state.frame_obus)) {\n\t\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_pop_back(state->frame_state.frame_obus);\n\t\t\tif (a->obu) gf_free(a->obu);\n\t\t\tgf_free(a);\n\t\t}\n\t}\n\tl1 = state->frame_state.frame_obus;\n\tl2 = state->frame_state.header_obus;\n\tmemset(&state->frame_state, 0, sizeof(AV1StateFrame));\n\tstate->frame_state.is_first_frame = GF_TRUE;\n\tif (is_destroy) {\n\t\tgf_list_del(l1);\n\t\tgf_list_del(l2);\n\t\tif (state->bs) {\n\t\t\tif (gf_bs_get_position(state->bs)) {\n\t\t\t\tu32 size;\n\t\t\t\tgf_bs_get_content_no_truncate(state->bs, &state->frame_obus, &size, &state->frame_obus_alloc);\n\t\t\t}\n\t\t\tgf_bs_del(state->bs);\n\t\t}\n\t\tstate->bs = NULL;\n\t}\n\telse {\n\t\tstate->frame_state.frame_obus = l1;\n\t\tstate->frame_state.header_obus = l2;\n\t\tif (state->bs)\n\t\t\tgf_bs_seek(state->bs, 0);\n\t}\n}", "target": 1}
{"code": "static void zend_throw_or_error(int fetch_type, zend_class_entry *exception_ce, const char *format, ...) \n{\n\tva_list va;\n\tchar *message = NULL;\n\tva_start(va, format);\n\tzend_vspprintf(&message, 0, format, va);\n\tif (fetch_type & ZEND_FETCH_CLASS_EXCEPTION) {\n\t\tzend_throw_error(exception_ce, message);\n\t} else {\n\t\tzend_error(E_ERROR, \"%s\", message);\n\t}\n\tefree(message);\n\tva_end(va);\n}", "target": 1}
{"code": "static CACHE_BITMAP_V3_ORDER* update_read_cache_bitmap_v3_order(rdpUpdate* update, wStream* s,\n                                                                UINT16 flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\tUINT32 new_len;\n\tBYTE* new_data;\n\tCACHE_BITMAP_V3_ORDER* cache_bitmap_v3;\n\tif (!update || !s)\n\t\treturn NULL;\n\tcache_bitmap_v3 = calloc(1, sizeof(CACHE_BITMAP_V3_ORDER));\n\tif (!cache_bitmap_v3)\n\t\tgoto fail;\n\tcache_bitmap_v3->cacheId = flags & 0x00000003;\n\tcache_bitmap_v3->flags = (flags & 0x0000FF80) >> 7;\n\tbitsPerPixelId = (flags & 0x00000078) >> 3;\n\tcache_bitmap_v3->bpp = CBR23_BPP[bitsPerPixelId];\n\tif (Stream_GetRemainingLength(s) < 21)\n\t\tgoto fail;\n\tStream_Read_UINT16(s, cache_bitmap_v3->cacheIndex); \n\tStream_Read_UINT32(s, cache_bitmap_v3->key1);       \n\tStream_Read_UINT32(s, cache_bitmap_v3->key2);       \n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tStream_Read_UINT8(s, bitmapData->bpp);\n\tif ((bitmapData->bpp < 1) || (bitmapData->bpp > 32))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"invalid bpp value %\" PRIu32 \"\", bitmapData->bpp);\n\t\tgoto fail;\n\t}\n\tStream_Seek_UINT8(s);                      \n\tStream_Seek_UINT8(s);                      \n\tStream_Read_UINT8(s, bitmapData->codecID); \n\tStream_Read_UINT16(s, bitmapData->width);  \n\tStream_Read_UINT16(s, bitmapData->height); \n\tStream_Read_UINT32(s, new_len);            \n\tif (Stream_GetRemainingLength(s) < new_len)\n\t\tgoto fail;\n\tnew_data = (BYTE*)realloc(bitmapData->data, new_len);\n\tif (!new_data)\n\t\tgoto fail;\n\tbitmapData->data = new_data;\n\tbitmapData->length = new_len;\n\tStream_Read(s, bitmapData->data, bitmapData->length);\n\treturn cache_bitmap_v3;\nfail:\n\tfree_cache_bitmap_v3_order(update->context, cache_bitmap_v3);\n\treturn NULL;\n}", "target": 1}
{"code": "static ssize_t lbs_debugfs_write(struct file *f, const char __user *buf,\n\t\t\t    size_t cnt, loff_t *ppos)\n{\n\tint r, i;\n\tchar *pdata;\n\tchar *p;\n\tchar *p0;\n\tchar *p1;\n \tchar *p2;\n \tstruct debug_data *d = f->private_data;\n\tpdata = kmalloc(cnt, GFP_KERNEL);\n \tif (pdata == NULL)\n \t\treturn 0;\n\tif (copy_from_user(pdata, buf, cnt)) {\n\t\tlbs_deb_debugfs(\"Copy from user failed\\n\");\n \t\tkfree(pdata);\n \t\treturn 0;\n \t}\n \tp0 = pdata;\n \tfor (i = 0; i < num_of_items; i++) {\n\t\tdo {\n\t\t\tp = strstr(p0, d[i].name);\n\t\t\tif (p == NULL)\n\t\t\t\tbreak;\n\t\t\tp1 = strchr(p, '\\n');\n\t\t\tif (p1 == NULL)\n\t\t\t\tbreak;\n\t\t\tp0 = p1++;\n\t\t\tp2 = strchr(p, '=');\n\t\t\tif (!p2)\n\t\t\t\tbreak;\n\t\t\tp2++;\n\t\t\tr = simple_strtoul(p2, NULL, 0);\n\t\t\tif (d[i].size == 1)\n\t\t\t\t*((u8 *) d[i].addr) = (u8) r;\n\t\t\telse if (d[i].size == 2)\n\t\t\t\t*((u16 *) d[i].addr) = (u16) r;\n\t\t\telse if (d[i].size == 4)\n\t\t\t\t*((u32 *) d[i].addr) = (u32) r;\n\t\t\telse if (d[i].size == 8)\n\t\t\t\t*((u64 *) d[i].addr) = (u64) r;\n\t\t\tbreak;\n\t\t} while (1);\n\t}\n\tkfree(pdata);\n\treturn (ssize_t)cnt;\n}", "target": 1}
{"code": "static int i2r_pci(X509V3_EXT_METHOD *method, PROXY_CERT_INFO_EXTENSION *pci,\n                   BIO *out, int indent)\n{\n    BIO_printf(out, \"%*sPath Length Constraint: \", indent, \"\");\n    if (pci->pcPathLengthConstraint)\n        i2a_ASN1_INTEGER(out, pci->pcPathLengthConstraint);\n    else\n        BIO_printf(out, \"infinite\");\n    BIO_puts(out, \"\\n\");\n    BIO_printf(out, \"%*sPolicy Language: \", indent, \"\");\n    i2a_ASN1_OBJECT(out, pci->proxyPolicy->policyLanguage);\n    BIO_puts(out, \"\\n\");\n    if (pci->proxyPolicy->policy && pci->proxyPolicy->policy->data)\n        BIO_printf(out, \"%*sPolicy Text: %s\\n\", indent, \"\",\n                   pci->proxyPolicy->policy->data);\n    return 1;\n}", "target": 1}
{"code": "Status GetDeviceForInput(const EagerOperation& op, const EagerContext& ctx,\n                         TensorHandle* tensor_handle, Device** result) {\n  Device* cpu_device = ctx.HostCPU();\n  string device_name;\n  if (tensor_handle->Type() != TensorHandle::LOCAL) {\n    Device* device = tensor_handle->device();\n    device_name = device != nullptr ? device->name() : cpu_device->name();\n    *result = (device == nullptr ? cpu_device : device);\n  } else if (tensor_handle->dtype == DT_RESOURCE) {\n    const Tensor* tensor;\n    TF_RETURN_IF_ERROR(tensor_handle->Tensor(&tensor));\n    const ResourceHandle& handle = tensor->flat<ResourceHandle>()(0);\n    device_name = handle.device();\n    Device* input_device;\n    TF_RETURN_IF_ERROR(\n        ctx.FindDeviceFromName(device_name.c_str(), &input_device));\n    *result = input_device;\n  } else {\n    Device* device = tensor_handle->device();\n    const bool is_tpu = device != nullptr && device->device_type() == \"TPU\";\n    const bool use_host_memory =\n        is_tpu ? MTypeFromDTypeIntsOnDevice(tensor_handle->dtype)\n               : MTypeFromDType(tensor_handle->dtype);\n    if (use_host_memory) {\n      *result = cpu_device;\n    } else {\n      if (!op.is_function() && device != nullptr && device != cpu_device) {\n        device = absl::get<Device*>(op.Device());\n      }\n      *result = (device == nullptr ? cpu_device : device);\n    }\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "fb_mmap(struct file *file, struct vm_area_struct * vma)\n {\n \tstruct fb_info *info = file_fb_info(file);\n \tstruct fb_ops *fb;\n\tunsigned long off;\n \tunsigned long start;\n \tu32 len;\n \tif (!info)\n \t\treturn -ENODEV;\n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))\n\t\treturn -EINVAL;\n\toff = vma->vm_pgoff << PAGE_SHIFT;\n \tfb = info->fbops;\n \tif (!fb)\n \t\treturn -ENODEV;\n\tmutex_lock(&info->mm_lock);\n\tif (fb->fb_mmap) {\n\t\tint res;\n\t\tres = fb->fb_mmap(info, vma);\n\t\tmutex_unlock(&info->mm_lock);\n \t\treturn res;\n \t}\n \tstart = info->fix.smem_start;\n\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.smem_len);\n\tif (off >= len) {\n\t\toff -= len;\n\t\tif (info->var.accel_flags) {\n\t\t\tmutex_unlock(&info->mm_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n \t\tstart = info->fix.mmio_start;\n\t\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.mmio_len);\n \t}\n \tmutex_unlock(&info->mm_lock);\n\tstart &= PAGE_MASK;\n\tif ((vma->vm_end - vma->vm_start + off) > len)\n\t\treturn -EINVAL;\n\toff += start;\n\tvma->vm_pgoff = off >> PAGE_SHIFT;\n \tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\tfb_pgprotect(file, vma, off);\n\tif (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n\t\t\t     vma->vm_end - vma->vm_start, vma->vm_page_prot))\n\t\treturn -EAGAIN;\n\treturn 0;\n }", "target": 1}
{"code": "bool TradQT_Manager::ParseCachedBoxes ( const MOOV_Manager & moovMgr )\n{\n\tMOOV_Manager::BoxInfo udtaInfo;\n\tMOOV_Manager::BoxRef  udtaRef = moovMgr.GetBox ( \"moov/udta\", &udtaInfo );\n\tif ( udtaRef == 0 ) return false;\n\tfor ( XMP_Uns32 i = 0; i < udtaInfo.childCount; ++i ) {\n\t\tMOOV_Manager::BoxInfo currInfo;\n\t\tMOOV_Manager::BoxRef  currRef = moovMgr.GetNthChild ( udtaRef, i, &currInfo );\n\t\tif ( currRef == 0 ) break;\t\n\t\tif ( (currInfo.boxType >> 24) != 0xA9 ) continue;\n\t\tif ( currInfo.contentSize < 2+2+1 ) continue;\t\n\t\tInfoMapPos newInfo = this->parsedBoxes.insert ( this->parsedBoxes.end(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tInfoMap::value_type ( currInfo.boxType, ParsedBoxInfo ( currInfo.boxType ) ) );\n\t\tstd::vector<ValueInfo> * newValues = &newInfo->second.values;\n\t\tXMP_Uns8 * boxPtr = (XMP_Uns8*) currInfo.content;\n\t\tXMP_Uns8 * boxEnd = boxPtr + currInfo.contentSize;\n\t\tXMP_Uns16 miniLen, macLang;\n\t\tfor ( ; boxPtr < boxEnd-4; boxPtr += miniLen ) {\n \t\t\tminiLen = 4 + GetUns16BE ( boxPtr );\t\n \t\t\tmacLang  = GetUns16BE ( boxPtr+2);\n\t\t\tif ( (miniLen <= 4) || (miniLen > (boxEnd - boxPtr)) ) continue;\t\n \t\t\tXMP_StringPtr valuePtr = (char*)(boxPtr+4);\n \t\t\tsize_t valueLen = miniLen - 4;\n\t\t\tnewValues->push_back ( ValueInfo() );\n\t\t\tValueInfo * newValue = &newValues->back();\n\t\t\tnewValue->macLang = macLang;\n\t\t\tif ( IsMacLangKnown ( macLang ) ) newValue->xmpLang = GetXMPLang ( macLang );\n\t\t\tnewValue->macValue.assign ( valuePtr, valueLen );\n\t\t}\n\t}\n\treturn (! this->parsedBoxes.empty());\n}\t", "target": 1}
{"code": "polkit_system_bus_name_get_creds_sync (PolkitSystemBusName           *system_bus_name,\n\t\t\t\t       guint32                       *out_uid,\n\t\t\t\t       guint32                       *out_pid,\n\t\t\t\t       GCancellable                  *cancellable,\n\t\t\t\t       GError                       **error)\n{\n  gboolean ret = FALSE;\n  AsyncGetBusNameCredsData data = { 0, };\n  GDBusConnection *connection = NULL;\n  GMainContext *tmp_context = NULL;\n  connection = g_bus_get_sync (G_BUS_TYPE_SYSTEM, cancellable, error);\n  if (connection == NULL)\n    goto out;\n  data.error = error;\n  tmp_context = g_main_context_new ();\n  g_main_context_push_thread_default (tmp_context);\n  g_dbus_connection_call (connection,\n\t\t\t  \"org.freedesktop.DBus\",       \n\t\t\t  \"/org/freedesktop/DBus\",      \n\t\t\t  \"org.freedesktop.DBus\",       \n\t\t\t  \"GetConnectionUnixUser\",      \n\t\t\t  g_variant_new (\"(s)\", system_bus_name->name),\n\t\t\t  G_VARIANT_TYPE (\"(u)\"),\n\t\t\t  G_DBUS_CALL_FLAGS_NONE,\n\t\t\t  -1,\n\t\t\t  cancellable,\n\t\t\t  on_retrieved_unix_uid_pid,\n\t\t\t  &data);\n  g_dbus_connection_call (connection,\n\t\t\t  \"org.freedesktop.DBus\",       \n\t\t\t  \"/org/freedesktop/DBus\",      \n\t\t\t  \"org.freedesktop.DBus\",       \n\t\t\t  \"GetConnectionUnixProcessID\", \n\t\t\t  g_variant_new (\"(s)\", system_bus_name->name),\n\t\t\t  G_VARIANT_TYPE (\"(u)\"),\n\t\t\t  G_DBUS_CALL_FLAGS_NONE,\n\t\t\t  -1,\n\t\t\t  cancellable,\n\t\t\t  on_retrieved_unix_uid_pid,\n\t\t\t  &data);\n  while (!((data.retrieved_uid && data.retrieved_pid) || data.caught_error))\n    g_main_context_iteration (tmp_context, TRUE);\n  if (out_uid)\n    *out_uid = data.uid;\n  if (out_pid)\n    *out_pid = data.pid;\n  ret = TRUE;\n out:\n  if (tmp_context)\n    {\n      g_main_context_pop_thread_default (tmp_context);\n      g_main_context_unref (tmp_context);\n    }\n  if (connection != NULL)\n    g_object_unref (connection);\n  return ret;\n}", "target": 1}
{"code": "  static void  Ins_MDRP( INS_ARG )\n  {\n    Int         point;\n    TT_F26Dot6  distance,\n                org_dist;\n     point = (Int)args[0];\n    if ( BOUNDS( args[0], CUR.zp1.n_points ) )\n     {\n    org_dist = CUR_Func_dualproj( CUR.zp1.org_x[point] -\n                                    CUR.zp0.org_x[CUR.GS.rp0],\n                                  CUR.zp1.org_y[point] -\n                                    CUR.zp0.org_y[CUR.GS.rp0] );\n    if ( ABS(org_dist) < CUR.GS.single_width_cutin )\n    {\n      if ( org_dist >= 0 )\n        org_dist = CUR.GS.single_width_value;\n      else\n        org_dist = -CUR.GS.single_width_value;\n    }\n    if ( (CUR.opcode & 4) != 0 )\n      distance = CUR_Func_round( org_dist,\n                                 CUR.metrics.compensations[CUR.opcode & 3] );\n    else\n      distance = Round_None( EXEC_ARGS\n                             org_dist,\n                             CUR.metrics.compensations[CUR.opcode & 3]  );\n    if ( (CUR.opcode & 8) != 0 )\n    {\n      if ( org_dist >= 0 )\n      {\n        if ( distance < CUR.GS.minimum_distance )\n          distance = CUR.GS.minimum_distance;\n      }\n      else\n      {\n        if ( distance > -CUR.GS.minimum_distance )\n          distance = -CUR.GS.minimum_distance;\n      }\n    }\n    org_dist = CUR_Func_project( CUR.zp1.cur_x[point] -\n                                   CUR.zp0.cur_x[CUR.GS.rp0],\n                                 CUR.zp1.cur_y[point] -\n                                   CUR.zp0.cur_y[CUR.GS.rp0] );\n    CUR_Func_move( &CUR.zp1, point, distance - org_dist );\n    CUR.GS.rp1 = CUR.GS.rp0;\n    CUR.GS.rp2 = point;\n    if ( (CUR.opcode & 16) != 0 )\n      CUR.GS.rp0 = point;\n  }", "target": 1}
{"code": "static int phar_tar_process_metadata(phar_entry_info *entry, php_stream *fp TSRMLS_DC) \n{\n\tchar *metadata;\n\tsize_t save = php_stream_tell(fp), read;\n\tphar_entry_info *mentry;\n\tmetadata = (char *) emalloc(entry->uncompressed_filesize + 1);\n\tread = php_stream_read(fp, metadata, entry->uncompressed_filesize);\n\tif (read != entry->uncompressed_filesize) {\n\t\tefree(metadata);\n\t\tphp_stream_seek(fp, save, SEEK_SET);\n\t\treturn FAILURE;\n\t}\n\tif (phar_parse_metadata(&metadata, &entry->metadata, entry->uncompressed_filesize TSRMLS_CC) == FAILURE) {\n\t\tefree(metadata);\n\t\tphp_stream_seek(fp, save, SEEK_SET);\n\t\treturn FAILURE;\n\t}\n\tif (entry->filename_len == sizeof(\".phar/.metadata.bin\")-1 && !memcmp(entry->filename, \".phar/.metadata.bin\", sizeof(\".phar/.metadata.bin\")-1)) {\n\t\tentry->phar->metadata = entry->metadata;\n\t\tentry->metadata = NULL;\n\t} else if (entry->filename_len >= sizeof(\".phar/.metadata/\") + sizeof(\"/.metadata.bin\") - 1 && SUCCESS == zend_hash_find(&(entry->phar->manifest), entry->filename + sizeof(\".phar/.metadata/\") - 1, entry->filename_len - (sizeof(\"/.metadata.bin\") - 1 + sizeof(\".phar/.metadata/\") - 1), (void *)&mentry)) {\n\t\tmentry->metadata = entry->metadata;\n\t\tentry->metadata = NULL;\n\t}\n\tefree(metadata);\n\tphp_stream_seek(fp, save, SEEK_SET);\n\treturn SUCCESS;\n}", "target": 1}
{"code": "brcmf_wowl_nd_results(struct brcmf_if *ifp, const struct brcmf_event_msg *e,\n\t\t      void *data)\n{\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\tstruct wiphy *wiphy = cfg_to_wiphy(cfg);\n\tstruct brcmf_pno_scanresults_le *pfn_result;\n\tstruct brcmf_pno_net_info_le *netinfo;\n\tbrcmf_dbg(SCAN, \"Enter\\n\");\n\tif (e->datalen < (sizeof(*pfn_result) + sizeof(*netinfo))) {\n\t\tbrcmf_dbg(SCAN, \"Event data to small. Ignore\\n\");\n\t\treturn 0;\n\t}\n\tpfn_result = (struct brcmf_pno_scanresults_le *)data;\n\tif (e->event_code == BRCMF_E_PFN_NET_LOST) {\n\t\tbrcmf_dbg(SCAN, \"PFN NET LOST event. Ignore\\n\");\n\t\treturn 0;\n\t}\n\tif (le32_to_cpu(pfn_result->count) < 1) {\n\t\tbphy_err(wiphy, \"Invalid result count, expected 1 (%d)\\n\",\n\t\t\t le32_to_cpu(pfn_result->count));\n\t\treturn -EINVAL;\n\t}\n\tnetinfo = brcmf_get_netinfo_array(pfn_result);\n\tmemcpy(cfg->wowl.nd->ssid.ssid, netinfo->SSID, netinfo->SSID_len);\n\tcfg->wowl.nd->ssid.ssid_len = netinfo->SSID_len;\n\tcfg->wowl.nd->n_channels = 1;\n\tcfg->wowl.nd->channels[0] =\n\t\tieee80211_channel_to_frequency(netinfo->channel,\n\t\t\tnetinfo->channel <= CH_MAX_2G_CHANNEL ?\n\t\t\t\t\tNL80211_BAND_2GHZ : NL80211_BAND_5GHZ);\n\tcfg->wowl.nd_info->n_matches = 1;\n\tcfg->wowl.nd_info->matches[0] = cfg->wowl.nd;\n\tcfg->wowl.nd_data_completed = true;\n\twake_up(&cfg->wowl.nd_data_wait);\n\treturn 0;\n}", "target": 1}
{"code": "static void close_all_connections(struct Curl_multi *multi)\n{\n  struct connectdata *conn;\n  conn = Curl_conncache_find_first_connection(&multi->conn_cache);\n  while(conn) {\n    SIGPIPE_VARIABLE(pipe_st);\n    conn->data = multi->closure_handle;\n    sigpipe_ignore(conn->data, &pipe_st);\n    (void)Curl_disconnect(conn, FALSE);\n    sigpipe_restore(&pipe_st);\n    conn = Curl_conncache_find_first_connection(&multi->conn_cache);\n  }\n}", "target": 1}
{"code": " static void mpeg4_encode_gop_header(MpegEncContext *s)\n {\n    int hours, minutes, seconds;\n     int64_t time;\n     put_bits(&s->pb, 16, 0);\n    put_bits(&s->pb, 16, GOP_STARTCODE);\n    time = s->current_picture_ptr->f->pts;\n    if (s->reordered_input_picture[1])\n        time = FFMIN(time, s->reordered_input_picture[1]->f->pts);\n    time = time * s->avctx->time_base.num;\n    s->last_time_base = FFUDIV(time, s->avctx->time_base.den);\n    seconds = FFUDIV(time, s->avctx->time_base.den);\n    minutes = FFUDIV(seconds, 60); seconds = FFUMOD(seconds, 60);\n    hours   = FFUDIV(minutes, 60); minutes = FFUMOD(minutes, 60);\n    hours   = FFUMOD(hours  , 24);\n    put_bits(&s->pb, 5, hours);\n    put_bits(&s->pb, 6, minutes);\n    put_bits(&s->pb, 1, 1);\n    put_bits(&s->pb, 6, seconds);\n    put_bits(&s->pb, 1, !!(s->avctx->flags & AV_CODEC_FLAG_CLOSED_GOP));\n    put_bits(&s->pb, 1, 0);  \n    ff_mpeg4_stuffing(&s->pb);\n}", "target": 1}
{"code": "repodata_schema2id(Repodata *data, Id *schema, int create)\n{\n  int h, len, i;\n  Id *sp, cid;\n  Id *schematahash;\n  if (!*schema)\n    return 0;\t\n  if ((schematahash = data->schematahash) == 0)\n    {\n      data->schematahash = schematahash = solv_calloc(256, sizeof(Id));\n      for (i = 1; i < data->nschemata; i++)\n\t{\n\t  for (sp = data->schemadata + data->schemata[i], h = 0; *sp;)\n\t    h = h * 7 + *sp++;\n\t  h &= 255;\n\t  schematahash[h] = i;\n\t}\n      data->schemadata = solv_extend_resize(data->schemadata, data->schemadatalen, sizeof(Id), SCHEMATADATA_BLOCK);\n      data->schemata = solv_extend_resize(data->schemata, data->nschemata, sizeof(Id), SCHEMATA_BLOCK);\n    }\n  for (sp = schema, len = 0, h = 0; *sp; len++)\n    h = h * 7 + *sp++;\n  h &= 255;\n  len++;\n  cid = schematahash[h];\n  if (cid)\n    {\n      if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n        return cid;\n      for (cid = 1; cid < data->nschemata; cid++)\n        if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n          return cid;\n    }\n  if (!create)\n    return 0;\n  data->schemadata = solv_extend(data->schemadata, data->schemadatalen, len, sizeof(Id), SCHEMATADATA_BLOCK);\n  data->schemata = solv_extend(data->schemata, data->nschemata, 1, sizeof(Id), SCHEMATA_BLOCK);\n  memcpy(data->schemadata + data->schemadatalen, schema, len * sizeof(Id));\n  data->schemata[data->nschemata] = data->schemadatalen;\n  data->schemadatalen += len;\n  schematahash[h] = data->nschemata;\n#if 0\nfprintf(stderr, \"schema2id: new schema\\n\");\n#endif\n  return data->nschemata++;\n}", "target": 1}
{"code": "void dtls1_reset_seq_numbers(SSL *s, int rw)\n{\n    unsigned char *seq;\n    unsigned int seq_bytes = sizeof(s->s3->read_sequence);\n    if (rw & SSL3_CC_READ) {\n        seq = s->s3->read_sequence;\n        s->d1->r_epoch++;\n        memcpy(&(s->d1->bitmap), &(s->d1->next_bitmap), sizeof(DTLS1_BITMAP));\n        memset(&(s->d1->next_bitmap), 0x00, sizeof(DTLS1_BITMAP));\n    } else {\n        seq = s->s3->write_sequence;\n        memcpy(s->d1->last_write_sequence, seq,\n               sizeof(s->s3->write_sequence));\n        s->d1->w_epoch++;\n    }\n    memset(seq, 0x00, seq_bytes);\n}", "target": 1}
{"code": "http_isfiltered(const struct http *fm, unsigned u, unsigned how)\n{\n\tconst char *e;\n\tconst struct http_hdrflg *f;\n\tif (fm->hdf[u] & HDF_FILTER)\n\t\treturn (1);\n\te = strchr(fm->hd[u].b, ':');\n\tif (e == NULL)\n\t\treturn (0);\n\tf = http_hdr_flags(fm->hd[u].b, e);\n\treturn (f != NULL && f->flag & how);\n}", "target": 1}
{"code": "search_impl(i_ctx_t *i_ctx_p, bool forward)\n{\n    os_ptr op = osp;\n    os_ptr op1 = op - 1;\n    uint size = r_size(op);\n    uint count;\n    byte *pat;\n    byte *ptr;\n    byte ch;\n    int incr = forward ? 1 : -1;\n    check_read_type(*op1, t_string);\n    check_read_type(*op, t_string);\n    if (size > r_size(op1)) {\t\n        make_false(op);\n        return 0;\n    }\n    count = r_size(op1) - size;\n    ptr = op1->value.bytes;\n    if (size == 0)\n        goto found;\n    if (!forward)\n        ptr += count;\n    pat = op->value.bytes;\n    ch = pat[0];\n    do {\n        if (*ptr == ch && (size == 1 || !memcmp(ptr, pat, size)))\n            goto found;\n        ptr += incr;\n    }\n    while (count--);\n    make_false(op);\n    return 0;\nfound:\n    op->tas.type_attrs = op1->tas.type_attrs;\n    op->value.bytes = ptr;\n    r_set_size(op, size);\n    push(2);\n    op[-1] = *op1;\n    r_set_size(op - 1, ptr - op[-1].value.bytes);\n    op1->value.bytes = ptr + size;\n    r_set_size(op1, count + (!forward ? (size - 1) : 0));\n    make_true(op);\n    return 0;\n}", "target": 1}
{"code": "UnicodeString DecimalQuantity::toScientificString() const {\n    U_ASSERT(!isApproximate);\n    UnicodeString result;\n    if (isNegative()) {\n        result.append(u'-');\n    }\n    if (precision == 0) {\n        result.append(u\"0E+0\", -1);\n        return result;\n    }\n    int32_t upperPos = std::min(precision + scale, lOptPos) - scale - 1;\n    int32_t lowerPos = std::max(scale, rOptPos) - scale;\n    int32_t p = upperPos;\n    result.append(u'0' + getDigitPos(p));\n    if ((--p) >= lowerPos) {\n        result.append(u'.');\n        for (; p >= lowerPos; p--) {\n            result.append(u'0' + getDigitPos(p));\n        }\n    }\n    result.append(u'E');\n    int32_t _scale = upperPos + scale;\n    if (_scale < 0) {\n        _scale *= -1;\n        result.append(u'-');\n    } else {\n        result.append(u'+');\n    }\n    if (_scale == 0) {\n        result.append(u'0');\n    }\n    int32_t insertIndex = result.length();\n    while (_scale > 0) {\n        std::div_t res = std::div(_scale, 10);\n        result.insert(insertIndex, u'0' + res.rem);\n        _scale = res.quot;\n    }\n    return result;\n}", "target": 1}
{"code": "    void PsdImage::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \"Exiv2::PsdImage::readMetadata: Reading Photoshop file \" << io_->path() << \"\\n\";\n#endif\n        if (io_->open() != 0)\n        {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        if (!isPsdType(*io_, false))\n        {\n            if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        clearMetadata();\n        byte buf[26];\n        if (io_->read(buf, 26) != 26)\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        pixelWidth_ = getLong(buf + 18, bigEndian);\n        pixelHeight_ = getLong(buf + 14, bigEndian);\n        if (io_->read(buf, 4) != 4)\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        uint32_t colorDataLength = getULong(buf, bigEndian);\n        if (io_->seek(colorDataLength, BasicIo::cur))\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        if (io_->read(buf, 4) != 4)\n        {\n            throw Error(kerNotAnImage, \"Photoshop\");\n        }\n        uint32_t resourcesLength = getULong(buf, bigEndian);\n        while (resourcesLength > 0)\n        {\n            if (io_->read(buf, 8) != 8)\n            {\n                throw Error(kerNotAnImage, \"Photoshop\");\n            }\n            if (!Photoshop::isIrb(buf, 4))\n            {\n                break; \n            }\n            uint16_t resourceId = getUShort(buf + 4, bigEndian);\n            uint32_t resourceNameLength = buf[6] & ~1;\n            io_->seek(resourceNameLength, BasicIo::cur);\n            if (io_->read(buf, 4) != 4)\n            {\n                throw Error(kerNotAnImage, \"Photoshop\");\n            }\n            uint32_t resourceSize = getULong(buf, bigEndian);\n            uint32_t curOffset = io_->tell();\n#ifdef DEBUG\n        std::cerr << std::hex << \"resourceId: \" << resourceId << std::dec << \" length: \" << resourceSize << std::hex << \"\\n\";\n#endif\n            readResourceBlock(resourceId, resourceSize);\n            resourceSize = (resourceSize + 1) & ~1;        \n            io_->seek(curOffset + resourceSize, BasicIo::beg);\n            resourcesLength -= (12 + resourceNameLength + resourceSize);\n        }\n    } ", "target": 1}
{"code": "static int io_rw_init_file(struct io_kiocb *req, fmode_t mode)\n{\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct file *file = req->file;\n\tint ret;\n\tif (unlikely(!file || !(file->f_mode & mode)))\n\t\treturn -EBADF;\n\tif (!io_req_ffs_set(req))\n\t\treq->flags |= io_file_get_flags(file) << REQ_F_SUPPORT_NOWAIT_BIT;\n\tkiocb->ki_flags = iocb_flags(file);\n\tret = kiocb_set_rw_flags(kiocb, req->rw.flags);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tif ((kiocb->ki_flags & IOCB_NOWAIT) ||\n\t    ((file->f_flags & O_NONBLOCK) && !io_file_supports_nowait(req)))\n\t\treq->flags |= REQ_F_NOWAIT;\n\tif (ctx->flags & IORING_SETUP_IOPOLL) {\n\t\tif (!(kiocb->ki_flags & IOCB_DIRECT) || !file->f_op->iopoll)\n\t\t\treturn -EOPNOTSUPP;\n\t\tkiocb->ki_flags |= IOCB_HIPRI | IOCB_ALLOC_CACHE;\n\t\tkiocb->ki_complete = io_complete_rw_iopoll;\n\t\treq->iopoll_completed = 0;\n\t} else {\n\t\tif (kiocb->ki_flags & IOCB_HIPRI)\n\t\t\treturn -EINVAL;\n\t\tkiocb->ki_complete = io_complete_rw;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "soup_ntlm_parse_challenge (const char *challenge,\n\t\t\t   char      **nonce,\n\t\t\t   char      **default_domain,\n\t\t\t   gboolean   *ntlmv2_session)\n{\n\tgsize clen;\n\tNTLMString domain;\n\tguchar *chall;\n\tguint32 flags;\n\tchall = g_base64_decode (challenge, &clen);\n\tif (clen < NTLM_CHALLENGE_DOMAIN_STRING_OFFSET ||\n\t    clen < NTLM_CHALLENGE_NONCE_OFFSET + NTLM_CHALLENGE_NONCE_LENGTH) {\n\t\tg_free (chall);\n\t\treturn FALSE;\n\t}\n\tmemcpy (&flags, chall + NTLM_CHALLENGE_FLAGS_OFFSET, sizeof(flags));\n\tflags = GUINT_FROM_LE (flags);\n\t*ntlmv2_session = (flags & NTLM_FLAGS_NEGOTIATE_NTLMV2) ? TRUE : FALSE;\n\tif (default_domain) {\n\t\tmemcpy (&domain, chall + NTLM_CHALLENGE_DOMAIN_STRING_OFFSET, sizeof (domain));\n\t\tdomain.length = GUINT16_FROM_LE (domain.length);\n\t\tdomain.offset = GUINT16_FROM_LE (domain.offset);\n\t\tif (clen < domain.length + domain.offset) {\n\t\t\tg_free (chall);\n\t\t\treturn FALSE;\n\t\t}\n\t\t*default_domain = g_convert ((char *)chall + domain.offset,\n\t\t\t\t\t     domain.length, \"UTF-8\", \"UCS-2LE\",\n\t\t\t\t\t     NULL, NULL, NULL);\n\t}\n\tif (nonce) {\n\t\t*nonce = g_memdup (chall + NTLM_CHALLENGE_NONCE_OFFSET,\n\t\t\t\t   NTLM_CHALLENGE_NONCE_LENGTH);\n\t}\n\tg_free (chall);\n\treturn TRUE;\n}", "target": 1}
{"code": "void LanLinkProvider::dataReceived()\n{\n    QSslSocket* socket = qobject_cast<QSslSocket*>(sender());\n#if QT_VERSION < QT_VERSION_CHECK(5,7,0)\n    if (!socket->canReadLine())\n        return;\n#else\n    socket->startTransaction();\n#endif\n    const QByteArray data = socket->readLine();\n    qCDebug(KDECONNECT_CORE) << \"LanLinkProvider received reply:\" << data;\n    NetworkPacket* np = new NetworkPacket(QLatin1String(\"\"));\n    bool success = NetworkPacket::unserialize(data, np);\n#if QT_VERSION < QT_VERSION_CHECK(5,7,0)\n    if (!success) {\n        delete np;\n        return;\n    }\n#else\n    if (!success) {\n        delete np;\n        socket->rollbackTransaction();\n        return;\n    }\n    socket->commitTransaction();\n#endif\n    if (np->type() != PACKET_TYPE_IDENTITY) {\n        qCWarning(KDECONNECT_CORE) << \"LanLinkProvider/newConnection: Expected identity, received \" << np->type();\n        delete np;\n        return;\n    }\n    m_receivedIdentityPackets[socket].np = np;\n    const QString& deviceId = np->get<QString>(QStringLiteral(\"deviceId\"));\n    disconnect(socket, &QIODevice::readyRead, this, &LanLinkProvider::dataReceived);\n    if (np->get<int>(QStringLiteral(\"protocolVersion\")) >= MIN_VERSION_WITH_SSL_SUPPORT) {\n        bool isDeviceTrusted = KdeConnectConfig::instance().trustedDevices().contains(deviceId);\n        configureSslSocket(socket, deviceId, isDeviceTrusted);\n        qCDebug(KDECONNECT_CORE) << \"Starting client ssl (but I'm the server TCP socket)\";\n        connect(socket, &QSslSocket::encrypted, this, &LanLinkProvider::encrypted);\n        if (isDeviceTrusted) {\n            connect(socket, QOverload<const QList<QSslError> &>::of(&QSslSocket::sslErrors), this, &LanLinkProvider::sslErrors);\n        }\n        socket->startClientEncryption();\n    } else {\n        qWarning() << np->get<QString>(QStringLiteral(\"deviceName\")) << \"uses an old protocol version, this won't work\";\n        delete m_receivedIdentityPackets.take(socket).np;\n    }\n}", "target": 1}
{"code": "static void *etm_setup_aux(int event_cpu, void **pages,\n\t\t\t   int nr_pages, bool overwrite)\n{\n\tint cpu;\n\tcpumask_t *mask;\n\tstruct coresight_device *sink;\n\tstruct etm_event_data *event_data = NULL;\n\tevent_data = alloc_event_data(event_cpu);\n\tif (!event_data)\n\t\treturn NULL;\n\tsink = coresight_get_enabled_sink(true);\n\tif (!sink)\n\t\tgoto err;\n\tINIT_WORK(&event_data->work, free_event_data);\n\tmask = &event_data->mask;\n\tfor_each_cpu(cpu, mask) {\n\t\tstruct coresight_device *csdev;\n\t\tcsdev = per_cpu(csdev_src, cpu);\n\t\tif (!csdev)\n\t\t\tgoto err;\n\t\tevent_data->path[cpu] = coresight_build_path(csdev, sink);\n\t\tif (IS_ERR(event_data->path[cpu]))\n\t\t\tgoto err;\n\t}\n \tif (!sink_ops(sink)->alloc_buffer)\n \t\tgoto err;\n \tevent_data->snk_config =\n \t\t\tsink_ops(sink)->alloc_buffer(sink, cpu, pages,\n\t\t\t\t\t\t     nr_pages, overwrite);\n\tif (!event_data->snk_config)\n\t\tgoto err;\nout:\n\treturn event_data;\nerr:\n\tetm_free_aux(event_data);\n\tevent_data = NULL;\n\tgoto out;\n}", "target": 1}
{"code": "TfLiteStatus ResizeOutputTensor(TfLiteContext* context,\n                                SpaceToBatchNDContext* op_context) {\n  TfLiteIntArray* input_size = op_context->input->dims;\n  const int32* block_shape = GetTensorData<int32>(op_context->block_shape);\n  const int32* paddings_data = GetTensorData<int32>(op_context->paddings);\n  int spatial_dims_num = input_size->size - 2;\n  TF_LITE_ENSURE_EQ(context, NumDimensions(op_context->block_shape), 1);\n  TF_LITE_ENSURE_EQ(context, op_context->block_shape->dims->data[0],\n                    spatial_dims_num);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(op_context->paddings), 2);\n  TF_LITE_ENSURE_EQ(context, op_context->paddings->dims->data[0],\n                    spatial_dims_num);\n  TF_LITE_ENSURE_EQ(context, op_context->paddings->dims->data[1], 2);\n  TfLiteIntArray* output_size = TfLiteIntArrayCopy(input_size);\n  int output_batch_size = input_size->data[0];\n  for (int dim = 0; dim < spatial_dims_num; ++dim) {\n    int final_dim_size = (input_size->data[dim + 1] + paddings_data[dim * 2] +\n                          paddings_data[dim * 2 + 1]);\n    TF_LITE_ENSURE_EQ(context, final_dim_size % block_shape[dim], 0);\n    output_size->data[dim + 1] = final_dim_size / block_shape[dim];\n    output_batch_size *= block_shape[dim];\n  }\n  output_size->data[0] = output_batch_size;\n  output_size->data[input_size->size - 1] =\n      input_size->data[input_size->size - 1];\n  return context->ResizeTensor(context, op_context->output, output_size);\n}", "target": 1}
{"code": "void show_opcodes(u8 *rip, const char *loglvl)\n{\n#define PROLOGUE_SIZE 42\n#define EPILOGUE_SIZE 21\n#define OPCODE_BUFSIZE (PROLOGUE_SIZE + 1 + EPILOGUE_SIZE)\n\tu8 opcodes[OPCODE_BUFSIZE];\n\tif (probe_kernel_read(opcodes, rip - PROLOGUE_SIZE, OPCODE_BUFSIZE)) {\n\t\tprintk(\"%sCode: Bad RIP value.\\n\", loglvl);\n\t} else {\n\t\tprintk(\"%sCode: %\" __stringify(PROLOGUE_SIZE) \"ph <%02x> %\"\n\t\t       __stringify(EPILOGUE_SIZE) \"ph\\n\", loglvl, opcodes,\n\t\t       opcodes[PROLOGUE_SIZE], opcodes + PROLOGUE_SIZE + 1);\n\t}\n}", "target": 1}
{"code": "get_matching_model_microcode(int cpu, unsigned long start,\n\t\t\t     void *data, size_t size,\n\t\t\t     struct mc_saved_data *mc_saved_data,\n\t\t\t     unsigned long *mc_saved_in_initrd,\n\t\t\t     struct ucode_cpu_info *uci)\n{\n\tu8 *ucode_ptr = data;\n\tunsigned int leftover = size;\n\tenum ucode_state state = UCODE_OK;\n\tunsigned int mc_size;\n\tstruct microcode_header_intel *mc_header;\n\tstruct microcode_intel *mc_saved_tmp[MAX_UCODE_COUNT];\n \tunsigned int mc_saved_count = mc_saved_data->mc_saved_count;\n \tint i;\n\twhile (leftover) {\n \t\tmc_header = (struct microcode_header_intel *)ucode_ptr;\n \t\tmc_size = get_totalsize(mc_header);\n\t\tif (!mc_size || mc_size > leftover ||\n\t\t\tmicrocode_sanity_check(ucode_ptr, 0) < 0)\n\t\t\tbreak;\n\t\tleftover -= mc_size;\n\t\tif (matching_model_microcode(mc_header, uci->cpu_sig.sig) !=\n\t\t\t UCODE_OK) {\n\t\t\tucode_ptr += mc_size;\n\t\t\tcontinue;\n\t\t}\n\t\t_save_mc(mc_saved_tmp, ucode_ptr, &mc_saved_count);\n\t\tucode_ptr += mc_size;\n\t}\n\tif (leftover) {\n\t\tstate = UCODE_ERROR;\n\t\tgoto out;\n\t}\n\tif (mc_saved_count == 0) {\n\t\tstate = UCODE_NFOUND;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < mc_saved_count; i++)\n\t\tmc_saved_in_initrd[i] = (unsigned long)mc_saved_tmp[i] - start;\n\tmc_saved_data->mc_saved_count = mc_saved_count;\nout:\n\treturn state;\n}", "target": 1}
{"code": "void rfbClientCleanup(rfbClient* client) {\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n  int i;\n  for ( i = 0; i < 4; i++ ) {\n    if (client->zlibStreamActive[i] == TRUE ) {\n      if (inflateEnd (&client->zlibStream[i]) != Z_OK &&\n\t  client->zlibStream[i].msg != NULL)\n\trfbClientLog(\"inflateEnd: %s\\n\", client->zlibStream[i].msg);\n    }\n  }\n  if ( client->decompStreamInited == TRUE ) {\n    if (inflateEnd (&client->decompStream) != Z_OK &&\n\tclient->decompStream.msg != NULL)\n      rfbClientLog(\"inflateEnd: %s\\n\", client->decompStream.msg );\n  }\n#endif\n  if (client->ultra_buffer)\n    free(client->ultra_buffer);\n  if (client->raw_buffer)\n    free(client->raw_buffer);\n  FreeTLS(client);\n  while (client->clientData) {\n    rfbClientData* next = client->clientData->next;\n    free(client->clientData);\n    client->clientData = next;\n  }\n  if (client->sock != RFB_INVALID_SOCKET)\n    rfbCloseSocket(client->sock);\n  if (client->listenSock != RFB_INVALID_SOCKET)\n    rfbCloseSocket(client->listenSock);\n  free(client->desktopName);\n  free(client->serverHost);\n  if (client->destHost)\n    free(client->destHost);\n  if (client->clientAuthSchemes)\n    free(client->clientAuthSchemes);\n#ifdef LIBVNCSERVER_HAVE_SASL\n  if (client->saslSecret)\n    free(client->saslSecret);\n#endif \n#ifdef WIN32\n  if(WSACleanup() != 0) {\n      errno=WSAGetLastError();\n      rfbClientErr(\"Could not terminate Windows Sockets: %s\\n\", strerror(errno));\n  }\n#endif\n  free(client);\n}", "target": 1}
{"code": " PPB_URLLoader_Impl::~PPB_URLLoader_Impl() {\n }", "target": 1}
{"code": "static int pcan_usb_pro_drv_loaded(struct peak_usb_device *dev, int loaded)\n{\n\tu8 *buffer;\n\tint err;\n\tbuffer = kmalloc(PCAN_USBPRO_FCT_DRVLD_REQ_LEN, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\tbuffer[0] = 0;\n\tbuffer[1] = !!loaded;\n\terr = pcan_usb_pro_send_req(dev, PCAN_USBPRO_REQ_FCT,\n\t\t\t\t    PCAN_USBPRO_FCT_DRVLD, buffer,\n\t\t\t\t    PCAN_USBPRO_FCT_DRVLD_REQ_LEN);\n\tkfree(buffer);\n\treturn err;\n}", "target": 1}
{"code": "char *compose_path(ctrl_t *ctrl, char *path)\n{\n\tstruct stat st;\n\tstatic char rpath[PATH_MAX];\n\tchar *name, *ptr;\n\tchar dir[PATH_MAX] = { 0 };\n\tstrlcpy(dir, ctrl->cwd, sizeof(dir));\n\tDBG(\"Compose path from cwd: %s, arg: %s\", ctrl->cwd, path ?: \"\");\n\tif (!path || !strlen(path))\n\t\tgoto check;\n\tif (path) {\n\t\tif (path[0] != '/') {\n\t\t\tif (dir[strlen(dir) - 1] != '/')\n\t\t\t\tstrlcat(dir, \"/\", sizeof(dir));\n\t\t}\n\t\tstrlcat(dir, path, sizeof(dir));\n\t}\ncheck:\n\twhile ((ptr = strstr(dir, \"\n\t\tmemmove(ptr, &ptr[1], strlen(&ptr[1]) + 1);\n\tif (!chrooted) {\n\t\tsize_t len = strlen(home);\n\t\tDBG(\"Server path from CWD: %s\", dir);\n\t\tif (len > 0 && home[len - 1] == '/')\n\t\t\tlen--;\n\t\tmemmove(dir + len, dir, strlen(dir) + 1);\n\t\tmemcpy(dir, home, len);\n\t\tDBG(\"Resulting non-chroot path: %s\", dir);\n\t}\n\tif (!stat(dir, &st) && S_ISDIR(st.st_mode)) {\n\t\tif (!realpath(dir, rpath))\n\t\t\treturn NULL;\n\t} else {\n\t\tname = basename(path);\n\t\tptr = dirname(dir);\n\t\tmemset(rpath, 0, sizeof(rpath));\n\t\tif (!realpath(ptr, rpath)) {\n\t\t\tINFO(\"Failed realpath(%s): %m\", ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (rpath[1] != 0)\n\t\t\tstrlcat(rpath, \"/\", sizeof(rpath));\n\t\tstrlcat(rpath, name, sizeof(rpath));\n\t}\n\tif (!chrooted && strncmp(dir, home, strlen(home))) {\n\t\tDBG(\"Failed non-chroot dir:%s vs home:%s\", dir, home);\n\t\treturn NULL;\n\t}\n\treturn rpath;\n}", "target": 1}
{"code": "static int sockfs_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tint err = simple_setattr(dentry, iattr);\n \tif (!err && (iattr->ia_valid & ATTR_UID)) {\n \t\tstruct socket *sock = SOCKET_I(d_inode(dentry));\n\t\tsock->sk->sk_uid = iattr->ia_uid;\n \t}\n \treturn err;\n}", "target": 1}
{"code": "int ip_ra_control(struct sock *sk, unsigned char on,\n\t\t  void (*destructor)(struct sock *))\n{\n\tstruct ip_ra_chain *ra, *new_ra;\n\tstruct ip_ra_chain __rcu **rap;\n\tstruct net *net = sock_net(sk);\n\tif (sk->sk_type != SOCK_RAW || inet_sk(sk)->inet_num == IPPROTO_RAW)\n\t\treturn -EINVAL;\n\tnew_ra = on ? kmalloc(sizeof(*new_ra), GFP_KERNEL) : NULL;\n\tmutex_lock(&net->ipv4.ra_mutex);\n\tfor (rap = &net->ipv4.ra_chain;\n\t     (ra = rcu_dereference_protected(*rap,\n\t\t\tlockdep_is_held(&net->ipv4.ra_mutex))) != NULL;\n\t     rap = &ra->next) {\n\t\tif (ra->sk == sk) {\n\t\t\tif (on) {\n\t\t\t\tmutex_unlock(&net->ipv4.ra_mutex);\n\t\t\t\tkfree(new_ra);\n\t\t\t\treturn -EADDRINUSE;\n\t\t\t}\n\t\t\tra->sk = NULL;\n\t\t\tRCU_INIT_POINTER(*rap, ra->next);\n\t\t\tmutex_unlock(&net->ipv4.ra_mutex);\n\t\t\tif (ra->destructor)\n\t\t\t\tra->destructor(sk);\n\t\t\tra->saved_sk = sk;\n\t\t\tcall_rcu(&ra->rcu, ip_ra_destroy_rcu);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (!new_ra) {\n\t\tmutex_unlock(&net->ipv4.ra_mutex);\n\t\treturn -ENOBUFS;\n\t}\n\tnew_ra->sk = sk;\n\tnew_ra->destructor = destructor;\n\tRCU_INIT_POINTER(new_ra->next, ra);\n\trcu_assign_pointer(*rap, new_ra);\n\tsock_hold(sk);\n\tmutex_unlock(&net->ipv4.ra_mutex);\n\treturn 0;\n}", "target": 1}
{"code": " cdf_unpack_summary_info(const cdf_stream_t *sst, const cdf_header_t *h,\n     cdf_summary_info_header_t *ssi, cdf_property_info_t **info, size_t *count)\n {\n\tsize_t i, maxcount;\n \tconst cdf_summary_info_header_t *si =\n \t    CAST(const cdf_summary_info_header_t *, sst->sst_tab);\n \tconst cdf_section_declaration_t *sd =\n\t    CAST(const cdf_section_declaration_t *, (const void *)\n\t    ((const char *)sst->sst_tab + CDF_SECTION_DECLARATION_OFFSET));\n\tif (cdf_check_stream_offset(sst, h, si, sizeof(*si), __LINE__) == -1 ||\n\t    cdf_check_stream_offset(sst, h, sd, sizeof(*sd), __LINE__) == -1)\n\t\treturn -1;\n\tssi->si_byte_order = CDF_TOLE2(si->si_byte_order);\n\tssi->si_os_version = CDF_TOLE2(si->si_os_version);\n \tssi->si_os = CDF_TOLE2(si->si_os);\n \tssi->si_class = si->si_class;\n \tcdf_swap_class(&ssi->si_class);\n\tssi->si_count = CDF_TOLE2(si->si_count);\n \t*count = 0;\n \tmaxcount = 0;\n \t*info = NULL;\n\tfor (i = 0; i < CDF_TOLE4(si->si_count); i++) {\n\t\tif (i >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Unpack summary info loop limit\"));\n\t\t\terrno = EFTYPE;\n\t\t\treturn -1;\n\t\t}\n\t\tif (cdf_read_property_info(sst, h, CDF_TOLE4(sd->sd_offset),\n\t\t    info, count, &maxcount) == -1) {\n\t\t\treturn -1;\n\t\t}\n\t}\n \treturn 0;\n }", "target": 1}
{"code": "static int crypto_rsa_common(const BYTE* input, int length, UINT32 key_length, const BYTE* modulus,\n                             const BYTE* exponent, int exponent_size, BYTE* output)\n{\n\tBN_CTX* ctx;\n\tint output_length = -1;\n\tBYTE* input_reverse;\n\tBYTE* modulus_reverse;\n\tBYTE* exponent_reverse;\n\tBIGNUM *mod, *exp, *x, *y;\n\tinput_reverse = (BYTE*)malloc(2 * key_length + exponent_size);\n\tif (!input_reverse)\n\t\treturn -1;\n\tmodulus_reverse = input_reverse + key_length;\n\texponent_reverse = modulus_reverse + key_length;\n\tmemcpy(modulus_reverse, modulus, key_length);\n\tcrypto_reverse(modulus_reverse, key_length);\n\tmemcpy(exponent_reverse, exponent, exponent_size);\n\tcrypto_reverse(exponent_reverse, exponent_size);\n\tmemcpy(input_reverse, input, length);\n\tcrypto_reverse(input_reverse, length);\n\tif (!(ctx = BN_CTX_new()))\n\t\tgoto fail_bn_ctx;\n\tif (!(mod = BN_new()))\n\t\tgoto fail_bn_mod;\n\tif (!(exp = BN_new()))\n\t\tgoto fail_bn_exp;\n\tif (!(x = BN_new()))\n\t\tgoto fail_bn_x;\n\tif (!(y = BN_new()))\n\t\tgoto fail_bn_y;\n\tBN_bin2bn(modulus_reverse, key_length, mod);\n\tBN_bin2bn(exponent_reverse, exponent_size, exp);\n\tBN_bin2bn(input_reverse, length, x);\n\tBN_mod_exp(y, x, exp, mod, ctx);\n\toutput_length = BN_bn2bin(y, output);\n\tcrypto_reverse(output, output_length);\n\tif (output_length < (int)key_length)\n\t\tmemset(output + output_length, 0, key_length - output_length);\n\tBN_free(y);\nfail_bn_y:\n\tBN_clear_free(x);\nfail_bn_x:\n\tBN_free(exp);\nfail_bn_exp:\n\tBN_free(mod);\nfail_bn_mod:\n\tBN_CTX_free(ctx);\nfail_bn_ctx:\n\tfree(input_reverse);\n\treturn output_length;\n}", "target": 1}
{"code": " void DelegatedFrameHost::ClearDelegatedFrame() {\n   EvictDelegatedFrame();\n }", "target": 1}
{"code": "void blk_cleanup_queue(struct request_queue *q)\n{\n\tmutex_lock(&q->sysfs_lock);\n\tblk_set_queue_dying(q);\n\tblk_queue_flag_set(QUEUE_FLAG_NOMERGES, q);\n\tblk_queue_flag_set(QUEUE_FLAG_NOXMERGES, q);\n\tblk_queue_flag_set(QUEUE_FLAG_DYING, q);\n\tmutex_unlock(&q->sysfs_lock);\n\tblk_freeze_queue(q);\n\trq_qos_exit(q);\n\tblk_queue_flag_set(QUEUE_FLAG_DEAD, q);\n\tblk_flush_integrity();\n\tdel_timer_sync(&q->backing_dev_info->laptop_mode_wb_timer);\n\tblk_sync_queue(q);\n\tif (queue_is_mq(q))\n\t\tblk_mq_exit_queue(q);\n\tpercpu_ref_exit(&q->q_usage_counter);\n\tblk_put_queue(q);\n}", "target": 1}
{"code": " base::string16 FormatBookmarkURLForDisplay(const GURL& url) {\n  return url_formatter::FormatUrl(\n      url, url_formatter::kFormatUrlOmitAll &\n               ~url_formatter::kFormatUrlOmitUsernamePassword,\n      net::UnescapeRule::SPACES, nullptr, nullptr, nullptr);\n }", "target": 1}
{"code": "atol8(const char *p, size_t char_cnt)\n {\n \tint64_t l;\n \tint digit;\n \tl = 0;\n \twhile (char_cnt-- > 0) {\n \t\tif (*p >= '0' && *p <= '7')\n\t\t\tdigit = *p - '0';\n\t\telse\n\t\t\tbreak;\n\t\tp++;\n\t\tl <<= 3;\n\t\tl |= digit;\n\t}\n\treturn (l);\n}", "target": 1}
{"code": "file_extension(const char *s)\t\n{\n  const char\t*extension;\t\n  static char\tbuf[1024];\t\n  if (s == NULL)\n    return (NULL);\n  else if (!strncmp(s, \"data:image/bmp;\", 15))\n    return (\"bmp\");\n  else if (!strncmp(s, \"data:image/gif;\", 15))\n    return (\"gif\");\n  else if (!strncmp(s, \"data:image/jpeg;\", 16))\n    return (\"jpg\");\n  else if (!strncmp(s, \"data:image/png;\", 15))\n    return (\"png\");\n  else if ((extension = strrchr(s, '/')) != NULL)\n    extension ++;\n  else if ((extension = strrchr(s, '\\\\')) != NULL)\n    extension ++;\n  else\n    extension = s;\n  if ((extension = strrchr(extension, '.')) == NULL)\n    return (\"\");\n  else\n    extension ++;\n  if (strchr(extension, '#') == NULL)\n    return (extension);\n  strlcpy(buf, extension, sizeof(buf));\n  *(char *)strchr(buf, '#') = '\\0';\n  return (buf);\n}", "target": 1}
{"code": "usm_free_usmStateReference(void *old)\n{\n    struct usmStateReference *old_ref = (struct usmStateReference *) old;\n    if (old_ref) {\n        if (old_ref->usr_name_length)\n            SNMP_FREE(old_ref->usr_name);\n        if (old_ref->usr_engine_id_length)\n            SNMP_FREE(old_ref->usr_engine_id);\n        if (old_ref->usr_auth_protocol_length)\n            SNMP_FREE(old_ref->usr_auth_protocol);\n        if (old_ref->usr_priv_protocol_length)\n            SNMP_FREE(old_ref->usr_priv_protocol);\n        if (old_ref->usr_auth_key_length && old_ref->usr_auth_key) {\n            SNMP_ZERO(old_ref->usr_auth_key, old_ref->usr_auth_key_length);\n            SNMP_FREE(old_ref->usr_auth_key);\n        }\n        if (old_ref->usr_priv_key_length && old_ref->usr_priv_key) {\n            SNMP_ZERO(old_ref->usr_priv_key, old_ref->usr_priv_key_length);\n            SNMP_FREE(old_ref->usr_priv_key);\n        }\n        SNMP_ZERO(old_ref, sizeof(*old_ref));\n        SNMP_FREE(old_ref);\n    }\n}                               ", "target": 1}
{"code": " DynamicMetadataProvider::DynamicMetadataProvider(const DOMElement* e)\n    : saml2md::DynamicMetadataProvider(e),\n         m_verifyHost(XMLHelper::getAttrBool(e, true, verifyHost)),\n         m_ignoreTransport(XMLHelper::getAttrBool(e, false, ignoreTransport)),\n         m_encoded(true), m_trust(nullptr)\n{\n    const DOMElement* child = XMLHelper::getFirstChildElement(e, Subst);\n    if (child && child->hasChildNodes()) {\n        auto_ptr_char s(child->getFirstChild()->getNodeValue());\n        if (s.get() && *s.get()) {\n            m_subst = s.get();\n            m_encoded = XMLHelper::getAttrBool(child, true, encoded);\n            m_hashed = XMLHelper::getAttrString(child, nullptr, hashed);\n        }\n    }\n    if (m_subst.empty()) {\n        child = XMLHelper::getFirstChildElement(e, Regex);\n        if (child && child->hasChildNodes() && child->hasAttributeNS(nullptr, match)) {\n            m_match = XMLHelper::getAttrString(child, nullptr, match);\n            auto_ptr_char repl(child->getFirstChild()->getNodeValue());\n            if (repl.get() && *repl.get())\n                m_regex = repl.get();\n        }\n    }\n    if (!m_ignoreTransport) {\n        child = XMLHelper::getFirstChildElement(e, _TrustEngine);\n        string t = XMLHelper::getAttrString(child, nullptr, _type);\n        if (!t.empty()) {\n            TrustEngine* trust = XMLToolingConfig::getConfig().TrustEngineManager.newPlugin(t.c_str(), child);\n            if (!dynamic_cast<X509TrustEngine*>(trust)) {\n                delete trust;\n                throw ConfigurationException(\"DynamicMetadataProvider requires an X509TrustEngine plugin.\");\n            }\n            m_trust.reset(dynamic_cast<X509TrustEngine*>(trust));\n            m_dummyCR.reset(XMLToolingConfig::getConfig().CredentialResolverManager.newPlugin(DUMMY_CREDENTIAL_RESOLVER, nullptr));\n        }\n        if (!m_trust.get() || !m_dummyCR.get())\n            throw ConfigurationException(\"DynamicMetadataProvider requires an X509TrustEngine plugin unless ignoreTransport is true.\");\n    }\n}", "target": 1}
{"code": "hufUncompress (const char compressed[],\n\t       int nCompressed,\n\t       unsigned short raw[],\n\t       int nRaw)\n{\n    if (nCompressed < 20 )\n    {\n\tif (nRaw != 0)\n\t    notEnoughData();\n\treturn;\n    }\n    int im = readUInt (compressed);\n    int iM = readUInt (compressed + 4);\n    int nBits = readUInt (compressed + 12);\n    if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE)\n\tinvalidTableSize();\n    const char *ptr = compressed + 20;\n    if ( ptr + (nBits+7 )/8 > compressed+nCompressed)\n    {\n        notEnoughData();\n        return;\n    }\n    if (FastHufDecoder::enabled() && nBits > 128)\n    {\n        FastHufDecoder fhd (ptr, nCompressed - (ptr - compressed), im, iM, iM);\n        fhd.decode ((unsigned char*)ptr, nBits, raw, nRaw);\n    }\n    else\n    {\n        AutoArray <Int64, HUF_ENCSIZE> freq;\n        AutoArray <HufDec, HUF_DECSIZE> hdec;\n        hufClearDecTable (hdec);\n        hufUnpackEncTable (&ptr,\n                           nCompressed - (ptr - compressed),\n                           im,\n                           iM,\n                           freq);\n        try\n        {\n            if (nBits > 8 * (nCompressed - (ptr - compressed)))\n                invalidNBits();\n            hufBuildDecTable (freq, im, iM, hdec);\n            hufDecode (freq, hdec, ptr, nBits, iM, nRaw, raw);\n        }\n        catch (...)\n        {\n            hufFreeDecTable (hdec);\n            throw;\n        }\n        hufFreeDecTable (hdec);\n    }\n}", "target": 1}
{"code": " static int digi_startup(struct usb_serial *serial)\n {\n \tstruct digi_serial *serial_priv;\n \tint ret;\n \tserial_priv = kzalloc(sizeof(*serial_priv), GFP_KERNEL);\n \tif (!serial_priv)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&serial_priv->ds_serial_lock);\n\tserial_priv->ds_oob_port_num = serial->type->num_ports;\n\tserial_priv->ds_oob_port = serial->port[serial_priv->ds_oob_port_num];\n\tret = digi_port_init(serial_priv->ds_oob_port,\n\t\t\t\t\t\tserial_priv->ds_oob_port_num);\n\tif (ret) {\n\t\tkfree(serial_priv);\n\t\treturn ret;\n\t}\n\tusb_set_serial_data(serial, serial_priv);\n\treturn 0;\n}", "target": 1}
{"code": "void CLASS samsung_load_raw()\n{\n  int row, col, c, i, dir, op[4], len[4];\n  order = 0x4949;\n  for (row=0; row < raw_height; row++) {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    fseek (ifp, strip_offset+row*4, SEEK_SET);\n    fseek (ifp, data_offset+get4(), SEEK_SET);\n    ph1_bits(-1);\n    FORC4 len[c] = row < 2 ? 7:4;\n    for (col=0; col < raw_width; col+=16) {\n      dir = ph1_bits(1);\n      FORC4 op[c] = ph1_bits(2);\n      FORC4 switch (op[c]) {\n\tcase 3: len[c] = ph1_bits(4);\tbreak;\n\tcase 2: len[c]--;\t\tbreak;\n\tcase 1: len[c]++;\n      }\n      for (c=0; c < 16; c+=2) {\n\ti = len[((c & 1) << 1) | (c >> 3)];\n        RAW(row,col+c) = ((signed) ph1_bits(i) << (32-i) >> (32-i)) +\n\t  (dir ? RAW(row+(~c | -2),col+c) : col ? RAW(row,col+(c | -2)) : 128);\n\tif (c == 14) c = -1;\n      }\n    }\n  }\n  for (row=0; row < raw_height-1; row+=2)\n    for (col=0; col < raw_width-1; col+=2)\n      SWAP (RAW(row,col+1), RAW(row+1,col));\n}", "target": 1}
{"code": "AudioSource::AudioSource(\n audio_source_t inputSource, const String16 &opPackageName,\n uint32_t sampleRate, uint32_t channelCount, uint32_t outSampleRate)\n     : mStarted(false),\n       mSampleRate(sampleRate),\n       mOutSampleRate(outSampleRate > 0 ? outSampleRate : sampleRate),\n       mPrevSampleTimeUs(0),\n       mFirstSampleTimeUs(-1ll),\n       mNumFramesReceived(0),\n       mNumClientOwnedBuffers(0) {\n     ALOGV(\"sampleRate: %u, outSampleRate: %u, channelCount: %u\",\n            sampleRate, outSampleRate, channelCount);\n    CHECK(channelCount == 1 || channelCount == 2);\n    CHECK(sampleRate > 0);\n size_t minFrameCount;\n status_t status = AudioRecord::getMinFrameCount(&minFrameCount,\n                                           sampleRate,\n                                           AUDIO_FORMAT_PCM_16_BIT,\n                                           audio_channel_in_mask_from_count(channelCount));\n if (status == OK) {\n uint32_t frameCount = kMaxBufferSize / sizeof(int16_t) / channelCount;\n size_t bufCount = 2;\n while ((bufCount * frameCount) < minFrameCount) {\n            bufCount++;\n }\n        mRecord = new AudioRecord(\n                    inputSource, sampleRate, AUDIO_FORMAT_PCM_16_BIT,\n                    audio_channel_in_mask_from_count(channelCount),\n                    opPackageName,\n (size_t) (bufCount * frameCount),\n AudioRecordCallbackFunction,\n this,\n                    frameCount );\n        mInitCheck = mRecord->initCheck();\n if (mInitCheck != OK) {\n            mRecord.clear();\n }\n } else {\n        mInitCheck = status;\n }\n}", "target": 1}
{"code": "    long WebPImage::getHeaderOffset(byte *data, long data_size,\n                                    byte *header, long header_size) {\n        long pos = -1;\n        for (long i=0; i < data_size - header_size; i++) {\n            if (memcmp(header, &data[i], header_size) == 0) {\n                pos = i;\n                break;\n            }\n        }\n        return pos;\n    }", "target": 1}
{"code": "static int qh_help(int sd, char *buf, unsigned int len)\n{\n\tstruct query_handler *qh = NULL;\n\tif (!*buf || !strcmp(buf, \"help\")) {\n\t\tnsock_printf_nul(sd,\n\t\t\t\"  help <name>   show help for handler <name>\\n\"\n\t\t\t\"  help list     list registered handlers\\n\");\n\t\treturn 0;\n\t}\n\tif (!strcmp(buf, \"list\")) {\n\t\tfor (qh = qhandlers; qh != NULL; qh = qh->next_qh) {\n\t\t\tnsock_printf(sd, \"%-10s %s\\n\", qh->name, qh->description ? qh->description : \"(No description available)\");\n\t\t}\n\t\tnsock_printf(sd, \"%c\", 0);\n\t\treturn 0;\n\t}\n\tqh = qh_find_handler(buf);\n\tif (qh == NULL) {\n\t\tnsock_printf_nul(sd, \"No handler named '%s' is registered\\n\", buf);\n\t} else if (qh->handler(sd, \"help\", 4) > 200) {\n\t\tnsock_printf_nul(sd, \"The handler %s doesn't have any help yet.\", buf);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void CLASS kodak_65000_load_raw()\n{\n  short buf[256];\n  int row, col, len, pred[2], ret, i;\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col+=256) {\n      pred[0] = pred[1] = 0;\n      len = MIN (256, width-col);\n      ret = kodak_65000_decode (buf, len);\n      for (i=0; i < len; i++)\n\tif ((RAW(row,col+i) =\tcurve[ret ? buf[i] :\n\t\t(pred[i & 1] += buf[i])]) >> 12) derror();\n    }\n  }\n}", "target": 1}
{"code": "find_start_brace(void)\t    \n{\n    pos_T\tcursor_save;\n    pos_T\t*trypos;\n    pos_T\t*pos;\n    static pos_T\tpos_copy;\n    cursor_save = curwin->w_cursor;\n    while ((trypos = findmatchlimit(NULL, '{', FM_BLOCKSTOP, 0)) != NULL)\n    {\n\tpos_copy = *trypos;\t\n\ttrypos = &pos_copy;\n\tcurwin->w_cursor = *trypos;\n\tpos = NULL;\n\tif ((colnr_T)cin_skip2pos(trypos) == trypos->col\n\t\t       && (pos = ind_find_start_CORS(NULL)) == NULL) \n\t    break;\n\tif (pos != NULL)\n\t    curwin->w_cursor.lnum = pos->lnum;\n    }\n    curwin->w_cursor = cursor_save;\n    return trypos;\n}", "target": 1}
{"code": "TfLiteStatus ResizeOutputTensors(TfLiteContext* context, TfLiteNode* node,\n                                 const TfLiteTensor* input,\n                                 const TfLiteTensor* size_splits,\n                                 const TfLiteTensor* axis) {\n  int axis_value = GetTensorData<int>(axis)[0];\n  if (axis_value < 0) {\n    axis_value += NumDimensions(input);\n  }\n  std::vector<int64_t> size_splits_vector;\n  if (size_splits->type == kTfLiteInt32) {\n    GetSizeSplitsVector<int32_t>(size_splits, &size_splits_vector);\n  } else if (size_splits->type == kTfLiteInt64) {\n    GetSizeSplitsVector<int64_t>(size_splits, &size_splits_vector);\n  } else {\n    context->ReportError(context, \"size_splits only support type int32|int64.\");\n    return kTfLiteError;\n  }\n  int minus_one_index = -1;\n  int64_t size_splits_sum = 0;\n  for (int i = 0; i < size_splits_vector.size(); ++i) {\n    if (size_splits_vector.at(i) == -1) {\n      if (minus_one_index == -1) {\n        minus_one_index = i;\n      } else {\n        context->ReportError(context,\n                             \"The size_splits contains more than one -1.\");\n      }\n    } else {\n      size_splits_sum += size_splits_vector.at(i);\n    }\n  }\n  const int input_size = SizeOfDimension(input, axis_value);\n  if (minus_one_index != -1) {\n    if (size_splits_sum > input_size) {\n      context->ReportError(\n          context,\n          \"The sum of size_splits must be less than the dimension of value.\");\n    } else {\n      size_splits_vector[minus_one_index] = input_size - size_splits_sum;\n    }\n  } else if (size_splits_sum != input_size) {\n    context->ReportError(\n        context,\n        \"The size_splits must sum to the dimension of value along axis.\");\n  }\n  for (int i = 0; i < NumOutputs(node); ++i) {\n    TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input->dims);\n    output_dims->data[axis_value] = size_splits_vector.at(i);\n    TfLiteTensor* output;\n    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output));\n    TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_dims));\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static int hi3660_stub_clk_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tunsigned int i;\n\tint ret;\n\tstub_clk_chan.cl.dev = dev;\n\tstub_clk_chan.cl.tx_done = NULL;\n\tstub_clk_chan.cl.tx_block = false;\n\tstub_clk_chan.cl.knows_txdone = false;\n\tstub_clk_chan.mbox = mbox_request_channel(&stub_clk_chan.cl, 0);\n\tif (IS_ERR(stub_clk_chan.mbox))\n \t\treturn PTR_ERR(stub_clk_chan.mbox);\n \tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n \tfreq_reg = devm_ioremap(dev, res->start, resource_size(res));\n \tif (!freq_reg)\n \t\treturn -ENOMEM;\n\tfreq_reg += HI3660_STUB_CLOCK_DATA;\n\tfor (i = 0; i < HI3660_CLK_STUB_NUM; i++) {\n\t\tret = devm_clk_hw_register(&pdev->dev, &hi3660_stub_clks[i].hw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn devm_of_clk_add_hw_provider(&pdev->dev, hi3660_stub_clk_hw_get,\n\t\t\t\t\t   hi3660_stub_clks);\n}", "target": 1}
{"code": "int OmniboxViewViews::OnDrop(const ui::OSExchangeData& data) {\n  if (HasTextBeingDragged())\n    return ui::DragDropTypes::DRAG_NONE;\n  if (data.HasURL(ui::OSExchangeData::CONVERT_FILENAMES)) {\n    GURL url;\n    base::string16 title;\n    if (data.GetURLAndTitle(\n            ui::OSExchangeData::CONVERT_FILENAMES, &url, &title)) {\n      base::string16 text(\n          StripJavascriptSchemas(base::UTF8ToUTF16(url.spec())));\n      if (model()->CanPasteAndGo(text)) {\n        model()->PasteAndGo(text);\n        return ui::DragDropTypes::DRAG_COPY;\n      }\n    }\n   } else if (data.HasString()) {\n     base::string16 text;\n     if (data.GetString(&text)) {\n      base::string16 collapsed_text(base::CollapseWhitespace(text, true));\n       if (model()->CanPasteAndGo(collapsed_text))\n         model()->PasteAndGo(collapsed_text);\n       return ui::DragDropTypes::DRAG_COPY;\n    }\n  }\n  return ui::DragDropTypes::DRAG_NONE;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    StagingMap<Ordered>* map = nullptr;\n    OP_REQUIRES_OK(ctx, GetStagingMap(ctx, def(), &map));\n    core::ScopedUnref scope(map);\n    typename StagingMap<Ordered>::OptionalTuple tuple;\n    const Tensor* key_tensor;\n    const Tensor* indices_tensor;\n    OpInputList values_tensor;\n    OP_REQUIRES_OK(ctx, ctx->input(\"key\", &key_tensor));\n    OP_REQUIRES_OK(ctx, ctx->input(\"indices\", &indices_tensor));\n    OP_REQUIRES_OK(ctx, ctx->input_list(\"values\", &values_tensor));\n    OP_REQUIRES(ctx, key_tensor->NumElements() > 0,\n                errors::InvalidArgument(\"key must not be empty\"));\n    Tensor key(*key_tensor);\n    for (std::size_t i = 0; i < values_tensor.size(); ++i) {\n      tuple.push_back(values_tensor[i]);\n    }\n    OP_REQUIRES_OK(ctx, map->put(&key, indices_tensor, &tuple));\n  }", "target": 1}
{"code": "GF_Err stbl_AppendSize(GF_SampleTableBox *stbl, u32 size, u32 nb_pack)\n{\n\tu32 i;\n\tif (!nb_pack) nb_pack = 1;\n\tif (!stbl->SampleSize->sampleCount) {\n\t\tstbl->SampleSize->sampleSize = size;\n\t\tstbl->SampleSize->sampleCount += nb_pack;\n\t\treturn GF_OK;\n\t}\n\tif (stbl->SampleSize->sampleSize && (stbl->SampleSize->sampleSize==size)) {\n\t\tstbl->SampleSize->sampleCount += nb_pack;\n\t\treturn GF_OK;\n\t}\n\tif (!stbl->SampleSize->sizes || (stbl->SampleSize->sampleCount+nb_pack > stbl->SampleSize->alloc_size)) {\n\t\tBool init_table = (stbl->SampleSize->sizes==NULL) ? 1 : 0;\n\t\tALLOC_INC(stbl->SampleSize->alloc_size);\n\t\tif (stbl->SampleSize->sampleCount+nb_pack > stbl->SampleSize->alloc_size)\n\t\t\tstbl->SampleSize->alloc_size = stbl->SampleSize->sampleCount+nb_pack;\n\t\tstbl->SampleSize->sizes = (u32 *)gf_realloc(stbl->SampleSize->sizes, sizeof(u32)*stbl->SampleSize->alloc_size);\n\t\tif (!stbl->SampleSize->sizes) return GF_OUT_OF_MEM;\n\t\tmemset(&stbl->SampleSize->sizes[stbl->SampleSize->sampleCount], 0, sizeof(u32) * (stbl->SampleSize->alloc_size - stbl->SampleSize->sampleCount) );\n\t\tif (init_table) {\n\t\t\tfor (i=0; i<stbl->SampleSize->sampleCount; i++)\n\t\t\t\tstbl->SampleSize->sizes[i] = stbl->SampleSize->sampleSize;\n\t\t}\n\t}\n\tstbl->SampleSize->sampleSize = 0;\n\tfor (i=0; i<nb_pack; i++) {\n\t\tstbl->SampleSize->sizes[stbl->SampleSize->sampleCount+i] = size;\n\t}\n\tstbl->SampleSize->sampleCount += nb_pack;\n\tif (size > stbl->SampleSize->max_size)\n\t\tstbl->SampleSize->max_size = size;\n\tstbl->SampleSize->total_size += size;\n\tstbl->SampleSize->total_samples += nb_pack;\n\treturn GF_OK;\n}", "target": 1}
{"code": "bool PlatformFontSkia::InitDefaultFont() {\n  if (g_default_font.Get())\n    return true;\n   bool success = false;\n   std::string family = kFallbackFontFamilyName;\n  int size_pixels = 12;\n   int style = Font::NORMAL;\n   Font::Weight weight = Font::Weight::NORMAL;\n   FontRenderParams params;\n  const SkiaFontDelegate* delegate = SkiaFontDelegate::instance();\n  if (delegate) {\n    delegate->GetDefaultFontDescription(&family, &size_pixels, &style, &weight,\n                                        &params);\n  } else if (default_font_description_) {\n#if defined(OS_CHROMEOS)\n    FontRenderParamsQuery query;\n    CHECK(FontList::ParseDescription(*default_font_description_,\n                                     &query.families, &query.style,\n                                     &query.pixel_size, &query.weight))\n        << \"Failed to parse font description \" << *default_font_description_;\n    params = gfx::GetFontRenderParams(query, &family);\n    size_pixels = query.pixel_size;\n    style = query.style;\n    weight = query.weight;\n#else\n    NOTREACHED();\n#endif\n  }\n  sk_sp<SkTypeface> typeface =\n      CreateSkTypeface(style & Font::ITALIC, weight, &family, &success);\n  if (!success)\n    return false;\n  g_default_font.Get() = new PlatformFontSkia(\n      std::move(typeface), family, size_pixels, style, weight, params);\n  return true;\n}", "target": 1}
{"code": "  Status BuildInputArgIndex(const OpDef::ArgDef& arg_def, AttrSlice attr_values,\n                            const FunctionDef::ArgAttrs* arg_attrs,\n                            bool ints_on_device,\n                            int64_t resource_arg_unique_id) {\n    bool is_type_list;\n    DataTypeVector dtypes;\n    TF_RETURN_IF_ERROR(\n        ArgNumType(attr_values, arg_def, &is_type_list, &dtypes));\n    if (dtypes.size() < size_t{1}) {\n      return errors::Internal(\"Expected a list of at least one dtype\");\n    }\n    int arg_index = result_.nodes.size();\n    TF_RETURN_IF_ERROR(\n        AddItem(arg_def.name(), {true, arg_index, 0, is_type_list, dtypes}));\n    for (size_t i = 0; i < dtypes.size(); ++i) {\n      TF_RETURN_IF_ERROR(AddItem(strings::StrCat(arg_def.name(), \":\", i),\n                                 {true, arg_index, 0, false, {dtypes[i]}}));\n      DCHECK_EQ(arg_index, result_.nodes.size());\n      string name = arg_def.name();\n      if (dtypes.size() > 1) {\n        strings::StrAppend(&name, \"_\", i);\n      }\n      NodeDef* gnode = AddNode(name);\n      if (ints_on_device && dtypes[i] == DataType::DT_INT32) {\n        gnode->set_op(FunctionLibraryDefinition::kDeviceArgOp);\n      } else {\n        gnode->set_op(FunctionLibraryDefinition::kArgOp);\n      }\n      DataType dtype = arg_def.is_ref() ? MakeRefType(dtypes[i]) : dtypes[i];\n      AddAttr(\"T\", dtype, gnode);\n      AddAttr(\"index\", arg_index, gnode);\n      if (resource_arg_unique_id >= 0) {\n        AddAttr(\"_resource_arg_unique_id\", resource_arg_unique_id, gnode);\n      }\n      if (arg_attrs) {\n        for (const auto& arg_attr : arg_attrs->attr()) {\n          AddAttr(arg_attr.first, arg_attr.second, gnode->mutable_attr());\n        }\n      }\n      result_.arg_types.push_back(dtypes[i]);\n      ++arg_index;\n    }\n    return Status::OK();\n  }", "target": 1}
{"code": "mrb_realloc(mrb_state *mrb, void *p, size_t len)\n{\n  void *p2;\n  p2 = mrb_realloc_simple(mrb, p, len);\n  if (len == 0) return p2;\n  if (p2 == NULL) {\n    mrb_free(mrb, p);\n    mrb->gc.out_of_memory = TRUE;\n    mrb_raise_nomemory(mrb);\n  }\n  else {\n    mrb->gc.out_of_memory = FALSE;\n  }\n  return p2;\n}", "target": 1}
{"code": "static int xfrm6_tunnel_rcv(struct sk_buff *skb)\n{\n\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n \t__be32 spi;\n \tspi = xfrm6_tunnel_spi_lookup((xfrm_address_t *)&iph->saddr);\n\treturn xfrm6_rcv_spi(skb, spi);\n }", "target": 1}
{"code": "static ssize_t aio_poll(struct aio_kiocb *aiocb, const struct iocb *iocb)\n{\n\tstruct kioctx *ctx = aiocb->ki_ctx;\n\tstruct poll_iocb *req = &aiocb->poll;\n\tstruct aio_poll_table apt;\n\t__poll_t mask;\n\tif ((u16)iocb->aio_buf != iocb->aio_buf)\n\t\treturn -EINVAL;\n\tif (iocb->aio_offset || iocb->aio_nbytes || iocb->aio_rw_flags)\n\t\treturn -EINVAL;\n\tINIT_WORK(&req->work, aio_poll_complete_work);\n\treq->events = demangle_poll(iocb->aio_buf) | EPOLLERR | EPOLLHUP;\n\treq->file = fget(iocb->aio_fildes);\n\tif (unlikely(!req->file))\n\t\treturn -EBADF;\n\treq->head = NULL;\n\treq->woken = false;\n\treq->cancelled = false;\n\tapt.pt._qproc = aio_poll_queue_proc;\n\tapt.pt._key = req->events;\n\tapt.iocb = aiocb;\n\tapt.error = -EINVAL; \n\tINIT_LIST_HEAD(&req->wait.entry);\n\tinit_waitqueue_func_entry(&req->wait, aio_poll_wake);\n\trefcount_set(&aiocb->ki_refcnt, 2);\n\tmask = vfs_poll(req->file, &apt.pt) & req->events;\n\tif (unlikely(!req->head)) {\n\t\tgoto out;\n\t}\n\tspin_lock_irq(&ctx->ctx_lock);\n\tspin_lock(&req->head->lock);\n\tif (req->woken) {\n\t\tmask = 0;\n\t\tapt.error = 0;\n\t} else if (mask || apt.error) {\n\t\tWARN_ON_ONCE(list_empty(&req->wait.entry));\n\t\tlist_del_init(&req->wait.entry);\n\t} else {\n\t\tlist_add_tail(&aiocb->ki_list, &ctx->active_reqs);\n\t\taiocb->ki_cancel = aio_poll_cancel;\n\t}\n\tspin_unlock(&req->head->lock);\n\tspin_unlock_irq(&ctx->ctx_lock);\nout:\n\tif (unlikely(apt.error)) {\n\t\tfput(req->file);\n\t\treturn apt.error;\n\t}\n\tif (mask)\n\t\taio_poll_complete(aiocb, mask);\n\tiocb_put(aiocb);\n\treturn 0;\n}", "target": 1}
{"code": "static __always_inline int __do_follow_link(struct path *path, struct nameidata *nd)\n{\n\tint error;\n\tvoid *cookie;\n\tstruct dentry *dentry = path->dentry;\n\ttouch_atime(path->mnt, dentry);\n\tnd_set_link(nd, NULL);\n\tif (path->mnt != nd->path.mnt) {\n\t\tpath_to_nameidata(path, nd);\n \t\tdget(dentry);\n \t}\n \tmntget(path->mnt);\n \tcookie = dentry->d_inode->i_op->follow_link(dentry, nd);\n \terror = PTR_ERR(cookie);\n \tif (!IS_ERR(cookie)) {\n\t\tchar *s = nd_get_link(nd);\n\t\terror = 0;\n\t\tif (s)\n\t\t\terror = __vfs_follow_link(nd, s);\n\t\telse if (nd->last_type == LAST_BIND) {\n\t\t\terror = force_reval_path(&nd->path, nd);\n\t\t\tif (error)\n\t\t\t\tpath_put(&nd->path);\n\t\t}\n\t\tif (dentry->d_inode->i_op->put_link)\n\t\t\tdentry->d_inode->i_op->put_link(dentry, nd, cookie);\n\t}\n\treturn error;\n}", "target": 1}
{"code": "ssize_t tcp_splice_read(struct socket *sock, loff_t *ppos,\n\t\t\tstruct pipe_inode_info *pipe, size_t len,\n\t\t\tunsigned int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct tcp_splice_state tss = {\n\t\t.pipe = pipe,\n\t\t.len = len,\n\t\t.flags = flags,\n\t};\n\tlong timeo;\n\tssize_t spliced;\n\tint ret;\n\tsock_rps_record_flow(sk);\n\tif (unlikely(*ppos))\n\t\treturn -ESPIPE;\n\tret = spliced = 0;\n\tlock_sock(sk);\n\ttimeo = sock_rcvtimeo(sk, sock->file->f_flags & O_NONBLOCK);\n\twhile (tss.len) {\n\t\tret = __tcp_splice_read(sk, &tss);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\telse if (!ret) {\n\t\t\tif (spliced)\n\t\t\t\tbreak;\n\t\t\tif (sock_flag(sk, SOCK_DONE))\n\t\t\t\tbreak;\n\t\t\tif (sk->sk_err) {\n\t\t\t\tret = sock_error(sk);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\t\tbreak;\n\t\t\tif (sk->sk_state == TCP_CLOSE) {\n\t\t\t\tif (!sock_flag(sk, SOCK_DONE))\n\t\t\t\t\tret = -ENOTCONN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!timeo) {\n \t\t\t\tret = -EAGAIN;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tsk_wait_data(sk, &timeo, NULL);\n \t\t\tif (signal_pending(current)) {\n \t\t\t\tret = sock_intr_errno(timeo);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\ttss.len -= ret;\n\t\tspliced += ret;\n\t\tif (!timeo)\n\t\t\tbreak;\n\t\trelease_sock(sk);\n\t\tlock_sock(sk);\n\t\tif (sk->sk_err || sk->sk_state == TCP_CLOSE ||\n\t\t    (sk->sk_shutdown & RCV_SHUTDOWN) ||\n\t\t    signal_pending(current))\n\t\t\tbreak;\n\t}\n\trelease_sock(sk);\n\tif (spliced)\n\t\treturn spliced;\n\treturn ret;\n}", "target": 1}
{"code": " void HTMLFormControlElement::updateVisibleValidationMessage() {\n   Page* page = document().page();\n  if (!page)\n     return;\n   String message;\n   if (layoutObject() && willValidate())\n    message = validationMessage().stripWhiteSpace();\n  m_hasValidationMessage = true;\n  ValidationMessageClient* client = &page->validationMessageClient();\n  TextDirection messageDir = LTR;\n  TextDirection subMessageDir = LTR;\n  String subMessage = validationSubMessage().stripWhiteSpace();\n  if (message.isEmpty())\n    client->hideValidationMessage(*this);\n  else\n    findCustomValidationMessageTextDirection(message, messageDir, subMessage,\n                                             subMessageDir);\n  client->showValidationMessage(*this, message, messageDir, subMessage,\n                                subMessageDir);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& input = ctx->input(0);\n    const Tensor& input_min_tensor = ctx->input(1);\n    const Tensor& input_max_tensor = ctx->input(2);\n    int num_slices = 1;\n    if (axis_ > -1) {\n      num_slices = input.dim_size(axis_);\n    }\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output));\n    Tensor float_output =\n        need_cast_ ? tensorflow::Tensor(DT_FLOAT, input.shape()) : *output;\n    if (num_slices == 1) {\n      const float min_range = input_min_tensor.flat<float>()(0);\n      const float max_range = input_max_tensor.flat<float>()(0);\n      DequantizeTensor(ctx, input, min_range, max_range, &float_output);\n    } else {\n      OP_REQUIRES(ctx, mode_ != QUANTIZE_MODE_MIN_FIRST,\n                  errors::Unimplemented(\"MIN_FIRST mode is not implemented for \"\n                                        \"Dequantize with axis != -1.\"));\n      int64 pre_dim = 1, post_dim = 1;\n      for (int i = 0; i < axis_; ++i) {\n        pre_dim *= float_output.dim_size(i);\n      }\n      for (int i = axis_ + 1; i < float_output.dims(); ++i) {\n        post_dim *= float_output.dim_size(i);\n      }\n      auto input_tensor = input.template bit_casted_shaped<T, 3>(\n          {pre_dim, num_slices, post_dim});\n      auto output_tensor =\n          float_output.flat_inner_outer_dims<float, 3>(axis_ - 1);\n      auto min_ranges = input_min_tensor.vec<float>();\n      auto max_ranges = input_max_tensor.vec<float>();\n      for (int i = 0; i < num_slices; ++i) {\n        DequantizeSlice(ctx->eigen_device<Device>(), ctx,\n                        input_tensor.template chip<1>(i), min_ranges(i),\n                        max_ranges(i), output_tensor.template chip<1>(i));\n      }\n    }\n    if (need_cast_) {\n      S* out_ptr = output->flat<S>().data();\n      float* in_ptr = float_output.flat<float>().data();\n      for (int64 i = 0; i < float_output.NumElements(); ++i) {\n        out_ptr[i] = static_cast<S>(in_ptr[i]);\n      }\n    }\n  }", "target": 1}
{"code": "  Status ValidateInputsGenerateOutputs(\n      OpKernelContext* ctx, const Tensor** inputs, const Tensor** seq_len,\n      Tensor** log_prob, OpOutputList* decoded_indices,\n      OpOutputList* decoded_values, OpOutputList* decoded_shape) const {\n    Status status = ctx->input(\"inputs\", inputs);\n    if (!status.ok()) return status;\n    status = ctx->input(\"sequence_length\", seq_len);\n    if (!status.ok()) return status;\n    const TensorShape& inputs_shape = (*inputs)->shape();\n    if (inputs_shape.dims() != 3) {\n      return errors::InvalidArgument(\"inputs is not a 3-Tensor\");\n    }\n    const int64 max_time = inputs_shape.dim_size(0);\n    const int64 batch_size = inputs_shape.dim_size(1);\n    if (max_time == 0) {\n      return errors::InvalidArgument(\"max_time is 0\");\n    }\n    if (!TensorShapeUtils::IsVector((*seq_len)->shape())) {\n      return errors::InvalidArgument(\"sequence_length is not a vector\");\n    }\n    if (!(batch_size == (*seq_len)->dim_size(0))) {\n      return errors::FailedPrecondition(\n          \"len(sequence_length) != batch_size.  \",\n          \"len(sequence_length):  \", (*seq_len)->dim_size(0),\n          \" batch_size: \", batch_size);\n    }\n    auto seq_len_t = (*seq_len)->vec<int32>();\n    for (int b = 0; b < batch_size; ++b) {\n      if (!(seq_len_t(b) <= max_time)) {\n        return errors::FailedPrecondition(\"sequence_length(\", b,\n                                          \") <= \", max_time);\n      }\n    }\n    Status s = ctx->allocate_output(\n        \"log_probability\", TensorShape({batch_size, top_paths_}), log_prob);\n    if (!s.ok()) return s;\n    s = ctx->output_list(\"decoded_indices\", decoded_indices);\n    if (!s.ok()) return s;\n    s = ctx->output_list(\"decoded_values\", decoded_values);\n    if (!s.ok()) return s;\n    s = ctx->output_list(\"decoded_shape\", decoded_shape);\n    if (!s.ok()) return s;\n    return Status::OK();\n  }", "target": 1}
{"code": "static bool check_client_passwd(PgSocket *client, const char *passwd)\n{\n\tchar md5[MD5_PASSWD_LEN + 1];\n \tconst char *correct;\n \tPgUser *user = client->auth_user;\n \tif (!*passwd || !*user->passwd)\n \t\treturn false;\n\tswitch (cf_auth_type) {\n\tcase AUTH_PLAIN:\n\t\treturn strcmp(user->passwd, passwd) == 0;\n\tcase AUTH_CRYPT:\n\t\tcorrect = crypt(user->passwd, (char *)client->tmp_login_salt);\n\t\treturn correct && strcmp(correct, passwd) == 0;\n\tcase AUTH_MD5:\n\t\tif (strlen(passwd) != MD5_PASSWD_LEN)\n\t\t\treturn false;\n\t\tif (!isMD5(user->passwd))\n\t\t\tpg_md5_encrypt(user->passwd, user->name, strlen(user->name), user->passwd);\n\t\tpg_md5_encrypt(user->passwd + 3, (char *)client->tmp_login_salt, 4, md5);\n\t\treturn strcmp(md5, passwd) == 0;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "struct resource_pool *dcn10_create_resource_pool(\n\t\tconst struct dc_init_data *init_data,\n\t\tstruct dc *dc)\n{\n\tstruct dcn10_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dcn10_resource_pool), GFP_KERNEL);\n\tif (!pool)\n\t\treturn NULL;\n\tif (construct(init_data->num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 1}
{"code": "rsock_init_unixsock(VALUE sock, VALUE path, int server)\n{\n    struct sockaddr_un sockaddr;\n    socklen_t sockaddrlen;\n    int fd, status;\n    rb_io_t *fptr;\n    SafeStringValue(path);\n    INIT_SOCKADDR_UN(&sockaddr, sizeof(struct sockaddr_un));\n    if (sizeof(sockaddr.sun_path) < (size_t)RSTRING_LEN(path)) {\n        rb_raise(rb_eArgError, \"too long unix socket path (%ldbytes given but %dbytes max)\",\n            RSTRING_LEN(path), (int)sizeof(sockaddr.sun_path));\n    }\n    memcpy(sockaddr.sun_path, RSTRING_PTR(path), RSTRING_LEN(path));\n    sockaddrlen = rsock_unix_sockaddr_len(path);\n    fd = rsock_socket(AF_UNIX, SOCK_STREAM, 0);\n    if (fd < 0) {\n\trsock_sys_fail_path(\"socket(2)\", path);\n    }\n    if (server) {\n        status = bind(fd, (struct sockaddr*)&sockaddr, sockaddrlen);\n    }\n    else {\n\tint prot;\n\tstruct unixsock_arg arg;\n\targ.sockaddr = &sockaddr;\n\targ.sockaddrlen = sockaddrlen;\n\targ.fd = fd;\n        status = (int)rb_protect(unixsock_connect_internal, (VALUE)&arg, &prot);\n\tif (prot) {\n\t    close(fd);\n\t    rb_jump_tag(prot);\n\t}\n    }\n    if (status < 0) {\n\tclose(fd);\n        rsock_sys_fail_path(\"connect(2)\", path);\n    }\n    if (server) {\n\tif (listen(fd, SOMAXCONN) < 0) {\n\t    close(fd);\n            rsock_sys_fail_path(\"listen(2)\", path);\n\t}\n    }\n    rsock_init_sock(sock, fd);\n    if (server) {\n\tGetOpenFile(sock, fptr);\n        fptr->pathv = rb_str_new_frozen(path);\n    }\n    return sock;\n}", "target": 1}
{"code": "dtls1_reassemble_fragment(SSL *s, struct hm_header_st* msg_hdr, int *ok)\n\t{\n\thm_fragment *frag = NULL;\n\tpitem *item = NULL;\n\tint i = -1, is_complete;\n\tunsigned char seq64be[8];\n\tunsigned long frag_len = msg_hdr->frag_len, max_len;\n\tif ((msg_hdr->frag_off+frag_len) > msg_hdr->msg_len)\n\t\tgoto err;\n\tif (DTLS1_HM_HEADER_LENGTH + SSL3_RT_MAX_ENCRYPTED_LENGTH < s->max_cert_list)\n\t\tmax_len = s->max_cert_list;\n\telse\n\t\tmax_len = DTLS1_HM_HEADER_LENGTH + SSL3_RT_MAX_ENCRYPTED_LENGTH;\n\tif ((msg_hdr->frag_off+frag_len) > max_len)\n\t\tgoto err;\n\tmemset(seq64be,0,sizeof(seq64be));\n\tseq64be[6] = (unsigned char) (msg_hdr->seq>>8);\n\tseq64be[7] = (unsigned char) msg_hdr->seq;\n\titem = pqueue_find(s->d1->buffered_messages, seq64be);\n\tif (item == NULL)\n\t\t{\n\t\tfrag = dtls1_hm_fragment_new(msg_hdr->msg_len, 1);\n\t\tif ( frag == NULL)\n\t\t\tgoto err;\n\t\tmemcpy(&(frag->msg_header), msg_hdr, sizeof(*msg_hdr));\n\t\tfrag->msg_header.frag_len = frag->msg_header.msg_len;\n                frag->msg_header.frag_off = 0;\n                }\n        else\n                frag = (hm_fragment*) item->data;", "target": 1}
{"code": "static void php_snmp_error(zval *object, const char *docref, int type, const char *format, ...)\n{\n\tva_list args;\n\tphp_snmp_object *snmp_object = NULL;\n\tif (object) {\n\t\tsnmp_object = Z_SNMP_P(object);\n\t\tif (type == PHP_SNMP_ERRNO_NOERROR) {\n\t\t\tmemset(snmp_object->snmp_errstr, 0, sizeof(snmp_object->snmp_errstr));\n\t\t} else {\n\t\t\tva_start(args, format);\n\t\t\tvsnprintf(snmp_object->snmp_errstr, sizeof(snmp_object->snmp_errstr) - 1, format, args);\n\t\t\tva_end(args);\n\t\t}\n\t\tsnmp_object->snmp_errno = type;\n\t}\n\tif (type == PHP_SNMP_ERRNO_NOERROR) {\n\t\treturn;\n        }\n        if (object && (snmp_object->exceptions_enabled & type)) {\n               zend_throw_exception_ex(php_snmp_exception_ce, type, snmp_object->snmp_errstr);\n        } else {\n                va_start(args, format);\n                php_verror(docref, \"\", E_WARNING, format, args);\n\t\tva_end(args);\n\t}\n}", "target": 1}
{"code": "xmlDictComputeFastQKey(const xmlChar *prefix, int plen,\n                       const xmlChar *name, int len, int seed)\n{\n    unsigned long value = (unsigned long) seed;\n    if (plen == 0)\n\tvalue += 30 * (unsigned long) ':';\n    else\n\tvalue += 30 * (*prefix);\n    if (len > 10) {\n        value += name[len - (plen + 1 + 1)];\n        len = 10;\n\tif (plen > 10)\n\t    plen = 10;\n    }\n    switch (plen) {\n        case 10: value += prefix[9];\n        case 9: value += prefix[8];\n        case 8: value += prefix[7];\n        case 7: value += prefix[6];\n        case 6: value += prefix[5];\n        case 5: value += prefix[4];\n        case 4: value += prefix[3];\n        case 3: value += prefix[2];\n        case 2: value += prefix[1];\n        case 1: value += prefix[0];\n        default: break;\n    }\n    len -= plen;\n    if (len > 0) {\n        value += (unsigned long) ':';\n\tlen--;\n    }\n    switch (len) {\n        case 10: value += name[9];\n        case 9: value += name[8];\n        case 8: value += name[7];\n        case 7: value += name[6];\n        case 6: value += name[5];\n        case 5: value += name[4];\n        case 4: value += name[3];\n        case 3: value += name[2];\n        case 2: value += name[1];\n        case 1: value += name[0];\n        default: break;\n    }\n    return(value);\n}", "target": 1}
{"code": "static int override_release(char __user *release, int len)\n {\n \tint ret = 0;\n\tchar buf[65];\n \tif (current->personality & UNAME26) {\n\t\tchar *rest = UTS_RELEASE;\n \t\tint ndots = 0;\n \t\tunsigned v;\n \t\twhile (*rest) {\n \t\t\tif (*rest == '.' && ++ndots >= 3)\n\t\t\t\tbreak;\n\t\t\tif (!isdigit(*rest) && *rest != '.')\n\t\t\t\tbreak;\n \t\t\trest++;\n \t\t}\n \t\tv = ((LINUX_VERSION_CODE >> 8) & 0xff) + 40;\n\t\tsnprintf(buf, len, \"2.6.%u%s\", v, rest);\n\t\tret = copy_to_user(release, buf, len);\n \t}\n \treturn ret;\n }", "target": 1}
{"code": " long ssl_get_algorithm2(SSL *s)\n        {\n        long alg2 = s->s3->tmp.new_cipher->algorithm2;\n       if (TLS1_get_version(s) >= TLS1_2_VERSION &&\n            alg2 == (SSL_HANDSHAKE_MAC_DEFAULT|TLS1_PRF))\n                return SSL_HANDSHAKE_MAC_SHA256 | TLS1_PRF_SHA256;\n        return alg2;\n\t}", "target": 1}
{"code": "void RGWCORSRule::format_exp_headers(string& s) {\n  s = \"\";\n  for(list<string>::iterator it = exposable_hdrs.begin();\n      it != exposable_hdrs.end(); ++it) {\n      if (s.length() > 0)\n        s.append(\",\");\n      s.append((*it));\n  }\n}", "target": 1}
{"code": "void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick)\n{\n  const char *quote = \"`\\\"\\\\\";\n  if (!quote_backtick)\n    quote++;\n  char *pt = dest;\n  const char *s = src;\n  *pt++ = '\"';\n  dlen -= 2;\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      dlen -= 2;\n      if (dlen == 0)\n        break;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = '\\0';\n}", "target": 1}
{"code": "static int register_queue_kobjects(struct net_device *dev)\n{\n\tint error = 0, txq = 0, rxq = 0, real_rx = 0, real_tx = 0;\n#ifdef CONFIG_SYSFS\n\tdev->queues_kset = kset_create_and_add(\"queues\",\n\t\t\t\t\t       NULL, &dev->dev.kobj);\n\tif (!dev->queues_kset)\n\t\treturn -ENOMEM;\n\treal_rx = dev->real_num_rx_queues;\n#endif\n\treal_tx = dev->real_num_tx_queues;\n\terror = net_rx_queue_update_kobjects(dev, 0, real_rx);\n\tif (error)\n\t\tgoto error;\n\trxq = real_rx;\n\terror = netdev_queue_update_kobjects(dev, 0, real_tx);\n\tif (error)\n\t\tgoto error;\n\ttxq = real_tx;\n\treturn 0;\nerror:\n\tnetdev_queue_update_kobjects(dev, txq, 0);\n\tnet_rx_queue_update_kobjects(dev, rxq, 0);\n\treturn error;", "target": 1}
{"code": "static void parse_rtcp_bye(pjmedia_rtcp_session *sess,\n\t\t\t   const void *pkt,\n\t\t\t   pj_size_t size)\n{\n    pj_str_t reason = {\"-\", 1};\n    if (size > 8) {\n\treason.slen = PJ_MIN(sizeof(sess->stat.peer_sdes_buf_),\n                             *((pj_uint8_t*)pkt+8));\n\tpj_memcpy(sess->stat.peer_sdes_buf_, ((pj_uint8_t*)pkt+9),\n\t\t  reason.slen);\n\treason.ptr = sess->stat.peer_sdes_buf_;\n    }\n    PJ_LOG(5, (sess->name, \"Received RTCP BYE, reason: %.*s\",\n\t       reason.slen, reason.ptr));\n}", "target": 1}
{"code": "static int rfcomm_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t       struct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rfcomm_dlc *d = rfcomm_pi(sk)->dlc;\n\tint len;\n \tif (test_and_clear_bit(RFCOMM_DEFER_SETUP, &d->flags)) {\n \t\trfcomm_dlc_accept(d);\n \t\treturn 0;\n \t}\n\tlen = bt_sock_stream_recvmsg(iocb, sock, msg, size, flags);\n\tlock_sock(sk);\n\tif (!(flags & MSG_PEEK) && len > 0)\n\t\tatomic_sub(len, &sk->sk_rmem_alloc);\n\tif (atomic_read(&sk->sk_rmem_alloc) <= (sk->sk_rcvbuf >> 2))\n\t\trfcomm_dlc_unthrottle(rfcomm_pi(sk)->dlc);\n\trelease_sock(sk);\n\treturn len;\n}", "target": 1}
{"code": "lib_file_open(gs_file_path_ptr  lib_path, const gs_memory_t *mem, i_ctx_t *i_ctx_p,\n                       const char *fname, uint flen, char *buffer, int blen, uint *pclen, ref *pfile)\n{   \n    bool starting_arg_file = (i_ctx_p == NULL) ? true : i_ctx_p->starting_arg_file;\n    bool search_with_no_combine = false;\n    bool search_with_combine = false;\n    char fmode[2] = { 'r', 0};\n    gx_io_device *iodev = iodev_default(mem);\n     gs_main_instance *minst = get_minst_from_memory(mem);\n     int code;\n     if (iodev == 0)\n         iodev = (gx_io_device *)gx_io_device_table[0];\n       search_with_combine = false;\n    } else {\n       search_with_no_combine = starting_arg_file;\n       search_with_combine = true;\n    }", "target": 1}
{"code": "gst_mpegts_section_new (guint16 pid, guint8 * data, gsize data_size)\n{\n  GstMpegtsSection *res = NULL;\n  guint8 tmp;\n  guint8 table_id;\n  guint16 section_length;\n  section_length = GST_READ_UINT16_BE (data + 1) & 0x0FFF;\n  if (G_UNLIKELY (data_size < section_length + 3))\n    goto short_packet;\n  table_id = *data;\n  res = _gst_mpegts_section_init (pid, table_id);\n  res->data = data;\n  data++;\n  res->short_section = (*data & 0x80) == 0x00;\n  res->section_length = section_length + 3;\n  if (!res->short_section) {\n    res->crc = GST_READ_UINT32_BE (res->data + res->section_length - 4);\n    data += 2;\n    res->subtable_extension = GST_READ_UINT16_BE (data);\n    data += 2;\n    tmp = *data++;\n    res->version_number = tmp >> 1 & 0x1f;\n    res->current_next_indicator = tmp & 0x01;\n    res->section_number = *data++;\n    res->last_section_number = *data;\n  }\n  return res;\nshort_packet:\n  {\n    GST_WARNING\n        (\"PID 0x%04x section extends past provided data (got:%\" G_GSIZE_FORMAT\n        \", need:%d)\", pid, data_size, section_length + 3);\n    g_free (data);\n    return NULL;\n  }\n}", "target": 1}
{"code": "SCM_DEFINE (scm_mkdir, \"mkdir\", 1, 1, 0,\n            (SCM path, SCM mode),\n\t    \"Create a new directory named by @var{path}.  If @var{mode} is omitted\\n\"\n\t    \"then the permissions of the directory file are set using the current\\n\"\n\t    \"umask.  Otherwise they are set to the decimal value specified with\\n\"\n\t    \"@var{mode}.  The return value is unspecified.\")\n#define FUNC_NAME s_scm_mkdir\n{\n  int rv;\n  mode_t mask;\n  if (SCM_UNBNDP (mode))\n    {\n      mask = umask (0);\n      umask (mask);\n      STRING_SYSCALL (path, c_path, rv = mkdir (c_path, 0777 ^ mask));\n    }\n  else\n    {\n      STRING_SYSCALL (path, c_path, rv = mkdir (c_path, scm_to_uint (mode)));\n    }\n  if (rv != 0)\n    SCM_SYSERROR;\n  return SCM_UNSPECIFIED;\n}", "target": 1}
{"code": "void RenderLayerScrollableArea::setScrollOffset(const IntPoint& newScrollOffset)\n{\n    if (!box().isMarquee()) {\n        if (m_scrollDimensionsDirty)\n            computeScrollDimensions();\n    }\n    if (scrollOffset() == toIntSize(newScrollOffset))\n        return;\n    setScrollOffset(toIntSize(newScrollOffset));\n    LocalFrame* frame = box().frame();\n    ASSERT(frame);\n    RefPtr<FrameView> frameView = box().frameView();\n    TRACE_EVENT1(TRACE_DISABLED_BY_DEFAULT(\"devtools.timeline\"), \"ScrollLayer\", \"data\", InspectorScrollLayerEvent::data(&box()));\n    InspectorInstrumentation::willScrollLayer(&box());\n    const RenderLayerModelObject* paintInvalidationContainer = box().containerForPaintInvalidation();\n    if (!frameView->isInPerformLayout()) {\n        layer()->clipper().clearClipRectsIncludingDescendants();\n         box().setPreviousPaintInvalidationRect(box().boundsRectForPaintInvalidation(paintInvalidationContainer));\n         frameView->updateAnnotatedRegions();\n        frameView->updateWidgetPositions();\n        RELEASE_ASSERT(frameView->renderView());\n         updateCompositingLayersAfterScroll();\n     }\n    frame->selection().setCaretRectNeedsUpdate();\n    FloatQuad quadForFakeMouseMoveEvent = FloatQuad(layer()->renderer()->previousPaintInvalidationRect());\n    quadForFakeMouseMoveEvent = paintInvalidationContainer->localToAbsoluteQuad(quadForFakeMouseMoveEvent);\n    frame->eventHandler().dispatchFakeMouseMoveEventSoonInQuad(quadForFakeMouseMoveEvent);\n    bool requiresPaintInvalidation = true;\n    if (!box().isMarquee() && box().view()->compositor()->inCompositingMode()) {\n        DisableCompositingQueryAsserts disabler;\n        bool onlyScrolledCompositedLayers = scrollsOverflow()\n            && !layer()->hasVisibleNonLayerContent()\n            && !layer()->hasNonCompositedChild()\n            && !layer()->hasBlockSelectionGapBounds()\n            && box().style()->backgroundLayers().attachment() != LocalBackgroundAttachment;\n        if (usesCompositedScrolling() || onlyScrolledCompositedLayers)\n            requiresPaintInvalidation = false;\n    }\n    if (requiresPaintInvalidation) {\n        if (box().frameView()->isInPerformLayout())\n            box().setShouldDoFullPaintInvalidation(true);\n        else\n            box().invalidatePaintUsingContainer(paintInvalidationContainer, layer()->renderer()->previousPaintInvalidationRect(), InvalidationScroll);\n    }\n    if (box().node())\n        box().node()->document().enqueueScrollEventForNode(box().node());\n    if (AXObjectCache* cache = box().document().existingAXObjectCache())\n        cache->handleScrollPositionChanged(&box());\n    InspectorInstrumentation::didScrollLayer(&box());\n}", "target": 1}
{"code": "Curves16Data* CurvesAlloc(cmsContext ContextID, int nCurves, int nElements, cmsToneCurve** G)\n{\n    int i, j;\n    Curves16Data* c16;\n    c16 = _cmsMallocZero(ContextID, sizeof(Curves16Data));\n    if (c16 == NULL) return NULL;\n    c16 ->nCurves = nCurves;\n    c16 ->nElements = nElements;\n    c16 ->Curves = _cmsCalloc(ContextID, nCurves, sizeof(cmsUInt16Number*));\n    if (c16 ->Curves == NULL) return NULL;\n    for (i=0; i < nCurves; i++) {\n         c16->Curves[i] = _cmsCalloc(ContextID, nElements, sizeof(cmsUInt16Number));\n         if (nElements == 256) {\n             for (j=0; j < nElements; j++) {\n                c16 ->Curves[i][j] = cmsEvalToneCurve16(G[i], FROM_8_TO_16(j));\n            }\n        }\n        else {\n            for (j=0; j < nElements; j++) {\n                c16 ->Curves[i][j] = cmsEvalToneCurve16(G[i], (cmsUInt16Number) j);\n            }\n        }\n    }\n    return c16;\n}", "target": 1}
{"code": "skip_string(char_u *p)\n{\n    int\t    i;\n    for ( ; ; ++p)\n    {\n\tif (p[0] == '\\'')\t\t    \n\t{\n\t    if (p[1] == NUL)\t\t    \n\t\tbreak;\n\t    i = 2;\n\t    if (p[1] == '\\\\' && p[2] != NUL)    \n\t    {\n\t\t++i;\n\t\twhile (vim_isdigit(p[i - 1]))   \n\t\t    ++i;\n\t    }\n\t    if (p[i] == '\\'')\t\t    \n\t    {\n\t\tp += i;\n\t\tcontinue;\n\t    }\n\t}\n\telse if (p[0] == '\"')\t\t    \n\t{\n\t    for (++p; p[0]; ++p)\n\t    {\n\t\tif (p[0] == '\\\\' && p[1] != NUL)\n\t\t    ++p;\n\t\telse if (p[0] == '\"')\t    \n\t\t    break;\n\t    }\n\t    if (p[0] == '\"')\n\t\tcontinue; \n\t}\n\telse if (p[0] == 'R' && p[1] == '\"')\n\t{\n\t    char_u *delim = p + 2;\n\t    char_u *paren = vim_strchr(delim, '(');\n\t    if (paren != NULL)\n\t    {\n\t\tsize_t delim_len = paren - delim;\n\t\tfor (p += 3; *p; ++p)\n\t\t    if (p[0] == ')' && STRNCMP(p + 1, delim, delim_len) == 0\n\t\t\t    && p[delim_len + 1] == '\"')\n\t\t    {\n\t\t\tp += delim_len + 1;\n\t\t\tbreak;\n\t\t    }\n\t\tif (p[0] == '\"')\n\t\t    continue; \n\t    }\n\t}\n\tbreak;\t\t\t\t    \n    }\n    if (!*p)\n\t--p;\t\t\t\t    \n    return p;\n}", "target": 1}
{"code": "cnt_recv_prep(struct req *req, const char *ci)\n{\n\tconst char *xff;\n\tif (req->restarts == 0) {\n\t\thttp_CollectHdr(req->http, H_X_Forwarded_For);\n\t\tif (http_GetHdr(req->http, H_X_Forwarded_For, &xff)) {\n\t\t\thttp_Unset(req->http, H_X_Forwarded_For);\n\t\t\thttp_PrintfHeader(req->http, \"X-Forwarded-For: %s, %s\",\n\t\t\t    xff, ci);\n\t\t} else {\n\t\t\thttp_PrintfHeader(req->http, \"X-Forwarded-For: %s\", ci);\n\t\t}\n\t\thttp_CollectHdr(req->http, H_Cache_Control);\n\t\treq->director_hint = VCL_DefaultDirector(req->vcl);\n\t\treq->d_ttl = -1;\n\t\treq->d_grace = -1;\n\t\treq->disable_esi = 0;\n\t\treq->hash_always_miss = 0;\n\t\treq->hash_ignore_busy = 0;\n\t\treq->client_identity = NULL;\n\t\treq->storage = NULL;\n\t}\n\treq->vdc->retval = 0;\n\treq->is_hit = 0;\n\treq->is_hitmiss = 0;\n\treq->is_hitpass = 0;\n}", "target": 1}
{"code": "AMediaCodecCryptoInfo *AMediaCodecCryptoInfo_new(\n int numsubsamples,\n uint8_t key[16],\n uint8_t iv[16],\n cryptoinfo_mode_t mode,\n size_t *clearbytes,\n         size_t *encryptedbytes) {\n    size_t cryptosize = sizeof(AMediaCodecCryptoInfo) + sizeof(size_t) * numsubsamples * 2;\n     AMediaCodecCryptoInfo *ret = (AMediaCodecCryptoInfo*) malloc(cryptosize);\n     if (!ret) {\n         ALOGE(\"couldn't allocate %zu bytes\", cryptosize);\n return NULL;\n }\n    ret->numsubsamples = numsubsamples;\n    memcpy(ret->key, key, 16);\n    memcpy(ret->iv, iv, 16);\n    ret->mode = mode;\n    ret->pattern.encryptBlocks = 0;\n    ret->pattern.skipBlocks = 0;\n    ret->clearbytes = (size_t*) (ret + 1); \n    ret->encryptedbytes = ret->clearbytes + numsubsamples; \n    memcpy(ret->clearbytes, clearbytes, numsubsamples * sizeof(size_t));\n    memcpy(ret->encryptedbytes, encryptedbytes, numsubsamples * sizeof(size_t));\n return ret;\n}", "target": 1}
{"code": "void sctp_association_free(struct sctp_association *asoc)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tstruct sctp_transport *transport;\n\tstruct list_head *pos, *temp;\n\tint i;\n\tif (!asoc->temp) {\n \t\tlist_del(&asoc->asocs);\n\t\tif (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING))\n\t\t\tsk->sk_ack_backlog--;\n\t}\n\tasoc->base.dead = true;\n\tsctp_outq_free(&asoc->outqueue);\n\tsctp_ulpq_free(&asoc->ulpq);\n\tsctp_inq_free(&asoc->base.inqueue);\n\tsctp_tsnmap_free(&asoc->peer.tsn_map);\n\tsctp_ssnmap_free(asoc->ssnmap);\n\tsctp_bind_addr_free(&asoc->base.bind_addr);\n\tfor (i = SCTP_EVENT_TIMEOUT_NONE; i < SCTP_NUM_TIMEOUT_TYPES; ++i) {\n\t\tif (del_timer(&asoc->timers[i]))\n\t\t\tsctp_association_put(asoc);\n\t}\n\tkfree(asoc->peer.cookie);\n\tkfree(asoc->peer.peer_random);\n\tkfree(asoc->peer.peer_chunks);\n\tkfree(asoc->peer.peer_hmacs);\n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\ttransport = list_entry(pos, struct sctp_transport, transports);\n\t\tlist_del_rcu(pos);\n\t\tsctp_transport_free(transport);\n\t}\n\tasoc->peer.transport_count = 0;\n\tsctp_asconf_queue_teardown(asoc);\n\tif (asoc->asconf_addr_del_pending != NULL)\n\t\tkfree(asoc->asconf_addr_del_pending);\n\tsctp_auth_destroy_keys(&asoc->endpoint_shared_keys);\n\tsctp_auth_key_put(asoc->asoc_shared_key);\n\tsctp_association_put(asoc);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    INDEX_TYPE first_dimension;\n    OP_REQUIRES_OK(context, GetFirstDimensionSize(context, &first_dimension));\n    vector<INDEX_TYPE> output_size;\n    OP_REQUIRES_OK(context,\n                   CalculateOutputSize(first_dimension, context, &output_size));\n    vector<INDEX_TYPE> multiplier;\n    multiplier.resize(ragged_rank_ + 1);\n    multiplier[multiplier.size() - 1] = 1;\n    for (int i = multiplier.size() - 2; i >= 0; --i) {\n      multiplier[i] = multiplier[i + 1] * output_size[i + 1];\n    }\n    TensorShape output_shape;\n    OP_REQUIRES_OK(context,\n                   TensorShapeUtils::MakeShape(output_size, &output_shape));\n    Tensor* output_tensor = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, output_shape, &output_tensor));\n    const INDEX_TYPE full_size = multiplier[0] * output_size[0];\n    if (full_size > 0) {\n      vector<INDEX_TYPE> output_index, new_output_index;\n      int nvals = context->input(kValueInputIndex).shape().dim_size(0);\n      output_index.reserve(nvals);\n      new_output_index.reserve(nvals);\n      CalculateFirstParentOutputIndex(first_dimension, multiplier[0],\n                                      output_size[0], &output_index);\n      for (int i = 1; i <= ragged_rank_; ++i) {\n        OP_REQUIRES_OK(context, CalculateOutputIndex(\n                                    context, i - 1, output_index, multiplier[i],\n                                    output_size[i], &new_output_index));\n        output_index.swap(new_output_index);\n        new_output_index.clear();\n      }\n      SetOutput(context, ragged_rank_, output_index, output_tensor);\n    }\n  }", "target": 1}
{"code": "static void update_read_synchronize(rdpUpdate* update, wStream* s)\n{\n\tWINPR_UNUSED(update);\n\tStream_Seek_UINT16(s); \n}", "target": 1}
{"code": "njs_function_frame_save(njs_vm_t *vm, njs_frame_t *frame, u_char *pc)\n{\n    size_t              value_count, n;\n    njs_value_t         *start, *end, *p, **new, *value, **local;\n    njs_function_t      *function;\n    njs_native_frame_t  *active, *native;\n    *frame = *vm->active_frame;\n    frame->previous_active_frame = NULL;\n    native = &frame->native;\n    active = &vm->active_frame->native;\n    value_count = njs_function_frame_value_count(active);\n    function = active->function;\n    new = (njs_value_t **) ((u_char *) native + NJS_FRAME_SIZE);\n    value = (njs_value_t *) (new + value_count\n                             + function->u.lambda->temp);\n    native->arguments = value;\n    native->arguments_offset = value + (function->args_offset - 1);\n    native->local = new + njs_function_frame_args_count(active);\n    native->temp = new + value_count;\n    native->pc = pc;\n    start = njs_function_frame_values(active, &end);\n    p = native->arguments;\n    while (start < end) {\n        *p = *start++;\n        *new++ = p++;\n    }\n    p = native->arguments;\n    local = native->local + function->args_offset;\n    for (n = 0; n < function->args_count; n++) {\n        if (!njs_is_valid(p)) {\n            njs_set_undefined(p);\n        }\n        *local++ = p++;\n    }\n    return NJS_OK;\n}", "target": 1}
{"code": "static BOOL gdi_Bitmap_Decompress(rdpContext* context, rdpBitmap* bitmap,\n                                  const BYTE* pSrcData, UINT32 DstWidth, UINT32 DstHeight,\n                                  UINT32 bpp, UINT32 length, BOOL compressed,\n                                  UINT32 codecId)\n {\n \tUINT32 SrcSize = length;\n \trdpGdi* gdi = context->gdi;\n \tbitmap->compressed = FALSE;\n \tbitmap->format = gdi->dstFormat;\n\tbitmap->length = DstWidth * DstHeight * GetBytesPerPixel(bitmap->format);\n \tbitmap->data = (BYTE*) _aligned_malloc(bitmap->length, 16);\n \tif (!bitmap->data)\n\t\treturn FALSE;\n\tif (compressed)\n\t{\n\t\tif (bpp < 32)\n\t\t{\n\t\t\tif (!interleaved_decompress(context->codecs->interleaved,\n\t\t\t                            pSrcData, SrcSize,\n\t\t\t                            DstWidth, DstHeight,\n\t\t\t                            bpp,\n\t\t\t                            bitmap->data, bitmap->format,\n\t\t\t                            0, 0, 0, DstWidth, DstHeight,\n\t\t\t                            &gdi->palette))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!planar_decompress(context->codecs->planar, pSrcData, SrcSize,\n\t\t\t                       DstWidth, DstHeight,\n\t\t\t                       bitmap->data, bitmap->format, 0, 0, 0,\n\t\t\t                       DstWidth, DstHeight, TRUE))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tconst UINT32 SrcFormat = gdi_get_pixel_format(bpp);\n\t\tconst size_t sbpp = GetBytesPerPixel(SrcFormat);\n\t\tconst size_t dbpp = GetBytesPerPixel(bitmap->format);\n\t\tif ((sbpp == 0) || (dbpp == 0))\n\t\t\treturn FALSE;\n\t\telse\n\t\t{\n\t\t\tconst size_t dstSize = SrcSize * dbpp / sbpp;\n\t\t\tif (dstSize  < bitmap->length)\n\t\t\t\treturn FALSE;\n\t\t}\n\t\tif (!freerdp_image_copy(bitmap->data, bitmap->format, 0, 0, 0,\n\t\t                        DstWidth, DstHeight, pSrcData, SrcFormat,\n\t\t                        0, 0, 0, &gdi->palette, FREERDP_FLIP_VERTICAL))\n\t\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "writeDataError(instanceData *pData, cJSON **pReplyRoot, uchar *reqmsg)\n{\n\tchar *rendered = NULL;\n\tcJSON *errRoot;\n\tcJSON *req;\n\tcJSON *replyRoot = *pReplyRoot;\n\tsize_t toWrite;\n\tssize_t wrRet;\n\tchar errStr[1024];\n\tDEFiRet;\n\tif(pData->errorFile == NULL) {\n\t\tDBGPRINTF(\"omelasticsearch: no local error logger defined - \"\n\t\t          \"ignoring ES error information\\n\");\n\t\tFINALIZE;\n\t}\n\tif(pData->fdErrFile == -1) {\n\t\tpData->fdErrFile = open((char*)pData->errorFile,\n\t\t\t\t\tO_WRONLY|O_CREAT|O_APPEND|O_LARGEFILE|O_CLOEXEC,\n\t\t\t\t\tS_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP);\n\t\tif(pData->fdErrFile == -1) {\n\t\t\trs_strerror_r(errno, errStr, sizeof(errStr));\n\t\t\tDBGPRINTF(\"omelasticsearch: error opening error file: %s\\n\", errStr);\n\t\t\tABORT_FINALIZE(RS_RET_ERR);\n\t\t}\n\t}\n\tif((req=cJSON_CreateObject()) == NULL) ABORT_FINALIZE(RS_RET_ERR);\n\tcJSON_AddItemToObject(req, \"url\", cJSON_CreateString((char*)pData->restURL));\n\tcJSON_AddItemToObject(req, \"postdata\", cJSON_CreateString((char*)reqmsg));\n\tif((errRoot=cJSON_CreateObject()) == NULL) ABORT_FINALIZE(RS_RET_ERR);\n\tcJSON_AddItemToObject(errRoot, \"request\", req);\n\tcJSON_AddItemToObject(errRoot, \"reply\", replyRoot);\n\trendered = cJSON_Print(errRoot);\n\tDBGPRINTF(\"omelasticsearch: error record: '%s'\\n\", rendered);\n\ttoWrite = strlen(rendered);\n\twrRet = write(pData->fdErrFile, rendered, toWrite);\n\tif(wrRet != (ssize_t) toWrite) {\n\t\tDBGPRINTF(\"omelasticsearch: error %d writing error file, write returns %lld\\n\",\n\t\t\t  errno, (long long) wrRet);\n\t}\n\tfree(rendered);\n\tcJSON_Delete(errRoot);\n\t*pReplyRoot = NULL; \nfinalize_it:\n\tif(rendered != NULL)\n\t\tfree(rendered);\n\tRETiRet;\n}", "target": 1}
{"code": "  Ins_GETVARIATION( TT_ExecContext  exc,\n                    FT_Long*        args )\n  {\n    FT_UInt    num_axes = exc->face->blend->num_axis;\n    FT_Fixed*  coords   = exc->face->blend->normalizedcoords;\n    FT_UInt  i;\n    if ( BOUNDS( num_axes, exc->stackSize + 1 - exc->top ) )\n    {\n      exc->error = FT_THROW( Stack_Overflow );\n       return;\n     }\n    for ( i = 0; i < num_axes; i++ )\n      args[i] = coords[i] >> 2; \n   }", "target": 1}
{"code": "static void vhost_vdpa_config_put(struct vhost_vdpa *v)\n{\n\tif (v->config_ctx)\n\t\teventfd_ctx_put(v->config_ctx);\n}", "target": 1}
{"code": "ExprResolveBoolean(struct xkb_context *ctx, const ExprDef *expr,\n                   bool *set_rtrn)\n{\n    bool ok = false;\n    const char *ident;\n    switch (expr->expr.op) {\n    case EXPR_VALUE:\n        if (expr->expr.value_type != EXPR_TYPE_BOOLEAN) {\n            log_err(ctx,\n                    \"Found constant of type %s where boolean was expected\\n\",\n                    expr_value_type_to_string(expr->expr.value_type));\n            return false;\n        }\n        *set_rtrn = expr->boolean.set;\n        return true;\n    case EXPR_IDENT:\n        ident = xkb_atom_text(ctx, expr->ident.ident);\n        if (ident) {\n            if (istreq(ident, \"true\") ||\n                istreq(ident, \"yes\") ||\n                istreq(ident, \"on\")) {\n                *set_rtrn = true;\n                return true;\n            }\n            else if (istreq(ident, \"false\") ||\n                     istreq(ident, \"no\") ||\n                     istreq(ident, \"off\")) {\n                *set_rtrn = false;\n                return true;\n            }\n        }\n        log_err(ctx, \"Identifier \\\"%s\\\" of type boolean is unknown\\n\", ident);\n        return false;\n    case EXPR_FIELD_REF:\n        log_err(ctx, \"Default \\\"%s.%s\\\" of type boolean is unknown\\n\",\n                xkb_atom_text(ctx, expr->field_ref.element),\n                xkb_atom_text(ctx, expr->field_ref.field));\n        return false;\n     case EXPR_INVERT:\n     case EXPR_NOT:\n        ok = ExprResolveBoolean(ctx, expr, set_rtrn);\n         if (ok)\n             *set_rtrn = !*set_rtrn;\n         return ok;\n    case EXPR_ADD:\n    case EXPR_SUBTRACT:\n    case EXPR_MULTIPLY:\n    case EXPR_DIVIDE:\n    case EXPR_ASSIGN:\n    case EXPR_NEGATE:\n    case EXPR_UNARY_PLUS:\n        log_err(ctx, \"%s of boolean values not permitted\\n\",\n                expr_op_type_to_string(expr->expr.op));\n        break;\n    default:\n        log_wsgo(ctx, \"Unknown operator %d in ResolveBoolean\\n\",\n                 expr->expr.op);\n        break;\n    }\n    return false;\n}", "target": 1}
{"code": "bool Item_singlerow_subselect::fix_length_and_dec()\n{\n  if ((max_columns= engine->cols()) == 1)\n  {\n    if (engine->fix_length_and_dec(row= &value))\n      return TRUE;\n  }\n  else\n  {\n    if (!(row= (Item_cache**) current_thd->alloc(sizeof(Item_cache*) *\n                                                 max_columns)) ||\n        engine->fix_length_and_dec(row))\n      return TRUE;\n    value= *row;\n  }\n  unsigned_flag= value->unsigned_flag;\n  if (engine->no_tables())\n    maybe_null= engine->may_be_null();\n  else\n  {\n    for (uint i= 0; i < max_columns; i++)\n      row[i]->maybe_null= TRUE;\n  }\n  return FALSE;\n}", "target": 1}
{"code": "xmlDocPtr soap_xmlParseMemory(const void *buf, size_t buf_size)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n */\n        ctxt = xmlCreateMemoryParserCtxt(buf, buf_size);\n        if (ctxt) {\n                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n                ctxt->sax->comment = soap_Comment;\n                ctxt->sax->warning = NULL;\n#if LIBXML_VERSION >= 20703\n\t\tctxt->options |= XML_PARSE_HUGE;\n#endif\n\t\txmlParseDocument(ctxt);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "shiftAnchorPosition(AnchorList *al, HmarkerList *hl, int line, int pos,\n\t\t    int shift)\n{\n    Anchor *a;\n    size_t b, e, s = 0;\n    int cmp;\n    if (al == NULL || al->nanchor == 0)\n\treturn;\n    s = al->nanchor / 2;\n    for (b = 0, e = al->nanchor - 1; b <= e; s = (b + e + 1) / 2) {\n\ta = &al->anchors[s];\n\tcmp = onAnchor(a, line, pos);\n\tif (cmp == 0)\n\t    break;\n\telse if (cmp > 0)\n\t    b = s + 1;\n\telse if (s == 0)\n\t    break;\n\telse\n\t    e = s - 1;\n    }\n    for (; s < al->nanchor; s++) {\n\ta = &al->anchors[s];\n\tif (a->start.line > line)\n\t    break;\n\tif (a->start.pos > pos) {\n\t    a->start.pos += shift;\n\t    if (hl->marks[a->hseq].line == line)\n\t\thl->marks[a->hseq].pos = a->start.pos;\n\t}\n\tif (a->end.pos >= pos)\n\t    a->end.pos += shift;\n    }\n}", "target": 1}
{"code": "mt76_add_fragment(struct mt76_dev *dev, struct mt76_queue *q, void *data,\n\t\t  int len, bool more)\n{\n\tstruct page *page = virt_to_head_page(data);\n\tint offset = data - page_address(page);\n\tstruct sk_buff *skb = q->rx_head;\n\toffset += q->buf_offset;\n\tskb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page, offset, len,\n\t\t\tq->buf_size);\n\tif (more)\n\t\treturn;\n\tq->rx_head = NULL;\n\tdev->drv->rx_skb(dev, q - dev->q_rx, skb);\n}", "target": 1}
{"code": "std::string queueloader::get_filename(const std::string& str) {\n\tstd::string fn = ctrl->get_dlpath();\n\tif (fn[fn.length()-1] != NEWSBEUTER_PATH_SEP[0])\n\t\tfn.append(NEWSBEUTER_PATH_SEP);\n\tchar buf[1024];\n\tsnprintf(buf, sizeof(buf), \"%s\", str.c_str());\n\tchar * base = basename(buf);\n\tif (!base || strlen(base) == 0) {\n\t\tchar lbuf[128];\n\t\ttime_t t = time(NULL);\n\t\tstrftime(lbuf, sizeof(lbuf), \"%Y-%b-%d-%H%M%S.unknown\", localtime(&t));\n\t\tfn.append(lbuf);\n\t} else {\n\t\tfn.append(base);\n\t}\n\treturn fn;\n}", "target": 1}
{"code": "static int decode_bit_string(const u8 * inbuf, size_t inlen, void *outbuf,\n\t\t\t     size_t outlen, int invert)\n {\n \tconst u8 *in = inbuf;\n \tu8 *out = (u8 *) outbuf;\n\tint zero_bits = *in & 0x07;\n\tsize_t octets_left = inlen - 1;\n \tint i, count = 0;\n\tmemset(outbuf, 0, outlen);\n\tin++;\n \tif (outlen < octets_left)\n \t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n \tif (inlen < 1)\n \t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n \twhile (octets_left) {\n\t\tint bits_to_go;\n\t\t*out = 0;\n\t\tif (octets_left == 1)\n\t\t\tbits_to_go = 8 - zero_bits;\n\t\telse\n\t\t\tbits_to_go = 8;\n\t\tif (invert)\n\t\t\tfor (i = 0; i < bits_to_go; i++) {\n\t\t\t\t*out |= ((*in >> (7 - i)) & 1) << i;\n\t\t\t}\n\t\telse {\n\t\t\t*out = *in;\n\t\t}\n\t\tout++;\n\t\tin++;\n\t\toctets_left--;\n\t\tcount++;\n\t}\n\treturn (count * 8) - zero_bits;\n}", "target": 1}
{"code": "static bool on_accept(private_stroke_socket_t *this, stream_t *stream)\n{\n\tstroke_msg_t *msg;\n\tuint16_t len;\n\tFILE *out;\n\tif (!stream->read_all(stream, &len, sizeof(len)))\n\t{\n\t\tif (errno != EWOULDBLOCK)\n\t\t{\n\t\t\tDBG1(DBG_CFG, \"reading length of stroke message failed: %s\",\n\t\t\t\t strerror(errno));\n                }\n                return FALSE;\n        }\n        msg = malloc(len + 1);\n\t\t\tDBG1(DBG_CFG, \"reading stroke message failed: %s\", strerror(errno));\n\t\t}", "target": 1}
{"code": "static void check_pointer_type_change(Notifier *notifier, void *data)\n{\n    VncState *vs = container_of(notifier, VncState, mouse_mode_notifier);\n    int absolute = qemu_input_is_absolute();\n    if (vnc_has_feature(vs, VNC_FEATURE_POINTER_TYPE_CHANGE) && vs->absolute != absolute) {\n         vnc_write_u8(vs, 0);\n         vnc_write_u16(vs, 1);\n         vnc_framebuffer_update(vs, absolute, 0,\n                               surface_width(vs->vd->ds),\n                               surface_height(vs->vd->ds),\n                                VNC_ENCODING_POINTER_TYPE_CHANGE);\n         vnc_unlock_output(vs);\n         vnc_flush(vs);\n        vnc_unlock_output(vs);\n        vnc_flush(vs);\n    }\n    vs->absolute = absolute;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor* stamp_token_t;\n    OP_REQUIRES_OK(context, context->input(\"stamp_token\", &stamp_token_t));\n    int64_t stamp_token = stamp_token_t->scalar<int64>()();\n    const Tensor* tree_ensemble_serialized_t;\n    OP_REQUIRES_OK(context, context->input(\"tree_ensemble_serialized\",\n                                           &tree_ensemble_serialized_t));\n    std::unique_ptr<BoostedTreesEnsembleResource> result(\n        new BoostedTreesEnsembleResource());\n    if (!result->InitFromSerialized(\n            tree_ensemble_serialized_t->scalar<tstring>()(), stamp_token)) {\n      result->Unref();\n      OP_REQUIRES(\n          context, false,\n          errors::InvalidArgument(\"Unable to parse tree ensemble proto.\"));\n    }\n    auto status =\n        CreateResource(context, HandleFromInput(context, 0), result.release());\n    if (status.code() != tensorflow::error::ALREADY_EXISTS) {\n      OP_REQUIRES_OK(context, status);\n    }\n  }", "target": 1}
{"code": "p11_rpc_buffer_get_attribute (p11_buffer *buffer,\n\t\t\t      size_t *offset,\n\t\t\t      CK_ATTRIBUTE *attr)\n{\n\tuint32_t type, length;\n\tunsigned char validity;\n\tp11_rpc_attribute_serializer *serializer;\n\tp11_rpc_value_type value_type;\n\tif (!p11_rpc_buffer_get_uint32 (buffer, offset, &type))\n\t\treturn false;\n\tif (!p11_rpc_buffer_get_byte (buffer, offset, &validity))\n\t\treturn false;\n\tif (!validity) {\n\t\tattr->ulValueLen = ((CK_ULONG)-1);\n\t\tattr->type = type;\n\t\treturn true;\n\t}\n\tif (!p11_rpc_buffer_get_uint32 (buffer, offset, &length))\n\t\treturn false;\n\tvalue_type = map_attribute_to_value_type (type);\n\tassert (value_type < ELEMS (p11_rpc_attribute_serializers));\n\tserializer = &p11_rpc_attribute_serializers[value_type];\n\tassert (serializer != NULL);\n\tif (!serializer->decode (buffer, offset, attr->pValue, &attr->ulValueLen))\n\t\treturn false;\n\tif (!attr->pValue)\n\t\tattr->ulValueLen = length;\n\tattr->type = type;\n\treturn true;\n}", "target": 1}
{"code": "void dmar_free_irte(const struct intr_source *intr_src, uint16_t index)\n{\n\tstruct dmar_drhd_rt *dmar_unit;\n\tunion dmar_ir_entry *ir_table, *ir_entry;\n\tunion pci_bdf sid;\n\tif (intr_src->is_msi) {\n\t\tdmar_unit = device_to_dmaru((uint8_t)intr_src->src.msi.bits.b, intr_src->src.msi.fields.devfun);\n\t} else {\n\t\tdmar_unit = ioapic_to_dmaru(intr_src->src.ioapic_id, &sid);\n\t}\n\tif (is_dmar_unit_valid(dmar_unit, sid)) {\n\t\tir_table = (union dmar_ir_entry *)hpa2hva(dmar_unit->ir_table_addr);\n\t\tir_entry = ir_table + index;\n\t\tir_entry->bits.remap.present = 0x0UL;\n\t\tiommu_flush_cache(ir_entry, sizeof(union dmar_ir_entry));\n\t\tdmar_invalid_iec(dmar_unit, index, 0U, false);\n\t\tif (!is_irte_reserved(dmar_unit, index)) {\n\t\t\tspinlock_obtain(&dmar_unit->lock);\n\t\t\tbitmap_clear_nolock(index & 0x3FU, &dmar_unit->irte_alloc_bitmap[index >> 6U]);\n\t\t\tspinlock_release(&dmar_unit->lock);\n\t\t}\n\t}\n}", "target": 1}
{"code": "void set_fat(DOS_FS * fs, uint32_t cluster, int32_t new)\n{\n    unsigned char *data = NULL;\n    int size;\n    loff_t offs;\n    if (new == -1)\n\tnew = FAT_EOF(fs);\n    else if ((long)new == -2)\n\tnew = FAT_BAD(fs);\n    switch (fs->fat_bits) {\n    case 12:\n\tdata = fs->fat + cluster * 3 / 2;\n\toffs = fs->fat_start + cluster * 3 / 2;\n\tif (cluster & 1) {\n\t    FAT_ENTRY prevEntry;\n\t    get_fat(&prevEntry, fs->fat, cluster - 1, fs);\n\t    data[0] = ((new & 0xf) << 4) | (prevEntry.value >> 8);\n \t    data[1] = new >> 4;\n \t} else {\n \t    FAT_ENTRY subseqEntry;\n\t    if (cluster != fs->clusters - 1)\n \t\tget_fat(&subseqEntry, fs->fat, cluster + 1, fs);\n \t    else\n \t\tsubseqEntry.value = 0;\n\t    data[0] = new & 0xff;\n\t    data[1] = (new >> 8) | ((0xff & subseqEntry.value) << 4);\n\t}\n\tsize = 2;\n\tbreak;\n    case 16:\n\tdata = fs->fat + cluster * 2;\n\toffs = fs->fat_start + cluster * 2;\n\t*(unsigned short *)data = htole16(new);\n\tsize = 2;\n\tbreak;\n    case 32:\n\t{\n\t    FAT_ENTRY curEntry;\n\t    get_fat(&curEntry, fs->fat, cluster, fs);\n\t    data = fs->fat + cluster * 4;\n\t    offs = fs->fat_start + cluster * 4;\n\t    *(uint32_t *)data = htole32((new & 0xfffffff) |\n\t\t\t\t\t     (curEntry.reserved << 28));\n\t    size = 4;\n\t}\n\tbreak;\n    default:\n\tdie(\"Bad FAT entry size: %d bits.\", fs->fat_bits);\n    }\n    fs_write(offs, size, data);\n    if (fs->nfats > 1) {\n\tfs_write(offs + fs->fat_size, size, data);\n    }\n}", "target": 1}
{"code": "void json_object_seed(size_t seed) {\n    uint32_t new_seed = (uint32_t)seed;\n    if (hashtable_seed == 0) {\n        if (__atomic_test_and_set(&seed_initialized, __ATOMIC_RELAXED) == 0) {\n            if (new_seed == 0)\n                new_seed = generate_seed();\n            __atomic_store_n(&hashtable_seed, new_seed, __ATOMIC_ACQ_REL);\n        } else {\n            do {\n#ifdef HAVE_SCHED_YIELD\n                sched_yield();\n#endif\n            } while(__atomic_load_n(&hashtable_seed, __ATOMIC_ACQUIRE) == 0);\n        }\n    }\n}", "target": 1}
{"code": "void SimpleModule::runPull()\n{\n\tpull(m_outChunk->frameCount);\n\trun(*m_inChunk, *m_outChunk);\n}", "target": 1}
{"code": " chdlc_print(netdissect_options *ndo, register const u_char *p, u_int length)\n {\n \tu_int proto;\n \tproto = EXTRACT_16BITS(&p[2]);\n \tif (ndo->ndo_eflag) {\n                 ND_PRINT((ndo, \"%s, ethertype %s (0x%04x), length %u: \",\n                       tok2str(chdlc_cast_values, \"0x%02x\", p[0]),\n                       tok2str(ethertype_values, \"Unknown\", proto),\n                       proto,\n                       length));\n\t}\n\tlength -= CHDLC_HDRLEN;\n\tp += CHDLC_HDRLEN;\n\tswitch (proto) {\n\tcase ETHERTYPE_IP:\n\t\tip_print(ndo, p, length);\n\t\tbreak;\n\tcase ETHERTYPE_IPV6:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\tcase CHDLC_TYPE_SLARP:\n\t\tchdlc_slarp_print(ndo, p, length);\n\t\tbreak;\n#if 0\n\tcase CHDLC_TYPE_CDP:\n\t\tchdlc_cdp_print(p, length);\n\t\tbreak;\n#endif\n        case ETHERTYPE_MPLS:\n        case ETHERTYPE_MPLS_MULTI:\n                mpls_print(ndo, p, length);\n \t\tbreak;\n         case ETHERTYPE_ISO:\n                 if (*(p+1) == 0x81 ||\n                     *(p+1) == 0x82 ||\n                     *(p+1) == 0x83)\n                    isoclns_print(ndo, p + 1, length - 1, ndo->ndo_snapend - p - 1);\n                else\n                    isoclns_print(ndo, p, length, ndo->ndo_snapend - p);\n                break;\n\tdefault:\n                if (!ndo->ndo_eflag)\n                        ND_PRINT((ndo, \"unknown CHDLC protocol (0x%04x)\", proto));\n                break;\n \t}\n \treturn (CHDLC_HDRLEN);\n }", "target": 1}
{"code": "static int pit_ioport_read(struct kvm_io_device *this,\n\t\t\t   gpa_t addr, int len, void *data)\n{\n\tstruct kvm_pit *pit = dev_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\tint ret, count;\n\tstruct kvm_kpit_channel_state *s;\n\tif (!pit_in_range(addr))\n \t\treturn -EOPNOTSUPP;\n \taddr &= KVM_PIT_CHANNEL_MASK;\n \ts = &pit_state->channels[addr];\n \tmutex_lock(&pit_state->lock);\n\tif (s->status_latched) {\n\t\ts->status_latched = 0;\n\t\tret = s->status;\n\t} else if (s->count_latched) {\n\t\tswitch (s->count_latched) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tret = s->latched_count & 0xff;\n\t\t\ts->count_latched = 0;\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tret = s->latched_count >> 8;\n\t\t\ts->count_latched = 0;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\tret = s->latched_count & 0xff;\n\t\t\ts->count_latched = RW_STATE_MSB;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (s->read_state) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = count & 0xff;\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = (count >> 8) & 0xff;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = count & 0xff;\n\t\t\ts->read_state = RW_STATE_WORD1;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD1:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = (count >> 8) & 0xff;\n\t\t\ts->read_state = RW_STATE_WORD0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (len > sizeof(ret))\n\t\tlen = sizeof(ret);\n\tmemcpy(data, (char *)&ret, len);\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}", "target": 1}
{"code": "void __split_huge_pmd(struct vm_area_struct *vma, pmd_t *pmd,\n\t\tunsigned long address, bool freeze, struct page *page)\n{\n\tspinlock_t *ptl;\n\tstruct mmu_notifier_range range;\n\tmmu_notifier_range_init(&range, MMU_NOTIFY_CLEAR, 0, vma, vma->vm_mm,\n\t\t\t\taddress & HPAGE_PMD_MASK,\n\t\t\t\t(address & HPAGE_PMD_MASK) + HPAGE_PMD_SIZE);\n\tmmu_notifier_invalidate_range_start(&range);\n\tptl = pmd_lock(vma->vm_mm, pmd);\n\tVM_BUG_ON(freeze && !page);\n\tif (page && page != pmd_page(*pmd))\n\t        goto out;\n\tif (pmd_trans_huge(*pmd)) {\n\t\tpage = pmd_page(*pmd);\n\t\tif (PageMlocked(page))\n\t\t\tclear_page_mlock(page);\n\t} else if (!(pmd_devmap(*pmd) || is_pmd_migration_entry(*pmd)))\n\t\tgoto out;\n\t__split_huge_pmd_locked(vma, pmd, range.start, freeze);\nout:\n\tspin_unlock(ptl);\n\tmmu_notifier_invalidate_range_only_end(&range);\n}", "target": 1}
{"code": "int wsrep_sst_donate(const std::string &msg, const wsrep::gtid &current_gtid,\n                     const bool bypass) {\n  local_status.set(wsrep::server_state::s_donor);\n  const char *method = msg.data();\n  size_t method_len = strlen(method);\n  const char *data = method + method_len + 1;\n  wsp::env env(NULL);\n  if (env.error()) {\n    WSREP_ERROR(\"wsrep_sst_donate_cb(): env var ctor failed: %d\", -env.error());\n    return WSREP_CB_FAILURE;\n  }\n#if 0\n  while (!wsrep_is_SE_initialized()) {\n    sleep(1);\n    THD *applier_thd = static_cast<THD *>(recv_ctx);\n    if (applier_thd->killed == THD::KILL_CONNECTION) return WSREP_CB_FAILURE;\n  }\n#endif\n  int ret;\n  ret = sst_donate_other(method, data, current_gtid, bypass, env());\n  return (ret >= 0 ? WSREP_CB_SUCCESS : WSREP_CB_FAILURE);\n}", "target": 1}
{"code": "static void touch_pmd(struct vm_area_struct *vma, unsigned long addr,\n\t\tpmd_t *pmd)\n{\n\tpmd_t _pmd;\n\t_pmd = pmd_mkyoung(pmd_mkdirty(*pmd));\n\tif (pmdp_set_access_flags(vma, addr & HPAGE_PMD_MASK,\n\t\t\t\tpmd, _pmd,  1))\n\t\tupdate_mmu_cache_pmd(vma, addr, pmd);\n}", "target": 1}
{"code": "Status SparseCountSparseOutputShapeFn(InferenceContext *c) {\n  auto rank = c->Dim(c->input(0), 1);\n  auto nvals = c->UnknownDim();\n  c->set_output(0, c->Matrix(nvals, rank));  \n  c->set_output(1, c->Vector(nvals));        \n  c->set_output(2, c->Vector(rank));         \n  return Status::OK();\n}", "target": 1}
{"code": "rdpdr_process(STREAM s)\n{\n\tuint32 handle;\n \tuint16 vmin;\n \tuint16 component;\n \tuint16 pakid;\n \tlogger(Protocol, Debug, \"rdpdr_process()\");\n\tin_uint16(s, component);\n\tin_uint16(s, pakid);\n\tif (component == RDPDR_CTYP_CORE)\n\t{\n\t\tswitch (pakid)\n\t\t{\n\t\t\tcase PAKID_CORE_DEVICE_IOREQUEST:\n\t\t\t\trdpdr_process_irp(s);\n\t\t\t\tbreak;\n\t\t\tcase PAKID_CORE_SERVER_ANNOUNCE:\n \t\t\t\tin_uint8s(s, 2);\t\n \t\t\t\tin_uint16_le(s, vmin);\t\n \t\t\t\tin_uint32_le(s, g_client_id);\t\n \t\t\t\tif (vmin < 0x000c)\n\t\t\t\t\tg_client_id = 0x815ed39d;\t\n\t\t\t\tg_epoch++;\n#if WITH_SCARD\n\t\t\t\tscard_release_all_contexts();\n#endif\n\t\t\t\trdpdr_send_client_announce_reply();\n\t\t\t\trdpdr_send_client_name_request();\n\t\t\t\tbreak;\n\t\t\tcase PAKID_CORE_CLIENTID_CONFIRM:\n\t\t\t\trdpdr_send_client_device_list_announce();\n\t\t\t\tbreak;\n\t\t\tcase PAKID_CORE_DEVICE_REPLY:\n\t\t\t\tin_uint32(s, handle);\n\t\t\t\tlogger(Protocol, Debug,\n\t\t\t\t       \"rdpdr_process(), server connected to resource %d\", handle);\n\t\t\t\tbreak;\n\t\t\tcase PAKID_CORE_SERVER_CAPABILITY:\n\t\t\t\trdpdr_send_client_capability_response();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlogger(Protocol, Debug,\n\t\t\t\t       \"rdpdr_process(), pakid 0x%x of component 0x%x\", pakid,\n\t\t\t\t       component);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse if (component == RDPDR_CTYP_PRN)\n\t{\n\t\tif (pakid == PAKID_PRN_CACHE_DATA)\n\t\t\tprintercache_process(s);\n\t}\n\telse\n\t\tlogger(Protocol, Warning, \"rdpdr_process(), unhandled component 0x%x\", component);\n}", "target": 1}
{"code": "static struct scatterlist *alloc_sgtable(int size)\n{\n\tint alloc_size, nents, i;\n\tstruct page *new_page;\n\tstruct scatterlist *iter;\n\tstruct scatterlist *table;\n\tnents = DIV_ROUND_UP(size, PAGE_SIZE);\n\ttable = kcalloc(nents, sizeof(*table), GFP_KERNEL);\n\tif (!table)\n\t\treturn NULL;\n\tsg_init_table(table, nents);\n\titer = table;\n\tfor_each_sg(table, iter, sg_nents(table), i) {\n\t\tnew_page = alloc_page(GFP_KERNEL);\n\t\tif (!new_page) {\n\t\t\titer = table;\n\t\t\tfor_each_sg(table, iter, sg_nents(table), i) {\n\t\t\t\tnew_page = sg_page(iter);\n\t\t\t\tif (new_page)\n\t\t\t\t\t__free_page(new_page);\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\talloc_size = min_t(int, size, PAGE_SIZE);\n\t\tsize -= PAGE_SIZE;\n\t\tsg_set_page(iter, new_page, alloc_size, 0);\n\t}\n\treturn table;\n}", "target": 1}
{"code": " bool BaseSettingChange::Init(Profile* profile) {\n  DCHECK(profile);\n   profile_ = profile;\n   return true;\n }", "target": 1}
{"code": "static int cypress_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct cypress_private *priv = usb_get_serial_port_data(port);\n\tstruct usb_serial *serial = port->serial;\n\tunsigned long flags;\n\tint result = 0;\n\tif (!priv->comm_is_ok)\n\t\treturn -EIO;\n\tusb_clear_halt(serial->dev, 0x81);\n\tusb_clear_halt(serial->dev, 0x02);\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpriv->bytes_in = 0;\n\tpriv->bytes_out = 0;\n\tpriv->cmd_count = 0;\n\tpriv->rx_flags = 0;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\tcypress_send(port);\n\tif (tty)\n \t\tcypress_set_termios(tty, port, &priv->tmp_termios);\n\tif (!port->interrupt_in_urb) {\n\t\tdev_err(&port->dev, \"%s - interrupt_in_urb is empty!\\n\",\n\t\t\t__func__);\n\t\treturn -1;\n\t}\n \tusb_fill_int_urb(port->interrupt_in_urb, serial->dev,\n \t\tusb_rcvintpipe(serial->dev, port->interrupt_in_endpointAddress),\n \t\tport->interrupt_in_urb->transfer_buffer,\n\t\tport->interrupt_in_urb->transfer_buffer_length,\n\t\tcypress_read_int_callback, port, priv->read_urb_interval);\n\tresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\n\tif (result) {\n\t\tdev_err(&port->dev,\n\t\t\t\"%s - failed submitting read urb, error %d\\n\",\n\t\t\t\t\t\t\t__func__, result);\n\t\tcypress_set_dead(port);\n\t}\n\treturn result;\n} ", "target": 1}
{"code": " static inline void schedule_debug(struct task_struct *prev)\n {\n #ifdef CONFIG_SCHED_STACK_END_CHECK\n\tBUG_ON(task_stack_end_corrupted(prev));\n #endif\n \tif (unlikely(in_atomic_preempt_off())) {\n\t\t__schedule_bug(prev);\n\t\tpreempt_count_set(PREEMPT_DISABLED);\n\t}\n\trcu_sleep_check();\n\tprofile_hit(SCHED_PROFILING, __builtin_return_address(0));\n\tschedstat_inc(this_rq(), sched_count);\n}", "target": 1}
{"code": "static OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *\n        p_code_block)\n {\n     OPJ_UINT32 l_data_size;\n    l_data_size = (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) *\n                               (p_code_block->y1 - p_code_block->y0) * (OPJ_INT32)sizeof(OPJ_UINT32));\n     if (l_data_size > p_code_block->data_size) {\n         if (p_code_block->data) {\n            opj_free(p_code_block->data - 1);\n        }\n        p_code_block->data = (OPJ_BYTE*) opj_malloc(l_data_size + 1);\n        if (! p_code_block->data) {\n            p_code_block->data_size = 0U;\n            return OPJ_FALSE;\n        }\n        p_code_block->data_size = l_data_size;\n        p_code_block->data[0] = 0;\n        p_code_block->data += 1; \n    }\n    return OPJ_TRUE;\n}", "target": 1}
{"code": "static int copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb)\n{\n\tstruct xfrm_algo *algo;\n\tstruct nlattr *nla;\n\tnla = nla_reserve(skb, XFRMA_ALG_AUTH,\n\t\t\t  sizeof(*algo) + (auth->alg_key_len + 7) / 8);\n\tif (!nla)\n \t\treturn -EMSGSIZE;\n \talgo = nla_data(nla);\n\tstrcpy(algo->alg_name, auth->alg_name);\n \tmemcpy(algo->alg_key, auth->alg_key, (auth->alg_key_len + 7) / 8);\n \talgo->alg_key_len = auth->alg_key_len;\n\treturn 0;\n}", "target": 1}
{"code": "GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>\"\n\t\t\"</u:%sResponse>\";\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * int_ip, * int_port, * rem_host, * rem_port, * protocol;\n\tint opt=0;\n\tunsigned short iport, rport;\n\tif (GETFLAG(IPV6FCFWDISABLEDMASK))\n\t{\n\t\tSoapError(h, 702, \"FirewallDisabled\");\n\t\treturn;\n\t}\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tint_ip = GetValueFromNameValueList(&data, \"InternalClient\");\n\tint_port = GetValueFromNameValueList(&data, \"InternalPort\");\n\trem_host = GetValueFromNameValueList(&data, \"RemoteHost\");\n \trem_port = GetValueFromNameValueList(&data, \"RemotePort\");\n \tprotocol = GetValueFromNameValueList(&data, \"Protocol\");\n \trport = (unsigned short)atoi(rem_port);\n \tiport = (unsigned short)atoi(int_port);\n\tsyslog(LOG_INFO, \"%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s\", action, int_ip, iport,rem_host, rport, protocol);\n\tr = -1;\n\tswitch(r)\n\t{\n\t\tcase 1:\t\n\t\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t                   action, ns,\n\t\t\t                   opt, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t\tbreak;\n\t\tcase -5:\t\n\t\t\tSoapError(h, 705, \"ProtocolNotSupported\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSoapError(h, 501, \"ActionFailed\");\n\t}\n\tClearNameValueList(&data);\n}", "target": 1}
{"code": "void put_busid_priv(struct bus_id_priv *bid)\n{\n\tspin_unlock(&bid->busid_lock);\n}", "target": 1}
{"code": "iscsi_aio_ioctl_cb(struct iscsi_context *iscsi, int status,\n                     void *command_data, void *opaque)\n{\n    IscsiAIOCB *acb = opaque;\n    if (status == SCSI_STATUS_CANCELLED) {\n        if (!acb->bh) {\n            acb->status = -ECANCELED;\n            iscsi_schedule_bh(acb);\n        }\n        return;\n    }\n    acb->status = 0;\n    if (status < 0) {\n        error_report(\"Failed to ioctl(SG_IO) to iSCSI lun. %s\",\n                     iscsi_get_error(iscsi));\n        acb->status = -iscsi_translate_sense(&acb->task->sense);\n    }\n    acb->ioh->driver_status = 0;\n    acb->ioh->host_status   = 0;\n    acb->ioh->resid         = 0;\n    acb->ioh->status        = status;\n#define SG_ERR_DRIVER_SENSE    0x08\n    if (status == SCSI_STATUS_CHECK_CONDITION && acb->task->datain.size >= 2) {\n        int ss;\n        acb->ioh->driver_status |= SG_ERR_DRIVER_SENSE;\n        acb->ioh->sb_len_wr = acb->task->datain.size - 2;\n        ss = (acb->ioh->mx_sb_len >= acb->ioh->sb_len_wr) ?\n             acb->ioh->mx_sb_len : acb->ioh->sb_len_wr;\n        memcpy(acb->ioh->sbp, &acb->task->datain.data[2], ss);\n    }\n    iscsi_schedule_bh(acb);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& handle = ctx->input(0);\n    const string& name = handle.scalar<tstring>()();\n    auto session_state = ctx->session_state();\n    OP_REQUIRES(ctx, session_state != nullptr,\n                errors::FailedPrecondition(\n                    \"DeleteSessionTensor called on null session state\"));\n    OP_REQUIRES_OK(ctx, session_state->DeleteTensor(name));\n  }", "target": 1}
{"code": "bool SoftVPX::outputBufferSafe(OMX_BUFFERHEADERTYPE *outHeader) {\n uint32_t width = outputBufferWidth();\n uint32_t height = outputBufferHeight();\n     uint64_t nFilledLen = width;\n     nFilledLen *= height;\n     if (nFilledLen > UINT32_MAX / 3) {\n        ALOGE(\"b/29421675, nFilledLen overflow %llu w %u h %u\", nFilledLen, width, height);\n         android_errorWriteLog(0x534e4554, \"29421675\");\n         return false;\n     } else if (outHeader->nAllocLen < outHeader->nFilledLen) {\n        ALOGE(\"b/27597103, buffer too small\");\n        android_errorWriteLog(0x534e4554, \"27597103\");\n return false;\n }\n return true;\n}", "target": 1}
{"code": "TerminalUserInfo UserTerminalRouter::getInfoForId(const string &id) {\n  auto it = idInfoMap.find(id);\n  if (it == idInfoMap.end()) {\n    STFATAL << \" Tried to read from an id that no longer exists\";\n  }\n  return it->second;\n}", "target": 1}
{"code": "void Http2Stream::SubmitRstStream(const uint32_t code) {\n  CHECK(!this->is_destroyed());\n  code_ = code;\n  if (session_->is_in_scope() &&\n      !is_writable() && is_reading()) {\n    session_->AddPendingRstStream(id_);\n    return;\n  }\n  if (session_->SendPendingData() != 0) {\n    session_->AddPendingRstStream(id_);\n    return;\n  }\n  FlushRstStream();\n}", "target": 1}
{"code": "aspath_put (struct stream *s, struct aspath *as, int use32bit )\n{\n  struct assegment *seg = as->segments;\n  size_t bytes = 0;\n  if (!seg || seg->length == 0)\n    return 0;\n  if (seg)\n    {\n      while (seg && (ASSEGMENT_LEN(seg, use32bit) <= STREAM_WRITEABLE(s)))\n        {\n          struct assegment *next = seg->next;\n          int written = 0;\n          int asns_packed = 0;\n          size_t lenp;\n          while ( (seg->length - written) > AS_SEGMENT_MAX)\n            {\n               assegment_header_put (s, seg->type, AS_SEGMENT_MAX);\n               assegment_data_put (s, seg->as, AS_SEGMENT_MAX, use32bit);\n               written += AS_SEGMENT_MAX;\n              bytes += ASSEGMENT_SIZE (written, use32bit);\n             }\n          lenp = assegment_header_put (s, seg->type, seg->length - written);\n          assegment_data_put (s, (seg->as + written), seg->length - written, \n                              use32bit);\n          while (next && ASSEGMENTS_PACKABLE (seg, next))\n            {\n              assegment_data_put (s, next->as, next->length, use32bit);\n\t      stream_putc_at (s, lenp, seg->length - written + next->length);\n              asns_packed += next->length;\n\t      next = next->next;\n\t    }\n          bytes += ASSEGMENT_SIZE (seg->length - written + asns_packed, \n\t\t\t\t   use32bit);\n          seg = next;\n        }\n    }\n  return bytes;\n}", "target": 1}
{"code": "inline bool loadModule(const char* filename, IR::Module& outModule)\n{\n\tstd::vector<U8> fileBytes;\n\tif(!loadFile(filename, fileBytes)) { return false; }\n\tif(*(U32*)fileBytes.data() == 0x6d736100)\n\t{ return loadBinaryModule(fileBytes.data(), fileBytes.size(), outModule); }\n\telse\n\t{\n\t\tfileBytes.push_back(0);\n\t\tstd::vector<WAST::Error> parseErrors;\n\t\tif(!WAST::parseModule(\n\t\t\t   (const char*)fileBytes.data(), fileBytes.size(), outModule, parseErrors))\n\t\t{\n\t\t\tLog::printf(Log::error, \"Error parsing WebAssembly text file:\\n\");\n\t\t\treportParseErrors(filename, parseErrors);\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}", "target": 1}
{"code": "u_undo_end(\n    int\t\tdid_undo,\t\n    int\t\tabsolute)\t\n{\n    char\t*msgstr;\n    u_header_T\t*uhp;\n    char_u\tmsgbuf[80];\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_UNDO) && KeyTyped)\n\tfoldOpenCursor();\n#endif\n    if (global_busy\t    \n\t    || !messaging())  \n\treturn;\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\t--u_newcount;\n    u_oldcount -= u_newcount;\n    if (u_oldcount == -1)\n\tmsgstr = N_(\"more line\");\n    else if (u_oldcount < 0)\n\tmsgstr = N_(\"more lines\");\n    else if (u_oldcount == 1)\n\tmsgstr = N_(\"line less\");\n    else if (u_oldcount > 1)\n\tmsgstr = N_(\"fewer lines\");\n    else\n    {\n\tu_oldcount = u_newcount;\n\tif (u_newcount == 1)\n\t    msgstr = N_(\"change\");\n\telse\n\t    msgstr = N_(\"changes\");\n    }\n    if (curbuf->b_u_curhead != NULL)\n    {\n\tif (absolute && curbuf->b_u_curhead->uh_next.ptr != NULL)\n\t{\n\t    uhp = curbuf->b_u_curhead->uh_next.ptr;\n\t    did_undo = FALSE;\n\t}\n\telse if (did_undo)\n\t    uhp = curbuf->b_u_curhead;\n\telse\n\t    uhp = curbuf->b_u_curhead->uh_next.ptr;\n    }\n    else\n\tuhp = curbuf->b_u_newhead;\n    if (uhp == NULL)\n\t*msgbuf = NUL;\n    else\n\tadd_time(msgbuf, sizeof(msgbuf), uhp->uh_time);\n#ifdef FEAT_CONCEAL\n    {\n\twin_T\t*wp;\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    if (wp->w_buffer == curbuf && wp->w_p_cole > 0)\n\t\tredraw_win_later(wp, NOT_VALID);\n\t}\n    }\n#endif\n    smsg_attr_keep(0, _(\"%ld %s; %s #%ld  %s\"),\n\t    u_oldcount < 0 ? -u_oldcount : u_oldcount,\n\t    _(msgstr),\n\t    did_undo ? _(\"before\") : _(\"after\"),\n\t    uhp == NULL ? 0L : uhp->uh_seq,\n\t    msgbuf);\n}", "target": 1}
{"code": "TfLiteIntArray* TfLiteIntArrayCreate(int size) {\n  int alloc_size = TfLiteIntArrayGetSizeInBytes(size);\n  if (alloc_size <= 0) return NULL;\n  TfLiteIntArray* ret = (TfLiteIntArray*)malloc(alloc_size);\n  if (!ret) return ret;\n  ret->size = size;\n  return ret;\n}", "target": 1}
{"code": "static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {\n\tRBuffer *fbuf = r_buf_ref (buf);\n\tstruct MACH0_(opts_t) opts;\n\tMACH0_(opts_set_default) (&opts, bf);\n\tstruct MACH0_(obj_t) *main_mach0 = MACH0_(new_buf) (fbuf, &opts);\n\tif (!main_mach0) {\n\t\treturn false;\n\t}\n\tRRebaseInfo *rebase_info = r_rebase_info_new_from_mach0 (fbuf, main_mach0);\n\tRKernelCacheObj *obj = NULL;\n\tRPrelinkRange *prelink_range = get_prelink_info_range_from_mach0 (main_mach0);\n\tif (!prelink_range) {\n\t\tgoto beach;\n\t}\n\tobj = R_NEW0 (RKernelCacheObj);\n\tif (!obj) {\n\t\tR_FREE (prelink_range);\n\t\tgoto beach;\n\t}\n\tRCFValueDict *prelink_info = NULL;\n\tif (main_mach0->hdr.filetype != MH_FILESET && prelink_range->range.size) {\n\t\tprelink_info = r_cf_value_dict_parse (fbuf, prelink_range->range.offset,\n\t\t\t\tprelink_range->range.size, R_CF_OPTION_SKIP_NSDATA);\n\t\tif (!prelink_info) {\n\t\t\tR_FREE (prelink_range);\n\t\t\tR_FREE (obj);\n\t\t\tgoto beach;\n\t\t}\n\t}\n\tif (!pending_bin_files) {\n\t\tpending_bin_files = r_list_new ();\n\t\tif (!pending_bin_files) {\n\t\t\tR_FREE (prelink_range);\n\t\t\tR_FREE (obj);\n\t\t\tR_FREE (prelink_info);\n\t\t\tgoto beach;\n\t\t}\n\t}\n\tobj->mach0 = main_mach0;\n\tobj->rebase_info = rebase_info;\n\tobj->prelink_info = prelink_info;\n\tobj->cache_buf = fbuf;\n\tobj->pa2va_exec = prelink_range->pa2va_exec;\n\tobj->pa2va_data = prelink_range->pa2va_data;\n\tR_FREE (prelink_range);\n\t*bin_obj = obj;\n\tr_list_push (pending_bin_files, bf);\n\tif (rebase_info || main_mach0->chained_starts) {\n\t\tRIO *io = bf->rbin->iob.io;\n\t\tswizzle_io_read (obj, io);\n\t}\n\treturn true;\nbeach:\n\tr_buf_free (fbuf);\n\tobj->cache_buf = NULL;\n\tMACH0_(mach0_free) (main_mach0);\n\treturn false;\n}", "target": 1}
{"code": "int kvmppc_rtas_hcall(struct kvm_vcpu *vcpu)\n{\n\tstruct rtas_token_definition *d;\n\tstruct rtas_args args;\n\trtas_arg_t *orig_rets;\n\tgpa_t args_phys;\n\tint rc;\n\targs_phys = kvmppc_get_gpr(vcpu, 4) & KVM_PAM;\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\trc = kvm_read_guest(vcpu->kvm, args_phys, &args, sizeof(args));\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\tif (rc)\n\t\tgoto fail;\n\torig_rets = args.rets;\n\targs.rets = &args.args[be32_to_cpu(args.nargs)];\n\tmutex_lock(&vcpu->kvm->arch.rtas_token_lock);\n\trc = -ENOENT;\n\tlist_for_each_entry(d, &vcpu->kvm->arch.rtas_tokens, list) {\n\t\tif (d->token == be32_to_cpu(args.token)) {\n\t\t\td->handler->handler(vcpu, &args);\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&vcpu->kvm->arch.rtas_token_lock);\n\tif (rc == 0) {\n\t\targs.rets = orig_rets;\n\t\trc = kvm_write_guest(vcpu->kvm, args_phys, &args, sizeof(args));\n\t\tif (rc)\n\t\t\tgoto fail;\n\t}\n\treturn rc;\nfail:\n\treturn rc;\n}", "target": 1}
{"code": "static apr_status_t session_identity_decode(request_rec * r, session_rec * z)\n{\n    char *last = NULL;\n    char *encoded, *pair;\n    const char *sep = \"&\";\n    if (!z->encoded) {\n        return OK;\n    }\n    encoded = apr_pstrdup(r->pool, z->encoded);\n    pair = apr_strtok(encoded, sep, &last);\n    while (pair && pair[0]) {\n        char *plast = NULL;\n        const char *psep = \"=\";\n        char *key = apr_strtok(pair, psep, &plast);\n        char *val = apr_strtok(NULL, psep, &plast);\n        if (key && *key) {\n            if (!val || !*val) {\n                apr_table_unset(z->entries, key);\n            }\n            else if (!ap_unescape_urlencoded(key) && !ap_unescape_urlencoded(val)) {\n                if (!strcmp(SESSION_EXPIRY, key)) {\n                    z->expiry = (apr_time_t) apr_atoi64(val);\n                }\n                else {\n                    apr_table_set(z->entries, key, val);\n                }\n            }\n        }\n        pair = apr_strtok(NULL, sep, &last);\n    }\n    z->encoded = NULL;\n    return OK;\n}", "target": 1}
{"code": "file_check_mem(struct magic_set *ms, unsigned int level)\n{\n \tsize_t len;\n \tif (level >= ms->c.len) {\n\t\tlen = (ms->c.len += 20) * sizeof(*ms->c.li);\n \t\tms->c.li = CAST(struct level_info *, (ms->c.li == NULL) ?\n \t\t    malloc(len) :\n \t\t    realloc(ms->c.li, len));\n\t\tif (ms->c.li == NULL) {\n\t\t\tfile_oomem(ms, len);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tms->c.li[level].got_match = 0;\n#ifdef ENABLE_CONDITIONALS\n\tms->c.li[level].last_match = 0;\n\tms->c.li[level].last_cond = COND_NONE;\n#endif \n\treturn 0;\n}", "target": 1}
{"code": "static void *__bpf_ringbuf_reserve(struct bpf_ringbuf *rb, u64 size)\n{\n\tunsigned long cons_pos, prod_pos, new_prod_pos, flags;\n\tu32 len, pg_off;\n\tstruct bpf_ringbuf_hdr *hdr;\n\tif (unlikely(size > RINGBUF_MAX_RECORD_SZ))\n\t\treturn NULL;\n\tlen = round_up(size + BPF_RINGBUF_HDR_SZ, 8);\n\tcons_pos = smp_load_acquire(&rb->consumer_pos);\n\tif (in_nmi()) {\n\t\tif (!spin_trylock_irqsave(&rb->spinlock, flags))\n\t\t\treturn NULL;\n\t} else {\n\t\tspin_lock_irqsave(&rb->spinlock, flags);\n\t}\n\tprod_pos = rb->producer_pos;\n\tnew_prod_pos = prod_pos + len;\n\tif (new_prod_pos - cons_pos > rb->mask) {\n\t\tspin_unlock_irqrestore(&rb->spinlock, flags);\n\t\treturn NULL;\n\t}\n\thdr = (void *)rb->data + (prod_pos & rb->mask);\n\tpg_off = bpf_ringbuf_rec_pg_off(rb, hdr);\n\thdr->len = size | BPF_RINGBUF_BUSY_BIT;\n\thdr->pg_off = pg_off;\n\tsmp_store_release(&rb->producer_pos, new_prod_pos);\n\tspin_unlock_irqrestore(&rb->spinlock, flags);\n\treturn (void *)hdr + BPF_RINGBUF_HDR_SZ;\n}", "target": 1}
{"code": "append_utf8_value (const unsigned char *value, size_t length,\n                   struct stringbuf *sb)\n{\n  unsigned char tmp[6];\n  const unsigned char *s;\n  size_t n;\n  int i, nmore;\n  if (length && (*value == ' ' || *value == '#'))\n    {\n      tmp[0] = '\\\\';\n      tmp[1] = *value;\n      put_stringbuf_mem (sb, tmp, 2);\n      value++;\n      length--;\n    }\n  if (length && value[length-1] == ' ')\n    {\n      tmp[0] = '\\\\';\n      tmp[1] = ' ';\n      put_stringbuf_mem (sb, tmp, 2);\n       length--;\n     }\n   for (s=value, n=0;;)\n     {\n       for (value = s; n < length && !(*s & 0x80); n++, s++)\n      for (value = s; n < length && !(*s & 0x80); n++, s++)\n        ;\n         append_quoted (sb, value, s-value, 0);\n       if (n==length)\n         return; \n      assert ((*s & 0x80));\n      if ( (*s & 0xe0) == 0xc0 )      \n         nmore = 1;\n       else if ( (*s & 0xf0) == 0xe0 ) \n         nmore = 2;\n      else if ( (*s & 0xf8) == 0xf0 ) \n        nmore = 3;\n      else if ( (*s & 0xfc) == 0xf8 ) \n         nmore = 4;\n       else if ( (*s & 0xfe) == 0xfc ) \n         nmore = 5;\n      else \n        nmore = 5;  \n      if (n+nmore > length)\n        nmore = length - n; \n      tmp[0] = *s++; n++;\n      for (i=1; i <= nmore; i++)\n         {\n          if ( (*s & 0xc0) != 0x80)\n            break; \n          tmp[i] = *s++;\n          n++;\n         }\n      put_stringbuf_mem (sb, tmp, i);\n     }\n }", "target": 1}
{"code": "static OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *\n        p_code_block)\n{\n    OPJ_UINT32 l_data_size;\n    l_data_size = 26 + (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) *\n                                   (p_code_block->y1 - p_code_block->y0) * (OPJ_INT32)sizeof(OPJ_UINT32));\n    if (l_data_size > p_code_block->data_size) {\n        if (p_code_block->data) {\n            opj_free(p_code_block->data - 1);\n        }\n        p_code_block->data = (OPJ_BYTE*) opj_malloc(l_data_size + 1);\n        if (! p_code_block->data) {\n            p_code_block->data_size = 0U;\n            return OPJ_FALSE;\n        }\n        p_code_block->data_size = l_data_size;\n        p_code_block->data[0] = 0;\n        p_code_block->data += 1; \n    }\n    return OPJ_TRUE;\n}", "target": 1}
{"code": "rsCStrExtendBuf(cstr_t *pThis, size_t iMinNeeded)\n{\n\tuchar *pNewBuf;\n\tunsigned short iNewSize;\n\tDEFiRet;\n\tif(iMinNeeded > RS_STRINGBUF_ALLOC_INCREMENT) {\n\t\tiNewSize = (iMinNeeded / RS_STRINGBUF_ALLOC_INCREMENT + 1) * RS_STRINGBUF_ALLOC_INCREMENT;\n\t} else {\n\t\tiNewSize = pThis->iBufSize + RS_STRINGBUF_ALLOC_INCREMENT;\n\t}\n\tiNewSize += pThis->iBufSize; \n\tCHKmalloc(pNewBuf = (uchar*) realloc(pThis->pBuf, iNewSize * sizeof(uchar)));\n\tpThis->iBufSize = iNewSize;\n\tpThis->pBuf = pNewBuf;\nfinalize_it:\n\tRETiRet;\n}", "target": 1}
{"code": " INST_HANDLER (sts) {\t\n \tint r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n \tint k = (buf[3] << 8) | buf[2];\n \top->ptr = k;\n\tESIL_A (\"r%d,\", r);\n\t__generic_ld_st (op, \"ram\", 0, 1, 0, k, 1);\n\top->cycles = 2;\n}", "target": 1}
{"code": "\t\tvoid CWebServer::GetFloorplanImage(WebEmSession & session, const request& req, reply & rep)\n\t\t{\n\t\t\tstd::string idx = request::findValue(&req, \"idx\");\n\t\t\tif (idx == \"\") {\n \t\t\t\treturn;\n \t\t\t}\n \t\t\tstd::vector<std::vector<std::string> > result;\n\t\t\tresult = m_sql.safe_queryBlob(\"SELECT Image FROM Floorplans WHERE ID=%s\", idx.c_str());\n \t\t\tif (result.empty())\n \t\t\t\treturn;\n \t\t\treply::set_content(&rep, result[0][0].begin(), result[0][0].end());\n\t\t\tstd::string oname = \"floorplan\";\n\t\t\tif (result[0][0].size() > 10)\n\t\t\t{\n\t\t\t\tif (result[0][0][0] == 'P')\n\t\t\t\t\toname += \".png\";\n\t\t\t\telse if (result[0][0][0] == -1)\n\t\t\t\t\toname += \".jpg\";\n\t\t\t\telse if (result[0][0][0] == 'B')\n\t\t\t\t\toname += \".bmp\";\n\t\t\t\telse if (result[0][0][0] == 'G')\n\t\t\t\t\toname += \".gif\";\n\t\t\t}\n\t\t\treply::add_header_attachment(&rep, oname);\n\t\t}", "target": 1}
{"code": "vhost_user_check_and_alloc_queue_pair(struct virtio_net *dev,\n\t\t\tstruct vhu_msg_context *ctx)\n{\n\tuint32_t vring_idx;\n\tswitch (ctx->msg.request.master) {\n\tcase VHOST_USER_SET_VRING_KICK:\n\tcase VHOST_USER_SET_VRING_CALL:\n\tcase VHOST_USER_SET_VRING_ERR:\n\t\tvring_idx = ctx->msg.payload.u64 & VHOST_USER_VRING_IDX_MASK;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_NUM:\n\tcase VHOST_USER_SET_VRING_BASE:\n\tcase VHOST_USER_GET_VRING_BASE:\n\tcase VHOST_USER_SET_VRING_ENABLE:\n\t\tvring_idx = ctx->msg.payload.state.index;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_ADDR:\n\t\tvring_idx = ctx->msg.payload.addr.index;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (vring_idx >= VHOST_MAX_VRING) {\n\t\tVHOST_LOG_CONFIG(ERR, \"(%s) invalid vring index: %u\\n\", dev->ifname, vring_idx);\n\t\treturn -1;\n\t}\n\tif (dev->virtqueue[vring_idx])\n\t\treturn 0;\n\treturn alloc_vring_queue(dev, vring_idx);\n}", "target": 1}
{"code": "size_t tls12_get_psigalgs(SSL *s, const unsigned char **psigs)\n\t{\n#ifndef OPENSSL_NO_EC\n\tswitch (tls1_suiteb(s))\n\t\t{\n\tcase SSL_CERT_FLAG_SUITEB_128_LOS:\n\t\t*psigs = suiteb_sigalgs;\n\t\treturn sizeof(suiteb_sigalgs);\n\tcase SSL_CERT_FLAG_SUITEB_128_LOS_ONLY:\n\t\t*psigs = suiteb_sigalgs;\n\t\treturn 2;\n\tcase SSL_CERT_FLAG_SUITEB_192_LOS:\n\t\t*psigs = suiteb_sigalgs + 2;\n\t\treturn 2;\n\t\t}\n#endif\n\tif (s->server && s->cert->client_sigalgs)\n\t\t{\n\t\t*psigs = s->cert->client_sigalgs;\n\t\treturn s->cert->client_sigalgslen;\n\t\t}\n\telse if (s->cert->conf_sigalgs)\n\t\t{\n\t\t*psigs = s->cert->conf_sigalgs;\n\t\treturn s->cert->conf_sigalgslen;\n\t\t}\n\telse\n\t\t{\n\t\t*psigs = tls12_sigalgs;\n#ifdef OPENSSL_FIPS\n\t\tif (FIPS_mode())\n\t\t\treturn sizeof(tls12_sigalgs) - 2;\n\t\telse\n#endif\n\t\t\treturn sizeof(tls12_sigalgs);\n\t\t}\n\t}", "target": 1}
{"code": "static MagickBooleanType load_tile(Image *image,Image *tile_image,\n  XCFDocInfo *inDocInfo,XCFLayerInfo *inLayerInfo,size_t data_length,\n  ExceptionInfo *exception)\n{\n  ssize_t\n    y;\n  register ssize_t\n    x;\n  register Quantum\n    *q;\n  ssize_t\n    count;\n  unsigned char\n    *graydata;\n  XCFPixelInfo\n     *xcfdata,\n     *xcfodata;\n  xcfdata=(XCFPixelInfo *) AcquireQuantumMemory(data_length,sizeof(*xcfdata));\n   if (xcfdata == (XCFPixelInfo *) NULL)\n     ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n       image->filename);\n  xcfodata=xcfdata;\n  graydata=(unsigned char *) xcfdata;  \n  count=ReadBlob(image,data_length,(unsigned char *) xcfdata);\n  if (count != (ssize_t) data_length)\n    ThrowBinaryException(CorruptImageError,\"NotEnoughPixelData\",\n      image->filename);\n  for (y=0; y < (ssize_t) tile_image->rows; y++)\n  {\n    q=GetAuthenticPixels(tile_image,0,y,tile_image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    if (inDocInfo->image_type == GIMP_GRAY)\n      {\n        for (x=0; x < (ssize_t) tile_image->columns; x++)\n        {\n          SetPixelGray(tile_image,ScaleCharToQuantum(*graydata),q);\n          SetPixelAlpha(tile_image,ScaleCharToQuantum((unsigned char)\n            inLayerInfo->alpha),q);\n          graydata++;\n          q+=GetPixelChannels(tile_image);\n        }\n      }\n    else\n      if (inDocInfo->image_type == GIMP_RGB)\n        {\n          for (x=0; x < (ssize_t) tile_image->columns; x++)\n          {\n            SetPixelRed(tile_image,ScaleCharToQuantum(xcfdata->red),q);\n            SetPixelGreen(tile_image,ScaleCharToQuantum(xcfdata->green),q);\n            SetPixelBlue(tile_image,ScaleCharToQuantum(xcfdata->blue),q);\n            SetPixelAlpha(tile_image,xcfdata->alpha == 255U ? TransparentAlpha :\n              ScaleCharToQuantum((unsigned char) inLayerInfo->alpha),q);\n            xcfdata++;\n            q+=GetPixelChannels(tile_image);\n          }\n        }\n     if (SyncAuthenticPixels(tile_image,exception) == MagickFalse)\n       break;\n  }\n  xcfodata=(XCFPixelInfo *) RelinquishMagickMemory(xcfodata);\n  return MagickTrue;\n}", "target": 1}
{"code": "void* leak_malloc(size_t bytes)\n{\n    void* base = dlmalloc(bytes + sizeof(AllocationEntry));\n    if (base != NULL) {\n        pthread_mutex_lock(&gAllocationsMutex);\n            intptr_t backtrace[BACKTRACE_SIZE];\n            size_t numEntries = get_backtrace(backtrace, BACKTRACE_SIZE);\n            AllocationEntry* header = (AllocationEntry*)base;\n            header->entry = record_backtrace(backtrace, numEntries, bytes);\n            header->guard = GUARD;\n            base = (AllocationEntry*)base + 1;\n        pthread_mutex_unlock(&gAllocationsMutex);\n    }\n    return base;\n}", "target": 1}
{"code": " void red_channel_pipes_add_type(RedChannel *channel, int pipe_item_type)\n {\n    RingItem *link;\n    RING_FOREACH(link, &channel->clients) {\n         red_channel_client_pipe_add_type(\n             SPICE_CONTAINEROF(link, RedChannelClient, channel_link),\n             pipe_item_type);\n    }\n}", "target": 1}
{"code": "int gnutls_x509_ext_import_proxy(const gnutls_datum_t * ext, int *pathlen,\n\t\t\t      char **policyLanguage, char **policy,\n\t\t\t      size_t * sizeof_policy)\n{\n\tASN1_TYPE c2 = ASN1_TYPE_EMPTY;\n\tint result;\n\tgnutls_datum_t value = { NULL, 0 };\n\tif ((result = asn1_create_element\n\t     (_gnutls_get_pkix(), \"PKIX1.ProxyCertInfo\",\n\t      &c2)) != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\treturn _gnutls_asn2err(result);\n\t}\n\tresult = _asn1_strict_der_decode(&c2, ext->data, ext->size, NULL);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\tresult = _gnutls_asn2err(result);\n\t\tgoto cleanup;\n\t}\n\tif (pathlen) {\n\t\tresult = _gnutls_x509_read_uint(c2, \"pCPathLenConstraint\",\n\t\t\t\t\t\t(unsigned int *)\n\t\t\t\t\t\tpathlen);\n\t\tif (result == GNUTLS_E_ASN1_ELEMENT_NOT_FOUND)\n\t\t\t*pathlen = -1;\n\t\telse if (result != GNUTLS_E_SUCCESS) {\n\t\t\tgnutls_assert();\n\t\t\tresult = _gnutls_asn2err(result);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tresult = _gnutls_x509_read_value(c2, \"proxyPolicy.policyLanguage\",\n\t\t\t\t\t &value);\n\tif (result < 0) {\n\t\tgnutls_assert();\n\t\tgoto cleanup;\n\t}\n\tif (policyLanguage) {\n\t\t*policyLanguage = (char *)value.data;\n\t} else {\n\t\tgnutls_free(value.data);\n\t\tvalue.data = NULL;\n\t}\n\tresult = _gnutls_x509_read_value(c2, \"proxyPolicy.policy\", &value);\n\tif (result == GNUTLS_E_ASN1_ELEMENT_NOT_FOUND) {\n\t\tif (policy)\n\t\t\t*policy = NULL;\n\t\tif (sizeof_policy)\n\t\t\t*sizeof_policy = 0;\n\t} else if (result < 0) {\n\t\tgnutls_assert();\n\t\tgoto cleanup;\n\t} else {\n\t\tif (policy) {\n\t\t\t*policy = (char *)value.data;\n\t\t\tvalue.data = NULL;\n\t\t}\n\t\tif (sizeof_policy)\n\t\t\t*sizeof_policy = value.size;\n\t}\n\tresult = 0;\n cleanup:\n\tgnutls_free(value.data);\n\tasn1_delete_structure(&c2);\n\treturn result;\n}", "target": 1}
{"code": "static ssize_t rpmsg_eptdev_write_iter(struct kiocb *iocb,\n\t\t\t\t       struct iov_iter *from)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct rpmsg_eptdev *eptdev = filp->private_data;\n\tsize_t len = iov_iter_count(from);\n\tvoid *kbuf;\n\tint ret;\n\tkbuf = kzalloc(len, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\tif (!copy_from_iter_full(kbuf, len, from))\n\t\treturn -EFAULT;\n\tif (mutex_lock_interruptible(&eptdev->ept_lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto free_kbuf;\n\t}\n\tif (!eptdev->ept) {\n\t\tret = -EPIPE;\n\t\tgoto unlock_eptdev;\n\t}\n\tif (filp->f_flags & O_NONBLOCK)\n\t\tret = rpmsg_trysend(eptdev->ept, kbuf, len);\n\telse\n\t\tret = rpmsg_send(eptdev->ept, kbuf, len);\nunlock_eptdev:\n\tmutex_unlock(&eptdev->ept_lock);\nfree_kbuf:\n\tkfree(kbuf);\n\treturn ret < 0 ? ret : len;\n}", "target": 1}
{"code": "static void snippet_add_content(struct snippet_context *ctx,\n\t\t\t\tstruct snippet_data *target,\n\t\t\t\tconst unsigned char *data, size_t size,\n\t\t\t\tsize_t *count_r)\n{\n\ti_assert(target != NULL);\n\tif (size >= 3 &&\n\t     ((data[0] == 0xEF && data[1] == 0xBB && data[2] == 0xBF) ||\n\t      (data[0] == 0xBF && data[1] == 0xBB && data[2] == 0xEF))) {\n\t\t*count_r = 3;\n\t\treturn;\n\t}\n\tif (data[0] == '\\0') {\n\t\treturn;\n\t}\n\tif (i_isspace(*data)) {\n\t\tif (str_len(target->snippet) > 1)\n\t\t\tctx->add_whitespace = TRUE;\n\t\tif (data[0] == '\\n')\n\t\t\tctx->state = SNIPPET_STATE_NEWLINE;\n\t\treturn;\n\t}\n\tif (ctx->add_whitespace) {\n\t\tstr_append_c(target->snippet, ' ');\n\t\tctx->add_whitespace = FALSE;\n\t\tif (target->chars_left-- == 0)\n\t\t\treturn;\n\t}\n\tif (target->chars_left == 0)\n\t\treturn;\n\ttarget->chars_left--;\n\t*count_r = uni_utf8_char_bytes(data[0]);\n\ti_assert(*count_r <= size);\n\tstr_append_data(target->snippet, data, *count_r);\n}", "target": 1}
{"code": "static void gf_dump_vrml_simple_field(GF_SceneDumper *sdump, GF_FieldInfo field, GF_Node *parent)\n{\n\tu32 i, sf_type;\n\tGF_ChildNodeItem *list;\n\tvoid *slot_ptr;\n\tswitch (field.fieldType) {\n\tcase GF_SG_VRML_SFNODE:\n\t\tassert ( *(GF_Node **)field.far_ptr);\n\t\tgf_dump_vrml_node(sdump, *(GF_Node **)field.far_ptr, 0, NULL);\n\t\treturn;\n\tcase GF_SG_VRML_MFNODE:\n\t\tlist = * ((GF_ChildNodeItem **) field.far_ptr);\n\t\tassert( list );\n\t\tsdump->indent++;\n\t\twhile (list) {\n\t\t\tgf_dump_vrml_node(sdump, list->node, 1, NULL);\n\t\t\tlist = list->next;\n\t\t}\n\t\tsdump->indent--;\n\t\treturn;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t\treturn;\n\t}\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\tif (sdump->XMLDump) StartAttribute(sdump, \"value\");\n\t\tgf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, parent);\n\t\tif (sdump->XMLDump) EndAttribute(sdump);\n\t} else {\n\t\tGenMFField *mffield;\n\t\tmffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"[\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \" value=\\'\");\n\t\t} else {\n\t\t\tStartAttribute(sdump, \"value\");\n\t\t}\n\t\tfor (i=0; i<mffield->count; i++) {\n\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, parent);\n\t\t}\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"]\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \"\\'\");\n\t\t} else {\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t}\n}", "target": 1}
{"code": "XFixesFetchRegionAndBounds (Display\t    *dpy,\n\t\t\t    XserverRegion   region,\n\t\t\t    int\t\t    *nrectanglesRet,\n\t\t\t    XRectangle\t    *bounds)\n{\n    XFixesExtDisplayInfo\t*info = XFixesFindDisplay (dpy);\n    xXFixesFetchRegionReq\t*req;\n    xXFixesFetchRegionReply\trep;\n    XRectangle\t\t\t*rects;\n    int    \t\t\tnrects;\n    long    \t\t\tnbytes;\n    long\t\t\tnread;\n    XFixesCheckExtension (dpy, info, NULL);\n    LockDisplay (dpy);\n    GetReq (XFixesFetchRegion, req);\n    req->reqType = info->codes->major_opcode;\n    req->xfixesReqType = X_XFixesFetchRegion;\n    req->region = region;\n    *nrectanglesRet = 0;\n    if (!_XReply (dpy, (xReply *) &rep, 0, xFalse))\n    {\n\tUnlockDisplay (dpy);\n\tSyncHandle ();\n\treturn NULL;\n    }\n    bounds->x = rep.x;\n    bounds->y = rep.y;\n     bounds->y = rep.y;\n     bounds->width = rep.width;\n     bounds->height = rep.height;\n    nbytes = (long) rep.length << 2;\n    nrects = rep.length >> 1;\n    rects = Xmalloc (nrects * sizeof (XRectangle));\n     if (!rects)\n     {\n \t_XEatDataWords(dpy, rep.length);\n\t_XEatData (dpy, (unsigned long) (nbytes - nread));\n    }\n    UnlockDisplay (dpy);\n    SyncHandle();\n    *nrectanglesRet = nrects;\n    return rects;\n}", "target": 1}
{"code": "static void sdhci_send_command(SDHCIState *s)\n{\n    SDRequest request;\n    uint8_t response[16];\n    int rlen;\n    s->errintsts = 0;\n    s->acmd12errsts = 0;\n    request.cmd = s->cmdreg >> 8;\n    request.arg = s->argument;\n    trace_sdhci_send_command(request.cmd, request.arg);\n    rlen = sdbus_do_command(&s->sdbus, &request, response);\n    if (s->cmdreg & SDHC_CMD_RESPONSE) {\n        if (rlen == 4) {\n            s->rspreg[0] = ldl_be_p(response);\n            s->rspreg[1] = s->rspreg[2] = s->rspreg[3] = 0;\n            trace_sdhci_response4(s->rspreg[0]);\n        } else if (rlen == 16) {\n            s->rspreg[0] = ldl_be_p(&response[11]);\n            s->rspreg[1] = ldl_be_p(&response[7]);\n            s->rspreg[2] = ldl_be_p(&response[3]);\n            s->rspreg[3] = (response[0] << 16) | (response[1] << 8) |\n                            response[2];\n            trace_sdhci_response16(s->rspreg[3], s->rspreg[2],\n                                   s->rspreg[1], s->rspreg[0]);\n        } else {\n            trace_sdhci_error(\"timeout waiting for command response\");\n            if (s->errintstsen & SDHC_EISEN_CMDTIMEOUT) {\n                s->errintsts |= SDHC_EIS_CMDTIMEOUT;\n                s->norintsts |= SDHC_NIS_ERR;\n            }\n        }\n        if (!(s->quirks & SDHCI_QUIRK_NO_BUSY_IRQ) &&\n            (s->norintstsen & SDHC_NISEN_TRSCMP) &&\n            (s->cmdreg & SDHC_CMD_RESPONSE) == SDHC_CMD_RSP_WITH_BUSY) {\n            s->norintsts |= SDHC_NIS_TRSCMP;\n        }\n    }\n    if (s->norintstsen & SDHC_NISEN_CMDCMP) {\n        s->norintsts |= SDHC_NIS_CMDCMP;\n    }\n    sdhci_update_irq(s);\n    if (s->blksize && (s->cmdreg & SDHC_CMD_DATA_PRESENT)) {\n        s->data_count = 0;\n        sdhci_data_transfer(s);\n    }\n}", "target": 1}
{"code": "static int fetch_uidl (char *line, void *data)\n{\n  int i, index;\n  CONTEXT *ctx = (CONTEXT *)data;\n  POP_DATA *pop_data = (POP_DATA *)ctx->data;\n  char *endp;\n  errno = 0;\n  index = strtol(line, &endp, 10);\n  if (errno)\n      return -1;\n  while (*endp == ' ')\n      endp++;\n  memmove(line, endp, strlen(endp) + 1);\n  for (i = 0; i < ctx->msgcount; i++)\n    if (!mutt_strcmp (line, ctx->hdrs[i]->data))\n      break;\n  if (i == ctx->msgcount)\n  {\n    dprint (1, (debugfile, \"pop_fetch_headers: new header %d %s\\n\", index, line));\n    if (i >= ctx->hdrmax)\n      mx_alloc_memory(ctx);\n    ctx->msgcount++;\n    ctx->hdrs[i] = mutt_new_header ();\n    ctx->hdrs[i]->data = safe_strdup (line);\n  }\n  else if (ctx->hdrs[i]->index != index - 1)\n    pop_data->clear_cache = 1;\n  ctx->hdrs[i]->refno = index;\n  ctx->hdrs[i]->index = index - 1;\n  return 0;\n}", "target": 1}
{"code": "entityValueInitProcessor(XML_Parser parser,\n                         const char *s,\n                         const char *end,\n                         const char **nextPtr)\n{\n  int tok;\n  const char *start = s;\n  const char *next = start;\n  eventPtr = start;\n  for (;;) {\n    tok = XmlPrologTok(encoding, start, end, &next);\n    eventEndPtr = next;\n    if (tok <= 0) {\n      if (!ps_finalBuffer && tok != XML_TOK_INVALID) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      switch (tok) {\n      case XML_TOK_INVALID:\n        return XML_ERROR_INVALID_TOKEN;\n      case XML_TOK_PARTIAL:\n        return XML_ERROR_UNCLOSED_TOKEN;\n      case XML_TOK_PARTIAL_CHAR:\n        return XML_ERROR_PARTIAL_CHAR;\n      case XML_TOK_NONE:   \n      default:\n        break;\n      }\n      return storeEntityValue(parser, encoding, s, end);\n    }\n    else if (tok == XML_TOK_XML_DECL) {\n      enum XML_Error result;\n      result = processXmlDecl(parser, 0, start, next);\n      if (result != XML_ERROR_NONE)\n        return result;\n      switch (ps_parsing) {\n      case XML_SUSPENDED:\n        *nextPtr = next;\n        return XML_ERROR_NONE;\n      case XML_FINISHED:\n        return XML_ERROR_ABORTED;\n      default:\n        *nextPtr = next;\n      }\n      processor = entityValueProcessor;\n      return entityValueProcessor(parser, next, end, nextPtr);\n    }\n    else if (tok == XML_TOK_BOM && next == end && !ps_finalBuffer) {\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    }\n    start = next;\n    eventPtr = start;\n  }\n}", "target": 1}
{"code": "_asn1_extract_der_octet (asn1_node node, const unsigned char *der,\n\t\t\t int der_len, unsigned flags)\n{\n  int len2, len3;\n  int counter, counter_end;\n  int result;\n  len2 = asn1_get_length_der (der, der_len, &len3);\n  if (len2 < -1)\n    return ASN1_DER_ERROR;\n  counter = len3 + 1;\n  if (len2 == -1)\n    counter_end = der_len - 2;\n  else\n    counter_end = der_len;\n  while (counter < counter_end)\n    {\n      len2 = asn1_get_length_der (der + counter, der_len, &len3);\n      if (IS_ERR(len2, flags))\n\t{\n\t  warn();\n\t  return ASN1_DER_ERROR;\n\t}\n      if (len2 >= 0)\n\t{\n\t  DECR_LEN(der_len, len2+len3);\n\t  _asn1_append_value (node, der + counter + len3, len2);\n\t}\n      else\n\t{\t\t\t\n\t  DECR_LEN(der_len, len3);\n\t  result =\n\t    _asn1_extract_der_octet (node, der + counter + len3,\n\t\t\t\t     der_len, flags);\n\t  if (result != ASN1_SUCCESS)\n\t    return result;\n\t  len2 = 0;\n\t}\n      DECR_LEN(der_len, 1);\n      counter += len2 + len3 + 1;\n    }\n  return ASN1_SUCCESS;\ncleanup:\n  return result;\n}", "target": 1}
{"code": "status_t SampleTable::setSampleToChunkParams(\n off64_t data_offset, size_t data_size) {\n if (mSampleToChunkOffset >= 0) {\n return ERROR_MALFORMED;\n }\n    mSampleToChunkOffset = data_offset;\n if (data_size < 8) {\n return ERROR_MALFORMED;\n }\n uint8_t header[8];\n if (mDataSource->readAt(\n                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {\n return ERROR_IO;\n }\n if (U32_AT(header) != 0) {\n return ERROR_MALFORMED;\n }\n    mNumSampleToChunkOffsets = U32_AT(&header[4]);\n if (data_size < 8 + mNumSampleToChunkOffsets * 12) {\n         return ERROR_MALFORMED;\n     }\n     mSampleToChunkEntries =\n         new SampleToChunkEntry[mNumSampleToChunkOffsets];\n for (uint32_t i = 0; i < mNumSampleToChunkOffsets; ++i) {\n uint8_t buffer[12];\n if (mDataSource->readAt(\n                    mSampleToChunkOffset + 8 + i * 12, buffer, sizeof(buffer))\n != (ssize_t)sizeof(buffer)) {\n return ERROR_IO;\n }\n        CHECK(U32_AT(buffer) >= 1); \n        mSampleToChunkEntries[i].startChunk = U32_AT(buffer) - 1;\n        mSampleToChunkEntries[i].samplesPerChunk = U32_AT(&buffer[4]);\n        mSampleToChunkEntries[i].chunkDesc = U32_AT(&buffer[8]);\n }\n return OK;\n}", "target": 1}
{"code": " void altivec_unavailable_exception(struct pt_regs *regs)\n {\n#if !defined(CONFIG_ALTIVEC)\n \tif (user_mode(regs)) {\n \t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n \t\treturn;\n \t}\n#endif\n \tprintk(KERN_EMERG \"Unrecoverable VMX/Altivec Unavailable Exception \"\n \t\t\t\"%lx at %lx\\n\", regs->trap, regs->nip);\n \tdie(\"Unrecoverable VMX/Altivec Unavailable Exception\", regs, SIGABRT);\n}", "target": 1}
{"code": "bool L2NormalizeReduceAxis(Value sq_op, DenseElementsAttr axis) {\n  if (sq_op.getType().cast<ShapedType>().getRank() - 1 ==\n          *axis.getValues<int>().begin() ||\n      *axis.getValues<int>().begin() == -1) {\n    return true;\n  }\n  if (sq_op.getType().cast<ShapedType>().getRank() != axis.getNumElements()) {\n    return false;\n  }\n  auto shape = sq_op.getType().cast<ShapedType>();\n  SmallVector<int, 4> elems{axis.getValues<int>().begin(),\n                            axis.getValues<int>().end()};\n  for (int i = 0; i < shape.getRank(); ++i) {\n    if (i != elems[i]) return false;\n  }\n  return true;\n}", "target": 1}
{"code": "size_t mptsas_config_manufacturing_1(MPTSASState *s, uint8_t **data, int address)\n {\n     return MPTSAS_CONFIG_PACK(1, MPI_CONFIG_PAGETYPE_MANUFACTURING, 0x00,\n                              \"s256\");\n }", "target": 1}
{"code": "static ssize_t ucma_migrate_id(struct ucma_file *new_file,\n\t\t\t       const char __user *inbuf,\n\t\t\t       int in_len, int out_len)\n{\n\tstruct rdma_ucm_migrate_id cmd;\n\tstruct rdma_ucm_migrate_resp resp;\n\tstruct ucma_context *ctx;\n\tstruct fd f;\n\tstruct ucma_file *cur_file;\n\tint ret = 0;\n\tif (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n\t\treturn -EFAULT;\n\tf = fdget(cmd.fd);\n\tif (!f.file)\n\t\treturn -ENOENT;\n\tif (f.file->f_op != &ucma_fops) {\n\t\tret = -EINVAL;\n\t\tgoto file_put;\n\t}\n\tctx = ucma_get_ctx(f.file->private_data, cmd.id);\n\tif (IS_ERR(ctx)) {\n\t\tret = PTR_ERR(ctx);\n\t\tgoto file_put;\n\t}\n\trdma_lock_handler(ctx->cm_id);\n\tcur_file = ctx->file;\n\tif (cur_file == new_file) {\n\t\tmutex_lock(&cur_file->mut);\n\t\tresp.events_reported = ctx->events_reported;\n\t\tmutex_unlock(&cur_file->mut);\n\t\tgoto response;\n\t}\n\tucma_lock_files(cur_file, new_file);\n\txa_lock(&ctx_table);\n\tlist_move_tail(&ctx->list, &new_file->ctx_list);\n\tucma_move_events(ctx, new_file);\n\tctx->file = new_file;\n\tresp.events_reported = ctx->events_reported;\n\txa_unlock(&ctx_table);\n\tucma_unlock_files(cur_file, new_file);\nresponse:\n\tif (copy_to_user(u64_to_user_ptr(cmd.response),\n\t\t\t &resp, sizeof(resp)))\n\t\tret = -EFAULT;\n\trdma_unlock_handler(ctx->cm_id);\n\tucma_put_ctx(ctx);\nfile_put:\n\tfdput(f);\n\treturn ret;\n}", "target": 1}
{"code": "static ssize_t driver_override_store(struct device *_dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct amba_device *dev = to_amba_device(_dev);\n\tchar *driver_override, *old, *cp;\n\tif (count > PATH_MAX)\n\t\treturn -EINVAL;\n\tdriver_override = kstrndup(buf, count, GFP_KERNEL);\n\tif (!driver_override)\n\t\treturn -ENOMEM;\n\tcp = strchr(driver_override, '\\n');\n\tif (cp)\n\t\t*cp = '\\0';\n\tdevice_lock(_dev);\n\told = dev->driver_override;\n\tif (strlen(driver_override)) {\n\t\tdev->driver_override = driver_override;\n\t} else {\n\t       kfree(driver_override);\n\t       dev->driver_override = NULL;\n\t}\n\tdevice_unlock(_dev);\n\tkfree(old);\n\treturn count;\n}", "target": 1}
{"code": "void RenderWidgetHostImpl::DidNavigate(uint32_t next_source_id) {\n  current_content_source_id_ = next_source_id;\n  did_receive_first_frame_after_navigation_ = false;\n  if (enable_surface_synchronization_) {\n     visual_properties_ack_pending_ = false;\n    viz::LocalSurfaceId old_surface_id = view_->GetLocalSurfaceId();\n     if (view_)\n       view_->DidNavigate();\n    viz::LocalSurfaceId new_surface_id = view_->GetLocalSurfaceId();\n    if (old_surface_id == new_surface_id)\n      return;\n   } else {\n    if (last_received_content_source_id_ >= current_content_source_id_)\n      return;\n  }\n  if (!new_content_rendering_timeout_)\n    return;\n  new_content_rendering_timeout_->Start(new_content_rendering_delay_);\n}", "target": 1}
{"code": "static int ath6kl_wmi_pstream_timeout_event_rx(struct wmi *wmi, u8 *datap,\n\t\t\t\t\t       int len)\n{\n\tstruct wmi_pstream_timeout_event *ev;\n\tif (len < sizeof(struct wmi_pstream_timeout_event))\n\t\treturn -EINVAL;\n\tev = (struct wmi_pstream_timeout_event *) datap;\n\tspin_lock_bh(&wmi->lock);\n\twmi->stream_exist_for_ac[ev->traffic_class] = 0;\n\twmi->fat_pipe_exist &= ~(1 << ev->traffic_class);\n\tspin_unlock_bh(&wmi->lock);\n\tath6kl_indicate_tx_activity(wmi->parent_dev, ev->traffic_class, false);\n\treturn 0;\n}", "target": 1}
{"code": "static int usb_host_handle_control(USBHostDevice *s, USBPacket *p)\n{\n    struct usbdevfs_urb *urb;\n    AsyncURB *aurb;\n    int ret, value, index;\n    value = le16_to_cpu(s->ctrl.req.wValue);\n    index = le16_to_cpu(s->ctrl.req.wIndex);\n    dprintf(\"husb: ctrl type 0x%x req 0x%x val 0x%x index %u len %u\\n\",\n        s->ctrl.req.bRequestType, s->ctrl.req.bRequest, value, index, \n        s->ctrl.len);\n    if (s->ctrl.req.bRequestType == 0) {\n        switch (s->ctrl.req.bRequest) {\n        case USB_REQ_SET_ADDRESS:\n            return usb_host_set_address(s, value);\n        case USB_REQ_SET_CONFIGURATION:\n            return usb_host_set_config(s, value & 0xff);\n        }\n    }\n    if (s->ctrl.req.bRequestType == 1 &&\n                  s->ctrl.req.bRequest == USB_REQ_SET_INTERFACE)\n        return usb_host_set_interface(s, index, value);\n    aurb = async_alloc();\n    aurb->hdev   = s;\n    aurb->packet = p;\n    urb = &aurb->urb;\n    urb->type     = USBDEVFS_URB_TYPE_CONTROL;\n    urb->endpoint = p->devep;\n    urb->buffer        = &s->ctrl.req;\n    urb->buffer_length = 8 + s->ctrl.len;\n    urb->usercontext = s;\n    ret = ioctl(s->fd, USBDEVFS_SUBMITURB, urb);\n    dprintf(\"husb: submit ctrl. len %u aurb %p\\n\", urb->buffer_length, aurb);\n    if (ret < 0) {\n        dprintf(\"husb: submit failed. errno %d\\n\", errno);\n        async_free(aurb);\n        switch(errno) {\n        case ETIMEDOUT:\n            return USB_RET_NAK;\n        case EPIPE:\n        default:\n            return USB_RET_STALL;\n        }\n    }\n    usb_defer_packet(p, async_cancel, aurb);\n    return USB_RET_ASYNC;\n}", "target": 1}
{"code": "static inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)\n{\n\tpmd_t pmdval = *pmd;\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tbarrier();\n#endif\n\tif (pmd_none(pmdval))\n\t\treturn 1;\n\tif (unlikely(pmd_bad(pmdval))) {\n\t\tif (!pmd_trans_huge(pmdval))\n\t\t\tpmd_clear_bad(pmd);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int oidc_request_post_preserved_restore(request_rec *r,\n\t\tconst char *original_url) {\n\toidc_debug(r, \"enter: original_url=%s\", original_url);\n\tconst char *method = \"postOnLoad\";\n\tconst char *script =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function str_decode(string) {\\n\"\n\t\t\t\t\t\"        try {\\n\"\n\t\t\t\t\t\"          result = decodeURIComponent(string);\\n\"\n\t\t\t\t\t\"        } catch (e) {\\n\"\n\t\t\t\t\t\"          result =  unescape(string);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        return result;\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        var mod_auth_openidc_preserve_post_params = JSON.parse(sessionStorage.getItem('mod_auth_openidc_preserve_post_params'));\\n\"\n\t\t\t\t\t\"\t\t sessionStorage.removeItem('mod_auth_openidc_preserve_post_params');\\n\"\n\t\t\t\t\t\"        for (var key in mod_auth_openidc_preserve_post_params) {\\n\"\n\t\t\t\t\t\"          var input = document.createElement(\\\"input\\\");\\n\"\n\t\t\t\t\t\"          input.name = str_decode(key);\\n\"\n\t\t\t\t\t\"          input.value = str_decode(mod_auth_openidc_preserve_post_params[key]);\\n\"\n\t\t\t\t\t\"          input.type = \\\"hidden\\\";\\n\"\n\t\t\t\t\t\"          document.forms[0].appendChild(input);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        document.forms[0].action = '%s';\\n\"\n\t\t\t\t\t\"        document.forms[0].submit();\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", method, original_url);\n\tconst char *body = \"    <p>Restoring...</p>\\n\"\n\t\t\t\"    <form method=\\\"post\\\"></form>\\n\";\n\treturn oidc_util_html_send(r, \"Restoring...\", script, method, body,\n\t\t\tOK);\n}", "target": 1}
{"code": "static int af9005_identify_state(struct usb_device *udev,\n\t\t\t\t struct dvb_usb_device_properties *props,\n\t\t\t\t struct dvb_usb_device_description **desc,\n\t\t\t\t int *cold)\n{\n\tint ret;\n\tu8 reply, *buf;\n\tbuf = kmalloc(FW_BULKOUT_SIZE + 2, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tret = af9005_boot_packet(udev, FW_CONFIG, &reply,\n\t\t\t\t buf, FW_BULKOUT_SIZE + 2);\n\tif (ret)\n\t\tgoto err;\n\tdeb_info(\"result of FW_CONFIG in identify state %d\\n\", reply);\n\tif (reply == 0x01)\n\t\t*cold = 1;\n\telse if (reply == 0x02)\n\t\t*cold = 0;\n\telse\n\t\treturn -EIO;\n\tdeb_info(\"Identify state cold = %d\\n\", *cold);\nerr:\n\tkfree(buf);\n\treturn ret;\n}", "target": 1}
{"code": "validGlxScreen(ClientPtr client, int screen, __GLXscreen **pGlxScreen, int *err)\n{\n    if (screen >= screenInfo.numScreens) {\n \tclient->errorValue = screen;\n \t*err = BadValue;\n \treturn FALSE;\n    }\n    *pGlxScreen = glxGetScreen(screenInfo.screens[screen]);\n    return TRUE;\n}", "target": 1}
{"code": "find_next_quote(\n    char_u\t*line,\n    int\t\tcol,\n    int\t\tquotechar,\n    char_u\t*escape)\t\n{\n    int\t\tc;\n    for (;;)\n    {\n\tc = line[col];\n\tif (c == NUL)\n\t    return -1;\n\telse if (escape != NULL && vim_strchr(escape, c))\n\t    ++col;\n\telse if (c == quotechar)\n\t    break;\n\tif (has_mbyte)\n\t    col += (*mb_ptr2len)(line + col);\n\telse\n\t    ++col;\n    }\n    return col;\n}", "target": 1}
{"code": "ex_put(exarg_T *eap)\n{\n    if (eap->line2 == 0)\n    {\n\teap->line2 = 1;\n\teap->forceit = TRUE;\n    }\n    curwin->w_cursor.lnum = eap->line2;\n    do_put(eap->regname, NULL, eap->forceit ? BACKWARD : FORWARD, 1L,\n\t\t\t\t\t\t       PUT_LINE|PUT_CURSLINE);\n}", "target": 1}
{"code": "static int vt_disallocate(unsigned int vc_num)\n{\n\tstruct vc_data *vc = NULL;\n\tint ret = 0;\n\tconsole_lock();\n\tif (vt_busy(vc_num))\n\t\tret = -EBUSY;\n\telse if (vc_num)\n\t\tvc = vc_deallocate(vc_num);\n\tconsole_unlock();\n\tif (vc && vc_num >= MIN_NR_CONSOLES) {\n\t\ttty_port_destroy(&vc->port);\n\t\tkfree(vc);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static void mutt_decode_uuencoded (STATE *s, LOFF_T len, int istext, iconv_t cd)\n{\n  char tmps[SHORT_STRING];\n  char linelen, c, l, out;\n  char *pt;\n  char bufi[BUFI_SIZE];\n  size_t k = 0;\n  if (istext)\n    state_set_prefix(s);\n  while (len > 0)\n  {\n    if ((fgets(tmps, sizeof(tmps), s->fpin)) == NULL)\n      return;\n    len -= mutt_strlen(tmps);\n    if ((!mutt_strncmp (tmps, \"begin\", 5)) && ISSPACE (tmps[5]))\n      break;\n  }\n  while (len > 0)\n  {\n    if ((fgets(tmps, sizeof(tmps), s->fpin)) == NULL)\n      return;\n    len -= mutt_strlen(tmps);\n    if (!mutt_strncmp (tmps, \"end\", 3))\n      break;\n    pt = tmps;\n    linelen = decode_byte (*pt);\n    pt++;\n    for (c = 0; c < linelen;)\n    {\n      for (l = 2; l <= 6; l += 2)\n      {\n\tout = decode_byte (*pt) << l;\n\tpt++;\n\tout |= (decode_byte (*pt) >> (6 - l));\n\tbufi[k++] = out;\n\tc++;\n\tif (c == linelen)\n\t  break;\n      }\n      mutt_convert_to_state (cd, bufi, &k, s);\n      pt++;\n    }\n  }\n  mutt_convert_to_state (cd, bufi, &k, s);\n  mutt_convert_to_state (cd, 0, 0, s);\n  state_reset_prefix(s);\n}", "target": 1}
{"code": "do_bid_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap __attribute__((__unused__)), uint32_t namesz, uint32_t descsz,\n     size_t noff, size_t doff, int *flags)\n {\n \tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"GNU\") == 0 &&\n\t    type == NT_GNU_BUILD_ID && (descsz >= 4 || descsz <= 20)) {\n \t\tuint8_t desc[20];\n \t\tconst char *btype;\n \t\tuint32_t i;\n\t\t*flags |= FLAGS_DID_BUILD_ID;\n\t\tswitch (descsz) {\n\t\tcase 8:\n\t\t    btype = \"xxHash\";\n\t\t    break;\n\t\tcase 16:\n\t\t    btype = \"md5/uuid\";\n\t\t    break;\n\t\tcase 20:\n\t\t    btype = \"sha1\";\n\t\t    break;\n\t\tdefault:\n\t\t    btype = \"unknown\";\n\t\t    break;\n\t\t}\n\t\tif (file_printf(ms, \", BuildID[%s]=\", btype) == -1)\n\t\t\treturn 1;\n\t\t(void)memcpy(desc, &nbuf[doff], descsz);\n\t\tfor (i = 0; i < descsz; i++)\n\t\t    if (file_printf(ms, \"%02x\", desc[i]) == -1)\n\t\t\treturn 1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": " void ChromeContentBrowserClient::OpenURL(\n    content::BrowserContext* browser_context,\n     const content::OpenURLParams& params,\n    const base::Callback<void(content::WebContents*)>& callback) {\n   DCHECK_CURRENTLY_ON(BrowserThread::UI);\n #if defined(OS_ANDROID)\n   ServiceTabLauncher::GetInstance()->LaunchTab(browser_context, params,\n                                               callback);\n#else\n  NavigateParams nav_params(Profile::FromBrowserContext(browser_context),\n                            params.url, params.transition);\n  nav_params.FillNavigateParamsFromOpenURLParams(params);\n  nav_params.user_gesture = params.user_gesture;\n  Navigate(&nav_params);\n  callback.Run(nav_params.navigated_or_inserted_contents);\n#endif\n}", "target": 1}
{"code": "static int hash_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tstruct ahash_request *req = &ctx->req;\n\tchar state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];\n \tstruct sock *sk2;\n \tstruct alg_sock *ask2;\n \tstruct hash_ctx *ctx2;\n \tint err;\n\terr = crypto_ahash_export(req, state);\n \tif (err)\n \t\treturn err;\n\terr = af_alg_accept(ask->parent, newsock);\n\tif (err)\n\t\treturn err;\n \tsk2 = newsock->sk;\n \task2 = alg_sk(sk2);\n \tctx2 = ask2->private;\n\tctx2->more = 1;\n \terr = crypto_ahash_import(&ctx2->req, state);\n \tif (err) {\n\t\tsock_orphan(sk2);\n\t\tsock_put(sk2);\n\t}\n\treturn err;\n}", "target": 1}
{"code": "static void hidp_process_report(struct hidp_session *session,\n\t\t\t\tint type, const u8 *data, int len, int intr)\n{\n\tif (len > HID_MAX_BUFFER_SIZE)\n\t\tlen = HID_MAX_BUFFER_SIZE;\n\tmemcpy(session->input_buf, data, len);\n\thid_input_report(session->hid, type, session->input_buf, len, intr);\n}", "target": 1}
{"code": "rpmRC hdrblobInit(const void *uh, size_t uc,\n\t\trpmTagVal regionTag, int exact_size,\n\t\tstruct hdrblob_s *blob, char **emsg)\n{\n    rpmRC rc = RPMRC_FAIL;\n    memset(blob, 0, sizeof(*blob));\n    blob->ei = (int32_t *) uh; \n    blob->il = ntohl(blob->ei[0]);\n    blob->dl = ntohl(blob->ei[1]);\n    blob->pe = (entryInfo) &(blob->ei[2]);\n    blob->pvlen = sizeof(blob->il) + sizeof(blob->dl) +\n\t\t  (blob->il * sizeof(*blob->pe)) + blob->dl;\n    blob->dataStart = (uint8_t *) (blob->pe + blob->il);\n    blob->dataEnd = blob->dataStart + blob->dl;\n    if (blob->pvlen >= headerMaxbytes || (uc && blob->pvlen != uc)) {\n\trasprintf(emsg, _(\"blob size(%d): BAD, 8 + 16 * il(%d) + dl(%d)\"),\n\t\t\tblob->pvlen, blob->il, blob->dl);\n\tgoto exit;\n    }\n    if (hdrblobVerifyRegion(regionTag, exact_size, blob, emsg) == RPMRC_FAIL)\n\tgoto exit;\n    if (hdrblobVerifyInfo(blob, emsg))\n\tgoto exit;\n    rc = RPMRC_OK;\nexit:\n    return rc;\n}", "target": 1}
{"code": "decrypt(gcry_mpi_t output, gcry_mpi_t a, gcry_mpi_t b, ELG_secret_key *skey )\n{\n  gcry_mpi_t t1 = mpi_alloc_secure( mpi_get_nlimbs( skey->p ) );\n  gcry_mpi_powm( t1, a, skey->x, skey->p );\n  mpi_invm( t1, t1, skey->p );\n  mpi_mulm( output, b, t1, skey->p );\n#if 0\n  if( DBG_CIPHER )\n    {\n      log_mpidump(\"elg decrypted x= \", skey->x);\n      log_mpidump(\"elg decrypted p= \", skey->p);\n      log_mpidump(\"elg decrypted a= \", a);\n      log_mpidump(\"elg decrypted b= \", b);\n      log_mpidump(\"elg decrypted M= \", output);\n    }\n#endif\n  mpi_free(t1);\n}", "target": 1}
{"code": "Node* Graph::AddNode(NodeDef node_def, Status* status) {\n  const OpRegistrationData* op_reg_data;\n  status->Update(ops_.LookUp(node_def.op(), &op_reg_data));\n  if (!status->ok()) return nullptr;\n  DataTypeVector inputs;\n  DataTypeVector outputs;\n  status->Update(\n      InOutTypesForNode(node_def, op_reg_data->op_def, &inputs, &outputs));\n  if (!status->ok()) {\n    *status = AttachDef(*status, node_def);\n    return nullptr;\n  }\n  Node::NodeClass node_class = op_reg_data->is_function_op\n                                   ? Node::NC_FUNCTION_OP\n                                   : Node::GetNodeClassForOp(node_def.op());\n  if (op_reg_data->type_ctor != nullptr) {\n    VLOG(3) << \"AddNode: found type constructor for \" << node_def.name();\n    const auto ctor_type =\n        full_type::SpecializeType(AttrSlice(node_def), op_reg_data->op_def);\n    const FullTypeDef ctor_typedef = ctor_type.ValueOrDie();\n    if (ctor_typedef.type_id() != TFT_UNSET) {\n      *(node_def.mutable_experimental_type()) = ctor_typedef;\n    }\n  } else {\n    VLOG(3) << \"AddNode: no type constructor for \" << node_def.name();\n  }\n  Node* node = AllocateNode(std::make_shared<NodeProperties>(\n                                &op_reg_data->op_def, std::move(node_def),\n                                inputs, outputs, op_reg_data->fwd_type_fn),\n                            nullptr, node_class);\n  return node;\n}", "target": 1}
{"code": "static void msf2_dma_tx(MSF2EmacState *s)\n{\n    NetClientState *nc = qemu_get_queue(s->nic);\n    hwaddr desc = s->regs[R_DMA_TX_DESC];\n    uint8_t buf[MAX_PKT_SIZE];\n    EmacDesc d;\n    int size;\n    uint8_t pktcnt;\n    uint32_t status;\n    if (!(s->regs[R_CFG1] & R_CFG1_TX_EN_MASK)) {\n        return;\n    }\n    while (1) {\n        emac_load_desc(s, &d, desc);\n        if (d.pktsize & EMPTY_MASK) {\n            break;\n        }\n        size = d.pktsize & PKT_SIZE;\n        address_space_read(&s->dma_as, d.pktaddr, MEMTXATTRS_UNSPECIFIED,\n                           buf, size);\n        if (s->regs[R_CFG1] & R_CFG1_LB_EN_MASK) {\n            nc->info->receive(nc, buf, size);\n        } else {\n            qemu_send_packet(nc, buf, size);\n        }\n        d.pktsize |= EMPTY_MASK;\n        emac_store_desc(s, &d, desc);\n        status = s->regs[R_DMA_TX_STATUS];\n        pktcnt = FIELD_EX32(status, DMA_TX_STATUS, PKTCNT);\n        pktcnt++;\n        s->regs[R_DMA_TX_STATUS] = FIELD_DP32(status, DMA_TX_STATUS,\n                                              PKTCNT, pktcnt);\n        s->regs[R_DMA_TX_STATUS] |= R_DMA_TX_STATUS_PKT_SENT_MASK;\n        desc = d.next;\n    }\n    s->regs[R_DMA_TX_STATUS] |= R_DMA_TX_STATUS_UNDERRUN_MASK;\n    s->regs[R_DMA_TX_CTL] &= ~R_DMA_TX_CTL_EN_MASK;\n}", "target": 1}
{"code": "XdmcpGenerateKey (XdmAuthKeyPtr key)\n{\n #ifndef HAVE_ARC4RANDOM_BUF\n     long    lowbits, highbits;\n     srandom ((int)getpid() ^ time((Time_t *)0));\n    highbits = random ();\n     highbits = random ();\n     getbits (lowbits, key->data);\n     getbits (highbits, key->data + 4);\n#else\n     arc4random_buf(key->data, 8);\n#endif\n }", "target": 1}
{"code": "FindEmptyObjectSlot(\n\t\t    TPMI_DH_OBJECT  *handle         \n\t\t    )\n{\n    UINT32               i;\n    OBJECT              *object;\n    for(i = 0; i < MAX_LOADED_OBJECTS; i++)\n\t{\n\t    object = &s_objects[i];\n\t    if(object->attributes.occupied == CLEAR)\n\t\t{\n\t\t    if(handle)\n\t\t\t*handle = i + TRANSIENT_FIRST;\n\t\t    MemorySet(&object->attributes, 0, sizeof(OBJECT_ATTRIBUTES));\n\t\t    return object;\n\t\t}\n\t}\n    return NULL;\n}", "target": 1}
{"code": "pam_converse (int num_msg, PAM_CONVERSE_ARG2_TYPE **msg,\n  struct pam_response **resp, void *appdata_ptr)\n{\nint sep = 0;\nstruct pam_response *reply;\nif (  pam_arg_ended\n   || !(reply = malloc(sizeof(struct pam_response) * num_msg)))\n  return PAM_CONV_ERR;\nfor (int i = 0; i < num_msg; i++)\n  {\n  uschar *arg;\n  switch (msg[i]->msg_style)\n    {\n    case PAM_PROMPT_ECHO_ON:\n    case PAM_PROMPT_ECHO_OFF:\n      if (!(arg = string_nextinlist(&pam_args, &sep, NULL, 0)))\n\t{\n\targ = US\"\";\n\tpam_arg_ended = TRUE;\n\t}\n      reply[i].resp = CS string_copy_malloc(arg); \n      reply[i].resp_retcode = PAM_SUCCESS;\n      break;\n    case PAM_TEXT_INFO:    \n    case PAM_ERROR_MSG:\n      reply[i].resp_retcode = PAM_SUCCESS;\n      reply[i].resp = NULL;\n      break;\n    default:  \n      free(reply);\n      pam_conv_had_error = TRUE;\n      return PAM_CONV_ERR;\n    }\n  }\n*resp = reply;\nreturn PAM_SUCCESS;\n}", "target": 1}
{"code": "static void test_jwt_token_escape(void)\n{\n\tstruct test_case {\n\t\tconst char *azp;\n\t\tconst char *alg;\n\t\tconst char *kid;\n\t\tconst char *esc_azp;\n\t\tconst char *esc_kid;\n\t} test_cases[] = {\n\t\t{ \"\", \"hs256\", \"\", \"default\", \"default\" },\n\t\t{ \"\", \"hs256\", \"test\", \"default\", \"test\" },\n\t\t{ \"test\", \"hs256\", \"test\", \"test\", \"test\" },\n\t\t{\n\t\t\t\"http:\n\t\t\t\"hs256\",\n\t\t\t\"http:\n\t\t\t\"http:%2f%2ftest%2eunit%2flocal%25key\",\n\t\t\t\"http:%2f%2ftest%2eunit%2flocal%25key\"\n\t\t},\n\t\t{ \"../\", \"hs256\", \"../\", \"%2e%2e%2f\", \"%2e%2e%2f\" },\n\t};\n\tbuffer_t *b64_key =\n\t\tt_base64_encode(0, SIZE_MAX, hs_sign_key->data, hs_sign_key->used);\n\tARRAY_TYPE(oauth2_field) fields;\n\tt_array_init(&fields, 8);\n\tfor (size_t i = 0; i < N_ELEMENTS(test_cases); i++) {\n\t\tconst struct test_case *test_case = &test_cases[i];\n\t\tarray_clear(&fields);\n\t\tstruct oauth2_field *field = array_append_space(&fields);\n\t\tfield->name = \"sub\";\n\t\tfield->value = \"testuser\";\n\t\tif (*test_case->azp != '\\0') {\n\t\t\tfield = array_append_space(&fields);\n\t\t\tfield->name = \"azp\";\n\t\t\tfield->value = test_case->azp;\n\t\t}\n\t\tif (*test_case->kid != '\\0') {\n\t\t\tfield = array_append_space(&fields);\n\t\t\tfield->name = \"kid\";\n\t\t\tfield->value = test_case->kid;\n\t\t}\n\t\tsave_key_azp_to(test_case->alg, test_case->esc_azp, test_case->esc_kid,\n\t\t\t\tstr_c(b64_key));\n\t\tbuffer_t *token = create_jwt_token_fields_kid(test_case->alg,\n\t\t\t\t\t\t\t      test_case->kid,\n\t\t\t\t\t\t\t      time(NULL)+500,\n\t\t\t\t\t\t\t      time(NULL)-500,\n\t\t\t\t\t\t\t      0, &fields);\n\t\tsign_jwt_token_hs256(token, hs_sign_key);\n\t\ttest_jwt_token(str_c(token));\n\t}\n}", "target": 1}
{"code": "nosy_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct client *client = file->private_data;\n\tspinlock_t *client_list_lock = &client->lynx->client_list_lock;\n\tstruct nosy_stats stats;\n\tswitch (cmd) {\n\tcase NOSY_IOC_GET_STATS:\n\t\tspin_lock_irq(client_list_lock);\n\t\tstats.total_packet_count = client->buffer.total_packet_count;\n\t\tstats.lost_packet_count  = client->buffer.lost_packet_count;\n\t\tspin_unlock_irq(client_list_lock);\n\t\tif (copy_to_user((void __user *) arg, &stats, sizeof stats))\n\t\t\treturn -EFAULT;\n\t\telse\n\t\t\treturn 0;\n\tcase NOSY_IOC_START:\n\t\tspin_lock_irq(client_list_lock);\n\t\tlist_add_tail(&client->link, &client->lynx->client_list);\n\t\tspin_unlock_irq(client_list_lock);\n\t\treturn 0;\n\tcase NOSY_IOC_STOP:\n\t\tspin_lock_irq(client_list_lock);\n\t\tlist_del_init(&client->link);\n\t\tspin_unlock_irq(client_list_lock);\n\t\treturn 0;\n\tcase NOSY_IOC_FILTER:\n\t\tspin_lock_irq(client_list_lock);\n\t\tclient->tcode_mask = arg;\n\t\tspin_unlock_irq(client_list_lock);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}", "target": 1}
{"code": "static int ssl_parse_server_psk_hint( mbedtls_ssl_context *ssl,\n                                      unsigned char **p,\n                                      unsigned char *end )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n    size_t  len;\n    ((void) ssl);\n    if( (*p) > end - 2 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                    \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n     len = (*p)[0] << 8 | (*p)[1];\n     *p += 2;\n    if( (*p) + len > end )\n     {\n         MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                     \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n    *p += len;\n    ret = 0;\n    return( ret );\n}", "target": 1}
{"code": "SplashBitmap::SplashBitmap(int widthA, int heightA, int rowPad,\n\t\t\t   SplashColorMode modeA, GBool alphaA,\n\t\t\t   GBool topDown) {\n  width = widthA;\n  height = heightA;\n  mode = modeA;\n  switch (mode) {\n  case splashModeMono1:\n    rowSize = (width + 7) >> 3;\n    break;\n  case splashModeMono8:\n    rowSize = width;\n    break;\n  case splashModeRGB8:\n  case splashModeBGR8:\n    rowSize = width * 3;\n    break;\n  case splashModeXBGR8:\n    rowSize = width * 4;\n    break;\n#if SPLASH_CMYK\n  case splashModeCMYK8:\n    rowSize = width * 4;\n    break;\n#endif\n  }\n  rowSize += rowPad - 1;\n  rowSize -= rowSize % rowPad;\n  data = (SplashColorPtr)gmalloc(rowSize * height);\n  if (!topDown) {\n    data += (height - 1) * rowSize;\n    rowSize = -rowSize;\n  }\n  if (alphaA) {\n    alpha = (Guchar *)gmalloc(width * height);\n  } else {\n    alpha = NULL;\n  }\n}", "target": 1}
{"code": "void Utf8DecoderBase::WriteUtf16Slow(const uint8_t* stream,\n                                     uint16_t* data,\n                                     unsigned data_length) {\n  while (data_length != 0) {\n    unsigned cursor = 0;\n    uint32_t character = Utf8::ValueOf(stream, Utf8::kMaxEncodedSize, &cursor);\n    stream += cursor;\n    if (character > unibrow::Utf16::kMaxNonSurrogateCharCode) {\n      *data++ = Utf16::LeadSurrogate(character);\n      *data++ = Utf16::TrailSurrogate(character);\n      DCHECK(data_length > 1);\n      data_length -= 2;\n    } else {\n      *data++ = character;\n      data_length -= 1;\n    }\n  }\n}", "target": 1}
{"code": "evbuffer_add(struct evbuffer *buf, const void *data, size_t datlen)\n{\n\tsize_t need = buf->misalign + buf->off + datlen;\n\tsize_t oldoff = buf->off;\n\tif (buf->totallen < need) {\n\t\tif (evbuffer_expand(buf, datlen) == -1)\n\t\t\treturn (-1);\n\t}\n\tmemcpy(buf->buffer + buf->off, data, datlen);\n\tbuf->off += datlen;\n\tif (datlen && buf->cb != NULL)\n\t\t(*buf->cb)(buf, oldoff, buf->off, buf->cbarg);\n\treturn (0);\n}", "target": 1}
{"code": "int handle(int s, unsigned char* data, int len, struct sockaddr_in *s_in)\n{\n\tchar buf[2048];\n\tunsigned short *cmd = (unsigned short *)buf;\n\tint plen;\n\tstruct in_addr *addr = &s_in->sin_addr;\n\tunsigned short *pid = (unsigned short*) data;\n\tif (len == S_HELLO_LEN && memcmp(data, \"sorbo\", 5) == 0) {\n\t\tunsigned short *id = (unsigned short*) (data+5);\n\t\tint x = 2+4+2;\n\t\t*cmd = htons(S_CMD_INET_CHECK);\n\t\tmemcpy(cmd+1, addr, 4);\n\t\tmemcpy(cmd+1+2, id, 2);\n\t\tprintf(\"Inet check by %s %d\\n\",\n\t\t       inet_ntoa(*addr), ntohs(*id));\n\t\tif (send(s, buf, x, 0) != x)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n \t*cmd++ = htons(S_CMD_PACKET);\n \t*cmd++ = *pid;\n \tplen = len - 2;\n \tlast_id = ntohs(*pid);\n \tif (last_id > 20000)\n\t\twrap = 1;\n\tif (wrap && last_id < 100) {\n\t\twrap = 0;\n\t\tmemset(ids, 0, sizeof(ids));\n\t}\n\tprintf(\"Got packet %d %d\", last_id, plen);\n\tif (is_dup(last_id)) {\n\t\tprintf(\" (DUP)\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"\\n\");\n\t*cmd++ = htons(plen);\n\tmemcpy(cmd, data+2, plen);\n\tplen += 2 + 2 + 2;\n\tassert(plen <= (int) sizeof(buf));\n\tif (send(s, buf, plen, 0) != plen)\n\t\treturn 1;\n\treturn 0;\n}", "target": 1}
{"code": "static int sched_read_attr(struct sched_attr __user *uattr,\n\t\t\t   struct sched_attr *attr,\n\t\t\t   unsigned int usize)\n{\n\tint ret;\n\tif (!access_ok(VERIFY_WRITE, uattr, usize))\n\t\treturn -EFAULT;\n\tif (usize < sizeof(*attr)) {\n\t\tunsigned char *addr;\n\t\tunsigned char *end;\n\t\taddr = (void *)attr + usize;\n\t\tend  = (void *)attr + sizeof(*attr);\n\t\tfor (; addr < end; addr++) {\n\t\t\tif (*addr)\n\t\t\t\tgoto err_size;\n\t\t}\n \t\tattr->size = usize;\n \t}\n\tret = copy_to_user(uattr, attr, usize);\n \tif (ret)\n \t\treturn -EFAULT;\nout:\n\treturn ret;\nerr_size:\n\tret = -E2BIG;\n\tgoto out;\n}", "target": 1}
{"code": "struct vfsmount *clone_private_mount(const struct path *path)\n{\n\tstruct mount *old_mnt = real_mount(path->mnt);\n\tstruct mount *new_mnt;\n\tif (IS_MNT_UNBINDABLE(old_mnt))\n\t\treturn ERR_PTR(-EINVAL);\n\tnew_mnt = clone_mnt(old_mnt, path->dentry, CL_PRIVATE);\n\tif (IS_ERR(new_mnt))\n\t\treturn ERR_CAST(new_mnt);\n\tnew_mnt->mnt_ns = MNT_NS_INTERNAL;\n\treturn &new_mnt->mnt;\n}", "target": 1}
{"code": "static size_t handle_returned_header (void *ptr, size_t size, size_t nmemb, void *stream)\n{\n    auth_client *auth_user = stream;\n    size_t bytes = size * nmemb;\n    client_t *client = auth_user->client;\n    if (client)\n    {\n        auth_t *auth = client->auth;\n        auth_url *url = auth->state;\n        if (strncasecmp (ptr, url->auth_header, url->auth_header_len) == 0)\n            client->authenticated = 1;\n        if (strncasecmp (ptr, url->timelimit_header, url->timelimit_header_len) == 0)\n        {\n            unsigned int limit = 0;\n            sscanf ((char *)ptr+url->timelimit_header_len, \"%u\\r\\n\", &limit);\n            client->con->discon_time = time(NULL) + limit;\n        }\n        if (strncasecmp (ptr, \"icecast-auth-message: \", 22) == 0)\n        {\n            char *eol;\n            snprintf (url->errormsg, sizeof (url->errormsg), \"%s\", (char*)ptr+22);\n            eol = strchr (url->errormsg, '\\r');\n            if (eol == NULL)\n                eol = strchr (url->errormsg, '\\n');\n            if (eol)\n                *eol = '\\0';\n        }\n    }\n    return bytes;\n}", "target": 1}
{"code": "static irqreturn_t snd_msnd_interrupt(int irq, void *dev_id)\n {\n \tstruct snd_msnd *chip = dev_id;\n \tvoid *pwDSPQData = chip->mappedbase + DSPQ_DATA_BUFF;\n\twhile (readw(chip->DSPQ + JQS_wTail) != readw(chip->DSPQ + JQS_wHead)) {\n\t\tu16 wTmp;\n\t\tsnd_msnd_eval_dsp_msg(chip,\n\t\t\treadw(pwDSPQData + 2 * readw(chip->DSPQ + JQS_wHead)));\n\t\twTmp = readw(chip->DSPQ + JQS_wHead) + 1;\n\t\tif (wTmp > readw(chip->DSPQ + JQS_wSize))\n\t\t\twritew(0, chip->DSPQ + JQS_wHead);\n\t\telse\n\t\t\twritew(wTmp, chip->DSPQ + JQS_wHead);\n \t}\n \tinb(chip->io + HP_RXL);\n \treturn IRQ_HANDLED;\n}", "target": 1}
{"code": "static int decode_studio_vop_header(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    if (get_bits_left(gb) <= 32)\n         return 0;\n     s->partitioned_frame = 0;\n     s->decode_mb = mpeg4_decode_studio_mb;\n     decode_smpte_tc(ctx, gb);\n    skip_bits(gb, 10); \n    skip_bits(gb, 2); \n    s->pict_type = get_bits(gb, 2) + AV_PICTURE_TYPE_I; \n    if (get_bits1(gb)) { \n        skip_bits1(gb); \n        skip_bits1(gb); \n        s->progressive_frame = get_bits1(gb) ^ 1; \n    }\n    if (s->pict_type == AV_PICTURE_TYPE_I) {\n        if (get_bits1(gb))\n            reset_studio_dc_predictors(s);\n    }\n    if (ctx->shape != BIN_ONLY_SHAPE) {\n        s->alternate_scan = get_bits1(gb);\n        s->frame_pred_frame_dct = get_bits1(gb);\n        s->dct_precision = get_bits(gb, 2);\n        s->intra_dc_precision = get_bits(gb, 2);\n        s->q_scale_type = get_bits1(gb);\n    }\n    if (s->alternate_scan) {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);\n    } else {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_zigzag_direct);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_zigzag_direct);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);\n    }\n    mpeg4_load_default_matrices(s);\n    next_start_code_studio(gb);\n    extension_and_user_data(s, gb, 4);\n    return 0;\n}", "target": 1}
{"code": "__xml_acl_post_process(xmlNode * xml)\n{\n    xmlNode *cIter = __xml_first_child(xml);\n    xml_private_t *p = xml->_private;\n     if(is_set(p->flags, xpf_created)) {\n         xmlAttr *xIter = NULL;\n         for (xIter = crm_first_attr(xml); xIter != NULL; xIter = xIter->next) {\n             const char *prop_name = (const char *)xIter->name;\n            if (strcmp(prop_name, XML_ATTR_ID) == 0) {\n                 continue;\n            } else if(__xml_acl_check(xml, NULL, xpf_acl_write)) {\n                crm_trace(\"Creation of %s=%s is allowed\", crm_element_name(xml), ID(xml));\n                 break;\n             } else {\n                char *path = xml_get_path(xml);\n                 crm_trace(\"Cannot add new node %s at %s\", crm_element_name(xml), path);\n                 if(xml != xmlDocGetRootElement(xml->doc)) {\n                    xmlUnlinkNode(xml);\n                    xmlFreeNode(xml);\n                }\n                free(path);\n                 return;\n             }\n         }\n     }\n     while (cIter != NULL) {\n        xmlNode *child = cIter;\n        cIter = __xml_next(cIter); \n        __xml_acl_post_process(child);\n    }\n}", "target": 1}
{"code": "int tpm_open(struct inode *inode, struct file *file)\n{\n\tint minor = iminor(inode);\n\tstruct tpm_chip *chip = NULL, *pos;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pos, &tpm_chip_list, list) {\n\t\tif (pos->vendor.miscdev.minor == minor) {\n\t\t\tchip = pos;\n\t\t\tget_device(chip->dev);\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (!chip)\n\t\treturn -ENODEV;\n\tif (test_and_set_bit(0, &chip->is_open)) {\n\t\tdev_dbg(chip->dev, \"Another process owns this TPM\\n\");\n\t\tput_device(chip->dev);\n \t\treturn -EBUSY;\n \t}\n\tchip->data_buffer = kmalloc(TPM_BUFSIZE * sizeof(u8), GFP_KERNEL);\n \tif (chip->data_buffer == NULL) {\n \t\tclear_bit(0, &chip->is_open);\n \t\tput_device(chip->dev);\n\t\treturn -ENOMEM;\n\t}\n\tatomic_set(&chip->data_pending, 0);\n\tfile->private_data = chip;\n\treturn 0;\n}", "target": 1}
{"code": "MagickExport void RemoveDuplicateLayers(Image **images,\n     ExceptionInfo *exception)\n {\n  register Image\n    *curr,\n    *next;\n   RectangleInfo\n     bounds;\n   assert((*images) != (const Image *) NULL);\n   assert((*images)->signature == MagickCoreSignature);\n   if ((*images)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",(*images)->filename);\n   assert(exception != (ExceptionInfo *) NULL);\n   assert(exception->signature == MagickCoreSignature);\n  curr=GetFirstImageInList(*images);\n  for (; (next=GetNextImageInList(curr)) != (Image *) NULL; curr=next)\n   {\n    if ( curr->columns != next->columns || curr->rows != next->rows\n         || curr->page.x != next->page.x || curr->page.y != next->page.y )\n       continue;\n    bounds=CompareImagesBounds(curr,next,CompareAnyLayer,exception);\n    if ( bounds.x < 0 ) {\n      size_t time;\n      time = curr->delay*1000/curr->ticks_per_second;\n      time += next->delay*1000/next->ticks_per_second;\n      next->ticks_per_second = 100L;\n      next->delay = time*curr->ticks_per_second/1000;\n      next->iterations = curr->iterations;\n      *images = curr;\n      (void) DeleteImageFromList(images);\n    }\n   }\n  *images = GetFirstImageInList(*images);\n }", "target": 1}
{"code": "static inline void get_page(struct page *page)\n{\n\tpage = compound_head(page);\n\tVM_BUG_ON_PAGE(page_ref_count(page) <= 0, page);\n\tpage_ref_inc(page);\n}", "target": 1}
{"code": " void TestBlinkPlatformSupport::cryptographicallyRandomValues(\n     unsigned char* buffer,\n     size_t length) {\n }", "target": 1}
{"code": "ProcEstablishConnection(ClientPtr client)\n{\n    const char *reason;\n    char *auth_proto, *auth_string;\n    xConnClientPrefix *prefix;\n    REQUEST(xReq);\n     prefix = (xConnClientPrefix *) ((char *) stuff + sz_xReq);\n     auth_proto = (char *) prefix + sz_xConnClientPrefix;\n     auth_string = auth_proto + pad_to_int32(prefix->nbytesAuthProto);\n    if ((prefix->majorVersion != X_PROTOCOL) ||\n         (prefix->minorVersion != X_PROTOCOL_REVISION))\n         reason = \"Protocol version mismatch\";\n     else\n    return (SendConnSetup(client, reason));\n}", "target": 1}
{"code": "static inline void *host_from_stream_offset(QEMUFile *f,\n                                            ram_addr_t offset,\n                                            int flags)\n{\n    static RAMBlock *block = NULL;\n    char id[256];\n    uint8_t len;\n    if (flags & RAM_SAVE_FLAG_CONTINUE) {\n        if (!block) {\n            error_report(\"Ack, bad migration stream!\");\n            return NULL;\n        }\n        return memory_region_get_ram_ptr(block->mr) + offset;\n    }\n    len = qemu_get_byte(f);\n    qemu_get_buffer(f, (uint8_t *)id, len);\n    id[len] = 0;\n    QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n        if (!strncmp(id, block->idstr, sizeof(id)))\n            return memory_region_get_ram_ptr(block->mr) + offset;\n    }\n    error_report(\"Can't find block %s!\", id);\n    return NULL;\n}", "target": 1}
{"code": "static apr_byte_t oidc_validate_post_logout_url(request_rec *r, const char *url,\n\t\tchar **err_str, char **err_desc) {\n\tapr_uri_t uri;\n\tconst char *c_host = NULL;\n\tif (apr_uri_parse(r->pool, url, &uri) != APR_SUCCESS) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n\t\t*err_desc = apr_psprintf(r->pool, \"Logout URL malformed: %s\", url);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t}\n\tc_host = oidc_get_current_url_host(r);\n\tif ((uri.hostname != NULL)\n\t\t\t&& ((strstr(c_host, uri.hostname) == NULL)\n\t\t\t\t\t|| (strstr(uri.hostname, c_host) == NULL))) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Invalid Request\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"logout value \\\"%s\\\" does not match the hostname of the current request \\\"%s\\\"\",\n\t\t\t\t\t\tapr_uri_unparse(r->pool, &uri, 0), c_host);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t} else if (strstr(url, \"/\") != url) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"No hostname was parsed and it does not seem to be relative, i.e starting with '/': %s\",\n\t\t\t\t\t\turl);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t}\n\tif (((strstr(url, \"\\n\") != NULL) || strstr(url, \"\\r\") != NULL)) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Invalid Request\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"logout value \\\"%s\\\" contains illegal \\\"\\n\\\" or \\\"\\r\\\" character(s)\",\n\t\t\t\t\t\turl);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "static bool checkreturn decode_static_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)\n{\n    pb_type_t type;\n    pb_decoder_t func;\n    type = iter->pos->type;\n    func = PB_DECODERS[PB_LTYPE(type)];\n    switch (PB_HTYPE(type))\n    {\n        case PB_HTYPE_REQUIRED:\n            return func(stream, iter->pos, iter->pData);\n        case PB_HTYPE_OPTIONAL:\n            if (iter->pSize != iter->pData)\n                *(bool*)iter->pSize = true;\n            return func(stream, iter->pos, iter->pData);\n        case PB_HTYPE_REPEATED:\n            if (wire_type == PB_WT_STRING\n                && PB_LTYPE(type) <= PB_LTYPE_LAST_PACKABLE)\n            {\n                bool status = true;\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n                pb_istream_t substream;\n                if (!pb_make_string_substream(stream, &substream))\n                    return false;\n                while (substream.bytes_left > 0 && *size < iter->pos->array_size)\n                {\n                    void *pItem = (char*)iter->pData + iter->pos->data_size * (*size);\n                    if (!func(&substream, iter->pos, pItem))\n                    {\n                        status = false;\n                        break;\n                    }\n                    (*size)++;\n                }\n                if (substream.bytes_left != 0)\n                    PB_RETURN_ERROR(stream, \"array overflow\");\n                if (!pb_close_string_substream(stream, &substream))\n                    return false;\n                return status;\n            }\n            else\n            {\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n                char *pItem = (char*)iter->pData + iter->pos->data_size * (*size);\n                if ((*size)++ >= iter->pos->array_size)\n                    PB_RETURN_ERROR(stream, \"array overflow\");\n                return func(stream, iter->pos, pItem);\n            }\n        case PB_HTYPE_ONEOF:\n            *(pb_size_t*)iter->pSize = iter->pos->tag;\n            if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE)\n            {\n                memset(iter->pData, 0, iter->pos->data_size);\n                pb_message_set_to_defaults((const pb_field_t*)iter->pos->ptr, iter->pData);\n            }\n            return func(stream, iter->pos, iter->pData);\n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n}", "target": 1}
{"code": "static x86newTokenType getToken(const char *str, size_t *begin, size_t *end) {\n\twhile (begin && isspace ((ut8)str[*begin])) {\n\t\t++(*begin);\n\t}\n\tif (!str[*begin]) {                \n\t\t*end = *begin;\n\t\treturn TT_EOF;\n\t} else if (isalpha ((ut8)str[*begin])) {   \n\t\t*end = *begin;\n\t\twhile (end && isalnum ((ut8)str[*end])) {\n\t\t\t++(*end);\n\t\t}\n\t\treturn TT_WORD;\n\t} else if (isdigit ((ut8)str[*begin])) {   \n\t\t*end = *begin;\n\t\twhile (end && isalnum ((ut8)str[*end])) {     \n\t\t\t++(*end);\n\t\t}\n\t\treturn TT_NUMBER;\n\t} else {                             \n\t\t*end = *begin + 1;\n\t\treturn TT_SPECIAL;\n\t}\n}", "target": 1}
{"code": "inline int nci_request(struct nci_dev *ndev,\n\t\t       void (*req)(struct nci_dev *ndev,\n\t\t\t\t   const void *opt),\n\t\t       const void *opt, __u32 timeout)\n{\n\tint rc;\n\tif (!test_bit(NCI_UP, &ndev->flags))\n\t\treturn -ENETDOWN;\n\tmutex_lock(&ndev->req_lock);\n\trc = __nci_request(ndev, req, opt, timeout);\n\tmutex_unlock(&ndev->req_lock);\n\treturn rc;\n}", "target": 1}
{"code": "static int set_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)\n{\n\t__u32 __user *uaddr = (__u32 __user *)(unsigned long)reg->addr;\n\tstruct kvm_regs *regs = vcpu_gp_regs(vcpu);\n\tint nr_regs = sizeof(*regs) / sizeof(__u32);\n\t__uint128_t tmp;\n\tvoid *valp = &tmp;\n\tu64 off;\n\tint err = 0;\n\toff = core_reg_offset_from_id(reg->id);\n\tif (off >= nr_regs ||\n\t    (off + (KVM_REG_SIZE(reg->id) / sizeof(__u32))) >= nr_regs)\n\t\treturn -ENOENT;\n\tif (validate_core_offset(reg))\n\t\treturn -EINVAL;\n\tif (KVM_REG_SIZE(reg->id) > sizeof(tmp))\n\t\treturn -EINVAL;\n\tif (copy_from_user(valp, uaddr, KVM_REG_SIZE(reg->id))) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n \t}\n \tif (off == KVM_REG_ARM_CORE_REG(regs.pstate)) {\n\t\tu32 mode = (*(u32 *)valp) & PSR_AA32_MODE_MASK;\n \t\tswitch (mode) {\n \t\tcase PSR_AA32_MODE_USR:\n \t\tcase PSR_AA32_MODE_FIQ:\n \t\tcase PSR_AA32_MODE_IRQ:\n \t\tcase PSR_AA32_MODE_SVC:\n \t\tcase PSR_AA32_MODE_ABT:\n \t\tcase PSR_AA32_MODE_UND:\n \t\tcase PSR_MODE_EL0t:\n \t\tcase PSR_MODE_EL1t:\n \t\tcase PSR_MODE_EL1h:\n \t\t\tbreak;\n \t\tdefault:\n \t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmemcpy((u32 *)regs + off, valp, KVM_REG_SIZE(reg->id));\nout:\n\treturn err;\n}", "target": 1}
{"code": "static int logi_dj_raw_event(struct hid_device *hdev,\n\t\t\t     struct hid_report *report, u8 *data,\n\t\t\t     int size)\n{\n\tstruct dj_receiver_dev *djrcv_dev = hid_get_drvdata(hdev);\n\tstruct dj_report *dj_report = (struct dj_report *) data;\n\tunsigned long flags;\n\tbool report_processed = false;\n\tdbg_hid(\"%s, size:%d\\n\", __func__, size);\n \tspin_lock_irqsave(&djrcv_dev->lock, flags);\n \tif (dj_report->report_id == REPORT_ID_DJ_SHORT) {\n\t\tswitch (dj_report->report_type) {\n\t\tcase REPORT_TYPE_NOTIF_DEVICE_PAIRED:\n\t\tcase REPORT_TYPE_NOTIF_DEVICE_UNPAIRED:\n\t\t\tlogi_dj_recv_queue_notification(djrcv_dev, dj_report);\n\t\t\tbreak;\n\t\tcase REPORT_TYPE_NOTIF_CONNECTION_STATUS:\n\t\t\tif (dj_report->report_params[CONNECTION_STATUS_PARAM_STATUS] ==\n\t\t\t    STATUS_LINKLOSS) {\n\t\t\t\tlogi_dj_recv_forward_null_report(djrcv_dev, dj_report);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlogi_dj_recv_forward_report(djrcv_dev, dj_report);\n\t\t}\n\t\treport_processed = true;\n\t}\n\tspin_unlock_irqrestore(&djrcv_dev->lock, flags);\n\treturn report_processed;\n}", "target": 1}
{"code": "BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n{\n\tuint8_t *argb;\n\tint x, y;\n\tuint8_t *p;\n\tuint8_t *out;\n\tsize_t out_size;\n\tif (im == NULL) {\n\t\treturn;\n\t}\n\tif (!gdImageTrueColor(im)) {\n\t\tgd_error(\"Paletter image not supported by webp\");\n\t\treturn;\n\t}\n\tif (quality == -1) {\n \t\tquality = 80;\n \t}\n \targb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));\n \tif (!argb) {\n \t\treturn;\n\t}\n\tp = argb;\n\tfor (y = 0; y < gdImageSY(im); y++) {\n\t\tfor (x = 0; x < gdImageSX(im); x++) {\n\t\t\tregister int c;\n\t\t\tregister char a;\n\t\t\tc = im->tpixels[y][x];\n\t\t\ta = gdTrueColorGetAlpha(c);\n\t\t\tif (a == 127) {\n\t\t\t\ta = 0;\n\t\t\t} else {\n\t\t\t\ta = 255 - ((a << 1) + (a >> 6));\n\t\t\t}\n\t\t\t*(p++) = gdTrueColorGetRed(c);\n\t\t\t*(p++) = gdTrueColorGetGreen(c);\n\t\t\t*(p++) = gdTrueColorGetBlue(c); \n\t\t\t*(p++) = a;\n\t\t}\n\t}\n\tout_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);\n\tif (out_size == 0) {\n\t\tgd_error(\"gd-webp encoding failed\");\n\t\tgoto freeargb;\n\t}\n\tgdPutBuf(out, out_size, outfile);\n\tfree(out);\nfreeargb:\n\tgdFree(argb);\n}", "target": 1}
{"code": "TIFFFlushData1(TIFF* tif)\n{\n\tif (tif->tif_rawcc > 0 && tif->tif_flags & TIFF_BUF4WRITE ) {\n\t\tif (!isFillOrder(tif, tif->tif_dir.td_fillorder) &&\n\t\t    (tif->tif_flags & TIFF_NOBITREV) == 0)\n\t\t\tTIFFReverseBits((uint8*)tif->tif_rawdata,\n\t\t\t    tif->tif_rawcc);\n \t\tif (!TIFFAppendToStrip(tif,\n \t\t    isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip,\n \t\t    tif->tif_rawdata, tif->tif_rawcc))\n \t\t\treturn (0);\n \t\ttif->tif_rawcc = 0;\n \t\ttif->tif_rawcp = tif->tif_rawdata;\n \t}\n\treturn (1);\n}", "target": 1}
{"code": "void ndpi_search_oracle(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow)\n{\n  struct ndpi_packet_struct *packet = &flow->packet;\n  u_int16_t dport = 0, sport = 0;\n  NDPI_LOG_DBG(ndpi_struct, \"search ORACLE\\n\");\n  if(packet->tcp != NULL) {\n    sport = ntohs(packet->tcp->source), dport = ntohs(packet->tcp->dest);\n    NDPI_LOG_DBG2(ndpi_struct, \"calculating ORACLE over tcp\\n\");\n    if ((dport == 1521 || sport == 1521)\n\t&&  (((packet->payload[0] == 0x07) && (packet->payload[1] == 0xff) && (packet->payload[2] == 0x00))\n\t     || ((packet->payload_packet_len >= 232) && ((packet->payload[0] == 0x00) || (packet->payload[0] == 0x01)) \n\t     && (packet->payload[1] != 0x00)\n\t     && (packet->payload[2] == 0x00)\n\t\t && (packet->payload[3] == 0x00)))) {\n      NDPI_LOG_INFO(ndpi_struct, \"found oracle\\n\");\n      ndpi_int_oracle_add_connection(ndpi_struct, flow);\n    } else if (packet->payload_packet_len == 213 && packet->payload[0] == 0x00 &&\n               packet->payload[1] == 0xd5 && packet->payload[2] == 0x00 &&\n               packet->payload[3] == 0x00 ) {\n      NDPI_LOG_INFO(ndpi_struct, \"found oracle\\n\");\n      ndpi_int_oracle_add_connection(ndpi_struct, flow);\n    }\n  } else {\n    NDPI_EXCLUDE_PROTO(ndpi_struct, flow);\n  }\n}", "target": 1}
{"code": "static void dtls1_clear_queues(SSL *s)\n\t{\n    pitem *item = NULL;\n    hm_fragment *frag = NULL;\n\tDTLS1_RECORD_DATA *rdata;\n    while( (item = pqueue_pop(s->d1->unprocessed_rcds.q)) != NULL)\n        {\n\t\trdata = (DTLS1_RECORD_DATA *) item->data;\n\t\tif (rdata->rbuf.buf)\n\t\t\t{\n\t\t\tOPENSSL_free(rdata->rbuf.buf);\n\t\t\t}\n        OPENSSL_free(item->data);\n        pitem_free(item);\n        }\n    while( (item = pqueue_pop(s->d1->processed_rcds.q)) != NULL)\n        {\n\t\trdata = (DTLS1_RECORD_DATA *) item->data;\n\t\tif (rdata->rbuf.buf)\n\t\t\t{\n\t\t\tOPENSSL_free(rdata->rbuf.buf);\n\t\t\t}\n        OPENSSL_free(item->data);\n        pitem_free(item);\n        }\n    while( (item = pqueue_pop(s->d1->buffered_messages)) != NULL)\n        {\n        frag = (hm_fragment *)item->data;\n        OPENSSL_free(frag->fragment);\n        OPENSSL_free(frag);\n        pitem_free(item);\n        }\n    while ( (item = pqueue_pop(s->d1->sent_messages)) != NULL)\n        {\n        frag = (hm_fragment *)item->data;\n        OPENSSL_free(frag->fragment);\n        OPENSSL_free(frag);\n        pitem_free(item);\n        }\n \twhile ( (item = pqueue_pop(s->d1->buffered_app_data.q)) != NULL)\n \t\t{\n\t\tfrag = (hm_fragment *)item->data;\n\t\tOPENSSL_free(frag->fragment);\n\t\tOPENSSL_free(frag);\n \t\tpitem_free(item);\n \t\t}\n \t}", "target": 1}
{"code": "CURLcode Curl_close(struct Curl_easy *data)\n{\n  struct Curl_multi *m;\n  if(!data)\n    return CURLE_OK;\n  Curl_expire_clear(data); \n  m = data->multi;\n  if(m)\n     curl_multi_remove_handle(data->multi, data);\n  if(data->multi_easy)\n     curl_multi_cleanup(data->multi_easy);\n  Curl_llist_destroy(&data->state.timeoutlist, NULL);\n  data->magic = 0; \n  if(data->state.rangestringalloc)\n    free(data->state.range);\n  Curl_free_request_state(data);\n  Curl_ssl_close_all(data);\n  Curl_safefree(data->state.first_host);\n  Curl_safefree(data->state.scratch);\n  Curl_ssl_free_certinfo(data);\n  free(data->req.newurl);\n  data->req.newurl = NULL;\n  if(data->change.referer_alloc) {\n    Curl_safefree(data->change.referer);\n    data->change.referer_alloc = FALSE;\n  }\n  data->change.referer = NULL;\n  Curl_up_free(data);\n  Curl_safefree(data->state.buffer);\n  Curl_safefree(data->state.headerbuff);\n  Curl_safefree(data->state.ulbuf);\n  Curl_flush_cookies(data, 1);\n  Curl_digest_cleanup(data);\n  Curl_safefree(data->info.contenttype);\n  Curl_safefree(data->info.wouldredirect);\n  Curl_resolver_cleanup(data->state.resolver);\n  Curl_http2_cleanup_dependencies(data);\n  Curl_convert_close(data);\n  if(data->share) {\n    Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);\n    data->share->dirty--;\n    Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);\n  }\n  Curl_wildcard_dtor(&data->wildcard);\n  Curl_freeset(data);\n  free(data);\n  return CURLE_OK;\n}", "target": 1}
{"code": "static int do_insn_fetch(struct x86_emulate_ctxt *ctxt,\n\t\t\t struct x86_emulate_ops *ops,\n\t\t\t unsigned long eip, void *dest, unsigned size)\n{\n\tint rc = 0;\n\teip += ctxt->cs_base;\n\twhile (size--) {\n\t\trc = do_fetch_insn_byte(ctxt, ops, eip++, dest++);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static bool msr_mtrr_valid(unsigned msr)\n{\n\tswitch (msr) {\n\tcase 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1:\n\tcase MSR_MTRRfix64K_00000:\n\tcase MSR_MTRRfix16K_80000:\n\tcase MSR_MTRRfix16K_A0000:\n\tcase MSR_MTRRfix4K_C0000:\n\tcase MSR_MTRRfix4K_C8000:\n\tcase MSR_MTRRfix4K_D0000:\n\tcase MSR_MTRRfix4K_D8000:\n\tcase MSR_MTRRfix4K_E0000:\n\tcase MSR_MTRRfix4K_E8000:\n\tcase MSR_MTRRfix4K_F0000:\n\tcase MSR_MTRRfix4K_F8000:\n \tcase MSR_MTRRdefType:\n \tcase MSR_IA32_CR_PAT:\n \t\treturn true;\n\tcase 0x2f8:\n\t\treturn true;\n \t}\n \treturn false;\n }", "target": 1}
{"code": "static int parallels_open(BlockDriverState *bs, QDict *options, int flags,\n                          Error **errp)\n{\n    BDRVParallelsState *s = bs->opaque;\n    int i;\n    struct parallels_header ph;\n    int ret;\n    bs->read_only = 1; \n    ret = bdrv_pread(bs->file, 0, &ph, sizeof(ph));\n    if (ret < 0) {\n        goto fail;\n    }\n    if (memcmp(ph.magic, HEADER_MAGIC, 16) ||\n        (le32_to_cpu(ph.version) != HEADER_VERSION)) {\n        error_setg(errp, \"Image not in Parallels format\");\n        ret = -EINVAL;\n        goto fail;\n    }\n    bs->total_sectors = le32_to_cpu(ph.nb_sectors);\n    s->tracks = le32_to_cpu(ph.tracks);\n    s->catalog_size = le32_to_cpu(ph.catalog_entries);\n    s->catalog_bitmap = g_malloc(s->catalog_size * 4);\n    ret = bdrv_pread(bs->file, 64, s->catalog_bitmap, s->catalog_size * 4);\n    if (ret < 0) {\n        goto fail;\n    }\n    for (i = 0; i < s->catalog_size; i++)\n\tle32_to_cpus(&s->catalog_bitmap[i]);\n    qemu_co_mutex_init(&s->lock);\n    return 0;\nfail:\n    g_free(s->catalog_bitmap);\n    return ret;\n}", "target": 1}
{"code": "void mobi_buffer_move(MOBIBuffer *buf, const int offset, const size_t len) {\n    size_t aoffset = (size_t) abs(offset);\n    unsigned char *source = buf->data + buf->offset;\n    if (offset >= 0) {\n        if (buf->offset + aoffset + len > buf->maxlen) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source += aoffset;\n    } else {\n        if (buf->offset < aoffset) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source -= aoffset;\n    }\n    memmove(buf->data + buf->offset, source, len);\n    buf->offset += len;\n}", "target": 1}
{"code": "zrestore(i_ctx_t *i_ctx_p)\n {\n     os_ptr op = osp;\n    alloc_save_t *asave;\n    bool last;\n    vm_save_t *vmsave;\n    int code = restore_check_operand(op, &asave, idmemory);\n     if (code < 0)\n         return code;\n     if_debug2m('u', imemory, \"[u]vmrestore 0x%lx, id = %lu\\n\",\n               (ulong) alloc_save_client_data(asave),\n                (ulong) op->value.saveid);\n     if (I_VALIDATE_BEFORE_RESTORE)\n         ivalidate_clean_spaces(i_ctx_p);\n        ivalidate_clean_spaces(i_ctx_p);\n     {\n         int code;\n        if ((code = restore_check_stack(i_ctx_p, &o_stack, asave, false)) < 0 ||\n            (code = restore_check_stack(i_ctx_p, &e_stack, asave, true)) < 0 ||\n            (code = restore_check_stack(i_ctx_p, &d_stack, asave, false)) < 0\n             ) {\n             osp++;\n             return code;\n         }\n     }\n     restore_fix_stack(i_ctx_p, &o_stack, asave, false);\n    }", "target": 1}
{"code": "bool RenderFrameDevToolsAgentHost::AttachSession(DevToolsSession* session) {\n  if (session->restricted() && !IsFrameHostAllowedForRestrictedSessions())\n    return false;\n  session->SetRenderer(frame_host_ ? frame_host_->GetProcess()->GetID()\n                                   : ChildProcessHost::kInvalidUniqueID,\n                       frame_host_);\n  protocol::EmulationHandler* emulation_handler =\n      new protocol::EmulationHandler();\n  session->AddHandler(base::WrapUnique(new protocol::BrowserHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::DOMHandler()));\n  session->AddHandler(base::WrapUnique(emulation_handler));\n  session->AddHandler(base::WrapUnique(new protocol::InputHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::InspectorHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::IOHandler(\n      GetIOContext())));\n  session->AddHandler(base::WrapUnique(new protocol::MemoryHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::NetworkHandler(GetId())));\n   session->AddHandler(base::WrapUnique(new protocol::SchemaHandler()));\n   session->AddHandler(base::WrapUnique(new protocol::ServiceWorkerHandler()));\n   session->AddHandler(base::WrapUnique(new protocol::StorageHandler()));\n  session->AddHandler(\n      base::WrapUnique(new protocol::TargetHandler(false )));\n   session->AddHandler(base::WrapUnique(new protocol::TracingHandler(\n       protocol::TracingHandler::Renderer,\n       frame_tree_node_ ? frame_tree_node_->frame_tree_node_id() : 0,\n      GetIOContext())));\n  session->AddHandler(\n      base::WrapUnique(new protocol::PageHandler(emulation_handler)));\n  session->AddHandler(base::WrapUnique(new protocol::SecurityHandler()));\n  if (EnsureAgent())\n    session->AttachToAgent(agent_ptr_);\n  if (sessions().size() == 1) {\n    if (!base::FeatureList::IsEnabled(features::kVizDisplayCompositor) &&\n        !base::FeatureList::IsEnabled(\n            features::kUseVideoCaptureApiForDevToolsSnapshots)) {\n      frame_trace_recorder_.reset(new DevToolsFrameTraceRecorder());\n    }\n    GrantPolicy();\n#if defined(OS_ANDROID)\n    GetWakeLock()->RequestWakeLock();\n#endif\n  }\n  return true;\n}", "target": 1}
{"code": " static Maybe<bool> CollectValuesOrEntriesImpl(\n       Isolate* isolate, Handle<JSObject> object,\n       Handle<FixedArray> values_or_entries, bool get_entries, int* nof_items,\n       PropertyFilter filter) {\n    int count = 0;\n     KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,\n                                ALL_PROPERTIES);\n     Subclass::CollectElementIndicesImpl(\n         object, handle(object->elements(), isolate), &accumulator);\n     Handle<FixedArray> keys = accumulator.GetKeys();\n    for (int i = 0; i < keys->length(); ++i) {\n       Handle<Object> key(keys->get(i), isolate);\n      Handle<Object> value;\n       uint32_t index;\n       if (!key->ToUint32(&index)) continue;\n       uint32_t entry = Subclass::GetEntryForIndexImpl(\n           isolate, *object, object->elements(), index, filter);\n       if (entry == kMaxUInt32) continue;\n       PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);\n       if (details.kind() == kData) {\n         value = Subclass::GetImpl(isolate, object->elements(), entry);\n       } else {\n         LookupIterator it(isolate, object, index, LookupIterator::OWN);\n         ASSIGN_RETURN_ON_EXCEPTION_VALUE(\n             isolate, value, Object::GetProperty(&it), Nothing<bool>());\n       }\n      if (get_entries) {\n        value = MakeEntryPair(isolate, index, value);\n       }\n       values_or_entries->set(count++, *value);\n     }\n *nof_items = count;\n return Just(true);\n }", "target": 1}
{"code": " ZEND_METHOD(CURLFile, __wakeup)\n {\n       zend_update_property_string(curl_CURLFile_class, getThis(), \"name\", sizeof(\"name\")-1, \"\" TSRMLS_CC);\n        zend_throw_exception(NULL, \"Unserialization of CURLFile instances is not allowed\", 0 TSRMLS_CC);\n }", "target": 1}
{"code": "static size_t curl_read_cb(void *ptr, size_t size, size_t nmemb, void *opaque)\n{\n    CURLState *s = ((CURLState*)opaque);\n    size_t realsize = size * nmemb;\n    int i;\n    DPRINTF(\"CURL: Just reading %zd bytes\\n\", realsize);\n    if (!s || !s->orig_buf)\n        goto read_end;\n    memcpy(s->orig_buf + s->buf_off, ptr, realsize);\n    s->buf_off += realsize;\n    for(i=0; i<CURL_NUM_ACB; i++) {\n        CURLAIOCB *acb = s->acb[i];\n        if (!acb)\n            continue;\n        if ((s->buf_off >= acb->end)) {\n            qemu_iovec_from_buf(acb->qiov, 0, s->orig_buf + acb->start,\n                                acb->end - acb->start);\n            acb->common.cb(acb->common.opaque, 0);\n            qemu_aio_release(acb);\n            s->acb[i] = NULL;\n        }\n    }\nread_end:\n    return realsize;\n}", "target": 1}
{"code": "static int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir,\n\t\t\t      struct dentry *dentry, struct path *lowerpath,\n\t\t\t      struct kstat *stat, struct iattr *attr,\n\t\t\t      const char *link)\n{\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *newdentry = NULL;\n\tstruct dentry *upper = NULL;\n\tumode_t mode = stat->mode;\n\tint err;\n\tnewdentry = ovl_lookup_temp(workdir, dentry);\n\terr = PTR_ERR(newdentry);\n\tif (IS_ERR(newdentry))\n\t\tgoto out;\n\tupper = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t       dentry->d_name.len);\n\terr = PTR_ERR(upper);\n\tif (IS_ERR(upper))\n\t\tgoto out1;\n\tstat->mode &= S_IFMT;\n\terr = ovl_create_real(wdir, newdentry, stat, link, NULL, true);\n\tstat->mode = mode;\n\tif (err)\n\t\tgoto out2;\n\tif (S_ISREG(stat->mode)) {\n\t\tstruct path upperpath;\n\t\tovl_path_upper(dentry, &upperpath);\n\t\tBUG_ON(upperpath.dentry != NULL);\n\t\tupperpath.dentry = newdentry;\n\t\terr = ovl_copy_up_data(lowerpath, &upperpath, stat->size);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\t}\n\terr = ovl_copy_xattr(lowerpath->dentry, newdentry);\n\tif (err)\n\t\tgoto out_cleanup;\n\tmutex_lock(&newdentry->d_inode->i_mutex);\n\terr = ovl_set_attr(newdentry, stat);\n\tif (!err && attr)\n\t\terr = notify_change(newdentry, attr, NULL);\n\tmutex_unlock(&newdentry->d_inode->i_mutex);\n\tif (err)\n\t\tgoto out_cleanup;\n\terr = ovl_do_rename(wdir, newdentry, udir, upper, 0);\n\tif (err)\n\t\tgoto out_cleanup;\n\tovl_dentry_update(dentry, newdentry);\n\tnewdentry = NULL;\n\tif (!S_ISDIR(stat->mode))\n\t\tovl_dentry_set_opaque(dentry, true);\nout2:\n\tdput(upper);\nout1:\n\tdput(newdentry);\nout:\n\treturn err;\n out_cleanup:\n \tovl_cleanup(wdir, newdentry);\n\tgoto out;\n }", "target": 1}
{"code": "ProfilingProcessHost::Mode ProfilingProcessHost::GetCurrentMode() {\n  const base::CommandLine* cmdline = base::CommandLine::ForCurrentProcess();\n#if BUILDFLAG(USE_ALLOCATOR_SHIM)\n  if (cmdline->HasSwitch(switches::kMemlog) ||\n      base::FeatureList::IsEnabled(kOOPHeapProfilingFeature)) {\n    if (cmdline->HasSwitch(switches::kEnableHeapProfiling)) {\n      LOG(ERROR) << \"--\" << switches::kEnableHeapProfiling\n                 << \" specified with --\" << switches::kMemlog\n                 << \"which are not compatible. Memlog will be disabled.\";\n      return Mode::kNone;\n    }\n    std::string mode;\n    if (cmdline->HasSwitch(switches::kMemlog)) {\n      mode = cmdline->GetSwitchValueASCII(switches::kMemlog);\n    } else {\n      mode = base::GetFieldTrialParamValueByFeature(\n           kOOPHeapProfilingFeature, kOOPHeapProfilingFeatureMode);\n     }\n    if (mode == switches::kMemlogModeAll)\n      return Mode::kAll;\n    if (mode == switches::kMemlogModeMinimal)\n      return Mode::kMinimal;\n    if (mode == switches::kMemlogModeBrowser)\n      return Mode::kBrowser;\n    if (mode == switches::kMemlogModeGpu)\n      return Mode::kGpu;\n    if (mode == switches::kMemlogModeRendererSampling)\n      return Mode::kRendererSampling;\n    DLOG(ERROR) << \"Unsupported value: \\\"\" << mode << \"\\\" passed to --\"\n                << switches::kMemlog;\n   }\n   return Mode::kNone;\n #else\n  LOG_IF(ERROR, cmdline->HasSwitch(switches::kMemlog))\n      << \"--\" << switches::kMemlog\n      << \" specified but it will have no effect because the use_allocator_shim \"\n      << \"is not available in this build.\";\n  return Mode::kNone;\n #endif\n }", "target": 1}
{"code": "void php_filter_validate_url(PHP_INPUT_FILTER_PARAM_DECL) \n{\n\tphp_url *url;\n\tsize_t old_len = Z_STRLEN_P(value);\n\tif (flags & (FILTER_FLAG_SCHEME_REQUIRED | FILTER_FLAG_HOST_REQUIRED)) {\n\t\tphp_error_docref(NULL, E_DEPRECATED,\n\t\t\t\"explicit use of FILTER_FLAG_SCHEME_REQUIRED and FILTER_FLAG_HOST_REQUIRED is deprecated\");\n\t}\n\tphp_filter_url(value, flags, option_array, charset);\n\tif (Z_TYPE_P(value) != IS_STRING || old_len != Z_STRLEN_P(value)) {\n\t\tRETURN_VALIDATION_FAILED\n\t}\n\turl = php_url_parse_ex(Z_STRVAL_P(value), Z_STRLEN_P(value));\n\tif (url == NULL) {\n\t\tRETURN_VALIDATION_FAILED\n\t}\n\tif (url->scheme != NULL &&\n\t\t(zend_string_equals_literal_ci(url->scheme, \"http\") || zend_string_equals_literal_ci(url->scheme, \"https\"))) {\n\t\tchar *e, *s, *t;\n\t\tsize_t l;\n\t\tif (url->host == NULL) {\n\t\t\tgoto bad_url;\n\t\t}\n\t\ts = ZSTR_VAL(url->host);\n\t\tl = ZSTR_LEN(url->host);\n\t\te = s + l;\n\t\tt = e - 1;\n\t\tif (*s == '[' && *t == ']' && _php_filter_validate_ipv6((s + 1), l - 2)) {\n\t\t\tphp_url_free(url);\n\t\t\treturn;\n\t\t}\n\t\tif (!_php_filter_validate_domain(ZSTR_VAL(url->host), l, FILTER_FLAG_HOSTNAME)) {\n\t\t\tphp_url_free(url);\n\t\t\tRETURN_VALIDATION_FAILED\n\t\t}\n\t}\n\tif (\n\t\turl->scheme == NULL ||\n\t\t(url->host == NULL && (strcmp(ZSTR_VAL(url->scheme), \"mailto\") && strcmp(ZSTR_VAL(url->scheme), \"news\") && strcmp(ZSTR_VAL(url->scheme), \"file\"))) ||\n\t\t((flags & FILTER_FLAG_PATH_REQUIRED) && url->path == NULL) || ((flags & FILTER_FLAG_QUERY_REQUIRED) && url->query == NULL)\n\t) {\nbad_url:\n\t\tphp_url_free(url);\n\t\tRETURN_VALIDATION_FAILED\n\t}\n\tif (url->user != NULL && !is_userinfo_valid(url->user)) {\n\t\tphp_url_free(url);\n\t\tRETURN_VALIDATION_FAILED\n\t}\n\tphp_url_free(url);\n}", "target": 1}
{"code": "native_handle* Parcel::readNativeHandle() const\n{\n int numFds, numInts;\n status_t err;\n    err = readInt32(&numFds);\n if (err != NO_ERROR) return 0;\n    err = readInt32(&numInts);\n if (err != NO_ERROR) return 0;\n    native_handle* h = native_handle_create(numFds, numInts);\n if (!h) {\n return 0;\n }\n     for (int i=0 ; err==NO_ERROR && i<numFds ; i++) {\n         h->data[i] = dup(readFileDescriptor());\n        if (h->data[i] < 0) err = BAD_VALUE;\n     }\n     err = read(h->data + numFds, sizeof(int)*numInts);\n     if (err != NO_ERROR) {\n        native_handle_close(h);\n        native_handle_delete(h);\n        h = 0;\n }\n return h;\n}", "target": 1}
{"code": "bool VaapiJpegDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) {\n  vaapi_wrapper_ = VaapiWrapper::Create(VaapiWrapper::kDecode,\n                                        VAProfileJPEGBaseline, error_uma_cb);\n  if (!vaapi_wrapper_) {\n    VLOGF(1) << \"Failed initializing VAAPI\";\n    return false;\n  }\n  return true;\n}", "target": 1}
{"code": "path_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tPATH\t   *path;\n\tint\t\t\tisopen;\n \tchar\t   *s;\n \tint\t\t\tnpts;\n \tint\t\t\tsize;\n \tint\t\t\tdepth = 0;\n \tif ((npts = pair_count(str, ',')) <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type path: \\\"%s\\\"\", str)));\n\ts = str;\n\twhile (isspace((unsigned char) *s))\n\t\ts++;\n\tif ((*s == LDELIM) && (strrchr(s, LDELIM) == s))\n\t{\n\t\ts++;\n \t\tdepth++;\n \t}\n\tsize = offsetof(PATH, p[0]) +sizeof(path->p[0]) * npts;\n \tpath = (PATH *) palloc(size);\n \tSET_VARSIZE(path, size);\n\tpath->npts = npts;\n\tif ((!path_decode(TRUE, npts, s, &isopen, &s, &(path->p[0])))\n\t&& (!((depth == 0) && (*s == '\\0'))) && !((depth >= 1) && (*s == RDELIM)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type path: \\\"%s\\\"\", str)));\n\tpath->closed = (!isopen);\n\tpath->dummy = 0;\n\tPG_RETURN_PATH_P(path);\n}", "target": 1}
{"code": "static int arc_emac_tx(struct sk_buff *skb, struct net_device *ndev)\n{\n\tstruct arc_emac_priv *priv = netdev_priv(ndev);\n\tunsigned int len, *txbd_curr = &priv->txbd_curr;\n\tstruct net_device_stats *stats = &ndev->stats;\n\t__le32 *info = &priv->txbd[*txbd_curr].info;\n\tdma_addr_t addr;\n\tif (skb_padto(skb, ETH_ZLEN))\n\t\treturn NETDEV_TX_OK;\n\tlen = max_t(unsigned int, ETH_ZLEN, skb->len);\n\tif (unlikely(!arc_emac_tx_avail(priv))) {\n\t\tnetif_stop_queue(ndev);\n\t\tnetdev_err(ndev, \"BUG! Tx Ring full when queue awake!\\n\");\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\taddr = dma_map_single(&ndev->dev, (void *)skb->data, len,\n\t\t\t      DMA_TO_DEVICE);\n\tif (unlikely(dma_mapping_error(&ndev->dev, addr))) {\n\t\tstats->tx_dropped++;\n\t\tstats->tx_errors++;\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\tdma_unmap_addr_set(&priv->tx_buff[*txbd_curr], addr, addr);\n\tdma_unmap_len_set(&priv->tx_buff[*txbd_curr], len, len);\n\tpriv->tx_buff[*txbd_curr].skb = skb;\n\tpriv->txbd[*txbd_curr].data = cpu_to_le32(addr);\n\twmb();\n\tskb_tx_timestamp(skb);\n\t*info = cpu_to_le32(FOR_EMAC | FIRST_OR_LAST_MASK | len);\n\t*txbd_curr = (*txbd_curr + 1) % TX_BD_NUM;\n\tsmp_mb();\n\tif (!arc_emac_tx_avail(priv)) {\n\t\tnetif_stop_queue(ndev);\n\t\tsmp_mb();\n\t\tif (arc_emac_tx_avail(priv))\n\t\t\tnetif_start_queue(ndev);\n\t}\n\tarc_reg_set(priv, R_STATUS, TXPL_MASK);\n\treturn NETDEV_TX_OK;\n}", "target": 1}
{"code": " static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)\n {\n \tint start = 0;\n \tu32 prev_legacy, cur_legacy;\n \tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n \tprev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tcur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tif (!prev_legacy && cur_legacy)\n\t\tstart = 1;\n \tmemcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels,\n \t       sizeof(kvm->arch.vpit->pit_state.channels));\n \tkvm->arch.vpit->pit_state.flags = ps->flags;\n\tkvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, start);\n \tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n \treturn 0;\n }", "target": 1}
{"code": "generatePreview (const char inFileName[],\n\t\t float exposure,\n\t\t int previewWidth,\n\t\t int &previewHeight,\n\t\t Array2D <PreviewRgba> &previewPixels)\n{\n    RgbaInputFile in (inFileName);\n    Box2i dw = in.dataWindow();\n    float a = in.pixelAspectRatio();\n    int w = dw.max.x - dw.min.x + 1;\n    int h = dw.max.y - dw.min.y + 1;\n    Array2D <Rgba> pixels (h, w);\n    in.setFrameBuffer (ComputeBasePointer (&pixels[0][0], dw), 1, w);\n    in.readPixels (dw.min.y, dw.max.y);\n    previewHeight = max (int (h / (w * a) * previewWidth + .5f), 1);\n    previewPixels.resizeErase (previewHeight, previewWidth);\n    float fx = (previewWidth  > 0)? (float (w - 1) / (previewWidth  - 1)): 1;\n    float fy = (previewHeight > 0)? (float (h - 1) / (previewHeight - 1)): 1;\n    float m  = Math<float>::pow (2.f, IMATH_NAMESPACE::clamp (exposure + 2.47393f, -20.f, 20.f));\n    for (int y = 0; y < previewHeight; ++y)\n    {\n\tfor (int x = 0; x < previewWidth; ++x)\n\t{\n\t    PreviewRgba &preview = previewPixels[y][x];\n\t    const Rgba &pixel = pixels[int (y * fy + .5f)][int (x * fx + .5f)];\n\t    preview.r = gamma (pixel.r, m);\n\t    preview.g = gamma (pixel.g, m);\n\t    preview.b = gamma (pixel.b, m);\n\t    preview.a = int (IMATH_NAMESPACE::clamp (pixel.a * 255.f, 0.f, 255.f) + .5f);\n\t}\n    }\n}", "target": 1}
{"code": "int line6_init_pcm(struct usb_line6 *line6,\n\t\t   struct line6_pcm_properties *properties)\n{\n\tint i, err;\n\tunsigned ep_read = line6->properties->ep_audio_r;\n\tunsigned ep_write = line6->properties->ep_audio_w;\n\tstruct snd_pcm *pcm;\n\tstruct snd_line6_pcm *line6pcm;\n\tif (!(line6->properties->capabilities & LINE6_CAP_PCM))\n\t\treturn 0;\t\n\terr = snd_line6_new_pcm(line6, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tline6pcm = kzalloc(sizeof(*line6pcm), GFP_KERNEL);\n\tif (!line6pcm)\n\t\treturn -ENOMEM;\n\tmutex_init(&line6pcm->state_mutex);\n\tline6pcm->pcm = pcm;\n\tline6pcm->properties = properties;\n\tline6pcm->volume_playback[0] = line6pcm->volume_playback[1] = 255;\n\tline6pcm->volume_monitor = 255;\n\tline6pcm->line6 = line6;\n\tline6pcm->max_packet_size_in =\n\t\tusb_maxpacket(line6->usbdev,\n\t\t\tusb_rcvisocpipe(line6->usbdev, ep_read), 0);\n\tline6pcm->max_packet_size_out =\n\t\tusb_maxpacket(line6->usbdev,\n\t\t\tusb_sndisocpipe(line6->usbdev, ep_write), 1);\n\tspin_lock_init(&line6pcm->out.lock);\n\tspin_lock_init(&line6pcm->in.lock);\n\tline6pcm->impulse_period = LINE6_IMPULSE_DEFAULT_PERIOD;\n\tline6->line6pcm = line6pcm;\n\tpcm->private_data = line6pcm;\n\tpcm->private_free = line6_cleanup_pcm;\n\terr = line6_create_audio_out_urbs(line6pcm);\n\tif (err < 0)\n\t\treturn err;\n\terr = line6_create_audio_in_urbs(line6pcm);\n\tif (err < 0)\n\t\treturn err;\n\tfor (i = 0; i < ARRAY_SIZE(line6_controls); i++) {\n\t\terr = snd_ctl_add(line6->card,\n\t\t\t\t  snd_ctl_new1(&line6_controls[i], line6pcm));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "int32_t cli_bcapi_extract_new(struct cli_bc_ctx *ctx, int32_t id)\n{\n    cli_ctx *cctx;\n    int res = -1;\n    cli_event_count(EV, BCEV_EXTRACTED);\n    cli_dbgmsg(\"previous tempfile had %u bytes\\n\", ctx->written);\n    if (!ctx->written)\n\treturn 0;\n    if (ctx->ctx && cli_updatelimits(ctx->ctx, ctx->written))\n\treturn -1;\n    ctx->written = 0;\n    lseek(ctx->outfd, 0, SEEK_SET);\n    cli_dbgmsg(\"bytecode: scanning extracted file %s\\n\", ctx->tempfile);\n    cctx = (cli_ctx*)ctx->ctx;\n    if (cctx) {\n\tcli_file_t current = cctx->container_type;\n\tif (ctx->containertype != CL_TYPE_ANY)\n\t    cctx->container_type = ctx->containertype;\n\tres = cli_magic_scandesc(ctx->outfd, cctx);\n\tcctx->container_type = current;\n\tif (res == CL_VIRUS) {\n\t    if (cctx->virname)\n\t\tctx->virname = *cctx->virname;\n\t    ctx->found = 1;\n\t}\n    }\n    if ((cctx && cctx->engine->keeptmp) ||\n\t(ftruncate(ctx->outfd, 0) == -1)) {\n\tclose(ctx->outfd);\n\tif (!(cctx && cctx->engine->keeptmp) && ctx->tempfile)\n\t    cli_unlink(ctx->tempfile);\n\tfree(ctx->tempfile);\n\tctx->tempfile = NULL;\n\tctx->outfd = 0;\n    }\n    cli_dbgmsg(\"bytecode: extracting new file with id %u\\n\", id);\n    return res;\n}", "target": 1}
{"code": "int user_update(struct key *key, const void *data, size_t datalen)\n{\n\tstruct user_key_payload *upayload, *zap;\n\tint ret;\n\tret = -EINVAL;\n\tif (datalen <= 0 || datalen > 32767 || !data)\n\t\tgoto error;\n\tret = -ENOMEM;\n\tupayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);\n\tif (!upayload)\n\t\tgoto error;\n\tupayload->datalen = datalen;\n\tmemcpy(upayload->data, data, datalen);\n\tzap = upayload;\n\tret = key_payload_reserve(key, datalen);\n\tif (ret == 0) {\n\t\tzap = key->payload.data;\n\t\trcu_assign_pointer(key->payload.data, upayload);\n\t\tkey->expiry = 0;\n\t}\n\tkfree_rcu(zap, rcu);\nerror:\n\treturn ret;\n}", "target": 1}
{"code": "static XMLSharedNodeList* find_impl(xmlXPathContext* ctxt, const string& xpath)\n{\n\txmlXPathObject* result = xmlXPathEval((const xmlChar*)xpath.c_str(), ctxt);\n\tif (!result) {\n\t\txmlXPathFreeContext(ctxt);\n\t\txmlFreeDoc(ctxt->doc);\n\t\tthrow XMLException(\"Invalid XPath: \" + xpath);\n\t}\n\tif (result->type != XPATH_NODESET) {\n\t\txmlXPathFreeObject(result);\n\t\txmlXPathFreeContext(ctxt);\n\t\txmlFreeDoc(ctxt->doc);\n\t\tthrow XMLException(\"Only nodeset result types are supported.\");\n\t}\n\txmlNodeSet* nodeset = result->nodesetval;\n\tXMLSharedNodeList* nodes = new XMLSharedNodeList();\n\tif (nodeset) {\n\t\tfor (int i = 0; i < nodeset->nodeNr; ++i) {\n\t\t\tXMLNode* node = readnode(nodeset->nodeTab[i]);\n\t\t\tnodes->push_back(boost::shared_ptr<XMLNode>(node));\n\t\t}\n\t} else {\n\t}\n\txmlXPathFreeObject(result);\n\treturn nodes;\n}", "target": 1}
{"code": "static void _cmd_window_show_opt(const char *data, int right)\n{\n\tMAIN_WINDOW_REC *parent;\n\tWINDOW_REC *window;\n\tif (*data == '\\0') cmd_return_error(CMDERR_NOT_ENOUGH_PARAMS);\n\tif (is_numeric(data, '\\0')) {\n\t\twindow = window_find_refnum(atoi(data));\n\t\tif (window == NULL) {\n\t\t\tprintformat_window(active_win, MSGLEVEL_CLIENTERROR,\n\t\t\t\t\t   TXT_REFNUM_NOT_FOUND, data);\n\t\t}\n\t} else {\n\t\twindow = window_find_item(active_win->active_server, data);\n\t}\n\tif (window == NULL || is_window_visible(window))\n\t\treturn;\n\tif (WINDOW_GUI(window)->sticky) {\n\t\tif (!settings_get_bool(\"autounstick_windows\")) {\n\t\t\tprintformat_window(active_win, MSGLEVEL_CLIENTERROR,\n\t\t\t\t\t   TXT_CANT_SHOW_STICKY_WINDOWS);\n\t\t\treturn;\n\t\t}\n\t}\n\tparent = mainwindow_create(right);\n\tparent->active = window;\n\tgui_window_reparent(window, parent);\n\tif (settings_get_bool(\"autostick_split_windows\"))\n\t\tgui_window_set_sticky(window);\n\tactive_mainwin = NULL;\n\twindow_set_active(window);\n}", "target": 1}
{"code": "gnutls_session_get_data (gnutls_session_t session,\n                         void *session_data, size_t * session_data_size)\n{\n  gnutls_datum_t psession;\n  int ret;\n  if (session->internals.resumable == RESUME_FALSE)\n    return GNUTLS_E_INVALID_SESSION;\n  psession.data = session_data;\n  ret = _gnutls_session_pack (session, &psession);\n  if (ret < 0)\n    {\n       gnutls_assert ();\n       return ret;\n     }\n  *session_data_size = psession.size;\n   if (psession.size > *session_data_size)\n     {\n       ret = GNUTLS_E_SHORT_MEMORY_BUFFER;\n       goto error;\n     }\n   if (session_data != NULL)\n     memcpy (session_data, psession.data, psession.size);\n  ret = 0;\nerror:\n  _gnutls_free_datum (&psession);\n  return ret;\n}", "target": 1}
{"code": "static void ipmr_destroy_unres(struct mfc_cache *c)\n{\n\tstruct sk_buff *skb;\n\tatomic_dec(&cache_resolve_queue_len);\n\twhile((skb=skb_dequeue(&c->mfc_un.unres.unresolved))) {\n\t\tif (skb->nh.iph->version == 0) {\n\t\t\tstruct nlmsghdr *nlh = (struct nlmsghdr *)skb_pull(skb, sizeof(struct iphdr));\n\t\t\tnlh->nlmsg_type = NLMSG_ERROR;\n\t\t\tnlh->nlmsg_len = NLMSG_LENGTH(sizeof(struct nlmsgerr));\n\t\t\tskb_trim(skb, nlh->nlmsg_len);\n\t\t\t((struct nlmsgerr*)NLMSG_DATA(nlh))->error = -ETIMEDOUT;\n\t\t\tnetlink_unicast(rtnl, skb, NETLINK_CB(skb).dst_pid, MSG_DONTWAIT);\n\t\t} else\n\t\t\tkfree_skb(skb);\n\t}\n\tkmem_cache_free(mrt_cachep, c);\n}", "target": 1}
{"code": "int hci_conn_check_link_mode(struct hci_conn *conn)\n{\n\tBT_DBG(\"hcon %p\", conn);\n\tif (hci_dev_test_flag(conn->hdev, HCI_SC_ONLY)) {\n\t\tif (!hci_conn_sc_enabled(conn) ||\n\t\t    !test_bit(HCI_CONN_AES_CCM, &conn->flags) ||\n\t\t    conn->key_type != HCI_LK_AUTH_COMBINATION_P256)\n\t\t\treturn 0;\n\t}\n\tif (hci_conn_ssp_enabled(conn) &&\n\t    !test_bit(HCI_CONN_ENCRYPT, &conn->flags))\n\t\treturn 0;\n\treturn 1;\n}", "target": 1}
{"code": "static int ieee802154_create(struct net *net, struct socket *sock,\n\t\t\t     int protocol, int kern)\n{\n\tstruct sock *sk;\n\tint rc;\n\tstruct proto *proto;\n\tconst struct proto_ops *ops;\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\tswitch (sock->type) {\n\tcase SOCK_RAW:\n\t\tproto = &ieee802154_raw_prot;\n\t\tops = &ieee802154_raw_ops;\n\t\tbreak;\n\tcase SOCK_DGRAM:\n\t\tproto = &ieee802154_dgram_prot;\n\t\tops = &ieee802154_dgram_ops;\n\t\tbreak;\n\tdefault:\n\t\trc = -ESOCKTNOSUPPORT;\n\t\tgoto out;\n\t}\n\trc = -ENOMEM;\n\tsk = sk_alloc(net, PF_IEEE802154, GFP_KERNEL, proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\trc = 0;\n\tsock->ops = ops;\n\tsock_init_data(sock, sk);\n\tsk->sk_family = PF_IEEE802154;\n\tsock_set_flag(sk, SOCK_ZAPPED);\n\tif (sk->sk_prot->hash) {\n\t\trc = sk->sk_prot->hash(sk);\n\t\tif (rc) {\n\t\t\tsk_common_release(sk);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (sk->sk_prot->init) {\n\t\trc = sk->sk_prot->init(sk);\n\t\tif (rc)\n\t\t\tsk_common_release(sk);\n\t}\nout:\n\treturn rc;\n}", "target": 1}
{"code": "mrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b)\n{\n  if (a->body.irep) {\n    return;\n  }\n  a->flags = b->flags;\n  a->body = b->body;\n  a->upper = b->upper;\n  if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {\n    mrb_irep_incref(mrb, (mrb_irep*)a->body.irep);\n  }\n  a->e.env = b->e.env;\n}", "target": 1}
{"code": " static int proc_connectinfo(struct usb_dev_state *ps, void __user *arg)\n {\n\tstruct usbdevfs_connectinfo ci = {\n\t\t.devnum = ps->dev->devnum,\n\t\t.slow = ps->dev->speed == USB_SPEED_LOW\n\t};\n \tif (copy_to_user(arg, &ci, sizeof(ci)))\n \t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "iakerb_gss_export_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                               gss_buffer_t interprocess_token)\n {\n     OM_uint32 maj;\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n     if (!ctx->established)\n        return GSS_S_UNAVAILABLE;\n    maj = krb5_gss_export_sec_context(minor_status, &ctx->gssc,\n                                      interprocess_token);\n    if (ctx->gssc == GSS_C_NO_CONTEXT) {\n        iakerb_release_context(ctx);\n        *context_handle = GSS_C_NO_CONTEXT;\n    }\n     return maj;\n }", "target": 1}
{"code": "ImagingNew(const char* mode, int xsize, int ysize)\n{\n    int bytes;\n    Imaging im;\n    if (strlen(mode) == 1) {\n        if (mode[0] == 'F' || mode[0] == 'I')\n            bytes = 4;\n        else\n            bytes = 1;\n    } else\n        bytes = strlen(mode); \n    if ((int64_t) xsize * (int64_t) ysize <= THRESHOLD / bytes) {\n        im = ImagingNewBlock(mode, xsize, ysize);\n        if (im)\n            return im;\n        ImagingError_Clear();\n    }\n    return ImagingNewArray(mode, xsize, ysize);\n}", "target": 1}
{"code": "void DownloadUIAdapterDelegate::OpenItem(const OfflineItem& item,\n                                          int64_t offline_id) {\n   JNIEnv* env = AttachCurrentThread();\n   Java_OfflinePageDownloadBridge_openItem(\n      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id);\n }", "target": 1}
{"code": "SessionStartupPref StartupBrowserCreator::GetSessionStartupPref(\n    const base::CommandLine& command_line,\n    Profile* profile) {\n  DCHECK(profile);\n  PrefService* prefs = profile->GetPrefs();\n  SessionStartupPref pref = SessionStartupPref::GetStartupPref(prefs);\n#if defined(OS_CHROMEOS)\n  const bool is_first_run =\n      user_manager::UserManager::Get()->IsCurrentUserNew();\n  const bool did_restart = false;\n  StartupBrowserCreator::WasRestarted();\n#else\n  const bool is_first_run = first_run::IsChromeFirstRun();\n  const bool did_restart = StartupBrowserCreator::WasRestarted();\n#endif\n  if (is_first_run && SessionStartupPref::TypeIsDefault(prefs))\n    pref.type = SessionStartupPref::DEFAULT;\n  if ((command_line.HasSwitch(switches::kRestoreLastSession) || did_restart) &&\n      !profile->IsNewProfile()) {\n    pref.type = SessionStartupPref::LAST;\n  }\n  if (!profile->IsGuestSession()) {\n    ProfileAttributesEntry* entry = nullptr;\n    bool has_entry =\n        g_browser_process->profile_manager()\n            ->GetProfileAttributesStorage()\n            .GetProfileAttributesWithPath(profile->GetPath(), &entry);\n    if (has_entry && entry->IsSigninRequired())\n       pref.type = SessionStartupPref::LAST;\n   }\n  if (pref.type == SessionStartupPref::LAST &&\n      IncognitoModePrefs::ShouldLaunchIncognito(command_line, prefs)) {\n    pref.type = SessionStartupPref::DEFAULT;\n  }\n  return pref;\n}", "target": 1}
{"code": "static zend_long firebird_handle_doer(pdo_dbh_t *dbh, const char *sql, size_t sql_len) \n{\n\tpdo_firebird_db_handle *H = (pdo_firebird_db_handle *)dbh->driver_data;\n\tisc_stmt_handle stmt = PDO_FIREBIRD_HANDLE_INITIALIZER;\n\tstatic char const info_count[] = { isc_info_sql_records };\n\tchar result[64];\n\tint ret = 0;\n\tXSQLDA in_sqlda, out_sqlda;\n\tin_sqlda.version = out_sqlda.version = PDO_FB_SQLDA_VERSION;\n\tin_sqlda.sqld = out_sqlda.sqld = 0;\n\tout_sqlda.sqln = 1;\n\tif (!firebird_alloc_prepare_stmt(dbh, sql, sql_len, &out_sqlda, &stmt, 0)) {\n\t\treturn -1;\n\t}\n\tif (isc_dsql_execute2(H->isc_status, &H->tr, &stmt, PDO_FB_SQLDA_VERSION, &in_sqlda, &out_sqlda)) {\n\t\tRECORD_ERROR(dbh);\n\t\tret = -1;\n\t\tgoto free_statement;\n\t}\n\tif (isc_dsql_sql_info(H->isc_status, &stmt, sizeof(info_count), const_cast(info_count),\n\t\t\tsizeof(result),\tresult)) {\n\t\tRECORD_ERROR(dbh);\n\t\tret = -1;\n\t\tgoto free_statement;\n\t}\n\tif (result[0] == isc_info_sql_records) {\n\t\tunsigned i = 3, result_size = isc_vax_integer(&result[1],2);\n\t\twhile (result[i] != isc_info_end && i < result_size) {\n\t\t\tshort len = (short)isc_vax_integer(&result[i+1],2);\n\t\t\tif (result[i] != isc_info_req_select_count) {\n\t\t\t\tret += isc_vax_integer(&result[i+3],len);\n\t\t\t}\n\t\t\ti += len+3;\n\t\t}\n\t}\n\tif (dbh->auto_commit && isc_commit_retaining(H->isc_status, &H->tr)) {\n\t\tRECORD_ERROR(dbh);\n\t}\nfree_statement:\n\tif (isc_dsql_free_statement(H->isc_status, &stmt, DSQL_drop)) {\n\t\tRECORD_ERROR(dbh);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "  Status DoCompute(OpKernelContext* ctx) {\n    tensorflow::ResourceTagger tag(kTFDataResourceTag,\n                                   ctx->op_kernel().type_string());\n    tstring filename;\n    TF_RETURN_IF_ERROR(\n        ParseScalarArgument<tstring>(ctx, \"filename\", &filename));\n    tstring compression_type;\n    TF_RETURN_IF_ERROR(ParseScalarArgument<tstring>(ctx, \"compression_type\",\n                                                    &compression_type));\n    std::unique_ptr<WritableFile> file;\n    TF_RETURN_IF_ERROR(ctx->env()->NewWritableFile(filename, &file));\n    auto writer = absl::make_unique<io::RecordWriter>(\n        file.get(),\n        io::RecordWriterOptions::CreateRecordWriterOptions(compression_type));\n    DatasetBase* dataset;\n    TF_RETURN_IF_ERROR(GetDatasetFromVariantTensor(ctx->input(0), &dataset));\n    IteratorContext::Params params(ctx);\n    FunctionHandleCache function_handle_cache(params.flr);\n    params.function_handle_cache = &function_handle_cache;\n    ResourceMgr resource_mgr;\n    params.resource_mgr = &resource_mgr;\n    CancellationManager cancellation_manager(ctx->cancellation_manager());\n    params.cancellation_manager = &cancellation_manager;\n    IteratorContext iter_ctx(std::move(params));\n    DatasetBase* finalized_dataset;\n    TF_RETURN_IF_ERROR(FinalizeDataset(ctx, dataset, &finalized_dataset));\n    std::unique_ptr<IteratorBase> iterator;\n    TF_RETURN_IF_ERROR(finalized_dataset->MakeIterator(\n        &iter_ctx, nullptr, \"ToTFRecordOpIterator\", &iterator));\n    std::vector<Tensor> components;\n    components.reserve(finalized_dataset->output_dtypes().size());\n    bool end_of_sequence;\n    do {\n      TF_RETURN_IF_ERROR(\n          iterator->GetNext(&iter_ctx, &components, &end_of_sequence));\n      if (!end_of_sequence) {\n        TF_RETURN_IF_ERROR(\n            writer->WriteRecord(components[0].scalar<tstring>()()));\n      }\n      components.clear();\n    } while (!end_of_sequence);\n    return Status::OK();\n  }", "target": 1}
{"code": "static bool regsafe(struct bpf_reg_state *rold, struct bpf_reg_state *rcur,\n\t\t    struct idpair *idmap)\n{\n\tif (!(rold->live & REG_LIVE_READ))\n\t\treturn true;\n\tif (memcmp(rold, rcur, offsetof(struct bpf_reg_state, live)) == 0)\n\t\treturn true;\n\tif (rold->type == NOT_INIT)\n\t\treturn true;\n\tif (rcur->type == NOT_INIT)\n\t\treturn false;\n\tswitch (rold->type) {\n\tcase SCALAR_VALUE:\n\t\tif (rcur->type == SCALAR_VALUE) {\n \t\t\treturn range_within(rold, rcur) &&\n \t\t\t       tnum_in(rold->var_off, rcur->var_off);\n \t\t} else {\n\t\t\treturn rold->umin_value == 0 &&\n\t\t\t       rold->umax_value == U64_MAX &&\n\t\t\t       rold->smin_value == S64_MIN &&\n\t\t\t       rold->smax_value == S64_MAX &&\n\t\t\t       tnum_is_unknown(rold->var_off);\n \t\t}\n \tcase PTR_TO_MAP_VALUE:\n\t\treturn memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)) == 0 &&\n\t\t       range_within(rold, rcur) &&\n\t\t       tnum_in(rold->var_off, rcur->var_off);\n\tcase PTR_TO_MAP_VALUE_OR_NULL:\n\t\tif (rcur->type != PTR_TO_MAP_VALUE_OR_NULL)\n\t\t\treturn false;\n\t\tif (memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)))\n\t\t\treturn false;\n\t\treturn check_ids(rold->id, rcur->id, idmap);\n\tcase PTR_TO_PACKET_META:\n\tcase PTR_TO_PACKET:\n\t\tif (rcur->type != rold->type)\n\t\t\treturn false;\n\t\tif (rold->range > rcur->range)\n\t\t\treturn false;\n\t\tif (rold->off != rcur->off)\n\t\t\treturn false;\n\t\tif (rold->id && !check_ids(rold->id, rcur->id, idmap))\n\t\t\treturn false;\n\t\treturn range_within(rold, rcur) &&\n\t\t       tnum_in(rold->var_off, rcur->var_off);\n\tcase PTR_TO_CTX:\n\tcase CONST_PTR_TO_MAP:\n\tcase PTR_TO_STACK:\n\tcase PTR_TO_PACKET_END:\n\tdefault:\n\t\treturn false;\n\t}\n\tWARN_ON_ONCE(1);\n\treturn false;\n}", "target": 1}
{"code": "bool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, int *r, struct dest_map *dest_map)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap;\n\tstruct kvm_lapic **dst = NULL;\n\tint i;\n\tbool ret;\n\t*r = -1;\n\tif (irq->shorthand == APIC_DEST_SELF) {\n\t\t*r = kvm_apic_set_irq(src->vcpu, irq, dest_map);\n\t\treturn true;\n\t}\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\tret = kvm_apic_map_get_dest_lapic(kvm, &src, irq, map, &dst, &bitmap);\n\tif (ret) {\n\t\t*r = 0;\n\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\tif (!dst[i])\n\t\t\t\tcontinue;\n\t\t\t*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}", "target": 1}
{"code": " onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,\n                OnigCompileInfo* ci, OnigErrorInfo* einfo)\n{\n  int r;\n  UChar *cpat, *cpat_end;\n   if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;\n   if (ci->pattern_enc != ci->target_enc) {\n    r = conv_encoding(ci->pattern_enc, ci->target_enc, pattern, pattern_end,\n                      &cpat, &cpat_end);\n    if (r != 0) return r;\n   }\n   else {\n     cpat     = (UChar* )pattern;\n    cpat_end = (UChar* )pattern_end;\n  }\n  *reg = (regex_t* )xmalloc(sizeof(regex_t));\n  if (IS_NULL(*reg)) {\n    r = ONIGERR_MEMORY;\n    goto err2;\n  }\n  r = onig_reg_init(*reg, ci->option, ci->case_fold_flag, ci->target_enc,\n                    ci->syntax);\n  if (r != 0) goto err;\n  r = onig_compile(*reg, cpat, cpat_end, einfo);\n  if (r != 0) {\n  err:\n    onig_free(*reg);\n    *reg = NULL;\n  }\n err2:\n  if (cpat != pattern) xfree(cpat);\n  return r;\n}", "target": 1}
{"code": "int url_is_local_not_ssh(const char *url)\n{\n\tconst char *colon = strchr(url, ':');\n\tconst char *slash = strchr(url, '/');\n\treturn !colon || (slash && slash < colon) ||\n\t\thas_dos_drive_prefix(url);\n}", "target": 1}
{"code": "fmtstr(char **sbuffer,\n       char **buffer,\n       size_t *currlen,\n       size_t *maxlen, const char *value, int flags, int min, int max)\n{\n    int padlen, strln;\n    int cnt = 0;\n    if (value == 0)\n        value = \"<NULL>\";\n    for (strln = 0; value[strln]; ++strln) ;\n    padlen = min - strln;\n    if (padlen < 0)\n        padlen = 0;\n    if (flags & DP_F_MINUS)\n        padlen = -padlen;\n    while ((padlen > 0) && (cnt < max)) {\n        doapr_outch(sbuffer, buffer, currlen, maxlen, ' ');\n        --padlen;\n        ++cnt;\n    }\n    while (*value && (cnt < max)) {\n        doapr_outch(sbuffer, buffer, currlen, maxlen, *value++);\n        ++cnt;\n    }\n    while ((padlen < 0) && (cnt < max)) {\n        doapr_outch(sbuffer, buffer, currlen, maxlen, ' ');\n        ++padlen;\n        ++cnt;\n    }\n}", "target": 1}
{"code": "Http::Response AbstractWebApplication::processRequest(const Http::Request &request, const Http::Environment &env)\n{\n    session_ = 0;\n    request_ = request;\n    env_ = env;\n    clear(); \n    sessionInitialize();\n    if (!sessionActive() && !isAuthNeeded())\n        sessionStart();\n    if (isBanned()) {\n        status(403, \"Forbidden\");\n        print(QObject::tr(\"Your IP address has been banned after too many failed authentication attempts.\"), Http::CONTENT_TYPE_TXT);\n    }\n    else {\n        processRequest();\n    }\n    return response();\n}", "target": 1}
{"code": "static inline void phar_set_inode(phar_entry_info *entry TSRMLS_DC) \n{\n\tchar tmp[MAXPATHLEN];\n\tint tmp_len;\n\ttmp_len = entry->filename_len + entry->phar->fname_len;\n\tmemcpy(tmp, entry->phar->fname, entry->phar->fname_len);\n\tmemcpy(tmp + entry->phar->fname_len, entry->filename, entry->filename_len);\n\tentry->inode = (unsigned short)zend_get_hash_value(tmp, tmp_len);\n}", "target": 1}
{"code": "static int emsff_init(struct hid_device *hid)\n{\n\tstruct emsff_device *emsff;\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput = list_first_entry(&hid->inputs,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct list_head *report_list =\n\t\t\t&hid->report_enum[HID_OUTPUT_REPORT].report_list;\n\tstruct input_dev *dev = hidinput->input;\n\tint error;\n\tif (list_empty(report_list)) {\n\t\thid_err(hid, \"no output reports found\\n\");\n\t\treturn -ENODEV;\n\t}\n\treport = list_first_entry(report_list, struct hid_report, list);\n\tif (report->maxfield < 1) {\n\t\thid_err(hid, \"no fields in the report\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (report->field[0]->report_count < 7) {\n\t\thid_err(hid, \"not enough values in the field\\n\");\n\t\treturn -ENODEV;\n\t}\n\temsff = kzalloc(sizeof(struct emsff_device), GFP_KERNEL);\n\tif (!emsff)\n\t\treturn -ENOMEM;\n\tset_bit(FF_RUMBLE, dev->ffbit);\n\terror = input_ff_create_memless(dev, emsff, emsff_play);\n\tif (error) {\n\t\tkfree(emsff);\n\t\treturn error;\n\t}\n\temsff->report = report;\n\temsff->report->field[0]->value[0] = 0x01;\n\temsff->report->field[0]->value[1] = 0x00;\n\temsff->report->field[0]->value[2] = 0x00;\n\temsff->report->field[0]->value[3] = 0x00;\n\temsff->report->field[0]->value[4] = 0x00;\n\temsff->report->field[0]->value[5] = 0x00;\n\temsff->report->field[0]->value[6] = 0x00;\n\thid_hw_request(hid, emsff->report, HID_REQ_SET_REPORT);\n\thid_info(hid, \"force feedback for EMS based devices by Ignaz Forster <ignaz.forster@gmx.de>\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "int compat_get_timex(struct timex *txc, const struct compat_timex __user *utp)\n {\n \tstruct compat_timex tx32;\n \tif (copy_from_user(&tx32, utp, sizeof(struct compat_timex)))\n \t\treturn -EFAULT;\n\ttxc->modes = tx32.modes;\n\ttxc->offset = tx32.offset;\n\ttxc->freq = tx32.freq;\n\ttxc->maxerror = tx32.maxerror;\n\ttxc->esterror = tx32.esterror;\n\ttxc->status = tx32.status;\n\ttxc->constant = tx32.constant;\n\ttxc->precision = tx32.precision;\n\ttxc->tolerance = tx32.tolerance;\n\ttxc->time.tv_sec = tx32.time.tv_sec;\n\ttxc->time.tv_usec = tx32.time.tv_usec;\n\ttxc->tick = tx32.tick;\n\ttxc->ppsfreq = tx32.ppsfreq;\n\ttxc->jitter = tx32.jitter;\n\ttxc->shift = tx32.shift;\n\ttxc->stabil = tx32.stabil;\n\ttxc->jitcnt = tx32.jitcnt;\n\ttxc->calcnt = tx32.calcnt;\n\ttxc->errcnt = tx32.errcnt;\n\ttxc->stbcnt = tx32.stbcnt;\n\treturn 0;\n}", "target": 1}
{"code": "static int irda_recvmsg_dgram(struct kiocb *iocb, struct socket *sock,\n\t\t\t      struct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct irda_sock *self = irda_sk(sk);\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint err;\n \tIRDA_DEBUG(4, \"%s()\\n\", __func__);\n \tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n \t\t\t\tflags & MSG_DONTWAIT, &err);\n \tif (!skb)\n\t\treturn err;\n\tskb_reset_transport_header(skb);\n\tcopied = skb->len;\n\tif (copied > size) {\n\t\tIRDA_DEBUG(2, \"%s(), Received truncated frame (%zd < %zd)!\\n\",\n\t\t\t   __func__, copied, size);\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tskb_free_datagram(sk, skb);\n\tif (self->rx_flow == FLOW_STOP) {\n\t\tif ((atomic_read(&sk->sk_rmem_alloc) << 2) <= sk->sk_rcvbuf) {\n\t\t\tIRDA_DEBUG(2, \"%s(), Starting IrTTP\\n\", __func__);\n\t\t\tself->rx_flow = FLOW_START;\n\t\t\tirttp_flow_request(self->tsap, FLOW_START);\n\t\t}\n\t}\n\treturn copied;\n}", "target": 1}
{"code": "static int prealloc_elems_and_freelist(struct bpf_stack_map *smap)\n{\n\tu32 elem_size = sizeof(struct stack_map_bucket) + smap->map.value_size;\n\tint err;\n\tsmap->elems = bpf_map_area_alloc(elem_size * smap->map.max_entries,\n\t\t\t\t\t smap->map.numa_node);\n\tif (!smap->elems)\n\t\treturn -ENOMEM;\n\terr = pcpu_freelist_init(&smap->freelist);\n\tif (err)\n\t\tgoto free_elems;\n\tpcpu_freelist_populate(&smap->freelist, smap->elems, elem_size,\n\t\t\t       smap->map.max_entries);\n\treturn 0;\nfree_elems:\n\tbpf_map_area_free(smap->elems);\n\treturn err;\n}", "target": 1}
{"code": "static bool allowed_problem_dir(const char *dir_name)\n{\n#if 0\n    unsigned len = strlen(g_settings_dump_location);\n    if (strncmp(dir_name, g_settings_dump_location, len) != 0\n     || (dir_name[len] != '/' && dir_name[len] != '\\0')\n     || strstr(dir_name + len, \"/.\")\n    ) {\n        return false;\n    }\n#endif\n    return true;\n}", "target": 1}
{"code": "DOMArrayBuffer* FileReaderLoader::ArrayBufferResult() {\n  DCHECK_EQ(read_type_, kReadAsArrayBuffer);\n  if (array_buffer_result_)\n    return array_buffer_result_;\n   if (!raw_data_ || error_code_ != FileErrorCode::kOK)\n     return nullptr;\n  DOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());\n  if (finished_loading_) {\n    array_buffer_result_ = result;\n    AdjustReportedMemoryUsageToV8(\n        -1 * static_cast<int64_t>(raw_data_->ByteLength()));\n    raw_data_.reset();\n   }\n  return result;\n }", "target": 1}
{"code": "static unsigned int stack_maxrandom_size(void)\n {\n\tunsigned int max = 0;\n \tif ((current->flags & PF_RANDOMIZE) &&\n \t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n\t\tmax = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;\n \t}\n \treturn max;\n}", "target": 1}
{"code": "Variant HHVM_FUNCTION(mcrypt_get_block_size, const String& cipher,\n                                    const Variant& module ) {\n  MCRYPT td = mcrypt_module_open((char*)cipher.data(),\n                                 (char*)MCG(algorithms_dir).data(),\n                                 (char*)module.asCStrRef().data(),\n                                 (char*)MCG(modes_dir).data());\n  if (td == MCRYPT_FAILED) {\n    MCRYPT_OPEN_MODULE_FAILED(\"mcrypt_get_block_size\");\n    return false;\n  }\n  int64_t ret = mcrypt_enc_get_block_size(td);\n  mcrypt_module_close(td);\n  return ret;\n}", "target": 1}
{"code": "size_t jsvGetString(const JsVar *v, char *str, size_t len) {\n  assert(len>0);\n  const char *s = jsvGetConstString(v);\n  if (s) {\n     len--;\n     int l = 0;\n    while (*s && l<len) {\n       str[l] = s[l];\n       l++;\n     }\n    str[l] = 0;\n    return l;\n  } else if (jsvIsInt(v)) {\n    itostr(v->varData.integer, str, 10);\n    return strlen(str);\n  } else if (jsvIsFloat(v)) {\n    ftoa_bounded(v->varData.floating, str, len);\n    return strlen(str);\n  } else if (jsvHasCharacterData(v)) {\n    assert(!jsvIsStringExt(v));\n    size_t l = len;\n    JsvStringIterator it;\n    jsvStringIteratorNewConst(&it, v, 0);\n    while (jsvStringIteratorHasChar(&it)) {\n      if (l--<=1) {\n        *str = 0;\n        jsvStringIteratorFree(&it);\n        return len;\n      }\n      *(str++) = jsvStringIteratorGetChar(&it);\n      jsvStringIteratorNext(&it);\n    }\n    jsvStringIteratorFree(&it);\n    *str = 0;\n    return len-l;\n  } else {\n    JsVar *stringVar = jsvAsString((JsVar*)v, false); \n    if (stringVar) {\n      size_t l = jsvGetString(stringVar, str, len); \n      jsvUnLock(stringVar);\n      return l;\n    } else {\n      str[0] = 0;\n      jsExceptionHere(JSET_INTERNALERROR, \"Variable type cannot be converted to string\");\n      return 0;\n    }\n  }\n}", "target": 1}
{"code": "TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,\n\t\t\t\t       uint32_t flags, uaddr_t uaddr,\n \t\t\t\t       size_t len)\n {\n \tuaddr_t a;\n \tsize_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,\n \t\t\t       CORE_MMU_USER_PARAM_SIZE);\n\tif (ADD_OVERFLOW(uaddr, len, &a))\n \t\treturn TEE_ERROR_ACCESS_DENIED;\n \tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t    (flags & TEE_MEMORY_ACCESS_SECURE))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\tif (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) &&\n \t   !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))\n \t\treturn TEE_ERROR_ACCESS_DENIED;\n\tfor (a = uaddr; a < (uaddr + len); a += addr_incr) {\n \t\tuint32_t attr;\n \t\tTEE_Result res;\n\t\tres = tee_mmu_user_va2pa_attr(utc, (void *)a, NULL, &attr);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t\t    (attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_SECURE) &&\n\t\t    !(attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_WRITE) && !(attr & TEE_MATTR_UW))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_READ) && !(attr & TEE_MATTR_UR))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t}\n\treturn TEE_SUCCESS;\n}", "target": 1}
{"code": "static void adu_disconnect(struct usb_interface *interface)\n{\n\tstruct adu_device *dev;\n\tdev = usb_get_intfdata(interface);\n\tmutex_lock(&dev->mtx);\t\n\tdev->udev = NULL;\t\n\tusb_deregister_dev(interface, &adu_class);\n\tmutex_unlock(&dev->mtx);\n\tmutex_lock(&adutux_mutex);\n\tusb_set_intfdata(interface, NULL);\n\tif (!dev->open_count)\n\t\tadu_delete(dev);\n\tmutex_unlock(&adutux_mutex);\n}", "target": 1}
{"code": " INST_HANDLER (lds) {\t\n \tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n \tint k = (buf[3] << 8) | buf[2];\n \top->ptr = k;\n\t__generic_ld_st (op, \"ram\", 0, 1, 0, k, 0);\n\tESIL_A (\"r%d,=,\", d);\n}", "target": 1}
{"code": "int mp_pack(lua_State *L) {\n    int nargs = lua_gettop(L);\n    int i;\n    mp_buf *buf;\n     if (nargs == 0)\n         return luaL_argerror(L, 0, \"MessagePack pack needs input.\");\n     buf = mp_buf_new(L);\n     for(i = 1; i <= nargs; i++) {\n        lua_pushvalue(L, i);\n        mp_encode_lua_type(L,buf,0);\n        lua_pushlstring(L,(char*)buf->b,buf->len);\n        buf->free += buf->len;\n        buf->len = 0;\n    }\n    mp_buf_free(L, buf);\n    lua_concat(L, nargs);\n    return 1;\n}", "target": 1}
{"code": " _prolog_error(batch_job_launch_msg_t *req, int rc)\n {\n\tchar *err_name_ptr, err_name[256], path_name[MAXPATHLEN];\n\tchar *fmt_char;\n\tint fd;\n\tif (req->std_err || req->std_out) {\n\t\tif (req->std_err)\n\t\t\tstrncpy(err_name, req->std_err, sizeof(err_name));\n\t\telse\n\t\t\tstrncpy(err_name, req->std_out, sizeof(err_name));\n\t\tif ((fmt_char = strchr(err_name, (int) '%')) &&\n\t\t    (fmt_char[1] == 'j') && !strchr(fmt_char+1, (int) '%')) {\n\t\t\tchar tmp_name[256];\n\t\t\tfmt_char[1] = 'u';\n\t\t\tsnprintf(tmp_name, sizeof(tmp_name), err_name,\n\t\t\t\t req->job_id);\n\t\t\tstrncpy(err_name, tmp_name, sizeof(err_name));\n\t\t}\n\t} else {\n\t\tsnprintf(err_name, sizeof(err_name), \"slurm-%u.out\",\n\t\t\t req->job_id);\n\t}\n\terr_name_ptr = err_name;\n\tif (err_name_ptr[0] == '/')\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s\", err_name_ptr);\n\telse if (req->work_dir)\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s/%s\",\n \t\t\treq->work_dir, err_name_ptr);\n \telse\n \t\tsnprintf(path_name, MAXPATHLEN, \"/%s\", err_name_ptr);\n\tif ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1) {\n\t\terror(\"Unable to open %s: %s\", path_name,\n\t\t      slurm_strerror(errno));\n \t\treturn;\n \t}\n \tsnprintf(err_name, sizeof(err_name),\n\t\t \"Error running slurm prolog: %d\\n\", WEXITSTATUS(rc));\n\tsafe_write(fd, err_name, strlen(err_name));\n\tif (fchown(fd, (uid_t) req->uid, (gid_t) req->gid) == -1) {\n\t\tsnprintf(err_name, sizeof(err_name),\n\t\t\t \"Couldn't change fd owner to %u:%u: %m\\n\",\n\t\t\t req->uid, req->gid);\n\t}\nrwfail:\n\tclose(fd);\n}", "target": 1}
{"code": " static void copyIPv6IfDifferent(void * dest, const void * src)\n {\n\tif(dest != src) {\n \t\tmemcpy(dest, src, sizeof(struct in6_addr));\n \t}\n }", "target": 1}
{"code": "handle_mlppp(netdissect_options *ndo,\n             const u_char *p, int length)\n{\n     if (!ndo->ndo_eflag)\n         ND_PRINT((ndo, \"MLPPP, \"));\n     ND_PRINT((ndo, \"seq 0x%03x, Flags [%s], length %u\",\n            (EXTRACT_16BITS(p))&0x0fff, \n            bittok2str(ppp_ml_flag_values, \"none\", *p & 0xc0),\n           length));\n}", "target": 1}
{"code": "void Con_Dump_f( void ) {\n\tint l, x, i;\n\tshort   *line;\n\tfileHandle_t f;\n\tint\t\tbufferlen;\n\tchar\t*buffer;\n\tchar\tfilename[MAX_QPATH];\n\tif ( Cmd_Argc() != 2 ) {\n\t\tCom_Printf( \"usage: condump <filename>\\n\" );\n\t\treturn;\n\t}\n\tQ_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) );\n\tCOM_DefaultExtension( filename, sizeof( filename ), \".txt\" );\n\tf = FS_FOpenFileWrite( filename );\n\tif ( !f ) {\n\t\tCom_Printf (\"ERROR: couldn't open %s.\\n\", filename);\n\t\treturn;\n\t}\n\tCom_Printf (\"Dumped console text to %s.\\n\", filename );\n\tfor ( l = con.current - con.totallines + 1 ; l <= con.current ; l++ )\n\t{\n\t\tline = con.text + ( l % con.totallines ) * con.linewidth;\n\t\tfor ( x = 0 ; x < con.linewidth ; x++ )\n\t\t\tif ( ( line[x] & 0xff ) != ' ' ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif ( x != con.linewidth ) {\n\t\t\tbreak;\n\t\t}\n\t}\n#ifdef _WIN32\n\tbufferlen = con.linewidth + 3 * sizeof ( char );\n#else\n\tbufferlen = con.linewidth + 2 * sizeof ( char );\n#endif\n\tbuffer = Hunk_AllocateTempMemory( bufferlen );\n\tbuffer[bufferlen-1] = 0;\n\tfor ( ; l <= con.current ; l++ )\n\t{\n\t\tline = con.text + ( l % con.totallines ) * con.linewidth;\n\t\tfor ( i = 0; i < con.linewidth; i++ )\n\t\t\tbuffer[i] = line[i] & 0xff;\n\t\tfor ( x = con.linewidth - 1 ; x >= 0 ; x-- )\n\t\t{\n\t\t\tif ( buffer[x] == ' ' ) {\n\t\t\t\tbuffer[x] = 0;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#ifdef _WIN32\n\t\tQ_strcat(buffer, bufferlen, \"\\r\\n\");\n#else\n\t\tQ_strcat(buffer, bufferlen, \"\\n\");\n#endif\n\t\tFS_Write( buffer, strlen( buffer ), f );\n\t}\n\tHunk_FreeTempMemory( buffer );\n\tFS_FCloseFile( f );\n}", "target": 1}
{"code": "int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gid, mode_t mode) {\n        _cleanup_close_ int fd;\n        int r;\n        assert(path);\n         if (parents)\n                 mkdir_parents(path, 0755);\n        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY, mode > 0 ? mode : 0644);\n         if (fd < 0)\n                 return -errno;\n        if (mode != MODE_INVALID) {\n                r = fchmod(fd, mode);\n                if (r < 0)\n                        return -errno;\n        }\n        if (uid != UID_INVALID || gid != GID_INVALID) {\n                r = fchown(fd, uid, gid);\n                if (r < 0)\n                        return -errno;\n        }\n        if (stamp != USEC_INFINITY) {\n                struct timespec ts[2];\n                timespec_store(&ts[0], stamp);\n                ts[1] = ts[0];\n                r = futimens(fd, ts);\n        } else\n                r = futimens(fd, NULL);\n        if (r < 0)\n                return -errno;\n        return 0;\n}", "target": 1}
{"code": "static int http_connect(http_subtransport *t)\n{\n\tint error;\n\tchar *proxy_url;\n\tif (t->connected &&\n\t\thttp_should_keep_alive(&t->parser) &&\n\t\tt->parse_finished)\n\t\treturn 0;\n\tif (t->io) {\n\t\tgit_stream_close(t->io);\n\t\tgit_stream_free(t->io);\n\t\tt->io = NULL;\n\t\tt->connected = 0;\n\t}\n\tif (t->connection_data.use_ssl) {\n\t\terror = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n\t} else {\n#ifdef GIT_CURL\n\t\terror = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n#else\n\t\terror = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);\n#endif\n\t}\n\tif (error < 0)\n\t\treturn error;\n\tGITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, \"git_stream\");\n\tif (git_stream_supports_proxy(t->io) &&\n\t    !git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url)) {\n\t\terror = git_stream_set_proxy(t->io, proxy_url);\n\t\tgit__free(proxy_url);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\terror = git_stream_connect(t->io);\n#if defined(GIT_OPENSSL) || defined(GIT_SECURE_TRANSPORT) || defined(GIT_CURL)\n \tif ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&\n \t    git_stream_is_encrypted(t->io)) {\n \t\tgit_cert *cert;\n\t\tint is_valid;\n \t\tif ((error = git_stream_certificate(&cert, t->io)) < 0)\n \t\t\treturn error;\n \t\tgiterr_clear();\n\t\tis_valid = error != GIT_ECERTIFICATE;\n \t\terror = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);\n \t\tif (error < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, \"user cancelled certificate check\");\n\t\t\treturn error;\n\t\t}\n\t}\n#endif\n\tif (error < 0)\n\t\treturn error;\n\tt->connected = 1;\n\treturn 0;\n}", "target": 1}
{"code": "static int decode_level3_header(LHAFileHeader **header, LHAInputStream *stream)\n{\n\tunsigned int header_len;\n\tif (lha_decode_uint16(&RAW_DATA(header, 0)) != 4) {\n\t\treturn 0;\n\t}\n\tif (!extend_raw_data(header, stream,\n\t                     LEVEL_3_HEADER_LEN - RAW_DATA_LEN(header))) {\n\t\treturn 0;\n\t}\n \theader_len = lha_decode_uint32(&RAW_DATA(header, 24));\n\tif (header_len > LEVEL_3_MAX_HEADER_LEN) {\n \t\treturn 0;\n \t}\n\tif (!extend_raw_data(header, stream,\n\t                     header_len - RAW_DATA_LEN(header))) {\n\t\treturn 0;\n\t}\n\tmemcpy((*header)->compress_method, &RAW_DATA(header, 2), 5);\n\t(*header)->compress_method[5] = '\\0';\n\t(*header)->compressed_length = lha_decode_uint32(&RAW_DATA(header, 7));\n\t(*header)->length = lha_decode_uint32(&RAW_DATA(header, 11));\n\t(*header)->timestamp = lha_decode_uint32(&RAW_DATA(header, 15));\n\t(*header)->crc = lha_decode_uint16(&RAW_DATA(header, 21));\n\t(*header)->os_type = RAW_DATA(header, 23);\n\tif (!decode_extended_headers(header, 28)) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": " Response PageHandler::SetDownloadBehavior(const std::string& behavior,\n                                           Maybe<std::string> download_path) {\n   WebContentsImpl* web_contents = GetWebContents();\n   if (!web_contents)\n     return Response::InternalError();\n  if (behavior == Page::SetDownloadBehavior::BehaviorEnum::Allow &&\n      !download_path.isJust())\n    return Response::Error(\"downloadPath not provided\");\n  if (behavior == Page::SetDownloadBehavior::BehaviorEnum::Default) {\n    DevToolsDownloadManagerHelper::RemoveFromWebContents(web_contents);\n    download_manager_delegate_ = nullptr;\n    return Response::OK();\n  }\n  content::BrowserContext* browser_context = web_contents->GetBrowserContext();\n  DCHECK(browser_context);\n  content::DownloadManager* download_manager =\n      content::BrowserContext::GetDownloadManager(browser_context);\n  download_manager_delegate_ =\n      DevToolsDownloadManagerDelegate::TakeOver(download_manager);\n  DevToolsDownloadManagerHelper::CreateForWebContents(web_contents);\n  DevToolsDownloadManagerHelper* download_helper =\n      DevToolsDownloadManagerHelper::FromWebContents(web_contents);\n  download_helper->SetDownloadBehavior(\n      DevToolsDownloadManagerHelper::DownloadBehavior::DENY);\n  if (behavior == Page::SetDownloadBehavior::BehaviorEnum::Allow) {\n    download_helper->SetDownloadBehavior(\n        DevToolsDownloadManagerHelper::DownloadBehavior::ALLOW);\n    download_helper->SetDownloadPath(download_path.fromJust());\n  }\n  return Response::OK();\n}", "target": 1}
{"code": "static void ppp_cp_parse_cr(struct net_device *dev, u16 pid, u8 id,\n\t\t\t    unsigned int req_len, const u8 *data)\n{\n\tstatic u8 const valid_accm[6] = { LCP_OPTION_ACCM, 6, 0, 0, 0, 0 };\n\tconst u8 *opt;\n\tu8 *out;\n\tunsigned int len = req_len, nak_len = 0, rej_len = 0;\n\tif (!(out = kmalloc(len, GFP_ATOMIC))) {\n\t\tdev->stats.rx_dropped++;\n\t\treturn;\t\n\t}\n\tfor (opt = data; len; len -= opt[1], opt += opt[1]) {\n\t\tif (len < 2 || len < opt[1]) {\n\t\t\tdev->stats.rx_errors++;\n\t\t\tkfree(out);\n\t\t\treturn; \n\t\t}\n\t\tif (pid == PID_LCP)\n\t\t\tswitch (opt[0]) {\n\t\t\tcase LCP_OPTION_MRU:\n\t\t\t\tcontinue; \n\t\t\tcase LCP_OPTION_ACCM: \n\t\t\t\tif (!memcmp(opt, valid_accm,\n\t\t\t\t\t    sizeof(valid_accm)))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!rej_len) { \n\t\t\t\t\tmemcpy(out + nak_len, valid_accm,\n\t\t\t\t\t       sizeof(valid_accm));\n\t\t\t\t\tnak_len += sizeof(valid_accm);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LCP_OPTION_MAGIC:\n\t\t\t\tif (opt[1] != 6 || (!opt[2] && !opt[3] &&\n\t\t\t\t\t\t    !opt[4] && !opt[5]))\n\t\t\t\t\tbreak; \n\t\t\t\tcontinue;\n\t\t\t}\n\t\tmemcpy(out + rej_len, opt, opt[1]);\n\t\trej_len += opt[1];\n\t}\n\tif (rej_len)\n\t\tppp_cp_event(dev, pid, RCR_BAD, CP_CONF_REJ, id, rej_len, out);\n\telse if (nak_len)\n\t\tppp_cp_event(dev, pid, RCR_BAD, CP_CONF_NAK, id, nak_len, out);\n\telse\n\t\tppp_cp_event(dev, pid, RCR_GOOD, CP_CONF_ACK, id, req_len, data);\n\tkfree(out);\n}", "target": 1}
{"code": "static int load_script(struct linux_binprm *bprm)\n{\n\tconst char *i_arg, *i_name;\n\tchar *cp;\n\tstruct file *file;\n\tchar interp[BINPRM_BUF_SIZE];\n\tint retval;\n\tif ((bprm->buf[0] != '#') || (bprm->buf[1] != '!') ||\n\t    (bprm->recursion_depth > BINPRM_MAX_RECURSION))\n\t\treturn -ENOEXEC;\n\tbprm->recursion_depth++;\n\tallow_write_access(bprm->file);\n\tfput(bprm->file);\n\tbprm->file = NULL;\n\tbprm->buf[BINPRM_BUF_SIZE - 1] = '\\0';\n\tif ((cp = strchr(bprm->buf, '\\n')) == NULL)\n\t\tcp = bprm->buf+BINPRM_BUF_SIZE-1;\n\t*cp = '\\0';\n\twhile (cp > bprm->buf) {\n\t\tcp--;\n\t\tif ((*cp == ' ') || (*cp == '\\t'))\n\t\t\t*cp = '\\0';\n\t\telse\n\t\t\tbreak;\n\t}\n\tfor (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\\t'); cp++);\n\tif (*cp == '\\0') \n\t\treturn -ENOEXEC; \n\ti_name = cp;\n\ti_arg = NULL;\n\tfor ( ; *cp && (*cp != ' ') && (*cp != '\\t'); cp++)\n\t\t ;\n\twhile ((*cp == ' ') || (*cp == '\\t'))\n\t\t*cp++ = '\\0';\n\tif (*cp)\n\t\ti_arg = cp;\n\tstrcpy (interp, i_name);\n\tretval = remove_arg_zero(bprm);\n\tif (retval)\n\t\treturn retval;\n\tretval = copy_strings_kernel(1, &bprm->interp, bprm);\n\tif (retval < 0) return retval; \n\tbprm->argc++;\n\tif (i_arg) {\n\t\tretval = copy_strings_kernel(1, &i_arg, bprm);\n\t\tif (retval < 0) return retval; \n\t\tbprm->argc++;\n\t}\n\tretval = copy_strings_kernel(1, &i_name, bprm);\n\tif (retval) return retval; \n\tbprm->argc++;\n\tbprm->interp = interp;\n\tfile = open_exec(interp);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\tbprm->file = file;\n\tretval = prepare_binprm(bprm);\n\tif (retval < 0)\n\t\treturn retval;\n\treturn search_binary_handler(bprm);\n}", "target": 1}
{"code": "OFCondition DcmSCP::listen()\n{\n  dcmEnableAutomaticInputDataCorrection.set( OFFalse );\n  OFCondition cond = EC_Normal;\n  if( !dcmDataDict.isDictionaryLoaded() )\n    DCMNET_WARN(\"No data dictionary loaded, check environment variable: \" << DCM_DICT_ENVIRONMENT_VARIABLE);\n#ifndef DISABLE_PORT_PERMISSION_CHECK\n#ifdef HAVE_GETEUID\n  if( m_cfg->getPort() < 1024 && geteuid() != 0 )\n  {\n    DCMNET_ERROR(\"No privileges to open this network port (\" << m_cfg->getPort() << \")\");\n    return NET_EC_InsufficientPortPrivileges;\n  }\n#endif\n#endif\n  T_ASC_Network *network = NULL;\n  cond = ASC_initializeNetwork( NET_ACCEPTOR, OFstatic_cast(int, m_cfg->getPort()), m_cfg->getACSETimeout(), &network );\n  if( cond.bad() )\n    return cond;\n#if defined(HAVE_SETUID) && defined(HAVE_GETUID)\n  setuid( getuid() );\n#endif\n  while( cond.good() && !stopAfterCurrentAssociation() )\n  {\n    cond = waitForAssociationRQ(network);\n  }\n  cond = ASC_dropNetwork( &network );\n  network = NULL;\n  return cond;\n}", "target": 1}
{"code": "RsaAdjustPrimeCandidate(\n\t\t\tbigNum          prime,\n\t\t\tSEED_COMPAT_LEVEL seedCompatLevel  \n\t\t\t)\n{\n    switch (seedCompatLevel) {\n    case SEED_COMPAT_LEVEL_ORIGINAL:\n        RsaAdjustPrimeCandidate_PreRev155(prime);\n        break;\n    case SEED_COMPAT_LEVEL_RSA_PRIME_ADJUST_FIX:\n        RsaAdjustPrimeCandidate_New(prime);\n        break;\n    default:\n        FAIL(FATAL_ERROR_INTERNAL);\n    }\n}", "target": 1}
{"code": "Fraction::Fraction(int32_t num,int32_t den)\n{\n  int32_t g = gcd(num, den);\n  if (num == std::numeric_limits<int32_t>::min() && g == -1) {\n    num++;\n  }\n  if (den == std::numeric_limits<int32_t>::min() && g == -1) {\n    den++;\n  }\n  numerator = num / g;\n  denominator = den / g;\n  while (denominator > MAX_FRACTION_DENOMINATOR) {\n    numerator >>= 1;\n    denominator >>= 1;\n  }\n}", "target": 1}
{"code": "XLookupColor (\n\tregister Display *dpy,\n        Colormap cmap,\n\t_Xconst char *spec,\n\tXColor *def,\n\tXColor *scr)\n{\n\tregister int n;\n\txLookupColorReply reply;\n\tregister xLookupColorReq *req;\n\tXcmsCCC ccc;\n\tXcmsColor cmsColor_exact;\n#ifdef XCMS\n\tif ((ccc = XcmsCCCOfColormap(dpy, cmap)) != (XcmsCCC)NULL) {\n\t    const char *tmpName = spec;\n\t    switch (_XcmsResolveColorString(ccc, &tmpName, &cmsColor_exact,\n\t\t\t\t\t    XcmsRGBFormat)) {\n\t    case XcmsSuccess:\n\t    case XcmsSuccessWithCompression:\n\t\t_XcmsRGB_to_XColor(&cmsColor_exact, def, 1);\n\t\tmemcpy((char *)scr, (char *)def, sizeof(XColor));\n\t\t_XUnresolveColor(ccc, scr);\n\t\treturn(1);\n\t    case XcmsFailure:\n\t    case _XCMS_NEWNAME:\n\t\tbreak;\n\t    }\n\t}\n#endif\n\tn = (int) strlen (spec);\n\tLockDisplay(dpy);\n\tGetReq (LookupColor, req);\n\treq->cmap = cmap;\n\treq->nbytes = n;\n\treq->length += (n + 3) >> 2;\n\tData (dpy, spec, (long)n);\n\tif (!_XReply (dpy, (xReply *) &reply, 0, xTrue)) {\n\t    UnlockDisplay(dpy);\n\t    SyncHandle();\n\t    return (0);\n\t    }\n\tdef->red   = reply.exactRed;\n\tdef->green = reply.exactGreen;\n\tdef->blue  = reply.exactBlue;\n\tscr->red   = reply.screenRed;\n\tscr->green = reply.screenGreen;\n\tscr->blue  = reply.screenBlue;\n\tUnlockDisplay(dpy);\n\tSyncHandle();\n\treturn (1);\n}", "target": 1}
{"code": "ssh_scp ssh_scp_new(ssh_session session, int mode, const char *location)\n{\n    ssh_scp scp = NULL;\n    if (session == NULL) {\n        goto error;\n    }\n    scp = (ssh_scp)calloc(1, sizeof(struct ssh_scp_struct));\n    if (scp == NULL) {\n        ssh_set_error(session, SSH_FATAL,\n                      \"Error allocating memory for ssh_scp\");\n        goto error;\n    }\n    if ((mode & ~SSH_SCP_RECURSIVE) != SSH_SCP_WRITE &&\n        (mode & ~SSH_SCP_RECURSIVE) != SSH_SCP_READ)\n    {\n        ssh_set_error(session, SSH_FATAL,\n                      \"Invalid mode %d for ssh_scp_new()\", mode);\n        goto error;\n    }\n    scp->location = strdup(location);\n    if (scp->location == NULL) {\n        ssh_set_error(session, SSH_FATAL,\n                      \"Error allocating memory for ssh_scp\");\n        goto error;\n    }\n    scp->session = session;\n    scp->mode = mode & ~SSH_SCP_RECURSIVE;\n    scp->recursive = (mode & SSH_SCP_RECURSIVE) != 0;\n    scp->channel = NULL;\n    scp->state = SSH_SCP_NEW;\n    return scp;\nerror:\n    ssh_scp_free(scp);\n    return NULL;\n}", "target": 1}
{"code": "MagickExport void RemoveDuplicateLayers(Image **images,\n     ExceptionInfo *exception)\n {\n  register Image\n    *curr,\n    *next;\n   RectangleInfo\n     bounds;\n   assert((*images) != (const Image *) NULL);\n   assert((*images)->signature == MagickCoreSignature);\n   if ((*images)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",(*images)->filename);\n   assert(exception != (ExceptionInfo *) NULL);\n   assert(exception->signature == MagickCoreSignature);\n  curr=GetFirstImageInList(*images);\n  for (; (next=GetNextImageInList(curr)) != (Image *) NULL; curr=next)\n   {\n    if ( curr->columns != next->columns || curr->rows != next->rows\n         || curr->page.x != next->page.x || curr->page.y != next->page.y )\n       continue;\n    bounds=CompareImageBounds(curr,next,CompareAnyLayer,exception);\n    if ( bounds.x < 0 ) {\n      size_t time;\n      time = curr->delay*1000/curr->ticks_per_second;\n      time += next->delay*1000/next->ticks_per_second;\n      next->ticks_per_second = 100L;\n      next->delay = time*curr->ticks_per_second/1000;\n      next->iterations = curr->iterations;\n      *images = curr;\n      (void) DeleteImageFromList(images);\n    }\n   }\n  *images = GetFirstImageInList(*images);\n }", "target": 1}
{"code": "static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n {\n   MagickBooleanType\n     status;\n  int\n    bit;\n  register const PixelPacket\n    *p;\n  register ssize_t\n    x;\n  ssize_t\n    y;\n  unsigned char\n    byte;\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n   assert(image->signature == MagickSignature);\n   if (image->debug != MagickFalse)\n     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n   if (status == MagickFalse)\n     return(status);\n   (void) TransformImageColorspace(image,sRGBColorspace);\n  if((image->columns > 255L) || (image->rows > 255L))\n    ThrowWriterException(ImageError,\"Dimensions must be less than 255x255\");\n  (void) WriteBlobByte(image,image->columns & 0xff);\n  (void) WriteBlobByte(image,image->rows & 0xff);\n  (void) SetImageType(image,BilevelType);\n  x=0;\n   y=0;\n   for (y=0; y < (ssize_t) image->rows; y++)\n   {\n    p=GetVirtualPixels(image,0,y,image->columns,1,exception);\n     if (p == (const PixelPacket *) NULL)\n       break;\n     bit=0;\n    byte=0;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      byte>>=1;\n      if (GetPixelLuma(image,p) < (QuantumRange/2.0))\n        byte|=0x80;\n      bit++;\n      if (bit == 8)\n        {\n       \t  (void) WriteBlobByte(image,byte);\n          bit=0;\n          byte=0;\n        }\n      p++;\n    }\n    if (bit != 0)\n      (void) WriteBlobByte(image,byte);\n    status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n      image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}", "target": 1}
{"code": "GetCode_(gdIOCtx *fd, CODE_STATIC_DATA *scd, int code_size, int flag, int *ZeroDataBlockP)\n{\n\tint           i, j, ret;\n\tunsigned char count;\n\tif (flag) {\n\t\tscd->curbit = 0;\n\t\tscd->lastbit = 0;\n\t\tscd->last_byte = 0;\n\t\tscd->done = FALSE;\n\t\treturn 0;\n\t}\n\tif ( (scd->curbit + code_size) >= scd->lastbit) {\n\t\tif (scd->done) {\n\t\t\tif (scd->curbit >= scd->lastbit) {\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\tscd->buf[0] = scd->buf[scd->last_byte-2];\n\t\tscd->buf[1] = scd->buf[scd->last_byte-1];\n               if ((count = GetDataBlock(fd, &scd->buf[2], ZeroDataBlockP)) <= 0)\n\t\t\tscd->done = TRUE;\n\t\tscd->last_byte = 2 + count;\n\t\tscd->curbit = (scd->curbit - scd->lastbit) + 16;\n\t\tscd->lastbit = (2+count)*8 ;\n\t}\n\tret = 0;\n\tfor (i = scd->curbit, j = 0; j < code_size; ++i, ++j)\n\t\tif (i < CSD_BUF_SIZE * 8) {\n\t\t\tret |= ((scd->buf[i / 8] & (1 << (i % 8))) != 0) << j;\n\t\t} else {\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\tscd->curbit += code_size;\n\treturn ret;\n}", "target": 1}
{"code": "CURLcode Curl_http_done(struct connectdata *conn,\n                        CURLcode status, bool premature)\n{\n  struct SessionHandle *data = conn->data;\n  struct HTTP *http =data->req.protop;\n  Curl_unencode_cleanup(conn);\n#ifdef USE_SPNEGO\n  if(data->state.proxyneg.state == GSS_AUTHSENT ||\n      data->state.negotiate.state == GSS_AUTHSENT)\n    Curl_cleanup_negotiate(data);\n#endif\n  conn->fread_func = data->set.fread_func; \n  conn->fread_in = data->set.in; \n  conn->seek_func = data->set.seek_func; \n  conn->seek_client = data->set.seek_client; \n  if(http == NULL)\n    return CURLE_OK;\n  if(http->send_buffer) {\n    Curl_send_buffer *buff = http->send_buffer;\n    free(buff->buffer);\n    free(buff);\n    http->send_buffer = NULL; \n  }\n  if(HTTPREQ_POST_FORM == data->set.httpreq) {\n    data->req.bytecount = http->readbytecount + http->writebytecount;\n    Curl_formclean(&http->sendit); \n    if(http->form.fp) {\n      fclose(http->form.fp);\n      http->form.fp = NULL;\n    }\n  }\n  else if(HTTPREQ_PUT == data->set.httpreq)\n    data->req.bytecount = http->readbytecount + http->writebytecount;\n  if(status)\n    return status;\n  if(!premature && \n     !conn->bits.retry &&\n     !data->set.connect_only &&\n     ((http->readbytecount +\n       data->req.headerbytecount -\n       data->req.deductheadercount)) <= 0) {\n    failf(data, \"Empty reply from server\");\n    return CURLE_GOT_NOTHING;\n  }\n  return CURLE_OK;\n}", "target": 1}
{"code": "PHP_FUNCTION(locale_accept_from_http)\n{\n\tUEnumeration *available;\n\tchar *http_accept = NULL;\n\tint http_accept_len;\n\tUErrorCode status = 0;\n\tint len;\n\tchar resultLocale[INTL_MAX_LOCALE_LEN+1];\n\tUAcceptResult outResult;\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &http_accept, &http_accept_len) == FAILURE)\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n \t\t\"locale_accept_from_http: unable to parse input parameters\", 0 TSRMLS_CC );\n \t\tRETURN_FALSE;\n \t}\n \tavailable = ures_openAvailableLocales(NULL, &status);\n \tINTL_CHECK_STATUS(status, \"locale_accept_from_http: failed to retrieve locale list\");\n\tlen = uloc_acceptLanguageFromHTTP(resultLocale, INTL_MAX_LOCALE_LEN, \n \t\t\t\t\t\t&outResult, http_accept, available, &status);\n \tuenum_close(available);\n \tINTL_CHECK_STATUS(status, \"locale_accept_from_http: failed to find acceptable locale\");\n\tif (len < 0 || outResult == ULOC_ACCEPT_FAILED) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_STRINGL(resultLocale, len, 1);\n}", "target": 1}
{"code": "void RemoteFrame::ScheduleNavigation(Document& origin_document,\n                                      const KURL& url,\n                                      WebFrameLoadType frame_load_type,\n                                      UserGestureStatus user_gesture_status) {\n   FrameLoadRequest frame_request(&origin_document, ResourceRequest(url));\n   frame_request.GetResourceRequest().SetHasUserGesture(\n       user_gesture_status == UserGestureStatus::kActive);\n  frame_request.GetResourceRequest().SetFrameType(\n      IsMainFrame() ? network::mojom::RequestContextFrameType::kTopLevel\n                    : network::mojom::RequestContextFrameType::kNested);\n  Navigate(frame_request, frame_load_type);\n}", "target": 1}
{"code": "ssize_t NuPlayer::NuPlayerStreamListener::read(\n void *data, size_t size, sp<AMessage> *extra) {\n    CHECK_GT(size, 0u);\n    extra->clear();\n Mutex::Autolock autoLock(mLock);\n if (mEOS) {\n return 0;\n }\n if (mQueue.empty()) {\n        mSendDataNotification = true;\n return -EWOULDBLOCK;\n }\n QueueEntry *entry = &*mQueue.begin();\n if (entry->mIsCommand) {\n switch (entry->mCommand) {\n case EOS:\n {\n                mQueue.erase(mQueue.begin());\n                entry = NULL;\n                mEOS = true;\n return 0;\n }\n case DISCONTINUITY:\n {\n *extra = entry->mExtra;\n                mQueue.erase(mQueue.begin());\n                entry = NULL;\n return INFO_DISCONTINUITY;\n }\n default:\n                TRESPASS();\n break;\n }\n }\n size_t copy = entry->mSize;\n if (copy > size) {\n         copy = size;\n     }\n     memcpy(data,\n           (const uint8_t *)mBuffers.editItemAt(entry->mIndex)->pointer()\n             + entry->mOffset,\n            copy);\n    entry->mOffset += copy;\n    entry->mSize -= copy;\n if (entry->mSize == 0) {\n        mSource->onBufferAvailable(entry->mIndex);\n        mQueue.erase(mQueue.begin());\n        entry = NULL;\n }\n return copy;\n}", "target": 1}
{"code": "static inline char *parse_ip_address_ex(const char *str, size_t str_len, int *portno, int get_err, zend_string **err)\n{\n\tchar *colon;\n \tchar *host = NULL;\n #ifdef HAVE_IPV6\n\tchar *p;\n \tif (*(str) == '[' && str_len > 1) {\n\t\tp = memchr(str + 1, ']', str_len - 2);\n \t\tif (!p || *(p + 1) != ':') {\n \t\t\tif (get_err) {\n \t\t\t\t*err = strpprintf(0, \"Failed to parse IPv6 address \\\"%s\\\"\", str);\n \t\t\t}\n \t\t\treturn NULL;\n \t\t}\n\t\t*portno = atoi(p + 2);\n \t\treturn estrndup(str + 1, p - str - 1);\n \t}\n #endif\n \tif (str_len) {\n \t\tcolon = memchr(str, ':', str_len - 1);\n \t} else {\n \t\tcolon = NULL;\n \t}\n \tif (colon) {\n\t\t*portno = atoi(colon + 1);\n\t\thost = estrndup(str, colon - str);\n\t} else {\n\t\tif (get_err) {\n\t\t\t*err = strpprintf(0, \"Failed to parse address \\\"%s\\\"\", str);\n \t\t}\n\t\treturn NULL;\n \t}\n\treturn host;\n }", "target": 1}
{"code": "sug_filltree(spellinfo_T *spin, slang_T *slang)\n{\n    char_u\t*byts;\n    idx_T\t*idxs;\n    int\t\tdepth;\n    idx_T\tarridx[MAXWLEN];\n    int\t\tcuri[MAXWLEN];\n    char_u\ttword[MAXWLEN];\n    char_u\ttsalword[MAXWLEN];\n    int\t\tc;\n    idx_T\tn;\n    unsigned\twords_done = 0;\n    int\t\twordcount[MAXWLEN];\n    spin->si_foldroot = wordtree_alloc(spin);\n    if (spin->si_foldroot == NULL)\n\treturn FAIL;\n    spin->si_sugtree = TRUE;\n    byts = slang->sl_fbyts;\n    idxs = slang->sl_fidxs;\n    arridx[0] = 0;\n    curi[0] = 1;\n    wordcount[0] = 0;\n    depth = 0;\n    while (depth >= 0 && !got_int)\n    {\n\tif (curi[depth] > byts[arridx[depth]])\n\t{\n\t    idxs[arridx[depth]] = wordcount[depth];\n\t    if (depth > 0)\n\t\twordcount[depth - 1] += wordcount[depth];\n\t    --depth;\n\t    line_breakcheck();\n\t}\n\telse\n\t{\n\t    n = arridx[depth] + curi[depth];\n\t    ++curi[depth];\n\t    c = byts[n];\n\t    if (c == 0)\n\t    {\n\t\ttword[depth] = NUL;\n\t\tspell_soundfold(slang, tword, TRUE, tsalword);\n\t\tif (tree_add_word(spin, tsalword, spin->si_foldroot,\n\t\t\t\twords_done >> 16, words_done & 0xffff,\n\t\t\t\t\t\t\t   0) == FAIL)\n\t\t    return FAIL;\n\t\t++words_done;\n\t\t++wordcount[depth];\n\t\tspin->si_blocks_cnt = 0;\n\t\twhile (n + 1 < slang->sl_fbyts_len && byts[n + 1] == 0)\n\t\t{\n\t\t    ++n;\n\t\t    ++curi[depth];\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\ttword[depth++] = c;\n\t\tarridx[depth] = idxs[n];\n\t\tcuri[depth] = 1;\n\t\twordcount[depth] = 0;\n\t    }\n\t}\n    }\n    smsg(_(\"Total number of words: %d\"), words_done);\n    return OK;\n}", "target": 1}
{"code": "ssize_t enc_untrusted_recvfrom(int sockfd, void *buf, size_t len, int flags,\n                               struct sockaddr *src_addr, socklen_t *addrlen) {\n  int klinux_flags = TokLinuxRecvSendFlag(flags);\n  if (klinux_flags == 0 && flags != 0) {\n    errno = EINVAL;\n    return -1;\n  }\n  MessageWriter input;\n  input.Push<int>(sockfd);\n  input.Push<uint64_t>(len);\n  input.Push<int>(klinux_flags);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kRecvFromHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_recvfrom\", 4);\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n  auto buffer_received = output.next();\n  memcpy(buf, buffer_received.data(), len);\n  if (src_addr != nullptr && addrlen != nullptr) {\n    auto klinux_sockaddr_buf = output.next();\n    const struct klinux_sockaddr *klinux_addr =\n        klinux_sockaddr_buf.As<struct klinux_sockaddr>();\n    FromkLinuxSockAddr(klinux_addr, klinux_sockaddr_buf.size(), src_addr,\n                       addrlen, TrustedPrimitives::BestEffortAbort);\n  }\n  return result;\n}", "target": 1}
{"code": "static void do_cmd(ESPState *s)\n{\n    uint8_t busid = fifo8_pop(&s->cmdfifo);\n    s->cmdfifo_cdb_offset--;\n    if (s->cmdfifo_cdb_offset) {\n        esp_fifo_pop_buf(&s->cmdfifo, NULL, s->cmdfifo_cdb_offset);\n        s->cmdfifo_cdb_offset = 0;\n    }\n    do_busid_cmd(s, busid);\n}", "target": 1}
{"code": "static int walk_hugetlb_range(unsigned long addr, unsigned long end,\n\t\t\t      struct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct hstate *h = hstate_vma(vma);\n\tunsigned long next;\n\tunsigned long hmask = huge_page_mask(h);\n\tunsigned long sz = huge_page_size(h);\n\tpte_t *pte;\n\tint err = 0;\n \tdo {\n \t\tnext = hugetlb_entry_end(h, addr, end);\n \t\tpte = huge_pte_offset(walk->mm, addr & hmask, sz);\n\t\tif (pte && walk->hugetlb_entry)\n \t\t\terr = walk->hugetlb_entry(pte, hmask, addr, next, walk);\n \t\tif (err)\n \t\t\tbreak;\n \t} while (addr = next, addr != end);\n\treturn err;\n}", "target": 1}
{"code": "bool timerqueue_add(struct timerqueue_head *head, struct timerqueue_node *node)\n{\n\tstruct rb_node **p = &head->head.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct timerqueue_node  *ptr;\n\tWARN_ON_ONCE(!RB_EMPTY_NODE(&node->node));\n\twhile (*p) {\n\t\tparent = *p;\n\t\tptr = rb_entry(parent, struct timerqueue_node, node);\n\t\tif (node->expires < ptr->expires)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\tp = &(*p)->rb_right;\n\t}\n\trb_link_node(&node->node, parent, p);\n\trb_insert_color(&node->node, &head->head);\n\tif (!head->next || node->expires < head->next->expires) {\n\t\thead->next = node;\n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "ptp_unpack_OPL (PTPParams *params, unsigned char* data, MTPProperties **pprops, unsigned int len)\n{ \n\tuint32_t prop_count = dtoh32a(data);\n\tMTPProperties *props = NULL;\n\tunsigned int offset = 0, i;\n\t*pprops = NULL;\n\tif (prop_count == 0)\n\t\treturn 0;\n\tif (prop_count >= INT_MAX/sizeof(MTPProperties)) {\n\t\tptp_debug (params ,\"prop_count %d is too large\", prop_count);\n\t\treturn 0;\n\t}\n\tptp_debug (params ,\"Unpacking MTP OPL, size %d (prop_count %d)\", len, prop_count);\n\tdata += sizeof(uint32_t);\n\tlen -= sizeof(uint32_t);\n\tprops = malloc(prop_count * sizeof(MTPProperties));\n\tif (!props) return 0;\n\tfor (i = 0; i < prop_count; i++) {\n\t\tif (len <= 0) {\n\t\t\tptp_debug (params ,\"short MTP Object Property List at property %d (of %d)\", i, prop_count);\n\t\t\tptp_debug (params ,\"device probably needs DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL\");\n\t\t\tptp_debug (params ,\"or even DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST\", i);\n\t\t\tqsort (props, i, sizeof(MTPProperties),_compare_func);\n\t\t\t*pprops = props;\n\t\t\treturn i;\n\t\t}\n\t\tprops[i].ObjectHandle = dtoh32a(data);\n\t\tdata += sizeof(uint32_t);\n\t\tlen -= sizeof(uint32_t);\n\t\tprops[i].property = dtoh16a(data);\n\t\tdata += sizeof(uint16_t);\n\t\tlen -= sizeof(uint16_t);\n\t\tprops[i].datatype = dtoh16a(data);\n\t\tdata += sizeof(uint16_t);\n\t\tlen -= sizeof(uint16_t);\n\t\toffset = 0;\n\t\tif (!ptp_unpack_DPV(params, data, &offset, len, &props[i].propval, props[i].datatype)) {\n\t\t\tptp_debug (params ,\"unpacking DPV of property %d encountered insufficient buffer. attack?\", i);\n\t\t\tqsort (props, i, sizeof(MTPProperties),_compare_func);\n\t\t\t*pprops = props;\n\t\t\treturn i;\n\t\t}\n\t\tdata += offset;\n\t\tlen -= offset;\n\t}\n\tqsort (props, prop_count, sizeof(MTPProperties),_compare_func);\n\t*pprops = props;\n\treturn prop_count;\n}", "target": 1}
{"code": " static void print_maps(struct pid_info_t* info)\n {\n     FILE *maps;\n     size_t offset;\n     char device[10];\n     long int inode;\n    char file[PATH_MAX];\n     strlcat(info->path, \"maps\", sizeof(info->path));\n    maps = fopen(info->path, \"r\");\n     if (!maps)\n         goto out;\n    while (fscanf(maps, \"%*x-%*x %*s %zx %s %ld %s\\n\", &offset, device, &inode,\n            file) == 4) {\n         if (inode == 0 || !strcmp(device, \"00:00\"))\n             continue;\n        printf(\"%-9s %5d %10s %4s %9s %18s %9zd %10ld %s\\n\",\n                info->cmdline, info->pid, info->user, \"mem\",\n \"???\", device, offset, inode, file);\n }\n    fclose(maps);\nout:\n    info->path[info->parent_length] = '\\0';\n}", "target": 1}
{"code": " int vfs_open(const struct path *path, struct file *file,\n \t     const struct cred *cred)\n {\n\tstruct dentry *dentry = path->dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tfile->f_path = *path;\n\tif (dentry->d_flags & DCACHE_OP_SELECT_INODE) {\n\t\tinode = dentry->d_op->d_select_inode(dentry, file->f_flags);\n\t\tif (IS_ERR(inode))\n\t\t\treturn PTR_ERR(inode);\n\t}\n \treturn do_dentry_open(file, inode, NULL, cred);\n }", "target": 1}
{"code": "OGRKMLLayer::OGRKMLLayer( const char * pszName,\n                          OGRSpatialReference *poSRSIn, bool bWriterIn,\n                          OGRwkbGeometryType eReqType,\n                          OGRKMLDataSource *poDSIn ) :\n    poDS_(poDSIn),\n    poSRS_(poSRSIn ? new OGRSpatialReference(nullptr) : nullptr),\n    poCT_(nullptr),\n    poFeatureDefn_(new OGRFeatureDefn( pszName )),\n    iNextKMLId_(0),\n    nTotalKMLCount_(-1),\n    bWriter_(bWriterIn),\n    nLayerNumber_(0),\n    nWroteFeatureCount_(0),\n    bSchemaWritten_(false),\n    pszName_(CPLStrdup(pszName)),\n    nLastAsked(-1),\n    nLastCount(-1)\n{\n    if( poSRSIn != nullptr )\n    {\n        poSRS_->SetWellKnownGeogCS( \"WGS84\" );\n        if( !poSRS_->IsSame(poSRSIn) )\n        {\n            poCT_ = OGRCreateCoordinateTransformation( poSRSIn, poSRS_ );\n            if( poCT_ == nullptr && poDSIn->IsFirstCTError() )\n            {\n                char *pszWKT = nullptr;\n                poSRSIn->exportToPrettyWkt( &pszWKT, FALSE );\n                CPLError(\n                    CE_Warning, CPLE_AppDefined,\n                    \"Failed to create coordinate transformation between the \"\n                    \"input coordinate system and WGS84.  This may be because \"\n                    \"they are not transformable.  \"\n                    \"KML geometries may not render correctly.  \"\n                    \"This message will not be issued any more.\"\n                    \"\\nSource:\\n%s\\n\",\n                    pszWKT );\n                CPLFree( pszWKT );\n                poDSIn->IssuedFirstCTError();\n            }\n        }\n    }\n    SetDescription( poFeatureDefn_->GetName() );\n    poFeatureDefn_->Reference();\n    poFeatureDefn_->SetGeomType( eReqType );\n    if( poFeatureDefn_->GetGeomFieldCount() != 0 )\n        poFeatureDefn_->GetGeomFieldDefn(0)->SetSpatialRef(poSRS_);\n    OGRFieldDefn oFieldName( \"Name\", OFTString );\n    poFeatureDefn_->AddFieldDefn( &oFieldName );\n    OGRFieldDefn oFieldDesc( \"Description\", OFTString );\n    poFeatureDefn_->AddFieldDefn( &oFieldDesc );\n    bClosedForWriting = !bWriterIn;\n}", "target": 1}
{"code": "static void _gnutls_handshake_internal_state_init(gnutls_session_t session)\n{\n\tsession->internals.adv_version_major = 0;\n\tsession->internals.adv_version_minor = 0;\n\tsession->internals.direction = 0;\n\tsession->internals.last_handshake_in = -1;\n\tsession->internals.last_handshake_out = -1;\n\tsession->internals.resumable = RESUME_TRUE;\n\tsession->internals.handshake_large_loops = 0;\n\tsession->internals.dtls.hsk_read_seq = 0;\n\tsession->internals.dtls.hsk_write_seq = 0;\n}", "target": 1}
{"code": "static bool parse_reconnect(struct pool *pool, json_t *val)\n{\n\tchar *sockaddr_url, *stratum_port, *tmp;\n\tchar *url, *port, address[256];\n\tmemset(address, 0, 255);\n\turl = (char *)json_string_value(json_array_get(val, 0));\n\tif (!url)\n\t\turl = pool->sockaddr_url;\n\telse {\n\t\tchar *dot_pool, *dot_reconnect;\n\t\tdot_pool = strchr(pool->sockaddr_url, '.');\n\t\tif (!dot_pool) {\n\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request for pool without domain '%s'\",\n\t\t\t       pool->sockaddr_url);\n\t\t\treturn false;\n\t\t}\n\t\tdot_reconnect = strchr(url, '.');\n\t\tif (!dot_reconnect) {\n\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request to url without domain '%s'\",\n\t\t\t       url);\n\t\t\treturn false;\n\t\t}\n\t\tif (strcmp(dot_pool, dot_reconnect)) {\n\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request to non-matching domain url '%s'\",\n\t\t\t\tpool->sockaddr_url);\n\t\t\treturn false;\n\t\t}\n\t}\n\tport = (char *)json_string_value(json_array_get(val, 1));\n \tif (!port)\n \t\tport = pool->stratum_port;\n\tsprintf(address, \"%s:%s\", url, port);\n \tif (!extract_sockaddr(address, &sockaddr_url, &stratum_port))\n \t\treturn false;\n\tapplog(LOG_WARNING, \"Stratum reconnect requested from pool %d to %s\", pool->pool_no, address);\n\tclear_pool_work(pool);\n\tmutex_lock(&pool->stratum_lock);\n\t__suspend_stratum(pool);\n\ttmp = pool->sockaddr_url;\n\tpool->sockaddr_url = sockaddr_url;\n\tpool->stratum_url = pool->sockaddr_url;\n\tfree(tmp);\n\ttmp = pool->stratum_port;\n\tpool->stratum_port = stratum_port;\n\tfree(tmp);\n\tmutex_unlock(&pool->stratum_lock);\n\tif (!restart_stratum(pool)) {\n\t\tpool_failed(pool);\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": " static void copy_to_user_policy(struct xfrm_policy *xp, struct xfrm_userpolicy_info *p, int dir)\n {\n \tmemcpy(&p->sel, &xp->selector, sizeof(p->sel));\n \tmemcpy(&p->lft, &xp->lft, sizeof(p->lft));\n \tmemcpy(&p->curlft, &xp->curlft, sizeof(p->curlft));\n\tp->priority = xp->priority;\n\tp->index = xp->index;\n\tp->sel.family = xp->family;\n\tp->dir = dir;\n\tp->action = xp->action;\n\tp->flags = xp->flags;\n\tp->share = XFRM_SHARE_ANY; \n}", "target": 1}
{"code": "OMX_ERRORTYPE SimpleSoftOMXComponent::useBuffer(\n        OMX_BUFFERHEADERTYPE **header,\n        OMX_U32 portIndex,\n        OMX_PTR appPrivate,\n        OMX_U32 size,\n        OMX_U8 *ptr) {\n     Mutex::Autolock autoLock(mLock);\n     CHECK_LT(portIndex, mPorts.size());\n     *header = new OMX_BUFFERHEADERTYPE;\n     (*header)->nSize = sizeof(OMX_BUFFERHEADERTYPE);\n     (*header)->nVersion.s.nVersionMajor = 1;\n (*header)->nVersion.s.nVersionMinor = 0;\n (*header)->nVersion.s.nRevision = 0;\n (*header)->nVersion.s.nStep = 0;\n (*header)->pBuffer = ptr;\n (*header)->nAllocLen = size;\n (*header)->nFilledLen = 0;\n (*header)->nOffset = 0;\n (*header)->pAppPrivate = appPrivate;\n (*header)->pPlatformPrivate = NULL;\n (*header)->pInputPortPrivate = NULL;\n (*header)->pOutputPortPrivate = NULL;\n (*header)->hMarkTargetComponent = NULL;\n (*header)->pMarkData = NULL;\n (*header)->nTickCount = 0;\n (*header)->nTimeStamp = 0;\n (*header)->nFlags = 0;\n     (*header)->nOutputPortIndex = portIndex;\n     (*header)->nInputPortIndex = portIndex;\n    PortInfo *port = &mPorts.editItemAt(portIndex);\n     CHECK(mState == OMX_StateLoaded || port->mDef.bEnabled == OMX_FALSE);\n     CHECK_LT(port->mBuffers.size(), port->mDef.nBufferCountActual);\n    port->mBuffers.push();\n BufferInfo *buffer =\n &port->mBuffers.editItemAt(port->mBuffers.size() - 1);\n    buffer->mHeader = *header;\n    buffer->mOwnedByUs = false;\n if (port->mBuffers.size() == port->mDef.nBufferCountActual) {\n        port->mDef.bPopulated = OMX_TRUE;\n        checkTransitions();\n }\n return OMX_ErrorNone;\n}", "target": 1}
{"code": " void FrameView::updateLayoutAndStyleForPainting()\n {\n     RefPtr<FrameView> protector(this);\n     updateLayoutAndStyleIfNeededRecursive();\n     if (RenderView* view = renderView()) {\n         TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(\"devtools.timeline\"), \"UpdateLayerTree\", \"frame\", m_frame.get());\n        InspectorInstrumentation::willUpdateLayerTree(m_frame.get());\n        view->compositor()->updateIfNeededRecursive();\n        if (view->compositor()->inCompositingMode() && m_frame->isLocalRoot())\n            m_frame->page()->scrollingCoordinator()->updateAfterCompositingChangeIfNeeded();\n        updateCompositedSelectionBoundsIfNeeded();\n        InspectorInstrumentation::didUpdateLayerTree(m_frame.get());\n        invalidateTreeIfNeededRecursive();\n    }\n    scrollContentsIfNeededRecursive();\n    ASSERT(lifecycle().state() == DocumentLifecycle::PaintInvalidationClean);\n}", "target": 1}
{"code": "file_add_mapi_attrs (File* file, MAPI_Attr** attrs)\n{\n    int i;\n    for (i = 0; attrs[i]; i++)\n    {\n\tMAPI_Attr* a = attrs[i];\n\tif (a->num_values)\n\t{\n \t    switch (a->name)\n \t    {\n \t    case MAPI_ATTACH_LONG_FILENAME:\n \t\tif (file->name) XFREE(file->name);\n \t\tfile->name = strdup( (char*)a->values[0].data.buf );\n \t\tbreak;\n \t    case MAPI_ATTACH_DATA_OBJ:\n \t\tfile->len = a->values[0].len;\n \t\tif (file->data) XFREE (file->data);\n \t\tfile->data = CHECKED_XMALLOC (unsigned char, file->len);\n \t\tmemmove (file->data, a->values[0].data.buf, file->len);\n \t\tbreak;\n              case MAPI_ATTACH_MIME_TAG:\n \t\tif (file->mime_type) XFREE (file->mime_type);\n \t\tfile->mime_type = CHECKED_XMALLOC (char, a->values[0].len);\n \t\tmemmove (file->mime_type, a->values[0].data.buf, a->values[0].len);\n \t\tbreak;\n                 case MAPI_ATTACH_CONTENT_ID:\n                     if (file->content_id) XFREE(file->content_id);\n                     file->content_id = CHECKED_XMALLOC (char, a->values[0].len);\n                     memmove (file->content_id, a->values[0].data.buf, a->values[0].len);\n                    break;\n\t    default:\n\t\tbreak;\n\t    }\n\t}\n    }\n}", "target": 1}
{"code": "int ShellBrowserMain(const content::MainFunctionParams& parameters) {\n  bool layout_test_mode =\n      CommandLine::ForCurrentProcess()->HasSwitch(switches::kDumpRenderTree);\n  base::ScopedTempDir browser_context_path_for_layout_tests;\n  if (layout_test_mode) {\n    CHECK(browser_context_path_for_layout_tests.CreateUniqueTempDir());\n    CHECK(!browser_context_path_for_layout_tests.path().MaybeAsASCII().empty());\n    CommandLine::ForCurrentProcess()->AppendSwitchASCII(\n        switches::kContentShellDataPath,\n        browser_context_path_for_layout_tests.path().MaybeAsASCII());\n  }\n  scoped_ptr<content::BrowserMainRunner> main_runner_(\n      content::BrowserMainRunner::Create());\n  int exit_code = main_runner_->Initialize(parameters);\n  if (exit_code >= 0)\n    return exit_code;\n  if (CommandLine::ForCurrentProcess()->HasSwitch(\n        switches::kCheckLayoutTestSysDeps)) {\n    MessageLoop::current()->PostTask(FROM_HERE, MessageLoop::QuitClosure());\n    main_runner_->Run();\n    main_runner_->Shutdown();\n    return 0;\n  }\n  if (layout_test_mode) {\n    content::WebKitTestController test_controller;\n    std::string test_string;\n    CommandLine::StringVector args =\n        CommandLine::ForCurrentProcess()->GetArgs();\n    size_t command_line_position = 0;\n    bool ran_at_least_once = false;\n#if defined(OS_ANDROID)\n    std::cout << \"#READY\\n\";\n     std::cout.flush();\n #endif\n     while (GetNextTest(args, &command_line_position, &test_string)) {\n       if (test_string.empty())\n         continue;\n      if (test_string == \"QUIT\")\n        break;\n      bool enable_pixel_dumps;\n      std::string pixel_hash;\n      FilePath cwd;\n      GURL test_url = GetURLForLayoutTest(\n          test_string, &cwd, &enable_pixel_dumps, &pixel_hash);\n      if (!content::WebKitTestController::Get()->PrepareForLayoutTest(\n              test_url, cwd, enable_pixel_dumps, pixel_hash)) {\n        break;\n      }\n       ran_at_least_once = true;\n       main_runner_->Run();\n       if (!content::WebKitTestController::Get()->ResetAfterLayoutTest())\n         break;\n     }\n    if (!ran_at_least_once) {\n      MessageLoop::current()->PostTask(FROM_HERE, MessageLoop::QuitClosure());\n      main_runner_->Run();\n    }\n    exit_code = 0;\n  } else {\n    exit_code = main_runner_->Run();\n  }\n  main_runner_->Shutdown();\n  return exit_code;\n}", "target": 1}
{"code": "void UTFstring::UpdateFromUTF8()\n{\n  delete [] _Data;\n  size_t i;\n  for (_Length=0, i=0; i<UTF8string.length(); _Length++) {\n    uint8 lead = static_cast<uint8>(UTF8string[i]);\n    if (lead < 0x80)\n      i++;\n    else if ((lead >> 5) == 0x6)\n      i += 2;\n    else if ((lead >> 4) == 0xe)\n      i += 3;\n    else if ((lead >> 3) == 0x1e)\n      i += 4;\n    else\n      break;\n  }\n  _Data = new wchar_t[_Length+1];\n  size_t j;\n  for (j=0, i=0; i<UTF8string.length(); j++) {\n    uint8 lead = static_cast<uint8>(UTF8string[i]);\n    if (lead < 0x80) {\n      _Data[j] = lead;\n      i++;\n    } else if ((lead >> 5) == 0x6) {\n      _Data[j] = ((lead & 0x1F) << 6) + (UTF8string[i+1] & 0x3F);\n      i += 2;\n    } else if ((lead >> 4) == 0xe) {\n      _Data[j] = ((lead & 0x0F) << 12) + ((UTF8string[i+1] & 0x3F) << 6) + (UTF8string[i+2] & 0x3F);\n      i += 3;\n    } else if ((lead >> 3) == 0x1e) {\n      _Data[j] = ((lead & 0x07) << 18) + ((UTF8string[i+1] & 0x3F) << 12) + ((UTF8string[i+2] & 0x3F) << 6) + (UTF8string[i+3] & 0x3F);\n      i += 4;\n    } else\n      break;\n  }\n  _Data[j] = 0;\n}", "target": 1}
{"code": " pvscsi_ring_init_data(PVSCSIRingInfo *m, PVSCSICmdDescSetupRings *ri)\n {\n     int i;\n    uint32_t txr_len_log2, rxr_len_log2;\n     uint32_t req_ring_size, cmp_ring_size;\n     m->rs_pa = ri->ringsStatePPN << VMW_PAGE_SHIFT;\n    if ((ri->reqRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES)\n        || (ri->cmpRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES)) {\n        return -1;\n    }\n     req_ring_size = ri->reqRingNumPages * PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;\n     cmp_ring_size = ri->cmpRingNumPages * PVSCSI_MAX_NUM_CMP_ENTRIES_PER_PAGE;\n     txr_len_log2 = pvscsi_log2(req_ring_size - 1);\n    }", "target": 1}
{"code": "int main(int argc, const char *argv[])\n{\n\tstruct group *grent;\n\tconst char *cmd;\n\tconst char *path;\n\tint i;\n\tstruct passwd *pw;\n\tgrent = getgrnam(ABUILD_GROUP);\n\tif (grent == NULL)\n\t\terrx(1, \"%s: Group not found\", ABUILD_GROUP);\n\tchar *name = NULL;\n\tpw = getpwuid(getuid());\n\tif (pw)\n\t\tname = pw->pw_name;\n\tif (!is_in_group(grent->gr_gid)) {\n\t\terrx(1, \"User %s is not a member of group %s\\n\",\n\t\t\tname ? name : \"(unknown)\", ABUILD_GROUP);\n\t}\n\tif (name == NULL)\n\t\twarnx(\"Could not find username for uid %d\\n\", getuid());\n\tsetenv(\"USER\", name ?: \"\", 1);\n\tcmd = strrchr(argv[0], '/');\n\tif (cmd)\n\t\tcmd++;\n\telse\n\t\tcmd = argv[0];\n\tcmd = strchr(cmd, '-');\n\tif (cmd == NULL)\n\t\terrx(1, \"Calling command has no '-'\");\n\tcmd++;\n\tpath = get_command_path(cmd);\n\tif (path == NULL)\n\t\terrx(1, \"%s: Not a valid subcommand\", cmd);\n\tfor (i = 1; i < argc; i++)\n\t\tif (strcmp(argv[i], \"--allow-untrusted\") == 0)\n\t\t\terrx(1, \"%s: not allowed option\", \"--allow-untrusted\");\n\targv[0] = path;\n\tsetuid(0);\n\tsetgid(0);\n\texecv(path, (char * const*)argv);\n\tperror(path);\n\treturn 1;\n}", "target": 1}
{"code": "static unsigned int xdr_set_page_base(struct xdr_stream *xdr,\n\t\t\t\t      unsigned int base, unsigned int len)\n{\n\tunsigned int pgnr;\n\tunsigned int maxlen;\n\tunsigned int pgoff;\n\tunsigned int pgend;\n\tvoid *kaddr;\n\tmaxlen = xdr->buf->page_len;\n\tif (base >= maxlen) {\n\t\tbase = maxlen;\n\t\tmaxlen = 0;\n\t} else\n\t\tmaxlen -= base;\n\tif (len > maxlen)\n\t\tlen = maxlen;\n\txdr_stream_page_set_pos(xdr, base);\n\tbase += xdr->buf->page_base;\n\tpgnr = base >> PAGE_SHIFT;\n\txdr->page_ptr = &xdr->buf->pages[pgnr];\n\tkaddr = page_address(*xdr->page_ptr);\n\tpgoff = base & ~PAGE_MASK;\n\txdr->p = (__be32*)(kaddr + pgoff);\n\tpgend = pgoff + len;\n\tif (pgend > PAGE_SIZE)\n\t\tpgend = PAGE_SIZE;\n\txdr->end = (__be32*)(kaddr + pgend);\n\txdr->iov = NULL;\n\treturn len;\n}", "target": 1}
{"code": "static inline int object_custom(UNSERIALIZE_PARAMETER, zend_class_entry *ce)\n{\n\tlong datalen;\n\tdatalen = parse_iv2((*p) + 2, p);\n        (*p) += 2;\n       if (datalen < 0 || (*p) + datalen >= max) {\n                zend_error(E_WARNING, \"Insufficient data for unserializing - %ld required, %ld present\", datalen, (long)(max - (*p)));\n                return 0;\n        }\n\tif (ce->unserialize == NULL) {\n\t\tzend_error(E_WARNING, \"Class %s has no unserializer\", ce->name);\n\t\tobject_init_ex(*rval, ce);\n\t} else if (ce->unserialize(rval, ce, (const unsigned char*)*p, datalen, (zend_unserialize_data *)var_hash TSRMLS_CC) != SUCCESS) {\n\t\treturn 0;\n\t}\n\t(*p) += datalen;\n\treturn finish_nested_data(UNSERIALIZE_PASSTHRU);\n}", "target": 1}
{"code": "int gg_change_status_descr(struct gg_session *sess, int status, const char *descr)\n{\n\tstruct gg_new_status80 p;\n\tchar *gen_descr = NULL;\n\tint descr_len = 0;\n\tint res;\n\tgg_debug_session(sess, GG_DEBUG_FUNCTION, \"** gg_change_status_descr(%p, %d, \\\"%s\\\");\\n\", sess, status, descr);\n\tif (!sess) {\n\t\terrno = EFAULT;\n\t\treturn -1;\n\t}\n\tif (sess->state != GG_STATE_CONNECTED) {\n\t\terrno = ENOTCONN;\n\t\treturn -1;\n\t}\n\tsess->status = status;\n\tif (descr != NULL && sess->encoding != GG_ENCODING_UTF8) {\n\t\tdescr = gen_descr = gg_encoding_convert(descr, GG_ENCODING_CP1250, GG_ENCODING_UTF8, -1, -1);\n\t\tif (!gen_descr)\n\t\t\treturn -1;\n\t}\n\tif (descr) {\n\t\tdescr_len = strlen(descr);\n\t\tif (descr_len > GG_STATUS_DESCR_MAXSIZE)\n\t\t\tdescr_len = GG_STATUS_DESCR_MAXSIZE;\n\t} else {\n\t\tdescr = \"\";\n\t}\n\tp.status\t\t= gg_fix32(status);\n\tp.flags\t\t\t= gg_fix32(sess->status_flags);\n\tp.description_size\t= gg_fix32(descr_len);\n\tif (sess->protocol_version >= GG_PROTOCOL_110) {\n\t\tp.flags = gg_fix32(0x00000014);\n\t\tdescr_len++; \n\t}\n\tres = gg_send_packet(sess, GG_NEW_STATUS80, \n\t\t\t&p, sizeof(p), \n\t\t\tdescr, descr_len,\n\t\t\tNULL);\n\tfree(gen_descr);\n\tif (GG_S_NA(status)) {\n\t\tsess->state = GG_STATE_DISCONNECTING;\n\t\tsess->timeout = GG_TIMEOUT_DISCONNECT;\n\t}\n\treturn res;\n}", "target": 1}
{"code": "static int l2cap_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)\n{\n\tstruct sockaddr_l2 *la = (struct sockaddr_l2 *) addr;\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n \tBT_DBG(\"sock %p, sk %p\", sock, sk);\n \taddr->sa_family = AF_BLUETOOTH;\n \t*len = sizeof(struct sockaddr_l2);\n\tif (peer) {\n\t\tla->l2_psm = chan->psm;\n\t\tbacpy(&la->l2_bdaddr, &bt_sk(sk)->dst);\n\t\tla->l2_cid = cpu_to_le16(chan->dcid);\n\t} else {\n\t\tla->l2_psm = chan->sport;\n\t\tbacpy(&la->l2_bdaddr, &bt_sk(sk)->src);\n\t\tla->l2_cid = cpu_to_le16(chan->scid);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int multipart_buffer_headers(multipart_buffer *self, zend_llist *header TSRMLS_DC)\n{\n\tchar *line;\n\tmime_header_entry prev_entry = {0}, entry;\n\tint prev_len, cur_len;\n\tif (!find_boundary(self, self->boundary TSRMLS_CC)) {\n\t\treturn 0;\n\t}\n\twhile( (line = get_line(self TSRMLS_CC)) && strlen(line) > 0 )\n\t{\n\t\tchar *key = line;\n\t\tchar *value = NULL;\n\t\tif (php_rfc1867_encoding_translation(TSRMLS_C)) {\n\t\t\tself->input_encoding = zend_multibyte_encoding_detector(line, strlen(line), self->detect_order, self->detect_order_size TSRMLS_CC);\n\t\t}\n\t\tif (!isspace(line[0])) {\n\t\t\tvalue = strchr(line, ':');\n\t\t}\n\t\tif (value) {\n\t\t\t*value = 0;\n\t\t\tdo { value++; } while(isspace(*value));\n\t\t\tentry.value = estrdup(value);\n\t\t\tentry.key = estrdup(key);\n\t\t} else if (zend_llist_count(header)) { \n\t\t\tprev_len = strlen(prev_entry.value);\n\t\t\tcur_len = strlen(line);\n\t\t\tentry.value = emalloc(prev_len + cur_len + 1);\n\t\t\tmemcpy(entry.value, prev_entry.value, prev_len);\n\t\t\tmemcpy(entry.value + prev_len, line, cur_len);\n\t\t\tentry.value[cur_len + prev_len] = '\\0';\n\t\t\tentry.key = estrdup(prev_entry.key);\n\t\t\tzend_llist_remove_tail(header);\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tzend_llist_add_element(header, &entry);\n\t\tprev_entry = entry;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "static void ip6_append_data_mtu(int *mtu,\n \t\t\t\tint *maxfraglen,\n \t\t\t\tunsigned int fragheaderlen,\n \t\t\t\tstruct sk_buff *skb,\n\t\t\t\tstruct rt6_info *rt)\n {\n \tif (!(rt->dst.flags & DST_XFRM_TUNNEL)) {\n \t\tif (skb == NULL) {\n\t\t\t*mtu = *mtu - rt->dst.header_len;\n\t\t} else {\n\t\t\t*mtu = dst_mtu(rt->dst.path);\n \t\t}\n \t\t*maxfraglen = ((*mtu - fragheaderlen) & ~7)\n \t\t\t      + fragheaderlen - sizeof(struct frag_hdr);\n\t}\n}", "target": 1}
{"code": "static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)\n{\n        uint8* bufp = buf;\n        int32  bytes_read = 0;\n        uint32 strip, nstrips   = TIFFNumberOfStrips(in);\n        uint32 stripsize = TIFFStripSize(in);\n        uint32 rows = 0;\n        uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n        tsize_t scanline_size = TIFFScanlineSize(in);\n        if (scanline_size == 0) {\n                TIFFError(\"\", \"TIFF scanline size is zero!\");    \n                return 0;\n        }\n        for (strip = 0; strip < nstrips; strip++) {\n                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);\n                rows = bytes_read / scanline_size;\n                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))\n                        TIFFError(\"\", \"Strip %d: read %lu bytes, strip size %lu\",\n                                  (int)strip + 1, (unsigned long) bytes_read,\n                                  (unsigned long)stripsize);\n                if (bytes_read < 0 && !ignore) {\n                        TIFFError(\"\", \"Error reading strip %lu after %lu rows\",\n                                   (unsigned long) strip, (unsigned long)rows);\n                         return 0;\n                 }\n                bufp += bytes_read;\n         }\n         return 1;\n} ", "target": 1}
{"code": "static void xhci_kick_ep(XHCIState *xhci, unsigned int slotid,\n                         unsigned int epid, unsigned int streamid)\n{\n    XHCIEPContext *epctx;\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n    assert(epid >= 1 && epid <= 31);\n    if (!xhci->slots[slotid-1].enabled) {\n        DPRINTF(\"xhci: xhci_kick_ep for disabled slot %d\\n\", slotid);\n        return;\n    }\n    epctx = xhci->slots[slotid-1].eps[epid-1];\n    if (!epctx) {\n        DPRINTF(\"xhci: xhci_kick_ep for disabled endpoint %d,%d\\n\",\n                epid, slotid);\n        return;\n         return;\n     }\n     xhci_kick_epctx(epctx, streamid);\n }", "target": 1}
{"code": "int st21nfca_connectivity_event_received(struct nfc_hci_dev *hdev, u8 host,\n\t\t\t\tu8 event, struct sk_buff *skb)\n{\n\tint r = 0;\n\tstruct device *dev = &hdev->ndev->dev;\n\tstruct nfc_evt_transaction *transaction;\n\tpr_debug(\"connectivity gate event: %x\\n\", event);\n\tswitch (event) {\n\tcase ST21NFCA_EVT_CONNECTIVITY:\n\t\tr = nfc_se_connectivity(hdev->ndev, host);\n\tbreak;\n\tcase ST21NFCA_EVT_TRANSACTION:\n\t\tif (skb->len < NFC_MIN_AID_LENGTH + 2 &&\n\t\t    skb->data[0] != NFC_EVT_TRANSACTION_AID_TAG)\n\t\t\treturn -EPROTO;\n\t\ttransaction = devm_kzalloc(dev, skb->len - 2, GFP_KERNEL);\n\t\tif (!transaction)\n\t\t\treturn -ENOMEM;\n\t\ttransaction->aid_len = skb->data[1];\n\t\tmemcpy(transaction->aid, &skb->data[2],\n\t\t       transaction->aid_len);\n\t\tif (skb->data[transaction->aid_len + 2] !=\n\t\t    NFC_EVT_TRANSACTION_PARAMS_TAG)\n\t\t\treturn -EPROTO;\n\t\ttransaction->params_len = skb->data[transaction->aid_len + 3];\n\t\tmemcpy(transaction->params, skb->data +\n\t\t       transaction->aid_len + 4, transaction->params_len);\n\t\tr = nfc_se_transaction(hdev->ndev, host, transaction);\n\tbreak;\n\tdefault:\n\t\tnfc_err(&hdev->ndev->dev, \"Unexpected event on connectivity gate\\n\");\n\t\treturn 1;\n\t}\n\tkfree_skb(skb);\n\treturn r;\n}", "target": 1}
{"code": "CString CWebSock::GetSkinPath(const CString& sSkinName) {\n    CString sRet = CZNC::Get().GetZNCPath() + \"/webskins/\" + sSkinName;\n    if (!CFile::IsDir(sRet)) {\n        sRet = CZNC::Get().GetCurPath() + \"/webskins/\" + sSkinName;\n        if (!CFile::IsDir(sRet)) {\n            sRet = CString(_SKINDIR_) + \"/\" + sSkinName;\n        }\n    }\n    return sRet + \"/\";\n}", "target": 1}
{"code": "static inline int get_len(LZOContext *c, int x, int mask)\n{\n    int cnt = x & mask;\n    if (!cnt) {\n        while (!(x = get_byte(c)))\n            cnt += 255;\n        cnt += mask + x;\n    }\n    return cnt;\n}", "target": 1}
{"code": " static int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n {\n\tstruct trusted_key_payload *p = key->payload.data[0];\n \tstruct trusted_key_payload *new_p;\n \tstruct trusted_key_options *new_o;\n \tsize_t datalen = prep->datalen;\n \tchar *datablob;\n \tint ret = 0;\n \tif (!p->migratable)\n \t\treturn -EPERM;\n \tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tnew_o = trusted_options_alloc();\n\tif (!new_o) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tnew_p = trusted_payload_alloc(key);\n\tif (!new_p) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmemcpy(datablob, prep->data, datalen);\n\tdatablob[datalen] = '\\0';\n\tret = datablob_parse(datablob, new_p, new_o);\n\tif (ret != Opt_update) {\n\t\tret = -EINVAL;\n\t\tkfree(new_p);\n\t\tgoto out;\n\t}\n\tif (!new_o->keyhandle) {\n\t\tret = -EINVAL;\n\t\tkfree(new_p);\n\t\tgoto out;\n\t}\n\tnew_p->migratable = p->migratable;\n\tnew_p->key_len = p->key_len;\n\tmemcpy(new_p->key, p->key, p->key_len);\n\tdump_payload(p);\n\tdump_payload(new_p);\n\tret = key_seal(new_p, new_o);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: key_seal failed (%d)\\n\", ret);\n\t\tkfree(new_p);\n\t\tgoto out;\n\t}\n\tif (new_o->pcrlock) {\n\t\tret = pcrlock(new_o->pcrlock);\n\t\tif (ret < 0) {\n\t\t\tpr_info(\"trusted_key: pcrlock failed (%d)\\n\", ret);\n\t\t\tkfree(new_p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\trcu_assign_keypointer(key, new_p);\n\tcall_rcu(&p->rcu, trusted_rcu_free);\nout:\n\tkfree(datablob);\n\tkfree(new_o);\n\treturn ret;\n}", "target": 1}
{"code": "static int adts_decode_extradata(AVFormatContext *s, ADTSContext *adts, const uint8_t *buf, int size)\n{\n    GetBitContext gb;\n    PutBitContext pb;\n    MPEG4AudioConfig m4ac;\n    int off;\n    init_get_bits(&gb, buf, size * 8);\n    off = avpriv_mpeg4audio_get_config2(&m4ac, buf, size, 1, s);\n    if (off < 0)\n        return off;\n    skip_bits_long(&gb, off);\n    adts->objecttype        = m4ac.object_type - 1;\n    adts->sample_rate_index = m4ac.sampling_index;\n    adts->channel_conf      = m4ac.chan_config;\n    if (adts->objecttype > 3U) {\n        av_log(s, AV_LOG_ERROR, \"MPEG-4 AOT %d is not allowed in ADTS\\n\", adts->objecttype+1);\n        return AVERROR_INVALIDDATA;\n    }\n    if (adts->sample_rate_index == 15) {\n        av_log(s, AV_LOG_ERROR, \"Escape sample rate index illegal in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"960/120 MDCT window is not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"Scalable configurations are not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"Extension flag is not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (!adts->channel_conf) {\n        init_put_bits(&pb, adts->pce_data, MAX_PCE_SIZE);\n        put_bits(&pb, 3, 5); \n        adts->pce_size = (ff_copy_pce_data(&pb, &gb) + 3) / 8;\n        flush_put_bits(&pb);\n    }\n    adts->write_adts = 1;\n    return 0;\n}", "target": 1}
{"code": "static void decode_data(struct sixpack *sp, unsigned char inbyte)\n{\n\tunsigned char *buf;\n\tif (sp->rx_count != 3) {\n\t\tsp->raw_buf[sp->rx_count++] = inbyte;\n\t\treturn;\n\t}\n\tbuf = sp->raw_buf;\n\tsp->cooked_buf[sp->rx_count_cooked++] =\n\t\tbuf[0] | ((buf[1] << 2) & 0xc0);\n\tsp->cooked_buf[sp->rx_count_cooked++] =\n\t\t(buf[1] & 0x0f) | ((buf[2] << 2) & 0xf0);\n\tsp->cooked_buf[sp->rx_count_cooked++] =\n\t\t(buf[2] & 0x03) | (inbyte << 2);\n\tsp->rx_count = 0;\n}", "target": 1}
{"code": "calculateNumTiles (int *numTiles,\n\t\t   int numLevels,\n\t\t   int min, int max,\n\t\t   int size,\n\t\t   LevelRoundingMode rmode)\n{\n    for (int i = 0; i < numLevels; i++)\n    {\n        int l = levelSize (min, max, i, rmode);\n        if (l > std::numeric_limits<int>::max() - size + 1)\n            throw IEX_NAMESPACE::ArgExc (\"Invalid size.\");\n        numTiles[i] = (l + size - 1) / size;\n    }\n}", "target": 1}
{"code": " void EnsureInitializeForAndroidLayoutTests() {\n  CHECK(CommandLine::ForCurrentProcess()->HasSwitch(switches::kDumpRenderTree));\n   JNIEnv* env = base::android::AttachCurrentThread();\n   content::NestedMessagePumpAndroid::RegisterJni(env);\n   content::RegisterNativesImpl(env);\n  bool success = base::MessageLoop::InitMessagePumpForUIFactory(\n      &CreateMessagePumpForUI);\n  CHECK(success) << \"Unable to initialize the message pump for Android.\";\n  base::FilePath files_dir(GetTestFilesDirectory(env));\n  base::FilePath stdout_fifo(files_dir.Append(FILE_PATH_LITERAL(\"test.fifo\")));\n  EnsureCreateFIFO(stdout_fifo);\n  base::FilePath stderr_fifo(\n      files_dir.Append(FILE_PATH_LITERAL(\"stderr.fifo\")));\n  EnsureCreateFIFO(stderr_fifo);\n  base::FilePath stdin_fifo(files_dir.Append(FILE_PATH_LITERAL(\"stdin.fifo\")));\n  EnsureCreateFIFO(stdin_fifo);\n  success = base::android::RedirectStream(stdout, stdout_fifo, \"w\") &&\n            base::android::RedirectStream(stdin, stdin_fifo, \"r\") &&\n            base::android::RedirectStream(stderr, stderr_fifo, \"w\");\n  CHECK(success) << \"Unable to initialize the Android FIFOs.\";\n}", "target": 1}
{"code": "TIFFReadEncodedStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size)\n{\n\tstatic const char module[] = \"TIFFReadEncodedStrip\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 rowsperstrip;\n\tuint32 stripsperplane;\n\tuint32 stripinplane;\n\tuint16 plane;\n\tuint32 rows;\n\ttmsize_t stripsize;\n\tif (!TIFFCheckRead(tif,0))\n\t\treturn((tmsize_t)(-1));\n\tif (strip>=td->td_nstrips)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t    \"%lu: Strip out of range, max %lu\",(unsigned long)strip,\n\t\t    (unsigned long)td->td_nstrips);\n\t\treturn((tmsize_t)(-1));\n\t}\n \trowsperstrip=td->td_rowsperstrip;\n \tif (rowsperstrip>td->td_imagelength)\n \t\trowsperstrip=td->td_imagelength;\n\tstripsperplane=((td->td_imagelength+rowsperstrip-1)/rowsperstrip);\n \tstripinplane=(strip%stripsperplane);\n \tplane=(uint16)(strip/stripsperplane);\n \trows=td->td_imagelength-stripinplane*rowsperstrip;\n\tif (rows>rowsperstrip)\n\t\trows=rowsperstrip;\n\tstripsize=TIFFVStripSize(tif,rows);\n\tif (stripsize==0)\n\t\treturn((tmsize_t)(-1));\n    if( td->td_compression == COMPRESSION_NONE &&\n        size!=(tmsize_t)(-1) && size >= stripsize &&\n        !isMapped(tif) &&\n        ((tif->tif_flags&TIFF_NOREADRAW)==0) )\n    {\n        if (TIFFReadRawStrip1(tif, strip, buf, stripsize, module) != stripsize)\n            return ((tmsize_t)(-1));\n        if (!isFillOrder(tif, td->td_fillorder) &&\n            (tif->tif_flags & TIFF_NOBITREV) == 0)\n            TIFFReverseBits(buf,stripsize);\n        (*tif->tif_postdecode)(tif,buf,stripsize);\n        return (stripsize);\n    }\n\tif ((size!=(tmsize_t)(-1))&&(size<stripsize))\n\t\tstripsize=size;\n\tif (!TIFFFillStrip(tif,strip))\n\t\treturn((tmsize_t)(-1));\n\tif ((*tif->tif_decodestrip)(tif,buf,stripsize,plane)<=0)\n\t\treturn((tmsize_t)(-1));\n\t(*tif->tif_postdecode)(tif,buf,stripsize);\n\treturn(stripsize);\n}", "target": 1}
{"code": " static void tokenadd(struct jv_parser* p, char c) {\n   assert(p->tokenpos <= p->tokenlen);\n  if (p->tokenpos == p->tokenlen) {\n     p->tokenlen = p->tokenlen*2 + 256;\n     p->tokenbuf = jv_mem_realloc(p->tokenbuf, p->tokenlen);\n   }\n  assert(p->tokenpos < p->tokenlen);\n  p->tokenbuf[p->tokenpos++] = c;\n}", "target": 1}
{"code": " mrb_class_real(struct RClass* cl)\n {\n  if (cl == 0)\n    return NULL;\n   while ((cl->tt == MRB_TT_SCLASS) || (cl->tt == MRB_TT_ICLASS)) {\n     cl = cl->super;\n   }\n   return cl;\n }", "target": 1}
{"code": " static int rename_in_ns(int pid, char *oldname, char **newnamep)\n {\n\tint fd = -1, ofd = -1, ret, ifindex = -1;\n \tbool grab_newname = false;\n \tofd = lxc_preserve_ns(getpid(), \"net\");\n \tif (ofd < 0) {\n\t\tfprintf(stderr, \"Failed opening network namespace path for '%d'.\", getpid());\n\t\treturn -1;\n \t}\n \tfd = lxc_preserve_ns(pid, \"net\");\n \tif (fd < 0) {\n\t\tfprintf(stderr, \"Failed opening network namespace path for '%d'.\", pid);\n\t\treturn -1;\n \t}\n\tif (setns(fd, 0) < 0) {\n\t\tfprintf(stderr, \"setns to container network namespace\\n\");\n\t\tgoto out_err;\n \t}\n\tclose(fd); fd = -1;\n \tif (!*newnamep) {\n \t\tgrab_newname = true;\n \t\t*newnamep = VETH_DEF_NAME;\n\t\tif (!(ifindex = if_nametoindex(oldname))) {\n\t\t\tfprintf(stderr, \"failed to get netdev index\\n\");\n\t\t\tgoto out_err;\n \t\t}\n \t}\n\tif ((ret = lxc_netdev_rename_by_name(oldname, *newnamep)) < 0) {\n\t\tfprintf(stderr, \"Error %d renaming netdev %s to %s in container\\n\", ret, oldname, *newnamep);\n\t\tgoto out_err;\n \t}\n \tif (grab_newname) {\n\t\tchar ifname[IFNAMSIZ], *namep = ifname;\n \t\tif (!if_indextoname(ifindex, namep)) {\n\t\t\tfprintf(stderr, \"Failed to get new netdev name\\n\");\n\t\t\tgoto out_err;\n \t\t}\n \t\t*newnamep = strdup(namep);\n \t\tif (!*newnamep)\n\t\t\tgoto out_err;\n \t}\n\tif (setns(ofd, 0) < 0) {\n\t\tfprintf(stderr, \"Error returning to original netns\\n\");\n\t\tclose(ofd);\n\t\treturn -1;\n \t}\n\tclose(ofd);\n\treturn 0;\nout_err:\n\tif (ofd >= 0)\n\t\tclose(ofd);\n\tif (setns(ofd, 0) < 0)\n\t\tfprintf(stderr, \"Error returning to original network namespace\\n\");\n \tif (fd >= 0)\n \t\tclose(fd);\n\treturn -1;\n }", "target": 1}
{"code": "im_vips2dz( IMAGE *in, const char *filename )\n{\n\tchar *p, *q;\n\tchar name[FILENAME_MAX];\n\tchar mode[FILENAME_MAX];\n\tchar buf[FILENAME_MAX];\n\tint i;\n\tVipsForeignDzLayout layout = VIPS_FOREIGN_DZ_LAYOUT_DZ; \n\tchar *suffix = \".jpeg\";\n\tint overlap = 0;\n\tint tile_size = 256;\n\tVipsForeignDzDepth depth = VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL; \n\tgboolean centre = FALSE;\n\tVipsAngle angle = VIPS_ANGLE_D0; \n\tim_strncpy( name, filename, FILENAME_MAX ); \n\tif( (p = strchr( name, ':' )) ) {\n\t\t*p = '\\0';\n\t\tim_strncpy( mode, p + 1, FILENAME_MAX ); \n\t}\n\tstrcpy( buf, mode ); \n\tp = &buf[0];\n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( (i = vips_enum_from_nick( \"im_vips2dz\", \n\t\t\tVIPS_TYPE_FOREIGN_DZ_LAYOUT, q )) < 0 ) \n\t\t\treturn( -1 );\n\t\tlayout = i;\n\t}\n\tif( (q = im_getnextoption( &p )) ) \n\t\tsuffix = g_strdup( q );\n\tif( (q = im_getnextoption( &p )) ) \n\t\toverlap = atoi( q ); \n\tif( (q = im_getnextoption( &p )) ) \n\t\ttile_size = atoi( q ); \n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( (i = vips_enum_from_nick( \"im_vips2dz\", \n\t\t\tVIPS_TYPE_FOREIGN_DZ_DEPTH, q )) < 0 )\n\t\t\treturn( -1 );\n\t\tdepth = i;\n\t}\n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( im_isprefix( \"cen\", q ) ) \n\t\t\tcentre = TRUE;\n\t}\n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( (i = vips_enum_from_nick( \"im_vips2dz\", \n\t\t\tVIPS_TYPE_ANGLE, q )) < 0 )\n\t\t\treturn( -1 );\n\t\tangle = i;\n\t}\n\tif( vips_dzsave( in, name,\n\t\t\"layout\", layout,\n\t\t\"suffix\", suffix,\n\t\t\"overlap\", overlap,\n\t\t\"tile_size\", tile_size,\n\t\t\"depth\", depth,\n\t\t\"centre\", centre,\n\t\t\"angle\", angle,\n\t\tNULL ) )\n\t\treturn( -1 );\n\treturn( 0 );\n}", "target": 1}
{"code": "filter_session_io(struct io *io, int evt, void *arg)\n{\n\tstruct filter_session *fs = arg;\n\tchar *line = NULL;\n\tssize_t len;\n\tlog_trace(TRACE_IO, \"filter session: %p: %s %s\", fs, io_strevent(evt),\n\t    io_strio(io));\n\tswitch (evt) {\n\tcase IO_DATAIN:\n\tnextline:\n\t\tline = io_getline(fs->io, &len);\n\t\tif (line == NULL)\n\t\t\treturn;\n\t\tfilter_data(fs->id, line);\n\t\tgoto nextline;\n\tcase IO_DISCONNECTED:\n\t\tio_free(fs->io);\n\t\tfs->io = NULL;\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": " static void make_response(struct xen_blkif_ring *ring, u64 id,\n \t\t\t  unsigned short op, int st)\n {\n\tstruct blkif_response  resp;\n \tunsigned long     flags;\n \tunion blkif_back_rings *blk_rings;\n \tint notify;\n\tresp.id        = id;\n\tresp.operation = op;\n\tresp.status    = st;\n \tspin_lock_irqsave(&ring->blk_ring_lock, flags);\n \tblk_rings = &ring->blk_rings;\n \tswitch (ring->blkif->blk_protocol) {\n \tcase BLKIF_PROTOCOL_NATIVE:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->native, blk_rings->native.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n \t\tbreak;\n \tcase BLKIF_PROTOCOL_X86_32:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->x86_32, blk_rings->x86_32.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n \t\tbreak;\n \tcase BLKIF_PROTOCOL_X86_64:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->x86_64, blk_rings->x86_64.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n \t\tbreak;\n \tdefault:\n \t\tBUG();\n \t}\n \tblk_rings->common.rsp_prod_pvt++;\n \tRING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);\n \tspin_unlock_irqrestore(&ring->blk_ring_lock, flags);\n\tif (notify)\n\t\tnotify_remote_via_irq(ring->irq);\n}", "target": 1}
{"code": " asmlinkage void bad_mode(struct pt_regs *regs, int reason, unsigned int esr)\n {\n \tconsole_verbose();\n \tpr_crit(\"Bad mode in %s handler detected, code 0x%08x\\n\",\n \t\thandler[reason], esr);\n\tdie(\"Oops - bad mode\", regs, 0);\n\tlocal_irq_disable();\n\tpanic(\"bad mode\");\n }", "target": 1}
{"code": "static ssize_t qrtr_tun_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct qrtr_tun *tun = filp->private_data;\n\tsize_t len = iov_iter_count(from);\n\tssize_t ret;\n\tvoid *kbuf;\n\tkbuf = kzalloc(len, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\tif (!copy_from_iter_full(kbuf, len, from))\n\t\treturn -EFAULT;\n\tret = qrtr_endpoint_post(&tun->ep, kbuf, len);\n\treturn ret < 0 ? ret : len;\n}", "target": 1}
{"code": " static TEE_Result set_rmem_param(const struct optee_msg_param_rmem *rmem,\n \t\t\t\t struct param_mem *mem)\n {\n \tuint64_t shm_ref = READ_ONCE(rmem->shm_ref);\n \tmem->mobj = mobj_reg_shm_get_by_cookie(shm_ref);\n\tif (!mem->mobj)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n \tmem->offs = READ_ONCE(rmem->offs);\n \tmem->size = READ_ONCE(rmem->size);\n \treturn TEE_SUCCESS;\n }", "target": 1}
{"code": "static int putreg(struct task_struct *child,\n\tunsigned long regno, unsigned long value)\n{\n\tunsigned long tmp; \n\tif (test_tsk_thread_flag(child, TIF_IA32))\n\t\tvalue &= 0xffffffff;\n\tswitch (regno) {\n\t\tcase offsetof(struct user_regs_struct,fs):\n\t\t\tif (value && (value & 3) != 3)\n\t\t\t\treturn -EIO;\n\t\t\tchild->thread.fsindex = value & 0xffff; \n\t\t\treturn 0;\n\t\tcase offsetof(struct user_regs_struct,gs):\n\t\t\tif (value && (value & 3) != 3)\n\t\t\t\treturn -EIO;\n\t\t\tchild->thread.gsindex = value & 0xffff;\n\t\t\treturn 0;\n\t\tcase offsetof(struct user_regs_struct,ds):\n\t\t\tif (value && (value & 3) != 3)\n\t\t\t\treturn -EIO;\n\t\t\tchild->thread.ds = value & 0xffff;\n\t\t\treturn 0;\n\t\tcase offsetof(struct user_regs_struct,es): \n\t\t\tif (value && (value & 3) != 3)\n\t\t\t\treturn -EIO;\n\t\t\tchild->thread.es = value & 0xffff;\n\t\t\treturn 0;\n\t\tcase offsetof(struct user_regs_struct,ss):\n\t\t\tif ((value & 3) != 3)\n\t\t\t\treturn -EIO;\n\t\t\tvalue &= 0xffff;\n\t\t\treturn 0;\n\t\tcase offsetof(struct user_regs_struct,fs_base):\n\t\t\tif (value >= TASK_SIZE_OF(child))\n\t\t\t\treturn -EIO;\n\t\t\tchild->thread.fs = value;\n\t\t\treturn 0;\n\t\tcase offsetof(struct user_regs_struct,gs_base):\n\t\t\tif (value >= TASK_SIZE_OF(child))\n\t\t\t\treturn -EIO;\n\t\t\tchild->thread.gs = value;\n\t\t\treturn 0;\n\t\tcase offsetof(struct user_regs_struct, eflags):\n\t\t\tvalue &= FLAG_MASK;\n\t\t\ttmp = get_stack_long(child, EFL_OFFSET); \n\t\t\ttmp &= ~FLAG_MASK; \n\t\t\tvalue |= tmp;\n\t\t\tbreak;\n\t\tcase offsetof(struct user_regs_struct,cs): \n\t\t\tif ((value & 3) != 3)\n\t\t\t\treturn -EIO;\n\t\t\tvalue &= 0xffff;\n\t\t\tbreak;\n\t}\n\tput_stack_long(child, regno - sizeof(struct pt_regs), value);\n\treturn 0;\n}", "target": 1}
{"code": "static void kiocb_batch_free(struct kiocb_batch *batch)\n {\n \tstruct kiocb *req, *n;\n \tlist_for_each_entry_safe(req, n, &batch->head, ki_batch) {\n \t\tlist_del(&req->ki_batch);\n \t\tkmem_cache_free(kiocb_cachep, req);\n \t}\n }", "target": 1}
{"code": "static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)\n {\n         uint8* bufp = buf;\n         int32  bytes_read = 0;\n        uint16 strip, nstrips   = TIFFNumberOfStrips(in);\n         uint32 stripsize = TIFFStripSize(in);\n         uint32 rows = 0;\n         uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n        tsize_t scanline_size = TIFFScanlineSize(in);\n        if (scanline_size == 0) {\n                TIFFError(\"\", \"TIFF scanline size is zero!\");    \n                return 0;\n        }\n        for (strip = 0; strip < nstrips; strip++) {\n                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);\n                rows = bytes_read / scanline_size;\n                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))\n                        TIFFError(\"\", \"Strip %d: read %lu bytes, strip size %lu\",\n                                  (int)strip + 1, (unsigned long) bytes_read,\n                                  (unsigned long)stripsize);\n                if (bytes_read < 0 && !ignore) {\n                        TIFFError(\"\", \"Error reading strip %lu after %lu rows\",\n                                  (unsigned long) strip, (unsigned long)rows);\n                        return 0;\n                }\n                bufp += bytes_read;\n        }\n        return 1;\n} ", "target": 1}
{"code": "static int inet6_fill_prefix(struct sk_buff *skb, struct inet6_dev *idev,\n\t\t\tstruct prefix_info *pinfo, u32 pid, u32 seq, \n\t\t\tint event, unsigned int flags)\n{\n\tstruct prefixmsg\t*pmsg;\n\tstruct nlmsghdr \t*nlh;\n\tunsigned char\t\t*b = skb->tail;\n\tstruct prefix_cacheinfo\tci;\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*pmsg), flags);\n\tpmsg = NLMSG_DATA(nlh);\n\tpmsg->prefix_family = AF_INET6;\n\tpmsg->prefix_ifindex = idev->dev->ifindex;\n\tpmsg->prefix_len = pinfo->prefix_len;\n\tpmsg->prefix_type = pinfo->type;\n\tpmsg->prefix_flags = 0;\n\tif (pinfo->onlink)\n\t\tpmsg->prefix_flags |= IF_PREFIX_ONLINK;\n\tif (pinfo->autoconf)\n\t\tpmsg->prefix_flags |= IF_PREFIX_AUTOCONF;\n\tRTA_PUT(skb, PREFIX_ADDRESS, sizeof(pinfo->prefix), &pinfo->prefix);\n\tci.preferred_time = ntohl(pinfo->prefered);\n\tci.valid_time = ntohl(pinfo->valid);\n\tRTA_PUT(skb, PREFIX_CACHEINFO, sizeof(ci), &ci);\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\nnlmsg_failure:\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1}
{"code": "static struct property *dlpar_parse_cc_property(struct cc_workarea *ccwa)\n{\n\tstruct property *prop;\n\tchar *name;\n\tchar *value;\n\tprop = kzalloc(sizeof(*prop), GFP_KERNEL);\n\tif (!prop)\n\t\treturn NULL;\n\tname = (char *)ccwa + be32_to_cpu(ccwa->name_offset);\n\tprop->name = kstrdup(name, GFP_KERNEL);\n\tprop->length = be32_to_cpu(ccwa->prop_length);\n\tvalue = (char *)ccwa + be32_to_cpu(ccwa->prop_offset);\n\tprop->value = kmemdup(value, prop->length, GFP_KERNEL);\n\tif (!prop->value) {\n\t\tdlpar_free_cc_property(prop);\n\t\treturn NULL;\n\t}\n\treturn prop;\n}", "target": 1}
{"code": "static MagickBooleanType TIFFGetProfiles(TIFF *tiff,Image *image,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n  uint32\n    length = 0;\n  unsigned char\n    *profile = (unsigned char *) NULL;\n  status=MagickTrue;\n#if defined(TIFFTAG_ICCPROFILE)\n  if ((TIFFGetField(tiff,TIFFTAG_ICCPROFILE,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    status=ReadProfile(image,\"icc\",profile,(ssize_t) length,exception);\n#endif\n#if defined(TIFFTAG_PHOTOSHOP)\n  if ((TIFFGetField(tiff,TIFFTAG_PHOTOSHOP,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    status=ReadProfile(image,\"8bim\",profile,(ssize_t) length,exception);\n#endif\n#if defined(TIFFTAG_RICHTIFFIPTC)\n  if ((TIFFGetField(tiff,TIFFTAG_RICHTIFFIPTC,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    {\n      if (TIFFIsByteSwapped(tiff) != 0)\n        TIFFSwabArrayOfLong((uint32 *) profile,(size_t) length);\n      status=ReadProfile(image,\"iptc\",profile,4L*length,exception);\n    }\n#endif\n#if defined(TIFFTAG_XMLPACKET)\n  if ((TIFFGetField(tiff,TIFFTAG_XMLPACKET,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    {\n      StringInfo\n        *dng;\n      status=ReadProfile(image,\"xmp\",profile,(ssize_t) length,exception);\n      dng=BlobToStringInfo(profile,length);\n      if (dng != (StringInfo *) NULL)\n        {\n          const char\n            *target = \"dc:format=\\\"image/dng\\\"\";\n          if (strstr((char *) GetStringInfoDatum(dng),target) != (char *) NULL)\n            (void) CopyMagickString(image->magick,\"DNG\",MagickPathExtent);\n          dng=DestroyStringInfo(dng);\n        }\n    }\n#endif\n  if ((TIFFGetField(tiff,34118,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    status=ReadProfile(image,\"tiff:34118\",profile,(ssize_t) length,\n      exception);\n  if ((TIFFGetField(tiff,37724,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    status=ReadProfile(image,\"tiff:37724\",profile,(ssize_t) length,exception);\n  return(status);\n}", "target": 1}
{"code": "void TableLookUp::setTable(int ntable, const std::vector<ushort16>& table) {\n  assert(!table.empty());\n  const int nfilled = table.size();\n  if (ntable > ntables) {\n    ThrowRDE(\"Table lookup with number greater than number of tables.\");\n  }\n  ushort16* t = &tables[ntable * TABLE_SIZE];\n  if (!dither) {\n    for (int i = 0; i < 65536; i++) {\n      t[i] = (i < nfilled) ? table[i] : table[nfilled - 1];\n    }\n    return;\n  }\n  for (int i = 0; i < nfilled; i++) {\n    int center = table[i];\n    int lower = i > 0 ? table[i - 1] : center;\n    int upper = i < (nfilled - 1) ? table[i + 1] : center;\n    int delta = upper - lower;\n    t[i * 2] = center - ((upper - lower + 2) / 4);\n    t[i * 2 + 1] = delta;\n  }\n  for (int i = nfilled; i < 65536; i++) {\n    t[i * 2] = table[nfilled - 1];\n    t[i * 2 + 1] = 0;\n  }\n  t[0] = t[1];\n  t[TABLE_SIZE - 1] = t[TABLE_SIZE - 2];\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& data = context->input(0);\n    const Tensor& weights = context->input(1);\n    bool use_weights = weights.NumElements() > 0;\n    OP_REQUIRES(context,\n                TensorShapeUtils::IsVector(data.shape()) ||\n                    TensorShapeUtils::IsMatrix(data.shape()),\n                errors::InvalidArgument(\n                    \"Input must be a 1 or 2-dimensional tensor. Got: \",\n                    data.shape().DebugString()));\n    if (use_weights) {\n      OP_REQUIRES(\n          context, weights.shape() == data.shape(),\n          errors::InvalidArgument(\n              \"Weights and data must have the same shape. Weight shape: \",\n              weights.shape().DebugString(),\n              \"; data shape: \", data.shape().DebugString()));\n    }\n    bool is_1d = TensorShapeUtils::IsVector(data.shape());\n    int negative_valued_axis = -1;\n    int num_batch_dimensions = (data.shape().dims() + negative_valued_axis);\n    int num_batch_elements = 1;\n    for (int i = 0; i < num_batch_dimensions; ++i) {\n      num_batch_elements *= data.shape().dim_size(i);\n    }\n    int num_value_elements = data.shape().num_elements() / num_batch_elements;\n    auto per_batch_counts = BatchedMap<W>(num_batch_elements);\n    T max_value = 0;\n    const auto data_values = data.flat<T>();\n    const auto weight_values = weights.flat<W>();\n    int i = 0;\n    for (int b = 0; b < num_batch_elements; ++b) {\n      for (int v = 0; v < num_value_elements; ++v) {\n        const auto& value = data_values(i);\n        if (value >= 0 && (maxlength_ <= 0 || value < maxlength_)) {\n          if (binary_output_) {\n            per_batch_counts[b][value] = 1;\n          } else if (use_weights) {\n            per_batch_counts[b][value] += weight_values(i);\n          } else {\n            per_batch_counts[b][value]++;\n          }\n          if (value > max_value) {\n            max_value = value;\n          }\n        }\n        ++i;\n      }\n    }\n    int num_output_values = GetOutputSize(max_value, maxlength_, minlength_);\n    OP_REQUIRES_OK(context, OutputSparse<W>(per_batch_counts, num_output_values,\n                                            is_1d, context));\n  }", "target": 1}
{"code": "Node::InsertionNotificationRequest HTMLLinkElement::InsertedInto(\n    ContainerNode& insertion_point) {\n  HTMLElement::InsertedInto(insertion_point);\n  LogAddElementIfIsolatedWorldAndInDocument(\"link\", relAttr, hrefAttr);\n   if (!insertion_point.isConnected())\n     return kInsertionDone;\n   DCHECK(isConnected());\n   if (!ShouldLoadLink() && IsInShadowTree()) {\n     String message = \"HTML element <link> is ignored in shadow tree.\";\n     GetDocument().AddConsoleMessage(ConsoleMessage::Create(\n         kJSMessageSource, kWarningMessageLevel, message));\n     return kInsertionDone;\n   }\n  GetDocument().GetStyleEngine().AddStyleSheetCandidateNode(*this);\n   Process();\n   if (link_)\n    link_->OwnerInserted();\n  return kInsertionDone;\n}", "target": 1}
{"code": "int CLASS ljpeg_start (struct jhead *jh, int info_only)\n{\n  int c, tag, len;\n  uchar data[0x10000];\n  const uchar *dp;\n  memset (jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  fread (data, 2, 1, ifp);\n  if (data[1] != 0xd8) return 0;\n  do {\n    fread (data, 2, 2, ifp);\n    tag =  data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00) return 0;\n    fread (data, 1, len, ifp);\n    switch (tag) {\n      case 0xffc3:\n\tjh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n      case 0xffc0:\n\tjh->bits = data[0];\n\tjh->high = data[1] << 8 | data[2];\n\tjh->wide = data[3] << 8 | data[4];\n\tjh->clrs = data[5] + jh->sraw;\n\tif (len == 9 && !dng_version) getc(ifp);\n\tbreak;\n      case 0xffc4:\n\tif (info_only) break;\n\tfor (dp = data; dp < data+len && (c = *dp++) < 4; )\n\t  jh->free[c] = jh->huff[c] = make_decoder_ref (&dp);\n\tbreak;\n      case 0xffda:\n\tjh->psv = data[1+data[0]*2];\n\tjh->bits -= data[3+data[0]*2] & 15;\n\tbreak;\n      case 0xffdd:\n\tjh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (info_only) return 1;\n  if (jh->clrs > 6 || !jh->huff[0]) return 0;\n  FORC(5) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c];\n  if (jh->sraw) {\n    FORC(4)        jh->huff[2+c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1+c] = jh->huff[0];\n  }\n  jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);\n  merror (jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}", "target": 1}
{"code": "htmlParsePubidLiteral(htmlParserCtxtPtr ctxt) {\n    const xmlChar *q;\n    xmlChar *ret = NULL;\n    if (CUR == '\"') {\n        NEXT;\n\tq = CUR_PTR;\n\twhile (IS_PUBIDCHAR_CH(CUR)) NEXT;\n\tif (CUR != '\"') {\n\t    htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED,\n\t                 \"Unfinished PubidLiteral\\n\", NULL, NULL);\n\t} else {\n\t    ret = xmlStrndup(q, CUR_PTR - q);\n\t    NEXT;\n\t}\n    } else if (CUR == '\\'') {\n        NEXT;\n\tq = CUR_PTR;\n\twhile ((IS_PUBIDCHAR_CH(CUR)) && (CUR != '\\''))\n\t    NEXT;\n\tif (CUR != '\\'') {\n\t    htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED,\n\t                 \"Unfinished PubidLiteral\\n\", NULL, NULL);\n\t} else {\n\t    ret = xmlStrndup(q, CUR_PTR - q);\n\t    NEXT;\n\t}\n    } else {\n\thtmlParseErr(ctxt, XML_ERR_LITERAL_NOT_STARTED,\n\t             \"PubidLiteral \\\" or ' expected\\n\", NULL, NULL);\n    }\n    return(ret);\n}", "target": 1}
{"code": "static int __init fm10k_init_module(void)\n{\n\tpr_info(\"%s - version %s\\n\", fm10k_driver_string, fm10k_driver_version);\n\tpr_info(\"%s\\n\", fm10k_copyright);\n \tfm10k_workqueue = alloc_workqueue(\"%s\", WQ_MEM_RECLAIM, 0,\n \t\t\t\t\t  fm10k_driver_name);\n \tfm10k_dbg_init();\n\treturn fm10k_register_pci_driver();\n}", "target": 1}
{"code": "file_rlookup(const char *filename)\t\n{\n  int\t\ti;\t\t\t\n  cache_t\t*wc;\t\t\t\n  for (i = web_files, wc = web_cache; i > 0; i --, wc ++)\n    if (!strcmp(wc->name, filename))\n      return (wc->url);\n  return (filename);\n}", "target": 1}
{"code": "void hid_reset(HIDState *hs)\n{\n    switch (hs->kind) {\n    case HID_KEYBOARD:\n        memset(hs->kbd.keycodes, 0, sizeof(hs->kbd.keycodes));\n        memset(hs->kbd.key, 0, sizeof(hs->kbd.key));\n        hs->kbd.keys = 0;\n        break;\n    case HID_MOUSE:\n    case HID_TABLET:\n        memset(hs->ptr.queue, 0, sizeof(hs->ptr.queue));\n        break;\n    }\n    hs->head = 0;\n    hs->n = 0;\n    hs->protocol = 1;\n    hs->idle = 0;\n    hs->idle_pending = false;\n    hid_del_idle_timer(hs);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) final {\n    const Tensor& superdiag = context->input(0);\n    const Tensor& maindiag = context->input(1);\n    const Tensor& subdiag = context->input(2);\n    const Tensor& rhs = context->input(3);\n    const int ndims = rhs.dims();\n    int64 batch_size = 1;\n    for (int i = 0; i < ndims - 2; i++) {\n      batch_size *= rhs.dim_size(i);\n    }\n    const int m = rhs.dim_size(ndims - 2);\n    const int n = rhs.dim_size(ndims - 1);\n    Tensor* output;\n    OP_REQUIRES_OK(context, context->allocate_output(0, rhs.shape(), &output));\n    const Eigen::GpuDevice& device = context->eigen_device<Eigen::GpuDevice>();\n    GpuLaunchConfig cfg = GetGpuLaunchConfig(1, device);\n    TF_CHECK_OK(GpuLaunchKernel(\n        TridiagonalMatMulKernel<Scalar>, cfg.block_count, cfg.thread_per_block,\n        0, device.stream(), batch_size, m, n, superdiag.flat<Scalar>().data(),\n        maindiag.flat<Scalar>().data(), subdiag.flat<Scalar>().data(),\n        rhs.flat<Scalar>().data(), output->flat<Scalar>().data()));\n  }", "target": 1}
{"code": "process_secondary_order(STREAM s)\n{\n\tuint16 length;\n \tuint16 flags;\n \tuint8 type;\n \tuint8 *next_order;\n \tin_uint16_le(s, length);\n \tin_uint16_le(s, flags);\t\n \tin_uint8(s, type);\n \tnext_order = s->p + (sint16) length + 7;\n \tswitch (type)\n\t{\n\t\tcase RDP_ORDER_RAW_BMPCACHE:\n\t\t\tprocess_raw_bmpcache(s);\n\t\t\tbreak;\n\t\tcase RDP_ORDER_COLCACHE:\n\t\t\tprocess_colcache(s);\n\t\t\tbreak;\n\t\tcase RDP_ORDER_BMPCACHE:\n\t\t\tprocess_bmpcache(s);\n\t\t\tbreak;\n\t\tcase RDP_ORDER_FONTCACHE:\n\t\t\tprocess_fontcache(s);\n\t\t\tbreak;\n\t\tcase RDP_ORDER_RAW_BMPCACHE2:\n\t\t\tprocess_bmpcache2(s, flags, False);\t\n\t\t\tbreak;\n\t\tcase RDP_ORDER_BMPCACHE2:\n\t\t\tprocess_bmpcache2(s, flags, True);\t\n\t\t\tbreak;\n\t\tcase RDP_ORDER_BRUSHCACHE:\n\t\t\tprocess_brushcache(s, flags);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlogger(Graphics, Warning,\n\t\t\t       \"process_secondary_order(), unhandled secondary order %d\", type);\n\t}\n\ts->p = next_order;\n}", "target": 1}
{"code": "static int generate_key(DH *dh)\n{\n     int ok = 0;\n     int generate_new_key = 0;\n     unsigned l;\n    BN_CTX *ctx;\n     BN_MONT_CTX *mont = NULL;\n     BIGNUM *pub_key = NULL, *priv_key = NULL;\n     ctx = BN_CTX_new();\n     if (ctx == NULL)\n         goto err;\n        generate_new_key = 1;\n    } else", "target": 1}
{"code": "PLIST_API void plist_from_bin(const char *plist_bin, uint32_t length, plist_t * plist)\n{\n    char *trailer = NULL;\n    uint8_t offset_size = 0;\n    uint8_t dict_size = 0;\n    uint64_t num_objects = 0;\n    uint64_t root_object = 0;\n    uint64_t offset_table_index = 0;\n    char *offset_table = NULL;\n    if (!(length >= BPLIST_MAGIC_SIZE + BPLIST_VERSION_SIZE + BPLIST_TRL_SIZE))\n        return;\n    if (memcmp(plist_bin, BPLIST_MAGIC, BPLIST_MAGIC_SIZE) != 0)\n        return;\n    if (memcmp(plist_bin + BPLIST_MAGIC_SIZE, BPLIST_VERSION, BPLIST_VERSION_SIZE) != 0)\n        return;\n    trailer = (char *) (plist_bin + (length - BPLIST_TRL_SIZE));\n    offset_size = trailer[BPLIST_TRL_OFFSIZE_IDX];\n    dict_size = trailer[BPLIST_TRL_PARMSIZE_IDX];\n    num_objects = be64dec(trailer + BPLIST_TRL_NUMOBJ_IDX);\n    root_object = be64dec(trailer + BPLIST_TRL_ROOTOBJ_IDX);\n    offset_table_index = be64dec(trailer + BPLIST_TRL_OFFTAB_IDX);\n    offset_table = (char *) (plist_bin + offset_table_index);\n    if (num_objects == 0)\n        return;\n    if (root_object >= num_objects)\n        return;\n    if (offset_table < plist_bin || offset_table >= plist_bin + length)\n        return;\n    if (offset_table + num_objects * offset_size >= plist_bin + length)\n        return;\n    if (sizeof(uint32_t) * num_objects < num_objects)\n        return;\n    struct bplist_data bplist;\n    bplist.data = plist_bin;\n    bplist.size = length;\n    bplist.num_objects = num_objects;\n    bplist.dict_size = dict_size;\n    bplist.offset_size = offset_size;\n    bplist.offset_table = offset_table;\n    bplist.level = 0;\n    bplist.used_indexes = (uint32_t*)malloc(sizeof(uint32_t) * num_objects);\n    if (!bplist.used_indexes)\n        return;\n    *plist = parse_bin_node_at_index(&bplist, root_object);\n    free(bplist.used_indexes);\n}", "target": 1}
{"code": "status_t Parcel::readUtf8FromUtf16(std::string* str) const {\n size_t utf16Size = 0;\n const char16_t* src = readString16Inplace(&utf16Size);\n if (!src) {\n return UNEXPECTED_NULL;\n }\n if (utf16Size == 0u) {\n        str->clear();\n        return NO_ERROR;\n     }\n    ssize_t utf8Size = utf16_to_utf8_length(src, utf16Size);\n    if (utf8Size < 0) {\n         return BAD_VALUE;\n     }\n    str->resize(utf8Size + 1);\n    utf16_to_utf8(src, utf16Size, &((*str)[0]));\n     str->resize(utf8Size);\n     return NO_ERROR;\n }", "target": 1}
{"code": "static int ttusb_dec_send_command(struct ttusb_dec *dec, const u8 command,\n\t\t\t\t  int param_length, const u8 params[],\n\t\t\t\t  int *result_length, u8 cmd_result[])\n{\n\tint result, actual_len;\n\tu8 *b;\n\tdprintk(\"%s\\n\", __func__);\n\tb = kmalloc(COMMAND_PACKET_SIZE + 4, GFP_KERNEL);\n\tif (!b)\n\t\treturn -ENOMEM;\n\tif ((result = mutex_lock_interruptible(&dec->usb_mutex))) {\n\t\tkfree(b);\n\t\tprintk(\"%s: Failed to lock usb mutex.\\n\", __func__);\n\t\treturn result;\n\t}\n\tb[0] = 0xaa;\n\tb[1] = ++dec->trans_count;\n\tb[2] = command;\n\tb[3] = param_length;\n\tif (params)\n\t\tmemcpy(&b[4], params, param_length);\n\tif (debug) {\n\t\tprintk(KERN_DEBUG \"%s: command: %*ph\\n\",\n\t\t       __func__, param_length, b);\n\t}\n\tresult = usb_bulk_msg(dec->udev, dec->command_pipe, b,\n\t\t\t      COMMAND_PACKET_SIZE + 4, &actual_len, 1000);\n\tif (result) {\n\t\tprintk(\"%s: command bulk message failed: error %d\\n\",\n\t\t       __func__, result);\n\t\tmutex_unlock(&dec->usb_mutex);\n\t\tkfree(b);\n\t\treturn result;\n\t}\n\tresult = usb_bulk_msg(dec->udev, dec->result_pipe, b,\n\t\t\t      COMMAND_PACKET_SIZE + 4, &actual_len, 1000);\n\tif (result) {\n\t\tprintk(\"%s: result bulk message failed: error %d\\n\",\n\t\t       __func__, result);\n\t\tmutex_unlock(&dec->usb_mutex);\n\t\tkfree(b);\n\t\treturn result;\n\t} else {\n\t\tif (debug) {\n\t\t\tprintk(KERN_DEBUG \"%s: result: %*ph\\n\",\n\t\t\t       __func__, actual_len, b);\n\t\t}\n\t\tif (result_length)\n\t\t\t*result_length = b[3];\n\t\tif (cmd_result && b[3] > 0)\n\t\t\tmemcpy(cmd_result, &b[4], b[3]);\n\t\tmutex_unlock(&dec->usb_mutex);\n\t\tkfree(b);\n\t\treturn 0;\n\t}\n}", "target": 1}
{"code": "static void virtio_blk_handle_write(VirtIOBlockReq *req, MultiReqBuffer *mrb)\n{\n    BlockRequest *blkreq;\n    uint64_t sector;\n    sector = ldq_p(&req->out->sector);\n    trace_virtio_blk_handle_write(req, sector, req->qiov.size / 512);\n    if (sector & req->dev->sector_mask) {\n        virtio_blk_rw_complete(req, -EIO);\n        return;\n    }\n    if (mrb->num_writes == 32) {\n        virtio_submit_multiwrite(req->dev->bs, mrb);\n    }\n    blkreq = &mrb->blkreq[mrb->num_writes];\n    blkreq->sector = sector;\n    blkreq->nb_sectors = req->qiov.size / BDRV_SECTOR_SIZE;\n    blkreq->qiov = &req->qiov;\n    blkreq->cb = virtio_blk_rw_complete;\n    blkreq->opaque = req;\n    blkreq->error = 0;\n    mrb->num_writes++;\n}", "target": 1}
{"code": " unsigned char *base64decode(const char *buf, size_t *size)\n {\n \tif (!buf || !size) return NULL;\n\tsize_t len = (*size > 0) ? *size : strlen(buf);\n\tif (len <= 0) return NULL;\n \tunsigned char *outbuf = (unsigned char*)malloc((len/4)*3+3);\n \tconst char *ptr = buf;\n \tint p = 0;\n\tsize_t l = 0;\n \tdo {\n\t\tptr += strspn(ptr, \"\\r\\n\\t \");\n \t\tif (*ptr == '\\0' || ptr >= buf+len) {\n \t\t\tbreak;\n \t\t}\n\t\tl = strcspn(ptr, \"\\r\\n\\t \");\n\t\tif (l > 3 && ptr+l <= buf+len) {\n\t\t\tp+=base64decode_block(outbuf+p, ptr, l);\n\t\t\tptr += l;\n\t\t} else {\n\t\t\tbreak;\n \t\t}\n \t} while (1);\n\toutbuf[p] = 0;\n\t*size = p;\n\treturn outbuf;\n}", "target": 1}
{"code": "TEST(ArrayOpsTest, QuantizeAndDequantizeV2_ShapeFn) {\n  ShapeInferenceTestOp op(\"QuantizeAndDequantizeV2\");\n  op.input_tensors.resize(3);\n  TF_ASSERT_OK(NodeDefBuilder(\"test\", \"QuantizeAndDequantizeV2\")\n                   .Input(\"input\", 0, DT_FLOAT)\n                   .Input(\"input_min\", 1, DT_FLOAT)\n                   .Input(\"input_max\", 2, DT_FLOAT)\n                   .Attr(\"signed_input\", true)\n                   .Attr(\"num_bits\", 8)\n                   .Attr(\"range_given\", false)\n                   .Attr(\"narrow_range\", false)\n                   .Attr(\"axis\", -1)\n                   .Finalize(&op.node_def));\n  INFER_OK(op, \"?;?;?\", \"in0\");\n  INFER_OK(op, \"[];?;?\", \"in0\");\n  INFER_OK(op, \"[1,2,?,4,5];?;?\", \"in0\");\n  INFER_ERROR(\"Shape must be rank 0 but is rank 1\", op, \"[1,2,?,4,5];[1];[]\");\n  INFER_ERROR(\"Shapes must be equal rank, but are 1 and 0\", op,\n              \"[1,2,?,4,5];[];[1]\");\n  INFER_ERROR(\"Shape must be rank 0 but is rank 1\", op, \"[1,2,?,4,5];[1];[1]\");\n}", "target": 1}
{"code": " smbhash(unsigned char *out, const unsigned char *in, unsigned char *key)\n {\n\tint rc;\n \tunsigned char key2[8];\n\tstruct crypto_skcipher *tfm_des;\n\tstruct scatterlist sgin, sgout;\n\tstruct skcipher_request *req;\n \tstr_to_key(key, key2);\n\ttfm_des = crypto_alloc_skcipher(\"ecb(des)\", 0, CRYPTO_ALG_ASYNC);\n \tif (IS_ERR(tfm_des)) {\n\t\trc = PTR_ERR(tfm_des);\n\t\tcifs_dbg(VFS, \"could not allocate des crypto API\\n\");\n\t\tgoto smbhash_err;\n\t}\n\treq = skcipher_request_alloc(tfm_des, GFP_KERNEL);\n\tif (!req) {\n\t\trc = -ENOMEM;\n \t\tcifs_dbg(VFS, \"could not allocate des crypto API\\n\");\n\t\tgoto smbhash_free_skcipher;\n \t}\n\tcrypto_skcipher_setkey(tfm_des, key2, 8);\n\tsg_init_one(&sgin, in, 8);\n\tsg_init_one(&sgout, out, 8);\n\tskcipher_request_set_callback(req, 0, NULL, NULL);\n\tskcipher_request_set_crypt(req, &sgin, &sgout, 8, NULL);\n\trc = crypto_skcipher_encrypt(req);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"could not encrypt crypt key rc: %d\\n\", rc);\n\tskcipher_request_free(req);\nsmbhash_free_skcipher:\n\tcrypto_free_skcipher(tfm_des);\nsmbhash_err:\n\treturn rc;\n }", "target": 1}
{"code": "char *VDir::MapPathA(const char *pInName)\n{   \n    char szBuffer[(MAX_PATH+1)*2];\n    char szlBuf[MAX_PATH+1];\n    int length = strlen(pInName);\n    if (!length)\n\treturn (char*)pInName;\n    if (length > MAX_PATH) {\n\tstrncpy(szlBuf, pInName, MAX_PATH);\n\tif (IsPathSep(pInName[0]) && !IsPathSep(pInName[1])) {   \n\t    szlBuf[MAX_PATH-2] = '\\0';\n\t}\n\telse\n\t    szlBuf[MAX_PATH] = '\\0';\n\tpInName = szlBuf;\n    }\n    if (pInName[1] == ':') {\n\tif (IsPathSep(pInName[2])) {\n\t    DoGetFullPathNameA((char*)pInName, sizeof(szLocalBufferA), szLocalBufferA);\n\t}\n\telse {\n\t    strcpy(szBuffer, GetDirA(DriveIndex(*pInName)));\n\t    strcat(szBuffer, &pInName[2]);\n\t    if(strlen(szBuffer) > MAX_PATH)\n\t\tszBuffer[MAX_PATH] = '\\0';\n\t    DoGetFullPathNameA(szBuffer, sizeof(szLocalBufferA), szLocalBufferA);\n\t}\n    }\n    else {\n\tif (IsPathSep(pInName[1]) && IsPathSep(pInName[0])) {\n\t    DoGetFullPathNameA((char*)pInName, sizeof(szLocalBufferA), szLocalBufferA);\n\t}\n\telse {\n\t    strcpy(szBuffer, GetDefaultDirA());\n\t    if (IsPathSep(pInName[0])) {\n\t\tstrcpy(&szBuffer[2], pInName);\n\t\tDoGetFullPathNameA(szBuffer, sizeof(szLocalBufferA), szLocalBufferA);\n\t    }\n\t    else {\n\t\tif (IsSpecialFileName(pInName)) {\n\t\t    return (char*)pInName;\n\t\t}\n\t\telse {\n\t\t    strcat(szBuffer, pInName);\n\t\t    if (strlen(szBuffer) > MAX_PATH)\n\t\t\tszBuffer[MAX_PATH] = '\\0';\n\t\t    DoGetFullPathNameA(szBuffer, sizeof(szLocalBufferA), szLocalBufferA);\n\t\t}\n\t    }\n\t}\n    }\n    return szLocalBufferA;\n}", "target": 1}
{"code": "bool RGWSwiftWebsiteHandler::is_web_dir() const\n{\n  std::string subdir_name = url_decode(s->object.name);\n  if (subdir_name.empty()) {\n    return false;\n  } else if (subdir_name.back() == '/') {\n    subdir_name.pop_back();\n  }\n  rgw_obj obj(s->bucket, std::move(subdir_name));\n  RGWObjectCtx& obj_ctx = *static_cast<RGWObjectCtx *>(s->obj_ctx);\n  obj_ctx.set_atomic(obj);\n  obj_ctx.set_prefetch_data(obj);\n  RGWObjState* state = nullptr;\n  if (store->get_obj_state(&obj_ctx, s->bucket_info, obj, &state, false) < 0) {\n    return false;\n  }\n  if (! state->exists) {\n    return false;\n  }\n  std::string content_type;\n  get_contype_from_attrs(state->attrset, content_type);\n  const auto& ws_conf = s->bucket_info.website_conf;\n  const std::string subdir_marker = ws_conf.subdir_marker.empty()\n                                      ? \"application/directory\"\n                                      : ws_conf.subdir_marker;\n  return subdir_marker == content_type && state->size <= 1;\n}", "target": 1}
{"code": "void fmtutil_macbitmap_read_pixmap_only_fields(deark *c, dbuf *f, struct fmtutil_macbitmap_info *bi,\n\ti64 pos)\n{\n\ti64 pixmap_version;\n\ti64 pack_size;\n\ti64 plane_bytes;\n\ti64 n;\n\tde_dbg(c, \"additional PixMap header fields, at %d\", (int)pos);\n\tde_dbg_indent(c, 1);\n\tpixmap_version = dbuf_getu16be(f, pos+0);\n\tde_dbg(c, \"pixmap version: %d\", (int)pixmap_version);\n\tbi->packing_type = dbuf_getu16be(f, pos+2);\n\tde_dbg(c, \"packing type: %d\", (int)bi->packing_type);\n\tpack_size = dbuf_getu32be(f, pos+4);\n\tde_dbg(c, \"pixel data length: %d\", (int)pack_size);\n\tbi->hdpi = pict_read_fixed(f, pos+8);\n\tbi->vdpi = pict_read_fixed(f, pos+12);\n\tde_dbg(c, \"dpi: %.2f\"DE_CHAR_TIMES\"%.2f\", bi->hdpi, bi->vdpi);\n\tbi->pixeltype = dbuf_getu16be(f, pos+16);\n\tbi->pixelsize = dbuf_getu16be(f, pos+18);\n\tbi->cmpcount = dbuf_getu16be(f, pos+20);\n\tbi->cmpsize = dbuf_getu16be(f, pos+22);\n\tde_dbg(c, \"pixel type=%d, bits/pixel=%d, components/pixel=%d, bits/comp=%d\",\n\t\t(int)bi->pixeltype, (int)bi->pixelsize, (int)bi->cmpcount, (int)bi->cmpsize);\n\tbi->pdwidth = (bi->rowbytes*8)/bi->pixelsize;\n\tif(bi->pdwidth < bi->npwidth) {\n\t\tbi->pdwidth = bi->npwidth;\n\t}\n\tplane_bytes = dbuf_getu32be(f, pos+24);\n\tde_dbg(c, \"plane bytes: %d\", (int)plane_bytes);\n\tbi->pmTable = (u32)dbuf_getu32be(f, pos+28);\n\tde_dbg(c, \"pmTable: 0x%08x\", (unsigned int)bi->pmTable);\n\tn = dbuf_getu32be(f, pos+32);\n\tde_dbg(c, \"pmReserved: 0x%08x\", (unsigned int)n);\n\tde_dbg_indent(c, -1);\n}", "target": 1}
{"code": "SProcXkbSelectEvents(ClientPtr client)\n{\n    REQUEST(xkbSelectEventsReq);\n    swaps(&stuff->length);\n    REQUEST_AT_LEAST_SIZE(xkbSelectEventsReq);\n    swaps(&stuff->deviceSpec);\n    swaps(&stuff->affectWhich);\n    swaps(&stuff->clear);\n    swaps(&stuff->selectAll);\n    swaps(&stuff->affectMap);\n    swaps(&stuff->map);\n    if ((stuff->affectWhich & (~XkbMapNotifyMask)) != 0) {\n        union {\n            BOOL *b;\n            CARD8 *c8;\n            CARD16 *c16;\n            CARD32 *c32;\n        } from;\n        register unsigned bit, ndx, maskLeft, dataLeft, size;\n        from.c8 = (CARD8 *) &stuff[1];\n        dataLeft = (stuff->length * 4) - SIZEOF(xkbSelectEventsReq);\n        maskLeft = (stuff->affectWhich & (~XkbMapNotifyMask));\n        for (ndx = 0, bit = 1; (maskLeft != 0); ndx++, bit <<= 1) {\n            if (((bit & maskLeft) == 0) || (ndx == XkbMapNotify))\n                continue;\n            maskLeft &= ~bit;\n            if ((stuff->selectAll & bit) || (stuff->clear & bit))\n                continue;\n            switch (ndx) {\n            case XkbNewKeyboardNotify:\n            case XkbStateNotify:\n            case XkbNamesNotify:\n            case XkbAccessXNotify:\n            case XkbExtensionDeviceNotify:\n                size = 2;\n                break;\n            case XkbControlsNotify:\n            case XkbIndicatorStateNotify:\n            case XkbIndicatorMapNotify:\n                size = 4;\n                break;\n            case XkbBellNotify:\n            case XkbActionMessage:\n            case XkbCompatMapNotify:\n                size = 1;\n                break;\n            default:\n                client->errorValue = _XkbErrCode2(0x1, bit);\n                return BadValue;\n            }\n            if (dataLeft < (size * 2))\n                return BadLength;\n            if (size == 2) {\n                swaps(&from.c16[0]);\n                swaps(&from.c16[1]);\n            }\n            else if (size == 4) {\n                swapl(&from.c32[0]);\n                swapl(&from.c32[1]);\n            }\n            else {\n                size = 2;\n            }\n            from.c8 += (size * 2);\n            dataLeft -= (size * 2);\n        }\n        if (dataLeft > 2) {\n            ErrorF(\"[xkb] Extra data (%d bytes) after SelectEvents\\n\",\n                   dataLeft);\n            return BadLength;\n        }\n    }\n    return ProcXkbSelectEvents(client);\n}", "target": 1}
{"code": "Literal *hermes::evalUnaryOperator(\n    UnaryOperatorInst::OpKind kind,\n    IRBuilder &builder,\n    Literal *operand) {\n  switch (kind) {\n    case UnaryOperatorInst::OpKind::MinusKind:\n      switch (operand->getKind()) {\n        case ValueKind::LiteralNumberKind:\n          if (auto *literalNum = llvh::dyn_cast<LiteralNumber>(operand)) {\n            auto V = -literalNum->getValue();\n            return builder.getLiteralNumber(V);\n          }\n          break;\n        case ValueKind::LiteralUndefinedKind:\n          return builder.getLiteralNaN();\n        case ValueKind::LiteralBoolKind:\n          if (evalIsTrue(builder, operand)) {\n            return builder.getLiteralNumber(-1);\n          } else { \n            return builder.getLiteralNegativeZero();\n          }\n        case ValueKind::LiteralNullKind:\n          return builder.getLiteralNegativeZero();\n        default:\n          break;\n      }\n      break;\n    case UnaryOperatorInst::OpKind::TypeofKind:\n      switch (operand->getKind()) {\n        case ValueKind::GlobalObjectKind:\n        case ValueKind::LiteralNullKind:\n          return builder.getLiteralString(\"object\");\n        case ValueKind::LiteralUndefinedKind:\n          return builder.getLiteralString(\"undefined\");\n        case ValueKind::LiteralBoolKind:\n          return builder.getLiteralString(\"boolean\");\n        case ValueKind::LiteralNumberKind:\n          return builder.getLiteralString(\"number\");\n        case ValueKind::LiteralStringKind:\n          return builder.getLiteralString(\"string\");\n        default:\n          llvm_unreachable(\"Invalid literal kind.\");\n      }\n      break;\n    case UnaryOperatorInst::OpKind::BangKind:\n      if (evalIsTrue(builder, operand)) {\n        return builder.getLiteralBool(false);\n      }\n      if (evalIsFalse(builder, operand)) {\n        return builder.getLiteralBool(true);\n      }\n      break;\n    case UnaryOperatorInst::OpKind::VoidKind:\n      return builder.getLiteralUndefined();\n    default:\n      break;\n  }\n  return nullptr;\n}", "target": 1}
{"code": "static inline int restore_fpu_checking(struct task_struct *tsk)\n{\n\talternative_input(\n\t\tASM_NOP8 ASM_NOP2,\n\t\t\"emms\\n\\t\"\t\t\n\t\t\"fildl %P[addr]\",\t\n\t\tX86_FEATURE_FXSAVE_LEAK,\n\t\t[addr] \"m\" (tsk->thread.fpu.has_fpu));\n\treturn fpu_restore_checking(&tsk->thread.fpu);\n}", "target": 1}
{"code": "static int uio_mmap_physical(struct vm_area_struct *vma)\n {\n \tstruct uio_device *idev = vma->vm_private_data;\n \tint mi = uio_find_mem_index(vma);\n \tif (mi < 0)\n \t\treturn -EINVAL;\n\tvma->vm_ops = &uio_physical_vm_ops;\n \tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n \treturn remap_pfn_range(vma,\n \t\t\t       vma->vm_start,\n\t\t\t       idev->info->mem[mi].addr >> PAGE_SHIFT,\n \t\t\t       vma->vm_end - vma->vm_start,\n \t\t\t       vma->vm_page_prot);\n }", "target": 1}
{"code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* params;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kParams, &params));\n  const TfLiteTensor* indices;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kIndices, &indices));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  switch (indices->type) {\n    case kTfLiteInt32:\n      return EvalGatherNd<int32_t>(context, params, indices, output);\n    case kTfLiteInt64:\n      return EvalGatherNd<int64_t>(context, params, indices, output);\n    default:\n      context->ReportError(\n          context, \"Indices of type '%s' are not supported by gather_nd.\",\n          TfLiteTypeGetName(indices->type));\n      return kTfLiteError;\n  }\n}", "target": 1}
{"code": "static int sco_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sco_pinfo *pi = sco_pi(sk);\n\tlock_sock(sk);\n\tif (sk->sk_state == BT_CONNECT2 &&\n \t    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {\n \t\thci_conn_accept(pi->conn->hcon, 0);\n \t\tsk->sk_state = BT_CONFIG;\n \t\trelease_sock(sk);\n \t\treturn 0;\n\t}\n\trelease_sock(sk);\n\treturn bt_sock_recvmsg(iocb, sock, msg, len, flags);\n}", "target": 1}
{"code": "bool Capability::ChangeUnixUser(uid_t uid) {\n  if (setInitialCapabilities()) {\n    struct passwd *pw;\n    if ((pw = getpwuid(uid)) == nullptr) {\n      Logger::Error(\"unable to getpwuid(%d): %s\", uid,\n                    folly::errnoStr(errno).c_str());\n      return false;\n    }\n    if (pw->pw_gid == 0 || setgid(pw->pw_gid) < 0) {\n      Logger::Error(\"unable to drop gid privs: %s\",\n                    folly::errnoStr(errno).c_str());\n      return false;\n    }\n    if (uid == 0 || setuid(uid) < 0) {\n      Logger::Error(\"unable to drop uid privs: %s\",\n                    folly::errnoStr(errno).c_str());\n      return false;\n    }\n    if (!setMinimalCapabilities()) {\n      Logger::Error(\"unable to set minimal server capabiltiies\");\n      return false;\n    }\n    return true;\n  }\n  return false;\n}", "target": 1}
{"code": "void FeatureInfo::EnableOESTextureHalfFloatLinear() {\n  if (!oes_texture_half_float_linear_available_)\n     return;\n   AddExtensionString(\"GL_OES_texture_half_float_linear\");\n   feature_flags_.enable_texture_half_float_linear = true;\n   feature_flags_.gpu_memory_buffer_formats.Add(gfx::BufferFormat::RGBA_F16);\n }", "target": 1}
{"code": "png_set_PLTE(png_structrp png_ptr, png_inforp info_ptr,\n    png_const_colorp palette, int num_palette)\n{\n   png_debug1(1, \"in %s storage function\", \"PLTE\");\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n   if (num_palette < 0 || num_palette > PNG_MAX_PALETTE_LENGTH)\n   {\n      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n         png_error(png_ptr, \"Invalid palette length\");\n      else\n      {\n         png_warning(png_ptr, \"Invalid palette length\");\n         return;\n      }\n   }\n   if ((num_palette > 0 && palette == NULL) ||\n      (num_palette == 0\n#        ifdef PNG_MNG_FEATURES_SUPPORTED\n            && (png_ptr->mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE) == 0\n#        endif\n      ))\n   {\n      png_error(png_ptr, \"Invalid palette\");\n   }\n   png_free_data(png_ptr, info_ptr, PNG_FREE_PLTE, 0);\n   png_ptr->palette = png_voidcast(png_colorp, png_calloc(png_ptr,\n       PNG_MAX_PALETTE_LENGTH * (sizeof (png_color))));\n   if (num_palette > 0)\n      memcpy(png_ptr->palette, palette, num_palette * (sizeof (png_color)));\n   info_ptr->palette = png_ptr->palette;\n   info_ptr->num_palette = png_ptr->num_palette = (png_uint_16)num_palette;\n   info_ptr->free_me |= PNG_FREE_PLTE;\n   info_ptr->valid |= PNG_INFO_PLTE;\n}", "target": 1}
{"code": "kex_input_kexinit(int type, u_int32_t seq, void *ctxt)\n{\n\tstruct ssh *ssh = ctxt;\n\tstruct kex *kex = ssh->kex;\n\tconst u_char *ptr;\n\tu_int i;\n\tsize_t dlen;\n\tint r;\n\tdebug(\"SSH2_MSG_KEXINIT received\");\n \tif (kex == NULL)\n \t\treturn SSH_ERR_INVALID_ARGUMENT;\n \tptr = sshpkt_ptr(ssh, &dlen);\n \tif ((r = sshbuf_put(kex->peer, ptr, dlen)) != 0)\n \t\treturn r;\n\tfor (i = 0; i < KEX_COOKIE_LEN; i++)\n\t\tif ((r = sshpkt_get_u8(ssh, NULL)) != 0)\n\t\t\treturn r;\n\tfor (i = 0; i < PROPOSAL_MAX; i++)\n\t\tif ((r = sshpkt_get_string(ssh, NULL, NULL)) != 0)\n\t\t\treturn r;\n\tif ((r = sshpkt_get_u8(ssh, NULL)) != 0 ||\t\n\t    (r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\t\treturn r;\n\tif (!(kex->flags & KEX_INIT_SENT))\n\t\tif ((r = kex_send_kexinit(ssh)) != 0)\n\t\t\treturn r;\n\tif ((r = kex_choose_conf(ssh)) != 0)\n\t\treturn r;\n\tif (kex->kex_type < KEX_MAX && kex->kex[kex->kex_type] != NULL)\n\t\treturn (kex->kex[kex->kex_type])(ssh);\n\treturn SSH_ERR_INTERNAL_ERROR;\n}", "target": 1}
{"code": "lldp_mgmt_addr_tlv_print(netdissect_options *ndo,\n                         const u_char *pptr, u_int len)\n{\n    uint8_t mgmt_addr_len, intf_num_subtype, oid_len;\n    const u_char *tptr;\n    u_int tlen;\n    char *mgmt_addr;\n    tlen = len;\n    tptr = pptr;\n    if (tlen < 1) {\n        return 0;\n    }\n    mgmt_addr_len = *tptr++;\n    tlen--;\n    if (tlen < mgmt_addr_len) {\n        return 0;\n    }\n    mgmt_addr = lldp_network_addr_print(ndo, tptr, mgmt_addr_len);\n    if (mgmt_addr == NULL) {\n        return 0;\n    }\n    ND_PRINT((ndo, \"\\n\\t  Management Address length %u, %s\",\n           mgmt_addr_len, mgmt_addr));\n    tptr += mgmt_addr_len;\n    tlen -= mgmt_addr_len;\n    if (tlen < LLDP_INTF_NUM_LEN) {\n        return 0;\n    }\n    intf_num_subtype = *tptr;\n    ND_PRINT((ndo, \"\\n\\t  %s Interface Numbering (%u): %u\",\n           tok2str(lldp_intf_numb_subtype_values, \"Unknown\", intf_num_subtype),\n           intf_num_subtype,\n           EXTRACT_32BITS(tptr + 1)));\n    tptr += LLDP_INTF_NUM_LEN;\n    tlen -= LLDP_INTF_NUM_LEN;\n     if (tlen) {\n         oid_len = *tptr;\n        if (tlen < oid_len) {\n             return 0;\n         }\n         if (oid_len) {\n            ND_PRINT((ndo, \"\\n\\t  OID length %u\", oid_len));\n            safeputs(ndo, tptr + 1, oid_len);\n        }\n    }\n    return 1;\n}", "target": 1}
{"code": "OFCondition WlmActivityManager::StartProvidingService()\n{\n  OFCondition cond = EC_Normal;\n  T_ASC_Network *net = NULL;\n  if( !dcmDataDict.isDictionaryLoaded() )\n  {\n    DCMWLM_WARN(\"no data dictionary loaded, check environment variable: \" << DCM_DICT_ENVIRONMENT_VARIABLE);\n  }\n#ifndef DISABLE_PORT_PERMISSION_CHECK\n#ifdef HAVE_GETEUID\n  if( opt_port < 1024 && geteuid() != 0 )\n    return( WLM_EC_InsufficientPortPrivileges );\n#endif\n#endif\n#ifdef _WIN32\n  if (opt_forkedChild)\n  {\n    DUL_markProcessAsForkedChild();\n    char buf[256];\n    DWORD bytesRead = 0;\n    HANDLE hStdIn = GetStdHandle(STD_INPUT_HANDLE);\n    if (ReadFile(hStdIn, buf, sizeof(buf), &bytesRead, NULL))\n    {\n      buf[bytesRead] = '\\0';\n        dcmExternalSocketHandle.set(atoi(buf));\n    }\n    else\n    {\n      DCMWLM_ERROR(\"cannot read socket handle: \" << GetLastError());\n      exit(0);\n    }\n  }\n  else\n  {\n    if (!opt_singleProcess)\n      DUL_requestForkOnTransportConnectionReceipt(cmd_argc, cmd_argv);\n  }\n#endif\n  cond = ASC_initializeNetwork( NET_ACCEPTOR, OFstatic_cast(int, opt_port), opt_acse_timeout, &net );\n  if( cond.bad() ) return( WLM_EC_InitializationOfNetworkConnectionFailed );\n#if defined(HAVE_SETUID) && defined(HAVE_GETUID)\n  setuid( getuid() );\n#endif\n  while( cond.good() )\n  {\n    cond = WaitForAssociation( net );\n#ifdef HAVE_FORK\n    if( !opt_singleProcess )\n      CleanChildren();\n#elif defined(_WIN32)\n    if (DUL_processIsForkedChild()) break;\n#endif\n  }\n  cond = ASC_dropNetwork( &net );\n  if( cond.bad() ) return( WLM_EC_TerminationOfNetworkConnectionFailed );\n  return( EC_Normal );\n}", "target": 1}
{"code": "get_caller_uid (GDBusMethodInvocation *context, gint *uid)\n {\n        PolkitSubject *subject;\n        PolkitSubject *process;\n        subject = polkit_system_bus_name_new (g_dbus_method_invocation_get_sender (context));\n        process = polkit_system_bus_name_get_process_sync (POLKIT_SYSTEM_BUS_NAME (subject), NULL, NULL);\n        if (!process) {\n                g_object_unref (subject);\n                 return FALSE;\n         }\n        *uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (process));\n        g_object_unref (subject);\n        g_object_unref (process);\n         return TRUE;\n }", "target": 1}
{"code": "static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}", "target": 1}
{"code": "static uint32_t get_cmd(ESPState *s, uint32_t maxlen)\n{\n    uint8_t buf[ESP_CMDFIFO_SZ];\n    uint32_t dmalen, n;\n    int target;\n    target = s->wregs[ESP_WBUSID] & BUSID_DID;\n    if (s->dma) {\n        dmalen = MIN(esp_get_tc(s), maxlen);\n        if (dmalen == 0) {\n            return 0;\n        }\n        if (s->dma_memory_read) {\n            s->dma_memory_read(s->dma_opaque, buf, dmalen);\n            fifo8_push_all(&s->cmdfifo, buf, dmalen);\n        } else {\n            if (esp_select(s) < 0) {\n                fifo8_reset(&s->cmdfifo);\n                return -1;\n            }\n            esp_raise_drq(s);\n            fifo8_reset(&s->cmdfifo);\n            return 0;\n        }\n    } else {\n        dmalen = MIN(fifo8_num_used(&s->fifo), maxlen);\n        if (dmalen == 0) {\n            return 0;\n        }\n        n = esp_fifo_pop_buf(&s->fifo, buf, dmalen);\n        if (n >= 3) {\n            buf[0] = buf[2] >> 5;\n        }\n        fifo8_push_all(&s->cmdfifo, buf, n);\n    }\n    trace_esp_get_cmd(dmalen, target);\n    if (esp_select(s) < 0) {\n        fifo8_reset(&s->cmdfifo);\n        return -1;\n    }\n    return dmalen;\n}", "target": 1}
{"code": "lyxml_parse_mem(struct ly_ctx *ctx, const char *data, int options)\n{\n    FUN_IN;\n    const char *c = data;\n    unsigned int len;\n    struct lyxml_elem *root, *first = NULL, *next;\n    if (!ctx) {\n        LOGARG;\n        return NULL;\n    }\n    if (!data) {\n        return NULL;\n    }\nrepeat:\n    while (1) {\n        if (!*c) {\n            return first;\n        } else if (is_xmlws(*c)) {\n            ign_xmlws(c);\n        } else if (!strncmp(c, \"<?\", 2)) {\n            c += 2;\n            if (parse_ignore(ctx, c, \"?>\", &len)) {\n                goto error;\n            }\n            c += len;\n        } else if (!strncmp(c, \"<!--\", 4)) {\n            c += 2;\n            if (parse_ignore(ctx, c, \"-->\", &len)) {\n                goto error;\n            }\n            c += len;\n        } else if (!strncmp(c, \"<!\", 2)) {\n            LOGERR(ctx, LY_EINVAL, \"DOCTYPE not supported in XML documents.\");\n            goto error;\n        } else if (*c == '<') {\n            break;\n        } else {\n            LOGVAL(ctx, LYE_XML_INCHAR, LY_VLOG_NONE, NULL, c);\n            goto error;\n        }\n    }\n    root = lyxml_parse_elem(ctx, c, &len, NULL, options);\n    if (!root) {\n        goto error;\n    } else if (!first) {\n        first = root;\n    } else {\n        first->prev->next = root;\n        root->prev = first->prev;\n        first->prev = root;\n    }\n    c += len;\n    ign_xmlws(c);\n    if (*c) {\n        if (options & LYXML_PARSE_MULTIROOT) {\n            goto repeat;\n        } else {\n            LOGWRN(ctx, \"There are some not parsed data:\\n%s\", c);\n        }\n    }\n    return first;\nerror:\n    LY_TREE_FOR_SAFE(first, next, root) {\n        lyxml_free(ctx, root);\n    }\n    return NULL;\n}", "target": 1}
{"code": "int vcc_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n\t\tsize_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct atm_vcc *vcc;\n \tstruct sk_buff *skb;\n \tint copied, error = -EINVAL;\n \tif (sock->state != SS_CONNECTED)\n \t\treturn -ENOTCONN;\n\tif (flags & ~(MSG_DONTWAIT | MSG_PEEK))\n\t\treturn -EOPNOTSUPP;\n\tvcc = ATM_SD(sock);\n\tif (test_bit(ATM_VF_RELEASED, &vcc->flags) ||\n\t    test_bit(ATM_VF_CLOSE, &vcc->flags) ||\n\t    !test_bit(ATM_VF_READY, &vcc->flags))\n\t\treturn 0;\n\tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &error);\n\tif (!skb)\n\t\treturn error;\n\tcopied = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\terror = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (error)\n\t\treturn error;\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\tif (!(flags & MSG_PEEK)) {\n\t\tpr_debug(\"%d -= %d\\n\", atomic_read(&sk->sk_rmem_alloc),\n\t\t\t skb->truesize);\n\t\tatm_return(vcc, skb->truesize);\n\t}\n\tskb_free_datagram(sk, skb);\n\treturn copied;\n}", "target": 1}
{"code": " static int check_mtab(const char *progname, const char *devname,\n                      const char *dir)\n {\n       if (check_newline(progname, devname) == -1 ||\n           check_newline(progname, dir) == -1)\n                return EX_USAGE;\n        return 0;\n }", "target": 1}
{"code": " void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {\n     if (len > outHeader->nAllocLen) {\n        ALOGE(\"memset buffer too small: got %lu, expected %zu\", (unsigned long)outHeader->nAllocLen, len);\n         android_errorWriteLog(0x534e4554, \"29422022\");\n         notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);\n         mSignalledError = true;\n return NULL;\n }\n return memset(outHeader->pBuffer, c, len);\n}", "target": 1}
{"code": "static int dns_parse_callback(void *c, int rr, const void *data, int len, const void *packet)\n {\n \tchar tmp[256];\n \tstruct dpc_ctx *ctx = c;\n \tswitch (rr) {\n \tcase RR_A:\n \t\tif (len != 4) return -1;\n\t\tctx->addrs[ctx->cnt].scopeid = 0;\n\t\tmemcpy(ctx->addrs[ctx->cnt++].addr, data, 4);\n\t\tbreak;\n\tcase RR_AAAA:\n\t\tif (len != 16) return -1;\n\t\tctx->addrs[ctx->cnt].family = AF_INET6;\n\t\tctx->addrs[ctx->cnt].scopeid = 0;\n\t\tmemcpy(ctx->addrs[ctx->cnt++].addr, data, 16);\n\t\tbreak;\n\tcase RR_CNAME:\n\t\tif (__dn_expand(packet, (const unsigned char *)packet + 512,\n\t\t    data, tmp, sizeof tmp) > 0 && is_valid_hostname(tmp))\n\t\t\tstrcpy(ctx->canon, tmp);\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int rds_iw_laddr_check(__be32 addr)\n{\n\tint ret;\n\tstruct rdma_cm_id *cm_id;\n\tstruct sockaddr_in sin;\n\tcm_id = rdma_create_id(NULL, NULL, RDMA_PS_TCP, IB_QPT_RC);\n\tif (IS_ERR(cm_id))\n\t\treturn PTR_ERR(cm_id);\n\tmemset(&sin, 0, sizeof(sin));\n\tsin.sin_family = AF_INET;\n\tsin.sin_addr.s_addr = addr;\n\tret = rdma_bind_addr(cm_id, (struct sockaddr *)&sin);\n\tif (ret || cm_id->device->node_type != RDMA_NODE_RNIC)\n\t\tret = -EADDRNOTAVAIL;\n\trdsdebug(\"addr %pI4 ret %d node type %d\\n\",\n\t\t&addr, ret,\n\t\tcm_id->device ? cm_id->device->node_type : -1);\n\trdma_destroy_id(cm_id);\n\treturn ret;\n}", "target": 1}
{"code": "void WavOutFile::write(const float *buffer, int numElems)\n{\n    int numBytes;\n    int bytesPerSample;\n    if (numElems == 0) return;\n    bytesPerSample = header.format.bits_per_sample / 8;\n    numBytes = numElems * bytesPerSample;\n    int confBufBytes = (numBytes + 3) & -4; \n    void *temp = getConvBuffer(confBufBytes);\n    switch (bytesPerSample)\n    {\n        case 1:\n        {\n            unsigned char *temp2 = (unsigned char *)temp;\n            for (int i = 0; i < numElems; i ++)\n            {\n                temp2[i] = (unsigned char)saturate(buffer[i] * 128.0f + 128.0f, 0.0f, 255.0f);\n            }\n            break;\n        }\n        case 2:\n        {\n            short *temp2 = (short *)temp;\n            for (int i = 0; i < numElems; i ++)\n            {\n                short value = (short)saturate(buffer[i] * 32768.0f, -32768.0f, 32767.0f);\n                temp2[i] = _swap16(value);\n            }\n            break;\n        }\n        case 3:\n        {\n            char *temp2 = (char *)temp;\n            for (int i = 0; i < numElems; i ++)\n            {\n                int value = saturate(buffer[i] * 8388608.0f, -8388608.0f, 8388607.0f);\n                *((int*)temp2) = _swap32(value);\n                temp2 += 3;\n            }\n            break;\n        }\n        case 4:\n        {\n            int *temp2 = (int *)temp;\n            for (int i = 0; i < numElems; i ++)\n            {\n                int value = saturate(buffer[i] * 2147483648.0f, -2147483648.0f, 2147483647.0f);\n                temp2[i] = _swap32(value);\n            }\n            break;\n        }\n        default:\n            assert(false);\n    }\n    int res = (int)fwrite(temp, 1, numBytes, fptr);\n    if (res != numBytes) \n    {\n        ST_THROW_RT_ERROR(\"Error while writing to a wav file.\");\n    }\n    bytesWritten += numBytes;\n}", "target": 1}
{"code": "bool PPVarToNPVariant(PP_Var var, NPVariant* result) {\n  switch (var.type) {\n    case PP_VARTYPE_UNDEFINED:\n      VOID_TO_NPVARIANT(*result);\n      break;\n    case PP_VARTYPE_NULL:\n      NULL_TO_NPVARIANT(*result);\n      break;\n    case PP_VARTYPE_BOOL:\n      BOOLEAN_TO_NPVARIANT(var.value.as_bool, *result);\n      break;\n    case PP_VARTYPE_INT32:\n      INT32_TO_NPVARIANT(var.value.as_int, *result);\n      break;\n    case PP_VARTYPE_DOUBLE:\n      DOUBLE_TO_NPVARIANT(var.value.as_double, *result);\n      break;\n    case PP_VARTYPE_STRING: {\n      scoped_refptr<StringVar> string(StringVar::FromPPVar(var));\n      if (!string) {\n        VOID_TO_NPVARIANT(*result);\n         return false;\n       }\n       const std::string& value = string->value();\n      STRINGN_TO_NPVARIANT(base::strdup(value.c_str()), value.size(), *result);\n       break;\n     }\n     case PP_VARTYPE_OBJECT: {\n      scoped_refptr<ObjectVar> object(ObjectVar::FromPPVar(var));\n      if (!object) {\n        VOID_TO_NPVARIANT(*result);\n        return false;\n      }\n      OBJECT_TO_NPVARIANT(WebBindings::retainObject(object->np_object()),\n                          *result);\n      break;\n    }\n    case PP_VARTYPE_ARRAY:\n    case PP_VARTYPE_DICTIONARY:\n      VOID_TO_NPVARIANT(*result);\n      break;\n  }\n  return true;\n}", "target": 1}
{"code": "    void TiffImage::readMetadata()\n    {\n#ifdef DEBUG\n        std::cerr << \"Reading TIFF file \" << io_->path() << \"\\n\";\n#endif\n        if (io_->open() != 0) throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        IoCloser closer(*io_);\n        if (!isTiffType(*io_, false)) {\n            if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData);\n            throw Error(kerNotAnImage, \"TIFF\");\n        }\n        clearMetadata();\n        ByteOrder bo = TiffParser::decode(exifData_,\n                                          iptcData_,\n                                          xmpData_,\n                                          io_->mmap(),\n                                          (uint32_t) io_->size());\n        setByteOrder(bo);\n        Exiv2::ExifKey            key(\"Exif.Image.InterColorProfile\");\n        Exiv2::ExifData::iterator pos   = exifData_.findKey(key);\n        if ( pos != exifData_.end()  ) {\n            iccProfile_.alloc(pos->count());\n            pos->copy(iccProfile_.pData_,bo);\n        }\n    } ", "target": 1}
{"code": "static int sctp_setsockopt_auth_key(struct sock *sk,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    int optlen)\n{\n\tstruct sctp_authkey *authkey;\n\tstruct sctp_association *asoc;\n\tint ret;\n\tif (!sctp_auth_enable)\n\t\treturn -EACCES;\n\tif (optlen <= sizeof(struct sctp_authkey))\n\t\treturn -EINVAL;\n\tauthkey = kmalloc(optlen, GFP_KERNEL);\n\tif (!authkey)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(authkey, optval, optlen)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\tif (authkey->sca_keylength > optlen) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tasoc = sctp_id2assoc(sk, authkey->sca_assoc_id);\n\tif (!asoc && authkey->sca_assoc_id && sctp_style(sk, UDP)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = sctp_auth_set_key(sctp_sk(sk)->ep, asoc, authkey);\nout:\n\tkfree(authkey);\n\treturn ret;\n}", "target": 1}
{"code": " static void update_blocked_averages(int cpu)\n {\n \tstruct rq *rq = cpu_rq(cpu);\n\tstruct cfs_rq *cfs_rq, *pos;\n \tconst struct sched_class *curr_class;\n \tstruct rq_flags rf;\n \tbool done = true;\n\trq_lock_irqsave(rq, &rf);\n\tupdate_rq_clock(rq);\n\tfor_each_leaf_cfs_rq_safe(rq, cfs_rq, pos) {\n \t\tstruct sched_entity *se;\n\t\tif (throttled_hierarchy(cfs_rq))\n\t\t\tcontinue;\n\t\tif (update_cfs_rq_load_avg(cfs_rq_clock_task(cfs_rq), cfs_rq))\n\t\t\tupdate_tg_load_avg(cfs_rq, 0);\n\t\tse = cfs_rq->tg->se[cpu];\n \t\tif (se && !skip_blocked_update(se))\n \t\t\tupdate_load_avg(cfs_rq_of(se), se, 0);\n\t\tif (cfs_rq_is_decayed(cfs_rq))\n\t\t\tlist_del_leaf_cfs_rq(cfs_rq);\n \t\tif (cfs_rq_has_blocked(cfs_rq))\n \t\t\tdone = false;\n\t}\n\tcurr_class = rq->curr->sched_class;\n\tupdate_rt_rq_load_avg(rq_clock_task(rq), rq, curr_class == &rt_sched_class);\n\tupdate_dl_rq_load_avg(rq_clock_task(rq), rq, curr_class == &dl_sched_class);\n\tupdate_irq_load_avg(rq, 0);\n\tif (others_have_blocked(rq))\n\t\tdone = false;\n#ifdef CONFIG_NO_HZ_COMMON\n\trq->last_blocked_load_update_tick = jiffies;\n\tif (done)\n\t\trq->has_blocked_load = 0;\n#endif\n\trq_unlock_irqrestore(rq, &rf);\n}", "target": 1}
{"code": "void SVGImage::setContainerSize(const IntSize& size)\n{\n    if (!m_page || !usesContainerSize())\n        return;\n    LocalFrame* frame = m_page->mainFrame();\n     SVGSVGElement* rootElement = toSVGDocument(frame->document())->rootElement();\n     if (!rootElement)\n         return;\n    RenderSVGRoot* renderer = toRenderSVGRoot(rootElement->renderer());\n    if (!renderer)\n        return;\n     FrameView* view = frameView();\n     view->resize(this->containerSize());\n     renderer->setContainerSize(size);\n }", "target": 1}
{"code": "escape_xml(const char *text)\n{\n\tstatic char *escaped;\n\tstatic size_t escaped_size;\n\tchar *out;\n\tsize_t len;\n\tfor (out=escaped, len=0; *text; ++len, ++out, ++text) {\n\t\tif ((len + 8) > escaped_size) {\n\t\t\tchar *bigger_escaped;\n\t\t\tescaped_size += 128;\n\t\t\tbigger_escaped = realloc(escaped, escaped_size);\n\t\t\tif (!bigger_escaped) {\n\t\t\t\tfree(escaped);\t\n\t\t\t\tescaped = NULL;\n\t\t\t\tescaped_size = 0;\n\t\t\t\treturn \">>> out of memory <<<\";\n\t\t\t}\n\t\t\tout = bigger_escaped + len;\n\t\t\tescaped = bigger_escaped;\n\t\t}\n\t\tswitch (*text) {\n\t\t\tcase '&':\n\t\t\t\tstrcpy(out, \"&amp;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\tstrcpy(out, \"&lt;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\tstrcpy(out, \"&gt;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t*out = *text;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t*out = '\\x0';  \n\treturn escaped;\n}", "target": 1}
{"code": "static int holtekff_init(struct hid_device *hid)\n{\n\tstruct holtekff_device *holtekff;\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct list_head *report_list =\n\t\t\t&hid->report_enum[HID_OUTPUT_REPORT].report_list;\n\tstruct input_dev *dev = hidinput->input;\n\tint error;\n\tif (list_empty(report_list)) {\n\t\thid_err(hid, \"no output report found\\n\");\n\t\treturn -ENODEV;\n\t}\n\treport = list_entry(report_list->next, struct hid_report, list);\n\tif (report->maxfield < 1 || report->field[0]->report_count != 7) {\n\t\thid_err(hid, \"unexpected output report layout\\n\");\n\t\treturn -ENODEV;\n\t}\n\tholtekff = kzalloc(sizeof(*holtekff), GFP_KERNEL);\n\tif (!holtekff)\n\t\treturn -ENOMEM;\n\tset_bit(FF_RUMBLE, dev->ffbit);\n\tholtekff->field = report->field[0];\n\tholtekff_send(holtekff, hid, stop_all4);\n\tholtekff_send(holtekff, hid, stop_all6);\n\terror = input_ff_create_memless(dev, holtekff, holtekff_play);\n\tif (error) {\n\t\tkfree(holtekff);\n\t\treturn error;\n\t}\n\thid_info(hid, \"Force feedback for Holtek On Line Grip based devices by Anssi Hannula <anssi.hannula@iki.fi>\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "long do_io_submit(aio_context_t ctx_id, long nr,\n\t\t  struct iocb __user *__user *iocbpp, bool compat)\n{\n\tstruct kioctx *ctx;\n\tlong ret = 0;\n\tint i;\n\tstruct hlist_head batch_hash[AIO_BATCH_HASH_SIZE] = { { 0, }, };\n\tif (unlikely(nr < 0))\n\t\treturn -EINVAL;\n\tif (unlikely(!access_ok(VERIFY_READ, iocbpp, (nr*sizeof(*iocbpp)))))\n\t\treturn -EFAULT;\n\tctx = lookup_ioctx(ctx_id);\n\tif (unlikely(!ctx)) {\n\t\tpr_debug(\"EINVAL: io_submit: invalid context id\\n\");\n\t\treturn -EINVAL;\n\t}\n\tfor (i=0; i<nr; i++) {\n\t\tstruct iocb __user *user_iocb;\n\t\tstruct iocb tmp;\n\t\tif (unlikely(__get_user(user_iocb, iocbpp + i))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (unlikely(copy_from_user(&tmp, user_iocb, sizeof(tmp)))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tret = io_submit_one(ctx, user_iocb, &tmp, batch_hash, compat);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\taio_batch_free(batch_hash);\n\tput_ioctx(ctx);\n\treturn i ? i : ret;\n}", "target": 1}
{"code": "png_check_chunk_length(png_const_structrp png_ptr, const png_uint_32 length)\n{\n   png_alloc_size_t limit = PNG_UINT_31_MAX;\n# ifdef PNG_SET_USER_LIMITS_SUPPORTED\n   if (png_ptr->user_chunk_malloc_max > 0 &&\n       png_ptr->user_chunk_malloc_max < limit)\n      limit = png_ptr->user_chunk_malloc_max;\n# elif PNG_USER_CHUNK_MALLOC_MAX > 0\n   if (PNG_USER_CHUNK_MALLOC_MAX < limit)\n      limit = PNG_USER_CHUNK_MALLOC_MAX;\n# endif\n   if (png_ptr->chunk_name == png_IDAT)\n    {\n       png_alloc_size_t idat_limit = PNG_UINT_31_MAX;\n       size_t row_factor =\n         (png_ptr->width * png_ptr->channels * (png_ptr->bit_depth > 8? 2: 1)\n          + 1 + (png_ptr->interlaced? 6: 0));\n       if (png_ptr->height > PNG_UINT_32_MAX/row_factor)\n         idat_limit=PNG_UINT_31_MAX;\n       else\n          idat_limit = png_ptr->height * row_factor;\n       row_factor = row_factor > 32566? 32566 : row_factor;\n      idat_limit += 6 + 5*(idat_limit/row_factor+1); \n      idat_limit=idat_limit < PNG_UINT_31_MAX? idat_limit : PNG_UINT_31_MAX;\n      limit = limit < idat_limit? idat_limit : limit;\n   }\n   if (length > limit)\n   {\n      png_debug2(0,\" length = %lu, limit = %lu\",\n         (unsigned long)length,(unsigned long)limit);\n      png_chunk_error(png_ptr, \"chunk data is too large\");\n   }\n}", "target": 1}
{"code": "void SkiaOutputSurfaceImpl::Reshape(const gfx::Size& size,\n                                    float device_scale_factor,\n                                    const gfx::ColorSpace& color_space,\n                                    bool has_alpha,\n                                    bool use_stencil) {\n   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);\n   if (initialize_waitable_event_) {\n     initialize_waitable_event_->Wait();\n    initialize_waitable_event_ = nullptr;\n   }\n   SkSurfaceCharacterization* characterization = nullptr;\n   if (characterization_.isValid()) {\n    characterization_ =\n        characterization_.createResized(size.width(), size.height());\n     RecreateRootRecorder();\n   } else {\n     characterization = &characterization_;\n    initialize_waitable_event_ = std::make_unique<base::WaitableEvent>(\n        base::WaitableEvent::ResetPolicy::MANUAL,\n        base::WaitableEvent::InitialState::NOT_SIGNALED);\n  }\n  auto callback = base::BindOnce(\n      &SkiaOutputSurfaceImplOnGpu::Reshape,\n      base::Unretained(impl_on_gpu_.get()), size, device_scale_factor,\n      std::move(color_space), has_alpha, use_stencil, pre_transform_,\n      characterization, initialize_waitable_event_.get());\n  ScheduleGpuTask(std::move(callback), std::vector<gpu::SyncToken>());\n }", "target": 1}
{"code": "static int extractRDNSequence(struct ndpi_packet_struct *packet,\n\t\t\t      u_int offset, char *buffer, u_int buffer_len,\n\t\t\t      char *rdnSeqBuf, u_int *rdnSeqBuf_offset,\n\t\t\t      u_int rdnSeqBuf_len,\n\t\t\t      const char *label) {\n  u_int8_t str_len = packet->payload[offset+4], is_printable = 1;\n  char *str;\n  u_int len, j;\n  if((offset+4+str_len) >= packet->payload_packet_len)\n    return(-1);\n  str = (char*)&packet->payload[offset+5];\n  len = (u_int)ndpi_min(str_len, buffer_len-1);\n  strncpy(buffer, str, len);\n  buffer[len] = '\\0';\n  for(j = 0; j < len; j++) {\n    if(!ndpi_isprint(buffer[j])) {\n      is_printable = 0;\n      break;\n    }\n  }\n  if(is_printable) {\n    int rc = snprintf(&rdnSeqBuf[*rdnSeqBuf_offset],\n\t\t      rdnSeqBuf_len-(*rdnSeqBuf_offset),\n\t\t      \"%s%s=%s\", (*rdnSeqBuf_offset > 0) ? \", \" : \"\",\n\t\t      label, buffer);\n    if(rc > 0)\n      (*rdnSeqBuf_offset) += rc;\n  }\n  return(is_printable);\n}", "target": 1}
{"code": "fst_get_iface(struct fst_card_info *card, struct fst_port_info *port,\n\t      struct ifreq *ifr)\n{\n\tsync_serial_settings sync;\n\tint i;\n\tswitch (port->hwif) {\n\tcase E1:\n\t\tifr->ifr_settings.type = IF_IFACE_E1;\n\t\tbreak;\n\tcase T1:\n\t\tifr->ifr_settings.type = IF_IFACE_T1;\n\t\tbreak;\n\tcase V35:\n\t\tifr->ifr_settings.type = IF_IFACE_V35;\n\t\tbreak;\n\tcase V24:\n\t\tifr->ifr_settings.type = IF_IFACE_V24;\n\t\tbreak;\n\tcase X21D:\n\t\tifr->ifr_settings.type = IF_IFACE_X21D;\n\t\tbreak;\n\tcase X21:\n\tdefault:\n\t\tifr->ifr_settings.type = IF_IFACE_X21;\n\t\tbreak;\n\t}\n\tif (ifr->ifr_settings.size == 0) {\n\t\treturn 0;\t\n\t}\n\tif (ifr->ifr_settings.size < sizeof (sync)) {\n\t\treturn -ENOMEM;\n \t}\n \ti = port->index;\n \tsync.clock_rate = FST_RDL(card, portConfig[i].lineSpeed);\n \tsync.clock_type = FST_RDB(card, portConfig[i].internalClock) ==\n\t    INTCLK ? CLOCK_INT : CLOCK_EXT;\n\tsync.loopback = 0;\n\tif (copy_to_user(ifr->ifr_settings.ifs_ifsu.sync, &sync, sizeof (sync))) {\n\t\treturn -EFAULT;\n\t}\n\tifr->ifr_settings.size = sizeof (sync);\n\treturn 0;\n}", "target": 1}
{"code": "static avifBool avifParseImageGridBox(avifImageGrid * grid, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n    uint8_t version, flags;\n    CHECK(avifROStreamRead(&s, &version, 1)); \n    if (version != 0) {\n        return AVIF_FALSE;\n    }\n    CHECK(avifROStreamRead(&s, &flags, 1));         \n    CHECK(avifROStreamRead(&s, &grid->rows, 1));    \n    CHECK(avifROStreamRead(&s, &grid->columns, 1)); \n    ++grid->rows;\n    ++grid->columns;\n    uint32_t fieldLength = ((flags & 1) + 1) * 16;\n    if (fieldLength == 16) {\n        uint16_t outputWidth16, outputHeight16;\n        CHECK(avifROStreamReadU16(&s, &outputWidth16));  \n        CHECK(avifROStreamReadU16(&s, &outputHeight16)); \n        grid->outputWidth = outputWidth16;\n        grid->outputHeight = outputHeight16;\n    } else {\n        if (fieldLength != 32) {\n            return AVIF_FALSE;\n        }\n        CHECK(avifROStreamReadU32(&s, &grid->outputWidth));  \n        CHECK(avifROStreamReadU32(&s, &grid->outputHeight)); \n    }\n    return AVIF_TRUE;\n}", "target": 1}
{"code": "evbuffer_add(struct evbuffer *buf, const void *data_in, size_t datlen)\n{\n\tstruct evbuffer_chain *chain, *tmp;\n\tconst unsigned char *data = data_in;\n\tsize_t remain, to_alloc;\n\tint result = -1;\n\tEVBUFFER_LOCK(buf);\n\tif (buf->freeze_end) {\n\t\tgoto done;\n\t}\n\tchain = buf->last;\n\tif (chain == NULL) {\n\t\tchain = evbuffer_chain_new(datlen);\n\t\tif (!chain)\n\t\t\tgoto done;\n\t\tevbuffer_chain_insert(buf, chain);\n\t}\n\tif ((chain->flags & EVBUFFER_IMMUTABLE) == 0) {\n\t\tremain = (size_t)(chain->buffer_len - chain->misalign - chain->off);\n\t\tif (remain >= datlen) {\n\t\t\tmemcpy(chain->buffer + chain->misalign + chain->off,\n\t\t\t    data, datlen);\n\t\t\tchain->off += datlen;\n\t\t\tbuf->total_len += datlen;\n\t\t\tbuf->n_add_for_cb += datlen;\n\t\t\tgoto out;\n\t\t} else if (!CHAIN_PINNED(chain) &&\n\t\t    evbuffer_chain_should_realign(chain, datlen)) {\n\t\t\tevbuffer_chain_align(chain);\n\t\t\tmemcpy(chain->buffer + chain->off, data, datlen);\n\t\t\tchain->off += datlen;\n\t\t\tbuf->total_len += datlen;\n\t\t\tbuf->n_add_for_cb += datlen;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tremain = 0;\n\t}\n\tto_alloc = chain->buffer_len;\n\tif (to_alloc <= EVBUFFER_CHAIN_MAX_AUTO_SIZE/2)\n\t\tto_alloc <<= 1;\n\tif (datlen > to_alloc)\n\t\tto_alloc = datlen;\n\ttmp = evbuffer_chain_new(to_alloc);\n\tif (tmp == NULL)\n\t\tgoto done;\n\tif (remain) {\n\t\tmemcpy(chain->buffer + chain->misalign + chain->off,\n\t\t    data, remain);\n\t\tchain->off += remain;\n\t\tbuf->total_len += remain;\n\t\tbuf->n_add_for_cb += remain;\n\t}\n\tdata += remain;\n\tdatlen -= remain;\n\tmemcpy(tmp->buffer, data, datlen);\n\ttmp->off = datlen;\n\tevbuffer_chain_insert(buf, tmp);\n\tbuf->n_add_for_cb += datlen;\nout:\n\tevbuffer_invoke_callbacks(buf);\n\tresult = 0;\ndone:\n\tEVBUFFER_UNLOCK(buf);\n\treturn result;\n}", "target": 1}
{"code": "allocate_trace_buffer(struct trace_array *tr, struct trace_buffer *buf, int size)\n{\n\tenum ring_buffer_flags rb_flags;\n\trb_flags = tr->trace_flags & TRACE_ITER_OVERWRITE ? RB_FL_OVERWRITE : 0;\n\tbuf->tr = tr;\n\tbuf->buffer = ring_buffer_alloc(size, rb_flags);\n\tif (!buf->buffer)\n\t\treturn -ENOMEM;\n\tbuf->data = alloc_percpu(struct trace_array_cpu);\n\tif (!buf->data) {\n\t\tring_buffer_free(buf->buffer);\n\t\treturn -ENOMEM;\n\t}\n\tset_buffer_entries(&tr->trace_buffer,\n\t\t\t   ring_buffer_size(tr->trace_buffer.buffer, 0));\n\treturn 0;\n}", "target": 1}
{"code": "includeFile(FileInfo *nested, CharsString *includedFile,\n\t\tCharacterClass **characterClasses,\n\t\tTranslationTableCharacterAttributes *characterClassAttribute,\n\t\tshort opcodeLengths[], TranslationTableOffset *newRuleOffset,\n\t\tTranslationTableRule **newRule, RuleName **ruleNames,\n\t\tTranslationTableHeader **table) {\n\tint k;\n\tchar includeThis[MAXSTRING];\n\tchar **tableFiles;\n\tint rv;\n\tfor (k = 0; k < includedFile->length; k++)\n\t\tincludeThis[k] = (char)includedFile->chars[k];\n\tincludeThis[k] = 0;\n\ttableFiles = _lou_resolveTable(includeThis, nested->fileName);\n\tif (tableFiles == NULL) {\n\t\terrorCount++;\n\t\treturn 0;\n\t}\n\tif (tableFiles[1] != NULL) {\n\t\terrorCount++;\n\t\tfree_tablefiles(tableFiles);\n\t\t_lou_logMessage(LOG_ERROR,\n\t\t\t\t\"Table list not supported in include statement: 'include %s'\",\n\t\t\t\tincludeThis);\n\t\treturn 0;\n\t}\n\trv = compileFile(*tableFiles, characterClasses, characterClassAttribute,\n\t\t\topcodeLengths, newRuleOffset, newRule, ruleNames, table);\n\tfree_tablefiles(tableFiles);\n\treturn rv;\n}", "target": 1}
{"code": "void WebUIExtension::Send(gin::Arguments* args) {\n  blink::WebLocalFrame* frame;\n  RenderFrame* render_frame;\n  if (!ShouldRespondToRequest(&frame, &render_frame))\n    return;\n  std::string message;\n  if (!args->GetNext(&message)) {\n    args->ThrowError();\n    return;\n  }\n  if (base::EndsWith(message, \"RequiringGesture\",\n                     base::CompareCase::SENSITIVE) &&\n      !blink::WebUserGestureIndicator::IsProcessingUserGesture(frame)) {\n    NOTREACHED();\n    return;\n  }\n  std::unique_ptr<base::ListValue> content;\n  if (args->PeekNext().IsEmpty() || args->PeekNext()->IsUndefined()) {\n    content.reset(new base::ListValue());\n  } else {\n    v8::Local<v8::Object> obj;\n    if (!args->GetNext(&obj)) {\n      args->ThrowError();\n      return;\n    }\n     content = base::ListValue::From(V8ValueConverter::Create()->FromV8Value(\n         obj, frame->MainWorldScriptContext()));\n     DCHECK(content);\n   }\n  render_frame->Send(new FrameHostMsg_WebUISend(render_frame->GetRoutingID(),\n                                                frame->GetDocument().Url(),\n                                                message, *content));\n}", "target": 1}
{"code": "njs_vmcode_typeof(njs_vm_t *vm, njs_value_t *value, njs_value_t *invld)\n{\n    static const njs_value_t  *types[NJS_VALUE_TYPE_MAX] = {\n        &njs_string_object,\n        &njs_string_undefined,\n        &njs_string_boolean,\n        &njs_string_number,\n        &njs_string_symbol,\n        &njs_string_string,\n        &njs_string_data,\n        &njs_string_external,\n        &njs_string_invalid,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_function,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n    };\n    vm->retval = *types[value->type];\n    return sizeof(njs_vmcode_2addr_t);\n}", "target": 1}
{"code": "void GpuDataManager::UpdateGpuInfo(const GPUInfo& gpu_info) {\n  {\n     base::AutoLock auto_lock(gpu_info_lock_);\n     if (!gpu_info_.Merge(gpu_info))\n       return;\n    RunGpuInfoUpdateCallbacks();\n     content::GetContentClient()->SetGpuInfo(gpu_info_);\n   }\n  UpdateGpuFeatureFlags();\n}", "target": 1}
{"code": "secret (gcry_mpi_t output, gcry_mpi_t input, RSA_secret_key *skey )\n{\n  mpi_normalize (input);\n  if (!skey->p || !skey->q || !skey->u)\n    {\n      mpi_powm (output, input, skey->d, skey->n);\n    }\n  else\n    {\n      gcry_mpi_t m1 = mpi_alloc_secure( mpi_get_nlimbs(skey->n)+1 );\n      gcry_mpi_t m2 = mpi_alloc_secure( mpi_get_nlimbs(skey->n)+1 );\n      gcry_mpi_t h  = mpi_alloc_secure( mpi_get_nlimbs(skey->n)+1 );\n      mpi_sub_ui( h, skey->p, 1  );\n      mpi_fdiv_r( h, skey->d, h );\n      mpi_powm( m1, input, h, skey->p );\n      mpi_sub_ui( h, skey->q, 1  );\n      mpi_fdiv_r( h, skey->d, h );\n      mpi_powm( m2, input, h, skey->q );\n      mpi_sub( h, m2, m1 );\n      if ( mpi_has_sign ( h ) )\n        mpi_add ( h, h, skey->q );\n      mpi_mulm( h, skey->u, h, skey->q );\n      mpi_mul ( h, h, skey->p );\n      mpi_add ( output, m1, h );\n      mpi_free ( h );\n      mpi_free ( m1 );\n      mpi_free ( m2 );\n    }\n}", "target": 1}
{"code": "srs_timestamp_check(srs_t *srs, const char *stamp)\n{\n\tconst char\t*sp;\n\tchar\t\t*bp;\n\tint\t\t\t off;\n\ttime_t\t\t now;\n\ttime_t\t\t then;\n\tthen = 0;\n\tfor (sp = stamp; *sp; sp++) {\n\t\tbp = strchr(SRS_TIME_BASECHARS, toupper(*sp));\n\t\tif (bp == NULL)\n\t\t\treturn SRS_EBADTIMESTAMPCHAR;\n\t\toff = bp - SRS_TIME_BASECHARS;\n\t\tthen = (then << SRS_TIME_BASEBITS) | off;\n\t}\n\ttime(&now);\n\tnow = (now / SRS_TIME_PRECISION) % SRS_TIME_SLOTS;\n\twhile (now < then)\n\t\tnow = now + SRS_TIME_SLOTS;\n\tif (now <= then + srs->maxage)\n\t\treturn SRS_SUCCESS;\n\treturn SRS_ETIMESTAMPOUTOFDATE;\n}", "target": 1}
{"code": "udisks_log (UDisksLogLevel     level,\n            const gchar       *function,\n            const gchar       *location,\n            const gchar       *format,\n            ...)\n{\n  va_list var_args;\n  gchar *message;\n  va_start (var_args, format);\n  message = g_strdup_vprintf (format, var_args);\n  va_end (var_args);\n#if GLIB_CHECK_VERSION(2, 50, 0)\n  g_log_structured (\"udisks\", (GLogLevelFlags) level,\n                    \"MESSAGE\", message, \"THREAD_ID\", \"%d\", (gint) syscall (SYS_gettid),\n                    \"CODE_FUNC\", function, \"CODE_FILE\", location);\n#else\n  g_log (\"udisks\", level, \"[%d]: %s [%s, %s()]\", (gint) syscall (SYS_gettid), message, location, function);\n#endif\n  g_free (message);\n}", "target": 1}
{"code": "xid_map_enter(netdissect_options *ndo,\n              const struct sunrpc_msg *rp, const u_char *bp)\n{\n\tconst struct ip *ip = NULL;\n\tconst struct ip6_hdr *ip6 = NULL;\n\tstruct xid_map_entry *xmep;\n\tif (!ND_TTEST(rp->rm_call.cb_vers))\n\t\treturn (0);\n\tswitch (IP_V((const struct ip *)bp)) {\n\tcase 4:\n\t\tip = (const struct ip *)bp;\n\t\tbreak;\n\tcase 6:\n\t\tip6 = (const struct ip6_hdr *)bp;\n\t\tbreak;\n\tdefault:\n\t\treturn (1);\n\t}\n\txmep = &xid_map[xid_map_next];\n\tif (++xid_map_next >= XIDMAPSIZE)\n\t\txid_map_next = 0;\n\tUNALIGNED_MEMCPY(&xmep->xid, &rp->rm_xid, sizeof(xmep->xid));\n\tif (ip) {\n\t\txmep->ipver = 4;\n\t\tUNALIGNED_MEMCPY(&xmep->client, &ip->ip_src, sizeof(ip->ip_src));\n\t\tUNALIGNED_MEMCPY(&xmep->server, &ip->ip_dst, sizeof(ip->ip_dst));\n\t}\n\telse if (ip6) {\n\t\txmep->ipver = 6;\n \t\tUNALIGNED_MEMCPY(&xmep->client, &ip6->ip6_src, sizeof(ip6->ip6_src));\n \t\tUNALIGNED_MEMCPY(&xmep->server, &ip6->ip6_dst, sizeof(ip6->ip6_dst));\n \t}\n \txmep->proc = EXTRACT_32BITS(&rp->rm_call.cb_proc);\n \txmep->vers = EXTRACT_32BITS(&rp->rm_call.cb_vers);\n \treturn (1);\n }", "target": 1}
{"code": "rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)\n {\n \tint phy_addr;\n \tstruct netdev_private *np = netdev_priv(dev);\n\tstruct mii_data *miidata = (struct mii_data *) &rq->ifr_ifru;\n\tstruct netdev_desc *desc;\n\tint i;\n \tphy_addr = np->phy_addr;\n \tswitch (cmd) {\n\tcase SIOCDEVPRIVATE:\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 1:\n\t\tmiidata->out_value = mii_read (dev, phy_addr, miidata->reg_num);\n \t\tbreak;\n\tcase SIOCDEVPRIVATE + 2:\n\t\tmii_write (dev, phy_addr, miidata->reg_num, miidata->in_value);\n \t\tbreak;\n\tcase SIOCDEVPRIVATE + 3:\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 4:\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 5:\n\t\tnetif_stop_queue (dev);\n \t\tbreak;\n\tcase SIOCDEVPRIVATE + 6:\n\t\tnetif_wake_queue (dev);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 7:\n\t\tprintk\n\t\t    (\"tx_full=%x cur_tx=%lx old_tx=%lx cur_rx=%lx old_rx=%lx\\n\",\n\t\t     netif_queue_stopped(dev), np->cur_tx, np->old_tx, np->cur_rx,\n\t\t     np->old_rx);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 8:\n\t\tprintk(\"TX ring:\\n\");\n\t\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\t\tdesc = &np->tx_ring[i];\n\t\t\tprintk\n\t\t\t    (\"%02x:cur:%08x next:%08x status:%08x frag1:%08x frag0:%08x\",\n\t\t\t     i,\n\t\t\t     (u32) (np->tx_ring_dma + i * sizeof (*desc)),\n\t\t\t     (u32)le64_to_cpu(desc->next_desc),\n\t\t\t     (u32)le64_to_cpu(desc->status),\n\t\t\t     (u32)(le64_to_cpu(desc->fraginfo) >> 32),\n\t\t\t     (u32)le64_to_cpu(desc->fraginfo));\n\t\t\tprintk (\"\\n\");\n\t\t}\n\t\tprintk (\"\\n\");\n\t\tbreak;\n \tdefault:\n \t\treturn -EOPNOTSUPP;\n \t}\n\treturn 0;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    StagingMap<Ordered>* map = nullptr;\n    OP_REQUIRES_OK(ctx, GetStagingMap(ctx, def(), &map));\n    core::ScopedUnref scope(map);\n    typename StagingMap<Ordered>::OptionalTuple tuple;\n    const Tensor* key_tensor;\n    const Tensor* indices_tensor;\n    OpInputList values_tensor;\n    OP_REQUIRES_OK(ctx, ctx->input(\"key\", &key_tensor));\n    OP_REQUIRES_OK(ctx, ctx->input(\"indices\", &indices_tensor));\n    OP_REQUIRES_OK(ctx, ctx->input_list(\"values\", &values_tensor));\n    Tensor key(*key_tensor);\n    for (std::size_t i = 0; i < values_tensor.size(); ++i) {\n      tuple.push_back(values_tensor[i]);\n    }\n    OP_REQUIRES_OK(ctx, map->put(&key, indices_tensor, &tuple));\n  }", "target": 1}
{"code": "static int asn1_d2i_ex_primitive(ASN1_VALUE **pval,\n static int asn1_template_ex_d2i(ASN1_VALUE **pval,\n                                 const unsigned char **in, long len,\n                                 const ASN1_TEMPLATE *tt, char opt,\n                                ASN1_TLC *ctx);\n static int asn1_template_noexp_d2i(ASN1_VALUE **val,\n                                    const unsigned char **in, long len,\n                                    const ASN1_TEMPLATE *tt, char opt,\n                                   ASN1_TLC *ctx);\n static int asn1_d2i_ex_primitive(ASN1_VALUE **pval,\n                                  const unsigned char **in, long len,\n                                  const ASN1_ITEM *it,\n    B_ASN1_OCTET_STRING, 0, 0, B_ASN1_UNKNOWN,\n    B_ASN1_UNKNOWN, B_ASN1_UNKNOWN, B_ASN1_UNKNOWN, B_ASN1_UNKNOWN,\n    B_ASN1_UTF8STRING, B_ASN1_UNKNOWN, B_ASN1_UNKNOWN, B_ASN1_UNKNOWN,\n    B_ASN1_SEQUENCE, 0, B_ASN1_NUMERICSTRING, B_ASN1_PRINTABLESTRING,\n    B_ASN1_T61STRING, B_ASN1_VIDEOTEXSTRING, B_ASN1_IA5STRING,\n    B_ASN1_UTCTIME, B_ASN1_GENERALIZEDTIME,\n    B_ASN1_GRAPHICSTRING, B_ASN1_ISO64STRING, B_ASN1_GENERALSTRING,\n    B_ASN1_UNIVERSALSTRING, B_ASN1_UNKNOWN, B_ASN1_BMPSTRING, B_ASN1_UNKNOWN,\n};\nunsigned long ASN1_tag2bit(int tag)\n{", "target": 1}
{"code": "table_regex_match(const char *string, const char *pattern)\n{\n\tregex_t preg;\n\tint\tcflags = REG_EXTENDED|REG_NOSUB;\n\tif (strncmp(pattern, \"(?i)\", 4) == 0) {\n\t\tcflags |= REG_ICASE;\n\t\tpattern += 4;\n\t}\n\tif (regcomp(&preg, pattern, cflags) != 0)\n\t\treturn (0);\n\tif (regexec(&preg, string, 0, NULL, 0) != 0)\n\t\treturn (0);\n\treturn (1);\n}", "target": 1}
{"code": " void HTMLImportsController::Dispose() {\n  for (const auto& loader : loaders_)\n    loader->Dispose();\n  loaders_.clear();\n   if (root_) {\n     root_->Dispose();\n    root_.Clear();\n  }\n}", "target": 1}
{"code": "static void listdir(unsigned int depth, int f, void * const tls_fd,\n                    const char *name)\n{\n    PureFileInfo *dir;\n    char *names;\n    PureFileInfo *s;\n    PureFileInfo *r;\n    int d;\n    if (depth >= max_ls_depth || matches >= max_ls_files) {\n        return;\n    }\n    if ((dir = sreaddir(&names)) == NULL) {\n        addreply(226, MSG_CANT_READ_FILE, name);\n        return;\n    }\n    s = dir;\n    while (s->name_offset != (size_t) -1) {\n        d = 0;\n        if (FI_NAME(s)[0] != '.') {\n            d = listfile(s, NULL);\n        } else if (opt_a) {\n            if (FI_NAME(s)[1] == 0 ||\n                (FI_NAME(s)[1] == '.' && FI_NAME(s)[2] == 0)) {\n                listfile(s, NULL);\n            } else {\n                d = listfile(s, NULL);\n            }\n        }\n        if (!d) {\n            s->name_offset = (size_t) -1;\n        }\n        s++;\n    }\n    outputfiles(f, tls_fd);\n    r = dir;\n    while (opt_R && r != s) {\n        if (r->name_offset != (size_t) -1 && !chdir(FI_NAME(r))) {\n            char *alloca_subdir;\n            const size_t sizeof_subdir = PATH_MAX + 1U;\n            if ((alloca_subdir = ALLOCA(sizeof_subdir)) == NULL) {\n                goto toomany;\n            }\n            if (SNCHECK(snprintf(alloca_subdir, sizeof_subdir, \"%s/%s\",\n                                 name, FI_NAME(r)), sizeof_subdir)) {\n                goto nolist;\n            }\n            wrstr(f, tls_fd, \"\\r\\n\\r\\n\");\n            wrstr(f, tls_fd, alloca_subdir);\n            wrstr(f, tls_fd, \":\\r\\n\\r\\n\");\n            listdir(depth + 1U, f, tls_fd, alloca_subdir);\n            nolist:\n            ALLOCA_FREE(alloca_subdir);\n            if (matches >= max_ls_files) {\n                goto toomany;\n            }\n            if (chdir(\"..\")) {    \n                if (chdir(wd) || chdir(name)) {    \n                    die(421, LOG_ERR, \"chdir: %s\", strerror(errno));\n                }\n            }\n        }\n        r++;\n    }\n    toomany:\n    free(names);\n    free(dir);\n    names = NULL;\n}", "target": 1}
{"code": "String UTF16BEDecoder::to_utf8(const StringView& input)\n{\n    StringBuilder builder(input.length() / 2);\n    for (size_t i = 0; i < input.length(); i += 2) {\n        u16 code_point = (input[i] << 8) | input[i + 1];\n        builder.append_code_point(code_point);\n    }\n    return builder.to_string();\n}", "target": 1}
{"code": "static inline int ip6_ufo_append_data(struct sock *sk,\n\t\t\tint getfrag(void *from, char *to, int offset, int len,\n\t\t\tint odd, struct sk_buff *skb),\n\t\t\tvoid *from, int length, int hh_len, int fragheaderlen,\n\t\t\tint transhdrlen, int mtu,unsigned int flags,\n\t\t\tstruct rt6_info *rt)\n {\n \tstruct sk_buff *skb;\n \tint err;\n \tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {\n\t\tstruct frag_hdr fhdr;\n \t\tskb = sock_alloc_send_skb(sk,\n \t\t\thh_len + fragheaderlen + transhdrlen + 20,\n \t\t\t(flags & MSG_DONTWAIT), &err);\n\t\tif (skb == NULL)\n\t\t\treturn err;\n\t\tskb_reserve(skb, hh_len);\n\t\tskb_put(skb,fragheaderlen + transhdrlen);\n\t\tskb_reset_network_header(skb);\n \t\tskb->transport_header = skb->network_header + fragheaderlen;\n \t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n \t\tskb->csum = 0;\n\t\tskb_shinfo(skb)->gso_size = (mtu - fragheaderlen -\n\t\t\t\t\t     sizeof(struct frag_hdr)) & ~7;\n\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\t\tipv6_select_ident(&fhdr, rt);\n\t\tskb_shinfo(skb)->ip6_frag_id = fhdr.identification;\n \t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n \t}\n \treturn skb_append_datato_frags(sk, skb, getfrag, from,\n \t\t\t\t       (length - transhdrlen));\n }", "target": 1}
{"code": "TfLiteStatus GenericPrepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLitePoolParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  int batches = input->dims->data[0];\n  int height = input->dims->data[1];\n  int width = input->dims->data[2];\n  int channels_out = input->dims->data[3];\n  auto padding = params->padding;\n  int out_width, out_height;\n  data->padding = ComputePaddingHeightWidth(\n      params->stride_height, params->stride_width, 1, 1, height, width,\n      params->filter_height, params->filter_width, padding, &out_height,\n      &out_width);\n  if (input->type == kTfLiteUInt8 || input->type == kTfLiteInt8) {\n    if (pool_type == kAverage || pool_type == kMax) {\n      TFLITE_DCHECK_LE(std::abs(input->params.scale - output->params.scale),\n                       1.0e-6);\n      TFLITE_DCHECK_EQ(input->params.zero_point, output->params.zero_point);\n    }\n    if (pool_type == kL2) {\n      TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteFloat32);\n    }\n  }\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(4);\n  output_size->data[0] = batches;\n  output_size->data[1] = out_height;\n  output_size->data[2] = out_width;\n  output_size->data[3] = channels_out;\n  return context->ResizeTensor(context, output, output_size);\n}", "target": 1}
{"code": " tbGetBuffer(unsigned size)\n {\n    char *rtrn;\n    if (size >= BUFFER_SIZE)\n        return NULL;\n    if ((BUFFER_SIZE - tbNext) <= size)\n        tbNext = 0;\n    rtrn = &textBuffer[tbNext];\n    tbNext += size;\n    return rtrn;\n }", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    Buffer* buf = nullptr;\n    OP_REQUIRES_OK(ctx, GetBuffer(ctx, def(), &buf));\n    core::ScopedUnref scope(buf);\n    Buffer::Tuple tuple;\n    std::size_t index = ctx->input(0).scalar<int>()();\n    OP_REQUIRES_OK(ctx, buf->Peek(index, &tuple));\n    OP_REQUIRES(\n        ctx, tuple.size() == (size_t)ctx->num_outputs(),\n        errors::InvalidArgument(\"Mismatch stage/unstage: \", tuple.size(),\n                                \" vs. \", ctx->num_outputs()));\n    for (size_t i = 0; i < tuple.size(); ++i) {\n      ctx->set_output(i, tuple[i]);\n    }\n  }", "target": 1}
{"code": "static bool get_build_id(\n Backtrace* backtrace, uintptr_t base_addr, uint8_t* e_ident, std::string* build_id) {\n HdrType hdr;\n  memcpy(&hdr.e_ident[0], e_ident, EI_NIDENT);\n if (backtrace->Read(base_addr + EI_NIDENT, reinterpret_cast<uint8_t*>(&hdr) + EI_NIDENT,\n sizeof(HdrType) - EI_NIDENT) != sizeof(HdrType) - EI_NIDENT) {\n return false;\n }\n for (size_t i = 0; i < hdr.e_phnum; i++) {\n PhdrType phdr;\n if (backtrace->Read(base_addr + hdr.e_phoff + i * hdr.e_phentsize,\n reinterpret_cast<uint8_t*>(&phdr), sizeof(phdr)) != sizeof(phdr)) {\n return false;\n }\n if (phdr.p_type == PT_NOTE) {\n size_t hdr_size = phdr.p_filesz;\n uintptr_t addr = base_addr + phdr.p_offset;\n while (hdr_size >= sizeof(NhdrType)) {\n NhdrType nhdr;\n if (backtrace->Read(addr, reinterpret_cast<uint8_t*>(&nhdr), sizeof(nhdr)) != sizeof(nhdr)) {\n return false;\n }\n        addr += sizeof(nhdr);\n         if (nhdr.n_type == NT_GNU_BUILD_ID) {\n           addr += NOTE_ALIGN(nhdr.n_namesz);\n          uint8_t build_id_data[128];\n          if (nhdr.n_namesz > sizeof(build_id_data)) {\n            ALOGE(\"Possible corrupted note, name size value is too large: %u\",\n                  nhdr.n_namesz);\n             return false;\n           }\n           if (backtrace->Read(addr, build_id_data, nhdr.n_descsz) != nhdr.n_descsz) {\n return false;\n }\n          build_id->clear();\n for (size_t bytes = 0; bytes < nhdr.n_descsz; bytes++) {\n *build_id += android::base::StringPrintf(\"%02x\", build_id_data[bytes]);\n }\n return true;\n } else {\n          hdr_size -= sizeof(nhdr);\n size_t skip_bytes = NOTE_ALIGN(nhdr.n_namesz) + NOTE_ALIGN(nhdr.n_descsz);\n          addr += skip_bytes;\n if (hdr_size < skip_bytes) {\n break;\n }\n          hdr_size -= skip_bytes;\n }\n }\n }\n }\n return false;\n}", "target": 1}
{"code": "mark_context_stack(mrb_state *mrb, struct mrb_context *c)\n {\n   size_t i;\n   size_t e;\n   if (c->stack == NULL) return;\n   e = c->stack - c->stbase;\n  if (c->ci) e += c->ci->nregs;\n  if (c->stbase + e > c->stend) e = c->stend - c->stbase;\n  for (i=0; i<e; i++) {\n     mrb_value v = c->stbase[i];\n     if (!mrb_immediate_p(v)) {\n      if (mrb_basic_ptr(v)->tt == MRB_TT_FREE) {\n        c->stbase[i] = mrb_nil_value();\n      }\n      else {\n        mrb_gc_mark(mrb, mrb_basic_ptr(v));\n      }\n     }\n   }\n }", "target": 1}
{"code": "bool Scanner::fill(size_t need)\n{\n    if (eof) return false;\n    pop_finished_files();\n    DASSERT(bot <= tok && tok <= lim);\n    size_t free = static_cast<size_t>(tok - bot);\n    size_t copy = static_cast<size_t>(lim - tok);\n    if (free >= need) {\n        memmove(bot, tok, copy);\n        shift_ptrs_and_fpos(-static_cast<ptrdiff_t>(free));\n    }\n    else {\n        BSIZE += std::max(BSIZE, need);\n        char * buf = new char[BSIZE + YYMAXFILL];\n        if (!buf) fatal(\"out of memory\");\n        memmove(buf, tok, copy);\n        shift_ptrs_and_fpos(buf - bot);\n        delete [] bot;\n        bot = buf;\n        free = BSIZE - copy;\n    }\n    if (!read(free)) {\n        eof = lim;\n        memset(lim, 0, YYMAXFILL);\n        lim += YYMAXFILL;\n    }\n    return true;\n}", "target": 1}
{"code": " NativeBrowserFrame* NativeBrowserFrame::CreateNativeBrowserFrame(\n     BrowserFrame* browser_frame,\n     BrowserView* browser_view) {\n  if (views::Widget::IsPureViews())\n     return new BrowserFrameViews(browser_frame, browser_view);\n   return new BrowserFrameGtk(browser_frame, browser_view);\n }", "target": 1}
{"code": "bool HTMLFormControlElement::isAutofocusable() const\n {\n    if (!fastHasAttribute(autofocusAttr))\n        return false;\n    if (hasTagName(inputTag))\n        return !toHTMLInputElement(this)->isInputTypeHidden();\n    if (hasTagName(selectTag))\n        return true;\n    if (hasTagName(keygenTag))\n        return true;\n    if (hasTagName(buttonTag))\n        return true;\n    if (hasTagName(textareaTag))\n        return true;\n     return false;\n }", "target": 1}
{"code": "static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb, u32 features)\n{\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tunsigned int mss;\n\tunsigned int unfrag_ip6hlen, unfrag_len;\n\tstruct frag_hdr *fptr;\n\tu8 *mac_start, *prevhdr;\n\tu8 nexthdr;\n\tu8 frag_hdr_sz = sizeof(struct frag_hdr);\n\tint offset;\n\t__wsum csum;\n\tmss = skb_shinfo(skb)->gso_size;\n\tif (unlikely(skb->len <= mss))\n\t\tgoto out;\n\tif (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {\n\t\tint type = skb_shinfo(skb)->gso_type;\n\t\tif (unlikely(type & ~(SKB_GSO_UDP | SKB_GSO_DODGY) ||\n\t\t\t     !(type & (SKB_GSO_UDP))))\n\t\t\tgoto out;\n\t\tskb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss);\n\t\tsegs = NULL;\n\t\tgoto out;\n\t}\n\toffset = skb->csum_start - skb_headroom(skb);\n\tcsum = skb_checksum(skb, offset, skb->len- offset, 0);\n\toffset += skb->csum_offset;\n\t*(__sum16 *)(skb->data + offset) = csum_fold(csum);\n \tskb->ip_summed = CHECKSUM_NONE;\n\tif ((skb_headroom(skb) < frag_hdr_sz) &&\n \t    pskb_expand_head(skb, frag_hdr_sz, 0, GFP_ATOMIC))\n \t\tgoto out;\n\tunfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);\n\tnexthdr = *prevhdr;\n\t*prevhdr = NEXTHDR_FRAGMENT;\n\tunfrag_len = skb_network_header(skb) - skb_mac_header(skb) +\n\t\t     unfrag_ip6hlen;\n\tmac_start = skb_mac_header(skb);\n\tmemmove(mac_start-frag_hdr_sz, mac_start, unfrag_len);\n\tskb->mac_header -= frag_hdr_sz;\n\tskb->network_header -= frag_hdr_sz;\n\tfptr = (struct frag_hdr *)(skb_network_header(skb) + unfrag_ip6hlen);\n\tfptr->nexthdr = nexthdr;\n\tfptr->reserved = 0;\n\tipv6_select_ident(fptr);\n\tsegs = skb_segment(skb, features);\nout:\n\treturn segs;\n}", "target": 1}
{"code": "static ssize_t driver_override_show(struct device *_dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct amba_device *dev = to_amba_device(_dev);\n\treturn sprintf(buf, \"%s\\n\", dev->driver_override);\n}", "target": 1}
{"code": "hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tunsigned long orun = 1;\n\tktime_t delta;\n\tdelta = ktime_sub(now, timer->expires);\n\tif (delta.tv64 < 0)\n\t\treturn 0;\n\tif (interval.tv64 < timer->base->resolution.tv64)\n\t\tinterval.tv64 = timer->base->resolution.tv64;\n\tif (unlikely(delta.tv64 >= interval.tv64)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\t\torun = ktime_divns(delta, incr);\n\t\ttimer->expires = ktime_add_ns(timer->expires, incr * orun);\n\t\tif (timer->expires.tv64 > now.tv64)\n\t\t\treturn orun;\n\t\torun++;\n\t}\n\ttimer->expires = ktime_add(timer->expires, interval);\n\treturn orun;\n}", "target": 1}
{"code": "static ssize_t usbip_sockfd_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct stub_device *sdev = dev_get_drvdata(dev);\n\tint sockfd = 0;\n\tstruct socket *socket;\n\tint rv;\n\tif (!sdev) {\n\t\tdev_err(dev, \"sdev is null\\n\");\n\t\treturn -ENODEV;\n\t}\n\trv = sscanf(buf, \"%d\", &sockfd);\n\tif (rv != 1)\n\t\treturn -EINVAL;\n\tif (sockfd != -1) {\n\t\tint err;\n\t\tdev_info(dev, \"stub up\\n\");\n\t\tspin_lock_irq(&sdev->ud.lock);\n\t\tif (sdev->ud.status != SDEV_ST_AVAILABLE) {\n\t\t\tdev_err(dev, \"not ready\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\tsocket = sockfd_lookup(sockfd, &err);\n\t\tif (!socket) {\n\t\t\tdev_err(dev, \"failed to lookup sock\");\n\t\t\tgoto err;\n\t\t}\n\t\tif (socket->type != SOCK_STREAM) {\n\t\t\tdev_err(dev, \"Expecting SOCK_STREAM - found %d\",\n\t\t\t\tsocket->type);\n\t\t\tgoto sock_err;\n\t\t}\n\t\tsdev->ud.tcp_socket = socket;\n\t\tsdev->ud.sockfd = sockfd;\n\t\tspin_unlock_irq(&sdev->ud.lock);\n\t\tsdev->ud.tcp_rx = kthread_get_run(stub_rx_loop, &sdev->ud,\n\t\t\t\t\t\t  \"stub_rx\");\n\t\tsdev->ud.tcp_tx = kthread_get_run(stub_tx_loop, &sdev->ud,\n\t\t\t\t\t\t  \"stub_tx\");\n\t\tspin_lock_irq(&sdev->ud.lock);\n\t\tsdev->ud.status = SDEV_ST_USED;\n\t\tspin_unlock_irq(&sdev->ud.lock);\n\t} else {\n\t\tdev_info(dev, \"stub down\\n\");\n\t\tspin_lock_irq(&sdev->ud.lock);\n\t\tif (sdev->ud.status != SDEV_ST_USED)\n\t\t\tgoto err;\n\t\tspin_unlock_irq(&sdev->ud.lock);\n\t\tusbip_event_add(&sdev->ud, SDEV_EVENT_DOWN);\n\t}\n\treturn count;\nsock_err:\n\tsockfd_put(socket);\nerr:\n\tspin_unlock_irq(&sdev->ud.lock);\n\treturn -EINVAL;\n}", "target": 1}
{"code": "static int ccid3_hc_tx_getsockopt(struct sock *sk, const int optname, int len,\n\t\t\t\t  u32 __user *optval, int __user *optlen)\n{\n\tconst struct ccid3_hc_tx_sock *hc = ccid3_hc_tx_sk(sk);\n\tstruct tfrc_tx_info tfrc;\n\tconst void *val;\n\tswitch (optname) {\n \tcase DCCP_SOCKOPT_CCID_TX_INFO:\n \t\tif (len < sizeof(tfrc))\n \t\t\treturn -EINVAL;\n \t\ttfrc.tfrctx_x\t   = hc->tx_x;\n \t\ttfrc.tfrctx_x_recv = hc->tx_x_recv;\n \t\ttfrc.tfrctx_x_calc = hc->tx_x_calc;\n\t\ttfrc.tfrctx_rtt\t   = hc->tx_rtt;\n\t\ttfrc.tfrctx_p\t   = hc->tx_p;\n\t\ttfrc.tfrctx_rto\t   = hc->tx_t_rto;\n\t\ttfrc.tfrctx_ipi\t   = hc->tx_t_ipi;\n\t\tlen = sizeof(tfrc);\n\t\tval = &tfrc;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\tif (put_user(len, optlen) || copy_to_user(optval, val, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& in0 = ctx->input(0);\n    const Tensor& in1 = ctx->input(1);\n    ValidateInputTensors(ctx, in0, in1);\n    MatMulBCast bcast(in0.shape().dim_sizes(), in1.shape().dim_sizes());\n    OP_REQUIRES(\n        ctx, bcast.IsValid(),\n        errors::InvalidArgument(\n            \"In[0] and In[1] must have compatible batch dimensions: \",\n            in0.shape().DebugString(), \" vs. \", in1.shape().DebugString()));\n    TensorShape out_shape = bcast.output_batch_shape();\n    auto batch_size = bcast.output_batch_size();\n    auto d0 = in0.dim_size(in0.dims() - 2);  \n    auto d1 = in0.dim_size(in0.dims() - 1);\n    Tensor in0_reshaped;\n    OP_REQUIRES(\n        ctx,\n        in0_reshaped.CopyFrom(in0, TensorShape({bcast.x_batch_size(), d0, d1})),\n        errors::Internal(\"Failed to reshape In[0] from \",\n                         in0.shape().DebugString()));\n    auto d2 = in1.dim_size(in1.dims() - 2);\n    auto d3 = in1.dim_size(in1.dims() - 1);\n    Tensor in1_reshaped;\n    OP_REQUIRES(\n        ctx,\n        in1_reshaped.CopyFrom(in1, TensorShape({bcast.y_batch_size(), d2, d3})),\n        errors::Internal(\"Failed to reshape In[1] from \",\n                         in1.shape().DebugString()));\n    OP_REQUIRES(ctx, d1 == d2,\n                errors::InvalidArgument(\n                    \"In[0] mismatch In[1] shape: \", d1, \" vs. \", d2, \": \",\n                    in0.shape().DebugString(), \" \", in1.shape().DebugString(),\n                    \" \", lower_, \" \", adjoint_));\n    out_shape.AddDim(d1);\n    out_shape.AddDim(d3);\n    Tensor* out = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, out_shape, &out));\n    if (out->NumElements() == 0) {\n      return;\n    }\n    Tensor out_reshaped;\n    OP_REQUIRES(ctx,\n                out_reshaped.CopyFrom(*out, TensorShape({batch_size, d1, d3})),\n                errors::Internal(\"Failed to reshape output from \",\n                                 out->shape().DebugString()));\n    LaunchBatchBandedTriangularSolve<Scalar>::Launch(\n        ctx, in0_reshaped, in1_reshaped, adjoint_, lower_, bcast,\n        &out_reshaped);\n  }", "target": 1}
{"code": "static inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_esn,\n\t\t\t\t\t struct nlattr *rp)\n{\n\tstruct xfrm_replay_state_esn *up;\n\tint ulen;\n\tif (!replay_esn || !rp)\n\t\treturn 0;\n\tup = nla_data(rp);\n\tulen = xfrm_replay_state_esn_len(up);\n \tif (nla_len(rp) < ulen || xfrm_replay_state_esn_len(replay_esn) != ulen)\n \t\treturn -EINVAL;\n \treturn 0;\n }", "target": 1}
{"code": "_gdata_service_build_session (void)\n{\n\tSoupSession *session = soup_session_sync_new ();\n#ifdef HAVE_GNOME\n\tsoup_session_add_feature_by_type (session, SOUP_TYPE_GNOME_FEATURES_2_26);\n#endif \n\tif (_gdata_service_get_log_level () > GDATA_LOG_MESSAGES) {\n\t\tSoupLoggerLogLevel level;\n\t\tSoupLogger *logger;\n\t\tswitch (_gdata_service_get_log_level ()) {\n\t\t\tcase GDATA_LOG_FULL:\n\t\t\t\tlevel = SOUP_LOGGER_LOG_BODY;\n\t\t\t\tbreak;\n\t\t\tcase GDATA_LOG_HEADERS:\n\t\t\t\tlevel = SOUP_LOGGER_LOG_HEADERS;\n\t\t\t\tbreak;\n\t\t\tcase GDATA_LOG_MESSAGES:\n\t\t\tcase GDATA_LOG_NONE:\n\t\t\tdefault:\n\t\t\t\tg_assert_not_reached ();\n\t\t}\n\t\tlogger = soup_logger_new (level, -1);\n\t\tsoup_logger_set_printer (logger, (SoupLoggerPrinter) soup_log_printer, NULL, NULL);\n\t\tsoup_session_add_feature (session, SOUP_SESSION_FEATURE (logger));\n\t\tg_object_unref (logger);\n\t}\n\treturn session;\n}", "target": 1}
{"code": "begin_softmask(fz_context *ctx, pdf_run_processor *pr, softmask_save *save)\n{\n\tpdf_gstate *gstate = pr->gstate + pr->gtop;\n\tpdf_xobject *softmask = gstate->softmask;\n\tfz_rect mask_bbox;\n\tfz_matrix tos_save[2], save_ctm;\n\tfz_matrix mask_matrix;\n\tfz_colorspace *mask_colorspace;\n\tsave->softmask = softmask;\n\tif (softmask == NULL)\n\t\treturn gstate;\n\tsave->page_resources = gstate->softmask_resources;\n\tsave->ctm = gstate->softmask_ctm;\n\tsave_ctm = gstate->ctm;\n\tpdf_xobject_bbox(ctx, softmask, &mask_bbox);\n\tpdf_xobject_matrix(ctx, softmask, &mask_matrix);\n\tpdf_tos_save(ctx, &pr->tos, tos_save);\n\tif (gstate->luminosity)\n\t\tmask_bbox = fz_infinite_rect;\n\telse\n\t{\n\t\tfz_transform_rect(&mask_bbox, &mask_matrix);\n\t\tfz_transform_rect(&mask_bbox, &gstate->softmask_ctm);\n\t}\n\tgstate->softmask = NULL;\n\tgstate->softmask_resources = NULL;\n\tgstate->ctm = gstate->softmask_ctm;\n        mask_colorspace = pdf_xobject_colorspace(ctx, softmask);\n        if (gstate->luminosity && !mask_colorspace)\n               mask_colorspace = fz_device_gray(ctx);\n        fz_try(ctx)\n        {\n\t\tfz_begin_mask(ctx, pr->dev, &mask_bbox, gstate->luminosity, mask_colorspace, gstate->softmask_bc, &gstate->fill.color_params);\n\t\tpdf_run_xobject(ctx, pr, softmask, save->page_resources, &fz_identity, 1);\n\t}\n\tfz_always(ctx)\n\t\tfz_drop_colorspace(ctx, mask_colorspace);\n\tfz_catch(ctx)\n\t{\n\t\tfz_rethrow_if(ctx, FZ_ERROR_TRYLATER);\n\t}\n\tfz_end_mask(ctx, pr->dev);\n\tpdf_tos_restore(ctx, &pr->tos, tos_save);\n\tgstate = pr->gstate + pr->gtop;\n\tgstate->ctm = save_ctm;\n\treturn gstate;\n}", "target": 1}
{"code": "static bool pb_release_union_field(pb_istream_t *stream, pb_field_iter_t *field)\n{\n    pb_field_iter_t old_field = *field;\n    pb_size_t old_tag = *(pb_size_t*)field->pSize; \n    pb_size_t new_tag = field->tag; \n    if (old_tag == 0)\n        return true; \n    if (old_tag == new_tag)\n        return true; \n    if (!pb_field_iter_find(&old_field, old_tag))\n        PB_RETURN_ERROR(stream, \"invalid union tag\");\n    pb_release_single_field(&old_field);\n    return true;\n}", "target": 1}
{"code": "inline bool SegmentReader::containsInterval(const void* from, const void* to) {\n  return from >= this->ptr.begin() && to <= this->ptr.end() && from <= to &&\n      readLimiter->canRead(\n          intervalLength(reinterpret_cast<const byte*>(from),\n                         reinterpret_cast<const byte*>(to),\n                         MAX_SEGMENT_WORDS * BYTES_PER_WORD)\n              / BYTES_PER_WORD,\n          arena);\n}", "target": 1}
{"code": "int CephxSessionHandler::_calc_signature(Message *m, uint64_t *psig)\n{\n  const ceph_msg_header& header = m->get_header();\n  const ceph_msg_footer& footer = m->get_footer();\n  struct {\n    __u8 v;\n    __le64 magic;\n    __le32 len;\n    __le32 header_crc;\n    __le32 front_crc;\n    __le32 middle_crc;\n    __le32 data_crc;\n  } __attribute__ ((packed)) sigblock = {\n    1, mswab(AUTH_ENC_MAGIC), mswab<uint32_t>(4*4),\n    mswab<uint32_t>(header.crc), mswab<uint32_t>(footer.front_crc),\n    mswab<uint32_t>(footer.middle_crc), mswab<uint32_t>(footer.data_crc)\n  };\n  char exp_buf[CryptoKey::get_max_outbuf_size(sizeof(sigblock))];\n  try {\n    const CryptoKey::in_slice_t in {\n      sizeof(sigblock),\n      reinterpret_cast<const unsigned char*>(&sigblock)\n    };\n    const CryptoKey::out_slice_t out {\n      sizeof(exp_buf),\n      reinterpret_cast<unsigned char*>(&exp_buf)\n    };\n    key.encrypt(cct, in, out);\n  } catch (std::exception& e) {\n    lderr(cct) << __func__ << \" failed to encrypt signature block\" << dendl;\n    return -1;\n  }\n  *psig = *reinterpret_cast<__le64*>(exp_buf);\n  ldout(cct, 10) << __func__ << \" seq \" << m->get_seq()\n\t\t << \" front_crc_ = \" << footer.front_crc\n\t\t << \" middle_crc = \" << footer.middle_crc\n\t\t << \" data_crc = \" << footer.data_crc\n\t\t << \" sig = \" << *psig\n\t\t << dendl;\n  return 0;\n}", "target": 1}
{"code": "static int prepend_path(const struct path *path,\n\t\t\tconst struct path *root,\n\t\t\tchar **buffer, int *buflen)\n{\n\tstruct dentry *dentry;\n\tstruct vfsmount *vfsmnt;\n\tstruct mount *mnt;\n\tint error = 0;\n\tunsigned seq, m_seq = 0;\n\tchar *bptr;\n\tint blen;\n\trcu_read_lock();\nrestart_mnt:\n\tread_seqbegin_or_lock(&mount_lock, &m_seq);\n\tseq = 0;\n\trcu_read_lock();\nrestart:\n\tbptr = *buffer;\n\tblen = *buflen;\n\terror = 0;\n\tdentry = path->dentry;\n\tvfsmnt = path->mnt;\n\tmnt = real_mount(vfsmnt);\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\twhile (dentry != root->dentry || vfsmnt != root->mnt) {\n\t\tstruct dentry * parent;\n \t\tif (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {\n \t\t\tstruct mount *parent = ACCESS_ONCE(mnt->mnt_parent);\n \t\t\tif (mnt != parent) {\n \t\t\t\tdentry = ACCESS_ONCE(mnt->mnt_mountpoint);\n\t\t\t\tmnt = parent;\n\t\t\t\tvfsmnt = &mnt->mnt;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!error)\n\t\t\t\terror = is_mounted(vfsmnt) ? 1 : 2;\n\t\t\tbreak;\n\t\t}\n\t\tparent = dentry->d_parent;\n\t\tprefetch(parent);\n\t\terror = prepend_name(&bptr, &blen, &dentry->d_name);\n\t\tif (error)\n\t\t\tbreak;\n\t\tdentry = parent;\n\t}\n\tif (!(seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&rename_lock, seq)) {\n\t\tseq = 1;\n\t\tgoto restart;\n\t}\n\tdone_seqretry(&rename_lock, seq);\n\tif (!(m_seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&mount_lock, m_seq)) {\n\t\tm_seq = 1;\n\t\tgoto restart_mnt;\n\t}\n\tdone_seqretry(&mount_lock, m_seq);\n\tif (error >= 0 && bptr == *buffer) {\n\t\tif (--blen < 0)\n\t\t\terror = -ENAMETOOLONG;\n\t\telse\n\t\t\t*--bptr = '/';\n\t}\n\t*buffer = bptr;\n\t*buflen = blen;\n\treturn error;\n}", "target": 1}
{"code": "TfLiteStatus Gather(const TfLiteGatherParams& params, const TfLiteTensor* input,\n                    const TfLiteTensor* positions, TfLiteTensor* output) {\n  tflite::GatherParams op_params;\n  op_params.axis = params.axis;\n  op_params.batch_dims = params.batch_dims;\n  optimized_ops::Gather(op_params, GetTensorShape(input),\n                        GetTensorData<InputT>(input), GetTensorShape(positions),\n                        GetTensorData<PositionsT>(positions),\n                        GetTensorShape(output), GetTensorData<InputT>(output));\n  return kTfLiteOk;\n}", "target": 1}
{"code": "jas_iccprof_t *jas_iccprof_createfrombuf(uchar *buf, int len)\n{\n\tjas_stream_t *in;\n\tjas_iccprof_t *prof;\n\tif (!(in = jas_stream_memopen(JAS_CAST(char *, buf), len)))\n\t\tgoto error;\n\tif (!(prof = jas_iccprof_load(in)))\n\t\tgoto error;\n\tjas_stream_close(in);\n\treturn prof;\nerror:\n\treturn 0;\n}", "target": 1}
{"code": "static __net_init int setup_net(struct net *net, struct user_namespace *user_ns)\n{\n\tconst struct pernet_operations *ops, *saved_ops;\n\tint error = 0;\n\tLIST_HEAD(net_exit_list);\n \trefcount_set(&net->count, 1);\n \trefcount_set(&net->passive, 1);\n \tnet->dev_base_seq = 1;\n \tnet->user_ns = user_ns;\n \tidr_init(&net->netns_ids);\n\tspin_lock_init(&net->nsid_lock);\n\tmutex_init(&net->ipv4.ra_mutex);\n\tlist_for_each_entry(ops, &pernet_list, list) {\n\t\terror = ops_init(ops, net);\n\t\tif (error < 0)\n\t\t\tgoto out_undo;\n\t}\n\tdown_write(&net_rwsem);\n\tlist_add_tail_rcu(&net->list, &net_namespace_list);\n\tup_write(&net_rwsem);\nout:\n\treturn error;\nout_undo:\n\tlist_add(&net->exit_list, &net_exit_list);\n\tsaved_ops = ops;\n\tlist_for_each_entry_continue_reverse(ops, &pernet_list, list)\n\t\tops_exit_list(ops, &net_exit_list);\n\tops = saved_ops;\n\tlist_for_each_entry_continue_reverse(ops, &pernet_list, list)\n\t\tops_free_list(ops, &net_exit_list);\n\trcu_barrier();\n\tgoto out;\n}", "target": 1}
{"code": "ExtensionInstallDialogView::ExtensionInstallDialogView(\n    Profile* profile,\n    content::PageNavigator* navigator,\n    const ExtensionInstallPrompt::DoneCallback& done_callback,\n    std::unique_ptr<ExtensionInstallPrompt::Prompt> prompt)\n    : profile_(profile),\n      navigator_(navigator),\n      done_callback_(done_callback),\n       prompt_(std::move(prompt)),\n       container_(NULL),\n       scroll_view_(NULL),\n      handled_result_(false) {\n   InitView();\n }", "target": 1}
{"code": "static pj_status_t parse_query(pj_dns_parsed_query *q, pj_pool_t *pool,\n\t\t\t       const pj_uint8_t *pkt, const pj_uint8_t *start,\n\t\t\t       const pj_uint8_t *max, int *parsed_len)\n{\n    const pj_uint8_t *p = start;\n    int name_len, name_part_len;\n    pj_status_t status;\n    status = get_name_len(0, pkt, start, max, &name_part_len, &name_len);\n    if (status != PJ_SUCCESS)\n\treturn status;\n    q->name.ptr = (char*) pj_pool_alloc(pool, name_len+4);\n    q->name.slen = 0;\n    status = get_name(0, pkt, start, max, &q->name);\n    if (status != PJ_SUCCESS)\n\treturn status;\n    p = (start + name_part_len);\n    pj_memcpy(&q->type, p, 2);\n    q->type = pj_ntohs(q->type);\n    p += 2;\n    pj_memcpy(&q->dnsclass, p, 2);\n    q->dnsclass = pj_ntohs(q->dnsclass);\n    p += 2;\n    *parsed_len = (int)(p - start);\n    return PJ_SUCCESS;\n}", "target": 1}
{"code": "static jas_image_cmpt_t *jas_image_cmpt_create(uint_fast32_t tlx, uint_fast32_t tly,\n  uint_fast32_t hstep, uint_fast32_t vstep, uint_fast32_t width, uint_fast32_t\n  height, uint_fast16_t depth, bool sgnd, uint_fast32_t inmem)\n{\n\tjas_image_cmpt_t *cmpt;\n\tlong size;\n\tif (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {\n\t\treturn 0;\n\t}\n\tcmpt->type_ = JAS_IMAGE_CT_UNKNOWN;\n\tcmpt->tlx_ = tlx;\n\tcmpt->tly_ = tly;\n\tcmpt->hstep_ = hstep;\n\tcmpt->vstep_ = vstep;\n\tcmpt->width_ = width;\n\tcmpt->height_ = height;\n\tcmpt->prec_ = depth;\n\tcmpt->sgnd_ = sgnd;\n\tcmpt->stream_ = 0;\n\tcmpt->cps_ = (depth + 7) / 8;\n\tsize = cmpt->width_ * cmpt->height_ * cmpt->cps_;\n\tcmpt->stream_ = (inmem) ? jas_stream_memopen(0, size) : jas_stream_tmpfile();\n\tif (!cmpt->stream_) {\n\t\tjas_image_cmpt_destroy(cmpt);\n\t\treturn 0;\n\t}\n\tif (jas_stream_seek(cmpt->stream_, size - 1, SEEK_SET) < 0 ||\n\t  jas_stream_putc(cmpt->stream_, 0) == EOF ||\n\t  jas_stream_seek(cmpt->stream_, 0, SEEK_SET) < 0) {\n\t\tjas_image_cmpt_destroy(cmpt);\n\t\treturn 0;\n\t}\n\treturn cmpt;\n}", "target": 1}
{"code": "R_API int r_egg_compile(REgg *egg) {\n\tr_buf_seek (egg->src, 0, R_BUF_SET);\n\tchar b;\n\tint r = r_buf_read (egg->src, (ut8 *)&b, sizeof (b));\n\tif (r != sizeof (b) || !egg->remit) {\n\t\treturn true;\n\t}\n\tr_egg_lang_init (egg);\n\tfor (; b; ) {\n\t\tr_egg_lang_parsechar (egg, b);\n\t\tint r = r_buf_read (egg->src, (ut8 *)&b, sizeof (b));\n\t\tif (r != sizeof (b)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (egg->context>0) {\n\t\teprintf (\"ERROR: expected '}' at the end of the file. %d left\\n\", egg->context);\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "__switch_to(struct task_struct *prev_p, struct task_struct *next_p)\n{\n\tstruct thread_struct *prev = &prev_p->thread;\n\tstruct thread_struct *next = &next_p->thread;\n\tint cpu = smp_processor_id();\n\tstruct tss_struct *tss = &per_cpu(init_tss, cpu);\n\tunsigned fsindex, gsindex;\n\tfpu_switch_t fpu;\n \tfpu = switch_fpu_prepare(prev_p, next_p, cpu);\n \tload_sp0(tss, next);\n\tsavesegment(es, prev->es);\n\tif (unlikely(next->es | prev->es))\n\t\tloadsegment(es, next->es);\n\tsavesegment(ds, prev->ds);\n\tif (unlikely(next->ds | prev->ds))\n\t\tloadsegment(ds, next->ds);\n \tsavesegment(fs, fsindex);\n \tsavesegment(gs, gsindex);\n \tload_TLS(next, cpu);\n \tarch_end_context_switch(next_p);\n \tif (unlikely(fsindex | next->fsindex | prev->fs)) {\n \t\tloadsegment(fs, next->fsindex);\n \t\tif (fsindex)\n \t\t\tprev->fs = 0;\n \t}\n \tif (next->fs)\n \t\twrmsrl(MSR_FS_BASE, next->fs);\n \tprev->fsindex = fsindex;\n \tif (unlikely(gsindex | next->gsindex | prev->gs)) {\n \t\tload_gs_index(next->gsindex);\n \t\tif (gsindex)\n \t\t\tprev->gs = 0;\n \t}\n\tif (next->gs)\n\t\twrmsrl(MSR_KERNEL_GS_BASE, next->gs);\n\tprev->gsindex = gsindex;\n\tswitch_fpu_finish(next_p, fpu);\n\tprev->usersp = this_cpu_read(old_rsp);\n\tthis_cpu_write(old_rsp, next->usersp);\n\tthis_cpu_write(current_task, next_p);\n\ttask_thread_info(prev_p)->saved_preempt_count = this_cpu_read(__preempt_count);\n\tthis_cpu_write(__preempt_count, task_thread_info(next_p)->saved_preempt_count);\n\tthis_cpu_write(kernel_stack,\n\t\t  (unsigned long)task_stack_page(next_p) +\n\t\t  THREAD_SIZE - KERNEL_STACK_OFFSET);\n\tif (unlikely(task_thread_info(next_p)->flags & _TIF_WORK_CTXSW_NEXT ||\n\t\t     task_thread_info(prev_p)->flags & _TIF_WORK_CTXSW_PREV))\n\t\t__switch_to_xtra(prev_p, next_p, tss);\n\treturn prev_p;\n}", "target": 1}
{"code": "static Fixed lsr_translate_coords(GF_LASeRCodec *lsr, u32 val, u32 nb_bits)\n{\n#ifdef GPAC_FIXED_POINT\n\tif (val >> (nb_bits-1) ) {\n\t\ts32 neg = (s32) val - (1<<nb_bits);\n\t\tif (neg < -FIX_ONE / 2)\n\t\t\treturn 2 * gf_divfix(INT2FIX(neg/2), lsr->res_factor);\n\t\treturn gf_divfix(INT2FIX(neg), lsr->res_factor);\n\t} else {\n\t\tif (val > FIX_ONE / 2)\n\t\t\treturn 2 * gf_divfix(INT2FIX(val/2), lsr->res_factor);\n\t\treturn gf_divfix(INT2FIX(val), lsr->res_factor);\n\t}\n#else\n\tif (val >> (nb_bits-1) ) {\n\t\ts32 neg = (s32) val - (1<<nb_bits);\n\t\treturn gf_divfix(INT2FIX(neg), lsr->res_factor);\n\t} else {\n\t\treturn gf_divfix(INT2FIX(val), lsr->res_factor);\n\t}\n#endif\n}", "target": 1}
{"code": "static int sco_sock_getsockopt_old(struct socket *sock, int optname, char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sco_options opts;\n\tstruct sco_conninfo cinfo;\n\tint len, err = 0;\n\tBT_DBG(\"sk %p\", sk);\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tlock_sock(sk);\n\tswitch (optname) {\n\tcase SCO_OPTIONS:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\t\topts.mtu = sco_pi(sk)->conn->mtu;\n\t\tBT_DBG(\"mtu %d\", opts.mtu);\n\t\tlen = min_t(unsigned int, len, sizeof(opts));\n\t\tif (copy_to_user(optval, (char *)&opts, len))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase SCO_CONNINFO:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n \t\t\tbreak;\n \t\t}\n \t\tcinfo.hci_handle = sco_pi(sk)->conn->hcon->handle;\n \t\tmemcpy(cinfo.dev_class, sco_pi(sk)->conn->hcon->dev_class, 3);\n\t\tlen = min_t(unsigned int, len, sizeof(cinfo));\n\t\tif (copy_to_user(optval, (char *)&cinfo, len))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn err;\n}", "target": 1}
{"code": "static void sctp_destroy_sock(struct sock *sk)\n{\n\tstruct sctp_sock *sp;\n\tpr_debug(\"%s: sk:%p\\n\", __func__, sk);\n\tsp = sctp_sk(sk);\n\tif (sp->ep == NULL)\n\t\treturn;\n\tif (sp->do_auto_asconf) {\n\t\tsp->do_auto_asconf = 0;\n\t\tlist_del(&sp->auto_asconf_list);\n\t}\n\tsctp_endpoint_free(sp->ep);\n\tlocal_bh_disable();\n\tsk_sockets_allocated_dec(sk);\n\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\tlocal_bh_enable();\n}", "target": 1}
{"code": "png_set_PLTE(png_structrp png_ptr, png_inforp info_ptr,\n    png_const_colorp palette, int num_palette)\n{\n   png_uint_32 max_palette_length;\n   png_debug1(1, \"in %s storage function\", \"PLTE\");\n   if (png_ptr == NULL || info_ptr == NULL)\n      return;\n   max_palette_length = (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE) ?\n      (1 << png_ptr->bit_depth) : PNG_MAX_PALETTE_LENGTH;\n   if (num_palette < 0 || num_palette > max_palette_length)\n   {\n      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n         png_error(png_ptr, \"Invalid palette length\");\n      else\n      {\n         png_warning(png_ptr, \"Invalid palette length\");\n         return;\n      }\n   }\n   if ((num_palette > 0 && palette == NULL) ||\n      (num_palette == 0\n#        ifdef PNG_MNG_FEATURES_SUPPORTED\n            && (png_ptr->mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE) == 0\n#        endif\n      ))\n   {\n      png_error(png_ptr, \"Invalid palette\");\n   }\n   png_free_data(png_ptr, info_ptr, PNG_FREE_PLTE, 0);\n   png_ptr->palette = png_voidcast(png_colorp, png_calloc(png_ptr,\n       PNG_MAX_PALETTE_LENGTH * (sizeof (png_color))));\n   if (num_palette > 0)\n      memcpy(png_ptr->palette, palette, num_palette * (sizeof (png_color)));\n   info_ptr->palette = png_ptr->palette;\n   info_ptr->num_palette = png_ptr->num_palette = (png_uint_16)num_palette;\n   info_ptr->free_me |= PNG_FREE_PLTE;\n   info_ptr->valid |= PNG_INFO_PLTE;\n}", "target": 1}
{"code": "vmxnet3_io_bar0_write(void *opaque, hwaddr addr,\n                      uint64_t val, unsigned size)\n {\n     VMXNET3State *s = opaque;\n     if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_TXPROD,\n                         VMXNET3_DEVICE_MAX_TX_QUEUES, VMXNET3_REG_ALIGN)) {\n         int tx_queue_idx =\n        return;\n    }\n    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_IMR,\n                        VMXNET3_MAX_INTRS, VMXNET3_REG_ALIGN)) {\n        int l = VMW_MULTIREG_IDX_BY_ADDR(addr, VMXNET3_REG_IMR,\n                                         VMXNET3_REG_ALIGN);\n        VMW_CBPRN(\"Interrupt mask for line %d written: 0x%\" PRIx64, l, val);\n        vmxnet3_on_interrupt_mask_changed(s, l, val);\n        return;\n    }\n    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD,\n                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN) ||\n       VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD2,\n                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN)) {\n        return;\n    }\n    VMW_WRPRN(\"BAR0 unknown write [%\" PRIx64 \"] = %\" PRIx64 \", size %d\",\n              (uint64_t) addr, val, size);\n}", "target": 1}
{"code": "static void __dvb_frontend_free(struct dvb_frontend *fe)\n{\n\tstruct dvb_frontend_private *fepriv = fe->frontend_priv;\n\tif (fepriv)\n\t\tdvb_free_device(fepriv->dvbdev);\n\tdvb_frontend_invoke_release(fe, fe->ops.release);\n\tif (!fepriv)\n\t\treturn;\n\tkfree(fepriv);\n\tfe->frontend_priv = NULL;\n}", "target": 1}
{"code": "static int net_ctl_permissions(struct ctl_table_header *head,\n\t\t\t       struct ctl_table *table)\n{\n\tstruct net *net = container_of(head->set, struct net, sysctls);\n\tkuid_t root_uid = make_kuid(net->user_ns, 0);\n\tkgid_t root_gid = make_kgid(net->user_ns, 0);\n \tif (ns_capable(net->user_ns, CAP_NET_ADMIN) ||\n\t    uid_eq(root_uid, current_uid())) {\n \t\tint mode = (table->mode >> 6) & 7;\n \t\treturn (mode << 6) | (mode << 3) | mode;\n \t}\n\tif (gid_eq(root_gid, current_gid())) {\n \t\tint mode = (table->mode >> 3) & 7;\n \t\treturn (mode << 3) | mode;\n \t}\n\treturn table->mode;\n}", "target": 1}
{"code": "con_insert_unipair(struct uni_pagedir *p, u_short unicode, u_short fontpos)\n{\n\tint i, n;\n\tu16 **p1, *p2;\n\tp1 = p->uni_pgdir[n = unicode >> 11];\n\tif (!p1) {\n\t\tp1 = p->uni_pgdir[n] = kmalloc_array(32, sizeof(u16 *),\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!p1) return -ENOMEM;\n\t\tfor (i = 0; i < 32; i++)\n\t\t\tp1[i] = NULL;\n\t}\n\tp2 = p1[n = (unicode >> 6) & 0x1f];\n\tif (!p2) {\n\t\tp2 = p1[n] = kmalloc_array(64, sizeof(u16), GFP_KERNEL);\n\t\tif (!p2) {\n\t\t\tkfree(p1);\n\t\t\tp->uni_pgdir[n] = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemset(p2, 0xff, 64*sizeof(u16)); \n\t}\n\tp2[unicode & 0x3f] = fontpos;\n\tp->sum += (fontpos << 20) + unicode;\n\treturn 0;\n}", "target": 1}
{"code": "UnicodeString::doAppend(const UChar *srcChars, int32_t srcStart, int32_t srcLength) {\n  if(!isWritable() || srcLength == 0 || srcChars == NULL) {\n    return *this;\n  }\n  srcChars += srcStart;\n  if(srcLength < 0) {\n    if((srcLength = u_strlen(srcChars)) == 0) {\n      return *this;\n    }\n  }\n  int32_t oldLength = length();\n  int32_t newLength = oldLength + srcLength;\n  const UChar* oldArray = getArrayStart();\n  if (isBufferWritable() &&\n      oldArray < srcChars + srcLength &&\n      srcChars < oldArray + oldLength) {\n    UnicodeString copy(srcChars, srcLength);\n    if (copy.isBogus()) {\n      setToBogus();\n      return *this;\n    }\n    return doAppend(copy.getArrayStart(), 0, srcLength);\n  }\n  if((newLength <= getCapacity() && isBufferWritable()) ||\n      cloneArrayIfNeeded(newLength, getGrowCapacity(newLength))) {\n    UChar *newArray = getArrayStart();\n    if(srcChars != newArray + oldLength) {\n      us_arrayCopy(srcChars, 0, newArray, oldLength, srcLength);\n    }\n    setLength(newLength);\n  }\n  return *this;\n}", "target": 1}
{"code": "status_t MediaHTTP::connect(\n const char *uri,\n const KeyedVector<String8, String8> *headers,\n off64_t ) {\n if (mInitCheck != OK) {\n return mInitCheck;\n }\n KeyedVector<String8, String8> extHeaders;\n if (headers != NULL) {\n        extHeaders = *headers;\n }\n if (extHeaders.indexOfKey(String8(\"User-Agent\")) < 0) {\n         extHeaders.add(String8(\"User-Agent\"), String8(MakeUserAgent().c_str()));\n     }\n    bool success = mHTTPConnection->connect(uri, &extHeaders);\n     mLastHeaders = extHeaders;\n    mLastURI = uri;\n     mCachedSizeValid = false;\n     if (success) {\n        AString sanitized = uriDebugString(uri);\n         mName = String8::format(\"MediaHTTP(%s)\", sanitized.c_str());\n     }\n return success ? OK : UNKNOWN_ERROR;\n}", "target": 1}
{"code": "gen_values(codegen_scope *s, node *t, int val, int limit)\n{\n  int n = 0;\n  int first = 1;\n  int slimit = GEN_VAL_STACK_MAX;\n  if (limit == 0) limit = GEN_LIT_ARY_MAX;\n  if (cursp() >= slimit) slimit = INT16_MAX;\n  if (!val) {\n    while (t) {\n      codegen(s, t->car, NOVAL);\n      n++;\n      t = t->cdr;\n    }\n    return n;\n  }\n  while (t) {\n    int is_splat = nint(t->car->car) == NODE_SPLAT;\n    if (is_splat || n > limit || cursp() >= slimit) { \n      pop_n(n);\n      if (first) {\n        if (n == 0) {\n          genop_1(s, OP_LOADNIL, cursp());\n        }\n        else {\n          genop_2(s, OP_ARRAY, cursp(), n);\n        }\n        push();\n        first = 0;\n        limit = GEN_LIT_ARY_MAX;\n      }\n      else if (n > 0) {\n        pop();\n        genop_2(s, OP_ARYPUSH, cursp(), n);\n        push();\n      }\n      n = 0;\n    }\n    codegen(s, t->car, val);\n    if (is_splat) {\n      pop(); pop();\n      genop_1(s, OP_ARYCAT, cursp());\n      push();\n    }\n    else {\n      n++;\n    }\n    t = t->cdr;\n  }\n  if (!first) {\n    pop();\n    if (n > 0) {\n      pop_n(n);\n      genop_2(s, OP_ARYPUSH, cursp(), n);\n    }\n    return -1;                  \n  }\n  return n;\n}", "target": 1}
{"code": "static inline int fpregs_state_valid(struct fpu *fpu, unsigned int cpu)\n{\n\treturn fpu == this_cpu_read_stable(fpu_fpregs_owner_ctx) && cpu == fpu->last_cpu;\n}", "target": 1}
{"code": "GF_Err infe_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tchar *buf;\n\tu32 buf_len, i, string_len, string_start;\n\tGF_ItemInfoEntryBox *ptr = (GF_ItemInfoEntryBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->item_ID = gf_bs_read_u16(bs);\n\tptr->item_protection_index = gf_bs_read_u16(bs);\n\tif (ptr->version == 2) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->item_type = gf_bs_read_u32(bs);\n\t}\n\tbuf_len = (u32) (ptr->size);\n\tbuf = (char*)gf_malloc(buf_len);\n\tif (!buf) return GF_OUT_OF_MEM;\n\tif (buf_len != gf_bs_read_data(bs, buf, buf_len)) {\n\t\tgf_free(buf);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tstring_len = 1;\n\tstring_start = 0;\n\tfor (i = 0; i < buf_len; i++) {\n\t\tif (buf[i] == 0) {\n\t\t\tif (!ptr->item_name) {\n\t\t\t\tptr->item_name = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->item_name) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->item_name, buf+string_start, string_len);\n\t\t\t} else if (!ptr->content_type) {\n\t\t\t\tptr->content_type = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->content_type) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->content_type, buf+string_start, string_len);\n\t\t\t} else {\n\t\t\t\tptr->content_encoding = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->content_encoding) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->content_encoding, buf+string_start, string_len);\n\t\t\t}\n\t\t\tstring_start += string_len;\n\t\t\tstring_len = 0;\n\t\t\tif (ptr->content_encoding && ptr->version == 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tstring_len++;\n\t}\n\tgf_free(buf);\n\tif (!ptr->item_name || (!ptr->content_type && ptr->version < 2)) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isoff] Infe without name or content type !\\n\"));\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "int PackLinuxElf64::canUnpack()\n{\n    if (super::canUnpack()) {\n        return true;\n    }\n    if (Elf64_Ehdr::ET_DYN==get_te16(&ehdri.e_type)) {\n        PackLinuxElf64help1(fi);\n        Elf64_Phdr const *phdr = phdri, *last_LOAD = nullptr;\n        for (unsigned j = 0; j < e_phnum; ++phdr, ++j)\n            if (Elf64_Phdr::PT_LOAD==get_te32(&phdr->p_type)) {\n                last_LOAD = phdr;\n            }\n        if (!last_LOAD)\n            return false;\n        off_t offset = get_te64(&last_LOAD->p_offset);\n        unsigned filesz = get_te64(&last_LOAD->p_filesz);\n        fi->seek(filesz+offset, SEEK_SET);\n        MemBuffer buf(32 + sizeof(overlay_offset));\n        fi->readx(buf, buf.getSize());\n        return PackUnix::find_overlay_offset(buf);\n    }\n    return false;\n}", "target": 1}
{"code": "int Http2Stream::DoWrite(WriteWrap* req_wrap,\n                         uv_buf_t* bufs,\n                         size_t nbufs,\n                         uv_stream_t* send_handle) {\n  CHECK_NULL(send_handle);\n  Http2Scope h2scope(this);\n  if (!IsWritable() || IsDestroyed()) {\n    req_wrap->Done(UV_EOF);\n    return 0;\n  }\n  Debug(this, \"queuing %d buffers to send\", id_, nbufs);\n  for (size_t i = 0; i < nbufs; ++i) {\n    queue_.emplace(nghttp2_stream_write {\n      i == nbufs - 1 ? req_wrap : nullptr,\n      bufs[i]\n    });\n    IncrementAvailableOutboundLength(bufs[i].len);\n  }\n  CHECK_NE(nghttp2_session_resume_data(**session_, id_), NGHTTP2_ERR_NOMEM);\n  return 0;\n}", "target": 1}
{"code": "NativeModule::NativeModule(const std::string& filename) : init(nullptr) {\n\tif (uv_dlopen(filename.c_str(), &lib) != 0) {\n\t\tthrow RuntimeGenericError(\"Failed to load module\");\n\t}\n\tif (uv_dlsym(&lib, \"InitForContext\", reinterpret_cast<void**>(&init)) != 0 || init == nullptr) {\n\t\tuv_dlclose(&lib);\n\t\tthrow RuntimeGenericError(\"Module is not isolated-vm compatible\");\n\t}\n}", "target": 1}
{"code": "plugin_init (Ekiga::KickStart& kickstart)\n{\n#ifdef DEBUG\n  gchar* path = g_build_path (G_DIR_SEPARATOR_S,\n\t\t\t      g_get_tmp_dir (), \"ekiga_debug_plugins\", NULL);\n  plugin_parse_directory (kickstart, path);\n  g_free (path);\n#else\n  plugin_parse_directory (kickstart,\n\t\t\t  EKIGA_PLUGIN_DIR);\n#endif\n}", "target": 1}
{"code": "lys_restr_dup(struct lys_module *mod, struct lys_restr *old, int size, int shallow, struct unres_schema *unres)\n{\n    struct lys_restr *result;\n    int i;\n    if (!size) {\n        return NULL;\n    }\n    result = calloc(size, sizeof *result);\n    LY_CHECK_ERR_RETURN(!result, LOGMEM(mod->ctx), NULL);\n    for (i = 0; i < size; i++) {\n        result[i].ext_size = old[i].ext_size;\n        lys_ext_dup(mod->ctx, mod, old[i].ext, old[i].ext_size, &result[i], LYEXT_PAR_RESTR, &result[i].ext, shallow, unres);\n        result[i].expr = lydict_insert(mod->ctx, old[i].expr, 0);\n        result[i].dsc = lydict_insert(mod->ctx, old[i].dsc, 0);\n        result[i].ref = lydict_insert(mod->ctx, old[i].ref, 0);\n        result[i].eapptag = lydict_insert(mod->ctx, old[i].eapptag, 0);\n        result[i].emsg = lydict_insert(mod->ctx, old[i].emsg, 0);\n    }\n    return result;\n}", "target": 1}
{"code": "void CleanWriters(GF_List *writers)\n{\n\twhile (gf_list_count(writers)) {\n\t\tTrackWriter *writer = (TrackWriter*)gf_list_get(writers, 0);\n\t\tgf_isom_box_del(writer->stco);\n\t\tgf_isom_box_del((GF_Box *)writer->stsc);\n\t\tgf_free(writer);\n\t\tgf_list_rem(writers, 0);\n\t}\n}", "target": 1}
{"code": "*vidtv_s302m_encoder_init(struct vidtv_s302m_encoder_init_args args)\n{\n\tu32 priv_sz = sizeof(struct vidtv_s302m_ctx);\n\tstruct vidtv_s302m_ctx *ctx;\n\tstruct vidtv_encoder *e;\n\te = kzalloc(sizeof(*e), GFP_KERNEL);\n\tif (!e)\n\t\treturn NULL;\n\te->id = S302M;\n\tif (args.name)\n\t\te->name = kstrdup(args.name, GFP_KERNEL);\n\te->encoder_buf = vzalloc(VIDTV_S302M_BUF_SZ);\n\te->encoder_buf_sz = VIDTV_S302M_BUF_SZ;\n\te->encoder_buf_offset = 0;\n\te->sample_count = 0;\n\te->src_buf = (args.src_buf) ? args.src_buf : NULL;\n\te->src_buf_sz = (args.src_buf) ? args.src_buf_sz : 0;\n\te->src_buf_offset = 0;\n\te->is_video_encoder = false;\n\tctx = kzalloc(priv_sz, GFP_KERNEL);\n\tif (!ctx) {\n\t\tkfree(e);\n\t\treturn NULL;\n\t}\n\te->ctx = ctx;\n\tctx->last_duration = 0;\n\te->encode = vidtv_s302m_encode;\n\te->clear = vidtv_s302m_clear;\n\te->es_pid = cpu_to_be16(args.es_pid);\n\te->stream_id = cpu_to_be16(PES_PRIVATE_STREAM_1);\n\te->sync = args.sync;\n\te->sampling_rate_hz = S302M_SAMPLING_RATE_HZ;\n\te->last_sample_cb = args.last_sample_cb;\n\te->destroy = vidtv_s302m_encoder_destroy;\n\tif (args.head) {\n\t\twhile (args.head->next)\n\t\t\targs.head = args.head->next;\n\t\targs.head->next = e;\n\t}\n\te->next = NULL;\n\treturn e;\n}", "target": 1}
{"code": "buflist_match(\n    regmatch_T\t*rmp,\n    buf_T\t*buf,\n    int\t\tignore_case)  \n{\n    char_u\t*match;\n    match = fname_match(rmp, buf->b_sfname, ignore_case);\n    if (match == NULL)\n\tmatch = fname_match(rmp, buf->b_ffname, ignore_case);\n    return match;\n}", "target": 1}
{"code": "void luaD_callnoyield (lua_State *L, StkId func, int nResults) {\n  incXCcalls(L);\n  if (getCcalls(L) <= CSTACKERR)  \n    luaE_freeCI(L);\n  luaD_call(L, func, nResults);\n  decXCcalls(L);\n}", "target": 1}
{"code": " static opj_bool pi_next_lrcp(opj_pi_iterator_t * pi)\n {\n     opj_pi_comp_t *comp = NULL;\n    opj_pi_resolution_t *res = NULL;\n    long index = 0;\n    if (!pi->first) {\n        comp = &pi->comps[pi->compno];\n        res = &comp->resolutions[pi->resno];\n        goto LABEL_SKIP;\n    } else {\n        pi->first = 0;\n    }\n    for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {\n        for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1;\n                pi->resno++) {\n            for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {\n                comp = &pi->comps[pi->compno];\n                if (pi->resno >= comp->numresolutions) {\n                    continue;\n                }\n                res = &comp->resolutions[pi->resno];\n                if (!pi->tp_on) {\n                    pi->poc.precno1 = res->pw * res->ph;\n                }\n                 for (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {\n                     index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno *\n                             pi->step_c + pi->precno * pi->step_p;\n                     if (!pi->include[index]) {\n                         pi->include[index] = 1;\n                         return OPJ_TRUE;\n                    }\nLABEL_SKIP:\n                    ;\n                }\n            }\n        }\n    }\n    return OPJ_FALSE;\n}", "target": 1}
{"code": "void SparseFillEmptyRowsOpImpl(OpKernelContext* context,\n                               AsyncOpKernel::DoneCallback done = nullptr) {\n  if (!done) {\n    done = [] {};\n  }\n  const int kIndicesInput = 0;\n  const int kValuesInput = 1;\n  const int kDenseShapeInput = 2;\n  const int kDefaultValueInput = 3;\n  const Tensor& indices_t = context->input(kIndicesInput);\n  const Tensor& values_t = context->input(kValuesInput);\n  const Tensor& dense_shape_t = context->input(kDenseShapeInput);\n  const Tensor& default_value_t = context->input(kDefaultValueInput);\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsVector(dense_shape_t.shape()),\n      errors::InvalidArgument(\"dense_shape must be a vector, saw: \",\n                              dense_shape_t.shape().DebugString()),\n      done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsMatrix(indices_t.shape()),\n                    errors::InvalidArgument(\"indices must be a matrix, saw: \",\n                                            indices_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsVector(values_t.shape()),\n                    errors::InvalidArgument(\"values must be a vector, saw: \",\n                                            values_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsScalar(default_value_t.shape()),\n      errors::InvalidArgument(\"default_value must be a scalar, saw: \",\n                              default_value_t.shape().DebugString()),\n      done);\n  using FunctorType = functor::SparseFillEmptyRows<Device, T, Tindex>;\n  OP_REQUIRES_OK_ASYNC(context,\n                       FunctorType()(context, default_value_t, indices_t,\n                                     values_t, dense_shape_t, done),\n                       done);\n}", "target": 1}
{"code": "CotpConnection_readToTpktBuffer(CotpConnection* self)\n{\n    uint8_t* buffer = self->readBuffer->buffer;\n    int bufferSize = self->readBuffer->maxSize;\n    int bufPos = self->readBuffer->size;\n    assert (bufferSize > 4);\n    int readBytes;\n    if (bufPos < 4) {\n        readBytes = readFromSocket(self, buffer + bufPos, 4 - bufPos);\n        if (readBytes < 0)\n            goto exit_closed;\n        if (DEBUG_COTP) {\n            if (readBytes > 0)\n                printf(\"TPKT: read %i bytes from socket\\n\", readBytes);\n        }\n        bufPos += readBytes;\n        if (bufPos == 4) {\n            if ((buffer[0] == 3) && (buffer[1] == 0)) {\n                self->packetSize = (buffer[2] * 0x100) + buffer[3];\n                if (DEBUG_COTP)\n                    printf(\"TPKT: header complete (msg size = %i)\\n\", self->packetSize);\n                if (self->packetSize > bufferSize) {\n                    if (DEBUG_COTP) printf(\"TPKT: packet too large\\n\");\n                    goto exit_error;\n                }\n            }\n            else {\n                if (DEBUG_COTP) printf(\"TPKT: failed to decode TPKT header.\\n\");\n                goto exit_error;\n            }\n        }\n        else\n            goto exit_waiting;\n    }\n    readBytes = readFromSocket(self, buffer + bufPos, self->packetSize - bufPos);\n    if (readBytes < 0)\n        goto exit_closed;\n    bufPos += readBytes;\n    if (bufPos < self->packetSize)\n       goto exit_waiting;\n    if (DEBUG_COTP) printf(\"TPKT: message complete (size = %i)\\n\", self->packetSize);\n    self->readBuffer->size = bufPos;\n    return TPKT_PACKET_COMPLETE;\nexit_closed:\n    if (DEBUG_COTP) printf(\"TPKT: socket closed or socket error\\n\");\n    return TPKT_ERROR;\nexit_error:\n    if (DEBUG_COTP) printf(\"TPKT: Error parsing message\\n\");\n    return TPKT_ERROR;\nexit_waiting:\n    if (DEBUG_COTP)\n        if (bufPos != 0)\n            printf(\"TPKT: waiting (read %i of %i)\\n\", bufPos, self->packetSize);\n    self->readBuffer->size = bufPos;\n    return TPKT_WAITING;\n}", "target": 1}
{"code": "xbstream_open(ds_ctxt_t *ctxt, const char *path, MY_STAT *mystat)\n{\n\tds_file_t\t\t*file;\n\tds_stream_file_t\t*stream_file;\n\tds_stream_ctxt_t\t*stream_ctxt;\n\tds_ctxt_t\t\t*dest_ctxt;\n\txb_wstream_t\t\t*xbstream;\n\txb_wstream_file_t\t*xbstream_file;\n\txb_ad(ctxt->pipe_ctxt != NULL);\n\tdest_ctxt = ctxt->pipe_ctxt;\n\tstream_ctxt = (ds_stream_ctxt_t *) ctxt->ptr;\n\tpthread_mutex_lock(&stream_ctxt->mutex);\n\tif (stream_ctxt->dest_file == NULL) {\n\t\tstream_ctxt->dest_file = ds_open(dest_ctxt, path, mystat);\n\t\tif (stream_ctxt->dest_file == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tpthread_mutex_unlock(&stream_ctxt->mutex);\n\tfile = (ds_file_t *) my_malloc(sizeof(ds_file_t) +\n\t\t\t\t       sizeof(ds_stream_file_t),\n\t\t\t\t       MYF(MY_FAE));\n\tstream_file = (ds_stream_file_t *) (file + 1);\n\txbstream = stream_ctxt->xbstream;\n\txbstream_file = xb_stream_write_open(xbstream, path, mystat,\n\t\t                             stream_ctxt,\n\t\t\t\t\t     my_xbstream_write_callback);\n\tif (xbstream_file == NULL) {\n\t\tmsg(\"xb_stream_write_open() failed.\");\n\t\tgoto err;\n\t}\n\tstream_file->xbstream_file = xbstream_file;\n\tstream_file->stream_ctxt = stream_ctxt;\n\tfile->ptr = stream_file;\n\tfile->path = stream_ctxt->dest_file->path;\n\treturn file;\nerr:\n\tif (stream_ctxt->dest_file) {\n\t\tds_close(stream_ctxt->dest_file);\n\t\tstream_ctxt->dest_file = NULL;\n\t}\n\tmy_free(file);\n\treturn NULL;\n}", "target": 1}
{"code": "static void mkiss_close(struct tty_struct *tty)\n{\n\tstruct mkiss *ax;\n\twrite_lock_irq(&disc_data_lock);\n\tax = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\tif (!ax)\n\t\treturn;\n\tif (!refcount_dec_and_test(&ax->refcnt))\n\t\twait_for_completion(&ax->dead);\n\tnetif_stop_queue(ax->dev);\n\tkfree(ax->rbuff);\n\tkfree(ax->xbuff);\n\tax->tty = NULL;\n\tunregister_netdev(ax->dev);\n\tfree_netdev(ax->dev);\n}", "target": 1}
{"code": "rfbSendRectEncodingRaw(rfbClientPtr cl,\n                       int x,\n                       int y,\n                       int w,\n                       int h)\n{\n    rfbFramebufferUpdateRectHeader rect;\n    int nlines;\n    int bytesPerLine = w * (cl->format.bitsPerPixel / 8);\n    char *fbptr = (cl->scaledScreen->frameBuffer + (cl->scaledScreen->paddedWidthInBytes * y)\n                   + (x * (cl->scaledScreen->bitsPerPixel / 8)));\n    if (cl->ublen > 0) {\n        if (!rfbSendUpdateBuf(cl))\n            return FALSE;\n    }\n    rect.r.x = Swap16IfLE(x);\n    rect.r.y = Swap16IfLE(y);\n    rect.r.w = Swap16IfLE(w);\n    rect.r.h = Swap16IfLE(h);\n    rect.encoding = Swap32IfLE(rfbEncodingRaw);\n    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,sz_rfbFramebufferUpdateRectHeader);\n    cl->ublen += sz_rfbFramebufferUpdateRectHeader;\n    rfbStatRecordEncodingSent(cl, rfbEncodingRaw, sz_rfbFramebufferUpdateRectHeader + bytesPerLine * h,\n        sz_rfbFramebufferUpdateRectHeader + bytesPerLine * h);\n    nlines = (UPDATE_BUF_SIZE - cl->ublen) / bytesPerLine;\n    while (TRUE) {\n        if (nlines > h)\n            nlines = h;\n        (*cl->translateFn)(cl->translateLookupTable,\n\t\t\t   &(cl->screen->serverFormat),\n                           &cl->format, fbptr, &cl->updateBuf[cl->ublen],\n                           cl->scaledScreen->paddedWidthInBytes, w, nlines);\n        cl->ublen += nlines * bytesPerLine;\n        h -= nlines;\n        if (h == 0)     \n            return TRUE;\n        if (!rfbSendUpdateBuf(cl))\n            return FALSE;\n        fbptr += (cl->scaledScreen->paddedWidthInBytes * nlines);\n        nlines = (UPDATE_BUF_SIZE - cl->ublen) / bytesPerLine;\n        if (nlines == 0) {\n            rfbErr(\"rfbSendRectEncodingRaw: send buffer too small for %d \"\n                   \"bytes per line\\n\", bytesPerLine);\n            rfbCloseClient(cl);\n            return FALSE;\n        }\n    }\n}", "target": 1}
{"code": "l_noret luaG_runerror (lua_State *L, const char *fmt, ...) {\n  CallInfo *ci = L->ci;\n  const char *msg;\n  va_list argp;\n  luaC_checkGC(L);  \n  va_start(argp, fmt);\n  msg = luaO_pushvfstring(L, fmt, argp);  \n  va_end(argp);\n  if (isLua(ci))  \n    luaG_addinfo(L, msg, ci_func(ci)->p->source, getcurrentline(ci));\n  luaG_errormsg(L);\n}", "target": 1}
{"code": "nvmet_fc_find_target_queue(struct nvmet_fc_tgtport *tgtport,\n\t\t\t\tu64 connection_id)\n{\n\tstruct nvmet_fc_tgt_assoc *assoc;\n\tstruct nvmet_fc_tgt_queue *queue;\n\tu64 association_id = nvmet_fc_getassociationid(connection_id);\n \tu16 qid = nvmet_fc_getqueueid(connection_id);\n \tunsigned long flags;\n \tspin_lock_irqsave(&tgtport->lock, flags);\n \tlist_for_each_entry(assoc, &tgtport->assoc_list, a_list) {\n \t\tif (association_id == assoc->association_id) {\n\t\t\tqueue = assoc->queues[qid];\n\t\t\tif (queue &&\n\t\t\t    (!atomic_read(&queue->connected) ||\n\t\t\t     !nvmet_fc_tgt_q_get(queue)))\n\t\t\t\tqueue = NULL;\n\t\t\tspin_unlock_irqrestore(&tgtport->lock, flags);\n\t\t\treturn queue;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&tgtport->lock, flags);\n\treturn NULL;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& dims = context->input(1);\n    if (TensorShapeUtils::IsScalar(input.shape())) {\n      context->set_output(0, input);\n    } else {\n      const int input_dims = input.dims();\n      OP_REQUIRES(context, TensorShapeUtils::IsVector(dims.shape()),\n                  errors::InvalidArgument(\"'dims' must be 1-dimension, not \",\n                                          dims.dims()));\n      OP_REQUIRES(\n          context, input_dims == dims.dim_size(0),\n          errors::InvalidArgument(\n              \"'dims' must have the same number of values as 'input' has \"\n              \"dimensions. 'input' has \",\n              input_dims, \"'dims' has \", dims.dim_size(0), \" values\"));\n      OP_REQUIRES(context, input_dims <= 8,\n                  errors::Unimplemented(\n                      \"reverse is not implemented for tensors of rank > 8.\"));\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK(context,\n                     context->allocate_output(0, input.shape(), &output));\n#define HANDLE_REVERSE(NDIMS)                                               \\\n  case NDIMS:                                                               \\\n    HandleReverseCase<Device, T, NDIMS>(context, dims.vec<bool>(), output); \\\n    return;\n      switch (input_dims) {\n        HANDLE_REVERSE(0);\n        HANDLE_REVERSE(1);\n        HANDLE_REVERSE(2);\n        HANDLE_REVERSE(3);\n        HANDLE_REVERSE(4);\n        HANDLE_REVERSE(5);\n        HANDLE_REVERSE(6);\n        HANDLE_REVERSE(7);\n        HANDLE_REVERSE(8);\n      }\n#undef HANDLE_REVERSE\n    }\n  }", "target": 1}
{"code": "psf_fwrite (const void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)\n {\tsf_count_t total = 0 ;\n \tssize_t\tcount ;\n \tif (psf->virtual_io)\n \t\treturn psf->vio.write (ptr, bytes*items, psf->vio_user_data) / bytes ;\n\titems *= bytes ;\n\tif (items <= 0)\n\t\treturn 0 ;\n\twhile (items > 0)\n\t{\t\n\t\tcount = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : items ;\n\t\tcount = write (psf->file.filedes, ((const char*) ptr) + total, count) ;\n\t\tif (count == -1)\n\t\t{\tif (errno == EINTR)\n\t\t\t\tcontinue ;\n\t\t\tpsf_log_syserr (psf, errno) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\t\tif (count == 0)\n\t\t\tbreak ;\n\t\ttotal += count ;\n\t\titems -= count ;\n\t\t} ;\n\tif (psf->is_pipe)\n\t\tpsf->pipeoffset += total ;\n\treturn total / bytes ;\n} ", "target": 1}
{"code": "tcf_fill_node(struct sk_buff *skb, struct tcf_proto *tp, unsigned long fh,\n\t      u32 pid, u32 seq, u16 flags, int event)\n{\n\tstruct tcmsg *tcm;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char\t *b = skb->tail;\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*tcm), flags);\n\ttcm = NLMSG_DATA(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm_ifindex = tp->q->dev->ifindex;\n\ttcm->tcm_parent = tp->classid;\n\ttcm->tcm_info = TC_H_MAKE(tp->prio, tp->protocol);\n\tRTA_PUT(skb, TCA_KIND, IFNAMSIZ, tp->ops->kind);\n\ttcm->tcm_handle = fh;\n\tif (RTM_DELTFILTER != event) {\n\t\ttcm->tcm_handle = 0;\n\t\tif (tp->ops->dump && tp->ops->dump(tp, fh, skb, tcm) < 0)\n\t\t\tgoto rtattr_failure;\n\t}\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\nnlmsg_failure:\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1}
{"code": "void snd_msndmidi_input_read(void *mpuv)\n{\n \tunsigned long flags;\n \tstruct snd_msndmidi *mpu = mpuv;\n \tvoid *pwMIDQData = mpu->dev->mappedbase + MIDQ_DATA_BUFF;\n \tspin_lock_irqsave(&mpu->input_lock, flags);\n\twhile (readw(mpu->dev->MIDQ + JQS_wTail) !=\n\t       readw(mpu->dev->MIDQ + JQS_wHead)) {\n\t\tu16 wTmp, val;\n\t\tval = readw(pwMIDQData + 2 * readw(mpu->dev->MIDQ + JQS_wHead));\n\t\t\tif (test_bit(MSNDMIDI_MODE_BIT_INPUT_TRIGGER,\n\t\t\t\t     &mpu->mode))\n\t\t\t\tsnd_rawmidi_receive(mpu->substream_input,\n\t\t\t\t\t\t    (unsigned char *)&val, 1);\n\t\twTmp = readw(mpu->dev->MIDQ + JQS_wHead) + 1;\n\t\tif (wTmp > readw(mpu->dev->MIDQ + JQS_wSize))\n\t\t\twritew(0,  mpu->dev->MIDQ + JQS_wHead);\n\t\telse\n\t\t\twritew(wTmp,  mpu->dev->MIDQ + JQS_wHead);\n \t}\n \tspin_unlock_irqrestore(&mpu->input_lock, flags);\n }", "target": 1}
{"code": "struct se_portal_group *tcm_loop_make_naa_tpg(\n\tstruct se_wwn *wwn,\n\tstruct config_group *group,\n\tconst char *name)\n{\n\tstruct tcm_loop_hba *tl_hba = container_of(wwn,\n\t\t\tstruct tcm_loop_hba, tl_hba_wwn);\n\tstruct tcm_loop_tpg *tl_tpg;\n\tchar *tpgt_str, *end_ptr;\n\tint ret;\n\tunsigned short int tpgt;\n\ttpgt_str = strstr(name, \"tpgt_\");\n\tif (!tpgt_str) {\n\t\tprintk(KERN_ERR \"Unable to locate \\\"tpgt_#\\\" directory\"\n\t\t\t\t\" group\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n \ttpgt_str += 5; \n \ttpgt = (unsigned short int) simple_strtoul(tpgt_str, &end_ptr, 0);\n\tif (tpgt > TL_TPGS_PER_HBA) {\n \t\tprintk(KERN_ERR \"Passed tpgt: %hu exceeds TL_TPGS_PER_HBA:\"\n \t\t\t\t\" %u\\n\", tpgt, TL_TPGS_PER_HBA);\n \t\treturn ERR_PTR(-EINVAL);\n\t}\n\ttl_tpg = &tl_hba->tl_hba_tpgs[tpgt];\n\ttl_tpg->tl_hba = tl_hba;\n\ttl_tpg->tl_tpgt = tpgt;\n\tret = core_tpg_register(&tcm_loop_fabric_configfs->tf_ops,\n\t\t\twwn, &tl_tpg->tl_se_tpg, tl_tpg,\n\t\t\tTRANSPORT_TPG_TYPE_NORMAL);\n\tif (ret < 0)\n\t\treturn ERR_PTR(-ENOMEM);\n\tprintk(KERN_INFO \"TCM_Loop_ConfigFS: Allocated Emulated %s\"\n\t\t\" Target Port %s,t,0x%04x\\n\", tcm_loop_dump_proto_id(tl_hba),\n\t\tconfig_item_name(&wwn->wwn_group.cg_item), tpgt);\n\treturn &tl_tpg->tl_se_tpg;\n}", "target": 1}
{"code": "void add_interrupt_randomness(int irq, int irq_flags)\n{\n\tstruct entropy_store\t*r;\n\tstruct fast_pool\t*fast_pool = this_cpu_ptr(&irq_randomness);\n\tstruct pt_regs\t\t*regs = get_irq_regs();\n\tunsigned long\t\tnow = jiffies;\n\tcycles_t\t\tcycles = random_get_entropy();\n\t__u32\t\t\tc_high, j_high;\n\t__u64\t\t\tip;\n\tunsigned long\t\tseed;\n\tint\t\t\tcredit = 0;\n\tif (cycles == 0)\n\t\tcycles = get_reg(fast_pool, regs);\n\tc_high = (sizeof(cycles) > 4) ? cycles >> 32 : 0;\n\tj_high = (sizeof(now) > 4) ? now >> 32 : 0;\n\tfast_pool->pool[0] ^= cycles ^ j_high ^ irq;\n\tfast_pool->pool[1] ^= now ^ c_high;\n\tip = regs ? instruction_pointer(regs) : _RET_IP_;\n\tfast_pool->pool[2] ^= ip;\n\tfast_pool->pool[3] ^= (sizeof(ip) > 4) ? ip >> 32 :\n\t\tget_reg(fast_pool, regs);\n\tfast_mix(fast_pool);\n\tadd_interrupt_bench(cycles);\n\tif (unlikely(crng_init == 0)) {\n\t\tif ((fast_pool->count >= 64) &&\n\t\t    crng_fast_load((char *) fast_pool->pool,\n\t\t\t\t   sizeof(fast_pool->pool))) {\n\t\t\tfast_pool->count = 0;\n\t\t\tfast_pool->last = now;\n\t\t}\n\t\treturn;\n\t}\n\tif ((fast_pool->count < 64) &&\n\t    !time_after(now, fast_pool->last + HZ))\n\t\treturn;\n\tr = &input_pool;\n\tif (!spin_trylock(&r->lock))\n\t\treturn;\n\tfast_pool->last = now;\n\t__mix_pool_bytes(r, &fast_pool->pool, sizeof(fast_pool->pool));\n\tif (arch_get_random_seed_long(&seed)) {\n\t\t__mix_pool_bytes(r, &seed, sizeof(seed));\n\t\tcredit = 1;\n\t}\n\tspin_unlock(&r->lock);\n\tfast_pool->count = 0;\n\tcredit_entropy_bits(r, credit + 1);\n}", "target": 1}
{"code": "njs_array_convert_to_slow_array(njs_vm_t *vm, njs_array_t *array)\n{\n    uint32_t           i, length;\n    njs_value_t        index, value;\n    njs_object_prop_t  *prop;\n    njs_set_array(&value, array);\n    array->object.fast_array = 0;\n    length = array->length;\n    for (i = 0; i < length; i++) {\n        if (njs_is_valid(&array->start[i])) {\n            njs_uint32_to_string(&index, i);\n            prop = njs_object_property_add(vm, &value, &index, 0);\n            if (njs_slow_path(prop == NULL)) {\n                return NJS_ERROR;\n            }\n            prop->value = array->start[i];\n        }\n    }\n    njs_mp_free(vm->mem_pool, array->start);\n    array->start = NULL;\n    return NJS_OK;\n}", "target": 1}
{"code": "static int jpeg_size(unsigned char* data, unsigned int data_size,\n                     int *width, int *height)\n{\n    int i = 0;\n    if (i + 3 < data_size && data[i] == 0xFF && data[i+1] == 0xD8 &&\n            data[i+2] == 0xFF && data[i+3] == 0xE0) {\n        i += 4;\n        if(i + 6 < data_size &&\n                data[i+2] == 'J' && data[i+3] == 'F' && data[i+4] == 'I' &&\n                data[i+5] == 'F' && data[i+6] == 0x00) {\n            unsigned short block_length = data[i] * 256 + data[i+1];\n            while(i<data_size) {\n                i+=block_length;\n                if((i + 1) >= data_size)\n                    return -1;\n                if(data[i] != 0xFF)\n                    return -1;\n                if(data[i+1] == 0xC0) {\n                    *height = data[i+5]*256 + data[i+6];\n                    *width = data[i+7]*256 + data[i+8];\n                     return 0;\n                 }\n                 i+=2;\n                block_length = data[i] * 256 + data[i+1];\n             }\n         }\n     }\n    return -1;\n}", "target": 1}
{"code": "ptp_unpack_OPL (PTPParams *params, unsigned char* data, MTPProperties **pprops, unsigned int len)\n{ \n\tuint32_t prop_count = dtoh32a(data);\n\tMTPProperties *props = NULL;\n\tunsigned int offset = 0, i;\n\tif (prop_count == 0) {\n\t\t*pprops = NULL;\n\t\treturn 0;\n\t}\n\tptp_debug (params ,\"Unpacking MTP OPL, size %d (prop_count %d)\", len, prop_count);\n\tdata += sizeof(uint32_t);\n\tlen -= sizeof(uint32_t);\n\tprops = malloc(prop_count * sizeof(MTPProperties));\n\tif (!props) return 0;\n\tfor (i = 0; i < prop_count; i++) {\n\t\tif (len <= 0) {\n\t\t\tptp_debug (params ,\"short MTP Object Property List at property %d (of %d)\", i, prop_count);\n\t\t\tptp_debug (params ,\"device probably needs DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL\", i);\n\t\t\tptp_debug (params ,\"or even DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST\", i);\n\t\t\tqsort (props, i, sizeof(MTPProperties),_compare_func);\n\t\t\t*pprops = props;\n\t\t\treturn i;\n\t\t}\n\t\tprops[i].ObjectHandle = dtoh32a(data);\n\t\tdata += sizeof(uint32_t);\n\t\tlen -= sizeof(uint32_t);\n\t\tprops[i].property = dtoh16a(data);\n\t\tdata += sizeof(uint16_t);\n\t\tlen -= sizeof(uint16_t);\n\t\tprops[i].datatype = dtoh16a(data);\n\t\tdata += sizeof(uint16_t);\n\t\tlen -= sizeof(uint16_t);\n\t\toffset = 0;\n\t\tptp_unpack_DPV(params, data, &offset, len, &props[i].propval, props[i].datatype);\n\t\tdata += offset;\n\t\tlen -= offset;\n\t}\n\tqsort (props, prop_count, sizeof(MTPProperties),_compare_func);\n\t*pprops = props;\n\treturn prop_count;\n}", "target": 1}
{"code": "int mpol_parse_str(char *str, struct mempolicy **mpol)\n{\n\tstruct mempolicy *new = NULL;\n\tunsigned short mode_flags;\n\tnodemask_t nodes;\n\tchar *nodelist = strchr(str, ':');\n\tchar *flags = strchr(str, '=');\n\tint err = 1, mode;\n\tif (flags)\n\t\t*flags++ = '\\0';\t\n\tif (nodelist) {\n\t\t*nodelist++ = '\\0';\n\t\tif (nodelist_parse(nodelist, nodes))\n\t\t\tgoto out;\n\t\tif (!nodes_subset(nodes, node_states[N_MEMORY]))\n\t\t\tgoto out;\n\t} else\n\t\tnodes_clear(nodes);\n\tmode = match_string(policy_modes, MPOL_MAX, str);\n\tif (mode < 0)\n\t\tgoto out;\n\tswitch (mode) {\n\tcase MPOL_PREFERRED:\n\t\tif (nodelist) {\n\t\t\tchar *rest = nodelist;\n\t\t\twhile (isdigit(*rest))\n\t\t\t\trest++;\n\t\t\tif (*rest)\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase MPOL_INTERLEAVE:\n\t\tif (!nodelist)\n\t\t\tnodes = node_states[N_MEMORY];\n\t\tbreak;\n\tcase MPOL_LOCAL:\n\t\tif (nodelist)\n\t\t\tgoto out;\n\t\tmode = MPOL_PREFERRED;\n\t\tbreak;\n\tcase MPOL_DEFAULT:\n\t\tif (!nodelist)\n\t\t\terr = 0;\n\t\tgoto out;\n\tcase MPOL_BIND:\n\t\tif (!nodelist)\n\t\t\tgoto out;\n\t}\n\tmode_flags = 0;\n\tif (flags) {\n\t\tif (!strcmp(flags, \"static\"))\n\t\t\tmode_flags |= MPOL_F_STATIC_NODES;\n\t\telse if (!strcmp(flags, \"relative\"))\n\t\t\tmode_flags |= MPOL_F_RELATIVE_NODES;\n\t\telse\n\t\t\tgoto out;\n\t}\n\tnew = mpol_new(mode, mode_flags, &nodes);\n\tif (IS_ERR(new))\n\t\tgoto out;\n\tif (mode != MPOL_PREFERRED)\n\t\tnew->v.nodes = nodes;\n\telse if (nodelist)\n\t\tnew->v.preferred_node = first_node(nodes);\n\telse\n\t\tnew->flags |= MPOL_F_LOCAL;\n\tnew->w.user_nodemask = nodes;\n\terr = 0;\nout:\n\tif (nodelist)\n\t\t*--nodelist = ':';\n\tif (flags)\n\t\t*--flags = '=';\n\tif (!err)\n\t\t*mpol = new;\n\treturn err;\n}", "target": 1}
{"code": "static bool php_mb_parse_encoding(const Variant& encoding,\n                                  mbfl_encoding ***return_list,\n                                  int *return_size, bool persistent) {\n  bool ret;\n  if (encoding.isArray()) {\n    ret = php_mb_parse_encoding_array(encoding.toArray(),\n                                      return_list, return_size,\n                                      persistent ? 1 : 0);\n  } else {\n    String enc = encoding.toString();\n    ret = php_mb_parse_encoding_list(enc.data(), enc.size(),\n                                     return_list, return_size,\n                                     persistent ? 1 : 0);\n  }\n  if (!ret) {\n    if (return_list && *return_list) {\n      free(*return_list);\n      *return_list = nullptr;\n    }\n    return_size = 0;\n  }\n  return ret;\n}", "target": 1}
{"code": "_parse_pat (GstMpegtsSection * section)\n{\n  GPtrArray *pat;\n  guint16 i = 0, nb_programs;\n  GstMpegtsPatProgram *program;\n  guint8 *data, *end;\n  data = section->data + 8;\n  end = section->data + section->section_length;\n  nb_programs = (end - 4 - data) / 4;\n  pat =\n      g_ptr_array_new_full (nb_programs,\n      (GDestroyNotify) _mpegts_pat_program_free);\n  while (data < end - 4) {\n    program = g_slice_new0 (GstMpegtsPatProgram);\n    program->program_number = GST_READ_UINT16_BE (data);\n    data += 2;\n    program->network_or_program_map_PID = GST_READ_UINT16_BE (data) & 0x1FFF;\n    data += 2;\n    g_ptr_array_index (pat, i) = program;\n    i++;\n  }\n  pat->len = nb_programs;\n  if (data != end - 4) {\n    GST_ERROR (\"at the end of PAT data != end - 4\");\n    g_ptr_array_unref (pat);\n    return NULL;\n  }\n  return (gpointer) pat;\n}", "target": 1}
{"code": "int af_alg_release(struct socket *sock)\n{\n\tif (sock->sk)\n\t\tsock_put(sock->sk);\n\treturn 0;\n}", "target": 1}
{"code": "int imap_open_connection (IMAP_DATA* idata)\n{\n  if (mutt_socket_open (idata->conn) < 0)\n    return -1;\n  idata->state = IMAP_CONNECTED;\n  if (imap_cmd_step (idata) != IMAP_CMD_OK)\n  {\n    imap_close_connection (idata);\n    return -1;\n  }\n  if (ascii_strncasecmp (\"* OK\", idata->buf, 4) == 0)\n  {\n    if (ascii_strncasecmp (\"* OK [CAPABILITY\", idata->buf, 16)\n        && imap_check_capabilities (idata))\n      goto bail;\n#if defined(USE_SSL)\n    if (!idata->conn->ssf && (option(OPTSSLFORCETLS) ||\n                              mutt_bit_isset (idata->capabilities, STARTTLS)))\n    {\n      int rc;\n      if (option(OPTSSLFORCETLS))\n        rc = MUTT_YES;\n      else if ((rc = query_quadoption (OPT_SSLSTARTTLS,\n                                       _(\"Secure connection with TLS?\"))) == -1)\n\tgoto err_close_conn;\n      if (rc == MUTT_YES)\n      {\n\tif ((rc = imap_exec (idata, \"STARTTLS\", IMAP_CMD_FAIL_OK)) == -1)\n\t  goto bail;\n\tif (rc != -2)\n\t{\n\t  if (mutt_ssl_starttls (idata->conn))\n\t  {\n\t    mutt_error (_(\"Could not negotiate TLS connection\"));\n\t    mutt_sleep (1);\n\t    goto err_close_conn;\n\t  }\n\t  else\n\t  {\n\t    if (imap_exec (idata, \"CAPABILITY\", 0))\n\t      goto bail;\n\t  }\n\t}\n      }\n    }\n    if (option(OPTSSLFORCETLS) && ! idata->conn->ssf)\n    {\n      mutt_error _(\"Encrypted connection unavailable\");\n      mutt_sleep (1);\n      goto err_close_conn;\n    }\n#endif\n  }\n  else if (ascii_strncasecmp (\"* PREAUTH\", idata->buf, 9) == 0)\n  {\n    idata->state = IMAP_AUTHENTICATED;\n    if (imap_check_capabilities (idata) != 0)\n      goto bail;\n    FREE (&idata->capstr);\n  }\n  else\n  {\n    imap_error (\"imap_open_connection()\", idata->buf);\n    goto bail;\n  }\n  return 0;\n#if defined(USE_SSL)\nerr_close_conn:\n  imap_close_connection (idata);\n#endif\nbail:\n  FREE (&idata->capstr);\n  return -1;\n}", "target": 1}
{"code": "void gfs2_clear_rgrpd(struct gfs2_sbd *sdp)\n{\n\tstruct rb_node *n;\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_glock *gl;\n\twhile ((n = rb_first(&sdp->sd_rindex_tree))) {\n\t\trgd = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\t\tgl = rgd->rd_gl;\n\t\trb_erase(n, &sdp->sd_rindex_tree);\n\t\tif (gl) {\n\t\t\tspin_lock(&gl->gl_lockref.lock);\n\t\t\tgl->gl_object = NULL;\n\t\t\tspin_unlock(&gl->gl_lockref.lock);\n\t\t\tgfs2_glock_add_to_lru(gl);\n\t\t\tgfs2_glock_put(gl);\n\t\t}\n\t\tgfs2_free_clones(rgd);\n\t\tkfree(rgd->rd_bits);\n\t\treturn_all_reservations(rgd);\n\t\tkmem_cache_free(gfs2_rgrpd_cachep, rgd);\n\t}\n}", "target": 1}
{"code": "GURL URLFixerUpper::FixupRelativeFile(const FilePath& base_dir,\n                                      const FilePath& text) {\n  FilePath old_cur_directory;\n  if (!base_dir.empty()) {\n    file_util::GetCurrentDirectory(&old_cur_directory);\n    file_util::SetCurrentDirectory(base_dir);\n  }\n  FilePath::StringType trimmed;\n   PrepareStringForFileOps(text, &trimmed);\n   bool is_file = true;\n   FilePath full_path;\n  if (!ValidPathForFile(trimmed, &full_path)) {\n#if defined(OS_WIN)\n    std::wstring unescaped = UTF8ToWide(UnescapeURLComponent(\n        WideToUTF8(trimmed),\n        UnescapeRule::SPACES | UnescapeRule::URL_SPECIAL_CHARS));\n#elif defined(OS_POSIX)\n    std::string unescaped = UnescapeURLComponent(\n        trimmed,\n        UnescapeRule::SPACES | UnescapeRule::URL_SPECIAL_CHARS);\n#endif\n    if (!ValidPathForFile(unescaped, &full_path))\n      is_file = false;\n  }\n  if (!base_dir.empty())\n    file_util::SetCurrentDirectory(old_cur_directory);\n  if (is_file) {\n    GURL file_url = net::FilePathToFileURL(full_path);\n    if (file_url.is_valid())\n      return GURL(UTF16ToUTF8(net::FormatUrl(file_url, std::string(),\n          net::kFormatUrlOmitUsernamePassword, UnescapeRule::NORMAL, NULL,\n          NULL, NULL)));\n  }\n#if defined(OS_WIN)\n  std::string text_utf8 = WideToUTF8(text.value());\n#elif defined(OS_POSIX)\n  std::string text_utf8 = text.value();\n#endif\n  return FixupURL(text_utf8, std::string());\n}", "target": 1}
{"code": "void* chk_malloc(size_t bytes)\n{\n    char* buffer = (char*)dlmalloc(bytes + CHK_OVERHEAD_SIZE);\n    if (buffer) {\n        memset(buffer, CHK_SENTINEL_VALUE, bytes + CHK_OVERHEAD_SIZE);\n        size_t offset = dlmalloc_usable_size(buffer) - sizeof(size_t);\n        *(size_t *)(buffer + offset) = bytes;\n        buffer += CHK_SENTINEL_HEAD_SIZE;\n    }\n    return buffer;\n}", "target": 1}
{"code": "init_state(struct posix_acl_state *state, int cnt)\n{\n\tint alloc;\n\tmemset(state, 0, sizeof(struct posix_acl_state));\n\tstate->empty = 1;\n\talloc = sizeof(struct posix_ace_state_array)\n\t\t+ cnt*sizeof(struct posix_ace_state);\n\tstate->users = kzalloc(alloc, GFP_KERNEL);\n\tif (!state->users)\n\t\treturn -ENOMEM;\n\tstate->groups = kzalloc(alloc, GFP_KERNEL);\n\tif (!state->groups) {\n\t\tkfree(state->users);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& rhs = context->input(1);\n    context->forward_ref_input_to_ref_output(0, 0);\n    AllocatorAttributes attr;\n    if (!relax_constraints_) {\n      attr.set_gpu_compatible(true);\n      attr.set_nic_compatible(true);\n    }\n    {\n      mutex_lock l(*context->input_ref_mutex(0));\n      const Tensor& old_lhs = context->mutable_input(0,  true);\n      const bool same_shape = old_lhs.shape().IsSameSize(rhs.shape());\n      if (validate_shape_) {\n        OP_REQUIRES(context, same_shape,\n                    errors::InvalidArgument(\n                        \"Assign requires shapes of both tensors to match. \"\n                        \"lhs shape= \",\n                        old_lhs.shape().DebugString(),\n                        \" rhs shape= \", rhs.shape().DebugString()));\n      }\n      if (old_lhs.IsInitialized() &&\n          old_lhs.shape().num_elements() == rhs.shape().num_elements()) {\n        Tensor reshaped_old_lhs;\n        if (same_shape) {\n          reshaped_old_lhs = old_lhs;\n        } else {\n          CHECK(reshaped_old_lhs.CopyFrom(old_lhs, rhs.shape()));\n          context->replace_ref_input(0, reshaped_old_lhs,\n                                      true);\n        }\n        if (use_exclusive_lock_) {\n          Copy(context, &reshaped_old_lhs, rhs);\n          return;\n        }\n      } else {\n        std::unique_ptr<Tensor> input_alias = context->forward_input(\n            1, OpKernelContext::Params::kNoReservation ,\n            rhs.dtype(), rhs.shape(), DEVICE_MEMORY, attr);\n        if (input_alias != nullptr) {\n          context->replace_ref_input(0, *input_alias,  true);\n          return;\n        }\n        Tensor copy_tensor;\n        OP_REQUIRES_OK(context,\n                       context->allocate_temp(old_lhs.dtype(), rhs.shape(),\n                                              &copy_tensor, attr));\n        context->clear_recorded_memory();\n        context->replace_ref_input(0, copy_tensor,  true);\n        if (use_exclusive_lock_) {\n          Copy(context, &copy_tensor, rhs);\n          return;\n        }\n      }\n    }\n    Tensor old_unlocked_lhs = context->mutable_input(0,  false);\n    Copy(context, &old_unlocked_lhs, rhs);\n  }", "target": 1}
{"code": "static inline void fuse_make_bad(struct inode *inode)\n{\n\tset_bit(FUSE_I_BAD, &get_fuse_inode(inode)->state);\n}", "target": 1}
{"code": "static void *seq_buf_alloc(unsigned long size)\n{\n\treturn kvmalloc(size, GFP_KERNEL_ACCOUNT);\n}", "target": 1}
{"code": "static int rose_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint *uaddr_len, int peer)\n{\n\tstruct full_sockaddr_rose *srose = (struct full_sockaddr_rose *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tint n;\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->dest_addr;\n\t\tsrose->srose_call   = rose->dest_call;\n\t\tsrose->srose_ndigis = rose->dest_ndigis;\n\t\tfor (n = 0; n < rose->dest_ndigis; n++)\n\t\t\tsrose->srose_digis[n] = rose->dest_digis[n];\n\t} else {\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->source_addr;\n\t\tsrose->srose_call   = rose->source_call;\n\t\tsrose->srose_ndigis = rose->source_ndigis;\n\t\tfor (n = 0; n < rose->source_ndigis; n++)\n\t\t\tsrose->srose_digis[n] = rose->source_digis[n];\n\t}\n\t*uaddr_len = sizeof(struct full_sockaddr_rose);\n\treturn 0;\n}", "target": 1}
{"code": "ImagingPcxDecode(Imaging im, ImagingCodecState state, UINT8* buf, Py_ssize_t bytes)\n{\n    UINT8 n;\n    UINT8* ptr;\n    if (strcmp(im->mode, \"1\") == 0 && state->xsize > state->bytes * 8) {\n        state->errcode = IMAGING_CODEC_OVERRUN;\n        return -1;\n    }\n    ptr = buf;\n    for (;;) {\n\tif (bytes < 1)\n\t    return ptr - buf;\n\tif ((*ptr & 0xC0) == 0xC0) {\n\t    if (bytes < 2)\n\t\treturn ptr - buf;\n\t    n = ptr[0] & 0x3F;\n\t    while (n > 0) {\n\t\tif (state->x >= state->bytes) {\n\t\t    state->errcode = IMAGING_CODEC_OVERRUN;\n\t\t    break;\n\t\t}\n\t\tstate->buffer[state->x++] = ptr[1];\n\t\tn--;\n\t    }\n\t    ptr += 2; bytes -= 2;\n\t} else {\n\t    state->buffer[state->x++] = ptr[0];\n\t    ptr++; bytes--;\n\t}\n\tif (state->x >= state->bytes) {\n        if (state->bytes % state->xsize && state->bytes > state->xsize) {\n            int bands = state->bytes / state->xsize;\n            int stride = state->bytes / bands;\n            int i;\n            for (i=1; i< bands; i++) {  \n                memmove(&state->buffer[i*state->xsize],\n                        &state->buffer[i*stride],\n                        state->xsize);\n            }\n        }\n\t    state->shuffle((UINT8*) im->image[state->y + state->yoff] +\n\t\t\t   state->xoff * im->pixelsize, state->buffer,\n\t\t\t   state->xsize);\n\t    state->x = 0;\n\t    if (++state->y >= state->ysize) {\n\t\treturn -1;\n\t    }\n\t}\n    }\n}", "target": 1}
{"code": "SRP_user_pwd *SRP_VBASE_get_by_user(SRP_VBASE *vb, char *username)\n {\n     int i;\n     SRP_user_pwd *user;\n    unsigned char digv[SHA_DIGEST_LENGTH];\n    unsigned char digs[SHA_DIGEST_LENGTH];\n    EVP_MD_CTX ctxt;\n     if (vb == NULL)\n         return NULL;\n     for (i = 0; i < sk_SRP_user_pwd_num(vb->users_pwd); i++) {\n         user = sk_SRP_user_pwd_value(vb->users_pwd, i);\n         if (strcmp(user->id, username) == 0)\n             return user;\n     }\n     if ((vb->seed_key == NULL) ||\n         (vb->default_g == NULL) || (vb->default_N == NULL))\n         return NULL;\n        if (!(len = t_fromb64(tmp, N)))\n            goto err;\n        N_bn = BN_bin2bn(tmp, len, NULL);\n        if (!(len = t_fromb64(tmp, g)))\n            goto err;\n        g_bn = BN_bin2bn(tmp, len, NULL);\n        defgNid = \"*\";\n    } else {\n        SRP_gN *gN = SRP_get_gN_by_id(g, NULL);\n        if (gN == NULL)\n            goto err;\n        N_bn = gN->N;\n        g_bn = gN->g;\n        defgNid = gN->id;\n    }", "target": 1}
{"code": "ImmutableConstantOp::ImmutableConstantOp(OpKernelConstruction* context)\n    : OpKernel(context) {\n  OP_REQUIRES_OK(context,\n                 context->GetAttr(kMemoryRegionNameAttr, &region_name_));\n  OP_REQUIRES_OK(context, context->GetAttr(kDTypeAttr, &dtype_));\n  OP_REQUIRES_OK(context, context->GetAttr(kShapeAttr, &shape_));\n}", "target": 1}
{"code": "ipmi_get_channel_cipher_suites(struct ipmi_intf *intf,\n                               const char *payload_type,\n                               uint8_t channel,\n                               struct cipher_suite_info *suites,\n                               size_t *count)\n{\n\tstruct ipmi_rs *rsp;\n\tstruct ipmi_rq req;\n\tuint8_t rqdata[3];\n\tuint8_t list_index = 0;\n\tuint8_t cipher_suite_data[MAX_CIPHER_SUITE_RECORD_OFFSET *\n\t                          MAX_CIPHER_SUITE_DATA_LEN];\n\tsize_t offset = 0;\n\tsize_t nr_suites = 0;\n\tif (!suites || !count || !*count)\n\t\treturn -1;\n\tnr_suites = *count;\n\t*count = 0;\n\tmemset(cipher_suite_data, 0, sizeof(cipher_suite_data));\n\tmemset(&req, 0, sizeof(req));\n\treq.msg.netfn = IPMI_NETFN_APP;\n\treq.msg.cmd = IPMI_GET_CHANNEL_CIPHER_SUITES;\n\treq.msg.data = rqdata;\n\treq.msg.data_len = sizeof(rqdata);\n\trqdata[0] = channel;\n\trqdata[1] = ((strncmp(payload_type, \"ipmi\", 4) == 0)? 0: 1);\n\tdo {\n\t\trqdata[2] = LIST_ALGORITHMS_BY_CIPHER_SUITE | list_index;\n\t\trsp = intf->sendrecv(intf, &req);\n\t\tif (!rsp) {\n\t\t\tlprintf(LOG_ERR, \"Unable to Get Channel Cipher Suites\");\n\t\t\treturn -1;\n\t\t}\n\t\tif (rsp->ccode || rsp->data_len < 1) {\n\t\t\tlprintf(LOG_ERR, \"Get Channel Cipher Suites failed: %s\",\n\t\t\t\t\tval2str(rsp->ccode, completion_code_vals));\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(cipher_suite_data + offset, rsp->data + 1, rsp->data_len - 1);\n\t\toffset += rsp->data_len - 1;\n\t\t++list_index;\n\t} while ((rsp->data_len == (sizeof(uint8_t) + MAX_CIPHER_SUITE_DATA_LEN))\n\t         && (list_index < MAX_CIPHER_SUITE_RECORD_OFFSET));\n\t*count = parse_channel_cipher_suite_data(cipher_suite_data, offset, suites,\n\t                                         nr_suites);\n\treturn 0;\n}", "target": 1}
{"code": "int git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\t\treturn (int)len;\n\t}\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\tif (len != 0 && len < PKT_LEN_SIZE)\n\t\treturn GIT_ERROR;\n \tline += PKT_LEN_SIZE;\n \tif (len == PKT_LEN_SIZE) {\n\t\t*head = NULL;\n\t\t*out = line;\n\t\treturn 0;\n \t}\n \tif (len == 0) { \n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\tlen -= PKT_LEN_SIZE; \n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\t*out = line + len;\n\treturn ret;\n}", "target": 1}
{"code": "static int decode_tree_entry(struct tree_desc *desc, const char *buf, unsigned long size, struct strbuf *err)\n{\n\tconst char *path;\n\tunsigned int mode, len;\n\tif (size < 23 || buf[size - 21]) {\n\t\tstrbuf_addstr(err, _(\"too-short tree object\"));\n\t\treturn -1;\n\t}\n\tpath = get_mode(buf, &mode);\n\tif (!path) {\n\t\tstrbuf_addstr(err, _(\"malformed mode in tree entry\"));\n\t\treturn -1;\n\t}\n\tif (!*path) {\n\t\tstrbuf_addstr(err, _(\"empty filename in tree entry\"));\n\t\treturn -1;\n\t}\n\tlen = strlen(path) + 1;\n\tdesc->entry.path = path;\n\tdesc->entry.mode = canon_mode(mode);\n\tdesc->entry.oid  = (const struct object_id *)(path + len);\n\treturn 0;\n}", "target": 1}
{"code": "static Status ValidateSavedTensors(const GraphDef& graph_def) {\n  for (const auto& node : graph_def.node()) {\n    const auto node_iterator = node.attr().find(\"value\");\n    if (node_iterator != node.attr().end()) {\n      AttrValue node_value = node_iterator->second;\n      if (node_value.has_tensor()) {\n        const PartialTensorShape node_shape(node_value.tensor().tensor_shape());\n        if (node_shape.num_elements() < 0) {\n          return errors::FailedPrecondition(\n              \"Saved model contains node \\\"\", node.name(), \"\\\" (op \\\"\",\n              node.op(), \"\\\") which initializes from a tensor with \",\n              node_shape.num_elements(), \" elements\");\n        }\n      }\n    } else if (node.op() == \"Const\") {\n      return errors::FailedPrecondition(\n          \"Saved model contains node \\\"\", node.name(),\n          \"\\\" which is a constant tensor but no value has been provided\");\n    }\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "FILE *fopen_safe(const char *path, const char *mode)\n{\n\tint fd;\n\tFILE *file;\n\tint flags = O_NOFOLLOW | O_CREAT;\n\tint sav_errno;\n\tif (mode[0] == 'r')\n\t\treturn fopen(path, mode);\n\tif ((mode[0] != 'a' && mode[0] != 'w') ||\n\t    (mode[1] &&\n\t     (mode[1] != '+' || mode[2]))) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif (mode[0] == 'w')\n\t\tflags |= O_TRUNC;\n\telse\n\t\tflags |= O_APPEND;\n\tif (mode[1])\n\t\tflags |= O_RDWR;\n\telse\n\t\tflags |= O_WRONLY;\n\tif (mode[0] == 'w') {\n\t\tif (unlink(path) && errno != ENOENT) {\n\t\t\tlog_message(LOG_INFO, \"Failed to remove existing file '%s' prior to write\", path);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\telse {\n#ifndef ENABLE_LOG_FILE_APPEND\n\t\tlog_message(LOG_INFO, \"BUG - shouldn't be opening file for append with current build options\");\n\t\terrno = EINVAL;\n\t\treturn NULL;\n#endif\n\t}\n\tfd = open(path, flags, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n\tif (fd == -1)\n\t\treturn NULL;\n\tif (fchown(fd, 0, 0)) {\n\t\tsav_errno = errno;\n\t\tlog_message(LOG_INFO, \"Unable to change file ownership of %s- errno %d (%m)\", path, errno);\n\t\tclose(fd);\n\t\terrno = sav_errno;\n\t\treturn NULL;\n\t}\n\tif (fchmod(fd, S_IRUSR | S_IWUSR)) {\n\t\tsav_errno = errno;\n\t\tlog_message(LOG_INFO, \"Unable to change file permission of %s - errno %d (%m)\", path, errno);\n\t\tclose(fd);\n\t\terrno = sav_errno;\n\t\treturn NULL;\n\t}\n\tfile = fdopen (fd, \"w\");\n\tif (!file) {\n\t\tsav_errno = errno;\n\t\tlog_message(LOG_INFO, \"fdopen(\\\"%s\\\") failed - errno %d (%m)\", path, errno);\n\t\tclose(fd);\n\t\terrno = sav_errno;\n\t\treturn NULL;\n\t}\n\treturn file;\n}", "target": 1}
{"code": "static void parse_relocation_info(struct MACH0_(obj_t) *bin, RSkipList *relocs, ut32 offset, ut32 num) {\n\tif (!num || !offset || (st32)num < 0) {\n\t\treturn;\n\t}\n\tut64 total_size = num * sizeof (struct relocation_info);\n\tif (offset > bin->size) {\n\t\treturn;\n\t}\n\tif (total_size > bin->size) {\n\t\ttotal_size = bin->size - offset;\n\t\tnum = total_size /= sizeof (struct relocation_info);\n\t}\n\tstruct relocation_info *info = calloc (num, sizeof (struct relocation_info));\n\tif (!info) {\n\t\treturn;\n\t}\n\tif (r_buf_read_at (bin->b, offset, (ut8 *) info, total_size) < total_size) {\n\t\tfree (info);\n\t\treturn;\n\t}\n\tsize_t i;\n\tfor (i = 0; i < num; i++) {\n\t\tstruct relocation_info a_info = info[i];\n\t\tut32 sym_num = a_info.r_symbolnum;\n\t\tif (sym_num > bin->nsymtab) {\n\t\t\tcontinue;\n\t\t}\n\t\tut32 stridx = bin->symtab[sym_num].n_strx;\n\t\tchar *sym_name = get_name (bin, stridx, false);\n\t\tif (!sym_name) {\n\t\t\tcontinue;\n\t\t}\n\t\tstruct reloc_t *reloc = R_NEW0 (struct reloc_t);\n\t\tif (!reloc) {\n\t\t\tfree (info);\n\t\t\tfree (sym_name);\n\t\t\treturn;\n\t\t}\n\t\treloc->addr = offset_to_vaddr (bin, a_info.r_address);\n\t\treloc->offset = a_info.r_address;\n\t\treloc->ord = sym_num;\n\t\treloc->type = a_info.r_type; \n\t\treloc->external = a_info.r_extern;\n\t\treloc->pc_relative = a_info.r_pcrel;\n\t\treloc->size = a_info.r_length;\n\t\tr_str_ncpy (reloc->name, sym_name, sizeof (reloc->name) - 1);\n\t\tr_skiplist_insert (relocs, reloc);\n\t\tfree (sym_name);\n\t}\n\tfree (info);\n}", "target": 1}
{"code": "bool WindowsServiceControl::install( const QString& filePath, const QString& displayName  )\n{\n\tm_serviceHandle = CreateService(\n\t\t\t\tm_serviceManager,\t\t\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( m_name ),\t\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( displayName ),\n\t\t\t\tSERVICE_ALL_ACCESS,\t\n\t\t\t\tSERVICE_WIN32_OWN_PROCESS,\n\t\t\t\tSERVICE_AUTO_START,\t\n\t\t\t\tSERVICE_ERROR_NORMAL,\t\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( filePath ),\t\t\n\t\t\t\tnullptr,\t\t\t\n\t\t\t\tnullptr,\t\t\t\n\t\t\t\tL\"Tcpip\\0RpcSs\\0\\0\",\t\t\n\t\t\t\tnullptr,\t\t\t\n\t\t\t\tnullptr );\t\t\t\n\tif( m_serviceHandle == nullptr )\n\t{\n\t\tconst auto error = GetLastError();\n\t\tif( error == ERROR_SERVICE_EXISTS )\n\t\t{\n\t\t\tvCritical() << qUtf8Printable( tr( \"The service \\\"%1\\\" is already installed.\" ).arg( m_name ) );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvCritical() << qUtf8Printable( tr( \"The service \\\"%1\\\" could not be installed.\" ).arg( m_name ) );\n\t\t}\n\t\treturn false;\n\t}\n\tSC_ACTION serviceActions;\n\tserviceActions.Delay = 10000;\n\tserviceActions.Type = SC_ACTION_RESTART;\n\tSERVICE_FAILURE_ACTIONS serviceFailureActions;\n\tserviceFailureActions.dwResetPeriod = 0;\n\tserviceFailureActions.lpRebootMsg = nullptr;\n\tserviceFailureActions.lpCommand = nullptr;\n\tserviceFailureActions.lpsaActions = &serviceActions;\n\tserviceFailureActions.cActions = 1;\n\tChangeServiceConfig2( m_serviceHandle, SERVICE_CONFIG_FAILURE_ACTIONS, &serviceFailureActions );\n\tvInfo() << qUtf8Printable( tr( \"The service \\\"%1\\\" has been installed successfully.\" ).arg( m_name ) );\n\treturn true;\n}", "target": 1}
{"code": "krb5_gss_process_context_token(minor_status, context_handle,\n                               token_buffer)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    gss_buffer_t token_buffer;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    OM_uint32 majerr;\n     ctx = (krb5_gss_ctx_id_t) context_handle;\n    if (! ctx->established) {\n         *minor_status = KG_CTX_INCOMPLETE;\n         return(GSS_S_NO_CONTEXT);\n     }\n     if (GSS_ERROR(majerr = kg_unseal(minor_status, context_handle,\n                                     token_buffer,\n                                     GSS_C_NO_BUFFER, NULL, NULL,\n                                      KG_TOK_DEL_CTX)))\n         return(majerr);\n    return(krb5_gss_delete_sec_context(minor_status, &context_handle,\n                                       GSS_C_NO_BUFFER));\n }", "target": 1}
{"code": "static long aio_read_events_ring(struct kioctx *ctx,\n\t\t\t\t struct io_event __user *event, long nr)\n{\n\tstruct aio_ring *ring;\n\tunsigned head, tail, pos;\n\tlong ret = 0;\n\tint copy_ret;\n\tmutex_lock(&ctx->ring_lock);\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\thead = ring->head;\n\ttail = ring->tail;\n\tkunmap_atomic(ring);\n\tpr_debug(\"h%u t%u m%u\\n\", head, tail, ctx->nr_events);\n \tif (head == tail)\n \t\tgoto out;\n \twhile (ret < nr) {\n \t\tlong avail;\n \t\tstruct io_event *ev;\n\t\tstruct page *page;\n\t\tavail = (head <= tail ?  tail : ctx->nr_events) - head;\n\t\tif (head == tail)\n\t\t\tbreak;\n\t\tavail = min(avail, nr - ret);\n\t\tavail = min_t(long, avail, AIO_EVENTS_PER_PAGE -\n\t\t\t    ((head + AIO_EVENTS_OFFSET) % AIO_EVENTS_PER_PAGE));\n\t\tpos = head + AIO_EVENTS_OFFSET;\n\t\tpage = ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE];\n\t\tpos %= AIO_EVENTS_PER_PAGE;\n\t\tev = kmap(page);\n\t\tcopy_ret = copy_to_user(event + ret, ev + pos,\n\t\t\t\t\tsizeof(*ev) * avail);\n\t\tkunmap(page);\n\t\tif (unlikely(copy_ret)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tret += avail;\n\t\thead += avail;\n\t\thead %= ctx->nr_events;\n\t}\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\tring->head = head;\n\tkunmap_atomic(ring);\n\tflush_dcache_page(ctx->ring_pages[0]);\n\tpr_debug(\"%li  h%u t%u\\n\", ret, head, tail);\nout:\n\tmutex_unlock(&ctx->ring_lock);\n\treturn ret;\n}", "target": 1}
{"code": "Pl_Count::write(unsigned char* buf, size_t len)\n{\n    if (len)\n    {\n\tthis->m->count += QIntC::to_offset(len);\n\tgetNext()->write(buf, len);\n\tthis->m->last_char = buf[len - 1];\n    }\n}", "target": 1}
{"code": "_poppler_attachment_new (FileSpec *emb_file)\n{\n  PopplerAttachment *attachment;\n  PopplerAttachmentPrivate *priv;\n  EmbFile *embFile;\n  g_assert (emb_file != nullptr);\n  attachment = (PopplerAttachment *) g_object_new (POPPLER_TYPE_ATTACHMENT, nullptr);\n  priv = POPPLER_ATTACHMENT_GET_PRIVATE (attachment);\n  if (emb_file->getFileName ())\n    attachment->name = _poppler_goo_string_to_utf8 (emb_file->getFileName ());\n  if (emb_file->getDescription ())\n    attachment->description = _poppler_goo_string_to_utf8 (emb_file->getDescription ());\n  embFile = emb_file->getEmbeddedFile();\n  attachment->size = embFile->size ();\n  if (embFile->createDate ())\n    _poppler_convert_pdf_date_to_gtime (embFile->createDate (), (time_t *)&attachment->ctime);\n  if (embFile->modDate ())\n    _poppler_convert_pdf_date_to_gtime (embFile->modDate (), (time_t *)&attachment->mtime);\n  if (embFile->checksum () && embFile->checksum ()->getLength () > 0)\n    attachment->checksum = g_string_new_len (embFile->checksum ()->getCString (),\n                                             embFile->checksum ()->getLength ());\n  priv->obj_stream = embFile->streamObject()->copy();\n  return attachment;\n}", "target": 1}
{"code": "char* dexOptGenerateCacheFileName(const char* fileName, const char* subFileName)\n{\n char nameBuf[512];\n char absoluteFile[sizeof(nameBuf)];\n const size_t kBufLen = sizeof(nameBuf) - 1;\n const char* dataRoot;\n char* cp;\n    absoluteFile[0] = '\\0';\n if (fileName[0] != '/') {\n if (getcwd(absoluteFile, kBufLen) == NULL) {\n             ALOGE(\"Can't get CWD while opening jar file\");\n             return NULL;\n         }\n        strncat(absoluteFile, \"/\", kBufLen);\n     }\n    strncat(absoluteFile, fileName, kBufLen);\n     if (subFileName != NULL) {\n        strncat(absoluteFile, \"/\", kBufLen);\n        strncat(absoluteFile, subFileName, kBufLen);\n     }\n    cp = absoluteFile + 1;\n while (*cp != '\\0') {\n if (*cp == '/') {\n *cp = '@';\n }\n        cp++;\n }\n    dataRoot = getenv(\"ANDROID_DATA\");\n if (dataRoot == NULL)\n        dataRoot = \"/data\";\n    snprintf(nameBuf, kBufLen, \"%s/%s\", dataRoot, kCacheDirectoryName);\n if (strcmp(dataRoot, \"/data\") != 0) {\n int result = dexOptMkdir(nameBuf, 0700);\n if (result != 0 && errno != EEXIST) {\n            ALOGE(\"Failed to create dalvik-cache directory %s: %s\", nameBuf, strerror(errno));\n return NULL;\n }\n }\n    snprintf(nameBuf, kBufLen, \"%s/%s/%s\", dataRoot, kCacheDirectoryName, kInstructionSet);\n if (strcmp(dataRoot, \"/data\") != 0) {\n int result = dexOptMkdir(nameBuf, 0700);\n if (result != 0 && errno != EEXIST) {\n            ALOGE(\"Failed to create dalvik-cache directory %s: %s\", nameBuf, strerror(errno));\n return NULL;\n }\n }\n    strncat(nameBuf, absoluteFile, kBufLen);\n     ALOGV(\"Cache file for '%s' '%s' is '%s'\", fileName, subFileName, nameBuf);\n     return strdup(nameBuf);\n}", "target": 1}
{"code": "xmlStrncat(xmlChar *cur, const xmlChar *add, int len) {\n    int size;\n    xmlChar *ret;\n    if ((add == NULL) || (len == 0))\n        return(cur);\n    if (len < 0)\n\treturn(NULL);\n    if (cur == NULL)\n        return(xmlStrndup(add, len));\n    size = xmlStrlen(cur);\n    ret = (xmlChar *) xmlRealloc(cur, (size + len + 1) * sizeof(xmlChar));\n    if (ret == NULL) {\n        xmlErrMemory(NULL, NULL);\n        return(cur);\n    }\n    memcpy(&ret[size], add, len * sizeof(xmlChar));\n    ret[size + len] = 0;\n    return(ret);\n}", "target": 1}
{"code": "static int collect_syscall(struct task_struct *target, struct syscall_info *info)\n{\n\tstruct pt_regs *regs;\n\tif (!try_get_task_stack(target)) {\n\t\tmemset(info, 0, sizeof(*info));\n\t\tinfo->data.nr = -1;\n\t\treturn 0;\n\t}\n\tregs = task_pt_regs(target);\n\tif (unlikely(!regs)) {\n\t\tput_task_stack(target);\n\t\treturn -EAGAIN;\n\t}\n\tinfo->sp = user_stack_pointer(regs);\n\tinfo->data.instruction_pointer = instruction_pointer(regs);\n\tinfo->data.nr = syscall_get_nr(target, regs);\n\tif (info->data.nr != -1L)\n\t\tsyscall_get_arguments(target, regs,\n\t\t\t\t      (unsigned long *)&info->data.args[0]);\n\tput_task_stack(target);\n\treturn 0;\n}", "target": 1}
{"code": "setup_server_realm(krb5_principal sprinc)\n{\n    krb5_error_code     kret;\n     kdc_realm_t         *newrealm;\n     kret = 0;\n     if (kdc_numrealms > 1) {\n         if (!(newrealm = find_realm_data(sprinc->realm.data,\n                                          (krb5_ui_4) sprinc->realm.length)))\n            kret = ENOENT;\n        else\n            kdc_active_realm = newrealm;\n    }\n    else\n        kdc_active_realm = kdc_realmlist[0];\n    return(kret);\n}", "target": 1}
{"code": "init_ccline(int firstc, int indent)\n{\n    ccline.overstrike = FALSE;\t\t    \n    ccline.cmdfirstc = (firstc == '@' ? 0 : firstc);\n    ccline.cmdindent = (firstc > 0 ? indent : 0);\n    alloc_cmdbuff(exmode_active ? 250 : indent + 1);\n    if (ccline.cmdbuff == NULL)\n\treturn FAIL;\n    ccline.cmdlen = ccline.cmdpos = 0;\n    ccline.cmdbuff[0] = NUL;\n    sb_text_start_cmdline();\n    if (firstc <= 0)\n    {\n\tvim_memset(ccline.cmdbuff, ' ', indent);\n\tccline.cmdbuff[indent] = NUL;\n\tccline.cmdpos = indent;\n\tccline.cmdspos = indent;\n\tccline.cmdlen = indent;\n    }\n    return OK;\n}", "target": 1}
{"code": "static void xmlGROW (xmlParserCtxtPtr ctxt) {\n    unsigned long curEnd = ctxt->input->end - ctxt->input->cur;\n    unsigned long curBase = ctxt->input->cur - ctxt->input->base;\n    if (((curEnd > (unsigned long) XML_MAX_LOOKUP_LIMIT) ||\n         (curBase > (unsigned long) XML_MAX_LOOKUP_LIMIT)) &&\n         ((ctxt->input->buf) && (ctxt->input->buf->readcallback != (xmlInputReadCallback) xmlNop)) &&\n        ((ctxt->options & XML_PARSE_HUGE) == 0)) {\n        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, \"Huge input lookup\");\n        ctxt->instate = XML_PARSER_EOF;\n    }\n    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n    if ((ctxt->input->cur != NULL) && (*ctxt->input->cur == 0) &&\n        (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0))\n\t    xmlPopInput(ctxt);\n}", "target": 1}
{"code": "ecc_ecdsa_sign (const struct ecc_curve *ecc,\n\t\tconst mp_limb_t *zp,\n\t\tconst mp_limb_t *kp,\n\t\tsize_t length, const uint8_t *digest,\n\t\tmp_limb_t *rp, mp_limb_t *sp,\n\t\tmp_limb_t *scratch)\n{\n#define P\t    scratch\n#define kinv\t    scratch\n#define hp\t    (scratch  + ecc->p.size) \n#define tp\t    (scratch + 2*ecc->p.size)\n  ecc->mul_g (ecc, P, kp, P + 3*ecc->p.size);\n  ecc->h_to_a (ecc, 2, rp, P, P + 3*ecc->p.size);\n  ecc->q.invert (&ecc->q, kinv, kp, tp);\n  ecc_hash (&ecc->q, hp, length, digest);\n  ecc_mod_mul (&ecc->q, tp, zp, rp, tp);\n  ecc_mod_add (&ecc->q, hp, hp, tp);\n  ecc_mod_mul (&ecc->q, tp, hp, kinv, tp);\n  mpn_copyi (sp, tp, ecc->p.size);\n#undef P\n#undef hp\n#undef kinv\n#undef tp\n}", "target": 1}
{"code": "findNextBorderPixel(l_int32    w,\n                    l_int32    h,\n                    l_uint32  *data,\n                    l_int32    wpl,\n                    l_int32    px,\n                    l_int32    py,\n                    l_int32   *pqpos,\n                    l_int32   *pnpx,\n                    l_int32   *pnpy)\n{\nl_int32    qpos, i, pos, npx, npy, val;\nl_uint32  *line;\n    qpos = *pqpos;\n    for (i = 1; i < 8; i++) {\n        pos = (qpos + i) % 8;\n        npx = px + xpostab[pos];\n        npy = py + ypostab[pos];\n        line = data + npy * wpl;\n        val = GET_DATA_BIT(line, npx);\n        if (val) {\n            *pnpx = npx;\n            *pnpy = npy;\n            *pqpos = qpostab[pos];\n            return 0;\n        }\n    }\n    return 1;\n}", "target": 1}
{"code": "static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len,\n         bigint *modulus, bigint *pub_exp)\n {\n    int i, size;\n     bigint *decrypted_bi, *dat_bi;\n     bigint *bir = NULL;\n     uint8_t *block = (uint8_t *)malloc(sig_len);\n     dat_bi = bi_import(ctx, sig, sig_len);\n     ctx->mod_offset = BIGINT_M_OFFSET;\n    decrypted_bi = bi_mod_power2(ctx, dat_bi, modulus, pub_exp);\n     bi_export(ctx, decrypted_bi, block, sig_len);\n     ctx->mod_offset = BIGINT_M_OFFSET;\n    i = 10; \n    while (block[i++] && i < sig_len);\n    size = sig_len - i;\n    if (size > 0)\n    {\n        int len;\n        const uint8_t *sig_ptr = get_signature(&block[i], &len);\n        if (sig_ptr)\n        {\n            bir = bi_import(ctx, sig_ptr, len);\n        }\n     }\n     free(block);\n     bi_clear_cache(ctx);\n    return bir;\n}", "target": 1}
{"code": "static void patch_instruction(VAPICROMState *s, X86CPU *cpu, target_ulong ip)\n{\n    CPUState *cs = CPU(cpu);\n     CPUX86State *env = &cpu->env;\n     VAPICHandlers *handlers;\n     uint8_t opcode[2];\n    uint32_t imm32;\n     target_ulong current_pc = 0;\n     target_ulong current_cs_base = 0;\n     uint32_t current_flags = 0;\n    if (smp_cpus == 1) {\n        handlers = &s->rom_state.up;\n    } else {\n        handlers = &s->rom_state.mp;\n    }\n    if (!kvm_enabled()) {\n        cpu_get_tb_cpu_state(env, &current_pc, &current_cs_base,\n                             &current_flags);\n    }\n    pause_all_vcpus();\n    cpu_memory_rw_debug(cs, ip, opcode, sizeof(opcode), 0);\n    switch (opcode[0]) {\n    case 0x89: \n        patch_byte(cpu, ip, 0x50 + modrm_reg(opcode[1]));  \n        patch_call(s, cpu, ip + 1, handlers->set_tpr);\n        break;\n    case 0x8b: \n        patch_byte(cpu, ip, 0x90);\n        patch_call(s, cpu, ip + 1, handlers->get_tpr[modrm_reg(opcode[1])]);\n        break;\n    case 0xa1: \n        patch_call(s, cpu, ip, handlers->get_tpr[0]);\n        break;\n    case 0xa3: \n        patch_call(s, cpu, ip, handlers->set_tpr_eax);\n        break;\n    case 0xc7: \n        patch_byte(cpu, ip, 0x68);  \n        cpu_memory_rw_debug(cs, ip + 6, (void *)&imm32, sizeof(imm32), 0);\n        cpu_memory_rw_debug(cs, ip + 1, (void *)&imm32, sizeof(imm32), 1);\n        patch_call(s, cpu, ip + 5, handlers->set_tpr);\n        break;\n    case 0xff: \n        patch_byte(cpu, ip, 0x50); \n        patch_call(s, cpu, ip + 1, handlers->get_tpr_stack);\n        break;\n    default:\n        abort();\n    }\n    resume_all_vcpus();\n    if (!kvm_enabled()) {\n        tb_gen_code(cs, current_pc, current_cs_base, current_flags, 1);\n        cpu_resume_from_signal(cs, NULL);\n    }\n}", "target": 1}
{"code": "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\tkey = key_ref_to_ptr(key_ref);\n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error;\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\n can_read_key:\n\tret = key_validate(key);\n\tif (ret == 0) {\n\t\tret = -EOPNOTSUPP;\n\t\tif (key->type->read) {\n\t\t\tdown_read(&key->sem);\n \t\t\tret = key->type->read(key, buffer, buflen);\n\t\t\tup_read(&key->sem);\n\t\t}\n \t}\n error2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}", "target": 1}
{"code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteDivParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n  const TfLiteTensor* input1;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor1, &input1));\n  const TfLiteTensor* input2;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor2, &input2));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  if (output->type == kTfLiteFloat32 || output->type == kTfLiteInt32) {\n    EvalDiv<kernel_type>(context, node, params, data, input1, input2, output);\n  } else if (output->type == kTfLiteUInt8) {\n    TF_LITE_ENSURE_OK(\n        context, EvalQuantized<kernel_type>(context, node, params, data, input1,\n                                            input2, output));\n  } else {\n    context->ReportError(\n        context,\n        \"Div only supports FLOAT32, INT32 and quantized UINT8 now, got %d.\",\n        output->type);\n    return kTfLiteError;\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,\n\tstruct user_namespace *user_ns)\n{\n\tmm->mmap = NULL;\n\tmm->mm_rb = RB_ROOT;\n\tmm->vmacache_seqnum = 0;\n\tatomic_set(&mm->mm_users, 1);\n\tatomic_set(&mm->mm_count, 1);\n\tinit_rwsem(&mm->mmap_sem);\n\tINIT_LIST_HEAD(&mm->mmlist);\n\tmm->core_state = NULL;\n\tatomic_long_set(&mm->nr_ptes, 0);\n\tmm_nr_pmds_init(mm);\n\tmm->map_count = 0;\n\tmm->locked_vm = 0;\n\tmm->pinned_vm = 0;\n\tmemset(&mm->rss_stat, 0, sizeof(mm->rss_stat));\n\tspin_lock_init(&mm->page_table_lock);\n \tmm_init_cpumask(mm);\n \tmm_init_aio(mm);\n \tmm_init_owner(mm, p);\n \tmmu_notifier_mm_init(mm);\n \tinit_tlb_flush_pending(mm);\n #if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS\n\tmm->pmd_huge_pte = NULL;\n#endif\n\tif (current->mm) {\n\t\tmm->flags = current->mm->flags & MMF_INIT_MASK;\n\t\tmm->def_flags = current->mm->def_flags & VM_INIT_DEF_MASK;\n\t} else {\n\t\tmm->flags = default_dump_filter;\n\t\tmm->def_flags = 0;\n\t}\n\tif (mm_alloc_pgd(mm))\n\t\tgoto fail_nopgd;\n\tif (init_new_context(p, mm))\n\t\tgoto fail_nocontext;\n\tmm->user_ns = get_user_ns(user_ns);\n\treturn mm;\nfail_nocontext:\n\tmm_free_pgd(mm);\nfail_nopgd:\n\tfree_mm(mm);\n\treturn NULL;\n}", "target": 1}
{"code": "bsg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct bsg_device *bd = file->private_data;\n\tssize_t bytes_written;\n\tint ret;\n \tdprintk(\"%s: write %Zd bytes\\n\", bd->name, count);\n \tbsg_set_block(bd, file);\n \tbytes_written = 0;\n\tret = __bsg_write(bd, buf, count, &bytes_written,\n\t\t\t  file->f_mode & FMODE_WRITE);\n\t*ppos = bytes_written;\n\tif (!bytes_written || err_block_err(ret))\n\t\tbytes_written = ret;\n\tdprintk(\"%s: returning %Zd\\n\", bd->name, bytes_written);\n\treturn bytes_written;\n}", "target": 1}
{"code": "new_msg_register_event (u_int32_t seqnum, struct lsa_filter_type *filter)\n{\n  u_char buf[OSPF_API_MAX_MSG_SIZE];\n  struct msg_register_event *emsg;\n  int len;\n  emsg = (struct msg_register_event *) buf;\n  len = sizeof (struct msg_register_event) +\n    filter->num_areas * sizeof (struct in_addr);\n   emsg->filter.typemask = htons (filter->typemask);\n   emsg->filter.origin = filter->origin;\n   emsg->filter.num_areas = filter->num_areas;\n   return msg_new (MSG_REGISTER_EVENT, emsg, seqnum, len);\n }", "target": 1}
{"code": "void luaD_shrinkstack (lua_State *L) {\n  int inuse = stackinuse(L);\n  int goodsize = inuse + (inuse / 8) + 2*EXTRA_STACK;\n  if (goodsize > LUAI_MAXSTACK)\n    goodsize = LUAI_MAXSTACK;  \n  if (inuse <= (LUAI_MAXSTACK - EXTRA_STACK) &&\n      goodsize < L->stacksize)\n    luaD_reallocstack(L, goodsize, 0);  \n  else  \n    condmovestack(L,{},{});  \n  luaE_shrinkCI(L);  \n}", "target": 1}
{"code": "static int nfs_readlink_reply(unsigned char *pkt, unsigned len)\n {\n \tuint32_t *data;\n \tchar *path;\n\tint rlen;\n \tint ret;\n \tret = rpc_check_reply(pkt, 1);\n\tif (ret)\n\t\treturn ret;\n\tdata = (uint32_t *)(pkt + sizeof(struct rpc_reply));\n\tdata++;\n \trlen = ntohl(net_read_uint32(data)); \n \tdata++;\n \tpath = (char *)data;\n\t} else {\n\t\tmemcpy(nfs_path, path, rlen);\n\t\tnfs_path[rlen] = 0;\n\t}", "target": 1}
{"code": "void SparseFillEmptyRowsOpImpl(OpKernelContext* context,\n                               AsyncOpKernel::DoneCallback done = nullptr) {\n  if (!done) {\n    done = [] {};\n  }\n  const int kIndicesInput = 0;\n  const int kValuesInput = 1;\n  const int kDenseShapeInput = 2;\n  const int kDefaultValueInput = 3;\n  const Tensor& indices_t = context->input(kIndicesInput);\n  const Tensor& values_t = context->input(kValuesInput);\n  const Tensor& dense_shape_t = context->input(kDenseShapeInput);\n  const Tensor& default_value_t = context->input(kDefaultValueInput);\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsVector(dense_shape_t.shape()),\n      errors::InvalidArgument(\"dense_shape must be a vector, saw: \",\n                              dense_shape_t.shape().DebugString()),\n      done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsMatrix(indices_t.shape()),\n                    errors::InvalidArgument(\"indices must be a matrix, saw: \",\n                                            indices_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsVector(values_t.shape()),\n                    errors::InvalidArgument(\"values must be a vector, saw: \",\n                                            values_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsScalar(default_value_t.shape()),\n      errors::InvalidArgument(\"default_value must be a scalar, saw: \",\n                              default_value_t.shape().DebugString()),\n      done);\n  OP_REQUIRES_ASYNC(context, dense_shape_t.NumElements() != 0,\n                    errors::InvalidArgument(\"Dense shape cannot be empty.\"),\n                    done);\n  using FunctorType = functor::SparseFillEmptyRows<Device, T, Tindex>;\n  OP_REQUIRES_OK_ASYNC(context,\n                       FunctorType()(context, default_value_t, indices_t,\n                                     values_t, dense_shape_t, done),\n                       done);\n}", "target": 1}
{"code": "zsetcolor(i_ctx_t * i_ctx_p)\n{\n    os_ptr                  op = osp;\n    es_ptr ep;\n    const gs_color_space *  pcs = gs_currentcolorspace(igs);\n    gs_client_color         cc;\n    int                     n_comps, n_numeric_comps, num_offset = 0, code, depth;\n    PS_colour_space_t *space;\n    cc.pattern = 0;\n    if ((n_comps = cs_num_components(pcs)) < 0) {\n        n_comps = -n_comps;\n         if (r_has_type(op, t_dictionary)) {\n             ref     *pImpl, pPatInst;\n            code = dict_find_string(op, \"Implementation\", &pImpl);\n            if (code != 0) {\n                 code = array_get(imemory, pImpl, 0, &pPatInst);\n                 if (code < 0)\n                     return code;\n                n_numeric_comps = ( pattern_instance_uses_base_space(cc.pattern)\n                      ? n_comps - 1\n                      : 0 );\n            } else\n                n_numeric_comps = 0;\n        } else\n            n_numeric_comps = 0;\n        num_offset = 1;\n    } else\n        n_numeric_comps = n_comps;\n    code = float_params(op - num_offset, n_numeric_comps, cc.paint.values);\n    if (code < 0)\n        return code;\n    memset(cc.paint.values + n_numeric_comps, 0,\n            sizeof(cc.paint.values) - sizeof(*cc.paint.values)*n_numeric_comps);\n    code = get_space_object(i_ctx_p, &istate->colorspace[0].array, &space);\n    if (code < 0)\n        return code;\n    if (space->validatecomponents) {\n        code = space->validatecomponents(i_ctx_p,\n                                         &istate->colorspace[0].array,\n                                         cc.paint.values, n_numeric_comps);\n        if (code < 0)\n            return code;\n    }\n    if ((code = gs_setcolor(igs, &cc)) >= 0) {\n        if (n_comps > n_numeric_comps) {\n            istate->pattern[0] = *op;      \n        }\n    }\n    code = validate_spaces(i_ctx_p, &istate->colorspace[0].array, &depth);\n    if (code < 0)\n        return code;\n    check_estack(5);\n    ep = esp += 1;\n    make_int(ep, 0);\n    ep = esp += 1;\n    make_int(ep, 0);\n    ep = esp += 1;\n    make_int(ep, 0);\n    ep = esp += 1;\n    *ep = istate->colorspace[0].array;\n    push_op_estack(setcolor_cont);\n    return o_push_estack;\n}", "target": 1}
{"code": "std::string get_wml_location(const std::string &filename, const std::string &current_dir)\n{\n\tDBG_FS << \"Looking for '\" << filename << \"'.\" << std::endl;\n\tassert(game_config::path.empty() == false);\n\tstd::string result;\n\tif (filename.empty()) {\n\t\tLOG_FS << \"  invalid filename\" << std::endl;\n\t\treturn result;\n\t}\n\tif (filename.find(\"..\") != std::string::npos) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (\\\"..\\\" not allowed).\" << std::endl;\n\t\treturn result;\n\t}\n\tif (ends_with(filename, \".pbl\")) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (.pbl files are not allowed).\" << std::endl;\n\t\treturn result;\n\t}\n\tbool already_found = false;\n\tif (filename[0] == '~')\n\t{\n\t\tresult = get_user_data_dir() + \"/data/\" + filename.substr(1);\n\t\tDBG_FS << \"  trying '\" << result << \"'\" << std::endl;\n\t\talready_found = file_exists(result) || is_directory(result);\n\t}\n\telse if (filename.size() >= 2 && filename[0] == '.' && filename[1] == '/')\n\t{\n\t\tif (!current_dir.empty())\n\t\t{\n\t\t\tresult = current_dir;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = game_config::path;\n\t\t}\n\t\tresult += filename.substr(2);\n\t}\n\telse if (!game_config::path.empty())\n\t\tresult = game_config::path + \"/data/\" + filename;\n\tDBG_FS << \"  trying '\" << result << \"'\" << std::endl;\n\tif (result.empty() ||\n\t    (!already_found && !file_exists(result) && !is_directory(result)))\n\t{\n\t\tDBG_FS << \"  not found\" << std::endl;\n\t\tresult.clear();\n\t}\n\telse\n\t\tDBG_FS << \"  found: '\" << result << \"'\" << std::endl;\n\treturn result;\n}", "target": 1}
{"code": "static int do_video_set_spu_palette(unsigned int fd, unsigned int cmd,\n\t\tstruct compat_video_spu_palette __user *up)\n{\n\tstruct video_spu_palette __user *up_native;\n\tcompat_uptr_t palp;\n\tint length, err;\n \terr  = get_user(palp, &up->palette);\n \terr |= get_user(length, &up->length);\n \tup_native = compat_alloc_user_space(sizeof(struct video_spu_palette));\n \terr  = put_user(compat_ptr(palp), &up_native->palette);\n\terr |= put_user(length, &up_native->length);\n\tif (err)\n\t\treturn -EFAULT;\n\terr = sys_ioctl(fd, cmd, (unsigned long) up_native);\n\treturn err;\n}", "target": 1}
{"code": "new_msg_lsa_change_notify (u_char msgtype,\n\t\t\t   u_int32_t seqnum,\n\t\t\t   struct in_addr ifaddr,\n\t\t\t   struct in_addr area_id,\n\t\t\t   u_char is_self_originated, struct lsa_header *data)\n{\n  u_char buf[OSPF_API_MAX_MSG_SIZE];\n  struct msg_lsa_change_notify *nmsg;\n  int len;\n  assert (data);\n  nmsg = (struct msg_lsa_change_notify *) buf;\n  len = ntohs (data->length) + sizeof (struct msg_lsa_change_notify)\n    - sizeof (struct lsa_header);\n  nmsg->ifaddr = ifaddr;\n  nmsg->area_id = area_id;\n  nmsg->is_self_originated = is_self_originated;\n  memset (&nmsg->pad, 0, sizeof (nmsg->pad));\n  memcpy (&nmsg->data, data, ntohs (data->length));\n  return msg_new (msgtype, nmsg, seqnum, len);\n}", "target": 1}
{"code": "static int zpff_init(struct hid_device *hid)\n{\n\tstruct zpff_device *zpff;\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next,\n\t\t\t\t\t\tstruct hid_input, list);\n\tstruct input_dev *dev = hidinput->input;\n\tint i, error;\n\tfor (i = 0; i < 4; i++) {\n\t\treport = hid_validate_values(hid, HID_OUTPUT_REPORT, 0, i, 1);\n\t\tif (!report)\n\t\t\treturn -ENODEV;\n\t}\n\tzpff = kzalloc(sizeof(struct zpff_device), GFP_KERNEL);\n\tif (!zpff)\n\t\treturn -ENOMEM;\n\tset_bit(FF_RUMBLE, dev->ffbit);\n\terror = input_ff_create_memless(dev, zpff, zpff_play);\n\tif (error) {\n\t\tkfree(zpff);\n\t\treturn error;\n\t}\n\tzpff->report = report;\n\tzpff->report->field[0]->value[0] = 0x00;\n\tzpff->report->field[1]->value[0] = 0x02;\n\tzpff->report->field[2]->value[0] = 0x00;\n\tzpff->report->field[3]->value[0] = 0x00;\n\thid_hw_request(hid, zpff->report, HID_REQ_SET_REPORT);\n\thid_info(hid, \"force feedback for Zeroplus based devices by Anssi Hannula <anssi.hannula@gmail.com>\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "int create_user_ns(struct cred *new)\n{\n\tstruct user_namespace *ns, *parent_ns = new->user_ns;\n\tkuid_t owner = new->euid;\n \tkgid_t group = new->egid;\n \tint ret;\n\tif (!kuid_has_mapping(parent_ns, owner) ||\n\t    !kgid_has_mapping(parent_ns, group))\n\t\treturn -EPERM;\n\tns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);\n\tif (!ns)\n\t\treturn -ENOMEM;\n\tret = proc_alloc_inum(&ns->proc_inum);\n\tif (ret) {\n\t\tkmem_cache_free(user_ns_cachep, ns);\n\t\treturn ret;\n\t}\n\tatomic_set(&ns->count, 1);\n\tns->parent = parent_ns;\n\tns->owner = owner;\n\tns->group = group;\n\tset_cred_user_ns(new, ns);\n\treturn 0;\n}", "target": 1}
{"code": "static int test_x509_time(int idx)\n{\n    ASN1_TIME *t = NULL;\n    int result, rv = 0;\n    if (x509_format_tests[idx].set_string) {\n        t = ASN1_TIME_new();\n        if (t == NULL) {\n            TEST_info(\"test_x509_time(%d) failed: internal error\\n\", idx);\n            return 0;\n        }\n    }\n    result = ASN1_TIME_set_string_X509(t, x509_format_tests[idx].data);\n    if (!TEST_int_eq(result, x509_format_tests[idx].expected)) {\n        TEST_info(\"test_x509_time(%d) failed: expected %d, got %d\\n\",\n                idx, x509_format_tests[idx].expected, result);\n        goto out;\n    }\n    if (t != NULL && x509_format_tests[idx].expected_type != -1) {\n        if (!TEST_int_eq(t->type, x509_format_tests[idx].expected_type)) {\n            TEST_info(\"test_x509_time(%d) failed: expected_type %d, got %d\\n\",\n                    idx, x509_format_tests[idx].expected_type, t->type);\n            goto out;\n        }\n    }\n    if (t != NULL && x509_format_tests[idx].expected_string) {\n        if (!TEST_str_eq((const char *)t->data,\n                    x509_format_tests[idx].expected_string)) {\n            TEST_info(\"test_x509_time(%d) failed: expected_string %s, got %s\\n\",\n                    idx, x509_format_tests[idx].expected_string, t->data);\n            goto out;\n        }\n    }\n    rv = 1;\nout:\n    if (t != NULL)\n        ASN1_TIME_free(t);\n    return rv;\n}", "target": 1}
{"code": "static int decode_font(ASS_Track *track)\n{\n    unsigned char *p;\n    unsigned char *q;\n    size_t i;\n    size_t size;                   \n    size_t dsize;                  \n    unsigned char *buf = 0;\n    ass_msg(track->library, MSGL_V, \"Font: %d bytes encoded data\",\n            track->parser_priv->fontdata_used);\n    size = track->parser_priv->fontdata_used;\n    if (size % 4 == 1) {\n        ass_msg(track->library, MSGL_ERR, \"Bad encoded data size\");\n        goto error_decode_font;\n    }\n    buf = malloc(size / 4 * 3 + FFMAX(size % 4 - 1, 0));\n    if (!buf)\n        goto error_decode_font;\n    q = buf;\n    for (i = 0, p = (unsigned char *) track->parser_priv->fontdata;\n         i < size / 4; i++, p += 4) {\n        q = decode_chars(p, q, 4);\n    }\n    if (size % 4 == 2) {\n        q = decode_chars(p, q, 2);\n    } else if (size % 4 == 3) {\n        q = decode_chars(p, q, 3);\n    }\n    dsize = q - buf;\n    assert(dsize == size / 4 * 3 + FFMAX(size % 4 - 1, 0));\n    if (track->library->extract_fonts) {\n        ass_add_font(track->library, track->parser_priv->fontname,\n                     (char *) buf, dsize);\n    }\nerror_decode_font:\n    free(buf);\n    reset_embedded_font_parsing(track->parser_priv);\n    return 0;\n}", "target": 1}
{"code": "irc_ctcp_dcc_filename_without_quotes (const char *filename)\n{\n     int length;\n     length = strlen (filename);\n    if (length > 0)\n     {\n         if ((filename[0] == '\\\"') && (filename[length - 1] == '\\\"'))\n             return weechat_strndup (filename + 1, length - 2);\n    }\n    return strdup (filename);\n}", "target": 1}
{"code": " virtual ssize_t readAt(off64_t offset, void *buffer, size_t size) {\n Parcel data, reply;\n        data.writeInterfaceToken(\n IMediaHTTPConnection::getInterfaceDescriptor());\n        data.writeInt64(offset);\n        data.writeInt32(size);\n status_t err = remote()->transact(READ_AT, data, &reply);\n if (err != OK) {\n            ALOGE(\"remote readAt failed\");\n return UNKNOWN_ERROR;\n }\n int32_t exceptionCode = reply.readExceptionCode();\n if (exceptionCode) {\n             return UNKNOWN_ERROR;\n         }\n        int32_t len = reply.readInt32();\n        if (len > 0) {\n            memcpy(buffer, mMemory->pointer(), len);\n         }\n         return len;\n     }", "target": 1}
{"code": "static int db_dict_iter_lookup_key_values(struct db_dict_value_iter *iter)\n{\n\tstruct db_dict_iter_key *key;\n\tstring_t *path;\n\tconst char *error;\n\tint ret;\n\tarray_sort(&iter->keys, db_dict_iter_key_cmp);\n\tpath = t_str_new(128);\n\tstr_append(path, DICT_PATH_SHARED);\n\tarray_foreach_modifiable(&iter->keys, key) {\n\t\tif (!key->used)\n\t\t\tcontinue;\n\t\tstr_truncate(path, strlen(DICT_PATH_SHARED));\n\t\tret = var_expand(path, key->key->key, iter->var_expand_table, &error);\n\t\tif (ret <= 0) {\n\t\t\tauth_request_log_error(iter->auth_request, AUTH_SUBSYS_DB,\n\t\t\t\t\"Failed to expand key %s: %s\", key->key->key, error);\n\t\t\treturn -1;\n\t\t}\n\t\tret = dict_lookup(iter->conn->dict, iter->pool,\n\t\t\t\t  str_c(path), &key->value, &error);\n\t\tif (ret > 0) {\n\t\t\tauth_request_log_debug(iter->auth_request, AUTH_SUBSYS_DB,\n\t\t\t\t\t       \"Lookup: %s = %s\", str_c(path),\n\t\t\t\t\t       key->value);\n\t\t} else if (ret < 0) {\n\t\t\tauth_request_log_error(iter->auth_request, AUTH_SUBSYS_DB,\n\t\t\t\t\"Failed to lookup key %s: %s\", str_c(path), error);\n\t\t\treturn -1;\n\t\t} else if (key->key->default_value != NULL) {\n\t\t\tauth_request_log_debug(iter->auth_request, AUTH_SUBSYS_DB,\n\t\t\t\t\"Lookup: %s not found, using default value %s\",\n\t\t\t\tstr_c(path), key->key->default_value);\n\t\t\tkey->value = key->key->default_value;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "static bool net_tx_pkt_do_sw_fragmentation(struct NetTxPkt *pkt,\n    NetClientState *nc)\n{\n    struct iovec fragment[NET_MAX_FRAG_SG_LIST];\n    size_t fragment_len = 0;\n    bool more_frags = false;\n    void *l2_iov_base, *l3_iov_base;\n    size_t l2_iov_len, l3_iov_len;\n    int src_idx =  NET_TX_PKT_PL_START_FRAG, dst_idx;\n    size_t src_offset = 0;\n    size_t fragment_offset = 0;\n    l2_iov_base = pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base;\n    l2_iov_len = pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len;\n    l3_iov_base = pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base;\n    l3_iov_len = pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len;\n    fragment[NET_TX_PKT_FRAGMENT_L2_HDR_POS].iov_base = l2_iov_base;\n    fragment[NET_TX_PKT_FRAGMENT_L2_HDR_POS].iov_len = l2_iov_len;\n    fragment[NET_TX_PKT_FRAGMENT_L3_HDR_POS].iov_base = l3_iov_base;\n    fragment[NET_TX_PKT_FRAGMENT_L3_HDR_POS].iov_len = l3_iov_len;\n    do {\n        fragment_len = net_tx_pkt_fetch_fragment(pkt, &src_idx, &src_offset,\n            fragment, &dst_idx);\n        more_frags = (fragment_offset + fragment_len < pkt->payload_len);\n        eth_setup_ip4_fragmentation(l2_iov_base, l2_iov_len, l3_iov_base,\n            l3_iov_len, fragment_len, fragment_offset, more_frags);\n        eth_fix_ip4_checksum(l3_iov_base, l3_iov_len);\n        net_tx_pkt_sendv(pkt, nc, fragment, dst_idx);\n         fragment_offset += fragment_len;\n    } while (more_frags);\n     return true;\n }", "target": 1}
{"code": "static inline void native_set_ldt(const void *addr, unsigned int entries)\n{\n\tif (likely(entries == 0))\n\t\tasm volatile(\"lldt %w0\"::\"q\" (0));\n\telse {\n\t\tunsigned cpu = smp_processor_id();\n\t\tldt_desc ldt;\n\t\tset_tssldt_descriptor(&ldt, (unsigned long)addr,\n\t\t\t\t      DESC_LDT, entries * sizeof(ldt) - 1);\n\t\twrite_gdt_entry(get_cpu_gdt_table(cpu), GDT_ENTRY_LDT,\n\t\t\t\t&ldt, DESC_LDT);\n\t\tasm volatile(\"lldt %w0\"::\"q\" (GDT_ENTRY_LDT*8));\n\t}\n}", "target": 1}
{"code": "void NuPlayer::GenericSource::notifyPreparedAndCleanup(status_t err) {\n if (err != OK) {\n        mMetaDataSize = -1ll;\n        mContentType = \"\";\n        mSniffedMIME = \"\";\n {\n            sp<DataSource> dataSource = mDataSource;\n            sp<NuCachedSource2> cachedSource = mCachedSource;\n            sp<DataSource> httpSource = mHttpSource;\n             {\n                 Mutex::Autolock _l(mDisconnectLock);\n                 mDataSource.clear();\n                 mCachedSource.clear();\n                 mHttpSource.clear();\n             }\n }\n        cancelPollBuffering();\n }\n    notifyPrepared(err);\n}", "target": 1}
{"code": "int Jsi_ObjArraySizer(Jsi_Interp *interp, Jsi_Obj *obj, uint len)\n{\n    int nsiz = len + 1, mod = ALLOC_MOD_SIZE;\n    assert(obj->isarrlist);\n    if (mod>1)\n        nsiz = nsiz + ((mod-1) - (nsiz + mod - 1)%mod);\n    if (nsiz > MAX_ARRAY_LIST) {\n        Jsi_LogError(\"array size too large\");\n        return 0;\n    }\n    if (len >= obj->arrMaxSize) {\n        int oldsz = (nsiz-obj->arrMaxSize);\n        obj->arr = (Jsi_Value**)Jsi_Realloc(obj->arr, nsiz*sizeof(Jsi_Value*));\n        memset(obj->arr+obj->arrMaxSize, 0, oldsz*sizeof(Jsi_Value*));\n        obj->arrMaxSize = nsiz;\n    }\n    if (len>obj->arrCnt)\n        obj->arrCnt = len;\n    return nsiz;\n}", "target": 1}
{"code": "String preg_quote(const String& str,\n                  const String& delimiter ) {\n  const char* in_str = str.data();\n  const char* in_str_end = in_str + str.size();\n  if (in_str == in_str_end) {\n    return str;\n  }\n  char delim_char = 0;      \n  bool quote_delim = false; \n  if (!delimiter.empty()) {\n    delim_char = delimiter.charAt(0);\n    quote_delim = true;\n  }\n  String ret(4 * str.size() + 1, ReserveString);\n  char* out_str = ret.mutableData();\n  const char* p;\n  char* q;\n  for (p = in_str, q = out_str; p != in_str_end; p++) {\n    char c = *p;\n    switch (c) {\n    case '.': case '\\\\': case '+': case '*': case '?':\n    case '[': case '^':  case ']': case '$': case '(':\n    case ')': case '{':  case '}': case '=': case '!':\n    case '>': case '<':  case '|': case ':': case '-':\n    case '#':\n      *q++ = '\\\\';\n      *q++ = c;\n      break;\n    case '\\0':\n      *q++ = '\\\\';\n      *q++ = '0';\n      *q++ = '0';\n      *q++ = '0';\n      break;\n    default:\n      if (quote_delim && c == delim_char)\n        *q++ = '\\\\';\n      *q++ = c;\n      break;\n    }\n  }\n  *q = '\\0';\n  return ret.setSize(q - out_str);\n}", "target": 1}
{"code": "ssh_scp ssh_scp_new(ssh_session session, int mode, const char *location){\n  ssh_scp scp=malloc(sizeof(struct ssh_scp_struct));\n  if(scp == NULL){\n    ssh_set_error(session,SSH_FATAL,\"Error allocating memory for ssh_scp\");\n    return NULL;\n  }\n  ZERO_STRUCTP(scp);\n  if((mode&~SSH_SCP_RECURSIVE) != SSH_SCP_WRITE && (mode &~SSH_SCP_RECURSIVE) != SSH_SCP_READ){\n    ssh_set_error(session,SSH_FATAL,\"Invalid mode %d for ssh_scp_new()\",mode);\n    ssh_scp_free(scp);\n    return NULL;\n  }\n  scp->location=strdup(location);\n  if (scp->location == NULL) {\n    ssh_set_error(session,SSH_FATAL,\"Error allocating memory for ssh_scp\");\n    ssh_scp_free(scp);\n    return NULL;\n  }\n  scp->session=session;\n  scp->mode=mode & ~SSH_SCP_RECURSIVE;\n  scp->recursive = (mode & SSH_SCP_RECURSIVE) != 0;\n  scp->channel=NULL;\n  scp->state=SSH_SCP_NEW;\n  return scp;\n}", "target": 1}
{"code": "snmp_ber_decode_string_len_buffer(unsigned char *buf, uint32_t *buff_len, const char **str, uint32_t *length)\n{\n  uint8_t type, i, length_bytes;\n  buf = snmp_ber_decode_type(buf, buff_len, &type);\n  if(buf == NULL || type != BER_DATA_TYPE_OCTET_STRING) {\n    return NULL;\n  }\n  if((*buf & 0x80) == 0) {\n    *length = (uint32_t)*buf++;\n    (*buff_len)--;\n  } else {\n    length_bytes = (uint8_t)(*buf++ & 0x7F);\n    (*buff_len)--;\n    if(length_bytes > 4) {\n      return NULL;\n    }\n    *length = (uint32_t)*buf++;\n    (*buff_len)--;\n    for(i = 1; i < length_bytes; ++i) {\n      *length <<= 8;\n      *length |= *buf++;\n      (*buff_len)--;\n    }\n  }\n  *str = (const char *)buf;\n  *buff_len -= *length;\n  return buf + *length;\n}", "target": 1}
{"code": "bool SQClass::NewSlot(SQSharedState *ss,const SQObjectPtr &key,const SQObjectPtr &val,bool bstatic)\n{\n    SQObjectPtr temp;\n    bool belongs_to_static_table = sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE || bstatic;\n    if(_locked && !belongs_to_static_table)\n        return false; \n    if(_members->Get(key,temp) && _isfield(temp)) \n    {\n        _defaultvalues[_member_idx(temp)].val = val;\n        return true;\n    }\n    if(belongs_to_static_table) {\n        SQInteger mmidx;\n        if((sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE) &&\n            (mmidx = ss->GetMetaMethodIdxByName(key)) != -1) {\n            _metamethods[mmidx] = val;\n        }\n        else {\n            SQObjectPtr theval = val;\n            if(_base && sq_type(val) == OT_CLOSURE) {\n                theval = _closure(val)->Clone();\n                _closure(theval)->_base = _base;\n                __ObjAddRef(_base); \n            }\n            if(sq_type(temp) == OT_NULL) {\n                bool isconstructor;\n                SQVM::IsEqual(ss->_constructoridx, key, isconstructor);\n                if(isconstructor) {\n                    _constructoridx = (SQInteger)_methods.size();\n                }\n                SQClassMember m;\n                m.val = theval;\n                _members->NewSlot(key,SQObjectPtr(_make_method_idx(_methods.size())));\n                _methods.push_back(m);\n            }\n            else {\n                _methods[_member_idx(temp)].val = theval;\n            }\n        }\n        return true;\n    }\n    SQClassMember m;\n    m.val = val;\n    _members->NewSlot(key,SQObjectPtr(_make_field_idx(_defaultvalues.size())));\n    _defaultvalues.push_back(m);\n    return true;\n}", "target": 1}
{"code": "static int HistogramCompare(const void *x,const void *y)\n{\n  const PixelInfo\n    *color_1,\n    *color_2;\n  color_1=(const PixelInfo *) x;\n  color_2=(const PixelInfo *) y;\n  if (color_2->red != color_1->red)\n    return((int) color_1->red-(int) color_2->red);\n  if (color_2->green != color_1->green)\n    return((int) color_1->green-(int) color_2->green);\n  if (color_2->blue != color_1->blue)\n    return((int) color_1->blue-(int) color_2->blue);\n  return((int) color_2->count-(int) color_1->count);\n}", "target": 1}
{"code": "convert(\n    Imaging imOut, Imaging imIn, const char *mode, ImagingPalette palette, int dither) {\n    ImagingSectionCookie cookie;\n    ImagingShuffler convert;\n    int y;\n    if (!imIn) {\n        return (Imaging)ImagingError_ModeError();\n    }\n    if (!mode) {\n        if (!imIn->palette) {\n            return (Imaging)ImagingError_ModeError();\n        }\n        mode = imIn->palette->mode;\n    } else {\n        if (!strcmp(imIn->mode, mode)) {\n            return ImagingCopy2(imOut, imIn);\n        }\n    }\n    if (strcmp(imIn->mode, \"P\") == 0 || strcmp(imIn->mode, \"PA\") == 0) {\n        return frompalette(imOut, imIn, mode);\n    }\n    if (strcmp(mode, \"P\") == 0 || strcmp(mode, \"PA\") == 0) {\n        return topalette(imOut, imIn, mode, palette, dither);\n    }\n    if (dither && strcmp(mode, \"1\") == 0) {\n        return tobilevel(imOut, imIn, dither);\n    }\n    convert = NULL;\n    for (y = 0; converters[y].from; y++) {\n        if (!strcmp(imIn->mode, converters[y].from) &&\n            !strcmp(mode, converters[y].to)) {\n            convert = converters[y].convert;\n            break;\n        }\n    }\n    if (!convert) {\n#ifdef notdef\n        return (Imaging)ImagingError_ValueError(\"conversion not supported\");\n#else\n        static char buf[256];\n        sprintf(buf, \"conversion from %s to %s not supported\", imIn->mode, mode);\n        return (Imaging)ImagingError_ValueError(buf);\n#endif\n    }\n    imOut = ImagingNew2Dirty(mode, imOut, imIn);\n    if (!imOut) {\n        return NULL;\n    }\n    ImagingSectionEnter(&cookie);\n    for (y = 0; y < imIn->ysize; y++) {\n        (*convert)((UINT8 *)imOut->image[y], (UINT8 *)imIn->image[y], imIn->xsize);\n    }\n    ImagingSectionLeave(&cookie);\n    return imOut;\n}", "target": 1}
{"code": "int dtls1_process_buffered_records(SSL *s)\n {\n     pitem *item;\n     SSL3_BUFFER *rb;\n     item = pqueue_peek(s->rlayer.d->unprocessed_rcds.q);\n     if (item) {\n         if (s->rlayer.d->unprocessed_rcds.epoch != s->rlayer.d->r_epoch)\n            return (1);         \n         rb = RECORD_LAYER_get_rbuf(&s->rlayer);\n             */\n            return 1;\n        }\n        while (pqueue_peek(s->rlayer.d->unprocessed_rcds.q)) {\n            dtls1_get_unprocessed_record(s);\n            if (!dtls1_process_record(s))\n                return (0);\n            if (dtls1_buffer_record(s, &(s->rlayer.d->processed_rcds),\n         while (pqueue_peek(s->rlayer.d->unprocessed_rcds.q)) {\n             dtls1_get_unprocessed_record(s);\n            if (!dtls1_process_record(s))\n                return (0);\n             if (dtls1_buffer_record(s, &(s->rlayer.d->processed_rcds),\n                                    SSL3_RECORD_get_seq_num(s->rlayer.rrec)) <\n                0)\n                return -1;\n         }\n     }\n *             here, anything else is handled by higher layers\n *     Application data protocol\n *             none of our business\n */\n     s->rlayer.d->processed_rcds.epoch = s->rlayer.d->r_epoch;\n     s->rlayer.d->unprocessed_rcds.epoch = s->rlayer.d->r_epoch + 1;\n    return (1);\n }", "target": 1}
{"code": "fgetwln(FILE *stream, size_t *lenp)\n{\n\tstruct filewbuf *fb;\n\twint_t wc;\n\tsize_t wused = 0;\n\tfb = &fb_pool[fb_pool_cur];\n\tif (fb->fp != stream && fb->fp != NULL) {\n\t\tfb_pool_cur++;\n\t\tfb_pool_cur %= FILEWBUF_POOL_ITEMS;\n\t\tfb = &fb_pool[fb_pool_cur];\n\t}\n \tfb->fp = stream;\n \twhile ((wc = fgetwc(stream)) != WEOF) {\n\t\tif (!fb->len || wused > fb->len) {\n \t\t\twchar_t *wp;\n \t\t\tif (fb->len)\n\t\t\t\tfb->len *= 2;\n\t\t\telse\n\t\t\t\tfb->len = FILEWBUF_INIT_LEN;\n\t\t\twp = reallocarray(fb->wbuf, fb->len, sizeof(wchar_t));\n\t\t\tif (wp == NULL) {\n\t\t\t\twused = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfb->wbuf = wp;\n\t\t}\n\t\tfb->wbuf[wused++] = wc;\n\t\tif (wc == L'\\n')\n\t\t\tbreak;\n\t}\n\t*lenp = wused;\n\treturn wused ? fb->wbuf : NULL;\n}", "target": 1}
{"code": "kvm_irqfd(struct kvm *kvm, struct kvm_irqfd *args)\n {\n \tif (args->flags & ~(KVM_IRQFD_FLAG_DEASSIGN | KVM_IRQFD_FLAG_RESAMPLE))\n \t\treturn -EINVAL;\n \tif (args->flags & KVM_IRQFD_FLAG_DEASSIGN)\n \t\treturn kvm_irqfd_deassign(kvm, args);\n\treturn kvm_irqfd_assign(kvm, args);\n}", "target": 1}
{"code": "static int handle_to_path(int mountdirfd, struct file_handle __user *ufh,\n\t\t   struct path *path)\n{\n\tint retval = 0;\n\tstruct file_handle f_handle;\n\tstruct file_handle *handle = NULL;\n\tif (!capable(CAP_DAC_READ_SEARCH)) {\n\t\tretval = -EPERM;\n\t\tgoto out_err;\n\t}\n\tif (copy_from_user(&f_handle, ufh, sizeof(struct file_handle))) {\n\t\tretval = -EFAULT;\n\t\tgoto out_err;\n\t}\n\tif ((f_handle.handle_bytes > MAX_HANDLE_SZ) ||\n\t    (f_handle.handle_bytes == 0)) {\n\t\tretval = -EINVAL;\n\t\tgoto out_err;\n\t}\n\thandle = kmalloc(sizeof(struct file_handle) + f_handle.handle_bytes,\n\t\t\t GFP_KERNEL);\n\tif (!handle) {\n\t\tretval = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\tif (copy_from_user(handle, ufh,\n\t\t\t   sizeof(struct file_handle) +\n\t\t\t   f_handle.handle_bytes)) {\n\t\tretval = -EFAULT;\n\t\tgoto out_handle;\n\t}\n\tretval = do_handle_to_path(mountdirfd, handle, path);\nout_handle:\n\tkfree(handle);\nout_err:\n\treturn retval;\n}", "target": 1}
{"code": "service_info *FindServiceControlURLPath(\n\tservice_table *table, const char *controlURLPath)\n{\n\tservice_info *finger = NULL;\n\turi_type parsed_url;\n\turi_type parsed_url_in;\n\tif (table && parse_uri(controlURLPath,\n\t\t\t     strlen(controlURLPath),\n\t\t\t     &parsed_url_in) == HTTP_SUCCESS) {\n\t\tfinger = table->serviceList;\n\t\twhile (finger) {\n\t\t\tif (finger->controlURL) {\n\t\t\t\tif (parse_uri(finger->controlURL,\n\t\t\t\t\t    strlen(finger->controlURL),\n\t\t\t\t\t    &parsed_url) == HTTP_SUCCESS) {\n\t\t\t\t\tif (!token_cmp(&parsed_url.pathquery,\n\t\t\t\t\t\t    &parsed_url_in.pathquery)) {\n\t\t\t\t\t\treturn finger;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinger = finger->next;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static int vfio_msi_enable(struct vfio_pci_device *vdev, int nvec, bool msix)\n{\n\tstruct pci_dev *pdev = vdev->pdev;\n\tunsigned int flag = msix ? PCI_IRQ_MSIX : PCI_IRQ_MSI;\n\tint ret;\n \tif (!is_irq_none(vdev))\n \t\treturn -EINVAL;\n\tvdev->ctx = kzalloc(nvec * sizeof(struct vfio_pci_irq_ctx), GFP_KERNEL);\n \tif (!vdev->ctx)\n \t\treturn -ENOMEM;\n\tret = pci_alloc_irq_vectors(pdev, 1, nvec, flag);\n\tif (ret < nvec) {\n\t\tif (ret > 0)\n\t\t\tpci_free_irq_vectors(pdev);\n\t\tkfree(vdev->ctx);\n\t\treturn ret;\n\t}\n\tvdev->num_ctx = nvec;\n\tvdev->irq_type = msix ? VFIO_PCI_MSIX_IRQ_INDEX :\n\t\t\t\tVFIO_PCI_MSI_IRQ_INDEX;\n\tif (!msix) {\n\t\tvdev->msi_qmax = fls(nvec * 2 - 1) - 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": " static __u8 *ch_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n \t\tunsigned int *rsize)\n {\n\tif (*rsize >= 17 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {\n \t\thid_info(hdev, \"fixing up Cherry Cymotion report descriptor\\n\");\n \t\trdesc[11] = rdesc[16] = 0xff;\n \t\trdesc[12] = rdesc[17] = 0x03;\n\t}\n\treturn rdesc;\n}", "target": 1}
{"code": "NAN_METHOD(DetectCharacterEncoding) {\n\tNan::HandleScope scope;\n\tv8::Local<v8::Object> inputBuffer = info[0]->ToObject();\n\tUCharsetDetector *charsetDetector;\n\tconst UCharsetMatch *charsetMatch;\n\tUErrorCode errorCode = U_ZERO_ERROR;\n\tcharsetDetector = ucsdet_open(&errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to open ICU charset detector.\");\n\t\treturn;\n\t}\n\tucsdet_setText(\n\t\tcharsetDetector,\n\t\tnode::Buffer::Data(inputBuffer),\n\t\tnode::Buffer::Length(inputBuffer),\n\t\t&errorCode\n\t);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to set ICU charset detectors text.\");\n\t\treturn;\n\t}\n\tcharsetMatch = ucsdet_detect(charsetDetector, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to detect charset.\");\n\t\treturn;\n\t}\n\tconst char *charsetName = ucsdet_getName(charsetMatch, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get name from charset match.\");\n\t\treturn;\n\t}\n\tint32_t confidence = ucsdet_getConfidence(charsetMatch, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get confidence from charset match.\");\n\t\treturn;\n\t}\n\tv8::Local<v8::Object> obj = Nan::New<v8::Object>();\n\tobj->Set(Nan::New<v8::String>(\"encoding\").ToLocalChecked(), Nan::New<v8::String>(charsetName).ToLocalChecked());\n\tobj->Set(Nan::New<v8::String>(\"confidence\").ToLocalChecked(), Nan::New<v8::Number>(confidence));\n\tinfo.GetReturnValue().Set(obj);\n}", "target": 1}
{"code": "static int raw_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t       int *len, int peer)\n{\n\tstruct sockaddr_can *addr = (struct sockaddr_can *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct raw_sock *ro = raw_sk(sk);\n\tif (peer)\n\t\treturn -EOPNOTSUPP;\n\taddr->can_family  = AF_CAN;\n\taddr->can_ifindex = ro->ifindex;\n\t*len = sizeof(*addr);\n\treturn 0;\n}", "target": 1}
{"code": "int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t *data_len)\n{\n\tstruct sc_path path;\n\tstruct sc_file *file;\n\tunsigned char *p;\n\tint ok = 0;\n\tint r;\n\tsize_t len;\n\tsc_format_path(str_path, &path);\n\tif (SC_SUCCESS != sc_select_file(card, &path, &file)) {\n \t\tgoto err;\n \t}\n\tlen = file ? file->size : 4096;\n \tp = realloc(*data, len);\n \tif (!p) {\n \t\tgoto err;\n\t}\n\t*data = p;\n\t*data_len = len;\n\tr = sc_read_binary(card, 0, p, len, 0);\n\tif (r < 0)\n\t\tgoto err;\n\t*data_len = r;\n\tok = 1;\nerr:\n\tsc_file_free(file);\n\treturn ok;\n}", "target": 1}
{"code": " status_t NuPlayer::GenericSource::setBuffers(\n         bool audio, Vector<MediaBuffer *> &buffers) {\n    if (mIsWidevine && !audio && mVideoTrack.mSource != NULL) {\n         return mVideoTrack.mSource->setBuffers(buffers);\n     }\n     return INVALID_OPERATION;\n}", "target": 1}
{"code": "copy_ciphersuites(gnutls_session_t session,\n\t\t  gnutls_buffer_st * cdata, int add_scsv)\n{\n\tint ret;\n\tuint8_t cipher_suites[MAX_CIPHERSUITE_SIZE + 2]; \n\tint cipher_suites_size;\n\tsize_t init_length = cdata->length;\n\tret =\n\t    _gnutls_supported_ciphersuites(session, cipher_suites,\n\t\t\t\t\t   sizeof(cipher_suites) - 2);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\tret =\n\t    _gnutls_remove_unwanted_ciphersuites(session, cipher_suites,\n\t\t\t\t\t\t ret, NULL, 0);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\tif (ret == 0)\n\t\treturn\n\t\t    gnutls_assert_val(GNUTLS_E_INSUFFICIENT_CREDENTIALS);\n\tcipher_suites_size = ret;\n\tif (add_scsv) {\n\t\tcipher_suites[cipher_suites_size] = 0x00;\n\t\tcipher_suites[cipher_suites_size + 1] = 0xff;\n\t\tcipher_suites_size += 2;\n\t\tret = _gnutls_ext_sr_send_cs(session);\n\t\tif (ret < 0)\n\t\t\treturn gnutls_assert_val(ret);\n\t}\n\tret =\n\t    _gnutls_buffer_append_data_prefix(cdata, 16, cipher_suites,\n\t\t\t\t\t      cipher_suites_size);\n\tif (ret < 0)\n\t\treturn gnutls_assert_val(ret);\n\tret = cdata->length - init_length;\n\treturn ret;\n}", "target": 1}
{"code": "setup_arch (char **cmdline_p)\n{\n\tunw_init();\n\tia64_patch_vtop((u64) __start___vtop_patchlist, (u64) __end___vtop_patchlist);\n\t*cmdline_p = __va(ia64_boot_param->command_line);\n\tstrlcpy(boot_command_line, *cmdline_p, COMMAND_LINE_SIZE);\n\tefi_init();\n\tio_port_init();\n#ifdef CONFIG_IA64_GENERIC\n\tmachvec_init_from_cmdline(*cmdline_p);\n#endif\n\tparse_early_param();\n\tif (early_console_setup(*cmdline_p) == 0)\n\t\tmark_bsp_online();\n#ifdef CONFIG_ACPI\n\tacpi_table_init();\n# ifdef CONFIG_ACPI_NUMA\n\tacpi_numa_init();\n\tper_cpu_scan_finalize((cpus_weight(early_cpu_possible_map) == 0 ?\n\t\t32 : cpus_weight(early_cpu_possible_map)), additional_cpus);\n# endif\n#else\n# ifdef CONFIG_SMP\n\tsmp_build_cpu_map();\t\n# endif\n#endif \n\tfind_memory();\n \tia64_sal_init(__va(efi.sal_systab));\n #ifdef CONFIG_SMP\n \tcpu_physical_id(0) = hard_smp_processor_id();\n #endif\n\tcpu_init();\t\n\tmmu_context_init();\t\n\tcheck_sal_cache_flush();\n#ifdef CONFIG_ACPI\n\tacpi_boot_init();\n#endif\n#ifdef CONFIG_VT\n\tif (!conswitchp) {\n# if defined(CONFIG_DUMMY_CONSOLE)\n\t\tconswitchp = &dummy_con;\n# endif\n# if defined(CONFIG_VGA_CONSOLE)\n\t\tif (efi_mem_type(0xA0000) != EFI_CONVENTIONAL_MEMORY)\n\t\t\tconswitchp = &vga_con;\n# endif\n\t}\n#endif\n\tif (!nomca)\n\t\tia64_mca_init();\n\tplatform_setup(cmdline_p);\n\tpaging_init();\n}", "target": 1}
{"code": "xmlParse3986Port(xmlURIPtr uri, const char **str)\n{\n const char *cur = *str;\n unsigned port = 0; \n if (ISA_DIGIT(cur)) {\n while (ISA_DIGIT(cur)) {\n\t    port = port * 10 + (*cur - '0');\n \t    cur++;\n \t}\n \tif (uri != NULL)\n\t    uri->port = port & INT_MAX; \n \t*str = cur;\n \treturn(0);\n     }\n return(1);\n}", "target": 1}
{"code": "ospf6_print_lshdr(netdissect_options *ndo,\n                  register const struct lsa6_hdr *lshp, const u_char *dataend)\n {\n \tif ((const u_char *)(lshp + 1) > dataend)\n \t\tgoto trunc;\n\tND_TCHECK(lshp->ls_type);\n\tND_TCHECK(lshp->ls_seq);\n \tND_PRINT((ndo, \"\\n\\t  Advertising Router %s, seq 0x%08x, age %us, length %u\",\n                ipaddr_string(ndo, &lshp->ls_router),\n               EXTRACT_32BITS(&lshp->ls_seq),\n               EXTRACT_16BITS(&lshp->ls_age),\n               EXTRACT_16BITS(&lshp->ls_length)-(u_int)sizeof(struct lsa6_hdr)));\n\tospf6_print_ls_type(ndo, EXTRACT_16BITS(&lshp->ls_type), &lshp->ls_stateid);\n\treturn (0);\ntrunc:\n\treturn (1);\n}", "target": 1}
{"code": "static int ocfs2_prepare_page_for_write(struct inode *inode, u64 *p_blkno,\n\t\t\t\t\tstruct ocfs2_write_ctxt *wc,\n\t\t\t\t\tstruct page *page, u32 cpos,\n\t\t\t\t\tloff_t user_pos, unsigned user_len,\n\t\t\t\t\tint new)\n{\n\tint ret;\n\tunsigned int map_from = 0, map_to = 0;\n\tunsigned int cluster_start, cluster_end;\n\tunsigned int user_data_from = 0, user_data_to = 0;\n\tocfs2_figure_cluster_boundaries(OCFS2_SB(inode->i_sb), cpos,\n\t\t\t\t\t&cluster_start, &cluster_end);\n\tif (page == wc->w_target_page) {\n\t\tmap_from = user_pos & (PAGE_CACHE_SIZE - 1);\n\t\tmap_to = map_from + user_len;\n\t\tif (new)\n\t\t\tret = ocfs2_map_page_blocks(page, p_blkno, inode,\n\t\t\t\t\t\t    cluster_start, cluster_end,\n\t\t\t\t\t\t    new);\n\t\telse\n\t\t\tret = ocfs2_map_page_blocks(page, p_blkno, inode,\n\t\t\t\t\t\t    map_from, map_to, new);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tuser_data_from = map_from;\n\t\tuser_data_to = map_to;\n\t\tif (new) {\n\t\t\tmap_from = cluster_start;\n\t\t\tmap_to = cluster_end;\n\t\t}\n\t} else {\n\t\tBUG_ON(!new);\n\t\tmap_from = cluster_start;\n\t\tmap_to = cluster_end;\n\t\tret = ocfs2_map_page_blocks(page, p_blkno, inode,\n\t\t\t\t\t    cluster_start, cluster_end, new);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (new && !PageUptodate(page))\n\t\tocfs2_clear_page_regions(page, OCFS2_SB(inode->i_sb),\n\t\t\t\t\t cpos, user_data_from, user_data_to);\n\tflush_dcache_page(page);\nout:\n\treturn ret;\n}", "target": 1}
{"code": "static void coroutine_fn v9fs_xattrcreate(void *opaque)\n{\n    int flags;\n    int32_t fid;\n    int64_t size;\n    ssize_t err = 0;\n    V9fsString name;\n    size_t offset = 7;\n    V9fsFidState *file_fidp;\n    V9fsFidState *xattr_fidp;\n    V9fsPDU *pdu = opaque;\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dsqd\", &fid, &name, &size, &flags);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_xattrcreate(pdu->tag, pdu->id, fid, name.data, size, flags);\n    file_fidp = get_fid(pdu, fid);\n    if (file_fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    xattr_fidp = file_fidp;\n    xattr_fidp->fid_type = P9_FID_XATTR;\n    xattr_fidp->fs.xattr.copied_len = 0;\n    xattr_fidp->fs.xattr.len = size;\n     xattr_fidp->fs.xattr.flags = flags;\n     v9fs_string_init(&xattr_fidp->fs.xattr.name);\n     v9fs_string_copy(&xattr_fidp->fs.xattr.name, &name);\n     xattr_fidp->fs.xattr.value = g_malloc0(size);\n     err = offset;\n     put_fid(pdu, file_fidp);\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}", "target": 1}
{"code": "static void ml_ff_destroy(struct ff_device *ff)\n{\n\tstruct ml_device *ml = ff->private;\n\tkfree(ml->private);\n}", "target": 1}
{"code": "cdf_check_stream_offset(const cdf_stream_t *sst, const cdf_header_t *h,\n    const void *p, size_t tail, int line)\n {\n \tconst char *b = (const char *)sst->sst_tab;\n \tconst char *e = ((const char *)p) + tail;\n \t(void)&line;\n\tif (e >= b && (size_t)(e - b) <= CDF_SEC_SIZE(h) * sst->sst_len)\n \t\treturn 0;\n \tDPRINTF((\"%d: offset begin %p < end %p || %\" SIZE_T_FORMAT \"u\"\n \t    \" > %\" SIZE_T_FORMAT \"u [%\" SIZE_T_FORMAT \"u %\"\n \t    SIZE_T_FORMAT \"u]\\n\", line, b, e, (size_t)(e - b),\n\t    CDF_SEC_SIZE(h) * sst->sst_len, CDF_SEC_SIZE(h), sst->sst_len));\n \terrno = EFTYPE;\n \treturn -1;\n }", "target": 1}
{"code": " ip_printroute(netdissect_options *ndo,\n               register const u_char *cp, u_int length)\n {\n\tregister u_int ptr;\n\tregister u_int len;\n \tif (length < 3) {\n \t\tND_PRINT((ndo, \" [bad length %u]\", length));\n\t\treturn;\n \t}\n \tif ((length + 1) & 3)\n \t\tND_PRINT((ndo, \" [bad length %u]\", length));\n \tptr = cp[2] - 1;\n \tif (ptr < 3 || ((ptr + 1) & 3) || ptr > length + 1)\n \t\tND_PRINT((ndo, \" [bad ptr %u]\", cp[2]));\n \tfor (len = 3; len < length; len += 4) {\n \t\tND_PRINT((ndo, \" %s\", ipaddr_string(ndo, &cp[len])));\n \t\tif (ptr > len)\n \t\t\tND_PRINT((ndo, \",\"));\n \t}\n }", "target": 1}
{"code": "xmlDocPtr soap_xmlParseMemory(const void *buf, size_t buf_size)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n        ctxt = xmlCreateMemoryParserCtxt(buf, buf_size);\n        if (ctxt) {\n               ctxt->options -= XML_PARSE_DTDLOAD;\n                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n                ctxt->sax->comment = soap_Comment;\n                ctxt->sax->warning = NULL;\n\t\tctxt->sax->error = NULL;\n#if LIBXML_VERSION >= 20703\n\t\tctxt->options |= XML_PARSE_HUGE;\n#endif\n\t\txmlParseDocument(ctxt);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static MemTxResult address_space_write_continue(AddressSpace *as, hwaddr addr,\n                                                MemTxAttrs attrs,\n                                                const uint8_t *buf,\n                                                int len, hwaddr addr1,\n                                                hwaddr l, MemoryRegion *mr)\n{\n    uint8_t *ptr;\n    uint64_t val;\n    MemTxResult result = MEMTX_OK;\n    bool release_lock = false;\n    for (;;) {\n        if (!memory_access_is_direct(mr, true)) {\n            release_lock |= prepare_mmio_access(mr);\n            l = memory_access_size(mr, l, addr1);\n            switch (l) {\n            case 8:\n                val = ldq_p(buf);\n                result |= memory_region_dispatch_write(mr, addr1, val, 8,\n                                                       attrs);\n                break;\n            case 4:\n                val = (uint32_t)ldl_p(buf);\n                result |= memory_region_dispatch_write(mr, addr1, val, 4,\n                                                       attrs);\n                break;\n            case 2:\n                val = lduw_p(buf);\n                result |= memory_region_dispatch_write(mr, addr1, val, 2,\n                                                       attrs);\n                break;\n            case 1:\n                val = ldub_p(buf);\n                result |= memory_region_dispatch_write(mr, addr1, val, 1,\n                                                       attrs);\n                break;\n            default:\n                abort();\n            }\n        } else {\n            ptr = qemu_map_ram_ptr(mr->ram_block, addr1);\n            memcpy(ptr, buf, l);\n            invalidate_and_set_dirty(mr, addr1, l);\n        }\n        if (release_lock) {\n            qemu_mutex_unlock_iothread();\n            release_lock = false;\n        }\n        len -= l;\n        buf += l;\n        addr += l;\n        if (!len) {\n            break;\n        }\n        l = len;\n        mr = address_space_translate(as, addr, &addr1, &l, true);\n    }\n    return result;\n}", "target": 1}
{"code": "static void set_banner(struct openconnect_info *vpninfo)\n{\n        char *banner, *q;\n        const char *p;\n       if (!vpninfo->banner || !(banner = malloc(strlen(vpninfo->banner)))) {\n                unsetenv(\"CISCO_BANNER\");\n                return;\n        }\n\tp = vpninfo->banner;\n\tq = banner;\n\twhile (*p) {\n\t\tif (*p == '%' && isxdigit((int)(unsigned char)p[1]) &&\n\t\t    isxdigit((int)(unsigned char)p[2])) {\n\t\t\t*(q++) = unhex(p + 1);\n\t\t\tp += 3;\n\t\t} else \n\t\t\t*(q++) = *(p++);\n\t}\n\t*q = 0;\n\tsetenv(\"CISCO_BANNER\", banner, 1);\n\tfree(banner);\n}\t", "target": 1}
{"code": "static int ax88179_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\n{\n\tstruct sk_buff *ax_skb;\n\tint pkt_cnt;\n\tu32 rx_hdr;\n\tu16 hdr_off;\n\tu32 *pkt_hdr;\n\tif (skb->len < dev->net->hard_header_len)\n\t\treturn 0;\n\tskb_trim(skb, skb->len - 4);\n\trx_hdr = get_unaligned_le32(skb_tail_pointer(skb));\n\tpkt_cnt = (u16)rx_hdr;\n\thdr_off = (u16)(rx_hdr >> 16);\n\tpkt_hdr = (u32 *)(skb->data + hdr_off);\n\twhile (pkt_cnt--) {\n\t\tu16 pkt_len;\n\t\tle32_to_cpus(pkt_hdr);\n\t\tpkt_len = (*pkt_hdr >> 16) & 0x1fff;\n\t\tif ((*pkt_hdr & AX_RXHDR_CRC_ERR) ||\n\t\t    (*pkt_hdr & AX_RXHDR_DROP_ERR)) {\n\t\t\tskb_pull(skb, (pkt_len + 7) & 0xFFF8);\n\t\t\tpkt_hdr++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (pkt_cnt == 0) {\n\t\t\tskb->len = pkt_len;\n\t\t\tskb_pull(skb, 2);\n\t\t\tskb_set_tail_pointer(skb, skb->len);\n\t\t\tskb->truesize = pkt_len + sizeof(struct sk_buff);\n\t\t\tax88179_rx_checksum(skb, pkt_hdr);\n\t\t\treturn 1;\n\t\t}\n\t\tax_skb = skb_clone(skb, GFP_ATOMIC);\n\t\tif (ax_skb) {\n\t\t\tax_skb->len = pkt_len;\n\t\t\tskb_pull(ax_skb, 2);\n\t\t\tskb_set_tail_pointer(ax_skb, ax_skb->len);\n\t\t\tax_skb->truesize = pkt_len + sizeof(struct sk_buff);\n\t\t\tax88179_rx_checksum(ax_skb, pkt_hdr);\n\t\t\tusbnet_skb_return(dev, ax_skb);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t\tskb_pull(skb, (pkt_len + 7) & 0xFFF8);\n\t\tpkt_hdr++;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "yaml_parser_save_simple_key(yaml_parser_t *parser)\n{\n    int required = (!parser->flow_level\n            && parser->indent == (ptrdiff_t)parser->mark.column);\n    assert(parser->simple_key_allowed || !required);    \n    if (parser->simple_key_allowed)\n    {\n        yaml_simple_key_t simple_key;\n        simple_key.possible = 1;\n        simple_key.required = required;\n        simple_key.token_number = \n            parser->tokens_parsed + (parser->tokens.tail - parser->tokens.head);\n        simple_key.mark = parser->mark;\n        if (!yaml_parser_remove_simple_key(parser)) return 0;\n        *(parser->simple_keys.top-1) = simple_key;\n    }\n    return 1;\n}", "target": 1}
{"code": "static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)\n{\n\tstruct fsck_gitmodules_data *data = vdata;\n\tconst char *subsection, *key;\n\tint subsection_len;\n\tchar *name;\n\tif (parse_config_key(var, \"submodule\", &subsection, &subsection_len, &key) < 0 ||\n\t    !subsection)\n\t\treturn 0;\n\tname = xmemdupz(subsection, subsection_len);\n\tif (check_submodule_name(name) < 0)\n\t\tdata->ret |= report(data->options, data->obj,\n \t\t\t\t    FSCK_MSG_GITMODULES_NAME,\n \t\t\t\t    \"disallowed submodule name: %s\",\n \t\t\t\t    name);\n \tfree(name);\n \treturn 0;\n}", "target": 1}
{"code": "static int ieee80211_fragment(struct ieee80211_tx_data *tx,\n\t\t\t      struct sk_buff *skb, int hdrlen,\n\t\t\t      int frag_threshold)\n{\n\tstruct ieee80211_local *local = tx->local;\n\tstruct ieee80211_tx_info *info;\n\tstruct sk_buff *tmp;\n\tint per_fragm = frag_threshold - hdrlen - FCS_LEN;\n\tint pos = hdrlen + per_fragm;\n\tint rem = skb->len - hdrlen - per_fragm;\n\tif (WARN_ON(rem < 0))\n\t\treturn -EINVAL;\n\twhile (rem) {\n\t\tint fraglen = per_fragm;\n\t\tif (fraglen > rem)\n\t\t\tfraglen = rem;\n\t\trem -= fraglen;\n\t\ttmp = dev_alloc_skb(local->tx_headroom +\n\t\t\t\t    frag_threshold +\n\t\t\t\t    tx->sdata->encrypt_headroom +\n\t\t\t\t    IEEE80211_ENCRYPT_TAILROOM);\n\t\tif (!tmp)\n\t\t\treturn -ENOMEM;\n\t\t__skb_queue_tail(&tx->skbs, tmp);\n\t\tskb_reserve(tmp,\n\t\t\t    local->tx_headroom + tx->sdata->encrypt_headroom);\n\t\tmemcpy(tmp->cb, skb->cb, sizeof(tmp->cb));\n\t\tinfo = IEEE80211_SKB_CB(tmp);\n\t\tinfo->flags &= ~(IEEE80211_TX_CTL_CLEAR_PS_FILT |\n\t\t\t\t IEEE80211_TX_CTL_FIRST_FRAGMENT);\n\t\tif (rem)\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_MORE_FRAMES;\n\t\tskb_copy_queue_mapping(tmp, skb);\n\t\ttmp->priority = skb->priority;\n\t\ttmp->dev = skb->dev;\n\t\tmemcpy(skb_put(tmp, hdrlen), skb->data, hdrlen);\n\t\tmemcpy(skb_put(tmp, fraglen), skb->data + pos, fraglen);\n\t\tpos += fraglen;\n \t}\n\tskb->len = hdrlen + per_fragm;\n \treturn 0;\n }", "target": 1}
{"code": "static Jsi_RC NumberToPrecisionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[100];\n    int prec = 0, skip = 0;\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    if (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &prec) != JSI_OK)\n        return JSI_ERROR;\n    if (prec<=0) return JSI_ERROR;\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    snprintf(buf, sizeof(buf),\"%.*\" JSI_NUMFFMT, prec, num);\n    if (num<0)\n        prec++;\n    buf[prec+1] = 0;\n    if (buf[prec] == '.')\n        buf[prec] = 0;\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}", "target": 1}
{"code": "static PyObject *checkPassword(PyObject *self, PyObject *args)\n{\n    const char *user = NULL;\n    const char *pswd = NULL;\n    const char *service = NULL;\n    const char *default_realm = NULL;\n    int result = 0;\n    if (!PyArg_ParseTuple(args, \"ssss\", &user, &pswd, &service, &default_realm))\n        return NULL;\n    result = authenticate_user_krb5pwd(user, pswd, service, default_realm);\n    if (result)\n        return Py_INCREF(Py_True), Py_True;\n    else\n        return NULL;\n}", "target": 1}
{"code": "scrollback_get_filename (session *sess)\n{\n\tchar *net, *chan, *buf, *ret = NULL;\n\tnet = server_get_network (sess->server, FALSE);\n\tif (!net)\n\t\treturn NULL;\n\tbuf = g_strdup_printf (\"%s\" G_DIR_SEPARATOR_S \"scrollback\" G_DIR_SEPARATOR_S \"%s\" G_DIR_SEPARATOR_S \"%s.txt\", get_xdir (), net, \"\");\n\tmkdir_p (buf);\n\tg_free (buf);\n\tchan = log_create_filename (sess->channel);\n\tif (chan[0])\n\t\tbuf = g_strdup_printf (\"%s\" G_DIR_SEPARATOR_S \"scrollback\" G_DIR_SEPARATOR_S \"%s\" G_DIR_SEPARATOR_S \"%s.txt\", get_xdir (), net, chan);\n\telse\n\t\tbuf = NULL;\n\tg_free (chan);\n\tif (buf)\n\t{\n\t\tret = g_filename_from_utf8 (buf, -1, NULL, NULL, NULL);\n\t\tg_free (buf);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static size_t php_bz2iop_read(php_stream *stream, char *buf, size_t count TSRMLS_DC)\n{\n\tstruct php_bz2_stream_data_t *self = (struct php_bz2_stream_data_t *) stream->abstract;\n\tsize_t ret;\n\tret = BZ2_bzread(self->bz_file, buf, count);\n\tif (ret == 0) {\n\t\tstream->eof = 1;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static void LogOpenCLBuildFailure(MagickCLDevice device,const char *kernel,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent],\n    *log;\n  size_t\n    log_size;\n  (void) FormatLocaleString(filename,MagickPathExtent,\"%s%s%s\",\n    GetOpenCLCacheDirectory(),DirectorySeparator,\"magick_badcl.cl\");\n  (void) remove_utf8(filename);\n  (void) BlobToFile(filename,kernel,strlen(kernel),exception);\n  openCL_library->clGetProgramBuildInfo(device->program,device->deviceID,\n    CL_PROGRAM_BUILD_LOG,0,NULL,&log_size);\n  log=(char*)AcquireMagickMemory(log_size);\n  openCL_library->clGetProgramBuildInfo(device->program,device->deviceID,\n    CL_PROGRAM_BUILD_LOG,log_size,log,&log_size);\n  (void) FormatLocaleString(filename,MagickPathExtent,\"%s%s%s\",\n    GetOpenCLCacheDirectory(),DirectorySeparator,\"magick_badcl.log\");\n  (void) remove_utf8(filename);\n  (void) BlobToFile(filename,log,log_size,exception);\n  log=(char*)RelinquishMagickMemory(log);\n}", "target": 1}
{"code": "GetCode_(gdIOCtx *fd, CODE_STATIC_DATA *scd, int code_size, int flag, int *ZeroDataBlockP)\n{\n\tint           i, j, ret;\n\tunsigned char count;\n\tif (flag) {\n\t\tscd->curbit = 0;\n\t\tscd->lastbit = 0;\n\t\tscd->last_byte = 0;\n\t\tscd->done = FALSE;\n\t\treturn 0;\n\t}\n\tif ( (scd->curbit + code_size) >= scd->lastbit) {\n\t\tif (scd->done) {\n\t\t\tif (scd->curbit >= scd->lastbit) {\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\tscd->buf[0] = scd->buf[scd->last_byte-2];\n\t\tscd->buf[1] = scd->buf[scd->last_byte-1];\n               if ((count = GetDataBlock(fd, &scd->buf[2], ZeroDataBlockP)) <= 0)\n\t\t\tscd->done = TRUE;\n\t\tscd->last_byte = 2 + count;\n\t\tscd->curbit = (scd->curbit - scd->lastbit) + 16;\n\t\tscd->lastbit = (2+count)*8 ;\n\t}\n\tret = 0;\n\tfor (i = scd->curbit, j = 0; j < code_size; ++i, ++j)\n\t\tret |= ((scd->buf[ i / 8 ] & (1 << (i % 8))) != 0) << j;\n\tscd->curbit += code_size;\n\treturn ret;\n}", "target": 1}
{"code": "static int ssl_verify_server_cert(Vio *vio, const char* server_hostname, const char **errptr)\n{\n  SSL *ssl;\n  X509 *server_cert;\n  char *cp1, *cp2;\n  char *buf;\n  DBUG_ENTER(\"ssl_verify_server_cert\");\n  DBUG_PRINT(\"enter\", (\"server_hostname: %s\", server_hostname));\n  if (!(ssl= (SSL*)vio->ssl_arg))\n  {\n    *errptr= \"No SSL pointer found\";\n    DBUG_RETURN(1);\n  }\n  if (!server_hostname)\n  {\n    *errptr= \"No server hostname supplied\";\n    DBUG_RETURN(1);\n  }\n  if (!(server_cert= SSL_get_peer_certificate(ssl)))\n  {\n    *errptr= \"Could not get server certificate\";\n    DBUG_RETURN(1);\n  }\n  if (X509_V_OK != SSL_get_verify_result(ssl))\n  {\n    *errptr= \"Failed to verify the server certificate\";\n    X509_free(server_cert);\n    DBUG_RETURN(1);\n  }\n  buf= X509_NAME_oneline(X509_get_subject_name(server_cert), 0, 0);\n  X509_free (server_cert);\n  if (!buf)\n  {\n    *errptr= \"Out of memory\";\n    DBUG_RETURN(1);\n  }\n  DBUG_PRINT(\"info\", (\"hostname in cert: %s\", buf));\n  cp1= strstr(buf, \"/CN=\");\n  if (cp1)\n  {\n    cp1+= 4; \n    cp2= strchr(cp1, '/');\n    if (cp2)\n      *cp2= '\\0';\n    DBUG_PRINT(\"info\", (\"Server hostname in cert: %s\", cp1));\n    if (!strcmp(cp1, server_hostname))\n    {\n      free(buf);\n      DBUG_RETURN(0);\n    }\n  }\n  *errptr= \"SSL certificate validation failure\";\n  free(buf);\n  DBUG_RETURN(1);\n}", "target": 1}
{"code": "Status QuantizeV2Shape(InferenceContext* c) {\n  int axis = -1;\n  Status s = c->GetAttr(\"axis\", &axis);\n  if (!s.ok() && s.code() != error::NOT_FOUND) {\n    return s;\n  }\n  const int minmax_rank = (axis == -1) ? 0 : 1;\n  TF_RETURN_IF_ERROR(shape_inference::UnchangedShape(c));\n  ShapeHandle minmax;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(1), minmax_rank, &minmax));\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(2), minmax_rank, &minmax));\n  if (axis != -1) {\n    ShapeHandle input;\n    TF_RETURN_IF_ERROR(c->WithRankAtLeast(c->input(0), axis + 1, &input));\n    DimensionHandle depth;\n    TF_RETURN_IF_ERROR(\n        c->Merge(c->Dim(minmax, 0), c->Dim(input, axis), &depth));\n  }\n  c->set_output(1, minmax);\n  c->set_output(2, minmax);\n  return Status::OK();\n}", "target": 1}
{"code": "void generic_pipe_buf_get(struct pipe_inode_info *pipe, struct pipe_buffer *buf)\n {\n\tget_page(buf->page);\n }", "target": 1}
{"code": "unserialize_uep(bufinfo_T *bi, int *error, char_u *file_name)\n{\n    int\t\ti;\n    u_entry_T\t*uep;\n    char_u\t**array;\n    char_u\t*line;\n    int\t\tline_len;\n    uep = (u_entry_T *)U_ALLOC_LINE(sizeof(u_entry_T));\n    if (uep == NULL)\n\treturn NULL;\n    vim_memset(uep, 0, sizeof(u_entry_T));\n#ifdef U_DEBUG\n    uep->ue_magic = UE_MAGIC;\n#endif\n    uep->ue_top = undo_read_4c(bi);\n    uep->ue_bot = undo_read_4c(bi);\n    uep->ue_lcount = undo_read_4c(bi);\n    uep->ue_size = undo_read_4c(bi);\n    if (uep->ue_size > 0)\n    {\n\tarray = (char_u **)U_ALLOC_LINE(sizeof(char_u *) * uep->ue_size);\n\tif (array == NULL)\n\t{\n\t    *error = TRUE;\n\t    return uep;\n\t}\n\tvim_memset(array, 0, sizeof(char_u *) * uep->ue_size);\n    }\n    else\n\tarray = NULL;\n    uep->ue_array = array;\n    for (i = 0; i < uep->ue_size; ++i)\n    {\n\tline_len = undo_read_4c(bi);\n\tif (line_len >= 0)\n\t    line = read_string_decrypt(bi, line_len);\n\telse\n\t{\n\t    line = NULL;\n\t    corruption_error(\"line length\", file_name);\n\t}\n\tif (line == NULL)\n\t{\n\t    *error = TRUE;\n\t    return uep;\n\t}\n\tarray[i] = line;\n    }\n    return uep;\n}", "target": 1}
{"code": "void FileSystemManagerImpl::CreateWriter(const GURL& file_path,\n                                          CreateWriterCallback callback) {\n   DCHECK_CURRENTLY_ON(BrowserThread::IO);\n   FileSystemURL url(context_->CrackURL(file_path));\n   base::Optional<base::File::Error> opt_error = ValidateFileSystemURL(url);\n   if (opt_error) {\n    std::move(callback).Run(opt_error.value(), nullptr);\n    return;\n  }\n  if (!security_policy_->CanWriteFileSystemFile(process_id_, url)) {\n    std::move(callback).Run(base::File::FILE_ERROR_SECURITY, nullptr);\n    return;\n  }\n  blink::mojom::FileWriterPtr writer;\n  mojo::MakeStrongBinding(std::make_unique<storage::FileWriterImpl>(\n                              url, context_->CreateFileSystemOperationRunner(),\n                              blob_storage_context_->context()->AsWeakPtr()),\n                          MakeRequest(&writer));\n  std::move(callback).Run(base::File::FILE_OK, std::move(writer));\n}", "target": 1}
{"code": "int nntp_add_group(char *line, void *data)\n {\n   struct NntpServer *nserv = data;\n   struct NntpData *nntp_data = NULL;\n  char group[LONG_STRING];\n   char desc[HUGE_STRING] = \"\";\n   char mod;\n   anum_t first, last;\n   if (!nserv || !line)\n     return 0;\n  if (sscanf(line, \"%s \" ANUM \" \" ANUM \" %c %[^\\n]\", group, &last, &first, &mod, desc) < 4)\n     return 0;\n   nntp_data = nntp_data_find(nserv, group);\n   nntp_data->deleted = false;\n  nntp_data->first_message = first;\n  nntp_data->last_message = last;\n  nntp_data->allowed = (mod == 'y') || (mod == 'm');\n  mutt_str_replace(&nntp_data->desc, desc);\n  if (nntp_data->newsrc_ent || nntp_data->last_cached)\n    nntp_group_unread_stat(nntp_data);\n  else if (nntp_data->last_message && nntp_data->first_message <= nntp_data->last_message)\n    nntp_data->unread = nntp_data->last_message - nntp_data->first_message + 1;\n  else\n    nntp_data->unread = 0;\n  return 0;\n}", "target": 1}
{"code": "static UINT drive_process_irp_write(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tDRIVE_FILE* file;\n\tUINT32 Length;\n\tUINT64 Offset;\n\tif (!drive || !irp || !irp->input || !irp->output || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Read_UINT64(irp->input, Offset);\n\tStream_Seek(irp->input, 20); \n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\tif (!file)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_seek(file, Offset))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_write(file, Stream_Pointer(irp->input), Length))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\tStream_Write_UINT32(irp->output, Length);\n\tStream_Write_UINT8(irp->output, 0); \n\treturn irp->Complete(irp);\n}", "target": 1}
{"code": "BGD_DECLARE(void *) gdImageBmpPtr(gdImagePtr im, int *size, int compression)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) return NULL;\n\tgdImageBmpCtx(im, out, compression);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}", "target": 1}
{"code": "  Status CalculateOutputIndex(OpKernelContext* context, int dimension,\n                              const vector<INDEX_TYPE>& parent_output_index,\n                              INDEX_TYPE output_index_multiplier,\n                              INDEX_TYPE output_size,\n                              vector<INDEX_TYPE>* result) {\n    const RowPartitionTensor row_partition_tensor =\n        GetRowPartitionTensor(context, dimension);\n    auto partition_type = GetRowPartitionTypeByDimension(dimension);\n    switch (partition_type) {\n      case RowPartitionType::VALUE_ROWIDS:\n        CalculateOutputIndexValueRowID(\n            context, row_partition_tensor, parent_output_index,\n            output_index_multiplier, output_size, result);\n        return tensorflow::Status::OK();\n      case RowPartitionType::ROW_SPLITS:\n        CalculateOutputIndexRowSplit(\n            context, row_partition_tensor, parent_output_index,\n            output_index_multiplier, output_size, result);\n        return tensorflow::Status::OK();\n      default:\n        return errors::InvalidArgument(\n            \"Unsupported partition type:\",\n            RowPartitionTypeToString(partition_type));\n    }\n  }", "target": 1}
{"code": " static MagickBooleanType ConcatenateImages(int argc,char **argv,\n     ExceptionInfo *exception )\n {\n   FILE\n     *input,\n     *output;\n   int\n     c;\n  register ssize_t\n    i;\n   if (ExpandFilenames(&argc,&argv) == MagickFalse)\n     ThrowFileException(exception,ResourceLimitError,\"MemoryAllocationFailed\",\n         GetExceptionMessage(errno));\n   output=fopen_utf8(argv[argc-1],\"wb\");\n  if (output == (FILE *) NULL) {\n    ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",argv[argc-1]);\n    return(MagickFalse);\n  }\n  for (i=2; i < (ssize_t) (argc-1); i++) {\n#if 0\n    fprintf(stderr, \"DEBUG: Concatenate Image: \\\"%s\\\"\\n\", argv[i]);\n#endif\n     input=fopen_utf8(argv[i],\"rb\");\n    if (input == (FILE *) NULL) {\n         ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",argv[i]);\n         continue;\n       }\n     for (c=fgetc(input); c != EOF; c=fgetc(input))\n      (void) fputc((char) c,output);\n     (void) fclose(input);\n     (void) remove_utf8(argv[i]);\n   }\n   (void) fclose(output);\n  return(MagickTrue);\n }", "target": 1}
{"code": "bool initialise_control(rzip_control *control)\n{\n\ttime_t now_t, tdiff;\n\tchar localeptr[] = \"./\", *eptr; \n\tsize_t len;\n\tmemset(control, 0, sizeof(rzip_control));\n\tcontrol->msgout = stderr;\n\tcontrol->msgerr = stderr;\n\tregister_outputfile(control, control->msgout);\n\tcontrol->flags = FLAG_SHOW_PROGRESS | FLAG_KEEP_FILES | FLAG_THRESHOLD;\n\tcontrol->suffix = \".lrz\";\n\tcontrol->compression_level = 7;\n\tcontrol->ramsize = get_ram(control);\n\tif (unlikely(control->ramsize == -1))\n\t\treturn false;\n\tcontrol->threads = PROCESSORS;\t\n\tcontrol->page_size = PAGE_SIZE;\n\tcontrol->nice_val = 19;\n\tif (unlikely((now_t = time(NULL)) == ((time_t)-1)))\n\t\tfatal_return((\"Failed to call time in main\\n\"), false);\n\tif (unlikely(now_t < T_ZERO)) {\n\t\tprint_output(\"Warning your time reads before the year 2011, check your system clock\\n\");\n\t\tnow_t = T_ZERO;\n\t}\n\ttdiff = (now_t - T_ZERO) / 4;\n\tnow_t = T_ZERO + tdiff;\n\tcontrol->secs = now_t;\n\tcontrol->encloops = nloops(control->secs, control->salt, control->salt + 1);\n\tif (unlikely(!get_rand(control, control->salt + 2, 6)))\n\t\treturn false;\n\teptr = getenv(\"TMPDIR\");\n\tif (!eptr)\n\t\teptr = getenv(\"TMP\");\n\tif (!eptr)\n\t\teptr = getenv(\"TEMPDIR\");\n\tif (!eptr)\n\t\teptr = getenv(\"TEMP\");\n\tif (!eptr)\n\t\teptr = localeptr;\n\tlen = strlen(eptr);\n\tcontrol->tmpdir = malloc(len + 2);\n\tif (control->tmpdir == NULL)\n\t\tfatal_return((\"Failed to allocate for tmpdir\\n\"), false);\n\tstrcpy(control->tmpdir, eptr);\n\tif (control->tmpdir[len - 1] != '/') {\n\t\tcontrol->tmpdir[len] = '/'; \n\t\tcontrol->tmpdir[len + 1] = '\\0';\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static int ghash_final(struct shash_desc *desc, u8 *dst)\n{\n\tstruct ghash_desc_ctx *dctx = shash_desc_ctx(desc);\n \tstruct ghash_ctx *ctx = crypto_shash_ctx(desc->tfm);\n \tu8 *buf = dctx->buffer;\n \tghash_flush(ctx, dctx);\n \tmemcpy(dst, buf, GHASH_BLOCK_SIZE);\n\treturn 0;\n}", "target": 1}
{"code": "UNCURL_EXPORT int32_t uncurl_ws_accept(struct uncurl_conn *ucc, char **origins, int32_t n_origins)\n{\n\tint32_t e;\n\te = uncurl_read_header(ucc);\n\tif (e != UNCURL_OK) return e;\n\tuncurl_set_header_str(ucc, \"Upgrade\", \"websocket\");\n\tuncurl_set_header_str(ucc, \"Connection\", \"Upgrade\");\n\tchar *origin = NULL;\n \te = uncurl_get_header_str(ucc, \"Origin\", &origin);\n \tif (e != UNCURL_OK) return e;\n \tbool origin_ok = false;\n\tfor (int32_t x = 0; x < n_origins; x++)\n\t\tif (strstr(origin, origins[x])) {origin_ok = true; break;}\n \tif (!origin_ok) return UNCURL_WS_ERR_ORIGIN;\n\tchar *sec_key = NULL;\n\te = uncurl_get_header_str(ucc, \"Sec-WebSocket-Key\", &sec_key);\n\tif (e != UNCURL_OK) return e;\n\tchar *accept_key = ws_create_accept_key(sec_key);\n\tuncurl_set_header_str(ucc, \"Sec-WebSocket-Accept\", accept_key);\n\tfree(accept_key);\n\te = uncurl_write_header(ucc, \"101\", \"Switching Protocols\", UNCURL_RESPONSE);\n\tif (e != UNCURL_OK) return e;\n\tucc->ws_mask = 0;\n\treturn UNCURL_OK;\n}", "target": 1}
{"code": "static void esp_do_dma(ESPState *s)\n{\n    uint32_t len;\n    int to_device;\n     len = s->dma_left;\n     if (s->do_cmd) {\n         trace_esp_do_dma(s->cmdlen, len);\n         s->dma_memory_read(s->dma_opaque, &s->cmdbuf[s->cmdlen], len);\n         return;\n     }\n        return;\n    }", "target": 1}
{"code": "static void qemu_input_queue_process(void *opaque)\n{\n    struct QemuInputEventQueueHead *queue = opaque;\n    QemuInputEventQueue *item;\n    g_assert(!QTAILQ_EMPTY(queue));\n    item = QTAILQ_FIRST(queue);\n    g_assert(item->type == QEMU_INPUT_QUEUE_DELAY);\n    QTAILQ_REMOVE(queue, item, node);\n    g_free(item);\n    while (!QTAILQ_EMPTY(queue)) {\n        item = QTAILQ_FIRST(queue);\n        switch (item->type) {\n        case QEMU_INPUT_QUEUE_DELAY:\n            timer_mod(item->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)\n                      + item->delay_ms);\n            return;\n        case QEMU_INPUT_QUEUE_EVENT:\n            qemu_input_event_send(item->src, item->evt);\n            qapi_free_InputEvent(item->evt);\n            break;\n        case QEMU_INPUT_QUEUE_SYNC:\n            qemu_input_event_sync();\n            break;\n        }\n        QTAILQ_REMOVE(queue, item, node);\n        queue_count--;\n        g_free(item);\n    }\n}", "target": 1}
{"code": "build_unc_path_to_root(const struct smb_vol *vol,\n\t\tconst struct cifs_sb_info *cifs_sb)\n{\n\tchar *full_path, *pos;\n\tunsigned int pplen = vol->prepath ? strlen(vol->prepath) + 1 : 0;\n\tunsigned int unc_len = strnlen(vol->UNC, MAX_TREE_SIZE + 1);\n\tfull_path = kmalloc(unc_len + pplen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tstrncpy(full_path, vol->UNC, unc_len);\n \tpos = full_path + unc_len;\n \tif (pplen) {\n\t\t*pos++ = CIFS_DIR_SEP(cifs_sb);\n\t\tstrncpy(pos, vol->prepath, pplen);\n \t\tpos += pplen;\n \t}\n\t*pos = '\\0'; \n\tconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));\n\tcifs_dbg(FYI, \"%s: full_path=%s\\n\", __func__, full_path);\n\treturn full_path;\n}", "target": 1}
{"code": " void * calloc(size_t n, size_t lb)\n {\n    if (lb && n > GC_SIZE_MAX / lb)\n       return NULL;\n #   if defined(GC_LINUX_THREADS) \n        {\n          static GC_bool lib_bounds_set = FALSE;\n          ptr_t caller = (ptr_t)__builtin_return_address(0);\n          if (!EXPECT(lib_bounds_set, TRUE)) {\n            GC_init_lib_bounds();\n            lib_bounds_set = TRUE;\n          }\n          if (((word)caller >= (word)GC_libpthread_start\n               && (word)caller < (word)GC_libpthread_end)\n              || ((word)caller >= (word)GC_libld_start\n                  && (word)caller < (word)GC_libld_end))\n            return GC_malloc_uncollectable(n*lb);\n        }\n#   endif\n    return((void *)REDIRECT_MALLOC(n*lb));\n}", "target": 1}
{"code": "RList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *bin) {\n\tRList *entries = r_list_newf (free);\n\tif (!entries) {\n\t\treturn NULL;\n\t}\n\tRBinAddr *entry;\n\tRList *segments = r_bin_ne_get_segments (bin);\n\tif (!segments) {\n\t\tr_list_free (entries);\n\t\treturn NULL;\n\t}\n\tif (bin->ne_header->csEntryPoint) {\n\t\tentry = R_NEW0 (RBinAddr);\n\t\tif (!entry) {\n\t\t\tr_list_free (entries);\n\t\t\treturn NULL;\n\t\t}\n\t\tentry->bits = 16;\n\t\tRBinSection *s = r_list_get_n (segments, bin->ne_header->csEntryPoint - 1);\n\t\tentry->paddr = bin->ne_header->ipEntryPoint + (s? s->paddr: 0);\n\t\tr_list_append (entries, entry);\n\t}\n\tint off = 0;\n\twhile (off < bin->ne_header->EntryTableLength) {\n\t\tut8 bundle_length = *(ut8 *)(bin->entry_table + off);\n\t\tif (!bundle_length) {\n\t\t\tbreak;\n\t\t}\n\t\toff++;\n\t\tut8 bundle_type = *(ut8 *)(bin->entry_table + off);\n\t\toff++;\n\t\tint i;\n\t\tfor (i = 0; i < bundle_length; i++) {\n\t\t\tentry = R_NEW0 (RBinAddr);\n\t\t\tif (!entry) {\n\t\t\t\tr_list_free (entries);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\toff++;\n\t\t\tif (!bundle_type) { \n\t\t\t\toff--;\n\t\t\t\tfree (entry);\n\t\t\t\tbreak;\n\t\t\t} else if (bundle_type == 0xFF) { \n\t\t\t\toff += 2;\n\t\t\t\tut8 segnum = *(bin->entry_table + off);\n\t\t\t\toff++;\n\t\t\t\tut16 segoff = *(ut16 *)(bin->entry_table + off);\n\t\t\t\tentry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff;\n\t\t\t} else { \n\t\t\t\tentry->paddr = (ut64)bin->segment_entries[bundle_type - 1].offset * bin->alignment + *(ut16 *)(bin->entry_table + off);\n\t\t\t}\n\t\t\toff += 2;\n\t\t\tr_list_append (entries, entry);\n\t\t}\n\t}\n\tr_list_free (segments);\n\tbin->entries = entries;\n\treturn entries;\n}", "target": 1}
{"code": "bool ItemStackMetadata::setString(const std::string &name, const std::string &var)\n{\n\tbool result = Metadata::setString(name, var);\n\tif (name == TOOLCAP_KEY)\n\t\tupdateToolCapabilities();\n\treturn result;\n}", "target": 1}
{"code": "CopyKeyAliasesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)\n{\n    AliasInfo *alias;\n    unsigned i, num_key_aliases;\n    struct xkb_key_alias *key_aliases;\n    num_key_aliases = 0;\n    darray_foreach(alias, info->aliases) {\n        if (!XkbKeyByName(keymap, alias->real, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to alias %s to non-existent key %s; Ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n        if (XkbKeyByName(keymap, alias->alias, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to create alias with the name of a real key; \"\n                    \"Alias \\\"%s = %s\\\" ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n        num_key_aliases++;\n    }\n    key_aliases = NULL;\n    if (num_key_aliases > 0) {\n         key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));\n         if (!key_aliases)\n             return false;\n    }\n    i = 0;\n    darray_foreach(alias, info->aliases) {\n        if (alias->real != XKB_ATOM_NONE) {\n            key_aliases[i].alias = alias->alias;\n            key_aliases[i].real = alias->real;\n            i++;\n         }\n     }\n    keymap->num_key_aliases = num_key_aliases;\n    keymap->key_aliases = key_aliases;\n    return true;\n}", "target": 1}
{"code": "static struct inet_frag_queue *inet_frag_intern(struct netns_frags *nf,\n\t\tstruct inet_frag_queue *qp_in, struct inet_frags *f,\n\t\tvoid *arg)\n{\n\tstruct inet_frag_bucket *hb;\n\tstruct inet_frag_queue *qp;\n\tunsigned int hash;\n\tread_lock(&f->lock); \n\thash = f->hashfn(qp_in);\n\thb = &f->hash[hash];\n\tspin_lock(&hb->chain_lock);\n#ifdef CONFIG_SMP\n\thlist_for_each_entry(qp, &hb->chain, list) {\n\t\tif (qp->net == nf && f->match(qp, arg)) {\n\t\t\tatomic_inc(&qp->refcnt);\n\t\t\tspin_unlock(&hb->chain_lock);\n\t\t\tread_unlock(&f->lock);\n\t\t\tqp_in->last_in |= INET_FRAG_COMPLETE;\n\t\t\tinet_frag_put(qp_in, f);\n\t\t\treturn qp;\n\t\t}\n\t}\n#endif\n\tqp = qp_in;\n\tif (!mod_timer(&qp->timer, jiffies + nf->timeout))\n\t\tatomic_inc(&qp->refcnt);\n\tatomic_inc(&qp->refcnt);\n\thlist_add_head(&qp->list, &hb->chain);\n\tspin_unlock(&hb->chain_lock);\n\tread_unlock(&f->lock);\n\tinet_frag_lru_add(nf, qp);\n\treturn qp;\n}", "target": 1}
{"code": "int ip_check_mc_rcu(struct in_device *in_dev, __be32 mc_addr, __be32 src_addr, u8 proto)\n{\n\tstruct ip_mc_list *im;\n\tstruct ip_mc_list __rcu **mc_hash;\n\tstruct ip_sf_list *psf;\n\tint rv = 0;\n\tmc_hash = rcu_dereference(in_dev->mc_hash);\n\tif (mc_hash) {\n\t\tu32 hash = hash_32((__force u32)mc_addr, MC_HASH_SZ_LOG);\n\t\tfor (im = rcu_dereference(mc_hash[hash]);\n\t\t     im != NULL;\n\t\t     im = rcu_dereference(im->next_hash)) {\n\t\t\tif (im->multiaddr == mc_addr)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tfor_each_pmc_rcu(in_dev, im) {\n\t\t\tif (im->multiaddr == mc_addr)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (im && proto == IPPROTO_IGMP) {\n\t\trv = 1;\n\t} else if (im) {\n\t\tif (src_addr) {\n\t\t\tfor (psf = im->sources; psf; psf = psf->sf_next) {\n\t\t\t\tif (psf->sf_inaddr == src_addr)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (psf)\n\t\t\t\trv = psf->sf_count[MCAST_INCLUDE] ||\n\t\t\t\t\tpsf->sf_count[MCAST_EXCLUDE] !=\n\t\t\t\t\tim->sfcount[MCAST_EXCLUDE];\n\t\t\telse\n\t\t\t\trv = im->sfcount[MCAST_EXCLUDE] != 0;\n\t\t} else\n\t\t\trv = 1; \n\t}\n\treturn rv;\n}", "target": 1}
{"code": "static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,\n \t\t\t\t    struct net_device *ndev)\n {\n \tstruct hns_nic_priv *priv = netdev_priv(ndev);\n\tint ret;\n \tassert(skb->queue_mapping < ndev->ae_handle->q_num);\n\tret = hns_nic_net_xmit_hw(ndev, skb,\n\t\t\t\t  &tx_ring_data(priv, skb->queue_mapping));\n\tif (ret == NETDEV_TX_OK) {\n\t\tnetif_trans_update(ndev);\n\t\tndev->stats.tx_bytes += skb->len;\n\t\tndev->stats.tx_packets++;\n\t}\n\treturn (netdev_tx_t)ret;\n }", "target": 1}
{"code": "int htc_connect_service(struct htc_target *target,\n\t\t     struct htc_service_connreq *service_connreq,\n\t\t     enum htc_endpoint_id *conn_rsp_epid)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_endpoint *endpoint;\n\tstruct htc_conn_svc_msg *conn_msg;\n\tint ret;\n\tunsigned long time_left;\n\tendpoint = get_next_avail_ep(target->endpoint);\n\tif (!endpoint) {\n\t\tdev_err(target->dev, \"Endpoint is not available for service %d\\n\",\n\t\t\tservice_connreq->service_id);\n\t\treturn -EINVAL;\n\t}\n\tendpoint->service_id = service_connreq->service_id;\n\tendpoint->max_txqdepth = service_connreq->max_send_qdepth;\n\tendpoint->ul_pipeid = service_to_ulpipe(service_connreq->service_id);\n\tendpoint->dl_pipeid = service_to_dlpipe(service_connreq->service_id);\n\tendpoint->ep_callbacks = service_connreq->ep_callbacks;\n\tskb = alloc_skb(sizeof(struct htc_conn_svc_msg) +\n\t\t\t    sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"Failed to allocate buf to send\"\n\t\t\t\"service connect req\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\tconn_msg = skb_put(skb, sizeof(struct htc_conn_svc_msg));\n\tconn_msg->service_id = cpu_to_be16(service_connreq->service_id);\n\tconn_msg->msg_id = cpu_to_be16(HTC_MSG_CONNECT_SERVICE_ID);\n\tconn_msg->con_flags = cpu_to_be16(service_connreq->con_flags);\n\tconn_msg->dl_pipeid = endpoint->dl_pipeid;\n\tconn_msg->ul_pipeid = endpoint->ul_pipeid;\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"Service connection timeout for: %d\\n\",\n\t\t\tservice_connreq->service_id);\n\t\treturn -ETIMEDOUT;\n\t}\n\t*conn_rsp_epid = target->conn_rsp_epid;\n\treturn 0;\nerr:\n\tkfree_skb(skb);\n\treturn ret;\n}", "target": 1}
{"code": "  cff_charset_load( CFF_Charset  charset,\n                    FT_UInt      num_glyphs,\n                    FT_Stream    stream,\n                    FT_ULong     base_offset,\n                    FT_ULong     offset,\n                    FT_Bool      invert )\n  {\n    FT_Memory  memory = stream->memory;\n    FT_Error   error  = CFF_Err_Ok;\n    FT_UShort  glyph_sid;\n    if ( offset > 2 )\n    {\n      FT_UInt  j;\n      charset->offset = base_offset + offset;\n      if ( FT_STREAM_SEEK( charset->offset ) ||\n           FT_READ_BYTE( charset->format )   )\n        goto Exit;\n      if ( FT_NEW_ARRAY( charset->sids, num_glyphs ) )\n        goto Exit;\n      charset->sids[0] = 0;\n      switch ( charset->format )\n      {\n      case 0:\n        if ( num_glyphs > 0 )\n        {\n          if ( FT_FRAME_ENTER( ( num_glyphs - 1 ) * 2 ) )\n             goto Exit;\n           for ( j = 1; j < num_glyphs; j++ )\n            charset->sids[j] = FT_GET_USHORT();\n           FT_FRAME_EXIT();\n         }\n            if ( FT_READ_USHORT( glyph_sid ) )\n              goto Exit;\n            if ( charset->format == 2 )\n            {\n              if ( FT_READ_USHORT( nleft ) )\n                goto Exit;\n            }\n            else\n            {\n              if ( FT_READ_BYTE( nleft ) )\n                goto Exit;\n            }\n            for ( i = 0; j < num_glyphs && i <= nleft; i++, j++, glyph_sid++ )\n              charset->sids[j] = glyph_sid;\n          }\n        }\n        break;\n      default:\n        FT_ERROR(( \"cff_charset_load: invalid table format!\\n\" ));\n        error = CFF_Err_Invalid_File_Format;\n                 goto Exit;\n             }", "target": 1}
{"code": "archive_read_format_zip_cleanup(struct archive_read *a)\n{\n\tstruct zip *zip;\n\tstruct zip_entry *zip_entry, *next_zip_entry;\n\tzip = (struct zip *)(a->format->data);\n#ifdef HAVE_ZLIB_H\n\tif (zip->stream_valid)\n \t\tinflateEnd(&zip->stream);\n #endif\n#if HAVA_LZMA_H && HAVE_LIBLZMA\n     if (zip->zipx_lzma_valid) {\n \t\tlzma_end(&zip->zipx_lzma_stream);\n \t}\n#endif\n#ifdef HAVE_BZLIB_H\n\tif (zip->bzstream_valid) {\n\t\tBZ2_bzDecompressEnd(&zip->bzstream);\n\t}\n#endif\n\tfree(zip->uncompressed_buffer);\n\tif (zip->ppmd8_valid)\n\t\t__archive_ppmd8_functions.Ppmd8_Free(&zip->ppmd8);\n\tif (zip->zip_entries) {\n\t\tzip_entry = zip->zip_entries;\n\t\twhile (zip_entry != NULL) {\n\t\t\tnext_zip_entry = zip_entry->next;\n\t\t\tarchive_string_free(&zip_entry->rsrcname);\n\t\t\tfree(zip_entry);\n\t\t\tzip_entry = next_zip_entry;\n\t\t}\n\t}\n\tfree(zip->decrypted_buffer);\n\tif (zip->cctx_valid)\n\t\tarchive_decrypto_aes_ctr_release(&zip->cctx);\n\tif (zip->hctx_valid)\n\t\tarchive_hmac_sha1_cleanup(&zip->hctx);\n\tfree(zip->iv);\n\tfree(zip->erd);\n\tfree(zip->v_data);\n\tarchive_string_free(&zip->format_name);\n\tfree(zip);\n\t(a->format->data) = NULL;\n\treturn (ARCHIVE_OK);\n}", "target": 1}
{"code": "xsltCompileLocationPathPattern(xsltParserContextPtr ctxt, int novar) {\n    SKIP_BLANKS;\n    if ((CUR == '/') && (NXT(1) == '/')) {\n\tNEXT;\n\tNEXT;\n\tctxt->comp->priority = 0.5;\t\n\txsltCompileRelativePathPattern(ctxt, NULL, novar);\n    } else if (CUR == '/') {\n\tNEXT;\n\tSKIP_BLANKS;\n\tPUSH(XSLT_OP_ROOT, NULL, NULL, novar);\n\tif ((CUR != 0) && (CUR != '|')) {\n\t    PUSH(XSLT_OP_PARENT, NULL, NULL, novar);\n\t    xsltCompileRelativePathPattern(ctxt, NULL, novar);\n\t}\n    } else if (CUR == '*') {\n\txsltCompileRelativePathPattern(ctxt, NULL, novar);\n    } else if (CUR == '@') {\n\txsltCompileRelativePathPattern(ctxt, NULL, novar);\n    } else {\n\txmlChar *name;\n\tname = xsltScanNCName(ctxt);\n\tif (name == NULL) {\n\t    xsltTransformError(NULL, NULL, NULL,\n\t\t    \"xsltCompileLocationPathPattern : Name expected\\n\");\n\t    ctxt->error = 1;\n\t    return;\n\t}\n \tSKIP_BLANKS;\n \tif ((CUR == '(') && !xmlXPathIsNodeType(name)) {\n \t    xsltCompileIdKeyPattern(ctxt, name, 1, novar, 0);\n \t    if ((CUR == '/') && (NXT(1) == '/')) {\n \t\tPUSH(XSLT_OP_ANCESTOR, NULL, NULL, novar);\n \t\tNEXT;\n\t\tNEXT;\n\t\tSKIP_BLANKS;\n\t\txsltCompileRelativePathPattern(ctxt, NULL, novar);\n\t    } else if (CUR == '/') {\n\t\tPUSH(XSLT_OP_PARENT, NULL, NULL, novar);\n\t\tNEXT;\n\t\tSKIP_BLANKS;\n\t\txsltCompileRelativePathPattern(ctxt, NULL, novar);\n\t    }\n\t    return;\n\t}\n\txsltCompileRelativePathPattern(ctxt, name, novar);\n    }\nerror:\n    return;\n}", "target": 1}
{"code": "  Status BuildFeatureReaders(const OpInputList& ragged_values_list,\n                             const OpInputList& ragged_splits_list,\n                             const OpInputList& sparse_indices_list,\n                             const OpInputList& sparse_values_list,\n                             const OpInputList& dense_list, int64 batch_size,\n                             FeatureReaders* features) {\n    features->reserve(input_order_.size());\n    int next_ragged = 0;\n    int next_sparse = 0;\n    int next_dense = 0;\n    for (char c : input_order_) {\n      if (c == 'R') {\n        TF_RETURN_IF_ERROR(BuildRaggedFeatureReader(\n            ragged_values_list[next_ragged], ragged_splits_list[next_ragged],\n            features));\n        next_ragged++;\n      } else if (c == 'S') {\n        TF_RETURN_IF_ERROR(BuildSparseFeatureReader(\n            sparse_indices_list[next_sparse], sparse_values_list[next_sparse],\n            batch_size, features));\n        next_sparse++;\n      } else if (c == 'D') {\n        TF_RETURN_IF_ERROR(\n            BuildDenseFeatureReader(dense_list[next_dense++], features));\n      } else {\n        return errors::InvalidArgument(\"Unexpected input_order value.\");\n      }\n    }\n    return Status::OK();\n  }", "target": 1}
{"code": "str2special(\n    char_u\t**sp,\n    int\t\tfrom)\t\n{\n    int\t\t\tc;\n    static char_u\tbuf[7];\n    char_u\t\t*str = *sp;\n    int\t\t\tmodifiers = 0;\n    int\t\t\tspecial = FALSE;\n    if (has_mbyte)\n    {\n\tchar_u\t*p;\n\tp = mb_unescape(sp);\n\tif (p != NULL)\n\t    return p;\n    }\n    c = *str;\n    if (c == K_SPECIAL && str[1] != NUL && str[2] != NUL)\n    {\n\tif (str[1] == KS_MODIFIER)\n\t{\n\t    modifiers = str[2];\n\t    str += 3;\n\t    c = *str;\n\t}\n\tif (c == K_SPECIAL && str[1] != NUL && str[2] != NUL)\n\t{\n\t    c = TO_SPECIAL(str[1], str[2]);\n\t    str += 2;\n\t}\n\tif (IS_SPECIAL(c) || modifiers)\t\n\t    special = TRUE;\n    }\n    if (has_mbyte && !IS_SPECIAL(c) && MB_BYTE2LEN(c) > 1)\n    {\n\tchar_u\t*p;\n\t*sp = str;\n\tp = mb_unescape(sp);\n\tif (p != NULL)\n\t    c = (*mb_ptr2char)(p);\n\telse\n\t    *sp = str + 1;\n    }\n    else\n\t*sp = str + 1;\n    if (special || c < ' ' || (from && c == ' '))\n\treturn get_special_key_name(c, modifiers);\n    buf[0] = c;\n    buf[1] = NUL;\n    return buf;\n}", "target": 1}
{"code": "static void virtqueue_map_desc(unsigned int *p_num_sg, hwaddr *addr, struct iovec *iov,\n                               unsigned int max_num_sg, bool is_write,\n                               hwaddr pa, size_t sz)\n{\n    unsigned num_sg = *p_num_sg;\n    assert(num_sg <= max_num_sg);\n    while (sz) {\n        hwaddr len = sz;\n        if (num_sg == max_num_sg) {\n            error_report(\"virtio: too many write descriptors in indirect table\");\n            exit(1);\n        }\n        iov[num_sg].iov_base = cpu_physical_memory_map(pa, &len, is_write);\n        iov[num_sg].iov_len = len;\n        addr[num_sg] = pa;\n        sz -= len;\n        pa += len;\n        num_sg++;\n    }\n    *p_num_sg = num_sg;\n}", "target": 1}
{"code": "static int key_notify_policy_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb_out;\n\tstruct sadb_msg *hdr;\n\tskb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb_out)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb_out, sizeof(struct sadb_msg));\n\thdr->sadb_msg_type = SADB_X_SPDFLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n \thdr->sadb_msg_errno = (uint8_t) 0;\n \thdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;\n \thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n \tpfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n \treturn 0;\n}", "target": 1}
{"code": "static BOOL rdp_read_font_capability_set(wStream* s, UINT16 length, rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (length > 4)\n\t\tStream_Seek_UINT16(s); \n\tif (length > 6)\n\t\tStream_Seek_UINT16(s); \n\treturn TRUE;\n}", "target": 1}
{"code": "int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl,\n                      const unsigned char *in, int inl)\n{\n    int i, j, bl;\n    if (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER) {\n        i = ctx->cipher->do_cipher(ctx, out, in, inl);\n        if (i < 0)\n            return 0;\n        else\n            *outl = i;\n        return 1;\n    }\n    if (inl <= 0) {\n        *outl = 0;\n        return inl == 0;\n    }\n    if (ctx->buf_len == 0 && (inl & (ctx->block_mask)) == 0) {\n        if (ctx->cipher->do_cipher(ctx, out, in, inl)) {\n            *outl = inl;\n            return 1;\n        } else {\n            *outl = 0;\n            return 0;\n        }\n    }\n    i = ctx->buf_len;\n     bl = ctx->cipher->block_size;\n     OPENSSL_assert(bl <= (int)sizeof(ctx->buf));\n     if (i != 0) {\n        if (i + inl < bl) {\n             memcpy(&(ctx->buf[i]), in, inl);\n             ctx->buf_len += inl;\n             *outl = 0;\n            return 1;\n        } else {\n            j = bl - i;\n            memcpy(&(ctx->buf[i]), in, j);\n            if (!ctx->cipher->do_cipher(ctx, out, ctx->buf, bl))\n                return 0;\n            inl -= j;\n            in += j;\n            out += bl;\n            *outl = bl;\n        }\n    } else\n        *outl = 0;\n    i = inl & (bl - 1);\n    inl -= i;\n    if (inl > 0) {\n        if (!ctx->cipher->do_cipher(ctx, out, in, inl))\n            return 0;\n        *outl += inl;\n    }\n    if (i != 0)\n        memcpy(ctx->buf, &(in[inl]), i);\n    ctx->buf_len = i;\n    return 1;\n}", "target": 1}
{"code": "ngx_http_send_error_page(ngx_http_request_t *r, ngx_http_err_page_t *err_page)\n{\n    ngx_int_t                  overwrite;\n    ngx_str_t                  uri, args;\n    ngx_table_elt_t           *location;\n    ngx_http_core_loc_conf_t  *clcf;\n    overwrite = err_page->overwrite;\n    if (overwrite && overwrite != NGX_HTTP_OK) {\n        r->expect_tested = 1;\n    }\n    if (overwrite >= 0) {\n        r->err_status = overwrite;\n    }\n    if (ngx_http_complex_value(r, &err_page->value, &uri) != NGX_OK) {\n        return NGX_ERROR;\n    }\n    if (uri.len && uri.data[0] == '/') {\n        if (err_page->value.lengths) {\n            ngx_http_split_args(r, &uri, &args);\n        } else {\n            args = err_page->args;\n        }\n        if (r->method != NGX_HTTP_HEAD) {\n            r->method = NGX_HTTP_GET;\n            r->method_name = ngx_http_core_get_method;\n        }\n        return ngx_http_internal_redirect(r, &uri, &args);\n    }\n    if (uri.len && uri.data[0] == '@') {\n        return ngx_http_named_location(r, &uri);\n    }\n    location = ngx_list_push(&r->headers_out.headers);\n    if (location == NULL) {\n        return NGX_ERROR;\n    }\n    if (overwrite != NGX_HTTP_MOVED_PERMANENTLY\n        && overwrite != NGX_HTTP_MOVED_TEMPORARILY\n        && overwrite != NGX_HTTP_SEE_OTHER\n        && overwrite != NGX_HTTP_TEMPORARY_REDIRECT\n        && overwrite != NGX_HTTP_PERMANENT_REDIRECT)\n    {\n        r->err_status = NGX_HTTP_MOVED_TEMPORARILY;\n    }\n    location->hash = 1;\n    ngx_str_set(&location->key, \"Location\");\n    location->value = uri;\n    ngx_http_clear_location(r);\n    r->headers_out.location = location;\n    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n    if (clcf->msie_refresh && r->headers_in.msie) {\n        return ngx_http_send_refresh(r);\n    }\n    return ngx_http_send_special_response(r, clcf, r->err_status\n                                                   - NGX_HTTP_MOVED_PERMANENTLY\n                                                   + NGX_HTTP_OFF_3XX);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    ReshapeSparseTensor<Device>(context, context->input(0), context->input(1),\n                                context->input(2), 0 ,\n                                1 );\n  }", "target": 1}
{"code": "void *UntrustedCacheMalloc::GetBuffer() {\n  void **buffers = nullptr;\n  void *buffer;\n  bool is_pool_empty;\n  {\n    LockGuard spin_lock(&lock_);\n    is_pool_empty = buffer_pool_.empty();\n    if (is_pool_empty) {\n      buffers =\n          primitives::AllocateUntrustedBuffers(kPoolIncrement, kPoolEntrySize);\n      for (int i = 0; i < kPoolIncrement; i++) {\n        if (!buffers[i] ||\n            !TrustedPrimitives::IsOutsideEnclave(buffers[i], kPoolEntrySize)) {\n          abort();\n        }\n        buffer_pool_.push(buffers[i]);\n      }\n    }\n    buffer = buffer_pool_.top();\n    buffer_pool_.pop();\n    busy_buffers_.insert(buffer);\n  }\n  if (is_pool_empty) {\n    Free(buffers);\n  }\n  return buffer;\n}", "target": 1}
{"code": "  cid_parse_font_matrix( CID_Face     face,\n                         CID_Parser*  parser )\n  {\n    CID_FaceDict  dict;\n    FT_Face       root = (FT_Face)&face->root;\n    FT_Fixed      temp[6];\n    FT_Fixed      temp_scale;\n    if ( parser->num_dict >= 0 && parser->num_dict < face->cid.num_dicts )\n     {\n       FT_Matrix*  matrix;\n       FT_Vector*  offset;\n       dict   = face->cid.font_dicts + parser->num_dict;\n       matrix = &dict->font_matrix;\n       offset = &dict->font_offset;\n      (void)cid_parser_to_fixed_array( parser, 6, temp, 3 );\n       temp_scale = FT_ABS( temp[3] );\n        temp[5] = FT_DivFix( temp[5], temp_scale );\n        temp[3] = 0x10000L;\n      }\n      matrix->xx = temp[0];\n      matrix->yx = temp[1];\n      matrix->xy = temp[2];\n      matrix->yy = temp[3];\n         temp[2] = FT_DivFix( temp[2], temp_scale );\n         temp[4] = FT_DivFix( temp[4], temp_scale );\n         temp[5] = FT_DivFix( temp[5], temp_scale );\n        temp[3] = 0x10000L;\n       }", "target": 1}
{"code": "void fli_read_brun(FILE *f, s_fli_header *fli_header, unsigned char *framebuf)\n{\n\tunsigned short yc;\n\tunsigned char *pos;\n\tfor (yc=0; yc < fli_header->height; yc++) {\n\t\tunsigned short xc, pc, pcnt;\n\t\tpc=fli_read_char(f);\n\t\txc=0;\n\t\tpos=framebuf+(fli_header->width * yc);\n\t\tfor (pcnt=pc; pcnt>0; pcnt--) {\n\t\t\tunsigned short ps;\n\t\t\tps=fli_read_char(f);\n\t\t\tif (ps & 0x80) {\n\t\t\t\tunsigned short len;\n\t\t\t\tfor (len=-(signed char)ps; len>0; len--) {\n\t\t\t\t\tpos[xc++]=fli_read_char(f);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tunsigned char val;\n\t\t\t\tval=fli_read_char(f);\n\t\t\t\tmemset(&(pos[xc]), val, ps);\n\t\t\t\txc+=ps;\n\t\t\t}\n\t\t}\n\t}\n}", "target": 1}
{"code": "static int l2tp_ip6_recvmsg(struct kiocb *iocb, struct sock *sk,\n\t\t\t    struct msghdr *msg, size_t len, int noblock,\n\t\t\t    int flags, int *addr_len)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *)msg->msg_name;\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tstruct sk_buff *skb;\n\tif (flags & MSG_OOB)\n\t\tgoto out;\n\tif (addr_len)\n\t\t*addr_len = sizeof(*lsa);\n\tif (flags & MSG_ERRQUEUE)\n\t\treturn ipv6_recv_error(sk, msg, len);\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto done;\n\tsock_recv_timestamp(msg, sk, skb);\n\tif (lsa) {\n\t\tlsa->l2tp_family = AF_INET6;\n\t\tlsa->l2tp_unused = 0;\n \t\tlsa->l2tp_addr = ipv6_hdr(skb)->saddr;\n \t\tlsa->l2tp_flowinfo = 0;\n \t\tlsa->l2tp_scope_id = 0;\n \t\tif (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)\n \t\t\tlsa->l2tp_scope_id = IP6CB(skb)->iif;\n \t}\n\tif (np->rxopt.all)\n\t\tip6_datagram_recv_ctl(sk, msg, skb);\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err ? err : copied;\n}", "target": 1}
{"code": "BOOL glyph_cache_put(rdpGlyphCache* glyphCache, UINT32 id, UINT32 index, rdpGlyph* glyph)\n{\n\trdpGlyph* prevGlyph;\n\tif (id > 9)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache id: %\" PRIu32 \"\", id);\n\t\treturn FALSE;\n\t}\n\tif (index > glyphCache->glyphCache[id].number)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache index: %\" PRIu32 \" in cache id: %\" PRIu32 \"\", index, id);\n\t\treturn FALSE;\n\t}\n\tWLog_Print(glyphCache->log, WLOG_DEBUG, \"GlyphCachePut: id: %\" PRIu32 \" index: %\" PRIu32 \"\", id,\n\t           index);\n\tprevGlyph = glyphCache->glyphCache[id].entries[index];\n\tif (prevGlyph)\n\t\tprevGlyph->Free(glyphCache->context, prevGlyph);\n\tglyphCache->glyphCache[id].entries[index] = glyph;\n\treturn TRUE;\n}", "target": 1}
{"code": "   void FocusFirstNameField() {\n     LOG(WARNING) << \"Clicking on the tab.\";\n    ASSERT_NO_FATAL_FAILURE(ui_test_utils::ClickOnView(browser(),\n                                                       VIEW_ID_TAB_CONTAINER));\n    ASSERT_TRUE(ui_test_utils::IsViewFocused(browser(),\n                                             VIEW_ID_TAB_CONTAINER));\n     LOG(WARNING) << \"Focusing the first name field.\";\n     bool result = false;\n    ASSERT_TRUE(ui_test_utils::ExecuteJavaScriptAndExtractBool(\n        render_view_host(), L\"\",\n        L\"if (document.readyState === 'complete')\"\n        L\"  document.getElementById('firstname').focus();\"\n        L\"else\"\n        L\"  domAutomationController.send(false);\",\n        &result));\n    ASSERT_TRUE(result);\n  }", "target": 1}
{"code": "void UncompressElementOp::Compute(OpKernelContext* ctx) {\n  Tensor tensor = ctx->input(0);\n  const Variant& variant = tensor.scalar<Variant>()();\n  const CompressedElement* compressed = variant.get<CompressedElement>();\n  std::vector<Tensor> components;\n  OP_REQUIRES_OK(ctx, UncompressElement(*compressed, &components));\n  OP_REQUIRES(ctx, components.size() == output_types_.size(),\n              errors::FailedPrecondition(\"Expected \", output_types_.size(),\n                                         \" outputs from uncompress, but got \",\n                                         components.size()));\n  for (int i = 0; i < components.size(); ++i) {\n    OP_REQUIRES(\n        ctx, components[i].dtype() == output_types_[i],\n        errors::FailedPrecondition(\"Expected a tensor of type \",\n                                   DataTypeString(output_types_[i]),\n                                   \" but got a tensor of type \",\n                                   DataTypeString(components[i].dtype())));\n    ctx->set_output(i, components[i]);\n  }\n}", "target": 1}
{"code": "static rsRetVal qAddDirect(qqueue_t *pThis, void* pUsr)\n{\n\tbatch_t singleBatch;\n\tbatch_obj_t batchObj;\n\tDEFiRet;\n\tASSERT(pThis != NULL);\n\tmemset(&batchObj, 0, sizeof(batch_obj_t));\n\tmemset(&singleBatch, 0, sizeof(batch_t));\n\tbatchObj.state = BATCH_STATE_RDY;\n\tbatchObj.pUsrp = (obj_t*) pUsr;\n\tbatchObj.bFilterOK = 1;\n\tsingleBatch.nElem = 1; \n\tsingleBatch.pElem = &batchObj;\n\tiRet = pThis->pConsumer(pThis->pUsr, &singleBatch, &pThis->bShutdownImmediate);\n\tobjDestruct(pUsr);\n\tRETiRet;\n}", "target": 1}
{"code": "lsquic_qeh_settings (struct qpack_enc_hdl *qeh, unsigned max_table_size,\n             unsigned dyn_table_size, unsigned max_risked_streams, int server)\n{\n    enum lsqpack_enc_opts enc_opts;\n    assert(qeh->qeh_flags & QEH_INITIALIZED);\n    if (qeh->qeh_flags & QEH_HAVE_SETTINGS)\n    {\n        LSQ_WARN(\"settings already set\");\n        return -1;\n    }\n    enc_opts = LSQPACK_ENC_OPT_STAGE_2\n             | (server ? LSQPACK_ENC_OPT_SERVER : 0);\n    qeh->qeh_tsu_sz = sizeof(qeh->qeh_tsu_buf);\n    if (0 != lsqpack_enc_init(&qeh->qeh_encoder, (void *) qeh->qeh_conn,\n                max_table_size, dyn_table_size, max_risked_streams, enc_opts,\n                qeh->qeh_tsu_buf, &qeh->qeh_tsu_sz))\n    {\n        LSQ_INFO(\"could not initialize QPACK encoder\");\n        return -1;\n    }\n    LSQ_DEBUG(\"%zu-byte post-init TSU\", qeh->qeh_tsu_sz);\n    qeh->qeh_flags |= QEH_HAVE_SETTINGS;\n    qeh->qeh_max_prefix_size =\n                        lsqpack_enc_header_block_prefix_size(&qeh->qeh_encoder);\n    LSQ_DEBUG(\"have settings: max table size=%u; dyn table size=%u; max risked \"\n        \"streams=%u\", max_table_size, dyn_table_size, max_risked_streams);\n    if (qeh->qeh_enc_sm_out)\n        qeh_begin_out(qeh);\n    return 0;\n}", "target": 1}
{"code": "static void virtio_blk_handle_read(VirtIOBlockReq *req)\n{\n    BlockDriverAIOCB *acb;\n    uint64_t sector;\n    sector = ldq_p(&req->out->sector);\n    if (sector & req->dev->sector_mask) {\n        virtio_blk_rw_complete(req, -EIO);\n        return;\n    }\n    acb = bdrv_aio_readv(req->dev->bs, sector, &req->qiov,\n                         req->qiov.size / BDRV_SECTOR_SIZE,\n                         virtio_blk_rw_complete, req);\n    if (!acb) {\n        virtio_blk_rw_complete(req, -EIO);\n    }\n}", "target": 1}
{"code": "static void interface_release_resource(QXLInstance *sin,\n                                       QXLReleaseInfoExt ext)\n{\n    PCIQXLDevice *qxl = container_of(sin, PCIQXLDevice, ssd.qxl);\n    QXLReleaseRing *ring;\n    uint64_t *item, id;\n    if (ext.group_id == MEMSLOT_GROUP_HOST) {\n        QXLCommandExt *cmdext = (void *)(intptr_t)(ext.info->id);\n        SimpleSpiceUpdate *update;\n        g_assert(cmdext->cmd.type == QXL_CMD_DRAW);\n        update = container_of(cmdext, SimpleSpiceUpdate, ext);\n        qemu_spice_destroy_update(&qxl->ssd, update);\n        return;\n    }\n    ring = &qxl->ram->release_ring;\n    SPICE_RING_PROD_ITEM(qxl, ring, item);\n    if (!item) {\n        return;\n    }\n    if (*item == 0) {\n        id = ext.info->id;\n        ext.info->next = 0;\n        qxl_ram_set_dirty(qxl, &ext.info->next);\n        *item = id;\n        qxl_ring_set_dirty(qxl);\n    } else {\n        qxl->last_release->next = ext.info->id;\n        qxl_ram_set_dirty(qxl, &qxl->last_release->next);\n        ext.info->next = 0;\n        qxl_ram_set_dirty(qxl, &ext.info->next);\n    }\n    qxl->last_release = ext.info;\n    qxl->num_free_res++;\n    trace_qxl_ring_res_put(qxl->id, qxl->num_free_res);\n    qxl_push_free_res(qxl, 0);\n}", "target": 1}
{"code": "op_format(\n    oparg_T\t*oap,\n    int\t\tkeep_cursor)\t\t\n{\n    long\told_line_count = curbuf->b_ml.ml_line_count;\n    curwin->w_cursor = oap->cursor_start;\n    if (u_save((linenr_T)(oap->start.lnum - 1),\n\t\t\t\t       (linenr_T)(oap->end.lnum + 1)) == FAIL)\n\treturn;\n    curwin->w_cursor = oap->start;\n    if (oap->is_VIsual)\n\tredraw_curbuf_later(INVERTED);\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\tcurbuf->b_op_start = oap->start;\n    if (keep_cursor)\n\tsaved_cursor = oap->cursor_start;\n    format_lines(oap->line_count, keep_cursor);\n    if (oap->end_adjusted && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t++curwin->w_cursor.lnum;\n    beginline(BL_WHITE | BL_FIX);\n    old_line_count = curbuf->b_ml.ml_line_count - old_line_count;\n    msgmore(old_line_count);\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n\tcurbuf->b_op_end = curwin->w_cursor;\n    if (keep_cursor)\n    {\n\tcurwin->w_cursor = saved_cursor;\n\tsaved_cursor.lnum = 0;\n    }\n    if (oap->is_VIsual)\n    {\n\twin_T\t*wp;\n\tFOR_ALL_WINDOWS(wp)\n\t{\n\t    if (wp->w_old_cursor_lnum != 0)\n\t    {\n\t\tif (wp->w_old_cursor_lnum > wp->w_old_visual_lnum)\n\t\t    wp->w_old_cursor_lnum += old_line_count;\n\t\telse\n\t\t    wp->w_old_visual_lnum += old_line_count;\n\t    }\n\t}\n    }\n}", "target": 1}
{"code": "static int tca_action_flush(struct rtattr *rta, struct nlmsghdr *n, u32 pid)\n{\n\tstruct sk_buff *skb;\n\tunsigned char *b;\n\tstruct nlmsghdr *nlh;\n\tstruct tcamsg *t;\n\tstruct netlink_callback dcb;\n\tstruct rtattr *x;\n\tstruct rtattr *tb[TCA_ACT_MAX+1];\n\tstruct rtattr *kind;\n\tstruct tc_action *a = create_a(0);\n\tint err = -EINVAL;\n\tif (a == NULL) {\n\t\tprintk(\"tca_action_flush: couldnt create tc_action\\n\");\n\t\treturn err;\n\t}\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb) {\n\t\tprintk(\"tca_action_flush: failed skb alloc\\n\");\n\t\tkfree(a);\n\t\treturn -ENOBUFS;\n\t}\n\tb = (unsigned char *)skb->tail;\n\tif (rtattr_parse_nested(tb, TCA_ACT_MAX, rta) < 0)\n\t\tgoto err_out;\n\tkind = tb[TCA_ACT_KIND-1];\n\ta->ops = tc_lookup_action(kind);\n\tif (a->ops == NULL)\n\t\tgoto err_out;\n\tnlh = NLMSG_PUT(skb, pid, n->nlmsg_seq, RTM_DELACTION, sizeof(*t));\n\tt = NLMSG_DATA(nlh);\n\tt->tca_family = AF_UNSPEC;\n\tx = (struct rtattr *) skb->tail;\n\tRTA_PUT(skb, TCA_ACT_TAB, 0, NULL);\n\terr = a->ops->walk(skb, &dcb, RTM_DELACTION, a);\n\tif (err < 0)\n\t\tgoto rtattr_failure;\n\tx->rta_len = skb->tail - (u8 *) x;\n\tnlh->nlmsg_len = skb->tail - b;\n\tnlh->nlmsg_flags |= NLM_F_ROOT;\n\tmodule_put(a->ops->owner);\n\tkfree(a);\n\terr = rtnetlink_send(skb, pid, RTMGRP_TC, n->nlmsg_flags&NLM_F_ECHO);\n\tif (err > 0)\n\t\treturn 0;\n\treturn err;\nrtattr_failure:\n\tmodule_put(a->ops->owner);\nnlmsg_failure:\nerr_out:\n\tkfree_skb(skb);\n\tkfree(a);\n\treturn err;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    OpInputList ragged_nested_splits_in;\n    OP_REQUIRES_OK(context, context->input_list(\"rt_nested_splits\",\n                                                &ragged_nested_splits_in));\n    const int ragged_nested_splits_len = ragged_nested_splits_in.size();\n    RaggedTensorVariant batched_ragged_input;\n    batched_ragged_input.set_values(context->input(ragged_nested_splits_len));\n    batched_ragged_input.mutable_nested_splits()->reserve(\n        ragged_nested_splits_len);\n    for (int i = 0; i < ragged_nested_splits_len; i++) {\n      batched_ragged_input.append_splits(ragged_nested_splits_in[i]);\n    }\n    if (!batched_input_) {\n      Tensor* encoded_scalar;\n      OP_REQUIRES_OK(context, context->allocate_output(0, TensorShape({}),\n                                                       &encoded_scalar));\n      encoded_scalar->scalar<Variant>()() = std::move(batched_ragged_input);\n      return;\n    }\n    std::vector<RaggedTensorVariant> unbatched_ragged_input;\n    OP_REQUIRES_OK(context, UnbatchRaggedZerothDim<VALUE_TYPE, SPLIT_TYPE>(\n                                batched_ragged_input, &unbatched_ragged_input));\n    Tensor* encoded_vector;\n    int output_size = unbatched_ragged_input.size();\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, TensorShape({output_size}),\n                                            &encoded_vector));\n    auto encoded_vector_t = encoded_vector->vec<Variant>();\n    for (int i = 0; i < output_size; i++) {\n      encoded_vector_t(i) = unbatched_ragged_input[i];\n    }\n  }", "target": 1}
{"code": "static int tc_fill_tclass(struct sk_buff *skb, struct Qdisc *q,\n\t\t\t  unsigned long cl,\n\t\t\t  u32 pid, u32 seq, u16 flags, int event)\n{\n\tstruct tcmsg *tcm;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct gnet_dump d;\n\tconst struct Qdisc_class_ops *cl_ops = q->ops->cl_ops;\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*tcm), flags);\n\ttcm = NLMSG_DATA(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm_ifindex = qdisc_dev(q)->ifindex;\n\ttcm->tcm_parent = q->handle;\n\ttcm->tcm_handle = q->handle;\n\ttcm->tcm_info = 0;\n\tNLA_PUT_STRING(skb, TCA_KIND, q->ops->id);\n\tif (cl_ops->dump && cl_ops->dump(q, cl, skb, tcm) < 0)\n\t\tgoto nla_put_failure;\n\tif (gnet_stats_start_copy_compat(skb, TCA_STATS2, TCA_STATS, TCA_XSTATS,\n\t\t\t\t\t qdisc_root_sleeping_lock(q), &d) < 0)\n\t\tgoto nla_put_failure;\n\tif (cl_ops->dump_stats && cl_ops->dump_stats(q, cl, &d) < 0)\n\t\tgoto nla_put_failure;\n\tif (gnet_stats_finish_copy(&d) < 0)\n\t\tgoto nla_put_failure;\n\tnlh->nlmsg_len = skb_tail_pointer(skb) - b;\n\treturn skb->len;\nnlmsg_failure:\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -1;\n}", "target": 1}
{"code": "static void chase_port(struct edgeport_port *port, unsigned long timeout,\n\t\t\t\t\t\t\t\tint flush)\n{\n\tint baud_rate;\n\tstruct tty_struct *tty = tty_port_tty_get(&port->port->port);\n\tstruct usb_serial *serial = port->port->serial;\n \twait_queue_t wait;\n \tunsigned long flags;\n \tif (!timeout)\n \t\ttimeout = (HZ * EDGE_CLOSING_WAIT)/100;\n\tspin_lock_irqsave(&port->ep_lock, flags);\n\tinit_waitqueue_entry(&wait, current);\n\tadd_wait_queue(&tty->write_wait, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (kfifo_len(&port->write_fifo) == 0\n\t\t|| timeout == 0 || signal_pending(current)\n\t\t|| serial->disconnected)\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&port->ep_lock, flags);\n\t\ttimeout = schedule_timeout(timeout);\n\t\tspin_lock_irqsave(&port->ep_lock, flags);\n\t}\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&tty->write_wait, &wait);\n\tif (flush)\n\t\tkfifo_reset_out(&port->write_fifo);\n\tspin_unlock_irqrestore(&port->ep_lock, flags);\n\ttty_kref_put(tty);\n\ttimeout += jiffies;\n\twhile ((long)(jiffies - timeout) < 0 && !signal_pending(current)\n\t\t\t\t\t\t&& !serial->disconnected) {\n\t\tif (!tx_active(port))\n\t\t\tbreak;\n\t\tmsleep(10);\n\t}\n\tif (serial->disconnected)\n\t\treturn;\n\tbaud_rate = port->baud_rate;\n\tif (baud_rate == 0)\n\t\tbaud_rate = 50;\n\tmsleep(max(1, DIV_ROUND_UP(10000, baud_rate)));\n}", "target": 1}
{"code": "static struct btrfs_device *find_device(struct btrfs_fs_devices *fs_devices,\n\t\tu64 devid, const u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\tlist_for_each_entry(dev, &fs_devices->devices, dev_list) {\n\t\tif (dev->devid == devid &&\n\t\t    (!uuid || !memcmp(dev->uuid, uuid, BTRFS_UUID_SIZE))) {\n\t\t\treturn dev;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "validate_event(struct pmu_hw_events *hw_events,\n\t       struct perf_event *event)\n{\n \tstruct arm_pmu *armpmu = to_arm_pmu(event->pmu);\n \tstruct pmu *leader_pmu = event->group_leader->pmu;\n \tif (event->pmu != leader_pmu || event->state < PERF_EVENT_STATE_OFF)\n \t\treturn 1;\n\tif (event->state == PERF_EVENT_STATE_OFF && !event->attr.enable_on_exec)\n\t\treturn 1;\n\treturn armpmu->get_event_idx(hw_events, event) >= 0;\n}", "target": 1}
{"code": "static void nsc_rle_decode(BYTE* in, BYTE* out, UINT32 originalSize)\n {\n \tUINT32 len;\n \tUINT32 left;\n\tBYTE value;\n\tleft = originalSize;\n\twhile (left > 4)\n\t{\n\t\tvalue = *in++;\n \t\tif (left == 5)\n \t\t{\n \t\t\t*out++ = value;\n \t\t\tleft--;\n \t\t}\n\t\telse if (value == *in)\n\t\t{\n\t\t\tin++;\n\t\t\tif (*in < 0xFF)\n\t\t\t{\n\t\t\t\tlen = (UINT32) * in++;\n\t\t\t\tlen += 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tin++;\n\t\t\t\tlen = *((UINT32*) in);\n \t\t\t\tin += 4;\n \t\t\t}\n \t\t\tFillMemory(out, len, value);\n \t\t\tout += len;\n \t\t\tleft -= len;\n \t\t}\n \t\telse\n \t\t{\n \t\t\t*out++ = value;\n \t\t\tleft--;\n \t\t}\n \t}\n\t*((UINT32*)out) = *((UINT32*)in);\n }", "target": 1}
{"code": "int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,\n                   const char *dir) {\n  char offset[40] = \"\", name[200] = \"\", path[256];\n  mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));\n  mg_http_get_var(&hm->query, \"name\", name, sizeof(name));\n  if (name[0] == '\\0') {\n    mg_http_reply(c, 400, \"\", \"%s\", \"name required\");\n    return -1;\n  } else {\n    FILE *fp;\n    size_t oft = strtoul(offset, NULL, 0);\n    snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);\n    LOG(LL_DEBUG,\n        (\"%p %d bytes @ %d [%s]\", c->fd, (int) hm->body.len, (int) oft, name));\n    if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {\n      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", name, errno);\n      return -2;\n    } else {\n      fwrite(hm->body.ptr, 1, hm->body.len, fp);\n      fclose(fp);\n      mg_http_reply(c, 200, \"\", \"\");\n      return (int) hm->body.len;\n    }\n  }\n}", "target": 1}
{"code": "GF_Err cat_multiple_files(GF_ISOFile *dest, char *fileName, u32 import_flags, Double force_fps, u32 frames_per_sample, char *tmp_dir, Bool force_cat, Bool align_timelines, Bool allow_add_in_command)\n{\n\tCATEnum cat_enum;\n\tchar *sep;\n\tcat_enum.dest = dest;\n\tcat_enum.import_flags = import_flags;\n\tcat_enum.force_fps = force_fps;\n\tcat_enum.frames_per_sample = frames_per_sample;\n\tcat_enum.tmp_dir = tmp_dir;\n\tcat_enum.force_cat = force_cat;\n \tcat_enum.align_timelines = align_timelines;\n \tcat_enum.allow_add_in_command = allow_add_in_command;\n \tstrcpy(cat_enum.szPath, fileName);\n \tsep = strrchr(cat_enum.szPath, GF_PATH_SEPARATOR);\n \tif (!sep) sep = strrchr(cat_enum.szPath, '/');\n \tif (!sep) {\n \t\tstrcpy(cat_enum.szPath, \".\");\n \t\tstrcpy(cat_enum.szRad1, fileName);\n \t} else {\n \t\tstrcpy(cat_enum.szRad1, sep+1);\n \t\tsep[0] = 0;\n \t}\n \tsep = strchr(cat_enum.szRad1, '*');\n \tstrcpy(cat_enum.szRad2, sep+1);\n \tsep[0] = 0;\n \tsep = strchr(cat_enum.szRad2, '%');\n \tif (!sep) sep = strchr(cat_enum.szRad2, '#');\n \tif (!sep) sep = strchr(cat_enum.szRad2, ':');\n \tstrcpy(cat_enum.szOpt, \"\");\n \tif (sep) {\n \t\tstrcpy(cat_enum.szOpt, sep);\n \t\tsep[0] = 0;\n \t}\n\treturn gf_enum_directory(cat_enum.szPath, 0, cat_enumerate, &cat_enum, NULL);\n}", "target": 1}
{"code": "StatusOr<FullTypeDef> SpecializeType(const AttrSlice& attrs,\n                                     const OpDef& op_def) {\n  FullTypeDef ft;\n  ft.set_type_id(TFT_PRODUCT);\n  for (int i = 0; i < op_def.output_arg_size(); i++) {\n    auto* t = ft.add_args();\n    *t = op_def.output_arg(i).experimental_full_type();\n    for (int j = 0; j < t->args_size(); j++) {\n      auto* arg = t->mutable_args(i);\n      if (arg->type_id() == TFT_VAR) {\n        const auto* attr = attrs.Find(arg->s());\n        if (attr == nullptr) {\n          return Status(\n              error::INVALID_ARGUMENT,\n              absl::StrCat(\"Could not find an attribute for key \", arg->s()));\n        }\n        if (attr->value_case() == AttrValue::kList) {\n          const auto& attr_list = attr->list();\n          arg->set_type_id(TFT_PRODUCT);\n          for (int i = 0; i < attr_list.type_size(); i++) {\n            map_dtype_to_tensor(attr_list.type(i), arg->add_args());\n          }\n        } else if (attr->value_case() == AttrValue::kType) {\n          map_dtype_to_tensor(attr->type(), arg);\n        } else {\n          return Status(error::UNIMPLEMENTED,\n                        absl::StrCat(\"unknown attribute type\",\n                                     attrs.DebugString(), \" key=\", arg->s()));\n        }\n        arg->clear_s();\n      }\n    }\n  }\n  return ft;\n}", "target": 1}
{"code": "int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,\n                            size_t size)\n{\n    GetBitContext gb;\n    AC3HeaderInfo *hdr;\n    int err;\n    if (!*phdr)\n        *phdr = av_mallocz(sizeof(AC3HeaderInfo));\n    if (!*phdr)\n         return AVERROR(ENOMEM);\n     hdr = *phdr;\n    init_get_bits8(&gb, buf, size);\n     err = ff_ac3_parse_header(&gb, hdr);\n     if (err < 0)\n         return AVERROR_INVALIDDATA;\n    return get_bits_count(&gb);\n}", "target": 1}
{"code": "PHP_FUNCTION(move_uploaded_file)\n{\n\tchar *path, *new_path;\n\tint path_len, new_path_len;\n\tzend_bool successful = 0;\n#ifndef PHP_WIN32\n\tint oldmask; int ret;\n#endif\n\tif (!SG(rfc1867_uploaded_files)) {\n                RETURN_FALSE;\n        }\n       if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss\", &path, &path_len, &new_path, &new_path_len) == FAILURE) {\n                return;\n        }\n\tif (!zend_hash_exists(SG(rfc1867_uploaded_files), path, path_len + 1)) {\n\t\tRETURN_FALSE;\n\t}\n\tif (php_check_open_basedir(new_path TSRMLS_CC)) {\n\t\tRETURN_FALSE;\n\t}\n\tif (VCWD_RENAME(path, new_path) == 0) {\n\t\tsuccessful = 1;\n#ifndef PHP_WIN32\n\t\toldmask = umask(077);\n\t\tumask(oldmask);\n\t\tret = VCWD_CHMOD(new_path, 0666 & ~oldmask);\n\t\tif (ret == -1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s\", strerror(errno));\n\t\t}\n#endif\n\t} else if (php_copy_file_ex(path, new_path, STREAM_DISABLE_OPEN_BASEDIR TSRMLS_CC) == SUCCESS) {\n\t\tVCWD_UNLINK(path);\n\t\tsuccessful = 1;\n\t}\n\tif (successful) {\n\t\tzend_hash_del(SG(rfc1867_uploaded_files), path, path_len + 1);\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to move '%s' to '%s'\", path, new_path);\n\t}\n\tRETURN_BOOL(successful);\n}", "target": 1}
{"code": "static jlong Region_createFromParcel(JNIEnv* env, jobject clazz, jobject parcel)\n{\n if (parcel == NULL) {\n return NULL;\n }\n     android::Parcel* p = android::parcelForJavaObject(env, parcel);\n     SkRegion* region = new SkRegion;\n    size_t size = p->readInt32();\n    region->readFromMemory(p->readInplace(size), size);\n     return reinterpret_cast<jlong>(region);\n }", "target": 1}
{"code": "TfLiteStatus Subgraph::AddNodeWithParameters(\n    const std::vector<int>& inputs, const std::vector<int>& outputs,\n    const std::vector<int>& intermediates, const char* init_data,\n    size_t init_data_size, void* builtin_data,\n    const TfLiteRegistration* registration, int* node_index) {\n  std::unique_ptr<void, decltype(free)*> builtin_data_deleter(builtin_data,\n                                                              free);\n  if (state_ == kStateInvokableAndImmutable) {\n    ReportError(\"AddNodeWithParameters is disallowed when graph is immutable.\");\n    return kTfLiteError;\n  }\n  state_ = kStateUninvokable;\n  TF_LITE_ENSURE_OK(&context_, CheckTensorIndices(\"node inputs\", inputs.data(),\n                                                  inputs.size()));\n  TF_LITE_ENSURE_OK(\n      &context_,\n      CheckTensorIndices(\"node outputs\", outputs.data(), outputs.size()));\n  int new_node_index = nodes_and_registration_.size();\n  if (node_index) *node_index = new_node_index;\n  nodes_and_registration_.resize(nodes_and_registration_.size() + 1);\n  auto& node_and_reg = nodes_and_registration_.back();\n  TfLiteNode& node = node_and_reg.first;\n  if (node.inputs) TfLiteIntArrayFree(node.inputs);\n  if (node.outputs) TfLiteIntArrayFree(node.outputs);\n  if (node.intermediates) TfLiteIntArrayFree(node.intermediates);\n  if (node.temporaries) TfLiteIntArrayFree(node.temporaries);\n  node.inputs = ConvertVectorToTfLiteIntArray(inputs);\n  node.outputs = ConvertVectorToTfLiteIntArray(outputs);\n  node.intermediates = ConvertVectorToTfLiteIntArray(intermediates);\n  node.temporaries = TfLiteIntArrayCreate(0);\n  if (init_data) {\n    node.user_data = OpInit(*registration, init_data, init_data_size);\n  } else {\n    node.user_data = OpInit(\n        *registration, static_cast<const char*>(builtin_data_deleter.get()), 0);\n  }\n  node.builtin_data = builtin_data_deleter.release();\n  if (registration->builtin_code == BuiltinOperator_CUSTOM) {\n    node.custom_initial_data = init_data;\n    node.custom_initial_data_size = init_data_size;\n  } else {\n    node.custom_initial_data = nullptr;\n    node.custom_initial_data_size = 0;\n  }\n  node.delegate = nullptr;\n  node_and_reg.second = *registration;\n  execution_plan_.push_back(new_node_index);\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static void perf_callchain_user_64(struct perf_callchain_entry *entry,\n\t\t\t\t   struct pt_regs *regs)\n{\n\tunsigned long sp, next_sp;\n\tunsigned long next_ip;\n\tunsigned long lr;\n\tlong level = 0;\n\tstruct signal_frame_64 __user *sigframe;\n\tunsigned long __user *fp, *uregs;\n\tnext_ip = perf_instruction_pointer(regs);\n\tlr = regs->link;\n \tsp = regs->gpr[1];\n \tperf_callchain_store(entry, next_ip);\n\tfor (;;) {\n \t\tfp = (unsigned long __user *) sp;\n \t\tif (!valid_user_sp(sp, 1) || read_user_stack_64(fp, &next_sp))\n \t\t\treturn;\n\t\tif (level > 0 && read_user_stack_64(&fp[2], &next_ip))\n\t\t\treturn;\n\t\tif (next_sp - sp >= sizeof(struct signal_frame_64) &&\n\t\t    (is_sigreturn_64_address(next_ip, sp) ||\n\t\t     (level <= 1 && is_sigreturn_64_address(lr, sp))) &&\n\t\t    sane_signal_64_frame(sp)) {\n\t\t\tsigframe = (struct signal_frame_64 __user *) sp;\n\t\t\turegs = sigframe->uc.uc_mcontext.gp_regs;\n\t\t\tif (read_user_stack_64(&uregs[PT_NIP], &next_ip) ||\n\t\t\t    read_user_stack_64(&uregs[PT_LNK], &lr) ||\n\t\t\t    read_user_stack_64(&uregs[PT_R1], &sp))\n\t\t\t\treturn;\n\t\t\tlevel = 0;\n\t\t\tperf_callchain_store(entry, PERF_CONTEXT_USER);\n\t\t\tperf_callchain_store(entry, next_ip);\n\t\t\tcontinue;\n\t\t}\n\t\tif (level == 0)\n\t\t\tnext_ip = lr;\n\t\tperf_callchain_store(entry, next_ip);\n\t\t++level;\n\t\tsp = next_sp;\n\t}\n}", "target": 1}
{"code": "ztype(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    ref tnref;\n    int code = array_get(imemory, op, (long)r_btype(op - 1), &tnref);\n    if (code < 0)\n        return code;\n    if (!r_has_type(&tnref, t_name)) {\n         check_op(2);\n         {                       \n            if (op[-1].value.pstruct != 0x00) {\n             const char *sname =\n                 gs_struct_type_name_string(gs_object_type(imemory,\n                                                           op[-1].value.pstruct));\n            int code = name_ref(imemory, (const byte *)sname, strlen(sname),\n                                (ref *) (op - 1), 0);\n            if (code < 0)\n                return code;\n            } else\n                return_error(gs_error_stackunderflow);\n        }\n        r_set_attrs(op - 1, a_executable);\n    } else {\n        ref_assign(op - 1, &tnref);\n    }\n    pop(1);\n    return 0;\n}", "target": 1}
{"code": " void ParamTraits<GURL>::Write(Message* m, const GURL& p) {\n   DCHECK(p.possibly_invalid_spec().length() <= content::kMaxURLChars);\n   m->WriteString(p.possibly_invalid_spec());\n }", "target": 1}
{"code": "feed_table_block_tag(struct table *tbl,\n\t\t     char *line, struct table_mode *mode, int indent, int cmd)\n{\n    int offset;\n    if (mode->indent_level <= 0 && indent == -1)\n\treturn;\n    setwidth(tbl, mode);\n    feed_table_inline_tag(tbl, line, mode, -1);\n    clearcontentssize(tbl, mode);\n    if (indent == 1) {\n\tmode->indent_level++;\n\tif (mode->indent_level <= MAX_INDENT_LEVEL)\n\t    tbl->indent += INDENT_INCR;\n    }\n    else if (indent == -1) {\n\tmode->indent_level--;\n\tif (mode->indent_level < MAX_INDENT_LEVEL)\n\t    tbl->indent -= INDENT_INCR;\n    }\n    offset = tbl->indent;\n    if (cmd == HTML_DT) {\n\tif (mode->indent_level > 0 && mode->indent_level <= MAX_INDENT_LEVEL)\n\t    offset -= INDENT_INCR;\n    }\n    if (tbl->indent > 0) {\n\tcheck_minimum0(tbl, 0);\n\taddcontentssize(tbl, offset);\n    }\n}", "target": 1}
{"code": "static int MOD_EXP_CTIME_COPY_FROM_PREBUF(BIGNUM *b, int top,\n                                          unsigned char *buf, int idx,\n                                          int width)\n{\n    size_t i, j;\n    if (bn_wexpand(b, top) == NULL)\n        return 0;\n    for (i = 0, j = idx; i < top * sizeof b->d[0]; i++, j += width) {\n        ((unsigned char *)b->d)[i] = buf[j];\n    }\n    b->top = top;\n    bn_correct_top(b);\n    return 1;\n}", "target": 1}
{"code": "gnutls_session_get_data (gnutls_session_t session,\n                         void *session_data, size_t * session_data_size)\n{\n  gnutls_datum_t psession;\n  int ret;\n  if (session->internals.resumable == RESUME_FALSE)\n    return GNUTLS_E_INVALID_SESSION;\n  psession.data = session_data;\n  ret = _gnutls_session_pack (session, &psession);\n  if (ret < 0)\n    {\n      gnutls_assert ();\n      return ret;\n    }\n   if (psession.size > *session_data_size)\n     {\n       ret = GNUTLS_E_SHORT_MEMORY_BUFFER;\n       goto error;\n     }\n  if (session_data != NULL)\n    memcpy (session_data, psession.data, psession.size);\n  ret = 0;\nerror:\n  _gnutls_free_datum (&psession);\n  return ret;\n}", "target": 1}
{"code": "xps_true_callback_glyph_name(gs_font *pfont, gs_glyph glyph, gs_const_string *pstr)\n{\n    int table_length;\n     int table_offset;\n     ulong format;\n    uint numGlyphs;\n     uint glyph_name_index;\n     const byte *postp; \n     if ( pfont->FontType != ft_TrueType )\n     {\n            pstr->size = strlen((char*)pstr->data);\n            return 0;\n        }\n        else\n        {\n            return gs_throw1(-1, \"glyph index %lu out of range\", (ulong)glyph);\n        }\n    }", "target": 1}
{"code": "llsec_key_alloc(const struct ieee802154_llsec_key *template)\n{\n\tconst int authsizes[3] = { 4, 8, 16 };\n\tstruct mac802154_llsec_key *key;\n\tint i;\n\tkey = kzalloc(sizeof(*key), GFP_KERNEL);\n\tif (!key)\n\t\treturn NULL;\n\tkref_init(&key->ref);\n\tkey->key = *template;\n\tBUILD_BUG_ON(ARRAY_SIZE(authsizes) != ARRAY_SIZE(key->tfm));\n\tfor (i = 0; i < ARRAY_SIZE(key->tfm); i++) {\n\t\tkey->tfm[i] = crypto_alloc_aead(\"ccm(aes)\", 0,\n\t\t\t\t\t\tCRYPTO_ALG_ASYNC);\n\t\tif (IS_ERR(key->tfm[i]))\n\t\t\tgoto err_tfm;\n\t\tif (crypto_aead_setkey(key->tfm[i], template->key,\n\t\t\t\t       IEEE802154_LLSEC_KEY_SIZE))\n\t\t\tgoto err_tfm;\n\t\tif (crypto_aead_setauthsize(key->tfm[i], authsizes[i]))\n\t\t\tgoto err_tfm;\n\t}\n\tkey->tfm0 = crypto_alloc_sync_skcipher(\"ctr(aes)\", 0, 0);\n\tif (IS_ERR(key->tfm0))\n\t\tgoto err_tfm;\n\tif (crypto_sync_skcipher_setkey(key->tfm0, template->key,\n\t\t\t\t   IEEE802154_LLSEC_KEY_SIZE))\n\t\tgoto err_tfm0;\n\treturn key;\nerr_tfm0:\n\tcrypto_free_sync_skcipher(key->tfm0);\nerr_tfm:\n\tfor (i = 0; i < ARRAY_SIZE(key->tfm); i++)\n\t\tif (key->tfm[i])\n\t\t\tcrypto_free_aead(key->tfm[i]);\n\tkfree_sensitive(key);\n\treturn NULL;\n}", "target": 1}
{"code": "static BOOL autodetect_recv_bandwidth_measure_results(rdpRdp* rdp, wStream* s,\n                                                      AUTODETECT_RSP_PDU* autodetectRspPdu)\n{\n\tBOOL success = TRUE;\n\tif (autodetectRspPdu->headerLength != 0x0E)\n\t\treturn FALSE;\n\tWLog_VRB(AUTODETECT_TAG, \"received Bandwidth Measure Results PDU\");\n\tStream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureTimeDelta); \n\tStream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureByteCount); \n\tif (rdp->autodetect->bandwidthMeasureTimeDelta > 0)\n\t\trdp->autodetect->netCharBandwidth = rdp->autodetect->bandwidthMeasureByteCount * 8 /\n\t\t                                    rdp->autodetect->bandwidthMeasureTimeDelta;\n\telse\n\t\trdp->autodetect->netCharBandwidth = 0;\n\tIFCALLRET(rdp->autodetect->BandwidthMeasureResults, success, rdp->context,\n\t          autodetectRspPdu->sequenceNumber);\n\treturn success;\n}", "target": 1}
{"code": "static inline int ip_ufo_append_data(struct sock *sk,\n\t\t\tstruct sk_buff_head *queue,\n\t\t\tint getfrag(void *from, char *to, int offset, int len,\n\t\t\t       int odd, struct sk_buff *skb),\n\t\t\tvoid *from, int length, int hh_len, int fragheaderlen,\n\t\t\tint transhdrlen, int maxfraglen, unsigned int flags)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\tif ((skb = skb_peek_tail(queue)) == NULL) {\n\t\tskb = sock_alloc_send_skb(sk,\n\t\t\thh_len + fragheaderlen + transhdrlen + 20,\n\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\tif (skb == NULL)\n\t\t\treturn err;\n\t\tskb_reserve(skb, hh_len);\n\t\tskb_put(skb, fragheaderlen + transhdrlen);\n\t\tskb_reset_network_header(skb);\n \t\tskb->transport_header = skb->network_header + fragheaderlen;\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n \t\tskb->csum = 0;\n\t\tskb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;\n\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n \t\t__skb_queue_tail(queue, skb);\n \t}\n \treturn skb_append_datato_frags(sk, skb, getfrag, from,\n \t\t\t\t       (length - transhdrlen));\n }", "target": 1}
{"code": "on_unregister_handler(TCMUService1HandlerManager1 *interface,\n\t\t      GDBusMethodInvocation *invocation,\n\t\t      gchar *subtype,\n \t\t      gpointer user_data)\n {\n \tstruct tcmur_handler *handler = find_handler_by_subtype(subtype);\n\tstruct dbus_info *info = handler->opaque;\n \tif (!handler) {\n \t\tg_dbus_method_invocation_return_value(invocation,\n\t\t\tg_variant_new(\"(bs)\", FALSE,\n\t\t\t\t      \"unknown subtype\"));\n\t\treturn TRUE;\n\t}\n\tdbus_unexport_handler(handler);\n\ttcmur_unregister_handler(handler);\n\tg_bus_unwatch_name(info->watcher_id);\n\tg_free(info);\n\tg_free(handler);\n\tg_dbus_method_invocation_return_value(invocation,\n\t\tg_variant_new(\"(bs)\", TRUE, \"succeeded\"));\n\treturn TRUE;\n}", "target": 1}
{"code": "static int FNAME(cmpxchg_gpte)(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t       pt_element_t __user *ptep_user, unsigned index,\n\t\t\t       pt_element_t orig_pte, pt_element_t new_pte)\n{\n\tint npages;\n\tpt_element_t ret;\n\tpt_element_t *table;\n\tstruct page *page;\n\tnpages = get_user_pages_fast((unsigned long)ptep_user, 1, FOLL_WRITE, &page);\n\tif (likely(npages == 1)) {\n\t\ttable = kmap_atomic(page);\n\t\tret = CMPXCHG(&table[index], orig_pte, new_pte);\n\t\tkunmap_atomic(table);\n\t\tkvm_release_page_dirty(page);\n\t} else {\n\t\tstruct vm_area_struct *vma;\n\t\tunsigned long vaddr = (unsigned long)ptep_user & PAGE_MASK;\n\t\tunsigned long pfn;\n\t\tunsigned long paddr;\n\t\tmmap_read_lock(current->mm);\n\t\tvma = find_vma_intersection(current->mm, vaddr, vaddr + PAGE_SIZE);\n\t\tif (!vma || !(vma->vm_flags & VM_PFNMAP)) {\n\t\t\tmmap_read_unlock(current->mm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tpfn = ((vaddr - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\t\tpaddr = pfn << PAGE_SHIFT;\n\t\ttable = memremap(paddr, PAGE_SIZE, MEMREMAP_WB);\n\t\tif (!table) {\n\t\t\tmmap_read_unlock(current->mm);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tret = CMPXCHG(&table[index], orig_pte, new_pte);\n\t\tmemunmap(table);\n\t\tmmap_read_unlock(current->mm);\n\t}\n\treturn (ret != orig_pte);\n}", "target": 1}
{"code": "MagickExport int LocaleLowercase(const int c)\n {\n #if defined(MAGICKCORE_LOCALE_SUPPORT)\n   if (c_locale != (locale_t) NULL)\n    return(tolower_l(c,c_locale));\n #endif\n  return(tolower(c));\n }", "target": 1}
{"code": "static void* OGRExpatRealloc( void *ptr, size_t size )\n{\n    if( CanAlloc(size) )\n        return realloc(ptr, size);\n    free(ptr);\n    return nullptr;\n}", "target": 1}
{"code": "x11_open_helper(Buffer *b)\n{\n\tu_char *ucp;\n\tu_int proto_len, data_len;\n \tu_char *ucp;\n \tu_int proto_len, data_len;\n \tif (buffer_len(b) < 12)\n \t\treturn 0;\n\t\tdebug2(\"Initial X11 packet contains bad byte order byte: 0x%x\",\n\t\t    ucp[0]);\n\t\treturn -1;\n\t}", "target": 1}
{"code": "int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)\n{\n\tflush_fp_to_thread(src);\n \tflush_altivec_to_thread(src);\n \tflush_vsx_to_thread(src);\n \tflush_spe_to_thread(src);\n \t*dst = *src;\n\tclear_task_ebb(dst);\n\treturn 0;\n}", "target": 1}
{"code": "int64_t OpLevelCostEstimator::CalculateOutputSize(const OpInfo& op_info,\n                                                  bool* found_unknown_shapes) {\n  int64_t total_output_size = 0;\n  for (const auto& output : op_info.outputs()) {\n    DataType dt = output.dtype();\n    const auto& original_output_shape = output.shape();\n    int64_t output_size = DataTypeSize(BaseType(dt));\n    int num_dims = std::max(1, original_output_shape.dim_size());\n    auto output_shape = MaybeGetMinimumShape(original_output_shape, num_dims,\n                                             found_unknown_shapes);\n    for (const auto& dim : output_shape.dim()) {\n      output_size *= dim.size();\n    }\n    total_output_size += output_size;\n    VLOG(1) << \"Output Size: \" << output_size\n            << \" Total Output Size:\" << total_output_size;\n  }\n  return total_output_size;\n}", "target": 1}
{"code": "static void setPathFromConvexPoints(SkPath* path, size_t numPoints, const FloatPoint* points)\n{\n    path->incReserve(numPoints);\n    path->moveTo(WebCoreFloatToSkScalar(points[0].x()),\n                 WebCoreFloatToSkScalar(points[0].y()));\n    for (size_t i = 1; i < numPoints; ++i) {\n         path->lineTo(WebCoreFloatToSkScalar(points[i].x()),\n                      WebCoreFloatToSkScalar(points[i].y()));\n     }\n    path->setIsConvex(true);\n }", "target": 1}
{"code": "static int inotify_update_existing_watch(struct fsnotify_group *group,\n\t\t\t\t\t struct inode *inode,\n\t\t\t\t\t u32 arg)\n{\n\tstruct fsnotify_mark *fsn_mark;\n\tstruct inotify_inode_mark *i_mark;\n\t__u32 old_mask, new_mask;\n\t__u32 mask;\n\tint add = (arg & IN_MASK_ADD);\n\tint create = (arg & IN_MASK_CREATE);\n\tint ret;\n\tmask = inotify_arg_to_mask(arg);\n\tfsn_mark = fsnotify_find_mark(&inode->i_fsnotify_marks, group);\n\tif (!fsn_mark)\n\t\treturn -ENOENT;\n\telse if (create)\n\t\treturn -EEXIST;\n\ti_mark = container_of(fsn_mark, struct inotify_inode_mark, fsn_mark);\n\tspin_lock(&fsn_mark->lock);\n\told_mask = fsn_mark->mask;\n\tif (add)\n\t\tfsn_mark->mask |= mask;\n\telse\n\t\tfsn_mark->mask = mask;\n\tnew_mask = fsn_mark->mask;\n\tspin_unlock(&fsn_mark->lock);\n\tif (old_mask != new_mask) {\n\t\tint dropped = (old_mask & ~new_mask);\n\t\tint do_inode = (new_mask & ~inode->i_fsnotify_mask);\n\t\tif (dropped || do_inode)\n\t\t\tfsnotify_recalc_mask(inode->i_fsnotify_marks);\n\t}\n\tret = i_mark->wd;\n\tfsnotify_put_mark(fsn_mark);\n\treturn ret;\n}", "target": 1}
{"code": "void auth_client_request_abort(struct auth_client_request **_request)\n{\n\tstruct auth_client_request *request = *_request;\n\t*_request = NULL;\n\tauth_client_send_cancel(request->conn->client, request->id);\n\tcall_callback(request, AUTH_REQUEST_STATUS_ABORT, NULL, NULL);\n}", "target": 1}
{"code": "GetCode_(gdIOCtx *fd, CODE_STATIC_DATA *scd, int code_size, int flag, int *ZeroDataBlockP)\n{\n\tint           i, j, ret;\n\tunsigned char count;\n\tif (flag) {\n\t\tscd->curbit = 0;\n\t\tscd->lastbit = 0;\n\t\tscd->last_byte = 0;\n\t\tscd->done = FALSE;\n\t\treturn 0;\n\t}\n\tif ( (scd->curbit + code_size) >= scd->lastbit) {\n\t\tif (scd->done) {\n\t\t\tif (scd->curbit >= scd->lastbit) {\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\tscd->buf[0] = scd->buf[scd->last_byte-2];\n\t\tscd->buf[1] = scd->buf[scd->last_byte-1];\n               if ((count = GetDataBlock(fd, &scd->buf[2], ZeroDataBlockP)) <= 0)\n\t\t\tscd->done = TRUE;\n\t\tscd->last_byte = 2 + count;\n\t\tscd->curbit = (scd->curbit - scd->lastbit) + 16;\n\t\tscd->lastbit = (2+count)*8 ;\n\t}\n\tif ((scd->curbit + code_size - 1) >= (CSD_BUF_SIZE * 8)) {\n\t\tret = -1;\n\t} else {\n\t\tret = 0;\n\t\tfor (i = scd->curbit, j = 0; j < code_size; ++i, ++j) {\n\t\t\tret |= ((scd->buf[i / 8] & (1 << (i % 8))) != 0) << j;\n\t\t}\n\t}\n\tscd->curbit += code_size;\n\treturn ret;\n}", "target": 1}
{"code": "static int autosieve_createfolder(const char *userid, const struct auth_state *auth_state,\n                                  const char *internalname, int createsievefolder)\n{\n    const char *subf ;\n    int r = 0;\n    int n;\n    if (userid == NULL || internalname == NULL)\n        return IMAP_MAILBOX_NONEXISTENT;\n    syslog(LOG_DEBUG, \"autosievefolder: autosieve_createfolder() was called for user %s, folder %s\",\n           userid, internalname);\n    if (config_getswitch(IMAPOPT_ANYSIEVEFOLDER)) {\n        createsievefolder = 1;\n    }\n    else if ((subf = config_getstring(IMAPOPT_AUTOCREATE_SIEVE_FOLDERS)) != NULL) {\n        strarray_t *create = strarray_split(subf, SEP, STRARRAY_TRIM);\n        for (n = 0; n < create->count; n++) {\n            const char *name = strarray_nth(create, n);\n            char *foldername = mboxname_user_mbox(userid, name);\n            if (!strcmp(foldername, internalname))\n                createsievefolder = 1;\n            free(foldername);\n            if (createsievefolder) break;\n        }\n        strarray_free(create);\n    }\n    if (!createsievefolder) return IMAP_MAILBOX_NONEXISTENT;\n    struct mboxlock *namespacelock = mboxname_usernamespacelock(internalname);\n    r = mboxlist_lookup(internalname, 0, 0);\n    if (r != IMAP_MAILBOX_NONEXISTENT) goto done;\n    r = mboxlist_createmailbox(internalname, 0, NULL,\n                               1, userid, auth_state, 0, 0, 0, 1, NULL);\n    if (r) {\n        syslog(LOG_ERR, \"autosievefolder: User %s, folder %s creation failed. %s\",\n               userid, internalname, error_message(r));\n        goto done;\n    }\n    mboxlist_changesub(internalname, userid, auth_state, 1, 1, 1);\n    syslog(LOG_DEBUG, \"autosievefolder: User %s, folder %s creation succeeded\",\n           userid, internalname);\ndone:\n    mboxname_release(&namespacelock);\n    return r;\n}", "target": 1}
{"code": "static int mwifiex_pcie_init_evt_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct mwifiex_evt_buf_desc *desc;\n\tstruct sk_buff *skb;\n\tdma_addr_t buf_pa;\n\tint i;\n\tfor (i = 0; i < MWIFIEX_MAX_EVT_BD; i++) {\n\t\tskb = dev_alloc_skb(MAX_EVENT_SIZE);\n\t\tif (!skb) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Unable to allocate skb for EVENT buf.\\n\");\n\t\t\tkfree(card->evtbd_ring_vbase);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb_put(skb, MAX_EVENT_SIZE);\n\t\tif (mwifiex_map_pci_memory(adapter, skb, MAX_EVENT_SIZE,\n\t\t\t\t\t   PCI_DMA_FROMDEVICE))\n\t\t\treturn -1;\n\t\tbuf_pa = MWIFIEX_SKB_DMA_ADDR(skb);\n\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t    \"info: EVT ring: skb=%p len=%d data=%p buf_pa=%#x:%x\\n\",\n\t\t\t    skb, skb->len, skb->data, (u32)buf_pa,\n\t\t\t    (u32)((u64)buf_pa >> 32));\n\t\tcard->evt_buf_list[i] = skb;\n\t\tcard->evtbd_ring[i] = (void *)(card->evtbd_ring_vbase +\n\t\t\t\t      (sizeof(*desc) * i));\n\t\tdesc = card->evtbd_ring[i];\n\t\tdesc->paddr = buf_pa;\n\t\tdesc->len = (u16)skb->len;\n\t\tdesc->flags = 0;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "reg_match_visual(void)\n{\n    pos_T\ttop, bot;\n    linenr_T    lnum;\n    colnr_T\tcol;\n    win_T\t*wp = rex.reg_win == NULL ? curwin : rex.reg_win;\n    int\t\tmode;\n    colnr_T\tstart, end;\n    colnr_T\tstart2, end2;\n    colnr_T\tcols;\n    colnr_T\tcurswant;\n    if (rex.reg_buf != curbuf || VIsual.lnum == 0)\n\treturn FALSE;\n    if (VIsual_active)\n    {\n\tif (LT_POS(VIsual, wp->w_cursor))\n\t{\n\t    top = VIsual;\n\t    bot = wp->w_cursor;\n\t}\n\telse\n\t{\n\t    top = wp->w_cursor;\n\t    bot = VIsual;\n\t}\n\tmode = VIsual_mode;\n\tcurswant = wp->w_curswant;\n    }\n    else\n    {\n\tif (LT_POS(curbuf->b_visual.vi_start, curbuf->b_visual.vi_end))\n\t{\n\t    top = curbuf->b_visual.vi_start;\n\t    bot = curbuf->b_visual.vi_end;\n\t}\n\telse\n\t{\n\t    top = curbuf->b_visual.vi_end;\n\t    bot = curbuf->b_visual.vi_start;\n\t}\n\tmode = curbuf->b_visual.vi_mode;\n\tcurswant = curbuf->b_visual.vi_curswant;\n    }\n    lnum = rex.lnum + rex.reg_firstlnum;\n    if (lnum < top.lnum || lnum > bot.lnum)\n\treturn FALSE;\n    if (mode == 'v')\n    {\n\tcol = (colnr_T)(rex.input - rex.line);\n\tif ((lnum == top.lnum && col < top.col)\n\t\t|| (lnum == bot.lnum && col >= bot.col + (*p_sel != 'e')))\n\t    return FALSE;\n    }\n    else if (mode == Ctrl_V)\n    {\n\tgetvvcol(wp, &top, &start, NULL, &end);\n\tgetvvcol(wp, &bot, &start2, NULL, &end2);\n\tif (start2 < start)\n\t    start = start2;\n\tif (end2 > end)\n\t    end = end2;\n\tif (top.col == MAXCOL || bot.col == MAXCOL || curswant == MAXCOL)\n\t    end = MAXCOL;\n\tcols = win_linetabsize(wp, rex.line, (colnr_T)(rex.input - rex.line));\n\tif (cols < start || cols > end - (*p_sel == 'e'))\n\t    return FALSE;\n    }\n    return TRUE;\n}", "target": 1}
{"code": "static int key_notify_policy_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb_out;\n\tstruct sadb_msg *hdr;\n\tskb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb_out)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb_out, sizeof(struct sadb_msg));\n\thdr->sadb_msg_type = SADB_X_SPDFLUSH;\n\thdr->sadb_msg_seq = c->seq;\n \thdr->sadb_msg_pid = c->portid;\n \thdr->sadb_msg_version = PF_KEY_V2;\n \thdr->sadb_msg_errno = (uint8_t) 0;\n \thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n \tpfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n \treturn 0;\n}", "target": 1}
{"code": "static void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,\n\t\t\t\t      unsigned long resolution,\n\t\t\t\t      unsigned long ticks)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\tstruct snd_timer_tread *r, r1;\n\tstruct timespec tstamp;\n\tint prev, append = 0;\n\tmemset(&tstamp, 0, sizeof(tstamp));\n\tspin_lock(&tu->qlock);\n\tif ((tu->filter & ((1 << SNDRV_TIMER_EVENT_RESOLUTION) |\n\t\t\t   (1 << SNDRV_TIMER_EVENT_TICK))) == 0) {\n\t\tspin_unlock(&tu->qlock);\n\t\treturn;\n\t}\n\tif (tu->last_resolution != resolution || ticks > 0) {\n\t\tif (timer_tstamp_monotonic)\n\t\t\tktime_get_ts(&tstamp);\n\t\telse\n\t\t\tgetnstimeofday(&tstamp);\n \t}\n \tif ((tu->filter & (1 << SNDRV_TIMER_EVENT_RESOLUTION)) &&\n \t    tu->last_resolution != resolution) {\n \t\tr1.event = SNDRV_TIMER_EVENT_RESOLUTION;\n \t\tr1.tstamp = tstamp;\n \t\tr1.val = resolution;\n\t\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\t\ttu->last_resolution = resolution;\n\t\tappend++;\n\t}\n\tif ((tu->filter & (1 << SNDRV_TIMER_EVENT_TICK)) == 0)\n\t\tgoto __wake;\n\tif (ticks == 0)\n\t\tgoto __wake;\n\tif (tu->qused > 0) {\n\t\tprev = tu->qtail == 0 ? tu->queue_size - 1 : tu->qtail - 1;\n\t\tr = &tu->tqueue[prev];\n\t\tif (r->event == SNDRV_TIMER_EVENT_TICK) {\n\t\t\tr->tstamp = tstamp;\n\t\t\tr->val += ticks;\n\t\t\tappend++;\n\t\t\tgoto __wake;\n\t\t}\n\t}\n\tr1.event = SNDRV_TIMER_EVENT_TICK;\n\tr1.tstamp = tstamp;\n\tr1.val = ticks;\n\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\tappend++;\n      __wake:\n\tspin_unlock(&tu->qlock);\n\tif (append == 0)\n\t\treturn;\n\tkill_fasync(&tu->fasync, SIGIO, POLL_IN);\n\twake_up(&tu->qchange_sleep);\n}", "target": 1}
{"code": "static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n                                const uint8_t *buf, int buf_size)\n{\n    ParseContext *pc = &dctx->pc;\n    uint64_t state = pc->state64;\n    int pic_found = pc->frame_start_found;\n    int i = 0;\n    if (!pic_found) {\n        for (i = 0; i < buf_size; i++) {\n            state = (state << 8) | buf[i];\n            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {\n                i++;\n                pic_found = 1;\n                dctx->cur_byte = 0;\n                dctx->remaining = 0;\n                break;\n            }\n        }\n    }\n    if (pic_found && !dctx->remaining) {\n        if (!buf_size) \n            return 0;\n        for (; i < buf_size; i++) {\n            dctx->cur_byte++;\n            state = (state << 8) | buf[i];\n            if (dctx->cur_byte == 24) {\n                dctx->h = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 26) {\n                 dctx->w = (state >> 32) & 0xFFFF;\n             } else if (dctx->cur_byte == 42) {\n                 int cid = (state >> 32) & 0xFFFFFFFF;\n                 if (cid <= 0)\n                     continue;\n                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);\n                if (dctx->remaining <= 0) {\n                    dctx->remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n                    if (dctx->remaining <= 0)\n                        return dctx->remaining;\n                 }\n                 if (buf_size - i + 47 >= dctx->remaining) {\n                     int remaining = dctx->remaining;\n                    pc->frame_start_found = 0;\n                    pc->state64 = -1;\n                    dctx->cur_byte = 0;\n                    dctx->remaining = 0;\n                    return remaining;\n                } else {\n                    dctx->remaining -= buf_size;\n                }\n            }\n        }\n    } else if (pic_found) {\n        if (dctx->remaining > buf_size) {\n            dctx->remaining -= buf_size;\n        } else {\n            int remaining = dctx->remaining;\n            pc->frame_start_found = 0;\n            pc->state64 = -1;\n            dctx->cur_byte = 0;\n            dctx->remaining = 0;\n            return remaining;\n        }\n    }\n    pc->frame_start_found = pic_found;\n    pc->state64 = state;\n    return END_NOT_FOUND;\n}", "target": 1}
{"code": "static int newque(struct ipc_namespace *ns, struct ipc_params *params)\n{\n\tstruct msg_queue *msq;\n\tint id, retval;\n\tkey_t key = params->key;\n\tint msgflg = params->flg;\n\tmsq = ipc_rcu_alloc(sizeof(*msq));\n\tif (!msq)\n\t\treturn -ENOMEM;\n\tmsq->q_perm.mode = msgflg & S_IRWXUGO;\n\tmsq->q_perm.key = key;\n\tmsq->q_perm.security = NULL;\n\tretval = security_msg_queue_alloc(msq);\n\tif (retval) {\n\t\tipc_rcu_putref(msq, ipc_rcu_free);\n \t\treturn retval;\n \t}\n\tid = ipc_addid(&msg_ids(ns), &msq->q_perm, ns->msg_ctlmni);\n\tif (id < 0) {\n\t\tipc_rcu_putref(msq, msg_rcu_free);\n\t\treturn id;\n\t}\n \tmsq->q_stime = msq->q_rtime = 0;\n \tmsq->q_ctime = get_seconds();\n \tmsq->q_cbytes = msq->q_qnum = 0;\n\tmsq->q_qbytes = ns->msg_ctlmnb;\n\tmsq->q_lspid = msq->q_lrpid = 0;\n\tINIT_LIST_HEAD(&msq->q_messages);\n \tINIT_LIST_HEAD(&msq->q_receivers);\n \tINIT_LIST_HEAD(&msq->q_senders);\n \tipc_unlock_object(&msq->q_perm);\n \trcu_read_unlock();\n\treturn msq->q_perm.id;\n}", "target": 1}
{"code": "void TightDecoder::FilterGradient(const rdr::U8* inbuf,\n                                  const PixelFormat& pf, PIXEL_T* outbuf,\n                                  int stride, const Rect& r)\n{\n  int x, y, c;\n  static rdr::U8 prevRow[TIGHT_MAX_WIDTH*3];\n  static rdr::U8 thisRow[TIGHT_MAX_WIDTH*3];\n  rdr::U8 pix[3]; \n  int est[3]; \n  memset(prevRow, 0, sizeof(prevRow));\n  int rectHeight = r.height();\n  int rectWidth = r.width();\n  for (y = 0; y < rectHeight; y++) {\n    pf.rgbFromBuffer(pix, &inbuf[y*rectWidth], 1);\n    for (c = 0; c < 3; c++)\n      pix[c] += prevRow[c];\n    memcpy(thisRow, pix, sizeof(pix));\n    pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride], pix, 1);\n    for (x = 1; x < rectWidth; x++) {\n      for (c = 0; c < 3; c++) {\n        est[c] = prevRow[x*3+c] + pix[c] - prevRow[(x-1)*3+c];\n        if (est[c] > 255) {\n          est[c] = 255;\n        } else if (est[c] < 0) {\n          est[c] = 0;\n        }\n      }\n      pf.rgbFromBuffer(pix, &inbuf[y*rectWidth+x], 1);\n      for (c = 0; c < 3; c++)\n        pix[c] += est[c];\n      memcpy(&thisRow[x*3], pix, sizeof(pix));\n      pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride+x], pix, 1);\n    }\n    memcpy(prevRow, thisRow, sizeof(prevRow));\n  }\n}", "target": 1}
{"code": "RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {\n\tint i;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_list_newf (free);\n\tfor (i = 0; i < bin->ne_header->SegCount; i++) {\n\t\tRBinSection *bs = R_NEW0 (RBinSection);\n\t\tif (!bs) {\n\t\t\treturn segments;\n\t\t}\n\t\tNE_image_segment_entry *se = &bin->segment_entries[i];\n\t\tbs->size = se->length;\n\t\tbs->vsize = se->minAllocSz ? se->minAllocSz : 64000;\n\t\tbs->bits = R_SYS_BITS_16;\n\t\tbs->is_data = se->flags & IS_DATA;\n\t\tbs->perm = __translate_perms (se->flags);\n\t\tbs->paddr = (ut64)se->offset * bin->alignment;\n\t\tbs->name = r_str_newf (\"%s.%\" PFMT64d, se->flags & IS_MOVEABLE ? \"MOVEABLE\" : \"FIXED\", bs->paddr);\n\t\tbs->is_segment = true;\n\t\tr_list_append (segments, bs);\n\t}\n\tbin->segments = segments;\n\treturn segments;\n}", "target": 1}
{"code": "void CLASS panasonic_load_raw()\n{\n  int row, col, i, j, sh = 0, pred[2], nonz[2];\n  pana_bits(0);\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < raw_width; col++)\n    {\n      if ((i = col % 14) == 0)\n        pred[0] = pred[1] = nonz[0] = nonz[1] = 0;\n      if (i % 3 == 2)\n        sh = 4 >> (3 - pana_bits(2));\n      if (nonz[i & 1])\n      {\n        if ((j = pana_bits(8)))\n        {\n          if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)\n            pred[i & 1] &= ~((~0u) << sh);\n          pred[i & 1] += j << sh;\n        }\n      }\n      else if ((nonz[i & 1] = pana_bits(8)) || i > 11)\n        pred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);\n      if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width)\n        derror();\n    }\n  }\n}", "target": 1}
{"code": "GetCode_(gdIOCtx *fd, CODE_STATIC_DATA *scd, int code_size, int flag, int *ZeroDataBlockP)\n{\n\tint i, j, ret;\n\tunsigned char count;\n\tif(flag) {\n\t\tscd->curbit = 0;\n\t\tscd->lastbit = 0;\n\t\tscd->last_byte = 2;\n\t\tscd->done = FALSE;\n\t\treturn 0;\n\t}\n\tif((scd->curbit + code_size) >= scd->lastbit) {\n\t\tif(scd->done) {\n\t\t\tif(scd->curbit >= scd->lastbit) {\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\tscd->buf[0] = scd->buf[scd->last_byte - 2];\n\t\tscd->buf[1] = scd->buf[scd->last_byte - 1];\n\t\tif((count = GetDataBlock(fd, &scd->buf[2], ZeroDataBlockP)) <= 0) {\n\t\t\tscd->done = TRUE;\n\t\t}\n\t\tscd->last_byte = 2 + count;\n\t\tscd->curbit = (scd->curbit - scd->lastbit) + 16;\n\t\tscd->lastbit = (2 + count) * 8;\n\t}\n\tif ((scd->curbit + code_size - 1) >= (CSD_BUF_SIZE * 8)) {\n\t\tret = -1;\n\t} else {\n\t\tret = 0;\n\t\tfor (i = scd->curbit, j = 0; j < code_size; ++i, ++j) {\n\t\t\tret |= ((scd->buf[i / 8] & (1 << (i % 8))) != 0) << j;\n\t\t}\n\t}\n\tscd->curbit += code_size;\n\treturn ret;\n}", "target": 1}
{"code": "switchGroup(uid_t uid, const struct passwd *userInfo, gid_t gid) {\n\tif (userInfo != NULL) {\n\t\tbool setgroupsCalled = false;\n\t\t#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__)\n\t\t\t#ifdef __APPLE__\n\t\t\t\tint groups[1024];\n\t\t\t\tint ngroups = sizeof(groups) / sizeof(int);\n\t\t\t#else\n\t\t\t\tgid_t groups[1024];\n\t\t\t\tint ngroups = sizeof(groups) / sizeof(gid_t);\n\t\t\t#endif\n\t\t\tboost::scoped_array<gid_t> gidset;\n\t\t\tint ret = getgrouplist(userInfo->pw_name, gid,\n\t\t\t\tgroups, &ngroups);\n\t\t\tif (ret == -1) {\n\t\t\t\tint e = errno;\n\t\t\t\tfprintf(stderr, \"ERROR: getgrouplist(%s, %d) failed: %s (errno=%d)\\n\",\n\t\t\t\t\tuserInfo->pw_name, (int) gid, strerror(e), e);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (ngroups <= NGROUPS_MAX) {\n\t\t\t\tsetgroupsCalled = true;\n\t\t\t\tgidset.reset(new gid_t[ngroups]);\n\t\t\t\tif (setgroups(ngroups, gidset.get()) == -1) {\n\t\t\t\t\tint e = errno;\n\t\t\t\t\tfprintf(stderr, \"ERROR: setgroups(%d, ...) failed: %s (errno=%d)\\n\",\n\t\t\t\t\t\tngroups, strerror(e), e);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t#endif\n\t\tif (!setgroupsCalled && initgroups(userInfo->pw_name, gid) == -1) {\n\t\t\tint e = errno;\n\t\t\tfprintf(stderr, \"ERROR: initgroups(%s, %d) failed: %s (errno=%d)\\n\",\n\t\t\t\tuserInfo->pw_name, (int) gid, strerror(e), e);\n\t\t\texit(1);\n\t\t}\n\t}\n\tif (setgid(gid) == -1) {\n\t\tint e = errno;\n\t\tfprintf(stderr, \"ERROR: setgid(%d) failed: %s (errno=%d)\\n\",\n\t\t\t(int) gid, strerror(e), e);\n\t\texit(1);\n\t}\n}", "target": 1}
{"code": "static int ima_lsm_rule_init(struct ima_measure_rule_entry *entry,\n\t\t\t     char *args, int lsm_rule, int audit_type)\n{\n\tint result;\n\tif (entry->lsm[lsm_rule].rule)\n\t\treturn -EINVAL;\n\tentry->lsm[lsm_rule].type = audit_type;\n \tresult = security_filter_rule_init(entry->lsm[lsm_rule].type,\n \t\t\t\t\t   Audit_equal, args,\n \t\t\t\t\t   &entry->lsm[lsm_rule].rule);\n \treturn result;\n }", "target": 1}
{"code": "int TS_OBJ_print_bio(BIO *bio, const ASN1_OBJECT *obj)\n {\n     char obj_txt[128];\n    int len = OBJ_obj2txt(obj_txt, sizeof(obj_txt), obj, 0);\n    BIO_write(bio, obj_txt, len);\n    BIO_write(bio, \"\\n\", 1);\n     return 1;\n }", "target": 1}
{"code": "static jlong Region_createFromParcel(JNIEnv* env, jobject clazz, jobject parcel)\n{\n if (parcel == NULL) {\n return NULL;\n }\n    android::Parcel* p = android::parcelForJavaObject(env, parcel);\n const size_t size = p->readInt32();\n const void* regionData = p->readInplace(size);\n if (regionData == NULL) {\n         return NULL;\n     }\n     SkRegion* region = new SkRegion;\n    region->readFromMemory(regionData, size);\n     return reinterpret_cast<jlong>(region);\n }", "target": 1}
{"code": "RoleName RoleName::parseFromBSON(const BSONElement& elem) {\n    auto obj = elem.embeddedObjectUserCheck();\n    std::array<BSONElement, 2> fields;\n    obj.getFields(\n        {AuthorizationManager::ROLE_NAME_FIELD_NAME, AuthorizationManager::ROLE_DB_FIELD_NAME},\n        &fields);\n    const auto& nameField = fields[0];\n    uassert(ErrorCodes::BadValue,\n            str::stream() << \"user name must contain a string field named: \"\n                          << AuthorizationManager::ROLE_NAME_FIELD_NAME,\n            nameField.type() == String);\n    const auto& dbField = fields[1];\n    uassert(ErrorCodes::BadValue,\n            str::stream() << \"role name must contain a string field named: \"\n                          << AuthorizationManager::ROLE_DB_FIELD_NAME,\n            nameField.type() == String);\n    return RoleName(nameField.valueStringData(), dbField.valueStringData());\n}", "target": 1}
{"code": "skip_short_body (int fd, wgint contlen, bool chunked)\n{\n  enum {\n    SKIP_SIZE = 512,                \n    SKIP_THRESHOLD = 4096        \n  };\n  wgint remaining_chunk_size = 0;\n  char dlbuf[SKIP_SIZE + 1];\n  dlbuf[SKIP_SIZE] = '\\0';        \n  if (contlen > SKIP_THRESHOLD)\n    return false;\n  while (contlen > 0 || chunked)\n    {\n      int ret;\n      if (chunked)\n        {\n          if (remaining_chunk_size == 0)\n            {\n              char *line = fd_read_line (fd);\n              char *endl;\n              if (line == NULL)\n                break;\n              remaining_chunk_size = strtol (line, &endl, 16);\n              xfree (line);\n              if (remaining_chunk_size == 0)\n                {\n                  line = fd_read_line (fd);\n                  xfree (line);\n                  break;\n                }\n            }\n          contlen = MIN (remaining_chunk_size, SKIP_SIZE);\n        }\n      DEBUGP ((\"Skipping %s bytes of body: [\", number_to_static_string (contlen)));\n      ret = fd_read (fd, dlbuf, MIN (contlen, SKIP_SIZE), -1);\n      if (ret <= 0)\n        {\n          DEBUGP ((\"] aborting (%s).\\n\",\n                   ret < 0 ? fd_errstr (fd) : \"EOF received\"));\n          return false;\n        }\n      contlen -= ret;\n      if (chunked)\n        {\n          remaining_chunk_size -= ret;\n          if (remaining_chunk_size == 0)\n            {\n              char *line = fd_read_line (fd);\n              if (line == NULL)\n                return false;\n              else\n                xfree (line);\n            }\n        }\n      DEBUGP ((\"%.*s\", ret, dlbuf));\n    }\n  DEBUGP ((\"] done.\\n\"));\n  return true;\n}", "target": 1}
{"code": "uint8_t ethereum_extractThorchainData(const EthereumSignTx *msg,\n                                          char *buffer) {\n  uint16_t offset = 4 + (5 * 32);\n  int16_t len = msg->data_length - offset;\n  if (msg->has_data_length && len > 0) {\n    memcpy(buffer, msg->data_initial_chunk.bytes + offset, len);\n    return len < 256 ? (uint8_t)len : 0;\n  }\n  return 0;\n}", "target": 1}
{"code": "MOBI_RET mobi_trie_insert_infl(MOBITrie **root, const MOBIIndx *indx, size_t i) {\n    MOBIIndexEntry e = indx->entries[i];\n    char *inflected = e.label;\n    for (size_t j = 0; j < e.tags_count; j++) {\n        MOBIIndexTag t = e.tags[j];\n        if (t.tagid == INDX_TAGARR_INFL_PARTS_V1) {\n            for (size_t k = 0; k < t.tagvalues_count - 1; k += 2) {\n                uint32_t len = t.tagvalues[k];\n                uint32_t offset = t.tagvalues[k + 1];\n                char *base = mobi_get_cncx_string_flat(indx->cncx_record, offset, len);\n                if (base == NULL) {\n                    return MOBI_MALLOC_FAILED;\n                }\n                MOBI_RET ret = mobi_trie_insert_reversed(root, base, inflected);\n                free(base);\n                if (ret != MOBI_SUCCESS) {\n                    return ret;\n                }\n            }\n        }\n    }\n    return MOBI_SUCCESS;\n}", "target": 1}
{"code": "static void write_response(ESPState *s)\n{\n    uint32_t n;\n    trace_esp_write_response(s->status);\n    fifo8_reset(&s->fifo);\n    esp_fifo_push(s, s->status);\n    esp_fifo_push(s, 0);\n    if (s->dma) {\n        if (s->dma_memory_write) {\n            s->dma_memory_write(s->dma_opaque,\n                                (uint8_t *)fifo8_pop_buf(&s->fifo, 2, &n), 2);\n            s->rregs[ESP_RSTAT] = STAT_TC | STAT_ST;\n            s->rregs[ESP_RINTR] |= INTR_BS | INTR_FC;\n            s->rregs[ESP_RSEQ] = SEQ_CD;\n        } else {\n            s->pdma_cb = write_response_pdma_cb;\n            esp_raise_drq(s);\n            return;\n        }\n    } else {\n        s->ti_size = 2;\n        s->rregs[ESP_RFLAGS] = 2;\n    }\n    esp_raise_irq(s);\n}", "target": 1}
{"code": "void giveup_all(struct task_struct *tsk)\n{\n\tunsigned long usermsr;\n\tif (!tsk->thread.regs)\n\t\treturn;\n\tusermsr = tsk->thread.regs->msr;\n\tif ((usermsr & msr_all_available) == 0)\n\t\treturn;\n\tmsr_check_and_set(msr_all_available);\n\tcheck_if_tm_restore_required(tsk);\n\tWARN_ON((usermsr & MSR_VSX) && !((usermsr & MSR_FP) && (usermsr & MSR_VEC)));\n#ifdef CONFIG_PPC_FPU\n\tif (usermsr & MSR_FP)\n\t\t__giveup_fpu(tsk);\n#endif\n#ifdef CONFIG_ALTIVEC\n\tif (usermsr & MSR_VEC)\n\t\t__giveup_altivec(tsk);\n#endif\n#ifdef CONFIG_SPE\n\tif (usermsr & MSR_SPE)\n\t\t__giveup_spe(tsk);\n#endif\n\tmsr_check_and_clear(msr_all_available);\n}", "target": 1}
{"code": " struct crypto_template *crypto_lookup_template(const char *name)\n {\n\treturn try_then_request_module(__crypto_lookup_template(name), \"%s\",\n\t\t\t\t       name);\n }", "target": 1}
{"code": "static void edge_bulk_in_callback(struct urb *urb)\n{\n\tstruct edgeport_port *edge_port = urb->context;\n\tstruct device *dev = &edge_port->port->dev;\n\tunsigned char *data = urb->transfer_buffer;\n\tint retval = 0;\n\tint port_number;\n\tint status = urb->status;\n\tswitch (status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\tdev_dbg(&urb->dev->dev, \"%s - urb shutting down with status: %d\\n\", __func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_err(&urb->dev->dev, \"%s - nonzero read bulk status received: %d\\n\", __func__, status);\n\t}\n\tif (status == -EPIPE)\n\t\tgoto exit;\n\tif (status) {\n\t\tdev_err(&urb->dev->dev, \"%s - stopping read!\\n\", __func__);\n\t\treturn;\n\t}\n \tport_number = edge_port->port->port_number;\n\tif (edge_port->lsr_event) {\n \t\tedge_port->lsr_event = 0;\n \t\tdev_dbg(dev, \"%s ===== Port %u LSR Status = %02x, Data = %02x ======\\n\",\n \t\t\t__func__, port_number, edge_port->lsr_mask, *data);\n\t\thandle_new_lsr(edge_port, 1, edge_port->lsr_mask, *data);\n\t\t--urb->actual_length;\n\t\t++data;\n\t}\n\tif (urb->actual_length) {\n\t\tusb_serial_debug_data(dev, __func__, urb->actual_length, data);\n\t\tif (edge_port->close_pending)\n\t\t\tdev_dbg(dev, \"%s - close pending, dropping data on the floor\\n\",\n\t\t\t\t\t\t\t\t__func__);\n\t\telse\n\t\t\tedge_tty_recv(edge_port->port, data,\n\t\t\t\t\turb->actual_length);\n\t\tedge_port->port->icount.rx += urb->actual_length;\n\t}\nexit:\n\tspin_lock(&edge_port->ep_lock);\n\tif (edge_port->ep_read_urb_state == EDGE_READ_URB_RUNNING)\n\t\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\telse if (edge_port->ep_read_urb_state == EDGE_READ_URB_STOPPING)\n\t\tedge_port->ep_read_urb_state = EDGE_READ_URB_STOPPED;\n\tspin_unlock(&edge_port->ep_lock);\n\tif (retval)\n\t\tdev_err(dev, \"%s - usb_submit_urb failed with result %d\\n\", __func__, retval);\n}", "target": 1}
{"code": " int dns_read_name(unsigned char *buffer, unsigned char *bufend,\n                  unsigned char *name, char *destination, int dest_len,\n                 int *offset)\n {\n        int nb_bytes = 0, n = 0;\n        int label_len;\n\tunsigned char *reader = name;\n\tchar *dest = destination;\n\twhile (1) {\n\t\tif ((*reader & 0xc0) == 0xc0) {\n                        if ((buffer + reader[1]) > reader)\n                                goto err;\n                        n = dns_read_name(buffer, bufend, buffer + reader[1],\n                                         dest, dest_len - nb_bytes, offset);\n                        if (n == 0)\n                                goto err;\n\t\t}\n\t\tlabel_len = *reader;\n\t\tif (label_len == 0)\n\t\t\tgoto out;\n\t\tif ((reader + label_len >= bufend) || (nb_bytes + label_len >= dest_len))\n\t\t\tgoto err;\n\t\tlabel_len++;\n\t\tmemcpy(dest, reader, label_len);\n\t\tdest     += label_len;\n\t\tnb_bytes += label_len;\n\t\treader   += label_len;\n\t}\n  out:\n\treader  = name;\n\t*offset = 0;\n\twhile (reader < bufend) {\n\t\tif ((reader[0] & 0xc0) == 0xc0) {\n\t\t\t*offset += 2;\n\t\t\tbreak;\n\t\t}\n\t\telse if (*reader == 0) {\n\t\t\t*offset += 1;\n\t\t\tbreak;\n\t\t}\n\t\t*offset += 1;\n\t\t++reader;\n\t}\n\treturn nb_bytes;\n  err:\n\treturn 0;\n}", "target": 1}
{"code": "static bool fib6_rule_suppress(struct fib_rule *rule, struct fib_lookup_arg *arg)\n{\n\tstruct fib6_result *res = arg->result;\n\tstruct rt6_info *rt = res->rt6;\n\tstruct net_device *dev = NULL;\n\tif (!rt)\n\t\treturn false;\n\tif (rt->rt6i_idev)\n\t\tdev = rt->rt6i_idev->dev;\n\tif (rt->rt6i_dst.plen <= rule->suppress_prefixlen)\n\t\tgoto suppress_route;\n\tif (rule->suppress_ifgroup != -1 && dev && dev->group == rule->suppress_ifgroup)\n\t\tgoto suppress_route;\n\treturn false;\nsuppress_route:\n\tip6_rt_put(rt);\n\treturn true;\n}", "target": 1}
{"code": "void ssl3_cbc_copy_mac(unsigned char* out,\n\t\t       const SSL3_RECORD *rec,\n\t\t       unsigned md_size,unsigned orig_len)\n\t{\n#if defined(CBC_MAC_ROTATE_IN_PLACE)\n\tunsigned char rotated_mac_buf[EVP_MAX_MD_SIZE*2];\n\tunsigned char *rotated_mac;\n#else\n\tunsigned char rotated_mac[EVP_MAX_MD_SIZE];\n#endif\n\tunsigned mac_end = rec->length;\n\tunsigned mac_start = mac_end - md_size;\n\tunsigned scan_start = 0;\n\tunsigned i, j;\n\tunsigned div_spoiler;\n\tunsigned rotate_offset;\n\tOPENSSL_assert(orig_len >= md_size);\n\tOPENSSL_assert(md_size <= EVP_MAX_MD_SIZE);\n#if defined(CBC_MAC_ROTATE_IN_PLACE)\n\trotated_mac = (unsigned char*) (((intptr_t)(rotated_mac_buf + 64)) & ~63);\n#endif\n\tif (orig_len > md_size + 255 + 1)\n\t\tscan_start = orig_len - (md_size + 255 + 1);\n\tdiv_spoiler = md_size >> 1;\n\tdiv_spoiler <<= (sizeof(div_spoiler)-1)*8;\n\trotate_offset = (div_spoiler + mac_start - scan_start) % md_size;\n\tmemset(rotated_mac, 0, md_size);\n\tfor (i = scan_start, j = 0; i < orig_len; i++)\n\t\t{\n\t\tunsigned char mac_started = constant_time_ge(i, mac_start);\n\t\tunsigned char mac_ended = constant_time_ge(i, mac_end);\n\t\tunsigned char b = rec->data[i];\n\t\trotated_mac[j++] |= b & mac_started & ~mac_ended;\n\t\tj &= constant_time_lt(j,md_size);\n\t\t}\n#if defined(CBC_MAC_ROTATE_IN_PLACE)\n\tj = 0;\n\tfor (i = 0; i < md_size; i++)\n\t\t{\n\t\tout[j++] = rotated_mac[rotate_offset++];\n\t\trotate_offset &= constant_time_lt(rotate_offset,md_size);\n\t\t}\n#else\n\tmemset(out, 0, md_size);\n\trotate_offset = md_size - rotate_offset;\n\trotate_offset &= constant_time_lt(rotate_offset,md_size);\n\tfor (i = 0; i < md_size; i++)\n\t\t{\n\t\tfor (j = 0; j < md_size; j++)\n\t\t\tout[j] |= rotated_mac[i] & constant_time_eq_8(j, rotate_offset);\n\t\trotate_offset++;\n\t\trotate_offset &= constant_time_lt(rotate_offset,md_size);\n\t\t}\n#endif\n\t}", "target": 1}
{"code": "static int handle_wrmsr(struct kvm_vcpu *vcpu)\n{\n\tstruct msr_data msr;\n\tu32 ecx = vcpu->arch.regs[VCPU_REGS_RCX];\n\tu64 data = (vcpu->arch.regs[VCPU_REGS_RAX] & -1u)\n\t\t| ((u64)(vcpu->arch.regs[VCPU_REGS_RDX] & -1u) << 32);\n \tmsr.data = data;\n \tmsr.index = ecx;\n \tmsr.host_initiated = false;\n\tif (vmx_set_msr(vcpu, &msr) != 0) {\n \t\ttrace_kvm_msr_write_ex(ecx, data);\n \t\tkvm_inject_gp(vcpu, 0);\n \t\treturn 1;\n\t}\n\ttrace_kvm_msr_write(ecx, data);\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}", "target": 1}
{"code": "bool Item_equal::create_pushable_equalities(THD *thd,\n                                            List<Item> *equalities,\n                                            Pushdown_checker checker,\n                                            uchar *arg,\n                                            bool clone_const)\n{\n  Item *item;\n  Item *left_item= NULL;\n  Item *right_item = get_const();\n  Item_equal_fields_iterator it(*this);\n  while ((item=it++))\n  {\n    left_item= item;\n    if (checker && !((item->*checker) (arg)))\n      continue;\n    break;\n  }\n  if (!left_item)\n    return false;\n  if (right_item)\n  {\n    Item_func_eq *eq= 0;\n    Item *left_item_clone= left_item->build_clone(thd);\n    Item *right_item_clone= !clone_const ?\n                            right_item : right_item->build_clone(thd);\n    if (!left_item_clone || !right_item_clone)\n      return true;\n    eq= new (thd->mem_root) Item_func_eq(thd,\n                                         left_item_clone,\n                                         right_item_clone);\n    if (!eq ||  equalities->push_back(eq, thd->mem_root))\n      return true;\n    if (!clone_const)\n      right_item->set_extraction_flag(IMMUTABLE_FL);\n  }\n  while ((item=it++))\n  {\n    if (checker && !((item->*checker) (arg)))\n      continue;\n    Item_func_eq *eq= 0;\n    Item *left_item_clone= left_item->build_clone(thd);\n    Item *right_item_clone= item->build_clone(thd);\n    if (!(left_item_clone && right_item_clone))\n      return true;\n    left_item_clone->set_item_equal(NULL);\n    right_item_clone->set_item_equal(NULL);\n    eq= new (thd->mem_root) Item_func_eq(thd,\n                                         right_item_clone,\n                                         left_item_clone);\n    if (!eq || equalities->push_back(eq, thd->mem_root))\n      return true;\n  }\n  return false;\n}", "target": 1}
{"code": "bool RepeatedAttrDefEqual(\n    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a1,\n    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a2) {\n  std::unordered_map<string, const OpDef::AttrDef*> a1_set;\n  for (const OpDef::AttrDef& def : a1) {\n    DCHECK(a1_set.find(def.name()) == a1_set.end())\n        << \"AttrDef names must be unique, but '\" << def.name()\n        << \"' appears more than once\";\n    a1_set[def.name()] = &def;\n  }\n  for (const OpDef::AttrDef& def : a2) {\n    auto iter = a1_set.find(def.name());\n    if (iter == a1_set.end()) return false;\n    if (!AttrDefEqual(*iter->second, def)) return false;\n    a1_set.erase(iter);\n  }\n  if (!a1_set.empty()) return false;\n  return true;\n}", "target": 1}
{"code": " void TestingPlatformSupport::cryptographicallyRandomValues(unsigned char* buffer, size_t length)\n {\n }", "target": 1}
{"code": "static int hmac_create(struct crypto_template *tmpl, struct rtattr **tb)\n{\n\tstruct shash_instance *inst;\n\tstruct crypto_alg *alg;\n\tstruct shash_alg *salg;\n\tint err;\n\tint ds;\n\tint ss;\n\terr = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_SHASH);\n\tif (err)\n\t\treturn err;\n \tsalg = shash_attr_alg(tb[1], 0, 0);\n \tif (IS_ERR(salg))\n \t\treturn PTR_ERR(salg);\n \terr = -EINVAL;\n \tds = salg->digestsize;\n \tss = salg->statesize;\n\talg = &salg->base;\n \tif (ds > alg->cra_blocksize ||\n \t    ss < alg->cra_blocksize)\n \t\tgoto out_put_alg;\n\tinst = shash_alloc_instance(\"hmac\", alg);\n\terr = PTR_ERR(inst);\n\tif (IS_ERR(inst))\n\t\tgoto out_put_alg;\n\terr = crypto_init_shash_spawn(shash_instance_ctx(inst), salg,\n\t\t\t\t      shash_crypto_instance(inst));\n\tif (err)\n\t\tgoto out_free_inst;\n\tinst->alg.base.cra_priority = alg->cra_priority;\n\tinst->alg.base.cra_blocksize = alg->cra_blocksize;\n\tinst->alg.base.cra_alignmask = alg->cra_alignmask;\n\tss = ALIGN(ss, alg->cra_alignmask + 1);\n\tinst->alg.digestsize = ds;\n\tinst->alg.statesize = ss;\n\tinst->alg.base.cra_ctxsize = sizeof(struct hmac_ctx) +\n\t\t\t\t     ALIGN(ss * 2, crypto_tfm_ctx_alignment());\n\tinst->alg.base.cra_init = hmac_init_tfm;\n\tinst->alg.base.cra_exit = hmac_exit_tfm;\n\tinst->alg.init = hmac_init;\n\tinst->alg.update = hmac_update;\n\tinst->alg.final = hmac_final;\n\tinst->alg.finup = hmac_finup;\n\tinst->alg.export = hmac_export;\n\tinst->alg.import = hmac_import;\n\tinst->alg.setkey = hmac_setkey;\n\terr = shash_register_instance(tmpl, inst);\n\tif (err) {\nout_free_inst:\n\t\tshash_free_instance(shash_crypto_instance(inst));\n\t}\nout_put_alg:\n\tcrypto_mod_put(alg);\n\treturn err;\n}", "target": 1}
{"code": "static int bufp_alloc(USBRedirDevice *dev, uint8_t *data, uint16_t len,\n    uint8_t status, uint8_t ep, void *free_on_destroy)\n{\n    struct buf_packet *bufp;\n    if (!dev->endpoint[EP2I(ep)].bufpq_dropping_packets &&\n        dev->endpoint[EP2I(ep)].bufpq_size >\n            2 * dev->endpoint[EP2I(ep)].bufpq_target_size) {\n        DPRINTF(\"bufpq overflow, dropping packets ep %02X\\n\", ep);\n        dev->endpoint[EP2I(ep)].bufpq_dropping_packets = 1;\n    }\n    if (dev->endpoint[EP2I(ep)].bufpq_dropping_packets) {\n        if (dev->endpoint[EP2I(ep)].bufpq_size >\n                dev->endpoint[EP2I(ep)].bufpq_target_size) {\n            free(data);\n            return -1;\n        }\n        dev->endpoint[EP2I(ep)].bufpq_dropping_packets = 0;\n    }\n    bufp = g_new(struct buf_packet, 1);\n    bufp->data   = data;\n    bufp->len    = len;\n    bufp->offset = 0;\n    bufp->status = status;\n    bufp->free_on_destroy = free_on_destroy;\n    QTAILQ_INSERT_TAIL(&dev->endpoint[EP2I(ep)].bufpq, bufp, next);\n    dev->endpoint[EP2I(ep)].bufpq_size++;\n    return 0;\n}", "target": 1}
{"code": "win_exchange(long Prenum)\n{\n    frame_T\t*frp;\n    frame_T\t*frp2;\n    win_T\t*wp;\n    win_T\t*wp2;\n    int\t\ttemp;\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (ONE_WINDOW)\t    \n    {\n\tbeep_flush();\n\treturn;\n    }\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n    if (Prenum)\n    {\n\tfrp = curwin->w_frame->fr_parent->fr_child;\n\twhile (frp != NULL && --Prenum > 0)\n\t    frp = frp->fr_next;\n    }\n    else if (curwin->w_frame->fr_next != NULL)\t\n\tfrp = curwin->w_frame->fr_next;\n    else    \n\tfrp = curwin->w_frame->fr_prev;\n    if (frp == NULL || frp->fr_win == NULL || frp->fr_win == curwin)\n\treturn;\n    wp = frp->fr_win;\n    wp2 = curwin->w_prev;\n    frp2 = curwin->w_frame->fr_prev;\n    if (wp->w_prev != curwin)\n    {\n\twin_remove(curwin, NULL);\n\tframe_remove(curwin->w_frame);\n\twin_append(wp->w_prev, curwin);\n\tframe_insert(frp, curwin->w_frame);\n    }\n    if (wp != wp2)\n    {\n\twin_remove(wp, NULL);\n\tframe_remove(wp->w_frame);\n\twin_append(wp2, wp);\n\tif (frp2 == NULL)\n\t    frame_insert(wp->w_frame->fr_parent->fr_child, wp->w_frame);\n\telse\n\t    frame_append(frp2, wp->w_frame);\n    }\n    temp = curwin->w_status_height;\n    curwin->w_status_height = wp->w_status_height;\n    wp->w_status_height = temp;\n    temp = curwin->w_vsep_width;\n    curwin->w_vsep_width = wp->w_vsep_width;\n    wp->w_vsep_width = temp;\n    frame_fix_height(curwin);\n    frame_fix_height(wp);\n    frame_fix_width(curwin);\n    frame_fix_width(wp);\n    (void)win_comp_pos();\t\t\n    win_enter(wp, TRUE);\n    redraw_all_later(NOT_VALID);\n}", "target": 1}
{"code": "static int parallels_open(BlockDriverState *bs, QDict *options, int flags,\n                          Error **errp)\n{\n    BDRVParallelsState *s = bs->opaque;\n    int i;\n    struct parallels_header ph;\n    int ret;\n    bs->read_only = 1; \n    ret = bdrv_pread(bs->file, 0, &ph, sizeof(ph));\n    if (ret < 0) {\n        goto fail;\n    }\n    if (memcmp(ph.magic, HEADER_MAGIC, 16) ||\n        (le32_to_cpu(ph.version) != HEADER_VERSION)) {\n        error_setg(errp, \"Image not in Parallels format\");\n        ret = -EINVAL;\n        goto fail;\n    }\n    bs->total_sectors = le32_to_cpu(ph.nb_sectors);\n    s->tracks = le32_to_cpu(ph.tracks);\n    s->catalog_size = le32_to_cpu(ph.catalog_entries);\n    if (s->catalog_size > INT_MAX / 4) {\n        error_setg(errp, \"Catalog too large\");\n        ret = -EFBIG;\n        goto fail;\n    }\n    s->catalog_bitmap = g_malloc(s->catalog_size * 4);\n    ret = bdrv_pread(bs->file, 64, s->catalog_bitmap, s->catalog_size * 4);\n    if (ret < 0) {\n        goto fail;\n    }\n    for (i = 0; i < s->catalog_size; i++)\n\tle32_to_cpus(&s->catalog_bitmap[i]);\n    qemu_co_mutex_init(&s->lock);\n    return 0;\nfail:\n    g_free(s->catalog_bitmap);\n    return ret;\n}", "target": 1}
{"code": "static struct mobj *alloc_ta_mem(size_t size)\n{\n#ifdef CFG_PAGED_USER_TA\n\treturn mobj_paged_alloc(size);\n #else\n \tstruct mobj *mobj = mobj_mm_alloc(mobj_sec_ddr, size, &tee_mm_sec_ddr);\n\tif (mobj)\n\t\tmemset(mobj_get_va(mobj, 0), 0, size);\n \treturn mobj;\n #endif\n }", "target": 1}
{"code": "static v8::Local<v8::Value> compileAndRunPrivateScript(ScriptState* scriptState,\n                                                       String scriptClassName,\n                                                       const char* source,\n                                                       size_t size) {\n  v8::Isolate* isolate = scriptState->isolate();\n  v8::TryCatch block(isolate);\n  String sourceString(source, size);\n  String fileName = scriptClassName + \".js\";\n   v8::Local<v8::Context> context = scriptState->context();\n   v8::Local<v8::Object> global = context->Global();\n  v8::Local<v8::Value> privateScriptController =\n      global->Get(context, v8String(isolate, \"privateScriptController\"))\n          .ToLocalChecked();\n  RELEASE_ASSERT(privateScriptController->IsUndefined() ||\n                 privateScriptController->IsObject());\n  if (privateScriptController->IsObject()) {\n     v8::Local<v8::Object> privateScriptControllerObject =\n         privateScriptController.As<v8::Object>();\n     v8::Local<v8::Value> importFunctionValue =\n        privateScriptControllerObject->Get(context, v8String(isolate, \"import\"))\n            .ToLocalChecked();\n    if (importFunctionValue->IsUndefined()) {\n      v8::Local<v8::Function> function;\n      if (!v8::FunctionTemplate::New(isolate, importFunction)\n               ->GetFunction(context)\n               .ToLocal(&function) ||\n          !v8CallBoolean(privateScriptControllerObject->Set(\n              context, v8String(isolate, \"import\"), function))) {\n        dumpV8Message(context, block.Message());\n        LOG(FATAL)\n            << \"Private script error: Setting import function failed. (Class \"\n               \"name = \"\n            << scriptClassName.utf8().data() << \")\";\n      }\n    }\n  }\n  v8::Local<v8::Script> script;\n  if (!v8Call(V8ScriptRunner::compileScript(\n                  v8String(isolate, sourceString), fileName, String(),\n                  TextPosition::minimumPosition(), isolate, nullptr, nullptr,\n                  nullptr, NotSharableCrossOrigin),\n              script, block)) {\n    dumpV8Message(context, block.Message());\n    LOG(FATAL) << \"Private script error: Compile failed. (Class name = \"\n               << scriptClassName.utf8().data() << \")\";\n  }\n  v8::Local<v8::Value> result;\n  if (!v8Call(V8ScriptRunner::runCompiledInternalScript(isolate, script),\n              result, block)) {\n    dumpV8Message(context, block.Message());\n    LOG(FATAL) << \"Private script error: installClass() failed. (Class name = \"\n               << scriptClassName.utf8().data() << \")\";\n  }\n  return result;\n}", "target": 1}
{"code": "static char *getsistring(FILE *f, uint32_t ptr, uint32_t len) {\n  char *name;\n  uint32_t i;\n  if (!len) return NULL;\n  if (len>400) len=400;\n  name = cli_malloc(len);\n  if (!name) {\n    cli_dbgmsg(\"SIS: OOM\\n\");\n    return NULL;\n  }\n  fseek(f, ptr, SEEK_SET);\n  if (fread(name, len, 1, f)!=1) {\n    cli_dbgmsg(\"SIS: Unable to read string\\n\");\n    free(name);\n    return NULL;\n  }\n  for (i = 0 ; i < len; i+=2) name[i/2] = name[i];\n  name[i/2]='\\0';\n  return name;\n}", "target": 1}
{"code": "void vrend_renderer_context_destroy(uint32_t handle)\n{\n   struct vrend_decode_ctx *ctx;\n   bool ret;\n    if (handle >= VREND_MAX_CTX)\n       return;\n    ctx = dec_ctx[handle];\n    if (!ctx)\n       return;\n      vrend_hw_switch_context(dec_ctx[0]->grctx, true);\n}", "target": 1}
{"code": "QPDF::QPDF() :\n    encrypted(false),\n    encryption_initialized(false),\n    ignore_xref_streams(false),\n    suppress_warnings(false),\n    out_stream(&std::cout),\n    err_stream(&std::cerr),\n    attempt_recovery(true),\n    encryption_V(0),\n    encryption_R(0),\n    encrypt_metadata(true),\n    cf_stream(e_none),\n    cf_string(e_none),\n    cf_file(e_none),\n    cached_key_objid(0),\n    cached_key_generation(0),\n    pushed_inherited_attributes_to_pages(false),\n    copied_stream_data_provider(0),\n    first_xref_item_offset(0),\n    uncompressed_after_compressed(false)\n{\n}", "target": 1}
{"code": "bntseq_t *bns_restore(const char *prefix)\n{  \n\tchar ann_filename[1024], amb_filename[1024], pac_filename[1024], alt_filename[1024];\n\tFILE *fp;\n\tbntseq_t *bns;\n\tstrcat(strcpy(ann_filename, prefix), \".ann\");\n\tstrcat(strcpy(amb_filename, prefix), \".amb\");\n\tstrcat(strcpy(pac_filename, prefix), \".pac\");\n\tbns = bns_restore_core(ann_filename, amb_filename, pac_filename);\n\tif (bns == 0) return 0;\n\tif ((fp = fopen(strcat(strcpy(alt_filename, prefix), \".alt\"), \"r\")) != 0) { \n\t\tchar str[1024];\n\t\tkhash_t(str) *h;\n\t\tint c, i, absent;\n\t\tkhint_t k;\n\t\th = kh_init(str);\n\t\tfor (i = 0; i < bns->n_seqs; ++i) {\n\t\t\tk = kh_put(str, h, bns->anns[i].name, &absent);\n\t\t\tkh_val(h, k) = i;\n\t\t}\n\t\ti = 0;\n\t\twhile ((c = fgetc(fp)) != EOF) {\n\t\t\tif (c == '\\t' || c == '\\n' || c == '\\r') {\n\t\t\t\tstr[i] = 0;\n\t\t\t\tif (str[0] != '@') {\n\t\t\t\t\tk = kh_get(str, h, str);\n\t\t\t\t\tif (k != kh_end(h))\n\t\t\t\t\t\tbns->anns[kh_val(h, k)].is_alt = 1;\n\t\t\t\t}\n\t\t\t\twhile (c != '\\n' && c != EOF) c = fgetc(fp);\n\t\t\t\ti = 0;\n\t\t\t} else str[i++] = c; \n\t\t}\n\t\tkh_destroy(str, h);\n\t\tfclose(fp);\n\t}\n\treturn bns;\n}", "target": 1}
{"code": "process_rs(struct Interface *iface, unsigned char *msg, int len,\n\tstruct sockaddr_in6 *addr)\n{\n\tdouble delay;\n\tdouble next;\n\tstruct timeval tv;\n\tuint8_t *opt_str;\n\tlen -= sizeof(struct nd_router_solicit);\n\topt_str = (uint8_t *)(msg + sizeof(struct nd_router_solicit));\n\twhile (len > 0)\n\t{\n\t\tint optlen;\n\t\tif (len < 2)\n\t\t{\n\t\t\tflog(LOG_WARNING, \"trailing garbage in RS\");\n\t\t\treturn;\n\t\t}\n\t\toptlen = (opt_str[1] << 3);\n\t\tif (optlen == 0)\n\t\t{\n\t\t\tflog(LOG_WARNING, \"zero length option in RS\");\n\t\t\treturn;\n\t\t}\n\t\telse if (optlen > len)\n\t\t{\n\t\t\tflog(LOG_WARNING, \"option length greater than total length in RS\");\n\t\t\treturn;\n\t\t}\n\t\tif (*opt_str == ND_OPT_SOURCE_LINKADDR &&\n\t\t    IN6_IS_ADDR_UNSPECIFIED(&addr->sin6_addr)) {\n\t\t\tflog(LOG_WARNING, \"received icmpv6 RS packet with unspecified source address and there is a lladdr option\");\n\t\t\treturn;\n\t\t}\n\t\tlen -= optlen;\n\t\topt_str += optlen;\n\t}\n\tgettimeofday(&tv, NULL);\n\tdelay = MAX_RA_DELAY_TIME * rand() / (RAND_MAX +1.0);\n\tif (iface->UnicastOnly) {\n\t\tdlog(LOG_DEBUG, 5, \"random mdelay for %s: %g seconds.\", iface->Name, delay/1000.0);\n\t\tmdelay(delay);\n\t\tsend_ra_forall(iface, &addr->sin6_addr);\n\t}\n\telse if ( timevaldiff(&tv, &iface->last_multicast) / 1000.0 < iface->MinDelayBetweenRAs ) {\n\t\tnext = iface->MinDelayBetweenRAs - (tv.tv_sec + tv.tv_usec / 1000000.0) + (iface->last_multicast.tv_sec + iface->last_multicast.tv_usec / 1000000.0) + delay/1000.0;\n\t\tiface->next_multicast = next_timeval(next);\n\t}\n\telse {\n\t\tsend_ra_forall(iface, NULL);\n\t\tnext = rand_between(iface->MinRtrAdvInterval, iface->MaxRtrAdvInterval);\n\t\tiface->next_multicast = next_timeval(next);\n\t}\n}", "target": 1}
{"code": "int64_t OutputFile::readImpl(char* , int64_t ) {\n  raise_warning(\"cannot read from a php:\n  return -1;\n}", "target": 1}
{"code": "static int decode_dds1(GetByteContext *gb, uint8_t *frame, int width, int height)\n{\n    const uint8_t *frame_start = frame;\n    const uint8_t *frame_end   = frame + width * height;\n    int mask = 0x10000, bitbuf = 0;\n    int i, v, offset, count, segments;\n    segments = bytestream2_get_le16(gb);\n    while (segments--) {\n        if (bytestream2_get_bytes_left(gb) < 2)\n            return AVERROR_INVALIDDATA;\n        if (mask == 0x10000) {\n            bitbuf = bytestream2_get_le16u(gb);\n            mask = 1;\n        }\n        if (bitbuf & mask) {\n            v = bytestream2_get_le16(gb);\n            offset = (v & 0x1FFF) << 2;\n            count = ((v >> 13) + 2) << 1;\n            if (frame - frame_start < offset || frame_end - frame < count*2 + width)\n                return AVERROR_INVALIDDATA;\n            for (i = 0; i < count; i++) {\n                frame[0] = frame[1] =\n                frame[width] = frame[width + 1] = frame[-offset];\n                frame += 2;\n            }\n        } else if (bitbuf & (mask << 1)) {\n            v = bytestream2_get_le16(gb)*2;\n            if (frame - frame_end < v)\n                 return AVERROR_INVALIDDATA;\n             frame += v;\n         } else {\n            if (frame_end - frame < width + 3)\n                 return AVERROR_INVALIDDATA;\n             frame[0] = frame[1] =\n             frame[width] = frame[width + 1] =  bytestream2_get_byte(gb);\n            frame += 2;\n            frame[0] = frame[1] =\n            frame[width] = frame[width + 1] =  bytestream2_get_byte(gb);\n            frame += 2;\n        }\n        mask <<= 2;\n    }\n    return 0;\n}", "target": 1}
{"code": "Pl_ASCII85Decoder::flush()\n{\n    if (this->pos == 0)\n    {\n\tQTC::TC(\"libtests\", \"Pl_ASCII85Decoder no-op flush\");\n\treturn;\n    }\n    unsigned long lval = 0;\n    for (int i = 0; i < 5; ++i)\n    {\n\tlval *= 85;\n\tlval += (this->inbuf[i] - 33U);\n    }\n    unsigned char outbuf[4];\n    memset(outbuf, 0, 4);\n    for (int i = 3; i >= 0; --i)\n    {\n\toutbuf[i] = lval & 0xff;\n\tlval >>= 8;\n    }\n    QTC::TC(\"libtests\", \"Pl_ASCII85Decoder partial flush\",\n\t    (this->pos == 5) ? 0 : 1);\n    getNext()->write(outbuf, this->pos - 1);\n    this->pos = 0;\n    memset(this->inbuf, 117, 5);\n}", "target": 1}
{"code": "static inline bool mpOk(const QString &mp)\n{\n    return !mp.isEmpty() && mp.startsWith(\"/home/\"); \n}", "target": 1}
{"code": "int sas_smp_get_phy_events(struct sas_phy *phy)\n{\n\tint res;\n\tu8 *req;\n\tu8 *resp;\n\tstruct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);\n\tstruct domain_device *dev = sas_find_dev_by_rphy(rphy);\n\treq = alloc_smp_req(RPEL_REQ_SIZE);\n\tif (!req)\n\t\treturn -ENOMEM;\n\tresp = alloc_smp_resp(RPEL_RESP_SIZE);\n\tif (!resp) {\n\t\tkfree(req);\n\t\treturn -ENOMEM;\n\t}\n\treq[1] = SMP_REPORT_PHY_ERR_LOG;\n\treq[9] = phy->number;\n\tres = smp_execute_task(dev, req, RPEL_REQ_SIZE,\n\t\t\t            resp, RPEL_RESP_SIZE);\n\tif (!res)\n\t\tgoto out;\n\tphy->invalid_dword_count = scsi_to_u32(&resp[12]);\n\tphy->running_disparity_error_count = scsi_to_u32(&resp[16]);\n\tphy->loss_of_dword_sync_count = scsi_to_u32(&resp[20]);\n \tphy->phy_reset_problem_count = scsi_to_u32(&resp[24]);\n  out:\n \tkfree(resp);\n \treturn res;\n}", "target": 1}
{"code": "void *_zend_shared_memdup(void *source, size_t size, zend_bool free_source)\n{\n\tvoid *old_p, *retval;\n\tif ((old_p = zend_hash_index_find_ptr(&xlat_table, (zend_ulong)source)) != NULL) {\n\t\treturn old_p;\n\t}\n        retval = ZCG(mem);\n        ZCG(mem) = (void*)(((char*)ZCG(mem)) + ZEND_ALIGNED_SIZE(size));\n        memcpy(retval, source, size);\n        if (free_source) {\n                efree(source);\n        }\n       zend_shared_alloc_register_xlat_entry(source, retval);\n        return retval;\n }", "target": 1}
{"code": "Expr *sqlite3CreateColumnExpr(sqlite3 *db, SrcList *pSrc, int iSrc, int iCol){\n  Expr *p = sqlite3ExprAlloc(db, TK_COLUMN, 0, 0);\n  if( p ){\n    struct SrcList_item *pItem = &pSrc->a[iSrc];\n    p->y.pTab = pItem->pTab;\n    p->iTable = pItem->iCursor;\n    if( p->y.pTab->iPKey==iCol ){\n      p->iColumn = -1;\n    }else{\n      p->iColumn = (ynVar)iCol;\n      testcase( iCol==BMS );\n      testcase( iCol==BMS-1 );\n      pItem->colUsed |= ((Bitmask)1)<<(iCol>=BMS ? BMS-1 : iCol);\n    }\n  }\n  return p;\n}", "target": 1}
{"code": "static u8 BS_ReadByte(GF_BitStream *bs)\n{\n\tBool is_eos;\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tu8 res;\n\t\tif (bs->position >= bs->size) {\n\t\t\tif (bs->EndOfStream) bs->EndOfStream(bs->par);\n\t\t\tif (!bs->overflow_state) bs->overflow_state = 1;\n\t\t\treturn 0;\n\t\t}\n\t\tres = bs->original[bs->position++];\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\tif ((bs->nb_zeros==2) && (res==0x03) && (bs->position<bs->size) && (bs->original[bs->position]<0x04)) {\n\t\t\t\tbs->nb_zeros = 0;\n\t\t\t\tres = bs->original[bs->position++];\n\t\t\t}\n\t\t\tif (!res) bs->nb_zeros++;\n\t\t\telse bs->nb_zeros = 0;\n\t\t}\n\t\treturn res;\n\t}\n\tif (bs->cache_write)\n\t\tbs_flush_write_cache(bs);\n\tis_eos = gf_feof(bs->stream);\n\tif (!is_eos || bs->cache_read) {\n\t\tu8 res;\n\t\tBool loc_eos=GF_FALSE;\n\t\tassert(bs->position<=bs->size);\n\t\tbs->position++;\n\t\tres = gf_bs_load_byte(bs, &loc_eos);\n\t\tif (loc_eos) goto bs_eof;\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\tif ((bs->nb_zeros==2) && (res==0x03) && (bs->position<bs->size)) {\n\t\t\t\tu8 next = gf_bs_load_byte(bs, &loc_eos);\n\t\t\t\tif (next < 0x04) {\n\t\t\t\t\tbs->nb_zeros = 0;\n\t\t\t\t\tres = next;\n\t\t\t\t\tbs->position++;\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_seek(bs, bs->position);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!res) bs->nb_zeros++;\n\t\t\telse bs->nb_zeros = 0;\n\t\t}\n\t\treturn res;\n\t}\nbs_eof:\n\tif (bs->EndOfStream) {\n\t\tbs->EndOfStream(bs->par);\n\t\tif (!bs->overflow_state) bs->overflow_state = 1;\n\t} else {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to overread bitstream\\n\"));\n\t}\n\tassert(bs->position <= 1+bs->size);\n\treturn 0;\n}", "target": 1}
{"code": "static int key_notify_sa_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\tskb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));\n\thdr->sadb_msg_satype = pfkey_proto2satype(c->data.proto);\n\thdr->sadb_msg_type = SADB_FLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n \thdr->sadb_msg_version = PF_KEY_V2;\n \thdr->sadb_msg_errno = (uint8_t) 0;\n \thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n \tpfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\treturn 0;\n}", "target": 1}
{"code": "V4L2JpegEncodeAccelerator::JobRecord::JobRecord(\n    scoped_refptr<VideoFrame> input_frame,\n    scoped_refptr<VideoFrame> output_frame,\n    int quality,\n    int32_t task_id,\n    BitstreamBuffer* exif_buffer)\n    : input_frame(input_frame),\n       output_frame(output_frame),\n       quality(quality),\n       task_id(task_id),\n      output_shm(base::SharedMemoryHandle(), 0, true),  \n       exif_shm(nullptr) {\n   if (exif_buffer) {\n     exif_shm.reset(new UnalignedSharedMemory(exif_buffer->TakeRegion(),\n                                             exif_buffer->size(), false));\n    exif_offset = exif_buffer->offset();\n  }\n}", "target": 1}
{"code": "static bool imap_parser_read_string(struct imap_parser *parser,\n\t\t\t\t    const unsigned char *data, size_t data_size)\n{\n\tsize_t i;\n\tfor (i = parser->cur_pos; i < data_size; i++) {\n\t\tif (data[i] == '\"') {\n\t\t\timap_parser_save_arg(parser, data, i);\n\t\t\ti++; \n\t\t\tbreak;\n\t\t}\n\t\tif (data[i] == '\\\\') {\n\t\t\tif (i+1 == data_size) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (parser->str_first_escape < 0)\n\t\t\t\tparser->str_first_escape = i;\n\t\t\ti++;\n\t\t}\n\t\tif (is_linebreak(data[i]) &&\n\t\t    (parser->flags & IMAP_PARSE_FLAG_MULTILINE_STR) == 0) {\n\t\t\tparser->error = IMAP_PARSE_ERROR_BAD_SYNTAX;\n\t\t\tparser->error_msg = \"Missing '\\\"'\";\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\tparser->cur_pos = i;\n\treturn parser->cur_type == ARG_PARSE_NONE;\n}", "target": 1}
{"code": "static int sco_sock_bind(struct socket *sock, struct sockaddr *addr,\n\t\t\t int addr_len)\n{\n\tstruct sockaddr_sco *sa = (struct sockaddr_sco *) addr;\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\tBT_DBG(\"sk %p %pMR\", sk, &sa->sco_bdaddr);\n \tif (!addr || addr->sa_family != AF_BLUETOOTH)\n \t\treturn -EINVAL;\n \tlock_sock(sk);\n \tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\tbacpy(&sco_pi(sk)->src, &sa->sco_bdaddr);\n\tsk->sk_state = BT_BOUND;\ndone:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 1}
{"code": "static struct dst_entry *ip6_sk_dst_check(struct sock *sk,\n\t\t\t\t\t  struct dst_entry *dst,\n \t\t\t\t\t  const struct flowi6 *fl6)\n {\n \tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct rt6_info *rt = (struct rt6_info *)dst;\n \tif (!dst)\n \t\tgoto out;\n\tif (ip6_rt_check(&rt->rt6i_dst, &fl6->daddr, np->daddr_cache) ||\n#ifdef CONFIG_IPV6_SUBTREES\n\t    ip6_rt_check(&rt->rt6i_src, &fl6->saddr, np->saddr_cache) ||\n#endif\n\t    (fl6->flowi6_oif && fl6->flowi6_oif != dst->dev->ifindex)) {\n\t\tdst_release(dst);\n\t\tdst = NULL;\n\t}\nout:\n\treturn dst;\n}", "target": 1}
{"code": "gen_hash(codegen_scope *s, node *tree, int val, int limit)\n{\n  int slimit = GEN_VAL_STACK_MAX;\n  if (cursp() >= GEN_LIT_ARY_MAX) slimit = INT16_MAX;\n  int len = 0;\n  mrb_bool update = FALSE;\n  while (tree) {\n    if (nint(tree->car->car->car) == NODE_KW_REST_ARGS) {\n      if (len > 0) {\n        pop_n(len*2);\n        if (!update) {\n          genop_2(s, OP_HASH, cursp(), len);\n        }\n        else {\n          pop();\n          genop_2(s, OP_HASHADD, cursp(), len);\n        }\n        push();\n      }\n      codegen(s, tree->car->cdr, val);\n      if (len > 0 || update) {\n        pop(); pop();\n        genop_1(s, OP_HASHCAT, cursp());\n        push();\n      }\n      update = TRUE;\n      len = 0;\n    }\n    else {\n      codegen(s, tree->car->car, val);\n      codegen(s, tree->car->cdr, val);\n      len++;\n    }\n    tree = tree->cdr;\n    if (val && cursp() >= slimit) {\n      pop_n(len*2);\n      if (!update) {\n        genop_2(s, OP_HASH, cursp(), len);\n      }\n      else {\n        pop();\n        genop_2(s, OP_HASHADD, cursp(), len);\n      }\n      push();\n      update = TRUE;\n      len = 0;\n    }\n  }\n  if (update) {\n    if (len > 0) {\n      pop_n(len*2+1);\n      genop_2(s, OP_HASHADD, cursp(), len);\n      push();\n    }\n    return -1;                  \n  }\n  if (update) return -1;\n  return len;\n}", "target": 1}
{"code": "XvQueryAdaptors(\n    Display *dpy,\n    Window window,\n    unsigned int *p_nAdaptors,\n    XvAdaptorInfo **p_pAdaptors)\n{\n    XExtDisplayInfo *info = xv_find_display(dpy);\n    xvQueryAdaptorsReq *req;\n    xvQueryAdaptorsReply rep;\n     size_t size;\n     unsigned int ii, jj;\n     char *name;\n     XvAdaptorInfo *pas = NULL, *pa;\n     XvFormat *pfs, *pf;\n     char *buffer = NULL;\n        char *buffer;\n        char *string;\n        xvAdaptorInfo *pa;\n        xvFormat *pf;\n    } u;", "target": 1}
{"code": "int X509_cmp_time(const ASN1_TIME *ctm, time_t *cmp_time)\n{\n    char *str;\n     ASN1_TIME atm;\n     long offset;\n     char buff1[24], buff2[24], *p;\n    int i, j;\n     p = buff1;\n    i = ctm->length;\n     str = (char *)ctm->data;\n     if (ctm->type == V_ASN1_UTCTIME) {\n        if ((i < 11) || (i > 17))\n             return 0;\n         memcpy(p, str, 10);\n         p += 10;\n         str += 10;\n     } else {\n        if (i < 13)\n             return 0;\n         memcpy(p, str, 12);\n         p += 12;\n         str += 12;\n     }\n     if ((*str == 'Z') || (*str == '-') || (*str == '+')) {\n         *(p++) = '0';\n         *(p++) = '0';\n     } else {\n         *(p++) = *(str++);\n         *(p++) = *(str++);\n        if (*str == '.') {\n             str++;\n            while ((*str >= '0') && (*str <= '9'))\n                str++;\n         }\n     }\n     *(p++) = 'Z';\n     *(p++) = '\\0';\n    if (*str == 'Z')\n         offset = 0;\n    else {\n         if ((*str != '+') && (*str != '-'))\n             return 0;\n         offset = ((str[1] - '0') * 10 + (str[2] - '0')) * 60;\n         offset += (str[3] - '0') * 10 + (str[4] - '0');\n         if (*str == '-')\n            offset = -offset;\n    }\n    atm.type = ctm->type;\n    atm.flags = 0;\n    atm.length = sizeof(buff2);\n    atm.data = (unsigned char *)buff2;\n    if (X509_time_adj(&atm, offset * 60, cmp_time) == NULL)\n        return 0;\n    if (ctm->type == V_ASN1_UTCTIME) {\n        i = (buff1[0] - '0') * 10 + (buff1[1] - '0');\n        if (i < 50)\n            i += 100;           \n        j = (buff2[0] - '0') * 10 + (buff2[1] - '0');\n        if (j < 50)\n            j += 100;\n        if (i < j)\n            return -1;\n        if (i > j)\n            return 1;\n    }\n    i = strcmp(buff1, buff2);\n    if (i == 0)                 \n        return -1;\n    else\n        return i;\n}", "target": 1}
{"code": "batadv_frag_merge_packets(struct hlist_head *chain, struct sk_buff *skb)\n{\n\tstruct batadv_frag_packet *packet;\n\tstruct batadv_frag_list_entry *entry;\n\tstruct sk_buff *skb_out = NULL;\n\tint size, hdr_size = sizeof(struct batadv_frag_packet);\n\tpacket = (struct batadv_frag_packet *)skb->data;\n\tsize = ntohs(packet->total_size);\n\tif (size > batadv_frag_size_limit())\n\t\tgoto free;\n\tentry = hlist_entry(chain->first, struct batadv_frag_list_entry, list);\n\thlist_del(&entry->list);\n\tskb_out = entry->skb;\n \tkfree(entry);\n\tif (pskb_expand_head(skb_out, 0, size - skb->len, GFP_ATOMIC) < 0) {\n \t\tkfree_skb(skb_out);\n \t\tskb_out = NULL;\n \t\tgoto free;\n\t}\n\tskb_pull_rcsum(skb_out, hdr_size);\n\tmemmove(skb_out->data - ETH_HLEN, skb_mac_header(skb_out), ETH_HLEN);\n\tskb_set_mac_header(skb_out, -ETH_HLEN);\n\tskb_reset_network_header(skb_out);\n\tskb_reset_transport_header(skb_out);\n\thlist_for_each_entry(entry, chain, list) {\n\t\tsize = entry->skb->len - hdr_size;\n\t\tmemcpy(skb_put(skb_out, size), entry->skb->data + hdr_size,\n\t\t       size);\n\t}\nfree:\n\tbatadv_frag_clear_chain(chain);\n\treturn skb_out;\n}", "target": 1}
{"code": "MagickExport MagickBooleanType IsOptionMember(const char *option,\n  const char *options)\n{\n  char\n    **option_list,\n    *string;\n  int\n    number_options;\n  MagickBooleanType\n    member;\n  register ssize_t\n    i;\n  if (options == (const char *) NULL)\n    return(MagickFalse);\n  string=ConstantString(options);\n  (void) SubstituteString(&string,\",\",\" \");\n  option_list=StringToArgv(string,&number_options);\n  string=DestroyString(string);\n  if (option_list == (char **) NULL)\n    return(MagickFalse);\n  member=MagickFalse;\n  for (i=1; i < (ssize_t) number_options; i++)\n  {\n    if ((*option_list[i] == '!') &&\n        (LocaleCompare(option,option_list[i]+1) == 0))\n      break;\n    if (GlobExpression(option,option_list[i],MagickTrue) != MagickFalse)\n      {\n        member=MagickTrue;\n        break;\n      }\n    option_list[i]=DestroyString(option_list[i]);\n  }\n  for ( ; i < (ssize_t) number_options; i++)\n    option_list[i]=DestroyString(option_list[i]);\n  option_list=(char **) RelinquishMagickMemory(option_list);\n  return(member);\n}", "target": 1}
{"code": " static int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps)\n {\n \tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n \tmemcpy(&kvm->arch.vpit->pit_state, ps, sizeof(struct kvm_pit_state));\n\tkvm_pit_load_count(kvm, 0, ps->channels[0].count, 0);\n \tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n \treturn 0;\n }", "target": 1}
{"code": "void MediaStreamDispatcherHost::DoOpenDevice(\n    int32_t page_request_id,\n    const std::string& device_id,\n    blink::MediaStreamType type,\n    OpenDeviceCallback callback,\n    MediaDeviceSaltAndOrigin salt_and_origin) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  if (!MediaStreamManager::IsOriginAllowed(render_process_id_,\n                                           salt_and_origin.origin)) {\n    std::move(callback).Run(false , std::string(),\n                            blink::MediaStreamDevice());\n    return;\n   }\n   media_stream_manager_->OpenDevice(\n      render_process_id_, render_frame_id_, page_request_id, requester_id_,\n       device_id, type, std::move(salt_and_origin), std::move(callback),\n       base::BindRepeating(&MediaStreamDispatcherHost::OnDeviceStopped,\n                           weak_factory_.GetWeakPtr()));\n}", "target": 1}
{"code": "Error HeifContext::get_id_of_non_virtual_child_image(heif_item_id id, heif_item_id& out) const\n{\n  std::string image_type = m_heif_file->get_item_type(id);\n  if (image_type==\"grid\" ||\n      image_type==\"iden\" ||\n      image_type==\"iovl\") {\n    auto iref_box = m_heif_file->get_iref_box();\n    std::vector<heif_item_id> image_references = iref_box->get_references(id, fourcc(\"dimg\"));\n    if (image_references.empty()) {\n      return Error(heif_error_Invalid_input,\n                   heif_suberror_No_item_data,\n                   \"Derived image does not reference any other image items\");\n    }\n    else {\n      return get_id_of_non_virtual_child_image(image_references[0], out);\n    }\n  }\n  else {\n    out = id;\n    return Error::Ok;\n  }\n}", "target": 1}
{"code": "bool PDFiumEngine::HandleEvent(const pp::InputEvent& event) {\n  DCHECK(!defer_page_unload_);\n  defer_page_unload_ = true;\n  bool rv = false;\n  switch (event.GetType()) {\n    case PP_INPUTEVENT_TYPE_MOUSEDOWN:\n      rv = OnMouseDown(pp::MouseInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_MOUSEUP:\n      rv = OnMouseUp(pp::MouseInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_MOUSEMOVE:\n      rv = OnMouseMove(pp::MouseInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_KEYDOWN:\n      rv = OnKeyDown(pp::KeyboardInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_KEYUP:\n      rv = OnKeyUp(pp::KeyboardInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_CHAR:\n      rv = OnChar(pp::KeyboardInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_TOUCHSTART: {\n      KillTouchTimer(next_touch_timer_id_);\n      pp::TouchInputEvent touch_event(event);\n      if (touch_event.GetTouchCount(PP_TOUCHLIST_TYPE_TARGETTOUCHES) == 1)\n        ScheduleTouchTimer(touch_event);\n      break;\n    }\n    case PP_INPUTEVENT_TYPE_TOUCHEND:\n      KillTouchTimer(next_touch_timer_id_);\n      break;\n    case PP_INPUTEVENT_TYPE_TOUCHMOVE:\n      KillTouchTimer(next_touch_timer_id_);\n    default:\n      break;\n  }\n   DCHECK(defer_page_unload_);\n   defer_page_unload_ = false;\n  for (int page_index : deferred_page_unloads_)\n     pages_[page_index]->Unload();\n  deferred_page_unloads_.clear();\n   return rv;\n }", "target": 1}
{"code": "get_word_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n  }\n  return 1;\n}", "target": 1}
{"code": "static int ng_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_ng *pkt;\n\tconst char *ptr;\n\tsize_t alloclen;\n\tpkt = git__malloc(sizeof(*pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n \tpkt->ref = NULL;\n \tpkt->type = GIT_PKT_NG;\n \tline += 3; \n\tif (!(ptr = strchr(line, ' ')))\n \t\tgoto out_err;\n \tlen = ptr - line;\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->ref = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->ref);\n \tmemcpy(pkt->ref, line, len);\n \tpkt->ref[len] = '\\0';\n \tline = ptr + 1;\n\tif (!(ptr = strchr(line, '\\n')))\n \t\tgoto out_err;\n \tlen = ptr - line;\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->msg = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->msg);\n\tmemcpy(pkt->msg, line, len);\n\tpkt->msg[len] = '\\0';\n\t*out = (git_pkt *)pkt;\n\treturn 0;\nout_err:\n\tgiterr_set(GITERR_NET, \"invalid packet line\");\n\tgit__free(pkt->ref);\n\tgit__free(pkt);\n\treturn -1;\n}", "target": 1}
{"code": " void BeginInstallWithManifestFunction::OnParseSuccess(\n     const SkBitmap& icon, DictionaryValue* parsed_manifest) {\n  CHECK(parsed_manifest);\n  icon_ = icon;\n  parsed_manifest_.reset(parsed_manifest);\n  std::string init_errors;\n  dummy_extension_ = Extension::Create(\n      FilePath(),\n      Extension::INTERNAL,\n      *static_cast<DictionaryValue*>(parsed_manifest_.get()),\n      Extension::NO_FLAGS,\n      &init_errors);\n  if (!dummy_extension_.get()) {\n    OnParseFailure(MANIFEST_ERROR, std::string(kInvalidManifestError));\n    return;\n  }\n   if (icon_.empty())\n     icon_ = Extension::GetDefaultIcon(dummy_extension_->is_app());\n   ShowExtensionInstallDialog(profile(),\n                              this,\n                              dummy_extension_.get(),\n                             &icon_,\n                             dummy_extension_->GetPermissionMessageStrings(),\n                             ExtensionInstallUI::INSTALL_PROMPT);\n}", "target": 1}
{"code": "GPMF_ERR IsValidSize(GPMF_stream *ms, uint32_t size) \n {\n \tif (ms)\n \t{\n\t\tint32_t nestsize = (int32_t)ms->nest_size[ms->nest_level];\n \t\tif (nestsize == 0 && ms->nest_level == 0)\n \t\t\tnestsize = ms->buffer_size_longs;\n\t\tif (size + 2 <= nestsize) return GPMF_OK;\n\t}\n\treturn GPMF_ERROR_BAD_STRUCTURE;\n}", "target": 1}
{"code": "static int bond_ipsec_add_sa(struct xfrm_state *xs)\n{\n\tstruct net_device *bond_dev = xs->xso.dev;\n\tstruct bonding *bond;\n\tstruct slave *slave;\n\tint err;\n\tif (!bond_dev)\n\t\treturn -EINVAL;\n\trcu_read_lock();\n\tbond = netdev_priv(bond_dev);\n\tslave = rcu_dereference(bond->curr_active_slave);\n\txs->xso.real_dev = slave->dev;\n\tbond->xs = xs;\n\tif (!(slave->dev->xfrmdev_ops\n\t      && slave->dev->xfrmdev_ops->xdo_dev_state_add)) {\n\t\tslave_warn(bond_dev, slave->dev, \"Slave does not support ipsec offload\\n\");\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\terr = slave->dev->xfrmdev_ops->xdo_dev_state_add(xs);\n\trcu_read_unlock();\n\treturn err;\n}", "target": 1}
{"code": " static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)\n {\n\trcu_read_lock();\n\t__ptrace_link(child, new_parent, __task_cred(new_parent));\n\trcu_read_unlock();\n }", "target": 1}
{"code": " int devmem_is_allowed(unsigned long pagenr)\n {\n\tif (pagenr < 256)\n\t\treturn 1;\n\tif (iomem_is_exclusive(pagenr << PAGE_SHIFT))\n \t\treturn 0;\n\tif (!page_is_ram(pagenr))\n\t\treturn 1;\n\treturn 0;\n }", "target": 1}
{"code": " static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)\n {\n \tint rlen, remain;\n\tdpIOCtxPtr dctx;\n\tdynamicPtr *dp;\n \tdctx = (dpIOCtxPtr) ctx;\n \tdp = dctx->dp;\n \tremain = dp->logicalSize - dp->pos;\n \tif(remain >= len) {\n \t\trlen = len;\n \t} else {\n \t\tif(remain <= 0) {\n\t\t\treturn 0; \n \t\t}\n \t\trlen = remain;\n \t}\n \tmemcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);\n \tdp->pos += rlen;\n\treturn rlen;\n}", "target": 1}
{"code": "Result ZipFile::uncompressEntry (int index, const File& targetDirectory, bool shouldOverwriteFiles)\n{\n    auto* zei = entries.getUnchecked (index);\n   #if JUCE_WINDOWS\n    auto entryPath = zei->entry.filename;\n   #else\n    auto entryPath = zei->entry.filename.replaceCharacter ('\\\\', '/');\n   #endif\n    if (entryPath.isEmpty())\n        return Result::ok();\n    auto targetFile = targetDirectory.getChildFile (entryPath);\n    if (entryPath.endsWithChar ('/') || entryPath.endsWithChar ('\\\\'))\n        return targetFile.createDirectory(); \n    std::unique_ptr<InputStream> in (createStreamForEntry (index));\n    if (in == nullptr)\n        return Result::fail (\"Failed to open the zip file for reading\");\n    if (targetFile.exists())\n    {\n        if (! shouldOverwriteFiles)\n            return Result::ok();\n        if (! targetFile.deleteFile())\n            return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\n    }\n    if (! targetFile.getParentDirectory().createDirectory())\n        return Result::fail (\"Failed to create target folder: \" + targetFile.getParentDirectory().getFullPathName());\n    if (zei->entry.isSymbolicLink)\n    {\n        String originalFilePath (in->readEntireStreamAsString()\n                                    .replaceCharacter (L'/', File::getSeparatorChar()));\n        if (! File::createSymbolicLink (targetFile, originalFilePath, true))\n            return Result::fail (\"Failed to create symbolic link: \" + originalFilePath);\n    }\n    else\n    {\n        FileOutputStream out (targetFile);\n        if (out.failedToOpen())\n            return Result::fail (\"Failed to write to target file: \" + targetFile.getFullPathName());\n        out << *in;\n    }\n    targetFile.setCreationTime (zei->entry.fileTime);\n    targetFile.setLastModificationTime (zei->entry.fileTime);\n    targetFile.setLastAccessTime (zei->entry.fileTime);\n    return Result::ok();\n}", "target": 1}
{"code": "smb_fdata(netdissect_options *ndo,\n          const u_char *buf, const char *fmt, const u_char *maxbuf,\n          int unicodestr)\n{\n    static int depth = 0;\n    char s[128];\n    char *p;\n    while (*fmt) {\n\tswitch (*fmt) {\n\tcase '*':\n\t    fmt++;\n \t    while (buf < maxbuf) {\n \t\tconst u_char *buf2;\n \t\tdepth++;\n\t\tbuf2 = smb_fdata(ndo, buf, fmt, maxbuf, unicodestr);\n \t\tdepth--;\n \t\tif (buf2 == NULL)\n \t\t    return(NULL);\n\t\tif (buf2 == buf)\n\t\t    return(buf);\n\t\tbuf = buf2;\n\t    }\n\t    return(buf);\n\tcase '|':\n\t    fmt++;\n\t    if (buf >= maxbuf)\n\t\treturn(buf);\n\t    break;\n\tcase '%':\n\t    fmt++;\n\t    buf = maxbuf;\n\t    break;\n\tcase '#':\n\t    fmt++;\n\t    return(buf);\n\t    break;\n\tcase '[':\n\t    fmt++;\n\t    if (buf >= maxbuf)\n\t\treturn(buf);\n\t    memset(s, 0, sizeof(s));\n\t    p = strchr(fmt, ']');\n\t    if ((size_t)(p - fmt + 1) > sizeof(s)) {\n\t\treturn(buf);\n\t    }\n\t    strncpy(s, fmt, p - fmt);\n\t    s[p - fmt] = '\\0';\n\t    fmt = p + 1;\n\t    buf = smb_fdata1(ndo, buf, s, maxbuf, unicodestr);\n\t    if (buf == NULL)\n\t\treturn(NULL);\n\t    break;\n\tdefault:\n\t    ND_PRINT((ndo, \"%c\", *fmt));\n\t    fmt++;\n\t    break;\n\t}\n    }\n    if (!depth && buf < maxbuf) {\n\tsize_t len = PTR_DIFF(maxbuf, buf);\n\tND_PRINT((ndo, \"Data: (%lu bytes)\\n\", (unsigned long)len));\n\tsmb_print_data(ndo, buf, len);\n\treturn(buf + len);\n    }\n    return(buf);\n}", "target": 1}
{"code": "static ssize_t store_int_with_restart(struct device *s,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t size)\n{\n\tssize_t ret = device_store_int(s, attr, buf, size);\n\tmce_restart();\n\treturn ret;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& grad_in = context->input(1);\n    const Tensor& argmax = context->input(2);\n    PoolParameters params{context,\n                          ksize_,\n                          stride_,\n                          padding_,\n                          {},\n                          FORMAT_NHWC,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n    TensorShape out_shape({params.tensor_in_batch, params.tensor_in_rows,\n                           params.tensor_in_cols, params.depth});\n    Tensor* grad_out = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {0}, 0, out_shape, &grad_out));\n    LaunchMaxPoolingGradWithArgmax<Device, T>::launch(\n        context, params, grad_in, argmax, grad_out, include_batch_in_index_);\n  }", "target": 1}
{"code": "convert(\n    Imaging imOut, Imaging imIn, const char *mode, ImagingPalette palette, int dither) {\n    ImagingSectionCookie cookie;\n    ImagingShuffler convert;\n    int y;\n    if (!imIn) {\n        return (Imaging)ImagingError_ModeError();\n    }\n    if (!mode) {\n        if (!imIn->palette) {\n            return (Imaging)ImagingError_ModeError();\n        }\n        mode = imIn->palette->mode;\n    } else {\n        if (!strcmp(imIn->mode, mode)) {\n            return ImagingCopy2(imOut, imIn);\n        }\n    }\n    if (strcmp(imIn->mode, \"P\") == 0 || strcmp(imIn->mode, \"PA\") == 0) {\n        return frompalette(imOut, imIn, mode);\n    }\n    if (strcmp(mode, \"P\") == 0 || strcmp(mode, \"PA\") == 0) {\n        return topalette(imOut, imIn, mode, palette, dither);\n    }\n    if (dither && strcmp(mode, \"1\") == 0) {\n        return tobilevel(imOut, imIn, dither);\n    }\n    convert = NULL;\n    for (y = 0; converters[y].from; y++) {\n        if (!strcmp(imIn->mode, converters[y].from) &&\n            !strcmp(mode, converters[y].to)) {\n            convert = converters[y].convert;\n            break;\n        }\n    }\n    if (!convert) {\n#ifdef notdef\n        return (Imaging)ImagingError_ValueError(\"conversion not supported\");\n#else\n        static char buf[100];\n        sprintf(buf, \"conversion from %.10s to %.10s not supported\", imIn->mode, mode);\n        return (Imaging)ImagingError_ValueError(buf);\n#endif\n    }\n    imOut = ImagingNew2Dirty(mode, imOut, imIn);\n    if (!imOut) {\n        return NULL;\n    }\n    ImagingSectionEnter(&cookie);\n    for (y = 0; y < imIn->ysize; y++) {\n        (*convert)((UINT8 *)imOut->image[y], (UINT8 *)imIn->image[y], imIn->xsize);\n    }\n    ImagingSectionLeave(&cookie);\n    return imOut;\n}", "target": 1}
{"code": "static void RemoveResolutionFromResourceBlock(StringInfo *bim_profile)\n{\n  register const unsigned char\n    *p;\n  size_t\n    length;\n  unsigned char\n    *datum;\n  unsigned int\n    count,\n    long_sans;\n  unsigned short\n    id,\n    short_sans;\n  length=GetStringInfoLength(bim_profile);\n  if (length < 16)\n    return;\n  datum=GetStringInfoDatum(bim_profile);\n  for (p=datum; (p >= datum) && (p < (datum+length-16)); )\n  {\n     register unsigned char\n       *q;\n     q=(unsigned char *) p;\n     if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n      break;\n     p=PushLongPixel(MSBEndian,p,&long_sans);\n     p=PushShortPixel(MSBEndian,p,&id);\n     p=PushShortPixel(MSBEndian,p,&short_sans);\n     p=PushLongPixel(MSBEndian,p,&count);\n    if ((id == 0x000003ed) && (PSDQuantum(count) < (ssize_t) (length-12)))\n       {\n        (void) CopyMagickMemory(q,q+PSDQuantum(count)+12,length-\n          (PSDQuantum(count)+12)-(q-datum));\n        SetStringInfoLength(bim_profile,length-(PSDQuantum(count)+12));\n         break;\n       }\n     p+=count;\n    if ((count & 0x01) != 0)\n      p++;\n   }\n }", "target": 1}
{"code": "static ssize_t gadget_dev_desc_UDC_store(struct config_item *item,\n\t\tconst char *page, size_t len)\n{\n\tstruct gadget_info *gi = to_gadget_info(item);\n\tchar *name;\n\tint ret;\n\tname = kstrdup(page, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\tif (name[len - 1] == '\\n')\n\t\tname[len - 1] = '\\0';\n\tmutex_lock(&gi->lock);\n\tif (!strlen(name)) {\n\t\tret = unregister_gadget(gi);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tkfree(name);\n\t} else {\n\t\tif (gi->composite.gadget_driver.udc_name) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto err;\n\t\t}\n\t\tgi->composite.gadget_driver.udc_name = name;\n\t\tret = usb_gadget_probe_driver(&gi->composite.gadget_driver);\n\t\tif (ret) {\n\t\t\tgi->composite.gadget_driver.udc_name = NULL;\n\t\t\tgoto err;\n\t\t}\n\t}\n\tmutex_unlock(&gi->lock);\n\treturn len;\nerr:\n\tkfree(name);\n\tmutex_unlock(&gi->lock);\n\treturn ret;\n}", "target": 1}
{"code": "  bool matches(const Http::RequestHeaderMap& headers) const override {\n    if (BaseMatcherImpl::matchRoute(headers)) {\n      const Http::HeaderString& path = headers.Path()->value();\n      const absl::string_view query_string = Http::Utility::findQueryStringStart(path);\n      absl::string_view path_view = path.getStringView();\n      path_view.remove_suffix(query_string.length());\n      if (path_matcher_->match(path_view)) {\n        ENVOY_LOG(debug, \"Regex requirement '{}' matched.\", regex_str_);\n        return true;\n      }\n    }\n    return false;\n  }", "target": 1}
{"code": "dns_stricmp(const char* str1, const char* str2)\n{\n  char c1, c2;\n  *----------------------------------------------------------------------------*/\nstatic struct udp_pcb        *dns_pcb;\n static u8_t                   dns_seqno;\n static struct dns_table_entry dns_table[DNS_TABLE_SIZE];\n static struct dns_req_entry   dns_requests[DNS_MAX_REQUESTS];\n        if (c1_upc != c2_upc) {\n          return 1;\n        }\n      } else {\n        return 1;\n      }", "target": 1}
{"code": "void wifi_cleanup(wifi_handle handle, wifi_cleaned_up_handler handler)\n{\n    hal_info *info = getHalInfo(handle);\n char buf[64];\n    info->cleaned_up_handler = handler;\n if (write(info->cleanup_socks[0], \"Exit\", 4) < 1) {\n        ALOGE(\"could not write to the cleanup socket\");\n } else {\n        memset(buf, 0, sizeof(buf));\n int result = read(info->cleanup_socks[0], buf, sizeof(buf));\n        ALOGE(\"%s: Read after POLL returned %d, error no = %d\", __FUNCTION__, result, errno);\n if (strncmp(buf, \"Done\", 4) == 0) {\n            ALOGE(\"Event processing terminated\");\n } else {\n            ALOGD(\"Rx'ed %s\", buf);\n }\n }\n    info->clean_up = true;\n    pthread_mutex_lock(&info->cb_lock);\n int bad_commands = 0;\n for (int i = 0; i < info->num_event_cb; i++) {\n        cb_info *cbi = &(info->event_cb[i]);\n WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;\n        ALOGI(\"Command left in event_cb %p:%s\", cmd, (cmd ? cmd->getType(): \"\"));\n }\n while (info->num_cmd > bad_commands) {\n int num_cmd = info->num_cmd;\n        cmd_info *cmdi = &(info->cmd[bad_commands]);\n WifiCommand *cmd = cmdi->cmd;\n if (cmd != NULL) {\n            ALOGI(\"Cancelling command %p:%s\", cmd, cmd->getType());\n             pthread_mutex_unlock(&info->cb_lock);\n             cmd->cancel();\n             pthread_mutex_lock(&info->cb_lock);\n            cmd->releaseRef();\n             if (num_cmd == info->num_cmd) {\n                 ALOGI(\"Cancelling command %p:%s did not work\", cmd, (cmd ? cmd->getType(): \"\"));\n                 bad_commands++;\n             }\n         }\n     }\n for (int i = 0; i < info->num_event_cb; i++) {\n        cb_info *cbi = &(info->event_cb[i]);\n WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;\n        ALOGE(\"Leaked command %p\", cmd);\n }\n    pthread_mutex_unlock(&info->cb_lock);\n    internal_cleaned_up_handler(handle);\n}", "target": 1}
{"code": "setup_efi_state(struct boot_params *params, unsigned long params_load_addr,\n\t\tunsigned int efi_map_offset, unsigned int efi_map_sz,\n\t\tunsigned int efi_setup_data_offset)\n{\n\tstruct efi_info *current_ei = &boot_params.efi_info;\n\tstruct efi_info *ei = &params->efi_info;\n\tif (!current_ei->efi_memmap_size)\n\t\treturn 0;\n \tif (efi_enabled(EFI_OLD_MEMMAP))\n \t\treturn 0;\n \tei->efi_loader_signature = current_ei->efi_loader_signature;\n \tei->efi_systab = current_ei->efi_systab;\n \tei->efi_systab_hi = current_ei->efi_systab_hi;\n\tei->efi_memdesc_version = current_ei->efi_memdesc_version;\n\tei->efi_memdesc_size = efi_get_runtime_map_desc_size();\n\tsetup_efi_info_memmap(params, params_load_addr, efi_map_offset,\n\t\t\t      efi_map_sz);\n\tprepare_add_efi_setup_data(params, params_load_addr,\n\t\t\t\t   efi_setup_data_offset);\n\treturn 0;\n}", "target": 1}
{"code": "static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)\n {\n     int i, j, v;\n     if (get_bits1(gb)) {\n         for (i = 0; i < 64; i++) {\n             v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->intra_matrix[j]        = v;\n            s->chroma_intra_matrix[j] = v;\n        }\n     }\n     if (get_bits1(gb)) {\n         for (i = 0; i < 64; i++) {\n             get_bits(gb, 8);\n         }\n     }\n     if (get_bits1(gb)) {\n         for (i = 0; i < 64; i++) {\n             v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->chroma_intra_matrix[j] = v;\n        }\n     }\n     if (get_bits1(gb)) {\n         for (i = 0; i < 64; i++) {\n             get_bits(gb, 8);\n         }\n     }\n     next_start_code_studio(gb);\n }", "target": 1}
{"code": "i915_gem_execbuffer2_ioctl(struct drm_device *dev, void *data,\n\t\t\t   struct drm_file *file)\n{\n\tstruct drm_i915_gem_execbuffer2 *args = data;\n\tstruct drm_i915_gem_exec_object2 *exec2_list;\n\tstruct drm_syncobj **fences = NULL;\n\tconst size_t count = args->buffer_count;\n\tint err;\n\tif (!check_buffer_count(count)) {\n\t\tDRM_DEBUG(\"execbuf2 with %zd buffers\\n\", count);\n\t\treturn -EINVAL;\n\t}\n\tif (!i915_gem_check_execbuffer(args))\n\t\treturn -EINVAL;\n\texec2_list = kvmalloc_array(count + 1, eb_element_size(),\n\t\t\t\t    __GFP_NOWARN | GFP_KERNEL);\n\tif (exec2_list == NULL) {\n\t\tDRM_DEBUG(\"Failed to allocate exec list for %zd buffers\\n\",\n\t\t\t  count);\n\t\treturn -ENOMEM;\n\t}\n\tif (copy_from_user(exec2_list,\n\t\t\t   u64_to_user_ptr(args->buffers_ptr),\n\t\t\t   sizeof(*exec2_list) * count)) {\n\t\tDRM_DEBUG(\"copy %zd exec entries failed\\n\", count);\n\t\tkvfree(exec2_list);\n\t\treturn -EFAULT;\n\t}\n\tif (args->flags & I915_EXEC_FENCE_ARRAY) {\n\t\tfences = get_fence_array(args, file);\n\t\tif (IS_ERR(fences)) {\n\t\t\tkvfree(exec2_list);\n\t\t\treturn PTR_ERR(fences);\n\t\t}\n\t}\n\terr = i915_gem_do_execbuffer(dev, file, args, exec2_list, fences);\n\tif (args->flags & __EXEC_HAS_RELOC) {\n\t\tstruct drm_i915_gem_exec_object2 __user *user_exec_list =\n\t\t\tu64_to_user_ptr(args->buffers_ptr);\n\t\tunsigned int i;\n\t\tuser_access_begin();\n\t\tfor (i = 0; i < args->buffer_count; i++) {\n\t\t\tif (!(exec2_list[i].offset & UPDATE))\n\t\t\t\tcontinue;\n\t\t\texec2_list[i].offset =\n\t\t\t\tgen8_canonical_addr(exec2_list[i].offset & PIN_OFFSET_MASK);\n\t\t\tunsafe_put_user(exec2_list[i].offset,\n\t\t\t\t\t&user_exec_list[i].offset,\n\t\t\t\t\tend_user);\n\t\t}\nend_user:\n\t\tuser_access_end();\n\t}\n\targs->flags &= ~__I915_EXEC_UNKNOWN_FLAGS;\n\tput_fence_array(args, fences);\n\tkvfree(exec2_list);\n\treturn err;\n}", "target": 1}
{"code": "nm_wildcard_match_check(const char *str, const char *const *patterns, guint num_patterns)\n{\n    gboolean has_optional     = FALSE;\n    gboolean has_any_optional = FALSE;\n    guint    i;\n    for (i = 0; i < num_patterns; i++) {\n        gboolean    is_inverted;\n        gboolean    is_mandatory;\n        gboolean    match;\n        const char *p;\n        _pattern_parse(patterns[i], &p, &is_inverted, &is_mandatory);\n        match = (fnmatch(p, str, 0) == 0);\n        if (is_inverted)\n            match = !match;\n        if (is_mandatory) {\n            if (!match)\n                return FALSE;\n        } else {\n            has_any_optional = TRUE;\n            if (match)\n                has_optional = TRUE;\n        }\n    }\n    return has_optional || !has_any_optional;\n}", "target": 1}
{"code": "static uint64_t pci_read(void *opaque, hwaddr addr, unsigned int size)\n{\n    AcpiPciHpState *s = opaque;\n     uint32_t val = 0;\n     int bsel = s->hotplug_select;\n    if (bsel < 0 || bsel > ACPI_PCIHP_MAX_HOTPLUG_BUS) {\n         return 0;\n     }\n    switch (addr) {\n    case PCI_UP_BASE:\n        val = s->acpi_pcihp_pci_status[bsel].up;\n        if (!s->legacy_piix) {\n            s->acpi_pcihp_pci_status[bsel].up = 0;\n        }\n        ACPI_PCIHP_DPRINTF(\"pci_up_read %\" PRIu32 \"\\n\", val);\n        break;\n    case PCI_DOWN_BASE:\n        val = s->acpi_pcihp_pci_status[bsel].down;\n        ACPI_PCIHP_DPRINTF(\"pci_down_read %\" PRIu32 \"\\n\", val);\n        break;\n    case PCI_EJ_BASE:\n        ACPI_PCIHP_DPRINTF(\"pci_features_read %\" PRIu32 \"\\n\", val);\n        break;\n    case PCI_RMV_BASE:\n        val = s->acpi_pcihp_pci_status[bsel].hotplug_enable;\n        ACPI_PCIHP_DPRINTF(\"pci_rmv_read %\" PRIu32 \"\\n\", val);\n        break;\n    case PCI_SEL_BASE:\n        val = s->hotplug_select;\n        ACPI_PCIHP_DPRINTF(\"pci_sel_read %\" PRIu32 \"\\n\", val);\n    default:\n        break;\n    }\n    return val;\n}", "target": 1}
{"code": "static plist_t parse_dict_node(struct bplist_data *bplist, const char** bnode, uint64_t size)\n{\n    uint64_t j;\n    uint64_t str_i = 0, str_j = 0;\n    uint64_t index1, index2;\n    plist_data_t data = plist_new_plist_data();\n    const char *const end_data = bplist->data + bplist->size;\n    const char *index1_ptr = NULL;\n    const char *index2_ptr = NULL;\n    data->type = PLIST_DICT;\n    data->length = size;\n    plist_t node = node_create(NULL, data);\n    for (j = 0; j < data->length; j++) {\n        str_i = j * bplist->dict_size;\n        str_j = (j + size) * bplist->dict_size;\n        index1_ptr = (*bnode) + str_i;\n        index2_ptr = (*bnode) + str_j;\n        if ((index1_ptr < bplist->data || index1_ptr + bplist->dict_size >= end_data) ||\n            (index2_ptr < bplist->data || index2_ptr + bplist->dict_size >= end_data)) {\n            plist_free(node);\n            return NULL;\n        }\n        index1 = UINT_TO_HOST(index1_ptr, bplist->dict_size);\n        index2 = UINT_TO_HOST(index2_ptr, bplist->dict_size);\n        if (index1 >= bplist->num_objects) {\n            plist_free(node);\n            return NULL;\n        }\n        if (index2 >= bplist->num_objects) {\n            plist_free(node);\n            return NULL;\n        }\n        plist_t key = parse_bin_node_at_index(bplist, index1);\n        if (!key) {\n            plist_free(node);\n            return NULL;\n        }\n        plist_get_data(key)->type = PLIST_KEY;\n        if (!plist_get_data(key)->strval) {\n            fprintf(stderr, \"ERROR: Malformed binary plist dict, invalid key node encountered!\\n\");\n            plist_free(key);\n            plist_free(node);\n            return NULL;\n        }\n        plist_t val = parse_bin_node_at_index(bplist, index2);\n        if (!val) {\n            plist_free(key);\n            plist_free(node);\n            return NULL;\n        }\n        node_attach(node, key);\n        node_attach(node, val);\n    }\n    return node;\n}", "target": 1}
{"code": "static void warnf(struct Configurable *config, const char *fmt, ...)\n{\n  if(!(config->conf & CONF_MUTE)) {\n    va_list ap;\n    int len;\n    char *ptr;\n    char print_buffer[256];\n    va_start(ap, fmt);\n    va_start(ap, fmt);\n    len = vsnprintf(print_buffer, sizeof(print_buffer), fmt, ap);\n    va_end(ap);\n    ptr = print_buffer;\n    while(len > 0) {\n      fputs(WARN_PREFIX, config->errors);\n      if(len > (int)WARN_TEXTWIDTH) {\n        int cut = WARN_TEXTWIDTH-1;\n        while(!ISSPACE(ptr[cut]) && cut) {\n          cut--;\n        }\n        fwrite(ptr, cut + 1, 1, config->errors);\n        fputs(\"\\n\", config->errors);\n        ptr += cut+1; \n        len -= cut;\n      }\n      else {\n        fputs(ptr, config->errors);\n        len = 0;\n      }\n    }\n  }\n}", "target": 1}
{"code": " status_t AudioFlinger::EffectModule::command(uint32_t cmdCode,\n                                              uint32_t cmdSize,\n                                              void *pCmdData,\n uint32_t *replySize,\n void *pReplyData)\n{\n Mutex::Autolock _l(mLock);\n    ALOGVV(\"command(), cmdCode: %d, mEffectInterface: %p\", cmdCode, mEffectInterface);\n if (mState == DESTROYED || mEffectInterface == NULL) {\n return NO_INIT;\n }\n if (mStatus != NO_ERROR) {\n return mStatus;\n }\n if (cmdCode == EFFECT_CMD_GET_PARAM &&\n (*replySize < sizeof(effect_param_t) ||\n ((effect_param_t *)pCmdData)->psize > *replySize - sizeof(effect_param_t))) {\n         android_errorWriteLog(0x534e4554, \"29251553\");\n         return -EINVAL;\n     }\n     status_t status = (*mEffectInterface)->command(mEffectInterface,\n                                                    cmdCode,\n                                                    cmdSize,\n                                                   pCmdData,\n                                                   replySize,\n                                                   pReplyData);\n if (cmdCode != EFFECT_CMD_GET_PARAM && status == NO_ERROR) {\n uint32_t size = (replySize == NULL) ? 0 : *replySize;\n for (size_t i = 1; i < mHandles.size(); i++) {\n EffectHandle *h = mHandles[i];\n if (h != NULL && !h->destroyed_l()) {\n                h->commandExecuted(cmdCode, cmdSize, pCmdData, size, pReplyData);\n }\n }\n }\n return status;\n}", "target": 1}
{"code": "inline void ComputeInterpolationWeights(\n    const int64 out_size, const int64 in_size, const float scale,\n    const int resolution, InterpolationCache<T_SCALE>* interpolation) {\n  const Scaler scaler;\n  interpolation->lower.resize(out_size + 1);\n  interpolation->upper.resize(out_size + 1);\n  interpolation->lerp.resize(out_size + 1);\n  interpolation->ilerp.resize(out_size + 1);\n  interpolation->lower[out_size] = 0;\n  interpolation->upper[out_size] = 0;\n  for (int64 i = out_size - 1; i >= 0; --i) {\n    const float in = scaler(i, scale);\n    const float in_f = std::floor(in);\n    interpolation->lower[i] =\n        std::max(static_cast<int64>(in_f), static_cast<int64>(0));\n    interpolation->upper[i] =\n        std::min(static_cast<int64>(std::ceil(in)), in_size - 1);\n    interpolation->lerp[i] = in - in_f;\n    interpolation->ilerp[i] =\n        static_cast<T_SCALE>((in - in_f) * (1 << resolution));\n  }\n}", "target": 1}
{"code": " void SetUpFontconfig() {\n  std::unique_ptr<Environment> env = Environment::Create();\n  if (!env->HasVar(\"FONTCONFIG_FILE\")) {\n    FilePath dir_module;\n    PathService::Get(DIR_MODULE, &dir_module);\n    FilePath font_cache = dir_module.Append(\"fontconfig_caches\");\n    FilePath test_fonts = dir_module.Append(\"test_fonts\");\n    std::string fonts_conf = ReplaceStringPlaceholders(\n        kFontsConfTemplate, {font_cache.value(), test_fonts.value()}, nullptr);\n    FilePath fonts_conf_file_temp;\n    CHECK(CreateTemporaryFileInDir(dir_module, &fonts_conf_file_temp));\n    CHECK(\n        WriteFile(fonts_conf_file_temp, fonts_conf.c_str(), fonts_conf.size()));\n    FilePath fonts_conf_file = dir_module.Append(\"fonts.conf\");\n    CHECK(ReplaceFile(fonts_conf_file_temp, fonts_conf_file, nullptr));\n    env->SetVar(\"FONTCONFIG_FILE\", fonts_conf_file.value());\n  }\n  CHECK(FcInit());\n }", "target": 1}
{"code": "  size_t recv_body(char* buf, size_t max) override {\n    auto& message = parser.get();\n    auto& body_remaining = message.body();\n    body_remaining.data = buf;\n    body_remaining.size = max;\n    while (body_remaining.size && !parser.is_done()) {\n      boost::system::error_code ec;\n      http::async_read_some(stream, buffer, parser, yield[ec]);\n      if (ec == http::error::partial_message ||\n          ec == http::error::need_buffer) {\n        break;\n      }\n      if (ec) {\n        ldout(cct, 4) << \"failed to read body: \" << ec.message() << dendl;\n        throw rgw::io::Exception(ec.value(), std::system_category());\n      }\n    }\n    return max - body_remaining.size;\n  }", "target": 1}
{"code": "static void command_port_read_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *command_port = urb->context;\n\tstruct whiteheat_command_private *command_info;\n\tint status = urb->status;\n\tunsigned char *data = urb->transfer_buffer;\n\tint result;\n\tcommand_info = usb_get_serial_port_data(command_port);\n\tif (!command_info) {\n \t\tdev_dbg(&urb->dev->dev, \"%s - command_info is NULL, exiting.\\n\", __func__);\n \t\treturn;\n \t}\n \tif (status) {\n \t\tdev_dbg(&urb->dev->dev, \"%s - nonzero urb status: %d\\n\", __func__, status);\n \t\tif (status != -ENOENT)\n\t\t\tcommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\n\t\twake_up(&command_info->wait_command);\n\t\treturn;\n\t}\n\tusb_serial_debug_data(&command_port->dev, __func__, urb->actual_length, data);\n\tif (data[0] == WHITEHEAT_CMD_COMPLETE) {\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\n\t\twake_up(&command_info->wait_command);\n\t} else if (data[0] == WHITEHEAT_CMD_FAILURE) {\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\n\t\twake_up(&command_info->wait_command);\n\t} else if (data[0] == WHITEHEAT_EVENT) {\n \t\tdev_dbg(&urb->dev->dev, \"%s - event received\\n\", __func__);\n\t} else if (data[0] == WHITEHEAT_GET_DTR_RTS) {\n \t\tmemcpy(command_info->result_buffer, &data[1],\n \t\t\t\t\t\turb->actual_length - 1);\n \t\tcommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\n\t\twake_up(&command_info->wait_command);\n\t} else\n\t\tdev_dbg(&urb->dev->dev, \"%s - bad reply from firmware\\n\", __func__);\n\tresult = usb_submit_urb(command_port->read_urb, GFP_ATOMIC);\n\tif (result)\n\t\tdev_dbg(&urb->dev->dev, \"%s - failed resubmitting read urb, error %d\\n\",\n\t\t\t__func__, result);\n}", "target": 1}
{"code": "int ecall_restore(const char *input, uint64_t input_len, char **output,\n                  uint64_t *output_len) {\n  if (!asylo::primitives::TrustedPrimitives::IsOutsideEnclave(input,\n                                                              input_len) ||\n      !asylo::primitives::TrustedPrimitives::IsOutsideEnclave(\n          output_len, sizeof(uint64_t))) {\n    asylo::primitives::TrustedPrimitives::BestEffortAbort(\n        \"ecall_restore: input/output found to not be in untrusted memory.\");\n  }\n  int result = 0;\n  size_t tmp_output_len;\n  try {\n    result = asylo::Restore(input, static_cast<size_t>(input_len), output,\n                            &tmp_output_len);\n  } catch (...) {\n    LOG(FATAL) << \"Uncaught exception in enclave\";\n  }\n  if (output_len) {\n    *output_len = static_cast<uint64_t>(tmp_output_len);\n  }\n  return result;\n}", "target": 1}
{"code": " bool OmniboxViewViews::ShouldShowPlaceholderText() const {\n   return Textfield::ShouldShowPlaceholderText() &&\n         !model()->is_caret_visible() && !model()->is_keyword_selected();\n }", "target": 1}
{"code": "bool AffiliationFetcher::ParseResponse(\n    AffiliationFetcherDelegate::Result* result) const {\n  std::string serialized_response;\n  if (!fetcher_->GetResponseAsString(&serialized_response)) {\n    NOTREACHED();\n  }\n  affiliation_pb::LookupAffiliationResponse response;\n  if (!response.ParseFromString(serialized_response))\n    return false;\n  result->reserve(requested_facet_uris_.size());\n  std::map<FacetURI, size_t> facet_uri_to_class_index;\n  for (int i = 0; i < response.affiliation_size(); ++i) {\n    const affiliation_pb::Affiliation& equivalence_class(\n        response.affiliation(i));\n     AffiliatedFacets affiliated_uris;\n     for (int j = 0; j < equivalence_class.facet_size(); ++j) {\n      const std::string& uri_spec(equivalence_class.facet(j));\n       FacetURI uri = FacetURI::FromPotentiallyInvalidSpec(uri_spec);\n       if (!uri.is_valid())\n        continue;\n      affiliated_uris.push_back(uri);\n    }\n    if (affiliated_uris.empty())\n      continue;\n    for (const FacetURI& uri : affiliated_uris) {\n      if (!facet_uri_to_class_index.count(uri))\n        facet_uri_to_class_index[uri] = result->size();\n      if (facet_uri_to_class_index[uri] !=\n          facet_uri_to_class_index[affiliated_uris[0]]) {\n        return false;\n      }\n    }\n    if (facet_uri_to_class_index[affiliated_uris[0]] == result->size())\n      result->push_back(affiliated_uris);\n  }\n  for (const FacetURI& uri : requested_facet_uris_) {\n    if (!facet_uri_to_class_index.count(uri))\n      result->push_back(AffiliatedFacets(1, uri));\n  }\n  return true;\n}", "target": 1}
{"code": "static void ipmr_cache_resolve(struct mfc_cache *uc, struct mfc_cache *c)\n{\n\tstruct sk_buff *skb;\n\twhile((skb=__skb_dequeue(&uc->mfc_un.unres.unresolved))) {\n\t\tif (skb->nh.iph->version == 0) {\n\t\t\tint err;\n\t\t\tstruct nlmsghdr *nlh = (struct nlmsghdr *)skb_pull(skb, sizeof(struct iphdr));\n\t\t\tif (ipmr_fill_mroute(skb, c, NLMSG_DATA(nlh)) > 0) {\n\t\t\t\tnlh->nlmsg_len = skb->tail - (u8*)nlh;\n\t\t\t} else {\n\t\t\t\tnlh->nlmsg_type = NLMSG_ERROR;\n\t\t\t\tnlh->nlmsg_len = NLMSG_LENGTH(sizeof(struct nlmsgerr));\n\t\t\t\tskb_trim(skb, nlh->nlmsg_len);\n\t\t\t\t((struct nlmsgerr*)NLMSG_DATA(nlh))->error = -EMSGSIZE;\n\t\t\t}\n\t\t\terr = netlink_unicast(rtnl, skb, NETLINK_CB(skb).dst_pid, MSG_DONTWAIT);\n\t\t} else\n\t\t\tip_mr_forward(skb, c, 0);\n\t}\n}", "target": 1}
{"code": "std::string utf16ToUtf8(const StringPiece16& utf16) {\n ssize_t utf8Length = utf16_to_utf8_length(utf16.data(), utf16.length());\n if (utf8Length <= 0) {\n return {};\n     }\n     std::string utf8;\n     utf8.resize(utf8Length);\n    utf16_to_utf8(utf16.data(), utf16.length(), &*utf8.begin());\n     return utf8;\n }", "target": 1}
{"code": "auth_password(Authctxt *authctxt, const char *password)\n{\n\tstruct passwd * pw = authctxt->pw;\n\tint result, ok = authctxt->valid;\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n \tstatic int expire_checked = 0;\n #endif\n #ifndef HAVE_CYGWIN\n \tif (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)\n \t\tok = 0;\n#endif\n\tif (*password == '\\0' && options.permit_empty_passwd == 0)\n\t\treturn 0;\n#ifdef KRB5\n\tif (options.kerberos_authentication == 1) {\n\t\tint ret = auth_krb5_password(authctxt, password);\n\t\tif (ret == 1 || ret == 0)\n\t\t\treturn ret && ok;\n\t}\n#endif\n#ifdef HAVE_CYGWIN\n\t{\n\t\tHANDLE hToken = cygwin_logon_user(pw, password);\n\t\tif (hToken == INVALID_HANDLE_VALUE)\n\t\t\treturn 0;\n\t\tcygwin_set_impersonation_token(hToken);\n\t\treturn ok;\n\t}\n#endif\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\treturn (sshpam_auth_passwd(authctxt, password) && ok);\n#endif\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tif (!expire_checked) {\n\t\texpire_checked = 1;\n\t\tif (auth_shadow_pwexpired(authctxt))\n\t\t\tauthctxt->force_pwchange = 1;\n\t}\n#endif\n\tresult = sys_auth_passwd(authctxt, password);\n\tif (authctxt->force_pwchange)\n\t\tdisable_forwarding();\n\treturn (result && ok);\n}", "target": 1}
{"code": "AP_DECLARE(void) ap_increment_counts(ap_sb_handle_t *sb, request_rec *r)\n{\n    worker_score *ws;\n    apr_off_t bytes;\n    if (!sb)\n        return;\n    ws = &ap_scoreboard_image->servers[sb->child_num][sb->thread_num];\n    if (pfn_ap_logio_get_last_bytes != NULL) {\n        bytes = pfn_ap_logio_get_last_bytes(r->connection);\n    }\n    else if (r->method_number == M_GET && r->method[0] == 'H') {\n        bytes = 0;\n    }\n    else {\n        bytes = r->bytes_sent;\n    }\n#ifdef HAVE_TIMES\n    times(&ws->times);\n#endif\n    ws->access_count++;\n    ws->my_access_count++;\n    ws->conn_count++;\n    ws->bytes_served += bytes;\n    ws->my_bytes_served += bytes;\n    ws->conn_bytes += bytes;\n}", "target": 1}
{"code": "static void b43_request_firmware(struct work_struct *work)\n{\n\tstruct b43_wl *wl = container_of(work,\n\t\t\t    struct b43_wl, firmware_load);\n\tstruct b43_wldev *dev = wl->current_dev;\n\tstruct b43_request_fw_context *ctx;\n\tunsigned int i;\n\tint err;\n\tconst char *errmsg;\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn;\n\tctx->dev = dev;\n\tctx->req_type = B43_FWTYPE_PROPRIETARY;\n\terr = b43_try_request_fw(ctx);\n\tif (!err)\n\t\tgoto start_ieee80211; \n\tif (ctx->fatal_failure)\n\t\tgoto out;\n\tctx->req_type = B43_FWTYPE_OPENSOURCE;\n\terr = b43_try_request_fw(ctx);\n\tif (!err)\n\t\tgoto start_ieee80211; \n\tif(ctx->fatal_failure)\n\t\tgoto out;\n\tfor (i = 0; i < B43_NR_FWTYPES; i++) {\n\t\terrmsg = ctx->errors[i];\n\t\tif (strlen(errmsg))\n\t\t\tb43err(dev->wl, errmsg);\n\t}\n\tb43_print_fw_helptext(dev->wl, 1);\n\tgoto out;\nstart_ieee80211:\n\twl->hw->queues = B43_QOS_QUEUE_NUM;\n\tif (!modparam_qos || dev->fw.opensource)\n\t\twl->hw->queues = 1;\n\terr = ieee80211_register_hw(wl->hw);\n\tif (err)\n\t\tgoto err_one_core_detach;\n\twl->hw_registred = true;\n\tb43_leds_register(wl->current_dev);\n\tgoto out;\nerr_one_core_detach:\n\tb43_one_core_detach(dev->dev);\nout:\n\tkfree(ctx);\n}", "target": 1}
{"code": "static int exif_read_from_impl(image_info_type *ImageInfo, php_stream *stream, int read_thumbnail, int read_all)\n{\n\tint ret;\n\tzend_stat_t st;\n\tmemset(ImageInfo, 0, sizeof(*ImageInfo));\n\tImageInfo->motorola_intel\t= -1; \n\tImageInfo->infile\t\t\t= stream;\n\tImageInfo->FileName\t\t\t= NULL;\n\tif (php_stream_is(ImageInfo->infile, PHP_STREAM_IS_STDIO)) {\n\t\tif (VCWD_STAT(stream->orig_path, &st) >= 0) {\n\t\t\tzend_string *base;\n\t\t\tif ((st.st_mode & S_IFMT) != S_IFREG) {\n\t\t\t\texif_error_docref(NULL EXIFERR_CC, ImageInfo, E_WARNING, \"Not a file\");\n\t\t\t\tphp_stream_close(ImageInfo->infile);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tbase = php_basename(stream->orig_path, strlen(stream->orig_path), NULL, 0);\n\t\t\tImageInfo->FileName = estrndup(ZSTR_VAL(base), ZSTR_LEN(base));\n\t\t\tzend_string_release(base);\n\t\t\tImageInfo->FileDateTime = st.st_mtime;\n\t\t\tImageInfo->FileSize = st.st_size;\n\t\t}\n\t} else {\n\t\tif (!ImageInfo->FileSize) {\n\t\t\tphp_stream_seek(ImageInfo->infile, 0, SEEK_END);\n\t\t\tImageInfo->FileSize = php_stream_tell(ImageInfo->infile);\n\t\t\tphp_stream_seek(ImageInfo->infile, 0, SEEK_SET);\n\t\t}\n\t}\n\tImageInfo->read_thumbnail\t\t= read_thumbnail;\n\tImageInfo->read_all\t\t\t\t= read_all;\n\tImageInfo->Thumbnail.filetype\t= IMAGE_FILETYPE_UNKNOWN;\n\tImageInfo->encode_unicode\t\t= estrdup(EXIF_G(encode_unicode));\n\tImageInfo->decode_unicode_be\t= estrdup(EXIF_G(decode_unicode_be));\n\tImageInfo->decode_unicode_le\t= estrdup(EXIF_G(decode_unicode_le));\n\tImageInfo->encode_jis\t\t\t= estrdup(EXIF_G(encode_jis));\n\tImageInfo->decode_jis_be\t \t= estrdup(EXIF_G(decode_jis_be));\n\tImageInfo->decode_jis_le\t\t= estrdup(EXIF_G(decode_jis_le));\n\tImageInfo->ifd_nesting_level = 0;\n\tret = exif_scan_FILE_header(ImageInfo);\n\treturn ret;\n}", "target": 1}
{"code": " std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,\n                                            const std::wstring& switch_name) {\n   assert(!command_line.empty());\n   assert(!switch_name.empty());\n   std::vector<std::wstring> as_array = TokenizeCommandLineToArray(command_line);\n   std::wstring switch_with_equal = L\"--\" + switch_name + L\"=\";\n  for (size_t i = 1; i < as_array.size(); ++i) {\n    const std::wstring& arg = as_array[i];\n     if (arg.compare(0, switch_with_equal.size(), switch_with_equal) == 0)\n       return arg.substr(switch_with_equal.size());\n   }\n  return std::wstring();\n}", "target": 1}
{"code": "p11_rpc_buffer_get_byte_array (p11_buffer *buf,\n                               size_t *offset,\n                               const unsigned char **data,\n                               size_t *length)\n{\n\tsize_t off = *offset;\n\tuint32_t len;\n\tif (!p11_rpc_buffer_get_uint32 (buf, &off, &len))\n\t\treturn false;\n\tif (len == 0xffffffff) {\n\t\t*offset = off;\n\t\tif (data)\n\t\t\t*data = NULL;\n\t\tif (length)\n\t\t\t*length = 0;\n\t\treturn true;\n\t} else if (len >= 0x7fffffff) {\n\t\tp11_buffer_fail (buf);\n\t\treturn false;\n\t}\n\tif (buf->len < len || *offset > buf->len - len) {\n\t\tp11_buffer_fail (buf);\n\t\treturn false;\n\t}\n\tif (data)\n\t\t*data = (unsigned char *)buf->data + off;\n\tif (length)\n\t\t*length = len;\n\t*offset = off + len;\n\treturn true;\n}", "target": 1}
{"code": " static int sock_close(struct inode *inode, struct file *filp)\n {\n\tsock_release(SOCKET_I(inode));\n \treturn 0;\n }", "target": 1}
{"code": "static int fuse_do_getattr(struct inode *inode, struct kstat *stat,\n\t\t\t   struct file *file)\n{\n\tint err;\n\tstruct fuse_getattr_in inarg;\n\tstruct fuse_attr_out outarg;\n\tstruct fuse_mount *fm = get_fuse_mount(inode);\n\tFUSE_ARGS(args);\n\tu64 attr_version;\n\tattr_version = fuse_get_attr_version(fm->fc);\n\tmemset(&inarg, 0, sizeof(inarg));\n\tmemset(&outarg, 0, sizeof(outarg));\n\tif (file && S_ISREG(inode->i_mode)) {\n\t\tstruct fuse_file *ff = file->private_data;\n\t\tinarg.getattr_flags |= FUSE_GETATTR_FH;\n\t\tinarg.fh = ff->fh;\n\t}\n\targs.opcode = FUSE_GETATTR;\n\targs.nodeid = get_node_id(inode);\n\targs.in_numargs = 1;\n\targs.in_args[0].size = sizeof(inarg);\n\targs.in_args[0].value = &inarg;\n\targs.out_numargs = 1;\n\targs.out_args[0].size = sizeof(outarg);\n\targs.out_args[0].value = &outarg;\n\terr = fuse_simple_request(fm, &args);\n\tif (!err) {\n\t\tif (fuse_invalid_attr(&outarg.attr) ||\n\t\t    (inode->i_mode ^ outarg.attr.mode) & S_IFMT) {\n\t\t\tmake_bad_inode(inode);\n\t\t\terr = -EIO;\n\t\t} else {\n\t\t\tfuse_change_attributes(inode, &outarg.attr,\n\t\t\t\t\t       attr_timeout(&outarg),\n\t\t\t\t\t       attr_version);\n\t\t\tif (stat)\n\t\t\t\tfuse_fillattr(inode, &outarg.attr, stat);\n\t\t}\n\t}\n\treturn err;\n}", "target": 1}
{"code": "int JSStream::DoWrite(WriteWrap* w,\n                      uv_buf_t* bufs,\n                      size_t count,\n                      uv_stream_t* send_handle) {\n  CHECK_NULL(send_handle);\n  HandleScope scope(env()->isolate());\n  Context::Scope context_scope(env()->context());\n  Local<Array> bufs_arr = Array::New(env()->isolate(), count);\n  Local<Object> buf;\n  for (size_t i = 0; i < count; i++) {\n    buf = Buffer::Copy(env(), bufs[i].base, bufs[i].len).ToLocalChecked();\n    bufs_arr->Set(i, buf);\n  }\n  Local<Value> argv[] = {\n    w->object(),\n    bufs_arr\n  };\n  TryCatch try_catch(env()->isolate());\n  Local<Value> value;\n  int value_int = UV_EPROTO;\n  if (!MakeCallback(env()->onwrite_string(),\n                    arraysize(argv),\n                    argv).ToLocal(&value) ||\n      !value->Int32Value(env()->context()).To(&value_int)) {\n    if (!try_catch.HasTerminated())\n      FatalException(env()->isolate(), try_catch);\n  }\n  return value_int;\n}", "target": 1}
{"code": " pvscsi_ring_pop_req_descr(PVSCSIRingInfo *mgr)\n {\n     uint32_t ready_ptr = RS_GET_FIELD(mgr, reqProdIdx);\n    if (ready_ptr != mgr->consumed_ptr) {\n         uint32_t next_ready_ptr =\n             mgr->consumed_ptr++ & mgr->txr_len_mask;\n         uint32_t next_ready_page =\n        return mgr->req_ring_pages_pa[next_ready_page] +\n               inpage_idx * sizeof(PVSCSIRingReqDesc);\n    } else {\n        return 0;\n    }\n}", "target": 1}
{"code": "rx_cache_insert(netdissect_options *ndo,\n                const u_char *bp, const struct ip *ip, int dport)\n{\n\tstruct rx_cache_entry *rxent;\n\tconst struct rx_header *rxh = (const struct rx_header *) bp;\n\tif (ndo->ndo_snapend - bp + 1 <= (int)(sizeof(struct rx_header) + sizeof(int32_t)))\n\t\treturn;\n\trxent = &rx_cache[rx_cache_next];\n\tif (++rx_cache_next >= RX_CACHE_SIZE)\n\t\trx_cache_next = 0;\n\trxent->callnum = EXTRACT_32BITS(&rxh->callNumber);\n \tUNALIGNED_MEMCPY(&rxent->client, &ip->ip_src, sizeof(uint32_t));\n \tUNALIGNED_MEMCPY(&rxent->server, &ip->ip_dst, sizeof(uint32_t));\n \trxent->dport = dport;\n\trxent->serviceId = EXTRACT_32BITS(&rxh->serviceId);\n \trxent->opcode = EXTRACT_32BITS(bp + sizeof(struct rx_header));\n }", "target": 1}
{"code": "static long __media_device_enum_links(struct media_device *mdev,\n\t\t\t\t      struct media_links_enum *links)\n{\n\tstruct media_entity *entity;\n\tentity = find_entity(mdev, links->entity);\n\tif (entity == NULL)\n\t\treturn -EINVAL;\n\tif (links->pads) {\n\t\tunsigned int p;\n \t\tfor (p = 0; p < entity->num_pads; p++) {\n \t\t\tstruct media_pad_desc pad;\n \t\t\tmedia_device_kpad_to_upad(&entity->pads[p], &pad);\n \t\t\tif (copy_to_user(&links->pads[p], &pad, sizeof(pad)))\n \t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\tif (links->links) {\n\t\tstruct media_link_desc __user *ulink;\n\t\tunsigned int l;\n\t\tfor (l = 0, ulink = links->links; l < entity->num_links; l++) {\n\t\t\tstruct media_link_desc link;\n \t\t\tif (entity->links[l].source->entity != entity)\n \t\t\t\tcontinue;\n \t\t\tmedia_device_kpad_to_upad(entity->links[l].source,\n \t\t\t\t\t\t  &link.source);\n \t\t\tmedia_device_kpad_to_upad(entity->links[l].sink,\n\t\t\t\t\t\t  &link.sink);\n\t\t\tlink.flags = entity->links[l].flags;\n\t\t\tif (copy_to_user(ulink, &link, sizeof(*ulink)))\n\t\t\t\treturn -EFAULT;\n\t\t\tulink++;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int bnep_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tstruct bnep_connlist_req cl;\n\tstruct bnep_connadd_req  ca;\n\tstruct bnep_conndel_req  cd;\n\tstruct bnep_conninfo ci;\n\tstruct socket *nsock;\n\tvoid __user *argp = (void __user *)arg;\n\tint err;\n\tBT_DBG(\"cmd %x arg %lx\", cmd, arg);\n\tswitch (cmd) {\n\tcase BNEPCONNADD:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EACCES;\n\t\tif (copy_from_user(&ca, argp, sizeof(ca)))\n\t\t\treturn -EFAULT;\n\t\tnsock = sockfd_lookup(ca.sock, &err);\n\t\tif (!nsock)\n\t\t\treturn err;\n\t\tif (nsock->sk->sk_state != BT_CONNECTED) {\n \t\t\tsockfd_put(nsock);\n \t\t\treturn -EBADFD;\n \t\t}\n \t\terr = bnep_add_connection(&ca, nsock);\n \t\tif (!err) {\n\t\t\tif (copy_to_user(argp, &ca, sizeof(ca)))\n\t\t\t\terr = -EFAULT;\n\t\t} else\n\t\t\tsockfd_put(nsock);\n\t\treturn err;\n\tcase BNEPCONNDEL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EACCES;\n\t\tif (copy_from_user(&cd, argp, sizeof(cd)))\n\t\t\treturn -EFAULT;\n\t\treturn bnep_del_connection(&cd);\n\tcase BNEPGETCONNLIST:\n\t\tif (copy_from_user(&cl, argp, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\t\tif (cl.cnum <= 0)\n\t\t\treturn -EINVAL;\n\t\terr = bnep_get_connlist(&cl);\n\t\tif (!err && copy_to_user(argp, &cl, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\t\treturn err;\n\tcase BNEPGETCONNINFO:\n\t\tif (copy_from_user(&ci, argp, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\t\terr = bnep_get_conninfo(&ci);\n\t\tif (!err && copy_to_user(argp, &ci, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\t\treturn err;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "int snd_rawmidi_input_params(struct snd_rawmidi_substream *substream,\n\t\t\t     struct snd_rawmidi_params * params)\n{\n\tchar *newbuf;\n\tstruct snd_rawmidi_runtime *runtime = substream->runtime;\n\tsnd_rawmidi_drain_input(substream);\n\tif (params->buffer_size < 32 || params->buffer_size > 1024L * 1024L) {\n\t\treturn -EINVAL;\n\t}\n\tif (params->avail_min < 1 || params->avail_min > params->buffer_size) {\n\t\treturn -EINVAL;\n\t}\n\tif (params->buffer_size != runtime->buffer_size) {\n\t\tnewbuf = krealloc(runtime->buffer, params->buffer_size,\n\t\t\t\t  GFP_KERNEL);\n\t\tif (!newbuf)\n\t\t\treturn -ENOMEM;\n\t\truntime->buffer = newbuf;\n\t\truntime->buffer_size = params->buffer_size;\n\t}\n\truntime->avail_min = params->avail_min;\n\treturn 0;\n}", "target": 1}
{"code": "struct mapped_device *dm_get_from_kobject(struct kobject *kobj)\n{\n\tstruct mapped_device *md;\n \tmd = container_of(kobj, struct mapped_device, kobj_holder.kobj);\n\tif (test_bit(DMF_FREEING, &md->flags) ||\n\t    dm_deleting_md(md))\n\t\treturn NULL;\n \tdm_get(md);\n \treturn md;\n }", "target": 1}
{"code": "void color_cmyk_to_rgb(opj_image_t *image)\n{\n\tfloat C, M, Y, K;\n\tfloat sC, sM, sY, sK;\n\tunsigned int w, h, max, i;\n \tw = image->comps[0].w;\n \th = image->comps[0].h;\n\tif(image->numcomps < 4) return;\n \tmax = w * h;\n\tsC = 1.0F / (float)((1 << image->comps[0].prec) - 1);\n\tsM = 1.0F / (float)((1 << image->comps[1].prec) - 1);\n\tsY = 1.0F / (float)((1 << image->comps[2].prec) - 1);\n\tsK = 1.0F / (float)((1 << image->comps[3].prec) - 1);\n\tfor(i = 0; i < max; ++i)\n\t{\n\t\tC = (float)(image->comps[0].data[i]) * sC;\n\t\tM = (float)(image->comps[1].data[i]) * sM;\n\t\tY = (float)(image->comps[2].data[i]) * sY;\n\t\tK = (float)(image->comps[3].data[i]) * sK;\n\t\tC = 1.0F - C;\n\t\tM = 1.0F - M;\n\t\tY = 1.0F - Y;\n\t\tK = 1.0F - K;\n\t\timage->comps[0].data[i] = (int)(255.0F * C * K); \n\t\timage->comps[1].data[i] = (int)(255.0F * M * K); \n\t\timage->comps[2].data[i] = (int)(255.0F * Y * K); \n\t}\n\tfree(image->comps[3].data); image->comps[3].data = NULL;\n\timage->comps[0].prec = 8;\n\timage->comps[1].prec = 8;\n\timage->comps[2].prec = 8;\n\timage->numcomps -= 1;\n\timage->color_space = OPJ_CLRSPC_SRGB;\n\tfor (i = 3; i < image->numcomps; ++i) {\n\t\tmemcpy(&(image->comps[i]), &(image->comps[i+1]), sizeof(image->comps[i]));\n\t}\n}", "target": 1}
{"code": "static MagickBooleanType SkipRGBMipmaps(Image *image,DDSInfo *dds_info,\n  int pixel_size,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    offset;\n  register ssize_t\n    i;\n  size_t\n    h,\n    w;\n  if (EOFBlob(image) != MagickFalse)\n    {\n      ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n        image->filename);\n      return(MagickFalse);\n    }\n  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP\n      && (dds_info->ddscaps1 & DDSCAPS_TEXTURE\n          || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))\n    {\n      w = DIV2(dds_info->width);\n      h = DIV2(dds_info->height);\n       for (i=1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n       {\n         offset = (MagickOffsetType) w * h * pixel_size;\n        (void) SeekBlob(image, offset, SEEK_CUR);\n         w = DIV2(w);\n         h = DIV2(h);\n       }\n    }\n  return(MagickTrue);\n}", "target": 1}
{"code": "v8::Local<v8::Object> V8SchemaRegistry::GetSchema(const std::string& api) {\n  if (schema_cache_ != NULL) {\n    v8::Local<v8::Object> cached_schema = schema_cache_->Get(api);\n    if (!cached_schema.IsEmpty()) {\n      return cached_schema;\n    }\n  }\n  v8::Isolate* isolate = v8::Isolate::GetCurrent();\n  v8::EscapableHandleScope handle_scope(isolate);\n  v8::Local<v8::Context> context = GetOrCreateContext(isolate);\n  v8::Context::Scope context_scope(context);\n  const base::DictionaryValue* schema =\n      ExtensionAPI::GetSharedInstance()->GetSchema(api);\n  CHECK(schema) << api;\n  std::unique_ptr<V8ValueConverter> v8_value_converter(\n      V8ValueConverter::create());\n  v8::Local<v8::Value> value = v8_value_converter->ToV8Value(schema, context);\n   CHECK(!value.IsEmpty());\n   v8::Local<v8::Object> v8_schema(v8::Local<v8::Object>::Cast(value));\n  v8_schema->SetIntegrityLevel(context, v8::IntegrityLevel::kFrozen);\n   schema_cache_->Set(api, v8_schema);\n   return handle_scope.Escape(v8_schema);\n}", "target": 1}
{"code": "int main(int argc, char **argv, char **envp)\n{\n#ifdef DYNLOAD\n    if (!uc_dyn_load(NULL, 0)) {\n        printf(\"Error dynamically loading shared library.\\n\");\n        printf(\"Please check that unicorn.dll/unicorn.so is available as well as\\n\");\n        printf(\"any other dependent dll/so files.\\n\");\n        printf(\"The easiest way is to place them in the same directory as this app.\\n\");\n        return 1;\n    }\n#endif\n    test_arm();\n    printf(\"==========================\\n\");\n    test_thumb();\n#ifdef DYNLOAD\n    uc_dyn_free();\n#endif\n    return 0;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const auto& input = context->input(0);\n    auto flat_in = input.flat<tstring>();\n    int fixed_length;\n    const auto& length_input = context->input(1);\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(length_input.shape()),\n                errors::InvalidArgument(\"k must be scalar, got shape \",\n                                        length_input.shape().DebugString()));\n    fixed_length = length_input.scalar<int32>()();\n    OP_REQUIRES(\n        context, fixed_length % sizeof(T) == 0,\n        errors::InvalidArgument(\n            \"fixed_length (\", fixed_length,\n            \") must be a multiple of the size of out_type (\", sizeof(T), \")\"));\n    OP_REQUIRES(context, fixed_length > 0,\n                errors::InvalidArgument(\"fixed_length (\", fixed_length,\n                                        \") must be greater than zero.\"));\n    int width = fixed_length / sizeof(T);\n    TensorShape out_shape = input.shape();\n    out_shape.AddDim(width);\n    Tensor* output_tensor = nullptr;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(\"output\", out_shape, &output_tensor));\n    if (flat_in.size() == 0) {  \n      return;\n    }\n    auto out = output_tensor->flat_inner_dims<T>();\n    T* out_data = out.data();\n    memset(out_data, 0, fixed_length * flat_in.size());\n    if (!convert_data_endianness_ || sizeof(T) == 1) {\n      for (int64 i = 0; i < flat_in.size(); ++i) {\n        const T* in_data = reinterpret_cast<const T*>(flat_in(i).data());\n        if (flat_in(i).size() > fixed_length) {\n          memcpy(out_data, in_data, fixed_length);\n        } else {\n          memcpy(out_data, in_data, flat_in(i).size());\n        }\n        out_data += fixed_length;\n      }\n    } else {\n      for (int64 i = 0; i < flat_in.size(); ++i) {\n        const char* in_data_bytes =\n            reinterpret_cast<const char*>(flat_in(i).data());\n        char* out_data_bytes = reinterpret_cast<char*>(out_data);\n        const char* p_in = in_data_bytes;\n        char* p_out = out_data_bytes;\n        for (; p_in < in_data_bytes + fixed_length;\n             p_in += sizeof(T), p_out += sizeof(T)) {\n          std::reverse_copy(p_in, p_in + sizeof(T), p_out);\n        }\n        out_data += fixed_length;\n      }\n    }\n  }", "target": 1}
{"code": "rpa_read_buffer(pool_t pool, const unsigned char **data,\n\t\tconst unsigned char *end, unsigned char **buffer)\n{\n\tconst unsigned char *p = *data;\n\tunsigned int len;\n\tif (p > end)\n\t\treturn 0;\n\tlen = *p++;\n\tif (p + len > end)\n\t\treturn 0;\n\t*buffer = p_malloc(pool, len);\n\tmemcpy(*buffer, p, len);\n\t*data += 1 + len;\n\treturn len;\n}", "target": 1}
{"code": "AcpiPsCompleteFinalOp (\n    ACPI_WALK_STATE         *WalkState,\n     ACPI_PARSE_OBJECT       *Op,\n     ACPI_STATUS             Status)\n {\n    ACPI_STATUS             Status2;\n     ACPI_FUNCTION_TRACE_PTR (PsCompleteFinalOp, WalkState);\n    ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, \"AML package complete at Op %p\\n\", Op));\n    do\n     {\n         if (Op)\n         {\n            if (WalkState->AscendingCallback != NULL)\n             {\n                 WalkState->Op = Op;\n                 WalkState->OpInfo = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode);\n                WalkState->Opcode = Op->Common.AmlOpcode;\n                Status = WalkState->AscendingCallback (WalkState);\n                Status = AcpiPsNextParseState (WalkState, Op, Status);\n                if (Status == AE_CTRL_PENDING)\n                {\n                    Status = AcpiPsCompleteOp (WalkState, &Op, AE_OK);\n                    if (ACPI_FAILURE (Status))\n                    {\n                        return_ACPI_STATUS (Status);\n                    }\n                }\n                 if (Status == AE_CTRL_TERMINATE)\n                 {\n                    Status = AE_OK;\n                    do\n                    {\n                        if (Op)\n                        {\n                            Status2 = AcpiPsCompleteThisOp (WalkState, Op);\n                            if (ACPI_FAILURE (Status2))\n                            {\n                                return_ACPI_STATUS (Status2);\n                            }\n                        }\n                        AcpiPsPopScope (&(WalkState->ParserState), &Op,\n                            &WalkState->ArgTypes, &WalkState->ArgCount);\n                    } while (Op);\n                    return_ACPI_STATUS (Status);\n                 }\n                 else if (ACPI_FAILURE (Status))\n                 {\n                    (void) AcpiPsCompleteThisOp (WalkState, Op);\n                    return_ACPI_STATUS (Status);\n                 }\n             }\n            Status2 = AcpiPsCompleteThisOp (WalkState, Op);\n            if (ACPI_FAILURE (Status2))\n             {\n                return_ACPI_STATUS (Status2);\n             }\n         }\n        AcpiPsPopScope (&(WalkState->ParserState), &Op, &WalkState->ArgTypes,\n            &WalkState->ArgCount);\n     } while (Op);\n    return_ACPI_STATUS (Status);\n }", "target": 1}
{"code": "static int java_switch_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\n\tut8 op_byte = data[0];\n\tut64 offset = addr - java_get_method_start ();\n\tut8 pos = (offset+1)%4 ? 1 + 4 - (offset+1)%4 : 1;\n\tif (op_byte == 0xaa) {\n\t\tif (pos + 8 > len) {\n\t\t\treturn op->size;\n\t\t}\n\t\tint min_val = (ut32)(UINT (data, pos + 4)),\n\t\t\tmax_val = (ut32)(UINT (data, pos + 8));\n\t\tut32 default_loc = (ut32) (UINT (data, pos)), cur_case = 0;\n\t\top->switch_op = r_anal_switch_op_new (addr, min_val, default_loc);\n\t\tRAnalCaseOp *caseop = NULL;\n\t\tpos += 12;\n\t\tif (max_val > min_val && ((max_val - min_val)<(UT16_MAX/4))) {\n\t\t\tfor (cur_case = 0; cur_case <= max_val - min_val; pos += 4, cur_case++) {\n\t\t\t\tif (pos + 4 >= len) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint offset = (int)(ut32)(R_BIN_JAVA_UINT (data, pos));\n\t\t\t\tcaseop = r_anal_switch_op_add_case (op->switch_op,\n\t\t\t\t\taddr + pos, cur_case + min_val, addr + offset);\n\t\t\t\tif (caseop) {\n\t\t\t\t\tcaseop->bb_ref_to = addr+offset;\n\t\t\t\t\tcaseop->bb_ref_from = addr; \n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Invalid switch boundaries at 0x%\"PFMT64x\"\\n\", addr);\n\t\t}\n\t}\n\top->size = pos;\n\treturn op->size;\n}", "target": 1}
{"code": "static bool tailmatch(const char *little, const char *bigone)\n {\n  size_t littlelen = strlen(little);\n  size_t biglen = strlen(bigone);\n  if(littlelen > biglen)\n     return FALSE;\n  return Curl_raw_equal(little, bigone+biglen-littlelen) ? TRUE : FALSE;\n }", "target": 1}
{"code": " get_next_file(FILE *VFile, char *ptr)\n {\n \tchar *ret;\n \tret = fgets(ptr, PATH_MAX, VFile);\n \tif (!ret)\n \t\treturn NULL;\n\tif (ptr[strlen(ptr) - 1] == '\\n')\n\t\tptr[strlen(ptr) - 1] = '\\0';\n \treturn ret;\n }", "target": 1}
{"code": "static void encode_share_access(struct xdr_stream *xdr, int open_flags)\n {\n \t__be32 *p;\n \tRESERVE_SPACE(8);\n\tswitch (open_flags & (FMODE_READ|FMODE_WRITE)) {\n \t\tcase FMODE_READ:\n \t\t\tWRITE32(NFS4_SHARE_ACCESS_READ);\n \t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tWRITE32(NFS4_SHARE_ACCESS_WRITE);\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n \t\t\tWRITE32(NFS4_SHARE_ACCESS_BOTH);\n \t\t\tbreak;\n \t\tdefault:\n\t\t\tBUG();\n \t}\n \tWRITE32(0);\t\t\n }", "target": 1}
{"code": "z_jbig2decode(i_ctx_t * i_ctx_p)\n{\n    os_ptr op = osp;\n    ref *sop = NULL;\n    s_jbig2_global_data_t *gref;\n    stream_jbig2decode_state state;\n    s_jbig2decode_set_global_data((stream_state*)&state, NULL);\n    if (r_has_type(op, t_dictionary)) {\n        check_dict_read(*op);\n        if ( dict_find_string(op, \".jbig2globalctx\", &sop) > 0) {\n            gref = r_ptr(sop, s_jbig2_global_data_t);\n            s_jbig2decode_set_global_data((stream_state*)&state, gref);\n        }\n    }\n    return filter_read(i_ctx_p, 0, &s_jbig2decode_template,\n                       (stream_state *) & state, (sop ? r_space(sop) : 0));\n}", "target": 1}
{"code": "ecc_gostdsa_verify (const struct ecc_curve *ecc,\n\t\t  const mp_limb_t *pp, \n\t\t  size_t length, const uint8_t *digest,\n\t\t  const mp_limb_t *rp, const mp_limb_t *sp,\n\t\t  mp_limb_t *scratch)\n{\n#define hp (scratch)\n#define vp (scratch + ecc->p.size)\n#define z1 (scratch + 3*ecc->p.size)\n#define z2 (scratch + 4*ecc->p.size)\n#define P1 (scratch + 4*ecc->p.size)\n#define P2 (scratch)\n  if (! (ecdsa_in_range (ecc, rp)\n\t && ecdsa_in_range (ecc, sp)))\n    return 0;\n  gost_hash (&ecc->q, hp, length, digest);\n  if (mpn_zero_p (hp, ecc->p.size))\n    mpn_add_1 (hp, hp, ecc->p.size, 1);\n  ecc->q.invert (&ecc->q, vp, hp, vp + ecc->p.size);\n  ecc_mod_mul (&ecc->q, z1, sp, vp, z1);\n  ecc_mod_mul (&ecc->q, z2, rp, vp, z2);\n  mpn_sub_n (z2, ecc->q.m, z2, ecc->p.size);\n  ecc->mul (ecc, P2, z2, pp, z2 + ecc->p.size);\n  ecc->mul_g (ecc, P1, z1, P1 + 3*ecc->p.size);\n  ecc->add_hhh (ecc, P1, P1, P2, P1 + 3*ecc->p.size);\n  ecc->h_to_a (ecc, 2, P2, P1, P1 + 3*ecc->p.size);\n  return (mpn_cmp (rp, P2, ecc->p.size) == 0);\n#undef P2\n#undef P1\n#undef z2\n#undef z1\n#undef hp\n#undef vp\n}", "target": 1}
{"code": "newEntry(struct rx_call *call, char aname[], afs_int32 flag, afs_int32 oid,\n\t afs_int32 *aid, afs_int32 *cid)\n{\n    afs_int32 code;\n    struct ubik_trans *tt;\n    int admin;\n    char cname[PR_MAXNAMELEN];\n    stolower(aname);\n    code = Initdb();\n    if (code)\n\treturn code;\n    code = ubik_BeginTrans(dbase, UBIK_WRITETRANS, &tt);\n    if (code)\n\treturn code;\n    code = ubik_SetLock(tt, 1, 1, LOCKWRITE);\n    if (code)\n\tABORT_WITH(tt, code);\n    code = read_DbHeader(tt);\n    if (code)\n\tABORT_WITH(tt, code);\n     code = WhoIsThisWithName(call, tt, cid, cname);\n    if (code != 2) {           \n       if (code)\n           ABORT_WITH(tt, PRPERM);\n       admin = IsAMemberOf(tt, *cid, SYSADMINID);\n    } else {\n       admin = ((!restricted && !strcmp(aname, cname))) || IsAMemberOf(tt, *cid, SYSADMINID);\n       oid = *cid = SYSADMINID;\n     }\n     if (!CreateOK(tt, *cid, oid, flag, admin))\n        ABORT_WITH(tt, PRPERM);\n    if (code)\n\treturn code;\n    return PRSUCCESS;\n}", "target": 1}
{"code": "static struct dentry *aio_mount(struct file_system_type *fs_type,\n\t\t\t\tint flags, const char *dev_name, void *data)\n{\n \tstatic const struct dentry_operations ops = {\n \t\t.d_dname\t= simple_dname,\n \t};\n\treturn mount_pseudo(fs_type, \"aio:\", NULL, &ops, AIO_RING_MAGIC);\n }", "target": 1}
{"code": " static size_t consume_init_expr (ut8 *buf, ut8 *max, ut8 eoc, void *out, ut32 *offset) {\n \tut32 i = 0;\n \twhile (buf + i < max && buf[i] != eoc) {\n\t\ti += 1;\n \t}\n \tif (buf[i] != eoc) {\n \t\treturn 0;\n\t}\n\tif (offset) {\n\t\t*offset += i + 1;\n\t}\n\treturn i + 1;\n}", "target": 1}
{"code": "void vrend_renderer_context_create_internal(uint32_t handle, uint32_t nlen,\n                                            const char *debug_name)\n{\n   struct vrend_decode_ctx *dctx;\n   if (handle >= VREND_MAX_CTX)\n      return;\n   dctx = malloc(sizeof(struct vrend_decode_ctx));\n   if (!dctx)\n      return;\n   dctx->grctx = vrend_create_context(handle, nlen, debug_name);\n   if (!dctx->grctx) {\n      free(dctx);\n      return;\n   }\n   dctx->ds = &dctx->ids;\n   dec_ctx[handle] = dctx;\n}", "target": 1}
{"code": "static int __init unittest_data_add(void)\n{\n\tvoid *unittest_data;\n\tstruct device_node *unittest_data_node, *np;\n\textern uint8_t __dtb_testcases_begin[];\n\textern uint8_t __dtb_testcases_end[];\n\tconst int size = __dtb_testcases_end - __dtb_testcases_begin;\n\tint rc;\n\tif (!size) {\n\t\tpr_warn(\"%s: No testcase data to attach; not running tests\\n\",\n\t\t\t__func__);\n\t\treturn -ENODATA;\n\t}\n\tunittest_data = kmemdup(__dtb_testcases_begin, size, GFP_KERNEL);\n\tif (!unittest_data)\n\t\treturn -ENOMEM;\n\tof_fdt_unflatten_tree(unittest_data, NULL, &unittest_data_node);\n\tif (!unittest_data_node) {\n\t\tpr_warn(\"%s: No tree to attach; not running tests\\n\", __func__);\n\t\treturn -ENODATA;\n\t}\n\tof_overlay_mutex_lock();\n\trc = of_resolve_phandles(unittest_data_node);\n\tif (rc) {\n\t\tpr_err(\"%s: Failed to resolve phandles (rc=%i)\\n\", __func__, rc);\n\t\tof_overlay_mutex_unlock();\n\t\treturn -EINVAL;\n\t}\n\tif (!of_root) {\n\t\tof_root = unittest_data_node;\n\t\tfor_each_of_allnodes(np)\n\t\t\t__of_attach_node_sysfs(np);\n\t\tof_aliases = of_find_node_by_path(\"/aliases\");\n\t\tof_chosen = of_find_node_by_path(\"/chosen\");\n\t\tof_overlay_mutex_unlock();\n\t\treturn 0;\n\t}\n\tnp = unittest_data_node->child;\n\twhile (np) {\n\t\tstruct device_node *next = np->sibling;\n\t\tnp->parent = of_root;\n\t\tattach_node_and_children(np);\n\t\tnp = next;\n\t}\n\tof_overlay_mutex_unlock();\n\treturn 0;\n}", "target": 1}
{"code": "void auth_policy_create_json(struct policy_lookup_ctx *context,\n\tconst char *password, bool include_success)\n{\n\tconst struct var_expand_table *var_table;\n\tcontext->json = str_new(context->pool, 64);\n\tunsigned char *ptr;\n\tconst struct hash_method *digest = hash_method_lookup(context->set->policy_hash_mech);\n\ti_assert(digest != NULL);\n\tvoid *ctx = t_malloc(digest->context_size);\n\tstring_t *buffer = t_str_new(64);\n\tdigest->init(ctx);\n\tdigest->loop(ctx,\n\t\tcontext->set->policy_hash_nonce,\n\t\tstrlen(context->set->policy_hash_nonce));\n\tdigest->loop(ctx, context->request->user, strlen(context->request->user) + 1);\n\tif (password != NULL)\n\t\tdigest->loop(ctx, password, strlen(password));\n\tptr = (unsigned char*)str_c_modifiable(buffer);\n\tdigest->result(ctx, ptr);\n\tstr_truncate(buffer, digest->digest_size);\n\tif (context->set->policy_hash_truncate > 0) {\n\t\tbuffer_truncate_rshift_bits(buffer, context->set->policy_hash_truncate);\n\t}\n\tconst char *hashed_password = binary_to_hex(str_data(buffer), str_len(buffer));\n\tstr_append_c(context->json, '{');\n\tvar_table = policy_get_var_expand_table(context->request, hashed_password);\n\tauth_request_var_expand_with_table(context->json, auth_policy_json_template,\n\t\t\t\t\t   context->request, var_table,\n\t\t\t\t\t   auth_policy_escape_function);\n\tif (include_success) {\n\t\tstr_append(context->json, \",\\\"success\\\":\");\n\t\tif (!context->request->failed && context->request->successful &&\n\t\t    !context->request->internal_failure)\n\t\t\tstr_append(context->json, \"true\");\n\t\telse\n\t\t\tstr_append(context->json, \"false\");\n\t\tstr_append(context->json, \",\\\"policy_reject\\\":\");\n\t\tstr_append(context->json, context->request->policy_refusal ? \"true\" : \"false\");\n\t}\n\tstr_append_c(context->json, '}');\n\tauth_request_log_debug(context->request, \"policy\",\n\t\t\"Policy server request JSON: %s\", str_c(context->json));\n}", "target": 1}
{"code": "gs_font_map_glyph_to_unicode(gs_font *font, gs_glyph glyph, int ch, ushort *u, unsigned int length)\n{\n    font_data *pdata = pfont_data(font);\n    const ref *UnicodeDecoding;\n    uchar *unicode_return = (uchar *)u;\n    if (r_type(&pdata->GlyphNames2Unicode) == t_dictionary) {\n        int c = gs_font_map_glyph_by_dict(font->memory,\n                                              &pdata->GlyphNames2Unicode, glyph, u, length);\n        if (c != 0)\n            return c;\n        if (ch != -1) { \n            ref *v, n;\n            make_int(&n, ch);\n            if (dict_find(&pdata->GlyphNames2Unicode, &n, &v) > 0) {\n                if (r_has_type(v, t_string)) {\n                    int l = r_size(v);\n                    if (l > length)\n                        return l;\n                    memcpy(unicode_return, v->value.const_bytes, l * sizeof(short));\n                    return l;\n                }\n                if (r_type(v) == t_integer) {\n                    if (v->value.intval > 65535) {\n                        if (length < 4)\n                            return 4;\n                        unicode_return[0] = v->value.intval >> 24;\n                        unicode_return[1] = (v->value.intval & 0x00FF0000) >> 16;\n                        unicode_return[2] = (v->value.intval & 0x0000FF00) >> 8;\n                        unicode_return[3] = v->value.intval & 0xFF;\n                        return 4;\n                    } else {\n                        if (length < 2)\n                            return 2;\n                        unicode_return[0] = v->value.intval >> 8;\n                        unicode_return[1] = v->value.intval & 0xFF;\n                        return 2;\n                    }\n                }\n            }\n        }\n    }\n    if (glyph <= GS_MIN_CID_GLYPH) {\n        UnicodeDecoding = zfont_get_to_unicode_map(font->dir);\n        if (UnicodeDecoding != NULL && r_type(UnicodeDecoding) == t_dictionary)\n            return gs_font_map_glyph_by_dict(font->memory, UnicodeDecoding, glyph, u, length);\n    }\n    return 0; \n}", "target": 1}
{"code": "void base64_decode_xmlrpc(struct buffer_st *bfr, const char *source, int length)\n{\n    int i;\n    int offset = 0;\n    int endoffile;\n    int count;\n    buffer_new(bfr);\n    for (i = 0; i < 255; i++) {\n\tdtable[i] = 0x80;\n    }\n    for (i = 'A'; i <= 'Z'; i++) {\n        dtable[i] = 0 + (i - 'A');\n    }\n    for (i = 'a'; i <= 'z'; i++) {\n        dtable[i] = 26 + (i - 'a');\n    }\n    for (i = '0'; i <= '9'; i++) {\n        dtable[i] = 52 + (i - '0');\n    }\n    dtable['+'] = 62;\n    dtable['/'] = 63;\n    dtable['='] = 0;\n    endoffile = 0;\n    while (1) {\n\tunsigned char a[4], b[4], o[3];\n\tfor (i = 0; i < 4; i++) {\n\t    int c;\n\t    while (1) {\n\t      c = *(source++);\n\t      offset++;\n\t      if (offset > length) endoffile = 1;\n\t      if (isspace(c) || c == '\\n' || c == '\\r') continue;\n\t      break;\n\t    }\n\t    if (endoffile) {\n\t\treturn;\n\t    }\n\t    if (dtable[c] & 0x80) {\n\t      i--;\n\t      continue;\n\t    }\n\t    a[i] = (unsigned char) c;\n\t    b[i] = (unsigned char) dtable[c];\n\t}\n\to[0] = (b[0] << 2) | (b[1] >> 4);\n\to[1] = (b[1] << 4) | (b[2] >> 2);\n\to[2] = (b[2] << 6) | b[3];\n        i = a[2] == '=' ? 1 : (a[3] == '=' ? 2 : 3);\n\tcount = 0;\n\twhile (count < i) {\n\t  buffer_add(bfr, o[count++]);\n\t}\n\tif (i < 3) {\n\t    return;\n\t}\n    }\n}", "target": 1}
{"code": "int lgff_init(struct hid_device* hid)\n{\n\tstruct hid_input *hidinput = list_entry(hid->inputs.next, struct hid_input, list);\n\tstruct input_dev *dev = hidinput->input;\n\tconst signed short *ff_bits = ff_joystick;\n\tint error;\n\tint i;\n\tif (!hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7))\n\t\treturn -ENODEV;\n\tfor (i = 0; i < ARRAY_SIZE(devices); i++) {\n\t\tif (dev->id.vendor == devices[i].idVendor &&\n\t\t    dev->id.product == devices[i].idProduct) {\n\t\t\tff_bits = devices[i].ff;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i = 0; ff_bits[i] >= 0; i++)\n\t\tset_bit(ff_bits[i], dev->ffbit);\n\terror = input_ff_create_memless(dev, NULL, hid_lgff_play);\n\tif (error)\n\t\treturn error;\n\tif ( test_bit(FF_AUTOCENTER, dev->ffbit) )\n\t\tdev->ff->set_autocenter = hid_lgff_set_autocenter;\n\tpr_info(\"Force feedback for Logitech force feedback devices by Johann Deneux <johann.deneux@it.uu.se>\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "bool st_select_lex::setup_ref_array(THD *thd, uint order_group_num)\n{\n  if (!((options & SELECT_DISTINCT) && !group_list.elements))\n    hidden_bit_fields= 0;\n  order_group_num*= 2;\n  Query_arena *arena= thd->stmt_arena;\n  const uint n_elems= (n_sum_items +\n                       n_child_sum_items +\n                       item_list.elements +\n                       select_n_reserved +\n                       select_n_having_items +\n                       select_n_where_fields +\n                       order_group_num +\n                       hidden_bit_fields +\n                       fields_in_window_functions) * 5;\n  if (!ref_pointer_array.is_null())\n  {\n    if (ref_pointer_array.size() >= n_elems)\n      return false;\n   }\n  Item **array= static_cast<Item**>(arena->alloc(sizeof(Item*) * n_elems));\n  if (array != NULL)\n    ref_pointer_array= Ref_ptr_array(array, n_elems);\n  return array == NULL;\n}", "target": 1}
{"code": "static int fetch_uidl(char *line, void *data)\n{\n  int i, index;\n  struct Context *ctx = (struct Context *) data;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  char *endp = NULL;\n  errno = 0;\n  index = strtol(line, &endp, 10);\n  if (errno)\n    return -1;\n  while (*endp == ' ')\n     endp++;\n   memmove(line, endp, strlen(endp) + 1);\n   for (i = 0; i < ctx->msgcount; i++)\n     if (mutt_str_strcmp(line, ctx->hdrs[i]->data) == 0)\n       break;\n  if (i == ctx->msgcount)\n  {\n    mutt_debug(1, \"new header %d %s\\n\", index, line);\n    if (i >= ctx->hdrmax)\n      mx_alloc_memory(ctx);\n    ctx->msgcount++;\n    ctx->hdrs[i] = mutt_header_new();\n    ctx->hdrs[i]->data = mutt_str_strdup(line);\n  }\n  else if (ctx->hdrs[i]->index != index - 1)\n    pop_data->clear_cache = true;\n  ctx->hdrs[i]->refno = index;\n  ctx->hdrs[i]->index = index - 1;\n  return 0;\n}", "target": 1}
{"code": " void BookmarksIOFunction::ShowSelectFileDialog(\n     ui::SelectFileDialog::Type type,\n     const base::FilePath& default_path) {\n   AddRef();\n  WebContents* web_contents = dispatcher()->delegate()->\n      GetAssociatedWebContents();\n  select_file_dialog_ = ui::SelectFileDialog::Create(\n      this, new ChromeSelectFilePolicy(web_contents));\n  ui::SelectFileDialog::FileTypeInfo file_type_info;\n  file_type_info.extensions.resize(1);\n  file_type_info.extensions[0].push_back(FILE_PATH_LITERAL(\"html\"));\n  if (type == ui::SelectFileDialog::SELECT_OPEN_FILE)\n    file_type_info.support_drive = true;\n  select_file_dialog_->SelectFile(type,\n                                  string16(),\n                                  default_path,\n                                  &file_type_info,\n                                  0,\n                                  FILE_PATH_LITERAL(\"\"),\n                                  NULL,\n                                  NULL);\n}", "target": 1}
{"code": " void OmniboxEditModel::RestoreState(const State* state) {\n   controller_->GetToolbarModel()->set_url_replacement_enabled(\n      !state || state->url_replacement_enabled);\n   permanent_text_ = controller_->GetToolbarModel()->GetText();\n  view_->RevertWithoutResettingSearchTermReplacement();\n  input_ = state ? state->autocomplete_input : AutocompleteInput();\n  if (!state)\n    return;\n  SetFocusState(state->focus_state, OMNIBOX_FOCUS_CHANGE_TAB_SWITCH);\n  focus_source_ = state->focus_source;\n  if (state->user_input_in_progress) {\n    keyword_ = state->keyword;\n    is_keyword_hint_ = state->is_keyword_hint;\n    view_->SetUserText(state->user_text,\n        DisplayTextFromUserText(state->user_text), false);\n    view_->SetGrayTextAutocompletion(state->gray_text);\n  }\n}", "target": 1}
{"code": "get_cookies (SoupCookieJar *jar, SoupURI *uri, gboolean for_http, gboolean copy_cookies)\n{\n\tSoupCookieJarPrivate *priv;\n\tGSList *cookies, *domain_cookies;\n\tchar *domain, *cur, *next_domain;\n\tGSList *new_head, *cookies_to_remove = NULL, *p;\n\tpriv = soup_cookie_jar_get_instance_private (jar);\n\tif (!uri->host)\n\t\treturn NULL;\n\tcookies = NULL;\n\tdomain = cur = g_strdup_printf (\".%s\", uri->host);\n\tnext_domain = domain + 1;\n\tdo {\n\t\tnew_head = domain_cookies = g_hash_table_lookup (priv->domains, cur);\n\t\twhile (domain_cookies) {\n\t\t\tGSList *next = domain_cookies->next;\n\t\t\tSoupCookie *cookie = domain_cookies->data;\n\t\t\tif (cookie->expires && soup_date_is_past (cookie->expires)) {\n\t\t\t\tcookies_to_remove = g_slist_append (cookies_to_remove,\n\t\t\t\t\t\t\t\t    cookie);\n\t\t\t\tnew_head = g_slist_delete_link (new_head, domain_cookies);\n\t\t\t\tg_hash_table_insert (priv->domains,\n\t\t\t\t\t\t     g_strdup (cur),\n\t\t\t\t\t\t     new_head);\n\t\t\t} else if (soup_cookie_applies_to_uri (cookie, uri) &&\n\t\t\t\t   (for_http || !cookie->http_only))\n\t\t\t\tcookies = g_slist_append (cookies, copy_cookies ? soup_cookie_copy (cookie) : cookie);\n\t\t\tdomain_cookies = next;\n\t\t}\n\t\tcur = next_domain;\n\t\tif (cur)\n\t\t\tnext_domain = strchr (cur + 1, '.');\n\t} while (cur);\n\tg_free (domain);\n\tfor (p = cookies_to_remove; p; p = p->next) {\n\t\tSoupCookie *cookie = p->data;\n\t\tsoup_cookie_jar_changed (jar, cookie, NULL);\n\t\tsoup_cookie_free (cookie);\n\t}\n\tg_slist_free (cookies_to_remove);\n\treturn g_slist_sort_with_data (cookies, compare_cookies, jar);\n}", "target": 1}
{"code": " set_text_distance(gs_point *pdist, double dx, double dy, const gs_matrix *pmat)\n {\n    int code = gs_distance_transform_inverse(dx, dy, pmat, pdist);\n     double rounded;\n     if (code == gs_error_undefinedresult) {\n    if (fabs(pdist->x - (rounded = floor(pdist->x + 0.5))) < 0.0005)\n        pdist->x = rounded;\n    if (fabs(pdist->y - (rounded = floor(pdist->y + 0.5))) < 0.0005)\n        pdist->y = rounded;\n    return 0;\n}", "target": 1}
{"code": "std::string TestURLLoader::TestUntendedLoad() {\n  pp::URLRequestInfo request(instance_);\n  request.SetURL(\"test_url_loader_data/hello.txt\");\n  request.SetRecordDownloadProgress(true);\n  TestCompletionCallback callback(instance_->pp_instance(), callback_type());\n  pp::URLLoader loader(instance_);\n  callback.WaitForResult(loader.Open(request, callback.GetCallback()));\n  CHECK_CALLBACK_BEHAVIOR(callback);\n  ASSERT_EQ(PP_OK, callback.result());\n  int64_t bytes_received = 0;\n  int64_t total_bytes_to_be_received = 0;\n  while (true) {\n     loader.GetDownloadProgress(&bytes_received, &total_bytes_to_be_received);\n     if (total_bytes_to_be_received <= 0)\n       return ReportError(\"URLLoader::GetDownloadProgress total size\",\n          total_bytes_to_be_received);\n     if (bytes_received == total_bytes_to_be_received)\n       break;\n    if (pp::Module::Get()->core()->IsMainThread()) {\n      NestedEvent event(instance_->pp_instance());\n      event.PostSignal(10);\n      event.Wait();\n    }\n  }\n  std::string body;\n  std::string error = ReadEntireResponseBody(&loader, &body);\n  if (!error.empty())\n    return error;\n  if (body != \"hello\\n\")\n    return ReportError(\"Couldn't read data\", callback.result());\n  PASS();\n}", "target": 1}
{"code": "bool SubsetterImpl::ResolveCompositeGlyphs(const unsigned int* glyph_ids,\n                                           size_t glyph_count,\n                                           IntegerSet* glyph_id_processed) {\n  if (glyph_ids == NULL || glyph_count == 0 || glyph_id_processed == NULL) {\n    return false;\n  }\n  GlyphTablePtr glyph_table =\n      down_cast<GlyphTable*>(font_->GetTable(Tag::glyf));\n  LocaTablePtr loca_table = down_cast<LocaTable*>(font_->GetTable(Tag::loca));\n  if (glyph_table == NULL || loca_table == NULL) {\n    return false;\n  }\n  IntegerSet glyph_id_remaining;\n  glyph_id_remaining.insert(0);  \n  for (size_t i = 0; i < glyph_count; ++i) {\n    glyph_id_remaining.insert(glyph_ids[i]);\n  }\n  while (!glyph_id_remaining.empty()) {\n    IntegerSet comp_glyph_id;\n    for (IntegerSet::iterator i = glyph_id_remaining.begin(),\n                              e = glyph_id_remaining.end(); i != e; ++i) {\n      if (*i < 0 || *i >= loca_table->NumGlyphs()) {\n        continue;\n      }\n      int32_t length = loca_table->GlyphLength(*i);\n      if (length == 0) {\n        continue;\n      }\n      int32_t offset = loca_table->GlyphOffset(*i);\n      GlyphPtr glyph;\n      glyph.Attach(glyph_table->GetGlyph(offset, length));\n      if (glyph == NULL) {\n        continue;\n      }\n      if (glyph->GlyphType() == GlyphType::kComposite) {\n        Ptr<GlyphTable::CompositeGlyph> comp_glyph =\n            down_cast<GlyphTable::CompositeGlyph*>(glyph.p_);\n        for (int32_t j = 0; j < comp_glyph->NumGlyphs(); ++j) {\n          int32_t glyph_id = comp_glyph->GlyphIndex(j);\n          if (glyph_id_processed->find(glyph_id) == glyph_id_processed->end() &&\n              glyph_id_remaining.find(glyph_id) == glyph_id_remaining.end()) {\n            comp_glyph_id.insert(comp_glyph->GlyphIndex(j));\n          }\n        }\n      }\n      glyph_id_processed->insert(*i);\n    }\n     glyph_id_remaining.clear();\n     glyph_id_remaining = comp_glyph_id;\n   }\n }", "target": 1}
{"code": "static long media_device_enum_entities(struct media_device *mdev,\n\t\t\t\t       struct media_entity_desc __user *uent)\n{\n \tstruct media_entity *ent;\n \tstruct media_entity_desc u_ent;\n \tif (copy_from_user(&u_ent.id, &uent->id, sizeof(u_ent.id)))\n \t\treturn -EFAULT;\n\tent = find_entity(mdev, u_ent.id);\n\tif (ent == NULL)\n\t\treturn -EINVAL;\n\tu_ent.id = ent->id;\n\tif (ent->name) {\n\t\tstrncpy(u_ent.name, ent->name, sizeof(u_ent.name));\n\t\tu_ent.name[sizeof(u_ent.name) - 1] = '\\0';\n\t} else {\n\t\tmemset(u_ent.name, 0, sizeof(u_ent.name));\n\t}\n\tu_ent.type = ent->type;\n\tu_ent.revision = ent->revision;\n\tu_ent.flags = ent->flags;\n\tu_ent.group_id = ent->group_id;\n\tu_ent.pads = ent->num_pads;\n\tu_ent.links = ent->num_links - ent->num_backlinks;\n\tmemcpy(&u_ent.raw, &ent->info, sizeof(ent->info));\n\tif (copy_to_user(uent, &u_ent, sizeof(u_ent)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "ex_copy(linenr_T line1, linenr_T line2, linenr_T n)\n{\n    linenr_T\tcount;\n    char_u\t*p;\n    count = line2 - line1 + 1;\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\tcurbuf->b_op_start.lnum = n + 1;\n\tcurbuf->b_op_end.lnum = n + count;\n\tcurbuf->b_op_start.col = curbuf->b_op_end.col = 0;\n    }\n    if (u_save(n, n + 1) == FAIL)\n\treturn;\n    curwin->w_cursor.lnum = n;\n    while (line1 <= line2)\n    {\n\tp = vim_strsave(ml_get(line1));\n\tif (p != NULL)\n\t{\n\t    ml_append(curwin->w_cursor.lnum, p, (colnr_T)0, FALSE);\n\t    vim_free(p);\n\t}\n\tif (line1 == n)\n\t    line1 = curwin->w_cursor.lnum;\n\t++line1;\n\tif (curwin->w_cursor.lnum < line1)\n\t    ++line1;\n\tif (curwin->w_cursor.lnum < line2)\n\t    ++line2;\n\t++curwin->w_cursor.lnum;\n    }\n    appended_lines_mark(n, count);\n    msgmore((long)count);\n}", "target": 1}
{"code": "static void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,\n\tstruct oz_usb_hdr *usb_hdr, int len)\n{\n\tstruct oz_data *data_hdr = (struct oz_data *)usb_hdr;\n\tswitch (data_hdr->format) {\n\tcase OZ_DATA_F_MULTIPLE_FIXED: {\n \t\t\tstruct oz_multiple_fixed *body =\n \t\t\t\t(struct oz_multiple_fixed *)data_hdr;\n \t\t\tu8 *data = body->data;\n\t\t\tint n = (len - sizeof(struct oz_multiple_fixed)+1)\n \t\t\t\t/ body->unit_size;\n \t\t\twhile (n--) {\n \t\t\t\toz_hcd_data_ind(usb_ctx->hport, body->endpoint,\n\t\t\t\t\tdata, body->unit_size);\n\t\t\t\tdata += body->unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase OZ_DATA_F_ISOC_FIXED: {\n\t\t\tstruct oz_isoc_fixed *body =\n\t\t\t\t(struct oz_isoc_fixed *)data_hdr;\n\t\t\tint data_len = len-sizeof(struct oz_isoc_fixed)+1;\n\t\t\tint unit_size = body->unit_size;\n\t\t\tu8 *data = body->data;\n\t\t\tint count;\n\t\t\tint i;\n\t\t\tif (!unit_size)\n\t\t\t\tbreak;\n\t\t\tcount = data_len/unit_size;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\toz_hcd_data_ind(usb_ctx->hport,\n\t\t\t\t\tbody->endpoint, data, unit_size);\n\t\t\t\tdata += unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "uint64_t hllCount(struct hllhdr *hdr, int *invalid) {\n    double m = HLL_REGISTERS;\n    double E;\n    int j;\n    int reghisto[HLL_Q+2] = {0};\n    if (hdr->encoding == HLL_DENSE) {\n        hllDenseRegHisto(hdr->registers,reghisto);\n    } else if (hdr->encoding == HLL_SPARSE) {\n        hllSparseRegHisto(hdr->registers,\n                         sdslen((sds)hdr)-HLL_HDR_SIZE,invalid,reghisto);\n    } else if (hdr->encoding == HLL_RAW) {\n        hllRawRegHisto(hdr->registers,reghisto);\n    } else {\n        serverPanic(\"Unknown HyperLogLog encoding in hllCount()\");\n    }\n    double z = m * hllTau((m-reghisto[HLL_Q+1])/(double)m);\n    for (j = HLL_Q; j >= 1; --j) {\n        z += reghisto[j];\n        z *= 0.5;\n    }\n    z += m * hllSigma(reghisto[0]/(double)m);\n    E = llroundl(HLL_ALPHA_INF*m*m/z);\n    return (uint64_t) E;\n}", "target": 1}
{"code": "xmlNodePtr SimpleXMLElement_exportNode(const Object& sxe) {\n  assert(sxe->instanceof(SimpleXMLElement_classof()));\n  auto data = Native::data<SimpleXMLElement>(sxe.get());\n  return php_sxe_get_first_node(data, data->nodep());\n}", "target": 1}
{"code": "   void CreateAuthenticatorFactory() {\n     DCHECK(context_->network_task_runner()->BelongsToCurrentThread());\n     std::string local_certificate = key_pair_.GenerateCertificate();\n     if (local_certificate.empty()) {\n       LOG(ERROR) << \"Failed to generate host certificate.\";\n      Shutdown(kHostInitializationFailed);\n      return;\n    }\n    scoped_ptr<protocol::AuthenticatorFactory> factory(\n        new protocol::Me2MeHostAuthenticatorFactory(\n            local_certificate, *key_pair_.private_key(), host_secret_hash_));\n    host_->SetAuthenticatorFactory(factory.Pass());\n  }", "target": 1}
{"code": " ExtensionFunction::ResponseAction BluetoothSocketSendFunction::Run() {\n   DCHECK_CURRENTLY_ON(work_thread_id());\n  auto params = bluetooth_socket::Send::Params::Create(*args_);\n  EXTENSION_FUNCTION_VALIDATE(params.get());\n  io_buffer_size_ = params->data.size();\n  io_buffer_ = new net::WrappedIOBuffer(params->data.data());\n  BluetoothApiSocket* socket = GetSocket(params->socket_id);\n   if (!socket)\n     return RespondNow(Error(kSocketNotFoundError));\n  socket->Send(io_buffer_,\n               io_buffer_size_,\n               base::Bind(&BluetoothSocketSendFunction::OnSuccess, this),\n               base::Bind(&BluetoothSocketSendFunction::OnError, this));\n  return did_respond() ? AlreadyResponded() : RespondLater();\n}", "target": 1}
{"code": "void TensorSliceReader::LoadShard(int shard) const {\n  CHECK_LT(shard, sss_.size());\n  if (sss_[shard] || !status_.ok()) {\n    return;  \n  }\n  string value;\n  SavedTensorSlices sts;\n  const string fname = fnames_[shard];\n  VLOG(1) << \"Reading meta data from file \" << fname << \"...\";\n  Table* table;\n  Status s = open_function_(fname, &table);\n  if (!s.ok()) {\n    status_ = errors::DataLoss(\"Unable to open table file \", fname, \": \",\n                               s.ToString());\n    return;\n  }\n  sss_[shard].reset(table);\n  if (!(table->Get(kSavedTensorSlicesKey, &value) &&\n        ParseProtoUnlimited(&sts, value))) {\n    status_ = errors::Internal(\n        \"Failed to find the saved tensor slices at the beginning of the \"\n        \"checkpoint file: \",\n        fname);\n    return;\n  }\n  status_ = CheckVersions(sts.meta().versions(), TF_CHECKPOINT_VERSION,\n                          TF_CHECKPOINT_VERSION_MIN_PRODUCER, \"Checkpoint\",\n                          \"checkpoint\");\n  if (!status_.ok()) return;\n  for (const SavedSliceMeta& ssm : sts.meta().tensor()) {\n    TensorShape ssm_shape(ssm.shape());\n    for (const TensorSliceProto& tsp : ssm.slice()) {\n      TensorSlice ss_slice(tsp);\n      status_ = RegisterTensorSlice(ssm.name(), ssm_shape, ssm.type(), fname,\n                                    ss_slice, &tensors_);\n      if (!status_.ok()) return;\n    }\n  }\n}", "target": 1}
{"code": "int yr_re_ast_create(\n    RE_AST** re_ast)\n{\n  *re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));\n  if (*re_ast == NULL)\n     return ERROR_INSUFFICIENT_MEMORY;\n   (*re_ast)->flags = 0;\n   (*re_ast)->root_node = NULL;\n   return ERROR_SUCCESS;\n}", "target": 1}
{"code": "void oz_hcd_get_desc_cnf(void *hport, u8 req_id, int status, const u8 *desc,\n\t\t\tint length, int offset, int total_size)\n {\n \tstruct oz_port *port = hport;\n \tstruct urb *urb;\n\tint err = 0;\n\toz_dbg(ON, \"oz_hcd_get_desc_cnf length = %d offs = %d tot_size = %d\\n\",\n\t       length, offset, total_size);\n\turb = oz_find_urb_by_id(port, 0, req_id);\n \tif (!urb)\n \t\treturn;\n \tif (status == 0) {\n\t\tint copy_len;\n\t\tint required_size = urb->transfer_buffer_length;\n \t\tif (required_size > total_size)\n \t\t\trequired_size = total_size;\n\t\tcopy_len = required_size-offset;\n\t\tif (length <= copy_len)\n\t\t\tcopy_len = length;\n\t\tmemcpy(urb->transfer_buffer+offset, desc, copy_len);\n\t\toffset += copy_len;\n\t\tif (offset < required_size) {\n\t\t\tstruct usb_ctrlrequest *setup =\n\t\t\t\t(struct usb_ctrlrequest *)urb->setup_packet;\n\t\t\tunsigned wvalue = le16_to_cpu(setup->wValue);\n\t\t\tif (oz_enqueue_ep_urb(port, 0, 0, urb, req_id))\n\t\t\t\terr = -ENOMEM;\n\t\t\telse if (oz_usb_get_desc_req(port->hpd, req_id,\n\t\t\t\t\tsetup->bRequestType, (u8)(wvalue>>8),\n\t\t\t\t\t(u8)wvalue, setup->wIndex, offset,\n\t\t\t\t\trequired_size-offset)) {\n\t\t\t\toz_dequeue_ep_urb(port, 0, 0, urb);\n\t\t\t\terr = -ENOMEM;\n\t\t\t}\n\t\t\tif (err == 0)\n\t\t\t\treturn;\n\t\t}\n\t}\n\turb->actual_length = total_size;\n\toz_complete_urb(port->ozhcd->hcd, urb, 0);\n}", "target": 1}
{"code": "static bool do_write_pids(pid_t tpid, const char *contrl, const char *cg, const char *file, const char *buf)\n {\n \tint sock[2] = {-1, -1};\n \tpid_t qpid, cpid = -1;\n\tFILE *pids_file = NULL;\n\tbool answer = false, fail = false;\n\tpids_file = open_pids_file(contrl, cg);\n\tif (!pids_file)\n\t\treturn false;\n\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, sock) < 0) {\n\t\tperror(\"socketpair\");\n\t\tgoto out;\n\t}\n\tcpid = fork();\n\tif (cpid == -1)\n\t\tgoto out;\n\tif (!cpid) { \n\t\tfclose(pids_file);\n\t\tpid_from_ns_wrapper(sock[1], tpid);\n\t}\n\tconst char *ptr = buf;\n\twhile (sscanf(ptr, \"%d\", &qpid) == 1) {\n\t\tstruct ucred cred;\n\t\tchar v;\n\t\tif (write(sock[0], &qpid, sizeof(qpid)) != sizeof(qpid)) {\n\t\t\tfprintf(stderr, \"%s: error writing pid to child: %s\\n\",\n\t\t\t\t__func__, strerror(errno));\n\t\t\tgoto out;\n\t\t}\n \t\tif (recv_creds(sock[0], &cred, &v)) {\n \t\t\tif (v == '0') {\n \t\t\t\tif (fprintf(pids_file, \"%d\", (int) cred.pid) < 0)\n \t\t\t\t\tfail = true;\n \t\t\t}\n\t\t}\n\t\tptr = strchr(ptr, '\\n');\n\t\tif (!ptr)\n\t\t\tbreak;\n\t\tptr++;\n\t}\n\tqpid = -1;\n\tif (write(sock[0], &qpid ,sizeof(qpid)) != sizeof(qpid))\n\t\tfprintf(stderr, \"Warning: failed to ask child to exit\\n\");\n\tif (!fail)\n\t\tanswer = true;\nout:\n\tif (cpid != -1)\n\t\twait_for_pid(cpid);\n\tif (sock[0] != -1) {\n\t\tclose(sock[0]);\n\t\tclose(sock[1]);\n\t}\n\tif (pids_file) {\n\t\tif (fclose(pids_file) != 0)\n\t\t\tanswer = false;\n\t}\n\treturn answer;\n}", "target": 1}
{"code": "static void exif_process_APP12(image_info_type *ImageInfo,\n                               char *buffer, size_t length) {\n  size_t l1, l2=0;\n  if ((l1 = php_strnlen(buffer+2, length-2)) > 0) {\n    exif_iif_add_tag(ImageInfo, SECTION_APP12, \"Company\",\n                     TAG_NONE, TAG_FMT_STRING, l1, buffer+2);\n    if (length > 2+l1+1) {\n      l2 = php_strnlen(buffer+2+l1+1, length-2-l1+1);\n      exif_iif_add_tag(ImageInfo, SECTION_APP12, \"Info\",\n                       TAG_NONE, TAG_FMT_STRING, l2, buffer+2+l1+1);\n    }\n  }\n}", "target": 1}
{"code": "file_continue(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    es_ptr pscratch = esp - 2;\n    file_enum *pfen = r_ptr(esp - 1, file_enum);\n    int devlen = esp[-3].value.intval;\n    gx_io_device *iodev = r_ptr(esp - 4, gx_io_device);\n    uint len = r_size(pscratch);\n    uint code;\n    if (len < devlen)\n        return_error(gs_error_rangecheck);     \n    do {\n        memcpy((char *)pscratch->value.bytes, iodev->dname, devlen);\n        code = iodev->procs.enumerate_next(pfen, (char *)pscratch->value.bytes + devlen,\n                    len - devlen);\n        if (code == ~(uint) 0) {    \n            esp -= 5;               \n            return o_pop_estack;\n         } else if (code > len)      \n             return_error(gs_error_rangecheck);\n         else if (iodev != iodev_default(imemory)\n              || (check_file_permissions_reduced(i_ctx_p, (char *)pscratch->value.bytes, code + devlen, iodev, \"PermitFileReading\")) == 0) {\n             push(1);\n             ref_assign(op, pscratch);\n             r_set_size(op, code + devlen);\n            push_op_estack(file_continue);  \n            *++esp = pscratch[2];   \n            return o_push_estack;\n        }\n    } while(1);\n}", "target": 1}
{"code": "static int snd_compress_check_input(struct snd_compr_params *params)\n {\n \tif (params->buffer.fragment_size == 0 ||\n\t\t\tparams->buffer.fragments > SIZE_MAX / params->buffer.fragment_size)\n \t\treturn -EINVAL;\n\tif (params->codec.id == 0 || params->codec.id > SND_AUDIOCODEC_MAX)\n\t\treturn -EINVAL;\n\tif (params->codec.ch_in == 0 || params->codec.ch_out == 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": " int unshare_userns(unsigned long unshare_flags, struct cred **new_cred)\n {\n \tstruct cred *cred;\n \tif (!(unshare_flags & CLONE_NEWUSER))\n \t\treturn 0;\n \tcred = prepare_creds();\n\tif (!cred)\n\t\treturn -ENOMEM;\n\t*new_cred = cred;\n\treturn create_user_ns(cred);\n }", "target": 1}
{"code": "static GF_Err BM_ParseGlobalQuantizer(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tGF_Node *node;\n\tGF_Command *com;\n\tGF_CommandField *inf;\n\tnode = gf_bifs_dec_node(codec, bs, NDT_SFWorldNode);\n\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\tif (codec->scenegraph->global_qp) {\n\t\tgf_node_unregister(codec->scenegraph->global_qp, NULL);\n\t}\n\tcodec->ActiveQP = NULL;\n\tcodec->scenegraph->global_qp = NULL;\n\tif (gf_node_get_tag(node) != TAG_MPEG4_QuantizationParameter) {\n\t\tgf_node_unregister(node, NULL);\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tcodec->ActiveQP = (M_QuantizationParameter *) node;\n\tcodec->ActiveQP->isLocal = 0;\n\tcodec->scenegraph->global_qp = node;\n\tnode->sgprivate->num_instances = 2;\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER);\n\tinf = gf_sg_command_field_new(com);\n\tinf->new_node = node;\n\tinf->field_ptr = &inf->new_node;\n\tinf->fieldType = GF_SG_VRML_SFNODE;\n\tgf_list_add(com_list, com);\n\treturn GF_OK;\n}", "target": 1}
{"code": "IceGenerateMagicCookie (\n \tint len\n )\n {\n    char    *auth;\n#ifndef HAVE_ARC4RANDOM_BUF\n     long    ldata[2];\n     int\t    seed;\n     int\t    value;\n     int\t    i;\n#endif\n    if ((auth = malloc (len + 1)) == NULL)\n\treturn (NULL);\n#ifdef HAVE_ARC4RANDOM_BUF\n    arc4random_buf(auth, len);\n#else\n #ifdef ITIMER_REAL\n     {\n \tstruct timeval  now;\n    int\t    i;\n \tldata[0] = now.tv_sec;\n \tldata[1] = now.tv_usec;\n     }\n#else\n     {\n \tlong    time ();\n \tldata[0] = time ((long *) 0);\n \tldata[1] = getpid ();\n     }\n#endif\n     seed = (ldata[0]) + (ldata[1] << 16);\n     srand (seed);\n     for (i = 0; i < len; i++)\n\tldata[1] = now.tv_usec;\n \tvalue = rand ();\n \tauth[i] = value & 0xff;\n     }", "target": 1}
{"code": "static struct ib_ucontext *hns_roce_alloc_ucontext(struct ib_device *ib_dev,\n\t\t\t\t\t\t   struct ib_udata *udata)\n {\n \tint ret = 0;\n \tstruct hns_roce_ucontext *context;\n\tstruct hns_roce_ib_alloc_ucontext_resp resp;\n \tstruct hns_roce_dev *hr_dev = to_hr_dev(ib_dev);\n \tresp.qp_tab_size = hr_dev->caps.num_qps;\n\tcontext = kmalloc(sizeof(*context), GFP_KERNEL);\n\tif (!context)\n\t\treturn ERR_PTR(-ENOMEM);\n\tret = hns_roce_uar_alloc(hr_dev, &context->uar);\n\tif (ret)\n\t\tgoto error_fail_uar_alloc;\n\tif (hr_dev->caps.flags & HNS_ROCE_CAP_FLAG_RECORD_DB) {\n\t\tINIT_LIST_HEAD(&context->page_list);\n\t\tmutex_init(&context->page_mutex);\n\t}\n\tret = ib_copy_to_udata(udata, &resp, sizeof(resp));\n\tif (ret)\n\t\tgoto error_fail_copy_to_udata;\n\treturn &context->ibucontext;\nerror_fail_copy_to_udata:\n\thns_roce_uar_free(hr_dev, &context->uar);\nerror_fail_uar_alloc:\n\tkfree(context);\n\treturn ERR_PTR(ret);\n}", "target": 1}
{"code": "int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],\n\t\t     unsigned char multicast_spec, u8 protocol_version)\n{\n\tstruct hsr_priv *hsr;\n\tstruct hsr_port *port;\n\tint res;\n\thsr = netdev_priv(hsr_dev);\n\tINIT_LIST_HEAD(&hsr->ports);\n\tINIT_LIST_HEAD(&hsr->node_db);\n\tINIT_LIST_HEAD(&hsr->self_node_db);\n\tether_addr_copy(hsr_dev->dev_addr, slave[0]->dev_addr);\n\tres = hsr_create_self_node(&hsr->self_node_db, hsr_dev->dev_addr,\n\t\t\t\t   slave[1]->dev_addr);\n\tif (res < 0)\n\t\treturn res;\n\tspin_lock_init(&hsr->seqnr_lock);\n\thsr->sequence_nr = HSR_SEQNR_START;\n\thsr->sup_sequence_nr = HSR_SUP_SEQNR_START;\n\ttimer_setup(&hsr->announce_timer, hsr_announce, 0);\n\ttimer_setup(&hsr->prune_timer, hsr_prune_nodes, 0);\n\tether_addr_copy(hsr->sup_multicast_addr, def_multicast_addr);\n\thsr->sup_multicast_addr[ETH_ALEN - 1] = multicast_spec;\n\thsr->protVersion = protocol_version;\n\tnetif_carrier_off(hsr_dev);\n \tres = hsr_add_port(hsr, hsr_dev, HSR_PT_MASTER);\n \tif (res)\n\t\treturn res;\n \tres = register_netdevice(hsr_dev);\n \tif (res)\n\t\tgoto fail;\n\tres = hsr_add_port(hsr, slave[0], HSR_PT_SLAVE_A);\n\tif (res)\n\t\tgoto fail;\n\tres = hsr_add_port(hsr, slave[1], HSR_PT_SLAVE_B);\n\tif (res)\n\t\tgoto fail;\n\tmod_timer(&hsr->prune_timer, jiffies + msecs_to_jiffies(PRUNE_PERIOD));\n\treturn 0;\n fail:\n \thsr_for_each_port(hsr, port)\n \t\thsr_del_port(port);\n \treturn res;\n }", "target": 1}
{"code": "get_visual_text(\n    cmdarg_T\t*cap,\n    char_u\t**pp,\t    \n    int\t\t*lenp)\t    \n{\n    if (VIsual_mode != 'V')\n\tunadjust_for_sel();\n    if (VIsual.lnum != curwin->w_cursor.lnum)\n    {\n\tif (cap != NULL)\n\t    clearopbeep(cap->oap);\n\treturn FAIL;\n    }\n    if (VIsual_mode == 'V')\n    {\n\t*pp = ml_get_curline();\n\t*lenp = (int)STRLEN(*pp);\n    }\n    else\n    {\n\tif (LT_POS(curwin->w_cursor, VIsual))\n\t{\n\t    *pp = ml_get_pos(&curwin->w_cursor);\n\t    *lenp = VIsual.col - curwin->w_cursor.col + 1;\n\t}\n\telse\n\t{\n\t    *pp = ml_get_pos(&VIsual);\n\t    *lenp = curwin->w_cursor.col - VIsual.col + 1;\n\t}\n\tif (**pp == NUL)\n\t    *lenp = 0;\n\tif (has_mbyte && *lenp > 0)\n\t    *lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;\n    }\n    reset_VIsual_and_resel();\n    return OK;\n}", "target": 1}
{"code": "fname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  \n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n    if (name != NULL)\n    {\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse\n\t{\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n    return match;\n}", "target": 1}
{"code": "static int nfc_genl_deactivate_target(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n \tu32 device_idx, target_idx;\n \tint rc;\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n \t\treturn -EINVAL;\n \tdevice_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tdev = nfc_get_device(device_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\ttarget_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);\n\trc = nfc_deactivate_target(dev, target_idx, NFC_TARGET_MODE_SLEEP);\n\tnfc_put_device(dev);\n\treturn rc;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor* epsilon_t;\n    OP_REQUIRES_OK(context, context->input(kEpsilonName, &epsilon_t));\n    float epsilon = epsilon_t->scalar<float>()();\n    OP_REQUIRES(\n        context, epsilon > 0,\n        errors::InvalidArgument(\"An epsilon value of zero is not allowed.\"));\n    const Tensor* num_streams_t;\n    OP_REQUIRES_OK(context, context->input(kNumStreamsName, &num_streams_t));\n    int64_t num_streams = num_streams_t->scalar<int64>()();\n    auto result =\n        new QuantileStreamResource(epsilon, max_elements_, num_streams);\n    auto status = CreateResource(context, HandleFromInput(context, 0), result);\n    if (!status.ok() && status.code() != tensorflow::error::ALREADY_EXISTS) {\n      OP_REQUIRES(context, false, status);\n    }\n  }", "target": 1}
{"code": "PHP_FUNCTION( msgfmt_format_message )\n{\n\tzval       *args;\n\tUChar      *spattern = NULL;\n\tint         spattern_len = 0;\n\tchar       *pattern = NULL;\n\tint         pattern_len = 0;\n\tconst char *slocale = NULL;\n\tint         slocale_len = 0;\n\tMessageFormatter_object mf = {0};\n\tMessageFormatter_object *mfo = &mf;\n\tif( zend_parse_method_parameters( ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"ssa\",\n\t\t  &slocale, &slocale_len, &pattern, &pattern_len, &args ) == FAILURE )\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t\"msgfmt_format_message: unable to parse input params\", 0 TSRMLS_CC );\n \t\tRETURN_FALSE;\n \t}\n \tmsgformat_data_init(&mfo->mf_data TSRMLS_CC);\n \tif(pattern && pattern_len) {\n\t\tintl_convert_utf8_to_utf16(&spattern, &spattern_len, pattern, pattern_len, &INTL_DATA_ERROR_CODE(mfo));\n\t\tif( U_FAILURE(INTL_DATA_ERROR_CODE((mfo))) )\n\t\t{\n\t\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t\t\"msgfmt_format_message: error converting pattern to UTF-16\", 0 TSRMLS_CC );\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tspattern_len = 0;\n\t\tspattern = NULL;\n\t}\n\tif(slocale_len == 0) {\n\t\tslocale = intl_locale_get_default(TSRMLS_C);\n\t}\n#ifdef MSG_FORMAT_QUOTE_APOS\n\tif(msgformat_fix_quotes(&spattern, &spattern_len, &INTL_DATA_ERROR_CODE(mfo)) != SUCCESS) {\n\t\tintl_error_set( NULL, U_INVALID_FORMAT_ERROR,\n\t\t\t\"msgfmt_format_message: error converting pattern to quote-friendly format\", 0 TSRMLS_CC );\n\t\tRETURN_FALSE;\n\t}\n#endif\n\tMSG_FORMAT_OBJECT(mfo) = umsg_open(spattern, spattern_len, slocale, NULL, &INTL_DATA_ERROR_CODE(mfo));\n\tif(spattern && spattern_len) {\n\t\tefree(spattern);\n\t}\n\tINTL_METHOD_CHECK_STATUS(mfo, \"Creating message formatter failed\");\n\tmsgfmt_do_format(mfo, args, return_value TSRMLS_CC);\n\tmsgformat_data_free(&mfo->mf_data TSRMLS_CC);\n}", "target": 1}
{"code": "struct sock *inet_csk_clone_lock(const struct sock *sk,\n\t\t\t\t const struct request_sock *req,\n\t\t\t\t const gfp_t priority)\n{\n\tstruct sock *newsk = sk_clone_lock(sk, priority);\n\tif (newsk) {\n\t\tstruct inet_connection_sock *newicsk = inet_csk(newsk);\n\t\tnewsk->sk_state = TCP_SYN_RECV;\n\t\tnewicsk->icsk_bind_hash = NULL;\n\t\tinet_sk(newsk)->inet_dport = inet_rsk(req)->ir_rmt_port;\n\t\tinet_sk(newsk)->inet_num = inet_rsk(req)->ir_num;\n\t\tinet_sk(newsk)->inet_sport = htons(inet_rsk(req)->ir_num);\n\t\tnewsk->sk_write_space = sk_stream_write_space;\n \t\tsock_reset_flag(newsk, SOCK_RCU_FREE);\n \t\tnewsk->sk_mark = inet_rsk(req)->ir_mark;\n \t\tatomic64_set(&newsk->sk_cookie,\n \t\t\t     atomic64_read(&inet_rsk(req)->ir_cookie));\n\t\tnewicsk->icsk_retransmits = 0;\n\t\tnewicsk->icsk_backoff\t  = 0;\n\t\tnewicsk->icsk_probes_out  = 0;\n\t\tmemset(&newicsk->icsk_accept_queue, 0, sizeof(newicsk->icsk_accept_queue));\n\t\tsecurity_inet_csk_clone(newsk, req);\n\t}\n\treturn newsk;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const float in_min = context->input(2).flat<float>()(0);\n    const float in_max = context->input(3).flat<float>()(0);\n    ImageResizerState st(align_corners_, false);\n    st.ValidateAndCreateOutput(context);\n    if (!context->status().ok()) return;\n    if (st.output->NumElements() == 0) return;\n    typename TTypes<T, 4>::ConstTensor image_data(\n        context->input(0).tensor<T, 4>());\n    typename TTypes<T, 4>::Tensor output_data(st.output->tensor<T, 4>());\n    ResizeBilinear<T>(image_data, st.height_scale, st.width_scale, in_min,\n                      in_max, half_pixel_centers_, &output_data);\n    Tensor* out_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &out_min));\n    out_min->flat<float>()(0) = in_min;\n    Tensor* out_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &out_max));\n    out_max->flat<float>()(0) = in_max;\n  }", "target": 1}
{"code": "static int __io_sync_cancel(struct io_uring_task *tctx,\n\t\t\t    struct io_cancel_data *cd, int fd)\n{\n\tstruct io_ring_ctx *ctx = cd->ctx;\n\tif ((cd->flags & IORING_ASYNC_CANCEL_FD) &&\n\t    (cd->flags & IORING_ASYNC_CANCEL_FD_FIXED)) {\n\t\tunsigned long file_ptr;\n\t\tif (unlikely(fd > ctx->nr_user_files))\n\t\t\treturn -EBADF;\n\t\tfd = array_index_nospec(fd, ctx->nr_user_files);\n\t\tfile_ptr = io_fixed_file_slot(&ctx->file_table, fd)->file_ptr;\n\t\tcd->file = (struct file *) (file_ptr & FFS_MASK);\n\t\tif (!cd->file)\n\t\t\treturn -EBADF;\n\t}\n\treturn __io_async_cancel(cd, tctx, 0);\n}", "target": 1}
{"code": "static const char *escape_identifier(const char *identifier)\n{\n\tsize_t pos = strcspn(identifier, \"./%\");\n\tif (pos < strlen(identifier)) {\n\t\tstring_t *new_id = t_str_new(strlen(identifier));\n\t\tstr_append_data(new_id, identifier, pos);\n\t\tfor (const char *c = identifier+pos; *c != '\\0'; c++) {\n\t\t\tswitch (*c) {\n\t\t\tcase '.':\n\t\t\t\tstr_append(new_id, \"%2e\");\n\t\t\t\tbreak;\n\t\t\tcase '/':\n\t\t\t\tstr_append(new_id, \"%2f\");\n\t\t\t\tbreak;\n\t\t\tcase '%':\n\t\t\t\tstr_append(new_id, \"%25\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstr_append_c(new_id, *c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn str_c(new_id);\n\t}\n\treturn identifier;\n}", "target": 1}
{"code": "CallResult<PseudoHandle<>> JSObject::getComputedWithReceiver_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    Handle<> receiver) {\n  if (selfHandle->flags_.fastIndexProperties) {\n    if (auto arrayIndex = toArrayIndexFastPath(*nameValHandle)) {\n      PseudoHandle<> ourValue = createPseudoHandle(\n          getOwnIndexed(selfHandle.get(), runtime, *arrayIndex));\n      if (LLVM_LIKELY(!ourValue->isEmpty()))\n        return ourValue;\n    }\n  }\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto nameValPrimitiveHandle = *converted;\n  ComputedPropertyDescriptor desc;\n  MutableHandle<JSObject> propObj{runtime};\n  if (LLVM_UNLIKELY(\n          getComputedPrimitiveDescriptor(\n              selfHandle, runtime, nameValPrimitiveHandle, propObj, desc) ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  if (!propObj)\n    return createPseudoHandle(HermesValue::encodeUndefinedValue());\n  if (LLVM_LIKELY(\n          !desc.flags.accessor && !desc.flags.hostObject &&\n          !desc.flags.proxyObject))\n    return createPseudoHandle(\n        getComputedSlotValue(propObj.get(), runtime, desc));\n  if (desc.flags.accessor) {\n    auto *accessor = vmcast<PropertyAccessor>(\n        getComputedSlotValue(propObj.get(), runtime, desc));\n    if (!accessor->getter)\n      return createPseudoHandle(HermesValue::encodeUndefinedValue());\n    return accessor->getter.get(runtime)->executeCall0(\n        runtime->makeHandle(accessor->getter), runtime, receiver);\n  } else if (desc.flags.hostObject) {\n    SymbolID id{};\n    LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n    auto propRes = vmcast<HostObject>(selfHandle.get())->get(id);\n    if (propRes == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return createPseudoHandle(*propRes);\n  } else {\n    assert(desc.flags.proxyObject && \"descriptor flags are impossible\");\n    CallResult<Handle<>> key = toPropertyKey(runtime, nameValPrimitiveHandle);\n    if (key == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return JSProxy::getComputed(propObj, runtime, *key, receiver);\n  }\n}", "target": 1}
{"code": "void PDFDoc::markObject (Object* obj, XRef *xRef, XRef *countRef, unsigned int numOffset, int oldRefNum, int newRefNum, std::set<Dict*> *alreadyMarkedDicts)\n{\n  Array *array;\n  switch (obj->getType()) {\n    case objArray:\n      array = obj->getArray();\n      for (int i=0; i<array->getLength(); i++) {\n        Object obj1 = array->getNF(i).copy();\n        markObject(&obj1, xRef, countRef, numOffset, oldRefNum, newRefNum);\n      }\n      break;\n    case objDict:\n      markDictionnary (obj->getDict(), xRef, countRef, numOffset, oldRefNum, newRefNum, alreadyMarkedDicts);\n      break;\n    case objStream: \n      {\n        Stream *stream = obj->getStream();\n        markDictionnary (stream->getDict(), xRef, countRef, numOffset, oldRefNum, newRefNum, alreadyMarkedDicts);\n      }\n      break;\n    case objRef:\n      {\n        if (obj->getRef().num + (int) numOffset >= xRef->getNumObjects() || xRef->getEntry(obj->getRef().num + numOffset)->type == xrefEntryFree) {\n          if (getXRef()->getEntry(obj->getRef().num)->type == xrefEntryFree) {\n            return;  \n          }\n          xRef->add(obj->getRef().num + numOffset, obj->getRef().gen, 0, true);\n          if (getXRef()->getEntry(obj->getRef().num)->type == xrefEntryCompressed) {\n            xRef->getEntry(obj->getRef().num + numOffset)->type = xrefEntryCompressed;\n          }\n        }\n        if (obj->getRef().num + (int) numOffset >= countRef->getNumObjects() || \n            countRef->getEntry(obj->getRef().num + numOffset)->type == xrefEntryFree)\n        {\n          countRef->add(obj->getRef().num + numOffset, 1, 0, true);\n        } else {\n          XRefEntry *entry = countRef->getEntry(obj->getRef().num + numOffset);\n          entry->gen++;\n          if (entry->gen > 9)\n            break;\n        } \n        Object obj1 = getXRef()->fetch(obj->getRef());\n        markObject(&obj1, xRef, countRef, numOffset, oldRefNum, newRefNum);\n      }\n      break;\n    default:\n      break;\n  }\n}", "target": 1}
{"code": "static int selinux_ptrace_traceme(struct task_struct *parent)\n{\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    task_sid_subj(parent), task_sid_obj(current),\n\t\t\t    SECCLASS_PROCESS, PROCESS__PTRACE, NULL);\n}", "target": 1}
{"code": " static inline int ldsem_cmpxchg(long *old, long new, struct ld_semaphore *sem)\n {\n\tlong tmp = *old;\n\t*old = atomic_long_cmpxchg(&sem->count, *old, new);\n\treturn *old == tmp;\n }", "target": 1}
{"code": "static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\t\tsecurity_key_free(key);\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\t\tatomic_dec(&key->user->nkeys);\n \t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n \t\t\tatomic_dec(&key->user->nikeys);\n\t\tkey_user_put(key->user);\n \t\tif (key->type->destroy)\n \t\t\tkey->type->destroy(key);\n \t\tkfree(key->description);\n #ifdef KEY_DEBUGGING\n\t\tkey->magic = KEY_DEBUG_MAGIC_X;\n#endif\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}", "target": 1}
{"code": "FileSpec::FileSpec(const Object *fileSpecA)\n{\n  ok = true;\n  fileName = nullptr;\n  platformFileName = nullptr;\n  embFile = nullptr;\n  desc = nullptr;\n  fileSpec = fileSpecA->copy();\n  Object obj1 = getFileSpecName(fileSpecA);\n  if (!obj1.isString()) {\n    ok = false;\n    error(errSyntaxError, -1, \"Invalid FileSpec\");\n    return;\n  }\n  fileName = obj1.getString()->copy();\n  if (fileSpec.isDict()) {\n    obj1 = fileSpec.dictLookup(\"EF\");\n    if (obj1.isDict()) {\n      fileStream = obj1.dictLookupNF(\"F\");\n      if (!fileStream.isRef()) {\n        ok = false;\n        fileStream.setToNull();\n        error(errSyntaxError, -1, \"Invalid FileSpec: Embedded file stream is not an indirect reference\");\n        return;\n      }\n    }\n  }\n  obj1 = fileSpec.dictLookup(\"Desc\");\n  if (obj1.isString())\n    desc = obj1.getString()->copy();\n}", "target": 1}
{"code": "static ssize_t cgroup_release_agent_write(struct kernfs_open_file *of,\n\t\t\t\t\t  char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\tBUILD_BUG_ON(sizeof(cgrp->root->release_agent_path) < PATH_MAX);\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENODEV;\n\tspin_lock(&release_agent_path_lock);\n\tstrlcpy(cgrp->root->release_agent_path, strstrip(buf),\n\t\tsizeof(cgrp->root->release_agent_path));\n\tspin_unlock(&release_agent_path_lock);\n\tcgroup_kn_unlock(of->kn);\n\treturn nbytes;\n}", "target": 1}
{"code": "static ssize_t remove_slot_store(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t const char *buf, size_t nbytes)\n{\n\tchar drc_name[MAX_DRC_NAME_LEN];\n\tint rc;\n\tchar *end;\n\tif (nbytes >= MAX_DRC_NAME_LEN)\n\t\treturn 0;\n\tmemcpy(drc_name, buf, nbytes);\n\tend = strchr(drc_name, '\\n');\n\tif (!end)\n\t\tend = &drc_name[nbytes];\n\t*end = '\\0';\n\trc = dlpar_remove_slot(drc_name);\n\tif (rc)\n\t\treturn rc;\n\treturn nbytes;\n}", "target": 1}
{"code": "PHP_FUNCTION(enchant_broker_request_dict)\n{\n\tzval *broker;\n\tenchant_broker *pbroker;\n\tenchant_dict *dict;\n\tEnchantDict *d;\n\tchar *tag;\n\tint taglen;\n\tint pos;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rs\", &broker, &tag, &taglen) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tPHP_ENCHANT_GET_BROKER;\n\tif (taglen == 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Tag cannot be empty\");\n\t\tRETURN_FALSE;\n\t}\n\td = enchant_broker_request_dict(pbroker->pbroker, (const char *)tag);\n\tif (d) {\n\t\tif (pbroker->dictcnt) {\n\t\t\tpbroker->dict = (enchant_dict **)erealloc(pbroker->dict, sizeof(enchant_dict *) * pbroker->dictcnt);\n\t\t\tpos = pbroker->dictcnt++;\n\t\t} else {\n\t\t\tpbroker->dict = (enchant_dict **)emalloc(sizeof(enchant_dict *));\n\t\t\tpos = 0;\n\t\t\tpbroker->dictcnt++;\n\t\t}\n\t\tdict = pbroker->dict[pos] = (enchant_dict *)emalloc(sizeof(enchant_dict));\n\t\tdict->id = pos;\n\t\tdict->pbroker = pbroker;\n\t\tdict->pdict = d;\n\t\tdict->prev = pos ? pbroker->dict[pos-1] : NULL;\n\t\tdict->next = NULL;\n\t\tpbroker->dict[pos] = dict;\n\t\tif (pos) {\n\t\t\tpbroker->dict[pos-1]->next = dict;\n\t\t}\n\t\tdict->rsrc_id = ZEND_REGISTER_RESOURCE(return_value, dict, le_enchant_dict);\n\t\tzend_list_addref(pbroker->rsrc_id);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}", "target": 1}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteSpaceToDepthParams*>(node->builtin_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n  auto data_type = output->type;\n  TF_LITE_ENSURE(context,\n                 data_type == kTfLiteFloat32 || data_type == kTfLiteUInt8 ||\n                     data_type == kTfLiteInt8 || data_type == kTfLiteInt32 ||\n                     data_type == kTfLiteInt64);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  const int block_size = params->block_size;\n  const int input_height = input->dims->data[1];\n  const int input_width = input->dims->data[2];\n  int output_height = input_height / block_size;\n  int output_width = input_width / block_size;\n  TF_LITE_ENSURE_EQ(context, input_height, output_height * block_size);\n  TF_LITE_ENSURE_EQ(context, input_width, output_width * block_size);\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(4);\n  output_size->data[0] = input->dims->data[0];\n  output_size->data[1] = output_height;\n  output_size->data[2] = output_width;\n  output_size->data[3] = input->dims->data[3] * block_size * block_size;\n  return context->ResizeTensor(context, output, output_size);\n}", "target": 1}
{"code": "bool SetExtendedFileAttribute(const char* path,\n                              const char* name,\n                               const char* value,\n                               size_t value_size,\n                               int flags) {\n   base::ScopedBlockingCall scoped_blocking_call(base::BlockingType::MAY_BLOCK);\n   int result = setxattr(path, name, value, value_size, flags);\n   if (result) {\n     DPLOG(ERROR) << \"Could not set extended attribute \" << name << \" on file \"\n                  << path;\n     return false;\n   }\n   return true;\n }", "target": 1}
{"code": "regional_create_custom(size_t size)\n{\n\tstruct regional* r = (struct regional*)malloc(size);\n\tlog_assert(sizeof(struct regional) <= size);\n\tif(!r) return NULL;\n\tr->first_size = size;\n\tregional_init(r);\n\treturn r;\n}", "target": 1}
{"code": "cr_input_read_byte (CRInput * a_this, guchar * a_byte)\n{\n        g_return_val_if_fail (a_this && PRIVATE (a_this)\n                              && a_byte, CR_BAD_PARAM_ERROR);\n        g_return_val_if_fail (PRIVATE (a_this)->next_byte_index <=\n                              PRIVATE (a_this)->nb_bytes, CR_BAD_PARAM_ERROR);\n        if (PRIVATE (a_this)->end_of_input == TRUE)\n                return CR_END_OF_INPUT_ERROR;\n        *a_byte = PRIVATE (a_this)->in_buf[PRIVATE (a_this)->next_byte_index];\n        if (PRIVATE (a_this)->nb_bytes -\n            PRIVATE (a_this)->next_byte_index < 2) {\n                PRIVATE (a_this)->end_of_input = TRUE;\n        } else {\n                PRIVATE (a_this)->next_byte_index++;\n        }\n        return CR_OK;\n}", "target": 1}
{"code": "commonio_sort (struct commonio_db *db, int (*cmp) (const void *, const void *))\n{\n\tstruct commonio_entry **entries, *ptr;\n\tsize_t n = 0, i;\n#if KEEP_NIS_AT_END\n\tstruct commonio_entry *nis = NULL;\n#endif\n\tfor (ptr = db->head;\n\t        (NULL != ptr)\n#if KEEP_NIS_AT_END\n\t     && (NULL != ptr->line)\n\t     && (   ('+' != ptr->line[0])\n\t         && ('-' != ptr->line[0]))\n#endif\n\t     ;\n\t     ptr = ptr->next) {\n\t\tn++;\n\t}\n#if KEEP_NIS_AT_END\n\tif ((NULL != ptr) && (NULL != ptr->line)) {\n\t\tnis = ptr;\n\t}\n#endif\n\tif (n <= 1) {\n\t\treturn 0;\n\t}\n\tentries = malloc (n * sizeof (struct commonio_entry *));\n\tif (entries == NULL) {\n\t\treturn -1;\n\t}\n\tn = 0;\n\tfor (ptr = db->head;\n#if KEEP_NIS_AT_END\n\t     nis != ptr;\n#else\n\t     NULL != ptr;\n#endif\n\t     ptr = ptr->next\n\t    ) {\n\t\tentries[n] = ptr;\n\t\tn++;\n\t}\n\tqsort (entries, n, sizeof (struct commonio_entry *), cmp);\n\tdb->head = entries[0];\n\tn--;\n#if KEEP_NIS_AT_END\n\tif (NULL == nis)\n#endif\n\t{\n\t\tdb->tail = entries[n];\n\t}\n\tdb->head->prev = NULL;\n\tdb->head->next = entries[1];\n\tentries[n]->prev = entries[n - 1];\n#if KEEP_NIS_AT_END\n\tentries[n]->next = nis;\n#else\n\tentries[n]->next = NULL;\n#endif\n\tfor (i = 1; i < n; i++) {\n\t\tentries[i]->prev = entries[i - 1];\n\t\tentries[i]->next = entries[i + 1];\n\t}\n\tfree (entries);\n\tdb->changed = true;\n\treturn 0;\n}", "target": 1}
{"code": "void nfcmrvl_nci_unregister_dev(struct nfcmrvl_private *priv)\n{\n\tstruct nci_dev *ndev = priv->ndev;\n\tif (priv->ndev->nfc_dev->fw_download_in_progress)\n\t\tnfcmrvl_fw_dnld_abort(priv);\n\tnfcmrvl_fw_dnld_deinit(priv);\n\tif (gpio_is_valid(priv->config.reset_n_io))\n\t\tgpio_free(priv->config.reset_n_io);\n\tnci_unregister_device(ndev);\n\tnci_free_device(ndev);\n\tkfree(priv);\n}", "target": 1}
{"code": "mrb_remove_method(mrb_state *mrb, struct RClass *c, mrb_sym mid)\n{\n  mt_tbl *h;\n  MRB_CLASS_ORIGIN(c);\n  h = c->mt;\n  if (h && mt_del(mrb, h, mid)) return;\n  mrb_name_error(mrb, mid, \"method '%n' not defined in %C\", mid, c);\n}", "target": 1}
{"code": "static int magicmouse_raw_event(struct hid_device *hdev,\n\t\tstruct hid_report *report, u8 *data, int size)\n{\n\tstruct magicmouse_sc *msc = hid_get_drvdata(hdev);\n\tstruct input_dev *input = msc->input;\n\tint x = 0, y = 0, ii, clicks = 0, npoints;\n\tswitch (data[0]) {\n\tcase TRACKPAD_REPORT_ID:\n \t\tif (size < 4 || ((size - 4) % 9) != 0)\n \t\t\treturn 0;\n \t\tnpoints = (size - 4) / 9;\n \t\tmsc->ntouches = 0;\n \t\tfor (ii = 0; ii < npoints; ii++)\n \t\t\tmagicmouse_emit_touch(msc, ii, data + ii * 9 + 4);\n\t\tclicks = data[1];\n\t\tbreak;\n\tcase MOUSE_REPORT_ID:\n \t\tif (size < 6 || ((size - 6) % 8) != 0)\n \t\t\treturn 0;\n \t\tnpoints = (size - 6) / 8;\n \t\tmsc->ntouches = 0;\n \t\tfor (ii = 0; ii < npoints; ii++)\n \t\t\tmagicmouse_emit_touch(msc, ii, data + ii * 8 + 6);\n\t\tx = (int)(((data[3] & 0x0c) << 28) | (data[1] << 22)) >> 22;\n\t\ty = (int)(((data[3] & 0x30) << 26) | (data[2] << 22)) >> 22;\n\t\tclicks = data[3];\n\t\tbreak;\n\tcase DOUBLE_REPORT_ID:\n\t\tmagicmouse_raw_event(hdev, report, data + 2, data[1]);\n\t\tmagicmouse_raw_event(hdev, report, data + 2 + data[1],\n\t\t\tsize - 2 - data[1]);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (input->id.product == USB_DEVICE_ID_APPLE_MAGICMOUSE) {\n\t\tmagicmouse_emit_buttons(msc, clicks & 3);\n\t\tinput_report_rel(input, REL_X, x);\n\t\tinput_report_rel(input, REL_Y, y);\n\t} else { \n\t\tinput_report_key(input, BTN_MOUSE, clicks & 1);\n\t\tinput_mt_report_pointer_emulation(input, true);\n\t}\n\tinput_sync(input);\n\treturn 1;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const float min_input = context->input(1).flat<float>()(0);\n    const float max_input = context->input(2).flat<float>()(0);\n    MaxPoolingOp<Device, T>::Compute(context);\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));\n    output_min->flat<float>()(0) = min_input;\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max));\n    output_max->flat<float>()(0) = max_input;\n  }", "target": 1}
{"code": "MediaStreamImpl::~MediaStreamImpl() {\n  DCHECK(!peer_connection_handler_);\n  if (dependency_factory_.get())\n    dependency_factory_->ReleasePeerConnectionFactory();\n  if (network_manager_) {\n    if (chrome_worker_thread_.IsRunning()) {\n       chrome_worker_thread_.message_loop()->PostTask(FROM_HERE, base::Bind(\n           &MediaStreamImpl::DeleteIpcNetworkManager,\n           base::Unretained(this)));\n     } else {\n       NOTREACHED() << \"Worker thread not running.\";\n     }\n  }\n}", "target": 1}
{"code": "static void tcp_mtu_probing(struct inet_connection_sock *icsk, struct sock *sk)\n{\n\tconst struct net *net = sock_net(sk);\n\tint mss;\n\tif (!net->ipv4.sysctl_tcp_mtu_probing)\n\t\treturn;\n\tif (!icsk->icsk_mtup.enabled) {\n\t\ticsk->icsk_mtup.enabled = 1;\n\t\ticsk->icsk_mtup.probe_timestamp = tcp_jiffies32;\n\t} else {\n\t\tmss = tcp_mtu_to_mss(sk, icsk->icsk_mtup.search_low) >> 1;\n\t\tmss = min(net->ipv4.sysctl_tcp_base_mss, mss);\n\t\tmss = max(mss, 68 - tcp_sk(sk)->tcp_header_len);\n\t\ticsk->icsk_mtup.search_low = tcp_mss_to_mtu(sk, mss);\n\t}\n\ttcp_sync_mss(sk, icsk->icsk_pmtu_cookie);\n}", "target": 1}
{"code": "static void mcf_fec_do_tx(mcf_fec_state *s)\n{\n    uint32_t addr;\n    mcf_fec_bd bd;\n    int frame_size;\n    int len;\n    uint8_t frame[FEC_MAX_FRAME_SIZE];\n    uint8_t *ptr;\n    DPRINTF(\"do_tx\\n\");\n    ptr = frame;\n    frame_size = 0;\n    addr = s->tx_descriptor;\n    while (1) {\n        mcf_fec_read_bd(&bd, addr);\n        DPRINTF(\"tx_bd %x flags %04x len %d data %08x\\n\",\n                addr, bd.flags, bd.length, bd.data);\n        if ((bd.flags & FEC_BD_R) == 0) {\n            break;\n        }\n        len = bd.length;\n        if (frame_size + len > FEC_MAX_FRAME_SIZE) {\n            len = FEC_MAX_FRAME_SIZE - frame_size;\n            s->eir |= FEC_INT_BABT;\n        }\n        cpu_physical_memory_read(bd.data, ptr, len);\n        ptr += len;\n        frame_size += len;\n        if (bd.flags & FEC_BD_L) {\n            DPRINTF(\"Sending packet\\n\");\n            qemu_send_packet(qemu_get_queue(s->nic), frame, len);\n            ptr = frame;\n            frame_size = 0;\n            s->eir |= FEC_INT_TXF;\n        }\n        s->eir |= FEC_INT_TXB;\n        bd.flags &= ~FEC_BD_R;\n        mcf_fec_write_bd(&bd, addr);\n        if ((bd.flags & FEC_BD_W) != 0) {\n            addr = s->etdsr;\n        } else {\n            addr += 8;\n        }\n    }\n    s->tx_descriptor = addr;\n}", "target": 1}
{"code": "int pipe_resize_ring(struct pipe_inode_info *pipe, unsigned int nr_slots)\n{\n\tstruct pipe_buffer *bufs;\n\tunsigned int head, tail, mask, n;\n\tmask = pipe->ring_size - 1;\n\thead = pipe->head;\n\ttail = pipe->tail;\n\tn = pipe_occupancy(pipe->head, pipe->tail);\n\tif (nr_slots < n)\n\t\treturn -EBUSY;\n\tbufs = kcalloc(nr_slots, sizeof(*bufs),\n\t\t       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);\n\tif (unlikely(!bufs))\n\t\treturn -ENOMEM;\n\tif (n > 0) {\n\t\tunsigned int h = head & mask;\n\t\tunsigned int t = tail & mask;\n\t\tif (h > t) {\n\t\t\tmemcpy(bufs, pipe->bufs + t,\n\t\t\t       n * sizeof(struct pipe_buffer));\n\t\t} else {\n\t\t\tunsigned int tsize = pipe->ring_size - t;\n\t\t\tif (h > 0)\n\t\t\t\tmemcpy(bufs + tsize, pipe->bufs,\n\t\t\t\t       h * sizeof(struct pipe_buffer));\n\t\t\tmemcpy(bufs, pipe->bufs + t,\n\t\t\t       tsize * sizeof(struct pipe_buffer));\n\t\t}\n\t}\n\thead = n;\n\ttail = 0;\n\tkfree(pipe->bufs);\n\tpipe->bufs = bufs;\n\tpipe->ring_size = nr_slots;\n\tif (pipe->max_usage > nr_slots)\n\t\tpipe->max_usage = nr_slots;\n\tpipe->tail = tail;\n\tpipe->head = head;\n\twake_up_interruptible(&pipe->wr_wait);\n\treturn 0;\n}", "target": 1}
{"code": "tca_get_fill(struct sk_buff *skb, struct tc_action *a, u32 pid, u32 seq,\n             u16 flags, int event, int bind, int ref)\n{\n\tstruct tcamsg *t;\n\tstruct nlmsghdr *nlh;\n\tunsigned char *b = skb->tail;\n\tstruct rtattr *x;\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*t), flags);\n\tt = NLMSG_DATA(nlh);\n\tt->tca_family = AF_UNSPEC;\n\tx = (struct rtattr*) skb->tail;\n\tRTA_PUT(skb, TCA_ACT_TAB, 0, NULL);\n\tif (tcf_action_dump(skb, a, bind, ref) < 0)\n\t\tgoto rtattr_failure;\n\tx->rta_len = skb->tail - (u8*)x;\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\nrtattr_failure:\nnlmsg_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1}
{"code": "bool TensorSliceReader::CopySliceData(const string& name,\n                                      const TensorSlice& slice, T* data) const {\n  std::vector<std::pair<TensorSlice, string>> details;\n  const TensorSliceSet* tss;\n  {\n    mutex_lock l(mu_);\n    tss = FindTensorSlice(name, slice, &details);\n    if (!tss && !all_shards_loaded_) {\n      VLOG(1) << \"Did not find slice in preferred shard, loading all shards.\"\n              << name << \": \" << slice.DebugString();\n      LoadAllShards();\n      tss = FindTensorSlice(name, slice, &details);\n    }\n    if (!tss) {\n      return false;\n    }\n  }\n  string value;\n  for (const auto& x : details) {\n    const TensorSlice& slice_s = x.first;\n    const string& fname = x.second;\n    int idx = gtl::FindWithDefault(fname_to_index_, fname, -1);\n    CHECK_GE(idx, 0) << \"Failed to find the index for filename \" << fname;\n    const string key = EncodeTensorNameSlice(name, slice_s);\n    if (!sss_[idx]->Get(key, &value)) {\n      VLOG(1) << \"Failed to seek to the record for tensor \" << name\n              << \", slice \" << slice_s.DebugString()\n              << \": computed key = \" << key;\n      return false;\n    }\n    SavedTensorSlices sts;\n    if (!ParseProtoUnlimited(&sts, value)) {\n      VLOG(1) << \"Failed to parse the record for tensor \" << name << \", slice \"\n              << slice_s.DebugString() << \": computed key = \" << key;\n      return false;\n    }\n    CopyDataFromTensorSliceToTensorSlice(\n        tss->shape(), slice_s, slice,\n        checkpoint::TensorProtoData<T>(sts.data().data()), data);\n  }\n  return true;\n}", "target": 1}
{"code": "static int cloop_open(BlockDriverState *bs, QDict *options, int flags,\n                      Error **errp)\n{\n    BDRVCloopState *s = bs->opaque;\n    uint32_t offsets_size, max_compressed_block_size = 1, i;\n    int ret;\n    bs->read_only = 1;\n    ret = bdrv_pread(bs->file, 128, &s->block_size, 4);\n    if (ret < 0) {\n        return ret;\n    }\n    s->block_size = be32_to_cpu(s->block_size);\n    ret = bdrv_pread(bs->file, 128 + 4, &s->n_blocks, 4);\n    if (ret < 0) {\n        return ret;\n    }\n    s->n_blocks = be32_to_cpu(s->n_blocks);\n    offsets_size = s->n_blocks * sizeof(uint64_t);\n    s->offsets = g_malloc(offsets_size);\n    ret = bdrv_pread(bs->file, 128 + 4 + 4, s->offsets, offsets_size);\n    if (ret < 0) {\n        goto fail;\n    }\n    for(i=0;i<s->n_blocks;i++) {\n        s->offsets[i] = be64_to_cpu(s->offsets[i]);\n        if (i > 0) {\n            uint32_t size = s->offsets[i] - s->offsets[i - 1];\n            if (size > max_compressed_block_size) {\n                max_compressed_block_size = size;\n            }\n        }\n    }\n    s->compressed_block = g_malloc(max_compressed_block_size + 1);\n    s->uncompressed_block = g_malloc(s->block_size);\n    if (inflateInit(&s->zstream) != Z_OK) {\n        ret = -EINVAL;\n        goto fail;\n    }\n    s->current_block = s->n_blocks;\n    s->sectors_per_block = s->block_size/512;\n    bs->total_sectors = s->n_blocks * s->sectors_per_block;\n    qemu_co_mutex_init(&s->lock);\n    return 0;\nfail:\n    g_free(s->offsets);\n    g_free(s->compressed_block);\n    g_free(s->uncompressed_block);\n    return ret;\n}", "target": 1}
{"code": "status_t OMXNodeInstance::allocateBufferWithBackup(\n        OMX_U32 portIndex, const sp<IMemory> &params,\n        OMX::buffer_id *buffer, OMX_U32 allottedSize) {\n if (params == NULL || buffer == NULL) {\n        ALOGE(\"b/25884056\");\n return BAD_VALUE;\n }\n Mutex::Autolock autoLock(mLock);\n if (allottedSize > params->size() || portIndex >= NELEM(mNumPortBuffers)) {\n return BAD_VALUE;\n }\n bool copy = mMetadataType[portIndex] == kMetadataBufferTypeInvalid;\n BufferMeta *buffer_meta = new BufferMeta(\n            params, portIndex,\n (portIndex == kPortIndexInput) && copy ,\n (portIndex == kPortIndexOutput) && copy ,\n            NULL );\n    OMX_BUFFERHEADERTYPE *header;\n    OMX_ERRORTYPE err = OMX_AllocateBuffer(\n            mHandle, &header, portIndex, buffer_meta, allottedSize);\n if (err != OMX_ErrorNone) {\n        CLOG_ERROR(allocateBufferWithBackup, err,\n                SIMPLE_BUFFER(portIndex, (size_t)allottedSize, params->pointer()));\n delete buffer_meta;\n        buffer_meta = NULL;\n *buffer = 0;\n return StatusFromOMXError(err);\n     }\n     CHECK_EQ(header->pAppPrivate, buffer_meta);\n    memset(header->pBuffer, 0, header->nAllocLen);\n     *buffer = makeBufferID(header);\n    addActiveBuffer(portIndex, *buffer);\n    sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());\n if (bufferSource != NULL && portIndex == kPortIndexInput) {\n        bufferSource->addCodecBuffer(header);\n }\n    CLOG_BUFFER(allocateBufferWithBackup, NEW_BUFFER_FMT(*buffer, portIndex, \"%zu@%p :> %u@%p\",\n            params->size(), params->pointer(), allottedSize, header->pBuffer));\n return OK;\n}", "target": 1}
{"code": "int NETSCAPE_SPKI_print(BIO *out, NETSCAPE_SPKI *spki)\n{\n    EVP_PKEY *pkey;\n    ASN1_IA5STRING *chal;\n    ASN1_OBJECT *spkioid;\n    int i, n;\n    char *s;\n    BIO_printf(out, \"Netscape SPKI:\\n\");\n    X509_PUBKEY_get0_param(&spkioid, NULL, NULL, NULL, spki->spkac->pubkey);\n    i = OBJ_obj2nid(spkioid);\n    BIO_printf(out, \"  Public Key Algorithm: %s\\n\",\n               (i == NID_undef) ? \"UNKNOWN\" : OBJ_nid2ln(i));\n    pkey = X509_PUBKEY_get(spki->spkac->pubkey);\n    if (!pkey)\n        BIO_printf(out, \"  Unable to load public key\\n\");\n    else {\n        EVP_PKEY_print_public(out, pkey, 4, NULL);\n        EVP_PKEY_free(pkey);\n    }\n    chal = spki->spkac->challenge;\n    if (chal->length)\n        BIO_printf(out, \"  Challenge String: %s\\n\", chal->data);\n    i = OBJ_obj2nid(spki->sig_algor.algorithm);\n    BIO_printf(out, \"  Signature Algorithm: %s\",\n               (i == NID_undef) ? \"UNKNOWN\" : OBJ_nid2ln(i));\n    n = spki->signature->length;\n    s = (char *)spki->signature->data;\n    for (i = 0; i < n; i++) {\n        if ((i % 18) == 0)\n            BIO_write(out, \"\\n      \", 7);\n        BIO_printf(out, \"%02x%s\", (unsigned char)s[i],\n                   ((i + 1) == n) ? \"\" : \":\");\n    }\n    BIO_write(out, \"\\n\", 1);\n    return 1;\n}", "target": 1}
{"code": "static int __ptrace_may_access(struct task_struct *task, unsigned int mode)\n{\n\tconst struct cred *cred = current_cred(), *tcred;\n\tint dumpable = 0;\n\tif (same_thread_group(task, current))\n\t\treturn 0;\n\trcu_read_lock();\n\ttcred = __task_cred(task);\n\tif (uid_eq(cred->uid, tcred->euid) &&\n\t    uid_eq(cred->uid, tcred->suid) &&\n\t    uid_eq(cred->uid, tcred->uid)  &&\n\t    gid_eq(cred->gid, tcred->egid) &&\n\t    gid_eq(cred->gid, tcred->sgid) &&\n\t    gid_eq(cred->gid, tcred->gid))\n\t\tgoto ok;\n\tif (ptrace_has_cap(tcred->user_ns, mode))\n\t\tgoto ok;\n\trcu_read_unlock();\n\treturn -EPERM;\nok:\n\trcu_read_unlock();\n\tsmp_rmb();\n \tif (task->mm)\n \t\tdumpable = get_dumpable(task->mm);\n \trcu_read_lock();\n\tif (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {\n \t\trcu_read_unlock();\n \t\treturn -EPERM;\n \t}\n\trcu_read_unlock();\n\treturn security_ptrace_access_check(task, mode);\n}", "target": 1}
{"code": "call_qftf_func(qf_list_T *qfl, int qf_winid, long start_idx, long end_idx)\n{\n    callback_T\t*cb = &qftf_cb;\n    list_T\t*qftf_list = NULL;\n    if (qfl->qf_qftf_cb.cb_name != NULL)\n\tcb = &qfl->qf_qftf_cb;\n    if (cb->cb_name != NULL)\n    {\n\ttypval_T\targs[1];\n\tdict_T\t\t*d;\n\ttypval_T\trettv;\n\tif ((d = dict_alloc_lock(VAR_FIXED)) == NULL)\n\t    return NULL;\n\tdict_add_number(d, \"quickfix\", (long)IS_QF_LIST(qfl));\n\tdict_add_number(d, \"winid\", (long)qf_winid);\n\tdict_add_number(d, \"id\", (long)qfl->qf_id);\n\tdict_add_number(d, \"start_idx\", start_idx);\n\tdict_add_number(d, \"end_idx\", end_idx);\n\t++d->dv_refcount;\n\targs[0].v_type = VAR_DICT;\n\targs[0].vval.v_dict = d;\n\tqftf_list = NULL;\n\tif (call_callback(cb, 0, &rettv, 1, args) != FAIL)\n\t{\n\t    if (rettv.v_type == VAR_LIST)\n\t    {\n\t\tqftf_list = rettv.vval.v_list;\n\t\tqftf_list->lv_refcount++;\n\t    }\n\t    clear_tv(&rettv);\n\t}\n\tdict_unref(d);\n    }\n    return qftf_list;\n}", "target": 1}
{"code": "Integer InvertibleRWFunction::CalculateInverse(RandomNumberGenerator &rng, const Integer &x) const\n{\n\tDoQuickSanityCheck();\n\tModularArithmetic modn(m_n);\n\tInteger r, rInv;\n\tdo {\t\n\t\tr.Randomize(rng, Integer::One(), m_n - Integer::One());\n\t\trInv = modn.MultiplicativeInverse(r);\n\t} while (rInv.IsZero());\n\tInteger re = modn.Square(r);\n\tre = modn.Multiply(re, x);\t\t\t\n\tInteger cp=re%m_p, cq=re%m_q;\n\tif (Jacobi(cp, m_p) * Jacobi(cq, m_q) != 1)\n\t{\n\t\tcp = cp.IsOdd() ? (cp+m_p) >> 1 : cp >> 1;\n\t\tcq = cq.IsOdd() ? (cq+m_q) >> 1 : cq >> 1;\n\t}\n\t#pragma omp parallel\n\t\t#pragma omp sections\n\t\t{\n\t\t\t#pragma omp section\n\t\t\t\tcp = ModularSquareRoot(cp, m_p);\n\t\t\t#pragma omp section\n\t\t\t\tcq = ModularSquareRoot(cq, m_q);\n\t\t}\n\tInteger y = CRT(cq, m_q, cp, m_p, m_u);\n\ty = modn.Multiply(y, rInv);\t\t\t\t\n\ty = STDMIN(y, m_n-y);\n\tif (ApplyFunction(y) != x)\t\t\t\t\n\t\tthrow Exception(Exception::OTHER_ERROR, \"InvertibleRWFunction: computational error during private key operation\");\n\treturn y;\n}", "target": 1}
{"code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  OpContext op_context(context, node);\n    switch (op_context.output->type) {\n      case kTfLiteFloat32:\n        TFLiteOperation<kernel_type, float, OpType>(context, node, op_context);\n        break;\n      case kTfLiteUInt8:\n        TFLiteOperation<kernel_type, uint8_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt8:\n        TFLiteOperation<kernel_type, int8_t, OpType>(context, node, op_context);\n        break;\n      case kTfLiteInt32:\n        TFLiteOperation<kernel_type, int32_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt64:\n        TFLiteOperation<kernel_type, int64_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt16:\n        TFLiteOperation<kernel_type, int16_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      default:\n        context->ReportError(context,\n                             \"Type %d is currently not supported by Maximum.\",\n                             op_context.output->type);\n        return kTfLiteError;\n    }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static inline void ConvertLuvToXYZ(const double L,const double u,const double v,\n  double *X,double *Y,double *Z)\n{\n  assert(X != (double *) NULL);\n  assert(Y != (double *) NULL);\n  assert(Z != (double *) NULL);\n  if (L > (CIEK*CIEEpsilon))\n    *Y=(double) pow((L+16.0)/116.0,3.0);\n  else\n    *Y=L/CIEK;\n  *X=((*Y*((39.0*L/(v+13.0*L*(9.0*D65Y/(D65X+15.0*D65Y+3.0*D65Z))))-5.0))+\n    5.0*(*Y))/((((52.0*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+3.0*D65Z))))-1.0)/\n    3.0)-(-1.0/3.0));\n  *Z=(*X*(((52.0*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+3.0*D65Z))))-1.0)/3.0))-\n    5.0*(*Y);\n}", "target": 1}
{"code": "#ifndef GPAC_DISABLE_ISOM_HINTING\nvoid dump_isom_sdp(GF_ISOFile *file, char *inName, Bool is_final_name)\n{\n\tconst char *sdp;\n\tu32 size, i;\n\tFILE *dump;\n\tif (inName) {\n\t\tchar szBuf[1024];\n\t\tstrcpy(szBuf, inName);\n\t\tif (!is_final_name) {\n\t\t\tchar *ext = strchr(szBuf, '.');\n\t\t\tif (ext) ext[0] = 0;\n\t\t\tstrcat(szBuf, \"_sdp.txt\");\n\t\t}\n\t\tdump = gf_fopen(szBuf, \"wt\");\n\t\tif (!dump) {\n\t\t\tfprintf(stderr, \"Failed to open %s for dumping\\n\", szBuf);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tdump = stdout;\n\t\tfprintf(dump, \"* File SDP content *\\n\\n\");\n\t}\n\tgf_isom_sdp_get(file, &sdp, &size);\n\tfprintf(dump, \"%s\", sdp);\n\tfprintf(dump, \"\\r\\n\");\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tif (gf_isom_get_media_type(file, i+1) != GF_ISOM_MEDIA_HINT) continue;\n\t\tgf_isom_sdp_track_get(file, i+1, &sdp, &size);\n\t\tfprintf(dump, \"%s\", sdp);\n\t}\n\tfprintf(dump, \"\\n\\n\");", "target": 1}
{"code": "void NavigatorImpl::DiscardPendingEntryIfNeeded(int expected_pending_entry_id) {\n  NavigationEntry* pending_entry = controller_->GetPendingEntry();\n  bool pending_matches_fail_msg =\n      pending_entry &&\n      expected_pending_entry_id == pending_entry->GetUniqueID();\n  if (!pending_matches_fail_msg)\n    return;\n  bool should_preserve_entry = controller_->IsUnmodifiedBlankTab() ||\n                               delegate_->ShouldPreserveAbortedURLs();\n   if (pending_entry != controller_->GetVisibleEntry() ||\n       !should_preserve_entry) {\n     controller_->DiscardPendingEntry(true);\n    controller_->delegate()->NotifyNavigationStateChanged(INVALIDATE_TYPE_URL);\n  }\n}", "target": 1}
{"code": "static OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *\n        p_code_block)\n {\n     OPJ_UINT32 l_data_size;\n    l_data_size = 1 + (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) *\n                                    (p_code_block->y1 - p_code_block->y0) * (OPJ_INT32)sizeof(OPJ_UINT32));\n     if (l_data_size > p_code_block->data_size) {\n        if (p_code_block->data) {\n            opj_free(p_code_block->data - 1);\n        }\n        p_code_block->data = (OPJ_BYTE*) opj_malloc(l_data_size + 1);\n        if (! p_code_block->data) {\n            p_code_block->data_size = 0U;\n            return OPJ_FALSE;\n        }\n        p_code_block->data_size = l_data_size;\n        p_code_block->data[0] = 0;\n        p_code_block->data += 1; \n    }\n    return OPJ_TRUE;\n}", "target": 1}
{"code": "static int nft_verdict_init(const struct nft_ctx *ctx, struct nft_data *data,\n\t\t\t    struct nft_data_desc *desc, const struct nlattr *nla)\n{\n\tu8 genmask = nft_genmask_next(ctx->net);\n\tstruct nlattr *tb[NFTA_VERDICT_MAX + 1];\n\tstruct nft_chain *chain;\n\tint err;\n\terr = nla_parse_nested_deprecated(tb, NFTA_VERDICT_MAX, nla,\n\t\t\t\t\t  nft_verdict_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\tif (!tb[NFTA_VERDICT_CODE])\n\t\treturn -EINVAL;\n\tdata->verdict.code = ntohl(nla_get_be32(tb[NFTA_VERDICT_CODE]));\n\tswitch (data->verdict.code) {\n\tdefault:\n\t\tswitch (data->verdict.code & NF_VERDICT_MASK) {\n\t\tcase NF_ACCEPT:\n\t\tcase NF_DROP:\n\t\tcase NF_QUEUE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfallthrough;\n\tcase NFT_CONTINUE:\n\tcase NFT_BREAK:\n\tcase NFT_RETURN:\n\t\tbreak;\n\tcase NFT_JUMP:\n\tcase NFT_GOTO:\n\t\tif (tb[NFTA_VERDICT_CHAIN]) {\n\t\t\tchain = nft_chain_lookup(ctx->net, ctx->table,\n\t\t\t\t\t\t tb[NFTA_VERDICT_CHAIN],\n\t\t\t\t\t\t genmask);\n\t\t} else if (tb[NFTA_VERDICT_CHAIN_ID]) {\n\t\t\tchain = nft_chain_lookup_byid(ctx->net, ctx->table,\n\t\t\t\t\t\t      tb[NFTA_VERDICT_CHAIN_ID]);\n\t\t\tif (IS_ERR(chain))\n\t\t\t\treturn PTR_ERR(chain);\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (IS_ERR(chain))\n\t\t\treturn PTR_ERR(chain);\n\t\tif (nft_is_base_chain(chain))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (desc->flags & NFT_DATA_DESC_SETELEM &&\n\t\t    chain->flags & NFT_CHAIN_BINDING)\n\t\t\treturn -EINVAL;\n\t\tchain->use++;\n\t\tdata->verdict.chain = chain;\n\t\tbreak;\n\t}\n\tdesc->len = sizeof(data->verdict);\n\treturn 0;\n}", "target": 1}
{"code": "static int rtsx_usb_ms_drv_remove(struct platform_device *pdev)\n{\n\tstruct rtsx_usb_ms *host = platform_get_drvdata(pdev);\n\tstruct memstick_host *msh = host->msh;\n\tint err;\n\thost->eject = true;\n\tcancel_work_sync(&host->handle_req);\n\tmutex_lock(&host->host_mutex);\n\tif (host->req) {\n\t\tdev_dbg(ms_dev(host),\n\t\t\t\"%s: Controller removed during transfer\\n\",\n\t\t\tdev_name(&msh->dev));\n\t\thost->req->error = -ENOMEDIUM;\n\t\tdo {\n\t\t\terr = memstick_next_req(msh, &host->req);\n\t\t\tif (!err)\n\t\t\t\thost->req->error = -ENOMEDIUM;\n\t\t} while (!err);\n\t}\n\tmutex_unlock(&host->host_mutex);\n\tmemstick_remove_host(msh);\n\tmemstick_free_host(msh);\n\tif (pm_runtime_active(ms_dev(host)))\n\t\tpm_runtime_put(ms_dev(host));\n\tpm_runtime_disable(ms_dev(host));\n\tplatform_set_drvdata(pdev, NULL);\n\tdev_dbg(ms_dev(host),\n\t\t\": Realtek USB Memstick controller has been removed\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "ipf_extract_frags_from_batch(struct ipf *ipf, struct dp_packet_batch *pb,\n                             ovs_be16 dl_type, uint16_t zone, long long now,\n                             uint32_t hash_basis)\n{\n    const size_t pb_cnt = dp_packet_batch_size(pb);\n    int pb_idx; \n    struct dp_packet *pkt;\n    DP_PACKET_BATCH_REFILL_FOR_EACH (pb_idx, pb_cnt, pkt, pb) {\n        if (OVS_UNLIKELY((dl_type == htons(ETH_TYPE_IP) &&\n                          ipf_is_valid_v4_frag(ipf, pkt))\n                          ||\n                          (dl_type == htons(ETH_TYPE_IPV6) &&\n                          ipf_is_valid_v6_frag(ipf, pkt)))) {\n            ovs_mutex_lock(&ipf->ipf_lock);\n            if (!ipf_handle_frag(ipf, pkt, dl_type, zone, now, hash_basis)) {\n                dp_packet_batch_refill(pb, pkt, pb_idx);\n            }\n            ovs_mutex_unlock(&ipf->ipf_lock);\n        } else {\n            dp_packet_batch_refill(pb, pkt, pb_idx);\n        }\n    }\n}", "target": 1}
{"code": "ppp_unregister_channel(struct ppp_channel *chan)\n{\n\tstruct channel *pch = chan->ppp;\n\tstruct ppp_net *pn;\n\tif (!pch)\n\t\treturn;\t\t\n\tchan->ppp = NULL;\n\tdown_write(&pch->chan_sem);\n\tspin_lock_bh(&pch->downl);\n\tpch->chan = NULL;\n\tspin_unlock_bh(&pch->downl);\n\tup_write(&pch->chan_sem);\n\tppp_disconnect_channel(pch);\n\tpn = ppp_pernet(pch->chan_net);\n \tspin_lock_bh(&pn->all_channels_lock);\n \tlist_del(&pch->list);\n \tspin_unlock_bh(&pn->all_channels_lock);\n \tpch->file.dead = 1;\n \twake_up_interruptible(&pch->file.rwait);\n\tif (atomic_dec_and_test(&pch->file.refcnt))\n\t\tppp_destroy_channel(pch);\n}", "target": 1}
{"code": "void RemoveActionCallback(const ActionCallback& callback) {\n  DCHECK(g_task_runner.Get());\n   DCHECK(g_task_runner.Get()->BelongsToCurrentThread());\n   std::vector<ActionCallback>* callbacks = g_callbacks.Pointer();\n   for (size_t i = 0; i < callbacks->size(); ++i) {\n    if ((*callbacks)[i].Equals(callback)) {\n       callbacks->erase(callbacks->begin() + i);\n       return;\n     }\n  }\n}", "target": 1}
{"code": "void SimpleSoftOMXComponent::onPortEnable(OMX_U32 portIndex, bool enable) {\n    CHECK_LT(portIndex, mPorts.size());\n PortInfo *port = &mPorts.editItemAt(portIndex);\n     CHECK_EQ((int)port->mTransition, (int)PortInfo::NONE);\n     CHECK(port->mDef.bEnabled == !enable);\n     if (!enable) {\n         port->mDef.bEnabled = OMX_FALSE;\n         port->mTransition = PortInfo::DISABLING;\n for (size_t i = 0; i < port->mBuffers.size(); ++i) {\n BufferInfo *buffer = &port->mBuffers.editItemAt(i);\n if (buffer->mOwnedByUs) {\n                buffer->mOwnedByUs = false;\n if (port->mDef.eDir == OMX_DirInput) {\n                    notifyEmptyBufferDone(buffer->mHeader);\n } else {\n                    CHECK_EQ(port->mDef.eDir, OMX_DirOutput);\n                    notifyFillBufferDone(buffer->mHeader);\n }\n }\n }\n        port->mQueue.clear();\n } else {\n        port->mTransition = PortInfo::ENABLING;\n }\n    checkTransitions();\n}", "target": 1}
{"code": "static int clone_submodule(const char *path, const char *gitdir, const char *url,\n\t\t\t   const char *depth, struct string_list *reference,\n\t\t\t   int quiet, int progress)\n{\n\tstruct child_process cp = CHILD_PROCESS_INIT;\n\targv_array_push(&cp.args, \"clone\");\n\targv_array_push(&cp.args, \"--no-checkout\");\n\tif (quiet)\n\t\targv_array_push(&cp.args, \"--quiet\");\n\tif (progress)\n\t\targv_array_push(&cp.args, \"--progress\");\n\tif (depth && *depth)\n\t\targv_array_pushl(&cp.args, \"--depth\", depth, NULL);\n\tif (reference->nr) {\n\t\tstruct string_list_item *item;\n\t\tfor_each_string_list_item(item, reference)\n\t\t\targv_array_pushl(&cp.args, \"--reference\",\n\t\t\t\t\t item->string, NULL);\n\t}\n\tif (gitdir && *gitdir)\n\t\targv_array_pushl(&cp.args, \"--separate-git-dir\", gitdir, NULL);\n\targv_array_push(&cp.args, url);\n\targv_array_push(&cp.args, path);\n\tcp.git_cmd = 1;\n\tprepare_submodule_repo_env(&cp.env_array);\n\tcp.no_stdin = 1;\n\treturn run_command(&cp);\n}", "target": 1}
{"code": "void pb_controller::play_file(const std::string& file) {\n\tstd::string cmdline;\n\tstd::string player = cfg->get_configvalue(\"player\");\n\tif (player == \"\")\n\t\treturn;\n\tcmdline.append(player);\n\tcmdline.append(\" \\\"\");\n\tcmdline.append(utils::replace_all(file,\"\\\"\", \"\\\\\\\"\"));\n\tcmdline.append(\"\\\"\");\n\tstfl::reset();\n\tLOG(LOG_DEBUG, \"pb_controller::play_file: running `%s'\", cmdline.c_str());\n\t::system(cmdline.c_str());\n}", "target": 1}
{"code": "bool DoResolveRelativeHost(const char* base_url,\n                           const url_parse::Parsed& base_parsed,\n                           const CHAR* relative_url,\n                           const url_parse::Component& relative_component,\n                           CharsetConverter* query_converter,\n                           CanonOutput* output,\n                           url_parse::Parsed* out_parsed) {\n   url_parse::Parsed relative_parsed;  \n  url_parse::ParseAfterScheme(&relative_url[relative_component.begin],\n                              relative_component.len, relative_component.begin,\n                              &relative_parsed);\n  Replacements<CHAR> replacements;\n  replacements.SetUsername(relative_url, relative_parsed.username);\n  replacements.SetPassword(relative_url, relative_parsed.password);\n  replacements.SetHost(relative_url, relative_parsed.host);\n  replacements.SetPort(relative_url, relative_parsed.port);\n  replacements.SetPath(relative_url, relative_parsed.path);\n  replacements.SetQuery(relative_url, relative_parsed.query);\n  replacements.SetRef(relative_url, relative_parsed.ref);\n  return ReplaceStandardURL(base_url, base_parsed, replacements,\n                            query_converter, output, out_parsed);\n}", "target": 1}
{"code": "cmdline_insert_reg(int *gotesc UNUSED)\n{\n    int\t\ti;\n    int\t\tc;\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t\n#endif\n    putcmdline('\"', TRUE);\n    ++no_mapping;\n    ++allow_keys;\n    i = c = plain_vgetc();\t\n    if (i == Ctrl_O)\n\ti = Ctrl_R;\t\t\n    if (i == Ctrl_R)\n\tc = plain_vgetc();\t\n    extra_char = NUL;\n    --no_mapping;\n    --allow_keys;\n#ifdef FEAT_EVAL\n    new_cmdpos = -1;\n    if (c == '=')\n    {\n\tif (ccline.cmdfirstc == '='  \n\t\t|| cmdline_star > 0) \n\t{\n\t    beep_flush();\n\t    c = ESC;\n\t}\n\telse\n\t    c = get_expr_register();\n    }\n#endif\n    if (c != ESC)\t    \n    {\n\tcmdline_paste(c, i == Ctrl_R, FALSE);\n#ifdef FEAT_EVAL\n\tif (aborting())\n\t{\n\t    *gotesc = TRUE;  \n\t    return GOTO_NORMAL_MODE;\n\t}\n#endif\n\tKeyTyped = FALSE;\t\n#ifdef FEAT_EVAL\n\tif (new_cmdpos >= 0)\n\t{\n\t    if (new_cmdpos > ccline.cmdlen)\n\t\tccline.cmdpos = ccline.cmdlen;\n\t    else\n\t\tccline.cmdpos = new_cmdpos;\n\t}\n#endif\n    }\n    redrawcmd();\n    return CMDLINE_NOT_CHANGED;\n}", "target": 1}
{"code": "flush_signal_handlers(struct task_struct *t, int force_default)\n{\n\tint i;\n\tstruct k_sigaction *ka = &t->sighand->action[0];\n\tfor (i = _NSIG ; i != 0 ; i--) {\n \t\tif (force_default || ka->sa.sa_handler != SIG_IGN)\n \t\t\tka->sa.sa_handler = SIG_DFL;\n \t\tka->sa.sa_flags = 0;\n \t\tsigemptyset(&ka->sa.sa_mask);\n \t\tka++;\n \t}\n}", "target": 1}
{"code": " static int nfc_llcp_build_gb(struct nfc_llcp_local *local)\n {\n\tu8 *gb_cur, *version_tlv, version, version_length;\n\tu8 *lto_tlv, lto_length;\n\tu8 *wks_tlv, wks_length;\n\tu8 *miux_tlv, miux_length;\n \t__be16 wks = cpu_to_be16(local->local_wks);\n \tu8 gb_len = 0;\n \tint ret = 0;\n \tversion = LLCP_VERSION_11;\n \tversion_tlv = nfc_llcp_build_tlv(LLCP_TLV_VERSION, &version,\n \t\t\t\t\t 1, &version_length);\n \tgb_len += version_length;\n \tlto_tlv = nfc_llcp_build_tlv(LLCP_TLV_LTO, &local->lto, 1, &lto_length);\n \tgb_len += lto_length;\n \tpr_debug(\"Local wks 0x%lx\\n\", local->local_wks);\n \twks_tlv = nfc_llcp_build_tlv(LLCP_TLV_WKS, (u8 *)&wks, 2, &wks_length);\n \tgb_len += wks_length;\n \tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&local->miux, 0,\n \t\t\t\t      &miux_length);\n \tgb_len += miux_length;\n \tgb_len += ARRAY_SIZE(llcp_magic);\n\tif (gb_len > NFC_MAX_GT_LEN) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tgb_cur = local->gb;\n\tmemcpy(gb_cur, llcp_magic, ARRAY_SIZE(llcp_magic));\n\tgb_cur += ARRAY_SIZE(llcp_magic);\n\tmemcpy(gb_cur, version_tlv, version_length);\n\tgb_cur += version_length;\n\tmemcpy(gb_cur, lto_tlv, lto_length);\n\tgb_cur += lto_length;\n\tmemcpy(gb_cur, wks_tlv, wks_length);\n\tgb_cur += wks_length;\n\tmemcpy(gb_cur, miux_tlv, miux_length);\n\tgb_cur += miux_length;\n\tlocal->gb_len = gb_len;\nout:\n\tkfree(version_tlv);\n\tkfree(lto_tlv);\n\tkfree(wks_tlv);\n\tkfree(miux_tlv);\n\treturn ret;\n}", "target": 1}
{"code": "static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct sockaddr_l2tpip *addr = (struct sockaddr_l2tpip *) uaddr;\n\tstruct net *net = sock_net(sk);\n \tint ret;\n \tint chk_addr_ret;\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\treturn -EINVAL;\n \tif (addr_len < sizeof(struct sockaddr_l2tpip))\n \t\treturn -EINVAL;\n \tif (addr->l2tp_family != AF_INET)\n\t\treturn -EINVAL;\n\tret = -EADDRINUSE;\n\tread_lock_bh(&l2tp_ip_lock);\n\tif (__l2tp_ip_bind_lookup(net, addr->l2tp_addr.s_addr,\n\t\t\t\t  sk->sk_bound_dev_if, addr->l2tp_conn_id))\n\t\tgoto out_in_use;\n \tread_unlock_bh(&l2tp_ip_lock);\n \tlock_sock(sk);\n \tif (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))\n \t\tgoto out;\n\tchk_addr_ret = inet_addr_type(net, addr->l2tp_addr.s_addr);\n\tret = -EADDRNOTAVAIL;\n\tif (addr->l2tp_addr.s_addr && chk_addr_ret != RTN_LOCAL &&\n\t    chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST)\n\t\tgoto out;\n\tif (addr->l2tp_addr.s_addr)\n\t\tinet->inet_rcv_saddr = inet->inet_saddr = addr->l2tp_addr.s_addr;\n\tif (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)\n\t\tinet->inet_saddr = 0;  \n\tsk_dst_reset(sk);\n\tl2tp_ip_sk(sk)->conn_id = addr->l2tp_conn_id;\n\twrite_lock_bh(&l2tp_ip_lock);\n\tsk_add_bind_node(sk, &l2tp_ip_bind_table);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip_lock);\n\tret = 0;\n\tsock_reset_flag(sk, SOCK_ZAPPED);\nout:\n\trelease_sock(sk);\n\treturn ret;\nout_in_use:\n\tread_unlock_bh(&l2tp_ip_lock);\n\treturn ret;\n}", "target": 1}
{"code": "char *rfbProcessFileTransferReadBuffer(rfbClientPtr cl, uint32_t length)\n{\n    char *buffer=NULL;\n    int   n=0;\n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, NULL);\n    if(length == SIZE_MAX) {\n\trfbErr(\"rfbProcessFileTransferReadBuffer: too big file transfer length requested: %u\", (unsigned int)length);\n\trfbCloseClient(cl);\n\treturn NULL;\n    }\n    if (length>0) {\n        buffer=malloc((size_t)length+1);\n        if (buffer!=NULL) {\n            if ((n = rfbReadExact(cl, (char *)buffer, length)) <= 0) {\n                if (n != 0)\n                    rfbLogPerror(\"rfbProcessFileTransferReadBuffer: read\");\n                rfbCloseClient(cl);\n                if (buffer!=NULL) free(buffer);\n                return NULL;\n            }\n            buffer[length]=0;\n        }\n    }\n    return buffer;\n}", "target": 1}
{"code": "void WebURLLoaderImpl::Context::OnReceivedResponse(\n    const ResourceResponseInfo& info) {\n  if (!client_)\n    return;\n  WebURLResponse response;\n  response.initialize();\n  PopulateURLResponse(request_.url(), info, &response);\n  bool show_raw_listing = (GURL(request_.url()).query() == \"raw\");\n  if (info.mime_type == \"text/vnd.chromium.ftp-dir\") {\n    if (show_raw_listing) {\n      response.setMIMEType(\"text/plain\");\n    } else {\n      response.setMIMEType(\"text/html\");\n     }\n   }\n   client_->didReceiveResponse(loader_, response);\n  if (!client_)\n    return;\n  DCHECK(!ftp_listing_delegate_.get());\n  DCHECK(!multipart_delegate_.get());\n  if (info.headers && info.mime_type == \"multipart/x-mixed-replace\") {\n    std::string content_type;\n    info.headers->EnumerateHeader(NULL, \"content-type\", &content_type);\n    std::string mime_type;\n    std::string charset;\n    bool had_charset = false;\n    std::string boundary;\n    net::HttpUtil::ParseContentType(content_type, &mime_type, &charset,\n                                    &had_charset, &boundary);\n    TrimString(boundary, \" \\\"\", &boundary);\n    if (!boundary.empty()) {\n      multipart_delegate_.reset(\n          new MultipartResponseDelegate(client_, loader_, response, boundary));\n    }\n  } else if (info.mime_type == \"text/vnd.chromium.ftp-dir\" &&\n             !show_raw_listing) {\n    ftp_listing_delegate_.reset(\n        new FtpDirectoryListingResponseDelegate(client_, loader_, response));\n  }\n}", "target": 1}
{"code": "  BasicWriter<Char>::prepare_int_buffer(\n    unsigned num_digits, const Spec &spec,\n    const char *prefix, unsigned prefix_size) {\n  unsigned width = spec.width();\n  Alignment align = spec.align();\n  Char fill = internal::CharTraits<Char>::cast(spec.fill());\n  if (spec.precision() > static_cast<int>(num_digits)) {\n    if (prefix_size > 0 && prefix[prefix_size - 1] == '0')\n      --prefix_size;\n    unsigned number_size =\n        prefix_size + internal::to_unsigned(spec.precision());\n    AlignSpec subspec(number_size, '0', ALIGN_NUMERIC);\n    if (number_size >= width)\n      return prepare_int_buffer(num_digits, subspec, prefix, prefix_size);\n    buffer_.reserve(width);\n    unsigned fill_size = width - number_size;\n    if (align != ALIGN_LEFT) {\n      CharPtr p = grow_buffer(fill_size);\n      std::uninitialized_fill(p, p + fill_size, fill);\n    }\n    CharPtr result = prepare_int_buffer(\n        num_digits, subspec, prefix, prefix_size);\n    if (align == ALIGN_LEFT) {\n      CharPtr p = grow_buffer(fill_size);\n      std::uninitialized_fill(p, p + fill_size, fill);\n    }\n    return result;\n  }\n  unsigned size = prefix_size + num_digits;\n  if (width <= size) {\n    CharPtr p = grow_buffer(size);\n    std::uninitialized_copy(prefix, prefix + prefix_size, p);\n    return p + size - 1;\n  }\n  CharPtr p = grow_buffer(width);\n  CharPtr end = p + width;\n  if (align == ALIGN_LEFT) {\n    std::uninitialized_copy(prefix, prefix + prefix_size, p);\n    p += size;\n    std::uninitialized_fill(p, end, fill);\n  } else if (align == ALIGN_CENTER) {\n    p = fill_padding(p, width, size, fill);\n    std::uninitialized_copy(prefix, prefix + prefix_size, p);\n    p += size;\n  } else {\n    if (align == ALIGN_NUMERIC) {\n      if (prefix_size != 0) {\n        p = std::uninitialized_copy(prefix, prefix + prefix_size, p);\n        size -= prefix_size;\n      }\n    } else {\n      std::uninitialized_copy(prefix, prefix + prefix_size, end - size);\n    }\n    std::uninitialized_fill(p, end - size, fill);\n    p = end;\n  }\n  return p - 1;\n}", "target": 1}
{"code": "static void mysql_prune_stmt_list(MYSQL *mysql)\n{\n  LIST *element= mysql->stmts;\n  LIST *pruned_list= 0;\n  for (; element; element= element->next)\n  {\n    MYSQL_STMT *stmt= (MYSQL_STMT *) element->data;\n    if (stmt->state != MYSQL_STMT_INIT_DONE)\n    {\n      stmt->mysql= 0;\n      stmt->last_errno= CR_SERVER_LOST;\n      strmov(stmt->last_error, ER(CR_SERVER_LOST));\n      strmov(stmt->sqlstate, unknown_sqlstate);\n    }\n    else\n    {\n      pruned_list= list_add(pruned_list, element);\n    }\n  }\n  mysql->stmts= pruned_list;\n}", "target": 1}
{"code": "append_command(char_u *cmd)\n{\n    char_u *s = cmd;\n    char_u *d;\n    STRCAT(IObuff, \": \");\n    d = IObuff + STRLEN(IObuff);\n    while (*s != NUL && d - IObuff < IOSIZE - 7)\n    {\n\tif (enc_utf8 ? (s[0] == 0xc2 && s[1] == 0xa0) : *s == 0xa0)\n\t{\n\t    s += enc_utf8 ? 2 : 1;\n\t    STRCPY(d, \"<a0>\");\n\t    d += 4;\n\t}\n\telse\n\t    MB_COPY_CHAR(s, d);\n    }\n    *d = NUL;\n}", "target": 1}
{"code": "MagickExport unsigned char *DetachBlob(BlobInfo *blob_info)\n{\n  unsigned char\n    *data;\n  assert(blob_info != (BlobInfo *) NULL);\n  if (blob_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n   if (blob_info->mapped != MagickFalse)\n     {\n       (void) UnmapBlob(blob_info->data,blob_info->length);\n       RelinquishMagickResource(MapResource,blob_info->length);\n     }\n   blob_info->mapped=MagickFalse;\n  blob_info->length=0;\n  blob_info->offset=0;\n  blob_info->eof=MagickFalse;\n  blob_info->error=0;\n  blob_info->exempt=MagickFalse;\n  blob_info->type=UndefinedStream;\n  blob_info->file_info.file=(FILE *) NULL;\n  data=blob_info->data;\n  blob_info->data=(unsigned char *) NULL;\n  blob_info->stream=(StreamHandler) NULL;\n  return(data);\n}", "target": 1}
{"code": "parse_tag_11_packet(unsigned char *data, unsigned char *contents,\n\t\t    size_t max_contents_bytes, size_t *tag_11_contents_size,\n\t\t    size_t *packet_size, size_t max_packet_size)\n{\n\tsize_t body_size;\n\tsize_t length_size;\n\tint rc = 0;\n\t(*packet_size) = 0;\n\t(*tag_11_contents_size) = 0;\n\tif (max_packet_size < 16) {\n\t\tprintk(KERN_ERR \"Maximum packet size too small\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != ECRYPTFS_TAG_11_PACKET_TYPE) {\n\t\tprintk(KERN_WARNING \"Invalid tag 11 packet format\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\trc = ecryptfs_parse_packet_length(&data[(*packet_size)], &body_size,\n\t\t\t\t\t  &length_size);\n\tif (rc) {\n\t\tprintk(KERN_WARNING \"Invalid tag 11 packet format\\n\");\n\t\tgoto out;\n\t}\n\tif (body_size < 14) {\n\t\tprintk(KERN_WARNING \"Invalid body size ([%td])\\n\", body_size);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t(*packet_size) += length_size;\n\t(*tag_11_contents_size) = (body_size - 14);\n\tif (unlikely((*packet_size) + body_size + 1 > max_packet_size)) {\n\t\tprintk(KERN_ERR \"Packet size exceeds max\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != 0x62) {\n\t\tprintk(KERN_WARNING \"Unrecognizable packet\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (data[(*packet_size)++] != 0x08) {\n\t\tprintk(KERN_WARNING \"Unrecognizable packet\\n\");\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\t(*packet_size) += 12; \n\tmemcpy(contents, &data[(*packet_size)], (*tag_11_contents_size));\n\t(*packet_size) += (*tag_11_contents_size);\nout:\n\tif (rc) {\n\t\t(*packet_size) = 0;\n\t\t(*tag_11_contents_size) = 0;\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "ssize_t v9fs_list_xattr(FsContext *ctx, const char *path,\n                        void *value, size_t vsize)\n{\n    ssize_t size = 0;\n    void *ovalue = value;\n    XattrOperations *xops;\n    char *orig_value, *orig_value_start;\n    ssize_t xattr_len, parsed_len = 0, attr_len;\n    char *dirpath, *name;\n    int dirfd;\n    dirpath = g_path_get_dirname(path);\n    dirfd = local_opendir_nofollow(ctx, dirpath);\n    g_free(dirpath);\n    if (dirfd == -1) {\n        return -1;\n    }\n    name = g_path_get_basename(path);\n    xattr_len = flistxattrat_nofollow(dirfd, name, value, 0);\n    if (xattr_len <= 0) {\n        g_free(name);\n        close_preserve_errno(dirfd);\n        return xattr_len;\n    }\n    orig_value = g_malloc(xattr_len);\n    xattr_len = flistxattrat_nofollow(dirfd, name, orig_value, xattr_len);\n    g_free(name);\n    close_preserve_errno(dirfd);\n    if (xattr_len < 0) {\n        return -1;\n    }\n    orig_value_start = orig_value;\n    while (xattr_len > parsed_len) {\n        xops = get_xattr_operations(ctx->xops, orig_value);\n        if (!xops) {\n            goto next_entry;\n        }\n        if (!value) {\n            size += xops->listxattr(ctx, path, orig_value, value, vsize);\n        } else {\n            size = xops->listxattr(ctx, path, orig_value, value, vsize);\n            if (size < 0) {\n                goto err_out;\n            }\n            value += size;\n            vsize -= size;\n        }\nnext_entry:\n        attr_len = strlen(orig_value) + 1;\n        parsed_len += attr_len;\n        orig_value += attr_len;\n    }\n    if (value) {\n        size = value - ovalue;\n    }\nerr_out:\n    g_free(orig_value_start);\n    return size;\n}", "target": 1}
{"code": "static int do_remount(struct path *path, int flags, int mnt_flags,\n\t\t      void *data)\n{\n\tint err;\n\tstruct super_block *sb = path->mnt->mnt_sb;\n\tstruct mount *mnt = real_mount(path->mnt);\n\tif (!check_mnt(mnt))\n\t\treturn -EINVAL;\n\tif (path->dentry != path->mnt->mnt_root)\n\t\treturn -EINVAL;\n\terr = security_sb_remount(sb, data);\n\tif (err)\n\t\treturn err;\n\tdown_write(&sb->s_umount);\n\tif (flags & MS_BIND)\n\t\terr = change_mount_flags(path->mnt, flags);\n\telse if (!capable(CAP_SYS_ADMIN))\n\t\terr = -EPERM;\n\telse\n \t\terr = do_remount_sb(sb, flags, data, 0);\n \tif (!err) {\n \t\tlock_mount_hash();\n\t\tmnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;\n \t\tmnt->mnt.mnt_flags = mnt_flags;\n \t\ttouch_mnt_namespace(mnt->mnt_ns);\n \t\tunlock_mount_hash();\n\t}\n\tup_write(&sb->s_umount);\n\treturn err;\n}", "target": 1}
{"code": "static int axff_init(struct hid_device *hid)\n{\n\tstruct axff_device *axff;\n\tstruct hid_report *report;\n\tstruct hid_input *hidinput = list_first_entry(&hid->inputs, struct hid_input, list);\n\tstruct list_head *report_list =&hid->report_enum[HID_OUTPUT_REPORT].report_list;\n\tstruct input_dev *dev = hidinput->input;\n\tint field_count = 0;\n\tint i, j;\n\tint error;\n\tif (list_empty(report_list)) {\n\t\thid_err(hid, \"no output reports found\\n\");\n\t\treturn -ENODEV;\n\t}\n\treport = list_first_entry(report_list, struct hid_report, list);\n\tfor (i = 0; i < report->maxfield; i++) {\n\t\tfor (j = 0; j < report->field[i]->report_count; j++) {\n\t\t\treport->field[i]->value[j] = 0x00;\n\t\t\tfield_count++;\n\t\t}\n\t}\n\tif (field_count < 4 && hid->product != 0xf705) {\n\t\thid_err(hid, \"not enough fields in the report: %d\\n\",\n\t\t\tfield_count);\n\t\treturn -ENODEV;\n\t}\n\taxff = kzalloc(sizeof(struct axff_device), GFP_KERNEL);\n\tif (!axff)\n\t\treturn -ENOMEM;\n\tset_bit(FF_RUMBLE, dev->ffbit);\n\terror = input_ff_create_memless(dev, axff, axff_play);\n\tif (error)\n\t\tgoto err_free_mem;\n\taxff->report = report;\n\thid_hw_request(hid, axff->report, HID_REQ_SET_REPORT);\n\thid_info(hid, \"Force Feedback for ACRUX game controllers by Sergei Kolzun <x0r@dv-life.ru>\\n\");\n\treturn 0;\nerr_free_mem:\n\tkfree(axff);\n\treturn error;\n}", "target": 1}
{"code": "static ssize_t add_slot_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t      const char *buf, size_t nbytes)\n{\n\tchar drc_name[MAX_DRC_NAME_LEN];\n\tchar *end;\n\tint rc;\n\tif (nbytes >= MAX_DRC_NAME_LEN)\n\t\treturn 0;\n\tmemcpy(drc_name, buf, nbytes);\n\tend = strchr(drc_name, '\\n');\n\tif (!end)\n\t\tend = &drc_name[nbytes];\n\t*end = '\\0';\n\trc = dlpar_add_slot(drc_name);\n\tif (rc)\n\t\treturn rc;\n\treturn nbytes;\n}", "target": 1}
{"code": "static int codeCompare(\n  Parse *pParse,    \n  Expr *pLeft,      \n  Expr *pRight,     \n  int opcode,       \n  int in1, int in2, \n  int dest,         \n  int jumpIfNull,   \n  int isCommuted    \n){\n  int p5;\n  int addr;\n  CollSeq *p4;\n  if( isCommuted ){\n    p4 = sqlite3BinaryCompareCollSeq(pParse, pRight, pLeft);\n  }else{\n    p4 = sqlite3BinaryCompareCollSeq(pParse, pLeft, pRight);\n  }\n  p5 = binaryCompareP5(pLeft, pRight, jumpIfNull);\n  addr = sqlite3VdbeAddOp4(pParse->pVdbe, opcode, in2, dest, in1,\n                           (void*)p4, P4_COLLSEQ);\n  sqlite3VdbeChangeP5(pParse->pVdbe, (u8)p5);\n  return addr;\n}", "target": 1}
{"code": "static void cpia2_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct camera_data *cam = usb_get_intfdata(intf);\n\tusb_set_intfdata(intf, NULL);\n\tDBG(\"Stopping stream\\n\");\n\tcpia2_usb_stream_stop(cam);\n\tmutex_lock(&cam->v4l2_lock);\n\tDBG(\"Unregistering camera\\n\");\n\tcpia2_unregister_camera(cam);\n\tv4l2_device_disconnect(&cam->v4l2_dev);\n\tmutex_unlock(&cam->v4l2_lock);\n\tv4l2_device_put(&cam->v4l2_dev);\n\tif(cam->buffers) {\n\t\tDBG(\"Wakeup waiting processes\\n\");\n\t\tcam->curbuff->status = FRAME_READY;\n\t\tcam->curbuff->length = 0;\n\t\twake_up_interruptible(&cam->wq_stream);\n\t}\n\tLOG(\"CPiA2 camera disconnected.\\n\");\n}", "target": 1}
{"code": "static int mpeg4video_probe(AVProbeData *probe_packet)\n{\n    uint32_t temp_buffer = -1;\n    int VO = 0, VOL = 0, VOP = 0, VISO = 0, res = 0;\n    int i;\n     for (i = 0; i < probe_packet->buf_size; i++) {\n         temp_buffer = (temp_buffer << 8) + probe_packet->buf[i];\n        if ((temp_buffer & 0xffffff00) != 0x100)\n             continue;\n         if (temp_buffer == VOP_START_CODE)\n             VOP++;\n         else if (temp_buffer == VISUAL_OBJECT_START_CODE)\n             VISO++;\n        else if (temp_buffer < 0x120)\n             VO++;\n        else if (temp_buffer < 0x130)\n             VOL++;\n         else if (!(0x1AF < temp_buffer && temp_buffer < 0x1B7) &&\n                  !(0x1B9 < temp_buffer && temp_buffer < 0x1C4))\n            res++;\n    }\n    if (VOP >= VISO && VOP >= VOL && VO >= VOL && VOL > 0 && res == 0)\n        return AVPROBE_SCORE_EXTENSION;\n    return 0;\n}", "target": 1}
{"code": "static inline void ConvertRGBToCMYK(PixelInfo *pixel)\n{\n  MagickRealType\n    black,\n    blue,\n    cyan,\n    green,\n    magenta,\n    red,\n    yellow;\n  if (pixel->colorspace != sRGBColorspace)\n    {\n      red=QuantumScale*pixel->red;\n      green=QuantumScale*pixel->green;\n      blue=QuantumScale*pixel->blue;\n    }\n  else\n    {\n      red=QuantumScale*DecodePixelGamma(pixel->red);\n      green=QuantumScale*DecodePixelGamma(pixel->green);\n      blue=QuantumScale*DecodePixelGamma(pixel->blue);\n    }\n  if ((fabs((double) red) < MagickEpsilon) &&\n      (fabs((double) green) < MagickEpsilon) &&\n      (fabs((double) blue) < MagickEpsilon))\n    {\n      pixel->black=(MagickRealType) QuantumRange;\n      return;\n    }\n  cyan=(MagickRealType) (1.0-red);\n  magenta=(MagickRealType) (1.0-green);\n  yellow=(MagickRealType) (1.0-blue);\n  black=cyan;\n  if (magenta < black)\n    black=magenta;\n  if (yellow < black)\n    black=yellow;\n  cyan=(MagickRealType) ((cyan-black)/(1.0-black));\n  magenta=(MagickRealType) ((magenta-black)/(1.0-black));\n  yellow=(MagickRealType) ((yellow-black)/(1.0-black));\n  pixel->colorspace=CMYKColorspace;\n  pixel->red=QuantumRange*cyan;\n  pixel->green=QuantumRange*magenta;\n  pixel->blue=QuantumRange*yellow;\n  pixel->black=QuantumRange*black;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input_tensor = context->input(0);\n    const auto input_tensor_flat = input_tensor.flat<int32>();\n    const Tensor& input_splits = context->input(1);\n    const auto input_splits_flat = input_splits.flat<SPLITS_TYPE>();\n    TensorShape output_shape({input_splits.dim_size(0) - 1});\n    Tensor* output_tensor;\n    OP_REQUIRES_OK(context, context->allocate_output(\"output\", output_shape,\n                                                     &output_tensor));\n    auto output_tensor_flat = output_tensor->flat<tstring>();\n    int idx = 0;\n    for (int i = 1; i < input_splits_flat.size(); ++i) {\n      icu::UnicodeString unicode_string;\n      icu::UnicodeStringAppendable appendable_unicode_string(unicode_string);\n      for (; idx < input_splits_flat(i); ++idx) {\n        int32 code_point = input_tensor_flat(idx);\n        if (!U_IS_UNICODE_CHAR(code_point)) {\n          if (error_options_.error_on_malformatting) {\n            context->CtxFailure(errors::InvalidArgument(\n                \"Code point is out of range for Unicode, or a noncharacter.\"));\n            return;\n          } else if (!error_options_.elide_replacement) {\n            code_point = error_options_.subst;\n          }\n        }\n        appendable_unicode_string.appendCodePoint(code_point);\n      }\n      tstring result;\n      Encode(encoding_, unicode_string, &result);\n      output_tensor_flat(i - 1) = std::move(result);\n    }\n  }", "target": 1}
{"code": "static bool ldm_frag_add (const u8 *data, int size, struct list_head *frags)\n{\n\tstruct frag *f;\n\tstruct list_head *item;\n\tint rec, num, group;\n\tBUG_ON (!data || !frags);\n\tif (size < 2 * VBLK_SIZE_HEAD) {\n\t\tldm_error(\"Value of size is to small.\");\n\t\treturn false;\n\t}\n\tgroup = get_unaligned_be32(data + 0x08);\n\trec   = get_unaligned_be16(data + 0x0C);\n\tnum   = get_unaligned_be16(data + 0x0E);\n\tif ((num < 1) || (num > 4)) {\n\t\tldm_error (\"A VBLK claims to have %d parts.\", num);\n\t\treturn false;\n\t}\n\tif (rec >= num) {\n\t\tldm_error(\"REC value (%d) exceeds NUM value (%d)\", rec, num);\n\t\treturn false;\n\t}\n\tlist_for_each (item, frags) {\n\t\tf = list_entry (item, struct frag, list);\n\t\tif (f->group == group)\n\t\t\tgoto found;\n\t}\n\tf = kmalloc (sizeof (*f) + size*num, GFP_KERNEL);\n\tif (!f) {\n\t\tldm_crit (\"Out of memory.\");\n\t\treturn false;\n\t}\n\tf->group = group;\n\tf->num   = num;\n\tf->rec   = rec;\n\tf->map   = 0xFF << num;\n \tlist_add_tail (&f->list, frags);\n found:\n \tif (f->map & (1 << rec)) {\n \t\tldm_error (\"Duplicate VBLK, part %d.\", rec);\n \t\tf->map &= 0x7F;\t\t\t\n\t\treturn false;\n\t}\n\tf->map |= (1 << rec);\n\tdata += VBLK_SIZE_HEAD;\n\tsize -= VBLK_SIZE_HEAD;\n\tmemcpy (f->data+rec*(size-VBLK_SIZE_HEAD)+VBLK_SIZE_HEAD, data, size);\n\treturn true;\n}", "target": 1}
{"code": "uint32_t skip(Protocol_& prot, TType type) {\n  switch (type) {\n  case T_BOOL: {\n    bool boolv;\n    return prot.readBool(boolv);\n  }\n  case T_BYTE: {\n    int8_t bytev;\n    return prot.readByte(bytev);\n  }\n  case T_I16: {\n    int16_t i16;\n    return prot.readI16(i16);\n  }\n  case T_I32: {\n    int32_t i32;\n    return prot.readI32(i32);\n  }\n  case T_I64: {\n    int64_t i64;\n    return prot.readI64(i64);\n  }\n  case T_DOUBLE: {\n    double dub;\n    return prot.readDouble(dub);\n  }\n  case T_STRING: {\n    std::string str;\n    return prot.readBinary(str);\n  }\n  case T_STRUCT: {\n    uint32_t result = 0;\n    std::string name;\n    int16_t fid;\n    TType ftype;\n    result += prot.readStructBegin(name);\n    while (true) {\n      result += prot.readFieldBegin(name, ftype, fid);\n      if (ftype == T_STOP) {\n        break;\n      }\n      result += skip(prot, ftype);\n      result += prot.readFieldEnd();\n    }\n    result += prot.readStructEnd();\n    return result;\n  }\n  case T_MAP: {\n    uint32_t result = 0;\n    TType keyType;\n    TType valType;\n    uint32_t i, size;\n    result += prot.readMapBegin(keyType, valType, size);\n    for (i = 0; i < size; i++) {\n      result += skip(prot, keyType);\n      result += skip(prot, valType);\n    }\n    result += prot.readMapEnd();\n    return result;\n  }\n  case T_SET: {\n    uint32_t result = 0;\n    TType elemType;\n    uint32_t i, size;\n    result += prot.readSetBegin(elemType, size);\n    for (i = 0; i < size; i++) {\n      result += skip(prot, elemType);\n    }\n    result += prot.readSetEnd();\n    return result;\n  }\n  case T_LIST: {\n    uint32_t result = 0;\n    TType elemType;\n    uint32_t i, size;\n    result += prot.readListBegin(elemType, size);\n    for (i = 0; i < size; i++) {\n      result += skip(prot, elemType);\n    }\n    result += prot.readListEnd();\n    return result;\n  }\n  case T_STOP:\n  case T_VOID:\n  case T_U64:\n  case T_UTF8:\n  case T_UTF16:\n    break;\n  }\n  return 0;\n}", "target": 1}
{"code": "bool PPB_ImageData_Impl::Init(PP_ImageDataFormat format,\n                              int width, int height,\n                              bool init_to_zero) {\n  if (!IsImageDataFormatSupported(format))\n     return false;  \n   if (width <= 0 || height <= 0)\n     return false;\n  if (static_cast<int64>(width) * static_cast<int64>(height) * 4 >=\n      std::numeric_limits<int32>::max())\n     return false;  \n   format_ = format;\n  width_ = width;\n  height_ = height;\n  return backend_->Init(this, format, width, height, init_to_zero);\n}", "target": 1}
{"code": "BPMDetect::BPMDetect(int numChannels, int aSampleRate) :\n    beat_lpf(_LPF_coeffs)\n{\n    beats.reserve(250); \n    this->sampleRate = aSampleRate;\n    this->channels = numChannels;\n    decimateSum = 0;\n    decimateCount = 0;\n    decimateBy = sampleRate / TARGET_SRATE;\n    assert(decimateBy > 0);\n    assert(INPUT_BLOCK_SIZE < decimateBy * DECIMATED_BLOCK_SIZE);\n    windowLen = (60 * sampleRate) / (decimateBy * MIN_BPM);\n    windowStart = (60 * sampleRate) / (decimateBy * MAX_BPM_RANGE);\n    assert(windowLen > windowStart);\n    xcorr = new float[windowLen];\n    memset(xcorr, 0, windowLen * sizeof(float));\n    pos = 0;\n    peakPos = 0;\n    peakVal = 0;\n    init_scaler = 1;\n    beatcorr_ringbuffpos = 0;\n    beatcorr_ringbuff = new float[windowLen];\n    memset(beatcorr_ringbuff, 0, windowLen * sizeof(float));\n    buffer = new FIFOSampleBuffer();\n    buffer->setChannels(1);\n    buffer->clear();\n    hamw = new float[XCORR_UPDATE_SEQUENCE];\n    hamming(hamw, XCORR_UPDATE_SEQUENCE);\n    hamw2 = new float[XCORR_UPDATE_SEQUENCE / 2];\n    hamming(hamw2, XCORR_UPDATE_SEQUENCE / 2);\n}", "target": 1}
{"code": "static int ghash_update(struct shash_desc *desc,\n\t\t\t const u8 *src, unsigned int srclen)\n{\n\tstruct ghash_desc_ctx *dctx = shash_desc_ctx(desc);\n \tstruct ghash_ctx *ctx = crypto_shash_ctx(desc->tfm);\n \tu8 *dst = dctx->buffer;\n \tif (dctx->bytes) {\n \t\tint n = min(srclen, dctx->bytes);\n \t\tu8 *pos = dst + (GHASH_BLOCK_SIZE - dctx->bytes);\n\t\tdctx->bytes -= n;\n\t\tsrclen -= n;\n\t\twhile (n--)\n\t\t\t*pos++ ^= *src++;\n\t\tif (!dctx->bytes)\n\t\t\tgf128mul_4k_lle((be128 *)dst, ctx->gf128);\n\t}\n\twhile (srclen >= GHASH_BLOCK_SIZE) {\n\t\tcrypto_xor(dst, src, GHASH_BLOCK_SIZE);\n\t\tgf128mul_4k_lle((be128 *)dst, ctx->gf128);\n\t\tsrc += GHASH_BLOCK_SIZE;\n\t\tsrclen -= GHASH_BLOCK_SIZE;\n\t}\n\tif (srclen) {\n\t\tdctx->bytes = GHASH_BLOCK_SIZE - srclen;\n\t\twhile (srclen--)\n\t\t\t*dst++ ^= *src++;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": " struct request *blk_mq_tag_to_rq(struct blk_mq_tags *tags, unsigned int tag)\n {\n\tstruct request *rq = tags->rqs[tag];\n\tstruct blk_flush_queue *fq = blk_get_flush_queue(rq->q, rq->mq_ctx);\n\tif (!is_flush_request(rq, fq, tag))\n\t\treturn rq;\n\treturn fq->flush_rq;\n }", "target": 1}
{"code": "_rsvg_io_get_file_path (const gchar * filename,\n                        const gchar * base_uri)\n {\n     gchar *absolute_filename;\n    if (g_file_test (filename, G_FILE_TEST_EXISTS) || g_path_is_absolute (filename)) {\n         absolute_filename = g_strdup (filename);\n     } else {\n         gchar *tmpcdir;\n        gchar *base_filename;\n        if (base_uri) {\n            base_filename = g_filename_from_uri (base_uri, NULL, NULL);\n            if (base_filename != NULL) {\n                tmpcdir = g_path_get_dirname (base_filename);\n                g_free (base_filename);\n            } else \n                return NULL;\n        } else\n            tmpcdir = g_get_current_dir ();\n        absolute_filename = g_build_filename (tmpcdir, filename, NULL);\n        g_free (tmpcdir);\n    }\n    return absolute_filename;\n}", "target": 1}
{"code": "ffi_prep_closure_loc (ffi_closure *closure,\n                      ffi_cif* cif,\n                      void (*fun)(ffi_cif*,void*,void**,void*),\n                      void *user_data,\n                      void *codeloc)\n{\n  if (cif->abi != FFI_SYSV)\n    return FFI_BAD_ABI;\n  void (*start)(void);\n  if (cif->flags & AARCH64_FLAG_ARG_V)\n    start = ffi_closure_SYSV_V;\n  else\n    start = ffi_closure_SYSV;\n#if FFI_EXEC_TRAMPOLINE_TABLE\n#ifdef __MACH__\n  void **config = (void **)((uint8_t *)codeloc - PAGE_MAX_SIZE);\n  config[0] = closure;\n  config[1] = start;\n#endif\n#else\n  static const unsigned char trampoline[16] = {\n    0x90, 0x00, 0x00, 0x58,\t\n    0xf1, 0xff, 0xff, 0x10,\t\n    0x00, 0x02, 0x1f, 0xd6\t\n  };\n  char *tramp = closure->tramp;\n  memcpy (tramp, trampoline, sizeof(trampoline));\n  *(UINT64 *)(tramp + 16) = (uintptr_t)start;\n  ffi_clear_cache(tramp, tramp + FFI_TRAMPOLINE_SIZE);\n#endif\n  closure->cif = cif;\n  closure->fun = fun;\n  closure->user_data = user_data;\n  return FFI_OK;\n}", "target": 1}
{"code": "bool SimplifiedBackwardsTextIterator::handleTextNode()\n{\n    m_lastTextNode = m_node;\n    int startOffset;\n    int offsetInNode;\n    RenderText* renderer = handleFirstLetter(startOffset, offsetInNode);\n    if (!renderer)\n        return true;\n    String text = renderer->text();\n    if (!renderer->firstTextBox() && text.length() > 0)\n        return true;\n    m_positionEndOffset = m_offset;\n    m_offset = startOffset + offsetInNode;\n    m_positionNode = m_node;\n    m_positionStartOffset = m_offset;\n    ASSERT(0 <= m_positionStartOffset - offsetInNode && m_positionStartOffset - offsetInNode <= static_cast<int>(text.length()));\n    ASSERT(1 <= m_positionEndOffset - offsetInNode && m_positionEndOffset - offsetInNode <= static_cast<int>(text.length()));\n    ASSERT(m_positionStartOffset <= m_positionEndOffset);\n     m_textLength = m_positionEndOffset - m_positionStartOffset;\n     m_textCharacters = text.characters() + (m_positionStartOffset - offsetInNode);\n     ASSERT(m_textCharacters >= text.characters());\n    ASSERT(m_textCharacters + m_textLength <= text.characters() + static_cast<int>(text.length()));\n     m_lastCharacter = text[m_positionEndOffset - 1];\n    return !m_shouldHandleFirstLetter;\n}", "target": 1}
{"code": " static int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)\n {\n \tstruct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;\n \treturn aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);\n }", "target": 1}
{"code": "find_help_tags(\n    char_u\t*arg,\n    int\t\t*num_matches,\n    char_u\t***matches,\n    int\t\tkeep_lang)\n{\n    char_u\t*s, *d;\n    int\t\ti;\n    static char *(except_tbl[][2]) = {\n\t{\"*\",\t\t\"star\"},\n\t{\"g*\",\t\t\"gstar\"},\n\t{\"[*\",\t\t\"[star\"},\n\t{\"]*\",\t\t\"]star\"},\n\t{\":*\",\t\t\":star\"},\n\t{\"", "target": 1}
{"code": "static __inline__ int cbq_dump_ovl(struct sk_buff *skb, struct cbq_class *cl)\n{\n\tunsigned char\t *b = skb->tail;\n\tstruct tc_cbq_ovl opt;\n\topt.strategy = cl->ovl_strategy;\n\topt.priority2 = cl->priority2+1;\n\topt.penalty = (cl->penalty*1000)/HZ;\n\tRTA_PUT(skb, TCA_CBQ_OVL_STRATEGY, sizeof(opt), &opt);\n\treturn skb->len;\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1}
{"code": "static void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tstruct sock *sk;\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tsk = s->sk;\n\t\t\tsock_hold(sk);\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(sk);\n\t\t\ts->ax25_dev = NULL;\n\t\t\tdev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker);\n\t\t\tax25_dev_put(ax25_dev);\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\trelease_sock(sk);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tsock_put(sk);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}", "target": 1}
{"code": "gdImageScaleTwoPass(const gdImagePtr src, const unsigned int new_width,\n                    const unsigned int new_height)\n{\n    const unsigned int src_width = src->sx;\n    const unsigned int src_height = src->sy;\n\tgdImagePtr tmp_im = NULL;\n\tgdImagePtr dst = NULL;\n    if (src_width == new_width && src_height == new_height) {\n        return gdImageClone(src);\n    }\n\tif (!src->trueColor) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n    if (src_width == new_width) {\n        tmp_im = src;\n    } else {\n        tmp_im = gdImageCreateTrueColor(new_width, src_height);\n        if (tmp_im == NULL) {\n            return NULL;\n        }\n        gdImageSetInterpolationMethod(tmp_im, src->interpolation_id);\n        _gdScalePass(src, src_width, tmp_im, new_width, src_height, HORIZONTAL);\n    }\n    if (src_height == new_height) {\n        assert(tmp_im != src);\n        return tmp_im;\n    }\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (dst != NULL) {\n        gdImageSetInterpolationMethod(dst, src->interpolation_id);\n        _gdScalePass(tmp_im, src_height, dst, new_height, new_width, VERTICAL);\n     }\n     if (src != tmp_im) {\n        gdFree(tmp_im);\n     }\n \treturn dst;\n}", "target": 1}
{"code": "static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct encrypted_key_payload *epayload = key->payload.data[0];\n\tstruct encrypted_key_payload *new_epayload;\n\tchar *buf;\n\tchar *new_master_desc = NULL;\n\tconst char *format = NULL;\n \tsize_t datalen = prep->datalen;\n \tint ret = 0;\n \tif (datalen <= 0 || datalen > 32767 || !prep->data)\n \t\treturn -EINVAL;\n\tbuf = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tbuf[datalen] = 0;\n\tmemcpy(buf, prep->data, datalen);\n\tret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = valid_master_desc(new_master_desc, epayload->master_desc);\n\tif (ret < 0)\n\t\tgoto out;\n\tnew_epayload = encrypted_key_alloc(key, epayload->format,\n\t\t\t\t\t   new_master_desc, epayload->datalen);\n\tif (IS_ERR(new_epayload)) {\n\t\tret = PTR_ERR(new_epayload);\n\t\tgoto out;\n\t}\n\t__ekey_init(new_epayload, epayload->format, new_master_desc,\n\t\t    epayload->datalen);\n\tmemcpy(new_epayload->iv, epayload->iv, ivsize);\n\tmemcpy(new_epayload->payload_data, epayload->payload_data,\n\t       epayload->payload_datalen);\n\trcu_assign_keypointer(key, new_epayload);\n\tcall_rcu(&epayload->rcu, encrypted_rcu_free);\nout:\n\tkfree(buf);\n\treturn ret;\n}", "target": 1}
{"code": "int hci_req_sync(struct hci_dev *hdev, int (*req)(struct hci_request *req,\n\t\t\t\t\t\t  unsigned long opt),\n\t\t unsigned long opt, u32 timeout, u8 *hci_status)\n{\n\tint ret;\n\tif (!test_bit(HCI_UP, &hdev->flags))\n\t\treturn -ENETDOWN;\n\thci_req_sync_lock(hdev);\n\tret = __hci_req_sync(hdev, req, opt, timeout, hci_status);\n\thci_req_sync_unlock(hdev);\n\treturn ret;\n}", "target": 1}
{"code": "int X509_cmp_time(ASN1_TIME *ctm, time_t *cmp_time)\n{\n    char *str;\n    ASN1_TIME atm;\n    long offset;\n    char buff1[24], buff2[24], *p;\n    int i, j;\n    p = buff1;\n    i = ctm->length;\n    str = (char *)ctm->data;\n    if (ctm->type == V_ASN1_UTCTIME) {\n        if ((i < 11) || (i > 17))\n            return 0;\n        memcpy(p, str, 10);\n        p += 10;\n        str += 10;\n    } else {\n        if (i < 13)\n            return 0;\n        memcpy(p, str, 12);\n        p += 12;\n        str += 12;\n    }\n    if ((*str == 'Z') || (*str == '-') || (*str == '+')) {\n        *(p++) = '0';\n        *(p++) = '0';\n    } else {\n        *(p++) = *(str++);\n        *(p++) = *(str++);\n        if (*str == '.') {\n            str++;\n            while ((*str >= '0') && (*str <= '9'))\n                str++;\n        }\n    }\n    *(p++) = 'Z';\n    *(p++) = '\\0';\n    if (*str == 'Z')\n        offset = 0;\n    else {\n        if ((*str != '+') && (*str != '-'))\n            return 0;\n        offset = ((str[1] - '0') * 10 + (str[2] - '0')) * 60;\n        offset += (str[3] - '0') * 10 + (str[4] - '0');\n        if (*str == '-')\n            offset = -offset;\n    }\n    atm.type = ctm->type;\n    atm.length = sizeof(buff2);\n    atm.data = (unsigned char *)buff2;\n    if (X509_time_adj(&atm, offset * 60, cmp_time) == NULL)\n        return 0;\n    if (ctm->type == V_ASN1_UTCTIME) {\n        i = (buff1[0] - '0') * 10 + (buff1[1] - '0');\n        if (i < 50)\n            i += 100;           \n        j = (buff2[0] - '0') * 10 + (buff2[1] - '0');\n        if (j < 50)\n            j += 100;\n        if (i < j)\n            return -1;\n        if (i > j)\n            return 1;\n    }\n    i = strcmp(buff1, buff2);\n    if (i == 0)                 \n        return -1;\n    else\n        return i;\n}", "target": 1}
{"code": "static TValue *trace_exit_cp(lua_State *L, lua_CFunction dummy, void *ud)\n{\n  ExitDataCP *exd = (ExitDataCP *)ud;\n  cframe_errfunc(L->cframe) = -1;  \n  exd->pc = lj_snap_restore(exd->J, exd->exptr);\n  UNUSED(dummy);\n  return NULL;\n}", "target": 1}
{"code": "  bool const_item() const { return used_tables() == 0; }", "target": 1}
{"code": "vhost_scsi_make_tpg(struct se_wwn *wwn,\n\t\t   struct config_group *group,\n\t\t   const char *name)\n{\n\tstruct vhost_scsi_tport *tport = container_of(wwn,\n \t\t\tstruct vhost_scsi_tport, tport_wwn);\n \tstruct vhost_scsi_tpg *tpg;\n\tunsigned long tpgt;\n \tint ret;\n \tif (strstr(name, \"tpgt_\") != name)\n \t\treturn ERR_PTR(-EINVAL);\n\tif (kstrtoul(name + 5, 10, &tpgt) || tpgt > UINT_MAX)\n \t\treturn ERR_PTR(-EINVAL);\n \ttpg = kzalloc(sizeof(struct vhost_scsi_tpg), GFP_KERNEL);\n\tif (!tpg) {\n\t\tpr_err(\"Unable to allocate struct vhost_scsi_tpg\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tmutex_init(&tpg->tv_tpg_mutex);\n\tINIT_LIST_HEAD(&tpg->tv_tpg_list);\n\ttpg->tport = tport;\n\ttpg->tport_tpgt = tpgt;\n\tret = core_tpg_register(&vhost_scsi_fabric_configfs->tf_ops, wwn,\n\t\t\t\t&tpg->se_tpg, tpg, TRANSPORT_TPG_TYPE_NORMAL);\n\tif (ret < 0) {\n\t\tkfree(tpg);\n\t\treturn NULL;\n\t}\n\tmutex_lock(&vhost_scsi_mutex);\n\tlist_add_tail(&tpg->tv_tpg_list, &vhost_scsi_list);\n\tmutex_unlock(&vhost_scsi_mutex);\n\treturn &tpg->se_tpg;\n}", "target": 1}
{"code": "int ssh_scp_init(ssh_scp scp)\n{\n    int rc;\n    char execbuffer[1024] = {0};\n    if (scp == NULL) {\n        return SSH_ERROR;\n    }\n    if (scp->state != SSH_SCP_NEW) {\n        ssh_set_error(scp->session, SSH_FATAL,\n                      \"ssh_scp_init called under invalid state\");\n        return SSH_ERROR;\n    }\n    SSH_LOG(SSH_LOG_PROTOCOL,\n            \"Initializing scp session %s %son location '%s'\",\n            scp->mode == SSH_SCP_WRITE?\"write\":\"read\",\n            scp->recursive?\"recursive \":\"\",\n            scp->location);\n    scp->channel = ssh_channel_new(scp->session);\n    if (scp->channel == NULL) {\n        scp->state = SSH_SCP_ERROR;\n        return SSH_ERROR;\n    }\n    rc = ssh_channel_open_session(scp->channel);\n    if (rc == SSH_ERROR) {\n        scp->state = SSH_SCP_ERROR;\n        return SSH_ERROR;\n    }\n    if (scp->mode == SSH_SCP_WRITE) {\n        snprintf(execbuffer, sizeof(execbuffer), \"scp -t %s %s\",\n                scp->recursive ? \"-r\":\"\", scp->location);\n    } else {\n        snprintf(execbuffer, sizeof(execbuffer), \"scp -f %s %s\",\n                scp->recursive ? \"-r\":\"\", scp->location);\n    }\n    if (ssh_channel_request_exec(scp->channel, execbuffer) == SSH_ERROR) {\n        scp->state = SSH_SCP_ERROR;\n        return SSH_ERROR;\n    }\n    if (scp->mode == SSH_SCP_WRITE) {\n        rc = ssh_scp_response(scp, NULL);\n        if (rc != 0) {\n            return SSH_ERROR;\n        }\n    } else {\n        ssh_channel_write(scp->channel, \"\", 1);\n    }\n    if (scp->mode == SSH_SCP_WRITE) {\n        scp->state = SSH_SCP_WRITE_INITED;\n    } else {\n        scp->state = SSH_SCP_READ_INITED;\n    }\n    return SSH_OK;\n}", "target": 1}
{"code": "static void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(s->sk);\n\t\t\ts->ax25_dev = NULL;\n\t\t\trelease_sock(s->sk);\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}", "target": 1}
{"code": "void PacketReader::getLabelFromContent(const vector<uint8_t>& content, uint16_t& frompos, string& ret, int recurs) \n{\n  if(recurs > 1000) \n    throw MOADNSException(\"Loop\");\n  int pos = frompos;\n  for(;;) {\n    unsigned char labellen=content.at(frompos++);\n    if(!labellen) {\n      if(ret.empty())\n              ret.append(1,'.');\n      break;\n    }\n    else if((labellen & 0xc0) == 0xc0) {\n      uint16_t offset=256*(labellen & ~0xc0) + (unsigned int)content.at(frompos++) - sizeof(dnsheader);\n      if(offset >= pos-2)\n        throw MOADNSException(\"forward reference during label decompression\");\n      return getLabelFromContent(content, offset, ret, ++recurs);\n    }\n    else if(labellen > 63) \n      throw MOADNSException(\"Overly long label during label decompression (\"+lexical_cast<string>((unsigned int)labellen)+\")\");\n    else {\n      for(string::size_type n = 0 ; n < labellen; ++n, frompos++) {\n        if(content.at(frompos)=='.' || content.at(frompos)=='\\\\') {\n          ret.append(1, '\\\\');\n          ret.append(1, content[frompos]);\n        }\n        else if(content.at(frompos)==' ') {\n          ret+=\"\\\\032\";\n        }\n        else \n          ret.append(1, content[frompos]);\n      }\n      ret.append(1,'.');\n    }\n  }\n}", "target": 1}
{"code": "R_API bool r_crbtree_insert(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree && data && cmp, false);\n\tbool inserted = false;\n\tif (tree->root == NULL) {\n\t\ttree->root = _node_new (data, NULL);\n\t\tif (tree->root == NULL) {\n\t\t\treturn false;\n\t\t}\n\t\tinserted = true;\n\t\tgoto out_exit;\n\t}\n\tRRBNode head; \n\tmemset (&head, 0, sizeof (RRBNode));\n\tRRBNode *g = NULL, *parent = &head; \n\tRRBNode *p = NULL, *q = tree->root; \n\tint dir = 0, last = 0; \n\t_set_link (parent, q, 1);\n\tfor (;;) {\n\t\tif (!q) {\n\t\t\tq = _node_new (data, p);\n\t\t\tif (!q) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tp->link[dir] = q;\n\t\t\tinserted = true;\n\t\t} else if (IS_RED (q->link[0]) && IS_RED (q->link[1])) {\n\t\t\tq->red = 1;\n\t\t\tq->link[0]->red = 0;\n\t\t\tq->link[1]->red = 0;\n\t\t}\n\t\tif (IS_RED (q) && IS_RED (p)) {\n#if 0\n\t\t\tif (!parent) {\n\t\t\t\treturn false;\n\t\t\t}\n#endif\n\t\t\tint dir2 = parent->link[1] == g;\n\t\t\tif (q == p->link[last]) {\n\t\t\t\t_set_link (parent, _rot_once (g, !last), dir2);\n\t\t\t} else {\n\t\t\t\t_set_link (parent, _rot_twice (g, !last), dir2);\n\t\t\t}\n\t\t}\n\t\tif (inserted) {\n\t\t\tbreak;\n\t\t}\n\t\tlast = dir;\n\t\tdir = cmp (data, q->data, user) >= 0;\n\t\tif (g) {\n\t\t\tparent = g;\n\t\t}\n\t\tg = p;\n\t\tp = q;\n\t\tq = q->link[dir];\n\t}\n\ttree->root = head.link[1];\nout_exit:\n\ttree->root->red = 0;\n\ttree->root->parent = NULL;\n\tif (inserted) {\n\t\ttree->size++;\n\t}\n\treturn inserted;\n}", "target": 1}
{"code": "acc_ctx_cont(OM_uint32 *minstat,\n\t     gss_buffer_t buf,\n\t     gss_ctx_id_t *ctx,\n\t     gss_buffer_t *responseToken,\n\t     gss_buffer_t *mechListMIC,\n\t     OM_uint32 *negState,\n\t     send_token_flag *return_token)\n{\n\tOM_uint32 ret, tmpmin;\n\tgss_OID supportedMech;\n\tspnego_gss_ctx_id_t sc;\n\tunsigned int len;\n\tunsigned char *ptr, *bufstart;\n\tsc = (spnego_gss_ctx_id_t)*ctx;\n\tret = GSS_S_DEFECTIVE_TOKEN;\n\t*negState = REJECT;\n\t*minstat = 0;\n\tsupportedMech = GSS_C_NO_OID;\n\t*return_token = ERROR_TOKEN_SEND;\n\t*responseToken = *mechListMIC = GSS_C_NO_BUFFER;\n \tptr = bufstart = buf->value;\n #define REMAIN (buf->length - (ptr - bufstart))\n\tif (REMAIN > INT_MAX)\n \t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tif (*ptr == HEADER_ID) {\n\t\tret = g_verify_token_header(gss_mech_spnego,\n\t\t\t\t\t    &len, &ptr, 0, REMAIN);\n\t\tif (ret) {\n\t\t\t*minstat = ret;\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t\t}\n\t}\n\tif (*ptr != (CONTEXT | 0x01)) {\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\tret = get_negTokenResp(minstat, ptr, REMAIN,\n\t\t\t       negState, &supportedMech,\n\t\t\t       responseToken, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\tif (*responseToken == GSS_C_NO_BUFFER &&\n\t    *mechListMIC == GSS_C_NO_BUFFER) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto cleanup;\n\t}\n\tif (supportedMech != GSS_C_NO_OID) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto cleanup;\n\t}\n\tsc->firstpass = 0;\n\t*negState = ACCEPT_INCOMPLETE;\n\t*return_token = CONT_TOKEN_SEND;\ncleanup:\n\tif (supportedMech != GSS_C_NO_OID) {\n\t\tgeneric_gss_release_oid(&tmpmin, &supportedMech);\n\t}\n\treturn ret;\n#undef REMAIN\n}", "target": 1}
{"code": " gs_nulldevice(gs_gstate * pgs)\n {\n     int code = 0;\n     if (pgs->device == 0 || !gx_device_is_null(pgs->device)) {\n         gx_device *ndev;\n         code = gs_copydevice(&ndev, (const gx_device *)&gs_null_device,\n                                 pgs->memory);\n         if (code < 0)\n             return code;\n        rc_init(ndev, pgs->memory, 0);\n        if (pgs->device != NULL) {\n            if ((code = dev_proc(pgs->device, get_profile)(pgs->device,\n                                               &(ndev->icc_struct))) < 0)\n                return code;\n            rc_increment(ndev->icc_struct);\n            set_dev_proc(ndev, get_profile, gx_default_get_profile);\n        }\n        if ((code = gs_setdevice_no_erase(pgs, ndev)) < 0)\n         if ((code = gs_setdevice_no_erase(pgs, ndev)) < 0)\n             gs_free_object(pgs->memory, ndev, \"gs_copydevice(device)\");\n     }\n     return code;\n }", "target": 1}
{"code": "static gint conv_jistoeuc(gchar *outbuf, gint outlen, const gchar *inbuf)\n{\n\tconst guchar *in = inbuf;\n\tguchar *out = outbuf;\n\tJISState state = JIS_ASCII;\n\twhile (*in != '\\0') {\n\t\tif (*in == ESC) {\n\t\t\tin++;\n\t\t\tif (*in == '$') {\n\t\t\t\tif (*(in + 1) == '@' || *(in + 1) == 'B') {\n\t\t\t\t\tstate = JIS_KANJI;\n\t\t\t\t\tin += 2;\n\t\t\t\t} else if (*(in + 1) == '(' &&\n\t\t\t\t\t   *(in + 2) == 'D') {\n\t\t\t\t\tstate = JIS_AUXKANJI;\n\t\t\t\t\tin += 3;\n\t\t\t\t} else {\n\t\t\t\t\tstate = JIS_ASCII;\n\t\t\t\t}\n\t\t\t} else if (*in == '(') {\n\t\t\t\tif (*(in + 1) == 'B' || *(in + 1) == 'J') {\n\t\t\t\t\tstate = JIS_ASCII;\n\t\t\t\t\tin += 2;\n\t\t\t\t} else if (*(in + 1) == 'I') {\n\t\t\t\t\tstate = JIS_HWKANA;\n\t\t\t\t\tin += 2;\n\t\t\t\t} else {\n\t\t\t\t\tstate = JIS_ASCII;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstate = JIS_ASCII;\n\t\t\t}\n\t\t} else if (*in == 0x0e) {\n\t\t\tstate = JIS_HWKANA;\n\t\t\tin++;\n\t\t} else if (*in == 0x0f) {\n\t\t\tstate = JIS_ASCII;\n\t\t\tin++;\n\t\t} else {\n\t\t\tswitch (state) {\n\t\t\tcase JIS_ASCII:\n\t\t\t\t*out++ = *in++;\n\t\t\t\tbreak;\n\t\t\tcase JIS_KANJI:\n\t\t\t\t*out++ = *in++ | 0x80;\n\t\t\t\tif (*in == '\\0') break;\n\t\t\t\t*out++ = *in++ | 0x80;\n\t\t\t\tbreak;\n\t\t\tcase JIS_HWKANA:\n\t\t\t\t*out++ = 0x8e;\n\t\t\t\t*out++ = *in++ | 0x80;\n\t\t\t\tbreak;\n\t\t\tcase JIS_AUXKANJI:\n\t\t\t\t*out++ = 0x8f;\n\t\t\t\t*out++ = *in++ | 0x80;\n\t\t\t\tif (*in == '\\0') break;\n\t\t\t\t*out++ = *in++ | 0x80;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t*out = '\\0';\n\treturn 0;\n}", "target": 1}
{"code": " _dbus_header_byteswap (DBusHeader *header,\n                        int         new_order)\n {\n   if (header->byte_order == new_order)\n     return;\n   _dbus_marshal_byteswap (&_dbus_header_signature_str,\n                           0, header->byte_order,\n                           new_order,\n                           &header->data, 0);\n   header->byte_order = new_order;\n }", "target": 1}
{"code": "bool ZipCommon::isValidPath(const std::string& path)\n{\n\tif (path == \"..\")\n\t\treturn false;\n\tif (path.compare(0, 3, \"../\") == 0)\n\t\treturn false;\n\tif (path.compare(0, 3, \"..\\\\\") == 0)\n\t\treturn false;\n\tif (path.find(\"/..\") != std::string::npos)\n\t\treturn false;\n\tif (path.find(\"\\\\..\") != std::string::npos)\n\t\treturn false;\n\treturn true;\n}", "target": 1}
{"code": "  String_Obj Parser::parse_url_function_argument()\n  {\n    const char* p = position;\n    std::string uri(\"\");\n    if (lex< real_uri_value >(false)) {\n      uri = lexed.to_string();\n    }\n    if (peek< exactly< hash_lbrace > >()) {\n      const char* pp = position;\n      while (pp && peek< exactly< hash_lbrace > >(pp)) {\n        pp = sequence< interpolant, real_uri_value >(pp);\n      }\n      position = pp;\n      return parse_interpolated_chunk(Token(p, position));\n    }\n    else if (uri != \"\") {\n      std::string res = Util::rtrim(uri);\n      return SASS_MEMORY_NEW(String_Constant, pstate, res);\n    }\n    return 0;\n  }", "target": 1}
{"code": "WebContents* DevToolsWindow::OpenURLFromTab(\n    WebContents* source,\n    const content::OpenURLParams& params) {\n   DCHECK(source == main_web_contents_);\n   if (!params.url.SchemeIs(content::kChromeDevToolsScheme)) {\n     WebContents* inspected_web_contents = GetInspectedWebContents();\n    return inspected_web_contents ?\n        inspected_web_contents->OpenURL(params) : NULL;\n   }\n   bindings_->Reload();\n   return main_web_contents_;\n}", "target": 1}
{"code": " stringprep_utf8_nfkc_normalize (const char *str, ssize_t len)\n {\n   return g_utf8_normalize (str, len, G_NORMALIZE_NFKC);\n }", "target": 1}
{"code": "void PPB_Buffer_Proxy::OnMsgCreate(\n    PP_Instance instance,\n    uint32_t size,\n    HostResource* result_resource,\n    ppapi::proxy::SerializedHandle* result_shm_handle) {\n  result_shm_handle->set_null_shmem();\n   HostDispatcher* dispatcher = HostDispatcher::GetForInstance(instance);\n   if (!dispatcher)\n     return;\n   thunk::EnterResourceCreation enter(instance);\n   if (enter.failed())\n    return;\n  PP_Resource local_buffer_resource = enter.functions()->CreateBuffer(instance,\n                                                                      size);\n  if (local_buffer_resource == 0)\n    return;\n  thunk::EnterResourceNoLock<thunk::PPB_BufferTrusted_API> trusted_buffer(\n      local_buffer_resource, false);\n  if (trusted_buffer.failed())\n    return;\n  int local_fd;\n  if (trusted_buffer.object()->GetSharedMemory(&local_fd) != PP_OK)\n    return;\n  result_resource->SetHostResource(instance, local_buffer_resource);\n  base::PlatformFile platform_file =\n#if defined(OS_WIN)\n      reinterpret_cast<HANDLE>(static_cast<intptr_t>(local_fd));\n#elif defined(OS_POSIX)\n      local_fd;\n#else\n  #error Not implemented.\n#endif\n  result_shm_handle->set_shmem(\n      dispatcher->ShareHandleWithRemote(platform_file, false), size);\n}", "target": 1}
{"code": "}\nvoid print_udta(GF_ISOFile *file, u32 track_number, Bool has_itags)\n{\n\tu32 i, count;\n\tcount =  gf_isom_get_udta_count(file, track_number);\n\tif (!count) return;\n\tif (has_itags) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu32 type;\n\t\t\tbin128 uuid;\n\t\t\tgf_isom_get_udta_type(file, track_number, i+1, &type, &uuid);\n\t\t\tif (type == GF_ISOM_BOX_TYPE_META) {\n\t\t\t\tcount--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!count) return;\n\t}\n\tfprintf(stderr, \"%d UDTA types: \", count);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j, type, nb_items, first=GF_TRUE;\n\t\tbin128 uuid;\n\t\tgf_isom_get_udta_type(file, track_number, i+1, &type, &uuid);\n\t\tnb_items = gf_isom_get_user_data_count(file, track_number, type, uuid);\n\t\tfprintf(stderr, \"%s (%d) \", gf_4cc_to_str(type), nb_items);\n\t\tfor (j=0; j<nb_items; j++) {\n\t\t\tu8 *udta=NULL;\n\t\t\tu32 udta_size;\n\t\t\tgf_isom_get_user_data(file, track_number, type, uuid, j+1, &udta, &udta_size);\n\t\t\tif (!udta) continue;\n\t\t\tif (gf_utf8_is_legal(udta, udta_size)) {\n\t\t\t\tif (first) {\n\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\tfirst = GF_FALSE;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\t%s\\n\", (char *) udta);\n\t\t\t}\n\t\t\tgf_free(udta);\n\t\t}\n\t}", "target": 1}
{"code": "static int nr_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t      struct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;\n\tsize_t copied;\n\tstruct sk_buff *skb;\n\tint er;\n\tlock_sock(sk);\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\trelease_sock(sk);\n\t\treturn -ENOTCONN;\n\t}\n\tif ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL) {\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\tskb_reset_transport_header(skb);\n\tcopied     = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\ter = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (er < 0) {\n\t\tskb_free_datagram(sk, skb);\n\t\trelease_sock(sk);\n\t\treturn er;\n \t}\n \tif (sax != NULL) {\n\t\tmemset(sax, 0, sizeof(sax));\n \t\tsax->sax25_family = AF_NETROM;\n \t\tskb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,\n \t\t\t      AX25_ADDR_LEN);\n\t}\n\tmsg->msg_namelen = sizeof(*sax);\n\tskb_free_datagram(sk, skb);\n\trelease_sock(sk);\n\treturn copied;\n}", "target": 1}
{"code": "build_model(XML_Parser parser) {\n  DTD *const dtd = parser->m_dtd; \n  XML_Content *ret;\n  XML_Content *cpos;\n  XML_Char *str;\n#if UINT_MAX >= SIZE_MAX\n  if (dtd->scaffCount > (size_t)(-1) / sizeof(XML_Content)) {\n    return NULL;\n  }\n  if (dtd->contentStringLen > (size_t)(-1) / sizeof(XML_Char)) {\n    return NULL;\n  }\n#endif\n  if (dtd->scaffCount * sizeof(XML_Content)\n      > (size_t)(-1) - dtd->contentStringLen * sizeof(XML_Char)) {\n    return NULL;\n  }\n  const size_t allocsize = (dtd->scaffCount * sizeof(XML_Content)\n                            + (dtd->contentStringLen * sizeof(XML_Char)));\n  ret = (XML_Content *)MALLOC(parser, allocsize);\n  if (! ret)\n    return NULL;\n  str = (XML_Char *)(&ret[dtd->scaffCount]);\n  cpos = &ret[1];\n  build_node(parser, 0, ret, &cpos, &str);\n  return ret;\n}", "target": 1}
{"code": "init_device (u2fh_devs * devs, struct u2fdevice *dev)\n{\n  unsigned char resp[1024];\n  unsigned char nonce[8];\n  if (obtain_nonce(nonce) != 0)\n    {\n      return U2FH_TRANSPORT_ERROR;\n    }\n  size_t resplen = sizeof (resp);\n  dev->cid = CID_BROADCAST;\n  if (u2fh_sendrecv\n       (devs, dev->id, U2FHID_INIT, nonce, sizeof (nonce), resp,\n        &resplen) == U2FH_OK)\n     {\n      U2FHID_INIT_RESP initresp;\n      if (resplen > sizeof (initresp))\n \t{\n\t  return U2FH_MEMORY_ERROR;\n \t}\n      memcpy (&initresp, resp, resplen);\n      dev->cid = initresp.cid;\n      dev->versionInterface = initresp.versionInterface;\n      dev->versionMajor = initresp.versionMajor;\n      dev->versionMinor = initresp.versionMinor;\n      dev->capFlags = initresp.capFlags;\n     }\n   else\n     {\n      return U2FH_TRANSPORT_ERROR;\n    }\n  return U2FH_OK;\n}", "target": 1}
{"code": "int setup_tests(void)\n{\n    ADD_ALL_TESTS(call_run_cert, OSSL_NELEM(name_fns));\n    return 1;\n}", "target": 1}
{"code": "void BufferQueueConsumer::dump(String8& result, const char* prefix) const {\n const IPCThreadState* ipc = IPCThreadState::self();\n const pid_t pid = ipc->getCallingPid();\n const uid_t uid = ipc->getCallingUid();\n if ((uid != AID_SHELL)\n && !PermissionCache::checkPermission(String16(\n             \"android.permission.DUMP\"), pid, uid)) {\n         result.appendFormat(\"Permission Denial: can't dump BufferQueueConsumer \"\n                 \"from pid=%d, uid=%d\\n\", pid, uid);\n     } else {\n         mCore->dump(result, prefix);\n     }\n}", "target": 1}
{"code": "  Status GetFirstDimensionSize(OpKernelContext* context, INDEX_TYPE* result) {\n    const Tensor first_partition_tensor =\n        context->input(kFirstPartitionInputIndex);\n    const RowPartitionType first_partition_type = row_partition_types_[0];\n    switch (first_partition_type) {\n      case RowPartitionType::FIRST_DIM_SIZE:\n        *result = first_partition_tensor.scalar<INDEX_TYPE>()();\n        return Status::OK();\n      case RowPartitionType::VALUE_ROWIDS:\n        return errors::InvalidArgument(\n            \"Cannot handle VALUE_ROWIDS in first dimension.\");\n      case RowPartitionType::ROW_SPLITS:\n        *result = first_partition_tensor.shape().dim_size(0) - 1;\n        return Status::OK();\n      default:\n        return errors::InvalidArgument(\n            \"Cannot handle type \",\n            RowPartitionTypeToString(first_partition_type));\n    }\n  }", "target": 1}
{"code": "int PDFiumEngine::GetMostVisiblePage() {\n   if (in_flight_visible_page_)\n     return *in_flight_visible_page_;\n   CalculateVisiblePages();\n   return most_visible_page_;\n }", "target": 1}
{"code": "TfLiteTensor* GetVariableInput(TfLiteContext* context, const TfLiteNode* node,\n                               int index) {\n  TfLiteTensor* tensor = GetMutableInput(context, node, index);\n  return tensor->is_variable ? tensor : nullptr;\n}", "target": 1}
{"code": "static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)\n{\n \tstruct snd_seq_port_info *info = arg;\n \tstruct snd_seq_client_port *port;\n \tstruct snd_seq_port_callback *callback;\n \tif (info->addr.client != client->number)\n\t\treturn -EPERM;\n\tport = snd_seq_create_port(client, (info->flags & SNDRV_SEQ_PORT_FLG_GIVEN_PORT) ? info->addr.port : -1);\n\tif (port == NULL)\n \t\treturn -ENOMEM;\n \tif (client->type == USER_CLIENT && info->kernel) {\n\t\tsnd_seq_delete_port(client, port->addr.port);\n \t\treturn -EINVAL;\n \t}\n \tif (client->type == KERNEL_CLIENT) {\n\t\tif ((callback = info->kernel) != NULL) {\n\t\t\tif (callback->owner)\n\t\t\t\tport->owner = callback->owner;\n\t\t\tport->private_data = callback->private_data;\n\t\t\tport->private_free = callback->private_free;\n\t\t\tport->event_input = callback->event_input;\n\t\t\tport->c_src.open = callback->subscribe;\n\t\t\tport->c_src.close = callback->unsubscribe;\n\t\t\tport->c_dest.open = callback->use;\n\t\t\tport->c_dest.close = callback->unuse;\n\t\t}\n\t}\n\tinfo->addr = port->addr;\n \tsnd_seq_set_port_info(port, info);\n \tsnd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);\n \treturn 0;\n }", "target": 1}
{"code": "static int list_devices(struct file *filp, struct dm_ioctl *param, size_t param_size)\n{\n\tunsigned int i;\n\tstruct hash_cell *hc;\n\tsize_t len, needed = 0;\n\tstruct gendisk *disk;\n\tstruct dm_name_list *orig_nl, *nl, *old_nl = NULL;\n\tuint32_t *event_nr;\n\tdown_write(&_hash_lock);\n\tfor (i = 0; i < NUM_BUCKETS; i++) {\n\t\tlist_for_each_entry (hc, _name_buckets + i, name_list) {\n\t\t\tneeded += align_val(offsetof(struct dm_name_list, name) + strlen(hc->name) + 1);\n\t\t\tneeded += align_val(sizeof(uint32_t));\n\t\t}\n\t}\n\tnl = orig_nl = get_result_buffer(param, param_size, &len);\n\tif (len < needed) {\n\t\tparam->flags |= DM_BUFFER_FULL_FLAG;\n\t\tgoto out;\n\t}\n\tparam->data_size = param->data_start + needed;\n\tnl->dev = 0;\t\n\tfor (i = 0; i < NUM_BUCKETS; i++) {\n\t\tlist_for_each_entry (hc, _name_buckets + i, name_list) {\n\t\t\tif (old_nl)\n\t\t\t\told_nl->next = (uint32_t) ((void *) nl -\n\t\t\t\t\t\t\t   (void *) old_nl);\n\t\t\tdisk = dm_disk(hc->md);\n\t\t\tnl->dev = huge_encode_dev(disk_devt(disk));\n\t\t\tnl->next = 0;\n\t\t\tstrcpy(nl->name, hc->name);\n\t\t\told_nl = nl;\n\t\t\tevent_nr = align_ptr(nl->name + strlen(hc->name) + 1);\n\t\t\t*event_nr = dm_get_event_nr(hc->md);\n\t\t\tnl = align_ptr(event_nr + 1);\n\t\t}\n\t}\n\tBUG_ON((char *)nl - (char *)orig_nl != needed);\n out:\n\tup_write(&_hash_lock);\n\treturn 0;\n}", "target": 1}
{"code": "int sr_do_ioctl(Scsi_CD *cd, struct packet_command *cgc)\n{\n \tstruct scsi_device *SDev;\n \tstruct scsi_sense_hdr sshdr;\n \tint result, err = 0, retries = 0;\n \tSDev = cd->device;\n       retry:\n \tif (!scsi_block_when_processing_errors(SDev)) {\n \t\terr = -ENODEV;\n \t\tgoto out;\n \t}\n \tresult = scsi_execute(SDev, cgc->cmd, cgc->data_direction,\n\t\t\t      cgc->buffer, cgc->buflen,\n\t\t\t      (unsigned char *)cgc->sense, &sshdr,\n \t\t\t      cgc->timeout, IOCTL_RETRIES, 0, 0, NULL);\n \tif (driver_byte(result) != 0) {\n \t\tswitch (sshdr.sense_key) {\n\t\tcase UNIT_ATTENTION:\n\t\t\tSDev->changed = 1;\n\t\t\tif (!cgc->quiet)\n\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t  \"disc change detected.\\n\");\n\t\t\tif (retries++ < 10)\n\t\t\t\tgoto retry;\n\t\t\terr = -ENOMEDIUM;\n\t\t\tbreak;\n\t\tcase NOT_READY:\t\n\t\t\tif (sshdr.asc == 0x04 &&\n\t\t\t    sshdr.ascq == 0x01) {\n\t\t\t\tif (!cgc->quiet)\n\t\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t\t  \"CDROM not ready yet.\\n\");\n\t\t\t\tif (retries++ < 10) {\n\t\t\t\t\tssleep(2);\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else {\n\t\t\t\t\terr = -ENOMEDIUM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!cgc->quiet)\n\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t  \"CDROM not ready.  Make sure there \"\n\t\t\t\t\t  \"is a disc in the drive.\\n\");\n\t\t\terr = -ENOMEDIUM;\n\t\t\tbreak;\n\t\tcase ILLEGAL_REQUEST:\n\t\t\terr = -EIO;\n\t\t\tif (sshdr.asc == 0x20 &&\n\t\t\t    sshdr.ascq == 0x00)\n\t\t\t\terr = -EDRIVE_CANT_DO_THIS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EIO;\n\t\t}\n\t}\n      out:\n\tcgc->stat = err;\n\treturn err;\n}", "target": 1}
{"code": "bool VariableUnserializer::matchString(folly::StringPiece str) {\n  const char* p = m_buf;\n  assertx(p <= m_end);\n  int total = 0;\n  if (*p == 'S') {\n    total = 2 + 8 + 1;\n    if (p + total > m_end) return false;\n    p++;\n    if (*p++ != ':') return false;\n    auto const sd = *reinterpret_cast<StringData*const*>(p);\n    assertx(sd->isStatic());\n    if (str.compare(sd->slice()) != 0) return false;\n    p += size_t(8);\n  } else {\n    const auto ss = str.size();\n    if (ss >= 100) return false;\n    int digits = ss >= 10 ? 2 : 1;\n    total = 2 + digits + 2 + ss + 2;\n    if (p + total > m_end) return false;\n    if (*p++ != 's') return false;\n    if (*p++ != ':') return false;\n    if (digits == 2) {\n      if (*p++ != '0' + ss/10) return false;\n      if (*p++ != '0' + ss%10) return false;\n    } else {\n      if (*p++ != '0' + ss) return false;\n    }\n    if (*p++ != ':') return false;\n    if (*p++ != '\\\"') return false;\n    if (memcmp(p, str.data(), ss)) return false;\n    p += ss;\n    if (*p++ != '\\\"') return false;\n  }\n  if (*p++ != ';') return false;\n  assertx(m_buf + total == p);\n  m_buf = p;\n  return true;\n}", "target": 1}
{"code": "static int check_stack_boundary(struct bpf_verifier_env *env, int regno,\n\t\t\t\tint access_size, bool zero_size_allowed,\n\t\t\t\tstruct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_verifier_state *state = env->cur_state;\n\tstruct bpf_reg_state *regs = state->regs;\n\tint off, i, slot, spi;\n\tif (regs[regno].type != PTR_TO_STACK) {\n\t\tif (zero_size_allowed && access_size == 0 &&\n\t\t    register_is_null(regs[regno]))\n\t\t\treturn 0;\n\t\tverbose(env, \"R%d type=%s expected=%s\\n\", regno,\n\t\t\treg_type_str[regs[regno].type],\n\t\t\treg_type_str[PTR_TO_STACK]);\n\t\treturn -EACCES;\n\t}\n\tif (!tnum_is_const(regs[regno].var_off)) {\n\t\tchar tn_buf[48];\n \t\ttnum_strn(tn_buf, sizeof(tn_buf), regs[regno].var_off);\n \t\tverbose(env, \"invalid variable stack read R%d var_off=%s\\n\",\n \t\t\tregno, tn_buf);\n \t}\n \toff = regs[regno].off + regs[regno].var_off.value;\n \tif (off >= 0 || off < -MAX_BPF_STACK || off + access_size > 0 ||\n\t    access_size < 0 || (access_size == 0 && !zero_size_allowed)) {\n\t\tverbose(env, \"invalid stack type R%d off=%d access_size=%d\\n\",\n\t\t\tregno, off, access_size);\n\t\treturn -EACCES;\n\t}\n\tif (env->prog->aux->stack_depth < -off)\n\t\tenv->prog->aux->stack_depth = -off;\n\tif (meta && meta->raw_mode) {\n\t\tmeta->access_size = access_size;\n\t\tmeta->regno = regno;\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < access_size; i++) {\n\t\tslot = -(off + i) - 1;\n\t\tspi = slot / BPF_REG_SIZE;\n\t\tif (state->allocated_stack <= slot ||\n\t\t    state->stack[spi].slot_type[slot % BPF_REG_SIZE] !=\n\t\t\tSTACK_MISC) {\n\t\t\tverbose(env, \"invalid indirect read from stack off %d+%d size %d\\n\",\n\t\t\t\toff, i, access_size);\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int decode_zbuf(AVBPrint *bp, const uint8_t *data,\n                       const uint8_t *data_end)\n{\n    z_stream zstream;\n    unsigned char *buf;\n    unsigned buf_size;\n    int ret;\n    zstream.zalloc = ff_png_zalloc;\n    zstream.zfree  = ff_png_zfree;\n    zstream.opaque = NULL;\n    if (inflateInit(&zstream) != Z_OK)\n        return AVERROR_EXTERNAL;\n    zstream.next_in  = (unsigned char *)data;\n    zstream.avail_in = data_end - data;\n     av_bprint_init(bp, 0, -1);\n     while (zstream.avail_in > 0) {\n        av_bprint_get_buffer(bp, 1, &buf, &buf_size);\n        if (!buf_size) {\n             ret = AVERROR(ENOMEM);\n             goto fail;\n         }\n         zstream.next_out  = buf;\n        zstream.avail_out = buf_size;\n         ret = inflate(&zstream, Z_PARTIAL_FLUSH);\n         if (ret != Z_OK && ret != Z_STREAM_END) {\n             ret = AVERROR_EXTERNAL;\n            goto fail;\n        }\n        bp->len += zstream.next_out - buf;\n        if (ret == Z_STREAM_END)\n            break;\n    }\n    inflateEnd(&zstream);\n    bp->str[bp->len] = 0;\n    return 0;\nfail:\n    inflateEnd(&zstream);\n    av_bprint_finalize(bp, NULL);\n    return ret;\n}", "target": 1}
{"code": "int snd_card_disconnect(struct snd_card *card)\n{\n\tstruct snd_monitor_file *mfile;\n\tif (!card)\n\t\treturn -EINVAL;\n\tspin_lock(&card->files_lock);\n\tif (card->shutdown) {\n\t\tspin_unlock(&card->files_lock);\n\t\treturn 0;\n\t}\n\tcard->shutdown = 1;\n\tspin_unlock(&card->files_lock);\n\tmutex_lock(&snd_card_mutex);\n\tsnd_cards[card->number] = NULL;\n\tclear_bit(card->number, snd_cards_lock);\n\tmutex_unlock(&snd_card_mutex);\n\tspin_lock(&card->files_lock);\n\tlist_for_each_entry(mfile, &card->files_list, list) {\n\t\tmfile->disconnected_f_op = mfile->file->f_op;\n\t\tspin_lock(&shutdown_lock);\n\t\tlist_add(&mfile->shutdown_list, &shutdown_files);\n\t\tspin_unlock(&shutdown_lock);\n\t\tmfile->file->f_op = &snd_shutdown_f_ops;\n\t\tfops_get(mfile->file->f_op);\n\t}\n\tspin_unlock(&card->files_lock);\t\n#if IS_ENABLED(CONFIG_SND_MIXER_OSS)\n\tif (snd_mixer_oss_notify_callback)\n\t\tsnd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_DISCONNECT);\n#endif\n\tsnd_device_disconnect_all(card);\n\tsnd_info_card_disconnect(card);\n\tif (card->registered) {\n\t\tdevice_del(&card->card_dev);\n\t\tcard->registered = false;\n\t}\n#ifdef CONFIG_PM\n\twake_up(&card->power_sleep);\n#endif\n\treturn 0;\t\n}", "target": 1}
{"code": "_eddsa_hash (const struct ecc_modulo *m,\n\t     mp_limb_t *rp, size_t digest_size, const uint8_t *digest)\n{\n  mp_size_t nlimbs = (8*digest_size + GMP_NUMB_BITS - 1) / GMP_NUMB_BITS;\n  mpn_set_base256_le (rp, nlimbs, digest, digest_size);\n  if (nlimbs > 2*m->size)\n    {\n      mp_limb_t hi = rp[2*m->size];\n      assert (nlimbs == 2*m->size + 1);\n      hi = mpn_addmul_1 (rp + m->size, m->B, m->size, hi);\n      assert (hi <= 1);\n      hi = mpn_cnd_add_n (hi, rp + m->size, rp + m->size, m->B, m->size);\n      assert (hi == 0);\n    }\n  m->mod (m, rp, rp);\n}", "target": 1}
{"code": "static void construct_get_dest_keyring(struct key **_dest_keyring)\n {\n \tstruct request_key_auth *rka;\n \tconst struct cred *cred = current_cred();\n \tstruct key *dest_keyring = *_dest_keyring, *authkey;\n \tkenter(\"%p\", dest_keyring);\n\tif (dest_keyring) {\n \t\tkey_get(dest_keyring);\n \t} else {\n \t\tswitch (cred->jit_keyring) {\n\t\tcase KEY_REQKEY_DEFL_DEFAULT:\n\t\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\t\tif (cred->request_key_auth) {\n\t\t\t\tauthkey = cred->request_key_auth;\n\t\t\t\tdown_read(&authkey->sem);\n\t\t\t\trka = authkey->payload.data[0];\n\t\t\t\tif (!test_bit(KEY_FLAG_REVOKED,\n\t\t\t\t\t      &authkey->flags))\n \t\t\t\t\tdest_keyring =\n \t\t\t\t\t\tkey_get(rka->dest_keyring);\n \t\t\t\tup_read(&authkey->sem);\n\t\t\t\tif (dest_keyring)\n \t\t\t\t\tbreak;\n \t\t\t}\n \t\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\t\tdest_keyring = key_get(cred->thread_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\t\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\t\tdest_keyring = key_get(cred->process_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\t\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\t\t\trcu_read_lock();\n\t\t\tdest_keyring = key_get(\n\t\t\t\trcu_dereference(cred->session_keyring));\n\t\t\trcu_read_unlock();\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\t\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\t\t\tdest_keyring =\n\t\t\t\tkey_get(cred->user->session_keyring);\n\t\t\tbreak;\n\t\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\t\t\tdest_keyring = key_get(cred->user->uid_keyring);\n\t\t\tbreak;\n\t\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n \t\tdefault:\n \t\t\tBUG();\n \t\t}\n \t}\n \t*_dest_keyring = dest_keyring;\n \tkleave(\" [dk %d]\", key_serial(dest_keyring));\n\treturn;\n }", "target": 1}
{"code": "  Field *get_tmp_table_field() { return 0; }", "target": 1}
{"code": "static int msr_open(struct inode *inode, struct file *file)\n{\n \tunsigned int cpu;\n \tstruct cpuinfo_x86 *c;\n \tcpu = iminor(file->f_path.dentry->d_inode);\n \tif (cpu >= nr_cpu_ids || !cpu_online(cpu))\n \t\treturn -ENXIO;\t\n\tc = &cpu_data(cpu);\n\tif (!cpu_has(c, X86_FEATURE_MSR))\n\t\treturn -EIO;\t\n\treturn 0;\n}", "target": 1}
{"code": "tar_directory_for_file (GsfInfileTar *dir, const char *name, gboolean last)\n{\n\tconst char *s = name;\n\twhile (1) {\n\t\tconst char *s0 = s;\n\t\tchar *dirname;\n\t\twhile (1) {\n\t\t\tif (*s == 0) {\n\t\t\t\tif (last && s != s0)\n\t\t\t\t\tbreak;\n\t\t\t\telse\n\t\t\t\t\treturn dir;\n\t\t\t}\n\t\t\tif (*s == '/')\n\t\t\t\tbreak;\n\t\t\ts++;\n\t\t}\n\t\tdirname = g_strndup (s0, s - s0);\n\t\twhile (*s == '/')\n\t\t\ts++;\n\t\tif (strcmp (dirname, \".\") != 0) {\n\t\t\tGsfInput *subdir =\n \t\t\t\tgsf_infile_child_by_name (GSF_INFILE (dir),\n \t\t\t\t\t\t\t  dirname);\n \t\t\tif (subdir) {\n \t\t\t\tg_object_unref (subdir);\n\t\t\t\tdir = GSF_INFILE_TAR (subdir);\n \t\t\t} else\n \t\t\t\tdir = tar_create_dir (dir, dirname);\n \t\t}\n\t\tg_free (dirname);\n\t}\n}", "target": 1}
{"code": "static int print_media_desc(const pjmedia_sdp_media *m, char *buf, pj_size_t len)\n{\n    char *p = buf;\n    char *end = buf+len;\n    unsigned i;\n    int printed;\n    if (len < (pj_size_t)m->desc.media.slen+m->desc.transport.slen+12+24) {\n\treturn -1;\n    }\n    *p++ = 'm';\t    \n    *p++ = '=';\n    pj_memcpy(p, m->desc.media.ptr, m->desc.media.slen);\n    p += m->desc.media.slen;\n    *p++ = ' ';\n    printed = pj_utoa(m->desc.port, p);\n    p += printed;\n    if (m->desc.port_count > 1) {\n\t*p++ = '/';\n\tprinted = pj_utoa(m->desc.port_count, p);\n\tp += printed;\n    }\n    *p++ = ' ';\n    pj_memcpy(p, m->desc.transport.ptr, m->desc.transport.slen);\n    p += m->desc.transport.slen;\n    for (i=0; i<m->desc.fmt_count; ++i) {\n\t*p++ = ' ';\n\tpj_memcpy(p, m->desc.fmt[i].ptr, m->desc.fmt[i].slen);\n\tp += m->desc.fmt[i].slen;\n    }\n    *p++ = '\\r';\n    *p++ = '\\n';\n    if (m->conn) {\n\tprinted = print_connection_info(m->conn, p, (int)(end-p));\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n    for (i=0; i<m->bandw_count; ++i) {\n\tprinted = (int)print_bandw(m->bandw[i], p, end-p);\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n    for (i=0; i<m->attr_count; ++i) {\n\tprinted = (int)print_attr(m->attr[i], p, end-p);\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n    return (int)(p-buf);\n}", "target": 1}
{"code": "void exit_io_context(void)\n{\n\tstruct io_context *ioc;\n\ttask_lock(current);\n\tioc = current->io_context;\n\tcurrent->io_context = NULL;\n\ttask_unlock(current);\n\tif (atomic_dec_and_test(&ioc->nr_tasks)) {\n\t\tif (ioc->aic && ioc->aic->exit)\n \t\t\tioc->aic->exit(ioc->aic);\n \t\tcfq_exit(ioc);\n\t\tput_io_context(ioc);\n \t}\n }", "target": 1}
{"code": "bool CSPSource::schemeMatches(const KURL& url) const\n {\n     if (m_scheme.isEmpty())\n         return m_policy->protocolMatchesSelf(url);\n     return equalIgnoringCase(url.protocol(), m_scheme);\n }", "target": 1}
{"code": "static int get_pipe(struct stub_device *sdev, int epnum, int dir)\n{\n\tstruct usb_device *udev = sdev->udev;\n\tstruct usb_host_endpoint *ep;\n\tstruct usb_endpoint_descriptor *epd = NULL;\n\tif (dir == USBIP_DIR_IN)\n\t\tep = udev->ep_in[epnum & 0x7f];\n\telse\n\t\tep = udev->ep_out[epnum & 0x7f];\n\tif (!ep) {\n\t\tdev_err(&sdev->udev->dev, \"no such endpoint?, %d\\n\",\n\t\t\tepnum);\n\t\tBUG();\n\t}\n\tepd = &ep->desc;\n\tif (usb_endpoint_xfer_control(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndctrlpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvctrlpipe(udev, epnum);\n\t}\n\tif (usb_endpoint_xfer_bulk(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndbulkpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvbulkpipe(udev, epnum);\n\t}\n\tif (usb_endpoint_xfer_int(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndintpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvintpipe(udev, epnum);\n\t}\n\tif (usb_endpoint_xfer_isoc(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndisocpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvisocpipe(udev, epnum);\n\t}\n\tdev_err(&sdev->udev->dev, \"get pipe, epnum %d\\n\", epnum);\n\treturn 0;\n}", "target": 1}
{"code": "static NTSTATUS fd_open_atomic(struct connection_struct *conn,\n\t\t\tfiles_struct *fsp,\n\t\t\tint flags,\n\t\t\tmode_t mode,\n                        bool *file_created)\n {\n        NTSTATUS status = NT_STATUS_UNSUCCESSFUL;\n        bool file_existed = VALID_STAT(fsp->fsp_name->st);\n        *file_created = false;\n\t\t * We're not creating the file, just pass through.\n\t\t */\n\t\treturn fd_open(conn, fsp, flags, mode);\n\t}", "target": 1}
{"code": "static int hci_sock_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct hci_ufilter uf;\n\tstruct sock *sk = sock->sk;\n\tint len, opt, err = 0;\n\tBT_DBG(\"sk %p, opt %d\", sk, optname);\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tlock_sock(sk);\n\tif (hci_pi(sk)->channel != HCI_CHANNEL_RAW) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\tswitch (optname) {\n\tcase HCI_DATA_DIR:\n\t\tif (hci_pi(sk)->cmsg_mask & HCI_CMSG_DIR)\n\t\t\topt = 1;\n\t\telse\n\t\t\topt = 0;\n\t\tif (put_user(opt, optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase HCI_TIME_STAMP:\n\t\tif (hci_pi(sk)->cmsg_mask & HCI_CMSG_TSTAMP)\n\t\t\topt = 1;\n\t\telse\n\t\t\topt = 0;\n\t\tif (put_user(opt, optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase HCI_FILTER:\n \t\t{\n \t\t\tstruct hci_filter *f = &hci_pi(sk)->filter;\n \t\t\tuf.type_mask = f->type_mask;\n \t\t\tuf.opcode    = f->opcode;\n \t\t\tuf.event_mask[0] = *((u32 *) f->event_mask + 0);\n\t\t\tuf.event_mask[1] = *((u32 *) f->event_mask + 1);\n\t\t}\n\t\tlen = min_t(unsigned int, len, sizeof(uf));\n\t\tif (copy_to_user(optval, &uf, len))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\ndone:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 1}
{"code": "static int calcstepsizes(uint_fast16_t refstepsize, int numrlvls,\n  uint_fast16_t *stepsizes)\n{\n\tint bandno;\n\tint numbands;\n\tuint_fast16_t expn;\n\tuint_fast16_t mant;\n\texpn = JPC_QCX_GETEXPN(refstepsize);\n\tmant = JPC_QCX_GETMANT(refstepsize);\n\tnumbands = 3 * numrlvls - 2;\n\tfor (bandno = 0; bandno < numbands; ++bandno) {\n\t\tstepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn + (bandno + 2) / 3);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "process_bitmap_updates(STREAM s)\n {\n\tuint16 num_updates;\n \tuint16 left, top, right, bottom, width, height;\n\tuint16 cx, cy, bpp, Bpp, compress, bufsize, size;\n \tuint8 *data, *bmpdata;\n\tint i;\n \tlogger(Protocol, Debug, \"%s()\", __func__);\n\tin_uint16_le(s, num_updates);\n\tfor (i = 0; i < num_updates; i++)\n\t{\n\t\tin_uint16_le(s, left);\n\t\tin_uint16_le(s, top);\n\t\tin_uint16_le(s, right);\n\t\tin_uint16_le(s, bottom);\n\t\tin_uint16_le(s, width);\n\t\tin_uint16_le(s, height);\n\t\tin_uint16_le(s, bpp);\n\t\tBpp = (bpp + 7) / 8;\n\t\tin_uint16_le(s, compress);\n\t\tin_uint16_le(s, bufsize);\n\t\tcx = right - left + 1;\n\t\tcy = bottom - top + 1;\n\t\tlogger(Graphics, Debug,\n\t\t       \"process_bitmap_updates(), [%d,%d,%d,%d], [%d,%d], bpp=%d, compression=%d\",\n\t\t       left, top, right, bottom, width, height, Bpp, compress);\n\t\tif (!compress)\n\t\t{\n\t\t\tint y;\n\t\t\tbmpdata = (uint8 *) xmalloc(width * height * Bpp);\n\t\t\tfor (y = 0; y < height; y++)\n\t\t\t{\n\t\t\t\tin_uint8a(s, &bmpdata[(height - y - 1) * (width * Bpp)],\n\t\t\t\t\t  width * Bpp);\n\t\t\t}\n\t\t\tui_paint_bitmap(left, top, cx, cy, width, height, bmpdata);\n\t\t\txfree(bmpdata);\n\t\t\tcontinue;\n\t\t}\n\t\tif (compress & 0x400)\n\t\t{\n\t\t\tsize = bufsize;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tin_uint8s(s, 2);\t\n\t\t\tin_uint16_le(s, size);\n\t\t\tin_uint8s(s, 4);\t\n\t\t}\n\t\tin_uint8p(s, data, size);\n \t\tbmpdata = (uint8 *) xmalloc(width * height * Bpp);\n\t\tif (bitmap_decompress(bmpdata, width, height, data, size, Bpp))\n \t\t{\n\t\t\tui_paint_bitmap(left, top, cx, cy, width, height, bmpdata);\n \t\t}\n\t\telse\n\t\t{\n\t\t\tlogger(Graphics, Warning,\n\t\t\t       \"process_bitmap_updates(), failed to decompress bitmap\");\n\t\t}\n \t\txfree(bmpdata);\n \t}\n }", "target": 1}
{"code": "static int netlink_dump(struct sock *sk)\n{\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n \tstruct netlink_callback *cb;\n \tstruct sk_buff *skb = NULL;\n \tstruct nlmsghdr *nlh;\n \tint len, err = -ENOBUFS;\n \tint alloc_min_size;\n \tint alloc_size;\n\tmutex_lock(nlk->cb_mutex);\n\tif (!nlk->cb_running) {\n\t\terr = -EINVAL;\n\t\tgoto errout_skb;\n\t}\n\tif (atomic_read(&sk->sk_rmem_alloc) >= sk->sk_rcvbuf)\n\t\tgoto errout_skb;\n\tcb = &nlk->cb;\n\talloc_min_size = max_t(int, cb->min_dump_alloc, NLMSG_GOODSIZE);\n\tif (alloc_min_size < nlk->max_recvmsg_len) {\n\t\talloc_size = nlk->max_recvmsg_len;\n\t\tskb = alloc_skb(alloc_size, GFP_KERNEL |\n\t\t\t\t\t    __GFP_NOWARN | __GFP_NORETRY);\n\t}\n\tif (!skb) {\n\t\talloc_size = alloc_min_size;\n\t\tskb = alloc_skb(alloc_size, GFP_KERNEL);\n\t}\n\tif (!skb)\n\t\tgoto errout_skb;\n\tskb_reserve(skb, skb_tailroom(skb) - alloc_size);\n\tnetlink_skb_set_owner_r(skb, sk);\n\tlen = cb->dump(skb, cb);\n\tif (len > 0) {\n\t\tmutex_unlock(nlk->cb_mutex);\n\t\tif (sk_filter(sk, skb))\n\t\t\tkfree_skb(skb);\n\t\telse\n\t\t\t__netlink_sendskb(sk, skb);\n\t\treturn 0;\n\t}\n\tnlh = nlmsg_put_answer(skb, cb, NLMSG_DONE, sizeof(len), NLM_F_MULTI);\n\tif (!nlh)\n\t\tgoto errout_skb;\n\tnl_dump_check_consistent(cb, nlh);\n\tmemcpy(nlmsg_data(nlh), &len, sizeof(len));\n\tif (sk_filter(sk, skb))\n\t\tkfree_skb(skb);\n\telse\n\t\t__netlink_sendskb(sk, skb);\n\tif (cb->done)\n \t\tcb->done(cb);\n \tnlk->cb_running = false;\n \tmutex_unlock(nlk->cb_mutex);\n\tmodule_put(cb->module);\n\tconsume_skb(cb->skb);\n \treturn 0;\n errout_skb:\n\tmutex_unlock(nlk->cb_mutex);\n\tkfree_skb(skb);\n\treturn err;\n}", "target": 1}
{"code": "gboolean textview_uri_security_check(TextView *textview, ClickableText *uri)\n{\n\tgchar *visible_str;\n\tgboolean retval = TRUE;\n\tif (is_uri_string(uri->uri) == FALSE)\n\t\treturn TRUE;\n\tvisible_str = textview_get_visible_uri(textview, uri);\n\tif (visible_str == NULL)\n\t\treturn TRUE;\n\tg_strstrip(visible_str);\n\tif (strcmp(visible_str, uri->uri) != 0 && is_uri_string(visible_str)) {\n\t\tgchar *uri_path;\n\t\tgchar *visible_uri_path;\n\t\turi_path = get_uri_path(uri->uri);\n\t\tvisible_uri_path = get_uri_path(visible_str);\n\t\tif (path_cmp(uri_path, visible_uri_path) != 0)\n\t\t\tretval = FALSE;\n\t}\n\tif (retval == FALSE) {\n\t\tgchar *msg;\n\t\tAlertValue aval;\n\t\tmsg = g_markup_printf_escaped(\"%s\\n\\n\"\n\t\t\t\t\t\t\"<b>%s</b> %s\\n\\n\"\n\t\t\t\t\t\t\"<b>%s</b> %s\\n\\n\"\n\t\t\t\t\t\t\"%s\",\n\t\t\t\t\t\t_(\"The real URL is different from the displayed URL.\"),\n\t\t\t\t\t\t_(\"Displayed URL:\"), visible_str,\n\t\t\t\t\t\t_(\"Real URL:\"), uri->uri,\n\t\t\t\t\t\t_(\"Open it anyway?\"));\n\t\taval = alertpanel_full(_(\"Phishing attempt warning\"), msg,\n\t\t\t\t       GTK_STOCK_CANCEL, _(\"_Open URL\"), NULL, ALERTFOCUS_FIRST,\n\t\t\t\t\t\t\t FALSE, NULL, ALERT_WARNING);\n\t\tg_free(msg);\n\t\tif (aval == G_ALERTALTERNATE)\n\t\t\tretval = TRUE;\n\t}\n\tg_free(visible_str);\n\treturn retval;\n}", "target": 1}
{"code": "int am_generate_random_bytes(request_rec *r, void *dest, apr_size_t count)\n{\n    int rc;\n    rc = RAND_pseudo_bytes((unsigned char *)dest, (int)count);\n    if(rc == -1) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Error generating random data: %lu\",\n                      ERR_get_error());\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n    if(rc == 0) {\n        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,\n                      \"Random data is not cryptographically strong.\");\n    }\n    return OK;\n}", "target": 1}
{"code": "inline bool ResolveAxis(const int num_dims, const int* axis,\n                        const int64_t num_axis, int* out_axis,\n                        int* out_num_axis) {\n  *out_num_axis = 0;  \n  if (num_dims == 0) {\n    return true;\n  }\n  for (int64_t idx = 0; idx < num_axis; ++idx) {\n    int current = axis[idx] < 0 ? (axis[idx] + num_dims) : axis[idx];\n    TFLITE_DCHECK(current >= 0 && current < num_dims);\n    bool is_dup = false;\n    for (int j = 0; j < *out_num_axis; ++j) {\n      if (out_axis[j] == current) {\n        is_dup = true;\n        break;\n      }\n    }\n    if (!is_dup) {\n      out_axis[*out_num_axis] = current;\n      *out_num_axis += 1;\n    }\n  }\n  return true;\n}", "target": 1}
{"code": "main_get_appheader (xd3_stream *stream, main_file *ifile,\n\t\t    main_file *output, main_file *sfile)\n{\n  uint8_t *apphead;\n  usize_t appheadsz;\n  int ret;\n  if (! option_use_appheader) { return; }\n  ret = xd3_get_appheader (stream, & apphead, & appheadsz);\n  if (ret != 0) { return; }\n  if (appheadsz > 0)\n    {\n      char *start = (char*)apphead;\n      char *slash;\n      int   place = 0;\n      char *parsed[4];\n      memset (parsed, 0, sizeof (parsed));\n      while ((slash = strchr (start, '/')) != NULL)\n\t{\n\t  *slash = 0;\n\t  parsed[place++] = start;\n\t  start = slash + 1;\n\t}\n      parsed[place++] = start;\n      if (place == 2 || place == 4)\n\t{\n\t  main_get_appheader_params (output, parsed, 1, \"output\", ifile);\n\t}\n      if (place == 4)\n\t{\n\t  main_get_appheader_params (sfile, parsed+2, 0, \"source\", ifile);\n\t}\n    }\n  option_use_appheader = 0;\n  return;\n}", "target": 1}
{"code": "int GENERAL_NAME_cmp(GENERAL_NAME *a, GENERAL_NAME *b)\n{\n    int result = -1;\n    if (!a || !b || a->type != b->type)\n        return -1;\n    switch (a->type) {\n    case GEN_X400:\n    case GEN_EDIPARTY:\n        result = ASN1_TYPE_cmp(a->d.other, b->d.other);\n        break;\n    case GEN_OTHERNAME:\n        result = OTHERNAME_cmp(a->d.otherName, b->d.otherName);\n        break;\n    case GEN_EMAIL:\n    case GEN_DNS:\n    case GEN_URI:\n        result = ASN1_STRING_cmp(a->d.ia5, b->d.ia5);\n        break;\n    case GEN_DIRNAME:\n        result = X509_NAME_cmp(a->d.dirn, b->d.dirn);\n        break;\n    case GEN_IPADD:\n        result = ASN1_OCTET_STRING_cmp(a->d.ip, b->d.ip);\n        break;\n    case GEN_RID:\n        result = OBJ_cmp(a->d.rid, b->d.rid);\n        break;\n    }\n    return result;\n}", "target": 1}
{"code": " static int mct_u232_port_probe(struct usb_serial_port *port)\n {\n \tstruct mct_u232_private *priv;\n \tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n \tif (!priv)\n \t\treturn -ENOMEM;\n\tpriv->read_urb = port->serial->port[1]->interrupt_in_urb;\n \tpriv->read_urb->context = port;\n \tspin_lock_init(&priv->lock);\n\tusb_set_serial_port_data(port, priv);\n\treturn 0;\n}", "target": 1}
{"code": "static __be32 nfsacld_proc_setacl(struct svc_rqst * rqstp,\n\t\tstruct nfsd3_setaclargs *argp,\n\t\tstruct nfsd_attrstat *resp)\n{\n\tstruct inode *inode;\n\tsvc_fh *fh;\n\t__be32 nfserr = 0;\n\tint error;\n\tdprintk(\"nfsd: SETACL(2acl)   %s\\n\", SVCFH_fmt(&argp->fh));\n\tfh = fh_copy(&resp->fh, &argp->fh);\n\tnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);\n\tif (nfserr)\n \t\tgoto out;\n \tinode = d_inode(fh->fh_dentry);\n\tif (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {\n\t\terror = -EOPNOTSUPP;\n\t\tgoto out_errno;\n\t}\n \terror = fh_want_write(fh);\n \tif (error)\n \t\tgoto out_errno;\n\terror = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);\n \tif (error)\n\t\tgoto out_drop_write;\n\terror = inode->i_op->set_acl(inode, argp->acl_default,\n\t\t\t\t     ACL_TYPE_DEFAULT);\n \tif (error)\n\t\tgoto out_drop_write;\n \tfh_drop_write(fh);\n\tnfserr = fh_getattr(fh, &resp->stat);\nout:\n \tposix_acl_release(argp->acl_access);\n \tposix_acl_release(argp->acl_default);\n \treturn nfserr;\nout_drop_write:\n \tfh_drop_write(fh);\n out_errno:\n \tnfserr = nfserrno(error);\n\tgoto out;\n}", "target": 1}
{"code": "int sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,\n\t\t\t size_t sec_attr_len)\n{\n\tu8 *tmp;\n\tif (!sc_file_valid(file)) {\n \t\treturn SC_ERROR_INVALID_ARGUMENTS;\n \t}\n\tif (sec_attr == NULL) {\n \t\tif (file->sec_attr != NULL)\n \t\t\tfree(file->sec_attr);\n \t\tfile->sec_attr = NULL;\n\t\tfile->sec_attr_len = 0;\n\t\treturn 0;\n\t }\n\ttmp = (u8 *) realloc(file->sec_attr, sec_attr_len);\n\tif (!tmp) {\n\t\tif (file->sec_attr)\n\t\t\tfree(file->sec_attr);\n\t\tfile->sec_attr     = NULL;\n\t\tfile->sec_attr_len = 0;\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t}\n\tfile->sec_attr = tmp;\n\tmemcpy(file->sec_attr, sec_attr, sec_attr_len);\n\tfile->sec_attr_len = sec_attr_len;\n\treturn 0;\n}", "target": 1}
{"code": "ssize_t enc_untrusted_read(int fd, void *buf, size_t count) {\n  return static_cast<ssize_t>(EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_read, fd, buf, count));\n}", "target": 1}
{"code": "void jfs_evict_inode(struct inode *inode)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\tjfs_info(\"In jfs_evict_inode, inode = 0x%p\", inode);\n\tif (!inode->i_nlink && !is_bad_inode(inode)) {\n\t\tdquot_initialize(inode);\n\t\tif (JFS_IP(inode)->fileset == FILESYSTEM_I) {\n\t\t\ttruncate_inode_pages_final(&inode->i_data);\n\t\t\tif (test_cflag(COMMIT_Freewmap, inode))\n\t\t\t\tjfs_free_zero_link(inode);\n\t\t\tif (JFS_SBI(inode->i_sb)->ipimap)\n\t\t\t\tdiFree(inode);\n\t\t\tdquot_free_inode(inode);\n\t\t}\n\t} else {\n\t\ttruncate_inode_pages_final(&inode->i_data);\n\t}\n\tclear_inode(inode);\n\tdquot_drop(inode);\n\tBUG_ON(!list_empty(&ji->anon_inode_list));\n\tspin_lock_irq(&ji->ag_lock);\n\tif (ji->active_ag != -1) {\n\t\tstruct bmap *bmap = JFS_SBI(inode->i_sb)->bmap;\n\t\tatomic_dec(&bmap->db_active[ji->active_ag]);\n\t\tji->active_ag = -1;\n\t}\n\tspin_unlock_irq(&ji->ag_lock);\n}", "target": 1}
{"code": "static int cqspi_setup_flash(struct cqspi_st *cqspi, struct device_node *np)\n{\n\tstruct platform_device *pdev = cqspi->pdev;\n\tstruct device *dev = &pdev->dev;\n\tstruct cqspi_flash_pdata *f_pdata;\n\tstruct spi_nor *nor;\n\tstruct mtd_info *mtd;\n\tunsigned int cs;\n\tint i, ret;\n\tfor_each_available_child_of_node(dev->of_node, np) {\n\t\tif (of_property_read_u32(np, \"reg\", &cs)) {\n\t\t\tdev_err(dev, \"Couldn't determine chip select.\\n\");\n \t\t\tgoto err;\n \t\t}\n\t\tif (cs > CQSPI_MAX_CHIPSELECT) {\n \t\t\tdev_err(dev, \"Chip select %d out of range.\\n\", cs);\n \t\t\tgoto err;\n \t\t}\n\t\tf_pdata = &cqspi->f_pdata[cs];\n\t\tf_pdata->cqspi = cqspi;\n\t\tf_pdata->cs = cs;\n\t\tret = cqspi_of_get_flash_pdata(pdev, f_pdata, np);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tnor = &f_pdata->nor;\n\t\tmtd = &nor->mtd;\n\t\tmtd->priv = nor;\n\t\tnor->dev = dev;\n\t\tspi_nor_set_flash_node(nor, np);\n\t\tnor->priv = f_pdata;\n\t\tnor->read_reg = cqspi_read_reg;\n\t\tnor->write_reg = cqspi_write_reg;\n\t\tnor->read = cqspi_read;\n\t\tnor->write = cqspi_write;\n\t\tnor->erase = cqspi_erase;\n\t\tnor->prepare = cqspi_prep;\n\t\tnor->unprepare = cqspi_unprep;\n\t\tmtd->name = devm_kasprintf(dev, GFP_KERNEL, \"%s.%d\",\n\t\t\t\t\t   dev_name(dev), cs);\n\t\tif (!mtd->name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tret = spi_nor_scan(nor, NULL, SPI_NOR_QUAD);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = mtd_device_register(mtd, NULL, 0);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tf_pdata->registered = true;\n\t}\n\treturn 0;\nerr:\n\tfor (i = 0; i < CQSPI_MAX_CHIPSELECT; i++)\n\t\tif (cqspi->f_pdata[i].registered)\n\t\t\tmtd_device_unregister(&cqspi->f_pdata[i].nor.mtd);\n\treturn ret;\n}", "target": 1}
{"code": "rdpBitmapCache* bitmap_cache_new(rdpSettings* settings)\n{\n\tint i;\n\trdpBitmapCache* bitmapCache;\n\tbitmapCache = (rdpBitmapCache*)calloc(1, sizeof(rdpBitmapCache));\n\tif (!bitmapCache)\n\t\treturn NULL;\n\tbitmapCache->settings = settings;\n\tbitmapCache->update = ((freerdp*)settings->instance)->update;\n\tbitmapCache->context = bitmapCache->update->context;\n\tbitmapCache->maxCells = settings->BitmapCacheV2NumCells;\n\tbitmapCache->cells = (BITMAP_V2_CELL*)calloc(bitmapCache->maxCells, sizeof(BITMAP_V2_CELL));\n\tif (!bitmapCache->cells)\n\t\tgoto fail;\n\tfor (i = 0; i < (int)bitmapCache->maxCells; i++)\n\t{\n\t\tbitmapCache->cells[i].number = settings->BitmapCacheV2CellInfo[i].numEntries;\n\t\tbitmapCache->cells[i].entries =\n\t\t    (rdpBitmap**)calloc((bitmapCache->cells[i].number + 1), sizeof(rdpBitmap*));\n\t\tif (!bitmapCache->cells[i].entries)\n\t\t\tgoto fail;\n\t}\n\treturn bitmapCache;\nfail:\n\tif (bitmapCache->cells)\n\t{\n\t\tfor (i = 0; i < (int)bitmapCache->maxCells; i++)\n\t\t\tfree(bitmapCache->cells[i].entries);\n\t}\n\tfree(bitmapCache);\n\treturn NULL;\n}", "target": 1}
{"code": "otError Commissioner::GeneratePskc(const char *              aPassPhrase,\n                                   const char *              aNetworkName,\n                                   const Mac::ExtendedPanId &aExtPanId,\n                                   Pskc &                    aPskc)\n{\n    otError     error      = OT_ERROR_NONE;\n    const char *saltPrefix = \"Thread\";\n    uint8_t     salt[OT_PBKDF2_SALT_MAX_LEN];\n    uint16_t    saltLen = 0;\n    VerifyOrExit((strlen(aPassPhrase) >= OT_COMMISSIONING_PASSPHRASE_MIN_SIZE) &&\n                     (strlen(aPassPhrase) <= OT_COMMISSIONING_PASSPHRASE_MAX_SIZE) &&\n                     (strlen(aNetworkName) <= OT_NETWORK_NAME_MAX_SIZE),\n                 error = OT_ERROR_INVALID_ARGS);\n    memset(salt, 0, sizeof(salt));\n    memcpy(salt, saltPrefix, strlen(saltPrefix));\n    saltLen += static_cast<uint16_t>(strlen(saltPrefix));\n    memcpy(salt + saltLen, aExtPanId.m8, sizeof(aExtPanId));\n    saltLen += OT_EXT_PAN_ID_SIZE;\n    memcpy(salt + saltLen, aNetworkName, strlen(aNetworkName));\n    saltLen += static_cast<uint16_t>(strlen(aNetworkName));\n    otPbkdf2Cmac(reinterpret_cast<const uint8_t *>(aPassPhrase), static_cast<uint16_t>(strlen(aPassPhrase)),\n                 reinterpret_cast<const uint8_t *>(salt), saltLen, 16384, OT_PSKC_MAX_SIZE, aPskc.m8);\nexit:\n    return error;\n}", "target": 1}
{"code": "int copy_creds(struct task_struct *p, unsigned long clone_flags)\n{\n#ifdef CONFIG_KEYS\n\tstruct thread_group_cred *tgcred;\n#endif\n \tstruct cred *new;\n \tint ret;\n \tif (\n #ifdef CONFIG_KEYS\n \t\t!p->cred->thread_keyring &&\n#endif\n\t\tclone_flags & CLONE_THREAD\n\t    ) {\n\t\tp->real_cred = get_cred(p->cred);\n\t\tget_cred(p->cred);\n\t\talter_cred_subscribers(p->cred, 2);\n\t\tkdebug(\"share_creds(%p{%d,%d})\",\n\t\t       p->cred, atomic_read(&p->cred->usage),\n\t\t       read_cred_subscribers(p->cred));\n\t\tatomic_inc(&p->cred->user->processes);\n\t\treturn 0;\n\t}\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tif (clone_flags & CLONE_NEWUSER) {\n\t\tret = create_user_ns(new);\n\t\tif (ret < 0)\n\t\t\tgoto error_put;\n\t}\n\tnew->user_ns = new->user->user_ns;\n#ifdef CONFIG_KEYS\n\tif (new->thread_keyring) {\n\t\tkey_put(new->thread_keyring);\n\t\tnew->thread_keyring = NULL;\n\t\tif (clone_flags & CLONE_THREAD)\n\t\t\tinstall_thread_keyring_to_cred(new);\n\t}\n\tif (!(clone_flags & CLONE_THREAD)) {\n\t\ttgcred = kmalloc(sizeof(*tgcred), GFP_KERNEL);\n\t\tif (!tgcred) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error_put;\n\t\t}\n\t\tatomic_set(&tgcred->usage, 1);\n\t\tspin_lock_init(&tgcred->lock);\n\t\ttgcred->process_keyring = NULL;\n\t\ttgcred->session_keyring = key_get(new->tgcred->session_keyring);\n\t\trelease_tgcred(new);\n\t\tnew->tgcred = tgcred;\n\t}\n#endif\n\tatomic_inc(&new->user->processes);\n\tp->cred = p->real_cred = get_cred(new);\n\talter_cred_subscribers(new, 2);\n\tvalidate_creds(new);\n\treturn 0;\nerror_put:\n\tput_cred(new);\n\treturn ret;\n}", "target": 1}
{"code": "void rds6_inc_info_copy(struct rds_incoming *inc,\n\t\t\tstruct rds_info_iterator *iter,\n\t\t\tstruct in6_addr *saddr, struct in6_addr *daddr,\n\t\t\tint flip)\n{\n\tstruct rds6_info_message minfo6;\n \tminfo6.seq = be64_to_cpu(inc->i_hdr.h_sequence);\n \tminfo6.len = be32_to_cpu(inc->i_hdr.h_len);\n \tif (flip) {\n \t\tminfo6.laddr = *daddr;\n\t\tminfo6.faddr = *saddr;\n\t\tminfo6.lport = inc->i_hdr.h_dport;\n\t\tminfo6.fport = inc->i_hdr.h_sport;\n\t} else {\n\t\tminfo6.laddr = *saddr;\n\t\tminfo6.faddr = *daddr;\n\t\tminfo6.lport = inc->i_hdr.h_sport;\n \t\tminfo6.fport = inc->i_hdr.h_dport;\n \t}\n \trds_info_copy(iter, &minfo6, sizeof(minfo6));\n }", "target": 1}
{"code": "static ssize_t clusterip_proc_write(struct file *file, const char __user *input,\n\t\t\t\tsize_t size, loff_t *ofs)\n{\n\tstruct clusterip_config *c = PDE(file->f_path.dentry->d_inode)->data;\n#define PROC_WRITELEN\t10\n\tchar buffer[PROC_WRITELEN+1];\n\tunsigned long nodenum;\n\tif (copy_from_user(buffer, input, PROC_WRITELEN))\n\t\treturn -EFAULT;\n\tif (*buffer == '+') {\n\t\tnodenum = simple_strtoul(buffer+1, NULL, 10);\n\t\tif (clusterip_add_node(c, nodenum))\n\t\t\treturn -ENOMEM;\n\t} else if (*buffer == '-') {\n\t\tnodenum = simple_strtoul(buffer+1, NULL,10);\n\t\tif (clusterip_del_node(c, nodenum))\n\t\t\treturn -ENOENT;\n\t} else\n\t\treturn -EIO;\n\treturn size;\n}", "target": 1}
{"code": " static int mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt)\n {\n\tstruct serial_icounter_struct icount;\n \tstruct sb_uart_icount cnow;\n \tstruct sb_uart_port *port = state->port;\n\tspin_lock_irq(&port->lock);\n\tmemcpy(&cnow, &port->icount, sizeof(struct sb_uart_icount));\n\tspin_unlock_irq(&port->lock);\n\ticount.cts         = cnow.cts;\n\ticount.dsr         = cnow.dsr;\n\ticount.rng         = cnow.rng;\n\ticount.dcd         = cnow.dcd;\n\ticount.rx          = cnow.rx;\n\ticount.tx          = cnow.tx;\n\ticount.frame       = cnow.frame;\n\ticount.overrun     = cnow.overrun;\n\ticount.parity      = cnow.parity;\n\ticount.brk         = cnow.brk;\n\ticount.buf_overrun = cnow.buf_overrun;\n\treturn copy_to_user(icnt, &icount, sizeof(icount)) ? -EFAULT : 0;\n}", "target": 1}
{"code": "PassRefPtr<Attr> Element::setAttributeNode(Attr* attrNode, ExceptionCode& ec)\n{\n    if (!attrNode) {\n        ec = TYPE_MISMATCH_ERR;\n        return 0;\n    }\n    RefPtr<Attr> oldAttrNode = attrIfExists(attrNode->qualifiedName());\n    if (oldAttrNode.get() == attrNode)\n        return attrNode; \n    if (attrNode->ownerElement()) {\n        ec = INUSE_ATTRIBUTE_ERR;\n        return 0;\n    }\n    synchronizeAllAttributes();\n    UniqueElementData* elementData = ensureUniqueElementData();\n    size_t index = elementData->getAttributeItemIndex(attrNode->qualifiedName());\n    if (index != notFound) {\n        if (oldAttrNode)\n            detachAttrNodeFromElementWithValue(oldAttrNode.get(), elementData->attributeItem(index)->value());\n        else\n            oldAttrNode = Attr::create(document(), attrNode->qualifiedName(), elementData->attributeItem(index)->value());\n    }\n     setAttributeInternal(index, attrNode->qualifiedName(), attrNode->value(), NotInSynchronizationOfLazyAttribute);\n     attrNode->attachToElement(this);\n     ensureAttrNodeListForElement(this)->append(attrNode);\n     return oldAttrNode.release();\n}", "target": 1}
{"code": "ProcDbeGetVisualInfo(ClientPtr client)\n{\n    REQUEST(xDbeGetVisualInfoReq);\n    DbeScreenPrivPtr pDbeScreenPriv;\n    xDbeGetVisualInfoReply rep;\n    Drawable *drawables;\n    DrawablePtr *pDrawables = NULL;\n    register int i, j, rc;\n    register int count;         \n    register int length;        \n    ScreenPtr pScreen;\n     XdbeScreenVisualInfo *pScrVisInfo;\n     REQUEST_AT_LEAST_SIZE(xDbeGetVisualInfoReq);\n     if (stuff->n > UINT32_MAX / sizeof(DrawablePtr))\n         return BadAlloc;\n            return BadAlloc;\n        }", "target": 1}
{"code": "\tvoid initialize(const string &path, bool owner) {\n\t\tTRACE_POINT();\n\t\tthis->path  = path;\n\t\tthis->owner = owner;\n\t\tmakeDirTree(path, \"u=rwx,g=rx,o=rx\");\n\t}", "target": 1}
{"code": "R_API void r_anal_bb_free(RAnalBlock *bb) {\n\tif (!bb) {\n\t\treturn;\n\t}\n\tr_anal_cond_free (bb->cond);\n\tR_FREE (bb->fingerprint);\n\tr_anal_diff_free (bb->diff);\n\tbb->diff = NULL;\n\tR_FREE (bb->op_bytes);\n\tr_anal_switch_op_free (bb->switch_op);\n\tbb->switch_op = NULL;\n\tbb->fingerprint = NULL;\n\tbb->cond = NULL;\n\tR_FREE (bb->label);\n\tR_FREE (bb->op_pos);\n\tR_FREE (bb->parent_reg_arena);\n\tif (bb->prev) {\n\t\tif (bb->prev->jumpbb == bb) {\n\t\t\tbb->prev->jumpbb = NULL;\n\t\t}\n\t\tif (bb->prev->failbb == bb) {\n\t\t\tbb->prev->failbb = NULL;\n\t\t}\n\t\tbb->prev = NULL;\n\t}\n\tif (bb->jumpbb) {\n\t\tbb->jumpbb->prev = NULL;\n\t\tbb->jumpbb = NULL;\n\t}\n\tif (bb->failbb) {\n \t\tbb->failbb->prev = NULL;\n \t\tbb->failbb = NULL;\n \t}\n\tR_FREE (bb);\n }", "target": 1}
{"code": "static void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tstruct sock *sk;\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tsk = s->sk;\n\t\t\tsock_hold(sk);\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(sk);\n\t\t\ts->ax25_dev = NULL;\n\t\t\tax25_dev_put(ax25_dev);\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tsock_put(sk);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}", "target": 1}
{"code": "ssize_t enc_untrusted_recvmsg(int sockfd, struct msghdr *msg, int flags) {\n  size_t total_buffer_size = CalculateTotalMessageSize(msg);\n  MessageWriter input;\n  input.Push(sockfd);\n  input.Push<uint64_t>(msg->msg_namelen);\n  input.Push<uint64_t>(total_buffer_size);\n  input.Push<uint64_t>(msg->msg_controllen);\n  input.Push(msg->msg_flags);\n  input.Push(flags);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kRecvMsgHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_recvmsg\", 2,\n                           false);\n  ssize_t result = output.next<ssize_t>();\n  int klinux_errno = output.next<int>();\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n  auto msg_name_extent = output.next();\n  if (msg_name_extent.size() <= msg->msg_namelen) {\n    msg->msg_namelen = msg_name_extent.size();\n  }\n  memcpy(msg->msg_name, msg_name_extent.As<char>(), msg->msg_namelen);\n  auto msg_iov_extent = output.next();\n  size_t total_bytes = msg_iov_extent.size();\n  size_t bytes_copied = 0;\n  for (int i = 0; i < msg->msg_iovlen && bytes_copied < total_bytes; ++i) {\n    size_t bytes_to_copy =\n        std::min(msg->msg_iov[i].iov_len, total_bytes - bytes_copied);\n    memcpy(msg->msg_iov[i].iov_base, msg_iov_extent.As<char>() + bytes_copied,\n           bytes_to_copy);\n    bytes_copied += bytes_to_copy;\n  }\n  auto msg_control_extent = output.next();\n  if (msg_control_extent.size() <= msg->msg_controllen) {\n    msg->msg_controllen = msg_control_extent.size();\n  }\n  memcpy(msg->msg_control, msg_control_extent.As<char>(), msg->msg_controllen);\n  return result;\n}", "target": 1}
{"code": "void bpf_int_jit_compile(struct bpf_prog *prog)\n{\n\tstruct bpf_binary_header *header = NULL;\n\tint proglen, oldproglen = 0;\n\tstruct jit_context ctx = {};\n\tu8 *image = NULL;\n\tint *addrs;\n\tint pass;\n\tint i;\n\tif (!bpf_jit_enable)\n\t\treturn;\n\tif (!prog || !prog->len)\n\t\treturn;\n\taddrs = kmalloc(prog->len * sizeof(*addrs), GFP_KERNEL);\n\tif (!addrs)\n\t\treturn;\n\tfor (proglen = 0, i = 0; i < prog->len; i++) {\n\t\tproglen += 64;\n\t\taddrs[i] = proglen;\n \t}\n \tctx.cleanup_addr = proglen;\n\tfor (pass = 0; pass < 10; pass++) {\n \t\tproglen = do_jit(prog, addrs, image, oldproglen, &ctx);\n \t\tif (proglen <= 0) {\n \t\t\timage = NULL;\n\t\t\tif (header)\n\t\t\t\tbpf_jit_binary_free(header);\n\t\t\tgoto out;\n\t\t}\n\t\tif (image) {\n\t\t\tif (proglen != oldproglen) {\n\t\t\t\tpr_err(\"bpf_jit: proglen=%d != oldproglen=%d\\n\",\n\t\t\t\t       proglen, oldproglen);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (proglen == oldproglen) {\n\t\t\theader = bpf_jit_binary_alloc(proglen, &image,\n\t\t\t\t\t\t      1, jit_fill_hole);\n\t\t\tif (!header)\n\t\t\t\tgoto out;\n\t\t}\n\t\toldproglen = proglen;\n\t}\n\tif (bpf_jit_enable > 1)\n\t\tbpf_jit_dump(prog->len, proglen, 0, image);\n\tif (image) {\n\t\tbpf_flush_icache(header, image + proglen);\n\t\tset_memory_ro((unsigned long)header, header->pages);\n\t\tprog->bpf_func = (void *)image;\n\t\tprog->jited = true;\n\t}\nout:\n\tkfree(addrs);\n}", "target": 1}
{"code": "static size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t bytes,\n\t\t\t struct iov_iter *i)\n{\n\tstruct pipe_inode_info *pipe = i->pipe;\n\tstruct pipe_buffer *buf;\n\tunsigned int p_tail = pipe->tail;\n\tunsigned int p_mask = pipe->ring_size - 1;\n\tunsigned int i_head = i->head;\n\tsize_t off;\n\tif (unlikely(bytes > i->count))\n\t\tbytes = i->count;\n\tif (unlikely(!bytes))\n\t\treturn 0;\n\tif (!sanity(i))\n\t\treturn 0;\n\toff = i->iov_offset;\n\tbuf = &pipe->bufs[i_head & p_mask];\n\tif (off) {\n\t\tif (offset == off && buf->page == page) {\n\t\t\tbuf->len += bytes;\n\t\t\ti->iov_offset += bytes;\n\t\t\tgoto out;\n\t\t}\n\t\ti_head++;\n\t\tbuf = &pipe->bufs[i_head & p_mask];\n\t}\n\tif (pipe_full(i_head, p_tail, pipe->max_usage))\n\t\treturn 0;\n\tbuf->ops = &page_cache_pipe_buf_ops;\n\tget_page(page);\n\tbuf->page = page;\n\tbuf->offset = offset;\n\tbuf->len = bytes;\n\tpipe->head = i_head + 1;\n\ti->iov_offset = offset + bytes;\n\ti->head = i_head;\nout:\n\ti->count -= bytes;\n\treturn bytes;\n}", "target": 1}
{"code": "content::WebContents* WebContents::OpenURLFromTab(\n    content::WebContents* source,\n    const content::OpenURLParams& params) {\n  if (params.disposition != WindowOpenDisposition::CURRENT_TAB) {\n    Emit(\"-new-window\", params.url, \"\", params.disposition, \"\", params.referrer,\n         params.post_data);\n    return nullptr;\n  }\n  if (Emit(\"will-navigate\", params.url))\n    return nullptr;\n  if (IsDestroyed())\n    return nullptr;\n  return CommonWebContentsDelegate::OpenURLFromTab(source, params);\n}", "target": 1}
{"code": "gst_h264_slice_parse_dec_ref_pic_marking (GstH264SliceHdr * slice,\n    GstH264NalUnit * nalu, NalReader * nr)\n{\n  GstH264DecRefPicMarking *dec_ref_pic_m;\n  guint start_pos;\n  GST_DEBUG (\"parsing \\\"Decoded reference picture marking\\\"\");\n  start_pos = nal_reader_get_pos (nr);\n  dec_ref_pic_m = &slice->dec_ref_pic_marking;\n  if (nalu->idr_pic_flag) {\n    READ_UINT8 (nr, dec_ref_pic_m->no_output_of_prior_pics_flag, 1);\n    READ_UINT8 (nr, dec_ref_pic_m->long_term_reference_flag, 1);\n  } else {\n    READ_UINT8 (nr, dec_ref_pic_m->adaptive_ref_pic_marking_mode_flag, 1);\n    if (dec_ref_pic_m->adaptive_ref_pic_marking_mode_flag) {\n      guint32 mem_mgmt_ctrl_op;\n      GstH264RefPicMarking *refpicmarking;\n      dec_ref_pic_m->n_ref_pic_marking = 0;\n      while (1) {\n        refpicmarking =\n            &dec_ref_pic_m->ref_pic_marking[dec_ref_pic_m->n_ref_pic_marking];\n        READ_UE (nr, mem_mgmt_ctrl_op);\n        if (mem_mgmt_ctrl_op == 0)\n          break;\n        refpicmarking->memory_management_control_operation = mem_mgmt_ctrl_op;\n        if (mem_mgmt_ctrl_op == 1 || mem_mgmt_ctrl_op == 3)\n          READ_UE (nr, refpicmarking->difference_of_pic_nums_minus1);\n        if (mem_mgmt_ctrl_op == 2)\n          READ_UE (nr, refpicmarking->long_term_pic_num);\n        if (mem_mgmt_ctrl_op == 3 || mem_mgmt_ctrl_op == 6)\n          READ_UE (nr, refpicmarking->long_term_frame_idx);\n        if (mem_mgmt_ctrl_op == 4)\n          READ_UE (nr, refpicmarking->max_long_term_frame_idx_plus1);\n        dec_ref_pic_m->n_ref_pic_marking++;\n      }\n    }\n  }\n  dec_ref_pic_m->bit_size = nal_reader_get_pos (nr) - start_pos;\n  return TRUE;\nerror:\n  GST_WARNING (\"error parsing \\\"Decoded reference picture marking\\\"\");\n  return FALSE;\n}", "target": 1}
{"code": "ModuleExport size_t RegisterMPCImage(void)\n{\n  MagickInfo\n    *entry;\n   entry=SetMagickInfo(\"CACHE\");\n   entry->description=ConstantString(\"Magick Persistent Cache image format\");\n   entry->module=ConstantString(\"MPC\");\n   entry->stealth=MagickTrue;\n   (void) RegisterMagickInfo(entry);\n   entry=SetMagickInfo(\"MPC\");\n   entry->decoder=(DecodeImageHandler *) ReadMPCImage;\n   entry->encoder=(EncodeImageHandler *) WriteMPCImage;\n   entry->magick=(IsImageFormatHandler *) IsMPC;\n   entry->description=ConstantString(\"Magick Persistent Cache image format\");\n   entry->module=ConstantString(\"MPC\");\n   (void) RegisterMagickInfo(entry);\n   return(MagickImageCoderSignature);\n}", "target": 1}
{"code": "StreamWriteResult StreamBase::Write(\n    uv_buf_t* bufs,\n    size_t count,\n    uv_stream_t* send_handle,\n    v8::Local<v8::Object> req_wrap_obj) {\n  Environment* env = stream_env();\n  int err;\n  size_t total_bytes = 0;\n  for (size_t i = 0; i < count; ++i)\n    total_bytes += bufs[i].len;\n  bytes_written_ += total_bytes;\n  if (send_handle == nullptr) {\n    err = DoTryWrite(&bufs, &count);\n    if (err != 0 || count == 0) {\n      return StreamWriteResult { false, err, nullptr, total_bytes };\n    }\n  }\n  v8::HandleScope handle_scope(env->isolate());\n  if (req_wrap_obj.IsEmpty()) {\n    if (!env->write_wrap_template()\n             ->NewInstance(env->context())\n             .ToLocal(&req_wrap_obj)) {\n      return StreamWriteResult { false, UV_EBUSY, nullptr, 0 };\n    }\n    StreamReq::ResetObject(req_wrap_obj);\n  }\n  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(GetAsyncWrap());\n  WriteWrap* req_wrap = CreateWriteWrap(req_wrap_obj);\n  err = DoWrite(req_wrap, bufs, count, send_handle);\n  bool async = err == 0;\n  if (!async) {\n    req_wrap->Dispose();\n    req_wrap = nullptr;\n  }\n  const char* msg = Error();\n  if (msg != nullptr) {\n    req_wrap_obj->Set(env->context(),\n                      env->error_string(),\n                      OneByteString(env->isolate(), msg)).Check();\n    ClearError();\n  }\n  return StreamWriteResult { async, err, req_wrap, total_bytes };\n}", "target": 1}
{"code": "static int open_url(AVFormatContext *s, AVIOContext **pb, const char *url,\n                    AVDictionary *opts, AVDictionary *opts2, int *is_http)\n{\n    HLSContext *c = s->priv_data;\n    AVDictionary *tmp = NULL;\n    const char *proto_name = NULL;\n    int ret;\n    av_dict_copy(&tmp, opts, 0);\n    av_dict_copy(&tmp, opts2, 0);\n    if (av_strstart(url, \"crypto\", NULL)) {\n        if (url[6] == '+' || url[6] == ':')\n            proto_name = avio_find_protocol_name(url + 7);\n    }\n    if (!proto_name)\n        proto_name = avio_find_protocol_name(url);\n    if (!proto_name)\n         return AVERROR_INVALIDDATA;\n    if (!av_strstart(proto_name, \"http\", NULL) && !av_strstart(proto_name, \"file\", NULL))\n         return AVERROR_INVALIDDATA;\n     if (!strncmp(proto_name, url, strlen(proto_name)) && url[strlen(proto_name)] == ':')\n         ;\n     else if (av_strstart(url, \"crypto\", NULL) && !strncmp(proto_name, url + 7, strlen(proto_name)) && url[7 + strlen(proto_name)] == ':')\n        ;\n    else if (strcmp(proto_name, \"file\") || !strncmp(url, \"file,\", 5))\n        return AVERROR_INVALIDDATA;\n    ret = s->io_open(s, pb, url, AVIO_FLAG_READ, &tmp);\n    if (ret >= 0) {\n        char *new_cookies = NULL;\n        if (!(s->flags & AVFMT_FLAG_CUSTOM_IO))\n            av_opt_get(*pb, \"cookies\", AV_OPT_SEARCH_CHILDREN, (uint8_t**)&new_cookies);\n        if (new_cookies) {\n            av_free(c->cookies);\n            c->cookies = new_cookies;\n        }\n        av_dict_set(&opts, \"cookies\", c->cookies, 0);\n    }\n    av_dict_free(&tmp);\n    if (is_http)\n        *is_http = av_strstart(proto_name, \"http\", NULL);\n    return ret;\n}", "target": 1}
{"code": "static MagickBooleanType WriteINLINEImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  char\n    *base64,\n    message[MagickPathExtent];\n  const MagickInfo\n    *magick_info;\n  Image\n    *write_image;\n  ImageInfo\n    *write_info;\n  MagickBooleanType\n    status;\n  size_t\n    blob_length,\n    encode_length;\n  unsigned char\n    *blob;\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  write_info=CloneImageInfo(image_info);\n  (void) SetImageInfo(write_info,1,exception);\n  if (LocaleCompare(write_info->magick,\"INLINE\") == 0)\n    (void) CopyMagickString(write_info->magick,image->magick,MagickPathExtent);\n  magick_info=GetMagickInfo(write_info->magick,exception);\n  if ((magick_info == (const MagickInfo *) NULL) ||\n      (GetMagickMimeType(magick_info) == (const char *) NULL))\n    ThrowWriterException(CorruptImageError,\"ImageTypeNotSupported\");\n  (void) CopyMagickString(image->filename,write_info->filename,\n    MagickPathExtent);\n  blob_length=2048;\n  write_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (write_image == (Image *) NULL)\n    {\n      write_info=DestroyImageInfo(write_info);\n      return(MagickTrue);\n    }\n  blob=(unsigned char *) ImageToBlob(write_info,write_image,&blob_length,\n    exception);\n  write_image=DestroyImage(write_image);\n  write_info=DestroyImageInfo(write_info);\n  if (blob == (unsigned char *) NULL)\n    return(MagickFalse);\n  encode_length=0;\n  base64=Base64Encode(blob,blob_length,&encode_length);\n  blob=(unsigned char *) RelinquishMagickMemory(blob);\n  if (base64 == (char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      base64=DestroyString(base64);\n      return(status);\n    }\n  (void) FormatLocaleString(message,MagickPathExtent,\"data:%s;base64,\",\n    GetMagickMimeType(magick_info));\n  (void) WriteBlobString(image,message);\n  (void) WriteBlobString(image,base64);\n  base64=DestroyString(base64);\n  return(MagickTrue);\n}", "target": 1}
{"code": "int imap_subscribe(char *path, bool subscribe)\n{\n  struct ImapData *idata = NULL;\n  char buf[LONG_STRING];\n  char mbox[LONG_STRING];\n   char errstr[STRING];\n   struct Buffer err, token;\n   struct ImapMbox mx;\n   if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)\n   {\n    mutt_error(_(\"Bad mailbox name\"));\n    return -1;\n  }\n  idata = imap_conn_find(&(mx.account), 0);\n  if (!idata)\n    goto fail;\n  imap_fix_path(idata, mx.mbox, buf, sizeof(buf));\n  if (!*buf)\n    mutt_str_strfcpy(buf, \"INBOX\", sizeof(buf));\n  if (ImapCheckSubscribed)\n  {\n    mutt_buffer_init(&token);\n     mutt_buffer_init(&err);\n     err.data = errstr;\n     err.dsize = sizeof(errstr);\n    snprintf(mbox, sizeof(mbox), \"%smailboxes \\\"%s\\\"\", subscribe ? \"\" : \"un\", path);\n     if (mutt_parse_rc_line(mbox, &token, &err))\n       mutt_debug(1, \"Error adding subscribed mailbox: %s\\n\", errstr);\n     FREE(&token.data);\n  }\n  if (subscribe)\n    mutt_message(_(\"Subscribing to %s...\"), buf);\n  else\n    mutt_message(_(\"Unsubscribing from %s...\"), buf);\n  imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);\n  snprintf(buf, sizeof(buf), \"%sSUBSCRIBE %s\", subscribe ? \"\" : \"UN\", mbox);\n  if (imap_exec(idata, buf, 0) < 0)\n    goto fail;\n  imap_unmunge_mbox_name(idata, mx.mbox);\n  if (subscribe)\n    mutt_message(_(\"Subscribed to %s\"), mx.mbox);\n  else\n    mutt_message(_(\"Unsubscribed from %s\"), mx.mbox);\n  FREE(&mx.mbox);\n  return 0;\nfail:\n  FREE(&mx.mbox);\n  return -1;\n}", "target": 1}
{"code": "gpg_ctx_add_recipient (struct _GpgCtx *gpg,\n                       const gchar *keyid)\n{\n\tif (gpg->mode != GPG_CTX_MODE_ENCRYPT && gpg->mode != GPG_CTX_MODE_EXPORT)\n\t\treturn;\n\tif (!gpg->recipients)\n\t\tgpg->recipients = g_ptr_array_new ();\n\tg_ptr_array_add (gpg->recipients, g_strdup (keyid));\n}", "target": 1}
{"code": "gen_hash(codegen_scope *s, node *tree, int val, int limit)\n{\n  int slimit = GEN_VAL_STACK_MAX;\n  if (cursp() >= GEN_LIT_ARY_MAX) slimit = INT16_MAX;\n  int len = 0;\n  mrb_bool update = FALSE;\n  while (tree) {\n    if (nint(tree->car->car->car) == NODE_KW_REST_ARGS) {\n      if (len > 0) {\n        pop_n(len*2);\n        if (!update) {\n          genop_2(s, OP_HASH, cursp(), len);\n        }\n        else {\n          pop();\n          genop_2(s, OP_HASHADD, cursp(), len);\n        }\n        push();\n      }\n      codegen(s, tree->car->cdr, val);\n      if (len > 0 || update) {\n        pop(); pop();\n        genop_1(s, OP_HASHCAT, cursp());\n        push();\n      }\n      update = TRUE;\n      len = 0;\n    }\n    else {\n      codegen(s, tree->car->car, val);\n      codegen(s, tree->car->cdr, val);\n      len++;\n    }\n    tree = tree->cdr;\n    if (val && cursp() >= slimit) {\n      pop_n(len*2);\n      if (!update) {\n        genop_2(s, OP_HASH, cursp(), len);\n      }\n      else {\n        pop();\n        genop_2(s, OP_HASHADD, cursp(), len);\n      }\n      push();\n      update = TRUE;\n      len = 0;\n    }\n  }\n  if (update) {\n    if (val && len > 0) {\n      pop_n(len*2+1);\n      genop_2(s, OP_HASHADD, cursp(), len);\n      push();\n    }\n    return -1;                  \n  }\n  return len;\n}", "target": 1}
{"code": "void dname_pkt_copy(sldns_buffer* pkt, uint8_t* to, uint8_t* dname)\n{\n\tsize_t len = 0;\n\tuint8_t lablen;\n\tlablen = *dname++;\n\twhile(lablen) {\n\t\tif(LABEL_IS_PTR(lablen)) {\n\t\t\tdname = sldns_buffer_at(pkt, PTR_OFFSET(lablen, *dname));\n\t\t\tlablen = *dname++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(lablen > LDNS_MAX_LABELLEN) {\n\t\t\t*to = 0; \n\t\t\treturn;\n\t\t}\n\t\tlog_assert(lablen <= LDNS_MAX_LABELLEN);\n\t\tlen += (size_t)lablen+1;\n\t\tif(len >= LDNS_MAX_DOMAINLEN) {\n\t\t\t*to = 0; \n\t\t\tlog_err(\"bad dname in dname_pkt_copy\");\n\t\t\treturn;\n\t\t}\n\t\t*to++ = lablen;\n\t\tmemmove(to, dname, lablen);\n\t\tdname += lablen;\n\t\tto += lablen;\n\t\tlablen = *dname++;\n\t}\n\t*to = 0;\n}", "target": 1}
{"code": "bool DL_Dxf::handleLWPolylineData(DL_CreationInterface* ) {\n    if (groupCode==90) {\n        maxVertices = toInt(groupValue);\n        if (maxVertices>0) {\n            if (vertices!=NULL) {\n                delete[] vertices;\n            }\n            vertices = new double[4*maxVertices];\n            for (int i=0; i<maxVertices; ++i) {\n                vertices[i*4] = 0.0;\n                vertices[i*4+1] = 0.0;\n                vertices[i*4+2] = 0.0;\n                vertices[i*4+3] = 0.0;\n            }\n        }\n        vertexIndex=-1;\n        return true;\n    }\n    else if (groupCode==10 || groupCode==20 ||\n             groupCode==30 || groupCode==42) {\n        if (vertexIndex<maxVertices-1 && groupCode==10) {\n            vertexIndex++;\n        }\n        if (groupCode<=30) {\n            if (vertexIndex>=0 && vertexIndex<maxVertices) {\n                vertices[4*vertexIndex + (groupCode/10-1)] = toReal(groupValue);\n            }\n        } else if (groupCode==42 && vertexIndex<maxVertices) {\n            vertices[4*vertexIndex + 3] = toReal(groupValue);\n        }\n        return true;\n    }\n    return false;\n}", "target": 1}
{"code": "_fr_window_ask_overwrite_dialog (OverwriteData *odata)\n{\n\tif ((odata->edata->overwrite == FR_OVERWRITE_ASK) && (odata->current_file != NULL)) {\n\t\tconst char *base_name;\n\t\tGFile      *destination;\n\t\tbase_name = _g_path_get_relative_basename ((char *) odata->current_file->data, odata->edata->base_dir, odata->edata->junk_paths);\n\t\tdestination = g_file_get_child (odata->edata->destination, base_name);\n\t\tg_file_query_info_async (destination,\n\t\t\t\t\t G_FILE_ATTRIBUTE_STANDARD_TYPE \",\" G_FILE_ATTRIBUTE_STANDARD_NAME \",\" G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME,\n\t\t\t\t\t G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n\t\t\t\t\t G_PRIORITY_DEFAULT,\n\t\t\t\t\t odata->window->priv->cancellable,\n\t\t\t\t\t query_info_ready_for_overwrite_dialog_cb,\n\t\t\t\t\t odata);\n\t\tg_object_unref (destination);\n\t\treturn;\n\t}\n\tif (odata->edata->file_list != NULL) {\n\t\tif (odata->extract_all) {\n\t\t\t_g_string_list_free (odata->edata->file_list);\n\t\t\todata->edata->file_list = NULL;\n\t\t}\n\t\todata->edata->overwrite = FR_OVERWRITE_YES;\n\t\t_fr_window_archive_extract_from_edata (odata->window, odata->edata);\n\t}\n\telse {\n\t\tGtkWidget *d;\n\t\td = _gtk_message_dialog_new (GTK_WINDOW (odata->window),\n\t\t\t\t\t     0,\n\t\t\t\t\t     GTK_STOCK_DIALOG_WARNING,\n\t\t\t\t\t     _(\"Extraction not performed\"),\n\t\t\t\t\t     NULL,\n\t\t\t\t\t     GTK_STOCK_OK, GTK_RESPONSE_OK,\n\t\t\t\t\t     NULL);\n\t\tgtk_dialog_set_default_response (GTK_DIALOG (d), GTK_RESPONSE_OK);\n\t\tfr_window_show_error_dialog (odata->window, d, GTK_WINDOW (odata->window), _(\"Extraction not performed\"));\n\t\tfr_window_stop_batch (odata->window);\n\t}\n\tg_free (odata);\n}", "target": 1}
{"code": "void queue_push(register Queue *qp, size_t extra_length, char const *info)\n{\n    register char *cp;\n    size_t memory_length;\n    size_t available_length;\n    size_t begin_length;\n    size_t n_begin;\n    size_t q_length;\n    if (!extra_length)\n        return;\n    memory_length    = qp->d_memory_end - qp->d_memory;\n    q_length = \n        qp->d_read <= qp->d_write ?\n            (size_t)(qp->d_write - qp->d_read)\n        :\n            memory_length - (qp->d_read - qp->d_write);\n    available_length = memory_length - q_length - 1;\n    if (message_show(MSG_INFO))\n        message(\"push_front %u bytes in `%s'\", (unsigned)extra_length, info);\n     if (extra_length > available_length)\n     {\n         memory_length += extra_length - available_length + BLOCK_QUEUE;\n         cp = new_memory(memory_length, sizeof(char));\n         if (message_show(MSG_INFO))\n            message(\"Reallocating queue at %p to %p\", qp->d_memory, cp);\n        if (qp->d_read > qp->d_write)               \n        {\n            size_t tail_len = qp->d_memory_end - qp->d_read;\n            memcpy(cp, qp->d_read, tail_len);       \n            memcpy(cp + tail_len, qp->d_memory, \n                                    (size_t)(qp->d_write - qp->d_memory));\n            qp->d_write = cp + q_length;\n            qp->d_read = cp;\n         }\n         else                                        \n         {\n            memcpy(cp, qp->d_memory, memory_length);\n             qp->d_read = cp + (qp->d_read - qp->d_memory);\n             qp->d_write = cp + (qp->d_write - qp->d_memory);\n         }\n        free(qp->d_memory);                         \n        qp->d_memory_end = cp + memory_length;      \n        qp->d_memory = cp;                          \n    }\n    begin_length = qp->d_read - qp->d_memory;   \n    n_begin = extra_length <= begin_length ?    \n                    extra_length                \n                :\n                    begin_length;\n    memcpy                                      \n    (                                           \n        qp->d_read -= n_begin,\n        info + extra_length - n_begin,\n        n_begin\n    );\n    if (extra_length > begin_length)            \n    {\n        extra_length -= begin_length;           \n        memcpy                                  \n        (                                       \n            qp->d_read = qp->d_memory_end - extra_length,\n            info,\n            extra_length\n        );\n    }\n}", "target": 1}
{"code": "int av_reallocp_array(void *ptr, size_t nmemb, size_t size)\n {\n     void **ptrptr = ptr;\n     *ptrptr = av_realloc_f(*ptrptr, nmemb, size);\n    if (!*ptrptr && !(nmemb && size))\n         return AVERROR(ENOMEM);\n     return 0;\n }", "target": 1}
{"code": "static uint64_t unpack_timestamp(const struct efi_time *timestamp)\n{\n\tuint64_t val = 0;\n\tuint16_t year = le32_to_cpu(timestamp->year);\n\tval |= ((uint64_t) timestamp->pad1 & 0xFF) << 0;\n\tval |= ((uint64_t) timestamp->second & 0xFF) << (1*8);\n\tval |= ((uint64_t) timestamp->minute & 0xFF) << (2*8);\n\tval |= ((uint64_t) timestamp->hour & 0xFF) << (3*8);\n\tval |= ((uint64_t) timestamp->day & 0xFF) << (4*8);\n\tval |= ((uint64_t) timestamp->month & 0xFF) << (5*8);\n\tval |= ((uint64_t) year) << (6*8);\n\treturn val;\n}", "target": 1}
{"code": "Stream *Parser::makeStream(Object &&dict, Guchar *fileKey,\n\t\t\t   CryptAlgorithm encAlgorithm, int keyLength,\n\t\t\t   int objNum, int objGen, int recursion,\n                           GBool strict) {\n  BaseStream *baseStr;\n  Stream *str;\n  Goffset length;\n  Goffset pos, endPos;\n  lexer->skipToNextLine();\n  if (!(str = lexer->getStream())) {\n    return nullptr;\n  }\n  pos = str->getPos();\n  Object obj = dict.dictLookup(\"Length\", recursion);\n  if (obj.isInt()) {\n    length = obj.getInt();\n  } else if (obj.isInt64()) {\n    length = obj.getInt64();\n  } else {\n    error(errSyntaxError, getPos(), \"Bad 'Length' attribute in stream\");\n    if (strict) return nullptr;\n    length = 0;\n  }\n  if (xref && xref->getStreamEnd(pos, &endPos)) {\n    length = endPos - pos;\n  }\n  if (!lexer->getStream()) {\n    return nullptr;\n  }\n  baseStr = lexer->getStream()->getBaseStream();\n  if (Lexer::LOOK_VALUE_NOT_CACHED != lexer->lookCharLastValueCached) {\n      pos = pos - 1;\n      lexer->lookCharLastValueCached = Lexer::LOOK_VALUE_NOT_CACHED;\n  }\n  lexer->setPos(pos + length);\n  shift();  \n  shift(\"endstream\", objNum);  \n  if (buf1.isCmd(\"endstream\")) {\n    shift();\n  } else {\n    error(errSyntaxError, getPos(), \"Missing 'endstream' or incorrect stream length\");\n    if (strict) return nullptr;\n    if (xref && lexer->getStream()) {\n      length = lexer->getPos() - pos;\n      if (buf1.isCmd(\"endstream\")) {\n        dict.dictSet(\"Length\", Object(length));\n      }\n    } else {\n      length += 5000;\n    }\n  }\n  str = baseStr->makeSubStream(pos, gTrue, length, std::move(dict));\n  if (fileKey) {\n    str = new DecryptStream(str, fileKey, encAlgorithm, keyLength,\n\t\t\t    objNum, objGen);\n  }\n  str = str->addFilters(str->getDict(), recursion);\n  return str;\n}", "target": 1}
{"code": "ecryptfs_write_metadata_to_contents(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t    struct dentry *ecryptfs_dentry,\n\t\t\t\t    char *virt)\n{\n\tint rc;\n\trc = ecryptfs_write_lower(ecryptfs_dentry->d_inode, virt,\n\t\t\t\t  0, crypt_stat->num_header_bytes_at_front);\n\tif (rc)\n\t\tprintk(KERN_ERR \"%s: Error attempting to write header \"\n\t\t       \"information to lower file; rc = [%d]\\n\", __func__,\n\t\t       rc);\n\treturn rc;\n}", "target": 1}
{"code": "void EC_GROUP_clear_free(EC_GROUP *group)\n\t{\n\tif (!group) return;\n\tif (group->meth->group_clear_finish != 0)\n\t\tgroup->meth->group_clear_finish(group);\n\telse if (group->meth->group_finish != 0)\n\t\tgroup->meth->group_finish(group);\n\tEC_EX_DATA_clear_free_all_data(&group->extra_data);\n\tif (group->generator != NULL)\n        EC_EX_DATA_clear_free_all_data(&group->extra_data);\n        if (group->generator != NULL)\n                EC_POINT_clear_free(group->generator);\n        BN_clear_free(&group->order);\n\tOPENSSL_cleanse(group, sizeof *group);\n\tOPENSSL_free(group);\n\t}", "target": 1}
{"code": "static int pipe_to_file(struct pipe_inode_info *pipe, struct pipe_buffer *buf,\n\t\t\tstruct splice_desc *sd)\n{\n\tstruct file *file = sd->u.file;\n\tstruct address_space *mapping = file->f_mapping;\n\tunsigned int offset, this_len;\n\tstruct page *page;\n\tpgoff_t index;\n\tint ret;\n\tret = buf->ops->confirm(pipe, buf);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tindex = sd->pos >> PAGE_CACHE_SHIFT;\n\toffset = sd->pos & ~PAGE_CACHE_MASK;\n\tthis_len = sd->len;\n\tif (this_len + offset > PAGE_CACHE_SIZE)\n\t\tthis_len = PAGE_CACHE_SIZE - offset;\nfind_page:\n\tpage = find_lock_page(mapping, index);\n\tif (!page) {\n\t\tret = -ENOMEM;\n\t\tpage = page_cache_alloc_cold(mapping);\n\t\tif (unlikely(!page))\n\t\t\tgoto out_ret;\n\t\tret = add_to_page_cache_lru(page, mapping, index,\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (unlikely(ret))\n\t\t\tgoto out;\n\t}\n\tret = mapping->a_ops->prepare_write(file, page, offset, offset+this_len);\n\tif (unlikely(ret)) {\n\t\tloff_t isize = i_size_read(mapping->host);\n\t\tif (ret != AOP_TRUNCATED_PAGE)\n\t\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (ret == AOP_TRUNCATED_PAGE)\n\t\t\tgoto find_page;\n\t\tif (sd->pos + this_len > isize)\n\t\t\tvmtruncate(mapping->host, isize);\n\t\tgoto out_ret;\n\t}\n\tif (buf->page != page) {\n\t\tchar *src = buf->ops->map(pipe, buf, 1);\n\t\tchar *dst = kmap_atomic(page, KM_USER1);\n\t\tmemcpy(dst + offset, src + buf->offset, this_len);\n\t\tflush_dcache_page(page);\n\t\tkunmap_atomic(dst, KM_USER1);\n\t\tbuf->ops->unmap(pipe, buf, src);\n\t}\n\tret = mapping->a_ops->commit_write(file, page, offset, offset+this_len);\n\tif (ret) {\n\t\tif (ret == AOP_TRUNCATED_PAGE) {\n\t\t\tpage_cache_release(page);\n\t\t\tgoto find_page;\n\t\t}\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t} else\n\t\tret = this_len;\n\tmark_page_accessed(page);\nout:\n\tpage_cache_release(page);\n\tunlock_page(page);\nout_ret:\n\treturn ret;\n}", "target": 1}
{"code": "static bool disconnect_cb(struct io *io, void *user_data)\n{\n\tstruct bt_att_chan *chan = user_data;\n\tstruct bt_att *att = chan->att;\n\tint err;\n\tsocklen_t len;\n\tlen = sizeof(err);\n\tif (getsockopt(chan->fd, SOL_SOCKET, SO_ERROR, &err, &len) < 0) {\n\t\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"(chan %p) Failed to obtain disconnect\"\n\t\t\t\t\t\" error: %s\", chan, strerror(errno));\n\t\terr = 0;\n\t}\n\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"Channel %p disconnected: %s\",\n\t\t\t\t\tchan, strerror(err));\n\tqueue_remove(att->chans, chan);\n\tqueue_remove_all(att->req_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->ind_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->write_queue, NULL, NULL, disc_att_send_op);\n\tif (chan->pending_req) {\n\t\tdisc_att_send_op(chan->pending_req);\n\t\tchan->pending_req = NULL;\n\t}\n\tif (chan->pending_ind) {\n\t\tdisc_att_send_op(chan->pending_ind);\n\t\tchan->pending_ind = NULL;\n\t}\n\tbt_att_chan_free(chan);\n\tif (!queue_isempty(att->chans))\n\t\treturn false;\n\tbt_att_ref(att);\n\tqueue_foreach(att->disconn_list, disconn_handler, INT_TO_PTR(err));\n\tbt_att_unregister_all(att);\n\tbt_att_unref(att);\n\treturn false;\n}", "target": 1}
{"code": "static int do_io_accounting(struct task_struct *task, char *buffer, int whole)\n{\n \tstruct task_io_accounting acct = task->ioac;\n \tunsigned long flags;\n \tif (whole && lock_task_sighand(task, &flags)) {\n \t\tstruct task_struct *t = task;\n\t\ttask_io_accounting_add(&acct, &task->signal->ioac);\n\t\twhile_each_thread(task, t)\n\t\t\ttask_io_accounting_add(&acct, &t->ioac);\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\treturn sprintf(buffer,\n\t\t\t\"rchar: %llu\\n\"\n\t\t\t\"wchar: %llu\\n\"\n\t\t\t\"syscr: %llu\\n\"\n\t\t\t\"syscw: %llu\\n\"\n\t\t\t\"read_bytes: %llu\\n\"\n\t\t\t\"write_bytes: %llu\\n\"\n\t\t\t\"cancelled_write_bytes: %llu\\n\",\n\t\t\t(unsigned long long)acct.rchar,\n\t\t\t(unsigned long long)acct.wchar,\n\t\t\t(unsigned long long)acct.syscr,\n\t\t\t(unsigned long long)acct.syscw,\n\t\t\t(unsigned long long)acct.read_bytes,\n\t\t\t(unsigned long long)acct.write_bytes,\n\t\t\t(unsigned long long)acct.cancelled_write_bytes);\n}", "target": 1}
{"code": "ngx_gmtime(time_t t, ngx_tm_t *tp)\n{\n    ngx_int_t   yday;\n    ngx_uint_t  sec, min, hour, mday, mon, year, wday, days, leap;\n    if (t < 0) {\n        t = 0;\n    }\n    days = t / 86400;\n    sec = t % 86400;\n    wday = (4 + days) % 7;\n    hour = sec / 3600;\n    sec %= 3600;\n    min = sec / 60;\n    sec %= 60;\n    days = days - (31 + 28) + 719527;\n    year = (days + 2) * 400 / (365 * 400 + 100 - 4 + 1);\n    yday = days - (365 * year + year / 4 - year / 100 + year / 400);\n    if (yday < 0) {\n        leap = (year % 4 == 0) && (year % 100 || (year % 400 == 0));\n        yday = 365 + leap + yday;\n        year--;\n    }\n    mon = (yday + 31) * 10 / 306;\n    mday = yday - (367 * mon / 12 - 30) + 1;\n    if (yday >= 306) {\n        year++;\n        mon -= 10;\n    } else {\n        mon += 2;\n    }\n    tp->ngx_tm_sec = (ngx_tm_sec_t) sec;\n    tp->ngx_tm_min = (ngx_tm_min_t) min;\n    tp->ngx_tm_hour = (ngx_tm_hour_t) hour;\n    tp->ngx_tm_mday = (ngx_tm_mday_t) mday;\n    tp->ngx_tm_mon = (ngx_tm_mon_t) mon;\n    tp->ngx_tm_year = (ngx_tm_year_t) year;\n    tp->ngx_tm_wday = (ngx_tm_wday_t) wday;\n}", "target": 1}
{"code": " void ColorChooserDialog::DidCloseDialog(bool chose_color,\n                                         SkColor color,\n                                         RunState run_state) {\n  if (!listener_)\n    return;\n   EndRun(run_state);\n   CopyCustomColors(custom_colors_, g_custom_colors);\n  if (chose_color)\n    listener_->OnColorChosen(color);\n  listener_->OnColorChooserDialogClosed();\n }", "target": 1}
{"code": "static ssize_t stellaris_enet_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n{\n    stellaris_enet_state *s = qemu_get_nic_opaque(nc);\n    int n;\n    uint8_t *p;\n    uint32_t crc;\n    if ((s->rctl & SE_RCTL_RXEN) == 0)\n        return -1;\n    if (s->np >= 31) {\n        return 0;\n    }\n    DPRINTF(\"Received packet len=%zu\\n\", size);\n    n = s->next_packet + s->np;\n    if (n >= 31)\n        n -= 31;\n    s->np++;\n    s->rx[n].len = size + 6;\n    p = s->rx[n].data;\n    *(p++) = (size + 6);\n    *(p++) = (size + 6) >> 8;\n    memcpy (p, buf, size);\n    p += size;\n    crc = crc32(~0, buf, size);\n    *(p++) = crc;\n    *(p++) = crc >> 8;\n    *(p++) = crc >> 16;\n    *(p++) = crc >> 24;\n    if ((size & 3) != 2) {\n        memset(p, 0, (6 - size) & 3);\n    }\n    s->ris |= SE_INT_RX;\n    stellaris_enet_update(s);\n    return size;\n}", "target": 1}
{"code": "tiff_document_get_thumbnail (EvDocument      *document,\n\t\t\t     EvRenderContext *rc)\n{\n\tTiffDocument *tiff_document = TIFF_DOCUMENT (document);\n\tint width, height;\n\tint scaled_width, scaled_height;\n\tfloat x_res, y_res;\n\tgint rowstride, bytes;\n\tguchar *pixels = NULL;\n\tGdkPixbuf *pixbuf;\n\tGdkPixbuf *scaled_pixbuf;\n\tGdkPixbuf *rotated_pixbuf;\n\tpush_handlers ();\n\tif (TIFFSetDirectory (tiff_document->tiff, rc->page->index) != 1) {\n\t\tpop_handlers ();\n\t\treturn NULL;\n\t}\n\tif (!TIFFGetField (tiff_document->tiff, TIFFTAG_IMAGEWIDTH, &width)) {\n\t\tpop_handlers ();\n\t\treturn NULL;\n\t}\n\tif (! TIFFGetField (tiff_document->tiff, TIFFTAG_IMAGELENGTH, &height)) {\n\t\tpop_handlers ();\n\t\treturn NULL;\n\t}\n\ttiff_document_get_resolution (tiff_document, &x_res, &y_res);\n\tpop_handlers ();\n\tif (width <= 0 || height <= 0)\n\t\treturn NULL;                \n\tif (width >= INT_MAX / 4)\n\t\treturn NULL;                \n\trowstride = width * 4;\n\tif (height >= INT_MAX / rowstride)\n\t\treturn NULL;                \n\tbytes = height * rowstride;\n\tpixels = g_try_malloc (bytes);\n\tif (!pixels)\n\t\treturn NULL;\n\tpixbuf = gdk_pixbuf_new_from_data (pixels, GDK_COLORSPACE_RGB, TRUE, 8, \n\t\t\t\t\t   width, height, rowstride,\n\t\t\t\t\t   (GdkPixbufDestroyNotify) g_free, NULL);\n\tTIFFReadRGBAImageOriented (tiff_document->tiff,\n\t\t\t\t   width, height,\n\t\t\t\t   (uint32 *)pixels,\n\t\t\t\t   ORIENTATION_TOPLEFT, 0);\n\tpop_handlers ();\n\tev_render_context_compute_scaled_size (rc, width, height * (x_res / y_res),\n\t\t\t\t\t       &scaled_width, &scaled_height);\n\tscaled_pixbuf = gdk_pixbuf_scale_simple (pixbuf,\n\t\t\t\t\t\t scaled_width, scaled_height,\n\t\t\t\t\t\t GDK_INTERP_BILINEAR);\n\tg_object_unref (pixbuf);\n\trotated_pixbuf = gdk_pixbuf_rotate_simple (scaled_pixbuf, 360 - rc->rotation);\n\tg_object_unref (scaled_pixbuf);\n\treturn rotated_pixbuf;\n}", "target": 1}
{"code": "static void upnp_event_prepare(struct upnp_event_notify * obj)\n{\n\tstatic const char notifymsg[] =\n\t\t\"NOTIFY %s HTTP/1.1\\r\\n\"\n\t\t\"Host: %s%s\\r\\n\"\n#if (UPNP_VERSION_MAJOR == 1) && (UPNP_VERSION_MINOR == 0)\n\t\t\"Content-Type: text/xml\\r\\n\"\t\n#else\n\t\t\"Content-Type: text/xml; charset=\\\"utf-8\\\"\\r\\n\"\t\n#endif\n\t\t\"Content-Length: %d\\r\\n\"\n\t\t\"NT: upnp:event\\r\\n\"\n\t\t\"NTS: upnp:propchange\\r\\n\"\n\t\t\"SID: %s\\r\\n\"\n\t\t\"SEQ: %u\\r\\n\"\n\t\t\"Connection: close\\r\\n\"\n\t\t\"Cache-Control: no-cache\\r\\n\"\n\t\t\"\\r\\n\"\n\t\t\"%.*s\\r\\n\";\n\tchar * xml;\n\tint l;\n\tif(obj->sub == NULL) {\n\t\tobj->state = EError;\n\t\treturn;\n\t}\n\tswitch(obj->sub->service) {\n\tcase EWanCFG:\n\t\txml = getVarsWANCfg(&l);\n\t\tbreak;\n\tcase EWanIPC:\n\t\txml = getVarsWANIPCn(&l);\n\t\tbreak;\n#ifdef ENABLE_L3F_SERVICE\n\tcase EL3F:\n\t\txml = getVarsL3F(&l);\n\t\tbreak;\n#endif\n#ifdef ENABLE_6FC_SERVICE\n\tcase E6FC:\n\t\txml = getVars6FC(&l);\n\t\tbreak;\n#endif\n#ifdef ENABLE_DP_SERVICE\n\tcase EDP:\n\t\txml = getVarsDP(&l);\n\t\tbreak;\n#endif\n\tdefault:\n\t\txml = NULL;\n \t\tl = 0;\n \t}\n \tobj->buffersize = 1024;\n\tobj->buffer = malloc(obj->buffersize);\n\tif(!obj->buffer) {\n\t\tsyslog(LOG_ERR, \"%s: malloc returned NULL\", \"upnp_event_prepare\");\n\t\tif(xml) {\n\t\t\tfree(xml);\n \t\t}\n\t\tobj->state = EError;\n\t\treturn;\n \t}\n\tobj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,\n\t                       obj->path, obj->addrstr, obj->portstr, l+2,\n\t                       obj->sub->uuid, obj->sub->seq,\n\t                       l, xml);\n \tif(xml) {\n \t\tfree(xml);\n \t\txml = NULL;\n\t}\n\tobj->state = ESending;\n}", "target": 1}
{"code": "grub_password_get (char buf[], unsigned buf_size)\n{\n  unsigned cur_len = 0;\n  int key;\n  while (1)\n    {\n      key = grub_getkey (); \n      if (key == '\\n' || key == '\\r')\n\tbreak;\n      if (key == '\\e')\n\t{\n\t  cur_len = 0;\n\t  break;\n\t}\n      if (key == '\\b')\n\t{\n\t  cur_len--;\n\t  continue;\n\t}\n      if (!grub_isprint (key))\n\tcontinue;\n      if (cur_len + 2 < buf_size)\n\tbuf[cur_len++] = key;\n    }\n  grub_memset (buf + cur_len, 0, buf_size - cur_len);\n  grub_xputs (\"\\n\");\n  grub_refresh ();\n  return (key != '\\e');\n}", "target": 1}
{"code": " int usb_cypress_load_firmware(struct usb_device *udev, const struct firmware *fw, int type)\n {\n \tstruct hexline *hx;\n\tu8 reset;\n\tint ret,pos=0;\n\thx = kmalloc(sizeof(*hx), GFP_KERNEL);\n\tif (!hx)\n \t\treturn -ENOMEM;\n\treset = 1;\n\tif ((ret = usb_cypress_writemem(udev,cypress[type].cpu_cs_register,&reset,1)) != 1)\n \t\terr(\"could not stop the USB controller CPU.\");\n \twhile ((ret = dvb_usb_get_hexline(fw, hx, &pos)) > 0) {\n\t\tdeb_fw(\"writing to address 0x%04x (buffer: 0x%02x %02x)\\n\", hx->addr, hx->len, hx->chk);\n\t\tret = usb_cypress_writemem(udev, hx->addr, hx->data, hx->len);\n\t\tif (ret != hx->len) {\n\t\t\terr(\"error while transferring firmware (transferred size: %d, block size: %d)\",\n\t\t\t\tret, hx->len);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n \t}\n \tif (ret < 0) {\n \t\terr(\"firmware download failed at %d with %d\",pos,ret);\n\t\tkfree(hx);\n \t\treturn ret;\n \t}\n \tif (ret == 0) {\n\t\treset = 0;\n\t\tif (ret || usb_cypress_writemem(udev,cypress[type].cpu_cs_register,&reset,1) != 1) {\n \t\t\terr(\"could not restart the USB controller CPU.\");\n \t\t\tret = -EINVAL;\n \t\t}\n \t} else\n \t\tret = -EIO;\n\tkfree(hx);\n \treturn ret;\n }", "target": 1}
{"code": "int input_set_keycode(struct input_dev *dev,\n\t\t      const struct input_keymap_entry *ke)\n{\n\tunsigned long flags;\n\tunsigned int old_keycode;\n\tint retval;\n\tif (ke->keycode > KEY_MAX)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\tretval = dev->setkeycode(dev, ke, &old_keycode);\n\tif (retval)\n\t\tgoto out;\n\t__clear_bit(KEY_RESERVED, dev->keybit);\n\tif (test_bit(EV_KEY, dev->evbit) &&\n\t    !is_event_supported(old_keycode, dev->keybit, KEY_MAX) &&\n\t    __test_and_clear_bit(old_keycode, dev->key)) {\n\t\tstruct input_value vals[] =  {\n\t\t\t{ EV_KEY, old_keycode, 0 },\n\t\t\tinput_value_sync\n\t\t};\n\t\tinput_pass_values(dev, vals, ARRAY_SIZE(vals));\n\t}\n out:\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\treturn retval;\n}", "target": 1}
{"code": "isis_print_id(const uint8_t *cp, int id_len)\n{\n     int i;\n     static char id[sizeof(\"xxxx.xxxx.xxxx.yy-zz\")];\n     char *pos = id;\n    for (i = 1; i <= SYSTEM_ID_LEN; i++) {\n         snprintf(pos, sizeof(id) - (pos - id), \"%02x\", *cp++);\n \tpos += strlen(pos);\n \tif (i == 2 || i == 4)\n\t    *pos++ = '.';\n\t}\n    if (id_len >= NODE_ID_LEN) {\n        snprintf(pos, sizeof(id) - (pos - id), \".%02x\", *cp++);\n\tpos += strlen(pos);\n    }\n    if (id_len == LSP_ID_LEN)\n        snprintf(pos, sizeof(id) - (pos - id), \"-%02x\", *cp);\n    return (id);\n}", "target": 1}
{"code": "TfLiteStatus Resize(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteLSHProjectionParams*>(node->builtin_data);\n  TF_LITE_ENSURE(context, NumInputs(node) == 2 || NumInputs(node) == 3);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* hash;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &hash));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(hash), 2);\n  TF_LITE_ENSURE(context, SizeOfDimension(hash, 1) <= 32);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &input));\n  TF_LITE_ENSURE(context, NumDimensions(input) >= 1);\n  if (NumInputs(node) == 3) {\n    const TfLiteTensor* weight;\n    TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &weight));\n    TF_LITE_ENSURE_EQ(context, NumDimensions(weight), 1);\n    TF_LITE_ENSURE_EQ(context, SizeOfDimension(weight, 0),\n                      SizeOfDimension(input, 0));\n  }\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  TfLiteIntArray* outputSize = TfLiteIntArrayCreate(1);\n  switch (params->type) {\n    case kTfLiteLshProjectionSparse:\n      outputSize->data[0] = SizeOfDimension(hash, 0);\n      break;\n    case kTfLiteLshProjectionDense:\n      outputSize->data[0] = SizeOfDimension(hash, 0) * SizeOfDimension(hash, 1);\n      break;\n    default:\n      return kTfLiteError;\n  }\n  return context->ResizeTensor(context, output, outputSize);\n}", "target": 1}
{"code": "main(int argc, char *argv[])\n{\n  int cnt,rc,cc;\n  char cmnd[255];\n  strcpy(cmnd, CMD);\n  if (argc > 1)\n  {\n    for (cnt = 1; cnt < argc; cnt++)\n    {\n      strcat(cmnd, \" \");\n      strcat(cmnd, argv[cnt]);\n    }\n  }\n  else\n  {\n    fprintf(stderr, \"__ %s:  failed %d  %d\\n\", argv[0], rc, cc);\n    return 255;\n  }\n  cc = setuid(UID);\n  rc = system(cmnd);\n  if ((rc != 0) || (cc != 0))\n  {\n    fprintf(stderr, \"__ %s:  failed %d  %d\\n\", argv[0], rc, cc);\n    return 1;\n  }\n  return 0;\n}", "target": 1}
{"code": "int ecryptfs_privileged_open(struct file **lower_file,\n\t\t\t     struct dentry *lower_dentry,\n\t\t\t     struct vfsmount *lower_mnt,\n\t\t\t     const struct cred *cred)\n{\n\tstruct ecryptfs_open_req req;\n\tint flags = O_LARGEFILE;\n\tint rc = 0;\n\tinit_completion(&req.done);\n\treq.lower_file = lower_file;\n\treq.path.dentry = lower_dentry;\n\treq.path.mnt = lower_mnt;\n \tflags |= IS_RDONLY(d_inode(lower_dentry)) ? O_RDONLY : O_RDWR;\n \t(*lower_file) = dentry_open(&req.path, flags, cred);\n \tif (!IS_ERR(*lower_file))\n\t\tgoto out;\n \tif ((flags & O_ACCMODE) == O_RDONLY) {\n \t\trc = PTR_ERR((*lower_file));\n \t\tgoto out;\n\t}\n\tmutex_lock(&ecryptfs_kthread_ctl.mux);\n\tif (ecryptfs_kthread_ctl.flags & ECRYPTFS_KTHREAD_ZOMBIE) {\n\t\trc = -EIO;\n\t\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\t\tprintk(KERN_ERR \"%s: We are in the middle of shutting down; \"\n\t\t       \"aborting privileged request to open lower file\\n\",\n\t\t\t__func__);\n\t\tgoto out;\n\t}\n\tlist_add_tail(&req.kthread_ctl_list, &ecryptfs_kthread_ctl.req_list);\n \tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n \twake_up(&ecryptfs_kthread_ctl.wait);\n \twait_for_completion(&req.done);\n\tif (IS_ERR(*lower_file))\n \t\trc = PTR_ERR(*lower_file);\n out:\n \treturn rc;\n }", "target": 1}
{"code": "void MimeHandlerViewContainer::OnReady() {\n  if (!render_frame() || !is_embedded_)\n    return;\n  blink::WebLocalFrame* frame = render_frame()->GetWebFrame();\n  blink::WebAssociatedURLLoaderOptions options;\n  DCHECK(!loader_);\n  loader_.reset(frame->CreateAssociatedURLLoader(options));\n   blink::WebURLRequest request(original_url_);\n   request.SetRequestContext(blink::WebURLRequest::kRequestContextObject);\n   loader_->LoadAsynchronously(request, this);\n }", "target": 1}
{"code": "ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,\n               const char **elem_rtrn, const char **field_rtrn,\n               ExprDef **index_rtrn)\n{\n    switch (expr->expr.op) {\n    case EXPR_IDENT:\n         *elem_rtrn = NULL;\n         *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);\n         *index_rtrn = NULL;\n        return true;\n     case EXPR_FIELD_REF:\n         *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n         *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);\n        *index_rtrn = NULL;\n        return true;\n    case EXPR_ARRAY_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);\n        *index_rtrn = expr->array_ref.entry;\n        return true;\n    default:\n        break;\n    }\n    log_wsgo(ctx, \"Unexpected operator %d in ResolveLhs\\n\", expr->expr.op);\n    return false;\n}", "target": 1}
{"code": "static int futex_wait(u32 __user *uaddr, int fshared,\n\t\t      u32 val, ktime_t *abs_time, u32 bitset, int clockrt)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct restart_block *restart;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q q;\n\tint ret;\n\tif (!bitset)\n\t\treturn -EINVAL;\n\tq.pi_state = NULL;\n\tq.bitset = bitset;\n\tq.rt_waiter = NULL;\n\tq.requeue_pi_key = NULL;\n\tif (abs_time) {\n\t\tto = &timeout;\n\t\thrtimer_init_on_stack(&to->timer, clockrt ? CLOCK_REALTIME :\n\t\t\t\t      CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n \t}\n retry:\n \tret = futex_wait_setup(uaddr, val, fshared, &q, &hb);\n \tif (ret)\n \t\tgoto out;\n\tfutex_wait_queue_me(hb, &q, to);\n \tret = 0;\n \tif (!unqueue_me(&q))\n\t\tgoto out_put_key;\n \tret = -ETIMEDOUT;\n \tif (to && !to->task)\n\t\tgoto out_put_key;\n\tif (!signal_pending(current)) {\n\t\tput_futex_key(fshared, &q.key);\n \t\tgoto retry;\n\t}\n \tret = -ERESTARTSYS;\n \tif (!abs_time)\n\t\tgoto out_put_key;\n \trestart = &current_thread_info()->restart_block;\n \trestart->fn = futex_wait_restart;\n\trestart->futex.uaddr = (u32 *)uaddr;\n\trestart->futex.val = val;\n\trestart->futex.time = abs_time->tv64;\n\trestart->futex.bitset = bitset;\n\trestart->futex.flags = FLAGS_HAS_TIMEOUT;\n\tif (fshared)\n\t\trestart->futex.flags |= FLAGS_SHARED;\n\tif (clockrt)\n\t\trestart->futex.flags |= FLAGS_CLOCKRT;\n \tret = -ERESTART_RESTARTBLOCK;\nout_put_key:\n\tput_futex_key(fshared, &q.key);\n out:\n \tif (to) {\n \t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "ins_compl_stop(int c, int prev_mode, int retval)\n{\n    char_u\t*ptr;\n    int\t\twant_cindent;\n    if (compl_curr_match != NULL || compl_leader != NULL || c == Ctrl_E)\n    {\n\tif (compl_curr_match != NULL && compl_used_match && c != Ctrl_E)\n\t    ptr = compl_curr_match->cp_str;\n\telse\n\t    ptr = NULL;\n\tins_compl_fixRedoBufForLeader(ptr);\n    }\n    want_cindent = (get_can_cindent() && cindent_on());\n    if (compl_cont_mode == CTRL_X_WHOLE_LINE)\n    {\n\tif (want_cindent)\n\t{\n\t    do_c_expr_indent();\n\t    want_cindent = FALSE;\t\n\t}\n    }\n    else\n    {\n\tint prev_col = curwin->w_cursor.col;\n\tif (prev_col > 0)\n\t    dec_cursor();\n\tif (!arrow_used && !ins_need_undo_get() && c != Ctrl_E)\n\t    insertchar(NUL, 0, -1);\n\tif (prev_col > 0\n\t\t&& ml_get_curline()[curwin->w_cursor.col] != NUL)\n\t    inc_cursor();\n    }\n    if ((c == Ctrl_Y || (compl_enter_selects\n\t\t    && (c == CAR || c == K_KENTER || c == NL)))\n\t    && pum_visible())\n\tretval = TRUE;\n    if (c == Ctrl_E)\n    {\n\tins_compl_delete();\n\tif (compl_leader != NULL)\n\t    ins_bytes(compl_leader + get_compl_len());\n\telse if (compl_first_match != NULL)\n\t    ins_bytes(compl_orig_text + get_compl_len());\n\tretval = TRUE;\n    }\n    auto_format(FALSE, TRUE);\n    ctrl_x_mode = prev_mode;\n    ins_apply_autocmds(EVENT_COMPLETEDONEPRE);\n    ins_compl_free();\n    compl_started = FALSE;\n    compl_matches = 0;\n    if (!shortmess(SHM_COMPLETIONMENU))\n\tmsg_clr_cmdline();\t\n    ctrl_x_mode = CTRL_X_NORMAL;\n    compl_enter_selects = FALSE;\n    if (edit_submode != NULL)\n    {\n\tedit_submode = NULL;\n\tshowmode();\n    }\n#ifdef FEAT_CMDWIN\n    if (c == Ctrl_C && cmdwin_type != 0)\n\tupdate_screen(0);\n#endif\n    if (want_cindent && in_cinkeys(KEY_COMPLETE, ' ', inindent(0)))\n\tdo_c_expr_indent();\n    ins_apply_autocmds(EVENT_COMPLETEDONE);\n    return retval;\n}", "target": 1}
{"code": "static void iowarrior_disconnect(struct usb_interface *interface)\n{\n\tstruct iowarrior *dev;\n\tint minor;\n\tdev = usb_get_intfdata(interface);\n\tmutex_lock(&iowarrior_open_disc_lock);\n\tusb_set_intfdata(interface, NULL);\n\tdev->present = 0;\n\tminor = dev->minor;\n\tmutex_unlock(&iowarrior_open_disc_lock);\n\tusb_deregister_dev(interface, &iowarrior_class);\n\tmutex_lock(&dev->mutex);\n\tmutex_unlock(&dev->mutex);\n\tif (dev->opened) {\n\t\tusb_kill_urb(dev->int_in_urb);\n\t\twake_up_interruptible(&dev->read_wait);\n\t\twake_up_interruptible(&dev->write_wait);\n\t} else {\n\t\tiowarrior_delete(dev);\n\t}\n\tdev_info(&interface->dev, \"I/O-Warror #%d now disconnected\\n\",\n\t\t minor - IOWARRIOR_MINOR_BASE);\n}", "target": 1}
{"code": "xcf_load_stream (Gimp          *gimp,\n                 GInputStream  *input,\n                 GFile         *input_file,\n                 GimpProgress  *progress,\n                 GError       **error)\n{\n  XcfInfo      info  = { 0, };\n  const gchar *filename;\n  GimpImage   *image = NULL;\n  gchar        id[14];\n  gboolean     success;\n  g_return_val_if_fail (GIMP_IS_GIMP (gimp), NULL);\n  g_return_val_if_fail (G_IS_INPUT_STREAM (input), NULL);\n  g_return_val_if_fail (input_file == NULL || G_IS_FILE (input_file), NULL);\n  g_return_val_if_fail (progress == NULL || GIMP_IS_PROGRESS (progress), NULL);\n  g_return_val_if_fail (error == NULL || *error == NULL, NULL);\n  if (input_file)\n    filename = gimp_file_get_utf8_name (input_file);\n  else\n    filename = _(\"Memory Stream\");\n  info.gimp             = gimp;\n  info.input            = input;\n  info.seekable         = G_SEEKABLE (input);\n  info.bytes_per_offset = 4;\n  info.progress         = progress;\n  info.file             = input_file;\n  info.compression      = COMPRESS_NONE;\n  if (progress)\n    gimp_progress_start (progress, FALSE, _(\"Opening '%s'\"), filename);\n  success = TRUE;\n  xcf_read_int8 (&info, (guint8 *) id, 14);\n  if (! g_str_has_prefix (id, \"gimp xcf \"))\n    {\n      success = FALSE;\n    }\n  else if (strcmp (id + 9, \"file\") == 0)\n    {\n      info.file_version = 0;\n    }\n  else if (id[9] == 'v')\n    {\n      info.file_version = atoi (id + 10);\n    }\n  else\n    {\n      success = FALSE;\n    }\n  if (info.file_version >= 11)\n    info.bytes_per_offset = 8;\n  if (success)\n    {\n      if (info.file_version >= 0 &&\n          info.file_version < G_N_ELEMENTS (xcf_loaders))\n        {\n          image = (*(xcf_loaders[info.file_version])) (gimp, &info, error);\n          if (! image)\n            success = FALSE;\n          g_input_stream_close (info.input, NULL, NULL);\n        }\n      else\n        {\n          g_set_error (error, G_FILE_ERROR, G_FILE_ERROR_FAILED,\n                       _(\"XCF error: unsupported XCF file version %d \"\n                         \"encountered\"), info.file_version);\n          success = FALSE;\n        }\n    }\n  if (progress)\n    gimp_progress_end (progress);\n  return image;\n}", "target": 1}
{"code": "static void RemoveICCProfileFromResourceBlock(StringInfo *bim_profile)\n{\n  register const unsigned char\n    *p;\n  size_t\n    length;\n  unsigned char\n    *datum;\n  unsigned int\n    count,\n    long_sans;\n  unsigned short\n    id,\n    short_sans;\n  length=GetStringInfoLength(bim_profile);\n  if (length < 16)\n    return;\n  datum=GetStringInfoDatum(bim_profile);\n  for (p=datum; (p >= datum) && (p < (datum+length-16)); )\n  {\n    register unsigned char\n      *q;\n    q=(unsigned char *) p;\n    if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n      break;\n    p=PushLongPixel(MSBEndian,p,&long_sans);\n    p=PushShortPixel(MSBEndian,p,&id);\n    p=PushShortPixel(MSBEndian,p,&short_sans);\n     p=PushLongPixel(MSBEndian,p,&count);\n     if (id == 0x0000040f)\n       {\n        (void) CopyMagickMemory(q,q+PSDQuantum(count)+12,length-\n          (PSDQuantum(count)+12)-(q-datum));\n        SetStringInfoLength(bim_profile,length-(PSDQuantum(count)+12));\n         break;\n       }\n     p+=count;\n    if ((count & 0x01) != 0)\n      p++;\n  }\n}", "target": 1}
{"code": "Status CompressElement(const std::vector<Tensor>& element,\n                       CompressedElement* out) {\n  std::vector<TensorProto> non_memcpy_components;\n  int64 total_size = 0;\n  for (auto& component : element) {\n    if (DataTypeCanUseMemcpy(component.dtype())) {\n      total_size += DMAHelper::buffer(&component)->size();\n    } else {\n      non_memcpy_components.emplace_back();\n      component.AsProtoTensorContent(&non_memcpy_components.back());\n      total_size += non_memcpy_components.back().ByteSizeLong();\n    }\n  }\n  tstring uncompressed;\n  uncompressed.resize_uninitialized(total_size);\n  char* position = uncompressed.mdata();\n  int non_memcpy_component_index = 0;\n  for (auto& component : element) {\n    CompressedComponentMetadata* metadata =\n        out->mutable_component_metadata()->Add();\n    metadata->set_dtype(component.dtype());\n    component.shape().AsProto(metadata->mutable_tensor_shape());\n    if (DataTypeCanUseMemcpy(component.dtype())) {\n      const TensorBuffer* buffer = DMAHelper::buffer(&component);\n      memcpy(position, buffer->data(), buffer->size());\n      metadata->set_tensor_size_bytes(buffer->size());\n    } else {\n      TensorProto& proto = non_memcpy_components[non_memcpy_component_index++];\n      proto.SerializeToArray(position, proto.ByteSizeLong());\n      metadata->set_tensor_size_bytes(proto.ByteSizeLong());\n    }\n    position += metadata->tensor_size_bytes();\n  }\n  DCHECK_EQ(position, uncompressed.mdata() + total_size);\n  if (!port::Snappy_Compress(uncompressed.mdata(), total_size,\n                             out->mutable_data())) {\n    return errors::Internal(\"Failed to compress using snappy.\");\n  }\n  VLOG(3) << \"Compressed element from \" << total_size << \" bytes to \"\n          << out->data().size() << \" bytes\";\n  return Status::OK();\n}", "target": 1}
{"code": "static int asn1_find_indefinite_length(const unsigned char *data, size_t datalen,\n\t\t\t\t       size_t *_dp, size_t *_len,\n\t\t\t\t       const char **_errmsg)\n{\n\tunsigned char tag, tmp;\n\tsize_t dp = *_dp, len, n;\n\tint indef_level = 1;\nnext_tag:\n\tif (unlikely(datalen - dp < 2)) {\n\t\tif (datalen == dp)\n\t\t\tgoto missing_eoc;\n\t\tgoto data_overrun_error;\n\t}\n \ttag = data[dp++];\n\tif (tag == 0) {\n \t\tif (data[dp++] != 0)\n \t\t\tgoto invalid_eoc;\n\t\tif (--indef_level <= 0) {\n\t\t\t*_len = dp - *_dp;\n\t\t\t*_dp = dp;\n\t\t\treturn 0;\n\t\t}\n\t\tgoto next_tag;\n\t}\n\tif (unlikely((tag & 0x1f) == ASN1_LONG_TAG)) {\n\t\tdo {\n\t\t\tif (unlikely(datalen - dp < 2))\n\t\t\t\tgoto data_overrun_error;\n\t\t\ttmp = data[dp++];\n\t\t} while (tmp & 0x80);\n\t}\n \tlen = data[dp++];\n\tif (len <= 0x7f) {\n\t\tdp += len;\n\t\tgoto next_tag;\n\t}\n \tif (unlikely(len == ASN1_INDEFINITE_LENGTH)) {\n\t\tif (unlikely((tag & ASN1_CONS_BIT) == ASN1_PRIM << 5))\n\t\t\tgoto indefinite_len_primitive;\n\t\tindef_level++;\n\t\tgoto next_tag;\n \t}\n \tn = len - 0x80;\n\tif (unlikely(n > sizeof(size_t) - 1))\n \t\tgoto length_too_long;\n \tif (unlikely(n > datalen - dp))\n \t\tgoto data_overrun_error;\n\tfor (len = 0; n > 0; n--) {\n \t\tlen <<= 8;\n \t\tlen |= data[dp++];\n \t}\n \tdp += len;\n \tgoto next_tag;\nlength_too_long:\n\t*_errmsg = \"Unsupported length\";\n\tgoto error;\nindefinite_len_primitive:\n\t*_errmsg = \"Indefinite len primitive not permitted\";\n\tgoto error;\ninvalid_eoc:\n\t*_errmsg = \"Invalid length EOC\";\n\tgoto error;\ndata_overrun_error:\n\t*_errmsg = \"Data overrun error\";\n\tgoto error;\nmissing_eoc:\n\t*_errmsg = \"Missing EOC in indefinite len cons\";\nerror:\n\t*_dp = dp;\n\treturn -1;\n}", "target": 1}
{"code": " bool NavigateToUrlWithEdge(const base::string16& url) {\n   base::string16 protocol_url = L\"microsoft-edge:\" + url;\n   SHELLEXECUTEINFO info = { sizeof(info) };\n  info.fMask = SEE_MASK_NOASYNC | SEE_MASK_FLAG_NO_UI;\n   info.lpVerb = L\"open\";\n   info.lpFile = protocol_url.c_str();\n   info.nShow = SW_SHOWNORMAL;\n  if (::ShellExecuteEx(&info))\n    return true;\n  PLOG(ERROR) << \"Failed to launch Edge for uninstall survey\";\n  return false;\n}", "target": 1}
{"code": "static int rfcomm_get_dev_list(void __user *arg)\n{\n\tstruct rfcomm_dev *dev;\n\tstruct rfcomm_dev_list_req *dl;\n\tstruct rfcomm_dev_info *di;\n\tint n = 0, size, err;\n\tu16 dev_num;\n\tBT_DBG(\"\");\n\tif (get_user(dev_num, (u16 __user *) arg))\n\t\treturn -EFAULT;\n\tif (!dev_num || dev_num > (PAGE_SIZE * 4) / sizeof(*di))\n\t\treturn -EINVAL;\n \tsize = sizeof(*dl) + dev_num * sizeof(*di);\n\tdl = kmalloc(size, GFP_KERNEL);\n \tif (!dl)\n \t\treturn -ENOMEM;\n\tdi = dl->dev_info;\n\tspin_lock(&rfcomm_dev_lock);\n\tlist_for_each_entry(dev, &rfcomm_dev_list, list) {\n\t\tif (test_bit(RFCOMM_TTY_RELEASED, &dev->flags))\n\t\t\tcontinue;\n\t\t(di + n)->id      = dev->id;\n\t\t(di + n)->flags   = dev->flags;\n\t\t(di + n)->state   = dev->dlc->state;\n\t\t(di + n)->channel = dev->channel;\n\t\tbacpy(&(di + n)->src, &dev->src);\n\t\tbacpy(&(di + n)->dst, &dev->dst);\n\t\tif (++n >= dev_num)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&rfcomm_dev_lock);\n\tdl->dev_num = n;\n\tsize = sizeof(*dl) + n * sizeof(*di);\n\terr = copy_to_user(arg, dl, size);\n\tkfree(dl);\n\treturn err ? -EFAULT : 0;\n}", "target": 1}
{"code": "static int read_tfra(MOVContext *mov, AVIOContext *f)\n{\n    MOVFragmentIndex* index = NULL;\n    int version, fieldlength, i, j;\n    int64_t pos = avio_tell(f);\n    uint32_t size = avio_rb32(f);\n    void *tmp;\n    if (avio_rb32(f) != MKBETAG('t', 'f', 'r', 'a')) {\n        return 1;\n    }\n    av_log(mov->fc, AV_LOG_VERBOSE, \"found tfra\\n\");\n    index = av_mallocz(sizeof(MOVFragmentIndex));\n    if (!index) {\n        return AVERROR(ENOMEM);\n    }\n    tmp = av_realloc_array(mov->fragment_index_data,\n                           mov->fragment_index_count + 1,\n                           sizeof(MOVFragmentIndex*));\n    if (!tmp) {\n        av_freep(&index);\n        return AVERROR(ENOMEM);\n    }\n    mov->fragment_index_data = tmp;\n    mov->fragment_index_data[mov->fragment_index_count++] = index;\n    version = avio_r8(f);\n    avio_rb24(f);\n    index->track_id = avio_rb32(f);\n    fieldlength = avio_rb32(f);\n    index->item_count = avio_rb32(f);\n    index->items = av_mallocz_array(\n            index->item_count, sizeof(MOVFragmentIndexItem));\n    if (!index->items) {\n        index->item_count = 0;\n        return AVERROR(ENOMEM);\n     }\n     for (i = 0; i < index->item_count; i++) {\n         int64_t time, offset;\n         if (version == 1) {\n             time   = avio_rb64(f);\n             offset = avio_rb64(f);\n        } else {\n            time   = avio_rb32(f);\n            offset = avio_rb32(f);\n        }\n        index->items[i].time = time;\n        index->items[i].moof_offset = offset;\n        for (j = 0; j < ((fieldlength >> 4) & 3) + 1; j++)\n            avio_r8(f);\n        for (j = 0; j < ((fieldlength >> 2) & 3) + 1; j++)\n            avio_r8(f);\n        for (j = 0; j < ((fieldlength >> 0) & 3) + 1; j++)\n            avio_r8(f);\n    }\n    avio_seek(f, pos + size, SEEK_SET);\n    return 0;\n}", "target": 1}
{"code": "static int php_openssl_validate_iv(char **piv, size_t *piv_len, size_t iv_required_len,\n\t\tzend_bool *free_iv, EVP_CIPHER_CTX *cipher_ctx, struct php_openssl_cipher_mode *mode) \n{\n\tchar *iv_new;\n\tif (*piv_len == iv_required_len) {\n\t\treturn SUCCESS;\n\t}\n\tif (mode->is_aead) {\n\t\tif (EVP_CIPHER_CTX_ctrl(cipher_ctx, mode->aead_ivlen_flag, *piv_len, NULL) != 1) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Setting of IV length for AEAD mode failed\");\n\t\t\treturn FAILURE;\n\t\t}\n\t\treturn SUCCESS;\n\t}\n\tiv_new = ecalloc(1, iv_required_len + 1);\n\tif (*piv_len == 0) {\n\t\t*piv_len = iv_required_len;\n\t\t*piv = iv_new;\n\t\t*free_iv = 1;\n\t\treturn SUCCESS;\n\t}\n\tif (*piv_len < iv_required_len) {\n\t\tphp_error_docref(NULL, E_WARNING,\n\t\t\t\t\"IV passed is only %zd bytes long, cipher expects an IV of precisely %zd bytes, padding with \\\\0\",\n\t\t\t\t*piv_len, iv_required_len);\n\t\tmemcpy(iv_new, *piv, *piv_len);\n\t\t*piv_len = iv_required_len;\n\t\t*piv = iv_new;\n\t\t*free_iv = 1;\n\t\treturn SUCCESS;\n\t}\n\tphp_error_docref(NULL, E_WARNING,\n\t\t\t\"IV passed is %zd bytes long which is longer than the %zd expected by selected cipher, truncating\",\n\t\t\t*piv_len, iv_required_len);\n\tmemcpy(iv_new, *piv, iv_required_len);\n\t*piv_len = iv_required_len;\n\t*piv = iv_new;\n\t*free_iv = 1;\n\treturn SUCCESS;\n}", "target": 1}
{"code": "void faad_resetbits(bitfile *ld, int bits)\n{\n    uint32_t tmp;\n    int words = bits >> 5;\n    int remainder = bits & 0x1F;\n    ld->bytes_left = ld->buffer_size - words*4;\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(&ld->start[words]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(&ld->start[words], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufa = tmp;\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(&ld->start[words+1]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(&ld->start[words+1], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufb = tmp;\n    ld->bits_left = 32 - remainder;\n    ld->tail = &ld->start[words+2];\n    ld->error = 0;\n}", "target": 1}
{"code": "static void put_ucounts(struct ucounts *ucounts)\n {\n \tunsigned long flags;\n\tif (atomic_dec_and_test(&ucounts->count)) {\n\t\tspin_lock_irqsave(&ucounts_lock, flags);\n \t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\t\tkfree(ucounts);\n\t}\n }", "target": 1}
{"code": "gdImagePtr gdImageCrop(gdImagePtr src, const gdRectPtr crop)\n{\n\tgdImagePtr dst;\n\tint y;\n\tif (crop->width<=0 || crop->height<=0) {\n\t\treturn NULL;\n\t}\n\tif (src->trueColor) {\n\t\tdst = gdImageCreateTrueColor(crop->width, crop->height);\n\t\tgdImageSaveAlpha(dst, 1);\n\t} else {\n\t\tdst = gdImageCreate(crop->width, crop->height);\n\t\tgdImagePaletteCopy(dst, src);\n\t}\n\tif (dst == NULL) {\n\t\treturn NULL;\n\t}\n\tdst->transparent = src->transparent;\n\tif (crop->x < 0 || crop->x>=src->sx || crop->y<0 || crop->y>=src->sy) {\n\t\treturn dst;\n\t}\n\tif ((src->sx - crop->width) < crop->x) {\n\t\tcrop->width = src->sx - crop->x;\n\t}\n\tif ((src->sy - crop->height) < crop->y) {\n\t\tcrop->height = src->sy - crop->y;\n\t}\n#if 0\nprintf(\"rect->x: %i\\nrect->y: %i\\nrect->width: %i\\nrect->height: %i\\n\", crop->x, crop->y, crop->width, crop->height);\n#endif\n\ty = crop->y;\n\tif (src->trueColor) {\n\t\tunsigned int dst_y = 0;\n\t\twhile (y < (crop->y + (crop->height - 1))) {\n\t\t\tmemcpy(dst->tpixels[dst_y++], src->tpixels[y++] + crop->x, crop->width * 4);\n\t\t}\n\t} else {\n\t\tint x;\n\t\tfor (y = crop->y; y < (crop->y + (crop->height - 1)); y++) {\n\t\t\tfor (x = crop->x; x < (crop->x + (crop->width - 1)); x++) {\n\t\t\t\tdst->pixels[y - crop->y][x - crop->x] = src->pixels[y][x];\n\t\t\t}\n\t\t}\n\t}\n\treturn dst;\n}", "target": 1}
{"code": "static const char *quote_arg(const char *arg)\n{\n\tint len = 0, n = 0;\n\tint force_quotes = 0;\n\tchar *q, *d;\n\tconst char *p = arg;\n\tif (!*p) force_quotes = 1;\n\twhile (*p) {\n\t\tif (isspace(*p) || *p == '*' || *p == '?' || *p == '{' || *p == '\\'')\n\t\t\tforce_quotes = 1;\n\t\telse if (*p == '\"')\n\t\t\tn++;\n\t\telse if (*p == '\\\\') {\n\t\t\tint count = 0;\n\t\t\twhile (*p == '\\\\') {\n\t\t\t\tcount++;\n\t\t\t\tp++;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t\tif (*p == '\"')\n\t\t\t\tn += count*2 + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tlen++;\n\t\tp++;\n\t}\n\tif (!force_quotes && n == 0)\n\t\treturn arg;\n\td = q = xmalloc(st_add3(len, n, 3));\n\t*d++ = '\"';\n\twhile (*arg) {\n\t\tif (*arg == '\"')\n\t\t\t*d++ = '\\\\';\n\t\telse if (*arg == '\\\\') {\n\t\t\tint count = 0;\n\t\t\twhile (*arg == '\\\\') {\n\t\t\t\tcount++;\n\t\t\t\t*d++ = *arg++;\n\t\t\t}\n\t\t\tif (*arg == '\"') {\n\t\t\t\twhile (count-- > 0)\n\t\t\t\t\t*d++ = '\\\\';\n\t\t\t\t*d++ = '\\\\';\n\t\t\t}\n\t\t}\n\t\t*d++ = *arg++;\n\t}\n\t*d++ = '\"';\n\t*d++ = 0;\n\treturn q;\n}", "target": 1}
{"code": "  ps_parser_skip_PS_token( PS_Parser  parser )\n  {\n    FT_Byte*  cur   = parser->cursor;\n    FT_Byte*  limit = parser->limit;\n    FT_Error  error = FT_Err_Ok;\n    skip_spaces( &cur, limit );             \n    if ( cur >= limit )\n      goto Exit;\n    if ( *cur == '[' || *cur == ']' )\n    {\n      cur++;\n      goto Exit;\n    }\n    if ( *cur == '{' )                              \n    {\n      error = skip_procedure( &cur, limit );\n      goto Exit;\n    }\n    if ( *cur == '(' )                              \n    {\n      error = skip_literal_string( &cur, limit );\n      goto Exit;\n    }\n    if ( *cur == '<' )                              \n    {\n      if ( cur + 1 < limit && *(cur + 1) == '<' )   \n      {\n        cur++;\n        cur++;\n      }\n      else\n        error = skip_string( &cur, limit );\n      goto Exit;\n    }\n    if ( *cur == '>' )\n    {\n      cur++;\n      if ( cur >= limit || *cur != '>' )             \n      {\n        FT_ERROR(( \"ps_parser_skip_PS_token:\"\n                   \" unexpected closing delimiter `>'\\n\" ));\n        error = FT_THROW( Invalid_File_Format );\n        goto Exit;\n      }\n      cur++;\n      goto Exit;\n    }\n    if ( *cur == '/' )\n      cur++;\n    while ( cur < limit )\n    {\n      if ( IS_PS_DELIM( *cur ) )\n        break;\n      cur++;\n    }\n  Exit:\n    if ( cur < limit && cur == parser->cursor )\n    {\n      FT_ERROR(( \"ps_parser_skip_PS_token:\"\n                 \" current token is `%c' which is self-delimiting\\n\"\n                 \"                        \"\n                 \" but invalid at this point\\n\",\n                 *cur ));\n       error = FT_THROW( Invalid_File_Format );\n     }\n     parser->error  = error;\n     parser->cursor = cur;\n   }", "target": 1}
{"code": "TEE_Result syscall_cryp_obj_populate(unsigned long obj,\n\t\t\tstruct utee_attribute *usr_attrs,\n\t\t\tunsigned long attr_count)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tTEE_Attribute *attrs = NULL;\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n \tif (!type_props)\n \t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\tattrs = malloc(sizeof(TEE_Attribute) * attr_count);\n \tif (!attrs)\n \t\treturn TEE_ERROR_OUT_OF_MEMORY;\n \tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_attrs, attr_count,\n \t\t\t    attrs);\n \tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_POPULATE, type_props,\n\t\t\t\t      attrs, attr_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\tres = tee_svc_cryp_obj_populate_type(o, type_props, attrs, attr_count);\n\tif (res == TEE_SUCCESS)\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\nout:\n\tfree(attrs);\n\treturn res;\n}", "target": 1}
{"code": "static int hiddev_open(struct inode *inode, struct file *file)\n{\n\tstruct hiddev_list *list;\n\tstruct usb_interface *intf;\n\tstruct hid_device *hid;\n\tstruct hiddev *hiddev;\n\tint res;\n\tintf = usbhid_find_interface(iminor(inode));\n\tif (!intf)\n\t\treturn -ENODEV;\n\thid = usb_get_intfdata(intf);\n\thiddev = hid->hiddev;\n\tif (!(list = vzalloc(sizeof(struct hiddev_list))))\n\t\treturn -ENOMEM;\n\tmutex_init(&list->thread_lock);\n\tlist->hiddev = hiddev;\n\tfile->private_data = list;\n\tif (list->hiddev->exist) {\n\t\tif (!list->hiddev->open++) {\n\t\t\tres = hid_hw_open(hiddev->hid);\n\t\t\tif (res < 0)\n\t\t\t\tgoto bail;\n\t\t}\n\t} else {\n\t\tres = -ENODEV;\n\t\tgoto bail;\n\t}\n\tspin_lock_irq(&list->hiddev->list_lock);\n\tlist_add_tail(&list->node, &hiddev->list);\n\tspin_unlock_irq(&list->hiddev->list_lock);\n\tmutex_lock(&hiddev->existancelock);\n\tif (!list->hiddev->open++)\n\t\tif (list->hiddev->exist) {\n\t\t\tstruct hid_device *hid = hiddev->hid;\n\t\t\tres = hid_hw_power(hid, PM_HINT_FULLON);\n\t\t\tif (res < 0)\n\t\t\t\tgoto bail_unlock;\n\t\t\tres = hid_hw_open(hid);\n\t\t\tif (res < 0)\n\t\t\t\tgoto bail_normal_power;\n\t\t}\n\tmutex_unlock(&hiddev->existancelock);\n\treturn 0;\nbail_normal_power:\n\thid_hw_power(hid, PM_HINT_NORMAL);\nbail_unlock:\n\tmutex_unlock(&hiddev->existancelock);\nbail:\n\tfile->private_data = NULL;\n\tvfree(list);\n\treturn res;\n}", "target": 1}
{"code": "SPL_METHOD(SplDoublyLinkedList, unserialize)\n{\n\tspl_dllist_object     *intern   = (spl_dllist_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tzval                  *flags, *elem;\n\tchar *buf;\n\tint buf_len;\n\tconst unsigned char *p, *s;\n\tphp_unserialize_data_t var_hash;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &buf, &buf_len) == FAILURE) {\n\t\treturn;\n\t}\n\tif (buf_len == 0) {\n\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Serialized string cannot be empty\");\n\t\treturn;\n\t}\n\ts = p = (const unsigned char*)buf;\n\tPHP_VAR_UNSERIALIZE_INIT(var_hash);\n\tALLOC_INIT_ZVAL(flags);\n\tif (!php_var_unserialize(&flags, &p, s + buf_len, &var_hash TSRMLS_CC) || Z_TYPE_P(flags) != IS_LONG) {\n\t\tzval_ptr_dtor(&flags);\n\t\tgoto error;\n\t}\n\tintern->flags = Z_LVAL_P(flags);\n\tzval_ptr_dtor(&flags);\n\twhile(*p == ':') {\n\t\t++p;\n\t\tALLOC_INIT_ZVAL(elem);\n\t\tif (!php_var_unserialize(&elem, &p, s + buf_len, &var_hash TSRMLS_CC)) {\n\t\t\tzval_ptr_dtor(&elem);\n\t\t\tgoto error;\n\t\t}\n\t\tspl_ptr_llist_push(intern->llist, elem TSRMLS_CC);\n\t}\n\tif (*p != '\\0') {\n\t\tgoto error;\n\t}\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\treturn;\nerror:\n\tPHP_VAR_UNSERIALIZE_DESTROY(var_hash);\n\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0 TSRMLS_CC, \"Error at offset %ld of %d bytes\", (long)((char*)p - buf), buf_len);\n\treturn;\n} ", "target": 1}
{"code": "zzip_disk_entry_fopen (ZZIP_DISK* disk, ZZIP_DISK_ENTRY* entry)\n{\n    ZZIP_DISK_FILE* file = malloc(sizeof(ZZIP_DISK_FILE));\n    if (! file) return file;\n    file->buffer = disk->buffer;\n    file->endbuf = disk->endbuf;\n    file->header = zzip_disk_entry_to_file_header (disk, entry);\n    if (! file->header) { free (file); return 0; }\n    file->avail = zzip_file_header_usize (file->header);\n    if (! file->avail || zzip_file_header_data_stored (file->header))\n    { file->stored = zzip_file_header_to_data (file->header); return file; }\n    file->stored = 0;\n    file->zlib.opaque = 0;\n    file->zlib.zalloc = Z_NULL;\n    file->zlib.zfree = Z_NULL;\n    file->zlib.avail_in = zzip_file_header_csize (file->header);\n    file->zlib.next_in = zzip_file_header_to_data (file->header);\n    if (! zzip_file_header_data_deflated (file->header) ||\n\tinflateInit2 (& file->zlib, -MAX_WBITS) != Z_OK)\n    { free (file); return 0; }\n    return file;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    OpInputList params_nested_splits_in;\n    OP_REQUIRES_OK(context, context->input_list(\"params_nested_splits\",\n                                                &params_nested_splits_in));\n    const Tensor& params_dense_values_in =\n        context->input(params_nested_splits_in.size());\n    const Tensor& indices_in =\n        context->input(params_nested_splits_in.size() + 1);\n    DCHECK_GT(params_nested_splits_in.size(), 0);  \n    SPLITS_TYPE num_params = params_nested_splits_in[0].dim_size(0) - 1;\n    OP_REQUIRES_OK(context, ValidateIndices(indices_in, num_params));\n    OP_REQUIRES(context, params_dense_values_in.dims() > 0,\n                errors::InvalidArgument(\"params.rank must be nonzero\"));\n    SPLITS_TYPE num_params_dense_values = params_dense_values_in.dim_size(0);\n    std::vector<std::pair<SPLITS_TYPE, SPLITS_TYPE>> value_slices;\n    SPLITS_TYPE num_values = 0;\n    std::vector<std::vector<SPLITS_TYPE>> out_splits;\n    OP_REQUIRES_OK(context, MakeSplits(indices_in, params_nested_splits_in,\n                                       num_params_dense_values, &out_splits,\n                                       &value_slices, &num_values));\n    OP_REQUIRES_OK(context, WriteSplits(out_splits, context));\n    OP_REQUIRES_OK(context,\n                   WriteValues(params_dense_values_in, value_slices,\n                               out_splits.size(), num_values, context));\n  }", "target": 1}
{"code": "void CredentialManagerImpl::OnProvisionalSaveComplete() {\n  DCHECK(form_manager_);\n  DCHECK(client_->IsSavingAndFillingEnabledForCurrentPage());\n  const autofill::PasswordForm& form = form_manager_->pending_credentials();\n  if (form_manager_->IsPendingCredentialsPublicSuffixMatch()) {\n    form_manager_->Save();\n    return;\n  }\n  if (!form.federation_origin.unique()) {\n    for (auto* match : form_manager_->form_fetcher()->GetFederatedMatches()) {\n      if (match->username_value == form.username_value &&\n          match->federation_origin.IsSameOriginWith(form.federation_origin)) {\n        form_manager_->Update(*match);\n        return;\n      }\n    }\n  } else if (!form_manager_->IsNewLogin()) {\n    form_manager_->Update(*form_manager_->preferred_match());\n     return;\n   }\n  client_->PromptUserToSaveOrUpdatePassword(std::move(form_manager_), false);\n}", "target": 1}
{"code": "void vp8_deblock(VP8_COMMON *cm, YV12_BUFFER_CONFIG *source,\n                 YV12_BUFFER_CONFIG *post, int q, int low_var_thresh,\n                 int flag) {\n  double level = 6.0e-05 * q * q * q - .0067 * q * q + .306 * q + .0065;\n  int ppl = (int)(level + .5);\n  const MODE_INFO *mode_info_context = cm->show_frame_mi;\n  int mbr, mbc;\n  unsigned char *ylimits = cm->pp_limits_buffer;\n  unsigned char *uvlimits = cm->pp_limits_buffer + 16 * cm->mb_cols;\n  (void)low_var_thresh;\n  (void)flag;\n  if (ppl > 0) {\n    for (mbr = 0; mbr < cm->mb_rows; ++mbr) {\n      unsigned char *ylptr = ylimits;\n      unsigned char *uvlptr = uvlimits;\n      for (mbc = 0; mbc < cm->mb_cols; ++mbc) {\n        unsigned char mb_ppl;\n        if (mode_info_context->mbmi.mb_skip_coeff) {\n          mb_ppl = (unsigned char)ppl >> 1;\n        } else {\n          mb_ppl = (unsigned char)ppl;\n        }\n        memset(ylptr, mb_ppl, 16);\n        memset(uvlptr, mb_ppl, 8);\n        ylptr += 16;\n        uvlptr += 8;\n        mode_info_context++;\n      }\n      mode_info_context++;\n      vpx_post_proc_down_and_across_mb_row(\n          source->y_buffer + 16 * mbr * source->y_stride,\n          post->y_buffer + 16 * mbr * post->y_stride, source->y_stride,\n          post->y_stride, source->y_width, ylimits, 16);\n      vpx_post_proc_down_and_across_mb_row(\n          source->u_buffer + 8 * mbr * source->uv_stride,\n          post->u_buffer + 8 * mbr * post->uv_stride, source->uv_stride,\n          post->uv_stride, source->uv_width, uvlimits, 8);\n      vpx_post_proc_down_and_across_mb_row(\n          source->v_buffer + 8 * mbr * source->uv_stride,\n          post->v_buffer + 8 * mbr * post->uv_stride, source->uv_stride,\n          post->uv_stride, source->uv_width, uvlimits, 8);\n    }\n  } else {\n    vp8_yv12_copy_frame(source, post);\n  }\n}", "target": 1}
{"code": "    OVS_REQUIRES(ofproto_mutex)\n{\n     const struct rule_actions *actions = rule_get_actions(rule);\n    ovs_assert(rule->state == RULE_INITIALIZED);\n     if (rule->hard_timeout || rule->idle_timeout) {\n         ovs_list_insert(&ofproto->expirable, &rule->expirable);\n    }\n    cookies_insert(ofproto, rule);\n    eviction_group_add_rule(rule);\n    if (actions->has_meter) {\n        meter_insert_rule(rule);\n    }\n    if (actions->has_groups) {\n        const struct ofpact_group *a;\n        OFPACT_FOR_EACH_TYPE_FLATTENED (a, GROUP, actions->ofpacts,\n                                        actions->ofpacts_len) {\n            struct ofgroup *group;\n            group = ofproto_group_lookup(ofproto, a->group_id, OVS_VERSION_MAX,\n                                         false);\n            ovs_assert(group != NULL);\n            group_add_rule(group, rule);\n        }\n    }\n    rule->state = RULE_INSERTED;\n}", "target": 1}
{"code": "void sdb_edit(procinfo *pi)\n{\n  char * filename = omStrDup(\"/tmp/sd000000\");\n  sprintf(filename+7,\"%d\",getpid());\n  FILE *fp=fopen(filename,\"w\");\n  if (fp==NULL)\n  {\n    Print(\"cannot open %s\\n\",filename);\n    omFree(filename);\n    return;\n  }\n  if (pi->language!= LANG_SINGULAR)\n  {\n    Print(\"cannot edit type %d\\n\",pi->language);\n    fclose(fp);\n    fp=NULL;\n  }\n  else\n  {\n    const char *editor=getenv(\"EDITOR\");\n    if (editor==NULL)\n      editor=getenv(\"VISUAL\");\n    if (editor==NULL)\n      editor=\"vi\";\n    editor=omStrDup(editor);\n    if (pi->data.s.body==NULL)\n    {\n      iiGetLibProcBuffer(pi);\n      if (pi->data.s.body==NULL)\n      {\n        PrintS(\"cannot get the procedure body\\n\");\n        fclose(fp);\n        si_unlink(filename);\n        omFree(filename);\n        return;\n      }\n    }\n    fwrite(pi->data.s.body,1,strlen(pi->data.s.body),fp);\n    fclose(fp);\n    int pid=fork();\n    if (pid!=0)\n    {\n      si_wait(&pid);\n    }\n    else if(pid==0)\n    {\n      if (strchr(editor,' ')==NULL)\n      {\n        execlp(editor,editor,filename,NULL);\n        Print(\"cannot exec %s\\n\",editor);\n      }\n      else\n      {\n        char *p=(char *)omAlloc(strlen(editor)+strlen(filename)+2);\n        sprintf(p,\"%s %s\",editor,filename);\n        system(p);\n      }\n      exit(0);\n    }\n    else\n    {\n      PrintS(\"cannot fork\\n\");\n    }\n    fp=fopen(filename,\"r\");\n    if (fp==NULL)\n    {\n      Print(\"cannot read from %s\\n\",filename);\n    }\n    else\n    {\n      fseek(fp,0L,SEEK_END);\n      long len=ftell(fp);\n      fseek(fp,0L,SEEK_SET);\n      omFree((ADDRESS)pi->data.s.body);\n      pi->data.s.body=(char *)omAlloc((int)len+1);\n      myfread( pi->data.s.body, len, 1, fp);\n      pi->data.s.body[len]='\\0';\n      fclose(fp);\n    }\n  }\n  si_unlink(filename);\n  omFree(filename);\n}", "target": 1}
{"code": "static int adis_update_scan_mode_burst(struct iio_dev *indio_dev,\n\tconst unsigned long *scan_mask)\n{\n\tstruct adis *adis = iio_device_get_drvdata(indio_dev);\n\tunsigned int burst_length;\n\tu8 *tx;\n\tburst_length = (indio_dev->num_channels - 1) * sizeof(u16);\n\tburst_length += adis->burst->extra_len;\n\tadis->xfer = kcalloc(2, sizeof(*adis->xfer), GFP_KERNEL);\n\tif (!adis->xfer)\n\t\treturn -ENOMEM;\n\tadis->buffer = kzalloc(burst_length + sizeof(u16), GFP_KERNEL);\n\tif (!adis->buffer)\n\t\treturn -ENOMEM;\n\ttx = adis->buffer + burst_length;\n\ttx[0] = ADIS_READ_REG(adis->burst->reg_cmd);\n\ttx[1] = 0;\n\tadis->xfer[0].tx_buf = tx;\n\tadis->xfer[0].bits_per_word = 8;\n\tadis->xfer[0].len = 2;\n\tadis->xfer[1].rx_buf = adis->buffer;\n\tadis->xfer[1].bits_per_word = 8;\n\tadis->xfer[1].len = burst_length;\n\tspi_message_init(&adis->msg);\n\tspi_message_add_tail(&adis->xfer[0], &adis->msg);\n\tspi_message_add_tail(&adis->xfer[1], &adis->msg);\n\treturn 0;\n}", "target": 1}
{"code": "int main(int argc, char **argv)\n{\n    int fd;\n    int ret;\n    fd = mkstemp(test_image);\n    g_assert(fd >= 0);\n    ret = ftruncate(fd, TEST_IMAGE_SIZE);\n    g_assert(ret == 0);\n    close(fd);\n    g_test_init(&argc, &argv, NULL);\n    qtest_start(\"-machine pc -device floppy,id=floppy0\");\n    qtest_irq_intercept_in(global_qtest, \"ioapic\");\n    qtest_add_func(\"/fdc/cmos\", test_cmos);\n    qtest_add_func(\"/fdc/no_media_on_start\", test_no_media_on_start);\n    qtest_add_func(\"/fdc/read_without_media\", test_read_without_media);\n    qtest_add_func(\"/fdc/media_change\", test_media_change);\n    qtest_add_func(\"/fdc/sense_interrupt\", test_sense_interrupt);\n    qtest_add_func(\"/fdc/relative_seek\", test_relative_seek);\n    qtest_add_func(\"/fdc/read_id\", test_read_id);\n    qtest_add_func(\"/fdc/verify\", test_verify);\n    qtest_add_func(\"/fdc/media_insert\", test_media_insert);\n    qtest_add_func(\"/fdc/read_no_dma_1\", test_read_no_dma_1);\n    qtest_add_func(\"/fdc/read_no_dma_18\", test_read_no_dma_18);\n    qtest_add_func(\"/fdc/read_no_dma_19\", test_read_no_dma_19);\n    qtest_add_func(\"/fdc/fuzz-registers\", fuzz_registers);\n    qtest_add_func(\"/fdc/fuzz/cve_2021_20196\", test_cve_2021_20196);\n    ret = g_test_run();\n    qtest_end();\n    unlink(test_image);\n    return ret;\n}", "target": 1}
{"code": "Status TensorSliceReader::GetTensor(\n    const string& name, std::unique_ptr<tensorflow::Tensor>* out_tensor) const {\n  DataType type;\n  TensorShape shape;\n  TensorSlice slice;\n  {\n    mutex_lock l(mu_);\n    const TensorSliceSet* tss = gtl::FindPtrOrNull(tensors_, name);\n    if (tss == nullptr) {\n      return errors::NotFound(name, \" not found in checkpoint file\");\n    }\n    if (tss->Slices().size() > 1) {\n      return errors::Unimplemented(\"Sliced checkpoints are not supported\");\n    }\n    type = tss->type();\n    shape = tss->shape();\n    slice = tss->Slices().begin()->second.slice;\n  }\n  std::unique_ptr<tensorflow::Tensor> t(new tensorflow::Tensor(type, shape));\n  bool success = false;\n#define READER_COPY(dt)                                                  \\\n  case dt:                                                               \\\n    success = CopySliceData(name, slice,                                 \\\n                            t->flat<EnumToDataType<dt>::Type>().data()); \\\n    break;\n  switch (type) {\n    READER_COPY(DT_FLOAT);\n    READER_COPY(DT_DOUBLE);\n    READER_COPY(DT_INT32);\n    READER_COPY(DT_UINT8);\n    READER_COPY(DT_INT16);\n    READER_COPY(DT_INT8);\n    READER_COPY(DT_INT64);\n    READER_COPY(DT_STRING);\n    default:\n      return errors::Unimplemented(\"Data type not supported\");\n  }\n#undef READER_COPY\n  if (!success) {\n    return errors::NotFound(name, \" not found in checkpoint file\");\n  }\n  std::swap(*out_tensor, t);\n  return Status::OK();\n}", "target": 1}
{"code": "int FuzzerTestOneInput(const uint8_t *buf, size_t len)\n{\n    const unsigned char *p = buf;\n    unsigned char *der = NULL;\n    X509 *x509 = d2i_X509(NULL, &p, len);\n    if (x509 != NULL) {\n        BIO *bio = BIO_new(BIO_s_null());\n        X509_print(bio, x509);\n        BIO_free(bio);\n        i2d_X509(x509, &der);\n        OPENSSL_free(der);\n        X509_free(x509);\n    }\n    ERR_clear_error();\n    return 0;\n}", "target": 1}
{"code": "static int ieee80211_drop_unencrypted_mgmt(struct ieee80211_rx_data *rx)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)rx->skb->data;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(rx->skb);\n\t__le16 fc = hdr->frame_control;\n\tif (status->flag & RX_FLAG_DECRYPTED)\n\t\treturn 0;\n\tif (rx->sta && test_sta_flag(rx->sta, WLAN_STA_MFP)) {\n\t\tif (unlikely(!ieee80211_has_protected(fc) &&\n\t\t\t     ieee80211_is_unicast_robust_mgmt_frame(rx->skb) &&\n\t\t\t     rx->key)) {\n\t\t\tif (ieee80211_is_deauth(fc) ||\n\t\t\t    ieee80211_is_disassoc(fc))\n\t\t\t\tcfg80211_rx_unprot_mlme_mgmt(rx->sdata->dev,\n\t\t\t\t\t\t\t     rx->skb->data,\n\t\t\t\t\t\t\t     rx->skb->len);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (unlikely(ieee80211_is_multicast_robust_mgmt_frame(rx->skb) &&\n\t\t\t     ieee80211_get_mmie_keyidx(rx->skb) < 0)) {\n\t\t\tif (ieee80211_is_deauth(fc) ||\n\t\t\t    ieee80211_is_disassoc(fc))\n\t\t\t\tcfg80211_rx_unprot_mlme_mgmt(rx->sdata->dev,\n\t\t\t\t\t\t\t     rx->skb->data,\n\t\t\t\t\t\t\t     rx->skb->len);\n\t\t\treturn -EACCES;\n\t\t}\n\t\tif (unlikely(ieee80211_is_action(fc) && !rx->key &&\n\t\t\t     ieee80211_is_robust_mgmt_frame(rx->skb)))\n\t\t\treturn -EACCES;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "join_read_prev_same(READ_RECORD *info)\n{\n  int error;\n  TABLE *table= info->table;\n  JOIN_TAB *tab=table->reginfo.join_tab;\n  if ((error= table->file->ha_index_prev(table->record[0])))\n    return report_error(table, error);\n  if (key_cmp_if_same(table, tab->ref.key_buff, tab->ref.key,\n                      tab->ref.key_length))\n  {\n    table->status=STATUS_NOT_FOUND;\n    error= -1;\n  }\n  return error;\n}", "target": 0}
{"code": "void OmniboxViewWin::OnMButtonDown(UINT , const CPoint& ) {\n  tracking_double_click_ = false;\n}", "target": 0}
{"code": "GF_VVCConfig *VVC_DuplicateConfig(GF_VVCConfig *cfg)\n{\n\tu8 *data;\n\tu32 data_size;\n\tGF_VVCConfig *new_cfg;\n\tGF_BitStream *bs;\n\tif (!cfg) return NULL;\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_odf_vvc_cfg_write_bs(cfg, bs);\n\tgf_bs_get_content(bs, &data, &data_size);\n\tgf_bs_del(bs);\n\tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\tnew_cfg = gf_odf_vvc_cfg_read_bs(bs);\n\tgf_bs_del(bs);\n\tgf_free(data);\n\treturn new_cfg;\n}", "target": 0}
{"code": "static int fixup_call_args(struct bpf_verifier_env *env)\n{\n#ifndef CONFIG_BPF_JIT_ALWAYS_ON\n\tstruct bpf_prog *prog = env->prog;\n\tstruct bpf_insn *insn = prog->insnsi;\n\tint i, depth;\n#endif\n\tint err = 0;\n\tif (env->prog->jit_requested &&\n\t    !bpf_prog_is_dev_bound(env->prog->aux)) {\n\t\terr = jit_subprogs(env);\n\t\tif (err == 0)\n\t\t\treturn 0;\n\t\tif (err == -EFAULT)\n\t\t\treturn err;\n\t}\n#ifndef CONFIG_BPF_JIT_ALWAYS_ON\n\tif (env->subprog_cnt > 1 && env->prog->aux->tail_call_reachable) {\n\t\tverbose(env, \"tail_calls are not allowed in non-JITed programs with bpf-to-bpf calls\\n\");\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < prog->len; i++, insn++) {\n\t\tif (insn->code != (BPF_JMP | BPF_CALL) ||\n\t\t    insn->src_reg != BPF_PSEUDO_CALL)\n\t\t\tcontinue;\n\t\tdepth = get_callee_stack_depth(env, insn, i);\n\t\tif (depth < 0)\n\t\t\treturn depth;\n\t\tbpf_patch_call_args(insn, depth);\n\t}\n\terr = 0;\n#endif\n\treturn err;\n}", "target": 0}
{"code": "    XmpData::iterator XmpData::erase(XmpData::iterator pos) {\n        return xmpMetadata_.erase(pos);\n    }", "target": 0}
{"code": "    bool XmpParser::initialize(XmpParser::XmpLockFct, void* )\n    {\n        initialized_ = true;\n        return initialized_;\n    }", "target": 0}
{"code": "void FrameLoader::didExplicitOpen()\n{\n    m_isComplete = false;\n    if (!m_stateMachine.committedFirstRealDocumentLoad())\n        m_stateMachine.advanceTo(FrameLoaderStateMachine::CommittedFirstRealLoad);\n    m_frame->navigationScheduler()->cancel();\n}", "target": 0}
{"code": "static int unix_dgram_peer_wake_relay(wait_queue_t *q, unsigned mode, int flags,\n\t\t\t\t      void *key)\n{\n\tstruct unix_sock *u;\n\twait_queue_head_t *u_sleep;\n\tu = container_of(q, struct unix_sock, peer_wake);\n\t__remove_wait_queue(&unix_sk(u->peer_wake.private)->peer_wait,\n\t\t\t    q);\n\tu->peer_wake.private = NULL;\n\tu_sleep = sk_sleep(&u->sk);\n\tif (u_sleep)\n\t\twake_up_interruptible_poll(u_sleep, key);\n\treturn 0;\n}", "target": 0}
{"code": "free_key_string(decryption_key_t *dk)\n{\n    if (dk->key)\n        g_string_free(dk->key, TRUE);\n    if (dk->ssid)\n        g_byte_array_free(dk->ssid, TRUE);\n    g_free(dk);\n}", "target": 0}
{"code": "AP_DECLARE(void) ap_hook_check_authz(ap_HOOK_auth_checker_t *pf,\n                                     const char * const *aszPre,\n                                     const char * const *aszSucc,\n                                     int nOrder, int type)\n{\n    if ((type & AP_AUTH_INTERNAL_MASK) == AP_AUTH_INTERNAL_PER_CONF) {\n        ++auth_internal_per_conf_hooks;\n    }\n    ap_hook_auth_checker(pf, aszPre, aszSucc, nOrder);\n}", "target": 0}
{"code": "    virtual ~ContextLifetimeTestWebFrameClient()\n    {\n        reset();\n    }", "target": 0}
{"code": "uint64_t HTMLMediaElement::webkitVideoDecodedByteCount() const {\n  if (!GetWebMediaPlayer())\n    return 0;\n  return GetWebMediaPlayer()->VideoDecodedByteCount();\n}", "target": 0}
{"code": "\tSPL_ME(SplMinHeap, compare, arginfo_heap_compare, ZEND_ACC_PROTECTED)\n\t{NULL, NULL, NULL}", "target": 0}
{"code": "int InstanceKlass::find_method_by_name(const Symbol* name, int* end) const {\n  return find_method_by_name(methods(), name, end);\n}", "target": 0}
{"code": "bool PngImg::Fill(png_uint_32 offsetX, png_uint_32 offsetY, png_uint_32 width, png_uint_32 height, const Pxl& pxl)\n{\n    if(!InBounds_(offsetX, offsetY, width, height))\n    {\n        error_ = \"Out of the bounds\";\n        return false;\n    }\n    for(size_t i = 0; i < height; ++i) {\n        for(size_t j = 0; j < width; ++j) {\n            Set_(offsetX + j, offsetY + i, pxl);\n        }\n    }\n    return true;\n}", "target": 0}
{"code": "void X509_STORE_CTX_set0_param(X509_STORE_CTX *ctx, X509_VERIFY_PARAM *param)\n{\n    X509_VERIFY_PARAM_free(ctx->param);\n    ctx->param = param;\n}", "target": 0}
{"code": "void Statement::Work_BeginRun(Baton* baton) {\n    STATEMENT_BEGIN(Run);\n}", "target": 0}
{"code": "option_to_str(char str[4], int options)\n{\n    char *p = str;\n    if (options & ONIG_OPTION_MULTILINE) *p++ = 'm';\n    if (options & ONIG_OPTION_IGNORECASE) *p++ = 'i';\n    if (options & ONIG_OPTION_EXTEND) *p++ = 'x';\n    *p = 0;\n    return str;\n}", "target": 0}
{"code": "static int create_cq(PVRDMADev *dev, union pvrdma_cmd_req *req,\n                     union pvrdma_cmd_resp *rsp)\n{\n    struct pvrdma_cmd_create_cq *cmd = &req->create_cq;\n    struct pvrdma_cmd_create_cq_resp *resp = &rsp->create_cq_resp;\n    PvrdmaRing *ring = NULL;\n    int rc;\n    memset(resp, 0, sizeof(*resp));\n    resp->cqe = cmd->cqe;\n    rc = create_cq_ring(PCI_DEVICE(dev), &ring, cmd->pdir_dma, cmd->nchunks,\n                        cmd->cqe);\n    if (rc) {\n        return rc;\n    }\n    rc = rdma_rm_alloc_cq(&dev->rdma_dev_res, &dev->backend_dev, cmd->cqe,\n                          &resp->cq_handle, ring);\n    if (rc) {\n        destroy_cq_ring(ring);\n    }\n    resp->cqe = cmd->cqe;\n    return rc;\n}", "target": 0}
{"code": "static int nl80211_probe_client(struct sk_buff *skb,\n\t\t\t\tstruct genl_info *info)\n{\n\tstruct cfg80211_registered_device *rdev = info->user_ptr[0];\n\tstruct net_device *dev = info->user_ptr[1];\n\tstruct wireless_dev *wdev = dev->ieee80211_ptr;\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tconst u8 *addr;\n\tu64 cookie;\n\tint err;\n\tif (wdev->iftype != NL80211_IFTYPE_AP &&\n\t    wdev->iftype != NL80211_IFTYPE_P2P_GO)\n\t\treturn -EOPNOTSUPP;\n\tif (!info->attrs[NL80211_ATTR_MAC])\n\t\treturn -EINVAL;\n\tif (!rdev->ops->probe_client)\n\t\treturn -EOPNOTSUPP;\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\thdr = nl80211hdr_put(msg, info->snd_portid, info->snd_seq, 0,\n\t\t\t     NL80211_CMD_PROBE_CLIENT);\n\tif (IS_ERR(hdr)) {\n\t\terr = PTR_ERR(hdr);\n\t\tgoto free_msg;\n\t}\n\taddr = nla_data(info->attrs[NL80211_ATTR_MAC]);\n\terr = rdev_probe_client(rdev, dev, addr, &cookie);\n\tif (err)\n\t\tgoto free_msg;\n\tif (nla_put_u64(msg, NL80211_ATTR_COOKIE, cookie))\n\t\tgoto nla_put_failure;\n\tgenlmsg_end(msg, hdr);\n\treturn genlmsg_reply(msg, info);\n nla_put_failure:\n\terr = -ENOBUFS;\n free_msg:\n\tnlmsg_free(msg);\n\treturn err;\n}", "target": 0}
{"code": "int Curl_single_getsock(struct Curl_easy *data,\n                        struct connectdata *conn,\n                        curl_socket_t *sock)\n{\n  int bitmap = GETSOCK_BLANK;\n  unsigned sockindex = 0;\n  if(conn->handler->perform_getsock)\n    return conn->handler->perform_getsock(data, conn, sock);\n  if((data->req.keepon & KEEP_RECVBITS) == KEEP_RECV) {\n    DEBUGASSERT(conn->sockfd != CURL_SOCKET_BAD);\n    bitmap |= GETSOCK_READSOCK(sockindex);\n    sock[sockindex] = conn->sockfd;\n  }\n  if((data->req.keepon & KEEP_SENDBITS) == KEEP_SEND) {\n    if((conn->sockfd != conn->writesockfd) ||\n       bitmap == GETSOCK_BLANK) {\n      if(bitmap != GETSOCK_BLANK)\n        sockindex++; \n      DEBUGASSERT(conn->writesockfd != CURL_SOCKET_BAD);\n      sock[sockindex] = conn->writesockfd;\n    }\n    bitmap |= GETSOCK_WRITESOCK(sockindex);\n  }\n  return bitmap;\n}", "target": 0}
{"code": "static apr_byte_t oidc_is_discovery_response(request_rec *r, oidc_cfg *cfg) {\n\treturn oidc_util_request_has_parameter(r, OIDC_DISC_OP_PARAM)\n\t\t\t|| oidc_util_request_has_parameter(r, OIDC_DISC_USER_PARAM);\n}", "target": 0}
{"code": "static inline unsigned int size_from_object(struct kmem_cache *s)\n{\n\tif (s->flags & SLAB_RED_ZONE)\n\t\treturn s->size - s->red_left_pad;\n\treturn s->size;\n}", "target": 0}
{"code": "static inline bool tok_white(const Token *x)\n{\n    return tok_type(x, TOK_WHITESPACE);\n}", "target": 0}
{"code": "pa2i(UINT8 *out_, const UINT8 *in, int xsize, const UINT8 *palette) {\n    int x;\n    INT32 *out = (INT32 *)out_;\n    for (x = 0; x < xsize; x++, in += 4) {\n        *out++ = L(&palette[in[0] * 4]) / 1000;\n    }\n}", "target": 0}
{"code": "*/\nPHP_FUNCTION(timezone_version_get)\n{\n\tconst timelib_tzdb *tzdb;\n\ttzdb = DATE_TIMEZONEDB;\n\tRETURN_STRING(tzdb->version, 1);", "target": 0}
{"code": "BOOL CSoundFile::SetPatternName(UINT nPat, LPCSTR lpszName)\n{\n        char szName[MAX_PATTERNNAME] = \"\";   \n\tif (nPat >= MAX_PATTERNS) return FALSE;\n\tif (lpszName) lstrcpyn(szName, lpszName, MAX_PATTERNNAME);\n\tszName[MAX_PATTERNNAME-1] = 0;\n\tif (!m_lpszPatternNames) m_nPatternNames = 0;\n\tif (nPat >= m_nPatternNames)\n\t{\n\t\tif (!lpszName[0]) return TRUE;\n\t\tUINT len = (nPat+1)*MAX_PATTERNNAME;\n\t\tchar *p = new char[len];   \n\t\tif (!p) return FALSE;\n\t\tmemset(p, 0, len);\n\t\tif (m_lpszPatternNames)\n\t\t{\n\t\t\tmemcpy(p, m_lpszPatternNames, m_nPatternNames * MAX_PATTERNNAME);\n\t\t\tdelete m_lpszPatternNames;\n\t\t\tm_lpszPatternNames = NULL;\n\t\t}\n\t\tm_lpszPatternNames = p;\n\t\tm_nPatternNames = nPat + 1;\n\t}\n\tmemcpy(m_lpszPatternNames + nPat * MAX_PATTERNNAME, szName, MAX_PATTERNNAME);\n\treturn TRUE;\n}", "target": 0}
{"code": "void WebContentsImpl::RendererResponsive(RenderViewHost* render_view_host) {\n  if (delegate_)\n    delegate_->RendererResponsive(this);\n}", "target": 0}
{"code": "fz_convert_color(fz_context *ctx, const fz_color_params *params, const fz_colorspace *is, const fz_colorspace *ds, float *dv, const fz_colorspace *ss, const float *sv)\n{\n\tfz_color_converter cc;\n\tfz_find_color_converter(ctx, &cc, is, ds, ss, params);\n\tcc.convert(ctx, &cc, dv, sv);\n\tfz_drop_color_converter(ctx, &cc);\n}", "target": 0}
{"code": "void HTMLMediaElement::HonorUserPreferencesForAutomaticTextTrackSelection() {\n  if (!text_tracks_ || !text_tracks_->length())\n    return;\n  if (!should_perform_automatic_track_selection_)\n    return;\n  AutomaticTrackSelection::Configuration configuration;\n  if (processing_preference_change_)\n    configuration.disable_currently_enabled_tracks = true;\n  if (text_tracks_visible_)\n    configuration.force_enable_subtitle_or_caption_track = true;\n  Settings* settings = GetDocument().GetSettings();\n  if (settings) {\n    configuration.text_track_kind_user_preference =\n        settings->GetTextTrackKindUserPreference();\n  }\n  AutomaticTrackSelection track_selection(configuration);\n  track_selection.Perform(*text_tracks_);\n}", "target": 0}
{"code": "find_start_rawstring(int ind_maxcomment)\t\n{\n    pos_T\t*pos;\n    char_u\t*line;\n    char_u\t*p;\n    int\t\tcur_maxcomment = ind_maxcomment;\n    for (;;)\n    {\n\tpos = findmatchlimit(NULL, 'R', FM_BACKWARD, cur_maxcomment);\n\tif (pos == NULL)\n\t    break;\n\tline = ml_get(pos->lnum);\n\tfor (p = line; *p && (colnr_T)(p - line) < pos->col; ++p)\n\t    p = skip_string(p);\n\tif ((colnr_T)(p - line) <= pos->col)\n\t    break;\n\tcur_maxcomment = curwin->w_cursor.lnum - pos->lnum - 1;\n\tif (cur_maxcomment <= 0)\n\t{\n\t    pos = NULL;\n\t    break;\n\t}\n    }\n    return pos;\n}", "target": 0}
{"code": "    TimeValue* TimeValue::clone_() const\n    {\n        return new TimeValue(*this);\n    }", "target": 0}
{"code": "TEST_F(ExprMatchTest, ComplexExprMatchesCorrectly) {\n    createMatcher(\n        fromjson(\"{\"\n                 \"  $expr: {\"\n                 \"      $and: [\"\n                 \"          {$eq: ['$a', 1]},\"\n                 \"          {$eq: ['$b', '$c']},\"\n                 \"          {\"\n                 \"            $or: [\"\n                 \"                {$eq: ['$d', 1]},\"\n                 \"                {$eq: ['$e', 3]},\"\n                 \"                {\"\n                 \"                  $and: [\"\n                 \"                      {$eq: ['$f', 1]},\"\n                 \"                      {$eq: ['$g', '$h']},\"\n                 \"                      {$or: [{$eq: ['$i', 3]}, {$eq: ['$j', '$k']}]}\"\n                 \"                  ]\"\n                 \"                }\"\n                 \"            ]\"\n                 \"          }\"\n                 \"      ]\"\n                 \"  }\"\n                 \"}\"));\n    ASSERT_TRUE(matches(BSON(\"a\" << 1 << \"b\" << 3 << \"c\" << 3 << \"d\" << 1)));\n    ASSERT_TRUE(matches(BSON(\"a\" << 1 << \"b\" << 3 << \"c\" << 3 << \"e\" << 3)));\n    ASSERT_TRUE(matches(BSON(\"a\" << 1 << \"b\" << 3 << \"c\" << 3 << \"f\" << 1 << \"i\" << 3)));\n    ASSERT_TRUE(\n        matches(BSON(\"a\" << 1 << \"b\" << 3 << \"c\" << 3 << \"f\" << 1 << \"j\" << 5 << \"k\" << 5)));\n    ASSERT_FALSE(matches(BSON(\"a\" << 1)));\n    ASSERT_FALSE(matches(BSON(\"a\" << 1 << \"b\" << 3 << \"c\" << 3)));\n    ASSERT_FALSE(matches(BSON(\"a\" << 1 << \"b\" << 3 << \"c\" << 3 << \"d\" << 5)));\n    ASSERT_FALSE(matches(BSON(\"a\" << 1 << \"b\" << 3 << \"c\" << 3 << \"j\" << 5 << \"k\" << 10)));\n}", "target": 0}
{"code": "strdup_with_null(OnigEncoding enc, UChar* s, UChar* end)\n{\n  ptrdiff_t slen;\n  int term_len, i;\n  UChar *r;\n  slen = end - s;\n  term_len = ONIGENC_MBC_MINLEN(enc);\n  r = (UChar* )xmalloc(slen + term_len);\n  CHECK_NULL_RETURN(r);\n  xmemcpy(r, s, slen);\n  for (i = 0; i < term_len; i++)\n    r[slen + i] = (UChar )0;\n  return r;\n}", "target": 0}
{"code": "static bool io_wq_work_match_item(struct io_wq_work *work, void *data)\n{\n\treturn work == data;\n}", "target": 0}
{"code": "static RBinWasmGlobalEntry *parse_global_entry(RBinWasmObj *bin, ut64 bound, ut32 index) {\n\tRBuffer *b = bin->buf;\n\tRBinWasmGlobalEntry *ptr = R_NEW0 (RBinWasmGlobalEntry);\n\tif (ptr) {\n\t\tptr->sec_i = index;\n\t\tptr->file_offset = r_buf_tell (b);\n\t\tif (!consume_u7_r (b, bound, (ut8 *)&ptr->content_type)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (!consume_u1_r (b, bound, &ptr->mutability)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (!consume_init_expr_r (b, bound, R_BIN_WASM_END_OF_CODE, NULL)) {\n\t\t\tgoto beach;\n\t\t}\n\t}\n\treturn ptr;\nbeach:\n\tfree (ptr);\n\treturn NULL;\n}", "target": 0}
{"code": "spnego_gss_context_time(\n\t\t\tOM_uint32\t*minor_status,\n\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\tOM_uint32\t*time_rec)\n{\n\tOM_uint32 ret;\n\tret = gss_context_time(minor_status,\n\t\t\t    context_handle,\n\t\t\t    time_rec);\n\treturn (ret);\n}", "target": 0}
{"code": "int filter_match_preds(struct event_filter *filter, void *rec)\n{\n\tstruct prog_entry *prog;\n\tint i;\n\tif (!filter)\n\t\treturn 1;\n\tprog = rcu_dereference_sched(filter->prog);\n\tif (!prog)\n\t\treturn 1;\n\tfor (i = 0; prog[i].pred; i++) {\n\t\tstruct filter_pred *pred = prog[i].pred;\n\t\tint match = pred->fn(pred, rec);\n\t\tif (match == prog[i].when_to_branch)\n\t\t\ti = prog[i].target;\n\t}\n\treturn prog[i].target;\n}", "target": 0}
{"code": "static int read_emulate(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\tvoid *val, int bytes)\n{\n\treturn !kvm_read_guest(vcpu->kvm, gpa, val, bytes);\n}", "target": 0}
{"code": "ChromeContentBrowserClient::CreateURLLoaderFactoryForNetworkRequests(\n    content::RenderProcessHost* process,\n    network::mojom::NetworkContext* network_context,\n    const url::Origin& request_initiator) {\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  return ChromeContentBrowserClientExtensionsPart::\n      CreateURLLoaderFactoryForNetworkRequests(process, network_context,\n                                               request_initiator);\n#else\n  return network::mojom::URLLoaderFactoryPtrInfo();\n#endif\n}", "target": 0}
{"code": "static int __init init_ipv6_mibs(void)\n{\n\tif (snmp_mib_init((void **)ipv6_statistics,\n\t\t\t  sizeof(struct ipstats_mib)) < 0)\n\t\tgoto err_ip_mib;\n\tif (snmp_mib_init((void **)icmpv6_statistics,\n\t\t\t  sizeof(struct icmpv6_mib)) < 0)\n\t\tgoto err_icmp_mib;\n\tif (snmp_mib_init((void **)icmpv6msg_statistics,\n\t\t\t  sizeof(struct icmpv6msg_mib)) < 0)\n\t\tgoto err_icmpmsg_mib;\n\tif (snmp_mib_init((void **)udp_stats_in6, sizeof (struct udp_mib)) < 0)\n\t\tgoto err_udp_mib;\n\tif (snmp_mib_init((void **)udplite_stats_in6,\n\t\t\t  sizeof (struct udp_mib)) < 0)\n\t\tgoto err_udplite_mib;\n\treturn 0;\nerr_udplite_mib:\n\tsnmp_mib_free((void **)udp_stats_in6);\nerr_udp_mib:\n\tsnmp_mib_free((void **)icmpv6msg_statistics);\nerr_icmpmsg_mib:\n\tsnmp_mib_free((void **)icmpv6_statistics);\nerr_icmp_mib:\n\tsnmp_mib_free((void **)ipv6_statistics);\nerr_ip_mib:\n\treturn -ENOMEM;\n}", "target": 0}
{"code": "static char* guess_timezone(const timelib_tzdb *tzdb TSRMLS_DC)\n{\n\tif (DATEG(timezone) && (strlen(DATEG(timezone))) > 0) {\n\t\treturn DATEG(timezone);\n\t}\n\tif (!DATEG(default_timezone)) {\n\t\tzval ztz;\n\t\tif (SUCCESS == zend_get_configuration_directive(\"date.timezone\", sizeof(\"date.timezone\"), &ztz)\n\t\t\t&& Z_TYPE(ztz) == IS_STRING && Z_STRLEN(ztz) > 0 && timelib_timezone_id_is_valid(Z_STRVAL(ztz), tzdb)) {\n\t\t\treturn Z_STRVAL(ztz);\n\t\t}\n\t} else if (*DATEG(default_timezone)) {\n\t\tif (DATEG(timezone_valid) == 1) {\n\t\t\treturn DATEG(default_timezone);\n\t\t}\n\t\tif (!timelib_timezone_id_is_valid(DATEG(default_timezone), tzdb)) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid date.timezone value '%s', we selected the timezone 'UTC' for now.\", DATEG(default_timezone));\n\t\t\treturn \"UTC\";\n\t\t}\n\t\tDATEG(timezone_valid) = 1;\n\t\treturn DATEG(default_timezone);\n\t}\n\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, DATE_TZ_ERRMSG \"We selected the timezone 'UTC' for now, but please set date.timezone to select your timezone.\");\n\treturn \"UTC\";", "target": 0}
{"code": "static bool server_remote_addr_filter(PgSocket *sk, void *arg) {\n\tPgAddr *addr = arg;\n\treturn (pga_cmp_addr(&sk->remote_addr, addr) == 0);\n}", "target": 0}
{"code": "u8 bnx2x_is_pcie_pending(struct pci_dev *dev)\n{\n\tu16 status;\n\tpcie_capability_read_word(dev, PCI_EXP_DEVSTA, &status);\n\treturn status & PCI_EXP_DEVSTA_TRPND;\n}", "target": 0}
{"code": "partition_table_create_completed_cb (DBusGMethodInvocation *context,\n                                     Device *device,\n                                     gboolean job_was_cancelled,\n                                     int status,\n                                     const char *stderr,\n                                     const char *stdout,\n                                     gpointer user_data)\n{\n  CreatePartitionTableData *data = user_data;\n  device_generate_kernel_change_event (device);\n  if (WEXITSTATUS (status) == 0 && !job_was_cancelled)\n    {\n      if (g_strcmp0 (device->priv->partition_table_scheme, data->scheme) == 0)\n        {\n          dbus_g_method_return (context);\n        }\n      else\n        {\n          data->device_changed_signal_handler_id\n            = g_signal_connect_after (device->priv->daemon,\n                                      \"device-changed\",\n                                      (GCallback) partition_table_create_device_changed_cb,\n                                      partition_table_create_data_ref (data));\n          data->device_changed_timeout_id = g_timeout_add (10 * 1000,\n                                                           partition_table_create_device_not_changed_cb,\n                                                           data);\n        }\n    }\n  else\n    {\n      if (job_was_cancelled)\n        {\n          throw_error (context, ERROR_CANCELLED, \"Job was cancelled\");\n        }\n      else\n        {\n          throw_error (context,\n                       ERROR_FAILED,\n                       \"Error creating partition table: helper exited with exit code %d: %s\",\n                       WEXITSTATUS (status),\n                       stderr);\n        }\n    }\n}", "target": 0}
{"code": "PHPAPI int php_var_unserialize(zval *rval, const unsigned char **p, const unsigned char *max, php_unserialize_data_t *var_hash)\n{\n\tHashTable *classes = NULL;\n\treturn php_var_unserialize_ex(UNSERIALIZE_PASSTHRU);\n}", "target": 0}
{"code": "bool CLua::proc_returns(const char *par) const\n{\n    return strchr(par, '>') != nullptr;\n}", "target": 0}
{"code": "static int thread_cpu_clock_getres(const clockid_t which_clock,\n\t\t\t\t   struct timespec *tp)\n{\n\treturn posix_cpu_clock_getres(THREAD_CLOCK, tp);\n}", "target": 0}
{"code": "static ssize_t ctor_show(struct kmem_cache *s, char *buf)\n{\n\tif (!s->ctor)\n\t\treturn 0;\n\treturn sprintf(buf, \"%pS\\n\", s->ctor);\n}", "target": 0}
{"code": "INT64 LibRaw_file_datastream::tell()\n{\n  LR_STREAM_CHK();\n  return f->pubseekoff(0, std::ios_base::cur);\n}", "target": 0}
{"code": "void WasmBinaryBuilder::visitRefNull(RefNull* curr) {\n  BYN_TRACE(\"zz node: RefNull\\n\");\n  curr->finalize(getHeapType());\n}", "target": 0}
{"code": "    XmpData::const_iterator XmpData::end() const\n    {\n        return xmpMetadata_.end();\n    }", "target": 0}
{"code": "static int tg_set_cfs_bandwidth(struct task_group *tg, u64 period, u64 quota)\n{\n\tint i, ret = 0, runtime_enabled, runtime_was_enabled;\n\tstruct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth;\n\tif (tg == &root_task_group)\n\t\treturn -EINVAL;\n\tif (quota < min_cfs_quota_period || period < min_cfs_quota_period)\n\t\treturn -EINVAL;\n\tif (period > max_cfs_quota_period)\n\t\treturn -EINVAL;\n\tget_online_cpus();\n\tmutex_lock(&cfs_constraints_mutex);\n\tret = __cfs_schedulable(tg, period, quota);\n\tif (ret)\n\t\tgoto out_unlock;\n\truntime_enabled = quota != RUNTIME_INF;\n\truntime_was_enabled = cfs_b->quota != RUNTIME_INF;\n\tif (runtime_enabled && !runtime_was_enabled)\n\t\tcfs_bandwidth_usage_inc();\n\traw_spin_lock_irq(&cfs_b->lock);\n\tcfs_b->period = ns_to_ktime(period);\n\tcfs_b->quota = quota;\n\t__refill_cfs_bandwidth_runtime(cfs_b);\n\tif (runtime_enabled)\n\t\tstart_cfs_bandwidth(cfs_b);\n\traw_spin_unlock_irq(&cfs_b->lock);\n\tfor_each_online_cpu(i) {\n\t\tstruct cfs_rq *cfs_rq = tg->cfs_rq[i];\n\t\tstruct rq *rq = cfs_rq->rq;\n\t\traw_spin_lock_irq(&rq->lock);\n\t\tcfs_rq->runtime_enabled = runtime_enabled;\n\t\tcfs_rq->runtime_remaining = 0;\n\t\tif (cfs_rq->throttled)\n\t\t\tunthrottle_cfs_rq(cfs_rq);\n\t\traw_spin_unlock_irq(&rq->lock);\n\t}\n\tif (runtime_was_enabled && !runtime_enabled)\n\t\tcfs_bandwidth_usage_dec();\nout_unlock:\n\tmutex_unlock(&cfs_constraints_mutex);\n\tput_online_cpus();\n\treturn ret;\n}", "target": 0}
{"code": "static int fts3RenameMethod(\n  sqlite3_vtab *pVtab,            \n  const char *zName               \n){\n  Fts3Table *p = (Fts3Table *)pVtab;\n  sqlite3 *db = p->db;            \n  int rc;                         \n  rc = fts3SetHasStat(p);\n  assert( p->nPendingData==0 );\n  if( rc==SQLITE_OK ){\n    rc = sqlite3Fts3PendingTermsFlush(p);\n  }\n  if( p->zContentTbl==0 ){\n    fts3DbExec(&rc, db,\n      \"ALTER TABLE %Q.'%q_content'  RENAME TO '%q_content';\",\n      p->zDb, p->zName, zName\n    );\n  }\n  if( p->bHasDocsize ){\n    fts3DbExec(&rc, db,\n      \"ALTER TABLE %Q.'%q_docsize'  RENAME TO '%q_docsize';\",\n      p->zDb, p->zName, zName\n    );\n  }\n  if( p->bHasStat ){\n    fts3DbExec(&rc, db,\n      \"ALTER TABLE %Q.'%q_stat'  RENAME TO '%q_stat';\",\n      p->zDb, p->zName, zName\n    );\n  }\n  fts3DbExec(&rc, db,\n    \"ALTER TABLE %Q.'%q_segments' RENAME TO '%q_segments';\",\n    p->zDb, p->zName, zName\n  );\n  fts3DbExec(&rc, db,\n    \"ALTER TABLE %Q.'%q_segdir'   RENAME TO '%q_segdir';\",\n    p->zDb, p->zName, zName\n  );\n  return rc;\n}", "target": 0}
{"code": "static void set_cpu_partial(struct kmem_cache *s)\n{\n#ifdef CONFIG_SLUB_CPU_PARTIAL\n\tif (!kmem_cache_has_cpu_partial(s))\n\t\ts->cpu_partial = 0;\n\telse if (s->size >= PAGE_SIZE)\n\t\ts->cpu_partial = 2;\n\telse if (s->size >= 1024)\n\t\ts->cpu_partial = 6;\n\telse if (s->size >= 256)\n\t\ts->cpu_partial = 13;\n\telse\n\t\ts->cpu_partial = 30;\n#endif\n}", "target": 0}
{"code": "PHPAPI void var_push_dtor(php_unserialize_data_t *var_hashx, zval **rval)\n{\n\tvar_entries *var_hash = var_hashx->first_dtor, *prev = NULL;\n\twhile (var_hash && var_hash->used_slots == VAR_ENTRIES_MAX) {\n\t\tprev = var_hash;\n\t\tvar_hash = var_hash->next;\n\t}\n\tif (!var_hash) {\n\t\tvar_hash = emalloc(sizeof(var_entries));\n\t\tvar_hash->used_slots = 0;\n\t\tvar_hash->next = 0;\n\t\tif (!var_hashx->first_dtor)\n\t\t\tvar_hashx->first_dtor = var_hash;\n\t\telse\n\t\t\tprev->next = var_hash;\n\t}\n\tZ_ADDREF_PP(rval);\n\tvar_hash->data[var_hash->used_slots++] = *rval;\n}", "target": 0}
{"code": "virSecuritySELinuxRestoreImageLabel(virSecurityManager *mgr,\n                                    virDomainDef *def,\n                                    virStorageSource *src,\n                                    virSecurityDomainImageLabelFlags flags G_GNUC_UNUSED)\n{\n    return virSecuritySELinuxRestoreImageLabelInt(mgr, def, src, false);\n}", "target": 0}
{"code": "int kvm_vm_ioctl_get_dirty_log(struct kvm *kvm, struct kvm_dirty_log *log)\n{\n\tint r;\n\tstruct kvm_memory_slot *memslot;\n\tunsigned long n, i;\n\tunsigned long *dirty_bitmap;\n\tunsigned long *dirty_bitmap_buffer;\n\tbool is_dirty = false;\n\tmutex_lock(&kvm->slots_lock);\n\tr = -EINVAL;\n\tif (log->slot >= KVM_USER_MEM_SLOTS)\n\t\tgoto out;\n\tmemslot = id_to_memslot(kvm->memslots, log->slot);\n\tdirty_bitmap = memslot->dirty_bitmap;\n\tr = -ENOENT;\n\tif (!dirty_bitmap)\n\t\tgoto out;\n\tn = kvm_dirty_bitmap_bytes(memslot);\n\tdirty_bitmap_buffer = dirty_bitmap + n / sizeof(long);\n\tmemset(dirty_bitmap_buffer, 0, n);\n\tspin_lock(&kvm->mmu_lock);\n\tfor (i = 0; i < n / sizeof(long); i++) {\n\t\tunsigned long mask;\n\t\tgfn_t offset;\n\t\tif (!dirty_bitmap[i])\n\t\t\tcontinue;\n\t\tis_dirty = true;\n\t\tmask = xchg(&dirty_bitmap[i], 0);\n\t\tdirty_bitmap_buffer[i] = mask;\n\t\toffset = i * BITS_PER_LONG;\n\t\tkvm_mmu_write_protect_pt_masked(kvm, memslot, offset, mask);\n\t}\n\tif (is_dirty)\n\t\tkvm_flush_remote_tlbs(kvm);\n\tspin_unlock(&kvm->mmu_lock);\n\tr = -EFAULT;\n\tif (copy_to_user(log->dirty_bitmap, dirty_bitmap_buffer, n))\n\t\tgoto out;\n\tr = 0;\nout:\n\tmutex_unlock(&kvm->slots_lock);\n\treturn r;\n}", "target": 0}
{"code": "do_curl_dealloc(CurlObject *self)\n{\n    PyObject_GC_UnTrack(self);\n    Py_TRASHCAN_SAFE_BEGIN(self);\n    Py_CLEAR(self->dict);\n    util_curl_close(self);\n    Py_TRASHCAN_SAFE_END(self);\n    Curl_Type.tp_free(self);\n}", "target": 0}
{"code": "init_cifs_idmap(void)\n{\n\tstruct cred *cred;\n\tstruct key *keyring;\n\tint ret;\n\tcifs_dbg(FYI, \"Registering the %s key type\\n\",\n\t\t cifs_idmap_key_type.name);\n\tcred = prepare_kernel_cred(NULL);\n\tif (!cred)\n\t\treturn -ENOMEM;\n\tkeyring = keyring_alloc(\".cifs_idmap\",\n\t\t\t\tGLOBAL_ROOT_UID, GLOBAL_ROOT_GID, cred,\n\t\t\t\t(KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\tKEY_USR_VIEW | KEY_USR_READ,\n\t\t\t\tKEY_ALLOC_NOT_IN_QUOTA, NULL);\n\tif (IS_ERR(keyring)) {\n\t\tret = PTR_ERR(keyring);\n\t\tgoto failed_put_cred;\n\t}\n\tret = register_key_type(&cifs_idmap_key_type);\n\tif (ret < 0)\n\t\tgoto failed_put_key;\n\tset_bit(KEY_FLAG_ROOT_CAN_CLEAR, &keyring->flags);\n\tcred->thread_keyring = keyring;\n\tcred->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;\n\troot_cred = cred;\n\tcifs_dbg(FYI, \"cifs idmap keyring: %d\\n\", key_serial(keyring));\n\treturn 0;\nfailed_put_key:\n\tkey_put(keyring);\nfailed_put_cred:\n\tput_cred(cred);\n\treturn ret;\n}", "target": 0}
{"code": "int sock_no_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *m,\n\t\t    size_t len, int flags)\n{\n\treturn -EOPNOTSUPP;\n}", "target": 0}
{"code": "int tls1_check_curve(SSL *s, const unsigned char *p, size_t len)\n\t{\n\tconst unsigned char *curves;\n\tsize_t curveslen, i;\n\tunsigned int suiteb_flags = tls1_suiteb(s);\n\tif (len != 3 || p[0] != NAMED_CURVE_TYPE)\n\t\treturn 0;\n\tif (suiteb_flags)\n\t\t{\n\t\tunsigned long cid = s->s3->tmp.new_cipher->id;\n\t\tif (p[1])\n\t\t\treturn 0;\n\t\tif (cid == TLS1_CK_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256)\n\t\t\t{\n\t\t\tif (p[2] != TLSEXT_curve_P_256)\n\t\t\t\treturn 0;\n\t\t\t}\n\t\telse if (cid == TLS1_CK_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384)\n\t\t\t{\n\t\t\tif (p[2] != TLSEXT_curve_P_384)\n\t\t\t\treturn 0;\n\t\t\t}\n\t\telse\t\n\t\t\treturn 0;\n\t\t}\n\ttls1_get_curvelist(s, 0, &curves, &curveslen);\n\tfor (i = 0; i < curveslen; i += 2, curves += 2)\n\t\t{\n\t\tif (p[1] == curves[0] && p[2] == curves[1])\n\t\t\treturn 1;\n\t\t}\n\treturn 0;\n\t}", "target": 0}
{"code": "static int pfkey_sendmsg(struct kiocb *kiocb,\n\t\t\t struct socket *sock, struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb = NULL;\n\tstruct sadb_msg *hdr = NULL;\n\tint err;\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags & MSG_OOB)\n\t\tgoto out;\n\terr = -EMSGSIZE;\n\tif ((unsigned int)len > sk->sk_sndbuf - 32)\n\t\tgoto out;\n\terr = -ENOBUFS;\n\tskb = alloc_skb(len, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto out;\n\terr = -EFAULT;\n\tif (memcpy_fromiovec(skb_put(skb,len), msg->msg_iov, len))\n\t\tgoto out;\n\thdr = pfkey_get_base_msg(skb, &err);\n\tif (!hdr)\n\t\tgoto out;\n\tmutex_lock(&xfrm_cfg_mutex);\n\terr = pfkey_process(sk, skb, hdr);\n\tmutex_unlock(&xfrm_cfg_mutex);\nout:\n\tif (err && hdr && pfkey_error(hdr, err, sk) == 0)\n\t\terr = 0;\n\tkfree_skb(skb);\n\treturn err ? : len;\n}", "target": 0}
{"code": "static int ssl_generate_random( mbedtls_ssl_context *ssl )\n{\n    int ret;\n    unsigned char *p = ssl->handshake->randbytes;\n#if defined(MBEDTLS_HAVE_TIME)\n    mbedtls_time_t t;\n#endif\n#if defined(MBEDTLS_SSL_PROTO_DTLS)\n    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&\n        ssl->handshake->verify_cookie != NULL )\n    {\n        return( 0 );\n    }\n#endif\n#if defined(MBEDTLS_HAVE_TIME)\n    t = mbedtls_time( NULL );\n    *p++ = (unsigned char)( t >> 24 );\n    *p++ = (unsigned char)( t >> 16 );\n    *p++ = (unsigned char)( t >>  8 );\n    *p++ = (unsigned char)( t       );\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"client hello, current time: %lu\", t ) );\n#else\n    if( ( ret = ssl->conf->f_rng( ssl->conf->p_rng, p, 4 ) ) != 0 )\n        return( ret );\n    p += 4;\n#endif \n    if( ( ret = ssl->conf->f_rng( ssl->conf->p_rng, p, 28 ) ) != 0 )\n        return( ret );\n    return( 0 );\n}", "target": 0}
{"code": "SWFShape_getScaledPenY(SWFShape shape)\n{\n\treturn shape->ypos;\n}", "target": 0}
{"code": "GF_EXPORT\nGF_Err gf_isom_get_track_layout_info(GF_ISOFile *movie, u32 trackNumber, u32 *width, u32 *height, s32 *translation_x, s32 *translation_y, s16 *layer)\n{\n\tGF_TrackBox *tk = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!tk) return GF_BAD_PARAM;\n\tif (width) *width = tk->Header->width>>16;\n\tif (height) *height = tk->Header->height>>16;\n\tif (layer) *layer = tk->Header->layer;\n\tif (translation_x) *translation_x = tk->Header->matrix[6] >> 16;\n\tif (translation_y) *translation_y = tk->Header->matrix[7] >> 16;\n\treturn GF_OK;", "target": 0}
{"code": "void RenderWidgetHostViewAura::ReturnSubscriberTexture(\n    base::WeakPtr<RenderWidgetHostViewAura> rwhva,\n    scoped_refptr<OwnedMailbox> subscriber_texture,\n    uint32 sync_point) {\n  if (!subscriber_texture.get())\n    return;\n  if (!rwhva)\n    return;\n  DCHECK_NE(\n      rwhva->active_frame_subscriber_textures_.count(subscriber_texture.get()),\n      0u);\n  subscriber_texture->UpdateSyncPoint(sync_point);\n  rwhva->active_frame_subscriber_textures_.erase(subscriber_texture.get());\n  if (rwhva->frame_subscriber_ && subscriber_texture->texture_id())\n    rwhva->idle_frame_subscriber_textures_.push_back(subscriber_texture);\n}", "target": 0}
{"code": "  LangToExemplarSet() { }", "target": 0}
{"code": "  void AddDep(int node_index, int dep_index) {\n    CHECK_LT(node_index, nodes_.size());\n    nodes_[node_index].control_inputs.push_back(dep_index);\n  }", "target": 0}
{"code": "bool XSSAuditor::filterParamToken(const FilterTokenRequest& request)\n{\n    ASSERT(request.token.type() == HTMLToken::StartTag);\n    ASSERT(hasName(request.token, paramTag));\n    size_t indexOfNameAttribute;\n    if (!findAttributeWithName(request.token, nameAttr, indexOfNameAttribute))\n        return false;\n    const HTMLToken::Attribute& nameAttribute = request.token.attributes().at(indexOfNameAttribute);\n    if (!HTMLParamElement::isURLParameter(String(nameAttribute.value)))\n        return false;\n    return eraseAttributeIfInjected(request, valueAttr, blankURL().string(), SrcLikeAttribute);\n}", "target": 0}
{"code": "static bool winbind_name_list_to_sid_string_list(struct pwb_context *ctx,\n\t\t\t\t\t\t const char *user,\n\t\t\t\t\t\t const char *name_list,\n\t\t\t\t\t\t char *sid_list_buffer,\n\t\t\t\t\t\t int sid_list_buffer_size)\n{\n\tbool result = false;\n\tchar *current_name = NULL;\n\tconst char *search_location;\n\tconst char *comma;\n\tif (sid_list_buffer_size > 0) {\n\t\tsid_list_buffer[0] = 0;\n\t}\n\tsearch_location = name_list;\n\twhile ((comma = strstr(search_location, \",\")) != NULL) {\n\t\tcurrent_name = strndup(search_location,\n\t\t\t\t       comma - search_location);\n\t\tif (NULL == current_name) {\n\t\t\tgoto out;\n\t\t}\n\t\tif (!winbind_name_to_sid_string(ctx, user,\n\t\t\t\t\t\tcurrent_name,\n\t\t\t\t\t\tsid_list_buffer,\n\t\t\t\t\t\tsid_list_buffer_size)) {\n\t\t\t_pam_log(ctx, LOG_INFO, \"cannot convert group %s to sid, \"\n\t\t\t\t \"check if group %s is valid group.\", current_name,\n\t\t\t\t current_name);\n\t\t\t_make_remark_format(ctx, PAM_TEXT_INFO, _(\"Cannot convert group %s \"\n\t\t\t\t\t\"to sid, please contact your administrator to see \"\n\t\t\t\t\t\"if group %s is valid.\"), current_name, current_name);\n\t\t\tSAFE_FREE(current_name);\n\t\t\tsearch_location = comma + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tSAFE_FREE(current_name);\n\t\tif (!safe_append_string(sid_list_buffer, \",\",\n\t\t\t\t\tsid_list_buffer_size)) {\n\t\t\tgoto out;\n\t\t}\n\t\tsearch_location = comma + 1;\n\t}\n\tif (!winbind_name_to_sid_string(ctx, user, search_location,\n\t\t\t\t\tsid_list_buffer,\n\t\t\t\t\tsid_list_buffer_size)) {\n\t\t_pam_log(ctx, LOG_INFO, \"cannot convert group %s to sid, \"\n\t\t\t \"check if group %s is valid group.\", search_location,\n\t\t\t search_location);\n\t\t_make_remark_format(ctx, PAM_TEXT_INFO, _(\"Cannot convert group %s \"\n\t\t\t\t\"to sid, please contact your administrator to see \"\n\t\t\t\t\"if group %s is valid.\"), search_location, search_location);\n\t}\n\tresult = true;\nout:\n\tSAFE_FREE(current_name);\n\treturn result;\n}", "target": 0}
{"code": "AWSGeneralAbstractor::get_v4_canonical_headers(\n  const req_info& info,\n  const boost::string_view& signedheaders,\n  const bool using_qs) const\n{\n  return rgw::auth::s3::get_v4_canonical_headers(info, signedheaders,\n                                                 using_qs, false);\n}", "target": 0}
{"code": " double ConvolverNode::latencyTime() const\n {\n    MutexTryLocker tryLocker(m_processLock);\n    if (tryLocker.locked())\n        return m_reverb ? m_reverb->latencyFrames() / static_cast<double>(sampleRate()) : 0;\n    return std::numeric_limits<double>::infinity();\n }", "target": 0}
{"code": "static void slab_mem_offline_callback(void *arg)\n{\n\tstruct kmem_cache_node *n;\n\tstruct kmem_cache *s;\n\tstruct memory_notify *marg = arg;\n\tint offline_node;\n\toffline_node = marg->status_change_nid;\n\tif (offline_node < 0)\n\t\treturn;\n\tdown_read(&slub_lock);\n\tlist_for_each_entry(s, &slab_caches, list) {\n\t\tn = get_node(s, offline_node);\n\t\tif (n) {\n\t\t\tBUG_ON(slabs_node(s, offline_node));\n\t\t\ts->node[offline_node] = NULL;\n\t\t\tkmem_cache_free(kmalloc_caches, n);\n\t\t}\n\t}\n\tup_read(&slub_lock);\n}", "target": 0}
{"code": "static int panic_op_write_handler(const char *val,\n\t\t\t\t  const struct kernel_param *kp)\n{\n\tchar valcp[16];\n\tchar *s;\n\tstrncpy(valcp, val, 15);\n\tvalcp[15] = '\\0';\n\ts = strstrip(valcp);\n\tif (strcmp(s, \"none\") == 0)\n\t\tipmi_send_panic_event = IPMI_SEND_PANIC_EVENT_NONE;\n\telse if (strcmp(s, \"event\") == 0)\n\t\tipmi_send_panic_event = IPMI_SEND_PANIC_EVENT;\n\telse if (strcmp(s, \"string\") == 0)\n\t\tipmi_send_panic_event = IPMI_SEND_PANIC_EVENT_STRING;\n\telse\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 0}
{"code": "PHP_FUNCTION(fmod)\n{\n\tdouble num1, num2;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"dd\",  &num1, &num2) == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_DOUBLE(fmod(num1, num2));\n}", "target": 0}
{"code": "void JOIN::cleanup(bool full)\n{\n  DBUG_ENTER(\"JOIN::cleanup\");\n  DBUG_PRINT(\"enter\", (\"full %u\", (uint) full));\n  if (full)\n    have_query_plan= QEP_DELETED;\n  if (original_join_tab)\n  {\n    join_tab= original_join_tab;\n    original_join_tab= 0;\n    table_count= original_table_count;\n  }\n  if (join_tab)\n  {\n    JOIN_TAB *tab;\n    if (full)\n    {\n      if (top_join_tab_count && tables_list)\n      {\n        for (tab= first_breadth_first_tab(); tab;\n             tab= next_breadth_first_tab(first_breadth_first_tab(),\n                                         top_join_tab_count, tab))\n        {\n          tab->cleanup();\n          delete tab->filesort_result;\n          tab->filesort_result= NULL;\n        }\n      }\n      cleaned= true;\n      {\n        JOIN_TAB *curr_tab= join_tab + exec_join_tab_cnt();\n        for (uint i= 0; i < aggr_tables; i++, curr_tab++)\n        {\n          if (curr_tab->aggr)\n          {\n            free_tmp_table(thd, curr_tab->table);\n            delete curr_tab->tmp_table_param;\n            curr_tab->tmp_table_param= NULL;\n            curr_tab->aggr= NULL;\n            delete curr_tab->filesort_result;\n            curr_tab->filesort_result= NULL;\n          }\n        }\n        aggr_tables= 0; \n      }\n    }\n    else\n    {\n      for (tab= first_linear_tab(this, WITH_BUSH_ROOTS, WITH_CONST_TABLES); tab;\n           tab= next_linear_tab(this, tab, WITH_BUSH_ROOTS))\n      {\n        tab->partial_cleanup();\n      }\n    }\n  }\n  if (full)\n  {\n    cleanup_empty_jtbm_semi_joins(this, join_list);\n    group_fields.delete_elements();\n    tmp_table_param.copy_funcs.empty();\n    tmp_table_param.cleanup();\n    delete pushdown_query;\n    pushdown_query= 0;\n    if (!join_tab)\n    {\n      List_iterator<TABLE_LIST> li(*join_list);\n      TABLE_LIST *table_ref;\n      while ((table_ref= li++))\n      {\n        if (table_ref->table &&\n            table_ref->jtbm_subselect &&\n            table_ref->jtbm_subselect->is_jtbm_const_tab)\n        {\n          free_tmp_table(thd, table_ref->table);\n          table_ref->table= NULL;\n        }\n      }\n    }\n  }\n  if (current_ref_ptrs != items0)\n  {\n    set_items_ref_array(items0);\n    set_group_rpa= false;\n  }\n  DBUG_VOID_RETURN;\n}", "target": 0}
{"code": "static APR_INLINE int do_double_reverse (int double_reverse,\n                                         const char *remote_host,\n                                         apr_sockaddr_t *client_addr,\n                                         apr_pool_t *pool)\n{\n    apr_sockaddr_t *sa;\n    apr_status_t rv;\n    if (double_reverse) {\n        return double_reverse;\n    }\n    if (remote_host == NULL || remote_host[0] == '\\0') {\n        return -1;\n    }\n    rv = apr_sockaddr_info_get(&sa, remote_host, APR_UNSPEC, 0, 0, pool);\n    if (rv == APR_SUCCESS) {\n        while (sa) {\n            if (apr_sockaddr_equal(sa, client_addr)) {\n                return 1;\n            }\n            sa = sa->next;\n        }\n    }\n    return -1;\n}", "target": 0}
{"code": "static inline u32 nfsd4_commit_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + op_encode_verifier_maxsz) * sizeof(__be32);\n}", "target": 0}
{"code": "static int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct trusted_key_payload *p = key->payload.data;\n\tstruct trusted_key_payload *new_p;\n\tstruct trusted_key_options *new_o;\n\tsize_t datalen = prep->datalen;\n\tchar *datablob;\n\tint ret = 0;\n\tif (!p->migratable)\n\t\treturn -EPERM;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tnew_o = trusted_options_alloc();\n\tif (!new_o) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tnew_p = trusted_payload_alloc(key);\n\tif (!new_p) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmemcpy(datablob, prep->data, datalen);\n\tdatablob[datalen] = '\\0';\n\tret = datablob_parse(datablob, new_p, new_o);\n\tif (ret != Opt_update) {\n\t\tret = -EINVAL;\n\t\tkfree(new_p);\n\t\tgoto out;\n\t}\n\tnew_p->migratable = p->migratable;\n\tnew_p->key_len = p->key_len;\n\tmemcpy(new_p->key, p->key, p->key_len);\n\tdump_payload(p);\n\tdump_payload(new_p);\n\tret = key_seal(new_p, new_o);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: key_seal failed (%d)\\n\", ret);\n\t\tkfree(new_p);\n\t\tgoto out;\n\t}\n\tif (new_o->pcrlock) {\n\t\tret = pcrlock(new_o->pcrlock);\n\t\tif (ret < 0) {\n\t\t\tpr_info(\"trusted_key: pcrlock failed (%d)\\n\", ret);\n\t\t\tkfree(new_p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\trcu_assign_keypointer(key, new_p);\n\tcall_rcu(&p->rcu, trusted_rcu_free);\nout:\n\tkfree(datablob);\n\tkfree(new_o);\n\treturn ret;\n}", "target": 0}
{"code": "bool JOIN::make_sum_func_list(List<Item> &field_list,\n                              List<Item> &send_result_set_metadata,\n\t\t\t      bool before_group_by, bool recompute)\n{\n  List_iterator_fast<Item> it(field_list);\n  Item_sum **func;\n  Item *item;\n  DBUG_ENTER(\"make_sum_func_list\");\n  if (*sum_funcs && !recompute)\n    DBUG_RETURN(FALSE); \n  func= sum_funcs;\n  while ((item=it++))\n  {\n    if (item->type() == Item::SUM_FUNC_ITEM && !item->const_item() &&\n        (!((Item_sum*) item)->depended_from() ||\n         ((Item_sum *)item)->depended_from() == select_lex))\n      *func++= (Item_sum*) item;\n  }\n  if (before_group_by && rollup.state == ROLLUP::STATE_INITED)\n  {\n    rollup.state= ROLLUP::STATE_READY;\n    if (rollup_make_fields(field_list, send_result_set_metadata, &func))\n      DBUG_RETURN(TRUE);\t\t\t\n  }\n  else if (rollup.state == ROLLUP::STATE_NONE)\n  {\n    for (uint i=0 ; i <= send_group_parts ;i++)\n      sum_funcs_end[i]= func;\n  }\n  else if (rollup.state == ROLLUP::STATE_READY)\n    DBUG_RETURN(FALSE);                         \n  *func=0;\t\t\t\t\t\n  DBUG_RETURN(FALSE);\n}", "target": 0}
{"code": "static inline struct kvm *mmu_notifier_to_kvm(struct mmu_notifier *mn)\n{\n\treturn container_of(mn, struct kvm, mmu_notifier);\n}", "target": 0}
{"code": "void nl80211_send_unprot_deauth(struct cfg80211_registered_device *rdev,\n\t\t\t\tstruct net_device *netdev, const u8 *buf,\n\t\t\t\tsize_t len, gfp_t gfp)\n{\n\tnl80211_send_mlme_event(rdev, netdev, buf, len,\n\t\t\t\tNL80211_CMD_UNPROT_DEAUTHENTICATE, gfp);\n}", "target": 0}
{"code": "static void memcg_propagate_slab_attrs(struct kmem_cache *s)\n{\n#ifdef CONFIG_MEMCG\n\tint i;\n\tchar *buffer = NULL;\n\tstruct kmem_cache *root_cache;\n\tif (is_root_cache(s))\n\t\treturn;\n\troot_cache = s->memcg_params.root_cache;\n\tif (!root_cache->max_attr_size)\n\t\treturn;\n\tfor (i = 0; i < ARRAY_SIZE(slab_attrs); i++) {\n\t\tchar mbuf[64];\n\t\tchar *buf;\n\t\tstruct slab_attribute *attr = to_slab_attr(slab_attrs[i]);\n\t\tssize_t len;\n\t\tif (!attr || !attr->store || !attr->show)\n\t\t\tcontinue;\n\t\tif (buffer)\n\t\t\tbuf = buffer;\n\t\telse if (root_cache->max_attr_size < ARRAY_SIZE(mbuf))\n\t\t\tbuf = mbuf;\n\t\telse {\n\t\t\tbuffer = (char *) get_zeroed_page(GFP_KERNEL);\n\t\t\tif (WARN_ON(!buffer))\n\t\t\t\tcontinue;\n\t\t\tbuf = buffer;\n\t\t}\n\t\tlen = attr->show(root_cache, buf);\n\t\tif (len > 0)\n\t\t\tattr->store(s, buf, len);\n\t}\n\tif (buffer)\n\t\tfree_page((unsigned long)buffer);\n#endif\t", "target": 0}
{"code": "long dtls1_default_timeout(void)\n{\n    return (60 * 60 * 2);\n}", "target": 0}
{"code": "TEST(RegexMatchExpression, RegexAcceptsUCPOption) {\n    RegexMatchExpression regex(\"a\", \"(*UCP)(\\\\w|\\u304C)\", \"\");\n    ASSERT(regex.matchesBSON(BSON(\"a\"\n                                  << \"k\")));\n    ASSERT(regex.matchesBSON(BSON(\"a\"\n                                  << \"\\u304B\")));\n    ASSERT(regex.matchesBSON(BSON(\"a\"\n                                  << \"\\u304C\")));\n}", "target": 0}
{"code": "    Xmpdatum& Xmpdatum::operator=(const Value& value)\n    {\n        setValue(&value);\n        return *this;\n    }", "target": 0}
{"code": "ConnStateData::buildFakeRequest(Http::MethodType const method, SBuf &useHost, unsigned short usePort, const SBuf &payload)\n{\n    ClientHttpRequest *http = new ClientHttpRequest(this);\n    Http::Stream *stream = new Http::Stream(clientConnection, http);\n    StoreIOBuffer tempBuffer;\n    tempBuffer.data = stream->reqbuf;\n    tempBuffer.length = HTTP_REQBUF_SZ;\n    ClientStreamData newServer = new clientReplyContext(http);\n    ClientStreamData newClient = stream;\n    clientStreamInit(&http->client_stream, clientGetMoreData, clientReplyDetach,\n                     clientReplyStatus, newServer, clientSocketRecipient,\n                     clientSocketDetach, newClient, tempBuffer);\n    stream->flags.parsed_ok = 1; \n    stream->mayUseConnection(true);\n    AsyncCall::Pointer timeoutCall = commCbCall(5, 4, \"clientLifetimeTimeout\",\n                                     CommTimeoutCbPtrFun(clientLifetimeTimeout, stream->http));\n    commSetConnTimeout(clientConnection, Config.Timeout.lifetime, timeoutCall);\n    stream->registerWithConn();\n    MasterXaction::Pointer mx = new MasterXaction(XactionInitiator::initClient);\n    mx->tcpClient = clientConnection;\n    HttpRequest::Pointer request = new HttpRequest(mx);\n    AnyP::ProtocolType proto = (method == Http::METHOD_NONE) ? AnyP::PROTO_AUTHORITY_FORM : AnyP::PROTO_HTTP;\n    request->url.setScheme(proto, nullptr);\n    request->method = method;\n    request->url.host(useHost.c_str());\n    request->url.port(usePort);\n    http->uri = SBufToCstring(request->effectiveRequestUri());\n    http->initRequest(request.getRaw());\n    request->manager(this, http->al);\n    if (proto == AnyP::PROTO_HTTP)\n        request->header.putStr(Http::HOST, useHost.c_str());\n    request->sources |= ((switchedToHttps() || port->transport.protocol == AnyP::PROTO_HTTPS) ? HttpMsg::srcHttps : HttpMsg::srcHttp);\n#if USE_AUTH\n    if (getAuth())\n        request->auth_user_request = getAuth();\n#endif\n    inBuf = payload;\n    flags.readMore = false;\n    return http;\n}", "target": 0}
{"code": "static int check_helper_mem_access(struct bpf_verifier_env *env, int regno,\n\t\t\t\t   int access_size, bool zero_size_allowed,\n\t\t\t\t   struct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env), *reg = &regs[regno];\n\tconst char *buf_info;\n\tu32 *max_access;\n\tswitch (base_type(reg->type)) {\n\tcase PTR_TO_PACKET:\n\tcase PTR_TO_PACKET_META:\n\t\treturn check_packet_access(env, regno, reg->off, access_size,\n\t\t\t\t\t   zero_size_allowed);\n\tcase PTR_TO_MAP_KEY:\n\t\treturn check_mem_region_access(env, regno, reg->off, access_size,\n\t\t\t\t\t       reg->map_ptr->key_size, false);\n\tcase PTR_TO_MAP_VALUE:\n\t\tif (check_map_access_type(env, regno, reg->off, access_size,\n\t\t\t\t\t  meta && meta->raw_mode ? BPF_WRITE :\n\t\t\t\t\t  BPF_READ))\n\t\t\treturn -EACCES;\n\t\treturn check_map_access(env, regno, reg->off, access_size,\n\t\t\t\t\tzero_size_allowed);\n\tcase PTR_TO_MEM:\n\t\treturn check_mem_region_access(env, regno, reg->off,\n\t\t\t\t\t       access_size, reg->mem_size,\n\t\t\t\t\t       zero_size_allowed);\n\tcase PTR_TO_BUF:\n\t\tif (type_is_rdonly_mem(reg->type)) {\n\t\t\tif (meta && meta->raw_mode)\n\t\t\t\treturn -EACCES;\n\t\t\tbuf_info = \"rdonly\";\n\t\t\tmax_access = &env->prog->aux->max_rdonly_access;\n\t\t} else {\n\t\t\tbuf_info = \"rdwr\";\n\t\t\tmax_access = &env->prog->aux->max_rdwr_access;\n\t\t}\n\t\treturn check_buffer_access(env, reg, regno, reg->off,\n\t\t\t\t\t   access_size, zero_size_allowed,\n\t\t\t\t\t   buf_info, max_access);\n\tcase PTR_TO_STACK:\n\t\treturn check_stack_range_initialized(\n\t\t\t\tenv,\n\t\t\t\tregno, reg->off, access_size,\n\t\t\t\tzero_size_allowed, ACCESS_HELPER, meta);\n\tdefault: \n\t\tif (zero_size_allowed && access_size == 0 &&\n\t\t    register_is_null(reg))\n\t\t\treturn 0;\n\t\tverbose(env, \"R%d type=%s \", regno,\n\t\t\treg_type_str(env, reg->type));\n\t\tverbose(env, \"expected=%s\\n\", reg_type_str(env, PTR_TO_STACK));\n\t\treturn -EACCES;\n\t}\n}", "target": 0}
{"code": "static void register_disk(struct device *parent, struct gendisk *disk)\n{\n\tstruct device *ddev = disk_to_dev(disk);\n\tstruct block_device *bdev;\n\tstruct disk_part_iter piter;\n\tstruct hd_struct *part;\n\tint err;\n\tddev->parent = parent;\n\tdev_set_name(ddev, \"%s\", disk->disk_name);\n\tdev_set_uevent_suppress(ddev, 1);\n\tif (device_add(ddev))\n\t\treturn;\n\tif (!sysfs_deprecated) {\n\t\terr = sysfs_create_link(block_depr, &ddev->kobj,\n\t\t\t\t\tkobject_name(&ddev->kobj));\n\t\tif (err) {\n\t\t\tdevice_del(ddev);\n\t\t\treturn;\n\t\t}\n\t}\n\tpm_runtime_set_memalloc_noio(ddev, true);\n\tdisk->part0.holder_dir = kobject_create_and_add(\"holders\", &ddev->kobj);\n\tdisk->slave_dir = kobject_create_and_add(\"slaves\", &ddev->kobj);\n\tif (!disk_part_scan_enabled(disk))\n\t\tgoto exit;\n\tif (!get_capacity(disk))\n\t\tgoto exit;\n\tbdev = bdget_disk(disk, 0);\n\tif (!bdev)\n\t\tgoto exit;\n\tbdev->bd_invalidated = 1;\n\terr = blkdev_get(bdev, FMODE_READ, NULL);\n\tif (err < 0)\n\t\tgoto exit;\n\tblkdev_put(bdev, FMODE_READ);\nexit:\n\tdev_set_uevent_suppress(ddev, 0);\n\tkobject_uevent(&ddev->kobj, KOBJ_ADD);\n\tdisk_part_iter_init(&piter, disk, 0);\n\twhile ((part = disk_part_iter_next(&piter)))\n\t\tkobject_uevent(&part_to_dev(part)->kobj, KOBJ_ADD);\n\tdisk_part_iter_exit(&piter);\n}", "target": 0}
{"code": "static int nft_trans_chain_add(struct nft_ctx *ctx, int msg_type)\n{\n\tstruct nft_trans *trans;\n\ttrans = nft_trans_alloc(ctx, msg_type, sizeof(struct nft_trans_chain));\n\tif (trans == NULL)\n\t\treturn -ENOMEM;\n\tif (msg_type == NFT_MSG_NEWCHAIN)\n\t\tctx->chain->flags |= NFT_CHAIN_INACTIVE;\n\tlist_add_tail(&trans->list, &ctx->net->nft.commit_list);\n\treturn 0;\n}", "target": 0}
{"code": "static void blk_mq_map_swqueue(struct request_queue *q)\n{\n\tunsigned int i;\n\tstruct blk_mq_hw_ctx *hctx;\n\tstruct blk_mq_ctx *ctx;\n\tstruct blk_mq_tag_set *set = q->tag_set;\n\tqueue_for_each_hw_ctx(q, hctx, i) {\n\t\tcpumask_clear(hctx->cpumask);\n\t\thctx->nr_ctx = 0;\n\t}\n\tqueue_for_each_ctx(q, ctx, i) {\n\t\tif (!cpu_online(i))\n\t\t\tcontinue;\n\t\thctx = q->mq_ops->map_queue(q, i);\n\t\tcpumask_set_cpu(i, hctx->cpumask);\n\t\tcpumask_set_cpu(i, hctx->tags->cpumask);\n\t\tctx->index_hw = hctx->nr_ctx;\n\t\thctx->ctxs[hctx->nr_ctx++] = ctx;\n\t}\n\tqueue_for_each_hw_ctx(q, hctx, i) {\n\t\tstruct blk_mq_ctxmap *map = &hctx->ctx_map;\n\t\tif (!hctx->nr_ctx) {\n\t\t\tif (set->tags[i]) {\n\t\t\t\tblk_mq_free_rq_map(set, set->tags[i], i);\n\t\t\t\tset->tags[i] = NULL;\n\t\t\t}\n\t\t\thctx->tags = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!set->tags[i])\n\t\t\tset->tags[i] = blk_mq_init_rq_map(set, i);\n\t\thctx->tags = set->tags[i];\n\t\tWARN_ON(!hctx->tags);\n\t\tmap->size = DIV_ROUND_UP(hctx->nr_ctx, map->bits_per_word);\n\t\thctx->next_cpu = cpumask_first(hctx->cpumask);\n\t\thctx->next_cpu_batch = BLK_MQ_CPU_WORK_BATCH;\n\t}\n}", "target": 0}
{"code": "void trgt_box_del(GF_Box *s)\n{\n\tGF_TrackGroupTypeBox *ptr = (GF_TrackGroupTypeBox *)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}", "target": 0}
{"code": "git_commit_list_node *git_commit_list_pop(git_commit_list **stack)\n{\n\tgit_commit_list *top = *stack;\n\tgit_commit_list_node *item = top ? top->item : NULL;\n\tif (top) {\n\t\t*stack = top->next;\n\t\tgit__free(top);\n\t}\n\treturn item;\n}", "target": 0}
{"code": "PHPAPI ZEND_COLD void php_error_docref1(const char *docref, const char *param1, int type, const char *format, ...)\n{\n\tva_list args;\n\tva_start(args, format);\n\tphp_verror(docref, param1, type, format, args);\n\tva_end(args);\n}", "target": 0}
{"code": "v8::Handle<v8::Value> WindowSetTimeoutImpl(const v8::Arguments& args, bool singleShot)\n{\n    int argumentCount = args.Length();\n    if (argumentCount < 1)\n        return v8::Undefined();\n    DOMWindow* imp = V8DOMWindow::toNative(args.Holder());\n    ScriptExecutionContext* scriptContext = static_cast<ScriptExecutionContext*>(imp->document());\n    if (!scriptContext)\n        return setDOMException(INVALID_ACCESS_ERR, args.GetIsolate());\n    v8::Handle<v8::Value> function = args[0];\n    WTF::String functionString;\n    if (!function->IsFunction()) {\n        if (function->IsString())\n            functionString = toWebCoreString(function);\n        else {\n            v8::Handle<v8::Value> v8String = function->ToString();\n            if (v8String.IsEmpty())\n                return v8::Undefined();\n            functionString = toWebCoreString(v8String);\n        }\n        if (functionString.length() == 0)\n            return v8::Undefined();\n    }\n    int32_t timeout = 0;\n    if (argumentCount >= 2)\n        timeout = args[1]->Int32Value();\n    if (!BindingSecurity::shouldAllowAccessToFrame(imp->frame()))\n        return v8::Undefined();\n    int id;\n    if (function->IsFunction()) {\n        int paramCount = argumentCount >= 2 ? argumentCount - 2 : 0;\n        v8::Local<v8::Value>* params = 0;\n        if (paramCount > 0) {\n            params = new v8::Local<v8::Value>[paramCount];\n            for (int i = 0; i < paramCount; i++)\n                params[i] = args[i+2];\n        }\n        ASSERT(imp->frame());\n        OwnPtr<ScheduledAction> action = adoptPtr(new ScheduledAction(imp->frame()->script()->currentWorldContext(), v8::Handle<v8::Function>::Cast(function), paramCount, params, args.GetIsolate()));\n        delete[] params;\n        id = DOMTimer::install(scriptContext, action.release(), timeout, singleShot);\n    } else {\n        if (imp->document() && !imp->document()->contentSecurityPolicy()->allowEval())\n            return v8Integer(0, args.GetIsolate());\n        ASSERT(imp->frame());\n        id = DOMTimer::install(scriptContext, adoptPtr(new ScheduledAction(imp->frame()->script()->currentWorldContext(), functionString, KURL(), args.GetIsolate())), timeout, singleShot);\n    }\n    double maximumFireInterval = static_cast<double>(timeout) / 1000 / 2;\n    V8GCForContextDispose::instance().notifyIdleSooner(maximumFireInterval);\n    return v8Integer(id, args.GetIsolate());\n}", "target": 0}
{"code": "static void bio_put_slab(struct bio_set *bs)\n{\n\tstruct bio_slab *bslab = NULL;\n\tunsigned int i;\n\tmutex_lock(&bio_slab_lock);\n\tfor (i = 0; i < bio_slab_nr; i++) {\n\t\tif (bs->bio_slab == bio_slabs[i].slab) {\n\t\t\tbslab = &bio_slabs[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (WARN(!bslab, KERN_ERR \"bio: unable to find slab!\\n\"))\n\t\tgoto out;\n\tWARN_ON(!bslab->slab_ref);\n\tif (--bslab->slab_ref)\n\t\tgoto out;\n\tkmem_cache_destroy(bslab->slab);\n\tbslab->slab = NULL;\nout:\n\tmutex_unlock(&bio_slab_lock);\n}", "target": 0}
{"code": "setup_boot_information(struct archive_write *a)\n{\n\tstruct iso9660 *iso9660 = a->format_data;\n\tstruct isoent *np;\n\tint64_t size;\n\tuint32_t sum;\n\tunsigned char buff[4096];\n\tnp = iso9660->el_torito.boot;\n\tlseek(iso9660->temp_fd,\n\t    np->file->content.offset_of_temp + 64, SEEK_SET);\n\tsize = archive_entry_size(np->file->entry) - 64;\n\tif (size <= 0) {\n\t\tarchive_set_error(&a->archive, errno,\n\t\t    \"Boot file(%jd) is too small\", (intmax_t)size + 64);\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\tsum = 0;\n\twhile (size > 0) {\n\t\tsize_t rsize;\n\t\tssize_t i, rs;\n\t\tif (size > (int64_t)sizeof(buff))\n\t\t\trsize = sizeof(buff);\n\t\telse\n\t\t\trsize = (size_t)size;\n\t\trs = read(iso9660->temp_fd, buff, rsize);\n\t\tif (rs <= 0) {\n\t\t\tarchive_set_error(&a->archive, errno,\n\t\t\t    \"Can't read temporary file(%jd)\",\n\t\t\t    (intmax_t)rs);\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tfor (i = 0; i < rs; i += 4)\n\t\t\tsum += archive_le32dec(buff + i);\n\t\tsize -= rs;\n\t}\n\tset_num_731(buff, SYSTEM_AREA_BLOCK);\n\tset_num_731(buff+4, np->file->content.location);\n\tsize = fd_boot_image_size(iso9660->el_torito.media_type);\n\tif (size == 0)\n\t\tsize = archive_entry_size(np->file->entry);\n\tset_num_731(buff+8, (uint32_t)size);\n\tset_num_731(buff+12, sum);\n\tmemset(buff+16, 0, 40);\n\tlseek(iso9660->temp_fd,\n\t    np->file->content.offset_of_temp + 8, SEEK_SET);\n\treturn (write_to_temp(a, buff, 56));\n}", "target": 0}
{"code": "int epo_copy_alpha_hl_color(gx_device *dev, const byte *data, int data_x,\n    int raster, gx_bitmap_id id, int x, int y, int width, int height,\n    const gx_drawing_color *pdcolor, int depth)\n{\n    int code = epo_handle_erase_page(dev);\n    if (code != 0)\n        return code;\n    return dev_proc(dev, copy_alpha_hl_color)(dev, data, data_x, raster, id, x, y, width, height, pdcolor, depth);\n}", "target": 0}
{"code": "void dev_shutdown(struct net_device *dev)\n{\n\tstruct Qdisc *qdisc;\n\tqdisc_lock_tree(dev);\n\tqdisc = dev->qdisc_sleeping;\n\tdev->qdisc = &noop_qdisc;\n\tdev->qdisc_sleeping = &noop_qdisc;\n\tqdisc_destroy(qdisc);\n#if defined(CONFIG_NET_SCH_INGRESS) || defined(CONFIG_NET_SCH_INGRESS_MODULE)\n\tif ((qdisc = dev->qdisc_ingress) != NULL) {\n\t\tdev->qdisc_ingress = NULL;\n\t\tqdisc_destroy(qdisc);\n\t}\n#endif\n\tBUG_TRAP(!timer_pending(&dev->watchdog_timer));\n\tqdisc_unlock_tree(dev);\n}", "target": 0}
{"code": "  Value_Obj Parser::parse_static_value()\n  {\n    lex< static_value >();\n    Token str(lexed);\n    --pstate.offset.column;\n    --after_token.column;\n    --str.end;\n    --position;\n    return color_or_string(str.time_wspace());;\n  }", "target": 0}
{"code": "static int check_ctx_access(struct bpf_verifier_env *env, int insn_idx, int off, int size,\n\t\t\t    enum bpf_access_type t, enum bpf_reg_type *reg_type,\n\t\t\t    u32 *btf_id)\n{\n\tstruct bpf_insn_access_aux info = {\n\t\t.reg_type = *reg_type,\n\t\t.log = &env->log,\n\t};\n\tif (env->ops->is_valid_access &&\n\t    env->ops->is_valid_access(off, size, t, env->prog, &info)) {\n\t\t*reg_type = info.reg_type;\n\t\tif (*reg_type == PTR_TO_BTF_ID)\n\t\t\t*btf_id = info.btf_id;\n\t\telse\n\t\t\tenv->insn_aux_data[insn_idx].ctx_field_size = info.ctx_field_size;\n\t\tif (env->prog->aux->max_ctx_offset < off + size)\n\t\t\tenv->prog->aux->max_ctx_offset = off + size;\n\t\treturn 0;\n\t}\n\tverbose(env, \"invalid bpf_context access off=%d size=%d\\n\", off, size);\n\treturn -EACCES;\n}", "target": 0}
{"code": "TEST_F(HeaderToMetadataTest, DefaultEndpointsTest) {\n  initializeFilter(request_config_yaml);\n  Http::TestRequestHeaderMapImpl incoming_headers{{\"X-FOO\", \"bar\"}};\n  std::map<std::string, std::string> expected = {{\"default\", \"true\"}};\n  EXPECT_CALL(decoder_callbacks_, streamInfo()).WillRepeatedly(ReturnRef(req_info_));\n  EXPECT_CALL(req_info_, setDynamicMetadata(\"envoy.lb\", MapEq(expected)));\n  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->decodeHeaders(incoming_headers, false));\n}", "target": 0}
{"code": "void WasmBinaryWriter::writeEscapedName(const char* name) {\n  assert(name);\n  if (!strpbrk(name, \"\\\\\")) {\n    writeInlineString(name);\n    return;\n  }\n  std::string unescaped;\n  int32_t size = strlen(name);\n  for (int32_t i = 0; i < size;) {\n    char ch = name[i++];\n    if (ch != '\\\\' || i + 1 >= size || !isHexDigit(name[i]) ||\n        !isHexDigit(name[i + 1])) {\n      unescaped.push_back(ch);\n      continue;\n    }\n    unescaped.push_back(\n      char((decodeHexNibble(name[i]) << 4) | decodeHexNibble(name[i + 1])));\n    i += 2;\n  }\n  writeInlineString(unescaped.c_str());\n}", "target": 0}
{"code": "\t\tbnx2x_prev_path_get_entry(struct bnx2x *bp)\n{\n\tstruct bnx2x_prev_path_list *tmp_list;\n\tlist_for_each_entry(tmp_list, &bnx2x_prev_list, list)\n\t\tif (PCI_SLOT(bp->pdev->devfn) == tmp_list->slot &&\n\t\t    bp->pdev->bus->number == tmp_list->bus &&\n\t\t    BP_PATH(bp) == tmp_list->path)\n\t\t\treturn tmp_list;\n\treturn NULL;\n}", "target": 0}
{"code": "spnego_gss_export_cred(OM_uint32 *minor_status,\n\t\t       gss_cred_id_t cred_handle,\n\t\t       gss_buffer_t token)\n{\n\tspnego_gss_cred_id_t spcred = (spnego_gss_cred_id_t)cred_handle;\n\treturn (gss_export_cred(minor_status, spcred->mcred, token));\n}", "target": 0}
{"code": "static int orinoco_ioctl_set_auth(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\thermes_t *hw = &priv->hw;\n\tstruct iw_param *param = &wrqu->param;\n\tunsigned long flags;\n\tint ret = -EINPROGRESS;\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\tswitch (param->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_WPA_VERSION:\n\tcase IW_AUTH_CIPHER_PAIRWISE:\n\tcase IW_AUTH_CIPHER_GROUP:\n\tcase IW_AUTH_RX_UNENCRYPTED_EAPOL:\n\tcase IW_AUTH_PRIVACY_INVOKED:\n\tcase IW_AUTH_DROP_UNENCRYPTED:\n\t\tbreak;\n\tcase IW_AUTH_KEY_MGMT:\n\t\tpriv->key_mgmt = param->value;\n\t\tbreak;\n\tcase IW_AUTH_TKIP_COUNTERMEASURES:\n \t\tif (param->value) {\n \t\t\tpriv->tkip_cm_active = 1;\n\t\t\tret = hermes_disable_port(hw, 0);\n \t\t} else {\n \t\t\tpriv->tkip_cm_active = 0;\n\t\t\tret = hermes_enable_port(hw, 0);\n \t\t}\n \t\tbreak;\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tif (param->value & IW_AUTH_ALG_SHARED_KEY)\n\t\t\tpriv->wep_restrict = 1;\n\t\telse if (param->value & IW_AUTH_ALG_OPEN_SYSTEM)\n\t\t\tpriv->wep_restrict = 0;\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tif (priv->has_wpa) {\n\t\t\tpriv->wpa_enabled = param->value ? 1 : 0;\n\t\t} else {\n\t\t\tif (param->value)\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\tpriv->wpa_enabled = 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t}\n\torinoco_unlock(priv, &flags);\n\treturn ret;\n}", "target": 0}
{"code": "findtags_apply_tfu(findtags_state_T *st, char_u *pat, char_u *buf_ffname)\n{\n    int\t\tuse_tfu = ((st->flags & TAG_NO_TAGFUNC) == 0);\n    int\t\tretval;\n    if (!use_tfu || tfu_in_use || *curbuf->b_p_tfu == NUL)\n\treturn NOTDONE;\n    tfu_in_use = TRUE;\n    retval = find_tagfunc_tags(pat, st->ga_match, &st->match_count,\n\t\t\t\t\t\tst->flags, buf_ffname);\n    tfu_in_use = FALSE;\n    return retval;\n}", "target": 0}
{"code": "TEST_F(ExprMatchTest, FailGracefullyOnInvalidExpression) {\n    ASSERT_THROWS_CODE(createMatcher(fromjson(\"{$expr: {$anyElementTrue: undefined}}\")),\n                       AssertionException,\n                       17041);\n    ASSERT_THROWS_CODE(\n        createMatcher(fromjson(\"{$and: [{x: 1},{$expr: {$anyElementTrue: undefined}}]}\")),\n        AssertionException,\n        17041);\n    ASSERT_THROWS_CODE(\n        createMatcher(fromjson(\"{$or: [{x: 1},{$expr: {$anyElementTrue: undefined}}]}\")),\n        AssertionException,\n        17041);\n    ASSERT_THROWS_CODE(\n        createMatcher(fromjson(\"{$nor: [{x: 1},{$expr: {$anyElementTrue: undefined}}]}\")),\n        AssertionException,\n        17041);\n}", "target": 0}
{"code": "MagickExport MagickBooleanType ListLocaleInfo(FILE *file,\n  ExceptionInfo *exception)\n{\n  const char\n    *path;\n  const LocaleInfo\n    **locale_info;\n  register ssize_t\n    i;\n  size_t\n    number_messages;\n  if (file == (const FILE *) NULL)\n    file=stdout;\n  number_messages=0;\n  locale_info=GetLocaleInfoList(\"*\",&number_messages,exception);\n  if (locale_info == (const LocaleInfo **) NULL)\n    return(MagickFalse);\n  path=(const char *) NULL;\n  for (i=0; i < (ssize_t) number_messages; i++)\n  {\n    if (locale_info[i]->stealth != MagickFalse)\n      continue;\n    if ((path == (const char *) NULL) ||\n        (LocaleCompare(path,locale_info[i]->path) != 0))\n      {\n        if (locale_info[i]->path != (char *) NULL)\n          (void) FormatLocaleFile(file,\"\\nPath: %s\\n\\n\",locale_info[i]->path);\n        (void) FormatLocaleFile(file,\"Tag/Message\\n\");\n        (void) FormatLocaleFile(file,\n          \"-------------------------------------------------\"\n          \"------------------------------\\n\");\n      }\n    path=locale_info[i]->path;\n    (void) FormatLocaleFile(file,\"%s\\n\",locale_info[i]->tag);\n    if (locale_info[i]->message != (char *) NULL)\n      (void) FormatLocaleFile(file,\"  %s\",locale_info[i]->message);\n    (void) FormatLocaleFile(file,\"\\n\");\n  }\n  (void) fflush(file);\n  locale_info=(const LocaleInfo **)\n    RelinquishMagickMemory((void *) locale_info);\n  return(MagickTrue);\n}", "target": 0}
{"code": "static void calc_group_buffer(JOIN *join, ORDER *group)\n{\n  if (group)\n    join->group= 1;\n  calc_group_buffer(&join->tmp_table_param, group);\n}", "target": 0}
{"code": "fz_drop_colorspace(fz_context *ctx, fz_colorspace *cs)\n{\n\tfz_drop_key_storable(ctx, &cs->key_storable);\n}", "target": 0}
{"code": "      void from_sync_pipe_filter(const rgw_sync_pipe_filter& f) {\n        if (f.prefix && f.tags.empty()) {\n          prefix = f.prefix;\n          return;\n        }\n        if (f.prefix) {\n          and_elements.emplace();\n          and_elements->prefix = f.prefix;\n        } else if (f.tags.size() == 1) {\n          auto iter = f.tags.begin();\n          if (iter == f.tags.end()) {\n            return;\n          }\n          auto& t = *iter;\n          tag.emplace();\n          tag->key = t.key;\n          tag->value = t.value;\n          return;\n        }\n        if (f.tags.empty()) {\n          return;\n        }\n        if (!and_elements) {\n          and_elements.emplace();\n        }\n        for (auto& t : f.tags) {\n          auto& tag = and_elements->tags.emplace_back();\n          tag.key = t.key;\n          tag.value = t.value;\n        }\n      }", "target": 0}
{"code": "unsigned int vcc_poll(struct file *file, struct socket *sock, poll_table *wait)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct atm_vcc *vcc;\n\tunsigned int mask;\n\tsock_poll_wait(file, sk_sleep(sk), wait);\n\tmask = 0;\n\tvcc = ATM_SD(sock);\n\tif (sk->sk_err)\n\t\tmask = POLLERR;\n\tif (test_bit(ATM_VF_RELEASED, &vcc->flags) ||\n\t    test_bit(ATM_VF_CLOSE, &vcc->flags))\n\t\tmask |= POLLHUP;\n\tif (!skb_queue_empty(&sk->sk_receive_queue))\n\t\tmask |= POLLIN | POLLRDNORM;\n\tif (sock->state == SS_CONNECTING &&\n\t    test_bit(ATM_VF_WAITING, &vcc->flags))\n\t\treturn mask;\n\tif (vcc->qos.txtp.traffic_class != ATM_NONE &&\n\t    vcc_writable(sk))\n\t\tmask |= POLLOUT | POLLWRNORM | POLLWRBAND;\n\treturn mask;\n}", "target": 0}
{"code": "match_begin(VALUE match, VALUE n)\n{\n    int i = match_backref_number(match, n);\n    struct re_registers *regs = RMATCH_REGS(match);\n    match_check(match);\n    if (i < 0 || regs->num_regs <= i)\n\trb_raise(rb_eIndexError, \"index %d out of matches\", i);\n    if (BEG(i) < 0)\n\treturn Qnil;\n    update_char_offset(match);\n    return INT2FIX(RMATCH(match)->rmatch->char_offset[i].beg);\n}", "target": 0}
{"code": "void QuitMainThreadMessageLoop() {\n  base::MessageLoop::current()->Quit();\n}", "target": 0}
{"code": "void smp_match_dhkey_checks(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n  SMP_TRACE_DEBUG(\"%s\", __func__);\n if (memcmp(p_data->key.p_data, p_cb->remote_dhkey_check, BT_OCTET16_LEN)) {\n    SMP_TRACE_WARNING(\"dhkey chcks do no match\");\n    tSMP_INT_DATA smp_int_data;\n    smp_int_data.status = SMP_DHKEY_CHK_FAIL;\n    p_cb->failure = SMP_DHKEY_CHK_FAIL;\n    smp_sm_event(p_cb, SMP_AUTH_CMPL_EVT, &smp_int_data);\n return;\n }\n  SMP_TRACE_EVENT(\"dhkey chcks match\");\n if (p_cb->peer_enc_size < p_cb->loc_enc_size)\n    p_cb->loc_enc_size = p_cb->peer_enc_size;\n if (p_cb->role == HCI_ROLE_SLAVE) {\n    smp_sm_event(p_cb, SMP_PAIR_DHKEY_CHCK_EVT, NULL);\n } else {\n    p_cb->local_i_key = p_cb->peer_i_key;\n    p_cb->local_r_key = p_cb->peer_r_key;\n    smp_sm_event(p_cb, SMP_ENC_REQ_EVT, NULL);\n }\n}", "target": 0}
{"code": "static int __rtnl_recvmsg(int fd, struct msghdr *msg, int flags)\n{\n\tint len;\n\tdo {\n\t\tlen = recvmsg(fd, msg, flags);\n\t} while (len < 0 && (errno == EINTR || errno == EAGAIN));\n\tif (len < 0) {\n\t\tfprintf(stderr, \"netlink receive error %s (%d)\\n\",\n\t\t\tstrerror(errno), errno);\n\t\treturn -errno;\n\t}\n\tif (len == 0) {\n\t\tfprintf(stderr, \"EOF on netlink\\n\");\n\t\treturn -ENODATA;\n\t}\n\treturn len;\n}", "target": 0}
{"code": "xmlDumpElementDecl(xmlBufferPtr buf, xmlElementPtr elem) {\n    if ((buf == NULL) || (elem == NULL))\n        return;\n    switch (elem->etype) {\n\tcase XML_ELEMENT_TYPE_EMPTY:\n\t    xmlBufferWriteChar(buf, \"<!ELEMENT \");\n\t    if (elem->prefix != NULL) {\n\t\txmlBufferWriteCHAR(buf, elem->prefix);\n\t\txmlBufferWriteChar(buf, \":\");\n\t    }\n\t    xmlBufferWriteCHAR(buf, elem->name);\n\t    xmlBufferWriteChar(buf, \" EMPTY>\\n\");\n\t    break;\n\tcase XML_ELEMENT_TYPE_ANY:\n\t    xmlBufferWriteChar(buf, \"<!ELEMENT \");\n\t    if (elem->prefix != NULL) {\n\t\txmlBufferWriteCHAR(buf, elem->prefix);\n\t\txmlBufferWriteChar(buf, \":\");\n\t    }\n\t    xmlBufferWriteCHAR(buf, elem->name);\n\t    xmlBufferWriteChar(buf, \" ANY>\\n\");\n\t    break;\n\tcase XML_ELEMENT_TYPE_MIXED:\n\t    xmlBufferWriteChar(buf, \"<!ELEMENT \");\n\t    if (elem->prefix != NULL) {\n\t\txmlBufferWriteCHAR(buf, elem->prefix);\n\t\txmlBufferWriteChar(buf, \":\");\n\t    }\n\t    xmlBufferWriteCHAR(buf, elem->name);\n\t    xmlBufferWriteChar(buf, \" \");\n\t    xmlDumpElementContent(buf, elem->content, 1);\n\t    xmlBufferWriteChar(buf, \">\\n\");\n\t    break;\n\tcase XML_ELEMENT_TYPE_ELEMENT:\n\t    xmlBufferWriteChar(buf, \"<!ELEMENT \");\n\t    if (elem->prefix != NULL) {\n\t\txmlBufferWriteCHAR(buf, elem->prefix);\n\t\txmlBufferWriteChar(buf, \":\");\n\t    }\n\t    xmlBufferWriteCHAR(buf, elem->name);\n\t    xmlBufferWriteChar(buf, \" \");\n\t    xmlDumpElementContent(buf, elem->content, 1);\n\t    xmlBufferWriteChar(buf, \">\\n\");\n\t    break;\n\tdefault:\n\t    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t    \"Internal: ELEMENT struct corrupted invalid type\\n\",\n\t\t    NULL);\n    }\n}", "target": 0}
{"code": "void USBMountObserver::Observe(NotificationType type,\n                               const NotificationSource& source,\n                               const NotificationDetails& details) {\n  DCHECK(type == NotificationType::BROWSER_CLOSED);\n  for (BrowserIterator i = browsers_.begin(); i != browsers_.end();\n       ++i) {\n    if (Source<Browser>(source).ptr() == i->browser) {\n      i->browser = NULL;\n      registrar_.Remove(this,\n                        NotificationType::BROWSER_CLOSED,\n                        source);\n      return;\n    }\n  }\n}", "target": 0}
{"code": "ProcRecordCreateContext(ClientPtr client)\n{\n    REQUEST(xRecordCreateContextReq);\n    RecordContextPtr pContext;\n    RecordContextPtr *ppNewAllContexts = NULL;\n    int err = BadAlloc;\n    REQUEST_AT_LEAST_SIZE(xRecordCreateContextReq);\n    LEGAL_NEW_RESOURCE(stuff->context, client);\n    pContext = (RecordContextPtr) malloc(sizeof(RecordContextRec));\n    if (!pContext)\n        goto bailout;\n    ppNewAllContexts =\n        reallocarray(ppAllContexts, numContexts + 1, sizeof(RecordContextPtr));\n    if (!ppNewAllContexts)\n        goto bailout;\n    ppAllContexts = ppNewAllContexts;\n    pContext->id = stuff->context;\n    pContext->pRecordingClient = NULL;\n    pContext->pListOfRCAP = NULL;\n    pContext->elemHeaders = 0;\n    pContext->bufCategory = 0;\n    pContext->numBufBytes = 0;\n    pContext->pBufClient = NULL;\n    pContext->continuedReply = 0;\n    pContext->inFlush = 0;\n    err = RecordRegisterClients(pContext, client,\n                                (xRecordRegisterClientsReq *) stuff);\n    if (err != Success)\n        goto bailout;\n    if (AddResource(pContext->id, RTContext, pContext)) {\n        ppAllContexts[numContexts++] = pContext;\n        return Success;\n    }\n    else {\n        return BadAlloc;\n    }\n bailout:\n    free(pContext);\n    return err;\n}                               ", "target": 0}
{"code": "ZEND_API void zend_merge_properties(zval *obj, HashTable *properties, int destroy_ht TSRMLS_DC) \n{\n\tconst zend_object_handlers *obj_ht = Z_OBJ_HT_P(obj);\n\tzend_class_entry *old_scope = EG(scope);\n\tEG(scope) = Z_OBJCE_P(obj);\n\tzend_hash_apply_with_arguments(properties TSRMLS_CC, (apply_func_args_t)zend_merge_property, 2, obj, obj_ht);\n\tEG(scope) = old_scope;\n\tif (destroy_ht) {\n\t\tzend_hash_destroy(properties);\n\t\tFREE_HASHTABLE(properties);\n\t}\n}", "target": 0}
{"code": "static void vnc_client_cache_auth(VncState *client)\n{\n    if (!client->info) {\n        return;\n    }\n    if (client->tls) {\n        client->info->x509_dname =\n            qcrypto_tls_session_get_peer_name(client->tls);\n        client->info->has_x509_dname =\n            client->info->x509_dname != NULL;\n    }\n#ifdef CONFIG_VNC_SASL\n    if (client->sasl.conn &&\n        client->sasl.username) {\n        client->info->has_sasl_username = true;\n        client->info->sasl_username = g_strdup(client->sasl.username);\n    }\n#endif\n}", "target": 0}
{"code": "  DumpOriginInfoTableTask(\n      QuotaManager* manager,\n      Callback* callback)\n      : DatabaseTaskBase(manager),\n        callback_(callback) {\n  }", "target": 0}
{"code": "InotifyReader::InotifyReader()\n    : thread_(\"inotify_reader\"),\n      inotify_fd_(inotify_init()),\n      valid_(false) {\n  shutdown_pipe_[0] = -1;\n  shutdown_pipe_[1] = -1;\n  if (inotify_fd_ >= 0 && pipe(shutdown_pipe_) == 0 && thread_.Start()) {\n    thread_.message_loop()->PostTask(\n        FROM_HERE, new InotifyReaderTask(this, inotify_fd_, shutdown_pipe_[0]));\n    valid_ = true;\n  }\n}", "target": 0}
{"code": "GF_Err akey_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs);\n}", "target": 0}
{"code": "int install_user_keyrings(void)\n{\n\tstruct user_struct *user;\n\tconst struct cred *cred;\n\tstruct key *uid_keyring, *session_keyring;\n\tchar buf[20];\n\tint ret;\n\tcred = current_cred();\n\tuser = cred->user;\n\tkenter(\"%p{%u}\", user, user->uid);\n\tif (user->uid_keyring) {\n\t\tkleave(\" = 0 [exist]\");\n\t\treturn 0;\n\t}\n\tmutex_lock(&key_user_keyring_mutex);\n\tret = 0;\n\tif (!user->uid_keyring) {\n\t\tsprintf(buf, \"_uid.%u\", user->uid);\n\t\tuid_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(uid_keyring)) {\n\t\t\tuid_keyring = keyring_alloc(buf, user->uid, (gid_t) -1,\n\t\t\t\t\t\t    cred, KEY_ALLOC_IN_QUOTA,\n\t\t\t\t\t\t    NULL);\n\t\t\tif (IS_ERR(uid_keyring)) {\n\t\t\t\tret = PTR_ERR(uid_keyring);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tsprintf(buf, \"_uid_ses.%u\", user->uid);\n\t\tsession_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(session_keyring)) {\n\t\t\tsession_keyring =\n\t\t\t\tkeyring_alloc(buf, user->uid, (gid_t) -1,\n\t\t\t\t\t      cred, KEY_ALLOC_IN_QUOTA, NULL);\n\t\t\tif (IS_ERR(session_keyring)) {\n\t\t\t\tret = PTR_ERR(session_keyring);\n\t\t\t\tgoto error_release;\n\t\t\t}\n\t\t\tret = key_link(session_keyring, uid_keyring);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_release_both;\n\t\t}\n\t\tuser->uid_keyring = uid_keyring;\n\t\tuser->session_keyring = session_keyring;\n\t}\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = 0\");\n\treturn 0;\nerror_release_both:\n\tkey_put(session_keyring);\nerror_release:\n\tkey_put(uid_keyring);\nerror:\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}", "target": 0}
{"code": "GF_ISOTrackID gf_isom_get_track_id(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tif (!movie) return 0;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Header) return 0;\n\treturn trak->Header->trackID;\n}", "target": 0}
{"code": "int __cond_resched_lock(spinlock_t *lock)\n{\n\tint resched = should_resched(PREEMPT_LOCK_OFFSET);\n\tint ret = 0;\n\tlockdep_assert_held(lock);\n\tif (spin_needbreak(lock) || resched) {\n\t\tspin_unlock(lock);\n\t\tif (resched)\n\t\t\tpreempt_schedule_common();\n\t\telse\n\t\t\tcpu_relax();\n\t\tret = 1;\n\t\tspin_lock(lock);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "size_t snd_dma_get_reserved_buf(struct snd_dma_buffer *dmab, unsigned int id)\n{\n\tstruct snd_mem_list *mem;\n\tsnd_assert(dmab, return 0);\n\tmutex_lock(&list_mutex);\n\tlist_for_each_entry(mem, &mem_list_head, list) {\n\t\tif (mem->id == id &&\n\t\t    (mem->buffer.dev.dev == NULL || dmab->dev.dev == NULL ||\n\t\t     ! memcmp(&mem->buffer.dev, &dmab->dev, sizeof(dmab->dev)))) {\n\t\t\tstruct device *dev = dmab->dev.dev;\n\t\t\tlist_del(&mem->list);\n\t\t\t*dmab = mem->buffer;\n\t\t\tif (dmab->dev.dev == NULL)\n\t\t\t\tdmab->dev.dev = dev;\n\t\t\tkfree(mem);\n\t\t\tmutex_unlock(&list_mutex);\n\t\t\treturn dmab->bytes;\n\t\t}\n\t}\n\tmutex_unlock(&list_mutex);\n\treturn 0;\n}", "target": 0}
{"code": "void RenderView::OnSetContentSettingsForLoadingURL(\n    const GURL& url,\n    const ContentSettings& content_settings) {\n  host_content_settings_[url] = content_settings;\n}", "target": 0}
{"code": "static int expand_ipv6(char *addr, int type)\n{\n\tint ret;\n\tstruct in6_addr v6_addr;\n\tret = inet_pton(AF_INET6, addr, &v6_addr);\n\tif (ret != 1) {\n\t\tif (type == NETMASK)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tsprintf(addr, \"%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:\"\n\t\t\"%02x%02x:%02x%02x:%02x%02x\",\n\t\t(int)v6_addr.s6_addr[0], (int)v6_addr.s6_addr[1],\n\t\t(int)v6_addr.s6_addr[2], (int)v6_addr.s6_addr[3],\n\t\t(int)v6_addr.s6_addr[4], (int)v6_addr.s6_addr[5],\n\t\t(int)v6_addr.s6_addr[6], (int)v6_addr.s6_addr[7],\n\t\t(int)v6_addr.s6_addr[8], (int)v6_addr.s6_addr[9],\n\t\t(int)v6_addr.s6_addr[10], (int)v6_addr.s6_addr[11],\n\t\t(int)v6_addr.s6_addr[12], (int)v6_addr.s6_addr[13],\n\t\t(int)v6_addr.s6_addr[14], (int)v6_addr.s6_addr[15]);\n\treturn 1;\n}", "target": 0}
{"code": "static bool vmci_transport_dgram_allow(u32 cid, u32 port)\n{\n\tif (cid == VMADDR_CID_HYPERVISOR) {\n\t\treturn port == VMCI_UNITY_PBRPC_REGISTER;\n\t}\n\treturn true;\n}", "target": 0}
{"code": "static inline void add_partial(struct kmem_cache_node *n,\n\t\t\t\tstruct page *page, int tail)\n{\n\tlockdep_assert_held(&n->list_lock);\n\t__add_partial(n, page, tail);\n}", "target": 0}
{"code": "ofpact_check_output_port(ofp_port_t port, ofp_port_t max_ports)\n{\n    switch (port) {\n    case OFPP_IN_PORT:\n    case OFPP_TABLE:\n    case OFPP_NORMAL:\n    case OFPP_FLOOD:\n    case OFPP_ALL:\n    case OFPP_CONTROLLER:\n    case OFPP_LOCAL:\n        return 0;\n    case OFPP_NONE:\n        return OFPERR_OFPBAC_BAD_OUT_PORT;\n    default:\n        if (ofp_to_u16(port) < ofp_to_u16(max_ports)) {\n            return 0;\n        }\n        return OFPERR_OFPBAC_BAD_OUT_PORT;\n    }\n}", "target": 0}
{"code": "static inline void packet_increment_head(struct packet_ring_buffer *buff)\n{\n\tbuff->head = buff->head != buff->frame_max ? buff->head+1 : 0;\n}", "target": 0}
{"code": "compute_object_path (const char *native_path)\n{\n  const gchar *basename;\n  GString *s;\n  guint n;\n  g_return_val_if_fail (native_path != NULL, NULL);\n  basename = strrchr (native_path, '/');\n  if (basename != NULL)\n    {\n      basename++;\n    }\n  else\n    {\n      basename = native_path;\n    }\n  s = g_string_new (\"/org/freedesktop/UDisks/devices/\");\n  for (n = 0; basename[n] != '\\0'; n++)\n    {\n      gint c = basename[n];\n      if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9'))\n        {\n          g_string_append_c (s, c);\n        }\n      else\n        {\n          g_string_append_printf (s, \"_%02x\", c);\n        }\n    }\n  return g_string_free (s, FALSE);\n}", "target": 0}
{"code": "    bool TiffBinaryArray::initialize(TiffComponent* const pRoot)\n    {\n        if (cfgSelFct_ == 0) return true; \n        int idx = cfgSelFct_(tag(), pData(), TiffEntryBase::doSize(), pRoot);\n        if (idx > -1) {\n            arrayCfg_ = &arraySet_[idx].cfg_;\n            arrayDef_ = arraySet_[idx].def_;\n            defSize_  = arraySet_[idx].defSize_;\n        }\n        return idx > -1;\n    }", "target": 0}
{"code": "reg_enc_error(VALUE re, VALUE str)\n{\n    rb_raise(rb_eEncCompatError,\n\t     \"incompatible encoding regexp match (%s regexp with %s string)\",\n\t     rb_enc_name(rb_enc_get(re)),\n\t     rb_enc_name(rb_enc_get(str)));\n}", "target": 0}
{"code": "static void floppy_ready(void)\n{\n\tif (FDCS->reset) {\n\t\treset_fdc();\n\t\treturn;\n\t}\n\tif (start_motor(floppy_ready))\n\t\treturn;\n\tif (fdc_dtr())\n\t\treturn;\n\tdebug_dcl(DP->flags, \"calling disk change from floppy_ready\\n\");\n\tif (!(raw_cmd->flags & FD_RAW_NO_MOTOR) &&\n\t    disk_change(current_drive) && !DP->select_delay)\n\t\ttwaddle();\t\n#ifdef fd_chose_dma_mode\n\tif ((raw_cmd->flags & FD_RAW_READ) || (raw_cmd->flags & FD_RAW_WRITE)) {\n\t\tunsigned long flags = claim_dma_lock();\n\t\tfd_chose_dma_mode(raw_cmd->kernel_data, raw_cmd->length);\n\t\trelease_dma_lock(flags);\n\t}\n#endif\n\tif (raw_cmd->flags & (FD_RAW_NEED_SEEK | FD_RAW_NEED_DISK)) {\n\t\tperpendicular_mode();\n\t\tfdc_specify();\t\n\t\tseek_floppy();\n\t} else {\n\t\tif ((raw_cmd->flags & FD_RAW_READ) ||\n\t\t    (raw_cmd->flags & FD_RAW_WRITE))\n\t\t\tfdc_specify();\n\t\tsetup_rw_floppy();\n\t}\n}", "target": 0}
{"code": "static struct fuse *req_fuse(fuse_req_t req)\n{\n    return (struct fuse *) fuse_req_userdata(req);\n}", "target": 0}
{"code": "GLenum GLES2DecoderImpl::GetBoundDrawFrameBufferInternalFormat() {\n  FramebufferManager::FramebufferInfo* framebuffer =\n      GetFramebufferInfoForTarget(GL_DRAW_FRAMEBUFFER);\n  if (framebuffer != NULL) {\n    return framebuffer->GetColorAttachmentFormat();\n  } else if (offscreen_target_frame_buffer_.get()) {\n    return offscreen_target_color_format_;\n  } else {\n    return back_buffer_color_format_;\n  }\n}", "target": 0}
{"code": "test_extract_length_at_end(void)\n{\n\tconst char *refname = \"test_read_format_zip_length_at_end.zip\";\n\tchar *p;\n\tsize_t s;\n\tstruct archive *a;\n\textract_reference_file(refname);\n\tassert((a = archive_read_new()) != NULL);\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_support_filter_all(a));\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_all(a));\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_open_filename(a, refname, 10240));\n\tverify_extract_length_at_end(a, 1);\n\tp = slurpfile(&s, refname);\n\tassert((a = archive_read_new()) != NULL);\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_support_filter_all(a));\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_all(a));\n\tassertEqualIntA(a, ARCHIVE_OK, read_open_memory(a, p, s, 108));\n\tverify_extract_length_at_end(a, 0);\n\tfree(p);\n}", "target": 0}
{"code": "static inline struct sock *__udp4_lib_lookup_skb(struct sk_buff *skb,\n\t\t\t\t\t\t __be16 sport, __be16 dport,\n\t\t\t\t\t\t struct udp_table *udptable)\n{\n\tconst struct iphdr *iph = ip_hdr(skb);\n\treturn __udp4_lib_lookup(dev_net(skb_dst(skb)->dev), iph->saddr, sport,\n\t\t\t\t iph->daddr, dport, inet_iif(skb),\n\t\t\t\t udptable);\n}", "target": 0}
{"code": "MYSQL_FIELD_OFFSET STDCALL mysql_field_tell(MYSQL_RES *res)\n{\n  return (res)->current_field;\n}", "target": 0}
{"code": "static inline void snow_set_blocks(SnowContext *s, int level, int x, int y, int l, int cb, int cr, int mx, int my, int ref, int type){\n    const int w= s->b_width << s->block_max_depth;\n    const int rem_depth= s->block_max_depth - level;\n    const int index= (x + y*w) << rem_depth;\n    const int block_w= 1<<rem_depth;\n    BlockNode block;\n    int i,j;\n    block.color[0]= l;\n    block.color[1]= cb;\n    block.color[2]= cr;\n    block.mx= mx;\n    block.my= my;\n    block.ref= ref;\n    block.type= type;\n    block.level= level;\n    for(j=0; j<block_w; j++){\n        for(i=0; i<block_w; i++){\n            s->block[index + i + j*w]= block;\n        }\n    }\n}", "target": 0}
{"code": "\t\tint num_digits(int val)\n\t\t{\n\t\t\tint ret = 1;\n\t\t\twhile (val >= 10)\n\t\t\t{\n\t\t\t\t++ret;\n\t\t\t\tval /= 10;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}", "target": 0}
{"code": "self_recursively_generated_p (ipcp_value<tree> *val)\n{\n  class ipa_node_params *info = NULL;\n  for (ipcp_value_source<tree> *src = val->sources; src; src = src->next)\n    {\n      cgraph_edge *cs = src->cs;\n      if (!src->val || cs->caller != cs->callee->function_symbol ()\n\t  || src->val == val)\n\treturn false;\n      if (!info)\n\tinfo = IPA_NODE_REF (cs->caller);\n      class ipcp_param_lattices *plats = ipa_get_parm_lattices (info,\n\t\t\t\t\t\t\t\tsrc->index);\n      ipcp_lattice<tree> *src_lat = src->offset == -1 ? &plats->itself\n\t\t\t\t\t\t      : plats->aggs;\n      ipcp_value<tree> *src_val;\n      for (src_val = src_lat->values; src_val; src_val = src_val->next)\n\tif (src_val == val)\n\t  break;\n      if (!src_val)\n\treturn false;\n    }\n  return true;\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::DidCompleteResizeOrRepaint(\n    const ViewHostMsg_ResizeOrRepaint_ACK_Params& params,\n    const TimeTicks& paint_start) {\n  TRACE_EVENT0(\"renderer_host\",\n               \"RenderWidgetHostImpl::DidCompleteResizeOrRepaint\");\n  NotificationService::current()->Notify(\n      NOTIFICATION_RENDER_WIDGET_HOST_DID_COMPLETE_RESIZE_OR_REPAINT,\n      Source<RenderWidgetHost>(this), NotificationService::NoDetails());\n  if (is_hidden_)\n    return;\n  bool is_resize_ack =\n      ViewHostMsg_ResizeOrRepaint_ACK_Flags::is_resize_ack(params.flags);\n  if (is_resize_ack)\n    WasResized();\n}", "target": 0}
{"code": "bool HTMLButtonElement::isInteractiveContent() const\n{\n     return true;\n }", "target": 0}
{"code": "void smbd_setup_sig_term_handler(void)\n{\n\tstruct tevent_signal *se;\n\tse = tevent_add_signal(smbd_event_context(),\n\t\t\t       smbd_event_context(),\n\t\t\t       SIGTERM, 0,\n\t\t\t       smbd_sig_term_handler,\n\t\t\t       NULL);\n\tif (!se) {\n\t\texit_server(\"failed to setup SIGTERM handler\");\n\t}\n}", "target": 0}
{"code": "static int handle_cpuid(struct kvm_vcpu *vcpu)\n{\n\tkvm_emulate_cpuid(vcpu);\n\treturn 1;\n}", "target": 0}
{"code": "static inline void io_wqe_remove_pending(struct io_wqe *wqe,\n\t\t\t\t\t struct io_wq_work *work,\n\t\t\t\t\t struct io_wq_work_node *prev)\n{\n\tstruct io_wqe_acct *acct = io_work_get_acct(wqe, work);\n\tunsigned int hash = io_get_work_hash(work);\n\tstruct io_wq_work *prev_work = NULL;\n\tif (io_wq_is_hashed(work) && work == wqe->hash_tail[hash]) {\n\t\tif (prev)\n\t\t\tprev_work = container_of(prev, struct io_wq_work, list);\n\t\tif (prev_work && io_get_work_hash(prev_work) == hash)\n\t\t\twqe->hash_tail[hash] = prev_work;\n\t\telse\n\t\t\twqe->hash_tail[hash] = NULL;\n\t}\n\twq_list_del(&acct->work_list, &work->list, prev);\n}", "target": 0}
{"code": "NCR_ChangeRemoteAddress(NCR_Instance inst, NTP_Remote_Address *remote_addr)\n{\n  inst->remote_addr = *remote_addr;\n  inst->tx_count = 0;\n  inst->presend_done = 0;\n  if (inst->mode == MODE_CLIENT)\n    close_client_socket(inst);\n  else {\n    NIO_CloseServerSocket(inst->local_addr.sock_fd);\n    inst->local_addr.sock_fd = NIO_OpenServerSocket(remote_addr);\n  }\n  SRC_SetRefid(inst->source, UTI_IPToRefid(&remote_addr->ip_addr),\n               &inst->remote_addr.ip_addr);\n  SRC_ResetInstance(inst->source);\n}", "target": 0}
{"code": "void CorePageLoadMetricsObserver::OnParseStop(\n    const page_load_metrics::PageLoadTiming& timing,\n    const page_load_metrics::PageLoadExtraInfo& info) {\n  base::TimeDelta parse_duration =\n      timing.parse_stop.value() - timing.parse_start.value();\n  if (WasStartedInForegroundOptionalEventInForeground(timing.parse_stop,\n                                                      info)) {\n    PAGE_LOAD_HISTOGRAM(internal::kHistogramParseDurationImmediate,\n                        parse_duration);\n    PAGE_LOAD_HISTOGRAM(internal::kHistogramParseBlockedOnScriptLoadImmediate,\n                        timing.parse_blocked_on_script_load_duration.value());\n    PAGE_LOAD_HISTOGRAM(\n        internal::kHistogramParseBlockedOnScriptLoadDocumentWriteImmediate,\n        timing.parse_blocked_on_script_load_from_document_write_duration\n            .value());\n  } else {\n    PAGE_LOAD_HISTOGRAM(internal::kBackgroundHistogramParseDurationImmediate,\n                        parse_duration);\n    PAGE_LOAD_HISTOGRAM(\n        internal::kBackgroundHistogramParseBlockedOnScriptLoadImmediate,\n        timing.parse_blocked_on_script_load_duration.value());\n    PAGE_LOAD_HISTOGRAM(\n        internal::\n            kBackgroundHistogramParseBlockedOnScriptLoadDocumentWriteImmediate,\n        timing.parse_blocked_on_script_load_from_document_write_duration\n            .value());\n  }\n}", "target": 0}
{"code": "static VariLenAffix affixForIndex(uint64_t index)\n{\n    VariLenAffix prefix;\n    prefix = expGolombEncode(index, EXP_GOLOMB_K);\n    return invertAffix(&prefix); \n}", "target": 0}
{"code": "static void rb_init_page(struct buffer_data_page *bpage)\n{\n\tlocal_set(&bpage->commit, 0);\n}", "target": 0}
{"code": "static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb)\n{\n    s->avctx->profile = get_bits(gb, 4);\n    s->avctx->level   = get_bits(gb, 4);\n    if (s->avctx->profile == 0 && s->avctx->level == 8) {\n        s->avctx->level = 0;\n    }\n    return 0;\n}", "target": 0}
{"code": "  Value_Ptr Parser::color_or_string(const std::string& lexed) const\n  {\n    if (auto color = name_to_color(lexed)) {\n      auto c = SASS_MEMORY_NEW(Color, color);\n      c->is_delayed(true);\n      c->pstate(pstate);\n      c->disp(lexed);\n      return c;\n    } else {\n      return SASS_MEMORY_NEW(String_Constant, pstate, lexed);\n    }\n  }", "target": 0}
{"code": "static unsigned long bad_file_get_unmapped_area(struct file *file,\n\t\t\t\tunsigned long addr, unsigned long len,\n\t\t\t\tunsigned long pgoff, unsigned long flags)\n{\n\treturn -EIO;\n}", "target": 0}
{"code": "void spl_object_storage_addall(spl_SplObjectStorage *intern, zval *this, spl_SplObjectStorage *other TSRMLS_DC) { \n\tHashPosition pos;\n\tspl_SplObjectStorageElement *element;\n\tzend_hash_internal_pointer_reset_ex(&other->storage, &pos);\n\twhile (zend_hash_get_current_data_ex(&other->storage, (void **)&element, &pos) == SUCCESS) {\n\t\tspl_object_storage_attach(intern, this, element->obj, element->inf TSRMLS_CC);\n\t\tzend_hash_move_forward_ex(&other->storage, &pos);\n\t}\n\tzend_hash_internal_pointer_reset_ex(&intern->storage, &intern->pos);\n\tintern->index = 0;\n} ", "target": 0}
{"code": "int LibRaw::adjust_sizes_info_only(void)\n{\n  CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY);\n  raw2image_start();\n  if (O.use_fuji_rotate)\n    {\n      if (IO.fuji_width) \n        {\n          IO.fuji_width = (IO.fuji_width - 1 + IO.shrink) >> IO.shrink;\n          S.iwidth = (ushort)(IO.fuji_width / sqrt(0.5));\n          S.iheight = (ushort)( (S.iheight - IO.fuji_width) / sqrt(0.5));\n        } \n      else \n        {\n          if (S.pixel_aspect < 0.995) S.iheight = (ushort)( S.iheight / S.pixel_aspect + 0.5);\n          if (S.pixel_aspect > 1.005) S.iwidth  = (ushort) (S.iwidth  * S.pixel_aspect + 0.5);\n        }\n    }\n  SET_PROC_FLAG(LIBRAW_PROGRESS_FUJI_ROTATE);\n  if ( S.flip & 4)\n    {\n      unsigned short t = S.iheight;\n      S.iheight=S.iwidth;\n      S.iwidth = t;\n      SET_PROC_FLAG(LIBRAW_PROGRESS_FLIP);\n    }\n  return 0;\n}", "target": 0}
{"code": "static void copy_to_page(struct page *page, unsigned long vaddr, const void *src, int len)\n{\n\tvoid *kaddr = kmap_atomic(page);\n\tmemcpy(kaddr + (vaddr & ~PAGE_MASK), src, len);\n\tkunmap_atomic(kaddr);\n}", "target": 0}
{"code": "    **/\n    CImg<T>& operator<<=(const char *const expression) {\n      return *this<<=(+*this)._fill(expression,true,true,0,0,\"operator<<=\",this);", "target": 0}
{"code": "void rfc_send_fcon(tRFC_MCB* p_mcb, bool is_command) {\n uint8_t* p_data;\n  BT_HDR* p_buf = (BT_HDR*)osi_malloc(RFCOMM_CMD_BUF_SIZE);\n  p_buf->offset = L2CAP_MIN_OFFSET + RFCOMM_CTRL_FRAME_LEN;\n  p_data = (uint8_t*)(p_buf + 1) + p_buf->offset;\n *p_data++ = RFCOMM_EA | RFCOMM_I_CR(is_command) | RFCOMM_MX_FCON;\n *p_data++ = RFCOMM_EA | (RFCOMM_MX_FCON_LEN << 1);\n  p_buf->len = RFCOMM_MX_FCON_LEN + 2;\n  rfc_send_buf_uih(p_mcb, RFCOMM_MX_DLCI, p_buf);\n}", "target": 0}
{"code": "bool HHVM_FUNCTION(array_key_exists,\n                   const Variant& key,\n                   const Variant& search) {\n  const ArrayData *ad;\n  auto const searchCell = search.asCell();\n  if (LIKELY(isArrayType(searchCell->m_type))) {\n    ad = searchCell->m_data.parr;\n  } else if (searchCell->m_type == KindOfObject) {\n    ObjectData* obj = searchCell->m_data.pobj;\n    if (obj->isCollection()) {\n      return collections::contains(obj, key);\n    }\n    return HHVM_FN(array_key_exists)(key, toArray(search));\n  } else {\n    throw_bad_type_exception(\"array_key_exists expects an array or an object; \"\n                             \"false returned.\");\n    return false;\n  }\n  auto const cell = key.asCell();\n  switch (cell->m_type) {\n    case KindOfUninit:\n    case KindOfNull:\n      return ad->useWeakKeys() && ad->exists(staticEmptyString());\n    case KindOfBoolean:\n    case KindOfDouble:\n    case KindOfPersistentArray:\n    case KindOfArray:\n    case KindOfObject:\n    case KindOfResource:\n      if (!ad->useWeakKeys()) throwInvalidArrayKeyException(cell, ad);\n      raise_warning(\"Array key should be either a string or an integer\");\n      return false;\n    case KindOfPersistentString:\n    case KindOfString: {\n      int64_t n = 0;\n      if (ad->convertKey(cell->m_data.pstr, n)) {\n        return ad->exists(n);\n      }\n      return ad->exists(StrNR(cell->m_data.pstr));\n    }\n    case KindOfInt64:\n      return ad->exists(cell->m_data.num);\n    case KindOfRef:\n    case KindOfClass:\n      break;\n  }\n  not_reached();\n}", "target": 0}
{"code": "        bool operator()(const Exiv2::Xmpdatum& xmpdatum) const\n            { return key_ == xmpdatum.key(); }", "target": 0}
{"code": "static zend_object_value zend_error_exception_new(zend_class_entry *class_type TSRMLS_DC) \n{\n\treturn zend_default_exception_new_ex(class_type, 2 TSRMLS_CC);\n}", "target": 0}
{"code": "  HandleScopeImplementer* handle_scope_implementer() {\n    ASSERT(handle_scope_implementer_);\n    return handle_scope_implementer_;\n  }", "target": 0}
{"code": "static int lua_ap_strcmp_match(lua_State *L)\n{\n    int returnValue;\n    const char     *str;\n    const char     *expected;\n    int ignoreCase = 0;\n    luaL_checktype(L, 1, LUA_TSTRING);\n    str = lua_tostring(L, 1);\n    luaL_checktype(L, 2, LUA_TSTRING);\n    expected = lua_tostring(L, 2);\n    if (lua_isboolean(L, 3))\n        ignoreCase = lua_toboolean(L, 3);\n    if (!ignoreCase)\n        returnValue = ap_strcmp_match(str, expected);\n    else\n        returnValue = ap_strcasecmp_match(str, expected);\n    lua_pushboolean(L, (!returnValue));\n    return 1;\n}", "target": 0}
{"code": "copy_opt_env(OptEnv* to, OptEnv* from)\n{\n  *to = *from;\n}", "target": 0}
{"code": "LRESULT RootWindowHostWin::OnMouseRange(UINT message,\n                                        WPARAM w_param,\n                                        LPARAM l_param) {\n  MSG msg = { hwnd(), message, w_param, l_param, 0,\n              { GET_X_LPARAM(l_param), GET_Y_LPARAM(l_param) } };\n  MouseEvent event(msg);\n  bool handled = false;\n  if (!(event.flags() & ui::EF_IS_NON_CLIENT))\n    handled = root_window_->DispatchMouseEvent(&event);\n  SetMsgHandled(handled);\n  return 0;\n}", "target": 0}
{"code": "RenderViewHostDelegateView* WebContentsImpl::GetDelegateView() {\n  return render_view_host_delegate_view_;\n}", "target": 0}
{"code": "parse_LEARN(char *arg, const struct ofpact_parse_params *pp)\n{\n    return learn_parse(arg, pp->port_map, pp->table_map, pp->ofpacts);\n}", "target": 0}
{"code": "cdf_ctime(const time_t *sec, char *buf)\n{\n\tchar *ptr = ctime_r(sec, buf);\n\tif (ptr != NULL)\n\t\treturn buf;\n\t(void)snprintf(buf, 26, \"*Bad* 0x%16.16llx\\n\", (long long)*sec);\n\treturn buf;\n}", "target": 0}
{"code": "find_field_in_view(THD *thd, TABLE_LIST *table_list,\n                   const char *name, uint length,\n                   const char *item_name, Item **ref,\n                   bool register_tree_change)\n{\n  DBUG_ENTER(\"find_field_in_view\");\n  DBUG_PRINT(\"enter\",\n             (\"view: '%s', field name: '%s', item name: '%s', ref %p\",\n              table_list->alias, name, item_name, ref));\n  Field_iterator_view field_it;\n  field_it.set(table_list);\n  Query_arena *arena= 0, backup;  \n  for (; !field_it.end_of_fields(); field_it.next())\n  {\n    if (!my_strcasecmp(system_charset_info, field_it.name(), name))\n    {\n      if (register_tree_change &&\n          thd->stmt_arena->is_stmt_prepare_or_first_stmt_execute())\n        arena= thd->activate_stmt_arena_if_needed(&backup);\n      Item *item= field_it.create_item(thd);\n      if (arena)\n        thd->restore_active_arena(arena, &backup);\n      if (!item)\n        DBUG_RETURN(0);\n      if (!ref)\n        DBUG_RETURN((Field*) view_ref_found);\n      if (*ref && !(*ref)->is_autogenerated_name)\n      {\n        if (register_tree_change)\n\t{\n          item->set_name_for_rollback(thd, (*ref)->name, \n                                      (*ref)->name_length,\n                                      system_charset_info);\n          item->real_item()->set_name_for_rollback(thd, (*ref)->name,\n                                                   (*ref)->name_length,\n                                                   system_charset_info);\n        }\n        else\n\t{\n          item->set_name(thd, (*ref)->name, (*ref)->name_length,\n                         system_charset_info);\n          item->real_item()->set_name(thd, (*ref)->name, (*ref)->name_length,\n                                      system_charset_info);\n        }\n      }\n      if (register_tree_change)\n        thd->change_item_tree(ref, item);\n      else\n        *ref= item;\n      DBUG_RETURN((Field*) view_ref_found);\n    }\n  }\n  DBUG_RETURN(0);\n}", "target": 0}
{"code": "void FrameLoader::loadedResourceFromMemoryCache(const CachedResource* resource)\n{\n    Page* page = m_frame->page();\n    if (!page)\n        return;\n#if ENABLE(INSPECTOR)\n    page->inspectorController()->didLoadResourceFromMemoryCache(m_documentLoader.get(), resource);\n#endif\n    if (!resource->sendResourceLoadCallbacks() || m_documentLoader->haveToldClientAboutLoad(resource->url()))\n        return;\n    if (!page->areMemoryCacheClientCallsEnabled()) {\n        m_documentLoader->recordMemoryCacheLoadForFutureClientNotification(resource->url());\n        m_documentLoader->didTellClientAboutLoad(resource->url());\n        return;\n    }\n    ResourceRequest request(resource->url());\n    if (m_client->dispatchDidLoadResourceFromMemoryCache(m_documentLoader.get(), request, resource->response(), resource->encodedSize())) {\n        m_documentLoader->didTellClientAboutLoad(resource->url());\n        return;\n    }\n    unsigned long identifier;\n    ResourceError error;\n    requestFromDelegate(request, identifier, error);\n    notifier()->sendRemainingDelegateMessages(m_documentLoader.get(), identifier, resource->response(), resource->encodedSize(), error);\n}", "target": 0}
{"code": "void LibRaw::getOlympus_SensorTemperature(unsigned len)\n{\n  if (OlyID != 0x0ULL)\n  {\n    short temp = get2();\n    if ((OlyID == 0x4434303430ULL) || \n        (OlyID == 0x5330303336ULL) || \n        (len != 1))\n      imgdata.makernotes.common.SensorTemperature = (float)temp;\n    else if ((temp != -32768) && (temp != 0))\n    {\n      if (temp > 199)\n        imgdata.makernotes.common.SensorTemperature = 86.474958f - 0.120228f * (float)temp;\n      else\n        imgdata.makernotes.common.SensorTemperature = (float)temp;\n    }\n  }\n  return;\n}", "target": 0}
{"code": "static zend_object_value zend_default_exception_new(zend_class_entry *class_type TSRMLS_DC) \n{\n\treturn zend_default_exception_new_ex(class_type, 0 TSRMLS_CC);\n}", "target": 0}
{"code": "static int compat_do_ebt_set_ctl(struct sock *sk,\n\t\tint cmd, void __user *user, unsigned int len)\n{\n\tint ret;\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\tswitch (cmd) {\n\tcase EBT_SO_SET_ENTRIES:\n\t\tret = compat_do_replace(sock_net(sk), user, len);\n\t\tbreak;\n\tcase EBT_SO_SET_COUNTERS:\n\t\tret = compat_update_counters(sock_net(sk), user, len);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n  }\n\treturn ret;\n}", "target": 0}
{"code": "ConnStateData::borrowPinnedConnection(HttpRequest *request, const CachePeer *aPeer)\n{\n    debugs(33, 7, pinning.serverConnection);\n    if (validatePinnedConnection(request, aPeer) != NULL)\n        stopPinnedConnectionMonitoring();\n    return pinning.serverConnection; \n}", "target": 0}
{"code": "sg_fasync(int fd, struct file *filp, int mode)\n{\n\tSg_device *sdp;\n\tSg_fd *sfp;\n\tif ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp)))\n\t\treturn -ENXIO;\n\tSCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp,\n\t\t\t\t      \"sg_fasync: mode=%d\\n\", mode));\n\treturn fasync_helper(fd, filp, mode, &sfp->async_qp);\n}", "target": 0}
{"code": "void set_disk_ro(struct gendisk *disk, int flag)\n{\n\tstruct disk_part_iter piter;\n\tstruct hd_struct *part;\n\tif (disk->part0.policy != flag) {\n\t\tset_disk_ro_uevent(disk, flag);\n\t\tdisk->part0.policy = flag;\n\t}\n\tdisk_part_iter_init(&piter, disk, DISK_PITER_INCL_EMPTY);\n\twhile ((part = disk_part_iter_next(&piter)))\n\t\tpart->policy = flag;\n\tdisk_part_iter_exit(&piter);\n}", "target": 0}
{"code": "static inline void inc_snd_pages(int order)\n{\n\tsnd_allocated_pages += 1 << order;\n}", "target": 0}
{"code": "ScriptValue ScriptController::executeScript(const String& script, bool forceUserGesture)\n{\n    UserGestureIndicator gestureIndicator(forceUserGesture ? DefinitelyProcessingNewUserGesture : PossiblyProcessingUserGesture);\n    return executeScript(ScriptSourceCode(script, m_frame->document()->url()));\n}", "target": 0}
{"code": "Method* LinkResolver::lookup_method_in_interfaces(const LinkInfo& cp_info) {\n  InstanceKlass *ik = InstanceKlass::cast(cp_info.resolved_klass());\n  return ik->lookup_method_in_all_interfaces(cp_info.name(), cp_info.signature(), Klass::DefaultsLookupMode::skip);\n}", "target": 0}
{"code": "static int8 TIFFClampDoubleToInt8( double val )\n{\n    if( val > 127 )\n        return 127;\n    if( val < -128 || val != val )\n        return -128;\n    return (int8)val;\n}", "target": 0}
{"code": "static inline int is_zero_pfn(unsigned long pfn)\n{\n\textern unsigned long zero_pfn;\n\tunsigned long offset_from_zero_pfn = pfn - zero_pfn;\n\treturn offset_from_zero_pfn <= (zero_page_mask >> PAGE_SHIFT);\n}", "target": 0}
{"code": "mysql_declare_plugin(audit_null)\n{\n  MYSQL_AUDIT_PLUGIN,         \n  &audit_null_descriptor,     \n  \"NULL_AUDIT\",               \n  \"Oracle Corp\",              \n  \"Simple NULL Audit\",        \n  PLUGIN_LICENSE_GPL,\n  audit_null_plugin_init,     \n  audit_null_plugin_deinit,   \n  0x0003,                     \n  simple_status,              \n  system_variables,           \n  NULL,\n  0,\n}", "target": 0}
{"code": "onig_get_passed_args_num_by_callout_args(OnigCalloutArgs* args)\n{\n  int num;\n  CalloutListEntry* e;\n  num = args->num;\n  e = onig_reg_callout_list_at(args->regex, num);\n  if (IS_NULL(e)) return ONIGERR_INVALID_ARGUMENT;\n  if (e->of == ONIG_CALLOUT_OF_NAME) {\n    return e->u.arg.passed_num;\n  }\n  return ONIGERR_INVALID_ARGUMENT;\n}", "target": 0}
{"code": "static u64 bpf_map_key_immediate(const struct bpf_insn_aux_data *aux)\n{\n\treturn aux->map_key_state & ~(BPF_MAP_KEY_SEEN | BPF_MAP_KEY_POISON);\n}", "target": 0}
{"code": "bool kvm_mtrr_valid(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tint i;\n\tu64 mask;\n\tif (!msr_mtrr_valid(msr))\n\t\treturn false;\n\tif (msr == MSR_IA32_CR_PAT) {\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tif (!valid_pat_type((data >> (i * 8)) & 0xff))\n\t\t\t\treturn false;\n\t\treturn true;\n\t} else if (msr == MSR_MTRRdefType) {\n\t\tif (data & ~0xcff)\n\t\t\treturn false;\n\t\treturn valid_mtrr_type(data & 0xff);\n\t} else if (msr >= MSR_MTRRfix64K_00000 && msr <= MSR_MTRRfix4K_F8000) {\n\t\tfor (i = 0; i < 8 ; i++)\n\t\t\tif (!valid_mtrr_type((data >> (i * 8)) & 0xff))\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\tWARN_ON(!(msr >= 0x200 && msr < 0x200 + 2 * KVM_NR_VAR_MTRR));\n\tmask = (~0ULL) << cpuid_maxphyaddr(vcpu);\n\tif ((msr & 1) == 0) {\n\t\tif (!valid_mtrr_type(data & 0xff))\n\t\t\treturn false;\n\t\tmask |= 0xf00;\n\t} else\n\t\tmask |= 0x7ff;\n\tif (data & mask) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 0}
{"code": "static int readfull(AVFormatContext *s, AVIOContext *pb, uint8_t *dst, int n) {\n    int ret = avio_read(pb, dst, n);\n    if (ret != n) {\n        if (ret >= 0) memset(dst + ret, 0, n - ret);\n        else          memset(dst      , 0, n);\n        av_log(s, AV_LOG_ERROR, \"Failed to fully read block\\n\");\n    }\n    return ret;\n}", "target": 0}
{"code": "void GfxIndexedColorSpace::getDeviceN(const GfxColor *color, GfxColor *deviceN) const\n{\n    GfxColor color2;\n    base->getDeviceN(mapColorToBase(color, &color2), deviceN);\n}", "target": 0}
{"code": "SYSCALL_DEFINE4(pread64, unsigned int, fd, char __user *, buf,\n\t\t\tsize_t, count, loff_t, pos)\n{\n\tstruct fd f;\n\tssize_t ret = -EBADF;\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tf = fdget(fd);\n\tif (f.file) {\n\t\tret = -ESPIPE;\n\t\tif (f.file->f_mode & FMODE_PREAD)\n\t\t\tret = vfs_read(f.file, buf, count, &pos);\n\t\tfdput(f);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "bool\nPerl__invlistEQ(pTHX_ SV* const a, SV* const b, const bool complement_b)\n{\n    const UV len_a = _invlist_len(a);\n    UV len_b = _invlist_len(b);\n    const UV* array_a = NULL;\n    const UV* array_b = NULL;\n    PERL_ARGS_ASSERT__INVLISTEQ;\n    if (len_a == 0) {\n        if (len_b == 0) {\n            return ! complement_b;\n        }\n    }\n    else {\n        array_a = invlist_array(a);\n    }\n    if (len_b != 0) {\n        array_b = invlist_array(b);\n    }\n    if (complement_b) {\n        if (len_b == 0) {\n            return (len_a == 1 && array_a[0] == 0);\n        }\n        if (array_b[0] == 0) {\n            array_b++;\n            len_b--;\n        }\n        else {\n            array_b--;\n            len_b++;\n        }\n    }\n    return    len_a == len_b\n           && memEQ(array_a, array_b, len_a * sizeof(array_a[0]));", "target": 0}
{"code": "njs_typed_array_prototype_iterator_obj(njs_vm_t *vm, njs_value_t *args,\n    njs_uint_t nargs, njs_index_t kind)\n{\n    njs_value_t        *this;\n    njs_typed_array_t  *array;\n    this = njs_argument(args, 0);\n    if (njs_slow_path(!njs_is_typed_array(this))) {\n        njs_type_error(vm, \"this is not a typed array\");\n        return NJS_ERROR;\n    }\n    array = njs_typed_array(this);\n    if (njs_slow_path(njs_is_detached_buffer(array->buffer))) {\n        njs_type_error(vm, \"detached buffer\");\n        return NJS_ERROR;\n    }\n    return njs_array_iterator_create(vm, this, &vm->retval, kind);\n}", "target": 0}
{"code": "static int cma_port_is_unique(struct rdma_bind_list *bind_list,\n\t\t\t      struct rdma_id_private *id_priv)\n{\n\tstruct rdma_id_private *cur_id;\n\tstruct sockaddr  *daddr = cma_dst_addr(id_priv);\n\tstruct sockaddr  *saddr = cma_src_addr(id_priv);\n\t__be16 dport = cma_port(daddr);\n\tlockdep_assert_held(&lock);\n\thlist_for_each_entry(cur_id, &bind_list->owners, node) {\n\t\tstruct sockaddr  *cur_daddr = cma_dst_addr(cur_id);\n\t\tstruct sockaddr  *cur_saddr = cma_src_addr(cur_id);\n\t\t__be16 cur_dport = cma_port(cur_daddr);\n\t\tif (id_priv == cur_id)\n\t\t\tcontinue;\n\t\tif (!cma_any_port(daddr) &&\n\t\t    !cma_any_port(cur_daddr) &&\n\t\t    (dport != cur_dport))\n\t\t\tcontinue;\n\t\tif (!cma_any_addr(saddr) &&\n\t\t    !cma_any_addr(cur_saddr) &&\n\t\t    cma_addr_cmp(saddr, cur_saddr))\n\t\t\tcontinue;\n\t\tif (!cma_any_addr(daddr) &&\n\t\t    !cma_any_addr(cur_daddr) &&\n\t\t    cma_addr_cmp(daddr, cur_daddr))\n\t\t\tcontinue;\n\t\treturn -EADDRNOTAVAIL;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "ref_stack_push_block(ref_stack_t *pstack, uint keep, uint add)\n{\n    const ref_stack_params_t *params = pstack->params;\n    uint count = pstack->p - pstack->bot + 1;\n    uint move = count - keep;\n    ref_stack_block *pcur = (ref_stack_block *) pstack->current.value.refs;\n    ref next;\n    ref_stack_block *pnext;\n    ref *body;\n    int code;\n    if (keep > count)\n        return_error(gs_error_Fatal);\n    if (pstack->max_stack.value.intval > 0) {\n        if (pstack->extension_used + (pstack->top - pstack->bot) + add >=\n            pstack->max_stack.value.intval ||\n            !params->allow_expansion\n            )\n            return_error(params->overflow_error);\n    }\n    code = gs_alloc_ref_array(pstack->memory, &next, 0,\n                              params->block_size, \"ref_stack_push_block\");\n    if (code < 0)\n        return code;\n    pnext = (ref_stack_block *) next.value.refs;\n    body = (ref *) (pnext + 1);\n    init_block(pstack, &next, keep);\n    body += params->bot_guard;\n    memcpy(body, pstack->bot + move, keep * sizeof(ref));\n    refset_null_new(body + keep, params->data_size - keep, 0);\n    refset_null_new(pstack->bot + move, keep, 0);\n    pnext->next = pstack->current;\n    pcur->used.value.refs = pstack->bot;\n    r_set_size(&pcur->used, move);\n    pstack->current = next;\n    pstack->bot = body;\n    pstack->top = pstack->bot + pstack->body_size - 1;\n    pstack->p = pstack->bot + keep - 1;\n    pstack->extension_size += pstack->body_size;\n    pstack->extension_used += move;\n    return 0;\n}", "target": 0}
{"code": "ex_win_close(\n    int\t\tforceit,\n    win_T\t*win,\n    tabpage_T\t*tp)\t\t\n{\n    int\t\tneed_hide;\n    buf_T\t*buf = win->w_buffer;\n    if (win == aucmd_win)\n    {\n\temsg(_(e_autocmd_close));\n\treturn;\n    }\n    need_hide = (bufIsChanged(buf) && buf->b_nwindows <= 1);\n    if (need_hide && !buf_hide(buf) && !forceit)\n    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\tif ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t{\n\t    bufref_T bufref;\n\t    set_bufref(&bufref, buf);\n\t    dialog_changed(buf, FALSE);\n\t    if (bufref_valid(&bufref) && bufIsChanged(buf))\n\t\treturn;\n\t    need_hide = FALSE;\n\t}\n\telse\n#endif\n\t{\n\t    no_write_message();\n\t    return;\n\t}\n    }\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n    if (tp == NULL)\n\twin_close(win, !need_hide && !buf_hide(buf));\n    else\n\twin_close_othertab(win, !need_hide && !buf_hide(buf), tp);\n}", "target": 0}
{"code": "static inline int socket_set_cork(int socket, int enabled)\n{\n    return -1;\n}", "target": 0}
{"code": "static void update_db_bp_intercept(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tclr_exception_intercept(svm, DB_VECTOR);\n\tclr_exception_intercept(svm, BP_VECTOR);\n\tif (svm->nmi_singlestep)\n\t\tset_exception_intercept(svm, DB_VECTOR);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_ENABLE) {\n\t\tif (vcpu->guest_debug &\n\t\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))\n\t\t\tset_exception_intercept(svm, DB_VECTOR);\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\tset_exception_intercept(svm, BP_VECTOR);\n\t} else\n\t\tvcpu->guest_debug = 0;\n}", "target": 0}
{"code": "SAPI_API void sapi_unregister_post_entry(sapi_post_entry *post_entry TSRMLS_DC)\n{\n\tif (SG(sapi_started) && EG(in_execution)) {\n\t\treturn;\n\t}\n\tzend_hash_del(&SG(known_post_content_types), post_entry->content_type,\n\t\t\tpost_entry->content_type_len+1);\n}", "target": 0}
{"code": "static inline int x86_pmu_addr_offset(int index)\n{\n\tif (boot_cpu_has(X86_FEATURE_PERFCTR_CORE))\n\t\treturn index << 1;\n\treturn index;\n}", "target": 0}
{"code": "void ConnectDialog::on_qaFavoriteAddNew_triggered() {\n\tConnectDialogEdit *cde = new ConnectDialogEdit(this);\n\tif (cde->exec() == QDialog::Accepted) {\n\t\tServerItem *si = new ServerItem(cde->qsName, cde->qsHostname, cde->usPort, cde->qsUsername, cde->qsPassword);\n\t\tqlItems << si;\n\t\tqtwServers->siFavorite->addServerItem(si);\n\t\tqtwServers->setCurrentItem(si);\n\t\tstartDns(si);\n\t}\n\tdelete cde;\n}", "target": 0}
{"code": "nofail(krb5_context context, krb5_verify_init_creds_opt *options,\n       krb5_creds *creds)\n{\n    int val;\n    if (options &&\n        (options->flags & KRB5_VERIFY_INIT_CREDS_OPT_AP_REQ_NOFAIL))\n        return (options->ap_req_nofail != 0);\n    if (krb5int_libdefault_boolean(context, &creds->client->realm,\n                                   KRB5_CONF_VERIFY_AP_REQ_NOFAIL,\n                                   &val) == 0)\n        return (val != 0);\n    return FALSE;\n}", "target": 0}
{"code": "void ewk_view_need_touch_events_set(Evas_Object* ewkView, bool needed)\n{\n    EWK_VIEW_SD_GET(ewkView, smartData);\n    EWK_VIEW_PRIV_GET(smartData, priv);\n    priv->flags.needTouchEvents = needed;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, ThreeRegexSameFieldMultikey) {\n    addIndex(BSON(\"a\" << 1), true);\n    runQuery(fromjson(\"{$and: [{a: /0/}, {a: /1/}, {a: /2/}]}\"));\n    ASSERT_EQUALS(getNumSolutions(), 4U);\n    assertSolutionExists(\"{cscan: {filter: {$and:[{a:/0/},{a:/1/},{a:/2/}]}, dir: 1}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: {$and:[{a:/0/},{a:/1/},{a:/2/}]}, node: {ixscan: \"\n        \"{pattern: {a: 1}, filter: null, \"\n        \"bounds: {a: [['', {}, true, false], [/0/, /0/, true, true]]}}}}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: {$and:[{a:/1/},{a:/0/},{a:/2/}]}, node: {ixscan: \"\n        \"{pattern: {a: 1}, filter: null, \"\n        \"bounds: {a: [['', {}, true, false], [/1/, /1/, true, true]]}}}}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: {$and:[{a:/2/},{a:/0/},{a:/1/}]}, node: {ixscan: \"\n        \"{pattern: {a: 1}, filter: null, \"\n        \"bounds: {a: [['', {}, true, false], [/2/, /2/, true, true]]}}}}}\");\n}", "target": 0}
{"code": "void ImageLoader::DispatchPendingLoadEvent(\n    std::unique_ptr<IncrementLoadEventDelayCount> count) {\n  if (!image_content_)\n    return;\n  CHECK(image_complete_);\n  if (GetElement()->GetDocument().GetFrame())\n    DispatchLoadEvent();\n  count->ClearAndCheckLoadEvent();\n}", "target": 0}
{"code": "static int xennet_connect(struct net_device *dev)\n{\n\tstruct netfront_info *np = netdev_priv(dev);\n\tunsigned int num_queues = 0;\n\tint err;\n\tunsigned int j = 0;\n\tstruct netfront_queue *queue = NULL;\n\tif (!xenbus_read_unsigned(np->xbdev->otherend, \"feature-rx-copy\", 0)) {\n\t\tdev_info(&dev->dev,\n\t\t\t \"backend does not support copying receive path\\n\");\n\t\treturn -ENODEV;\n\t}\n\terr = talk_to_netback(np->xbdev, np);\n\tif (err)\n\t\treturn err;\n\tif (np->netback_has_xdp_headroom)\n\t\tpr_info(\"backend supports XDP headroom\\n\");\n\tif (np->bounce)\n\t\tdev_info(&np->xbdev->dev,\n\t\t\t \"bouncing transmitted data to zeroed pages\\n\");\n\tnum_queues = dev->real_num_tx_queues;\n\tif (dev->reg_state == NETREG_UNINITIALIZED) {\n\t\terr = register_netdev(dev);\n\t\tif (err) {\n\t\t\tpr_warn(\"%s: register_netdev err=%d\\n\", __func__, err);\n\t\t\tdevice_unregister(&np->xbdev->dev);\n\t\t\treturn err;\n\t\t}\n\t}\n\trtnl_lock();\n\tnetdev_update_features(dev);\n\trtnl_unlock();\n\tnetif_tx_lock_bh(np->netdev);\n\tnetif_device_attach(np->netdev);\n\tnetif_tx_unlock_bh(np->netdev);\n\tnetif_carrier_on(np->netdev);\n\tfor (j = 0; j < num_queues; ++j) {\n\t\tqueue = &np->queues[j];\n\t\tnotify_remote_via_irq(queue->tx_irq);\n\t\tif (queue->tx_irq != queue->rx_irq)\n\t\t\tnotify_remote_via_irq(queue->rx_irq);\n\t\tspin_lock_irq(&queue->tx_lock);\n\t\txennet_tx_buf_gc(queue);\n\t\tspin_unlock_irq(&queue->tx_lock);\n\t\tspin_lock_bh(&queue->rx_lock);\n\t\txennet_alloc_rx_buffers(queue);\n\t\tspin_unlock_bh(&queue->rx_lock);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static inline unsigned long tid_to_event(unsigned long tid)\n{\n\treturn tid / TID_STEP;\n}", "target": 0}
{"code": "is_code_ctype(OnigCodePoint code, unsigned int ctype, OnigEncoding enc)\n{\n  if (ctype <= ONIGENC_MAX_STD_CTYPE) {\n    if (code < 128)\n      return ONIGENC_IS_ASCII_CODE_CTYPE(code, ctype);\n    else {\n      if (CTYPE_IS_WORD_GRAPH_PRINT(ctype)) {\n\treturn TRUE;\n      }\n    }\n  }\n  else {\n    PROPERTY_LIST_INIT_CHECK;\n    ctype -= (ONIGENC_MAX_STD_CTYPE + 1);\n    if (ctype >= (unsigned int )PropertyListNum)\n      return ONIGERR_TYPE_BUG;\n    return onig_is_in_code_range((UChar* )PropertyList[ctype], code);\n  }\n  return FALSE;\n}", "target": 0}
{"code": "TEST(HeaderIsValidTest, IsConnectResponse) {\n  RequestHeaderMapPtr connect_request{new TestRequestHeaderMapImpl{{\":method\", \"CONNECT\"}}};\n  RequestHeaderMapPtr get_request{new TestRequestHeaderMapImpl{{\":method\", \"GET\"}}};\n  TestResponseHeaderMapImpl success_response{{\":status\", \"200\"}};\n  TestResponseHeaderMapImpl failure_response{{\":status\", \"500\"}};\n  EXPECT_TRUE(HeaderUtility::isConnectResponse(connect_request.get(), success_response));\n  EXPECT_FALSE(HeaderUtility::isConnectResponse(connect_request.get(), failure_response));\n  EXPECT_FALSE(HeaderUtility::isConnectResponse(nullptr, success_response));\n  EXPECT_FALSE(HeaderUtility::isConnectResponse(get_request.get(), success_response));\n}", "target": 0}
{"code": "void OmniboxViewWin::OnKeyUp(TCHAR key,\n                             UINT repeat_count,\n                             UINT flags) {\n  if (key == VK_CONTROL)\n    model_->OnControlKeyChanged(false);\n  if (!(flags & KF_ALTDOWN) &&\n      (((key == VK_CONTROL) && (GetKeyState(VK_SHIFT) < 0)) ||\n       ((key == VK_SHIFT) && (GetKeyState(VK_CONTROL) < 0)))) {\n    ScopedFreeze freeze(this, GetTextObjectModel());\n    string16 saved_text(GetText());\n    CHARRANGE saved_sel;\n    GetSelection(saved_sel);\n    SetWindowText(L\"\");\n    DefWindowProc(WM_KEYUP, key, MAKELPARAM(repeat_count, flags));\n    SetWindowText(saved_text.c_str());\n    SetSelectionRange(saved_sel);\n    return;\n  }\n  SetMsgHandled(false);\n}", "target": 0}
{"code": "create_node(authz_rule_segment_t *segment,\n            apr_pool_t *result_pool)\n{\n  node_t *result = apr_pcalloc(result_pool, sizeof(*result));\n  if (segment)\n    result->segment = segment->pattern;\n  else\n    {\n      result->segment.data = \"\";\n      result->segment.len = 0;\n    }\n  result->rights.access.sequence_number = NO_SEQUENCE_NUMBER;\n  return result;\n}", "target": 0}
{"code": "sec_to_ms(VALUE s)\n{\n    if (safe_mul_p(s, SECOND_IN_MILLISECONDS))\n\treturn LONG2FIX(FIX2LONG(s) * SECOND_IN_MILLISECONDS);\n    return f_mul(s, INT2FIX(SECOND_IN_MILLISECONDS));\n}", "target": 0}
{"code": "int mbedtls_asn1_write_algorithm_identifier( unsigned char **p, unsigned char *start,\n                                     const char *oid, size_t oid_len,\n                                     size_t par_len )\n{\n    int ret;\n    size_t len = 0;\n    if( par_len == 0 )\n        MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_null( p, start ) );\n    else\n        len += par_len;\n    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_oid( p, start, oid, oid_len ) );\n    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_len( p, start, len ) );\n    MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_tag( p, start,\n                                       MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) );\n    return( (int) len );\n}", "target": 0}
{"code": "static int decode_test_stateid(struct xdr_stream *xdr,\n\t\t\t       struct nfs41_test_stateid_res *res)\n{\n\t__be32 *p;\n\tint status;\n\tint num_res;\n\tstatus = decode_op_hdr(xdr, OP_TEST_STATEID);\n\tif (status)\n\t\treturn status;\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\tnum_res = be32_to_cpup(p++);\n\tif (num_res != 1)\n\t\tgoto out;\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\tres->status = be32_to_cpup(p++);\n\treturn status;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\nout:\n\treturn -EIO;\n}", "target": 0}
{"code": "static void mark_ptr_not_null_reg(struct bpf_reg_state *reg)\n{\n\tif (base_type(reg->type) == PTR_TO_MAP_VALUE) {\n\t\tconst struct bpf_map *map = reg->map_ptr;\n\t\tif (map->inner_map_meta) {\n\t\t\treg->type = CONST_PTR_TO_MAP;\n\t\t\treg->map_ptr = map->inner_map_meta;\n\t\t\tif (map_value_has_timer(map->inner_map_meta))\n\t\t\t\treg->map_uid = reg->id;\n\t\t} else if (map->map_type == BPF_MAP_TYPE_XSKMAP) {\n\t\t\treg->type = PTR_TO_XDP_SOCK;\n\t\t} else if (map->map_type == BPF_MAP_TYPE_SOCKMAP ||\n\t\t\t   map->map_type == BPF_MAP_TYPE_SOCKHASH) {\n\t\t\treg->type = PTR_TO_SOCKET;\n\t\t} else {\n\t\t\treg->type = PTR_TO_MAP_VALUE;\n\t\t}\n\t\treturn;\n\t}\n\treg->type &= ~PTR_MAYBE_NULL;\n}", "target": 0}
{"code": "static ssize_t new_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = (void __user *)buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tiov_iter_init(&iter, WRITE, &iov, 1, len);\n\tret = filp->f_op->write_iter(&kiocb, &iter);\n\tBUG_ON(ret == -EIOCBQUEUED);\n\tif (ret > 0)\n\t\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}", "target": 0}
{"code": "SWFShape_addBitmapFillStyle(SWFShape shape, SWFBitmap bitmap, byte flags)\n{\n\tSWFFillStyle fill;\n\tif ( bitmap )\n\t{\n\t\tSWFCharacter_addDependency((SWFCharacter)shape,\n\t\t                           (SWFCharacter)bitmap);\n\t}\n\tfill = newSWFBitmapFillStyle(bitmap, flags);\n\tif(addFillStyle(shape, fill) < 0)\n\t{\n\t\tdestroySWFFillStyle(fill);\n\t\treturn NULL;\n\t}\n\treturn fill;\n}", "target": 0}
{"code": "static void discard_slab(struct kmem_cache *s, struct page *page)\n{\n\tdec_slabs_node(s, page_to_nid(page), page->objects);\n\tfree_slab(s, page);\n}", "target": 0}
{"code": "static bool get_range_limit_read_cost(const JOIN_TAB *tab, \n                                      const TABLE *table, \n                                      uint keynr, \n                                      ha_rows rows_limit,\n                                      double *read_time)\n{\n  bool res= false;\n  if (table->quick_keys.is_set(keynr))\n  {\n    double best_rows= (double)table->quick_rows[keynr];\n    double best_cost= (double)table->quick_costs[keynr];\n    if (tab)\n    {\n      key_part_map map= 1;\n      uint kp;\n      for (kp=0; kp < MAX_REF_PARTS; map=map << 1, kp++)\n      {\n        if (!(table->const_key_parts[keynr] & map))\n          break;\n      }\n      if (kp > 0)\n      {\n        ha_rows ref_rows;\n        if (kp == table->quick_key_parts[keynr])\n          ref_rows= table->quick_rows[keynr];\n        else\n          ref_rows= (ha_rows) table->key_info[keynr].actual_rec_per_key(kp-1);\n        if (ref_rows > 0)\n        {\n          double tmp= (double)ref_rows;\n          set_if_smaller(tmp, (double) tab->join->thd->variables.max_seeks_for_key);\n          if (table->covering_keys.is_set(keynr))\n            tmp= table->file->keyread_time(keynr, 1, (ha_rows) tmp);\n          else\n            tmp= table->file->read_time(keynr, 1,\n                                        (ha_rows) MY_MIN(tmp,tab->worst_seeks));\n          if (tmp < best_cost)\n          {\n            best_cost= tmp;\n            best_rows= (double)ref_rows;\n          }\n        }\n      }\n    }\n    if (best_rows > rows_limit)\n    {\n      best_cost *= rows_limit / best_rows;\n    }\n    *read_time= best_cost;\n    res= true;\n  }\n  return res;\n}", "target": 0}
{"code": "static void addColorBits(unsigned char* out, size_t index, unsigned bits, unsigned in)\n{\n  unsigned m = bits == 1 ? 7 : bits == 2 ? 3 : 1; \n  unsigned p = index & m;\n  in &= (1u << bits) - 1u; \n  in = in << (bits * (m - p));\n  if(p == 0) out[index * bits / 8] = in;\n  else out[index * bits / 8] |= in;\n}", "target": 0}
{"code": "void DelegatedFrameHost::LockResources() {\n  DCHECK(local_surface_id_.is_valid());\n  frame_evictor_->LockFrame();\n}", "target": 0}
{"code": "static int mov_read_senc(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVEncryptionInfo **encrypted_samples;\n    MOVEncryptionIndex *encryption_index;\n    MOVStreamContext *sc;\n    int use_subsamples, ret;\n    unsigned int sample_count, i, alloc_size = 0;\n    ret = get_current_encryption_info(c, &encryption_index, &sc);\n    if (ret != 1)\n        return ret;\n    if (encryption_index->nb_encrypted_samples) {\n        av_log(c->fc, AV_LOG_DEBUG, \"Ignoring duplicate encryption info in senc\\n\");\n        return 0;\n    }\n    avio_r8(pb); \n    use_subsamples = avio_rb24(pb) & 0x02; \n    sample_count = avio_rb32(pb);\n    if (sample_count >= INT_MAX / sizeof(*encrypted_samples))\n        return AVERROR(ENOMEM);\n    for (i = 0; i < sample_count; i++) {\n        unsigned int min_samples = FFMIN(FFMAX(i + 1, 1024 * 1024), sample_count);\n        encrypted_samples = av_fast_realloc(encryption_index->encrypted_samples, &alloc_size,\n                                            min_samples * sizeof(*encrypted_samples));\n        if (encrypted_samples) {\n            encryption_index->encrypted_samples = encrypted_samples;\n            ret = mov_read_sample_encryption_info(\n                c, pb, sc, &encryption_index->encrypted_samples[i], use_subsamples);\n        } else {\n            ret = AVERROR(ENOMEM);\n        }\n        if (pb->eof_reached) {\n            av_log(c->fc, AV_LOG_ERROR, \"Hit EOF while reading senc\\n\");\n            if (ret >= 0)\n                av_encryption_info_free(encryption_index->encrypted_samples[i]);\n            ret = AVERROR_INVALIDDATA;\n        }\n        if (ret < 0) {\n            for (; i > 0; i--)\n                av_encryption_info_free(encryption_index->encrypted_samples[i - 1]);\n            av_freep(&encryption_index->encrypted_samples);\n            return ret;\n        }\n    }\n    encryption_index->nb_encrypted_samples = sample_count;\n    return 0;\n}", "target": 0}
{"code": "static OPJ_OFF_T JP2SkipHandler(OPJ_OFF_T offset,void *context)\n{\n  Image\n    *image;\n  image=(Image *) context;\n  return(SeekBlob(image,offset,SEEK_CUR) < 0 ? -1 : offset);\n}", "target": 0}
{"code": "archive_read_format_zip_streamable_bid(struct archive_read *a, int best_bid)\n{\n\tconst char *p;\n\t(void)best_bid; \n\tif ((p = __archive_read_ahead(a, 4, NULL)) == NULL)\n\t\treturn (-1);\n\tif (p[0] == 'P' && p[1] == 'K') {\n\t\tif ((p[2] == '\\001' && p[3] == '\\002')\n\t\t    || (p[2] == '\\003' && p[3] == '\\004')\n\t\t    || (p[2] == '\\005' && p[3] == '\\006')\n\t\t    || (p[2] == '\\006' && p[3] == '\\006')\n\t\t    || (p[2] == '\\007' && p[3] == '\\010')\n\t\t    || (p[2] == '0' && p[3] == '0'))\n\t\t\treturn (29);\n\t}\n\treturn (0);\n}", "target": 0}
{"code": "static size_t cookie_hash_domain(const char *domain, const size_t len)\n{\n  const char *end = domain + len;\n  size_t h = 5381;\n  while(domain < end) {\n    h += h << 5;\n    h ^= Curl_raw_toupper(*domain++);\n  }\n  return (h % COOKIE_HASH_SIZE);\n}", "target": 0}
{"code": "static int kvp_write_file(FILE *f, char *s1, char *s2, char *s3)\n{\n\tint ret;\n\tret = fprintf(f, \"%s%s%s%s\\n\", s1, s2, \"=\", s3);\n\tif (ret < 0)\n\t\treturn HV_E_FAIL;\n\treturn 0;\n}", "target": 0}
{"code": "static String bundleName()\n{\n    DEFINE_STATIC_LOCAL(String, name, (ASCIILiteral(\"WebKit\")));\n#if USE(CF)\n    static bool initialized;\n    if (!initialized) {\n        initialized = true;\n        if (CFBundleRef bundle = CFBundleGetMainBundle())\n            if (CFTypeRef bundleExecutable = CFBundleGetValueForInfoDictionaryKey(bundle, kCFBundleExecutableKey))\n                if (CFGetTypeID(bundleExecutable) == CFStringGetTypeID())\n                    name = reinterpret_cast<CFStringRef>(bundleExecutable);\n    }\n#endif\n    return name;\n}", "target": 0}
{"code": "struct cred *cred_alloc_blank(void)\n{\n\tstruct cred *new;\n\tnew = kmem_cache_zalloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\tatomic_set(&new->usage, 1);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tnew->magic = CRED_MAGIC;\n#endif\n\tif (security_cred_alloc_blank(new, GFP_KERNEL) < 0)\n\t\tgoto error;\n\treturn new;\nerror:\n\tabort_creds(new);\n\treturn NULL;\n}", "target": 0}
{"code": "static int decode_opaque_inline(struct xdr_stream *xdr, unsigned int *len, char **string)\n{\n\t__be32 *p;\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\t*len = be32_to_cpup(p);\n\tp = xdr_inline_decode(xdr, *len);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\t*string = (char *)p;\n\treturn 0;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}", "target": 0}
{"code": "static int bnx2x_set_iscsi_eth_mac_addr(struct bnx2x *bp)\n{\n\tunsigned long ramrod_flags = 0;\n\t__set_bit(RAMROD_COMP_WAIT, &ramrod_flags);\n\treturn bnx2x_set_mac_one(bp, bp->cnic_eth_dev.iscsi_mac,\n\t\t\t\t &bp->iscsi_l2_mac_obj, true,\n\t\t\t\t BNX2X_ISCSI_ETH_MAC, &ramrod_flags);\n}", "target": 0}
{"code": "static void udf_open_lvid(struct super_block *sb)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct buffer_head *bh = sbi->s_lvid_bh;\n\tstruct logicalVolIntegrityDesc *lvid;\n\tstruct logicalVolIntegrityDescImpUse *lvidiu;\n\tif (!bh)\n\t\treturn;\n\tmutex_lock(&sbi->s_alloc_mutex);\n\tlvid = (struct logicalVolIntegrityDesc *)bh->b_data;\n\tlvidiu = udf_sb_lvidiu(sbi);\n\tlvidiu->impIdent.identSuffix[0] = UDF_OS_CLASS_UNIX;\n\tlvidiu->impIdent.identSuffix[1] = UDF_OS_ID_LINUX;\n\tudf_time_to_disk_stamp(&lvid->recordingDateAndTime,\n\t\t\t\tCURRENT_TIME);\n\tlvid->integrityType = cpu_to_le32(LVID_INTEGRITY_TYPE_OPEN);\n\tlvid->descTag.descCRC = cpu_to_le16(\n\t\tcrc_itu_t(0, (char *)lvid + sizeof(struct tag),\n\t\t\tle16_to_cpu(lvid->descTag.descCRCLength)));\n\tlvid->descTag.tagChecksum = udf_tag_checksum(&lvid->descTag);\n\tmark_buffer_dirty(bh);\n\tsbi->s_lvid_dirty = 0;\n\tmutex_unlock(&sbi->s_alloc_mutex);\n}", "target": 0}
{"code": "static ssize_t store_rps_dev_flow_table_cnt(struct netdev_rx_queue *queue,\n\t\t\t\t\t    const char *buf, size_t len)\n{\n\tunsigned long mask, count;\n\tstruct rps_dev_flow_table *table, *old_table;\n\tstatic DEFINE_SPINLOCK(rps_dev_flow_lock);\n\tint rc;\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\trc = kstrtoul(buf, 0, &count);\n\tif (rc < 0)\n\t\treturn rc;\n\tif (count) {\n\t\tmask = count - 1;\n\t\twhile ((mask | (mask >> 1)) != mask)\n\t\t\tmask |= (mask >> 1);\n#if BITS_PER_LONG > 32\n\t\tif (mask > (unsigned long)(u32)mask)\n\t\t\treturn -EINVAL;\n#else\n\t\tif (mask > (ULONG_MAX - RPS_DEV_FLOW_TABLE_SIZE(1))\n\t\t\t\t/ sizeof(struct rps_dev_flow)) {\n\t\t\treturn -EINVAL;\n\t\t}\n#endif\n\t\ttable = vmalloc(RPS_DEV_FLOW_TABLE_SIZE(mask + 1));\n\t\tif (!table)\n\t\t\treturn -ENOMEM;\n\t\ttable->mask = mask;\n\t\tfor (count = 0; count <= mask; count++)\n\t\t\ttable->flows[count].cpu = RPS_NO_CPU;\n\t} else {\n\t\ttable = NULL;\n\t}\n\tspin_lock(&rps_dev_flow_lock);\n\told_table = rcu_dereference_protected(queue->rps_flow_table,\n\t\t\t\t\t      lockdep_is_held(&rps_dev_flow_lock));\n\trcu_assign_pointer(queue->rps_flow_table, table);\n\tspin_unlock(&rps_dev_flow_lock);\n\tif (old_table)\n\t\tcall_rcu(&old_table->rcu, rps_dev_flow_table_release);\n\treturn len;", "target": 0}
{"code": "gx_get_largest_clipping_box(gx_device * dev, gs_fixed_rect * pbox)\n{\n    pbox->p.x = min_fixed;\n    pbox->p.y = min_fixed;\n    pbox->q.x = max_fixed;\n    pbox->q.y = max_fixed;\n}", "target": 0}
{"code": "void Document::write(LocalDOMWindow* calling_window,\n                     const Vector<String>& text,\n                     ExceptionState& exception_state) {\n  DCHECK(calling_window);\n  if (GetSecurityContext().RequireTrustedTypes()) {\n    DCHECK(RuntimeEnabledFeatures::TrustedDOMTypesEnabled());\n    exception_state.ThrowTypeError(\n        \"This document can only write `TrustedHTML` objects.\");\n    return;\n  }\n  StringBuilder builder;\n  for (const String& string : text)\n    builder.Append(string);\n  write(builder.ToString(), calling_window->document(), exception_state);\n}", "target": 0}
{"code": "void FileSystemOperation::Copy(const GURL& src_path_url,\n                               const GURL& dest_path_url,\n                               const StatusCallback& callback) {\n  DCHECK(SetPendingOperationType(kOperationCopy));\n  base::PlatformFileError result = SetUpFileSystemPath(\n      src_path_url, &src_path_, &src_util_, PATH_FOR_READ);\n  if (result == base::PLATFORM_FILE_OK)\n    result = SetUpFileSystemPath(\n        dest_path_url, &dest_path_, &dest_util_, PATH_FOR_CREATE);\n  if (result != base::PLATFORM_FILE_OK) {\n    callback.Run(result);\n    delete this;\n    return;\n  }\n  GetUsageAndQuotaThenRunTask(\n      dest_path_.origin(), dest_path_.type(),\n      base::Bind(&FileSystemOperation::DoCopy,\n                 base::Unretained(this), callback),\n      base::Bind(callback, base::PLATFORM_FILE_ERROR_FAILED));\n}", "target": 0}
{"code": "cmsToneCurve* CMSEXPORT cmsDupToneCurve(const cmsToneCurve* In)\n{\n    if (In == NULL) return NULL;\n    return  AllocateToneCurveStruct(In ->InterpParams ->ContextID, In ->nEntries, In ->nSegments, In ->Segments, In ->Table16);\n}", "target": 0}
{"code": "bool Item::eq(const Item *item, bool binary_cmp) const\n{\n  return type() == item->type() && name && item->name &&\n    !my_strcasecmp(system_charset_info,name,item->name);\n}", "target": 0}
{"code": "RGWOp* RGWHandler_REST_Obj_S3Website::get_obj_op(bool get_data)\n{\n  RGWGetObj_ObjStore_S3Website* op = new RGWGetObj_ObjStore_S3Website;\n  op->set_get_data(get_data);\n  return op;\n}", "target": 0}
{"code": "AP_DECLARE(apr_size_t) ap_get_limit_xml_body(const request_rec *r)\n{\n    core_dir_config *conf;\n    conf = ap_get_core_module_config(r->per_dir_config);\n    if (conf->limit_xml_body == AP_LIMIT_UNSET)\n        return AP_DEFAULT_LIMIT_XML_BODY;\n    return (apr_size_t)conf->limit_xml_body;\n}", "target": 0}
{"code": "pam_chauthtok_conv(int n,\n\t const struct pam_message **msg,\n\t struct pam_response **resp,\n\t void *data)\n{\n\tchar input[PAM_MAX_MSG_SIZE];\n\tint i;\n\tif (n <= 0 || n > PAM_MAX_NUM_MSG)\n\t\treturn (PAM_CONV_ERR);\n\t*resp = xmalloc(n * sizeof **resp);\n\tfor (i = 0; i < n; ++i) {\n\t\tswitch (PAM_MSG_MEMBER(msg, i, msg_style)) {\n\t\tcase PAM_PROMPT_ECHO_OFF:\n\t\t\tresp[i]->resp =\n\t\t\t    read_passphrase(PAM_MSG_MEMBER(msg, i, msg), \n\t\t\t    RP_ALLOW_STDIN);\n\t\t\tresp[i]->resp_retcode = PAM_SUCCESS;\n\t\t\tbreak;\n\t\tcase PAM_PROMPT_ECHO_ON:\n\t\t\tfputs(PAM_MSG_MEMBER(msg, i, msg), stderr);\n\t\t\tfgets(input, sizeof input, stdin);\n\t\t\tresp[i]->resp = xstrdup(input);\n\t\t\tresp[i]->resp_retcode = PAM_SUCCESS;\n\t\t\tbreak;\n\t\tcase PAM_ERROR_MSG:\n\t\tcase PAM_TEXT_INFO:\n\t\t\tfputs(PAM_MSG_MEMBER(msg, i, msg), stderr);\n\t\t\tresp[i]->resp_retcode = PAM_SUCCESS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn (PAM_SUCCESS);\n fail:\n\twhile (i)\n\t\txfree(resp[--i]);\n\txfree(*resp);\n\t*resp = NULL;\n\treturn (PAM_CONV_ERR);\n}", "target": 0}
{"code": "MagickExport void *GetImageRegistry(const RegistryType type,const char *key,\n  ExceptionInfo *exception)\n{\n  void\n    *value;\n  RegistryInfo\n    *registry_info;\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",key);\n  if (registry == (void *) NULL)\n    return((void *) NULL);\n  registry_info=(RegistryInfo *) GetValueFromSplayTree(registry,key);\n  if (registry_info == (void *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),RegistryError,\n        \"UnableToGetRegistryID\",\"`%s'\",key);\n      return((void *) NULL);\n    }\n  value=(void *) NULL;\n  switch (type)\n  {\n    case ImageRegistryType:\n    {\n      if (type == registry_info->type)\n        value=(void *) CloneImageList((Image *) registry_info->value,exception);\n      break;\n    }\n    case ImageInfoRegistryType:\n    {\n      if (type == registry_info->type)\n        value=(void *) CloneImageInfo((ImageInfo *) registry_info->value);\n      break;\n    }\n    case StringRegistryType:\n    {\n      switch (registry_info->type)\n      {\n        case ImageRegistryType:\n        {\n          value=(Image *) ConstantString(((Image *)\n            registry_info->value)->filename);\n          break;\n        }\n        case ImageInfoRegistryType:\n        {\n          value=(Image *) ConstantString(((ImageInfo *)\n            registry_info->value)->filename);\n          break;\n        }\n        case StringRegistryType:\n        {\n          value=(void *) ConstantString((char *) registry_info->value);\n          break;\n        }\n        default:\n          break;\n      }\n      break;\n    }\n    default:\n      break;\n  }\n  return(value);\n}", "target": 0}
{"code": "smb2_need_neg(struct TCP_Server_Info *server)\n{\n\treturn server->max_read == 0;\n}", "target": 0}
{"code": "__cfg80211_wdev_from_attrs(struct net *netns, struct nlattr **attrs)\n{\n\tstruct cfg80211_registered_device *rdev;\n\tstruct wireless_dev *result = NULL;\n\tbool have_ifidx = attrs[NL80211_ATTR_IFINDEX];\n\tbool have_wdev_id = attrs[NL80211_ATTR_WDEV];\n\tu64 wdev_id;\n\tint wiphy_idx = -1;\n\tint ifidx = -1;\n\tassert_cfg80211_lock();\n\tif (!have_ifidx && !have_wdev_id)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (have_ifidx)\n\t\tifidx = nla_get_u32(attrs[NL80211_ATTR_IFINDEX]);\n\tif (have_wdev_id) {\n\t\twdev_id = nla_get_u64(attrs[NL80211_ATTR_WDEV]);\n\t\twiphy_idx = wdev_id >> 32;\n\t}\n\tlist_for_each_entry(rdev, &cfg80211_rdev_list, list) {\n\t\tstruct wireless_dev *wdev;\n\t\tif (wiphy_net(&rdev->wiphy) != netns)\n\t\t\tcontinue;\n\t\tif (have_wdev_id && rdev->wiphy_idx != wiphy_idx)\n\t\t\tcontinue;\n\t\tmutex_lock(&rdev->devlist_mtx);\n\t\tlist_for_each_entry(wdev, &rdev->wdev_list, list) {\n\t\t\tif (have_ifidx && wdev->netdev &&\n\t\t\t    wdev->netdev->ifindex == ifidx) {\n\t\t\t\tresult = wdev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (have_wdev_id && wdev->identifier == (u32)wdev_id) {\n\t\t\t\tresult = wdev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&rdev->devlist_mtx);\n\t\tif (result)\n\t\t\tbreak;\n\t}\n\tif (result)\n\t\treturn result;\n\treturn ERR_PTR(-ENODEV);\n}", "target": 0}
{"code": "        virtual ~Thumbnail() {}", "target": 0}
{"code": "static int __init efi_memreserve_map_root(void)\n{\n\tif (efi.mem_reserve == EFI_INVALID_TABLE_ADDR)\n\t\treturn -ENODEV;\n\tefi_memreserve_root = memremap(efi.mem_reserve,\n\t\t\t\t       sizeof(*efi_memreserve_root),\n\t\t\t\t       MEMREMAP_WB);\n\tif (WARN_ON_ONCE(!efi_memreserve_root))\n\t\treturn -ENOMEM;\n\treturn 0;\n}", "target": 0}
{"code": "static int _make_remark(struct pwb_context *ctx,\n\t\t\tint type,\n\t\t\tconst char *text)\n{\n\tint retval = PAM_SUCCESS;\n\tstruct pam_message *pmsg[1], msg[1];\n\tstruct pam_response *resp;\n\tif (ctx->flags & WINBIND_SILENT) {\n\t\treturn PAM_SUCCESS;\n\t}\n\tpmsg[0] = &msg[0];\n\tmsg[0].msg = discard_const_p(char, text);\n\tmsg[0].msg_style = type;\n\tresp = NULL;\n\tretval = converse(ctx->pamh, 1, pmsg, &resp);\n\tif (resp) {\n\t\t_pam_drop_reply(resp, 1);\n\t}\n\treturn retval;\n}", "target": 0}
{"code": "void BrowserTitlebar::UpdateTextColor() {\n  if (app_mode_title_) {\n    if (theme_provider_ && theme_provider_->UseGtkTheme()) {\n      GdkColor frame_color;\n      if (window_has_focus_) {\n        frame_color = theme_provider_->GetGdkColor(\n          BrowserThemeProvider::COLOR_FRAME);\n      } else {\n        frame_color = theme_provider_->GetGdkColor(\n          BrowserThemeProvider::COLOR_FRAME_INACTIVE);\n      }\n      GdkColor text_color = PickLuminosityContrastingColor(\n          &frame_color, &gfx::kGdkWhite, &gfx::kGdkBlack);\n      gtk_util::SetLabelColor(app_mode_title_, &text_color);\n    } else {\n      gtk_util::SetLabelColor(app_mode_title_, &gfx::kGdkWhite);\n    }\n  }\n}", "target": 0}
{"code": "cql_server::connection::make_topology_change_event(const event::topology_change& event) const\n{\n    auto response = std::make_unique<cql_server::response>(-1, cql_binary_opcode::EVENT, tracing::trace_state_ptr());\n    response->write_string(\"TOPOLOGY_CHANGE\");\n    response->write_string(to_string(event.change));\n    response->write_inet(event.node);\n    return response;\n}", "target": 0}
{"code": "EXPORTED void transaction_free(struct transaction_t *txn)\n{\n    transaction_reset(txn);\n    ws_end_channel(txn->ws_ctx);\n    http2_end_stream(txn->strm_ctx);\n    zlib_done(txn->zstrm);\n    zstd_done(txn->zstd);\n    brotli_done(txn->brotli);\n    buf_free(&txn->req_body.payload);\n    buf_free(&txn->resp_body.payload);\n    buf_free(&txn->zbuf);\n    buf_free(&txn->buf);\n}", "target": 0}
{"code": "void dtls1_start_timer(SSL *s)\n{\n#ifndef OPENSSL_NO_SCTP\n    if (BIO_dgram_is_sctp(SSL_get_wbio(s))) {\n        memset(&(s->d1->next_timeout), 0, sizeof(struct timeval));\n        return;\n    }\n#endif\n    if (s->d1->next_timeout.tv_sec == 0 && s->d1->next_timeout.tv_usec == 0) {\n        s->d1->timeout_duration = 1;\n    }\n    get_current_time(&(s->d1->next_timeout));\n    s->d1->next_timeout.tv_sec += s->d1->timeout_duration;\n    BIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT, 0,\n             &(s->d1->next_timeout));\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::Init() {\n  DCHECK(process_->HasConnection());\n  renderer_initialized_ = true;\n  if (view_) {\n    Send(new ViewMsg_SetSurfaceIdNamespace(routing_id_,\n                                           view_->GetSurfaceIdNamespace()));\n  }\n  SendScreenRects();\n  WasResized();\n  if (owner_delegate_)\n    owner_delegate_->RenderWidgetDidInit();\n}", "target": 0}
{"code": "static ssize_t red_zone_show(struct kmem_cache *s, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", !!(s->flags & SLAB_RED_ZONE));\n}", "target": 0}
{"code": "void QuotaManagerProxy::NotifyStorageAccessed(\n    QuotaClient::ID client_id,\n    const GURL& origin,\n    StorageType type) {\n  if (!io_thread_->BelongsToCurrentThread()) {\n    io_thread_->PostTask(FROM_HERE, NewRunnableMethod(\n        this, &QuotaManagerProxy::NotifyStorageAccessed,\n        client_id, origin, type));\n    return;\n  }\n  if (manager_)\n    manager_->NotifyStorageAccessed(client_id, origin, type);\n}", "target": 0}
{"code": "static int vnc_refresh_lossy_rect(VncDisplay *vd, int x, int y)\n{\n    VncState *vs;\n    int sty = y / VNC_STAT_RECT;\n    int stx = x / VNC_STAT_RECT;\n    int has_dirty = 0;\n    y = QEMU_ALIGN_DOWN(y, VNC_STAT_RECT);\n    x = QEMU_ALIGN_DOWN(x, VNC_STAT_RECT);\n    QTAILQ_FOREACH(vs, &vd->clients, next) {\n        int j;\n        if (vs->output.offset) {\n            continue;\n        }\n        if (!vs->lossy_rect[sty][stx]) {\n            continue;\n        }\n        vs->lossy_rect[sty][stx] = 0;\n        for (j = 0; j < VNC_STAT_RECT; ++j) {\n            bitmap_set(vs->dirty[y + j],\n                       x / VNC_DIRTY_PIXELS_PER_BIT,\n                       VNC_STAT_RECT / VNC_DIRTY_PIXELS_PER_BIT);\n        }\n        has_dirty++;\n    }\n    return has_dirty;\n}", "target": 0}
{"code": "void PDFiumEngine::GetAllScreenRectsUnion(std::vector<PDFiumRange>* rect_range,\n                                          const pp::Point& offset_point,\n                                          std::vector<pp::Rect>* rect_vector) {\n  for (auto& range : *rect_range) {\n    pp::Rect result_rect;\n    std::vector<pp::Rect> rects =\n        range.GetScreenRects(offset_point, current_zoom_, current_rotation_);\n    for (const auto& rect : rects)\n      result_rect = result_rect.Union(rect);\n    rect_vector->push_back(result_rect);\n  }\n}", "target": 0}
{"code": "    template<typename t>\n    CImg<T>& operator%=(const t value) {\n      if (is_empty()) return *this;\n      cimg_pragma_openmp(parallel for cimg_openmp_if(size()>=16384))\n      cimg_rof(*this,ptrd,T) *ptrd = (T)cimg::mod(*ptrd,(T)value);\n      return *this;", "target": 0}
{"code": "ExecutionContext* SpeechSynthesis::executionContext() const\n{\n    return ContextLifecycleObserver::executionContext();\n}", "target": 0}
{"code": "mysql_stmt_result_metadata(MYSQL_STMT *stmt)\n{\n  MYSQL_RES *result;\n  DBUG_ENTER(\"mysql_stmt_result_metadata\");\n  if (!stmt->field_count)\n     DBUG_RETURN(0);\n  if (!(result=(MYSQL_RES*) my_malloc(sizeof(*result),\n                                      MYF(MY_WME | MY_ZEROFILL))))\n  {\n    set_stmt_error(stmt, CR_OUT_OF_MEMORY, unknown_sqlstate, NULL);\n    DBUG_RETURN(0);\n  }\n  result->methods=\tstmt->mysql->methods;\n  result->eof=\t\t1;                      \n  result->fields=\tstmt->fields;\n  result->field_count=\tstmt->field_count;\n  DBUG_RETURN(result);\n}", "target": 0}
{"code": "static int adjust_subprog_starts_after_remove(struct bpf_verifier_env *env,\n\t\t\t\t\t      u32 off, u32 cnt)\n{\n\tint i, j;\n\tfor (i = 0; i < env->subprog_cnt; i++)\n\t\tif (env->subprog_info[i].start >= off)\n\t\t\tbreak;\n\tfor (j = i; j < env->subprog_cnt; j++)\n\t\tif (env->subprog_info[j].start >= off + cnt)\n\t\t\tbreak;\n\tif (env->subprog_info[j].start != off + cnt)\n\t\tj--;\n\tif (j > i) {\n\t\tstruct bpf_prog_aux *aux = env->prog->aux;\n\t\tint move;\n\t\tmove = env->subprog_cnt + 1 - j;\n\t\tmemmove(env->subprog_info + i,\n\t\t\tenv->subprog_info + j,\n\t\t\tsizeof(*env->subprog_info) * move);\n\t\tenv->subprog_cnt -= j - i;\n\t\tif (aux->func_info) {\n\t\t\tmove = aux->func_info_cnt - j;\n\t\t\tmemmove(aux->func_info + i,\n\t\t\t\taux->func_info + j,\n\t\t\t\tsizeof(*aux->func_info) * move);\n\t\t\taux->func_info_cnt -= j - i;\n\t\t}\n\t} else {\n\t\tif (env->subprog_info[i].start == off)\n\t\t\ti++;\n\t}\n\tfor (; i <= env->subprog_cnt; i++)\n\t\tenv->subprog_info[i].start -= cnt;\n\treturn 0;\n}", "target": 0}
{"code": "gfx::NativeViewAccessible RenderWidgetHostViewAura::GetNativeViewAccessible() {\n#if defined(OS_WIN)\n  aura::WindowEventDispatcher* dispatcher = window_->GetDispatcher();\n  if (!dispatcher)\n    return static_cast<gfx::NativeViewAccessible>(NULL);\n  HWND hwnd = dispatcher->host()->GetAcceleratedWidget();\n  CreateBrowserAccessibilityManagerIfNeeded();\n  BrowserAccessibilityManager* manager = GetBrowserAccessibilityManager();\n  if (manager)\n    return manager->GetRoot()->ToBrowserAccessibilityWin();\n#endif\n  NOTIMPLEMENTED();\n  return static_cast<gfx::NativeViewAccessible>(NULL);\n}", "target": 0}
{"code": "TypedValue HHVM_FUNCTION(array_diff_assoc,\n                         const Variant& array1,\n                         const Variant& array2,\n                         const Array& args ) {\n  diff_intersect_body(diff, args, true COMMA true);\n}", "target": 0}
{"code": "int sc_append_file_id(sc_path_t *dest, unsigned int fid)\n{\n\tu8 id[2] = { fid >> 8, fid & 0xff };\n\treturn sc_append_path_id(dest, id, 2);\n}", "target": 0}
{"code": "static av_cold int decode_init(AVCodecContext *avctx)\n{\n    VmncContext * const c = avctx->priv_data;\n    c->avctx  = avctx;\n    c->width  = avctx->width;\n    c->height = avctx->height;\n    c->bpp    = avctx->bits_per_coded_sample;\n    c->bpp2   = c->bpp / 8;\n    switch (c->bpp) {\n    case 8:\n        avctx->pix_fmt = AV_PIX_FMT_PAL8;\n        break;\n    case 16:\n        avctx->pix_fmt = AV_PIX_FMT_RGB555;\n        break;\n    case 32:\n        avctx->pix_fmt = AV_PIX_FMT_RGB32;\n        break;\n    default:\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported bitdepth %i\\n\", c->bpp);\n        return AVERROR_INVALIDDATA;\n    }\n    c->pic = av_frame_alloc();\n    if (!c->pic)\n        return AVERROR(ENOMEM);\n    return 0;\n}", "target": 0}
{"code": "NPObject* ScriptController::windowScriptNPObject()\n{\n    if (m_windowScriptNPObject)\n        return m_windowScriptNPObject;\n    if (canExecuteScripts(NotAboutToExecuteScript)) {\n        m_windowScriptNPObject = createScriptObject(m_frame);\n        _NPN_RegisterObject(m_windowScriptNPObject, 0);\n    } else {\n        m_windowScriptNPObject = createNoScriptObject();\n    }\n    return m_windowScriptNPObject;\n}", "target": 0}
{"code": "static void mce_unmap_kpfn(unsigned long pfn)\n{\n\tunsigned long decoy_addr;\n#if PGDIR_SHIFT + 9 < 63\n\tdecoy_addr = (pfn << PAGE_SHIFT) + (PAGE_OFFSET ^ BIT(63));\n#else\n#error \"no unused virtual bit available\"\n#endif\n\tif (set_memory_np(decoy_addr, 1))\n\t\tpr_warn(\"Could not invalidate pfn=0x%lx from 1:1 map\\n\", pfn);\n}", "target": 0}
{"code": "node_new_call(UChar* name, UChar* name_end, int gnum, int by_number)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n  NODE_SET_TYPE(node, NODE_CALL);\n  CALL_(node)->by_number   = by_number;\n  CALL_(node)->name        = name;\n  CALL_(node)->name_end    = name_end;\n  CALL_(node)->group_num   = gnum;\n  CALL_(node)->entry_count = 1;\n  return node;\n}", "target": 0}
{"code": "accountingOnAbort(XML_Parser originParser) {\n  accountingReportStats(originParser, \" ABORTING\\n\");\n}", "target": 0}
{"code": "SSLNetVConnection::clear()\n{\n  if (ssl != nullptr) {\n    SSL_free(ssl);\n    ssl = nullptr;\n  }\n  sslHandShakeComplete        = false;\n  sslHandshakeBeginTime       = 0;\n  sslLastWriteTime            = 0;\n  sslTotalBytesSent           = 0;\n  sslClientRenegotiationAbort = false;\n  sslSessionCacheHit          = false;\n  curHook              = nullptr;\n  hookOpRequested      = SSL_HOOK_OP_DEFAULT;\n  npnSet               = nullptr;\n  npnEndpoint          = nullptr;\n  sslHandShakeComplete = false;\n  free_handshake_buffers();\n  sslTrace = false;\n  super::clear();\n}", "target": 0}
{"code": "vte_sequence_handler_set_mode_internal(VteTerminal *terminal,\n\t\t\t\t       long setting, gboolean value)\n{\n\tswitch (setting) {\n\tcase 2:\t\t\n\t\tbreak;\n\tcase 4:\t\t\n\t\tterminal->pvt->screen->insert_mode = value;\n\t\tbreak;\n\tcase 12:\t\n\t\tterminal->pvt->screen->sendrecv_mode = value;\n\t\tbreak;\n\tcase 20:\t\n\t\tterminal->pvt->screen->linefeed_mode = value;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "DEFINE_TEST(test_read_format_zip_ppmd_multi)\n{\n\tconst char *refname = \"test_read_format_zip_ppmd8_multi.zipx\";\n\tstruct archive *a;\n\tstruct archive_entry *ae;\n\textract_reference_file(refname);\n\tassert((a = archive_read_new()) != NULL);\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_zip(a));\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_open_filename(a, refname, 37));\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));\n\tassertEqualString(\"ZIP 6.3 (ppmd-1)\", archive_format_name(a));\n\tassertEqualString(\"smartd.conf\", archive_entry_pathname(ae));\n\tassertEqualIntA(a, 0, extract_one(a, ae, 0x8DD7379E));\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));\n\tassertEqualString(\"ZIP 6.3 (ppmd-1)\", archive_format_name(a));\n\tassertEqualString(\"ts.conf\", archive_entry_pathname(ae));\n\tassertEqualIntA(a, 0, extract_one(a, ae, 0x7AE59B31));\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));\n\tassertEqualString(\"ZIP 6.3 (ppmd-1)\", archive_format_name(a));\n\tassertEqualString(\"vimrc\", archive_entry_pathname(ae));\n\tassertEqualIntA(a, 0, extract_one(a, ae, 0xBA8E3BAA));\n\tassertEqualIntA(a, ARCHIVE_EOF, archive_read_next_header(a, &ae));\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_close(a));\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_free(a));\n}", "target": 0}
{"code": "static int mov_parse_uuid_spherical(MOVStreamContext *sc, AVIOContext *pb, size_t len)\n{\n    int ret = 0;\n    uint8_t *buffer = av_malloc(len + 1);\n    const char *val;\n    if (!buffer)\n        return AVERROR(ENOMEM);\n    buffer[len] = '\\0';\n    ret = ffio_read_size(pb, buffer, len);\n    if (ret < 0)\n        goto out;\n    if (!sc->spherical &&\n        av_stristr(buffer, \"<GSpherical:StitchingSoftware>\") &&\n        (val = av_stristr(buffer, \"<GSpherical:Spherical>\")) &&\n        av_stristr(val, \"true\") &&\n        (val = av_stristr(buffer, \"<GSpherical:Stitched>\")) &&\n        av_stristr(val, \"true\") &&\n        (val = av_stristr(buffer, \"<GSpherical:ProjectionType>\")) &&\n        av_stristr(val, \"equirectangular\")) {\n        sc->spherical = av_spherical_alloc(&sc->spherical_size);\n        if (!sc->spherical)\n            goto out;\n        sc->spherical->projection = AV_SPHERICAL_EQUIRECTANGULAR;\n        if (av_stristr(buffer, \"<GSpherical:StereoMode>\") && !sc->stereo3d) {\n            enum AVStereo3DType mode;\n            if (av_stristr(buffer, \"left-right\"))\n                mode = AV_STEREO3D_SIDEBYSIDE;\n            else if (av_stristr(buffer, \"top-bottom\"))\n                mode = AV_STEREO3D_TOPBOTTOM;\n            else\n                mode = AV_STEREO3D_2D;\n            sc->stereo3d = av_stereo3d_alloc();\n            if (!sc->stereo3d)\n                goto out;\n            sc->stereo3d->type = mode;\n        }\n        val = av_stristr(buffer, \"<GSpherical:InitialViewHeadingDegrees>\");\n        if (val)\n            sc->spherical->yaw = strtol(val, NULL, 10) * (1 << 16);\n        val = av_stristr(buffer, \"<GSpherical:InitialViewPitchDegrees>\");\n        if (val)\n            sc->spherical->pitch = strtol(val, NULL, 10) * (1 << 16);\n        val = av_stristr(buffer, \"<GSpherical:InitialViewRollDegrees>\");\n        if (val)\n            sc->spherical->roll = strtol(val, NULL, 10) * (1 << 16);\n    }\nout:\n    av_free(buffer);\n    return ret;\n}", "target": 0}
{"code": "xfs_inactive(\n\txfs_inode_t\t*ip)\n{\n\tstruct xfs_mount\t*mp;\n\tint\t\t\terror;\n\tint\t\t\ttruncate = 0;\n\tif (VFS_I(ip)->i_mode == 0) {\n\t\tASSERT(ip->i_df.if_broot_bytes == 0);\n\t\treturn;\n\t}\n\tmp = ip->i_mount;\n\tASSERT(!xfs_iflags_test(ip, XFS_IRECOVERY));\n\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\treturn;\n\tif (xfs_inode_has_cow_data(ip))\n\t\txfs_reflink_cancel_cow_range(ip, 0, NULLFILEOFF, true);\n\tif (VFS_I(ip)->i_nlink != 0) {\n\t\tif (xfs_can_free_eofblocks(ip, true))\n\t\t\txfs_free_eofblocks(ip);\n\t\treturn;\n\t}\n\tif (S_ISREG(VFS_I(ip)->i_mode) &&\n\t    (ip->i_d.di_size != 0 || XFS_ISIZE(ip) != 0 ||\n\t     ip->i_df.if_nextents > 0 || ip->i_delayed_blks > 0))\n\t\ttruncate = 1;\n\terror = xfs_qm_dqattach(ip);\n\tif (error)\n\t\treturn;\n\tif (S_ISLNK(VFS_I(ip)->i_mode))\n\t\terror = xfs_inactive_symlink(ip);\n\telse if (truncate)\n\t\terror = xfs_inactive_truncate(ip);\n\tif (error)\n\t\treturn;\n\tif (XFS_IFORK_Q(ip)) {\n\t\terror = xfs_attr_inactive(ip);\n\t\tif (error)\n\t\t\treturn;\n\t}\n\tASSERT(!ip->i_afp);\n\tASSERT(ip->i_d.di_forkoff == 0);\n\terror = xfs_inactive_ifree(ip);\n\tif (error)\n\t\treturn;\n\txfs_qm_dqdetach(ip);\n}", "target": 0}
{"code": "void __paginginit set_pageblock_order(void)\n{\n}", "target": 0}
{"code": "static void __slab_free(struct kmem_cache *s, struct page *page,\n\t\t\t\tvoid *x, void *addr, unsigned int offset)\n{\n\tvoid *prior;\n\tvoid **object = (void *)x;\n\tstruct kmem_cache_cpu *c;\n\tc = get_cpu_slab(s, raw_smp_processor_id());\n\tstat(c, FREE_SLOWPATH);\n\tslab_lock(page);\n\tif (unlikely(SlabDebug(page)))\n\t\tgoto debug;\nchecks_ok:\n\tprior = object[offset] = page->freelist;\n\tpage->freelist = object;\n\tpage->inuse--;\n\tif (unlikely(SlabFrozen(page))) {\n\t\tstat(c, FREE_FROZEN);\n\t\tgoto out_unlock;\n\t}\n\tif (unlikely(!page->inuse))\n\t\tgoto slab_empty;\n\tif (unlikely(!prior)) {\n\t\tadd_partial(get_node(s, page_to_nid(page)), page, 1);\n\t\tstat(c, FREE_ADD_PARTIAL);\n\t}\nout_unlock:\n\tslab_unlock(page);\n\treturn;\nslab_empty:\n\tif (prior) {\n\t\tremove_partial(s, page);\n\t\tstat(c, FREE_REMOVE_PARTIAL);\n\t}\n\tslab_unlock(page);\n\tstat(c, FREE_SLAB);\n\tdiscard_slab(s, page);\n\treturn;\ndebug:\n\tif (!free_debug_processing(s, page, x, addr))\n\t\tgoto out_unlock;\n\tgoto checks_ok;\n}", "target": 0}
{"code": "xfs_ifree_cluster(\n\tstruct xfs_inode\t*free_ip,\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_icluster\t*xic)\n{\n\tstruct xfs_mount\t*mp = free_ip->i_mount;\n\tstruct xfs_ino_geometry\t*igeo = M_IGEO(mp);\n\tstruct xfs_buf\t\t*bp;\n\txfs_daddr_t\t\tblkno;\n\txfs_ino_t\t\tinum = xic->first_ino;\n\tint\t\t\tnbufs;\n\tint\t\t\ti, j;\n\tint\t\t\tioffset;\n\tint\t\t\terror;\n\tnbufs = igeo->ialloc_blks / igeo->blocks_per_cluster;\n\tfor (j = 0; j < nbufs; j++, inum += igeo->inodes_per_cluster) {\n\t\tioffset = inum - xic->first_ino;\n\t\tif ((xic->alloc & XFS_INOBT_MASK(ioffset)) == 0) {\n\t\t\tASSERT(ioffset % igeo->inodes_per_cluster == 0);\n\t\t\tcontinue;\n\t\t}\n\t\tblkno = XFS_AGB_TO_DADDR(mp, XFS_INO_TO_AGNO(mp, inum),\n\t\t\t\t\t XFS_INO_TO_AGBNO(mp, inum));\n\t\terror = xfs_trans_get_buf(tp, mp->m_ddev_targp, blkno,\n\t\t\t\tmp->m_bsize * igeo->blocks_per_cluster,\n\t\t\t\tXBF_UNMAPPED, &bp);\n\t\tif (error)\n\t\t\treturn error;\n\t\tbp->b_ops = &xfs_inode_buf_ops;\n\t\tfor (i = 0; i < igeo->inodes_per_cluster; i++)\n\t\t\txfs_ifree_mark_inode_stale(bp, free_ip, inum + i);\n\t\txfs_trans_stale_inode_buf(tp, bp);\n\t\txfs_trans_binval(tp, bp);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "uint32_t address_space_lduw_le(AddressSpace *as, hwaddr addr,\n                           MemTxAttrs attrs, MemTxResult *result)\n{\n    return address_space_lduw_internal(as, addr, attrs, result,\n                                       DEVICE_LITTLE_ENDIAN);\n}", "target": 0}
{"code": "rdpsnd_process_ping(STREAM in)\n{\n\tuint16 tick;\n\tSTREAM out;\n\tstruct stream packet = *in;\n\tif (!s_check_rem(in, 4))\n\t{\n\t\trdp_protocol_error(\"rdpsnd_process_training(), consume of training data from stream would overrun\", &packet);\n\t}\n\tin_uint16_le(in, tick);\n\tDEBUG_SOUND((\"RDPSND: RDPSND_PING(tick: 0x%04x)\\n\", (unsigned) tick));\n\tout = rdpsnd_init_packet(RDPSND_PING | 0x2300, 4);\n\tout_uint16_le(out, tick);\n\tout_uint16_le(out, 0);\n\ts_mark_end(out);\n\trdpsnd_send(out);\n\tDEBUG_SOUND((\"RDPSND: -> (tick: 0x%04x)\\n\", (unsigned) tick));\n}", "target": 0}
{"code": " void ip6_frag_init(struct inet_frag_queue *q, void *a)\n {\n \tstruct frag_queue *fq = container_of(q, struct frag_queue, q);\n\tstruct ip6_create_arg *arg = a;\n\tfq->id = arg->id;\n\tfq->user = arg->user;\n\tipv6_addr_copy(&fq->saddr, arg->src);\n\tipv6_addr_copy(&fq->daddr, arg->dst);\n}", "target": 0}
{"code": "smp_fetch_url_param(struct proxy *px, struct session *l4, void *l7, unsigned int opt,\n                    const struct arg *args, struct sample *smp)\n{\n\tchar delim = '?';\n\tstruct http_txn *txn = l7;\n\tstruct http_msg *msg = &txn->req;\n\tif (!args || args[0].type != ARGT_STR ||\n\t    (args[1].type && args[1].type != ARGT_STR))\n\t\treturn 0;\n\tCHECK_HTTP_MESSAGE_FIRST();\n\tif (args[1].type)\n\t\tdelim = *args[1].data.str.str;\n\tif (!find_url_param_value(msg->chn->buf->p + msg->sl.rq.u, msg->sl.rq.u_l,\n                                 args->data.str.str, args->data.str.len,\n                                 &smp->data.str.str, &smp->data.str.len,\n                                 delim))\n\t\treturn 0;\n\tsmp->type = SMP_T_CSTR;\n\tsmp->flags = SMP_F_VOL_1ST;\n\treturn 1;\n}", "target": 0}
{"code": "libxlDomainShutdownHandleRestart(libxlDriverPrivate *driver,\n                                 virDomainObj *vm)\n{\n    libxlDomainDestroyInternal(driver, vm);\n    libxlDomainCleanup(driver, vm);\n    if (libxlDomainStartNew(driver, vm, false) < 0) {\n        VIR_ERROR(_(\"Failed to restart VM '%s': %s\"),\n                  vm->def->name, virGetLastErrorMessage());\n    }\n}", "target": 0}
{"code": "static int key_notify_sa_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\tskb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\thdr = skb_put(skb, sizeof(struct sadb_msg));\n\thdr->sadb_msg_satype = pfkey_proto2satype(c->data.proto);\n\thdr->sadb_msg_type = SADB_FLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\thdr->sadb_msg_reserved = 0;\n\tpfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\treturn 0;\n}", "target": 0}
{"code": "coolkey_get_access(sc_card_t *card, sc_cardctl_coolkey_object_t *obj, unsigned int *access_ptr)\n{\n\treturn coolkey_set_bool_flags(card, obj, access_ptr, access_table, access_table_size);\n}", "target": 0}
{"code": "SPL_METHOD(DirectoryIterator, next)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tint skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS);\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tintern->u.dir.index++;\n\tdo {\n\t\tspl_filesystem_dir_read(intern TSRMLS_CC);\n\t} while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));\n\tif (intern->file_name) {\n\t\tefree(intern->file_name);\n\t\tintern->file_name = NULL;\n\t}\n}", "target": 0}
{"code": "code_to_mbclen(OnigCodePoint code, OnigEncoding enc ARG_UNUSED)\n{\n  if (ONIGENC_IS_CODE_ASCII(code)) return 1;\n  else if (code > 0xffffffff) return 0;\n  else if ((code & 0xff000000) >= 0x80000000) return 4;\n  else if ((code &   0xff0000) >= 0x800000) return 3;\n  else if ((code &     0xff00) >= 0x8000) return 2;\n  else\n    return ONIGERR_INVALID_CODE_POINT_VALUE;\n}", "target": 0}
{"code": "static void cmdproc_thread_cleanup(void *arg)\n{\n\tstruct tcmu_device *dev = arg;\n\tstruct tcmur_handler *rhandler = tcmu_get_runner_handler(dev);\n\trhandler->close(dev);\n}", "target": 0}
{"code": "static void sprint_byte_with_x(char* s, unsigned int v)\n{\n  xsnprintf(s, 5, \"\\\\x%02x\", (v & 0377));\n}", "target": 0}
{"code": "ram_addr_t qemu_ram_alloc(ram_addr_t size, MemoryRegion *mr, Error **errp)\n{\n    return qemu_ram_alloc_internal(size, size, NULL, NULL, false, mr, errp);\n}", "target": 0}
{"code": "irc_server_set_lag (struct t_irc_server *server)\n{\n    char str_lag[32];\n    if (server->lag >= weechat_config_integer (irc_config_network_lag_min_show))\n    {\n        snprintf (str_lag, sizeof (str_lag),\n                  ((server->lag_check_time.tv_sec == 0) || (server->lag < 1000)) ?\n                  \"%.3f\" : \"%.0f\",\n                  ((float)(server->lag)) / 1000);\n        weechat_buffer_set (server->buffer, \"localvar_set_lag\", str_lag);\n    }\n    else\n    {\n        weechat_buffer_set (server->buffer, \"localvar_del_lag\", \"\");\n    }\n    weechat_hook_signal_send (\"irc_server_lag_changed\",\n                              WEECHAT_HOOK_SIGNAL_STRING,\n                              server->name);\n    weechat_bar_item_update (\"lag\");\n}", "target": 0}
{"code": "zsetpagedevice(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    int code;\n    if (r_has_type(op, t_dictionary)) {\n        check_dict_read(*op);\n#if 0\t\n        if (!(r_is_local(op)))\n            return_error(gs_error_invalidaccess);\n#endif\t\n        code = zreadonly(i_ctx_p);\n        if (code < 0)\n            return code;\n    } else {\n        check_type(*op, t_null);\n    }\n    istate->pagedevice = *op;\n    pop(1);\n    return 0;\n}", "target": 0}
{"code": "static void php_xml_parser_create_impl(INTERNAL_FUNCTION_PARAMETERS, int ns_support) \n{\n\txml_parser *parser;\n\tint auto_detect = 0;\n\tchar *encoding_param = NULL;\n\tint encoding_param_len = 0;\n\tchar *ns_param = NULL;\n\tint ns_param_len = 0;\n\tXML_Char *encoding;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, (ns_support ? \"|ss\": \"|s\"), &encoding_param, &encoding_param_len, &ns_param, &ns_param_len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tif (encoding_param != NULL) {\n\t\tif (encoding_param_len == 0) {\n\t\t\tencoding = XML(default_encoding);\n\t\t\tauto_detect = 1;\n\t\t} else if (strcasecmp(encoding_param, \"ISO-8859-1\") == 0) {\n\t\t\tencoding = \"ISO-8859-1\";\n\t\t} else if (strcasecmp(encoding_param, \"UTF-8\") == 0) {\n\t\t\tencoding = \"UTF-8\";\n\t\t} else if (strcasecmp(encoding_param, \"US-ASCII\") == 0) {\n\t\t\tencoding = \"US-ASCII\";\n\t\t} else {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"unsupported source encoding \\\"%s\\\"\", encoding_param);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tencoding = XML(default_encoding);\n\t}\n\tif (ns_support && ns_param == NULL){\n\t\tns_param = \":\";\n\t}\n\tparser = ecalloc(1, sizeof(xml_parser));\n\tparser->parser = XML_ParserCreate_MM((auto_detect ? NULL : encoding),\n                                         &php_xml_mem_hdlrs, ns_param);\n\tparser->target_encoding = encoding;\n\tparser->case_folding = 1;\n\tparser->object = NULL;\n\tparser->isparsing = 0;\n\tXML_SetUserData(parser->parser, parser);\n\tZEND_REGISTER_RESOURCE(return_value, parser,le_xml_parser);\n\tparser->index = Z_LVAL_P(return_value);\n}", "target": 0}
{"code": "void abort_creds(struct cred *new)\n{\n\tkdebug(\"abort_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(new) != 0);\n#endif\n\tBUG_ON(atomic_read(&new->usage) < 1);\n\tput_cred(new);\n}", "target": 0}
{"code": "void btrfs_update_commit_device_size(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct btrfs_device *curr, *next;\n\tif (list_empty(&fs_devices->resized_devices))\n\t\treturn;\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tmutex_lock(&fs_info->chunk_mutex);\n\tlist_for_each_entry_safe(curr, next, &fs_devices->resized_devices,\n\t\t\t\t resized_list) {\n\t\tlist_del_init(&curr->resized_list);\n\t\tcurr->commit_total_bytes = curr->disk_total_bytes;\n\t}\n\tmutex_unlock(&fs_info->chunk_mutex);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n}", "target": 0}
{"code": "negotiate_mech(gss_OID_set supported, gss_OID_set received,\n\t       OM_uint32 *negResult)\n{\n\tsize_t i, j;\n\tfor (i = 0; i < received->count; i++) {\n\t\tgss_OID mech_oid = &received->elements[i];\n\t\tif (g_OID_equal(mech_oid, &gss_mech_krb5_wrong_oid))\n\t\t\tmech_oid = (gss_OID)&gss_mech_krb5_oid;\n\t\tfor (j = 0; j < supported->count; j++) {\n\t\t\tif (g_OID_equal(mech_oid, &supported->elements[j])) {\n\t\t\t\t*negResult = (i == 0) ? ACCEPT_INCOMPLETE :\n\t\t\t\t\tREQUEST_MIC;\n\t\t\t\treturn &received->elements[i];\n\t\t\t}\n\t\t}\n\t}\n\t*negResult = REJECT;\n\treturn (NULL);\n}", "target": 0}
{"code": "  DllDef void libraw_set_gamma(libraw_data_t *lr, int index, float value)\n  {\n    if (!lr)\n      return;\n    LibRaw *ip = (LibRaw *)lr->parent_class;\n    ip->imgdata.params.gamm[LIM(index, 0, 5)] = value;\n  }", "target": 0}
{"code": "static module *find_module(server_rec *s, const char *name)\n{\n    module *found = ap_find_linked_module(name);\n    if (!found) {\n        ap_module_symbol_t *current = ap_prelinked_module_symbols;\n        for (; current->name; ++current) {\n            if (!strcmp(current->name, name)) {\n                found = current->modp;\n                break;\n            }\n        }\n    }\n    if (!found) {\n        APR_OPTIONAL_FN_TYPE(ap_find_loaded_module_symbol) *check_symbol =\n            APR_RETRIEVE_OPTIONAL_FN(ap_find_loaded_module_symbol);\n        if (check_symbol) {\n            found = check_symbol(s->is_virtual ? ap_server_conf : s, name);\n        }\n    }\n    return found;\n}", "target": 0}
{"code": "static int fts3EvalNearTrim(\n  int nNear,                      \n  char *aTmp,                     \n  char **paPoslist,               \n  int *pnToken,                   \n  Fts3Phrase *pPhrase             \n){\n  int nParam1 = nNear + pPhrase->nToken;\n  int nParam2 = nNear + *pnToken;\n  int nNew;\n  char *p2; \n  char *pOut; \n  int res;\n  assert( pPhrase->doclist.pList );\n  p2 = pOut = pPhrase->doclist.pList;\n  res = fts3PoslistNearMerge(\n    &pOut, aTmp, nParam1, nParam2, paPoslist, &p2\n  );\n  if( res ){\n    nNew = (int)(pOut - pPhrase->doclist.pList) - 1;\n    assert( pPhrase->doclist.pList[nNew]=='\\0' );\n    assert( nNew<=pPhrase->doclist.nList && nNew>0 );\n    memset(&pPhrase->doclist.pList[nNew], 0, pPhrase->doclist.nList - nNew);\n    pPhrase->doclist.nList = nNew;\n    *paPoslist = pPhrase->doclist.pList;\n    *pnToken = pPhrase->nToken;\n  }\n  return res;\n}", "target": 0}
{"code": "void PDFiumEngineExports::SetPDFUseGDIPrinting(bool enable) {\n  FPDF_SetPrintTextWithGDI(enable);\n}", "target": 0}
{"code": "static bool nested_vmx_exit_handled_io(struct kvm_vcpu *vcpu,\n\t\t\t\t       struct vmcs12 *vmcs12)\n{\n\tunsigned long exit_qualification;\n\tgpa_t bitmap, last_bitmap;\n\tunsigned int port;\n\tint size;\n\tu8 b;\n\tif (!nested_cpu_has(vmcs12, CPU_BASED_USE_IO_BITMAPS))\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_UNCOND_IO_EXITING);\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tport = exit_qualification >> 16;\n\tsize = (exit_qualification & 7) + 1;\n\tlast_bitmap = (gpa_t)-1;\n\tb = -1;\n\twhile (size > 0) {\n\t\tif (port < 0x8000)\n\t\t\tbitmap = vmcs12->io_bitmap_a;\n\t\telse if (port < 0x10000)\n\t\t\tbitmap = vmcs12->io_bitmap_b;\n\t\telse\n\t\t\treturn true;\n\t\tbitmap += (port & 0x7fff) / 8;\n\t\tif (last_bitmap != bitmap)\n\t\t\tif (kvm_vcpu_read_guest(vcpu, bitmap, &b, 1))\n\t\t\t\treturn true;\n\t\tif (b & (1 << (port & 7)))\n\t\t\treturn true;\n\t\tport++;\n\t\tsize--;\n\t\tlast_bitmap = bitmap;\n\t}\n\treturn false;\n}", "target": 0}
{"code": "smb21_set_oplock_level(struct cifsInodeInfo *cinode, __u32 oplock,\n\t\t       unsigned int epoch, bool *purge_cache)\n{\n\tchar message[5] = {0};\n\tunsigned int new_oplock = 0;\n\toplock &= 0xFF;\n\tcinode->lease_granted = true;\n\tif (oplock == SMB2_OPLOCK_LEVEL_NOCHANGE)\n\t\treturn;\n\tif (oplock & SMB2_OPLOCK_LEVEL_EXCLUSIVE)\n\t\treturn smb2_set_oplock_level(cinode, oplock, epoch,\n\t\t\t\t\t     purge_cache);\n\tif (oplock & SMB2_LEASE_READ_CACHING_HE) {\n\t\tnew_oplock |= CIFS_CACHE_READ_FLG;\n\t\tstrcat(message, \"R\");\n\t}\n\tif (oplock & SMB2_LEASE_HANDLE_CACHING_HE) {\n\t\tnew_oplock |= CIFS_CACHE_HANDLE_FLG;\n\t\tstrcat(message, \"H\");\n\t}\n\tif (oplock & SMB2_LEASE_WRITE_CACHING_HE) {\n\t\tnew_oplock |= CIFS_CACHE_WRITE_FLG;\n\t\tstrcat(message, \"W\");\n\t}\n\tif (!new_oplock)\n\t\tstrncpy(message, \"None\", sizeof(message));\n\tcinode->oplock = new_oplock;\n\tcifs_dbg(FYI, \"%s Lease granted on inode %p\\n\", message,\n\t\t &cinode->vfs_inode);\n}", "target": 0}
{"code": "static int encode_private_key(RSA *rsa, u8 *key, size_t *keysize)\n{\n\tu8 buf[1024], *p = buf;\n\tu8 bnbuf[256];\n\tint base = 0;\n\tint r;\n\tconst BIGNUM *rsa_p, *rsa_q, *rsa_dmp1, *rsa_dmq1, *rsa_iqmp;\n\tswitch (RSA_bits(rsa)) {\n\tcase 512:\n\t\tbase = 32;\n\t\tbreak;\n\tcase 768:\n\t\tbase = 48;\n\t\tbreak;\n\tcase 1024:\n\t\tbase = 64;\n\t\tbreak;\n\tcase 2048:\n\t\tbase = 128;\n\t\tbreak;\n\t}\n\tif (base == 0) {\n\t\tfprintf(stderr, \"Key length invalid.\\n\");\n\t\treturn 2;\n\t}\n\t*p++ = (5 * base + 3) >> 8;\n\t*p++ = (5 * base + 3) & 0xFF;\n\t*p++ = opt_key_num;\n\tRSA_get0_factors(rsa, &rsa_p, &rsa_q);\n\tr = bn2cf(rsa_p, bnbuf);\n\tif (r != base) {\n\t\tfprintf(stderr, \"Invalid private key.\\n\");\n\t\treturn 2;\n\t}\n\tmemcpy(p, bnbuf, base);\n\tp += base;\n\tr = bn2cf(rsa_q, bnbuf);\n\tif (r != base) {\n\t\tfprintf(stderr, \"Invalid private key.\\n\");\n\t\treturn 2;\n\t}\n\tmemcpy(p, bnbuf, base);\n\tp += base;\n\tRSA_get0_crt_params(rsa, &rsa_dmp1, &rsa_dmq1, &rsa_iqmp);\n\tr = bn2cf(rsa_iqmp, bnbuf);\n\tif (r != base) {\n\t\tfprintf(stderr, \"Invalid private key.\\n\");\n\t\treturn 2;\n\t}\n\tmemcpy(p, bnbuf, base);\n\tp += base;\n\tr = bn2cf(rsa_dmp1, bnbuf);\n\tif (r != base) {\n\t\tfprintf(stderr, \"Invalid private key.\\n\");\n\t\treturn 2;\n\t}\n\tmemcpy(p, bnbuf, base);\n\tp += base;\n\tr = bn2cf(rsa_dmq1, bnbuf);\n\tif (r != base) {\n\t\tfprintf(stderr, \"Invalid private key.\\n\");\n\t\treturn 2;\n\t}\n\tmemcpy(p, bnbuf, base);\n\tp += base;\n\tmemcpy(key, buf, p - buf);\n\t*keysize = p - buf;\n\treturn 0;\n}", "target": 0}
{"code": "int js_isdefined(js_State *J, int idx) { return stackidx(J, idx)->type != JS_TUNDEFINED; }", "target": 0}
{"code": "ipcp_store_bits_results (void)\n{\n  cgraph_node *node;\n  FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n    {\n      ipa_node_params *info = IPA_NODE_REF (node);\n      bool dumped_sth = false;\n      bool found_useful_result = false;\n      if (!opt_for_fn (node->decl, flag_ipa_bit_cp) || !info)\n\t{\n\t  if (dump_file)\n\t    fprintf (dump_file, \"Not considering %s for ipa bitwise propagation \"\n\t\t\t\t\"; -fipa-bit-cp: disabled.\\n\",\n\t\t\t\tnode->name ());\n\t  continue;\n\t}\n      if (info->ipcp_orig_node)\n\tinfo = IPA_NODE_REF (info->ipcp_orig_node);\n      if (!info->lattices)\n\tcontinue;\n      unsigned count = ipa_get_param_count (info);\n      for (unsigned i = 0; i < count; i++)\n\t{\n\t  ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n\t  if (plats->bits_lattice.constant_p ())\n\t    {\n\t      found_useful_result = true;\n\t      break;\n\t    }\n\t}\n      if (!found_useful_result)\n\tcontinue;\n      ipcp_transformation_initialize ();\n      ipcp_transformation *ts = ipcp_transformation_sum->get_create (node);\n      vec_safe_reserve_exact (ts->bits, count);\n      for (unsigned i = 0; i < count; i++)\n\t{\n\t  ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n\t  ipa_bits *jfbits;\n\t  if (plats->bits_lattice.constant_p ())\n\t    jfbits\n\t      = ipa_get_ipa_bits_for_value (plats->bits_lattice.get_value (),\n\t\t\t\t\t    plats->bits_lattice.get_mask ());\n\t  else\n\t    jfbits = NULL;\n\t  ts->bits->quick_push (jfbits);\n\t  if (!dump_file || !jfbits)\n\t    continue;\n\t  if (!dumped_sth)\n\t    {\n\t      fprintf (dump_file, \"Propagated bits info for function %s:\\n\",\n\t\t       node->dump_name ());\n\t      dumped_sth = true;\n\t    }\n\t  fprintf (dump_file, \" param %i: value = \", i);\n\t  print_hex (jfbits->value, dump_file);\n\t  fprintf (dump_file, \", mask = \");\n\t  print_hex (jfbits->mask, dump_file);\n\t  fprintf (dump_file, \"\\n\");\n\t}\n    }\n}", "target": 0}
{"code": "bool _af_ms_adpcm_format_ok (_AudioFormat *f)\n{\n\tif (f->channelCount != 1 && f->channelCount != 2)\n\t{\n\t\t_af_error(AF_BAD_COMPRESSION,\n\t\t\t\"MS ADPCM compression requires 1 or 2 channels\");\n\t\treturn false;\n\t}\n\tif (f->sampleFormat != AF_SAMPFMT_TWOSCOMP || f->sampleWidth != 16)\n\t{\n\t\t_af_error(AF_BAD_COMPRESSION,\n\t\t\t\"MS ADPCM compression requires 16-bit signed integer format\");\n\t\tf->sampleFormat = AF_SAMPFMT_TWOSCOMP;\n\t\tf->sampleWidth = 16;\n\t}\n\tif (f->byteOrder != AF_BYTEORDER_BIGENDIAN)\n\t{\n\t\t_af_error(AF_BAD_COMPRESSION,\n\t\t\t\"MS ADPCM compression requires big endian format\");\n\t\tf->byteOrder = AF_BYTEORDER_BIGENDIAN;\n\t}\n\treturn true;\n}", "target": 0}
{"code": "void smp_pairing_cmpl(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n if (p_cb->total_tx_unacked == 0) {\n    smp_proc_pairing_cmpl(p_cb);\n }\n}", "target": 0}
{"code": "static void unhash_id(struct fuse *f, struct node *node)\n{\n    size_t hash = node->nodeid % f->id_table_size;\n    struct node **nodep = &f->id_table[hash];\n    for (; *nodep != NULL; nodep = &(*nodep)->id_next)\n        if (*nodep == node) {\n            *nodep = node->id_next;\n            return;\n        }\n}", "target": 0}
{"code": "static MagickBooleanType WritePTIFImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  Image\n    *images,\n    *next,\n    *pyramid_image;\n  ImageInfo\n    *write_info;\n  MagickBooleanType\n    status;\n  PointInfo\n    resolution;\n  size_t\n    columns,\n    rows;\n  images=NewImageList();\n  for (next=image; next != (Image *) NULL; next=GetNextImageInList(next))\n  {\n    Image\n      *clone_image;\n    clone_image=CloneImage(next,0,0,MagickFalse,exception);\n    if (clone_image == (Image *) NULL)\n      break;\n    clone_image->previous=NewImageList();\n    clone_image->next=NewImageList();\n    (void) SetImageProperty(clone_image,\"tiff:subfiletype\",\"none\",exception);\n    AppendImageToList(&images,clone_image);\n    columns=next->columns;\n    rows=next->rows;\n    resolution=next->resolution;\n    while ((columns > 64) && (rows > 64))\n    {\n      columns/=2;\n      rows/=2;\n      resolution.x/=2;\n      resolution.y/=2;\n      pyramid_image=ResizeImage(next,columns,rows,image->filter,exception);\n      if (pyramid_image == (Image *) NULL)\n        break;\n      pyramid_image->resolution=resolution;\n      (void) SetImageProperty(pyramid_image,\"tiff:subfiletype\",\"REDUCEDIMAGE\",\n        exception);\n      AppendImageToList(&images,pyramid_image);\n    }\n  }\n  images=GetFirstImageInList(images);\n  write_info=CloneImageInfo(image_info);\n  write_info->adjoin=MagickTrue;\n  (void) CopyMagickString(write_info->magick,\"TIFF\",MagickPathExtent);\n  (void) CopyMagickString(images->magick,\"TIFF\",MagickPathExtent);\n  status=WriteTIFFImage(write_info,images,exception);\n  images=DestroyImageList(images);\n  write_info=DestroyImageInfo(write_info);\n  return(status);\n}", "target": 0}
{"code": "void spk_ttyio_register_ldisc(void)\n{\n\tif (tty_register_ldisc(N_SPEAKUP, &spk_ttyio_ldisc_ops))\n\t\tpr_warn(\"speakup: Error registering line discipline. Most synths won't work.\\n\");\n}", "target": 0}
{"code": "static RBinElfSymbol *Elf_(r_bin_elf_get_phdr_symbols)(ELFOBJ *bin) {\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tif (bin->phdr_symbols) {\n\t\treturn bin->phdr_symbols;\n\t}\n\tbin->phdr_symbols = get_symbols_from_phdr (bin, R_BIN_ELF_SYMBOLS);\n\treturn bin->phdr_symbols;\n}", "target": 0}
{"code": "void LIRGenerator::volatile_field_load(LIR_Address* address, LIR_Opr result,\n                                       CodeEmitInfo* info) {\n  if (address->type() == T_LONG) {\n    address = new LIR_Address(address->base(),\n                              address->index(), address->scale(),\n                              address->disp(), T_DOUBLE);\n    LIR_Opr temp_double = new_register(T_DOUBLE);\n    __ volatile_move(LIR_OprFact::address(address), temp_double, T_LONG, info);\n    __ volatile_move(temp_double, result, T_LONG);\n    if (UseSSE < 2) {\n      set_vreg_flag(result, must_start_in_memory);\n    }\n  } else {\n    __ load(address, result, info);\n  }\n}", "target": 0}
{"code": "static int ep_poll(struct eventpoll *ep, struct epoll_event __user *events,\n\t\t   int maxevents, long timeout)\n{\n\tint res = 0, eavail, timed_out = 0;\n\tunsigned long flags;\n\tlong slack = 0;\n\twait_queue_t wait;\n\tktime_t expires, *to = NULL;\n\tif (timeout > 0) {\n\t\tstruct timespec end_time = ep_set_mstimeout(timeout);\n\t\tslack = select_estimate_accuracy(&end_time);\n\t\tto = &expires;\n\t\t*to = timespec_to_ktime(end_time);\n\t} else if (timeout == 0) {\n\t\ttimed_out = 1;\n\t\tspin_lock_irqsave(&ep->lock, flags);\n\t\tgoto check_events;\n\t}\nfetch_events:\n\tspin_lock_irqsave(&ep->lock, flags);\n\tif (!ep_events_available(ep)) {\n\t\tinit_waitqueue_entry(&wait, current);\n\t\t__add_wait_queue_exclusive(&ep->wq, &wait);\n\t\tfor (;;) {\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tif (ep_events_available(ep) || timed_out)\n\t\t\t\tbreak;\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tres = -EINTR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&ep->lock, flags);\n\t\t\tif (!schedule_hrtimeout_range(to, slack, HRTIMER_MODE_ABS))\n\t\t\t\ttimed_out = 1;\n\t\t\tspin_lock_irqsave(&ep->lock, flags);\n\t\t}\n\t\t__remove_wait_queue(&ep->wq, &wait);\n\t\tset_current_state(TASK_RUNNING);\n\t}\ncheck_events:\n\teavail = ep_events_available(ep);\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\tif (!res && eavail &&\n\t    !(res = ep_send_events(ep, events, maxevents)) && !timed_out)\n\t\tgoto fetch_events;\n\treturn res;\n}", "target": 0}
{"code": "GfxColorSpace *GfxSeparationColorSpace::parse(GfxResources *res, Array *arr, OutputDev *out, GfxState *state, int recursion)\n{\n    GfxSeparationColorSpace *cs;\n    GooString *nameA;\n    GfxColorSpace *altA;\n    Function *funcA;\n    Object obj1;\n    if (arr->getLength() != 4) {\n        error(errSyntaxWarning, -1, \"Bad Separation color space\");\n        goto err1;\n    }\n    obj1 = arr->get(1);\n    if (!obj1.isName()) {\n        error(errSyntaxWarning, -1, \"Bad Separation color space (name)\");\n        goto err1;\n    }\n    nameA = new GooString(obj1.getName());\n    obj1 = arr->get(2);\n    if (!(altA = GfxColorSpace::parse(res, &obj1, out, state, recursion + 1))) {\n        error(errSyntaxWarning, -1, \"Bad Separation color space (alternate color space)\");\n        goto err3;\n    }\n    obj1 = arr->get(3);\n    if (!(funcA = Function::parse(&obj1))) {\n        goto err4;\n    }\n    if (funcA->getInputSize() != 1) {\n        error(errSyntaxWarning, -1, \"Bad SeparationColorSpace function\");\n        goto err5;\n    }\n    cs = new GfxSeparationColorSpace(nameA, altA, funcA);\n    return cs;\nerr5:\n    delete funcA;\nerr4:\n    delete altA;\nerr3:\n    delete nameA;\nerr1:\n    return nullptr;\n}", "target": 0}
{"code": "static int handle_ept_misconfig(struct kvm_vcpu *vcpu)\n{\n\tint ret;\n\tgpa_t gpa;\n\tgpa = vmcs_read64(GUEST_PHYSICAL_ADDRESS);\n\tif (!kvm_io_bus_write(vcpu, KVM_FAST_MMIO_BUS, gpa, 0, NULL)) {\n\t\tskip_emulated_instruction(vcpu);\n\t\ttrace_kvm_fast_mmio(gpa);\n\t\treturn 1;\n\t}\n\tret = handle_mmio_page_fault(vcpu, gpa, true);\n\tif (likely(ret == RET_MMIO_PF_EMULATE))\n\t\treturn x86_emulate_instruction(vcpu, gpa, 0, NULL, 0) ==\n\t\t\t\t\t      EMULATE_DONE;\n\tif (unlikely(ret == RET_MMIO_PF_INVALID))\n\t\treturn kvm_mmu_page_fault(vcpu, gpa, 0, NULL, 0);\n\tif (unlikely(ret == RET_MMIO_PF_RETRY))\n\t\treturn 1;\n\tWARN_ON(1);\n\tvcpu->run->exit_reason = KVM_EXIT_UNKNOWN;\n\tvcpu->run->hw.hardware_exit_reason = EXIT_REASON_EPT_MISCONFIG;\n\treturn 0;\n}", "target": 0}
{"code": "static bool tr_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment tr;\n\tvmx_get_segment(vcpu, &tr, VCPU_SREG_TR);\n\tif (tr.unusable)\n\t\treturn false;\n\tif (tr.selector & SEGMENT_TI_MASK)\t\n\t\treturn false;\n\tif (tr.type != 3 && tr.type != 11) \n\t\treturn false;\n\tif (!tr.present)\n\t\treturn false;\n\treturn true;\n}", "target": 0}
{"code": "GF_Err gf_isom_close(GF_ISOFile *movie)\n{\n\tGF_Err e=GF_OK;\n\tif (movie == NULL) return GF_ISOM_INVALID_FILE;\n\te = gf_isom_write(movie);\n\tgf_isom_delete_movie(movie);\n\treturn e;\n}", "target": 0}
{"code": "void PDFiumEngine::Form_EmailTo(FPDF_FORMFILLINFO* param,\n                                FPDF_FILEHANDLER* file_handler,\n                                FPDF_WIDESTRING to,\n                                FPDF_WIDESTRING subject,\n                                FPDF_WIDESTRING cc,\n                                FPDF_WIDESTRING bcc,\n                                FPDF_WIDESTRING message) {\n  std::string to_str =\n      base::UTF16ToUTF8(reinterpret_cast<const base::char16*>(to));\n  std::string subject_str =\n      base::UTF16ToUTF8(reinterpret_cast<const base::char16*>(subject));\n  std::string cc_str =\n      base::UTF16ToUTF8(reinterpret_cast<const base::char16*>(cc));\n  std::string bcc_str =\n      base::UTF16ToUTF8(reinterpret_cast<const base::char16*>(bcc));\n  std::string message_str =\n      base::UTF16ToUTF8(reinterpret_cast<const base::char16*>(message));\n  PDFiumEngine* engine = static_cast<PDFiumEngine*>(param);\n  engine->client_->Email(to_str, cc_str, bcc_str, subject_str, message_str);\n}", "target": 0}
{"code": "RPVector *r_bin_wasm_get_memories(RBinWasmObj *bin) {\n\tr_return_val_if_fail (bin && bin->g_sections, NULL);\n\treturn bin->g_memories? bin->g_memories: parse_unique_subsec_vec_by_id (bin, R_BIN_WASM_SECTION_MEMORY);\n}", "target": 0}
{"code": "update_map (char * const mapping, const char * const map_file)\n{\n  const size_t map_len = strlen (mapping);\n  const int fd = xopen (map_file, O_WRONLY, 0);\n  xwrite (fd, mapping, map_len);\n  xclose (fd);\n}", "target": 0}
{"code": "kadm5_create_principal(void *server_handle,\n                       kadm5_principal_ent_t entry, long mask,\n                       char *password)\n{\n    return\n        kadm5_create_principal_3(server_handle, entry, mask,\n                                 0, NULL, password);\n}", "target": 0}
{"code": "decompileWAITFORFRAME (SWF_ACTION *act)\n{\n\tOUT_BEGIN(SWF_ACTIONWAITFORFRAME);\n\tINDENT\n\tprintln(\"WaitForFrame(%d,%d);\", sact->Frame,sact->SkipCount);\n}", "target": 0}
{"code": "gimp_channel_convert_type (GimpDrawable     *drawable,\n                           GimpImage        *dest_image,\n                           const Babl       *new_format,\n                           GimpColorProfile *dest_profile,\n                           GeglDitherMethod  layer_dither_type,\n                           GeglDitherMethod  mask_dither_type,\n                           gboolean          push_undo,\n                           GimpProgress     *progress)\n{\n  GeglBuffer *dest_buffer;\n  dest_buffer =\n    gegl_buffer_new (GEGL_RECTANGLE (0, 0,\n                                     gimp_item_get_width  (GIMP_ITEM (drawable)),\n                                     gimp_item_get_height (GIMP_ITEM (drawable))),\n                     new_format);\n  if (mask_dither_type == GEGL_DITHER_NONE)\n    {\n      gimp_gegl_buffer_copy (gimp_drawable_get_buffer (drawable), NULL,\n                             GEGL_ABYSS_NONE,\n                             dest_buffer, NULL);\n    }\n  else\n    {\n      gint bits;\n      bits = (babl_format_get_bytes_per_pixel (new_format) * 8 /\n              babl_format_get_n_components (new_format));\n      gimp_gegl_apply_dither (gimp_drawable_get_buffer (drawable),\n                              NULL, NULL,\n                              dest_buffer, 1 << bits, mask_dither_type);\n    }\n  gimp_drawable_set_buffer (drawable, push_undo, NULL, dest_buffer);\n  g_object_unref (dest_buffer);\n}", "target": 0}
{"code": "    uint32_t TiffEncoder::updateDirEntry(byte* buf,\n                                         ByteOrder byteOrder,\n                                         TiffComponent* pTiffComponent) const\n    {\n        assert(buf);\n        assert(pTiffComponent);\n        TiffEntryBase* pTiffEntry = dynamic_cast<TiffEntryBase*>(pTiffComponent);\n        assert(pTiffEntry);\n        us2Data(buf + 2, pTiffEntry->tiffType(), byteOrder);\n        ul2Data(buf + 4, pTiffEntry->count(),    byteOrder);\n        if (pTiffEntry->size() <= 4 && buf + 8 != pTiffEntry->pData()) {\n#ifdef DEBUG\n            std::cerr << \"Copying data for tag \" << pTiffEntry->tag()\n                      << \" to offset area.\\n\";\n#endif\n            memset(buf + 8, 0x0, 4);\n            memcpy(buf + 8, pTiffEntry->pData(), pTiffEntry->size());\n            memset(const_cast<byte*>(pTiffEntry->pData()), 0x0, pTiffEntry->size());\n        }\n        return 12;\n    }", "target": 0}
{"code": "int bdev_add_partition(struct gendisk *disk, int partno, sector_t start,\n\t\tsector_t length)\n{\n\tstruct block_device *part;\n\tint ret;\n\tmutex_lock(&disk->open_mutex);\n\tif (!disk_live(disk)) {\n\t\tret = -ENXIO;\n\t\tgoto out;\n\t}\n\tif (partition_overlaps(disk, start, length, -1)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\tpart = add_partition(disk, partno, start, length,\n\t\t\tADDPART_FLAG_NONE, NULL);\n\tret = PTR_ERR_OR_ZERO(part);\nout:\n\tmutex_unlock(&disk->open_mutex);\n\treturn ret;\n}", "target": 0}
{"code": "static int spl_ptr_heap_cmp_cb_helper(zval *object, spl_heap_object *heap_object, zval *a, zval *b, long *result TSRMLS_DC) { \n\t\tzval *result_p = NULL;\n\t\tzend_call_method_with_2_params(&object, heap_object->std.ce, &heap_object->fptr_cmp, \"compare\", &result_p, a, b);\n\t\tif (EG(exception)) {\n\t\t\treturn FAILURE;\n\t\t}\n\t\tconvert_to_long(result_p);\n\t\t*result = Z_LVAL_P(result_p);\n\t\tzval_ptr_dtor(&result_p);\n\t\treturn SUCCESS;\n}", "target": 0}
{"code": "    void eraseIfd(Exiv2::ExifData& ed, Exiv2::IfdId ifdId)\n    {\n        ed.erase(std::remove_if(ed.begin(),\n                                ed.end(),\n                                Exiv2::FindExifdatum(ifdId)),\n                 ed.end());\n    }", "target": 0}
{"code": "PHP_FUNCTION(floor)\n{\n\tzval **value;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Z\", &value) == FAILURE) {\n\t\treturn;\n\t}\n\tconvert_scalar_to_number_ex(value);\n\tif (Z_TYPE_PP(value) == IS_DOUBLE) {\n\t\tRETURN_DOUBLE(floor(Z_DVAL_PP(value)));\n\t} else if (Z_TYPE_PP(value) == IS_LONG) {\n\t\tconvert_to_double_ex(value);\n\t\tRETURN_DOUBLE(Z_DVAL_PP(value));\n\t}\n\tRETURN_FALSE;\n}", "target": 0}
{"code": "static inline XMLTokenizer* getTokenizer(void* closure)\n{\n    xmlParserCtxtPtr ctxt = static_cast<xmlParserCtxtPtr>(closure);\n    return static_cast<XMLTokenizer*>(ctxt->_private);\n}", "target": 0}
{"code": "static void n_tty_check_unthrottle(struct tty_struct *tty)\n{\n\tif (tty->driver->type == TTY_DRIVER_TYPE_PTY &&\n\t    tty->link->ldisc->ops->write_wakeup == n_tty_write_wakeup) {\n\t\tif (chars_in_buffer(tty) > TTY_THRESHOLD_UNTHROTTLE)\n\t\t\treturn;\n\t\tif (!tty->count)\n\t\t\treturn;\n\t\tn_tty_set_room(tty);\n\t\tn_tty_write_wakeup(tty->link);\n\t\tif (waitqueue_active(&tty->link->write_wait))\n\t\t\twake_up_interruptible_poll(&tty->link->write_wait, POLLOUT);\n\t\treturn;\n\t}\n\twhile (1) {\n\t\tint unthrottled;\n\t\ttty_set_flow_change(tty, TTY_UNTHROTTLE_SAFE);\n\t\tif (chars_in_buffer(tty) > TTY_THRESHOLD_UNTHROTTLE)\n\t\t\tbreak;\n\t\tif (!tty->count)\n\t\t\tbreak;\n\t\tn_tty_set_room(tty);\n\t\tunthrottled = tty_unthrottle_safe(tty);\n\t\tif (!unthrottled)\n\t\t\tbreak;\n\t}\n\t__tty_set_flow_change(tty, 0);\n}", "target": 0}
{"code": "chunk_new_with_alloc_size(size_t alloc)\n{\n  chunk_t *ch;\n  ch = tor_malloc(alloc);\n  ch->next = NULL;\n  ch->datalen = 0;\n#ifdef DEBUG_CHUNK_ALLOC\n  ch->DBG_alloc = alloc;\n#endif\n  ch->memlen = CHUNK_SIZE_WITH_ALLOC(alloc);\n  total_bytes_allocated_in_chunks += alloc;\n  ch->data = &ch->mem[0];\n  return ch;\n}", "target": 0}
{"code": "static void mce_disable_error_reporting(void)\n{\n\tint i;\n\tfor (i = 0; i < mca_cfg.banks; i++) {\n\t\tstruct mce_bank *b = &mce_banks[i];\n\t\tif (b->init)\n\t\t\twrmsrl(msr_ops.ctl(i), 0);\n\t}\n\treturn;\n}", "target": 0}
{"code": "NCR_ReportSource(NCR_Instance inst, RPT_SourceReport *report, struct timeval *now)\n{\n  report->poll = inst->local_poll;\n  switch (inst->mode) {\n    case MODE_CLIENT:\n      report->mode = RPT_NTP_CLIENT;\n      break;\n    case MODE_ACTIVE:\n      report->mode = RPT_NTP_PEER;\n      break;\n    default:\n      assert(0);\n  }\n}", "target": 0}
{"code": " CFTypeRef tokenNullTypeRef()\n{\n    static CFStringRef tokenNullType = CFSTR(\"WKNull\");\n    return tokenNullType;\n}", "target": 0}
{"code": "   Mark a message for deletion */\nPHP_FUNCTION(imap_delete)\n{\n\tzval *streamind, *sequence;\n\tpils *imap_le_struct;\n\tzend_long flags = 0;\n\tint argc = ZEND_NUM_ARGS();\n\tif (zend_parse_parameters(argc, \"rz|l\", &streamind, &sequence, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\tif ((imap_le_struct = (pils *)zend_fetch_resource(Z_RES_P(streamind), \"imap\", le_imap)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tconvert_to_string_ex(sequence);\n\tmail_setflag_full(imap_le_struct->imap_stream, Z_STRVAL_P(sequence), \"\\\\DELETED\", (argc == 3 ? flags : NIL));\n\tRETVAL_TRUE;", "target": 0}
{"code": "DataObjectItem* DataObjectItem::CreateFromFile(File* file) {\n  DataObjectItem* item =\n      MakeGarbageCollected<DataObjectItem>(kFileKind, file->type());\n  item->file_ = file;\n  return item;\n}", "target": 0}
{"code": "onig_match_with_param(regex_t* reg, const UChar* str, const UChar* end,\n                      const UChar* at, OnigRegion* region, OnigOptionType option,\n                      OnigMatchParam* mp)\n{\n  int r;\n  UChar *prev;\n  MatchArg msa;\n  ADJUST_MATCH_PARAM(reg, mp);\n  MATCH_ARG_INIT(msa, reg, option, region, at, mp);\n  if (region\n#ifdef USE_POSIX_API_REGION_OPTION\n      && !IS_POSIX_REGION(option)\n#endif\n      ) {\n    r = onig_region_resize_clear(region, reg->num_mem + 1);\n  }\n  else\n    r = 0;\n  if (r == 0) {\n    if (ONIG_IS_OPTION_ON(option, ONIG_OPTION_CHECK_VALIDITY_OF_STRING)) {\n      if (! ONIGENC_IS_VALID_MBC_STRING(reg->enc, str, end)) {\n        r = ONIGERR_INVALID_WIDE_CHAR_VALUE;\n        goto end;\n      }\n    }\n    prev = (UChar* )onigenc_get_prev_char_head(reg->enc, str, at);\n    r = match_at(reg, str, end, end, at, prev, &msa);\n  }\n end:\n  MATCH_ARG_FREE(msa);\n  return r;\n}", "target": 0}
{"code": "static int64_t klv_decode_ber_length(AVIOContext *pb)\n{\n    uint64_t size = avio_r8(pb);\n    if (size & 0x80) { \n        int bytes_num = size & 0x7f;\n        if (bytes_num > 8)\n            return AVERROR_INVALIDDATA;\n        size = 0;\n        while (bytes_num--)\n            size = size << 8 | avio_r8(pb);\n    }\n    return size;\n}", "target": 0}
{"code": "sg_finish_rem_req(Sg_request *srp)\n{\n\tint ret = 0;\n\tSg_fd *sfp = srp->parentfp;\n\tSg_scatter_hold *req_schp = &srp->data;\n\tSCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\t      \"sg_finish_rem_req: res_used=%d\\n\",\n\t\t\t\t      (int) srp->res_used));\n\tif (srp->bio)\n\t\tret = blk_rq_unmap_user(srp->bio);\n\tif (srp->rq) {\n\t\tscsi_req_free_cmd(scsi_req(srp->rq));\n\t\tblk_put_request(srp->rq);\n\t}\n\tif (srp->res_used)\n\t\tsg_unlink_reserve(sfp, srp);\n\telse\n\t\tsg_remove_scat(sfp, req_schp);\n\treturn ret;\n}", "target": 0}
{"code": "static int __init ibwdt_init(void)\n{\n\tint err;\n\tprintk(KERN_INFO PFX\n\t\t\"WDT driver for IB700 single board computer initialising.\\n\");\n\terr = platform_driver_register(&ibwdt_driver);\n\tif (err)\n\t\treturn err;\n\tibwdt_platform_device = platform_device_register_simple(DRV_NAME,\n\t\t\t\t\t\t\t\t-1, NULL, 0);\n\tif (IS_ERR(ibwdt_platform_device)) {\n\t\terr = PTR_ERR(ibwdt_platform_device);\n\t\tgoto unreg_platform_driver;\n\t}\n\treturn 0;\nunreg_platform_driver:\n\tplatform_driver_unregister(&ibwdt_driver);\n\treturn err;\n}", "target": 0}
{"code": "njs_decode_hex(njs_str_t *dst, const njs_str_t *src)\n{\n    u_char        *p;\n    size_t        len;\n    njs_int_t     c;\n    njs_uint_t    i, n;\n    const u_char  *start;\n    n = 0;\n    p = dst->start;\n    start = src->start;\n    len = src->length;\n    for (i = 0; i < len; i++) {\n        c = njs_char_to_hex(start[i]);\n        if (njs_slow_path(c < 0)) {\n            break;\n        }\n        n = n * 16 + c;\n        if ((i & 1) != 0) {\n            *p++ = (u_char) n;\n            n = 0;\n        }\n    }\n    dst->length -= (dst->start + dst->length) - p;\n}", "target": 0}
{"code": "void PrepareFrameAndViewForPrint::CallOnReady() {\n  return on_ready_.Run();  \n}", "target": 0}
{"code": "void CallInfo::set_handle(Klass* resolved_klass,\n                          const methodHandle& resolved_method,\n                          Handle resolved_appendix,\n                          Handle resolved_method_type, TRAPS) {\n  if (resolved_method.is_null()) {\n    THROW_MSG(vmSymbols::java_lang_InternalError(), \"resolved method is null\");\n  }\n  assert(resolved_method->intrinsic_id() == vmIntrinsics::_invokeBasic ||\n         resolved_method->is_compiled_lambda_form(),\n         \"linkMethod must return one of these\");\n  int vtable_index = Method::nonvirtual_vtable_index;\n  assert(!resolved_method->has_vtable_index(), \"\");\n  set_common(resolved_klass, resolved_klass, resolved_method, resolved_method, CallInfo::direct_call, vtable_index, CHECK);\n  _resolved_appendix    = resolved_appendix;\n  _resolved_method_type = resolved_method_type;\n}", "target": 0}
{"code": "PassRefPtr<AccessibilityUIElement> AccessibilityUIElement::linkedUIElementAtIndex(unsigned index)\n{\n    return 0;\n}", "target": 0}
{"code": "  virtual int jpeg_src(void *) { return -1; }", "target": 0}
{"code": "void RenderView::OnAllowScriptToClose(bool script_can_close) {\n  script_can_close_ = script_can_close;\n}", "target": 0}
{"code": "static void tpacket_destruct_skb(struct sk_buff *skb)\n{\n\tstruct packet_sock *po = pkt_sk(skb->sk);\n\tif (likely(po->tx_ring.pg_vec)) {\n\t\tvoid *ph;\n\t\t__u32 ts;\n\t\tph = skb_shinfo(skb)->destructor_arg;\n\t\tpacket_dec_pending(&po->tx_ring);\n\t\tts = __packet_set_timestamp(po, ph, skb);\n\t\t__packet_set_status(po, ph, TP_STATUS_AVAILABLE | ts);\n\t}\n\tsock_wfree(skb);\n}", "target": 0}
{"code": "process_pdu_logon(STREAM s)\n{\n\tuint32 infotype;\n\tin_uint32_le(s, infotype);\n\tif (infotype == INFOTYPE_LOGON_EXTENDED_INF)\n\t{\n\t\tuint32 fieldspresent;\n\t\tin_uint8s(s, 2);\t\n\t\tin_uint32_le(s, fieldspresent);\n\t\tif (fieldspresent & LOGON_EX_AUTORECONNECTCOOKIE)\n\t\t{\n\t\t\tuint32 len;\n\t\t\tuint32 version;\n\t\t\tin_uint8s(s, 4);\t\n\t\t\tin_uint32_le(s, len);\n\t\t\tif (len != 28)\n\t\t\t{\n\t\t\t\twarning(\"Invalid length in Auto-Reconnect packet\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tin_uint32_le(s, version);\n\t\t\tif (version != 1)\n\t\t\t{\n\t\t\t\twarning(\"Unsupported version of Auto-Reconnect packet\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tin_uint32_le(s, g_reconnect_logonid);\n\t\t\tin_uint8a(s, g_reconnect_random, 16);\n\t\t\tg_has_reconnect_random = True;\n\t\t\tg_reconnect_random_ts = time(NULL);\n\t\t\tDEBUG((\"Saving auto-reconnect cookie, id=%u\\n\", g_reconnect_logonid));\n\t\t}\n\t}\n}", "target": 0}
{"code": "njs_typed_array_species_create(njs_vm_t *vm, njs_value_t *exemplar,\n    njs_value_t *args, njs_uint_t nargs, njs_value_t *retval)\n{\n    njs_int_t          ret;\n    njs_value_t        constructor;\n    njs_typed_array_t  *array;\n    array = njs_typed_array(exemplar);\n    njs_set_function(&constructor, &vm->constructors[array->type]);\n    ret = njs_value_species_constructor(vm, exemplar, &constructor,\n                                        &constructor);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    return njs_typed_array_create(vm, &constructor, args, nargs, retval);\n}", "target": 0}
{"code": "static MagickBooleanType RenderFreetype(Image *image,const DrawInfo *draw_info,\n  const char *magick_unused(encoding),const PointInfo *offset,\n  TypeMetric *metrics)\n{\n  (void) ThrowMagickException(&image->exception,GetMagickModule(),\n    MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\"`%s' (Freetype)\",\n    draw_info->font != (char *) NULL ? draw_info->font : \"none\");\n  return(RenderPostscript(image,draw_info,offset,metrics));\n}", "target": 0}
{"code": "static void k_itimer_rcu_free(struct rcu_head *head)\n{\n\tstruct k_itimer *tmr = container_of(head, struct k_itimer, it.rcu);\n\tkmem_cache_free(posix_timers_cache, tmr);\n}", "target": 0}
{"code": "static void push_output_configuration(AACContext *ac) {\n    if (ac->oc[1].status == OC_LOCKED) {\n        ac->oc[0] = ac->oc[1];\n    }\n    ac->oc[1].status = OC_NONE;\n}", "target": 0}
{"code": "static Image *RenderHoughLines(const ImageInfo *image_info,const size_t columns,\n  const size_t rows,ExceptionInfo *exception)\n{\n#define BoundingBox  \"viewbox\"\n  DrawInfo\n    *draw_info;\n  Image\n    *image;\n  MagickBooleanType\n    status;\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image->columns=columns;\n  image->rows=rows;\n  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  draw_info->affine.sx=image->resolution.x == 0.0 ? 1.0 : image->resolution.x/\n    DefaultResolution;\n  draw_info->affine.sy=image->resolution.y == 0.0 ? 1.0 : image->resolution.y/\n    DefaultResolution;\n  image->columns=(size_t) (draw_info->affine.sx*image->columns);\n  image->rows=(size_t) (draw_info->affine.sy*image->rows);\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  if (SetImageBackgroundColor(image,exception) == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  if (GetBlobStreamData(image) == (unsigned char *) NULL)\n    draw_info->primitive=FileToString(image->filename,~0UL,exception);\n  else\n    {\n      draw_info->primitive=(char *) AcquireMagickMemory((size_t)\n        GetBlobSize(image)+1);\n      if (draw_info->primitive != (char *) NULL)\n        {\n          (void) memcpy(draw_info->primitive,GetBlobStreamData(image),\n            (size_t) GetBlobSize(image));\n          draw_info->primitive[GetBlobSize(image)]='\\0';\n        }\n     }\n  (void) DrawImage(image,draw_info,exception);\n  draw_info=DestroyDrawInfo(draw_info);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}", "target": 0}
{"code": "static int prdt_tbl_entry_size(const AHCI_SG *tbl)\n{\n    return (le32_to_cpu(tbl->flags_size) & AHCI_PRDT_SIZE_MASK) + 1;\n}", "target": 0}
{"code": "njs_decode_base64(njs_str_t *dst, const njs_str_t *src)\n{\n    njs_decode_base64_core(dst, src, njs_basis64);\n}", "target": 0}
{"code": "_dbus_get_standard_system_servicedirs (DBusList **dirs)\n{\n  *dirs = NULL;\n  return TRUE;\n}", "target": 0}
{"code": "static void sched_dl_do_global(void)\n{\n\tu64 new_bw = -1;\n\tstruct dl_bw *dl_b;\n\tint cpu;\n\tunsigned long flags;\n\tdef_dl_bandwidth.dl_period = global_rt_period();\n\tdef_dl_bandwidth.dl_runtime = global_rt_runtime();\n\tif (global_rt_runtime() != RUNTIME_INF)\n\t\tnew_bw = to_ratio(global_rt_period(), global_rt_runtime());\n\tfor_each_possible_cpu(cpu) {\n\t\trcu_read_lock_sched();\n\t\tdl_b = dl_bw_of(cpu);\n\t\traw_spin_lock_irqsave(&dl_b->lock, flags);\n\t\tdl_b->bw = new_bw;\n\t\traw_spin_unlock_irqrestore(&dl_b->lock, flags);\n\t\trcu_read_unlock_sched();\n\t}\n}", "target": 0}
{"code": "void *TrustedPrimitives::UntrustedLocalAlloc(size_t size) noexcept {\n  void *result;\n  CHECK_OCALL(\n      ocall_untrusted_local_alloc(&result, static_cast<uint64_t>(size)));\n  if (result && !IsOutsideEnclave(result, static_cast<uint64_t>(size))) {\n    TrustedPrimitives::BestEffortAbort(\n        \"Allocated memory not found to be outside the enclave.\");\n  }\n  if (!result) {\n    errno = ENOMEM;\n    TrustedPrimitives::DebugPuts(\"UntrustedLocalAlloc on SGX failed.\");\n  }\n  return result;\n}", "target": 0}
{"code": "static void ldapsrv_accept_priv(struct stream_connection *c)\n{\n\tstruct ldapsrv_service *ldapsrv_service = talloc_get_type_abort(\n\t\tc->private_data, struct ldapsrv_service);\n\tstruct auth_session_info *session_info;\n\tsession_info = system_session(ldapsrv_service->task->lp_ctx);\n\tif (!session_info) {\n\t\tstream_terminate_connection(c, \"failed to setup system \"\n\t\t\t\t\t    \"session info\");\n\t\treturn;\n\t}\n\tldapsrv_accept(c, session_info, true);\n}", "target": 0}
{"code": "private uint32_t\ndo_ops(struct magic *m, intmax_t lhs, intmax_t off)\n{\n\tintmax_t offset;\n\tif (off) {\n\t\tswitch (m->in_op & FILE_OPS_MASK) {\n\t\tcase FILE_OPAND:\n\t\t\toffset = lhs & off;\n\t\t\tbreak;\n\t\tcase FILE_OPOR:\n\t\t\toffset = lhs | off;\n\t\t\tbreak;\n\t\tcase FILE_OPXOR:\n\t\t\toffset = lhs ^ off;\n\t\t\tbreak;\n\t\tcase FILE_OPADD:\n\t\t\toffset = lhs + off;\n\t\t\tbreak;\n\t\tcase FILE_OPMINUS:\n\t\t\toffset = lhs - off;\n\t\t\tbreak;\n\t\tcase FILE_OPMULTIPLY:\n\t\t\toffset = lhs * off;\n\t\t\tbreak;\n\t\tcase FILE_OPDIVIDE:\n\t\t\toffset = lhs / off;\n\t\t\tbreak;\n\t\tcase FILE_OPMODULO:\n\t\t\toffset = lhs % off;\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\toffset = lhs;\n\tif (m->in_op & FILE_OPINVERSE)\n\t\toffset = ~offset;", "target": 0}
{"code": "char *get_sa_devname(unsigned int major, unsigned int minor, unsigned long long wwn[],\n\t\t     unsigned int part_nr, unsigned int flags)\n{\n\tchar *dev_name = NULL, *persist_dev_name = NULL;\n\tstatic char sid[64];\n\tchar xsid[32] = \"\", pn[16] = \"\";\n\tif (DISPLAY_PERSIST_NAME_S(flags)) {\n\t\tpersist_dev_name = get_persistent_name_from_pretty(get_devname(major, minor, TRUE));\n\t}\n\tif (persist_dev_name) {\n\t\tdev_name = persist_dev_name;\n\t}\n\telse {\n\t\tif ((USE_STABLE_ID(flags)) && (wwn[0] != 0)) {\n\t\t\tif (wwn[1] != 0) {\n\t\t\t\tsprintf(xsid, \"%016llx\", wwn[1]);\n\t\t\t}\n\t\t\tif (part_nr) {\n\t\t\t\tsprintf(pn, \"-%d\", part_nr);\n\t\t\t}\n\t\t\tsnprintf(sid, sizeof(sid), \"%#016llx%s%s\", wwn[0], xsid, pn);\n\t\t\tdev_name = sid;\n\t\t}\n\t\telse if ((USE_PRETTY_OPTION(flags)) && (major == dm_major)) {\n\t\t\tdev_name = transform_devmapname(major, minor);\n\t\t}\n\t\tif (!dev_name) {\n\t\t\tdev_name = get_devname(major, minor,\n\t\t\t\t\t       USE_PRETTY_OPTION(flags));\n\t\t}\n\t}\n\treturn dev_name;\n}", "target": 0}
{"code": "static int bad_inode_setattr(struct dentry *direntry, struct iattr *attrs)\n{\n\treturn -EIO;\n}", "target": 0}
{"code": "void rdma_destroy_id(struct rdma_cm_id *id)\n{\n\tstruct rdma_id_private *id_priv =\n\t\tcontainer_of(id, struct rdma_id_private, id);\n\tmutex_lock(&id_priv->handler_mutex);\n\tdestroy_id_handler_unlock(id_priv);\n}", "target": 0}
{"code": "static void fuse_lib_readdir(fuse_req_t req, fuse_ino_t ino, size_t size,\n                             off_t off, struct fuse_file_info *llfi)\n{\n    struct fuse *f = req_fuse_prepare(req);\n    struct fuse_file_info fi;\n    struct fuse_dh *dh = get_dirhandle(llfi, &fi);\n    pthread_mutex_lock(&dh->lock);\n    if (!off)\n        dh->filled = 0;\n    if (!dh->filled) {\n        int err = readdir_fill(f, req, ino, size, off, dh, &fi);\n        if (err) {\n            reply_err(req, err);\n            goto out;\n        }\n    }\n    if (dh->filled) {\n        if ((off >= 0) && (off < dh->len)) {\n            if (off + size > dh->len)\n                size = dh->len - off;\n        } else\n            size = 0;\n    } else {\n        size = dh->len;\n        off = 0;\n    }\n    fuse_reply_buf(req, dh->contents + off, size);\n out:\n    pthread_mutex_unlock(&dh->lock);\n}", "target": 0}
{"code": "void smp_br_select_next_key(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n  SMP_TRACE_DEBUG(\"%s role=%d (0-master) r_keys=0x%x i_keys=0x%x\", __func__,\n                  p_cb->role, p_cb->local_r_key, p_cb->local_i_key);\n if (p_cb->role == HCI_ROLE_SLAVE ||\n (!p_cb->local_r_key && p_cb->role == HCI_ROLE_MASTER)) {\n    smp_key_pick_key(p_cb, p_data);\n }\n if (!p_cb->local_i_key && !p_cb->local_r_key) {\n if (smp_get_br_state() == SMP_BR_STATE_BOND_PENDING) {\n if (p_cb->total_tx_unacked == 0) {\n        tSMP_INT_DATA smp_int_data;\n        smp_int_data.status = SMP_SUCCESS;\n        smp_br_state_machine_event(p_cb, SMP_BR_AUTH_CMPL_EVT, &smp_int_data);\n } else {\n        p_cb->wait_for_authorization_complete = true;\n }\n }\n }\n}", "target": 0}
{"code": "BGD_DECLARE(int) gdAlphaBlend (int dst, int src)\n{\n\tint src_alpha = gdTrueColorGetAlpha(src);\n\tint dst_alpha, alpha, red, green, blue;\n\tint src_weight, dst_weight, tot_weight;\n\tif( src_alpha == gdAlphaOpaque )\n\t\treturn src;\n\tdst_alpha = gdTrueColorGetAlpha(dst);\n\tif( src_alpha == gdAlphaTransparent )\n\t\treturn dst;\n\tif( dst_alpha == gdAlphaTransparent )\n\t\treturn src;\n\tsrc_weight = gdAlphaTransparent - src_alpha;\n\tdst_weight = (gdAlphaTransparent - dst_alpha) * src_alpha / gdAlphaMax;\n\ttot_weight = src_weight + dst_weight;\n\talpha = src_alpha * dst_alpha / gdAlphaMax;\n\tred = (gdTrueColorGetRed(src) * src_weight\n\t       + gdTrueColorGetRed(dst) * dst_weight) / tot_weight;\n\tgreen = (gdTrueColorGetGreen(src) * src_weight\n\t         + gdTrueColorGetGreen(dst) * dst_weight) / tot_weight;\n\tblue = (gdTrueColorGetBlue(src) * src_weight\n\t        + gdTrueColorGetBlue(dst) * dst_weight) / tot_weight;\n\treturn ((alpha << 24) + (red << 16) + (green << 8) + blue);\n}", "target": 0}
{"code": "libxlDomainStartRestore(libxlDriverPrivate *driver,\n                        virDomainObj *vm,\n                        bool start_paused,\n                        int restore_fd,\n                        uint32_t restore_ver)\n{\n    return libxlDomainStart(driver, vm, start_paused,\n                            restore_fd, restore_ver);\n}", "target": 0}
{"code": "int sc_pkcs15emu_sc_hsm_init_ex(sc_pkcs15_card_t *p15card,\n\t\t\t\tstruct sc_aid *aid,\n\t\t\t\tsc_pkcs15emu_opt_t *opts)\n{\n\tif (opts && (opts->flags & SC_PKCS15EMU_FLAGS_NO_CHECK)) {\n\t\treturn sc_pkcs15emu_sc_hsm_init(p15card);\n\t} else {\n\t\tif (p15card->card->type != SC_CARD_TYPE_SC_HSM\n\t\t\t\t&& p15card->card->type != SC_CARD_TYPE_SC_HSM_SOC\n\t\t\t\t&& p15card->card->type != SC_CARD_TYPE_SC_HSM_GOID) {\n\t\t\treturn SC_ERROR_WRONG_CARD;\n\t\t}\n\t\treturn sc_pkcs15emu_sc_hsm_init(p15card);\n\t}\n}", "target": 0}
{"code": "static struct inet6_protocol *ipv6_gso_pull_exthdrs(struct sk_buff *skb,\n\t\t\t\t\t\t    int proto)\n{\n\tstruct inet6_protocol *ops = NULL;\n\tfor (;;) {\n\t\tstruct ipv6_opt_hdr *opth;\n\t\tint len;\n\t\tif (proto != NEXTHDR_HOP) {\n\t\t\tops = rcu_dereference(inet6_protos[proto]);\n\t\t\tif (unlikely(!ops))\n\t\t\t\tbreak;\n\t\t\tif (!(ops->flags & INET6_PROTO_GSO_EXTHDR))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (unlikely(!pskb_may_pull(skb, 8)))\n\t\t\tbreak;\n\t\topth = (void *)skb->data;\n\t\tlen = ipv6_optlen(opth);\n\t\tif (unlikely(!pskb_may_pull(skb, len)))\n\t\t\tbreak;\n\t\tproto = opth->nexthdr;\n\t\t__skb_pull(skb, len);\n\t}\n\treturn ops;\n}", "target": 0}
{"code": "st_insert(register st_table *table, register st_data_t key, st_data_t value)\n{\n    st_index_t hash_val, bin_pos;\n    register st_table_entry *ptr;\n    if (table->entries_packed) {\n        st_index_t i;\n        for (i = 0; i < table->num_entries; i++) {\n            if ((st_data_t)table->bins[i*2] == key) {\n                table->bins[i*2+1] = (struct st_table_entry*)value;\n                return 1;\n            }\n        }\n        if (MORE_PACKABLE_P(table)) {\n            i = table->num_entries++;\n            table->bins[i*2] = (struct st_table_entry*)key;\n            table->bins[i*2+1] = (struct st_table_entry*)value;\n            return 0;\n        }\n        else {\n            unpack_entries(table);\n        }\n    }\n    hash_val = do_hash(key, table);\n    FIND_ENTRY(table, ptr, hash_val, bin_pos);\n    if (ptr == 0) {\n\tADD_DIRECT(table, key, value, hash_val, bin_pos);\n\treturn 0;\n    }\n    else {\n\tptr->record = value;\n\treturn 1;\n    }\n}", "target": 0}
{"code": "static bool tcp_try_coalesce(struct sock *sk,\n\t\t\t     struct sk_buff *to,\n\t\t\t     struct sk_buff *from,\n\t\t\t     bool *fragstolen)\n{\n\tint delta;\n\t*fragstolen = false;\n\tif (TCP_SKB_CB(from)->seq != TCP_SKB_CB(to)->end_seq)\n\t\treturn false;\n\tif (!skb_try_coalesce(to, from, fragstolen, &delta))\n\t\treturn false;\n\tatomic_add(delta, &sk->sk_rmem_alloc);\n\tsk_mem_charge(sk, delta);\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPRCVCOALESCE);\n\tTCP_SKB_CB(to)->end_seq = TCP_SKB_CB(from)->end_seq;\n\tTCP_SKB_CB(to)->ack_seq = TCP_SKB_CB(from)->ack_seq;\n\tTCP_SKB_CB(to)->tcp_flags |= TCP_SKB_CB(from)->tcp_flags;\n\treturn true;\n}", "target": 0}
{"code": "  friend std::ostream& operator<<(std::ostream& os, const HeaderMap& headers) {\n    headers.dumpState(os);\n    return os;\n  }", "target": 0}
{"code": "static struct dma_pte *dma_pfn_level_pte(struct dmar_domain *domain,\n\t\t\t\t\t unsigned long pfn,\n\t\t\t\t\t int level, int *large_page)\n{\n\tstruct dma_pte *parent, *pte = NULL;\n\tint total = agaw_to_level(domain->agaw);\n\tint offset;\n\tparent = domain->pgd;\n\twhile (level <= total) {\n\t\toffset = pfn_level_offset(pfn, total);\n\t\tpte = &parent[offset];\n\t\tif (level == total)\n\t\t\treturn pte;\n\t\tif (!dma_pte_present(pte)) {\n\t\t\t*large_page = total;\n\t\t\tbreak;\n\t\t}\n\t\tif (dma_pte_superpage(pte)) {\n\t\t\t*large_page = total;\n\t\t\treturn pte;\n\t\t}\n\t\tparent = phys_to_virt(dma_pte_addr(pte));\n\t\ttotal--;\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "int RegisterSignalHandler(int signum,\n                          void (*klinux_sigaction)(int, klinux_siginfo_t *,\n                                                   void *),\n                          const sigset_t mask, int flags) {\n  flags &= ~SA_SIGINFO;\n  flags &= SA_NODEFER | SA_RESETHAND;\n  absl::optional<int> klinux_signum = TokLinuxSignalNumber(signum);\n  absl::optional<int> klinux_flags = TokLinuxSignalFlag(flags);\n  if (!klinux_signum || !klinux_flags) {\n    errno = EINVAL;\n    return -1;\n  }\n  klinux_sigset_t klinux_mask;\n  TokLinuxSigset(&mask, &klinux_mask);\n  int ret;\n  CHECK_OCALL(ocall_enc_untrusted_register_signal_handler(\n      &ret, *klinux_signum, reinterpret_cast<void *>(klinux_sigaction),\n      reinterpret_cast<void *>(&klinux_mask), sizeof(klinux_mask),\n      *klinux_flags));\n  return ret;\n}", "target": 0}
{"code": "static ssize_t bql_show_inflight(struct netdev_queue *queue,\n\t\t\t\t char *buf)\n{\n\tstruct dql *dql = &queue->dql;\n\treturn sprintf(buf, \"%u\\n\", dql->num_queued - dql->num_completed);", "target": 0}
{"code": "void FrameLoader::addData(const char* bytes, int length)\n{\n    ASSERT(m_workingURL.isEmpty());\n    ASSERT(m_frame->document());\n    ASSERT(m_frame->document()->parsing());\n    write(bytes, length);\n}", "target": 0}
{"code": "Eina_Bool ewk_view_setting_auto_shrink_images_set(Evas_Object* ewkView, Eina_Bool automatic)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, false);\n    automatic = !!automatic;\n    if (priv->settings.autoShrinkImages != automatic) {\n        priv->pageSettings->setShrinksStandaloneImagesToFit(automatic);\n        priv->settings.autoShrinkImages = automatic;\n    }\n    return true;\n}", "target": 0}
{"code": "static int coolkey_select_file(sc_card_t *card, const sc_path_t *in_path, sc_file_t **file_out)\n{\n\tint r;\n\tstruct sc_file *file = NULL;\n\tcoolkey_private_data_t * priv = COOLKEY_DATA(card);\n\tunsigned long object_id;\n\tassert(card != NULL && in_path != NULL);\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tif (in_path->len != 4) {\n\t\treturn SC_ERROR_OBJECT_NOT_FOUND;\n\t}\n\tr = coolkey_select_applet(card);\n\tif (r != SC_SUCCESS) {\n\t\treturn r;\n\t}\n\tobject_id = bebytes2ulong(in_path->value);\n\tpriv->obj = coolkey_find_object_by_id(&priv->objects_list, object_id);\n\tif (priv->obj == NULL) {\n\t\treturn SC_ERROR_OBJECT_NOT_FOUND;\n\t}\n\tpriv->key_id = COOLKEY_INVALID_KEY;\n\tif (coolkey_class(object_id) == COOLKEY_KEY_CLASS) {\n\t\tpriv->key_id = coolkey_get_key_id(object_id);\n\t}\n\tif (file_out) {\n\t\tfile = sc_file_new();\n\t\tif (file == NULL)\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t\tfile->path = *in_path;\n\t\tfile->type =  SC_PATH_TYPE_FILE_ID;\n\t\tfile->shareable = 0;\n\t\tfile->ef_structure = 0;\n\t\tfile->size = priv->obj->length;\n\t\t*file_out = file;\n\t}\n\treturn SC_SUCCESS;\n}", "target": 0}
{"code": "fbCombineConjointOverU (CARD32 *dest, const CARD32 *src, int width)\n{\n    fbCombineConjointGeneralU (dest, src, width, CombineAOver);\n}", "target": 0}
{"code": "SMB2_ioctl_free(struct smb_rqst *rqst)\n{\n\tif (rqst && rqst->rq_iov)\n\t\tcifs_small_buf_release(rqst->rq_iov[0].iov_base); \n}", "target": 0}
{"code": "static int ssl_compress_buf( mbedtls_ssl_context *ssl )\n{\n    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;\n    unsigned char *msg_post = ssl->out_msg;\n    ptrdiff_t bytes_written = ssl->out_msg - ssl->out_buf;\n    size_t len_pre = ssl->out_msglen;\n    unsigned char *msg_pre = ssl->compress_buf;\n#if defined(MBEDTLS_SSL_VARIABLE_BUFFER_LENGTH)\n    size_t out_buf_len = ssl->out_buf_len;\n#else\n    size_t out_buf_len = MBEDTLS_SSL_OUT_BUFFER_LEN;\n#endif\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"=> compress buf\" ) );\n    if( len_pre == 0 )\n        return( 0 );\n    memcpy( msg_pre, ssl->out_msg, len_pre );\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"before compression: msglen = %\" MBEDTLS_PRINTF_SIZET \", \",\n                   ssl->out_msglen ) );\n    MBEDTLS_SSL_DEBUG_BUF( 4, \"before compression: output payload\",\n                   ssl->out_msg, ssl->out_msglen );\n    ssl->transform_out->ctx_deflate.next_in = msg_pre;\n    ssl->transform_out->ctx_deflate.avail_in = len_pre;\n    ssl->transform_out->ctx_deflate.next_out = msg_post;\n    ssl->transform_out->ctx_deflate.avail_out = out_buf_len - bytes_written;\n    ret = deflate( &ssl->transform_out->ctx_deflate, Z_SYNC_FLUSH );\n    if( ret != Z_OK )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"failed to perform compression (%d)\", ret ) );\n        return( MBEDTLS_ERR_SSL_COMPRESSION_FAILED );\n    }\n    ssl->out_msglen = out_buf_len -\n                      ssl->transform_out->ctx_deflate.avail_out - bytes_written;\n    MBEDTLS_SSL_DEBUG_MSG( 3, ( \"after compression: msglen = %\" MBEDTLS_PRINTF_SIZET \", \",\n                   ssl->out_msglen ) );\n    MBEDTLS_SSL_DEBUG_BUF( 4, \"after compression: output payload\",\n                   ssl->out_msg, ssl->out_msglen );\n    MBEDTLS_SSL_DEBUG_MSG( 2, ( \"<= compress buf\" ) );\n    return( 0 );\n}", "target": 0}
{"code": "gather_time_entropy(void) {\n#  ifdef _WIN32\n  FILETIME ft;\n  GetSystemTimeAsFileTime(&ft); \n  return ft.dwHighDateTime ^ ft.dwLowDateTime;\n#  else\n  struct timeval tv;\n  int gettimeofday_res;\n  gettimeofday_res = gettimeofday(&tv, NULL);\n#    if defined(NDEBUG)\n  (void)gettimeofday_res;\n#    else\n  assert(gettimeofday_res == 0);\n#    endif \n  return tv.tv_usec;\n#  endif\n}", "target": 0}
{"code": "callbacks_change_layer_edit_clicked  (GtkButton *button, gpointer userData)\n{\n\tgint index = callbacks_get_selected_row_index();\n\tgerbv_fileinfo_t **files = mainProject->file;\n\tgerbv_user_transformation_t **transforms;\n\tint i, j;\n\tif (index < 0) {\n\t\tshow_no_layers_warning ();\n\t\treturn;\n\t}\n\ttransforms = g_new (gerbv_user_transformation_t *,\n\t\t\tmainProject->last_loaded +\n\t\t\t2  +\n\t\t\t1 );\n\ttransforms[0] = &mainProject->file[index]->transform;\n\tj = 1;\t\n\tfor (i = 0; i <= mainProject->last_loaded; i++) {\n\t\tif (files[i] && files[i]->isVisible)\n\t\t\ttransforms[j++] = &files[i]->transform;\n\t}\n\ttransforms[j] = NULL;\n\tinterface_show_layer_edit_dialog(transforms, screen.unit);\n\tg_free (transforms);\n\trender_refresh_rendered_image_on_screen ();\n\tcallbacks_update_layer_tree ();\t\n}", "target": 0}
{"code": "vim_mkdir_emsg(char_u *name, int prot UNUSED)\n{\n    if (vim_mkdir(name, prot) != 0)\n    {\n\tsemsg(_(\"E739: Cannot create directory: %s\"), name);\n\treturn FAIL;\n    }\n    return OK;\n}", "target": 0}
{"code": "static int ssl_parse_renegotiation_info( mbedtls_ssl_context *ssl,\n                                         const unsigned char *buf,\n                                         size_t len )\n{\n#if defined(MBEDTLS_SSL_RENEGOTIATION)\n    if( ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE )\n    {\n        if( len    != 1 + ssl->verify_data_len * 2 ||\n            buf[0] !=     ssl->verify_data_len * 2 ||\n            mbedtls_ssl_safer_memcmp( buf + 1,\n                          ssl->own_verify_data, ssl->verify_data_len ) != 0 ||\n            mbedtls_ssl_safer_memcmp( buf + 1 + ssl->verify_data_len,\n                          ssl->peer_verify_data, ssl->verify_data_len ) != 0 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"non-matching renegotiation info\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n        }\n    }\n    else\n#endif \n    {\n        if( len != 1 || buf[0] != 0x00 )\n        {\n            MBEDTLS_SSL_DEBUG_MSG( 1, ( \"non-zero length renegotiation info\" ) );\n            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                            MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );\n            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_HELLO );\n        }\n        ssl->secure_renegotiation = MBEDTLS_SSL_SECURE_RENEGOTIATION;\n    }\n    return( 0 );\n}", "target": 0}
{"code": "static bool dl_param_changed(struct task_struct *p,\n\t\tconst struct sched_attr *attr)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\tif (dl_se->dl_runtime != attr->sched_runtime ||\n\t\tdl_se->dl_deadline != attr->sched_deadline ||\n\t\tdl_se->dl_period != attr->sched_period ||\n\t\tdl_se->flags != attr->sched_flags)\n\t\treturn true;\n\treturn false;\n}", "target": 0}
{"code": "get_use_pkg(Token *t, const char *dname, const char **name)\n{\n    const char *id;\n    t = skip_white(t);\n    t = expand_smacro(t);\n    *name = NULL;\n    if (!t) {\n        nasm_nonfatal(\"`%s' expects a package name, got end of line\", dname);\n        return NULL;\n    } else if (t->type != TOK_ID && t->type != TOK_STRING) {\n        nasm_nonfatal(\"`%s' expects a package name, got `%s'\",\n                      dname, tok_text(t));\n        return NULL;\n    }\n    *name = id = unquote_token(t);\n    t = t->next;\n    t = skip_white(t);\n    if (t)\n        nasm_warn(WARN_OTHER, \"trailing garbage after `%s' ignored\", dname);\n    return nasm_find_use_package(id);\n}", "target": 0}
{"code": "GF_Err akey_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_full_box_write(s, bs);\n}", "target": 0}
{"code": "\tvirtual const char *name() const { return \"expand3to4\"; }", "target": 0}
{"code": "    CiffComponent* CiffComponent::add(CrwDirs& crwDirs, uint16_t crwTagId)\n    {\n        return doAdd(crwDirs, crwTagId);\n    }", "target": 0}
{"code": "static void emulator_set_cached_descriptor(struct desc_struct *desc, int seg,\n\t\t\t\t\t   struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment var;\n\tkvm_get_segment(vcpu, &var, seg);\n\tvar.base = get_desc_base(desc);\n\tvar.limit = get_desc_limit(desc);\n\tif (desc->g)\n\t\tvar.limit = (var.limit << 12) | 0xfff;\n\tvar.type = desc->type;\n\tvar.present = desc->p;\n\tvar.dpl = desc->dpl;\n\tvar.db = desc->d;\n\tvar.s = desc->s;\n\tvar.l = desc->l;\n\tvar.g = desc->g;\n\tvar.avl = desc->avl;\n\tvar.present = desc->p;\n\tvar.unusable = !var.present;\n\tvar.padding = 0;\n\tkvm_set_segment(vcpu, &var, seg);\n\treturn;\n}", "target": 0}
{"code": "static LayoutPoint CornerPointOfRect(LayoutRect rect, Corner which_corner) {\n  switch (which_corner) {\n    case Corner::kTopLeft:\n      return rect.MinXMinYCorner();\n    case Corner::kTopRight:\n      return rect.MaxXMinYCorner();\n  }\n  NOTREACHED();\n  return LayoutPoint();\n}", "target": 0}
{"code": "static int nsim_bpf_translate(struct bpf_prog *prog)\n{\n\tstruct nsim_bpf_bound_prog *state = prog->aux->offload->dev_priv;\n\tstate->state = \"xlated\";\n\treturn 0;\n}", "target": 0}
{"code": "unsigned lodepng_is_greyscale_type(const LodePNGColorMode* info)\n{\n  return info->colortype == LCT_GREY || info->colortype == LCT_GREY_ALPHA;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, OrEnumerationLimit) {\n    params.options = QueryPlannerParams::NO_TABLE_SCAN;\n    addIndex(BSON(\"a\" << 1));\n    addIndex(BSON(\"b\" << 1));\n    runQuery(\n        fromjson(\"{$or: [{a: 1, b: 1},\"\n                 \"{a: 2, b: 2},\"\n                 \"{a: 3, b: 3},\"\n                 \"{a: 4, b: 4},\"\n                 \"{a: 5, b: 5},\"\n                 \"{a: 6, b: 6}]}\"));\n    assertNumSolutions(internalQueryEnumerationMaxOrSolutions.load());\n}", "target": 0}
{"code": "void LibRaw::ppm16_thumb()\n{\n  int i;\n  char *thumb;\n  thumb_length = thumb_width * thumb_height * 3;\n  thumb = (char *)calloc(thumb_length, 2);\n  merror(thumb, \"ppm16_thumb()\");\n  read_shorts((ushort *)thumb, thumb_length);\n  for (i = 0; i < thumb_length; i++)\n    thumb[i] = ((ushort *)thumb)[i] >> 8;\n  fprintf(ofp, \"P6\\n%d %d\\n255\\n\", thumb_width, thumb_height);\n  fwrite(thumb, 1, thumb_length, ofp);\n  free(thumb);\n}", "target": 0}
{"code": "AP_DECLARE(int) ap_sys_privileges_handlers(int inc)\n{\n    sys_privileges += inc;\n    return sys_privileges;\n}", "target": 0}
{"code": "check_SET_IP_DSCP(const struct ofpact_dscp *a OVS_UNUSED,\n                  struct ofpact_check_params *cp)\n{\n    return check_set_ip(cp);\n}", "target": 0}
{"code": "double ensure_font_size(ASS_Renderer *priv, double size)\n{\n    if (size < 1)\n        size = 1;\n    else if (size > priv->height * 2)\n        size = priv->height * 2;\n    return size;\n}", "target": 0}
{"code": "void tipc_node_apply_property(struct net *net, struct tipc_bearer *b,\n\t\t\t      int prop)\n{\n\tstruct tipc_net *tn = tipc_net(net);\n\tint bearer_id = b->identity;\n\tstruct sk_buff_head xmitq;\n\tstruct tipc_link_entry *e;\n\tstruct tipc_node *n;\n\t__skb_queue_head_init(&xmitq);\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(n, &tn->node_list, list) {\n\t\ttipc_node_write_lock(n);\n\t\te = &n->links[bearer_id];\n\t\tif (e->link) {\n\t\t\tif (prop == TIPC_NLA_PROP_TOL)\n\t\t\t\ttipc_link_set_tolerance(e->link, b->tolerance,\n\t\t\t\t\t\t\t&xmitq);\n\t\t\telse if (prop == TIPC_NLA_PROP_MTU)\n\t\t\t\ttipc_link_set_mtu(e->link, b->mtu);\n\t\t\te->mtu = tipc_link_mss(e->link);\n\t\t}\n\t\ttipc_node_write_unlock(n);\n\t\ttipc_bearer_xmit(net, bearer_id, &xmitq, &e->maddr, NULL);\n\t}\n\trcu_read_unlock();\n}", "target": 0}
{"code": "static void vgacon_save_screen(struct vc_data *c)\n{\n\tstatic int vga_bootup_console = 0;\n\tif (!vga_bootup_console) {\n\t\tvga_bootup_console = 1;\n\t\tc->state.x = screen_info.orig_x;\n\t\tc->state.y = screen_info.orig_y;\n\t}\n\tif (!vga_is_gfx)\n\t\tscr_memcpyw((u16 *) c->vc_screenbuf, (u16 *) c->vc_origin,\n\t\t\t    c->vc_screenbuf_size > vga_vram_size ? vga_vram_size : c->vc_screenbuf_size);\n}", "target": 0}
{"code": "static void xennet_make_one_txreq(unsigned long gfn, unsigned int offset,\n\t\t\t\t  unsigned int len, void *data)\n{\n\tstruct xennet_gnttab_make_txreq *info = data;\n\tinfo->tx->flags |= XEN_NETTXF_more_data;\n\tskb_get(info->skb);\n\txennet_tx_setup_grant(gfn, offset, len, data);\n}", "target": 0}
{"code": "static int clear_refs_pte_range(pmd_t *pmd, unsigned long addr,\n\t\t\t\tunsigned long end, void *private)\n{\n\tstruct vm_area_struct *vma = private;\n\tpte_t *pte, ptent;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\tfor (; addr != end; pte++, addr += PAGE_SIZE) {\n\t\tptent = *pte;\n\t\tif (!pte_present(ptent))\n\t\t\tcontinue;\n\t\tpage = vm_normal_page(vma, addr, ptent);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tptep_test_and_clear_young(vma, addr, pte);\n\t\tClearPageReferenced(page);\n\t}\n\tpte_unmap_unlock(pte - 1, ptl);\n\tcond_resched();\n\treturn 0;\n}", "target": 0}
{"code": "extract_tag_der_recursive(asn1_node node, const unsigned char *der, int der_len,\n\t\t       int *ret_len, unsigned flags)\n{\nasn1_node p;\nint ris = ASN1_DER_ERROR;\n  if (type_field (node->type) == ASN1_ETYPE_CHOICE)\n    {\n      p = node->down;\n      while (p)\n        {\n          ris = _asn1_extract_tag_der (p, der, der_len, ret_len, flags);\n          if (ris == ASN1_SUCCESS)\n            break;\n          p = p->right;\n\t}\n      *ret_len = 0;\n      return ris;\n    }\n  else\n    return _asn1_extract_tag_der (node, der, der_len, ret_len, flags);\n}", "target": 0}
{"code": "get_name_end_code_point(OnigCodePoint start)\n{\n  switch (start) {\n  case '<':  return (OnigCodePoint )'>'; break;\n  case '\\'': return (OnigCodePoint )'\\''; break;\n  case '(':  return (OnigCodePoint )')'; break;\n  case '{':  return (OnigCodePoint )'}'; break;\n  default:\n    break;\n  }\n  return (OnigCodePoint )0;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, GreaterThanEqual) {\n    addIndex(BSON(\"x\" << 1));\n    runQuery(BSON(\"x\" << BSON(\"$gte\" << 5)));\n    ASSERT_EQUALS(getNumSolutions(), 2U);\n    assertSolutionExists(\"{cscan: {dir: 1, filter: {x: {$gte: 5}}}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: {ixscan: \"\n        \"{filter: null, pattern: {x: 1}}}}}\");\n}", "target": 0}
{"code": "KCleanup::expandVariables( const KFileInfo *\titem,\n\t\t\t   const QString &\tunexpanded ) const\n{\n    QString expanded = unexpanded;\n    QString url = QString::fromLocal8Bit( item->url() ).replace(\"'\", \"'\\\\''\");\n    expanded.replace( QRegExp( \"%p\" ), \"'\" + url + \"'\" );\n    QString name = QString::fromLocal8Bit( item->name() ).replace(\"'\", \"'\\\\''\");\n    expanded.replace( QRegExp( \"%n\" ), \"'\" + name + \"'\" );\n\texpanded.replace( QRegExp( \"%t\" ), \"trash:/\" );\n    return expanded;\n}", "target": 0}
{"code": "static inline struct kvm_ioapic *to_ioapic(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_ioapic, dev);\n}", "target": 0}
{"code": "static inline void init_reserved_page(unsigned long pfn)\n{\n}", "target": 0}
{"code": "void FrameLoader::closeAndRemoveChild(Frame* child)\n{\n    child->tree()->detachFromParent();\n    child->setView(0);\n    if (child->ownerElement() && child->page())\n        child->page()->decrementSubframeCount();\n    child->willDetachPage();\n    child->detachFromPage();\n    m_frame->tree()->removeChild(child);\n}", "target": 0}
{"code": "InstanceKlass* InstanceKlass::allocate_instance_klass(const ClassFileParser& parser, TRAPS) {\n  const int size = InstanceKlass::size(parser.vtable_size(),\n                                       parser.itable_size(),\n                                       nonstatic_oop_map_size(parser.total_oop_map_count()),\n                                       parser.is_interface(),\n                                       parser.is_anonymous(),\n                                       should_store_fingerprint(parser.is_anonymous()));\n  const Symbol* const class_name = parser.class_name();\n  assert(class_name != NULL, \"invariant\");\n  ClassLoaderData* loader_data = parser.loader_data();\n  assert(loader_data != NULL, \"invariant\");\n  InstanceKlass* ik;\n  if (REF_NONE == parser.reference_type()) {\n    if (class_name == vmSymbols::java_lang_Class()) {\n      ik = new (loader_data, size, THREAD) InstanceMirrorKlass(parser);\n    }\n    else if (is_class_loader(class_name, parser)) {\n      ik = new (loader_data, size, THREAD) InstanceClassLoaderKlass(parser);\n    } else {\n      ik = new (loader_data, size, THREAD) InstanceKlass(parser, InstanceKlass::_misc_kind_other);\n    }\n  } else {\n    ik = new (loader_data, size, THREAD) InstanceRefKlass(parser);\n  }\n  if (HAS_PENDING_EXCEPTION) {\n    return NULL;\n  }\n  return ik;\n}", "target": 0}
{"code": "    void Image::setComment(const std::string& comment)\n    {\n        comment_ = comment;\n    }", "target": 0}
{"code": "bool InstanceKlass::has_as_permitted_subclass(const InstanceKlass* k) const {\n  Thread* current = Thread::current();\n  assert(k != NULL, \"sanity check\");\n  assert(_permitted_subclasses != NULL && _permitted_subclasses != Universe::the_empty_short_array(),\n         \"unexpected empty _permitted_subclasses array\");\n  if (log_is_enabled(Trace, class, sealed)) {\n    ResourceMark rm(current);\n    log_trace(class, sealed)(\"Checking for permitted subclass of %s in %s\",\n                             k->external_name(), this->external_name());\n  }\n  if (k->module() != this->module()) {\n    ResourceMark rm(current);\n    log_trace(class, sealed)(\"Check failed for same module of permitted subclass %s and sealed class %s\",\n                             k->external_name(), this->external_name());\n    return false;\n  }\n  if (!k->is_public() && !is_same_class_package(k)) {\n    ResourceMark rm(current);\n    log_trace(class, sealed)(\"Check failed, subclass %s not public and not in the same package as sealed class %s\",\n                             k->external_name(), this->external_name());\n    return false;\n  }\n  for (int i = 0; i < _permitted_subclasses->length(); i++) {\n    int cp_index = _permitted_subclasses->at(i);\n    Symbol* name = _constants->klass_name_at(cp_index);\n    if (name == k->name()) {\n      log_trace(class, sealed)(\"- Found it at permitted_subclasses[%d] => cp[%d]\", i, cp_index);\n      return true;\n    }\n  }\n  log_trace(class, sealed)(\"- class is NOT a permitted subclass!\");\n  return false;\n}", "target": 0}
{"code": "irc_server_get_default_msg (const char *default_msg,\n                            struct t_irc_server *server,\n                            const char *channel_name)\n{\n    char *version;\n    struct t_hashtable *extra_vars;\n    char *msg, *res;\n    if (strstr (default_msg, \"%v\") && !strstr (default_msg, \"${\"))\n    {\n        version = weechat_info_get (\"version\", \"\");\n        res = weechat_string_replace (default_msg, \"%v\",\n                                      (version) ? version : \"\");\n        if (version)\n            free (version);\n        return res;\n    }\n    extra_vars = weechat_hashtable_new (32,\n                                        WEECHAT_HASHTABLE_STRING,\n                                        WEECHAT_HASHTABLE_STRING,\n                                        NULL,\n                                        NULL);\n    if (extra_vars)\n    {\n        weechat_hashtable_set (extra_vars, \"server\", server->name);\n        weechat_hashtable_set (extra_vars, \"channel\",\n                               (channel_name) ? channel_name : \"\");\n        weechat_hashtable_set (extra_vars, \"nick\", server->nick);\n    }\n    msg = weechat_string_eval_expression (default_msg, NULL, extra_vars, NULL);\n    if (extra_vars)\n        weechat_hashtable_free (extra_vars);\n    return msg;\n}", "target": 0}
{"code": "static inline void context_set_present(struct context_entry *context)\n{\n\tcontext->lo |= 1;\n}", "target": 0}
{"code": "static int sco_sock_connect(struct socket *sock, struct sockaddr *addr, int alen, int flags)\n{\n\tstruct sockaddr_sco *sa = (struct sockaddr_sco *) addr;\n\tstruct sock *sk = sock->sk;\n\tstruct hci_dev  *hdev;\n\tint err;\n\tBT_DBG(\"sk %p\", sk);\n\tif (alen < sizeof(struct sockaddr_sco) ||\n\t    addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\tif (sk->sk_state != BT_OPEN && sk->sk_state != BT_BOUND)\n\t\treturn -EBADFD;\n\tif (sk->sk_type != SOCK_SEQPACKET)\n\t\treturn -EINVAL;\n\thdev = hci_get_route(&sa->sco_bdaddr, &sco_pi(sk)->src, BDADDR_BREDR);\n\tif (!hdev)\n\t\treturn -EHOSTUNREACH;\n\thci_dev_lock(hdev);\n\tlock_sock(sk);\n\tbacpy(&sco_pi(sk)->dst, &sa->sco_bdaddr);\n\terr = sco_connect(hdev, sk);\n\thci_dev_unlock(hdev);\n\thci_dev_put(hdev);\n\tif (err)\n\t\tgoto done;\n\terr = bt_sock_wait_state(sk, BT_CONNECTED,\n\t\t\t\t sock_sndtimeo(sk, flags & O_NONBLOCK));\ndone:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "int EC_GROUP_get_basis_type(const EC_GROUP *group)\n{\n    int i = 0;\n    if (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) !=\n        NID_X9_62_characteristic_two_field)\n        return 0;\n    while (group->poly[i] != 0)\n        i++;\n    if (i == 4)\n        return NID_X9_62_ppBasis;\n    else if (i == 2)\n        return NID_X9_62_tpBasis;\n    else\n        return 0;\n}", "target": 0}
{"code": "static Bool check_task_list_enum(void *udta, void *item)\n{\n\tassert(udta != item);\n\treturn GF_FALSE;\n}", "target": 0}
{"code": "node_new_update_var_gimmick(Node** node, enum UpdateVarType update_var_type,\n                            int id, ScanEnv* env)\n{\n  *node = node_new();\n  CHECK_NULL_RETURN_MEMERR(*node);\n  NODE_SET_TYPE(*node, NODE_GIMMICK);\n  GIMMICK_(*node)->id   = id;\n  GIMMICK_(*node)->type = GIMMICK_UPDATE_VAR;\n  GIMMICK_(*node)->detail_type = (int )update_var_type;\n  return ONIG_NORMAL;\n}", "target": 0}
{"code": "attrhash_key_make (void *p)\n{\n  const struct attr * attr = (struct attr *) p;\n  uint32_t key = 0;\n#define MIX(val)\tkey = jhash_1word(val, key)\n  MIX(attr->origin);\n  MIX(attr->nexthop.s_addr);\n  MIX(attr->med);\n  MIX(attr->local_pref);\n  key += attr->origin;\n  key += attr->nexthop.s_addr;\n  key += attr->med;\n  key += attr->local_pref;\n  if (attr->extra)\n    {\n      MIX(attr->extra->aggregator_as);\n      MIX(attr->extra->aggregator_addr.s_addr);\n      MIX(attr->extra->weight);\n      MIX(attr->extra->mp_nexthop_global_in.s_addr);\n    }\n  if (attr->aspath)\n    MIX(aspath_key_make (attr->aspath));\n  if (attr->community)\n    MIX(community_hash_make (attr->community));\n  if (attr->extra)\n    {\n      if (attr->extra->ecommunity)\n        MIX(ecommunity_hash_make (attr->extra->ecommunity));\n      if (attr->extra->cluster)\n        MIX(cluster_hash_key_make (attr->extra->cluster));\n      if (attr->extra->transit)\n        MIX(transit_hash_key_make (attr->extra->transit));\n#ifdef HAVE_IPV6\n      MIX(attr->extra->mp_nexthop_len);\n      key = jhash(attr->extra->mp_nexthop_global.s6_addr, 16, key);\n      key = jhash(attr->extra->mp_nexthop_local.s6_addr, 16, key);\n#endif \n    }\n  return key;\n}", "target": 0}
{"code": "_asn1_hierarchical_name (asn1_node node, char *name, int name_size)\n{\n  asn1_node p;\n  char tmp_name[64];\n  p = node;\n  name[0] = 0;\n  while (p != NULL)\n    {\n      if (p->name[0] != 0)\n\t{\n\t  _asn1_str_cpy (tmp_name, sizeof (tmp_name), name),\n\t    _asn1_str_cpy (name, name_size, p->name);\n\t  _asn1_str_cat (name, name_size, \".\");\n\t  _asn1_str_cat (name, name_size, tmp_name);\n\t}\n      p = _asn1_find_up (p);\n    }\n  if (name[0] == 0)\n    _asn1_str_cpy (name, name_size, \"ROOT\");\n}", "target": 0}
{"code": "inline int task_curr(const struct task_struct *p)\n{\n\treturn cpu_curr(task_cpu(p)) == p;\n}", "target": 0}
{"code": "  void setReferenceInline(Handle handle, absl::string_view value) override {\n    header_map_->setReferenceInline(handle, value);\n    header_map_->verifyByteSizeInternalForTest();\n  }", "target": 0}
{"code": "  bool WasAutoplayInitiated() { return Media()->WasAutoplayInitiated(); }", "target": 0}
{"code": "bool Item_param::set_from_user_var(THD *thd, const user_var_entry *entry)\n{\n  DBUG_ENTER(\"Item_param::set_from_user_var\");\n  if (entry && entry->value)\n  {\n    item_result_type= entry->type;\n    unsigned_flag= entry->unsigned_flag;\n    if (limit_clause_param)\n    {\n      bool unused;\n      set_int(entry->val_int(&unused), MY_INT64_NUM_DECIMAL_DIGITS);\n      item_type= Item::INT_ITEM;\n      DBUG_RETURN(!unsigned_flag && value.integer < 0 ? 1 : 0);\n    }\n    switch (item_result_type) {\n    case REAL_RESULT:\n      set_double(*(double*)entry->value);\n      item_type= Item::REAL_ITEM;\n      param_type= MYSQL_TYPE_DOUBLE;\n      break;\n    case INT_RESULT:\n      set_int(*(longlong*)entry->value, MY_INT64_NUM_DECIMAL_DIGITS);\n      item_type= Item::INT_ITEM;\n      param_type= MYSQL_TYPE_LONGLONG;\n      break;\n    case STRING_RESULT:\n    {\n      CHARSET_INFO *fromcs= entry->collation.collation;\n      CHARSET_INFO *tocs= thd->variables.collation_connection;\n      uint32 dummy_offset;\n      value.cs_info.character_set_of_placeholder= fromcs;\n      value.cs_info.character_set_client= thd->variables.character_set_client;\n      value.cs_info.final_character_set_of_str_value=\n        String::needs_conversion(0, fromcs, tocs, &dummy_offset) ?\n        tocs : fromcs;\n      item_type= Item::STRING_ITEM;\n      param_type= MYSQL_TYPE_VARCHAR;\n      if (set_str((const char *)entry->value, entry->length))\n        DBUG_RETURN(1);\n      break;\n    }\n    case DECIMAL_RESULT:\n    {\n      const my_decimal *ent_value= (const my_decimal *)entry->value;\n      my_decimal2decimal(ent_value, &decimal_value);\n      state= DECIMAL_VALUE;\n      decimals= ent_value->frac;\n      max_length=\n        my_decimal_precision_to_length_no_truncation(ent_value->precision(),\n                                                     decimals, unsigned_flag);\n      item_type= Item::DECIMAL_ITEM;\n      param_type= MYSQL_TYPE_NEWDECIMAL;\n      break;\n    }\n    case ROW_RESULT:\n    case TIME_RESULT:\n    case IMPOSSIBLE_RESULT:\n      DBUG_ASSERT(0);\n      set_null();\n    }\n  }\n  else\n    set_null();\n  DBUG_RETURN(0);\n}", "target": 0}
{"code": "static inline void pi_set_sn(struct pi_desc *pi_desc)\n{\n\treturn set_bit(POSTED_INTR_SN,\n\t\t\t(unsigned long *)&pi_desc->control);\n}", "target": 0}
{"code": "void AccessibilityUIElement::getChildrenWithRange(Vector<RefPtr<AccessibilityUIElement> >& children, unsigned location, unsigned length)\n{\n    if (!m_element || !ATK_IS_OBJECT(m_element))\n        return;\n    unsigned end = location + length;\n    for (unsigned i = location; i < end; i++) {\n        AtkObject* child = atk_object_ref_accessible_child(ATK_OBJECT(m_element), i);\n        children.append(AccessibilityUIElement::create(child));\n    }\n}", "target": 0}
{"code": "NCR_AddBroadcastDestination(IPAddr *addr, unsigned short port, int interval)\n{\n  BroadcastDestination *destination;\n  destination = (BroadcastDestination *)ARR_GetNewElement(broadcasts);\n  destination->addr.ip_addr = *addr;\n  destination->addr.port = port;\n  destination->local_addr.ip_addr.family = IPADDR_UNSPEC;\n  destination->local_addr.sock_fd = NIO_OpenServerSocket(&destination->addr);\n  destination->interval = interval;\n  SCH_AddTimeoutInClass(destination->interval, SAMPLING_SEPARATION, SAMPLING_RANDOMNESS,\n                        SCH_NtpBroadcastClass, broadcast_timeout,\n                        (void *)(long)(ARR_GetSize(broadcasts) - 1));\n}", "target": 0}
{"code": "static ssize_t carrier_store(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t len)\n{\n\treturn netdev_store(dev, attr, buf, len, change_carrier);", "target": 0}
{"code": "static int pagemap_pte_hole(unsigned long start, unsigned long end,\n\t\t\t\tvoid *private)\n{\n\tstruct pagemapread *pm = private;\n\tunsigned long addr;\n\tint err = 0;\n\tfor (addr = start; addr < end; addr += PAGE_SIZE) {\n\t\terr = add_to_pagemap(addr, PM_NOT_PRESENT, pm);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\treturn err;\n}", "target": 0}
{"code": "static void virtio_net_set_multiqueue(VirtIONet *n, int multiqueue)\n{\n    int max = multiqueue ? n->max_queues : 1;\n    n->multiqueue = multiqueue;\n    virtio_net_change_num_queues(n, max);\n    virtio_net_set_queues(n);\n}", "target": 0}
{"code": "static void kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     struct kvm_debugregs *dbgregs)\n{\n\tunsigned long val;\n\tmemcpy(dbgregs->db, vcpu->arch.db, sizeof(vcpu->arch.db));\n\t_kvm_get_dr(vcpu, 6, &val);\n\tdbgregs->dr6 = val;\n\tdbgregs->dr7 = vcpu->arch.dr7;\n\tdbgregs->flags = 0;\n\tmemset(&dbgregs->reserved, 0, sizeof(dbgregs->reserved));\n}", "target": 0}
{"code": "static inline int skcipher_sndbuf(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\treturn max_t(int, max_t(int, sk->sk_sndbuf & PAGE_MASK, PAGE_SIZE) -\n\t\t\t  ctx->used, 0);\n}", "target": 0}
{"code": "cliprdr_send_packet(uint16 type, uint16 status, uint8 * data, uint32 length)\n{\n\tSTREAM s;\n\tDEBUG_CLIPBOARD((\"CLIPRDR send: type=%d, status=%d, length=%d\\n\", type, status, length));\n\ts = channel_init(cliprdr_channel, length + 12);\n\tout_uint16_le(s, type);\n\tout_uint16_le(s, status);\n\tout_uint32_le(s, length);\n\tout_uint8p(s, data, length);\n\tout_uint32(s, 0);\t\n\ts_mark_end(s);\n\tchannel_send(s, cliprdr_channel);\n}", "target": 0}
{"code": "ff_lseg_merge(struct pnfs_layout_segment *new,\n\t\tstruct pnfs_layout_segment *old)\n{\n\tu64 new_end, old_end;\n\tif (test_bit(NFS_LSEG_LAYOUTRETURN, &old->pls_flags))\n\t\treturn false;\n\tif (new->pls_range.iomode != old->pls_range.iomode)\n\t\treturn false;\n\told_end = pnfs_calc_offset_end(old->pls_range.offset,\n\t\t\told->pls_range.length);\n\tif (old_end < new->pls_range.offset)\n\t\treturn false;\n\tnew_end = pnfs_calc_offset_end(new->pls_range.offset,\n\t\t\tnew->pls_range.length);\n\tif (new_end < old->pls_range.offset)\n\t\treturn false;\n\tif (!ff_lseg_match_mirrors(new, old))\n\t\treturn false;\n\tif (new_end < old_end)\n\t\tnew_end = old_end;\n\tif (new->pls_range.offset < old->pls_range.offset)\n\t\tnew->pls_range.offset = old->pls_range.offset;\n\tnew->pls_range.length = pnfs_calc_offset_length(new->pls_range.offset,\n\t\t\tnew_end);\n\tif (test_bit(NFS_LSEG_ROC, &old->pls_flags))\n\t\tset_bit(NFS_LSEG_ROC, &new->pls_flags);\n\treturn true;\n}", "target": 0}
{"code": "DH *ssl_get_auto_dh(SSL *s)\n\t{\n\tint dh_secbits = 80;\n\tif (s->cert->dh_tmp_auto == 2)\n\t\treturn DH_get_1024_160();\n\tif (s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL)\n\t\t{\n\t\tif (s->s3->tmp.new_cipher->strength_bits == 256)\n\t\t\tdh_secbits = 128;\n\t\telse\n\t\t\tdh_secbits = 80;\n\t\t}\n\telse\n\t\t{\n\t\tCERT_PKEY *cpk = ssl_get_server_send_pkey(s);\n\t\tdh_secbits = EVP_PKEY_security_bits(cpk->privatekey);\n\t\t}\n\tif (dh_secbits >= 128)\n\t\t{\n\t\tDH *dhp = DH_new();\n\t\tif (!dhp)\n\t\t\treturn NULL;\n\t\tdhp->g = BN_new();\n\t\tif (dhp->g)\n\t\t\tBN_set_word(dhp->g, 2);\n\t\tif (dh_secbits >= 192)\n\t\t\tdhp->p = get_rfc3526_prime_8192(NULL);\n\t\telse\n\t\t\tdhp->p = get_rfc3526_prime_3072(NULL);\n\t\tif (!dhp->p || !dhp->g)\n\t\t\t{\n\t\t\tDH_free(dhp);\n\t\t\treturn NULL;\n\t\t\t}\n\t\treturn dhp;\n\t\t}\n\tif (dh_secbits >= 112)\n\t\treturn DH_get_2048_224();\n\treturn DH_get_1024_160();\n\t}", "target": 0}
{"code": "bool HTMLMediaElement::SupportsLoop() const {\n  if (GetLoadType() == WebMediaPlayer::kLoadTypeMediaStream)\n    return false;\n  if (duration() == std::numeric_limits<double>::infinity())\n    return false;\n  return true;\n}", "target": 0}
{"code": "  virtual bool ethernet_enabled() const { return true; }", "target": 0}
{"code": "    size_t OlympusMnHeader::size() const\n    {\n        return header_.size_;\n    }", "target": 0}
{"code": "static int mce_usable_address(struct mce *m)\n{\n\tif (!(m->status & MCI_STATUS_ADDRV))\n\t\treturn 0;\n\tif (boot_cpu_data.x86_vendor != X86_VENDOR_INTEL)\n\t\treturn 1;\n\tif (!(m->status & MCI_STATUS_MISCV))\n\t\treturn 0;\n\tif (MCI_MISC_ADDR_LSB(m->misc) > PAGE_SHIFT)\n\t\treturn 0;\n\tif (MCI_MISC_ADDR_MODE(m->misc) != MCI_MISC_ADDR_PHYS)\n\t\treturn 0;\n\treturn 1;\n}", "target": 0}
{"code": "virSecuritySELinuxMoveImageMetadataHelper(pid_t pid G_GNUC_UNUSED,\n                                          void *opaque)\n{\n    struct virSecuritySELinuxMoveImageMetadataData *data = opaque;\n    const char *paths[2] = { data->src, data->dst };\n    virSecurityManagerMetadataLockState *state;\n    int ret;\n    if (!(state = virSecurityManagerMetadataLock(data->mgr, paths, G_N_ELEMENTS(paths))))\n        return -1;\n    ret = virSecurityMoveRememberedLabel(SECURITY_SELINUX_NAME, data->src, data->dst);\n    virSecurityManagerMetadataUnlock(data->mgr, &state);\n    if (ret == -2) {\n        ret = 0;\n    }\n    return ret;\n}", "target": 0}
{"code": "void zmq::stream_engine_t::plug (io_thread_t *io_thread_,\n    session_base_t *session_)\n{\n    zmq_assert (!plugged);\n    plugged = true;\n    zmq_assert (!session);\n    zmq_assert (session_);\n    session = session_;\n    socket = session-> get_socket ();\n    io_object_t::plug (io_thread_);\n    handle = add_fd (s);\n    io_error = false;\n    if (options.raw_sock) {\n        encoder = new (std::nothrow) raw_encoder_t (out_batch_size);\n        alloc_assert (encoder);\n        decoder = new (std::nothrow) raw_decoder_t (in_batch_size);\n        alloc_assert (decoder);\n        handshaking = false;\n        next_msg = &stream_engine_t::pull_msg_from_session;\n        process_msg = &stream_engine_t::push_msg_to_session;\n        msg_t connector;\n        connector.init();\n        push_msg_to_session (&connector);\n        connector.close();\n        session->flush ();\n    }\n    else {\n        set_handshake_timer ();\n        outpos = greeting_send;\n        outpos [outsize++] = 0xff;\n        put_uint64 (&outpos [outsize], options.identity_size + 1);\n        outsize += 8;\n        outpos [outsize++] = 0x7f;\n    }\n    set_pollin (handle);\n    set_pollout (handle);\n    in_event ();\n}", "target": 0}
{"code": "static ZIPARCHIVE_METHOD(statIndex)\n{\n\tstruct zip *intern;\n\tzval *this = getThis();\n\tlong index, flags = 0;\n\tstruct zip_stat sb;\n\tif (!this) {\n\t\tRETURN_FALSE;\n\t}\n\tZIP_FROM_OBJECT(intern, this);\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l|l\",\n\t\t\t&index, &flags) == FAILURE) {\n\t\treturn;\n\t}\n\tif (zip_stat_index(intern, index, flags, &sb) != 0) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_SB(&sb);\n}", "target": 0}
{"code": "void DefaultAudioDestinationHandler::StopPlatformDestination() {\n  if (platform_destination_->IsPlaying()) {\n    platform_destination_->Stop();\n  }\n}", "target": 0}
{"code": "int finish_open(struct file *file, struct dentry *dentry,\n\t\tint (*open)(struct inode *, struct file *),\n\t\tint *opened)\n{\n\tint error;\n\tBUG_ON(*opened & FILE_OPENED); \n\tfile->f_path.dentry = dentry;\n\terror = do_dentry_open(file, open, current_cred());\n\tif (!error)\n\t\t*opened |= FILE_OPENED;\n\treturn error;\n}", "target": 0}
{"code": "static int verify_headers(const void *data, unsigned long size,\n\t\t\t  struct object *obj, struct fsck_options *options)\n{\n\tconst char *buffer = (const char *)data;\n\tunsigned long i;\n\tfor (i = 0; i < size; i++) {\n\t\tswitch (buffer[i]) {\n\t\tcase '\\0':\n\t\t\treturn report(options, obj,\n\t\t\t\tFSCK_MSG_NUL_IN_HEADER,\n\t\t\t\t\"unterminated header: NUL at offset %ld\", i);\n\t\tcase '\\n':\n\t\t\tif (i + 1 < size && buffer[i + 1] == '\\n')\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\tif (size && buffer[size - 1] == '\\n')\n\t\treturn 0;\n\treturn report(options, obj,\n\t\tFSCK_MSG_UNTERMINATED_HEADER, \"unterminated header\");\n}", "target": 0}
{"code": "gdImagePtr gdImageScaleTwoPass(const gdImagePtr src, const unsigned int src_width, const unsigned int src_height, const unsigned int new_width, const unsigned int new_height)\n{\n\tgdImagePtr tmp_im;\n\tgdImagePtr dst;\n\ttmp_im = gdImageCreateTrueColor(new_width, src_height);\n\tif (tmp_im == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageSetInterpolationMethod(tmp_im, src->interpolation_id);\n\t_gdScaleHoriz(src, src_width, src_height, tmp_im, new_width, src_height);\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (dst == NULL) {\n\t\tgdFree(tmp_im);\n\t\treturn NULL;\n\t}\n\tgdImageSetInterpolationMethod(dst, src->interpolation_id);\n\t_gdScaleVert(tmp_im, new_width, src_height, dst, new_width, new_height);\n\tgdFree(tmp_im);\n\treturn dst;\n}", "target": 0}
{"code": "free_entry (IconEntry *icon)\n{\n\tg_free (icon->colors);\n\tg_free (icon->and);\n\tg_free (icon->xor);\n\tg_free (icon);\n}", "target": 0}
{"code": "cmd_random (assuan_context_t ctx, char *line)\n{\n  ctrl_t ctrl = assuan_get_pointer (ctx);\n  int rc;\n  size_t nbytes;\n  unsigned char *buffer;\n  if (!*line)\n    return set_error (GPG_ERR_ASS_PARAMETER,\n                      \"number of requested bytes missing\");\n  nbytes = strtoul (line, NULL, 0);\n  if ((rc = open_card (ctrl, NULL)))\n    return rc;\n  if (!ctrl->app_ctx)\n    return gpg_error (GPG_ERR_UNSUPPORTED_OPERATION);\n  buffer = xtrymalloc (nbytes);\n  if (!buffer)\n    return out_of_core ();\n  rc = app_get_challenge (ctrl->app_ctx, nbytes, buffer);\n  if (!rc)\n    {\n      rc = assuan_send_data (ctx, buffer, nbytes);\n      xfree (buffer);\n      return rc; \n    }\n  xfree (buffer);\n  TEST_CARD_REMOVAL (ctrl, rc);\n  return rc;\n}", "target": 0}
{"code": "void rds_rdma_free_op(struct rm_rdma_op *ro)\n{\n\tunsigned int i;\n\tfor (i = 0; i < ro->op_nents; i++) {\n\t\tstruct page *page = sg_page(&ro->op_sg[i]);\n\t\tif (!ro->op_write) {\n\t\t\tWARN_ON(!page->mapping && irqs_disabled());\n\t\t\tset_page_dirty(page);\n\t\t}\n\t\tput_page(page);\n\t}\n\tkfree(ro->op_notifier);\n\tro->op_notifier = NULL;\n\tro->op_active = 0;\n}", "target": 0}
{"code": "static void ioctl32_insert_translation(struct ioctl_trans *trans)\n{\n\tunsigned long hash;\n\tstruct ioctl_trans *t;\n\thash = ioctl32_hash (trans->cmd);\n\tif (!ioctl32_hash_table[hash])\n\t\tioctl32_hash_table[hash] = trans;\n\telse {\n\t\tt = ioctl32_hash_table[hash];\n\t\twhile (t->next)\n\t\t\tt = t->next;\n\t\ttrans->next = NULL;\n\t\tt->next = trans;\n\t}\n}", "target": 0}
{"code": "static bool reg_type_mismatch_ok(enum bpf_reg_type type)\n{\n\tswitch (type) {\n\tcase PTR_TO_CTX:\n\tcase PTR_TO_SOCKET:\n\tcase PTR_TO_SOCKET_OR_NULL:\n\tcase PTR_TO_SOCK_COMMON:\n\tcase PTR_TO_SOCK_COMMON_OR_NULL:\n\tcase PTR_TO_TCP_SOCK:\n\tcase PTR_TO_TCP_SOCK_OR_NULL:\n\tcase PTR_TO_XDP_SOCK:\n\tcase PTR_TO_BTF_ID:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}", "target": 0}
{"code": "Eina_Bool ewk_view_setting_resizable_textareas_get(const Evas_Object* ewkView)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, false);\n    return priv->settings.resizableTextareas;\n}", "target": 0}
{"code": "stdmac_line(const SMacro *s, Token **params, int nparams)\n{\n    (void)s;\n    (void)params;\n    (void)nparams;\n    return make_tok_num(NULL, src_get_linnum());\n}", "target": 0}
{"code": "init_dwarf_regnames_iamcu (void)\n{\n  dwarf_regnames = dwarf_regnames_iamcu;\n  dwarf_regnames_count = ARRAY_SIZE (dwarf_regnames_iamcu);\n  dwarf_regnames_lookup_func = regname_internal_by_table_only;\n}", "target": 0}
{"code": "Locked_tables_list::init_locked_tables(THD *thd)\n{\n  DBUG_ASSERT(thd->locked_tables_mode == LTM_NONE);\n  DBUG_ASSERT(m_locked_tables == NULL);\n  DBUG_ASSERT(m_reopen_array == NULL);\n  DBUG_ASSERT(m_locked_tables_count == 0);\n  for (TABLE *table= thd->open_tables; table;\n       table= table->next, m_locked_tables_count++)\n  {\n    TABLE_LIST *src_table_list= table->pos_in_table_list;\n    char *db, *table_name, *alias;\n    size_t db_len=         table->s->db.length;\n    size_t table_name_len= table->s->table_name.length;\n    size_t alias_len=      table->alias.length();\n    TABLE_LIST *dst_table_list;\n    if (! multi_alloc_root(&m_locked_tables_root,\n                           &dst_table_list, sizeof(*dst_table_list),\n                           &db, db_len + 1,\n                           &table_name, table_name_len + 1,\n                           &alias, alias_len + 1,\n                           NullS))\n    {\n      reset();\n      return TRUE;\n    }\n    memcpy(db,         table->s->db.str, db_len + 1);\n    memcpy(table_name, table->s->table_name.str, table_name_len + 1);\n    strmake(alias,     table->alias.ptr(), alias_len);\n    dst_table_list->init_one_table(db, db_len, table_name, table_name_len,\n                                   alias, table->reginfo.lock_type);\n    dst_table_list->table= table;\n    dst_table_list->mdl_request.ticket= src_table_list->mdl_request.ticket;\n    *(dst_table_list->prev_global= m_locked_tables_last)= dst_table_list;\n    m_locked_tables_last= &dst_table_list->next_global;\n    table->pos_in_locked_tables= dst_table_list;\n  }\n  if (m_locked_tables_count)\n  {\n    m_reopen_array= (TABLE_LIST**)alloc_root(&m_locked_tables_root,\n                                             sizeof(TABLE_LIST*) *\n                                             (m_locked_tables_count+1));\n    if (m_reopen_array == NULL)\n    {\n      reset();\n      return TRUE;\n    }\n  }\n  TRANSACT_TRACKER(add_trx_state(thd, TX_LOCKED_TABLES));\n  thd->enter_locked_tables_mode(LTM_LOCK_TABLES);\n  return FALSE;\n}", "target": 0}
{"code": "conv_uni_to_pc(struct vc_data *conp, long ucs) \n{\n\tint h;\n\tu16 **p1, *p2;\n\tstruct uni_pagedir *p;\n\tif (ucs > 0xffff)\n\t\treturn -4;\t\t\n\telse if (ucs < 0x20)\n\t\treturn -1;\t\t\n\telse if (ucs == 0xfeff || (ucs >= 0x200b && ucs <= 0x200f))\n\t\treturn -2;\t\t\t\n\telse if ((ucs & ~UNI_DIRECT_MASK) == UNI_DIRECT_BASE)\n\t\treturn ucs & UNI_DIRECT_MASK;\n\tif (!*conp->vc_uni_pagedir_loc)\n\t\treturn -3;\n\tp = *conp->vc_uni_pagedir_loc;\n\tif ((p1 = p->uni_pgdir[ucs >> 11]) &&\n\t    (p2 = p1[(ucs >> 6) & 0x1f]) &&\n\t    (h = p2[ucs & 0x3f]) < MAX_GLYPH)\n\t\treturn h;\n\treturn -4;\t\t\n}", "target": 0}
{"code": "gint session_start_tls(Session *session)\n{\n\tgboolean nb_mode;\n\tnb_mode = sock_is_nonblocking_mode(session->sock);\n\tsession->sock->ssl_cert_auto_accept = session->ssl_cert_auto_accept;\n\tsession->sock->gnutls_priority = session->gnutls_priority;\n\tsession->sock->use_tls_sni = session->use_tls_sni;\n\tif (nb_mode)\n\t\tsock_set_nonblocking_mode(session->sock, FALSE);\n\tif (!ssl_init_socket(session->sock)) {\n\t\tg_warning(\"couldn't start STARTTLS session.\");\n\t\tif (nb_mode)\n\t\t\tsock_set_nonblocking_mode(session->sock, session->nonblocking);\n\t\treturn -1;\n\t}\n\tif (0 < session->read_buf_len) {\n\t\tg_warning(\"protocol violation: suffix data after STARTTLS detected.\");\n\t\tif (nb_mode)\n\t\t\tsock_set_nonblocking_mode(session->sock, session->nonblocking);\n\t\treturn -1;\n\t}\n\tif (nb_mode)\n\t\tsock_set_nonblocking_mode(session->sock, session->nonblocking);\n\treturn 0;\n}", "target": 0}
{"code": "  static void loadFromJson(const std::string& json, ProtobufWkt::Struct& message) {\n    MessageUtil::loadFromJson(json, message);\n  }", "target": 0}
{"code": "BGD_DECLARE(void) gdImageColorDeallocate (gdImagePtr im, int color)\n{\n\tif (im->trueColor || (color >= gdMaxColors) || (color < 0)) {\n\t\treturn;\n\t}\n\tim->open[color] = 1;\n}", "target": 0}
{"code": "void InlineFlowBox::computeOverflow(int lineTop, int lineBottom, bool strictMode, GlyphOverflowAndFallbackFontsMap& textBoxDataMap)\n{\n    int topOverflow = max(logicalTop(), lineTop);\n    int bottomOverflow = min(logicalBottom(), lineBottom);\n    IntRect logicalLayoutOverflow(enclosingIntRect(FloatRect(logicalLeft(), topOverflow, logicalWidth(), bottomOverflow - topOverflow)));\n    IntRect logicalVisualOverflow(logicalLayoutOverflow);\n    addBoxShadowVisualOverflow(logicalVisualOverflow);\n    for (InlineBox* curr = firstChild(); curr; curr = curr->nextOnLine()) {\n        if (curr->renderer()->isPositioned())\n            continue; \n        if (curr->renderer()->isText()) {\n            InlineTextBox* text = static_cast<InlineTextBox*>(curr);\n            RenderText* rt = toRenderText(text->renderer());\n            if (rt->isBR())\n                continue;\n            addTextBoxVisualOverflow(text, textBoxDataMap, logicalVisualOverflow);\n        } else  if (curr->renderer()->isRenderInline()) {\n            InlineFlowBox* flow = static_cast<InlineFlowBox*>(curr);\n            flow->computeOverflow(lineTop, lineBottom, strictMode, textBoxDataMap);\n            if (!flow->boxModelObject()->hasSelfPaintingLayer())\n                logicalVisualOverflow.unite(flow->logicalVisualOverflowRect());\n            IntRect childLayoutOverflow = flow->logicalLayoutOverflowRect();\n            childLayoutOverflow.move(flow->boxModelObject()->relativePositionLogicalOffset());\n            logicalLayoutOverflow.unite(childLayoutOverflow);\n        } else\n            addReplacedChildOverflow(curr, logicalLayoutOverflow, logicalVisualOverflow);\n    }\n    setOverflowFromLogicalRects(logicalLayoutOverflow, logicalVisualOverflow);\n}", "target": 0}
{"code": "static struct bpf_prog *bpf_patch_insn_data(struct bpf_verifier_env *env, u32 off,\n\t\t\t\t\t    const struct bpf_insn *patch, u32 len)\n{\n\tstruct bpf_prog *new_prog;\n\tnew_prog = bpf_patch_insn_single(env->prog, off, patch, len);\n\tif (!new_prog)\n\t\treturn NULL;\n\tif (adjust_insn_aux_data(env, new_prog->len, off, len))\n\t\treturn NULL;\n\tadjust_subprog_starts(env, off, len);\n\treturn new_prog;\n}", "target": 0}
{"code": "static inline ssize_t PixelRoundOffset(double x)\n{\n  if ((x-floor(x)) < (ceil(x)-x))\n    return((ssize_t) floor(ConstrainPixelOffset(x)));\n  return((ssize_t) ceil(ConstrainPixelOffset(x)));\n}", "target": 0}
{"code": "void ewk_view_editor_client_contents_changed(Evas_Object* ewkView)\n{\n    evas_object_smart_callback_call(ewkView, \"editorclient,contents,changed\", 0);\n}", "target": 0}
{"code": "gx_dc_pattern2_save_dc(\n    const gx_device_color * pdevc,\n    gx_device_color_saved * psdc )\n{\n    gs_pattern2_instance_t * pinst = (gs_pattern2_instance_t *)pdevc->ccolor.pattern;\n    psdc->type = pdevc->type;\n    psdc->colors.pattern2.id = pinst->pattern_id;\n    psdc->colors.pattern2.shfill = pinst->shfill;\n}", "target": 0}
{"code": " JSRetainPtr<JSStringRef> AccessibilityUIElement::stringValue()\n {\n    if (!m_element || !ATK_IS_TEXT(m_element))\n        return JSStringCreateWithCharacters(0, 0);\n    GOwnPtr<gchar> text(atk_text_get_text(ATK_TEXT(m_element), 0, -1));\n    GOwnPtr<gchar> textWithReplacedCharacters(replaceCharactersForResults(text.get()));\n    GOwnPtr<gchar> axValue(g_strdup_printf(\"AXValue: %s\", textWithReplacedCharacters.get()));\n    return JSStringCreateWithUTF8CString(axValue.get());\n }", "target": 0}
{"code": "ProcChangeAccessControl(ClientPtr client)\n{\n    REQUEST(xSetAccessControlReq);\n    REQUEST_SIZE_MATCH(xSetAccessControlReq);\n    if ((stuff->mode != EnableAccess) && (stuff->mode != DisableAccess)) {\n        client->errorValue = stuff->mode;\n        return BadValue;\n    }\n    return ChangeAccessControl(client, stuff->mode == EnableAccess);\n}", "target": 0}
{"code": "my_bool STDCALL mysql_thread_init()\n{\n  return my_thread_init();\n}", "target": 0}
{"code": "static int remove_dup_with_compare(THD *thd, TABLE *table, Field **first_field,\n\t\t\t\t   Item *having)\n{\n  handler *file=table->file;\n  uchar *record=table->record[0];\n  int error;\n  DBUG_ENTER(\"remove_dup_with_compare\");\n  if (unlikely(file->ha_rnd_init_with_error(1)))\n    DBUG_RETURN(1);\n  error= file->ha_rnd_next(record);\n  for (;;)\n  {\n    if (unlikely(thd->check_killed()))\n    {\n      error=0;\n      goto err;\n    }\n    if (unlikely(error))\n    {\n      if (error == HA_ERR_END_OF_FILE)\n\tbreak;\n      goto err;\n    }\n    if (having && !having->val_int())\n    {\n      if (unlikely((error= file->ha_delete_row(record))))\n\tgoto err;\n      error= file->ha_rnd_next(record);\n      continue;\n    }\n    if (unlikely(copy_blobs(first_field)))\n    {\n      my_message(ER_OUTOFMEMORY, ER_THD(thd,ER_OUTOFMEMORY),\n                 MYF(ME_FATAL));\n      error=0;\n      goto err;\n    }\n    store_record(table,record[1]);\n    bool found=0;\n    for (;;)\n    {\n      if (unlikely((error= file->ha_rnd_next(record))))\n      {\n\tif (error == HA_ERR_END_OF_FILE)\n\t  break;\n\tgoto err;\n      }\n      if (compare_record(table, first_field) == 0)\n      {\n\tif (unlikely((error= file->ha_delete_row(record))))\n\t  goto err;\n      }\n      else if (!found)\n      {\n\tfound=1;\n        if (unlikely((error= file->remember_rnd_pos())))\n          goto err;\n      }\n    }\n    if (!found)\n      break;\t\t\t\t\t\n    if (unlikely((error= file->restart_rnd_next(record))))\n      goto err;\n  }\n  file->extra(HA_EXTRA_NO_CACHE);\n  (void) file->ha_rnd_end();\n  DBUG_RETURN(0);\nerr:\n  file->extra(HA_EXTRA_NO_CACHE);\n  (void) file->ha_rnd_end();\n  if (error)\n    file->print_error(error,MYF(0));\n  DBUG_RETURN(1);\n}", "target": 0}
{"code": "void LinkResolver::throw_abstract_method_error(const methodHandle& resolved_method,\n                                               const methodHandle& selected_method,\n                                               Klass *recv_klass, TRAPS) {\n  Klass *resolved_klass = resolved_method->method_holder();\n  ResourceMark rm(THREAD);\n  stringStream ss;\n  if (recv_klass != NULL) {\n    ss.print(\"Receiver class %s does not define or inherit an \"\n             \"implementation of the\",\n             recv_klass->external_name());\n  } else {\n    ss.print(\"Missing implementation of\");\n  }\n  assert(resolved_method.not_null(), \"Sanity\");\n  ss.print(\" resolved method '%s%s\",\n           resolved_method->is_abstract() ? \"abstract \" : \"\",\n           resolved_method->is_private()  ? \"private \"  : \"\");\n  resolved_method->signature()->print_as_signature_external_return_type(&ss);\n  ss.print(\" %s(\", resolved_method->name()->as_C_string());\n  resolved_method->signature()->print_as_signature_external_parameters(&ss);\n  ss.print(\")' of %s %s.\",\n           resolved_klass->external_kind(),\n           resolved_klass->external_name());\n  if (selected_method.not_null() && !(resolved_method == selected_method)) {\n    ss.print(\" Selected method is '%s%s\",\n             selected_method->is_abstract() ? \"abstract \" : \"\",\n             selected_method->is_private()  ? \"private \"  : \"\");\n    selected_method->print_external_name(&ss);\n    ss.print(\"'.\");\n  }\n  THROW_MSG(vmSymbols::java_lang_AbstractMethodError(), ss.as_string());\n}", "target": 0}
{"code": "i915_gem_execbuffer_unreserve_object(struct drm_i915_gem_object *obj)\n{\n\tstruct drm_i915_gem_exec_object2 *entry;\n\tif (!obj->gtt_space)\n\t\treturn;\n\tentry = obj->exec_entry;\n\tif (entry->flags & __EXEC_OBJECT_HAS_FENCE)\n\t\ti915_gem_object_unpin_fence(obj);\n\tif (entry->flags & __EXEC_OBJECT_HAS_PIN)\n\t\ti915_gem_object_unpin(obj);\n\tentry->flags &= ~(__EXEC_OBJECT_HAS_FENCE | __EXEC_OBJECT_HAS_PIN);\n}", "target": 0}
{"code": "fire_sched_out_preempt_notifiers(struct task_struct *curr,\n\t\t\t\t struct task_struct *next)\n{\n\tif (static_key_false(&preempt_notifier_key))\n\t\t__fire_sched_out_preempt_notifiers(curr, next);\n}", "target": 0}
{"code": "void proc_flush_task(struct task_struct *task)\n{\n\tint i;\n\tstruct pid *pid, *tgid = NULL;\n\tstruct upid *upid;\n\tpid = task_pid(task);\n\tif (thread_group_leader(task))\n\t\ttgid = task_tgid(task);\n\tfor (i = 0; i <= pid->level; i++) {\n\t\tupid = &pid->numbers[i];\n\t\tproc_flush_task_mnt(upid->ns->proc_mnt, upid->nr,\n\t\t\ttgid ? tgid->numbers[i].nr : 0);\n\t}\n\tupid = &pid->numbers[pid->level];\n\tif (upid->nr == 1)\n\t\tpid_ns_release_proc(upid->ns);\n}", "target": 0}
{"code": "static int rfcomm_sock_sendmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t       struct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rfcomm_dlc *d = rfcomm_pi(sk)->dlc;\n\tstruct sk_buff *skb;\n\tint sent = 0;\n\tif (test_bit(RFCOMM_DEFER_SETUP, &d->flags))\n\t\treturn -ENOTCONN;\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\tif (sk->sk_shutdown & SEND_SHUTDOWN)\n\t\treturn -EPIPE;\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\tlock_sock(sk);\n\twhile (len) {\n\t\tsize_t size = min_t(size_t, len, d->mtu);\n\t\tint err;\n\t\tskb = sock_alloc_send_skb(sk, size + RFCOMM_SKB_RESERVE,\n\t\t\t\tmsg->msg_flags & MSG_DONTWAIT, &err);\n\t\tif (!skb) {\n\t\t\tif (sent == 0)\n\t\t\t\tsent = err;\n\t\t\tbreak;\n\t\t}\n\t\tskb_reserve(skb, RFCOMM_SKB_HEAD_RESERVE);\n\t\terr = memcpy_fromiovec(skb_put(skb, size), msg->msg_iov, size);\n\t\tif (err) {\n\t\t\tkfree_skb(skb);\n\t\t\tif (sent == 0)\n\t\t\t\tsent = err;\n\t\t\tbreak;\n\t\t}\n\t\tskb->priority = sk->sk_priority;\n\t\terr = rfcomm_dlc_send(d, skb);\n\t\tif (err < 0) {\n\t\t\tkfree_skb(skb);\n\t\t\tif (sent == 0)\n\t\t\t\tsent = err;\n\t\t\tbreak;\n\t\t}\n\t\tsent += size;\n\t\tlen  -= size;\n\t}\n\trelease_sock(sk);\n\treturn sent;\n}", "target": 0}
{"code": "void connections_free(server *srv) {\n\tconnections * const conns = &srv->conns;\n\tfor (uint32_t i = 0; i < conns->size; ++i) {\n\t\tconnection *con = conns->ptr[i];\n\t\trequest_st * const r = &con->request;\n\t\tconnection_reset(con);\n\t\tif (con->write_queue != &r->write_queue)\n\t\t\tchunkqueue_free(con->write_queue);\n\t\tif (con->read_queue != &r->read_queue)\n\t\t\tchunkqueue_free(con->read_queue);\n\t\trequest_free_data(r);\n\t\tfree(con->plugin_ctx);\n\t\tbuffer_free(con->dst_addr_buf);\n\t\tfree(con);\n\t}\n\tfree(conns->ptr);\n\tconns->ptr = NULL;\n}", "target": 0}
{"code": "rgw::auth::s3::STSEngine::get_session_token(const DoutPrefixProvider* dpp, const boost::string_view& session_token,\n                                            STS::SessionToken& token) const\n{\n  string decodedSessionToken;\n  try {\n    decodedSessionToken = rgw::from_base64(session_token);\n  } catch (...) {\n    ldpp_dout(dpp, 0) << \"ERROR: Invalid session token, not base64 encoded.\" << dendl;\n    return -EINVAL;\n  }\n  auto* cryptohandler = cct->get_crypto_handler(CEPH_CRYPTO_AES);\n  if (! cryptohandler) {\n    return -EINVAL;\n  }\n  string secret_s = cct->_conf->rgw_sts_key;\n  buffer::ptr secret(secret_s.c_str(), secret_s.length());\n  int ret = 0;\n  if (ret = cryptohandler->validate_secret(secret); ret < 0) {\n    ldpp_dout(dpp, 0) << \"ERROR: Invalid secret key\" << dendl;\n    return -EINVAL;\n  }\n  string error;\n  auto* keyhandler = cryptohandler->get_key_handler(secret, error);\n  if (! keyhandler) {\n    return -EINVAL;\n  }\n  error.clear();\n  string decrypted_str;\n  buffer::list en_input, dec_output;\n  en_input = buffer::list::static_from_string(decodedSessionToken);\n  ret = keyhandler->decrypt(en_input, dec_output, &error);\n  if (ret < 0) {\n    ldpp_dout(dpp, 0) << \"ERROR: Decryption failed: \" << error << dendl;\n    return -EPERM;\n  } else {\n    try {\n      dec_output.append('\\0');\n      auto iter = dec_output.cbegin();\n      decode(token, iter);\n    } catch (const buffer::error& e) {\n      ldout(cct, 0) << \"ERROR: decode SessionToken failed: \" << error << dendl;\n      return -EINVAL;\n    }\n  }\n  return 0;\n}", "target": 0}
{"code": "mcs_send_edrq(void)\n{\n\tSTREAM s;\n\ts = iso_init(5);\n\tout_uint8(s, (MCS_EDRQ << 2));\n\tout_uint16_be(s, 1);\t\n\tout_uint16_be(s, 1);\t\n\ts_mark_end(s);\n\tiso_send(s);\n}", "target": 0}
{"code": "dirserv_set_cached_consensus_networkstatus(const char *networkstatus,\n                                           const char *flavor_name,\n                                           const digests_t *digests,\n                                           time_t published)\n{\n  cached_dir_t *new_networkstatus;\n  cached_dir_t *old_networkstatus;\n  if (!cached_consensuses)\n    cached_consensuses = strmap_new();\n  new_networkstatus = new_cached_dir(tor_strdup(networkstatus), published);\n  memcpy(&new_networkstatus->digests, digests, sizeof(digests_t));\n  old_networkstatus = strmap_set(cached_consensuses, flavor_name,\n                                 new_networkstatus);\n  if (old_networkstatus)\n    cached_dir_decref(old_networkstatus);\n}", "target": 0}
{"code": "host_aton(const uschar *address, int *bin)\n{\nint x[4];\nint v4offset = 0;\nif (Ustrchr(address, ':') != NULL)\n  {\n  const uschar *p = address;\n  const uschar *component[8];\n  BOOL ipv4_ends = FALSE;\n  int ci = 0;\n  int nulloffset = 0;\n  int v6count = 8;\n  int i;\n  if (*p == ':') p++;\n  while (*p != 0 && *p != '%')\n    {\n    int len = Ustrcspn(p, \":%\");\n    if (len == 0) nulloffset = ci;\n    if (ci > 7) log_write(0, LOG_MAIN|LOG_PANIC_DIE,\n      \"Internal error: invalid IPv6 address \\\"%s\\\" passed to host_aton()\",\n      address);\n    component[ci++] = p;\n    p += len;\n    if (*p == ':') p++;\n    }\n  if (Ustrchr(component[ci-1], '.') != NULL)\n    {\n    address = component[--ci];\n    ipv4_ends = TRUE;\n    v4offset = 3;\n    v6count = 6;\n    }\n  if (ci < v6count)\n    {\n    int insert_count = v6count - ci;\n    for (i = v6count-1; i > nulloffset + insert_count; i--)\n      component[i] = component[i - insert_count];\n    while (i > nulloffset) component[i--] = US\"\";\n    }\n  for (i = 0; i < v6count; i += 2)\n    bin[i/2] = (Ustrtol(component[i], NULL, 16) << 16) +\n      Ustrtol(component[i+1], NULL, 16);\n  if (!ipv4_ends) return 4;\n  }\n(void)sscanf(CS address, \"%d.%d.%d.%d\", x, x+1, x+2, x+3);\nbin[v4offset] = ((uint)x[0] << 24) + (x[1] << 16) + (x[2] << 8) + x[3];\nreturn v4offset+1;\n}", "target": 0}
{"code": "void FrameLoader::commitProvisionalLoad()\n{\n    ASSERT(m_client->hasWebView());\n    ASSERT(m_state == FrameStateProvisional);\n    RefPtr<DocumentLoader> pdl = m_provisionalDocumentLoader;\n    RefPtr<Frame> protect(m_frame);\n    closeOldDataSources();\n    if (m_frame->document()) {\n        RefPtr<SecurityOrigin> securityOrigin = SecurityOrigin::create(pdl->request().url());\n        pdl->timing()->setHasSameOriginAsPreviousDocument(securityOrigin->canRequest(m_frame->document()->url()));\n    }\n    if (m_documentLoader)\n        closeURL();\n    if (pdl != m_provisionalDocumentLoader)\n        return;\n    RefPtr<DocumentLoader> loaderBeingCommitted = m_provisionalDocumentLoader.release();\n    detachChildren();\n    if (m_documentLoader)\n        m_documentLoader->detachFromFrame();\n    m_documentLoader = loaderBeingCommitted;\n    m_state = FrameStateCommittedPage;\n    if (isLoadingMainFrame())\n        m_frame->page()->chrome().client().needTouchEvents(false);\n    history()->updateForCommit();\n    m_client->transitionToCommittedForNewPage();\n    m_frame->navigationScheduler()->cancel();\n    m_frame->editor().clearLastEditCommand();\n    if (!m_stateMachine.creatingInitialEmptyDocument()) {\n        DOMWindow* window = m_frame->domWindow();\n        window->setStatus(String());\n        window->setDefaultStatus(String());\n    }\n    started();\n}", "target": 0}
{"code": "static void do_wakeup(void)\n{\n\treschedule_timeout(MAXTIMEOUT, \"do wakeup\");\n\tcont = NULL;\n\tcommand_status += 2;\n\twake_up(&command_done);\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::ForwardEmulatedTouchEvent(\n      const blink::WebTouchEvent& touch_event) {\n  TRACE_EVENT0(\"input\", \"RenderWidgetHostImpl::ForwardEmulatedTouchEvent\");\n  ui::LatencyInfo latency_info(ui::SourceEventType::TOUCH);\n  TouchEventWithLatencyInfo touch_with_latency(touch_event, latency_info);\n  DispatchInputEventWithLatencyInfo(touch_event, &touch_with_latency.latency);\n  input_router_->SendTouchEvent(touch_with_latency);\n}", "target": 0}
{"code": "xmlValidateOneCdataElement(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n                           xmlNodePtr elem) {\n    int ret = 1;\n    xmlNodePtr cur, child;\n    if ((ctxt == NULL) || (doc == NULL) || (elem == NULL) ||\n        (elem->type != XML_ELEMENT_NODE))\n\treturn(0);\n    child = elem->children;\n    cur = child;\n    while (cur != NULL) {\n\tswitch (cur->type) {\n\t    case XML_ENTITY_REF_NODE:\n\t\tif ((cur->children != NULL) &&\n\t\t    (cur->children->children != NULL)) {\n\t\t    nodeVPush(ctxt, cur);\n\t\t    cur = cur->children->children;\n\t\t    continue;\n\t\t}\n\t\tbreak;\n\t    case XML_COMMENT_NODE:\n\t    case XML_PI_NODE:\n\t    case XML_TEXT_NODE:\n\t    case XML_CDATA_SECTION_NODE:\n\t\tbreak;\n\t    default:\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\tcur = cur->next;\n\twhile (cur == NULL) {\n\t    cur = nodeVPop(ctxt);\n\t    if (cur == NULL)\n\t\tbreak;\n\t    cur = cur->next;\n\t}\n    }\ndone:\n    ctxt->nodeMax = 0;\n    ctxt->nodeNr = 0;\n    if (ctxt->nodeTab != NULL) {\n\txmlFree(ctxt->nodeTab);\n\tctxt->nodeTab = NULL;\n    }\n    return(ret);\n}", "target": 0}
{"code": "static int brotli_compress(struct transaction_t *txn,\n                           unsigned flags, const char *buf, unsigned len)\n{\n    unsigned op = (flags & COMPRESS_END) ?\n        BROTLI_OPERATION_FINISH : BROTLI_OPERATION_FLUSH;\n    BrotliEncoderState *brotli = txn->brotli;\n    const uint8_t *next_in = (const uint8_t *) buf;\n    size_t avail_in = (size_t) len;\n    buf_ensure(&txn->zbuf, BrotliEncoderMaxCompressedSize(avail_in));\n    buf_reset(&txn->zbuf);\n    do {\n        uint8_t *next_out = (uint8_t *) txn->zbuf.s + txn->zbuf.len;\n        size_t avail_out = txn->zbuf.alloc - txn->zbuf.len;\n        if (!BrotliEncoderCompressStream(brotli, op,\n                                         &avail_in, &next_in,\n                                         &avail_out, &next_out, NULL)) {\n            syslog(LOG_ERR, \"Brotli: Error while compressing data\");\n            return -1;\n        }\n        txn->zbuf.len = txn->zbuf.alloc - avail_out;\n    } while (avail_in || BrotliEncoderHasMoreOutput(brotli));\n    if (BrotliEncoderIsFinished(brotli)) {\n        BrotliEncoderDestroyInstance(brotli);\n        txn->brotli = brotli_init();\n    }\n    return 0;\n}", "target": 0}
{"code": "void lodepng_compress_settings_init(LodePNGCompressSettings* settings)\n{\n  settings->btype = 2;\n  settings->use_lz77 = 1;\n  settings->windowsize = DEFAULT_WINDOWSIZE;\n  settings->minmatch = 3;\n  settings->nicematch = 128;\n  settings->lazymatching = 1;\n  settings->custom_zlib = 0;\n  settings->custom_deflate = 0;\n  settings->custom_context = 0;\n}", "target": 0}
{"code": "struct timespec timespec_trunc(struct timespec t, unsigned gran)\n{\n\tif (gran == 1) {\n\t} else if (gran == NSEC_PER_SEC) {\n\t\tt.tv_nsec = 0;\n\t} else if (gran > 1 && gran < NSEC_PER_SEC) {\n\t\tt.tv_nsec -= t.tv_nsec % gran;\n\t} else {\n\t\tWARN(1, \"illegal file time granularity: %u\", gran);\n\t}\n\treturn t;\n}", "target": 0}
{"code": "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\tkey = key_ref_to_ptr(key_ref);\n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error;\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\ncan_read_key:\n\tret = -EOPNOTSUPP;\n\tif (key->type->read) {\n\t\tdown_read(&key->sem);\n\t\tret = key_validate(key);\n\t\tif (ret == 0)\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\tup_read(&key->sem);\n\t}\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "read_StreamsInfo(struct archive_read *a, struct _7z_stream_info *si)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\tconst unsigned char *p;\n\tunsigned i;\n\tmemset(si, 0, sizeof(*si));\n\tif ((p = header_bytes(a, 1)) == NULL)\n\t\treturn (-1);\n\tif (*p == kPackInfo) {\n\t\tuint64_t packPos;\n\t\tif (read_PackInfo(a, &(si->pi)) < 0)\n\t\t\treturn (-1);\n\t\tif (si->pi.positions == NULL || si->pi.sizes == NULL)\n\t\t\treturn (-1);\n\t\tpackPos = si->pi.pos;\n\t\tfor (i = 0; i < si->pi.numPackStreams; i++) {\n\t\t\tsi->pi.positions[i] = packPos;\n\t\t\tpackPos += si->pi.sizes[i];\n\t\t\tif (packPos > zip->header_offset)\n\t\t\t\treturn (-1);\n\t\t}\n\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\treturn (-1);\n\t}\n\tif (*p == kUnPackInfo) {\n\t\tuint32_t packIndex;\n\t\tstruct _7z_folder *f;\n\t\tif (read_CodersInfo(a, &(si->ci)) < 0)\n\t\t\treturn (-1);\n\t\tpackIndex = 0;\n\t\tf = si->ci.folders;\n\t\tfor (i = 0; i < si->ci.numFolders; i++) {\n\t\t\tf[i].packIndex = packIndex;\n\t\t\tpackIndex += (uint32_t)f[i].numPackedStreams;\n\t\t\tif (packIndex > si->pi.numPackStreams)\n\t\t\t\treturn (-1);\n\t\t}\n\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\treturn (-1);\n\t}\n\tif (*p == kSubStreamsInfo) {\n\t\tif (read_SubStreamsInfo(a, &(si->ss),\n\t\t    si->ci.folders, (size_t)si->ci.numFolders) < 0)\n\t\t\treturn (-1);\n\t\tif ((p = header_bytes(a, 1)) == NULL)\n\t\t\treturn (-1);\n\t}\n\tif (*p != kEnd)\n\t\treturn (-1);\n\treturn (0);\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::DisableResizeAckCheckForTesting() {\n  g_check_for_pending_resize_ack = false;\n}", "target": 0}
{"code": "static GCObject **sweeptolive (lua_State *L, GCObject **p) {\n  GCObject **old = p;\n  do {\n    p = sweeplist(L, p, 1, NULL);\n  } while (p == old);\n  return p;\n}", "target": 0}
{"code": "header_bin_le(struct archive_read *a, struct cpio *cpio,\n    struct archive_entry *entry, size_t *namelength, size_t *name_pad)\n{\n\tconst void *h;\n\tconst unsigned char *header;\n\ta->archive.archive_format = ARCHIVE_FORMAT_CPIO_BIN_LE;\n\ta->archive.archive_format_name = \"cpio (little-endian binary)\";\n\th = __archive_read_ahead(a, bin_header_size, NULL);\n\tif (h == NULL) {\n\t    archive_set_error(&a->archive, 0,\n\t\t\"End of file trying to read next cpio header\");\n\t    return (ARCHIVE_FATAL);\n\t}\n\theader = (const unsigned char *)h;\n\tarchive_entry_set_dev(entry, header[bin_dev_offset] + header[bin_dev_offset + 1] * 256);\n\tarchive_entry_set_ino(entry, header[bin_ino_offset] + header[bin_ino_offset + 1] * 256);\n\tarchive_entry_set_mode(entry, header[bin_mode_offset] + header[bin_mode_offset + 1] * 256);\n\tarchive_entry_set_uid(entry, header[bin_uid_offset] + header[bin_uid_offset + 1] * 256);\n\tarchive_entry_set_gid(entry, header[bin_gid_offset] + header[bin_gid_offset + 1] * 256);\n\tarchive_entry_set_nlink(entry, header[bin_nlink_offset] + header[bin_nlink_offset + 1] * 256);\n\tarchive_entry_set_rdev(entry, header[bin_rdev_offset] + header[bin_rdev_offset + 1] * 256);\n\tarchive_entry_set_mtime(entry, le4(header + bin_mtime_offset), 0);\n\t*namelength = header[bin_namesize_offset] + header[bin_namesize_offset + 1] * 256;\n\t*name_pad = *namelength & 1; \n\tcpio->entry_bytes_remaining = le4(header + bin_filesize_offset);\n\tarchive_entry_set_size(entry, cpio->entry_bytes_remaining);\n\tcpio->entry_padding = cpio->entry_bytes_remaining & 1; \n\t__archive_read_consume(a, bin_header_size);\n\treturn (ARCHIVE_OK);\n}", "target": 0}
{"code": "static void addrconf_disable_change(struct net *net, __s32 newf)\n{\n\tstruct net_device *dev;\n\tstruct inet6_dev *idev;\n\trcu_read_lock();\n\tfor_each_netdev_rcu(net, dev) {\n\t\tidev = __in6_dev_get(dev);\n\t\tif (idev) {\n\t\t\tint changed = (!idev->cnf.disable_ipv6) ^ (!newf);\n\t\t\tidev->cnf.disable_ipv6 = newf;\n\t\t\tif (changed)\n\t\t\t\tdev_disable_change(idev);\n\t\t}\n\t}\n\trcu_read_unlock();\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, EmptyQueryWithoutProjectionUsesCollscan) {\n    addIndex(BSON(\"a\" << 1));\n    runQuery(BSONObj());\n    assertNumSolutions(1);\n    assertSolutionExists(\"{cscan: {dir: 1}}}\");\n}", "target": 0}
{"code": "void GLES2DecoderTestBase::DoTexImage2D(\n    GLenum target, GLint level, GLenum internal_format,\n    GLsizei width, GLsizei height, GLint border,\n    GLenum format, GLenum type,\n    uint32 shared_memory_id, uint32 shared_memory_offset) {\n  EXPECT_CALL(*gl_, GetError())\n      .WillOnce(Return(GL_NO_ERROR))\n      .RetiresOnSaturation();\n  EXPECT_CALL(*gl_, TexImage2D(target, level, internal_format,\n                               width, height, border, format, type, _))\n      .Times(1)\n      .RetiresOnSaturation();\n  EXPECT_CALL(*gl_, GetError())\n      .WillOnce(Return(GL_NO_ERROR))\n      .RetiresOnSaturation();\n  TexImage2D cmd;\n  cmd.Init(target, level, internal_format, width, height, border, format,\n           type, shared_memory_id, shared_memory_offset);\n  EXPECT_EQ(error::kNoError, ExecuteCmd(cmd));\n}", "target": 0}
{"code": "static void __init paravirt_ops_setup(void)\n{\n\tpv_info.name = \"KVM\";\n\tpv_info.paravirt_enabled = 0;\n\tif (kvm_para_has_feature(KVM_FEATURE_NOP_IO_DELAY))\n\t\tpv_cpu_ops.io_delay = kvm_io_delay;\n#ifdef CONFIG_X86_IO_APIC\n\tno_timer_check = 1;\n#endif\n}", "target": 0}
{"code": "extract_argv (EvDocument *document, gint page)\n{\n\tComicsDocument *comics_document = COMICS_DOCUMENT (document);\n\tchar **argv;\n\tchar *command_line, *quoted_archive, *quoted_filename;\n\tGError *err = NULL;\n\tif (g_strrstr (comics_document->page_names->pdata[page], \"--checkpoint-action=\"))\n\t{\n\t\tg_warning (\"File unsupported\\n\");\n\t\tgtk_main_quit ();\n\t}\n        if (page >= comics_document->page_names->len)\n                return NULL;\n\tif (comics_document->regex_arg) {\n\t\tquoted_archive = g_shell_quote (comics_document->archive);\n\t\tquoted_filename =\n\t\t\tcomics_regex_quote (comics_document->page_names->pdata[page]);\n\t} else {\n\t\tquoted_archive = g_shell_quote (comics_document->archive);\n\t\tquoted_filename = g_shell_quote (comics_document->page_names->pdata[page]);\n\t}\n\tcommand_line = g_strdup_printf (\"%s %s %s\",\n\t\t\t\t\tcomics_document->extract_command,\n\t\t\t\t\tquoted_archive,\n\t\t\t\t\tquoted_filename);\n\tg_free (quoted_archive);\n\tg_free (quoted_filename);\n\tg_shell_parse_argv (command_line, NULL, &argv, &err);\n\tg_free (command_line);\n\tif (err) {\n\t\tg_warning (_(\"Error %s\"), err->message);\n\t\tg_error_free (err);\n\t\treturn NULL;\n\t}\n\treturn argv;\n}", "target": 0}
{"code": "static void vmx_set_nmi_mask(struct kvm_vcpu *vcpu, bool masked)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tif (!cpu_has_virtual_nmis()) {\n\t\tif (vmx->soft_vnmi_blocked != masked) {\n\t\t\tvmx->soft_vnmi_blocked = masked;\n\t\t\tvmx->vnmi_blocked_time = 0;\n\t\t}\n\t} else {\n\t\tvmx->nmi_known_unmasked = !masked;\n\t\tif (masked)\n\t\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\t      GUEST_INTR_STATE_NMI);\n\t\telse\n\t\t\tvmcs_clear_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\t\tGUEST_INTR_STATE_NMI);\n\t}\n}", "target": 0}
{"code": "static int send_connect_method_response (struct conn_s *connptr)\n{\n        return write_message (connptr->client_fd,\n                              \"HTTP/1.%u 200 Connection established\\r\\n\"\n                              \"Proxy-agent: \" PACKAGE \"/\" VERSION \"\\r\\n\"\n                              \"\\r\\n\", connptr->protocol.major != 1 ? 0 :\n                                      connptr->protocol.minor);\n}", "target": 0}
{"code": "static void __mark_reg_known_zero(struct bpf_reg_state *reg)\n{\n\t__mark_reg_known(reg, 0);\n}", "target": 0}
{"code": "void OmniboxViewWin::EditDropTarget::OnDragLeave(IDataObject* data_object) {\n  ResetDropHighlights();\n}", "target": 0}
{"code": "void ttm_unmap_and_unpopulate_pages(struct device *dev, struct ttm_dma_tt *tt)\n{\n\tunsigned i, j;\n\tfor (i = 0; i < tt->ttm.num_pages;) {\n\t\tstruct page *p = tt->ttm.pages[i];\n\t\tsize_t num_pages = 1;\n\t\tif (!tt->dma_address[i] || !tt->ttm.pages[i]) {\n\t\t\t++i;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (j = i + 1; j < tt->ttm.num_pages; ++j) {\n\t\t\tif (++p != tt->ttm.pages[j])\n\t\t\t\tbreak;\n\t\t\t++num_pages;\n\t\t}\n\t\tdma_unmap_page(dev, tt->dma_address[i], num_pages * PAGE_SIZE,\n\t\t\t       DMA_BIDIRECTIONAL);\n\t\ti += num_pages;\n\t}\n\tttm_pool_unpopulate(&tt->ttm);\n}", "target": 0}
{"code": "static inline Quantum ScaleLongToQuantum(const unsigned int value)\n{\n  return((Quantum) (4294967297.0*value));\n}", "target": 0}
{"code": "COMPAT_SYSCALL_DEFINE4(sendfile, int, out_fd, int, in_fd,\n\t\tcompat_off_t __user *, offset, compat_size_t, count)\n{\n\tloff_t pos;\n\toff_t off;\n\tssize_t ret;\n\tif (offset) {\n\t\tif (unlikely(get_user(off, offset)))\n\t\t\treturn -EFAULT;\n\t\tpos = off;\n\t\tret = do_sendfile(out_fd, in_fd, &pos, count, MAX_NON_LFS);\n\t\tif (unlikely(put_user(pos, offset)))\n\t\t\treturn -EFAULT;\n\t\treturn ret;\n\t}\n\treturn do_sendfile(out_fd, in_fd, NULL, count, 0);\n}", "target": 0}
{"code": "njs_encode_base64(njs_str_t *dst, const njs_str_t *src)\n{\n    njs_encode_base64_core(dst, src, njs_basis64_enc, 1);\n}", "target": 0}
{"code": "Item_result item_cmp_type(Item_result a,Item_result b)\n{\n  if (a == STRING_RESULT && b == STRING_RESULT)\n    return STRING_RESULT;\n  if (a == INT_RESULT && b == INT_RESULT)\n    return INT_RESULT;\n  else if (a == ROW_RESULT || b == ROW_RESULT)\n    return ROW_RESULT;\n  else if (a == TIME_RESULT || b == TIME_RESULT)\n    return TIME_RESULT;\n  if ((a == INT_RESULT || a == DECIMAL_RESULT) &&\n      (b == INT_RESULT || b == DECIMAL_RESULT))\n    return DECIMAL_RESULT;\n  return REAL_RESULT;\n}", "target": 0}
{"code": "void PDFiumEngine::Form_Beep(IPDF_JSPLATFORM* param, int type) {\n}", "target": 0}
{"code": "void Document::setBody(HTMLElement* prp_new_body,\n                       ExceptionState& exception_state) {\n  HTMLElement* new_body = prp_new_body;\n  if (!new_body) {\n    exception_state.ThrowDOMException(\n        kHierarchyRequestError,\n        ExceptionMessages::ArgumentNullOrIncorrectType(1, \"HTMLElement\"));\n    return;\n  }\n  if (!documentElement()) {\n    exception_state.ThrowDOMException(kHierarchyRequestError,\n                                      \"No document element exists.\");\n    return;\n  }\n  if (!IsHTMLBodyElement(*new_body) && !IsHTMLFrameSetElement(*new_body)) {\n    exception_state.ThrowDOMException(\n        kHierarchyRequestError,\n        \"The new body element is of type '\" + new_body->tagName() +\n            \"'. It must be either a 'BODY' or 'FRAMESET' element.\");\n    return;\n  }\n  HTMLElement* old_body = body();\n  if (old_body == new_body)\n    return;\n  if (old_body)\n    documentElement()->ReplaceChild(new_body, old_body, exception_state);\n  else\n    documentElement()->AppendChild(new_body, exception_state);\n}", "target": 0}
{"code": "onigenc_strlen_null(OnigEncoding enc, const UChar* s)\n{\n  int n = 0;\n  UChar* p = (UChar* )s;\n  UChar* e;\n  while (1) {\n    if (*p == '\\0') {\n      UChar* q;\n      int len = ONIGENC_MBC_MINLEN(enc);\n      if (len == 1) return n;\n      q = p + 1;\n      while (len > 1) {\n        if (*q != '\\0') break;\n        q++;\n        len--;\n      }\n      if (len == 1) return n;\n    }\n    e = p + ONIGENC_MBC_MAXLEN(enc);\n    p += ONIGENC_MBC_ENC_LEN(enc, p, e);\n    n++;\n  }\n}", "target": 0}
{"code": "rpmRC rpmReadHeader(rpmts ts, FD_t fd, Header *hdrp, char ** msg)\n{\n    rpmRC rc;\n    rpmKeyring keyring = rpmtsGetKeyring(ts, 1);\n    rpmVSFlags vsflags = rpmtsVSFlags(ts);\n    rc = rpmpkgReadHeader(keyring, vsflags, fd, hdrp, msg);\n    rpmKeyringFree(keyring);\n    return rc;\n}", "target": 0}
{"code": "static int check_is_mount(const char *last, const char *mnt)\n{\n\tpid_t pid, p;\n\tint status;\n\tconst char *a[2] = { last, mnt };\n\tpid = clone_newns((void *) a);\n\tif (pid == (pid_t) -1) {\n\t\tfprintf(stderr, \"%s: failed to clone namespace: %s\\n\",\n\t\t\tprogname, strerror(errno));\n\t\treturn -1;\n\t}\n\tp = waitpid(pid, &status, __WCLONE);\n\tif (p == (pid_t) -1) {\n\t\tfprintf(stderr, \"%s: waitpid failed: %s\\n\",\n\t\t\tprogname, strerror(errno));\n\t\treturn -1;\n\t}\n\tif (!WIFEXITED(status)) {\n\t\tfprintf(stderr, \"%s: child terminated abnormally (status %i)\\n\",\n\t\t\tprogname, status);\n\t\treturn -1;\n\t}\n\tif (WEXITSTATUS(status) != 0)\n\t\treturn -1;\n\treturn 0;\n}", "target": 0}
{"code": "cmsFloat32Number CMSEXPORT cmsEvalToneCurveFloat(const cmsToneCurve* Curve, cmsFloat32Number v)\n{\n    _cmsAssert(Curve != NULL);\n    if (Curve ->nSegments == 0) {\n        cmsUInt16Number In, Out;\n        In = (cmsUInt16Number) _cmsQuickSaturateWord(v * 65535.0);\n        Out = cmsEvalToneCurve16(Curve, In);\n        return (cmsFloat32Number) (Out / 65535.0);\n    }\n    return (cmsFloat32Number) EvalSegmentedFn(Curve, v);\n}", "target": 0}
{"code": "void decoder_context::compute_framedrop_table()\n{\n  int highestTID = get_highest_TID();\n  for (int tid=highestTID ; tid>=0 ; tid--) {\n    int lower  = 100 *  tid   /(highestTID+1);\n    int higher = 100 * (tid+1)/(highestTID+1);\n    for (int l=lower; l<=higher; l++) {\n      int ratio = 100 * (l-lower) / (higher-lower);\n      if (tid > limit_HighestTid) {\n        tid   = limit_HighestTid;\n        ratio = 100;\n      }\n      framedrop_tab[l].tid   = tid;\n      framedrop_tab[l].ratio = ratio;\n    }\n    framedrop_tid_index[tid] = higher;\n  }\n#if 0\n  for (int i=0;i<=100;i++) {\n    printf(\"%d%%: %d/%d\",i, framedrop_tab[i].tid, framedrop_tab[i].ratio);\n    for (int k=0;k<=highestTID;k++) {\n      if (framedrop_tid_index[k] == i) printf(\" ** TID=%d **\",k);\n    }\n    printf(\"\\n\");\n  }\n#endif\n}", "target": 0}
{"code": "void qemu_ram_set_idstr(ram_addr_t addr, const char *name, DeviceState *dev)\n{\n    RAMBlock *new_block, *block;\n    rcu_read_lock();\n    new_block = find_ram_block(addr);\n    assert(new_block);\n    assert(!new_block->idstr[0]);\n    if (dev) {\n        char *id = qdev_get_dev_path(dev);\n        if (id) {\n            snprintf(new_block->idstr, sizeof(new_block->idstr), \"%s/\", id);\n            g_free(id);\n        }\n    }\n    pstrcat(new_block->idstr, sizeof(new_block->idstr), name);\n    QLIST_FOREACH_RCU(block, &ram_list.blocks, next) {\n        if (block != new_block && !strcmp(block->idstr, new_block->idstr)) {\n            fprintf(stderr, \"RAMBlock \\\"%s\\\" already registered, abort!\\n\",\n                    new_block->idstr);\n            abort();\n        }\n    }\n    rcu_read_unlock();\n}", "target": 0}
{"code": "void LibRaw::hat_transform(float *temp, float *base, int st, int size, int sc)\n{\n  int i;\n  for (i = 0; i < sc; i++)\n    temp[i] = 2 * base[st * i] + base[st * (sc - i)] + base[st * (i + sc)];\n  for (; i + sc < size; i++)\n    temp[i] = 2 * base[st * i] + base[st * (i - sc)] + base[st * (i + sc)];\n  for (; i < size; i++)\n    temp[i] = 2 * base[st * i] + base[st * (i - sc)] +\n              base[st * (2 * size - 2 - (i + sc))];\n}", "target": 0}
{"code": "void smp_proc_discard(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n  SMP_TRACE_DEBUG(\"%s\", __func__);\n if (!(p_cb->flags & SMP_PAIR_FLAGS_WE_STARTED_DD))\n    smp_reset_control_value(p_cb);\n}", "target": 0}
{"code": "SMB2_request_res_key(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     u64 persistent_fid, u64 volatile_fid,\n\t\t     struct copychunk_ioctl *pcchunk)\n{\n\tint rc;\n\tunsigned int ret_data_len;\n\tstruct resume_key_req *res_key;\n\trc = SMB2_ioctl(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tFSCTL_SRV_REQUEST_RESUME_KEY, true ,\n\t\t\tNULL, 0 , CIFSMaxBufSize,\n\t\t\t(char **)&res_key, &ret_data_len);\n\tif (rc == -EOPNOTSUPP) {\n\t\tpr_warn_once(\"Server share %s does not support copy range\\n\", tcon->treeName);\n\t\tgoto req_res_key_exit;\n\t} else if (rc) {\n\t\tcifs_tcon_dbg(VFS, \"refcpy ioctl error %d getting resume key\\n\", rc);\n\t\tgoto req_res_key_exit;\n\t}\n\tif (ret_data_len < sizeof(struct resume_key_req)) {\n\t\tcifs_tcon_dbg(VFS, \"Invalid refcopy resume key length\\n\");\n\t\trc = -EINVAL;\n\t\tgoto req_res_key_exit;\n\t}\n\tmemcpy(pcchunk->SourceKey, res_key->ResumeKey, COPY_CHUNK_RES_KEY_SIZE);\nreq_res_key_exit:\n\tkfree(res_key);\n\treturn rc;\n}", "target": 0}
{"code": "static int mce_syscore_suspend(void)\n{\n\tvendor_disable_error_reporting();\n\treturn 0;\n}", "target": 0}
{"code": "GF_Err tref_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read_ex(s, bs, NULL, s->type);", "target": 0}
{"code": "static void nfs4_xdr_enc_open_downgrade(struct rpc_rqst *req,\n\t\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\t\tstruct nfs_closeargs *args)\n{\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_open_downgrade(xdr, args, &hdr);\n\tencode_getfattr(xdr, args->bitmask, &hdr);\n\tencode_nops(&hdr);\n}", "target": 0}
{"code": "void Item_ref_null_helper::print(String *str, enum_query_type query_type)\n{\n  str->append(STRING_WITH_LEN(\"<ref_null_helper>(\"));\n  if (ref)\n    (*ref)->print(str, query_type);\n  else\n    str->append('?');\n  str->append(')');\n}", "target": 0}
{"code": "parse_DECAP(char *arg, const struct ofpact_parse_params *pp)\n{\n    struct ofpact_decap *decap;\n    char *key, *value, *pos;\n    char *error = NULL;\n    uint16_t ns, type;\n    decap = ofpact_put_DECAP(pp->ofpacts);\n    decap->new_pkt_type = htonl(PT_USE_NEXT_PROTO);\n    if (ofputil_parse_key_value(&arg, &key, &value)) {\n        if (strcmp(key, \"packet_type\") == 0) {\n            pos = value;\n            if (!ofputil_parse_key_value(&pos, &key, &value)\n                || strcmp(key, \"ns\") != 0) {\n                return xstrdup(\"Missing packet_type attribute ns\");\n            }\n            error = str_to_u16(value, \"ns\", &ns);\n            if (error) {\n                return error;\n            }\n            if (ns >= OFPHTN_N_TYPES) {\n                return xasprintf(\"Unsupported ns value: %\"PRIu16, ns);\n            }\n            if (!ofputil_parse_key_value(&pos, &key, &value)\n                || strcmp(key, \"type\") != 0) {\n                return xstrdup(\"Missing packet_type attribute type\");\n            }\n            error = str_to_u16(value, \"type\", &type);\n            if (error) {\n                return error;\n            }\n            decap->new_pkt_type = htonl(PACKET_TYPE(ns, type));\n        } else {\n            return xasprintf(\"Invalid decap argument: %s\", key);\n        }\n    }\n    return NULL;\n}", "target": 0}
{"code": "ospf_make_ls_req_func (struct stream *s, u_int16_t *length,\n\t\t       unsigned long delta, struct ospf_neighbor *nbr,\n\t\t       struct ospf_lsa *lsa)\n{\n  struct ospf_interface *oi;\n  oi = nbr->oi;\n  if (*length + delta > ospf_packet_max(oi))\n    return 0;\n  stream_putl (s, lsa->data->type);\n  stream_put_ipv4 (s, lsa->data->id.s_addr);\n  stream_put_ipv4 (s, lsa->data->adv_router.s_addr);\n  ospf_lsa_unlock (&nbr->ls_req_last);\n  nbr->ls_req_last = ospf_lsa_lock (lsa);\n  *length += 12;\n  return 1;\n}", "target": 0}
{"code": "spnego_gss_verify_mic(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tconst gss_buffer_t msg_buffer,\n\t\tconst gss_buffer_t token_buffer,\n\t\tgss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tret = gss_verify_mic(minor_status,\n\t\t\t    context_handle,\n\t\t\t    msg_buffer,\n\t\t\t    token_buffer,\n\t\t\t    qop_state);\n\treturn (ret);\n}", "target": 0}
{"code": "isdn_net_newslave(char *parm)\n{\n\tchar *p = strchr(parm, ',');\n\tisdn_net_dev *n;\n\tchar newname[10];\n\tif (p) {\n\t\tif (!strlen(p + 1))\n\t\t\treturn NULL;\n\t\tstrcpy(newname, p + 1);\n\t\t*p = 0;\n\t\tif (!(n = isdn_net_findif(parm)))\n\t\t\treturn NULL;\n\t\tif (n->local->master)\n\t\t\treturn NULL;\n\t\tif (isdn_net_device_started(n)) \n\t\t\treturn NULL;\n\t\treturn (isdn_net_new(newname, n->dev));\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "sshpam_init(const char *user)\n{\n\textern ServerOptions options;\n\textern u_int utmp_len;\n\tconst char *pam_rhost, *pam_user;\n\tif (sshpam_handle != NULL) {\n\t\tsshpam_err = pam_get_item(sshpam_handle,\n\t\t    PAM_USER, (const void **)&pam_user);\n\t\tif (sshpam_err == PAM_SUCCESS && strcmp(user, pam_user) == 0)\n\t\t\treturn (0);\n\t\tfatal_remove_cleanup(sshpam_cleanup, NULL);\n\t\tpam_end(sshpam_handle, sshpam_err);\n\t\tsshpam_handle = NULL;\n\t}\n\tdebug(\"PAM: initializing for \\\"%s\\\"\", user);\n\tsshpam_err = pam_start(\"sshd\", user, &null_conv, &sshpam_handle);\n\tif (sshpam_err != PAM_SUCCESS)\n\t\treturn (-1);\n\tpam_rhost = get_remote_name_or_ip(utmp_len,\n\t    options.verify_reverse_mapping);\n\tdebug(\"PAM: setting PAM_RHOST to \\\"%s\\\"\", pam_rhost);\n\tsshpam_err = pam_set_item(sshpam_handle, PAM_RHOST, pam_rhost);\n\tif (sshpam_err != PAM_SUCCESS) {\n\t\tpam_end(sshpam_handle, sshpam_err);\n\t\tsshpam_handle = NULL;\n\t\treturn (-1);\n\t}\n\tfatal_add_cleanup(sshpam_cleanup, NULL);\n\treturn (0);\n}", "target": 0}
{"code": "object_removed (GDBusObjectManager *manager,\n\t        GDBusObject        *object,\n\t        BluetoothClient    *client)\n{\n\tGList *interfaces, *l;\n\tinterfaces = g_dbus_object_get_interfaces (object);\n\tfor (l = interfaces; l != NULL; l = l->next)\n\t\tinterface_removed (manager, object, G_DBUS_INTERFACE (l->data), client);\n\tg_list_free_full (interfaces, g_object_unref);\n}", "target": 0}
{"code": "smtp_getc(unsigned lim)\n{\nif (smtp_inptr >= smtp_inend)\n  if (!smtp_refill(lim))\n    return EOF;\nreturn *smtp_inptr++;\n}", "target": 0}
{"code": "soup_server_get_async_context (SoupServer *server)\n{\n\tSoupServerPrivate *priv;\n\tg_return_val_if_fail (SOUP_IS_SERVER (server), NULL);\n\tpriv = SOUP_SERVER_GET_PRIVATE (server);\n\treturn priv->async_context;\n}", "target": 0}
{"code": "GfxICCBasedColorSpace::GfxICCBasedColorSpace(int nCompsA, GfxColorSpace *altA, const Ref *iccProfileStreamA)\n{\n    nComps = nCompsA;\n    alt = altA;\n    iccProfileStream = *iccProfileStreamA;\n    rangeMin[0] = rangeMin[1] = rangeMin[2] = rangeMin[3] = 0;\n    rangeMax[0] = rangeMax[1] = rangeMax[2] = rangeMax[3] = 1;\n#ifdef USE_CMS\n    transform = nullptr;\n    lineTransform = nullptr;\n    psCSA = nullptr;\n#endif\n}", "target": 0}
{"code": "static inline unsigned long __meminit zone_absent_pages_in_node(int nid,\n\t\t\t\t\t\tunsigned long zone_type,\n\t\t\t\t\t\tunsigned long node_start_pfn,\n\t\t\t\t\t\tunsigned long node_end_pfn,\n\t\t\t\t\t\tunsigned long *zholes_size)\n{\n\tif (!zholes_size)\n\t\treturn 0;\n\treturn zholes_size[zone_type];\n}", "target": 0}
{"code": "void ciEnv::report_failure(const char* reason) {\n  EventCompilationFailure event;\n  if (event.should_commit()) {\n    event.set_compileId(compile_id());\n    event.set_failureMessage(reason);\n    event.commit();\n  }\n}", "target": 0}
{"code": "    void Converter::cnvIptcValue(const char* from, const char* to)\n    {\n        Exiv2::IptcData::iterator pos = iptcData_->findKey(IptcKey(from));\n        if (pos == iptcData_->end()) return;\n        if (!prepareXmpTarget(to)) return;\n        while (pos != iptcData_->end()) {\n            if (pos->key() == from) {\n                std::string value = pos->toString();\n                if (!pos->value().ok()) {\n#ifndef SUPPRESS_WARNINGS\n                    EXV_WARNING << \"Failed to convert \" << from << \" to \" << to << \"\\n\";\n#endif\n                    ++pos;\n                    continue;\n                }\n                if (iptcCharset_) convertStringCharset(value, iptcCharset_, \"UTF-8\");\n                (*xmpData_)[to] = value;\n                if (erase_) {\n                    pos = iptcData_->erase(pos);\n                    continue;\n                }\n            }\n            ++pos;\n        }\n    }", "target": 0}
{"code": "void lodepng_info_swap(LodePNGInfo* a, LodePNGInfo* b)\n{\n  LodePNGInfo temp = *a;\n  *a = *b;\n  *b = temp;\n}", "target": 0}
{"code": "void STDCALL mysql_thread_end()\n{\n  my_thread_end();\n}", "target": 0}
{"code": "static struct fuse_module *fuse_get_module(const char *module)\n{\n    struct fuse_module *m;\n    pthread_mutex_lock(&fuse_context_lock);\n    m = fuse_find_module(module);\n    if (!m) {\n        int err = fuse_load_so_module(module);\n        if (!err)\n            m = fuse_find_module(module);\n    }\n    pthread_mutex_unlock(&fuse_context_lock);\n    return m;\n}", "target": 0}
{"code": "static void set_time(int initialize) {\n\tstruct tm tm;\n\tstatic int isdst;\n\tStartTime = time(NULL);\n\ttm = *localtime(&StartTime);\n\tif (initialize || tm.tm_isdst != isdst) {\n\t\tisdst = tm.tm_isdst;\n\t\tGMToff = get_gmtoff(&StartTime, &tm);\n\t\tDebug(DSCH, (\"[%ld] GMToff=%ld\\n\", (long) getpid(), (long) GMToff))\n\t}\n\tclockTime = (StartTime + GMToff) / (time_t) SECONDS_PER_MINUTE;\n}", "target": 0}
{"code": "count_callers (cgraph_node *node, void *data)\n{\n  int *caller_count = (int *) data;\n  for (cgraph_edge *cs = node->callers; cs; cs = cs->next_caller)\n    if (!cs->caller->thunk.thunk_p || !cs->caller->local)\n      ++*caller_count;\n  return false;\n}", "target": 0}
{"code": "Hints::Hints(BaseStream *str, Linearization *linearization, XRef *xref, SecurityHandler *secHdlr)\n{\n    mainXRefEntriesOffset = linearization->getMainXRefEntriesOffset();\n    nPages = linearization->getNumPages();\n    pageFirst = linearization->getPageFirst();\n    pageEndFirst = linearization->getEndFirst();\n    pageObjectFirst = linearization->getObjectNumberFirst();\n    if (pageObjectFirst < 0 || pageObjectFirst >= xref->getNumObjects()) {\n        error(errSyntaxWarning, -1, \"Invalid reference for first page object ({0:d}) in linearization table \", pageObjectFirst);\n        pageObjectFirst = 0;\n    }\n    XRefEntry *pageObjectFirstXRefEntry = xref->getEntry(pageObjectFirst);\n    if (!pageObjectFirstXRefEntry) {\n        error(errSyntaxWarning, -1, \"No XRef entry for first page object\");\n        pageOffsetFirst = 0;\n    } else {\n        pageOffsetFirst = pageObjectFirstXRefEntry->offset;\n    }\n    if (nPages >= INT_MAX / (int)sizeof(unsigned int)) {\n        error(errSyntaxWarning, -1, \"Invalid number of pages ({0:d}) for hints table\", nPages);\n        nPages = 0;\n    }\n    nObjects = (unsigned int *)gmallocn_checkoverflow(nPages, sizeof(unsigned int));\n    pageObjectNum = (int *)gmallocn_checkoverflow(nPages, sizeof(int));\n    xRefOffset = (unsigned int *)gmallocn_checkoverflow(nPages, sizeof(unsigned int));\n    pageLength = (unsigned int *)gmallocn_checkoverflow(nPages, sizeof(unsigned int));\n    pageOffset = (Goffset *)gmallocn_checkoverflow(nPages, sizeof(Goffset));\n    numSharedObject = (unsigned int *)gmallocn_checkoverflow(nPages, sizeof(unsigned int));\n    sharedObjectId = (unsigned int **)gmallocn_checkoverflow(nPages, sizeof(unsigned int *));\n    if (!nObjects || !pageObjectNum || !xRefOffset || !pageLength || !pageOffset || !numSharedObject || !sharedObjectId) {\n        error(errSyntaxWarning, -1, \"Failed to allocate memory for hints table\");\n        nPages = 0;\n    }\n    if (nPages != 0) {\n        memset(pageLength, 0, nPages * sizeof(unsigned int));\n        memset(pageOffset, 0, nPages * sizeof(unsigned int));\n        memset(numSharedObject, 0, nPages * sizeof(unsigned int));\n        memset(pageObjectNum, 0, nPages * sizeof(int));\n    }\n    groupLength = nullptr;\n    groupOffset = nullptr;\n    groupHasSignature = nullptr;\n    groupNumObjects = nullptr;\n    groupXRefOffset = nullptr;\n    ok = true;\n    readTables(str, linearization, xref, secHdlr);\n}", "target": 0}
{"code": "string lua_text_pattern::new_fn_name()\n{\n    return make_stringf(\"__ch_stash_search_%u\", lfndx++);\n}", "target": 0}
{"code": "FoFiTrueType::FoFiTrueType(char *fileA, int lenA, GBool freeFileDataA, int faceIndexA):\n  FoFiBase(fileA, lenA, freeFileDataA)\n{\n  tables = NULL;\n  nTables = 0;\n  cmaps = NULL;\n  nCmaps = 0;\n  nameToGID = NULL;\n  parsedOk = gFalse;\n  faceIndex = faceIndexA;\n  gsubFeatureTable = 0;\n  gsubLookupList = 0;\n  parse();\n}", "target": 0}
{"code": "vmcs12_guest_cr4(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12)\n{\n\treturn\n\t\t(vmcs_readl(GUEST_CR4) & vcpu->arch.cr4_guest_owned_bits) |\n\t\t(vmcs12->guest_cr4 & vmcs12->cr4_guest_host_mask) |\n\t\t(vmcs_readl(CR4_READ_SHADOW) & ~(vmcs12->cr4_guest_host_mask |\n\t\t\tvcpu->arch.cr4_guest_owned_bits));\n}", "target": 0}
{"code": "static void vnc_register_config(void)\n{\n    qemu_add_opts(&qemu_vnc_opts);\n}", "target": 0}
{"code": "static void usb_net_handle_data(USBDevice *dev, USBPacket *p)\n{\n    USBNetState *s = (USBNetState *) dev;\n    switch(p->pid) {\n    case USB_TOKEN_IN:\n        switch (p->ep->nr) {\n        case 1:\n            usb_net_handle_statusin(s, p);\n            break;\n        case 2:\n            usb_net_handle_datain(s, p);\n            break;\n        default:\n            goto fail;\n        }\n        break;\n    case USB_TOKEN_OUT:\n        switch (p->ep->nr) {\n        case 2:\n            usb_net_handle_dataout(s, p);\n            break;\n        default:\n            goto fail;\n        }\n        break;\n    default:\n    fail:\n        p->status = USB_RET_STALL;\n        break;\n    }\n    if (p->status == USB_RET_STALL) {\n        fprintf(stderr, \"usbnet: failed data transaction: \"\n                        \"pid 0x%x ep 0x%x len 0x%zx\\n\",\n                        p->pid, p->ep->nr, p->iov.size);\n    }\n}", "target": 0}
{"code": "static void __vsock_insert_connected(struct list_head *list,\n\t\t\t\t     struct vsock_sock *vsk)\n{\n\tsock_hold(&vsk->sk);\n\tlist_add(&vsk->connected_table, list);\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, PlansForMultipleIndexesOnTheSameKeyPatternAreGenerated) {\n    CollatorInterfaceMock reverseCollator(CollatorInterfaceMock::MockType::kReverseString);\n    CollatorInterfaceMock equalCollator(CollatorInterfaceMock::MockType::kAlwaysEqual);\n    addIndex(BSON(\"a\" << 1), &reverseCollator, \"reverse\"_sd);\n    addIndex(BSON(\"a\" << 1), &equalCollator, \"forward\"_sd);\n    runQuery(BSON(\"a\" << 1));\n    assertNumSolutions(3U);\n    assertSolutionExists(\"{fetch: {node: {ixscan: {name: 'reverse'}}}}\");\n    assertSolutionExists(\"{fetch: {node: {ixscan: {name: 'forward'}}}}\");\n    assertSolutionExists(\"{cscan: {dir: 1}}}}\");\n}", "target": 0}
{"code": "GF_Err gf_isom_get_sample_to_group_info(GF_ISOFile *the_file, u32 trackNumber, u32 sample_number, u32 grouping_type, u32 grouping_type_param, u32 *sampleGroupDescIndex)\n{\n\tGF_TrackBox *trak;\n\tu32 i, count;\n\tif (!grouping_type || !sampleGroupDescIndex) return GF_BAD_PARAM;\n\t*sampleGroupDescIndex = 0;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->sampleGroups) return GF_OK;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sample_number <= trak->sample_count_at_seg_start) return GF_BAD_PARAM;\n\tsample_number -= trak->sample_count_at_seg_start;\n#endif\n\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroups);\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupBox *sg;\n\t\tu32 j;\n\t\tu32 first_sample_in_entry, last_sample_in_entry;\n\t\tfirst_sample_in_entry = 1;\n\t\tsg = (GF_SampleGroupBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroups, i);\n\t\tif (sg->grouping_type != grouping_type) continue;\n\t\tif (sg->grouping_type_parameter != grouping_type_param) continue;\n\t\tfor (j=0; j<sg->entry_count; j++) {\n\t\t\tlast_sample_in_entry = first_sample_in_entry + sg->sample_entries[j].sample_count - 1;\n\t\t\tif ((sample_number<first_sample_in_entry) || (sample_number>last_sample_in_entry)) {\n\t\t\t\tfirst_sample_in_entry = last_sample_in_entry+1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t*sampleGroupDescIndex = sg->sample_entries[j].group_description_index;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "init_caller_stats (struct caller_statistics *stats)\n{\n  stats->count_sum = profile_count::zero ();\n  stats->n_calls = 0;\n  stats->n_hot_calls = 0;\n  stats->freq_sum = 0;\n}", "target": 0}
{"code": "int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t       struct inode *new_dir, struct dentry *new_dentry)\n{\n\tint error;\n\tint is_dir = S_ISDIR(old_dentry->d_inode->i_mode);\n\tconst unsigned char *old_name;\n\tif (old_dentry->d_inode == new_dentry->d_inode)\n \t\treturn 0;\n\terror = may_delete(old_dir, old_dentry, is_dir);\n\tif (error)\n\t\treturn error;\n\tif (!new_dentry->d_inode)\n\t\terror = may_create(new_dir, new_dentry);\n\telse\n\t\terror = may_delete(new_dir, new_dentry, is_dir);\n\tif (error)\n\t\treturn error;\n\tif (!old_dir->i_op->rename)\n\t\treturn -EPERM;\n\told_name = fsnotify_oldname_init(old_dentry->d_name.name);\n\tif (is_dir)\n\t\terror = vfs_rename_dir(old_dir,old_dentry,new_dir,new_dentry);\n\telse\n\t\terror = vfs_rename_other(old_dir,old_dentry,new_dir,new_dentry);\n\tif (!error)\n\t\tfsnotify_move(old_dir, new_dir, old_name, is_dir,\n\t\t\t      new_dentry->d_inode, old_dentry);\n\tfsnotify_oldname_free(old_name);\n\treturn error;\n}", "target": 0}
{"code": "void RootWindow::OnLayerAnimationEnded(\n    ui::LayerAnimationSequence* animation) {\n  OnHostResized(host_->GetBounds().size());\n}", "target": 0}
{"code": "bool Item_field::add_field_to_set_processor(uchar *arg)\n{\n  DBUG_ENTER(\"Item_field::add_field_to_set_processor\");\n  DBUG_PRINT(\"info\", (\"%s\", field->field_name ? field->field_name : \"noname\"));\n  TABLE *table= (TABLE *) arg;\n  if (field->table == table)\n    bitmap_set_bit(&table->tmp_set, field->field_index);\n  DBUG_RETURN(FALSE);\n}", "target": 0}
{"code": "static struct dmar_domain *find_domain(struct device *dev)\n{\n\tstruct device_domain_info *info;\n\tinfo = dev->archdata.iommu;\n\tif (likely(info))\n\t\treturn info->domain;\n\treturn NULL;\n}", "target": 0}
{"code": "void PrepareFrameAndViewForPrint::CopySelectionIfNeeded(\n    const WebPreferences& preferences,\n    const base::Closure& on_ready) {\n  on_ready_ = on_ready;\n  if (should_print_selection_only_) {\n    CopySelection(preferences);\n  } else {\n    CallOnReady();\n  }\n}", "target": 0}
{"code": "parse_emph3(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size, uint8_t c)\n{\n\tsize_t i = 0, len;\n\tint r;\n\twhile (i < size) {\n\t\tlen = find_emph_char(data + i, size - i, c);\n\t\tif (!len) return 0;\n\t\ti += len;\n\t\tif (data[i] != c || _isspace(data[i - 1]))\n\t\t\tcontinue;\n\t\tif (i + 2 < size && data[i + 1] == c && data[i + 2] == c && rndr->cb.triple_emphasis) {\n\t\t\tstruct buf *work = rndr_newbuf(rndr, BUFFER_SPAN);\n\t\t\tparse_inline(work, rndr, data, i);\n\t\t\tr = rndr->cb.triple_emphasis(ob, work, rndr->opaque);\n\t\t\trndr_popbuf(rndr, BUFFER_SPAN);\n\t\t\treturn r ? i + 3 : 0;\n\t\t} else if (i + 1 < size && data[i + 1] == c) {\n\t\t\tlen = parse_emph1(ob, rndr, data - 2, size + 2, c);\n\t\t\tif (!len) return 0;\n\t\t\telse return len - 2;\n\t\t} else {\n\t\t\tlen = parse_emph2(ob, rndr, data - 1, size + 1, c);\n\t\t\tif (!len) return 0;\n\t\t\telse return len - 1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static void recalibrate_floppy(void)\n{\n\tdebugt(__func__, \"\");\n\tdo_floppy = recal_interrupt;\n\toutput_byte(FD_RECALIBRATE);\n\tif (output_byte(UNIT(current_drive)) < 0)\n\t\treset_fdc();\n}", "target": 0}
{"code": "  IndexedDBDatabaseTest() : lock_manager_(kIndexedDBLockLevelCount) {}", "target": 0}
{"code": "QString RemoteFsDevice::createUdi(const QString &n)\n{\n    return constCfgPrefix+n;\n}", "target": 0}
{"code": "  static unsigned sgetn(int n, uchar *s)\n  {\n    unsigned result = 0;\n    while (n-- > 0)\n      result = (result << 8) | (*s++);\n    return result;\n  }", "target": 0}
{"code": "respond_to_end_session (GDBusProxy *proxy)\n{\n  GVariant *parameters;\n  parameters = g_variant_new (\"(bs)\", TRUE, \"\");\n  g_dbus_proxy_call (proxy,\n                     \"EndSessionResponse\", parameters,\n                     G_DBUS_CALL_FLAGS_NONE,\n                     -1, NULL, NULL, NULL);\n}", "target": 0}
{"code": "code_to_mbc(OnigCodePoint code, UChar *buf, OnigEncoding enc)\n{\n  UChar *p = buf;\n  if ((code & 0xff000000) != 0) *p++ = (UChar )(((code >> 24) & 0xff));\n  if ((code &   0xff0000) != 0) *p++ = (UChar )(((code >> 16) & 0xff));\n  if ((code &     0xff00) != 0) *p++ = (UChar )(((code >>  8) & 0xff));\n  *p++ = (UChar )(code & 0xff);\n  if (enclen(enc, buf, p) != (p - buf))\n    return ONIGERR_INVALID_CODE_POINT_VALUE;\n  return (int)(p - buf);\n}", "target": 0}
{"code": "void __init setup_per_cpu_areas(void)\n{ \n\tint i;\n\tunsigned long size;\n#ifdef CONFIG_HOTPLUG_CPU\n\tprefill_possible_map();\n#endif\n\tsize = PERCPU_ENOUGH_ROOM;\n\tprintk(KERN_INFO \"PERCPU: Allocating %lu bytes of per cpu data\\n\", size);\n\tfor_each_cpu_mask (i, cpu_possible_map) {\n\t\tchar *ptr;\n\t\tif (!NODE_DATA(cpu_to_node(i))) {\n\t\t\tprintk(\"cpu with no node %d, num_online_nodes %d\\n\",\n\t\t\t       i, num_online_nodes());\n\t\t\tptr = alloc_bootmem(size);\n\t\t} else { \n\t\t\tptr = alloc_bootmem_node(NODE_DATA(cpu_to_node(i)), size);\n\t\t}\n\t\tif (!ptr)\n\t\t\tpanic(\"Cannot allocate cpu data for CPU %d\\n\", i);\n\t\tcpu_pda(i)->data_offset = ptr - __per_cpu_start;\n\t\tmemcpy(ptr, __per_cpu_start, __per_cpu_end - __per_cpu_start);\n\t}\n} ", "target": 0}
{"code": "int mem_cgroup_sockets_init(struct cgroup *cgrp, struct cgroup_subsys *ss)\n{\n\tstruct proto *proto;\n\tint ret = 0;\n\tmutex_lock(&proto_list_mutex);\n\tlist_for_each_entry(proto, &proto_list, node) {\n\t\tif (proto->init_cgroup) {\n\t\t\tret = proto->init_cgroup(cgrp, ss);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_unlock(&proto_list_mutex);\n\treturn ret;\nout:\n\tlist_for_each_entry_continue_reverse(proto, &proto_list, node)\n\t\tif (proto->destroy_cgroup)\n\t\t\tproto->destroy_cgroup(cgrp);\n\tmutex_unlock(&proto_list_mutex);\n\treturn ret;\n}", "target": 0}
{"code": "static ssize_t write_null(struct file *file, const char __user *buf,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\treturn count;\n}", "target": 0}
{"code": "GF_Err sgpd_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 entry_count;\n\tGF_SampleGroupDescriptionBox *p = (GF_SampleGroupDescriptionBox *)s;\n\tISOM_DECREASE_SIZE(p, 8);\n\tp->grouping_type = gf_bs_read_u32(bs);\n\tif (p->version>=1) {\n\t\tISOM_DECREASE_SIZE(p, 4);\n\t\tp->default_length = gf_bs_read_u32(bs);\n\t}\n\tif (p->version>=2) {\n\t\tISOM_DECREASE_SIZE(p, 4);\n\t\tp->default_description_index = gf_bs_read_u32(bs);\n\t}\n\tentry_count = gf_bs_read_u32(bs);\n\tif (entry_count>p->size)\n\t\treturn GF_ISOM_INVALID_FILE;\n\twhile (entry_count) {\n\t\tvoid *ptr;\n\t\tu32 parsed_bytes=0;\n\t\tu32 size = p->default_length;\n\t\tif ((p->version>=1) && !size) {\n\t\t\tsize = gf_bs_read_u32(bs);\n\t\t\tISOM_DECREASE_SIZE(p, 4);\n\t\t}\n\t\tptr = sgpd_parse_entry(p->grouping_type, bs, size, &parsed_bytes);\n\t\tif (!ptr) return GF_OK;\n\t\tISOM_DECREASE_SIZE(p, parsed_bytes);\n\t\tgf_list_add(p->group_descriptions, ptr);\n\t\tentry_count--;\n\t}\n\treturn GF_OK;", "target": 0}
{"code": "static long sock_wait_for_wmem(struct sock *sk, long timeo)\n{\n\tDEFINE_WAIT(wait);\n\tclear_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags);\n\tfor (;;) {\n\t\tif (!timeo)\n\t\t\tbreak;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tset_bit(SOCK_NOSPACE, &sk->sk_socket->flags);\n\t\tprepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);\n\t\tif (atomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf)\n\t\t\tbreak;\n\t\tif (sk->sk_shutdown & SEND_SHUTDOWN)\n\t\t\tbreak;\n\t\tif (sk->sk_err)\n\t\t\tbreak;\n\t\ttimeo = schedule_timeout(timeo);\n\t}\n\tfinish_wait(sk_sleep(sk), &wait);\n\treturn timeo;\n}", "target": 0}
{"code": "lsof_parse (const char *stdout,\n            GPtrArray *processes)\n{\n  int n;\n  char **tokens;\n  tokens = g_strsplit (stdout, \"\\n\", 0);\n  for (n = 0; tokens[n] != NULL; n++)\n    {\n      pid_t pid;\n      uid_t uid;\n      char *command_line;\n      GValue elem =\n        { 0 };\n      if (strlen (tokens[n]) == 0)\n        continue;\n      pid = strtol (tokens[n], NULL, 0);\n      uid = get_uid_for_pid (pid);\n      command_line = get_command_line_for_pid (pid);\n      g_value_init (&elem, LSOF_DATA_STRUCT_TYPE);\n      g_value_take_boxed (&elem, dbus_g_type_specialized_construct (LSOF_DATA_STRUCT_TYPE));\n      dbus_g_type_struct_set (&elem, 0, pid, 1, uid, 2, command_line != NULL ? command_line : \"\", G_MAXUINT);\n      g_ptr_array_add (processes, g_value_get_boxed (&elem));\n      g_free (command_line);\n    }\n  g_strfreev (tokens);\n}", "target": 0}
{"code": "static inline char *_validate_env(const char *env)\n{\n    char *res, *c;\n    if (env)\n        res = g_strdup(env);\n    else\n        res = g_strdup(\"\");\n    for (c = res; *c; c++)\n        if (*c == '\\n' || *c == '\\t')\n            *c = ' ';\n    return res;\n}", "target": 0}
{"code": "perform_estimation_of_a_value (cgraph_node *node, vec<tree> known_csts,\n\t\t\t       vec<ipa_polymorphic_call_context> known_contexts,\n\t\t\t       vec<ipa_agg_value_set> known_aggs,\n\t\t\t       int removable_params_cost,\n\t\t\t       int est_move_cost, ipcp_value_base *val)\n{\n  int size, time_benefit;\n  sreal time, base_time;\n  ipa_hints hints;\n  estimate_ipcp_clone_size_and_time (node, known_csts, known_contexts,\n\t\t\t\t     known_aggs, &size, &time,\n\t\t\t\t     &base_time, &hints);\n  base_time -= time;\n  if (base_time > 65535)\n    base_time = 65535;\n  if (DECL_EXTERNAL (node->decl) && DECL_DECLARED_INLINE_P (node->decl))\n    time_benefit = 0;\n  else\n    time_benefit = base_time.to_int ()\n      + devirtualization_time_bonus (node, known_csts, known_contexts,\n\t\t\t\t     known_aggs)\n      + hint_time_bonus (hints)\n      + removable_params_cost + est_move_cost;\n  gcc_checking_assert (size >=0);\n  if (size == 0)\n    size = 1;\n  val->local_time_benefit = time_benefit;\n  val->local_size_cost = size;\n}", "target": 0}
{"code": "static int vhost_user_set_log_fd(struct virtio_net **pdev __rte_unused,\n\t\t\tstruct VhostUserMsg *msg,\n\t\t\tint main_fd __rte_unused)\n{\n\tif (validate_msg_fds(msg, 1) != 0)\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\tclose(msg->fds[0]);\n\tVHOST_LOG_CONFIG(INFO, \"not implemented.\\n\");\n\treturn RTE_VHOST_MSG_RESULT_OK;\n}", "target": 0}
{"code": "yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, RE_LEX_ENVIRONMENT *lex_env)\n{\n  YYUSE (yyvaluep);\n  YYUSE (yyscanner);\n  YYUSE (lex_env);\n  if (!yymsg)\n    yymsg = \"Deleting\";\n  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n   switch (yytype)\n     {\n           case 6: \n#line 104 \"re_grammar.y\" \n       { yr_free(((*yyvaluep).class_vector)); }\n#line 1053 \"re_grammar.c\" \n         break;\n     case 26: \n#line 105 \"re_grammar.y\" \n       { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1059 \"re_grammar.c\" \n         break;\n     case 27: \n#line 106 \"re_grammar.y\" \n       { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1065 \"re_grammar.c\" \n         break;\n     case 28: \n#line 107 \"re_grammar.y\" \n       { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1071 \"re_grammar.c\" \n         break;\n     case 29: \n#line 108 \"re_grammar.y\" \n       { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1077 \"re_grammar.c\" \n         break;\n      default:\n        break;\n    }\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n}", "target": 0}
{"code": "static struct sctp_chunk *_sctp_make_chunk(const struct sctp_association *asoc,\n\t\t\t\t\t    __u8 type, __u8 flags, int paylen)\n{\n\tstruct sctp_chunk *retval;\n\tsctp_chunkhdr_t *chunk_hdr;\n\tstruct sk_buff *skb;\n\tstruct sock *sk;\n\tskb = alloc_skb(WORD_ROUND(sizeof(sctp_chunkhdr_t) + paylen),\n\t\t\tGFP_ATOMIC);\n\tif (!skb)\n\t\tgoto nodata;\n\tchunk_hdr = (sctp_chunkhdr_t *)skb_put(skb, sizeof(sctp_chunkhdr_t));\n\tchunk_hdr->type\t  = type;\n\tchunk_hdr->flags  = flags;\n\tchunk_hdr->length = htons(sizeof(sctp_chunkhdr_t));\n\tsk = asoc ? asoc->base.sk : NULL;\n\tretval = sctp_chunkify(skb, asoc, sk);\n\tif (!retval) {\n\t\tkfree_skb(skb);\n\t\tgoto nodata;\n\t}\n\tretval->chunk_hdr = chunk_hdr;\n\tretval->chunk_end = ((__u8 *)chunk_hdr) + sizeof(struct sctp_chunkhdr);\n\tif (sctp_auth_send_cid(type, asoc))\n\t\tretval->auth = 1;\n\treturn retval;\nnodata:\n\treturn NULL;\n}", "target": 0}
{"code": "ok_png ok_png_read(FILE *file, ok_png_decode_flags decode_flags) {\n    return ok_png_read_with_allocator(file, decode_flags, OK_PNG_DEFAULT_ALLOCATOR, NULL);\n}", "target": 0}
{"code": "    Image::UniquePtr newJpegInstance(BasicIo::UniquePtr io, bool create)\n    {\n        Image::UniquePtr image(new JpegImage(std::move(io), create));\n        if (!image->good()) {\n            image.reset();\n        }\n        return image;\n    }", "target": 0}
{"code": "xfs_bmap_btalloc_filestreams(\n\tstruct xfs_bmalloca\t*ap,\n\tstruct xfs_alloc_arg\t*args,\n\txfs_extlen_t\t\t*blen)\n{\n\tstruct xfs_mount\t*mp = ap->ip->i_mount;\n\txfs_agnumber_t\t\tag;\n\tint\t\t\tnotinit = 0;\n\tint\t\t\terror;\n\targs->type = XFS_ALLOCTYPE_NEAR_BNO;\n\targs->total = ap->total;\n\tag = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\tif (ag == NULLAGNUMBER)\n\t\tag = 0;\n\terror = xfs_bmap_longest_free_extent(args->tp, ag, blen, &notinit);\n\tif (error)\n\t\treturn error;\n\tif (*blen < args->maxlen) {\n\t\terror = xfs_filestream_new_ag(ap, &ag);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_bmap_longest_free_extent(args->tp, ag, blen,\n\t\t\t\t\t\t     &notinit);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\txfs_bmap_select_minlen(ap, args, blen, notinit);\n\tap->blkno = args->fsbno = XFS_AGB_TO_FSB(mp, ag, 0);\n\treturn 0;\n}", "target": 0}
{"code": "void LibRaw::fbdd_correction2(double (*image2)[3])\n{\n  int indx, u = width, v = 2 * width;\n  int col, row;\n  double Co, Ho, ratio;\n  for (row = 6; row < height - 6; row++)\n  {\n    for (col = 6; col < width - 6; col++)\n    {\n      indx = row * width + col;\n      if (image2[indx][1] * image2[indx][2] != 0)\n      {\n        Co = (image2[indx + v][1] + image2[indx - v][1] + image2[indx - 2][1] +\n              image2[indx + 2][1] -\n              MAX(image2[indx - 2][1],\n                  MAX(image2[indx + 2][1],\n                      MAX(image2[indx - v][1], image2[indx + v][1]))) -\n              MIN(image2[indx - 2][1],\n                  MIN(image2[indx + 2][1],\n                      MIN(image2[indx - v][1], image2[indx + v][1])))) /\n             2.0;\n        Ho = (image2[indx + v][2] + image2[indx - v][2] + image2[indx - 2][2] +\n              image2[indx + 2][2] -\n              MAX(image2[indx - 2][2],\n                  MAX(image2[indx + 2][2],\n                      MAX(image2[indx - v][2], image2[indx + v][2]))) -\n              MIN(image2[indx - 2][2],\n                  MIN(image2[indx + 2][2],\n                      MIN(image2[indx - v][2], image2[indx + v][2])))) /\n             2.0;\n        ratio = sqrt((Co * Co + Ho * Ho) / (image2[indx][1] * image2[indx][1] +\n                                            image2[indx][2] * image2[indx][2]));\n        if (ratio < 0.85)\n        {\n          image2[indx][0] =\n              -(image2[indx][1] + image2[indx][2] - Co - Ho) + image2[indx][0];\n          image2[indx][1] = Co;\n          image2[indx][2] = Ho;\n        }\n      }\n    }\n  }\n}", "target": 0}
{"code": "isdn_ppp_fill_rq(unsigned char *buf, int len, int proto, int slot)\n{\n\tstruct ippp_buf_queue *bf, *bl;\n\tu_long flags;\n\tu_char *nbuf;\n\tstruct ippp_struct *is;\n\tif (slot < 0 || slot >= ISDN_MAX_CHANNELS) {\n\t\tprintk(KERN_WARNING \"ippp: illegal slot(%d).\\n\", slot);\n\t\treturn 0;\n\t}\n\tis = ippp_table[slot];\n\tif (!(is->state & IPPP_CONNECT)) {\n\t\tprintk(KERN_DEBUG \"ippp: device not activated.\\n\");\n\t\treturn 0;\n\t}\n\tnbuf = kmalloc(len + 4, GFP_ATOMIC);\n\tif (!nbuf) {\n\t\tprintk(KERN_WARNING \"ippp: Can't alloc buf\\n\");\n\t\treturn 0;\n\t}\n\tnbuf[0] = PPP_ALLSTATIONS;\n\tnbuf[1] = PPP_UI;\n\tnbuf[2] = proto >> 8;\n\tnbuf[3] = proto & 0xff;\n\tmemcpy(nbuf + 4, buf, len);\n\tspin_lock_irqsave(&is->buflock, flags);\n\tbf = is->first;\n\tbl = is->last;\n\tif (bf == bl) {\n\t\tprintk(KERN_WARNING \"ippp: Queue is full; discarding first buffer\\n\");\n\t\tbf = bf->next;\n\t\tkfree(bf->buf);\n\t\tis->first = bf;\n\t}\n\tbl->buf = (char *) nbuf;\n\tbl->len = len + 4;\n\tis->last = bl->next;\n\tspin_unlock_irqrestore(&is->buflock, flags);\n\twake_up_interruptible(&is->wq);\n\treturn len;\n}", "target": 0}
{"code": "find_single_ipv6_orport(const smartlist_t *list,\n                        tor_addr_t *addr_out,\n                        uint16_t *port_out)\n{\n  int ret = 0;\n  tor_assert(list != NULL);\n  tor_assert(addr_out != NULL);\n  tor_assert(port_out != NULL);\n  SMARTLIST_FOREACH_BEGIN(list, directory_token_t *, t) {\n    tor_addr_t a;\n    maskbits_t bits;\n    uint16_t port_min, port_max;\n    tor_assert(t->n_args >= 1);\n    if (tor_addr_parse_mask_ports(t->args[0], 0,\n                                  &a, &bits, &port_min,\n                                  &port_max) == AF_INET6 &&\n        bits == 128 &&\n        port_min == port_max) {\n      tor_addr_copy(addr_out, &a);\n      *port_out = port_min;\n      ret = 1;\n      break;\n    }\n  } SMARTLIST_FOREACH_END(t);\n  return ret;\n}", "target": 0}
{"code": "static bool open_table_entry_fini(THD *thd, TABLE_SHARE *share, TABLE *entry)\n{\n  if (Table_triggers_list::check_n_load(thd, share->db.str,\n                                        share->table_name.str, entry, 0))\n    return TRUE;\n  if (unlikely(entry->file->implicit_emptied))\n  {\n    entry->file->implicit_emptied= 0;\n    if (mysql_bin_log.is_open())\n    {\n      char query_buf[2*FN_REFLEN + 21];\n      String query(query_buf, sizeof(query_buf), system_charset_info);\n      query.length(0);\n      query.append(\"DELETE FROM \");\n      append_identifier(thd, &query, share->db.str, share->db.length);\n      query.append(\".\");\n      append_identifier(thd, &query, share->table_name.str,\n                          share->table_name.length);\n      Query_log_event qinfo(thd, query.ptr(), query.length(),\n                            FALSE, TRUE, TRUE, 0);\n      if (mysql_bin_log.write(&qinfo))\n        return TRUE;\n    }\n  }\n  return FALSE;\n}", "target": 0}
{"code": "int js_toboolean(js_State *J, int idx)\n{\n\treturn jsV_toboolean(J, stackidx(J, idx));\n}", "target": 0}
{"code": "static int packet_snd_vnet_parse(struct msghdr *msg, size_t *len,\n\t\t\t\t struct virtio_net_hdr *vnet_hdr)\n{\n\tint n;\n\tif (*len < sizeof(*vnet_hdr))\n\t\treturn -EINVAL;\n\t*len -= sizeof(*vnet_hdr);\n\tn = copy_from_iter(vnet_hdr, sizeof(*vnet_hdr), &msg->msg_iter);\n\tif (n != sizeof(*vnet_hdr))\n\t\treturn -EFAULT;\n\treturn __packet_snd_vnet_parse(vnet_hdr, *len);\n}", "target": 0}
{"code": "get_poll_adj(NCR_Instance inst, double error_in_estimate, double peer_distance)\n{\n  double poll_adj;\n  if (error_in_estimate > peer_distance) {\n    int shift = 0;\n    unsigned long temp = (int)(error_in_estimate / peer_distance);\n    do {\n      shift++;\n      temp>>=1;\n    } while (temp);\n    poll_adj = -shift - inst->poll_score + 0.5;\n  } else {\n    int samples = SRC_Samples(inst->source);\n    poll_adj = ((double)samples / inst->poll_target - 1.0) / inst->poll_target;\n    if (samples < inst->poll_target) {\n      poll_adj *= 2.0;\n    }\n  }\n  return poll_adj;\n}", "target": 0}
{"code": "update_info_luks (Device *device)\n{\n  if (g_strcmp0 (device->priv->id_type, \"crypto_LUKS\") == 0 && device->priv->holders_objpath->len == 1)\n    {\n      device_set_device_is_luks (device, TRUE);\n      device_set_luks_holder (device, device->priv->holders_objpath->pdata[0]);\n    }\n  else\n    {\n      device_set_device_is_luks (device, FALSE);\n      device_set_luks_holder (device, NULL);\n    }\n  return TRUE;\n}", "target": 0}
{"code": "int HeaderMapWrapper::luaAdd(lua_State* state) {\n  checkModifiable(state);\n  const char* key = luaL_checkstring(state, 2);\n  const char* value = luaL_checkstring(state, 3);\n  headers_.addCopy(Http::LowerCaseString(key), value);\n  return 0;\n}", "target": 0}
{"code": "    void Image::writeXmpFromPacket(bool) {}", "target": 0}
{"code": "bool ParamTraits<IPC::ChannelHandle>::Read(const Message* m,\n                                           PickleIterator* iter,\n                                           param_type* r) {\n  return ReadParam(m, iter, &r->name)\n#if defined(OS_POSIX)\n      && ReadParam(m, iter, &r->socket)\n#endif\n      ;\n}", "target": 0}
{"code": "static CURLUcode parseurl_and_replace(const char *url, CURLU *u,\n                                      unsigned int flags)\n{\n  CURLUcode result;\n  CURLU tmpurl;\n  memset(&tmpurl, 0, sizeof(tmpurl));\n  result = parseurl(url, &tmpurl, flags);\n  if(!result) {\n    free_urlhandle(u);\n    *u = tmpurl;\n  }\n  else\n    free_urlhandle(&tmpurl);\n  return result;\n}", "target": 0}
{"code": "    void copyXmpToExif(const XmpData& xmpData, ExifData& exifData)\n    {\n        Converter converter(exifData, const_cast<XmpData&>(xmpData));\n        converter.cnvFromXmp();\n    }", "target": 0}
{"code": "static zend_bool php_auto_globals_create_post(const char *name, uint name_len TSRMLS_DC)\n{\n\tzval *vars;\n\tif (PG(variables_order) &&\n\t\t\t(strchr(PG(variables_order),'P') || strchr(PG(variables_order),'p')) &&\n\t\tSG(request_info).request_method &&\n\t\t!strcasecmp(SG(request_info).request_method, \"POST\")) {\n\t\tsapi_module.treat_data(PARSE_POST, NULL, NULL TSRMLS_CC);\n\t\tvars = PG(http_globals)[TRACK_VARS_POST];\n\t} else {\n\t\tALLOC_ZVAL(vars);\n\t\tarray_init(vars);\n\t\tINIT_PZVAL(vars);\n\t\tif (PG(http_globals)[TRACK_VARS_POST]) {\n\t\t\tzval_ptr_dtor(&PG(http_globals)[TRACK_VARS_POST]);\n\t\t}\n\t\tPG(http_globals)[TRACK_VARS_POST] = vars;\n\t}\n\tzend_hash_update(&EG(symbol_table), name, name_len + 1, &vars, sizeof(zval *), NULL);\n\tZ_ADDREF_P(vars);\n\treturn 0; \n}", "target": 0}
{"code": "int kvm_read_guest_page(struct kvm *kvm, gfn_t gfn, void *data, int offset,\n\t\t\tint len)\n{\n\tstruct kvm_memory_slot *slot = gfn_to_memslot(kvm, gfn);\n\treturn __kvm_read_guest_page(slot, gfn, data, offset, len);\n}", "target": 0}
{"code": "    static uint32_t byteSwap_(Exiv2::DataBuf& buf,size_t offset,bool bSwap)\n    {\n        uint32_t v;\n        char*    p = (char*) &v;\n        int      i;\n        for ( i = 0 ; i < 4 ; i++ ) p[i] = buf.pData_[offset+i];\n        uint32_t result = byteSwap_(v,bSwap);\n        p               = (char*) &result;\n        for ( i = 0 ; i < 4 ; i++ ) buf.pData_[offset+i] = p[i];\n        return result;\n    }", "target": 0}
{"code": "static inline pte_t pte_swp_clear_soft_dirty(pte_t pte)\n{\n\treturn pte;\n}", "target": 0}
{"code": "int RGWCompleteMultipart_ObjStore_S3::get_params()\n{\n  int ret = RGWCompleteMultipart_ObjStore::get_params();\n  if (ret < 0) {\n    return ret;\n  }\n  map_qs_metadata(s);\n  return do_aws4_auth_completion();\n}", "target": 0}
{"code": "static bool startsSingleLineCommentAt(const String& string, size_t start)\n{\n    return (start + 1 < string.length() && string[start] == '/' && string[start+1] == '/');\n}", "target": 0}
{"code": "static void sort_parity_stripes(struct btrfs_bio *bbio, int num_stripes)\n{\n\tstruct btrfs_bio_stripe s;\n\tint i;\n\tu64 l;\n\tint again = 1;\n\twhile (again) {\n\t\tagain = 0;\n\t\tfor (i = 0; i < num_stripes - 1; i++) {\n\t\t\tif (parity_smaller(bbio->raid_map[i],\n\t\t\t\t\t   bbio->raid_map[i+1])) {\n\t\t\t\ts = bbio->stripes[i];\n\t\t\t\tl = bbio->raid_map[i];\n\t\t\t\tbbio->stripes[i] = bbio->stripes[i+1];\n\t\t\t\tbbio->raid_map[i] = bbio->raid_map[i+1];\n\t\t\t\tbbio->stripes[i+1] = s;\n\t\t\t\tbbio->raid_map[i+1] = l;\n\t\t\t\tagain = 1;\n\t\t\t}\n\t\t}\n\t}\n}", "target": 0}
{"code": "static int decode_attr_files_total(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\t*res = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_FILES_TOTAL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_FILES_TOTAL)) {\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_overflow;\n\t\txdr_decode_hyper(p, res);\n\t\tbitmap[0] &= ~FATTR4_WORD0_FILES_TOTAL;\n\t}\n\tdprintk(\"%s: files total=%Lu\\n\", __func__, (unsigned long long)*res);\n\treturn status;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}", "target": 0}
{"code": "virStoragePoolObjFromStoragePool(virStoragePoolPtr pool)\n{\n    return storagePoolObjFindByUUID(pool->uuid, pool->name);\n}", "target": 0}
{"code": "void PDFiumEngine::SelectAll() {\n  SelectionChangeInvalidator selection_invalidator(this);\n  selection_.clear();\n  for (const auto& page : pages_) {\n    if (page->available())\n      selection_.push_back(PDFiumRange(page, 0, page->GetCharCount()));\n  }\n}", "target": 0}
{"code": "static int sctp_setsockopt_del_key(struct sock *sk,\n\t\t\t\t\tchar __user *optval,\n\t\t\t\t\tint optlen)\n{\n\tstruct sctp_authkeyid val;\n\tstruct sctp_association *asoc;\n\tif (!sctp_auth_enable)\n\t\treturn -EACCES;\n\tif (optlen != sizeof(struct sctp_authkeyid))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&val, optval, optlen))\n\t\treturn -EFAULT;\n\tasoc = sctp_id2assoc(sk, val.scact_assoc_id);\n\tif (!asoc && val.scact_assoc_id && sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\treturn sctp_auth_del_key_id(sctp_sk(sk)->ep, asoc,\n\t\t\t\t    val.scact_keynumber);\n}", "target": 0}
{"code": "static bool emulation_required(struct kvm_vcpu *vcpu)\n{\n\treturn emulate_invalid_guest_state && !guest_state_valid(vcpu);\n}", "target": 0}
{"code": "static void vmxnet3_pci_uninit(PCIDevice *pci_dev)\n{\n    VMXNET3State *s = VMXNET3(pci_dev);\n    VMW_CBPRN(\"Starting uninit...\");\n    vmxnet3_net_uninit(s);\n    vmxnet3_cleanup_msix(s);\n    vmxnet3_cleanup_msi(s);\n}", "target": 0}
{"code": "int http_process_tarpit(struct session *s, struct channel *req, int an_bit)\n{\n\tstruct http_txn *txn = &s->txn;\n\tchannel_dont_connect(req);\n\tif ((req->flags & (CF_SHUTR|CF_READ_ERROR)) == 0 &&\n\t    !tick_is_expired(req->analyse_exp, now_ms))\n\t\treturn 0;\n\ts->logs.t_queue = tv_ms_elapsed(&s->logs.tv_accept, &now);\n\ttxn->status = 500;\n\tif (!(req->flags & CF_READ_ERROR))\n\t\tstream_int_retnclose(req->prod, http_error_message(s, HTTP_ERR_500));\n\treq->analysers = 0;\n\treq->analyse_exp = TICK_ETERNITY;\n\ts->fe->fe_counters.failed_req++;\n\tif (s->listener->counters)\n\t\ts->listener->counters->failed_req++;\n\tif (!(s->flags & SN_ERR_MASK))\n\t\ts->flags |= SN_ERR_PRXCOND;\n\tif (!(s->flags & SN_FINST_MASK))\n\t\ts->flags |= SN_FINST_T;\n\treturn 0;\n}", "target": 0}
{"code": "int sc_pkcs15emu_esteid_init_ex(sc_pkcs15_card_t *p15card,\n\t\t\t\tstruct sc_aid *aid,\n\t\t\t\tsc_pkcs15emu_opt_t *opts)\n{\n\tif (opts && opts->flags & SC_PKCS15EMU_FLAGS_NO_CHECK)\n\t\treturn sc_pkcs15emu_esteid_init(p15card);\n\telse {\n\t\tint r = esteid_detect_card(p15card);\n\t\tif (r)\n\t\t\treturn SC_ERROR_WRONG_CARD;\n\t\treturn sc_pkcs15emu_esteid_init(p15card);\n\t}\n}", "target": 0}
{"code": "void smp_proc_sl_key(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n uint8_t key_type = p_data->key.key_type;\n  SMP_TRACE_DEBUG(\"%s\", __func__);\n if (key_type == SMP_KEY_TYPE_TK) {\n    smp_generate_srand_mrand_confirm(p_cb, NULL);\n } else if (key_type == SMP_KEY_TYPE_CFM) {\n    smp_set_state(SMP_STATE_WAIT_CONFIRM);\n if (p_cb->flags & SMP_PAIR_FLAGS_CMD_CONFIRM)\n      smp_sm_event(p_cb, SMP_CONFIRM_EVT, NULL);\n }\n}", "target": 0}
{"code": "vmci_transport_recv_connecting_client_invalid(struct sock *sk,\n\t\t\t\t\t      struct vmci_transport_packet *pkt)\n{\n\tint err = 0;\n\tstruct vsock_sock *vsk = vsock_sk(sk);\n\tif (vsk->sent_request) {\n\t\tvsk->sent_request = false;\n\t\tvsk->ignore_connecting_rst = true;\n\t\terr = vmci_transport_send_conn_request(\n\t\t\tsk, vmci_trans(vsk)->queue_pair_size);\n\t\tif (err < 0)\n\t\t\terr = vmci_transport_error_to_vsock_error(err);\n\t\telse\n\t\t\terr = 0;\n\t}\n\treturn err;\n}", "target": 0}
{"code": "static int rxrpc_krb5_decode_ticket(u8 **_ticket, u16 *_tktlen,\n\t\t\t\t    const __be32 **_xdr, unsigned int *_toklen)\n{\n\tconst __be32 *xdr = *_xdr;\n\tunsigned int toklen = *_toklen, len;\n\tif (toklen <= 4)\n\t\treturn -EINVAL;\n\t_enter(\",{%x},%u\", ntohl(xdr[0]), toklen);\n\tlen = ntohl(*xdr++);\n\ttoklen -= 4;\n\tif (len > AFSTOKEN_K5_TIX_MAX)\n\t\treturn -EINVAL;\n\t*_tktlen = len;\n\t_debug(\"ticket len %u\", len);\n\tif (len > 0) {\n\t\t*_ticket = kmemdup(xdr, len, GFP_KERNEL);\n\t\tif (!*_ticket)\n\t\t\treturn -ENOMEM;\n\t\tlen = (len + 3) & ~3;\n\t\ttoklen -= len;\n\t\txdr += len >> 2;\n\t}\n\t*_xdr = xdr;\n\t*_toklen = toklen;\n\t_leave(\" = 0 [toklen=%u]\", toklen);\n\treturn 0;\n}", "target": 0}
{"code": "is_code_ctype(OnigCodePoint code, unsigned int ctype, OnigEncoding enc ARG_UNUSED)\n{\n  if (code < 256)\n    return ENC_IS_ISO_8859_14_CTYPE(code, ctype);\n  else\n    return FALSE;\n}", "target": 0}
{"code": "lookupGid(const string &groupName) {\n\tstruct group *groupEntry;\n\tgroupEntry = getgrnam(groupName.c_str());\n\tif (groupEntry == NULL) {\n\t\tif (looksLikePositiveNumber(groupName)) {\n\t\t\treturn atoi(groupName);\n\t\t} else {\n\t\t\treturn (gid_t) -1;\n\t\t}\n\t} else {\n\t\treturn groupEntry->gr_gid;\n\t}\n}", "target": 0}
{"code": "  void SetReadyState(HTMLMediaElement::ReadyState state) {\n    Media()->SetReadyState(state);\n  }", "target": 0}
{"code": "static int lstats_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\tstruct seq_file *m;\n\tstruct task_struct *task = get_proc_task(inode);\n\tret = single_open(file, lstats_show_proc, NULL);\n\tif (!ret) {\n\t\tm = file->private_data;\n\t\tm->private = task;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "void AutoFillManager::FillBillingFormField(const CreditCard* credit_card,\n                                           AutoFillType type,\n                                           webkit_glue::FormField* field) {\n  DCHECK(credit_card);\n  DCHECK(type.group() == AutoFillType::ADDRESS_BILLING);\n  DCHECK(field);\n  string16 billing_address = credit_card->billing_address();\n  if (!billing_address.empty()) {\n    AutoFillProfile* profile = NULL;\n    const std::vector<AutoFillProfile*>& profiles = personal_data_->profiles();\n    for (std::vector<AutoFillProfile*>::const_iterator iter = profiles.begin();\n         iter != profiles.end(); ++iter) {\n      if ((*iter)->Label() == billing_address) {\n        profile = *iter;\n        break;\n      }\n    }\n    if (profile) {\n      FillFormField(profile, type, field);\n    }\n  }\n}", "target": 0}
{"code": "    void CrwMap::encode0x0805(const Image&      image,\n                              const CrwMapping* pCrwMapping,\n                                    CiffHeader* pHead)\n    {\n        assert(pCrwMapping != 0);\n        assert(pHead != 0);\n        std::string comment = image.comment();\n        CiffComponent* cc = pHead->findComponent(pCrwMapping->crwTagId_,\n                                                 pCrwMapping->crwDir_);\n        if (!comment.empty()) {\n            uint32_t size = static_cast<uint32_t>(comment.size());\n            if (cc && cc->size() > size) size = cc->size();\n            DataBuf buf(size);\n            std::memset(buf.pData_, 0x0, buf.size_);\n            std::memcpy(buf.pData_, comment.data(), comment.size());\n            pHead->add(pCrwMapping->crwTagId_, pCrwMapping->crwDir_, buf);\n        }\n        else {\n            if (cc) {\n                DataBuf buf(cc->size());\n                std::memset(buf.pData_, 0x0, buf.size_);\n                cc->setValue(buf);\n            }\n        }\n    } ", "target": 0}
{"code": "long keyctl_set_timeout(key_serial_t id, unsigned timeout)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,\n\t\t\t\t  KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref)) {\n\t\tif (PTR_ERR(key_ref) == -EACCES) {\n\t\t\tinstkey = key_get_instantiation_authkey(id);\n\t\t\tif (!IS_ERR(instkey)) {\n\t\t\t\tkey_put(instkey);\n\t\t\t\tkey_ref = lookup_user_key(id,\n\t\t\t\t\t\t\t  KEY_LOOKUP_PARTIAL,\n\t\t\t\t\t\t\t  0);\n\t\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\t\tgoto okay;\n\t\t\t}\n\t\t}\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\nokay:\n\tkey = key_ref_to_ptr(key_ref);\n\tkey_set_timeout(key, timeout);\n\tkey_put(key);\n\tret = 0;\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "static int bnx2x_set_q_rx_mode(struct bnx2x *bp, u8 cl_id,\n\t\t\t       unsigned long rx_mode_flags,\n\t\t\t       unsigned long rx_accept_flags,\n\t\t\t       unsigned long tx_accept_flags,\n\t\t\t       unsigned long ramrod_flags)\n{\n\tstruct bnx2x_rx_mode_ramrod_params ramrod_param;\n\tint rc;\n\tmemset(&ramrod_param, 0, sizeof(ramrod_param));\n\tramrod_param.cid = 0;\n\tramrod_param.cl_id = cl_id;\n\tramrod_param.rx_mode_obj = &bp->rx_mode_obj;\n\tramrod_param.func_id = BP_FUNC(bp);\n\tramrod_param.pstate = &bp->sp_state;\n\tramrod_param.state = BNX2X_FILTER_RX_MODE_PENDING;\n\tramrod_param.rdata = bnx2x_sp(bp, rx_mode_rdata);\n\tramrod_param.rdata_mapping = bnx2x_sp_mapping(bp, rx_mode_rdata);\n\tset_bit(BNX2X_FILTER_RX_MODE_PENDING, &bp->sp_state);\n\tramrod_param.ramrod_flags = ramrod_flags;\n\tramrod_param.rx_mode_flags = rx_mode_flags;\n\tramrod_param.rx_accept_flags = rx_accept_flags;\n\tramrod_param.tx_accept_flags = tx_accept_flags;\n\trc = bnx2x_config_rx_mode(bp, &ramrod_param);\n\tif (rc < 0) {\n\t\tBNX2X_ERR(\"Set rx_mode %d failed\\n\", bp->rx_mode);\n\t\treturn rc;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static inline Quantum ScaleAnyToQuantum(const QuantumAny quantum,\n  const QuantumAny range)\n{\n  if (quantum > range)\n    return(QuantumRange);\n#if !defined(MAGICKCORE_HDRI_SUPPORT)\n  return((Quantum) (((double) QuantumRange*quantum)*\n    PerceptibleReciprocal((double) range)+0.5));\n#else\n  return((Quantum) (((double) QuantumRange*quantum)*\n    PerceptibleReciprocal((double) range)));\n#endif\n}", "target": 0}
{"code": "vte_sequence_handler_local_charset (VteTerminal *terminal, GValueArray *params)\n{\n\tG_CONST_RETURN char *locale_encoding;\n\tg_get_charset(&locale_encoding);\n\tvte_terminal_set_encoding(terminal, locale_encoding);\n}", "target": 0}
{"code": "dashedSet (gdImagePtr im, int x, int y, int color,\n\t\t   int *onP, int *dashStepP, int wid, int vert)\n{\n\tint dashStep = *dashStepP;\n\tint on = *onP;\n\tint w, wstart;\n\tdashStep++;\n\tif (dashStep == gdDashSize) {\n\t\tdashStep = 0;\n\t\ton = !on;\n\t}\n\tif (on) {\n\t\tif (vert) {\n\t\t\twstart = y - wid / 2;\n\t\t\tfor (w = wstart; w < wstart + wid; w++)\n\t\t\t\tgdImageSetPixel (im, x, w, color);\n\t\t} else {\n\t\t\twstart = x - wid / 2;\n\t\t\tfor (w = wstart; w < wstart + wid; w++)\n\t\t\t\tgdImageSetPixel (im, w, y, color);\n\t\t}\n\t}\n\t*dashStepP = dashStep;\n\t*onP = on;\n}", "target": 0}
{"code": "static int _nfs4_free_stateid(struct nfs_server *server, nfs4_stateid *stateid)\n{\n\tstruct nfs41_free_stateid_args args = {\n\t\t.stateid = stateid,\n\t};\n\tstruct nfs41_free_stateid_res res;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_FREE_STATEID],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tint status;\n\tdprintk(\"NFS call  free_stateid %p\\n\", stateid);\n\tnfs41_init_sequence(&args.seq_args, &res.seq_res, 0);\n\tstatus = nfs4_call_sync_sequence(server->client, server, &msg,\n\t\t\t\t\t &args.seq_args, &res.seq_res, 1);\n\tdprintk(\"NFS reply free_stateid: %d\\n\", status);\n\treturn status;\n}", "target": 0}
{"code": "fill_small_buf(__le16 smb2_command, struct cifs_tcon *tcon, void *buf,\n\t       unsigned int *total_len)\n{\n\tstruct smb2_sync_pdu *spdu = (struct smb2_sync_pdu *)buf;\n\t__u16 parmsize = smb2_req_struct_sizes[le16_to_cpu(smb2_command)];\n\tmemset(buf, 0, 256);\n\tsmb2_hdr_assemble(&spdu->sync_hdr, smb2_command, tcon);\n\tspdu->StructureSize2 = cpu_to_le16(parmsize);\n\t*total_len = parmsize + sizeof(struct smb2_sync_hdr);\n}", "target": 0}
{"code": "static void rds_inc_addref(struct rds_incoming *inc)\n{\n\trdsdebug(\"addref inc %p ref %d\\n\", inc, atomic_read(&inc->i_refcount));\n\tatomic_inc(&inc->i_refcount);\n}", "target": 0}
{"code": "Item_func_isnull::remove_eq_conds(THD *thd, Item::cond_result *cond_value,\n                                  bool top_level_arg)\n{\n  Item *real_item= args[0]->real_item();\n  if (real_item->type() == Item::FIELD_ITEM)\n  {\n    Field *field= ((Item_field*) real_item)->field;\n    if (((field->type() == MYSQL_TYPE_DATE) ||\n         (field->type() == MYSQL_TYPE_DATETIME)) &&\n         (field->flags & NOT_NULL_FLAG))\n    {\n      Item *item0= new(thd->mem_root) Item_int(thd, (longlong) 0, 1);\n      Item *eq_cond= new(thd->mem_root) Item_func_eq(thd, args[0], item0);\n      if (!eq_cond)\n        return this;\n      COND *cond= this;\n      if (field->table->pos_in_table_list->is_inner_table_of_outer_join())\n      {\n        Item *or_cond= new(thd->mem_root) Item_cond_or(thd, eq_cond, this);\n        if (!or_cond)\n          return this;\n        cond= or_cond;\n      }\n      else\n      {\n        cond= eq_cond;\n      }\n      cond->fix_fields(thd, &cond);\n      return cond->Item::remove_eq_conds(thd, cond_value, false);\n    }\n    if (top_level_arg) \n    {\n      if (field->flags & AUTO_INCREMENT_FLAG && !field->table->maybe_null &&\n          (thd->variables.option_bits & OPTION_AUTO_IS_NULL) &&\n          (thd->first_successful_insert_id_in_prev_stmt > 0 &&\n           thd->substitute_null_with_insert_id))\n      {\n  #ifdef HAVE_QUERY_CACHE\n        query_cache_abort(thd, &thd->query_cache_tls);\n  #endif\n        COND *new_cond, *cond= this;\n        if ((new_cond= new (thd->mem_root) Item_func_eq(thd, args[0],\n                                        new (thd->mem_root) Item_int(thd, \"last_insert_id()\",\n                                                     thd->read_first_successful_insert_id_in_prev_stmt(),\n                                                     MY_INT64_NUM_DECIMAL_DIGITS))))\n        {\n          cond= new_cond;\n          cond->fix_fields(thd, &cond);\n        }\n        thd->substitute_null_with_insert_id= FALSE;\n        *cond_value= Item::COND_OK;\n        return cond;\n      }\n    }\n  }\n  return Item::remove_eq_conds(thd, cond_value, top_level_arg);\n}", "target": 0}
{"code": "static int logi_dj_reset_resume(struct hid_device *hdev)\n{\n\tint retval;\n\tstruct dj_receiver_dev *djrcv_dev = hid_get_drvdata(hdev);\n\tretval = logi_dj_recv_switch_to_dj_mode(djrcv_dev, 0);\n\tif (retval < 0) {\n\t\tdev_err(&hdev->dev,\n\t\t\t\"%s:logi_dj_recv_switch_to_dj_mode returned error:%d\\n\",\n\t\t\t__func__, retval);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "GF_Err trik_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_TrickPlayBox *ptr = (GF_TrickPlayBox *) s;\n\tptr->entry_count = (u32) ptr->size;\n\tif ((u64)ptr->entry_count > (u64)SIZE_MAX/sizeof(GF_TrickPlayBoxEntry)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in trik\\n\", ptr->size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tptr->entries = (GF_TrickPlayBoxEntry *) gf_malloc(ptr->entry_count * sizeof(GF_TrickPlayBoxEntry) );\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\tfor (i=0; i< ptr->entry_count; i++) {\n\t\tptr->entries[i].pic_type = gf_bs_read_int(bs, 2);\n\t\tptr->entries[i].dependency_level = gf_bs_read_int(bs, 6);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "    uint32_t Olympus2MnHeader::baseOffset(uint32_t mnOffset) const\n    {\n        return mnOffset;\n    }", "target": 0}
{"code": "static inline void skb_dst_set_noref_force(struct sk_buff *skb,\n\t\t\t\t\t   struct dst_entry *dst)\n{\n\t__skb_dst_set_noref(skb, dst, true);\n}", "target": 0}
{"code": "static int bad_file_flock(struct file *filp, int cmd, struct file_lock *fl)\n{\n\treturn -EIO;\n}", "target": 0}
{"code": "struct sock *__vsock_create(struct net *net,\n\t\t\t    struct socket *sock,\n\t\t\t    struct sock *parent,\n\t\t\t    gfp_t priority,\n\t\t\t    unsigned short type)\n{\n\tstruct sock *sk;\n\tstruct vsock_sock *psk;\n\tstruct vsock_sock *vsk;\n\tsk = sk_alloc(net, AF_VSOCK, priority, &vsock_proto);\n\tif (!sk)\n\t\treturn NULL;\n\tsock_init_data(sock, sk);\n\tif (!sock)\n\t\tsk->sk_type = type;\n\tvsk = vsock_sk(sk);\n\tvsock_addr_init(&vsk->local_addr, VMADDR_CID_ANY, VMADDR_PORT_ANY);\n\tvsock_addr_init(&vsk->remote_addr, VMADDR_CID_ANY, VMADDR_PORT_ANY);\n\tsk->sk_destruct = vsock_sk_destruct;\n\tsk->sk_backlog_rcv = vsock_queue_rcv_skb;\n\tsk->sk_state = 0;\n\tsock_reset_flag(sk, SOCK_DONE);\n\tINIT_LIST_HEAD(&vsk->bound_table);\n\tINIT_LIST_HEAD(&vsk->connected_table);\n\tvsk->listener = NULL;\n\tINIT_LIST_HEAD(&vsk->pending_links);\n\tINIT_LIST_HEAD(&vsk->accept_queue);\n\tvsk->rejected = false;\n\tvsk->sent_request = false;\n\tvsk->ignore_connecting_rst = false;\n\tvsk->peer_shutdown = 0;\n\tpsk = parent ? vsock_sk(parent) : NULL;\n\tif (parent) {\n\t\tvsk->trusted = psk->trusted;\n\t\tvsk->owner = get_cred(psk->owner);\n\t\tvsk->connect_timeout = psk->connect_timeout;\n\t} else {\n\t\tvsk->trusted = capable(CAP_NET_ADMIN);\n\t\tvsk->owner = get_current_cred();\n\t\tvsk->connect_timeout = VSOCK_DEFAULT_CONNECT_TIMEOUT;\n\t}\n\tif (transport->init(vsk, psk) < 0) {\n\t\tsk_free(sk);\n\t\treturn NULL;\n\t}\n\tif (sock)\n\t\tvsock_insert_unbound(vsk);\n\treturn sk;\n}", "target": 0}
{"code": "Status FunctionLibraryDefinition::ReplaceGradient(const GradientDef& grad) {\n  mutex_lock l(mu_);\n  bool added;\n  TF_RETURN_IF_ERROR(RemoveGradient(grad.function_name()));\n  TF_RETURN_IF_ERROR(AddGradientDefHelper(grad, &added));\n  return Status::OK();\n}", "target": 0}
{"code": "void HTMLMediaElement::SetIgnorePreloadNone() {\n  BLINK_MEDIA_LOG << \"setIgnorePreloadNone(\" << (void*)this << \")\";\n  ignore_preload_none_ = true;\n  SetPlayerPreload();\n}", "target": 0}
{"code": "static int ax25_info_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &ax25_info_seqops);\n}", "target": 0}
{"code": "const char *prefix_path(const char *prefix, int len, const char *path)\n{\n\tconst char *orig = path;\n\tchar *sanitized = xmalloc(len + strlen(path) + 1);\n\tif (is_absolute_path(orig))\n\t\tstrcpy(sanitized, path);\n\telse {\n\t\tif (len)\n\t\t\tmemcpy(sanitized, prefix, len);\n\t\tstrcpy(sanitized + len, path);\n\t}\n\tif (sanitary_path_copy(sanitized, sanitized))\n\t\tgoto error_out;\n\tif (is_absolute_path(orig)) {\n\t\tconst char *work_tree = get_git_work_tree();\n\t\tsize_t len = strlen(work_tree);\n\t\tsize_t total = strlen(sanitized) + 1;\n\t\tif (strncmp(sanitized, work_tree, len) ||\n\t\t    (sanitized[len] != '\\0' && sanitized[len] != '/')) {\n\t\terror_out:\n\t\t\terror(\"'%s' is outside repository\", orig);\n\t\t\tfree(sanitized);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (sanitized[len] == '/')\n\t\t\tlen++;\n\t\tmemmove(sanitized, sanitized + len, total - len);\n\t}\n\treturn sanitized;\n}", "target": 0}
{"code": "Expression* WasmBinaryBuilder::readExpression() {\n  assert(depth == 0);\n  processExpressions();\n  if (expressionStack.size() != 1) {\n    throwError(\"expected to read a single expression\");\n  }\n  auto* ret = popExpression();\n  assert(depth == 0);\n  return ret;\n}", "target": 0}
{"code": "int epo_strip_copy_rop(gx_device *dev, const byte *sdata, int sourcex, uint sraster, gx_bitmap_id id,\n    const gx_color_index *scolors,\n    const gx_strip_bitmap *textures, const gx_color_index *tcolors,\n    int x, int y, int width, int height,\n    int phase_x, int phase_y, gs_logical_operation_t lop)\n{\n    int code = epo_handle_erase_page(dev);\n    if (code != 0)\n        return code;\n    return dev_proc(dev, strip_copy_rop)(dev, sdata, sourcex, sraster, id, scolors, textures, tcolors, x, y, width, height, phase_x, phase_y, lop);\n}", "target": 0}
{"code": "\t__must_hold(&resv->lock)\n{\n\tstruct list_head allocated_regions;\n\tint to_allocate = 0, i = 0;\n\tstruct file_region *trg = NULL, *rg = NULL;\n\tVM_BUG_ON(regions_needed < 0);\n\tINIT_LIST_HEAD(&allocated_regions);\n\twhile (resv->region_cache_count <\n\t       (resv->adds_in_progress + regions_needed)) {\n\t\tto_allocate = resv->adds_in_progress + regions_needed -\n\t\t\t      resv->region_cache_count;\n\t\tVM_BUG_ON(resv->region_cache_count < resv->adds_in_progress);\n\t\tspin_unlock(&resv->lock);\n\t\tfor (i = 0; i < to_allocate; i++) {\n\t\t\ttrg = kmalloc(sizeof(*trg), GFP_KERNEL);\n\t\t\tif (!trg)\n\t\t\t\tgoto out_of_memory;\n\t\t\tlist_add(&trg->link, &allocated_regions);\n\t\t}\n\t\tspin_lock(&resv->lock);\n\t\tlist_splice(&allocated_regions, &resv->region_cache);\n\t\tresv->region_cache_count += to_allocate;\n\t}\n\treturn 0;\nout_of_memory:\n\tlist_for_each_entry_safe(rg, trg, &allocated_regions, link) {\n\t\tlist_del(&rg->link);\n\t\tkfree(rg);\n\t}\n\treturn -ENOMEM;\n}", "target": 0}
{"code": "static int check_fw_sanity(struct edgeport_serial *serial,\n\t\tconst struct firmware *fw)\n{\n\tu16 length_total;\n\tu8 checksum = 0;\n\tint pos;\n\tstruct device *dev = &serial->serial->interface->dev;\n\tstruct edgeport_fw_hdr *fw_hdr = (struct edgeport_fw_hdr *)fw->data;\n\tif (fw->size < sizeof(struct edgeport_fw_hdr)) {\n\t\tdev_err(dev, \"incomplete fw header\\n\");\n\t\treturn -EINVAL;\n\t}\n\tlength_total = le16_to_cpu(fw_hdr->length) +\n\t\t\tsizeof(struct edgeport_fw_hdr);\n\tif (fw->size != length_total) {\n\t\tdev_err(dev, \"bad fw size (expected: %u, got: %zu)\\n\",\n\t\t\t\tlength_total, fw->size);\n\t\treturn -EINVAL;\n\t}\n\tfor (pos = sizeof(struct edgeport_fw_hdr); pos < fw->size; ++pos)\n\t\tchecksum += fw->data[pos];\n\tif (checksum != fw_hdr->checksum) {\n\t\tdev_err(dev, \"bad fw checksum (expected: 0x%x, got: 0x%x)\\n\",\n\t\t\t\tfw_hdr->checksum, checksum);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "convtime(const char *s)\n{\n\tlong total, secs, multiplier;\n\tconst char *p;\n\tchar *endp;\n\terrno = 0;\n\ttotal = 0;\n\tp = s;\n\tif (p == NULL || *p == '\\0')\n\t\treturn -1;\n\twhile (*p) {\n\t\tsecs = strtol(p, &endp, 10);\n\t\tif (p == endp ||\n\t\t    (errno == ERANGE && (secs == INT_MIN || secs == INT_MAX)) ||\n\t\t    secs < 0)\n\t\t\treturn -1;\n\t\tmultiplier = 1;\n\t\tswitch (*endp++) {\n\t\tcase '\\0':\n\t\t\tendp--;\n\t\t\tbreak;\n\t\tcase 's':\n\t\tcase 'S':\n\t\t\tbreak;\n\t\tcase 'm':\n\t\tcase 'M':\n\t\t\tmultiplier = MINUTES;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tcase 'H':\n\t\t\tmultiplier = HOURS;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\tcase 'D':\n\t\t\tmultiplier = DAYS;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\tcase 'W':\n\t\t\tmultiplier = WEEKS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t\tif (secs > INT_MAX / multiplier)\n\t\t\treturn -1;\n\t\tsecs *= multiplier;\n\t\tif  (total > INT_MAX - secs)\n\t\t\treturn -1;\n\t\ttotal += secs;\n\t\tif (total < 0)\n\t\t\treturn -1;\n\t\tp = endp;\n\t}\n\treturn total;\n}", "target": 0}
{"code": "static void nfs4_lock_done(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_lockdata *data = calldata;\n\tdprintk(\"%s: begin!\\n\", __func__);\n\tif (!nfs4_sequence_done(task, &data->res.seq_res))\n\t\treturn;\n\tdata->rpc_status = task->tk_status;\n\tif (data->arg.new_lock_owner != 0) {\n\t\tif (data->rpc_status == 0)\n\t\t\tnfs_confirm_seqid(&data->lsp->ls_seqid, 0);\n\t\telse\n\t\t\tgoto out;\n\t}\n\tif (data->rpc_status == 0) {\n\t\tnfs4_stateid_copy(&data->lsp->ls_stateid, &data->res.stateid);\n\t\tset_bit(NFS_LOCK_INITIALIZED, &data->lsp->ls_flags);\n\t\trenew_lease(NFS_SERVER(data->ctx->dentry->d_inode), data->timestamp);\n\t}\nout:\n\tdprintk(\"%s: done, ret = %d!\\n\", __func__, data->rpc_status);\n}", "target": 0}
{"code": "new_httpd(isc_httpdmgr_t *httpdmgr, isc_nmhandle_t *handle) {\n\tisc_httpd_t *httpd = NULL;\n\tchar *headerdata = NULL;\n\tREQUIRE(VALID_HTTPDMGR(httpdmgr));\n\thttpd = isc_nmhandle_getdata(handle);\n\tif (httpd == NULL) {\n\t\thttpd = isc_nmhandle_getextra(handle);\n\t\t*httpd = (isc_httpd_t){ .handle = NULL };\n\t\thttpdmgr_attach(httpdmgr, &httpd->mgr);\n\t}\n\tif (httpd->handle == NULL) {\n\t\tisc_nmhandle_setdata(handle, httpd, httpd_reset, httpd_put);\n\t\thttpd->handle = handle;\n\t} else {\n\t\tINSIST(httpd->handle == handle);\n\t}\n\theaderdata = isc_mem_get(httpdmgr->mctx, HTTP_SENDGROW);\n\tisc_buffer_init(&httpd->headerbuffer, headerdata, HTTP_SENDGROW);\n\tisc_buffer_clear(&httpd->headerbuffer);\n\tisc_buffer_initnull(&httpd->compbuffer);\n\tisc_buffer_clear(&httpd->compbuffer);\n\tisc_buffer_initnull(&httpd->bodybuffer);\n\tISC_LINK_INIT(httpd, link);\n\thttpd->magic = HTTPD_MAGIC;\n\thttpd->state = RECV;\n\tLOCK(&httpdmgr->lock);\n\tISC_LIST_APPEND(httpdmgr->running, httpd, link);\n\tUNLOCK(&httpdmgr->lock);\n\tisc_nmhandle_attach(httpd->handle, &httpd->readhandle);\n\tisc_nm_read(handle, httpd_request, httpdmgr);\n}", "target": 0}
{"code": "Expression::Parser makeConversionAlias(const StringData shortcutName, BSONType toType) {\n    return [=](ExpressionContext* const expCtx,\n               BSONElement elem,\n               const VariablesParseState& vps) -> intrusive_ptr<Expression> {\n        auto operands = ExpressionNary::parseArguments(expCtx, elem, vps);\n        uassert(50723,\n                str::stream() << shortcutName << \" requires a single argument, got \"\n                              << operands.size(),\n                operands.size() == 1);\n        return ExpressionConvert::create(expCtx, std::move(operands[0]), toType);\n    };\n}", "target": 0}
{"code": "tagstack_push_items(win_T *wp, list_T *l)\n{\n    listitem_T\t*li;\n    dictitem_T\t*di;\n    dict_T\t*itemdict;\n    char_u\t*tagname;\n    pos_T\tmark;\n    int\t\tfnum;\n    FOR_ALL_LIST_ITEMS(l, li)\n    {\n\tif (li->li_tv.v_type != VAR_DICT || li->li_tv.vval.v_dict == NULL)\n\t    continue;\t\t\t\t\n\titemdict = li->li_tv.vval.v_dict;\n\tif ((di = dict_find(itemdict, (char_u *)\"from\", -1)) == NULL)\n\t    continue;\n\tif (list2fpos(&di->di_tv, &mark, &fnum, NULL, FALSE) != OK)\n\t    continue;\n\tif ((tagname = dict_get_string(itemdict, \"tagname\", TRUE)) == NULL)\n\t    continue;\n\tif (mark.col > 0)\n\t    mark.col--;\n\ttagstack_push_item(wp, tagname,\n\t\t(int)dict_get_number(itemdict, \"bufnr\"),\n\t\t(int)dict_get_number(itemdict, \"matchnr\") - 1,\n\t\tmark, fnum,\n\t\tdict_get_string(itemdict, \"user_data\", TRUE));\n    }\n}", "target": 0}
{"code": "jpc_ms_t *jpc_ms_create(int type)\n{\n\tjpc_ms_t *ms;\n\tconst jpc_mstabent_t *mstabent;\n\tif (!(ms = jas_malloc(sizeof(jpc_ms_t)))) {\n\t\treturn 0;\n\t}\n\tms->id = type;\n\tms->len = 0;\n\tmstabent = jpc_mstab_lookup(ms->id);\n\tms->ops = &mstabent->ops;\n\tmemset(&ms->parms, 0, sizeof(jpc_msparms_t));\n\treturn ms;\n}", "target": 0}
{"code": "static int nested_vmx_check_msr_switch_controls(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\tstruct vmcs12 *vmcs12)\n{\n\tif (vmcs12->vm_exit_msr_load_count == 0 &&\n\t    vmcs12->vm_exit_msr_store_count == 0 &&\n\t    vmcs12->vm_entry_msr_load_count == 0)\n\t\treturn 0; \n\tif (nested_vmx_check_msr_switch(vcpu, VM_EXIT_MSR_LOAD_COUNT,\n\t\t\t\t\tVM_EXIT_MSR_LOAD_ADDR) ||\n\t    nested_vmx_check_msr_switch(vcpu, VM_EXIT_MSR_STORE_COUNT,\n\t\t\t\t\tVM_EXIT_MSR_STORE_ADDR) ||\n\t    nested_vmx_check_msr_switch(vcpu, VM_ENTRY_MSR_LOAD_COUNT,\n\t\t\t\t\tVM_ENTRY_MSR_LOAD_ADDR))\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 0}
{"code": "Variant HHVM_FUNCTION(each,\n                      VRefParam refParam) {\n  return iter_op_impl(\n    refParam,\n    &ArrayData::each,\n    s___each,\n    Variant::NullInit()\n  );\n}", "target": 0}
{"code": "static void tcmu_glfs_close(struct tcmu_device *dev)\n{\n\tstruct glfs_state *gfsp = tcmu_get_dev_private(dev);\n\tglfs_close(gfsp->gfd);\n\tgluster_cache_refresh(gfsp->fs, tcmu_get_path(dev));\n\tgluster_free_server(&gfsp->hosts);\n\tfree(gfsp);\n}", "target": 0}
{"code": "mcs_recv_cjcf(void)\n{\n\tuint8 opcode, result;\n\tSTREAM s;\n\ts = iso_recv(NULL);\n\tif (s == NULL)\n\t\treturn False;\n\tin_uint8(s, opcode);\n\tif ((opcode >> 2) != MCS_CJCF)\n\t{\n\t\terror(\"expected CJcf, got %d\\n\", opcode);\n\t\treturn False;\n\t}\n\tin_uint8(s, result);\n\tif (result != 0)\n\t{\n\t\terror(\"CJrq: %d\\n\", result);\n\t\treturn False;\n\t}\n\tin_uint8s(s, 4);\t\n\tif (opcode & 2)\n\t\tin_uint8s(s, 2);\t\n\treturn s_check_end(s);\n}", "target": 0}
{"code": "parse_WRITE_METADATA(char *arg, const struct ofpact_parse_params *pp)\n{\n    struct ofpact_metadata *om;\n    char *mask = strchr(arg, '/');\n    *pp->usable_protocols &= OFPUTIL_P_NXM_OF11_UP;\n    om = ofpact_put_WRITE_METADATA(pp->ofpacts);\n    if (mask) {\n        char *error;\n        *mask = '\\0';\n        error = str_to_be64(mask + 1, &om->mask);\n        if (error) {\n            return error;\n        }\n    } else {\n        om->mask = OVS_BE64_MAX;\n    }\n    return str_to_be64(arg, &om->metadata);\n}", "target": 0}
{"code": "dt_lite_to_s(VALUE self)\n{\n    return strftimev(\"%Y-%m-%dT%H:%M:%S%:z\", self, set_tmx);\n}", "target": 0}
{"code": "gbk_is_allowed_reverse_match(const UChar* s, const UChar* end ARG_UNUSED, OnigEncoding enc ARG_UNUSED)\n{\n  const UChar c = *s;\n  return (GBK_ISMB_TRAIL(c) ? FALSE : TRUE);\n}", "target": 0}
{"code": "void mbedtls_ssl_send_flight_completed( mbedtls_ssl_context *ssl )\n{\n    ssl_reset_retransmit_timeout( ssl );\n    mbedtls_ssl_set_timer( ssl, ssl->handshake->retransmit_timeout );\n    if( ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE &&\n        ssl->in_msg[0] == MBEDTLS_SSL_HS_FINISHED )\n    {\n        ssl->handshake->retransmit_state = MBEDTLS_SSL_RETRANS_FINISHED;\n    }\n    else\n        ssl->handshake->retransmit_state = MBEDTLS_SSL_RETRANS_WAITING;\n}", "target": 0}
{"code": "TEST(HeaderDataConstructorTest, ContainsMatchSpecifier) {\n  const std::string yaml = R\"EOF(\nname: test-header\ncontains_match: somevalueinside\n  )EOF\";\n  HeaderUtility::HeaderData header_data =\n      HeaderUtility::HeaderData(parseHeaderMatcherFromYaml(yaml));\n  EXPECT_EQ(\"test-header\", header_data.name_.get());\n  EXPECT_EQ(HeaderUtility::HeaderMatchType::Contains, header_data.header_match_type_);\n  EXPECT_EQ(\"somevalueinside\", header_data.value_);\n}", "target": 0}
{"code": "static int kvm_create_vcpu_debugfs(struct kvm_vcpu *vcpu)\n{\n\tchar dir_name[ITOA_MAX_LEN * 2];\n\tint ret;\n\tif (!kvm_arch_has_vcpu_debugfs())\n\t\treturn 0;\n\tif (!debugfs_initialized())\n\t\treturn 0;\n\tsnprintf(dir_name, sizeof(dir_name), \"vcpu%d\", vcpu->vcpu_id);\n\tvcpu->debugfs_dentry = debugfs_create_dir(dir_name,\n\t\t\t\t\t\t\t\tvcpu->kvm->debugfs_dentry);\n\tif (!vcpu->debugfs_dentry)\n\t\treturn -ENOMEM;\n\tret = kvm_arch_create_vcpu_debugfs(vcpu);\n\tif (ret < 0) {\n\t\tdebugfs_remove_recursive(vcpu->debugfs_dentry);\n\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int midi_setup_text(struct _mdi *mdi, char * text) {\n    MIDI_EVENT_SDEBUG(__FUNCTION__,0, text);\n    strip_text(text);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_meta_text;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.string = text;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}", "target": 0}
{"code": "static long dns_resolver_read(const struct key *key,\n\t\t\t      char __user *buffer, size_t buflen)\n{\n\tif (key->type_data.x[0])\n\t\treturn key->type_data.x[0];\n\treturn user_read(key, buffer, buflen);\n}", "target": 0}
{"code": "asn1_read_tag (asn1_node root, const char *name, int *tagValue,\n\t       int *classValue)\n{\n  asn1_node node, p, pTag;\n  node = asn1_find_node (root, name);\n  if (node == NULL)\n    return ASN1_ELEMENT_NOT_FOUND;\n  p = node->down;\n  pTag = NULL;\n  if (node->type & CONST_TAG)\n    {\n      while (p)\n\t{\n\t  if (type_field (p->type) == ASN1_ETYPE_TAG)\n\t    {\n\t      if ((p->type & CONST_IMPLICIT) && (pTag == NULL))\n\t\tpTag = p;\n\t      else if (p->type & CONST_EXPLICIT)\n\t\tpTag = NULL;\n\t    }\n\t  p = p->right;\n\t}\n    }\n  if (pTag)\n    {\n      *tagValue = _asn1_strtoul (pTag->value, NULL, 10);\n      if (pTag->type & CONST_APPLICATION)\n\t*classValue = ASN1_CLASS_APPLICATION;\n      else if (pTag->type & CONST_UNIVERSAL)\n\t*classValue = ASN1_CLASS_UNIVERSAL;\n      else if (pTag->type & CONST_PRIVATE)\n\t*classValue = ASN1_CLASS_PRIVATE;\n      else\n\t*classValue = ASN1_CLASS_CONTEXT_SPECIFIC;\n    }\n  else\n    {\n      unsigned type = type_field (node->type);\n      *classValue = ASN1_CLASS_UNIVERSAL;\n      switch (type)\n\t{\n\tCASE_HANDLED_ETYPES:\n\t  *tagValue = _asn1_tags[type].tag;\n\t  break;\n\tcase ASN1_ETYPE_TAG:\n\tcase ASN1_ETYPE_CHOICE:\n\tcase ASN1_ETYPE_ANY:\n\t  *tagValue = -1;\n\t  break;\n\tdefault:\n\t  break;\n\t}\n    }\n  return ASN1_SUCCESS;\n}", "target": 0}
{"code": "GF_Err pssh_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ProtectionSystemHeaderBox *ptr = (GF_ProtectionSystemHeaderBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, (char *) ptr->SystemID, 16);\n\tif (ptr->version > 0) {\n\t\tu32 i;\n\t\tgf_bs_write_u32(bs, ptr->KID_count);\n\t\tfor (i=0; i<ptr->KID_count; i++)\n\t\t\tgf_bs_write_data(bs, (char *) ptr->KIDs[i], 16);\n\t}\n\tif (ptr->private_data) {\n\t\tgf_bs_write_u32(bs, ptr->private_data_size);\n\t\tgf_bs_write_data(bs, (char *) ptr->private_data, ptr->private_data_size);\n\t} else\n\t\tgf_bs_write_u32(bs, 0);\n\treturn GF_OK;\n}", "target": 0}
{"code": "static void nvme_copy_bh(void *opaque)\n{\n    NvmeCopyAIOCB *iocb = opaque;\n    NvmeRequest *req = iocb->req;\n    NvmeNamespace *ns = req->ns;\n    BlockAcctStats *stats = blk_get_stats(ns->blkconf.blk);\n    if (iocb->idx != iocb->nr) {\n        req->cqe.result = cpu_to_le32(iocb->idx);\n    }\n    qemu_iovec_destroy(&iocb->iov);\n    g_free(iocb->bounce);\n    qemu_bh_delete(iocb->bh);\n    iocb->bh = NULL;\n    if (iocb->ret < 0) {\n        block_acct_failed(stats, &iocb->acct.read);\n        block_acct_failed(stats, &iocb->acct.write);\n    } else {\n        block_acct_done(stats, &iocb->acct.read);\n        block_acct_done(stats, &iocb->acct.write);\n    }\n    iocb->common.cb(iocb->common.opaque, iocb->ret);\n    qemu_aio_unref(iocb);\n}", "target": 0}
{"code": "archive_read_format_zip_seekable_bid(struct archive_read *a, int best_bid)\n{\n\tstruct zip *zip = (struct zip *)a->format->data;\n\tint64_t file_size, current_offset;\n\tconst char *p;\n\tint i, tail;\n\tif (best_bid > 32)\n\t\treturn (-1);\n\tfile_size = __archive_read_seek(a, 0, SEEK_END);\n\tif (file_size <= 0)\n\t\treturn 0;\n\ttail = (int)zipmin(1024 * 16, file_size);\n\tcurrent_offset = __archive_read_seek(a, -tail, SEEK_END);\n\tif (current_offset < 0)\n\t\treturn 0;\n\tif ((p = __archive_read_ahead(a, (size_t)tail, NULL)) == NULL)\n\t\treturn 0;\n\tfor (i = tail - 22; i > 0;) {\n\t\tswitch (p[i]) {\n\t\tcase 'P':\n\t\t\tif (memcmp(p + i, \"PK\\005\\006\", 4) == 0) {\n\t\t\t\tint ret = read_eocd(zip, p + i,\n\t\t\t\t    current_offset + i);\n\t\t\t\tif (ret > 0) {\n\t\t\t\t\tif (i >= 20\n\t\t\t\t\t    && memcmp(p + i - 20, \"PK\\006\\007\", 4) == 0) {\n\t\t\t\t\t\tread_zip64_eocd(a, zip, p + i - 20);\n\t\t\t\t\t}\n\t\t\t\t\treturn (ret);\n\t\t\t\t}\n\t\t\t}\n\t\t\ti -= 4;\n\t\t\tbreak;\n\t\tcase 'K': i -= 1; break;\n\t\tcase 005: i -= 2; break;\n\t\tcase 006: i -= 3; break;\n\t\tdefault: i -= 4; break;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void MenuGtk::MenuPositionFunc(GtkMenu* menu,\n                               int* x,\n                               int* y,\n                               gboolean* push_in,\n                               void* void_widget) {\n  GtkWidget* widget = GTK_WIDGET(void_widget);\n  GtkRequisition menu_req;\n  gtk_widget_size_request(GTK_WIDGET(menu), &menu_req);\n  gdk_window_get_origin(widget->window, x, y);\n  GdkScreen *screen = gtk_widget_get_screen(widget);\n  gint monitor = gdk_screen_get_monitor_at_point(screen, *x, *y);\n  GdkRectangle screen_rect;\n  gdk_screen_get_monitor_geometry(screen, monitor,\n                                  &screen_rect);\n  if (GTK_WIDGET_NO_WINDOW(widget)) {\n    *x += widget->allocation.x;\n    *y += widget->allocation.y;\n  }\n  *y += widget->allocation.height;\n  bool start_align =\n    !!g_object_get_data(G_OBJECT(widget), \"left-align-popup\");\n  if (l10n_util::GetTextDirection() == l10n_util::RIGHT_TO_LEFT)\n    start_align = !start_align;\n  if (!start_align)\n    *x += widget->allocation.width - menu_req.width;\n  if (*y + menu_req.height >= screen_rect.height &&\n      *y > screen_rect.height / 2) {\n    *y -= menu_req.height;\n  }\n  *push_in = FALSE;\n}", "target": 0}
{"code": "struct torture_suite *torture_raw_write(TALLOC_CTX *mem_ctx)\n{\n\tstruct torture_suite *suite = torture_suite_create(mem_ctx, \"write\");\n\ttorture_suite_add_1smb_test(suite, \"write\", test_write);\n\ttorture_suite_add_1smb_test(suite, \"write unlock\", test_writeunlock);\n\ttorture_suite_add_1smb_test(suite, \"write close\", test_writeclose);\n\ttorture_suite_add_1smb_test(suite, \"writex\", test_writex);\n\ttorture_suite_add_1smb_test(suite, \"bad-write\", test_bad_write);\n\treturn suite;\n}", "target": 0}
{"code": "static inline void reset_deferred_meminit(pg_data_t *pgdat)\n{\n\tunsigned long max_initialise;\n\tunsigned long reserved_lowmem;\n\tmax_initialise = max(2UL << (30 - PAGE_SHIFT),\n\t\t(pgdat->node_spanned_pages >> 8));\n\treserved_lowmem = memblock_reserved_memory_within(pgdat->node_start_pfn,\n\t\t\tpgdat->node_start_pfn + max_initialise);\n\tmax_initialise += reserved_lowmem;\n\tpgdat->static_init_size = min(max_initialise, pgdat->node_spanned_pages);\n\tpgdat->first_deferred_pfn = ULONG_MAX;\n}", "target": 0}
{"code": "  void imFree(void *ptr\n#ifdef IM_MEMORY_CHECK\n, int ln\n#endif\n  ) {\n    size_t size;\n    void *sizePtr = (char *)ptr - sizeof(size);\n    memcpy(&size, sizePtr, sizeof(size));\n    m_mallocSize -= size;\n#ifdef IM_MEMORY_CHECK\n    void *lnPtr = (char *)sizePtr - sizeof(ln);\n    int count = m_alloced.erase((char*)sizePtr - sizeof(ln));\n    assertx(count == 1); \n    assertx(m_mallocSize < (size_t)RuntimeOption::ImageMemoryMaxBytes);\n    local_free(lnPtr);\n#else\n    assertx(m_mallocSize < (size_t)RuntimeOption::ImageMemoryMaxBytes);\n    local_free(sizePtr);\n#endif\n  }", "target": 0}
{"code": "  void Add(RenderWidgetHost* host) {\n    hosts_.push_back(RenderWidgetHostID(host->GetProcess()->GetID(),\n                                        host->GetRoutingID()));\n  }", "target": 0}
{"code": "static int switch_listening_mode(GDHCPClient *dhcp_client,\n\t\t\t\t\tListenMode listen_mode)\n{\n\tGIOChannel *listener_channel;\n\tint listener_sockfd;\n\tif (dhcp_client->listen_mode == listen_mode)\n\t\treturn 0;\n\tdebug(dhcp_client, \"switch listening mode (%d ==> %d)\",\n\t\t\t\tdhcp_client->listen_mode, listen_mode);\n\tif (dhcp_client->listen_mode != L_NONE) {\n\t\tif (dhcp_client->listener_watch > 0)\n\t\t\tg_source_remove(dhcp_client->listener_watch);\n\t\tdhcp_client->listen_mode = L_NONE;\n\t\tdhcp_client->listener_sockfd = -1;\n\t\tdhcp_client->listener_watch = 0;\n\t}\n\tif (listen_mode == L_NONE)\n\t\treturn 0;\n\tif (listen_mode == L2)\n\t\tlistener_sockfd = dhcp_l2_socket(dhcp_client->ifindex);\n\telse if (listen_mode == L3) {\n\t\tif (dhcp_client->type == G_DHCP_IPV6)\n\t\t\tlistener_sockfd = dhcp_l3_socket(DHCPV6_CLIENT_PORT,\n\t\t\t\t\t\t\tdhcp_client->interface,\n\t\t\t\t\t\t\tAF_INET6);\n\t\telse\n\t\t\tlistener_sockfd = dhcp_l3_socket(CLIENT_PORT,\n\t\t\t\t\t\t\tdhcp_client->interface,\n\t\t\t\t\t\t\tAF_INET);\n\t} else if (listen_mode == L_ARP)\n\t\tlistener_sockfd = arp_socket(dhcp_client->ifindex);\n\telse\n\t\treturn -EIO;\n\tif (listener_sockfd < 0)\n\t\treturn -EIO;\n\tlistener_channel = g_io_channel_unix_new(listener_sockfd);\n\tif (!listener_channel) {\n\t\tclose(listener_sockfd);\n\t\treturn -EIO;\n\t}\n\tdhcp_client->listen_mode = listen_mode;\n\tdhcp_client->listener_sockfd = listener_sockfd;\n\tg_io_channel_set_close_on_unref(listener_channel, TRUE);\n\tdhcp_client->listener_watch =\n\t\t\tg_io_add_watch_full(listener_channel, G_PRIORITY_HIGH,\n\t\t\t\tG_IO_IN | G_IO_NVAL | G_IO_ERR | G_IO_HUP,\n\t\t\t\t\t\tlistener_event, g_dhcp_client_ref(dhcp_client),\n\t\t\t\t\t\t\t\tlistener_watch_destroy);\n\tg_io_channel_unref(listener_channel);\n\treturn 0;\n}", "target": 0}
{"code": "static bool reg_type_not_null(enum bpf_reg_type type)\n{\n\treturn type == PTR_TO_SOCKET ||\n\t\ttype == PTR_TO_TCP_SOCK ||\n\t\ttype == PTR_TO_MAP_VALUE ||\n\t\ttype == PTR_TO_MAP_KEY ||\n\t\ttype == PTR_TO_SOCK_COMMON;\n}", "target": 0}
{"code": "void nft_reg_track_update(struct nft_regs_track *track,\n\t\t\t  const struct nft_expr *expr, u8 dreg, u8 len)\n{\n\tunsigned int regcount;\n\tint i;\n\t__nft_reg_track_clobber(track, dreg);\n\tregcount = DIV_ROUND_UP(len, NFT_REG32_SIZE);\n\tfor (i = 0; i < regcount; i++, dreg++)\n\t\t__nft_reg_track_update(track, expr, dreg, i);\n}", "target": 0}
{"code": "absl::optional<CelValue> evaluate(const Expression& expr, Protobuf::Arena& arena,\n                                  const StreamInfo::StreamInfo& info,\n                                  const Http::RequestHeaderMap* request_headers,\n                                  const Http::ResponseHeaderMap* response_headers,\n                                  const Http::ResponseTrailerMap* response_trailers) {\n  auto activation =\n      createActivation(arena, info, request_headers, response_headers, response_trailers);\n  auto eval_status = expr.Evaluate(*activation, &arena);\n  if (!eval_status.ok()) {\n    return {};\n  }\n  return eval_status.value();\n}", "target": 0}
{"code": "  Expression_Obj Parser::lex_almost_any_value_chars()\n  {\n    const char* match =\n    lex <\n      one_plus <\n        alternatives <\n          sequence <\n            exactly <'\\\\'>,\n            any_char\n          >,\n          sequence <\n            negate <\n              sequence <\n                exactly < url_kwd >,\n                exactly <'('>\n              >\n            >,\n            neg_class_char <\n              almost_any_value_class\n            >\n          >,\n          sequence <\n            exactly <'/'>,\n            negate <\n              alternatives <\n                exactly <'/'>,\n                exactly <'*'>\n              >\n            >\n          >,\n          sequence <\n            exactly <'\\\\'>,\n            exactly <'#'>,\n            negate <\n              exactly <'{'>\n            >\n          >,\n          sequence <\n            exactly <'!'>,\n            negate <\n              alpha\n            >\n          >\n        >\n      >\n    >(false);\n    if (match) {\n      return SASS_MEMORY_NEW(String_Constant, pstate, lexed);\n    }\n    return {};\n  }", "target": 0}
{"code": "join_read_prev(READ_RECORD *info)\n{\n  int error;\n  if ((error= info->table->file->ha_index_prev(info->record)))\n    return report_error(info->table, error);\n  return 0;\n}", "target": 0}
{"code": "static void reds_mig_finished(RedsState *reds, int completed)\n{\n    spice_debug(\"trace\");\n    reds->mig_inprogress = TRUE;\n    if (reds->src_do_seamless_migrate && completed) {\n        reds_migrate_channels_seamless(reds);\n    } else {\n        reds->main_channel->migrate_src_complete(completed);\n    }\n    if (completed) {\n        reds_mig_fill_wait_disconnect(reds);\n    } else {\n        reds_mig_cleanup(reds);\n    }\n    reds_mig_release(reds->config);\n}", "target": 0}
{"code": "void gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color)\n{\n\tint lastBorder;\n\tint leftLimit = -1, rightLimit;\n\tint i, restoreAlphaBlending = 0;\n\tif (border < 0) {\n\t\treturn;\n\t}\n\trestoreAlphaBlending = im->alphaBlendingFlag;\n\tim->alphaBlendingFlag = 0;\n\tif (x >= im->sx) {\n\t\tx = im->sx - 1;\n\t} else if (x < 0) {\n\t\tx = 0;\n\t}\n\tif (y >= im->sy) {\n\t\ty = im->sy - 1;\n\t} else if (y < 0) {\n\t\ty = 0;\n\t}\n\tfor (i = x; i >= 0; i--) {\n\t\tif (gdImageGetPixel(im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel(im, i, y, color);\n\t\tleftLimit = i;\n\t}\n\tif (leftLimit == -1) {\n\t\tim->alphaBlendingFlag = restoreAlphaBlending;\n\t\treturn;\n\t}\n\trightLimit = x;\n\tfor (i = (x + 1); i < im->sx; i++) {\n\t\tif (gdImageGetPixel(im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel(im, i, y, color);\n\t\trightLimit = i;\n\t}\n\tif (y > 0) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; i <= rightLimit; i++) {\n\t\t\tint c = gdImageGetPixel(im, i, y - 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder(im, i, y - 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (y < ((im->sy) - 1)) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; i <= rightLimit; i++) {\n\t\t\tint c = gdImageGetPixel(im, i, y + 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder(im, i, y + 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\tim->alphaBlendingFlag = restoreAlphaBlending;\n}", "target": 0}
{"code": "void bnx2x_set_rx_mode_inner(struct bnx2x *bp)\n{\n\tu32 rx_mode = BNX2X_RX_MODE_NORMAL;\n\tDP(NETIF_MSG_IFUP, \"dev->flags = %x\\n\", bp->dev->flags);\n\tnetif_addr_lock_bh(bp->dev);\n\tif (bp->dev->flags & IFF_PROMISC) {\n\t\trx_mode = BNX2X_RX_MODE_PROMISC;\n\t} else if ((bp->dev->flags & IFF_ALLMULTI) ||\n\t\t   ((netdev_mc_count(bp->dev) > BNX2X_MAX_MULTICAST) &&\n\t\t    CHIP_IS_E1(bp))) {\n\t\trx_mode = BNX2X_RX_MODE_ALLMULTI;\n\t} else {\n\t\tif (IS_PF(bp)) {\n\t\t\tif (bnx2x_set_mc_list(bp) < 0)\n\t\t\t\trx_mode = BNX2X_RX_MODE_ALLMULTI;\n\t\t\tnetif_addr_unlock_bh(bp->dev);\n\t\t\tif (bnx2x_set_uc_list(bp) < 0)\n\t\t\t\trx_mode = BNX2X_RX_MODE_PROMISC;\n\t\t\tnetif_addr_lock_bh(bp->dev);\n\t\t} else {\n\t\t\tbnx2x_schedule_sp_rtnl(bp,\n\t\t\t\t\t       BNX2X_SP_RTNL_VFPF_MCAST, 0);\n\t\t}\n\t}\n\tbp->rx_mode = rx_mode;\n\tif (IS_MF_ISCSI_ONLY(bp))\n\t\tbp->rx_mode = BNX2X_RX_MODE_NONE;\n\tif (test_bit(BNX2X_FILTER_RX_MODE_PENDING, &bp->sp_state)) {\n\t\tset_bit(BNX2X_FILTER_RX_MODE_SCHED, &bp->sp_state);\n\t\tnetif_addr_unlock_bh(bp->dev);\n\t\treturn;\n\t}\n\tif (IS_PF(bp)) {\n\t\tbnx2x_set_storm_rx_mode(bp);\n\t\tnetif_addr_unlock_bh(bp->dev);\n\t} else {\n\t\tnetif_addr_unlock_bh(bp->dev);\n\t\tbnx2x_vfpf_storm_rx_mode(bp);\n\t}\n}", "target": 0}
{"code": "bool RenderFrameHostImpl::CanCommitURL(const GURL& url) {\n  return GetContentClient()->browser()->CanCommitURL(GetProcess(), url);\n}", "target": 0}
{"code": "static inline struct kvm_pit *speaker_to_pit(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_pit, speaker_dev);\n}", "target": 0}
{"code": "Guint FoFiTrueType::mapToVertGID(Guint orgGID)\n{\n  Guint mapped;\n  if (gsubFeatureTable == 0) return orgGID;\n  if ((mapped = doMapToVertGID(orgGID)) != 0) {\n    return mapped;\n  }\n  return orgGID;\n}", "target": 0}
{"code": "GF_Box *udta_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_UserDataBox, GF_ISOM_BOX_TYPE_UDTA);\n\ttmp->recordList = gf_list_new();\n\tif (!tmp->recordList) {\n\t\tgf_free(tmp);\n\t\treturn NULL;\n\t}\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "void JPXStream::getImageParams(int *bitsPerComponent, StreamColorSpaceMode *csMode) {\n  if (unlikely(priv->inited == false)) { init(); }\n  *bitsPerComponent = 8;\n  int numComps = (priv->image) ? priv->image->numcomps : 1;\n  if (priv->image) {\n    if (priv->image->color_space == OPJ_CLRSPC_SRGB && numComps == 4) { numComps = 3; }\n    else if (priv->image->color_space == OPJ_CLRSPC_SYCC && numComps == 4) { numComps = 3; }\n    else if (numComps == 2) { numComps = 1; }\n    else if (numComps > 4) { numComps = 4; }\n  }\n  if (numComps == 3)\n    *csMode = streamCSDeviceRGB;\n  else if (numComps == 4)\n    *csMode = streamCSDeviceCMYK;\n  else\n    *csMode = streamCSDeviceGray;\n}", "target": 0}
{"code": "is_html_type(char *type)\n{\n    return (type && (strcasecmp(type, \"text/html\") == 0 ||\n\t\t     strcasecmp(type, \"application/xhtml+xml\") == 0));\n}", "target": 0}
{"code": "steal_from_cms(cms_context *old, cms_context *new)\n{\n\tnew->tokenname = old->tokenname;\n\tnew->certname = old->certname;\n\tnew->selected_digest = old->selected_digest;\n\tnew->log = old->log;\n\tnew->log_priv = old->log_priv;\n}", "target": 0}
{"code": "Frame* FrameLoader::opener()\n{\n    return m_opener;\n}", "target": 0}
{"code": "cdf_dump_catalog(const cdf_header_t *h, const cdf_stream_t *sst)\n{\n\tcdf_catalog_t *cat;\n\tcdf_unpack_catalog(h, sst, &cat);\n\tconst cdf_catalog_entry_t *ce = cat->cat_e;\n\tstruct timespec ts;\n\tchar tbuf[64], sbuf[256];\n\tsize_t i;\n\tprintf(\"Catalog:\\n\");\n\tfor (i = 0; i < cat->cat_num; i++) {\n\t\tcdf_timestamp_to_timespec(&ts, ce[i].ce_timestamp);\n\t\tprintf(\"\\t%d %s %s\", ce[i].ce_num,\n\t\t    cdf_u16tos8(sbuf, ce[i].ce_namlen, ce[i].ce_name),\n\t\t    cdf_ctime(&ts.tv_sec, tbuf));\n\t}\n\tfree(cat);\n}", "target": 0}
{"code": "add_abs_addr(regex_t* reg, int addr)\n{\n  AbsAddrType ra = (AbsAddrType )addr;\n  BBUF_ADD(reg, &ra, SIZE_ABSADDR);\n  return 0;\n}", "target": 0}
{"code": "static int vsock_shutdown(struct socket *sock, int mode)\n{\n\tint err;\n\tstruct sock *sk;\n\tmode++;\n\tif ((mode & ~SHUTDOWN_MASK) || !mode)\n\t\treturn -EINVAL;\n\tsk = sock->sk;\n\tif (sock->state == SS_UNCONNECTED) {\n\t\terr = -ENOTCONN;\n\t\tif (sk->sk_type == SOCK_STREAM)\n\t\t\treturn err;\n\t} else {\n\t\tsock->state = SS_DISCONNECTING;\n\t\terr = 0;\n\t}\n\tmode = mode & (RCV_SHUTDOWN | SEND_SHUTDOWN);\n\tif (mode) {\n\t\tlock_sock(sk);\n\t\tsk->sk_shutdown |= mode;\n\t\tsk->sk_state_change(sk);\n\t\trelease_sock(sk);\n\t\tif (sk->sk_type == SOCK_STREAM) {\n\t\t\tsock_reset_flag(sk, SOCK_DONE);\n\t\t\tvsock_send_shutdown(sk, mode);\n\t\t}\n\t}\n\treturn err;\n}", "target": 0}
{"code": "nfs4_init_uniform_client_string(const struct nfs_client *clp,\n\t\t\t\tchar *buf, size_t len)\n{\n\tchar *nodename = clp->cl_rpcclient->cl_nodename;\n\tif (nfs4_client_id_uniquifier[0] != '\\0')\n\t\tnodename = nfs4_client_id_uniquifier;\n\treturn scnprintf(buf, len, \"Linux NFSv%u.%u %s\",\n\t\t\t\tclp->rpc_ops->version, clp->cl_minorversion,\n\t\t\t\tnodename);\n}", "target": 0}
{"code": "job_read_out (GIOChannel *channel,\n              GIOCondition condition,\n              gpointer user_data)\n{\n  char *s;\n  char *line;\n  char buf[1024];\n  gsize bytes_read;\n  Job *job = user_data;\n  g_io_channel_read_chars (channel, buf, sizeof buf, &bytes_read, NULL);\n  g_string_append_len (job->stdout_string, buf, bytes_read);\n  do\n    {\n      gsize line_len;\n      s = strstr (job->stdout_string->str + job->stdout_string_cursor, \"\\n\");\n      if (s == NULL)\n        break;\n      line_len = s - (job->stdout_string->str + job->stdout_string_cursor);\n      line = g_strndup (job->stdout_string->str + job->stdout_string_cursor, line_len);\n      job->stdout_string_cursor += line_len + 1;\n      if (strlen (line) < 256)\n        {\n          double cur_percentage;\n          ;\n          if (sscanf (line, \"udisks-helper-progress: %lg\", &cur_percentage) == 1)\n            {\n              if (job->device != NULL && job->job_id != NULL)\n                {\n                  job->device->priv->job_percentage = cur_percentage;\n                  emit_job_changed (job->device);\n                }\n            }\n        }\n      g_free (line);\n    }\n  while (TRUE);\n  return TRUE;\n}", "target": 0}
{"code": "int sqlite3Fts3GetVarint(const char *p, sqlite_int64 *v){\n  const char *pStart = p;\n  u32 a;\n  u64 b;\n  int shift;\n  GETVARINT_INIT(a, p, 0,  0x00,     0x80, *v, 1);\n  GETVARINT_STEP(a, p, 7,  0x7F,     0x4000, *v, 2);\n  GETVARINT_STEP(a, p, 14, 0x3FFF,   0x200000, *v, 3);\n  GETVARINT_STEP(a, p, 21, 0x1FFFFF, 0x10000000, *v, 4);\n  b = (a & 0x0FFFFFFF );\n  for(shift=28; shift<=63; shift+=7){\n    u64 c = *p++;\n    b += (c&0x7F) << shift;\n    if( (c & 0x80)==0 ) break;\n  }\n  *v = b;\n  return (int)(p - pStart);\n}", "target": 0}
{"code": "static void verbose_invalid_scalar(struct bpf_verifier_env *env,\n\t\t\t\t   struct bpf_reg_state *reg,\n\t\t\t\t   struct tnum *range, const char *ctx,\n\t\t\t\t   const char *reg_name)\n{\n\tchar tn_buf[48];\n\tverbose(env, \"At %s the register %s \", ctx, reg_name);\n\tif (!tnum_is_unknown(reg->var_off)) {\n\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);\n\t\tverbose(env, \"has value %s\", tn_buf);\n\t} else {\n\t\tverbose(env, \"has unknown scalar value\");\n\t}\n\ttnum_strn(tn_buf, sizeof(tn_buf), *range);\n\tverbose(env, \" should have been in %s\\n\", tn_buf);\n}", "target": 0}
{"code": "void afInitFileFormat (AFfilesetup setup, int filefmt)\n{\n\tif (!_af_filesetup_ok(setup))\n\t\treturn;\n\tif (filefmt < 0 || filefmt > _AF_NUM_UNITS)\n\t{\n\t\t_af_error(AF_BAD_FILEFMT, \"unrecognized file format %d\",\n\t\t\tfilefmt);\n\t\treturn;\n\t}\n\tif (!_af_units[filefmt].implemented)\n\t{\n\t\t_af_error(AF_BAD_NOT_IMPLEMENTED,\n\t\t\t\"%s format not currently supported\",\n\t\t\t_af_units[filefmt].name);\n\t\treturn;\n\t}\n\tsetup->fileFormat = filefmt;\n}", "target": 0}
{"code": "static ssize_t f2fs_sbi_show(struct f2fs_attr *a,\n\t\t\tstruct f2fs_sb_info *sbi, char *buf)\n{\n\tunsigned char *ptr = NULL;\n\tunsigned int *ui;\n\tptr = __struct_ptr(sbi, a->struct_type);\n\tif (!ptr)\n\t\treturn -EINVAL;\n\tui = (unsigned int *)(ptr + a->offset);\n\treturn snprintf(buf, PAGE_SIZE, \"%u\\n\", *ui);\n}", "target": 0}
{"code": "int __kmem_cache_shrink(struct kmem_cache *s)\n{\n\tint node;\n\tint i;\n\tstruct kmem_cache_node *n;\n\tstruct page *page;\n\tstruct page *t;\n\tstruct list_head discard;\n\tstruct list_head promote[SHRINK_PROMOTE_MAX];\n\tunsigned long flags;\n\tint ret = 0;\n\tflush_all(s);\n\tfor_each_kmem_cache_node(s, node, n) {\n\t\tINIT_LIST_HEAD(&discard);\n\t\tfor (i = 0; i < SHRINK_PROMOTE_MAX; i++)\n\t\t\tINIT_LIST_HEAD(promote + i);\n\t\tspin_lock_irqsave(&n->list_lock, flags);\n\t\tlist_for_each_entry_safe(page, t, &n->partial, slab_list) {\n\t\t\tint free = page->objects - page->inuse;\n\t\t\tbarrier();\n\t\t\tBUG_ON(free <= 0);\n\t\t\tif (free == page->objects) {\n\t\t\t\tlist_move(&page->slab_list, &discard);\n\t\t\t\tn->nr_partial--;\n\t\t\t} else if (free <= SHRINK_PROMOTE_MAX)\n\t\t\t\tlist_move(&page->slab_list, promote + free - 1);\n\t\t}\n\t\tfor (i = SHRINK_PROMOTE_MAX - 1; i >= 0; i--)\n\t\t\tlist_splice(promote + i, &n->partial);\n\t\tspin_unlock_irqrestore(&n->list_lock, flags);\n\t\tlist_for_each_entry_safe(page, t, &discard, slab_list)\n\t\t\tdiscard_slab(s, page);\n\t\tif (slabs_node(s, node))\n\t\t\tret = 1;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static int mov_skip_multiple_stsd(MOVContext *c, AVIOContext *pb,\n                                  int codec_tag, int format,\n                                  int64_t size)\n{\n    if (codec_tag &&\n         (codec_tag != format &&\n          (codec_tag != AV_RL32(\"AV1x\") || format != AV_RL32(\"AVup\")) &&\n          codec_tag != AV_RL32(\"apcn\") && codec_tag != AV_RL32(\"apch\") &&\n          codec_tag != AV_RL32(\"dvpp\") && codec_tag != AV_RL32(\"dvcp\") &&\n          (c->fc->video_codec_id ? ff_codec_get_id(ff_codec_movvideo_tags, format) != c->fc->video_codec_id\n                                 : codec_tag != MKTAG('j','p','e','g')))) {\n        av_log(c->fc, AV_LOG_WARNING, \"multiple fourcc not supported\\n\");\n        avio_skip(pb, size);\n        return 1;\n    }\n    return 0;\n}", "target": 0}
{"code": "rgb_to_lab(fz_context *ctx, const fz_colorspace *cs, const float *rgb, float *lab)\n{\n\tfz_warn(ctx, \"cannot convert into L*a*b colorspace\");\n\tlab[0] = rgb[0];\n\tlab[1] = rgb[1];\n\tlab[2] = rgb[2];\n}", "target": 0}
{"code": "static void virtio_net_vnet_endian_status(VirtIONet *n, uint8_t status)\n{\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n    int queues = n->multiqueue ? n->max_queues : 1;\n    if (virtio_net_started(n, status)) {\n        n->needs_vnet_hdr_swap = virtio_net_set_vnet_endian(vdev, n->nic->ncs,\n                                                            queues, true);\n    } else if (virtio_net_started(n, vdev->status)) {\n        virtio_net_set_vnet_endian(vdev, n->nic->ncs, queues, false);\n    }\n}", "target": 0}
{"code": "read_tube_name(char **tubename, char *buf, char **end)\n{\n    size_t len;\n    while (buf[0] == ' ') buf++;\n    len = strspn(buf, NAME_CHARS);\n    if (len == 0) return -1;\n    if (tubename) *tubename = buf;\n    if (end) *end = buf + len;\n    return 0;\n}", "target": 0}
{"code": "void SVGDocumentExtensions::invalidateSVGRootsWithRelativeLengthDescendents(SubtreeLayoutScope* scope)\n{\n    ASSERT(!m_inRelativeLengthSVGRootsInvalidation);\n#if !ASSERT_DISABLED\n    TemporaryChange<bool> inRelativeLengthSVGRootsChange(m_inRelativeLengthSVGRootsInvalidation, true);\n#endif\n    HashSet<SVGSVGElement*>::iterator end = m_relativeLengthSVGRoots.end();\n    for (HashSet<SVGSVGElement*>::iterator it = m_relativeLengthSVGRoots.begin(); it != end; ++it)\n        (*it)->invalidateRelativeLengthClients(scope);\n}", "target": 0}
{"code": "static CURLcode file_done(struct connectdata *conn,\n                               CURLcode status, bool premature)\n{\n  struct FILEPROTO *file = conn->data->req.protop;\n  (void)status; \n  (void)premature; \n  if(file) {\n    Curl_safefree(file->freepath);\n    file->path = NULL;\n    if(file->fd != -1)\n      close(file->fd);\n    file->fd = -1;\n  }\n  return CURLE_OK;\n}", "target": 0}
{"code": "JOIN::init_range_rowid_filters()\n{\n  DBUG_ENTER(\"init_range_rowid_filters\");\n  JOIN_TAB *tab;\n  for (tab= first_linear_tab(this, WITH_BUSH_ROOTS, WITHOUT_CONST_TABLES);\n       tab;\n       tab= next_linear_tab(this, tab, WITH_BUSH_ROOTS))\n  {\n    if (!tab->rowid_filter)\n      continue;\n    if (tab->rowid_filter->get_container()->alloc())\n    {\n      delete tab->rowid_filter;\n      tab->rowid_filter= 0;\n      continue;\n    }\n    tab->table->file->rowid_filter_push(tab->rowid_filter);\n    tab->is_rowid_filter_built= false;\n  }\n  DBUG_RETURN(0);\n}", "target": 0}
{"code": "static int common_timer_create(struct k_itimer *new_timer)\n{\n\thrtimer_init(&new_timer->it.real.timer, new_timer->it_clock, 0);\n\treturn 0;\n}", "target": 0}
{"code": "elg_generate_ext (int algo, unsigned int nbits, unsigned long evalue,\n                  const gcry_sexp_t genparms,\n                  gcry_mpi_t *skey, gcry_mpi_t **retfactors,\n                  gcry_sexp_t *r_extrainfo)\n{\n  gpg_err_code_t ec;\n  ELG_secret_key sk;\n  gcry_mpi_t xvalue = NULL;\n  gcry_sexp_t l1;\n  (void)algo;\n  (void)evalue;\n  (void)r_extrainfo;\n  if (genparms)\n    {\n      l1 = gcry_sexp_find_token (genparms, \"xvalue\", 0);\n      if (l1)\n        {\n          xvalue = gcry_sexp_nth_mpi (l1, 1, 0);\n          gcry_sexp_release (l1);\n          if (!xvalue)\n            return GPG_ERR_BAD_MPI;\n        }\n    }\n  if (xvalue)\n    ec = generate_using_x (&sk, nbits, xvalue, retfactors);\n  else\n    {\n      generate (&sk, nbits, retfactors);\n      ec = 0;\n    }\n  skey[0] = sk.p;\n  skey[1] = sk.g;\n  skey[2] = sk.y;\n  skey[3] = sk.x;\n  return ec;\n}", "target": 0}
{"code": "BOOL license_read_platform_challenge_packet(rdpLicense* license, wStream* s)\n{\n\tBYTE MacData[16];\n\tUINT32 ConnectFlags = 0;\n\tDEBUG_LICENSE(\"Receiving Platform Challenge Packet\");\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\tStream_Read_UINT32(s, ConnectFlags); \n\tlicense->EncryptedPlatformChallenge->type = BB_ANY_BLOB;\n\tlicense_read_binary_blob(s, license->EncryptedPlatformChallenge);\n\tlicense->EncryptedPlatformChallenge->type = BB_ENCRYPTED_DATA_BLOB;\n\tif (Stream_GetRemainingLength(s) < 16)\n\t\treturn FALSE;\n\tStream_Read(s, MacData, 16); \n\tlicense_decrypt_platform_challenge(license);\n#ifdef WITH_DEBUG_LICENSE\n\tfprintf(stderr, \"ConnectFlags: 0x%08X\\n\", ConnectFlags);\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"EncryptedPlatformChallenge:\\n\");\n\twinpr_HexDump(license->EncryptedPlatformChallenge->data, license->EncryptedPlatformChallenge->length);\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"PlatformChallenge:\\n\");\n\twinpr_HexDump(license->PlatformChallenge->data, license->PlatformChallenge->length);\n\tfprintf(stderr, \"\\n\");\n\tfprintf(stderr, \"MacData:\\n\");\n\twinpr_HexDump(MacData, 16);\n\tfprintf(stderr, \"\\n\");\n#endif\n\treturn TRUE;\n}", "target": 0}
{"code": "hdb_samba4_check_pkinit_ms_upn_match(krb5_context context, HDB *db,\n\t\t\t\t     hdb_entry *entry,\n\t\t\t\t     krb5_const_principal certificate_principal)\n{\n\tstruct samba_kdc_db_context *kdc_db_ctx;\n\tstruct samba_kdc_entry *skdc_entry;\n\tkrb5_error_code ret;\n\tkdc_db_ctx = talloc_get_type_abort(db->hdb_db,\n\t\t\t\t\t   struct samba_kdc_db_context);\n\tskdc_entry = talloc_get_type_abort(entry->context,\n\t\t\t\t\t   struct samba_kdc_entry);\n\tret = samba_kdc_check_pkinit_ms_upn_match(context, kdc_db_ctx,\n\t\t\t\t\t\t  skdc_entry,\n\t\t\t\t\t\t  certificate_principal);\n\tswitch (ret) {\n\tcase 0:\n\t\tbreak;\n\tcase SDB_ERR_WRONG_REALM:\n\t\tret = HDB_ERR_WRONG_REALM;\n\t\tbreak;\n\tcase SDB_ERR_NOENTRY:\n\t\tret = HDB_ERR_NOENTRY;\n\t\tbreak;\n\tcase SDB_ERR_NOT_FOUND_HERE:\n\t\tret = HDB_ERR_NOT_FOUND_HERE;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "void encode(ArgumentEncoder* encoder, CFDictionaryRef dictionary)\n{\n    CFIndex size = CFDictionaryGetCount(dictionary);\n    Vector<CFTypeRef, 32> keys(size);\n    Vector<CFTypeRef, 32> values(size);\n    CFDictionaryGetKeysAndValues(dictionary, keys.data(), values.data());\n    encoder->encodeUInt64(size);\n    for (CFIndex i = 0; i < size; ++i) {\n        ASSERT(keys[i]);\n        ASSERT(CFGetTypeID(keys[i]) == CFStringGetTypeID());\n        ASSERT(values[i]);\n        if (typeFromCFTypeRef(values[i]) == Unknown)\n            continue;\n        encode(encoder, static_cast<CFStringRef>(keys[i]));\n        encode(encoder, values[i]);\n    }\n}", "target": 0}
{"code": "    template <class UnaryPredicate> void remove_if(UnaryPredicate p) {\n      headers_.remove_if([&](const HeaderEntryImpl& entry) {\n        const bool to_remove = p(entry);\n        if (to_remove) {\n          if (pseudo_headers_end_ == entry.entry_) {\n            pseudo_headers_end_++;\n          }\n        }\n        return to_remove;\n      });\n    }", "target": 0}
{"code": "static inline struct skb_shared_hwtstamps *skb_hwtstamps(struct sk_buff *skb)\n{\n\treturn &skb_shinfo(skb)->hwtstamps;\n}", "target": 0}
{"code": "mono_class_is_constraint_compatible (MonoClass *candidate, MonoClass *target)\n{\n\tif (candidate == target)\n\t\treturn TRUE;\n\tif (target == mono_defaults.object_class)\n\t\t\treturn TRUE;\n\tmono_class_setup_supertypes (candidate);\n\tmono_class_setup_supertypes (target);\n\tif (mono_class_has_parent (candidate, target))\n\t\treturn TRUE;\n\tif (!MONO_CLASS_IS_INTERFACE (target))\n\t\t\treturn FALSE;\n\tif (candidate->image->dynamic && !candidate->wastypebuilder) {\n\t\tMonoReflectionTypeBuilder *tb = candidate->reflection_info;\n\t\tint j;\n\t\tif (tb->interfaces) {\n\t\t\tfor (j = mono_array_length (tb->interfaces) - 1; j >= 0; --j) {\n\t\t\t\tMonoReflectionType *iface = mono_array_get (tb->interfaces, MonoReflectionType*, j);\n\t\t\t\tMonoClass *ifaceClass = mono_class_from_mono_type (iface->type);\n\t\t\t\tif (mono_class_is_constraint_compatible (ifaceClass, target)) {\n\t\t\t\t\treturn TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn FALSE;\n\t}\n\treturn mono_class_interface_implements_interface (candidate, target);\n}", "target": 0}
{"code": "static bool disk_unlock_native_capacity(struct gendisk *disk)\n{\n\tconst struct block_device_operations *bdops = disk->fops;\n\tif (bdops->unlock_native_capacity &&\n\t    !(disk->flags & GENHD_FL_NATIVE_CAPACITY)) {\n\t\tprintk(KERN_CONT \"enabling native capacity\\n\");\n\t\tbdops->unlock_native_capacity(disk);\n\t\tdisk->flags |= GENHD_FL_NATIVE_CAPACITY;\n\t\treturn true;\n\t} else {\n\t\tprintk(KERN_CONT \"truncated\\n\");\n\t\treturn false;\n\t}\n}", "target": 0}
{"code": "BGD_DECLARE(void) gdImageEllipse(gdImagePtr im, int mx, int my, int w, int h, int c)\n{\n\tint x=0,mx1=0,mx2=0,my1=0,my2=0;\n\tlong aq,bq,dx,dy,r,rx,ry,a,b;\n\ta=w>>1;\n\tb=h>>1;\n\tgdImageSetPixel(im,mx+a, my, c);\n\tgdImageSetPixel(im,mx-a, my, c);\n\tmx1 = mx-a;\n\tmy1 = my;\n\tmx2 = mx+a;\n\tmy2 = my;\n\taq = a * a;\n\tbq = b * b;\n\tdx = aq << 1;\n\tdy = bq << 1;\n\tr  = a * bq;\n\trx = r << 1;\n\try = 0;\n\tx = a;\n\twhile (x > 0) {\n\t\tif (r > 0) {\n\t\t\tmy1++;\n\t\t\tmy2--;\n\t\t\try +=dx;\n\t\t\tr  -=ry;\n\t\t}\n\t\tif (r <= 0) {\n\t\t\tx--;\n\t\t\tmx1++;\n\t\t\tmx2--;\n\t\t\trx -=dy;\n\t\t\tr  +=rx;\n\t\t}\n\t\tgdImageSetPixel(im,mx1, my1, c);\n\t\tgdImageSetPixel(im,mx1, my2, c);\n\t\tgdImageSetPixel(im,mx2, my1, c);\n\t\tgdImageSetPixel(im,mx2, my2, c);\n\t}\n}", "target": 0}
{"code": "void HTMLTextAreaElement::handleFocusEvent(Element*, FocusDirection)\n{\n    if (Frame* frame = document().frame())\n        frame->spellChecker().didBeginEditing(this);\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::RemoveKeyPressEventCallback(\n    const KeyPressEventCallback& callback) {\n  for (size_t i = 0; i < key_press_event_callbacks_.size(); ++i) {\n    if (key_press_event_callbacks_[i].Equals(callback)) {\n      key_press_event_callbacks_.erase(\n          key_press_event_callbacks_.begin() + i);\n      return;\n    }\n  }\n}", "target": 0}
{"code": "void gf_sleep(u32 ms)\n{\n#ifdef WIN32\n\tSleep(ms);\n#else\n\ts32 sel_err;\n\tstruct timeval tv;\n#ifndef SLEEP_ABS_SELECT\n\tu32 prev, now, elapsed;\n#endif\n#ifdef SLEEP_ABS_SELECT\n\ttv.tv_sec = ms/1000;\n\ttv.tv_usec = (ms%1000)*1000;\n#else\n\tprev = gf_sys_clock();\n#endif\n\tdo {\n\t\terrno = 0;\n#ifndef SLEEP_ABS_SELECT\n\t\tnow = gf_sys_clock();\n\t\telapsed = (now - prev);\n\t\tif ( elapsed >= ms ) {\n\t\t\tbreak;\n\t\t}\n\t\tprev = now;\n\t\tms -= elapsed;\n\t\ttv.tv_sec = ms/1000;\n\t\ttv.tv_usec = (ms%1000)*1000;\n#endif\n\t\tsel_err = select(0, NULL, NULL, NULL, &tv);\n\t} while ( sel_err && (errno == EINTR) );\n#endif\n}", "target": 0}
{"code": "isdn_minor2drv(int minor)\n{\n\treturn (dev->drvmap[minor]);\n}", "target": 0}
{"code": "static inline void zone_statistics(struct zone *preferred_zone, struct zone *z)\n{\n#ifdef CONFIG_NUMA\n\tenum numa_stat_item local_stat = NUMA_LOCAL;\n\tif (!static_branch_likely(&vm_numa_stat_key))\n\t\treturn;\n\tif (z->node != numa_node_id())\n\t\tlocal_stat = NUMA_OTHER;\n\tif (z->node == preferred_zone->node)\n\t\t__inc_numa_state(z, NUMA_HIT);\n\telse {\n\t\t__inc_numa_state(z, NUMA_MISS);\n\t\t__inc_numa_state(preferred_zone, NUMA_FOREIGN);\n\t}\n\t__inc_numa_state(z, local_stat);\n#endif\n}", "target": 0}
{"code": "void JOIN::get_prefix_cost_and_fanout(uint n_tables, \n                                      double *read_time_arg,\n                                      double *record_count_arg)\n{\n  double record_count= 1;\n  double read_time= 0.0;\n  for (uint i= const_tables; i < n_tables + const_tables ; i++)\n  {\n    if (best_positions[i].records_read)\n    {\n      record_count= COST_MULT(record_count, best_positions[i].records_read);\n      read_time= COST_ADD(read_time, best_positions[i].read_time);\n    }\n  }\n  *read_time_arg= read_time;\n  *record_count_arg= record_count;\n}", "target": 0}
{"code": "GF_Err mdia_box_size(GF_Box *s)\n{\n\tu32 pos = 0;\n\tGF_MediaBox *ptr = (GF_MediaBox *)s;\n\tgf_isom_check_position(s, (GF_Box*)ptr->mediaHeader, &pos);\n\tgf_isom_check_position(s, (GF_Box*)ptr->handler, &pos);\n\tgf_isom_check_position(s, (GF_Box*)ptr->information, &pos);\n\treturn GF_OK;\n}", "target": 0}
{"code": "const char* InstanceKlass::signature_name() const {\n  int hash_len = 0;\n  char hash_buf[40];\n  const char* src = (const char*) (name()->as_C_string());\n  const int src_length = (int)strlen(src);\n  char* dest = NEW_RESOURCE_ARRAY(char, src_length + hash_len + 3);\n  int dest_index = 0;\n  dest[dest_index++] = JVM_SIGNATURE_CLASS;\n  for (int src_index = 0; src_index < src_length; ) {\n    dest[dest_index++] = src[src_index++];\n  }\n  if (is_hidden()) { \n    for (int index = (int)src_length; index > 0; index--) {\n      if (dest[index] == '+') {\n        dest[index] = JVM_SIGNATURE_DOT;\n        break;\n      }\n    }\n  }\n  for (int hash_index = 0; hash_index < hash_len; ) {\n    dest[dest_index++] = hash_buf[hash_index++];\n  }\n  dest[dest_index++] = JVM_SIGNATURE_ENDCLASS;\n  dest[dest_index] = '\\0';\n  return dest;\n}", "target": 0}
{"code": "    void CiffEntry::doDecode(Image& image, ByteOrder byteOrder) const\n    {\n        CrwMap::decode(*this, image, byteOrder);\n    } ", "target": 0}
{"code": "lexer_scan_identifier (parser_context_t *context_p, \n                       lexer_parse_options_t opts) \n{\n  lexer_skip_spaces (context_p);\n  context_p->token.keyword_type = LEXER_EOS;\n  context_p->token.line = context_p->line;\n  context_p->token.column = context_p->column;\n  if (context_p->source_p < context_p->source_end_p && lexer_parse_identifier (context_p, opts))\n  {\n    return true;\n  }\n  context_p->token.flags |= LEXER_NO_SKIP_SPACES;\n  lexer_next_token (context_p);\n  return false;\n} ", "target": 0}
{"code": "static void _default_exception_get_entry(zval *object, char *name, int name_len, zval *return_value TSRMLS_DC) \n{\n\tzval *value;\n\tvalue = zend_read_property(default_exception_ce, object, name, name_len, 0 TSRMLS_CC);\n\t*return_value = *value;\n\tzval_copy_ctor(return_value);\n\tINIT_PZVAL(return_value);\n}", "target": 0}
{"code": "z2grestoreall(i_ctx_t *i_ctx_p)\n{\n    for (;;) {\n        int code = restore_page_device(i_ctx_p, igs, gs_gstate_saved(igs));\n        if (code < 0) return code;\n        if (code == 0) {\n            bool done = !gs_gstate_saved(gs_gstate_saved(igs));\n            gs_grestore(igs);\n            if (done)\n                break;\n        } else\n            return push_callout(i_ctx_p, \"%grestoreallpagedevice\");\n    }\n    return 0;\n}", "target": 0}
{"code": "static void kvp_release_lock(int pool)\n{\n\tstruct flock fl = {F_UNLCK, SEEK_SET, 0, 0, 0};\n\tfl.l_pid = getpid();\n\tif (fcntl(kvp_file_info[pool].fd, F_SETLK, &fl) == -1) {\n\t\tperror(\"fcntl\");\n\t\tsyslog(LOG_ERR, \"Failed to release the lock pool: %d\", pool);\n\t\texit(EXIT_FAILURE);\n\t}\n}", "target": 0}
{"code": "static char *sqfs_get_abs_path(const char *base, const char *rel)\n{\n\tchar **base_tokens, **rel_tokens, *resolved = NULL;\n\tint ret, bc, rc, i, updir = 0, resolved_size = 0, offset = 0;\n\tbase_tokens = NULL;\n\trel_tokens = NULL;\n\tbc = sqfs_count_tokens(base);\n\trc = sqfs_count_tokens(rel);\n\tif (bc < 1 || rc < 1)\n\t\treturn NULL;\n\tbase_tokens = calloc(bc, sizeof(char *));\n\tif (!base_tokens)\n\t\treturn NULL;\n\trel_tokens = calloc(rc, sizeof(char *));\n\tif (!rel_tokens)\n\t\tgoto out;\n\tret = sqfs_tokenize(base_tokens, bc, base);\n\tif (ret)\n\t\tgoto out;\n\tret = sqfs_tokenize(rel_tokens, rc, rel);\n\tif (ret)\n\t\tgoto out;\n\tfor (i = 0; i < rc; i++) {\n\t\tif (!strcmp(rel_tokens[i], \"..\"))\n\t\t\tupdir++;\n\t}\n\tbc = sqfs_clean_base_path(base_tokens, bc, updir);\n\tif (bc < 0)\n\t\tgoto out;\n\tif (!bc)\n\t\tresolved_size++;\n\tresolved_size += sqfs_get_tokens_length(base_tokens, bc) +\n\t\tsqfs_get_tokens_length(rel_tokens, rc);\n\tresolved = malloc(resolved_size + 1);\n\tif (!resolved)\n\t\tgoto out;\n\tmemset(resolved, '\\0', resolved_size + 1);\n\toffset += sqfs_join(base_tokens, resolved + offset, 0, bc, '/');\n\tresolved[offset++] = '/';\n\toffset += sqfs_join(rel_tokens, resolved + offset, updir, rc, '/');\nout:\n\tif (rel_tokens)\n\t\tfor (i = 0; i < rc; i++)\n\t\t\tfree(rel_tokens[i]);\n\tif (base_tokens)\n\t\tfor (i = 0; i < bc; i++)\n\t\t\tfree(base_tokens[i]);\n\tfree(rel_tokens);\n\tfree(base_tokens);\n\treturn resolved;\n}", "target": 0}
{"code": "DLLIMPORT int cfg_setfloat(cfg_t *cfg, const char *name, double value)\n{\n\treturn cfg_setnfloat(cfg, name, value, 0);\n}", "target": 0}
{"code": "make_regexp(const char *s, long len, rb_encoding *enc, int flags, onig_errmsg_buffer err,\n\tconst char *sourcefile, int sourceline)\n{\n    Regexp *rp;\n    int r;\n    OnigErrorInfo einfo;\n    r = onig_new_with_source(&rp, (UChar*)s, (UChar*)(s + len), flags,\n\t\t enc, OnigDefaultSyntax, &einfo, sourcefile, sourceline);\n    if (r) {\n\tonig_error_code_to_str((UChar*)err, r, &einfo);\n\treturn 0;\n    }\n    return rp;\n}", "target": 0}
{"code": "int js_pconstruct(js_State *J, int n)\n{\n\tint savetop = TOP - n - 2;\n\tif (js_try(J)) {\n\t\tSTACK[savetop] = STACK[TOP-1];\n\t\tTOP = savetop + 1;\n\t\treturn 1;\n\t}\n\tjs_construct(J, n);\n\tjs_endtry(J);\n\treturn 0;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, ShardFilterBasicProjCovered) {\n    params.options = QueryPlannerParams::INCLUDE_SHARD_FILTER;\n    params.shardKey = BSON(\"a\" << 1);\n    addIndex(BSON(\"a\" << 1));\n    runQuerySortProj(fromjson(\"{a: 1}\"), BSONObj(), fromjson(\"{_id : 0, a : 1}\"));\n    assertNumSolutions(1U);\n    assertSolutionExists(\n        \"{proj: {spec: {_id: 0, a: 1}, type: 'coveredIndex', node: \"\n        \"{sharding_filter: {node: \"\n        \"{ixscan: {pattern: {a: 1}}}}}}}\");\n}", "target": 0}
{"code": "bool __zone_watermark_ok(struct zone *z, unsigned int order, unsigned long mark,\n\t\t\t int classzone_idx, unsigned int alloc_flags,\n\t\t\t long free_pages)\n{\n\tlong min = mark;\n\tint o;\n\tconst bool alloc_harder = (alloc_flags & (ALLOC_HARDER|ALLOC_OOM));\n\tfree_pages -= (1 << order) - 1;\n\tif (alloc_flags & ALLOC_HIGH)\n\t\tmin -= min / 2;\n\tif (likely(!alloc_harder)) {\n\t\tfree_pages -= z->nr_reserved_highatomic;\n\t} else {\n\t\tif (alloc_flags & ALLOC_OOM)\n\t\t\tmin -= min / 2;\n\t\telse\n\t\t\tmin -= min / 4;\n\t}\n#ifdef CONFIG_CMA\n\tif (!(alloc_flags & ALLOC_CMA))\n\t\tfree_pages -= zone_page_state(z, NR_FREE_CMA_PAGES);\n#endif\n\tif (free_pages <= min + z->lowmem_reserve[classzone_idx])\n\t\treturn false;\n\tif (!order)\n\t\treturn true;\n\tfor (o = order; o < MAX_ORDER; o++) {\n\t\tstruct free_area *area = &z->free_area[o];\n\t\tint mt;\n\t\tif (!area->nr_free)\n\t\t\tcontinue;\n\t\tfor (mt = 0; mt < MIGRATE_PCPTYPES; mt++) {\n\t\t\tif (!list_empty(&area->free_list[mt]))\n\t\t\t\treturn true;\n\t\t}\n#ifdef CONFIG_CMA\n\t\tif ((alloc_flags & ALLOC_CMA) &&\n\t\t    !list_empty(&area->free_list[MIGRATE_CMA])) {\n\t\t\treturn true;\n\t\t}\n#endif\n\t\tif (alloc_harder &&\n\t\t\t!list_empty(&area->free_list[MIGRATE_HIGHATOMIC]))\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "target": 0}
{"code": "struct file *file_open_root(struct dentry *dentry, struct vfsmount *mnt,\n\t\t\t    const char *filename, int flags)\n{\n\tstruct open_flags op;\n\tint err = build_open_flags(flags, 0, &op);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tif (flags & O_CREAT)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (!filename && (flags & O_DIRECTORY))\n\t\tif (!dentry->d_inode->i_op->lookup)\n\t\t\treturn ERR_PTR(-ENOTDIR);\n\treturn do_file_open_root(dentry, mnt, filename, &op);\n}", "target": 0}
{"code": "void clear_zone_contiguous(struct zone *zone)\n{\n\tzone->contiguous = false;\n}", "target": 0}
{"code": "entry_repeat_range(regex_t* reg, int id, int lower, int upper)\n{\n#define REPEAT_RANGE_ALLOC  4\n  OnigRepeatRange* p;\n  if (reg->repeat_range_alloc == 0) {\n    p = (OnigRepeatRange* )xmalloc(sizeof(OnigRepeatRange) * REPEAT_RANGE_ALLOC);\n    CHECK_NULL_RETURN_MEMERR(p);\n    reg->repeat_range = p;\n    reg->repeat_range_alloc = REPEAT_RANGE_ALLOC;\n  }\n  else if (reg->repeat_range_alloc <= id) {\n    int n;\n    n = reg->repeat_range_alloc + REPEAT_RANGE_ALLOC;\n    p = (OnigRepeatRange* )xrealloc(reg->repeat_range,\n                                    sizeof(OnigRepeatRange) * n);\n    CHECK_NULL_RETURN_MEMERR(p);\n    reg->repeat_range = p;\n    reg->repeat_range_alloc = n;\n  }\n  else {\n    p = reg->repeat_range;\n  }\n  p[id].lower = lower;\n  p[id].upper = (IS_REPEAT_INFINITE(upper) ? 0x7fffffff : upper);\n  return 0;\n}", "target": 0}
{"code": "    StringValueBase::~StringValueBase()\n    {\n    }", "target": 0}
{"code": "uint8_t sftp_client_message_get_type(sftp_client_message msg){\n\treturn msg->type;\n}", "target": 0}
{"code": "BGD_DECLARE(int) gdImageColorClosestAlpha (gdImagePtr im, int r, int g, int b, int a)\n{\n\tint i;\n\tlong rd, gd, bd, ad;\n\tint ct = (-1);\n\tint first = 1;\n\tlong mindist = 0;\n\tif (im->trueColor) {\n\t\treturn gdTrueColorAlpha (r, g, b, a);\n\t}\n\tfor (i = 0; (i < (im->colorsTotal)); i++) {\n\t\tlong dist;\n\t\tif (im->open[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\trd = (im->red[i] - r);\n\t\tgd = (im->green[i] - g);\n\t\tbd = (im->blue[i] - b);\n\t\tad = (im->alpha[i] - a);\n\t\tdist = rd * rd + gd * gd + bd * bd + ad * ad;\n\t\tif (first || (dist < mindist)) {\n\t\t\tmindist = dist;\n\t\t\tct = i;\n\t\t\tfirst = 0;\n\t\t}\n\t}\n\treturn ct;\n}", "target": 0}
{"code": "static int nfs4_xdr_dec_reclaim_complete(struct rpc_rqst *rqstp,\n\t\t\t\t\t struct xdr_stream *xdr,\n\t\t\t\t\t struct nfs41_reclaim_complete_res *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (!status)\n\t\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (!status)\n\t\tstatus = decode_reclaim_complete(xdr, (void *)NULL);\n\treturn status;\n}", "target": 0}
{"code": "static const char *set_signature_flag(cmd_parms *cmd, void *d_,\n                                      const char *arg)\n{\n    core_dir_config *d = d_;\n    if (ap_cstr_casecmp(arg, \"On\") == 0) {\n        d->server_signature = srv_sig_on;\n    }\n    else if (ap_cstr_casecmp(arg, \"Off\") == 0) {\n        d->server_signature = srv_sig_off;\n    }\n    else if (ap_cstr_casecmp(arg, \"EMail\") == 0) {\n        d->server_signature = srv_sig_withmail;\n    }\n    else {\n        return \"ServerSignature: use one of: off | on | email\";\n    }\n    return NULL;\n}", "target": 0}
{"code": "static int gdAlphaOverlayColor (int src, int dst, int max )\n{\n\tdst = dst << 1;\n\tif( dst > max ) {\n\t\treturn dst + (src << 1) - (dst * src / max) - max;\n\t} else {\n\t\treturn dst * src / max;\n\t}\n}", "target": 0}
{"code": "my_decimal *Item_int::val_decimal(my_decimal *decimal_value)\n{\n  int2my_decimal(E_DEC_FATAL_ERROR, value, unsigned_flag, decimal_value);\n  return decimal_value;\n}", "target": 0}
{"code": "gx_dc_is_pattern2_color(const gx_device_color *pdevc)\n{\n    return pdevc->type == &gx_dc_pattern2;\n}", "target": 0}
{"code": "static int ping_v4_push_pending_frames(struct sock *sk, struct pingfakehdr *pfh,\n\t\t\t\t       struct flowi4 *fl4)\n{\n\tstruct sk_buff *skb = skb_peek(&sk->sk_write_queue);\n\tif (!skb)\n\t\treturn 0;\n\tpfh->wcheck = csum_partial((char *)&pfh->icmph,\n\t\tsizeof(struct icmphdr), pfh->wcheck);\n\tpfh->icmph.checksum = csum_fold(pfh->wcheck);\n\tmemcpy(icmp_hdr(skb), &pfh->icmph, sizeof(struct icmphdr));\n\tskb->ip_summed = CHECKSUM_NONE;\n\treturn ip_push_pending_frames(sk, fl4);\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, SortElimTrailingFields) {\n    addIndex(BSON(\"a\" << 1 << \"b\" << 1 << \"c\" << 1));\n    runQuerySortProj(fromjson(\"{a: 5}\"), BSON(\"b\" << 1), BSONObj());\n    ASSERT_EQUALS(getNumSolutions(), 2U);\n    assertSolutionExists(\n        \"{sort: {pattern: {b: 1}, limit: 0, node: {sortKeyGen: \"\n        \"{node: {cscan: {dir: 1, filter: {a: 5}}}}}}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: {ixscan: \"\n        \"{filter: null, pattern: {a: 1, b: 1, c: 1}}}}}\");\n}", "target": 0}
{"code": "handle_mic(OM_uint32 *minor_status, gss_buffer_t mic_in,\n\t   int send_mechtok, spnego_gss_ctx_id_t sc,\n\t   gss_buffer_t *mic_out,\n\t   OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 ret;\n\tret = GSS_S_FAILURE;\n\t*mic_out = GSS_C_NO_BUFFER;\n\tif (mic_in != GSS_C_NO_BUFFER) {\n\t\tif (sc->mic_rcvd) {\n\t\t\t*negState = REJECT;\n\t\t\t*tokflag = ERROR_TOKEN_SEND;\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t\t}\n\t} else if (sc->mic_reqd && !send_mechtok) {\n\t\t*negState = REJECT;\n\t\t*tokflag = ERROR_TOKEN_SEND;\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\tret = process_mic(minor_status, mic_in, sc, mic_out,\n\t\t\t  negState, tokflag);\n\tif (ret != GSS_S_COMPLETE) {\n\t\treturn ret;\n\t}\n\tif (sc->mic_reqd) {\n\t\tassert(sc->mic_sent || sc->mic_rcvd);\n\t}\n\tif (sc->mic_sent && sc->mic_rcvd) {\n\t\tret = GSS_S_COMPLETE;\n\t\t*negState = ACCEPT_COMPLETE;\n\t\tif (*mic_out == GSS_C_NO_BUFFER) {\n\t\t\tassert(!send_mechtok);\n\t\t\t*tokflag = NO_TOKEN_SEND;\n\t\t} else {\n\t\t\t*tokflag = CONT_TOKEN_SEND;\n\t\t}\n\t} else if (sc->mic_reqd) {\n\t\t*negState = ACCEPT_INCOMPLETE;\n\t\tret = GSS_S_CONTINUE_NEEDED;\n\t} else if (*negState == ACCEPT_COMPLETE) {\n\t\tret = GSS_S_COMPLETE;\n\t} else {\n\t\tret = GSS_S_CONTINUE_NEEDED;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "void HTMLMediaElement::NoneSupported(const String& input_message) {\n  BLINK_MEDIA_LOG << \"NoneSupported(\" << (void*)this << \", message='\"\n                  << input_message << \"')\";\n  StopPeriodicTimers();\n  load_state_ = kWaitingForSource;\n  current_source_node_ = nullptr;\n  String empty_string;\n  const String& message = MediaShouldBeOpaque() ? empty_string : input_message;\n  error_ = MediaError::Create(MediaError::kMediaErrSrcNotSupported, message);\n  ForgetResourceSpecificTracks();\n  SetNetworkState(kNetworkNoSource);\n  UpdateDisplayState();\n  ScheduleEvent(event_type_names::kError);\n  ScheduleRejectPlayPromises(DOMExceptionCode::kNotSupportedError);\n  CloseMediaSource();\n  SetShouldDelayLoadEvent(false);\n  if (GetLayoutObject())\n    GetLayoutObject()->UpdateFromElement();\n}", "target": 0}
{"code": "feed_textarea(char *str)\n{\n    if (cur_textarea == NULL)\n\treturn;\n    if (ignore_nl_textarea) {\n\tif (*str == '\\r')\n\t    str++;\n\tif (*str == '\\n')\n\t    str++;\n    }\n    ignore_nl_textarea = FALSE;\n    while (*str) {\n\tif (*str == '&')\n\t    Strcat_charp(textarea_str[n_textarea], getescapecmd(&str));\n\telse if (*str == '\\n') {\n\t    Strcat_charp(textarea_str[n_textarea], \"\\r\\n\");\n\t    str++;\n\t}\n\telse if (*str != '\\r')\n\t    Strcat_char(textarea_str[n_textarea], *(str++));\n    }\n}", "target": 0}
{"code": "static int xen_net_read_mac(struct xenbus_device *dev, u8 mac[])\n{\n\tchar *s, *e, *macstr;\n\tint i;\n\tmacstr = s = xenbus_read(XBT_NIL, dev->nodename, \"mac\", NULL);\n\tif (IS_ERR(macstr))\n\t\treturn PTR_ERR(macstr);\n\tfor (i = 0; i < ETH_ALEN; i++) {\n\t\tmac[i] = simple_strtoul(s, &e, 16);\n\t\tif ((s == e) || (*e != ((i == ETH_ALEN-1) ? '\\0' : ':'))) {\n\t\t\tkfree(macstr);\n\t\t\treturn -ENOENT;\n\t\t}\n\t\ts = e+1;\n\t}\n\tkfree(macstr);\n\treturn 0;\n}", "target": 0}
{"code": "static bool ok_png_read_palette(ok_png_decoder *decoder, uint32_t chunk_length) {\n    ok_png *png = decoder->png;\n    decoder->palette_length = chunk_length / 3;\n    if (decoder->palette_length > 256 || decoder->palette_length * 3 != chunk_length) {\n        ok_png_error(png, OK_PNG_ERROR_INVALID, \"Invalid palette chunk length\");\n        return false;\n    }\n    const bool src_is_bgr = decoder->is_ios_format;\n    const bool dst_is_bgr = (decoder->decode_flags & OK_PNG_COLOR_FORMAT_BGRA) != 0;\n    const bool should_byteswap = src_is_bgr != dst_is_bgr;\n    uint8_t *dst = decoder->palette;\n    uint8_t buffer[256 * 3];\n    if (!ok_read(decoder, buffer, 3 * decoder->palette_length)) {\n        return false;\n    }\n    uint8_t *in = buffer;\n    if (should_byteswap) {\n        for (uint32_t i = 0; i < decoder->palette_length; i++, in += 3, dst += 4) {\n            dst[0] = in[2];\n            dst[1] = in[1];\n            dst[2] = in[0];\n            dst[3] = 0xff;\n        }\n    } else {\n        for (uint32_t i = 0; i < decoder->palette_length; i++, in += 3, dst += 4) {\n            dst[0] = in[0];\n            dst[1] = in[1];\n            dst[2] = in[2];\n            dst[3] = 0xff;\n        }\n    }\n    return true;\n}", "target": 0}
{"code": "bool ChildProcessSecurityPolicyImpl::HasPermissionsForFileSystem(\n    int child_id,\n    const std::string& filesystem_id,\n    int permission) {\n  base::AutoLock lock(lock_);\n  SecurityStateMap::iterator state = security_state_.find(child_id);\n  if (state == security_state_.end())\n    return false;\n  return state->second->HasPermissionsForFileSystem(filesystem_id, permission);\n}", "target": 0}
{"code": "static SymbolsMetadata parseMetadata(RBuffer *buf, int off) {\n\tSymbolsMetadata sm = { 0 };\n\tut8 b[0x100] = { 0 };\n\t(void)r_buf_read_at (buf, off, b, sizeof (b));\n\tsm.addr = off;\n\tsm.cputype = r_read_le32 (b);\n\tsm.arch = typeString (sm.cputype, &sm.bits);\n\tsm.subtype = r_read_le32 (b + 4);\n\tsm.cpu = subtypeString (sm.subtype);\n\tsm.n_segments = r_read_le32 (b + 8);\n\tsm.namelen = r_read_le32 (b + 0xc);\n\tint delta = 16;\n\tsm.size = (sm.n_segments * 32) + sm.namelen + delta;\n\tut32 nm, nm2, nm3;\n\tr_buf_read_at (buf, off + sm.size, (ut8 *)&nm, sizeof (nm));\n\tr_buf_read_at (buf, off + sm.size + 4, (ut8 *)&nm2, sizeof (nm2));\n\tr_buf_read_at (buf, off + sm.size + 8, (ut8 *)&nm3, sizeof (nm3));\n\tif (r_read_le32 (&nm3) != 0xa1b22b1a) {\n\t\tsm.size -= 8;\n\t}\n\treturn sm;\n}", "target": 0}
{"code": "static int oidc_handle_unauthorized_user22(request_rec *r) {\n\toidc_cfg *c = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\tif (apr_strnatcasecmp((const char *) ap_auth_type(r), OIDC_AUTH_TYPE_OPENID_OAUTH20) == 0) {\n\t\toidc_oauth_return_www_authenticate(r, \"insufficient_scope\", \"Different scope(s) or other claims required\");\n\t\treturn HTTP_UNAUTHORIZED;\n\t}\n\tswitch (oidc_dir_cfg_unautz_action(r)) {\n\tcase OIDC_UNAUTZ_RETURN403:\n\t\treturn HTTP_FORBIDDEN;\n\tcase OIDC_UNAUTZ_RETURN401:\n\t\treturn HTTP_UNAUTHORIZED;\n\tcase OIDC_UNAUTZ_AUTHENTICATE:\n\t\tif (oidc_is_xml_http_request(r) == TRUE)\n\t\t\treturn HTTP_UNAUTHORIZED;\n\t}\n\treturn oidc_authenticate_user(r, c, NULL, oidc_get_current_url(r), NULL,\n\t\t\tNULL, NULL, oidc_dir_cfg_path_auth_request_params(r), oidc_dir_cfg_path_scope(r));\n}", "target": 0}
{"code": "static bool xennet_can_sg(struct net_device *dev)\n{\n\treturn dev->features & NETIF_F_SG;\n}", "target": 0}
{"code": "static inline bool cpu_has_vmx_virtualize_x2apic_mode(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;\n}", "target": 0}
{"code": "void Hybrid_type_traits_decimal::add(Hybrid_type *val, Field *f) const\n{\n  my_decimal_add(E_DEC_FATAL_ERROR,\n                 &val->dec_buf[val->used_dec_buf_no ^ 1],\n                 &val->dec_buf[val->used_dec_buf_no],\n                 f->val_decimal(&val->dec_buf[2]));\n  val->used_dec_buf_no^= 1;\n}", "target": 0}
{"code": "void RenderViewImpl::didHandleGestureEvent(const WebGestureEvent& event,\n                                           bool event_swallowed) {\n#if defined(OS_ANDROID)\n  if (event.type == WebInputEvent::GestureTap ||\n      event.type == WebInputEvent::GestureLongPress) {\n    UpdateTextInputState(SHOW_IME_IF_NEEDED);\n  }\n#endif\n  FOR_EACH_OBSERVER(RenderViewObserver, observers_,\n                    DidHandleGestureEvent(event));\n}", "target": 0}
{"code": "static bool _pam_check_remark_auth_err(struct pwb_context *ctx,\n\t\t\t\t       const struct wbcAuthErrorInfo *e,\n\t\t\t\t       const char *nt_status_string,\n\t\t\t\t       int *pam_error)\n{\n\tconst char *ntstatus = NULL;\n\tconst char *error_string = NULL;\n\tif (!e || !pam_error) {\n\t\treturn false;\n\t}\n\tntstatus = e->nt_string;\n\tif (!ntstatus) {\n\t\treturn false;\n\t}\n\tif (strcasecmp(ntstatus, nt_status_string) == 0) {\n\t\terror_string = _get_ntstatus_error_string(nt_status_string);\n\t\tif (error_string) {\n\t\t\t_make_remark(ctx, PAM_ERROR_MSG, error_string);\n\t\t\t*pam_error = e->pam_error;\n\t\t\treturn true;\n\t\t}\n\t\tif (e->display_string) {\n\t\t\t_make_remark(ctx, PAM_ERROR_MSG, e->display_string);\n\t\t\t*pam_error = e->pam_error;\n\t\t\treturn true;\n\t\t}\n\t\t_make_remark(ctx, PAM_ERROR_MSG, nt_status_string);\n\t\t*pam_error = e->pam_error;\n\t\treturn true;\n\t}\n\treturn false;\n};", "target": 0}
{"code": "WebFrame* RenderView::GetChildFrame(const std::wstring& xpath) const {\n  if (xpath.empty())\n    return webview()->mainFrame();\n  WebFrame* frame = webview()->mainFrame();\n  std::wstring xpath_remaining = xpath;\n  while (!xpath_remaining.empty()) {\n    std::wstring::size_type delim_pos = xpath_remaining.find_first_of(L'\\n');\n    std::wstring xpath_child;\n    if (delim_pos != std::wstring::npos) {\n      xpath_child = xpath_remaining.substr(0, delim_pos);\n      xpath_remaining.erase(0, delim_pos + 1);\n    } else {\n      xpath_remaining.swap(xpath_child);\n    }\n    frame = frame->findChildByExpression(WideToUTF16Hack(xpath_child));\n  }\n  return frame;\n}", "target": 0}
{"code": "PHP_FUNCTION(locale_get_display_variant)\n{\n    get_icu_disp_value_src_php( LOC_VARIANT_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );\n}", "target": 0}
{"code": "void SoftAMR::initPorts() {\n    OMX_PARAM_PORTDEFINITIONTYPE def;\n InitOMXParams(&def);\n    def.nPortIndex = 0;\n    def.eDir = OMX_DirInput;\n    def.nBufferCountMin = kNumBuffers;\n    def.nBufferCountActual = def.nBufferCountMin;\n    def.nBufferSize = 8192;\n    def.bEnabled = OMX_TRUE;\n    def.bPopulated = OMX_FALSE;\n    def.eDomain = OMX_PortDomainAudio;\n    def.bBuffersContiguous = OMX_FALSE;\n    def.nBufferAlignment = 1;\n    def.format.audio.cMIMEType =\n        mMode == MODE_NARROW\n ? const_cast<char *>(\"audio/amr\")\n : const_cast<char *>(\"audio/amrwb\");\n    def.format.audio.pNativeRender = NULL;\n    def.format.audio.bFlagErrorConcealment = OMX_FALSE;\n    def.format.audio.eEncoding = OMX_AUDIO_CodingAMR;\n    addPort(def);\n    def.nPortIndex = 1;\n    def.eDir = OMX_DirOutput;\n    def.nBufferCountMin = kNumBuffers;\n    def.nBufferCountActual = def.nBufferCountMin;\n    def.nBufferSize =\n (mMode == MODE_NARROW ? kNumSamplesPerFrameNB : kNumSamplesPerFrameWB)\n * sizeof(int16_t);\n    def.bEnabled = OMX_TRUE;\n    def.bPopulated = OMX_FALSE;\n    def.eDomain = OMX_PortDomainAudio;\n    def.bBuffersContiguous = OMX_FALSE;\n    def.nBufferAlignment = 2;\n    def.format.audio.cMIMEType = const_cast<char *>(\"audio/raw\");\n    def.format.audio.pNativeRender = NULL;\n    def.format.audio.bFlagErrorConcealment = OMX_FALSE;\n    def.format.audio.eEncoding = OMX_AUDIO_CodingPCM;\n    addPort(def);\n}", "target": 0}
{"code": "R_API RIOBank *r_io_bank_get(RIO *io, const ut32 bankid) {\n\tr_return_val_if_fail (io && io->banks, NULL);\n\treturn (RIOBank *)r_id_storage_get (io->banks, bankid);\n}", "target": 0}
{"code": "static ssize_t disk_events_poll_msecs_store(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\tlong intv;\n\tif (!count || !sscanf(buf, \"%ld\", &intv))\n\t\treturn -EINVAL;\n\tif (intv < 0 && intv != -1)\n\t\treturn -EINVAL;\n\tdisk_block_events(disk);\n\tdisk->ev->poll_msecs = intv;\n\t__disk_unblock_events(disk, true);\n\treturn count;\n}", "target": 0}
{"code": "inline double _af_byteswap_float64 (double x)\n{\n\tunion\n\t{\n\t\tuint64_t i;\n\t\tdouble f;\n\t} u;\n\tu.f = x;\n\tu.i = _af_byteswap_int64(u.i);\n\treturn u.f;\n}", "target": 0}
{"code": "static struct sctp_transport *sctp_trans_elect_best(struct sctp_transport *curr,\n\t\t\t\t\t\t    struct sctp_transport *best)\n{\n\tu8 score_curr, score_best;\n\tif (best == NULL)\n\t\treturn curr;\n\tscore_curr = sctp_trans_score(curr);\n\tscore_best = sctp_trans_score(best);\n\tif (score_curr > score_best)\n\t\treturn curr;\n\telse if (score_curr == score_best)\n\t\treturn sctp_trans_elect_tie(curr, best);\n\telse\n\t\treturn best;\n}", "target": 0}
{"code": "static ssize_t virtio_net_receive(NetClientState *nc, const uint8_t *buf,\n                                  size_t size)\n{\n    VirtIONet *n = qemu_get_nic_opaque(nc);\n    if ((n->rsc4_enabled || n->rsc6_enabled)) {\n        return virtio_net_rsc_receive(nc, buf, size);\n    } else {\n        return virtio_net_do_receive(nc, buf, size);\n    }\n}", "target": 0}
{"code": "static int selinux_task_getsid(struct task_struct *p)\n{\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    current_sid(), task_sid(p), SECCLASS_PROCESS,\n\t\t\t    PROCESS__GETSESSION, NULL);\n}", "target": 0}
{"code": "    void set_simulator(Simulator* simulator) {\n      simulator_ = simulator;\n    }", "target": 0}
{"code": "canonicalize_c_jd(VALUE obj, union DateData *x)\n{\n    int j = x->c.jd;\n    VALUE nth = x->c.nth;\n    assert(have_jd_p(x));\n    canonicalize_jd(nth, x->c.jd);\n    RB_OBJ_WRITE(obj, &x->c.nth, nth);\n    if (x->c.jd != j)\n\tx->flags &= ~HAVE_CIVIL;\n}", "target": 0}
{"code": "static void packet_cached_dev_reset(struct packet_sock *po)\n{\n\tRCU_INIT_POINTER(po->cached_dev, NULL);\n}", "target": 0}
{"code": "l2f(UINT8 *out_, const UINT8 *in, int xsize) {\n    int x;\n    for (x = 0; x < xsize; x++, out_ += 4) {\n        FLOAT32 f = (FLOAT32)*in++;\n        memcpy(out_, &f, sizeof(f));\n    }\n}", "target": 0}
{"code": "    TiffSubIfd* TiffSubIfd::doClone() const\n    {\n        return new TiffSubIfd(*this);\n    }", "target": 0}
{"code": "static int megasas_finish_internal_dcmd(MegasasCmd *cmd,\n                                        SCSIRequest *req)\n{\n    int opcode;\n    int retval = MFI_STAT_OK;\n    int lun = req->lun;\n    opcode = le32_to_cpu(cmd->frame->dcmd.opcode);\n    trace_megasas_dcmd_internal_finish(cmd->index, opcode, lun);\n    switch (opcode) {\n    case MFI_DCMD_PD_GET_INFO:\n        retval = megasas_pd_get_info_submit(req->dev, lun, cmd);\n        break;\n    case MFI_DCMD_LD_GET_INFO:\n        retval = megasas_ld_get_info_submit(req->dev, lun, cmd);\n        break;\n    default:\n        trace_megasas_dcmd_internal_invalid(cmd->index, opcode);\n        retval = MFI_STAT_INVALID_DCMD;\n        break;\n    }\n    if (retval != MFI_STAT_INVALID_STATUS) {\n        megasas_finish_dcmd(cmd, cmd->iov_size);\n    }\n    return retval;\n}", "target": 0}
{"code": "expand_case_fold_make_rem_string(Node** rnode, UChar *s, UChar *end,\n\t\t\t\t regex_t* reg)\n{\n  int r;\n  Node *node;\n  node = onig_node_new_str(s, end);\n  if (IS_NULL(node)) return ONIGERR_MEMORY;\n  r = update_string_node_case_fold(reg, node);\n  if (r != 0) {\n    onig_node_free(node);\n    return r;\n  }\n  NSTRING_SET_AMBIG(node);\n  NSTRING_SET_DONT_GET_OPT_INFO(node);\n  *rnode = node;\n  return 0;\n}", "target": 0}
{"code": "  HostQuotaCallback* NewWaitableHostQuotaCallback() {\n    ++waiting_callbacks_;\n    return callback_factory_.NewCallback(\n            &UsageAndQuotaDispatcherTask::DidGetHostQuota);\n  }", "target": 0}
{"code": "zzip_dir_open_ext_io(zzip_char_t * filename, zzip_error_t * e,\n                     zzip_strings_t * ext, zzip_plugin_io_t io)\n{\n    int fd;\n    if (! io)\n        io = zzip_get_default_io();\n    if (! ext)\n        ext = zzip_get_default_ext();\n    fd = (io->fd.open)(filename, O_RDONLY | O_BINARY);\n    if (fd != -1)\n    {\n        return zzip_dir_fdopen_ext_io(fd, e, ext, io);\n    } else\n    {\n        fd = __zzip_try_open(filename, O_RDONLY | O_BINARY, ext, io);\n        if (fd != -1)\n        {\n            return zzip_dir_fdopen_ext_io(fd, e, ext, io);\n        } else\n        {\n            if (e)\n                { *e = ZZIP_DIR_OPEN; }\n            return 0;\n        }\n    }\n}", "target": 0}
{"code": "onig_get_syntax_behavior(const OnigSyntaxType* syntax)\n{\n  return syntax->behavior;\n}", "target": 0}
{"code": "long keyctl_keyring_link(key_serial_t id, key_serial_t ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tlong ret;\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error;\n\t}\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE, KEY_LINK);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\tret = key_link(key_ref_to_ptr(keyring_ref), key_ref_to_ptr(key_ref));\n\tkey_ref_put(key_ref);\nerror2:\n\tkey_ref_put(keyring_ref);\nerror:\n\treturn ret;\n} ", "target": 0}
{"code": "ns_clientmgr_create(isc_mem_t *mctx, isc_taskmgr_t *taskmgr,\n\t\t    isc_timermgr_t *timermgr, ns_clientmgr_t **managerp)\n{\n\tns_clientmgr_t *manager;\n\tisc_result_t result;\n#if NMCTXS > 0\n\tint i;\n#endif\n\tmanager = isc_mem_get(mctx, sizeof(*manager));\n\tif (manager == NULL)\n\t\treturn (ISC_R_NOMEMORY);\n\tresult = isc_mutex_init(&manager->lock);\n\tif (result != ISC_R_SUCCESS)\n\t\tgoto cleanup_manager;\n\tresult = isc_mutex_init(&manager->listlock);\n\tif (result != ISC_R_SUCCESS)\n\t\tgoto cleanup_lock;\n\tresult = isc_mutex_init(&manager->reclock);\n\tif (result != ISC_R_SUCCESS)\n\t\tgoto cleanup_listlock;\n\tmanager->mctx = mctx;\n\tmanager->taskmgr = taskmgr;\n\tmanager->timermgr = timermgr;\n\tmanager->exiting = false;\n\tISC_LIST_INIT(manager->clients);\n\tISC_LIST_INIT(manager->recursing);\n\tISC_QUEUE_INIT(manager->inactive, ilink);\n#if NMCTXS > 0\n\tmanager->nextmctx = 0;\n\tfor (i = 0; i < NMCTXS; i++)\n\t\tmanager->mctxpool[i] = NULL; \n#endif\n\tmanager->magic = MANAGER_MAGIC;\n\tMTRACE(\"create\");\n\t*managerp = manager;\n\treturn (ISC_R_SUCCESS);\n cleanup_listlock:\n\t(void) isc_mutex_destroy(&manager->listlock);\n cleanup_lock:\n\t(void) isc_mutex_destroy(&manager->lock);\n cleanup_manager:\n\tisc_mem_put(manager->mctx, manager, sizeof(*manager));\n\treturn (result);\n}", "target": 0}
{"code": "RPVector *r_bin_wasm_get_functions(RBinWasmObj *bin) {\n\tr_return_val_if_fail (bin && bin->g_sections, NULL);\n\treturn bin->g_funcs? bin->g_funcs: parse_unique_subsec_vec_by_id (bin, R_BIN_WASM_SECTION_FUNCTION);\n}", "target": 0}
{"code": "end_sj_materialize(JOIN *join, JOIN_TAB *join_tab, bool end_of_records)\n{\n  int error;\n  THD *thd= join->thd;\n  SJ_MATERIALIZATION_INFO *sjm= join_tab[-1].emb_sj_nest->sj_mat_info;\n  DBUG_ENTER(\"end_sj_materialize\");\n  if (!end_of_records)\n  {\n    TABLE *table= sjm->table;\n    List_iterator<Item> it(sjm->sjm_table_cols);\n    Item *item;\n    while ((item= it++))\n    {\n      if (item->is_null())\n        DBUG_RETURN(NESTED_LOOP_OK);\n    }\n    fill_record(thd, table, table->field, sjm->sjm_table_cols, TRUE, FALSE);\n    if (unlikely(thd->is_error()))\n      DBUG_RETURN(NESTED_LOOP_ERROR); \n    if (unlikely((error= table->file->ha_write_tmp_row(table->record[0]))))\n    {\n      if (table->file->is_fatal_error(error, HA_CHECK_DUP) &&\n          create_internal_tmp_table_from_heap(thd, table,\n                                              sjm->sjm_table_param.start_recinfo, \n                                              &sjm->sjm_table_param.recinfo, error, 1, NULL))\n        DBUG_RETURN(NESTED_LOOP_ERROR); \n    }\n  }\n  DBUG_RETURN(NESTED_LOOP_OK);\n}", "target": 0}
{"code": "static inline int pit_in_range(gpa_t addr)\n{\n\treturn ((addr >= KVM_PIT_BASE_ADDRESS) &&\n\t\t(addr < KVM_PIT_BASE_ADDRESS + KVM_PIT_MEM_LENGTH));\n}", "target": 0}
{"code": "WebContentsImpl* WebContentsImpl::GetCreatedWindow(int route_id) {\n  PendingContents::iterator iter = pending_contents_.find(route_id);\n  if (iter == pending_contents_.end()) {\n    return NULL;\n  }\n  WebContentsImpl* new_contents = iter->second;\n  pending_contents_.erase(route_id);\n  RemoveDestructionObserver(new_contents);\n  if (new_contents->GetRenderProcessHost()->IsGuest())\n    return new_contents;\n  if (!new_contents->GetRenderProcessHost()->HasConnection() ||\n      !new_contents->GetRenderViewHost()->GetView())\n    return NULL;\n  static_cast<RenderViewHostImpl*>(new_contents->GetRenderViewHost())->Init();\n  return new_contents;\n}", "target": 0}
{"code": "static void dbus_bus_acquired(GDBusConnection *connection,\n\t\t\t      const gchar *name,\n\t\t\t      gpointer user_data)\n{\n\tstruct tcmur_handler **handler;\n\ttcmu_dbg(\"bus %s acquired\\n\", name);\n\tmanager = g_dbus_object_manager_server_new(\"/org/kernel/TCMUService1\");\n\tdarray_foreach(handler, g_runner_handlers) {\n\t\tdbus_export_handler(*handler, G_CALLBACK(on_check_config));\n\t}\n\tdbus_handler_manager1_init(connection);\n\tg_dbus_object_manager_server_set_connection(manager, connection);\n}", "target": 0}
{"code": "int ZEXPORT inflatePrime(strm, bits, value)\nz_streamp strm;\nint bits;\nint value;\n{\n    struct inflate_state FAR *state;\n    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm->state;\n    if (bits < 0) {\n        state->hold = 0;\n        state->bits = 0;\n        return Z_OK;\n    }\n    if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;\n    value &= (1L << bits) - 1;\n    state->hold += (unsigned)value << state->bits;\n    state->bits += bits;\n    return Z_OK;\n}", "target": 0}
{"code": "SoftVPXEncoder::SoftVPXEncoder(const char *name,\n const OMX_CALLBACKTYPE *callbacks,\n                               OMX_PTR appData,\n                               OMX_COMPONENTTYPE **component)\n : SoftVideoEncoderOMXComponent(\n            name, \"video_encoder.vp8\", OMX_VIDEO_CodingVP8,\n            kProfileLevels, NELEM(kProfileLevels),\n 176 , 144 ,\n            callbacks, appData, component),\n      mCodecContext(NULL),\n      mCodecConfiguration(NULL),\n      mCodecInterface(NULL),\n      mBitrateUpdated(false),\n      mBitrateControlMode(VPX_VBR), \n      mDCTPartitions(0),\n      mErrorResilience(OMX_FALSE),\n      mLevel(OMX_VIDEO_VP8Level_Version0),\n      mKeyFrameInterval(0),\n      mMinQuantizer(0),\n      mMaxQuantizer(0),\n      mTemporalLayers(0),\n      mTemporalPatternType(OMX_VIDEO_VPXTemporalLayerPatternNone),\n      mTemporalPatternLength(0),\n      mTemporalPatternIdx(0),\n      mLastTimestamp(0x7FFFFFFFFFFFFFFFLL),\n      mConversionBuffer(NULL),\n      mKeyFrameRequested(false) {\n    memset(mTemporalLayerBitrateRatio, 0, sizeof(mTemporalLayerBitrateRatio));\n    mTemporalLayerBitrateRatio[0] = 100;\n const size_t kMinOutputBufferSize = 1024 * 1024; \n    initPorts(\n            kNumBuffers, kNumBuffers, kMinOutputBufferSize,\n            MEDIA_MIMETYPE_VIDEO_VP8, 2 );\n}", "target": 0}
{"code": "int X509_REQ_add1_attr(X509_REQ *req, X509_ATTRIBUTE *attr)\n{\n    if (X509at_add1_attr(&req->req_info->attributes, attr))\n        return 1;\n    return 0;\n}", "target": 0}
{"code": "DECLAREcpFunc(cpContigTiles2ContigStrips)\n{\n\treturn cpImage(in, out,\n\t    readContigTilesIntoBuffer,\n\t    writeBufferToContigStrips,\n\t    imagelength, imagewidth, spp);\n}", "target": 0}
{"code": "KURL FrameLoader::baseURL() const\n{\n    ASSERT(m_frame->document());\n    return m_frame->document()->baseURL();\n}", "target": 0}
{"code": "PHP_FUNCTION(pg_consume_input)\n{\n\tzval *pgsql_link;\n\tint id = -1;\n\tPGconn *pgsql;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r\", &pgsql_link) == FAILURE) {\n\t\treturn;\n\t}\n\tZEND_FETCH_RESOURCE2(pgsql, PGconn *, pgsql_link, id, \"PostgreSQL link\", le_link, le_plink);\n\tRETURN_BOOL(PQconsumeInput(pgsql));\n}", "target": 0}
{"code": "PHP_FUNCTION(log1p)\n{\n\tdouble num;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"d\", &num) == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_DOUBLE(php_log1p(num));\n}", "target": 0}
{"code": "void kvm_define_shared_msr(unsigned slot, u32 msr)\n{\n\tBUG_ON(slot >= KVM_NR_SHARED_MSRS);\n\tif (slot >= shared_msrs_global.nr)\n\t\tshared_msrs_global.nr = slot + 1;\n\tshared_msrs_global.msrs[slot] = msr;\n\tsmp_wmb();\n}", "target": 0}
{"code": "static void dump_backtrace()\n{\n    HANDLE hCurrentThread;\n    HANDLE hThread;\n    DWORD dwThreadId;\n    DuplicateHandle(GetCurrentProcess(), GetCurrentThread(),\n        GetCurrentProcess(), &hCurrentThread, 0, FALSE, DUPLICATE_SAME_ACCESS);\n    hThread = CreateThread(NULL, 0, dump_thread_proc, (LPVOID)hCurrentThread,\n        0, &dwThreadId);\n    WaitForSingleObject(hThread, INFINITE);\n    CloseHandle(hThread);\n    CloseHandle(hCurrentThread);\n}", "target": 0}
{"code": "comp_addr_base (const void * v0, const void * v1)\n{\n  debug_info *info0 = *(debug_info **) v0;\n  debug_info *info1 = *(debug_info **) v1;\n  return info0->addr_base - info1->addr_base;\n}", "target": 0}
{"code": "DEATH_TEST(LtOp, InvalidEooOperand, \"Invariant failure _rhs\") {\n    BSONObj operand;\n    LTMatchExpression lt(\"\", operand.firstElement());\n}", "target": 0}
{"code": "static void iova_entry_free(unsigned long data)\n{\n\tstruct page *freelist = (struct page *)data;\n\tdma_free_pagelist(freelist);\n}", "target": 0}
{"code": "inline void Splash::pipeIncX(SplashPipe *pipe) {\n  ++pipe->x;\n  if (state->softMask) {\n    ++pipe->softMaskPtr;\n  }\n  switch (bitmap->mode) {\n  case splashModeMono1:\n    if (!(pipe->destColorMask >>= 1)) {\n      pipe->destColorMask = 0x80;\n      ++pipe->destColorPtr;\n    }\n    break;\n  case splashModeMono8:\n    ++pipe->destColorPtr;\n    break;\n  case splashModeRGB8:\n  case splashModeBGR8:\n    pipe->destColorPtr += 3;\n    break;\n  case splashModeXBGR8:\n    pipe->destColorPtr += 4;\n    break;\n#if SPLASH_CMYK\n  case splashModeCMYK8:\n    pipe->destColorPtr += 4;\n    break;\n  case splashModeDeviceN8:\n    pipe->destColorPtr += (SPOT_NCOMPS+4);\n    break;\n#endif\n  }\n  if (pipe->destAlphaPtr) {\n    ++pipe->destAlphaPtr;\n  }\n  if (pipe->alpha0Ptr) {\n    ++pipe->alpha0Ptr;\n  }\n}", "target": 0}
{"code": "void WebGraphicsContext3DDefaultImpl::angleDestroyCompilers()\n{\n    if (m_fragmentCompiler) {\n        ShDestruct(m_fragmentCompiler);\n        m_fragmentCompiler = 0;\n    }\n    if (m_vertexCompiler) {\n        ShDestruct(m_vertexCompiler);\n        m_vertexCompiler = 0;\n    }\n}", "target": 0}
{"code": "bool SVGDocumentExtensions::isElementPendingResource(Element* element, const AtomicString& id) const\n{\n    ASSERT(element);\n    if (!hasPendingResource(id))\n        return false;\n    return m_pendingResources.get(id)->contains(element);\n}", "target": 0}
{"code": "static unsigned ucvector_push_back(ucvector* p, unsigned char c)\n{\n  if(!ucvector_resize(p, p->size + 1)) return 0;\n  p->data[p->size - 1] = c;\n  return 1;\n}", "target": 0}
{"code": "int afGetVirtualByteOrder (AFfilehandle handle, int track)\n{\n\t_Track *currentTrack;\n\tif (!_af_filehandle_ok(handle))\n\t\treturn -1;\n\tif ((currentTrack = _af_filehandle_get_track(handle, track)) == NULL)\n\t\treturn -1;\n\treturn (currentTrack->v.byteOrder);\n}", "target": 0}
{"code": "   Reopen an IMAP stream to a new mailbox */\nPHP_FUNCTION(imap_reopen)\n{\n\tzval *streamind;\n\tzend_string *mailbox;\n\tzend_long options = 0, retries = 0;\n\tpils *imap_le_struct;\n\tlong flags=NIL;\n\tlong cl_flags=NIL;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rS|ll\", &streamind, &mailbox, &options, &retries) == FAILURE) {\n\t\treturn;\n\t}\n\tif ((imap_le_struct = (pils *)zend_fetch_resource(Z_RES_P(streamind), \"imap\", le_imap)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tif (options) {\n\t\tflags = options;\n\t\tif (flags & PHP_EXPUNGE) {\n\t\t\tcl_flags = CL_EXPUNGE;\n\t\t\tflags ^= PHP_EXPUNGE;\n\t\t}\n\t\timap_le_struct->flags = cl_flags;\n\t}\n#ifdef SET_MAXLOGINTRIALS\n\tif (retries) {\n\t\tmail_parameters(NIL, SET_MAXLOGINTRIALS, (void *) retries);\n\t}\n#endif\n\tif (ZSTR_VAL(mailbox)[0] != '{' && php_check_open_basedir(ZSTR_VAL(mailbox))) {\n\t\tRETURN_FALSE;\n\t}\n\timap_le_struct->imap_stream = mail_open(imap_le_struct->imap_stream, ZSTR_VAL(mailbox), flags);\n\tif (imap_le_struct->imap_stream == NIL) {\n\t\tzend_list_delete(Z_RES_P(streamind));\n\t\tphp_error_docref(NULL, E_WARNING, \"Couldn't re-open stream\");\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_TRUE;", "target": 0}
{"code": "htmlblock_end(const char *curtag,\n\tstruct sd_markdown *rndr,\n\tuint8_t *data,\n\tsize_t size,\n\tint start_of_line)\n{\n\tsize_t tag_size = strlen(curtag);\n\tsize_t i = 1, end_tag;\n\tint block_lines = 0;\n\twhile (i < size) {\n\t\ti++;\n\t\twhile (i < size && !(data[i - 1] == '<' && data[i] == '/')) {\n\t\t\tif (data[i] == '\\n')\n\t\t\t\tblock_lines++;\n\t\t\ti++;\n\t\t}\n\t\tif (start_of_line && block_lines > 0 && data[i - 2] != '\\n')\n\t\t\tcontinue;\n\t\tif (i + 2 + tag_size >= size)\n\t\t\tbreak;\n\t\tend_tag = htmlblock_end_tag(curtag, tag_size, rndr, data + i - 1, size - i + 1);\n\t\tif (end_tag)\n\t\t\treturn i + end_tag - 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "  Number* Parser::lexed_dimension(const ParserState& pstate, const std::string& parsed)\n  {\n    size_t L = parsed.length();\n    size_t num_pos = parsed.find_first_not_of(\" \\n\\r\\t\");\n    if (num_pos == std::string::npos) num_pos = L;\n    size_t unit_pos = parsed.find_first_not_of(\"-+0123456789.\", num_pos);\n    if (parsed[unit_pos] == 'e' && is_number(parsed[unit_pos+1]) ) {\n      unit_pos = parsed.find_first_not_of(\"-+0123456789.\", ++ unit_pos);\n    }\n    if (unit_pos == std::string::npos) unit_pos = L;\n    const std::string& num = parsed.substr(num_pos, unit_pos - num_pos);\n    Number* nr = SASS_MEMORY_NEW(Number,\n                                    pstate,\n                                    sass_strtod(num.c_str()),\n                                    Token(number(parsed.c_str())),\n                                    number_has_zero(parsed));\n    nr->is_interpolant(false);\n    nr->is_delayed(true);\n    return nr;\n  }", "target": 0}
{"code": "GF_EXPORT\nu8 gf_isom_get_pl_indication(GF_ISOFile *movie, GF_ISOProfileLevelType PL_Code)\n{\n\tGF_IsomInitialObjectDescriptor *iod;\n\tif (!movie || !movie->moov) return 0xFF;\n\tif (!movie->moov->iods || !movie->moov->iods->descriptor) return 0xFF;\n\tif (movie->moov->iods->descriptor->tag != GF_ODF_ISOM_IOD_TAG) return 0xFF;\n\tiod = (GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor;\n\tswitch (PL_Code) {\n\tcase GF_ISOM_PL_AUDIO:\n\t\treturn iod->audio_profileAndLevel;\n\tcase GF_ISOM_PL_VISUAL:\n\t\treturn iod->visual_profileAndLevel;\n\tcase GF_ISOM_PL_GRAPHICS:\n\t\treturn iod->graphics_profileAndLevel;\n\tcase GF_ISOM_PL_SCENE:\n\t\treturn iod->scene_profileAndLevel;\n\tcase GF_ISOM_PL_OD:\n\t\treturn iod->OD_profileAndLevel;\n\tcase GF_ISOM_PL_INLINE:\n\t\treturn iod->inlineProfileFlag;\n\tcase GF_ISOM_PL_MPEGJ:\n\tdefault:\n\t\treturn 0xFF;\n\t}", "target": 0}
{"code": "void sqlite3Fts3DoclistNext(\n  int bDescIdx,                   \n  char *aDoclist,                 \n  int nDoclist,                   \n  char **ppIter,                  \n  sqlite3_int64 *piDocid,         \n  u8 *pbEof                       \n){\n  char *p = *ppIter;\n  assert( nDoclist>0 );\n  assert( *pbEof==0 );\n  assert( p || *piDocid==0 );\n  assert( !p || (p>=aDoclist && p<=&aDoclist[nDoclist]) );\n  if( p==0 ){\n    p = aDoclist;\n    p += sqlite3Fts3GetVarint(p, piDocid);\n  }else{\n    fts3PoslistCopy(0, &p);\n    if( p>=&aDoclist[nDoclist] ){\n      *pbEof = 1;\n    }else{\n      sqlite3_int64 iVar;\n      p += sqlite3Fts3GetVarint(p, &iVar);\n      *piDocid += ((bDescIdx ? -1 : 1) * iVar);\n    }\n  }\n  *ppIter = p;\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::DidAllocateSharedBitmap(\n    mojo::ScopedSharedBufferHandle buffer,\n    const viz::SharedBitmapId& id) {\n  if (!viz::ServerSharedBitmapManager::current()->ChildAllocatedSharedBitmap(\n          std::move(buffer), id)) {\n    bad_message::ReceivedBadMessage(GetProcess(),\n                                    bad_message::RWH_SHARED_BITMAP);\n  }\n  owned_bitmaps_.insert(id);\n}", "target": 0}
{"code": "struct sock *unix_peer_get(struct sock *s)\n{\n\tstruct sock *peer;\n\tunix_state_lock(s);\n\tpeer = unix_peer(s);\n\tif (peer)\n\t\tsock_hold(peer);\n\tunix_state_unlock(s);\n\treturn peer;\n}", "target": 0}
{"code": "attr_show_all (struct vty *vty)\n{\n  hash_iterate (attrhash, \n\t\t(void (*)(struct hash_backet *, void *))\n\t\tattr_show_all_iterator,\n\t\tvty);\n}", "target": 0}
{"code": "fz_drop_default_colorspaces(fz_context *ctx, fz_default_colorspaces *default_cs)\n{\n\tif (fz_drop_imp(ctx, default_cs, &default_cs->refs))\n\t{\n\t\tfz_drop_colorspace(ctx, default_cs->gray);\n\t\tfz_drop_colorspace(ctx, default_cs->rgb);\n\t\tfz_drop_colorspace(ctx, default_cs->cmyk);\n\t\tfz_drop_colorspace(ctx, default_cs->oi);\n\t\tfz_free(ctx, default_cs);\n\t}\n}", "target": 0}
{"code": "static int kvm_vcpu_ioctl_x86_set_mce(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_x86_mce *mce)\n{\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\tu64 *banks = vcpu->arch.mce_banks;\n\tif (mce->bank >= bank_num || !(mce->status & MCI_STATUS_VAL))\n\t\treturn -EINVAL;\n\tif ((mce->status & MCI_STATUS_UC) && (mcg_cap & MCG_CTL_P) &&\n\t    vcpu->arch.mcg_ctl != ~(u64)0)\n\t\treturn 0;\n\tbanks += 4 * mce->bank;\n\tif ((mce->status & MCI_STATUS_UC) && banks[0] != ~(u64)0)\n\t\treturn 0;\n\tif (mce->status & MCI_STATUS_UC) {\n\t\tif ((vcpu->arch.mcg_status & MCG_STATUS_MCIP) ||\n\t\t    !kvm_read_cr4_bits(vcpu, X86_CR4_MCE)) {\n\t\t\tprintk(KERN_DEBUG \"kvm: set_mce: \"\n\t\t\t       \"injects mce exception while \"\n\t\t\t       \"previous one is in progress!\\n\");\n\t\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\t\treturn 0;\n\t\t}\n\t\tif (banks[1] & MCI_STATUS_VAL)\n\t\t\tmce->status |= MCI_STATUS_OVER;\n\t\tbanks[2] = mce->addr;\n\t\tbanks[3] = mce->misc;\n\t\tvcpu->arch.mcg_status = mce->mcg_status;\n\t\tbanks[1] = mce->status;\n\t\tkvm_queue_exception(vcpu, MC_VECTOR);\n\t} else if (!(banks[1] & MCI_STATUS_VAL)\n\t\t   || !(banks[1] & MCI_STATUS_UC)) {\n\t\tif (banks[1] & MCI_STATUS_VAL)\n\t\t\tmce->status |= MCI_STATUS_OVER;\n\t\tbanks[2] = mce->addr;\n\t\tbanks[3] = mce->misc;\n\t\tbanks[1] = mce->status;\n\t} else\n\t\tbanks[1] |= MCI_STATUS_OVER;\n\treturn 0;\n}", "target": 0}
{"code": "static void fuse_lib_release(fuse_req_t req, fuse_ino_t ino,\n                             struct fuse_file_info *fi)\n{\n    struct fuse *f = req_fuse_prepare(req);\n    struct fuse_intr_data d;\n    char *path;\n    int err = 0;\n    pthread_rwlock_rdlock(&f->tree_lock);\n    path = get_path(f, ino);\n    if (f->conf.debug)\n        fprintf(stderr, \"RELEASE%s[%llu] flags: 0x%x\\n\",\n                fi->flush ? \"+FLUSH\" : \"\",\n                (unsigned long long) fi->fh, fi->flags);\n    if (fi->flush) {\n        err = fuse_flush_common(f, req, ino, path, fi);\n        if (err == -ENOSYS)\n            err = 0;\n    }\n    fuse_prepare_interrupt(f, req, &d);\n    fuse_do_release(f, ino, path, fi);\n    fuse_finish_interrupt(f, req, &d);\n    free(path);\n    pthread_rwlock_unlock(&f->tree_lock);\n    reply_err(req, err);\n}", "target": 0}
{"code": "int ff_h264_decode_extradata(H264Context *h, const uint8_t *buf, int size)\n{\n    AVCodecContext *avctx = h->avctx;\n    int ret;\n    if (!buf || size <= 0)\n        return -1;\n    if (buf[0] == 1) {\n        int i, cnt, nalsize;\n        const unsigned char *p = buf;\n        h->is_avc = 1;\n        if (size < 7) {\n            av_log(avctx, AV_LOG_ERROR,\n                   \"avcC %d too short\\n\", size);\n            return AVERROR_INVALIDDATA;\n        }\n        h->nal_length_size = 2;\n        cnt = *(p + 5) & 0x1f; \n        p  += 6;\n        for (i = 0; i < cnt; i++) {\n            nalsize = AV_RB16(p) + 2;\n            if(nalsize > size - (p-buf))\n                return AVERROR_INVALIDDATA;\n            ret = decode_nal_units(h, p, nalsize, 1);\n            if (ret < 0) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Decoding sps %d from avcC failed\\n\", i);\n                return ret;\n            }\n            p += nalsize;\n        }\n        cnt = *(p++); \n        for (i = 0; i < cnt; i++) {\n            nalsize = AV_RB16(p) + 2;\n            if(nalsize > size - (p-buf))\n                return AVERROR_INVALIDDATA;\n            ret = decode_nal_units(h, p, nalsize, 1);\n            if (ret < 0) {\n                av_log(avctx, AV_LOG_ERROR,\n                       \"Decoding pps %d from avcC failed\\n\", i);\n                return ret;\n            }\n            p += nalsize;\n        }\n        h->nal_length_size = (buf[4] & 0x03) + 1;\n    } else {\n        h->is_avc = 0;\n        ret = decode_nal_units(h, buf, size, 1);\n        if (ret < 0)\n            return ret;\n    }\n    return size;\n}", "target": 0}
{"code": "InlineBoxPosition AdjustInlineBoxPositionForTextDirection(\n    InlineBox* inline_box,\n    int caret_offset,\n    UnicodeBidi unicode_bidi,\n    TextDirection primary_direction) {\n  if (inline_box->Direction() == primary_direction)\n    return AdjustInlineBoxPositionForPrimaryDirection(inline_box, caret_offset);\n  const unsigned char level = inline_box->BidiLevel();\n  if (caret_offset == inline_box->CaretLeftmostOffset()) {\n    InlineBox* const prev_box = inline_box->PrevLeafChildIgnoringLineBreak();\n    if (!prev_box || prev_box->BidiLevel() < level) {\n      InlineBox* const result_box =\n          InlineBoxTraversal::FindRightBoundaryOfEntireBidiRunIgnoringLineBreak(\n              *inline_box, level);\n      return InlineBoxPosition(result_box, result_box->CaretRightmostOffset());\n    }\n    if (prev_box->BidiLevel() <= level)\n      return InlineBoxPosition(inline_box, caret_offset);\n    InlineBox* const result_box =\n        InlineBoxTraversal::FindLeftBoundaryOfBidiRunIgnoringLineBreak(\n            *inline_box, level);\n    return InlineBoxPosition(result_box, result_box->CaretLeftmostOffset());\n  }\n  if (unicode_bidi == UnicodeBidi::kPlaintext) {\n    if (inline_box->BidiLevel() < level)\n      return InlineBoxPosition(inline_box, inline_box->CaretLeftmostOffset());\n    return InlineBoxPosition(inline_box, inline_box->CaretRightmostOffset());\n  }\n  InlineBox* const next_box = inline_box->NextLeafChildIgnoringLineBreak();\n  if (!next_box || next_box->BidiLevel() < level) {\n    InlineBox* const result_box =\n        InlineBoxTraversal::FindLeftBoundaryOfEntireBidiRunIgnoringLineBreak(\n            *inline_box, level);\n    return InlineBoxPosition(result_box, result_box->CaretLeftmostOffset());\n  }\n  if (next_box->BidiLevel() <= level)\n    return InlineBoxPosition(inline_box, caret_offset);\n  InlineBox* const result_box =\n      InlineBoxTraversal::FindRightBoundaryOfBidiRunIgnoringLineBreak(\n          *inline_box, level);\n  return InlineBoxPosition(result_box, result_box->CaretRightmostOffset());\n}", "target": 0}
{"code": "COMPAT_SYSCALL_DEFINE4(preadv64, unsigned long, fd,\n\t\tconst struct compat_iovec __user *,vec,\n\t\tunsigned long, vlen, loff_t, pos)\n{\n\treturn __compat_sys_preadv64(fd, vec, vlen, pos);\n}", "target": 0}
{"code": "static void curlfile_get_property(char *name, INTERNAL_FUNCTION_PARAMETERS)\n{\n\tzval *res;\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tres = zend_read_property(curl_CURLFile_class, getThis(), name, strlen(name), 1 TSRMLS_CC);\n\t*return_value = *res;\n\tzval_copy_ctor(return_value);\n\tINIT_PZVAL(return_value);\n}", "target": 0}
{"code": "static int nfs4_xdr_dec_write(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t      struct nfs_writeres *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_write(xdr, res);\n\tif (status)\n\t\tgoto out;\n\tif (res->fattr)\n\t\tdecode_getfattr(xdr, res->fattr, res->server);\n\tif (!status)\n\t\tstatus = res->count;\nout:\n\treturn status;\n}", "target": 0}
{"code": "static bool guest_cpuid_has_xsave(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\tbest = kvm_find_cpuid_entry(vcpu, 1, 0);\n\treturn best && (best->ecx & bit(X86_FEATURE_XSAVE));\n}", "target": 0}
{"code": "int64 GetInitialTemporaryStorageQuotaSize(const FilePath& path,\n                                          bool is_incognito) {\n  int64 free_space = base::SysInfo::AmountOfFreeDiskSpace(path);\n  UMA_HISTOGRAM_MBYTES(\"Quota.FreeDiskSpaceForProfile\", free_space);\n  if (free_space < QuotaManager::kTemporaryStorageQuotaDefaultSize * 2)\n    return 0;\n  if (is_incognito)\n    return QuotaManager::kIncognitoDefaultTemporaryQuota;\n  if (free_space < QuotaManager::kTemporaryStorageQuotaDefaultSize * 20)\n    return QuotaManager::kTemporaryStorageQuotaDefaultSize;\n  if (free_space < QuotaManager::kTemporaryStorageQuotaMaxSize * 20)\n    return free_space / 20;\n  return QuotaManager::kTemporaryStorageQuotaMaxSize;\n}", "target": 0}
{"code": "static void fuse_lib_open(fuse_req_t req, fuse_ino_t ino,\n                          struct fuse_file_info *fi)\n{\n    struct fuse *f = req_fuse_prepare(req);\n    struct fuse_intr_data d;\n    char *path = NULL;\n    int err = 0;\n    err = -ENOENT;\n    pthread_rwlock_rdlock(&f->tree_lock);\n    path = get_path(f, ino);\n    if (path) {\n        fuse_prepare_interrupt(f, req, &d);\n        err = fuse_fs_open(f->fs, path, fi);\n        if (!err) {\n            if (f->conf.direct_io)\n                fi->direct_io = 1;\n            if (f->conf.kernel_cache)\n                fi->keep_cache = 1;\n#ifdef __SOLARIS__\n            if (f->conf.auto_cache)\n                open_auto_cache(f, ino, path, fi);\n#endif \n        }\n        fuse_finish_interrupt(f, req, &d);\n    }\n    if (!err) {\n        pthread_mutex_lock(&f->lock);\n        get_node(f, ino)->open_count++;\n        pthread_mutex_unlock(&f->lock);\n        if (fuse_reply_open(req, fi) == -ENOENT) {\n            fuse_prepare_interrupt(f, req, &d);\n            fuse_do_release(f, ino, path, fi);\n            fuse_finish_interrupt(f, req, &d);\n        } else if (f->conf.debug) {\n            fprintf(stderr, \"OPEN[%llu] flags: 0x%x %s\\n\",\n                    (unsigned long long) fi->fh, fi->flags, path);\n        }\n    } else\n        reply_err(req, err);\n    if (path)\n        free(path);\n    pthread_rwlock_unlock(&f->tree_lock);\n}", "target": 0}
{"code": "form_auth_data_free (EphyEmbedSingleFormAuthData *data)\n{\n  g_free (data->form_username);\n  g_free (data->form_password);\n  g_free (data->username);\n  g_slice_free (EphyEmbedSingleFormAuthData, data);\n}", "target": 0}
{"code": "unsigned long nsecs_to_jiffies(u64 n)\n{\n\treturn (unsigned long)nsecs_to_jiffies64(n);\n}", "target": 0}
{"code": "static int add_seccomp_syscall_filter(scmp_filter_ctx seccomp,\n                                      uint32_t arch,\n                                      int nr,\n                                      unsigned int arg_cnt,\n                                      const struct scmp_arg_cmp arg) {\n        int r;\n        r = seccomp_rule_add_exact(seccomp, SCMP_ACT_ERRNO(EPERM), nr, arg_cnt, arg);\n        if (r < 0) {\n                _cleanup_free_ char *n = NULL;\n                n = seccomp_syscall_resolve_num_arch(arch, nr);\n                log_debug_errno(r, \"Failed to add %s() rule for architecture %s, skipping: %m\",\n                                strna(n),\n                                seccomp_arch_to_string(arch));\n        }\n        return r;\n}", "target": 0}
{"code": "static int handle_monitor_trap(struct kvm_vcpu *vcpu)\n{\n\treturn 1;\n}", "target": 0}
{"code": "xmlNewDocElementContent(xmlDocPtr doc, const xmlChar *name,\n                        xmlElementContentType type) {\n    xmlElementContentPtr ret;\n    xmlDictPtr dict = NULL;\n    if (doc != NULL)\n        dict = doc->dict;\n    switch(type) {\n\tcase XML_ELEMENT_CONTENT_ELEMENT:\n\t    if (name == NULL) {\n\t        xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t\t\"xmlNewElementContent : name == NULL !\\n\",\n\t\t\tNULL);\n\t    }\n\t    break;\n        case XML_ELEMENT_CONTENT_PCDATA:\n\tcase XML_ELEMENT_CONTENT_SEQ:\n\tcase XML_ELEMENT_CONTENT_OR:\n\t    if (name != NULL) {\n\t        xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t\t\"xmlNewElementContent : name != NULL !\\n\",\n\t\t\tNULL);\n\t    }\n\t    break;\n\tdefault:\n\t    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t    \"Internal: ELEMENT content corrupted invalid type\\n\",\n\t\t    NULL);\n\t    return(NULL);\n    }\n    ret = (xmlElementContentPtr) xmlMalloc(sizeof(xmlElementContent));\n    if (ret == NULL) {\n\txmlVErrMemory(NULL, \"malloc failed\");\n\treturn(NULL);\n    }\n    memset(ret, 0, sizeof(xmlElementContent));\n    ret->type = type;\n    ret->ocur = XML_ELEMENT_CONTENT_ONCE;\n    if (name != NULL) {\n        int l;\n\tconst xmlChar *tmp;\n\ttmp = xmlSplitQName3(name, &l);\n\tif (tmp == NULL) {\n\t    if (dict == NULL)\n\t\tret->name = xmlStrdup(name);\n\t    else\n\t        ret->name = xmlDictLookup(dict, name, -1);\n\t} else {\n\t    if (dict == NULL) {\n\t\tret->prefix = xmlStrndup(name, l);\n\t\tret->name = xmlStrdup(tmp);\n\t    } else {\n\t        ret->prefix = xmlDictLookup(dict, name, l);\n\t\tret->name = xmlDictLookup(dict, tmp, -1);\n\t    }\n\t}\n    }\n    return(ret);\n}", "target": 0}
{"code": "transport_pass_socket(const uschar *transport_name, const uschar *hostname,\n  const uschar *hostaddress, uschar *id, int socket_fd)\n{\npid_t pid;\nint status;\nDEBUG(D_transport) debug_printf(\"transport_pass_socket entered\\n\");\nif ((pid = fork()) == 0)\n  {\n  if ((pid = fork()) != 0)\n    {\n    DEBUG(D_transport) debug_printf(\"transport_pass_socket succeeded (final-pid %d)\\n\", pid);\n    _exit(EXIT_SUCCESS);\n    }\n  if (f.running_in_test_harness) sleep(1);\n  transport_do_pass_socket(transport_name, hostname, hostaddress,\n    id, socket_fd);\n  }\nif (pid > 0)\n  {\n  int rc;\n  while ((rc = wait(&status)) != pid && (rc >= 0 || errno != ECHILD));\n  DEBUG(D_transport) debug_printf(\"transport_pass_socket succeeded (inter-pid %d)\\n\", pid);\n  return TRUE;\n  }\nelse\n  {\n  DEBUG(D_transport) debug_printf(\"transport_pass_socket failed to fork: %s\\n\",\n    strerror(errno));\n  return FALSE;\n  }\n}", "target": 0}
{"code": "int r_jwe_set_iv(jwe_t * jwe, const unsigned char * iv, size_t iv_len) {\n  int ret;\n  unsigned char * iv_b64 = NULL;\n  size_t iv_b64_len = 0;\n  if (jwe != NULL) {\n    o_free(jwe->iv);\n    if (iv != NULL && iv_len) {\n      if ((jwe->iv = o_malloc(iv_len)) != NULL) {\n        memcpy(jwe->iv, iv, iv_len);\n        jwe->iv_len = iv_len;\n        if ((iv_b64 = o_malloc(jwe->iv_len*2)) != NULL) {\n          if (o_base64url_encode(jwe->iv, jwe->iv_len, iv_b64, &iv_b64_len)) {\n            o_free(jwe->iv_b64url);\n            jwe->iv_b64url = (unsigned char *)o_strndup((const char *)iv_b64, iv_b64_len);\n            ret = RHN_OK;\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_set_iv - Error o_base64url_encode iv_b64\");\n            ret = RHN_ERROR;\n          }\n          o_free(iv_b64);\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_set_iv - Error allocating resources for iv_b64\");\n          ret = RHN_ERROR_MEMORY;\n        }\n        ret = RHN_OK;\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"r_jwe_set_iv - Error allocating resources for iv\");\n        ret = RHN_ERROR_MEMORY;\n      }\n    } else {\n      jwe->iv = NULL;\n      jwe->iv_len = 0;\n      ret = RHN_OK;\n    }\n  } else {\n    ret = RHN_ERROR_PARAM;\n  }\n  return ret;\n}", "target": 0}
{"code": "ephy_string_commandline_args_to_uris (char   **arguments,\n                                      GError **error)\n{\n  gchar **args;\n  GFile *file;\n  guint i;\n  if (arguments == NULL)\n    return NULL;\n  args = g_malloc0 (sizeof (gchar *) * (g_strv_length (arguments) + 1));\n  for (i = 0; arguments[i] != NULL; ++i) {\n    file = g_file_new_for_commandline_arg (arguments [i]);\n    if (g_file_is_native (file) && g_file_query_exists (file, NULL)) {\n      args[i] = g_file_get_uri (file);\n    } else {\n      args[i] = g_locale_to_utf8 (arguments [i], -1,\n                                  NULL, NULL, error);\n      if (error && *error) {\n        g_strfreev (args);\n        return NULL;\n      }\n    }\n    g_object_unref (file);\n  }\n  return args;\n}", "target": 0}
{"code": "static bool wcd9335_is_volatile_register(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase WCD9335_INTR_PIN1_STATUS0...WCD9335_INTR_PIN2_CLEAR3:\n\tcase WCD9335_ANA_MBHC_RESULT_3:\n\tcase WCD9335_ANA_MBHC_RESULT_2:\n\tcase WCD9335_ANA_MBHC_RESULT_1:\n\tcase WCD9335_ANA_MBHC_MECH:\n\tcase WCD9335_ANA_MBHC_ELECT:\n\tcase WCD9335_ANA_MBHC_ZDET:\n\tcase WCD9335_ANA_MICB2:\n\tcase WCD9335_ANA_RCO:\n\tcase WCD9335_ANA_BIAS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}", "target": 0}
{"code": "Variant HHVM_FUNCTION(reset,\n                      VRefParam refParam) {\n  return iter_op_impl(\n    refParam,\n    &ArrayData::reset,\n    s___reset,\n    false,\n    &ArrayData::isHead\n  );\n}", "target": 0}
{"code": "int RemoveSectionType(int SectionType)\n{\n    int a;\n    int retval = FALSE;\n    for (a=0;a<SectionsRead-1;a++){\n        if (Sections[a].Type == SectionType){\n            free (Sections[a].Data);\n            memmove(Sections+a, Sections+a+1, sizeof(Section_t) * (SectionsRead-a-1));\n            SectionsRead -= 1;\n            a -= 1;\n            retval = TRUE;\n        }\n    }\n    return retval;\n}", "target": 0}
{"code": "static void virtio_net_tx_bh(void *opaque)\n{\n    VirtIONetQueue *q = opaque;\n    VirtIONet *n = q->n;\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n    int32_t ret;\n    if (!vdev->vm_running) {\n        assert(q->tx_waiting);\n        return;\n    }\n    q->tx_waiting = 0;\n    if (unlikely(!(vdev->status & VIRTIO_CONFIG_S_DRIVER_OK))) {\n        return;\n    }\n    ret = virtio_net_flush_tx(q);\n    if (ret == -EBUSY || ret == -EINVAL) {\n        return; \n    }\n    if (ret >= n->tx_burst) {\n        qemu_bh_schedule(q->tx_bh);\n        q->tx_waiting = 1;\n        return;\n    }\n    virtio_queue_set_notification(q->tx_vq, 1);\n    ret = virtio_net_flush_tx(q);\n    if (ret == -EINVAL) {\n        return;\n    } else if (ret > 0) {\n        virtio_queue_set_notification(q->tx_vq, 0);\n        qemu_bh_schedule(q->tx_bh);\n        q->tx_waiting = 1;\n    }\n}", "target": 0}
{"code": "int _san_othername_to_virtual(const char *oid, size_t size)\n{\n\tif (oid) {\n\t\tif ((unsigned) size == (sizeof(XMPP_OID)-1)\n\t\t    && memcmp(oid, XMPP_OID, sizeof(XMPP_OID)-1) == 0)\n\t\t\treturn GNUTLS_SAN_OTHERNAME_XMPP;\n\t}\n\treturn GNUTLS_SAN_OTHERNAME;\n} ", "target": 0}
{"code": "static int failover_set_primary(DeviceState *dev, void *opaque)\n{\n    FailoverDevice *fdev = opaque;\n    PCIDevice *pci_dev = (PCIDevice *)\n        object_dynamic_cast(OBJECT(dev), TYPE_PCI_DEVICE);\n    if (!pci_dev) {\n        return 0;\n    }\n    if (!g_strcmp0(pci_dev->failover_pair_id, fdev->n->netclient_name)) {\n        fdev->dev = dev;\n        return 1;\n    }\n    return 0;\n}", "target": 0}
{"code": "void ntfs_attr_init(ntfs_attr *na, const BOOL non_resident,\n\t\tconst ATTR_FLAGS data_flags,\n\t\tconst BOOL encrypted, const BOOL sparse,\n\t\tconst s64 allocated_size, const s64 data_size,\n\t\tconst s64 initialized_size, const s64 compressed_size,\n\t\tconst u8 compression_unit)\n{\n\tif (!NAttrInitialized(na)) {\n\t\tna->data_flags = data_flags;\n\t\tif (non_resident)\n\t\t\tNAttrSetNonResident(na);\n\t\tif (data_flags & ATTR_COMPRESSION_MASK)\n\t\t\tNAttrSetCompressed(na);\n\t\tif (encrypted)\n\t\t\tNAttrSetEncrypted(na);\n\t\tif (sparse)\n\t\t\tNAttrSetSparse(na);\n\t\tna->allocated_size = allocated_size;\n\t\tna->data_size = data_size;\n\t\tna->initialized_size = initialized_size;\n\t\tif ((data_flags & ATTR_COMPRESSION_MASK) || sparse) {\n\t\t\tntfs_volume *vol = na->ni->vol;\n\t\t\tna->compressed_size = compressed_size;\n\t\t\tna->compression_block_clusters = 1 << compression_unit;\n\t\t\tna->compression_block_size = 1 << (compression_unit +\n\t\t\t\t\tvol->cluster_size_bits);\n\t\t\tna->compression_block_size_bits = ffs(\n\t\t\t\t\tna->compression_block_size) - 1;\n\t\t}\n\t\tNAttrSetInitialized(na);\n\t}\n}", "target": 0}
{"code": "bool EditorClientBlackBerry::canRedo() const\n{\n    return !m_redoStack.isEmpty();\n}", "target": 0}
{"code": " void HTMLFormControlElement::setAutofilled(bool autofilled)\n {\n     if (autofilled == m_isAutofilled)\n        return;\n    m_isAutofilled = autofilled;\n    setNeedsStyleRecalc();\n}", "target": 0}
{"code": "TEST_F(HeaderToMetadataTest, HeaderRemovedTest) {\n  const std::string response_config_yaml = R\"EOF(\nresponse_rules:\n  - header: x-authenticated\n    on_header_present:\n      key: auth\n      type: STRING\n    remove: true\n)EOF\";\n  initializeFilter(response_config_yaml);\n  Http::TestResponseHeaderMapImpl incoming_headers{{\"x-authenticated\", \"1\"}};\n  std::map<std::string, std::string> expected = {{\"auth\", \"1\"}};\n  Http::TestResponseHeaderMapImpl empty_headers;\n  EXPECT_CALL(encoder_callbacks_, streamInfo()).WillRepeatedly(ReturnRef(req_info_));\n  EXPECT_CALL(req_info_,\n              setDynamicMetadata(HttpFilterNames::get().HeaderToMetadata, MapEq(expected)));\n  Http::TestResponseHeaderMapImpl continue_response{{\":status\", \"100\"}};\n  EXPECT_EQ(Http::FilterHeadersStatus::Continue,\n            filter_->encode100ContinueHeaders(continue_response));\n  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->encodeHeaders(incoming_headers, false));\n  EXPECT_EQ(empty_headers, incoming_headers);\n  Http::MetadataMap metadata_map{{\"metadata\", \"metadata\"}};\n  EXPECT_EQ(Http::FilterMetadataStatus::Continue, filter_->encodeMetadata(metadata_map));\n  Buffer::OwnedImpl data(\"data\");\n  EXPECT_EQ(Http::FilterDataStatus::Continue, filter_->encodeData(data, false));\n  Http::TestResponseTrailerMapImpl incoming_trailers;\n  EXPECT_EQ(Http::FilterTrailersStatus::Continue, filter_->encodeTrailers(incoming_trailers));\n}", "target": 0}
{"code": "GF_Err traf_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_TrackFragmentBox *ptr = (GF_TrackFragmentBox *) s;\n\tgf_isom_check_position(s, (GF_Box *)ptr->tfhd, &pos);\n\tgf_isom_check_position_list(s, ptr->sub_samples, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->tfdt, &pos);\n\tgf_isom_check_position_list(s, ptr->sampleGroupsDescription, &pos);\n\tgf_isom_check_position_list(s, ptr->sampleGroups, &pos);\n\tgf_isom_check_position_list(s, ptr->sai_sizes, &pos);\n\tgf_isom_check_position_list(s, ptr->sai_offsets, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->sample_encryption, &pos);\n\tgf_isom_check_position_list(s, ptr->TrackRuns, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->sdtp, &pos);\n\tif (ptr->tfxd)\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->tfxd, &pos);\n\treturn GF_OK;\n}", "target": 0}
{"code": "unsigned long nr_iowait(void)\n{\n\tunsigned long i, sum = 0;\n\tfor_each_possible_cpu(i)\n\t\tsum += atomic_read(&cpu_rq(i)->nr_iowait);\n\treturn sum;\n}", "target": 0}
{"code": "bool HTMLMediaElement::ended() const {\n  return EndedPlayback() && GetDirectionOfPlayback() == kForward;\n}", "target": 0}
{"code": "uint8_t* sldns_wirerr_get_rdata(uint8_t* rr, size_t len, size_t dname_len)\n{\n\tif(len < dname_len+10)\n\t\treturn NULL;\n\treturn rr+dname_len+10;\n}", "target": 0}
{"code": "xmlReadDoc(const xmlChar * cur, const char *URL, const char *encoding, int options)\n{\n    xmlParserCtxtPtr ctxt;\n    if (cur == NULL)\n        return (NULL);\n    xmlInitParser();\n    ctxt = xmlCreateDocParserCtxt(cur);\n    if (ctxt == NULL)\n        return (NULL);\n    return (xmlDoRead(ctxt, URL, encoding, options, 0));\n}", "target": 0}
{"code": "void ieee80211_rx_irqsafe(struct ieee80211_hw *hw, struct sk_buff *skb)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tBUILD_BUG_ON(sizeof(struct ieee80211_rx_status) > sizeof(skb->cb));\n\tskb->pkt_type = IEEE80211_RX_MSG;\n\tskb_queue_tail(&local->skb_queue, skb);\n\ttasklet_schedule(&local->tasklet);\n}", "target": 0}
{"code": "      void end() {\n        if (code_end.is_empty()) return;\n        if (imgin) {\n          mem[_cimg_mp_slot_x] = imgin._width - 1.0;\n          mem[_cimg_mp_slot_y] = imgin._height - 1.0f;\n          mem[_cimg_mp_slot_z] = imgin._depth - 1.0f;\n          mem[_cimg_mp_slot_c] = imgin._spectrum - 1.0f;\n        } else mem[_cimg_mp_slot_x] = mem[_cimg_mp_slot_y] = mem[_cimg_mp_slot_z] = mem[_cimg_mp_slot_c] = 0;\n        p_code_end = code_end.end();\n        for (p_code = code_end; p_code<p_code_end; ++p_code) {\n          opcode._data = p_code->_data;\n          const ulongT target = opcode[1];\n          mem[target] = _cimg_mp_defunc(*this);\n        }", "target": 0}
{"code": "    XMP_OptionBits xmpArrayOptionBits(Exiv2::XmpValue::XmpArrayType xat)\n    {\n        XMP_OptionBits var(0);\n        switch (xat) {\n        case Exiv2::XmpValue::xaNone:\n            break;\n        case Exiv2::XmpValue::xaAlt:\n            XMP_SetOption(var, kXMP_PropValueIsArray);\n            XMP_SetOption(var, kXMP_PropArrayIsAlternate);\n            break;\n        case Exiv2::XmpValue::xaSeq:\n            XMP_SetOption(var, kXMP_PropValueIsArray);\n            XMP_SetOption(var, kXMP_PropArrayIsOrdered);\n            break;\n        case Exiv2::XmpValue::xaBag:\n            XMP_SetOption(var, kXMP_PropValueIsArray);\n            break;\n        }\n        return var;\n    }", "target": 0}
{"code": "int ring_buffer_poll_wait(struct ring_buffer *buffer, int cpu,\n\t\t\t  struct file *filp, poll_table *poll_table)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tstruct rb_irq_work *work;\n\tif (cpu == RING_BUFFER_ALL_CPUS)\n\t\twork = &buffer->irq_work;\n\telse {\n\t\tif (!cpumask_test_cpu(cpu, buffer->cpumask))\n\t\t\treturn -EINVAL;\n\t\tcpu_buffer = buffer->buffers[cpu];\n\t\twork = &cpu_buffer->irq_work;\n\t}\n\tpoll_wait(filp, &work->waiters, poll_table);\n\twork->waiters_pending = true;\n\tsmp_mb();\n\tif ((cpu == RING_BUFFER_ALL_CPUS && !ring_buffer_empty(buffer)) ||\n\t    (cpu != RING_BUFFER_ALL_CPUS && !ring_buffer_empty_cpu(buffer, cpu)))\n\t\treturn POLLIN | POLLRDNORM;\n\treturn 0;\n}", "target": 0}
{"code": "pa2ycbcr(UINT8 *out, const UINT8 *in, int xsize, const UINT8 *palette) {\n    pa2rgb(out, in, xsize, palette);\n    ImagingConvertRGB2YCbCr(out, out, xsize);\n}", "target": 0}
{"code": "static ssize_t shrink_store(struct kmem_cache *s,\n\t\t\tconst char *buf, size_t length)\n{\n\tif (buf[0] == '1') {\n\t\tint rc = kmem_cache_shrink(s);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else\n\t\treturn -EINVAL;\n\treturn length;\n}", "target": 0}
{"code": "void PrintWebViewHelper::OnPrintForSystemDialog() {\n  WebFrame* frame = print_preview_context_.frame();\n  if (!frame) {\n    NOTREACHED();\n    return;\n  }\n  Print(frame, print_preview_context_.node());\n}", "target": 0}
{"code": "  string Name(int node_index, int output_index) const {\n    if (output_index == 0) {\n      return Name(node_index);\n    } else {\n      return strings::StrCat(Name(node_index), \":\", output_index);\n    }\n  }", "target": 0}
{"code": "void ff_mpeg4_pred_ac(MpegEncContext *s, int16_t *block, int n, int dir)\n{\n    int i;\n    int16_t *ac_val, *ac_val1;\n    int8_t *const qscale_table = s->current_picture.qscale_table;\n    ac_val  = s->ac_val[0][0] + s->block_index[n] * 16;\n    ac_val1 = ac_val;\n    if (s->ac_pred) {\n        if (dir == 0) {\n            const int xy = s->mb_x - 1 + s->mb_y * s->mb_stride;\n            ac_val -= 16;\n            if (s->mb_x == 0 || s->qscale == qscale_table[xy] ||\n                n == 1 || n == 3) {\n                for (i = 1; i < 8; i++)\n                    block[s->dsp.idct_permutation[i << 3]] += ac_val[i];\n            } else {\n                for (i = 1; i < 8; i++)\n                    block[s->dsp.idct_permutation[i << 3]] += ROUNDED_DIV(ac_val[i] * qscale_table[xy], s->qscale);\n            }\n        } else {\n            const int xy = s->mb_x + s->mb_y * s->mb_stride - s->mb_stride;\n            ac_val -= 16 * s->block_wrap[n];\n            if (s->mb_y == 0 || s->qscale == qscale_table[xy] ||\n                n == 2 || n == 3) {\n                for (i = 1; i < 8; i++)\n                    block[s->dsp.idct_permutation[i]] += ac_val[i + 8];\n            } else {\n                for (i = 1; i < 8; i++)\n                    block[s->dsp.idct_permutation[i]] += ROUNDED_DIV(ac_val[i + 8] * qscale_table[xy], s->qscale);\n            }\n        }\n    }\n    for (i = 1; i < 8; i++)\n        ac_val1[i] = block[s->dsp.idct_permutation[i << 3]];\n    for (i = 1; i < 8; i++)\n        ac_val1[8 + i] = block[s->dsp.idct_permutation[i]];\n}", "target": 0}
{"code": "void RootWindowHostWin::ToggleFullScreen() {\n  gfx::Rect target_rect;\n  if (!fullscreen_) {\n    fullscreen_ = true;\n    saved_window_style_ = GetWindowLong(hwnd(), GWL_STYLE);\n    saved_window_ex_style_ = GetWindowLong(hwnd(), GWL_EXSTYLE);\n    GetWindowRect(hwnd(), &saved_window_rect_);\n    SetWindowLong(hwnd(), GWL_STYLE,\n                  saved_window_style_ & ~(WS_CAPTION | WS_THICKFRAME));\n    SetWindowLong(hwnd(), GWL_EXSTYLE,\n                  saved_window_ex_style_ & ~(WS_EX_DLGMODALFRAME |\n                      WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE | WS_EX_STATICEDGE));\n    MONITORINFO mi;\n    mi.cbSize = sizeof(mi);\n    GetMonitorInfo(MonitorFromWindow(hwnd(), MONITOR_DEFAULTTONEAREST), &mi);\n    target_rect = mi.rcMonitor;\n  } else {\n    fullscreen_ = false;\n    SetWindowLong(hwnd(), GWL_STYLE, saved_window_style_);\n    SetWindowLong(hwnd(), GWL_EXSTYLE, saved_window_ex_style_);\n    target_rect = saved_window_rect_;\n  }\n  SetWindowPos(hwnd(),\n               NULL,\n               target_rect.x(),\n               target_rect.y(),\n               target_rect.width(),\n               target_rect.height(),\n               SWP_NOZORDER | SWP_NOACTIVATE | SWP_FRAMECHANGED);\n}", "target": 0}
{"code": "static void vmx_set_msr_bitmap(struct kvm_vcpu *vcpu)\n{\n\tunsigned long *msr_bitmap;\n\tif (irqchip_in_kernel(vcpu->kvm) && apic_x2apic_mode(vcpu->arch.apic)) {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode_x2apic;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy_x2apic;\n\t} else {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy;\n\t}\n\tvmcs_write64(MSR_BITMAP, __pa(msr_bitmap));\n}", "target": 0}
{"code": "RenderFrameHostImpl::~RenderFrameHostImpl() {\n  GetProcess()->RemoveRoute(routing_id_);\n  g_routing_id_frame_map.Get().erase(\n      RenderFrameHostID(GetProcess()->GetID(), routing_id_));\n  if (delegate_)\n    delegate_->RenderFrameDeleted(this);\n  frame_tree_->UnregisterRenderFrameHost(this);\n}", "target": 0}
{"code": "nft_rule_activate_next(struct net *net, struct nft_rule *rule)\n{\n\trule->genmask = (1 << net->nft.gencursor);\n}", "target": 0}
{"code": "destroyMasterParserList(void)\n{\n\tparserList_t *pParsLst;\n\tparserList_t *pParsLstDel;\n\tpParsLst = pParsLstRoot;\n\twhile(pParsLst != NULL) {\n\t\tparserDestruct(&pParsLst->pParser);\n\t\tpParsLstDel = pParsLst;\n\t\tpParsLst = pParsLst->pNext;\n\t\tfree(pParsLstDel);\n\t}\n}", "target": 0}
{"code": "void VideoRendererBase::Stop(const base::Closure& callback) {\n  if (state_ == kStopped) {\n    callback.Run();\n    return;\n  }\n  base::PlatformThreadHandle thread_to_join = base::kNullThreadHandle;\n  {\n    base::AutoLock auto_lock(lock_);\n    state_ = kStopped;\n    statistics_cb_.Reset();\n    time_cb_.Reset();\n    if (!pending_paint_ && !pending_paint_with_last_available_)\n      DoStopOrError_Locked();\n    if (thread_ != base::kNullThreadHandle) {\n      frame_available_.Signal();\n      thread_to_join = thread_;\n      thread_ = base::kNullThreadHandle;\n    }\n  }\n  if (thread_to_join != base::kNullThreadHandle)\n    base::PlatformThread::Join(thread_to_join);\n  decoder_->Stop(callback);\n}", "target": 0}
{"code": "SpeechSynthesis::SpeechSynthesis(ExecutionContext* context)\n    : ContextLifecycleObserver(context)\n    , m_platformSpeechSynthesizer(PlatformSpeechSynthesizer::create(this))\n    , m_isPaused(false)\n{\n    ScriptWrappable::init(this);\n}", "target": 0}
{"code": "xfs_iunlink_destroy(\n\tstruct xfs_perag\t*pag)\n{\n\tbool\t\t\tfreed_anything = false;\n\trhashtable_free_and_destroy(&pag->pagi_unlinked_hash,\n\t\t\txfs_iunlink_free_item, &freed_anything);\n\tASSERT(freed_anything == false || XFS_FORCED_SHUTDOWN(pag->pag_mount));\n}", "target": 0}
{"code": "static void skcipher_free_sgl(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tskcipher_pull_sgl(sk, ctx->used);\n}", "target": 0}
{"code": "__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, int preferred_nid,\n\t\t\t\t\t\t\tnodemask_t *nodemask)\n{\n\tstruct page *page;\n\tunsigned int alloc_flags = ALLOC_WMARK_LOW;\n\tgfp_t alloc_mask; \n\tstruct alloc_context ac = { };\n\tgfp_mask &= gfp_allowed_mask;\n\talloc_mask = gfp_mask;\n\tif (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &ac, &alloc_mask, &alloc_flags))\n\t\treturn NULL;\n\tfinalise_ac(gfp_mask, order, &ac);\n\tpage = get_page_from_freelist(alloc_mask, order, alloc_flags, &ac);\n\tif (likely(page))\n\t\tgoto out;\n\talloc_mask = current_gfp_context(gfp_mask);\n\tac.spread_dirty_pages = false;\n\tif (unlikely(ac.nodemask != nodemask))\n\t\tac.nodemask = nodemask;\n\tpage = __alloc_pages_slowpath(alloc_mask, order, &ac);\nout:\n\tif (memcg_kmem_enabled() && (gfp_mask & __GFP_ACCOUNT) && page &&\n\t    unlikely(memcg_kmem_charge(page, gfp_mask, order) != 0)) {\n\t\t__free_pages(page, order);\n\t\tpage = NULL;\n\t}\n\ttrace_mm_page_alloc(page, order, alloc_mask, ac.migratetype);\n\treturn page;\n}", "target": 0}
{"code": "void FrameLoader::detachChildren()\n{\n    typedef Vector<RefPtr<Frame> > FrameVector;\n    FrameVector childrenToDetach;\n    childrenToDetach.reserveCapacity(m_frame->tree()->childCount());\n    for (Frame* child = m_frame->tree()->lastChild(); child; child = child->tree()->previousSibling())\n        childrenToDetach.append(child);\n    FrameVector::iterator end = childrenToDetach.end();\n    for (FrameVector::iterator it = childrenToDetach.begin(); it != end; it++)\n        (*it)->loader()->detachFromParent();\n}", "target": 0}
{"code": "static void tcp_reset(struct sock *sk)\n{\n\tswitch (sk->sk_state) {\n\tcase TCP_SYN_SENT:\n\t\tsk->sk_err = ECONNREFUSED;\n\t\tbreak;\n\tcase TCP_CLOSE_WAIT:\n\t\tsk->sk_err = EPIPE;\n\t\tbreak;\n\tcase TCP_CLOSE:\n\t\treturn;\n\tdefault:\n\t\tsk->sk_err = ECONNRESET;\n\t}\n\tsmp_wmb();\n\tif (!sock_flag(sk, SOCK_DEAD))\n\t\tsk->sk_error_report(sk);\n\ttcp_done(sk);\n}", "target": 0}
{"code": "static void add_atomic_switch_msr_special(struct vcpu_vmx *vmx,\n\t\tunsigned long entry, unsigned long exit,\n\t\tunsigned long guest_val_vmcs, unsigned long host_val_vmcs,\n\t\tu64 guest_val, u64 host_val)\n{\n\tvmcs_write64(guest_val_vmcs, guest_val);\n\tvmcs_write64(host_val_vmcs, host_val);\n\tvm_entry_controls_setbit(vmx, entry);\n\tvm_exit_controls_setbit(vmx, exit);\n}", "target": 0}
{"code": "  Directive_Obj Parser::parse_special_directive()\n  {\n    std::string kwd(lexed);\n    if (lexed == \"@else\") error(\"Invalid CSS: @else must come after @if\");\n    Directive_Ptr at_rule = SASS_MEMORY_NEW(Directive, pstate, kwd);\n    Lookahead lookahead = lookahead_for_include(position);\n    if (lookahead.found && !lookahead.has_interpolants) {\n      at_rule->selector(parse_selector_list(false));\n    }\n    lex < css_comments >(false);\n    if (lex < static_property >()) {\n      at_rule->value(parse_interpolated_chunk(Token(lexed)));\n    } else if (!(peek < alternatives < exactly<'{'>, exactly<'}'>, exactly<';'> > >())) {\n      at_rule->value(parse_list());\n    }\n    lex < css_comments >(false);\n    if (peek< exactly<'{'> >()) {\n      at_rule->block(parse_block());\n    }\n    return at_rule;\n  }", "target": 0}
{"code": "DelayNode* BaseAudioContext::createDelay(ExceptionState& exception_state) {\n  DCHECK(IsMainThread());\n  return DelayNode::Create(*this, exception_state);\n}", "target": 0}
{"code": "    void averageOp(void *src1, void *src2, void *dst)\n    {\n        addWeighted(*(Mat *)src1, 0.5, *(Mat *)src2, 0.5, 0.0, *(Mat *)dst, CV_32F);\n    }", "target": 0}
{"code": "bool FrameLoader::shouldReload(const KURL& currentURL, const KURL& destinationURL)\n{\n#if ENABLE(WML)\n    if (frameContainsWMLContent(m_frame))\n        return true;\n#endif\n    if (!destinationURL.hasFragmentIdentifier())\n        return true;\n    return !equalIgnoringFragmentIdentifier(currentURL, destinationURL);\n}", "target": 0}
{"code": "Method* ciEnv::lookup_method(ciInstanceKlass* accessor,\n                             ciKlass*         holder,\n                             Symbol*          name,\n                             Symbol*          sig,\n                             Bytecodes::Code  bc,\n                             constantTag      tag) {\n  InstanceKlass* accessor_klass = accessor->get_instanceKlass();\n  Klass* holder_klass = holder->get_Klass();\n  assert(check_klass_accessibility(accessor, holder_klass), \"holder not accessible\");\n  LinkInfo link_info(holder_klass, name, sig, accessor_klass,\n                     LinkInfo::AccessCheck::required,\n                     LinkInfo::LoaderConstraintCheck::required,\n                     tag);\n  switch (bc) {\n    case Bytecodes::_invokestatic:\n      return LinkResolver::resolve_static_call_or_null(link_info);\n    case Bytecodes::_invokespecial:\n      return LinkResolver::resolve_special_call_or_null(link_info);\n    case Bytecodes::_invokeinterface:\n      return LinkResolver::linktime_resolve_interface_method_or_null(link_info);\n    case Bytecodes::_invokevirtual:\n      return LinkResolver::linktime_resolve_virtual_method_or_null(link_info);\n    default:\n      fatal(\"Unhandled bytecode: %s\", Bytecodes::name(bc));\n      return NULL; \n  }\n}", "target": 0}
{"code": "format_POP_MPLS(const struct ofpact_pop_mpls *a,\n                const struct ofpact_format_params *fp)\n{\n    ds_put_format(fp->s, \"%spop_mpls:%s0x%04\"PRIx16,\n                  colors.param, colors.end, ntohs(a->ethertype));\n}", "target": 0}
{"code": "static ssize_t mds_show_state(char *buf)\n{\n\tif (boot_cpu_has(X86_FEATURE_HYPERVISOR)) {\n\t\treturn sprintf(buf, \"%s; SMT Host state unknown\\n\",\n\t\t\t       mds_strings[mds_mitigation]);\n\t}\n\tif (boot_cpu_has(X86_BUG_MSBDS_ONLY)) {\n\t\treturn sprintf(buf, \"%s; SMT %s\\n\", mds_strings[mds_mitigation],\n\t\t\t       (mds_mitigation == MDS_MITIGATION_OFF ? \"vulnerable\" :\n\t\t\t        sched_smt_active() ? \"mitigated\" : \"disabled\"));\n\t}\n\treturn sprintf(buf, \"%s; SMT %s\\n\", mds_strings[mds_mitigation],\n\t\t       sched_smt_active() ? \"vulnerable\" : \"disabled\");\n}", "target": 0}
{"code": "gboolean\nmono_verifier_is_enabled_for_class (MonoClass *klass)\n{\n\treturn verify_all || (verifier_mode > MONO_VERIFIER_MODE_OFF && !klass->image->assembly->in_gac && klass->image != mono_defaults.corlib);", "target": 0}
{"code": "static void __dmar_remove_one_dev_info(struct device_domain_info *info)\n{\n\tstruct intel_iommu *iommu;\n\tunsigned long flags;\n\tassert_spin_locked(&device_domain_lock);\n\tif (WARN_ON(!info))\n\t\treturn;\n\tiommu = info->iommu;\n\tif (info->dev) {\n\t\tif (dev_is_pci(info->dev) && sm_supported(iommu))\n\t\t\tintel_pasid_tear_down_entry(iommu, info->dev,\n\t\t\t\t\tPASID_RID2PASID);\n\t\tiommu_disable_dev_iotlb(info);\n\t\tdomain_context_clear(iommu, info->dev);\n\t\tintel_pasid_free_table(info->dev);\n\t}\n\tunlink_domain_info(info);\n\tspin_lock_irqsave(&iommu->lock, flags);\n\tdomain_detach_iommu(info->domain, iommu);\n\tspin_unlock_irqrestore(&iommu->lock, flags);\n\tfree_devinfo_mem(info);\n}", "target": 0}
{"code": "static void floppy_end_request(struct request *req, int error)\n{\n\tunsigned int nr_sectors = current_count_sectors;\n\tunsigned int drive = (unsigned long)req->rq_disk->private_data;\n\tif (error)\n\t\tnr_sectors = blk_rq_cur_sectors(req);\n\tif (__blk_end_request(req, error, nr_sectors << 9))\n\t\treturn;\n\tfloppy_off(drive);\n\tcurrent_req = NULL;\n}", "target": 0}
{"code": "void red_stream_set_core_interface(RedStream *stream, SpiceCoreInterfaceInternal *core)\n{\n    red_stream_remove_watch(stream);\n    stream->priv->core = core;\n}", "target": 0}
{"code": "static void virtio_net_disable_rss(VirtIONet *n)\n{\n    if (n->rss_data.enabled) {\n        trace_virtio_net_rss_disable();\n    }\n    n->rss_data.enabled = false;\n    virtio_net_detach_epbf_rss(n);\n}", "target": 0}
{"code": "void InterstitialPage::DidNavigate(\n    RenderViewHost* render_view_host,\n    const ViewHostMsg_FrameNavigate_Params& params) {\n  if (!enabled_) {\n    DontProceed();\n    return;\n  }\n  render_view_host_->view()->Show();\n  tab_->set_interstitial_page(this);\n  RenderWidgetHostView* rwh_view = tab_->render_view_host()->view();\n  if (rwh_view) {\n    if (rwh_view->HasFocus())\n      Focus();\n    rwh_view->Hide();\n  }\n  tab_->SetIsLoading(false, NULL);\n}", "target": 0}
{"code": "bool Item_cache_row::null_inside()\n{\n  for (uint i= 0; i < item_count; i++)\n  {\n    if (values[i]->cols() > 1)\n    {\n      if (values[i]->null_inside())\n\treturn 1;\n    }\n    else\n    {\n      values[i]->update_null_value();\n      if (values[i]->null_value)\n\treturn 1;\n    }\n  }\n  return 0;\n}", "target": 0}
{"code": "unsigned lodepng_deflate(unsigned char** out, size_t* outsize,\n                         const unsigned char* in, size_t insize,\n                         const LodePNGCompressSettings* settings)\n{\n  unsigned error;\n  ucvector v;\n  ucvector_init_buffer(&v, *out, *outsize);\n  error = lodepng_deflatev(&v, in, insize, settings);\n  *out = v.data;\n  *outsize = v.size;\n  return error;\n}", "target": 0}
{"code": "void ClientUsageTracker::GatherHostUsageComplete(const std::string& host) {\n  DCHECK(host_usage_tasks_.find(host) != host_usage_tasks_.end());\n  host_usage_tasks_.erase(host);\n   host_usage_callbacks_.Run(host, host, type_, GetCachedHostUsage(host));\n }", "target": 0}
{"code": "static int ndpi_search_tls_udp(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\t       struct ndpi_flow_struct *flow) {\n  struct ndpi_packet_struct *packet = &flow->packet;\n  u_int32_t handshake_len;\n  u_int16_t p_len;\n  const u_int8_t *p;\n#ifdef DEBUG_TLS\n  printf(\"[TLS] %s()\\n\", __FUNCTION__);\n#endif\n  if((packet->payload_packet_len < 17)\n     || (packet->payload[0]  != 0x16)\n     || (packet->payload[1]  != 0xfe) \n     || ((packet->payload[2] != 0xff) && (packet->payload[2] != 0xfd))\n     || ((ntohs(*((u_int16_t*)&packet->payload[11]))+13) != packet->payload_packet_len)\n    ) {\n  no_dtls:\n#ifdef DEBUG_TLS\n    printf(\"[TLS] No DTLS found\\n\");\n#endif\n    NDPI_EXCLUDE_PROTO(ndpi_struct, flow);\n    return(0); \n  }\n  handshake_len  = (packet->payload[14] << 16) + (packet->payload[15] << 8) + packet->payload[16];\n  if((handshake_len+25) != packet->payload_packet_len)\n    goto no_dtls;\n  p = packet->payload, p_len = packet->payload_packet_len; \n  packet->payload = &packet->payload[13], packet->payload_packet_len -= 13;\n  processTLSBlock(ndpi_struct, flow);\n  packet->payload = p, packet->payload_packet_len = p_len; \n  ndpi_int_tls_add_connection(ndpi_struct, flow, NDPI_PROTOCOL_TLS);\n  return(1); \n}", "target": 0}
{"code": "static void vnc_tight_cleanup(Notifier *n, void *value)\n{\n    g_free(color_count_palette);\n    color_count_palette = NULL;\n}", "target": 0}
{"code": "TEST(FloatPoolingOpTest, AveragePoolPaddingSameStride1) {\n  FloatPoolingOpModel m(BuiltinOperator_AVERAGE_POOL_2D,\n                        {TensorType_FLOAT32, {1, 2, 4, 1}},\n                        2, 2,\n                        {TensorType_FLOAT32, {}}, Padding_SAME, 1,\n                        1);\n  m.SetInput({\n      0, 6, 2, 4,   \n      3, 2, 10, 7,  \n  });\n  m.Invoke();\n  EXPECT_THAT(m.GetOutput(),\n              ElementsAreArray({2.75, 5.0, 5.75, 5.5, 2.5, 6.0, 8.5, 7.0}));\n}", "target": 0}
{"code": "static int rfcomm_sock_setsockopt(struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct bt_security sec;\n\tint err = 0;\n\tsize_t len;\n\tu32 opt;\n\tBT_DBG(\"sk %p\", sk);\n\tif (level == SOL_RFCOMM)\n\t\treturn rfcomm_sock_setsockopt_old(sock, optname, optval, optlen);\n\tif (level != SOL_BLUETOOTH)\n\t\treturn -ENOPROTOOPT;\n\tlock_sock(sk);\n\tswitch (optname) {\n\tcase BT_SECURITY:\n\t\tif (sk->sk_type != SOCK_STREAM) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tsec.level = BT_SECURITY_LOW;\n\t\tlen = min_t(unsigned int, sizeof(sec), optlen);\n\t\tif (copy_from_user((char *) &sec, optval, len)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (sec.level > BT_SECURITY_HIGH) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\trfcomm_pi(sk)->sec_level = sec.level;\n\t\tbreak;\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (get_user(opt, (u32 __user *) optval)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (opt)\n\t\t\tset_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n\t\telse\n\t\t\tclear_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "void PrintWebViewHelper::OnPrintForPrintPreview(\n    const DictionaryValue& job_settings) {\n  DCHECK(is_preview_enabled_);\n  if (print_web_view_)\n    return;\n  if (!render_view()->GetWebView())\n    return;\n  WebFrame* main_frame = render_view()->GetWebView()->mainFrame();\n  if (!main_frame)\n    return;\n  WebDocument document = main_frame->document();\n  WebElement pdf_element = document.getElementById(\"pdf-viewer\");\n  if (pdf_element.isNull()) {\n    NOTREACHED();\n    return;\n  }\n  WebFrame* pdf_frame = pdf_element.document().frame();\n  if (!UpdatePrintSettings(pdf_frame, pdf_element, job_settings, true)) {\n    LOG(ERROR) << \"UpdatePrintSettings failed\";\n    DidFinishPrinting(FAIL_PRINT);\n    return;\n  }\n  scoped_ptr<PrepareFrameAndViewForPrint> prepare;\n  prepare.reset(new PrepareFrameAndViewForPrint(print_pages_params_->params,\n                                                pdf_frame, pdf_element));\n  UpdatePrintableSizeInPrintParameters(pdf_frame, pdf_element, prepare.get(),\n                                       &print_pages_params_->params);\n  if (!RenderPagesForPrint(pdf_frame, pdf_element, prepare.get())) {\n    LOG(ERROR) << \"RenderPagesForPrint failed\";\n    DidFinishPrinting(FAIL_PRINT);\n  }\n}", "target": 0}
{"code": "static int ssl_hs_is_proper_fragment( mbedtls_ssl_context *ssl )\n{\n    if( ssl->in_msglen < ssl->in_hslen ||\n        memcmp( ssl->in_msg + 6, \"\\0\\0\\0\",        3 ) != 0 ||\n        memcmp( ssl->in_msg + 9, ssl->in_msg + 1, 3 ) != 0 )\n    {\n        return( 1 );\n    }\n    return( 0 );\n}", "target": 0}
{"code": "rpmRC headerCheck(rpmts ts, const void * uh, size_t uc, char ** msg)\n{\n    rpmRC rc;\n    rpmVSFlags vsflags = rpmtsVSFlags(ts);\n    rpmKeyring keyring = rpmtsGetKeyring(ts, 1);\n    rpmswEnter(rpmtsOp(ts, RPMTS_OP_DIGEST), 0);\n    rc = headerVerify(keyring, vsflags, uh, uc, msg);\n    rpmswExit(rpmtsOp(ts, RPMTS_OP_DIGEST), uc);\n    rpmKeyringFree(keyring);\n    return rc;\n}", "target": 0}
{"code": "double Item_param::val_real()\n{\n  switch (state) {\n  case REAL_VALUE:\n    return value.real;\n  case INT_VALUE:\n    return (double) value.integer;\n  case DECIMAL_VALUE:\n  {\n    double result;\n    my_decimal2double(E_DEC_FATAL_ERROR, &decimal_value, &result);\n    return result;\n  }\n  case STRING_VALUE:\n  case LONG_DATA_VALUE:\n  {\n    int dummy_err;\n    char *end_not_used;\n    return my_strntod(str_value.charset(), (char*) str_value.ptr(),\n                      str_value.length(), &end_not_used, &dummy_err);\n  }\n  case TIME_VALUE:\n    return ulonglong2double(TIME_to_ulonglong(&value.time));\n  case NULL_VALUE:\n    return 0.0;\n  default:\n    DBUG_ASSERT(0);\n  }\n  return 0.0;\n} ", "target": 0}
{"code": "static int rtnl_dellink(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct net_device *dev;\n\tstruct ifinfomsg *ifm;\n\tchar ifname[IFNAMSIZ];\n\tstruct nlattr *tb[IFLA_MAX+1];\n\tint err;\n\terr = nlmsg_parse(nlh, sizeof(*ifm), tb, IFLA_MAX, ifla_policy);\n\tif (err < 0)\n\t\treturn err;\n\tif (tb[IFLA_IFNAME])\n\t\tnla_strlcpy(ifname, tb[IFLA_IFNAME], IFNAMSIZ);\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifi_index > 0)\n\t\tdev = __dev_get_by_index(net, ifm->ifi_index);\n\telse if (tb[IFLA_IFNAME])\n\t\tdev = __dev_get_by_name(net, ifname);\n\telse if (tb[IFLA_GROUP])\n\t\treturn rtnl_group_dellink(net, nla_get_u32(tb[IFLA_GROUP]));\n\telse\n\t\treturn -EINVAL;\n\tif (!dev)\n\t\treturn -ENODEV;\n\treturn rtnl_delete_link(dev);\n}", "target": 0}
{"code": "int _WM_midi_setup_noteoff(struct _mdi *mdi, uint8_t channel,\n                           uint8_t note, uint8_t velocity) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,channel, note);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_note_off;\n    mdi->events[mdi->event_count].event_data.channel = channel;\n    mdi->events[mdi->event_count].event_data.data.value = (note << 8) | velocity;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}", "target": 0}
{"code": "device_local_get_native_path (Device *device)\n{\n  return device->priv->native_path;\n}", "target": 0}
{"code": "static void radix_sort(RCCMPEntry *data, int size)\n{\n    int buckets[RADIX_PASSES][NBUCKETS];\n    RCCMPEntry *tmp = av_malloc(sizeof(*tmp) * size);\n    radix_count(data, size, buckets);\n    radix_sort_pass(tmp, data, size, buckets[0], 0);\n    radix_sort_pass(data, tmp, size, buckets[1], 1);\n    if (buckets[2][NBUCKETS - 1] || buckets[3][NBUCKETS - 1]) {\n        radix_sort_pass(tmp, data, size, buckets[2], 2);\n        radix_sort_pass(data, tmp, size, buckets[3], 3);\n    }\n    av_free(tmp);\n}", "target": 0}
{"code": "static int decode_attr_length(struct xdr_stream *xdr, uint32_t *attrlen, unsigned int *savep)\n{\n\t__be32 *p;\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\t*attrlen = be32_to_cpup(p);\n\t*savep = xdr_stream_pos(xdr);\n\treturn 0;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}", "target": 0}
{"code": "iasecc_keyset_change(struct sc_card *card, struct sc_pin_cmd_data *data, int *tries_left)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct iasecc_sdo_update update;\n\tstruct iasecc_sdo sdo;\n\tunsigned scb;\n\tint rv;\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"Change keyset(ref:%i,lengths:%i)\", data->pin_reference, data->pin2.len);\n\tif (!data->pin2.data || data->pin2.len < 32)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Needs at least 32 bytes for a new keyset value\");\n\tmemset(&sdo, 0, sizeof(sdo));\n\tsdo.sdo_class = IASECC_SDO_CLASS_KEYSET;\n\tsdo.sdo_ref  = data->pin_reference;\n\trv = iasecc_sdo_get_data(card, &sdo);\n\tLOG_TEST_RET(ctx, rv, \"Cannot get keyset data\");\n\tif (sdo.docp.acls_contact.size == 0)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_INVALID_DATA, \"Bewildered ... there are no ACLs\");\n\tscb = sdo.docp.scbs[IASECC_ACLS_KEYSET_PUT_DATA];\n\tiasecc_sdo_free_fields(card, &sdo);\n\tsc_log(ctx, \"SCB:0x%X\", scb);\n\tif (!(scb & IASECC_SCB_METHOD_SM))\n\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"Other then protected by SM, the keyset change is not supported\");\n\tmemset(&update, 0, sizeof(update));\n\tupdate.magic = SC_CARDCTL_IASECC_SDO_MAGIC_PUT_DATA;\n\tupdate.sdo_class = sdo.sdo_class;\n\tupdate.sdo_ref = sdo.sdo_ref;\n\tupdate.fields[0].parent_tag = IASECC_SDO_KEYSET_TAG;\n\tupdate.fields[0].tag = IASECC_SDO_KEYSET_TAG_MAC;\n\tupdate.fields[0].value = (unsigned char *) data->pin2.data;\n\tupdate.fields[0].size = 16;\n\tupdate.fields[1].parent_tag = IASECC_SDO_KEYSET_TAG;\n\tupdate.fields[1].tag = IASECC_SDO_KEYSET_TAG_ENC;\n\tupdate.fields[1].value = (unsigned char *) data->pin2.data + 16;\n\tupdate.fields[1].size = 16;\n\trv = iasecc_sm_sdo_update(card, (scb & IASECC_SCB_METHOD_MASK_REF), &update);\n\tLOG_FUNC_RETURN(ctx, rv);\n}", "target": 0}
{"code": "bool RenderWidgetHostViewAura::LockMouse() {\n  aura::Window* root_window = window_->GetRootWindow();\n  if (!root_window)\n    return false;\n  if (mouse_locked_)\n    return true;\n  mouse_locked_ = true;\n#if !defined(OS_WIN)\n  window_->SetCapture();\n#endif\n  aura::client::CursorClient* cursor_client =\n      aura::client::GetCursorClient(root_window);\n  if (cursor_client) {\n    cursor_client->HideCursor();\n    cursor_client->LockCursor();\n  }\n  if (ShouldMoveToCenter()) {\n    synthetic_move_sent_ = true;\n    window_->MoveCursorTo(gfx::Rect(window_->bounds().size()).CenterPoint());\n  }\n  tooltip_disabler_.reset(new aura::client::ScopedTooltipDisabler(root_window));\n  root_window->GetDispatcher()->host()->ConfineCursorToRootWindow();\n  return true;\n}", "target": 0}
{"code": "ValueToOption (\n  IN FORM_DISPLAY_ENGINE_STATEMENT   *Question,\n  IN EFI_HII_VALUE                   *OptionValue\n  )\n{\n  LIST_ENTRY               *Link;\n  DISPLAY_QUESTION_OPTION  *Option;\n  INTN                     Result;\n  EFI_HII_VALUE            Value;\n  Link = GetFirstNode (&Question->OptionListHead);\n  while (!IsNull (&Question->OptionListHead, Link)) {\n    Option = DISPLAY_QUESTION_OPTION_FROM_LINK (Link);\n    ZeroMem (&Value, sizeof (EFI_HII_VALUE));\n    Value.Type = Option->OptionOpCode->Type;\n    CopyMem (&Value.Value, &Option->OptionOpCode->Value, Option->OptionOpCode->Header.Length - OFFSET_OF (EFI_IFR_ONE_OF_OPTION, Value));\n    if ((CompareHiiValue (&Value, OptionValue, &Result, NULL) == EFI_SUCCESS) && (Result == 0)) {\n      return Option;\n    }\n    Link = GetNextNode (&Question->OptionListHead, Link);\n  }\n  return NULL;\n}", "target": 0}
{"code": "static inline int imgCoordMungeUpperC(SplashCoord x, GBool glyphMode) {\n  return glyphMode ? (splashCeil(x + 0.5) - 1) : (splashFloor(x) + 1);\n}", "target": 0}
{"code": "static inline bool cpu_has_vmx_invept_global(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_EXTENT_GLOBAL_BIT;\n}", "target": 0}
{"code": "MagickPrivate void ConvertRGBToLCHab(const double red,const double green,\n  const double blue,double *luma,double *chroma,double *hue)\n{\n  double\n    X,\n    Y,\n    Z;\n  assert(luma != (double *) NULL);\n  assert(chroma != (double *) NULL);\n  assert(hue != (double *) NULL);\n  ConvertRGBToXYZ(red,green,blue,&X,&Y,&Z);\n  ConvertXYZToLCHab(X,Y,Z,luma,chroma,hue);\n}", "target": 0}
{"code": "iasecc_pin_get_status(struct sc_card *card, struct sc_pin_cmd_data *data, int *tries_left)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_pin_cmd_data info;\n\tint rv;\n\tLOG_FUNC_CALLED(ctx);\n\tif (data->pin_type != SC_AC_CHV)\n\t\tLOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, \"PIN type is not supported for status\");\n\tmemset(&info, 0, sizeof(info));\n\tinfo.cmd = SC_PIN_CMD_GET_INFO;\n\tinfo.pin_type = data->pin_type;\n\tinfo.pin_reference = data->pin_reference;\n\trv = iso_ops->pin_cmd(card, &info, tries_left);\n\tLOG_TEST_RET(ctx, rv, \"Failed to get PIN info\");\n\tdata->pin1.max_tries = info.pin1.max_tries;\n\tdata->pin1.tries_left = info.pin1.tries_left;\n\tdata->pin1.logged_in = info.pin1.logged_in;\n\tLOG_FUNC_RETURN(ctx, rv);\n}", "target": 0}
{"code": "static int mirror_prepare(Job *job)\n{\n    return mirror_exit_common(job);\n}", "target": 0}
{"code": "void GLES2DecoderTestBase::DoBindRenderbuffer(\n    GLenum target, GLuint client_id, GLuint service_id) {\n  EXPECT_CALL(*gl_, BindRenderbufferEXT(target, service_id))\n      .Times(1)\n      .RetiresOnSaturation();\n  BindRenderbuffer cmd;\n  cmd.Init(target, client_id);\n  EXPECT_EQ(error::kNoError, ExecuteCmd(cmd));\n}", "target": 0}
{"code": "void tipc_node_get(struct tipc_node *node)\n{\n\tkref_get(&node->kref);\n}", "target": 0}
{"code": "virSecuritySELinuxMCSRemove(virSecurityManager *mgr,\n                            const char *mcs)\n{\n    virSecuritySELinuxData *data = virSecurityManagerGetPrivateData(mgr);\n    virHashRemoveEntry(data->mcs, mcs);\n}", "target": 0}
{"code": "static int nfs4_lock_reclaim(struct nfs4_state *state, struct file_lock *request)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_exception exception = {\n\t\t.inode = state->inode,\n\t};\n\tint err;\n\tdo {\n\t\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) != 0)\n\t\t\treturn 0;\n\t\terr = _nfs4_do_setlk(state, F_SETLK, request, NFS_LOCK_RECLAIM);\n\t\tif (err != -NFS4ERR_DELAY)\n\t\t\tbreak;\n\t\tnfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\n\treturn err;\n}", "target": 0}
{"code": "vte_sequence_handler_normal_keypad (VteTerminal *terminal, GValueArray *params)\n{\n\t_vte_debug_print(VTE_DEBUG_KEYBOARD,\n\t\t\t\"Leaving application keypad mode.\\n\");\n\tterminal->pvt->keypad_mode = VTE_KEYMODE_NORMAL;\n}", "target": 0}
{"code": "    DataBuf TiffHeaderBase::write() const\n    {\n        DataBuf buf(8);\n        switch (byteOrder_) {\n        case littleEndian:\n            buf.pData_[0] = 0x49;\n            buf.pData_[1] = 0x49;\n            break;\n        case bigEndian:\n            buf.pData_[0] = 0x4d;\n            buf.pData_[1] = 0x4d;\n            break;\n        case invalidByteOrder:\n            assert(false);\n            break;\n        }\n        us2Data(buf.pData_ + 2, tag_, byteOrder_);\n        ul2Data(buf.pData_ + 4, 0x00000008, byteOrder_);\n        return buf;\n    }", "target": 0}
{"code": "void set_position(JOIN *join,uint idx,JOIN_TAB *table,KEYUSE *key)\n{\n  join->positions[idx].table= table;\n  join->positions[idx].key=key;\n  join->positions[idx].records_read=1.0;\t\n  join->positions[idx].cond_selectivity= 1.0;\n  join->positions[idx].ref_depend_map= 0;\n  join->positions[idx].sj_strategy= SJ_OPT_NONE;\n  join->positions[idx].use_join_buffer= FALSE;\n  JOIN_TAB **pos=join->best_ref+idx+1;\n  JOIN_TAB *next=join->best_ref[idx];\n  for (;next != table ; pos++)\n  {\n    JOIN_TAB *tmp=pos[0];\n    pos[0]=next;\n    next=tmp;\n  }\n  join->best_ref[idx]=table;\n}", "target": 0}
{"code": "rt__valid_ordinal_p(VALUE y, VALUE d, VALUE sg)\n{\n    VALUE nth, rjd2;\n    int ry, rd, rjd, ns;\n    if (!valid_ordinal_p(y, NUM2INT(d), NUM2DBL(sg),\n\t\t\t &nth, &ry,\n\t\t\t &rd, &rjd,\n\t\t\t &ns))\n\treturn Qnil;\n    encode_jd(nth, rjd, &rjd2);\n    return rjd2;\n}", "target": 0}
{"code": "int close_fd_get_file(unsigned int fd, struct file **res)\n{\n\tstruct files_struct *files = current->files;\n\tint ret;\n\tspin_lock(&files->file_lock);\n\tret = __close_fd_get_file(fd, res);\n\tspin_unlock(&files->file_lock);\n\treturn ret;\n}", "target": 0}
{"code": "static PHP_INI_MH(OnChangeMailForceExtra)\n{\n\tif (stage == PHP_INI_STAGE_HTACCESS) {\n\t\t\treturn FAILURE;\n\t}\n\treturn SUCCESS;\n}", "target": 0}
{"code": "static ssize_t evdev_read(struct file *file, char __user *buffer,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct evdev_client *client = file->private_data;\n\tstruct evdev *evdev = client->evdev;\n\tstruct input_event event;\n\tsize_t read = 0;\n\tint error;\n\tif (count != 0 && count < input_event_size())\n\t\treturn -EINVAL;\n\tfor (;;) {\n\t\tif (!evdev->exist || client->revoked)\n\t\t\treturn -ENODEV;\n\t\tif (client->packet_head == client->tail &&\n\t\t    (file->f_flags & O_NONBLOCK))\n\t\t\treturn -EAGAIN;\n\t\tif (count == 0)\n\t\t\tbreak;\n\t\twhile (read + input_event_size() <= count &&\n\t\t       evdev_fetch_next_event(client, &event)) {\n\t\t\tif (input_event_to_user(buffer + read, &event))\n\t\t\t\treturn -EFAULT;\n\t\t\tread += input_event_size();\n\t\t}\n\t\tif (read)\n\t\t\tbreak;\n\t\tif (!(file->f_flags & O_NONBLOCK)) {\n\t\t\terror = wait_event_interruptible(evdev->wait,\n\t\t\t\t\tclient->packet_head != client->tail ||\n\t\t\t\t\t!evdev->exist || client->revoked);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\treturn read;\n}", "target": 0}
{"code": "la2ycbcr(UINT8 *out, const UINT8 *in, int xsize) {\n    int x;\n    for (x = 0; x < xsize; x++, in += 4) {\n        *out++ = in[0];\n        *out++ = 128;\n        *out++ = 128;\n        *out++ = 255;\n    }\n}", "target": 0}
{"code": "writeRandomBytes_dev_urandom(void *target, size_t count) {\n  int success = 0; \n  size_t bytesWrittenTotal = 0;\n  const int fd = open(\"/dev/urandom\", O_RDONLY);\n  if (fd < 0) {\n    return 0;\n  }\n  do {\n    void *const currentTarget = (void *)((char *)target + bytesWrittenTotal);\n    const size_t bytesToWrite = count - bytesWrittenTotal;\n    const ssize_t bytesWrittenMore = read(fd, currentTarget, bytesToWrite);\n    if (bytesWrittenMore > 0) {\n      bytesWrittenTotal += bytesWrittenMore;\n      if (bytesWrittenTotal >= count)\n        success = 1;\n    }\n  } while (! success && (errno == EINTR));\n  close(fd);\n  return success;\n}", "target": 0}
{"code": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}", "target": 0}
{"code": "CSSRule *CSSStyleSheet::ownerRule() const\n{\n    return (parent() && parent()->isRule()) ? static_cast<CSSRule*>(parent()) : 0;\n}", "target": 0}
{"code": "static inline int skb_pagelen(const struct sk_buff *skb)\n{\n\tint i, len = 0;\n\tfor (i = (int)skb_shinfo(skb)->nr_frags - 1; i >= 0; i--)\n\t\tlen += skb_frag_size(&skb_shinfo(skb)->frags[i]);\n\treturn len + skb_headlen(skb);\n}", "target": 0}
{"code": "PHPAPI zend_class_entry *php_date_get_timezone_ce(void)\n{\n\treturn date_ce_timezone;\n}", "target": 0}
{"code": "static void free_type_entry(RBinWasmTypeEntry *ptr) {\n\tif (ptr) {\n\t\tfree_type_vec (ptr->args);\n\t\tfree_type_vec (ptr->rets);\n\t\tfree (ptr->to_str);\n\t\tfree (ptr);\n\t}\n}", "target": 0}
{"code": "GF_Err gitn_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, ptr->nb_entries);\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tgf_bs_write_u32(bs, ptr->entries[i].group_id);\n\t\tif (ptr->entries[i].name) gf_bs_write_data(bs, ptr->entries[i].name, (u32)strlen(ptr->entries[i].name) );\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "rgbA2rgba(UINT8 *out, const UINT8 *in, int xsize) {\n    int x;\n    unsigned int alpha, tmp;\n    for (x = 0; x < xsize; x++) {\n        alpha = in[3];\n        *out++ = MULDIV255(*in++, alpha, tmp);\n        *out++ = MULDIV255(*in++, alpha, tmp);\n        *out++ = MULDIV255(*in++, alpha, tmp);\n        *out++ = *in++;\n    }\n}", "target": 0}
{"code": "static int ldapsrv_add_with_controls(struct ldapsrv_call *call,\n\t\t\t\t     const struct ldb_message *message,\n\t\t\t\t     struct ldb_control **controls,\n\t\t\t\t     struct ldb_result *res)\n{\n\tstruct ldb_context *ldb = call->conn->ldb;\n\tstruct ldb_request *req;\n\tint ret;\n\tret = ldb_msg_sanity_check(ldb, message);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tret = ldb_build_add_req(&req, ldb, ldb,\n\t\t\t\t\tmessage,\n\t\t\t\t\tcontrols,\n\t\t\t\t\tres,\n\t\t\t\t\tldb_modify_default_callback,\n\t\t\t\t\tNULL);\n\tif (ret != LDB_SUCCESS) return ret;\n\tif (call->conn->global_catalog) {\n\t\treturn ldb_error(ldb, LDB_ERR_UNWILLING_TO_PERFORM, \"modify forbidden on global catalog port\");\n\t}\n\tldb_request_add_control(req, DSDB_CONTROL_NO_GLOBAL_CATALOG, false, NULL);\n\tret = ldb_transaction_start(ldb);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (!call->conn->is_privileged) {\n\t\tldb_req_mark_untrusted(req);\n\t}\n\tLDB_REQ_SET_LOCATION(req);\n\tret = ldb_request(ldb, req);\n\tif (ret == LDB_SUCCESS) {\n\t\tret = ldb_wait(req->handle, LDB_WAIT_ALL);\n\t}\n\tif (ret == LDB_SUCCESS) {\n\t\tret = ldb_transaction_commit(ldb);\n\t}\n\telse {\n\t\tldb_transaction_cancel(ldb);\n\t}\n\ttalloc_free(req);\n\treturn ret;\n}", "target": 0}
{"code": "rb_enc_asciicompat(OnigEncoding enc)\n{\n  return ONIGENC_MBC_MINLEN(enc)==1 && !((enc)->ruby_encoding_index & ENC_DUMMY_FLAG);\n}", "target": 0}
{"code": "GDHCPClientError g_dhcp_client_set_id(GDHCPClient *dhcp_client)\n{\n\tconst unsigned maclen = 6;\n\tconst unsigned idlen = maclen + 1;\n\tconst uint8_t option_code = G_DHCP_CLIENT_ID;\n\tuint8_t idbuf[idlen];\n\tuint8_t *data_option;\n\tidbuf[0] = ARPHRD_ETHER;\n\tmemcpy(&idbuf[1], dhcp_client->mac_address, maclen);\n\tdata_option = alloc_dhcp_data_option(option_code, idbuf, idlen);\n\tif (!data_option)\n\t\treturn G_DHCP_CLIENT_ERROR_NOMEM;\n\tg_hash_table_insert(dhcp_client->send_value_hash,\n\t\tGINT_TO_POINTER((int) option_code), data_option);\n\treturn G_DHCP_CLIENT_ERROR_NONE;\n}", "target": 0}
{"code": "asmlinkage unsigned long sys_brk(unsigned long brk)\n{\n\tunsigned long rlim, retval;\n\tunsigned long newbrk, oldbrk;\n\tstruct mm_struct *mm = current->mm;\n\tdown_write(&mm->mmap_sem);\n\tif (brk < mm->end_code)\n\t\tgoto out;\n\trlim = current->signal->rlim[RLIMIT_DATA].rlim_cur;\n\tif (rlim < RLIM_INFINITY && brk - mm->start_data > rlim)\n\t\tgoto out;\n\tnewbrk = PAGE_ALIGN(brk);\n\toldbrk = PAGE_ALIGN(mm->brk);\n\tif (oldbrk == newbrk)\n\t\tgoto set_brk;\n\tif (brk <= mm->brk) {\n\t\tif (!do_munmap(mm, newbrk, oldbrk-newbrk))\n\t\t\tgoto set_brk;\n\t\tgoto out;\n\t}\n\tif (find_vma_intersection(mm, oldbrk, newbrk+PAGE_SIZE))\n\t\tgoto out;\n\tif (do_brk(oldbrk, newbrk-oldbrk) != oldbrk)\n\t\tgoto out;\nset_brk:\n\tmm->brk = brk;\nout:\n\tretval = mm->brk;\n\tup_write(&mm->mmap_sem);\n\treturn retval;\n}", "target": 0}
{"code": "static long int cfg_opt_gettsecidx(cfg_opt_t *opt, const char *title)\n{\n\tunsigned int i, n;\n\tn = cfg_opt_size(opt);\n\tfor (i = 0; i < n; i++) {\n\t\tcfg_t *sec = cfg_opt_getnsec(opt, i);\n\t\tif (!sec || !sec->title)\n\t\t\treturn -1;\n\t\tif (is_set(CFGF_NOCASE, opt->flags)) {\n\t\t\tif (strcasecmp(title, sec->title) == 0)\n\t\t\t\treturn i;\n\t\t} else {\n\t\t\tif (strcmp(title, sec->title) == 0)\n\t\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}", "target": 0}
{"code": "static int compat_update_counters(struct net *net, void __user *user,\n\t\t\t\t  unsigned int len)\n{\n\tstruct compat_ebt_replace hlp;\n\tif (copy_from_user(&hlp, user, sizeof(hlp)))\n\t\treturn -EFAULT;\n\tif (len != sizeof(hlp) + hlp.num_counters * sizeof(struct ebt_counter))\n\t\treturn update_counters(net, user, len);\n\treturn do_update_counters(net, hlp.name, compat_ptr(hlp.counters),\n\t\t\t\t\thlp.num_counters, user, len);\n}", "target": 0}
{"code": "foreachfile_callback (char *dirname, void *data1, void *data2)\n{\n  file_worker_func *func = *(file_worker_func **) data1;\n  int\t  is_done  = 0;\n  char   *argz     = 0;\n  size_t  argz_len = 0;\n  if (list_files_by_dir (dirname, &argz, &argz_len) != 0)\n    goto cleanup;\n  if (!argz)\n    goto cleanup;\n  {\n    char *filename = 0;\n    while ((filename = argz_next (argz, argz_len, filename)))\n      if ((is_done = (*func) (filename, data2)))\n\tbreak;\n  }\n cleanup:\n  FREE (argz);\n  return is_done;\n}", "target": 0}
{"code": "PHP_IMAP_EXPORT void mm_lsub(MAILSTREAM *stream, DTYPE delimiter, char *mailbox, long attributes)\n{\n\tSTRINGLIST *cur=NIL;\n\tFOBJECTLIST *ocur=NIL;\n\tif (IMAPG(folderlist_style) == FLIST_OBJECT) {\n\t\tif (IMAPG(imap_sfolder_objects) == NIL) {\n\t\t\tIMAPG(imap_sfolder_objects) = mail_newfolderobjectlist();\n\t\t\tIMAPG(imap_sfolder_objects)->LSIZE = strlen((char*)(IMAPG(imap_sfolder_objects)->LTEXT = (unsigned char*)cpystr(mailbox)));\n\t\t\tIMAPG(imap_sfolder_objects)->delimiter = delimiter;\n\t\t\tIMAPG(imap_sfolder_objects)->attributes = attributes;\n\t\t\tIMAPG(imap_sfolder_objects)->next = NIL;\n\t\t\tIMAPG(imap_sfolder_objects_tail) = IMAPG(imap_sfolder_objects);\n\t\t} else {\n\t\t\tocur=IMAPG(imap_sfolder_objects_tail);\n\t\t\tocur->next=mail_newfolderobjectlist();\n\t\t\tocur=ocur->next;\n\t\t\tocur->LSIZE=strlen((char*)(ocur->LTEXT = (unsigned char*)cpystr(mailbox)));\n\t\t\tocur->delimiter = delimiter;\n\t\t\tocur->attributes = attributes;\n\t\t\tocur->next = NIL;\n\t\t\tIMAPG(imap_sfolder_objects_tail) = ocur;\n\t\t}\n\t} else {\n\t\tif (IMAPG(imap_sfolders) == NIL) {\n\t\t\tIMAPG(imap_sfolders)=mail_newstringlist();\n\t\t\tIMAPG(imap_sfolders)->LSIZE=strlen((char*)(IMAPG(imap_sfolders)->LTEXT = (unsigned char*)cpystr(mailbox)));\n\t\t\tIMAPG(imap_sfolders)->next=NIL;\n\t\t\tIMAPG(imap_sfolders_tail) = IMAPG(imap_sfolders);\n\t\t} else {\n\t\t\tcur=IMAPG(imap_sfolders_tail);\n\t\t\tcur->next=mail_newstringlist ();\n\t\t\tcur=cur->next;\n\t\t\tcur->LSIZE = strlen((char*)(cur->LTEXT = (unsigned char*)cpystr(mailbox)));\n\t\t\tcur->next = NIL;\n\t\t\tIMAPG(imap_sfolders_tail) = cur;\n\t\t}\n\t}", "target": 0}
{"code": "TEST(QuantizedPoolingOpTest, MaxPoolLargeDepth) {\n  constexpr int depth = 1999;  \n  QuantizedPoolingOpModel m(\n      BuiltinOperator_MAX_POOL_2D,\n      {TensorType_UINT8, {1, 2, 4, depth}, 0, 15.9375},\n      2, 2,\n      {TensorType_UINT8, {}, 0, 15.9375});\n  std::vector<float> input_image_plane({\n      0.f, 6.f, 2.f, 4.f,   \n      3.f, 2.f, 10.f, 7.f,  \n  });\n  std::vector<float> output_image_plane({6.f, 10.f});\n  m.SetInput(ReplicateDepthRamp(input_image_plane, depth, 1.f / 512.f));\n  m.Invoke();\n  EXPECT_THAT(m.GetDequantizedOutput(),\n              ElementsAreArray(ArrayFloatNear(\n                  ReplicateDepthRamp(output_image_plane, depth, 1.f / 512.f),\n                  1. / 32.f)));\n}", "target": 0}
{"code": "template <> HeaderMapImpl::StaticLookupTable<RequestTrailerMap>::StaticLookupTable() {\n  finalizeTable();\n}", "target": 0}
{"code": "static unsigned long ssl_session_hash(const SSL_SESSION *a)\n\t{\n\tunsigned long l;\n\tl=(unsigned long)\n\t\t((unsigned int) a->session_id[0]     )|\n\t\t((unsigned int) a->session_id[1]<< 8L)|\n\t\t((unsigned long)a->session_id[2]<<16L)|\n\t\t((unsigned long)a->session_id[3]<<24L);\n\treturn(l);\n\t}", "target": 0}
{"code": "static void php_apache_child_init(apr_pool_t *pchild, server_rec *s)\n{\n\tapr_pool_cleanup_register(pchild, NULL, php_apache_child_shutdown, apr_pool_cleanup_null);\n}", "target": 0}
{"code": "generate_string(cms_context *cms, SECItem *der, char *str)\n{\n\tSECItem input;\n\tinput.data = (void *)str;\n\tinput.len = strlen(str);\n\tinput.type = siBMPString;\n\tvoid *ret;\n\tret = SEC_ASN1EncodeItem(cms->arena, der, &input,\n\t\t\t\t\t\tSEC_PrintableStringTemplate);\n\tif (ret == NULL)\n\t\tcnreterr(-1, cms, \"could not encode string\");\n\treturn 0;\n}", "target": 0}
{"code": "static git_tree_entry *treebuilder_get(git_treebuilder *bld, const char *filename)\n{\n\tsize_t idx;\n\tgit_tree_entry *entry;\n\tassert(bld && filename);\n\tif (tree_key_search(&idx, &bld->entries, filename, strlen(filename)) < 0)\n\t\treturn NULL;\n\tentry = git_vector_get(&bld->entries, idx);\n\tif (entry->removed)\n\t\treturn NULL;\n\treturn entry;\n}", "target": 0}
{"code": "void exit_aio(struct mm_struct *mm)\n{\n\tstruct kioctx_table *table;\n\tstruct kioctx *ctx;\n\tunsigned i = 0;\n\twhile (1) {\n\t\tstruct completion requests_done =\n\t\t\tCOMPLETION_INITIALIZER_ONSTACK(requests_done);\n\t\trcu_read_lock();\n\t\ttable = rcu_dereference(mm->ioctx_table);\n\t\tdo {\n\t\t\tif (!table || i >= table->nr) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\trcu_assign_pointer(mm->ioctx_table, NULL);\n\t\t\t\tif (table)\n\t\t\t\t\tkfree(table);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tctx = table->table[i++];\n\t\t} while (!ctx);\n\t\trcu_read_unlock();\n\t\tctx->mmap_size = 0;\n\t\tkill_ioctx(mm, ctx, &requests_done);\n\t\twait_for_completion(&requests_done);\n\t}\n}", "target": 0}
{"code": "isdn_dc2minor(int di, int ch)\n{\n\tint i;\n\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++)\n\t\tif (dev->chanmap[i] == ch && dev->drvmap[i] == di)\n\t\t\treturn i;\n\treturn -1;\n}", "target": 0}
{"code": "static struct in6_addr *extract_addr(struct nlattr *addr, struct nlattr *local,\n\t\t\t\t     struct in6_addr **peer_pfx)\n{\n\tstruct in6_addr *pfx = NULL;\n\t*peer_pfx = NULL;\n\tif (addr)\n\t\tpfx = nla_data(addr);\n\tif (local) {\n\t\tif (pfx && nla_memcmp(local, pfx, sizeof(*pfx)))\n\t\t\t*peer_pfx = pfx;\n\t\tpfx = nla_data(local);\n\t}\n\treturn pfx;\n}", "target": 0}
{"code": "static int decode_attr_files_avail(struct xdr_stream *xdr, uint32_t *bitmap, uint64_t *res)\n{\n\t__be32 *p;\n\tint status = 0;\n\t*res = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_FILES_AVAIL - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_FILES_AVAIL)) {\n\t\tp = xdr_inline_decode(xdr, 8);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_overflow;\n\t\txdr_decode_hyper(p, res);\n\t\tbitmap[0] &= ~FATTR4_WORD0_FILES_AVAIL;\n\t}\n\tdprintk(\"%s: files avail=%Lu\\n\", __func__, (unsigned long long)*res);\n\treturn status;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}", "target": 0}
{"code": "void Shell::OnLockStateChanged(bool locked) {\n  FOR_EACH_OBSERVER(ShellObserver, observers_, OnLockStateChanged(locked));\n#ifndef NDEBUG\n  if (!locked) {\n    std::vector<aura::Window*> containers = GetContainersFromAllRootWindows(\n        kShellWindowId_LockSystemModalContainer, GetPrimaryRootWindow());\n    for (std::vector<aura::Window*>::const_iterator iter = containers.begin();\n         iter != containers.end(); ++iter) {\n      DCHECK_EQ(0u, (*iter)->children().size());\n    }\n  }\n#endif\n}", "target": 0}
{"code": "debug_print_argv(const uschar ** argv)\n{\ndebug_printf(\"exec\");\nwhile (*argv) debug_printf(\" %.256s\", *argv++);\ndebug_printf(\"\\n\");\n}", "target": 0}
{"code": "d_lite_sec(VALUE self)\n{\n    get_d1(self);\n    return INT2FIX(m_sec(dat));\n}", "target": 0}
{"code": "    TiffMnEntry* TiffMnEntry::doClone() const\n    {\n        assert(false); \n        return 0;\n    }", "target": 0}
{"code": "static void bm_clear_inode(struct inode *inode)\n{\n\tkfree(inode->i_private);\n}", "target": 0}
{"code": "void AudioContext::decodeAudioData(DOMArrayBuffer* audioData, AudioBufferCallback* successCallback, AudioBufferCallback* errorCallback, ExceptionState& exceptionState)\n{\n    if (!audioData) {\n        exceptionState.throwDOMException(\n            SyntaxError,\n            \"invalid ArrayBuffer for audioData.\");\n        return;\n    }\n    m_audioDecoder.decodeAsync(audioData, sampleRate(), successCallback, errorCallback);\n}", "target": 0}
{"code": "static ssize_t disk_events_poll_msecs_show(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\treturn sprintf(buf, \"%ld\\n\", disk->ev->poll_msecs);\n}", "target": 0}
{"code": "create_code(struct archive_read *a, struct huffman_code *code,\n            unsigned char *lengths, int numsymbols, char maxlength)\n{\n  int i, j, codebits = 0, symbolsleft = numsymbols;\n  code->numentries = 0;\n  code->numallocatedentries = 0;\n  if (new_node(code) < 0) {\n    archive_set_error(&a->archive, ENOMEM,\n                      \"Unable to allocate memory for node data.\");\n    return (ARCHIVE_FATAL);\n  }\n  code->numentries = 1;\n  code->minlength = INT_MAX;\n  code->maxlength = INT_MIN;\n  codebits = 0;\n  for(i = 1; i <= maxlength; i++)\n  {\n    for(j = 0; j < numsymbols; j++)\n    {\n      if (lengths[j] != i) continue;\n      if (add_value(a, code, j, codebits, i) != ARCHIVE_OK)\n        return (ARCHIVE_FATAL);\n      codebits++;\n      if (--symbolsleft <= 0) { break; break; }\n    }\n    codebits <<= 1;\n  }\n  return (ARCHIVE_OK);\n}", "target": 0}
{"code": "stmt_read_row_no_data(MYSQL_STMT *stmt  __attribute__((unused)),\n                      unsigned char **row  __attribute__((unused)))\n{\n  return MYSQL_NO_DATA;\n}", "target": 0}
{"code": "static void bnx2x_drv_info_ether_stat(struct bnx2x *bp)\n{\n\tstruct eth_stats_info *ether_stat =\n\t\t&bp->slowpath->drv_info_to_mcp.ether_stat;\n\tstruct bnx2x_vlan_mac_obj *mac_obj =\n\t\t&bp->sp_objs->mac_obj;\n\tint i;\n\tstrlcpy(ether_stat->version, DRV_MODULE_VERSION,\n\t\tETH_STAT_INFO_VERSION_LEN);\n\tfor (i = 0; i < DRV_INFO_ETH_STAT_NUM_MACS_REQUIRED; i++)\n\t\tmemset(ether_stat->mac_local + i, 0,\n\t\t       sizeof(ether_stat->mac_local[0]));\n\tmac_obj->get_n_elements(bp, &bp->sp_objs[0].mac_obj,\n\t\t\t\tDRV_INFO_ETH_STAT_NUM_MACS_REQUIRED,\n\t\t\t\tether_stat->mac_local + MAC_PAD, MAC_PAD,\n\t\t\t\tETH_ALEN);\n\tether_stat->mtu_size = bp->dev->mtu;\n\tif (bp->dev->features & NETIF_F_RXCSUM)\n\t\tether_stat->feature_flags |= FEATURE_ETH_CHKSUM_OFFLOAD_MASK;\n\tif (bp->dev->features & NETIF_F_TSO)\n\t\tether_stat->feature_flags |= FEATURE_ETH_LSO_MASK;\n\tether_stat->feature_flags |= bp->common.boot_mode;\n\tether_stat->promiscuous_mode = (bp->dev->flags & IFF_PROMISC) ? 1 : 0;\n\tether_stat->txq_size = bp->tx_ring_size;\n\tether_stat->rxq_size = bp->rx_ring_size;\n#ifdef CONFIG_BNX2X_SRIOV\n\tether_stat->vf_cnt = IS_SRIOV(bp) ? bp->vfdb->sriov.nr_virtfn : 0;\n#endif\n}", "target": 0}
{"code": "static int btrfs_relocate_sys_chunks(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *chunk_root = fs_info->chunk_root;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct btrfs_chunk *chunk;\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tu64 chunk_type;\n\tbool retried = false;\n\tint failed = 0;\n\tint ret;\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\nagain:\n\tkey.objectid = BTRFS_FIRST_CHUNK_TREE_OBJECTID;\n\tkey.offset = (u64)-1;\n\tkey.type = BTRFS_CHUNK_ITEM_KEY;\n\twhile (1) {\n\t\tmutex_lock(&fs_info->delete_unused_bgs_mutex);\n\t\tret = btrfs_search_slot(NULL, chunk_root, &key, path, 0, 0);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&fs_info->delete_unused_bgs_mutex);\n\t\t\tgoto error;\n\t\t}\n\t\tBUG_ON(ret == 0); \n\t\tret = btrfs_previous_item(chunk_root, path, key.objectid,\n\t\t\t\t\t  key.type);\n\t\tif (ret)\n\t\t\tmutex_unlock(&fs_info->delete_unused_bgs_mutex);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tif (ret > 0)\n\t\t\tbreak;\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &found_key, path->slots[0]);\n\t\tchunk = btrfs_item_ptr(leaf, path->slots[0],\n\t\t\t\t       struct btrfs_chunk);\n\t\tchunk_type = btrfs_chunk_type(leaf, chunk);\n\t\tbtrfs_release_path(path);\n\t\tif (chunk_type & BTRFS_BLOCK_GROUP_SYSTEM) {\n\t\t\tret = btrfs_relocate_chunk(fs_info, found_key.offset);\n\t\t\tif (ret == -ENOSPC)\n\t\t\t\tfailed++;\n\t\t\telse\n\t\t\t\tBUG_ON(ret);\n\t\t}\n\t\tmutex_unlock(&fs_info->delete_unused_bgs_mutex);\n\t\tif (found_key.offset == 0)\n\t\t\tbreak;\n\t\tkey.offset = found_key.offset - 1;\n\t}\n\tret = 0;\n\tif (failed && !retried) {\n\t\tfailed = 0;\n\t\tretried = true;\n\t\tgoto again;\n\t} else if (WARN_ON(failed && retried)) {\n\t\tret = -ENOSPC;\n\t}\nerror:\n\tbtrfs_free_path(path);\n\treturn ret;\n}", "target": 0}
{"code": "static void free_recv_msg(struct ipmi_recv_msg *msg)\n{\n\tatomic_dec(&recv_msg_inuse_count);\n\tkfree(msg);\n}", "target": 0}
{"code": "static ssize_t usbnet_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n{\n    USBNetState *s = qemu_get_nic_opaque(nc);\n    uint8_t *in_buf = s->in_buf;\n    size_t total_size = size;\n    if (!s->dev.config) {\n        return -1;\n    }\n    if (is_rndis(s)) {\n        if (s->rndis_state != RNDIS_DATA_INITIALIZED) {\n            return -1;\n        }\n        total_size += sizeof(struct rndis_packet_msg_type);\n    }\n    if (total_size > sizeof(s->in_buf)) {\n        return -1;\n    }\n    if (s->in_len > 0) {\n        return 0;\n    }\n    if (is_rndis(s)) {\n        struct rndis_packet_msg_type *msg;\n        msg = (struct rndis_packet_msg_type *)in_buf;\n        memset(msg, 0, sizeof(struct rndis_packet_msg_type));\n        msg->MessageType = cpu_to_le32(RNDIS_PACKET_MSG);\n        msg->MessageLength = cpu_to_le32(size + sizeof(*msg));\n        msg->DataOffset = cpu_to_le32(sizeof(*msg) - 8);\n        msg->DataLength = cpu_to_le32(size);\n        in_buf += sizeof(*msg);\n    }\n    memcpy(in_buf, buf, size);\n    s->in_len = total_size;\n    s->in_ptr = 0;\n    return size;\n}", "target": 0}
{"code": "RGWOp *RGWHandler_REST_Service_S3::op_head()\n{\n  return new RGWListBuckets_ObjStore_S3;\n}", "target": 0}
{"code": "static int soft_offline_in_use_page(struct page *page, int flags)\n{\n\tint ret;\n\tstruct page *hpage = compound_head(page);\n\tif (!PageHuge(page) && PageTransHuge(hpage)) {\n\t\tlock_page(hpage);\n\t\tif (!PageAnon(hpage) || unlikely(split_huge_page(hpage))) {\n\t\t\tunlock_page(hpage);\n\t\t\tif (!PageAnon(hpage))\n\t\t\t\tpr_info(\"soft offline: %#lx: non anonymous thp\\n\", page_to_pfn(page));\n\t\t\telse\n\t\t\t\tpr_info(\"soft offline: %#lx: thp split failed\\n\", page_to_pfn(page));\n\t\t\tput_hwpoison_page(hpage);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tunlock_page(hpage);\n\t\tget_hwpoison_page(page);\n\t\tput_hwpoison_page(hpage);\n\t}\n\tif (PageHuge(page))\n\t\tret = soft_offline_huge_page(page, flags);\n\telse\n\t\tret = __soft_offline_page(page, flags);\n\treturn ret;\n}", "target": 0}
{"code": "void IDNSpoofChecker::RestoreTopDomainGraphToDefault() {\n  g_graph = kDafsa;\n  g_graph_length = sizeof(kDafsa);\n}", "target": 0}
{"code": "mono_dllmap_insert (MonoImage *assembly, const char *dll, const char *func, const char *tdll, const char *tfunc)\n{\n\tMonoDllMap *entry;\n\tmono_loader_init ();\n\tmono_loader_lock ();\n\tif (!assembly) {\n\t\tentry = g_malloc0 (sizeof (MonoDllMap));\n\t\tentry->dll = dll? g_strdup (dll): NULL;\n\t\tentry->target = tdll? g_strdup (tdll): NULL;\n\t\tentry->func = func? g_strdup (func): NULL;\n\t\tentry->target_func = tfunc? g_strdup (tfunc): NULL;\n\t\tentry->next = global_dll_map;\n\t\tglobal_dll_map = entry;\n\t} else {\n\t\tentry = mono_image_alloc0 (assembly, sizeof (MonoDllMap));\n\t\tentry->dll = dll? mono_image_strdup (assembly, dll): NULL;\n\t\tentry->target = tdll? mono_image_strdup (assembly, tdll): NULL;\n\t\tentry->func = func? mono_image_strdup (assembly, func): NULL;\n\t\tentry->target_func = tfunc? mono_image_strdup (assembly, tfunc): NULL;\n\t\tentry->next = assembly->dll_map;\n\t\tassembly->dll_map = entry;\n\t}\n\tmono_loader_unlock ();\n}", "target": 0}
{"code": "connection_dirserv_flushed_some(dir_connection_t *conn)\n{\n  tor_assert(conn->base_.state == DIR_CONN_STATE_SERVER_WRITING);\n  if (connection_get_outbuf_len(TO_CONN(conn)) >= DIRSERV_BUFFER_MIN)\n    return 0;\n  switch (conn->dir_spool_src) {\n    case DIR_SPOOL_EXTRA_BY_DIGEST:\n    case DIR_SPOOL_EXTRA_BY_FP:\n    case DIR_SPOOL_SERVER_BY_DIGEST:\n    case DIR_SPOOL_SERVER_BY_FP:\n      return connection_dirserv_add_servers_to_outbuf(conn);\n    case DIR_SPOOL_MICRODESC:\n      return connection_dirserv_add_microdescs_to_outbuf(conn);\n    case DIR_SPOOL_CACHED_DIR:\n      return connection_dirserv_add_dir_bytes_to_outbuf(conn);\n    case DIR_SPOOL_NETWORKSTATUS:\n      return connection_dirserv_add_networkstatus_bytes_to_outbuf(conn);\n    case DIR_SPOOL_NONE:\n    default:\n      return 0;\n  }\n}", "target": 0}
{"code": "static size_t item_make_header(const uint8_t nkey, const unsigned int flags, const int nbytes,\n                     char *suffix, uint8_t *nsuffix) {\n    if (settings.inline_ascii_response) {\n        *nsuffix = (uint8_t) snprintf(suffix, 40, \" %u %d\\r\\n\", flags, nbytes - 2);\n    } else {\n        *nsuffix = sizeof(flags);\n    }\n    return sizeof(item) + nkey + *nsuffix + nbytes;\n}", "target": 0}
{"code": "static uint16_t player_settings_changed(struct avrcp_player *player,\n\t\t\t\t\t\tstruct avrcp_header *pdu)\n{\n\tGList *settings = player_list_settings(player);\n\tint size = 2;\n\tfor (; settings; settings = settings->next) {\n\t\tconst char *key = settings->data;\n\t\tint attr;\n\t\tint val;\n\t\tattr = attr_to_val(key);\n\t\tif (attr < 0)\n\t\t\tcontinue;\n\t\tval = player_get_setting(player, attr);\n\t\tif (val < 0)\n\t\t\tcontinue;\n\t\tpdu->params[size++] = attr;\n\t\tpdu->params[size++] = val;\n\t}\n\tg_list_free(settings);\n\tpdu->params[1] = (size - 2) >> 1;\n\treturn size;\n}", "target": 0}
{"code": "static int net_param_nic(void *dummy, QemuOpts *opts, Error **errp)\n{\n    char *mac, *nd_id;\n    int idx, ret;\n    NICInfo *ni;\n    const char *type;\n    type = qemu_opt_get(opts, \"type\");\n    if (type && g_str_equal(type, \"none\")) {\n        return 0;    \n    }\n    idx = nic_get_free_idx();\n    if (idx == -1 || nb_nics >= MAX_NICS) {\n        error_setg(errp, \"no more on-board/default NIC slots available\");\n        return -1;\n    }\n    if (!type) {\n        qemu_opt_set(opts, \"type\", \"user\", &error_abort);\n    }\n    ni = &nd_table[idx];\n    memset(ni, 0, sizeof(*ni));\n    ni->model = qemu_opt_get_del(opts, \"model\");\n    nd_id = g_strdup(qemu_opts_id(opts));\n    if (!nd_id) {\n        nd_id = g_strdup_printf(\"__org.qemu.nic%i\\n\", idx);\n        qemu_opts_set_id(opts, nd_id);\n    }\n    mac = qemu_opt_get_del(opts, \"mac\");\n    if (mac) {\n        ret = net_parse_macaddr(ni->macaddr.a, mac);\n        g_free(mac);\n        if (ret) {\n            error_setg(errp, \"invalid syntax for ethernet address\");\n            goto out;\n        }\n        if (is_multicast_ether_addr(ni->macaddr.a)) {\n            error_setg(errp, \"NIC cannot have multicast MAC address\");\n            ret = -1;\n            goto out;\n        }\n    }\n    qemu_macaddr_default_if_unset(&ni->macaddr);\n    ret = net_client_init(opts, true, errp);\n    if (ret == 0) {\n        ni->netdev = qemu_find_netdev(nd_id);\n        ni->used = true;\n        nb_nics++;\n    }\nout:\n    g_free(nd_id);\n    return ret;\n}", "target": 0}
{"code": "yang_free_inout(struct ly_ctx *ctx, struct lys_node_inout *inout)\n{\n    uint8_t i;\n    yang_tpdf_free(ctx, inout->tpdf, 0, inout->tpdf_size);\n    free(inout->tpdf);\n    for (i = 0; i < inout->must_size; ++i) {\n        lys_restr_free(ctx, &inout->must[i], NULL);\n    }\n    free(inout->must);\n}", "target": 0}
{"code": "void ChildProcessSecurityPolicyImpl::RegisterWebSafeScheme(\n    const std::string& scheme) {\n  base::AutoLock lock(lock_);\n  DCHECK(web_safe_schemes_.count(scheme) == 0) << \"Add schemes at most once.\";\n  DCHECK(pseudo_schemes_.count(scheme) == 0) << \"Web-safe implies not pseudo.\";\n  web_safe_schemes_.insert(scheme);\n}", "target": 0}
{"code": "GF_Box *jp2h_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_J2KHeaderBox, GF_ISOM_BOX_TYPE_JP2H);\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "static int get_task_ioprio(struct task_struct *p)\n{\n\tint ret;\n\tret = security_task_getioprio(p);\n\tif (ret)\n\t\tgoto out;\n\tret = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_NONE, IOPRIO_NORM);\n\ttask_lock(p);\n\tif (p->io_context)\n\t\tret = p->io_context->ioprio;\n\ttask_unlock(p);\nout:\n\treturn ret;\n}", "target": 0}
{"code": "static int coroutine_fn v9fs_complete_rename(V9fsPDU *pdu, V9fsFidState *fidp,\n                                             int32_t newdirfid,\n                                             V9fsString *name)\n{\n    int err = 0;\n    V9fsPath new_path;\n    V9fsFidState *tfidp;\n    V9fsState *s = pdu->s;\n    V9fsFidState *dirfidp = NULL;\n    v9fs_path_init(&new_path);\n    if (newdirfid != -1) {\n        dirfidp = get_fid(pdu, newdirfid);\n        if (dirfidp == NULL) {\n            return -ENOENT;\n        }\n        if (fidp->fid_type != P9_FID_NONE) {\n            err = -EINVAL;\n            goto out;\n        }\n        err = v9fs_co_name_to_path(pdu, &dirfidp->path, name->data, &new_path);\n        if (err < 0) {\n            goto out;\n        }\n    } else {\n        char *dir_name = g_path_get_dirname(fidp->path.data);\n        V9fsPath dir_path;\n        v9fs_path_init(&dir_path);\n        v9fs_path_sprintf(&dir_path, \"%s\", dir_name);\n        g_free(dir_name);\n        err = v9fs_co_name_to_path(pdu, &dir_path, name->data, &new_path);\n        v9fs_path_free(&dir_path);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    err = v9fs_co_rename(pdu, &fidp->path, &new_path);\n    if (err < 0) {\n        goto out;\n    }\n    for (tfidp = s->fid_list; tfidp; tfidp = tfidp->next) {\n        if (v9fs_path_is_ancestor(&fidp->path, &tfidp->path)) {\n            v9fs_fix_path(&tfidp->path, &new_path, strlen(fidp->path.data));\n        }\n    }\nout:\n    if (dirfidp) {\n        put_fid(pdu, dirfidp);\n    }\n    v9fs_path_free(&new_path);\n    return err;\n}", "target": 0}
{"code": "EXPORTED void keepalive_response(struct transaction_t *txn)\n{\n    if (gotsigalrm) {\n        response_header(HTTP_PROCESSING, txn);\n    }\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::OnImeCompositionRangeChanged(\n    const gfx::Range& range,\n    const std::vector<gfx::Rect>& character_bounds) {\n  if (view_)\n    view_->ImeCompositionRangeChanged(range, character_bounds);\n}", "target": 0}
{"code": "static int unmount_fuse_locked(const char *mnt, int quiet, int lazy)\n{\n\tint res;\n\tchar *copy;\n\tconst char *last;\n\tint umount_flags = lazy ? UMOUNT_DETACH : 0;\n\tif (getuid() != 0) {\n\t\tres = may_unmount(mnt, quiet);\n\t\tif (res == -1)\n\t\t\treturn -1;\n\t}\n\tcopy = strdup(mnt);\n\tif (copy == NULL) {\n\t\tfprintf(stderr, \"%s: failed to allocate memory\\n\", progname);\n\t\treturn -1;\n\t}\n\tres = chdir_to_parent(copy, &last);\n\tif (res == -1)\n\t\tgoto out;\n\tif (umount_nofollow_support()) {\n\t\tumount_flags |= UMOUNT_NOFOLLOW;\n\t} else {\n\t\tres = check_is_mount(last, mnt);\n\t\tif (res == -1)\n\t\t\tgoto out;\n\t}\n\tres = umount2(last, umount_flags);\n\tif (res == -1 && !quiet) {\n\t\tfprintf(stderr, \"%s: failed to unmount %s: %s\\n\",\n\t\t\tprogname, mnt, strerror(errno));\n\t}\nout:\n\tif (res == -1)\n\t\treturn -1;\n\tres = chdir(\"/\");\n\tif (res == -1) {\n\t\tfprintf(stderr, \"%s: failed to chdir to '/'\\n\", progname);\n\t\treturn -1;\n\t}\n\treturn fuse_mnt_remove_mount(progname, mnt);\n}", "target": 0}
{"code": "static int cac_parse_aid(sc_card_t *card, cac_private_data_t *priv, u8 *aid, int aid_len)\n{\n\tcac_object_t new_object;\n\tcac_properties_t prop;\n\tsize_t i;\n\tint r;\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tif (aid_len != 7 || (memcmp(aid, CAC_1_RID \"\\x01\", 6) != 0\n\t    && memcmp(aid, CAC_1_RID \"\\x00\", 6) != 0))\n\t\treturn SC_SUCCESS;\n\tsc_mem_clear(&new_object.path, sizeof(sc_path_t));\n\tmemcpy(new_object.path.aid.value, aid, aid_len);\n\tnew_object.path.aid.len = aid_len;\n\tcac_select_file_by_type(card, &new_object.path, NULL, SC_CARD_TYPE_CAC_II);\n\tr = cac_get_properties(card, &prop);\n\tif (r < 0)\n\t\treturn SC_ERROR_INTERNAL;\n\tfor (i = 0; i < prop.num_objects; i++) {\n\t\tif (priv->cert_next >= MAX_CAC_SLOTS)\n\t\t\treturn SC_SUCCESS;\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t    \"ACA: pki_object found, cert_next=%d (%s), privkey=%d\",\n\t\t    priv->cert_next, cac_labels[priv->cert_next],\n\t\t    prop.objects[i].privatekey);\n\t\tif (!prop.objects[i].privatekey) {\n\t\t\tpriv->cert_next++;\n\t\t\tcontinue;\n\t\t}\n\t\tmemcpy(new_object.path.value, &prop.objects[i].oid, 2);\n\t\tnew_object.path.len = 2;\n\t\tnew_object.path.type = SC_PATH_TYPE_FILE_ID;\n\t\tnew_object.name = cac_labels[priv->cert_next];\n\t\tnew_object.fd = priv->cert_next+1;\n\t\tcac_add_object_to_list(&priv->pki_list, &new_object);\n\t\tpriv->cert_next++;\n\t}\n\treturn SC_SUCCESS;\n}", "target": 0}
{"code": "ff_rm_retrieve_cache (AVFormatContext *s, AVIOContext *pb,\n                      AVStream *st, RMStream *ast, AVPacket *pkt)\n{\n    RMDemuxContext *rm = s->priv_data;\n    av_assert0 (rm->audio_pkt_cnt > 0);\n    if (ast->deint_id == DEINT_ID_VBRF ||\n        ast->deint_id == DEINT_ID_VBRS) {\n        int ret = av_get_packet(pb, pkt, ast->sub_packet_lengths[ast->sub_packet_cnt - rm->audio_pkt_cnt]);\n        if (ret < 0)\n            return ret;\n    } else {\n        int ret = av_new_packet(pkt, st->codecpar->block_align);\n        if (ret < 0)\n            return ret;\n        memcpy(pkt->data, ast->pkt.data + st->codecpar->block_align * \n               (ast->sub_packet_h * ast->audio_framesize / st->codecpar->block_align - rm->audio_pkt_cnt),\n               st->codecpar->block_align);\n    }\n    rm->audio_pkt_cnt--;\n    if ((pkt->pts = ast->audiotimestamp) != AV_NOPTS_VALUE) {\n        ast->audiotimestamp = AV_NOPTS_VALUE;\n        pkt->flags = AV_PKT_FLAG_KEY;\n    } else\n        pkt->flags = 0;\n    pkt->stream_index = st->index;\n    return rm->audio_pkt_cnt;\n}", "target": 0}
{"code": "static int vmx_check_nested_events(struct kvm_vcpu *vcpu, bool external_intr)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tif (nested_cpu_has_preemption_timer(get_vmcs12(vcpu)) &&\n\t    vmx->nested.preemption_timer_expired) {\n\t\tif (vmx->nested.nested_run_pending)\n\t\t\treturn -EBUSY;\n\t\tnested_vmx_vmexit(vcpu, EXIT_REASON_PREEMPTION_TIMER, 0, 0);\n\t\treturn 0;\n\t}\n\tif (vcpu->arch.nmi_pending && nested_exit_on_nmi(vcpu)) {\n\t\tif (vmx->nested.nested_run_pending ||\n\t\t    vcpu->arch.interrupt.pending)\n\t\t\treturn -EBUSY;\n\t\tnested_vmx_vmexit(vcpu, EXIT_REASON_EXCEPTION_NMI,\n\t\t\t\t  NMI_VECTOR | INTR_TYPE_NMI_INTR |\n\t\t\t\t  INTR_INFO_VALID_MASK, 0);\n\t\tvcpu->arch.nmi_pending = 0;\n\t\tvmx_set_nmi_mask(vcpu, true);\n\t\treturn 0;\n\t}\n\tif ((kvm_cpu_has_interrupt(vcpu) || external_intr) &&\n\t    nested_exit_on_intr(vcpu)) {\n\t\tif (vmx->nested.nested_run_pending)\n\t\t\treturn -EBUSY;\n\t\tnested_vmx_vmexit(vcpu, EXIT_REASON_EXTERNAL_INTERRUPT, 0, 0);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int ssl_security_cert_key(SSL *s, SSL_CTX *ctx, X509 *x, int op)\n\t{\n\tint secbits;\n\tEVP_PKEY *pkey = X509_get_pubkey(x);\n\tif (pkey)\n\t\t{\n\t\tsecbits = EVP_PKEY_security_bits(pkey);\n\t\tEVP_PKEY_free(pkey);\n\t\t}\n\telse\n\t\tsecbits = -1;\n\tif (s)\n\t\treturn ssl_security(s, op, secbits, 0, x);\n\telse\n\t\treturn ssl_ctx_security(ctx, op, secbits, 0, x);\n\t}", "target": 0}
{"code": "void RenderWidgetHostImpl::OnAutoscrollFling(const gfx::Vector2dF& velocity) {\n  WebGestureEvent event = SyntheticWebGestureEventBuilder::Build(\n      WebInputEvent::kGestureFlingStart,\n      blink::kWebGestureDeviceSyntheticAutoscroll);\n  event.data.fling_start.velocity_x = velocity.x();\n  event.data.fling_start.velocity_y = velocity.y();\n  event.source_device = blink::kWebGestureDeviceSyntheticAutoscroll;\n  input_router_->SendGestureEvent(GestureEventWithLatencyInfo(event));\n}", "target": 0}
{"code": "static int zipfileCommit(sqlite3_vtab *pVtab){\n  ZipfileTab *pTab = (ZipfileTab*)pVtab;\n  int rc = SQLITE_OK;\n  if( pTab->pWriteFd ){\n    i64 iOffset = pTab->szCurrent;\n    ZipfileEntry *p;\n    ZipfileEOCD eocd;\n    int nEntry = 0;\n    for(p=pTab->pFirstEntry; rc==SQLITE_OK && p; p=p->pNext){\n      int n = zipfileSerializeCDS(p, pTab->aBuffer);\n      rc = zipfileAppendData(pTab, pTab->aBuffer, n);\n      nEntry++;\n    }\n    eocd.iDisk = 0;\n    eocd.iFirstDisk = 0;\n    eocd.nEntry = (u16)nEntry;\n    eocd.nEntryTotal = (u16)nEntry;\n    eocd.nSize = (u32)(pTab->szCurrent - iOffset);\n    eocd.iOffset = (u32)iOffset;\n    rc = zipfileAppendEOCD(pTab, &eocd);\n    zipfileCleanupTransaction(pTab);\n  }\n  return rc;\n}", "target": 0}
{"code": "static int kiss_esc(unsigned char *s, unsigned char *d, int len)\n{\n\tunsigned char *ptr = d;\n\tunsigned char c;\n\t*ptr++ = END;\n\twhile (len-- > 0) {\n\t\tswitch (c = *s++) {\n\t\tcase END:\n\t\t\t*ptr++ = ESC;\n\t\t\t*ptr++ = ESC_END;\n\t\t\tbreak;\n\t\tcase ESC:\n\t\t\t*ptr++ = ESC;\n\t\t\t*ptr++ = ESC_ESC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*ptr++ = c;\n\t\t\tbreak;\n\t\t}\n\t}\n\t*ptr++ = END;\n\treturn ptr - d;\n}", "target": 0}
{"code": "int HttpStreamParser::DoReadHeaders() {\n  io_state_ = STATE_READ_HEADERS_COMPLETE;\n  if (read_buf_->RemainingCapacity() == 0)\n    read_buf_->SetCapacity(read_buf_->capacity() + kHeaderBufInitialSize);\n  CHECK(read_buf_->data());\n  return connection_->socket()->Read(read_buf_,\n                                     read_buf_->RemainingCapacity(),\n                                     io_callback_);\n}", "target": 0}
{"code": "    long ul2Data(byte* buf, uint32_t l, ByteOrder byteOrder)\n    {\n        if (byteOrder == littleEndian) {\n            buf[0] = (byte) (l & 0x000000ff);\n            buf[1] = (byte)((l & 0x0000ff00) >> 8);\n            buf[2] = (byte)((l & 0x00ff0000) >> 16);\n            buf[3] = (byte)((l & 0xff000000) >> 24);\n        }\n        else {\n            buf[0] = (byte)((l & 0xff000000) >> 24);\n            buf[1] = (byte)((l & 0x00ff0000) >> 16);\n            buf[2] = (byte)((l & 0x0000ff00) >> 8);\n            buf[3] = (byte) (l & 0x000000ff);\n        }\n        return 4;\n    }", "target": 0}
{"code": "static inline unsigned int init_tid(int cpu)\n{\n\treturn cpu;\n}", "target": 0}
{"code": "OPEN_TABLE_LIST *list_open_tables(THD *thd, const char *db, const char *wild)\n{\n  list_open_tables_arg argument;\n  DBUG_ENTER(\"list_open_tables\");\n  argument.thd= thd;\n  argument.db= db;\n  argument.wild= wild;\n  bzero((char*) &argument.table_list, sizeof(argument.table_list));\n  argument.start_list= &argument.open_list;\n  argument.open_list= 0;\n  if (tdc_iterate(thd, (my_hash_walk_action) list_open_tables_callback,\n                  &argument, true))\n    DBUG_RETURN(0);\n  DBUG_RETURN(argument.open_list);\n}", "target": 0}
{"code": "  JwtLocationBase(const std::string& token, const absl::node_hash_set<std::string>& issuers)\n      : token_(token), specified_issuers_(issuers) {}", "target": 0}
{"code": "uint32_t PDFiumEngine::QuerySupportedPrintOutputFormats() {\n  if (!HasPermission(PDFEngine::PERMISSION_PRINT_LOW_QUALITY))\n    return 0;\n  return PP_PRINTOUTPUTFORMAT_PDF;\n}", "target": 0}
{"code": "void put_mnt_ns(struct mnt_namespace *ns)\n{\n\tif (!atomic_dec_and_test(&ns->count))\n\t\treturn;\n\tdrop_collected_mounts(&ns->root->mnt);\n\tfree_mnt_ns(ns);\n}", "target": 0}
{"code": "void IndexedDBDatabase::VersionChangeIgnored() {\n  if (active_request_)\n    active_request_->OnVersionChangeIgnored();\n}", "target": 0}
{"code": "add_document_portal_args (FlatpakBwrap *bwrap,\n                          const char   *app_id,\n                          char        **out_mount_path)\n{\n  g_autoptr(GDBusConnection) session_bus = NULL;\n  g_autofree char *doc_mount_path = NULL;\n  session_bus = g_bus_get_sync (G_BUS_TYPE_SESSION, NULL, NULL);\n  if (session_bus)\n    {\n      g_autoptr(GError) local_error = NULL;\n      g_autoptr(GDBusMessage) reply = NULL;\n      g_autoptr(GDBusMessage) msg =\n        g_dbus_message_new_method_call (\"org.freedesktop.portal.Documents\",\n                                        \"/org/freedesktop/portal/documents\",\n                                        \"org.freedesktop.portal.Documents\",\n                                        \"GetMountPoint\");\n      g_dbus_message_set_body (msg, g_variant_new (\"()\"));\n      reply =\n        g_dbus_connection_send_message_with_reply_sync (session_bus, msg,\n                                                        G_DBUS_SEND_MESSAGE_FLAGS_NONE,\n                                                        30000,\n                                                        NULL,\n                                                        NULL,\n                                                        NULL);\n      if (reply)\n        {\n          if (g_dbus_message_to_gerror (reply, &local_error))\n            {\n              if (g_error_matches (local_error, G_DBUS_ERROR, G_DBUS_ERROR_SERVICE_UNKNOWN))\n                g_debug (\"Document portal not available, not mounting /run/flatpak/doc\");\n              else\n                g_message (\"Can't get document portal: %s\", local_error->message);\n            }\n          else\n            {\n              static const char dst_path[] = \"/run/flatpak/doc\";\n              g_autofree char *src_path = NULL;\n              g_variant_get (g_dbus_message_get_body (reply),\n                             \"(^ay)\", &doc_mount_path);\n              src_path = g_strdup_printf (\"%s/by-app/%s\",\n                                          doc_mount_path, app_id);\n              flatpak_bwrap_add_args (bwrap, \"--bind\", src_path, dst_path, NULL);\n              flatpak_bwrap_add_runtime_dir_member (bwrap, \"doc\");\n            }\n        }\n    }\n  *out_mount_path = g_steal_pointer (&doc_mount_path);\n}", "target": 0}
{"code": "static inline void perf_read_regs(struct pt_regs *regs)\n{\n\tregs->dsisr = mfspr(SPRN_MMCRA);\n}", "target": 0}
{"code": "void OverlayWindowViews::UpdateLayerBoundsWithLetterboxing(\n    gfx::Size window_size) {\n  if (window_bounds_.size().IsEmpty() || natural_size_.IsEmpty())\n    return;\n  gfx::Rect letterbox_region = media::ComputeLetterboxRegion(\n      gfx::Rect(gfx::Point(0, 0), window_size), natural_size_);\n  if (letterbox_region.IsEmpty())\n    return;\n  gfx::Size letterbox_size = letterbox_region.size();\n  gfx::Point origin =\n      gfx::Point((window_size.width() - letterbox_size.width()) / 2,\n                 (window_size.height() - letterbox_size.height()) / 2);\n  video_bounds_.set_origin(origin);\n  video_bounds_.set_size(letterbox_region.size());\n  UpdateControlsBounds();\n  controller_->UpdateLayerBounds();\n}", "target": 0}
{"code": "static int nf_tables_fill_setelem(struct sk_buff *skb,\n\t\t\t\t  const struct nft_set *set,\n\t\t\t\t  const struct nft_set_elem *elem)\n{\n\tunsigned char *b = skb_tail_pointer(skb);\n\tstruct nlattr *nest;\n\tnest = nla_nest_start(skb, NFTA_LIST_ELEM);\n\tif (nest == NULL)\n\t\tgoto nla_put_failure;\n\tif (nft_data_dump(skb, NFTA_SET_ELEM_KEY, &elem->key, NFT_DATA_VALUE,\n\t\t\t  set->klen) < 0)\n\t\tgoto nla_put_failure;\n\tif (set->flags & NFT_SET_MAP &&\n\t    !(elem->flags & NFT_SET_ELEM_INTERVAL_END) &&\n\t    nft_data_dump(skb, NFTA_SET_ELEM_DATA, &elem->data,\n\t\t\t  set->dtype == NFT_DATA_VERDICT ? NFT_DATA_VERDICT : NFT_DATA_VALUE,\n\t\t\t  set->dlen) < 0)\n\t\tgoto nla_put_failure;\n\tif (elem->flags != 0)\n\t\tif (nla_put_be32(skb, NFTA_SET_ELEM_FLAGS, htonl(elem->flags)))\n\t\t\tgoto nla_put_failure;\n\tnla_nest_end(skb, nest);\n\treturn 0;\nnla_put_failure:\n\tnlmsg_trim(skb, b);\n\treturn -EMSGSIZE;\n}", "target": 0}
{"code": "static void ldapsrv_call_writev_start(struct ldapsrv_call *call)\n{\n\tstruct ldapsrv_connection *conn = call->conn;\n\tstruct ldapsrv_reply *reply = NULL;\n\tstruct tevent_req *subreq = NULL;\n\tsize_t length = 0;\n\tsize_t i;\n\tcall->iov_count = 0;\n\tfor (reply = call->replies;\n\t     reply != NULL;\n\t     reply = reply->next) {\n\t\tif (length > length + reply->blob.length\n\t\t    || length + reply->blob.length > LDAP_SERVER_MAX_CHUNK_SIZE) {\n\t\t\tbreak;\n\t\t}\n\t\tlength += reply->blob.length;\n\t\tcall->iov_count++;\n\t}\n\tif (length == 0) {\n\t\tif (!call->notification.busy) {\n\t\t\tTALLOC_FREE(call);\n\t\t}\n\t\tldapsrv_call_read_next(conn);\n\t\treturn;\n\t}\n\tcall->iov_count = MIN(call->iov_count, IOV_MAX);\n\tcall->out_iov = talloc_array(call,\n\t\t\t\t     struct iovec,\n\t\t\t\t     call->iov_count);\n\tif (!call->out_iov) {\n\t\tldapsrv_terminate_connection(conn,\n\t\t\t\t\t     \"failed to allocate \"\n\t\t\t\t\t     \"iovec array\");\n\t\treturn;\n\t}\n\tfor (i = 0;\n\t     i < call->iov_count && call->replies != NULL;\n\t     i++) {\n\t\treply = call->replies;\n\t\tcall->out_iov[i].iov_base = reply->blob.data;\n\t\tcall->out_iov[i].iov_len = reply->blob.length;\n\t\ttalloc_steal(call->out_iov, reply->blob.data);\n\t\tDLIST_REMOVE(call->replies, reply);\n\t\tTALLOC_FREE(reply);\n\t}\n\tif (i > call->iov_count) {\n\t\tldapsrv_terminate_connection(conn,\n\t\t\t\t\t     \"call list ended\"\n\t\t\t\t\t     \"before iov_count\");\n\t\treturn;\n\t}\n\tsubreq = tstream_writev_queue_send(call,\n\t\t\t\t\t   conn->connection->event.ctx,\n\t\t\t\t\t   conn->sockets.active,\n\t\t\t\t\t   conn->sockets.send_queue,\n\t\t\t\t\t   call->out_iov, call->iov_count);\n\tif (subreq == NULL) {\n\t\tldapsrv_terminate_connection(conn, \"stream_writev_queue_send failed\");\n\t\treturn;\n\t}\n\ttevent_req_set_callback(subreq, ldapsrv_call_writev_done, call);\n}", "target": 0}
{"code": "void *idr_get_next(struct idr *idp, int *nextidp)\n{\n\tstruct idr_layer *p, *pa[MAX_LEVEL];\n\tstruct idr_layer **paa = &pa[0];\n\tint id = *nextidp;\n\tint n, max;\n\tn = idp->layers * IDR_BITS;\n\tmax = 1 << n;\n\tp = rcu_dereference(idp->top);\n\tif (!p)\n\t\treturn NULL;\n\twhile (id < max) {\n\t\twhile (n > 0 && p) {\n\t\t\tn -= IDR_BITS;\n\t\t\t*paa++ = p;\n\t\t\tp = rcu_dereference(p->ary[(id >> n) & IDR_MASK]);\n\t\t}\n\t\tif (p) {\n\t\t\t*nextidp = id;\n\t\t\treturn p;\n\t\t}\n\t\tid += 1 << n;\n\t\twhile (n < fls(id)) {\n\t\t\tn += IDR_BITS;\n\t\t\tp = *--paa;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "xfs_release(\n\txfs_inode_t\t*ip)\n{\n\txfs_mount_t\t*mp = ip->i_mount;\n\tint\t\terror;\n\tif (!S_ISREG(VFS_I(ip)->i_mode) || (VFS_I(ip)->i_mode == 0))\n\t\treturn 0;\n\tif (mp->m_flags & XFS_MOUNT_RDONLY)\n\t\treturn 0;\n\tif (!XFS_FORCED_SHUTDOWN(mp)) {\n\t\tint truncated;\n\t\ttruncated = xfs_iflags_test_and_clear(ip, XFS_ITRUNCATED);\n\t\tif (truncated) {\n\t\t\txfs_iflags_clear(ip, XFS_IDIRTY_RELEASE);\n\t\t\tif (ip->i_delayed_blks > 0) {\n\t\t\t\terror = filemap_flush(VFS_I(ip)->i_mapping);\n\t\t\t\tif (error)\n\t\t\t\t\treturn error;\n\t\t\t}\n\t\t}\n\t}\n\tif (VFS_I(ip)->i_nlink == 0)\n\t\treturn 0;\n\tif (xfs_can_free_eofblocks(ip, false)) {\n\t\tif (xfs_iflags_test(ip, XFS_IDIRTY_RELEASE))\n\t\t\treturn 0;\n\t\tif (xfs_ilock_nowait(ip, XFS_IOLOCK_EXCL)) {\n\t\t\terror = xfs_free_eofblocks(ip);\n\t\t\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tif (ip->i_delayed_blks)\n\t\t\txfs_iflags_set(ip, XFS_IDIRTY_RELEASE);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "unsigned long __fdget(unsigned int fd)\n{\n\treturn __fget_light(fd, FMODE_PATH);\n}", "target": 0}
{"code": "process_option(void)\n{\n    char begin_char = '[', end_char = ']';\n    int len;\n    if (cur_select == NULL || cur_option == NULL)\n\treturn;\n    while (cur_option->length > 0 && IS_SPACE(Strlastchar(cur_option)))\n\tStrshrink(cur_option, 1);\n    if (cur_option_value == NULL)\n\tcur_option_value = cur_option;\n    if (cur_option_label == NULL)\n\tcur_option_label = cur_option;\n#ifdef MENU_SELECT\n    if (!select_is_multiple) {\n\tlen = get_Str_strwidth(cur_option_label);\n\tif (len > cur_option_maxwidth)\n\t    cur_option_maxwidth = len;\n\taddSelectOption(&select_option[n_select],\n\t\t\tcur_option_value,\n\t\t\tcur_option_label, cur_option_selected);\n\treturn;\n    }\n#endif\t\t\t\t\n    if (!select_is_multiple) {\n\tbegin_char = '(';\n\tend_char = ')';\n    }\n    Strcat(select_str, Sprintf(\"<br><pre_int>%c<input_alt hseq=\\\"%d\\\" \"\n\t\t\t       \"fid=\\\"%d\\\" type=%s name=\\\"%s\\\" value=\\\"%s\\\"\",\n\t\t\t       begin_char, cur_hseq++, cur_form_id,\n\t\t\t       select_is_multiple ? \"checkbox\" : \"radio\",\n\t\t\t       html_quote(cur_select->ptr),\n\t\t\t       html_quote(cur_option_value->ptr)));\n    if (cur_option_selected)\n\tStrcat_charp(select_str, \" checked>*</input_alt>\");\n    else\n\tStrcat_charp(select_str, \"> </input_alt>\");\n    Strcat_char(select_str, end_char);\n    Strcat_charp(select_str, html_quote(cur_option_label->ptr));\n    Strcat_charp(select_str, \"</pre_int>\");\n    n_selectitem++;\n}", "target": 0}
{"code": "    SpillSTLComparator(ValueComparator valueComparator) : _valueComparator(valueComparator) {}", "target": 0}
{"code": "void CLASS process_Sony_0x940c (uchar * buf)\n{\n  ushort lid2;\n  if (imgdata.lens.makernotes.LensMount != Canon_EF)\n    {\n      switch (SonySubstitution[buf[0x0008]]) {\n      case 1:\n      case 5:\n        imgdata.lens.makernotes.LensMount = Minolta_A;\n        break;\n      case 4:\n        imgdata.lens.makernotes.LensMount = Sony_E;\n        break;\n      }\n    }\n  lid2 = (((ushort)SonySubstitution[buf[0x000a]])<<8) |\n    ((ushort)SonySubstitution[buf[0x0009]]);\n  if ((lid2 > 0) && (lid2 < 32784))\n    parseSonyLensType2 (SonySubstitution[buf[0x000a]],\t\n                        SonySubstitution[buf[0x0009]]);\n  return;\n}", "target": 0}
{"code": "mysql_get_host_info(MYSQL *mysql)\n{\n  return(mysql->host_info);\n}", "target": 0}
{"code": "gs_pattern2_make_pattern(gs_client_color * pcc,\n                         const gs_pattern_template_t * pcp,\n                         const gs_matrix * pmat, gs_gstate * pgs,\n                         gs_memory_t * mem)\n{\n    const gs_pattern2_template_t *ptemp =\n        (const gs_pattern2_template_t *)pcp;\n    int code = gs_make_pattern_common(pcc, pcp, pmat, pgs, mem,\n                                      &st_pattern2_instance);\n    gs_pattern2_instance_t *pinst;\n    if (code < 0)\n        return code;\n    pinst = (gs_pattern2_instance_t *)pcc->pattern;\n    pinst->templat = *ptemp;\n    pinst->shfill = false;\n    return 0;\n}", "target": 0}
{"code": "bool Virtual_tmp_table::init(uint field_count)\n{\n  uint *blob_field;\n  uchar *bitmaps;\n  if (!multi_alloc_root(in_use->mem_root,\n                        &s, sizeof(*s),\n                        &field, (field_count + 1) * sizeof(Field*),\n                        &blob_field, (field_count + 1) * sizeof(uint),\n                        &bitmaps, bitmap_buffer_size(field_count) * 6,\n                        NullS))\n    return true;\n  s->reset();\n  s->blob_field= blob_field;\n  setup_tmp_table_column_bitmaps(this, bitmaps, field_count);\n  m_alloced_field_count= field_count;\n  return false;\n};", "target": 0}
{"code": "onig_end(void)\n{\n  exec_end_call_list();\n#ifdef ONIG_DEBUG_STATISTICS\n  onig_print_statistics(stderr);\n#endif\n#if defined(ONIG_DEBUG_MEMLEAK) && defined(_MSC_VER)\n  _CrtDumpMemoryLeaks();\n#endif\n  onig_inited = 0;\n  return 0;\n}", "target": 0}
{"code": "spnego_gss_compare_name(\n\t\t\tOM_uint32 *minor_status,\n\t\t\tconst gss_name_t name1,\n\t\t\tconst gss_name_t name2,\n\t\t\tint *name_equal)\n{\n\tOM_uint32 status = GSS_S_COMPLETE;\n\tdsyslog(\"Entering compare_name\\n\");\n\tstatus = gss_compare_name(minor_status, name1, name2, name_equal);\n\tdsyslog(\"Leaving compare_name\\n\");\n\treturn (status);\n}", "target": 0}
{"code": "ZEND_API void zend_wrong_param_count(TSRMLS_D) \n{\n\tconst char *space;\n\tconst char *class_name = get_active_class_name(&space TSRMLS_CC);\n\tzend_error(E_WARNING, \"Wrong parameter count for %s%s%s()\", class_name, space, get_active_function_name(TSRMLS_C));\n}", "target": 0}
{"code": "struct dmar_domain *get_valid_domain_for_dev(struct device *dev)\n{\n\tstruct dmar_domain *domain, *tmp;\n\tstruct dmar_rmrr_unit *rmrr;\n\tstruct device *i_dev;\n\tint i, ret;\n\tdomain = find_domain(dev);\n\tif (domain)\n\t\tgoto out;\n\tdomain = find_or_alloc_domain(dev, DEFAULT_DOMAIN_ADDRESS_WIDTH);\n\tif (!domain)\n\t\tgoto out;\n\trcu_read_lock();\n\tfor_each_rmrr_units(rmrr) {\n\t\tfor_each_active_dev_scope(rmrr->devices, rmrr->devices_cnt,\n\t\t\t\t\t  i, i_dev) {\n\t\t\tif (i_dev != dev)\n\t\t\t\tcontinue;\n\t\t\tret = domain_prepare_identity_map(dev, domain,\n\t\t\t\t\t\t\t  rmrr->base_address,\n\t\t\t\t\t\t\t  rmrr->end_address);\n\t\t\tif (ret)\n\t\t\t\tdev_err(dev, \"Mapping reserved region failed\\n\");\n\t\t}\n\t}\n\trcu_read_unlock();\n\ttmp = set_domain_for_dev(dev, domain);\n\tif (!tmp || domain != tmp) {\n\t\tdomain_exit(domain);\n\t\tdomain = tmp;\n\t}\nout:\n\tif (!domain)\n\t\tdev_err(dev, \"Allocating domain failed\\n\");\n\treturn domain;\n}", "target": 0}
{"code": "f_zero_p(VALUE x)\n{\n    switch (TYPE(x)) {\n      case T_FIXNUM:\n\treturn f_boolcast(FIX2LONG(x) == 0);\n      case T_BIGNUM:\n\treturn Qfalse;\n      case T_RATIONAL:\n\t{\n\t    VALUE num = rb_rational_num(x);\n\t    return f_boolcast(FIXNUM_P(num) && FIX2LONG(num) == 0);\n\t}\n    }\n    return rb_funcall(x, id_eqeq_p, 1, INT2FIX(0));\n}", "target": 0}
{"code": "static int snd_ctl_dev_register(struct snd_device *device)\n{\n\tstruct snd_card *card = device->device_data;\n\tint err, cardnum;\n\tchar name[16];\n\tif (snd_BUG_ON(!card))\n\t\treturn -ENXIO;\n\tcardnum = card->number;\n\tif (snd_BUG_ON(cardnum < 0 || cardnum >= SNDRV_CARDS))\n\t\treturn -ENXIO;\n\tsprintf(name, \"controlC%i\", cardnum);\n\tif ((err = snd_register_device(SNDRV_DEVICE_TYPE_CONTROL, card, -1,\n\t\t\t\t       &snd_ctl_f_ops, card, name)) < 0)\n\t\treturn err;\n\treturn 0;\n}", "target": 0}
{"code": "  void addReference(const LowerCaseString& key, absl::string_view value) override {\n    header_map_->addReference(key, value);\n    header_map_->verifyByteSizeInternalForTest();\n  }", "target": 0}
{"code": "v8::Local<v8::Context> ScriptController::currentWorldContext()\n{\n    if (!v8::Context::InContext())\n        return contextForWorld(this, mainThreadNormalWorld());\n    v8::Handle<v8::Context> context = v8::Context::GetEntered();\n    DOMWrapperWorld* isolatedWorld = DOMWrapperWorld::isolatedWorld(context);\n    if (!isolatedWorld)\n        return contextForWorld(this, mainThreadNormalWorld());\n    Frame* frame = toFrameIfNotDetached(context);\n    if (!m_frame)\n        return v8::Local<v8::Context>();\n    if (m_frame == frame)\n        return v8::Local<v8::Context>::New(context);\n    return contextForWorld(this, isolatedWorld);\n}", "target": 0}
{"code": "int afWriteFrames (AFfilehandle file, int trackid, const void *samples,\n\tint nvframes2write)\n{\n\tSharedPtr<Module> firstmod;\n\tSharedPtr<Chunk> userc;\n\t_Track *track;\n\tint bytes_per_vframe;\n\tAFframecount vframe;\n\tif (!_af_filehandle_ok(file))\n\t\treturn -1;\n\tif (!_af_filehandle_can_write(file))\n\t\treturn -1;\n\tif ((track = _af_filehandle_get_track(file, trackid)) == NULL)\n\t\treturn -1;\n\tif (track->ms->isDirty() && track->ms->setup(file, track) == AF_FAIL)\n\t\treturn -1;\n\tif (af_fseek(file->fh, track->fpos_next_frame, SEEK_SET) < 0)\n\t{\n\t\t_af_error(AF_BAD_LSEEK, \"unable to position write pointer at next frame\");\n\t\treturn -1;\n\t}\n\tbytes_per_vframe = _af_format_frame_size(&track->v, true);\n\tfirstmod = track->ms->modules().front();\n\tuserc = track->ms->chunks().front();\n\ttrack->filemodhappy = true;\n\tvframe = 0;\n#ifdef UNLIMITED_CHUNK_NVFRAMES\n\tif (!trk->ms->mustUseAtomicNVFrames())\n\t{\n\t\tuserc->buffer = (char *) samples;\n\t\tuserc->frameCount = nvframes2write;\n\t\tfirstmod->runPush();\n\t\tif (trk->filemodhappy)\n\t\t\tvframe += userc->frameCount;\n\t}\n\telse\n#else\n\tassert(track->ms->mustUseAtomicNVFrames());\n#endif\n\t{\n\t\twhile (vframe < nvframes2write)\n\t\t{\n\t\t\tuserc->buffer = (char *) samples + bytes_per_vframe * vframe;\n\t\t\tif (vframe <= nvframes2write - _AF_ATOMIC_NVFRAMES)\n\t\t\t\tuserc->frameCount = _AF_ATOMIC_NVFRAMES;\n\t\t\telse\n\t\t\t\tuserc->frameCount = nvframes2write - vframe;\n\t\t\tfirstmod->runPush();\n\t\t\tif (!track->filemodhappy)\n\t\t\t\tbreak;\n\t\t\tvframe += userc->frameCount;\n\t\t}\n\t}\n\ttrack->nextvframe += vframe;\n\ttrack->totalvframes += vframe;\n\treturn vframe;\n}", "target": 0}
{"code": "unsigned WebGraphicsContext3DDefaultImpl::createProgram()\n{\n    makeContextCurrent();\n    return glCreateProgram();\n}", "target": 0}
{"code": "long keyctl_instantiate_key_iov(key_serial_t id,\n\t\t\t\tconst struct iovec __user *_payload_iov,\n\t\t\t\tunsigned ioc,\n\t\t\t\tkey_serial_t ringid)\n{\n\tstruct iovec iovstack[UIO_FASTIOV], *iov = iovstack;\n\tstruct iov_iter from;\n\tlong ret;\n\tif (!_payload_iov)\n\t\tioc = 0;\n\tret = import_iovec(WRITE, _payload_iov, ioc,\n\t\t\t\t    ARRAY_SIZE(iovstack), &iov, &from);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = keyctl_instantiate_key_common(id, &from, ringid);\n\tkfree(iov);\n\treturn ret;\n}", "target": 0}
{"code": "static bool valid_mtrr_type(unsigned t)\n{\n\treturn t < 8 && (1 << t) & 0x73; \n}", "target": 0}
{"code": "static int remove_dup_with_compare(THD *thd, TABLE *table, Field **first_field,\n\t\t\t\t   Item *having)\n{\n  handler *file=table->file;\n  uchar *record=table->record[0];\n  int error;\n  DBUG_ENTER(\"remove_dup_with_compare\");\n  if (unlikely(file->ha_rnd_init_with_error(1)))\n    DBUG_RETURN(1);\n  error= file->ha_rnd_next(record);\n  for (;;)\n  {\n    if (unlikely(thd->check_killed()))\n    {\n      error=0;\n      goto err;\n    }\n    if (unlikely(error))\n    {\n      if (error == HA_ERR_END_OF_FILE)\n\tbreak;\n      goto err;\n    }\n    if (having && !having->val_int())\n    {\n      if (unlikely((error= file->ha_delete_row(record))))\n\tgoto err;\n      error= file->ha_rnd_next(record);\n      continue;\n    }\n    if (unlikely(copy_blobs(first_field)))\n    {\n      my_message(ER_OUTOFMEMORY, ER_THD(thd,ER_OUTOFMEMORY),\n                 MYF(ME_FATALERROR));\n      error=0;\n      goto err;\n    }\n    store_record(table,record[1]);\n    bool found=0;\n    for (;;)\n    {\n      if (unlikely((error= file->ha_rnd_next(record))))\n      {\n\tif (error == HA_ERR_END_OF_FILE)\n\t  break;\n\tgoto err;\n      }\n      if (compare_record(table, first_field) == 0)\n      {\n\tif (unlikely((error= file->ha_delete_row(record))))\n\t  goto err;\n      }\n      else if (!found)\n      {\n\tfound=1;\n        if (unlikely((error= file->remember_rnd_pos())))\n          goto err;\n      }\n    }\n    if (!found)\n      break;\t\t\t\t\t\n    if (unlikely((error= file->restart_rnd_next(record))))\n      goto err;\n  }\n  file->extra(HA_EXTRA_NO_CACHE);\n  (void) file->ha_rnd_end();\n  DBUG_RETURN(0);\nerr:\n  file->extra(HA_EXTRA_NO_CACHE);\n  (void) file->ha_rnd_end();\n  if (error)\n    file->print_error(error,MYF(0));\n  DBUG_RETURN(1);\n}", "target": 0}
{"code": "__timespec_to_jiffies(unsigned long sec, long nsec)\n{\n\treturn __timespec64_to_jiffies((u64)sec, nsec);\n}", "target": 0}
{"code": "static size_t php_pgsql_fd_read(php_stream *stream, char *buf, size_t count) \n{\n\treturn 0;\n}", "target": 0}
{"code": "static char *get_ver_flags(ut32 flags) {\n\tstatic char buff[32];\n\tbuff[0] = 0;\n\tif (!flags) {\n\t\treturn \"none\";\n\t}\n\tif (flags & VER_FLG_BASE) {\n\t\tstrcpy (buff, \"BASE \");\n\t}\n\tif (flags & VER_FLG_WEAK) {\n\t\tif (flags & VER_FLG_BASE) {\n\t\t\tstrcat (buff, \"| \");\n\t\t}\n\t\tstrcat (buff, \"WEAK \");\n\t}\n\tif (flags & ~(VER_FLG_BASE | VER_FLG_WEAK)) {\n\t\tstrcat (buff, \"| <unknown>\");\n\t}\n\treturn buff;\n}", "target": 0}
{"code": "Item* Item_ref::compile(Item_analyzer analyzer, uchar **arg_p,\n                        Item_transformer transformer, uchar *arg_t)\n{\n  if (!(this->*analyzer)(arg_p))\n    return NULL;\n  DBUG_ASSERT((*ref) != NULL);\n  if (*arg_p)\n  {\n    uchar *arg_v= *arg_p;\n    Item *new_item= (*ref)->compile(analyzer, &arg_v, transformer, arg_t);\n    if (new_item && *ref != new_item)\n      current_thd->change_item_tree(ref, new_item);\n  }\n  return (this->*transformer)(arg_t);\n}", "target": 0}
{"code": "GF_Err fiin_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tFDItemInformationBox *ptr = (FDItemInformationBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, gf_list_count(ptr->partition_entries) );\n\treturn GF_OK;\n}", "target": 0}
{"code": "  GetPersistentHostQuotaTask(\n      QuotaManager* manager,\n      const std::string& host,\n      HostQuotaCallback* callback)\n      : DatabaseTaskBase(manager),\n        host_(host),\n        quota_(-1),\n        callback_(callback) {\n  }", "target": 0}
{"code": "static int compat_copy_entries(unsigned char *data, unsigned int size_user,\n\t\t\t\tstruct ebt_entries_buf_state *state)\n{\n\tunsigned int size_remaining = size_user;\n\tint ret;\n\tret = EBT_ENTRY_ITERATE(data, size_user, size_entry_mwt, data,\n\t\t\t\t\t&size_remaining, state);\n\tif (ret < 0)\n\t\treturn ret;\n\tWARN_ON(size_remaining);\n\treturn state->buf_kern_offset;\n}", "target": 0}
{"code": "static unsigned int rds_pages_in_vec(struct rds_iovec *vec)\n{\n\tif ((vec->addr + vec->bytes <= vec->addr) ||\n\t    (vec->bytes > (u64)UINT_MAX))\n\t\treturn 0;\n\treturn ((vec->addr + vec->bytes + PAGE_SIZE - 1) >> PAGE_SHIFT) -\n\t\t(vec->addr >> PAGE_SHIFT);\n}", "target": 0}
{"code": "static inline int resolve_named_entity_html(const char *start, size_t length, const entity_ht *ht, unsigned *uni_cp1, unsigned *uni_cp2)\n{\n\tconst entity_cp_map *s;\n\tulong hash = zend_inline_hash_func(start, length);\n\ts = ht->buckets[hash % ht->num_elems];\n\twhile (s->entity) {\n\t\tif (s->entity_len == length) {\n\t\t\tif (memcmp(start, s->entity, length) == 0) {\n\t\t\t\t*uni_cp1 = s->codepoint1;\n\t\t\t\t*uni_cp2 = s->codepoint2;\n\t\t\t\treturn SUCCESS;\n\t\t\t}\n\t\t}\n\t\ts++;\n\t}\n\treturn FAILURE;\n}", "target": 0}
{"code": "void find_var_recursive(const TypedValue* tv,\n                        const req::ptr<WddxPacket>& wddxPacket) {\n  if (tvIsString(tv)) {\n    String var_name{tvCastToString(tv)};\n    wddxPacket->add_var(var_name, true);\n  }\n  if (isArrayType(tv->m_type)) {\n    for (ArrayIter iter(tv->m_data.parr); iter; ++iter) {\n      find_var_recursive(iter.secondRef().asTypedValue(), wddxPacket);\n    }\n  }\n}", "target": 0}
{"code": "bool IsIDNComponentInSingleScript(const char16* str, int str_len) {\n  UScriptCode first_script = USCRIPT_INVALID_CODE;\n  bool is_first = true;\n  int i = 0;\n  while (i < str_len) {\n    unsigned code_point;\n    U16_NEXT(str, i, str_len, code_point);\n    UErrorCode err = U_ZERO_ERROR;\n    UScriptCode cur_script = uscript_getScript(code_point, &err);\n    if (err != U_ZERO_ERROR)\n      return false;  \n    cur_script = NormalizeScript(cur_script);\n    if (is_first && cur_script != USCRIPT_COMMON) {\n      first_script = cur_script;\n      is_first = false;\n    } else {\n      if (cur_script != USCRIPT_COMMON && cur_script != first_script)\n        return false;\n    }\n  }\n  return true;\n}", "target": 0}
{"code": "SPL_METHOD(Array, hasChildren)\n{\n\tzval *object = getThis(), **entry;\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);\n\tHashTable *aht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tif (spl_array_object_verify_pos(intern, aht TSRMLS_CC) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tif (zend_hash_get_current_data_ex(aht, (void **) &entry, &intern->pos) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_BOOL(Z_TYPE_PP(entry) == IS_ARRAY || (Z_TYPE_PP(entry) == IS_OBJECT && (intern->ar_flags & SPL_ARRAY_CHILD_ARRAYS_ONLY) == 0));\n}", "target": 0}
{"code": "njs_string_decode_base64(njs_vm_t *vm, njs_value_t *value, const njs_str_t *src)\n{\n    return njs_string_decode_base64_core(vm, value, src, 0);\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, CannotTrimIxisectAndHashWithOrChild) {\n    params.options = QueryPlannerParams::CANNOT_TRIM_IXISECT;\n    params.options |= QueryPlannerParams::INDEX_INTERSECTION;\n    params.options |= QueryPlannerParams::NO_TABLE_SCAN;\n    addIndex(BSON(\"a\" << 1));\n    addIndex(BSON(\"b\" << 1));\n    addIndex(BSON(\"c\" << 1));\n    runQuery(fromjson(\"{c: 1, $or: [{a: 1}, {b: 1, d: 1}]}\"));\n    assertNumSolutions(3U);\n    assertSolutionExists(\n        \"{fetch: {filter: {c: 1}, node: {or: {nodes: [\"\n        \"{fetch: {filter: {d: 1}, node: {ixscan: {filter: null,\"\n        \"pattern: {b: 1}, bounds: {b: [[1,1,true,true]]}}}}},\"\n        \"{ixscan: {filter: null, pattern: {a: 1},\"\n        \"bounds: {a: [[1,1,true,true]]}}}]}}}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: {$or:[{b:1,d:1},{a:1}]}, node:\"\n        \"{ixscan: {filter: null, pattern: {c: 1}}}}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: {c:1,$or:[{a:1},{b:1,d:1}]}, node:{andHash:{nodes:[\"\n        \"{or: {nodes: [\"\n        \"{fetch: {filter: {d:1}, node: {ixscan: {pattern: {b: 1}}}}},\"\n        \"{ixscan: {filter: null, pattern: {a: 1}}}]}},\"\n        \"{ixscan: {filter: null, pattern: {c: 1}}}]}}}}\");\n}", "target": 0}
{"code": "status_t MPEG4Source::parseSampleAuxiliaryInformationSizes(\n off64_t offset, off64_t ) {\n    ALOGV(\"parseSampleAuxiliaryInformationSizes\");\n uint8_t version;\n if (mDataSource->readAt(\n            offset, &version, sizeof(version))\n < (ssize_t)sizeof(version)) {\n return ERROR_IO;\n }\n if (version != 0) {\n return ERROR_UNSUPPORTED;\n }\n    offset++;\n uint32_t flags;\n if (!mDataSource->getUInt24(offset, &flags)) {\n return ERROR_IO;\n }\n    offset += 3;\n if (flags & 1) {\n uint32_t tmp;\n if (!mDataSource->getUInt32(offset, &tmp)) {\n return ERROR_MALFORMED;\n }\n        mCurrentAuxInfoType = tmp;\n        offset += 4;\n if (!mDataSource->getUInt32(offset, &tmp)) {\n return ERROR_MALFORMED;\n }\n        mCurrentAuxInfoTypeParameter = tmp;\n        offset += 4;\n }\n uint8_t defsize;\n if (mDataSource->readAt(offset, &defsize, 1) != 1) {\n return ERROR_MALFORMED;\n }\n    mCurrentDefaultSampleInfoSize = defsize;\n    offset++;\n uint32_t smplcnt;\n if (!mDataSource->getUInt32(offset, &smplcnt)) {\n return ERROR_MALFORMED;\n }\n    mCurrentSampleInfoCount = smplcnt;\n    offset += 4;\n if (mCurrentDefaultSampleInfoSize != 0) {\n        ALOGV(\"@@@@ using default sample info size of %d\", mCurrentDefaultSampleInfoSize);\n return OK;\n }\n if (smplcnt > mCurrentSampleInfoAllocSize) {\n uint8_t * newPtr = (uint8_t*) realloc(mCurrentSampleInfoSizes, smplcnt);\n if (newPtr == NULL) {\n            ALOGE(\"failed to realloc %u -> %u\", mCurrentSampleInfoAllocSize, smplcnt);\n return NO_MEMORY;\n }\n        mCurrentSampleInfoSizes = newPtr;\n        mCurrentSampleInfoAllocSize = smplcnt;\n }\n    mDataSource->readAt(offset, mCurrentSampleInfoSizes, smplcnt);\n return OK;\n}", "target": 0}
{"code": "TEST_F(ExprMatchTest, InWithLhsFieldPathAndArrayAsConstMatchesCorrectly) {\n    createMatcher(fromjson(\"{$expr: {$in: ['$x', {$const: [1, 2, 3]}]}}\"));\n    ASSERT_TRUE(matches(BSON(\"x\" << 1)));\n    ASSERT_TRUE(matches(BSON(\"x\" << 3)));\n    ASSERT_FALSE(matches(BSON(\"x\" << 5)));\n    ASSERT_FALSE(matches(BSON(\"y\" << 2)));\n    ASSERT_FALSE(matches(BSON(\"x\" << BSON(\"y\" << 2))));\n}", "target": 0}
{"code": "    int Exifdatum::setDataArea(const byte* buf, long len)\n    {\n        return value_.get() == 0 ? -1 : value_->setDataArea(buf, len);\n    }", "target": 0}
{"code": "unset(struct tbl *vp, int flags)\n{\n\tif (vp->flag & ALLOC)\n\t\tafree(vp->val.s, vp->areap);\n\tif ((vp->flag & ARRAY) && (flags & 1)) {\n\t\tstruct tbl *a, *tmp;\n\t\tfor (a = vp->u.array; a; ) {\n\t\t\ttmp = a;\n\t\t\ta = a->u.array;\n\t\t\tif (tmp->flag & ALLOC)\n\t\t\t\tafree(tmp->val.s, tmp->areap);\n\t\t\tafree(tmp, tmp->areap);\n\t\t}\n\t\tvp->u.array = NULL;\n\t}\n\tif (flags & 2) {\n\t\tvp->flag &= ~(ALLOC|ISSET);\n\t\treturn;\n\t}\n\tvp->flag &= SPECIAL | ((flags & 1) ? 0 : ARRAY|DEFINED);\n\tif (vp->flag & SPECIAL)\n\t\tunsetspec(vp);\n}", "target": 0}
{"code": "  Item_default_value(THD *thd, Name_resolution_context *context_arg, Field *a)\n    :Item_field(thd, context_arg, (const char *)NULL, (const char *)NULL,\n                (const char *)NULL),\n    arg(NULL) {}", "target": 0}
{"code": "static int ref_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tint error;\n\tgit_pkt_ref *pkt;\n\tsize_t alloclen;\n\tpkt = git__malloc(sizeof(git_pkt_ref));\n\tGITERR_CHECK_ALLOC(pkt);\n\tmemset(pkt, 0x0, sizeof(git_pkt_ref));\n\tpkt->type = GIT_PKT_REF;\n\tif ((error = git_oid_fromstr(&pkt->head.oid, line)) < 0)\n\t\tgoto error_out;\n\tif (line[GIT_OID_HEXSZ] != ' ') {\n\t\tgiterr_set(GITERR_NET, \"Error parsing pkt-line\");\n\t\terror = -1;\n\t\tgoto error_out;\n\t}\n\tline += GIT_OID_HEXSZ + 1;\n\tlen -= (GIT_OID_HEXSZ + 1);\n\tif (line[len - 1] == '\\n')\n\t\t--len;\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->head.name = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->head.name);\n\tmemcpy(pkt->head.name, line, len);\n\tpkt->head.name[len] = '\\0';\n\tif (strlen(pkt->head.name) < len) {\n\t\tpkt->capabilities = strchr(pkt->head.name, '\\0') + 1;\n\t}\n\t*out = (git_pkt *)pkt;\n\treturn 0;\nerror_out:\n\tgit__free(pkt);\n\treturn error;\n}", "target": 0}
{"code": "OPJ_BOOL opj_j2k_pre_write_tile (       opj_j2k_t * p_j2k,\n                                                                OPJ_UINT32 p_tile_index,\n                                                                opj_stream_private_t *p_stream,\n                                                                opj_event_mgr_t * p_manager )\n{\n  (void)p_stream;\n        if (p_tile_index != p_j2k->m_current_tile_number) {\n                opj_event_msg(p_manager, EVT_ERROR, \"The given tile index does not match.\" );\n                return OPJ_FALSE;\n        }\n        opj_event_msg(p_manager, EVT_INFO, \"tile number %d / %d\\n\", p_j2k->m_current_tile_number + 1, p_j2k->m_cp.tw * p_j2k->m_cp.th);\n        p_j2k->m_specific_param.m_encoder.m_current_tile_part_number = 0;\n        p_j2k->m_tcd->cur_totnum_tp = p_j2k->m_cp.tcps[p_tile_index].m_nb_tile_parts;\n        p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = 0;\n        if (! opj_tcd_init_encode_tile(p_j2k->m_tcd, p_j2k->m_current_tile_number)) {\n                return OPJ_FALSE;\n        }\n        return OPJ_TRUE;\n}", "target": 0}
{"code": "gx_default_composite_clist_write_update(const gs_composite_t *pcte, gx_device * dev,\n                gx_device ** pcdev, gs_gstate * pgs, gs_memory_t * mem)\n{\n    *pcdev = dev;\t\t\n    return 0;\n}", "target": 0}
{"code": "void kvm_free_physmem(struct kvm *kvm)\n{\n\tint i;\n\tstruct kvm_memslots *slots = kvm->memslots;\n\tfor (i = 0; i < slots->nmemslots; ++i)\n\t\tkvm_free_physmem_slot(&slots->memslots[i], NULL);\n\tkfree(kvm->memslots);\n}", "target": 0}
{"code": "static inline struct net *xt_net(const struct xt_action_param *par)\n{\n\treturn par->state->net;\n}", "target": 0}
{"code": "int newsgroups_cb(const char *mailbox,\n\t\t  uint32_t uid __attribute__((unused)),\n\t\t  const char *entry __attribute__((unused)),\n\t\t  const char *userid,\n\t\t  const struct buf *value, void *rock)\n{\n    struct wildmat *wild = (struct wildmat *) rock;\n    if ((!strncasecmp(mailbox, \"INBOX\", 5) &&\n\t (!mailbox[5] || mailbox[5] == '.')) ||\n\t!strncmp(mailbox, \"user.\", 5))\n\treturn 0;\n    while (wild->pat && wildmat(mailbox, wild->pat) != 1) wild++;\n    if (!wild->pat || wild->not) return 0;\n    if (userid[0]) return 0;\n    prot_printf(nntp_out, \"%s\\t%s\\r\\n\", mailbox+strlen(newsprefix),\n\t\tvalue->s);\n    return 0;\n}", "target": 0}
{"code": "static unsigned addChunk_IEND(ucvector* out)\n{\n  unsigned error = 0;\n  error = addChunk(out, \"IEND\", 0, 0);\n  return error;\n}", "target": 0}
{"code": "ipcp_bits_lattice::meet_with_1 (widest_int value, widest_int mask,\n\t\t\t\tunsigned precision)\n{\n  gcc_assert (constant_p ());\n  widest_int old_mask = m_mask;\n  m_mask = (m_mask | mask) | (m_value ^ value);\n  if (wi::sext (m_mask, precision) == -1)\n    return set_to_bottom ();\n  return m_mask != old_mask;\n}", "target": 0}
{"code": "TEST(EqOp, MatchesFullArray) {\n    BSONObj operand = BSON(\"a\" << BSON_ARRAY(1 << 2));\n    EqualityMatchExpression eq(\"a\", operand[\"a\"]);\n    ASSERT(eq.matchesBSON(BSON(\"a\" << BSON_ARRAY(1 << 2)), NULL));\n    ASSERT(!eq.matchesBSON(BSON(\"a\" << BSON_ARRAY(1 << 2 << 3)), NULL));\n    ASSERT(!eq.matchesBSON(BSON(\"a\" << BSON_ARRAY(1)), NULL));\n    ASSERT(!eq.matchesBSON(BSON(\"a\" << 1), NULL));\n}", "target": 0}
{"code": "static int grep_object(struct grep_opt *opt, const char **paths,\n\t\t       struct object *obj, const char *name)\n{\n\tif (obj->type == OBJ_BLOB)\n\t\treturn grep_sha1(opt, obj->sha1, name, 0);\n\tif (obj->type == OBJ_COMMIT || obj->type == OBJ_TREE) {\n\t\tstruct tree_desc tree;\n\t\tvoid *data;\n\t\tunsigned long size;\n\t\tint hit;\n\t\tdata = read_object_with_reference(obj->sha1, tree_type,\n\t\t\t\t\t\t  &size, NULL);\n\t\tif (!data)\n\t\t\tdie(\"unable to read tree (%s)\", sha1_to_hex(obj->sha1));\n\t\tinit_tree_desc(&tree, data, size);\n\t\thit = grep_tree(opt, paths, &tree, name, \"\");\n\t\tfree(data);\n\t\treturn hit;\n\t}\n\tdie(\"unable to grep from object of type %s\", typename(obj->type));\n}", "target": 0}
{"code": "Opal::Call::OnNoAnswerTimeout (PTimer &,\n                               INT)\n{\n  if (!is_outgoing ()) {\n    if (!forward_uri.empty ()) {\n      PSafePtr<OpalConnection> connection = get_remote_connection ();\n      if (connection != NULL)\n        connection->ForwardCall (forward_uri);\n    }\n    else\n      Clear (OpalConnection::EndedByNoAnswer);\n  }\n}", "target": 0}
{"code": "static void vhost_net_stop(struct vhost_net *n, struct socket **tx_sock,\n\t\t\t   struct socket **rx_sock)\n{\n\t*tx_sock = vhost_net_stop_vq(n, n->vqs + VHOST_NET_VQ_TX);\n\t*rx_sock = vhost_net_stop_vq(n, n->vqs + VHOST_NET_VQ_RX);\n}", "target": 0}
{"code": "static void __tcp_ack_snd_check(struct sock *sk, int ofo_possible)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tif (((tp->rcv_nxt - tp->rcv_wup) > inet_csk(sk)->icsk_ack.rcv_mss &&\n\t     __tcp_select_window(sk) >= tp->rcv_wnd) ||\n\t    tcp_in_quickack_mode(sk) ||\n\t    (ofo_possible && skb_peek(&tp->out_of_order_queue))) {\n\t\ttcp_send_ack(sk);\n\t} else {\n\t\ttcp_send_delayed_ack(sk);\n\t}\n}", "target": 0}
{"code": "static void net_layer_file_report(gerbv_net_t *net,\n\t\tgerbv_image_t *img, gerbv_project_t *prj)\n{\n\tif (net->label != NULL)\n\t\tg_message (_(\"    Net label: %s\"), net->label->str);\n\tif (net->layer->name != NULL)\n\t\tg_message (_(\"    Layer name: %s\"), net->layer->name);\n\tfor (int i = 0; i <= prj->last_loaded; i++) {\n\t\tif (img == prj->file[i]->image)\n\t\t\tg_message (_(\"    In file: %s\"), prj->file[i]->name);\n\t}\n}", "target": 0}
{"code": "xfs_trim_extent(\n\tstruct xfs_bmbt_irec\t*irec,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen)\n{\n\txfs_fileoff_t\t\tdistance;\n\txfs_fileoff_t\t\tend = bno + len;\n\tif (irec->br_startoff + irec->br_blockcount <= bno ||\n\t    irec->br_startoff >= end) {\n\t\tirec->br_blockcount = 0;\n\t\treturn;\n\t}\n\tif (irec->br_startoff < bno) {\n\t\tdistance = bno - irec->br_startoff;\n\t\tif (isnullstartblock(irec->br_startblock))\n\t\t\tirec->br_startblock = DELAYSTARTBLOCK;\n\t\tif (irec->br_startblock != DELAYSTARTBLOCK &&\n\t\t    irec->br_startblock != HOLESTARTBLOCK)\n\t\t\tirec->br_startblock += distance;\n\t\tirec->br_startoff += distance;\n\t\tirec->br_blockcount -= distance;\n\t}\n\tif (end < irec->br_startoff + irec->br_blockcount) {\n\t\tdistance = irec->br_startoff + irec->br_blockcount - end;\n\t\tirec->br_blockcount -= distance;\n\t}\n}", "target": 0}
{"code": "header_checkname(void *h, char *name, int len)\n{\nh = h;            \nname = name;\nlen = len;\nreturn 0;\n}", "target": 0}
{"code": "    StringValueBase::StringValueBase(const StringValueBase& rhs)\n        : Value(rhs), value_(rhs.value_)\n    {\n    }", "target": 0}
{"code": "void RGWGetBucketPublicAccessBlock_ObjStore_S3::send_response()\n{\n  if (op_ret) {\n    set_req_state_err(s, op_ret);\n  }\n  dump_errno(s);\n  end_header(s, this, \"application/xml\");\n  dump_start(s);\n  access_conf.dump_xml(s->formatter);\n  rgw_flush_formatter_and_reset(s, s->formatter);\n}", "target": 0}
{"code": "static int legacy_fs_context_dup(struct fs_context *fc, struct fs_context *src_fc)\n{\n\tstruct legacy_fs_context *ctx;\n\tstruct legacy_fs_context *src_ctx = src_fc->fs_private;\n\tctx = kmemdup(src_ctx, sizeof(*src_ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\tif (ctx->param_type == LEGACY_FS_INDIVIDUAL_PARAMS) {\n\t\tctx->legacy_data = kmemdup(src_ctx->legacy_data,\n\t\t\t\t\t   src_ctx->data_size, GFP_KERNEL);\n\t\tif (!ctx->legacy_data) {\n\t\t\tkfree(ctx);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tfc->fs_private = ctx;\n\treturn 0;\n}", "target": 0}
{"code": "const net::LoadStateWithParam& WebContentsImpl::GetLoadState() const {\n  return load_state_;\n}", "target": 0}
{"code": "static int filter_flatedecode(struct pdf_struct *pdf, struct pdf_obj *obj,\n\t\t\t      const char *buf, off_t len, int fout, off_t *sum)\n{\n    int zstat;\n    z_stream stream;\n    off_t nbytes;\n    char output[BUFSIZ];\n    if (len == 0)\n\treturn CL_CLEAN;\n    memset(&stream, 0, sizeof(stream));\n    stream.next_in = (Bytef *)buf;\n    stream.avail_in = len;\n    stream.next_out = (Bytef *)output;\n    stream.avail_out = sizeof(output);\n    zstat = inflateInit(&stream);\n    if(zstat != Z_OK) {\n\tcli_warnmsg(\"cli_pdf: inflateInit failed\\n\");\n\treturn CL_EMEM;\n    }\n    nbytes = 0;\n    while(stream.avail_in) {\n\tzstat = inflate(&stream, Z_NO_FLUSH);\t\n\tswitch(zstat) {\n\t    case Z_OK:\n\t\tif(stream.avail_out == 0) {\n\t\t    int written;\n\t\t    if ((written=filter_writen(pdf, obj, fout, output, sizeof(output), sum))!=sizeof(output)) {\n\t\t\tcli_errmsg(\"cli_pdf: failed to write output file\\n\");\n\t\t\tinflateEnd(&stream);\n\t\t\treturn CL_EWRITE;\n\t\t    }\n\t\t    nbytes += written;\n\t\t    stream.next_out = (Bytef *)output;\n\t\t    stream.avail_out = sizeof(output);\n\t\t}\n\t\tcontinue;\n\t    case Z_STREAM_END:\n\t\tbreak;\n\t    default:\n\t\tif(stream.msg)\n\t\t    cli_dbgmsg(\"cli_pdf: after writing %lu bytes, got error \\\"%s\\\" inflating PDF stream in %u %u obj\\n\",\n\t\t\t       (unsigned long)nbytes,\n\t\t\t       stream.msg, obj->id>>8, obj->id&0xff);\n\t\telse\n\t\t    cli_dbgmsg(\"cli_pdf: after writing %lu bytes, got error %d inflating PDF stream in %u %u obj\\n\",\n\t\t\t       (unsigned long)nbytes, zstat, obj->id>>8, obj->id&0xff);\n\t\tpdf->flags |= 1 << BAD_FLATE;\n\t\tinflateEnd(&stream);\n\t\treturn CL_CLEAN;\n\t}\n\tbreak;\n    }\n    if(stream.avail_out != sizeof(output)) {\n\tif(filter_writen(pdf, obj, fout, output, sizeof(output) - stream.avail_out, sum) < 0) {\n\t    cli_errmsg(\"cli_pdf: failed to write output file\\n\");\n\t    inflateEnd(&stream);\n\t    return CL_EWRITE;\n\t}\n    }\n    inflateEnd(&stream);\n    return CL_CLEAN;\n}", "target": 0}
{"code": "void gss_spnegoint_lib_fini(void)\n{\n}", "target": 0}
{"code": "void vfs_clean_context(struct fs_context *fc)\n{\n\tif (fc->need_free && fc->ops && fc->ops->free)\n\t\tfc->ops->free(fc);\n\tfc->need_free = false;\n\tfc->fs_private = NULL;\n\tfc->s_fs_info = NULL;\n\tfc->sb_flags = 0;\n\tsecurity_free_mnt_opts(&fc->security);\n\tkfree(fc->source);\n\tfc->source = NULL;\n\tfc->purpose = FS_CONTEXT_FOR_RECONFIGURE;\n\tfc->phase = FS_CONTEXT_AWAITING_RECONF;\n}", "target": 0}
{"code": "static int tcp_check_dsack(struct sock *sk, const struct sk_buff *ack_skb,\n\t\t\t   struct tcp_sack_block_wire *sp, int num_sacks,\n\t\t\t   u32 prior_snd_una)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 start_seq_0 = get_unaligned_be32(&sp[0].start_seq);\n\tu32 end_seq_0 = get_unaligned_be32(&sp[0].end_seq);\n\tint dup_sack = 0;\n\tif (before(start_seq_0, TCP_SKB_CB(ack_skb)->ack_seq)) {\n\t\tdup_sack = 1;\n\t\ttcp_dsack_seen(tp);\n\t\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPDSACKRECV);\n\t} else if (num_sacks > 1) {\n\t\tu32 end_seq_1 = get_unaligned_be32(&sp[1].end_seq);\n\t\tu32 start_seq_1 = get_unaligned_be32(&sp[1].start_seq);\n\t\tif (!after(end_seq_0, end_seq_1) &&\n\t\t    !before(start_seq_0, start_seq_1)) {\n\t\t\tdup_sack = 1;\n\t\t\ttcp_dsack_seen(tp);\n\t\t\tNET_INC_STATS_BH(sock_net(sk),\n\t\t\t\t\tLINUX_MIB_TCPDSACKOFORECV);\n\t\t}\n\t}\n\tif (dup_sack && tp->undo_marker && tp->undo_retrans &&\n\t    !after(end_seq_0, prior_snd_una) &&\n\t    after(end_seq_0, tp->undo_marker))\n\t\ttp->undo_retrans--;\n\treturn dup_sack;\n}", "target": 0}
{"code": "tree_printsub(tree_node *p, int pos, int barswitch)\n{\nint i;\nif (p->right) tree_printsub(p->right, pos+2, 1);\nfor (i = 0; i <= pos-1; i++) debug_printf(\"%c\", tree_printline[i]);\ndebug_printf(\"-->%s [%d]\\n\", p->name, p->balance);\ntree_printline[pos] = barswitch? '|' : ' ';\nif (p->left)\n  {\n  tree_printline[pos+2] = '|';\n  tree_printsub(p->left, pos+2, 0);\n  }\n}", "target": 0}
{"code": "static DeviceState *failover_find_primary_device(VirtIONet *n)\n{\n    FailoverDevice fdev = {\n        .n = n,\n    };\n    qbus_walk_children(sysbus_get_default(), failover_set_primary, NULL,\n                       NULL, NULL, &fdev);\n    return fdev.dev;\n}", "target": 0}
{"code": "fbStore_x8b8g8r8 (FbBits *bits, const CARD32 *values, int x, int width, miIndexedPtr indexed)\n{\n    int i;\n    CARD32 *pixel = (CARD32 *)bits + x;\n    for (i = 0; i < width; ++i)\n        WRITE(pixel++, (READ(values + i) & 0x0000ff00) | ((READ(values + i) >> 16) & 0xff) | ((READ(values + i) & 0xff) << 16));\n}", "target": 0}
{"code": "static void get_counters(const struct ebt_counter *oldcounters,\n   struct ebt_counter *counters, unsigned int nentries)\n{\n\tint i, cpu;\n\tstruct ebt_counter *counter_base;\n\tmemcpy(counters, oldcounters,\n\t       sizeof(struct ebt_counter) * nentries);\n\tfor_each_possible_cpu(cpu) {\n\t\tif (cpu == 0)\n\t\t\tcontinue;\n\t\tcounter_base = COUNTER_BASE(oldcounters, nentries, cpu);\n\t\tfor (i = 0; i < nentries; i++) {\n\t\t\tcounters[i].pcnt += counter_base[i].pcnt;\n\t\t\tcounters[i].bcnt += counter_base[i].bcnt;\n\t\t}\n\t}\n}", "target": 0}
{"code": "de265_error decoder_context::read_eos_NAL(bitreader& reader)\n{\n  FirstAfterEndOfSequenceNAL = true;\n  return DE265_OK;\n}", "target": 0}
{"code": "__print_funct_t print_sar_comment(int *tab, int action, char *cur_date, char *cur_time, int utc,\n\t\t\t\t  char *comment, struct file_header *file_hdr,\n\t\t\t\t  struct record_header *record_hdr)\n{\n\tprintf(\"%-11s\", cur_time);\n\tcprintf_s(IS_COMMENT, \"  COM %s\\n\", comment);\n}", "target": 0}
{"code": "static bool is_seccomp_filter_available(void) {\n        return prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, NULL, 0, 0) < 0 &&\n                errno == EFAULT;\n}", "target": 0}
{"code": "obtain_authtok(pam_handle_t *pamh)\n{\n    char *resp;\n    const void *item;\n    int retval;\n    retval = pam_prompt(pamh, PAM_PROMPT_ECHO_OFF, &resp, _(\"Password: \"));\n    if (retval != PAM_SUCCESS)\n\treturn retval;\n    if (resp == NULL)\n\treturn PAM_CONV_ERR;\n    retval = pam_set_item(pamh, PAM_AUTHTOK, resp);\n    _pam_overwrite(resp);\n    _pam_drop(resp);\n    if ( (retval != PAM_SUCCESS) ||\n\t (retval = pam_get_item(pamh, PAM_AUTHTOK, &item))\n\t != PAM_SUCCESS ) {\n\treturn retval;\n    }\n    return retval;\n}", "target": 0}
{"code": "static void hci_si_event(struct hci_dev *hdev, int type, int dlen, void *data)\n{\n\tstruct hci_event_hdr *hdr;\n\tstruct hci_ev_stack_internal *ev;\n\tstruct sk_buff *skb;\n\tskb = bt_skb_alloc(HCI_EVENT_HDR_SIZE + sizeof(*ev) + dlen, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\thdr = (void *) skb_put(skb, HCI_EVENT_HDR_SIZE);\n\thdr->evt  = HCI_EV_STACK_INTERNAL;\n\thdr->plen = sizeof(*ev) + dlen;\n\tev  = (void *) skb_put(skb, sizeof(*ev) + dlen);\n\tev->type = type;\n\tmemcpy(ev->data, data, dlen);\n\tbt_cb(skb)->incoming = 1;\n\t__net_timestamp(skb);\n\tbt_cb(skb)->pkt_type = HCI_EVENT_PKT;\n\tskb->dev = (void *) hdev;\n\thci_send_to_sock(hdev, skb);\n\tkfree_skb(skb);\n}", "target": 0}
{"code": "static int writeback(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tswitch (ctxt->dst.type) {\n\tcase OP_REG:\n\t\twrite_register_operand(&ctxt->dst);\n\t\tbreak;\n\tcase OP_MEM:\n\t\tif (ctxt->lock_prefix)\n\t\t\trc = segmented_cmpxchg(ctxt,\n\t\t\t\t\t       ctxt->dst.addr.mem,\n\t\t\t\t\t       &ctxt->dst.orig_val,\n\t\t\t\t\t       &ctxt->dst.val,\n\t\t\t\t\t       ctxt->dst.bytes);\n\t\telse\n\t\t\trc = segmented_write(ctxt,\n\t\t\t\t\t     ctxt->dst.addr.mem,\n\t\t\t\t\t     &ctxt->dst.val,\n\t\t\t\t\t     ctxt->dst.bytes);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\treturn rc;\n\t\tbreak;\n\tcase OP_XMM:\n\t\twrite_sse_reg(ctxt, &ctxt->dst.vec_val, ctxt->dst.addr.xmm);\n\t\tbreak;\n\tcase OP_NONE:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn X86EMUL_CONTINUE;\n}", "target": 0}
{"code": "long big_key_read(const struct key *key, char __user *buffer, size_t buflen)\n{\n\tunsigned long datalen = key->type_data.x[1];\n\tlong ret;\n\tif (!buffer || buflen < datalen)\n\t\treturn datalen;\n\tif (datalen > BIG_KEY_FILE_THRESHOLD) {\n\t\tstruct path *path = (struct path *)&key->payload.data2;\n\t\tstruct file *file;\n\t\tloff_t pos;\n\t\tfile = dentry_open(path, O_RDONLY, current_cred());\n\t\tif (IS_ERR(file))\n\t\t\treturn PTR_ERR(file);\n\t\tpos = 0;\n\t\tret = vfs_read(file, buffer, datalen, &pos);\n\t\tfput(file);\n\t\tif (ret >= 0 && ret != datalen)\n\t\t\tret = -EIO;\n\t} else {\n\t\tret = datalen;\n\t\tif (copy_to_user(buffer, key->payload.data, datalen) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static inline u32 nfsd4_offload_status_rsize(struct svc_rqst *rqstp,\n\t\t\t\t\t     struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size +\n\t\t2  +\n\t\t1 ) * sizeof(__be32);\n}", "target": 0}
{"code": "static void check_watchpoint(int offset, int len, MemTxAttrs attrs, int flags)\n{\n    CPUState *cpu = current_cpu;\n    CPUArchState *env = cpu->env_ptr;\n    target_ulong pc, cs_base;\n    target_ulong vaddr;\n    CPUWatchpoint *wp;\n    int cpu_flags;\n    if (cpu->watchpoint_hit) {\n        cpu_interrupt(cpu, CPU_INTERRUPT_DEBUG);\n        return;\n    }\n    vaddr = (cpu->mem_io_vaddr & TARGET_PAGE_MASK) + offset;\n    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {\n        if (cpu_watchpoint_address_matches(wp, vaddr, len)\n            && (wp->flags & flags)) {\n            if (flags == BP_MEM_READ) {\n                wp->flags |= BP_WATCHPOINT_HIT_READ;\n            } else {\n                wp->flags |= BP_WATCHPOINT_HIT_WRITE;\n            }\n            wp->hitaddr = vaddr;\n            wp->hitattrs = attrs;\n            if (!cpu->watchpoint_hit) {\n                cpu->watchpoint_hit = wp;\n                tb_check_watchpoint(cpu);\n                if (wp->flags & BP_STOP_BEFORE_ACCESS) {\n                    cpu->exception_index = EXCP_DEBUG;\n                    cpu_loop_exit(cpu);\n                } else {\n                    cpu_get_tb_cpu_state(env, &pc, &cs_base, &cpu_flags);\n                    tb_gen_code(cpu, pc, cs_base, cpu_flags, 1);\n                    cpu_resume_from_signal(cpu, NULL);\n                }\n            }\n        } else {\n            wp->flags &= ~BP_WATCHPOINT_HIT;\n        }\n    }\n}", "target": 0}
{"code": "static void hashkey(struct connectdata *conn, char *buf,\n                    size_t len,  \n                    const char **hostp)\n{\n  const char *hostname;\n  long port = conn->remote_port;\n#ifndef CURL_DISABLE_PROXY\n  if(conn->bits.httpproxy && !conn->bits.tunnel_proxy) {\n    hostname = conn->http_proxy.host.name;\n    port = conn->port;\n  }\n  else\n#endif\n    if(conn->bits.conn_to_host)\n      hostname = conn->conn_to_host.name;\n  else\n    hostname = conn->host.name;\n  if(hostp)\n    *hostp = hostname;\n#ifdef ENABLE_IPV6\n  msnprintf(buf, len, \"%u/%ld/%s\", conn->scope_id, port, hostname);\n#else\n  msnprintf(buf, len, \"%ld/%s\", port, hostname);\n#endif\n  Curl_strntolower(buf, buf, len);\n}", "target": 0}
{"code": "flatpak_dir_find_installed_refs (FlatpakDir           *self,\n                                 const char           *opt_name,\n                                 const char           *opt_branch,\n                                 const char           *opt_arch,\n                                 FlatpakKinds          kinds,\n                                 FindMatchingRefsFlags flags,\n                                 GError              **error)\n{\n  g_autoptr(GHashTable) local_refs = NULL;\n  g_autoptr(GPtrArray) matched_refs = NULL;\n  local_refs = flatpak_dir_get_all_installed_refs (self, kinds, error);\n  if (local_refs == NULL)\n    return NULL;\n  matched_refs = find_matching_refs (local_refs,\n                                     opt_name,\n                                     opt_branch,\n                                     NULL, \n                                     opt_arch,\n                                     NULL, \n                                     kinds,\n                                     flags,\n                                     error);\n  if (matched_refs == NULL)\n    return NULL;\n  return g_steal_pointer (&matched_refs);\n}", "target": 0}
{"code": "void aprm_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}", "target": 0}
{"code": "decode_control(const uschar *arg, const uschar **pptr, int where, uschar **log_msgptr)\n{\nint idx, len;\ncontrol_def * d;\nif (  (idx = find_control(arg, controls_list, nelem(controls_list))) < 0\n   || (  arg[len = Ustrlen((d = controls_list+idx)->name)] != 0\n      && (!d->has_option || arg[len] != '/')\n   )  )\n  {\n  *log_msgptr = string_sprintf(\"syntax error in \\\"control=%s\\\"\", arg);\n  return CONTROL_ERROR;\n  }\n*pptr = arg + len;\nreturn idx;\n}", "target": 0}
{"code": "virSecuritySELinuxTransactionCommit(virSecurityManager *mgr G_GNUC_UNUSED,\n                                    pid_t pid,\n                                    bool lock)\n{\n    virSecuritySELinuxContextList *list;\n    int rc;\n    int ret = -1;\n    list = virThreadLocalGet(&contextList);\n    if (!list) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"No transaction is set\"));\n        return -1;\n    }\n    if (virThreadLocalSet(&contextList, NULL) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to clear thread local variable\"));\n        goto cleanup;\n    }\n    list->lock = lock;\n    if (pid != -1) {\n        rc = virProcessRunInMountNamespace(pid,\n                                           virSecuritySELinuxTransactionRun,\n                                           list);\n        if (rc < 0) {\n            if (virGetLastErrorCode() == VIR_ERR_SYSTEM_ERROR)\n                pid = -1;\n            else\n                goto cleanup;\n        }\n    }\n    if (pid == -1) {\n        if (lock)\n            rc = virProcessRunInFork(virSecuritySELinuxTransactionRun, list);\n        else\n            rc = virSecuritySELinuxTransactionRun(pid, list);\n    }\n    if (rc < 0)\n        goto cleanup;\n    ret = 0;\n cleanup:\n    virSecuritySELinuxContextListFree(list);\n    return ret;\n}", "target": 0}
{"code": "rb_reg_named_captures(VALUE re)\n{\n    VALUE hash = rb_hash_new();\n    rb_reg_check(re);\n    onig_foreach_name(RREGEXP_PTR(re), reg_named_captures_iter, (void*)hash);\n    return hash;\n}", "target": 0}
{"code": "generate_object_id(cms_context *cms, SECItem *der, SECOidTag tag)\n{\n\tSECOidData *oid;\n\toid = SECOID_FindOIDByTag(tag);\n\tif (!oid)\n\t\tcnreterr(-1, cms, \"could not find OID\");\n\tvoid *ret;\n\tret = SEC_ASN1EncodeItem(cms->arena, der, &oid->oid,\n\t\t\t\t\t\tSEC_ObjectIDTemplate);\n\tif (ret == NULL)\n\t\tcnreterr(-1, cms, \"could not encode ODI\");\n\treturn 0;\n}", "target": 0}
{"code": "static int mov_read_meta(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    while (atom.size > 8) {\n        uint32_t tag;\n        if (avio_feof(pb))\n            return AVERROR_EOF;\n        tag = avio_rl32(pb);\n        atom.size -= 4;\n        if (tag == MKTAG('h','d','l','r')) {\n            int ret;\n            avio_seek(pb, -8, SEEK_CUR);\n            atom.size += 8;\n            if ((ret = mov_read_default(c, pb, atom)) < 0)\n                return ret;\n            if (c->is_still_picture_avif) {\n                int ret;\n                if ((ret = avif_add_stream(c, c->primary_item_id)) < 0)\n                    return ret;\n                c->found_moov = 1;\n            }\n            return ret;\n        }\n    }\n    return 0;\n}", "target": 0}
{"code": "static int allocate_vpid(void)\n{\n\tint vpid;\n\tif (!enable_vpid)\n\t\treturn 0;\n\tspin_lock(&vmx_vpid_lock);\n\tvpid = find_first_zero_bit(vmx_vpid_bitmap, VMX_NR_VPIDS);\n\tif (vpid < VMX_NR_VPIDS)\n\t\t__set_bit(vpid, vmx_vpid_bitmap);\n\telse\n\t\tvpid = 0;\n\tspin_unlock(&vmx_vpid_lock);\n\treturn vpid;\n}", "target": 0}
{"code": "long keyctl_update_key(key_serial_t id,\n\t\t       const void __user *_payload,\n\t\t       size_t plen)\n{\n\tkey_ref_t key_ref;\n\tvoid *payload;\n\tlong ret;\n\tret = -EINVAL;\n\tif (plen > PAGE_SIZE)\n\t\tgoto error;\n\tpayload = NULL;\n\tif (_payload) {\n\t\tret = -ENOMEM;\n\t\tpayload = kmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error;\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error2;\n\t}\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\tret = key_update(key_ref, payload, plen);\n\tkey_ref_put(key_ref);\nerror2:\n\tkfree(payload);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "bool HTMLSelectElement::anonymousIndexedSetterRemove(unsigned index, ExceptionState& exceptionState)\n{\n    remove(index);\n    return true;\n}", "target": 0}
{"code": " int devmem_is_allowed(unsigned long pagenr)\n {\n\tif (page_is_ram(pagenr)) {\n\t\tif (pagenr < 256)\n\t\t\treturn 2;\n\t\treturn 0;\n\t}\n\tif (iomem_is_exclusive(pagenr << PAGE_SHIFT)) {\n\t\tif (pagenr < 256)\n\t\t\treturn 1;\n \t\treturn 0;\n\t}\n\treturn 1;\n }", "target": 0}
{"code": "gs_heap_alloc_byte_array(gs_memory_t * mem, uint num_elements, uint elt_size,\n                         client_name_t cname)\n{\n    ulong lsize = (ulong) num_elements * elt_size;\n    if (lsize != (uint) lsize)\n        return 0;\n    return gs_heap_alloc_bytes(mem, (uint) lsize, cname);\n}", "target": 0}
{"code": "static int StartDownload(content::RenderViewHost* rvh,\n                         const GURL& url,\n                         bool is_favicon,\n                         uint32_t max_bitmap_size) {\n  static int g_next_image_download_id = 0;\n  rvh->Send(new ImageMsg_DownloadImage(rvh->GetRoutingID(),\n                                       ++g_next_image_download_id,\n                                       url,\n                                       is_favicon,\n                                       max_bitmap_size));\n  return g_next_image_download_id;\n}", "target": 0}
{"code": "  void addCopy(const LowerCaseString& key, uint64_t value) override {\n    header_map_->addCopy(key, value);\n    header_map_->verifyByteSizeInternalForTest();\n  }", "target": 0}
{"code": "static void vmcs_write16(unsigned long field, u16 value)\n{\n\tvmcs_writel(field, value);\n}", "target": 0}
{"code": "void __init acpi_initrd_initialize_tables(void)\n{\n\tint table_offset = 0;\n\tint table_index = 0;\n\tu32 table_length;\n\tstruct acpi_table_header *table;\n\tif (!acpi_tables_addr)\n\t\treturn;\n\twhile (table_offset + ACPI_HEADER_SIZE <= all_tables_size) {\n\t\ttable = acpi_os_map_memory(acpi_tables_addr + table_offset,\n\t\t\t\t\t   ACPI_HEADER_SIZE);\n\t\tif (table_offset + table->length > all_tables_size) {\n\t\t\tacpi_os_unmap_memory(table, ACPI_HEADER_SIZE);\n\t\t\tWARN_ON(1);\n\t\t\treturn;\n\t\t}\n\t\ttable_length = table->length;\n\t\tif (test_bit(table_index, acpi_initrd_installed) ||\n\t\t    ACPI_COMPARE_NAME(table->signature, ACPI_SIG_RSDT) ||\n\t\t    ACPI_COMPARE_NAME(table->signature, ACPI_SIG_XSDT)) {\n\t\t\tacpi_os_unmap_memory(table, ACPI_HEADER_SIZE);\n\t\t\tgoto next_table;\n\t\t}\n\t\tacpi_table_taint(table);\n\t\tacpi_os_unmap_memory(table, ACPI_HEADER_SIZE);\n\t\tacpi_install_table(acpi_tables_addr + table_offset, TRUE);\n\t\tset_bit(table_index, acpi_initrd_installed);\nnext_table:\n\t\ttable_offset += table_length;\n\t\ttable_index++;\n\t}\n}", "target": 0}
{"code": "void set_postjoin_aggr_write_func(JOIN_TAB *tab)\n{\n  JOIN *join= tab->join;\n  TABLE *table= tab->table;\n  AGGR_OP *aggr= tab->aggr;\n  TMP_TABLE_PARAM *tmp_tbl= tab->tmp_table_param;\n  DBUG_ASSERT(table && aggr);\n  if (table->group && tmp_tbl->sum_func_count && \n      !tmp_tbl->precomputed_group_by)\n  {\n    if (table->s->keys && !table->s->uniques)\n    {\n      DBUG_PRINT(\"info\",(\"Using end_update\"));\n      aggr->set_write_func(end_update);\n    }\n    else\n    {\n      DBUG_PRINT(\"info\",(\"Using end_unique_update\"));\n      aggr->set_write_func(end_unique_update);\n    }\n  }\n  else if (join->sort_and_group && !tmp_tbl->precomputed_group_by &&\n           !join->sort_and_group_aggr_tab && join->tables_list &&\n           join->top_join_tab_count)\n  {\n    DBUG_PRINT(\"info\",(\"Using end_write_group\"));\n    aggr->set_write_func(end_write_group);\n    join->sort_and_group_aggr_tab= tab;\n  }\n  else\n  {\n    DBUG_PRINT(\"info\",(\"Using end_write\"));\n    aggr->set_write_func(end_write);\n    if (tmp_tbl->precomputed_group_by)\n    {\n      memcpy(tmp_tbl->items_to_copy + tmp_tbl->func_count,\n             join->sum_funcs,\n             sizeof(Item*)*tmp_tbl->sum_func_count);\n      tmp_tbl->items_to_copy[tmp_tbl->func_count+tmp_tbl->sum_func_count]= 0;\n    }\n  }\n}", "target": 0}
{"code": "my_decimal *Item_field::val_decimal_result(my_decimal *decimal_value)\n{\n  if ((null_value= result_field->is_null()))\n    return 0;\n  return result_field->val_decimal(decimal_value);\n}", "target": 0}
{"code": "static void piix3_ide_class_init(ObjectClass *klass, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(klass);\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n    k->realize = pci_piix_ide_realize;\n    k->exit = pci_piix_ide_exitfn;\n    k->vendor_id = PCI_VENDOR_ID_INTEL;\n    k->device_id = PCI_DEVICE_ID_INTEL_82371SB_1;\n    k->class_id = PCI_CLASS_STORAGE_IDE;\n    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);\n    dc->hotpluggable = false;\n}", "target": 0}
{"code": "uint32_t address_space_lduw_be(AddressSpace *as, hwaddr addr,\n                           MemTxAttrs attrs, MemTxResult *result)\n{\n    return address_space_lduw_internal(as, addr, attrs, result,\n                                       DEVICE_BIG_ENDIAN);\n}", "target": 0}
{"code": "static PHP_FUNCTION(libxml_set_external_entity_loader)\n{\n\tzend_fcall_info\t\t\tfci;\n\tzend_fcall_info_cache\tfcc;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"f!\", &fci, &fcc)\n\t\t\t== FAILURE) {\n\t\treturn;\n\t}\n\t_php_libxml_destroy_fci(&LIBXML(entity_loader).fci);\n\tif (fci.size > 0) { \n\t\tLIBXML(entity_loader).fci = fci;\n\t\tZ_ADDREF_P(fci.function_name);\n\t\tif (fci.object_ptr != NULL) {\n\t\t\tZ_ADDREF_P(fci.object_ptr);\n\t\t}\n\t\tLIBXML(entity_loader).fcc = fcc;\n\t}\n\tRETURN_TRUE;\n}", "target": 0}
{"code": "void *sftp_handle(sftp_session sftp, ssh_string handle){\n  uint32_t val;\n  if (sftp->handles == NULL) {\n    return NULL;\n  }\n  if (ssh_string_len(handle) != sizeof(uint32_t)) {\n    return NULL;\n  }\n  memcpy(&val, ssh_string_data(handle), sizeof(uint32_t));\n  if (val > SFTP_HANDLES) {\n    return NULL;\n  }\n  return sftp->handles[val];\n}", "target": 0}
{"code": "static u8 __init acpi_table_checksum(u8 *buffer, u32 length)\n{\n\tu8 sum = 0;\n\tu8 *end = buffer + length;\n\twhile (buffer < end)\n\t\tsum = (u8) (sum + *(buffer++));\n\treturn sum;\n}", "target": 0}
{"code": "static bool isNameOfInlineEventHandler(const Vector<UChar, 32>& name)\n{\n    const size_t lengthOfShortestInlineEventHandlerName = 5; \n    if (name.size() < lengthOfShortestInlineEventHandlerName)\n        return false;\n    return name[0] == 'o' && name[1] == 'n';\n}", "target": 0}
{"code": "static void bnx2x_attn_int(struct bnx2x *bp)\n{\n\tu32 attn_bits = le32_to_cpu(bp->def_status_blk->atten_status_block.\n\t\t\t\t\t\t\t\tattn_bits);\n\tu32 attn_ack = le32_to_cpu(bp->def_status_blk->atten_status_block.\n\t\t\t\t\t\t\t\tattn_bits_ack);\n\tu32 attn_state = bp->attn_state;\n\tu32 asserted   =  attn_bits & ~attn_ack & ~attn_state;\n\tu32 deasserted = ~attn_bits &  attn_ack &  attn_state;\n\tDP(NETIF_MSG_HW,\n\t   \"attn_bits %x  attn_ack %x  asserted %x  deasserted %x\\n\",\n\t   attn_bits, attn_ack, asserted, deasserted);\n\tif (~(attn_bits ^ attn_ack) & (attn_bits ^ attn_state))\n\t\tBNX2X_ERR(\"BAD attention state\\n\");\n\tif (asserted)\n\t\tbnx2x_attn_int_asserted(bp, asserted);\n\tif (deasserted)\n\t\tbnx2x_attn_int_deasserted(bp, deasserted);\n}", "target": 0}
{"code": "static MagickBooleanType WritePTIFImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  Image\n    *images,\n    *next,\n    *pyramid_image;\n  ImageInfo\n    *write_info;\n  MagickBooleanType\n    status;\n  PointInfo\n    resolution;\n  size_t\n    columns,\n    rows;\n  images=NewImageList();\n  for (next=image; next != (Image *) NULL; next=GetNextImageInList(next))\n  {\n    Image\n      *clone_image;\n    clone_image=CloneImage(next,0,0,MagickFalse,exception);\n    if (clone_image == (Image *) NULL)\n      break;\n    clone_image->previous=NewImageList();\n    clone_image->next=NewImageList();\n    (void) SetImageProperty(clone_image,\"tiff:subfiletype\",\"none\",exception);\n    AppendImageToList(&images,clone_image);\n    columns=next->columns;\n    rows=next->rows;\n    resolution=next->resolution;\n    while ((columns > 64) && (rows > 64))\n    {\n      columns/=2;\n      rows/=2;\n      resolution.x/=2;\n      resolution.y/=2;\n      pyramid_image=ResizeImage(next,columns,rows,image->filter,exception);\n      if (pyramid_image == (Image *) NULL)\n        break;\n      pyramid_image->resolution=resolution;\n      (void) SetImageProperty(pyramid_image,\"tiff:subfiletype\",\"REDUCEDIMAGE\",\n        exception);\n      AppendImageToList(&images,pyramid_image);\n    }\n  }\n  status=MagickFalse;\n  if (images != (Image *) NULL)\n    {\n      images=GetFirstImageInList(images);\n      write_info=CloneImageInfo(image_info);\n      write_info->adjoin=MagickTrue;\n      (void) CopyMagickString(write_info->magick,\"TIFF\",MagickPathExtent);\n      (void) CopyMagickString(images->magick,\"TIFF\",MagickPathExtent);\n      status=WriteTIFFImage(write_info,images,exception);\n      images=DestroyImageList(images);\n      write_info=DestroyImageInfo(write_info);\n    }\n  return(status);\n}", "target": 0}
{"code": "gfx::GLSurfaceHandle RenderWidgetHostViewAura::GetCompositingSurface() {\n  return ImageTransportFactory::GetInstance()->GetSharedSurfaceHandle();\n}", "target": 0}
{"code": "static struct media_item *parse_media_element(struct avrcp *session,\n\t\t\t\t\tuint8_t *operands, uint16_t len)\n{\n\tstruct avrcp_player *player;\n\tstruct media_player *mp;\n\tstruct media_item *item;\n\tuint16_t namelen;\n\tchar name[255];\n\tuint64_t uid;\n\tif (len < 13)\n\t\treturn NULL;\n\tuid = get_be64(&operands[0]);\n\tnamelen = MIN(get_be16(&operands[11]), sizeof(name) - 1);\n\tif (namelen > 0) {\n\t\tmemcpy(name, &operands[13], namelen);\n\t\tname[namelen] = '\\0';\n\t}\n\tplayer = session->controller->player;\n\tmp = player->user_data;\n\titem = media_player_create_item(mp, name, PLAYER_ITEM_TYPE_AUDIO, uid);\n\tif (item == NULL)\n\t\treturn NULL;\n\tmedia_item_set_playable(item, true);\n\treturn item;\n}", "target": 0}
{"code": "onigenc_mb4_is_code_ctype(OnigEncoding enc, OnigCodePoint code,\n\t\t\t  unsigned int ctype)\n{\n  if (code < 128)\n    return ONIGENC_IS_ASCII_CODE_CTYPE(code, ctype);\n  else {\n    if (CTYPE_IS_WORD_GRAPH_PRINT(ctype)) {\n      return (ONIGENC_CODE_TO_MBCLEN(enc, code) > 1 ? TRUE : FALSE);\n    }\n  }\n  return FALSE;\n}", "target": 0}
{"code": "void verify_non_filename(const char *prefix, const char *arg)\n{\n\tconst char *name;\n\tstruct stat st;\n\tif (!is_inside_work_tree() || is_inside_git_dir())\n\t\treturn;\n\tif (*arg == '-')\n\t\treturn; \n\tname = prefix ? prefix_filename(prefix, strlen(prefix), arg) : arg;\n\tif (!lstat(name, &st))\n\t\tdie(\"ambiguous argument '%s': both revision and filename\\n\"\n\t\t    \"Use '--' to separate filenames from revisions\", arg);\n\tif (errno != ENOENT && errno != ENOTDIR)\n\t\tdie(\"'%s': %s\", arg, strerror(errno));\n}", "target": 0}
{"code": "njs_string_decode_utf8(njs_vm_t *vm, njs_value_t *value, const njs_str_t *src)\n{\n    size_t     length;\n    njs_str_t  dst;\n    length = njs_decode_utf8_length(src, &dst.length);\n    dst.start = njs_string_alloc(vm, value, dst.length, length);\n    if (njs_fast_path(dst.start != NULL)) {\n        njs_decode_utf8(&dst, src);\n        return NJS_OK;\n    }\n    return NJS_ERROR;\n}", "target": 0}
{"code": "    int Image::pixelHeight() const\n    {\n        return pixelHeight_;\n    }", "target": 0}
{"code": "static inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)\n{\n\tpmd_t pmdval = pmd_read_atomic(pmd);\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tbarrier();\n#endif\n\tif (pmd_none(pmdval) || pmd_trans_huge(pmdval))\n\t\treturn 1;\n\tif (unlikely(pmd_bad(pmdval))) {\n\t\tpmd_clear_bad(pmd);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static inline void perf_cgroup_sched_out(struct task_struct *task,\n\t\t\t\t\t struct task_struct *next)\n{\n\tstruct perf_cgroup *cgrp1;\n\tstruct perf_cgroup *cgrp2 = NULL;\n\tcgrp1 = perf_cgroup_from_task(task);\n\tif (next)\n\t\tcgrp2 = perf_cgroup_from_task(next);\n\tif (cgrp1 != cgrp2)\n\t\tperf_cgroup_switch(task, PERF_CGROUP_SWOUT);\n}", "target": 0}
{"code": "static char *r_buf_read_string (RBuffer *buf, ut64 addr, int len) {\n\tut8 *data = malloc (len);\n\tif (data) {\n\t\tr_buf_read_at (buf, addr, data, len);\n\t\tdata[len-1] = 0;\n\t\treturn data;\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "static inline int open_arg(int flags, int mask)\n{\n\tint n = ACC_MODE(flags);\n\tif (flags & (O_TRUNC | O_CREAT))\n\t\tn |= AUDIT_PERM_WRITE;\n\treturn n & mask;\n}", "target": 0}
{"code": "static int sqfs_get_tokens_length(char **tokens, int count)\n{\n\tint length = 0, i;\n\tfor (i = 0; i < count; i++)\n\t\tlength += strlen(tokens[i]) + 1;\n\treturn length;\n}", "target": 0}
{"code": "void smp_process_dhkey_check(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n uint8_t* p = p_data->p_data;\n  SMP_TRACE_DEBUG(\"%s\", __func__);\n if (smp_command_has_invalid_parameters(p_cb)) {\n    tSMP_INT_DATA smp_int_data;\n    smp_int_data.status = SMP_INVALID_PARAMETERS;\n    smp_sm_event(p_cb, SMP_AUTH_CMPL_EVT, &smp_int_data);\n return;\n }\n if (p != NULL) {\n    STREAM_TO_ARRAY(p_cb->remote_dhkey_check, p, BT_OCTET16_LEN);\n }\n  p_cb->flags |= SMP_PAIR_FLAG_HAVE_PEER_DHK_CHK;\n}", "target": 0}
{"code": "struct anon_vma *find_mergeable_anon_vma(struct vm_area_struct *vma)\n{\n\tstruct vm_area_struct *near;\n\tunsigned long vm_flags;\n\tnear = vma->vm_next;\n\tif (!near)\n\t\tgoto try_prev;\n\tvm_flags = vma->vm_flags & ~(VM_READ|VM_WRITE|VM_EXEC);\n\tvm_flags |= near->vm_flags & (VM_READ|VM_WRITE|VM_EXEC);\n\tif (near->anon_vma && vma->vm_end == near->vm_start &&\n \t\t\tmpol_equal(vma_policy(vma), vma_policy(near)) &&\n\t\t\tcan_vma_merge_before(near, vm_flags,\n\t\t\t\tNULL, vma->vm_file, vma->vm_pgoff +\n\t\t\t\t((vma->vm_end - vma->vm_start) >> PAGE_SHIFT)))\n\t\treturn near->anon_vma;\ntry_prev:\n\tBUG_ON(find_vma_prev(vma->vm_mm, vma->vm_start, &near) != vma);\n\tif (!near)\n\t\tgoto none;\n\tvm_flags = vma->vm_flags & ~(VM_READ|VM_WRITE|VM_EXEC);\n\tvm_flags |= near->vm_flags & (VM_READ|VM_WRITE|VM_EXEC);\n\tif (near->anon_vma && near->vm_end == vma->vm_start &&\n  \t\t\tmpol_equal(vma_policy(near), vma_policy(vma)) &&\n\t\t\tcan_vma_merge_after(near, vm_flags,\n\t\t\t\tNULL, vma->vm_file, vma->vm_pgoff))\n\t\treturn near->anon_vma;\nnone:\n\treturn NULL;\n}", "target": 0}
{"code": "xcrealloc (void *ptr, size_t nmemb, size_t size)\n{\n  if (nmemb >= ~(size_t) 0 / size)\n    {\n      error (_(\"Attempt to re-allocate an array with an excessive number of elements: 0x%lx\\n\"),\n\t     (long) nmemb);\n      xexit (1);\n    }\n  return xrealloc (ptr, nmemb * size);\n}", "target": 0}
{"code": "static int bad_inode_setxattr(struct dentry *dentry, const char *name,\n\t\tconst void *value, size_t size, int flags)\n{\n\treturn -EIO;\n}", "target": 0}
{"code": "void PasswordAutofillAgent::PasswordValueGatekeeper::ShowValue(\n    blink::WebInputElement* element) {\n  if (!element->isNull() && !element->suggestedValue().isEmpty())\n    element->setValue(element->suggestedValue(), true);\n}", "target": 0}
{"code": "is_plain_text_type(char *type)\n{\n    return ((type && strcasecmp(type, \"text/plain\") == 0) ||\n\t    (is_text_type(type) && !is_dump_text_type(type)));\n}", "target": 0}
{"code": "xfs_ifree(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip)\n{\n\tint\t\t\terror;\n\tstruct xfs_icluster\txic = { 0 };\n\tstruct xfs_inode_log_item *iip = ip->i_itemp;\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(VFS_I(ip)->i_nlink == 0);\n\tASSERT(ip->i_df.if_nextents == 0);\n\tASSERT(ip->i_d.di_size == 0 || !S_ISREG(VFS_I(ip)->i_mode));\n\tASSERT(ip->i_d.di_nblocks == 0);\n\terror = xfs_iunlink_remove(tp, ip);\n\tif (error)\n\t\treturn error;\n\terror = xfs_difree(tp, ip->i_ino, &xic);\n\tif (error)\n\t\treturn error;\n\tif (ip->i_df.if_format == XFS_DINODE_FMT_LOCAL) {\n\t\tkmem_free(ip->i_df.if_u1.if_data);\n\t\tip->i_df.if_u1.if_data = NULL;\n\t\tip->i_df.if_bytes = 0;\n\t}\n\tVFS_I(ip)->i_mode = 0;\t\t\n\tip->i_d.di_flags = 0;\n\tip->i_d.di_flags2 = ip->i_mount->m_ino_geo.new_diflags2;\n\tip->i_d.di_dmevmask = 0;\n\tip->i_d.di_forkoff = 0;\t\t\n\tip->i_df.if_format = XFS_DINODE_FMT_EXTENTS;\n\tspin_lock(&iip->ili_lock);\n\tiip->ili_fields &= ~(XFS_ILOG_AOWNER | XFS_ILOG_DOWNER);\n\tspin_unlock(&iip->ili_lock);\n\tVFS_I(ip)->i_generation++;\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\tif (xic.deleted)\n\t\terror = xfs_ifree_cluster(ip, tp, &xic);\n\treturn error;\n}", "target": 0}
{"code": "static void tcp_rcv_nxt_update(struct tcp_sock *tp, u32 seq)\n{\n\tu32 delta = seq - tp->rcv_nxt;\n\tsock_owned_by_me((struct sock *)tp);\n\tu64_stats_update_begin_raw(&tp->syncp);\n\ttp->bytes_received += delta;\n\tu64_stats_update_end_raw(&tp->syncp);\n\ttp->rcv_nxt = seq;\n}", "target": 0}
{"code": "filesystem_create_wait_for_cleartext_device_hook (DBusGMethodInvocation *context,\n                                                  Device *device,\n                                                  gpointer user_data)\n{\n  MkfsLuksData *data = user_data;\n  if (device == NULL)\n    {\n    }\n  else\n    {\n      device_filesystem_create_internal (device,\n                                         data->fstype,\n                                         data->options,\n                                         data->mkfs_hook_func,\n                                         data->mkfs_hook_user_data,\n                                         data->context);\n      mkfse_data_unref (data);\n    }\n}", "target": 0}
{"code": "GF_EXPORT\nBool gf_isom_is_JPEG2000(GF_ISOFile *mov)\n{\n\treturn (mov && mov->is_jp2) ? GF_TRUE : GF_FALSE;", "target": 0}
{"code": "static long vhost_net_ioctl(struct file *f, unsigned int ioctl,\n\t\t\t    unsigned long arg)\n{\n\tstruct vhost_net *n = f->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tu64 __user *featurep = argp;\n\tstruct vhost_vring_file backend;\n\tu64 features;\n\tint r;\n\tswitch (ioctl) {\n\tcase VHOST_NET_SET_BACKEND:\n\t\tif (copy_from_user(&backend, argp, sizeof backend))\n\t\t\treturn -EFAULT;\n\t\treturn vhost_net_set_backend(n, backend.index, backend.fd);\n\tcase VHOST_GET_FEATURES:\n\t\tfeatures = VHOST_NET_FEATURES;\n\t\tif (copy_to_user(featurep, &features, sizeof features))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase VHOST_SET_FEATURES:\n\t\tif (copy_from_user(&features, featurep, sizeof features))\n\t\t\treturn -EFAULT;\n\t\tif (features & ~VHOST_NET_FEATURES)\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn vhost_net_set_features(n, features);\n\tcase VHOST_RESET_OWNER:\n\t\treturn vhost_net_reset_owner(n);\n\tdefault:\n\t\tmutex_lock(&n->dev.mutex);\n\t\tr = vhost_dev_ioctl(&n->dev, ioctl, argp);\n\t\tif (r == -ENOIOCTLCMD)\n\t\t\tr = vhost_vring_ioctl(&n->dev, ioctl, argp);\n\t\telse\n\t\t\tvhost_net_flush(n);\n\t\tmutex_unlock(&n->dev.mutex);\n\t\treturn r;\n\t}\n}", "target": 0}
{"code": "static int slab_mem_going_offline_callback(void *arg)\n{\n\tstruct kmem_cache *s;\n\tdown_read(&slub_lock);\n\tlist_for_each_entry(s, &slab_caches, list)\n\t\tkmem_cache_shrink(s);\n\tup_read(&slub_lock);\n\treturn 0;\n}", "target": 0}
{"code": "void blk_mq_stop_hw_queue(struct blk_mq_hw_ctx *hctx)\n{\n\tcancel_delayed_work(&hctx->run_work);\n\tcancel_delayed_work(&hctx->delay_work);\n\tset_bit(BLK_MQ_S_STOPPED, &hctx->state);\n}", "target": 0}
{"code": "static void usb_net_reset_in_buf(USBNetState *s)\n{\n    s->in_ptr = s->in_len = 0;\n    qemu_flush_queued_packets(qemu_get_queue(s->nic));\n}", "target": 0}
{"code": "ssize_t acpi_debugger_read_cmd(char *buffer, size_t buffer_length)\n{\n\tssize_t ret;\n\tssize_t (*func)(char *, size_t);\n\tstruct module *owner;\n\tif (!acpi_debugger_initialized)\n\t\treturn -ENODEV;\n\tmutex_lock(&acpi_debugger.lock);\n\tif (!acpi_debugger.ops) {\n\t\tret = -ENODEV;\n\t\tgoto err_lock;\n\t}\n\tif (!try_module_get(acpi_debugger.owner)) {\n\t\tret = -ENODEV;\n\t\tgoto err_lock;\n\t}\n\tfunc = acpi_debugger.ops->read_cmd;\n\towner = acpi_debugger.owner;\n\tmutex_unlock(&acpi_debugger.lock);\n\tret = func(buffer, buffer_length);\n\tmutex_lock(&acpi_debugger.lock);\n\tmodule_put(owner);\nerr_lock:\n\tmutex_unlock(&acpi_debugger.lock);\n\treturn ret;\n}", "target": 0}
{"code": "static inline struct nlmsghdr *__nlmsg_put(struct sk_buff *skb, u32 pid,\n\t\t\t\t\t   u32 seq, int type, int payload,\n\t\t\t\t\t   int flags)\n{\n\tstruct nlmsghdr *nlh;\n\tnlh = (struct nlmsghdr *) skb_put(skb, nlmsg_total_size(payload));\n\tnlh->nlmsg_type = type;\n\tnlh->nlmsg_len = nlmsg_msg_size(payload);\n\tnlh->nlmsg_flags = flags;\n\tnlh->nlmsg_pid = pid;\n\tnlh->nlmsg_seq = seq;\n\tmemset((unsigned char *) nlmsg_data(nlh) + payload, 0,\n\t       nlmsg_padlen(payload));\n\treturn nlh;\n}", "target": 0}
{"code": "socket_disconnected (SoupSocket *sock, SoupClientContext *client)\n{\n\tSoupServerPrivate *priv = SOUP_SERVER_GET_PRIVATE (client->server);\n\tpriv->clients = g_slist_remove (priv->clients, client);\n\tg_signal_handlers_disconnect_by_func (sock, socket_disconnected, client);\n\tg_object_unref (sock);\n}", "target": 0}
{"code": "    void Converter::cnvExifFlash(const char* from, const char* to)\n    {\n        Exiv2::ExifData::iterator pos = exifData_->findKey(ExifKey(from));\n        if (pos == exifData_->end() || pos->count() == 0) return;\n        if (!prepareXmpTarget(to)) return;\n        int value = pos->toLong();\n        if (!pos->value().ok()) {\n#ifndef SUPPRESS_WARNINGS\n            EXV_WARNING << \"Failed to convert \" << from << \" to \" << to << \"\\n\";\n#endif\n            return;\n        }\n        (*xmpData_)[\"Xmp.exif.Flash/exif:Fired\"] = static_cast<bool>(value & 1);\n        (*xmpData_)[\"Xmp.exif.Flash/exif:Return\"] = (value >> 1) & 3;\n        (*xmpData_)[\"Xmp.exif.Flash/exif:Mode\"] = (value >> 3) & 3;\n        (*xmpData_)[\"Xmp.exif.Flash/exif:Function\"] = static_cast<bool>((value >> 5) & 1);\n        (*xmpData_)[\"Xmp.exif.Flash/exif:RedEyeMode\"] = static_cast<bool>((value >> 6) & 1);\n        if (erase_) exifData_->erase(pos);\n    }", "target": 0}
{"code": "my_decimal *Item_cache_int::val_decimal(my_decimal *decimal_val)\n{\n  DBUG_ASSERT(fixed == 1);\n  if (!has_value())\n    return NULL;\n  int2my_decimal(E_DEC_FATAL_ERROR, value, unsigned_flag, decimal_val);\n  return decimal_val;\n}", "target": 0}
{"code": "DECLAREwriteFunc(writeBufferToSeparateStrips)\n{\n\tuint32 rowsize = imagewidth * spp;\n\tuint32 rowsperstrip;\n\ttsize_t stripsize = TIFFStripSize(out);\n\ttdata_t obuf;\n\ttstrip_t strip = 0;\n\ttsample_t s;\n\tobuf = _TIFFmalloc(stripsize);\n\tif (obuf == NULL)\n\t\treturn (0);\n\t_TIFFmemset(obuf, 0, stripsize);\n\t(void) TIFFGetFieldDefaulted(out, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n\tfor (s = 0; s < spp; s++) {\n\t\tuint32 row;\n\t\tfor (row = 0; row < imagelength; row += rowsperstrip) {\n\t\t\tuint32 nrows = (row+rowsperstrip > imagelength) ?\n\t\t\t    imagelength-row : rowsperstrip;\n\t\t\ttsize_t stripsize = TIFFVStripSize(out, nrows);\n\t\t\tcpContigBufToSeparateBuf(\n\t\t\t    obuf, (uint8*) buf + row*rowsize + s,\n\t\t\t    nrows, imagewidth, 0, 0, spp, 1);\n\t\t\tif (TIFFWriteEncodedStrip(out, strip++, obuf, stripsize) < 0) {\n\t\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t\t    \"Error, can't write strip %u\",\n\t\t\t\t    strip - 1);\n\t\t\t\t_TIFFfree(obuf);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\t_TIFFfree(obuf);\n\treturn 1;\n}", "target": 0}
{"code": "void CLua::remove_shutdown_listener(lua_shutdown_listener *listener)\n{\n    erase_val(shutdown_listeners, listener);\n}", "target": 0}
{"code": "static __always_inline void slab_lock(struct page *page)\n{\n\tVM_BUG_ON_PAGE(PageTail(page), page);\n\tbit_spin_lock(PG_locked, &page->flags);\n}", "target": 0}
{"code": "crypt_block (unsigned char *buffer, size_t length, char *salt, size_t saltlen,\n             int iter, const void *iv, size_t ivlen,\n             const char *pw, int cipher_algo, int encrypt)\n{\n  gcry_cipher_hd_t chd;\n  int rc;\n  rc = gcry_cipher_open (&chd, cipher_algo, GCRY_CIPHER_MODE_CBC, 0);\n  if (rc)\n    {\n      log_error ( \"gcry_cipher_open failed: %s\\n\", gpg_strerror(rc));\n      wipememory (buffer, length);\n      return;\n    }\n  if (cipher_algo == GCRY_CIPHER_AES128\n      ? set_key_iv_pbes2 (chd, salt, saltlen, iter, iv, ivlen, pw, cipher_algo)\n      : set_key_iv (chd, salt, saltlen, iter, pw,\n                    cipher_algo == GCRY_CIPHER_RFC2268_40? 5:24))\n    {\n      wipememory (buffer, length);\n      goto leave;\n    }\n  rc = encrypt? gcry_cipher_encrypt (chd, buffer, length, NULL, 0)\n              : gcry_cipher_decrypt (chd, buffer, length, NULL, 0);\n  if (rc)\n    {\n      wipememory (buffer, length);\n      log_error ( \"en/de-crytion failed: %s\\n\", gpg_strerror (rc));\n      goto leave;\n    }\n leave:\n  gcry_cipher_close (chd);\n}", "target": 0}
{"code": "int update_server_info(int force)\n{\n\tint errs = 0;\n\terrs = errs | update_info_refs(force);\n\terrs = errs | update_info_packs(force);\n\tunlink_or_warn(git_path(\"info/rev-cache\"));\n\treturn errs;\n}", "target": 0}
{"code": "void RenderView::ClearBlockedContentSettings() {\n  for (size_t i = 0; i < arraysize(content_blocked_); ++i)\n    content_blocked_[i] = false;\n}", "target": 0}
{"code": "int ldb_msg_append_fmt(struct ldb_message *msg, int flags,\n\t\t       const char *attr_name, const char *fmt, ...)\n{\n\tstruct ldb_val val;\n\tva_list ap;\n\tchar *str = NULL;\n\tva_start(ap, fmt);\n\tstr = talloc_vasprintf(msg, fmt, ap);\n\tva_end(ap);\n\tif (str == NULL) {\n\t\treturn LDB_ERR_OPERATIONS_ERROR;\n\t}\n\tval.data   = (uint8_t *)str;\n\tval.length = strlen(str);\n\treturn ldb_msg_append_steal_value(msg, attr_name, &val, flags);\n}", "target": 0}
{"code": "static size_t strlen_url(const char *url, bool relative)\n{\n  const unsigned char *ptr;\n  size_t newlen = 0;\n  bool left = TRUE; \n  const unsigned char *host_sep = (const unsigned char *) url;\n  if(!relative)\n    host_sep = (const unsigned char *) find_host_sep(url);\n  for(ptr = (unsigned char *)url; *ptr; ptr++) {\n    if(ptr < host_sep) {\n      ++newlen;\n      continue;\n    }\n    if(*ptr == ' ') {\n      if(left)\n        newlen += 3;\n      else\n        newlen++;\n      continue;\n    }\n    if (*ptr == '?')\n      left = FALSE;\n    if(urlchar_needs_escaping(*ptr))\n      newlen += 2;\n    newlen++;\n  }\n  return newlen;\n}", "target": 0}
{"code": "DLLEXPORT tjhandle DLLCALL tjInitDecompress(void)\n{\n\ttjinstance *this;\n\tif((this=(tjinstance *)malloc(sizeof(tjinstance)))==NULL)\n\t{\n\t\tsnprintf(errStr, JMSG_LENGTH_MAX,\n\t\t\t\"tjInitDecompress(): Memory allocation failure\");\n\t\treturn NULL;\n\t}\n\tMEMZERO(this, sizeof(tjinstance));\n\treturn _tjInitDecompress(this);\n}", "target": 0}
{"code": "GF_Err gf_isom_get_pixel_aspect_ratio(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 *hSpacing, u32 *vSpacing)\n{\n\tGF_TrackBox *trak;\n\tGF_VisualSampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !hSpacing || !vSpacing) return GF_BAD_PARAM;\n\t*hSpacing = 1;\n\t*vSpacing = 1;\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\tentry = (GF_VisualSampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\tif (entry == NULL) return GF_OK;\n\tif (entry->internal_type==GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\tGF_PixelAspectRatioBox *pasp = (GF_PixelAspectRatioBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_PASP);\n\t\tif (pasp) {\n\t\t\t*hSpacing = pasp->hSpacing;\n\t\t\t*vSpacing = pasp->vSpacing;\n\t\t}\n\t\treturn GF_OK;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n}", "target": 0}
{"code": "static PHP_INI_MH(OnUpdateDisplayErrors)\n{\n\tPG(display_errors) = (zend_bool) php_get_display_errors_mode(ZSTR_VAL(new_value), (int)ZSTR_LEN(new_value));\n\treturn SUCCESS;\n}", "target": 0}
{"code": "str_coderange(VALUE str)\n{\n    int cr = ENC_CODERANGE(str);\n    if (cr == ENC_CODERANGE_UNKNOWN) {\n\tcr = rb_enc_str_coderange(str);\n    }\n    return cr;\n}", "target": 0}
{"code": "NTSTATUS winbindd_lookupsids_recv(struct tevent_req *req,\n\t\t\t\t  struct winbindd_response *response)\n{\n\tstruct winbindd_lookupsids_state *state = tevent_req_data(\n\t\treq, struct winbindd_lookupsids_state);\n\tNTSTATUS status;\n\tchar *result;\n\tuint32_t i;\n\tif (tevent_req_is_nterror(req, &status)) {\n\t\tDEBUG(5, (\"wb_lookupsids failed: %s\\n\", nt_errstr(status)));\n\t\treturn status;\n\t}\n\tresult = talloc_asprintf(response, \"%d\\n\", (int)state->domains->count);\n\tif (result == NULL) {\n\t\treturn NT_STATUS_NO_MEMORY;\n\t}\n\tfor (i=0; i<state->domains->count; i++) {\n\t\tstruct dom_sid_buf sid_str;\n\t\tresult = talloc_asprintf_append_buffer(\n\t\t\tresult, \"%s %s\\n\",\n\t\t\tdom_sid_str_buf(state->domains->domains[i].sid,\n\t\t\t\t\t&sid_str),\n\t\t\tstate->domains->domains[i].name.string);\n\t\tif (result == NULL) {\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\t}\n\tresult = talloc_asprintf_append_buffer(\n\t\tresult, \"%d\\n\", (int)state->names->count);\n\tif (result == NULL) {\n\t\treturn NT_STATUS_NO_MEMORY;\n\t}\n\tfor (i=0; i<state->names->count; i++) {\n\t\tstruct lsa_TranslatedName *name;\n\t\tname = &state->names->names[i];\n\t\tresult = talloc_asprintf_append_buffer(\n\t\t\tresult, \"%d %d %s\\n\",\n\t\t\t(int)name->sid_index, (int)name->sid_type,\n\t\t\tname->name.string);\n\t\tif (result == NULL) {\n\t\t\treturn NT_STATUS_NO_MEMORY;\n\t\t}\n\t}\n\tresponse->extra_data.data = result;\n\tresponse->length += talloc_get_size(result);\n\treturn NT_STATUS_OK;\n}", "target": 0}
{"code": "cdf_getday(int year, int days)\n{\n\tsize_t m;\n\tfor (m = 0; m < sizeof(mdays) / sizeof(mdays[0]); m++) {\n\t\tint sub = mdays[m] + (m == 1 && isleap(year));\n\t\tif (days < sub)\n\t\t\treturn days;\n\t\tdays -= sub;\n\t}\n\treturn days;\n}", "target": 0}
{"code": "vhost_user_send_rarp(struct virtio_net **pdev, struct VhostUserMsg *msg,\n\t\t\tint main_fd __rte_unused)\n{\n\tstruct virtio_net *dev = *pdev;\n\tuint8_t *mac = (uint8_t *)&msg->payload.u64;\n\tstruct rte_vdpa_device *vdpa_dev;\n\tint did = -1;\n\tif (validate_msg_fds(msg, 0) != 0)\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\tVHOST_LOG_CONFIG(DEBUG,\n\t\t\":: mac: %02x:%02x:%02x:%02x:%02x:%02x\\n\",\n\t\tmac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);\n\tmemcpy(dev->mac.addr_bytes, mac, 6);\n\t__atomic_store_n(&dev->broadcast_rarp, 1, __ATOMIC_RELEASE);\n\tdid = dev->vdpa_dev_id;\n\tvdpa_dev = rte_vdpa_get_device(did);\n\tif (vdpa_dev && vdpa_dev->ops->migration_done)\n\t\tvdpa_dev->ops->migration_done(dev->vid);\n\treturn RTE_VHOST_MSG_RESULT_OK;\n}", "target": 0}
{"code": "const char* part_mode_name(enum PartMode pm)\n{\n  switch (pm) {\n  case PART_2Nx2N: return \"2Nx2N\";\n  case PART_2NxN:  return \"2NxN\";\n  case PART_Nx2N:  return \"Nx2N\";\n  case PART_NxN:   return \"NxN\";\n  case PART_2NxnU: return \"2NxnU\";\n  case PART_2NxnD: return \"2NxnD\";\n  case PART_nLx2N: return \"nLx2N\";\n  case PART_nRx2N: return \"nRx2N\";\n  }\n  return \"undefined part mode\";\n}", "target": 0}
{"code": "PHP_FUNCTION(pg_unescape_bytea)\n{\n\tchar *from = NULL, *to = NULL, *tmp = NULL;\n\tsize_t to_len;\n\tint from_len;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\",\n\t\t\t\t\t\t\t  &from, &from_len) == FAILURE) {\n\t\treturn;\n\t}\n#if HAVE_PQUNESCAPEBYTEA\n\ttmp = (char *)PQunescapeBytea((unsigned char*)from, &to_len);\n\tto = estrndup(tmp, to_len);\n\tPQfreemem(tmp);\n#else\n\tto = (char *)php_pgsql_unescape_bytea((unsigned char*)from, &to_len);\n#endif\n\tif (!to) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING,\"Invalid parameter\");\n\t\tRETURN_FALSE;\n\t}\n\tRETVAL_STRINGL(to, to_len, 0);\n}", "target": 0}
{"code": "int LibRaw::is_phaseone_compressed() \n{ \n  return (load_raw == &LibRaw::phase_one_load_raw_c || load_raw == &LibRaw::phase_one_load_raw); \n}", "target": 0}
{"code": "static inline uint16_t nvme_c2h(NvmeCtrl *n, uint8_t *ptr, uint32_t len,\n                                NvmeRequest *req)\n{\n    uint16_t status;\n    status = nvme_map_dptr(n, &req->sg, len, &req->cmd);\n    if (status) {\n        return status;\n    }\n    return nvme_tx(n, &req->sg, ptr, len, NVME_TX_DIRECTION_FROM_DEVICE);\n}", "target": 0}
{"code": "rb_reg_s_alloc(VALUE klass)\n{\n    NEWOBJ_OF(re, struct RRegexp, klass, T_REGEXP | (RGENGC_WB_PROTECTED_REGEXP ? FL_WB_PROTECTED : 0));\n    re->ptr = 0;\n    RB_OBJ_WRITE(re, &re->src, 0);\n    re->usecnt = 0;\n    return (VALUE)re;\n}", "target": 0}
{"code": "static gboolean timeout_cb(gpointer)\n{\n    if (sharedTimerFiredFunction)\n        sharedTimerFiredFunction();\n    return FALSE;\n}", "target": 0}
{"code": "    uint64_t Image::byteSwap8(const DataBuf& buf,size_t offset,bool bSwap) const\n    {\n        uint64_t v;\n        byte*    p = reinterpret_cast<byte *>(&v);\n        for(int i = 0; i < 8; i++)\n            p[i] = buf.pData_[offset + i];\n        return Image::byteSwap(v,bSwap);\n    }", "target": 0}
{"code": "  Expression_Obj Parser::fold_operands(Expression_Obj base, std::vector<Expression_Obj>& operands, std::vector<Operand>& ops, size_t i)\n  {\n    if (String_Schema* schema = Cast<String_Schema>(base)) {\n      if (schema->has_interpolants()) {\n        if (i + 1 < operands.size() && (\n             (ops[0].operand == Sass_OP::EQ)\n          || (ops[0].operand == Sass_OP::ADD)\n          || (ops[0].operand == Sass_OP::DIV)\n          || (ops[0].operand == Sass_OP::MUL)\n          || (ops[0].operand == Sass_OP::NEQ)\n          || (ops[0].operand == Sass_OP::LT)\n          || (ops[0].operand == Sass_OP::GT)\n          || (ops[0].operand == Sass_OP::LTE)\n          || (ops[0].operand == Sass_OP::GTE)\n        )) {\n          Expression_Obj rhs = fold_operands(operands[i], operands, ops, i + 1);\n          rhs = SASS_MEMORY_NEW(Binary_Expression, base->pstate(), ops[0], schema, rhs);\n          return rhs;\n        }\n      }\n    }\n    for (size_t S = operands.size(); i < S; ++i) {\n      if (String_Schema* schema = Cast<String_Schema>(operands[i])) {\n        if (schema->has_interpolants()) {\n          if (i + 1 < S) {\n            Expression_Obj rhs = fold_operands(operands[i+1], operands, ops, i + 2);\n            rhs = SASS_MEMORY_NEW(Binary_Expression, base->pstate(), ops[i], schema, rhs);\n            base = SASS_MEMORY_NEW(Binary_Expression, base->pstate(), ops[i], base, rhs);\n            return base;\n          }\n          base = SASS_MEMORY_NEW(Binary_Expression, base->pstate(), ops[i], base, operands[i]);\n          return base;\n        } else {\n          base = SASS_MEMORY_NEW(Binary_Expression, base->pstate(), ops[i], base, operands[i]);\n        }\n      } else {\n        base = SASS_MEMORY_NEW(Binary_Expression, base->pstate(), ops[i], base, operands[i]);\n      }\n      Binary_Expression* b = Cast<Binary_Expression>(base.ptr());\n      if (b && ops[i].operand == Sass_OP::DIV && b->left()->is_delayed() && b->right()->is_delayed()) {\n        base->is_delayed(true);\n      }\n    }\n    if (Binary_Expression* b = Cast<Binary_Expression>(base)) {\n      if (Cast<Binary_Expression>(b->left())) base->set_delayed(false);\n      if (Cast<Binary_Expression>(b->right())) base->set_delayed(false);\n    }\n    return base;\n  }", "target": 0}
{"code": "int __init if6_proc_init(void)\n{\n\treturn register_pernet_subsys(&if6_proc_net_ops);\n}", "target": 0}
{"code": "static int sr_share_write_word(struct usbnet *dev, int phy, u8 reg,\n\t\t\t       __le16 value)\n{\n\tint ret;\n\tmutex_lock(&dev->phy_mutex);\n\tret = sr_write(dev, SR_EPDR, 2, &value);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\tsr_write_reg(dev, SR_EPAR, phy ? (reg | EPAR_PHY_ADR) : reg);\n\tsr_write_reg(dev, SR_EPCR, phy ? (EPCR_WEP | EPCR_EPOS | EPCR_ERPRW) :\n\t\t    (EPCR_WEP | EPCR_ERPRW));\n\tret = wait_phy_eeprom_ready(dev, phy);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\tsr_write_reg(dev, SR_EPCR, 0x0);\nout_unlock:\n\tmutex_unlock(&dev->phy_mutex);\n\treturn ret;\n}", "target": 0}
{"code": "static PixelList **AcquirePixelListThreadSet(const size_t width,\n  const size_t height)\n{\n  PixelList\n    **pixel_list;\n  ssize_t\n    i;\n  size_t\n    number_threads;\n  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  pixel_list=(PixelList **) AcquireQuantumMemory(number_threads,\n    sizeof(*pixel_list));\n  if (pixel_list == (PixelList **) NULL)\n    return((PixelList **) NULL);\n  (void) memset(pixel_list,0,number_threads*sizeof(*pixel_list));\n  for (i=0; i < (ssize_t) number_threads; i++)\n  {\n    pixel_list[i]=AcquirePixelList(width,height);\n    if (pixel_list[i] == (PixelList *) NULL)\n      return(DestroyPixelListThreadSet(pixel_list));\n  }\n  return(pixel_list);\n}", "target": 0}
{"code": "connection_dirserv_add_dir_bytes_to_outbuf(dir_connection_t *conn)\n{\n  ssize_t bytes;\n  int64_t remaining;\n  bytes = DIRSERV_BUFFER_MIN - buf_datalen(conn->_base.outbuf);\n  tor_assert(bytes > 0);\n  tor_assert(conn->cached_dir);\n  if (bytes < 8192)\n    bytes = 8192;\n  remaining = conn->cached_dir->dir_z_len - conn->cached_dir_offset;\n  if (bytes > remaining)\n    bytes = (ssize_t) remaining;\n  if (conn->zlib_state) {\n    connection_write_to_buf_zlib(\n                             conn->cached_dir->dir_z + conn->cached_dir_offset,\n                             bytes, conn, bytes == remaining);\n  } else {\n    connection_write_to_buf(conn->cached_dir->dir_z + conn->cached_dir_offset,\n                            bytes, TO_CONN(conn));\n  }\n  conn->cached_dir_offset += bytes;\n  if (conn->cached_dir_offset == (int)conn->cached_dir->dir_z_len) {\n    connection_dirserv_finish_spooling(conn);\n    cached_dir_decref(conn->cached_dir);\n    conn->cached_dir = NULL;\n  }\n  return 0;\n}", "target": 0}
{"code": "void InstanceKlass::set_init_state(ClassState state) {\n#ifdef ASSERT\n  bool good_state = is_shared() ? (_init_state <= state)\n                                               : (_init_state < state);\n  assert(good_state || state == allocated, \"illegal state transition\");\n#endif\n  assert(_init_thread == NULL, \"should be cleared before state change\");\n  _init_state = (u1)state;\n}", "target": 0}
{"code": "htp_status_t htp_tx_res_set_header(htp_tx_t *tx, const char *name, size_t name_len,\n        const char *value, size_t value_len, enum htp_alloc_strategy_t alloc) {\n    if ((tx == NULL) || (name == NULL) || (value == NULL)) return HTP_ERROR;\n    htp_header_t *h = calloc(1, sizeof (htp_header_t));\n    if (h == NULL) return HTP_ERROR;\n    h->name = copy_or_wrap_mem(name, name_len, alloc);\n    if (h->name == NULL) {\n        free(h);\n        return HTP_ERROR;\n    }\n    h->value = copy_or_wrap_mem(value, value_len, alloc);\n    if (h->value == NULL) {\n        bstr_free(h->name);\n        free(h);\n        return HTP_ERROR;\n    }\n    if (htp_table_add(tx->response_headers, h->name, h) != HTP_OK) {\n        bstr_free(h->name);\n        bstr_free(h->value);\n        free(h);\n        return HTP_ERROR;\n    }\n    return HTP_OK;\n}", "target": 0}
{"code": "int snd_timer_global_register(struct snd_timer *timer)\n{\n\tstruct snd_device dev;\n\tmemset(&dev, 0, sizeof(dev));\n\tdev.device_data = timer;\n\treturn snd_timer_dev_register(&dev);\n}", "target": 0}
{"code": "void FrameLoader::loadDone()\n{\n    checkCompleted();\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, EmptyQueryWithProjectionDoesNotConsiderNonHintedIndices) {\n    params.options = QueryPlannerParams::GENERATE_COVERED_IXSCANS;\n    addIndex(BSON(\"a\" << 1));\n    runQueryAsCommand(fromjson(\"{find: 'testns', projection: {_id: 0, a: 1}, hint: {_id: 1}}\"));\n    assertNumSolutions(1);\n    assertSolutionExists(\n        \"{proj: {spec: {_id: 0, a: 1}, node: \"\n        \"{fetch: {filter: null, node: \"\n        \"{ixscan: {filter: null, pattern: {_id: 1}, \"\n        \"bounds: {_id: [['MinKey', 'MaxKey', true, true]]}}}}}}}\");\n}", "target": 0}
{"code": "_gnutls_x509_decode_string(unsigned int etype,\n\t\t\t   const uint8_t * der, size_t der_size,\n\t\t\t   gnutls_datum_t * output, unsigned allow_ber)\n{\n\tint ret;\n\tuint8_t *str;\n\tunsigned int str_size, len;\n\tgnutls_datum_t td;\n#ifdef HAVE_ASN1_DECODE_SIMPLE_BER\n\tif (allow_ber)\n\t\tret =\n\t\t    asn1_decode_simple_ber(etype, der, der_size, &str, &str_size, NULL);\n\telse\n#endif\n\t\tret =\n\t\t    asn1_decode_simple_der(etype, der, der_size, (const uint8_t**)&str, &str_size);\n\tif (ret != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\tret = _gnutls_asn2err(ret);\n\t\treturn ret;\n\t}\n\ttd.size = str_size;\n\ttd.data = gnutls_malloc(str_size + 1);\n\tif (td.data == NULL)\n\t\treturn gnutls_assert_val(GNUTLS_E_MEMORY_ERROR);\n\tmemcpy(td.data, str, str_size);\n\ttd.data[str_size] = 0;\n#ifdef HAVE_ASN1_DECODE_SIMPLE_BER\n\tif (allow_ber)\n\t\tfree(str);\n#endif\n\tret = make_printable_string(etype, &td, output);\n\tif (ret == GNUTLS_E_INVALID_REQUEST) {\t\n\t\toutput->data = td.data;\n\t\toutput->size = td.size;\n\t\tret = 0;\n\t} else if (ret <= 0) {\n\t\t_gnutls_free_datum(&td);\n\t}\n\tif (etype != ASN1_ETYPE_OCTET_STRING) {\n\t\tif (output->data)\n\t\t\tlen = strlen((void *) output->data);\n\t\telse\n\t\t\tlen = 0;\n\t\tif (len != (size_t) output->size) {\n\t\t\t_gnutls_free_datum(output);\n\t\t\tret = gnutls_assert_val(GNUTLS_E_ASN1_DER_ERROR);\n\t\t}\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "    uint32_t TiffMnEntry::doWrite(IoWrapper& ioWrapper,\n                                  ByteOrder byteOrder,\n                                  int32_t   offset,\n                                  uint32_t  valueIdx,\n                                  uint32_t  dataIdx,\n                                  uint32_t& imageIdx)\n    {\n        if (!mn_) {\n            return TiffEntryBase::doWrite(ioWrapper, byteOrder, offset, valueIdx, dataIdx, imageIdx);\n        }\n        return mn_->write(ioWrapper, byteOrder, offset + valueIdx, uint32_t(-1), uint32_t(-1), imageIdx);\n    } ", "target": 0}
{"code": "int fuse_fs_mknod(struct fuse_fs *fs, const char *path, mode_t mode,\n                  dev_t rdev)\n{\n    fuse_get_context()->private_data = fs->user_data;\n    if (fs->op.mknod)\n        return fs->op.mknod(path, mode, rdev);\n    else\n        return -ENOSYS;\n}", "target": 0}
{"code": "coolkey_add_object(coolkey_private_data_t *priv, unsigned long object_id, const u8 *object_data, size_t object_length, int add_v1_record)\n{\n\tsc_cardctl_coolkey_object_t new_object;\n\tint r;\n\tmemset(&new_object, 0, sizeof(new_object));\n\tnew_object.path = coolkey_template_path;\n\tnew_object.path.len = 4;\n\tulong2bebytes(new_object.path.value, object_id);\n\tnew_object.id = object_id;\n\tnew_object.length = object_length;\n\tif (object_data) {\n\t\tnew_object.data = malloc(object_length + add_v1_record);\n\t\tif (new_object.data == NULL) {\n\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\t}\n\t\tif (add_v1_record) {\n\t\t\tnew_object.data[0] = COOLKEY_V1_OBJECT;\n\t\t\tnew_object.length++;\n\t\t}\n\t\tmemcpy(&new_object.data[add_v1_record], object_data, object_length);\n\t}\n\tr = coolkey_add_object_to_list(&priv->objects_list, &new_object);\n\tif (r != SC_SUCCESS) {\n\t\tfree(new_object.data);\n\t\tnew_object.data = NULL;\n\t}\n\treturn r;\n}", "target": 0}
{"code": "ClientUsageTracker::~ClientUsageTracker() {\n  if (special_storage_policy_)\n    special_storage_policy_->RemoveObserver(this);\n}", "target": 0}
{"code": "static inline u32 nfsd4_write_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + 2 + op_encode_verifier_maxsz) * sizeof(__be32);\n}", "target": 0}
{"code": "luks_unlock_device_added_cb (Daemon *daemon,\n                             const char *object_path,\n                             gpointer user_data)\n{\n  UnlockEncryptionData *data = user_data;\n  Device *device;\n  device = daemon_local_find_by_object_path (daemon, object_path);\n  if (device != NULL && device->priv->device_is_luks_cleartext && strcmp (device->priv->luks_cleartext_slave,\n                                                                          data->device->priv->object_path) == 0)\n    {\n      g_signal_handler_disconnect (daemon, data->device_added_signal_handler_id);\n      g_signal_handler_disconnect (daemon, data->device_changed_signal_handler_id);\n      g_source_remove (data->device_added_timeout_id);\n      update_info (data->device);\n      drain_pending_changes (data->device, FALSE);\n      if (data->hook_func != NULL)\n        {\n          data->hook_func (data->context, device, data->hook_user_data);\n        }\n      else\n        {\n          dbus_g_method_return (data->context, object_path);\n        }\n      unlock_encryption_data_unref (data);\n    }\n}", "target": 0}
{"code": "void InstanceKlass::initialize(TRAPS) {\n  if (this->should_be_initialized()) {\n    initialize_impl(CHECK);\n  } else {\n    assert(is_initialized(), \"sanity check\");\n  }\n}", "target": 0}
{"code": "    std::string getExifModel(Exiv2::Internal::TiffComponent* const pRoot)\n    {\n        Exiv2::Internal::TiffFinder finder(0x0110, Exiv2::Internal::ifd0Id); \n        pRoot->accept(finder);\n        Exiv2::Internal::TiffEntryBase* te = dynamic_cast<Exiv2::Internal::TiffEntryBase*>(finder.result());\n        if (!te || !te->pValue() || te->pValue()->count() == 0) return std::string();\n        return te->pValue()->toString();\n    }", "target": 0}
{"code": "static void parse_cmdline(int argc, char **argv, int pass)\n{\n    FILE *rfile;\n    char *envreal, *envcopy = NULL, *p;\n    int i;\n    for (i = 0; i < ERR_WARN_ALL; i++) {\n        warning_state_init[i] = warning_state[i] =\n\t    warnings[i].enabled ? WARN_ST_ENABLED : 0;\n    }\n    envreal = getenv(\"NASMENV\");\n    if (envreal) {\n        envcopy = nasm_strdup(envreal);\n        process_args(envcopy, pass);\n        nasm_free(envcopy);\n    }\n    while (--argc) {\n        bool advance;\n        argv++;\n        if (argv[0][0] == '@') {\n            process_response_file(argv[0]+1, pass);\n            argc--;\n            argv++;\n        }\n        if (!stopoptions && argv[0][0] == '-' && argv[0][1] == '@') {\n            p = get_param(argv[0], argc > 1 ? argv[1] : NULL, &advance);\n            if (p) {\n                rfile = nasm_open_read(p, NF_TEXT);\n                if (rfile) {\n                    process_respfile(rfile, pass);\n                    fclose(rfile);\n                } else\n                    nasm_error(ERR_NONFATAL | ERR_NOFILE | ERR_USAGE,\n                                 \"unable to open response file `%s'\", p);\n            }\n        } else\n            advance = process_arg(argv[0], argc > 1 ? argv[1] : NULL, pass);\n        argv += advance, argc -= advance;\n    }\n    if (pass != 2)\n        return;\n    if (!inname)\n        nasm_fatal(ERR_NOFILE | ERR_USAGE, \"no input file specified\");\n    else if ((errname && !strcmp(inname, errname)) ||\n             (outname && !strcmp(inname, outname)) ||\n             (listname &&  !strcmp(inname, listname))  ||\n             (depend_file && !strcmp(inname, depend_file)))\n        nasm_fatal(ERR_USAGE, \"will not overwrite input file\");\n    if (errname) {\n        error_file = nasm_open_write(errname, NF_TEXT);\n        if (!error_file) {\n            error_file = stderr;        \n            nasm_fatal(ERR_NOFILE | ERR_USAGE,\n                       \"cannot open file `%s' for error messages\",\n                       errname);\n        }\n    }\n}", "target": 0}
{"code": "int sqlite3_zipfile_init(\n  sqlite3 *db, \n  char **pzErrMsg, \n  const sqlite3_api_routines *pApi\n){\n  SQLITE_EXTENSION_INIT2(pApi);\n  (void)pzErrMsg;  \n  return zipfileRegister(db);\n}", "target": 0}
{"code": "static int err_attr_cb(const struct nlattr *attr, void *data)\n{\n\tconst struct nlattr **tb = data;\n\tuint16_t type;\n\tif (mnl_attr_type_valid(attr, NLMSGERR_ATTR_MAX) < 0) {\n\t\tfprintf(stderr, \"Invalid extack attribute\\n\");\n\t\treturn MNL_CB_ERROR;\n\t}\n\ttype = mnl_attr_get_type(attr);\n\tif (mnl_attr_validate(attr, extack_policy[type]) < 0) {\n\t\tfprintf(stderr, \"extack attribute %d failed validation\\n\",\n\t\t\ttype);\n\t\treturn MNL_CB_ERROR;\n\t}\n\ttb[type] = attr;\n\treturn MNL_CB_OK;\n}", "target": 0}
{"code": "njs_eval_function(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_internal_error(vm, \"Not implemented\");\n    return NJS_ERROR;\n}", "target": 0}
{"code": "static bool emulator_get_segment(struct x86_emulate_ctxt *ctxt, u16 *selector,\n\t\t\t\t struct desc_struct *desc, u32 *base3,\n\t\t\t\t int seg)\n{\n\tstruct kvm_segment var;\n\tkvm_get_segment(emul_to_vcpu(ctxt), &var, seg);\n\t*selector = var.selector;\n\tif (var.unusable) {\n\t\tmemset(desc, 0, sizeof(*desc));\n\t\treturn false;\n\t}\n\tif (var.g)\n\t\tvar.limit >>= 12;\n\tset_desc_limit(desc, var.limit);\n\tset_desc_base(desc, (unsigned long)var.base);\n#ifdef CONFIG_X86_64\n\tif (base3)\n\t\t*base3 = var.base >> 32;\n#endif\n\tdesc->type = var.type;\n\tdesc->s = var.s;\n\tdesc->dpl = var.dpl;\n\tdesc->p = var.present;\n\tdesc->avl = var.avl;\n\tdesc->l = var.l;\n\tdesc->d = var.db;\n\tdesc->g = var.g;\n\treturn true;\n}", "target": 0}
{"code": "static Token **count_mmac_params(Token *tline, int *nparamp, Token ***paramsp)\n{\n    int paramsize;\n    int nparam = 0;\n    Token *t;\n    Token **comma = NULL, **maybe_comma = NULL;\n    Token **params;\n    paramsize = PARAM_DELTA;\n    nasm_newn(params, paramsize);\n    t = skip_white(tline);\n    if (t) {\n        while (true) {\n            if (unlikely(nparam+2 >= paramsize)) {\n                paramsize += PARAM_DELTA;\n                params = nasm_realloc(params, sizeof(*params) * paramsize);\n            }\n            params[++nparam] = t;\n            if (tok_is(t, '{')) {\n                int brace = 1;\n                comma = NULL;   \n                while (brace && (t = t->next)) {\n                    brace += tok_is(t, '{');\n                    brace -= tok_is(t, '}');\n                }\n                if (t) {\n                    t = skip_white(t->next);\n                    if (tok_isnt(t, ','))\n                        nasm_nonfatal(\"braces do not enclose all of macro parameter\");\n                } else {\n                    nasm_nonfatal(\"expecting closing brace in macro parameter\");\n                }\n            }\n            maybe_comma = &t->next;\n            while (tok_isnt(t, ',')) {\n                if (!tok_white(t))\n                    comma = NULL; \n                maybe_comma = &t->next;\n                t = t->next;\n            }\n            if (!t)\n                break;              \n            comma = maybe_comma;     \n            t = skip_white(t->next); \n        }\n    }\n    params[nparam+1] = NULL;\n    *paramsp = params;\n    *nparamp = nparam;\n    return comma;\n}", "target": 0}
{"code": "static int Get16m(const void * Short)\n{\n    return (((uchar *)Short)[0] << 8) | ((uchar *)Short)[1];\n}", "target": 0}
{"code": "fbFetch_b5g6r5 (const FbBits *bits, int x, int width, CARD32 *buffer, miIndexedPtr indexed)\n{\n    const CARD16 *pixel = (const CARD16 *)bits + x;\n    const CARD16 *end = pixel + width;\n    while (pixel < end) {\n        CARD32  p = READ(pixel++);\n        CARD32  r,g,b;\n        b = ((p & 0xf800) | ((p & 0xe000) >> 5)) >> 8;\n        g = ((p & 0x07e0) | ((p & 0x0600) >> 6)) << 5;\n        r = ((p & 0x001c) | ((p & 0x001f) << 5)) << 14;\n        WRITE(buffer++, (0xff000000 | r | g | b));\n    }\n}", "target": 0}
{"code": "    int Insert::insertIccProfile(const std::string& path, const std::string& iccPath) const\n    {\n        int rc = 0;\n        std::string iccProfilePath = newFilePath(path, \".icc\");\n        if (iccPath == \"-\") {\n            Exiv2::DataBuf iccProfile;\n            Params::instance().getStdin(iccProfile);\n            rc = insertIccProfile(path, iccProfile);\n        } else {\n            if (!Exiv2::fileExists(iccProfilePath, true)) {\n                std::cerr << iccProfilePath << \": \" << _(\"Failed to open the file\\n\");\n                rc = -1;\n            } else {\n                Exiv2::DataBuf iccProfile = Exiv2::readFile(iccPath);\n                rc = insertIccProfile(path, iccProfile);\n            }\n        }\n        return rc;\n    }", "target": 0}
{"code": "OfflineAudioDestinationHandler::Create(AudioNode& node,\n                                       unsigned number_of_channels,\n                                       uint32_t frames_to_process,\n                                       float sample_rate) {\n  return base::AdoptRef(new OfflineAudioDestinationHandler(\n      node, number_of_channels, frames_to_process, sample_rate));\n}", "target": 0}
{"code": "void _WM_do_meta_smpteoffset(struct _mdi *mdi, struct _event_data *data) {\n#ifdef DEBUG_MIDI\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__, ch, data->data.value);\n#else\n    UNUSED(data);\n#endif\n    UNUSED(mdi);\n    return;\n}", "target": 0}
{"code": "fz_cmm_avoid_white_fix_flag(fz_context *ctx)\n{\n\tif (ctx && ctx->colorspace && ctx->colorspace->cmm && ctx->cmm_instance)\n\t\treturn ctx->colorspace->cmm->avoid_white_fix_flag;\n\treturn 0;\n}", "target": 0}
{"code": "rb_head_page_deactivate(struct ring_buffer_per_cpu *cpu_buffer)\n{\n\tstruct list_head *hd;\n\trb_list_head_clear(cpu_buffer->pages);\n\tlist_for_each(hd, cpu_buffer->pages)\n\t\trb_list_head_clear(hd);\n}", "target": 0}
{"code": "uipbuf_set_len_field(struct uip_ip_hdr *hdr, uint16_t len)\n{\n  hdr->len[0] = (len >> 8);\n  hdr->len[1] = (len & 0xff);\n}", "target": 0}
{"code": "const GURL& WebContentsImpl::GetURL() const {\n  NavigationEntry* entry = controller_.GetVisibleEntry();\n  return entry ? entry->GetVirtualURL() : GURL::EmptyGURL();\n}", "target": 0}
{"code": "int DNS::PruneCache()\n{\n\tint n = 0;\n\tdnscache* newcache = new dnscache();\n\tfor (dnscache::iterator i = this->cache->begin(); i != this->cache->end(); i++)\n\t\tif (i->second.CalcTTLRemaining())\n\t\t\tnewcache->insert(*i);\n\t\telse\n\t\t\tn++;\n\tdelete this->cache;\n\tthis->cache = newcache;\n\treturn n;\n}", "target": 0}
{"code": "void close_thread_table(THD *thd, TABLE **table_ptr)\n{\n  TABLE *table= *table_ptr;\n  DBUG_ENTER(\"close_thread_table\");\n  DBUG_PRINT(\"tcache\", (\"table: '%s'.'%s' %p\", table->s->db.str,\n                        table->s->table_name.str, table));\n  DBUG_ASSERT(!table->file->keyread_enabled());\n  DBUG_ASSERT(!table->file || table->file->inited == handler::NONE);\n  DBUG_ASSERT(thd->mdl_context.is_lock_owner(MDL_key::TABLE,\n                                             table->s->db.str,\n                                             table->s->table_name.str,\n                                             MDL_SHARED));\n  table->mdl_ticket= NULL;\n  if (table->file)\n  {\n    table->file->update_global_table_stats();\n    table->file->update_global_index_stats();\n  }\n  mysql_mutex_lock(&thd->LOCK_thd_data);\n  *table_ptr=table->next;\n  mysql_mutex_unlock(&thd->LOCK_thd_data);\n  if (! table->needs_reopen())\n  {\n    table->file->extra(HA_EXTRA_DETACH_CHILDREN);\n    free_field_buffers_larger_than(table, MAX_TDC_BLOB_SIZE);\n    table->file->ha_reset();\n  }\n  MYSQL_UNBIND_TABLE(table->file);\n  tc_release_table(table);\n  DBUG_VOID_RETURN;\n}", "target": 0}
{"code": "void vhost_poll_init(struct vhost_poll *poll, vhost_work_fn_t fn,\n\t\t     unsigned long mask, struct vhost_dev *dev)\n{\n\tinit_waitqueue_func_entry(&poll->wait, vhost_poll_wakeup);\n\tinit_poll_funcptr(&poll->table, vhost_poll_func);\n\tpoll->mask = mask;\n\tpoll->dev = dev;\n\tvhost_work_init(&poll->work, fn);\n}", "target": 0}
{"code": "static int sg_proc_seq_show_devstrs(struct seq_file *s, void *v)\n{\n\tstruct sg_proc_deviter * it = (struct sg_proc_deviter *) v;\n\tSg_device *sdp;\n\tstruct scsi_device *scsidp;\n\tunsigned long iflags;\n\tread_lock_irqsave(&sg_index_lock, iflags);\n\tsdp = it ? sg_lookup_dev(it->index) : NULL;\n\tscsidp = sdp ? sdp->device : NULL;\n\tif (sdp && scsidp && (!atomic_read(&sdp->detaching)))\n\t\tseq_printf(s, \"%8.8s\\t%16.16s\\t%4.4s\\n\",\n\t\t\t   scsidp->vendor, scsidp->model, scsidp->rev);\n\telse\n\t\tseq_puts(s, \"<no active device>\\n\");\n\tread_unlock_irqrestore(&sg_index_lock, iflags);\n\treturn 0;\n}", "target": 0}
{"code": "soup_server_remove_handler (SoupServer *server, const char *path)\n{\n\tSoupServerPrivate *priv;\n\tSoupServerHandler *hand;\n\tg_return_if_fail (SOUP_IS_SERVER (server));\n\tpriv = SOUP_SERVER_GET_PRIVATE (server);\n\tif (!path || !*path || !strcmp (path, \"/\")) {\n\t\tif (priv->default_handler) {\n\t\t\tunregister_handler (priv->default_handler);\n\t\t\tfree_handler (priv->default_handler);\n\t\t\tpriv->default_handler = NULL;\n\t\t}\n\t\treturn;\n\t}\n\thand = soup_path_map_lookup (priv->handlers, path);\n\tif (hand && !strcmp (path, hand->path)) {\n\t\tunregister_handler (hand);\n\t\tsoup_path_map_remove (priv->handlers, path);\n\t}\n}", "target": 0}
{"code": "    template<typename tp, typename tf, typename tc, typename tz>\n    CImg<T>& draw_object3d(const float x0, const float y0, const float z0,\n                           const CImg<tp>& vertices, const CImgList<tf>& primitives,\n                           const CImgList<tc>& colors,\n                           const unsigned int render_type,\n                           const bool is_double_sided, const float focale,\n                           const float lightx, const float lighty, const float lightz,\n                           const float specular_lightness, const float specular_shininess,\n                           CImg<tz>& zbuffer) {\n      return draw_object3d(x0,y0,z0,vertices,primitives,colors,CImg<floatT>::const_empty(),\n                           render_type,is_double_sided,focale,lightx,lighty,lightz,\n                           specular_lightness,specular_shininess,zbuffer);", "target": 0}
{"code": "device_generate_kernel_change_event (Device *device)\n{\n  FILE *f;\n  char *filename;\n  filename = g_build_filename (device->priv->native_path, \"uevent\", NULL);\n  f = fopen (filename, \"w\");\n  if (f == NULL)\n    {\n      g_warning (\"error opening %s for writing: %m\", filename);\n    }\n  else\n    {\n      if (fputs (\"change\", f) == EOF)\n        {\n          g_warning (\"error writing 'change' to %s: %m\", filename);\n        }\n      fclose (f);\n    }\n  g_free (filename);\n}", "target": 0}
{"code": "static void\nS_unwind_scan_frames(pTHX_ const void *p)\n{\n    scan_frame *f= (scan_frame *)p;\n    do {\n        scan_frame *n= f->next_frame;\n        Safefree(f);\n        f= n;\n    } while (f);", "target": 0}
{"code": "void GLES2DecoderImpl::DoUniform1iv(\n    GLint location, GLsizei count, const GLint *value) {\n  if (!CheckCurrentProgramForUniform(location, \"glUniform1iv\")) {\n    return;\n  }\n  current_program_->SetSamplers(location, count, value);\n  glUniform1iv(location, count, value);\n}", "target": 0}
{"code": "void IMA::reset1()\n{\n\tAFframecount nextTrackFrame = m_track->nextfframe;\n\tm_track->nextfframe = (nextTrackFrame / m_framesPerBlock) *\n\t\tm_framesPerBlock;\n\tm_framesToIgnore = nextTrackFrame - m_track->nextfframe;\n}", "target": 0}
{"code": "void HTMLSelectElement::setMultiple(bool multiple)\n{\n    bool oldMultiple = this->multiple();\n    int oldSelectedIndex = selectedIndex();\n    setAttribute(multipleAttr, multiple ? emptyAtom : nullAtom);\n    if (oldMultiple != this->multiple())\n        setSelectedIndex(oldSelectedIndex);\n}", "target": 0}
{"code": "static HashTable *spl_object_storage_get_gc(zval *obj, zval ***table, int *n TSRMLS_DC) \n{\n\tspl_SplObjectStorage *intern = (spl_SplObjectStorage*)zend_object_store_get_object(obj TSRMLS_CC);\n\tspl_SplObjectStorageElement *element;\n\tHashTable *props;\n\tHashPosition pos;\n\tzval *gcdata_arr = NULL,\n\t\t **gcdata_arr_pp;\n\tprops = std_object_handlers.get_properties(obj TSRMLS_CC);\n\t*table = NULL;\n\t*n = 0;\n\tif (zend_hash_find(props, \"\\x00gcdata\", sizeof(\"\\x00gcdata\"), (void**) &gcdata_arr_pp) == SUCCESS) {\n\t\tgcdata_arr = *gcdata_arr_pp;\n\t\tzend_hash_clean(Z_ARRVAL_P(gcdata_arr));\n\t}\n\tif (gcdata_arr == NULL) {\n\t\tMAKE_STD_ZVAL(gcdata_arr);\n\t\tarray_init(gcdata_arr);\n\t\tZ_ARRVAL_P(gcdata_arr)->pDestructor = NULL;\n\t\tzend_hash_add(props, \"\\x00gcdata\", sizeof(\"\\x00gcdata\"), &gcdata_arr, sizeof(gcdata_arr), NULL);\n\t}\n\tzend_hash_internal_pointer_reset_ex(&intern->storage, &pos);\n\twhile (zend_hash_get_current_data_ex(&intern->storage, (void **)&element, &pos) == SUCCESS) {\n\t\tadd_next_index_zval(gcdata_arr, element->obj);\n\t\tadd_next_index_zval(gcdata_arr, element->inf);\n\t\tzend_hash_move_forward_ex(&intern->storage, &pos);\n\t}\n\treturn props;\n}", "target": 0}
{"code": "fbFetch_r3g3b2 (const FbBits *bits, int x, int width, CARD32 *buffer, miIndexedPtr indexed)\n{\n    const CARD8 *pixel = (const CARD8 *)bits + x;\n    const CARD8 *end = pixel + width;\n    while (pixel < end) {\n        CARD32  p = READ(pixel++);\n        CARD32  r,g,b;\n        r = ((p & 0xe0) | ((p & 0xe0) >> 3) | ((p & 0xc0) >> 6)) << 16;\n        g = ((p & 0x1c) | ((p & 0x18) >> 3) | ((p & 0x1c) << 3)) << 8;\n        b = (((p & 0x03)     ) |\n             ((p & 0x03) << 2) |\n             ((p & 0x03) << 4) |\n             ((p & 0x03) << 6));\n        WRITE(buffer++, (0xff000000 | r | g | b));\n    }\n}", "target": 0}
{"code": "virSecuritySELinuxSetHostdevLabel(virSecurityManager *mgr,\n                                  virDomainDef *def,\n                                  virDomainHostdevDef *dev,\n                                  const char *vroot)\n{\n    virSecurityLabelDef *secdef;\n    secdef = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n    if (!secdef || !secdef->relabel)\n        return 0;\n    switch (dev->mode) {\n    case VIR_DOMAIN_HOSTDEV_MODE_SUBSYS:\n        return virSecuritySELinuxSetHostdevSubsysLabel(mgr, def, dev, vroot);\n    case VIR_DOMAIN_HOSTDEV_MODE_CAPABILITIES:\n        return virSecuritySELinuxSetHostdevCapsLabel(mgr, def, dev, vroot);\n    default:\n        return 0;\n    }\n}", "target": 0}
{"code": "MenuCacheDir* menu_cache_dup_root_dir( MenuCache* cache )\n{\n    MenuCacheDir* dir;\n    MENU_CACHE_LOCK;\n    dir = cache->root_dir;\n    if(G_LIKELY(dir))\n        menu_cache_item_ref(MENU_CACHE_ITEM(dir));\n    MENU_CACHE_UNLOCK;\n    return dir;\n}", "target": 0}
{"code": "SProcRecordDisableContext(ClientPtr client)\n{\n    REQUEST(xRecordDisableContextReq);\n    swaps(&stuff->length);\n    REQUEST_SIZE_MATCH(xRecordDisableContextReq);\n    swapl(&stuff->context);\n    return ProcRecordDisableContext(client);\n}                               ", "target": 0}
{"code": "static void discard_receive_data(int f_in, OFF_T length)\n{\n\treceive_data(f_in, NULL, -1, 0, NULL, -1, length);\n}", "target": 0}
{"code": "static void default_local_infile_end(void *ptr)\n{\n  default_local_infile_data *data= (default_local_infile_data *) ptr;\n  if (data)\t\t\t\t\t\n  {\n    if (data->fd >= 0)\n      my_close(data->fd, MYF(MY_WME));\n    my_free(ptr);\n  }\n}", "target": 0}
{"code": "void CSSStyleSheet::addSubresourceStyleURLs(ListHashSet<KURL>& urls)\n{\n    Deque<CSSStyleSheet*> styleSheetQueue;\n    styleSheetQueue.append(this);\n    while (!styleSheetQueue.isEmpty()) {\n        CSSStyleSheet* styleSheet = styleSheetQueue.takeFirst();\n        for (unsigned i = 0; i < styleSheet->length(); ++i) {\n            StyleBase* styleBase = styleSheet->item(i);\n            if (!styleBase->isRule())\n                continue;\n            CSSRule* rule = static_cast<CSSRule*>(styleBase);\n            if (rule->isImportRule()) {\n                if (CSSStyleSheet* ruleStyleSheet = static_cast<CSSImportRule*>(rule)->styleSheet())\n                    styleSheetQueue.append(ruleStyleSheet);\n            }\n            rule->addSubresourceStyleURLs(urls);\n        }\n    }\n}", "target": 0}
{"code": "*/\nPHP_FUNCTION(timezone_name_get)\n{\n\tzval             *object;\n\tphp_timezone_obj *tzobj;\n\tif (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"O\", &object, date_ce_timezone) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\ttzobj = (php_timezone_obj *) zend_object_store_get_object(object TSRMLS_CC);\n\tDATE_CHECK_INITIALIZED(tzobj->initialized, DateTimeZone);\n\tswitch (tzobj->type) {\n\t\tcase TIMELIB_ZONETYPE_ID:\n\t\t\tRETURN_STRING(tzobj->tzi.tz->name, 1);\n\t\t\tbreak;\n\t\tcase TIMELIB_ZONETYPE_OFFSET: {\n\t\t\tchar *tmpstr = emalloc(sizeof(\"UTC+05:00\"));\n\t\t\ttimelib_sll utc_offset = tzobj->tzi.utc_offset;\n\t\t\tsnprintf(tmpstr, sizeof(\"+05:00\"), \"%c%02d:%02d\",\n\t\t\t\tutc_offset > 0 ? '-' : '+',\n\t\t\t\tabs(utc_offset / 60),\n\t\t\t\tabs((utc_offset % 60)));\n\t\t\tRETURN_STRING(tmpstr, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase TIMELIB_ZONETYPE_ABBR:\n\t\t\tRETURN_STRING(tzobj->tzi.z.abbr, 1);\n\t\t\tbreak;\n\t}", "target": 0}
{"code": "kgid_t make_kgid(struct user_namespace *ns, gid_t gid)\n{\n\treturn KGIDT_INIT(map_id_down(&ns->gid_map, gid));\n}", "target": 0}
{"code": "ephy_embed_single_get_network_status (EphyEmbedSingle *single)\n{\n  return single->priv->online;\n}", "target": 0}
{"code": "static int panic_op_read_handler(char *buffer, const struct kernel_param *kp)\n{\n\tswitch (ipmi_send_panic_event) {\n\tcase IPMI_SEND_PANIC_EVENT_NONE:\n\t\tstrcpy(buffer, \"none\");\n\t\tbreak;\n\tcase IPMI_SEND_PANIC_EVENT:\n\t\tstrcpy(buffer, \"event\");\n\t\tbreak;\n\tcase IPMI_SEND_PANIC_EVENT_STRING:\n\t\tstrcpy(buffer, \"string\");\n\t\tbreak;\n\tdefault:\n\t\tstrcpy(buffer, \"???\");\n\t\tbreak;\n\t}\n\treturn strlen(buffer);\n}", "target": 0}
{"code": "XkbComputeGetIndicatorMapReplySize(\n    XkbIndicatorPtr\t\tindicators,\n    xkbGetIndicatorMapReply\t*rep)\n{\nregister int \ti,bit;\nint\t\tnIndicators;\n    rep->realIndicators = indicators->phys_indicators;\n    for (i=nIndicators=0,bit=1;i<XkbNumIndicators;i++,bit<<=1) {\n\tif (rep->which&bit)\n\t    nIndicators++;\n    }\n    rep->length = (nIndicators*SIZEOF(xkbIndicatorMapWireDesc))/4;\n    return Success;\n}", "target": 0}
{"code": "static int cac_decipher(sc_card_t *card,\n\t\t\t\t\t const u8 * data, size_t datalen,\n\t\t\t\t\t u8 * out, size_t outlen)\n{\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, cac_rsa_op(card, data, datalen, out, outlen));\n}", "target": 0}
{"code": "MagickPrivate void ConvertRGBToHSI(const double red,const double green,\n  const double blue,double *hue,double *saturation,double *intensity)\n{\n  double\n    alpha,\n    beta;\n  assert(hue != (double *) NULL);\n  assert(saturation != (double *) NULL);\n  assert(intensity != (double *) NULL);\n  *intensity=(QuantumScale*red+QuantumScale*green+QuantumScale*blue)/3.0;\n  if (*intensity <= 0.0)\n    {\n      *hue=0.0;\n      *saturation=0.0;\n      return;\n    }\n  *saturation=1.0-MagickMin(QuantumScale*red,MagickMin(QuantumScale*green,\n    QuantumScale*blue))/(*intensity);\n  alpha=0.5*(2.0*QuantumScale*red-QuantumScale*green-QuantumScale*blue);\n  beta=0.8660254037844385*(QuantumScale*green-QuantumScale*blue);\n  *hue=atan2(beta,alpha)*(180.0/MagickPI)/360.0;\n  if (*hue < 0.0)\n    *hue+=1.0;\n}", "target": 0}
{"code": "uint16_t nvme_bounce_mdata(NvmeCtrl *n, uint8_t *ptr, uint32_t len,\n                           NvmeTxDirection dir, NvmeRequest *req)\n{\n    NvmeNamespace *ns = req->ns;\n    uint16_t status;\n    if (nvme_ns_ext(ns)) {\n        return nvme_tx_interleaved(n, &req->sg, ptr, len, ns->lbaf.ms,\n                                   ns->lbasz, ns->lbasz, dir);\n    }\n    nvme_sg_unmap(&req->sg);\n    status = nvme_map_mptr(n, &req->sg, len, &req->cmd);\n    if (status) {\n        return status;\n    }\n    return nvme_tx(n, &req->sg, ptr, len, dir);\n}", "target": 0}
{"code": "void WebProcessProxy::disconnectFramesFromPage(WebPageProxy* page)\n{\n    Vector<RefPtr<WebFrameProxy> > frames;\n    copyValuesToVector(m_frameMap, frames);\n    for (size_t i = 0, size = frames.size(); i < size; ++i) {\n        if (frames[i]->page() == page)\n            frames[i]->disconnect();\n    }\n}", "target": 0}
{"code": "bool ChildProcessSecurityPolicyImpl::HasWebUIBindings(int child_id) {\n  base::AutoLock lock(lock_);\n  SecurityStateMap::iterator state = security_state_.find(child_id);\n  if (state == security_state_.end())\n    return false;\n  return state->second->has_web_ui_bindings();\n}", "target": 0}
{"code": "isdn_net_rmallphone(isdn_net_dev *p)\n{\n\tisdn_net_phone *n;\n\tisdn_net_phone *m;\n\tint i;\n\tfor (i = 0; i < 2; i++) {\n\t\tn = p->local->phone[i];\n\t\twhile (n) {\n\t\t\tm = n->next;\n\t\t\tkfree(n);\n\t\t\tn = m;\n\t\t}\n\t\tp->local->phone[i] = NULL;\n\t}\n\tp->local->dial = NULL;\n\treturn 0;\n}", "target": 0}
{"code": "static void mce_reenable_cpu(void)\n{\n\tint i;\n\tif (!mce_available(raw_cpu_ptr(&cpu_info)))\n\t\treturn;\n\tif (!cpuhp_tasks_frozen)\n\t\tcmci_reenable();\n\tfor (i = 0; i < mca_cfg.banks; i++) {\n\t\tstruct mce_bank *b = &mce_banks[i];\n\t\tif (b->init)\n\t\t\twrmsrl(msr_ops.ctl(i), b->ctl);\n\t}\n}", "target": 0}
{"code": "static void breakpoint_invalidate(CPUState *cpu, target_ulong pc)\n{\n    hwaddr phys = cpu_get_phys_page_debug(cpu, pc);\n    if (phys != -1) {\n        tb_invalidate_phys_addr(cpu->as,\n                                phys | (pc & ~TARGET_PAGE_MASK));\n    }\n}", "target": 0}
{"code": "int btrfs_close_devices(struct btrfs_fs_devices *fs_devices)\n{\n\tstruct btrfs_fs_devices *seed_devices = NULL;\n\tint ret;\n\tmutex_lock(&uuid_mutex);\n\tret = close_fs_devices(fs_devices);\n\tif (!fs_devices->opened) {\n\t\tseed_devices = fs_devices->seed;\n\t\tfs_devices->seed = NULL;\n\t}\n\tmutex_unlock(&uuid_mutex);\n\twhile (seed_devices) {\n\t\tfs_devices = seed_devices;\n\t\tseed_devices = fs_devices->seed;\n\t\tclose_fs_devices(fs_devices);\n\t\tfree_fs_devices(fs_devices);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static PHP_NAMED_FUNCTION(zif_zip_open)\n{\n\tchar     *filename;\n\tint       filename_len;\n\tchar resolved_path[MAXPATHLEN + 1];\n\tzip_rsrc *rsrc_int;\n\tint err = 0;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p\", &filename, &filename_len) == FAILURE) {\n\t\treturn;\n\t}\n\tif (filename_len == 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Empty string as source\");\n\t\tRETURN_FALSE;\n\t}\n\tif (ZIP_OPENBASEDIR_CHECKPATH(filename)) {\n\t\tRETURN_FALSE;\n\t}\n\tif(!expand_filepath(filename, resolved_path TSRMLS_CC)) {\n\t\tRETURN_FALSE;\n\t}\n\trsrc_int = (zip_rsrc *)emalloc(sizeof(zip_rsrc));\n\trsrc_int->za = zip_open(resolved_path, 0, &err);\n\tif (rsrc_int->za == NULL) {\n\t\tefree(rsrc_int);\n\t\tRETURN_LONG((long)err);\n\t}\n\trsrc_int->index_current = 0;\n\trsrc_int->num_files = zip_get_num_files(rsrc_int->za);\n\tZEND_REGISTER_RESOURCE(return_value, rsrc_int, le_zip_dir);\n}", "target": 0}
{"code": "sid_to_key_str(struct cifs_sid *sidptr, unsigned int type)\n{\n\tint i, len;\n\tunsigned int saval;\n\tchar *sidstr, *strptr;\n\tunsigned long long id_auth_val;\n\tsidstr = kmalloc(3 + SID_STRING_BASE_SIZE +\n\t\t\t (SID_STRING_SUBAUTH_SIZE * sidptr->num_subauth),\n\t\t\t GFP_KERNEL);\n\tif (!sidstr)\n\t\treturn sidstr;\n\tstrptr = sidstr;\n\tlen = sprintf(strptr, \"%cs:S-%hhu\", type == SIDOWNER ? 'o' : 'g',\n\t\t\tsidptr->revision);\n\tstrptr += len;\n\tid_auth_val = (unsigned long long)sidptr->authority[5];\n\tid_auth_val |= (unsigned long long)sidptr->authority[4] << 8;\n\tid_auth_val |= (unsigned long long)sidptr->authority[3] << 16;\n\tid_auth_val |= (unsigned long long)sidptr->authority[2] << 24;\n\tid_auth_val |= (unsigned long long)sidptr->authority[1] << 32;\n\tid_auth_val |= (unsigned long long)sidptr->authority[0] << 48;\n\tif (id_auth_val <= UINT_MAX)\n\t\tlen = sprintf(strptr, \"-%llu\", id_auth_val);\n\telse\n\t\tlen = sprintf(strptr, \"-0x%llx\", id_auth_val);\n\tstrptr += len;\n\tfor (i = 0; i < sidptr->num_subauth; ++i) {\n\t\tsaval = le32_to_cpu(sidptr->sub_auth[i]);\n\t\tlen = sprintf(strptr, \"-%u\", saval);\n\t\tstrptr += len;\n\t}\n\treturn sidstr;\n}", "target": 0}
{"code": "struct r_bin_dyldcache_obj_t* r_bin_dyldcache_new(const char* file) {\n\tstruct r_bin_dyldcache_obj_t *bin;\n\tut8 *buf;\n\tif (!(bin = R_NEW0 (struct r_bin_dyldcache_obj_t))) {\n\t\treturn NULL;\n\t}\n\tbin->file = file;\n\tif (!(buf = (ut8*)r_file_slurp (file, &bin->size))) {\n\t\treturn r_bin_dyldcache_free (bin);\n\t}\n\tbin->b = r_buf_new ();\n\tif (!r_buf_set_bytes (bin->b, buf, bin->size)) {\n\t\tfree (buf);\n\t\treturn r_bin_dyldcache_free (bin);\n\t}\n\tfree (buf);\n\tif (!r_bin_dyldcache_init (bin)) {\n\t\treturn r_bin_dyldcache_free (bin);\n\t}\n\treturn bin;\n}", "target": 0}
{"code": "ospf_fifo_head (struct ospf_fifo *fifo)\n{\n  return fifo->head;\n}", "target": 0}
{"code": "int apply_to_page_range(struct mm_struct *mm, unsigned long addr,\n\t\t\tunsigned long size, pte_fn_t fn, void *data)\n{\n\tpgd_t *pgd;\n\tunsigned long next;\n\tunsigned long end = addr + size;\n\tint err;\n\tBUG_ON(addr >= end);\n\tpgd = pgd_offset(mm, addr);\n\tdo {\n\t\tnext = pgd_addr_end(addr, end);\n\t\terr = apply_to_pud_range(mm, pgd, addr, next, fn, data);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (pgd++, addr = next, addr != end);\n\treturn err;\n}", "target": 0}
{"code": "static int orinoco_ioctl_setport3(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  void *wrqu,\n\t\t\t\t  char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint val = *((int *) extra);\n\tint err = 0;\n\tunsigned long flags;\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\tswitch (val) {\n\tcase 0: \n\t\tif (!priv->has_ibss) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tpriv->prefer_port3 = 0;\n\t\tbreak;\n\tcase 1: \n\t\tif (!priv->has_port3) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tpriv->prefer_port3 = 1;\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\tif (!err) {\n\t\tset_port_type(priv);\n\t\terr = -EINPROGRESS;\n\t}\n\torinoco_unlock(priv, &flags);\n\treturn err;\n}", "target": 0}
{"code": "void region16_uninit(REGION16* region)\n{\n\tassert(region);\n\tif (region->data)\n\t{\n\t\tif ((region->data->size > 0) && (region->data != &empty_region))\n\t\t\tfree(region->data);\n\t\tregion->data = NULL;\n\t}\n}", "target": 0}
{"code": "xfs_attr_leaf_newentsize(int namelen, int valuelen, int blocksize, int *local)\n{\n\tint size;\n\tsize = xfs_attr_leaf_entsize_local(namelen, valuelen);\n\tif (size < xfs_attr_leaf_entsize_local_max(blocksize)) {\n\t\tif (local) {\n\t\t\t*local = 1;\n\t\t}\n\t} else {\n\t\tsize = xfs_attr_leaf_entsize_remote(namelen);\n\t\tif (local) {\n\t\t\t*local = 0;\n\t\t}\n\t}\n\treturn size;\n}", "target": 0}
{"code": "  void RevokeReadRawCookies() {\n    can_read_raw_cookies_ = false;\n  }", "target": 0}
{"code": "static void debug_info(const char *what, struct attr_stack *elem)\n{\n\tfprintf(stderr, \"%s: %s\\n\", what, elem->origin ? elem->origin : \"()\");\n}", "target": 0}
{"code": "get_iter_from_path (GtkTreeStore *store,\n\t\t    GtkTreeIter *iter,\n\t\t    const char *path)\n{\n\treturn iter_search(store, iter, NULL, compare_path, (gpointer) path);\n}", "target": 0}
{"code": "get_tagstack(win_T *wp, dict_T *retdict)\n{\n    list_T\t*l;\n    int\t\ti;\n    dict_T\t*d;\n    dict_add_number(retdict, \"length\", wp->w_tagstacklen);\n    dict_add_number(retdict, \"curidx\", wp->w_tagstackidx + 1);\n    l = list_alloc_id(aid_tagstack_items);\n    if (l == NULL)\n\treturn;\n    dict_add_list(retdict, \"items\", l);\n    for (i = 0; i < wp->w_tagstacklen; i++)\n    {\n\tif ((d = dict_alloc_id(aid_tagstack_details)) == NULL)\n\t    return;\n\tlist_append_dict(l, d);\n\tget_tag_details(&wp->w_tagstack[i], d);\n    }\n}", "target": 0}
{"code": "GF_Err CoLL_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_VPContentLightLevelBox *p = (GF_VPContentLightLevelBox*)s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u16(bs, p->maxCLL);\n\tgf_bs_write_u16(bs, p->maxFALL);\n\treturn GF_OK;\n}", "target": 0}
{"code": "MagickPrivate size_t GetOptimalKernelWidth2D(const double radius,\n  const double sigma)\n{\n  double\n    alpha,\n    beta,\n    gamma,\n    normalize,\n    value;\n  size_t\n    width;\n  ssize_t\n    j,\n    u,\n    v;\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  if (radius > MagickEpsilon)\n    return((size_t) (2.0*ceil(radius)+1.0));\n  gamma=fabs(sigma);\n  if (gamma <= MagickEpsilon)\n    return(3UL);\n  alpha=PerceptibleReciprocal(2.0*gamma*gamma);\n  beta=(double) PerceptibleReciprocal((double) Magick2PI*gamma*gamma);\n  for (width=5; ; )\n  {\n    normalize=0.0;\n    j=(ssize_t) (width-1)/2;\n    for (v=(-j); v <= j; v++)\n      for (u=(-j); u <= j; u++)\n        normalize+=exp(-((double) (u*u+v*v))*alpha)*beta;\n    value=exp(-((double) (j*j))*alpha)*beta/normalize;\n    if ((value < QuantumScale) || (value < MagickEpsilon))\n      break;\n    width+=2;\n  }\n  return((size_t) (width-2));\n}", "target": 0}
{"code": "static void cma_set_rep_event_data(struct rdma_cm_event *event,\n\t\t\t\t   const struct ib_cm_rep_event_param *rep_data,\n\t\t\t\t   void *private_data)\n{\n\tevent->param.conn.private_data = private_data;\n\tevent->param.conn.private_data_len = IB_CM_REP_PRIVATE_DATA_SIZE;\n\tevent->param.conn.responder_resources = rep_data->responder_resources;\n\tevent->param.conn.initiator_depth = rep_data->initiator_depth;\n\tevent->param.conn.flow_control = rep_data->flow_control;\n\tevent->param.conn.rnr_retry_count = rep_data->rnr_retry_count;\n\tevent->param.conn.srq = rep_data->srq;\n\tevent->param.conn.qp_num = rep_data->remote_qpn;\n\tevent->ece.vendor_id = rep_data->ece.vendor_id;\n\tevent->ece.attr_mod = rep_data->ece.attr_mod;\n}", "target": 0}
{"code": "static long get_instantiation_keyring(key_serial_t ringid,\n\t\t\t\t      struct request_key_auth *rka,\n\t\t\t\t      struct key **_dest_keyring)\n{\n\tkey_ref_t dkref;\n\t*_dest_keyring = NULL;\n\tif (ringid == 0)\n\t\treturn 0;\n\tif (ringid > 0) {\n\t\tdkref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_WRITE);\n\t\tif (IS_ERR(dkref))\n\t\t\treturn PTR_ERR(dkref);\n\t\t*_dest_keyring = key_ref_to_ptr(dkref);\n\t\treturn 0;\n\t}\n\tif (ringid == KEY_SPEC_REQKEY_AUTH_KEY)\n\t\treturn -EINVAL;\n\tif (ringid >= KEY_SPEC_REQUESTOR_KEYRING) {\n\t\t*_dest_keyring = key_get(rka->dest_keyring);\n\t\treturn 0;\n\t}\n\treturn -ENOKEY;\n}", "target": 0}
{"code": "void InstanceKlass::oop_print_on(oop obj, outputStream* st) {\n  Klass::oop_print_on(obj, st);\n  if (this == SystemDictionary::String_klass()) {\n    typeArrayOop value  = java_lang_String::value(obj);\n    juint        length = java_lang_String::length(obj);\n    if (value != NULL &&\n        value->is_typeArray() &&\n        length <= (juint) value->length()) {\n      st->print(BULLET\"string: \");\n      java_lang_String::print(obj, st);\n      st->cr();\n      if (!WizardMode)  return;  \n    }\n  }\n  st->print_cr(BULLET\"---- fields (total size %d words):\", oop_size(obj));\n  FieldPrinter print_field(st, obj);\n  do_nonstatic_fields(&print_field);\n  if (this == SystemDictionary::Class_klass()) {\n    st->print(BULLET\"signature: \");\n    java_lang_Class::print_signature(obj, st);\n    st->cr();\n    Klass* mirrored_klass = java_lang_Class::as_Klass(obj);\n    st->print(BULLET\"fake entry for mirror: \");\n    mirrored_klass->print_value_on_maybe_null(st);\n    st->cr();\n    Klass* array_klass = java_lang_Class::array_klass_acquire(obj);\n    st->print(BULLET\"fake entry for array: \");\n    array_klass->print_value_on_maybe_null(st);\n    st->cr();\n    st->print_cr(BULLET\"fake entry for oop_size: %d\", java_lang_Class::oop_size(obj));\n    st->print_cr(BULLET\"fake entry for static_oop_field_count: %d\", java_lang_Class::static_oop_field_count(obj));\n    Klass* real_klass = java_lang_Class::as_Klass(obj);\n    if (real_klass != NULL && real_klass->is_instance_klass()) {\n      InstanceKlass::cast(real_klass)->do_local_static_fields(&print_field);\n    }\n  } else if (this == SystemDictionary::MethodType_klass()) {\n    st->print(BULLET\"signature: \");\n    java_lang_invoke_MethodType::print_signature(obj, st);\n    st->cr();\n  }\n}", "target": 0}
{"code": "static zval *spl_array_read_dimension(zval *object, zval *offset, int type TSRMLS_DC) \n{\n\treturn spl_array_read_dimension_ex(1, object, offset, type TSRMLS_CC);\n} ", "target": 0}
{"code": "void bnx2x_nic_init_cnic(struct bnx2x *bp)\n{\n\tif (!NO_FCOE(bp))\n\t\tbnx2x_init_fcoe_fp(bp);\n\tbnx2x_init_sb(bp, bp->cnic_sb_mapping,\n\t\t      BNX2X_VF_ID_INVALID, false,\n\t\t      bnx2x_cnic_fw_sb_id(bp), bnx2x_cnic_igu_sb_id(bp));\n\trmb();\n\tbnx2x_init_rx_rings_cnic(bp);\n\tbnx2x_init_tx_rings_cnic(bp);\n\tmb();\n\tmmiowb();\n}", "target": 0}
{"code": "onig_noname_group_capture_is_active(const regex_t* reg)\n{\n  if (ONIG_IS_OPTION_ON(reg->options, ONIG_OPTION_DONT_CAPTURE_GROUP))\n    return 0;\n#ifdef USE_NAMED_GROUP\n  if (onig_number_of_names(reg) > 0 &&\n      IS_SYNTAX_BV(reg->syntax, ONIG_SYN_CAPTURE_ONLY_NAMED_GROUP) &&\n      !ONIG_IS_OPTION_ON(reg->options, ONIG_OPTION_CAPTURE_GROUP)) {\n    return 0;\n  }\n#endif\n  return 1;\n}", "target": 0}
{"code": "int ldb_msg_append_string(struct ldb_message *msg,\n\t\t\t  const char *attr_name, const char *str, int flags)\n{\n\tstruct ldb_val val;\n\tval.data = discard_const_p(uint8_t, str);\n\tval.length = strlen(str);\n\tif (val.length == 0) {\n\t\treturn LDB_SUCCESS;\n\t}\n\treturn ldb_msg_append_value(msg, attr_name, &val, flags);\n}", "target": 0}
{"code": "static void nfs4_xdr_enc_open_confirm(struct rpc_rqst *req,\n\t\t\t\t      struct xdr_stream *xdr,\n\t\t\t\t      struct nfs_open_confirmargs *args)\n{\n\tstruct compound_hdr hdr = {\n\t\t.nops   = 0,\n\t};\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_open_confirm(xdr, args, &hdr);\n\tencode_nops(&hdr);\n}", "target": 0}
{"code": "void GLES2DecoderImpl::DoDisableVertexAttribArray(GLuint index) {\n  if (vertex_attrib_manager_.Enable(index, false)) {\n    if (index != 0) {\n      glDisableVertexAttribArray(index);\n    }\n  } else {\n    SetGLError(GL_INVALID_VALUE,\n               \"glDisableVertexAttribArray: index out of range\");\n  }\n}", "target": 0}
{"code": "    void TiffCopier::visitIfdMakernote(TiffIfdMakernote* object)\n    {\n        copyObject(object);\n    }", "target": 0}
{"code": "  UpdateModifiedTimeTask(\n      QuotaManager* manager,\n      const GURL& origin,\n      StorageType type,\n      base::Time modified_time)\n      : DatabaseTaskBase(manager),\n        origin_(origin),\n        type_(type),\n        modified_time_(modified_time) {}", "target": 0}
{"code": "FunctionLibraryDefinition::FunctionDefAndOpRegistration::\n    FunctionDefAndOpRegistration(const FunctionDef& fdef_in,\n                                 const StackTracesMap& stack_traces)\n    : fdef(fdef_in),\n      op_registration_data(fdef.signature(), shape_inference::UnknownShape,\n                           true ),\n      stack_traces(stack_traces) {}", "target": 0}
{"code": "static inline struct kmem_cache_cpu *get_cpu_slab(struct kmem_cache *s, int cpu)\n{\n#ifdef CONFIG_SMP\n\treturn s->cpu_slab[cpu];\n#else\n\treturn &s->cpu_slab;\n#endif\n}", "target": 0}
{"code": "process_mic(OM_uint32 *minor_status, gss_buffer_t mic_in,\n\t    spnego_gss_ctx_id_t sc, gss_buffer_t *mic_out,\n\t    OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 ret, tmpmin;\n\tgss_qop_t qop_state;\n\tgss_buffer_desc tmpmic = GSS_C_EMPTY_BUFFER;\n\tret = GSS_S_FAILURE;\n\tif (mic_in != GSS_C_NO_BUFFER) {\n\t\tret = gss_verify_mic(minor_status, sc->ctx_handle,\n\t\t\t\t     &sc->DER_mechTypes,\n\t\t\t\t     mic_in, &qop_state);\n\t\tif (ret != GSS_S_COMPLETE) {\n\t\t\t*negState = REJECT;\n\t\t\t*tokflag = ERROR_TOKEN_SEND;\n\t\t\treturn ret;\n\t\t}\n\t\tsc->mic_reqd = 1;\n\t\tsc->mic_rcvd = 1;\n\t}\n\tif (sc->mic_reqd && !sc->mic_sent) {\n\t\tret = gss_get_mic(minor_status, sc->ctx_handle,\n\t\t\t\t  GSS_C_QOP_DEFAULT,\n\t\t\t\t  &sc->DER_mechTypes,\n\t\t\t\t  &tmpmic);\n\t\tif (ret != GSS_S_COMPLETE) {\n\t\t\tgss_release_buffer(&tmpmin, &tmpmic);\n\t\t\t*tokflag = NO_TOKEN_SEND;\n\t\t\treturn ret;\n\t\t}\n\t\t*mic_out = malloc(sizeof(gss_buffer_desc));\n\t\tif (*mic_out == GSS_C_NO_BUFFER) {\n\t\t\tgss_release_buffer(&tmpmin, &tmpmic);\n\t\t\t*tokflag = NO_TOKEN_SEND;\n\t\t\treturn GSS_S_FAILURE;\n\t\t}\n\t\t**mic_out = tmpmic;\n\t\tsc->mic_sent = 1;\n\t}\n\treturn GSS_S_COMPLETE;\n}", "target": 0}
{"code": "static void init_once(void *foo)\n{\n\tstruct iso_inode_info *ei = foo;\n\tinode_init_once(&ei->vfs_inode);\n}", "target": 0}
{"code": "ZEND_METHOD(CURLFile, setPostFilename)\n{\n\tcurlfile_set_property(\"postname\", INTERNAL_FUNCTION_PARAM_PASSTHRU);\n}", "target": 0}
{"code": "add_lease_context(struct TCP_Server_Info *server, struct kvec *iov,\n\t\t  unsigned int *num_iovec, u8 *lease_key, __u8 *oplock)\n{\n\tstruct smb2_create_req *req = iov[0].iov_base;\n\tunsigned int num = *num_iovec;\n\tiov[num].iov_base = server->ops->create_lease_buf(lease_key, *oplock);\n\tif (iov[num].iov_base == NULL)\n\t\treturn -ENOMEM;\n\tiov[num].iov_len = server->vals->create_lease_size;\n\treq->RequestedOplockLevel = SMB2_OPLOCK_LEVEL_LEASE;\n\tif (!req->CreateContextsOffset)\n\t\treq->CreateContextsOffset = cpu_to_le32(\n\t\t\t\tsizeof(struct smb2_create_req) +\n\t\t\t\tiov[num - 1].iov_len);\n\tle32_add_cpu(&req->CreateContextsLength,\n\t\t     server->vals->create_lease_size);\n\t*num_iovec = num + 1;\n\treturn 0;\n}", "target": 0}
{"code": "void EVP_MD_CTX_destroy(EVP_MD_CTX *ctx)\n\t{\n\tif (ctx)\n\t\t{\n\t\tEVP_MD_CTX_cleanup(ctx);\n\t\tOPENSSL_free(ctx);\n\t\t}\n\t}", "target": 0}
{"code": "static inline uint32_t kvm_cpuid_base(void)\n{\n\tstatic int kvm_cpuid_base = -1;\n\tif (kvm_cpuid_base == -1)\n\t\tkvm_cpuid_base = __kvm_cpuid_base();\n\treturn kvm_cpuid_base;\n}", "target": 0}
{"code": "PHP_LIBXML_API zval *php_libxml_switch_context(zval *context TSRMLS_DC)\n{\n\tzval *oldcontext;\n\toldcontext = LIBXML(stream_context);\n\tLIBXML(stream_context) = context;\n\treturn oldcontext;\n}", "target": 0}
{"code": "static inline struct sk_buff *__skb_dequeue_tail(struct sk_buff_head *list)\n{\n\tstruct sk_buff *skb = skb_peek_tail(list);\n\tif (skb)\n\t\t__skb_unlink(skb, list);\n\treturn skb;\n}", "target": 0}
{"code": "DLLEXPORT int DLLCALL tjDecompress(tjhandle handle, unsigned char *jpegBuf,\n\tunsigned long jpegSize, unsigned char *dstBuf, int width, int pitch,\n\tint height, int pixelSize, int flags)\n{\n\tif(flags&TJ_YUV)\n\t\treturn tjDecompressToYUV(handle, jpegBuf, jpegSize, dstBuf, flags);\n\telse\n\t\treturn tjDecompress2(handle, jpegBuf, jpegSize, dstBuf, width, pitch,\n\t\t\theight, getPixelFormat(pixelSize, flags), flags);\n}", "target": 0}
{"code": "void LibRaw::trimSpaces(char *s)\n{\n  char *p = s;\n  int l = strlen(p);\n  if (!l)\n    return;\n  while (isspace(p[l - 1]))\n    p[--l] = 0; \n  while (*p && isspace(*p))\n    ++p, --l;   \n  memmove(s, p, l + 1);\n}", "target": 0}
{"code": "static bool type_is_sk_pointer(enum bpf_reg_type type)\n{\n\treturn type == PTR_TO_SOCKET ||\n\t\ttype == PTR_TO_SOCK_COMMON ||\n\t\ttype == PTR_TO_TCP_SOCK ||\n\t\ttype == PTR_TO_XDP_SOCK;\n}", "target": 0}
{"code": "static void hns_roce_unregister_device(struct hns_roce_dev *hr_dev)\n{\n\tstruct hns_roce_ib_iboe *iboe = &hr_dev->iboe;\n\tunregister_netdevice_notifier(&iboe->nb);\n\tib_unregister_device(&hr_dev->ib_dev);\n}", "target": 0}
{"code": "static int _sched_setscheduler(struct task_struct *p, int policy,\n\t\t\t       const struct sched_param *param, bool check)\n{\n\tstruct sched_attr attr = {\n\t\t.sched_policy   = policy,\n\t\t.sched_priority = param->sched_priority,\n\t\t.sched_nice\t= PRIO_TO_NICE(p->static_prio),\n\t};\n\tif ((policy != SETPARAM_POLICY) && (policy & SCHED_RESET_ON_FORK)) {\n\t\tattr.sched_flags |= SCHED_FLAG_RESET_ON_FORK;\n\t\tpolicy &= ~SCHED_RESET_ON_FORK;\n\t\tattr.sched_policy = policy;\n\t}\n\treturn __sched_setscheduler(p, &attr, check, true);\n}", "target": 0}
{"code": "int ldb_msg_add_string(struct ldb_message *msg,\n\t\t       const char *attr_name, const char *str)\n{\n\treturn ldb_msg_add_string_flags(msg, attr_name, str, 0);\n}", "target": 0}
{"code": "xmlParseQNameAndCompare(xmlParserCtxtPtr ctxt, xmlChar const *name,\n                        xmlChar const *prefix) {\n    const xmlChar *cmp;\n    const xmlChar *in;\n    const xmlChar *ret;\n    const xmlChar *prefix2;\n    if (prefix == NULL) return(xmlParseNameAndCompare(ctxt, name));\n    GROW;\n    in = ctxt->input->cur;\n    cmp = prefix;\n    while (*in != 0 && *in == *cmp) {\n\t++in;\n\t++cmp;\n    }\n    if ((*cmp == 0) && (*in == ':')) {\n        in++;\n\tcmp = name;\n\twhile (*in != 0 && *in == *cmp) {\n\t    ++in;\n\t    ++cmp;\n\t}\n\tif (*cmp == 0 && (*in == '>' || IS_BLANK_CH (*in))) {\n\t    ctxt->input->cur = in;\n\t    return((const xmlChar*) 1);\n\t}\n    }\n    ret = xmlParseQName (ctxt, &prefix2);\n    if ((ret == name) && (prefix == prefix2))\n\treturn((const xmlChar*) 1);\n    return ret;\n}", "target": 0}
{"code": "const char* DocumentSourceGroup::getSourceName() const {\n    return kStageName.rawData();\n}", "target": 0}
{"code": "fbFetchPixel_r5g6b5 (const FbBits *bits, int offset, miIndexedPtr indexed)\n{\n    CARD32  pixel = READ((CARD16 *) bits + offset);\n    CARD32  r,g,b;\n    r = ((pixel & 0xf800) | ((pixel & 0xe000) >> 5)) << 8;\n    g = ((pixel & 0x07e0) | ((pixel & 0x0600) >> 6)) << 5;\n    b = ((pixel & 0x001c) | ((pixel & 0x001f) << 5)) >> 2;\n    return (0xff000000 | r | g | b);\n}", "target": 0}
{"code": "cdf_dump(const void *v, size_t len)\n{\n\tsize_t i, j;\n\tconst unsigned char *p = v;\n\tchar abuf[16];\n\t(void)fprintf(stderr, \"%.4x: \", 0);\n\tfor (i = 0, j = 0; i < len; i++, p++) {\n\t\t(void)fprintf(stderr, \"%.2x \", *p);\n\t\tabuf[j++] = isprint(*p) ? *p : '.';\n\t\tif (j == 16) {\n\t\t\tj = 0;\n\t\t\tabuf[15] = '\\0';\n\t\t\t(void)fprintf(stderr, \"%s\\n%.4\" SIZE_T_FORMAT \"x: \",\n\t\t\t    abuf, i + 1);\n\t\t}\n\t}\n\t(void)fprintf(stderr, \"\\n\");\n}", "target": 0}
{"code": "nfsd4_layout_verify(struct svc_export *exp, unsigned int layout_type)\n{\n\tif (!exp->ex_layout_types) {\n\t\tdprintk(\"%s: export does not support pNFS\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tif (layout_type >= LAYOUT_TYPE_MAX ||\n\t    !(exp->ex_layout_types & (1 << layout_type))) {\n\t\tdprintk(\"%s: layout type %d not supported\\n\",\n\t\t\t__func__, layout_type);\n\t\treturn NULL;\n\t}\n\treturn nfsd4_layout_ops[layout_type];\n}", "target": 0}
{"code": "Resolver::~Resolver()\n{\n}", "target": 0}
{"code": "    void Image::setMetadata(const Image& image)\n    {\n        if (checkMode(mdExif) & amWrite) {\n            setExifData(image.exifData());\n        }\n        if (checkMode(mdIptc) & amWrite) {\n            setIptcData(image.iptcData());\n        }\n        if (checkMode(mdIccProfile) & amWrite && iccProfile()) {\n            setIccProfile(*iccProfile());\n        }\n        if (checkMode(mdXmp) & amWrite) {\n            setXmpPacket(image.xmpPacket());\n            setXmpData(image.xmpData());\n        }\n        if (checkMode(mdComment) & amWrite) {\n            setComment(image.comment());\n        }\n    }", "target": 0}
{"code": "ShutdownWatcherHelper::ShutdownWatcherHelper()\n    : shutdown_watchdog_(nullptr),\n      thread_id_(base::PlatformThread::CurrentId()) {\n}", "target": 0}
{"code": "isdn_net_ciscohdlck_alloc_skb(isdn_net_local *lp, int len)\n{\n\tunsigned short hl = dev->drv[lp->isdn_device]->interface->hl_hdrlen;\n\tstruct sk_buff *skb;\n\tskb = alloc_skb(hl + len, GFP_ATOMIC);\n\tif (skb)\n\t\tskb_reserve(skb, hl);\n\telse\n\t\tprintk(\"isdn out of mem at %s:%d!\\n\", __FILE__, __LINE__);\n\treturn skb;\n}", "target": 0}
{"code": "check_solid_tile32(VncState *vs, int x, int y, int w, int h,\n                   uint32_t *color, bool samecolor)\n{\n    VncDisplay *vd = vs->vd;\n    uint32_t *fbptr;\n    uint32_t c;\n    int dx, dy;\n    fbptr = vnc_server_fb_ptr(vd, x, y);\n    c = *fbptr;\n    if (samecolor && (uint32_t)c != *color) {\n        return false;\n    }\n    for (dy = 0; dy < h; dy++) {\n        for (dx = 0; dx < w; dx++) {\n            if (c != fbptr[dx]) {\n                return false;\n            }\n        }\n        fbptr = (uint32_t *)\n            ((uint8_t *)fbptr + vnc_server_fb_stride(vd));\n    }\n    *color = (uint32_t)c;\n    return true;\n}", "target": 0}
{"code": "static int gs_cmd_reset(struct gs_can *gsdev)\n{\n\tstruct gs_device_mode *dm;\n\tstruct usb_interface *intf = gsdev->iface;\n\tint rc;\n\tdm = kzalloc(sizeof(*dm), GFP_KERNEL);\n\tif (!dm)\n\t\treturn -ENOMEM;\n\tdm->mode = GS_CAN_MODE_RESET;\n\trc = usb_control_msg(interface_to_usbdev(intf),\n\t\t\t     usb_sndctrlpipe(interface_to_usbdev(intf), 0),\n\t\t\t     GS_USB_BREQ_MODE,\n\t\t\t     USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\t     gsdev->channel,\n\t\t\t     0,\n\t\t\t     dm,\n\t\t\t     sizeof(*dm),\n\t\t\t     1000);\n\tkfree(dm);\n\treturn rc;\n}", "target": 0}
{"code": "njs_encode_base64url(njs_str_t *dst, const njs_str_t *src)\n{\n    njs_encode_base64_core(dst, src, njs_basis64url_enc, 0);\n}", "target": 0}
{"code": "test_are_urls_equal(void)\n{\n  unsigned i;\n  static const struct {\n    const char *url1;\n    const char *url2;\n    bool expected_result;\n  } test_array[] = {\n    { \"http:\n    { \"http:\n    { \"http:\n    { \"http:\n    { \"http:\n    { \"http:\n  };\n  for (i = 0; i < countof(test_array); ++i)\n    {\n      mu_assert (\"test_are_urls_equal: wrong result\",\n                 are_urls_equal (test_array[i].url1, test_array[i].url2) == test_array[i].expected_result);\n    }\n  return NULL;\n}", "target": 0}
{"code": "_dbus_path_is_absolute (const DBusString *filename)\n{\n  if (_dbus_string_get_length (filename) > 0)\n    return _dbus_string_get_byte (filename, 1) == ':'\n           || _dbus_string_get_byte (filename, 0) == '\\\\'\n           || _dbus_string_get_byte (filename, 0) == '/';\n  else\n    return FALSE;\n}", "target": 0}
{"code": "static int fsmCommit(int dirfd, char **path, rpmfi fi, rpmFileAction action, const char *suffix)\n{\n    int rc = 0;\n    if (!(S_ISSOCK(rpmfiFMode(fi)) && IS_DEV_LOG(*path))) {\n\tconst char *nsuffix = (action == FA_ALTNAME) ? SUFFIX_RPMNEW : NULL;\n\tchar *dest = *path;\n\tif (suffix)\n\t    dest = fsmFsPath(fi, nsuffix);\n\tif (dest != *path) {\n\t    rc = fsmRename(dirfd, *path, dirfd, dest);\n\t    if (!rc) {\n\t\tif (nsuffix) {\n\t\t    char * opath = fsmFsPath(fi, NULL);\n\t\t    rpmlog(RPMLOG_WARNING, _(\"%s created as %s\\n\"),\n\t\t\t   opath, dest);\n\t\t    free(opath);\n\t\t}\n\t\tfree(*path);\n\t\t*path = dest;\n\t    }\n\t}\n    }\n    return rc;\n}", "target": 0}
{"code": "static int ct_list_items(struct media_player *mp, const char *name,\n\t\t\t\tuint32_t start, uint32_t end, void *user_data)\n{\n\tstruct avrcp_player *player = user_data;\n\tstruct avrcp *session;\n\tstruct pending_list_items *p;\n\tif (player->p != NULL)\n\t\treturn -EBUSY;\n\tsession = player->sessions->data;\n\tset_ct_player(session, player);\n\tif (g_str_has_prefix(name, \"/NowPlaying\"))\n\t\tplayer->scope = 0x03;\n\telse if (g_str_has_suffix(name, \"/search\"))\n\t\tplayer->scope = 0x02;\n\telse\n\t\tplayer->scope = 0x01;\n\tavrcp_list_items(session, start, end);\n\tp = g_new0(struct pending_list_items, 1);\n\tp->start = start;\n\tp->end = end;\n\tp->total = (uint64_t) (p->end - p->start) + 1;\n\tplayer->p = p;\n\treturn 0;\n}", "target": 0}
{"code": "static int ep_send_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv)\n{\n\tstruct ep_send_events_data *esed = priv;\n\tint eventcnt;\n\tunsigned int revents;\n\tstruct epitem *epi;\n\tstruct epoll_event __user *uevent;\n\tpoll_table pt;\n\tinit_poll_funcptr(&pt, NULL);\n\tfor (eventcnt = 0, uevent = esed->events;\n\t     !list_empty(head) && eventcnt < esed->maxevents;) {\n\t\tepi = list_first_entry(head, struct epitem, rdllink);\n\t\tlist_del_init(&epi->rdllink);\n\t\tpt._key = epi->event.events;\n\t\trevents = epi->ffd.file->f_op->poll(epi->ffd.file, &pt) &\n\t\t\tepi->event.events;\n\t\tif (revents) {\n\t\t\tif (__put_user(revents, &uevent->events) ||\n\t\t\t    __put_user(epi->event.data, &uevent->data)) {\n\t\t\t\tlist_add(&epi->rdllink, head);\n\t\t\t\treturn eventcnt ? eventcnt : -EFAULT;\n\t\t\t}\n\t\t\teventcnt++;\n\t\t\tuevent++;\n\t\t\tif (epi->event.events & EPOLLONESHOT)\n\t\t\t\tepi->event.events &= EP_PRIVATE_BITS;\n\t\t\telse if (!(epi->event.events & EPOLLET)) {\n\t\t\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t\t\t}\n\t\t}\n\t}\n\treturn eventcnt;\n}", "target": 0}
{"code": "bool ChromotingInstance::ParseAuthMethods(const std::string& auth_methods_str,\n                                          ClientConfig* config) {\n  std::vector<std::string> auth_methods;\n  base::SplitString(auth_methods_str, ',', &auth_methods);\n  for (std::vector<std::string>::iterator it = auth_methods.begin();\n       it != auth_methods.end(); ++it) {\n    protocol::AuthenticationMethod authentication_method =\n        protocol::AuthenticationMethod::FromString(*it);\n    if (authentication_method.is_valid())\n      config->authentication_methods.push_back(authentication_method);\n  }\n  if (config->authentication_methods.empty()) {\n    LOG(ERROR) << \"No valid authentication methods specified.\";\n    return false;\n  }\n  return true;\n}", "target": 0}
{"code": "static long smb3_fallocate(struct file *file, struct cifs_tcon *tcon, int mode,\n\t\t\t   loff_t off, loff_t len)\n{\n\tif (mode & FALLOC_FL_PUNCH_HOLE)\n\t\treturn smb3_punch_hole(file, tcon, off, len);\n\telse if (mode & FALLOC_FL_ZERO_RANGE) {\n\t\tif (mode & FALLOC_FL_KEEP_SIZE)\n\t\t\treturn smb3_zero_range(file, tcon, off, len, true);\n\t\treturn smb3_zero_range(file, tcon, off, len, false);\n\t} else if (mode == FALLOC_FL_KEEP_SIZE)\n\t\treturn smb3_simple_falloc(file, tcon, off, len, true);\n\telse if (mode == FALLOC_FL_COLLAPSE_RANGE)\n\t\treturn smb3_collapse_range(file, tcon, off, len);\n\telse if (mode == FALLOC_FL_INSERT_RANGE)\n\t\treturn smb3_insert_range(file, tcon, off, len);\n\telse if (mode == 0)\n\t\treturn smb3_simple_falloc(file, tcon, off, len, false);\n\treturn -EOPNOTSUPP;\n}", "target": 0}
{"code": "xps_parse_glyph_metrics(char *s, float *advance, float *uofs, float *vofs, int bidi_level)\n{\n    s = xps_parse_glyph_advance(s, advance, bidi_level);\n    s = xps_parse_glyph_offsets(s, uofs, vofs);\n    return s;\n}", "target": 0}
{"code": "static int cardos_pass_algo_flags(sc_card_t *card, struct sc_cardctl_cardos_pass_algo_flags * ptr)\n{\n\tcardos_data_t * priv = (cardos_data_t *)card->drv_data;\n\tint r = 0;\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tswitch (ptr->pass) {\n\t\tcase 1:\n\t\t\tptr->card_flags = card->flags;\n\t\t\tptr->used_flags = priv->flags;\n\t\t\tptr->ec_flags = priv->ec_flags;\n\t\t\tptr->ext_flags = priv->ext_flags;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tr = cardos_add_algs(card,ptr->new_flags, ptr->ec_flags, ptr->ext_flags);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsc_log(card->ctx, \"ptr->pass: %ul invalid\", ptr->pass);\n\t\t\tr = SC_ERROR_INTERNAL;\n\t}\n\tLOG_FUNC_RETURN(card->ctx, r);\n}", "target": 0}
{"code": "rb_push_glob(VALUE str, VALUE base, int flags) \n{\n    VALUE ary;\n    int status;\n    if (!RB_TYPE_P(str, T_STRING)) {\n\tFilePathValue(str);\n    }\n    else if (!rb_str_to_cstr(str)) {\n        rb_raise(rb_eArgError, \"nul-separated glob pattern is deprecated\");\n    }\n    else {\n\trb_check_safe_obj(str);\n\trb_enc_check(str, rb_enc_from_encoding(rb_usascii_encoding()));\n    }\n    ary = rb_ary_new();\n    status = push_glob(ary, str, base, flags);\n    if (status) GLOB_JUMP_TAG(status);\n    return ary;\n}", "target": 0}
{"code": "void QuotaManagerProxy::RegisterClient(QuotaClient* client) {\n  if (!io_thread_->BelongsToCurrentThread()) {\n    io_thread_->PostTask(FROM_HERE, NewRunnableMethod(\n        this, &QuotaManagerProxy::RegisterClient, client));\n    return;\n  }\n  if (manager_)\n    manager_->RegisterClient(client);\n  else\n    client->OnQuotaManagerDestroyed();\n}", "target": 0}
{"code": "static void *DestroyLocaleNode(void *locale_info)\n{\n  register LocaleInfo\n    *p;\n  p=(LocaleInfo *) locale_info;\n  if (p->path != (char *) NULL)\n    p->path=DestroyString(p->path);\n  if (p->tag != (char *) NULL)\n    p->tag=DestroyString(p->tag);\n  if (p->message != (char *) NULL)\n    p->message=DestroyString(p->message);\n  return(RelinquishMagickMemory(p));\n}", "target": 0}
{"code": "rb_backref_set_string(VALUE string, long pos, long len)\n{\n    VALUE match = rb_backref_get();\n    if (NIL_P(match) || FL_TEST(match, MATCH_BUSY)) {\n\tmatch = match_alloc(rb_cMatch);\n    }\n    match_set_string(match, string, pos, len);\n    rb_backref_set(match);\n}", "target": 0}
{"code": "static zend_bool ZEND_FASTCALL instanceof_interface(const zend_class_entry *instance_ce, const zend_class_entry *ce) \n{\n\tuint32_t i;\n\tif (instance_ce->num_interfaces) {\n\t\tZEND_ASSERT(instance_ce->ce_flags & ZEND_ACC_RESOLVED_INTERFACES);\n\t\tfor (i = 0; i < instance_ce->num_interfaces; i++) {\n\t\t\tif (instance_ce->interfaces[i] == ce) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn instance_ce == ce;\n}", "target": 0}
{"code": "int nft_set_elem_expr_clone(const struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t    struct nft_expr *expr_array[])\n{\n\tstruct nft_expr *expr;\n\tint err, i, k;\n\tfor (i = 0; i < set->num_exprs; i++) {\n\t\texpr = kzalloc(set->exprs[i]->ops->size, GFP_KERNEL_ACCOUNT);\n\t\tif (!expr)\n\t\t\tgoto err_expr;\n\t\terr = nft_expr_clone(expr, set->exprs[i]);\n\t\tif (err < 0) {\n\t\t\tnft_expr_destroy(ctx, expr);\n\t\t\tgoto err_expr;\n\t\t}\n\t\texpr_array[i] = expr;\n\t}\n\treturn 0;\nerr_expr:\n\tfor (k = i - 1; k >= 0; k--)\n\t\tnft_expr_destroy(ctx, expr_array[k]);\n\treturn -ENOMEM;\n}", "target": 0}
{"code": "void cql_server::response::write_byte(uint8_t b)\n{\n    auto s = reinterpret_cast<const int8_t*>(&b);\n    _body.write(bytes_view(s, sizeof(b)));\n}", "target": 0}
{"code": "make_eku_oid(cms_context *cms, SECItem *encoded, SECOidTag oid_tag)\n{\n\tvoid *rv;\n\tSECOidData *oid_data;\n\toid_data = SECOID_FindOIDByTag(oid_tag);\n\tif (!oid_data)\n\t\tcmsreterr(-1, cms, \"could not encode eku oid data\");\n\trv = SEC_ASN1EncodeItem(cms->arena, encoded, &oid_data->oid,\n\t\t\t\tEKUOidSequence);\n\tif (rv == NULL)\n\t\tcmsreterr(-1, cms, \"could not encode eku oid data\");\n\tencoded->type = siBuffer;\n\treturn 0;\n}", "target": 0}
{"code": "static int init_kmem_cache_nodes(struct kmem_cache *s, gfp_t gfpflags)\n{\n\tint node;\n\tint local_node;\n\tif (slab_state >= UP)\n\t\tlocal_node = page_to_nid(virt_to_page(s));\n\telse\n\t\tlocal_node = 0;\n\tfor_each_node_state(node, N_NORMAL_MEMORY) {\n\t\tstruct kmem_cache_node *n;\n\t\tif (local_node == node)\n\t\t\tn = &s->local_node;\n\t\telse {\n\t\t\tif (slab_state == DOWN) {\n\t\t\t\tn = early_kmem_cache_node_alloc(gfpflags,\n\t\t\t\t\t\t\t\tnode);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tn = kmem_cache_alloc_node(kmalloc_caches,\n\t\t\t\t\t\t\tgfpflags, node);\n\t\t\tif (!n) {\n\t\t\t\tfree_kmem_cache_nodes(s);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\ts->node[node] = n;\n\t\tinit_kmem_cache_node(n);\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "    Exifdatum& Exifdatum::operator=(const Value& value)\n    {\n        setValue(&value);\n        return *this;\n    }", "target": 0}
{"code": "int Item::save_in_field(Field *field, bool no_conversions)\n{\n  int error;\n  if (result_type() == STRING_RESULT)\n  {\n    String *result;\n    CHARSET_INFO *cs= collation.collation;\n    char buff[MAX_FIELD_WIDTH];\t\t\n    str_value.set_quick(buff, sizeof(buff), cs);\n    result=val_str(&str_value);\n    if (null_value)\n    {\n      str_value.set_quick(0, 0, cs);\n      return set_field_to_null_with_conversions(field, no_conversions);\n    }\n    field->set_notnull();\n    error=field->store(result->ptr(),result->length(),cs);\n    str_value.set_quick(0, 0, cs);\n  }\n  else if (result_type() == REAL_RESULT)\n  {\n    double nr= val_real();\n    if (null_value)\n      return set_field_to_null_with_conversions(field, no_conversions);\n    field->set_notnull();\n    error=field->store(nr);\n  }\n  else if (result_type() == DECIMAL_RESULT)\n  {\n    my_decimal decimal_value;\n    my_decimal *value= val_decimal(&decimal_value);\n    if (null_value)\n      return set_field_to_null_with_conversions(field, no_conversions);\n    field->set_notnull();\n    error=field->store_decimal(value);\n  }\n  else\n  {\n    longlong nr=val_int();\n    if (null_value)\n      return set_field_to_null_with_conversions(field, no_conversions);\n    field->set_notnull();\n    error=field->store(nr, unsigned_flag);\n  }\n  return error ? error : (field->table->in_use->is_error() ? 1 : 0);\n}", "target": 0}
{"code": "void FrameLoader::didReceiveServerRedirectForProvisionalLoadForFrame()\n{\n    m_client->dispatchDidReceiveServerRedirectForProvisionalLoad();\n}", "target": 0}
{"code": "void OfflineAudioDestinationHandler::Uninitialize() {\n  if (!IsInitialized())\n    return;\n  render_thread_.reset();\n  AudioHandler::Uninitialize();\n}", "target": 0}
{"code": "static int load_scode(struct dvb_frontend *fe, unsigned int type,\n\t\t\t v4l2_std_id *id, __u16 int_freq, int scode)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tint                pos, rc;\n\tunsigned char\t   *p;\n\ttuner_dbg(\"%s called\\n\", __func__);\n\tif (!int_freq) {\n\t\tpos = seek_firmware(fe, type, id);\n\t\tif (pos < 0)\n\t\t\treturn pos;\n\t} else {\n\t\tfor (pos = 0; pos < priv->firm_size; pos++) {\n\t\t\tif ((priv->firm[pos].int_freq == int_freq) &&\n\t\t\t    (priv->firm[pos].type & HAS_IF))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (pos == priv->firm_size)\n\t\t\treturn -ENOENT;\n\t}\n\tp = priv->firm[pos].ptr;\n\tif (priv->firm[pos].type & HAS_IF) {\n\t\tif (priv->firm[pos].size != 12 * 16 || scode >= 16)\n\t\t\treturn -EINVAL;\n\t\tp += 12 * scode;\n\t} else {\n\t\tif (priv->firm[pos].size != 14 * 16 || scode >= 16 ||\n\t\t    le16_to_cpu(*(__le16 *)(p + 14 * scode)) != 12)\n\t\t\treturn -EINVAL;\n\t\tp += 14 * scode + 2;\n\t}\n\ttuner_info(\"Loading SCODE for type=\");\n\tdump_firm_type_and_int_freq(priv->firm[pos].type,\n\t\t\t\t    priv->firm[pos].int_freq);\n\tprintk(\"(%x), id %016llx.\\n\", priv->firm[pos].type,\n\t       (unsigned long long)*id);\n\tif (priv->firm_version < 0x0202)\n\t\trc = send_seq(priv, {0x20, 0x00, 0x00, 0x00});\n\telse\n\t\trc = send_seq(priv, {0xa0, 0x00, 0x00, 0x00});\n\tif (rc < 0)\n\t\treturn -EIO;\n\trc = i2c_send(priv, p, 12);\n\tif (rc < 0)\n\t\treturn -EIO;\n\trc = send_seq(priv, {0x00, 0x8c});\n\tif (rc < 0)\n\t\treturn -EIO;\n\treturn 0;\n}", "target": 0}
{"code": "    void TiffFinder::visitDataEntry(TiffDataEntry* object)\n    {\n        findObject(object);\n    }", "target": 0}
{"code": "static void opj_j2k_setup_decoding (opj_j2k_t *p_j2k)\n{\n        assert(p_j2k != 00);\n        opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_decode_tiles);\n}", "target": 0}
{"code": "int con_set_trans_new(ushort __user * arg)\n{\n\tunsigned short inbuf[E_TABSZ];\n\tif (copy_from_user(inbuf, arg, sizeof(inbuf)))\n\t\treturn -EFAULT;\n\tconsole_lock();\n\tmemcpy(translations[USER_MAP], inbuf, sizeof(inbuf));\n\tupdate_user_maps();\n\tconsole_unlock();\n\treturn 0;\n}", "target": 0}
{"code": "int unit_name_to_instance(const char *n, char **ret) {\n        const char *p, *d;\n        assert(n);\n        if (!unit_name_is_valid(n, UNIT_NAME_ANY))\n                return -EINVAL;\n        p = strchr(n, '@');\n        if (!p) {\n                if (ret)\n                        *ret = NULL;\n                return UNIT_NAME_PLAIN;\n        }\n        p++;\n        d = strrchr(p, '.');\n        if (!d)\n                return -EINVAL;\n        if (ret) {\n                char *i = strndup(p, d-p);\n                if (!i)\n                        return -ENOMEM;\n                *ret = i;\n        }\n        return d > p ? UNIT_NAME_INSTANCE : UNIT_NAME_TEMPLATE;\n}", "target": 0}
{"code": "static int mov_read_stps(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned i, entries;\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n    avio_rb32(pb); \n    entries = avio_rb32(pb);\n    if (sc->stps_data)\n        av_log(c->fc, AV_LOG_WARNING, \"Duplicated STPS atom\\n\");\n    av_free(sc->stps_data);\n    sc->stps_count = 0;\n    sc->stps_data = av_malloc_array(entries, sizeof(*sc->stps_data));\n    if (!sc->stps_data)\n        return AVERROR(ENOMEM);\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        sc->stps_data[i] = avio_rb32(pb);\n    }\n    sc->stps_count = i;\n    if (pb->eof_reached) {\n        av_log(c->fc, AV_LOG_WARNING, \"reached eof, corrupted STPS atom\\n\");\n        return AVERROR_EOF;\n    }\n    return 0;\n}", "target": 0}
{"code": "CSoundFile::~CSoundFile()\n{\n\tDestroy();\n}", "target": 0}
{"code": "int apply_event_filter(struct trace_event_file *file, char *filter_string)\n{\n\tstruct trace_event_call *call = file->event_call;\n\tstruct event_filter *filter = NULL;\n\tint err;\n\tif (!strcmp(strstrip(filter_string), \"0\")) {\n\t\tfilter_disable(file);\n\t\tfilter = event_filter(file);\n\t\tif (!filter)\n\t\t\treturn 0;\n\t\tevent_clear_filter(file);\n\t\tsynchronize_sched();\n\t\t__free_filter(filter);\n\t\treturn 0;\n\t}\n\terr = create_filter(call, filter_string, true, &filter);\n\tif (filter) {\n\t\tstruct event_filter *tmp;\n\t\ttmp = event_filter(file);\n\t\tif (!err)\n\t\t\tevent_set_filtered_flag(file);\n\t\telse\n\t\t\tfilter_disable(file);\n\t\tevent_set_filter(file, filter);\n\t\tif (tmp) {\n\t\t\tsynchronize_sched();\n\t\t\t__free_filter(tmp);\n\t\t}\n\t}\n\treturn err;\n}", "target": 0}
{"code": "int Item_copy_string::save_in_field(Field *field, bool no_conversions)\n{\n  return save_str_value_in_field(field, &str_value);\n}", "target": 0}
{"code": "static void zipfileMtimeToDos(ZipfileCDS *pCds, u32 mUnixTime){\n  i64 JD = (i64)2440588 + mUnixTime / (24*60*60);\n  int A, B, C, D, E;\n  int yr, mon, day;\n  int hr, min, sec;\n  A = (int)((JD - 1867216.25)/36524.25);\n  A = (int)(JD + 1 + A - (A/4));\n  B = A + 1524;\n  C = (int)((B - 122.1)/365.25);\n  D = (36525*(C&32767))/100;\n  E = (int)((B-D)/30.6001);\n  day = B - D - (int)(30.6001*E);\n  mon = (E<14 ? E-1 : E-13);\n  yr = mon>2 ? C-4716 : C-4715;\n  hr = (mUnixTime % (24*60*60)) / (60*60);\n  min = (mUnixTime % (60*60)) / 60;\n  sec = (mUnixTime % 60);\n  if( yr>=1980 ){\n    pCds->mDate = (u16)(day + (mon << 5) + ((yr-1980) << 9));\n    pCds->mTime = (u16)(sec/2 + (min<<5) + (hr<<11));\n  }else{\n    pCds->mDate = pCds->mTime = 0;\n  }\n  assert( mUnixTime<315507600 \n       || mUnixTime==zipfileMtime(pCds) \n       || ((mUnixTime % 2) && mUnixTime-1==zipfileMtime(pCds)) \n  );\n}", "target": 0}
{"code": "static int cenc_decrypt(MOVContext *c, MOVStreamContext *sc, AVEncryptionInfo *sample, uint8_t *input, int size)\n{\n    if (sample->scheme == MKBETAG('c','e','n','c') && !sample->crypt_byte_block && !sample->skip_byte_block) {\n        return cenc_scheme_decrypt(c, sc, sample, input, size);\n    } else if (sample->scheme == MKBETAG('c','b','c','1') && !sample->crypt_byte_block && !sample->skip_byte_block) {\n        return cbc1_scheme_decrypt(c, sc, sample, input, size);\n    } else if (sample->scheme == MKBETAG('c','e','n','s')) {\n        return cens_scheme_decrypt(c, sc, sample, input, size);\n    } else if (sample->scheme == MKBETAG('c','b','c','s')) {\n        return cbcs_scheme_decrypt(c, sc, sample, input, size);\n    } else {\n        av_log(c->fc, AV_LOG_ERROR, \"invalid encryption scheme\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n}", "target": 0}
{"code": "epass2003_sm_wrap_apdu(struct sc_card *card, struct sc_apdu *plain, struct sc_apdu *sm)\n{\n\tunsigned char buf[4096] = { 0 };\t\n\tsize_t buf_len = sizeof(buf);\n\tepass2003_exdata *exdata = NULL;\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\texdata = (epass2003_exdata *)card->drv_data;\n\tLOG_FUNC_CALLED(card->ctx);\n\tif (exdata->sm)\n\t\tplain->cla |= 0x0C;\n\tsm->cse = plain->cse;\n\tsm->cla = plain->cla;\n\tsm->ins = plain->ins;\n\tsm->p1 = plain->p1;\n\tsm->p2 = plain->p2;\n\tsm->lc = plain->lc;\n\tsm->le = plain->le;\n\tsm->control = plain->control;\n\tsm->flags = plain->flags;\n\tswitch (sm->cla & 0x0C) {\n\tcase 0x00:\n\tcase 0x04:\n\t\tsm->datalen = plain->datalen;\n\t\tmemcpy((void *)sm->data, plain->data, plain->datalen);\n\t\tsm->resplen = plain->resplen;\n\t\tmemcpy(sm->resp, plain->resp, plain->resplen);\n\t\tbreak;\n\tcase 0x0C:\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tif (0 != encode_apdu(card, plain, sm, buf, &buf_len))\n\t\t\treturn SC_ERROR_CARD_CMD_FAILED;\n\t\tbreak;\n\tdefault:\n\t\treturn SC_ERROR_INCORRECT_PARAMETERS;\n\t}\n\treturn SC_SUCCESS;\n}", "target": 0}
{"code": "static int php_pgsql_fd_flush(php_stream *stream) \n{\n\treturn FAILURE;\n}", "target": 0}
{"code": "static zval **spl_array_get_property_ptr_ptr(zval *object, zval *member, const zend_literal *key TSRMLS_DC) \n{\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);\n\tif ((intern->ar_flags & SPL_ARRAY_ARRAY_AS_PROPS) != 0\n\t&& !std_object_handlers.has_property(object, member, 2, key TSRMLS_CC)) {\n\t\treturn spl_array_get_dimension_ptr_ptr(1, object, member, BP_VAR_RW TSRMLS_CC);\n\t}\n\treturn std_object_handlers.get_property_ptr_ptr(object, member, key TSRMLS_CC);\n} ", "target": 0}
{"code": "PHP_FUNCTION(pg_convert)\n{\n\tzval *pgsql_link, *values;\n\tchar *table_name;\n\tsize_t table_name_len;\n\tzend_ulong option = 0;\n\tPGconn *pg_link;\n\tint id = -1;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(),\n\t\t\t\t\t\t\t  \"rsa|l\", &pgsql_link, &table_name, &table_name_len, &values, &option) == FAILURE) {\n\t\treturn;\n\t}\n\tif (option & ~PGSQL_CONV_OPTS) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Invalid option is specified\");\n\t\tRETURN_FALSE;\n\t}\n\tif (!table_name_len) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Table name is invalid\");\n\t\tRETURN_FALSE;\n\t}\n\tZEND_FETCH_RESOURCE2(pg_link, PGconn *, pgsql_link, id, \"PostgreSQL link\", le_link, le_plink);\n\tif (php_pgsql_flush_query(pg_link)) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Detected unhandled result(s) in connection\");\n\t}\n\tarray_init(return_value);\n\tif (php_pgsql_convert(pg_link, table_name, values, return_value, option) == FAILURE) {\n\t\tzval_dtor(return_value);\n\t\tRETURN_FALSE;\n\t}\n}", "target": 0}
{"code": "attlist_new (void)\n{\n  mu_list_t lst;\n  int rc = mu_list_create (&lst);\n  if (rc)\n    {\n      mu_diag_funcall (MU_DIAG_ERROR, \"mu_list_create\", NULL, rc);\n      exit (1);\n    }\n  mu_list_set_destroy_item (lst, atchinfo_free);\n  return lst;\n}", "target": 0}
{"code": "void InlineFlowBox::addReplacedChildOverflow(const InlineBox* inlineBox, IntRect& logicalLayoutOverflow, IntRect& logicalVisualOverflow)\n{\n    RenderBox* box = toRenderBox(inlineBox->renderer());\n    if (!box->hasSelfPaintingLayer()) {\n        IntRect childLogicalVisualOverflow = box->logicalVisualOverflowRectForPropagation(renderer()->style());\n        childLogicalVisualOverflow.move(inlineBox->logicalLeft(), inlineBox->logicalTop());\n        logicalVisualOverflow.unite(childLogicalVisualOverflow);\n    }\n    IntRect childLogicalLayoutOverflow = box->logicalLayoutOverflowRectForPropagation(renderer()->style());\n    childLogicalLayoutOverflow.move(inlineBox->logicalLeft(), inlineBox->logicalTop());\n    logicalLayoutOverflow.unite(childLogicalLayoutOverflow);\n}", "target": 0}
{"code": "void ImageLoader::timerFired(TimerBase*) {\n  m_keepAlive.clear();\n}", "target": 0}
{"code": "decompileDEFINELOCAL2(int n, SWF_ACTION *actions, int maxn)\n{\n\tstruct SWF_ACTIONPUSHPARAM *var;\n\tINDENT\n\tvar = pop();\n\tputs(\"var \");\n\tputs(getName(var));\n\tprintln(\";\");\n\treturn 0;\n}", "target": 0}
{"code": "    VertexAttribInfo()\n        : index_(0),\n          enabled_(false),\n          size_(4),\n          type_(GL_FLOAT),\n          offset_(0),\n          normalized_(GL_FALSE),\n          gl_stride_(0),\n          real_stride_(16),\n          list_(NULL) {\n      value_.v[0] = 0.0f;\n      value_.v[1] = 0.0f;\n      value_.v[2] = 0.0f;\n      value_.v[3] = 1.0f;\n    }", "target": 0}
{"code": "parse_absolute_time(const char *s, uint64_t *tp)\n{\n\tstruct tm tm;\n\ttime_t tt;\n\tchar buf[32], *fmt;\n\t*tp = 0;\n\tswitch (strlen(s)) {\n\tcase 8: \n\t\tfmt = \"%Y-%m-%d\";\n\t\tsnprintf(buf, sizeof(buf), \"%.4s-%.2s-%.2s\", s, s + 4, s + 6);\n\t\tbreak;\n\tcase 12: \n\t\tfmt = \"%Y-%m-%dT%H:%M\";\n\t\tsnprintf(buf, sizeof(buf), \"%.4s-%.2s-%.2sT%.2s:%.2s\",\n\t\t    s, s + 4, s + 6, s + 8, s + 10);\n\t\tbreak;\n\tcase 14: \n\t\tfmt = \"%Y-%m-%dT%H:%M:%S\";\n\t\tsnprintf(buf, sizeof(buf), \"%.4s-%.2s-%.2sT%.2s:%.2s:%.2s\",\n\t\t    s, s + 4, s + 6, s + 8, s + 10, s + 12);\n\t\tbreak;\n\tdefault:\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t}\n\tmemset(&tm, 0, sizeof(tm));\n\tif (strptime(buf, fmt, &tm) == NULL)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tif ((tt = mktime(&tm)) < 0)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\t*tp = (uint64_t)tt;\n\treturn 0;\n}", "target": 0}
{"code": "    bool isPsdType(BasicIo& iIo, bool advance)\n    {\n        const int32_t len = 6;\n        const unsigned char PsdHeader[6] = { '8', 'B', 'P', 'S', 0, 1 };\n        byte buf[len];\n        iIo.read(buf, len);\n        if (iIo.error() || iIo.eof())\n        {\n            return false;\n        }\n        bool matched = (memcmp(buf, PsdHeader, len) == 0);\n        if (!advance || !matched)\n        {\n            iIo.seek(-len, BasicIo::cur);\n        }\n        return matched;\n    }", "target": 0}
{"code": "static void fuse_lib_ioctl(fuse_req_t req, fuse_ino_t ino, int cmd, void *arg,\n\t\t\t   struct fuse_file_info *llfi, unsigned int flags,\n\t\t\t   const void *in_buf, size_t in_bufsz,\n\t\t\t   size_t out_bufsz)\n{\n    struct fuse *f = req_fuse_prepare(req);\n    struct fuse_intr_data d;\n    struct fuse_file_info fi;\n    char *path, *out_buf = NULL;\n    int err;\n    err = -EPERM;\n    if (flags & FUSE_IOCTL_UNRESTRICTED)\n\tgoto err;\n    if (flags & FUSE_IOCTL_DIR)\n\tget_dirhandle(llfi, &fi);\n    else\n\tfi = *llfi;\n    if (out_bufsz) {\n\terr = -ENOMEM;\n\tout_buf = malloc(out_bufsz);\n\tif (!out_buf)\n\t    goto err;\n    }\n    assert(!in_bufsz || !out_bufsz || in_bufsz == out_bufsz);\n    if (out_buf)\n\tmemcpy(out_buf, in_buf, in_bufsz);\n    path = get_path(f, ino); \n    if (!path) {\n\terr = ENOENT;\n\tgoto err;\n    }\n    fuse_prepare_interrupt(f, req, &d);\n    err = fuse_fs_ioctl(f->fs, path, cmd, arg, &fi, flags,\n\t\t\tout_buf ? (void*)out_buf : (void*)(uintptr_t)in_buf);\n    fuse_finish_interrupt(f, req, &d);\n    free(path);\n    if (err >= 0) { \n        fuse_reply_ioctl(req, err, out_buf, out_bufsz);\n\tgoto out;\n    }\nerr:\n    reply_err(req, err);\nout:\n    free(out_buf);\n}", "target": 0}
{"code": "static int do_check_subprogs(struct bpf_verifier_env *env)\n{\n\tstruct bpf_prog_aux *aux = env->prog->aux;\n\tint i, ret;\n\tif (!aux->func_info)\n\t\treturn 0;\n\tfor (i = 1; i < env->subprog_cnt; i++) {\n\t\tif (aux->func_info_aux[i].linkage != BTF_FUNC_GLOBAL)\n\t\t\tcontinue;\n\t\tenv->insn_idx = env->subprog_info[i].start;\n\t\tWARN_ON_ONCE(env->insn_idx == 0);\n\t\tret = do_check_common(env, i);\n\t\tif (ret) {\n\t\t\treturn ret;\n\t\t} else if (env->log.level & BPF_LOG_LEVEL) {\n\t\t\tverbose(env,\n\t\t\t\t\"Func#%d is safe for any args that match its prototype\\n\",\n\t\t\t\ti);\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "cmsInt32Number  CMSEXPORT cmsGetToneCurveParametricType(const cmsToneCurve* t)\n{\n    _cmsAssert(t != NULL);\n    if (t -> nSegments != 1) return 0;\n    return t ->Segments[0].Type;\n}", "target": 0}
{"code": "static int lua_apr_date_parse_rfc(lua_State *L)\n{\n    const char *input;\n    apr_time_t result;\n    luaL_checktype(L, 1, LUA_TSTRING);\n    input = lua_tostring(L, 1);\n    result = apr_date_parse_rfc(input);\n    if (result == 0)\n        return 0;\n    lua_pushnumber(L, (lua_Number)(result / APR_USEC_PER_SEC));\n    return 1;\n}", "target": 0}
{"code": "host_build_hostlist(host_item **anchor, const uschar *list, BOOL randomize)\n{\nint sep = 0;\nint fake_mx = MX_NONE;          \nuschar *name;\nif (list == NULL) return;\nif (randomize) fake_mx--;       \n*anchor = NULL;\nwhile ((name = string_nextinlist(&list, &sep, NULL, 0)) != NULL)\n  {\n  host_item *h;\n  if (name[0] == '+' && name[1] == 0)   \n    {                                   \n    if (randomize) fake_mx--;\n    continue;\n    }\n  h = store_get(sizeof(host_item));\n  h->name = name;\n  h->address = NULL;\n  h->port = PORT_NONE;\n  h->mx = fake_mx;\n  h->sort_key = randomize? (-fake_mx)*1000 + random_number(1000) : 0;\n  h->status = hstatus_unknown;\n  h->why = hwhy_unknown;\n  h->last_try = 0;\n  if (*anchor == NULL)\n    {\n    h->next = NULL;\n    *anchor = h;\n    }\n  else\n    {\n    host_item *hh = *anchor;\n    if (h->sort_key < hh->sort_key)\n      {\n      h->next = hh;\n      *anchor = h;\n      }\n    else\n      {\n      while (hh->next != NULL && h->sort_key >= (hh->next)->sort_key)\n        hh = hh->next;\n      h->next = hh->next;\n      hh->next = h;\n      }\n    }\n  }\n}", "target": 0}
{"code": "PHP_METHOD(snmp, close)\n{\n\tphp_snmp_object *snmp_object;\n\tzval *object = getThis();\n\tsnmp_object = Z_SNMP_P(object);\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tnetsnmp_session_free(&(snmp_object->session));\n\tRETURN_TRUE;\n}", "target": 0}
{"code": "static int fanout_set_data(struct packet_sock *po, char __user *data,\n\t\t\t   unsigned int len)\n{\n\tswitch (po->fanout->type) {\n\tcase PACKET_FANOUT_CBPF:\n\t\treturn fanout_set_data_cbpf(po, data, len);\n\tcase PACKET_FANOUT_EBPF:\n\t\treturn fanout_set_data_ebpf(po, data, len);\n\tdefault:\n\t\treturn -EINVAL;\n\t};\n}", "target": 0}
{"code": "onigenc_utf16_32_get_ctype_code_range(OnigCtype ctype, OnigCodePoint* sb_out,\n                                      const OnigCodePoint* ranges[],\n\t\t\t\t      OnigEncoding enc ARG_UNUSED)\n{\n  *sb_out = 0x00;\n  return onigenc_unicode_ctype_code_range(ctype, ranges);\n}", "target": 0}
{"code": "static bool bpf_map_ptr_poisoned(const struct bpf_insn_aux_data *aux)\n{\n\treturn BPF_MAP_PTR(aux->map_state) == BPF_MAP_PTR_POISON;\n}", "target": 0}
{"code": "static const char *set_recursion_limit(cmd_parms *cmd, void *dummy,\n                                       const char *arg1, const char *arg2)\n{\n    core_server_config *conf =\n        ap_get_core_module_config(cmd->server->module_config);\n    int limit = atoi(arg1);\n    if (limit <= 0) {\n        return \"The recursion limit must be greater than zero.\";\n    }\n    if (limit < 4) {\n        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server, APLOGNO(00119)\n                     \"Limiting internal redirects to very low numbers may \"\n                     \"cause normal requests to fail.\");\n    }\n    conf->redirect_limit = limit;\n    if (arg2) {\n        limit = atoi(arg2);\n        if (limit <= 0) {\n            return \"The recursion limit must be greater than zero.\";\n        }\n        if (limit < 4) {\n            ap_log_error(APLOG_MARK, APLOG_WARNING, 0, cmd->server, APLOGNO(00120)\n                         \"Limiting the subrequest depth to a very low level may\"\n                         \" cause normal requests to fail.\");\n        }\n    }\n    conf->subreq_limit = limit;\n    return NULL;\n}", "target": 0}
{"code": "ProcPolyText(ClientPtr client)\n{\n    int err;\n    REQUEST(xPolyTextReq);\n    DrawablePtr pDraw;\n    GC *pGC;\n    REQUEST_AT_LEAST_SIZE(xPolyTextReq);\n    VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, DixWriteAccess);\n    err = PolyText(client,\n                   pDraw,\n                   pGC,\n                   (unsigned char *) &stuff[1],\n                   ((unsigned char *) stuff) + (client->req_len << 2),\n                   stuff->x, stuff->y, stuff->reqType, stuff->drawable);\n    if (err == Success) {\n        return Success;\n    }\n    else\n        return err;\n}", "target": 0}
{"code": "_PUBLIC_ bool file_save_mode(const char *fname, const void *packet,\n\t\t\t     size_t length, mode_t mode)\n{\n\tint fd;\n\tfd = open(fname, O_WRONLY|O_CREAT|O_TRUNC, mode);\n\tif (fd == -1) {\n\t\treturn false;\n\t}\n\tif (write(fd, packet, length) != (size_t)length) {\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\tclose(fd);\n\treturn true;\n}", "target": 0}
{"code": "ieee80211_tx_h_calculate_duration(struct ieee80211_tx_data *tx)\n{\n\tstruct sk_buff *skb;\n\tstruct ieee80211_hdr *hdr;\n\tint next_len;\n\tbool group_addr;\n\tskb_queue_walk(&tx->skbs, skb) {\n\t\thdr = (void *) skb->data;\n\t\tif (unlikely(ieee80211_is_pspoll(hdr->frame_control)))\n\t\t\tbreak; \n\t\tif (!skb_queue_is_last(&tx->skbs, skb)) {\n\t\t\tstruct sk_buff *next = skb_queue_next(&tx->skbs, skb);\n\t\t\tnext_len = next->len;\n\t\t} else\n\t\t\tnext_len = 0;\n\t\tgroup_addr = is_multicast_ether_addr(hdr->addr1);\n\t\thdr->duration_id =\n\t\t\tieee80211_duration(tx, skb, group_addr, next_len);\n\t}\n\treturn TX_CONTINUE;\n}", "target": 0}
{"code": "hash_findi_add(struct hash_table *hash, const char *str)\n{\n    struct hash_insert hi;\n    void **r;\n    char *strx;\n    size_t l = strlen(str) + 1;\n    r = hash_findib(hash, str, l, &hi);\n    if (r)\n        return r;\n    strx = nasm_malloc(l);  \n    memcpy(strx, str, l);\n    return hash_add(&hi, strx, NULL);\n}", "target": 0}
{"code": "static void vcc_release_cb(struct sock *sk)\n{\n\tstruct atm_vcc *vcc = atm_sk(sk);\n\tif (vcc->release_cb)\n\t\tvcc->release_cb(vcc);\n}", "target": 0}
{"code": "static int selinux_ib_endport_manage_subnet(void *ib_sec, const char *dev_name,\n\t\t\t\t\t    u8 port_num)\n{\n\tstruct common_audit_data ad;\n\tint err;\n\tu32 sid = 0;\n\tstruct ib_security_struct *sec = ib_sec;\n\tstruct lsm_ibendport_audit ibendport;\n\terr = security_ib_endport_sid(&selinux_state, dev_name, port_num,\n\t\t\t\t      &sid);\n\tif (err)\n\t\treturn err;\n\tad.type = LSM_AUDIT_DATA_IBENDPORT;\n\tstrncpy(ibendport.dev_name, dev_name, sizeof(ibendport.dev_name));\n\tibendport.port = port_num;\n\tad.u.ibendport = &ibendport;\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    sec->sid, sid,\n\t\t\t    SECCLASS_INFINIBAND_ENDPORT,\n\t\t\t    INFINIBAND_ENDPORT__MANAGE_SUBNET, &ad);\n}", "target": 0}
{"code": "ZEND_API zval * zend_throw_exception_ex(zend_class_entry *exception_ce, long code TSRMLS_DC, char *format, ...) \n{\n\tva_list arg;\n\tchar *message;\n\tzval *zexception;\n\tva_start(arg, format);\n\tzend_vspprintf(&message, 0, format, arg);\n\tva_end(arg);\n\tzexception = zend_throw_exception(exception_ce, message, code TSRMLS_CC);\n\tefree(message);\n\treturn zexception;\n}", "target": 0}
{"code": "void print_usage(const char *pname)\n{\n\tprintf(\"Usage: %s [options] inputfiles\\n\", pname);\n\tprintf(\"Options:\\n\"\n\t\t\"\\t-c\\tcompact output\\n\"\n\t\t\"\\t-v\\tverbose output\\n\"\n\t\t\"\\t-w\\tprint white balance\\n\"\n\t\t\"\\t-u\\tprint unpack function\\n\"\n\t\t\"\\t-f\\tprint frame size (only w/ -u)\\n\"\n\t\t\"\\t-s\\tprint output image size\\n\"\n\t\t\"\\t-h\\tforce half-size mode (only for -s)\\n\"\n\t\t\"\\t-M\\tdisable use of raw-embedded color data\\n\"\n\t\t\"\\t+M\\tforce use of raw-embedded color data\\n\"\n\t\t\"\\t-L filename\\tread input files list from filename\\n\"\n\t\t\"\\t-o filename\\toutput to filename\\n\");\n}", "target": 0}
{"code": "STATIC GC_bool GC_alloc_reclaim_list(struct obj_kind *kind)\n{\n    struct hblk ** result = (struct hblk **)\n                GC_scratch_alloc((MAXOBJGRANULES+1) * sizeof(struct hblk *));\n    if (result == 0) return(FALSE);\n    BZERO(result, (MAXOBJGRANULES+1)*sizeof(struct hblk *));\n    kind -> ok_reclaim_list = result;\n    return(TRUE);\n}", "target": 0}
{"code": "static int rtnl_dump_ifinfo(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tint h, s_h;\n\tint idx = 0, s_idx;\n\tstruct net_device *dev;\n\tstruct hlist_head *head;\n\tstruct nlattr *tb[IFLA_MAX+1];\n\tu32 ext_filter_mask = 0;\n\tconst struct rtnl_link_ops *kind_ops = NULL;\n\tunsigned int flags = NLM_F_MULTI;\n\tint master_idx = 0;\n\tint err;\n\tint hdrlen;\n\ts_h = cb->args[0];\n\ts_idx = cb->args[1];\n\tcb->seq = net->dev_base_seq;\n\thdrlen = nlmsg_len(cb->nlh) < sizeof(struct ifinfomsg) ?\n\t\t sizeof(struct rtgenmsg) : sizeof(struct ifinfomsg);\n\tif (nlmsg_parse(cb->nlh, hdrlen, tb, IFLA_MAX, ifla_policy) >= 0) {\n\t\tif (tb[IFLA_EXT_MASK])\n\t\t\text_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);\n\t\tif (tb[IFLA_MASTER])\n\t\t\tmaster_idx = nla_get_u32(tb[IFLA_MASTER]);\n\t\tif (tb[IFLA_LINKINFO])\n\t\t\tkind_ops = linkinfo_to_kind_ops(tb[IFLA_LINKINFO]);\n\t\tif (master_idx || kind_ops)\n\t\t\tflags |= NLM_F_DUMP_FILTERED;\n\t}\n\tfor (h = s_h; h < NETDEV_HASHENTRIES; h++, s_idx = 0) {\n\t\tidx = 0;\n\t\thead = &net->dev_index_head[h];\n\t\thlist_for_each_entry(dev, head, index_hlist) {\n\t\t\tif (link_dump_filtered(dev, master_idx, kind_ops))\n\t\t\t\tcontinue;\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto cont;\n\t\t\terr = rtnl_fill_ifinfo(skb, dev, RTM_NEWLINK,\n\t\t\t\t\t       NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t       cb->nlh->nlmsg_seq, 0,\n\t\t\t\t\t       flags,\n\t\t\t\t\t       ext_filter_mask);\n\t\t\tWARN_ON((err == -EMSGSIZE) && (skb->len == 0));\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\t\t\tnl_dump_check_consistent(cb, nlmsg_hdr(skb));\ncont:\n\t\t\tidx++;\n\t\t}\n\t}\nout:\n\tcb->args[1] = idx;\n\tcb->args[0] = h;\n\treturn skb->len;\n}", "target": 0}
{"code": "buf_find_string_offset(const buf_t *buf, const char *s, size_t n)\n{\n  buf_pos_t pos;\n  buf_pos_init(buf, &pos);\n  while (buf_find_pos_of_char(*s, &pos) >= 0) {\n    if (buf_matches_at_pos(&pos, s, n)) {\n      tor_assert(pos.chunk_pos + pos.pos < INT_MAX);\n      return (int)(pos.chunk_pos + pos.pos);\n    } else {\n      if (buf_pos_inc(&pos)<0)\n        return -1;\n    }\n  }\n  return -1;\n}", "target": 0}
{"code": "void HeaderMapImpl::HeaderEntryImpl::value(absl::string_view value) { value_.setCopy(value); }", "target": 0}
{"code": "ff_layout_send_layouterror(struct pnfs_layout_segment *lseg)\n{\n\tstruct pnfs_layout_hdr *lo = lseg->pls_layout;\n\tstruct nfs42_layout_error *errors;\n\tLIST_HEAD(head);\n\tif (!nfs_server_capable(lo->plh_inode, NFS_CAP_LAYOUTERROR))\n\t\treturn;\n\tff_layout_fetch_ds_ioerr(lo, &lseg->pls_range, &head, -1);\n\tif (list_empty(&head))\n\t\treturn;\n\terrors = kmalloc_array(NFS42_LAYOUTERROR_MAX,\n\t\t\tsizeof(*errors), GFP_NOFS);\n\tif (errors != NULL) {\n\t\tconst struct nfs4_ff_layout_ds_err *pos;\n\t\tsize_t n = 0;\n\t\tlist_for_each_entry(pos, &head, list) {\n\t\t\terrors[n].offset = pos->offset;\n\t\t\terrors[n].length = pos->length;\n\t\t\tnfs4_stateid_copy(&errors[n].stateid, &pos->stateid);\n\t\t\terrors[n].errors[0].dev_id = pos->deviceid;\n\t\t\terrors[n].errors[0].status = pos->status;\n\t\t\terrors[n].errors[0].opnum = pos->opnum;\n\t\t\tn++;\n\t\t\tif (!list_is_last(&pos->list, &head) &&\n\t\t\t    n < NFS42_LAYOUTERROR_MAX)\n\t\t\t\tcontinue;\n\t\t\tif (nfs42_proc_layouterror(lseg, errors, n) < 0)\n\t\t\t\tbreak;\n\t\t\tn = 0;\n\t\t}\n\t\tkfree(errors);\n\t}\n\tff_layout_free_ds_ioerr(&head);\n}", "target": 0}
{"code": "        virtual ~PendingCallback() { }", "target": 0}
{"code": "static void reds_mig_fill_wait_disconnect(RedsState *reds)\n{\n    spice_assert(!reds->clients.empty());\n    for (auto client: reds->clients) {\n        reds->mig_wait_disconnect_clients.push_front(client);\n    }\n    reds->mig_wait_connect = FALSE;\n    reds->mig_wait_disconnect = TRUE;\n    red_timer_start(reds->mig_timer, MIGRATE_TIMEOUT);\n}", "target": 0}
{"code": "vg_get_config(VuDev *dev, uint8_t *config, uint32_t len)\n{\n    VuGpu *g = container_of(dev, VuGpu, dev.parent);\n    if (len > sizeof(struct virtio_gpu_config)) {\n        return -1;\n    }\n    if (opt_virgl) {\n        g->virtio_config.num_capsets = vg_virgl_get_num_capsets();\n    }\n    memcpy(config, &g->virtio_config, len);\n    return 0;\n}", "target": 0}
{"code": "static void mark_curve_tr_app(cursor_tr *cr, fixed sx, fixed sy, fixed c1x, fixed c1y, fixed c2x, fixed c2y, fixed ex, fixed ey, int depth, int *id)\n{\n        int ax = (sx + c1x)>>1;\n        int ay = (sy + c1y)>>1;\n        int bx = (c1x + c2x)>>1;\n        int by = (c1y + c2y)>>1;\n        int cx = (c2x + ex)>>1;\n        int cy = (c2y + ey)>>1;\n        int dx = (ax + bx)>>1;\n        int dy = (ay + by)>>1;\n        int fx = (bx + cx)>>1;\n        int fy = (by + cy)>>1;\n        int gx = (dx + fx)>>1;\n        int gy = (dy + fy)>>1;\n        assert(depth >= 0);\n        if (depth == 0) {\n            *id += 1;\n            mark_line_tr_app(cr, sx, sy, ex, ey, *id);\n        } else {\n            depth--;\n            mark_curve_tr_app(cr, sx, sy, ax, ay, dx, dy, gx, gy, depth, id);\n            mark_curve_tr_app(cr, gx, gy, fx, fy, cx, cy, ex, ey, depth, id);\n        }\n}", "target": 0}
{"code": "void FrameLoader::cancelAndClear()\n{\n    m_frame->redirectScheduler()->cancel();\n    if (!m_isComplete)\n        closeURL();\n    clear(false);\n    m_frame->script()->updatePlatformScriptObjects();\n}", "target": 0}
{"code": "static int copy_func_state(struct bpf_func_state *dst,\n\t\t\t   const struct bpf_func_state *src)\n{\n\tint err;\n\terr = realloc_func_state(dst, src->allocated_stack, src->acquired_refs,\n\t\t\t\t false);\n\tif (err)\n\t\treturn err;\n\tmemcpy(dst, src, offsetof(struct bpf_func_state, acquired_refs));\n\terr = copy_reference_state(dst, src);\n\tif (err)\n\t\treturn err;\n\treturn copy_stack_state(dst, src);\n}", "target": 0}
{"code": "size_t Curl_conncache_size(struct Curl_easy *data)\n{\n  size_t num;\n  CONNCACHE_LOCK(data);\n  num = data->state.conn_cache->num_conn;\n  CONNCACHE_UNLOCK(data);\n  return num;\n}", "target": 0}
{"code": "static int lua_apr_sha1(lua_State *L)\n{\n    unsigned char digest[APR_SHA1_DIGESTSIZE];\n    apr_sha1_ctx_t sha1;\n    const char     *buffer;\n    char           *result;\n    size_t len;\n    request_rec    *r;\n    r = ap_lua_check_request_rec(L, 1);\n    luaL_checktype(L, 2, LUA_TSTRING);\n    result = apr_pcalloc(r->pool, sizeof(digest) * 2 + 1);\n    buffer = lua_tolstring(L, 2, &len);\n    apr_sha1_init(&sha1);\n    apr_sha1_update(&sha1, buffer, len);\n    apr_sha1_final(digest, &sha1);\n    ap_bin2hex(digest, sizeof(digest), result);\n    lua_pushstring(L, result);\n    return 1;\n}", "target": 0}
{"code": "static u32 rt6_peer_genid(void)\n{\n\treturn atomic_read(&__rt6_peer_genid);\n}", "target": 0}
{"code": "void _single_copy_from_wide( SQLCHAR *out, LPCWSTR in, int len )\n{\n    while ( len >= 0 )\n    {\n        *out = *in;\n        out++;\n        in++;\n        len --;\n    }\n}", "target": 0}
{"code": "int sc_pkcs15emu_gemsafeV1_init_ex( sc_pkcs15_card_t *p15card,\n\t\t\tstruct sc_aid *aid,\n\t\t\tsc_pkcs15emu_opt_t *opts)\n{\n\tif (opts && opts->flags & SC_PKCS15EMU_FLAGS_NO_CHECK)\n\t\treturn sc_pkcs15emu_gemsafeV1_init(p15card);\n\telse {\n\t\tint r = gemsafe_detect_card(p15card);\n\t\tif (r)\n\t\t\treturn SC_ERROR_WRONG_CARD;\n\t\treturn sc_pkcs15emu_gemsafeV1_init(p15card);\n\t}\n}", "target": 0}
{"code": "static long timelib_parse_tz_cor(char **ptr)\n{\n\tchar *begin = *ptr, *end;\n\tlong  tmp;\n\twhile (isdigit(**ptr) || **ptr == ':') {\n\t\t++*ptr;\n\t}\n\tend = *ptr;\n\tswitch (end - begin) {\n\t\tcase 1:\n\t\tcase 2:\n\t\t\treturn HOUR(strtol(begin, NULL, 10));\n\t\t\tbreak;\n\t\tcase 3:\n\t\tcase 4:\n\t\t\tif (begin[1] == ':') {\n\t\t\t\ttmp = HOUR(strtol(begin, NULL, 10)) + strtol(begin + 2, NULL, 10);\n\t\t\t\treturn tmp;\n\t\t\t} else if (begin[2] == ':') {\n\t\t\t\ttmp = HOUR(strtol(begin, NULL, 10)) + strtol(begin + 3, NULL, 10);\n\t\t\t\treturn tmp;\n\t\t\t} else {\n\t\t\t\ttmp = strtol(begin, NULL, 10);\n\t\t\t\treturn HOUR(tmp / 100) + tmp % 100;\n\t\t\t}\n\t\tcase 5:\n\t\t\ttmp = HOUR(strtol(begin, NULL, 10)) + strtol(begin + 3, NULL, 10);\n\t\t\treturn tmp;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void kvm_release_pfn_clean(pfn_t pfn)\n{\n\tif (!kvm_is_mmio_pfn(pfn))\n\t\tput_page(pfn_to_page(pfn));\n}", "target": 0}
{"code": "void IndexedDBDatabase::RenameIndex(IndexedDBTransaction* transaction,\n                                    int64_t object_store_id,\n                                    int64_t index_id,\n                                    const base::string16& new_name) {\n  DCHECK(transaction);\n  IDB_TRACE1(\"IndexedDBDatabase::RenameIndex\", \"txn.id\", transaction->id());\n  DCHECK_EQ(transaction->mode(),\n            blink::mojom::IDBTransactionMode::VersionChange);\n  if (!ValidateObjectStoreIdAndIndexId(object_store_id, index_id))\n    return;\n  IndexedDBIndexMetadata& index_metadata =\n      metadata_.object_stores[object_store_id].indexes[index_id];\n  base::string16 old_name;\n  Status s = metadata_coding_->RenameIndex(\n      transaction->BackingStoreTransaction()->transaction(),\n      transaction->database()->id(), object_store_id, new_name, &old_name,\n      &index_metadata);\n  if (!s.ok()) {\n    ReportErrorWithDetails(s, \"Internal error renaming index.\");\n    return;\n  }\n  DCHECK_EQ(index_metadata.name, new_name);\n  transaction->ScheduleAbortTask(\n      base::BindOnce(&IndexedDBDatabase::RenameIndexAbortOperation, this,\n                     object_store_id, index_id, std::move(old_name)));\n}", "target": 0}
{"code": "get_request_entity(struct conn_s *connptr)\n{\n        int ret;\n        pollfd_struct fds[1] = {0};\n        fds[0].fd = connptr->client_fd;\n        fds[0].events |= MYPOLL_READ;\n        ret = mypoll(fds, 1, config->idletimeout);\n        if (ret == -1) {\n                log_message (LOG_ERR,\n                             \"Error calling \" SELECT_OR_POLL \" on client fd %d: %s\",\n                             connptr->client_fd, strerror(errno));\n        } else if (ret == 0) {\n               log_message (LOG_INFO, \"no entity\");\n        } else if (ret == 1 && (fds[0].revents & MYPOLL_READ)) {\n                ssize_t nread;\n                nread = read_buffer (connptr->client_fd, connptr->cbuffer);\n                if (nread < 0) {\n                        log_message (LOG_ERR,\n                                     \"Error reading readable client_fd %d (%s)\",\n                                     connptr->client_fd, strerror(errno));\n                        ret = -1;\n                } else {\n                        log_message (LOG_INFO,\n                                     \"Read request entity of %ld bytes\",\n                                     (long) nread);\n                        ret = 0;\n                }\n        } else {\n                log_message (LOG_ERR, \"strange situation after \" SELECT_OR_POLL \": \"\n                             \"ret = %d, but client_fd (%d) is not readable...\",\n                             ret, connptr->client_fd);\n                ret = -1;\n        }\n        return ret;\n}", "target": 0}
{"code": "  void update_used_tables()\n  {\n    if (field && field->default_value)\n      field->default_value->expr->update_used_tables();\n  }", "target": 0}
{"code": "static irqreturn_t vhost_vdpa_virtqueue_cb(void *private)\n{\n\tstruct vhost_virtqueue *vq = private;\n\tstruct eventfd_ctx *call_ctx = vq->call_ctx.ctx;\n\tif (call_ctx)\n\t\teventfd_signal(call_ctx, 1);\n\treturn IRQ_HANDLED;\n}", "target": 0}
{"code": "_dbus_get_real_time (long *tv_sec,\n                     long *tv_usec)\n{\n  FILETIME ft;\n  dbus_uint64_t time64;\n  GetSystemTimeAsFileTime (&ft);\n  memcpy (&time64, &ft, sizeof (time64));\n  time64 -= DBUS_INT64_CONSTANT (116444736000000000);\n  time64 /= 10;\n  if (tv_sec)\n    *tv_sec = time64 / 1000000;\n  if (tv_usec)\n    *tv_usec = time64 % 1000000;\n}", "target": 0}
{"code": "static char * coolkey_get_manufacturer(coolkey_cuid_t *cuid)\n{\n\tunsigned short fabricator = bebytes2ushort(cuid->ic_fabricator);\n\tint i;\n\tchar *buf;\n\tconst char *manufacturer_string = \"%04x Unknown\";\n\tsize_t len;\n\tint r;\n\tfor (i=0; i < manufacturer_list_count; i++) {\n\t\tif (manufacturer_list[i].id == fabricator) {\n\t\t\tmanufacturer_string = manufacturer_list[i].string;\n\t\t\tbreak;\n\t\t}\n\t}\n\tlen = strlen(manufacturer_string)+1;\n\tbuf= malloc(len);\n\tif (buf == NULL) {\n\t\treturn NULL;\n\t}\n\tr = snprintf(buf, len, manufacturer_string, fabricator);\n\tif (r < 0) {\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\treturn buf;\n}", "target": 0}
{"code": "static loff_t memory_lseek(struct file *file, loff_t offset, int orig)\n{\n\tloff_t ret;\n\tinode_lock(file_inode(file));\n\tswitch (orig) {\n\tcase SEEK_CUR:\n\t\toffset += file->f_pos;\n\tcase SEEK_SET:\n\t\tif ((unsigned long long)offset >= -MAX_ERRNO) {\n\t\t\tret = -EOVERFLOW;\n\t\t\tbreak;\n\t\t}\n\t\tfile->f_pos = offset;\n\t\tret = file->f_pos;\n\t\tforce_successful_syscall_return();\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tinode_unlock(file_inode(file));\n\treturn ret;\n}", "target": 0}
{"code": "AP_DECLARE(int) ap_some_authn_required(request_rec *r)\n{\n    int access_status;\n    char *olduser = r->user;\n    int rv = FALSE;\n    switch (ap_satisfies(r)) {\n    case SATISFY_ALL:\n    case SATISFY_NOSPEC:\n        if ((access_status = ap_run_access_checker(r)) != OK) {\n            break;\n        }\n        access_status = ap_run_access_checker_ex(r);\n        if (access_status == DECLINED) {\n            rv = TRUE;\n        }\n        break;\n    case SATISFY_ANY:\n        if ((access_status = ap_run_access_checker(r)) == OK) {\n            break;\n        }\n        access_status = ap_run_access_checker_ex(r);\n        if (access_status == DECLINED) {\n            rv = TRUE;\n        }\n        break;\n    }\n    r->user = olduser;\n    return rv;\n}", "target": 0}
{"code": "WebPlugin* RenderView::CreatePepperPlugin(WebFrame* frame,\n                                          const WebPluginParams& params,\n                                          const FilePath& path,\n                                          pepper::PluginModule* pepper_module) {\n  WebPlugin* plugin = new pepper::WebPluginImpl(pepper_module, params,\n                                                pepper_delegate_.AsWeakPtr());\n  if (plugin && !frame->parent() && frame->document().isPluginDocument()) {\n    FilePath pdf_path;\n    PathService::Get(chrome::FILE_PDF_PLUGIN, &pdf_path);\n    if (path == pdf_path)\n      Send(new ViewHostMsg_SetDisplayingPDFContent(routing_id_));\n  }\n  return plugin;\n}", "target": 0}
{"code": "onigenc_utf16_32_get_ctype_code_range(OnigCtype ctype, OnigCodePoint* sb_out,\n                                      const OnigCodePoint* ranges[],\n\t\t\t\t      struct OnigEncodingTypeST* enc ARG_UNUSED)\n{\n  *sb_out = 0x00;\n  return onigenc_unicode_ctype_code_range(ctype, ranges);\n}", "target": 0}
{"code": "  SaveContext* save_context() {return thread_local_top_.save_context_; }", "target": 0}
{"code": "static int em_cmp(struct x86_emulate_ctxt *ctxt)\n{\n\temulate_2op_SrcV(ctxt, \"cmp\");\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}", "target": 0}
{"code": "int nsim_bpf_setup_tc_block_cb(enum tc_setup_type type,\n\t\t\t       void *type_data, void *cb_priv)\n{\n\tstruct tc_cls_bpf_offload *cls_bpf = type_data;\n\tstruct bpf_prog *prog = cls_bpf->prog;\n\tstruct netdevsim *ns = cb_priv;\n\tstruct bpf_prog *oldprog;\n\tif (type != TC_SETUP_CLSBPF) {\n\t\tNSIM_EA(cls_bpf->common.extack,\n\t\t\t\"only offload of BPF classifiers supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (!tc_cls_can_offload_and_chain0(ns->netdev, &cls_bpf->common))\n\t\treturn -EOPNOTSUPP;\n\tif (cls_bpf->common.protocol != htons(ETH_P_ALL)) {\n\t\tNSIM_EA(cls_bpf->common.extack,\n\t\t\t\"only ETH_P_ALL supported as filter protocol\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (!ns->bpf_tc_accept) {\n\t\tNSIM_EA(cls_bpf->common.extack,\n\t\t\t\"netdevsim configured to reject BPF TC offload\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (prog && !prog->aux->offload && !ns->bpf_tc_non_bound_accept) {\n\t\tNSIM_EA(cls_bpf->common.extack,\n\t\t\t\"netdevsim configured to reject unbound programs\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (cls_bpf->command != TC_CLSBPF_OFFLOAD)\n\t\treturn -EOPNOTSUPP;\n\toldprog = cls_bpf->oldprog;\n\tif (ns->bpf_offloaded != oldprog) {\n\t\toldprog = NULL;\n\t\tif (!cls_bpf->prog)\n\t\t\treturn 0;\n\t\tif (ns->bpf_offloaded) {\n\t\t\tNSIM_EA(cls_bpf->common.extack,\n\t\t\t\t\"driver and netdev offload states mismatch\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\treturn nsim_bpf_offload(ns, cls_bpf->prog, oldprog);\n}", "target": 0}
{"code": "static int pfkey_sockaddr_pair_size(sa_family_t family)\n{\n\treturn PFKEY_ALIGN8(pfkey_sockaddr_len(family) * 2);\n}", "target": 0}
{"code": "static int pptp_stop_ctrl_conn_rply(struct pptp_conn_t *conn)\n{\n\tstruct pptp_stop_ctrl_conn *msg = (struct pptp_stop_ctrl_conn*)conn->in_buf;\n\tif (conf_verbose)\n\t\tlog_ppp_info2(\"recv [PPTP Stop-Ctrl-Conn-Reply <Result %i> <Error %i>]\\n\", msg->reason_result, msg->error_code);\n\treturn -1;\n}", "target": 0}
{"code": "static bool match_fanout_group(struct packet_type *ptype, struct sock *sk)\n{\n\tif (sk->sk_family != PF_PACKET)\n\t\treturn false;\n\treturn ptype->af_packet_priv == pkt_sk(sk)->fanout;\n}", "target": 0}
{"code": "GF_Err vwid_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_ViewIdentifierBox *ptr = (GF_ViewIdentifierBox *) s;\n\tISOM_DECREASE_SIZE(s, 3)\n\tgf_bs_read_int(bs, 2);\n\tptr->min_temporal_id = gf_bs_read_int(bs, 3);\n\tptr->max_temporal_id = gf_bs_read_int(bs, 3);\n\tptr->num_views = gf_bs_read_u16(bs);\n\tif (6 * ptr->num_views > ptr->size)\n\t\treturn GF_ISOM_INVALID_FILE;\n\tptr->views = gf_malloc(sizeof(ViewIDEntry)*ptr->num_views);\n\tfor (i=0; i<ptr->num_views; i++) {\n\t\tu32 j;\n\t\tISOM_DECREASE_SIZE(s, 6)\n\t\tgf_bs_read_int(bs, 6);\n\t\tptr->views[i].view_id = gf_bs_read_int(bs, 10);\n\t\tgf_bs_read_int(bs, 6);\n\t\tptr->views[i].view_order_index = gf_bs_read_int(bs, 10);\n\t\tptr->views[i].texture_in_stream = gf_bs_read_int(bs, 1);\n\t\tptr->views[i].texture_in_track = gf_bs_read_int(bs, 1);\n\t\tptr->views[i].depth_in_stream = gf_bs_read_int(bs, 1);\n\t\tptr->views[i].depth_in_track = gf_bs_read_int(bs, 1);\n\t\tptr->views[i].base_view_type = gf_bs_read_int(bs, 2);\n\t\tptr->views[i].num_ref_views = gf_bs_read_int(bs, 10);\n\t\tif (2 * ptr->views[i].num_ref_views > ptr->size)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tptr->views[i].view_refs = gf_malloc(sizeof(ViewIDRefViewEntry)*ptr->views[i].num_ref_views);\n\t\tfor (j=0; j<ptr->views[i].num_ref_views; j++) {\n\t\t\tISOM_DECREASE_SIZE(s, 2)\n\t\t\tgf_bs_read_int(bs, 4);\n\t\t\tptr->views[i].view_refs[j].dep_comp_idc = gf_bs_read_int(bs, 2);\n\t\t\tptr->views[i].view_refs[j].ref_view_id = gf_bs_read_int(bs, 10);\n\t\t}\n\t}\n\treturn GF_OK;", "target": 0}
{"code": "static inline void kvm_async_pf_hash_reset(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tfor (i = 0; i < roundup_pow_of_two(ASYNC_PF_PER_VCPU); i++)\n\t\tvcpu->arch.apf.gfns[i] = ~0;\n}", "target": 0}
{"code": "void LibRaw:: recycle() \n{\n  recycle_datastream();\n#define FREE(a) do { if(a) { free(a); a = NULL;} }while(0)\n  FREE(imgdata.image); \n  FREE(imgdata.thumbnail.thumb);\n  FREE(libraw_internal_data.internal_data.meta_data);\n  FREE(libraw_internal_data.output_data.histogram);\n  FREE(libraw_internal_data.output_data.oprof);\n  FREE(imgdata.color.profile);\n  FREE(imgdata.rawdata.ph1_black);\n  FREE(imgdata.rawdata.raw_alloc); \n#undef FREE\n  ZERO(imgdata.rawdata);\n  ZERO(imgdata.sizes);\n  ZERO(imgdata.color);\n  ZERO(libraw_internal_data);\n  _exitflag = 0;\n#ifdef USE_RAWSPEED\n  if(_rawspeed_decoder)\n    {\n      RawDecoder *d = static_cast<RawDecoder*>(_rawspeed_decoder);\n      delete d;\n    }\n  _rawspeed_decoder = 0;\n#endif\n  if(_x3f_data)\n    {\n      x3f_clear(_x3f_data);\n      _x3f_data = 0;\n    }\n  memmgr.cleanup();\n  imgdata.thumbnail.tformat = LIBRAW_THUMBNAIL_UNKNOWN;\n  imgdata.progress_flags = 0;\n  tls->init();\n}", "target": 0}
{"code": "  template<typename T>\n  inline CImg<_cimg_Tfloat> sinh(const CImg<T>& instance) {\n    return instance.get_sinh();", "target": 0}
{"code": "static int set_timer_callback_state(struct bpf_verifier_env *env,\n\t\t\t\t    struct bpf_func_state *caller,\n\t\t\t\t    struct bpf_func_state *callee,\n\t\t\t\t    int insn_idx)\n{\n\tstruct bpf_map *map_ptr = caller->regs[BPF_REG_1].map_ptr;\n\tcallee->regs[BPF_REG_1].type = CONST_PTR_TO_MAP;\n\t__mark_reg_known_zero(&callee->regs[BPF_REG_1]);\n\tcallee->regs[BPF_REG_1].map_ptr = map_ptr;\n\tcallee->regs[BPF_REG_2].type = PTR_TO_MAP_KEY;\n\t__mark_reg_known_zero(&callee->regs[BPF_REG_2]);\n\tcallee->regs[BPF_REG_2].map_ptr = map_ptr;\n\tcallee->regs[BPF_REG_3].type = PTR_TO_MAP_VALUE;\n\t__mark_reg_known_zero(&callee->regs[BPF_REG_3]);\n\tcallee->regs[BPF_REG_3].map_ptr = map_ptr;\n\t__mark_reg_not_init(env, &callee->regs[BPF_REG_4]);\n\t__mark_reg_not_init(env, &callee->regs[BPF_REG_5]);\n\tcallee->in_async_callback_fn = true;\n\treturn 0;\n}", "target": 0}
{"code": "get_gdb_index_symbol_kind_name (gdb_index_symbol_kind kind)\n{\n  static const char * const kinds[] =\n  {\n    N_ (\"no info\"),\n    N_ (\"type\"),\n    N_ (\"variable\"),\n    N_ (\"function\"),\n    N_ (\"other\"),\n    N_ (\"unused5\"),\n    N_ (\"unused6\"),\n    N_ (\"unused7\")\n  };\n  return _ (kinds[kind]);\n}", "target": 0}
{"code": "char *must_copy_string(const char *entry)\n{\n\tchar *ret;\n\tif (!entry)\n\t\treturn NULL;\n\tdo {\n\t\tret = strdup(entry);\n\t} while (!ret);\n\treturn ret;\n}", "target": 0}
{"code": "static void ldapsrv_call_postprocess_done(struct tevent_req *subreq)\n{\n\tstruct ldapsrv_call *call =\n\t\ttevent_req_callback_data(subreq,\n\t\tstruct ldapsrv_call);\n\tstruct ldapsrv_connection *conn = call->conn;\n\tNTSTATUS status;\n\tstatus = call->postprocess_recv(subreq);\n\tTALLOC_FREE(subreq);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\tconst char *reason;\n\t\treason = talloc_asprintf(call, \"ldapsrv_call_postprocess_done: \"\n\t\t\t\t\t \"call->postprocess_recv() - %s\",\n\t\t\t\t\t nt_errstr(status));\n\t\tif (reason == NULL) {\n\t\t\treason = nt_errstr(status);\n\t\t}\n\t\tldapsrv_terminate_connection(conn, reason);\n\t\treturn;\n\t}\n\tTALLOC_FREE(call);\n\tldapsrv_call_read_next(conn);\n}", "target": 0}
{"code": "static void migrate_timeout(RedsState *reds)\n{\n    spice_debug(\"trace\");\n    spice_assert(reds->mig_wait_connect || reds->mig_wait_disconnect);\n    if (reds->mig_wait_connect) {\n        reds->main_channel->migrate_cancel_wait();\n        reds_mig_target_client_disconnect_all(reds);\n        reds_mig_cleanup(reds);\n    } else {\n        reds_mig_disconnect(reds);\n    }\n}", "target": 0}
{"code": "ProcXkbGetCompatMap(ClientPtr client)\n{\n    xkbGetCompatMapReply \trep;\n    DeviceIntPtr \t\tdev;\n    XkbDescPtr\t\t\txkb;\n    XkbCompatMapPtr\t\tcompat;\n    REQUEST(xkbGetCompatMapReq);\n    REQUEST_SIZE_MATCH(xkbGetCompatMapReq);\n    if (!(client->xkbClientFlags&_XkbClientInitialized))\n\treturn BadAccess;\n    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixGetAttrAccess);\n    xkb = dev->key->xkbInfo->desc;\n    compat= xkb->compat;\n    rep.type = X_Reply;\n    rep.deviceID = dev->id;\n    rep.sequenceNumber = client->sequence;\n    rep.length = 0;\n    rep.firstSI = stuff->firstSI;\n    rep.nSI = stuff->nSI;\n    if (stuff->getAllSI) {\n\trep.firstSI = 0;\n\trep.nSI = compat->num_si;\n    }\n    else if ((((unsigned)stuff->nSI)>0)&&\n\t\t((unsigned)(stuff->firstSI+stuff->nSI-1)>=compat->num_si)) {\n\tclient->errorValue = _XkbErrCode2(0x05,compat->num_si);\n\treturn BadValue;\n    }\n    rep.nTotalSI = compat->num_si;\n    rep.groups= stuff->groups;\n    XkbComputeGetCompatMapReplySize(compat,&rep);\n    return XkbSendCompatMap(client,compat,&rep);\n}", "target": 0}
{"code": "static NTSTATUS send_break_message(struct messaging_context *msg_ctx,\n\t\t\t\t   const struct share_mode_entry *exclusive,\n\t\t\t\t   uint16_t break_to)\n{\n\tNTSTATUS status;\n\tchar msg[MSG_SMB_SHARE_MODE_ENTRY_SIZE];\n\tDEBUG(10, (\"Sending break request to PID %s\\n\",\n\t\t   procid_str_static(&exclusive->pid)));\n\tshare_mode_entry_to_message(msg, exclusive);\n\tSSVAL(msg,OP_BREAK_MSG_OP_TYPE_OFFSET, break_to);\n\tstatus = messaging_send_buf(msg_ctx, exclusive->pid,\n\t\t\t\t    MSG_SMB_BREAK_REQUEST,\n\t\t\t\t    (uint8 *)msg, sizeof(msg));\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\tDEBUG(3, (\"Could not send oplock break message: %s\\n\",\n\t\t\t  nt_errstr(status)));\n\t}\n\treturn status;\n}", "target": 0}
{"code": "static CURLcode cookie_output(struct Curl_easy *data,\n                              struct CookieInfo *c, const char *filename)\n{\n  struct Cookie *co;\n  FILE *out = NULL;\n  bool use_stdout = FALSE;\n  char *tempstore = NULL;\n  CURLcode error = CURLE_OK;\n  if(!c)\n    return CURLE_OK;\n  remove_expired(c);\n  if(!strcmp(\"-\", filename)) {\n    out = stdout;\n    use_stdout = TRUE;\n  }\n  else {\n    error = Curl_fopen(data, filename, &out, &tempstore);\n    if(error)\n      goto error;\n  }\n  fputs(\"# Netscape HTTP Cookie File\\n\"\n        \"# https:\n        \"# This file was generated by libcurl! Edit at your own risk.\\n\\n\",\n        out);\n  if(c->numcookies) {\n    unsigned int i;\n    size_t nvalid = 0;\n    struct Cookie **array;\n    array = calloc(1, sizeof(struct Cookie *) * c->numcookies);\n    if(!array) {\n      error = CURLE_OUT_OF_MEMORY;\n      goto error;\n    }\n    for(i = 0; i < COOKIE_HASH_SIZE; i++) {\n      for(co = c->cookies[i]; co; co = co->next) {\n        if(!co->domain)\n          continue;\n        array[nvalid++] = co;\n      }\n    }\n    qsort(array, nvalid, sizeof(struct Cookie *), cookie_sort_ct);\n    for(i = 0; i < nvalid; i++) {\n      char *format_ptr = get_netscape_format(array[i]);\n      if(!format_ptr) {\n        free(array);\n        error = CURLE_OUT_OF_MEMORY;\n        goto error;\n      }\n      fprintf(out, \"%s\\n\", format_ptr);\n      free(format_ptr);\n    }\n    free(array);\n  }\n  if(!use_stdout) {\n    fclose(out);\n    out = NULL;\n    if(tempstore && Curl_rename(tempstore, filename)) {\n      unlink(tempstore);\n      error = CURLE_WRITE_ERROR;\n      goto error;\n    }\n  }\n  free(tempstore);\n  return CURLE_OK;\nerror:\n  if(out && !use_stdout)\n    fclose(out);\n  free(tempstore);\n  return error;\n}", "target": 0}
{"code": "void PrintWebViewHelper::PrintNode(const blink::WebNode& node) {\n  if (node.isNull() || !node.document().frame()) {\n    return;\n  }\n  if (print_node_in_progress_) {\n    return;\n  }\n  print_node_in_progress_ = true;\n  if (!g_is_preview_enabled_) {\n    blink::WebNode duplicate_node(node);\n    Print(duplicate_node.document().frame(), duplicate_node, false);\n  } else {\n    print_preview_context_.InitWithNode(node);\n    RequestPrintPreview(PRINT_PREVIEW_USER_INITIATED_CONTEXT_NODE);\n  }\n  print_node_in_progress_ = false;\n}", "target": 0}
{"code": "newSWFShape()\n{\n\tSWFShape shape = (SWFShape)malloc(sizeof(struct SWFShape_s));\n\tif (NULL == shape)\n\t\treturn NULL;\n\tSWFCharacterInit((SWFCharacter)shape);\n\tBLOCK(shape)->writeBlock = writeSWFShapeBlockToMethod;\n\tBLOCK(shape)->complete = completeSWFShapeBlock;\n\tBLOCK(shape)->dtor = (destroySWFBlockMethod) destroySWFShape;\n\tBLOCK(shape)->type = SWF_DEFINESHAPE3;\n\tCHARACTERID(shape) = ++SWF_gNumCharacters;\n\tshape->out = newSWFOutput();\n\tCHARACTER(shape)->bounds = newSWFRect(0,0,0,0);\n\tshape->edgeBounds = newSWFRect(0,0,0,0);\n\tshape->records = NULL;\n\tshape->lines = NULL;\n\tshape->fills = NULL;\n\tshape->nRecords = 0;\n\tshape->xpos = 0;\n\tshape->ypos = 0;\n\tshape->nLines = 0;\n\tshape->nFills = 0;\n\tshape->lineWidth = 0;\n\tshape->isMorph = FALSE;\n\tshape->isEnded = FALSE;\n\tshape->flags = 0;\n\tshape->useVersion = SWF_SHAPE3;\n\tSWFOutput_writeUInt8(shape->out, 0); \n#if TRACK_ALLOCS\n\tshape->gcnode = ming_gc_add_node(shape, (dtorfunctype) destroySWFShape);\n#endif\n\treturn shape;\n}", "target": 0}
{"code": "nfsd4_access(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t     union nfsd4_op_u *u)\n{\n\tstruct nfsd4_access *access = &u->access;\n\tif (access->ac_req_access & ~NFS3_ACCESS_FULL)\n\t\treturn nfserr_inval;\n\taccess->ac_resp_access = access->ac_req_access;\n\treturn nfsd_access(rqstp, &cstate->current_fh, &access->ac_resp_access,\n\t\t\t   &access->ac_supported);\n}", "target": 0}
{"code": "int fuse_fs_mkdir(struct fuse_fs *fs, const char *path, mode_t mode)\n{\n    fuse_get_context()->private_data = fs->user_data;\n    if (fs->op.mkdir)\n        return fs->op.mkdir(path, mode);\n    else\n        return -ENOSYS;\n}", "target": 0}
{"code": "static int __init ppp_init(void)\n{\n\tint err;\n\tprintk(KERN_INFO \"PPP generic driver version \" PPP_VERSION \"\\n\");\n\terr = register_pernet_gen_device(&ppp_net_id, &ppp_net_ops);\n\tif (err) {\n\t\tprintk(KERN_ERR \"failed to register PPP pernet device (%d)\\n\", err);\n\t\tgoto out;\n\t}\n\terr = register_chrdev(PPP_MAJOR, \"ppp\", &ppp_device_fops);\n\tif (err) {\n\t\tprintk(KERN_ERR \"failed to register PPP device (%d)\\n\", err);\n\t\tgoto out_net;\n\t}\n\tppp_class = class_create(THIS_MODULE, \"ppp\");\n\tif (IS_ERR(ppp_class)) {\n\t\terr = PTR_ERR(ppp_class);\n\t\tgoto out_chrdev;\n\t}\n\tdevice_create(ppp_class, NULL, MKDEV(PPP_MAJOR, 0), NULL, \"ppp\");\n\treturn 0;\nout_chrdev:\n\tunregister_chrdev(PPP_MAJOR, \"ppp\");\nout_net:\n\tunregister_pernet_gen_device(ppp_net_id, &ppp_net_ops);\nout:\n\treturn err;\n}", "target": 0}
{"code": "BGD_DECLARE(void) gdImageArc (gdImagePtr im, int cx, int cy, int w, int h, int s, int e,\n\t\t\t\t\t\t\t  int color)\n{\n\tgdImageFilledArc (im, cx, cy, w, h, s, e, color, gdNoFill);\n}", "target": 0}
{"code": "void LibRaw::median_filter()\n{\n  ushort(*pix)[4];\n  int pass, c, i, j, k, med[9];\n  static const uchar opt[] = \n      {1, 2, 4, 5, 7, 8, 0, 1, 3, 4, 6, 7, 1, 2, 4, 5, 7, 8, 0,\n       3, 5, 8, 4, 7, 3, 6, 1, 4, 2, 5, 4, 7, 4, 2, 6, 4, 4, 2};\n  for (pass = 1; pass <= med_passes; pass++)\n  {\n    RUN_CALLBACK(LIBRAW_PROGRESS_MEDIAN_FILTER, pass - 1, med_passes);\n    for (c = 0; c < 3; c += 2)\n    {\n      for (pix = image; pix < image + width * height; pix++)\n        pix[0][3] = pix[0][c];\n      for (pix = image + width; pix < image + width * (height - 1); pix++)\n      {\n        if ((pix - image + 1) % width < 2)\n          continue;\n        for (k = 0, i = -width; i <= width; i += width)\n          for (j = i - 1; j <= i + 1; j++)\n            med[k++] = pix[j][3] - pix[j][1];\n        for (i = 0; i < sizeof opt; i += 2)\n          if (med[opt[i]] > med[opt[i + 1]])\n            SWAP(med[opt[i]], med[opt[i + 1]]);\n        pix[0][c] = CLIP(med[4] + pix[0][1]);\n      }\n    }\n  }\n}", "target": 0}
{"code": "static int mpeg4_decode_gop_header(MpegEncContext *s, GetBitContext *gb)\n{\n    int hours, minutes, seconds;\n    if (!show_bits(gb, 23)) {\n        av_log(s->avctx, AV_LOG_WARNING, \"GOP header invalid\\n\");\n        return -1;\n    }\n    hours   = get_bits(gb, 5);\n    minutes = get_bits(gb, 6);\n    skip_bits1(gb);\n    seconds = get_bits(gb, 6);\n    s->time_base = seconds + 60*(minutes + 60*hours);\n    skip_bits1(gb);\n    skip_bits1(gb);\n    return 0;\n}", "target": 0}
{"code": "fetch_ext_or_command_from_buf(buf_t *buf, ext_or_cmd_t **out)\n{\n  char hdr[EXT_OR_CMD_HEADER_SIZE];\n  uint16_t len;\n  check();\n  if (buf->datalen < EXT_OR_CMD_HEADER_SIZE)\n    return 0;\n  peek_from_buf(hdr, sizeof(hdr), buf);\n  len = ntohs(get_uint16(hdr+2));\n  if (buf->datalen < (unsigned)len + EXT_OR_CMD_HEADER_SIZE)\n    return 0;\n  *out = ext_or_cmd_new(len);\n  (*out)->cmd = ntohs(get_uint16(hdr));\n  (*out)->len = len;\n  buf_remove_from_front(buf, EXT_OR_CMD_HEADER_SIZE);\n  fetch_from_buf((*out)->body, len, buf);\n  return 1;\n}", "target": 0}
{"code": "static void update_depend_map_for_order(JOIN *join, ORDER *order)\n{\n  for (; order ; order=order->next)\n  {\n    table_map depend_map;\n    order->item[0]->update_used_tables();\n    order->depend_map=depend_map=order->item[0]->used_tables();\n    order->used= 0;\n    if (!(order->depend_map & (OUTER_REF_TABLE_BIT | RAND_TABLE_BIT))\n        && !order->item[0]->with_sum_func() &&\n        join->join_tab)\n    {\n      for (JOIN_TAB **tab=join->map2table;\n\t   depend_map ;\n\t   tab++, depend_map>>=1)\n      {\n\tif (depend_map & 1)\n\t  order->depend_map|=(*tab)->ref.depend_map;\n      }\n    }\n  }\n}", "target": 0}
{"code": "static bool rmode_exception(struct kvm_vcpu *vcpu, int vec)\n{\n\tswitch (vec) {\n\tcase BP_VECTOR:\n\t\tto_vmx(vcpu)->vcpu.arch.event_exit_inst_len =\n\t\t\tvmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\treturn false;\n\tcase DB_VECTOR:\n\t\tif (vcpu->guest_debug &\n\t\t\t(KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))\n\t\t\treturn false;\n\tcase DE_VECTOR:\n\tcase OF_VECTOR:\n\tcase BR_VECTOR:\n\tcase UD_VECTOR:\n\tcase DF_VECTOR:\n\tcase SS_VECTOR:\n\tcase GP_VECTOR:\n\tcase MF_VECTOR:\n\t\treturn true;\n\tbreak;\n\t}\n\treturn false;\n}", "target": 0}
{"code": "void OmniboxViewWin::OnKeyDown(TCHAR key,\n                               UINT repeat_count,\n                               UINT flags) {\n  delete_at_end_pressed_ = false;\n  if (OnKeyDownAllModes(key, repeat_count, flags))\n    return;\n  if (popup_window_mode_) {\n    DefWindowProc(GetCurrentMessage()->message, key, MAKELPARAM(repeat_count,\n                                                                flags));\n    return;\n  }\n  if (OnKeyDownOnlyWritable(key, repeat_count, flags))\n    return;\n  HandleKeystroke(GetCurrentMessage()->message, key, repeat_count, flags);\n}", "target": 0}
{"code": "_tiff_write (thandle_t handle,\n\t     tdata_t   buf,\n\t     tsize_t   size)\n{\n\treturn -1;\n}", "target": 0}
{"code": "static inline void verify_mm_writelocked(struct mm_struct *mm)\n{\n#ifdef CONFIG_DEBUG_VM\n\tif (unlikely(down_read_trylock(&mm->mmap_sem))) {\n\t\tWARN_ON(1);\n\t\tup_read(&mm->mmap_sem);\n\t}\n#endif\n}", "target": 0}
{"code": "nfsd4_security_inode_setsecctx(struct svc_fh *resfh, struct xdr_netobj *label, u32 *bmval)\n{ }", "target": 0}
{"code": "  void DeleteOriginData(const GURL& origin,\n                        StorageType type) {\n    quota_status_ = kQuotaStatusUnknown;\n    quota_manager_->DeleteOriginData(origin, type,\n        callback_factory_.NewCallback(\n            &QuotaManagerTest::StatusCallback));\n  }", "target": 0}
{"code": "long keyctl_session_to_parent(void)\n{\n\tstruct task_struct *me, *parent;\n\tconst struct cred *mycred, *pcred;\n\tstruct callback_head *newwork, *oldwork;\n\tkey_ref_t keyring_r;\n\tstruct cred *cred;\n\tint ret;\n\tkeyring_r = lookup_user_key(KEY_SPEC_SESSION_KEYRING, 0, KEY_NEED_LINK);\n\tif (IS_ERR(keyring_r))\n\t\treturn PTR_ERR(keyring_r);\n\tret = -ENOMEM;\n\tcred = cred_alloc_blank();\n\tif (!cred)\n\t\tgoto error_keyring;\n\tnewwork = &cred->rcu;\n\tcred->session_keyring = key_ref_to_ptr(keyring_r);\n\tkeyring_r = NULL;\n\tinit_task_work(newwork, key_change_session_keyring);\n\tme = current;\n\trcu_read_lock();\n\twrite_lock_irq(&tasklist_lock);\n\tret = -EPERM;\n\toldwork = NULL;\n\tparent = me->real_parent;\n\tif (parent->pid <= 1 || !parent->mm)\n\t\tgoto unlock;\n\tif (!thread_group_empty(parent))\n\t\tgoto unlock;\n\tmycred = current_cred();\n\tpcred = __task_cred(parent);\n\tif (mycred == pcred ||\n\t    mycred->session_keyring == pcred->session_keyring) {\n\t\tret = 0;\n\t\tgoto unlock;\n\t}\n\tif (!uid_eq(pcred->uid,\t mycred->euid) ||\n\t    !uid_eq(pcred->euid, mycred->euid) ||\n\t    !uid_eq(pcred->suid, mycred->euid) ||\n\t    !gid_eq(pcred->gid,\t mycred->egid) ||\n\t    !gid_eq(pcred->egid, mycred->egid) ||\n\t    !gid_eq(pcred->sgid, mycred->egid))\n\t\tgoto unlock;\n\tif ((pcred->session_keyring &&\n\t     !uid_eq(pcred->session_keyring->uid, mycred->euid)) ||\n\t    !uid_eq(mycred->session_keyring->uid, mycred->euid))\n\t\tgoto unlock;\n\toldwork = task_work_cancel(parent, key_change_session_keyring);\n\tret = task_work_add(parent, newwork, true);\n\tif (!ret)\n\t\tnewwork = NULL;\nunlock:\n\twrite_unlock_irq(&tasklist_lock);\n\trcu_read_unlock();\n\tif (oldwork)\n\t\tput_cred(container_of(oldwork, struct cred, rcu));\n\tif (newwork)\n\t\tput_cred(cred);\n\treturn ret;\nerror_keyring:\n\tkey_ref_put(keyring_r);\n\treturn ret;\n}", "target": 0}
{"code": "InlineBoxPosition ComputeInlineBoxPosition(const Position& position,\n                                           TextAffinity affinity,\n                                           TextDirection primary_direction) {\n  return ComputeInlineBoxPositionTemplate<EditingStrategy>(position, affinity,\n                                                           primary_direction);\n}", "target": 0}
{"code": "void FrameLoader::scheduleCheckLoadComplete()\n{\n    m_shouldCallCheckLoadComplete = true;\n    startCheckCompleteTimer();\n}", "target": 0}
{"code": "archive_read_format_rar_cleanup(struct archive_read *a)\n{\n  struct rar *rar;\n  rar = (struct rar *)(a->format->data);\n  free_codes(a);\n  free(rar->filename);\n  free(rar->filename_save);\n  free(rar->dbo);\n  free(rar->unp_buffer);\n  free(rar->lzss.window);\n  __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context, &g_szalloc);\n  free(rar);\n  (a->format->data) = NULL;\n  return (ARCHIVE_OK);\n}", "target": 0}
{"code": "bool PrintWebViewHelper::InitPrintSettings(bool fit_to_paper_size) {\n  PrintMsg_PrintPages_Params settings;\n  Send(new PrintHostMsg_GetDefaultPrintSettings(routing_id(),\n                                                &settings.params));\n  bool result = true;\n  if (!PrintMsg_Print_Params_IsValid(settings.params))\n    result = false;\n  ignore_css_margins_ = false;\n  settings.pages.clear();\n  settings.params.print_scaling_option = blink::WebPrintScalingOptionSourceSize;\n  if (fit_to_paper_size) {\n    settings.params.print_scaling_option =\n        blink::WebPrintScalingOptionFitToPrintableArea;\n  }\n  SetPrintPagesParams(settings);\n  return result;\n}", "target": 0}
{"code": "int ip6_frag_nqueues(struct net *net)\n{\n\treturn net->ipv6.frags.nqueues;\n}", "target": 0}
{"code": "static inline int track_pfn_insert(struct vm_area_struct *vma, pgprot_t *prot,\n\t\t\t\t   unsigned long pfn)\n{\n\treturn 0;\n}", "target": 0}
{"code": "static inline u32 nfsd4_getfh_rsize(struct svc_rqst *rqstp, struct nfsd4_op *op)\n{\n\treturn (op_encode_hdr_size + 1) * sizeof(__be32) + NFS4_FHSIZE;\n}", "target": 0}
{"code": "void NavigationControllerImpl::DeleteNavigationEntries(\n    const DeletionPredicate& deletionPredicate) {\n  CHECK(CanPruneAllButLastCommitted());\n  std::vector<int> delete_indices;\n  for (size_t i = 0; i < entries_.size(); i++) {\n    if (i != static_cast<size_t>(last_committed_entry_index_) &&\n        deletionPredicate.Run(*entries_[i])) {\n      delete_indices.push_back(i);\n    }\n  }\n  if (delete_indices.empty())\n    return;\n  if (delete_indices.size() == GetEntryCount() - 1U) {\n    PruneAllButLastCommitted();\n  } else {\n    for (auto it = delete_indices.rbegin(); it != delete_indices.rend(); ++it) {\n      RemoveEntryAtIndex(*it);\n    }\n    delegate_->SetHistoryOffsetAndLength(last_committed_entry_index_,\n                                         GetEntryCount());\n  }\n  delegate()->NotifyNavigationEntriesDeleted();\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, IntersectBasicTwoPredCompound) {\n    params.options = QueryPlannerParams::NO_TABLE_SCAN | QueryPlannerParams::INDEX_INTERSECTION;\n    addIndex(BSON(\"a\" << 1 << \"c\" << 1));\n    addIndex(BSON(\"b\" << 1));\n    runQuery(fromjson(\"{a:1, b:1, c:1}\"));\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: {andSorted: {nodes: [\"\n        \"{ixscan: {filter: null, pattern: {a:1, c:1}}},\"\n        \"{ixscan: {filter: null, pattern: {b:1}}}]}}}}\");\n}", "target": 0}
{"code": "void Curl_cookie_freelist(struct Cookie *co, bool cookiestoo)\n{\n  struct Cookie *next;\n  if(co) {\n    while(co) {\n      next = co->next;\n      if(cookiestoo)\n        freecookie(co);\n      else\n        free(co); \n      co = next;\n    }\n  }\n}", "target": 0}
{"code": "static int count_esp_combs(const struct xfrm_tmpl *t)\n{\n\tint i, k, sz = 0;\n\tfor (i = 0; ; i++) {\n\t\tconst struct xfrm_algo_desc *ealg = xfrm_ealg_get_byidx(i);\n\t\tif (!ealg)\n\t\t\tbreak;\n\t\tif (!ealg->pfkey_supported)\n\t\t\tcontinue;\n\t\tif (!(ealg_tmpl_set(t, ealg) && ealg->available))\n\t\t\tcontinue;\n\t\tfor (k = 1; ; k++) {\n\t\t\tconst struct xfrm_algo_desc *aalg = xfrm_aalg_get_byidx(k);\n\t\t\tif (!aalg)\n\t\t\t\tbreak;\n\t\t\tif (!aalg->pfkey_supported)\n\t\t\t\tcontinue;\n\t\t\tif (aalg_tmpl_set(t, aalg) && aalg->available)\n\t\t\t\tsz += sizeof(struct sadb_comb);\n\t\t}\n\t}\n\treturn sz + sizeof(struct sadb_prop);\n}", "target": 0}
{"code": "AnalyserNode* BaseAudioContext::createAnalyser(\n    ExceptionState& exception_state) {\n  DCHECK(IsMainThread());\n  return AnalyserNode::Create(*this, exception_state);\n}", "target": 0}
{"code": "cancel_port_requests(struct intel_engine_execlists * const execlists)\n{\n\tstruct i915_request * const *port;\n\tfor (port = execlists->pending; *port; port++)\n\t\texeclists_schedule_out(*port);\n\tmemset(execlists->pending, 0, sizeof(execlists->pending));\n\tfor (port = xchg(&execlists->active, execlists->pending); *port; port++)\n\t\texeclists_schedule_out(*port);\n\tWRITE_ONCE(execlists->active,\n\t\t   memset(execlists->inflight, 0, sizeof(execlists->inflight)));\n}", "target": 0}
{"code": "void ParamTraits<long>::Log(const param_type& p, std::string* l) {\n  l->append(base::Int64ToString(static_cast<int64>(p)));\n}", "target": 0}
{"code": "static int sched_cpu_inactive(struct notifier_block *nfb,\n\t\t\t\t\tunsigned long action, void *hcpu)\n{\n\tswitch (action & ~CPU_TASKS_FROZEN) {\n\tcase CPU_DOWN_PREPARE:\n\t\tset_cpu_active((long)hcpu, false);\n\t\treturn NOTIFY_OK;\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n}", "target": 0}
{"code": "static inline void nvme_sg_unmap(NvmeSg *sg)\n{\n    if (!(sg->flags & NVME_SG_ALLOC)) {\n        return;\n    }\n    if (sg->flags & NVME_SG_DMA) {\n        qemu_sglist_destroy(&sg->qsg);\n    } else {\n        qemu_iovec_destroy(&sg->iov);\n    }\n    memset(sg, 0x0, sizeof(*sg));\n}", "target": 0}
{"code": "u32 gf_isom_get_sample_duration(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber)\n{\n\tu32 dur;\n\tu64 dts;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !sampleNumber) return 0;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return 0;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\tstbl_GetSampleDTS_and_Duration(trak->Media->information->sampleTable->TimeToSample, sampleNumber, &dts, &dur);\n\treturn dur;\n}", "target": 0}
{"code": "static struct lock *locks_conflict(struct node *node, const struct lock *lock)\n{\n    struct lock *l;\n    for (l = node->locks; l; l = l->next)\n        if (l->owner != lock->owner &&\n            lock->start <= l->end && l->start <= lock->end &&\n            (l->type == F_WRLCK || lock->type == F_WRLCK))\n            break;\n    return l;\n}", "target": 0}
{"code": "void ChildProcessSecurityPolicyImpl::RegisterDisabledSchemes(\n    const std::set<std::string>& schemes) {\n  base::AutoLock lock(lock_);\n  disabled_schemes_ = schemes;\n}", "target": 0}
{"code": "void arch_unmap_area(struct mm_struct *mm, unsigned long addr)\n{\n\tif (addr >= TASK_UNMAPPED_BASE && addr < mm->free_area_cache) {\n\t\tmm->free_area_cache = addr;\n\t\tmm->cached_hole_size = ~0UL;\n\t}\n}", "target": 0}
{"code": "static int __scan_channels(struct ipmi_smi *intf, struct ipmi_device_id *id)\n{\n\tint rv;\n\tif (ipmi_version_major(id) > 1\n\t\t\t|| (ipmi_version_major(id) == 1\n\t\t\t    && ipmi_version_minor(id) >= 5)) {\n\t\tunsigned int set;\n\t\tset = !intf->curr_working_cset;\n\t\tintf->curr_working_cset = set;\n\t\tmemset(&intf->wchannels[set], 0,\n\t\t       sizeof(struct ipmi_channel_set));\n\t\tintf->null_user_handler = channel_handler;\n\t\tintf->curr_channel = 0;\n\t\trv = send_channel_info_cmd(intf, 0);\n\t\tif (rv) {\n\t\t\tdev_warn(intf->si_dev,\n\t\t\t\t \"Error sending channel information for channel 0, %d\\n\",\n\t\t\t\t rv);\n\t\t\treturn -EIO;\n\t\t}\n\t\twait_event(intf->waitq, intf->channels_ready);\n\t\tintf->null_user_handler = NULL;\n\t} else {\n\t\tunsigned int set = intf->curr_working_cset;\n\t\tintf->wchannels[set].c[0].medium = IPMI_CHANNEL_MEDIUM_IPMB;\n\t\tintf->wchannels[set].c[0].protocol = IPMI_CHANNEL_PROTOCOL_IPMB;\n\t\tintf->channel_list = intf->wchannels + set;\n\t\tintf->channels_ready = true;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "int print_to_file(const char *file, const char *content)\n{\n\tFILE *f;\n\tint ret = 0;\n\tf = fopen(file, \"w\");\n\tif (!f)\n\t\treturn -1;\n\tif (fprintf(f, \"%s\", content) != strlen(content))\n\t\tret = -1;\n\tfclose(f);\n\treturn ret;\n}", "target": 0}
{"code": "seamless_send(const char *command, const char *format, ...)\n{\n\tSTREAM s;\n\tsize_t len;\n\tva_list argp;\n\tchar *escaped, buf[1025];\n\tlen = snprintf(buf, sizeof(buf) - 1, \"%s,%u,\", command, seamless_serial);\n\tassert(len < (sizeof(buf) - 1));\n\tva_start(argp, format);\n\tlen += vsnprintf(buf + len, sizeof(buf) - len - 1, format, argp);\n\tva_end(argp);\n\tassert(len < (sizeof(buf) - 1));\n\tescaped = utils_string_escape(buf);\n\tlen = snprintf(buf, sizeof(buf), \"%s\", escaped);\n\tfree(escaped);\n\tassert(len < (sizeof(buf) - 1));\n\tbuf[len] = '\\n';\n\tbuf[len + 1] = '\\0';\n\tlen++;\n\ts = channel_init(seamless_channel, len);\n\tout_uint8p(s, buf, len) s_mark_end(s);\n\tDEBUG_SEAMLESS((\"seamlessrdp sending:%s\", buf));\n#if 0\n\tprintf(\"seamless send:\\n\");\n\thexdump(s->channel_hdr + 8, s->end - s->channel_hdr - 8);\n#endif\n\tchannel_send(s, seamless_channel);\n\treturn seamless_serial++;\n}", "target": 0}
{"code": "static int tipc_nl_retrieve_nodeid(struct nlattr **attrs, u8 **node_id)\n{\n\tstruct nlattr *attr = attrs[TIPC_NLA_NODE_ID];\n\tif (!attr)\n\t\treturn -ENODATA;\n\tif (nla_len(attr) < TIPC_NODEID_LEN)\n\t\treturn -EINVAL;\n\t*node_id = (u8 *)nla_data(attr);\n\treturn 0;\n}", "target": 0}
{"code": "void xtra_box_del(GF_Box *s)\n{\n\tGF_XtraBox *ptr = (GF_XtraBox *)s;\n\twhile (gf_list_count(ptr->tags)) {\n\t\tGF_XtraTag *tag = gf_list_pop_back(ptr->tags);\n\t\tif (tag->name) gf_free(tag->name);\n\t\tif (tag->prop_value) gf_free(tag->prop_value);\n\t\tgf_free(tag);\n\t}\n\tgf_list_del(ptr->tags);\n\tgf_free(s);\n}", "target": 0}
{"code": "void EditorClientBlackBerry::pageDestroyed()\n{\n    delete this;\n}", "target": 0}
{"code": "static void sdhci_poweron_reset(DeviceState *dev)\n{\n    SDHCIState *s = (SDHCIState *)dev;\n    sdhci_reset(s);\n    if (s->pending_insert_quirk) {\n        s->pending_insert_state = true;\n    }\n}", "target": 0}
{"code": "PHP_MINIT_FUNCTION(date)\n{\n\tREGISTER_INI_ENTRIES();\n\tdate_register_classes(TSRMLS_C);\n\tREGISTER_STRING_CONSTANT(\"DATE_ATOM\",    DATE_FORMAT_RFC3339, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_STRING_CONSTANT(\"DATE_COOKIE\",  DATE_FORMAT_COOKIE,  CONST_CS | CONST_PERSISTENT);\n\tREGISTER_STRING_CONSTANT(\"DATE_ISO8601\", DATE_FORMAT_ISO8601, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_STRING_CONSTANT(\"DATE_RFC822\",  DATE_FORMAT_RFC822,  CONST_CS | CONST_PERSISTENT);\n\tREGISTER_STRING_CONSTANT(\"DATE_RFC850\",  DATE_FORMAT_RFC850,  CONST_CS | CONST_PERSISTENT);\n\tREGISTER_STRING_CONSTANT(\"DATE_RFC1036\", DATE_FORMAT_RFC1036, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_STRING_CONSTANT(\"DATE_RFC1123\", DATE_FORMAT_RFC1123, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_STRING_CONSTANT(\"DATE_RFC2822\", DATE_FORMAT_RFC2822, CONST_CS | CONST_PERSISTENT);\n \tREGISTER_STRING_CONSTANT(\"DATE_RFC3339\", DATE_FORMAT_RFC3339, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_STRING_CONSTANT(\"DATE_RSS\",     DATE_FORMAT_RFC1123, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_STRING_CONSTANT(\"DATE_W3C\",     DATE_FORMAT_RFC3339, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SUNFUNCS_RET_TIMESTAMP\", SUNFUNCS_RET_TIMESTAMP, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SUNFUNCS_RET_STRING\", SUNFUNCS_RET_STRING, CONST_CS | CONST_PERSISTENT);\n\tREGISTER_LONG_CONSTANT(\"SUNFUNCS_RET_DOUBLE\", SUNFUNCS_RET_DOUBLE, CONST_CS | CONST_PERSISTENT);\n\tphp_date_global_timezone_db = NULL;\n\tphp_date_global_timezone_db_enabled = 0;\n\tDATEG(last_errors) = NULL;\n\treturn SUCCESS;", "target": 0}
{"code": "print_line_header(Dwarf_Debug dbg,\n    Dwarf_Bool is_single_tab,\n    Dwarf_Bool is_actuals_tab)\n{\nif (!is_single_tab) {\nif (is_actuals_tab) {\n_dwarf_printf(dbg,\"\\nActuals Table\\n\");\n_dwarf_printf(dbg,\n\"                                                         be\\n\"\n\"                                                         ls\\n\"\n\"                                                         ce\\n\"\n\" section    op                                           kq\\n\"\n\" offset     code                address/index    row isa ??\\n\");\n    return;\n} else {\n_dwarf_printf(dbg,\"\\nLogicals Table\\n\");\n_dwarf_printf(dbg,\n\"                                                                              s pe\\n\"\n\"                                                                              tirp\\n\"\n\"                                                                              msoi\\n\"\n\" section          op                                                          tall\\n\"\n\" offset      row  code                address/indx fil lne col disc cntx subp ????\\n\");\n    return;\n}\n}\n_dwarf_printf(dbg,\n\"                                                         s b e p e i d\\n\"\n\"                                                         t l s r p s i\\n\"\n\"                                                         m c e o i a s\\n\"\n\" section    op                                       col t k q l l   c\\n\"\n\" offset     code               address     file line umn ? ? ? ? ?\\n\");\n} ", "target": 0}
{"code": "static gboolean delayed_reload( Cache* cache )\n{\n    if(g_source_is_destroyed(g_main_current_source()))\n        return FALSE;\n    if(cache->need_reload)\n        do_reload(cache);\n    if (cache->need_reload)\n      return TRUE;\n    cache->delayed_reload_handler = 0;\n    return FALSE;\n}", "target": 0}
{"code": "fmtint(int64 value, char type, int forcesign, int leftjust,\n\t   int minlen, int zpad, int precision, int pointflag,\n\t   PrintfTarget *target)\n{\n\tuint64\t\tbase;\n\tint\t\t\tdosign;\n\tconst char *cvt = \"0123456789abcdef\";\n\tint\t\t\tsignvalue = 0;\n\tchar\t\tconvert[64];\n\tint\t\t\tvallen = 0;\n\tint\t\t\tpadlen = 0;\t\t\n\tint\t\t\tzeropad;\t\t\n\tswitch (type)\n\t{\n\t\tcase 'd':\n\t\tcase 'i':\n\t\t\tbase = 10;\n\t\t\tdosign = 1;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tbase = 8;\n\t\t\tdosign = 0;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tbase = 10;\n\t\t\tdosign = 0;\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tbase = 16;\n\t\t\tdosign = 0;\n\t\t\tbreak;\n\t\tcase 'X':\n\t\t\tcvt = \"0123456789ABCDEF\";\n\t\t\tbase = 16;\n\t\t\tdosign = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\t\t\t\t\n\t}\n\tif (dosign && adjust_sign((value < 0), forcesign, &signvalue))\n\t\tvalue = -value;\n\tif (value == 0 && pointflag && precision == 0)\n\t\tvallen = 0;\n\telse\n\t{\n\t\tuint64\t\tuvalue = (uint64) value;\n\t\tdo\n\t\t{\n\t\t\tconvert[vallen++] = cvt[uvalue % base];\n\t\t\tuvalue = uvalue / base;\n\t\t} while (uvalue);\n\t}\n\tzeropad = Max(0, precision - vallen);\n\tadjust_padlen(minlen, vallen + zeropad, leftjust, &padlen);\n\tleading_pad(zpad, &signvalue, &padlen, target);\n\twhile (zeropad-- > 0)\n\t\tdopr_outch('0', target);\n\twhile (vallen > 0)\n\t\tdopr_outch(convert[--vallen], target);\n\ttrailing_pad(&padlen, target);\n}", "target": 0}
{"code": "u8 *ulong2bebytes(u8 *buf, unsigned long x)\n{\n\tif (buf != NULL) {\n\t\tbuf[3] = (u8) (x & 0xff);\n\t\tbuf[2] = (u8) ((x >> 8) & 0xff);\n\t\tbuf[1] = (u8) ((x >> 16) & 0xff);\n\t\tbuf[0] = (u8) ((x >> 24) & 0xff);\n\t}\n\treturn buf;\n}", "target": 0}
{"code": "static void mark_ptr_or_null_reg(struct bpf_func_state *state,\n\t\t\t\t struct bpf_reg_state *reg, u32 id,\n\t\t\t\t bool is_null)\n{\n\tif (type_may_be_null(reg->type) && reg->id == id &&\n\t    !WARN_ON_ONCE(!reg->id)) {\n\t\tif (WARN_ON_ONCE(reg->smin_value || reg->smax_value ||\n\t\t\t\t !tnum_equals_const(reg->var_off, 0) ||\n\t\t\t\t reg->off)) {\n\t\t\t__mark_reg_known_zero(reg);\n\t\t\treg->off = 0;\n\t\t}\n\t\tif (is_null) {\n\t\t\treg->type = SCALAR_VALUE;\n\t\t\treg->id = 0;\n\t\t\treg->ref_obj_id = 0;\n\t\t\treturn;\n\t\t}\n\t\tmark_ptr_not_null_reg(reg);\n\t\tif (!reg_may_point_to_spin_lock(reg)) {\n\t\t\treg->id = 0;\n\t\t}\n\t}\n}", "target": 0}
{"code": "  NetworkLibraryStubImpl()\n      : ip_address_(\"1.1.1.1\"),\n        ethernet_(new EthernetNetwork()),\n        wifi_(NULL),\n        cellular_(NULL) {\n  }", "target": 0}
{"code": "static void spl_array_it_rewind(zend_object_iterator *iter TSRMLS_DC) \n{\n\tspl_array_it       *iterator = (spl_array_it *)iter;\n\tspl_array_object   *object   = iterator->object;\n\tif (object->ar_flags & SPL_ARRAY_OVERLOADED_REWIND) {\n\t\tzend_user_it_rewind(iter TSRMLS_CC);\n\t} else {\n\t\tzend_user_it_invalidate_current(iter TSRMLS_CC);\n\t\tspl_array_rewind(object TSRMLS_CC);\n\t}\n}", "target": 0}
{"code": "    static bool isPrintICC(uint16_t type, Exiv2::PrintStructureOption option)\n    {\n        return type == 0x8773 && option == kpsIccProfile;\n    }", "target": 0}
{"code": "static int begins_with(const char *s, const char *beg)\n{\n\tif (strncmp(s, beg, strlen(beg)) == 0)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}", "target": 0}
{"code": "void HeaderMapImpl::insertByKey(HeaderString&& key, HeaderString&& value) {\n  auto lookup = staticLookup(key.getStringView());\n  if (lookup.has_value()) {\n    key.clear();\n    if (*lookup.value().entry_ == nullptr) {\n      maybeCreateInline(lookup.value().entry_, *lookup.value().key_, std::move(value));\n    } else {\n      const uint64_t added_size =\n          appendToHeader((*lookup.value().entry_)->value(), value.getStringView());\n      addSize(added_size);\n      value.clear();\n    }\n  } else {\n    addSize(key.size() + value.size());\n    std::list<HeaderEntryImpl>::iterator i = headers_.insert(std::move(key), std::move(value));\n    i->entry_ = i;\n  }\n}", "target": 0}
{"code": "int __sched __cond_resched_softirq(void)\n{\n\tBUG_ON(!in_softirq());\n\tif (should_resched(SOFTIRQ_DISABLE_OFFSET)) {\n\t\tlocal_bh_enable();\n\t\tpreempt_schedule_common();\n\t\tlocal_bh_disable();\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "parse_SET_MPLS_TTL(char *arg, const struct ofpact_parse_params *pp)\n{\n    struct ofpact_mpls_ttl *mpls_ttl = ofpact_put_SET_MPLS_TTL(pp->ofpacts);\n    if (*arg == '\\0') {\n        return xstrdup(\"set_mpls_ttl: expected ttl.\");\n    }\n    mpls_ttl->ttl = atoi(arg);\n    return NULL;\n}", "target": 0}
{"code": "void power_pmu_start_txn(struct pmu *pmu)\n{\n\tstruct cpu_hw_events *cpuhw = &__get_cpu_var(cpu_hw_events);\n\tperf_pmu_disable(pmu);\n\tcpuhw->group_flag |= PERF_EVENT_TXN;\n\tcpuhw->n_txn_start = cpuhw->n_events;\n}", "target": 0}
{"code": "format_SET_FIELD(const struct ofpact_set_field *a,\n                 const struct ofpact_format_params *fp)\n{\n    if (a->ofpact.raw == NXAST_RAW_REG_LOAD) {\n        struct mf_subfield dst;\n        uint64_t value;\n        dst.ofs = dst.n_bits = 0;\n        while (next_load_segment(a, &dst, &value)) {\n            ds_put_format(fp->s, \"%sload:%s%#\"PRIx64\"%s->%s\",\n                          colors.special, colors.end, value,\n                          colors.special, colors.end);\n            mf_format_subfield(&dst, fp->s);\n            ds_put_char(fp->s, ',');\n        }\n        ds_chomp(fp->s, ',');\n    } else {\n        ds_put_format(fp->s, \"%sset_field:%s\", colors.special, colors.end);\n        mf_format(a->field, a->value, ofpact_set_field_mask(a),\n                  fp->port_map, fp->s);\n        ds_put_format(fp->s, \"%s->%s%s\",\n                      colors.special, colors.end, a->field->name);\n    }\n}", "target": 0}
{"code": "bool PrintWebViewHelper::ScriptingThrottler::IsAllowed(blink::WebFrame* frame) {\n  const int kMinSecondsToIgnoreJavascriptInitiatedPrint = 2;\n  const int kMaxSecondsToIgnoreJavascriptInitiatedPrint = 32;\n  bool too_frequent = false;\n  if (count_ > 0) {\n    base::TimeDelta diff = base::Time::Now() - last_print_;\n    int min_wait_seconds = kMinSecondsToIgnoreJavascriptInitiatedPrint;\n    if (count_ > 3) {\n      min_wait_seconds =\n          std::min(kMinSecondsToIgnoreJavascriptInitiatedPrint << (count_ - 3),\n                   kMaxSecondsToIgnoreJavascriptInitiatedPrint);\n    }\n    if (diff.InSeconds() < min_wait_seconds) {\n      too_frequent = true;\n    }\n  }\n  if (!too_frequent) {\n    ++count_;\n    last_print_ = base::Time::Now();\n    return true;\n  }\n  blink::WebString message(\n      blink::WebString::fromUTF8(\"Ignoring too frequent calls to print().\"));\n  frame->addMessageToConsole(blink::WebConsoleMessage(\n      blink::WebConsoleMessage::LevelWarning, message));\n  return false;\n}", "target": 0}
{"code": "static void _pam_free_data_info3(pam_handle_t *pamh)\n{\n\tpam_set_data(pamh, PAM_WINBIND_HOMEDIR, NULL, NULL);\n\tpam_set_data(pamh, PAM_WINBIND_LOGONSCRIPT, NULL, NULL);\n\tpam_set_data(pamh, PAM_WINBIND_LOGONSERVER, NULL, NULL);\n\tpam_set_data(pamh, PAM_WINBIND_PROFILEPATH, NULL, NULL);\n}", "target": 0}
{"code": "lou_compileString (const char *tableList, const char *inString)\n{\n  if (!lou_getTable (tableList))\n    return 0;\n  return compileString (inString);\n}", "target": 0}
{"code": "static void sched_rt_do_global(void)\n{\n\tdef_rt_bandwidth.rt_runtime = global_rt_runtime();\n\tdef_rt_bandwidth.rt_period = ns_to_ktime(global_rt_period());\n}", "target": 0}
{"code": "void FrameLoader::checkIfRunInsecureContent(SecurityOrigin* context, const KURL& url)\n{\n    if (!isMixedContent(context, url))\n        return;\n    String message = String::format(\"The page at %s ran insecure content from %s.\\n\",\n        m_URL.string().utf8().data(), url.string().utf8().data());\n    m_frame->domWindow()->console()->addMessage(HTMLMessageSource, LogMessageType, WarningMessageLevel, message, 1, String());\n    m_client->didRunInsecureContent(context);\n}", "target": 0}
{"code": "static filter_pred_fn_t select_comparison_fn(enum filter_op_ids op,\n\t\t\t\t\t    int field_size, int field_is_signed)\n{\n\tfilter_pred_fn_t fn = NULL;\n\tint pred_func_index = -1;\n\tswitch (op) {\n\tcase OP_EQ:\n\tcase OP_NE:\n\t\tbreak;\n\tdefault:\n\t\tif (WARN_ON_ONCE(op < PRED_FUNC_START))\n\t\t\treturn NULL;\n\t\tpred_func_index = op - PRED_FUNC_START;\n\t\tif (WARN_ON_ONCE(pred_func_index > PRED_FUNC_MAX))\n\t\t\treturn NULL;\n\t}\n\tswitch (field_size) {\n\tcase 8:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_64;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s64[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u64[pred_func_index];\n\t\tbreak;\n\tcase 4:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_32;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s32[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u32[pred_func_index];\n\t\tbreak;\n\tcase 2:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_16;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s16[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u16[pred_func_index];\n\t\tbreak;\n\tcase 1:\n\t\tif (pred_func_index < 0)\n\t\t\tfn = filter_pred_8;\n\t\telse if (field_is_signed)\n\t\t\tfn = pred_funcs_s8[pred_func_index];\n\t\telse\n\t\t\tfn = pred_funcs_u8[pred_func_index];\n\t\tbreak;\n\t}\n\treturn fn;\n}", "target": 0}
{"code": "static void selinux_task_to_inode(struct task_struct *p,\n\t\t\t\t  struct inode *inode)\n{\n\tstruct inode_security_struct *isec = selinux_inode(inode);\n\tu32 sid = task_sid(p);\n\tspin_lock(&isec->lock);\n\tisec->sclass = inode_mode_to_security_class(inode->i_mode);\n\tisec->sid = sid;\n\tisec->initialized = LABEL_INITIALIZED;\n\tspin_unlock(&isec->lock);\n}", "target": 0}
{"code": "  SecurityState()\n    : enabled_bindings_(0),\n      can_read_raw_cookies_(false) { }", "target": 0}
{"code": "rb_reg_last_match(VALUE match)\n{\n    return rb_reg_nth_match(0, match);\n}", "target": 0}
{"code": "gb18030_mbc_to_code(const UChar* p, const UChar* end, OnigEncoding enc)\n{\n  int c, i, len;\n  OnigCodePoint n;\n  len = enclen(enc, p, end);\n  n = (OnigCodePoint )(*p++);\n  if (len == 1) return n;\n  for (i = 1; i < len; i++) {\n    if (p >= end) break;\n    c = *p++;\n    n <<= 8;  n += c;\n  }\n  return n;\n}", "target": 0}
{"code": "_vte_terminal_clear_current_line (VteTerminal *terminal)\n{\n\tVteRowData *rowdata;\n\tVteScreen *screen;\n\tscreen = terminal->pvt->screen;\n\tif (_vte_ring_next(screen->row_data) > screen->cursor_current.row) {\n\t\trowdata = _vte_ring_index(screen->row_data, VteRowData *,\n\t\t\t\t\t  screen->cursor_current.row);\n\t\tg_assert(rowdata != NULL);\n\t\tif (rowdata->cells->len > 0) {\n\t\t\tg_array_set_size(rowdata->cells, 0);\n\t\t}\n\t\tvte_g_array_fill(rowdata->cells,\n\t\t\t\t &screen->fill_defaults,\n\t\t\t\t terminal->column_count);\n\t\trowdata->soft_wrapped = 0;\n\t\t_vte_invalidate_cells(terminal,\n\t\t\t\t      0, terminal->column_count,\n\t\t\t\t      screen->cursor_current.row, 1);\n\t}\n\tterminal->pvt->text_deleted_flag = TRUE;\n}", "target": 0}
{"code": "static inline void __vmx_flush_tlb(struct kvm_vcpu *vcpu, int vpid)\n{\n\tvpid_sync_context(vpid);\n\tif (enable_ept) {\n\t\tif (!VALID_PAGE(vcpu->arch.mmu.root_hpa))\n\t\t\treturn;\n\t\tept_sync_context(construct_eptp(vcpu->arch.mmu.root_hpa));\n\t}\n}", "target": 0}
{"code": "static inline void map_to_unicode(unsigned code, const enc_to_uni *table, unsigned *res)\n{\n\t*res = table->inner[ENT_ENC_TO_UNI_STAGE1(code)]->uni_cp[ENT_ENC_TO_UNI_STAGE2(code)];\n}", "target": 0}
{"code": "static bool check_package_owner(GDHCPClient *dhcp_client, gpointer pkt)\n{\n\tif (dhcp_client->type == G_DHCP_IPV6) {\n\t\tstruct dhcpv6_packet *packet6 = pkt;\n\t\tuint32_t xid;\n\t\tif (!packet6)\n\t\t\treturn false;\n\t\txid = packet6->transaction_id[0] << 16 |\n\t\t\tpacket6->transaction_id[1] << 8 |\n\t\t\tpacket6->transaction_id[2];\n\t\tif (xid != dhcp_client->xid)\n\t\t\treturn false;\n\t} else {\n\t\tstruct dhcp_packet *packet = pkt;\n\t\tif (packet->xid != dhcp_client->xid)\n\t\t\treturn false;\n\t\tif (packet->hlen != 6)\n\t\t\treturn false;\n\t\tif (memcmp(packet->chaddr, dhcp_client->mac_address, 6))\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "target": 0}
{"code": "enum AVPixelFormat avcodec_default_get_format(struct AVCodecContext *s, const enum AVPixelFormat *fmt)\n{\n    while (*fmt != AV_PIX_FMT_NONE && is_hwaccel_pix_fmt(*fmt))\n        ++fmt;\n    return fmt[0];\n}", "target": 0}
{"code": "static int gen11_emit_flush_render(struct i915_request *request,\n\t\t\t\t   u32 mode)\n{\n\tif (mode & EMIT_FLUSH) {\n\t\tu32 *cs;\n\t\tu32 flags = 0;\n\t\tflags |= PIPE_CONTROL_CS_STALL;\n\t\tflags |= PIPE_CONTROL_TILE_CACHE_FLUSH;\n\t\tflags |= PIPE_CONTROL_RENDER_TARGET_CACHE_FLUSH;\n\t\tflags |= PIPE_CONTROL_DEPTH_CACHE_FLUSH;\n\t\tflags |= PIPE_CONTROL_DC_FLUSH_ENABLE;\n\t\tflags |= PIPE_CONTROL_FLUSH_ENABLE;\n\t\tflags |= PIPE_CONTROL_QW_WRITE;\n\t\tflags |= PIPE_CONTROL_STORE_DATA_INDEX;\n\t\tcs = intel_ring_begin(request, 6);\n\t\tif (IS_ERR(cs))\n\t\t\treturn PTR_ERR(cs);\n\t\tcs = gen8_emit_pipe_control(cs, flags, LRC_PPHWSP_SCRATCH_ADDR);\n\t\tintel_ring_advance(request, cs);\n\t}\n\tif (mode & EMIT_INVALIDATE) {\n\t\tu32 *cs;\n\t\tu32 flags = 0;\n\t\tflags |= PIPE_CONTROL_CS_STALL;\n\t\tflags |= PIPE_CONTROL_COMMAND_CACHE_INVALIDATE;\n\t\tflags |= PIPE_CONTROL_TLB_INVALIDATE;\n\t\tflags |= PIPE_CONTROL_INSTRUCTION_CACHE_INVALIDATE;\n\t\tflags |= PIPE_CONTROL_TEXTURE_CACHE_INVALIDATE;\n\t\tflags |= PIPE_CONTROL_VF_CACHE_INVALIDATE;\n\t\tflags |= PIPE_CONTROL_CONST_CACHE_INVALIDATE;\n\t\tflags |= PIPE_CONTROL_STATE_CACHE_INVALIDATE;\n\t\tflags |= PIPE_CONTROL_QW_WRITE;\n\t\tflags |= PIPE_CONTROL_STORE_DATA_INDEX;\n\t\tcs = intel_ring_begin(request, 6);\n\t\tif (IS_ERR(cs))\n\t\t\treturn PTR_ERR(cs);\n\t\tcs = gen8_emit_pipe_control(cs, flags, LRC_PPHWSP_SCRATCH_ADDR);\n\t\tintel_ring_advance(request, cs);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static void set_cursor(struct vc_data *vc)\n{\n\tif (!con_is_fg(vc) || console_blanked || vc->vc_mode == KD_GRAPHICS)\n\t\treturn;\n\tif (vc->vc_deccm) {\n\t\tif (vc_is_sel(vc))\n\t\t\tclear_selection();\n\t\tadd_softcursor(vc);\n\t\tif ((vc->vc_cursor_type & 0x0f) != 1)\n\t\t\tvc->vc_sw->con_cursor(vc, CM_DRAW);\n\t} else\n\t\thide_cursor(vc);\n}", "target": 0}
{"code": "void uprobe_clear_state(struct mm_struct *mm)\n{\n\tstruct xol_area *area = mm->uprobes_state.xol_area;\n\tif (!area)\n\t\treturn;\n\tput_page(area->pages[0]);\n\tkfree(area->bitmap);\n\tkfree(area);\n}", "target": 0}
{"code": "static bool red_link_info_test_capability(const RedLinkInfo *link, uint32_t cap)\n{\n    const uint32_t *caps = red_link_info_get_caps(link);\n    return test_capability(caps, link->link_mess->num_common_caps, cap);\n}", "target": 0}
{"code": "full_path_length (const struct url *url)\n{\n  int len = 0;\n#define FROB(el) if (url->el) len += 1 + strlen (url->el)\n  FROB (path);\n  FROB (params);\n  FROB (query);\n#undef FROB\n  return len;\n}", "target": 0}
{"code": "void leva_box_del(GF_Box *s)\n{\n\tGF_LevelAssignmentBox *ptr = (GF_LevelAssignmentBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->levels) gf_free(ptr->levels);\n\tgf_free(ptr);\n}", "target": 0}
{"code": "showString (widechar const *chars, int length)\n{\n  int charPos;\n  int bufPos = 0;\n  scratchBuf[bufPos++] = '\\'';\n  for (charPos = 0; charPos < length; charPos++)\n    {\n      if (chars[charPos] >= 32 && chars[charPos] < 127)\n\tscratchBuf[bufPos++] = (char) chars[charPos];\n      else\n\t{\n\t  char hexbuf[20];\n\t  int hexLength;\n\t  char escapeLetter;\n\t  int leadingZeros;\n\t  int hexPos;\n\t  hexLength = sprintf (hexbuf, \"%x\", chars[charPos]);\n\t  switch (hexLength)\n\t    {\n\t    case 1:\n\t    case 2:\n\t    case 3:\n\t    case 4:\n\t      escapeLetter = 'x';\n\t      leadingZeros = 4 - hexLength;\n\t      break;\n\t    case 5:\n\t      escapeLetter = 'y';\n\t      leadingZeros = 0;\n\t      break;\n\t    case 6:\n\t    case 7:\n\t    case 8:\n\t      escapeLetter = 'z';\n\t      leadingZeros = 8 - hexLength;\n\t      break;\n\t    default:\n\t      escapeLetter = '?';\n\t      leadingZeros = 0;\n\t      break;\n\t    }\n\t  if ((bufPos + leadingZeros + hexLength + 4) >= sizeof (scratchBuf))\n\t    break;\n\t  scratchBuf[bufPos++] = '\\\\';\n\t  scratchBuf[bufPos++] = escapeLetter;\n\t  for (hexPos = 0; hexPos < leadingZeros; hexPos++)\n\t    scratchBuf[bufPos++] = '0';\n\t  for (hexPos = 0; hexPos < hexLength; hexPos++)\n\t    scratchBuf[bufPos++] = hexbuf[hexPos];\n\t}\n    }\n  scratchBuf[bufPos++] = '\\'';\n  scratchBuf[bufPos] = 0;\n  return scratchBuf;\n}", "target": 0}
{"code": "utf16be_is_mbc_ambiguous(OnigCaseFoldType flag, const UChar** pp, const UChar* end)\n{\n  const UChar* p = *pp;\n  (*pp) += EncLen_UTF16[*p];\n  if (*p == 0) {\n    int c, v;\n    p++;\n    if (*p == 0xdf && (flag & INTERNAL_ONIGENC_CASE_FOLD_MULTI_CHAR) != 0) {\n      return TRUE;\n    }\n    c = *p;\n    v = ONIGENC_IS_UNICODE_ISO_8859_1_BIT_CTYPE(c,\n\t\t(BIT_CTYPE_UPPER | BIT_CTYPE_LOWER));\n    if ((v | BIT_CTYPE_LOWER) != 0) {\n      if (c >= 0xaa && c <= 0xba)\n        return FALSE;\n      else\n        return TRUE;\n    }\n    return (v != 0 ? TRUE : FALSE);\n  }\n  return FALSE;\n}", "target": 0}
{"code": "void QuotaManagerProxy::NotifyStorageModified(\n    QuotaClient::ID client_id,\n    const GURL& origin,\n    StorageType type,\n    int64 delta) {\n  if (!io_thread_->BelongsToCurrentThread()) {\n    io_thread_->PostTask(FROM_HERE, NewRunnableMethod(\n        this, &QuotaManagerProxy::NotifyStorageModified,\n        client_id, origin, type, delta));\n    return;\n  }\n  if (manager_)\n    manager_->NotifyStorageModified(client_id, origin, type, delta);\n}", "target": 0}
{"code": "static inline int unix_our_peer(struct sock *sk, struct sock *osk)\n{\n\treturn unix_peer(osk) == sk;\n}", "target": 0}
{"code": "cp1251_get_case_fold_codes_by_str(OnigCaseFoldType flag,\n    const OnigUChar* p, const OnigUChar* end, OnigCaseFoldCodeItem items[], OnigEncoding enc ARG_UNUSED)\n{\n  return onigenc_get_case_fold_codes_by_str_with_map(\n\t     sizeof(CaseFoldMap)/sizeof(OnigPairCaseFoldCodes), CaseFoldMap, 0,\n\t     flag, p, end, items);\n}", "target": 0}
{"code": "static bool FNAME(prefetch_invalid_gpte)(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu_page *sp, u64 *spte,\n\t\t\t\t  u64 gpte)\n{\n\tif (!FNAME(is_present_gpte)(gpte))\n\t\tgoto no_present;\n\tif (PT_HAVE_ACCESSED_DIRTY(vcpu->arch.mmu) &&\n\t    !(gpte & PT_GUEST_ACCESSED_MASK))\n\t\tgoto no_present;\n\tif (FNAME(is_rsvd_bits_set)(vcpu->arch.mmu, gpte, PG_LEVEL_4K))\n\t\tgoto no_present;\n\treturn false;\nno_present:\n\tdrop_spte(vcpu->kvm, spte);\n\treturn true;\n}", "target": 0}
{"code": "static inline void *packet_current_frame(struct packet_sock *po,\n\t\tstruct packet_ring_buffer *rb,\n\t\tint status)\n{\n\treturn packet_lookup_frame(po, rb, rb->head, status);\n}", "target": 0}
{"code": "static inline void __skb_queue_before(struct sk_buff_head *list,\n\t\t\t\t      struct sk_buff *next,\n\t\t\t\t      struct sk_buff *newsk)\n{\n\t__skb_insert(newsk, next->prev, next, list);\n}", "target": 0}
{"code": "    size_t size() const { return result_.size(); }", "target": 0}
{"code": "int WebContentsImpl::DownloadImage(const GURL& url,\n                                   bool is_favicon,\n                                   uint32_t max_bitmap_size,\n                                   const ImageDownloadCallback& callback) {\n  RenderViewHost* host = GetRenderViewHost();\n  int id = StartDownload(host, url, is_favicon, max_bitmap_size);\n  image_download_map_[id] = callback;\n  return id;\n}", "target": 0}
{"code": "check_METER(const struct ofpact_meter *a,\n            const struct ofpact_check_params *cp OVS_UNUSED)\n{\n    uint32_t mid = a->meter_id;\n    return mid == 0 || mid > OFPM13_MAX ? OFPERR_OFPMMFC_INVALID_METER : 0;\n}", "target": 0}
{"code": "static void constInsert(\n  WhereConst *pConst,\n  Expr *pColumn,\n  Expr *pValue\n){\n  pConst->nConst++;\n  pConst->apExpr = sqlite3DbReallocOrFree(pConst->db, pConst->apExpr,\n                         pConst->nConst*2*sizeof(Expr*));\n  if( pConst->apExpr==0 ){\n    pConst->nConst = 0;\n  }else{\n    pConst->apExpr[pConst->nConst*2-2] = pColumn;\n    pConst->apExpr[pConst->nConst*2-1] = pValue;\n  }\n}", "target": 0}
{"code": "wait_for_job(conn c, int timeout)\n{\n    int r;\n    c->state = STATE_WAIT;\n    enqueue_waiting_conn(c);\n    c->pending_timeout = timeout;\n    r = conn_update_evq(c, EV_READ | EV_PERSIST);\n    if (r == -1) return twarnx(\"update events failed\"), conn_close(c);\n}", "target": 0}
{"code": "check_OUTPUT_REG(const struct ofpact_output_reg *a,\n                 const struct ofpact_check_params *cp)\n{\n    return mf_check_src(&a->src, cp->match);\n}", "target": 0}
{"code": "MenuGtk::MenuGtk(MenuGtk::Delegate* delegate,\n                 const MenuCreateMaterial* menu_data,\n                 GtkAccelGroup* accel_group)\n    : delegate_(delegate),\n      dummy_accel_group_(gtk_accel_group_new()),\n      menu_(gtk_menu_new()),\n      factory_(this) {\n  ConnectSignalHandlers();\n  BuildMenuIn(menu_.get(), menu_data, accel_group);\n}", "target": 0}
{"code": "static void zipfilePutU32(u8 *aBuf, u32 val){\n  aBuf[0] = val & 0xFF;\n  aBuf[1] = (val>>8) & 0xFF;\n  aBuf[2] = (val>>16) & 0xFF;\n  aBuf[3] = (val>>24) & 0xFF;\n}", "target": 0}
{"code": "callbacks_show_sidepane_toggled (GtkMenuItem *menuitem, gpointer user_data)\n{\n\tgtk_widget_set_visible (user_data, GTK_CHECK_MENU_ITEM(menuitem)->active);\n}", "target": 0}
{"code": "static void work_around_broken_dhclient(struct virtio_net_hdr *hdr,\n                                        uint8_t *buf, size_t size)\n{\n    if ((hdr->flags & VIRTIO_NET_HDR_F_NEEDS_CSUM) && \n        (size > 27 && size < 1500) && \n        (buf[12] == 0x08 && buf[13] == 0x00) && \n        (buf[23] == 17) && \n        (buf[34] == 0 && buf[35] == 67)) { \n        net_checksum_calculate(buf, size, CSUM_UDP);\n        hdr->flags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM;\n    }\n}", "target": 0}
{"code": "vte_sequence_handler_ae (VteTerminal *terminal, GValueArray *params)\n{\n\tterminal->pvt->screen->alternate_charset = FALSE;\n}", "target": 0}
{"code": " virtual bool supportNonblockingRead() { return true; }", "target": 0}
{"code": "TEST(HeaderMapImplTest, ValidHeaderString) {\n  EXPECT_TRUE(validHeaderString(\"abc\"));\n  EXPECT_FALSE(validHeaderString(absl::string_view(\"a\\000bc\", 4)));\n  EXPECT_FALSE(validHeaderString(\"abc\\n\"));\n}", "target": 0}
{"code": "bool fhas_fs_type(int fd, fs_type_magic magic_val)\n{\n\tint ret;\n\tstruct statfs sb;\n\tret = fstatfs(fd, &sb);\n\tif (ret < 0)\n\t\treturn false;\n\treturn is_fs_type(&sb, magic_val);\n}", "target": 0}
{"code": "blkid_partition blkid_parttable_get_parent(blkid_parttable tab)\n{\n\treturn tab->parent;\n}", "target": 0}
{"code": "save_to_file_cb (const gchar *buf,\n\t\t gsize count,\n\t\t GError **error,\n\t\t gpointer data)\n{\n\tgint bytes;\n\twhile (count > 0) {\n\t\tbytes = fwrite (buf, sizeof (gchar), count, (FILE *) data);\n\t\tif (bytes <= 0)\n\t\t\tbreak;\n\t\tcount -= bytes;\n\t\tbuf += bytes;\n\t}\n\tif (count) {\n\t\tg_set_error_literal (error,\n                                     GDK_PIXBUF_ERROR,\n                                     GDK_PIXBUF_ERROR_FAILED,\n                                     _(\"Couldn't write to TIFF file\"));\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 0}
{"code": "do_curl_close(CurlObject *self)\n{\n    if (check_curl_state(self, 2, \"close\") != 0) {\n        return NULL;\n    }\n    util_curl_close(self);\n    Py_RETURN_NONE;\n}", "target": 0}
{"code": "static int dmar_init_reserved_ranges(void)\n{\n\tstruct pci_dev *pdev = NULL;\n\tstruct iova *iova;\n\tint i;\n\tinit_iova_domain(&reserved_iova_list, VTD_PAGE_SIZE, IOVA_START_PFN);\n\tlockdep_set_class(&reserved_iova_list.iova_rbtree_lock,\n\t\t&reserved_rbtree_key);\n\tiova = reserve_iova(&reserved_iova_list, IOVA_PFN(IOAPIC_RANGE_START),\n\t\tIOVA_PFN(IOAPIC_RANGE_END));\n\tif (!iova) {\n\t\tpr_err(\"Reserve IOAPIC range failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\tfor_each_pci_dev(pdev) {\n\t\tstruct resource *r;\n\t\tfor (i = 0; i < PCI_NUM_RESOURCES; i++) {\n\t\t\tr = &pdev->resource[i];\n\t\t\tif (!r->flags || !(r->flags & IORESOURCE_MEM))\n\t\t\t\tcontinue;\n\t\t\tiova = reserve_iova(&reserved_iova_list,\n\t\t\t\t\t    IOVA_PFN(r->start),\n\t\t\t\t\t    IOVA_PFN(r->end));\n\t\t\tif (!iova) {\n\t\t\t\tpr_err(\"Reserve iova failed\\n\");\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "parse_BUNDLE(const char *arg, const struct ofpact_parse_params *pp)\n{\n    return bundle_parse(arg, pp->port_map, pp->ofpacts);\n}", "target": 0}
{"code": "static bool ok_inflater_noop(ok_inflater *inflater) {\n    (void)inflater;\n    return false;\n}", "target": 0}
{"code": "sctp_disposition_t sctp_sf_t1_init_timer_expire(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const sctp_subtype_t type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *repl = NULL;\n\tstruct sctp_bind_addr *bp;\n\tint attempts = asoc->init_err_counter + 1;\n\tSCTP_DEBUG_PRINTK(\"Timer T1 expired (INIT).\\n\");\n\tSCTP_INC_STATS(net, SCTP_MIB_T1_INIT_EXPIREDS);\n\tif (attempts <= asoc->max_init_attempts) {\n\t\tbp = (struct sctp_bind_addr *) &asoc->base.bind_addr;\n\t\trepl = sctp_make_init(asoc, bp, GFP_ATOMIC, 0);\n\t\tif (!repl)\n\t\t\treturn SCTP_DISPOSITION_NOMEM;\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_CHOOSE_TRANSPORT,\n\t\t\t\tSCTP_CHUNK(repl));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_RESTART,\n\t\t\t\tSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(repl));\n\t} else {\n\t\tSCTP_DEBUG_PRINTK(\"Giving up on INIT, attempts: %d\"\n\t\t\t\t  \" max_init_attempts: %d\\n\",\n\t\t\t\t  attempts, asoc->max_init_attempts);\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,\n\t\t\t\tSCTP_ERROR(ETIMEDOUT));\n\t\tsctp_add_cmd_sf(commands, SCTP_CMD_INIT_FAILED,\n\t\t\t\tSCTP_PERR(SCTP_ERROR_NO_ERROR));\n\t\treturn SCTP_DISPOSITION_DELETE_TCB;\n\t}\n\treturn SCTP_DISPOSITION_CONSUME;\n}", "target": 0}
{"code": "int RenderView::historyBackListCount() {\n  return history_list_offset_ < 0 ? 0 : history_list_offset_;\n}", "target": 0}
{"code": "void WebContentsImpl::UpdatePreferredSize(const gfx::Size& pref_size) {\n  preferred_size_ = pref_size;\n  if (delegate_)\n    delegate_->UpdatePreferredSize(this, pref_size);\n}", "target": 0}
{"code": "void smp_send_ltk_reply(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n  SMP_TRACE_DEBUG(\"%s\", __func__);\n  btm_ble_ltk_request_reply(p_cb->pairing_bda, true, p_data->key.p_data);\n}", "target": 0}
{"code": "SWFShape_addSolidFillStyle(SWFShape shape, byte r, byte g, byte b, byte a)\n{\n\tint  ret;\n\tSWFFillStyle fill = newSWFSolidFillStyle(r, g, b, a);\n\tret = addFillStyle(shape, fill);\n\tif(ret < 0) \n\t{\n\t\tdestroySWFFillStyle(fill);\n\t\treturn NULL;\n\t}\n\telse if(ret == shape->nFills)  \n\t{\n\t\treturn fill;\n\t}\n\telse  \n\t{\n\t\tdestroySWFFillStyle(fill);\n\t\treturn shape->fills[ret];\n\t}\n}", "target": 0}
{"code": "static gps_mask_t json_pass_packet(struct gps_device_t *session UNUSED)\n{\n    gpsd_report(LOG_IO, \"<= GPS: %s\\n\", (char *)session->packet.outbuffer);\n    if (strstr((char *)session->packet.outbuffer, \"DEVICE\") != NULL)\n\tpath_rewrite(session, \"\\\"path\\\":\\\"\");\n    path_rewrite(session, \"\\\"device\\\":\\\"\");\n    if (strstr((char *)session->packet.outbuffer, \"VERSION\") != NULL\n\t|| strstr((char *)session->packet.outbuffer, \"WATCH\") != NULL\n\t|| strstr((char *)session->packet.outbuffer, \"DEVICES\") != NULL) {\n\tsession->packet.outbuffer[session->packet.outbuflen-1] = '\\0';\n\t(void)strlcat((char *)session->packet.outbuffer, \",\\\"remote\\\":\\\"\",\n\t\t      sizeof(session->packet.outbuffer));\n\t(void)strlcat((char *)session->packet.outbuffer,\n\t\t      session->gpsdata.dev.path,\n\t\t      sizeof(session->packet.outbuffer));\n\t(void)strlcat((char *)session->packet.outbuffer, \"\\\"}\",\n\t\t      sizeof(session->packet.outbuffer));\n    }\n    gpsd_report (LOG_PROG,\n\t\t \"JSON, passing through %s\\n\",\n\t\t (char *)session->packet.outbuffer);\n    return PASSTHROUGH_IS;\n}", "target": 0}
{"code": "static void release_maps(struct bpf_verifier_env *env)\n{\n\tint i;\n\tif (env->prog->aux->cgroup_storage)\n\t\tbpf_cgroup_storage_release(env->prog,\n\t\t\t\t\t   env->prog->aux->cgroup_storage);\n\tfor (i = 0; i < env->used_map_cnt; i++)\n\t\tbpf_map_put(env->used_maps[i]);\n}", "target": 0}
{"code": "bool GetURLRowForAutocompleteMatch(Profile* profile,", "target": 0}
{"code": "bool restart_trans_for_tables(THD *thd, TABLE_LIST *table)\n{\n  DBUG_ENTER(\"restart_trans_for_tables\");\n  for (; table; table= table->next_global)\n  {\n    if (table->placeholder())\n      continue;\n    if (check_lock_and_start_stmt(thd, thd->lex, table))\n    {\n      DBUG_ASSERT(0);                           \n      DBUG_RETURN(TRUE);\n    }\n  }\n  DBUG_RETURN(FALSE);\n}", "target": 0}
{"code": "static int udp6_ufo_send_check(struct sk_buff *skb)\n{\n\tconst struct ipv6hdr *ipv6h;\n\tstruct udphdr *uh;\n\tif (skb->encapsulation)\n\t\treturn -EINVAL;\n\tif (!pskb_may_pull(skb, sizeof(*uh)))\n\t\treturn -EINVAL;\n\tipv6h = ipv6_hdr(skb);\n\tuh = udp_hdr(skb);\n\tuh->check = ~csum_ipv6_magic(&ipv6h->saddr, &ipv6h->daddr, skb->len,\n\t\t\t\t     IPPROTO_UDP, 0);\n\tskb->csum_start = skb_transport_header(skb) - skb->head;\n\tskb->csum_offset = offsetof(struct udphdr, check);\n\tskb->ip_summed = CHECKSUM_PARTIAL;\n\treturn 0;\n}", "target": 0}
{"code": "XkbSendCompatMap(\tClientPtr \t\tclient,\n\t\t\tXkbCompatMapPtr \tcompat,\n\t\t\txkbGetCompatMapReply *\trep)\n{\nchar\t*\tdata;\nint\t\tsize;\n    size= rep->length*4;\n    if (size>0) {\n\tdata = (char *)xalloc(size);\n\tif (data) {\n\t    register unsigned i,bit;\n\t    xkbModsWireDesc *\tgrp;\n\t    XkbSymInterpretPtr\tsym= &compat->sym_interpret[rep->firstSI];\n\t    xkbSymInterpretWireDesc *wire = (xkbSymInterpretWireDesc *)data;\n\t    for (i=0;i<rep->nSI;i++,sym++,wire++) {\n\t\twire->sym= sym->sym;\n\t\twire->mods= sym->mods;\n\t\twire->match= sym->match;\n\t\twire->virtualMod= sym->virtual_mod;\n\t\twire->flags= sym->flags;\n\t\tmemcpy((char*)&wire->act,(char*)&sym->act,sz_xkbActionWireDesc);\n\t\tif (client->swapped) {\n\t\t    register int n;\n\t\t    swapl(&wire->sym,n);\n\t\t}\n\t    }\n\t    if (rep->groups) {\n\t\tgrp = (xkbModsWireDesc *)wire;\n\t\tfor (i=0,bit=1;i<XkbNumKbdGroups;i++,bit<<=1) {\n\t\t    if (rep->groups&bit) {\n\t\t\tgrp->mask= compat->groups[i].mask;\n\t\t\tgrp->realMods= compat->groups[i].real_mods;\n\t\t\tgrp->virtualMods= compat->groups[i].vmods;\n\t\t\tif (client->swapped) {\n\t\t\t    register int n;\n\t\t\t    swaps(&grp->virtualMods,n);\n\t\t\t}\n\t\t\tgrp++;\n\t\t    }\n\t\t}\n\t\twire= (xkbSymInterpretWireDesc*)grp;\n\t    }\n\t}\n\telse return BadAlloc;\n    }\n    else data= NULL;\n    if (client->swapped) {\n\tregister int n;\n\tswaps(&rep->sequenceNumber,n);\n\tswapl(&rep->length,n);\n\tswaps(&rep->firstSI,n);\n\tswaps(&rep->nSI,n);\n\tswaps(&rep->nTotalSI,n);\n    }\n    WriteToClient(client, SIZEOF(xkbGetCompatMapReply), (char *)rep);\n    if (data) {\n\tWriteToClient(client, size, data);\n\txfree((char *)data);\n    }\n    return client->noClientException;\n}", "target": 0}
{"code": "lt_dlexit (void)\n{\n  lt_dlloader *loader   = 0;\n  lt_dlhandle  handle   = handles;\n  int\t       errors   = 0;\n  if (!initialized)\n    {\n      LT__SETERROR (SHUTDOWN);\n      ++errors;\n      goto done;\n    }\n  if (--initialized == 0)\n    {\n      int\tlevel;\n      while (handles && LT_DLIS_RESIDENT (handles))\n\t{\n\t  handles = handles->next;\n\t}\n      for (level = 1; handle; ++level)\n\t{\n\t  lt_dlhandle cur = handles;\n\t  int saw_nonresident = 0;\n\t  while (cur)\n\t    {\n\t      lt_dlhandle tmp = cur;\n\t      cur = cur->next;\n\t      if (!LT_DLIS_RESIDENT (tmp))\n\t\t{\n\t\t  saw_nonresident = 1;\n\t\t  if (tmp->info.ref_count <= level)\n\t\t    {\n\t\t      if (lt_dlclose (tmp))\n\t\t\t{\n\t\t\t  ++errors;\n\t\t\t}\n\t\t      if (cur)\n\t\t\t{\n\t\t\t  for (tmp = handles; tmp; tmp = tmp->next)\n\t\t\t    if (tmp == cur)\n\t\t\t      break;\n\t\t\t  if (! tmp)\n\t\t\t    cur = handles;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t  if (!saw_nonresident)\n\t    break;\n\t}\n      if (!errors)\n\tLT__SETERRORSTR (0);\n      for (loader = (lt_dlloader *) lt_dlloader_next (NULL); loader;)\n\t{\n\t  lt_dlloader *next   = (lt_dlloader *) lt_dlloader_next (loader);\n\t  lt_dlvtable *vtable = (lt_dlvtable *) lt_dlloader_get (loader);\n\t  if ((vtable = lt_dlloader_remove ((char *) vtable->name)))\n\t    {\n\t      FREE (vtable);\n\t    }\n\t  else\n\t    {\n\t      const char *err;\n\t      LT__GETERROR (err);\n\t      if (err)\n\t\t++errors;\n\t    }\n\t  loader = next;\n\t}\n      FREE(user_search_path);\n    }\n done:\n  return errors;\n}", "target": 0}
{"code": "ut64 r_bin_mdmp_get_paddr(struct r_bin_mdmp_obj *obj, ut64 vaddr) {\n\tstruct minidump_memory_descriptor64 *memory;\n\tut64 index, paddr = 0;\n\tRListIter *it;\n\tindex = obj->streams.memories64.base_rva;\n\tr_list_foreach (obj->streams.memories64.memories, it, memory) {\n\t\tif (vaddr == memory->start_of_memory_range) {\n\t\t\tpaddr = index;\n\t\t\tbreak;\n\t\t}\n\t\tindex += memory->data_size;\n\t}\n\treturn paddr;\n}", "target": 0}
{"code": "static void decode_array_0000(APEContext *ctx, GetBitContext *gb,\n                              int32_t *out, APERice *rice, int blockstodecode)\n{\n    int i;\n    int ksummax, ksummin;\n    rice->ksum = 0;\n    for (i = 0; i < FFMIN(blockstodecode, 5); i++) {\n        out[i] = get_rice_ook(&ctx->gb, 10);\n        rice->ksum += out[i];\n    }\n    rice->k = av_log2(rice->ksum / 10) + 1;\n    if (rice->k >= 24)\n        return;\n    for (; i < FFMIN(blockstodecode, 64); i++) {\n        out[i] = get_rice_ook(&ctx->gb, rice->k);\n        rice->ksum += out[i];\n        rice->k = av_log2(rice->ksum / ((i + 1) * 2)) + 1;\n        if (rice->k >= 24)\n            return;\n    }\n    ksummax = 1 << rice->k + 7;\n    ksummin = rice->k ? (1 << rice->k + 6) : 0;\n    for (; i < blockstodecode; i++) {\n        out[i] = get_rice_ook(&ctx->gb, rice->k);\n        rice->ksum += out[i] - out[i - 64];\n        while (rice->ksum < ksummin) {\n            rice->k--;\n            ksummin = rice->k ? ksummin >> 1 : 0;\n            ksummax >>= 1;\n        }\n        while (rice->ksum >= ksummax) {\n            rice->k++;\n            if (rice->k > 24)\n                return;\n            ksummax <<= 1;\n            ksummin = ksummin ? ksummin << 1 : 128;\n        }\n    }\n    for (i = 0; i < blockstodecode; i++) {\n        if (out[i] & 1)\n            out[i] = (out[i] >> 1) + 1;\n        else\n            out[i] = -(out[i] >> 1);\n    }\n}", "target": 0}
{"code": "real_crc32(unsigned long crc, const void *buff, size_t len)\n{\n\treturn crc32(crc, buff, (unsigned int)len);\n}", "target": 0}
{"code": "static inline uint16_t ok_inflater_can_write(const ok_inflater *inflater) {\n    if (inflater->buffer_start_pos == 0) {\n        return -inflater->buffer_end_pos - 1;\n    } else if (inflater->buffer_start_pos > inflater->buffer_end_pos) {\n        return inflater->buffer_start_pos - inflater->buffer_end_pos - 1;\n    } else {\n        return -inflater->buffer_end_pos;\n    }\n}", "target": 0}
{"code": "catch(...)\n{\n  throw std::out_of_range(\"xfrBlob out of range\");\n}", "target": 0}
{"code": "static inline void *get_freelist(struct kmem_cache *s, struct page *page)\n{\n\tstruct page new;\n\tunsigned long counters;\n\tvoid *freelist;\n\tdo {\n\t\tfreelist = page->freelist;\n\t\tcounters = page->counters;\n\t\tnew.counters = counters;\n\t\tVM_BUG_ON(!new.frozen);\n\t\tnew.inuse = page->objects;\n\t\tnew.frozen = freelist != NULL;\n\t} while (!__cmpxchg_double_slab(s, page,\n\t\tfreelist, counters,\n\t\tNULL, new.counters,\n\t\t\"get_freelist\"));\n\treturn freelist;\n}", "target": 0}
{"code": "static bool notify_marshall_changes(int num_changes,\n\t\t\t\tuint32_t max_offset,\n\t\t\t\tstruct notify_change_event *changes,\n\t\t\t\tDATA_BLOB *final_blob)\n{\n\tint i;\n\tif (num_changes == -1) {\n\t\treturn false;\n\t}\n\tqsort(changes, num_changes,\n\t      sizeof(*changes), compare_notify_change_events);\n\tfor (i=0; i<num_changes; i++) {\n\t\tenum ndr_err_code ndr_err;\n\t\tstruct notify_change_event *c;\n\t\tstruct FILE_NOTIFY_INFORMATION m;\n\t\tDATA_BLOB blob;\n\t\tuint16_t pad = 0;\n\t\twhile (i+1 < num_changes &&\n\t\t\tnotify_change_record_identical(&changes[i],\n\t\t\t\t\t\t&changes[i+1])) {\n\t\t\ti++;\n\t\t}\n\t\tc = &changes[i];\n\t\tm.FileName1 = c->name;\n\t\tm.FileNameLength = strlen_m(c->name)*2;\n\t\tm.Action = c->action;\n\t\tm._pad = data_blob_null;\n\t\tif (i == (num_changes-1)) {\n\t\t\tm.NextEntryOffset = 0;\n\t\t} else {\n\t\t\tif ((m.FileNameLength % 4) == 2) {\n\t\t\t\tm._pad = data_blob_const(&pad, 2);\n\t\t\t}\n\t\t\tm.NextEntryOffset =\n\t\t\t\tndr_size_FILE_NOTIFY_INFORMATION(&m, 0);\n\t\t}\n\t\tndr_err = ndr_push_struct_blob(&blob, talloc_tos(), &m,\n\t\t\t(ndr_push_flags_fn_t)ndr_push_FILE_NOTIFY_INFORMATION);\n\t\tif (!NDR_ERR_CODE_IS_SUCCESS(ndr_err)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (DEBUGLEVEL >= 10) {\n\t\t\tNDR_PRINT_DEBUG(FILE_NOTIFY_INFORMATION, &m);\n\t\t}\n\t\tif (!data_blob_append(talloc_tos(), final_blob,\n\t\t\t\t      blob.data, blob.length)) {\n\t\t\tdata_blob_free(&blob);\n\t\t\treturn false;\n\t\t}\n\t\tdata_blob_free(&blob);\n\t\tif (final_blob->length > max_offset) {\n\t\t\tDEBUG(10, (\"Client only wanted %d bytes, trying to \"\n\t\t\t\t   \"marshall %d bytes\\n\", (int)max_offset,\n\t\t\t\t   (int)final_blob->length));\n\t\t\treturn False;\n\t\t}\n\t}\n\treturn True;\n}", "target": 0}
{"code": "static void fuse_lib_forget(fuse_req_t req, fuse_ino_t ino,\n                            unsigned long nlookup)\n{\n    struct fuse *f = req_fuse(req);\n    if (f->conf.debug)\n        fprintf(stderr, \"FORGET %llu/%lu\\n\", (unsigned long long)ino, nlookup);\n    forget_node(f, ino, nlookup);\n    fuse_reply_none(req);\n}", "target": 0}
{"code": "opt_dequote(const char **sp, const char **errstrp)\n{\n\tconst char *s = *sp;\n\tchar *ret;\n\tsize_t i;\n\t*errstrp = NULL;\n\tif (*s != '\"') {\n\t\t*errstrp = \"missing start quote\";\n\t\treturn NULL;\n\t}\n\ts++;\n\tif ((ret = malloc(strlen((s)) + 1)) == NULL) {\n\t\t*errstrp = \"memory allocation failed\";\n\t\treturn NULL;\n\t}\n\tfor (i = 0; *s != '\\0' && *s != '\"';) {\n\t\tif (s[0] == '\\\\' && s[1] == '\"')\n\t\t\ts++;\n\t\tret[i++] = *s++;\n\t}\n\tif (*s == '\\0') {\n\t\t*errstrp = \"missing end quote\";\n\t\tfree(ret);\n\t\treturn NULL;\n\t}\n\tret[i] = '\\0';\n\ts++;\n\t*sp = s;\n\treturn ret;\n}", "target": 0}
{"code": "static int udf_load_sequence(struct super_block *sb, struct buffer_head *bh,\n\t\t\t     struct kernel_lb_addr *fileset)\n{\n\tstruct anchorVolDescPtr *anchor;\n\tlong main_s, main_e, reserve_s, reserve_e;\n\tanchor = (struct anchorVolDescPtr *)bh->b_data;\n\tmain_s = le32_to_cpu(anchor->mainVolDescSeqExt.extLocation);\n\tmain_e = le32_to_cpu(anchor->mainVolDescSeqExt.extLength);\n\tmain_e = main_e >> sb->s_blocksize_bits;\n\tmain_e += main_s;\n\treserve_s = le32_to_cpu(anchor->reserveVolDescSeqExt.extLocation);\n\treserve_e = le32_to_cpu(anchor->reserveVolDescSeqExt.extLength);\n\treserve_e = reserve_e >> sb->s_blocksize_bits;\n\treserve_e += reserve_s;\n\tif (!udf_process_sequence(sb, main_s, main_e, fileset))\n\t\treturn 1;\n\treturn !udf_process_sequence(sb, reserve_s, reserve_e, fileset);\n}", "target": 0}
{"code": "static uint16_t nvme_map_addr(NvmeCtrl *n, NvmeSg *sg, hwaddr addr, size_t len)\n{\n    bool cmb = false, pmr = false;\n    if (!len) {\n        return NVME_SUCCESS;\n    }\n    trace_pci_nvme_map_addr(addr, len);\n    if (nvme_addr_is_iomem(n, addr)) {\n        return NVME_DATA_TRAS_ERROR;\n    }\n    if (nvme_addr_is_cmb(n, addr)) {\n        cmb = true;\n    } else if (nvme_addr_is_pmr(n, addr)) {\n        pmr = true;\n    }\n    if (cmb || pmr) {\n        if (sg->flags & NVME_SG_DMA) {\n            return NVME_INVALID_USE_OF_CMB | NVME_DNR;\n        }\n        if (sg->iov.niov + 1 > IOV_MAX) {\n            goto max_mappings_exceeded;\n        }\n        if (cmb) {\n            return nvme_map_addr_cmb(n, &sg->iov, addr, len);\n        } else {\n            return nvme_map_addr_pmr(n, &sg->iov, addr, len);\n        }\n    }\n    if (!(sg->flags & NVME_SG_DMA)) {\n        return NVME_INVALID_USE_OF_CMB | NVME_DNR;\n    }\n    if (sg->qsg.nsg + 1 > IOV_MAX) {\n        goto max_mappings_exceeded;\n    }\n    qemu_sglist_add(&sg->qsg, addr, len);\n    return NVME_SUCCESS;\nmax_mappings_exceeded:\n    NVME_GUEST_ERR(pci_nvme_ub_too_many_mappings,\n                   \"number of mappings exceed 1024\");\n    return NVME_INTERNAL_DEV_ERROR | NVME_DNR;\n}", "target": 0}
{"code": "            Header(const ByteOrder& order, int v, int size, uint64_t offset):\n                byteOrder_(order),\n                version_(v),\n                data_size_(size),\n                dir_offset_(offset)\n            {\n            }", "target": 0}
{"code": "  virtual uint64 DoGetLength()\n  {\n    if (parent_stream)\n      return parent_stream->size();\n    return 0;\n  }", "target": 0}
