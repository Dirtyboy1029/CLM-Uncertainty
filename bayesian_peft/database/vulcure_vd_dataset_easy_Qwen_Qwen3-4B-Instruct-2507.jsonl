{"code": "void device_init()\n{\n    hw_init(LOW_FREQUENCY);\n    if (! tsc_sensor_exists())\n    {\n        _NFC_status = nfc_init();\n    }\n    if (_NFC_status == NFC_IS_ACTIVE)\n    {\n        printf1(TAG_NFC, \"Have NFC\\r\\n\");\n        isLowFreq = 1;\n        IS_BUTTON_PRESSED = is_physical_button_pressed;\n    }\n    else\n    {\n        printf1(TAG_NFC, \"Have NO NFC\\r\\n\");\n        hw_init(HIGH_FREQUENCY);\n        isLowFreq = 0;\n        device_init_button();\n    }\n    usbhid_init();\n    ctaphid_init();\n    ctap_init();\n    device_migrate();\n#if BOOT_TO_DFU\n    flash_option_bytes_init(1);\n#else\n    flash_option_bytes_init(0);\n#endif\n}", "target": 1}
{"code": "PHP_MINFO_FUNCTION(mcrypt) \n{\n\tchar **modules;\n\tchar mcrypt_api_no[16];\n\tint i, count;\n\tsmart_str tmp1 = {0};\n\tsmart_str tmp2 = {0};\n\tmodules = mcrypt_list_algorithms(MCG(algorithms_dir), &count);\n\tif (count == 0) {\n\t\tsmart_str_appends(&tmp1, \"none\");\n\t}\n\tfor (i = 0; i < count; i++) {\n\t\tsmart_str_appends(&tmp1, modules[i]);\n\t\tsmart_str_appendc(&tmp1, ' ');\n\t}\n\tsmart_str_0(&tmp1);\n\tmcrypt_free_p(modules, count);\n\tmodules = mcrypt_list_modes(MCG(modes_dir), &count);\n\tif (count == 0) {\n\t\tsmart_str_appends(&tmp2, \"none\");\n\t}\n\tfor (i = 0; i < count; i++) {\n\t\tsmart_str_appends(&tmp2, modules[i]);\n\t\tsmart_str_appendc(&tmp2, ' ');\n\t}\n\tsmart_str_0 (&tmp2);\n\tmcrypt_free_p (modules, count);\n\tsnprintf (mcrypt_api_no, 16, \"%d\", MCRYPT_API_VERSION);\n\tphp_info_print_table_start();\n\tphp_info_print_table_header(2, \"mcrypt support\", \"enabled\");\n\tphp_info_print_table_header(2, \"mcrypt_filter support\", \"enabled\");\n\tphp_info_print_table_row(2, \"Version\", LIBMCRYPT_VERSION);\n\tphp_info_print_table_row(2, \"Api No\", mcrypt_api_no);\n\tphp_info_print_table_row(2, \"Supported ciphers\", tmp1.c);\n\tphp_info_print_table_row(2, \"Supported modes\", tmp2.c);\n\tsmart_str_free(&tmp1);\n\tsmart_str_free(&tmp2);\n\tphp_info_print_table_end();\n\tDISPLAY_INI_ENTRIES();", "target": 1}
{"code": "TEST_F(SecretManagerImplTest, DeprecatedSanMatcher) {\n  envoy::extensions::transport_sockets::tls::v3::Secret secret_config;\n  const std::string yaml =\n      R\"EOF(\n      name: \"abc.com\"\n      validation_context:\n        trusted_ca: { filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\" }\n        allow_expired_certificate: true\n        match_subject_alt_names:\n          exact: \"example.foo\"\n      )EOF\";\n  TestUtility::loadFromYaml(TestEnvironment::substitute(yaml), secret_config);\n  std::unique_ptr<SecretManager> secret_manager(new SecretManagerImpl(config_tracker_));\n  secret_manager->addStaticSecret(secret_config);\n  ASSERT_EQ(secret_manager->findStaticCertificateValidationContextProvider(\"undefined\"), nullptr);\n  ASSERT_NE(secret_manager->findStaticCertificateValidationContextProvider(\"abc.com\"), nullptr);\n  Ssl::CertificateValidationContextConfigImpl cvc_config(\n      *secret_manager->findStaticCertificateValidationContextProvider(\"abc.com\")->secret(), *api_);\n  EXPECT_EQ(cvc_config.subjectAltNameMatchers().size(), 4);\n  EXPECT_EQ(\"example.foo\", cvc_config.subjectAltNameMatchers()[0].matcher().exact());\n  EXPECT_EQ(envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::DNS,\n            cvc_config.subjectAltNameMatchers()[0].san_type());\n  EXPECT_EQ(\"example.foo\", cvc_config.subjectAltNameMatchers()[1].matcher().exact());\n  EXPECT_EQ(envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::URI,\n            cvc_config.subjectAltNameMatchers()[1].san_type());\n  EXPECT_EQ(\"example.foo\", cvc_config.subjectAltNameMatchers()[2].matcher().exact());\n  EXPECT_EQ(envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::EMAIL,\n            cvc_config.subjectAltNameMatchers()[2].san_type());\n  EXPECT_EQ(\"example.foo\", cvc_config.subjectAltNameMatchers()[3].matcher().exact());\n  EXPECT_EQ(envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::IP_ADDRESS,\n            cvc_config.subjectAltNameMatchers()[3].san_type());\n}", "target": 0}
{"code": "static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rcomp;\n\tstrlcpy(rcomp.type, \"compression\", sizeof(rcomp.type));\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n\t\t    sizeof(struct crypto_report_comp), &rcomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "Sfdouble_t sh_strnum(Shell_t *shp, const char *str, char **ptr, int mode) {\n    Sfdouble_t d;\n    char *last;\n    if (*str == 0) {\n        if (ptr) *ptr = (char *)str;\n        return 0;\n    }\n    errno = 0;\n    d = number(str, &last, shp->inarith ? 0 : 10, NULL);\n    if (*last) {\n        if (*last != '.' || last[1] != '.') {\n            d = strval(shp, str, &last, arith, mode);\n            Varsubscript = true;\n        }\n        if (!ptr && *last && mode > 0) errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);\n    } else if (!d && *str == '-') {\n        d = -0.0;\n    }\n    if (ptr) *ptr = last;\n    return d;\n}", "target": 1}
{"code": "static int spl_heap_it_valid(zend_object_iterator *iter TSRMLS_DC) \n{\n\tspl_heap_it         *iterator = (spl_heap_it *)iter;\n\treturn (iterator->object->heap->count != 0 ? SUCCESS : FAILURE);\n}", "target": 0}
{"code": "static RList* entries(RBinFile* bf) {\n\tRList* ret = NULL;\n\tRBinAddr* addr = NULL;\n\tpsxexe_header psxheader;\n\tif (!(ret = r_list_new ())) {\n\t\treturn NULL;\n\t}\n\tif (!(addr = R_NEW0 (RBinAddr))) {\n\t\tr_list_free (ret);\n\t\treturn NULL;\n\t}\n\tif (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, \"8c17i\", 1) < sizeof (psxexe_header)) {\n\t\teprintf (\"PSXEXE Header truncated\\n\");\n\t\tr_list_free (ret);\n\t\tfree (addr);\n\t\treturn NULL;\n\t}\n\taddr->paddr = (psxheader.pc0 - psxheader.t_addr) + PSXEXE_TEXTSECTION_OFFSET;\n\taddr->vaddr = psxheader.pc0;\n\tr_list_append (ret, addr);\n\treturn ret;\n}", "target": 1}
{"code": "struct crypto_alg *crypto_larval_lookup(const char *name, u32 type, u32 mask)\n{\n\tstruct crypto_alg *alg;\n\tif (!name)\n\t\treturn ERR_PTR(-ENOENT);\n\tmask &= ~(CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD);\n\ttype &= mask;\n\talg = crypto_alg_lookup(name, type, mask);\n\tif (!alg) {\n\t\trequest_module(\"%s\", name);\n\t\tif (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &\n\t\t      CRYPTO_ALG_NEED_FALLBACK))\n\t\t\trequest_module(\"%s-all\", name);\n\t\talg = crypto_alg_lookup(name, type, mask);\n\t}\n\tif (alg)\n\t\treturn crypto_is_larval(alg) ? crypto_larval_wait(alg) : alg;\n\treturn crypto_larval_add(name, type, mask);\n}", "target": 1}
{"code": "static UINT drive_process_irp_query_directory(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tconst WCHAR* path;\n\tDRIVE_FILE* file;\n\tBYTE InitialQuery;\n\tUINT32 PathLength;\n\tUINT32 FsInformationClass;\n\tif (!drive || !irp || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tStream_Read_UINT8(irp->input, InitialQuery);\n\tStream_Read_UINT32(irp->input, PathLength);\n\tStream_Seek(irp->input, 23); \n\tpath = (WCHAR*)Stream_Pointer(irp->input);\n\tif (!Stream_CheckAndLogRequiredLength(TAG, irp->input, PathLength))\n\t\treturn ERROR_INVALID_DATA;\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\tif (file == NULL)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tStream_Write_UINT32(irp->output, 0); \n\t}\n\telse if (!drive_file_query_directory(file, FsInformationClass, InitialQuery, path,\n\t                                     PathLength / sizeof(WCHAR), irp->output))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t}\n\treturn irp->Complete(irp);\n}", "target": 0}
{"code": "static int caif_seqpkt_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t       struct msghdr *m, size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint ret;\n\tint copylen;\n\tret = -EOPNOTSUPP;\n\tif (m->msg_flags&MSG_OOB)\n\t\tgoto read_error;\n\tm->msg_namelen = 0;\n\tskb = skb_recv_datagram(sk, flags, 0 , &ret);\n\tif (!skb)\n\t\tgoto read_error;\n\tcopylen = skb->len;\n\tif (len < copylen) {\n\t\tm->msg_flags |= MSG_TRUNC;\n\t\tcopylen = len;\n\t}\n\tret = skb_copy_datagram_iovec(skb, 0, m->msg_iov, copylen);\n\tif (ret)\n\t\tgoto out_free;\n\tret = (flags & MSG_TRUNC) ? skb->len : copylen;\nout_free:\n\tskb_free_datagram(sk, skb);\n\tcaif_check_flow_release(sk);\n\treturn ret;\nread_error:\n\treturn ret;\n}", "target": 1}
{"code": "static inline bool is_nmi(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VALID_MASK))\n\t\t== (INTR_TYPE_NMI_INTR | INTR_INFO_VALID_MASK);\n}", "target": 0}
{"code": "static bool nvme_nsid_valid(NvmeCtrl *n, uint32_t nsid)\n{\n    return nsid &&\n        (nsid == NVME_NSID_BROADCAST || nsid <= NVME_MAX_NAMESPACES);\n}", "target": 0}
{"code": "Status OpLevelCostEstimator::PredictAvgPool(const OpContext& op_context,\n                                            NodeCosts* node_costs) const {\n  bool found_unknown_shapes = false;\n  const auto& op_info = op_context.op_info;\n  ConvolutionDimensions dims = OpDimensionsFromInputs(\n      op_info.inputs(0).shape(), op_info, &found_unknown_shapes);\n  int64_t ops = dims.batch * dims.ox * dims.oy * dims.oz * dims.kx * dims.ky;\n  node_costs->num_compute_ops = ops;\n  int64_t input_size;\n  if (dims.ky >= dims.sy) {\n    input_size = CalculateTensorSize(op_info.inputs(0), &found_unknown_shapes);\n  } else {  \n    const auto data_size = DataTypeSize(BaseType(op_info.inputs(0).dtype()));\n    input_size = data_size * dims.batch * dims.ix * dims.ky * dims.oy * dims.iz;\n  }\n  node_costs->num_input_bytes_accessed = {input_size};\n  const int64_t output_size =\n      CalculateOutputSize(op_info, &found_unknown_shapes);\n  node_costs->num_output_bytes_accessed = {output_size};\n  node_costs->max_memory = output_size;\n  if (found_unknown_shapes) {\n    node_costs->inaccurate = true;\n    node_costs->num_nodes_with_unknown_shapes = 1;\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "juniper_atm2_print(netdissect_options *ndo,\n                   const struct pcap_pkthdr *h, register const u_char *p)\n{\n        int llc_hdrlen;\n        struct juniper_l2info_t l2info;\n        l2info.pictype = DLT_JUNIPER_ATM2;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        if (l2info.cookie[7] & ATM2_PKT_TYPE_MASK) { \n            oam_print(ndo, p, l2info.length, ATM_OAM_NOHEC);\n            return l2info.header_len;\n        }\n        if (EXTRACT_24BITS(p) == 0xfefe03 || \n            EXTRACT_24BITS(p) == 0xaaaa03) { \n            llc_hdrlen = llc_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);\n            if (llc_hdrlen > 0)\n                return l2info.header_len;\n        }\n        if (l2info.direction != JUNIPER_BPF_PKT_IN && \n            (EXTRACT_32BITS(l2info.cookie) & ATM2_GAP_COUNT_MASK)) {\n            ether_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);\n            return l2info.header_len;\n        }\n        if (p[0] == 0x03) { \n            isoclns_print(ndo, p + 1, l2info.length - 1, l2info.caplen - 1);\n            return l2info.header_len;\n        }\n        if(juniper_ppp_heuristic_guess(ndo, p, l2info.length) != 0) \n            return l2info.header_len;\n        if (ip_heuristic_guess(ndo, p, l2info.length) != 0) \n            return l2info.header_len;\n\treturn l2info.header_len;\n}", "target": 1}
{"code": "static irqreturn_t snd_msnd_interrupt(int irq, void *dev_id)\n{\n\tstruct snd_msnd *chip = dev_id;\n\tvoid *pwDSPQData = chip->mappedbase + DSPQ_DATA_BUFF;\n\twhile (readw(chip->DSPQ + JQS_wTail) != readw(chip->DSPQ + JQS_wHead)) {\n\t\tu16 wTmp;\n\t\tsnd_msnd_eval_dsp_msg(chip,\n\t\t\treadw(pwDSPQData + 2 * readw(chip->DSPQ + JQS_wHead)));\n\t\twTmp = readw(chip->DSPQ + JQS_wHead) + 1;\n\t\tif (wTmp > readw(chip->DSPQ + JQS_wSize))\n\t\t\twritew(0, chip->DSPQ + JQS_wHead);\n\t\telse\n\t\t\twritew(wTmp, chip->DSPQ + JQS_wHead);\n\t}\n\tinb(chip->io + HP_RXL);\n\treturn IRQ_HANDLED;\n}", "target": 1}
{"code": "static void parse_time(pj_scanner *scanner, pjmedia_sdp_session *ses,\n\t\t       volatile parse_context *ctx)\n{\n    pj_str_t str;\n    ctx->last_error = PJMEDIA_SDP_EINTIME;\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n    pj_scan_get_until_ch(scanner, ' ', &str);\n    ses->time.start = pj_strtoul(&str);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_chr(scanner, \" \\t\\r\\n\", &str);\n    ses->time.stop = pj_strtoul(&str);\n    pj_scan_skip_line(scanner);\n}", "target": 1}
{"code": "ev_archive_finalize (GObject *object)\n{\n\tEvArchive *archive = EV_ARCHIVE (object);\n\tswitch (archive->type) {\n\tcase EV_ARCHIVE_TYPE_RAR:\n\tcase EV_ARCHIVE_TYPE_ZIP:\n\tcase EV_ARCHIVE_TYPE_7Z:\n\tcase EV_ARCHIVE_TYPE_TAR:\n\t\tg_clear_pointer (&archive->libar, archive_free);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tG_OBJECT_CLASS (ev_archive_parent_class)->finalize (object);\n}", "target": 0}
{"code": "vte_sequence_handler_DC (VteTerminal *terminal, GValueArray *params)\n{\n\tvte_sequence_handler_multiple(terminal, params, vte_sequence_handler_dc);\n}", "target": 0}
{"code": "int Item::save_time_in_field(Field *field)\n{\n  MYSQL_TIME ltime;\n  if (get_time(&ltime))\n    return set_field_to_null_with_conversions(field, 0);\n  field->set_notnull();\n  return field->store_time_dec(&ltime, decimals);\n}", "target": 0}
{"code": "rtadv_read (struct thread *thread)\n{\n  int sock;\n  int len;\n  u_char buf[RTADV_MSG_SIZE];\n  struct sockaddr_in6 from;\n  ifindex_t ifindex = 0;\n  int hoplimit = -1;\n  struct zebra_vrf *zvrf = THREAD_ARG (thread);\n  sock = THREAD_FD (thread);\n  zvrf->rtadv.ra_read = NULL;\n  rtadv_event (zvrf, RTADV_READ, sock);\n  len = rtadv_recv_packet (sock, buf, BUFSIZ, &from, &ifindex, &hoplimit);\n  if (len < 0) \n    {\n      zlog_warn (\"router solicitation recv failed: %s.\", safe_strerror (errno));\n      return len;\n    }\n  rtadv_process_packet (buf, (unsigned)len, ifindex, hoplimit, zvrf->vrf_id);\n  return 0;\n}", "target": 1}
{"code": "pci_emul_cmdsts_write(struct pci_vdev *dev, int coff, uint32_t new, int bytes)\n{\n\tint i, rshift;\n\tuint32_t cmd, cmd2, changed, old, readonly;\n\tcmd = pci_get_cfgdata16(dev, PCIR_COMMAND);\t\n\trshift = (coff & 0x3) * 8;\n\treadonly = 0xFFFFF880 >> rshift;\n\told = CFGREAD(dev, coff, bytes);\n\tnew &= ~readonly;\n\tnew |= (old & readonly);\n\tCFGWRITE(dev, coff, new, bytes);\t\t\n\tcmd2 = pci_get_cfgdata16(dev, PCIR_COMMAND);\t\n\tchanged = cmd ^ cmd2;\n\tfor (i = 0; i <= PCI_BARMAX; i++) {\n\t\tswitch (dev->bar[i].type) {\n\t\tcase PCIBAR_NONE:\n\t\tcase PCIBAR_MEMHI64:\n\t\t\tbreak;\n\t\tcase PCIBAR_IO:\n\t\t\tif (changed & PCIM_CMD_PORTEN) {\n\t\t\t\tif (porten(dev))\n\t\t\t\t\tregister_bar(dev, i);\n\t\t\t\telse\n\t\t\t\t\tunregister_bar(dev, i);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PCIBAR_MEM32:\n\t\tcase PCIBAR_MEM64:\n\t\t\tif (changed & PCIM_CMD_MEMEN) {\n\t\t\t\tif (memen(dev))\n\t\t\t\t\tregister_bar(dev, i);\n\t\t\t\telse\n\t\t\t\t\tunregister_bar(dev, i);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t}\n\t}\n\tpci_lintr_update(dev);\n}", "target": 1}
{"code": "void pickHyprPicker(sdbus::MethodCall& call) {\n    const std::string HYPRPICKER_CMD = \"hyprpicker --format=rgb --no-fancy\";\n    std::string       rgbColor       = execAndGet(HYPRPICKER_CMD.c_str());\n    if (rgbColor.size() > 12) {\n        Debug::log(ERR, \"hyprpicker returned strange output: \" + rgbColor);\n        sendEmptyDbusMethodReply(call, 1);\n        return;\n    }\n    std::array<uint8_t, 3> colors{0, 0, 0};\n    try {\n        for (uint8_t i = 0; i < 2; i++) {\n            uint64_t next = rgbColor.find(' ');\n            if (next == std::string::npos) {\n                Debug::log(ERR, \"hyprpicker returned strange output: \" + rgbColor);\n                sendEmptyDbusMethodReply(call, 1);\n                return;\n            }\n            colors[i] = std::stoi(rgbColor.substr(0, next));\n            rgbColor  = rgbColor.substr(next + 1, rgbColor.size() - next);\n        }\n        colors[2] = std::stoi(rgbColor);\n    } catch (...) {\n        Debug::log(ERR, \"Reading RGB values from hyprpicker failed. This is likely a string to integer error.\");\n        sendEmptyDbusMethodReply(call, 1);\n    }\n    auto [r, g, b] = colors;\n    std::unordered_map<std::string, sdbus::Variant> results;\n    results[\"color\"] = sdbus::Struct(std::tuple{r / 255.0, g / 255.0, b / 255.0});\n    auto reply = call.createReply();\n    reply << (uint32_t)0;\n    reply << results;\n    reply.send();\n}", "target": 1}
{"code": "static inline int xsave_state(struct xsave_struct *fx, u64 mask)\n{\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\tint err = 0;\n\talternative_input_2(\n\t\t\"1:\"XSAVE,\n\t\t\"1:\"XSAVEOPT,\n\t\tX86_FEATURE_XSAVEOPT,\n\t\t\"1:\"XSAVES,\n\t\tX86_FEATURE_XSAVES,\n\t\t[fx] \"D\" (fx), \"a\" (lmask), \"d\" (hmask) :\n\t\t\"memory\");\n\tasm volatile(\"2:\\n\\t\"\n\t\t     xstate_fault\n\t\t     : \"0\" (0)\n\t\t     : \"memory\");\n\treturn err;\n}", "target": 1}
{"code": "void* CxImage::Create(uint32_t dwWidth, uint32_t dwHeight, uint32_t wBpp, uint32_t imagetype)\n{\n\tif (!Destroy())\n\t\treturn NULL;\n\tif ((dwWidth == 0) || (dwHeight == 0)){\n\t\tstrcpy(info.szLastError,\"CxImage::Create : width and height must be greater than zero\");\n\t\treturn NULL;\n\t}\n    if\t\t(wBpp <= 1)\twBpp = 1;\n    else if (wBpp <= 4)\twBpp = 4;\n    else if (wBpp <= 8)\twBpp = 8;\n    else\t\t\t\twBpp = 24;\n\tif ((((float)dwWidth*(float)dwHeight*(float)wBpp)/8.0f) > (float)CXIMAGE_MAX_MEMORY)\n\t{\n\t\tstrcpy(info.szLastError,\"CXIMAGE_MAX_MEMORY exceeded\");\n\t\treturn NULL;\n\t}\n    switch (wBpp){\n        case 1:\n            head.biClrUsed = 2;\tbreak;\n        case 4:\n            head.biClrUsed = 16; break;\n        case 8:\n            head.biClrUsed = 256; break;\n        default:\n            head.biClrUsed = 0;\n    }\n    info.dwEffWidth = ((((wBpp * dwWidth) + 31) / 32) * 4);\n    info.dwType = imagetype;\n\thead.biSize = sizeof(BITMAPINFOHEADER); \n    head.biWidth = dwWidth;\t\t\n    head.biHeight = dwHeight;\t\n    head.biPlanes = 1;\t\t\t\n    head.biBitCount = (uint16_t)wBpp;\t\t\n    head.biCompression = BI_RGB;    \n    head.biSizeImage = info.dwEffWidth * dwHeight;\n\tpDib = malloc(GetSize()); \n    if (!pDib){\n\t\tstrcpy(info.szLastError,\"CxImage::Create can't allocate memory\");\n\t\treturn NULL;\n\t}\n    pDibLimit = (void*)((uint8_t*)pDib + GetSize());\n\tRGBQUAD* pal=GetPalette();\n\tif (pal) memset(pal,0,GetPaletteSize());\n#if CXIMAGE_SUPPORT_SELECTION\n\tif (pSelection) SelectionDelete();\n#endif \n#if CXIMAGE_SUPPORT_ALPHA\n\tif (pAlpha) AlphaDelete();\n#endif \n    BITMAPINFOHEADER*  lpbi;\n\tlpbi = (BITMAPINFOHEADER*)(pDib);\n    *lpbi = head;\n\tinfo.pImage=GetBits();\n    return pDib; \n}", "target": 0}
{"code": "IOBasicTypes::LongBufferSizeType ObjectByteWriterWithPosition::Write(const IOBasicTypes::Byte* inBuffer,IOBasicTypes::LongBufferSizeType inBufferSize)\n{\n\tCREATE_ISOLATE_CONTEXT;\n\tCREATE_ESCAPABLE_SCOPE;\n    Local<Object> anArray = NEW_ARRAY((int)inBufferSize);\n    for(int i=0;i<(int)inBufferSize;++i)\n        anArray->Set(GET_CURRENT_CONTEXT, NEW_NUMBER(i),NEW_NUMBER(inBuffer[i]));\n\tLocal<Value> value = OBJECT_FROM_PERSISTENT(mObject)->Get(GET_CURRENT_CONTEXT, NEW_STRING(\"write\")).ToLocalChecked();\n    if(value->IsUndefined() || !value->IsFunction())\n    {\n\t\tTHROW_EXCEPTION(\"write is not a function, it should be you know...\");\n        return 0;\n    }\n    Local<Function> func = Local<Function>::Cast(value);\n    Local<Value> args[1];\n    args[0] = anArray;\n\tLocal<Value> result = func->Call(GET_CURRENT_CONTEXT,  OBJECT_FROM_PERSISTENT(mObject), 1, args).ToLocalChecked();\n    if(result.IsEmpty())\n    {\n\t\tTHROW_EXCEPTION(\"wrong return value. it's empty. return the number of written characters\");\n\t\treturn 0;\n    }\n    else if(result->IsNumber())\n    {\n        return TO_UINT32(result)->Value();\n    }\n    else\n    {\n\t\tTHROW_EXCEPTION(\"wrong return value. write should return the number of written characters\");\n\t\treturn 0;\n    }\n}", "target": 1}
{"code": "static int pppol2tp_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel;\n\tint val, len;\n\tint err;\n\tstruct pppol2tp_session *ps;\n\tif (level != SOL_PPPOL2TP)\n\t\treturn udp_prot.getsockopt(sk, level, optname, optval, optlen);\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tlen = min_t(unsigned int, len, sizeof(int));\n\tif (len < 0)\n\t\treturn -EINVAL;\n\terr = -ENOTCONN;\n\tif (sk->sk_user_data == NULL)\n\t\tgoto end;\n\terr = -EBADF;\n\tsession = pppol2tp_sock_to_session(sk);\n\tif (session == NULL)\n\t\tgoto end;\n\tps = l2tp_session_priv(session);\n\tif ((session->session_id == 0) &&\n\t    (session->peer_session_id == 0)) {\n\t\terr = -EBADF;\n\t\ttunnel = l2tp_sock_to_tunnel(ps->tunnel_sock);\n\t\tif (tunnel == NULL)\n\t\t\tgoto end_put_sess;\n\t\terr = pppol2tp_tunnel_getsockopt(sk, tunnel, optname, &val);\n\t\tsock_put(ps->tunnel_sock);\n\t} else\n\t\terr = pppol2tp_session_getsockopt(sk, session, optname, &val);\n\terr = -EFAULT;\n\tif (put_user(len, optlen))\n\t\tgoto end_put_sess;\n\tif (copy_to_user((void __user *) optval, &val, len))\n\t\tgoto end_put_sess;\n\terr = 0;\nend_put_sess:\n\tsock_put(sk);\nend:\n\treturn err;\n}", "target": 1}
{"code": "buf_copy(const buf_t *buf)\n{\n  chunk_t *ch;\n  buf_t *out = buf_new();\n  out->default_chunk_size = buf->default_chunk_size;\n  for (ch = buf->head; ch; ch = ch->next) {\n    chunk_t *newch = chunk_copy(ch);\n    if (out->tail) {\n      out->tail->next = newch;\n      out->tail = newch;\n    } else {\n      out->head = out->tail = newch;\n    }\n  }\n  out->datalen = buf->datalen;\n  return out;\n}", "target": 0}
{"code": "bgp_afi_safi_valid_indices (afi_t afi, safi_t *safi)\n{\n  if ((afi == AFI_IP6 && *safi == BGP_SAFI_VPNV4)\n      || (afi == AFI_IP && *safi == BGP_SAFI_VPNV6))\n    {\n      zlog_warn (\"Invalid afi/safi combination (%u/%u)\", afi, *safi);\n      return 0;\n    }\n  switch (afi)\n    {\n      case AFI_IP:\n#ifdef HAVE_IPV6\n      case AFI_IP6:\n#endif\n        switch (*safi)\n          {\n            case BGP_SAFI_VPNV4:\n            case BGP_SAFI_VPNV6:\n              *safi = SAFI_MPLS_VPN;\n            case SAFI_UNICAST:\n            case SAFI_MULTICAST:\n            case SAFI_MPLS_VPN:\n              return 1;\n          }\n    }\n  zlog_debug (\"unknown afi/safi (%u/%u)\", afi, *safi);\n  return 0;\n}", "target": 0}
{"code": "messageFindArgument(const message *m, const char *variable)\n{\n\tint i;\n\tsize_t len;\n\tassert(m != NULL);\n\tassert(variable != NULL);\n\tlen = strlen(variable);\n\tfor(i = 0; i < m->numberOfArguments; i++) {\n\t\tconst char *ptr;\n\t\tptr = messageGetArgument(m, i);\n\t\tif((ptr == NULL) || (*ptr == '\\0'))\n\t\t\tcontinue;\n#ifdef\tCL_DEBUG\n\t\tcli_dbgmsg(\"messageFindArgument: compare %lu bytes of %s with %s\\n\",\n\t\t\t(unsigned long)len, variable, ptr);\n#endif\n\t\tif(strncasecmp(ptr, variable, len) == 0) {\n\t\t\tptr = &ptr[len];\n\t\t\twhile(isspace(*ptr))\n\t\t\t\tptr++;\n\t\t\tif(*ptr != '=') {\n\t\t\t\tcli_dbgmsg(\"messageFindArgument: no '=' sign found in MIME header '%s' (%s)\\n\", variable, messageGetArgument(m, i));\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif((*++ptr == '\"') && (strchr(&ptr[1], '\"') != NULL)) {\n\t\t\t\tchar *ret = cli_strdup(++ptr);\n\t\t\t\tchar *p;\n\t\t\t\tif(ret == NULL)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif((p = strchr(ret, '\"')) != NULL) {\n\t\t\t\t\tret[strlen(ret) - 1] = '\\0';\n\t\t\t\t\t*p = '\\0';\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\treturn cli_strdup(ptr);\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "Status XlaOpKernelContext::ConstantInputAsShape(int index, TensorShape* shape,\n                                                xla::ValueInferenceMode mode) {\n  xla::Literal literal;\n  TF_RETURN_IF_ERROR(ConstantInput(index, &literal, mode));\n  std::vector<int64_t> dims;\n  TF_RETURN_IF_ERROR(LiteralToInt64Vector(literal, &dims));\n  int64_t num_elements = 1;\n  for (auto i = dims.begin(); i != dims.end(); ++i) {\n    num_elements = MultiplyWithoutOverflow(num_elements, *i);\n    if (num_elements < 0)\n      return errors::InvalidArgument(\n          \"The total elements specified by orig_input_shape is too large.\",\n          \"Encountered overflow after multiplying\", *i,\n          \", result: \", num_elements);\n  }\n  *shape = TensorShape(dims);\n  return OkStatus();\n}", "target": 0}
{"code": "static int snd_timer_user_open(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\tint err;\n\terr = nonseekable_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\ttu = kzalloc(sizeof(*tu), GFP_KERNEL);\n\tif (tu == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&tu->qlock);\n\tinit_waitqueue_head(&tu->qchange_sleep);\n\tmutex_init(&tu->tread_sem);\n\ttu->ticks = 1;\n\ttu->queue_size = 128;\n\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t    GFP_KERNEL);\n\tif (tu->queue == NULL) {\n\t\tkfree(tu);\n\t\treturn -ENOMEM;\n\t}\n\tfile->private_data = tu;\n\treturn 0;\n}", "target": 1}
{"code": "static int em_sysenter(struct x86_emulate_ctxt *ctxt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tu16 cs_sel, ss_sel;\n\tu64 efer = 0;\n\tops->get_msr(ctxt, MSR_EFER, &efer);\n\tif (ctxt->mode == X86EMUL_MODE_REAL)\n\t\treturn emulate_gp(ctxt, 0);\n\tif ((ctxt->mode == X86EMUL_MODE_PROT32) && (efer & EFER_LMA)\n\t    && !vendor_intel(ctxt))\n\t\treturn emulate_ud(ctxt);\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\tsetup_syscalls_segments(ctxt, &cs, &ss);\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_CS, &msr_data);\n\tswitch (ctxt->mode) {\n\tcase X86EMUL_MODE_PROT32:\n\t\tif ((msr_data & 0xfffc) == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT64:\n\t\tif (msr_data == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tctxt->eflags &= ~(EFLG_VM | EFLG_IF);\n\tcs_sel = (u16)msr_data;\n\tcs_sel &= ~SELECTOR_RPL_MASK;\n\tss_sel = cs_sel + 8;\n\tss_sel &= ~SELECTOR_RPL_MASK;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64 || (efer & EFER_LMA)) {\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t}\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n\tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_EIP, &msr_data);\n\tctxt->_eip = msr_data;\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_ESP, &msr_data);\n\t*reg_write(ctxt, VCPU_REGS_RSP) = msr_data;\n\treturn X86EMUL_CONTINUE;\n}", "target": 1}
{"code": "void RenderView::SyncNavigationState() {\n  if (!webview())\n    return;\n  const WebHistoryItem& item = webview()->mainFrame()->currentHistoryItem();\n  if (item.isNull())\n    return;\n  Send(new ViewHostMsg_UpdateState(\n      routing_id_, page_id_, webkit_glue::HistoryItemToString(item)));\n}", "target": 0}
{"code": "static bool IsValidPermutation(const std::string& src, const std::string& dst) {\n  if (src.size() != dst.size()) {\n    return false;\n  }\n  std::map<char, bool> characters;\n  for (const auto c : src) {\n    if (characters[c]) {\n      return false;\n    }\n    characters[c] = true;\n  }\n  for (const auto c : dst) {\n    if (!characters[c]) {\n      return false;\n    }\n    characters[c] = false;\n  }\n  return true;\n}", "target": 0}
{"code": "bool IsHostMemoryArg(const EagerOperation& op, const NodeDef* node_def,\n                     const Device* op_device, const KernelDef* kernel_def,\n                     const int port_id) {\n  if (op.is_function()) return false;\n  if (node_def == nullptr) return false;\n  if (kernel_def == nullptr || op_device == nullptr) return false;\n  const auto& host_memory_args = kernel_def->host_memory_arg();\n  const OpDef& op_def = OpRegistry::Global()->LookUp(op.Name())->op_def;\n  const int arg_id = OpPortIdToArgId(*node_def, op_def.input_arg(), port_id);\n  if (arg_id < 0) {\n    return false;\n  }\n  return std::find(host_memory_args.begin(), host_memory_args.end(),\n                   op_def.input_arg(arg_id).name()) != host_memory_args.end();\n}", "target": 0}
{"code": "int RECORD_LAYER_data_present(const RECORD_LAYER *rl)\n{\n    if (rl->rstate == SSL_ST_READ_BODY)\n        return 1;\n    if (RECORD_LAYER_processed_read_pending(rl))\n        return 1;\n    return 0;\n}", "target": 0}
{"code": "TEST(ArrayOpsTest, QuantizeAndDequantizeV2_ShapeFn) {\n  ShapeInferenceTestOp op(\"QuantizeAndDequantizeV2\");\n  op.input_tensors.resize(3);\n  TF_ASSERT_OK(NodeDefBuilder(\"test\", \"QuantizeAndDequantizeV2\")\n                   .Input(\"input\", 0, DT_FLOAT)\n                   .Input(\"input_min\", 1, DT_FLOAT)\n                   .Input(\"input_max\", 2, DT_FLOAT)\n                   .Attr(\"signed_input\", true)\n                   .Attr(\"num_bits\", 8)\n                   .Attr(\"range_given\", false)\n                   .Attr(\"narrow_range\", false)\n                   .Attr(\"axis\", -1)\n                   .Finalize(&op.node_def));\n  INFER_OK(op, \"?;?;?\", \"in0\");\n  INFER_OK(op, \"[];?;?\", \"in0\");\n  INFER_OK(op, \"[1,2,?,4,5];?;?\", \"in0\");\n  INFER_ERROR(\"Shape must be rank 0 but is rank 1\", op, \"[1,2,?,4,5];[1];[]\");\n  INFER_ERROR(\"Shapes must be equal rank, but are 1 and 0\", op,\n              \"[1,2,?,4,5];[];[1]\");\n  INFER_ERROR(\"Shape must be rank 0 but is rank 1\", op, \"[1,2,?,4,5];[1];[1]\");\n  (*op.node_def.mutable_attr())[\"axis\"].set_i(-2);\n  INFER_ERROR(\"axis should be at least -1, got -2\", op, \"?;?;?\");\n}", "target": 0}
{"code": "header_put_be_8byte (SF_PRIVATE *psf, sf_count_t x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)\n\t{\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} ", "target": 1}
{"code": "UnicodeString DecimalQuantity::toScientificString() const {\n    U_ASSERT(!isApproximate);\n    UnicodeString result;\n    if (isNegative()) {\n        result.append(u'-');\n    }\n    if (precision == 0) {\n        result.append(u\"0E+0\", -1);\n        return result;\n    }\n    int32_t upperPos = std::min(precision + scale, lOptPos) - scale - 1;\n    int32_t lowerPos = std::max(scale, rOptPos) - scale;\n    int32_t p = upperPos;\n    result.append(u'0' + getDigitPos(p));\n    if ((--p) >= lowerPos) {\n        result.append(u'.');\n        for (; p >= lowerPos; p--) {\n            result.append(u'0' + getDigitPos(p));\n        }\n    }\n    result.append(u'E');\n    int32_t _scale = upperPos + scale;\n    if (_scale < 0) {\n        _scale *= -1;\n        result.append(u'-');\n    } else {\n        result.append(u'+');\n    }\n    if (_scale == 0) {\n        result.append(u'0');\n    }\n    int32_t insertIndex = result.length();\n    while (_scale > 0) {\n        std::div_t res = std::div(_scale, 10);\n        result.insert(insertIndex, u'0' + res.rem);\n        _scale = res.quot;\n    }\n    return result;\n}", "target": 1}
{"code": "static bool php_mb_parse_encoding(const Variant& encoding,\n                                  mbfl_encoding ***return_list,\n                                  int *return_size, bool persistent) {\n  bool ret;\n  if (encoding.isArray()) {\n    ret = php_mb_parse_encoding_array(encoding.toArray(),\n                                      return_list, return_size,\n                                      persistent ? 1 : 0);\n  } else {\n    String enc = encoding.toString();\n    ret = php_mb_parse_encoding_list(enc.data(), enc.size(),\n                                     return_list, return_size,\n                                     persistent ? 1 : 0);\n  }\n  if (!ret) {\n    if (return_list && *return_list) {\n      free(*return_list);\n      *return_list = nullptr;\n    }\n    return_size = 0;\n  }\n  return ret;\n}", "target": 1}
{"code": "  virtual ~EmbeddedWorkerBrowserTest() {}", "target": 0}
{"code": "check(str, sub, should)\nchar *str;\nmy_regmatch_t sub;\nchar *should;\n{\n\tregister int len;\n\tregister int shlen;\n\tregister char *p;\n\tstatic char grump[500];\n\tregister char *at = NULL;\n\tif (should != NULL && strcmp(should, \"-\") == 0)\n\t\tshould = NULL;\n\tif (should != NULL && should[0] == '@') {\n\t\tat = should + 1;\n\t\tshould = (char*) \"\";\n\t}\n\tif (sub.rm_so > sub.rm_eo || (sub.rm_so == -1 && sub.rm_eo != -1) ||\n\t\t\t\t(sub.rm_so != -1 && sub.rm_eo == -1) ||\n\t\t\t\t(sub.rm_so != -1 && sub.rm_so < 0) ||\n\t\t\t\t(sub.rm_eo != -1 && sub.rm_eo < 0) ) {\n\t\tsprintf(grump, \"start %ld end %ld\", (long)sub.rm_so,\n\t\t\t\t\t\t\t(long)sub.rm_eo);\n\t\treturn(grump);\n\t}\n\tif (sub.rm_so == -1 && should == NULL)\n\t\treturn(NULL);\n\tif (sub.rm_so == -1)\n\t\treturn((char*) \"did not match\");\n\tif ((int) sub.rm_eo > (int) strlen(str)) {\n\t\tsprintf(grump, \"start %ld end %ld, past end of string\",\n\t\t\t\t\t(long)sub.rm_so, (long)sub.rm_eo);\n\t\treturn(grump);\n\t}\n\tlen = (int)(sub.rm_eo - sub.rm_so);\n\tshlen = (int)strlen(should);\n\tp = str + sub.rm_so;\n\tif (should == NULL) {\n\t\tsprintf(grump, \"matched `%.*s'\", len, p);\n\t\treturn(grump);\n\t}\n\tif (len != shlen || strncmp(p, should, (size_t)shlen) != 0) {\n\t\tsprintf(grump, \"matched `%.*s' instead\", len, p);\n\t\treturn(grump);\n\t}\n\tif (shlen > 0)\n\t\treturn(NULL);\n\tif (at == NULL)\n\t\treturn(NULL);\n\tshlen = strlen(at);\n\tif (shlen == 0)\n\t\tshlen = 1;\t\n\tif (strncmp(p, at, shlen) != 0) {\n\t\tsprintf(grump, \"matched null at `%.20s'\", p);\n\t\treturn(grump);\n\t}\n\treturn(NULL);\n}", "target": 1}
{"code": "static void load_xref_from_plaintext(FILE *fp, xref_t *xref)\n{\n    int  i, buf_idx, obj_id, added_entries;\n    char c, buf[32] = {0};\n    long start, pos;\n    start = ftell(fp);\n    pos = xref->end;\n    fseek(fp, pos, SEEK_SET);\n    while (ftell(fp) != 0)\n      if (SAFE_F(fp, (fgetc(fp) == '/' && fgetc(fp) == 'S')))\n        break;\n      else\n        SAFE_E(fseek(fp, --pos, SEEK_SET), 0, \"Failed seek to xref /Size.\\n\");\n    SAFE_E(fread(buf, 1, 21, fp), 21, \"Failed to load entry Size string.\\n\");\n    xref->n_entries = atoi(buf + strlen(\"ize \"));\n    xref->entries = calloc(1, xref->n_entries * sizeof(struct _xref_entry));\n    obj_id = 0;\n    fseek(fp, xref->start + strlen(\"xref\"), SEEK_SET);\n    added_entries = 0;\n    for (i=0; i<xref->n_entries; i++)\n    {\n        c = fgetc(fp);\n        while (c == '\\n' || c == '\\r')\n          c = fgetc(fp);\n        buf_idx = 0;\n        while (c != '\\n' && c != '\\r' && !feof(fp) &&\n               !ferror(fp) && buf_idx < sizeof(buf))\n        {\n            buf[buf_idx++] = c;\n            c = fgetc(fp);\n        }\n        if (buf_idx >= sizeof(buf))\n        {\n            ERR(\"Failed to locate newline character. \"\n                \"This might be a corrupt PDF.\\n\");\n            exit(EXIT_FAILURE);\n        }\n        buf[buf_idx] = '\\0';\n        if (strchr(buf, 't'))\n          break;\n        if (strlen(buf) > 17)\n        {\n            xref->entries[i].obj_id = obj_id++;\n            xref->entries[i].offset = atol(strtok(buf, \" \"));\n            xref->entries[i].gen_num = atoi(strtok(NULL, \" \"));\n            xref->entries[i].f_or_n = buf[17];\n            ++added_entries;\n        }\n        else\n        {\n            obj_id = atoi(buf);\n            --i;\n        }\n    }\n    xref->n_entries = added_entries;\n    fseek(fp, start, SEEK_SET);\n}", "target": 1}
{"code": "static x86newTokenType getToken(const char *str, size_t *begin, size_t *end) {\n\twhile (begin && isspace ((ut8)str[*begin])) {\n\t\t++(*begin);\n\t}\n\tif (!str[*begin]) {                \n\t\t*end = *begin;\n\t\treturn TT_EOF;\n\t} else if (isalpha ((ut8)str[*begin])) {   \n\t\t*end = *begin;\n\t\twhile (end && isalnum ((ut8)str[*end])) {\n\t\t\t++(*end);\n\t\t}\n\t\treturn TT_WORD;\n\t} else if (isdigit ((ut8)str[*begin])) {   \n\t\t*end = *begin;\n\t\twhile (end && isalnum ((ut8)str[*end])) {     \n\t\t\t++(*end);\n\t\t}\n\t\treturn TT_NUMBER;\n\t} else {                             \n\t\t*end = *begin + 1;\n\t\treturn TT_SPECIAL;\n\t}\n}", "target": 1}
{"code": "void Document::FinishedParsing() {\n  DCHECK(!GetScriptableDocumentParser() || !parser_->IsParsing());\n  DCHECK(!GetScriptableDocumentParser() || ready_state_ != kLoading);\n  SetParsingState(kInDOMContentLoaded);\n  DocumentParserTiming::From(*this).MarkParserStop();\n  if (!document_timing_.DomContentLoadedEventStart())\n    document_timing_.MarkDomContentLoadedEventStart();\n  DispatchEvent(Event::CreateBubble(EventTypeNames::DOMContentLoaded));\n  if (!document_timing_.DomContentLoadedEventEnd())\n    document_timing_.MarkDomContentLoadedEventEnd();\n  SetParsingState(kFinishedParsing);\n  Microtask::PerformCheckpoint(V8PerIsolateData::MainThreadIsolate());\n  ScriptableDocumentParser* parser = GetScriptableDocumentParser();\n  well_formed_ = parser && parser->WellFormed();\n  if (LocalFrame* frame = GetFrame()) {\n    const bool main_resource_was_already_requested =\n        frame->Loader().StateMachine()->CommittedFirstRealDocumentLoad();\n    if (main_resource_was_already_requested)\n      UpdateStyleAndLayoutTree();\n    BeginLifecycleUpdatesIfRenderingReady();\n    frame->Loader().FinishedParsing();\n    TRACE_EVENT_INSTANT1(\"devtools.timeline\", \"MarkDOMContent\",\n                         TRACE_EVENT_SCOPE_THREAD, \"data\",\n                         InspectorMarkLoadEvent::Data(frame));\n    probe::domContentLoadedEventFired(frame);\n    frame->GetIdlenessDetector()->DomContentLoadedEventFired();\n  }\n  element_data_cache_clear_timer_.StartOneShot(10, BLINK_FROM_HERE);\n  fetcher_->ClearPreloads(ResourceFetcher::kClearSpeculativeMarkupPreloads);\n  if (!frame_ || frame_->GetSettings()->GetSavePreviousDocumentResources() ==\n                     SavePreviousDocumentResources::kUntilOnDOMContentLoaded) {\n    fetcher_->ClearResourcesFromPreviousFetcher();\n  }\n  if (IsPrefetchOnly())\n    WebPrerenderingSupport::Current()->PrefetchFinished();\n}", "target": 0}
{"code": "print_perm_line (int        idx,\n                 GPtrArray *items,\n                 int        cols)\n{\n  g_autoptr(GString) res = g_string_new (NULL);\n  int i;\n  g_string_append_printf (res, \"    [%d] %s\", idx, (char *) items->pdata[0]);\n  for (i = 1; i < items->len; i++)\n    {\n      char *p;\n      int len;\n      p = strrchr (res->str, '\\n');\n      if (!p)\n        p = res->str;\n      len = (res->str + strlen (res->str)) - p;\n      if (len + strlen ((char *) items->pdata[i]) + 2 >= cols)\n        g_string_append_printf (res, \",\\n        %s\", (char *) items->pdata[i]);\n      else\n        g_string_append_printf (res, \", %s\", (char *) items->pdata[i]);\n    }\n  g_print (\"%s\\n\", res->str);\n}", "target": 1}
{"code": "bool jas_image_cmpt_domains_same(jas_image_t *image)\n{\n\tint cmptno;\n\tjas_image_cmpt_t *cmpt;\n\tjas_image_cmpt_t *cmpt0;\n\tcmpt0 = image->cmpts_[0];\n\tfor (cmptno = 1; cmptno < image->numcmpts_; ++cmptno) {\n\t\tcmpt = image->cmpts_[cmptno];\n\t\tif (cmpt->tlx_ != cmpt0->tlx_ || cmpt->tly_ != cmpt0->tly_ ||\n\t\t  cmpt->hstep_ != cmpt0->hstep_ || cmpt->vstep_ != cmpt0->vstep_ ||\n\t\t  cmpt->width_ != cmpt0->width_ || cmpt->height_ != cmpt0->height_) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "ext4_xattr_cache_find(struct inode *inode, struct ext4_xattr_header *header,\n\t\t      struct mb_cache_entry **pce)\n{\n\t__u32 hash = le32_to_cpu(header->h_hash);\n\tstruct mb_cache_entry *ce;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\tif (!header->h_hash)\n\t\treturn NULL;  \n\tea_idebug(inode, \"looking for cached blocks [%x]\", (int)hash);\nagain:\n\tce = mb_cache_entry_find_first(ext4_mb_cache, inode->i_sb->s_bdev,\n\t\t\t\t       hash);\n\twhile (ce) {\n\t\tstruct buffer_head *bh;\n\t\tif (IS_ERR(ce)) {\n\t\t\tif (PTR_ERR(ce) == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tbreak;\n\t\t}\n\t\tbh = sb_bread(inode->i_sb, ce->e_block);\n\t\tif (!bh) {\n\t\t\tEXT4_ERROR_INODE(inode, \"block %lu read error\",\n\t\t\t\t\t (unsigned long) ce->e_block);\n\t\t} else if (le32_to_cpu(BHDR(bh)->h_refcount) >=\n\t\t\t\tEXT4_XATTR_REFCOUNT_MAX) {\n\t\t\tea_idebug(inode, \"block %lu refcount %d>=%d\",\n\t\t\t\t  (unsigned long) ce->e_block,\n\t\t\t\t  le32_to_cpu(BHDR(bh)->h_refcount),\n\t\t\t\t\t  EXT4_XATTR_REFCOUNT_MAX);\n\t\t} else if (ext4_xattr_cmp(header, BHDR(bh)) == 0) {\n\t\t\t*pce = ce;\n\t\t\treturn bh;\n\t\t}\n\t\tbrelse(bh);\n\t\tce = mb_cache_entry_find_next(ce, inode->i_sb->s_bdev, hash);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "ExprCreateFloat(void)\n{\n    EXPR_CREATE(ExprFloat, expr, EXPR_VALUE, EXPR_TYPE_FLOAT);\n    return expr;\n}", "target": 0}
{"code": "static void unix_release_sock(struct sock *sk, int embrion)\n{\n\tstruct unix_sock *u = unix_sk(sk);\n\tstruct path path;\n\tstruct sock *skpair;\n\tstruct sk_buff *skb;\n\tint state;\n\tunix_remove_socket(sk);\n\tunix_state_lock(sk);\n\tsock_orphan(sk);\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\tpath\t     = u->path;\n\tu->path.dentry = NULL;\n\tu->path.mnt = NULL;\n\tstate = sk->sk_state;\n\tsk->sk_state = TCP_CLOSE;\n\tunix_state_unlock(sk);\n\twake_up_interruptible_all(&u->peer_wait);\n\tskpair = unix_peer(sk);\n\tif (skpair != NULL) {\n\t\tif (sk->sk_type == SOCK_STREAM || sk->sk_type == SOCK_SEQPACKET) {\n\t\t\tunix_state_lock(skpair);\n\t\t\tskpair->sk_shutdown = SHUTDOWN_MASK;\n\t\t\tif (!skb_queue_empty(&sk->sk_receive_queue) || embrion)\n\t\t\t\tskpair->sk_err = ECONNRESET;\n\t\t\tunix_state_unlock(skpair);\n\t\t\tskpair->sk_state_change(skpair);\n\t\t\tsk_wake_async(skpair, SOCK_WAKE_WAITD, POLL_HUP);\n\t\t}\n\t\tunix_dgram_peer_wake_disconnect(sk, skpair);\n\t\tsock_put(skpair); \n\t\tunix_peer(sk) = NULL;\n\t}\n\twhile ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {\n\t\tif (state == TCP_LISTEN)\n\t\t\tunix_release_sock(skb->sk, 1);\n\t\tUNIXCB(skb).consumed = skb->len;\n\t\tkfree_skb(skb);\n\t}\n\tif (path.dentry)\n\t\tpath_put(&path);\n\tsock_put(sk);\n\tif (unix_tot_inflight)\n\t\tunix_gc();\t\t\n}", "target": 0}
{"code": "static int adpt_bus_reset(struct scsi_cmnd* cmd)\n{\n\tadpt_hba* pHba;\n\tu32 msg[4];\n\tu32 rcode;\n\tpHba = (adpt_hba*)cmd->device->host->hostdata[0];\n\tmemset(msg, 0, sizeof(msg));\n\tprintk(KERN_WARNING\"%s: Bus reset: SCSI Bus %d: tid: %d\\n\",pHba->name, cmd->device->channel,pHba->channel[cmd->device->channel].tid );\n\tmsg[0] = FOUR_WORD_MSG_SIZE|SGL_OFFSET_0;\n\tmsg[1] = (I2O_HBA_BUS_RESET<<24|HOST_TID<<12|pHba->channel[cmd->device->channel].tid);\n\tmsg[2] = 0;\n\tmsg[3] = 0;\n\tif (pHba->host)\n\t\tspin_lock_irq(pHba->host->host_lock);\n\trcode = adpt_i2o_post_wait(pHba, msg,sizeof(msg), FOREVER);\n\tif (pHba->host)\n\t\tspin_unlock_irq(pHba->host->host_lock);\n\tif (rcode != 0) {\n\t\tprintk(KERN_WARNING\"%s: Bus reset failed.\\n\",pHba->name);\n\t\treturn FAILED;\n\t} else {\n\t\tprintk(KERN_WARNING\"%s: Bus reset success.\\n\",pHba->name);\n\t\treturn SUCCESS;\n\t}\n}", "target": 1}
{"code": "void AuthenticationFeature::collectOptions(std::shared_ptr<ProgramOptions> options) {\n  options->addOldOption(\"server.disable-authentication\",\n                        \"server.authentication\");\n  options->addOldOption(\"server.disable-authentication-unix-sockets\",\n                        \"server.authentication-unix-sockets\");\n  options->addOldOption(\"server.authenticate-system-only\",\n                        \"server.authentication-system-only\");\n  options->addOldOption(\"server.allow-method-override\",\n                        \"http.allow-method-override\");\n  options->addOldOption(\"server.hide-product-header\",\n                        \"http.hide-product-header\");\n  options->addOldOption(\"server.keep-alive-timeout\", \"http.keep-alive-timeout\");\n  options->addOldOption(\"server.default-api-compatibility\", \"\");\n  options->addOldOption(\"no-server\", \"server.rest-server\");\n  options->addOption(\"--server.authentication\",\n                     \"enable authentication for ALL client requests\",\n                     new BooleanParameter(&_active));\n  options->addOption(\n      \"--server.authentication-timeout\",\n      \"timeout for the authentication cache in seconds (0 = indefinitely)\",\n      new DoubleParameter(&_authenticationTimeout));\n  options->addOption(\"--server.local-authentication\",\n                     \"enable authentication using the local user database\",\n                     new BooleanParameter(&_localAuthentication));\n  options->addOption(\n      \"--server.authentication-system-only\",\n      \"use HTTP authentication only for requests to /_api and /_admin\",\n      new BooleanParameter(&_authenticationSystemOnly));\n#ifdef ARANGODB_HAVE_DOMAIN_SOCKETS\n  options->addOption(\"--server.authentication-unix-sockets\",\n                     \"authentication for requests via UNIX domain sockets\",\n                     new BooleanParameter(&_authenticationUnixSockets));\n#endif\n  options\n      ->addOption(\"--server.jwt-secret\",\n                  \"secret to use when doing jwt authentication\",\n                  new StringParameter(&_jwtSecretProgramOption))\n      .setDeprecatedIn(30322)\n      .setDeprecatedIn(30402);\n  options->addOption(\n      \"--server.jwt-secret-keyfile\",\n      \"file containing jwt secret to use when doing jwt authentication.\",\n      new StringParameter(&_jwtSecretKeyfileProgramOption));\n  options->addOption(\n      \"--server.jwt-secret-folder\",\n      \"folder containing one or more jwt secret files to use for jwt \"\n      \"authentication. Files are sorted alphabetically: First secret \"\n      \"is used for signing + verifying JWT tokens. The latter secrets \"\n      \"are only used for verifying.\",\n      new StringParameter(&_jwtSecretFolderProgramOption),\n      arangodb::options::makeDefaultFlags(arangodb::options::Flags::Enterprise))\n      .setIntroducedIn(30700);\n}", "target": 1}
{"code": "int http_parse_cont_len_header(struct ist *value, unsigned long long *body_len,\n                               int not_first)\n{\n\tchar *e, *n;\n\tunsigned long long cl;\n\tstruct ist word;\n\tint check_prev = not_first;\n\tword.ptr = value->ptr - 1; \n\te = value->ptr + value->len;\n\twhile (++word.ptr < e) {\n\t\tif (unlikely(HTTP_IS_LWS(*word.ptr)))\n\t\t\tcontinue;\n\t\tfor (cl = 0, n = word.ptr; n < e; n++) {\n\t\t\tunsigned int c = *n - '0';\n\t\t\tif (unlikely(c > 9)) {\n\t\t\t\tif (unlikely(n == word.ptr)) \n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(cl > ULLONG_MAX / 10ULL))\n\t\t\t\tgoto fail; \n\t\t\tcl = cl * 10ULL;\n\t\t\tif (unlikely(cl + c < cl))\n\t\t\t\tgoto fail; \n\t\t\tcl = cl + c;\n\t\t}\n\t\tword.len = n - word.ptr;\n\t\tfor (; n < e; n++) {\n\t\t\tif (!HTTP_IS_LWS(*n)) {\n\t\t\t\tif (unlikely(*n != ','))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (check_prev && cl != *body_len)\n\t\t\tgoto fail;\n\t\t*body_len = cl;\n\t\t*value = word;\n\t\tword.ptr = n;\n\t\tcheck_prev = 1;\n\t}\n\treturn !not_first;\n fail:\n\treturn -1;\n}", "target": 1}
{"code": "static void csi_K(struct vc_data *vc, int vpar)\n{\n\tunsigned int count;\n\tunsigned short *start = (unsigned short *)vc->vc_pos;\n\tint offset;\n\tswitch (vpar) {\n\t\tcase 0:\t\n\t\t\toffset = 0;\n\t\t\tcount = vc->vc_cols - vc->vc_x;\n\t\t\tbreak;\n\t\tcase 1:\t\n\t\t\toffset = -vc->vc_x;\n\t\t\tcount = vc->vc_x + 1;\n\t\t\tbreak;\n\t\tcase 2: \n\t\t\toffset = -vc->vc_x;\n\t\t\tcount = vc->vc_cols;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t}\n\tvc_uniscr_clear_line(vc, vc->vc_x + offset, count);\n\tscr_memsetw(start + offset, vc->vc_video_erase_char, 2 * count);\n\tvc->vc_need_wrap = 0;\n\tif (con_should_update(vc))\n\t\tdo_update_region(vc, (unsigned long)(start + offset), count);\n}", "target": 0}
{"code": "static void read_module(RBuffer *b, ut64 addr, struct minidump_module *module) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tr_buf_seek (b, addr, R_BUF_SET);\n\tmodule->base_of_image = r_buf_read_le64 (b);\n\tmodule->size_of_image = r_buf_read_le32 (b);\n\tmodule->check_sum = r_buf_read_le32 (b);\n\tmodule->time_date_stamp = r_buf_read_le32 (b);\n\tmodule->module_name_rva = r_buf_read_le32 (b);\n\tmodule->version_info.dw_signature = r_buf_read_le32 (b);\n\tmodule->version_info.dw_struc_version = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_version_ms = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_version_ls = r_buf_read_le32 (b);\n\tmodule->version_info.dw_product_version_ms = r_buf_read_le32 (b);\n\tmodule->version_info.dw_product_version_ls = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_flags_mask = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_flags = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_os = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_type = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_subtype = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_date_ms = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_date_ls = r_buf_read_le32 (b);\n\tmodule->cv_record.data_size = r_buf_read_le32 (b);\n\tmodule->cv_record.rva = r_buf_read_le32 (b);\n\tmodule->misc_record.data_size = r_buf_read_le32 (b);\n\tmodule->misc_record.rva = r_buf_read_le32 (b);\n\tmodule->reserved_0 = r_buf_read_le64 (b);\n\tmodule->reserved_1 = r_buf_read_le64 (b);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n}", "target": 1}
{"code": "FILE *fopen_safe(const char *path, const char *mode)\n{\n\tint fd;\n\tFILE *file;\n\tint flags = O_NOFOLLOW | O_CREAT;\n\tif (mode[0] == 'r')\n\t\treturn fopen(path, mode);\n\tif (mode[0] != 'a' && mode[0] != 'w')\n\t\treturn NULL;\n\tif (mode[1] &&\n\t    (mode[1] != '+' || mode[2]))\n\t\treturn NULL;\n\tif (mode[0] == 'w')\n\t\tflags |= O_TRUNC;\n\telse\n\t\tflags |= O_APPEND;\n\tif (mode[1])\n\t\tflags |= O_RDWR;\n\telse\n\t\tflags |= O_WRONLY;\n\tfd = open(path, flags, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n\tif (fd == -1)\n\t\treturn NULL;\n\tfile = fdopen (fd, \"w\");\n\tif (!file) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\treturn file;\n}", "target": 0}
{"code": "int ff_amf_get_field_value(const uint8_t *data, const uint8_t *data_end,\n                           const uint8_t *name, uint8_t *dst, int dst_size)\n{\n    int namelen = strlen(name);\n    int len;\n    while (*data != AMF_DATA_TYPE_OBJECT && data < data_end) {\n        len = ff_amf_tag_size(data, data_end);\n        if (len < 0)\n            len = data_end - data;\n        data += len;\n    }\n    if (data_end - data < 3)\n        return -1;\n    data++;\n    for (;;) {\n        int size = bytestream_get_be16(&data);\n        if (!size)\n            break;\n        if (size < 0 || size >= data_end - data)\n            return -1;\n        data += size;\n        if (size == namelen && !memcmp(data-size, name, namelen)) {\n            switch (*data++) {\n            case AMF_DATA_TYPE_NUMBER:\n                snprintf(dst, dst_size, \"%g\", av_int2double(AV_RB64(data)));\n                break;\n            case AMF_DATA_TYPE_BOOL:\n                snprintf(dst, dst_size, \"%s\", *data ? \"true\" : \"false\");\n                break;\n            case AMF_DATA_TYPE_STRING:\n                len = bytestream_get_be16(&data);\n                av_strlcpy(dst, data, FFMIN(len+1, dst_size));\n                break;\n            default:\n                return -1;\n            }\n            return 0;\n        }\n        len = ff_amf_tag_size(data, data_end);\n        if (len < 0 || len >= data_end - data)\n            return -1;\n        data += len;\n    }\n    return -1;\n}", "target": 1}
{"code": "BigInt EC_Group::multiply_mod_order(const BigInt& x, const BigInt& y, const BigInt& z) const\n   {\n   return data().multiply_mod_order(x, y, z);\n   }", "target": 0}
{"code": "static int __verify_planes_array_core(struct vb2_buffer *vb, const void *pb)\n{\n\treturn __verify_planes_array(vb, pb);\n}", "target": 0}
{"code": "int pdf_load_xrefs(FILE *fp, pdf_t *pdf)\n{\n    int  i, ver, is_linear;\n    long pos, pos_count;\n    char x, *c, buf[256];\n    c = NULL;\n    pdf->n_xrefs = 0;\n    fseek(fp, 0, SEEK_SET);\n    while (get_next_eof(fp) >= 0)\n      ++pdf->n_xrefs;\n    if (!pdf->n_xrefs)\n      return 0;\n    fseek(fp, 0, SEEK_SET);\n    pdf->xrefs = calloc(1, sizeof(xref_t) * pdf->n_xrefs);\n    ver = 1;\n    for (i=0; i<pdf->n_xrefs; i++)\n    {\n        if ((pos = get_next_eof(fp)) < 0)\n          break;\n        pdf->xrefs[i].version = ver++;\n        pos_count = 0;\n        while (SAFE_F(fp, ((x = fgetc(fp)) != 'f')))\n          fseek(fp, pos - (++pos_count), SEEK_SET);\n        if (pos_count >= sizeof(buf)) {\n          ERR(\"Failed to locate the startxref token. \"\n              \"This might be a corrupt PDF.\\n\");\n          return -1;\n        }\n        memset(buf, 0, sizeof(buf));\n        SAFE_E(fread(buf, 1, pos_count, fp), pos_count,\n               \"Failed to read startxref.\\n\");\n        c = buf;\n        while (*c == ' ' || *c == '\\n' || *c == '\\r')\n          ++c;\n        pdf->xrefs[i].start = atol(c);\n        if (pdf->xrefs[i].start == 0)\n          get_xref_linear_skipped(fp, &pdf->xrefs[i]);\n        else\n        {\n            pos = ftell(fp);\n            fseek(fp, pdf->xrefs[i].start, SEEK_SET);\n            pdf->xrefs[i].end = get_next_eof(fp);\n            fseek(fp, pos, SEEK_SET);\n        }\n        if (!is_valid_xref(fp, pdf, &pdf->xrefs[i]))\n        {\n            is_linear = pdf->xrefs[i].is_linear;\n            memset(&pdf->xrefs[i], 0, sizeof(xref_t));\n            pdf->xrefs[i].is_linear = is_linear;\n            rewind(fp);\n            get_next_eof(fp);\n            continue;\n        }\n        load_xref_entries(fp, &pdf->xrefs[i]);\n    }\n    if (pdf->xrefs[0].is_linear)\n      resolve_linearized_pdf(pdf);\n    load_creator(fp, pdf);\n    return pdf->n_xrefs;\n}", "target": 1}
{"code": "bool MainWindow::serverArgs(QStringList& args, QString& app)\n{\n    app = appPath(appConfig().barriersName());\n    if (!QFile::exists(app))\n    {\n        QMessageBox::warning(this, tr(\"Barrier server not found\"),\n                             tr(\"The executable for the barrier server does not exist.\"));\n        return false;\n    }\n#if defined(Q_OS_WIN)\n    app = QString(\"\\\"%1\\\"\").arg(app);\n#endif\n    if (appConfig().logToFile())\n    {\n        appConfig().persistLogDir();\n        args << \"--log\" << appConfig().logFilenameCmd();\n    }\n    if (!appConfig().getRequireClientCertificate()) {\n        args << \"--disable-client-cert-checking\";\n    }\n    QString configFilename = this->configFilename();\n#if defined(Q_OS_WIN)\n    configFilename = QString(\"\\\"%1\\\"\").arg(configFilename);\n#endif\n    args << \"-c\" << configFilename << \"--address\" << address();\n    return true;\n}", "target": 0}
{"code": "int do_remount_sb(struct super_block *sb, int flags, void *data, int force)\n{\n\tint retval;\n\tint remount_ro;\n\tif (sb->s_writers.frozen != SB_UNFROZEN)\n\t\treturn -EBUSY;\n#ifdef CONFIG_BLOCK\n\tif (!(flags & MS_RDONLY) && bdev_read_only(sb->s_bdev))\n\t\treturn -EACCES;\n#endif\n\tif (flags & MS_RDONLY)\n\t\tacct_auto_close(sb);\n\tshrink_dcache_sb(sb);\n\tsync_filesystem(sb);\n\tremount_ro = (flags & MS_RDONLY) && !(sb->s_flags & MS_RDONLY);\n\tif (remount_ro) {\n\t\tif (force) {\n\t\t\tmark_files_ro(sb);\n\t\t} else {\n\t\t\tretval = sb_prepare_remount_readonly(sb);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t}\n\tif (sb->s_op->remount_fs) {\n\t\tretval = sb->s_op->remount_fs(sb, &flags, data);\n\t\tif (retval) {\n\t\t\tif (!force)\n\t\t\t\tgoto cancel_readonly;\n\t\t\tWARN(1, \"forced remount of a %s fs returned %i\\n\",\n\t\t\t     sb->s_type->name, retval);\n\t\t}\n\t}\n\tsb->s_flags = (sb->s_flags & ~MS_RMT_MASK) | (flags & MS_RMT_MASK);\n\tsmp_wmb();\n\tsb->s_readonly_remount = 0;\n\tif (remount_ro && sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\n\treturn 0;\ncancel_readonly:\n\tsb->s_readonly_remount = 0;\n\treturn retval;\n}", "target": 1}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_constant_value_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 6;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_CONST_VALUE_ATTR;\n\t\tattr->info.constant_value_attr.constantvalue_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}", "target": 1}
{"code": "void PixelBuffer::setSize(int width, int height)\n{\n  if ((width < 0) || (width > maxPixelBufferWidth))\n    throw rfb::Exception(\"Invalid PixelBuffer width of %d pixels requested\", width);\n  if ((height < 0) || (height > maxPixelBufferHeight))\n    throw rfb::Exception(\"Invalid PixelBuffer height of %d pixels requested\", height);\n  width_ = width;\n  height_ = height;\n}", "target": 0}
{"code": "static int ndp_sock_recv(struct ndp *ndp)\n{\n\tstruct ndp_msg *msg;\n\tenum ndp_msg_type msg_type;\n\tsize_t len;\n\tint err;\n\tmsg = ndp_msg_alloc();\n\tif (!msg)\n\t\treturn -ENOMEM;\n\tlen = ndp_msg_payload_maxlen(msg);\n\terr = myrecvfrom6(ndp->sock, msg->buf, &len, 0,\n\t\t\t  &msg->addrto, &msg->ifindex);\n\tif (err) {\n\t\terr(ndp, \"Failed to receive message\");\n\t\tgoto free_msg;\n\t}\n\tdbg(ndp, \"rcvd from: %s, ifindex: %u\",\n\t\t str_in6_addr(&msg->addrto), msg->ifindex);\n\tif (len < sizeof(*msg->icmp6_hdr)) {\n\t\twarn(ndp, \"rcvd icmp6 packet too short (%luB)\", len);\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\terr = ndp_msg_type_by_raw_type(&msg_type, msg->icmp6_hdr->icmp6_type);\n\tif (err) {\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\tndp_msg_init(msg, msg_type);\n\tndp_msg_payload_len_set(msg, len);\n\tif (!ndp_msg_check_valid(msg)) {\n\t\twarn(ndp, \"rcvd invalid ND message\");\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\tdbg(ndp, \"rcvd %s, len: %zuB\",\n\t\t ndp_msg_type_info(msg_type)->strabbr, len);\n\tif (!ndp_msg_check_opts(msg)) {\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\terr = ndp_call_handlers(ndp, msg);;\nfree_msg:\n\tndp_msg_destroy(msg);\n\treturn err;\n}", "target": 1}
{"code": "d_lite_s_alloc_simple(VALUE klass)\n{\n    return d_simple_new_internal(klass,\n\t\t\t\t INT2FIX(0), 0,\n\t\t\t\t DEFAULT_SG,\n\t\t\t\t 0, 0, 0,\n\t\t\t\t HAVE_JD);\n}", "target": 0}
{"code": "static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,\n\t\t\t\t   size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\tint ret = 0;\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\tif (tmp >= O2NM_MAX_NODES)\n\t\treturn -ERANGE;\n\tif (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n\t\treturn -EINVAL; \n\twrite_lock(&cluster->cl_nodes_lock);\n\tif (cluster->cl_nodes[tmp])\n\t\tret = -EEXIST;\n\telse if (test_and_set_bit(O2NM_NODE_ATTR_NUM,\n\t\t\t&node->nd_set_attributes))\n\t\tret = -EBUSY;\n\telse  {\n\t\tcluster->cl_nodes[tmp] = node;\n\t\tnode->nd_num = tmp;\n\t\tset_bit(tmp, cluster->cl_nodes_bitmap);\n\t}\n\twrite_unlock(&cluster->cl_nodes_lock);\n\tif (ret)\n\t\treturn ret;\n\treturn count;\n}", "target": 1}
{"code": "heap_available()\n{\n    long avail = 0;\n    void *probes[max_malloc_probes];\n    uint n;\n    for (n = 0; n < max_malloc_probes; n++) {\n        if ((probes[n] = malloc(malloc_probe_size)) == 0)\n            break;\n        if_debug2('a', \"[a]heap_available probe[%d]=0x%lx\\n\",\n                  n, (ulong) probes[n]);\n        avail += malloc_probe_size;\n    }\n    while (n)\n        free(probes[--n]);\n    return avail;\n}", "target": 0}
{"code": "static int crypto_nivaead_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_aead raead;\n\tstruct aead_alg *aead = &alg->cra_aead;\n\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"nivaead\");\n\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \"%s\", aead->geniv);\n\traead.blocksize = alg->cra_blocksize;\n\traead.maxauthsize = aead->maxauthsize;\n\traead.ivsize = aead->ivsize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_AEAD,\n\t\t    sizeof(struct crypto_report_aead), &raead))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "int main()\n{\n    check_file(\"tiff_invalid_read_1.tiff\");\n    check_file(\"tiff_invalid_read_2.tiff\");\n    check_file(\"tiff_invalid_read_3.tiff\");\n    return gdNumFailures();\n}", "target": 0}
{"code": "  explicit SparseCrossOp(OpKernelConstruction* context) : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_buckets\", &num_buckets_));\n    int64 signed_hash_key_;\n    OP_REQUIRES_OK(context, context->GetAttr(\"hash_key\", &signed_hash_key_));\n    hash_key_ = static_cast<uint64>(signed_hash_key_);\n    OP_REQUIRES_OK(context, context->GetAttr(\"internal_type\", &internal_type_));\n  }", "target": 0}
{"code": "static int netbk_count_requests(struct xenvif *vif,\n\t\t\t\tstruct xen_netif_tx_request *first,\n\t\t\t\tstruct xen_netif_tx_request *txp,\n\t\t\t\tint work_to_do)\n{\n\tRING_IDX cons = vif->tx.req_cons;\n\tint frags = 0;\n\tif (!(first->flags & XEN_NETTXF_more_data))\n\t\treturn 0;\n\tdo {\n\t\tif (frags >= work_to_do) {\n\t\t\tnetdev_dbg(vif->dev, \"Need more frags\\n\");\n\t\t\treturn -frags;\n\t\t}\n\t\tif (unlikely(frags >= MAX_SKB_FRAGS)) {\n\t\t\tnetdev_dbg(vif->dev, \"Too many frags\\n\");\n\t\t\treturn -frags;\n\t\t}\n\t\tmemcpy(txp, RING_GET_REQUEST(&vif->tx, cons + frags),\n\t\t       sizeof(*txp));\n\t\tif (txp->size > first->size) {\n\t\t\tnetdev_dbg(vif->dev, \"Frags galore\\n\");\n\t\t\treturn -frags;\n\t\t}\n\t\tfirst->size -= txp->size;\n\t\tfrags++;\n\t\tif (unlikely((txp->offset + txp->size) > PAGE_SIZE)) {\n\t\t\tnetdev_dbg(vif->dev, \"txp->offset: %x, size: %u\\n\",\n\t\t\t\t txp->offset, txp->size);\n\t\t\treturn -frags;\n\t\t}\n\t} while ((txp++)->flags & XEN_NETTXF_more_data);\n\treturn frags;\n}", "target": 1}
{"code": "resolve_op_from_commit (FlatpakTransaction *self,\n                        FlatpakTransactionOperation *op,\n                        const char *checksum,\n                        GFile *sideload_path,\n                        GVariant *commit_data,\n                        GError **error)\n{\n  g_autoptr(GBytes) metadata_bytes = NULL;\n  g_autoptr(GVariant) commit_metadata = NULL;\n  const char *xa_metadata = NULL;\n  guint64 download_size = 0;\n  guint64 installed_size = 0;\n  commit_metadata = g_variant_get_child_value (commit_data, 0);\n  g_variant_lookup (commit_metadata, \"xa.metadata\", \"&s\", &xa_metadata);\n  if (xa_metadata == NULL)\n    return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA,\n                               \"No xa.metadata in local commit %s ref %s\",\n                               checksum, flatpak_decomposed_get_ref (op->ref));\n  metadata_bytes = g_bytes_new (xa_metadata, strlen (xa_metadata));\n  if (g_variant_lookup (commit_metadata, \"xa.download-size\", \"t\", &download_size))\n    op->download_size = GUINT64_FROM_BE (download_size);\n  if (g_variant_lookup (commit_metadata, \"xa.installed-size\", \"t\", &installed_size))\n    op->installed_size = GUINT64_FROM_BE (installed_size);\n  g_variant_lookup (commit_metadata, OSTREE_COMMIT_META_KEY_ENDOFLIFE, \"s\", &op->eol);\n  g_variant_lookup (commit_metadata, OSTREE_COMMIT_META_KEY_ENDOFLIFE_REBASE, \"s\", &op->eol_rebase);\n  return resolve_op_end (self, op, checksum, sideload_path, metadata_bytes, error);\n}", "target": 0}
{"code": "static inline void o2nm_unlock_subsystem(void)\n{\n\tmutex_unlock(&o2nm_cluster_group.cs_subsys.su_mutex);\n}", "target": 0}
{"code": "   int64 usage() const { return usage_; }", "target": 0}
{"code": "avp_find(struct l2tp_avp *avp, const u_char *pkt, int pktlen,\n    uint16_t vendor_id, uint16_t attr_type, int fill_data)\n{\n\tint avpsz;\n\twhile (pktlen >= 6 &&\n\t    (avpsz = avp_enum(avp, pkt, pktlen, fill_data)) > 0) {\n\t\tif (avp->vendor_id != vendor_id || avp->attr_type != attr_type) {\n\t\t\tif (avpsz < 6)\n\t\t\t\treturn NULL;\n\t\t\tpkt += avpsz;\n\t\t\tpktlen -= avpsz;\n\t\t\tcontinue;\n\t\t}\n\t\treturn avp;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "soup_server_new (const char *optname1, ...)\n{\n\tSoupServer *server;\n\tva_list ap;\n\tva_start (ap, optname1);\n\tserver = (SoupServer *)g_object_new_valist (SOUP_TYPE_SERVER,\n\t\t\t\t\t\t    optname1, ap);\n\tva_end (ap);\n\treturn server;\n}", "target": 0}
{"code": "static int kvm_ioctl_create_device(struct kvm *kvm,\n\t\t\t\t   struct kvm_create_device *cd)\n{\n\tstruct kvm_device_ops *ops = NULL;\n\tstruct kvm_device *dev;\n\tbool test = cd->flags & KVM_CREATE_DEVICE_TEST;\n\tint ret;\n\tif (cd->type >= ARRAY_SIZE(kvm_device_ops_table))\n\t\treturn -ENODEV;\n\tops = kvm_device_ops_table[cd->type];\n\tif (ops == NULL)\n\t\treturn -ENODEV;\n\tif (test)\n\t\treturn 0;\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tdev->ops = ops;\n\tdev->kvm = kvm;\n\tmutex_lock(&kvm->lock);\n\tret = ops->create(dev, cd->type);\n\tif (ret < 0) {\n\t\tmutex_unlock(&kvm->lock);\n\t\tkfree(dev);\n\t\treturn ret;\n\t}\n\tlist_add(&dev->vm_node, &kvm->devices);\n\tmutex_unlock(&kvm->lock);\n\tif (ops->init)\n\t\tops->init(dev);\n\tret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);\n\tif (ret < 0) {\n\t\tops->destroy(dev);\n\t\tmutex_lock(&kvm->lock);\n\t\tlist_del(&dev->vm_node);\n\t\tmutex_unlock(&kvm->lock);\n\t\treturn ret;\n\t}\n\tkvm_get_kvm(kvm);\n\tcd->fd = ret;\n\treturn 0;\n}", "target": 1}
{"code": "static void add_bytes_c(uint8_t *dst, uint8_t *src, int w){\n    long i;\n    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){\n        long a = *(long*)(src+i);\n        long b = *(long*)(dst+i);\n        *(long*)(dst+i) = ((a&pb_7f) + (b&pb_7f)) ^ ((a^b)&pb_80);\n    }\n    for(; i<w; i++)\n        dst[i+0] += src[i+0];\n}", "target": 1}
{"code": "static int elo_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct elo_priv *priv;\n\tint ret;\n\tstruct usb_device *udev;\n\tif (!hid_is_usb(hdev))\n\t\treturn -EINVAL;\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tINIT_DELAYED_WORK(&priv->work, elo_work);\n\tudev = interface_to_usbdev(to_usb_interface(hdev->dev.parent));\n\tpriv->usbdev = usb_get_dev(udev);\n\thid_set_drvdata(hdev, priv);\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto err_free;\n\t}\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto err_free;\n\t}\n\tif (elo_broken_firmware(priv->usbdev)) {\n\t\thid_info(hdev, \"broken firmware found, installing workaround\\n\");\n\t\tqueue_delayed_work(wq, &priv->work, ELO_PERIODIC_READ_INTERVAL);\n\t}\n\treturn 0;\nerr_free:\n\tusb_put_dev(udev);\n\tkfree(priv);\n\treturn ret;\n}", "target": 0}
{"code": "void *bson_realloc( void *ptr, int size ) {\n    void *p;\n    p = bson_realloc_func( ptr, size );\n    bson_fatal_msg( !!p, \"realloc() failed\" );\n    return p;\n}", "target": 1}
{"code": "static int scanbraces(const char* in) {\n    if (strncmp(in, \"{\\\\an\", 4) != 0) {\n        return 0;\n    }\n    if (!isdigit(in[4])) {\n        return 0;\n    }\n    if (in[5] != '}') {\n        return 0;\n    }\n    return 1;\n}", "target": 0}
{"code": "PackLinuxElf32::elf_find_dynamic(unsigned int key) const\n{\n    Elf32_Dyn const *dynp= dynseg;\n    if (dynp)\n    for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg\n            && Elf32_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te32(&dynp->d_tag)==key) {\n        unsigned const t= elf_get_offset_from_address(get_te32(&dynp->d_val));\n        if (t) {\n            return t + file_image;\n        }\n        break;\n    }\n    return 0;\n}", "target": 1}
{"code": "unsigned Cache::deadCapacity() const \n{\n    unsigned capacity = m_capacity - min(m_liveSize, m_capacity); \n    capacity = max(capacity, m_minDeadCapacity); \n    capacity = min(capacity, m_maxDeadCapacity); \n    return capacity;\n}", "target": 0}
{"code": "asmlinkage long sys_oabi_semtimedop(int semid,\n\t\t\t\t    struct oabi_sembuf __user *tsops,\n\t\t\t\t    unsigned nsops,\n\t\t\t\t    const struct timespec __user *timeout)\n{\n\tstruct sembuf *sops;\n\tstruct timespec local_timeout;\n\tlong err;\n\tint i;\n\tif (nsops < 1)\n\t\treturn -EINVAL;\n\tsops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);\n\tif (!sops)\n\t\treturn -ENOMEM;\n\terr = 0;\n\tfor (i = 0; i < nsops; i++) {\n\t\t__get_user_error(sops[i].sem_num, &tsops->sem_num, err);\n\t\t__get_user_error(sops[i].sem_op,  &tsops->sem_op,  err);\n\t\t__get_user_error(sops[i].sem_flg, &tsops->sem_flg, err);\n\t\ttsops++;\n\t}\n\tif (timeout) {\n\t\terr |= copy_from_user(&local_timeout, timeout, sizeof(*timeout));\n\t\ttimeout = &local_timeout;\n\t}\n\tif (err) {\n\t\terr = -EFAULT;\n\t} else {\n\t\tmm_segment_t fs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t\terr = sys_semtimedop(semid, sops, nsops, timeout);\n\t\tset_fs(fs);\n\t}\n\tkfree(sops);\n\treturn err;\n}", "target": 1}
{"code": "bool DNP3_Base::AddToBuffer(Endpoint* endp, int target_len, const u_char** data, int* len)\n\t{\n\tif ( ! target_len )\n\t\treturn true;\n\tint to_copy = min(*len, target_len - endp->buffer_len);\n\tmemcpy(endp->buffer + endp->buffer_len, *data, to_copy);\n\t*data += to_copy;\n\t*len -= to_copy;\n\tendp->buffer_len += to_copy;\n\treturn endp->buffer_len == target_len;\n\t}", "target": 1}
{"code": "ModuleExport size_t RegisterXWDImage(void)\n{\n  MagickInfo\n    *entry;\n  entry=AcquireMagickInfo(\"XWD\",\"XWD\",\"X Windows system window dump (color)\");\n#if defined(MAGICKCORE_X11_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadXWDImage;\n  entry->encoder=(EncodeImageHandler *) WriteXWDImage;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsXWD;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}", "target": 0}
{"code": "void CLua::init_libraries()\n{\n    lua_stack_cleaner clean(state());\n    lua_pushcfunction(_state, lua_loadstring);\n    lua_setglobal(_state, \"loadstring\");\n    lua_pushnil(_state);\n    lua_setglobal(_state, \"load\");\n    cluaopen_kills(_state);\n    cluaopen_you(_state);\n    cluaopen_item(_state);\n    cluaopen_food(_state);\n    cluaopen_crawl(_state);\n    cluaopen_file(_state);\n    cluaopen_moninf(_state);\n    cluaopen_options(_state);\n    cluaopen_travel(_state);\n    cluaopen_view(_state);\n    cluaopen_spells(_state);\n    cluaopen_globals(_state);\n    execfile(\"dlua/macro.lua\", true, true);\n    execstring(\"chk_startgame = { }\", \"base\");\n    lua_register(_state, \"loadfile\", _clua_loadfile);\n    lua_register(_state, \"dofile\", _clua_dofile);\n    lua_register(_state, \"crawl_require\", _clua_require);\n    execfile(\"dlua/util.lua\", true, true);\n    execfile(\"dlua/iter.lua\", true, true);\n    execfile(\"dlua/tags.lua\", true, true);\n    execfile(\"dlua/init.lua\", true, true);\n    if (managed_vm)\n    {\n        lua_register(_state, \"pcall\", _clua_guarded_pcall);\n        execfile(\"dlua/userbase.lua\", true, true);\n        execfile(\"dlua/persist.lua\", true, true);\n    }\n}", "target": 0}
{"code": "static bool range_within(struct bpf_reg_state *old,\n\t\t\t struct bpf_reg_state *cur)\n{\n\treturn old->umin_value <= cur->umin_value &&\n\t       old->umax_value >= cur->umax_value &&\n\t       old->smin_value <= cur->smin_value &&\n\t       old->smax_value >= cur->smax_value;\n}", "target": 0}
{"code": "deallocateCharacterClasses ()\n{\n  while (characterClasses)\n    {\n      struct CharacterClass *class = characterClasses;\n      characterClasses = characterClasses->next;\n      if (class)\n\tfree (class);\n    }\n}", "target": 0}
{"code": "char *ReadInput(char *filename)\n{\n    FILE *finput;\n    long filesize, num;\n    char *buffer;\n    if ( ( finput = fopen(filename,\"r\") ) == 0 ) {\n        fprintf(stderr,\"%s: Cannot open file %s\\n\",axohelp,filename);\n        exit(-1);\n    }\n    if ( ( fseek(finput,0,SEEK_END) != 0 )\n      || ( ( filesize = ftell(finput) ) < 0 )\n      || ( fseek(finput,0,SEEK_SET) != 0 ) ) {\n        fprintf(stderr,\"%s: File error in file %s\\n\",axohelp,filename);\n        exit(-1);\n    }\n    if ( ( buffer = malloc((filesize+1)*sizeof(char)) ) == 0 ) {\n        fprintf(stderr,\"%s: Error allocating %ld bytes of memory\",axohelp,filesize+1);\n        exit(-1);\n    }\n    num = fread( buffer, 1, filesize, finput );\n    if ( ferror(finput) ) {\n        fprintf(stderr,\"%s: Error reading file %s\\n\",axohelp,filename);\n        exit(-1);\n    }\n    buffer[num] = 0;\n    fclose(finput);\n    return(buffer);\n}", "target": 1}
{"code": "static bool nested_exit_on_nmi(struct kvm_vcpu *vcpu)\n{\n\treturn get_vmcs12(vcpu)->pin_based_vm_exec_control &\n\t\tPIN_BASED_NMI_EXITING;\n}", "target": 0}
{"code": "gen8_emit_flush_coherentl3_wa(struct intel_engine_cs *engine, u32 *batch)\n{\n\t*batch++ = MI_STORE_REGISTER_MEM_GEN8 | MI_SRM_LRM_GLOBAL_GTT;\n\t*batch++ = i915_mmio_reg_offset(GEN8_L3SQCREG4);\n\t*batch++ = intel_gt_scratch_offset(engine->gt,\n\t\t\t\t\t   INTEL_GT_SCRATCH_FIELD_COHERENTL3_WA);\n\t*batch++ = 0;\n\t*batch++ = MI_LOAD_REGISTER_IMM(1);\n\t*batch++ = i915_mmio_reg_offset(GEN8_L3SQCREG4);\n\t*batch++ = 0x40400000 | GEN8_LQSC_FLUSH_COHERENT_LINES;\n\tbatch = gen8_emit_pipe_control(batch,\n\t\t\t\t       PIPE_CONTROL_CS_STALL |\n\t\t\t\t       PIPE_CONTROL_DC_FLUSH_ENABLE,\n\t\t\t\t       0);\n\t*batch++ = MI_LOAD_REGISTER_MEM_GEN8 | MI_SRM_LRM_GLOBAL_GTT;\n\t*batch++ = i915_mmio_reg_offset(GEN8_L3SQCREG4);\n\t*batch++ = intel_gt_scratch_offset(engine->gt,\n\t\t\t\t\t   INTEL_GT_SCRATCH_FIELD_COHERENTL3_WA);\n\t*batch++ = 0;\n\treturn batch;\n}", "target": 0}
{"code": "static int mct_u232_port_probe(struct usb_serial_port *port)\n{\n\tstruct mct_u232_private *priv;\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tpriv->read_urb = port->serial->port[1]->interrupt_in_urb;\n\tpriv->read_urb->context = port;\n\tspin_lock_init(&priv->lock);\n\tusb_set_serial_port_data(port, priv);\n\treturn 0;\n}", "target": 1}
{"code": "int do_set_thread_area(struct task_struct *p, int idx,\n\t\t       struct user_desc __user *u_info,\n\t\t       int can_allocate)\n{\n\tstruct user_desc info;\n\tif (copy_from_user(&info, u_info, sizeof(info)))\n\t\treturn -EFAULT;\n\tif (!tls_desc_okay(&info))\n\t\treturn -EINVAL;\n\tif (idx == -1)\n\t\tidx = info.entry_number;\n\tif (idx == -1 && can_allocate) {\n\t\tidx = get_free_idx();\n\t\tif (idx < 0)\n\t\t\treturn idx;\n\t\tif (put_user(idx, &u_info->entry_number))\n\t\t\treturn -EFAULT;\n\t}\n\tif (idx < GDT_ENTRY_TLS_MIN || idx > GDT_ENTRY_TLS_MAX)\n\t\treturn -EINVAL;\n\tset_tls_desc(p, idx, &info, 1);\n\treturn 0;\n}", "target": 0}
{"code": "ip_printroute(netdissect_options *ndo,\n              register const u_char *cp, u_int length)\n{\n\tregister u_int ptr;\n\tregister u_int len;\n\tif (length < 3) {\n\t\tND_PRINT((ndo, \" [bad length %u]\", length));\n\t\treturn;\n\t}\n\tif ((length + 1) & 3)\n\t\tND_PRINT((ndo, \" [bad length %u]\", length));\n\tptr = cp[2] - 1;\n\tif (ptr < 3 || ((ptr + 1) & 3) || ptr > length + 1)\n\t\tND_PRINT((ndo, \" [bad ptr %u]\", cp[2]));\n\tfor (len = 3; len < length; len += 4) {\n\t\tND_PRINT((ndo, \" %s\", ipaddr_string(ndo, &cp[len])));\n\t\tif (ptr > len)\n\t\t\tND_PRINT((ndo, \",\"));\n\t}\n}", "target": 1}
{"code": "static int mptctl_do_reset(unsigned long arg)\n{\n\tstruct mpt_ioctl_diag_reset __user *urinfo = (void __user *) arg;\n\tstruct mpt_ioctl_diag_reset krinfo;\n\tMPT_ADAPTER\t\t*iocp;\n\tif (copy_from_user(&krinfo, urinfo, sizeof(struct mpt_ioctl_diag_reset))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_do_reset - \"\n\t\t\t\t\"Unable to copy mpt_ioctl_diag_reset struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, urinfo);\n\t\treturn -EFAULT;\n\t}\n\tif (mpt_verify_adapter(krinfo.hdr.iocnum, &iocp) < 0) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s@%d::mptctl_do_reset - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, krinfo.hdr.iocnum);\n\t\treturn -ENODEV; \n\t}\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT \"mptctl_do_reset called.\\n\",\n\t    iocp->name));\n\tif (mpt_HardResetHandler(iocp, CAN_SLEEP) != 0) {\n\t\tprintk (MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_reset - reset failed.\\n\",\n\t\t\tiocp->name, __FILE__, __LINE__);\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int vmx_cpu_uses_apicv(struct kvm_vcpu *vcpu)\n{\n\treturn enable_apicv && lapic_in_kernel(vcpu);\n}", "target": 0}
{"code": "bool CSPSource::isSchemeOnly() const\n{\n    return m_host.isEmpty();\n}", "target": 0}
{"code": "bool PixelFormat::is888(void) const\n{\n  if (!trueColour)\n    return false;\n  if (bpp != 32)\n    return false;\n  if (depth != 24)\n    return false;\n  if (redMax != 255)\n    return false;\n  if (greenMax != 255)\n    return false;\n  if (blueMax != 255)\n    return false;\n  if ((redShift & 0x7) != 0)\n    return false;\n  if ((greenShift & 0x7) != 0)\n    return false;\n  if ((blueShift & 0x7) != 0)\n    return false;\n  return true;\n}", "target": 0}
{"code": "static int crypto_rsa_common(const BYTE* input, int length, UINT32 key_length, const BYTE* modulus,\n                             const BYTE* exponent, int exponent_size, BYTE* output)\n{\n\tBN_CTX* ctx;\n\tint output_length = -1;\n\tBYTE* input_reverse;\n\tBYTE* modulus_reverse;\n\tBYTE* exponent_reverse;\n\tBIGNUM *mod, *exp, *x, *y;\n\tinput_reverse = (BYTE*)malloc(2 * key_length + exponent_size);\n\tif (!input_reverse)\n\t\treturn -1;\n\tmodulus_reverse = input_reverse + key_length;\n\texponent_reverse = modulus_reverse + key_length;\n\tmemcpy(modulus_reverse, modulus, key_length);\n\tcrypto_reverse(modulus_reverse, key_length);\n\tmemcpy(exponent_reverse, exponent, exponent_size);\n\tcrypto_reverse(exponent_reverse, exponent_size);\n\tmemcpy(input_reverse, input, length);\n\tcrypto_reverse(input_reverse, length);\n\tif (!(ctx = BN_CTX_new()))\n\t\tgoto fail_bn_ctx;\n\tif (!(mod = BN_new()))\n\t\tgoto fail_bn_mod;\n\tif (!(exp = BN_new()))\n\t\tgoto fail_bn_exp;\n\tif (!(x = BN_new()))\n\t\tgoto fail_bn_x;\n\tif (!(y = BN_new()))\n\t\tgoto fail_bn_y;\n\tBN_bin2bn(modulus_reverse, key_length, mod);\n\tBN_bin2bn(exponent_reverse, exponent_size, exp);\n\tBN_bin2bn(input_reverse, length, x);\n\tBN_mod_exp(y, x, exp, mod, ctx);\n\toutput_length = BN_bn2bin(y, output);\n\tcrypto_reverse(output, output_length);\n\tif (output_length < (int)key_length)\n\t\tmemset(output + output_length, 0, key_length - output_length);\n\tBN_free(y);\nfail_bn_y:\n\tBN_clear_free(x);\nfail_bn_x:\n\tBN_free(exp);\nfail_bn_exp:\n\tBN_free(mod);\nfail_bn_mod:\n\tBN_CTX_free(ctx);\nfail_bn_ctx:\n\tfree(input_reverse);\n\treturn output_length;\n}", "target": 1}
{"code": "void OpenURL(const char *url)\n{\n    if (strchr(url, '\\'') != NULL)\n    {\n        TRACELOG(LOG_WARNING, \"SYSTEM: Provided URL is not valid\");\n    }\n    else\n    {\n#if defined(PLATFORM_DESKTOP)\n        char *cmd = (char *)RL_CALLOC(strlen(url) + 32, sizeof(char));\n    #if defined(_WIN32)\n        sprintf(cmd, \"explorer \\\"%s\\\"\", url);\n    #endif\n    #if defined(__linux__) || defined(__FreeBSD__) || defined(__OpenBSD__)\n        sprintf(cmd, \"xdg-open '%s'\", url); \n    #endif\n    #if defined(__APPLE__)\n        sprintf(cmd, \"open '%s'\", url);\n    #endif\n        int result = system(cmd);\n        if (result == -1) TRACELOG(LOG_WARNING, \"OpenURL() child process could not be created\");\n        RL_FREE(cmd);\n#endif\n#if defined(PLATFORM_WEB)\n        emscripten_run_script(TextFormat(\"window.open('%s', '_blank')\", url));\n#endif\n#if defined(PLATFORM_ANDROID)\n        JNIEnv *env = NULL;\n        JavaVM *vm = CORE.Android.app->activity->vm;\n        (*vm)->AttachCurrentThread(vm, &env, NULL);\n        jstring urlString = (*env)->NewStringUTF(env, url);\n        jclass uriClass = (*env)->FindClass(env, \"android/net/Uri\");\n        jmethodID uriParse = (*env)->GetStaticMethodID(env, uriClass, \"parse\", \"(Ljava/lang/String;)Landroid/net/Uri;\");\n        jobject uri = (*env)->CallStaticObjectMethod(env, uriClass, uriParse, urlString);\n        jclass intentClass = (*env)->FindClass(env, \"android/content/Intent\");\n        jfieldID actionViewId = (*env)->GetStaticFieldID(env, intentClass, \"ACTION_VIEW\", \"Ljava/lang/String;\");\n        jobject actionView = (*env)->GetStaticObjectField(env, intentClass, actionViewId);\n        jmethodID newIntent = (*env)->GetMethodID(env, intentClass, \"<init>\", \"(Ljava/lang/String;Landroid/net/Uri;)V\");\n        jobject intent = (*env)->AllocObject(env, intentClass);\n        (*env)->CallVoidMethod(env, intent, newIntent, actionView, uri);\n        jclass activityClass = (*env)->FindClass(env, \"android/app/Activity\");\n        jmethodID startActivity = (*env)->GetMethodID(env, activityClass, \"startActivity\", \"(Landroid/content/Intent;)V\");\n        (*env)->CallVoidMethod(env, CORE.Android.app->activity->clazz, startActivity, intent);\n        (*vm)->DetachCurrentThread(vm);\n#endif\n    }\n}", "target": 1}
{"code": "static size_t GetImageChannels(const Image *image)\n{\n  register ssize_t\n    i;\n  size_t\n    channels;\n  channels=0;\n  for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n  {\n    PixelChannel channel = GetPixelChannelChannel(image,i);\n    PixelTrait traits = GetPixelChannelTraits(image,channel);\n    if (traits == UndefinedPixelTrait)\n      continue;\n    if ((traits & UpdatePixelTrait) == 0)\n      continue;\n    channels++;\n  }\n  return((size_t) (channels == 0 ? 1 : channels));\n}", "target": 0}
{"code": "ppmd_read(void* p) {\n\tstruct archive_read *a = ((IByteIn*)p)->a;\n\tstruct zip *zip = (struct zip*) a->format->data;\n\tconst uint8_t* data = __archive_read_ahead(a, 1, NULL);\n\t__archive_read_consume(a, 1);\n\t++zip->zipx_ppmd_read_compressed;\n\treturn data[0];\n}", "target": 0}
{"code": "static inline bool key_is_negative(const struct key *key)\n{\n\treturn key_read_state(key) < 0;\n}", "target": 0}
{"code": "static inline bool sched_clock_stable(void)\n{\n\treturn true;\n}", "target": 0}
{"code": "__u32 secure_ipv6_id(const __be32 daddr[4])\n{\n\t__u32 hash[4];\n\tmemcpy(hash, daddr, 16);\n\tmd5_transform(hash, net_secret);\n\treturn hash[0];\n}", "target": 0}
{"code": "void AuthChecker::PassUserInfoOnSuccess() {\n  char *json_buf = auth::WriteUserInfoToJson(user_info_);\n  if (json_buf == nullptr) {\n    return;\n  }\n  char *base64_json_buf = auth::esp_base64_encode(\n      json_buf, strlen(json_buf), true, false, true );\n  context_->request()->AddHeaderToBackend(auth::kEndpointApiUserInfo,\n                                          base64_json_buf);\n  auth::esp_grpc_free(json_buf);\n  auth::esp_grpc_free(base64_json_buf);\n  TRACE(trace_span_) << \"Authenticated.\";\n  trace_span_.reset();\n  on_done_(Status::OK);\n}", "target": 1}
{"code": "int extractVersionQuadFromString(const char* string, int* quad) {\n    const char* nextNumber = string;\n    for (int i = 0; i < 4; i++) {\n        quad[i] = (int)strtol(nextNumber, (char**)&nextNumber, 10);\n        if (*nextNumber != 0) {\n            nextNumber++;\n        }\n    }\n    return 0;\n}", "target": 0}
{"code": "  void connectErr(const AsyncSocketException& ex) noexcept override {\n    FAIL() << ex.what();\n  }", "target": 0}
{"code": "AP_CORE_DECLARE(void) ap_parse_uri(request_rec *r, const char *uri)\n{\n    int status = HTTP_OK;\n    r->unparsed_uri = apr_pstrdup(r->pool, uri);\n    while ((uri[0] == '/') && (uri[1] == '/')) {\n        ++uri ;\n    }\n    if (r->method_number == M_CONNECT) {\n        status = apr_uri_parse_hostinfo(r->pool, uri, &r->parsed_uri);\n    }\n    else {\n        status = apr_uri_parse(r->pool, uri, &r->parsed_uri);\n    }\n    if (status == APR_SUCCESS) {\n        if (r->parsed_uri.scheme\n            && !ap_cstr_casecmp(r->parsed_uri.scheme, ap_http_scheme(r))) {\n            r->hostname = r->parsed_uri.hostname;\n        }\n        else if (r->method_number == M_CONNECT) {\n            r->hostname = r->parsed_uri.hostname;\n        }\n        r->args = r->parsed_uri.query;\n        r->uri = r->parsed_uri.path ? r->parsed_uri.path\n                 : apr_pstrdup(r->pool, \"/\");\n#if defined(OS2) || defined(WIN32)\n        {\n            char *x;\n            for (x = r->uri; (x = strchr(x, '\\\\')) != NULL; )\n                *x = '/';\n        }\n#endif \n    }\n    else {\n        r->args = NULL;\n        r->hostname = NULL;\n        r->status = HTTP_BAD_REQUEST;             \n        r->uri = apr_pstrdup(r->pool, uri);\n    }\n}", "target": 1}
{"code": "static inline u16 skb_get_queue_mapping(const struct sk_buff *skb)\n{\n\treturn skb->queue_mapping;\n}", "target": 0}
{"code": "static void svg_parse_preserveaspectratio(SVG_PreserveAspectRatio *par, char *attribute_content, GF_Err *out_e)\n{\n\tchar *content = attribute_content;\n\twhile (*content == ' ') content++;\n\tif (strstr(content, \"defer\")) {\n\t\tpar->defer = 1;\n\t\tcontent += 4;\n\t} else {\n\t\tcontent = attribute_content;\n\t}\n\twhile (*content == ' ') content++;\n\tif (strstr(content, \"none\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_NONE;\n\t\tcontent+=4;\n\t} else if (strstr(content, \"xMinYMin\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMINYMIN;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMidYMin\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMIDYMIN;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMaxYMin\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMAXYMIN;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMinYMid\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMINYMID;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMidYMid\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMIDYMID;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMaxYMid\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMAXYMID;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMinYMax\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMINYMAX;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMidYMax\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMIDYMAX;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMaxYMax\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMAXYMAX;\n\t\tcontent+=8;\n\t} else {\n\t\t*out_e = GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\twhile (*content == ' ') content++;\n\tif (*content == 0) return;\n\tif (strstr(content, \"meet\")) {\n\t\tpar->meetOrSlice = SVG_MEETORSLICE_MEET;\n\t} else if (strstr(content, \"slice\")) {\n\t\tpar->meetOrSlice = SVG_MEETORSLICE_SLICE;\n\t} else {\n\t\t*out_e = GF_NON_COMPLIANT_BITSTREAM;\n\t}\n}", "target": 1}
{"code": "static void ie_destructor(void *arg)\n{\n\tstruct ident_entry *ie = arg;\n\tmem_deref(ie->content.publish);\n\tmem_deref(ie->content.accept);\n\tmem_deref(ie->ident);\n}", "target": 0}
{"code": "void shut_down(int code)\n{\n    int i;\n    int bytes_in = 0;\n    int bytes_out = 0;\n    in_shutdown = 1;\n    if (allow_cors) free_wildmats(allow_cors);\n    for (i = 0; http_namespaces[i]; i++) {\n        if (http_namespaces[i]->enabled && http_namespaces[i]->shutdown)\n            http_namespaces[i]->shutdown();\n    }\n    xmlCleanupParser();\n    proc_cleanup();\n    i = 0;\n    while (backend_cached && backend_cached[i]) {\n        proxy_downserver(backend_cached[i]);\n        free(backend_cached[i]->context);\n        free(backend_cached[i]);\n        i++;\n    }\n    if (backend_cached) free(backend_cached);\n    index_text_extractor_destroy();\n    annotatemore_close();\n    if (httpd_in) {\n        prot_NONBLOCK(httpd_in);\n        prot_fill(httpd_in);\n        bytes_in = prot_bytes_in(httpd_in);\n        prot_free(httpd_in);\n    }\n    if (httpd_out) {\n        prot_flush(httpd_out);\n        bytes_out = prot_bytes_out(httpd_out);\n        prot_free(httpd_out);\n        prometheus_decrement(CYRUS_HTTP_ACTIVE_CONNECTIONS);\n    }\n    else {\n        prometheus_decrement(CYRUS_HTTP_READY_LISTENERS);\n    }\n    prometheus_increment(code ? CYRUS_HTTP_SHUTDOWN_TOTAL_STATUS_ERROR\n                              : CYRUS_HTTP_SHUTDOWN_TOTAL_STATUS_OK);\n    if (protin) protgroup_free(protin);\n    if (config_auditlog)\n        syslog(LOG_NOTICE,\n               \"auditlog: traffic sessionid=<%s> bytes_in=<%d> bytes_out=<%d>\",\n               session_id(), bytes_in, bytes_out);\n#ifdef HAVE_SSL\n    tls_shutdown_serverengine();\n#endif\n    saslprops_free(&saslprops);\n    http2_done();\n    cyrus_done();\n    exit(code);\n}", "target": 0}
{"code": "static av_cold int xpm_decode_close(AVCodecContext *avctx)\n{\n    XPMDecContext *x = avctx->priv_data;\n    av_freep(&x->pixels);\n    av_freep(&x->buf);\n    x->buf_size = 0;\n    return 0;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* c) override {\n    Tensor* output_tensor;\n    AllocatorAttributes attr;\n    attr.set_on_host(true);\n    OP_REQUIRES_OK(c, c->allocate_output(0, {}, &output_tensor, attr));\n    PartialTensorShape element_shape;\n    OP_REQUIRES(\n        c, !TensorShapeUtils::IsMatrixOrHigher(c->input(1).shape()),\n        errors::InvalidArgument(\n            \"TensorListFromTensor: element_shape must be at most rank 1 but \",\n            \"has the shape of \", c->input(1).shape().DebugString()));\n    OP_REQUIRES_OK(c, TensorShapeFromTensor(c->input(1), &element_shape));\n    TensorList output_list;\n    const Tensor& t = c->input(0);\n    output_list.element_dtype = t.dtype();\n    OP_REQUIRES(c, TensorShapeUtils::IsVectorOrHigher(t.shape()),\n                errors::InvalidArgument(\n                    \"Tensor must be at least a vector, but saw shape: \",\n                    t.shape().DebugString()));\n    TensorShape output_shape(t.shape());\n    output_shape.RemoveDim(0);\n    OP_REQUIRES(c, element_shape.IsCompatibleWith(output_shape),\n                errors::InvalidArgument(\n                    \"Specified a list with shape \", element_shape.DebugString(),\n                    \" from a tensor with shape \", output_shape.DebugString()));\n    output_list.element_shape = element_shape;\n    output_list.tensors().reserve(t.shape().dim_size(0));\n    const auto copy_tensor = IsPluggableDevice(c)\n                                 ? &CopyTensorPluggableDevice<T>\n                                 : &CopyTensor<Device, T>;\n    for (int i = 0; i < t.shape().dim_size(0); ++i) {\n      Tensor tmp = t.Slice(i, i + 1);\n      TensorShape tmp_shape = tmp.shape();\n      tmp_shape.RemoveDim(0);\n      OP_REQUIRES(c, tmp.CopyFrom(tmp, tmp_shape),\n                  errors::Unknown(\"Unexpected shape error.\"));\n      Tensor aligned;\n      OP_REQUIRES_OK(c, c->allocate_temp(tmp.dtype(), tmp.shape(), &aligned));\n      copy_tensor(c, tmp, aligned);\n      output_list.tensors().push_back(aligned);\n    }\n    output_tensor->scalar<Variant>()() = std::move(output_list);\n  }", "target": 0}
{"code": "_prolog_error(batch_job_launch_msg_t *req, int rc)\n{\n\tchar *err_name_ptr, err_name[256], path_name[MAXPATHLEN];\n\tchar *fmt_char;\n\tint fd;\n\tif (req->std_err || req->std_out) {\n\t\tif (req->std_err)\n\t\t\tstrncpy(err_name, req->std_err, sizeof(err_name));\n\t\telse\n\t\t\tstrncpy(err_name, req->std_out, sizeof(err_name));\n\t\tif ((fmt_char = strchr(err_name, (int) '%')) &&\n\t\t    (fmt_char[1] == 'j') && !strchr(fmt_char+1, (int) '%')) {\n\t\t\tchar tmp_name[256];\n\t\t\tfmt_char[1] = 'u';\n\t\t\tsnprintf(tmp_name, sizeof(tmp_name), err_name,\n\t\t\t\t req->job_id);\n\t\t\tstrncpy(err_name, tmp_name, sizeof(err_name));\n\t\t}\n\t} else {\n\t\tsnprintf(err_name, sizeof(err_name), \"slurm-%u.out\",\n\t\t\t req->job_id);\n\t}\n\terr_name_ptr = err_name;\n\tif (err_name_ptr[0] == '/')\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s\", err_name_ptr);\n\telse if (req->work_dir)\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s/%s\",\n\t\t\treq->work_dir, err_name_ptr);\n\telse\n\t\tsnprintf(path_name, MAXPATHLEN, \"/%s\", err_name_ptr);\n\tif ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1) {\n\t\terror(\"Unable to open %s: %s\", path_name,\n\t\t      slurm_strerror(errno));\n\t\treturn;\n\t}\n\tsnprintf(err_name, sizeof(err_name),\n\t\t \"Error running slurm prolog: %d\\n\", WEXITSTATUS(rc));\n\tsafe_write(fd, err_name, strlen(err_name));\n\tif (fchown(fd, (uid_t) req->uid, (gid_t) req->gid) == -1) {\n\t\tsnprintf(err_name, sizeof(err_name),\n\t\t\t \"Couldn't change fd owner to %u:%u: %m\\n\",\n\t\t\t req->uid, req->gid);\n\t}\nrwfail:\n\tclose(fd);\n}", "target": 1}
{"code": "bool Archive::Close()\n{\n#ifdef USE_ARCMEM\n  if (ArcMem.Unload())\n    return true;\n#endif\n  return File::Close();\n}", "target": 0}
{"code": "x509_vfy_callback_indicate_completion(X509_STORE_CTX *ctx)\n{\n\treturn x509_vfy_internal_verify(ctx, 1);\n}", "target": 0}
{"code": "static NO_INLINE JsVar *jspGetNamedFieldInParents(JsVar *object, const char* name, bool returnName) {\n  JsVar * child = jspeiFindChildFromStringInParents(object, name);\n  if (!child) {\n    child = jswFindBuiltInFunction(object, name);\n  }\n  if (child && returnName) {\n    if (jsvIsName(child)) {\n      JsVar *t = jsvGetValueOfName(child);\n      jsvUnLock(child);\n      child = t;\n    }\n    JsVar *nameVar = jsvNewFromString(name);\n    JsVar *newChild = jsvCreateNewChild(object, nameVar, child);\n    jsvUnLock2(nameVar, child);\n    child = newChild;\n  }\n  if (!child) {\n    if (jsvIsFunction(object) && strcmp(name, JSPARSE_PROTOTYPE_VAR)==0) {\n      JsVar *proto = jsvNewObject();\n      jsvObjectSetChild(proto, JSPARSE_CONSTRUCTOR_VAR, object);\n      child = jsvAddNamedChild(object, proto, JSPARSE_PROTOTYPE_VAR);\n      jspEnsureIsPrototype(object, child);\n      jsvUnLock(proto);\n    } else if (strcmp(name, JSPARSE_INHERITS_VAR)==0) {\n      const char *objName = jswGetBasicObjectName(object);\n      if (objName) {\n        child = jspNewPrototype(objName);\n      }\n    }\n  }\n  return child;\n}", "target": 1}
{"code": "static inline void native_tss_invalidate_io_bitmap(void)\n{\n\tthis_cpu_write(cpu_tss_rw.x86_tss.io_bitmap_base,\n\t\t       IO_BITMAP_OFFSET_INVALID);\n}", "target": 0}
{"code": "static int ntlm_decode_u16l_str_hdr(struct ntlm_ctx *ctx,\n                                    struct wire_field_hdr *str_hdr,\n                                    struct ntlm_buffer *buffer,\n                                    size_t payload_offs, char **str)\n{\n    char *in, *out = NULL;\n    uint16_t str_len;\n    uint32_t str_offs;\n    size_t outlen = 0;\n    int ret = 0;\n    str_len = le16toh(str_hdr->len);\n    if (str_len == 0) goto done;\n    str_offs = le32toh(str_hdr->offset);\n    if ((str_offs < payload_offs) ||\n        (str_offs > buffer->length) ||\n        (UINT32_MAX - str_offs < str_len) ||\n        (str_offs + str_len > buffer->length)) {\n        return ERR_DECODE;\n    }\n    in = (char *)&buffer->data[str_offs];\n    out = malloc(str_len * 2 + 1);\n    if (!out) return ENOMEM;\n    ret = ntlm_str_convert(ctx->to_oem, in, out, str_len, &outlen);\ndone:\n    if (ret) {\n        safefree(out);\n    } else {\n        out[outlen] = '\\0';\n    }\n    *str = out;\n    return ret;\n}", "target": 0}
{"code": "find_cleartext_device (Device *device)\n{\n  GList *devices;\n  GList *l;\n  Device *ret;\n  ret = NULL;\n  devices = daemon_local_get_all_devices (device->priv->daemon);\n  for (l = devices; l != NULL; l = l->next)\n    {\n      Device *d = DEVICE (l->data);\n      if (d->priv->device_is_luks_cleartext && d->priv->luks_cleartext_slave != NULL\n          && strcmp (d->priv->luks_cleartext_slave, device->priv->object_path) == 0)\n        {\n          ret = d;\n          goto out;\n        }\n    }\n out:\n  g_list_free (devices);\n  return ret;\n}", "target": 0}
{"code": "int cx23888_ir_probe(struct cx23885_dev *dev)\n{\n\tstruct cx23888_ir_state *state;\n\tstruct v4l2_subdev *sd;\n\tstruct v4l2_subdev_ir_parameters default_params;\n\tint ret;\n\tstate = kzalloc(sizeof(struct cx23888_ir_state), GFP_KERNEL);\n\tif (state == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&state->rx_kfifo_lock);\n\tif (kfifo_alloc(&state->rx_kfifo, CX23888_IR_RX_KFIFO_SIZE, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\tstate->dev = dev;\n\tsd = &state->sd;\n\tv4l2_subdev_init(sd, &cx23888_ir_controller_ops);\n\tv4l2_set_subdevdata(sd, state);\n\tsnprintf(sd->name, sizeof(sd->name), \"%s/888-ir\", dev->name);\n\tsd->grp_id = CX23885_HW_888_IR;\n\tret = v4l2_device_register_subdev(&dev->v4l2_dev, sd);\n\tif (ret == 0) {\n\t\tcx23888_ir_write4(dev, CX23888_IR_IRQEN_REG, 0);\n\t\tmutex_init(&state->rx_params_lock);\n\t\tdefault_params = default_rx_params;\n\t\tv4l2_subdev_call(sd, ir, rx_s_parameters, &default_params);\n\t\tmutex_init(&state->tx_params_lock);\n\t\tdefault_params = default_tx_params;\n\t\tv4l2_subdev_call(sd, ir, tx_s_parameters, &default_params);\n\t} else {\n\t\tkfifo_free(&state->rx_kfifo);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "\t\tauto GetTargetAndAlsoCheckForProxy() -> Local<Object> {\n\t\t\tauto object = Local<Object>::Cast(Deref(target));\n\t\t\tif (HasProxy(object)) {\n\t\t\t\tthrow RuntimeTypeError(\"Object is or has proxy\");\n\t\t\t}\n\t\t\treturn object;\n\t\t}", "target": 0}
{"code": "bool PrintWebViewHelper::PrintPreviewContext::CreatePreviewDocument(\n    PrepareFrameAndViewForPrint* prepared_frame,\n    const std::vector<int>& pages) {\n  DCHECK_EQ(INITIALIZED, state_);\n  state_ = RENDERING;\n  prep_frame_view_.reset(prepared_frame);\n  prep_frame_view_->StartPrinting();\n  total_page_count_ = prep_frame_view_->GetExpectedPageCount();\n  if (total_page_count_ == 0) {\n    LOG(ERROR) << \"CreatePreviewDocument got 0 page count\";\n    set_error(PREVIEW_ERROR_ZERO_PAGES);\n    return false;\n  }\n  metafile_.reset(new PdfMetafileSkia);\n  if (!metafile_->Init()) {\n    set_error(PREVIEW_ERROR_METAFILE_INIT_FAILED);\n    LOG(ERROR) << \"PdfMetafileSkia Init failed\";\n    return false;\n  }\n  current_page_index_ = 0;\n  pages_to_render_ = pages;\n  std::sort(pages_to_render_.begin(), pages_to_render_.end());\n  pages_to_render_.resize(\n      std::unique(pages_to_render_.begin(), pages_to_render_.end()) -\n      pages_to_render_.begin());\n  pages_to_render_.resize(std::lower_bound(pages_to_render_.begin(),\n                                           pages_to_render_.end(),\n                                           total_page_count_) -\n                          pages_to_render_.begin());\n  print_ready_metafile_page_count_ = pages_to_render_.size();\n  if (pages_to_render_.empty()) {\n    print_ready_metafile_page_count_ = total_page_count_;\n    for (int i = 0; i < total_page_count_; ++i)\n      pages_to_render_.push_back(i);\n  } else if (generate_draft_pages_) {\n    int pages_index = 0;\n    for (int i = 0; i < total_page_count_; ++i) {\n      if (pages_index < print_ready_metafile_page_count_ &&\n          i == pages_to_render_[pages_index]) {\n        pages_index++;\n        continue;\n      }\n      pages_to_render_.push_back(i);\n    }\n  }\n  document_render_time_ = base::TimeDelta();\n  begin_time_ = base::TimeTicks::Now();\n  return true;\n}", "target": 0}
{"code": "static int br_parse_ip_options(struct sk_buff *skb)\n{\n\tstruct ip_options *opt;\n\tstruct iphdr *iph;\n\tstruct net_device *dev = skb->dev;\n\tu32 len;\n\tiph = ip_hdr(skb);\n\topt = &(IPCB(skb)->opt);\n\tif (iph->ihl < 5 || iph->version != 4)\n\t\tgoto inhdr_error;\n\tif (!pskb_may_pull(skb, iph->ihl*4))\n\t\tgoto inhdr_error;\n\tiph = ip_hdr(skb);\n\tif (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))\n\t\tgoto inhdr_error;\n\tlen = ntohs(iph->tot_len);\n\tif (skb->len < len) {\n\t\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INTRUNCATEDPKTS);\n\t\tgoto drop;\n\t} else if (len < (iph->ihl*4))\n\t\tgoto inhdr_error;\n\tif (pskb_trim_rcsum(skb, len)) {\n\t\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INDISCARDS);\n\t\tgoto drop;\n\t}\n\tif (iph->ihl == 5) {\n\t\tmemset(IPCB(skb), 0, sizeof(struct inet_skb_parm));\n\t\treturn 0;\n\t}\n\topt->optlen = iph->ihl*4 - sizeof(struct iphdr);\n\tif (ip_options_compile(dev_net(dev), opt, skb))\n\t\tgoto inhdr_error;\n\tif (unlikely(opt->srr)) {\n\t\tstruct in_device *in_dev = __in_dev_get_rcu(dev);\n\t\tif (in_dev && !IN_DEV_SOURCE_ROUTE(in_dev))\n\t\t\tgoto drop;\n\t\tif (ip_options_rcv_srr(skb))\n\t\t\tgoto drop;\n\t}\n\treturn 0;\ninhdr_error:\n\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INHDRERRORS);\ndrop:\n\treturn -1;\n}", "target": 1}
{"code": "static int check_stack_boundary(struct bpf_verifier_env *env, int regno,\n\t\t\t\tint access_size, bool zero_size_allowed,\n\t\t\t\tstruct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_verifier_state *state = env->cur_state;\n\tstruct bpf_reg_state *regs = state->regs;\n\tint off, i, slot, spi;\n\tif (regs[regno].type != PTR_TO_STACK) {\n\t\tif (zero_size_allowed && access_size == 0 &&\n\t\t    register_is_null(regs[regno]))\n\t\t\treturn 0;\n\t\tverbose(env, \"R%d type=%s expected=%s\\n\", regno,\n\t\t\treg_type_str[regs[regno].type],\n\t\t\treg_type_str[PTR_TO_STACK]);\n\t\treturn -EACCES;\n\t}\n\tif (!tnum_is_const(regs[regno].var_off)) {\n\t\tchar tn_buf[48];\n\t\ttnum_strn(tn_buf, sizeof(tn_buf), regs[regno].var_off);\n\t\tverbose(env, \"invalid variable stack read R%d var_off=%s\\n\",\n\t\t\tregno, tn_buf);\n\t\treturn -EACCES;\n\t}\n\toff = regs[regno].off + regs[regno].var_off.value;\n\tif (off >= 0 || off < -MAX_BPF_STACK || off + access_size > 0 ||\n\t    access_size < 0 || (access_size == 0 && !zero_size_allowed)) {\n\t\tverbose(env, \"invalid stack type R%d off=%d access_size=%d\\n\",\n\t\t\tregno, off, access_size);\n\t\treturn -EACCES;\n\t}\n\tif (env->prog->aux->stack_depth < -off)\n\t\tenv->prog->aux->stack_depth = -off;\n\tif (meta && meta->raw_mode) {\n\t\tmeta->access_size = access_size;\n\t\tmeta->regno = regno;\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < access_size; i++) {\n\t\tslot = -(off + i) - 1;\n\t\tspi = slot / BPF_REG_SIZE;\n\t\tif (state->allocated_stack <= slot ||\n\t\t    state->stack[spi].slot_type[slot % BPF_REG_SIZE] !=\n\t\t\tSTACK_MISC) {\n\t\t\tverbose(env, \"invalid indirect read from stack off %d+%d size %d\\n\",\n\t\t\t\toff, i, access_size);\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "ZEND_API int zend_ts_hash_num_elements(TsHashTable *ht)\n{\n\tint retval;\n\tbegin_read(ht);\n\tretval = zend_hash_num_elements(TS_HASH(ht));\n\tend_read(ht);\n\treturn retval;\n}", "target": 0}
{"code": "internalEntityProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  ENTITY *entity;\n  const char *textStart, *textEnd;\n  const char *next;\n  enum XML_Error result;\n  OPEN_INTERNAL_ENTITY *openEntity = parser->m_openInternalEntities;\n  if (! openEntity)\n    return XML_ERROR_UNEXPECTED_STATE;\n  entity = openEntity->entity;\n  textStart = ((char *)entity->textPtr) + entity->processed;\n  textEnd = (char *)(entity->textPtr + entity->textLen);\n  next = textStart;\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok\n        = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n                      tok, next, &next, XML_FALSE);\n  } else\n#endif \n    result = doContent(parser, openEntity->startTagLevel,\n                       parser->m_internalEncoding, textStart, textEnd, &next,\n                       XML_FALSE);\n  if (result != XML_ERROR_NONE)\n    return result;\n  else if (textEnd != next\n           && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n    entity->processed = (int)(next - (char *)entity->textPtr);\n    return result;\n  } else {\n    entity->open = XML_FALSE;\n    parser->m_openInternalEntities = openEntity->next;\n    openEntity->next = parser->m_freeInternalEntities;\n    parser->m_freeInternalEntities = openEntity;\n  }\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok;\n    parser->m_processor = prologProcessor;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n    return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                    (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n  } else\n#endif \n  {\n    parser->m_processor = contentProcessor;\n    return doContent(parser, parser->m_parentParser ? 1 : 0, parser->m_encoding,\n                     s, end, nextPtr,\n                     (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n  }\n}", "target": 1}
{"code": "struct mnt_namespace *copy_mnt_ns(unsigned long flags, struct mnt_namespace *ns,\n\t\tstruct user_namespace *user_ns, struct fs_struct *new_fs)\n{\n\tstruct mnt_namespace *new_ns;\n\tstruct vfsmount *rootmnt = NULL, *pwdmnt = NULL;\n\tstruct mount *p, *q;\n\tstruct mount *old;\n\tstruct mount *new;\n\tint copy_flags;\n\tBUG_ON(!ns);\n\tif (likely(!(flags & CLONE_NEWNS))) {\n\t\tget_mnt_ns(ns);\n\t\treturn ns;\n\t}\n\told = ns->root;\n\tnew_ns = alloc_mnt_ns(user_ns);\n\tif (IS_ERR(new_ns))\n\t\treturn new_ns;\n\tnamespace_lock();\n\tcopy_flags = CL_COPY_UNBINDABLE | CL_EXPIRE;\n\tif (user_ns != ns->user_ns)\n\t\tcopy_flags |= CL_SHARED_TO_SLAVE | CL_UNPRIVILEGED;\n\tnew = copy_tree(old, old->mnt.mnt_root, copy_flags);\n\tif (IS_ERR(new)) {\n\t\tnamespace_unlock();\n\t\tfree_mnt_ns(new_ns);\n\t\treturn ERR_CAST(new);\n\t}\n\tnew_ns->root = new;\n\tlist_add_tail(&new_ns->list, &new->mnt_list);\n\tp = old;\n\tq = new;\n\twhile (p) {\n\t\tq->mnt_ns = new_ns;\n\t\tnew_ns->mounts++;\n\t\tif (new_fs) {\n\t\t\tif (&p->mnt == new_fs->root.mnt) {\n\t\t\t\tnew_fs->root.mnt = mntget(&q->mnt);\n\t\t\t\trootmnt = &p->mnt;\n\t\t\t}\n\t\t\tif (&p->mnt == new_fs->pwd.mnt) {\n\t\t\t\tnew_fs->pwd.mnt = mntget(&q->mnt);\n\t\t\t\tpwdmnt = &p->mnt;\n\t\t\t}\n\t\t}\n\t\tp = next_mnt(p, old);\n\t\tq = next_mnt(q, new);\n\t\tif (!q)\n\t\t\tbreak;\n\t\twhile (p->mnt.mnt_root != q->mnt.mnt_root)\n\t\t\tp = next_mnt(p, old);\n\t}\n\tnamespace_unlock();\n\tif (rootmnt)\n\t\tmntput(rootmnt);\n\tif (pwdmnt)\n\t\tmntput(pwdmnt);\n\treturn new_ns;\n}", "target": 0}
{"code": "void test_xattrs(const char *path)\n{\n\t char value[200];\n\t if (getxattr(path, \"security.selinux\", value, 200) >= 0) {\n\t\tfprintf(stderr, \"leak at getxattr of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at getxattr of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "void pb_controller::play_file(const std::string& file) {\n\tstd::string cmdline;\n\tstd::string player = cfg->get_configvalue(\"player\");\n\tif (player == \"\")\n\t\treturn;\n\tcmdline.append(player);\n\tcmdline.append(\" \\\"\");\n\tcmdline.append(utils::replace_all(file,\"\\\"\", \"\\\\\\\"\"));\n\tcmdline.append(\"\\\"\");\n\tstfl::reset();\n\tutils::run_interactively(cmdline, \"pb_controller::play_file\");\n}", "target": 1}
{"code": "static int newque(struct ipc_namespace *ns, struct ipc_params *params)\n{\n\tstruct msg_queue *msq;\n\tint id, retval;\n\tkey_t key = params->key;\n\tint msgflg = params->flg;\n\tmsq = ipc_rcu_alloc(sizeof(*msq));\n\tif (!msq)\n\t\treturn -ENOMEM;\n\tmsq->q_perm.mode = msgflg & S_IRWXUGO;\n\tmsq->q_perm.key = key;\n\tmsq->q_perm.security = NULL;\n\tretval = security_msg_queue_alloc(msq);\n\tif (retval) {\n\t\tipc_rcu_putref(msq, ipc_rcu_free);\n\t\treturn retval;\n\t}\n\tid = ipc_addid(&msg_ids(ns), &msq->q_perm, ns->msg_ctlmni);\n\tif (id < 0) {\n\t\tipc_rcu_putref(msq, msg_rcu_free);\n\t\treturn id;\n\t}\n\tmsq->q_stime = msq->q_rtime = 0;\n\tmsq->q_ctime = get_seconds();\n\tmsq->q_cbytes = msq->q_qnum = 0;\n\tmsq->q_qbytes = ns->msg_ctlmnb;\n\tmsq->q_lspid = msq->q_lrpid = 0;\n\tINIT_LIST_HEAD(&msq->q_messages);\n\tINIT_LIST_HEAD(&msq->q_receivers);\n\tINIT_LIST_HEAD(&msq->q_senders);\n\tipc_unlock_object(&msq->q_perm);\n\trcu_read_unlock();\n\treturn msq->q_perm.id;\n}", "target": 1}
{"code": "void comps_objrtree_unite(COMPS_ObjRTree *rt1, COMPS_ObjRTree *rt2) {\n    COMPS_HSList *tmplist, *tmp_subnodes;\n    COMPS_HSListItem *it;\n    struct Pair {\n        COMPS_HSList * subnodes;\n        char * key;\n        char added;\n    } *pair, *parent_pair;\n    pair = malloc(sizeof(struct Pair));\n    pair->subnodes = rt2->subnodes;\n    pair->key = NULL;\n    tmplist = comps_hslist_create();\n    comps_hslist_init(tmplist, NULL, NULL, &free);\n    comps_hslist_append(tmplist, pair, 0);\n    while (tmplist->first != NULL) {\n        it = tmplist->first;\n        comps_hslist_remove(tmplist, tmplist->first);\n        tmp_subnodes = ((struct Pair*)it->data)->subnodes;\n        parent_pair = (struct Pair*) it->data;\n        free(it);\n        for (it = tmp_subnodes->first; it != NULL; it=it->next) {\n            pair = malloc(sizeof(struct Pair));\n            pair->subnodes = ((COMPS_ObjRTreeData*)it->data)->subnodes;\n            if (parent_pair->key != NULL) {\n                pair->key = malloc(sizeof(char)\n                               * (strlen(((COMPS_ObjRTreeData*)it->data)->key)\n                               + strlen(parent_pair->key) + 1));\n                memcpy(pair->key, parent_pair->key,\n                       sizeof(char) * strlen(parent_pair->key));\n                memcpy(pair->key + strlen(parent_pair->key),\n                       ((COMPS_ObjRTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_ObjRTreeData*)it->data)->key)+1));\n            } else {\n                pair->key = malloc(sizeof(char)*\n                                (strlen(((COMPS_ObjRTreeData*)it->data)->key) +1));\n                memcpy(pair->key, ((COMPS_ObjRTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_ObjRTreeData*)it->data)->key)+1));\n            }\n            if (((COMPS_ObjRTreeData*)it->data)->data != NULL) {\n                    comps_objrtree_set(rt1, pair->key,\n                                      (((COMPS_ObjRTreeData*)it->data)->data));\n            }\n            if (((COMPS_ObjRTreeData*)it->data)->subnodes->first) {\n                comps_hslist_append(tmplist, pair, 0);\n            } else {\n                free(pair->key);\n                free(pair);\n            }\n        }\n        free(parent_pair->key);\n        free(parent_pair);\n    }\n    comps_hslist_destroy(&tmplist);\n}", "target": 1}
{"code": "TEST(TensorSliceWriterTest, InvalidInput) {\n  SavedSlice ss;\n  std::array<uint32_t, 1> data;\n  std::fill(data.begin(), data.end(), 1234);\n  Status s = TensorSliceWriter::SaveData(data.data(), data.size(), &ss);\n  EXPECT_EQ(s.code(), error::INVALID_ARGUMENT);\n  EXPECT_TRUE(absl::StrContains(\n      s.error_message(),\n      \"Tensor slice serialization not implemented for dtype\"));\n}", "target": 0}
{"code": "static int adpt_i2o_systab_send(adpt_hba* pHba)\n{\n\tu32 msg[12];\n\tint ret;\n\tmsg[0] = I2O_MESSAGE_SIZE(12) | SGL_OFFSET_6;\n\tmsg[1] = I2O_CMD_SYS_TAB_SET<<24 | HOST_TID<<12 | ADAPTER_TID;\n\tmsg[2] = 0;\n\tmsg[3] = 0;\n\tmsg[4] = (0<<16) | ((pHba->unit+2) << 12); \n\tmsg[5] = 0;\t\t\t\t   \n\tmsg[6] = 0x54000000 | sys_tbl_len;\n\tmsg[7] = (u32)sys_tbl_pa;\n\tmsg[8] = 0x54000000 | 0;\n\tmsg[9] = 0;\n\tmsg[10] = 0xD4000000 | 0;\n\tmsg[11] = 0;\n\tif ((ret=adpt_i2o_post_wait(pHba, msg, sizeof(msg), 120))) {\n\t\tprintk(KERN_INFO \"%s: Unable to set SysTab (status=%#10x).\\n\", \n\t\t\tpHba->name, ret);\n\t}\n#ifdef DEBUG\n\telse {\n\t\tPINFO(\"%s: SysTab set.\\n\", pHba->name);\n\t}\n#endif\n\treturn ret;\t\n}", "target": 1}
{"code": "static int lmf_header_load(lmf_header *lmfh, RBuffer *buf, Sdb *db) {\n\tif (r_buf_size (buf) < sizeof (lmf_header)) {\n\t\treturn false;\n\t}\n\tif (r_buf_fread_at (buf, QNX_HEADER_ADDR, (ut8 *) lmfh, \"iiiiiiiicccciiiicc\", 1) < QNX_HDR_SIZE) {\n\t\treturn false;\n\t}\n\tr_strf_buffer (32);\n\tsdb_set (db, \"qnx.version\", r_strf (\"0x%xH\", lmfh->version), 0);\n\tsdb_set (db, \"qnx.cflags\", r_strf (\"0x%xH\", lmfh->cflags), 0);\n\tsdb_set (db, \"qnx.cpu\", r_strf (\"0x%xH\", lmfh->cpu), 0);\n\tsdb_set (db, \"qnx.fpu\", r_strf (\"0x%xH\", lmfh->fpu), 0);\n\tsdb_set (db, \"qnx.code_index\", r_strf (\"0x%x\", lmfh->code_index), 0);\n\tsdb_set (db, \"qnx.stack_index\", r_strf (\"0x%x\", lmfh->stack_index), 0);\n\tsdb_set (db, \"qnx.heap_index\", r_strf (\"0x%x\", lmfh->heap_index), 0);\n\tsdb_set (db, \"qnx.argv_index\", r_strf (\"0x%x\", lmfh->argv_index), 0);\n\tsdb_set (db, \"qnx.code_offset\", r_strf (\"0x%x\", lmfh->code_offset), 0);\n\tsdb_set (db, \"qnx.stack_nbytes\", r_strf (\"0x%x\", lmfh->stack_nbytes), 0);\n\tsdb_set (db, \"qnx.heap_nbytes\", r_strf (\"0x%x\", lmfh->heap_nbytes), 0);\n\tsdb_set (db, \"qnx.image_base\", r_strf (\"0x%x\", lmfh->image_base), 0);\n\treturn true;\n}", "target": 1}
{"code": "[[noreturn]] void TProtocolException::throwTruncatedData() {\n  throw TProtocolException(\n      TProtocolException::INVALID_DATA,\n      \"Not enough bytes to read the entire message, the data appears to be \"\n      \"truncated\");\n}", "target": 0}
{"code": "long keyctl_update_key(key_serial_t id,\n\t\t       const void __user *_payload,\n\t\t       size_t plen)\n{\n\tkey_ref_t key_ref;\n\tvoid *payload;\n\tlong ret;\n\tret = -EINVAL;\n\tif (plen > PAGE_SIZE)\n\t\tgoto error;\n\tpayload = NULL;\n\tif (_payload) {\n\t\tret = -ENOMEM;\n\t\tpayload = kmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error;\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error2;\n\t}\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\tret = key_update(key_ref, payload, plen);\n\tkey_ref_put(key_ref);\nerror2:\n\tkfree(payload);\nerror:\n\treturn ret;\n}", "target": 1}
{"code": "GF_Err pasp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_PixelAspectRatioBox *ptr = (GF_PixelAspectRatioBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->hSpacing);\n\tgf_bs_write_u32(bs, ptr->vSpacing);\n\treturn GF_OK;\n}", "target": 0}
{"code": "static INLINE SIZE_T ntlm_av_pair_get_len(const NTLM_AV_PAIR* pAvPair)\n{\n\tUINT16 AvLen;\n\tData_Read_UINT16(&pAvPair->AvLen, AvLen);\n\treturn AvLen;\n}", "target": 1}
{"code": "GF_Box *emsg_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_EventMessageBox, GF_ISOM_BOX_TYPE_EMSG);\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "  void operator()(const CPUDevice& d, typename TTypes<T, 4>::ConstTensor input,\n                  typename TTypes<T, 3>::ConstTensor filter,\n                  typename TTypes<T, 4>::ConstTensor out_backprop,\n                  int stride_rows, int stride_cols, int rate_rows,\n                  int rate_cols, int pad_top, int pad_left,\n                  typename TTypes<T, 4>::Tensor in_backprop) {\n    const int batch = input.dimension(0);\n    const int input_rows = input.dimension(1);\n    const int input_cols = input.dimension(2);\n    const int depth = input.dimension(3);\n    const int filter_rows = filter.dimension(0);\n    const int filter_cols = filter.dimension(1);\n    const int output_rows = out_backprop.dimension(1);\n    const int output_cols = out_backprop.dimension(2);\n    in_backprop.setZero();\n    for (int b = 0; b < batch; ++b) {\n      for (int h_out = 0; h_out < output_rows; ++h_out) {\n        int h_beg = h_out * stride_rows - pad_top;\n        for (int w_out = 0; w_out < output_cols; ++w_out) {\n          int w_beg = w_out * stride_cols - pad_left;\n          for (int d = 0; d < depth; ++d) {\n            T cur_val = Eigen::NumTraits<T>::lowest();\n            int h_in_max = (h_beg < 0) ? 0 : h_beg;\n            int w_in_max = (w_beg < 0) ? 0 : w_beg;\n            for (int h = 0; h < filter_rows; ++h) {\n              const int h_in = h_beg + h * rate_rows;\n              if (h_in >= 0 && h_in < input_rows) {\n                for (int w = 0; w < filter_cols; ++w) {\n                  const int w_in = w_beg + w * rate_cols;\n                  if (w_in >= 0 && w_in < input_cols) {\n                    const T val = input(b, h_in, w_in, d) + filter(h, w, d);\n                    if (val > cur_val) {\n                      cur_val = val;\n                      h_in_max = h_in;\n                      w_in_max = w_in;\n                    }\n                  }\n                }\n              }\n            }\n            in_backprop(b, h_in_max, w_in_max, d) +=\n                out_backprop(b, h_out, w_out, d);\n          }\n        }\n      }\n    }\n  }", "target": 1}
{"code": "int epo_copy_color(gx_device *dev, const byte *data, int data_x, int raster, gx_bitmap_id id,\\\n    int x, int y, int width, int height)\n{\n    int code = epo_handle_erase_page(dev);\n    if (code != 0)\n        return code;\n    return dev_proc(dev, copy_color)(dev, data, data_x, raster, id, x, y, width, height);\n}", "target": 0}
{"code": "CoinSpend::CoinSpend(const Params* p, const PrivateCoin& coin,\n                     Accumulator& a, const AccumulatorWitness& witness, const SpendMetaData& m):\n\tparams(p),\n\tdenomination(coin.getPublicCoin().getDenomination()),\n\tcoinSerialNumber((coin.getSerialNumber())),\n\taccumulatorPoK(&p->accumulatorParams),\n\tserialNumberSoK(p),\n\tcommitmentPoK(&p->serialNumberSoKCommitmentGroup, &p->accumulatorParams.accumulatorPoKCommitmentGroup) {\n\tif (!(witness.VerifyWitness(a, coin.getPublicCoin()))) {\n\t\tthrow ZerocoinException(\"Accumulator witness does not verify\");\n\t}\n\tif (!HasValidSerial()) {\n\t\tthrow ZerocoinException(\"Invalid serial # range\");\n\t}\n\tconst Commitment fullCommitmentToCoinUnderSerialParams(&p->serialNumberSoKCommitmentGroup, coin.getPublicCoin().getValue());\n\tthis->serialCommitmentToCoinValue = fullCommitmentToCoinUnderSerialParams.getCommitmentValue();\n\tconst Commitment fullCommitmentToCoinUnderAccParams(&p->accumulatorParams.accumulatorPoKCommitmentGroup, coin.getPublicCoin().getValue());\n\tthis->accCommitmentToCoinValue = fullCommitmentToCoinUnderAccParams.getCommitmentValue();\n\tthis->commitmentPoK = CommitmentProofOfKnowledge(&p->serialNumberSoKCommitmentGroup, &p->accumulatorParams.accumulatorPoKCommitmentGroup, fullCommitmentToCoinUnderSerialParams, fullCommitmentToCoinUnderAccParams);\n\tthis->accumulatorPoK = AccumulatorProofOfKnowledge(&p->accumulatorParams, fullCommitmentToCoinUnderAccParams, witness, a);\n\tthis->serialNumberSoK = SerialNumberSignatureOfKnowledge(p, coin, fullCommitmentToCoinUnderSerialParams, signatureHash(m));\n}", "target": 0}
{"code": "static void ReversePoints(PointInfo *points,const size_t number_points)\n{\n  PointInfo\n    point;\n  ssize_t\n    i;\n  for (i=0; i < (ssize_t) (number_points >> 1); i++)\n  {\n    point=points[i];\n    points[i]=points[number_points-(i+1)];\n    points[number_points-(i+1)]=point;\n  }\n}", "target": 0}
{"code": "static void setGenericValues(EctEnhancedCT *ct)\n{\n    if (!ct)\n        return;\n    OFCHECK(ct->getPatient().setPatientName(\"Bond^James\").good());\n    OFCHECK(ct->getPatient().setPatientID(\"007\").good());\n    OFCHECK(ct->getPatient().setPatientBirthDate(\"19771007\").good());\n    OFCHECK(ct->getStudy().setStudyDate(\"20190801\").good());\n    OFCHECK(ct->getStudy().setStudyTime(\"120000\").good());\n    OFCHECK(ct->getStudy().setStudyID(\"1\").good());\n    OFCHECK(ct->getPatientStudy().setPatientAge(\"040Y\").good());\n    OFCHECK(ct->getSeries().setSeriesDescription(\"Test Description\").good());\n    OFCHECK(ct->getSeries().setSeriesNumber(\"1\").good());\n    OFCHECK(ct->getSeries().setPatientPosition(\"HFS\").good());\n    OFCHECK(ct->getStudy().setStudyInstanceUID(\"1.2.276.0.7230010.3.1.2.8323329.14863.1565940357.864811\").good());\n    OFCHECK(ct->getFrameOfReference().setFrameOfReferenceUID(\"2.25.30853397773651184949181049330553108086\").good());\n    OFCHECK(ct->getSeries().setSeriesInstanceUID(\"1.2.276.0.7230010.3.1.3.8323329.14863.1565940357.864812\").good());\n    OFCHECK(ct->getSOPCommon().setSOPInstanceUID(\"1.2.276.0.7230010.3.1.4.8323329.14863.1565940357.864813\").good());\n    OFCHECK(ct->getIODMultiFrameFGModule().setContentTime(\"092557\").good());\n    OFCHECK(ct->getIODMultiFrameFGModule().setContentDate(\"20190816\").good());\n}", "target": 0}
{"code": "static __u8 *nci_extract_rf_params_nfca_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfca_poll *nfca_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfca_poll->sens_res = __le16_to_cpu(*((__u16 *)data));\n\tdata += 2;\n\tnfca_poll->nfcid1_len = *data++;\n\tpr_debug(\"sens_res 0x%x, nfcid1_len %d\\n\",\n\t\t nfca_poll->sens_res, nfca_poll->nfcid1_len);\n\tmemcpy(nfca_poll->nfcid1, data, nfca_poll->nfcid1_len);\n\tdata += nfca_poll->nfcid1_len;\n\tnfca_poll->sel_res_len = *data++;\n\tif (nfca_poll->sel_res_len != 0)\n\t\tnfca_poll->sel_res = *data++;\n\tpr_debug(\"sel_res_len %d, sel_res 0x%x\\n\",\n\t\t nfca_poll->sel_res_len,\n\t\t nfca_poll->sel_res);\n\treturn data;\n}", "target": 1}
{"code": "Status ImmutableExecutorState::BuildControlFlowInfo(const Graph* g,\n                                                    ControlFlowInfo* cf_info) {\n  const int num_nodes = g->num_node_ids();\n  cf_info->frame_names.resize(num_nodes);\n  std::vector<Node*> parent_nodes;\n  parent_nodes.resize(num_nodes);\n  std::vector<bool> visited;\n  visited.resize(num_nodes);\n  string frame_name;\n  std::deque<Node*> ready;\n  for (Node* n : g->nodes()) {\n    if (n->in_edges().empty()) {\n      visited[n->id()] = true;\n      cf_info->unique_frame_names.insert(frame_name);\n      ready.push_back(n);\n    }\n  }\n  while (!ready.empty()) {\n    Node* curr_node = ready.front();\n    int curr_id = curr_node->id();\n    ready.pop_front();\n    Node* parent = nullptr;\n    if (IsEnter(curr_node)) {\n      TF_RETURN_IF_ERROR(\n          GetNodeAttr(curr_node->attrs(), \"frame_name\", &frame_name));\n      parent = curr_node;\n    } else if (IsExit(curr_node)) {\n      parent = parent_nodes[curr_id];\n      if (!parent) {\n        return errors::InvalidArgument(\n            \"Invalid Exit op: Cannot find a corresponding Enter op.\");\n      }\n      frame_name = cf_info->frame_names[parent->id()];\n      parent = parent_nodes[parent->id()];\n    } else {\n      parent = parent_nodes[curr_id];\n      frame_name = cf_info->frame_names[curr_id];\n    }\n    for (const Edge* out_edge : curr_node->out_edges()) {\n      Node* out = out_edge->dst();\n      if (IsSink(out)) continue;\n      const int out_id = out->id();\n      bool is_visited = visited[out_id];\n      if (!is_visited) {\n        ready.push_back(out);\n        visited[out_id] = true;\n        cf_info->frame_names[out_id] = frame_name;\n        parent_nodes[out_id] = parent;\n        cf_info->unique_frame_names.insert(frame_name);\n      }\n    }\n  }\n  return Status::OK();\n}", "target": 0}
{"code": "AsfVideo::HeaderReader::HeaderReader(const BasicIo::UniquePtr& io) : IdBuf_(GUID) {\n  if (io->size() >= io->tell() + GUID + QWORD) {\n    IdBuf_ = io->read(GUID);\n    size_ = readQWORDTag(io);\n    if (size_ >= GUID + QWORD)\n      remaining_size_ = size_ - GUID - QWORD;\n  }\n}", "target": 1}
{"code": "static void validate_dex_header(const dex_header* dh,\n                                size_t dexsize,\n                                int support_dex_version) {\n  bool supported = false;\n  switch (support_dex_version) {\n  case 38:\n    supported = supported ||\n                !memcmp(dh->magic, DEX_HEADER_DEXMAGIC_V38, sizeof(dh->magic));\n    FALLTHROUGH_INTENDED; \n  case 37:\n    supported = supported ||\n                !memcmp(dh->magic, DEX_HEADER_DEXMAGIC_V37, sizeof(dh->magic));\n    FALLTHROUGH_INTENDED; \n  case 35:\n    supported = supported ||\n                !memcmp(dh->magic, DEX_HEADER_DEXMAGIC_V35, sizeof(dh->magic));\n    break;\n  default:\n    not_reached_log(\"Unrecognized support_dex_version %d\\n\",\n                    support_dex_version);\n  }\n  always_assert_log(supported, \"Bad dex magic %s for support_dex_version %d\\n\",\n                    dh->magic, support_dex_version);\n  always_assert_log(\n      dh->file_size == dexsize,\n      \"Reported size in header (%zu) does not match file size (%u)\\n\",\n      dexsize,\n      dh->file_size);\n  auto off = (uint64_t)dh->class_defs_off;\n  auto limit = off + dh->class_defs_size * sizeof(dex_class_def);\n  always_assert_log(off < dexsize, \"class_defs_off out of range\");\n  always_assert_log(limit <= dexsize, \"invalid class_defs_size\");\n}", "target": 1}
{"code": "static inline int page_is_allowed(unsigned long pfn)\n{\n\treturn devmem_is_allowed(pfn);\n}", "target": 0}
{"code": "static int sco_sock_bind(struct socket *sock, struct sockaddr *addr,\n\t\t\t int addr_len)\n{\n\tstruct sockaddr_sco *sa = (struct sockaddr_sco *) addr;\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\tBT_DBG(\"sk %p %pMR\", sk, &sa->sco_bdaddr);\n\tif (!addr || addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\tif (addr_len < sizeof(struct sockaddr_sco))\n\t\treturn -EINVAL;\n\tlock_sock(sk);\n\tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\tbacpy(&sco_pi(sk)->src, &sa->sco_bdaddr);\n\tsk->sk_state = BT_BOUND;\ndone:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "lexer_check_arrow_param (parser_context_t *context_p) \n{\n  JERRY_ASSERT (context_p->token.flags & LEXER_NO_SKIP_SPACES);\n  if (context_p->source_p >= context_p->source_end_p)\n  {\n    return false;\n  }\n  if (context_p->source_p[0] == LIT_CHAR_COMMA)\n  {\n    return true;\n  }\n  if (context_p->source_p[0] != LIT_CHAR_EQUALS)\n  {\n    return false;\n  }\n  return (context_p->source_p + 1 >= context_p->source_end_p || context_p->source_p[1] != LIT_CHAR_EQUALS);\n} ", "target": 0}
{"code": "static TEE_Result do_allocate_keypair(struct dsa_keypair *key, size_t l_bits,\n\t\t\t\t      size_t n_bits)\n{\n\tDSA_TRACE(\"DSA allocate Keypair of L=%zu bits and N=%zu bits\", l_bits,\n\t\t  n_bits);\n\tmemset(key, 0, sizeof(*key));\n\tkey->g = crypto_bignum_allocate(l_bits);\n\tif (!key->g)\n\t\tgoto err;\n\tkey->p = crypto_bignum_allocate(l_bits);\n\tif (!key->p)\n\t\tgoto err;\n\tkey->q = crypto_bignum_allocate(n_bits);\n\tif (!key->q)\n\t\tgoto err;\n\tkey->x = crypto_bignum_allocate(n_bits);\n\tif (!key->x)\n\t\tgoto err;\n\tkey->y = crypto_bignum_allocate(l_bits);\n\tif (!key->y)\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tDSA_TRACE(\"Allocation error\");\n\tcrypto_bignum_free(key->g);\n\tcrypto_bignum_free(key->p);\n\tcrypto_bignum_free(key->q);\n\tcrypto_bignum_free(key->x);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "static int DefragBsdPeose173Ipv4Test(void)\n{\n    DefragInit();\n    default_policy = DEFRAG_POLICY_BSD;\n    Packet *packets[5];\n    packets[0] = BuildIpv4TestPacketWithContent(\n            IPPROTO_ICMP, 189, 16 >> 3, 1, (uint8_t *)\"AABBCCDDAABBDDCC\", 16);\n    packets[1] =\n            BuildIpv4TestPacketWithContent(IPPROTO_ICMP, 189, 40 >> 3, 1, (uint8_t *)\"AACCBBDD\", 8);\n    packets[2] = BuildIpv4TestPacketWithContent(\n            IPPROTO_ICMP, 189, 8 >> 3, 1, (uint8_t *)\"AACCDDBBAADDBBCC\", 16);\n    packets[3] = BuildIpv4TestPacketWithContent(IPPROTO_ICMP, 189, 0, 1, (uint8_t *)\"ZZZZZZZZ\", 8);\n    packets[4] =\n            BuildIpv4TestPacketWithContent(IPPROTO_ICMP, 189, 48 >> 3, 0, (uint8_t *)\"DDCCBBAA\", 8);\n    Packet *r = Defrag(NULL, NULL, packets[0]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[1]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[2]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[3]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[4]);\n    FAIL_IF_NOT_NULL(r);\n#if 0\n    PrintRawDataFp(stdout, GET_PKT_DATA(r) + 20, GET_PKT_LEN(r) - 20);\n#endif\n    for (int i = 0; i < 5; i++) {\n        SCFree(packets[i]);\n    }\n    DefragDestroy();\n    PASS;\n}", "target": 0}
{"code": "flatpak_bwrap_take_arg (FlatpakBwrap *bwrap, char *arg)\n{\n  g_ptr_array_add (bwrap->argv, arg);\n}", "target": 0}
{"code": "bool CSSStyleSheet::isLoading()\n{\n    unsigned len = length();\n    for (unsigned i = 0; i < len; ++i) {\n        StyleBase* rule = item(i);\n        if (rule->isImportRule() && static_cast<CSSImportRule*>(rule)->isLoading())\n            return true;\n    }\n    return false;\n}", "target": 0}
{"code": "static Jsi_RC jsi_ArrayFillCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) \n        return Jsi_LogError(\"expected array object\");\n    Jsi_RC rc = JSI_OK;\n    int istart = 0, iend, n, nsiz;\n    Jsi_Number nstart = 0, nend = 0; \n    Jsi_Value *value = Jsi_ValueArrayIndex(interp, args, 0),\n        *start = Jsi_ValueArrayIndex(interp, args, 1),\n        *end = Jsi_ValueArrayIndex(interp, args, 2);\n    Jsi_Obj *obj = _this->d.obj;\n    n = Jsi_ObjGetLength(interp, obj);\n    if (start && Jsi_GetNumberFromValue(interp, start, &nstart) == JSI_OK) {\n        istart = (int)nstart;\n        if (istart > n)\n            goto bail;\n        if (istart < 0)\n            istart = (n+istart);\n        if (istart<0)\n            goto bail;\n    }\n    if (n == 0) {\n        goto bail;\n    }\n    iend = n-1;\n    if (end && Jsi_GetNumberFromValue(interp,end, &nend) == JSI_OK) {\n        iend = (int) nend;\n        if (iend >= n)\n            iend = n;\n        if (iend < 0)\n            iend = (n+iend);\n        if (iend<0)\n            goto bail;\n    }\n    nsiz = iend-istart+1;\n    if (nsiz<=0)\n        goto bail;\n    int i;\n    for (i = istart; i <= iend; i++)\n    {\n        if (obj->arr[i])\n            Jsi_ValueCopy(interp, obj->arr[i], value);\n        else\n            obj->arr[i] = Jsi_ValueDup(interp, value);\n    }\nbail:\n    if (_this != *ret) {\n        Jsi_ValueMove(interp, *ret, _this);\n    }\n    return rc;\n}", "target": 1}
{"code": "void CleanupOutput(char *str)\n{\n    char *s, *t;\n    int period = 0;\n    s = t = str;\n    while ( *s && *s != '}' ) {\n        if ( *s == '\\n' ) *s = ' ';\n        if ( ( *s == ' ' || *s == '\\n' ) && ( s[1] == ' ' || s[1] == '\\n' ) ) s++;\n        else *t++ = *s++;\n    }\n    while ( *s ) *t++ = *s++;\n    *t = 0;\n    s = t = str;\n    while ( *s ) {\n        if ( *s == '.' ) { period = 1; *t++ = *s++; }\n        else if ( *s == '-' && s[1] == '0' && s[2] == ' ' ) { s++; }\n        else if ( *s <= '9' && *s >= '0' ) { *t++ = *s++; }\n        else if ( *s == '\\n' && ( t > str && t[-1] == '\\n' ) ) { s++; }\n        else if ( period ) {\n            while ( t > str && t[-1] == '0' ) t--;\n            if ( t > str && t[-1] == '.' ) t--;\n            while ( *s == ' ' && s[1] == ' ' ) s++;\n            period = 0; *t++ = *s++;\n        }\n        else if ( *s == ' ' && s[1] == ' ' ) s++;\n        else {\n            period = 0; *t++ = *s++;\n        }\n    }\n    *t = 0;\n    s = t = str;\n    while ( *s ) {\n        if ( *s == '-' && s[1] == '0' && s[2] == ' ' ) { s++; }\n        else *t++ = *s++;\n    }\n    *t = 0;\n}", "target": 1}
{"code": "void HTMLMediaElement::AudioTracksTimerFired(TimerBase*) {\n  Vector<WebMediaPlayer::TrackId> enabled_track_ids;\n  for (unsigned i = 0; i < audioTracks().length(); ++i) {\n    AudioTrack* track = audioTracks().AnonymousIndexedGetter(i);\n    if (track->enabled())\n      enabled_track_ids.push_back(track->id());\n  }\n  GetWebMediaPlayer()->EnabledAudioTracksChanged(enabled_track_ids);\n}", "target": 0}
{"code": "_dl_dst_substitute (struct link_map *l, const char *name, char *result,\n\t\t    int is_path)\n{\n  char *last_elem, *wp;\n  last_elem = wp = result;\n  do\n    {\n      if (*name == '$')\n\t{\n\t  const char *repl;\n\t  size_t len;\n\t  if ((((strncmp (&name[1], \"ORIGIN\", 6) == 0 && (len = 7) != 0)\n\t\t|| (strncmp (&name[1], \"PLATFORM\", 8) == 0 && (len = 9) != 0))\n\t       && (name[len] == '\\0' || name[len] == '/'\n\t\t   || (is_path && name[len] == ':')))\n\t      || (name[1] == '{'\n\t\t  && ((strncmp (&name[2], \"ORIGIN}\", 7) == 0 && (len = 9) != 0)\n\t\t      || (strncmp (&name[2], \"PLATFORM}\", 9) == 0\n\t\t\t  && (len = 11) != 0))))\n\t    {\n\t      repl = ((len == 7 || name[2] == 'O')\n\t\t      ? (__libc_enable_secure ? NULL : l->l_origin)\n\t\t      : _dl_platform);\n\t      if (repl != NULL && repl != (const char *) -1)\n\t\t{\n\t\t  wp = __stpcpy (wp, repl);\n\t\t  name += len;\n\t\t}\n\t      else\n\t\t{\n\t\t  wp = last_elem;\n\t\t  name += len;\n\t\t  while (*name != '\\0' && (!is_path || *name != ':'))\n\t\t    ++name;\n\t\t}\n\t    }\n\t  else\n\t    *wp++ = *name++;\n\t}\n      else if (is_path && *name == ':')\n\t{\n\t  *wp++ = *name++;\n\t  last_elem = wp;\n\t}\n      else\n\t*wp++ = *name++;\n    }\n  while (*name != '\\0');\n  *wp = '\\0';\n  return result;\n}", "target": 1}
{"code": "void __meminit setup_zone_pageset(struct zone *zone)\n{\n\tint cpu;\n\tzone->pageset = alloc_percpu(struct per_cpu_pageset);\n\tfor_each_possible_cpu(cpu)\n\t\tzone_pageset_init(zone, cpu);\n}", "target": 0}
{"code": "xfs_attr_rmtval_get(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_bmbt_irec\tmap[ATTR_RMTVALUE_MAPSIZE];\n\tstruct xfs_mount\t*mp = args->dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\txfs_dablk_t\t\tlblkno = args->rmtblkno;\n\t__uint8_t\t\t*dst = args->value;\n\tint\t\t\tvaluelen = args->valuelen;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\tint\t\t\tblkcnt = args->rmtblkcnt;\n\tint\t\t\ti;\n\tint\t\t\toffset = 0;\n\ttrace_xfs_attr_rmtval_get(args);\n\tASSERT(!(args->flags & ATTR_KERNOVAL));\n\twhile (valuelen > 0) {\n\t\tnmap = ATTR_RMTVALUE_MAPSIZE;\n\t\terror = xfs_bmapi_read(args->dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, map, &nmap,\n\t\t\t\t       XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tASSERT(nmap >= 1);\n\t\tfor (i = 0; (i < nmap) && (valuelen > 0); i++) {\n\t\t\txfs_daddr_t\tdblkno;\n\t\t\tint\t\tdblkcnt;\n\t\t\tASSERT((map[i].br_startblock != DELAYSTARTBLOCK) &&\n\t\t\t       (map[i].br_startblock != HOLESTARTBLOCK));\n\t\t\tdblkno = XFS_FSB_TO_DADDR(mp, map[i].br_startblock);\n\t\t\tdblkcnt = XFS_FSB_TO_BB(mp, map[i].br_blockcount);\n\t\t\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp,\n\t\t\t\t\t\t   dblkno, dblkcnt, 0, &bp,\n\t\t\t\t\t\t   &xfs_attr3_rmt_buf_ops);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\terror = xfs_attr_rmtval_copyout(mp, bp, args->dp->i_ino,\n\t\t\t\t\t\t\t&offset, &valuelen,\n\t\t\t\t\t\t\t&dst);\n\t\t\txfs_buf_relse(bp);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tlblkno += map[i].br_blockcount;\n\t\t\tblkcnt -= map[i].br_blockcount;\n\t\t}\n\t}\n\tASSERT(valuelen == 0);\n\treturn 0;\n}", "target": 1}
{"code": "void traverse_commit_list(struct rev_info *revs,\n\t\t\t  show_commit_fn show_commit,\n\t\t\t  show_object_fn show_object,\n\t\t\t  void *data)\n{\n\tint i;\n\tstruct commit *commit;\n\tstruct strbuf base;\n\tstrbuf_init(&base, PATH_MAX);\n\twhile ((commit = get_revision(revs)) != NULL) {\n\t\tif (commit->tree)\n\t\t\tadd_pending_tree(revs, commit->tree);\n\t\tshow_commit(commit, data);\n\t}\n\tfor (i = 0; i < revs->pending.nr; i++) {\n\t\tstruct object_array_entry *pending = revs->pending.objects + i;\n\t\tstruct object *obj = pending->item;\n\t\tconst char *name = pending->name;\n\t\tconst char *path = pending->path;\n\t\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\t\tcontinue;\n\t\tif (obj->type == OBJ_TAG) {\n\t\t\tobj->flags |= SEEN;\n\t\t\tshow_object(obj, NULL, name, data);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!path)\n\t\t\tpath = \"\";\n\t\tif (obj->type == OBJ_TREE) {\n\t\t\tprocess_tree(revs, (struct tree *)obj, show_object,\n\t\t\t\t     &base, path, data);\n\t\t\tcontinue;\n\t\t}\n\t\tif (obj->type == OBJ_BLOB) {\n\t\t\tprocess_blob(revs, (struct blob *)obj, show_object,\n\t\t\t\t     NULL, path, data);\n\t\t\tcontinue;\n\t\t}\n\t\tdie(\"unknown pending object %s (%s)\",\n\t\t    oid_to_hex(&obj->oid), name);\n\t}\n\tobject_array_clear(&revs->pending);\n\tstrbuf_release(&base);\n}", "target": 1}
{"code": "int evm_update_evmxattr(struct dentry *dentry, const char *xattr_name,\n\t\t\tconst char *xattr_value, size_t xattr_value_len)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct evm_ima_xattr_data xattr_data;\n\tint rc = 0;\n\trc = evm_calc_hmac(dentry, xattr_name, xattr_value,\n\t\t\t   xattr_value_len, xattr_data.digest);\n\tif (rc == 0) {\n\t\txattr_data.type = EVM_XATTR_HMAC;\n\t\trc = __vfs_setxattr_noperm(dentry, XATTR_NAME_EVM,\n\t\t\t\t\t   &xattr_data,\n\t\t\t\t\t   sizeof(xattr_data), 0);\n\t}\n\telse if (rc == -ENODATA)\n\t\trc = inode->i_op->removexattr(dentry, XATTR_NAME_EVM);\n\treturn rc;\n}", "target": 1}
{"code": "rpl_print(netdissect_options *ndo,\n          const struct icmp6_hdr *hdr,\n          const u_char *bp, u_int length)\n{\n        int secured = hdr->icmp6_code & 0x80;\n        int basecode= hdr->icmp6_code & 0x7f;\n        if(secured) {\n                ND_PRINT((ndo, \", (SEC) [worktodo]\"));\n                return;\n        } else {\n                ND_PRINT((ndo, \", (CLR)\"));\n        }\n        switch(basecode) {\n        case ND_RPL_DAG_IS:\n                ND_PRINT((ndo, \"DODAG Information Solicitation\"));\n                if(ndo->ndo_vflag) {\n                }\n                break;\n        case ND_RPL_DAG_IO:\n                ND_PRINT((ndo, \"DODAG Information Object\"));\n                if(ndo->ndo_vflag) {\n                        rpl_dio_print(ndo, bp, length);\n                }\n                break;\n        case ND_RPL_DAO:\n                ND_PRINT((ndo, \"Destination Advertisement Object\"));\n                if(ndo->ndo_vflag) {\n                        rpl_dao_print(ndo, bp, length);\n                }\n                break;\n        case ND_RPL_DAO_ACK:\n                ND_PRINT((ndo, \"Destination Advertisement Object Ack\"));\n                if(ndo->ndo_vflag) {\n                        rpl_daoack_print(ndo, bp, length);\n                }\n                break;\n        default:\n                ND_PRINT((ndo, \"RPL message, unknown code %u\",hdr->icmp6_code));\n                break;\n        }\n\treturn;\n#if 0\ntrunc:\n\tND_PRINT((ndo,\" [|truncated]\"));\n\treturn;\n#endif\n}", "target": 1}
{"code": "static int sh_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\n\tut8 op_MSB,op_LSB;\n\tint ret;\n\tif (!data)\n\t\treturn 0;\n\tmemset (op, '\\0', sizeof (RAnalOp));\n\top->addr = addr;\n\top->type = R_ANAL_OP_TYPE_UNK;\n\top->jump = op->fail = -1;\n\top->ptr = op->val = -1;\n\top->size = 2;\n\top_MSB = anal->big_endian? data[0]: data[1];\n\top_LSB = anal->big_endian? data[1]: data[0];\n\tret =  first_nibble_decode[(op_MSB>>4) & 0x0F](anal, op, (ut16)(op_MSB<<8 | op_LSB));\n\treturn ret;\n}", "target": 1}
{"code": "static int cms_copy_content(BIO *out, BIO *in, unsigned int flags)\n\t{\n\tunsigned char buf[4096];\n\tint r = 0, i;\n\tBIO *tmpout = NULL;\n\tif (out == NULL)\n\t\ttmpout = BIO_new(BIO_s_null());\n\telse if (flags & CMS_TEXT)\n\t\t{\n\t\ttmpout = BIO_new(BIO_s_mem());\n\t\tBIO_set_mem_eof_return(tmpout, 0);\n\t\t}\n\telse\n\t\ttmpout = out;\n\tif(!tmpout)\n\t\t{\n\t\tCMSerr(CMS_F_CMS_COPY_CONTENT,ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t\t}\n\tfor (;;)\n\t{\n\t\ti=BIO_read(in,buf,sizeof(buf));\n\t\tif (i <= 0)\n\t\t\t{\n\t\t\tif (BIO_method_type(in) == BIO_TYPE_CIPHER)\n\t\t\t\t{\n\t\t\t\tif (!BIO_get_cipher_status(in))\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\tif (i < 0)\n\t\t\t\tgoto err;\n\t\t\tbreak;\n\t\t\t}\n\t\tif (tmpout && (BIO_write(tmpout, buf, i) != i))\n\t\t\tgoto err;\n\t}\n\tif(flags & CMS_TEXT)\n\t\t{\n\t\tif(!SMIME_text(tmpout, out))\n\t\t\t{\n\t\t\tCMSerr(CMS_F_CMS_COPY_CONTENT,CMS_R_SMIME_TEXT_ERROR);\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\tr = 1;\n\terr:\n\tif (tmpout && (tmpout != out))\n\t\tBIO_free(tmpout);\n\treturn r;\n\t}", "target": 1}
{"code": "static int swevent_hlist_get_cpu(struct perf_event *event, int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\tint err = 0;\n\tmutex_lock(&swhash->hlist_mutex);\n\tif (!swevent_hlist_deref(swhash) && cpu_online(cpu)) {\n\t\tstruct swevent_hlist *hlist;\n\t\thlist = kzalloc(sizeof(*hlist), GFP_KERNEL);\n\t\tif (!hlist) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\t\trcu_assign_pointer(swhash->swevent_hlist, hlist);\n\t}\n\tswhash->hlist_refcount++;\nexit:\n\tmutex_unlock(&swhash->hlist_mutex);\n\treturn err;\n}", "target": 1}
{"code": "void main_init() { \n#ifdef USE_SYSTEMD\n    int i;\n    systemd_fds=sd_listen_fds(1);\n    if(systemd_fds<0)\n        fatal(\"systemd initialization failed\");\n    listen_fds_start=SD_LISTEN_FDS_START;\n    for(i=0; i<systemd_fds; ++i)\n        set_nonblock(listen_fds_start+i, 1);\n#else\n    systemd_fds=0; \n    listen_fds_start=3; \n#endif\n    if(ssl_init()) \n        fatal(\"TLS initialization failed\");\n    if(sthreads_init()) \n        fatal(\"Threads initialization failed\");\n    options_defaults();\n    options_apply();\n#ifndef USE_FORK\n    get_limits(); \n#endif\n    fds=s_poll_alloc();\n    if(pipe_init(signal_pipe, \"signal_pipe\"))\n        fatal(\"Signal pipe initialization failed: \"\n            \"check your personal firewall\");\n    if(pipe_init(terminate_pipe, \"terminate_pipe\"))\n        fatal(\"Terminate pipe initialization failed: \"\n            \"check your personal firewall\");\n    stunnel_info(LOG_NOTICE);\n    if(systemd_fds>0)\n        s_log(LOG_INFO, \"Systemd socket activation: %d descriptors received\",\n            systemd_fds);\n}", "target": 1}
{"code": "m_hour(union DateData *x)\n{\n    if (simple_dat_p(x))\n\treturn 0;\n    else {\n\tget_c_time(x);\n#ifndef USE_PACK\n\treturn x->c.hour;\n#else\n\treturn EX_HOUR(x->c.pc);\n#endif\n    }\n}", "target": 0}
{"code": "ldbm_txn_ruv_modify_context( Slapi_PBlock *pb, modify_context *mc )\n{\n    char *uniqueid = NULL;\n    backend *be;\n    Slapi_Mods *smods = NULL;\n    struct backentry *bentry;\n    entry_address bentry_addr;\n    IFP fn = NULL;\n    int rc = 0;\n    back_txn txn = {NULL};\n    slapi_pblock_get(pb, SLAPI_TXN_RUV_MODS_FN, (void *)&fn);\n    slapi_pblock_get(pb, SLAPI_TXN, &txn.back_txn_txn);\n    if (NULL == fn) {\n        return (0);\n    }\n    rc = (*fn)(pb, &uniqueid, &smods);\n    if (1 != rc || NULL == smods || NULL == uniqueid) {\n        return (rc);\n    }\n    slapi_pblock_get( pb, SLAPI_BACKEND, &be);\n    bentry_addr.sdn = NULL;\n    bentry_addr.udn = NULL;\n    bentry_addr.uniqueid = uniqueid;\n    bentry = find_entry2modify_only( pb, be, &bentry_addr, &txn );\n    if (NULL == bentry) {\n        LDAPDebug( LDAP_DEBUG_ANY, \"Error: ldbm_txn_ruv_modify_context failed to retrieve and lock RUV entry\\n\",\n            0, 0, 0 );\n        rc = -1;\n        goto done;\n    }\n    modify_init( mc, bentry );\n    if (modify_apply_mods_ignore_error( mc, smods, LDAP_TYPE_OR_VALUE_EXISTS )) {\n        LDAPDebug( LDAP_DEBUG_ANY, \"Error: ldbm_txn_ruv_modify_context failed to apply updates to RUV entry\\n\",\n            0, 0, 0 );\n        rc = -1;\n        modify_term( mc, be );\n    }\ndone:\n    slapi_ch_free_string( &uniqueid );\n    return (rc);\n}", "target": 1}
{"code": "static void release_posix_timer(struct k_itimer *tmr, int it_id_set)\n{\n\tif (it_id_set) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&hash_lock, flags);\n\t\thlist_del_rcu(&tmr->t_hash);\n\t\tspin_unlock_irqrestore(&hash_lock, flags);\n\t}\n\tput_pid(tmr->it_pid);\n\tsigqueue_free(tmr->sigq);\n\tcall_rcu(&tmr->it.rcu, k_itimer_rcu_free);\n}", "target": 0}
{"code": "static bool regsafe(struct bpf_reg_state *rold, struct bpf_reg_state *rcur,\n\t\t    struct idpair *idmap)\n{\n\tif (!(rold->live & REG_LIVE_READ))\n\t\treturn true;\n\tif (memcmp(rold, rcur, offsetof(struct bpf_reg_state, live)) == 0)\n\t\treturn true;\n\tif (rold->type == NOT_INIT)\n\t\treturn true;\n\tif (rcur->type == NOT_INIT)\n\t\treturn false;\n\tswitch (rold->type) {\n\tcase SCALAR_VALUE:\n\t\tif (rcur->type == SCALAR_VALUE) {\n\t\t\treturn range_within(rold, rcur) &&\n\t\t\t       tnum_in(rold->var_off, rcur->var_off);\n\t\t} else {\n\t\t\treturn rold->umin_value == 0 &&\n\t\t\t       rold->umax_value == U64_MAX &&\n\t\t\t       rold->smin_value == S64_MIN &&\n\t\t\t       rold->smax_value == S64_MAX &&\n\t\t\t       tnum_is_unknown(rold->var_off);\n\t\t}\n\tcase PTR_TO_MAP_VALUE:\n\t\treturn memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)) == 0 &&\n\t\t       range_within(rold, rcur) &&\n\t\t       tnum_in(rold->var_off, rcur->var_off);\n\tcase PTR_TO_MAP_VALUE_OR_NULL:\n\t\tif (rcur->type != PTR_TO_MAP_VALUE_OR_NULL)\n\t\t\treturn false;\n\t\tif (memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)))\n\t\t\treturn false;\n\t\treturn check_ids(rold->id, rcur->id, idmap);\n\tcase PTR_TO_PACKET_META:\n\tcase PTR_TO_PACKET:\n\t\tif (rcur->type != rold->type)\n\t\t\treturn false;\n\t\tif (rold->range > rcur->range)\n\t\t\treturn false;\n\t\tif (rold->off != rcur->off)\n\t\t\treturn false;\n\t\tif (rold->id && !check_ids(rold->id, rcur->id, idmap))\n\t\t\treturn false;\n\t\treturn range_within(rold, rcur) &&\n\t\t       tnum_in(rold->var_off, rcur->var_off);\n\tcase PTR_TO_CTX:\n\tcase CONST_PTR_TO_MAP:\n\tcase PTR_TO_STACK:\n\tcase PTR_TO_PACKET_END:\n\tdefault:\n\t\treturn false;\n\t}\n\tWARN_ON_ONCE(1);\n\treturn false;\n}", "target": 1}
{"code": "static void command_port_read_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *command_port = urb->context;\n\tstruct whiteheat_command_private *command_info;\n\tint status = urb->status;\n\tunsigned char *data = urb->transfer_buffer;\n\tint result;\n\tcommand_info = usb_get_serial_port_data(command_port);\n\tif (!command_info) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - command_info is NULL, exiting.\\n\", __func__);\n\t\treturn;\n\t}\n\tif (status) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - nonzero urb status: %d\\n\", __func__, status);\n\t\tif (status != -ENOENT)\n\t\t\tcommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\n\t\twake_up(&command_info->wait_command);\n\t\treturn;\n\t}\n\tusb_serial_debug_data(&command_port->dev, __func__, urb->actual_length, data);\n\tif (data[0] == WHITEHEAT_CMD_COMPLETE) {\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\n\t\twake_up(&command_info->wait_command);\n\t} else if (data[0] == WHITEHEAT_CMD_FAILURE) {\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\n\t\twake_up(&command_info->wait_command);\n\t} else if (data[0] == WHITEHEAT_EVENT) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - event received\\n\", __func__);\n\t} else if (data[0] == WHITEHEAT_GET_DTR_RTS) {\n\t\tmemcpy(command_info->result_buffer, &data[1],\n\t\t\t\t\t\turb->actual_length - 1);\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\n\t\twake_up(&command_info->wait_command);\n\t} else\n\t\tdev_dbg(&urb->dev->dev, \"%s - bad reply from firmware\\n\", __func__);\n\tresult = usb_submit_urb(command_port->read_urb, GFP_ATOMIC);\n\tif (result)\n\t\tdev_dbg(&urb->dev->dev, \"%s - failed resubmitting read urb, error %d\\n\",\n\t\t\t__func__, result);\n}", "target": 1}
{"code": "static ssize_t environ_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar *page;\n\tunsigned long src = *ppos;\n\tint ret = 0;\n\tstruct mm_struct *mm = file->private_data;\n\tunsigned long env_start, env_end;\n\tif (!mm)\n\t\treturn 0;\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tret = 0;\n\tif (!atomic_inc_not_zero(&mm->mm_users))\n\t\tgoto free;\n\tdown_read(&mm->mmap_sem);\n\tenv_start = mm->env_start;\n\tenv_end = mm->env_end;\n\tup_read(&mm->mmap_sem);\n\twhile (count > 0) {\n\t\tsize_t this_len, max_len;\n\t\tint retval;\n\t\tif (src >= (env_end - env_start))\n\t\t\tbreak;\n\t\tthis_len = env_end - (env_start + src);\n\t\tmax_len = min_t(size_t, PAGE_SIZE, count);\n\t\tthis_len = min(max_len, this_len);\n\t\tretval = access_remote_vm(mm, (env_start + src),\n\t\t\tpage, this_len, 0);\n\t\tif (retval <= 0) {\n\t\t\tret = retval;\n\t\t\tbreak;\n\t\t}\n\t\tif (copy_to_user(buf, page, retval)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tret += retval;\n\t\tsrc += retval;\n\t\tbuf += retval;\n\t\tcount -= retval;\n\t}\n\t*ppos = src;\n\tmmput(mm);\nfree:\n\tfree_page((unsigned long) page);\n\treturn ret;\n}", "target": 1}
{"code": "static struct epitem *ep_find(struct eventpoll *ep, struct file *file, int fd)\n{\n\tint kcmp;\n\tstruct rb_node *rbp;\n\tstruct epitem *epi, *epir = NULL;\n\tstruct epoll_filefd ffd;\n\tep_set_ffd(&ffd, file, fd);\n\tfor (rbp = ep->rbr.rb_node; rbp; ) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tkcmp = ep_cmp_ffd(&ffd, &epi->ffd);\n\t\tif (kcmp > 0)\n\t\t\trbp = rbp->rb_right;\n\t\telse if (kcmp < 0)\n\t\t\trbp = rbp->rb_left;\n\t\telse {\n\t\t\tepir = epi;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn epir;\n}", "target": 0}
{"code": "static void snd_timer_user_ccallback(struct snd_timer_instance *timeri,\n\t\t\t\t     int event,\n\t\t\t\t     struct timespec *tstamp,\n\t\t\t\t     unsigned long resolution)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\tstruct snd_timer_tread r1;\n\tunsigned long flags;\n\tif (event >= SNDRV_TIMER_EVENT_START &&\n\t    event <= SNDRV_TIMER_EVENT_PAUSE)\n\t\ttu->tstamp = *tstamp;\n\tif ((tu->filter & (1 << event)) == 0 || !tu->tread)\n\t\treturn;\n\tmemset(&r1, 0, sizeof(r1));\n\tr1.event = event;\n\tr1.tstamp = *tstamp;\n\tr1.val = resolution;\n\tspin_lock_irqsave(&tu->qlock, flags);\n\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\tspin_unlock_irqrestore(&tu->qlock, flags);\n\tkill_fasync(&tu->fasync, SIGIO, POLL_IN);\n\twake_up(&tu->qchange_sleep);\n}", "target": 0}
{"code": "static void xen_invalidate_io_bitmap(void)\n{\n\tstruct physdev_set_iobitmap iobitmap = {\n\t\t.bitmap = 0,\n\t\t.nr_ports = 0,\n\t};\n\tnative_tss_invalidate_io_bitmap();\n\tHYPERVISOR_physdev_op(PHYSDEVOP_set_iobitmap, &iobitmap);\n}", "target": 0}
{"code": "static char *handle_new_problem(GVariant *problem_info, uid_t caller_uid, char **error)\n{\n    problem_data_t *pd = problem_data_new();\n    GVariantIter *iter;\n    g_variant_get(problem_info, \"a{ss}\", &iter);\n    gchar *key, *value;\n    while (g_variant_iter_loop(iter, \"{ss}\", &key, &value))\n    {\n        problem_data_add_text_editable(pd, key, value);\n    }\n    if (caller_uid != 0 || problem_data_get_content_or_NULL(pd, FILENAME_UID) == NULL)\n    {   \n        log_info(\"Adding UID %d to problem data\", caller_uid);\n        char buf[sizeof(uid_t) * 3 + 2];\n        snprintf(buf, sizeof(buf), \"%d\", caller_uid);\n        problem_data_add_text_noteditable(pd, FILENAME_UID, buf);\n    }\n    problem_data_add_basics(pd);\n    char *problem_id = problem_data_save(pd);\n    if (problem_id)\n        notify_new_path(problem_id);\n    else if (error)\n        *error = xasprintf(\"Cannot create a new problem\");\n    problem_data_free(pd);\n    return problem_id;\n}", "target": 1}
{"code": "ev_archive_get_entry_is_encrypted (EvArchive *archive)\n{\n\tg_return_val_if_fail (EV_IS_ARCHIVE (archive), FALSE);\n\tg_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, FALSE);\n\tswitch (archive->type) {\n\tcase EV_ARCHIVE_TYPE_NONE:\n\t\tg_assert_not_reached ();\n\tcase EV_ARCHIVE_TYPE_RAR:\n\tcase EV_ARCHIVE_TYPE_ZIP:\n\tcase EV_ARCHIVE_TYPE_7Z:\n\tcase EV_ARCHIVE_TYPE_TAR:\n\t\tg_return_val_if_fail (archive->libar_entry != NULL, -1);\n\t\treturn archive_entry_is_encrypted (archive->libar_entry);\n\t}\n\treturn FALSE;\n}", "target": 0}
{"code": "static ssize_t ocfs2_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tget_block_t *get_block;\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\tif (iocb->ki_pos + iter->count > i_size_read(inode) &&\n\t    !ocfs2_supports_append_dio(osb))\n\t\treturn 0;\n\tif (iov_iter_rw(iter) == READ)\n\t\tget_block = ocfs2_get_block;\n\telse\n\t\tget_block = ocfs2_dio_get_block;\n\treturn __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev,\n\t\t\t\t    iter, get_block,\n\t\t\t\t    ocfs2_dio_end_io, NULL, 0);\n}", "target": 1}
{"code": "add_header_value(VALUE hh, const char *key, int klen, const char *val, int vlen) {\n    if (sizeof(content_type) - 1 == klen && 0 == strncasecmp(key, content_type, sizeof(content_type) - 1)) {\n\trb_hash_aset(hh, content_type_val, rb_str_new(val, vlen));\n    } else if (sizeof(content_length) - 1 == klen && 0 == strncasecmp(key, content_length, sizeof(content_length) - 1)) {\n\trb_hash_aset(hh, content_length_val, rb_str_new(val, vlen));\n    } else {\n\tchar\t\thkey[1024];\n\tchar\t\t*k = hkey;\n\tvolatile VALUE\tsval = rb_str_new(val, vlen);\n\tstrcpy(hkey, \"HTTP_\");\n\tk = hkey + 5;\n\tif ((int)(sizeof(hkey) - 5) <= klen) {\n\t    klen = sizeof(hkey) - 6;\n\t}\n\tstrncpy(k, key, klen);\n\thkey[klen + 5] = '\\0';\n\tfor (k = hkey + 5; '\\0' != *k; k++) {\n\t    if ('-' == *k) {\n\t\t*k = '_';\n\t    } else {\n\t\t*k = toupper(*k);\n\t    }\n\t}\n\trb_hash_aset(hh, rb_str_new(hkey, klen + 5), sval);\n    }\n}", "target": 1}
{"code": "  void operator()(const CPUDevice& d, typename TTypes<T, 4>::ConstTensor input,\n                  typename TTypes<T, 3>::ConstTensor filter,\n                  typename TTypes<T, 4>::ConstTensor out_backprop,\n                  int stride_rows, int stride_cols, int rate_rows,\n                  int rate_cols, int pad_top, int pad_left,\n                  typename TTypes<T, 3>::Tensor filter_backprop) {\n    const int batch = input.dimension(0);\n    const int input_rows = input.dimension(1);\n    const int input_cols = input.dimension(2);\n    const int depth = input.dimension(3);\n    const int filter_rows = filter.dimension(0);\n    const int filter_cols = filter.dimension(1);\n    const int output_rows = out_backprop.dimension(1);\n    const int output_cols = out_backprop.dimension(2);\n    filter_backprop.setZero();\n    for (int b = 0; b < batch; ++b) {\n      for (int h_out = 0; h_out < output_rows; ++h_out) {\n        int h_beg = h_out * stride_rows - pad_top;\n        for (int w_out = 0; w_out < output_cols; ++w_out) {\n          int w_beg = w_out * stride_cols - pad_left;\n          for (int d = 0; d < depth; ++d) {\n            T cur_val = Eigen::NumTraits<T>::lowest();\n            int h_max = 0;\n            int w_max = 0;\n            for (int h = 0; h < filter_rows; ++h) {\n              const int h_in = h_beg + h * rate_rows;\n              if (h_in >= 0 && h_in < input_rows) {\n                for (int w = 0; w < filter_cols; ++w) {\n                  const int w_in = w_beg + w * rate_cols;\n                  if (w_in >= 0 && w_in < input_cols) {\n                    const T val = input(b, h_in, w_in, d) + filter(h, w, d);\n                    if (val > cur_val) {\n                      cur_val = val;\n                      h_max = h;\n                      w_max = w;\n                    }\n                  }\n                }\n              }\n            }\n            filter_backprop(h_max, w_max, d) +=\n                out_backprop(b, h_out, w_out, d);\n          }\n        }\n      }\n    }\n  }", "target": 1}
{"code": "static int iscsi_add_notunderstood_response(\n\tchar *key,\n\tchar *value,\n\tstruct iscsi_param_list *param_list)\n{\n\tstruct iscsi_extra_response *extra_response;\n\tif (strlen(value) > VALUE_MAXLEN) {\n\t\tpr_err(\"Value for notunderstood key \\\"%s\\\" exceeds %d,\"\n\t\t\t\" protocol error.\\n\", key, VALUE_MAXLEN);\n\t\treturn -1;\n\t}\n\textra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);\n\tif (!extra_response) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_extra_response.\\n\");\n\t\treturn -1;\n\t}\n\tINIT_LIST_HEAD(&extra_response->er_list);\n\tstrncpy(extra_response->key, key, strlen(key) + 1);\n\tstrncpy(extra_response->value, NOTUNDERSTOOD,\n\t\t\tstrlen(NOTUNDERSTOOD) + 1);\n\tlist_add_tail(&extra_response->er_list,\n\t\t\t&param_list->extra_response_list);\n\treturn 0;\n}", "target": 1}
{"code": "check_supported(item *new)\n{\nint c = -1;\nint bot = 0;\nint top = supported_elements_count;\nint mid;\ntree_node *tn;\nparamstr *param;\nwhile (top > bot)\n  {\n  mid = (top + bot)/2;\n  c = Ustrcmp(new->name, supported_elements[mid].name);\n  if (c == 0) break;\n  if (c < 0) top = mid; else bot = mid + 1;\n  }\nif (c != 0)\n  {\n  tn = tree_search(unknown_element_tree, new->name);\n  if (tn == NULL)\n    {\n    tn = misc_malloc(sizeof(tree_node) + Ustrlen(new->name));\n    Ustrcpy(tn->name, new->name);\n    (void)tree_insertnode(&unknown_element_tree, tn);\n    }\n  return;\n  }\nfor (param = new->p.param; param != NULL; param = param->next)\n  {\n  uschar buffer[256];\n  uschar **aptr;\n  if (param->name[0] == '#') continue;\n  if (Ustrcmp(param->name, \"revisionflag\") == 0)\n    {\n    if (Ustrcmp(param->value, \"changed\") == 0) continue;\n    (void)sprintf(CS buffer, \"+%s=%s:%s\", param->name, param->value,\n      new->name);\n    }\n  else\n    {\n    aptr = supported_elements[mid].attrs;\n    if (aptr != NULL)\n      {\n      if (Ustrcmp(*aptr, \"*\") == 0) continue;\n      for (; *aptr != NULL; aptr++)\n        if (Ustrcmp(*aptr, param->name) == 0) break;\n      if (*aptr != NULL) continue;\n      }\n    (void)sprintf(CS buffer, \"+%s:%s\", param->name, new->name);\n    }\n  tn = tree_search(unknown_element_tree, buffer);\n  if (tn == NULL)\n    {\n    tn = misc_malloc(sizeof(tree_node) + Ustrlen(buffer));\n    Ustrcpy(tn->name, buffer);\n    (void)tree_insertnode(&unknown_element_tree, tn);\n    }\n  }\n}", "target": 1}
{"code": "int URI_FUNC(ComposeQueryEngine)(URI_CHAR * dest,\n\t\tconst URI_TYPE(QueryList) * queryList,\n\t\tint maxChars, int * charsWritten, int * charsRequired,\n\t\tUriBool spaceToPlus, UriBool normalizeBreaks) {\n\tUriBool firstItem = URI_TRUE;\n\tint ampersandLen = 0;  \n\tURI_CHAR * write = dest;\n\tif (dest == NULL) {\n\t\t*charsRequired = 0;\n\t} else {\n\t\tmaxChars--;\n\t}\n\twhile (queryList != NULL) {\n\t\tconst URI_CHAR * const key = queryList->key;\n\t\tconst URI_CHAR * const value = queryList->value;\n\t\tconst int worstCase = (normalizeBreaks == URI_TRUE ? 6 : 3);\n\t\tconst int keyLen = (key == NULL) ? 0 : (int)URI_STRLEN(key);\n\t\tconst int keyRequiredChars = worstCase * keyLen;\n\t\tconst int valueLen = (value == NULL) ? 0 : (int)URI_STRLEN(value);\n\t\tconst int valueRequiredChars = worstCase * valueLen;\n\t\tif (dest == NULL) {\n\t\t\t(*charsRequired) += ampersandLen + keyRequiredChars + ((value == NULL)\n\t\t\t\t\t\t? 0\n\t\t\t\t\t\t: 1 + valueRequiredChars);\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((write - dest) + ampersandLen + keyRequiredChars > maxChars) {\n\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t}\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t} else {\n\t\t\t\twrite[0] = _UT('&');\n\t\t\t\twrite++;\n\t\t\t}\n\t\t\twrite = URI_FUNC(EscapeEx)(key, key + keyLen,\n\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\tif (value != NULL) {\n\t\t\t\tif ((write - dest) + 1 + valueRequiredChars > maxChars) {\n\t\t\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t\t\t}\n\t\t\t\twrite[0] = _UT('=');\n\t\t\t\twrite++;\n\t\t\t\twrite = URI_FUNC(EscapeEx)(value, value + valueLen,\n\t\t\t\t\t\twrite, spaceToPlus, normalizeBreaks);\n\t\t\t}\n\t\t}\n\t\tqueryList = queryList->next;\n\t}\n\tif (dest != NULL) {\n\t\twrite[0] = _UT('\\0');\n\t\tif (charsWritten != NULL) {\n\t\t\t*charsWritten = (int)(write - dest) + 1; \n\t\t}\n\t}\n\treturn URI_SUCCESS;\n}", "target": 1}
{"code": "struct sctp_chunk *sctp_process_asconf(struct sctp_association *asoc,\n\t\t\t\t       struct sctp_chunk *asconf)\n{\n\tsctp_addiphdr_t\t\t*hdr;\n\tunion sctp_addr_param\t*addr_param;\n\tsctp_addip_param_t\t*asconf_param;\n\tstruct sctp_chunk\t*asconf_ack;\n\t__be16\terr_code;\n\tint\tlength = 0;\n\tint\tchunk_len;\n\t__u32\tserial;\n\tint\tall_param_pass = 1;\n\tchunk_len = ntohs(asconf->chunk_hdr->length) - sizeof(sctp_chunkhdr_t);\n\thdr = (sctp_addiphdr_t *)asconf->skb->data;\n\tserial = ntohl(hdr->serial);\n\tlength = sizeof(sctp_addiphdr_t);\n\taddr_param = (union sctp_addr_param *)(asconf->skb->data + length);\n\tchunk_len -= length;\n\tlength = ntohs(addr_param->p.length);\n\tasconf_param = (void *)addr_param + length;\n\tchunk_len -= length;\n\tasconf_ack = sctp_make_asconf_ack(asoc, serial, chunk_len * 4);\n\tif (!asconf_ack)\n\t\tgoto done;\n\twhile (chunk_len > 0) {\n\t\terr_code = sctp_process_asconf_param(asoc, asconf,\n\t\t\t\t\t\t     asconf_param);\n\t\tif (SCTP_ERROR_NO_ERROR != err_code)\n\t\t\tall_param_pass = 0;\n\t\tif (!all_param_pass)\n\t\t\tsctp_add_asconf_response(asconf_ack,\n\t\t\t\t\t\t asconf_param->crr_id, err_code,\n\t\t\t\t\t\t asconf_param);\n\t\tif (SCTP_ERROR_RSRC_LOW == err_code)\n\t\t\tgoto done;\n\t\tlength = ntohs(asconf_param->param_hdr.length);\n\t\tasconf_param = (void *)asconf_param + length;\n\t\tchunk_len -= length;\n\t}\ndone:\n\tasoc->peer.addip_serial++;\n\tif (asconf_ack) {\n\t\tsctp_chunk_hold(asconf_ack);\n\t\tlist_add_tail(&asconf_ack->transmitted_list,\n\t\t\t      &asoc->asconf_ack_list);\n\t}\n\treturn asconf_ack;\n}", "target": 1}
{"code": "int multiplyCheckOverflow(int a, int b, int *result)\n{\n#if (defined __GNUC__ && __GNUC__ >= 5) || ( __clang__ && __has_builtin(__builtin_mul_overflow))\n\treturn __builtin_mul_overflow(a, b, result);\n#else\n\tif (firstBitSet(a)+firstBitSet(b)>31) \n\t\treturn true;\n\t*result = a * b;\n\treturn false;\n#endif\n}", "target": 0}
{"code": "parse_wcc_attr(netdissect_options *ndo,\n               const uint32_t *dp)\n{\n\tND_PRINT((ndo, \" sz %\" PRIu64, EXTRACT_64BITS(&dp[0])));\n\tND_PRINT((ndo, \" mtime %u.%06u ctime %u.%06u\",\n\t       EXTRACT_32BITS(&dp[2]), EXTRACT_32BITS(&dp[3]),\n\t       EXTRACT_32BITS(&dp[4]), EXTRACT_32BITS(&dp[5])));\n\treturn (dp + 6);\n}", "target": 0}
{"code": "int ipc_addid(struct ipc_ids *ids, struct kern_ipc_perm *new, int size)\n{\n\tkuid_t euid;\n\tkgid_t egid;\n\tint id;\n\tint next_id = ids->next_id;\n\tif (size > IPCMNI)\n\t\tsize = IPCMNI;\n\tif (ids->in_use >= size)\n\t\treturn -ENOSPC;\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_init(&new->lock);\n\tnew->deleted = false;\n\trcu_read_lock();\n\tspin_lock(&new->lock);\n\tid = idr_alloc(&ids->ipcs_idr, new,\n\t\t       (next_id < 0) ? 0 : ipcid_to_idx(next_id), 0,\n\t\t       GFP_NOWAIT);\n\tidr_preload_end();\n\tif (id < 0) {\n\t\tspin_unlock(&new->lock);\n\t\trcu_read_unlock();\n\t\treturn id;\n\t}\n\tids->in_use++;\n\tcurrent_euid_egid(&euid, &egid);\n\tnew->cuid = new->uid = euid;\n\tnew->gid = new->cgid = egid;\n\tif (next_id < 0) {\n\t\tnew->seq = ids->seq++;\n\t\tif (ids->seq > IPCID_SEQ_MAX)\n\t\t\tids->seq = 0;\n\t} else {\n\t\tnew->seq = ipcid_to_seqx(next_id);\n\t\tids->next_id = -1;\n\t}\n\tnew->id = ipc_buildid(id, new->seq);\n\treturn id;\n}", "target": 1}
{"code": "memcmp_constant_time (const void *a, const void *b, size_t size) {\n  const uint8_t * a1 = a;\n  const uint8_t * b1 = b;\n  int ret = 0;\n  size_t i;\n  for (i = 0; i < size; i++) {\n      ret |= *a1++ ^ *b1++;\n  }\n  return ret;\n}", "target": 0}
{"code": "uint64 ReadCodedSizeValue(const binary * InBuffer, uint32 & BufferSize, uint64 & SizeUnknown)\n{\n  binary SizeBitMask = 1 << 7;\n  uint64 Result = 0x7F;\n  unsigned int SizeIdx, PossibleSizeLength = 0;\n  binary PossibleSize[8];\n  memset(PossibleSize, 0, 8);\n  SizeUnknown = 0x7F; \n  for (SizeIdx = 0; SizeIdx < BufferSize && SizeIdx < 8; SizeIdx++) {\n    if (InBuffer[0] & (SizeBitMask >> SizeIdx)) {\n      PossibleSizeLength = SizeIdx + 1;\n      SizeBitMask >>= SizeIdx;\n      if (PossibleSizeLength > BufferSize)\n        break;\n      for (SizeIdx = 0; SizeIdx < PossibleSizeLength; SizeIdx++) {\n        PossibleSize[SizeIdx] = InBuffer[SizeIdx];\n      }\n      for (SizeIdx = 0; SizeIdx < PossibleSizeLength - 1; SizeIdx++) {\n        Result <<= 7;\n        Result |= 0xFF;\n      }\n      Result = 0;\n      Result |= PossibleSize[0] & ~SizeBitMask;\n      for (unsigned int i = 1; i<PossibleSizeLength; i++) {\n        Result <<= 8;\n        Result |= PossibleSize[i];\n      }\n      BufferSize = PossibleSizeLength;\n      return Result;\n    }\n    SizeUnknown <<= 7;\n    SizeUnknown |= 0xFF;\n  }\n  BufferSize = 0;\n  return 0;\n}", "target": 0}
{"code": "get_case_fold_codes_by_str(OnigCaseFoldType flag,\n\t\t\t\t       const OnigUChar* p, const OnigUChar* end,\n\t\t\t\t       OnigCaseFoldCodeItem items[],\n\t\t\t\t       OnigEncoding enc ARG_UNUSED)\n{\n  return onigenc_get_case_fold_codes_by_str_with_map(\n\t     sizeof(CaseFoldMap)/sizeof(OnigPairCaseFoldCodes), CaseFoldMap, 1,\n\t     flag, p, end, items);\n}", "target": 0}
{"code": "static int db__message_reconnect_reset_incoming(struct mosquitto *context)\n{\n\tstruct mosquitto_client_msg *msg, *tmp;\n\tcontext->msgs_in.inflight_bytes = 0;\n\tcontext->msgs_in.inflight_bytes12 = 0;\n\tcontext->msgs_in.inflight_count = 0;\n\tcontext->msgs_in.inflight_count12 = 0;\n\tcontext->msgs_in.queued_bytes = 0;\n\tcontext->msgs_in.queued_bytes12 = 0;\n\tcontext->msgs_in.queued_count = 0;\n\tcontext->msgs_in.queued_count12 = 0;\n\tcontext->msgs_in.inflight_quota = context->msgs_in.inflight_maximum;\n\tDL_FOREACH_SAFE(context->msgs_in.inflight, msg, tmp){\n\t\tdb__msg_add_to_inflight_stats(&context->msgs_in, msg);\n\t\tif(msg->qos > 0){\n\t\t\tutil__decrement_receive_quota(context);\n\t\t}\n\t\tif(msg->qos != 2){\n\t\t\tdb__message_remove_from_inflight(&context->msgs_in, msg);\n\t\t}else{\n\t\t\tmsg->dup = 0;\n\t\t}\n\t}\n\tDL_FOREACH_SAFE(context->msgs_in.queued, msg, tmp){\n\t\tmsg->dup = 0;\n\t\tdb__msg_add_to_queued_stats(&context->msgs_in, msg);\n\t\tif(db__ready_for_flight(context, mosq_md_in, msg->qos)){\n\t\t\tswitch(msg->qos){\n\t\t\t\tcase 0:\n\t\t\t\t\tmsg->state = mosq_ms_publish_qos0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tmsg->state = mosq_ms_publish_qos1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tmsg->state = mosq_ms_publish_qos2;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdb__message_dequeue_first(context, &context->msgs_in);\n\t\t}\n\t}\n\treturn MOSQ_ERR_SUCCESS;\n}", "target": 0}
{"code": "static void jsiSqlFunc(sqlite3_context *context, int argc, sqlite3_value**argv) {\n    SqlFunc *p = (SqlFunc*)sqlite3_user_data(context);\n    int i;\n    int rc;\n    Jsi_Interp *interp = p->interp;\n    Jsi_Value *vpargs, *itemsStatic[100], **items = itemsStatic, *ret;\n    if (argc>100)\n        items = (Jsi_Value**)Jsi_Calloc(argc, sizeof(Jsi_Value*));\n    for(i=0; i<argc; i++) {\n        items[i] = dbGetValueGet(interp, argv[i]);\n    }\n    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, argc, 0));\n    Jsi_IncrRefCount(interp, vpargs);\n    ret = Jsi_ValueNew1(interp);\n    rc = Jsi_FunctionInvoke(interp, p->tocall, vpargs, &ret, NULL);\n    Jsi_DecrRefCount(interp, vpargs);\n    if (items != itemsStatic)\n        Jsi_Free(items);\n    bool b;\n    if( rc != JSI_OK) {\n        char buf[250];\n        snprintf(buf, sizeof(buf), \"error in function: %.200s\", p->zName);\n        sqlite3_result_error(context, buf, -1);\n    } else if (Jsi_ValueIsBoolean(interp, ret)) {\n        Jsi_GetBoolFromValue(interp, ret, &b);\n        sqlite3_result_int(context, b);\n    } else if (Jsi_ValueIsNumber(interp, ret)) {\n        Jsi_Number d;\n        Jsi_GetNumberFromValue(interp, ret, &d);\n        sqlite3_result_double(context, (double)d);\n    } else {\n        const char * data;\n        if (!(data = Jsi_ValueGetStringLen(interp, ret, &i))) {\n            data = Jsi_ValueToString(interp, ret, NULL);\n            i = Jsi_Strlen(data);\n        }\n        sqlite3_result_text(context, (char *)data, i, SQLITE_TRANSIENT );\n    }\n    Jsi_DecrRefCount(interp, ret);\n}", "target": 1}
{"code": "static Sdb *get_gnu_verneed(ELFOBJ *bin) {\n\tut64 verneed_addr;\n\tut64 verneed_num;\n\tif (!Elf_(rz_bin_elf_get_dt_info)(bin, DT_VERNEED, &verneed_addr) || !Elf_(rz_bin_elf_get_dt_info)(bin, DT_VERNEEDNUM, &verneed_num)) {\n\t\treturn NULL;\n\t}\n\tut64 verneed_offset = Elf_(rz_bin_elf_v2p(bin, verneed_addr));\n\tif (verneed_offset == UT64_MAX) {\n\t\tRZ_LOG_WARN(\"Failed to convert verneed virtual address to physical address.\\n\");\n\t\treturn NULL;\n\t}\n\tSdb *sdb = sdb_new0();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tif (!sdb_num_set(sdb, \"num_entries\", verneed_num, 0) ||\n\t\t!sdb_num_set(sdb, \"addr\", verneed_addr, 0) ||\n\t\t!sdb_num_set(sdb, \"offset\", verneed_offset, 0)) {\n\t\tsdb_free(sdb);\n\t\treturn NULL;\n\t}\n\tfor (size_t i = 0; i < verneed_num; i++) {\n\t\tElf_(Verneed) verneed_entry;\n\t\tif (!get_verneed_entry(bin, verneed_offset, &verneed_entry)) {\n\t\t\tsdb_free(sdb);\n\t\t\treturn NULL;\n\t\t}\n\t\tSdb *sdb_version = get_verneed_entry_sdb(bin, verneed_entry, verneed_offset);\n\t\tif (!sdb_version) {\n\t\t\tsdb_free(sdb);\n\t\t\treturn NULL;\n\t\t}\n\t\tchar key[32];\n\t\tif (!sdb_ns_set(sdb, rz_strf(key, \"version%zu\", i), sdb_version)) {\n\t\t\tsdb_free(sdb_version);\n\t\t\tsdb_free(sdb);\n\t\t\treturn NULL;\n\t\t}\n\t\tsdb_free(sdb_version);\n\t\tif (!verneed_entry.vn_next) {\n\t\t\tbreak;\n\t\t}\n\t\tverneed_offset += verneed_entry.vn_next;\n\t}\n\treturn sdb;\n}", "target": 0}
{"code": "static int smtp_open(struct Connection *conn, bool esmtp)\n{\n  int rc;\n  if (mutt_socket_open(conn))\n    return -1;\n  rc = smtp_get_resp(conn);\n  if (rc != 0)\n    return rc;\n  rc = smtp_helo(conn, esmtp);\n  if (rc != 0)\n    return rc;\n#ifdef USE_SSL\n  enum QuadOption ans = MUTT_NO;\n  if (conn->ssf)\n    ans = MUTT_NO;\n  else if (C_SslForceTls)\n    ans = MUTT_YES;\n  else if ((Capabilities & SMTP_CAP_STARTTLS) &&\n           ((ans = query_quadoption(C_SslStarttls,\n                                    _(\"Secure connection with TLS?\"))) == MUTT_ABORT))\n  {\n    return -1;\n  }\n  if (ans == MUTT_YES)\n  {\n    if (mutt_socket_send(conn, \"STARTTLS\\r\\n\") < 0)\n      return SMTP_ERR_WRITE;\n    rc = smtp_get_resp(conn);\n    mutt_socket_empty(conn);\n    if (rc != 0)\n      return rc;\n    if (mutt_ssl_starttls(conn))\n    {\n      mutt_error(_(\"Could not negotiate TLS connection\"));\n      return -1;\n    }\n    rc = smtp_helo(conn, esmtp);\n    if (rc != 0)\n      return rc;\n  }\n#endif\n  if (conn->account.flags & MUTT_ACCT_USER)\n  {\n    if (!(Capabilities & SMTP_CAP_AUTH))\n    {\n      mutt_error(_(\"SMTP server does not support authentication\"));\n      return -1;\n    }\n    return smtp_auth(conn);\n  }\n  return 0;\n}", "target": 0}
{"code": "log2vis_utf8 (PyObject * string, int unicode_length,\n\t      FriBidiParType base_direction, int clean, int reordernsm)\n{\n\tFriBidiChar *logical = NULL; \n\tFriBidiChar *visual = NULL;\t \n\tchar *visual_utf8 = NULL;    \n\tFriBidiStrIndex new_len = 0; \n\tPyObject *result = NULL;\t \n\tlogical = PyMem_New (FriBidiChar, unicode_length + 1);\n\tif (logical == NULL)\n\t{\n\t\tPyErr_SetString (PyExc_MemoryError,\n\t\t\t\t \"failed to allocate unicode buffer\");\n\t\tgoto cleanup;\n\t}\n\tvisual = PyMem_New (FriBidiChar, unicode_length + 1);\n\tif (visual == NULL)\n\t{\n\t\tPyErr_SetString (PyExc_MemoryError,\n\t\t\t\t \"failed to allocate unicode buffer\");\n\t\tgoto cleanup;\n\t}\n\tfribidi_set_reorder_nsm(reordernsm);\n\tfribidi_utf8_to_unicode (PyString_AS_STRING (string),\n\t\t\t\t PyString_GET_SIZE (string), logical);\n\tif (!fribidi_log2vis (logical, unicode_length, &base_direction, visual,\n\t\t\t      NULL, NULL, NULL))\n\t{\n\t\tPyErr_SetString (PyExc_RuntimeError,\n\t\t\t\t \"fribidi failed to order string\");\n\t\tgoto cleanup;\n\t}\n\tif (clean)\n\t\tfribidi_remove_bidi_marks (visual, unicode_length, NULL, NULL, NULL);\n\tvisual_utf8 = PyMem_New(char, (unicode_length * 4)+1);\n\tif (visual_utf8 == NULL)\n\t{\n\t\tPyErr_SetString (PyExc_MemoryError,\n\t\t\t\t\"failed to allocate UTF-8 buffer\");\n\t\tgoto cleanup;\n\t}\n\tnew_len = fribidi_unicode_to_utf8 (visual, unicode_length, visual_utf8);\n\tresult = PyString_FromStringAndSize (visual_utf8, new_len);\n\tif (result == NULL)\n\t\tgoto cleanup;\n      cleanup:\n\tPyMem_Del (logical);\n\tPyMem_Del (visual);\n\tPyMem_Del (visual_utf8);\n\treturn result;\n}", "target": 1}
{"code": "static void reds_remove_char_device(RedsState *reds, RedCharDevice *dev)\n{\n    g_return_if_fail(reds != NULL);\n    auto &devs(reds->char_devices);\n    g_warn_if_fail(std::find(devs.begin(), devs.end(),\n                             red::shared_ptr<RedCharDevice>(dev)) != devs.end());\n    devs.remove(red::shared_ptr<RedCharDevice>(dev));\n}", "target": 0}
{"code": "d_lite_amjd(VALUE self)\n{\n    get_d1(self);\n    return m_amjd(dat);\n}", "target": 0}
{"code": "set_umask(const char *optarg)\n{\n\tlong umask_long;\n\tmode_t umask_val;\n\tchar *endptr;\n\tumask_long = strtoll(optarg, &endptr, 0);\n\tif (*endptr || umask_long < 0 || umask_long & ~0777L) {\n\t\tfprintf(stderr, \"Invalid --umask option %s\", optarg);\n\t\treturn 0;\n\t}\n\tumask_val = umask_long & 0777;\n\tumask(umask_val);\n\tumask_cmdline = true;\n\treturn umask_val;\n}", "target": 0}
{"code": "char *enl_ipc_get(const char *msg_data)\n{\n\tstatic char *message = NULL;\n\tstatic unsigned short len = 0;\n\tchar buff[13], *ret_msg = NULL;\n\tregister unsigned char i;\n\tunsigned char blen;\n\tif (msg_data == IPC_TIMEOUT) {\n\t\treturn(IPC_TIMEOUT);\n\t}\n\tfor (i = 0; i < 12; i++) {\n\t\tbuff[i] = msg_data[i];\n\t}\n\tbuff[12] = 0;\n\tblen = strlen(buff);\n\tif (message != NULL) {\n\t\tlen += blen;\n\t\tmessage = (char *) erealloc(message, len + 1);\n\t\tstrcat(message, buff);\n\t} else {\n\t\tlen = blen;\n\t\tmessage = (char *) emalloc(len + 1);\n\t\tstrcpy(message, buff);\n\t}\n\tif (blen < 12) {\n\t\tret_msg = message;\n\t\tmessage = NULL;\n\t\tD((\"Received complete reply:  \\\"%s\\\"\\n\", ret_msg));\n\t}\n\treturn(ret_msg);\n}", "target": 1}
{"code": "    size_t Xmpdatum::count() const\n    {\n        return p_->value_.get() == 0 ? 0 : p_->value_->count();\n    }", "target": 0}
{"code": "static void nf_tables_expr_destroy(const struct nft_ctx *ctx,\n\t\t\t\t   struct nft_expr *expr)\n{\n\tif (expr->ops->destroy)\n\t\texpr->ops->destroy(ctx, expr);\n\tmodule_put(expr->ops->type->owner);\n}", "target": 0}
{"code": "void virtio_config_writel(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint32_t val = data;\n    if (addr > (vdev->config_len - sizeof(val)))\n        return;\n    stl_p(vdev->config + addr, val);\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}", "target": 1}
{"code": "void sw_crypto_acipher_free_rsa_public_key(struct rsa_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\tcrypto_bignum_free(s->n);\n\tcrypto_bignum_free(s->e);\n}", "target": 1}
{"code": "wb_print(netdissect_options *ndo,\n         register const void *hdr, register u_int len)\n{\n\tregister const struct pkt_hdr *ph;\n\tph = (const struct pkt_hdr *)hdr;\n\tif (len < sizeof(*ph) || !ND_TTEST(*ph)) {\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\treturn;\n\t}\n\tlen -= sizeof(*ph);\n\tif (ph->ph_flags)\n\t\tND_PRINT((ndo, \"*\"));\n\tswitch (ph->ph_type) {\n\tcase PT_KILL:\n\t\tND_PRINT((ndo, \" wb-kill\"));\n\t\treturn;\n\tcase PT_ID:\n\t\tif (wb_id(ndo, (const struct pkt_id *)(ph + 1), len) >= 0)\n\t\t\treturn;\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\tbreak;\n\tcase PT_RREQ:\n\t\tif (wb_rreq(ndo, (const struct pkt_rreq *)(ph + 1), len) >= 0)\n\t\t\treturn;\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\tbreak;\n\tcase PT_RREP:\n\t\tif (wb_rrep(ndo, (const struct pkt_rrep *)(ph + 1), len) >= 0)\n\t\t\treturn;\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\tbreak;\n\tcase PT_DRAWOP:\n\t\tif (wb_drawop(ndo, (const struct pkt_dop *)(ph + 1), len) >= 0)\n\t\t\treturn;\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\tbreak;\n\tcase PT_PREQ:\n\t\tif (wb_preq(ndo, (const struct pkt_preq *)(ph + 1), len) >= 0)\n\t\t\treturn;\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\tbreak;\n\tcase PT_PREP:\n\t\tif (wb_prep(ndo, (const struct pkt_prep *)(ph + 1), len) >= 0)\n\t\t\treturn;\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \" wb-%d!\", ph->ph_type));\n\t\treturn;\n\t}\n}", "target": 0}
{"code": "void queue_push(register Queue *qp, size_t extra_length, char const *info)\n{\n    register char *cp;\n    size_t memory_length;\n    size_t available_length;\n    size_t begin_length;\n    size_t n_begin;\n    size_t q_length;\n    if (!extra_length)\n        return;\n    memory_length    = qp->d_memory_end - qp->d_memory;\n    q_length = \n        qp->d_read <= qp->d_write ?\n            (size_t)(qp->d_write - qp->d_read)\n        :\n            memory_length - (qp->d_read - qp->d_write);\n    available_length = memory_length - q_length - 1;\n    if (message_show(MSG_INFO))\n        message(\"push_front %u bytes in `%s'\", (unsigned)extra_length, info);\n    if (extra_length > available_length)\n    {\n        memory_length += extra_length - available_length + BLOCK_QUEUE;\n        cp = new_memory(memory_length, sizeof(char));\n        if (message_show(MSG_INFO))\n            message(\"Reallocating queue at %p to %p\", qp->d_memory, cp);\n        if (qp->d_read > qp->d_write)               \n        {\n            size_t tail_len = qp->d_memory_end - qp->d_read;\n            memcpy(cp, qp->d_read, tail_len);       \n            memcpy(cp + tail_len, qp->d_memory, \n                                    (size_t)(qp->d_write - qp->d_memory));\n            qp->d_write = cp + q_length;\n            qp->d_read = cp;\n        }\n        else                                        \n        {\n            memcpy(cp, qp->d_memory, memory_length);\n            qp->d_read = cp + (qp->d_read - qp->d_memory);\n            qp->d_write = cp + (qp->d_write - qp->d_memory);\n        }\n        free(qp->d_memory);                         \n        qp->d_memory_end = cp + memory_length;      \n        qp->d_memory = cp;                          \n    }\n    begin_length = qp->d_read - qp->d_memory;   \n    n_begin = extra_length <= begin_length ?    \n                    extra_length                \n                :\n                    begin_length;\n    memcpy                                      \n    (                                           \n        qp->d_read -= n_begin,\n        info + extra_length - n_begin,\n        n_begin\n    );\n    if (extra_length > begin_length)            \n    {\n        extra_length -= begin_length;           \n        memcpy                                  \n        (                                       \n            qp->d_read = qp->d_memory_end - extra_length,\n            info,\n            extra_length\n        );\n    }\n}", "target": 1}
{"code": "static inline uint32_t mp_clz_mpi(mp_int_t x) {\n    MP_STATIC_ASSERT(sizeof(mp_int_t) == sizeof(long long)\n        || sizeof(mp_int_t) == sizeof(long));\n    if (sizeof(mp_int_t) == sizeof(long)) {\n        return mp_clzl(x);\n    } else {\n        return mp_clzll(x);\n    }\n}", "target": 0}
{"code": "COMPAT_SYSCALL_DEFINE6(mbind, compat_ulong_t, start, compat_ulong_t, len,\n\t\t       compat_ulong_t, mode, compat_ulong_t __user *, nmask,\n\t\t       compat_ulong_t, maxnode, compat_ulong_t, flags)\n{\n\tlong err = 0;\n\tunsigned long __user *nm = NULL;\n\tunsigned long nr_bits, alloc_size;\n\tnodemask_t bm;\n\tnr_bits = min_t(unsigned long, maxnode-1, MAX_NUMNODES);\n\talloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;\n\tif (nmask) {\n\t\terr = compat_get_bitmap(nodes_addr(bm), nmask, nr_bits);\n\t\tnm = compat_alloc_user_space(alloc_size);\n\t\terr |= copy_to_user(nm, nodes_addr(bm), alloc_size);\n\t}\n\tif (err)\n\t\treturn -EFAULT;\n\treturn sys_mbind(start, len, mode, nm, nr_bits+1, flags);\n}", "target": 1}
{"code": "uint64_t ssh_scp_request_get_size64(ssh_scp scp)\n{\n    if (scp == NULL) {\n        return 0;\n    }\n    return scp->filelen;\n}", "target": 0}
{"code": "bool initialise_control(rzip_control *control)\n{\n\ttime_t now_t, tdiff;\n\tchar localeptr[] = \"./\", *eptr; \n\tsize_t len;\n\tmemset(control, 0, sizeof(rzip_control));\n\tcontrol->msgout = stderr;\n\tcontrol->msgerr = stderr;\n\tregister_outputfile(control, control->msgout);\n\tcontrol->flags = FLAG_SHOW_PROGRESS | FLAG_KEEP_FILES | FLAG_THRESHOLD;\n\tcontrol->suffix = \".lrz\";\n\tcontrol->compression_level = 7;\n\tcontrol->ramsize = get_ram(control);\n\tif (unlikely(control->ramsize == -1))\n\t\treturn false;\n\tcontrol->threads = PROCESSORS;\t\n\tcontrol->page_size = PAGE_SIZE;\n\tcontrol->nice_val = 19;\n\tif (unlikely((now_t = time(NULL)) == ((time_t)-1)))\n\t\tfatal_return((\"Failed to call time in main\\n\"), false);\n\tif (unlikely(now_t < T_ZERO)) {\n\t\tprint_output(\"Warning your time reads before the year 2011, check your system clock\\n\");\n\t\tnow_t = T_ZERO;\n\t}\n\ttdiff = (now_t - T_ZERO) / 4;\n\tnow_t = T_ZERO + tdiff;\n\tcontrol->secs = now_t;\n\tcontrol->encloops = nloops(control->secs, control->salt, control->salt + 1);\n\tif (unlikely(!get_rand(control, control->salt + 2, 6)))\n\t\treturn false;\n\teptr = getenv(\"TMPDIR\");\n\tif (!eptr)\n\t\teptr = getenv(\"TMP\");\n\tif (!eptr)\n\t\teptr = getenv(\"TEMPDIR\");\n\tif (!eptr)\n\t\teptr = getenv(\"TEMP\");\n\tif (!eptr)\n\t\teptr = localeptr;\n\tlen = strlen(eptr);\n\tcontrol->tmpdir = malloc(len + 2);\n\tif (control->tmpdir == NULL)\n\t\tfatal_return((\"Failed to allocate for tmpdir\\n\"), false);\n\tstrcpy(control->tmpdir, eptr);\n\tif (control->tmpdir[len - 1] != '/') {\n\t\tcontrol->tmpdir[len] = '/'; \n\t\tcontrol->tmpdir[len + 1] = '\\0';\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static inline void CleanupPDFInfo(PDFInfo *pdf_info)\n{\n  if (pdf_info->profile != (StringInfo *) NULL)\n    pdf_info->profile=DestroyStringInfo(pdf_info->profile);\n}", "target": 0}
{"code": "static inline void dec_snd_pages(int order)\n{\n\tsnd_allocated_pages -= 1 << order;\n}", "target": 0}
{"code": "process_request_identities(SocketEntry *e)\n{\n\tIdentity *id;\n\tstruct sshbuf *msg, *keys;\n\tint r;\n\tu_int nentries = 0;\n\tdebug2_f(\"entering\");\n\tif ((msg = sshbuf_new()) == NULL || (keys = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tTAILQ_FOREACH(id, &idtab->idlist, next) {\n\t\tif (identity_permitted(id, e, NULL, NULL, NULL) != 0)\n\t\t\tcontinue;\n\t\tif ((r = sshkey_puts_opts(id->key, keys,\n\t\t    SSHKEY_SERIALIZE_INFO)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(keys, id->comment)) != 0) {\n\t\t\terror_fr(r, \"compose key/comment\");\n\t\t\tcontinue;\n\t\t}\n\t\tnentries++;\n\t}\n\tdebug2_f(\"replying with %u allowed of %u available keys\",\n\t    nentries, idtab->nentries);\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_IDENTITIES_ANSWER)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, nentries)) != 0 ||\n\t    (r = sshbuf_putb(msg, keys)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tif ((r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal_fr(r, \"enqueue\");\n\tsshbuf_free(msg);\n\tsshbuf_free(keys);\n}", "target": 1}
{"code": "static int skcipher_accept_parent(void *private, struct sock *sk)\n{\n\tstruct skcipher_ctx *ctx;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tunsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(private);\n\tctx = sock_kmalloc(sk, len, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\tctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(private),\n\t\t\t       GFP_KERNEL);\n\tif (!ctx->iv) {\n\t\tsock_kfree_s(sk, ctx, len);\n\t\treturn -ENOMEM;\n\t}\n\tmemset(ctx->iv, 0, crypto_skcipher_ivsize(private));\n\tINIT_LIST_HEAD(&ctx->tsgl);\n\tctx->len = len;\n\tctx->used = 0;\n\tctx->more = 0;\n\tctx->merge = 0;\n\tctx->enc = 0;\n\tatomic_set(&ctx->inflight, 0);\n\taf_alg_init_completion(&ctx->completion);\n\task->private = ctx;\n\tskcipher_request_set_tfm(&ctx->req, private);\n\tskcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t      af_alg_complete, &ctx->completion);\n\tsk->sk_destruct = skcipher_sock_destruct;\n\treturn 0;\n}", "target": 1}
{"code": "error::Error GLES2DecoderImpl::HandleDestroyStreamTextureCHROMIUM(\n    uint32 immediate_data_size,\n    const gles2::DestroyStreamTextureCHROMIUM& c) {\n  GLuint client_id = c.texture;\n  TextureManager::TextureInfo* info =\n      texture_manager()->GetTextureInfo(client_id);\n  if (info && info->IsStreamTexture()) {\n    if (!stream_texture_manager_)\n      return error::kInvalidArguments;\n    stream_texture_manager_->DestroyStreamTexture(info->service_id());\n    info->SetStreamTexture(false);\n    texture_manager()->SetInfoTarget(info, 0);\n  } else {\n    SetGLError(GL_INVALID_VALUE,\n               \"glDestroyStreamTextureCHROMIUM: bad texture id.\");\n  }\n  return error::kNoError;\n}", "target": 0}
{"code": "acl_fetch_stver(struct proxy *px, struct session *l4, void *l7, int dir,\n                struct acl_expr *expr, struct acl_test *test)\n{\n\tstruct http_txn *txn = l7;\n\tchar *ptr;\n\tint len;\n\tif (!txn)\n\t\treturn 0;\n\tif (txn->rsp.msg_state < HTTP_MSG_BODY)\n\t\treturn 0;\n\tlen = txn->rsp.sl.st.v_l;\n\tptr = txn->rsp.sol;\n\twhile ((len-- > 0) && (*ptr++ != '/'));\n\tif (len <= 0)\n\t\treturn 0;\n\ttest->ptr = ptr;\n\ttest->len = len;\n\ttest->flags = ACL_TEST_F_READ_ONLY | ACL_TEST_F_VOL_1ST;\n\treturn 1;\n}", "target": 0}
{"code": "void SetColor(double c, double m, double y, double k,int par)\n{\n    if ( par == STROKING ) {\n        outpos += sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f K\",c,m,y,k);\n    }\n    else {\n        outpos += sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f k\",c,m,y,k);\n    }\n}", "target": 1}
{"code": "  Status DoCompute(OpKernelContext* ctx) {\n    tensorflow::ResourceTagger tag(kTFDataResourceTag,\n                                   ctx->op_kernel().type_string());\n    tstring filename;\n    TF_RETURN_IF_ERROR(\n        ParseScalarArgument<tstring>(ctx, \"filename\", &filename));\n    tstring compression_type;\n    TF_RETURN_IF_ERROR(ParseScalarArgument<tstring>(ctx, \"compression_type\",\n                                                    &compression_type));\n    std::unique_ptr<WritableFile> file;\n    TF_RETURN_IF_ERROR(ctx->env()->NewWritableFile(filename, &file));\n    auto writer = absl::make_unique<io::RecordWriter>(\n        file.get(),\n        io::RecordWriterOptions::CreateRecordWriterOptions(compression_type));\n    DatasetBase* dataset;\n    TF_RETURN_IF_ERROR(GetDatasetFromVariantTensor(ctx->input(0), &dataset));\n    IteratorContext::Params params(ctx);\n    FunctionHandleCache function_handle_cache(params.flr);\n    params.function_handle_cache = &function_handle_cache;\n    ResourceMgr resource_mgr;\n    params.resource_mgr = &resource_mgr;\n    CancellationManager cancellation_manager(ctx->cancellation_manager());\n    params.cancellation_manager = &cancellation_manager;\n    IteratorContext iter_ctx(std::move(params));\n    DatasetBase* finalized_dataset;\n    TF_RETURN_IF_ERROR(FinalizeDataset(ctx, dataset, &finalized_dataset));\n    std::unique_ptr<IteratorBase> iterator;\n    TF_RETURN_IF_ERROR(finalized_dataset->MakeIterator(\n        &iter_ctx, nullptr, \"ToTFRecordOpIterator\", &iterator));\n    std::vector<Tensor> components;\n    components.reserve(finalized_dataset->output_dtypes().size());\n    bool end_of_sequence;\n    do {\n      TF_RETURN_IF_ERROR(\n          iterator->GetNext(&iter_ctx, &components, &end_of_sequence));\n      if (!end_of_sequence) {\n        TF_RETURN_IF_ERROR(\n            writer->WriteRecord(components[0].scalar<tstring>()()));\n      }\n      components.clear();\n    } while (!end_of_sequence);\n    return Status::OK();\n  }", "target": 1}
{"code": "deltas_head_for_each(struct deltas_head *deltas, unsigned long max_serial,\n    unsigned long from_serial, delta_head_cb cb, void *arg)\n{\n\tsize_t index;\n\tsize_t from;\n\tint error;\n\tif (deltas->capacity == 0) {\n\t\tpr_val_warn(\"There's no delta list to process.\");\n\t\treturn -ENOENT;\n\t}\n\tpr_val_debug(\"Getting RRDP deltas from serial %lu to %lu.\", from_serial,\n\t    max_serial);\n\tfrom = deltas->capacity - (max_serial - from_serial);\n\tfor (index = from; index < deltas->capacity; index++) {\n\t\terror = cb(deltas->array[index], arg);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static inline bool spectre_v2_in_eibrs_mode(enum spectre_v2_mitigation mode)\n{\n\treturn mode == SPECTRE_V2_EIBRS ||\n\t       mode == SPECTRE_V2_EIBRS_RETPOLINE ||\n\t       mode == SPECTRE_V2_EIBRS_LFENCE;\n}", "target": 0}
{"code": "cp1250_mbc_case_fold(OnigCaseFoldType flag ARG_UNUSED,\n             const UChar** pp, const UChar* end ARG_UNUSED, UChar* lower, OnigEncoding enc ARG_UNUSED)\n{\n  const UChar* p = *pp;\n  *lower = ENC_CP1250_TO_LOWER_CASE(*p);\n  (*pp)++;\n  return 1;\n}", "target": 0}
{"code": "void FrameLoader::updateFirstPartyForCookies()\n{\n    if (m_frame->tree()->parent())\n        setFirstPartyForCookies(m_frame->tree()->parent()->document()->firstPartyForCookies());\n    else\n        setFirstPartyForCookies(m_URL);\n}", "target": 0}
{"code": "static int _process_request_metaflags(mcp_parser_t *pr, int token) {\n    if (pr->ntokens <= token) {\n        pr->t.meta.flags = 0; \n        return 0;\n    }\n    const char *cur = pr->request + pr->tokens[token];\n    const char *end = pr->request + pr->reqlen - 2;\n    int state = 0;\n    while (cur != end) {\n        switch (state) {\n            case 0:\n                if (*cur == ' ') {\n                    cur++;\n                } else {\n                    if (*cur < 65 || *cur > 122) {\n                        return -1;\n                    }\n                    P_DEBUG(\"%s: setting meta flag: %d\\n\", __func__, *cur - 65);\n                    pr->t.meta.flags |= (uint64_t)1 << (*cur - 65);\n                    state = 1;\n                }\n                break;\n            case 1:\n                if (*cur != ' ') {\n                    cur++;\n                } else {\n                    state = 0;\n                }\n                break;\n        }\n    }\n    if (pr->t.meta.flags & ((uint64_t)1 << 48)) {\n        pr->noreply = true;\n    }\n    return 0;\n}", "target": 1}
{"code": "bool isKeyInvalid(const String &key) {\n  return key.find('\\0') != -1;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input_tensor = context->input(0);\n    const auto input_tensor_flat = input_tensor.flat<int32>();\n    const Tensor& input_splits = context->input(1);\n    const auto input_splits_flat = input_splits.flat<SPLITS_TYPE>();\n    OP_REQUIRES(\n        context, input_splits.NumElements() > 0,\n        errors::InvalidArgument(\"Input_splits should contain elements, but \"\n                                \"given input_values has 0 elements\"));\n    OP_REQUIRES(\n        context, input_splits_flat(0) == 0,\n        errors::InvalidArgument(\"First value in input_splits must be zero.\"));\n    OP_REQUIRES(context,\n                input_splits_flat(input_splits_flat.size() - 1) ==\n                    input_tensor_flat.size(),\n                errors::InvalidArgument(\"Last value in input_splits must be \"\n                                        \"equal to length of input_tensor.\"));\n    TensorShape output_shape({input_splits.dim_size(0) - 1});\n    Tensor* output_tensor;\n    OP_REQUIRES_OK(context, context->allocate_output(\"output\", output_shape,\n                                                     &output_tensor));\n    auto output_tensor_flat = output_tensor->flat<tstring>();\n    int idx = 0;\n    for (int i = 1; i < input_splits_flat.size(); ++i) {\n      icu::UnicodeString unicode_string;\n      icu::UnicodeStringAppendable appendable_unicode_string(unicode_string);\n      OP_REQUIRES(\n          context, input_splits_flat(i - 1) <= input_splits_flat(i),\n          errors::InvalidArgument(\n              \"Values in input_splits must be equal or in ascending order.\"));\n      OP_REQUIRES(\n          context, input_splits_flat(i) <= input_tensor_flat.size(),\n          errors::InvalidArgument(\"Values in input_splits must be less than or \"\n                                  \"equal to input_tensor length.\"));\n      for (; idx < input_splits_flat(i); ++idx) {\n        int32_t code_point = input_tensor_flat(idx);\n        if (!U_IS_UNICODE_CHAR(code_point)) {\n          if (error_options_.error_on_malformatting) {\n            context->CtxFailure(errors::InvalidArgument(\n                \"Code point is out of range for Unicode, or a noncharacter.\"));\n            return;\n          } else if (!error_options_.elide_replacement) {\n            code_point = error_options_.subst;\n          }\n        }\n        appendable_unicode_string.appendCodePoint(code_point);\n      }\n      tstring result;\n      Encode(encoding_, unicode_string, &result);\n      output_tensor_flat(i - 1) = std::move(result);\n    }\n  }", "target": 0}
{"code": "void zend_shared_alloc_register_xlat_entry(const void *old, const void *new)\n{\n\tzend_hash_index_update_ptr(&xlat_table, (zend_ulong)old, (void*)new);\n}", "target": 0}
{"code": "delete_policy_2_svc(dpol_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->name;\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_DELETE, NULL, NULL)) {\n        log_unauth(\"kadm5_delete_policy\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_DELETE;\n    } else {\n        ret.code = kadm5_delete_policy((void *)handle, arg->name);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_delete_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "static __be32 nfsd3_proc_setacl(struct svc_rqst * rqstp,\n\t\tstruct nfsd3_setaclargs *argp,\n\t\tstruct nfsd3_attrstat *resp)\n{\n\tstruct inode *inode;\n\tsvc_fh *fh;\n\t__be32 nfserr = 0;\n\tint error;\n\tfh = fh_copy(&resp->fh, &argp->fh);\n\tnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);\n\tif (nfserr)\n\t\tgoto out;\n\tinode = d_inode(fh->fh_dentry);\n\tif (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {\n\t\terror = -EOPNOTSUPP;\n\t\tgoto out_errno;\n\t}\n\terror = fh_want_write(fh);\n\tif (error)\n\t\tgoto out_errno;\n\terror = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);\n\tif (error)\n\t\tgoto out_drop_write;\n\terror = inode->i_op->set_acl(inode, argp->acl_default,\n\t\t\t\t     ACL_TYPE_DEFAULT);\nout_drop_write:\n\tfh_drop_write(fh);\nout_errno:\n\tnfserr = nfserrno(error);\nout:\n\tposix_acl_release(argp->acl_access);\n\tposix_acl_release(argp->acl_default);\n\tRETURN_STATUS(nfserr);\n}", "target": 1}
{"code": "static inline struct ipv6_txoptions *txopt_get(const struct ipv6_pinfo *np)\n{\n\tstruct ipv6_txoptions *opt;\n\trcu_read_lock();\n\topt = rcu_dereference(np->opt);\n\tif (opt && !atomic_inc_not_zero(&opt->refcnt))\n\t\topt = NULL;\n\trcu_read_unlock();\n\treturn opt;\n}", "target": 0}
{"code": "segment_end (Elf_Internal_Phdr *segment, bfd_vma start)\n{\n  return start + segment_size (segment);\n}", "target": 0}
{"code": "bool SpeechSynthesis::speaking() const\n{\n    return currentSpeechUtterance();\n}", "target": 0}
{"code": "void GfxState::shiftCTMAndClip(double tx, double ty)\n{\n    ctm[4] += tx;\n    ctm[5] += ty;\n    clipXMin += tx;\n    clipYMin += ty;\n    clipXMax += tx;\n    clipYMax += ty;\n}", "target": 0}
{"code": "rb_decrement_entry(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t   struct ring_buffer_event *event)\n{\n\tunsigned long addr = (unsigned long)event;\n\tstruct buffer_page *bpage = cpu_buffer->commit_page;\n\tstruct buffer_page *start;\n\taddr &= PAGE_MASK;\n\tif (likely(bpage->page == (void *)addr)) {\n\t\tlocal_dec(&bpage->entries);\n\t\treturn;\n\t}\n\trb_inc_page(cpu_buffer, &bpage);\n\tstart = bpage;\n\tdo {\n\t\tif (bpage->page == (void *)addr) {\n\t\t\tlocal_dec(&bpage->entries);\n\t\t\treturn;\n\t\t}\n\t\trb_inc_page(cpu_buffer, &bpage);\n\t} while (bpage != start);\n\tRB_WARN_ON(cpu_buffer, 1);\n}", "target": 0}
{"code": "void luaV_concat (lua_State *L, int total) {\n  if (total == 1)\n    return;  \n  do {\n    StkId top = L->top;\n    int n = 2;  \n    if (!(ttisstring(s2v(top - 2)) || cvt2str(s2v(top - 2))) ||\n        !tostring(L, s2v(top - 1)))\n      luaT_tryconcatTM(L);\n    else if (isemptystr(s2v(top - 1)))  \n      cast_void(tostring(L, s2v(top - 2)));  \n    else if (isemptystr(s2v(top - 2))) {  \n      setobjs2s(L, top - 2, top - 1);  \n    }\n    else {\n      size_t tl = vslen(s2v(top - 1));\n      TString *ts;\n      for (n = 1; n < total && tostring(L, s2v(top - n - 1)); n++) {\n        size_t l = vslen(s2v(top - n - 1));\n        if (l_unlikely(l >= (MAX_SIZE/sizeof(char)) - tl))\n          luaG_runerror(L, \"string length overflow\");\n        tl += l;\n      }\n      if (tl <= LUAI_MAXSHORTLEN) {  \n        char buff[LUAI_MAXSHORTLEN];\n        copy2buff(top, n, buff);  \n        ts = luaS_newlstr(L, buff, tl);\n      }\n      else {  \n        ts = luaS_createlngstrobj(L, tl);\n        copy2buff(top, n, getstr(ts));\n      }\n      setsvalue2s(L, top - n, ts);  \n    }\n    total -= n-1;  \n    L->top -= n-1;  \n  } while (total > 1);  \n}", "target": 1}
{"code": "static inline void pfkey_hdr_dup(struct sadb_msg *new,\n\t\t\t\t const struct sadb_msg *orig)\n{\n\t*new = *orig;\n}", "target": 0}
{"code": "h2_end_headers(struct worker *wrk, struct h2_sess *h2,\n    struct req *req, struct h2_req *r2)\n{\n\th2_error h2e;\n\tASSERT_RXTHR(h2);\n\tassert(r2->state == H2_S_OPEN);\n\th2e = h2h_decode_fini(h2);\n\th2->new_req = NULL;\n\tif (h2e != NULL) {\n\t\tLck_Lock(&h2->sess->mtx);\n\t\tVSLb(h2->vsl, SLT_Debug, \"HPACK/FINI %s\", h2e->name);\n\t\tLck_Unlock(&h2->sess->mtx);\n\t\tassert(!WS_IsReserved(r2->req->ws));\n\t\th2_del_req(wrk, r2);\n\t\treturn (h2e);\n\t}\n\tVSLb_ts_req(req, \"Req\", req->t_req);\n\thttp_CollectHdrSep(req->http, H_Cookie, \"; \");\t\n\tif (req->req_body_status == NULL) {\n\t\tif (!http_GetHdr(req->http, H_Content_Length, NULL))\n\t\t\treq->req_body_status = BS_EOF;\n\t\telse\n\t\t\treq->req_body_status = BS_LENGTH;\n\t} else {\n\t\tassert (req->req_body_status == BS_NONE);\n\t\tr2->state = H2_S_CLOS_REM;\n\t\tif (http_GetContentLength(req->http) > 0)\n\t\t\treturn (H2CE_PROTOCOL_ERROR); \n\t}\n\tif (req->http->hd[HTTP_HDR_METHOD].b == NULL) {\n\t\tVSLb(h2->vsl, SLT_Debug, \"Missing :method\");\n\t\treturn (H2SE_PROTOCOL_ERROR); \n\t}\n\tif (req->http->hd[HTTP_HDR_URL].b == NULL) {\n\t\tVSLb(h2->vsl, SLT_Debug, \"Missing :path\");\n\t\treturn (H2SE_PROTOCOL_ERROR); \n\t}\n\tAN(req->http->hd[HTTP_HDR_PROTO].b);\n\treq->req_step = R_STP_TRANSPORT;\n\treq->task->func = h2_do_req;\n\treq->task->priv = req;\n\tr2->scheduled = 1;\n\tif (Pool_Task(wrk->pool, req->task, TASK_QUEUE_STR) != 0) {\n\t\tr2->scheduled = 0;\n\t\tr2->state = H2_S_CLOSED;\n\t\treturn (H2SE_REFUSED_STREAM); \n\t}\n\treturn (0);\n}", "target": 1}
{"code": "static void fuse_delete_context_key(void)\n{\n    pthread_mutex_lock(&fuse_context_lock);\n    fuse_context_ref--;\n    if (!fuse_context_ref) {\n        free(pthread_getspecific(fuse_context_key));\n        pthread_key_delete(fuse_context_key);\n    }\n    pthread_mutex_unlock(&fuse_context_lock);\n}", "target": 0}
{"code": "void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data;\n\tvoid *vapic;\n\tif (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))\n\t\tapic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\tvapic = kmap_atomic(vcpu->arch.apic->vapic_page);\n\tdata = *(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr));\n\tkunmap_atomic(vapic);\n\tapic_set_tpr(vcpu->arch.apic, data & 0xff);\n}", "target": 1}
{"code": "static int fetch_objects(struct repository *repo,\n\t\t\t const char *remote_name,\n\t\t\t const struct object_id *oids,\n\t\t\t int oid_nr)\n{\n\tstruct child_process child = CHILD_PROCESS_INIT;\n\tint i;\n\tFILE *child_in;\n\tif (git_env_bool(\"GIT_NO_LAZY_FETCH\", 0)) {\n\t\tstatic int warning_shown;\n\t\tif (!warning_shown) {\n\t\t\twarning_shown = 1;\n\t\t\twarning(_(\"lazy fetching disabled; some objects may not be available\"));\n\t\t}\n\t\treturn -1;\n\t}\n\tchild.git_cmd = 1;\n\tchild.in = -1;\n\tif (repo != the_repository)\n\t\tprepare_other_repo_env(&child.env, repo->gitdir);\n\tstrvec_pushl(&child.args, \"-c\", \"fetch.negotiationAlgorithm=noop\",\n\t\t     \"fetch\", remote_name, \"--no-tags\",\n\t\t     \"--no-write-fetch-head\", \"--recurse-submodules=no\",\n\t\t     \"--filter=blob:none\", \"--stdin\", NULL);\n\tif (start_command(&child))\n\t\tdie(_(\"promisor-remote: unable to fork off fetch subprocess\"));\n\tchild_in = xfdopen(child.in, \"w\");\n\ttrace2_data_intmax(\"promisor\", repo, \"fetch_count\", oid_nr);\n\tfor (i = 0; i < oid_nr; i++) {\n\t\tif (fputs(oid_to_hex(&oids[i]), child_in) < 0)\n\t\t\tdie_errno(_(\"promisor-remote: could not write to fetch subprocess\"));\n\t\tif (fputc('\\n', child_in) < 0)\n\t\t\tdie_errno(_(\"promisor-remote: could not write to fetch subprocess\"));\n\t}\n\tif (fclose(child_in) < 0)\n\t\tdie_errno(_(\"promisor-remote: could not close stdin to fetch subprocess\"));\n\treturn finish_command(&child) ? -1 : 0;\n}", "target": 0}
{"code": "pthread_mutex_unlock(pthread_mutex_t *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}", "target": 1}
{"code": "static int udf_symlink_filler(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct buffer_head *bh = NULL;\n\tunsigned char *symlink;\n\tint err = -EIO;\n\tunsigned char *p = kmap(page);\n\tstruct udf_inode_info *iinfo;\n\tuint32_t pos;\n\tiinfo = UDF_I(inode);\n\tpos = udf_block_map(inode, 0);\n\tdown_read(&iinfo->i_data_sem);\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tsymlink = iinfo->i_ext.i_data + iinfo->i_lenEAttr;\n\t} else {\n\t\tbh = sb_bread(inode->i_sb, pos);\n\t\tif (!bh)\n\t\t\tgoto out;\n\t\tsymlink = bh->b_data;\n\t}\n\tudf_pc_to_char(inode->i_sb, symlink, inode->i_size, p);\n\tbrelse(bh);\n\tup_read(&iinfo->i_data_sem);\n\tSetPageUptodate(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn 0;\nout:\n\tup_read(&iinfo->i_data_sem);\n\tSetPageError(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn err;\n}", "target": 1}
{"code": "static optional<Principal> parse_principal(CephContext* cct, TokenID t,\n\t\t\t\t    string&& s) {\n  if ((t == TokenID::AWS) && (s == \"*\")) {\n    return Principal::wildcard();\n  } else if (t == TokenID::CanonicalUser) {\n  } else if (t == TokenID::AWS) {\n    auto a = ARN::parse(s);\n    if (!a) {\n      if (std::none_of(s.begin(), s.end(),\n\t\t       [](const char& c) {\n\t\t\t return (c == ':') || (c == '/');\n\t\t       })) {\n\treturn Principal::tenant(std::move(s));\n      }\n    }\n    if (a->resource == \"root\") {\n      return Principal::tenant(std::move(a->account));\n    }\n    static const char rx_str[] = \"([^/]*)/(.*)\";\n    static const regex rx(rx_str, sizeof(rx_str) - 1,\n\t\t\t  ECMAScript | optimize);\n    smatch match;\n    if (regex_match(a->resource, match, rx)) {\n      ceph_assert(match.size() == 3);\n      if (match[1] == \"user\") {\n\treturn Principal::user(std::move(a->account),\n\t\t\t       match[2]);\n      }\n      if (match[1] == \"role\") {\n\treturn Principal::role(std::move(a->account),\n\t\t\t       match[2]);\n      }\n    }\n  }\n  ldout(cct, 0) << \"Supplied principal is discarded: \" << s << dendl;\n  return boost::none;\n}", "target": 1}
{"code": "static void lwp_write_int32(FILE *fout, int32_t d) {\n  fwrite(&d, sizeof(d), 1, fout);\n  fflush(fout);\n}", "target": 0}
{"code": "unsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source)\n{\n  lodepng_info_cleanup(dest);\n  *dest = *source;\n  lodepng_color_mode_init(&dest->color);\n  CERROR_TRY_RETURN(lodepng_color_mode_copy(&dest->color, &source->color));\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n  CERROR_TRY_RETURN(LodePNGText_copy(dest, source));\n  CERROR_TRY_RETURN(LodePNGIText_copy(dest, source));\n  LodePNGUnknownChunks_init(dest);\n  CERROR_TRY_RETURN(LodePNGUnknownChunks_copy(dest, source));\n#endif \n  return 0;\n}", "target": 0}
{"code": "static struct clock_source *dce120_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(*clk_src), GFP_KERNEL);\n\tif (!clk_src)\n\t\treturn NULL;\n\tif (dce112_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\t\t     regs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 0}
{"code": "set_lenIV(const char* line)\n{\n  char *p = strstr(line, \"/lenIV \");\n  if (p && (isdigit((unsigned char) p[7]) || p[7] == '+' || p[7] == '-')) {\n    lenIV = atoi(p + 7);\n  }\n}", "target": 0}
{"code": "static inline void init_fs_pin(struct fs_pin *p, void (*kill)(struct fs_pin *))\n{\n\tinit_waitqueue_head(&p->wait);\n\tINIT_HLIST_NODE(&p->s_list);\n\tINIT_HLIST_NODE(&p->m_list);\n\tp->kill = kill;\n}", "target": 0}
{"code": "PLT_HttpServer::ServeFile(const NPT_HttpRequest&        request, \n                          const NPT_HttpRequestContext& context,\n                          NPT_HttpResponse&             response,\n                          NPT_String                    file_path) \n{\n    NPT_InputStreamReference stream;\n    NPT_File                 file(file_path);\n    NPT_FileInfo             file_info;\n    if ((file_path.Find(\"/..\") >= 0) || (file_path.Find(\"\\\\..\") >= 0) ||\n        NPT_FAILED(NPT_File::GetInfo(file_path, &file_info))) {\n        return NPT_ERROR_NO_SUCH_ITEM;\n    }\n    const NPT_String* range_spec = request.GetHeaders().GetHeaderValue(NPT_HTTP_HEADER_RANGE);\n    NPT_DateTime  date;\n    NPT_TimeStamp timestamp;\n    if (NPT_SUCCEEDED(PLT_UPnPMessageHelper::GetIfModifiedSince((NPT_HttpMessage&)request, date)) &&\n        !range_spec) {\n        date.ToTimeStamp(timestamp);\n        NPT_LOG_INFO_5(\"File %s timestamps: request=%d (%s) vs file=%d (%s)\", \n                       (const char*)request.GetUrl().GetPath(),\n                       (NPT_UInt32)timestamp.ToSeconds(),\n                       (const char*)date.ToString(),\n                       (NPT_UInt32)file_info.m_ModificationTime,\n                       (const char*)NPT_DateTime(file_info.m_ModificationTime).ToString());\n        if (timestamp >= file_info.m_ModificationTime) {\n            NPT_LOG_FINE_1(\"Returning 304 for %s\", request.GetUrl().GetPath().GetChars());\n            response.SetStatus(304, \"Not Modified\", NPT_HTTP_PROTOCOL_1_1);\n            return NPT_SUCCESS;\n        }\n    }\n    if (NPT_FAILED(file.Open(NPT_FILE_OPEN_MODE_READ)) || \n        NPT_FAILED(file.GetInputStream(stream))        ||\n        stream.IsNull()) {\n        return NPT_ERROR_NO_SUCH_ITEM;\n    }\n    if (file_info.m_ModificationTime) {\n        NPT_DateTime last_modified = NPT_DateTime(file_info.m_ModificationTime);\n        response.GetHeaders().SetHeader(\"Last-Modified\", last_modified.ToString(NPT_DateTime::FORMAT_RFC_1123), true);\n        response.GetHeaders().SetHeader(\"Cache-Control\", \"max-age=0,must-revalidate\", true);\n    }\n    PLT_HttpRequestContext tmp_context(request, context);\n    return ServeStream(request, context, response, stream, PLT_MimeType::GetMimeType(file_path, &tmp_context));\n}", "target": 1}
{"code": "\tEventReturn OnPreCommand(CommandSource &source, Command *command, std::vector<Anope::string> &params) anope_override\n\t{\n\t\tif (command->name == \"nickserv/confirm\" && params.size() > 1)\n\t\t{\n\t\t\tif (Anope::ReadOnly)\n\t\t\t{\n\t\t\t\tsource.Reply(READ_ONLY_MODE);\n\t\t\t\treturn EVENT_STOP;\n\t\t\t}\n\t\t\tNickAlias *na = NickAlias::Find(params[0]);\n\t\t\tResetInfo *ri = na ? reset.Get(na->nc) : NULL;\n\t\t\tif (na && ri)\n\t\t\t{\n\t\t\t\tNickCore *nc = na->nc;\n\t\t\t\tif (nc->HasExt(\"NS_SUSPENDED\"))\n\t\t\t\t{\n\t\t\t\t\tsource.Reply(NICK_X_SUSPENDED, nc->display.c_str());\n\t\t\t\t\treturn EVENT_STOP;\n\t\t\t\t}\n\t\t\t\tconst Anope::string &passcode = params[1];\n\t\t\t\tif (ri->time < Anope::CurTime - 3600)\n\t\t\t\t{\n\t\t\t\t\treset.Unset(nc);\n\t\t\t\t\tsource.Reply(_(\"Your password reset request has expired.\"));\n\t\t\t\t}\n\t\t\t\telse if (passcode.equals_cs(ri->code))\n\t\t\t\t{\n\t\t\t\t\treset.Unset(nc);\n\t\t\t\t\tnc->Shrink<bool>(\"UNCONFIRMED\");\n\t\t\t\t\tLog(LOG_COMMAND, source, &commandnsresetpass) << \"to confirm RESETPASS and forcefully identify as \" << na->nick;\n\t\t\t\t\tif (source.GetUser())\n\t\t\t\t\t{\n\t\t\t\t\t\tsource.GetUser()->Identify(na);\n\t\t\t\t\t}\n\t\t\t\t\tsource.Reply(_(\"You are now identified for your nick. Change your password now.\"));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn EVENT_CONTINUE;\n\t\t\t\treturn EVENT_STOP;\n\t\t\t}\n\t\t}\n\t\treturn EVENT_CONTINUE;\n\t}", "target": 0}
{"code": "parse_SET_IP_ECN(char *arg, const struct ofpact_parse_params *pp)\n{\n    uint8_t ecn;\n    char *error;\n    error = str_to_u8(arg, \"ECN\", &ecn);\n    if (error) {\n        return error;\n    }\n    if (ecn & ~IP_ECN_MASK) {\n        return xasprintf(\"%s: not a valid ECN\", arg);\n    }\n    ofpact_put_SET_IP_ECN(pp->ofpacts)->ecn = ecn;\n    return NULL;\n}", "target": 0}
{"code": "    bool replaceHostInUri( std::string& uri, const char* szHost, const char* szPort ) {\n        su_home_t* home = theOneAndOnlyController->getHome() ;\n        char *s ;\n        char buf[255];\n        char obuf[255] ;\n        char hp[64] ;\n        char const *display = NULL;\n        url_t url[1];\n        msg_param_t const *params = NULL;\n        char const *comment = NULL;\n        int rc ;\n        s = strncpy( buf, uri.c_str(), 255 ) ;\n        rc = sip_name_addr_d(home, &s, &display, url, &params, &comment) ;\n        if( rc < 0 ) {  \n            return false ;\n        }\n        url->url_host = szHost ;\n        url->url_port = szPort ;\n        int nChars = sip_name_addr_e(obuf, 255, 0, display, 1, url, params, comment) ;\n        if( params ) {\n            su_free(home, (void *) params) ;\n        }\n        if( nChars <= 0 ) {\n            return false ;\n        }\n        uri.assign( obuf ) ;\n        return true ;\n    }", "target": 1}
{"code": "TfLiteStatus GenericPrepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  if (!IsSupportedType(input->type)) {\n    TF_LITE_KERNEL_LOG(context, \"Input data type %s (%d) is not supported.\",\n                       TfLiteTypeGetName(input->type), input->type);\n    return kTfLiteError;\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "HMAC_SHA256_Init(struct HMAC_SHA256_CTX * ctx, const void * _K, size_t Klen)\n{\n  unsigned char pad[64];\n  unsigned char khash[32];\n  const unsigned char * K = (unsigned char *) _K;\n  size_t i;\n  if (Klen > 64) {\n    SHA256_Init(&ctx->ictx);\n    scrypt_SHA256_Update(&ctx->ictx, K, Klen);\n    scrypt_SHA256_Final(khash, &ctx->ictx);\n    K = khash;\n    Klen = 32;\n  }\n  SHA256_Init(&ctx->ictx);\n  memset(pad, 0x36, 64);\n  for (i = 0; i < Klen; i++)\n    pad[i] ^= K[i];\n  scrypt_SHA256_Update(&ctx->ictx, pad, 64);\n  SHA256_Init(&ctx->octx);\n  memset(pad, 0x5c, 64);\n  for (i = 0; i < Klen; i++)\n    pad[i] ^= K[i];\n  scrypt_SHA256_Update(&ctx->octx, pad, 64);\n  memset(khash, 0, 32);\n}", "target": 1}
{"code": "static int logi_dj_ll_raw_request(struct hid_device *hid,\n\t\t\t\t  unsigned char reportnum, __u8 *buf,\n\t\t\t\t  size_t count, unsigned char report_type,\n\t\t\t\t  int reqtype)\n{\n\tstruct dj_device *djdev = hid->driver_data;\n\tstruct dj_receiver_dev *djrcv_dev = djdev->dj_receiver_dev;\n\tu8 *out_buf;\n\tint ret;\n\tif (buf[0] != REPORT_TYPE_LEDS)\n\t\treturn -EINVAL;\n\tout_buf = kzalloc(DJREPORT_SHORT_LENGTH, GFP_ATOMIC);\n\tif (!out_buf)\n\t\treturn -ENOMEM;\n\tif (count < DJREPORT_SHORT_LENGTH - 2)\n\t\tcount = DJREPORT_SHORT_LENGTH - 2;\n\tout_buf[0] = REPORT_ID_DJ_SHORT;\n\tout_buf[1] = djdev->device_index;\n\tmemcpy(out_buf + 2, buf, count);\n\tret = hid_hw_raw_request(djrcv_dev->hdev, out_buf[0], out_buf,\n\t\tDJREPORT_SHORT_LENGTH, report_type, reqtype);\n\tkfree(out_buf);\n\treturn ret;\n}", "target": 1}
{"code": "static int adpt_system_info(void __user *buffer)\n{\n\tsysInfo_S si;\n\tmemset(&si, 0, sizeof(si));\n\tsi.osType = OS_LINUX;\n\tsi.osMajorVersion = 0;\n\tsi.osMinorVersion = 0;\n\tsi.osRevision = 0;\n\tsi.busType = SI_PCI_BUS;\n\tsi.processorFamily = DPTI_sig.dsProcessorFamily;\n#if defined __i386__\n\tadpt_i386_info(&si);\n#elif defined (__ia64__)\n\tadpt_ia64_info(&si);\n#elif defined(__sparc__)\n\tadpt_sparc_info(&si);\n#elif defined (__alpha__)\n\tadpt_alpha_info(&si);\n#else\n\tsi.processorType = 0xff ;\n#endif\n\tif (copy_to_user(buffer, &si, sizeof(si))){\n\t\tprintk(KERN_WARNING\"dpti: Could not copy buffer TO user\\n\");\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "build_principal_va(krb5_context context, krb5_principal princ,\n                   unsigned int rlen, const char *realm, va_list ap)\n{\n    krb5_error_code retval = 0;\n    char *r = NULL;\n    krb5_data *data = NULL;\n    krb5_int32 count = 0;\n    krb5_int32 size = 2;  \n    char *component = NULL;\n    data = malloc(size * sizeof(krb5_data));\n    if (!data) { retval = ENOMEM; }\n    if (!retval) {\n        r = strdup(realm);\n        if (!r) { retval = ENOMEM; }\n    }\n    while (!retval && (component = va_arg(ap, char *))) {\n        if (count == size) {\n            krb5_data *new_data = NULL;\n            size *= 2;\n            new_data = realloc(data, size * sizeof(krb5_data));\n            if (new_data) {\n                data = new_data;\n            } else {\n                retval = ENOMEM;\n            }\n        }\n        if (!retval) {\n            data[count].length = strlen(component);\n            data[count].data = strdup(component);\n            if (!data[count].data) { retval = ENOMEM; }\n            count++;\n        }\n    }\n    if (!retval) {\n        princ->type = KRB5_NT_UNKNOWN;\n        princ->magic = KV5M_PRINCIPAL;\n        princ->realm = make_data(r, rlen);\n        princ->data = data;\n        princ->length = count;\n        r = NULL;    \n        data = NULL; \n    }\n    if (data) {\n        while (--count >= 0) {\n            free(data[count].data);\n        }\n        free(data);\n    }\n    free(r);\n    return retval;\n}", "target": 1}
{"code": "static int oidc_cache_crypto_encrypt_impl(request_rec *r,\n\t\tunsigned char *plaintext, int plaintext_len, const unsigned char *aad,\n\t\tint aad_len, unsigned char *key, const unsigned char *iv, int iv_len,\n\t\tunsigned char *ciphertext, const unsigned char *tag, int tag_len) {\n\tEVP_CIPHER_CTX *ctx;\n\tint len;\n\tint ciphertext_len;\n\tif (!(ctx = EVP_CIPHER_CTX_new())) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_CIPHER_CTX_new\");\n\t\treturn -1;\n\t}\n\tif (!EVP_EncryptInit_ex(ctx, OIDC_CACHE_CIPHER, NULL, NULL, NULL)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_EncryptInit_ex\");\n\t\treturn -1;\n\t}\n\tif (!EVP_CIPHER_CTX_ctrl(ctx, OIDC_CACHE_CRYPTO_SET_IVLEN, iv_len, NULL)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_CIPHER_CTX_ctrl\");\n\t\treturn -1;\n\t}\n\tif (!EVP_EncryptInit_ex(ctx, NULL, NULL, key, iv)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_EncryptInit_ex\");\n\t\treturn -1;\n\t}\n\tif (!EVP_EncryptUpdate(ctx, NULL, &len, aad, aad_len)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_DecryptUpdate aad: aad_len=%d\",\n\t\t\t\taad_len);\n\t\treturn -1;\n\t}\n\tif (!EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, plaintext_len)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_EncryptUpdate ciphertext\");\n\t\treturn -1;\n\t}\n\tciphertext_len = len;\n\tif (!EVP_EncryptFinal_ex(ctx, ciphertext + len, &len)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_EncryptFinal_ex\");\n\t\treturn -1;\n\t}\n\tciphertext_len += len;\n\tif (!EVP_CIPHER_CTX_ctrl(ctx, OIDC_CACHE_CRYPTO_GET_TAG, tag_len,\n\t\t\t(void *) tag)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_CIPHER_CTX_ctrl\");\n\t\treturn -1;\n\t}\n\tEVP_CIPHER_CTX_free(ctx);\n\treturn ciphertext_len;\n}", "target": 1}
{"code": "static int nfc_llcp_build_gb(struct nfc_llcp_local *local)\n{\n\tu8 *gb_cur, *version_tlv, version, version_length;\n\tu8 *lto_tlv, lto_length;\n\tu8 *wks_tlv, wks_length;\n\tu8 *miux_tlv, miux_length;\n\t__be16 wks = cpu_to_be16(local->local_wks);\n\tu8 gb_len = 0;\n\tint ret = 0;\n\tversion = LLCP_VERSION_11;\n\tversion_tlv = nfc_llcp_build_tlv(LLCP_TLV_VERSION, &version,\n\t\t\t\t\t 1, &version_length);\n\tgb_len += version_length;\n\tlto_tlv = nfc_llcp_build_tlv(LLCP_TLV_LTO, &local->lto, 1, &lto_length);\n\tgb_len += lto_length;\n\tpr_debug(\"Local wks 0x%lx\\n\", local->local_wks);\n\twks_tlv = nfc_llcp_build_tlv(LLCP_TLV_WKS, (u8 *)&wks, 2, &wks_length);\n\tgb_len += wks_length;\n\tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&local->miux, 0,\n\t\t\t\t      &miux_length);\n\tgb_len += miux_length;\n\tgb_len += ARRAY_SIZE(llcp_magic);\n\tif (gb_len > NFC_MAX_GT_LEN) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tgb_cur = local->gb;\n\tmemcpy(gb_cur, llcp_magic, ARRAY_SIZE(llcp_magic));\n\tgb_cur += ARRAY_SIZE(llcp_magic);\n\tmemcpy(gb_cur, version_tlv, version_length);\n\tgb_cur += version_length;\n\tmemcpy(gb_cur, lto_tlv, lto_length);\n\tgb_cur += lto_length;\n\tmemcpy(gb_cur, wks_tlv, wks_length);\n\tgb_cur += wks_length;\n\tmemcpy(gb_cur, miux_tlv, miux_length);\n\tgb_cur += miux_length;\n\tlocal->gb_len = gb_len;\nout:\n\tkfree(version_tlv);\n\tkfree(lto_tlv);\n\tkfree(wks_tlv);\n\tkfree(miux_tlv);\n\treturn ret;\n}", "target": 1}
{"code": "spnego_gss_wrap_aead(OM_uint32 *minor_status,\n\t\t     gss_ctx_id_t context_handle,\n\t\t     int conf_req_flag,\n\t\t     gss_qop_t qop_req,\n\t\t     gss_buffer_t input_assoc_buffer,\n\t\t     gss_buffer_t input_payload_buffer,\n\t\t     int *conf_state,\n\t\t     gss_buffer_t output_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_aead(minor_status,\n\t\t\t    context_handle,\n\t\t\t    conf_req_flag,\n\t\t\t    qop_req,\n\t\t\t    input_assoc_buffer,\n\t\t\t    input_payload_buffer,\n\t\t\t    conf_state,\n\t\t\t    output_message_buffer);\n\treturn (ret);\n}", "target": 1}
{"code": "    std::ostream& DataValue::write(std::ostream& os) const\n    {\n        std::vector<byte>::size_type end = value_.size();\n        for (std::vector<byte>::size_type i = 0; i != end; ++i) {\n            os << static_cast<int>(value_[i]);\n            if (i < end - 1) os << \" \";\n        }\n        return os;\n    }", "target": 0}
{"code": "int inet6_sk_rebuild_header(struct sock *sk)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct dst_entry *dst;\n\tdst = __sk_dst_check(sk, np->dst_cookie);\n\tif (!dst) {\n\t\tstruct inet_sock *inet = inet_sk(sk);\n\t\tstruct in6_addr *final_p, final;\n\t\tstruct flowi6 fl6;\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.flowi6_proto = sk->sk_protocol;\n\t\tfl6.daddr = sk->sk_v6_daddr;\n\t\tfl6.saddr = np->saddr;\n\t\tfl6.flowlabel = np->flow_label;\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\t\tfl6.flowi6_mark = sk->sk_mark;\n\t\tfl6.fl6_dport = inet->inet_dport;\n\t\tfl6.fl6_sport = inet->inet_sport;\n\t\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\t\tfinal_p = fl6_update_dst(&fl6, np->opt, &final);\n\t\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\t\tif (IS_ERR(dst)) {\n\t\t\tsk->sk_route_caps = 0;\n\t\t\tsk->sk_err_soft = -PTR_ERR(dst);\n\t\t\treturn PTR_ERR(dst);\n\t\t}\n\t\t__ip6_dst_store(sk, dst, NULL, NULL);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "Jsi_RC jsi_evalcode(jsi_Pstate *ps, Jsi_Func *func, Jsi_OpCodes *opcodes, \n         jsi_ScopeChain *scope, Jsi_Value *fargs,\n         Jsi_Value *_this,\n         Jsi_Value **vret)\n{\n    Jsi_Interp *interp = ps->interp;\n    if (interp->exited)\n        return JSI_ERROR;\n    Jsi_RC rc;\n    jsi_Frame frame = *interp->framePtr;\n    frame.parent = interp->framePtr;\n    interp->framePtr = &frame;\n    frame.parent->child = interp->framePtr = &frame;\n    frame.ps = ps;\n    frame.ingsc = scope;\n    frame.incsc = fargs;\n    frame.inthis = _this;\n    frame.opcodes = opcodes;\n    frame.fileName = ((func && func->script)?func->script:interp->curFile);\n    frame.funcName = interp->curFunction;\n    frame.dirName = interp->curDir;\n    if (frame.fileName && frame.fileName == frame.parent->fileName)\n        frame.logflag = frame.parent->logflag;\n    else\n        frame.logflag = 0;\n    frame.level = frame.parent->level+1;\n    frame.evalFuncPtr = func;\n    frame.arguments = NULL;\n    if (interp->curIp)\n        frame.parent->line = interp->curIp->Line;\n    frame.ip = interp->curIp;\n    interp->refCount++;\n    interp->level++;\n    Jsi_IncrRefCount(interp, fargs);\n    rc = jsi_evalcode_sub(ps, opcodes, scope, fargs, _this, *vret);\n    Jsi_DecrRefCount(interp, fargs);\n    if (interp->didReturn == 0 && !interp->exited) {\n        if ((interp->evalFlags&JSI_EVAL_RETURN)==0)\n            Jsi_ValueMakeUndef(interp, vret);\n    }\n    if (frame.arguments)\n        Jsi_DecrRefCount(interp, frame.arguments);\n    interp->didReturn = 0;\n    interp->refCount--;\n    interp->level--;\n    interp->framePtr = frame.parent;\n    interp->framePtr->child = NULL;\n    interp->curIp = frame.ip;\n    if (interp->exited)\n        rc = JSI_ERROR;\n    return rc;\n}", "target": 1}
{"code": "int prepare_binprm(struct linux_binprm *bprm)\n{\n\tstruct inode *inode = file_inode(bprm->file);\n\tumode_t mode = inode->i_mode;\n\tint retval;\n\tbprm->cred->euid = current_euid();\n\tbprm->cred->egid = current_egid();\n\tif (!(bprm->file->f_path.mnt->mnt_flags & MNT_NOSUID) &&\n\t    !task_no_new_privs(current) &&\n\t    kuid_has_mapping(bprm->cred->user_ns, inode->i_uid) &&\n\t    kgid_has_mapping(bprm->cred->user_ns, inode->i_gid)) {\n\t\tif (mode & S_ISUID) {\n\t\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\t\tbprm->cred->euid = inode->i_uid;\n\t\t}\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\t\tbprm->cred->egid = inode->i_gid;\n\t\t}\n\t}\n\tretval = security_bprm_set_creds(bprm);\n\tif (retval)\n\t\treturn retval;\n\tbprm->cred_prepared = 1;\n\tmemset(bprm->buf, 0, BINPRM_BUF_SIZE);\n\treturn kernel_read(bprm->file, 0, bprm->buf, BINPRM_BUF_SIZE);\n}", "target": 1}
{"code": "static int inet_sk_reselect_saddr(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\t__be32 old_saddr = inet->inet_saddr;\n\t__be32 daddr = inet->inet_daddr;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\t__be32 new_saddr;\n\tif (inet->opt && inet->opt->srr)\n\t\tdaddr = inet->opt->faddr;\n\trt = ip_route_connect(&fl4, daddr, 0, RT_CONN_FLAGS(sk),\n\t\t\t      sk->sk_bound_dev_if, sk->sk_protocol,\n\t\t\t      inet->inet_sport, inet->inet_dport, sk, false);\n\tif (IS_ERR(rt))\n\t\treturn PTR_ERR(rt);\n\tsk_setup_caps(sk, &rt->dst);\n\tnew_saddr = rt->rt_src;\n\tif (new_saddr == old_saddr)\n\t\treturn 0;\n\tif (sysctl_ip_dynaddr > 1) {\n\t\tprintk(KERN_INFO \"%s(): shifting inet->saddr from %pI4 to %pI4\\n\",\n\t\t       __func__, &old_saddr, &new_saddr);\n\t}\n\tinet->inet_saddr = inet->inet_rcv_saddr = new_saddr;\n\t__sk_prot_rehash(sk);\n\treturn 0;\n}", "target": 1}
{"code": "ev_archive_init (EvArchive *archive)\n{\n}", "target": 0}
{"code": "static int io_register_personality(struct io_ring_ctx *ctx)\n{\n\tconst struct cred *creds;\n\tu32 id;\n\tint ret;\n\tcreds = get_current_cred();\n\tret = xa_alloc_cyclic(&ctx->personalities, &id, (void *)creds,\n\t\t\tXA_LIMIT(0, USHRT_MAX), &ctx->pers_next, GFP_KERNEL);\n\tif (!ret)\n\t\treturn id;\n\tput_cred(creds);\n\treturn ret;", "target": 1}
{"code": "_PUBLIC_ char *fgets_slash(char *s2,int maxlen,XFILE *f)\n{\n  char *s=s2;\n  int len = 0;\n  int c;\n  bool start_of_line = true;\n  if (x_feof(f))\n    return(NULL);\n  if (maxlen <2) return(NULL);\n  if (!s2)\n    {\n      maxlen = MIN(maxlen,8);\n      s = (char *)malloc(maxlen);\n    }\n  if (!s) return(NULL);\n  *s = 0;\n  while (len < maxlen-1)\n    {\n      c = x_getc(f);\n      switch (c)\n\t{\n\tcase '\\r':\n\t  break;\n\tcase '\\n':\n\t  while (len > 0 && s[len-1] == ' ')\n\t    {\n\t      s[--len] = 0;\n\t    }\n\t  if (len > 0 && s[len-1] == '\\\\')\n\t    {\n\t      s[--len] = 0;\n\t      start_of_line = true;\n\t      break;\n\t    }\n\t  return(s);\n\tcase EOF:\n\t  if (len <= 0 && !s2) \n\t    SAFE_FREE(s);\n\t  return(len>0?s:NULL);\n\tcase ' ':\n\t  if (start_of_line)\n\t    break;\n\tdefault:\n\t  start_of_line = false;\n\t  s[len++] = c;\n\t  s[len] = 0;\n\t}\n      if (!s2 && len > maxlen-3)\n\t{\n\t  char *t;\n\t  maxlen *= 2;\n\t  t = realloc_p(s, char, maxlen);\n\t  if (!t) {\n\t    DEBUG(0,(\"fgets_slash: failed to expand buffer!\\n\"));\n\t    SAFE_FREE(s);\n\t    return(NULL);\n\t  } else s = t;\n\t}\n    }\n  return(s);\n}", "target": 0}
{"code": "htmlGetText(tree_t *t)\t\t\n{\n  uchar\t\t*s,\t\t\n\t\t*s2,\t\t\n\t\t*tdata = NULL,\t\n\t\t*talloc = NULL;\t\n  size_t\tslen,\t\t\n\t\ttlen;\t\t\n  slen = 0;\n  s    = NULL;\n  while (t != NULL)\n  {\n    if (t->child)\n      tdata = talloc = htmlGetText(t->child);\n    else\n      tdata = t->data;\n    if (tdata != NULL)\n    {\n      tlen = strlen((char *)tdata);\n      if (s)\n        s2 = (uchar *)realloc(s, 1 + slen + tlen);\n      else\n        s2 = (uchar *)malloc(1 + tlen);\n      if (!s2)\n        break;\n      s = s2;\n      memcpy((char *)s + slen, (char *)tdata, tlen);\n      slen += tlen;\n      if (talloc)\n      {\n\tfree(talloc);\n\ttalloc = NULL;\n      }\n    }\n    t = t->next;\n  }\n  if (slen)\n    s[slen] = '\\0';\n  if (talloc)\n    free(talloc);\n  return (s);\n}", "target": 1}
{"code": "int jp2_box_put(jp2_box_t *box, jas_stream_t *out)\n{\n\tjas_stream_t *tmpstream;\n\tbool extlen;\n\tbool dataflag;\n\ttmpstream = 0;\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (box->ops->putdata) {\n\t\t\tif ((*box->ops->putdata)(box, tmpstream)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tbox->len = jas_stream_tell(tmpstream) + JP2_BOX_HDRLEN(false);\n\t\tjas_stream_rewind(tmpstream);\n\t}\n\textlen = (box->len >= (((uint_fast64_t)1) << 32)) != 0;\n\tif (jp2_putuint32(out, extlen ? 1 : box->len)) {\n\t\tgoto error;\n\t}\n\tif (jp2_putuint32(out, box->type)) {\n\t\tgoto error;\n\t}\n\tif (extlen) {\n\t\tif (jp2_putuint64(out, box->len)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\tif (dataflag) {\n\t\tif (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\nerror:\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn -1;\n}", "target": 1}
{"code": "SWTPM_NVRAM_CheckHeader(unsigned char *data, uint32_t length,\n                        uint32_t *dataoffset, uint16_t *hdrflags,\n                        uint8_t *hdrversion, bool quiet)\n{\n    blobheader *bh = (blobheader *)data;\n    if (length < sizeof(bh)) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"not enough bytes for header: %u\\n\", length);\n        return TPM_BAD_PARAMETER;\n    }\n    if (ntohl(bh->totlen) != length) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"broken header: bh->totlen %u != %u\\n\",\n                      htonl(bh->totlen), length);\n        return TPM_BAD_PARAMETER;\n    }\n    if (bh->min_version > BLOB_HEADER_VERSION) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"Minimum required version for the blob is %d, we \"\n                      \"only support version %d\\n\", bh->min_version,\n                      BLOB_HEADER_VERSION);\n        return TPM_BAD_VERSION;\n    }\n    *hdrversion = bh->version;\n    *dataoffset = ntohs(bh->hdrsize);\n    *hdrflags = ntohs(bh->flags);\n    return TPM_SUCCESS;\n}", "target": 1}
{"code": "static bool torture_winbind_struct_netbios_name(struct torture_context *torture)\n{\n\tstruct winbindd_response rep;\n\tconst char *expected;\n\tZERO_STRUCT(rep);\n\ttorture_comment(torture, \"Running WINBINDD_NETBIOS_NAME (struct based)\\n\");\n\tDO_STRUCT_REQ_REP(WINBINDD_NETBIOS_NAME, NULL, &rep);\n\texpected = torture_setting_string(torture,\n\t\t\t\t\t  \"winbindd_netbios_name\",\n\t\t\t\t\t  lpcfg_netbios_name(torture->lp_ctx));\n\texpected = strupper_talloc(torture, expected);\n\ttorture_assert_str_equal(torture,\n\t\t\t\t rep.data.netbios_name, expected,\n\t\t\t\t \"winbindd's netbios name doesn't match\");\n\treturn true;\n}", "target": 0}
{"code": "onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end,\n                OnigCompileInfo* ci, OnigErrorInfo* einfo)\n{\n  int r;\n  UChar *cpat, *cpat_end;\n  if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL;\n  if (ci->pattern_enc != ci->target_enc) {\n    r = conv_encoding(ci->pattern_enc, ci->target_enc, pattern, pattern_end,\n                      &cpat, &cpat_end);\n    if (r != 0) return r;\n  }\n  else {\n    cpat     = (UChar* )pattern;\n    cpat_end = (UChar* )pattern_end;\n  }\n  *reg = (regex_t* )xmalloc(sizeof(regex_t));\n  if (IS_NULL(*reg)) {\n    r = ONIGERR_MEMORY;\n    goto err2;\n  }\n  r = onig_reg_init(*reg, ci->option, ci->case_fold_flag, ci->target_enc,\n                    ci->syntax);\n  if (r != 0) goto err;\n  r = onig_compile(*reg, cpat, cpat_end, einfo);\n  if (r != 0) {\n  err:\n    onig_free(*reg);\n    *reg = NULL;\n  }\n err2:\n  if (cpat != pattern) xfree(cpat);\n  return r;\n}", "target": 1}
{"code": "static int llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t  int *uaddrlen, int peer)\n{\n\tstruct sockaddr_llc sllc;\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tint rc = 0;\n\tmemset(&sllc, 0, sizeof(sllc));\n\tlock_sock(sk);\n\tif (sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\t*uaddrlen = sizeof(sllc);\n\tmemset(uaddr, 0, *uaddrlen);\n\tif (peer) {\n\t\trc = -ENOTCONN;\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\tgoto out;\n\t\tif(llc->dev)\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\tsllc.sllc_sap = llc->daddr.lsap;\n\t\tmemcpy(&sllc.sllc_mac, &llc->daddr.mac, IFHWADDRLEN);\n\t} else {\n\t\trc = -EINVAL;\n\t\tif (!llc->sap)\n\t\t\tgoto out;\n\t\tsllc.sllc_sap = llc->sap->laddr.lsap;\n\t\tif (llc->dev) {\n\t\t\tsllc.sllc_arphrd = llc->dev->type;\n\t\t\tmemcpy(&sllc.sllc_mac, llc->dev->dev_addr,\n\t\t\t       IFHWADDRLEN);\n\t\t}\n\t}\n\trc = 0;\n\tsllc.sllc_family = AF_LLC;\n\tmemcpy(uaddr, &sllc, sizeof(sllc));\nout:\n\trelease_sock(sk);\n\treturn rc;\n}", "target": 1}
{"code": "DefragTracker *DefragGetTrackerFromHash (Packet *p)\n{\n    DefragTracker *dt = NULL;\n    uint32_t key = DefragHashGetKey(p);\n    DefragTrackerHashRow *hb = &defragtracker_hash[key];\n    DRLOCK_LOCK(hb);\n    if (hb->head == NULL) {\n        dt = DefragTrackerGetNew(p);\n        if (dt == NULL) {\n            DRLOCK_UNLOCK(hb);\n            return NULL;\n        }\n        hb->head = dt;\n        hb->tail = dt;\n        DefragTrackerInit(dt,p);\n        DRLOCK_UNLOCK(hb);\n        return dt;\n    }\n    dt = hb->head;\n    if (dt->remove || DefragTrackerCompare(dt, p) == 0) {\n        DefragTracker *pdt = NULL; \n        while (dt) {\n            pdt = dt;\n            dt = dt->hnext;\n            if (dt == NULL) {\n                dt = pdt->hnext = DefragTrackerGetNew(p);\n                if (dt == NULL) {\n                    DRLOCK_UNLOCK(hb);\n                    return NULL;\n                }\n                hb->tail = dt;\n                dt->hprev = pdt;\n                DefragTrackerInit(dt,p);\n                DRLOCK_UNLOCK(hb);\n                return dt;\n            }\n            if (DefragTrackerCompare(dt, p) != 0) {\n                if (dt->hnext) {\n                    dt->hnext->hprev = dt->hprev;\n                }\n                if (dt->hprev) {\n                    dt->hprev->hnext = dt->hnext;\n                }\n                if (dt == hb->tail) {\n                    hb->tail = dt->hprev;\n                }\n                dt->hnext = hb->head;\n                dt->hprev = NULL;\n                hb->head->hprev = dt;\n                hb->head = dt;\n                SCMutexLock(&dt->lock);\n                (void) DefragTrackerIncrUsecnt(dt);\n                DRLOCK_UNLOCK(hb);\n                return dt;\n            }\n        }\n    }\n    SCMutexLock(&dt->lock);\n    (void) DefragTrackerIncrUsecnt(dt);\n    DRLOCK_UNLOCK(hb);\n    return dt;\n}", "target": 1}
{"code": "gopherStart(FwdState * fwd)\n{\n    GopherStateData *gopherState = new GopherStateData(fwd);\n    debugs(10, 3, gopherState->entry->url());\n    ++ statCounter.server.all.requests;\n    ++ statCounter.server.other.requests;\n    gopher_request_parse(fwd->request,\n                         &gopherState->type_id, gopherState->request);\n    comm_add_close_handler(fwd->serverConnection()->fd, gopherStateFree, gopherState);\n    if (((gopherState->type_id == GOPHER_INDEX) || (gopherState->type_id == GOPHER_CSO))\n            && (strchr(gopherState->request, '?') == nullptr)) {\n        gopherMimeCreate(gopherState);\n        if (gopherState->type_id == GOPHER_INDEX) {\n            gopherState->conversion = GopherStateData::HTML_INDEX_PAGE;\n        } else {\n            if (gopherState->type_id == GOPHER_CSO) {\n                gopherState->conversion = GopherStateData::HTML_CSO_PAGE;\n            } else {\n                gopherState->conversion = GopherStateData::HTML_INDEX_PAGE;\n            }\n        }\n        gopherToHTML(gopherState, (char *) nullptr, 0);\n        fwd->markStoredReplyAsWhole(\"gopher instant internal request satisfaction\");\n        fwd->complete();\n        return;\n    }\n    gopherState->serverConn = fwd->serverConnection();\n    gopherSendRequest(fwd->serverConnection()->fd, gopherState);\n    AsyncCall::Pointer timeoutCall = commCbCall(5, 4, \"gopherTimeout\",\n                                     CommTimeoutCbPtrFun(gopherTimeout, gopherState));\n    commSetConnTimeout(fwd->serverConnection(), Config.Timeout.read, timeoutCall);\n}", "target": 1}
{"code": "double AccessibilityUIElement::clickPointY()\n{\n    return 0.0f;\n}", "target": 0}
{"code": "comics_generate_command_lines (ComicsDocument *comics_document, \n\t\t\t       GError         **error)\n{\n\tgchar *quoted_file, *quoted_file_aux;\n\tgchar *quoted_command;\n\tComicBookDecompressType type;\n\ttype = comics_document->command_usage;\n\tcomics_document->regex_arg = command_usage_def[type].regex_arg;\n\tquoted_command = g_shell_quote (comics_document->selected_command);\n\tif (comics_document->regex_arg) {\n\t\tquoted_file = comics_regex_quote (comics_document->archive);\n\t\tquoted_file_aux = g_shell_quote (comics_document->archive);\n\t\tcomics_document->list_command =\n\t\t\t   g_strdup_printf (command_usage_def[type].list,\n\t\t\t                    comics_document->alternative_command,\n\t\t\t                    quoted_file_aux);\n\t\tg_free (quoted_file_aux);\n\t} else {\n\t\tquoted_file = g_shell_quote (comics_document->archive);\n\t\tcomics_document->list_command =\n\t\t\t\tg_strdup_printf (command_usage_def[type].list,\n\t\t\t\t                 quoted_command, quoted_file);\n\t}\n\tcomics_document->extract_command =\n\t\t\t    g_strdup_printf (command_usage_def[type].extract,\n\t\t\t\t             quoted_command);\n\tcomics_document->offset = command_usage_def[type].offset;\n\tif (command_usage_def[type].decompress_tmp) {\n\t\tcomics_document->dir = ev_mkdtemp (\"xreader-comics-XXXXXX\", error);\n                if (comics_document->dir == NULL)\n                        return FALSE;\n\t\tcomics_document->decompress_tmp =\n\t\t\tg_strdup_printf (command_usage_def[type].decompress_tmp, \n\t\t\t\t\t quoted_command, quoted_file,\n\t\t\t\t\t comics_document->dir);\n\t\tg_free (quoted_file);\n\t\tg_free (quoted_command);\n\t\tif (!comics_decompress_temp_dir (comics_document->decompress_tmp,\n\t\t    comics_document->selected_command, error))\n\t\t\treturn FALSE;\n\t\telse\n\t\t\treturn TRUE;\n\t} else {\n\t\tg_free (quoted_file);\n\t\tg_free (quoted_command);\n\t\treturn TRUE;\n\t}\n}", "target": 1}
{"code": "TEST_F(QuicUnencryptedServerTransportTest, DuplicateOneRttWriteCipher) {\n  setupClientReadCodec();\n  recvClientHello();\n  recvClientFinished();\n  loopForWrites();\n  try {\n    recvClientHello();\n    recvClientFinished();\n    FAIL();\n  } catch (const std::runtime_error& ex) {\n    EXPECT_THAT(ex.what(), HasSubstr(\"Crypto error\"));\n  }\n  EXPECT_TRUE(server->isClosed());\n}", "target": 0}
{"code": "crm_recv_remote_msg(void *session, gboolean encrypted)\n{\n    char *reply = NULL;\n    xmlNode *xml = NULL;\n    if (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        reply = cib_recv_tls(session);\n#else\n        CRM_ASSERT(encrypted == FALSE);\n#endif\n    } else {\n        reply = cib_recv_plaintext(GPOINTER_TO_INT(session));\n    }\n    if (reply == NULL || strlen(reply) == 0) {\n        crm_trace(\"Empty reply\");\n    } else {\n        xml = string2xml(reply);\n        if (xml == NULL) {\n            crm_err(\"Couldn't parse: '%.120s'\", reply);\n        }\n    }\n    free(reply);\n    return xml;\n}", "target": 1}
{"code": "void flash_option_bytes_init(int boot_from_dfu)\n{\n    uint32_t val = 0xfffff8aa;\n    if (boot_from_dfu){\n        val &= ~(1<<27); \n    }\n    else {\n        if (solo_is_locked())\n        {\n            val = 0xfffff8cc;\n        }\n    }\n    val &= ~(1<<26); \n    val &= ~(1<<25); \n    val &= ~(1<<24); \n    if (FLASH->OPTR == val)\n    {\n        return;\n    }\n    __disable_irq();\n    while (FLASH->SR & (1<<16))\n        ;\n    flash_unlock();\n    if (FLASH->CR & (1<<30))\n    {\n        FLASH->OPTKEYR = 0x08192A3B;\n        FLASH->OPTKEYR = 0x4C5D6E7F;\n    }\n    FLASH->OPTR =val;\n    FLASH->CR |= (1<<17);\n    while (FLASH->SR & (1<<16))\n        ;\n    flash_lock();\n    __enable_irq();\n}", "target": 1}
{"code": "static int base64decode_block(unsigned char *target, const char *data, size_t data_size)\n{\n\tint w1,w2,w3,w4;\n\tint i;\n\tsize_t n;\n\tif (!data || (data_size <= 0)) {\n\t\treturn 0;\n\t}\n\tn = 0;\n\ti = 0;\n\twhile (n < data_size-3) {\n\t\tw1 = base64_table[(int)data[n]];\n\t\tw2 = base64_table[(int)data[n+1]];\n\t\tw3 = base64_table[(int)data[n+2]];\n\t\tw4 = base64_table[(int)data[n+3]];\n\t\tif (w2 >= 0) {\n\t\t\ttarget[i++] = (char)((w1*4 + (w2 >> 4)) & 255);\n\t\t}\n\t\tif (w3 >= 0) {\n\t\t\ttarget[i++] = (char)((w2*16 + (w3 >> 2)) & 255);\n\t\t}\n\t\tif (w4 >= 0) {\n\t\t\ttarget[i++] = (char)((w3*64 + w4) & 255);\n\t\t}\n\t\tn+=4;\n\t}\n\treturn i;\n}", "target": 1}
{"code": "static int setup_config(int type)\n{\n\tint rv;\n\trv = read_config(cl.configfile, type);\n\tif (rv < 0)\n\t\tgoto out;\n\tif (is_auth_req()) {\n\t\trv = read_authkey();\n\t\tif (rv < 0)\n\t\t\tgoto out;\n#if HAVE_LIBGCRYPT\n\t\tif (!gcry_check_version(NULL)) {\n\t\t\tlog_error(\"gcry_check_version\");\n\t\t\trv = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tgcry_control(GCRYCTL_DISABLE_SECMEM, 0);\n\t\tgcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n\t}\n\tif (cl.type == DAEMON && cl.site[0]) {\n\t\tif (!find_site_by_name(cl.site, &local, 1)) {\n\t\t\tlog_error(\"Cannot find \\\"%s\\\" in the configuration.\",\n\t\t\t\t\tcl.site);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlocal->local = 1;\n\t} else\n\t\tfind_myself(NULL, type == CLIENT || type == GEOSTORE);\n\trv = check_config(type);\n\tif (rv < 0)\n\t\tgoto out;\n\tif (!cl.lockfile[0]) {\n\t\tsnprintf(cl.lockfile, sizeof(cl.lockfile)-1,\n\t\t\t\t\"%s/%s.pid\", BOOTH_RUN_DIR, booth_conf->name);\n\t}\nout:\n\treturn rv;\n}", "target": 1}
{"code": "\t~Chunk()\n\t{\n\t\tif (ownsMemory)\n\t\t\t::operator delete(buffer);\n\t\tbuffer = NULL;\n\t}", "target": 0}
{"code": "TypedValue HHVM_FUNCTION(array_reverse,\n                         ArrayArg input,\n                         bool preserve_keys ) {\n  ArrNR arrNR(input.get());\n  const Array& arr = arrNR.asArray();\n  return tvReturn(ArrayUtil::Reverse(arr, preserve_keys));\n}", "target": 0}
{"code": "TEST_F(MissingEKUTest, SignedData_missing_codesigning_EKU) {\n  auto certs = uthenticode::read_certs(pe);\n  auto signed_data = certs[0].as_signed_data();\n  ASSERT_FALSE(signed_data->verify_signature());\n}", "target": 0}
{"code": "static char *get_object(\n    FILE         *fp,\n    int           obj_id,\n    const xref_t *xref,\n    size_t       *size,\n    int          *is_stream)\n{\n    static const int    blk_sz = 256;\n    int                 i, total_sz, read_sz, n_blks, search, stream;\n    size_t              obj_sz;\n    char               *c, *data;\n    long                start;\n    const xref_entry_t *entry;\n    if (size)\n      *size = 0;\n    if (is_stream)\n      *is_stream = 0;\n    start = ftell(fp);\n    entry = NULL;\n    for (i=0; i<xref->n_entries; i++)\n      if (xref->entries[i].obj_id == obj_id)\n      {\n          entry = &xref->entries[i];\n          break;\n      }\n    if (!entry)\n      return NULL;\n    fseek(fp, entry->offset, SEEK_SET);\n    obj_sz = 0;    \n    total_sz = 0;  \n    n_blks = 1;\n    data = malloc(blk_sz * n_blks);\n    memset(data, 0, blk_sz * n_blks);\n    stream = 0;\n    while ((read_sz = fread(data+total_sz, 1, blk_sz-1, fp)) && !ferror(fp))\n    {\n        total_sz += read_sz;\n        *(data + total_sz) = '\\0';\n        if (total_sz + blk_sz >= (blk_sz * n_blks))\n          data = realloc(data, blk_sz * (++n_blks));\n        search = total_sz - read_sz;\n        if (search < 0)\n          search = 0;\n        if ((c = strstr(data + search, \"endobj\")))\n        {\n            *(c + strlen(\"endobj\") + 1) = '\\0';\n            obj_sz = (void *)strstr(data + search, \"endobj\") - (void *)data;\n            obj_sz += strlen(\"endobj\") + 1;\n            break;\n        }\n        else if (strstr(data, \"stream\"))\n          stream = 1;\n    }\n    clearerr(fp);\n    fseek(fp, start, SEEK_SET);\n    if (size)\n      *size = obj_sz;\n    if (is_stream)\n      *is_stream = stream;\n    return data;\n}", "target": 1}
{"code": "static const char *WorkingDirectory()\n{\n   static char path[kMAXPATHLEN];\n   if (getcwd(path, kMAXPATHLEN)) return path;\n   return 0;\n}", "target": 0}
{"code": "static bool is_legal_file(const std::string &filename)\n{\n\tDBG_FS << \"Looking for '\" << filename << \"'.\\n\";\n\tif (filename.empty()) {\n\t\tLOG_FS << \"  invalid filename\\n\";\n\t\treturn false;\n\t}\n\tif (filename.find(\"..\") != std::string::npos) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (\\\"..\\\" not allowed).\\n\";\n\t\treturn false;\n\t}\n\tif (looks_like_pbl(filename)) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (.pbl files are not allowed).\" << std::endl;\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 0}
{"code": "void CmdExtract::ExtractArchiveInit(Archive &Arc)\n{\n  DataIO.AdjustTotalArcSize(&Arc);\n  FileCount=0;\n  MatchedArgs=0;\n#ifndef SFX_MODULE\n  FirstFile=true;\n#endif\n  GlobalPassword=Cmd->Password.IsSet() || uiIsGlobalPasswordSet();\n  DataIO.UnpVolume=false;\n  PrevProcessed=false;\n  AllMatchesExact=true;\n  AnySolidDataUnpackedWell=false;\n  ArcAnalyzed=false;\n  StartTime.SetCurrentTime();\n  LastCheckedSymlink.clear();\n}", "target": 0}
{"code": "static int complete_emulated_mmio(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tstruct kvm_mmio_fragment *frag;\n\tunsigned len;\n\tBUG_ON(!vcpu->mmio_needed);\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];\n\tlen = min(8u, frag->len);\n\tif (!vcpu->mmio_is_write)\n\t\tmemcpy(frag->data, run->mmio.data, len);\n\tif (frag->len <= 8) {\n\t\tfrag++;\n\t\tvcpu->mmio_cur_fragment++;\n\t} else {\n\t\tfrag->data += len;\n\t\tfrag->gpa += len;\n\t\tfrag->len -= len;\n\t}\n\tif (vcpu->mmio_cur_fragment == vcpu->mmio_nr_fragments) {\n\t\tvcpu->mmio_needed = 0;\n\t\tif (vcpu->mmio_is_write)\n\t\t\treturn 1;\n\t\tvcpu->mmio_read_completed = 1;\n\t\treturn complete_emulated_io(vcpu);\n\t}\n\trun->exit_reason = KVM_EXIT_MMIO;\n\trun->mmio.phys_addr = frag->gpa;\n\tif (vcpu->mmio_is_write)\n\t\tmemcpy(run->mmio.data, frag->data, min(8u, frag->len));\n\trun->mmio.len = min(8u, frag->len);\n\trun->mmio.is_write = vcpu->mmio_is_write;\n\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\treturn 0;\n}", "target": 1}
{"code": "errno_t sss_filter_sanitize_ex(TALLOC_CTX *mem_ctx,\n                               const char *input,\n                               char **sanitized,\n                               const char *ignore)\n{\n    char *output;\n    size_t i = 0;\n    size_t j = 0;\n    char *allowed;\n    output = talloc_array(mem_ctx, char, strlen(input) * 3 + 1);\n    if (!output) {\n        return ENOMEM;\n    }\n    while (input[i]) {\n        if (ignore == NULL) {\n            allowed = NULL;\n        } else {\n            allowed = strchr(ignore, input[i]);\n        }\n        if (allowed) {\n            output[j++] = input[i++];\n            continue;\n        }\n        switch(input[i]) {\n        case '\\t':\n            output[j++] = '\\\\';\n            output[j++] = '0';\n            output[j++] = '9';\n            break;\n        case ' ':\n            output[j++] = '\\\\';\n            output[j++] = '2';\n            output[j++] = '0';\n            break;\n        case '*':\n            output[j++] = '\\\\';\n            output[j++] = '2';\n            output[j++] = 'a';\n            break;\n        case '(':\n            output[j++] = '\\\\';\n            output[j++] = '2';\n            output[j++] = '8';\n            break;\n        case ')':\n            output[j++] = '\\\\';\n            output[j++] = '2';\n            output[j++] = '9';\n            break;\n        case '\\\\':\n            output[j++] = '\\\\';\n            output[j++] = '5';\n            output[j++] = 'c';\n            break;\n        case '\\r':\n            output[j++] = '\\\\';\n            output[j++] = '0';\n            output[j++] = 'd';\n            break;\n        case '\\n':\n            output[j++] = '\\\\';\n            output[j++] = '0';\n            output[j++] = 'a';\n            break;\n        default:\n            output[j++] = input[i];\n        }\n        i++;\n    }\n    output[j] = '\\0';\n    *sanitized = talloc_realloc(mem_ctx, output, char, j+1);\n    if (!*sanitized) {\n        talloc_free(output);\n        return ENOMEM;\n    }\n    return EOK;\n}", "target": 1}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  TFLITE_DCHECK(node->builtin_data != nullptr);\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  TF_LITE_ENSURE(context, input1 != nullptr);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TF_LITE_ENSURE(context, input2 != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  OpData* data = static_cast<OpData*>(node->user_data);\n  auto* params = reinterpret_cast<TfLiteAddParams*>(node->builtin_data);\n  TF_LITE_ENSURE_STATUS(\n      CalculateOpData(context, params, input1, input2, output, data));\n  return kTfLiteOk;\n}", "target": 0}
{"code": "bool isCPUDevice<CPUDevice>() {\n  return true;\n}", "target": 0}
{"code": "unsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize)\n{\n  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGB, 8);\n}", "target": 0}
{"code": "void Filter::onDownstreamEvent(Network::ConnectionEvent event) {\n  if (event == Network::ConnectionEvent::LocalClose ||\n      event == Network::ConnectionEvent::RemoteClose) {\n    downstream_closed_ = true;\n  }\n  ENVOY_CONN_LOG(trace, \"on downstream event {}, has upstream = {}\", read_callbacks_->connection(),\n                 static_cast<int>(event), upstream_ == nullptr);\n  if (upstream_) {\n    Tcp::ConnectionPool::ConnectionDataPtr conn_data(upstream_->onDownstreamEvent(event));\n    if (conn_data != nullptr &&\n        conn_data->connection().state() != Network::Connection::State::Closed) {\n      config_->drainManager().add(config_->sharedConfig(), std::move(conn_data),\n                                  std::move(upstream_callbacks_), std::move(idle_timer_),\n                                  read_callbacks_->upstreamHost());\n    }\n    if (event != Network::ConnectionEvent::Connected) {\n      upstream_.reset();\n      disableIdleTimer();\n    }\n  }\n  if (generic_conn_pool_) {\n    if (event == Network::ConnectionEvent::LocalClose ||\n        event == Network::ConnectionEvent::RemoteClose) {\n      generic_conn_pool_.reset();\n    }\n  }\n}", "target": 0}
{"code": "int firstBitSet(int x)\n{\n        int position=0;\n        while (x!=0)\n        {\n                x>>=1;\n                ++position;\n        }\n        return position;\n}", "target": 0}
{"code": "directory_fetches_dir_info_later(const or_options_t *options)\n{\n  return options->UseBridges != 0;\n}", "target": 0}
{"code": "static inline bool vm_need_virtualize_apic_accesses(struct kvm *kvm)\n{\n\treturn flexpriority_enabled && irqchip_in_kernel(kvm);\n}", "target": 0}
{"code": "static inline u32 vm_exit_controls_get(struct vcpu_vmx *vmx)\n{\n\treturn vmx->vm_exit_controls_shadow;\n}", "target": 0}
{"code": "  CallOpDimensionsFromInputs(const int n, const int h, const int w, const int c,\n                             const int kx, const int ky, const int sx,\n                             const int sy, const string& data_format,\n                             const string& padding) {\n    OpContext op_context;\n    const std::vector<int> x = {n, h, w, c};\n    const std::vector<int> ksize = {1, kx, ky, 1};\n    std::vector<int> strides;\n    if (data_format == \"NHWC\") {\n      strides = {1, sy, sx, 1};\n    } else {\n      strides = {1, 1, sy, sx};\n    }\n    auto& op_info = op_context.op_info;\n    SetCpuDevice(&op_info);\n    op_info.set_op(\"MaxPool\");\n    DescribeTensor4D(x[0], x[1], x[2], x[3], op_info.add_inputs());\n    auto* attr = op_info.mutable_attr();\n    SetAttrValue(data_format, &(*attr)[\"data_format\"]);\n    SetAttrValue(padding, &(*attr)[\"padding\"]);\n    SetAttrValue(strides, &(*attr)[\"strides\"]);\n    SetAttrValue(ksize, &(*attr)[\"ksize\"]);\n    bool found_unknown_shapes;\n    return OpLevelCostEstimator::OpDimensionsFromInputs(\n        op_context.op_info.inputs(0).shape(), op_context.op_info,\n        &found_unknown_shapes);\n  }", "target": 0}
{"code": "  clientpairingsecret(std::shared_ptr<safe::queue_t<crypto::x509_t>> &add_cert, pair_session_t &sess, pt::ptree &tree, const args_t &args) {\n    auto &client = sess.client;\n    auto pairingsecret = util::from_hex_vec(get_arg(args, \"clientpairingsecret\"), true);\n    if (pairingsecret.size() <= 16) {\n      tree.put(\"root.paired\", 0);\n      tree.put(\"root.<xmlattr>.status_code\", 400);\n      tree.put(\"root.<xmlattr>.status_message\", \"Clientpairingsecret too short\");\n      return;\n    }\n    std::string_view secret { pairingsecret.data(), 16 };\n    std::string_view sign { pairingsecret.data() + secret.size(), pairingsecret.size() - secret.size() };\n    auto x509 = crypto::x509(client.cert);\n    auto x509_sign = crypto::signature(x509);\n    std::string data;\n    data.reserve(sess.serverchallenge.size() + x509_sign.size() + secret.size());\n    data.insert(std::end(data), std::begin(sess.serverchallenge), std::end(sess.serverchallenge));\n    data.insert(std::end(data), std::begin(x509_sign), std::end(x509_sign));\n    data.insert(std::end(data), std::begin(secret), std::end(secret));\n    auto hash = crypto::hash(data);\n    if (!std::memcmp(hash.data(), sess.clienthash.data(), hash.size()) && crypto::verify256(crypto::x509(client.cert), secret, sign)) {\n      tree.put(\"root.paired\", 1);\n      add_cert->raise(crypto::x509(client.cert));\n      auto it = map_id_sess.find(client.uniqueID);\n      update_id_client(client.uniqueID, std::move(client.cert), op_e::ADD);\n      map_id_sess.erase(it);\n    }\n    else {\n      map_id_sess.erase(client.uniqueID);\n      tree.put(\"root.paired\", 0);\n    }\n    tree.put(\"root.<xmlattr>.status_code\", 200);\n  }", "target": 1}
{"code": "snmp_api_replace_oid(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  uint8_t i;\n  i = 0;\n  while(oid[i] != ((uint32_t)-1)) {\n    varbind->oid[i] = oid[i];\n    i++;\n  }\n  varbind->oid[i] = ((uint32_t)-1);\n}", "target": 1}
{"code": "static void dhcps_send_offer(struct pbuf *packet_buffer)\n{\n\tuint8_t temp_ip = 0;\n\tdhcp_message_repository = (struct dhcp_msg *)packet_buffer->payload;\t\n#if (!IS_USE_FIXED_IP) \t\n\ttemp_ip = check_client_request_ip(&client_request_ip, client_addr);\n\tif(temp_ip == 0)\n\t\ttemp_ip = search_next_ip();\n#if (debug_dhcps)\t\n\tprintf(\"\\r\\n temp_ip = %d\",temp_ip);\n#endif\t\n\tif (temp_ip == 0) {\n#if 0\t\n\t  \tmemset(&ip_table, 0, sizeof(struct table));\n\t\tmark_ip_in_table((uint8_t)ip4_addr4(&dhcps_local_address));\n\t\tprintf(\"\\r\\n reset ip table!!\\r\\n\");\t\n#endif\t\n\t\tprintf(\"\\r\\n No useable ip!!!!\\r\\n\");\n\t}\n\tprintf(\"\\n\\r[%d]DHCP assign ip = %d.%d.%d.%d\\n\", xTaskGetTickCount(), ip4_addr1(&dhcps_network_id),ip4_addr2(&dhcps_network_id),ip4_addr3(&dhcps_network_id),temp_ip);\n\tIP4_ADDR(&dhcps_allocated_client_address, (ip4_addr1(&dhcps_network_id)),\n\t\t\tip4_addr2(&dhcps_network_id), ip4_addr3(&dhcps_network_id), temp_ip);\n#endif   \n\tdhcps_initialize_message(dhcp_message_repository);\n\tadd_offer_options(add_msg_type(&dhcp_message_repository->options[4],\n\t\t\tDHCP_MESSAGE_TYPE_OFFER));\n\tudp_sendto_if(dhcps_pcb, packet_buffer,\n\t\t\t&dhcps_send_broadcast_address, DHCP_CLIENT_PORT, dhcps_netif);\n}", "target": 1}
{"code": "ev_archive_new (void)\n{\n\treturn g_object_new (EV_TYPE_ARCHIVE, NULL);\n}", "target": 0}
{"code": "static std::string WrapWithTH(std::string text) {\n  return \"<th>\" + text + \"</th>\";\n}", "target": 0}
{"code": "void RenderView::InsertCSS(const std::wstring& frame_xpath,\n                           const std::string& css,\n                           const std::string& id) {\n  WebFrame* web_frame = GetChildFrame(frame_xpath);\n  if (!web_frame)\n    return;\n  web_frame->insertStyleText(WebString::fromUTF8(css), WebString::fromUTF8(id));\n}", "target": 0}
{"code": "static void flush_end_io(struct request *flush_rq, int error)\n{\n\tstruct request_queue *q = flush_rq->q;\n\tstruct list_head *running;\n\tbool queued = false;\n\tstruct request *rq, *n;\n\tunsigned long flags = 0;\n\tstruct blk_flush_queue *fq = blk_get_flush_queue(q, flush_rq->mq_ctx);\n\tif (q->mq_ops) {\n\t\tstruct blk_mq_hw_ctx *hctx;\n\t\tspin_lock_irqsave(&fq->mq_flush_lock, flags);\n\t\thctx = q->mq_ops->map_queue(q, flush_rq->mq_ctx->cpu);\n\t\tblk_mq_tag_set_rq(hctx, flush_rq->tag, fq->orig_rq);\n\t\tflush_rq->tag = -1;\n\t}\n\trunning = &fq->flush_queue[fq->flush_running_idx];\n\tBUG_ON(fq->flush_pending_idx == fq->flush_running_idx);\n\tfq->flush_running_idx ^= 1;\n\tif (!q->mq_ops)\n\t\telv_completed_request(q, flush_rq);\n\tlist_for_each_entry_safe(rq, n, running, flush.list) {\n\t\tunsigned int seq = blk_flush_cur_seq(rq);\n\t\tBUG_ON(seq != REQ_FSEQ_PREFLUSH && seq != REQ_FSEQ_POSTFLUSH);\n\t\tqueued |= blk_flush_complete_seq(rq, fq, seq, error);\n\t}\n\tif (queued || fq->flush_queue_delayed) {\n\t\tWARN_ON(q->mq_ops);\n\t\tblk_run_queue_async(q);\n\t}\n\tfq->flush_queue_delayed = 0;\n\tif (q->mq_ops)\n\t\tspin_unlock_irqrestore(&fq->mq_flush_lock, flags);\n}", "target": 0}
{"code": "void RootWindow::SetHostSize(const gfx::Size& size_in_pixel) {\n  DispatchHeldMouseMove();\n  gfx::Rect bounds = host_->GetBounds();\n  bounds.set_size(size_in_pixel);\n  host_->SetBounds(bounds);\n  last_mouse_location_ =\n      ui::ConvertPointToDIP(layer(), host_->QueryMouseLocation());\n  synthesize_mouse_move_ = false;\n}", "target": 0}
{"code": "HMAC_SHA256_Final(unsigned char digest[32], struct HMAC_SHA256_CTX * ctx)\n{\n  unsigned char ihash[32];\n  scrypt_SHA256_Final(ihash, &ctx->ictx);\n  scrypt_SHA256_Update(&ctx->octx, ihash, 32);\n  scrypt_SHA256_Final(digest, &ctx->octx);\n  memset(ihash, 0, 32);\n}", "target": 1}
{"code": "xdr_krb5_principal(XDR *xdrs, krb5_principal *objp)\n{\n    int\t    ret;\n    char\t    *p = NULL;\n    krb5_principal  pr = NULL;\n    static krb5_context context = NULL;\n    if (!context &&\n\tkadm5_init_krb5_context(&context))\n       return(FALSE);\n    switch(xdrs->x_op) {\n    case XDR_ENCODE:\n\tif (*objp) {\n\t     if((ret = krb5_unparse_name(context, *objp, &p)) != 0)\n\t\t  return FALSE;\n\t}\n\tif(!xdr_nullstring(xdrs, &p))\n\t    return FALSE;\n\tif (p) free(p);\n\tbreak;\n    case XDR_DECODE:\n\tif(!xdr_nullstring(xdrs, &p))\n\t    return FALSE;\n\tif (p) {\n\t     ret = krb5_parse_name(context, p, &pr);\n\t     if(ret != 0)\n\t\t  return FALSE;\n\t     *objp = pr;\n\t     free(p);\n\t} else\n\t     *objp = NULL;\n\tbreak;\n    case XDR_FREE:\n\tif(*objp != NULL)\n\t    krb5_free_principal(context, *objp);\n\t*objp = NULL;\n\tbreak;\n    }\n    return TRUE;\n}", "target": 0}
{"code": "static int check_ptrace_options(unsigned long data)\n{\n\tif (data & ~(unsigned long)PTRACE_O_MASK)\n\t\treturn -EINVAL;\n\tif (unlikely(data & PTRACE_O_SUSPEND_SECCOMP)) {\n\t\tif (!IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) ||\n\t\t    !IS_ENABLED(CONFIG_SECCOMP))\n\t\t\treturn -EINVAL;\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (seccomp_mode(&current->seccomp) != SECCOMP_MODE_DISABLED ||\n\t\t    current->ptrace & PT_SUSPEND_SECCOMP)\n\t\t\treturn -EPERM;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "ecryptfs_decode_from_filename(unsigned char *dst, size_t *dst_size,\n\t\t\t      const unsigned char *src, size_t src_size)\n{\n\tu8 current_bit_offset = 0;\n\tsize_t src_byte_offset = 0;\n\tsize_t dst_byte_offset = 0;\n\tif (dst == NULL) {\n\t\t(*dst_size) = ecryptfs_max_decoded_size(src_size);\n\t\tgoto out;\n\t}\n\twhile (src_byte_offset < src_size) {\n\t\tunsigned char src_byte =\n\t\t\t\tfilename_rev_map[(int)src[src_byte_offset]];\n\t\tswitch (current_bit_offset) {\n\t\tcase 0:\n\t\t\tdst[dst_byte_offset] = (src_byte << 2);\n\t\t\tcurrent_bit_offset = 6;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 4);\n\t\t\tdst[dst_byte_offset] = ((src_byte & 0xF)\n\t\t\t\t\t\t << 4);\n\t\t\tcurrent_bit_offset = 4;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 2);\n\t\t\tdst[dst_byte_offset] = (src_byte << 6);\n\t\t\tcurrent_bit_offset = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdst[dst_byte_offset++] |= (src_byte);\n\t\t\tdst[dst_byte_offset] = 0;\n\t\t\tcurrent_bit_offset = 0;\n\t\t\tbreak;\n\t\t}\n\t\tsrc_byte_offset++;\n\t}\n\t(*dst_size) = dst_byte_offset;\nout:\n\treturn;\n}", "target": 1}
{"code": "void ntlm_write_message_fields_buffer(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields->Len > 0)\n\t{\n\t\tStream_SetPosition(s, fields->BufferOffset);\n\t\tStream_Write(s, fields->Buffer, fields->Len);\n\t}\n}", "target": 1}
{"code": "static pfunc check_literal(struct jv_parser* p) {\n  if (p->tokenpos == 0) return 0;\n  const char* pattern = 0;\n  int plen;\n  jv v;\n  switch (p->tokenbuf[0]) {\n  case 't': pattern = \"true\"; plen = 4; v = jv_true(); break;\n  case 'f': pattern = \"false\"; plen = 5; v = jv_false(); break;\n  case 'n': pattern = \"null\"; plen = 4; v = jv_null(); break;\n  }\n  if (pattern) {\n    if (p->tokenpos != plen) return \"Invalid literal\";\n    for (int i=0; i<plen; i++)\n      if (p->tokenbuf[i] != pattern[i])\n        return \"Invalid literal\";\n    TRY(value(p, v));\n  } else {\n    p->tokenbuf[p->tokenpos] = 0; \n    char* end = 0;\n    double d = jvp_strtod(&p->dtoa, p->tokenbuf, &end);\n    if (end == 0 || *end != 0)\n      return \"Invalid numeric literal\";\n    TRY(value(p, jv_number(d)));\n  }\n  p->tokenpos = 0;\n  return 0;\n}", "target": 1}
{"code": "static ssize_t compress(zckCtx *zck, zckComp *comp, const char *src,\n                        const size_t src_size, char **dst, size_t *dst_size,\n                        bool use_dict) {\n    VALIDATE_INT(zck);\n    ALLOCD_INT(zck, dst);\n    ALLOCD_INT(zck, src);\n    ALLOCD_INT(zck, dst_size);\n    ALLOCD_INT(zck, comp);\n    if((comp->dc_data_size > comp->dc_data_size + src_size) ||\n       (src_size > comp->dc_data_size + src_size)) {\n        zck_log(ZCK_LOG_ERROR, \"Integer overflow when reading decompressed data\");\n        return false;\n    }\n    comp->dc_data = zrealloc(comp->dc_data, comp->dc_data_size + src_size);\n    if (!comp->dc_data) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return -1;\n    }\n    memcpy(comp->dc_data + comp->dc_data_size, src, src_size);\n    *dst = NULL;\n    *dst_size = 0;\n    return 0;\n}", "target": 0}
{"code": "mmsMsg_parseFileName(char* filename, uint8_t* buffer, int* bufPos, int maxBufPos , uint32_t invokeId, ByteBuffer* response)\n{\n    if (*bufPos == maxBufPos)\n        return false;\n    uint8_t tag = buffer[(*bufPos)++];\n    if (tag != 0x19) {\n      mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n      return false;\n    }\n    int length;\n    *bufPos = BerDecoder_decodeLength(buffer, &length, *bufPos, maxBufPos);\n    if (*bufPos < 0)  {\n      mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n      return false;\n    }\n    if (length > 255) {\n      mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT, response);\n      return false;\n    }\n    memcpy(filename, buffer + *bufPos, length);\n    filename[length] = 0;\n    *bufPos += length;\n    if (strstr(filename, \"..\") != NULL) {\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILENAME_SYNTAX_ERROR);\n        return false;\n    }\n    return true;\n}", "target": 1}
{"code": "static int create_constraints(struct powercap_zone *power_zone,\n\t\t\tint nr_constraints,\n\t\t\tconst struct powercap_zone_constraint_ops *const_ops)\n{\n\tint i;\n\tint ret = 0;\n\tint count;\n\tstruct powercap_zone_constraint *pconst;\n\tif (!power_zone || !const_ops || !const_ops->get_power_limit_uw ||\n\t\t\t\t\t!const_ops->set_power_limit_uw ||\n\t\t\t\t\t!const_ops->get_time_window_us ||\n\t\t\t\t\t!const_ops->set_time_window_us)\n\t\treturn -EINVAL;\n\tcount = power_zone->zone_attr_count;\n\tfor (i = 0; i < nr_constraints; ++i) {\n\t\tpconst = &power_zone->constraints[i];\n\t\tpconst->ops = const_ops;\n\t\tpconst->id = power_zone->const_id_cnt;\n\t\tpower_zone->const_id_cnt++;\n\t\tpower_zone->zone_dev_attrs[count++] =\n\t\t\t\t&constraint_attrs[i].power_limit_attr.attr;\n\t\tpower_zone->zone_dev_attrs[count++] =\n\t\t\t\t&constraint_attrs[i].time_window_attr.attr;\n\t\tif (pconst->ops->get_name)\n\t\t\tpower_zone->zone_dev_attrs[count++] =\n\t\t\t\t&constraint_attrs[i].name_attr.attr;\n\t\tif (pconst->ops->get_max_power_uw)\n\t\t\tpower_zone->zone_dev_attrs[count++] =\n\t\t\t\t&constraint_attrs[i].max_power_attr.attr;\n\t\tif (pconst->ops->get_min_power_uw)\n\t\t\tpower_zone->zone_dev_attrs[count++] =\n\t\t\t\t&constraint_attrs[i].min_power_attr.attr;\n\t\tif (pconst->ops->get_max_time_window_us)\n\t\t\tpower_zone->zone_dev_attrs[count++] =\n\t\t\t\t&constraint_attrs[i].max_time_window_attr.attr;\n\t\tif (pconst->ops->get_min_time_window_us)\n\t\t\tpower_zone->zone_dev_attrs[count++] =\n\t\t\t\t&constraint_attrs[i].min_time_window_attr.attr;\n\t}\n\tpower_zone->zone_attr_count = count;\n\treturn ret;\n}", "target": 0}
{"code": "static void ffs_user_copy_worker(struct work_struct *work)\n{\n\tstruct ffs_io_data *io_data = container_of(work, struct ffs_io_data,\n\t\t\t\t\t\t   work);\n\tint ret = io_data->req->status ? io_data->req->status :\n\t\t\t\t\t io_data->req->actual;\n\tif (io_data->read && ret > 0) {\n\t\tuse_mm(io_data->mm);\n\t\tret = copy_to_iter(io_data->buf, ret, &io_data->data);\n\t\tif (iov_iter_count(&io_data->data))\n\t\t\tret = -EFAULT;\n\t\tunuse_mm(io_data->mm);\n\t}\n\tio_data->kiocb->ki_complete(io_data->kiocb, ret, ret);\n\tif (io_data->ffs->ffs_eventfd &&\n\t    !(io_data->kiocb->ki_flags & IOCB_EVENTFD))\n\t\teventfd_signal(io_data->ffs->ffs_eventfd, 1);\n\tusb_ep_free_request(io_data->ep, io_data->req);\n\tio_data->kiocb->private = NULL;\n\tif (io_data->read)\n\t\tkfree(io_data->to_free);\n\tkfree(io_data->buf);\n\tkfree(io_data);\n}", "target": 1}
{"code": "propname2ctype(ScanEnv* env, const char* propname)\n{\n  UChar* name = (UChar* )propname;\n  int ctype = env->enc->property_name_to_ctype(ONIG_ENCODING_ASCII,\n      name, name + strlen(propname));\n  return ctype;\n}", "target": 0}
{"code": "spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n\t\t\t  int iov_count)\n{\n    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n\t\t\t      iov_count);\n}", "target": 1}
{"code": "static plist_t parse_string_node(const char **bnode, uint64_t size)\n{\n    plist_data_t data = plist_new_plist_data();\n    data->type = PLIST_STRING;\n    data->strval = (char *) malloc(sizeof(char) * (size + 1));\n    if (!data->strval) {\n        plist_free_data(data);\n        PLIST_BIN_ERR(\"%s: Could not allocate %\" PRIu64 \" bytes\\n\", __func__, sizeof(char) * (size + 1));\n        return NULL;\n    }\n    memcpy(data->strval, *bnode, size);\n    data->strval[size] = '\\0';\n    data->length = strlen(data->strval);\n    return node_create(NULL, data);\n}", "target": 0}
{"code": "    static std::string indent(int depth)\n    {\n        std::string result;\n        while ( depth -- ) result += \"  \";\n        return result;\n    }", "target": 0}
{"code": "    void TiffSizeEntry::doAccept(TiffVisitor& visitor)\n    {\n        visitor.visitSizeEntry(this);\n    } ", "target": 0}
{"code": "    void SetProhibitQOpen(bool Mode) {ProhibitQOpen=Mode;}", "target": 0}
{"code": "struct r_bin_dyldcache_obj_t* r_bin_dyldcache_from_bytes_new(const ut8* buf, ut64 size) {\n\tstruct r_bin_dyldcache_obj_t *bin;\n\tif (!(bin = malloc (sizeof (struct r_bin_dyldcache_obj_t)))) {\n\t\treturn NULL;\n\t}\n\tmemset (bin, 0, sizeof (struct r_bin_dyldcache_obj_t));\n\tif (!buf) {\n\t\treturn r_bin_dyldcache_free (bin);\n\t}\n\tbin->b = r_buf_new();\n\tif (!r_buf_set_bytes (bin->b, buf, size)) {\n\t\treturn r_bin_dyldcache_free (bin);\n\t}\n\tif (!r_bin_dyldcache_init (bin)) {\n\t\treturn r_bin_dyldcache_free (bin);\n\t}\n\tbin->size = size;\n\treturn bin;\n}", "target": 1}
{"code": "static int kernel_pio(struct kvm_vcpu *vcpu, void *pd)\n{\n\tint r;\n\tif (vcpu->arch.pio.in)\n\t\tr = kvm_io_bus_read(vcpu->kvm, KVM_PIO_BUS, vcpu->arch.pio.port,\n\t\t\t\t    vcpu->arch.pio.size, pd);\n\telse\n\t\tr = kvm_io_bus_write(vcpu->kvm, KVM_PIO_BUS,\n\t\t\t\t     vcpu->arch.pio.port, vcpu->arch.pio.size,\n\t\t\t\t     pd);\n\treturn r;\n}", "target": 0}
{"code": "static int send_header(void *data, const char *key, const char *val)\n{\n    ap_fputstrs(((hdr_ptr*)data)->f, ((hdr_ptr*)data)->bb,\n                key, \": \", val, CRLF, NULL);\n    return 1;\n}", "target": 0}
{"code": "static inline int object_common2(UNSERIALIZE_PARAMETER, long elements)\n{\n\tzval *retval_ptr = NULL;\n\tzval fname;\n\tif (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_OBJPROP_PP(rval), elements, 1)) {\n\t\treturn 0;\n\t}\n\tif (Z_OBJCE_PP(rval) != PHP_IC_ENTRY &&\n\t\tzend_hash_exists(&Z_OBJCE_PP(rval)->function_table, \"__wakeup\", sizeof(\"__wakeup\"))) {\n\t\tINIT_PZVAL(&fname);\n\t\tZVAL_STRINGL(&fname, \"__wakeup\", sizeof(\"__wakeup\") - 1, 0);\n\t\tcall_user_function_ex(CG(function_table), rval, &fname, &retval_ptr, 0, 0, 1, NULL TSRMLS_CC);\n\t}\n\tif (retval_ptr)\n\t\tzval_ptr_dtor(&retval_ptr);\n\treturn finish_nested_data(UNSERIALIZE_PASSTHRU);\n}", "target": 0}
{"code": "spnego_gss_delete_sec_context(\n\t\t\t    OM_uint32 *minor_status,\n\t\t\t    gss_ctx_id_t *context_handle,\n\t\t\t    gss_buffer_t output_token)\n{\n\tOM_uint32 ret = GSS_S_COMPLETE;\n\tspnego_gss_ctx_id_t *ctx =\n\t\t    (spnego_gss_ctx_id_t *)context_handle;\n\t*minor_status = 0;\n\tif (context_handle == NULL)\n\t\treturn (GSS_S_FAILURE);\n\tif (*ctx == NULL)\n\t\treturn (GSS_S_COMPLETE);\n\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n\t\t(void) gss_delete_sec_context(minor_status,\n\t\t\t\t    &(*ctx)->ctx_handle,\n\t\t\t\t    output_token);\n\t\t(void) release_spnego_ctx(ctx);\n\t} else {\n\t\tret = gss_delete_sec_context(minor_status,\n\t\t\t\t    context_handle,\n\t\t\t\t    output_token);\n\t}\n\treturn (ret);\n}", "target": 1}
{"code": "find_sig8_target_as_global_offset(Dwarf_Attribute attr,\n    Dwarf_Sig8  *sig8,\n    Dwarf_Bool  *is_info,\n    Dwarf_Off   *targoffset,\n    Dwarf_Error *error)\n{\n    Dwarf_Die  targdie = 0;\n    Dwarf_Bool targ_is_info = 0;\n    Dwarf_Off  localoff = 0;\n    int res = 0;\n    targ_is_info = attr->ar_cu_context->cc_is_info;\n    memcpy(sig8,attr->ar_debug_ptr,sizeof(*sig8));\n    res = dwarf_find_die_given_sig8(attr->ar_dbg,\n        sig8,&targdie,&targ_is_info,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    res = dwarf_die_offsets(targdie,targoffset,&localoff,error);\n    if (res != DW_DLV_OK) {\n        dwarf_dealloc_die(targdie);\n        return res;\n    }\n    *is_info = targdie->di_cu_context->cc_is_info;\n    dwarf_dealloc_die(targdie);\n    return DW_DLV_OK;\n}", "target": 1}
{"code": "static int pfkey_flush(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tunsigned int proto;\n\tstruct km_event c;\n\tint err, err2;\n\tproto = pfkey_satype2proto(hdr->sadb_msg_satype);\n\tif (proto == 0)\n\t\treturn -EINVAL;\n\terr = xfrm_state_flush(net, proto, true, false);\n\terr2 = unicast_flush_resp(sk, hdr);\n\tif (err || err2) {\n\t\tif (err == -ESRCH) \n\t\t\terr = 0;\n\t\treturn err ? err : err2;\n\t}\n\tc.data.proto = proto;\n\tc.seq = hdr->sadb_msg_seq;\n\tc.portid = hdr->sadb_msg_pid;\n\tc.event = XFRM_MSG_FLUSHSA;\n\tc.net = net;\n\tkm_state_notify(NULL, &c);\n\treturn 0;\n}", "target": 0}
{"code": "static inline __must_check bool try_get_page(struct page *page)\n{\n\tpage = compound_head(page);\n\tif (WARN_ON_ONCE(page_ref_count(page) <= 0))\n\t\treturn false;\n\tpage_ref_inc(page);\n\treturn true;\n}", "target": 0}
{"code": "nfs4_proc_create(struct inode *dir, struct dentry *dentry, struct iattr *sattr,\n                 int flags, struct nameidata *nd)\n{\n\tstruct path path = {\n\t\t.mnt = nd->path.mnt,\n\t\t.dentry = dentry,\n\t};\n\tstruct nfs4_state *state;\n\tstruct rpc_cred *cred;\n\tint status = 0;\n\tcred = rpc_lookup_cred();\n\tif (IS_ERR(cred)) {\n\t\tstatus = PTR_ERR(cred);\n\t\tgoto out;\n\t}\n\tstate = nfs4_do_open(dir, &path, flags, sattr, cred);\n\td_drop(dentry);\n\tif (IS_ERR(state)) {\n\t\tstatus = PTR_ERR(state);\n\t\tgoto out_putcred;\n\t}\n\td_add(dentry, igrab(state->inode));\n\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\tif (flags & O_EXCL) {\n\t\tstruct nfs_fattr fattr;\n\t\tstatus = nfs4_do_setattr(state->inode, cred, &fattr, sattr, state);\n\t\tif (status == 0)\n\t\t\tnfs_setattr_update_inode(state->inode, sattr);\n\t\tnfs_post_op_update_inode(state->inode, &fattr);\n\t}\n\tif (status == 0 && (nd->flags & LOOKUP_OPEN) != 0)\n\t\tstatus = nfs4_intent_set_file(nd, &path, state);\n\telse\n\t\tnfs4_close_sync(&path, state, flags);\nout_putcred:\n\tput_rpccred(cred);\nout:\n\treturn status;\n}", "target": 1}
{"code": "DEFINE_TEST(test_read_format_mtree_crash747)\n{\n\tconst char *reffile = \"test_read_format_mtree_crash747.mtree.bz2\";\n\tstruct archive *a;\n\textract_reference_file(reffile);\n\tassert((a = archive_read_new()) != NULL);\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_support_filter_bzip2(a));\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_mtree(a));\n\tassertEqualIntA(a, ARCHIVE_FATAL, archive_read_open_filename(a, reffile, 10240));\n\tassertEqualInt(ARCHIVE_OK, archive_read_free(a));\n}", "target": 0}
{"code": "void WasmBinaryBuilder::visitUnreachable(Unreachable* curr) {\n  BYN_TRACE(\"zz node: Unreachable\\n\");\n}", "target": 0}
{"code": "void AverageEvalQuantizedInt8(TfLiteContext* context, TfLiteNode* node,\n                              TfLitePoolParams* params, OpData* data,\n                              const TfLiteTensor* input, TfLiteTensor* output) {\n  int32_t activation_min;\n  int32_t activation_max;\n  (void)CalculateActivationRangeQuantized(context, params->activation, output,\n                                          &activation_min, &activation_max);\n#define TF_LITE_AVERAGE_POOL(type)                                        \\\n  tflite::PoolParams op_params;                                           \\\n  op_params.stride_height = params->stride_height;                        \\\n  op_params.stride_width = params->stride_width;                          \\\n  op_params.filter_height = params->filter_height;                        \\\n  op_params.filter_width = params->filter_width;                          \\\n  op_params.padding_values.height = data->padding.height;                 \\\n  op_params.padding_values.width = data->padding.width;                   \\\n  op_params.quantized_activation_min = activation_min;                    \\\n  op_params.quantized_activation_max = activation_max;                    \\\n  type::AveragePool(op_params, GetTensorShape(input),                     \\\n                    GetTensorData<int8_t>(input), GetTensorShape(output), \\\n                    GetTensorData<int8_t>(output))\n  if (kernel_type == kReference) {\n    TF_LITE_AVERAGE_POOL(reference_integer_ops);\n  } else {\n    TF_LITE_AVERAGE_POOL(optimized_integer_ops);\n  }\n#undef TF_LITE_AVERAGE_POOL\n}", "target": 1}
{"code": "onigenc_always_false_is_allowed_reverse_match(const UChar* s   ARG_UNUSED,\n\t\t\t\t\t      const UChar* end ARG_UNUSED,\n\t\t\t\t\t      OnigEncoding enc ARG_UNUSED)\n{\n  return FALSE;\n}", "target": 0}
{"code": "void exit_sem(struct task_struct *tsk)\n{\n\tstruct sem_undo_list *ulp;\n\tulp = tsk->sysvsem.undo_list;\n\tif (!ulp)\n\t\treturn;\n\ttsk->sysvsem.undo_list = NULL;\n\tif (!atomic_dec_and_test(&ulp->refcnt))\n\t\treturn;\n\tfor (;;) {\n\t\tstruct sem_array *sma;\n\t\tstruct sem_undo *un;\n\t\tstruct list_head tasks;\n\t\tint semid;\n\t\tint i;\n\t\trcu_read_lock();\n\t\tun = list_entry_rcu(ulp->list_proc.next,\n\t\t\t\t    struct sem_undo, list_proc);\n\t\tif (&un->list_proc == &ulp->list_proc)\n\t\t\tsemid = -1;\n\t\t else\n\t\t\tsemid = un->semid;\n\t\trcu_read_unlock();\n\t\tif (semid == -1)\n\t\t\tbreak;\n\t\tsma = sem_lock_check(tsk->nsproxy->ipc_ns, un->semid);\n\t\tif (IS_ERR(sma))\n\t\t\tcontinue;\n\t\tun = __lookup_undo(ulp, semid);\n\t\tif (un == NULL) {\n\t\t\tsem_unlock(sma);\n\t\t\tcontinue;\n\t\t}\n\t\tassert_spin_locked(&sma->sem_perm.lock);\n\t\tlist_del(&un->list_id);\n\t\tspin_lock(&ulp->lock);\n\t\tlist_del_rcu(&un->list_proc);\n\t\tspin_unlock(&ulp->lock);\n\t\tfor (i = 0; i < sma->sem_nsems; i++) {\n\t\t\tstruct sem * semaphore = &sma->sem_base[i];\n\t\t\tif (un->semadj[i]) {\n\t\t\t\tsemaphore->semval += un->semadj[i];\n\t\t\t\tif (semaphore->semval < 0)\n\t\t\t\t\tsemaphore->semval = 0;\n\t\t\t\tif (semaphore->semval > SEMVMX)\n\t\t\t\t\tsemaphore->semval = SEMVMX;\n\t\t\t\tsemaphore->sempid = task_tgid_vnr(current);\n\t\t\t}\n\t\t}\n\t\tINIT_LIST_HEAD(&tasks);\n\t\tdo_smart_update(sma, NULL, 0, 1, &tasks);\n\t\tsem_unlock(sma);\n\t\twake_up_sem_queue_do(&tasks);\n\t\tkfree_rcu(un, rcu);\n\t}\n\tkfree(ulp);\n}", "target": 1}
{"code": "log2vis_encoded_string (PyObject * string, const char *encoding,\n\t\t\tFriBidiParType base_direction, int clean, int reordernsm)\n{\n\tPyObject *logical = NULL;\t\n\tPyObject *result = NULL;\t\n\tlogical = PyUnicode_Decode (PyString_AS_STRING (string),\n\t\t\t\t    PyString_GET_SIZE (string),\n\t\t\t\t    encoding, \"strict\");\n\tif (logical == NULL)\n\t\treturn NULL;\n\tif (strcmp (encoding, \"utf-8\") == 0)\n\t\tresult = log2vis_utf8 (string,\n\t\t\t\t       PyUnicode_GET_SIZE (logical),\n\t\t\t\t       base_direction, clean, reordernsm);\n\telse\n\t{\n\t\tPyObject *visual = log2vis_unicode (logical, base_direction, clean, reordernsm);\n\t\tif (visual)\n\t\t{\n\t\t\tresult = PyUnicode_Encode (PyUnicode_AS_UNICODE\n\t\t\t\t\t\t   (visual),\n\t\t\t\t\t\t   PyUnicode_GET_SIZE (visual),\n\t\t\t\t\t\t   encoding, \"strict\");\n\t\t\tPy_DECREF (visual);\n\t\t}\n\t}\n\tPy_DECREF (logical);\n\treturn result;\n}", "target": 1}
{"code": "static inline int crypto_rng_generate(struct crypto_rng *tfm,\n\t\t\t\t      const u8 *src, unsigned int slen,\n\t\t\t\t      u8 *dst, unsigned int dlen)\n{\n\treturn tfm->generate(tfm, src, slen, dst, dlen);\n}", "target": 1}
{"code": "decode_rt_routing_info(netdissect_options *ndo,\n                       const u_char *pptr, char *buf, u_int buflen)\n{\n\tuint8_t route_target[8];\n\tu_int plen;\n\tND_TCHECK(pptr[0]);\n\tplen = pptr[0];   \n\tif (0 == plen) {\n\t\tsnprintf(buf, buflen, \"default route target\");\n\t\treturn 1;\n\t}\n\tif (32 > plen)\n\t\treturn -1;\n        plen-=32; \n\tif (64 < plen)\n\t\treturn -1;\n\tmemset(&route_target, 0, sizeof(route_target));\n\tND_TCHECK2(pptr[1], (plen + 7) / 8);\n\tmemcpy(&route_target, &pptr[1], (plen + 7) / 8);\n\tif (plen % 8) {\n\t\t((u_char *)&route_target)[(plen + 7) / 8 - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, buflen, \"origin AS: %s, route target %s\",\n\t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(pptr+1)),\n\t    bgp_vpn_rd_print(ndo, (u_char *)&route_target));\n\treturn 5 + (plen + 7) / 8;\ntrunc:\n\treturn -2;\n}", "target": 1}
{"code": "check_entry_for_referral(Slapi_PBlock *pb, Slapi_Entry *entry, char *matched, const char *callingfn) \n{\n\tint rc=0, i=0, numValues=0;\n\tSlapi_Attr *attr;\n\tSlapi_Value *val=NULL;\t\n\tstruct berval **refscopy=NULL;\n\tstruct berval **url=NULL;\n\tif ( slapi_entry_attr_find( entry, \"ref\", &attr ) )\n\t{\n\t\tgoto out;\n\t}\n\tslapi_attr_get_numvalues(attr, &numValues );\n\tif(numValues == 0) {\n\t\tgoto out;\n\t}\n\turl=(struct berval **) slapi_ch_malloc((numValues + 1) * sizeof(struct berval*));\n\tif (!url) {\n\t\tLDAPDebug( LDAP_DEBUG_ANY,\n\t\t\t\"check_entry_for_referral: Out of memory\\n\",\n\t\t\t0, 0, 0);\n\t\tgoto out;\n\t}\n\tfor (i = slapi_attr_first_value(attr, &val); i != -1;\n\t     i = slapi_attr_next_value(attr, i, &val)) {\n\t\turl[i]=(struct berval*)slapi_value_get_berval(val);\n\t}\n\turl[numValues]=NULL;\t\t\n\trefscopy = ref_adjust( pb, url, slapi_entry_get_sdn(entry), 0 ); \n\tslapi_send_ldap_result( pb, LDAP_REFERRAL, matched, NULL, 0, refscopy );\n\trc= 1;\n\tLDAPDebug( LDAP_DEBUG_TRACE,\n\t\t\"<= %s sent referral to (%s) for (%s)\\n\",\n\t\tcallingfn,\n\t\trefscopy ? refscopy[0]->bv_val : \"\",\n\t\tslapi_entry_get_dn(entry));\nout:\n\tif ( refscopy != NULL )\n\t{\n\t\tber_bvecfree( refscopy );\n\t}\n\tif( url != NULL) {\n\t\tslapi_ch_free( (void **)&url );\t\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "static void handle_get_accept(struct http_conn *conn,\n\t\t\t      const struct http_msg *msg,\n\t\t\t      struct mbuf *mb, size_t clen)\n{\n\tstruct ident_entry *ie = NULL;\n\tstruct pl pl;\n\tchar *key = NULL;\n\tint err;\n\tinfo(\"handle get accept\\n\");\n\terr = re_regex(msg->prm.p, msg->prm.l, \"?pairid=[0-9]+\", &pl);\n\tif (err) {\n\t\twarning(\"invalid input\\n\");\n\t\tgoto out;\n\t}\n\tpl_strdup(&key, &pl);\n\tie = dict_lookup(verifyd.idents, key);\n\tif (!ie) {\n\t\tinfo(\"accept: pairing-id %s not found\\n\", key);\n\t\thttp_ereply(conn, 404, \"Not found\");\n\t\tgoto out;\n\t}\n\tdebug(\"handle get accept (content=%s)\\n\", ie->content.accept);\n\tif (ie->content.accept) {\n\t\thttp_creply(conn, 200, \"OK\",\n\t\t\t    \"application/json\", \"%s\", ie->content.accept);\n\t}\n\telse {\n\t\thttp_ereply(conn, 404, \"Not Yet\");\n\t}\n\thttp_conn_close(conn);\n out:\n\tmem_deref(key);\n}", "target": 0}
{"code": "static int sd_e_h(GWindow gw, GEvent *event) {\n    struct sd_data *sd = GDrawGetUserData(gw);\n    if ( sd==NULL )\nreturn( true );\n    if ( event->type==et_close ) {\n\tSD_DoCancel( sd );\n    } else if ( event->type==et_controlevent && event->u.control.subtype==et_textchanged ) {\n    sd->fv->script_unsaved = !GTextFieldIsEmpty(GWidgetGetControl(sd->gw,CID_Script));\n    } else if ( event->type==et_controlevent && event->u.control.subtype==et_save ) {\n    sd->fv->script_unsaved = false;\n    } else if ( event->type==et_char ) {\n\tif ( event->u.chr.keysym == GK_F1 || event->u.chr.keysym == GK_Help ) {\n\t    help(\"scripting.html\");\nreturn( true );\n\t}\nreturn( false );\n    } else if ( event->type == et_map )\t\n\tGDrawRaise(gw);\n    else if ( event->type == et_resize )\n\tGDrawRequestExpose(gw,NULL,false);\nreturn( true );\n}", "target": 0}
{"code": "  void SetUp() override {\n    auto *file = UTHENTICODE_TEST_ASSETS \"/A_SSLippery_Slope.exe\";\n    pe = peparse::ParsePEFromFile(file);\n    ASSERT_TRUE(pe != nullptr);\n  }", "target": 0}
{"code": "static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,\n\t\t\t\t    struct net_device *ndev)\n{\n\tstruct hns_nic_priv *priv = netdev_priv(ndev);\n\tint ret;\n\tassert(skb->queue_mapping < ndev->ae_handle->q_num);\n\tret = hns_nic_net_xmit_hw(ndev, skb,\n\t\t\t\t  &tx_ring_data(priv, skb->queue_mapping));\n\tif (ret == NETDEV_TX_OK) {\n\t\tnetif_trans_update(ndev);\n\t\tndev->stats.tx_bytes += skb->len;\n\t\tndev->stats.tx_packets++;\n\t}\n\treturn (netdev_tx_t)ret;\n}", "target": 1}
{"code": "static HashTable *php_zip_get_gc(zval *object, zval ***gc_data, int *gc_data_count TSRMLS_DC) \n{\n\t*gc_data = NULL;\n\t*gc_data_count = 0;\n\treturn zend_std_get_properties(object TSRMLS_CC);\n}", "target": 0}
{"code": "GF_Err gf_isom_get_fragmented_samples_info(GF_ISOFile *movie, GF_ISOTrackID trackID, u32 *nb_samples, u64 *duration)\n{\n\tu32 i=0;\n\tu32 k, l;\n\tGF_MovieFragmentBox *moof;\n\tGF_TrackFragmentBox *traf;\n\t*nb_samples = 0;\n\t*duration = 0;\n\twhile ((moof=(GF_MovieFragmentBox*)gf_list_enum(movie->TopBoxes, &i))) {\n\t\tu32 j=0;\n\t\tif (moof->type!=GF_ISOM_BOX_TYPE_MOOF) continue;\n\t\twhile ((traf=(GF_TrackFragmentBox*)gf_list_enum( moof->TrackList, &j))) {\n\t\t\tu64 def_duration, samp_dur=0;\n\t\t\tif (traf->tfhd->trackID != trackID)\n\t\t\t\tcontinue;\n\t\t\tdef_duration = 0;\n\t\t\tif (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_DUR) def_duration = traf->tfhd->def_sample_duration;\n\t\t\telse if (traf->trex) def_duration = traf->trex->def_sample_duration;\n\t\t\tfor (k=0; k<gf_list_count(traf->TrackRuns); k++) {\n\t\t\t\tGF_TrackFragmentRunBox *trun = (GF_TrackFragmentRunBox*)gf_list_get(traf->TrackRuns, k);\n\t\t\t\t*nb_samples += trun->sample_count;\n\t\t\t\tfor (l=0; l<trun->nb_samples; l++) {\n\t\t\t\t\tGF_TrunEntry *ent = &trun->samples[l];\n\t\t\t\t\tsamp_dur = def_duration;\n\t\t\t\t\tif (trun->flags & GF_ISOM_TRUN_DURATION) samp_dur = ent->Duration;\n\t\t\t\t\tif (trun->nb_samples == trun->sample_count)\n\t\t\t\t\t\t*duration += samp_dur;\n\t\t\t\t}\n\t\t\t\tif (trun->nb_samples != trun->sample_count)\n\t\t\t\t\t*duration += samp_dur * trun->sample_count;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "static void rd_release_device_space(struct rd_dev *rd_dev)\n{\n\tu32 i, j, page_count = 0, sg_per_table;\n\tstruct rd_dev_sg_table *sg_table;\n\tstruct page *pg;\n\tstruct scatterlist *sg;\n\tif (!rd_dev->sg_table_array || !rd_dev->sg_table_count)\n\t\treturn;\n\tsg_table = rd_dev->sg_table_array;\n\tfor (i = 0; i < rd_dev->sg_table_count; i++) {\n\t\tsg = sg_table[i].sg_table;\n\t\tsg_per_table = sg_table[i].rd_sg_count;\n\t\tfor (j = 0; j < sg_per_table; j++) {\n\t\t\tpg = sg_page(&sg[j]);\n\t\t\tif (pg) {\n\t\t\t\t__free_page(pg);\n\t\t\t\tpage_count++;\n\t\t\t}\n\t\t}\n\t\tkfree(sg);\n\t}\n\tpr_debug(\"CORE_RD[%u] - Released device space for Ramdisk\"\n\t\t\" Device ID: %u, pages %u in %u tables total bytes %lu\\n\",\n\t\trd_dev->rd_host->rd_host_id, rd_dev->rd_dev_id, page_count,\n\t\trd_dev->sg_table_count, (unsigned long)page_count * PAGE_SIZE);\n\tkfree(sg_table);\n\trd_dev->sg_table_array = NULL;\n\trd_dev->sg_table_count = 0;\n}", "target": 1}
{"code": "static void JS_FoxxAllowInstallFromRemote(v8::FunctionCallbackInfo<v8::Value> const& args) {\n  TRI_V8_TRY_CATCH_BEGIN(isolate)\n  v8::HandleScope scope(isolate);\n  TRI_GET_GLOBALS();\n  ServerSecurityFeature& security = v8g->_server.getFeature<ServerSecurityFeature>();\n  TRI_V8_RETURN_BOOL(security.foxxAllowInstallFromRemote());\n  TRI_V8_TRY_CATCH_END\n}", "target": 0}
{"code": "void ip4_datagram_release_cb(struct sock *sk)\n{\n\tconst struct inet_sock *inet = inet_sk(sk);\n\tconst struct ip_options_rcu *inet_opt;\n\t__be32 daddr = inet->inet_daddr;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\tif (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))\n\t\treturn;\n\trcu_read_lock();\n\tinet_opt = rcu_dereference(inet->inet_opt);\n\tif (inet_opt && inet_opt->opt.srr)\n\t\tdaddr = inet_opt->opt.faddr;\n\trt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,\n\t\t\t\t   inet->inet_saddr, inet->inet_dport,\n\t\t\t\t   inet->inet_sport, sk->sk_protocol,\n\t\t\t\t   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);\n\tif (!IS_ERR(rt))\n\t\t__sk_dst_set(sk, &rt->dst);\n\trcu_read_unlock();\n}", "target": 1}
{"code": "static int do_devinfo_ioctl(struct comedi_device *dev,\n\t\t\t    struct comedi_devinfo __user *arg,\n\t\t\t    struct file *file)\n{\n\tstruct comedi_devinfo devinfo;\n\tconst unsigned minor = iminor(file->f_dentry->d_inode);\n\tstruct comedi_device_file_info *dev_file_info =\n\t    comedi_get_device_file_info(minor);\n\tstruct comedi_subdevice *read_subdev =\n\t    comedi_get_read_subdevice(dev_file_info);\n\tstruct comedi_subdevice *write_subdev =\n\t    comedi_get_write_subdevice(dev_file_info);\n\tmemset(&devinfo, 0, sizeof(devinfo));\n\tdevinfo.version_code = COMEDI_VERSION_CODE;\n\tdevinfo.n_subdevs = dev->n_subdevices;\n\tmemcpy(devinfo.driver_name, dev->driver->driver_name, COMEDI_NAMELEN);\n\tmemcpy(devinfo.board_name, dev->board_name, COMEDI_NAMELEN);\n\tif (read_subdev)\n\t\tdevinfo.read_subdevice = read_subdev - dev->subdevices;\n\telse\n\t\tdevinfo.read_subdevice = -1;\n\tif (write_subdev)\n\t\tdevinfo.write_subdevice = write_subdev - dev->subdevices;\n\telse\n\t\tdevinfo.write_subdevice = -1;\n\tif (copy_to_user(arg, &devinfo, sizeof(struct comedi_devinfo)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "void BytecodeModuleGenerator::setFunctionGenerator(\n    Function *F,\n    unique_ptr<BytecodeFunctionGenerator> BFG) {\n  assert(\n      functionGenerators_.find(F) == functionGenerators_.end() &&\n      \"Adding same function twice.\");\n  assert(\n      !BFG->hasEncodingError() && \"Error should have been reported already.\");\n  functionGenerators_[F] = std::move(BFG);\n}", "target": 0}
{"code": "void DISOpticalFlowImpl::autoSelectPatchSizeAndScales(int img_width)\n{\n    switch (finest_scale)\n    {\n    case 1:\n        patch_size = 8;\n        coarsest_scale = autoSelectCoarsestScale(img_width);\n        finest_scale = std::max(coarsest_scale-2, 0);\n        break;\n    case 3:\n        patch_size = 12;\n        coarsest_scale = autoSelectCoarsestScale(img_width);\n        finest_scale = std::max(coarsest_scale-4, 0);\n        break;\n    case 4:\n        patch_size = 12;\n        coarsest_scale = autoSelectCoarsestScale(img_width);\n        finest_scale = std::max(coarsest_scale-5, 0);\n        break;\n    case 2:\n    default:\n        patch_size = 8;\n        coarsest_scale = autoSelectCoarsestScale(img_width);\n        finest_scale = std::max(coarsest_scale-2, 0);\n        break;\n    }\n}", "target": 0}
{"code": "static int ext4_convert_unwritten_extents_endio(handle_t *handle,\n\t\t\t\t\t      struct inode *inode,\n\t\t\t\t\t      struct ext4_ext_path *path)\n{\n\tstruct ext4_extent *ex;\n\tint depth;\n\tint err = 0;\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\text_debug(\"ext4_convert_unwritten_extents_endio: inode %lu, logical\"\n\t\t\"block %llu, max_blocks %u\\n\", inode->i_ino,\n\t\t(unsigned long long)le32_to_cpu(ex->ee_block),\n\t\text4_ext_get_actual_len(ex));\n\terr = ext4_ext_get_access(handle, inode, path + depth);\n\tif (err)\n\t\tgoto out;\n\text4_ext_mark_initialized(ex);\n\text4_ext_try_to_merge(handle, inode, path, ex);\n\terr = ext4_ext_dirty(handle, inode, path + path->p_depth);\nout:\n\text4_ext_show_leaf(inode, path);\n\treturn err;\n}", "target": 1}
{"code": "void pickSlurp(sdbus::MethodCall& call) {\n    const std::string PICK_COLOR_CMD = \"grim -g \\\"$(slurp -p)\\\" -t ppm -\";\n    std::string       ppmColor       = execAndGet(PICK_COLOR_CMD.c_str());\n    ppmColor = std::regex_replace(ppmColor, std::regex(\"\\\\s+\"), std::string(\" \"));\n    if (!ppmColor.starts_with(\"P6 1 1 \")) {\n        Debug::log(ERR, \"grim did not return a PPM Image for us.\");\n        sendEmptyDbusMethodReply(call, 1);\n        return;\n    }\n    try {\n        std::string maxValString = ppmColor.substr(7, ppmColor.size());\n        maxValString             = maxValString.substr(0, maxValString.find(' '));\n        uint32_t maxVal          = std::stoi(maxValString);\n        double r, g, b;\n        if (maxVal < 256) {\n            std::string byteString = ppmColor.substr(11, 14);\n            r = (uint8_t)byteString[0] / (maxVal * 1.0);\n            g = (uint8_t)byteString[1] / (maxVal * 1.0);\n            b = (uint8_t)byteString[2] / (maxVal * 1.0);\n        } else {\n            std::string byteString = ppmColor.substr(11, 17);\n            r = ((byteString[0] << 8) | byteString[1]) / (maxVal * 1.0);\n            g = ((byteString[2] << 8) | byteString[3]) / (maxVal * 1.0);\n            b = ((byteString[4] << 8) | byteString[5]) / (maxVal * 1.0);\n        }\n        auto reply = call.createReply();\n        std::unordered_map<std::string, sdbus::Variant> results;\n        results[\"color\"] = sdbus::Struct(std::tuple{r, g, b});\n        reply << (uint32_t)0;\n        reply << results;\n        reply.send();\n    } catch (...) {\n        Debug::log(ERR, \"Converting PPM to RGB failed. This is likely a string to integer error.\");\n        sendEmptyDbusMethodReply(call, 1);\n    }\n}", "target": 1}
{"code": "static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n\t\t    !test_bit(KEY_FLAG_NEGATIVE, &key->flags) &&\n\t\t    key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\t\tsecurity_key_free(key);\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\t\tatomic_dec(&key->user->nkeys);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n\t\t\tatomic_dec(&key->user->nikeys);\n\t\tkey_user_put(key->user);\n\t\tkfree(key->description);\n\t\tmemzero_explicit(key, sizeof(*key));\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}", "target": 1}
{"code": "\t__releases(proto_list_mutex)\n{\n\tmutex_unlock(&proto_list_mutex);\n}", "target": 0}
{"code": "int rpc_type_of_NPNVariable(int variable)\n{\n  int type;\n  switch (variable) {\n  case NPNVjavascriptEnabledBool:\n  case NPNVasdEnabledBool:\n  case NPNVisOfflineBool:\n  case NPNVSupportsXEmbedBool:\n  case NPNVSupportsWindowless:\n  case NPNVprivateModeBool:\n  case NPNVsupportsAdvancedKeyHandling:\n\ttype = RPC_TYPE_BOOLEAN;\n\tbreak;\n  case NPNVToolkit:\n  case NPNVnetscapeWindow:\n\ttype = RPC_TYPE_UINT32;\n\tbreak;\n  case NPNVWindowNPObject:\n  case NPNVPluginElementNPObject:\n\ttype = RPC_TYPE_NP_OBJECT;\n\tbreak;\n  default:\n\ttype = RPC_ERROR_GENERIC;\n\tbreak;\n  }\n  return type;\n}", "target": 0}
{"code": "need_reloc_mappable(struct drm_i915_gem_object *obj)\n{\n\tstruct drm_i915_gem_exec_object2 *entry = obj->exec_entry;\n\treturn entry->relocation_count && !use_cpu_reloc(obj);\n}", "target": 0}
{"code": "    bool cmpPreviewProperties(\n        const PreviewProperties& lhs,\n        const PreviewProperties& rhs\n    )\n    {\n        uint32_t l = lhs.width_ * lhs.height_;\n        uint32_t r = rhs.width_ * rhs.height_;\n        return l < r;\n    }", "target": 0}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  TFLITE_DCHECK(node->builtin_data != nullptr);\n  auto* params = reinterpret_cast<TfLiteL2NormParams*>(node->builtin_data);\n  L2NormalizationParams* data =\n      static_cast<L2NormalizationParams*>(node->user_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE(context, NumDimensions(input) <= 4);\n  TF_LITE_ENSURE(context, output->type == kTfLiteFloat32 ||\n                              output->type == kTfLiteUInt8 ||\n                              output->type == kTfLiteInt8);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  if (output->type == kTfLiteUInt8 || output->type == kTfLiteInt8) {\n    data->input_zero_point = input->params.zero_point;\n  } else if (output->type == kTfLiteFloat32) {\n    data->input_zero_point = 0;\n  }\n  TF_LITE_ENSURE_EQ(context, params->activation, kTfLiteActNone);\n  return kTfLiteOk;\n}", "target": 0}
{"code": "void LayerTilerChromium::invalidateEntireLayer()\n{\n    for (size_t i = 0; i < m_tiles.size(); ++i) {\n        if (m_tiles[i])\n            m_unusedTiles.append(m_tiles[i].release());\n    }\n    m_tiles.clear();\n    m_layerSize = IntSize();\n    m_layerTileSize = IntSize();\n    m_lastUpdateLayerRect = IntRect();\n}", "target": 0}
{"code": "Status SparseCountSparseOutputShapeFn(InferenceContext *c) {\n  ShapeHandle unused;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &unused));\n  auto rank = c->Dim(c->input(0), 1);\n  auto nvals = c->UnknownDim();\n  c->set_output(0, c->Matrix(nvals, rank));  \n  c->set_output(1, c->Vector(nvals));        \n  c->set_output(2, c->Vector(rank));         \n  return Status::OK();\n}", "target": 0}
{"code": "PHPAPI PHP_FUNCTION(fread)\n{\n\tzval *arg1;\n\tlong len;\n\tphp_stream *stream;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl\", &arg1, &len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\tif (len <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be greater than 0\");\n\t\tRETURN_FALSE;\n\t}\n\tif (len > INT_MAX) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be no more than %d\", INT_MAX);\n\t\tRETURN_FALSE;\n\t}\n\tZ_STRVAL_P(return_value) = emalloc(len + 1);\n\tZ_STRLEN_P(return_value) = php_stream_read(stream, Z_STRVAL_P(return_value), len);\n\tZ_STRVAL_P(return_value)[Z_STRLEN_P(return_value)] = 0;\n\tZ_TYPE_P(return_value) = IS_STRING;\n}", "target": 0}
{"code": "static void cmd_parse_lsub(struct ImapData *idata, char *s)\n{\n  char buf[STRING];\n  char errstr[STRING];\n  struct Buffer err, token;\n  struct Url url;\n  struct ImapList list;\n  if (idata->cmddata && idata->cmdtype == IMAP_CT_LIST)\n  {\n    cmd_parse_list(idata, s);\n    return;\n  }\n  if (!ImapCheckSubscribed)\n    return;\n  idata->cmdtype = IMAP_CT_LIST;\n  idata->cmddata = &list;\n  cmd_parse_list(idata, s);\n  idata->cmddata = NULL;\n  if (!list.name || list.noselect)\n    return;\n  mutt_debug(3, \"Subscribing to %s\\n\", list.name);\n  mutt_str_strfcpy(buf, \"mailboxes \\\"\", sizeof(buf));\n  mutt_account_tourl(&idata->conn->account, &url);\n  imap_quote_string(errstr, sizeof(errstr), list.name);\n  url.path = errstr + 1;\n  url.path[strlen(url.path) - 1] = '\\0';\n  if (mutt_str_strcmp(url.user, ImapUser) == 0)\n    url.user = NULL;\n  url_tostring(&url, buf + 11, sizeof(buf) - 11, 0);\n  mutt_str_strcat(buf, sizeof(buf), \"\\\"\");\n  mutt_buffer_init(&token);\n  mutt_buffer_init(&err);\n  err.data = errstr;\n  err.dsize = sizeof(errstr);\n  if (mutt_parse_rc_line(buf, &token, &err))\n    mutt_debug(1, \"Error adding subscribed mailbox: %s\\n\", errstr);\n  FREE(&token.data);\n}", "target": 1}
{"code": "TfLiteStatus GatherNd(const TfLiteEvalTensor* params,\n                      const TfLiteEvalTensor* indices,\n                      TfLiteEvalTensor* output) {\n  const int indices_dims = indices->dims->size;\n  const int indices_nd = indices->dims->data[indices_dims - 1];\n  const int params_dims = params->dims->size;\n  const IndicesT* index_data = tflite::micro::GetTensorData<IndicesT>(indices);\n  const ParamsT* param_data = tflite::micro::GetTensorData<ParamsT>(params);\n  ParamsT* output_data = tflite::micro::GetTensorData<ParamsT>(output);\n  int n_slices = 1;\n  for (int i = 0; i < indices_dims - 1; ++i) {\n    n_slices *= indices->dims->data[i];\n  }\n  int slice_size = 1;\n  for (int i = indices_nd; i < params_dims; ++i) {\n    slice_size *= params->dims->data[i];\n  }\n  int remain_flat_size = ElementCount(*params->dims);\n  int dims_to_count[MAX_INDICES_ND];\n  for (int i = 0; i < indices_nd; ++i) {\n    dims_to_count[i] = remain_flat_size / params->dims->data[i];\n    remain_flat_size = dims_to_count[i];\n  }\n  for (int i = 0; i < n_slices; ++i) {\n    int from_pos = 0;\n    for (int j = 0; j < indices_nd; ++j) {\n      int offset = i * indices_nd + j;\n      IndicesT index = index_data[offset];\n      from_pos += index * dims_to_count[j];\n    }\n    std::memcpy(output_data + i * slice_size, param_data + from_pos,\n                sizeof(ParamsT) * slice_size);\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "  FramebufferManager::FramebufferInfo* GetFramebufferInfoForTarget(\n      GLenum target) {\n    FramebufferManager::FramebufferInfo* info = NULL;\n    switch (target) {\n      case GL_FRAMEBUFFER:\n      case GL_DRAW_FRAMEBUFFER:\n        info = bound_draw_framebuffer_;\n        break;\n      case GL_READ_FRAMEBUFFER:\n        info = bound_read_framebuffer_;\n        break;\n      default:\n        NOTREACHED();\n        break;\n    }\n    return info;\n  }", "target": 0}
{"code": "static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    int item_num = avio_rb32(pb);\n    int item_len = avio_rb32(pb);\n    if (item_len != 18) {\n        avpriv_request_sample(pb, \"Primer pack item length %d\", item_len);\n        return AVERROR_PATCHWELCOME;\n    }\n    if (item_num > 65536) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"item_num %d is too large\\n\", item_num);\n        return AVERROR_INVALIDDATA;\n    }\n    mxf->local_tags = av_calloc(item_num, item_len);\n    if (!mxf->local_tags)\n        return AVERROR(ENOMEM);\n    mxf->local_tags_count = item_num;\n    avio_read(pb, mxf->local_tags, item_num*item_len);\n    return 0;\n}", "target": 1}
{"code": "void sdb_edit(procinfo *pi)\n{\n  char * filename = omStrDup(\"/tmp/sd000000\");\n  sprintf(filename+7,\"%d\",getpid());\n  FILE *fp=fopen(filename,\"w\");\n  if (fp==NULL)\n  {\n    Print(\"cannot open %s\\n\",filename);\n    omFree(filename);\n    return;\n  }\n  if (pi->language!= LANG_SINGULAR)\n  {\n    Print(\"cannot edit type %d\\n\",pi->language);\n    fclose(fp);\n    fp=NULL;\n  }\n  else\n  {\n    const char *editor=getenv(\"EDITOR\");\n    if (editor==NULL)\n      editor=getenv(\"VISUAL\");\n    if (editor==NULL)\n      editor=\"vi\";\n    editor=omStrDup(editor);\n    if (pi->data.s.body==NULL)\n    {\n      iiGetLibProcBuffer(pi);\n      if (pi->data.s.body==NULL)\n      {\n        PrintS(\"cannot get the procedure body\\n\");\n        fclose(fp);\n        si_unlink(filename);\n        omFree(filename);\n        return;\n      }\n    }\n    fwrite(pi->data.s.body,1,strlen(pi->data.s.body),fp);\n    fclose(fp);\n    int pid=fork();\n    if (pid!=0)\n    {\n      si_wait(&pid);\n    }\n    else if(pid==0)\n    {\n      if (strchr(editor,' ')==NULL)\n      {\n        execlp(editor,editor,filename,NULL);\n        Print(\"cannot exec %s\\n\",editor);\n      }\n      else\n      {\n        char *p=(char *)omAlloc(strlen(editor)+strlen(filename)+2);\n        sprintf(p,\"%s %s\",editor,filename);\n        system(p);\n      }\n      exit(0);\n    }\n    else\n    {\n      PrintS(\"cannot fork\\n\");\n    }\n    fp=fopen(filename,\"r\");\n    if (fp==NULL)\n    {\n      Print(\"cannot read from %s\\n\",filename);\n    }\n    else\n    {\n      fseek(fp,0L,SEEK_END);\n      long len=ftell(fp);\n      fseek(fp,0L,SEEK_SET);\n      omFree((ADDRESS)pi->data.s.body);\n      pi->data.s.body=(char *)omAlloc((int)len+1);\n      myfread( pi->data.s.body, len, 1, fp);\n      pi->data.s.body[len]='\\0';\n      fclose(fp);\n    }\n  }\n  si_unlink(filename);\n  omFree(filename);\n}", "target": 1}
{"code": "static int hashtable_do_del(hashtable_t *hashtable,\n                            const char *key, size_t hash)\n{\n    pair_t *pair;\n    bucket_t *bucket;\n    size_t index;\n    index = hash % num_buckets(hashtable);\n    bucket = &hashtable->buckets[index];\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n    if(!pair)\n        return -1;\n    if(&pair->list == bucket->first && &pair->list == bucket->last)\n        bucket->first = bucket->last = &hashtable->list;\n    else if(&pair->list == bucket->first)\n        bucket->first = pair->list.next;\n    else if(&pair->list == bucket->last)\n        bucket->last = pair->list.prev;\n    list_remove(&pair->list);\n    json_decref(pair->value);\n    jsonp_free(pair);\n    hashtable->size--;\n    return 0;\n}", "target": 1}
{"code": "TfLiteStatus ResizeOutput(TfLiteContext* context, const TfLiteTensor* input,\n                          const TfLiteTensor* axis, TfLiteTensor* output) {\n  int axis_value;\n  if (axis->type == kTfLiteInt64) {\n    axis_value = static_cast<int>(*GetTensorData<int64_t>(axis));\n  } else {\n    axis_value = *GetTensorData<int>(axis);\n  }\n  if (axis_value < 0) {\n    axis_value += NumDimensions(input);\n  }\n  TF_LITE_ENSURE(context, axis_value >= 0);\n  TF_LITE_ENSURE(context, axis_value < NumDimensions(input));\n  TfLiteIntArray* output_dims = TfLiteIntArrayCreate(NumDimensions(input) - 1);\n  int j = 0;\n  for (int i = 0; i < NumDimensions(input); ++i) {\n    if (i != axis_value) {\n      output_dims->data[j] = SizeOfDimension(input, i);\n      ++j;\n    }\n  }\n  return context->ResizeTensor(context, output, output_dims);\n}", "target": 0}
{"code": "push_tag(struct readbuffer *obuf, char *cmdname, int cmd)\n{\n    obuf->tag_stack[obuf->tag_sp] = New(struct cmdtable);\n    obuf->tag_stack[obuf->tag_sp]->cmdname = allocStr(cmdname, -1);\n    obuf->tag_stack[obuf->tag_sp]->cmd = cmd;\n    obuf->tag_sp++;\n    if (obuf->tag_sp >= TAG_STACK_SIZE || obuf->flag & (RB_SPECIAL & ~RB_NOBR))\n\tappend_tags(obuf);\n}", "target": 0}
{"code": "struct resource_pool *dce120_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\tif (!pool)\n\t\treturn NULL;\n\tif (construct(num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\tkfree(pool);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 0}
{"code": "int StreamInfoWrapper::luaDynamicMetadata(lua_State* state) {\n  if (dynamic_metadata_wrapper_.get() != nullptr) {\n    dynamic_metadata_wrapper_.pushStack();\n  } else {\n    dynamic_metadata_wrapper_.reset(DynamicMetadataMapWrapper::create(state, *this), true);\n  }\n  return 1;\n}", "target": 0}
{"code": "  explicit FractionalMaxPoolOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"pooling_ratio\", &pooling_ratio_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"pseudo_random\", &pseudo_random_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"overlapping\", &overlapping_));\n    OP_REQUIRES(context, pooling_ratio_.size() == 4,\n                errors::InvalidArgument(\"pooling_ratio field must \"\n                                        \"specify 4 dimensions\"));\n    for (std::size_t i = 0; i < pooling_ratio_.size(); ++i) {\n      OP_REQUIRES(context, pooling_ratio_[i] >= 1,\n                  errors::InvalidArgument(\n                      \"pooling_ratio cannot be smaller than 1, got: \",\n                      pooling_ratio_[i]));\n    }\n    OP_REQUIRES(\n        context, pooling_ratio_[0] == 1 && pooling_ratio_[3] == 1,\n        errors::Unimplemented(\"Fractional max pooling is not yet \"\n                              \"supported on the batch nor channel dimension.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"deterministic\", &deterministic_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed\", &seed_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed2\", &seed2_));\n    if (deterministic_) {\n      if ((seed_ == 0) && (seed2_ == 0)) {\n        seed_ = random::New64();\n        seed2_ = random::New64();\n      }\n    } else {\n      OP_REQUIRES(\n          context, (seed_ == 0) && (seed2_ == 0),\n          errors::InvalidArgument(\n              \"Both seed and seed2 should be 0 if deterministic is false.\"));\n    }\n  }", "target": 0}
{"code": "is_anychar_star_quantifier(QtfrNode* qn)\n{\n  if (qn->greedy && IS_REPEAT_INFINITE(qn->upper) &&\n      NTYPE(qn->target) == NT_CANY)\n    return 1;\n  else\n    return 0;\n}", "target": 0}
{"code": "static int __init snd_mem_init(void)\n{\n#ifdef CONFIG_PROC_FS\n\tsnd_mem_proc = create_proc_entry(SND_MEM_PROC_FILE, 0644, NULL);\n\tif (snd_mem_proc)\n\t\tsnd_mem_proc->proc_fops = &snd_mem_proc_fops;\n#endif\n\treturn 0;\n}", "target": 0}
{"code": "static void nested_release_page(struct page *page)\n{\n\tkvm_release_page_dirty(page);\n}", "target": 0}
{"code": "static void skip_metadata(struct pstore *ps)\n{\n\tuint32_t stride = ps->exceptions_per_area + 1;\n\tchunk_t next_free = ps->next_free;\n\tif (sector_div(next_free, stride) == NUM_SNAPSHOT_HDR_CHUNKS)\n\t\tps->next_free++;\n}", "target": 0}
{"code": "getprivs_ret * get_privs_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)\n{\n    static getprivs_ret            ret;\n    gss_buffer_desc                client_name, service_name;\n    OM_uint32                      minor_stat;\n    kadm5_server_handle_t          handle;\n    const char                     *errmsg = NULL;\n    xdr_free(xdr_getprivs_ret, &ret);\n    if ((ret.code = new_server_handle(*arg, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    ret.code = kadm5_get_privs((void *)handle, &ret.privs);\n    if( ret.code != 0 )\n        errmsg = krb5_get_error_message(handle->context, ret.code);\n    log_done(\"kadm5_get_privs\", client_name.value, errmsg,\n             &client_name, &service_name, rqstp);\n    if (errmsg != NULL)\n        krb5_free_error_message(handle->context, errmsg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "static void reset_active(struct i915_request *rq,\n\t\t\t struct intel_engine_cs *engine)\n{\n\tstruct intel_context * const ce = rq->hw_context;\n\tu32 head;\n\tGEM_TRACE(\"%s(%s): { rq=%llx:%lld }\\n\",\n\t\t  __func__, engine->name, rq->fence.context, rq->fence.seqno);\n\tif (i915_request_completed(rq))\n\t\thead = rq->tail;\n\telse\n\t\thead = active_request(ce->timeline, rq)->head;\n\tce->ring->head = intel_ring_wrap(ce->ring, head);\n\tintel_ring_update_space(ce->ring);\n\trestore_default_state(ce, engine);\n\t__execlists_update_reg_state(ce, engine);\n\tce->lrc_desc |= CTX_DESC_FORCE_RESTORE;\n}", "target": 0}
{"code": "int genl_register_family(struct genl_family *family)\n{\n\tint err, i;\n\tint start = GENL_START_ALLOC, end = GENL_MAX_ID;\n\terr = genl_validate_ops(family);\n\tif (err)\n\t\treturn err;\n\tgenl_lock_all();\n\tif (genl_family_find_byname(family->name)) {\n\t\terr = -EEXIST;\n\t\tgoto errout_locked;\n\t}\n\tif (family == &genl_ctrl) {\n\t\tstart = end = GENL_ID_CTRL;\n\t} else if (strcmp(family->name, \"pmcraid\") == 0) {\n\t\tstart = end = GENL_ID_PMCRAID;\n\t} else if (strcmp(family->name, \"VFS_DQUOT\") == 0) {\n\t\tstart = end = GENL_ID_VFS_DQUOT;\n\t}\n\tif (family->maxattr && !family->parallel_ops) {\n\t\tfamily->attrbuf = kmalloc_array(family->maxattr + 1,\n\t\t\t\t\t\tsizeof(struct nlattr *),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (family->attrbuf == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto errout_locked;\n\t\t}\n\t} else\n\t\tfamily->attrbuf = NULL;\n\tfamily->id = idr_alloc(&genl_fam_idr, family,\n\t\t\t       start, end + 1, GFP_KERNEL);\n\tif (family->id < 0) {\n\t\terr = family->id;\n\t\tgoto errout_locked;\n\t}\n\terr = genl_validate_assign_mc_groups(family);\n\tif (err)\n\t\tgoto errout_remove;\n\tgenl_unlock_all();\n\tgenl_ctrl_event(CTRL_CMD_NEWFAMILY, family, NULL, 0);\n\tfor (i = 0; i < family->n_mcgrps; i++)\n\t\tgenl_ctrl_event(CTRL_CMD_NEWMCAST_GRP, family,\n\t\t\t\t&family->mcgrps[i], family->mcgrp_offset + i);\n\treturn 0;\nerrout_remove:\n\tidr_remove(&genl_fam_idr, family->id);\n\tkfree(family->attrbuf);\nerrout_locked:\n\tgenl_unlock_all();\n\treturn err;\n}", "target": 1}
{"code": "void HTTPServer::handleRequest(Client *cl, HTTPRequest* req) {\n\tif (!req->parse()) {\n\t\tstd::cout << \"[\" << cl->getClientIP() << \"] There was an error processing the request of type: \" << req->methodIntToStr(req->getMethod()) << std::endl;\n\t\tstd::cout << req->getParseError() << std::endl;\n\t\tsendStatusResponse(cl, Status(BAD_REQUEST), req->getParseError());\n\t\treturn;\n\t}\n\tstd::cout << \"[\" << cl->getClientIP() << \"] \" << req->methodIntToStr(req->getMethod()) << \" \" << req->getRequestUri() << std::endl;\n\tResourceHost* resHost = NULL;\n\tstd::string host = \"\";\n\tif (req->getVersion().compare(HTTP_VERSION_11) == 0) {\n\t\thost = req->getHeaderValue(\"Host\");\n\t\tif (host.find(\":\") == std::string::npos) {\n\t\t\thost.append(\":\" + std::to_string(listenPort));\n\t\t}\n\t\tstd::unordered_map<std::string, ResourceHost*>::const_iterator it = vhosts.find(host);\n\t\tif (it != vhosts.end())\n\t\t\tresHost = it->second;\n\t} else {\n\t\tif (hostList.size() > 0)\n\t\t\tresHost = hostList[0];\n\t}\n\tif (resHost == NULL) {\n\t\tsendStatusResponse(cl, Status(BAD_REQUEST), \"Invalid/No Host specified: \" + host);\n\t\treturn;\n\t}\n\tswitch (req->getMethod()) {\n\tcase Method(HEAD):\n\tcase Method(GET):\n\t\thandleGet(cl, req, resHost);\n\t\tbreak;\n\tcase Method(OPTIONS):\n\t\thandleOptions(cl, req);\n\t\tbreak;\n\tcase Method(TRACE):\n\t\thandleTrace(cl, req);\n\t\tbreak;\n\tdefault:\n\t\tstd::cout << \"[\" << cl->getClientIP() << \"] Could not handle or determine request of type \" << req->methodIntToStr(req->getMethod()) << std::endl;\n\t\tsendStatusResponse(cl, Status(NOT_IMPLEMENTED));\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "\tCommandAuthenticate(Module* Creator, SimpleExtItem<SaslAuthenticator>& ext, GenericCap& Cap)\n\t\t: Command(Creator, \"AUTHENTICATE\", 1), authExt(ext), cap(Cap)\n\t{\n\t\tworks_before_reg = true;\n\t\tallow_empty_last_param = false;\n\t}", "target": 0}
{"code": "static void _ipmi_destroy_user(struct ipmi_user *user)\n{\n\tstruct ipmi_smi  *intf = user->intf;\n\tint              i;\n\tunsigned long    flags;\n\tstruct cmd_rcvr  *rcvr;\n\tstruct cmd_rcvr  *rcvrs = NULL;\n\tif (!acquire_ipmi_user(user, &i)) {\n\t\tsynchronize_srcu(&user->release_barrier);\n\t\treturn;\n\t}\n\trcu_assign_pointer(user->self, NULL);\n\trelease_ipmi_user(user, i);\n\tsynchronize_srcu(&user->release_barrier);\n\tif (user->handler->shutdown)\n\t\tuser->handler->shutdown(user->handler_data);\n\tif (user->handler->ipmi_watchdog_pretimeout)\n\t\tsmi_remove_watch(intf, IPMI_WATCH_MASK_CHECK_WATCHDOG);\n\tif (user->gets_events)\n\t\tatomic_dec(&intf->event_waiters);\n\tspin_lock_irqsave(&intf->seq_lock, flags);\n\tlist_del_rcu(&user->link);\n\tfor (i = 0; i < IPMI_IPMB_NUM_SEQ; i++) {\n\t\tif (intf->seq_table[i].inuse\n\t\t    && (intf->seq_table[i].recv_msg->user == user)) {\n\t\t\tintf->seq_table[i].inuse = 0;\n\t\t\tsmi_remove_watch(intf, IPMI_WATCH_MASK_CHECK_MESSAGES);\n\t\t\tipmi_free_recv_msg(intf->seq_table[i].recv_msg);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&intf->seq_lock, flags);\n\tmutex_lock(&intf->cmd_rcvrs_mutex);\n\tlist_for_each_entry_rcu(rcvr, &intf->cmd_rcvrs, link) {\n\t\tif (rcvr->user == user) {\n\t\t\tlist_del_rcu(&rcvr->link);\n\t\t\trcvr->next = rcvrs;\n\t\t\trcvrs = rcvr;\n\t\t}\n\t}\n\tmutex_unlock(&intf->cmd_rcvrs_mutex);\n\tsynchronize_rcu();\n\twhile (rcvrs) {\n\t\trcvr = rcvrs;\n\t\trcvrs = rcvr->next;\n\t\tkfree(rcvr);\n\t}\n\tkref_put(&intf->refcount, intf_free);\n\tmodule_put(intf->owner);\n}", "target": 0}
{"code": "static int op_open1(OggOpusFile *_of,\n void *_stream,const OpusFileCallbacks *_cb,\n const unsigned char *_initial_data,size_t _initial_bytes){\n  ogg_page  og;\n  ogg_page *pog;\n  int       seekable;\n  int       ret;\n  memset(_of,0,sizeof(*_of));\n  if(OP_UNLIKELY(_initial_bytes>(size_t)LONG_MAX))return OP_EFAULT;\n  _of->end=-1;\n  _of->stream=_stream;\n  *&_of->callbacks=*_cb;\n  if(OP_UNLIKELY(_of->callbacks.read==NULL))return OP_EREAD;\n  ogg_sync_init(&_of->oy);\n  if(_initial_bytes>0){\n    char *buffer;\n    buffer=ogg_sync_buffer(&_of->oy,(long)_initial_bytes);\n    if(OP_UNLIKELY(buffer==NULL))return OP_EFAULT;\n    memcpy(buffer,_initial_data,_initial_bytes*sizeof(*buffer));\n    ogg_sync_wrote(&_of->oy,(long)_initial_bytes);\n  }\n  seekable=_cb->seek!=NULL&&(*_cb->seek)(_stream,0,SEEK_CUR)!=-1;\n  if(seekable){\n    opus_int64 pos;\n    if(OP_UNLIKELY(_of->callbacks.tell==NULL))return OP_EINVAL;\n    pos=(*_of->callbacks.tell)(_of->stream);\n    if(OP_UNLIKELY(pos!=(opus_int64)_initial_bytes))return OP_EINVAL;\n  }\n  _of->seekable=seekable;\n  _of->links=(OggOpusLink *)_ogg_malloc(sizeof(*_of->links));\n  ogg_stream_init(&_of->os,-1);\n  pog=NULL;\n  for(;;){\n    ret=op_fetch_headers(_of,&_of->links[0].head,&_of->links[0].tags,\n     &_of->serialnos,&_of->nserialnos,&_of->cserialnos,pog);\n    if(OP_UNLIKELY(ret<0))break;\n    _of->nlinks=1;\n    _of->links[0].offset=0;\n    _of->links[0].data_offset=_of->offset;\n    _of->links[0].pcm_end=-1;\n    _of->links[0].serialno=_of->os.serialno;\n    ret=op_find_initial_pcm_offset(_of,_of->links,&og);\n    if(seekable||OP_LIKELY(ret<=0))break;\n    opus_tags_clear(&_of->links[0].tags);\n    _of->nlinks=0;\n    if(!seekable)_of->cur_link++;\n    pog=&og;\n  }\n  if(OP_LIKELY(ret>=0))_of->ready_state=OP_PARTOPEN;\n  return ret;\n}", "target": 0}
{"code": "static TEE_Result do_allocate_publickey(struct rsa_public_key *key,\n\t\t\t\t\tsize_t size_bits)\n{\n\tRSA_TRACE(\"Allocate Public Key of %zu bits\", size_bits);\n\tmemset(key, 0, sizeof(*key));\n\tkey->e = crypto_bignum_allocate(MAX_BITS_EXP_E);\n\tif (!key->e)\n\t\tgoto err_alloc_publickey;\n\tkey->n = crypto_bignum_allocate(size_bits);\n\tif (!key->n)\n\t\tgoto err_alloc_publickey;\n\treturn TEE_SUCCESS;\nerr_alloc_publickey:\n\tRSA_TRACE(\"Allocation error\");\n\tcrypto_bignum_free(key->e);\n\tcrypto_bignum_free(key->n);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "int AVI_read_audio(avi_t *AVI, u8 *audbuf, int bytes, int *continuous)\n{\n\tint nr, todo;\n\ts64 pos;\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->track[AVI->aptr].audio_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\tnr = 0; \n\tif (bytes==0) {\n\t\tAVI->track[AVI->aptr].audio_posc++;\n\t\tAVI->track[AVI->aptr].audio_posb = 0;\n\t}\n\t*continuous = 1;\n\twhile(bytes>0)\n\t{\n\t\ts64 ret;\n\t\tint left = (int) (AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].len - AVI->track[AVI->aptr].audio_posb);\n\t\tif(left==0)\n\t\t{\n\t\t\tif(AVI->track[AVI->aptr].audio_posc>=AVI->track[AVI->aptr].audio_chunks-1) return nr;\n\t\t\tAVI->track[AVI->aptr].audio_posc++;\n\t\t\tAVI->track[AVI->aptr].audio_posb = 0;\n\t\t\t*continuous = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif(bytes<left)\n\t\t\ttodo = bytes;\n\t\telse\n\t\t\ttodo = left;\n\t\tpos = AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].pos + AVI->track[AVI->aptr].audio_posb;\n\t\tgf_fseek(AVI->fdes, pos, SEEK_SET);\n\t\tif ( (ret = avi_read(AVI->fdes,audbuf+nr,todo)) != todo)\n\t\t{\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] XXX pos = %\"LLD\", ret = %\"LLD\", todo = %ld\\n\", pos, ret, todo));\n\t\t\tAVI_errno = AVI_ERR_READ;\n\t\t\treturn -1;\n\t\t}\n\t\tbytes -= todo;\n\t\tnr    += todo;\n\t\tAVI->track[AVI->aptr].audio_posb += todo;\n\t}\n\treturn nr;\n}", "target": 1}
{"code": "void _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_flags);\n\thook_del_nick_can_register(check_registration_keywords);\n\thook_del_user_can_register(check_registration_keywords);\n\tdel_conf_item(\"ANOPE_FLAGS_COMPAT\", &chansvs.me->conf_table);\n}", "target": 0}
{"code": "void UnicodeStringTest::runIndexedTest( int32_t index, UBool exec, const char* &name, char *par)\n{\n    if (exec) logln(\"TestSuite UnicodeStringTest: \");\n    TESTCASE_AUTO_BEGIN;\n    TESTCASE_AUTO_CREATE_CLASS(StringCaseTest);\n    TESTCASE_AUTO(TestBasicManipulation);\n    TESTCASE_AUTO(TestCompare);\n    TESTCASE_AUTO(TestExtract);\n    TESTCASE_AUTO(TestRemoveReplace);\n    TESTCASE_AUTO(TestSearching);\n    TESTCASE_AUTO(TestSpacePadding);\n    TESTCASE_AUTO(TestPrefixAndSuffix);\n    TESTCASE_AUTO(TestFindAndReplace);\n    TESTCASE_AUTO(TestBogus);\n    TESTCASE_AUTO(TestReverse);\n    TESTCASE_AUTO(TestMiscellaneous);\n    TESTCASE_AUTO(TestStackAllocation);\n    TESTCASE_AUTO(TestUnescape);\n    TESTCASE_AUTO(TestCountChar32);\n    TESTCASE_AUTO(TestStringEnumeration);\n    TESTCASE_AUTO(TestNameSpace);\n    TESTCASE_AUTO(TestUTF32);\n    TESTCASE_AUTO(TestUTF8);\n    TESTCASE_AUTO(TestReadOnlyAlias);\n    TESTCASE_AUTO(TestAppendable);\n    TESTCASE_AUTO(TestUnicodeStringImplementsAppendable);\n    TESTCASE_AUTO(TestSizeofUnicodeString);\n    TESTCASE_AUTO(TestStartsWithAndEndsWithNulTerminated);\n    TESTCASE_AUTO(TestMoveSwap);\n    TESTCASE_AUTO(TestUInt16Pointers);\n    TESTCASE_AUTO(TestWCharPointers);\n    TESTCASE_AUTO(TestNullPointers);\n    TESTCASE_AUTO(TestUnicodeStringInsertAppendToSelf);\n    TESTCASE_AUTO(TestLargeAppend);\n    TESTCASE_AUTO_END;\n}", "target": 0}
{"code": "new_unencoding_writer(struct Curl_easy *data,\n                      const struct content_encoding *handler,\n                      struct contenc_writer *downstream)\n{\n  size_t sz = offsetof(struct contenc_writer, params) + handler->paramsize;\n  struct contenc_writer *writer = (struct contenc_writer *)calloc(1, sz);\n  if(writer) {\n    writer->handler = handler;\n    writer->downstream = downstream;\n    if(handler->init_writer(data, writer)) {\n      free(writer);\n      writer = NULL;\n    }\n  }\n  return writer;\n}", "target": 0}
{"code": "isdn_net_force_dial(char *name)\n{\n\tisdn_net_dev *p = isdn_net_findif(name);\n\tif (!p)\n\t\treturn -ENODEV;\n\treturn (isdn_net_force_dial_lp(p->local));\n}", "target": 0}
{"code": "void ConnPoolImplBase::checkForIdleAndNotify() {\n  if (isIdleImpl()) {\n    ENVOY_LOG(debug, \"invoking idle callbacks - is_draining_for_deletion_={}\",\n              is_draining_for_deletion_);\n    for (const Instance::IdleCb& cb : idle_callbacks_) {\n      cb();\n    }\n  }\n}", "target": 0}
{"code": "void handle_debug_usb_rx(const void *msg, size_t len)\n{\n    if (msg_tiny_flag) {\n        uint8_t buf[64];\n        memcpy(buf, msg, sizeof(buf));\n        uint16_t msgId = buf[4] | ((uint16_t)buf[3]) << 8;\n        uint32_t msgSize = buf[8]        |\n                ((uint32_t)buf[7]) <<  8 |\n                ((uint32_t)buf[6]) << 16 |\n                ((uint32_t)buf[5]) << 24;\n        if (msgSize > 64 - 9) {\n            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed tiny packet\");\n            return;\n        }\n        const MessagesMap_t *entry = message_map_entry(DEBUG_MSG, msgId, IN_MSG);\n        if (!entry) {\n            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Unknown message\");\n            return;\n        }\n        tiny_dispatch(entry, buf + 9, msgSize);\n    } else {\n        usb_rx_helper(msg, len, DEBUG_MSG);\n    }\n}", "target": 1}
{"code": "max3421_set_address(struct usb_hcd *hcd, struct usb_device *dev, int epnum,\n\t\t    int force_toggles)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tint old_epnum, same_ep, rcvtog, sndtog;\n\tstruct usb_device *old_dev;\n\tu8 hctl;\n\told_dev = max3421_hcd->loaded_dev;\n\told_epnum = max3421_hcd->loaded_epnum;\n\tsame_ep = (dev == old_dev && epnum == old_epnum);\n\tif (same_ep && !force_toggles)\n\t\treturn;\n\tif (old_dev && !same_ep) {\n\t\tu8 hrsl = spi_rd8(hcd, MAX3421_REG_HRSL);\n\t\trcvtog = (hrsl >> MAX3421_HRSL_RCVTOGRD_BIT) & 1;\n\t\tsndtog = (hrsl >> MAX3421_HRSL_SNDTOGRD_BIT) & 1;\n\t\tusb_settoggle(old_dev, old_epnum, 0, rcvtog);\n\t\tusb_settoggle(old_dev, old_epnum, 1, sndtog);\n\t}\n\trcvtog = usb_gettoggle(dev, epnum, 0);\n\tsndtog = usb_gettoggle(dev, epnum, 1);\n\thctl = (BIT(rcvtog + MAX3421_HCTL_RCVTOG0_BIT) |\n\t\tBIT(sndtog + MAX3421_HCTL_SNDTOG0_BIT));\n\tmax3421_hcd->loaded_epnum = epnum;\n\tspi_wr8(hcd, MAX3421_REG_HCTL, hctl);\n\tmax3421_hcd->loaded_dev = dev;\n\tspi_wr8(hcd, MAX3421_REG_PERADDR, dev->devnum);\n}", "target": 1}
{"code": "void JSArray::sortNumeric(ExecState* exec, JSValue compareFunction, CallType callType, const CallData& callData)\n{\n    ArrayStorage* storage = m_storage;\n    unsigned lengthNotIncludingUndefined = compactForSorting();\n    if (storage->m_sparseValueMap) {\n        throwOutOfMemoryError(exec);\n        return;\n    }\n    if (!lengthNotIncludingUndefined)\n        return;\n    bool allValuesAreNumbers = true;\n    size_t size = storage->m_numValuesInVector;\n    for (size_t i = 0; i < size; ++i) {\n        if (!storage->m_vector[i].isNumber()) {\n            allValuesAreNumbers = false;\n            break;\n        }\n    }\n    if (!allValuesAreNumbers)\n        return sort(exec, compareFunction, callType, callData);\n    qsort(storage->m_vector, size, sizeof(JSValue), compareNumbersForQSort);\n    checkConsistency(SortConsistencyCheck);\n}", "target": 0}
{"code": "        AuthenticationStatus get_auth_status() const\n        {\n            std::lock_guard<std::mutex> g(mtx_);\n            if (auth_.get() != nullptr)\n            {\n                return auth_->auth_status_;\n            }\n            else\n            {\n                return AUTHENTICATION_NOT_AVAILABLE;\n            }\n        }", "target": 0}
{"code": "remove_this_reserved_job(conn c, job j)\n{\n    j = job_remove(j);\n    if (j) {\n        global_stat.reserved_ct--;\n        j->tube->stat.reserved_ct--;\n        j->reserver = NULL;\n    }\n    c->soonest_job = NULL;\n    if (!job_list_any_p(&c->reserved_jobs)) conn_remove(c);\n    return j;\n}", "target": 0}
{"code": "PHPAPI zend_string *php_escape_shell_arg(char *str)\n{\n\tint x, y = 0, l = (int)strlen(str);\n\tzend_string *cmd;\n\tsize_t estimate = (4 * l) + 3;\n\tcmd = zend_string_alloc(4 * l + 2, 0); \n#ifdef PHP_WIN32\n\tZSTR_VAL(cmd)[y++] = '\"';\n#else\n\tZSTR_VAL(cmd)[y++] = '\\'';\n#endif\n\tfor (x = 0; x < l; x++) {\n\t\tint mb_len = php_mblen(str + x, (l - x));\n\t\tif (mb_len < 0) {\n\t\t\tcontinue;\n\t\t} else if (mb_len > 1) {\n\t\t\tmemcpy(ZSTR_VAL(cmd) + y, str + x, mb_len);\n\t\t\ty += mb_len;\n\t\t\tx += mb_len - 1;\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (str[x]) {\n#ifdef PHP_WIN32\n\t\tcase '\"':\n\t\tcase '%':\n\t\tcase '!':\n\t\t\tZSTR_VAL(cmd)[y++] = ' ';\n\t\t\tbreak;\n#else\n\t\tcase '\\'':\n\t\t\tZSTR_VAL(cmd)[y++] = '\\'';\n\t\t\tZSTR_VAL(cmd)[y++] = '\\\\';\n\t\t\tZSTR_VAL(cmd)[y++] = '\\'';\n#endif\n\t\tdefault:\n\t\t\tZSTR_VAL(cmd)[y++] = str[x];\n\t\t}\n\t}\n#ifdef PHP_WIN32\n\tif (y > 0 && '\\\\' == ZSTR_VAL(cmd)[y - 1]) {\n\t\tint k = 0, n = y - 1;\n\t\tfor (; n >= 0 && '\\\\' == ZSTR_VAL(cmd)[n]; n--, k++);\n\t\tif (k % 2) {\n\t\t\tZSTR_VAL(cmd)[y++] = '\\\\';\n\t\t}\n\t}\n\tZSTR_VAL(cmd)[y++] = '\"';\n#else\n\tZSTR_VAL(cmd)[y++] = '\\'';\n#endif\n\tZSTR_VAL(cmd)[y] = '\\0';\n\tif ((estimate - y) > 4096) {\n\t\tcmd = zend_string_truncate(cmd, y, 0);\n\t}\n\tZSTR_LEN(cmd) = y;\n\treturn cmd;\n}", "target": 1}
{"code": "void IGDstartelt(void * d, const char * name, int l)\n{\n\tstruct IGDdatas * datas = (struct IGDdatas *)d;\n\tmemcpy( datas->cureltname, name, l);\n\tdatas->cureltname[l] = '\\0';\n\tdatas->level++;\n\tif( (l==7) && !memcmp(name, \"service\", l) ) {\n\t\tdatas->tmp.controlurl[0] = '\\0';\n\t\tdatas->tmp.eventsuburl[0] = '\\0';\n\t\tdatas->tmp.scpdurl[0] = '\\0';\n\t\tdatas->tmp.servicetype[0] = '\\0';\n\t}\n}", "target": 1}
{"code": "GF_Err chnl_box_size(GF_Box *s)\n{\n\tGF_ChannelLayoutBox *ptr = (GF_ChannelLayoutBox *) s;\n\ts->size += 1;\n\tif (ptr->layout.stream_structure & 1) {\n\t\ts->size += 1;\n\t\tif (ptr->layout.definedLayout==0) {\n\t\t\tu32 i;\n\t\t\tfor (i=0; i<ptr->layout.channels_count; i++) {\n\t\t\t\ts->size+=1;\n\t\t\t\tif (ptr->layout.layouts[i].position==126)\n\t\t\t\t\ts->size+=3;\n\t\t\t}\n\t\t} else {\n\t\t\ts->size += 8;\n\t\t}\n\t}\n\tif (ptr->layout.stream_structure & 2) {\n\t\ts->size += 1;\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "AP_DECLARE(void) ap_update_vhost_from_headers(request_rec *r)\n{\n    core_server_config *conf = ap_get_core_module_config(r->server->module_config);\n    const char *host_header = apr_table_get(r->headers_in, \"Host\");\n    int is_v6literal = 0;\n    int have_hostname_from_url = 0;\n    if (r->hostname) {\n        have_hostname_from_url = 1;\n        is_v6literal = fix_hostname(r, NULL, conf->http_conformance);\n    }\n    else if (host_header != NULL) {\n        is_v6literal = fix_hostname(r, host_header, conf->http_conformance);\n    }\n    if (r->status != HTTP_OK)\n        return;\n    if (conf->http_conformance != AP_HTTP_CONFORMANCE_UNSAFE) {\n        if (have_hostname_from_url && host_header != NULL) {\n            const char *repl = construct_host_header(r, is_v6literal);\n            apr_table_setn(r->headers_in, \"Host\", repl);\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02417)\n                          \"Replacing host header '%s' with host '%s' given \"\n                          \"in the request uri\", host_header, repl);\n        }\n    }\n    if (r->connection->vhost_lookup_data) {\n        if (r->hostname)\n            check_hostalias(r);\n        else\n            check_serverpath(r);\n    }\n}", "target": 1}
{"code": "MONGO_EXPORT int bson_append_binary( bson *b, const char *name, char type, const char *str, int len ) {\n    if ( type == BSON_BIN_BINARY_OLD ) {\n        int subtwolen = len + 4;\n        if ( bson_append_estart( b, BSON_BINDATA, name, 4+1+4+len ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append32( b, &subtwolen );\n        bson_append_byte( b, type );\n        bson_append32( b, &len );\n        bson_append( b, str, len );\n    }\n    else {\n        if ( bson_append_estart( b, BSON_BINDATA, name, 4+1+len ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append32( b, &len );\n        bson_append_byte( b, type );\n        bson_append( b, str, len );\n    }\n    return BSON_OK;\n}", "target": 1}
{"code": "int SSL_free_buffers(SSL *ssl)\n{\n    RECORD_LAYER *rl = &ssl->rlayer;\n    if (RECORD_LAYER_read_pending(rl) || RECORD_LAYER_write_pending(rl))\n        return 0;\n    if (RECORD_LAYER_data_present(rl))\n        return 0;\n    RECORD_LAYER_release(rl);\n    return 1;\n}", "target": 0}
{"code": "R_API int r_io_bank_read_from_submap_at(RIO *io, const ut32 bankid, ut64 addr, ut8 *buf, int len) {\n\tr_return_val_if_fail (io, -1);\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tif (!bank) {\n\t\treturn 0;\n\t}\n\tif (!len) {\n\t\treturn 0;\n\t}\n\tRRBNode *node;\n\tif (bank->last_used && r_io_submap_contain (((RIOSubMap *)bank->last_used->data), addr)) {\n\t\tnode = bank->last_used;\n\t} else {\n\t\tnode = r_crbtree_find_node (bank->submaps, &addr, _find_sm_by_vaddr_cb, NULL);\n\t\tif (!node) {\n\t\t\treturn 0;\n\t\t}\n\t\tbank->last_used = node;\n\t}\n\tRIOSubMap *sm = (RIOSubMap *)node->data;\n\tif (!r_io_submap_contain (sm, addr)) {\n\t\treturn 0;\n\t}\n\tRIOMap *map = r_io_map_get_by_ref (io, &sm->mapref);\n\tif (!map || !(map->perm & R_PERM_R)) {\n\t\treturn -1;\n\t}\n\tconst int read_len = R_MIN (len, r_io_submap_to (sm) - addr + 1);\n\tif (map->perm & R_PERM_RELOC) {\n\t\treturn map->reloc_map->read (io, map, addr, buf, read_len);\n\t}\n\tconst ut64 paddr = addr - r_io_map_from (map) + map->delta;\n\treturn r_io_fd_read_at (io, map->fd, paddr, buf, read_len);\n}", "target": 1}
{"code": "double AccessibilityUIElement::width()\n{\n    if (!m_element || !ATK_IS_OBJECT(m_element))\n        return 0.0f;\n    int width, height;\n    atk_component_get_size(ATK_COMPONENT(m_element), &width, &height);\n    return width;\n}", "target": 0}
{"code": "static mongo_message *mongo_message_create( int len , int id , int responseTo , int op ) {\n    mongo_message *mm = ( mongo_message * )bson_malloc( len );\n    if ( !id )\n        id = rand();\n    mm->head.len = len;\n    mm->head.id = id;\n    mm->head.responseTo = responseTo;\n    mm->head.op = op;\n    return mm;\n}", "target": 1}
{"code": "  explicit ReverseSequenceOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"batch_dim\", &batch_dim_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seq_dim\", &seq_dim_));\n    OP_REQUIRES(context, batch_dim_ >= 0,\n                errors::InvalidArgument(\"Invalid batch_dim \", batch_dim_));\n    OP_REQUIRES(context, seq_dim_ >= 0,\n                errors::InvalidArgument(\"Invalid seq_dim \", seq_dim_));\n  }", "target": 0}
{"code": "BGD_DECLARE(void *) gdImageGifPtr(gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) return NULL;\n\tgdImageGifCtx(im, out);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}", "target": 1}
{"code": "static void encode_open(struct xdr_stream *xdr, const struct nfs_openargs *arg, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_OPEN, decode_open_maxsz, hdr);\n\tencode_openhdr(xdr, arg);\n\tencode_opentype(xdr, arg);\n\tswitch (arg->claim) {\n\tcase NFS4_OPEN_CLAIM_NULL:\n\t\tencode_claim_null(xdr, arg->name);\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_PREVIOUS:\n\t\tencode_claim_previous(xdr, arg->u.delegation_type);\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_DELEGATE_CUR:\n\t\tencode_claim_delegate_cur(xdr, arg->name, &arg->u.delegation);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}", "target": 0}
{"code": "parse_field(netdissect_options *ndo, const char **pptr, int *len)\n{\n    const char *s;\n    if (*len <= 0 || !pptr || !*pptr)\n\treturn NULL;\n    if (*pptr > (const char *) ndo->ndo_snapend)\n\treturn NULL;\n    s = *pptr;\n    while (*pptr <= (const char *) ndo->ndo_snapend && *len >= 0 && **pptr) {\n\t(*pptr)++;\n\t(*len)--;\n    }\n    (*pptr)++;\n    (*len)--;\n    if (*len < 0 || *pptr > (const char *) ndo->ndo_snapend)\n\treturn NULL;\n    return s;\n}", "target": 1}
{"code": "static void rds_tcp_kill_sock(struct net *net)\n{\n\tstruct rds_tcp_connection *tc, *_tc;\n\tLIST_HEAD(tmp_list);\n\tstruct rds_tcp_net *rtn = net_generic(net, rds_tcp_netid);\n\tstruct socket *lsock = rtn->rds_tcp_listen_sock;\n\trtn->rds_tcp_listen_sock = NULL;\n\trds_tcp_listen_stop(lsock, &rtn->rds_tcp_accept_w);\n\tspin_lock_irq(&rds_tcp_conn_lock);\n\tlist_for_each_entry_safe(tc, _tc, &rds_tcp_conn_list, t_tcp_node) {\n\t\tstruct net *c_net = read_pnet(&tc->t_cpath->cp_conn->c_net);\n\t\tif (net != c_net || !tc->t_sock)\n\t\t\tcontinue;\n\t\tif (!list_has_conn(&tmp_list, tc->t_cpath->cp_conn)) {\n\t\t\tlist_move_tail(&tc->t_tcp_node, &tmp_list);\n\t\t} else {\n\t\t\tlist_del(&tc->t_tcp_node);\n\t\t\ttc->t_tcp_node_detached = true;\n\t\t}\n\t}\n\tspin_unlock_irq(&rds_tcp_conn_lock);\n\tlist_for_each_entry_safe(tc, _tc, &tmp_list, t_tcp_node)\n\t\trds_conn_destroy(tc->t_cpath->cp_conn);\n}", "target": 1}
{"code": "dump_dest_constraints(const char *context,\n    const struct dest_constraint *dcs, size_t ndcs)\n{\n#ifdef DEBUG_CONSTRAINTS\n\tsize_t i;\n\tdebug_f(\"%s: %zu constraints\", context, ndcs);\n\tfor (i = 0; i < ndcs; i++) {\n\t\tdebug_f(\"constraint %zu / %zu: from: \", i, ndcs);\n\t\tdump_dest_constraint_hop(&dcs[i].from);\n\t\tdebug_f(\"constraint %zu / %zu: to: \", i, ndcs);\n\t\tdump_dest_constraint_hop(&dcs[i].to);\n\t}\n\tdebug_f(\"done for %s\", context);\n#endif \n}", "target": 0}
{"code": "isdn_ppp_poll(struct file *file, poll_table *wait)\n{\n\tu_int mask;\n\tstruct ippp_buf_queue *bf, *bl;\n\tu_long flags;\n\tstruct ippp_struct *is;\n\tis = file->private_data;\n\tif (is->debug & 0x2)\n\t\tprintk(KERN_DEBUG \"isdn_ppp_poll: minor: %d\\n\",\n\t\t       iminor(file_inode(file)));\n\tpoll_wait(file, &is->wq, wait);\n\tif (!(is->state & IPPP_OPEN)) {\n\t\tif (is->state == IPPP_CLOSEWAIT)\n\t\t\treturn POLLHUP;\n\t\tprintk(KERN_DEBUG \"isdn_ppp: device not open\\n\");\n\t\treturn POLLERR;\n\t}\n\tmask = POLLOUT | POLLWRNORM;\n\tspin_lock_irqsave(&is->buflock, flags);\n\tbl = is->last;\n\tbf = is->first;\n\tif (bf->next != bl || (is->state & IPPP_NOBLOCK)) {\n\t\tis->state &= ~IPPP_NOBLOCK;\n\t\tmask |= POLLIN | POLLRDNORM;\n\t}\n\tspin_unlock_irqrestore(&is->buflock, flags);\n\treturn mask;\n}", "target": 0}
{"code": "int http_connect(int sockfd, const char *host, int port, AyProxyData *proxy)\n{\n\tchar cmd[512];\n\tchar *inputline = NULL;\n\tchar *proxy_auth = NULL;\n\tchar debug_buff[512];\n\tint remaining = sizeof(cmd) - 1;\n\tremaining -= snprintf(cmd, sizeof(cmd), \"CONNECT %s:%d HTTP/1.1\\r\\n\", host, port);\n\tif (proxy->username && proxy->username[0]) {\n\t\tproxy_auth = encode_proxy_auth_str(proxy);\n\t\tstrncat(cmd, \"Proxy-Authorization: Basic \", remaining);\n\t\tremaining -= 27;\n\t\tstrncat(cmd, proxy_auth, remaining);\n\t\tremaining -= strlen(proxy_auth);\n\t\tstrncat(cmd, \"\\r\\n\", remaining);\n\t\tremaining -= 2;\n\t}\n\tstrncat(cmd, \"\\r\\n\", remaining);\n#ifndef DEBUG\n\tsnprintf(debug_buff, sizeof(debug_buff), \"<%s>\\n\", cmd);\n\tdebug_print(debug_buff);\n#endif\n\tif (send(sockfd, cmd, strlen(cmd), 0) < 0)\n\t\treturn AY_CONNECTION_REFUSED;\n\tif (ay_recv_line(sockfd, &inputline) < 0)\n\t\treturn AY_CONNECTION_REFUSED;\n#ifndef DEBUG\n\tsnprintf(debug_buff, sizeof(debug_buff), \"<%s>\\n\", inputline);\n\tdebug_print(debug_buff);\n#endif\n\tif (!strstr(inputline, \"200\")) {\n\t\tif (strstr(inputline, \"407\")) {\n\t\t\twhile (ay_recv_line(sockfd, &inputline) > 0) {\n\t\t\t\tfree(inputline);\n\t\t\t}\n\t\t\treturn AY_PROXY_AUTH_REQUIRED;\n\t\t}\n\t\tif (strstr(inputline, \"403\")) {\n\t\t\twhile (ay_recv_line(sockfd, &inputline) > 0) {\n\t\t\t\tfree(inputline);\n\t\t\t}\n\t\t\treturn AY_PROXY_PERMISSION_DENIED;\n\t\t}\n\t\tfree(inputline);\n\t\treturn AY_CONNECTION_REFUSED;\n\t}\n\twhile (strlen(inputline) > 1) {\n\t\tfree(inputline);\n\t\tif (ay_recv_line(sockfd, &inputline) < 0) {\n\t\t\treturn AY_CONNECTION_REFUSED;\n\t\t}\n#ifndef DEBUG\n\t\tsnprintf(debug_buff, sizeof(debug_buff), \"<%s>\\n\", inputline);\n\t\tdebug_print(debug_buff);\n#endif\n\t}\n\tfree(inputline);\n\tg_free(proxy_auth);\n\treturn 0;\n}", "target": 1}
{"code": "set_lenIV(char *line)\n{\n  char *p = strstr(line, \"/lenIV \");\n  if (p && (isdigit(p[7]) || p[7] == '+' || p[7] == '-')) {\n    lenIV = atoi(p + 7);\n  }\n}", "target": 1}
{"code": "static void test_double_compare()\n{\n  MYSQL_STMT *stmt;\n  int        rc;\n  char       real_data[10], tiny_data;\n  double     double_data;\n  MYSQL_RES  *result;\n  MYSQL_BIND my_bind[3];\n  ulong      length[3];\n  char query[MAX_TEST_QUERY_LENGTH];\n  myheader(\"test_double_compare\");\n  rc= mysql_autocommit(mysql, TRUE);\n  myquery(rc);\n  rc= mysql_query(mysql, \"DROP TABLE IF EXISTS test_double_compare\");\n  myquery(rc);\n  rc= mysql_query(mysql, \"CREATE TABLE test_double_compare(col1 tinyint, \"\n                         \" col2 float, col3 double )\");\n  myquery(rc);\n  rc= mysql_query(mysql, \"INSERT INTO test_double_compare \"\n                         \"VALUES (1, 10.2, 34.5)\");\n  myquery(rc);\n  strmov(query, \"UPDATE test_double_compare SET col1=100 \"\n                \"WHERE col1 = ? AND col2 = ? AND COL3 = ?\");\n  stmt= mysql_simple_prepare(mysql, query);\n  check_stmt(stmt);\n  verify_param_count(stmt, 3);\n  memset(my_bind, 0, sizeof(my_bind));\n  my_bind[0].buffer_type= MYSQL_TYPE_TINY;\n  my_bind[0].buffer= (void *)&tiny_data;\n  my_bind[1].buffer_type= MYSQL_TYPE_STRING;\n  my_bind[1].buffer= (void *)&real_data;\n  my_bind[1].buffer_length= sizeof(real_data);\n  my_bind[1].length= &length[1];\n  length[1]= 10;\n  my_bind[2].buffer_type= MYSQL_TYPE_DOUBLE;\n  my_bind[2].buffer= (void *)&double_data;\n  tiny_data= 1;\n  strmov(real_data, \"10.2\");\n  double_data= 34.5;\n  rc= mysql_stmt_bind_param(stmt, my_bind);\n  check_execute(stmt, rc);\n  rc= mysql_stmt_execute(stmt);\n  check_execute(stmt, rc);\n  verify_affected_rows(0);\n  mysql_stmt_close(stmt);\n  rc= mysql_commit(mysql);\n  myquery(rc);\n  rc= mysql_query(mysql, \"SELECT * FROM test_double_compare\");\n  myquery(rc);\n  result= mysql_store_result(mysql);\n  mytest(result);\n  rc= my_process_result_set(result);\n  DIE_UNLESS((int)tiny_data == rc);\n  mysql_free_result(result);\n}", "target": 0}
{"code": "bounded_iostream::bounded_iostream(Sirikata::DecoderWriter *w,\n                                   const std::function<void(Sirikata::DecoderWriter*, size_t)> &size_callback,\n                                   const Sirikata::JpegAllocator<uint8_t> &alloc) \n    : parent(w), err(Sirikata::JpegError::nil()) {\n    this->size_callback = size_callback;\n    buffer_position = 0;\n    byte_position = 0;\n    byte_bound = 0x7FFFFFFF;\n    num_bytes_attempted_to_write = 0;\n    set_bound(0);\n}", "target": 0}
{"code": "int ceph_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint ret = 0, size = 0;\n\tconst char *name = NULL;\n\tchar *value = NULL;\n\tstruct iattr newattrs;\n\tumode_t new_mode = inode->i_mode, old_mode = inode->i_mode;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tret = posix_acl_equiv_mode(acl, &new_mode);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode)) {\n\t\t\tret = acl ? -EINVAL : 0;\n\t\t\tgoto out;\n\t\t}\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_NOFS);\n\t\tif (!value) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (ret < 0)\n\t\t\tgoto out_free;\n\t}\n\tif (new_mode != old_mode) {\n\t\tnewattrs.ia_mode = new_mode;\n\t\tnewattrs.ia_valid = ATTR_MODE;\n\t\tret = __ceph_setattr(inode, &newattrs);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t}\n\tret = __ceph_setxattr(inode, name, value, size, 0);\n\tif (ret) {\n\t\tif (new_mode != old_mode) {\n\t\t\tnewattrs.ia_mode = old_mode;\n\t\t\tnewattrs.ia_valid = ATTR_MODE;\n\t\t\t__ceph_setattr(inode, &newattrs);\n\t\t}\n\t\tgoto out_free;\n\t}\n\tceph_set_cached_acl(inode, type, acl);\nout_free:\n\tkfree(value);\nout:\n\treturn ret;\n}", "target": 1}
{"code": "static int snd_timer_user_tselect(struct file *file,\n\t\t\t\t  struct snd_timer_select __user *_tselect)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_select tselect;\n\tchar str[32];\n\tint err = 0;\n\ttu = file->private_data;\n\tmutex_lock(&tu->tread_sem);\n\tif (tu->timeri) {\n\t\tsnd_timer_close(tu->timeri);\n\t\ttu->timeri = NULL;\n\t}\n\tif (copy_from_user(&tselect, _tselect, sizeof(tselect))) {\n\t\terr = -EFAULT;\n\t\tgoto __err;\n\t}\n\tsprintf(str, \"application %i\", current->pid);\n\tif (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)\n\t\ttselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;\n\terr = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid);\n\tif (err < 0)\n\t\tgoto __err;\n\tkfree(tu->queue);\n\ttu->queue = NULL;\n\tkfree(tu->tqueue);\n\ttu->tqueue = NULL;\n\tif (tu->tread) {\n\t\ttu->tqueue = kmalloc(tu->queue_size * sizeof(struct snd_timer_tread),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (tu->tqueue == NULL)\n\t\t\terr = -ENOMEM;\n\t} else {\n\t\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (tu->queue == NULL)\n\t\t\terr = -ENOMEM;\n\t}\n      \tif (err < 0) {\n\t\tsnd_timer_close(tu->timeri);\n      \t\ttu->timeri = NULL;\n      \t} else {\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;\n\t\ttu->timeri->callback = tu->tread\n\t\t\t? snd_timer_user_tinterrupt : snd_timer_user_interrupt;\n\t\ttu->timeri->ccallback = snd_timer_user_ccallback;\n\t\ttu->timeri->callback_data = (void *)tu;\n\t}\n      __err:\n      \tmutex_unlock(&tu->tread_sem);\n\treturn err;\n}", "target": 1}
{"code": "static void request_key_auth_describe(const struct key *key,\n\t\t\t\t      struct seq_file *m)\n{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\tseq_puts(m, \"key:\");\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \" pid:%d ci:%zu\", rka->pid, rka->callout_len);\n}", "target": 1}
{"code": "  virtual ~AuthAuthorizerChallenge() {}", "target": 0}
{"code": "static void __mcheck_cpu_clear_vendor(struct cpuinfo_x86 *c)\n{\n\tswitch (c->x86_vendor) {\n\tcase X86_VENDOR_INTEL:\n\t\tmce_intel_feature_clear(c);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "WebMediaPlayer::Preload HTMLMediaElement::EffectivePreloadType() const {\n  if (Autoplay() && !autoplay_policy_->IsGestureNeededForPlayback())\n    return WebMediaPlayer::kPreloadAuto;\n  WebMediaPlayer::Preload preload = PreloadType();\n  if (ignore_preload_none_ && preload == WebMediaPlayer::kPreloadNone)\n    return WebMediaPlayer::kPreloadMetaData;\n  return preload;\n}", "target": 0}
{"code": "static void RemoveResolutionFromResourceBlock(StringInfo *bim_profile)\n{\n  register const unsigned char\n    *p;\n  size_t\n    length;\n  unsigned char\n    *datum;\n  unsigned int\n    count,\n    long_sans;\n  unsigned short\n    id,\n    short_sans;\n  length=GetStringInfoLength(bim_profile);\n  if (length < 16)\n    return;\n  datum=GetStringInfoDatum(bim_profile);\n  for (p=datum; (p >= datum) && (p < (datum+length-16)); )\n  {\n    register unsigned char\n      *q;\n    q=(unsigned char *) p;\n    if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n      break;\n    p=PushLongPixel(MSBEndian,p,&long_sans);\n    p=PushShortPixel(MSBEndian,p,&id);\n    p=PushShortPixel(MSBEndian,p,&short_sans);\n    p=PushLongPixel(MSBEndian,p,&count);\n    if ((id == 0x000003ed) && (PSDQuantum(count) < (ssize_t) (length-12)))\n      {\n        (void) CopyMagickMemory(q,q+PSDQuantum(count)+12,length-\n          (PSDQuantum(count)+12)-(q-datum));\n        SetStringInfoLength(bim_profile,length-(PSDQuantum(count)+12));\n        break;\n      }\n    p+=count;\n    if ((count & 0x01) != 0)\n      p++;\n  }\n}", "target": 1}
{"code": "qedi_dbg_info(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t      u32 level, const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\tchar nfunc[32];\n\tmemset(nfunc, 0, sizeof(nfunc));\n\tmemcpy(nfunc, func, sizeof(nfunc) - 1);\n\tva_start(va, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\tif (!(qedi_dbg_log & level))\n\t\tgoto ret;\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_info(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t\tnfunc, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_info(\"[0000:00:00.0]:[%s:%d]: %pV\", nfunc, line, &vaf);\nret:\n\tva_end(va);\n}", "target": 1}
{"code": "comics_remove_dir (gchar *path_name) \n{\n\tGDir  *content_dir;\n\tconst gchar *filename;\n\tgchar *filename_with_path;\n\tif (g_file_test (path_name, G_FILE_TEST_IS_DIR)) {\n\t\tcontent_dir = g_dir_open  (path_name, 0, NULL);\n\t\tfilename  = g_dir_read_name (content_dir);\n\t\twhile (filename) {\n\t\t\tfilename_with_path = \n\t\t\t\tg_build_filename (path_name, \n\t\t\t\t\t\t  filename, NULL);\n\t\t\tcomics_remove_dir (filename_with_path);\n\t\t\tg_free (filename_with_path);\n\t\t\tfilename = g_dir_read_name (content_dir);\n\t\t}\n\t\tg_dir_close (content_dir);\n\t}\n\treturn (g_remove (path_name));\n}", "target": 0}
{"code": "createenv(const struct rule *rule)\n{\n\tstruct env *env;\n\tu_int i;\n\tenv = malloc(sizeof(*env));\n\tif (!env)\n\t\terr(1, NULL);\n\tRB_INIT(&env->root);\n\tenv->count = 0;\n\tif (rule->options & KEEPENV) {\n\t\textern char **environ;\n\t\tfor (i = 0; environ[i] != NULL; i++) {\n\t\t\tstruct envnode *node;\n\t\t\tconst char *e, *eq;\n\t\t\tsize_t len;\n\t\t\tchar keybuf[1024];\n\t\t\te = environ[i];\n\t\t\tif ((eq = strchr(e, '=')) == NULL || eq == e)\n\t\t\t\tcontinue;\n\t\t\tlen = eq - e;\n\t\t\tif (len > sizeof(keybuf) - 1)\n\t\t\t\tcontinue;\n\t\t\tmemcpy(keybuf, e, len);\n\t\t\tkeybuf[len] = '\\0';\n\t\t\tnode = createnode(keybuf, eq + 1);\n\t\t\tif (RB_INSERT(envtree, &env->root, node)) {\n\t\t\t\tfreenode(node);\n\t\t\t} else {\n\t\t\t\tenv->count++;\n\t\t\t}\n\t\t}\n\t}\n\treturn env;\n}", "target": 1}
{"code": "set_ssl_ciphers(SCHANNEL_CRED *schannel_cred, char *ciphers,\n                ALG_ID *algIds)\n{\n  char *startCur = ciphers;\n  int algCount = 0;\n  while(startCur && (0 != *startCur) && (algCount < NUMOF_CIPHERS)) {\n    long alg = strtol(startCur, 0, 0);\n    if(!alg)\n      alg = get_alg_id_by_name(startCur);\n    if(alg)\n      algIds[algCount++] = alg;\n    else if(!strncmp(startCur, \"USE_STRONG_CRYPTO\",\n                     sizeof(\"USE_STRONG_CRYPTO\") - 1) ||\n            !strncmp(startCur, \"SCH_USE_STRONG_CRYPTO\",\n                     sizeof(\"SCH_USE_STRONG_CRYPTO\") - 1))\n      schannel_cred->dwFlags |= SCH_USE_STRONG_CRYPTO;\n    else\n      return CURLE_SSL_CIPHER;\n    startCur = strchr(startCur, ':');\n    if(startCur)\n      startCur++;\n  }\n  schannel_cred->palgSupportedAlgs = algIds;\n  schannel_cred->cSupportedAlgs = algCount;\n  return CURLE_OK;\n}", "target": 0}
{"code": "static void print_value(int output, int num, const char *devname,\n\t\t\tconst char *value, const char *name, size_t valsz)\n{\n\tif (output & OUTPUT_VALUE_ONLY) {\n\t\tfputs(value, stdout);\n\t\tfputc('\\n', stdout);\n\t} else if (output & OUTPUT_UDEV_LIST) {\n\t\tprint_udev_format(name, value);\n\t} else if (output & OUTPUT_EXPORT_LIST) {\n\t\tif (num == 1 && devname)\n\t\t\tprintf(\"DEVNAME=%s\\n\", devname);\n\t\tfputs(name, stdout);\n\t\tfputs(\"=\", stdout);\n\t\tsafe_print(value, valsz, NULL);\n\t\tfputs(\"\\n\", stdout);\n\t} else {\n\t\tif (num == 1 && devname)\n\t\t\tprintf(\"%s:\", devname);\n\t\tfputs(\" \", stdout);\n\t\tfputs(name, stdout);\n\t\tfputs(\"=\\\"\", stdout);\n\t\tsafe_print(value, valsz, \"\\\"\");\n\t\tfputs(\"\\\"\", stdout);\n\t}\n}", "target": 1}
{"code": "_pdfioDictSetValue(\n    pdfio_dict_t   *dict,\t\t\n    const char     *key,\t\t\n    _pdfio_value_t *value)\t\t\n{\n  _pdfio_pair_t\t*pair;\t\t\t\n  PDFIO_DEBUG(\"_pdfioDictSetValue(dict=%p, key=\\\"%s\\\", value=%p)\\n\", dict, key, (void *)value);\n  if (dict->num_pairs > 0)\n  {\n    _pdfio_pair_t\tpkey;\t\t\n    pkey.key = key;\n    if ((pair = (_pdfio_pair_t *)bsearch(&pkey, dict->pairs, dict->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))compare_pairs)) != NULL)\n    {\n      PDFIO_DEBUG(\"_pdfioDictSetValue: Replacing existing value.\\n\");\n      if (pair->value.type == PDFIO_VALTYPE_BINARY)\n        free(pair->value.value.binary.data);\n      pair->value = *value;\n      return (true);\n    }\n  }\n  if (dict->num_pairs >= dict->alloc_pairs)\n  {\n    _pdfio_pair_t *temp = (_pdfio_pair_t *)realloc(dict->pairs, (dict->alloc_pairs + 8) * sizeof(_pdfio_pair_t));\n    if (!temp)\n    {\n      PDFIO_DEBUG(\"_pdfioDictSetValue: Out of memory.\\n\");\n      return (false);\n    }\n    dict->pairs       = temp;\n    dict->alloc_pairs += 8;\n  }\n  pair = dict->pairs + dict->num_pairs;\n  dict->num_pairs ++;\n  pair->key   = key;\n  pair->value = *value;\n  if (dict->num_pairs > 1 && compare_pairs(pair - 1, pair) > 0)\n    qsort(dict->pairs, dict->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))compare_pairs);\n#ifdef DEBUG\n  PDFIO_DEBUG(\"_pdfioDictSetValue(%p): %lu pairs\\n\", (void *)dict, (unsigned long)dict->num_pairs);\n  PDFIO_DEBUG(\"_pdfioDictSetValue(%p): \", (void *)dict);\n  PDFIO_DEBUG_DICT(dict);\n  PDFIO_DEBUG(\"\\n\");\n#endif \n  return (true);\n}", "target": 1}
{"code": "void set_numabalancing_state(bool enabled)\n{\n\tif (enabled)\n\t\tstatic_branch_enable(&sched_numa_balancing);\n\telse\n\t\tstatic_branch_disable(&sched_numa_balancing);\n}", "target": 0}
{"code": "static struct ip_options *tcp_v4_save_options(struct sock *sk,\n\t\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct ip_options *opt = &(IPCB(skb)->opt);\n\tstruct ip_options *dopt = NULL;\n\tif (opt && opt->optlen) {\n\t\tint opt_size = optlength(opt);\n\t\tdopt = kmalloc(opt_size, GFP_ATOMIC);\n\t\tif (dopt) {\n\t\t\tif (ip_options_echo(dopt, skb)) {\n\t\t\t\tkfree(dopt);\n\t\t\t\tdopt = NULL;\n\t\t\t}\n\t\t}\n\t}\n\treturn dopt;\n}", "target": 1}
{"code": "header_seek (SF_PRIVATE *psf, sf_count_t position, int whence)\n{\n\tswitch (whence)\n\t{\tcase SEEK_SET :\n\t\t\tif (position > SIGNED_SIZEOF (psf->header))\n\t\t\t{\t\n\t\t\t\tpsf_fseek (psf, position, whence) ;\n\t\t\t\treturn ;\n\t\t\t\t} ;\n\t\t\tif (position > psf->headend)\n\t\t\t\tpsf->headend += psf_fread (psf->header + psf->headend, 1, position - psf->headend, psf) ;\n\t\t\tpsf->headindex = position ;\n\t\t\tbreak ;\n\t\tcase SEEK_CUR :\n\t\t\tif (psf->headindex + position < 0)\n\t\t\t\tbreak ;\n\t\t\tif (psf->headindex >= SIGNED_SIZEOF (psf->header))\n\t\t\t{\tpsf_fseek (psf, position, whence) ;\n\t\t\t\treturn ;\n\t\t\t\t} ;\n\t\t\tif (psf->headindex + position <= psf->headend)\n\t\t\t{\tpsf->headindex += position ;\n\t\t\t\tbreak ;\n\t\t\t\t} ;\n\t\t\tif (psf->headindex + position > SIGNED_SIZEOF (psf->header))\n\t\t\t{\t\n\t\t\t\tpsf->headindex = psf->headend ;\n\t\t\t\tpsf_fseek (psf, position, SEEK_CUR) ;\n\t\t\t\tbreak ;\n\t\t\t\t} ;\n\t\t\tpsf->headend += psf_fread (psf->header + psf->headend, 1, position - (psf->headend - psf->headindex), psf) ;\n\t\t\tpsf->headindex = psf->headend ;\n\t\t\tbreak ;\n\t\tcase SEEK_END :\n\t\tdefault :\n\t\t\tpsf_log_printf (psf, \"Bad whence param in header_seek().\\n\") ;\n\t\t\tbreak ;\n\t\t} ;\n\treturn ;\n} ", "target": 1}
{"code": "bool AES_GCM_DecryptContext::Decrypt(\n\tconst void *pEncryptedDataAndTag, size_t cbEncryptedDataAndTag,\n\tconst void *pIV,\n\tvoid *pPlaintextData, uint32 *pcbPlaintextData,\n\tconst void *pAdditionalAuthenticationData, size_t cbAuthenticationData\n) {\n    unsigned long long pcbPlaintextData_longlong;\n    const int nDecryptResult = crypto_aead_aes256gcm_decrypt_afternm(\n\t\tstatic_cast<unsigned char*>( pPlaintextData ), &pcbPlaintextData_longlong,\n\t\tnullptr,\n\t\tstatic_cast<const unsigned char*>( pEncryptedDataAndTag ), cbEncryptedDataAndTag,\n\t\tstatic_cast<const unsigned char*>( pAdditionalAuthenticationData ), cbAuthenticationData,\n\t\tstatic_cast<const unsigned char*>( pIV ), static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )\n\t);\n    *pcbPlaintextData = pcbPlaintextData_longlong;\n    return nDecryptResult == 0;\n}", "target": 1}
{"code": "PassOwnPtr<SVGDocumentExtensions::SVGPendingElements> SVGDocumentExtensions::removePendingResource(const AtomicString& id)\n{\n    ASSERT(m_pendingResources.contains(id));\n    return m_pendingResources.take(id);\n}", "target": 0}
{"code": "test_compare_files (const char* tgt, const char *rec)\n{\n  FILE *orig, *recons;\n  static uint8_t obuf[TESTBUFSIZE], rbuf[TESTBUFSIZE];\n  xoff_t offset = 0;\n  size_t i;\n  size_t oc, rc;\n  xoff_t diffs = 0;\n  if ((orig = fopen (tgt, \"r\")) == NULL)\n    {\n      XPR(NT \"open %s failed\\n\", tgt);\n      return get_errno ();\n    }\n  if ((recons = fopen (rec, \"r\")) == NULL)\n    {\n      XPR(NT \"open %s failed\\n\", rec);\n      return get_errno ();\n    }\n  for (;;)\n    {\n      oc = fread (obuf, 1, TESTBUFSIZE, orig);\n      rc = fread (rbuf, 1, TESTBUFSIZE, recons);\n      if (oc != rc)\n\t{\n\t  return XD3_INTERNAL;\n\t}\n      if (oc == 0)\n\t{\n\t  break;\n\t}\n      for (i = 0; i < oc; i += 1)\n\t{\n\t  if (obuf[i] != rbuf[i])\n \t    {\n\t      XPR(NT \"byte %u (read %u @ %\"Q\"u) %d != %d\\n\", \n\t\t  (int)i, (int)oc, offset, obuf[i], rbuf[i]);\n\t      diffs++;\n\t      return XD3_INTERNAL;\n\t    }\n\t}\n      offset += oc;\n    }\n    fclose (orig);\n    fclose (recons);\n    if (diffs != 0) \n      {\n\treturn XD3_INTERNAL;\n      }\n    return 0;\n}", "target": 1}
{"code": "address_space_translate_for_iotlb(CPUState *cpu, int asidx, hwaddr addr,\n                                  hwaddr *xlat, hwaddr *plen,\n                                  MemTxAttrs attrs, int *prot)\n{\n    MemoryRegionSection *section;\n    IOMMUMemoryRegion *iommu_mr;\n    IOMMUMemoryRegionClass *imrc;\n    IOMMUTLBEntry iotlb;\n    int iommu_idx;\n    AddressSpaceDispatch *d =\n        qatomic_rcu_read(&cpu->cpu_ases[asidx].memory_dispatch);\n    for (;;) {\n        section = address_space_translate_internal(d, addr, &addr, plen, false);\n        iommu_mr = memory_region_get_iommu(section->mr);\n        if (!iommu_mr) {\n            break;\n        }\n        imrc = memory_region_get_iommu_class_nocheck(iommu_mr);\n        iommu_idx = imrc->attrs_to_index(iommu_mr, attrs);\n        tcg_register_iommu_notifier(cpu, iommu_mr, iommu_idx);\n        iotlb = imrc->translate(iommu_mr, addr, IOMMU_NONE, iommu_idx);\n        addr = ((iotlb.translated_addr & ~iotlb.addr_mask)\n                | (addr & iotlb.addr_mask));\n        if (!(iotlb.perm & IOMMU_RO)) {\n            *prot &= ~(PAGE_READ | PAGE_EXEC);\n        }\n        if (!(iotlb.perm & IOMMU_WO)) {\n            *prot &= ~PAGE_WRITE;\n        }\n        if (!*prot) {\n            goto translate_fail;\n        }\n        d = flatview_to_dispatch(address_space_to_flatview(iotlb.target_as));\n    }\n    assert(!memory_region_is_iommu(section->mr));\n    *xlat = addr;\n    return section;\ntranslate_fail:\n    return &d->map.sections[PHYS_SECTION_UNASSIGNED];\n}", "target": 1}
{"code": "bool ValidateInput<Variant>(const Tensor& updates) {\n  return true;\n}", "target": 0}
{"code": "static pj_status_t STATUS_FROM_SSL_ERR2(char *action, pj_ssl_sock_t *ssock,\n\t\t\t\t\tint ret, int err, int len)\n{\n    unsigned long ssl_err = err;\n    if (err == SSL_ERROR_SSL) {\n\tssl_err = ERR_peek_error();\n    }\n    SSLLogErrors(action, ret, err, len, ssock);\n    ssock->last_err = ssl_err;\n    return GET_STATUS_FROM_SSL_ERR(ssl_err);\n}", "target": 1}
{"code": "template <class T> void testFeatTable(const T & table, const char * testName)\n{\n    FeatureMap testFeatureMap;\n    dummyFace.replace_table(TtfUtil::Tag::Feat, &table, sizeof(T));\n    gr_face * face = gr_make_face_with_ops(&dummyFace, &face_handle::ops, gr_face_dumbRendering);\n    if (!face) throw std::runtime_error(\"failed to load font\");\n    bool readStatus = testFeatureMap.readFeats(*face);\n    testAssert(\"readFeats\", readStatus);\n    fprintf(stderr, testName, NULL);\n    testAssertEqual(\"test num features %hu,%hu\\n\", testFeatureMap.numFeats(), table.m_header.m_numFeat);\n    for (size_t i = 0; i < sizeof(table.m_defs) / sizeof(FeatDefn); i++)\n    {\n        const FeatureRef * ref = testFeatureMap.findFeatureRef(table.m_defs[i].m_featId);\n        testAssert(\"test feat\\n\", ref);\n        testAssertEqual(\"test feat settings %hu %hu\\n\", ref->getNumSettings(), table.m_defs[i].m_numFeatSettings);\n        testAssertEqual(\"test feat label %hu %hu\\n\", ref->getNameId(), table.m_defs[i].m_label);\n        size_t settingsIndex = (table.m_defs[i].m_settingsOffset - sizeof(FeatHeader)\n            - (sizeof(FeatDefn) * table.m_header.m_numFeat)) / sizeof(FeatSetting);\n        for (size_t j = 0; j < table.m_defs[i].m_numFeatSettings; j++)\n        {\n            testAssertEqual(\"setting label %hu %hu\\n\", ref->getSettingName(j),\n                       table.m_settings[settingsIndex+j].m_label);\n        }\n    }\n    gr_face_destroy(face);\n}", "target": 1}
{"code": "  CloseNotifyConnector(EventBase* evb, const SocketAddress& addr) {\n    evb_ = evb;\n    ssl_ = AsyncSSLSocket::newSocket(std::make_shared<SSLContext>(), evb_);\n    ssl_->connect(this, addr);\n  }", "target": 0}
{"code": "int validated_offset(uint32_t addr, uint32_t start, uint32_t end){\n    return addr <= end && addr >= start? 0:-1;\n}", "target": 0}
{"code": "ikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t  const struct isakmp_gen *ext,\n\t\t  u_int item_len _U_,\n\t\t  const u_char *ep,\n\t\t  uint32_t phase _U_, uint32_t doi _U_,\n\t\t  uint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_NONCE)));\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" n len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t} else if (1 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!ike_show_somedata(ndo, (const u_char *)(const uint8_t *)(ext + 1), ep))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_NONCE)));\n\treturn NULL;\n}", "target": 1}
{"code": "static void srv_close(void)\n{\n\tverifyd.sock = mem_deref(verifyd.sock);\n}", "target": 0}
{"code": "static SDL_Surface *Create_Surface_Blended(int width, int height, SDL_Color fg, Uint32 *color)\n{\n    const int alignment = Get_Alignement() - 1;\n    SDL_Surface *textbuf = NULL;\n    Uint32 bgcolor;\n    bgcolor = (fg.r << 16) | (fg.g << 8) | fg.b;\n    *color = bgcolor | (fg.a << 24);\n    if (width != 0) {\n        Sint64 size;\n        void *pixels, *ptr;\n        Sint64 pitch = (width + alignment) * 4;\n        pitch += alignment;\n        pitch &= ~alignment;\n        size = height * pitch + sizeof (void *) + alignment;\n        if (size < 0 || size > SDL_MAX_SINT32) {\n            return NULL;\n        }\n        ptr = SDL_malloc((size_t)size);\n        if (ptr == NULL) {\n            return NULL;\n        }\n        pixels = (void *)(((uintptr_t)ptr + sizeof(void *) + alignment) & ~alignment);\n        ((void **)pixels)[-1] = ptr;\n        textbuf = SDL_CreateRGBSurfaceWithFormatFrom(pixels, width, height, 0, pitch, SDL_PIXELFORMAT_ARGB8888);\n        if (textbuf == NULL) {\n            SDL_free(ptr);\n            return NULL;\n        }\n        textbuf->flags &= ~SDL_PREALLOC;\n        textbuf->flags |= SDL_SIMD_ALIGNED;\n        SDL_memset4(pixels, bgcolor, (height * pitch) / 4);\n        if (fg.a != SDL_ALPHA_OPAQUE) {\n            SDL_SetSurfaceBlendMode(textbuf, SDL_BLENDMODE_BLEND);\n        }\n    }\n    return textbuf;", "target": 1}
{"code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  TfLiteTensor* hits;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 1, &hits));\n  const TfLiteTensor* lookup;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &lookup));\n  const TfLiteTensor* key;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &key));\n  const TfLiteTensor* value;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &value));\n  const int num_rows = SizeOfDimension(value, 0);\n  TF_LITE_ENSURE(context, num_rows != 0);\n  const int row_bytes = value->bytes / num_rows;\n  void* pointer = nullptr;\n  DynamicBuffer buf;\n  for (int i = 0; i < SizeOfDimension(lookup, 0); i++) {\n    int idx = -1;\n    pointer = bsearch(&(lookup->data.i32[i]), key->data.i32, num_rows,\n                      sizeof(int32_t), greater);\n    if (pointer != nullptr) {\n      idx = (reinterpret_cast<char*>(pointer) - (key->data.raw)) /\n            sizeof(int32_t);\n    }\n    if (idx >= num_rows || idx < 0) {\n      if (output->type == kTfLiteString) {\n        buf.AddString(nullptr, 0);\n      } else {\n        memset(output->data.raw + i * row_bytes, 0, row_bytes);\n      }\n      hits->data.uint8[i] = 0;\n    } else {\n      if (output->type == kTfLiteString) {\n        buf.AddString(GetString(value, idx));\n      } else {\n        memcpy(output->data.raw + i * row_bytes,\n               value->data.raw + idx * row_bytes, row_bytes);\n      }\n      hits->data.uint8[i] = 1;\n    }\n  }\n  if (output->type == kTfLiteString) {\n    buf.WriteToTensorAsVector(output);\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "int rom_copy(uint8_t *dest, hwaddr addr, size_t size)\n{\n    hwaddr end = addr + size;\n    uint8_t *s, *d = dest;\n    size_t l = 0;\n    Rom *rom;\n    QTAILQ_FOREACH(rom, &roms, next) {\n        if (rom->fw_file) {\n            continue;\n        }\n        if (rom->mr) {\n            continue;\n        }\n        if (rom->addr + rom->romsize < addr) {\n            continue;\n        }\n        if (rom->addr > end) {\n            break;\n        }\n        d = dest + (rom->addr - addr);\n        s = rom->data;\n        l = rom->datasize;\n        if ((d + l) > (dest + size)) {\n            l = dest - d;\n        }\n        if (l > 0) {\n            memcpy(d, s, l);\n        }\n        if (rom->romsize > rom->datasize) {\n            d += l;\n            l = rom->romsize - rom->datasize;\n            if ((d + l) > (dest + size)) {\n                l = dest - d;\n            }\n            if (l > 0) {\n                memset(d, 0x0, l);\n            }\n        }\n    }\n    return (d + l) - dest;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    auto value = ctx->input(0);\n    OP_REQUIRES(ctx, value.dims() >= 1,\n                errors::InvalidArgument(\"value should be at least rank 1.\"));\n    OP_REQUIRES(\n        ctx, value.dim_size(0) > loc_,\n        errors::InvalidArgument(\"0th dimension of value = \", value.dim_size(0),\n                                \" must be greater than loc_ = \", loc_));\n    auto update = ctx->input(1);\n    OP_REQUIRES(\n        ctx, value.dims() == update.dims(),\n        errors::InvalidArgument(\"value and update shape doesn't match: \",\n                                value.shape().DebugString(), \" vs. \",\n                                update.shape().DebugString()));\n    for (int i = 1; i < value.dims(); ++i) {\n      OP_REQUIRES(\n          ctx, value.dim_size(i) == update.dim_size(i),\n          errors::InvalidArgument(\"value and update shape doesn't match \",\n                                  value.shape().DebugString(), \" vs. \",\n                                  update.shape().DebugString()));\n    }\n    OP_REQUIRES(ctx, 1 == update.dim_size(0),\n                errors::InvalidArgument(\"update shape doesn't match: \",\n                                        update.shape().DebugString()));\n    Tensor output = value;  \n    const auto& d = ctx->eigen_device<Device>();\n    OP_REQUIRES_OK(\n        ctx, ::tensorflow::functor::DoParallelConcat(d, update, loc_, &output));\n    ctx->set_output(0, output);\n  }", "target": 0}
{"code": "int nfc_activate_target(struct nfc_dev *dev, u32 target_idx, u32 protocol)\n{\n\tint rc;\n\tstruct nfc_target *target;\n\tpr_debug(\"dev_name=%s target_idx=%u protocol=%u\\n\",\n\t\t dev_name(&dev->dev), target_idx, protocol);\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->active_target) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\ttarget = nfc_find_target(dev, target_idx);\n\tif (target == NULL) {\n\t\trc = -ENOTCONN;\n\t\tgoto error;\n\t}\n\trc = dev->ops->activate_target(dev, target, protocol);\n\tif (!rc) {\n\t\tdev->active_target = target;\n\t\tdev->rf_mode = NFC_RF_INITIATOR;\n\t\tif (dev->ops->check_presence && !dev->shutting_down)\n\t\t\tmod_timer(&dev->check_pres_timer, jiffies +\n\t\t\t\t  msecs_to_jiffies(NFC_CHECK_PRES_FREQ_MS));\n\t}\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "static void vhost_zerocopy_done_signal(struct kref *kref)\n{\n\tstruct vhost_ubuf_ref *ubufs = container_of(kref, struct vhost_ubuf_ref,\n\t\t\t\t\t\t    kref);\n\twake_up(&ubufs->wait);\n}", "target": 0}
{"code": "int simple_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error;\n\tif (type == ACL_TYPE_ACCESS) {\n\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\tif (error < 0)\n\t\t\treturn 0;\n\t\tif (error == 0)\n\t\t\tacl = NULL;\n\t}\n\tinode->i_ctime = current_time(inode);\n\tset_cached_acl(inode, type, acl);\n\treturn 0;\n}", "target": 1}
{"code": "static void *skcipher_bind(const char *name, u32 type, u32 mask)\n{\n\treturn crypto_alloc_skcipher(name, type, mask);\n}", "target": 1}
{"code": "    int32_t audio_io_osx::shutdown_audio_unit() {\n        OSStatus result = -1;\n        if (NULL != au_rec_) {\n            result = AudioOutputUnitStop(au_rec_);\n            if (0 != result) {\n                error(\"audio_io_osx: Error stopping Audio Unit (result=%d) \\n\", result);\n            }\n            result = AudioComponentInstanceDispose(au_rec_);\n            if (0 != result) {\n                error(\"audio_io_osx: Error disposing Audio Unit (result=%d) \\n\", result);\n            }\n            au_rec_ = NULL;\n        }\n        if (NULL != au_play_) {\n            result = AudioOutputUnitStop(au_play_);\n            if (0 != result) {\n                error(\"audio_io_osx: Error stopping Audio Unit (result=%d) \\n\", result);\n            }\n            result = AudioComponentInstanceDispose(au_play_);\n            if (0 != result) {\n                error(\"audio_io_osx: Error disposing Audio Unit (result=%d) \\n\", result);\n            }\n            au_play_ = NULL;\n        }\n        return 0;\n    }", "target": 0}
{"code": "OFTEST(dcmect_overflow)\n{\n    if (!dcmDataDict.isDictionaryLoaded())\n    {\n        OFCHECK(dcmDataDict.isDictionaryLoaded());\n    }\n    EctEnhancedCT *ct = create();\n    configureIOD(ct);\n    setGenericValues(ct);\n    addSharedFGs(ct);\n    addFrames(ct);\n    addDimensions(ct);\n    DcmFileFormat dcmff;\n    OFTempFile tf(O_RDWR, \"\", \"t_overflow\", \".dcm\");\n    OFCondition result;\n    result = ct->saveFile(\"output.dcm\", EXS_LittleEndianExplicit);\n    OFCHECK_MSG(result == ECT_InvalidPixelInfo, result.text());\n}", "target": 0}
{"code": "static std::wstring MB2WC(const std::string& input, unsigned int code_page) {\n  if (input.empty()) {\n    return L\"\";\n  }\n  int length = ::MultiByteToWideChar(code_page, 0, &input[0],\n                                     static_cast<int>(input.size()),\n                                     NULL, 0);\n  std::wstring output(length, '\\0');\n  ::MultiByteToWideChar(code_page, 0, &input[0], static_cast<int>(input.size()),\n                        &output[0], static_cast<int>(output.size()));\n  return output;\n}", "target": 0}
{"code": "main (int argc, char *argv[])\n{\n  g_test_init (&argc, &argv, NULL);\n  g_test_add_func (\"/context/env\", test_context_env);\n  g_test_add_func (\"/context/env-fd\", test_context_env_fd);\n  g_test_add_func (\"/context/merge-fs\", test_context_merge_fs);\n  g_test_add_func (\"/context/validate-path-args\", test_validate_path_args);\n  g_test_add_func (\"/context/validate-path-meta\", test_validate_path_meta);\n  return g_test_run ();\n}", "target": 0}
{"code": "void InterstitialPage::Focus() {\n  render_view_host_->view()->Focus();\n}", "target": 0}
{"code": "inline int NumOutputs(const TfLiteNode* node) { return node->outputs->size; }", "target": 0}
{"code": "static long process_cpu_nsleep_restart(struct restart_block *restart_block)\n{\n\treturn -EINVAL;\n}", "target": 0}
{"code": "static int hgcm_call_preprocess_linaddr(\n\tconst struct vmmdev_hgcm_function_parameter *src_parm,\n\tvoid **bounce_buf_ret, size_t *extra)\n{\n\tvoid *buf, *bounce_buf;\n\tbool copy_in;\n\tu32 len;\n\tint ret;\n\tbuf = (void *)src_parm->u.pointer.u.linear_addr;\n\tlen = src_parm->u.pointer.size;\n\tcopy_in = src_parm->type != VMMDEV_HGCM_PARM_TYPE_LINADDR_OUT;\n\tif (len > VBG_MAX_HGCM_USER_PARM)\n\t\treturn -E2BIG;\n\tbounce_buf = kvmalloc(len, GFP_KERNEL);\n\tif (!bounce_buf)\n\t\treturn -ENOMEM;\n\tif (copy_in) {\n\t\tret = copy_from_user(bounce_buf, (void __user *)buf, len);\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tmemset(bounce_buf, 0, len);\n\t}\n\t*bounce_buf_ret = bounce_buf;\n\thgcm_call_add_pagelist_size(bounce_buf, len, extra);\n\treturn 0;\n}", "target": 1}
{"code": "MOBI_RET mobi_trie_insert_infl(MOBITrie **root, const MOBIIndx *indx, size_t i) {\n    MOBIIndexEntry e = indx->entries[i];\n    char *inflected = e.label;\n    for (size_t j = 0; j < e.tags_count; j++) {\n        MOBIIndexTag t = e.tags[j];\n        if (t.tagid == INDX_TAGARR_INFL_PARTS_V1) {\n            for (size_t k = 0; k < t.tagvalues_count - 1; k += 2) {\n                uint32_t len = t.tagvalues[k];\n                uint32_t offset = t.tagvalues[k + 1];\n                char *base = mobi_get_cncx_string_flat(indx->cncx_record, offset, len);\n                if (base == NULL) {\n                    return MOBI_MALLOC_FAILED;\n                }\n                MOBI_RET ret = mobi_trie_insert_reversed(root, base, inflected);\n                free(base);\n                if (ret != MOBI_SUCCESS) {\n                    return ret;\n                }\n            }\n        }\n    }\n    return MOBI_SUCCESS;\n}", "target": 1}
{"code": "TfLiteStatus ReluPrepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  ReluOpData* data = static_cast<ReluOpData*>(node->user_data);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  if (input->type == kTfLiteInt8) {\n    CalculateReluOpData<int8_t>(input, output, data);\n  } else if (input->type == kTfLiteUInt8) {\n    CalculateReluOpData<uint8_t>(input, output, data);\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "comics_generate_command_lines (ComicsDocument *comics_document,\n\t\t\t       GError         **error)\n{\n\tgchar *quoted_file, *quoted_file_aux;\n\tgchar *quoted_command;\n\tComicBookDecompressType type;\n\ttype = comics_document->command_usage;\n\tcomics_document->regex_arg = command_usage_def[type].regex_arg;\n\tquoted_command = g_shell_quote (comics_document->selected_command);\n\tif (comics_document->regex_arg) {\n\t\tquoted_file = comics_regex_quote (comics_document->archive);\n\t\tquoted_file_aux = g_shell_quote (comics_document->archive);\n\t\tcomics_document->list_command =\n\t\t\t   g_strdup_printf (command_usage_def[type].list,\n\t\t\t                    comics_document->alternative_command,\n\t\t\t                    quoted_file_aux);\n\t\tg_free (quoted_file_aux);\n\t} else {\n\t\tquoted_file = g_shell_quote (comics_document->archive);\n\t\tcomics_document->list_command =\n\t\t\t\tg_strdup_printf (command_usage_def[type].list,\n\t\t\t\t                 quoted_command, quoted_file);\n\t}\n\tcomics_document->extract_command =\n\t\t\t    g_strdup_printf (command_usage_def[type].extract,\n\t\t\t\t             quoted_command);\n\tcomics_document->offset = command_usage_def[type].offset;\n\tif (command_usage_def[type].decompress_tmp) {\n\t\tcomics_document->dir = ev_mkdtemp (\"atril-comics-XXXXXX\", error);\n                if (comics_document->dir == NULL)\n                        return FALSE;\n\t\tcomics_document->decompress_tmp =\n\t\t\tg_strdup_printf (command_usage_def[type].decompress_tmp,\n\t\t\t\t\t quoted_command, quoted_file,\n\t\t\t\t\t comics_document->dir);\n\t\tg_free (quoted_file);\n\t\tg_free (quoted_command);\n\t\tif (!comics_decompress_temp_dir (comics_document->decompress_tmp,\n\t\t    comics_document->selected_command, error))\n\t\t\treturn FALSE;\n\t\telse\n\t\t\treturn TRUE;\n\t} else {\n\t\tg_free (quoted_file);\n\t\tg_free (quoted_command);\n\t\treturn TRUE;\n\t}\n}", "target": 1}
{"code": "void Transform::interpolate_nearestneighbour( RawTile& in, unsigned int resampled_width, unsigned int resampled_height ){\n  unsigned char *input = (unsigned char*) in.data;\n  int channels = in.channels;\n  unsigned int width = in.width;\n  unsigned int height = in.height;\n  unsigned char *output;\n  bool new_buffer = false;\n  if( resampled_width*resampled_height > in.width*in.height ){\n    new_buffer = true;\n    output = new unsigned char[(unsigned long long)resampled_width*resampled_height*in.channels];\n  }\n  else output = (unsigned char*) in.data;\n  float xscale = (float)width / (float)resampled_width;\n  float yscale = (float)height / (float)resampled_height;\n  for( unsigned int j=0; j<resampled_height; j++ ){\n    for( unsigned int i=0; i<resampled_width; i++ ){\n      unsigned long ii = (unsigned int) floorf(i*xscale);\n      unsigned long jj = (unsigned int) floorf(j*yscale);\n      unsigned long pyramid_index = (unsigned int) channels * ( ii + jj*width );\n      unsigned long long resampled_index = (unsigned long long)(i + j*resampled_width)*channels;\n      for( int k=0; k<in.channels; k++ ){\n\toutput[resampled_index+k] = input[pyramid_index+k];\n      }\n    }\n  }\n  if( new_buffer ) delete[] (unsigned char*) input;\n  in.width = resampled_width;\n  in.height = resampled_height;\n  in.dataLength = resampled_width * resampled_height * channels * (in.bpc/8);\n  in.data = output;\n}", "target": 1}
{"code": "gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t   gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n\t\t   int iov_count)\n{\n    OM_uint32 status;\n    gss_union_ctx_id_t ctx;\n    gss_mechanism mech;\n    status = val_unwrap_iov_args(minor_status, context_handle, NULL,\n\t\t\t\t qop_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn status;\n    ctx = (gss_union_ctx_id_t)context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism(ctx->mech_type);\n    if (mech == NULL)\n\treturn GSS_S_BAD_MECH;\n    if (mech->gss_verify_mic_iov == NULL)\n\treturn GSS_S_UNAVAILABLE;\n    status = mech->gss_verify_mic_iov(minor_status, ctx->internal_ctx_id,\n\t\t\t\t      qop_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\tmap_error(minor_status, mech);\n    return status;\n}", "target": 0}
{"code": "spnego_gss_complete_auth_token(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tgss_buffer_t input_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_complete_auth_token(minor_status,\n\t\t\t\t      context_handle,\n\t\t\t\t      input_message_buffer);\n\treturn (ret);\n}", "target": 1}
{"code": "hybiReturnData(char *dst, int len, ws_ctx_t *wsctx, int *nWritten)\n{\n  int nextState = WS_HYBI_STATE_ERR;\n  if (wsctx->readlen > 0) {\n    if (wsctx->readlen > len) {\n      rfbLog(\"copy to %d bytes to dst buffer; readPos=%p, readLen=%d\\n\", len, wsctx->readPos, wsctx->readlen);\n      memcpy(dst, wsctx->readPos, len);\n      *nWritten = len;\n      wsctx->readlen -= len;\n      wsctx->readPos += len;\n      nextState = WS_HYBI_STATE_DATA_AVAILABLE;\n    } else {\n      rfbLog(\"copy to %d bytes to dst buffer; readPos=%p, readLen=%d\\n\", wsctx->readlen, wsctx->readPos, wsctx->readlen);\n      memcpy(dst, wsctx->readPos, wsctx->readlen);\n      *nWritten = wsctx->readlen;\n      wsctx->readlen = 0;\n      wsctx->readPos = NULL;\n      if (hybiRemaining(wsctx) == 0) {\n        nextState = WS_HYBI_STATE_FRAME_COMPLETE;\n      } else {\n        nextState = WS_HYBI_STATE_DATA_NEEDED;\n      }\n    }\n    rfbLog(\"after copy: readPos=%p, readLen=%d\\n\", wsctx->readPos, wsctx->readlen);\n  } else if (wsctx->hybiDecodeState == WS_HYBI_STATE_CLOSE_REASON_PENDING) {\n    nextState = WS_HYBI_STATE_CLOSE_REASON_PENDING;\n  }\n  return nextState;\n}", "target": 0}
{"code": "bool Scanner::fill(size_t need)\n{\n    if (eof) return false;\n    pop_finished_files();\n    DASSERT(bot <= tok && tok <= lim);\n    size_t free = static_cast<size_t>(tok - bot);\n    size_t copy = static_cast<size_t>(lim - tok);\n    if (free >= need) {\n        memmove(bot, tok, copy);\n        shift_ptrs_and_fpos(-static_cast<ptrdiff_t>(free));\n    }\n    else {\n        BSIZE += std::max(BSIZE, need);\n        char * buf = new char[BSIZE + YYMAXFILL];\n        if (!buf) fatal(\"out of memory\");\n        memmove(buf, tok, copy);\n        shift_ptrs_and_fpos(buf - bot);\n        delete [] bot;\n        bot = buf;\n        free = BSIZE - copy;\n    }\n    if (!read(free)) {\n        eof = lim;\n        memset(lim, 0, YYMAXFILL);\n        lim += YYMAXFILL;\n    }\n    return true;\n}", "target": 1}
{"code": "START_TEST(test_deltas_head_sort)\n{\n\tstruct deltas_head deltas;\n\tdeltas_head_init(&deltas);\n\tck_assert_int_eq(0, deltas_head_sort(&deltas, 0));\n\tck_assert_int_eq(0, deltas_head_sort(&deltas, 1));\n\tck_assert_int_eq(0, deltas_head_sort(&deltas, 2));\n\tadd_serials(&deltas, 0, END);\n\tck_assert_int_eq(0, deltas_head_sort(&deltas, 0));\n\tvalidate_serials(&deltas, 0, END);\n\tck_assert_int_eq(-EINVAL, deltas_head_sort(&deltas, 2));\n\tck_assert_int_eq(-EINVAL, deltas_head_sort(&deltas, 1));\n\tadd_serials(&deltas, 1, 2, 3, END);\n\tck_assert_int_eq(0, deltas_head_sort(&deltas, 3));\n\tvalidate_serials(&deltas, 0, 1, 2, 3, END);\n\tck_assert_int_eq(-EINVAL, deltas_head_sort(&deltas, 4));\n\tck_assert_int_eq(-EINVAL, deltas_head_sort(&deltas, 2));\n\tdeltas_head_cleanup(&deltas, NULL);\n\tdeltas_head_init(&deltas);\n\tadd_serials(&deltas, 3, 0, 1, 2, END);\n\tck_assert_int_eq(0, deltas_head_sort(&deltas, 3));\n\tvalidate_serials(&deltas, 0, 1, 2, 3, END);\n\tdeltas_head_cleanup(&deltas, NULL);\n\tdeltas_head_init(&deltas);\n\tadd_serials(&deltas, 4, 3, 2, 1, 0, END);\n\tck_assert_int_eq(0, deltas_head_sort(&deltas, 4));\n\tvalidate_serials(&deltas, 0, 1, 2, 3, 4, END);\n\tck_assert_int_eq(-EINVAL, deltas_head_sort(&deltas, 5));\n\tck_assert_int_eq(-EINVAL, deltas_head_sort(&deltas, 3));\n\tdeltas_head_cleanup(&deltas, NULL);\n}", "target": 0}
{"code": "int mp_pack(lua_State *L) {\n    int nargs = lua_gettop(L);\n    int i;\n    mp_buf *buf;\n    if (nargs == 0)\n        return luaL_argerror(L, 0, \"MessagePack pack needs input.\");\n    if (!lua_checkstack(L, nargs))\n        return luaL_argerror(L, 0, \"Too many arguments for MessagePack pack.\");\n    buf = mp_buf_new(L);\n    for(i = 1; i <= nargs; i++) {\n        luaL_checkstack(L, 1, \"in function mp_check\");\n        lua_pushvalue(L, i);\n        mp_encode_lua_type(L,buf,0);\n        lua_pushlstring(L,(char*)buf->b,buf->len);\n        buf->free += buf->len;\n        buf->len = 0;\n    }\n    mp_buf_free(L, buf);\n    lua_concat(L, nargs);\n    return 1;\n}", "target": 0}
{"code": "void common_timer_get(struct k_itimer *timr, struct itimerspec64 *cur_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tktime_t now, remaining, iv;\n\tstruct timespec64 ts64;\n\tbool sig_none;\n\tsig_none = timr->it_sigev_notify == SIGEV_NONE;\n\tiv = timr->it_interval;\n\tif (iv) {\n\t\tcur_setting->it_interval = ktime_to_timespec64(iv);\n\t} else if (!timr->it_active) {\n\t\tif (!sig_none)\n\t\t\treturn;\n\t}\n\tkc->clock_get(timr->it_clock, &ts64);\n\tnow = timespec64_to_ktime(ts64);\n\tif (iv && (timr->it_requeue_pending & REQUEUE_PENDING || sig_none))\n\t\ttimr->it_overrun += (int)kc->timer_forward(timr, now);\n\tremaining = kc->timer_remaining(timr, now);\n\tif (remaining <= 0) {\n\t\tif (!sig_none)\n\t\t\tcur_setting->it_value.tv_nsec = 1;\n\t} else {\n\t\tcur_setting->it_value = ktime_to_timespec64(remaining);\n\t}\n}", "target": 1}
{"code": "xfs_bmap_unmap_extent(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_defer_ops\t*dfops,\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_bmbt_irec\t*PREV)\n{\n\tif (!xfs_bmap_is_update_needed(PREV))\n\t\treturn 0;\n\treturn __xfs_bmap_add(mp, dfops, XFS_BMAP_UNMAP, ip,\n\t\t\tXFS_DATA_FORK, PREV);\n}", "target": 0}
{"code": "static void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tstruct sock *sk;\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tsk = s->sk;\n\t\t\tif (!sk) {\n\t\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\t\ts->ax25_dev = NULL;\n\t\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tsock_hold(sk);\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(sk);\n\t\t\ts->ax25_dev = NULL;\n\t\t\tif (sk->sk_socket) {\n\t\t\t\tdev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker);\n\t\t\t\tax25_dev_put(ax25_dev);\n\t\t\t}\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\trelease_sock(sk);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tsock_put(sk);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}", "target": 1}
{"code": "GF_Err Q_DecCoordOnUnitSphere(GF_BifsDecoder *codec, GF_BitStream *bs, u32 NbBits, u32 NbComp, Fixed *m_ft)\n{\n\tu32 i, orient, sign;\n\ts32 value;\n\tFixed tang[4], delta;\n\ts32 dir;\n\tif (NbComp != 2 && NbComp != 3) return GF_BAD_PARAM;\n\tdir = 1;\n\tif(NbComp == 2) dir -= 2 * gf_bs_read_int(bs, 1);\n\torient = gf_bs_read_int(bs, 2);\n\tif ((orient==3) && (NbComp==2)) return GF_NON_COMPLIANT_BITSTREAM;\n\tfor(i=0; i<NbComp; i++) {\n\t\tvalue = gf_bs_read_int(bs, NbBits) - (1 << (NbBits-1) );\n\t\tsign = (value >= 0) ? 1 : -1;\n\t\tm_ft[i] = sign * Q_InverseQuantize(0, 1, NbBits-1, sign*value);\n\t}\n\tdelta = 1;\n\tfor (i=0; i<NbComp; i++) {\n\t\ttang[i] = gf_tan(gf_mulfix(GF_PI/4, m_ft[i]) );\n\t\tdelta += gf_mulfix(tang[i], tang[i]);\n\t}\n\tdelta = gf_divfix(INT2FIX(dir), gf_sqrt(delta) );\n\tm_ft[orient] = delta;\n\tfor (i=0; i<NbComp; i++) {\n\t\tm_ft[ (orient + i+1) % (NbComp+1) ] = gf_mulfix(tang[i], delta);\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "static TEE_Result set_rmem_param(const struct optee_msg_param_rmem *rmem,\n\t\t\t\t struct param_mem *mem)\n{\n\tsize_t req_size = 0;\n\tuint64_t shm_ref = READ_ONCE(rmem->shm_ref);\n\tmem->mobj = mobj_reg_shm_get_by_cookie(shm_ref);\n\tif (!mem->mobj)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\tmem->offs = READ_ONCE(rmem->offs);\n\tmem->size = READ_ONCE(rmem->size);\n\tif (ADD_OVERFLOW(mem->offs, mem->size, &req_size) ||\n\t    mem->mobj->size < req_size)\n\t\treturn TEE_ERROR_SECURITY;\n\treturn TEE_SUCCESS;\n}", "target": 0}
{"code": "t1mac_output_ascii(char *s, int len)\n{\n  if (blocktyp == POST_BINARY) {\n    output_current_post();\n    blocktyp = POST_ASCII;\n  }\n  if (len > 0 && s[len-1] == '\\n')\n    s[len-1] = '\\r';\n  t1mac_output_data((byte *)s, len);\n  if (strncmp(s, \"/FontName\", 9) == 0) {\n    for (s += 9; isspace(*s); s++) ;\n    if (*s == '/') {\n      const char *t = ++s;\n      while (*t && !isspace(*t)) t++;\n      free(font_name);\n      font_name = (char *)malloc(t - s + 1);\n      memcpy(font_name, s, t - s);\n      font_name[t - s] = 0;\n    }\n  }\n}", "target": 1}
{"code": "FileInformation ImageReadJPEG(\n      Image& out,\n      String const& filename\n) {\n   JpegInput jpeg( filename );\n   FileInformation info = GetJPEGInfo( jpeg );\n   int nchan = jpeg.cinfo().num_components;\n   jpeg.cinfo().out_color_space = nchan > 1 ? JCS_RGB : JCS_GRAYSCALE;\n   out.ReForge( info.sizes, info.tensorElements, DT_UINT8, Option::AcceptDataTypeChange::DONT_ALLOW );\n   out.SetPixelSize( info.pixelSize );\n   out.SetColorSpace( info.colorSpace );\n   jpeg_start_decompress( jpeg.cinfoptr() );\n   std::vector< JSAMPLE > buffer( info.sizes[ 0 ] * static_cast< unsigned >( nchan )); \n   dip::uint8* imagedata = static_cast< dip::uint8* >( out.Origin() );\n   auto stride = out.Strides();\n   auto tStride = out.TensorStride();\n   for( dip::uint ii = 0; ii < info.sizes[ 1 ]; ++ii ) {\n      JSAMPLE* indata = buffer.data();\n      jpeg_read_scanlines( jpeg.cinfoptr(), &indata, 1 );\n      dip::uint8* outdata = imagedata;\n      if( nchan > 1 ) {\n         for( dip::uint jj = 0; jj < info.sizes[ 0 ]; ++jj ) {\n            for( int kk = 0; kk < nchan; ++kk ) {\n               *( outdata + kk * tStride ) = *indata;\n               ++indata;\n            }\n            outdata += stride[ 0 ];\n         }\n      } else {\n         for( dip::uint jj = 0; jj < info.sizes[ 0 ]; ++jj ) {\n            *outdata = *indata;\n            ++indata;\n            outdata += stride[ 0 ];\n         }\n      }\n      imagedata += stride[ 1 ];\n   }\n   jpeg_finish_decompress( jpeg.cinfoptr() );\n   return info;\n}", "target": 1}
{"code": "static int get_exif_tag_int_value(struct iw_exif_state *e, unsigned int tag_pos,\n\tunsigned int *pv)\n{\n\tunsigned int field_type;\n\tunsigned int value_count;\n\tfield_type = iw_get_ui16_e(&e->d[tag_pos+2],e->endian);\n\tvalue_count = iw_get_ui32_e(&e->d[tag_pos+4],e->endian);\n\tif(value_count!=1) return 0;\n\tif(field_type==3) { \n\t\t*pv = iw_get_ui16_e(&e->d[tag_pos+8],e->endian);\n\t\treturn 1;\n\t}\n\telse if(field_type==4) { \n\t\t*pv = iw_get_ui32_e(&e->d[tag_pos+8],e->endian);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "gplotCreate(const char  *rootname,\n            l_int32      outformat,\n            const char  *title,\n            const char  *xlabel,\n            const char  *ylabel)\n{\nchar    *newroot;\nchar     buf[L_BUF_SIZE];\nl_int32  badchar;\nGPLOT   *gplot;\n    PROCNAME(\"gplotCreate\");\n    if (!rootname)\n        return (GPLOT *)ERROR_PTR(\"rootname not defined\", procName, NULL);\n    if (outformat != GPLOT_PNG && outformat != GPLOT_PS &&\n        outformat != GPLOT_EPS && outformat != GPLOT_LATEX)\n        return (GPLOT *)ERROR_PTR(\"outformat invalid\", procName, NULL);\n    stringCheckForChars(rootname, \"`;&|><\\\"?*\", &badchar);\n    if (badchar)  \n        return (GPLOT *)ERROR_PTR(\"invalid rootname\", procName, NULL);\n    if ((gplot = (GPLOT *)LEPT_CALLOC(1, sizeof(GPLOT))) == NULL)\n        return (GPLOT *)ERROR_PTR(\"gplot not made\", procName, NULL);\n    gplot->cmddata = sarrayCreate(0);\n    gplot->datanames = sarrayCreate(0);\n    gplot->plotdata = sarrayCreate(0);\n    gplot->plottitles = sarrayCreate(0);\n    gplot->plotstyles = numaCreate(0);\n    newroot = genPathname(rootname, NULL);\n    gplot->rootname = newroot;\n    gplot->outformat = outformat;\n    snprintf(buf, L_BUF_SIZE, \"%s.cmd\", rootname);\n    gplot->cmdname = stringNew(buf);\n    if (outformat == GPLOT_PNG)\n        snprintf(buf, L_BUF_SIZE, \"%s.png\", newroot);\n    else if (outformat == GPLOT_PS)\n        snprintf(buf, L_BUF_SIZE, \"%s.ps\", newroot);\n    else if (outformat == GPLOT_EPS)\n        snprintf(buf, L_BUF_SIZE, \"%s.eps\", newroot);\n    else if (outformat == GPLOT_LATEX)\n        snprintf(buf, L_BUF_SIZE, \"%s.tex\", newroot);\n    gplot->outname = stringNew(buf);\n    if (title) gplot->title = stringNew(title);\n    if (xlabel) gplot->xlabel = stringNew(xlabel);\n    if (ylabel) gplot->ylabel = stringNew(ylabel);\n    return gplot;\n}", "target": 1}
{"code": "cmyk_to_rgb(JSAMPLE c, JSAMPLE m, JSAMPLE y, JSAMPLE k, JSAMPLE *r, JSAMPLE *g,\n            JSAMPLE *b)\n{\n  *r = (JSAMPLE)((double)c * (double)k / 255.0 + 0.5);\n  *g = (JSAMPLE)((double)m * (double)k / 255.0 + 0.5);\n  *b = (JSAMPLE)((double)y * (double)k / 255.0 + 0.5);\n}", "target": 0}
{"code": "void jpc_qmfb_split_colres(jpc_fix_t *a, int numrows, int numcols,\n  int stride, int parity)\n{\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE];\n\tjpc_fix_t *buf = splitbuf;\n\tjpc_fix_t *srcptr;\n\tjpc_fix_t *dstptr;\n\tregister jpc_fix_t *srcptr2;\n\tregister jpc_fix_t *dstptr2;\n\tregister int n;\n\tregister int i;\n\tint m;\n\tint hstartcol;\n\tif (bufsize > QMFB_SPLITBUFSIZE) {\n\t\tif (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {\n\t\t\tabort();\n\t\t}\n\t}\n\tif (numrows >= 2) {\n\t\thstartcol = (numrows + 1 - parity) >> 1;\n\t\tm = numrows - hstartcol;\n\t\tn = m;\n\t\tdstptr = buf;\n\t\tsrcptr = &a[(1 - parity) * stride];\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += numcols;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\tdstptr = &a[(1 - parity) * stride];\n\t\tsrcptr = &a[(2 - parity) * stride];\n\t\tn = numrows - m - (!parity);\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\tdstptr = &a[hstartcol * stride];\n\t\tsrcptr = buf;\n\t\tn = m;\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += numcols;\n\t\t}\n\t}\n\tif (buf != splitbuf) {\n\t\tjas_free(buf);\n\t}\n}", "target": 1}
{"code": "dissect_spoolss_keybuffer(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t  proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tguint32 size;\n\tint end_offset;\n\tif (di->conformant_run)\n\t\treturn offset;\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_keybuffer_size, &size);\n\tend_offset = offset + (size*2);\n\tif (end_offset < offset) {\n\t\tend_offset = tvb_reported_length_remaining(tvb, offset) + 1;\n\t}\n\twhile (offset < end_offset)\n\t\toffset = dissect_spoolss_uint16uni(\n\t\t\ttvb, offset, pinfo, tree, drep, NULL, hf_keybuffer);\n\treturn offset;\n}", "target": 1}
{"code": "static void ext4_invalidatepage_free_endio(struct page *page, unsigned long offset)\n{\n\tstruct buffer_head *head, *bh;\n\tunsigned int curr_off = 0;\n\tif (!page_has_buffers(page))\n\t\treturn;\n\thead = bh = page_buffers(page);\n\tdo {\n\t\tif (offset <= curr_off && test_clear_buffer_uninit(bh)\n\t\t\t\t\t&& bh->b_private) {\n\t\t\text4_free_io_end(bh->b_private);\n\t\t\tbh->b_private = NULL;\n\t\t\tbh->b_end_io = NULL;\n\t\t}\n\t\tcurr_off = curr_off + bh->b_size;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n}", "target": 0}
{"code": "f_indent(typval_T *argvars, typval_T *rettv)\n{\n    linenr_T\tlnum;\n    if (in_vim9script() && check_for_lnum_arg(argvars, 0) == FAIL)\n\treturn;\n    lnum = tv_get_lnum(argvars);\n    if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count)\n\trettv->vval.v_number = get_indent_lnum(lnum);\n    else\n    {\n\tif (in_vim9script())\n\t    semsg(_(e_invalid_line_number_nr), lnum);\n\trettv->vval.v_number = -1;\n    }\n}", "target": 0}
{"code": "static CURLUcode hostname_check(struct Curl_URL *u, char *hostname)\n{\n  size_t len;\n  size_t hlen = strlen(hostname);\n  if(hostname[0] == '[') {\n    const char *l = \"0123456789abcdefABCDEF:.\";\n    if(hlen < 4) \n      return CURLUE_BAD_IPV6;\n    hostname++;\n    hlen -= 2;\n    if(hostname[hlen] != ']')\n      return CURLUE_BAD_IPV6;\n    len = strspn(hostname, l);\n    if(hlen != len) {\n      hlen = len;\n      if(hostname[len] == '%') {\n        char zoneid[16];\n        int i = 0;\n        char *h = &hostname[len + 1];\n        if(!strncmp(h, \"25\", 2) && h[2] && (h[2] != ']'))\n          h += 2;\n        while(*h && (*h != ']') && (i < 15))\n          zoneid[i++] = *h++;\n        if(!i || (']' != *h))\n          return CURLUE_MALFORMED_INPUT;\n        zoneid[i] = 0;\n        u->zoneid = strdup(zoneid);\n        if(!u->zoneid)\n          return CURLUE_OUT_OF_MEMORY;\n        hostname[len] = ']'; \n        hostname[len + 1] = 0; \n      }\n      else\n        return CURLUE_BAD_IPV6;\n    }\n#ifdef ENABLE_IPV6\n    {\n      char dest[16]; \n      char norm[MAX_IPADR_LEN];\n      hostname[hlen] = 0; \n      if(1 != Curl_inet_pton(AF_INET6, hostname, dest))\n        return CURLUE_BAD_IPV6;\n      if(Curl_inet_ntop(AF_INET6, dest, norm, sizeof(norm)) &&\n         (strlen(norm) < hlen)) {\n        strcpy(hostname, norm);\n        hlen = strlen(norm);\n        hostname[hlen + 1] = 0;\n      }\n      hostname[hlen] = ']'; \n    }\n#endif\n  }\n  else {\n    len = strcspn(hostname, \" \\r\\n\\t/:#?!@\");\n    if(hlen != len)\n      return CURLUE_BAD_HOSTNAME;\n  }\n  if(!hostname[0])\n    return CURLUE_NO_HOST;\n  return CURLUE_OK;\n}", "target": 0}
{"code": "apr_byte_t oidc_cache_set(request_rec *r, const char *section, const char *key,\n\t\tconst char *value, apr_time_t expiry) {\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\tint encrypted = oidc_cfg_cache_encrypt(r);\n\tchar *encoded = NULL;\n\tapr_byte_t rc = FALSE;\n\tchar *msg = NULL;\n\toidc_debug(r,\n\t\t\t\"enter: %s (section=%s, len=%d, encrypt=%d, ttl(s)=%\" APR_TIME_T_FMT \", type=%s)\",\n\t\t\tkey, section, value ? (int )strlen(value) : 0, encrypted,\n\t\t\t\t\tapr_time_sec(expiry - apr_time_now()), cfg->cache->name);\n\tif (encrypted == 1) {\n\t\tkey = oidc_cache_get_hashed_key(r, cfg->crypto_passphrase, key);\n\t\tif (key == NULL)\n\t\t\tgoto out;\n\t\tif (value != NULL) {\n\t\t\tif (oidc_cache_crypto_encrypt(r, value,\n\t\t\t\t\toidc_cache_hash_passphrase(r, cfg->crypto_passphrase),\n\t\t\t\t\t&encoded) <= 0)\n\t\t\t\tgoto out;\n\t\t\tvalue = encoded;\n\t\t}\n\t}\n\trc = cfg->cache->set(r, section, key, value, expiry);\nout:\n\tmsg = apr_psprintf(r->pool, \"%d bytes in %s cache backend for %skey %s\",\n\t\t\t(value ? (int) strlen(value) : 0),\n\t\t\t(cfg->cache->name ? cfg->cache->name : \"\"),\n\t\t\t(encrypted ? \"encrypted \" : \"\"), (key ? key : \"\"));\n\tif (rc == TRUE)\n\t\toidc_debug(r, \"successfully stored %s\", msg);\n\telse\n\t\toidc_warn(r, \"could NOT store %s\", msg);\n\treturn rc;\n}", "target": 1}
{"code": "static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)\n{\n\tint start = 0;\n\tu32 prev_legacy, cur_legacy;\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tprev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tcur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tif (!prev_legacy && cur_legacy)\n\t\tstart = 1;\n\tmemcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels,\n\t       sizeof(kvm->arch.vpit->pit_state.channels));\n\tkvm->arch.vpit->pit_state.flags = ps->flags;\n\tkvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, start);\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn 0;\n}", "target": 1}
{"code": "struct resource_pool *dcn10_create_resource_pool(\n\t\tconst struct dc_init_data *init_data,\n\t\tstruct dc *dc)\n{\n\tstruct dcn10_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dcn10_resource_pool), GFP_KERNEL);\n\tif (!pool)\n\t\treturn NULL;\n\tif (construct(init_data->num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\tkfree(pool);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 0}
{"code": "static int rose_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\tstruct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tsize_t copied;\n\tunsigned char *asmptr;\n\tstruct sk_buff *skb;\n\tint n, er, qbit;\n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\treturn -ENOTCONN;\n\tif ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL)\n\t\treturn er;\n\tqbit = (skb->data[0] & ROSE_Q_BIT) == ROSE_Q_BIT;\n\tskb_pull(skb, ROSE_MIN_LEN);\n\tif (rose->qbitincl) {\n\t\tasmptr  = skb_push(skb, 1);\n\t\t*asmptr = qbit;\n\t}\n\tskb_reset_transport_header(skb);\n\tcopied     = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_rose *srose;\n\t\tmemset(msg->msg_name, 0, sizeof(struct full_sockaddr_rose));\n\t\tsrose = msg->msg_name;\n\t\tsrose->srose_family = AF_ROSE;\n\t\tsrose->srose_addr   = rose->dest_addr;\n\t\tsrose->srose_call   = rose->dest_call;\n\t\tsrose->srose_ndigis = rose->dest_ndigis;\n\t\tif (msg->msg_namelen >= sizeof(struct full_sockaddr_rose)) {\n\t\t\tstruct full_sockaddr_rose *full_srose = (struct full_sockaddr_rose *)msg->msg_name;\n\t\t\tfor (n = 0 ; n < rose->dest_ndigis ; n++)\n\t\t\t\tfull_srose->srose_digis[n] = rose->dest_digis[n];\n\t\t\tmsg->msg_namelen = sizeof(struct full_sockaddr_rose);\n\t\t} else {\n\t\t\tif (rose->dest_ndigis >= 1) {\n\t\t\t\tsrose->srose_ndigis = 1;\n\t\t\t\tsrose->srose_digi = rose->dest_digis[0];\n\t\t\t}\n\t\t\tmsg->msg_namelen = sizeof(struct sockaddr_rose);\n\t\t}\n\t}\n\tskb_free_datagram(sk, skb);\n\treturn copied;\n}", "target": 0}
{"code": "static int skcipher_recvmsg(struct kiocb *unused, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t ignored, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tunsigned bs = crypto_ablkcipher_blocksize(crypto_ablkcipher_reqtfm(\n\t\t&ctx->req));\n\tstruct skcipher_sg_list *sgl;\n\tstruct scatterlist *sg;\n\tint err = -EAGAIN;\n\tint used;\n\tlong copied = 0;\n\tlock_sock(sk);\n\twhile (iov_iter_count(&msg->msg_iter)) {\n\t\tsgl = list_first_entry(&ctx->tsgl,\n\t\t\t\t       struct skcipher_sg_list, list);\n\t\tsg = sgl->sg;\n\t\twhile (!sg->length)\n\t\t\tsg++;\n\t\tused = ctx->used;\n\t\tif (!used) {\n\t\t\terr = skcipher_wait_for_data(sk, flags);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\t\t}\n\t\tused = min_t(unsigned long, used, iov_iter_count(&msg->msg_iter));\n\t\tused = af_alg_make_sg(&ctx->rsgl, &msg->msg_iter, used);\n\t\terr = used;\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\t\tif (ctx->more || used < ctx->used)\n\t\t\tused -= used % bs;\n\t\terr = -EINVAL;\n\t\tif (!used)\n\t\t\tgoto free;\n\t\tablkcipher_request_set_crypt(&ctx->req, sg,\n\t\t\t\t\t     ctx->rsgl.sg, used,\n\t\t\t\t\t     ctx->iv);\n\t\terr = af_alg_wait_for_completion(\n\t\t\t\tctx->enc ?\n\t\t\t\t\tcrypto_ablkcipher_encrypt(&ctx->req) :\n\t\t\t\t\tcrypto_ablkcipher_decrypt(&ctx->req),\n\t\t\t\t&ctx->completion);\nfree:\n\t\taf_alg_free_sg(&ctx->rsgl);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t\tcopied += used;\n\t\tskcipher_pull_sgl(sk, used);\n\t\tiov_iter_advance(&msg->msg_iter, used);\n\t}\n\terr = 0;\nunlock:\n\tskcipher_wmem_wakeup(sk);\n\trelease_sock(sk);\n\treturn copied ?: err;\n}", "target": 1}
{"code": "static int opl3_load_patch(int dev, int format, const char __user *addr,\n\t\tint offs, int count, int pmgr_flag)\n{\n\tstruct sbi_instrument ins;\n\tif (count <sizeof(ins))\n\t{\n\t\tprintk(KERN_WARNING \"FM Error: Patch record too short\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif(copy_from_user(&((char *) &ins)[offs], addr + offs, sizeof(ins) - offs))\n\t\treturn -EFAULT;\n\tif (ins.channel < 0 || ins.channel >= SBFM_MAXINSTR)\n\t{\n\t\tprintk(KERN_WARNING \"FM Error: Invalid instrument number %d\\n\", ins.channel);\n\t\treturn -EINVAL;\n\t}\n\tins.key = format;\n\treturn store_instr(ins.channel, &ins);\n}", "target": 1}
{"code": "static int64_t adjust_scale(int64_t scale) {\n  if (scale < 0) {\n    scale = BCG(bc_precision);\n    if (scale < 0) scale = 0;\n  }\n  if ((uint64_t)scale > StringData::MaxSize) return StringData::MaxSize;\n  return scale;\n}", "target": 0}
{"code": "static void lwp_read_int32(FILE *fin, int32_t &d) {\n  fread(&d, sizeof(d), 1, fin);\n}", "target": 0}
{"code": "parse_range(char *str, size_t file_sz, int *nranges)\n{\n\tstatic struct range\t ranges[MAX_RANGES];\n\tint\t\t\t i = 0;\n\tchar\t\t\t*p, *q;\n\tif ((p = strchr(str, '=')) == NULL)\n\t\treturn (NULL);\n\t*p++ = '\\0';\n\tif (strcmp(str, \"bytes\") != 0)\n\t\treturn (NULL);\n\twhile ((q = strchr(p, ',')) != NULL) {\n\t\t*q++ = '\\0';\n\t\tif (parse_range_spec(p, file_sz, &ranges[i]) == 0)\n\t\t\tcontinue;\n\t\ti++;\n\t\tif (i == MAX_RANGES)\n\t\t\treturn (NULL);\n\t\tp = q;\n\t}\n\tif (parse_range_spec(p, file_sz, &ranges[i]) != 0)\n\t\ti++;\n\t*nranges = i;\n\treturn (i ? ranges : NULL);\n}", "target": 1}
{"code": "struct expr_parse_ctx *expr__ctx_new(void)\n{\n\tstruct expr_parse_ctx *ctx;\n\tctx = malloc(sizeof(struct expr_parse_ctx));\n\tif (!ctx)\n\t\treturn NULL;\n\tctx->ids = hashmap__new(key_hash, key_equal, NULL);\n\tif (IS_ERR(ctx->ids)) {\n\t\tfree(ctx);\n\t\treturn NULL;\n\t}\n\tctx->runtime = 0;\n\treturn ctx;\n}", "target": 0}
{"code": "static void addFrames(EctEnhancedCT *ct)\n{\n    if (!ct)\n        return;\n    FGFrameContent *fg = new FGFrameContent();\n    fg->setStackID(\"1\");\n    OFCHECK(fg);\n    if (fg)\n    {\n        EctEnhancedCT::FramesType frames = ct->getFrames();\n        for (Uint16 frameNo = 1; frameNo <= NUM_FRAMES; frameNo++)\n        {\n            OFCHECK(fg->setFrameAcquisitionNumber(frameNo).good());\n            OFCHECK(fg->setFrameReferenceDateTime(\"20190816092557\").good());\n            OFCHECK(fg->setFrameAcquisitionDateTime(\"20190816092557\").good());\n            OFCHECK(fg->setFrameAcquisitionDuration(0.001).good());\n            OFCHECK(fg->setInStackPositionNumber(frameNo).good());\n            OFCHECK(fg->setDimensionIndexValues(1, 0).good());\n            OFCHECK(fg->setDimensionIndexValues(frameNo, 1).good());\n            OFVector<FGBase *> groups;\n            groups.push_back(fg);\n            Uint16 *data = new Uint16[NUM_PIXELS_PER_FRAME];\n            for (size_t i = 0; i < NUM_PIXELS_PER_FRAME; ++i)\n            {\n                data[i] = 0x4141;\n            }\n            OFCHECK(\n                OFget<EctEnhancedCT::Frames<Uint16>>(&frames)->addFrame(data, NUM_PIXELS_PER_FRAME, groups).good());\n            delete[] data;\n        }\n    }\n    delete fg;\n}", "target": 0}
{"code": "base::string16 Browser::GetWindowTitleForTab(bool include_app_name,\n                                             int index) const {\n  return GetWindowTitleFromWebContents(\n      include_app_name, tab_strip_model_->GetWebContentsAt(index));\n}", "target": 0}
{"code": "SHA256_Pad(struct SHA256_CTX * ctx)\n{\n  unsigned char len[8];\n  uint32_t r, plen;\n  be32enc_vect(len, ctx->count, 8);\n  r = (ctx->count[1] >> 3) & 0x3f;\n  plen = (r < 56) ? (56 - r) : (120 - r);\n  scrypt_SHA256_Update(ctx, PAD, (size_t)plen);\n  scrypt_SHA256_Update(ctx, len, 8);\n}", "target": 1}
{"code": "int install_user_keyrings(void)\n{\n\tstruct user_struct *user;\n\tconst struct cred *cred;\n\tstruct key *uid_keyring, *session_keyring;\n\tkey_perm_t user_keyring_perm;\n\tchar buf[20];\n\tint ret;\n\tuid_t uid;\n\tuser_keyring_perm = (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_ALL;\n\tcred = current_cred();\n\tuser = cred->user;\n\tuid = from_kuid(cred->user_ns, user->uid);\n\tkenter(\"%p{%u}\", user, uid);\n\tif (user->uid_keyring) {\n\t\tkleave(\" = 0 [exist]\");\n\t\treturn 0;\n\t}\n\tmutex_lock(&key_user_keyring_mutex);\n\tret = 0;\n\tif (!user->uid_keyring) {\n\t\tsprintf(buf, \"_uid.%u\", uid);\n\t\tuid_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(uid_keyring)) {\n\t\t\tuid_keyring = keyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t\t    cred, user_keyring_perm,\n\t\t\t\t\t\t    KEY_ALLOC_IN_QUOTA, NULL);\n\t\t\tif (IS_ERR(uid_keyring)) {\n\t\t\t\tret = PTR_ERR(uid_keyring);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tsprintf(buf, \"_uid_ses.%u\", uid);\n\t\tsession_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(session_keyring)) {\n\t\t\tsession_keyring =\n\t\t\t\tkeyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t      cred, user_keyring_perm,\n\t\t\t\t\t      KEY_ALLOC_IN_QUOTA, NULL);\n\t\t\tif (IS_ERR(session_keyring)) {\n\t\t\t\tret = PTR_ERR(session_keyring);\n\t\t\t\tgoto error_release;\n\t\t\t}\n\t\t\tret = key_link(session_keyring, uid_keyring);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_release_both;\n\t\t}\n\t\tuser->uid_keyring = uid_keyring;\n\t\tuser->session_keyring = session_keyring;\n\t}\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = 0\");\n\treturn 0;\nerror_release_both:\n\tkey_put(session_keyring);\nerror_release:\n\tkey_put(uid_keyring);\nerror:\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}", "target": 1}
{"code": "krb5_ldap_get_password_policy_from_dn(krb5_context context, char *pol_name,\n                                      char *pol_dn, osa_policy_ent_t *policy)\n{\n    krb5_error_code             st=0, tempst=0;\n    LDAP                        *ld=NULL;\n    LDAPMessage                 *result=NULL,*ent=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n    krb5_clear_error_message(context);\n    if (pol_dn == NULL)\n        return EINVAL;\n    *policy = NULL;\n    SETUP_CONTEXT();\n    GET_HANDLE();\n    *(policy) = (osa_policy_ent_t) malloc(sizeof(osa_policy_ent_rec));\n    if (*policy == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n    memset(*policy, 0, sizeof(osa_policy_ent_rec));\n    LDAP_SEARCH(pol_dn, LDAP_SCOPE_BASE, \"(objectclass=krbPwdPolicy)\", password_policy_attributes);\n    ent=ldap_first_entry(ld, result);\n    if (ent != NULL) {\n        if ((st = populate_policy(context, ld, ent, pol_name, *policy)) != 0)\n            goto cleanup;\n    }\ncleanup:\n    ldap_msgfree(result);\n    if (st != 0) {\n        if (*policy != NULL) {\n            krb5_ldap_free_password_policy(context, *policy);\n            *policy = NULL;\n        }\n    }\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    return st;\n}", "target": 1}
{"code": "countAllSwitchActions (union SWF_ACTION *actions, union SWF_ACTION *pre)\n{\n\tint i,j=1;\n\tif (actions->SWF_ACTIONRECORD.ActionCode==SWFACTION_IF && pre->SWF_ACTIONRECORD.ActionCode==SWFACTION_STRICTEQUALS )\n\t{\n\t\tfor(i=0; i < ((struct SWF_ACTIONIF*)actions)->numActions; i++)\n\t\t{\n\t\t\tj+=countAllSwitchActions(&((struct SWF_ACTIONIF*)actions)->Actions[i],pre);\n\t\t\tpre=&((struct SWF_ACTIONIF*)actions)->Actions[i];\n\t\t}\n\t}                  \n\treturn j;\n}", "target": 0}
{"code": "pci_lintr_route(struct pci_vdev *dev)\n{\n\tstruct businfo *bi;\n\tstruct intxinfo *ii;\n\tif (dev->lintr.pin == 0)\n\t\treturn;\n\tbi = pci_businfo[dev->bus];\n\tassert(bi != NULL);\n\tii = &bi->slotinfo[dev->slot].si_intpins[dev->lintr.pin - 1];\n\tif (ii->ii_ioapic_irq == 0)\n\t\tii->ii_ioapic_irq = ioapic_pci_alloc_irq(dev);\n\tassert(ii->ii_ioapic_irq > 0);\n\tif (ii->ii_pirq_pin == 0)\n\t\tii->ii_pirq_pin = pirq_alloc_pin(dev);\n\tassert(ii->ii_pirq_pin > 0);\n\tdev->lintr.ioapic_irq = ii->ii_ioapic_irq;\n\tdev->lintr.pirq_pin = ii->ii_pirq_pin;\n\tpci_set_cfgdata8(dev, PCIR_INTLINE, pirq_irq(ii->ii_pirq_pin));\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& grad_in = context->input(1);\n    const Tensor& argmax = context->input(2);\n    PoolParameters params{context,\n                          ksize_,\n                          stride_,\n                          padding_,\n                          {},\n                          FORMAT_NHWC,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n    OP_REQUIRES(context, grad_in.shape() == params.forward_output_shape(),\n                errors::InvalidArgument(\"Expected grad shape to be \",\n                                        params.forward_output_shape(),\n                                        \", but got \", grad_in.shape()));\n    OP_REQUIRES(context, argmax.shape() == params.forward_output_shape(),\n                errors::InvalidArgument(\"Expected argmax shape to be \",\n                                        params.forward_output_shape(),\n                                        \", but got \", argmax.shape()));\n    TensorShape out_shape({params.tensor_in_batch, params.tensor_in_rows,\n                           params.tensor_in_cols, params.depth});\n    Tensor* grad_out = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {0}, 0, out_shape, &grad_out));\n    if (out_shape.num_elements() == 0) return;  \n    LaunchMaxPoolingGradWithArgmax<Device, T>::launch(\n        context, params, grad_in, argmax, grad_out, include_batch_in_index_);\n  }", "target": 0}
{"code": "void Item_direct_view_ref::update_used_tables()\n{\n  set_null_ref_table();\n  Item_direct_ref::update_used_tables();\n}", "target": 0}
{"code": "static int hwsim_new_radio_nl(struct sk_buff *msg, struct genl_info *info)\n{\n\tstruct hwsim_new_radio_params param = { 0 };\n\tconst char *hwname = NULL;\n\tint ret;\n\tparam.reg_strict = info->attrs[HWSIM_ATTR_REG_STRICT_REG];\n\tparam.p2p_device = info->attrs[HWSIM_ATTR_SUPPORT_P2P_DEVICE];\n\tparam.channels = channels;\n\tparam.destroy_on_close =\n\t\tinfo->attrs[HWSIM_ATTR_DESTROY_RADIO_ON_CLOSE];\n\tif (info->attrs[HWSIM_ATTR_CHANNELS])\n\t\tparam.channels = nla_get_u32(info->attrs[HWSIM_ATTR_CHANNELS]);\n\tif (info->attrs[HWSIM_ATTR_NO_VIF])\n\t\tparam.no_vif = true;\n\tif (info->attrs[HWSIM_ATTR_RADIO_NAME]) {\n\t\thwname = kasprintf(GFP_KERNEL, \"%.*s\",\n\t\t\t\t   nla_len(info->attrs[HWSIM_ATTR_RADIO_NAME]),\n\t\t\t\t   (char *)nla_data(info->attrs[HWSIM_ATTR_RADIO_NAME]));\n\t\tif (!hwname)\n\t\t\treturn -ENOMEM;\n\t\tparam.hwname = hwname;\n\t}\n\tif (info->attrs[HWSIM_ATTR_USE_CHANCTX])\n\t\tparam.use_chanctx = true;\n\telse\n\t\tparam.use_chanctx = (param.channels > 1);\n\tif (info->attrs[HWSIM_ATTR_REG_HINT_ALPHA2])\n\t\tparam.reg_alpha2 =\n\t\t\tnla_data(info->attrs[HWSIM_ATTR_REG_HINT_ALPHA2]);\n\tif (info->attrs[HWSIM_ATTR_REG_CUSTOM_REG]) {\n\t\tu32 idx = nla_get_u32(info->attrs[HWSIM_ATTR_REG_CUSTOM_REG]);\n\t\tif (idx >= ARRAY_SIZE(hwsim_world_regdom_custom))\n\t\t\treturn -EINVAL;\n\t\tparam.regd = hwsim_world_regdom_custom[idx];\n\t}\n\tret = mac80211_hwsim_new_radio(info, &param);\n\tkfree(hwname);\n\treturn ret;\n}", "target": 1}
{"code": "void test_bind(const char *path)\n{\n\tint sfd;\n\tstruct sockaddr_un my_addr, peer_addr;\n\tsfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif (sfd < 0) {\n\t\tfprintf(stderr, \"Failed to open a socket for bind test\\n\");\n\t\texit(1);\n\t}\n\tmemset(&my_addr, 0, sizeof(struct sockaddr_un));\n\tmy_addr.sun_family = AF_UNIX;\n\tstrncpy(my_addr.sun_path, path,\n\t\t\tsizeof(my_addr.sun_path) - 1);\n\tif (bind(sfd, (struct sockaddr *) &my_addr,\n\t\t\t\tsizeof(struct sockaddr_un)) != -1) {\n\t\tfprintf(stderr, \"leak at bind of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at bind of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n\tclose(sfd);\n}", "target": 0}
{"code": "R_API char *r_socket_http_post (const char *url, const char *data, int *code, int *rlen) {\n\tRSocket *s;\n\tbool ssl = r_str_startswith (url, \"https:\n\tchar *uri = strdup (url);\n\tif (!uri) {\n\t\treturn NULL;\n\t}\n\tchar *host = strstr (uri, \":\n\tif (!host) {\n\t\tfree (uri);\n\t\tprintf (\"Invalid URI\");\n\t\treturn NULL;\n\t}\n\thost += 3;\n\tchar *port = strchr (host, ':');\n\tif (!port) {\n\t\tport = (ssl)? \"443\": \"80\";\n\t} else {\n\t\t*port++ = 0;\n\t}\n\tchar *path = strchr (host, '/');\n\tif (!path) {\n\t\tpath = \"\";\n\t} else {\n\t\t*path++ = 0;\n\t}\n\ts = r_socket_new (ssl);\n\tif (!s) {\n\t\tprintf (\"Cannot create socket\\n\");\n\t\tfree (uri);\n\t\treturn NULL;\n\t}\n\tif (!r_socket_connect_tcp (s, host, port, 0)) {\n\t\teprintf (\"Cannot connect to %s:%s\\n\", host, port);\n\t\tfree (uri);\n\t\treturn NULL;\n\t}\n\tr_socket_printf (s,\n\t\t\t\"POST /%s HTTP/1.0\\r\\n\"\n\t\t\t\"User-Agent: radare2 \"R2_VERSION\"\\r\\n\"\n\t\t\t\"Accept: *", "target": 1}
{"code": "static int spl_object_storage_compare_info(spl_SplObjectStorageElement *e1, spl_SplObjectStorageElement *e2 TSRMLS_DC) \n{\n\tzval result;\n\tif (compare_function(&result, e1->inf, e2->inf TSRMLS_CC) == FAILURE) {\n\t\treturn 1;\n\t}\n\treturn Z_LVAL(result);\n}", "target": 0}
{"code": "static std::string PatchPattern(const std::string& pattern) {\n  const std::string fixed_prefix =\n      pattern.substr(0, pattern.find_first_of(kGlobbingChars));\n  if (io::Dirname(fixed_prefix).empty()) {\n    return io::JoinPath(\".\", pattern);\n  }\n  return pattern;\n}", "target": 0}
{"code": "void LIRGenerator::do_NegateOp(NegateOp* x) {\n  LIRItem value(x->x(), this);\n  value.set_destroys_register();\n  value.load_item();\n  LIR_Opr reg = rlock(x);\n  LIR_Opr tmp = LIR_OprFact::illegalOpr;\n#ifdef _LP64\n  if (UseAVX > 2 && !VM_Version::supports_avx512vl()) {\n    if (x->type()->tag() == doubleTag) {\n      tmp = new_register(T_DOUBLE);\n      __ move(LIR_OprFact::doubleConst(-0.0), tmp);\n    }\n    else if (x->type()->tag() == floatTag) {\n      tmp = new_register(T_FLOAT);\n      __ move(LIR_OprFact::floatConst(-0.0), tmp);\n    }\n  }\n#endif\n  __ negate(value.result(), reg, tmp);\n  set_result(x, round_item(reg));\n}", "target": 0}
{"code": "QPDF::read_xref(qpdf_offset_t xref_offset)\n{\n    std::map<int, int> free_table;\n    std::set<qpdf_offset_t> visited;\n    while (xref_offset)\n    {\n        visited.insert(xref_offset);\n        char buf[7];\n        memset(buf, 0, sizeof(buf));\n\tthis->m->file->seek(xref_offset, SEEK_SET);\n\tthis->m->file->read(buf, sizeof(buf) - 1);\n        if ((strncmp(buf, \"xref\", 4) == 0) &&\n            QUtil::is_space(buf[4]))\n\t{\n            QTC::TC(\"qpdf\", \"QPDF xref space\",\n                    ((buf[4] == '\\n') ? 0 :\n                     (buf[4] == '\\r') ? 1 :\n                     (buf[4] == ' ') ? 2 : 9999));\n            int skip = 4;\n            while (QUtil::is_space(buf[skip]))\n            {\n                ++skip;\n            }\n            xref_offset = read_xrefTable(xref_offset + skip);\n\t}\n\telse\n\t{\n\t    xref_offset = read_xrefStream(xref_offset);\n\t}\n        if (visited.count(xref_offset) != 0)\n        {\n            xref_offset = 0;\n        }\n    }\n    if (! this->m->trailer.isInitialized())\n    {\n        throw QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(), \"\", 0,\n                      \"unable to find trailer while reading xref\");\n    }\n    int size = this->m->trailer.getKey(\"/Size\").getIntValue();\n    int max_obj = 0;\n    if (! this->m->xref_table.empty())\n    {\n\tmax_obj = (*(this->m->xref_table.rbegin())).first.getObj();\n    }\n    if (! this->m->deleted_objects.empty())\n    {\n\tmax_obj = std::max(max_obj, *(this->m->deleted_objects.rbegin()));\n    }\n    if (size != max_obj + 1)\n    {\n\tQTC::TC(\"qpdf\", \"QPDF xref size mismatch\");\n\twarn(QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(), \"\", 0,\n\t\t     std::string(\"reported number of objects (\") +\n\t\t     QUtil::int_to_string(size) +\n\t\t     \") inconsistent with actual number of objects (\" +\n\t\t     QUtil::int_to_string(max_obj + 1) + \")\"));\n    }\n    this->m->deleted_objects.clear();\n}", "target": 0}
{"code": "static int selinux_task_setnice(struct task_struct *p, int nice)\n{\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    current_sid(), task_sid(p), SECCLASS_PROCESS,\n\t\t\t    PROCESS__SETSCHED, NULL);\n}", "target": 0}
{"code": "std::shared_ptr<SQLiteDBInstance> getTestDBC() {\n  auto dbc = SQLiteDBManager::getUnique();\n  char* err = nullptr;\n  std::vector<std::string> queries = {\n      \"CREATE TABLE test_table (username varchar(30) primary key, age int)\",\n      \"INSERT INTO test_table VALUES (\\\"mike\\\", 23)\",\n      \"INSERT INTO test_table VALUES (\\\"matt\\\", 24)\"};\n  for (auto q : queries) {\n    sqlite3_exec(dbc->db(), q.c_str(), nullptr, nullptr, &err);\n    if (err != nullptr) {\n      throw std::domain_error(std::string(\"Cannot create testing DBC's db: \") +\n                              err);\n    }\n  }\n  return dbc;\n}", "target": 1}
{"code": "static int js_doregexec(js_State *J, Reprog *prog, const char *string, Resub *sub, int eflags)\n{\n\tint result = js_regexec(prog, string, sub, eflags);\n\tif (result < 0)\n\t\tjs_error(J, \"regexec failed\");\n\treturn result;\n}", "target": 0}
{"code": "ut64 MACH0_(get_main)(struct MACH0_(obj_t)* bin) {\n\tut64 addr = 0LL;\n\tstruct symbol_t *symbols;\n\tint i;\n\tif (!(symbols = MACH0_(get_symbols) (bin))) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; !symbols[i].last; i++) {\n\t\tif (!strcmp (symbols[i].name, \"_main\")) {\n\t\t\taddr = symbols[i].addr;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree (symbols);\n\tif (!addr && bin->main_cmd.cmd == LC_MAIN) {\n\t\taddr = bin->entry + bin->baddr;\n\t}\n\tif (!addr) {\n\t\tut8 b[128];\n\t\tut64 entry = addr_to_offset(bin, bin->entry);\n\t\tif (entry > bin->size || entry + sizeof (b) > bin->size)\n\t\t\treturn 0;\n\t\ti = r_buf_read_at (bin->b, entry, b, sizeof (b));\n\t\tif (i < 1) {\n\t\t\treturn 0;\n\t\t}\n\t\tfor (i = 0; i < 64; i++) {\n\t\t\tif (b[i] == 0xe8 && !b[i+3] && !b[i+4]) {\n\t\t\t\tint delta = b[i+1] | (b[i+2] << 8) | (b[i+3] << 16) | (b[i+4] << 24);\n\t\t\t\treturn bin->entry + i + 5 + delta;\n\t\t\t}\n\t\t}\n\t}\n\treturn addr;\n}", "target": 1}
{"code": "MODULE_ENTRY (fill_info) (GdkPixbufFormat *info)\n{\n\tstatic const GdkPixbufModulePattern signature[] = {\n\t\t{ \"  \\x1   \", \"zz znz\", 100 }, \n\t\t{ \"  \\x2   \", \"zz znz\", 100 },\n\t\t{ NULL, NULL, 0 }\n\t};\n\tstatic const gchar *mime_types[] = {\n\t\t\"image/x-icon\",\n\t\t\"image/x-ico\",\n\t\t\"image/x-win-bitmap\",\n                \"image/vnd.microsoft.icon\",\n                \"application/ico\",\n                \"image/ico\",\n                \"image/icon\",\n                \"text/ico\",\n\t\tNULL\n\t};\n\tstatic const gchar *extensions[] = {\n\t\t\"ico\",\n\t\t\"cur\",\n\t\tNULL\n\t};\n\tinfo->name = \"ico\";\n\tinfo->signature = (GdkPixbufModulePattern *) signature;\n\tinfo->description = NC_(\"image format\", \"Windows icon\");\n\tinfo->mime_types = (gchar **) mime_types;\n\tinfo->extensions = (gchar **) extensions;\n\tinfo->flags = GDK_PIXBUF_FORMAT_WRITABLE | GDK_PIXBUF_FORMAT_THREADSAFE;\n\tinfo->license = \"LGPL\";\n}", "target": 0}
{"code": "callbacks_screen2board(gdouble *X, gdouble *Y, gint x, gint y) {\n\tif ((screenRenderInfo.scaleFactorX > 0.001)||(screenRenderInfo.scaleFactorY > 0.001)) {\n\t\t*X = screenRenderInfo.lowerLeftX + (x / screenRenderInfo.scaleFactorX);\n\t\t*Y = screenRenderInfo.lowerLeftY + ((screenRenderInfo.displayHeight - y)\n\t\t\t/ screenRenderInfo.scaleFactorY);\n\t}\n\telse {\n\t\t*X = *Y = 0.0;\n\t}\n}", "target": 0}
{"code": "test_save_copy (const char *origname)\n{\n  char buf[TESTBUFSIZE];\n  int ret;\n  snprintf_func (buf, TESTBUFSIZE, \"cp -f %s %s\", origname, TEST_COPY_FILE);\n  if ((ret = system (buf)) != 0)\n    {\n      return XD3_INTERNAL;\n    }\n  return 0;\n}", "target": 1}
{"code": "__ext4_set_acl(handle_t *handle, struct inode *inode, int type,\n\t     struct posix_acl *acl)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\telse {\n\t\t\t\tinode->i_ctime = ext4_current_time(inode);\n\t\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t\t\tif (error == 0)\n\t\t\t\t\tacl = NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tvalue = ext4_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\terror = ext4_xattr_set_handle(handle, inode, name_index, \"\",\n\t\t\t\t      value, size, 0);\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}", "target": 1}
{"code": "void CommandData::ProcessCommand()\n{\n#ifndef SFX_MODULE\n  const wchar *SingleCharCommands=L\"FUADPXETK\";\n  if (Command[0]!=0 && Command[1]!=0 && wcschr(SingleCharCommands,Command[0])!=NULL || *ArcName==0)\n    OutHelp(*Command==0 ? RARX_SUCCESS:RARX_USERERROR); \n  const wchar *ArcExt=GetExt(ArcName);\n#ifdef _UNIX\n  if (ArcExt==NULL && (!FileExist(ArcName) || IsDir(GetFileAttr(ArcName))))\n    wcsncatz(ArcName,L\".rar\",ASIZE(ArcName));\n#else\n  if (ArcExt==NULL)\n    wcsncatz(ArcName,L\".rar\",ASIZE(ArcName));\n#endif\n  if (ArcExt!=NULL && wcsnicomp(ArcExt,L\".part\",5)==0 && IsDigit(ArcExt[5]) &&\n      !FileExist(ArcName))\n  {\n    wchar Name[NM];\n    wcsncpyz(Name,ArcName,ASIZE(Name));\n    wcsncatz(Name,L\".rar\",ASIZE(Name));\n    if (FileExist(Name))\n      wcsncpyz(ArcName,Name,ASIZE(ArcName));\n  }\n  if (wcschr(L\"AFUMD\",*Command)==NULL)\n  {\n    if (GenerateArcName)\n      GenerateArchiveName(ArcName,ASIZE(ArcName),GenerateMask,false);\n    StringList ArcMasks;\n    ArcMasks.AddString(ArcName);\n    ScanTree Scan(&ArcMasks,Recurse,SaveSymLinks,SCAN_SKIPDIRS);\n    FindData FindData;\n    while (Scan.GetNext(&FindData)==SCAN_SUCCESS)\n      AddArcName(FindData.Name);\n  }\n  else\n    AddArcName(ArcName);\n#endif\n  switch(Command[0])\n  {\n    case 'P':\n    case 'X':\n    case 'E':\n    case 'T':\n    case 'I':\n      {\n        CmdExtract Extract(this);\n        Extract.DoExtract();\n      }\n      break;\n#ifndef SILENT\n    case 'V':\n    case 'L':\n      ListArchive(this);\n      break;\n    default:\n      OutHelp(RARX_USERERROR);\n#endif\n  }\n  if (!BareOutput)\n    mprintf(L\"\\n\");\n}", "target": 1}
{"code": "struct nfs_open_context *nfs_find_open_context(struct inode *inode, struct rpc_cred *cred, int mode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_open_context *pos, *ctx = NULL;\n\tspin_lock(&inode->i_lock);\n\tlist_for_each_entry(pos, &nfsi->open_files, list) {\n\t\tif (cred != NULL && pos->cred != cred)\n\t\t\tcontinue;\n\t\tif ((pos->mode & mode) == mode) {\n\t\t\tctx = get_nfs_open_context(pos);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn ctx;\n}", "target": 1}
{"code": "static void kvm_steal_time_set_preempted(struct kvm_vcpu *vcpu)\n{\n\tstruct gfn_to_hva_cache *ghc = &vcpu->arch.st.cache;\n\tstruct kvm_steal_time __user *st;\n\tstruct kvm_memslots *slots;\n\tstatic const u8 preempted = KVM_VCPU_PREEMPTED;\n\tif (!vcpu->arch.at_instruction_boundary) {\n\t\tvcpu->stat.preemption_other++;\n\t\treturn;\n\t}\n\tvcpu->stat.preemption_reported++;\n\tif (!(vcpu->arch.st.msr_val & KVM_MSR_ENABLED))\n\t\treturn;\n\tif (vcpu->arch.st.preempted)\n\t\treturn;\n\tif (unlikely(current->mm != vcpu->kvm->mm))\n\t\treturn;\n\tslots = kvm_memslots(vcpu->kvm);\n\tif (unlikely(slots->generation != ghc->generation ||\n\t\t     kvm_is_error_hva(ghc->hva) || !ghc->memslot))\n\t\treturn;\n\tst = (struct kvm_steal_time __user *)ghc->hva;\n\tBUILD_BUG_ON(sizeof(st->preempted) != sizeof(preempted));\n\tif (!copy_to_user_nofault(&st->preempted, &preempted, sizeof(preempted)))\n\t\tvcpu->arch.st.preempted = KVM_VCPU_PREEMPTED;\n\tmark_page_dirty_in_slot(vcpu->kvm, ghc->memslot, gpa_to_gfn(ghc->gpa));\n}", "target": 0}
{"code": "static int ipv4ll_recv_arp_packet(GDHCPClient *dhcp_client)\n{\n\tint bytes;\n\tstruct ether_arp arp;\n\tuint32_t ip_requested;\n\tint source_conflict;\n\tint target_conflict;\n\tguint timeout_ms;\n\tmemset(&arp, 0, sizeof(arp));\n\tbytes = read(dhcp_client->listener_sockfd, &arp, sizeof(arp));\n\tif (bytes < 0)\n\t\treturn bytes;\n\tif (arp.arp_op != htons(ARPOP_REPLY) &&\n\t\t\tarp.arp_op != htons(ARPOP_REQUEST))\n\t\treturn -EINVAL;\n\tif (memcmp(arp.arp_sha, dhcp_client->mac_address, ETH_ALEN) == 0)\n\t\treturn 0;\n\tip_requested = htonl(dhcp_client->requested_ip);\n\tsource_conflict = !memcmp(arp.arp_spa, &ip_requested,\n\t\t\t\t\t\tsizeof(ip_requested));\n\ttarget_conflict = !memcmp(arp.arp_tpa, &ip_requested,\n\t\t\t\tsizeof(ip_requested));\n\tif (!source_conflict && !target_conflict)\n\t\treturn 0;\n\tdhcp_client->conflicts++;\n\tdebug(dhcp_client, \"IPV4LL conflict detected\");\n\tif (dhcp_client->state == IPV4LL_MONITOR) {\n\t\tif (!source_conflict)\n\t\t\treturn 0;\n\t\tdhcp_client->state = IPV4LL_DEFEND;\n\t\tdebug(dhcp_client, \"DEFEND mode conflicts : %d\",\n\t\t\tdhcp_client->conflicts);\n\t\tsend_announce_packet(dhcp_client);\n\t\treturn 0;\n\t}\n\tif (dhcp_client->state == IPV4LL_DEFEND) {\n\t\tif (!source_conflict)\n\t\t\treturn 0;\n\t\telse if (dhcp_client->ipv4ll_lost_cb)\n\t\t\tdhcp_client->ipv4ll_lost_cb(dhcp_client,\n\t\t\t\t\t\tdhcp_client->ipv4ll_lost_data);\n\t}\n\tipv4ll_stop(dhcp_client);\n\tif (dhcp_client->conflicts < MAX_CONFLICTS)\n\t\ttimeout_ms = __connman_util_random_delay_ms(PROBE_WAIT);\n\telse\n\t\ttimeout_ms = RATE_LIMIT_INTERVAL * 1000;\n\tdhcp_client->retry_times++;\n\tdhcp_client->timeout =\n\t\tg_timeout_add_full(G_PRIORITY_HIGH,\n\t\t\t\ttimeout_ms,\n\t\t\t\tsend_probe_packet,\n\t\t\t\tdhcp_client,\n\t\t\t\tNULL);\n\treturn 0;\n}", "target": 0}
{"code": "parse_string(xmlTextReaderPtr reader, char const *attr, char **result)\n{\n\txmlChar *xml_value;\n\tchar *tmp;\n\tif (attr == NULL)\n\t\txml_value = xmlTextReaderValue(reader);\n\telse\n\t\txml_value = xmlTextReaderGetAttribute(reader, BAD_CAST attr);\n\tif (xml_value == NULL)\n\t\treturn pr_val_err(\"RRDP file: Couldn't find %s from '%s'\",\n\t\t    (attr == NULL ? \"string content\" : \"xml attribute\"),\n\t\t    xmlTextReaderConstLocalName(reader));\n\ttmp = malloc(xmlStrlen(xml_value) + 1);\n\tif (tmp == NULL) {\n\t\txmlFree(xml_value);\n\t\treturn pr_enomem();\n\t}\n\tmemcpy(tmp, xml_value, xmlStrlen(xml_value));\n\ttmp[xmlStrlen(xml_value)] = '\\0';\n\txmlFree(xml_value);\n\t*result = tmp;\n\treturn 0;\n}", "target": 1}
{"code": "bool CephXAuthorizer::add_challenge(CephContext *cct, bufferlist& challenge)\n{\n  bl = base_bl;\n  CephXAuthorize msg;\n  msg.nonce = nonce;\n  auto p = challenge.begin();\n  if (!p.end()) {\n    std::string error;\n    CephXAuthorizeChallenge ch;\n    decode_decrypt_enc_bl(cct, ch, session_key, challenge, error);\n    if (!error.empty()) {\n      ldout(cct, 0) << \"failed to decrypt challenge (\" << challenge.length() << \" bytes): \"\n\t\t    << error << dendl;\n      return false;\n    }\n    msg.have_challenge = true;\n    msg.server_challenge_plus_one = ch.server_challenge + 1;\n  }\n  std::string error;\n  if (encode_encrypt(cct, msg, session_key, bl, error)) {\n    ldout(cct, 0) << __func__ << \" failed to encrypt authorizer: \" << error << dendl;\n    return false;\n  }\n  return true;\n}", "target": 0}
{"code": "int delete_sdp_line( struct sip_msg * msg, char * s)\n{\n\tchar * start,*end;\n\tif( !s )\n\t\treturn 1;\n\tstart = s;\n\tend  = s;\n\twhile(*start != '\\n')\n\t\tstart--;\n\tstart++;\n\twhile(*end != '\\n')\n\t\tend++;\n\tend++;\n\tif( del_lump(msg, start - msg->buf, end - start,0) == NULL )\n\t{\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "parse_user_name(char *user_input, char **ret_username)\n{\n\tregister char *ptr;\n\tregister int index = 0;\n\tchar username[PAM_MAX_RESP_SIZE];\n\t*ret_username = NULL;\n\tbzero((void *)username, PAM_MAX_RESP_SIZE);\n\tptr = user_input;\n\twhile ((*ptr == ' ') || (*ptr == '\\t'))\n\t\tptr++;\n\tif (*ptr == '\\0') {\n\t\treturn (PAM_BUF_ERR);\n\t}\n\twhile (*ptr != '\\0') {\n\t\tif ((*ptr == ' ') || (*ptr == '\\t'))\n\t\t\tbreak;\n\t\telse {\n\t\t\tusername[index] = *ptr;\n\t\t\tindex++;\n\t\t\tptr++;\n\t\t}\n\t}\n\tif ((*ret_username = malloc(index + 1)) == NULL)\n\t\treturn (PAM_BUF_ERR);\n\t(void) strcpy(*ret_username, username);\n\treturn (PAM_SUCCESS);\n}", "target": 1}
{"code": "static int ipddp_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n        struct ipddp_route __user *rt = ifr->ifr_data;\n        struct ipddp_route rcp, rcp2, *rp;\n        if(!capable(CAP_NET_ADMIN))\n                return -EPERM;\n\tif(copy_from_user(&rcp, rt, sizeof(rcp)))\n\t\treturn -EFAULT;\n        switch(cmd)\n        {\n\t\tcase SIOCADDIPDDPRT:\n                        return ipddp_create(&rcp);\n                case SIOCFINDIPDDPRT:\n\t\t\tspin_lock_bh(&ipddp_route_lock);\n\t\t\trp = __ipddp_find_route(&rcp);\n\t\t\tif (rp)\n\t\t\t\tmemcpy(&rcp2, rp, sizeof(rcp2));\n\t\t\tspin_unlock_bh(&ipddp_route_lock);\n\t\t\tif (rp) {\n\t\t\t\tif (copy_to_user(rt, &rcp2,\n\t\t\t\t\t\t sizeof(struct ipddp_route)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -ENOENT;\n                case SIOCDELIPDDPRT:\n                        return ipddp_delete(&rcp);\n                default:\n                        return -EINVAL;\n        }\n}", "target": 1}
{"code": "void test_chown(const char *path)\n{\n\tif (chown(path, 0, 0) == 0) {\n\t\tfprintf(stderr, \"leak at chown of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at chown of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "int bson_ensure_space( bson *b, const int bytesNeeded ) {\n    int pos = b->cur - b->data;\n    char *orig = b->data;\n    int new_size;\n    if ( pos + bytesNeeded <= b->dataSize )\n        return BSON_OK;\n    new_size = 1.5 * ( b->dataSize + bytesNeeded );\n    if( new_size < b->dataSize ) {\n        if( ( b->dataSize + bytesNeeded ) < INT_MAX )\n            new_size = INT_MAX;\n        else {\n            b->err = BSON_SIZE_OVERFLOW;\n            return BSON_ERROR;\n        }\n    }\n    b->data = bson_realloc( b->data, new_size );\n    if ( !b->data )\n        bson_fatal_msg( !!b->data, \"realloc() failed\" );\n    b->dataSize = new_size;\n    b->cur += b->data - orig;\n    return BSON_OK;\n}", "target": 1}
{"code": "ModuleSQL::~ModuleSQL()\n{\n\tif (Dispatcher)\n\t{\n\t\tDispatcher->join();\n\t\tDispatcher->OnNotify();\n\t\tdelete Dispatcher;\n\t}\n\tfor(ConnMap::iterator i = connections.begin(); i != connections.end(); i++)\n\t{\n\t\tdelete i->second;\n\t}\n\tmysql_library_end();\n}", "target": 0}
{"code": "static inline int nlmsg_parse(struct nlmsghdr *nlh, int hdrlen,\n\t\t\t      struct nlattr *tb[], int maxtype,\n\t\t\t      const struct nla_policy *policy)\n{\n\tif (nlh->nlmsg_len < nlmsg_msg_size(hdrlen))\n\t\treturn -EINVAL;\n\treturn nla_parse(tb, maxtype, nlmsg_attrdata(nlh, hdrlen),\n\t\t\t nlmsg_attrlen(nlh, hdrlen), policy);\n}", "target": 0}
{"code": "ext2_xattr_cache_insert(struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(HDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\tce = mb_cache_entry_alloc(ext2_xattr_cache, GFP_NOFS);\n\tif (!ce)\n\t\treturn -ENOMEM;\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache (%d cache entries)\",\n\t\t\t\tatomic_read(&ext2_xattr_cache->c_entry_count));\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x] (%d cache entries)\", (int)hash,\n\t\t\t  atomic_read(&ext2_xattr_cache->c_entry_count));\n\t\tmb_cache_entry_release(ce);\n\t}\n\treturn error;\n}", "target": 1}
{"code": "static void do_waitpid(FILE *fin, FILE *fout) {\n  char buf[BUFFER_SIZE];\n  read_buf(fin, buf);\n  int64_t p = -1;\n  int options = 0;\n  int timeout = 0;\n  sscanf(buf, \"%\" PRId64 \" %d %d\", &p, &options, &timeout);\n  pid_t pid = (pid_t)p;\n  int stat;\n  if (timeout > 0) {\n    waited = pid;\n    signal(SIGALRM, kill_handler);\n    alarm(timeout);\n  }\n  pid_t ret = ::waitpid(pid, &stat, options);\n  alarm(0); \n  waited = 0;\n  fprintf(fout, \"%\" PRId64 \" %d\\n\", (int64_t)ret, stat);\n  if (ret < 0) {\n    fprintf(fout, \"%d\\n\", errno);\n  }\n  fflush(fout);\n}", "target": 1}
{"code": "crm_remote_tcp_connect(const char *host, int port)\n{\n    struct addrinfo *res;\n    struct addrinfo *rp;\n    struct addrinfo hints;\n    const char *server = host;\n    int ret_ga;\n    int sock;\n    memset(&hints, 0, sizeof(struct addrinfo));\n    hints.ai_family = AF_UNSPEC;    \n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_flags = AI_CANONNAME;\n    crm_debug(\"Looking up %s\", server);\n    ret_ga = getaddrinfo(server, NULL, &hints, &res);\n    if (ret_ga) {\n        crm_err(\"getaddrinfo: %s\", gai_strerror(ret_ga));\n        return -1;\n    }\n    if (!res || !res->ai_addr) {\n        crm_err(\"getaddrinfo failed\");\n        return -1;\n    }\n    for (rp = res; rp != NULL; rp = rp->ai_next) {\n        struct sockaddr *addr = rp->ai_addr;\n        int flag = 0;\n        if (!addr) {\n            continue;\n        }\n        if (rp->ai_canonname) {\n            server = res->ai_canonname;\n        }\n        crm_debug(\"Got address %s for %s\", server, host);\n        sock = socket(rp->ai_family, SOCK_STREAM, IPPROTO_TCP);\n        if (sock == -1) {\n            crm_err(\"Socket creation failed for remote client connection.\");\n            continue;\n        }\n        if (addr->sa_family == AF_INET6) {\n            struct sockaddr_in6 *addr_in = (struct sockaddr_in6 *) addr;\n            addr_in->sin6_port = htons(port);\n        } else {\n            struct sockaddr_in *addr_in = (struct sockaddr_in *) addr;\n            addr_in->sin_port = htons(port);\n            crm_info(\"Attempting to connect to remote server at %s:%d\", inet_ntoa(addr_in->sin_addr), port);\n        }\n        if (connect(sock, rp->ai_addr, rp->ai_addrlen) == 0) {\n            if ((flag = fcntl(sock, F_GETFL)) >= 0) {\n                if (fcntl(sock, F_SETFL, flag | O_NONBLOCK) < 0) {\n                    crm_err( \"fcntl() write failed\");\n                    close(sock);\n                    sock = -1;\n                    continue;\n                }\n            }\n            break;                  \n        }\n        close(sock);\n        sock = -1;\n    }\n    freeaddrinfo(res);\n    return sock;\n}", "target": 0}
{"code": "mktime(const unsigned int year0, const unsigned int mon0,\n       const unsigned int day, const unsigned int hour,\n       const unsigned int min, const unsigned int sec)\n{\n\tunsigned int mon = mon0, year = year0;\n\tif (0 >= (int) (mon -= 2)) {\n\t\tmon += 12;\t\n\t\tyear -= 1;\n\t}\n\treturn ((((unsigned long)\n\t\t  (year/4 - year/100 + year/400 + 367*mon/12 + day) +\n\t\t  year*365 - 719499\n\t    )*24 + hour \n\t  )*60 + min \n\t)*60 + sec; \n}", "target": 0}
{"code": "static std::vector<std::string> AllDirectoryPrefixes(const std::string& d) {\n  std::vector<std::string> dirs;\n  const std::string patched = PatchPattern(d);\n  StringPiece dir(patched);\n  bool is_directory = d[d.size() - 1] == '/';\n#ifdef PLATFORM_WINDOWS\n  is_directory = is_directory || (d[d.size() - 1] == '\\\\');\n#endif\n  if (is_directory) {\n    dir = io::Dirname(dir);\n  }\n  while (!dir.empty()) {\n    dirs.emplace_back(dir);\n    StringPiece new_dir(io::Dirname(dir));\n    if (dir == new_dir) break;\n    dir = new_dir;\n  }\n  std::reverse(dirs.begin(), dirs.end());\n  return dirs;\n}", "target": 0}
{"code": "static int check_client_redirect_uri_valid(struct _oidc_config * config,\n                                           const char * client_id,\n                                           const char * redirect_uri,\n                                           const char * ip_source) {\n  json_t * j_client = config->glewlwyd_config->glewlwyd_plugin_callback_get_client(config->glewlwyd_config, client_id);\n  int uri_found = 0, ret;\n  if (check_result_value(j_client, G_OK) && json_object_get(json_object_get(j_client, \"client\"), \"enabled\") == json_true()) {\n    if (!o_strnullempty(redirect_uri)) {\n      if (json_array_has_string(json_object_get(json_object_get(j_client, \"client\"), \"redirect_uri\"), redirect_uri)) {\n        uri_found = 1;\n      } else {\n        uri_found = 0;\n      }\n    } else {\n      uri_found = 1;\n    }\n    if (!uri_found) {\n      y_log_message(Y_LOG_LEVEL_DEBUG, \"check_client_redirect_uri_valid - oidc - Error, redirect_uri '%s' is invalid for the client '%s', origin: %s\", redirect_uri, client_id, ip_source);\n      ret = G_ERROR_UNAUTHORIZED;\n    } else {\n      ret = G_OK;\n    }\n  } else {\n    ret = G_ERROR_UNAUTHORIZED;\n  }\n  json_decref(j_client);\n  return ret;\n}", "target": 1}
{"code": "header_read (SF_PRIVATE *psf, void *ptr, int bytes)\n{\tint count = 0 ;\n\tif (psf->headindex >= SIGNED_SIZEOF (psf->header))\n\t\treturn psf_fread (ptr, 1, bytes, psf) ;\n\tif (psf->headindex + bytes > SIGNED_SIZEOF (psf->header))\n\t{\tint most ;\n\t\tmost = SIGNED_SIZEOF (psf->header) - psf->headend ;\n\t\tpsf_fread (psf->header + psf->headend, 1, most, psf) ;\n\t\tmemcpy (ptr, psf->header + psf->headend, most) ;\n\t\tpsf->headend = psf->headindex += most ;\n\t\tpsf_fread ((char *) ptr + most, bytes - most, 1, psf) ;\n\t\treturn bytes ;\n\t\t} ;\n\tif (psf->headindex + bytes > psf->headend)\n\t{\tcount = psf_fread (psf->header + psf->headend, 1, bytes - (psf->headend - psf->headindex), psf) ;\n\t\tif (count != bytes - (int) (psf->headend - psf->headindex))\n\t\t{\tpsf_log_printf (psf, \"Error : psf_fread returned short count.\\n\") ;\n\t\t\treturn count ;\n\t\t\t} ;\n\t\tpsf->headend += count ;\n\t\t} ;\n\tmemcpy (ptr, psf->header + psf->headindex, bytes) ;\n\tpsf->headindex += bytes ;\n\treturn bytes ;\n} ", "target": 1}
{"code": "        int          GetS32BE (int nPos, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos + 3 >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            int nRes = m_sFile[ nPos ];\n            nRes = (nRes << 8) + m_sFile[nPos + 1];\n            nRes = (nRes << 8) + m_sFile[nPos + 2];\n            nRes = (nRes << 8) + m_sFile[nPos + 3];\n            if ( nRes & 0x80000000 )\n                nRes |= ~0xffffffff;\n            return nRes;\n        }", "target": 1}
{"code": "int bad_format_imginfo(\n    char *fmt)\n{\n    char     *ptr;\n    int       n = 0;\n    ptr = fmt;\n    while (*ptr != '\\0')\n        if (*ptr++ == '%') {\n            if (*ptr == '\\0')\n                return 1;\n            if (*ptr == '%')\n                ptr++;\n            else if (*ptr == 's' || *ptr == 'S') {\n                n = 1;\n                ptr++;\n            }\n            else {\n                if (*ptr == ' ')\n                    ptr++;\n                while (*ptr >= '0' && *ptr <= '9')\n                    ptr++;\n                if (*ptr++ != 'l')\n                    return 1;\n                if (*ptr == 'u')\n                    ptr++;\n                else\n                    return 1;\n                n++;\n            }\n        }\n    return (n != 3);\n}", "target": 1}
{"code": "int rpc_type_of_NPPVariable(int variable)\n{\n  int type;\n  switch (variable) {\n  case NPPVpluginNameString:\n  case NPPVpluginDescriptionString:\n  case NPPVformValue: \n  case NPPVpluginNativeAccessibleAtkPlugId:\n\ttype = RPC_TYPE_STRING;\n\tbreak;\n  case NPPVpluginWindowSize:\n  case NPPVpluginTimerInterval:\n\ttype = RPC_TYPE_INT32;\n\tbreak;\n  case NPPVpluginNeedsXEmbed:\n  case NPPVpluginWindowBool:\n  case NPPVpluginTransparentBool:\n  case NPPVjavascriptPushCallerBool:\n  case NPPVpluginKeepLibraryInMemory:\n  case NPPVpluginUrlRequestsDisplayedBool:\n  case NPPVpluginWantsAllNetworkStreams:\n  case NPPVpluginCancelSrcStream:\n  case NPPVSupportsAdvancedKeyHandling:\n\ttype = RPC_TYPE_BOOLEAN;\n\tbreak;\n  case NPPVpluginScriptableNPObject:\n\ttype = RPC_TYPE_NP_OBJECT;\n\tbreak;\n  default:\n\ttype = RPC_ERROR_GENERIC;\n\tbreak;\n  }\n  return type;\n}", "target": 0}
{"code": "void *hashtable_iter_at(hashtable_t *hashtable, const char *key)\n{\n    pair_t *pair;\n    size_t hash;\n    bucket_t *bucket;\n    hash = hash_str(key);\n    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n    if(!pair)\n        return NULL;\n    return &pair->list;\n}", "target": 1}
{"code": "  int Bind(const Node& node, int max_retry) override {\n    receiver_ = zmq_socket(context_, ZMQ_ROUTER);\n    CHECK(receiver_ != NULL)\n        << \"create receiver socket failed: \" << zmq_strerror(errno);\n    int local = GetEnv(\"DMLC_LOCAL\", 0);\n    std::string addr = local ? \"ipc:\n    int port = node.port;\n    unsigned seed = static_cast<unsigned>(time(NULL)+port);\n    for (int i = 0; i < max_retry+1; ++i) {\n      auto address = addr + std::to_string(port);\n      if (zmq_bind(receiver_, address.c_str()) == 0) break;\n      if (i == max_retry) {\n        port = -1;\n      } else {\n        port = 10000 + rand_r(&seed) % 40000;\n      }\n    }\n    return port;\n  }", "target": 1}
{"code": "ikev2_ke_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep _U_,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct ikev2_ke ke;\n\tconst struct ikev2_ke *k;\n\tk = (const struct ikev2_ke *)ext;\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&ke, ext, sizeof(ke));\n\tikev2_pay_print(ndo, NPSTR(tpay), ke.h.critical);\n\tND_PRINT((ndo,\" len=%u group=%s\", ntohs(ke.h.len) - 8,\n\t\t  STR_OR_ID(ntohs(ke.ke_group), dh_p_map)));\n\tif (2 < ndo->ndo_vflag && 8 < ntohs(ke.h.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(k + 1), ntohs(ke.h.len) - 8))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(ke.h.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 1}
{"code": "DEFINE_TEST(test_read_too_many_filters)\n{\n\tconst char *name = \"test_read_too_many_filters.gz\";\n\tstruct archive *a;\n\tint r;\n\tassert((a = archive_read_new()) != NULL);\n\tr = archive_read_support_filter_gzip(a);\n\tif (r == ARCHIVE_WARN) {\n\t\tskipping(\"gzip reading not fully supported on this platform\");\n\t}\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_all(a));\n\textract_reference_file(name);\n\tassertEqualIntA(a, ARCHIVE_FATAL,\n\t    archive_read_open_filename(a, name, 200));\n\tassertEqualInt(ARCHIVE_OK, archive_read_close(a));\n\tassertEqualInt(ARCHIVE_OK, archive_read_free(a));\n}", "target": 0}
{"code": "CompileResult generateBytecodeForSerialization(\n    raw_ostream &OS,\n    Module &M,\n    const BytecodeGenerationOptions &genOptions,\n    const SHA1 &sourceHash,\n    hermes::OptValue<uint32_t> segment,\n    SourceMapGenerator *sourceMapGenOrNull,\n    BaseBytecodeMap &baseBytecodeMap) {\n  if (cl::BytecodeFormat == cl::BytecodeFormatKind::HBC) {\n    std::unique_ptr<hbc::BCProviderFromBuffer> baseBCProvider = nullptr;\n    auto itr = baseBytecodeMap.find(segment ? *segment : 0);\n    if (itr != baseBytecodeMap.end()) {\n      baseBCProvider = std::move(itr->second);\n      baseBytecodeMap.erase(itr);\n    }\n    auto bytecodeModule = hbc::generateBytecode(\n        &M,\n        OS,\n        genOptions,\n        sourceHash,\n        segment,\n        sourceMapGenOrNull,\n        std::move(baseBCProvider));\n    if (auto N = M.getContext().getSourceErrorManager().getErrorCount()) {\n      llvh::errs() << \"Emitted \" << N << \" errors in the backend. exiting.\\n\";\n      return BackendError;\n    }\n    if (cl::DumpTarget == DumpBytecode) {\n      disassembleBytecode(hbc::BCProviderFromSrc::createBCProviderFromSrc(\n          std::move(bytecodeModule)));\n    }\n  } else {\n    llvm_unreachable(\"Invalid bytecode kind\");\n  }\n  return Success;\n}", "target": 0}
{"code": "static Jsi_RC SysTimesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_RC rc = JSI_OK;\n    int i, n=1, argc = Jsi_ValueGetLength(interp, args);\n    Jsi_Value *func = Jsi_ValueArrayIndex(interp, args, 0);\n    if (Jsi_ValueIsBoolean(interp, func)) {\n        bool bv;\n        if (argc != 1)\n            return Jsi_LogError(\"bool must be only arg\");\n        Jsi_GetBoolFromValue(interp, func, &bv);\n        double now = jsi_GetTimestamp();\n        if (bv)\n            interp->timesStart = now;\n        else {\n            char buf[100];\n            snprintf(buf, sizeof(buf), \" (times = %.6f sec)\\n\", (now-interp->timesStart));\n            Jsi_Puts(interp, jsi_Stderr, buf, -1);\n        }\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    Jsi_Wide diff, start, end;\n    if (!Jsi_ValueIsFunction(interp, func))\n        return Jsi_LogError(\"arg1: expected function|bool\");\n    if (argc > 1 && Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, 1), &n) != JSI_OK)\n        return JSI_ERROR;\n    if (n<=0) \n        return Jsi_LogError(\"count not > 0: %d\", n);\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    start = (Jsi_Wide) tv.tv_sec * 1000000 + tv.tv_usec;\n    for (i=0; i<n && rc == JSI_OK; i++) {\n        rc = Jsi_FunctionInvoke(interp, func, NULL, ret, NULL);\n    }\n    gettimeofday(&tv, NULL);\n    end = (Jsi_Wide) tv.tv_sec * 1000000 + tv.tv_usec;\n    diff = (end - start);\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)diff);\n    return rc;\n}", "target": 1}
{"code": "static int ip_options_get_finish(struct net *net, struct ip_options **optp,\n\t\t\t\t struct ip_options *opt, int optlen)\n{\n\twhile (optlen & 3)\n\t\topt->__data[optlen++] = IPOPT_END;\n\topt->optlen = optlen;\n\tif (optlen && ip_options_compile(net, opt, NULL)) {\n\t\tkfree(opt);\n\t\treturn -EINVAL;\n\t}\n\tkfree(*optp);\n\t*optp = opt;\n\treturn 0;\n}", "target": 1}
{"code": "int jsi_PstateSetFile(jsi_Pstate *ps, Jsi_Channel fp, int skipbang)\n{\n    jsi_Lexer *l = ps->lexer;\n    jsi_PstateClear(ps);\n    l->ltype = LT_FILE;\n    l->d.fp = fp;\n    Jsi_Rewind(ps->interp, fp);\n    if (skipbang) {\n        char buf[1000];\n        if (Jsi_Gets(ps->interp, fp, buf, 1000) && (buf[0] != '#' || buf[1] != '!')) {\n            Jsi_Rewind(ps->interp, fp);\n        }\n    }\n    return JSI_OK;\n}", "target": 1}
{"code": "static void ready_handler(void *arg)\n{\n\tstruct stun_uri uri;\n\tint err;\n\tdns_init(NULL);\n\t(void)uri;\n\t(void)err;\n\tre_printf(\"engine ready.\\n\");\n\tconfig_alloc(&g_config, config_req_handler, NULL, NULL);\n\tconfig_start(g_config);\n#if 0\n\terr = stun_uri_decode(&uri, turn_uri);\n\tif (err) {\n\t\twarning(\"netprobe: ready_handler: failed to parse URI: %s\\n\",\n\t\t\tturn_uri);\n\t\treturn;\n\t}\n\tstart_netprobe(&uri.addr, uri.proto, uri.secure, \"\", \"\");\n#endif\n}", "target": 0}
{"code": "int setup_tests(void)\n{\n    crv_len = EC_get_builtin_curves(NULL, 0);\n    if (!TEST_ptr(curves = OPENSSL_malloc(sizeof(*curves) * crv_len))\n        || !TEST_true(EC_get_builtin_curves(curves, crv_len)))\n        return 0;\n    ADD_TEST(field_tests_ecp_simple);\n    ADD_TEST(field_tests_ecp_mont);\n#ifndef OPENSSL_NO_EC2M\n    ADD_TEST(ec2m_field_sanity);\n    ADD_TEST(field_tests_ec2_simple);\n#endif\n    ADD_ALL_TESTS(field_tests_default, crv_len);\n#ifndef OPENSSL_NO_EC_NISTP_64_GCC_128\n    ADD_TEST(underflow_test);\n#endif\n    ADD_TEST(set_private_key);\n    ADD_TEST(decoded_flag_test);\n    ADD_ALL_TESTS(ecpkparams_i2d2i_test, crv_len);\n    return 1;\n}", "target": 0}
{"code": "void CharCodeToUnicode::addMapping(CharCode code, char *uStr, int n,\n\t\t\t\t   int offset) {\n  CharCode oldLen, i;\n  Unicode u;\n  char uHex[5];\n  int j;\n  if (code >= mapLen) {\n    oldLen = mapLen;\n    mapLen = (code + 256) & ~255;\n    map = (Unicode *)greallocn(map, mapLen, sizeof(Unicode));\n    for (i = oldLen; i < mapLen; ++i) {\n      map[i] = 0;\n    }\n  }\n  if (n <= 4) {\n    if (sscanf(uStr, \"%x\", &u) != 1) {\n      error(-1, \"Illegal entry in ToUnicode CMap\");\n      return;\n    }\n    map[code] = u + offset;\n  } else {\n    if (sMapLen >= sMapSize) {\n      sMapSize = sMapSize + 16;\n      sMap = (CharCodeToUnicodeString *)\n\t       greallocn(sMap, sMapSize, sizeof(CharCodeToUnicodeString));\n    }\n    map[code] = 0;\n    sMap[sMapLen].c = code;\n    sMap[sMapLen].len = n / 4;\n    for (j = 0; j < sMap[sMapLen].len && j < maxUnicodeString; ++j) {\n      strncpy(uHex, uStr + j*4, 4);\n      uHex[4] = '\\0';\n      if (sscanf(uHex, \"%x\", &sMap[sMapLen].u[j]) != 1) {\n\terror(-1, \"Illegal entry in ToUnicode CMap\");\n      }\n    }\n    sMap[sMapLen].u[sMap[sMapLen].len - 1] += offset;\n    ++sMapLen;\n  }\n}", "target": 1}
{"code": "void QuotaManager::DidGetDatabaseLRUOrigin(const GURL& origin) {\n  if (origins_in_use_.find(origin) != origins_in_use_.end() ||\n      access_notified_origins_.find(origin) != access_notified_origins_.end())\n    lru_origin_callback_->Run(GURL());\n  else\n    lru_origin_callback_->Run(origin);\n  access_notified_origins_.clear();\n  lru_origin_callback_.reset();\n}", "target": 0}
{"code": "bool IsSupported(const tensorflow::DataType data_type) {\n  switch (data_type) {\n    case tensorflow::DT_FLOAT:\n    case tensorflow::DT_DOUBLE:\n    case tensorflow::DT_INT32:\n    case tensorflow::DT_UINT8:\n    case tensorflow::DT_INT16:\n    case tensorflow::DT_INT8:\n    case tensorflow::DT_STRING:\n    case tensorflow::DT_COMPLEX64:\n    case tensorflow::DT_INT64:\n    case tensorflow::DT_BOOL:\n    case tensorflow::DT_QINT8:\n    case tensorflow::DT_QUINT8:\n    case tensorflow::DT_QINT32:\n    case tensorflow::DT_BFLOAT16:\n    case tensorflow::DT_QINT16:\n    case tensorflow::DT_QUINT16:\n    case tensorflow::DT_UINT16:\n    case tensorflow::DT_COMPLEX128:\n    case tensorflow::DT_HALF:\n    case tensorflow::DT_UINT32:\n    case tensorflow::DT_UINT64:\n    case tensorflow::DT_FLOAT8_E5M2:\n    case tensorflow::DT_FLOAT8_E4M3FN:\n    case tensorflow::DT_INT4:\n    case tensorflow::DT_UINT4:\n      return true;\n    default:\n      return false;\n  }\n}", "target": 0}
{"code": "static apr_status_t parse_chunk_size(http_ctx_t *ctx, const char *buffer,\n        apr_size_t len, int linelimit)\n{\n    apr_size_t i = 0;\n    while (i < len) {\n        char c = buffer[i];\n        ap_xlate_proto_from_ascii(&c, 1);\n        if (ctx->state == BODY_CHUNK_END) {\n            if (c == LF) {\n                ctx->state = BODY_CHUNK;\n            }\n            i++;\n            continue;\n        }\n        if (ctx->state == BODY_CHUNK) {\n            if (!apr_isxdigit(c)) {\n                return APR_EGENERAL;\n            }\n            else {\n                ctx->state = BODY_CHUNK_PART;\n            }\n            ctx->remaining = 0;\n            ctx->chunkbits = sizeof(long) * 8;\n            ctx->chunk_used = 0;\n        }\n        if (c == ';' || c == CR) {\n            ctx->state = BODY_CHUNK_EXT;\n        }\n        else if (c == LF) {\n            if (ctx->remaining) {\n                ctx->state = BODY_CHUNK_DATA;\n            }\n            else {\n                ctx->state = BODY_CHUNK_TRAILER;\n            }\n        }\n        else if (ctx->state != BODY_CHUNK_EXT) {\n            int xvalue = 0;\n            if (!ctx->remaining && c == '0') {\n                i++;\n                continue;\n            }\n            if (c >= '0' && c <= '9') {\n                xvalue = c - '0';\n            }\n            else if (c >= 'A' && c <= 'F') {\n                xvalue = c - 'A' + 0xa;\n            }\n            else if (c >= 'a' && c <= 'f') {\n                xvalue = c - 'a' + 0xa;\n            }\n            else {\n                return APR_EGENERAL;\n            }\n            ctx->remaining = (ctx->remaining << 4) | xvalue;\n            ctx->chunkbits -= 4;\n            if (ctx->chunkbits <= 0 || ctx->remaining < 0) {\n                return APR_ENOSPC;\n            }\n        }\n        i++;\n    }\n    ctx->chunk_used += len;\n    if (ctx->chunk_used < 0 || ctx->chunk_used > linelimit) {\n        return APR_ENOSPC;\n    }\n    return APR_SUCCESS;\n}", "target": 1}
{"code": "static int ras_getcmap(jas_stream_t *in, ras_hdr_t *hdr, ras_cmap_t *cmap)\n{\n\tint i;\n\tint j;\n\tint x;\n\tint c;\n\tint numcolors;\n\tint actualnumcolors;\n\tswitch (hdr->maptype) {\n\tcase RAS_MT_NONE:\n\t\tbreak;\n\tcase RAS_MT_EQUALRGB:\n\t\t{\n\t\tjas_eprintf(\"warning: palettized images not fully supported\\n\");\n\t\tnumcolors = 1 << hdr->depth;\n\t\tassert(numcolors <= RAS_CMAP_MAXSIZ);\n\t\tactualnumcolors = hdr->maplength / 3;\n\t\tfor (i = 0; i < numcolors; i++) {\n\t\t\tcmap->data[i] = 0;\n\t\t}\n\t\tif ((hdr->maplength % 3) || hdr->maplength < 0 ||\n\t\t  hdr->maplength > 3 * numcolors) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tfor (j = 0; j < actualnumcolors; j++) {\n\t\t\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tx = 0;\n\t\t\t\tswitch (i) {\n\t\t\t\tcase 0:\n\t\t\t\t\tx = RAS_RED(c);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tx = RAS_GREEN(c);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tx = RAS_BLUE(c);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcmap->data[j] |= x;\n\t\t\t}\n\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "struct clock_source *dcn10_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\tif (!clk_src)\n\t\treturn NULL;\n\tif (dce112_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 0}
{"code": "int kvm_io_bus_write(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx, gpa_t addr,\n\t\t     int len, const void *val)\n{\n\tstruct kvm_io_bus *bus;\n\tstruct kvm_io_range range;\n\tint r;\n\trange = (struct kvm_io_range) {\n\t\t.addr = addr,\n\t\t.len = len,\n\t};\n\tbus = srcu_dereference(vcpu->kvm->buses[bus_idx], &vcpu->kvm->srcu);\n\tr = __kvm_io_bus_write(vcpu, bus, &range, val);\n\treturn r < 0 ? r : 0;\n}", "target": 0}
{"code": "static int fd_getgeo(struct block_device *bdev, struct hd_geometry *geo)\n{\n\tint drive = (long)bdev->bd_disk->private_data;\n\tint type = ITYPE(drive_state[drive].fd_device);\n\tstruct floppy_struct *g;\n\tint ret;\n\tret = get_floppy_geometry(drive, type, &g);\n\tif (ret)\n\t\treturn ret;\n\tgeo->heads = g->head;\n\tgeo->sectors = g->sect;\n\tgeo->cylinders = g->track;\n\treturn 0;\n}", "target": 0}
{"code": "check_owner_password_V4(std::string& user_password,\n                        std::string const& owner_password,\n                        QPDF::EncryptionData const& data)\n{\n    unsigned char key[OU_key_bytes_V4];\n    compute_O_rc4_key(user_password, owner_password, data, key);\n    unsigned char O_data[key_bytes];\n    memcpy(O_data, QUtil::unsigned_char_pointer(data.getO()), key_bytes);\n    iterate_rc4(O_data, key_bytes, key, data.getLengthBytes(),\n                (data.getR() >= 3) ? 20 : 1, true);\n    std::string new_user_password =\n        std::string(reinterpret_cast<char*>(O_data), key_bytes);\n    bool result = false;\n    if (check_user_password(new_user_password, data))\n    {\n        result = true;\n        user_password = new_user_password;\n    }\n    return result;\n}", "target": 1}
{"code": "static void sas_eh_defer_cmd(struct scsi_cmnd *cmd)\n{\n\tstruct domain_device *dev = cmd_to_domain_dev(cmd);\n\tstruct sas_ha_struct *ha = dev->port->ha;\n\tstruct sas_task *task = TO_SAS_TASK(cmd);\n\tif (!dev_is_sata(dev)) {\n\t\tsas_eh_finish_cmd(cmd);\n\t\treturn;\n\t}\n\tsas_end_task(cmd, task);\n\tlist_move_tail(&cmd->eh_entry, &ha->eh_ata_q);\n}", "target": 1}
{"code": "static struct nfs4_state *nfs4_try_open_cached(struct nfs4_opendata *opendata)\n{\n\tstruct nfs4_state *state = opendata->state;\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_delegation *delegation;\n\tint open_mode = opendata->o_arg.open_flags & (FMODE_READ|FMODE_WRITE|O_EXCL);\n\tnfs4_stateid stateid;\n\tint ret = -EAGAIN;\n\tfor (;;) {\n\t\tif (can_open_cached(state, open_mode)) {\n\t\t\tspin_lock(&state->owner->so_lock);\n\t\t\tif (can_open_cached(state, open_mode)) {\n\t\t\t\tupdate_open_stateflags(state, open_mode);\n\t\t\t\tspin_unlock(&state->owner->so_lock);\n\t\t\t\tgoto out_return_state;\n\t\t\t}\n\t\t\tspin_unlock(&state->owner->so_lock);\n\t\t}\n\t\trcu_read_lock();\n\t\tdelegation = rcu_dereference(nfsi->delegation);\n\t\tif (delegation == NULL ||\n\t\t    !can_open_delegated(delegation, open_mode)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(stateid.data, delegation->stateid.data, sizeof(stateid.data));\n\t\trcu_read_unlock();\n\t\tret = nfs_may_open(state->inode, state->owner->so_cred, open_mode);\n\t\tif (ret != 0)\n\t\t\tgoto out;\n\t\tret = -EAGAIN;\n\t\tif (update_open_stateid(state, NULL, &stateid, open_mode))\n\t\t\tgoto out_return_state;\n\t}\nout:\n\treturn ERR_PTR(ret);\nout_return_state:\n\tatomic_inc(&state->count);\n\treturn state;\n}", "target": 1}
{"code": "create_policy_2_svc(cpol_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->rec.policy;\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_ADD, NULL, NULL)) {\n        ret.code = KADM5_AUTH_ADD;\n        log_unauth(\"kadm5_create_policy\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_create_policy((void *)handle, &arg->rec,\n                                       arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_create_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "ngx_http_lua_copy_request_headers(ngx_http_request_t *sr, ngx_http_request_t *r)\n{\n    ngx_table_elt_t                 *header;\n    ngx_list_part_t                 *part;\n    ngx_uint_t                       i;\n    if (ngx_list_init(&sr->headers_in.headers, sr->pool, 20,\n                      sizeof(ngx_table_elt_t)) != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n    dd(\"before: parent req headers count: %d\",\n       (int) r->headers_in.headers.part.nelts);\n    part = &r->headers_in.headers.part;\n    header = part->elts;\n    for (i = 0; ; i++) {\n        if (i >= part->nelts) {\n            if (part->next == NULL) {\n                break;\n            }\n            part = part->next;\n            header = part->elts;\n            i = 0;\n        }\n        dd(\"setting request header %.*s: %.*s\", (int) header[i].key.len,\n           header[i].key.data, (int) header[i].value.len,\n           header[i].value.data);\n        if (ngx_http_lua_set_input_header(sr, header[i].key,\n                                          header[i].value, 0) == NGX_ERROR)\n        {\n            return NGX_ERROR;\n        }\n    }\n    dd(\"after: parent req headers count: %d\",\n       (int) r->headers_in.headers.part.nelts);\n    return NGX_OK;\n}", "target": 1}
{"code": "static int sdp_parse_fmtp_config_h264(AVFormatContext *s,\n                                      AVStream *stream,\n                                      PayloadContext *h264_data,\n                                      const char *attr, const char *value)\n{\n    AVCodecParameters *par = stream->codecpar;\n    if (!strcmp(attr, \"packetization-mode\")) {\n        av_log(s, AV_LOG_DEBUG, \"RTP Packetization Mode: %d\\n\", atoi(value));\n        h264_data->packetization_mode = atoi(value);\n        if (h264_data->packetization_mode > 1)\n            av_log(s, AV_LOG_ERROR,\n                   \"Interleaved RTP mode is not supported yet.\\n\");\n    } else if (!strcmp(attr, \"profile-level-id\")) {\n        if (strlen(value) == 6)\n            parse_profile_level_id(s, h264_data, value);\n    } else if (!strcmp(attr, \"sprop-parameter-sets\")) {\n        int ret;\n        if (value[strlen(value) - 1] == ',') {\n            av_log(s, AV_LOG_WARNING, \"Missing PPS in sprop-parameter-sets, ignoring\\n\");\n            return 0;\n        }\n        par->extradata_size = 0;\n        av_freep(&par->extradata);\n        ret = ff_h264_parse_sprop_parameter_sets(s, &par->extradata,\n                                                 &par->extradata_size, value);\n        av_log(s, AV_LOG_DEBUG, \"Extradata set to %p (size: %d)\\n\",\n               par->extradata, par->extradata_size);\n        return ret;\n    }\n    return 0;\n}", "target": 1}
{"code": "static int AskScriptChanged() {\n    int ret;\n    char *buts[4];\n    buts[0] = _(\"_Yes\");\n    buts[1] = _(\"Yes, and don't _remind me again\");\n    buts[2] = _(\"_No\");\n    buts[3] = NULL;\n    ret = gwwv_ask( _(\"Unsaved script\"),(const char **) buts,0,2,_(\"You have an unsaved script in the Execute Script dialog. Do you intend to discard it?\"));\n    if (ret == 1) {\n        warn_script_unsaved = false;\n        SavePrefs(true);\n    }\nreturn( ret );\n}", "target": 0}
{"code": "static inline void vpid_sync_context(struct vcpu_vmx *vmx)\n{\n\tif (cpu_has_vmx_invvpid_single())\n\t\tvpid_sync_vcpu_single(vmx);\n\telse\n\t\tvpid_sync_vcpu_global();\n}", "target": 0}
{"code": "void RenderView::OnSetDOMUIProperty(const std::string& name,\n                                    const std::string& value) {\n  DCHECK(BindingsPolicy::is_dom_ui_enabled(enabled_bindings_));\n  dom_ui_bindings_.SetProperty(name, value);\n}", "target": 0}
{"code": "find_auth_end (FlatpakProxyClient *client, Buffer *buffer)\n{\n  guchar *match;\n  int i;\n  if (client->auth_end_offset > 0)\n    {\n      gsize left = strlen (AUTH_END_STRING) - client->auth_end_offset;\n      gsize to_match = MIN (left, buffer->pos);\n      if (memcmp (buffer->data, &AUTH_END_STRING[client->auth_end_offset], to_match) == 0)\n        {\n          client->auth_end_offset += to_match;\n          if (client->auth_end_offset == strlen (AUTH_END_STRING))\n            return to_match;\n          return -1;\n        }\n      client->auth_end_offset = -1;\n    }\n  match = memmem (buffer, buffer->pos,\n                  AUTH_END_STRING, strlen (AUTH_END_STRING));\n  if (match != NULL)\n    return match - buffer->data + strlen (AUTH_END_STRING);\n  for (i = MIN (strlen (AUTH_END_STRING) - 1, buffer->pos); i > 0; i--)\n    {\n      if (memcmp (buffer->data + buffer->pos - i, AUTH_END_STRING, i) == 0)\n        {\n          client->auth_end_offset = i;\n          break;\n        }\n    }\n  return -1;\n}", "target": 1}
{"code": "static const char *adpt_info(struct Scsi_Host *host)\n{\n\tadpt_hba* pHba;\n\tpHba = (adpt_hba *) host->hostdata[0];\n\treturn (char *) (pHba->detail);\n}", "target": 1}
{"code": "get_one_option(int optid, const struct my_option *opt,\n               char *argument)\n{\n  my_bool add_option= TRUE;\n  switch (optid) {\n  case '?':\n    printf(\"%s  Ver %s Distrib %s, for %s (%s)\\n\",\n           my_progname, VER, MYSQL_SERVER_VERSION, SYSTEM_TYPE, MACHINE_TYPE);\n    puts(ORACLE_WELCOME_COPYRIGHT_NOTICE(\"2000\"));\n    puts(\"MySQL utility for upgrading databases to new MySQL versions.\\n\");\n    my_print_help(my_long_options);\n    exit(0);\n    break;\n  case '#':\n    DBUG_PUSH(argument ? argument : default_dbug_option);\n    add_option= FALSE;\n    debug_check_flag= 1;\n    break;\n  case 'p':\n    if (argument == disabled_my_option)\n      argument= (char*) \"\";\t\t\t\n    tty_password= 1;\n    add_option= FALSE;\n    if (argument)\n    {\n      add_one_option(&ds_args, opt, argument);\n      while (*argument)\n        *argument++= 'x';                       \n      tty_password= 0;\n    }\n    break;\n  case 't':\n    my_stpnmov(opt_tmpdir, argument, sizeof(opt_tmpdir));\n    add_option= FALSE;\n    break;\n  case 'k':                                     \n  case 'v': \n  case 'f': \n  case 's':                                     \n  case OPT_WRITE_BINLOG:                        \n    add_option= FALSE;\n    break;\n  case 'h': \n  case 'W': \n  case 'P': \n  case 'S': \n  case OPT_MYSQL_PROTOCOL: \n  case OPT_SHARED_MEMORY_BASE_NAME: \n  case OPT_PLUGIN_DIR:                          \n  case OPT_DEFAULT_AUTH:                        \n    add_one_option(&conn_args, opt, argument);\n    break;\n  }\n  if (add_option)\n  {\n    add_one_option(&ds_args, opt, argument);\n  }\n  return 0;\n}", "target": 1}
{"code": "ParseNameValue(const char * buffer, int bufsize,\n               struct NameValueParserData * data)\n{\n\tstruct xmlparser parser;\n\tdata->l_head = NULL;\n\tdata->portListing = NULL;\n\tdata->portListingLength = 0;\n\tparser.xmlstart = buffer;\n\tparser.xmlsize = bufsize;\n\tparser.data = data;\n\tparser.starteltfunc = NameValueParserStartElt;\n\tparser.endeltfunc = NameValueParserEndElt;\n\tparser.datafunc = NameValueParserGetData;\n\tparser.attfunc = 0;\n\tparsexml(&parser);\n}", "target": 1}
{"code": "int options_cmdline(char *arg1, char *arg2) {\n    char *name;\n    CONF_TYPE type;\n#ifdef USE_WIN32\n    (void)arg2; \n#endif\n    if(!arg1) {\n        name=\n#ifdef CONFDIR\n            CONFDIR\n#ifdef USE_WIN32\n            \"\\\\\"\n#else\n            \"/\"\n#endif\n#endif\n            \"stunnel.conf\";\n        type=CONF_FILE;\n    } else if(!strcasecmp(arg1, \"-help\")) {\n        parse_global_option(CMD_PRINT_HELP, NULL, NULL);\n        parse_service_option(CMD_PRINT_HELP, NULL, NULL, NULL);\n        log_flush(LOG_MODE_INFO);\n        return 2;\n    } else if(!strcasecmp(arg1, \"-version\")) {\n        parse_global_option(CMD_PRINT_DEFAULTS, NULL, NULL);\n        parse_service_option(CMD_PRINT_DEFAULTS, NULL, NULL, NULL);\n        log_flush(LOG_MODE_INFO);\n        return 2;\n    } else if(!strcasecmp(arg1, \"-sockets\")) {\n        socket_options_print();\n        log_flush(LOG_MODE_INFO);\n        return 2;\n    } else if(!strcasecmp(arg1, \"-options\")) {\n        print_ssl_options();\n        log_flush(LOG_MODE_INFO);\n        return 2;\n    } else\n#ifndef USE_WIN32\n    if(!strcasecmp(arg1, \"-fd\")) {\n        if(!arg2) {\n            s_log(LOG_ERR, \"No file descriptor specified\");\n            print_syntax();\n            return 1;\n        }\n        name=arg2;\n        type=CONF_FD;\n    } else\n#endif\n    {\n        name=arg1;\n        type=CONF_FILE;\n    }\n    if(type==CONF_FILE) {\n#ifdef HAVE_REALPATH\n        char *real_path=NULL;\n#ifdef MAXPATHLEN\n        real_path=malloc(MAXPATHLEN);\n#endif\n        real_path=realpath(name, real_path);\n        if(!real_path) {\n            s_log(LOG_ERR, \"Invalid configuration file name \\\"%s\\\"\", name);\n            ioerror(\"realpath\");\n            return 1;\n        }\n        configuration_file=str_dup(real_path);\n        free(real_path);\n#else\n        configuration_file=str_dup(name);\n#endif\n#ifndef USE_WIN32\n    } else if(type==CONF_FD) {\n        configuration_file=str_dup(name);\n#endif\n    }\n    return options_parse(type);\n}", "target": 1}
{"code": "COMPAT_SYSCALL_DEFINE3(set_mempolicy, int, mode, compat_ulong_t __user *, nmask,\n\t\t       compat_ulong_t, maxnode)\n{\n\tlong err = 0;\n\tunsigned long __user *nm = NULL;\n\tunsigned long nr_bits, alloc_size;\n\tDECLARE_BITMAP(bm, MAX_NUMNODES);\n\tnr_bits = min_t(unsigned long, maxnode-1, MAX_NUMNODES);\n\talloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;\n\tif (nmask) {\n\t\terr = compat_get_bitmap(bm, nmask, nr_bits);\n\t\tnm = compat_alloc_user_space(alloc_size);\n\t\terr |= copy_to_user(nm, bm, alloc_size);\n\t}\n\tif (err)\n\t\treturn -EFAULT;\n\treturn sys_set_mempolicy(mode, nm, nr_bits+1);\n}", "target": 1}
{"code": "void ImageWriteJPEG(\n      Image const& image,\n      String const& filename,\n      dip::uint jpegLevel\n) {\n   DIP_THROW_IF( !image.IsForged(), E::IMAGE_NOT_FORGED );\n   DIP_THROW_IF( image.Dimensionality() != 2, E::DIMENSIONALITY_NOT_SUPPORTED );\n   jpegLevel = clamp< dip::uint >( jpegLevel, 1, 100 );\n   JpegOutput jpeg( filename );\n   int nchan = static_cast< int >( image.TensorElements() );\n   jpeg.cinfo().image_width = static_cast< JDIMENSION >( image.Size( 0 ));\n   jpeg.cinfo().image_height = static_cast< JDIMENSION >( image.Size( 1 ));\n   jpeg.cinfo().input_components = nchan;\n   jpeg.cinfo().in_color_space = nchan > 1 ? JCS_RGB : JCS_GRAYSCALE;\n   jpeg_set_defaults( jpeg.cinfoptr() );\n   jpeg_set_quality( jpeg.cinfoptr(), static_cast< int >( jpegLevel ), FALSE );\n   jpeg.cinfo().density_unit = 2; \n   jpeg.cinfo().X_density = static_cast< UINT16 >( 0.01 / image.PixelSize( 0 ).RemovePrefix().magnitude ); \n   jpeg.cinfo().Y_density = static_cast< UINT16 >( 0.01 / image.PixelSize( 1 ).RemovePrefix().magnitude );\n   Image image_u8 = image.QuickCopy();\n   image_u8.Convert( DT_UINT8 );\n   jpeg_start_compress( jpeg.cinfoptr(), TRUE );\n   std::vector< JSAMPLE > buffer( image.Size( 0 ) * static_cast< dip::uint >( nchan ));\n   dip::uint8* imagedata = static_cast< dip::uint8* >( image_u8.Origin() );\n   auto stride = image_u8.Strides();\n   auto tStride = image_u8.TensorStride();\n   for( dip::uint ii = 0; ii < image.Size( 1 ); ++ii ) {\n      JSAMPLE* outdata = buffer.data();\n      dip::uint8* indata = imagedata;\n      for( dip::uint jj = 0; jj < image.Size( 0 ); ++jj ) {\n         for( int kk = 0; kk < nchan; ++kk ) {\n            *outdata = *( indata + kk * tStride );\n            ++outdata;\n         }\n         indata += stride[ 0 ];\n      }\n      outdata = buffer.data();\n      jpeg_write_scanlines( jpeg.cinfoptr(), &outdata, 1 );\n      imagedata += stride[ 1 ];\n   }\n   jpeg_finish_compress( jpeg.cinfoptr());\n}", "target": 1}
{"code": "gfx::Rect RootWindowHostLinux::GetBounds() const {\n  return bounds_;\n}", "target": 0}
{"code": "spnego_gss_export_sec_context(\n\t\t\t    OM_uint32\t  *minor_status,\n\t\t\t    gss_ctx_id_t *context_handle,\n\t\t\t    gss_buffer_t interprocess_token)\n{\n\tOM_uint32 ret;\n\tret = gss_export_sec_context(minor_status,\n\t\t\t\t    context_handle,\n\t\t\t\t    interprocess_token);\n\treturn (ret);\n}", "target": 1}
{"code": "  void SetInput(const std::vector<float>& data) {\n    QuantizeAndPopulate<uint8_t>(input_, data);\n  }", "target": 0}
{"code": "pid_t LightProcess::proc_open(const char *cmd, const std::vector<int> &created,\n                              const std::vector<int> &desired,\n                              const char *cwd,\n                              const std::vector<std::string> &env) {\n  int id = GetId();\n  Lock lock(g_procs[id].m_procMutex);\n  always_assert(Available());\n  always_assert(created.size() == desired.size());\n  if (fprintf(g_procs[id].m_fout, \"proc_open\\n%s\\n%s\\n\", cmd, cwd) <= 0) {\n    Logger::Error(\"Failed to send command proc_open\");\n    return -1;\n  }\n  fprintf(g_procs[id].m_fout, \"%d\\n\", (int)env.size());\n  for (unsigned int i = 0; i < env.size(); i++) {\n    fprintf(g_procs[id].m_fout, \"%s\\n\", env[i].c_str());\n  }\n  fprintf(g_procs[id].m_fout, \"%d\\n\", (int)created.size());\n  for (unsigned int i = 0; i < desired.size(); i++) {\n    fprintf(g_procs[id].m_fout, \"%d\\n\", desired[i]);\n  }\n  fflush(g_procs[id].m_fout);\n  bool error_send = false;\n  int save_errno = 0;\n  for (unsigned int i = 0; i < created.size(); i++) {\n    if (!send_fd(g_procs[id].m_afdt_fd, created[i])) {\n      error_send = true;\n      save_errno = errno;\n      break;\n    }\n  }\n  char buf[BUFFER_SIZE];\n  read_buf(g_procs[id].m_fin, buf);\n  if (strncmp(buf, \"error\", 5) == 0) {\n    read_buf(g_procs[id].m_fin, buf);\n    sscanf(buf, \"%d\", &errno);\n    if (error_send) {\n      errno = save_errno;\n    }\n    return -1;\n  }\n  int64_t pid = -1;\n  sscanf(buf, \"%\" PRId64, &pid);\n  assert(pid);\n  return (pid_t)pid;\n}", "target": 1}
{"code": "void add_interrupt_randomness(int irq, int irq_flags)\n{\n\tstruct entropy_store\t*r;\n\tstruct fast_pool\t*fast_pool = this_cpu_ptr(&irq_randomness);\n\tstruct pt_regs\t\t*regs = get_irq_regs();\n\tunsigned long\t\tnow = jiffies;\n\tcycles_t\t\tcycles = random_get_entropy();\n\t__u32\t\t\tc_high, j_high;\n\t__u64\t\t\tip;\n\tunsigned long\t\tseed;\n\tint\t\t\tcredit = 0;\n\tif (cycles == 0)\n\t\tcycles = get_reg(fast_pool, regs);\n\tc_high = (sizeof(cycles) > 4) ? cycles >> 32 : 0;\n\tj_high = (sizeof(now) > 4) ? now >> 32 : 0;\n\tfast_pool->pool[0] ^= cycles ^ j_high ^ irq;\n\tfast_pool->pool[1] ^= now ^ c_high;\n\tip = regs ? instruction_pointer(regs) : _RET_IP_;\n\tfast_pool->pool[2] ^= ip;\n\tfast_pool->pool[3] ^= (sizeof(ip) > 4) ? ip >> 32 :\n\t\tget_reg(fast_pool, regs);\n\tfast_mix(fast_pool);\n\tadd_interrupt_bench(cycles);\n\tthis_cpu_add(net_rand_state.s1, fast_pool->pool[cycles & 3]);\n\tif (unlikely(crng_init == 0)) {\n\t\tif ((fast_pool->count >= 64) &&\n\t\t    crng_fast_load((char *) fast_pool->pool,\n\t\t\t\t   sizeof(fast_pool->pool))) {\n\t\t\tfast_pool->count = 0;\n\t\t\tfast_pool->last = now;\n\t\t}\n\t\treturn;\n\t}\n\tif ((fast_pool->count < 64) &&\n\t    !time_after(now, fast_pool->last + HZ))\n\t\treturn;\n\tr = &input_pool;\n\tif (!spin_trylock(&r->lock))\n\t\treturn;\n\tfast_pool->last = now;\n\t__mix_pool_bytes(r, &fast_pool->pool, sizeof(fast_pool->pool));\n\tif (arch_get_random_seed_long(&seed)) {\n\t\t__mix_pool_bytes(r, &seed, sizeof(seed));\n\t\tcredit = 1;\n\t}\n\tspin_unlock(&r->lock);\n\tfast_pool->count = 0;\n\tcredit_entropy_bits(r, credit + 1);\n}", "target": 0}
{"code": "static int action_getconfig(struct mansession *s, const struct message *m)\n{\n\tstruct ast_config *cfg;\n\tconst char *fn = astman_get_header(m, \"Filename\");\n\tconst char *category = astman_get_header(m, \"Category\");\n\tconst char *filter = astman_get_header(m, \"Filter\");\n\tconst char *category_name;\n\tint catcount = 0;\n\tint lineno = 0;\n\tstruct ast_category *cur_category = NULL;\n\tstruct ast_variable *v;\n\tstruct ast_flags config_flags = { CONFIG_FLAG_WITHCOMMENTS | CONFIG_FLAG_NOCACHE };\n\tif (ast_strlen_zero(fn)) {\n\t\tastman_send_error(s, m, \"Filename not specified\");\n\t\treturn 0;\n\t}\n\tif (restrictedFile(fn)) {\n\t\tastman_send_error(s, m, \"File requires escalated priveledges\");\n\t\treturn 0;\n\t}\n\tcfg = ast_config_load2(fn, \"manager\", config_flags);\n\tif (cfg == CONFIG_STATUS_FILEMISSING) {\n\t\tastman_send_error(s, m, \"Config file not found\");\n\t\treturn 0;\n\t} else if (cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tastman_send_error(s, m, \"Config file has invalid format\");\n\t\treturn 0;\n\t}\n\tastman_start_ack(s, m);\n\twhile ((cur_category = ast_category_browse_filtered(cfg, category, cur_category, filter))) {\n\t\tstruct ast_str *templates;\n\t\tcategory_name = ast_category_get_name(cur_category);\n\t\tlineno = 0;\n\t\tastman_append(s, \"Category-%06d: %s\\r\\n\", catcount, category_name);\n\t\tif (ast_category_is_template(cur_category)) {\n\t\t\tastman_append(s, \"IsTemplate-%06d: %d\\r\\n\", catcount, 1);\n\t\t}\n\t\tif ((templates = ast_category_get_templates(cur_category))\n\t\t\t&& ast_str_strlen(templates) > 0) {\n\t\t\tastman_append(s, \"Templates-%06d: %s\\r\\n\", catcount, ast_str_buffer(templates));\n\t\t\tast_free(templates);\n\t\t}\n\t\tfor (v = ast_category_first(cur_category); v; v = v->next) {\n\t\t\tastman_append(s, \"Line-%06d-%06d: %s=%s\\r\\n\", catcount, lineno++, v->name, v->value);\n\t\t}\n\t\tcatcount++;\n\t}\n\tif (!ast_strlen_zero(category) && catcount == 0) { \n\t\tastman_append(s, \"No categories found\\r\\n\");\n\t}\n\tast_config_destroy(cfg);\n\tastman_append(s, \"\\r\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "TEST(BasicFlatBufferModel, TestUnsupportedRecursion) {\n  const auto model_path =\n      \"tensorflow/lite/testdata/unsupported_recursion.bin\";\n  std::unique_ptr<tflite::FlatBufferModel> model =\n      FlatBufferModel::BuildFromFile(model_path);\n  ASSERT_NE(model, nullptr);\n  tflite::ops::builtin::BuiltinOpResolver resolver;\n  InterpreterBuilder builder(*model, resolver);\n  std::unique_ptr<Interpreter> interpreter;\n  ASSERT_EQ(builder(&interpreter), kTfLiteOk);\n  ASSERT_NE(interpreter, nullptr);\n  ASSERT_NE(interpreter->AllocateTensors(), kTfLiteOk);\n}", "target": 0}
{"code": " void RootWindowHostWin::UnConfineCursor() {\n   ClipCursor(NULL);\n }", "target": 0}
{"code": "ServerApp::help()\n{\n#if WINAPI_XWINDOWS\n#  define WINAPI_ARGS \\\n    \" [--display <display>] [--no-xinitthreads]\"\n#  define WINAPI_INFO \\\n    \"      --display <display>  connect to the X server at <display>\\n\" \\\n    \"      --no-xinitthreads    do not call XInitThreads()\\n\" \\\n    \"      --screen-change-script <path>\\n\" \\\n    \"                           full path to script to run on screen change\\n\" \\\n    \"                           first argument is the new screen name\\n\"\n#else\n#  define WINAPI_ARGS \"\"\n#  define WINAPI_INFO \"\"\n#endif\n    barrier::fs::path profile_path = argsBase().m_profileDirectory;\n    if (profile_path.empty()) {\n        profile_path = barrier::DataDirectories::profile();\n    }\n    auto usr_config_path = (profile_path / barrier::fs::u8path(USR_CONFIG_NAME)).u8string();\n    auto sys_config_path = (barrier::DataDirectories::systemconfig() /\n                            barrier::fs::u8path(SYS_CONFIG_NAME)).u8string();\n    std::ostringstream buffer;\n    buffer << \"Start the barrier server component.\\n\"\n           << \"\\n\"\n           << \"Usage: \" << args().m_exename\n           << \" [--address <address>]\"\n           << \" [--config <pathname>]\"\n           << WINAPI_ARGS << HELP_SYS_ARGS << HELP_COMMON_ARGS << \"\\n\"\n           << \"\\n\"\n           << \"Options:\\n\"\n           << \"  -a, --address <address>  listen for clients on the given address.\\n\"\n           << \"  -c, --config <pathname>  use the named configuration file instead.\\n\"\n           << HELP_COMMON_INFO_1 << WINAPI_INFO << HELP_SYS_INFO << HELP_COMMON_INFO_2 << \"\\n\"\n           << \"Default options are marked with a *\\n\"\n           << \"\\n\"\n           << \"The argument for --address is of the form: [<hostname>][:<port>].  The\\n\"\n           << \"hostname must be the address or hostname of an interface on the system.\\n\"\n           << \"Placing brackets around an IPv6 address is required when also specifying \\n\"\n           << \"a port number and optional otherwise. The default is to listen on all\\n\"\n           << \"interfaces using port number \" << kDefaultPort << \".\\n\"\n           << \"\\n\"\n           << \"If no configuration file pathname is provided then the first of the\\n\"\n           << \"following to load successfully sets the configuration:\\n\"\n           << \"  \" << usr_config_path << \"\\n\"\n           << \"  \" << sys_config_path << \"\\n\";\n    LOG((CLOG_PRINT \"%s\", buffer.str().c_str()));\n}", "target": 1}
{"code": "  void event_cb(drachtio::RequestHandler::GlobalInfo *g, curl_socket_t s,\n                       int action, const boost::system::error_code & error,\n                       int *fdp) {\n    std::shared_ptr<RequestHandler> p = RequestHandler::getInstance() ;\n    std::map<curl_socket_t, boost::asio::ip::tcp::socket *>& socket_map = p->getSocketMap() ;\n    boost::asio::deadline_timer& timer = p->getTimer() ;\n    if(socket_map.find(s) == socket_map.end()) {\n      DR_LOG(log_error) << \"event_cb: socket already closed\";\n      return;\n    }\n    if(*fdp == action || *fdp == CURL_POLL_INOUT) {\n      CURLMcode rc;\n      if(error)\n        action = CURL_CSELECT_ERR;\n      rc = curl_multi_socket_action(g->multi, s, action, &g->still_running);\n      mcode_test(\"event_cb: curl_multi_socket_action\", rc);\n      check_multi_info(g);\n      if(g->still_running <= 0) {\n        timer.cancel();\n      }\n      if(!error && socket_map.find(s) != socket_map.end() &&\n         (*fdp == action || *fdp == CURL_POLL_INOUT)) {\n        boost::asio::ip::tcp::socket *tcp_socket = socket_map.find(s)->second;\n        if(action == CURL_POLL_IN) {\n          tcp_socket->async_read_some(boost::asio::null_buffers(),\n                                      boost::bind(&event_cb, g, s,\n                                                  action, boost::placeholders::_1, fdp));\n        }\n        if(action == CURL_POLL_OUT) {\n          tcp_socket->async_write_some(boost::asio::null_buffers(),\n                                       boost::bind(&event_cb, g, s,\n                                                   action, boost::placeholders::_1, fdp));\n        } \n      }\n    }\n  }", "target": 1}
{"code": "pixBlockconvGrayUnnormalized(PIX     *pixs,\n                             l_int32  wc,\n                             l_int32  hc)\n{\nl_int32    i, j, w, h, d, wpla, wpld, jmax;\nl_uint32  *linemina, *linemaxa, *lined, *dataa, *datad;\nPIX       *pixsb, *pixacc, *pixd;\n    PROCNAME(\"pixBlockconvGrayUnnormalized\");\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (d != 8)\n        return (PIX *)ERROR_PTR(\"pixs not 8 bpp\", procName, NULL);\n    if (wc < 0) wc = 0;\n    if (hc < 0) hc = 0;\n    if (w < 2 * wc + 1 || h < 2 * hc + 1) {\n        wc = L_MIN(wc, (w - 1) / 2);\n        hc = L_MIN(hc, (h - 1) / 2);\n        L_WARNING(\"kernel too large; reducing!\\n\", procName);\n        L_INFO(\"wc = %d, hc = %d\\n\", procName, wc, hc);\n    }\n    if (wc == 0 && hc == 0)   \n        return pixCopy(NULL, pixs);\n    if ((pixsb = pixAddMirroredBorder(pixs, wc + 1, wc, hc + 1, hc)) == NULL)\n        return (PIX *)ERROR_PTR(\"pixsb not made\", procName, NULL);\n    pixacc = pixBlockconvAccum(pixsb);\n    pixDestroy(&pixsb);\n    if (!pixacc)\n        return (PIX *)ERROR_PTR(\"pixacc not made\", procName, NULL);\n    if ((pixd = pixCreate(w, h, 32)) == NULL) {\n        pixDestroy(&pixacc);\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n    }\n    wpla = pixGetWpl(pixacc);\n    wpld = pixGetWpl(pixd);\n    datad = pixGetData(pixd);\n    dataa = pixGetData(pixacc);\n    for (i = 0; i < h; i++) {\n        lined = datad + i * wpld;\n        linemina = dataa + i * wpla;\n        linemaxa = dataa + (i + 2 * hc + 1) * wpla;\n        for (j = 0; j < w; j++) {\n            jmax = j + 2 * wc + 1;\n            lined[j] = linemaxa[jmax] - linemaxa[j] -\n                       linemina[jmax] + linemina[j];\n        }\n    }\n    pixDestroy(&pixacc);\n    return pixd;\n}", "target": 1}
{"code": "spnego_gss_inquire_sec_context_by_oid(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tconst gss_OID desired_object,\n\t\tgss_buffer_set_t *data_set)\n{\n\tOM_uint32 ret;\n\tret = gss_inquire_sec_context_by_oid(minor_status,\n\t\t\t    context_handle,\n\t\t\t    desired_object,\n\t\t\t    data_set);\n\treturn (ret);\n}", "target": 1}
{"code": "SQLWCHAR* _multi_string_alloc_and_expand( LPCSTR in )\n{\n    SQLWCHAR *chr;\n    int len = 0;\n    if ( !in )\n    {\n        return in;\n    }\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        len ++;\n    }\n    chr = malloc(sizeof( SQLWCHAR ) * ( len + 2 ));\n    len = 0;\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        chr[ len ] = in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = 0;\n    chr[ len ++ ] = 0;\n    return chr;\n}", "target": 1}
{"code": "bool HTMLMediaElement::ShouldShowControls(\n    const RecordMetricsBehavior record_metrics) const {\n  Settings* settings = GetDocument().GetSettings();\n  if (settings && !settings->GetMediaControlsEnabled()) {\n    if (record_metrics == RecordMetricsBehavior::kDoRecord)\n      ShowControlsHistogram().Count(kMediaControlsShowDisabledSettings);\n    return false;\n  }\n  if (FastHasAttribute(kControlsAttr)) {\n    if (record_metrics == RecordMetricsBehavior::kDoRecord)\n      ShowControlsHistogram().Count(kMediaControlsShowAttribute);\n    return true;\n  }\n  if (IsFullscreen()) {\n    if (record_metrics == RecordMetricsBehavior::kDoRecord)\n      ShowControlsHistogram().Count(kMediaControlsShowFullscreen);\n    return true;\n  }\n  LocalFrame* frame = GetDocument().GetFrame();\n  if (frame && !GetDocument().CanExecuteScripts(kNotAboutToExecuteScript)) {\n    if (record_metrics == RecordMetricsBehavior::kDoRecord)\n      ShowControlsHistogram().Count(kMediaControlsShowNoScript);\n    return true;\n  }\n  if (record_metrics == RecordMetricsBehavior::kDoRecord)\n    ShowControlsHistogram().Count(kMediaControlsShowNotShown);\n  return false;\n}", "target": 0}
{"code": "relax_ng_parse(const char *path, xml_read_cb cb, void *arg)\n{\n\txmlTextReaderPtr reader;\n\txmlRelaxNGValidCtxtPtr rngvalidctx;\n\tint read;\n\tint error;\n\treader = xmlNewTextReaderFilename(path);\n\tif (reader == NULL)\n\t\treturn pr_val_err(\"Couldn't get XML '%s' file.\", path);\n\terror = xmlTextReaderRelaxNGSetSchema(reader, schema);\n\tif (error) {\n\t\terror = pr_val_err(\"Couldn't set Relax NG schema.\");\n\t\tgoto free_reader;\n\t}\n\trngvalidctx = xmlRelaxNGNewValidCtxt(schema);\n\tif (rngvalidctx == NULL) {\n\t\terror = pr_val_err(\"xmlRelaxNGNewValidCtxt() returned NULL\");\n\t\tgoto free_reader;\n\t}\n\txmlRelaxNGSetValidErrors(rngvalidctx, relax_ng_log_err,\n\t    relax_ng_log_warn, NULL);\n\terror = xmlTextReaderRelaxNGValidateCtxt(reader, rngvalidctx, 1);\n\tif (error) {\n\t\terror = pr_val_err(\"Invalid XML document\");\n\t\tgoto free_valid_ctx;\n\t}\n\txmlTextReaderSetStructuredErrorHandler(reader, relax_ng_log_str_err,\n\t    NULL);\n\twhile ((read = xmlTextReaderRead(reader)) == 1) {\n\t\tif (xmlTextReaderIsValid(reader) <= 0) {\n\t\t\terror = pr_val_err(\"XML document isn't valid.\");\n\t\t\tgoto free_valid_ctx;\n\t\t}\n\t\terror = cb(reader, arg);\n\t\tif (error)\n\t\t\tgoto free_valid_ctx;\n\t}\n\tif (read < 0) {\n\t\terror = pr_val_err(\"Error parsing XML document.\");\n\t\tgoto free_valid_ctx;\n\t}\n\tif (xmlTextReaderIsValid(reader) <= 0) {\n\t\terror = pr_val_err(\"XML document isn't valid.\");\n\t\tgoto free_valid_ctx;\n\t}\n\txmlRelaxNGFreeValidCtxt(rngvalidctx);\n\txmlFreeTextReader(reader);\n\treturn 0;\nfree_valid_ctx:\n\txmlRelaxNGFreeValidCtxt(rngvalidctx);\nfree_reader:\n\txmlFreeTextReader(reader);\n\treturn error;\n}", "target": 1}
{"code": "DumpIoStats(Mgr::IoActionData& stats, StoreEntry* sentry)\n{\n    int i;\n    storeAppendPrintf(sentry, \"HTTP I/O\\n\");\n    storeAppendPrintf(sentry, \"number of reads: %.0f\\n\", stats.http_reads);\n    storeAppendPrintf(sentry, \"Read Histogram:\\n\");\n    for (i = 0; i < IoStats::histSize; ++i) {\n        storeAppendPrintf(sentry, \"%5d-%5d: %9.0f %2.0f%%\\n\",\n                          i ? (1 << (i - 1)) + 1 : 1,\n                          1 << i,\n                          stats.http_read_hist[i],\n                          Math::doublePercent(stats.http_read_hist[i], stats.http_reads));\n    }\n    storeAppendPrintf(sentry, \"\\n\");\n    storeAppendPrintf(sentry, \"FTP I/O\\n\");\n    storeAppendPrintf(sentry, \"number of reads: %.0f\\n\", stats.ftp_reads);\n    storeAppendPrintf(sentry, \"Read Histogram:\\n\");\n    for (i = 0; i < IoStats::histSize; ++i) {\n        storeAppendPrintf(sentry, \"%5d-%5d: %9.0f %2.0f%%\\n\",\n                          i ? (1 << (i - 1)) + 1 : 1,\n                          1 << i,\n                          stats.ftp_read_hist[i],\n                          Math::doublePercent(stats.ftp_read_hist[i], stats.ftp_reads));\n    }\n    storeAppendPrintf(sentry, \"\\n\");\n    storeAppendPrintf(sentry, \"Gopher I/O\\n\");\n    storeAppendPrintf(sentry, \"number of reads: %.0f\\n\", stats.gopher_reads);\n    storeAppendPrintf(sentry, \"Read Histogram:\\n\");\n    for (i = 0; i < IoStats::histSize; ++i) {\n        storeAppendPrintf(sentry, \"%5d-%5d: %9.0f %2.0f%%\\n\",\n                          i ? (1 << (i - 1)) + 1 : 1,\n                          1 << i,\n                          stats.gopher_read_hist[i],\n                          Math::doublePercent(stats.gopher_read_hist[i], stats.gopher_reads));\n    }\n    storeAppendPrintf(sentry, \"\\n\");\n}", "target": 1}
{"code": "    bool read(ReadonlyBytes buffer)\n    {\n        auto fields_size = sizeof(EndOfCentralDirectory) - sizeof(u8*);\n        if (buffer.size() < fields_size)\n            return false;\n        if (memcmp(buffer.data(), end_of_central_directory_signature, sizeof(end_of_central_directory_signature)) != 0)\n            return false;\n        memcpy(reinterpret_cast<void*>(&disk_number), buffer.data() + sizeof(end_of_central_directory_signature), fields_size);\n        comment = buffer.data() + sizeof(end_of_central_directory_signature) + fields_size;\n        return true;\n    }", "target": 1}
{"code": "void luaD_call (lua_State *L, StkId func, int nresults) {\n  lua_CFunction f;\n retry:\n  switch (ttypetag(s2v(func))) {\n    case LUA_VCCL:  \n      f = clCvalue(s2v(func))->f;\n      goto Cfunc;\n    case LUA_VLCF:  \n      f = fvalue(s2v(func));\n     Cfunc: {\n      int n;  \n      CallInfo *ci = next_ci(L);\n      checkstackp(L, LUA_MINSTACK, func);  \n      ci->nresults = nresults;\n      ci->callstatus = CIST_C;\n      ci->top = L->top + LUA_MINSTACK;\n      ci->func = func;\n      L->ci = ci;\n      lua_assert(ci->top <= L->stack_last);\n      if (L->hookmask & LUA_MASKCALL) {\n        int narg = cast_int(L->top - func) - 1;\n        luaD_hook(L, LUA_HOOKCALL, -1, 1, narg);\n      }\n      lua_unlock(L);\n      n = (*f)(L);  \n      lua_lock(L);\n      api_checknelems(L, n);\n      luaD_poscall(L, ci, n);\n      break;\n    }\n    case LUA_VLCL: {  \n      CallInfo *ci = next_ci(L);\n      Proto *p = clLvalue(s2v(func))->p;\n      int narg = cast_int(L->top - func) - 1;  \n      int nfixparams = p->numparams;\n      int fsize = p->maxstacksize;  \n      checkstackp(L, fsize, func);\n      ci->nresults = nresults;\n      ci->u.l.savedpc = p->code;  \n      ci->callstatus = 0;\n      ci->top = func + 1 + fsize;\n      ci->func = func;\n      L->ci = ci;\n      for (; narg < nfixparams; narg++)\n        setnilvalue(s2v(L->top++));  \n      lua_assert(ci->top <= L->stack_last);\n      luaV_execute(L, ci);  \n      break;\n    }\n    default: {  \n      checkstackp(L, 1, func);  \n      luaD_tryfuncTM(L, func);  \n      goto retry;  \n    }\n  }\n}", "target": 1}
{"code": "static int client_mpvio_read_packet(struct st_plugin_vio *mpv, uchar **buf)\n{\n  MCPVIO_EXT *mpvio= (MCPVIO_EXT*)mpv;\n  MYSQL *mysql= mpvio->mysql;\n  ulong  pkt_len;\n  if (mpvio->cached_server_reply.pkt)\n  {\n    *buf= mpvio->cached_server_reply.pkt;\n    mpvio->cached_server_reply.pkt= 0;\n    mpvio->packets_read++;\n    return mpvio->cached_server_reply.pkt_len;\n  }\n  if (mpvio->packets_read == 0)\n  {\n    if (client_mpvio_write_packet(mpv, 0, 0))\n      return (int)packet_error;\n  }\n  pkt_len= (*mysql->methods->read_change_user_result)(mysql);\n  mpvio->last_read_packet_len= pkt_len;\n  *buf= mysql->net.read_pos;\n  if (pkt_len == packet_error || **buf == 254)\n    return (int)packet_error; \n  if (pkt_len && **buf == 1)\n  {\n    (*buf)++;\n    pkt_len--;\n  }\n  mpvio->packets_read++;\n  return pkt_len;\n}", "target": 0}
{"code": "file_push_buffer(struct magic_set *ms)\n{\n\tfile_pushbuf_t *pb;\n\tif (ms->event_flags & EVENT_HAD_ERR)\n\t\treturn NULL;\n\tif ((pb = (CAST(file_pushbuf_t *, malloc(sizeof(*pb))))) == NULL)\n\t\treturn NULL;\n\tpb->buf = ms->o.buf;\n\tpb->offset = ms->offset;\n\tms->o.buf = NULL;\n\tms->offset = 0;\n\treturn pb;\n}", "target": 0}
{"code": "dns_lookup_timerwrap(dns_answer *dnsa, const uschar *name, int type,\n  const uschar **fully_qualified_name)\n{\nint retval;\nunsigned long time_msec;\nif (!slow_lookup_log)\n  return dns_lookup(dnsa, name, type, fully_qualified_name);\ntime_msec = get_time_in_ms();\nretval = dns_lookup(dnsa, name, type, fully_qualified_name);\nif ((time_msec = get_time_in_ms() - time_msec) > slow_lookup_log)\n  log_long_lookup(US\"name\", name, time_msec);\nreturn retval;\n}", "target": 0}
{"code": "int __fastcall BatchSettings(TConsole * Console, TProgramParams * Params)\n{\n  int Result = RESULT_SUCCESS;\n  try\n  {\n    std::unique_ptr<TStrings> Arguments(new TStringList());\n    if (!DebugAlwaysTrue(Params->FindSwitch(L\"batchsettings\", Arguments.get())))\n    {\n      Abort();\n    }\n    else\n    {\n      if (Arguments->Count < 1)\n      {\n        throw Exception(LoadStr(BATCH_SET_NO_MASK));\n      }\n      else if (Arguments->Count < 2)\n      {\n        throw Exception(LoadStr(BATCH_SET_NO_SETTINGS));\n      }\n      else\n      {\n        TFileMasks Mask(Arguments->Strings[0]);\n        Arguments->Delete(0);\n        std::unique_ptr<TOptionsStorage> OptionsStorage(new TOptionsStorage(Arguments.get(), false));\n        int Matches = 0;\n        int Changes = 0;\n        for (int Index = 0; Index < StoredSessions->Count; Index++)\n        {\n          TSessionData * Data = StoredSessions->Sessions[Index];\n          if (!Data->IsWorkspace &&\n              Mask.Matches(Data->Name, false, false))\n          {\n            Matches++;\n            std::unique_ptr<TSessionData> OriginalData(new TSessionData(L\"\"));\n            OriginalData->CopyDataNoRecrypt(Data);\n            Data->ApplyRawSettings(OptionsStorage.get());\n            bool Changed = !OriginalData->IsSame(Data, false);\n            if (Changed)\n            {\n              Changes++;\n            }\n            UnicodeString StateStr = LoadStr(Changed ? BATCH_SET_CHANGED : BATCH_SET_NOT_CHANGED);\n            Console->PrintLine(FORMAT(L\"%s - %s\", (Data->Name, StateStr)));\n          }\n        }\n        StoredSessions->Save(false, true); \n        Console->PrintLine(FMTLOAD(BATCH_SET_SUMMARY, (Matches, Changes)));\n      }\n    }\n  }\n  catch (Exception & E)\n  {\n    Result = HandleException(Console, E);\n  }\n  Console->WaitBeforeExit();\n  return Result;\n}", "target": 1}
{"code": "static int rm_read_multi(AVFormatContext *s, AVIOContext *pb,\n                         AVStream *st, char *mime)\n{\n    int number_of_streams = avio_rb16(pb);\n    int number_of_mdpr;\n    int i, ret;\n    unsigned size2;\n    for (i = 0; i<number_of_streams; i++)\n        avio_rb16(pb);\n    number_of_mdpr = avio_rb16(pb);\n    if (number_of_mdpr != 1) {\n        avpriv_request_sample(s, \"MLTI with multiple (%d) MDPR\", number_of_mdpr);\n    }\n    for (i = 0; i < number_of_mdpr; i++) {\n        AVStream *st2;\n        if (i > 0) {\n            st2 = avformat_new_stream(s, NULL);\n            if (!st2) {\n                ret = AVERROR(ENOMEM);\n                return ret;\n            }\n            st2->id = st->id + (i<<16);\n            st2->codecpar->bit_rate = st->codecpar->bit_rate;\n            st2->start_time = st->start_time;\n            st2->duration   = st->duration;\n            st2->codecpar->codec_type = AVMEDIA_TYPE_DATA;\n            st2->priv_data = ff_rm_alloc_rmstream();\n            if (!st2->priv_data)\n                return AVERROR(ENOMEM);\n        } else\n            st2 = st;\n        size2 = avio_rb32(pb);\n        ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,\n                                        size2, mime);\n        if (ret < 0)\n            return ret;\n    }\n    return 0;\n}", "target": 1}
{"code": "void WebContentsImpl::SetParentNativeViewAccessible(\ngfx::NativeViewAccessible accessible_parent) {\n  accessible_parent_ = accessible_parent;\n  if (GetRenderViewHost())\n    GetRenderViewHostImpl()->SetParentNativeViewAccessible(accessible_parent);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input_indices_in = context->input(0);\n    const Tensor& input_shape_in = context->input(1);\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices_in.shape()),\n                errors::InvalidArgument(\"Input must be a matrix.\"));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape_in.shape()),\n                errors::InvalidArgument(\"Input shape must be a vector.\"));\n    OP_REQUIRES(context,\n                input_indices_in.dim_size(1) == input_shape_in.dim_size(0),\n                errors::InvalidArgument(\n                    \"Input tensor rank must match input shape length.\"));\n    ReshapeSparseTensor<Device>(context, context->input(0), context->input(1),\n                                context->input(2), 0 ,\n                                1 );\n  }", "target": 0}
{"code": "TEST_P(LocalJwksIntegrationTest, ConnectRequestWithRegExMatch) {\n  config_helper_.prependFilter(getAuthFilterConfig(ExampleConfigWithRegEx, true));\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto encoder_decoder = codec_client_->startRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"CONNECT\"},\n      {\":authority\", \"host.com:80\"},\n      {\"authorization\", \"Bearer \" + std::string(GoodToken)},\n  });\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n  if (downstreamProtocol() == Http::CodecType::HTTP1) {\n    ASSERT_TRUE(response->waitForEndStream());\n    ASSERT_TRUE(response->complete());\n    EXPECT_EQ(\"404\", response->headers().getStatusValue());\n  } else {\n    ASSERT_TRUE(response->waitForReset());\n    ASSERT_TRUE(codec_client_->waitForDisconnect());\n  }\n}", "target": 0}
{"code": "static BOOL nsc_rle_decompress_data(NSC_CONTEXT* context)\n{\n\tif (!context)\n\t\treturn FALSE;\n\tBYTE* rle = context->Planes;\n\tWINPR_ASSERT(rle);\n\tfor (size_t i = 0; i < 4; i++)\n\t{\n\t\tconst UINT32 originalSize = context->OrgByteCount[i];\n\t\tconst UINT32 planeSize = context->PlaneByteCount[i];\n\t\tif (planeSize == 0)\n\t\t{\n\t\t\tif (context->priv->PlaneBuffersLength < originalSize)\n\t\t\t\treturn FALSE;\n\t\t\tFillMemory(context->priv->PlaneBuffers[i], originalSize, 0xFF);\n\t\t}\n\t\telse if (planeSize < originalSize)\n\t\t{\n\t\t\tif (!nsc_rle_decode(rle, context->priv->PlaneBuffers[i],\n\t\t\t                    context->priv->PlaneBuffersLength, originalSize))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (context->priv->PlaneBuffersLength < originalSize)\n\t\t\t\treturn FALSE;\n\t\t\tCopyMemory(context->priv->PlaneBuffers[i], rle, originalSize);\n\t\t}\n\t\trle += planeSize;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "void Statement::Work_AfterReset(napi_env e, napi_status status, void* data) {\n    std::unique_ptr<Baton> baton(static_cast<Baton*>(data));\n    Statement* stmt = baton->stmt;\n    Napi::Env env = stmt->Env();\n    Napi::HandleScope scope(env);\n    Napi::Function cb = baton->callback.Value();\n    if (!cb.IsUndefined() && cb.IsFunction()) {\n        Napi::Value argv[] = { env.Null() };\n        TRY_CATCH_CALL(stmt->Value(), cb, 1, argv);\n    }\n    STATEMENT_END();\n}", "target": 0}
{"code": "simple_upscale(j_decompress_ptr cinfo,\n               JDIFFROW diff_buf, _JSAMPROW output_buf, JDIMENSION width)\n{\n  do {\n#if BITS_IN_JSAMPLE == 12\n    *output_buf++ = (_JSAMPLE)((*diff_buf++ << cinfo->Al) & 0xFFF);\n#else\n    *output_buf++ = (_JSAMPLE)(*diff_buf++ << cinfo->Al);\n#endif\n  } while (--width);\n}", "target": 0}
{"code": "getRootParserOf(XML_Parser parser, unsigned int *outLevelDiff) {\n  XML_Parser rootParser = parser;\n  unsigned int stepsTakenUpwards = 0;\n  while (rootParser->m_parentParser) {\n    rootParser = rootParser->m_parentParser;\n    stepsTakenUpwards++;\n  }\n  assert(! rootParser->m_parentParser);\n  if (outLevelDiff != NULL) {\n    *outLevelDiff = stepsTakenUpwards;\n  }\n  return rootParser;\n}", "target": 0}
{"code": "modify_principal_2_svc(mprinc_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    restriction_t                   *rp;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->rec.principal, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,\n                               arg->rec.principal, &rp)\n        || kadm5int_acl_impose_restrictions(handle->context,\n                                            &arg->rec, &arg->mask, rp)) {\n        ret.code = KADM5_AUTH_MODIFY;\n        log_unauth(\"kadm5_modify_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_modify_principal((void *)handle, &arg->rec,\n                                          arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_modify_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "juniper_atm1_print(netdissect_options *ndo,\n                   const struct pcap_pkthdr *h, register const u_char *p)\n{\n        int llc_hdrlen;\n        struct juniper_l2info_t l2info;\n        l2info.pictype = DLT_JUNIPER_ATM1;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        if (l2info.cookie[0] == 0x80) { \n            oam_print(ndo, p, l2info.length, ATM_OAM_NOHEC);\n            return l2info.header_len;\n        }\n        if (EXTRACT_24BITS(p) == 0xfefe03 || \n            EXTRACT_24BITS(p) == 0xaaaa03) { \n            llc_hdrlen = llc_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);\n            if (llc_hdrlen > 0)\n                return l2info.header_len;\n        }\n        if (p[0] == 0x03) { \n            isoclns_print(ndo, p + 1, l2info.length - 1, l2info.caplen - 1);\n            return l2info.header_len;\n        }\n        if (ip_heuristic_guess(ndo, p, l2info.length) != 0) \n            return l2info.header_len;\n\treturn l2info.header_len;\n}", "target": 1}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_rti_annotations_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaAttrInfo *attr = NULL;\n\tut64 offset = 0;\n\tattr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_RUNTIME_INVISIBLE_ANNOTATION_ATTR;\n\t\tattr->info.annotation_array.num_annotations = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->info.annotation_array.annotations = r_list_newf (r_bin_java_annotation_free);\n\t\tfor (i = 0; i < attr->info.rtv_annotations_attr.num_annotations; i++) {\n\t\t\tif (offset >= sz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRBinJavaAnnotation *annotation = r_bin_java_annotation_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (annotation) {\n\t\t\t\toffset += annotation->size;\n\t\t\t}\n\t\t\tr_list_append (attr->info.annotation_array.annotations, (void *) annotation);\n\t\t}\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}", "target": 1}
{"code": "open_log_file(const char *name, const char *prog, const char *namespace, const char *instance)\n{\n\tchar *file_name;\n\tif (log_file) {\n\t\tfclose(log_file);\n\t\tlog_file = NULL;\n\t}\n\tif (!name)\n\t\treturn;\n\tfile_name = make_file_name(name, prog, namespace, instance);\n\tlog_file = fopen(file_name, \"a\");\n\tif (log_file) {\n\t\tint n = fileno(log_file);\n\t\tfcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));\n\t\tfcntl(n, F_SETFL, O_NONBLOCK | fcntl(n, F_GETFL));\n\t}\n\tFREE(file_name);\n}", "target": 1}
{"code": "static const EVP_MD *tpm_algorithm_to_openssl_digest(TPMI_ALG_HASH algorithm) {\n    switch(algorithm) {\n    case TPM_ALG_SHA1:\n        return EVP_sha1();\n    case ALG_SHA256_VALUE:\n        return EVP_sha256();\n    case TPM_ALG_SHA384:\n        return EVP_sha384();\n    case TPM_ALG_SHA512:\n        return EVP_sha512();\n    default:\n        return NULL;\n    }\n}", "target": 0}
{"code": "service_info *FindServiceControlURLPath(\n\tservice_table *table, const char *controlURLPath)\n{\n\tservice_info *finger = NULL;\n\turi_type parsed_url;\n\turi_type parsed_url_in;\n\tif (table && parse_uri(controlURLPath,\n\t\t\t     strlen(controlURLPath),\n\t\t\t     &parsed_url_in) == HTTP_SUCCESS) {\n\t\tfinger = table->serviceList;\n\t\twhile (finger) {\n\t\t\tif (finger->controlURL) {\n\t\t\t\tif (parse_uri(finger->controlURL,\n\t\t\t\t\t    strlen(finger->controlURL),\n\t\t\t\t\t    &parsed_url) == HTTP_SUCCESS) {\n\t\t\t\t\tif (!token_cmp(&parsed_url.pathquery,\n\t\t\t\t\t\t    &parsed_url_in.pathquery)) {\n\t\t\t\t\t\treturn finger;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinger = finger->next;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static int rndis_set_response(struct rndis_params *params,\n\t\t\t      rndis_set_msg_type *buf)\n{\n\tu32 BufLength, BufOffset;\n\trndis_set_cmplt_type *resp;\n\trndis_resp_t *r;\n\tr = rndis_add_response(params, sizeof(rndis_set_cmplt_type));\n\tif (!r)\n\t\treturn -ENOMEM;\n\tresp = (rndis_set_cmplt_type *)r->buf;\n\tBufLength = le32_to_cpu(buf->InformationBufferLength);\n\tBufOffset = le32_to_cpu(buf->InformationBufferOffset);\n#ifdef\tVERBOSE_DEBUG\n\tpr_debug(\"%s: Length: %d\\n\", __func__, BufLength);\n\tpr_debug(\"%s: Offset: %d\\n\", __func__, BufOffset);\n\tpr_debug(\"%s: InfoBuffer: \", __func__);\n\tfor (i = 0; i < BufLength; i++) {\n\t\tpr_debug(\"%02x \", *(((u8 *) buf) + i + 8 + BufOffset));\n\t}\n\tpr_debug(\"\\n\");\n#endif\n\tresp->MessageType = cpu_to_le32(RNDIS_MSG_SET_C);\n\tresp->MessageLength = cpu_to_le32(16);\n\tresp->RequestID = buf->RequestID; \n\tif (gen_ndis_set_resp(params, le32_to_cpu(buf->OID),\n\t\t\t((u8 *)buf) + 8 + BufOffset, BufLength, r))\n\t\tresp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);\n\telse\n\t\tresp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n\tparams->resp_avail(params->v);\n\treturn 0;\n}", "target": 1}
{"code": "bool ValidateInput(const Tensor& updates) {\n  const auto updates_flat = updates.flat<T>();\n  const T zero(0);\n  for (int i = 0; i < updates.NumElements(); i++) {\n    if (updates_flat(i) == zero) return false;\n  }\n  return true;\n}", "target": 0}
{"code": "static int do_i2c_loop(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t       char *const argv[])\n{\n\tuint\tchip;\n\tint alen;\n\tuint\taddr;\n\tuint\tlength;\n\tu_char\tbytes[16];\n\tint\tdelay;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\tif (argc < 3)\n\t\treturn CMD_RET_USAGE;\n\tchip = hextoul(argv[1], NULL);\n\taddr = hextoul(argv[2], NULL);\n\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn CMD_RET_USAGE;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n#endif\n\tlength = 1;\n\tlength = hextoul(argv[3], NULL);\n\tif (length > sizeof(bytes))\n\t\tlength = sizeof(bytes);\n\tdelay = 1000;\n\tif (argc > 3)\n\t\tdelay = dectoul(argv[4], NULL);\n\twhile (1) {\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_read(dev, addr, bytes, length);\n#else\n\t\tret = i2c_read(chip, addr, alen, bytes, length);\n#endif\n\t\tif (ret)\n\t\t\ti2c_report_err(ret, I2C_ERR_READ);\n\t\tudelay(delay);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "frag6_print(netdissect_options *ndo, register const u_char *bp, register const u_char *bp2)\n{\n\tregister const struct ip6_frag *dp;\n\tregister const struct ip6_hdr *ip6;\n\tdp = (const struct ip6_frag *)bp;\n\tip6 = (const struct ip6_hdr *)bp2;\n\tND_TCHECK(dp->ip6f_offlg);\n\tif (ndo->ndo_vflag) {\n\t\tND_PRINT((ndo, \"frag (0x%08x:%d|%ld)\",\n\t\t       EXTRACT_32BITS(&dp->ip6f_ident),\n\t\t       EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK,\n\t\t       sizeof(struct ip6_hdr) + EXTRACT_16BITS(&ip6->ip6_plen) -\n\t\t\t       (long)(bp - bp2) - sizeof(struct ip6_frag)));\n\t} else {\n\t\tND_PRINT((ndo, \"frag (%d|%ld)\",\n\t\t       EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK,\n\t\t       sizeof(struct ip6_hdr) + EXTRACT_16BITS(&ip6->ip6_plen) -\n\t\t\t       (long)(bp - bp2) - sizeof(struct ip6_frag)));\n\t}\n\tif ((EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK) != 0)\n\t\treturn -1;\n\telse\n\t{\n\t\tND_PRINT((ndo, \" \"));\n\t\treturn sizeof(struct ip6_frag);\n\t}\ntrunc:\n\tND_PRINT((ndo, \"[|frag]\"));\n\treturn -1;\n}", "target": 1}
{"code": "void Item_decimal::print(String *str, enum_query_type query_type)\n{\n  my_decimal2string(E_DEC_FATAL_ERROR, &decimal_value, 0, 0, 0, &str_value);\n  str->append(str_value);\n}", "target": 0}
{"code": "static int update_alu_sanitation_state(struct bpf_insn_aux_data *aux,\n\t\t\t\t       u32 alu_state, u32 alu_limit)\n{\n\tif (aux->alu_state &&\n\t    (aux->alu_state != alu_state ||\n\t     aux->alu_limit != alu_limit))\n\t\treturn -EACCES;\n\taux->alu_state = alu_state;\n\taux->alu_limit = alu_limit;\n\treturn 0;\n}", "target": 0}
{"code": "static int DefragBsdMissingFragmentIpv4Test(void)\n{\n    DefragInit();\n    default_policy = DEFRAG_POLICY_BSD;\n    Packet *packets[5];\n    packets[0] = BuildIpv4TestPacketWithContent(\n            IPPROTO_ICMP, 189, 16 >> 3, 1, (uint8_t *)\"AABBCCDDAABBDDCC\", 16);\n    packets[1] =\n            BuildIpv4TestPacketWithContent(IPPROTO_ICMP, 189, 40 >> 3, 1, (uint8_t *)\"AACCBBDD\", 8);\n    packets[2] = BuildIpv4TestPacketWithContent(\n            IPPROTO_ICMP, 189, 8 >> 3, 1, (uint8_t *)\"AACCDDBBAADDBBCC\", 16);\n    packets[3] = BuildIpv4TestPacketWithContent(IPPROTO_ICMP, 189, 0, 1, (uint8_t *)\"ZZZZZZZZ\", 8);\n    packets[4] =\n            BuildIpv4TestPacketWithContent(IPPROTO_ICMP, 189, 48 >> 3, 0, (uint8_t *)\"DDCCBBAA\", 8);\n    Packet *r = Defrag(NULL, NULL, packets[0]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[1]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[2]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[3]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[4]);\n    FAIL_IF_NOT_NULL(r);\n#if 0\n    PrintRawDataFp(stdout, GET_PKT_DATA(r) + 20, GET_PKT_LEN(r) - 20);\n#endif\n    for (int i = 0; i < 5; i++) {\n        SCFree(packets[i]);\n    }\n    DefragDestroy();\n    PASS;\n}", "target": 0}
{"code": "static inline unsigned char *skb_inner_mac_header(const struct sk_buff *skb)\n{\n\treturn skb->inner_mac_header;\n}", "target": 0}
{"code": "GF_Err trak_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\tif (ptr->sample_encryption && ptr->sample_encryption->load_needed) {\n\t\tif (!ptr->moov || !!ptr->moov->mov || !ptr->moov->mov->movieFileMap)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tGF_Err e = senc_Parse(ptr->moov->mov->movieFileMap->bs, ptr, NULL, ptr->sample_encryption);\n\t\tif (e) return e;\n\t}\n\tgf_isom_check_position(s, (GF_Box *)ptr->Header, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->Aperture, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->References, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->editBox, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->Media, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->meta, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->groups, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->udta, &pos);\n\treturn GF_OK;", "target": 0}
{"code": "static int key_notify_sa_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\tskb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));\n\thdr->sadb_msg_satype = pfkey_proto2satype(c->data.proto);\n\thdr->sadb_msg_type = SADB_FLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\thdr->sadb_msg_reserved = 0;\n\tpfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\treturn 0;\n}", "target": 0}
{"code": "    explicit DialogHandler(v8::Handle<v8::Value> dialogArguments, ScriptState* scriptState)\n        : m_scriptState(scriptState)\n        , m_dialogArguments(dialogArguments)\n    {\n    }", "target": 0}
{"code": "monitor_valid_hostbasedblob(u_char *data, u_int datalen, char *cuser,\n    char *chost)\n{\n\tBuffer b;\n\tchar *p;\n\tu_int len;\n\tint fail = 0;\n\tbuffer_init(&b);\n\tbuffer_append(&b, data, datalen);\n\tp = buffer_get_string(&b, &len);\n\tif ((session_id2 == NULL) ||\n\t    (len != session_id2_len) ||\n\t    (memcmp(p, session_id2, session_id2_len) != 0))\n\t\tfail++;\n\txfree(p);\n\tif (buffer_get_char(&b) != SSH2_MSG_USERAUTH_REQUEST)\n\t\tfail++;\n\tp = buffer_get_string(&b, NULL);\n\tif (strcmp(authctxt->user, p) != 0) {\n\t\tlogit(\"wrong user name passed to monitor: expected %s != %.100s\",\n\t\t    authctxt->user, p);\n\t\tfail++;\n\t}\n\txfree(p);\n\tbuffer_skip_string(&b);\t\n\tp = buffer_get_string(&b, NULL);\n\tif (strcmp(p, \"hostbased\") != 0)\n\t\tfail++;\n\txfree(p);\n\tbuffer_skip_string(&b);\t\n\tbuffer_skip_string(&b);\t\n\tp = buffer_get_string(&b, NULL);\n\tif (((len = strlen(p)) > 0) && p[len - 1] == '.')\n\t\tp[len - 1] = '\\0';\n\tif (strcmp(p, chost) != 0)\n\t\tfail++;\n\txfree(p);\n\tp = buffer_get_string(&b, NULL);\n\tif (strcmp(p, cuser) != 0)\n\t\tfail++;\n\txfree(p);\n\tif (buffer_len(&b) != 0)\n\t\tfail++;\n\tbuffer_free(&b);\n\treturn (fail == 0);\n}", "target": 0}
{"code": "static void nodeConstruct(struct SaveNode* node, tr_variant const* v, bool sort_dicts)\n{\n    node->isVisited = false;\n    node->childIndex = 0;\n    if (sort_dicts && tr_variantIsDict(v))\n    {\n        size_t const n = v->val.l.count;\n        struct KeyIndex* tmp = tr_new(struct KeyIndex, n);\n        for (size_t i = 0; i < n; i++)\n        {\n            tmp[i].val = v->val.l.vals + i;\n            tmp[i].keystr = tr_quark_get_string(tmp[i].val->key, NULL);\n        }\n        qsort(tmp, n, sizeof(struct KeyIndex), compareKeyIndex);\n        tr_variantInitDict(&node->sorted, n);\n        for (size_t i = 0; i < n; ++i)\n        {\n            node->sorted.val.l.vals[i] = *tmp[i].val;\n        }\n        node->sorted.val.l.count = n;\n        tr_free(tmp);\n        node->v = &node->sorted;\n    }\n    else\n    {\n        node->v = v;\n    }\n}", "target": 1}
{"code": "static Array HHVM_METHOD(Memcache, getextendedstats,\n                         const String&  ,\n                         int  , int  ) {\n  auto data = Native::data<MemcacheData>(this_);\n  memcached_return_t ret;\n  memcached_stat_st *stats;\n  stats = memcached_stat(&data->m_memcache, nullptr, &ret);\n  if (ret != MEMCACHED_SUCCESS) {\n    return Array();\n  }\n  int server_count = memcached_server_count(&data->m_memcache);\n  Array return_val;\n  for (int server_id = 0; server_id < server_count; server_id++) {\n    memcached_stat_st *stat;\n    char stats_key[30] = {0};\n    size_t key_len;\n    LMCD_SERVER_POSITION_INSTANCE_TYPE instance =\n      memcached_server_instance_by_position(&data->m_memcache, server_id);\n    const char *hostname = LMCD_SERVER_HOSTNAME(instance);\n    in_port_t port = LMCD_SERVER_PORT(instance);\n    stat = stats + server_id;\n    Array server_stats = memcache_build_stats(&data->m_memcache, stat, &ret);\n    if (ret != MEMCACHED_SUCCESS) {\n      continue;\n    }\n    key_len = snprintf(stats_key, sizeof(stats_key), \"%s:%d\", hostname, port);\n    return_val.set(String(stats_key, key_len, CopyString), server_stats);\n  }\n  free(stats);\n  return return_val;\n}", "target": 1}
{"code": "pixBlockconvGray(PIX     *pixs,\n                 PIX     *pixacc,\n                 l_int32  wc,\n                 l_int32  hc)\n{\nl_int32    w, h, d, wpl, wpla;\nl_uint32  *datad, *dataa;\nPIX       *pixd, *pixt;\n    PROCNAME(\"pixBlockconvGray\");\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (d != 8)\n        return (PIX *)ERROR_PTR(\"pixs not 8 bpp\", procName, NULL);\n    if (wc < 0) wc = 0;\n    if (hc < 0) hc = 0;\n    if (wc == 0 && hc == 0)   \n        return pixCopy(NULL, pixs);\n    if (w < 2 * wc + 1 || h < 2 * hc + 1) {\n        L_WARNING(\"kernel too large; returning a copy\\n\", procName);\n        L_INFO(\"w = %d, wc = %d, h = %d, hc = %d\\n\", procName, w, wc, h, hc);\n        return pixCopy(NULL, pixs);\n    }\n    if (pixacc) {\n        if (pixGetDepth(pixacc) == 32) {\n            pixt = pixClone(pixacc);\n        } else {\n            L_WARNING(\"pixacc not 32 bpp; making new one\\n\", procName);\n            if ((pixt = pixBlockconvAccum(pixs)) == NULL)\n                return (PIX *)ERROR_PTR(\"pixt not made\", procName, NULL);\n        }\n    } else {\n        if ((pixt = pixBlockconvAccum(pixs)) == NULL)\n            return (PIX *)ERROR_PTR(\"pixt not made\", procName, NULL);\n    }\n    if ((pixd = pixCreateTemplate(pixs)) == NULL) {\n        pixDestroy(&pixt);\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n    }\n    pixSetPadBits(pixt, 0);\n    wpl = pixGetWpl(pixd);\n    wpla = pixGetWpl(pixt);\n    datad = pixGetData(pixd);\n    dataa = pixGetData(pixt);\n    blockconvLow(datad, w, h, wpl, dataa, wpla, wc, hc);\n    pixDestroy(&pixt);\n    return pixd;\n}", "target": 1}
{"code": "static void rose_loopback_timer(unsigned long param)\n{\n\tstruct sk_buff *skb;\n\tstruct net_device *dev;\n\trose_address *dest;\n\tstruct sock *sk;\n\tunsigned short frametype;\n\tunsigned int lci_i, lci_o;\n\twhile ((skb = skb_dequeue(&loopback_queue)) != NULL) {\n\t\tlci_i     = ((skb->data[0] << 8) & 0xF00) + ((skb->data[1] << 0) & 0x0FF);\n\t\tframetype = skb->data[2];\n\t\tdest      = (rose_address *)(skb->data + 4);\n\t\tlci_o     = ROSE_DEFAULT_MAXVC + 1 - lci_i;\n\t\tskb_reset_transport_header(skb);\n\t\tsk = rose_find_socket(lci_o, rose_loopback_neigh);\n\t\tif (sk) {\n\t\t\tif (rose_process_rx_frame(sk, skb) == 0)\n\t\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\t\tif (frametype == ROSE_CALL_REQUEST) {\n\t\t\tif ((dev = rose_dev_get(dest)) != NULL) {\n\t\t\t\tif (rose_rx_call_request(skb, dev, rose_loopback_neigh, lci_o) == 0)\n\t\t\t\t\tkfree_skb(skb);\n\t\t\t} else {\n\t\t\t\tkfree_skb(skb);\n\t\t\t}\n\t\t} else {\n\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n}", "target": 1}
{"code": "inline bool SegmentReader::amplifiedRead(WordCount virtualAmount) {\n  return readLimiter->canRead(virtualAmount, arena);\n}", "target": 0}
{"code": "format_SET_IP_ECN(const struct ofpact_ecn *a,\n                  const struct ofpact_format_params *fp)\n{\n    ds_put_format(fp->s, \"%smod_nw_ecn:%s%d\",\n                  colors.param, colors.end, a->ecn);\n}", "target": 0}
{"code": "pci_emul_add_capability(struct pci_vdev *dev, u_char *capdata, int caplen)\n{\n\tint i, capoff, reallen;\n\tuint16_t sts;\n\tassert(caplen > 0);\n\treallen = roundup2(caplen, 4);\t\t\n\tsts = pci_get_cfgdata16(dev, PCIR_STATUS);\n\tif ((sts & PCIM_STATUS_CAPPRESENT) == 0)\n\t\tcapoff = CAP_START_OFFSET;\n\telse\n\t\tcapoff = dev->capend + 1;\n\tif (capoff + reallen > PCI_REGMAX + 1)\n\t\treturn -1;\n\tif ((sts & PCIM_STATUS_CAPPRESENT) == 0) {\n\t\tpci_set_cfgdata8(dev, PCIR_CAP_PTR, capoff);\n\t\tpci_set_cfgdata16(dev, PCIR_STATUS, sts|PCIM_STATUS_CAPPRESENT);\n\t} else\n\t\tpci_set_cfgdata8(dev, dev->prevcap + 1, capoff);\n\tfor (i = 0; i < caplen; i++)\n\t\tpci_set_cfgdata8(dev, capoff + i, capdata[i]);\n\tpci_set_cfgdata8(dev, capoff + 1, 0);\n\tdev->prevcap = capoff;\n\tdev->capend = capoff + reallen - 1;\n\treturn 0;\n}", "target": 1}
{"code": "xmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {\n    xmlIDTablePtr table;\n    xmlIDPtr id;\n    xmlChar *ID;\n    if (doc == NULL) return(-1);\n    if (attr == NULL) return(-1);\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)\n        return(-1);\n    ID = xmlNodeListGetString(doc, attr->children, 1);\n    if (ID == NULL)\n        return(-1);\n    id = xmlHashLookup(table, ID);\n    if (id == NULL || id->attr != attr) {\n        xmlFree(ID);\n        return(-1);\n    }\n    xmlHashRemoveEntry(table, ID, (xmlHashDeallocator) xmlFreeID);\n    xmlFree(ID);\n    attr->atype = 0;\n    return(0);\n}", "target": 0}
{"code": "static void xar_get_checksum_values(xmlTextReaderPtr reader, unsigned char ** cksum, int * hash)\n{\n    xmlChar * style = xmlTextReaderGetAttribute(reader, (const xmlChar *)\"style\");\n    const xmlChar * xmlval;\n    *hash = XAR_CKSUM_NONE;\n    if (style == NULL) {\n        cli_dbgmsg(\"cli_scaxar: xmlTextReaderGetAttribute no style attribute \"\n                   \"for checksum element\\n\");\n    } else {\n        cli_dbgmsg(\"cli_scanxar: checksum algorithm is %s.\\n\", style);        \n        if (0 == xmlStrcasecmp(style, (const xmlChar *)\"sha1\")) {\n            *hash = XAR_CKSUM_SHA1;\n        } else if (0 == xmlStrcasecmp(style, (const xmlChar *)\"md5\")) {\n            *hash = XAR_CKSUM_MD5;\n        } else {\n            cli_dbgmsg(\"cli_scanxar: checksum algorithm %s is unsupported.\\n\", style);\n            *hash = XAR_CKSUM_OTHER;\n        }\n    }\n    if (style != NULL)\n        xmlFree(style);\n    if (xmlTextReaderRead(reader) == 1 && xmlTextReaderNodeType(reader) == XML_READER_TYPE_TEXT) {\n        xmlval = xmlTextReaderConstValue(reader);\n        if (xmlval) {\n            *cksum = xmlStrdup(xmlval); \n            cli_dbgmsg(\"cli_scanxar: checksum value is %s.\\n\", *cksum);\n        } else {\n            *cksum = NULL;\n            cli_dbgmsg(\"cli_scanxar: xmlTextReaderConstValue() returns NULL for checksum value.\\n\");           \n        }\n    }\n    else\n        cli_dbgmsg(\"cli_scanxar: No text for XML checksum element.\\n\");\n}", "target": 1}
{"code": "purgekeys_2_svc(purgekeys_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg, *funcname;\n    gss_buffer_desc             client_name, service_name;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    const char                  *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    funcname = \"kadm5_purgekeys\";\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (!cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ) &&\n        (CHANGEPW_SERVICE(rqstp)\n         || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,\n                                arg->princ, NULL))) {\n        ret.code = KADM5_AUTH_MODIFY;\n        log_unauth(funcname, prime_arg, &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_purgekeys((void *)handle, arg->princ,\n                                   arg->keepkvno);\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(funcname, prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "parse_notification_delta(xmlTextReaderPtr reader,\n    struct rdr_notification_ctx *ctx)\n{\n\tstruct delta_head *tmp;\n\tunsigned long serial;\n\tint error;\n\terror = delta_head_create(&tmp);\n\tif (error)\n\t\treturn error;\n\terror = parse_long(reader, RRDP_ATTR_SERIAL, &serial);\n\tif (error)\n\t\tgoto delta_destroy;\n\ttmp->serial = serial;\n\terror = parse_doc_data(reader, true, true, &tmp->doc_data);\n\tif (error)\n\t\tgoto delta_destroy;\n\terror = deltas_parsed_add(&ctx->deltas, &tmp);\n\tif (error)\n\t\tgoto delta_destroy;\n\treturn 0;\ndelta_destroy:\n\tdelta_head_destroy(tmp);\n\treturn error;\n}", "target": 1}
{"code": "struct sctp_chunk *sctp_inq_pop(struct sctp_inq *queue)\n{\n\tstruct sctp_chunk *chunk;\n\tsctp_chunkhdr_t *ch = NULL;\n\tif ((chunk = queue->in_progress)) {\n\t\tif (chunk->singleton ||\n\t\t    chunk->end_of_packet ||\n\t\t    chunk->pdiscard) {\n\t\t\tsctp_chunk_free(chunk);\n\t\t\tchunk = queue->in_progress = NULL;\n\t\t} else {\n\t\t\tch = (sctp_chunkhdr_t *) chunk->chunk_end;\n\t\t\tskb_pull(chunk->skb,\n\t\t\t\t chunk->chunk_end - chunk->skb->data);\n\t\t\tif (skb_headlen(chunk->skb) < sizeof(sctp_chunkhdr_t)) {\n\t\t\t\tsctp_chunk_free(chunk);\n\t\t\t\tchunk = queue->in_progress = NULL;\n\t\t\t}\n\t\t}\n\t}\n\tif (!chunk) {\n\t\tstruct list_head *entry;\n\t\tif (list_empty(&queue->in_chunk_list))\n\t\t\treturn NULL;\n\t\tentry = queue->in_chunk_list.next;\n\t\tchunk = queue->in_progress =\n\t\t\tlist_entry(entry, struct sctp_chunk, list);\n\t\tlist_del_init(entry);\n\t\tchunk->singleton = 1;\n\t\tch = (sctp_chunkhdr_t *) chunk->skb->data;\n\t\tchunk->data_accepted = 0;\n\t}\n\tchunk->chunk_hdr = ch;\n\tchunk->chunk_end = ((__u8 *)ch) + WORD_ROUND(ntohs(ch->length));\n\tif (unlikely(skb_is_nonlinear(chunk->skb))) {\n\t\tif (chunk->chunk_end > skb_tail_pointer(chunk->skb))\n\t\t\tchunk->chunk_end = skb_tail_pointer(chunk->skb);\n\t}\n\tskb_pull(chunk->skb, sizeof(sctp_chunkhdr_t));\n\tchunk->subh.v = NULL; \n\tif (chunk->chunk_end < skb_tail_pointer(chunk->skb)) {\n\t\tchunk->singleton = 0;\n\t} else if (chunk->chunk_end > skb_tail_pointer(chunk->skb)) {\n\t\tsctp_chunk_free(chunk);\n\t\tchunk = queue->in_progress = NULL;\n\t\treturn NULL;\n\t} else {\n\t\tchunk->end_of_packet = 1;\n\t}\n\tpr_debug(\"+++sctp_inq_pop+++ chunk:%p[%s], length:%d, skb->len:%d\\n\",\n\t\t chunk, sctp_cname(SCTP_ST_CHUNK(chunk->chunk_hdr->type)),\n\t\t ntohs(chunk->chunk_hdr->length), chunk->skb->len);\n\treturn chunk;\n}", "target": 1}
{"code": "sync_cookie_isvalid(Sync_Cookie *testcookie, Sync_Cookie *refcookie)\n{\n    if (testcookie == NULL || refcookie == NULL) {\n        return 0;\n    }\n    if ((testcookie->openldap_compat != refcookie->openldap_compat ||\n         strcmp(testcookie->cookie_client_signature, refcookie->cookie_client_signature) ||\n         testcookie->cookie_change_info == -1 ||\n         testcookie->cookie_change_info > refcookie->cookie_change_info)) {\n        return 0;\n    }\n    if (refcookie->openldap_compat) {\n        if (testcookie->cookie_server_signature != NULL ||\n            refcookie->cookie_server_signature != NULL) {\n            return 0;\n        }\n    } else {\n        if (strcmp(testcookie->cookie_server_signature, refcookie->cookie_server_signature)) {\n            return 0;\n        }\n    }\n    return 1;\n}", "target": 0}
{"code": "static void sig_int_handler(int sig) {\n  struct sigaction *old = NULL;\n  switch (sig) {\n#if !FIO_DISABLE_HOT_RESTART\n  case SIGUSR1:\n    fio_signal_children_flag = 1;\n    old = &fio_old_sig_usr1;\n    break;\n#endif\n  case SIGINT:\n    if (!old)\n      old = &fio_old_sig_int;\n  case SIGTERM:\n    if (!old)\n      old = &fio_old_sig_term;\n    fio_stop();\n    break;\n  case SIGPIPE:\n    if (!old)\n      old = &fio_old_sig_pipe;\n  default:\n    break;\n  }\n  if (old->sa_handler != SIG_IGN && old->sa_handler != SIG_DFL)\n    old->sa_handler(sig);\n}", "target": 1}
{"code": "static void asmlinkage smm_do_relocation(void *arg)\n{\n\tconst struct smm_module_params *p;\n\tconst struct smm_runtime *runtime;\n\tint cpu;\n\tuintptr_t curr_smbase;\n\tuintptr_t perm_smbase;\n\tp = arg;\n\truntime = p->runtime;\n\tcpu = p->cpu;\n\tcurr_smbase = runtime->smbase;\n\tif (cpu >= CONFIG_MAX_CPUS) {\n\t\tprintk(BIOS_CRIT,\n\t\t       \"Invalid CPU number assigned in SMM stub: %d\\n\", cpu);\n\t\treturn;\n\t}\n\tperm_smbase = mp_state.perm_smbase;\n\tperm_smbase -= cpu * runtime->save_state_size;\n\tprintk(BIOS_DEBUG, \"New SMBASE 0x%08lx\\n\", perm_smbase);\n\tmp_state.ops.relocation_handler(cpu, curr_smbase, perm_smbase);\n\tif (CONFIG(STM)) {\n\t\tuintptr_t mseg;\n\t\tmseg = mp_state.perm_smbase +\n\t\t\t(mp_state.perm_smsize - CONFIG_MSEG_SIZE);\n\t\tstm_setup(mseg, p->cpu,\n\t\t\t\tperm_smbase,\n\t\t\t\tmp_state.perm_smbase,\n\t\t\t\truntime->start32_offset);\n\t}\n}", "target": 1}
{"code": "noop_post_process (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                   JDIMENSION *in_row_group_ctr,\n                   JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf,\n                   JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n{\n}", "target": 0}
{"code": "ptr_str_array_compare (const gchar **a,\n                       const gchar **b)\n{\n  return g_strcmp0 (*a, *b);\n}", "target": 0}
{"code": "static Jsi_RC jsi_BitfieldToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue,\n    Jsi_DString *outStr, void *record, Jsi_Wide flags)\n{\n    Jsi_csgset *bsget = spec->init.OPT_BITS;\n    Jsi_Interp *d = interp;\n    int idx = spec->idx;\n    uchar *data = (uchar*)record;\n    int64_t inum;\n    Jsi_OptionSpec* enumSpec = (typeof(enumSpec))spec->data;\n    if (!d || !bsget || idx<0) \n        return Jsi_LogBug(\"invalid bitfield\");\n    Jsi_RC rc = (*bsget)(interp, data, &inum, spec, idx, 0);\n    if (rc != JSI_OK)\n        return JSI_ERROR;\n    if (enumSpec) {\n        struct numStruct { int64_t numVal; } nval = { inum };\n        Jsi_OptionSpec eSpec[] = {\n            JSI_OPT(CUSTOM, struct numStruct, numVal, .help=spec->help, .flags=JSI_OPT_ENUM_SPEC, .custom=Jsi_Opt_SwitchEnum,\n            .data=(void*)enumSpec, .info=0, .tname=spec->tname, .value=0, .bits=0, .boffset=8*sizeof(int64_t) ), \n            JSI_OPT_END(struct numStruct)\n        };\n        if (JSI_OK != jsi_EnumToValue(interp, eSpec, outValue, outStr, (void*)&nval, flags))\n            return JSI_ERROR;\n    } else if (outStr) {\n        char obuf[100];\n        snprintf(obuf, sizeof(obuf), \"%\" PRId64, inum);\n        Jsi_DSAppend(outStr, obuf, NULL);\n    } else {\n        Jsi_Number num = (Jsi_Number)inum;\n        Jsi_ValueMakeNumber(interp, outValue, num);\n    }\n    return JSI_OK;\n}", "target": 1}
{"code": "static bool r_bin_mdmp_init_directory(struct r_bin_mdmp_obj *obj) {\n\tint i;\n\tut8 *directory_base;\n\tstruct minidump_directory *entry;\n\tdirectory_base = obj->b->buf + obj->hdr->stream_directory_rva;\n\tsdb_num_set (obj->kv, \"mdmp_directory.offset\",\n\t\t\tobj->hdr->stream_directory_rva, 0);\n\tsdb_set (obj->kv, \"mdmp_directory.format\", \"[4]E? \"\n\t\t\t\"(mdmp_stream_type)StreamType \"\n\t\t\t\"(mdmp_location_descriptor)Location\", 0);\n\tfor (i = 0; i < (int)obj->hdr->number_of_streams; i++) {\n\t\tentry = (struct minidump_directory *)(directory_base + (i * sizeof (struct minidump_directory)));\n\t\tr_bin_mdmp_init_directory_entry (obj, entry);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "get_pols_2_svc(gpols_arg *arg, struct svc_req *rqstp)\n{\n    static gpols_ret                ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_gpols_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->exp;\n    if (prime_arg == NULL)\n        prime_arg = \"*\";\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_LIST, NULL, NULL)) {\n        ret.code = KADM5_AUTH_LIST;\n        log_unauth(\"kadm5_get_policies\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code  = kadm5_get_policies((void *)handle,\n                                       arg->exp, &ret.pols,\n                                       &ret.count);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_get_policies\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "static void ext4_end_io_dio(struct kiocb *iocb, loff_t offset,\n\t\t\t    ssize_t size, void *private)\n{\n        ext4_io_end_t *io_end = iocb->private;\n\tstruct workqueue_struct *wq;\n\tif (!io_end || !size)\n\t\treturn;\n\text_debug(\"ext4_end_io_dio(): io_end 0x%p\"\n\t\t  \"for inode %lu, iocb 0x%p, offset %llu, size %llu\\n\",\n \t\t  iocb->private, io_end->inode->i_ino, iocb, offset,\n\t\t  size);\n\tif (io_end->flag != EXT4_IO_UNWRITTEN){\n\t\text4_free_io_end(io_end);\n\t\tiocb->private = NULL;\n\t\treturn;\n\t}\n\tio_end->offset = offset;\n\tio_end->size = size;\n\twq = EXT4_SB(io_end->inode->i_sb)->dio_unwritten_wq;\n\tqueue_work(wq, &io_end->work);\n\tlist_add_tail(&io_end->list,\n\t\t &EXT4_I(io_end->inode)->i_completed_io_list);\n\tiocb->private = NULL;\n}", "target": 1}
{"code": "feed_table_block_tag(struct table *tbl,\n\t\t     char *line, struct table_mode *mode, int indent, int cmd)\n{\n    int offset;\n    if (mode->indent_level <= 0 && indent == -1)\n\treturn;\n    if (mode->indent_level >= CHAR_MAX && indent == 1)\n\treturn;\n    setwidth(tbl, mode);\n    feed_table_inline_tag(tbl, line, mode, -1);\n    clearcontentssize(tbl, mode);\n    if (indent == 1) {\n\tmode->indent_level++;\n\tif (mode->indent_level <= MAX_INDENT_LEVEL)\n\t    tbl->indent += INDENT_INCR;\n    }\n    else if (indent == -1) {\n\tmode->indent_level--;\n\tif (mode->indent_level < MAX_INDENT_LEVEL)\n\t    tbl->indent -= INDENT_INCR;\n    }\n    if (tbl->indent < 0)\n\ttbl->indent = 0;\n    offset = tbl->indent;\n    if (cmd == HTML_DT) {\n\tif (mode->indent_level > 0 && mode->indent_level <= MAX_INDENT_LEVEL)\n\t    offset -= INDENT_INCR;\n\tif (offset < 0)\n\t    offset = 0;\n    }\n    if (tbl->indent > 0) {\n\tcheck_minimum0(tbl, 0);\n\taddcontentssize(tbl, offset);\n    }\n}", "target": 0}
{"code": "void mobi_buffer_move(MOBIBuffer *buf, const int offset, const size_t len) {\n    size_t aoffset = (size_t) abs(offset);\n    unsigned char *source = buf->data + buf->offset;\n    if (offset >= 0) {\n        if (buf->offset + aoffset + len > buf->maxlen) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source += aoffset;\n    } else {\n        if (buf->offset < aoffset) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source -= aoffset;\n    }\n    memmove(buf->data + buf->offset, source, len);\n    buf->offset += len;\n}", "target": 1}
{"code": "rt6_print(netdissect_options *ndo, register const u_char *bp, const u_char *bp2 _U_)\n{\n\tregister const struct ip6_rthdr *dp;\n\tregister const struct ip6_rthdr0 *dp0;\n\tregister const u_char *ep;\n\tint i, len;\n\tregister const struct in6_addr *addr;\n\tdp = (const struct ip6_rthdr *)bp;\n\tlen = dp->ip6r_len;\n\tep = ndo->ndo_snapend;\n\tND_TCHECK(dp->ip6r_segleft);\n\tND_PRINT((ndo, \"srcrt (len=%d\", dp->ip6r_len));\t\n\tND_PRINT((ndo, \", type=%d\", dp->ip6r_type));\n\tND_PRINT((ndo, \", segleft=%d\", dp->ip6r_segleft));\n\tswitch (dp->ip6r_type) {\n\tcase IPV6_RTHDR_TYPE_0:\n\tcase IPV6_RTHDR_TYPE_2:\t\t\t\n\t\tdp0 = (const struct ip6_rthdr0 *)dp;\n\t\tND_TCHECK(dp0->ip6r0_reserved);\n\t\tif (dp0->ip6r0_reserved || ndo->ndo_vflag) {\n\t\t\tND_PRINT((ndo, \", rsv=0x%0x\",\n\t\t\t    EXTRACT_32BITS(&dp0->ip6r0_reserved)));\n\t\t}\n\t\tif (len % 2 == 1)\n\t\t\tgoto trunc;\n\t\tlen >>= 1;\n\t\taddr = &dp0->ip6r0_addr[0];\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif ((const u_char *)(addr + 1) > ep)\n\t\t\t\tgoto trunc;\n\t\t\tND_PRINT((ndo, \", [%d]%s\", i, ip6addr_string(ndo, addr)));\n\t\t\taddr++;\n\t\t}\n\t\tND_PRINT((ndo, \") \"));\n\t\treturn((dp0->ip6r0_len + 1) << 3);\n\t\tbreak;\n\tdefault:\n\t\tgoto trunc;\n\t\tbreak;\n\t}\n trunc:\n\tND_PRINT((ndo, \"[|srcrt]\"));\n\treturn -1;\n}", "target": 1}
{"code": "bool SSecurityTLS::processMsg(SConnection *sc)\n{\n  rdr::InStream* is = sc->getInStream();\n  rdr::OutStream* os = sc->getOutStream();\n  vlog.debug(\"Process security message (session %p)\", session);\n  if (!session) {\n    initGlobal();\n    if (gnutls_init(&session, GNUTLS_SERVER) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_init failed\");\n    if (gnutls_set_default_priority(session) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_set_default_priority failed\");\n    try {\n      setParams(session);\n    }\n    catch(...) {\n      os->writeU8(0);\n      throw;\n    }\n    os->writeU8(1);\n    os->flush();\n  }\n  rdr::TLSInStream *tlsis = new rdr::TLSInStream(is, session);\n  rdr::TLSOutStream *tlsos = new rdr::TLSOutStream(os, session);\n  int err;\n  err = gnutls_handshake(session);\n  if (err != GNUTLS_E_SUCCESS) {\n    delete tlsis;\n    delete tlsos;\n    if (!gnutls_error_is_fatal(err)) {\n      vlog.debug(\"Deferring completion of TLS handshake: %s\", gnutls_strerror(err));\n      return false;\n    }\n    vlog.error(\"TLS Handshake failed: %s\", gnutls_strerror (err));\n    shutdown();\n    throw AuthFailureException(\"TLS Handshake failed\");\n  }\n  vlog.debug(\"Handshake completed\");\n  sc->setStreams(fis = tlsis, fos = tlsos);\n  return true;\n}", "target": 1}
{"code": "void kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data, tpr;\n\tint max_irr, max_isr;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tvoid *vapic;\n\tapic_sync_pv_eoi_to_guest(vcpu, apic);\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\ttpr = kvm_apic_get_reg(apic, APIC_TASKPRI) & 0xff;\n\tmax_irr = apic_find_highest_irr(apic);\n\tif (max_irr < 0)\n\t\tmax_irr = 0;\n\tmax_isr = apic_find_highest_isr(apic);\n\tif (max_isr < 0)\n\t\tmax_isr = 0;\n\tdata = (tpr & 0xff) | ((max_isr & 0xf0) << 8) | (max_irr << 24);\n\tvapic = kmap_atomic(vcpu->arch.apic->vapic_page);\n\t*(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr)) = data;\n\tkunmap_atomic(vapic);\n}", "target": 1}
{"code": "PBKDF2_SHA256(const uint8_t * passwd, size_t passwdlen, const uint8_t * salt,\n    size_t saltlen, uint64_t c, uint8_t * buf, size_t dkLen)\n{\n  struct HMAC_SHA256_CTX PShctx, hctx;\n  size_t i;\n  uint8_t ivec[4];\n  uint32_t *ivec_p;\n  uint8_t U[32];\n  uint8_t T[32];\n  uint64_t j;\n  int k;\n  size_t clen;\n  HMAC_SHA256_Init(&PShctx, passwd, passwdlen);\n  HMAC_SHA256_Update(&PShctx, salt, saltlen);\n  ivec_p = (uint32_t *) ivec;\n  for (i = 0; i * 32 < dkLen; i++) {\n    *ivec_p = folly::Endian::big32((uint32_t)(i + 1));\n    memcpy(&hctx, &PShctx, sizeof(struct HMAC_SHA256_CTX));\n    HMAC_SHA256_Update(&hctx, ivec, 4);\n    HMAC_SHA256_Final(U, &hctx);\n    memcpy(T, U, 32);\n    for (j = 2; j <= c; j++) {\n      HMAC_SHA256_Init(&hctx, passwd, passwdlen);\n      HMAC_SHA256_Update(&hctx, U, 32);\n      HMAC_SHA256_Final(U, &hctx);\n      for (k = 0; k < 32; k++)\n        T[k] ^= U[k];\n    }\n    clen = dkLen - i * 32;\n    if (clen > 32)\n      clen = 32;\n    memcpy(&buf[i * 32], T, clen);\n  }\n  memset(&PShctx, 0, sizeof(struct HMAC_SHA256_CTX));\n}", "target": 1}
{"code": "int avcodec_default_reget_buffer(AVCodecContext *s, AVFrame *pic)\n{\n    av_assert0(0);\n    return AVERROR_BUG;\n}", "target": 0}
{"code": "static Elf64_Sym * __init find_symbol64(struct lib64_elfinfo *lib,\n\t\t\t\t\tconst char *symname)\n{\n\tunsigned int i;\n\tchar name[MAX_SYMNAME], *c;\n\tfor (i = 0; i < (lib->dynsymsize / sizeof(Elf64_Sym)); i++) {\n\t\tif (lib->dynsym[i].st_name == 0)\n\t\t\tcontinue;\n\t\tstrlcpy(name, lib->dynstr + lib->dynsym[i].st_name,\n\t\t\tMAX_SYMNAME);\n\t\tc = strchr(name, '@');\n\t\tif (c)\n\t\t\t*c = 0;\n\t\tif (strcmp(symname, name) == 0)\n\t\t\treturn &lib->dynsym[i];\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "inline int TensorProtoDataSize<qint32>(const TensorProto& t) {\n  return t.int_val_size();\n}", "target": 0}
{"code": "void UnicodeStringTest::TestLargeAppend() {\n    if(quick) return;\n    IcuTestErrorCode status(*this, \"TestLargeAppend\");\n    int32_t len = 0xAFFFFFF;\n    UnicodeString str;\n    char16_t *buf = str.getBuffer(len);\n    uprv_memset(buf, 0x4e, len * 2);\n    str.releaseBuffer(len);\n    UnicodeString dest;\n    int64_t total = 0;\n    for (int32_t i = 0; i < 16; i++) {\n        dest.append(str);\n        total += len;\n        if (total <= INT32_MAX) {\n            assertFalse(\"dest is not bogus\", dest.isBogus());\n        } else {\n            assertTrue(\"dest should be bogus\", dest.isBogus());\n        }\n    }\n    dest.remove();\n    total = 0;\n    for (int32_t i = 0; i < 16; i++) {\n        dest.append(str);\n        total += len;\n        if (total + len <= INT32_MAX) {\n            assertFalse(\"dest is not bogus\", dest.isBogus());\n        } else if (total <= INT32_MAX) {\n            UnicodeString str2;\n            int32_t remain = INT32_MAX - total;\n            char16_t *buf2 = str2.getBuffer(remain);\n            if (buf2 == nullptr) {\n                return;\n            }\n            uprv_memset(buf2, 0x4e, remain * 2);\n            str2.releaseBuffer(remain);\n            dest.append(str2);\n            total += remain;\n            assertEquals(\"When a string of exactly the maximum size works\", (int64_t)INT32_MAX, total);\n            assertEquals(\"When a string of exactly the maximum size works\", INT32_MAX, dest.length());\n            assertFalse(\"dest is not bogus\", dest.isBogus());\n            str2.truncate(1);\n            dest.append(str2);\n            total++;\n            assertTrue(\"dest should be bogus\", dest.isBogus());\n        } else {\n            assertTrue(\"dest should be bogus\", dest.isBogus());\n        }\n    }\n}", "target": 0}
{"code": "  void setSocket(AsyncSocket* s) {\n    s_ = s;\n  }", "target": 0}
{"code": "const wchar_t *LibRaw_file_datastream::wfname()\n{\n  return wfilename.size() > 0 ? wfilename.c_str() : NULL;\n}", "target": 0}
{"code": "static int synic_set_irq(struct kvm_vcpu_hv_synic *synic, u32 sint)\n{\n\tstruct kvm_vcpu *vcpu = hv_synic_to_vcpu(synic);\n\tstruct kvm_lapic_irq irq;\n\tint ret, vector;\n\tif (KVM_BUG_ON(!lapic_in_kernel(vcpu), vcpu->kvm))\n\t\treturn -EINVAL;\n\tif (sint >= ARRAY_SIZE(synic->sint))\n\t\treturn -EINVAL;\n\tvector = synic_get_sint_vector(synic_read_sint(synic, sint));\n\tif (vector < 0)\n\t\treturn -ENOENT;\n\tmemset(&irq, 0, sizeof(irq));\n\tirq.shorthand = APIC_DEST_SELF;\n\tirq.dest_mode = APIC_DEST_PHYSICAL;\n\tirq.delivery_mode = APIC_DM_FIXED;\n\tirq.vector = vector;\n\tirq.level = 1;\n\tret = kvm_irq_delivery_to_apic(vcpu->kvm, vcpu->arch.apic, &irq, NULL);\n\ttrace_kvm_hv_synic_set_irq(vcpu->vcpu_id, sint, irq.vector, ret);\n\treturn ret;\n}", "target": 0}
{"code": "static irqreturn_t sunkbd_interrupt(struct serio *serio,\n\t\tunsigned char data, unsigned int flags)\n{\n\tstruct sunkbd *sunkbd = serio_get_drvdata(serio);\n\tif (sunkbd->reset <= -1) {\n\t\tsunkbd->reset = data;\n\t\twake_up_interruptible(&sunkbd->wait);\n\t\tgoto out;\n\t}\n\tif (sunkbd->layout == -1) {\n\t\tsunkbd->layout = data;\n\t\twake_up_interruptible(&sunkbd->wait);\n\t\tgoto out;\n\t}\n\tswitch (data) {\n\tcase SUNKBD_RET_RESET:\n\t\tschedule_work(&sunkbd->tq);\n\t\tsunkbd->reset = -1;\n\t\tbreak;\n\tcase SUNKBD_RET_LAYOUT:\n\t\tsunkbd->layout = -1;\n\t\tbreak;\n\tcase SUNKBD_RET_ALLUP: \n\t\tbreak;\n\tdefault:\n\t\tif (!sunkbd->enabled)\n\t\t\tbreak;\n\t\tif (sunkbd->keycode[data & SUNKBD_KEY]) {\n\t\t\tinput_report_key(sunkbd->dev,\n\t\t\t\t\t sunkbd->keycode[data & SUNKBD_KEY],\n\t\t\t\t\t !(data & SUNKBD_RELEASE));\n\t\t\tinput_sync(sunkbd->dev);\n\t\t} else {\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"sunkbd.c: Unknown key (scancode %#x) %s.\\n\",\n\t\t\t\tdata & SUNKBD_KEY,\n\t\t\t\tdata & SUNKBD_RELEASE ? \"released\" : \"pressed\");\n\t\t}\n\t}\nout:\n\treturn IRQ_HANDLED;\n}", "target": 1}
{"code": "int blkid_probe_invert_partitions_filter(blkid_probe pr)\n{\n\treturn __blkid_probe_invert_filter(pr, BLKID_CHAIN_PARTS);\n}", "target": 0}
{"code": "choose_filters(struct archive_read *a)\n{\n\tint number_bidders, i, bid, best_bid;\n\tstruct archive_read_filter_bidder *bidder, *best_bidder;\n\tstruct archive_read_filter *filter;\n\tssize_t avail;\n\tint r;\n\tfor (;;) {\n\t\tnumber_bidders = sizeof(a->bidders) / sizeof(a->bidders[0]);\n\t\tbest_bid = 0;\n\t\tbest_bidder = NULL;\n\t\tbidder = a->bidders;\n\t\tfor (i = 0; i < number_bidders; i++, bidder++) {\n\t\t\tif (bidder->bid != NULL) {\n\t\t\t\tbid = (bidder->bid)(bidder, a->filter);\n\t\t\t\tif (bid > best_bid) {\n\t\t\t\t\tbest_bid = bid;\n\t\t\t\t\tbest_bidder = bidder;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (best_bidder == NULL) {\n\t\t\t__archive_read_filter_ahead(a->filter, 1, &avail);\n\t\t\tif (avail < 0) {\n\t\t\t\t__archive_read_close_filters(a);\n\t\t\t\t__archive_read_free_filters(a);\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t\t}\n\t\t\ta->archive.compression_name = a->filter->name;\n\t\t\ta->archive.compression_code = a->filter->code;\n\t\t\treturn (ARCHIVE_OK);\n\t\t}\n\t\tfilter\n\t\t    = (struct archive_read_filter *)calloc(1, sizeof(*filter));\n\t\tif (filter == NULL)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tfilter->bidder = best_bidder;\n\t\tfilter->archive = a;\n\t\tfilter->upstream = a->filter;\n\t\ta->filter = filter;\n\t\tr = (best_bidder->init)(a->filter);\n\t\tif (r != ARCHIVE_OK) {\n\t\t\t__archive_read_close_filters(a);\n\t\t\t__archive_read_free_filters(a);\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t}\n}", "target": 1}
{"code": "static int __init setup_psi(char *str)\n{\n\treturn kstrtobool(str, &psi_enable) == 0;\n}", "target": 0}
{"code": "elg_get_nbits (int algo, gcry_mpi_t *pkey)\n{\n  (void)algo;\n  return mpi_get_nbits (pkey[0]);\n}", "target": 0}
{"code": "static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)\n{\n    cJSON *current_element = NULL;\n    if ((object == NULL) || (name == NULL))\n    {\n        return NULL;\n    }\n    current_element = object->child;\n    if (case_sensitive)\n    {\n        while ((current_element != NULL) && (strcmp(name, current_element->string) != 0))\n        {\n            current_element = current_element->next;\n        }\n    }\n    else\n    {\n        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))\n        {\n            current_element = current_element->next;\n        }\n    }\n    return current_element;\n}", "target": 1}
{"code": "static int vgacon_switch(struct vc_data *c)\n{\n\tint x = c->vc_cols * VGA_FONTWIDTH;\n\tint y = c->vc_rows * c->vc_font.height;\n\tint rows = screen_info.orig_video_lines * vga_default_font_height/\n\t\tc->vc_font.height;\n\tvga_video_num_columns = c->vc_cols;\n\tvga_video_num_lines = c->vc_rows;\n\tif (!vga_is_gfx) {\n\t\tscr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf,\n\t\t\t    c->vc_screenbuf_size > vga_vram_size ?\n\t\t\t\tvga_vram_size : c->vc_screenbuf_size);\n\t\tif ((vgacon_xres != x || vgacon_yres != y) &&\n\t\t    (!(vga_video_num_columns % 2) &&\n\t\t     vga_video_num_columns <= screen_info.orig_video_cols &&\n\t\t     vga_video_num_lines <= rows))\n\t\t\tvgacon_doresize(c, c->vc_cols, c->vc_rows);\n\t}\n\tvgacon_scrollback_switch(c->vc_num);\n\treturn 0;\t\t\n}", "target": 1}
{"code": "GF_Err gf_avc_change_color(GF_AVCConfig *avcc, s32 fullrange, s32 vidformat, s32 colorprim, s32 transfer, s32 colmatrix)\n{\n\tGF_VUIInfo vuii;\n\tmemset(&vuii, 0, sizeof(GF_VUIInfo));\n\tvuii.ar_num = -1;\n\tvuii.ar_den = -1;\n\tvuii.fullrange = fullrange;\n\tvuii.video_format = vidformat;\n\tvuii.color_prim = colorprim;\n\tvuii.color_tfc = transfer;\n\tvuii.color_matrix = colmatrix;\n\treturn gf_avc_change_vui(avcc, &vuii);\n}", "target": 0}
{"code": "int migrate_task_to(struct task_struct *p, int target_cpu)\n{\n\tstruct migration_arg arg = { p, target_cpu };\n\tint curr_cpu = task_cpu(p);\n\tif (curr_cpu == target_cpu)\n\t\treturn 0;\n\tif (!cpumask_test_cpu(target_cpu, tsk_cpus_allowed(p)))\n\t\treturn -EINVAL;\n\ttrace_sched_move_numa(p, curr_cpu, target_cpu);\n\treturn stop_one_cpu(curr_cpu, migration_cpu_stop, &arg);\n}", "target": 0}
{"code": "static int fuse_verify_ioctl_iov(struct iovec *iov, size_t count)\n{\n\tsize_t n;\n\tu32 max = FUSE_MAX_PAGES_PER_REQ << PAGE_SHIFT;\n\tfor (n = 0; n < count; n++) {\n\t\tif (iov->iov_len > (size_t) max)\n\t\t\treturn -ENOMEM;\n\t\tmax -= iov->iov_len;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "nfs4_file_open(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct dentry *dentry = file_dentry(filp);\n\tstruct dentry *parent = NULL;\n\tstruct inode *dir;\n\tunsigned openflags = filp->f_flags;\n\tstruct iattr attr;\n\tint err;\n\tdprintk(\"NFS: open file(%pd2)\\n\", dentry);\n\terr = nfs_check_flags(openflags);\n\tif (err)\n\t\treturn err;\n\tif ((openflags & O_ACCMODE) == 3)\n\t\treturn nfs_open(inode, filp);\n\topenflags &= ~(O_CREAT|O_EXCL);\n\tparent = dget_parent(dentry);\n\tdir = d_inode(parent);\n\tctx = alloc_nfs_open_context(file_dentry(filp), filp->f_mode, filp);\n\terr = PTR_ERR(ctx);\n\tif (IS_ERR(ctx))\n\t\tgoto out;\n\tattr.ia_valid = ATTR_OPEN;\n\tif (openflags & O_TRUNC) {\n\t\tattr.ia_valid |= ATTR_SIZE;\n\t\tattr.ia_size = 0;\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t}\n\tinode = NFS_PROTO(dir)->open_context(dir, ctx, openflags, &attr, NULL);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tswitch (err) {\n\t\tdefault:\n\t\t\tgoto out_put_ctx;\n\t\tcase -ENOENT:\n\t\tcase -ESTALE:\n\t\tcase -EISDIR:\n\t\tcase -ENOTDIR:\n\t\tcase -ELOOP:\n\t\t\tgoto out_drop;\n\t\t}\n\t}\n\tif (inode != d_inode(dentry))\n\t\tgoto out_drop;\n\tnfs_file_set_open_context(filp, ctx);\n\tnfs_fscache_open_file(inode, filp);\n\terr = 0;\nout_put_ctx:\n\tput_nfs_open_context(ctx);\nout:\n\tdput(parent);\n\treturn err;\nout_drop:\n\td_drop(dentry);\n\terr = -EOPENSTALE;\n\tgoto out_put_ctx;\n}", "target": 1}
{"code": "parse_tsquery(char *buf,\n\t\t\t  PushFunction pushval,\n\t\t\t  Datum opaque,\n\t\t\t  bool isplain)\n{\n\tstruct TSQueryParserStateData state;\n\tint\t\t\ti;\n\tTSQuery\t\tquery;\n\tint\t\t\tcommonlen;\n\tQueryItem  *ptr;\n\tListCell   *cell;\n\tstate.buffer = buf;\n\tstate.buf = buf;\n\tstate.state = (isplain) ? WAITSINGLEOPERAND : WAITFIRSTOPERAND;\n\tstate.count = 0;\n\tstate.polstr = NIL;\n\tstate.valstate = init_tsvector_parser(state.buffer, true, true);\n\tstate.sumlen = 0;\n\tstate.lenop = 64;\n\tstate.curop = state.op = (char *) palloc(state.lenop);\n\t*(state.curop) = '\\0';\n\tmakepol(&state, pushval, opaque);\n\tclose_tsvector_parser(state.valstate);\n\tif (list_length(state.polstr) == 0)\n\t{\n\t\tereport(NOTICE,\n\t\t\t\t(errmsg(\"text-search query doesn't contain lexemes: \\\"%s\\\"\",\n\t\t\t\t\t\tstate.buffer)));\n\t\tquery = (TSQuery) palloc(HDRSIZETQ);\n\t\tSET_VARSIZE(query, HDRSIZETQ);\n\t\tquery->size = 0;\n\t\treturn query;\n\t}\n\tcommonlen = COMPUTESIZE(list_length(state.polstr), state.sumlen);\n\tquery = (TSQuery) palloc0(commonlen);\n\tSET_VARSIZE(query, commonlen);\n\tquery->size = list_length(state.polstr);\n\tptr = GETQUERY(query);\n\ti = 0;\n\tforeach(cell, state.polstr)\n\t{\n\t\tQueryItem  *item = (QueryItem *) lfirst(cell);\n\t\tswitch (item->type)\n\t\t{\n\t\t\tcase QI_VAL:\n\t\t\t\tmemcpy(&ptr[i], item, sizeof(QueryOperand));\n\t\t\t\tbreak;\n\t\t\tcase QI_VALSTOP:\n\t\t\t\tptr[i].type = QI_VALSTOP;\n\t\t\t\tbreak;\n\t\t\tcase QI_OPR:\n\t\t\t\tmemcpy(&ptr[i], item, sizeof(QueryOperator));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"unrecognized QueryItem type: %d\", item->type);\n\t\t}\n\t\ti++;\n\t}\n\tmemcpy((void *) GETOPERAND(query), (void *) state.op, state.sumlen);\n\tpfree(state.op);\n\tfindoprnd(ptr, query->size);\n\treturn query;\n}", "target": 1}
{"code": "static int __init mb2cache_init(void)\n{\n\tmb2_entry_cache = kmem_cache_create(\"mbcache\",\n\t\t\t\tsizeof(struct mb2_cache_entry), 0,\n\t\t\t\tSLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD, NULL);\n\tBUG_ON(!mb2_entry_cache);\n\treturn 0;\n}", "target": 0}
{"code": "int bind_ports(void) {\n    SERVICE_OPTIONS *opt;\n    int listening_section;\n#ifdef USE_LIBWRAP\n    libwrap_init();\n#endif \n    s_poll_init(fds, 1);\n    for(opt=service_options.next; opt; opt=opt->next) {\n        unsigned i;\n        for(i=0; i<opt->local_addr.num; ++i)\n            opt->local_fd[i]=INVALID_SOCKET;\n    }\n    listening_section=0;\n    for(opt=service_options.next; opt; opt=opt->next) {\n        opt->bound_ports=0;\n        if(opt->local_addr.num) { \n            unsigned i;\n            s_log(LOG_DEBUG, \"Binding service [%s]\", opt->servname);\n            for(i=0; i<opt->local_addr.num; ++i) {\n                SOCKET fd;\n                fd=bind_port(opt, listening_section, i);\n                opt->local_fd[i]=fd;\n                if(fd!=INVALID_SOCKET) {\n                    s_poll_add(fds, fd, 1, 0);\n                    ++opt->bound_ports;\n                }\n            }\n            if(!opt->bound_ports) {\n                s_log(LOG_ERR, \"Binding service [%s] failed\", opt->servname);\n                return 1;\n            }\n            ++listening_section;\n        } else if(opt->exec_name && opt->connect_addr.names) {\n            s_log(LOG_DEBUG, \"Skipped exec+connect service [%s]\", opt->servname);\n#ifndef OPENSSL_NO_TLSEXT\n        } else if(!opt->option.client && opt->sni) {\n            s_log(LOG_DEBUG, \"Skipped SNI slave service [%s]\", opt->servname);\n#endif\n        } else { \n            s_log(LOG_ERR, \"Invalid service [%s]\", opt->servname);\n            return 1;\n        }\n    }\n    if(listening_section<systemd_fds) {\n        s_log(LOG_ERR,\n            \"Too many listening file descriptors received from systemd, got %d\",\n            systemd_fds);\n        return 1;\n    }\n    return 0; \n}", "target": 1}
{"code": "comics_document_class_init (ComicsDocumentClass *klass)\n{\n\tGObjectClass    *gobject_class = G_OBJECT_CLASS (klass);\n\tEvDocumentClass *ev_document_class = EV_DOCUMENT_CLASS (klass);\n\tgobject_class->finalize = comics_document_finalize;\n\tev_document_class->load = comics_document_load;\n\tev_document_class->save = comics_document_save;\n\tev_document_class->get_n_pages = comics_document_get_n_pages;\n\tev_document_class->get_page_size = comics_document_get_page_size;\n\tev_document_class->render = comics_document_render;\n}", "target": 0}
{"code": "static inline bool ib_safe_file_access(struct file *filp)\n{\n\treturn filp->f_cred == current_cred() && segment_eq(get_fs(), USER_DS);\n}", "target": 0}
{"code": "void HBCISel::generateHBCResolveEnvironment(\n    HBCResolveEnvironment *Inst,\n    BasicBlock *next) {\n  VariableScope *instScope = Inst->getScope();\n  Optional<int32_t> instScopeDepth = scopeAnalysis_.getScopeDepth(instScope);\n  Optional<int32_t> curScopeDepth =\n      scopeAnalysis_.getScopeDepth(F_->getFunctionScope());\n  if (!instScopeDepth || !curScopeDepth) {\n    emitUnreachableIfDebug();\n    return;\n  }\n  assert(\n      curScopeDepth && curScopeDepth.getValue() >= instScopeDepth.getValue() &&\n      \"Cannot access variables in inner scopes\");\n  int32_t delta = curScopeDepth.getValue() - instScopeDepth.getValue();\n  assert(delta > 0 && \"HBCResolveEnvironment for current scope\");\n  if (std::numeric_limits<uint8_t>::max() < delta) {\n    F_->getContext().getSourceErrorManager().error(\n        Inst->getLocation(), \"Variable environment is out-of-reach\");\n  }\n  BCFGen_->emitGetEnvironment(encodeValue(Inst), delta - 1);\n}", "target": 0}
{"code": "RootWindow* RootWindow::GetRootWindow() {\n  return this;\n}", "target": 0}
{"code": "static int crypto_report_kpp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_kpp rkpp;\n\tstrlcpy(rkpp.type, \"kpp\", sizeof(rkpp.type));\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_KPP,\n\t\t    sizeof(struct crypto_report_kpp), &rkpp))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "int main(int argc, char *argv[])\n{\n    FILE *iplist = NULL;\n    plist_t root_node = NULL;\n    char *plist_out = NULL;\n    uint32_t size = 0;\n    int read_size = 0;\n    char *plist_entire = NULL;\n    struct stat filestats;\n    options_t *options = parse_arguments(argc, argv);\n    if (!options)\n    {\n        print_usage(argc, argv);\n        return 0;\n    }\n    iplist = fopen(options->in_file, \"rb\");\n    if (!iplist) {\n        free(options);\n        return 1;\n    }\n    stat(options->in_file, &filestats);\n    if (filestats.st_size < 8) {\n        printf(\"ERROR: Input file is too small to contain valid plist data.\\n\");\n        return -1;\n    }\n    plist_entire = (char *) malloc(sizeof(char) * (filestats.st_size + 1));\n    read_size = fread(plist_entire, sizeof(char), filestats.st_size, iplist);\n    fclose(iplist);\n    if (memcmp(plist_entire, \"bplist00\", 8) == 0)\n    {\n        plist_from_bin(plist_entire, read_size, &root_node);\n        plist_to_xml(root_node, &plist_out, &size);\n    }\n    else\n    {\n        plist_from_xml(plist_entire, read_size, &root_node);\n        plist_to_bin(root_node, &plist_out, &size);\n    }\n    plist_free(root_node);\n    free(plist_entire);\n    if (plist_out)\n    {\n        if (options->out_file != NULL)\n        {\n            FILE *oplist = fopen(options->out_file, \"wb\");\n            if (!oplist) {\n                free(options);\n                return 1;\n            }\n            fwrite(plist_out, size, sizeof(char), oplist);\n            fclose(oplist);\n        }\n        else\n            fwrite(plist_out, size, sizeof(char), stdout);\n        free(plist_out);\n    }\n    else\n        printf(\"ERROR: Failed to convert input file.\\n\");\n    free(options);\n    return 0;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const auto& input = context->input(0);\n    auto flat_in = input.flat<tstring>();\n    int fixed_length;\n    const auto& length_input = context->input(1);\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(length_input.shape()),\n                errors::InvalidArgument(\"k must be scalar, got shape \",\n                                        length_input.shape().DebugString()));\n    fixed_length = length_input.scalar<int32>()();\n    OP_REQUIRES(\n        context, fixed_length % sizeof(T) == 0,\n        errors::InvalidArgument(\n            \"fixed_length (\", fixed_length,\n            \") must be a multiple of the size of out_type (\", sizeof(T), \")\"));\n    OP_REQUIRES(context, fixed_length > 0,\n                errors::InvalidArgument(\"fixed_length (\", fixed_length,\n                                        \") must be greater than zero.\"));\n    int width = fixed_length / sizeof(T);\n    TensorShape out_shape = input.shape();\n    out_shape.AddDim(width);\n    Tensor* output_tensor = nullptr;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(\"output\", out_shape, &output_tensor));\n    if (flat_in.size() == 0) {  \n      return;\n    }\n    auto out = output_tensor->flat_inner_dims<T>();\n    T* out_data = out.data();\n    memset(out_data, 0, fixed_length * flat_in.size());\n    if (!convert_data_endianness_ || sizeof(T) == 1) {\n      for (int64 i = 0; i < flat_in.size(); ++i) {\n        const T* in_data = reinterpret_cast<const T*>(flat_in(i).data());\n        if (flat_in(i).size() > fixed_length) {\n          memcpy(out_data, in_data, fixed_length);\n        } else {\n          memcpy(out_data, in_data, flat_in(i).size());\n        }\n        out_data += fixed_length;\n      }\n    } else {\n      for (int64 i = 0; i < flat_in.size(); ++i) {\n        const char* in_data_bytes =\n            reinterpret_cast<const char*>(flat_in(i).data());\n        char* out_data_bytes = reinterpret_cast<char*>(out_data);\n        const char* p_in = in_data_bytes;\n        char* p_out = out_data_bytes;\n        for (; p_in < in_data_bytes + fixed_length;\n             p_in += sizeof(T), p_out += sizeof(T)) {\n          std::reverse_copy(p_in, p_in + sizeof(T), p_out);\n        }\n        out_data += fixed_length;\n      }\n    }\n  }", "target": 1}
{"code": "void CtcpParser::query(CoreNetwork *net, const QString &bufname, const QString &ctcpTag, const QString &message)\n{\n    QList<QByteArray> params;\n    params << net->serverEncode(bufname) << lowLevelQuote(pack(net->serverEncode(ctcpTag), net->userEncode(bufname, message)));\n    static const char *splitter = \" .,-!?\";\n    int maxSplitPos = message.count();\n    int splitPos = maxSplitPos;\n    int overrun = net->userInputHandler()->lastParamOverrun(\"PRIVMSG\", params);\n    if (overrun) {\n        maxSplitPos = message.count() - overrun -2;\n        splitPos = -1;\n        for (const char *splitChar = splitter; *splitChar != 0; splitChar++) {\n            splitPos = qMax(splitPos, message.lastIndexOf(*splitChar, maxSplitPos) + 1); \n        }\n        if (splitPos <= 0 || splitPos > maxSplitPos)\n            splitPos = maxSplitPos;\n        params = params.mid(0, 1) <<  lowLevelQuote(pack(net->serverEncode(ctcpTag), net->userEncode(bufname, message.left(splitPos))));\n    }\n    net->putCmd(\"PRIVMSG\", params);\n    if (splitPos < message.count())\n        query(net, bufname, ctcpTag, message.mid(splitPos));\n}", "target": 1}
{"code": "  absl::string_view failureReason() const override { return error_; }", "target": 0}
{"code": "    OlympusMnHeader::~OlympusMnHeader()\n    {\n    }", "target": 0}
{"code": "int PackTmt::readFileHeader() {\n#define H(x) get_le16(h + 2 * (x))\n#define H4(x) get_le32(h + (x))\n    unsigned char h[0x40];\n    int ic;\n    unsigned exe_offset = 0;\n    adam_offset = 0;\n    for (ic = 0; ic < 20; ic++) {\n        fi->seek(adam_offset, SEEK_SET);\n        fi->readx(h, sizeof(h));\n        if (memcmp(h, \"MZ\", 2) == 0) \n        {\n            exe_offset = adam_offset;\n            adam_offset += H(2) * 512 + H(1);\n            if (H(1))\n                adam_offset -= 512;\n            if (H(0x18 / 2) == 0x40 && H4(0x3c))\n                adam_offset = H4(0x3c);\n        } else if (memcmp(h, \"BW\", 2) == 0)\n            adam_offset += H(2) * 512 + H(1);\n        else if (memcmp(h, \"PMW1\", 4) == 0) {\n            fi->seek(adam_offset + H4(0x18), SEEK_SET);\n            adam_offset += H4(0x24);\n            int objs = H4(0x1c);\n            while (objs--) {\n                fi->readx(h, 0x18);\n                adam_offset += H4(4);\n            }\n        } else if (memcmp(h, \"LE\", 2) == 0) {\n            unsigned offs = exe_offset + (H4(0x14) - 1) * H4(0x28) + H4(0x2c);\n            fi->seek(adam_offset + 0x80, SEEK_SET);\n            fi->readx(h, 4);\n            adam_offset = offs + H4(0);\n        } else if (memcmp(h, \"Adam\", 4) == 0)\n            break;\n        else\n            return 0;\n    }\n    if (ic == 20)\n        return 0;\n    fi->seek(adam_offset, SEEK_SET);\n    fi->readx(&ih, sizeof(ih));\n    unsigned const imagesize = ih.imagesize;\n    unsigned const entry = ih.entry;\n    unsigned const relocsize = ih.relocsize;\n    if (!imagesize || file_size <= imagesize || file_size <= entry || file_size <= relocsize) {\n        printWarn(getName(), \"bad header; imagesize=%#x  entry=%#x  relocsize=%#x\", imagesize,\n                  entry, relocsize);\n        return 0;\n    }\n    return UPX_F_TMT_ADAM;\n#undef H4\n#undef H\n}", "target": 1}
{"code": "horizontalDifference16(unsigned short *ip, int n, int stride, \n\tunsigned short *wp, uint16 *From14)\n{\n    register int  r1, g1, b1, a1, r2, g2, b2, a2, mask;\n#undef   CLAMP\n#define  CLAMP(v) From14[(v) >> 2]\n    mask = CODE_MASK;\n    if (n >= stride) {\n\tif (stride == 3) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);\n\t    n -= 3;\n\t    while (n > 0) {\n\t\tn -= 3;\n\t\twp += 3;\n\t\tip += 3;\n\t\tr1 = CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\n\t    }\n\t} else if (stride == 4) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);  a2 = wp[3] = CLAMP(ip[3]);\n\t    n -= 4;\n\t    while (n > 0) {\n\t\tn -= 4;\n\t\twp += 4;\n\t\tip += 4;\n\t\tr1 = CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\ta1 = CLAMP(ip[3]); wp[3] = (uint16)((a1-a2) & mask); a2 = a1;\n\t    }\n\t} else {\n\t    ip += n - 1;\t\n\t    wp += n - 1;\t\n\t    n -= stride;\n\t    while (n > 0) {\n\t\tREPEAT(stride, wp[0] = CLAMP(ip[0]);\n\t\t\t\twp[stride] -= wp[0];\n\t\t\t\twp[stride] &= mask;\n\t\t\t\twp--; ip--)\n\t\tn -= stride;\n\t    }\n\t    REPEAT(stride, wp[0] = CLAMP(ip[0]); wp--; ip--)\n\t}\n    }\n}", "target": 1}
{"code": "ldap_pvt_tls_init( void )\n{\n\treturn tls_init( tls_imp );\n}", "target": 0}
{"code": "TEST_F(OpLevelCostEstimatorTest, OpDimensionsFromInputsError) {\n  std::vector<string> paddings = {\"VALID\", \"SAME\"};\n  std::vector<string> formats = {\"NHWC\", \"NCHW\"};\n  for (const auto& p : paddings) {\n    for (const auto& f : formats) {\n      ASSERT_THAT(\n          CallOpDimensionsFromInputs(10, 14, 14, 3840, 3, 3, 0, 2, f, p),\n          testing::StatusIs(\n              error::INVALID_ARGUMENT,\n              \"Stride must be > 0 for Height and Width, but got (2, 0)\"));\n      ASSERT_THAT(\n          CallOpDimensionsFromInputs(10, 14, 14, 3840, 3, 3, 2, 0, f, p),\n          testing::StatusIs(\n              error::INVALID_ARGUMENT,\n              \"Stride must be > 0 for Height and Width, but got (0, 2)\"));\n    }\n  }\n}", "target": 0}
{"code": "int ext4_filemap_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tint err;\n\tdown_read(&EXT4_I(inode)->i_mmap_sem);\n\terr = filemap_fault(vma, vmf);\n\tup_read(&EXT4_I(inode)->i_mmap_sem);\n\treturn err;\n}", "target": 0}
{"code": "flushbuffer(PrintfTarget *target)\n{\n\tsize_t\t\tnc = target->bufptr - target->bufstart;\n\tif (nc > 0)\n\t\ttarget->nchars += fwrite(target->bufstart, 1, nc, target->stream);\n\ttarget->bufptr = target->bufstart;\n}", "target": 0}
{"code": "static bool checkreturn pb_dec_bytes(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    uint32_t size;\n    pb_bytes_array_t *bdest;\n    if (!pb_decode_varint32(stream, &size))\n        return false;\n    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)\n    {\n#ifndef PB_ENABLE_MALLOC\n        PB_RETURN_ERROR(stream, \"no malloc support\");\n#else\n        if (!allocate_field(stream, dest, PB_BYTES_ARRAY_T_ALLOCSIZE(size), 1))\n            return false;\n        bdest = *(pb_bytes_array_t**)dest;\n#endif\n    }\n    else\n    {\n        if (PB_BYTES_ARRAY_T_ALLOCSIZE(size) > field->data_size)\n            PB_RETURN_ERROR(stream, \"bytes overflow\");\n        bdest = (pb_bytes_array_t*)dest;\n    }\n    if (size > PB_SIZE_MAX)\n    {\n        PB_RETURN_ERROR(stream, \"bytes overflow\");\n    }\n    bdest->size = (pb_size_t)size;\n    return pb_read(stream, bdest->bytes, size);\n}", "target": 1}
{"code": "int IMA::decodeBlockWAVE(const uint8_t *encoded, int16_t *decoded)\n{\n\tint channelCount = m_track->f.channelCount;\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\tm_adpcmState[c].previousValue = (encoded[1]<<8) | encoded[0];\n\t\tif (encoded[1] & 0x80)\n\t\t\tm_adpcmState[c].previousValue -= 0x10000;\n\t\tm_adpcmState[c].index = encoded[2];\n\t\t*decoded++ = m_adpcmState[c].previousValue;\n\t\tencoded += 4;\n\t}\n\tfor (int n=0; n<m_framesPerPacket - 1; n += 8)\n\t{\n\t\tfor (int c=0; c<channelCount; c++)\n\t\t{\n\t\t\tint16_t *output = decoded + c;\n\t\t\tfor (int s=0; s<4; s++)\n\t\t\t{\n\t\t\t\t*output = decodeSample(m_adpcmState[c], *encoded & 0xf);\n\t\t\t\toutput += channelCount;\n\t\t\t\t*output = decodeSample(m_adpcmState[c], *encoded >> 4);\n\t\t\t\toutput += channelCount;\n\t\t\t\tencoded++;\n\t\t\t}\n\t\t}\n\t\tdecoded += channelCount * 8;\n\t}\n\treturn m_framesPerPacket * channelCount * sizeof (int16_t);\n}", "target": 1}
{"code": "void Huff_offsetTransmit (huff_t *huff, int ch, byte *fout, int *offset) {\n\tbloc = *offset;\n\tsend(huff->loc[ch], NULL, fout);\n\t*offset = bloc;\n}", "target": 1}
{"code": "static void apply_server_config(request_rec *r)\n{\n    apr_socket_t *csd;\n    csd = ap_get_conn_socket(r->connection);\n    apr_socket_timeout_set(csd, r->server->timeout);\n    r->per_dir_config = r->server->lookup_defaults;\n}", "target": 0}
{"code": "void Logger::addMessage(const QString &message, const Log::MsgType &type)\n{\n    QWriteLocker locker(&lock);\n    Log::Msg temp = { msgCounter++, QDateTime::currentMSecsSinceEpoch(), type, message };\n    m_messages.push_back(temp);\n    if (m_messages.size() >= MAX_LOG_MESSAGES)\n        m_messages.pop_front();\n    emit newLogMessage(temp);\n}", "target": 1}
{"code": "  void readDataAvailable(size_t len) noexcept override {\n    VLOG(3) << \"Read of size: \" << len;\n    s_->setReadCB(nullptr);\n    s_->getEventBase()->runInLoop([this]() { s_->setReadCB(this); });\n  }", "target": 0}
{"code": "ext2_xattr_cache_find(struct inode *inode, struct ext2_xattr_header *header)\n{\n\t__u32 hash = le32_to_cpu(header->h_hash);\n\tstruct mb_cache_entry *ce;\n\tif (!header->h_hash)\n\t\treturn NULL;  \n\tea_idebug(inode, \"looking for cached blocks [%x]\", (int)hash);\nagain:\n\tce = mb_cache_entry_find_first(ext2_xattr_cache, inode->i_sb->s_bdev,\n\t\t\t\t       hash);\n\twhile (ce) {\n\t\tstruct buffer_head *bh;\n\t\tif (IS_ERR(ce)) {\n\t\t\tif (PTR_ERR(ce) == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tbreak;\n\t\t}\n\t\tbh = sb_bread(inode->i_sb, ce->e_block);\n\t\tif (!bh) {\n\t\t\text2_error(inode->i_sb, \"ext2_xattr_cache_find\",\n\t\t\t\t\"inode %ld: block %ld read error\",\n\t\t\t\tinode->i_ino, (unsigned long) ce->e_block);\n\t\t} else {\n\t\t\tlock_buffer(bh);\n\t\t\tif (le32_to_cpu(HDR(bh)->h_refcount) >\n\t\t\t\t   EXT2_XATTR_REFCOUNT_MAX) {\n\t\t\t\tea_idebug(inode, \"block %ld refcount %d>%d\",\n\t\t\t\t\t  (unsigned long) ce->e_block,\n\t\t\t\t\t  le32_to_cpu(HDR(bh)->h_refcount),\n\t\t\t\t\t  EXT2_XATTR_REFCOUNT_MAX);\n\t\t\t} else if (!ext2_xattr_cmp(header, HDR(bh))) {\n\t\t\t\tea_bdebug(bh, \"b_count=%d\",\n\t\t\t\t\t  atomic_read(&(bh->b_count)));\n\t\t\t\tmb_cache_entry_release(ce);\n\t\t\t\treturn bh;\n\t\t\t}\n\t\t\tunlock_buffer(bh);\n\t\t\tbrelse(bh);\n\t\t}\n\t\tce = mb_cache_entry_find_next(ce, inode->i_sb->s_bdev, hash);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "vg_process_cursor_cmd(VuGpu *g, struct virtio_gpu_update_cursor *cursor)\n{\n    switch (cursor->hdr.type) {\n    case VIRTIO_GPU_CMD_MOVE_CURSOR: {\n        VhostUserGpuMsg msg = {\n            .request = cursor->resource_id ?\n                VHOST_USER_GPU_CURSOR_POS : VHOST_USER_GPU_CURSOR_POS_HIDE,\n            .size = sizeof(VhostUserGpuCursorPos),\n            .payload.cursor_pos = {\n                .scanout_id = cursor->pos.scanout_id,\n                .x = cursor->pos.x,\n                .y = cursor->pos.y,\n            }\n        };\n        g_debug(\"%s: move\", G_STRFUNC);\n        vg_send_msg(g, &msg, -1);\n        break;\n    }\n    case VIRTIO_GPU_CMD_UPDATE_CURSOR: {\n        VhostUserGpuMsg msg = {\n            .request = VHOST_USER_GPU_CURSOR_UPDATE,\n            .size = sizeof(VhostUserGpuCursorUpdate),\n            .payload.cursor_update = {\n                .pos = {\n                    .scanout_id = cursor->pos.scanout_id,\n                    .x = cursor->pos.x,\n                    .y = cursor->pos.y,\n                },\n                .hot_x = cursor->hot_x,\n                .hot_y = cursor->hot_y,\n            }\n        };\n        g_debug(\"%s: update\", G_STRFUNC);\n        if (g->virgl) {\n            vg_virgl_update_cursor_data(g, cursor->resource_id,\n                                        msg.payload.cursor_update.data);\n        } else {\n            update_cursor_data_simple(g, cursor->resource_id,\n                                      msg.payload.cursor_update.data);\n        }\n        vg_send_msg(g, &msg, -1);\n        break;\n    }\n    default:\n        g_debug(\"%s: unknown cmd %d\", G_STRFUNC, cursor->hdr.type);\n        break;\n    }\n}", "target": 0}
{"code": "static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData,\n                                   OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n{\n    OPJ_UINT32 x, y;\n    OPJ_UINT8 *pix;\n    const OPJ_UINT8 *beyond;\n    beyond = pData + stride * height;\n    pix = pData;\n    x = y = 0U;\n    while (y < height) {\n        int c = getc(IN);\n        if (c == EOF) {\n            return OPJ_FALSE;\n        }\n        if (c) {\n            int j, c1_int;\n            OPJ_UINT8 c1;\n            c1_int = getc(IN);\n            if (c1_int == EOF) {\n                return OPJ_FALSE;\n            }\n            c1 = (OPJ_UINT8)c1_int;\n            for (j = 0; (j < c) && (x < width) &&\n                    ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                *pix = c1;\n            }\n        } else {\n            c = getc(IN);\n            if (c == EOF) {\n                return OPJ_FALSE;\n            }\n            if (c == 0x00) { \n                x = 0;\n                ++y;\n                pix = pData + y * stride + x;\n            } else if (c == 0x01) { \n                break;\n            } else if (c == 0x02) { \n                c = getc(IN);\n                if (c == EOF) {\n                    return OPJ_FALSE;\n                }\n                x += (OPJ_UINT32)c;\n                c = getc(IN);\n                if (c == EOF) {\n                    return OPJ_FALSE;\n                }\n                y += (OPJ_UINT32)c;\n                pix = pData + y * stride + x;\n            } else { \n                int j;\n                for (j = 0; (j < c) && (x < width) &&\n                        ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                    int c1_int;\n                    OPJ_UINT8 c1;\n                    c1_int = getc(IN);\n                    if (c1_int == EOF) {\n                        return OPJ_FALSE;\n                    }\n                    c1 = (OPJ_UINT8)c1_int;\n                    *pix = c1;\n                }\n                if ((OPJ_UINT32)c & 1U) { \n                    c = getc(IN);\n                    if (c == EOF) {\n                        return OPJ_FALSE;\n                    }\n                }\n            }\n        }\n    }\n    return OPJ_TRUE;\n}", "target": 1}
{"code": "bool recovery_cipher_abort(void)\n{\n    recovery_started = false;\n    if (awaiting_character) {\n        awaiting_character = false;\n        return true;\n    }\n    return false;\n}", "target": 0}
{"code": "void HttpIntegrationTest::testLargeRequestTrailers(uint32_t size, uint32_t max_size) {\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void { hcm.mutable_max_request_headers_kb()->set_value(max_size); });\n  max_request_headers_kb_ = max_size;\n  Http::TestHeaderMapImpl request_trailers{{\"trailer\", \"trailer\"}};\n  request_trailers.addCopy(\"big\", std::string(size * 1024, 'a'));\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  fake_upstreams_[0]->set_allow_unexpected_disconnects(true);\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n  codec_client_->sendData(*request_encoder_, 10, false);\n  codec_client_->sendTrailers(*request_encoder_, request_trailers);\n  if (size >= max_size && downstream_protocol_ == Http::CodecClient::Type::HTTP2) {\n    response->waitForReset();\n    codec_client_->close();\n    EXPECT_FALSE(response->complete());\n  } else {\n    waitForNextUpstreamRequest();\n    upstream_request_->encodeHeaders(default_response_headers_, true);\n    response->waitForEndStream();\n    EXPECT_TRUE(response->complete());\n  }\n}", "target": 0}
{"code": "tegra_xusb_find_port_node(struct tegra_xusb_padctl *padctl, const char *type,\n\t\t\t  unsigned int index)\n{\n\tstruct device_node *ports, *np;\n\tchar *name;\n\tports = of_get_child_by_name(padctl->dev->of_node, \"ports\");\n\tif (!ports)\n\t\treturn NULL;\n\tname = kasprintf(GFP_KERNEL, \"%s-%u\", type, index);\n\tif (!name) {\n\t\tof_node_put(ports);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tnp = of_get_child_by_name(ports, name);\n\tkfree(name);\n\tof_node_put(ports);\n\treturn np;\n}", "target": 1}
{"code": "NTLM_AV_PAIR* ntlm_av_pair_get(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList, NTLM_AV_ID AvId,\n                               size_t* pcbAvPairListRemaining)\n{\n\tsize_t cbAvPair = cbAvPairList;\n\tNTLM_AV_PAIR* pAvPair = pAvPairList;\n\tif (!ntlm_av_pair_check(pAvPair, cbAvPair))\n\t\tpAvPair = NULL;\n\twhile (pAvPair)\n\t{\n\t\tUINT16 id = ntlm_av_pair_get_id(pAvPair);\n\t\tif (id == AvId)\n\t\t\tbreak;\n\t\tif (id == MsvAvEOL)\n\t\t{\n\t\t\tpAvPair = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tpAvPair = ntlm_av_pair_next(pAvPair, &cbAvPair);\n\t}\n\tif (!pAvPair)\n\t\tcbAvPair = 0;\n\tif (pcbAvPairListRemaining)\n\t\t*pcbAvPairListRemaining = cbAvPair;\n\treturn pAvPair;\n}", "target": 1}
{"code": "DU_getStringDOElement(DcmItem *obj, DcmTagKey t, char *s, size_t bufsize)\n{\n    DcmByteString *elem;\n    DcmStack stack;\n    OFCondition ec = EC_Normal;\n    char* aString;\n    ec = obj->search(t, stack);\n    elem = (DcmByteString*) stack.top();\n    if (ec == EC_Normal && elem != NULL) {\n        if (elem->getLength() == 0) {\n            s[0] = '\\0';\n        } else {\n            ec =  elem->getString(aString);\n            OFStandard::strlcpy(s, aString, bufsize);\n        }\n    }\n    return (ec == EC_Normal);\n}", "target": 1}
{"code": "static void save_client_addr(struct ip_addr *client_ip, uint8_t *hwaddr)\n{\n\tuint8_t d = (uint8_t)ip4_addr4(client_ip);\n\txSemaphoreTake(dhcps_ip_table_semaphore, portMAX_DELAY);\n\tmemcpy(ip_table.client_mac[d], hwaddr, 6); \n#if (debug_dhcps)\t\n\tprintf(\"\\r\\n%s: ip %d.%d.%d.%d, hwaddr %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\\n\", __func__,\n\t\tip4_addr1(client_ip), ip4_addr2(client_ip), ip4_addr3(client_ip), ip4_addr4(client_ip),\n\t\thwaddr[0], hwaddr[1], hwaddr[2], hwaddr[3], hwaddr[4], hwaddr[5]);\n#endif\t\n\txSemaphoreGive(dhcps_ip_table_semaphore);\n}", "target": 1}
{"code": "int migrate_page_move_mapping(struct address_space *mapping,\n\t\tstruct page *newpage, struct page *page,\n\t\tstruct buffer_head *head, enum migrate_mode mode,\n\t\tint extra_count)\n{\n\tint expected_count = 1 + extra_count;\n\tvoid **pslot;\n\tif (!mapping) {\n\t\tif (page_count(page) != expected_count)\n\t\t\treturn -EAGAIN;\n\t\tset_page_memcg(newpage, page_memcg(page));\n\t\tnewpage->index = page->index;\n\t\tnewpage->mapping = page->mapping;\n\t\tif (PageSwapBacked(page))\n\t\t\tSetPageSwapBacked(newpage);\n\t\treturn MIGRATEPAGE_SUCCESS;\n\t}\n\tspin_lock_irq(&mapping->tree_lock);\n\tpslot = radix_tree_lookup_slot(&mapping->page_tree,\n \t\t\t\t\tpage_index(page));\n\texpected_count += 1 + page_has_private(page);\n\tif (page_count(page) != expected_count ||\n\t\tradix_tree_deref_slot_protected(pslot, &mapping->tree_lock) != page) {\n\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\treturn -EAGAIN;\n\t}\n\tif (!page_freeze_refs(page, expected_count)) {\n\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\treturn -EAGAIN;\n\t}\n\tif (mode == MIGRATE_ASYNC && head &&\n\t\t\t!buffer_migrate_lock_buffers(head, mode)) {\n\t\tpage_unfreeze_refs(page, expected_count);\n\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\treturn -EAGAIN;\n\t}\n\tset_page_memcg(newpage, page_memcg(page));\n\tnewpage->index = page->index;\n\tnewpage->mapping = page->mapping;\n\tif (PageSwapBacked(page))\n\t\tSetPageSwapBacked(newpage);\n\tget_page(newpage);\t\n\tif (PageSwapCache(page)) {\n\t\tSetPageSwapCache(newpage);\n\t\tset_page_private(newpage, page_private(page));\n\t}\n\tradix_tree_replace_slot(pslot, newpage);\n\tpage_unfreeze_refs(page, expected_count - 1);\n\t__dec_zone_page_state(page, NR_FILE_PAGES);\n\t__inc_zone_page_state(newpage, NR_FILE_PAGES);\n\tif (!PageSwapCache(page) && PageSwapBacked(page)) {\n\t\t__dec_zone_page_state(page, NR_SHMEM);\n\t\t__inc_zone_page_state(newpage, NR_SHMEM);\n\t}\n\tspin_unlock_irq(&mapping->tree_lock);\n\treturn MIGRATEPAGE_SUCCESS;\n}", "target": 1}
{"code": "static int ssl_parse_client_psk_identity( mbedtls_ssl_context *ssl, unsigned char **p,\n                                          const unsigned char *end )\n{\n    int ret = 0;\n    size_t n;\n    if( ssl->conf->f_psk == NULL &&\n        ( ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL ||\n          ssl->conf->psk_identity_len == 0 || ssl->conf->psk_len == 0 ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got no pre-shared key\" ) );\n        return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );\n    }\n    if( *p + 2 > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n    n = ( (*p)[0] << 8 ) | (*p)[1];\n    *p += 2;\n    if( n < 1 || n > 65535 || *p + n > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n    if( ssl->conf->f_psk != NULL )\n    {\n        if( ssl->conf->f_psk( ssl->conf->p_psk, ssl, *p, n ) != 0 )\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n    }\n    else\n    {\n        if( n != ssl->conf->psk_identity_len ||\n            mbedtls_ssl_safer_memcmp( ssl->conf->psk_identity, *p, n ) != 0 )\n        {\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n        }\n    }\n    if( ret == MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY )\n    {\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"Unknown PSK identity\", *p, n );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY );\n        return( MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY );\n    }\n    *p += n;\n    return( 0 );\n}", "target": 1}
{"code": "static int l2cap_mode_supported(__u8 mode, __u32 feat_mask)\n{\n\tu32 local_feat_mask = l2cap_feat_mask;\n\tif (enable_ertm)\n\t\tlocal_feat_mask |= L2CAP_FEAT_ERTM;\n\tswitch (mode) {\n\tcase L2CAP_MODE_ERTM:\n\t\treturn L2CAP_FEAT_ERTM & feat_mask & local_feat_mask;\n\tcase L2CAP_MODE_STREAMING:\n\t\treturn L2CAP_FEAT_STREAMING & feat_mask & local_feat_mask;\n\tdefault:\n\t\treturn 0x00;\n\t}\n}", "target": 0}
{"code": "Status MakeArgTuple(const PyCall* call, TFE_Context* ctx, PyObject** tuple) {\n  int64_t n = call->ins.size();\n  PyObject* lst = PyList_New(n);\n  CHECK(lst);\n  const char* device_name = nullptr;\n  if (call->device != nullptr && !IsCPUDevice(call->device))\n    device_name = call->device->name().c_str();\n  for (int64_t i = 0; i < n; ++i) {\n    PyObject* arg = nullptr;\n    if (call->eager) {\n      Tensor t = call->ins[i];\n      arg = EagerTensorFromHandle(tensorflow::wrap(\n          tensorflow::unwrap(ctx)->CreateLocalHandleFromTFTensor(t,\n                                                                 device_name)));\n      if (arg == nullptr) {\n        Py_DECREF(lst);\n        return errors::Internal(\"Unable to procure EagerTensor from Tensor.\");\n      }\n    } else {\n      Status s = TensorToNdarray(call->ins[i], &arg);\n      if (!s.ok()) {\n        Py_DECREF(lst);\n        return s;\n      }\n      arg = PyArray_Return(reinterpret_cast<PyArrayObject*>(arg));\n    }\n    PyList_SetItem(lst, i, arg);\n  }\n  *tuple = Py_BuildValue(\"(ssN)\", call->token.c_str(), device_name, lst);\n  CHECK(*tuple);\n  return OkStatus();\n}", "target": 1}
{"code": "DLLIMPORT int cfg_rmnsec(cfg_t *cfg, const char *name, unsigned int index)\n{\n\treturn cfg_opt_rmnsec(cfg_getopt(cfg, name), index);\n}", "target": 0}
{"code": "void ip_options_build(struct sk_buff * skb, struct ip_options * opt,\n\t\t\t    __be32 daddr, struct rtable *rt, int is_frag)\n{\n\tunsigned char *iph = skb_network_header(skb);\n\tmemcpy(&(IPCB(skb)->opt), opt, sizeof(struct ip_options));\n\tmemcpy(iph+sizeof(struct iphdr), opt->__data, opt->optlen);\n\topt = &(IPCB(skb)->opt);\n\tif (opt->srr)\n\t\tmemcpy(iph+opt->srr+iph[opt->srr+1]-4, &daddr, 4);\n\tif (!is_frag) {\n\t\tif (opt->rr_needaddr)\n\t\t\tip_rt_get_source(iph+opt->rr+iph[opt->rr+2]-5, rt);\n\t\tif (opt->ts_needaddr)\n\t\t\tip_rt_get_source(iph+opt->ts+iph[opt->ts+2]-9, rt);\n\t\tif (opt->ts_needtime) {\n\t\t\tstruct timespec tv;\n\t\t\t__be32 midtime;\n\t\t\tgetnstimeofday(&tv);\n\t\t\tmidtime = htonl((tv.tv_sec % 86400) * MSEC_PER_SEC + tv.tv_nsec / NSEC_PER_MSEC);\n\t\t\tmemcpy(iph+opt->ts+iph[opt->ts+2]-5, &midtime, 4);\n\t\t}\n\t\treturn;\n\t}\n\tif (opt->rr) {\n\t\tmemset(iph+opt->rr, IPOPT_NOP, iph[opt->rr+1]);\n\t\topt->rr = 0;\n\t\topt->rr_needaddr = 0;\n\t}\n\tif (opt->ts) {\n\t\tmemset(iph+opt->ts, IPOPT_NOP, iph[opt->ts+1]);\n\t\topt->ts = 0;\n\t\topt->ts_needaddr = opt->ts_needtime = 0;\n\t}\n}", "target": 1}
{"code": "void IndexedDBDatabase::Clear(IndexedDBTransaction* transaction,\n                              int64_t object_store_id,\n                              scoped_refptr<IndexedDBCallbacks> callbacks) {\n  DCHECK(transaction);\n  IDB_TRACE1(\"IndexedDBDatabase::Clear\", \"txn.id\", transaction->id());\n  DCHECK_NE(transaction->mode(), blink::mojom::IDBTransactionMode::ReadOnly);\n  if (!ValidateObjectStoreId(object_store_id))\n    return;\n  transaction->ScheduleTask(base::BindOnce(&IndexedDBDatabase::ClearOperation,\n                                           this, object_store_id, callbacks));\n}", "target": 0}
{"code": "static int adpt_device_reset(struct scsi_cmnd* cmd)\n{\n\tadpt_hba* pHba;\n\tu32 msg[4];\n\tu32 rcode;\n\tint old_state;\n\tstruct adpt_device* d = cmd->device->hostdata;\n\tpHba = (void*) cmd->device->host->hostdata[0];\n\tprintk(KERN_INFO\"%s: Trying to reset device\\n\",pHba->name);\n\tif (!d) {\n\t\tprintk(KERN_INFO\"%s: Reset Device: Device Not found\\n\",pHba->name);\n\t\treturn FAILED;\n\t}\n\tmemset(msg, 0, sizeof(msg));\n\tmsg[0] = FOUR_WORD_MSG_SIZE|SGL_OFFSET_0;\n\tmsg[1] = (I2O_DEVICE_RESET<<24|HOST_TID<<12|d->tid);\n\tmsg[2] = 0;\n\tmsg[3] = 0;\n\tif (pHba->host)\n\t\tspin_lock_irq(pHba->host->host_lock);\n\told_state = d->state;\n\td->state |= DPTI_DEV_RESET;\n\trcode = adpt_i2o_post_wait(pHba, msg,sizeof(msg), FOREVER);\n\td->state = old_state;\n\tif (pHba->host)\n\t\tspin_unlock_irq(pHba->host->host_lock);\n\tif (rcode != 0) {\n\t\tif(rcode == -EOPNOTSUPP ){\n\t\t\tprintk(KERN_INFO\"%s: Device reset not supported\\n\",pHba->name);\n\t\t\treturn FAILED;\n\t\t}\n\t\tprintk(KERN_INFO\"%s: Device reset failed\\n\",pHba->name);\n\t\treturn FAILED;\n\t} else {\n\t\tprintk(KERN_INFO\"%s: Device reset successful\\n\",pHba->name);\n\t\treturn SUCCESS;\n\t}\n}", "target": 1}
{"code": "m_proleptic_julian_p(union DateData *x)\n{\n    double sg;\n    sg = m_sg(x);\n    if (isinf(sg) && sg > 0)\n\treturn 1;\n    return 0;\n}", "target": 0}
{"code": "static bool glfs_check_config(const char *cfgstring, char **reason)\n{\n\tchar *path;\n\tglfs_t *fs = NULL;\n\tglfs_fd_t *gfd = NULL;\n\tgluster_server *hosts = NULL; \n\tbool result = true;\n\tpath = strchr(cfgstring, '/');\n\tif (!path) {\n\t\tif (asprintf(reason, \"No path found\") == -1)\n\t\t\t*reason = NULL;\n\t\tresult = false;\n\t\tgoto done;\n\t}\n\tpath += 1; \n\tfs = tcmu_create_glfs_object(path, &hosts);\n\tif (!fs) {\n\t\ttcmu_err(\"tcmu_create_glfs_object failed\\n\");\n\t\tgoto done;\n\t}\n\tgfd = glfs_open(fs, hosts->path, ALLOWED_BSOFLAGS);\n\tif (!gfd) {\n\t\tif (asprintf(reason, \"glfs_open failed: %m\") == -1)\n\t\t\t*reason = NULL;\n\t\tresult = false;\n\t\tgoto unref;\n\t}\n\tif (glfs_access(fs, hosts->path, R_OK|W_OK) == -1) {\n\t\tif (asprintf(reason, \"glfs_access file not present, or not writable\") == -1)\n\t\t\t*reason = NULL;\n\t\tresult = false;\n\t\tgoto unref;\n\t}\n\tgoto done;\nunref:\n\tgluster_cache_refresh(fs, path);\ndone:\n\tif (gfd)\n\t\tglfs_close(gfd);\n\tgluster_free_server(&hosts);\n\treturn result;\n}", "target": 1}
{"code": "void* ipc_alloc(int size)\n{\n\tvoid* out;\n\tif(size > PAGE_SIZE)\n\t\tout = vmalloc(size);\n\telse\n\t\tout = kmalloc(size, GFP_KERNEL);\n\treturn out;\n}", "target": 1}
{"code": "ev_archive_class_init (EvArchiveClass *klass)\n{\n        GObjectClass *object_class = (GObjectClass *) klass;\n        object_class->finalize = ev_archive_finalize;\n}", "target": 0}
{"code": "static unsigned int btrfs_mask_fsflags_for_type(struct inode *inode,\n\t\tunsigned int flags)\n{\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn flags;\n\telse if (S_ISREG(inode->i_mode))\n\t\treturn flags & ~FS_DIRSYNC_FL;\n\telse\n\t\treturn flags & (FS_NODUMP_FL | FS_NOATIME_FL);\n}", "target": 0}
{"code": "Status CreateTempFileFloat(Env* env, float value, uint64 size,\n                           string* filename) {\n  const string dir = testing::TmpDir();\n  *filename = io::JoinPath(dir, strings::StrCat(\"file_\", value));\n  std::unique_ptr<WritableFile> file;\n  TF_RETURN_IF_ERROR(env->NewWritableFile(*filename, &file));\n  for (uint64 i = 0; i < size; ++i) {\n    StringPiece sp(static_cast<char*>(static_cast<void*>(&value)),\n                   sizeof(value));\n    TF_RETURN_IF_ERROR(file->Append(sp));\n  }\n  TF_RETURN_IF_ERROR(file->Close());\n  return Status::OK();\n}", "target": 0}
{"code": "int pdf_is_pdf(FILE *fp)\n{\n    int   is_pdf;\n    char *header;\n    header = get_header(fp);\n    if (header && strstr(header, \"%PDF-\"))\n      is_pdf = 1;\n    else \n      is_pdf = 0;\n    free(header);\n    return is_pdf;\n}", "target": 1}
{"code": "static int copy_to_user_tmpl(struct xfrm_policy *xp, struct sk_buff *skb)\n{\n\tstruct xfrm_user_tmpl vec[XFRM_MAX_DEPTH];\n\tint i;\n\tif (xp->xfrm_nr == 0)\n\t\treturn 0;\n\tfor (i = 0; i < xp->xfrm_nr; i++) {\n\t\tstruct xfrm_user_tmpl *up = &vec[i];\n\t\tstruct xfrm_tmpl *kp = &xp->xfrm_vec[i];\n\t\tmemset(up, 0, sizeof(*up));\n\t\tmemcpy(&up->id, &kp->id, sizeof(up->id));\n\t\tup->family = kp->encap_family;\n\t\tmemcpy(&up->saddr, &kp->saddr, sizeof(up->saddr));\n\t\tup->reqid = kp->reqid;\n\t\tup->mode = kp->mode;\n\t\tup->share = kp->share;\n\t\tup->optional = kp->optional;\n\t\tup->aalgos = kp->aalgos;\n\t\tup->ealgos = kp->ealgos;\n\t\tup->calgos = kp->calgos;\n\t}\n\treturn nla_put(skb, XFRMA_TMPL,\n\t\t       sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr, vec);\n}", "target": 0}
{"code": "userauth_gssapi(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tgss_OID_desc goid = {0, NULL};\n\tGssctxt *ctxt = NULL;\n\tint r, present;\n\tu_int mechs;\n\tOM_uint32 ms;\n\tsize_t len;\n\tu_char *doid = NULL;\n\tif (!authctxt->valid || authctxt->user == NULL)\n\t\treturn (0);\n\tif ((r = sshpkt_get_u32(ssh, &mechs)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\tif (mechs == 0) {\n\t\tdebug(\"Mechanism negotiation is not supported\");\n\t\treturn (0);\n\t}\n\tdo {\n\t\tmechs--;\n\t\tfree(doid);\n\t\tpresent = 0;\n\t\tif ((r = sshpkt_get_string(ssh, &doid, &len)) != 0)\n\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\tif (len > 2 && doid[0] == SSH_GSS_OIDTYPE &&\n\t\t    doid[1] == len - 2) {\n\t\t\tgoid.elements = doid + 2;\n\t\t\tgoid.length   = len - 2;\n\t\t\tssh_gssapi_test_oid_supported(&ms, &goid, &present);\n\t\t} else {\n\t\t\tlogit(\"Badly formed OID received\");\n\t\t}\n\t} while (mechs > 0 && !present);\n\tif (!present) {\n\t\tfree(doid);\n\t\tauthctxt->server_caused_failure = 1;\n\t\treturn (0);\n\t}\n\tif (GSS_ERROR(PRIVSEP(ssh_gssapi_server_ctx(&ctxt, &goid)))) {\n\t\tif (ctxt != NULL)\n\t\t\tssh_gssapi_delete_ctx(&ctxt);\n\t\tfree(doid);\n\t\tauthctxt->server_caused_failure = 1;\n\t\treturn (0);\n\t}\n\tauthctxt->methoddata = (void *)ctxt;\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_GSSAPI_RESPONSE)) != 0 ||\n\t    (r = sshpkt_put_string(ssh, doid, len)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\tfree(doid);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, &input_gssapi_token);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, &input_gssapi_errtok);\n\tauthctxt->postponed = 1;\n\treturn (0);\n}", "target": 1}
{"code": "static inline void o2nm_lock_subsystem(void)\n{\n\tmutex_lock(&o2nm_cluster_group.cs_subsys.su_mutex);\n}", "target": 0}
{"code": "char *suhosin_encrypt_single_cookie(char *name, int name_len, char *value, int value_len, char *key TSRMLS_DC)\n{\n\tchar buffer[4096];\n    char buffer2[4096];\n\tchar *buf = buffer, *buf2 = buffer2, *d, *d_url;\n    int l;\n\tif (name_len > sizeof(buffer)-2) {\n\t\tbuf = estrndup(name, name_len);\n\t} else {\n\t\tmemcpy(buf, name, name_len);\n\t\tbuf[name_len] = 0;\n\t}\n\tname_len = php_url_decode(buf, name_len);\n    normalize_varname(buf);\n    name_len = strlen(buf);\n\tif (SUHOSIN_G(cookie_plainlist)) {\n\t\tif (zend_hash_exists(SUHOSIN_G(cookie_plainlist), buf, name_len+1)) {\nencrypt_return_plain:\n\t\t\tif (buf != buffer) {\n\t\t\t\tefree(buf);\n\t\t\t}\n\t\t\treturn estrndup(value, value_len);\n\t\t}\n\t} else if (SUHOSIN_G(cookie_cryptlist)) {\n\t\tif (!zend_hash_exists(SUHOSIN_G(cookie_cryptlist), buf, name_len+1)) {\n\t\t\tgoto encrypt_return_plain;\n\t\t}\n\t}\n\tif (strlen(value) <= sizeof(buffer2)-2) {\n\t\tmemcpy(buf2, value, value_len);\n\t\tbuf2[value_len] = 0;\n\t} else {\n\t\tbuf2 = estrndup(value, value_len);\n\t}\n\tvalue_len = php_url_decode(buf2, value_len);\n\td = suhosin_encrypt_string(buf2, value_len, buf, name_len, key TSRMLS_CC);\n\td_url = php_url_encode(d, strlen(d), &l);\n\tefree(d);\n    if (buf != buffer) {\n\t\tefree(buf);\n\t}\n    if (buf2 != buffer2) {\n\t\tefree(buf2);\n\t}\n\treturn d_url;\n}", "target": 1}
{"code": "static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len,\n        bigint *modulus, bigint *pub_exp)\n{\n    int i, size;\n    bigint *decrypted_bi, *dat_bi;\n    bigint *bir = NULL;\n    uint8_t *block = (uint8_t *)malloc(sig_len);\n    dat_bi = bi_import(ctx, sig, sig_len);\n    ctx->mod_offset = BIGINT_M_OFFSET;\n    decrypted_bi = bi_mod_power2(ctx, dat_bi, modulus, pub_exp);\n    bi_export(ctx, decrypted_bi, block, sig_len);\n    ctx->mod_offset = BIGINT_M_OFFSET;\n    i = 10; \n    while (block[i++] && i < sig_len);\n    size = sig_len - i;\n    if (size > 0)\n    {\n        int len;\n        const uint8_t *sig_ptr = get_signature(&block[i], &len);\n        if (sig_ptr)\n        {\n            bir = bi_import(ctx, sig_ptr, len);\n        }\n    }\n    free(block);\n    bi_clear_cache(ctx);\n    return bir;\n}", "target": 1}
{"code": "static ssize_t available_instances_show(struct mdev_type *mtype,\n\t\t\t\t\tstruct mdev_type_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tconst struct mbochs_type *type =\n\t\t&mbochs_types[mtype_get_type_group_id(mtype)];\n\tint count = (max_mbytes - mbochs_used_mbytes) / type->mbytes;\n\treturn sprintf(buf, \"%d\\n\", count);\n}", "target": 1}
{"code": "static void mpeg4_encode_gop_header(MpegEncContext *s)\n{\n    int hours, minutes, seconds;\n    int64_t time;\n    put_bits(&s->pb, 16, 0);\n    put_bits(&s->pb, 16, GOP_STARTCODE);\n    time = s->current_picture_ptr->f->pts;\n    if (s->reordered_input_picture[1])\n        time = FFMIN(time, s->reordered_input_picture[1]->f->pts);\n    time = time * s->avctx->time_base.num;\n    s->last_time_base = FFUDIV(time, s->avctx->time_base.den);\n    seconds = FFUDIV(time, s->avctx->time_base.den);\n    minutes = FFUDIV(seconds, 60); seconds = FFUMOD(seconds, 60);\n    hours   = FFUDIV(minutes, 60); minutes = FFUMOD(minutes, 60);\n    hours   = FFUMOD(hours  , 24);\n    put_bits(&s->pb, 5, hours);\n    put_bits(&s->pb, 6, minutes);\n    put_bits(&s->pb, 1, 1);\n    put_bits(&s->pb, 6, seconds);\n    put_bits(&s->pb, 1, !!(s->avctx->flags & AV_CODEC_FLAG_CLOSED_GOP));\n    put_bits(&s->pb, 1, 0);  \n    ff_mpeg4_stuffing(&s->pb);\n}", "target": 1}
{"code": "build_unc_path_to_root(const struct smb_vol *vol,\n\t\tconst struct cifs_sb_info *cifs_sb)\n{\n\tchar *full_path, *pos;\n\tunsigned int pplen = vol->prepath ? strlen(vol->prepath) + 1 : 0;\n\tunsigned int unc_len = strnlen(vol->UNC, MAX_TREE_SIZE + 1);\n\tfull_path = kmalloc(unc_len + pplen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tstrncpy(full_path, vol->UNC, unc_len);\n\tpos = full_path + unc_len;\n\tif (pplen) {\n\t\t*pos++ = CIFS_DIR_SEP(cifs_sb);\n\t\tstrncpy(pos, vol->prepath, pplen);\n\t\tpos += pplen;\n\t}\n\t*pos = '\\0'; \n\tconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));\n\tcifs_dbg(FYI, \"%s: full_path=%s\\n\", __func__, full_path);\n\treturn full_path;\n}", "target": 1}
{"code": "static int crypto_givcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_blkcipher rblkcipher;\n\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"givcipher\");\n\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t alg->cra_ablkcipher.geniv ?: \"<built-in>\");\n\trblkcipher.blocksize = alg->cra_blocksize;\n\trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\n\trblkcipher.max_keysize = alg->cra_ablkcipher.max_keysize;\n\trblkcipher.ivsize = alg->cra_ablkcipher.ivsize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\n\t\t    sizeof(struct crypto_report_blkcipher), &rblkcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "arista_print_date_hms_time(netdissect_options *ndo, uint32_t seconds,\n\t\tuint32_t nanoseconds)\n{\n\ttime_t ts;\n\tstruct tm *tm;\n\tchar buf[BUFSIZE];\n\tts = seconds + (nanoseconds / 1000000000);\n\tnanoseconds %= 1000000000;\n\tif (NULL == (tm = gmtime(&ts)))\n\t\tND_PRINT(\"gmtime() error\");\n\telse if (0 == strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", tm))\n\t\tND_PRINT(\"strftime() error\");\n\telse\n\t\tND_PRINT(\"%s.%09u\", buf, nanoseconds);\n}", "target": 1}
{"code": "R_API RSocket *r_socket_accept_timeout(RSocket *s, unsigned int timeout) {\n\tfd_set read_fds;\n\tfd_set except_fds;\n\tFD_ZERO (&read_fds);\n\tFD_SET (s->fd, &read_fds);\n\tFD_ZERO (&except_fds);\n\tFD_SET (s->fd, &except_fds);\n\tstruct timeval t;\n\tt.tv_sec = timeout;\n\tt.tv_usec = 0;\n\tint r = select (s->fd + 1, &read_fds, NULL, &except_fds, &t);\n\tif(r < 0) {\n\t\tperror (\"select\");\n\t} else if (r > 0 && FD_ISSET (s->fd, &read_fds)) {\n\t\treturn r_socket_accept (s);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static void rb_wake_up_waiters(struct irq_work *work)\n{\n\tstruct rb_irq_work *rbwork = container_of(work, struct rb_irq_work, work);\n\twake_up_all(&rbwork->waiters);\n\tif (rbwork->wakeup_full) {\n\t\trbwork->wakeup_full = false;\n\t\twake_up_all(&rbwork->full_waiters);\n\t}\n}", "target": 0}
{"code": "node_new_anychar(void)\n{\n  Node* node = node_new_ctype(CTYPE_ANYCHAR, 0, ONIG_OPTION_NONE);\n  return node;\n}", "target": 0}
{"code": "static inline void find_entity_for_char(\n\tunsigned int k,\n\tenum entity_charset charset,\n\tconst entity_stage1_row *table,\n\tconst unsigned char **entity,\n\tsize_t *entity_len,\n\tunsigned char *old,\n\tsize_t oldlen,\n\tsize_t *cursor)\n{\n\tunsigned stage1_idx = ENT_STAGE1_INDEX(k);\n\tconst entity_stage3_row *c;\n\tif (stage1_idx > 0x1D) {\n\t\t*entity     = NULL;\n\t\t*entity_len = 0;\n\t\treturn;\n\t}\n\tc = &table[stage1_idx][ENT_STAGE2_INDEX(k)][ENT_STAGE3_INDEX(k)];\n\tif (!c->ambiguous) {\n\t\t*entity     = (const unsigned char *)c->data.ent.entity;\n\t\t*entity_len = c->data.ent.entity_len;\n\t} else {\n\t\tsize_t\t cursor_before\t= *cursor;\n\t\tint\t\t status\t\t\t= SUCCESS;\n\t\tunsigned next_char;\n\t\tif (!(*cursor < oldlen))\n\t\t\tgoto no_suitable_2nd;\n\t\tnext_char = get_next_char(charset, old, oldlen, cursor, &status); \n\t\tif (status == FAILURE)\n\t\t\tgoto no_suitable_2nd;\n\t\t{\n\t\t\tconst entity_multicodepoint_row *s, *e;\n\t\t\ts = &c->data.multicodepoint_table[1];\n\t\t\te = s - 1 + c->data.multicodepoint_table[0].leading_entry.size;\n\t\t\tfor ( ; s <= e; s++) {\n\t\t\t\tif (s->normal_entry.second_cp == next_char) {\n\t\t\t\t\t*entity     = s->normal_entry.entity;\n\t\t\t\t\t*entity_len = s->normal_entry.entity_len;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\nno_suitable_2nd:\n\t\t*cursor = cursor_before;\n\t\t*entity = (const unsigned char *)\n\t\t\tc->data.multicodepoint_table[0].leading_entry.default_entity;\n\t\t*entity_len = c->data.multicodepoint_table[0].leading_entry.default_entity_len;\n\t}\t\n}", "target": 1}
{"code": "int nfc_llcp_send_cc(struct nfc_llcp_sock *sock)\n{\n\tstruct nfc_llcp_local *local;\n\tstruct sk_buff *skb;\n\tu8 *miux_tlv = NULL, miux_tlv_length;\n\tu8 *rw_tlv = NULL, rw_tlv_length, rw;\n\tint err;\n\tu16 size = 0;\n\t__be16 miux;\n\tpr_debug(\"Sending CC\\n\");\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\tmiux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?\n\t\tlocal->miux : sock->miux;\n\trw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;\n\tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\n\t\t\t\t      &miux_tlv_length);\n\tif (!miux_tlv) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tsize += miux_tlv_length;\n\trw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\n\tif (!rw_tlv) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tsize += rw_tlv_length;\n\tskb = llcp_allocate_pdu(sock, LLCP_PDU_CC, size);\n\tif (skb == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tllcp_add_tlv(skb, miux_tlv, miux_tlv_length);\n\tllcp_add_tlv(skb, rw_tlv, rw_tlv_length);\n\tskb_queue_tail(&local->tx_queue, skb);\n\terr = 0;\nerror_tlv:\n\tif (err)\n\t\tpr_err(\"error %d\\n\", err);\n\tkfree(miux_tlv);\n\tkfree(rw_tlv);\n\treturn err;\n}", "target": 0}
{"code": "static int filter_frame(AVFilterLink *inlink, AVFrame *in)\n{\n    AVFilterContext *ctx = inlink->dst;\n    LutContext *s = ctx->priv;\n    AVFilterLink *outlink = ctx->outputs[0];\n    AVFrame *out;\n    uint8_t *inrow, *outrow, *inrow0, *outrow0;\n    int i, j, plane, direct = 0;\n    if (av_frame_is_writable(in)) {\n        direct = 1;\n        out = in;\n    } else {\n        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n        if (!out) {\n            av_frame_free(&in);\n            return AVERROR(ENOMEM);\n        }\n        av_frame_copy_props(out, in);\n    }\n    if (s->is_rgb) {\n        inrow0  = in ->data[0];\n        outrow0 = out->data[0];\n        for (i = 0; i < in->height; i ++) {\n            int w = inlink->w;\n            const uint8_t (*tab)[256] = (const uint8_t (*)[256])s->lut;\n            inrow  = inrow0;\n            outrow = outrow0;\n            for (j = 0; j < w; j++) {\n                switch (s->step) {\n                case 4:  outrow[3] = tab[3][inrow[3]]; \n                case 3:  outrow[2] = tab[2][inrow[2]]; \n                case 2:  outrow[1] = tab[1][inrow[1]]; \n                default: outrow[0] = tab[0][inrow[0]];\n                }\n                outrow += s->step;\n                inrow  += s->step;\n            }\n            inrow0  += in ->linesize[0];\n            outrow0 += out->linesize[0];\n        }\n    } else {\n        for (plane = 0; plane < 4 && in->data[plane]; plane++) {\n            int vsub = plane == 1 || plane == 2 ? s->vsub : 0;\n            int hsub = plane == 1 || plane == 2 ? s->hsub : 0;\n            int h = FF_CEIL_RSHIFT(inlink->h, vsub);\n            int w = FF_CEIL_RSHIFT(inlink->w, hsub);\n            inrow  = in ->data[plane];\n            outrow = out->data[plane];\n            for (i = 0; i < h; i++) {\n                const uint8_t *tab = s->lut[plane];\n                for (j = 0; j < w; j++)\n                    outrow[j] = tab[inrow[j]];\n                inrow  += in ->linesize[plane];\n                outrow += out->linesize[plane];\n            }\n        }\n    }\n    if (!direct)\n        av_frame_free(&in);\n    return ff_filter_frame(outlink, out);\n}", "target": 1}
{"code": "__u32 secure_ip_id(__be32 daddr)\n{\n\tstruct keydata *keyptr;\n\t__u32 hash[4];\n\tkeyptr = get_keyptr();\n\thash[0] = (__force __u32)daddr;\n\thash[1] = keyptr->secret[9];\n\thash[2] = keyptr->secret[10];\n\thash[3] = keyptr->secret[11];\n\treturn half_md4_transform(hash, keyptr->secret);\n}", "target": 1}
{"code": "static bool read_header_from_file(zckCtx *zck) {\n    if(zck->lead_size == 0 || zck->header_length == 0) {\n        set_error(zck, \"Lead and header sizes are both 0.  Have you run zck_read_lead() yet?\");\n        return false;\n    }\n    zck->header = zrealloc(zck->header, zck->lead_size + zck->header_length);\n    if (!zck->header) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return false;\n    }\n    zck->lead_string = zck->header;\n    char *header = zck->header + zck->lead_size;\n    size_t loaded = 0;\n    if(zck->header_length < zck->header_size - zck->lead_size) {\n        set_fatal_error(zck, \"Header size is too small for actual data\");\n        return false;\n    }\n    if(zck->lead_size < zck->header_size)\n        loaded = zck->header_size - zck->lead_size;\n    zck_log(ZCK_LOG_DEBUG, \"Reading the rest of the header: %llu bytes\",\n            (long long unsigned) zck->header_length);\n    if(loaded < zck->header_length) {\n        if(read_data(zck, header + loaded, zck->header_length - loaded) < zck->header_length - loaded) {\n            set_fatal_error(zck, \"Unable to read %llu bytes from the file\", zck->header_length - loaded);\n            return false;\n        }\n        zck->header_size = zck->lead_size + zck->header_length;\n    }\n    if(!hash_init(zck, &(zck->check_full_hash), &(zck->hash_type)))\n        return false;\n    if(!hash_update(zck, &(zck->check_full_hash), \"\\0ZCK1\", 5))\n        return false;\n    if(!hash_update(zck, &(zck->check_full_hash), zck->header+5,\n                    zck->hdr_digest_loc-5))\n        return false;\n    if(!hash_update(zck, &(zck->check_full_hash), header, zck->header_length))\n        return false;\n    int ret = validate_header(zck);\n    if(ret < 1) {\n        if(ret == -1)\n            set_fatal_error(zck, \"Header checksum failed verification\");\n        return false;\n    }\n    return true;\n}", "target": 1}
{"code": "ext4_xattr_release_block(handle_t *handle, struct inode *inode,\n\t\t\t struct buffer_head *bh)\n{\n\tstruct mb_cache_entry *ce = NULL;\n\tint error = 0;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\tce = mb_cache_entry_get(ext4_mb_cache, bh->b_bdev, bh->b_blocknr);\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, bh);\n\tif (error)\n\t\tgoto out;\n\tlock_buffer(bh);\n\tif (BHDR(bh)->h_refcount == cpu_to_le32(1)) {\n\t\tea_bdebug(bh, \"refcount now=0; freeing\");\n\t\tif (ce)\n\t\t\tmb_cache_entry_free(ce);\n\t\tget_bh(bh);\n\t\tunlock_buffer(bh);\n\t\text4_free_blocks(handle, inode, bh, 0, 1,\n\t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t} else {\n\t\tle32_add_cpu(&BHDR(bh)->h_refcount, -1);\n\t\tif (ce)\n\t\t\tmb_cache_entry_release(ce);\n\t\tif (ext4_handle_valid(handle))\n\t\t\terror = ext4_handle_dirty_xattr_block(handle, inode,\n\t\t\t\t\t\t\t      bh);\n\t\tunlock_buffer(bh);\n\t\tif (!ext4_handle_valid(handle))\n\t\t\terror = ext4_handle_dirty_xattr_block(handle, inode,\n\t\t\t\t\t\t\t      bh);\n\t\tif (IS_SYNC(inode))\n\t\t\text4_handle_sync(handle);\n\t\tdquot_free_block(inode, EXT4_C2B(EXT4_SB(inode->i_sb), 1));\n\t\tea_bdebug(bh, \"refcount now=%d; releasing\",\n\t\t\t  le32_to_cpu(BHDR(bh)->h_refcount));\n\t}\nout:\n\text4_std_error(inode->i_sb, error);\n\treturn;\n}", "target": 1}
{"code": "static void freeary(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp)\n{\n\tstruct sem_undo *un, *tu;\n\tstruct sem_queue *q, *tq;\n\tstruct sem_array *sma = container_of(ipcp, struct sem_array, sem_perm);\n\tstruct list_head tasks;\n\tint i;\n\tassert_spin_locked(&sma->sem_perm.lock);\n\tlist_for_each_entry_safe(un, tu, &sma->list_id, list_id) {\n\t\tlist_del(&un->list_id);\n\t\tspin_lock(&un->ulp->lock);\n\t\tun->semid = -1;\n\t\tlist_del_rcu(&un->list_proc);\n\t\tspin_unlock(&un->ulp->lock);\n\t\tkfree_rcu(un, rcu);\n\t}\n\tINIT_LIST_HEAD(&tasks);\n\tlist_for_each_entry_safe(q, tq, &sma->sem_pending, list) {\n\t\tunlink_queue(sma, q);\n\t\twake_up_sem_queue_prepare(&tasks, q, -EIDRM);\n\t}\n\tfor (i = 0; i < sma->sem_nsems; i++) {\n\t\tstruct sem *sem = sma->sem_base + i;\n\t\tlist_for_each_entry_safe(q, tq, &sem->sem_pending, list) {\n\t\t\tunlink_queue(sma, q);\n\t\t\twake_up_sem_queue_prepare(&tasks, q, -EIDRM);\n\t\t}\n\t}\n\tsem_rmid(ns, sma);\n\tsem_unlock(sma);\n\twake_up_sem_queue_do(&tasks);\n\tns->used_sems -= sma->sem_nsems;\n\tsecurity_sem_free(sma);\n\tipc_rcu_putref(sma);\n}", "target": 1}
{"code": "static int sockfs_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tint err = simple_setattr(dentry, iattr);\n\tif (!err && (iattr->ia_valid & ATTR_UID)) {\n\t\tstruct socket *sock = SOCKET_I(d_inode(dentry));\n\t\tsock->sk->sk_uid = iattr->ia_uid;\n\t}\n\treturn err;\n}", "target": 1}
{"code": "static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,\n\t\t\t\t     size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\tssize_t ret;\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\ttmp = !!tmp; \n\tif (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_NUM, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n\t\treturn -EINVAL; \n\tif (tmp && tmp == cluster->cl_has_local &&\n\t    cluster->cl_local_node != node->nd_num)\n\t\treturn -EBUSY;\n\tif (tmp && !cluster->cl_has_local) {\n\t\tret = o2net_start_listening(node);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (!tmp && cluster->cl_has_local &&\n\t    cluster->cl_local_node == node->nd_num) {\n\t\to2net_stop_listening(node);\n\t\tcluster->cl_local_node = O2NM_INVALID_NODE_NUM;\n\t}\n\tnode->nd_local = tmp;\n\tif (node->nd_local) {\n\t\tcluster->cl_has_local = tmp;\n\t\tcluster->cl_local_node = node->nd_num;\n\t}\n\treturn count;\n}", "target": 1}
{"code": "static VALUE read_memory(VALUE klass, VALUE content)\n{\n  xmlRelaxNGParserCtxtPtr ctx = xmlRelaxNGNewMemParserCtxt(\n      (const char *)StringValuePtr(content),\n      (int)RSTRING_LEN(content)\n  );\n  xmlRelaxNGPtr schema;\n  VALUE errors = rb_ary_new();\n  VALUE rb_schema;\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n#ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS\n  xmlRelaxNGSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n  schema = xmlRelaxNGParse(ctx);\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlRelaxNGFreeParserCtxt(ctx);\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n    return Qnil;\n  }\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n  return rb_schema;\n}", "target": 1}
{"code": "static int16_t decodeSample(ms_adpcm_state &state,\n\tuint8_t code, const int16_t *coefficient)\n{\n\tint linearSample = (state.sample1 * coefficient[0] +\n\t\tstate.sample2 * coefficient[1]) >> 8;\n\tlinearSample += ((code & 0x08) ? (code - 0x10) : code) * state.delta;\n\tlinearSample = clamp(linearSample, MIN_INT16, MAX_INT16);\n\tint delta = (state.delta * adaptationTable[code]) >> 8;\n\tif (delta < 16)\n\t\tdelta = 16;\n\tstate.delta = delta;\n\tstate.sample2 = state.sample1;\n\tstate.sample1 = linearSample;\n\treturn static_cast<int16_t>(linearSample);\n}", "target": 1}
{"code": "static inline VALUE fiobj_mustache_find_obj_absolute(VALUE udata,\n                                                     const char *name,\n                                                     uint32_t name_len) {\n  VALUE tmp;\n  if (!RB_TYPE_P(udata, T_HASH)) {\n    if (name_len == 1 && name[0] == '.')\n      return udata;\n    ID name_id = rb_intern2(name, name_len);\n    if (rb_respond_to(udata, name_id)) {\n      return IodineCaller.call(udata, name_id);\n    }\n    return Qnil;\n  }\n  ID name_id = rb_intern2(name, name_len);\n  VALUE key = ID2SYM(name_id);\n  tmp = rb_hash_lookup2(udata, key, Qundef);\n  if (tmp != Qundef)\n    return tmp;\n  key = rb_sym2str(key);\n  tmp = rb_hash_lookup2(udata, key, Qundef);\n  rb_str_free(key);\n  if (tmp != Qundef)\n    return tmp;\n  tmp = Qnil;\n  if (rb_respond_to(udata, name_id)) {\n    tmp = IodineCaller.call(udata, name_id);\n  }\n  return tmp;\n}", "target": 0}
{"code": "int hashbin_delete( hashbin_t* hashbin, FREE_FUNC free_func)\n{\n\tirda_queue_t* queue;\n\tunsigned long flags = 0;\n\tint i;\n\tIRDA_ASSERT(hashbin != NULL, return -1;);\n\tIRDA_ASSERT(hashbin->magic == HB_MAGIC, return -1;);\n\tif ( hashbin->hb_type & HB_LOCK ) {\n\t\tspin_lock_irqsave_nested(&hashbin->hb_spinlock, flags,\n\t\t\t\t\t hashbin_lock_depth++);\n\t}\n\tfor (i = 0; i < HASHBIN_SIZE; i ++ ) {\n\t\tqueue = dequeue_first((irda_queue_t**) &hashbin->hb_queue[i]);\n\t\twhile (queue ) {\n\t\t\tif (free_func)\n\t\t\t\t(*free_func)(queue);\n\t\t\tqueue = dequeue_first(\n\t\t\t\t(irda_queue_t**) &hashbin->hb_queue[i]);\n\t\t}\n\t}\n\thashbin->hb_current = NULL;\n\thashbin->magic = ~HB_MAGIC;\n\tif ( hashbin->hb_type & HB_LOCK) {\n\t\tspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\n#ifdef CONFIG_LOCKDEP\n\t\thashbin_lock_depth--;\n#endif\n\t}\n\tkfree(hashbin);\n\treturn 0;\n}", "target": 1}
{"code": "envoy::config::cluster::v3::Cluster ConfigHelper::buildH1ClusterWithHighCircuitBreakersLimits(\n    const std::string& name, int port, const std::string& address, const std::string& lb_policy) {\n  return TestUtility::parseYaml<envoy::config::cluster::v3::Cluster>(\n      fmt::format(R\"EOF(\n      name: {}\n      connect_timeout: 50s\n      type: STATIC\n      circuit_breakers:\n        thresholds:\n        - priority: DEFAULT\n          max_connections: 10000\n          max_pending_requests: 10000\n          max_requests: 10000\n          max_retries: 10000\n      load_assignment:\n        cluster_name: {}\n        endpoints:\n        - lb_endpoints:\n          - endpoint:\n              address:\n                socket_address:\n                  address: {}\n                  port_value: {}\n      lb_policy: {}\n    )EOF\",\n                  name, name, address, port, lb_policy));\n}", "target": 0}
{"code": "static int __f2fs_set_acl(struct inode *inode, int type,\n\t\t\tstruct posix_acl *acl, struct page *ipage)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\tset_acl_inode(inode, inode->i_mode);\n\t\t\tif (error == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tvalue = f2fs_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value)) {\n\t\t\tclear_inode_flag(inode, FI_ACL_MODE);\n\t\t\treturn (int)PTR_ERR(value);\n\t\t}\n\t}\n\terror = f2fs_setxattr(inode, name_index, \"\", value, size, ipage, 0);\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\tclear_inode_flag(inode, FI_ACL_MODE);\n\treturn error;\n}", "target": 1}
{"code": "static HashTable *spl_array_get_gc(zval *object, zval ***gc_data, int *gc_data_count TSRMLS_DC) \n{\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);\n\t*gc_data = &intern->array;\n\t*gc_data_count = 1;\n\treturn zend_std_get_properties(object);\n}", "target": 0}
{"code": "static int rds_ib_laddr_check(__be32 addr)\n{\n\tint ret;\n\tstruct rdma_cm_id *cm_id;\n\tstruct sockaddr_in sin;\n\tcm_id = rdma_create_id(NULL, NULL, RDMA_PS_TCP, IB_QPT_RC);\n\tif (IS_ERR(cm_id))\n\t\treturn PTR_ERR(cm_id);\n\tmemset(&sin, 0, sizeof(sin));\n\tsin.sin_family = AF_INET;\n\tsin.sin_addr.s_addr = addr;\n\tret = rdma_bind_addr(cm_id, (struct sockaddr *)&sin);\n\tif (ret || cm_id->device->node_type != RDMA_NODE_IB_CA)\n\t\tret = -EADDRNOTAVAIL;\n\trdsdebug(\"addr %pI4 ret %d node type %d\\n\",\n\t\t&addr, ret,\n\t\tcm_id->device ? cm_id->device->node_type : -1);\n\trdma_destroy_id(cm_id);\n\treturn ret;\n}", "target": 1}
{"code": "static int parse_video_info(AVIOContext *pb, AVStream *st)\n{\n    uint16_t size_asf; \n    uint32_t size_bmp; \n    unsigned int tag;\n    st->codecpar->width  = avio_rl32(pb);\n    st->codecpar->height = avio_rl32(pb);\n    avio_skip(pb, 1); \n    size_asf = avio_rl16(pb);\n    tag = ff_get_bmp_header(pb, st, &size_bmp);\n    st->codecpar->codec_tag = tag;\n    st->codecpar->codec_id  = ff_codec_get_id(ff_codec_bmp_tags, tag);\n    size_bmp = FFMAX(size_asf, size_bmp);\n    if (size_bmp > BMP_HEADER_SIZE) {\n        int ret;\n        st->codecpar->extradata_size  = size_bmp - BMP_HEADER_SIZE;\n        if (!(st->codecpar->extradata = av_malloc(st->codecpar->extradata_size +\n                                               AV_INPUT_BUFFER_PADDING_SIZE))) {\n            st->codecpar->extradata_size = 0;\n            return AVERROR(ENOMEM);\n        }\n        memset(st->codecpar->extradata + st->codecpar->extradata_size , 0,\n               AV_INPUT_BUFFER_PADDING_SIZE);\n        if ((ret = avio_read(pb, st->codecpar->extradata,\n                             st->codecpar->extradata_size)) < 0)\n            return ret;\n    }\n    return 0;\n}", "target": 1}
{"code": "static int check_ptr_alignment(struct bpf_verifier_env *env,\n\t\t\t       const struct bpf_reg_state *reg,\n\t\t\t       int off, int size)\n{\n\tbool strict = env->strict_alignment;\n\tconst char *pointer_desc = \"\";\n\tswitch (reg->type) {\n\tcase PTR_TO_PACKET:\n\tcase PTR_TO_PACKET_META:\n\t\treturn check_pkt_ptr_alignment(env, reg, off, size, strict);\n\tcase PTR_TO_MAP_VALUE:\n\t\tpointer_desc = \"value \";\n\t\tbreak;\n\tcase PTR_TO_CTX:\n\t\tpointer_desc = \"context \";\n\t\tbreak;\n\tcase PTR_TO_STACK:\n\t\tpointer_desc = \"stack \";\n\t\tstrict = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn check_generic_ptr_alignment(env, reg, pointer_desc, off, size,\n\t\t\t\t\t   strict);\n}", "target": 0}
{"code": "void iwjson_ftoa(long double val, char buf[static IWNUMBUF_SIZE], size_t *out_len) {\n  int len = snprintf(buf, 64, \"%.8Lf\", val);\n  if (len <= 0) {\n    buf[0] = '\\0';\n    *out_len = 0;\n    return;\n  }\n  while (len > 0 && buf[len - 1] == '0') { \n    buf[len - 1] = '\\0';\n    len--;\n  }\n  if ((len > 0) && (buf[len - 1] == '.')) {\n    buf[len - 1] = '\\0';\n    len--;\n  }\n  *out_len = (size_t) len;\n}", "target": 1}
{"code": "static __inline__ void scm_set_cred(struct scm_cookie *scm,\n\t\t\t\t    struct pid *pid, const struct cred *cred)\n{\n\tscm->pid  = get_pid(pid);\n\tscm->cred = cred ? get_cred(cred) : NULL;\n\tscm->creds.pid = pid_vnr(pid);\n\tscm->creds.uid = cred ? cred->euid : INVALID_UID;\n\tscm->creds.gid = cred ? cred->egid : INVALID_GID;\n}", "target": 1}
{"code": "int __usb_get_extra_descriptor(char *buffer, unsigned size,\n\t\t\t       unsigned char type, void **ptr)\n{\n\tstruct usb_descriptor_header *header;\n\twhile (size >= sizeof(struct usb_descriptor_header)) {\n\t\theader = (struct usb_descriptor_header *)buffer;\n\t\tif (header->bLength < 2) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"%s: bogus descriptor, type %d length %d\\n\",\n\t\t\t\tusbcore_name,\n\t\t\t\theader->bDescriptorType,\n\t\t\t\theader->bLength);\n\t\t\treturn -1;\n\t\t}\n\t\tif (header->bDescriptorType == type) {\n\t\t\t*ptr = header;\n\t\t\treturn 0;\n\t\t}\n\t\tbuffer += header->bLength;\n\t\tsize -= header->bLength;\n\t}\n\treturn -1;\n}", "target": 1}
{"code": "void WasmBinaryWriter::writeFunctionSignatures() {\n  if (importInfo->getNumDefinedFunctions() == 0) {\n    return;\n  }\n  BYN_TRACE(\"== writeFunctionSignatures\\n\");\n  auto start = startSection(BinaryConsts::Section::Function);\n  o << U32LEB(importInfo->getNumDefinedFunctions());\n  ModuleUtils::iterDefinedFunctions(*wasm, [&](Function* func) {\n    BYN_TRACE(\"write one\\n\");\n    o << U32LEB(getTypeIndex(func->type));\n  });\n  finishSection(start);\n}", "target": 0}
{"code": "TfLiteStatus TanhPrepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  OpData* data = static_cast<OpData*>(node->user_data);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  data->input_zero_point = input->params.zero_point;\n  return CalculateArithmeticOpData(context, node, data);\n}", "target": 0}
{"code": "std::string Url::DecodeUnsafe(string_view encoded) {\n  std::string raw;\n  if (Decode(encoded, &raw)) {\n    return raw;\n  }\n  return ToString(encoded);\n}", "target": 0}
{"code": "static void lan78xx_disconnect(struct usb_interface *intf)\n{\n\tstruct lan78xx_net *dev;\n\tstruct usb_device *udev;\n\tstruct net_device *net;\n\tstruct phy_device *phydev;\n\tdev = usb_get_intfdata(intf);\n\tusb_set_intfdata(intf, NULL);\n\tif (!dev)\n\t\treturn;\n\tset_bit(EVENT_DEV_DISCONNECT, &dev->flags);\n\tnetif_napi_del(&dev->napi);\n\tudev = interface_to_usbdev(intf);\n\tnet = dev->net;\n\tunregister_netdev(net);\n\tcancel_delayed_work_sync(&dev->wq);\n\tphydev = net->phydev;\n\tphy_unregister_fixup_for_uid(PHY_KSZ9031RNX, 0xfffffff0);\n\tphy_unregister_fixup_for_uid(PHY_LAN8835, 0xfffffff0);\n\tphy_disconnect(net->phydev);\n\tif (phy_is_pseudo_fixed_link(phydev))\n\t\tfixed_phy_unregister(phydev);\n\tusb_scuttle_anchored_urbs(&dev->deferred);\n\tif (timer_pending(&dev->stat_monitor))\n\t\tdel_timer_sync(&dev->stat_monitor);\n\tlan78xx_unbind(dev, intf);\n\tlan78xx_free_tx_resources(dev);\n\tlan78xx_free_rx_resources(dev);\n\tusb_kill_urb(dev->urb_intr);\n\tusb_free_urb(dev->urb_intr);\n\tfree_netdev(net);\n\tusb_put_dev(udev);\n}", "target": 1}
{"code": "static void nhml_node_end(void *sax_cbck, const char *node_name, const char *name_space)\n{\n\tXMLBreaker *breaker = (XMLBreaker *)sax_cbck;\n\tchar *node_id = (char *)gf_list_last(breaker->id_stack);\n\tgf_list_rem_last(breaker->id_stack);\n\tif (breaker->from_is_end && breaker->from_id && !strcmp(breaker->from_id, node_id)) {\n\t\tbreaker->from_pos = gf_xml_sax_get_node_end_pos(breaker->sax);\n\t\tbreaker->from_is_end = GF_FALSE;\n\t}\n\tif (breaker->to_is_end && breaker->to_id && !strcmp(breaker->to_id, node_id)) {\n\t\tbreaker->to_pos = gf_xml_sax_get_node_end_pos(breaker->sax);\n\t\tbreaker->to_is_end = GF_FALSE;\n\t}\n\tgf_free(node_id);\n\tif (!breaker->to_is_start && !breaker->from_is_start && !breaker->to_is_end && !breaker->from_is_end) {\n\t\tgf_xml_sax_suspend(breaker->sax, GF_TRUE);\n\t}\n}", "target": 0}
{"code": "ArcMemory::ArcMemory()\n{\n  Loaded=false;\n  SeekPos=0;\n}", "target": 0}
{"code": "  void DefaultEnv::Initialize()\n  {\n    sLog           = new Log();\n    SetUpLog();\n    sEnv           = new DefaultEnv();\n    sForkHandler   = new ForkHandler();\n    sFileTimer     = new FileTimer();\n    sPlugInManager = new PlugInManager();\n    sPlugInManager->ProcessEnvironmentSettings();\n    sForkHandler->RegisterFileTimer( sFileTimer );\n#ifdef __APPLE__\n    char *errBuff = new char[1024];\n    const char *libs[] =\n    {\n      \"libXrdSeckrb5.so\",\n      \"libXrdSecgsi.so\",\n      \"libXrdSecgsiAuthzVO.so\",\n      \"libXrdSecgsiGMAPDN.so\",\n      \"libXrdSecgsiGMAPLDAP.so\",\n      \"libXrdSecpwd.so\",\n      \"libXrdSecsss.so\",\n      \"libXrdSecunix.so\",\n      0\n    };\n    for( int i = 0; libs[i]; ++i )\n    {\n      sLog->Debug( UtilityMsg, \"Attempting to pre-load: %s\", libs[i] );\n      bool ok = XrdOucPreload( libs[i], errBuff, 1024 );\n      if( !ok )\n        sLog->Error( UtilityMsg, \"Unable to pre-load %s: %s\", libs[i], errBuff );\n    }\n    delete [] errBuff;\n#endif\n  }", "target": 1}
{"code": "void ContainerNode::cloneChildNodes(ContainerNode *clone)\n{\n    TrackExceptionState exceptionState;\n    for (Node* n = firstChild(); n && !exceptionState.hadException(); n = n->nextSibling())\n        clone->appendChild(n->cloneNode(true), exceptionState);\n}", "target": 0}
{"code": "deinit_authz(void *data)\n{\n  authz_pool = NULL;\n  filtered_pool = NULL;\n  authz_pool_initialized = FALSE;\n  return APR_SUCCESS;\n}", "target": 0}
{"code": "static CURLcode imap_parse_url_path(struct connectdata *conn)\n{\n  struct imap_conn *imapc = &conn->proto.imapc;\n  struct SessionHandle *data = conn->data;\n  const char *path = data->state.path;\n  int len;\n  if(!*path)\n    path = \"INBOX\";\n  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);\n  if(!imapc->mailbox)\n    return CURLE_OUT_OF_MEMORY;\n  return CURLE_OK;\n}", "target": 1}
{"code": "static void cp2112_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n\tint ret;\n\tspin_lock_irqsave(&dev->lock, flags);\n\tbuf[0] = CP2112_GPIO_SET;\n\tbuf[1] = value ? 0xff : 0;\n\tbuf[2] = 1 << offset;\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_SET, buf,\n\t\t\t\t CP2112_GPIO_SET_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0)\n\t\thid_err(hdev, \"error setting GPIO values: %d\\n\", ret);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n}", "target": 1}
{"code": "    **/\n    T cubic_cut_atXYZ(const float fx, const float fy, const float fz, const int c, const T& out_value) const {\n      return cimg::type<T>::cut(cubic_atXYZ(fx,fy,fz,c,out_value));", "target": 0}
{"code": "TEST(ModMatchExpression, MatchesArrayValue) {\n    ModMatchExpression mod(\"a\", 5, 2);\n    ASSERT(mod.matchesBSON(BSON(\"a\" << BSON_ARRAY(5 << 12LL)), NULL));\n    ASSERT(!mod.matchesBSON(BSON(\"a\" << BSON_ARRAY(6 << 8)), NULL));\n}", "target": 0}
{"code": "void sendClean( char* str ) {\n    CleanupOutput(str);\n    send(str);\n}", "target": 0}
{"code": "static size_t read_test_file(char **buffer, char *basename)\n{\n    char *filename;\n    FILE *fp;\n    size_t exp_size, act_size;\n    filename = gdTestFilePath2(\"tiff\", basename);\n    fp = fopen(filename, \"rb\");\n    gdTestAssert(fp != NULL);\n\tfseek(fp, 0, SEEK_END);\n\texp_size = ftell(fp);\n\tfseek(fp, 0, SEEK_SET);\n    *buffer = malloc(exp_size);\n    gdTestAssert(*buffer != NULL);\n    act_size = fread(*buffer, sizeof(**buffer), exp_size, fp);\n    gdTestAssert(act_size == exp_size);\n    fclose(fp);\n    free(filename);\n    return act_size;\n}", "target": 0}
{"code": "cmd_len(conn c)\n{\n    return scan_line_end(c->cmd, c->cmd_read);\n}", "target": 0}
{"code": "const char *enc_untrusted_inet_ntop(int af, const void *src, char *dst,\n                                    socklen_t size) {\n  if (!src || !dst) {\n    errno = EFAULT;\n    return nullptr;\n  }\n  size_t src_size = 0;\n  if (af == AF_INET) {\n    src_size = sizeof(struct in_addr);\n  } else if (af == AF_INET6) {\n    src_size = sizeof(struct in6_addr);\n  } else {\n    errno = EAFNOSUPPORT;\n    return nullptr;\n  }\n  MessageWriter input;\n  input.Push<int>(TokLinuxAfFamily(af));\n  input.PushByReference(Extent{reinterpret_cast<const char *>(src), src_size});\n  input.Push(size);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kInetNtopHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_inet_ntop\", 2);\n  auto result = output.next();\n  int klinux_errno = output.next<int>();\n  if (result.empty()) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return nullptr;\n  }\n  memcpy(dst, result.data(),\n         std::min(static_cast<size_t>(size),\n                  static_cast<size_t>(INET6_ADDRSTRLEN)));\n  return dst;\n}", "target": 1}
{"code": "static void cliRefreshPrompt(void) {\n    int len;\n    if (config.eval_ldb) return;\n    if (config.hostsocket != NULL)\n        len = snprintf(config.prompt,sizeof(config.prompt),\"redis %s\",\n                       config.hostsocket);\n    else\n        len = anetFormatAddr(config.prompt, sizeof(config.prompt),\n                           config.hostip, config.hostport);\n    if (config.dbnum != 0)\n        len += snprintf(config.prompt+len,sizeof(config.prompt)-len,\"[%d]\",\n            config.dbnum);\n    snprintf(config.prompt+len,sizeof(config.prompt)-len,\"> \");\n}", "target": 1}
{"code": "int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gid, mode_t mode) {\n        _cleanup_close_ int fd;\n        int r;\n        assert(path);\n        if (parents)\n                mkdir_parents(path, 0755);\n        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY, mode > 0 ? mode : 0644);\n        if (fd < 0)\n                return -errno;\n        if (mode > 0) {\n                r = fchmod(fd, mode);\n                if (r < 0)\n                        return -errno;\n        }\n        if (uid != UID_INVALID || gid != GID_INVALID) {\n                r = fchown(fd, uid, gid);\n                if (r < 0)\n                        return -errno;\n        }\n        if (stamp != USEC_INFINITY) {\n                struct timespec ts[2];\n                timespec_store(&ts[0], stamp);\n                ts[1] = ts[0];\n                r = futimens(fd, ts);\n        } else\n                r = futimens(fd, NULL);\n        if (r < 0)\n                return -errno;\n        return 0;\n}", "target": 1}
{"code": "int perf_config(config_fn_t fn, void *data)\n{\n\tint ret = 0, found = 0;\n\tchar *repo_config = NULL;\n\tconst char *home = NULL;\n\tif (config_exclusive_filename)\n\t\treturn perf_config_from_file(fn, config_exclusive_filename, data);\n\tif (perf_config_system() && !access(perf_etc_perfconfig(), R_OK)) {\n\t\tret += perf_config_from_file(fn, perf_etc_perfconfig(),\n\t\t\t\t\t    data);\n\t\tfound += 1;\n\t}\n\thome = getenv(\"HOME\");\n\tif (perf_config_global() && home) {\n\t\tchar *user_config = strdup(mkpath(\"%s/.perfconfig\", home));\n\t\tif (!access(user_config, R_OK)) {\n\t\t\tret += perf_config_from_file(fn, user_config, data);\n\t\t\tfound += 1;\n\t\t}\n\t\tfree(user_config);\n\t}\n\trepo_config = perf_pathdup(\"config\");\n\tif (!access(repo_config, R_OK)) {\n\t\tret += perf_config_from_file(fn, repo_config, data);\n\t\tfound += 1;\n\t}\n\tfree(repo_config);\n\tif (found == 0)\n\t\treturn -1;\n\treturn ret;\n}", "target": 1}
{"code": "void RenderViewTest::SendWebGestureEvent(\n    const blink::WebGestureEvent& gesture_event) {\n  SendInputEvent(gesture_event);\n}", "target": 0}
{"code": "juniper_atm1_print(netdissect_options *ndo,\n                   const struct pcap_pkthdr *h, register const u_char *p)\n{\n        int llc_hdrlen;\n        struct juniper_l2info_t l2info;\n        l2info.pictype = DLT_JUNIPER_ATM1;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        if (l2info.cookie[0] == 0x80) { \n            oam_print(ndo, p, l2info.length, ATM_OAM_NOHEC);\n            return l2info.header_len;\n        }\n        ND_TCHECK2(p[0], 3);\n        if (EXTRACT_24BITS(p) == 0xfefe03 || \n            EXTRACT_24BITS(p) == 0xaaaa03) { \n            llc_hdrlen = llc_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);\n            if (llc_hdrlen > 0)\n                return l2info.header_len;\n        }\n        if (p[0] == 0x03) { \n            isoclns_print(ndo, p + 1, l2info.length - 1);\n            return l2info.header_len;\n        }\n        if (ip_heuristic_guess(ndo, p, l2info.length) != 0) \n            return l2info.header_len;\n\treturn l2info.header_len;\ntrunc:\n\tND_PRINT((ndo, \"[|juniper_atm1]\"));\n\treturn l2info.header_len;\n}", "target": 0}
{"code": "bool chopOffDotted(string &domain)\n{\n  if(domain.empty() || (domain.size()==1 && domain[0]=='.'))\n    return false;\n  string::size_type fdot=domain.find('.');\n  if(fdot == string::npos)\n    return false;\n  if(fdot==domain.size()-1) \n    domain=\".\";\n  else  {\n    string::size_type remain = domain.length() - (fdot + 1);\n    char tmp[remain];\n    memcpy(tmp, domain.c_str()+fdot+1, remain);\n    domain.assign(tmp, remain);\n  }\n  return true;\n}", "target": 1}
{"code": "TfLiteStatus GetOutputSafe(const TfLiteContext* context, const TfLiteNode* node,\n                           int index, TfLiteTensor** tensor) {\n  int tensor_index;\n  TF_LITE_ENSURE_OK(\n      context, ValidateTensorIndexingSafe(context, index, node->outputs->size,\n                                          node->outputs->data, &tensor_index));\n  *tensor = GetTensorAtIndex(context, tensor_index);\n  return kTfLiteOk;\n}", "target": 0}
{"code": "inline bool CheckForOverflow<Eigen::half>(double as_double, Eigen::half* out) {\n  return (sizeof(Eigen::half) < sizeof(double) &&\n          Eigen::half_impl::isinf(*out) && std::isfinite(as_double));\n}", "target": 0}
{"code": "static int filter_frame(AVFilterLink *inlink, AVFrame *frame)\n{\n    AVFilterContext *ctx = inlink->dst;\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);\n    uint32_t plane_checksum[4] = {0}, checksum = 0;\n    int i, plane, vsub = desc->log2_chroma_h;\n    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {\n        int64_t linesize = av_image_get_linesize(frame->format, frame->width, plane);\n        uint8_t *data = frame->data[plane];\n        int h = plane == 1 || plane == 2 ? FF_CEIL_RSHIFT(inlink->h, vsub) : inlink->h;\n        if (linesize < 0)\n            return linesize;\n        for (i = 0; i < h; i++) {\n            plane_checksum[plane] = av_adler32_update(plane_checksum[plane], data, linesize);\n            checksum = av_adler32_update(checksum, data, linesize);\n            data += frame->linesize[plane];\n        }\n    }\n    av_log(ctx, AV_LOG_INFO,\n           \"n:%\"PRId64\" pts:%s pts_time:%s pos:%\"PRId64\" \"\n           \"fmt:%s sar:%d/%d s:%dx%d i:%c iskey:%d type:%c \"\n           \"checksum:%08X plane_checksum:[%08X\",\n           inlink->frame_count,\n           av_ts2str(frame->pts), av_ts2timestr(frame->pts, &inlink->time_base), av_frame_get_pkt_pos(frame),\n           desc->name,\n           frame->sample_aspect_ratio.num, frame->sample_aspect_ratio.den,\n           frame->width, frame->height,\n           !frame->interlaced_frame ? 'P' :         \n           frame->top_field_first   ? 'T' : 'B',    \n           frame->key_frame,\n           av_get_picture_type_char(frame->pict_type),\n           checksum, plane_checksum[0]);\n    for (plane = 1; plane < 4 && frame->data[plane]; plane++)\n        av_log(ctx, AV_LOG_INFO, \" %08X\", plane_checksum[plane]);\n    av_log(ctx, AV_LOG_INFO, \"]\\n\");\n    return ff_filter_frame(inlink->dst->outputs[0], frame);\n}", "target": 1}
{"code": "innodb_clean_engine(\n\tENGINE_HANDLE*\t\thandle,\t\t\n\tconst void*\t\tcookie __attribute__((unused)),\n\tvoid*\t\t\tconn)\t\t\n{\n\tinnodb_conn_data_t*\tconn_data = (innodb_conn_data_t*)conn;\n\tstruct innodb_engine*\tengine = innodb_handle(handle);\n\tvoid*\t\t\torignal_thd;\n\tLOCK_CURRENT_CONN_IF_NOT_LOCKED(false, conn_data);\n\tif (conn_data->thd) {\n\t\thandler_thd_attach(conn_data->thd, &orignal_thd);\n\t}\n\tinnodb_reset_conn(conn_data, true, true, engine->enable_binlog);\n\tinnodb_conn_clean_data(conn_data, true, false);\n\tconn_data->is_stale = true;\n\tUNLOCK_CURRENT_CONN_IF_NOT_LOCKED(false, conn_data);\n}", "target": 0}
{"code": "create_principal_2_svc(cprinc_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg;\n    gss_buffer_desc             client_name, service_name;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    restriction_t               *rp;\n    const char                  *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->rec.principal, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_ADD,\n                               arg->rec.principal, &rp)\n        || kadm5int_acl_impose_restrictions(handle->context,\n                                            &arg->rec, &arg->mask, rp)) {\n        ret.code = KADM5_AUTH_ADD;\n        log_unauth(\"kadm5_create_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_create_principal((void *)handle,\n                                          &arg->rec, arg->mask,\n                                          arg->passwd);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_create_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "void *safe_calloc(size_t size) {\n  void *addr;\n  if (!size)\n  {\n    ERR(\"Invalid allocation size.\\n\");\n    exit(EXIT_FAILURE);\n  }\n  if (!(addr = calloc(1, size)))\n  {\n      ERR(\"Failed to allocate requested number of bytes, out of memory?\\n\");\n      exit(EXIT_FAILURE);\n  }\n  return addr;\n}", "target": 0}
{"code": "AP_DECLARE(int) ap_check_request_header(request_rec *r)\n{\n    core_server_config *conf;\n    int strict_host_check;\n    const char *expect;\n    int access_status;\n    conf = ap_get_core_module_config(r->server->module_config);\n    strict_host_check = (conf->strict_host_check == AP_CORE_CONFIG_ON);\n    access_status = ap_update_vhost_from_headers_ex(r, strict_host_check);\n    if (strict_host_check && access_status != HTTP_OK) { \n        if (r->server == ap_server_conf) { \n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(10156)\n                          \"Requested hostname '%s' did not match any ServerName/ServerAlias \"\n                          \"in the global server configuration \", r->hostname);\n        }\n        else { \n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(10157)\n                          \"Requested hostname '%s' did not match any ServerName/ServerAlias \"\n                          \"in the matching virtual host (default vhost for \"\n                          \"current connection is %s:%u)\", \n                          r->hostname, r->server->defn_name, r->server->defn_line_number);\n        }\n        r->status = access_status;\n    }\n    if (r->status != HTTP_OK) { \n        return 0;\n    }\n    if ((!r->hostname && (r->proto_num >= HTTP_VERSION(1, 1)))\n        || ((r->proto_num == HTTP_VERSION(1, 1))\n            && !apr_table_get(r->headers_in, \"Host\"))) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00569)\n                      \"client sent HTTP/1.1 request without hostname \"\n                      \"(see RFC2616 section 14.23): %s\", r->uri);\n        r->status = HTTP_BAD_REQUEST;\n        return 0;\n    }\n    if (((expect = apr_table_get(r->headers_in, \"Expect\")) != NULL)\n        && (expect[0] != '\\0')) {\n        if (ap_cstr_casecmp(expect, \"100-continue\") == 0) {\n            r->expecting_100 = 1;\n        }\n        else {\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00570)\n                          \"client sent an unrecognized expectation value \"\n                          \"of Expect: %s\", expect);\n            r->status = HTTP_EXPECTATION_FAILED;\n            return 0;\n        }\n    }\n    return 1;\n}", "target": 0}
{"code": "static s32 adpt_i2o_post_this(adpt_hba* pHba, u32* data, int len)\n{\n\tu32 m = EMPTY_QUEUE;\n\tu32 __iomem *msg;\n\tulong timeout = jiffies + 30*HZ;\n\tdo {\n\t\trmb();\n\t\tm = readl(pHba->post_port);\n\t\tif (m != EMPTY_QUEUE) {\n\t\t\tbreak;\n\t\t}\n\t\tif(time_after(jiffies,timeout)){\n\t\t\tprintk(KERN_WARNING\"dpti%d: Timeout waiting for message frame!\\n\", pHba->unit);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tschedule_timeout_uninterruptible(1);\n\t} while(m == EMPTY_QUEUE);\n\tmsg = pHba->msg_addr_virt + m;\n\tmemcpy_toio(msg, data, len);\n\twmb();\n\twritel(m, pHba->post_port);\n\twmb();\n\treturn 0;\n}", "target": 1}
{"code": "bool fixpath_ro(Computer *comp, const std::string& path) {\n    std::vector<std::string> elems = split(path, \"/\\\\\");\n    std::list<std::string> pathc;\n    for (std::string s : elems) {\n        if (s == \"..\") { if (pathc.empty()) return false; else pathc.pop_back(); }\n        else if (!s.empty() && !std::all_of(s.begin(), s.end(), [](const char c)->bool{return c == '.';})) {\n            s = s.substr(s.find_first_not_of(' '), s.find_last_not_of(' ') - s.find_first_not_of(' ') + 1);\n            s.erase(std::remove_if(s.begin(), s.end(), [](char c)->bool{return c=='\"'||c==':'||c=='<'||c=='>'||c=='?'||c=='|';}), s.end());\n            pathc.push_back(s);\n        }\n    }\n    while (!pathc.empty() && pathc.front().empty()) pathc.pop_front();\n    if (!pathc.empty() && pathc.back().size() > 255) {\n        std::string s = pathc.back().substr(0, 255);\n        pathc.pop_back();\n        s = s.substr(0, s.find_last_not_of(' '));\n        pathc.push_back(s);\n    }\n    std::pair<size_t, bool> max_path = std::make_pair(0, false);\n    for (const auto& m : comp->mounts)\n        if (pathc.size() >= std::get<0>(m).size() && std::get<0>(m).size() > max_path.first && std::equal(std::get<0>(m).begin(), std::get<0>(m).end(), pathc.begin()))\n            max_path = std::make_pair(std::get<0>(m).size(), std::get<2>(m));\n    return max_path.second;\n}", "target": 1}
{"code": "static int xen_netbk_tx_check_gop(struct xen_netbk *netbk,\n\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t  struct gnttab_copy **gopp)\n{\n\tstruct gnttab_copy *gop = *gopp;\n\tu16 pending_idx = *((u16 *)skb->data);\n\tstruct pending_tx_info *pending_tx_info = netbk->pending_tx_info;\n\tstruct xenvif *vif = pending_tx_info[pending_idx].vif;\n\tstruct xen_netif_tx_request *txp;\n\tstruct skb_shared_info *shinfo = skb_shinfo(skb);\n\tint nr_frags = shinfo->nr_frags;\n\tint i, err, start;\n\terr = gop->status;\n\tif (unlikely(err)) {\n\t\tpending_ring_idx_t index;\n\t\tindex = pending_index(netbk->pending_prod++);\n\t\ttxp = &pending_tx_info[pending_idx].req;\n\t\tmake_tx_response(vif, txp, XEN_NETIF_RSP_ERROR);\n\t\tnetbk->pending_ring[index] = pending_idx;\n\t\txenvif_put(vif);\n\t}\n\tstart = (frag_get_pending_idx(&shinfo->frags[0]) == pending_idx);\n\tfor (i = start; i < nr_frags; i++) {\n\t\tint j, newerr;\n\t\tpending_ring_idx_t index;\n\t\tpending_idx = frag_get_pending_idx(&shinfo->frags[i]);\n\t\tnewerr = (++gop)->status;\n\t\tif (likely(!newerr)) {\n\t\t\tif (unlikely(err))\n\t\t\t\txen_netbk_idx_release(netbk, pending_idx);\n\t\t\tcontinue;\n\t\t}\n\t\ttxp = &netbk->pending_tx_info[pending_idx].req;\n\t\tmake_tx_response(vif, txp, XEN_NETIF_RSP_ERROR);\n\t\tindex = pending_index(netbk->pending_prod++);\n\t\tnetbk->pending_ring[index] = pending_idx;\n\t\txenvif_put(vif);\n\t\tif (err)\n\t\t\tcontinue;\n\t\tpending_idx = *((u16 *)skb->data);\n\t\txen_netbk_idx_release(netbk, pending_idx);\n\t\tfor (j = start; j < i; j++) {\n\t\t\tpending_idx = frag_get_pending_idx(&shinfo->frags[j]);\n\t\t\txen_netbk_idx_release(netbk, pending_idx);\n\t\t}\n\t\terr = newerr;\n\t}\n\t*gopp = gop + 1;\n\treturn err;\n}", "target": 1}
{"code": "bool Curl_conncache_foreach(struct Curl_easy *data,\n                            struct conncache *connc,\n                            void *param,\n                            int (*func)(struct Curl_easy *data,\n                                        struct connectdata *conn, void *param))\n{\n  struct Curl_hash_iterator iter;\n  struct Curl_llist_element *curr;\n  struct Curl_hash_element *he;\n  if(!connc)\n    return FALSE;\n  CONNCACHE_LOCK(data);\n  Curl_hash_start_iterate(&connc->hash, &iter);\n  he = Curl_hash_next_element(&iter);\n  while(he) {\n    struct connectbundle *bundle;\n    bundle = he->ptr;\n    he = Curl_hash_next_element(&iter);\n    curr = bundle->conn_list.head;\n    while(curr) {\n      struct connectdata *conn = curr->ptr;\n      curr = curr->next;\n      if(1 == func(data, conn, param)) {\n        CONNCACHE_UNLOCK(data);\n        return TRUE;\n      }\n    }\n  }\n  CONNCACHE_UNLOCK(data);\n  return FALSE;\n}", "target": 0}
{"code": "void DetectHttpResponseHeaderRegister(void)\n{\n    sigmatch_table[DETECT_HTTP_RESPONSE_HEADER].name = \"http.response_header\";\n    sigmatch_table[DETECT_HTTP_RESPONSE_HEADER].desc =\n            \"sticky buffer to match on only one HTTP header name and value\";\n    sigmatch_table[DETECT_HTTP_RESPONSE_HEADER].url = \"/rules/http2-keywords.html#response_header\";\n    sigmatch_table[DETECT_HTTP_RESPONSE_HEADER].Setup = DetectHTTPResponseHeaderSetup;\n    sigmatch_table[DETECT_HTTP_RESPONSE_HEADER].flags |=\n            SIGMATCH_NOOPT | SIGMATCH_INFO_STICKY_BUFFER;\n    DetectAppLayerMpmRegister2(\"http_response_header\", SIG_FLAG_TOCLIENT, 2,\n            PrefilterMpmHttp2HeaderRegister, NULL, ALPROTO_HTTP2, HTTP2StateOpen);\n    DetectAppLayerInspectEngineRegister2(\"http_response_header\", ALPROTO_HTTP2, SIG_FLAG_TOCLIENT,\n            HTTP2StateOpen, DetectEngineInspectHttp2Header, NULL);\n    DetectAppLayerMpmRegister2(\"http_response_header\", SIG_FLAG_TOCLIENT, 2,\n            PrefilterMpmHttp1HeaderRegister, NULL, ALPROTO_HTTP1, 0);\n    DetectAppLayerInspectEngineRegister2(\"http_response_header\", ALPROTO_HTTP1, SIG_FLAG_TOCLIENT,\n            HTP_RESPONSE_HEADERS, DetectEngineInspectHttp1Header, NULL);\n    DetectBufferTypeSetDescriptionByName(\"http_response_header\", \"HTTP header name and value\");\n    g_http_response_header_buffer_id = DetectBufferTypeGetByName(\"http_response_header\");\n    DetectBufferTypeSupportsMultiInstance(\"http_response_header\");\n    g_response_header_thread_id = DetectRegisterThreadCtxGlobalFuncs(\"http_response_header\",\n            HttpMultiBufHeaderThreadDataInit, NULL, HttpMultiBufHeaderThreadDataFree);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& in0 = ctx->input(0);\n    const Tensor& in1 = ctx->input(1);\n    ValidateInputTensors(ctx, in0, in1);\n    if (!ctx->status().ok()) return;\n    MatMulBCast bcast(in0.shape().dim_sizes(), in1.shape().dim_sizes());\n    OP_REQUIRES(\n        ctx, bcast.IsValid(),\n        errors::InvalidArgument(\n            \"In[0] and In[1] must have compatible batch dimensions: \",\n            in0.shape().DebugString(), \" vs. \", in1.shape().DebugString()));\n    TensorShape out_shape = bcast.output_batch_shape();\n    auto batch_size = bcast.output_batch_size();\n    auto d0 = in0.dim_size(in0.dims() - 2);  \n    auto d1 = in0.dim_size(in0.dims() - 1);\n    Tensor in0_reshaped;\n    OP_REQUIRES(\n        ctx,\n        in0_reshaped.CopyFrom(in0, TensorShape({bcast.x_batch_size(), d0, d1})),\n        errors::Internal(\"Failed to reshape In[0] from \",\n                         in0.shape().DebugString()));\n    auto d2 = in1.dim_size(in1.dims() - 2);\n    auto d3 = in1.dim_size(in1.dims() - 1);\n    Tensor in1_reshaped;\n    OP_REQUIRES(\n        ctx,\n        in1_reshaped.CopyFrom(in1, TensorShape({bcast.y_batch_size(), d2, d3})),\n        errors::Internal(\"Failed to reshape In[1] from \",\n                         in1.shape().DebugString()));\n    OP_REQUIRES(ctx, d1 == d2,\n                errors::InvalidArgument(\n                    \"In[0] mismatch In[1] shape: \", d1, \" vs. \", d2, \": \",\n                    in0.shape().DebugString(), \" \", in1.shape().DebugString(),\n                    \" \", lower_, \" \", adjoint_));\n    out_shape.AddDim(d1);\n    out_shape.AddDim(d3);\n    Tensor* out = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, out_shape, &out));\n    if (out->NumElements() == 0) {\n      return;\n    }\n    Tensor out_reshaped;\n    OP_REQUIRES(ctx,\n                out_reshaped.CopyFrom(*out, TensorShape({batch_size, d1, d3})),\n                errors::Internal(\"Failed to reshape output from \",\n                                 out->shape().DebugString()));\n    LaunchBatchBandedTriangularSolve<Scalar>::Launch(\n        ctx, in0_reshaped, in1_reshaped, adjoint_, lower_, bcast,\n        &out_reshaped);\n  }", "target": 0}
{"code": "int cg_write(const char *path, const char *buf, size_t size, off_t offset,\n\t     struct fuse_file_info *fi)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tchar *localbuf = NULL;\n\tstruct cgfs_files *k = NULL;\n\tstruct file_info *f = (struct file_info *)fi->fh;\n\tbool r;\n\tif (f->type != LXC_TYPE_CGFILE) {\n\t\tfprintf(stderr, \"Internal error: directory cache info used in cg_write\\n\");\n\t\treturn -EIO;\n\t}\n\tif (offset)\n\t\treturn 0;\n\tif (!fc)\n\t\treturn -EIO;\n\tlocalbuf = alloca(size+1);\n\tlocalbuf[size] = '\\0';\n\tmemcpy(localbuf, buf, size);\n\tif ((k = cgfs_get_key(f->controller, f->cgroup, f->file)) == NULL) {\n\t\tsize = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (!fc_may_access(fc, f->controller, f->cgroup, f->file, O_WRONLY)) {\n\t\tsize = -EACCES;\n\t\tgoto out;\n\t}\n\tif (strcmp(f->file, \"tasks\") == 0 ||\n\t\t\tstrcmp(f->file, \"/tasks\") == 0 ||\n\t\t\tstrcmp(f->file, \"/cgroup.procs\") == 0 ||\n\t\t\tstrcmp(f->file, \"cgroup.procs\") == 0)\n\t\tr = do_write_pids(fc->pid, f->controller, f->cgroup, f->file, localbuf);\n\telse\n\t\tr = cgfs_set_value(f->controller, f->cgroup, f->file, localbuf);\n\tif (!r)\n\t\tsize = -EINVAL;\nout:\n\tfree_key(k);\n\treturn size;\n}", "target": 1}
{"code": "ProcStoreNamedColor(ClientPtr client)\n{\n    ColormapPtr pcmp;\n    int rc;\n    REQUEST(xStoreNamedColorReq);\n    REQUEST_FIXED_SIZE(xStoreNamedColorReq, stuff->nbytes);\n    rc = dixLookupResourceByType((void **) &pcmp, stuff->cmap, RT_COLORMAP,\n                                 client, DixWriteAccess);\n    if (rc == Success) {\n        xColorItem def;\n        if (OsLookupColor(pcmp->pScreen->myNum, (char *) &stuff[1],\n                          stuff->nbytes, &def.red, &def.green, &def.blue)) {\n            def.flags = stuff->flags;\n            def.pixel = stuff->pixel;\n            return StoreColors(pcmp, 1, &def, client);\n        }\n        return BadName;\n    }\n    else {\n        client->errorValue = stuff->cmap;\n        return rc;\n    }\n}", "target": 0}
{"code": "ev_archive_reset (EvArchive *archive)\n{\n\tg_return_if_fail (EV_IS_ARCHIVE (archive));\n\tg_return_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE);\n\tswitch (archive->type) {\n\tcase EV_ARCHIVE_TYPE_RAR:\n\tcase EV_ARCHIVE_TYPE_ZIP:\n\tcase EV_ARCHIVE_TYPE_7Z:\n\tcase EV_ARCHIVE_TYPE_TAR:\n\t\tg_clear_pointer (&archive->libar, archive_free);\n\t\tlibarchive_set_archive_type (archive, archive->type);\n\t\tarchive->libar_entry = NULL;\n\t\tbreak;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n}", "target": 0}
{"code": "remote_auth_timeout_cb(gpointer data)\n{\n    cib_client_t *client = data;\n    client->remote_auth_timeout = 0;\n    if (client->remote_auth == TRUE) {\n        return FALSE;\n    }\n    mainloop_del_fd(client->remote);\n    crm_err(\"Remote client authentication timed out\");\n    return FALSE;\n}", "target": 0}
{"code": "Ztring& Ztring::Date_From_Seconds_1970_Local (const int32u Value)\n{\n    time_t Time=(time_t)Value;\n    #if _POSIX_C_SOURCE >= 1 || _XOPEN_SOURCE || _BSD_SOURCE || _SVID_SOURCE || _POSIX_SOURCE\n    struct tm Gmt_Temp;\n    struct tm *Gmt=localtime_r(&Time, &Gmt_Temp);\n    #elif defined(_MSC_VER)\n    struct tm Gmt_Temp;\n    errno_t localtime_s_Result=localtime_s(&Gmt_Temp , &Time);\n    struct tm* Gmt=localtime_s_Result?NULL:&Gmt_Temp;\n    #else\n    struct tm *Gmt=localtime(&Time);\n    #endif\n    Ztring DateT;\n    Ztring Date;\n    if (Gmt)\n    {\n    Date+=Ztring::ToZtring((Gmt->tm_year+1900));\n    Date+=__T(\"-\");\n    DateT.From_Number(Gmt->tm_mon+1); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_mon+1);}\n    Date+=DateT;\n    Date+=__T(\"-\");\n    DateT.From_Number(Gmt->tm_mday); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_mday);}\n    Date+=DateT;\n    Date+=__T(\" \");\n    DateT.From_Number(Gmt->tm_hour); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_hour);}\n    Date+=DateT;\n    Date+=__T(\":\");\n    DateT=Ztring::ToZtring(Gmt->tm_min); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_min);}\n    Date+=DateT;\n    Date+=__T(\":\");\n    DateT.From_Number(Gmt->tm_sec); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_sec);}\n    Date+=DateT;\n    assign (Date.c_str());\n    }\n    return *this;\n}", "target": 0}
{"code": "juniper_mlppp_print(netdissect_options *ndo,\n                    const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        l2info.pictype = DLT_JUNIPER_MLPPP;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        if (ndo->ndo_eflag &&\n            EXTRACT_16BITS(&l2info.cookie) != PPP_OSI &&\n            EXTRACT_16BITS(&l2info.cookie) !=  (PPP_ADDRESS << 8 | PPP_CONTROL))\n            ND_PRINT((ndo, \"Bundle-ID %u: \", l2info.bundle));\n        p+=l2info.header_len;\n        switch(l2info.proto) {\n        case JUNIPER_LSQ_L3_PROTO_IPV4:\n            if (l2info.cookie[4] == (JUNIPER_LSQ_COOKIE_RE|JUNIPER_LSQ_COOKIE_DIR))\n                ppp_print(ndo, p, l2info.length);\n            else\n                ip_print(ndo, p, l2info.length);\n            return l2info.header_len;\n        case JUNIPER_LSQ_L3_PROTO_IPV6:\n            ip6_print(ndo, p,l2info.length);\n            return l2info.header_len;\n        case JUNIPER_LSQ_L3_PROTO_MPLS:\n            mpls_print(ndo, p, l2info.length);\n            return l2info.header_len;\n        case JUNIPER_LSQ_L3_PROTO_ISO:\n            isoclns_print(ndo, p, l2info.length, l2info.caplen);\n            return l2info.header_len;\n        default:\n            break;\n        }\n        switch (EXTRACT_16BITS(&l2info.cookie)) {\n        case PPP_OSI:\n            ppp_print(ndo, p - 2, l2info.length + 2);\n            break;\n        case (PPP_ADDRESS << 8 | PPP_CONTROL): \n        default:\n            ppp_print(ndo, p, l2info.length);\n            break;\n        }\n        return l2info.header_len;\n}", "target": 1}
{"code": "  ~SubgraphGuard() {\n    if (status_ == kTfLiteOk) {\n      *is_subgraph_in_use_ = false;\n    }\n  }", "target": 0}
{"code": "int f2fs_trim_fs(struct f2fs_sb_info *sbi, struct fstrim_range *range)\n{\n\t__u64 start = F2FS_BYTES_TO_BLK(range->start);\n\t__u64 end = start + F2FS_BYTES_TO_BLK(range->len) - 1;\n\tunsigned int start_segno, end_segno;\n\tstruct cp_control cpc;\n\tint err = 0;\n\tif (start >= MAX_BLKADDR(sbi) || range->len < sbi->blocksize)\n\t\treturn -EINVAL;\n\tcpc.trimmed = 0;\n\tif (end <= MAIN_BLKADDR(sbi))\n\t\tgoto out;\n\tif (is_sbi_flag_set(sbi, SBI_NEED_FSCK)) {\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t\"Found FS corruption, run fsck to fix.\");\n\t\tgoto out;\n\t}\n\tstart_segno = (start <= MAIN_BLKADDR(sbi)) ? 0 : GET_SEGNO(sbi, start);\n\tend_segno = (end >= MAX_BLKADDR(sbi)) ? MAIN_SEGS(sbi) - 1 :\n\t\t\t\t\t\tGET_SEGNO(sbi, end);\n\tcpc.reason = CP_DISCARD;\n\tcpc.trim_minlen = max_t(__u64, 1, F2FS_BYTES_TO_BLK(range->minlen));\n\tfor (; start_segno <= end_segno; start_segno = cpc.trim_end + 1) {\n\t\tcpc.trim_start = start_segno;\n\t\tif (sbi->discard_blks == 0)\n\t\t\tbreak;\n\t\telse if (sbi->discard_blks < BATCHED_TRIM_BLOCKS(sbi))\n\t\t\tcpc.trim_end = end_segno;\n\t\telse\n\t\t\tcpc.trim_end = min_t(unsigned int,\n\t\t\t\trounddown(start_segno +\n\t\t\t\tBATCHED_TRIM_SEGMENTS(sbi),\n\t\t\t\tsbi->segs_per_sec) - 1, end_segno);\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\terr = write_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t\tif (err)\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\tmark_discard_range_all(sbi);\n\tf2fs_wait_discard_bios(sbi);\nout:\n\trange->len = F2FS_BLK_TO_BYTES(cpc.trimmed);\n\treturn err;\n}", "target": 1}
{"code": "void ntlm_write_message_header(wStream* s, NTLM_MESSAGE_HEADER* header)\n{\n\tStream_Write(s, header->Signature, sizeof(NTLM_SIGNATURE));\n\tStream_Write_UINT32(s, header->MessageType);\n}", "target": 1}
{"code": "static int link_pipe(struct pipe_inode_info *ipipe,\n\t\t     struct pipe_inode_info *opipe,\n\t\t     size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tint ret = 0, i = 0, nbuf;\n\tpipe_double_lock(ipipe, opipe);\n\tdo {\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\t\tif (i >= ipipe->nrbufs || opipe->nrbufs >= opipe->buffers)\n\t\t\tbreak;\n\t\tibuf = ipipe->bufs + ((ipipe->curbuf + i) & (ipipe->buffers-1));\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\t\tpipe_buf_get(ipipe, ibuf);\n\t\tobuf = opipe->bufs + nbuf;\n\t\t*obuf = *ibuf;\n\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\t\tif (obuf->len > len)\n\t\t\tobuf->len = len;\n\t\topipe->nrbufs++;\n\t\tret += obuf->len;\n\t\tlen -= obuf->len;\n\t\ti++;\n\t} while (len);\n\tif (!ret && ipipe->waiting_writers && (flags & SPLICE_F_NONBLOCK))\n\t\tret = -EAGAIN;\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\treturn ret;\n}", "target": 1}
{"code": "_dl_dst_count (const char *name, int is_path)\n{\n  size_t cnt = 0;\n  do\n    {\n      size_t len = 1;\n      if ((((!__libc_enable_secure\n\t     && strncmp (&name[1], \"ORIGIN\", 6) == 0 && (len = 7) != 0)\n\t    || (strncmp (&name[1], \"PLATFORM\", 8) == 0 && (len = 9) != 0))\n\t   && (name[len] == '\\0' || name[len] == '/'\n\t       || (is_path && name[len] == ':')))\n\t  || (name[1] == '{'\n\t      && ((!__libc_enable_secure\n\t\t   && strncmp (&name[2], \"ORIGIN}\", 7) == 0 && (len = 9) != 0)\n\t\t  || (strncmp (&name[2], \"PLATFORM}\", 9) == 0\n\t\t      && (len = 11) != 0))))\n\t++cnt;\n      name = strchr (name + len, '$');\n    }\n  while (name != NULL);\n  return cnt;\n}", "target": 1}
{"code": "int _mkp_stage_30(struct plugin *p,\n        struct client_session *cs,\n        struct session_request *sr)\n{\n    mk_ptr_t referer;\n    (void) p;\n    (void) cs;\n    PLUGIN_TRACE(\"[FD %i] Mandril validating URL\", cs->socket);\n    if (mk_security_check_url(sr->uri) < 0) {\n        PLUGIN_TRACE(\"[FD %i] Close connection, blocked URL\", cs->socket);\n        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);\n        return MK_PLUGIN_RET_CLOSE_CONX;\n    }\n    PLUGIN_TRACE(\"[FD %d] Mandril validating hotlinking\", cs->socket);\n    referer = mk_api->header_get(&sr->headers_toc, \"Referer\", strlen(\"Referer\"));\n    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {\n        PLUGIN_TRACE(\"[FD %i] Close connection, deny hotlinking.\", cs->socket);\n        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);\n        return MK_PLUGIN_RET_CLOSE_CONX;\n    }\n    return MK_PLUGIN_RET_NOT_ME;\n}", "target": 1}
{"code": "void RenderView::didUpdateInspectorSetting(const WebString& key,\n                                           const WebString& value) {\n  Send(new ViewHostMsg_UpdateInspectorSetting(routing_id_,\n                                              key.utf8(),\n                                              value.utf8()));\n}", "target": 0}
{"code": "snmp_ber_decode_integer(unsigned char *buf, uint32_t *buff_len, uint32_t *num)\n{\n  uint8_t i, len, type;\n  buf = snmp_ber_decode_type(buf, buff_len, &type);\n  if(buf == NULL || type != BER_DATA_TYPE_INTEGER) {\n    return NULL;\n  }\n  buf = snmp_ber_decode_length(buf, buff_len, &len);\n  if(buf == NULL || len > 4) {\n    return NULL;\n  }\n  if(*buff_len < len) {\n    return NULL;\n  }\n  *num = (uint32_t)(*buf++ & 0xFF);\n  (*buff_len)--;\n  for(i = 1; i < len; ++i) {\n    *num <<= 8;\n    *num |= (uint8_t)(*buf++ & 0xFF);\n    (*buff_len)--;\n  }\n  return buf;\n}", "target": 1}
{"code": "  void DidGetGlobalUsage(StorageType type, int64 usage,\n                         int64 unlimited_usage) {\n    DCHECK_EQ(type_, type);\n    DCHECK_GE(usage, unlimited_usage);\n    global_usage_ = usage;\n    global_unlimited_usage_ = unlimited_usage;\n    CheckCompleted();\n  }", "target": 0}
{"code": "static bool dir_is_in_dump_location(const char *dump_dir_name)\n{\n    unsigned len = strlen(g_settings_dump_location);\n    if (strncmp(dump_dir_name, g_settings_dump_location, len) == 0\n     && dump_dir_name[len] == '/'\n     && !strstr(dump_dir_name + len, \"/.\")\n    ) {\n        return 1;\n    }\n    return 0;\n}", "target": 1}
{"code": "  bool has_dom_ui_bindings() const {\n    return BindingsPolicy::is_dom_ui_enabled(enabled_bindings_);\n  }", "target": 0}
{"code": "rx_cache_find(const struct rx_header *rxh, const struct ip *ip, int sport,\n\t      int32_t *opcode)\n{\n\tint i;\n\tstruct rx_cache_entry *rxent;\n\tuint32_t clip;\n\tuint32_t sip;\n\tUNALIGNED_MEMCPY(&clip, &ip->ip_dst, sizeof(uint32_t));\n\tUNALIGNED_MEMCPY(&sip, &ip->ip_src, sizeof(uint32_t));\n\ti = rx_cache_hint;\n\tdo {\n\t\trxent = &rx_cache[i];\n\t\tif (rxent->callnum == EXTRACT_32BITS(&rxh->callNumber) &&\n\t\t    rxent->client.s_addr == clip &&\n\t\t    rxent->server.s_addr == sip &&\n\t\t    rxent->serviceId == EXTRACT_32BITS(&rxh->serviceId) &&\n\t\t    rxent->dport == sport) {\n\t\t\trx_cache_hint = i;\n\t\t\t*opcode = rxent->opcode;\n\t\t\treturn(1);\n\t\t}\n\t\tif (++i >= RX_CACHE_SIZE)\n\t\t\ti = 0;\n\t} while (i != rx_cache_hint);\n\treturn(0);\n}", "target": 1}
{"code": "static int bcm_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net;\n\tstruct bcm_sock *bo;\n\tstruct bcm_op *op, *next;\n\tif (!sk)\n\t\treturn 0;\n\tnet = sock_net(sk);\n\tbo = bcm_sk(sk);\n\tspin_lock(&bcm_notifier_lock);\n\twhile (bcm_busy_notifier == bo) {\n\t\tspin_unlock(&bcm_notifier_lock);\n\t\tschedule_timeout_uninterruptible(1);\n\t\tspin_lock(&bcm_notifier_lock);\n\t}\n\tlist_del(&bo->notifier);\n\tspin_unlock(&bcm_notifier_lock);\n\tlock_sock(sk);\n\tlist_for_each_entry_safe(op, next, &bo->tx_ops, list)\n\t\tbcm_remove_op(op);\n\tlist_for_each_entry_safe(op, next, &bo->rx_ops, list) {\n\t\tif (op->ifindex) {\n\t\t\tif (op->rx_reg_dev) {\n\t\t\t\tstruct net_device *dev;\n\t\t\t\tdev = dev_get_by_index(net, op->ifindex);\n\t\t\t\tif (dev) {\n\t\t\t\t\tbcm_rx_unreg(dev, op);\n\t\t\t\t\tdev_put(dev);\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tcan_rx_unregister(net, NULL, op->can_id,\n\t\t\t\t\t  REGMASK(op->can_id),\n\t\t\t\t\t  bcm_rx_handler, op);\n\t\tbcm_remove_op(op);\n\t}\n#if IS_ENABLED(CONFIG_PROC_FS)\n\tif (net->can.bcmproc_dir && bo->bcm_proc_read)\n\t\tremove_proc_entry(bo->procname, net->can.bcmproc_dir);\n#endif \n\tif (bo->bound) {\n\t\tbo->bound   = 0;\n\t\tbo->ifindex = 0;\n\t}\n\tsock_orphan(sk);\n\tsock->sk = NULL;\n\trelease_sock(sk);\n\tsock_put(sk);\n\treturn 0;\n}", "target": 1}
{"code": "void LIRGenerator::do_BlockBegin(BlockBegin* x) {\n}", "target": 0}
{"code": "static void key_gc_timer_func(unsigned long data)\n{\n\tkenter(\"\");\n\tkey_gc_next_run = LONG_MAX;\n\tkey_schedule_gc_links();\n}", "target": 0}
{"code": "bool test_r_str_escape_sh(void) {\n\tchar *escaped = r_str_escape_sh (\"Hello, \\\"World\\\"\");\n\tmu_assert_streq (escaped, \"Hello, \\\\\\\"World\\\\\\\"\", \"escaped \\\"double quotes\\\"\");\n\tfree (escaped);\n\tescaped = r_str_escape_sh (\"Hello, \\\\World\\\\\");\n\tmu_assert_streq (escaped, \"Hello, \\\\\\\\World\\\\\\\\\", \"escaped backspace\");\n\tfree (escaped);\n#if __UNIX__\n\tescaped = r_str_escape_sh (\"Hello, $(World)\");\n\tmu_assert_streq (escaped, \"Hello, \\\\$(World)\", \"escaped $(command)\");\n\tfree (escaped);\n\tescaped = r_str_escape_sh (\"Hello, `World`\");\n\tmu_assert_streq (escaped, \"Hello, \\\\`World\\\\`\", \"escaped `command`\");\n\tfree (escaped);\n#endif\n\tmu_end;\n}", "target": 0}
{"code": "GSList* menu_cache_list_all_apps(MenuCache* cache)\n{\n    GSList* list;\n    MENU_CACHE_LOCK;\n    if (G_UNLIKELY(!cache->root_dir)) \n        list = NULL;\n    else\n        list = list_app_in_dir(cache->root_dir, NULL);\n    MENU_CACHE_UNLOCK;\n    return list;\n}", "target": 0}
{"code": "GF_Box *flxs_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AdobeFlashAccessParamsBox, GF_ISOM_BOX_TYPE_FLXS);\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "Cleanup Ipv4Instance::forceProtocolUnsupportedForTest(bool new_val) {\n  bool old_val = force_ipv4_unsupported_for_test;\n  force_ipv4_unsupported_for_test = new_val;\n  return Cleanup([old_val]() { force_ipv4_unsupported_for_test = old_val; });\n}", "target": 0}
{"code": "static inline Quantum ClampPixel(const MagickRealType value)\n{\n#if !defined(MAGICKCORE_HDRI_SUPPORT)\n  return((Quantum) value);\n#else\n  if (value < 0.0)\n    return((Quantum) 0.0);\n  if (value >= (MagickRealType) QuantumRange)\n    return((Quantum) QuantumRange);\n  return((Quantum) value);\n#endif\n}", "target": 0}
{"code": "static int stszin(int size)\n{\n    int cnt;\n    uint32_t ofs;\n    u32in();\n    u32in();\n    mp4config.frame.ents = u32in();\n    mp4config.frame.data = malloc(sizeof(*mp4config.frame.data)\n                                  * (mp4config.frame.ents + 1));\n    if (!mp4config.frame.data)\n        return ERR_FAIL;\n    ofs = 0;\n    mp4config.frame.data[0] = ofs;\n    for (cnt = 0; cnt < mp4config.frame.ents; cnt++)\n    {\n        uint32_t fsize = u32in();\n        ofs += fsize;\n        if (mp4config.frame.maxsize < fsize)\n            mp4config.frame.maxsize = fsize;\n        mp4config.frame.data[cnt + 1] = ofs;\n        if (ofs < mp4config.frame.data[cnt])\n            return ERR_FAIL;\n    }\n    return size;\n}", "target": 1}
{"code": "static int snd_timer_s_stop(struct snd_timer * timer)\n{\n\tstruct snd_timer_system_private *priv;\n\tunsigned long jiff;\n\tpriv = (struct snd_timer_system_private *) timer->private_data;\n\tdel_timer(&priv->tlist);\n\tjiff = jiffies;\n\tif (time_before(jiff, priv->last_expires))\n\t\ttimer->sticks = priv->last_expires - jiff;\n\telse\n\t\ttimer->sticks = 1;\n\tpriv->correction = 0;\n\treturn 0;\n}", "target": 0}
{"code": "static void *__dma_alloc_coherent(struct device *dev, size_t size,\n\t\t\t\t  dma_addr_t *dma_handle, gfp_t flags,\n\t\t\t\t  struct dma_attrs *attrs)\n{\n\tif (dev == NULL) {\n\t\tWARN_ONCE(1, \"Use an actual device structure for DMA allocation\\n\");\n\t\treturn NULL;\n\t}\n\tif (IS_ENABLED(CONFIG_ZONE_DMA) &&\n\t    dev->coherent_dma_mask <= DMA_BIT_MASK(32))\n\t\tflags |= GFP_DMA;\n\tif (IS_ENABLED(CONFIG_DMA_CMA) && (flags & __GFP_WAIT)) {\n\t\tstruct page *page;\n\t\tvoid *addr;\n\t\tsize = PAGE_ALIGN(size);\n\t\tpage = dma_alloc_from_contiguous(dev, size >> PAGE_SHIFT,\n\t\t\t\t\t\t\tget_order(size));\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\t*dma_handle = phys_to_dma(dev, page_to_phys(page));\n\t\taddr = page_address(page);\n\t\tif (flags & __GFP_ZERO)\n\t\t\tmemset(addr, 0, size);\n\t\treturn addr;\n\t} else {\n\t\treturn swiotlb_alloc_coherent(dev, size, dma_handle, flags);\n\t}\n}", "target": 1}
{"code": "static int sd_isoc_nego(struct gspca_dev *gspca_dev)\n{\n\tint ret, packet_size, min_packet_size;\n\tstruct usb_host_interface *alt;\n\tswitch (gspca_dev->pixfmt.width) {\n\tcase 160:\n\t\tmin_packet_size = 200;\n\t\tbreak;\n\tcase 176:\n\t\tmin_packet_size = 266;\n\t\tbreak;\n\tdefault:\n\t\tmin_packet_size = 400;\n\t\tbreak;\n\t}\n\talt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\tif (packet_size <= min_packet_size)\n\t\treturn -EIO;\n\tpacket_size -= 100;\n\tif (packet_size < min_packet_size)\n\t\tpacket_size = min_packet_size;\n\talt->endpoint[0].desc.wMaxPacketSize = cpu_to_le16(packet_size);\n\tret = usb_set_interface(gspca_dev->dev, gspca_dev->iface, 1);\n\tif (ret < 0)\n\t\tpr_err(\"set alt 1 err %d\\n\", ret);\n\treturn ret;\n}", "target": 0}
{"code": "bool CSPSource::portMatches(const KURL& url) const\n{\n    if (m_portWildcard == HasWildcard)\n        return true;\n    int port = url.port();\n    if (port == m_port)\n        return true;\n    if (!port)\n        return isDefaultPortForProtocol(m_port, url.protocol());\n    if (!m_port)\n        return isDefaultPortForProtocol(port, url.protocol());\n    return false;\n}", "target": 0}
{"code": "bool VariableUnserializer::matchString(folly::StringPiece str) {\n  const char* p = m_buf;\n  assertx(p <= m_end);\n  int total = 0;\n  if (*p == 'S') {\n    total = 2 + 8 + 1;\n    if (p + total > m_end) return false;\n    p++;\n    if (*p++ != ':') return false;\n    auto const sd = *reinterpret_cast<StringData*const*>(p);\n    assertx(sd->isStatic());\n    if (str.compare(sd->slice()) != 0) return false;\n    p += size_t(8);\n  } else {\n    const auto ss = str.size();\n    if (ss >= 100) return false;\n    int digits = ss >= 10 ? 2 : 1;\n    total = 2 + digits + 2 + ss + 2;\n    if (p + total > m_end) return false;\n    if (*p++ != 's') return false;\n    if (*p++ != ':') return false;\n    if (digits == 2) {\n      if (*p++ != '0' + ss/10) return false;\n      if (*p++ != '0' + ss%10) return false;\n    } else {\n      if (*p++ != '0' + ss) return false;\n    }\n    if (*p++ != ':') return false;\n    if (*p++ != '\\\"') return false;\n    if (memcmp(p, str.data(), ss)) return false;\n    p += ss;\n    if (*p++ != '\\\"') return false;\n  }\n  if (*p++ != ';') return false;\n  assertx(m_buf + total == p);\n  m_buf = p;\n  return true;\n}", "target": 1}
{"code": "Pl_AES_PDF::flush(bool strip_padding)\n{\n    assert(this->offset == this->buf_size);\n    if (first)\n    {\n\tfirst = false;\n        bool return_after_init = false;\n\tif (this->cbc_mode)\n\t{\n\t    if (encrypt)\n\t    {\n\t\tinitializeVector();\n                if (! (this->use_zero_iv || this->use_specified_iv))\n                {\n                    getNext()->write(this->cbc_block, this->buf_size);\n                }\n\t    }\n\t    else if (this->use_zero_iv || this->use_specified_iv)\n            {\n                initializeVector();\n            }\n            else\n\t    {\n\t\tmemcpy(this->cbc_block, this->inbuf, this->buf_size);\n\t\tthis->offset = 0;\n                return_after_init = true;\n\t    }\n\t}\n        this->crypto->rijndael_init(\n            encrypt, this->key.get(), key_bytes,\n            this->cbc_mode, this->cbc_block);\n        if (return_after_init)\n        {\n            return;\n        }\n    }\n    if (this->encrypt)\n    {\n\tthis->crypto->rijndael_process(this->inbuf, this->outbuf);\n    }\n    else\n    {\n\tthis->crypto->rijndael_process(this->inbuf, this->outbuf);\n    }\n    unsigned int bytes = this->buf_size;\n    if (strip_padding)\n    {\n\tunsigned char last = this->outbuf[this->buf_size - 1];\n\tif (last <= this->buf_size)\n\t{\n\t    bool strip = true;\n\t    for (unsigned int i = 1; i <= last; ++i)\n\t    {\n\t\tif (this->outbuf[this->buf_size - i] != last)\n\t\t{\n\t\t    strip = false;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (strip)\n\t    {\n\t\tbytes -= last;\n\t    }\n\t}\n    }\n    getNext()->write(this->outbuf, bytes);\n    this->offset = 0;\n}", "target": 1}
{"code": "format_DEC_TTL(const struct ofpact_cnt_ids *a,\n               const struct ofpact_format_params *fp)\n{\n    size_t i;\n    ds_put_format(fp->s, \"%sdec_ttl%s\", colors.paren, colors.end);\n    if (a->ofpact.raw == NXAST_RAW_DEC_TTL_CNT_IDS) {\n        ds_put_format(fp->s, \"%s(%s\", colors.paren, colors.end);\n        for (i = 0; i < a->n_controllers; i++) {\n            if (i) {\n                ds_put_cstr(fp->s, \",\");\n            }\n            ds_put_format(fp->s, \"%\"PRIu16, a->cnt_ids[i]);\n        }\n        ds_put_format(fp->s, \"%s)%s\", colors.paren, colors.end);\n    }\n}", "target": 0}
{"code": "static bool tls_desc_okay(const struct user_desc *info)\n{\n\tif (LDT_empty(info))\n\t\treturn true;\n\tif (!info->seg_32bit)\n\t\treturn false;\n\treturn true;\n}", "target": 0}
{"code": "void options_apply() { \n    unsigned num=0;\n    SERVICE_OPTIONS *section;\n    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_SECTIONS]);\n    memcpy(&global_options, &new_global_options, sizeof(GLOBAL_OPTIONS));\n    memset(&new_global_options, 0, sizeof(GLOBAL_OPTIONS));\n    for(section=new_service_options.next; section; section=section->next)\n        section->section_number=num++;\n    memcpy(&service_options, &new_service_options, sizeof(SERVICE_OPTIONS));\n    memset(&new_service_options, 0, sizeof(SERVICE_OPTIONS));\n    number_of_sections=num;\n    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_SECTIONS]);\n}", "target": 0}
{"code": "bool DNP3_Base::ProcessData(int len, const u_char* data, bool orig)\n\t{\n\tEndpoint* endp = orig ? &orig_state : &resp_state;\n\twhile ( len )\n\t\t{\n\t\tif ( endp->in_hdr )\n\t\t\t{\n\t\t\tif ( ! AddToBuffer(endp, PSEUDO_APP_LAYER_INDEX, &data, &len) )\n\t\t\t\treturn true;\n\t\t\tif( endp->buffer[0] != 0x05 || endp->buffer[1] != 0x64 )\n\t\t\t\t{\n\t\t\t\tanalyzer->Weird(\"dnp3_header_lacks_magic\");\n\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\tif ( ! CheckCRC(PSEUDO_LINK_LAYER_LEN, endp->buffer, endp->buffer + PSEUDO_LINK_LAYER_LEN, \"header\") )\n\t\t\t\t{\n\t\t\t\tanalyzer->ProtocolViolation(\"broken_checksum\");\n\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\tanalyzer->ProtocolConfirmation();\n\t\t\tif ( (endp->buffer[PSEUDO_LENGTH_INDEX] + 3) == (char)PSEUDO_LINK_LAYER_LEN  )\n\t\t\t\t{\n\t\t\t\tClearEndpointState(orig);\n\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\tu_char ctrl = endp->buffer[PSEUDO_CONTROL_FIELD_INDEX];\n\t\t\tif ( orig != (bool)(ctrl & 0x80) )\n\t\t\t\tanalyzer->Weird(\"dnp3_unexpected_flow_direction\");\n\t\t\tendp->pkt_length = endp->buffer[PSEUDO_LENGTH_INDEX];\n\t\t\tendp->tpflags = endp->buffer[PSEUDO_TRANSPORT_INDEX];\n\t\t\tendp->in_hdr = false; \n\t\t\tif ( ++endp->pkt_cnt == 1 )\n\t\t\t\tinterp->NewData(orig, endp->buffer, endp->buffer + PSEUDO_LINK_LAYER_LEN);\n\t\t\t}\n\t\tif ( ! endp->in_hdr )\n\t\t\t{\n\t\t\tassert(endp->pkt_length);\n\t\t\tint n = PSEUDO_APP_LAYER_INDEX + (endp->pkt_length - 5) + ((endp->pkt_length - 5) / 16) * 2\n\t\t\t\t\t+ 2 * ( ((endp->pkt_length - 5) % 16 == 0) ? 0 : 1) - 1 ;\n\t\t\tif ( ! AddToBuffer(endp, n, &data, &len) )\n\t\t\t\treturn true;\n\t\t\tif ( ! ParseAppLayer(endp) )\n\t\t\t\treturn false;\n\t\t\tendp->buffer_len = 0;\n\t\t\tendp->in_hdr = true;\n\t\t\t}\n\t\t}\n\treturn true;\n\t}", "target": 1}
{"code": "static int raw_cmd_copyout(int cmd, void __user *param,\n\t\t\t\t  struct floppy_raw_cmd *ptr)\n{\n\tint ret;\n\twhile (ptr) {\n\t\tret = copy_to_user(param, ptr, sizeof(*ptr));\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t\tparam += sizeof(struct floppy_raw_cmd);\n\t\tif ((ptr->flags & FD_RAW_READ) && ptr->buffer_length) {\n\t\t\tif (ptr->length >= 0 &&\n\t\t\t    ptr->length <= ptr->buffer_length) {\n\t\t\t\tlong length = ptr->buffer_length - ptr->length;\n\t\t\t\tret = fd_copyout(ptr->data, ptr->kernel_data,\n\t\t\t\t\t\t length);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "PHP_FUNCTION(pg_host)\n{\n\tphp_pgsql_get_link_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_HOST);\n}", "target": 0}
{"code": "inline bool RARPPM_CONTEXT::decodeSymbol2(ModelPPM *Model)\n{\n  int count, HiCnt, i=NumStats-Model->NumMasked;\n  RARPPM_SEE2_CONTEXT* psee2c=makeEscFreq2(Model,i);\n  RARPPM_STATE* ps[256], ** pps=ps, * p=U.Stats-1;\n  HiCnt=0;\n  do \n  {\n    do \n    { \n      p++; \n    } while (Model->CharMask[p->Symbol] == Model->EscCount);\n    HiCnt += p->Freq;\n    if (pps>=ps+ASIZE(ps))\n      return false;\n    *pps++ = p;\n  } while ( --i );\n  Model->Coder.SubRange.scale += HiCnt;\n  count=Model->Coder.GetCurrentCount();\n  if (count>=(int)Model->Coder.SubRange.scale)\n    return(false);\n  p=*(pps=ps);\n  if (count < HiCnt) \n  {\n    HiCnt=0;\n    while ((HiCnt += p->Freq) <= count) \n    {\n      pps++;\n      if (pps>=ps+ASIZE(ps)) \n        return false;\n      p=*pps;\n    }\n    Model->Coder.SubRange.LowCount = (Model->Coder.SubRange.HighCount=HiCnt)-p->Freq;\n    psee2c->update();\n    update2(Model,p);\n  }\n  else\n  {\n    Model->Coder.SubRange.LowCount=HiCnt;\n    Model->Coder.SubRange.HighCount=Model->Coder.SubRange.scale;\n    i=NumStats-Model->NumMasked;\n    pps--;\n    do \n    { \n      pps++;\n      if (pps>=ps+ASIZE(ps)) \n        return false;\n      Model->CharMask[(*pps)->Symbol]=Model->EscCount; \n    } while ( --i );\n    psee2c->Summ += Model->Coder.SubRange.scale;\n    Model->NumMasked = NumStats;\n  }\n  return true;\n}", "target": 1}
{"code": "void schi_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}", "target": 0}
{"code": "int smb2_allocate_rsp_buf(struct ksmbd_work *work)\n{\n\tstruct smb2_hdr *hdr = smb2_get_msg(work->request_buf);\n\tsize_t small_sz = MAX_CIFS_SMALL_BUFFER_SIZE;\n\tsize_t large_sz = small_sz + work->conn->vals->max_trans_size;\n\tsize_t sz = small_sz;\n\tint cmd = le16_to_cpu(hdr->Command);\n\tif (cmd == SMB2_IOCTL_HE || cmd == SMB2_QUERY_DIRECTORY_HE)\n\t\tsz = large_sz;\n\tif (cmd == SMB2_QUERY_INFO_HE) {\n\t\tstruct smb2_query_info_req *req;\n\t\treq = smb2_get_msg(work->request_buf);\n\t\tif (req->InfoType == SMB2_O_INFO_FILE &&\n\t\t    (req->FileInfoClass == FILE_FULL_EA_INFORMATION ||\n\t\t     req->FileInfoClass == FILE_ALL_INFORMATION))\n\t\t\tsz = large_sz;\n\t}\n\tif (le32_to_cpu(hdr->NextCommand) > 0)\n\t\tsz = large_sz;\n\twork->response_buf = kvmalloc(sz, GFP_KERNEL | __GFP_ZERO);\n\tif (!work->response_buf)\n\t\treturn -ENOMEM;\n\twork->response_sz = sz;\n\treturn 0;\n}", "target": 1}
{"code": "DECLAREcpFunc(cpContigStrips2SeparateTiles)\n{\n\treturn cpImage(in, out,\n\t    readContigStripsIntoBuffer,\n\t    writeBufferToSeparateTiles,\n\t    imagelength, imagewidth, spp);\n}", "target": 0}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  TFLITE_DCHECK(node->builtin_data != nullptr);\n  OpData* data = static_cast<OpData*>(node->user_data);\n  auto* params = reinterpret_cast<TfLiteSubParams*>(node->builtin_data);\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  TF_LITE_ENSURE(context, input1 != nullptr);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TF_LITE_ENSURE(context, input2 != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE_STATUS(\n      CalculateOpData(context, params, input1, input2, output, data));\n  return kTfLiteOk;\n}", "target": 0}
{"code": "apply_intended_configuration (GsdXrandrManager *manager, const char *intended_filename, guint32 timestamp)\n{\n        GError *my_error;\n        my_error = NULL;\n        if (!apply_configuration_from_filename (manager, intended_filename, FALSE, timestamp, &my_error)) {\n                if (my_error) {\n                        if (!g_error_matches (my_error, G_FILE_ERROR, G_FILE_ERROR_NOENT))\n                                error_message (manager, _(\"Could not apply the stored configuration for monitors\"), my_error, NULL);\n                        g_error_free (my_error);\n                }\n        }\n}", "target": 0}
{"code": "static void free_kvm_area(void)\n{\n\tint cpu;\n\tfor_each_possible_cpu(cpu) {\n\t\tfree_vmcs(per_cpu(vmxarea, cpu));\n\t\tper_cpu(vmxarea, cpu) = NULL;\n\t}\n}", "target": 0}
{"code": "void headerMergeLegacySigs(Header h, Header sigh)\n{\n    HeaderIterator hi;\n    struct rpmtd_s td;\n    hi = headerInitIterator(sigh);\n    for (; headerNext(hi, &td); rpmtdFreeData(&td))\n    {\n\tswitch (td.tag) {\n\tcase RPMSIGTAG_SIZE:\n\t    td.tag = RPMTAG_SIGSIZE;\n\t    break;\n\tcase RPMSIGTAG_PGP:\n\t    td.tag = RPMTAG_SIGPGP;\n\t    break;\n\tcase RPMSIGTAG_MD5:\n\t    td.tag = RPMTAG_SIGMD5;\n\t    break;\n\tcase RPMSIGTAG_GPG:\n\t    td.tag = RPMTAG_SIGGPG;\n\t    break;\n\tcase RPMSIGTAG_PGP5:\n\t    td.tag = RPMTAG_SIGPGP5;\n\t    break;\n\tcase RPMSIGTAG_PAYLOADSIZE:\n\t    td.tag = RPMTAG_ARCHIVESIZE;\n\t    break;\n\tcase RPMSIGTAG_FILESIGNATURES:\n\t    td.tag = RPMTAG_FILESIGNATURES;\n\t    break;\n\tcase RPMSIGTAG_FILESIGNATURELENGTH:\n\t    td.tag = RPMTAG_FILESIGNATURELENGTH;\n\t    break;\n\tcase RPMSIGTAG_VERITYSIGNATURES:\n\tcase RPMSIGTAG_VERITYSIGNATUREALGO:\n\tcase RPMSIGTAG_SHA1:\n\tcase RPMSIGTAG_SHA256:\n\tcase RPMSIGTAG_DSA:\n\tcase RPMSIGTAG_RSA:\n\tdefault:\n\t    if (!(td.tag >= HEADER_SIGBASE && td.tag < HEADER_TAGBASE))\n\t\tcontinue;\n\t    break;\n\t}\n\tif (!headerIsEntry(h, td.tag)) {\n\t    switch (td.type) {\n\t    case RPM_NULL_TYPE:\n\t\tcontinue;\n\t\tbreak;\n\t    case RPM_CHAR_TYPE:\n\t    case RPM_INT8_TYPE:\n\t    case RPM_INT16_TYPE:\n\t    case RPM_INT32_TYPE:\n\t    case RPM_INT64_TYPE:\n\t\tif (td.count != 1)\n\t\t    continue;\n\t\tbreak;\n\t    case RPM_STRING_TYPE:\n\t    case RPM_STRING_ARRAY_TYPE:\n\t    case RPM_BIN_TYPE:\n\t\tif (td.count >= 16*1024)\n\t\t    continue;\n\t\tbreak;\n\t    case RPM_I18NSTRING_TYPE:\n\t\tcontinue;\n\t\tbreak;\n\t    }\n\t    (void) headerPut(h, &td, HEADERPUT_DEFAULT);\n\t}\n    }\n    headerFreeIterator(hi);\n}", "target": 1}
{"code": "static bool check_buffer(RBinFile *bf, RBuffer *b) {\n\tut8 buf[4];\n\tr_buf_read_at (b, 0, buf, sizeof (buf));\n\treturn !memcmp (buf, \"\\x02\\xff\\x01\\xff\", 4);\n}", "target": 0}
{"code": "    ThreadState* thread_state() const { return thread_state_; }", "target": 0}
{"code": "void UncompressElementOp::Compute(OpKernelContext* ctx) {\n  Tensor tensor = ctx->input(0);\n  const Variant& variant = tensor.scalar<Variant>()();\n  const CompressedElement* compressed = variant.get<CompressedElement>();\n  OP_REQUIRES(\n      ctx, compressed != nullptr,\n      errors::InvalidArgument(\n          \"Input does not contain a compressed element. Instead got tensor \",\n          tensor.DebugString()));\n  std::vector<Tensor> components;\n  OP_REQUIRES_OK(ctx, UncompressElement(*compressed, &components));\n  OP_REQUIRES(ctx, components.size() == output_types_.size(),\n              errors::FailedPrecondition(\"Expected \", output_types_.size(),\n                                         \" outputs from uncompress, but got \",\n                                         components.size()));\n  for (int i = 0; i < components.size(); ++i) {\n    OP_REQUIRES(\n        ctx, components[i].dtype() == output_types_[i],\n        errors::FailedPrecondition(\"Expected a tensor of type \",\n                                   DataTypeString(output_types_[i]),\n                                   \" but got a tensor of type \",\n                                   DataTypeString(components[i].dtype())));\n    ctx->set_output(i, components[i]);\n  }\n}", "target": 0}
{"code": "void LanLinkProvider::newConnection()\n{\n    qCDebug(KDECONNECT_CORE) << \"LanLinkProvider newConnection\";\n    while (m_server->hasPendingConnections()) {\n        QSslSocket* socket = m_server->nextPendingConnection();\n        configureSocket(socket);\n        connect(socket, &QAbstractSocket::disconnected,\n                socket, &QObject::deleteLater);\n        connect(socket, &QIODevice::readyRead,\n                this, &LanLinkProvider::dataReceived);\n        QTimer* timer = new QTimer(socket);\n        timer->setSingleShot(true);\n        timer->setInterval(1000);\n        connect(socket, &QSslSocket::encrypted,\n                timer, &QObject::deleteLater);\n        connect(timer, &QTimer::timeout, socket, [socket] {\n            qCWarning(KDECONNECT_CORE) << \"LanLinkProvider/newConnection: Host timed out without sending any identity.\" << socket->peerAddress();\n            socket->disconnectFromHost();\n        });\n        timer->start();\n    }\n}", "target": 0}
{"code": "buffer_add_range(int fd, struct evbuffer *evb, struct range *range)\n{\n\tchar\tbuf[BUFSIZ];\n\tsize_t\tn, range_sz;\n\tssize_t\tnread;\n\tif (lseek(fd, range->start, SEEK_SET) == -1)\n\t\treturn (0);\n\trange_sz = range->end - range->start + 1;\n\twhile (range_sz) {\n\t\tn = MINIMUM(range_sz, sizeof(buf));\n\t\tif ((nread = read(fd, buf, n)) == -1)\n\t\t\treturn (0);\n\t\tevbuffer_add(evb, buf, nread);\n\t\trange_sz -= nread;\n\t}\n\treturn (1);\n}", "target": 1}
{"code": "static const unsigned char *parse_object(cJSON *item, const unsigned char *value, const unsigned char **ep)\n{\n    cJSON *child = NULL;\n    if (*value != '{')\n    {\n        *ep = value;\n        goto fail;\n    }\n    item->type = cJSON_Object;\n    value = skip(value + 1);\n    if (*value == '}')\n    {\n        return value + 1;\n    }\n    child = cJSON_New_Item();\n    item->child = child;\n    if (!item->child)\n    {\n        goto fail;\n    }\n    value = skip(parse_string(child, skip(value), ep));\n    if (!value)\n    {\n        goto fail;\n    }\n    child->string = child->valuestring;\n    child->valuestring = NULL;\n    if (*value != ':')\n    {\n        *ep = value;\n        goto fail;\n    }\n    value = skip(parse_value(child, skip(value + 1), ep));\n    if (!value)\n    {\n        goto fail;\n    }\n    while (*value == ',')\n    {\n        cJSON *new_item = NULL;\n        if (!(new_item = cJSON_New_Item()))\n        {\n            goto fail;\n        }\n        child->next = new_item;\n        new_item->prev = child;\n        child = new_item;\n        value = skip(parse_string(child, skip(value + 1), ep));\n        if (!value)\n        {\n            goto fail;\n        }\n        child->string = child->valuestring;\n        child->valuestring = NULL;\n        if (*value != ':')\n        {\n            *ep = value;\n            goto fail;\n        }\n        value = skip(parse_value(child, skip(value + 1), ep));\n        if (!value)\n        {\n            goto fail;\n        }\n    }\n    if (*value == '}')\n    {\n        return value + 1;\n    }\n    *ep = value;\nfail:\n    if (item->child != NULL)\n    {\n        cJSON_Delete(child);\n        item->child = NULL;\n    }\n    return NULL;\n}", "target": 1}
{"code": "nvkm_vmm_node_remove(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n{\n\trb_erase(&vma->tree, &vmm->root);\n}", "target": 0}
{"code": "int ziplistSafeToAdd(unsigned char* zl, size_t add) {\n    size_t len = zl? ziplistBlobLen(zl): 0;\n    if (len + add > ZIPLIST_MAX_SAFETY_SIZE)\n        return 0;\n    return 1;\n}", "target": 0}
{"code": "GF_Box *vwid_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ViewIdentifierBox, GF_ISOM_BOX_TYPE_VWID);\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "static int adpt_bios_param(struct scsi_device *sdev, struct block_device *dev,\n\t\tsector_t capacity, int geom[])\n{\n\tint heads=-1;\n\tint sectors=-1;\n\tint cylinders=-1;\n\tif (capacity < 0x2000 ) {\t\n\t\theads = 18;\n\t\tsectors = 2;\n\t} \n\telse if (capacity < 0x20000) {\n\t\theads = 64;\n\t\tsectors = 32;\n\t}\n\telse if (capacity < 0x40000) {\n\t\theads = 65;\n\t\tsectors = 63;\n\t}\n\telse if (capacity < 0x80000) {\n\t\theads = 128;\n\t\tsectors = 63;\n\t}\n\telse {\n\t\theads = 255;\n\t\tsectors = 63;\n\t}\n\tcylinders = sector_div(capacity, heads * sectors);\n\tif(sdev->type == 5) {  \n\t\theads = 252;\n\t\tsectors = 63;\n\t\tcylinders = 1111;\n\t}\n\tgeom[0] = heads;\n\tgeom[1] = sectors;\n\tgeom[2] = cylinders;\n\tPDEBUG(\"adpt_bios_param: exit\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "static x3f_huffnode_t *new_node(x3f_hufftree_t *tree)\n{\n\tif (tree->free_node_index >= tree->total_node_index)\n\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n  x3f_huffnode_t *t = &tree->nodes[tree->free_node_index];\n  t->branch[0] = NULL;\n  t->branch[1] = NULL;\n  t->leaf = UNDEFINED_LEAF;\n  tree->free_node_index++;\n  return t;\n}", "target": 0}
{"code": "GF_Err chnl_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_ChannelLayoutBox *ptr = (GF_ChannelLayoutBox *) s;\n\tISOM_DECREASE_SIZE(s, 1)\n\tptr->layout.stream_structure = gf_bs_read_u8(bs);\n\tif (ptr->layout.stream_structure & 1) {\n\t\tISOM_DECREASE_SIZE(s, 1)\n\t\tptr->layout.definedLayout = gf_bs_read_u8(bs);\n\t\tif (ptr->layout.definedLayout==0) {\n\t\t\tu32 remain = (u32) ptr->size;\n\t\t\tif (ptr->layout.stream_structure & 2) remain--;\n\t\t\tptr->layout.channels_count = 0;\n\t\t\twhile (remain) {\n\t\t\t\tISOM_DECREASE_SIZE(s, 1)\n\t\t\t\tptr->layout.layouts[ptr->layout.channels_count].position = gf_bs_read_u8(bs);\n\t\t\t\tremain--;\n\t\t\t\tif (ptr->layout.layouts[ptr->layout.channels_count].position == 126) {\n\t\t\t\t\tISOM_DECREASE_SIZE(s, 3)\n\t\t\t\t\tptr->layout.layouts[ptr->layout.channels_count].azimuth = gf_bs_read_int(bs, 16);\n\t\t\t\t\tptr->layout.layouts[ptr->layout.channels_count].elevation = gf_bs_read_int(bs, 8);\n\t\t\t\t\tremain-=3;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(s, 8)\n\t\t\tptr->layout.omittedChannelsMap = gf_bs_read_u64(bs);\n\t\t}\n\t}\n\tif (ptr->layout.stream_structure & 2) {\n\t\tISOM_DECREASE_SIZE(s, 1)\n\t\tptr->layout.object_count = gf_bs_read_u8(bs);\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "write(Protocol_* iprot, const StructInfo& structInfo, const void* object) {\n  DCHECK(object);\n  size_t written = iprot->writeStructBegin(structInfo.name);\n  if (UNLIKELY(structInfo.unionExt != nullptr)) {\n    const FieldInfo* end = structInfo.fieldInfos + structInfo.numFields;\n    const auto& unionId =\n        activeUnionMemberId(object, structInfo.unionExt->unionTypeOffset);\n    const FieldInfo* found = std::lower_bound(\n        structInfo.fieldInfos,\n        end,\n        unionId,\n        [](const FieldInfo& lhs, FieldID rhs) { return lhs.id < rhs; });\n    if (found < end && found->id == unionId) {\n      const OptionalThriftValue value = getValue(*found->typeInfo, object);\n      if (value.hasValue()) {\n        written += writeField(iprot, *found, value.value());\n      } else if (found->typeInfo->type == protocol::TType::T_STRUCT) {\n        written += iprot->writeFieldBegin(\n            found->name, found->typeInfo->type, found->id);\n        written += iprot->writeStructBegin(found->name);\n        written += iprot->writeStructEnd();\n        written += iprot->writeFieldStop();\n        written += iprot->writeFieldEnd();\n      }\n    }\n  } else {\n    for (std::int16_t index = 0; index < structInfo.numFields; index++) {\n      const auto& fieldInfo = structInfo.fieldInfos[index];\n      if (fieldInfo.isUnqualified || fieldInfo.issetOffset == 0 ||\n          fieldIsSet(object, fieldInfo.issetOffset)) {\n        const OptionalThriftValue value =\n            getValue(*fieldInfo.typeInfo, getMember(fieldInfo, object));\n        if (value.hasValue()) {\n          written += writeField(iprot, fieldInfo, value.value());\n        }\n      }\n    }\n  }\n  written += iprot->writeFieldStop();\n  written += iprot->writeStructEnd();\n  return written;\n}", "target": 1}
{"code": "static int gup_pte_range(pmd_t pmd, unsigned long addr, unsigned long end,\n\t\t\t int write, struct page **pages, int *nr)\n{\n\tstruct dev_pagemap *pgmap = NULL;\n\tint nr_start = *nr, ret = 0;\n\tpte_t *ptep, *ptem;\n\tptem = ptep = pte_offset_map(&pmd, addr);\n\tdo {\n\t\tpte_t pte = gup_get_pte(ptep);\n\t\tstruct page *head, *page;\n\t\tif (pte_protnone(pte))\n\t\t\tgoto pte_unmap;\n\t\tif (!pte_access_permitted(pte, write))\n\t\t\tgoto pte_unmap;\n\t\tif (pte_devmap(pte)) {\n\t\t\tpgmap = get_dev_pagemap(pte_pfn(pte), pgmap);\n\t\t\tif (unlikely(!pgmap)) {\n\t\t\t\tundo_dev_pagemap(nr, nr_start, pages);\n\t\t\t\tgoto pte_unmap;\n\t\t\t}\n\t\t} else if (pte_special(pte))\n\t\t\tgoto pte_unmap;\n\t\tVM_BUG_ON(!pfn_valid(pte_pfn(pte)));\n\t\tpage = pte_page(pte);\n\t\thead = compound_head(page);\n\t\tif (!page_cache_get_speculative(head))\n\t\t\tgoto pte_unmap;\n\t\tif (unlikely(pte_val(pte) != pte_val(*ptep))) {\n\t\t\tput_page(head);\n\t\t\tgoto pte_unmap;\n\t\t}\n\t\tVM_BUG_ON_PAGE(compound_head(page) != head, page);\n\t\tSetPageReferenced(page);\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t} while (ptep++, addr += PAGE_SIZE, addr != end);\n\tret = 1;\npte_unmap:\n\tif (pgmap)\n\t\tput_dev_pagemap(pgmap);\n\tpte_unmap(ptem);\n\treturn ret;\n}", "target": 1}
{"code": "TEST(HeaderMapImplTest, RemoveHost) {\n  TestRequestHeaderMapImpl headers;\n  headers.setHost(\"foo\");\n  EXPECT_EQ(\"foo\", headers.get_(\"host\"));\n  EXPECT_EQ(\"foo\", headers.get_(\":authority\"));\n  EXPECT_EQ(1UL, headers.remove(\"host\"));\n  EXPECT_EQ(\"\", headers.get_(\"host\"));\n  EXPECT_EQ(\"\", headers.get_(\":authority\"));\n  EXPECT_EQ(nullptr, headers.Host());\n}", "target": 0}
{"code": "static int do_io_accounting(struct task_struct *task, char *buffer, int whole)\n{\n\tstruct task_io_accounting acct = task->ioac;\n\tunsigned long flags;\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ))\n\t\treturn -EACCES;\n\tif (whole && lock_task_sighand(task, &flags)) {\n\t\tstruct task_struct *t = task;\n\t\ttask_io_accounting_add(&acct, &task->signal->ioac);\n\t\twhile_each_thread(task, t)\n\t\t\ttask_io_accounting_add(&acct, &t->ioac);\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\treturn sprintf(buffer,\n\t\t\t\"rchar: %llu\\n\"\n\t\t\t\"wchar: %llu\\n\"\n\t\t\t\"syscr: %llu\\n\"\n\t\t\t\"syscw: %llu\\n\"\n\t\t\t\"read_bytes: %llu\\n\"\n\t\t\t\"write_bytes: %llu\\n\"\n\t\t\t\"cancelled_write_bytes: %llu\\n\",\n\t\t\t(unsigned long long)acct.rchar,\n\t\t\t(unsigned long long)acct.wchar,\n\t\t\t(unsigned long long)acct.syscr,\n\t\t\t(unsigned long long)acct.syscw,\n\t\t\t(unsigned long long)acct.read_bytes,\n\t\t\t(unsigned long long)acct.write_bytes,\n\t\t\t(unsigned long long)acct.cancelled_write_bytes);\n}", "target": 0}
{"code": "static int jsR_hasproperty(js_State *J, js_Object *obj, const char *name)\n{\n\tjs_Property *ref;\n\tint k;\n\tif (obj->type == JS_CARRAY) {\n\t\tif (!strcmp(name, \"length\")) {\n\t\t\tjs_pushnumber(J, obj->u.a.length);\n\t\t\treturn 1;\n\t\t}\n\t}\n\telse if (obj->type == JS_CSTRING) {\n\t\tif (!strcmp(name, \"length\")) {\n\t\t\tjs_pushnumber(J, obj->u.s.length);\n\t\t\treturn 1;\n\t\t}\n\t\tif (js_isarrayindex(J, name, &k)) {\n\t\t\tif (k >= 0 && k < obj->u.s.length) {\n\t\t\t\tjs_pushrune(J, js_runeat(J, obj->u.s.string, k));\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\telse if (obj->type == JS_CREGEXP) {\n\t\tif (!strcmp(name, \"source\")) {\n\t\t\tjs_pushliteral(J, obj->u.r.source);\n\t\t\treturn 1;\n\t\t}\n\t\tif (!strcmp(name, \"global\")) {\n\t\t\tjs_pushboolean(J, obj->u.r.flags & JS_REGEXP_G);\n\t\t\treturn 1;\n\t\t}\n\t\tif (!strcmp(name, \"ignoreCase\")) {\n\t\t\tjs_pushboolean(J, obj->u.r.flags & JS_REGEXP_I);\n\t\t\treturn 1;\n\t\t}\n\t\tif (!strcmp(name, \"multiline\")) {\n\t\t\tjs_pushboolean(J, obj->u.r.flags & JS_REGEXP_M);\n\t\t\treturn 1;\n\t\t}\n\t\tif (!strcmp(name, \"lastIndex\")) {\n\t\t\tjs_pushnumber(J, obj->u.r.last);\n\t\t\treturn 1;\n\t\t}\n\t}\n\telse if (obj->type == JS_CUSERDATA) {\n\t\tif (obj->u.user.has && obj->u.user.has(J, obj->u.user.data, name))\n\t\t\treturn 1;\n\t}\n\tref = jsV_getproperty(J, obj, name);\n\tif (ref) {\n\t\tif (ref->getter) {\n\t\t\tjs_pushobject(J, ref->getter);\n\t\t\tjs_pushobject(J, obj);\n\t\t\tjs_call(J, 0);\n\t\t} else {\n\t\t\tjs_pushvalue(J, ref->value);\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "qemuProcessHandleMonitorEOF(qemuMonitorPtr mon,\n                            virDomainObjPtr vm,\n                            void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    qemuDomainObjPrivatePtr priv;\n    struct qemuProcessEvent *processEvent;\n    virObjectLock(vm);\n    VIR_DEBUG(\"Received EOF on %p '%s'\", vm, vm->def->name);\n    priv = vm->privateData;\n    if (priv->beingDestroyed) {\n        VIR_DEBUG(\"Domain is being destroyed, EOF is expected\");\n        goto cleanup;\n    }\n    processEvent = g_new0(struct qemuProcessEvent, 1);\n    processEvent->eventType = QEMU_PROCESS_EVENT_MONITOR_EOF;\n    processEvent->vm = virObjectRef(vm);\n    if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {\n        virObjectUnref(vm);\n        qemuProcessEventFree(processEvent);\n        goto cleanup;\n    }\n    virObjectLock(mon);\n    qemuMonitorUnregister(mon);\n    virObjectUnlock(mon);\n    qemuDomainDestroyNamespace(driver, vm);\n cleanup:\n    virObjectUnlock(vm);\n}", "target": 0}
{"code": "cdf_tole4(uint32_t sv)\n{\n\treturn CDF_TOLE4(sv);\n}", "target": 0}
{"code": "static OPCODE_DESC* avr_op_analyze(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, CPU_MODEL *cpu) {\n\tOPCODE_DESC *opcode_desc;\n\tif (len < 2) {\n\t\treturn NULL;\n\t}\n\tut16 ins = (buf[1] << 8) | buf[0];\n\tint fail;\n\tchar *t;\n\tmemset (op, 0, sizeof (RAnalOp));\n\top->ptr = UT64_MAX;\n\top->val = UT64_MAX;\n\top->jump = UT64_MAX;\n\tr_strbuf_init (&op->esil);\n\tfor (opcode_desc = opcodes; opcode_desc->handler; opcode_desc++) {\n\t\tif ((ins & opcode_desc->mask) == opcode_desc->selector) {\n\t\t\tfail = 0;\n\t\t\top->cycles = opcode_desc->cycles;\n\t\t\top->size = opcode_desc->size;\n\t\t\top->type = opcode_desc->type;\n\t\t\top->jump = UT64_MAX;\n\t\t\top->fail = UT64_MAX;\n\t\t\top->addr = addr;\n\t\t\tr_strbuf_setf (&op->esil, \"\");\n\t\t\topcode_desc->handler (anal, op, buf, len, &fail, cpu);\n\t\t\tif (fail) {\n\t\t\t\tgoto INVALID_OP;\n\t\t\t}\n\t\t\tif (op->cycles <= 0) {\n\t\t\t\topcode_desc->cycles = 2;\n\t\t\t}\n\t\t\top->nopcode = (op->type == R_ANAL_OP_TYPE_UNK);\n\t\t\tt = r_strbuf_get (&op->esil);\n\t\t\tif (t && strlen (t) > 1) {\n\t\t\t\tt += strlen (t) - 1;\n\t\t\t\tif (*t == ',') {\n\t\t\t\t\t*t = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn opcode_desc;\n\t\t}\n\t}\n\tif ((ins & 0xff00) == 0xff00 && (ins & 0xf) > 7) {\n\t\tgoto INVALID_OP;\n\t}\nINVALID_OP:\n\top->family = R_ANAL_OP_FAMILY_UNKNOWN;\n\top->type = R_ANAL_OP_TYPE_UNK;\n\top->addr = addr;\n\top->fail = UT64_MAX;\n\top->jump = UT64_MAX;\n\top->ptr = UT64_MAX;\n\top->val = UT64_MAX;\n\top->nopcode = 1;\n\top->cycles = 1;\n\top->size = 2;\n\tr_strbuf_set (&op->esil, \"1,$\");\n\treturn NULL;\n}", "target": 0}
{"code": "GF_Err urn_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, to_read;\n\tchar *tmpName;\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\tif (! ptr->size ) return GF_OK;\n\tto_read = (u32) ptr->size;\n\ttmpName = (char*)gf_malloc(sizeof(char) * to_read);\n\tif (!tmpName) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, tmpName, to_read);\n\ti = 0;\n\twhile ( (tmpName[i] != 0) && (i < to_read) ) {\n\t\ti++;\n\t}\n\tif (i == to_read) {\n\t\tgf_free(tmpName);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (i == to_read - 1) {\n\t\tptr->nameURN = tmpName;\n\t\tptr->location = NULL;\n\t\treturn GF_OK;\n\t}\n\tptr->nameURN = (char*)gf_malloc(sizeof(char) * (i+1));\n\tif (!ptr->nameURN) {\n\t\tgf_free(tmpName);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tptr->location = (char*)gf_malloc(sizeof(char) * (to_read - i - 1));\n\tif (!ptr->location) {\n\t\tgf_free(tmpName);\n\t\tgf_free(ptr->nameURN);\n\t\tptr->nameURN = NULL;\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tmemcpy(ptr->nameURN, tmpName, i + 1);\n\tmemcpy(ptr->location, tmpName + i + 1, (to_read - i - 1));\n\tgf_free(tmpName);\n\treturn GF_OK;\n}", "target": 1}
{"code": "void xacct_add_tsk(struct taskstats *stats, struct task_struct *p)\n{\n\tstats->coremem = jiffies_to_usecs(p->acct_rss_mem1) * PAGE_SIZE / MB;\n\tstats->virtmem = jiffies_to_usecs(p->acct_vm_mem1) * PAGE_SIZE / MB;\n\tif (p->mm) {\n\t\tstats->hiwater_rss   = p->mm->hiwater_rss * PAGE_SIZE / KB;\n\t\tstats->hiwater_vm    = p->mm->hiwater_vm * PAGE_SIZE / KB;\n\t}\n\tstats->read_char\t= p->rchar;\n\tstats->write_char\t= p->wchar;\n\tstats->read_syscalls\t= p->syscr;\n\tstats->write_syscalls\t= p->syscw;\n}", "target": 1}
{"code": "ExprResolveGroup(struct xkb_context *ctx, const ExprDef *expr,\n                 xkb_layout_index_t *group_rtrn)\n{\n    bool ok;\n    int result;\n    ok = ExprResolveIntegerLookup(ctx, expr, &result, SimpleLookup,\n                                  groupNames);\n    if (!ok)\n        return false;\n    if (result <= 0 || result > XKB_MAX_GROUPS) {\n        log_err(ctx, \"Group index %u is out of range (1..%d)\\n\",\n                result, XKB_MAX_GROUPS);\n        return false;\n    }\n    *group_rtrn = (xkb_layout_index_t) result;\n    return true;\n}", "target": 0}
{"code": "void TestJlCompress::extractDir()\n{\n    QFETCH(QString, zipName);\n    QFETCH(QStringList, fileNames);\n    QDir curDir;\n    if (!curDir.mkpath(\"jlext/jldir\")) {\n        QFAIL(\"Couldn't mkpath jlext/jldir\");\n    }\n    if (!createTestFiles(fileNames)) {\n        QFAIL(\"Couldn't create test files\");\n    }\n    if (!createTestArchive(zipName, fileNames)) {\n        QFAIL(\"Couldn't create test archive\");\n    }\n    QStringList extracted;\n    QCOMPARE((extracted = JlCompress::extractDir(zipName, \"jlext/jldir\"))\n        .count(), fileNames.count());\n    foreach (QString fileName, fileNames) {\n        QString fullName = \"jlext/jldir/\" + fileName;\n        QFileInfo fileInfo(fullName);\n        QFileInfo extInfo(\"tmp/\" + fileName);\n        if (!fileInfo.isDir())\n            QCOMPARE(fileInfo.size(), extInfo.size());\n        QCOMPARE(fileInfo.permissions(), extInfo.permissions());\n        curDir.remove(fullName);\n        curDir.rmpath(fileInfo.dir().path());\n        QString absolutePath = fileInfo.absoluteFilePath();\n        if (fileInfo.isDir() && !absolutePath.endsWith('/'))\n\t    absolutePath += '/';\n        QVERIFY(extracted.contains(absolutePath));\n    }\n    QFile zipFile(zipName);\n    QVERIFY(zipFile.open(QIODevice::ReadOnly));\n    QCOMPARE((extracted = JlCompress::extractDir(&zipFile, \"jlext/jldir\"))\n        .count(), fileNames.count());\n    foreach (QString fileName, fileNames) {\n        QString fullName = \"jlext/jldir/\" + fileName;\n        QFileInfo fileInfo(fullName);\n        QFileInfo extInfo(\"tmp/\" + fileName);\n        if (!fileInfo.isDir())\n            QCOMPARE(fileInfo.size(), extInfo.size());\n        QCOMPARE(fileInfo.permissions(), extInfo.permissions());\n        curDir.remove(fullName);\n        curDir.rmpath(fileInfo.dir().path());\n        QString absolutePath = fileInfo.absoluteFilePath();\n        if (fileInfo.isDir() && !absolutePath.endsWith('/'))\n        absolutePath += '/';\n        QVERIFY(extracted.contains(absolutePath));\n    }\n    zipFile.close();\n    curDir.rmpath(\"jlext/jldir\");\n    removeTestFiles(fileNames);\n    curDir.remove(zipName);\n}", "target": 1}
{"code": "MagickPrivate MagickBooleanType SyncImagePixelCache(Image *image,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n  assert(image != (Image *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  cache_info=(CacheInfo *) GetImagePixelCache(image,MagickTrue,exception);\n  return(cache_info == (CacheInfo *) NULL ? MagickFalse : MagickTrue);\n}", "target": 0}
{"code": "static bool valid_filemode(const int filemode)\n{\n\treturn (filemode == GIT_FILEMODE_TREE\n\t\t|| filemode == GIT_FILEMODE_BLOB\n\t\t|| filemode == GIT_FILEMODE_BLOB_EXECUTABLE\n\t\t|| filemode == GIT_FILEMODE_LINK\n\t\t|| filemode == GIT_FILEMODE_COMMIT);\n}", "target": 0}
{"code": "void NetworkScreen::OnHelpLinkActivated() {\n  ClearErrors();\n  if (!help_app_.get())\n    help_app_.reset(new HelpAppLauncher(view()->GetNativeWindow()));\n  help_app_->ShowHelpTopic(HelpAppLauncher::HELP_CONNECTIVITY);\n}", "target": 0}
{"code": "  CrxImage() : memmgr(0){}", "target": 0}
{"code": "GF_Err schm_box_size(GF_Box *s)\n{\n\tGF_SchemeTypeBox *ptr = (GF_SchemeTypeBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\tptr->size += 8;\n\tif (ptr->flags & 0x000001) ptr->size += 1 + (ptr->URI ? strlen(ptr->URI) : 0);\n\treturn GF_OK;\n}", "target": 0}
{"code": "TfLiteStatus PreluPrepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  PreluParams* params = static_cast<PreluParams*>(node->user_data);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TF_LITE_ENSURE(context, input != nullptr);\n  const TfLiteTensor* alpha = GetInput(context, node, 1);\n  TF_LITE_ENSURE(context, alpha != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TF_LITE_ENSURE(context, output != nullptr);\n  return CalculatePreluParams(input, alpha, output, params);\n}", "target": 0}
{"code": "ProcAllocColor(ClientPtr client)\n{\n    ColormapPtr pmap;\n    int rc;\n    REQUEST(xAllocColorReq);\n    REQUEST_SIZE_MATCH(xAllocColorReq);\n    rc = dixLookupResourceByType((void **) &pmap, stuff->cmap, RT_COLORMAP,\n                                 client, DixAddAccess);\n    if (rc == Success) {\n        xAllocColorReply acr = {\n            .type = X_Reply,\n            .sequenceNumber = client->sequence,\n            .length = 0,\n            .red = stuff->red,\n            .green = stuff->green,\n            .blue = stuff->blue,\n            .pixel = 0\n        };\n        if ((rc = AllocColor(pmap, &acr.red, &acr.green, &acr.blue,\n                             &acr.pixel, client->index)))\n            return rc;\n#ifdef PANORAMIX\n        if (noPanoramiXExtension || !pmap->pScreen->myNum)\n#endif\n            WriteReplyToClient(client, sizeof(xAllocColorReply), &acr);\n        return Success;\n    }\n    else {\n        client->errorValue = stuff->cmap;\n        return rc;\n    }\n}", "target": 0}
{"code": "static void vgacon_scrollback_update(struct vc_data *c, int t, int count)\n{\n\tvoid *p;\n\tif (!vgacon_scrollback_cur->data || !vgacon_scrollback_cur->size ||\n\t    c->vc_num != fg_console)\n\t\treturn;\n\tp = (void *) (c->vc_origin + t * c->vc_size_row);\n\twhile (count--) {\n\t\tif ((vgacon_scrollback_cur->tail + c->vc_size_row) >\n\t\t    vgacon_scrollback_cur->size)\n\t\t\tvgacon_scrollback_cur->tail = 0;\n\t\tscr_memcpyw(vgacon_scrollback_cur->data +\n\t\t\t    vgacon_scrollback_cur->tail,\n\t\t\t    p, c->vc_size_row);\n\t\tvgacon_scrollback_cur->cnt++;\n\t\tp += c->vc_size_row;\n\t\tvgacon_scrollback_cur->tail += c->vc_size_row;\n\t\tif (vgacon_scrollback_cur->tail >= vgacon_scrollback_cur->size)\n\t\t\tvgacon_scrollback_cur->tail = 0;\n\t\tif (vgacon_scrollback_cur->cnt > vgacon_scrollback_cur->rows)\n\t\t\tvgacon_scrollback_cur->cnt = vgacon_scrollback_cur->rows;\n\t\tvgacon_scrollback_cur->cur = vgacon_scrollback_cur->cnt;\n\t}\n}", "target": 1}
{"code": "netsnmp_mibindex_load( void )\n{\n    DIR *dir;\n    struct dirent *file;\n    FILE *fp;\n    char tmpbuf[ 300];\n    char tmpbuf2[300];\n    int  i;\n    char *cp;\n    snprintf( tmpbuf, sizeof(tmpbuf), \"%s/mib_indexes\",\n              get_persistent_directory());\n    tmpbuf[sizeof(tmpbuf)-1] = 0;\n    dir = opendir( tmpbuf );\n    if ( dir == NULL ) {\n        DEBUGMSGTL((\"mibindex\", \"load: (new)\\n\"));\n        mkdirhier( tmpbuf, NETSNMP_AGENT_DIRECTORY_MODE, 0);\n        return;\n    }\n    while ((file = readdir( dir ))) {\n        if ( !isdigit((unsigned char)(file->d_name[0])))\n            continue;\n        i = atoi( file->d_name );\n        snprintf( tmpbuf, sizeof(tmpbuf), \"%s/mib_indexes/%d\",\n              get_persistent_directory(), i );\n        tmpbuf[sizeof(tmpbuf)-1] = 0;\n        fp = fopen( tmpbuf, \"r\" );\n        if (!fp)\n            continue;\n        cp = fgets( tmpbuf2, sizeof(tmpbuf2), fp );\n        fclose( fp );\n        if ( !cp ) {\n            DEBUGMSGTL((\"mibindex\", \"Empty MIB index (%d)\\n\", i));\n            continue;\n        }\n        if ( strncmp( tmpbuf2, \"DIR \", 4 ) != 0 ) {\n            DEBUGMSGTL((\"mibindex\", \"Malformed MIB index (%d)\\n\", i));\n            continue;\n        }\n        tmpbuf2[strlen(tmpbuf2)-1] = 0;\n        DEBUGMSGTL((\"mibindex\", \"load: (%d) %s\\n\", i, tmpbuf2));\n        (void)_mibindex_add( tmpbuf2+4, i );  \n    }\n    closedir( dir );\n}", "target": 1}
{"code": "x509stack_push(struct cert_stack *stack, struct rpki_uri *uri, X509 *x509,\n    enum rpki_policy policy, enum cert_type type)\n{\n\tstruct metadata_node *meta;\n\tstruct repo_level_node *repo, *head_repo;\n\tstruct defer_node *defer_separator;\n\tunsigned int work_repo_level;\n\tint ok;\n\tint error;\n\trepo = malloc(sizeof(struct repo_level_node));\n\tif (repo == NULL)\n\t\treturn pr_enomem();\n\trepo->level = 0;\n\twork_repo_level = working_repo_peek_level();\n\thead_repo = SLIST_FIRST(&stack->levels);\n\tif (head_repo != NULL && work_repo_level > head_repo->level)\n\t\trepo->level = work_repo_level;\n\tSLIST_INSERT_HEAD(&stack->levels, repo, next);\n\tmeta = malloc(sizeof(struct metadata_node));\n\tif (meta == NULL) {\n\t\terror = pr_enomem();\n\t\tgoto end3;\n\t}\n\tmeta->uri = uri;\n\turi_refget(uri);\n\tserial_numbers_init(&meta->serials);\n\tsubjects_init(&meta->subjects);\n\tmeta->resources = resources_create(false);\n\tif (meta->resources == NULL) {\n\t\terror = pr_enomem();\n\t\tgoto end4;\n\t}\n\tresources_set_policy(meta->resources, policy);\n\terror = certificate_get_resources(x509, meta->resources, type);\n\tif (error)\n\t\tgoto end5;\n\tif (type == TA && resources_empty(meta->resources)) {\n\t\terror = pr_val_err(\"Trust Anchor certificate does not define any number resources.\");\n\t\tgoto end5;\n\t}\n\tdefer_separator = malloc(sizeof(struct defer_node));\n\tif (defer_separator == NULL) {\n\t\terror = pr_enomem();\n\t\tgoto end5;\n\t}\n\tdefer_separator->type = DNT_SEPARATOR;\n\tok = sk_X509_push(stack->x509s, x509);\n\tif (ok <= 0) {\n\t\terror = val_crypto_err(\n\t\t    \"Could not add certificate to trusted stack: %d\", ok);\n\t\tgoto end5;\n\t}\n\tSLIST_INSERT_HEAD(&stack->defers, defer_separator, next);\n\tSLIST_INSERT_HEAD(&stack->metas, meta, next);\n\treturn 0;\nend5:\tresources_destroy(meta->resources);\nend4:\tsubjects_cleanup(&meta->subjects, subject_cleanup);\n\tserial_numbers_cleanup(&meta->serials, serial_cleanup);\n\turi_refput(meta->uri);\n\tfree(meta);\nend3:\tSLIST_REMOVE_HEAD(&stack->levels, next);\n\tfree(repo);\n\treturn error;\n}", "target": 1}
{"code": "struct torture_suite *torture_smb2_notify_inotify_init(TALLOC_CTX *ctx)\n{\n\tstruct torture_suite *suite = torture_suite_create(ctx, \"notify-inotify\");\n\tsuite->description = talloc_strdup(suite, \"SMB2-NOTIFY tests that use inotify\");\n\ttorture_suite_add_2smb2_test(suite, \"inotify-rename\", torture_smb2_inotify_rename);\n\treturn suite;\n}", "target": 0}
{"code": "inline int ValidateTensorIndexing(const TfLiteContext* context, int index,\n                                  int max_size, const int* tensor_indices) {\n  if (index >= 0 && index < max_size) {\n    const int tensor_index = tensor_indices[index];\n    if (tensor_index != kTfLiteOptionalTensor) {\n      return tensor_index;\n    }\n  }\n  return -1;\n}", "target": 0}
{"code": "Tss2_RC_Decode(TSS2_RC rc)\n{\n    static __thread char buf[TSS2_ERR_LAYER_NAME_MAX + TSS2_ERR_LAYER_ERROR_STR_MAX + 1];\n    clearbuf(buf);\n    UINT8 layer = tss2_rc_layer_number_get(rc);\n    TSS2_RC_HANDLER handler = layer_handler[layer].handler;\n    const char *lname = layer_handler[layer].name;\n    if (lname[0]) {\n        catbuf(buf, \"%s:\", lname);\n    } else {\n        catbuf(buf, \"%u:\", layer);\n    }\n    handler = !handler ? unknown_layer_handler : handler;\n    UINT16 err_bits = tpm2_error_get(rc);\n    const char *e = err_bits ? handler(err_bits) : \"success\";\n    if (e) {\n        catbuf(buf, \"%s\", e);\n    } else {\n        catbuf(buf, \"0x%X\", err_bits);\n    }\n    return buf;\n}", "target": 1}
{"code": "bool allow_svhandler_flash_range(size_t start, size_t end) {\n  if (start > end) return false;\n  if (start < FLASH_ORIGIN || end > FLASH_END) return false;\n  bool startAllowed = false;\n  bool endAllowed = false;\n  for (const FlashSector* s = flash_sector_map; s->use != FLASH_INVALID; s++) {\n    if (allow_svhandler_flash_sector(s)) {\n      if (!startAllowed &&\n          start + 1 > start &&\n          do_memory_ranges_overlap(start, start + 1, s->start, s->start + s->len)) {\n        startAllowed = true;\n      }\n      if (!endAllowed &&\n          end - 1 < end &&\n          do_memory_ranges_overlap(end - 1, end, s->start, s->start + s->len)) {\n        endAllowed = true;\n      }\n    } else {\n      if (do_memory_ranges_overlap(start, end, s->start, s->start + s->len)) return false;\n    }\n  }\n  if (!startAllowed || !endAllowed) return false;\n  return true;\n}", "target": 0}
{"code": "init_ctx_new(OM_uint32 *minor_status,\n\t     spnego_gss_cred_id_t spcred,\n\t     gss_ctx_id_t *ctx,\n\t     send_token_flag *tokflag)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = NULL;\n\tsc = create_spnego_ctx();\n\tif (sc == NULL)\n\t\treturn GSS_S_FAILURE;\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_INITIATE,\n\t\t\t\t   &sc->mech_set);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\tsc->internal_mech = &sc->mech_set->elements[0];\n\tif (put_mech_set(sc->mech_set, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tsc->ctx_handle = GSS_C_NO_CONTEXT;\n\t*ctx = (gss_ctx_id_t)sc;\n\tsc = NULL;\n\t*tokflag = INIT_TOKEN_SEND;\n\tret = GSS_S_CONTINUE_NEEDED;\ncleanup:\n\trelease_spnego_ctx(&sc);\n\treturn ret;\n}", "target": 1}
{"code": "static void kvm_destroy_devices(struct kvm *kvm)\n{\n\tstruct kvm_device *dev, *tmp;\n\tlist_for_each_entry_safe(dev, tmp, &kvm->devices, vm_node) {\n\t\tlist_del(&dev->vm_node);\n\t\tdev->ops->destroy(dev);\n\t}\n}", "target": 0}
{"code": "ZEND_API void zend_objects_store_del_ref_by_handle_ex(zend_object_handle handle, const zend_object_handlers *handlers TSRMLS_DC) \n{\n\tstruct _store_object *obj;\n\tint failure = 0;\n\tif (!EG(objects_store).object_buckets) {\n\t\treturn;\n\t}\n\tobj = &EG(objects_store).object_buckets[handle].bucket.obj;\n\tif (EG(objects_store).object_buckets[handle].valid) {\n\t\tif (obj->refcount == 1) {\n\t\t\tif (!EG(objects_store).object_buckets[handle].destructor_called) {\n\t\t\t\tEG(objects_store).object_buckets[handle].destructor_called = 1;\n\t\t\t\tif (obj->dtor) {\n\t\t\t\t\tif (handlers && !obj->handlers) {\n\t\t\t\t\t\tobj->handlers = handlers;\n\t\t\t\t\t}\n\t\t\t\t\tzend_try {\n\t\t\t\t\t\tobj->dtor(obj->object, handle TSRMLS_CC);\n\t\t\t\t\t} zend_catch {\n\t\t\t\t\t\tfailure = 1;\n\t\t\t\t\t} zend_end_try();\n\t\t\t\t}\n\t\t\t}\n\t\t\tobj = &EG(objects_store).object_buckets[handle].bucket.obj;\n\t\t\tif (obj->refcount == 1) {\n\t\t\t\tGC_REMOVE_ZOBJ_FROM_BUFFER(obj);\n\t\t\t\tif (obj->free_storage) {\n\t\t\t\t\tzend_try {\n\t\t\t\t\t\tobj->free_storage(obj->object TSRMLS_CC);\n\t\t\t\t\t} zend_catch {\n\t\t\t\t\t\tfailure = 1;\n\t\t\t\t\t} zend_end_try();\n\t\t\t\t}\n\t\t\t\tZEND_OBJECTS_STORE_ADD_TO_FREE_LIST();\n\t\t\t}\n\t\t}\n\t}\n\tobj->refcount--;\n#if ZEND_DEBUG_OBJECTS\n\tif (obj->refcount == 0) {\n\t\tfprintf(stderr, \"Deallocated object id #%d\\n\", handle);\n\t} else {\n\t\tfprintf(stderr, \"Decreased refcount of object id #%d\\n\", handle);\n\t}\n#endif\n\tif (failure) {\n\t\tzend_bailout();\n\t}\n}", "target": 1}
{"code": "static s32 adpt_i2o_quiesce_hba(adpt_hba* pHba)\n{\n\tu32 msg[4];\n\tint ret;\n\tadpt_i2o_status_get(pHba);\n\tif((pHba->status_block->iop_state != ADAPTER_STATE_READY) &&\n   \t   (pHba->status_block->iop_state != ADAPTER_STATE_OPERATIONAL)){\n\t\treturn 0;\n\t}\n\tmsg[0] = FOUR_WORD_MSG_SIZE|SGL_OFFSET_0;\n\tmsg[1] = I2O_CMD_SYS_QUIESCE<<24|HOST_TID<<12|ADAPTER_TID;\n\tmsg[2] = 0;\n\tmsg[3] = 0;\n\tif((ret = adpt_i2o_post_wait(pHba, msg, sizeof(msg), 240))) {\n\t\tprintk(KERN_INFO\"dpti%d: Unable to quiesce (status=%#x).\\n\",\n\t\t\t\tpHba->unit, -ret);\n\t} else {\n\t\tprintk(KERN_INFO\"dpti%d: Quiesced.\\n\",pHba->unit);\n\t}\n\tadpt_i2o_status_get(pHba);\n\treturn ret;\n}", "target": 1}
{"code": "void Ogg::XiphComment::parse(const ByteVector &data)\n{\n  int pos = 0;\n  int vendorLength = data.mid(0, 4).toUInt(false);\n  pos += 4;\n  d->vendorID = String(data.mid(pos, vendorLength), String::UTF8);\n  pos += vendorLength;\n  int commentFields = data.mid(pos, 4).toUInt(false);\n  pos += 4;\n  for(int i = 0; i < commentFields; i++) {\n    int commentLength = data.mid(pos, 4).toUInt(false);\n    pos += 4;\n    String comment = String(data.mid(pos, commentLength), String::UTF8);\n    pos += commentLength;\n    int commentSeparatorPosition = comment.find(\"=\");\n    String key = comment.substr(0, commentSeparatorPosition);\n    String value = comment.substr(commentSeparatorPosition + 1);\n    addField(key, value, false);\n  }\n}", "target": 1}
{"code": "my_decimal *Item_param::val_decimal(my_decimal *dec)\n{\n  switch (state) {\n  case DECIMAL_VALUE:\n    return &decimal_value;\n  case REAL_VALUE:\n    double2my_decimal(E_DEC_FATAL_ERROR, value.real, dec);\n    return dec;\n  case INT_VALUE:\n    int2my_decimal(E_DEC_FATAL_ERROR, value.integer, unsigned_flag, dec);\n    return dec;\n  case STRING_VALUE:\n  case LONG_DATA_VALUE:\n    string2my_decimal(E_DEC_FATAL_ERROR, &str_value, dec);\n    return dec;\n  case TIME_VALUE:\n  {\n    longlong i= (longlong) TIME_to_ulonglong(&value.time);\n    int2my_decimal(E_DEC_FATAL_ERROR, i, 0, dec);\n    return dec;\n  }\n  case NULL_VALUE:\n    return 0; \n  default:\n    DBUG_ASSERT(0);\n  }\n  return 0;\n}", "target": 0}
{"code": "int main()\n{\n    gdImagePtr im, clone;\n    int style[] = {0, 0, 0};\n    im = gdImageCreate(8, 8);\n    gdImageSetStyle(im, style, sizeof(style)/sizeof(style[0]));\n    clone = gdImageClone(im);\n    gdTestAssert(clone != NULL);\n    gdTestAssert(clone->styleLength == im->styleLength);\n    gdTestAssert(clone->stylePos == im->stylePos);\n    gdTestAssert(!memcmp(clone->style, im->style, sizeof(style)/sizeof(style[0])));\n    gdImageDestroy(clone);\n    gdImageDestroy(im);\n    return gdNumFailures();\n}", "target": 0}
{"code": "static inline int r_sys_mkdirp(char *dir) {\n\tint ret = 1;\n\tconst char slash = DIRSEP;\n\tchar *path = dir;\n\tchar *ptr = path;\n\tif (*ptr == slash) {\n\t\tptr++;\n\t}\n#if __SDB_WINDOWS__\n\tchar *p = strstr (ptr, \":\\\\\");\n\tif (p) {\n\t\tptr = p + 2;\n\t}\n#endif\n\twhile ((ptr = strchr (ptr, slash))) {\n\t\t*ptr = 0;\n\t\tif (!r_sys_mkdir (path) && r_sys_mkdir_failed ()) {\n\t\t\teprintf (\"r_sys_mkdirp: fail '%s' of '%s'\\n\", path, dir);\n\t\t\t*ptr = slash;\n\t\t\treturn 0;\n\t\t}\n\t\t*ptr = slash;\n\t\tptr++;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "node_new(void)\n{\n  Node* node;\n  node = (Node* )xmalloc(sizeof(Node));\n  xmemset(node, 0, sizeof(*node));\n#ifdef DEBUG_NODE_FREE\n  fprintf(stderr, \"node_new: %p\\n\", node);\n#endif\n  return node;\n}", "target": 0}
{"code": "int BUFFER_append(BUFFER_HANDLE handle1, BUFFER_HANDLE handle2)\n{\n    int result;\n    if ( (handle1 == NULL) || (handle2 == NULL) || (handle1 == handle2) )\n    {\n        result = MU_FAILURE;\n    }\n    else\n    {\n        BUFFER* b1 = (BUFFER*)handle1;\n        BUFFER* b2 = (BUFFER*)handle2;\n        if (b1->buffer == NULL)\n        {\n            result = MU_FAILURE;\n        }\n        else if (b2->buffer == NULL)\n        {\n            result = MU_FAILURE;\n        }\n        else\n        {\n            if (b2->size ==0)\n            {\n                result = 0;\n            }\n            else\n            {\n                unsigned char* temp = (unsigned char*)realloc(b1->buffer, b1->size + b2->size);\n                if (temp == NULL)\n                {\n                    LogError(\"Failure: allocating temp buffer.\");\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    b1->buffer = temp;\n                    (void)memcpy(&b1->buffer[b1->size], b2->buffer, b2->size);\n                    b1->size += b2->size;\n                    result = 0;\n                }\n            }\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "void RenderView::OnDownloadFavIcon(int id,\n                                   const GURL& image_url,\n                                   int image_size) {\n  bool data_image_failed = false;\n  if (image_url.SchemeIs(\"data\")) {\n    SkBitmap data_image = ImageFromDataUrl(image_url);\n    data_image_failed = data_image.empty();\n    if (!data_image_failed) {\n      Send(new ViewHostMsg_DidDownloadFavIcon(routing_id_, id, image_url, false,\n                                              data_image));\n    }\n  }\n  if (data_image_failed ||\n      !DownloadImage(id, image_url, image_size)) {\n    Send(new ViewHostMsg_DidDownloadFavIcon(routing_id_, id, image_url, true,\n                                            SkBitmap()));\n  }\n}", "target": 0}
{"code": "flatpak_print_escaped_string (const char        *s,\n                              FlatpakEscapeFlags flags)\n{\n  g_autofree char *escaped = flatpak_escape_string (s, flags);\n  g_print (\"%s\", escaped);\n}", "target": 0}
{"code": "static int fr_add_pvc(struct net_device *frad, unsigned int dlci, int type)\n{\n\thdlc_device *hdlc = dev_to_hdlc(frad);\n\tpvc_device *pvc;\n\tstruct net_device *dev;\n\tint used;\n\tif ((pvc = add_pvc(frad, dlci)) == NULL) {\n\t\tnetdev_warn(frad, \"Memory squeeze on fr_add_pvc()\\n\");\n\t\treturn -ENOBUFS;\n\t}\n\tif (*get_dev_p(pvc, type))\n\t\treturn -EEXIST;\n\tused = pvc_is_used(pvc);\n\tif (type == ARPHRD_ETHER)\n\t\tdev = alloc_netdev(0, \"pvceth%d\", ether_setup);\n\telse\n\t\tdev = alloc_netdev(0, \"pvc%d\", pvc_setup);\n\tif (!dev) {\n\t\tnetdev_warn(frad, \"Memory squeeze on fr_pvc()\\n\");\n\t\tdelete_unused_pvcs(hdlc);\n\t\treturn -ENOBUFS;\n\t}\n\tif (type == ARPHRD_ETHER)\n\t\trandom_ether_addr(dev->dev_addr);\n\telse {\n\t\t*(__be16*)dev->dev_addr = htons(dlci);\n\t\tdlci_to_q922(dev->broadcast, dlci);\n\t}\n\tdev->netdev_ops = &pvc_ops;\n\tdev->mtu = HDLC_MAX_MTU;\n\tdev->tx_queue_len = 0;\n\tdev->ml_priv = pvc;\n\tif (register_netdevice(dev) != 0) {\n\t\tfree_netdev(dev);\n\t\tdelete_unused_pvcs(hdlc);\n\t\treturn -EIO;\n\t}\n\tdev->destructor = free_netdev;\n\t*get_dev_p(pvc, type) = dev;\n\tif (!used) {\n\t\tstate(hdlc)->dce_changed = 1;\n\t\tstate(hdlc)->dce_pvc_count++;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "    void cleanup() { delete m_server; }", "target": 0}
{"code": "sixel_allocator_calloc(\n    sixel_allocator_t    *allocator,  \n    size_t               nelm,        \n    size_t               elsize)      \n{\n    size_t n;\n    assert(allocator);\n    assert(allocator->fn_calloc);\n    n = nelm * elsize;\n    if (n == 0) {\n        sixel_helper_set_additional_message(\n            \"sixel_allocator_malloc: called with n == 0\");\n        return NULL;\n    }\n    if (n > SIXEL_ALLOCATE_BYTES_MAX) {\n        return NULL;\n    }\n    return allocator->fn_calloc(nelm, elsize);\n}", "target": 0}
{"code": "static int em_fxsave(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct fxregs_state fx_state;\n\tsize_t size;\n\tint rc;\n\trc = check_fxsr(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tctxt->ops->get_fpu(ctxt);\n\trc = asm_safe(\"fxsave %[fx]\", , [fx] \"+m\"(fx_state));\n\tctxt->ops->put_fpu(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tif (ctxt->ops->get_cr(ctxt, 4) & X86_CR4_OSFXSR)\n\t\tsize = offsetof(struct fxregs_state, xmm_space[8 * 16/4]);\n\telse\n\t\tsize = offsetof(struct fxregs_state, xmm_space[0]);\n\treturn segmented_write(ctxt, ctxt->memop.addr.mem, &fx_state, size);\n}", "target": 1}
{"code": "static MYSQL *db_connect(char *host, char *database,\n                         char *user, char *passwd)\n{\n  MYSQL *mysql;\n  if (verbose)\n    fprintf(stdout, \"Connecting to %s\\n\", host ? host : \"localhost\");\n  if (!(mysql= mysql_init(NULL)))\n    return 0;\n  if (opt_compress)\n    mysql_options(mysql,MYSQL_OPT_COMPRESS,NullS);\n  if (opt_local_file)\n    mysql_options(mysql,MYSQL_OPT_LOCAL_INFILE,\n\t\t  (char*) &opt_local_file);\n#ifdef HAVE_OPENSSL\n  if (opt_use_ssl)\n  {\n    mysql_ssl_set(mysql, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n\t\t  opt_ssl_capath, opt_ssl_cipher);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRL, opt_ssl_crl);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);\n  }\n  mysql_options(mysql,MYSQL_OPT_SSL_VERIFY_SERVER_CERT,\n                (char*)&opt_ssl_verify_server_cert);\n#endif\n  if (opt_protocol)\n    mysql_options(mysql,MYSQL_OPT_PROTOCOL,(char*)&opt_protocol);\n  if (opt_bind_addr)\n    mysql_options(mysql,MYSQL_OPT_BIND,opt_bind_addr);\n#if defined (_WIN32) && !defined (EMBEDDED_LIBRARY)\n  if (shared_memory_base_name)\n    mysql_options(mysql,MYSQL_SHARED_MEMORY_BASE_NAME,shared_memory_base_name);\n#endif\n  if (opt_plugin_dir && *opt_plugin_dir)\n    mysql_options(mysql, MYSQL_PLUGIN_DIR, opt_plugin_dir);\n  if (opt_default_auth && *opt_default_auth)\n    mysql_options(mysql, MYSQL_DEFAULT_AUTH, opt_default_auth);\n  mysql_options(mysql, MYSQL_SET_CHARSET_NAME, default_charset);\n  mysql_options(mysql, MYSQL_OPT_CONNECT_ATTR_RESET, 0);\n  mysql_options4(mysql, MYSQL_OPT_CONNECT_ATTR_ADD,\n                 \"program_name\", \"mysqlimport\");\n  if (!(mysql_real_connect(mysql,host,user,passwd,\n                           database,opt_mysql_port,opt_mysql_unix_port,\n                           0)))\n  {\n    ignore_errors=0;\t  \n    db_error(mysql);\n  }\n  mysql->reconnect= 0;\n  if (verbose)\n    fprintf(stdout, \"Selecting database %s\\n\", database);\n  if (mysql_select_db(mysql, database))\n  {\n    ignore_errors=0;\n    db_error(mysql);\n  }\n  return mysql;\n}", "target": 1}
{"code": "PrimitiveStatus TrustedPrimitives::UntrustedCall(uint64_t untrusted_selector,\n                                                 MessageWriter *input,\n                                                 MessageReader *output) {\n  int ret;\n  UntrustedCacheMalloc *untrusted_cache = UntrustedCacheMalloc::Instance();\n  SgxParams *const sgx_params =\n      reinterpret_cast<SgxParams *>(untrusted_cache->Malloc(sizeof(SgxParams)));\n  if (!TrustedPrimitives::IsOutsideEnclave(sgx_params, sizeof(SgxParams))) {\n    TrustedPrimitives::BestEffortAbort(\n        \"UntrustedCall: sgx_param should be in untrusted memory\");\n  }\n  Cleanup clean_up(\n      [sgx_params, untrusted_cache] { untrusted_cache->Free(sgx_params); });\n  sgx_params->input_size = 0;\n  sgx_params->input = nullptr;\n  if (input) {\n    sgx_params->input_size = input->MessageSize();\n    if (sgx_params->input_size > 0) {\n      sgx_params->input = untrusted_cache->Malloc(sgx_params->input_size);\n      if (!TrustedPrimitives::IsOutsideEnclave(sgx_params->input,\n                                               sgx_params->input_size)) {\n        TrustedPrimitives::BestEffortAbort(\n            \"UntrustedCall: sgx_param input should be in untrusted memory\");\n      }\n      input->Serialize(const_cast<void *>(sgx_params->input));\n    }\n  }\n  sgx_params->output_size = 0;\n  sgx_params->output = nullptr;\n  CHECK_OCALL(\n      ocall_dispatch_untrusted_call(&ret, untrusted_selector, sgx_params));\n  if (sgx_params->input) {\n    untrusted_cache->Free(const_cast<void *>(sgx_params->input));\n  }\n  if (!TrustedPrimitives::IsOutsideEnclave(sgx_params->output,\n                                           sgx_params->output_size)) {\n    TrustedPrimitives::BestEffortAbort(\n        \"UntrustedCall: sgx_param output should be in untrusted memory\");\n  }\n  if (sgx_params->output) {\n    output->Deserialize(sgx_params->output, sgx_params->output_size);\n    TrustedPrimitives::UntrustedLocalFree(sgx_params->output);\n  }\n  return PrimitiveStatus::OkStatus();\n}", "target": 1}
{"code": "void Bezier(double x1,double y1,double x2,double y2,double x3,double y3) {\n    outpos +=\n    sprintf(outpos,\"\\n %12.3f %12.3f %12.3f %12.3f %12.3f %12.3f c\",x1,y1,x2,y2,x3,y3);\n}", "target": 1}
{"code": "static int nft_verdict_init(const struct nft_ctx *ctx, struct nft_data *data,\n\t\t\t    struct nft_data_desc *desc, const struct nlattr *nla)\n{\n\tu8 genmask = nft_genmask_next(ctx->net);\n\tstruct nlattr *tb[NFTA_VERDICT_MAX + 1];\n\tstruct nft_chain *chain;\n\tint err;\n\terr = nla_parse_nested_deprecated(tb, NFTA_VERDICT_MAX, nla,\n\t\t\t\t\t  nft_verdict_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\tif (!tb[NFTA_VERDICT_CODE])\n\t\treturn -EINVAL;\n\tdata->verdict.code = ntohl(nla_get_be32(tb[NFTA_VERDICT_CODE]));\n\tswitch (data->verdict.code) {\n\tdefault:\n\t\tswitch (data->verdict.code & NF_VERDICT_MASK) {\n\t\tcase NF_ACCEPT:\n\t\tcase NF_DROP:\n\t\tcase NF_QUEUE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfallthrough;\n\tcase NFT_CONTINUE:\n\tcase NFT_BREAK:\n\tcase NFT_RETURN:\n\t\tbreak;\n\tcase NFT_JUMP:\n\tcase NFT_GOTO:\n\t\tif (tb[NFTA_VERDICT_CHAIN]) {\n\t\t\tchain = nft_chain_lookup(ctx->net, ctx->table,\n\t\t\t\t\t\t tb[NFTA_VERDICT_CHAIN],\n\t\t\t\t\t\t genmask);\n\t\t} else if (tb[NFTA_VERDICT_CHAIN_ID]) {\n\t\t\tchain = nft_chain_lookup_byid(ctx->net, ctx->table,\n\t\t\t\t\t\t      tb[NFTA_VERDICT_CHAIN_ID]);\n\t\t\tif (IS_ERR(chain))\n\t\t\t\treturn PTR_ERR(chain);\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (IS_ERR(chain))\n\t\t\treturn PTR_ERR(chain);\n\t\tif (nft_is_base_chain(chain))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (nft_chain_is_bound(chain))\n\t\t\treturn -EINVAL;\n\t\tif (desc->flags & NFT_DATA_DESC_SETELEM &&\n\t\t    chain->flags & NFT_CHAIN_BINDING)\n\t\t\treturn -EINVAL;\n\t\tchain->use++;\n\t\tdata->verdict.chain = chain;\n\t\tbreak;\n\t}\n\tdesc->len = sizeof(data->verdict);\n\treturn 0;\n}", "target": 0}
{"code": "bool ExtractUnixLink30(CommandData *Cmd,ComprDataIO &DataIO,Archive &Arc,const wchar *LinkName)\n{\n  char Target[NM];\n  if (IsLink(Arc.FileHead.FileAttr))\n  {\n    size_t DataSize=(size_t)Arc.FileHead.PackSize;\n    if (DataSize>ASIZE(Target)-1)\n      return false;\n    if ((size_t)DataIO.UnpRead((byte *)Target,DataSize)!=DataSize)\n      return false;\n    Target[DataSize]=0;\n    DataIO.UnpHash.Init(Arc.FileHead.FileHash.Type,1);\n    DataIO.UnpHash.Update(Target,strlen(Target));\n    DataIO.UnpHash.Result(&Arc.FileHead.FileHash);\n    if (!DataIO.UnpHash.Cmp(&Arc.FileHead.FileHash,Arc.FileHead.UseHashKey ? Arc.FileHead.HashKey:NULL))\n      return true;\n    wchar TargetW[NM];\n    if (!SafeCharToWide(Target,TargetW,ASIZE(TargetW)))\n      return false;\n    if (!Cmd->AbsoluteLinks && (IsFullPath(TargetW) ||\n        !IsRelativeSymlinkSafe(Cmd,Arc.FileHead.FileName,LinkName,TargetW)))\n      return false;\n    return UnixSymlink(Cmd,Target,LinkName,&Arc.FileHead.mtime,&Arc.FileHead.atime);\n  }\n  return false;\n}", "target": 1}
{"code": "struct bpf_prog *bpf_patch_insn_single(struct bpf_prog *prog, u32 off,\n\t\t\t\t       const struct bpf_insn *patch, u32 len)\n{\n\tu32 insn_adj_cnt, insn_rest, insn_delta = len - 1;\n\tstruct bpf_prog *prog_adj;\n\tif (insn_delta == 0) {\n\t\tmemcpy(prog->insnsi + off, patch, sizeof(*patch));\n\t\treturn prog;\n\t}\n\tinsn_adj_cnt = prog->len + insn_delta;\n\tprog_adj = bpf_prog_realloc(prog, bpf_prog_size(insn_adj_cnt),\n\t\t\t\t    GFP_USER);\n\tif (!prog_adj)\n\t\treturn NULL;\n\tprog_adj->len = insn_adj_cnt;\n\tinsn_rest = insn_adj_cnt - off - len;\n\tmemmove(prog_adj->insnsi + off + len, prog_adj->insnsi + off + 1,\n\t\tsizeof(*patch) * insn_rest);\n\tmemcpy(prog_adj->insnsi + off, patch, sizeof(*patch) * len);\n\tbpf_adj_branches(prog_adj, off, insn_delta);\n\treturn prog_adj;\n}", "target": 1}
{"code": "spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n\t\t       gss_ctx_id_t context_handle,\n\t\t       gss_buffer_t input_message_buffer,\n\t\t       gss_buffer_t input_assoc_buffer,\n\t\t       gss_buffer_t output_payload_buffer,\n\t\t       int *conf_state,\n\t\t       gss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tret = gss_unwrap_aead(minor_status,\n\t\t\t      context_handle,\n\t\t\t      input_message_buffer,\n\t\t\t      input_assoc_buffer,\n\t\t\t      output_payload_buffer,\n\t\t\t      conf_state,\n\t\t\t      qop_state);\n\treturn (ret);\n}", "target": 1}
{"code": "static int empty_write_end(struct page *page, unsigned from,\n\t\t\t   unsigned to, int mode)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct buffer_head *bh;\n\tunsigned offset, blksize = 1 << inode->i_blkbits;\n\tpgoff_t end_index = i_size_read(inode) >> PAGE_CACHE_SHIFT;\n\tzero_user(page, from, to-from);\n\tmark_page_accessed(page);\n\tif (page->index < end_index || !(mode & FALLOC_FL_KEEP_SIZE)) {\n\t\tif (!gfs2_is_writeback(ip))\n\t\t\tgfs2_page_add_databufs(ip, page, from, to);\n\t\tblock_commit_write(page, from, to);\n\t\treturn 0;\n\t}\n\toffset = 0;\n\tbh = page_buffers(page);\n\twhile (offset < to) {\n\t\tif (offset >= from) {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tclear_buffer_new(bh);\n\t\t\twrite_dirty_buffer(bh, WRITE);\n\t\t}\n\t\toffset += blksize;\n\t\tbh = bh->b_this_page;\n\t}\n\toffset = 0;\n\tbh = page_buffers(page);\n\twhile (offset < to) {\n\t\tif (offset >= from) {\n\t\t\twait_on_buffer(bh);\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\treturn -EIO;\n\t\t}\n\t\toffset += blksize;\n\t\tbh = bh->b_this_page;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "    void Xmpdatum::setValue(const Value* pValue)\n    {\n        p_->value_.reset();\n        if (pValue) p_->value_ = pValue->clone();\n    }", "target": 0}
{"code": "size_t compile_tree(struct filter_op **fop)\n{\n   int i = 1;\n   struct filter_op *array = NULL;\n   struct unfold_elm *ue;\n   BUG_IF(tree_root == NULL);\n   fprintf(stdout, \" Unfolding the meta-tree \");\n   fflush(stdout);\n   unfold_blk(&tree_root);\n   fprintf(stdout, \" done.\\n\\n\");\n   labels_to_offsets();\n   TAILQ_FOREACH(ue, &unfolded_tree, next) {\n      if (ue->label == 0) {\n         SAFE_REALLOC(array, i * sizeof(struct filter_op));\n         memcpy(&array[i - 1], &ue->fop, sizeof(struct filter_op));\n         i++;\n      }\n   }\n   SAFE_REALLOC(array, i * sizeof(struct filter_op));\n   array[i - 1].opcode = FOP_EXIT;\n   *fop = array;\n   return (i);\n}", "target": 1}
{"code": "std::string queueloader::get_filename(const std::string& str) {\n\tstd::string fn = ctrl->get_dlpath();\n\tif (fn[fn.length()-1] != NEWSBEUTER_PATH_SEP[0])\n\t\tfn.append(NEWSBEUTER_PATH_SEP);\n\tchar buf[1024];\n\tsnprintf(buf, sizeof(buf), \"%s\", str.c_str());\n\tchar * base = basename(buf);\n\tif (!base || strlen(base) == 0) {\n\t\tchar lbuf[128];\n\t\ttime_t t = time(nullptr);\n\t\tstrftime(lbuf, sizeof(lbuf), \"%Y-%b-%d-%H%M%S.unknown\", localtime(&t));\n\t\tfn.append(lbuf);\n\t} else {\n\t\tfn.append(base);\n\t}\n\treturn fn;\n}", "target": 1}
{"code": "ScopedDefaultGLContext::ScopedDefaultGLContext(GLES2DecoderImpl* decoder)\n    : decoder_(decoder) {\n  decoder_->default_context_->MakeCurrent();\n}", "target": 0}
{"code": "RecordConvertRangesToIntervals(SetInfoPtr psi,\n                               xRecordRange * pRanges,\n                               int nRanges,\n                               int byteoffset,\n                               SetInfoPtr pExtSetInfo, int *pnExtSetInfo)\n{\n    int i;\n    CARD8 *pCARD8;\n    int first, last;\n    int err;\n    for (i = 0; i < nRanges; i++, pRanges++) {\n        pCARD8 = ((CARD8 *) pRanges) + byteoffset;\n        first = pCARD8[0];\n        last = pCARD8[1];\n        if (first || last) {\n            if (!psi->intervals) {\n                err = RecordAllocIntervals(psi, 2 * (nRanges - i));\n                if (err != Success)\n                    return err;\n            }\n            psi->intervals[psi->nintervals].first = first;\n            psi->intervals[psi->nintervals].last = last;\n            psi->nintervals++;\n            assert(psi->nintervals <= psi->size);\n            if (pExtSetInfo) {\n                SetInfoPtr pesi = pExtSetInfo;\n                CARD16 *pCARD16 = (CARD16 *) (pCARD8 + 2);\n                int j;\n                for (j = 0; j < *pnExtSetInfo; j++, pesi++) {\n                    if ((first == pesi->first) && (last == pesi->last))\n                        break;\n                }\n                if (j == *pnExtSetInfo) {\n                    err = RecordAllocIntervals(pesi, 2 * (nRanges - i));\n                    if (err != Success)\n                        return err;\n                    pesi->first = first;\n                    pesi->last = last;\n                    (*pnExtSetInfo)++;\n                }\n                pesi->intervals[pesi->nintervals].first = pCARD16[0];\n                pesi->intervals[pesi->nintervals].last = pCARD16[1];\n                pesi->nintervals++;\n                assert(pesi->nintervals <= pesi->size);\n            }\n        }\n    }\n    return Success;\n}                               ", "target": 0}
{"code": "void invalidFunctionWasCalled() {}", "target": 0}
{"code": "  void ValidateInputs(OpKernelContext* ctx,\n                      const CSRSparseMatrix& sparse_matrix,\n                      const Tensor& permutation_indices, int* batch_size,\n                      int64* num_rows) {\n    OP_REQUIRES(ctx, sparse_matrix.dtype() == DataTypeToEnum<T>::value,\n                errors::InvalidArgument(\n                    \"Asked for a CSRSparseMatrix of type \",\n                    DataTypeString(DataTypeToEnum<T>::value),\n                    \" but saw dtype: \", DataTypeString(sparse_matrix.dtype())));\n    const Tensor& dense_shape = sparse_matrix.dense_shape();\n    const int rank = dense_shape.dim_size(0);\n    OP_REQUIRES(ctx, rank == 2 || rank == 3,\n                errors::InvalidArgument(\"sparse matrix must have rank 2 or 3; \",\n                                        \"but dense_shape has size \", rank));\n    const int row_dim = (rank == 2) ? 0 : 1;\n    auto dense_shape_vec = dense_shape.vec<int64>();\n    *num_rows = dense_shape_vec(row_dim);\n    const int64 num_cols = dense_shape_vec(row_dim + 1);\n    OP_REQUIRES(ctx, *num_rows == num_cols,\n                errors::InvalidArgument(\"sparse matrix must be square; got: \",\n                                        *num_rows, \" != \", num_cols));\n    const TensorShape& perm_shape = permutation_indices.shape();\n    OP_REQUIRES(\n        ctx, perm_shape.dims() + 1 == rank,\n        errors::InvalidArgument(\n            \"sparse matrix must have the same rank as permutation; got: \", rank,\n            \" != \", perm_shape.dims(), \" + 1.\"));\n    OP_REQUIRES(\n        ctx, perm_shape.dim_size(rank - 2) == *num_rows,\n        errors::InvalidArgument(\n            \"permutation must have the same number of elements in each batch \"\n            \"as the number of rows in sparse matrix; got: \",\n            perm_shape.dim_size(rank - 2), \" != \", *num_rows));\n    *batch_size = sparse_matrix.batch_size();\n    if (*batch_size > 1) {\n      OP_REQUIRES(\n          ctx, perm_shape.dim_size(0) == *batch_size,\n          errors::InvalidArgument(\"permutation must have the same batch size \"\n                                  \"as sparse matrix; got: \",\n                                  perm_shape.dim_size(0), \" != \", *batch_size));\n    }\n  }", "target": 1}
{"code": "pf_remove_state(struct pf_state *st)\n{\n\tPF_ASSERT_LOCKED();\n\tif (st->timeout == PFTM_UNLINKED)\n\t\treturn;\n\tst->timeout = PFTM_UNLINKED;\n\tpf_postprocess_addr(st);\n\tif (st->src.state == PF_TCPS_PROXY_DST) {\n\t\tpf_send_tcp(st->rule.ptr, st->key[PF_SK_WIRE]->af,\n\t\t    &st->key[PF_SK_WIRE]->addr[1],\n\t\t    &st->key[PF_SK_WIRE]->addr[0],\n\t\t    st->key[PF_SK_WIRE]->port[1],\n\t\t    st->key[PF_SK_WIRE]->port[0],\n\t\t    st->src.seqhi, st->src.seqlo + 1,\n\t\t    TH_RST|TH_ACK, 0, 0, 0, 1, st->tag,\n\t\t    st->key[PF_SK_WIRE]->rdomain);\n\t}\n\tif (st->key[PF_SK_STACK]->proto == IPPROTO_TCP)\n\t\tpf_set_protostate(st, PF_PEER_BOTH, TCPS_CLOSED);\n\tRBT_REMOVE(pf_state_tree_id, &tree_id, st);\n#if NPFLOW > 0\n\tif (st->state_flags & PFSTATE_PFLOW)\n\t\texport_pflow(st);\n#endif\t\n#if NPFSYNC > 0\n\tpfsync_delete_state(st);\n#endif\t\n\tpf_src_tree_remove_state(st);\n\tpf_detach_state(st);\n}", "target": 1}
{"code": "GIOChannel *net_connect_ip_ssl(IPADDR *ip, int port, IPADDR *my_ip, const char *cert, const char *pkey, const char *cafile, const char *capath, gboolean verify)\n{\n\tGIOChannel *handle, *ssl_handle;\n\thandle = net_connect_ip(ip, port, my_ip);\n\tif (handle == NULL)\n\t\treturn NULL;\n\tssl_handle  = irssi_ssl_get_iochannel(handle, cert, pkey, cafile, capath, verify);\n\tif (ssl_handle == NULL)\n\t\tg_io_channel_unref(handle);\n\treturn ssl_handle;\n}", "target": 1}
{"code": "GF_Err gf_isom_last_error(GF_ISOFile *the_file)\n{\n\tif (!the_file) return MP4_API_IO_Err;\n\treturn the_file->LastError;\n}", "target": 0}
{"code": "std::string encodeBase64(const std::string& input) {\n  using namespace boost::archive::iterators;\n  using b64it = base64_from_binary<transform_width<const char*, 6, 8>>;\n  auto data = input.data();\n  std::string encoded(b64it(data), b64it(data + (input.length())));\n  encoded.append((3 - (input.length() % 3)) % 3, '=');\n  return encoded;\n}", "target": 1}
{"code": "void CoreUserInputHandler::handleMsg(const BufferInfo &bufferInfo, const QString &msg)\n{\n    Q_UNUSED(bufferInfo);\n    if (!msg.contains(' '))\n        return;\n    QString target = msg.section(' ', 0, 0);\n    QByteArray encMsg = userEncode(target, msg.section(' ', 1));\n#ifdef HAVE_QCA2\n    putPrivmsg(serverEncode(target), encMsg, network()->cipher(target));\n#else\n    putPrivmsg(serverEncode(target), encMsg);\n#endif\n}", "target": 1}
{"code": "static int secure_decrypt(void *data, unsigned int data_length, int is_signed)\n{\n\tat91_aes_key_size_t key_size;\n\tunsigned int computed_cmac[AT91_AES_BLOCK_SIZE_WORD];\n\tunsigned int fixed_length;\n\tconst unsigned int *cmac;\n\tint rc = -1;\n#if defined(CONFIG_AES_KEY_SIZE_128)\n\tkey_size = AT91_AES_KEY_SIZE_128;\n#elif defined(CONFIG_AES_KEY_SIZE_192)\n\tkey_size = AT91_AES_KEY_SIZE_192;\n#elif defined(CONFIG_AES_KEY_SIZE_256)\n\tkey_size = AT91_AES_KEY_SIZE_256;\n#else\n#error \"bad AES key size\"\n#endif\n\tat91_aes_init();\n\tif (is_signed) {\n\t\tif (at91_aes_cmac(data_length, data, computed_cmac,\n\t\t\t\t  key_size, cmac_key))\n\t\t\tgoto exit;\n\t\tfixed_length = at91_aes_roundup(data_length);\n\t\tcmac = (const unsigned int *)((char *)data + fixed_length);\n\t\tif (!consttime_memequal(cmac, computed_cmac, AT91_AES_BLOCK_SIZE_BYTE))\n\t\t\tgoto exit;\n\t}\n\tif (at91_aes_cbc(data_length, data, data, 0,\n\t\t\t key_size, cipher_key, iv))\n\t\tgoto exit;\n\trc = 0;\nexit:\n\tat91_aes_cleanup();\n\treturn rc;\n}", "target": 0}
{"code": "R_API int r_socket_read(RSocket *s, unsigned char *buf, int len) {\n\tif (!s) {\n\t\treturn -1;\n\t}\n#if HAVE_LIB_SSL\n\tif (s->is_ssl) {\n\t\tif (s->bio) {\n\t\t\treturn BIO_read (s->bio, buf, len);\n\t\t}\n\t\treturn SSL_read (s->sfd, buf, len);\n\t}\n#endif\n#if __WINDOWS__\nrep:\n\t{\n\tint ret = recv (s->fd, (void *)buf, len, 0);\n\tif (ret == -1) {\n\t\tgoto rep;\n\t}\n\treturn ret;\n\t}\n#else\n\tint r = recv (s->fd, buf, len, 0);\n\tD { eprintf (\"READ \"); int i; for (i = 0; i<len; i++) { eprintf (\"%02x \", buf[i]); } eprintf (\"\\n\"); }\n\treturn r;\n#endif\n}", "target": 1}
{"code": "void sigsegvHandler(int sig, siginfo_t *info, void *secret) {\n    UNUSED(secret);\n    UNUSED(info);\n    bugReportStart();\n    serverLog(LL_WARNING,\n        \"Redis %s crashed by signal: %d, si_code: %d\", REDIS_VERSION, sig, info->si_code);\n    if (sig == SIGSEGV || sig == SIGBUS) {\n        serverLog(LL_WARNING,\n        \"Accessing address: %p\", (void*)info->si_addr);\n    }\n    if (info->si_code == SI_USER && info->si_pid != -1) {\n        serverLog(LL_WARNING, \"Killed by PID: %ld, UID: %d\", (long) info->si_pid, info->si_uid);\n    }\n#ifdef HAVE_BACKTRACE\n    ucontext_t *uc = (ucontext_t*) secret;\n    void *eip = getMcontextEip(uc);\n    if (eip != NULL) {\n        serverLog(LL_WARNING,\n        \"Crashed running the instruction at: %p\", eip);\n    }\n    logStackTrace(getMcontextEip(uc), 1);\n    logRegisters(uc);\n#endif\n    printCrashReport();\n#ifdef HAVE_BACKTRACE\n    if (eip != NULL)\n        dumpCodeAroundEIP(eip);\n#endif\n    bugReportEnd(1, sig);\n}", "target": 1}
{"code": "static void check_file(char *basename)\n{\n    gdImagePtr im;\n    char *buffer;\n    size_t size;\n    size = read_test_file(&buffer, basename);\n    im = gdImageCreateFromTgaPtr(size, (void *) buffer);\n    gdTestAssert(im == NULL);\n    free(buffer);\n}", "target": 0}
{"code": "    static CImg<T> get_load_camera(const unsigned int camera_index=0, const unsigned int skip_frames=0,\n                                   const bool release_camera=true,\n                                   const unsigned int capture_width=0, const unsigned int capture_height=0) {\n      return CImg<T>().load_camera(camera_index,skip_frames,release_camera,capture_width,capture_height);", "target": 0}
{"code": "usm_free_usmStateReference(void *old)\n{\n    struct usmStateReference *old_ref = (struct usmStateReference *) old;\n    if (old_ref) {\n        if (old_ref->usr_name_length)\n            SNMP_FREE(old_ref->usr_name);\n        if (old_ref->usr_engine_id_length)\n            SNMP_FREE(old_ref->usr_engine_id);\n        if (old_ref->usr_auth_protocol_length)\n            SNMP_FREE(old_ref->usr_auth_protocol);\n        if (old_ref->usr_priv_protocol_length)\n            SNMP_FREE(old_ref->usr_priv_protocol);\n        if (old_ref->usr_auth_key_length && old_ref->usr_auth_key) {\n            SNMP_ZERO(old_ref->usr_auth_key, old_ref->usr_auth_key_length);\n            SNMP_FREE(old_ref->usr_auth_key);\n        }\n        if (old_ref->usr_priv_key_length && old_ref->usr_priv_key) {\n            SNMP_ZERO(old_ref->usr_priv_key, old_ref->usr_priv_key_length);\n            SNMP_FREE(old_ref->usr_priv_key);\n        }\n        SNMP_ZERO(old_ref, sizeof(*old_ref));\n        SNMP_FREE(old_ref);\n    }\n}                               ", "target": 1}
{"code": "get_strings_2_svc(gstrings_arg *arg, struct svc_req *rqstp)\n{\n    static gstrings_ret             ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_gstrings_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (! cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ) &&\n        (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                        rqst2name(rqstp),\n                                                        ACL_INQUIRE,\n                                                        arg->princ,\n                                                        NULL))) {\n        ret.code = KADM5_AUTH_GET;\n        log_unauth(\"kadm5_get_strings\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_get_strings((void *)handle, arg->princ, &ret.strings,\n                                     &ret.count);\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_get_strings\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "int pgpPrtParams(const uint8_t * pkts, size_t pktlen, unsigned int pkttype,\n\t\t pgpDigParams * ret)\n{\n    const uint8_t *p = pkts;\n    const uint8_t *pend = pkts + pktlen;\n    pgpDigParams digp = NULL;\n    struct pgpPkt pkt;\n    int rc = -1; \n    while (p < pend) {\n\tif (decodePkt(p, (pend - p), &pkt))\n\t    break;\n\tif (digp == NULL) {\n\t    if (pkttype && pkt.tag != pkttype) {\n\t\tbreak;\n\t    } else {\n\t\tdigp = pgpDigParamsNew(pkt.tag);\n\t    }\n\t}\n\tif (pgpPrtPkt(&pkt, digp))\n\t    break;\n\tp += (pkt.body - pkt.head) + pkt.blen;\n\tif (pkttype == PGPTAG_SIGNATURE)\n\t    break;\n    }\n    rc = (digp && (p == pend)) ? 0 : -1;\n    if (ret && rc == 0) {\n\t*ret = digp;\n    } else {\n\tpgpDigParamsFree(digp);\n    }\n    return rc;\n}", "target": 1}
{"code": "static ssize_t fuse_dev_splice_write(struct pipe_inode_info *pipe,\n\t\t\t\t     struct file *out, loff_t *ppos,\n\t\t\t\t     size_t len, unsigned int flags)\n{\n\tunsigned nbuf;\n\tunsigned idx;\n\tstruct pipe_buffer *bufs;\n\tstruct fuse_copy_state cs;\n\tstruct fuse_dev *fud;\n\tsize_t rem;\n\tssize_t ret;\n\tfud = fuse_get_dev(out);\n\tif (!fud)\n\t\treturn -EPERM;\n\tpipe_lock(pipe);\n\tbufs = kvmalloc_array(pipe->nrbufs, sizeof(struct pipe_buffer),\n\t\t\t      GFP_KERNEL);\n\tif (!bufs) {\n\t\tpipe_unlock(pipe);\n\t\treturn -ENOMEM;\n\t}\n\tnbuf = 0;\n\trem = 0;\n\tfor (idx = 0; idx < pipe->nrbufs && rem < len; idx++)\n\t\trem += pipe->bufs[(pipe->curbuf + idx) & (pipe->buffers - 1)].len;\n\tret = -EINVAL;\n\tif (rem < len) {\n\t\tpipe_unlock(pipe);\n\t\tgoto out;\n\t}\n\trem = len;\n\twhile (rem) {\n\t\tstruct pipe_buffer *ibuf;\n\t\tstruct pipe_buffer *obuf;\n\t\tBUG_ON(nbuf >= pipe->buffers);\n\t\tBUG_ON(!pipe->nrbufs);\n\t\tibuf = &pipe->bufs[pipe->curbuf];\n\t\tobuf = &bufs[nbuf];\n\t\tif (rem >= ibuf->len) {\n\t\t\t*obuf = *ibuf;\n\t\t\tibuf->ops = NULL;\n\t\t\tpipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);\n\t\t\tpipe->nrbufs--;\n\t\t} else {\n\t\t\tpipe_buf_get(pipe, ibuf);\n\t\t\t*obuf = *ibuf;\n\t\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\t\t\tobuf->len = rem;\n\t\t\tibuf->offset += obuf->len;\n\t\t\tibuf->len -= obuf->len;\n\t\t}\n\t\tnbuf++;\n\t\trem -= obuf->len;\n\t}\n\tpipe_unlock(pipe);\n\tfuse_copy_init(&cs, 0, NULL);\n\tcs.pipebufs = bufs;\n\tcs.nr_segs = nbuf;\n\tcs.pipe = pipe;\n\tif (flags & SPLICE_F_MOVE)\n\t\tcs.move_pages = 1;\n\tret = fuse_dev_do_write(fud, &cs, len);\n\tpipe_lock(pipe);\n\tfor (idx = 0; idx < nbuf; idx++)\n\t\tpipe_buf_release(pipe, &bufs[idx]);\n\tpipe_unlock(pipe);\nout:\n\tkvfree(bufs);\n\treturn ret;\n}", "target": 1}
{"code": "static int nested_vmx_check_permission(struct kvm_vcpu *vcpu)\n{\n\tif (vmx_get_cpl(vcpu)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 0;\n\t}\n\tif (!to_vmx(vcpu)->nested.vmxon) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "BITMAP_UPDATE* update_read_bitmap_update(rdpUpdate* update, wStream* s)\n{\n\tUINT32 i;\n\tBITMAP_UPDATE* bitmapUpdate = calloc(1, sizeof(BITMAP_UPDATE));\n\tif (!bitmapUpdate)\n\t\tgoto fail;\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\tStream_Read_UINT16(s, bitmapUpdate->number); \n\tWLog_Print(update->log, WLOG_TRACE, \"BitmapUpdate: %\"PRIu32\"\", bitmapUpdate->number);\n\tif (bitmapUpdate->number > bitmapUpdate->count)\n\t{\n\t\tUINT16 count;\n\t\tBITMAP_DATA* newdata;\n\t\tcount = bitmapUpdate->number * 2;\n\t\tnewdata = (BITMAP_DATA*) realloc(bitmapUpdate->rectangles,\n\t\t                                 sizeof(BITMAP_DATA) * count);\n\t\tif (!newdata)\n\t\t\tgoto fail;\n\t\tbitmapUpdate->rectangles = newdata;\n\t\tZeroMemory(&bitmapUpdate->rectangles[bitmapUpdate->count],\n\t\t           sizeof(BITMAP_DATA) * (count - bitmapUpdate->count));\n\t\tbitmapUpdate->count = count;\n\t}\n\tfor (i = 0; i < bitmapUpdate->number; i++)\n\t{\n\t\tif (!update_read_bitmap_data(update, s, &bitmapUpdate->rectangles[i]))\n\t\t\tgoto fail;\n\t}\n\treturn bitmapUpdate;\nfail:\n\tfree_bitmap_update(update->context, bitmapUpdate);\n\treturn NULL;\n}", "target": 1}
{"code": "static gpa_t FNAME(gva_to_gpa)(struct kvm_vcpu *vcpu, gva_t vaddr, u32 access,\n\t\t\t       struct x86_exception *exception)\n{\n\tstruct guest_walker walker;\n\tgpa_t gpa = UNMAPPED_GVA;\n\tint r;\n\tr = FNAME(walk_addr)(&walker, vcpu, vaddr, access);\n\tif (r) {\n\t\tgpa = gfn_to_gpa(walker.gfn);\n\t\tgpa |= vaddr & ~PAGE_MASK;\n\t} else if (exception)\n\t\t*exception = walker.fault;\n\treturn gpa;\n}", "target": 0}
{"code": "bool ExtractUnixLink50(CommandData *Cmd,const wchar *Name,FileHeader *hd)\n{\n  char Target[NM];\n  WideToChar(hd->RedirName,Target,ASIZE(Target));\n  if (hd->RedirType==FSREDIR_WINSYMLINK || hd->RedirType==FSREDIR_JUNCTION)\n  {\n    if (strncmp(Target,\"\\\\??\\\\\",4)==0 || strncmp(Target,\"/\\?\\?/\",4)==0)\n      return false;\n    DosSlashToUnix(Target,Target,ASIZE(Target));\n  }\n  wchar TargetW[NM];\n  if (!SafeCharToWide(Target,TargetW,ASIZE(TargetW)))\n    return false;\n  if (!Cmd->AbsoluteLinks && (IsFullPath(TargetW) ||\n      !IsRelativeSymlinkSafe(Cmd,hd->FileName,Name,TargetW)))\n    return false;\n  return UnixSymlink(Cmd,Target,Name,&hd->mtime,&hd->atime);\n}", "target": 1}
{"code": "static long __media_device_enum_links(struct media_device *mdev,\n\t\t\t\t      struct media_links_enum *links)\n{\n\tstruct media_entity *entity;\n\tentity = find_entity(mdev, links->entity);\n\tif (entity == NULL)\n\t\treturn -EINVAL;\n\tif (links->pads) {\n\t\tunsigned int p;\n\t\tfor (p = 0; p < entity->num_pads; p++) {\n\t\t\tstruct media_pad_desc pad;\n\t\t\tmemset(&pad, 0, sizeof(pad));\n\t\t\tmedia_device_kpad_to_upad(&entity->pads[p], &pad);\n\t\t\tif (copy_to_user(&links->pads[p], &pad, sizeof(pad)))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\tif (links->links) {\n\t\tstruct media_link_desc __user *ulink;\n\t\tunsigned int l;\n\t\tfor (l = 0, ulink = links->links; l < entity->num_links; l++) {\n\t\t\tstruct media_link_desc link;\n\t\t\tif (entity->links[l].source->entity != entity)\n\t\t\t\tcontinue;\n\t\t\tmemset(&link, 0, sizeof(link));\n\t\t\tmedia_device_kpad_to_upad(entity->links[l].source,\n\t\t\t\t\t\t  &link.source);\n\t\t\tmedia_device_kpad_to_upad(entity->links[l].sink,\n\t\t\t\t\t\t  &link.sink);\n\t\t\tlink.flags = entity->links[l].flags;\n\t\t\tif (copy_to_user(ulink, &link, sizeof(*ulink)))\n\t\t\t\treturn -EFAULT;\n\t\t\tulink++;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static void gf_dump_vrml_simple_field(GF_SceneDumper *sdump, GF_FieldInfo field, GF_Node *parent)\n{\n\tu32 i, sf_type;\n\tGF_ChildNodeItem *list;\n\tvoid *slot_ptr;\n\tswitch (field.fieldType) {\n\tcase GF_SG_VRML_SFNODE:\n\t\tassert ( *(GF_Node **)field.far_ptr);\n\t\tgf_dump_vrml_node(sdump, *(GF_Node **)field.far_ptr, 0, NULL);\n\t\treturn;\n\tcase GF_SG_VRML_MFNODE:\n\t\tlist = * ((GF_ChildNodeItem **) field.far_ptr);\n\t\tassert( list );\n\t\tsdump->indent++;\n\t\twhile (list) {\n\t\t\tgf_dump_vrml_node(sdump, list->node, 1, NULL);\n\t\t\tlist = list->next;\n\t\t}\n\t\tsdump->indent--;\n\t\treturn;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t\treturn;\n\t}\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\tif (sdump->XMLDump) StartAttribute(sdump, \"value\");\n\t\tgf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, parent);\n\t\tif (sdump->XMLDump) EndAttribute(sdump);\n\t} else {\n\t\tGenMFField *mffield;\n\t\tmffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"[\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \" value=\\'\");\n\t\t} else {\n\t\t\tStartAttribute(sdump, \"value\");\n\t\t}\n\t\tfor (i=0; i<mffield->count; i++) {\n\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, parent);\n\t\t}\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"]\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \"\\'\");\n\t\t} else {\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t}\n}", "target": 1}
{"code": "static int copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb)\n{\n\tstruct xfrm_algo *algo;\n\tstruct nlattr *nla;\n\tnla = nla_reserve(skb, XFRMA_ALG_AUTH,\n\t\t\t  sizeof(*algo) + (auth->alg_key_len + 7) / 8);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\talgo = nla_data(nla);\n\tstrcpy(algo->alg_name, auth->alg_name);\n\tmemcpy(algo->alg_key, auth->alg_key, (auth->alg_key_len + 7) / 8);\n\talgo->alg_key_len = auth->alg_key_len;\n\treturn 0;\n}", "target": 1}
{"code": "bool CModules::ValidateModuleName(const CString& sModule, CString& sRetMsg) {\n    for (unsigned int a = 0; a < sModule.length(); a++) {\n        if (((sModule[a] < '0') || (sModule[a] > '9')) &&\n            ((sModule[a] < 'a') || (sModule[a] > 'z')) &&\n            ((sModule[a] < 'A') || (sModule[a] > 'Z')) && (sModule[a] != '_')) {\n            sRetMsg =\n                t_f(\"Module names can only contain letters, numbers and \"\n                    \"underscores, [{1}] is invalid\")(sModule);\n            return false;\n        }\n    }\n    return true;\n}", "target": 0}
{"code": "  explicit DataFormatVecPermuteOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    string src_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"src_format\", &src_format));\n    OP_REQUIRES(context, src_format.size() == 4 || src_format.size() == 5,\n                errors::InvalidArgument(\n                    \"Source format must be of length 4 or 5, received \"\n                    \"src_format = \",\n                    src_format));\n    string dst_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"dst_format\", &dst_format));\n    OP_REQUIRES(context, dst_format.size() == 4 || dst_format.size() == 5,\n                errors::InvalidArgument(\"Destination format must be of length \"\n                                        \"4 or 5, received dst_format = \",\n                                        dst_format));\n    OP_REQUIRES(\n        context, IsValidPermutation(src_format, dst_format),\n        errors::InvalidArgument(\n            \"Destination and source format must determine a permutation, got \",\n            src_format, \" and \", dst_format));\n    src_format_ = src_format;\n    dst_format_ = dst_format;\n  }", "target": 0}
{"code": "  explicit FractionalAvgPoolOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"pooling_ratio\", &pooling_ratio_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"pseudo_random\", &pseudo_random_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"overlapping\", &overlapping_));\n    OP_REQUIRES(context, pooling_ratio_.size() == 4,\n                errors::InvalidArgument(\n                    \"pooling_ratio field must specify 4 dimensions\"));\n    for (std::size_t i = 0; i < pooling_ratio_.size(); ++i) {\n      OP_REQUIRES(context, pooling_ratio_[i] >= 1,\n                  errors::InvalidArgument(\n                      \"pooling_ratio cannot be smaller than 1, got: \",\n                      pooling_ratio_[i]));\n    }\n    OP_REQUIRES(\n        context, pooling_ratio_[0] == 1 && pooling_ratio_[3] == 1,\n        errors::Unimplemented(\"Fractional average pooling is not yet \"\n                              \"supported on the batch nor channel dimension.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"deterministic\", &deterministic_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed\", &seed_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed2\", &seed2_));\n    if (deterministic_) {\n      if ((seed_ == 0) && (seed2_ == 0)) {\n        seed_ = random::New64();\n        seed2_ = random::New64();\n      }\n    } else {\n      OP_REQUIRES(\n          context, (seed_ == 0) && (seed2_ == 0),\n          errors::InvalidArgument(\n              \"Both seed and seed2 should be 0 if deterministic is false.\"));\n    }\n  }", "target": 0}
{"code": "static int spk_ttyio_ldisc_open(struct tty_struct *tty)\n{\n\tstruct spk_ldisc_data *ldisc_data;\n\tif (!tty->ops->write)\n\t\treturn -EOPNOTSUPP;\n\tspeakup_tty = tty;\n\tldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);\n\tif (!ldisc_data)\n\t\treturn -ENOMEM;\n\tinit_completion(&ldisc_data->completion);\n\tldisc_data->buf_free = true;\n\tspeakup_tty->disc_data = ldisc_data;\n\treturn 0;\n}", "target": 1}
{"code": "static int build_open_gop_key_points(AVStream *st)\n{\n    int k;\n    int sample_id = 0;\n    uint32_t cra_index;\n    MOVStreamContext *sc = st->priv_data;\n    if (st->codecpar->codec_id != AV_CODEC_ID_HEVC || !sc->sync_group_count)\n        return 0;\n    sc->sample_offsets_count = 0;\n    for (uint32_t i = 0; i < sc->ctts_count; i++)\n        sc->sample_offsets_count += sc->ctts_data[i].count;\n    av_freep(&sc->sample_offsets);\n    sc->sample_offsets = av_calloc(sc->sample_offsets_count, sizeof(*sc->sample_offsets));\n    if (!sc->sample_offsets)\n        return AVERROR(ENOMEM);\n    k = 0;\n    for (uint32_t i = 0; i < sc->ctts_count; i++)\n        for (int j = 0; j < sc->ctts_data[i].count; j++)\n             sc->sample_offsets[k++] = sc->ctts_data[i].duration;\n    cra_index = get_sgpd_sync_index(sc, HEVC_NAL_CRA_NUT); \n    if (!cra_index)\n        return 0;\n    sc->open_key_samples_count = 0;\n    for (uint32_t i = 0; i < sc->sync_group_count; i++)\n        if (sc->sync_group[i].index == cra_index)\n            sc->open_key_samples_count += sc->sync_group[i].count;\n    av_freep(&sc->open_key_samples);\n    sc->open_key_samples = av_calloc(sc->open_key_samples_count, sizeof(*sc->open_key_samples));\n    if (!sc->open_key_samples)\n        return AVERROR(ENOMEM);\n    k = 0;\n    for (uint32_t i = 0; i < sc->sync_group_count; i++) {\n        const MOVSbgp *sg = &sc->sync_group[i];\n        if (sg->index == cra_index)\n            for (uint32_t j = 0; j < sg->count; j++)\n                sc->open_key_samples[k++] = sample_id;\n        sample_id += sg->count;\n    }\n    sc->min_sample_duration = UINT_MAX;\n    for (uint32_t i = 0; i < sc->stts_count; i++)\n        sc->min_sample_duration = FFMIN(sc->min_sample_duration, sc->stts_data[i].duration);\n    return 0;\n}", "target": 1}
{"code": "PLIST_API void plist_from_xml(const char *plist_xml, uint32_t length, plist_t * plist)\n{\n    xmlDocPtr plist_doc = xmlParseMemory(plist_xml, length);\n    xmlNodePtr root_node = xmlDocGetRootElement(plist_doc);\n    xml_to_node(root_node, plist);\n    xmlFreeDoc(plist_doc);\n}", "target": 1}
{"code": "exit_sg(void)\n{\n#ifdef CONFIG_SCSI_PROC_FS\n\tremove_proc_subtree(\"scsi/sg\", NULL);\n#endif\t\t\t\t\n\tscsi_unregister_interface(&sg_interface);\n\tclass_destroy(sg_sysfs_class);\n\tsg_sysfs_valid = 0;\n\tunregister_chrdev_region(MKDEV(SCSI_GENERIC_MAJOR, 0),\n\t\t\t\t SG_MAX_DEVS);\n\tidr_destroy(&sg_index_idr);\n}", "target": 0}
{"code": " */\nstatic void re_yyensure_buffer_stack (yyscan_t yyscanner)\n{\n\tyy_size_t num_to_alloc;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\tif (!yyg->yy_buffer_stack) {\n\t\tnum_to_alloc = 1; \n\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)re_yyalloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t, yyscanner);\n\t\tif ( ! yyg->yy_buffer_stack )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in re_yyensure_buffer_stack()\" );\n\t\tmemset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n\t\tyyg->yy_buffer_stack_max = num_to_alloc;\n\t\tyyg->yy_buffer_stack_top = 0;\n\t\treturn;\n\t}\n\tif (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){\n\t\tyy_size_t grow_size = 8 ;\n\t\tnum_to_alloc = yyg->yy_buffer_stack_max + grow_size;\n\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)re_yyrealloc\n\t\t\t\t\t\t\t\t(yyg->yy_buffer_stack,\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t, yyscanner);\n\t\tif ( ! yyg->yy_buffer_stack )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in re_yyensure_buffer_stack()\" );\n\t\tmemset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));\n\t\tyyg->yy_buffer_stack_max = num_to_alloc;\n\t}", "target": 1}
{"code": "static int do_i2c_write(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t\tchar *const argv[])\n{\n\tuint\tchip;\n\tuint\tdevaddr, length;\n\tint alen;\n\tu_char  *memaddr;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n\tstruct dm_i2c_chip *i2c_chip;\n#endif\n\tif ((argc < 5) || (argc > 6))\n\t\treturn cmd_usage(cmdtp);\n\tmemaddr = (u_char *)hextoul(argv[1], NULL);\n\tchip = hextoul(argv[2], NULL);\n\tdevaddr = hextoul(argv[3], NULL);\n\talen = get_alen(argv[3], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn cmd_usage(cmdtp);\n\tlength = hextoul(argv[4], NULL);\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n\ti2c_chip = dev_get_parent_plat(dev);\n\tif (!i2c_chip)\n\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n#endif\n\tif (argc == 6 && !strcmp(argv[5], \"-s\")) {\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\ti2c_chip->flags &= ~DM_I2C_CHIP_WR_ADDRESS;\n\t\tret = dm_i2c_write(dev, devaddr, memaddr, length);\n#else\n\t\tret = i2c_write(chip, devaddr, alen, memaddr, length);\n#endif\n\t\tif (ret)\n\t\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n\t} else {\n\t\twhile (length-- > 0) {\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\t\ti2c_chip->flags |= DM_I2C_CHIP_WR_ADDRESS;\n\t\t\tret = dm_i2c_write(dev, devaddr++, memaddr++, 1);\n#else\n\t\t\tret = i2c_write(chip, devaddr++, alen, memaddr++, 1);\n#endif\n\t\t\tif (ret)\n\t\t\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n#if !defined(CONFIG_SYS_I2C_FRAM)\n\t\t\tudelay(11000);\n#endif\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static Jsi_RC DebugAddCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (!interp->breakpointHash)\n        interp->breakpointHash = Jsi_HashNew(interp, JSI_KEYS_STRING, jsi_HashFree);\n    int argc = Jsi_ValueGetLength(interp, args);\n    jsi_BreakPoint *bptr, bp = {};\n    Jsi_Number vnum;\n    if (argc>1 && Jsi_ValueGetBoolean(interp, Jsi_ValueArrayIndex(interp, args, 1), &bp.temp) != JSI_OK) \n        return Jsi_LogError(\"bad boolean\");\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    if (Jsi_ValueGetNumber(interp, v, &vnum) == JSI_OK) {\n        bp.line = (int)vnum;\n        bp.file = interp->curFile;\n    } else {\n        const char *val = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n        const char *cp;\n        if (isdigit(val[0])) {\n            if (Jsi_GetInt(interp, val, &bp.line, 0) != JSI_OK) \n                return Jsi_LogError(\"bad number\");\n            bp.file = interp->curFile;\n        } else if ((cp = Jsi_Strchr(val, ':'))) {\n            if (Jsi_GetInt(interp, cp+1, &bp.line, 0) != JSI_OK) \n                return Jsi_LogError(\"bad number\");\n            Jsi_DString dStr = {};\n            Jsi_DSAppendLen(&dStr, val, cp-val);\n            bp.file = Jsi_KeyAdd(interp, Jsi_DSValue(&dStr));\n            Jsi_DSFree(&dStr);\n        } else {\n            bp.func = Jsi_KeyAdd(interp, val);\n        }\n    }\n    if (bp.line<=0 && !bp.func) \n        return Jsi_LogError(\"bad number\");\n    char nbuf[100];\n    bp.id = ++interp->debugOpts.breakIdx;\n    bp.enabled = 1;\n    snprintf(nbuf, sizeof(nbuf), \"%d\", bp.id);\n    bptr = (jsi_BreakPoint*)Jsi_Malloc(sizeof(*bptr));\n    *bptr = bp;\n    Jsi_HashSet(interp->breakpointHash, (void*)nbuf, bptr);\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)bp.id);\n    return JSI_OK;\n}", "target": 1}
{"code": "const AtomicString& BaseAudioContext::InterfaceName() const {\n  return event_target_names::kAudioContext;\n}", "target": 0}
{"code": "GF_Box *stri_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubTrackInformationBox, GF_ISOM_BOX_TYPE_STRI);\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "PHP_FUNCTION(linkinfo)\n{\n\tchar *link;\n\tchar *dirname;\n\tsize_t link_len;\n\tzend_stat_t sb;\n\tint ret;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"p\", &link, &link_len) == FAILURE) {\n\t\treturn;\n\t}\n\tdirname = estrndup(link, link_len);\n\tphp_dirname(dirname, link_len);\n\tif (php_check_open_basedir(dirname)) {\n\t\tefree(dirname);\n\t\tRETURN_FALSE;\n\t}\n\tret = VCWD_STAT(link, &sb);\n\tif (ret == -1) {\n\t\tphp_error_docref(NULL, E_WARNING, \"%s\", strerror(errno));\n\t\tefree(dirname);\n\t\tRETURN_LONG(Z_L(-1));\n\t}\n\tefree(dirname);\n\tRETURN_LONG((zend_long) sb.st_dev);\n}", "target": 0}
{"code": "struct vfsmount *collect_mounts(struct path *path)\n{\n\tstruct mount *tree;\n\tnamespace_lock();\n\ttree = copy_tree(real_mount(path->mnt), path->dentry,\n\t\t\t CL_COPY_ALL | CL_PRIVATE);\n\tnamespace_unlock();\n\tif (IS_ERR(tree))\n\t\treturn ERR_CAST(tree);\n\treturn &tree->mnt;\n}", "target": 1}
{"code": "struct lib_t* MACH0_(get_libs)(struct MACH0_(obj_t)* bin) {\n\tstruct lib_t *libs;\n\tint i;\n\tif (!bin->nlibs)\n\t\treturn NULL;\n\tif (!(libs = calloc ((bin->nlibs + 1), sizeof(struct lib_t))))\n\t\treturn NULL;\n\tfor (i = 0; i < bin->nlibs; i++) {\n\t\tstrncpy (libs[i].name, bin->libs[i], R_BIN_MACH0_STRING_LENGTH);\n\t\tlibs[i].name[R_BIN_MACH0_STRING_LENGTH-1] = '\\0';\n\t\tlibs[i].last = 0;\n\t}\n\tlibs[i].last = 1;\n\treturn libs;\n}", "target": 1}
{"code": "rpl_dio_print(netdissect_options *ndo,\n              const u_char *bp, u_int length)\n{\n        const struct nd_rpl_dio *dio = (const struct nd_rpl_dio *)bp;\n        const char *dagid_str;\n        ND_TCHECK(*dio);\n        dagid_str = ip6addr_string (ndo, dio->rpl_dagid);\n        ND_PRINT((ndo, \" [dagid:%s,seq:%u,instance:%u,rank:%u,%smop:%s,prf:%u]\",\n                  dagid_str,\n                  dio->rpl_dtsn,\n                  dio->rpl_instanceid,\n                  EXTRACT_16BITS(&dio->rpl_dagrank),\n                  RPL_DIO_GROUNDED(dio->rpl_mopprf) ? \"grounded,\":\"\",\n                  tok2str(rpl_mop_values, \"mop%u\", RPL_DIO_MOP(dio->rpl_mopprf)),\n                  RPL_DIO_PRF(dio->rpl_mopprf)));\n        if(ndo->ndo_vflag > 1) {\n                const struct rpl_dio_genoption *opt = (const struct rpl_dio_genoption *)&dio[1];\n                rpl_dio_printopt(ndo, opt, length);\n        }\n\treturn;\ntrunc:\n\tND_PRINT((ndo,\" [|truncated]\"));\n\treturn;\n}", "target": 1}
{"code": "static int is_cmd_rcvr_exclusive(struct ipmi_smi *intf,\n\t\t\t\t unsigned char netfn,\n\t\t\t\t unsigned char cmd,\n\t\t\t\t unsigned int  chans)\n{\n\tstruct cmd_rcvr *rcvr;\n\tlist_for_each_entry_rcu(rcvr, &intf->cmd_rcvrs, link) {\n\t\tif ((rcvr->netfn == netfn) && (rcvr->cmd == cmd)\n\t\t\t\t\t&& (rcvr->chans & chans))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "bool DependencyOptimizer::SafeToRemoveIdentity(const NodeDef& node) const {\n  if (!IsIdentity(node) && !IsIdentityN(node)) {\n    return true;\n  }\n  if (nodes_to_preserve_.find(node.name()) != nodes_to_preserve_.end()) {\n    return false;\n  }\n  if (!fetch_nodes_known_) {\n    return false;\n  }\n  if (node.input_size() < 1) {\n    return false;\n  }\n  const NodeDef* input = node_map_->GetNode(NodeName(node.input(0)));\n  CHECK(input != nullptr) << \"node = \" << node.name()\n                          << \" input = \" << node.input(0);\n  if (IsVariable(*input) || IsRecv(*input)) {\n    return false;\n  }\n  for (const auto& consumer : node_map_->GetOutputs(node.name())) {\n    if (node.input_size() > 1 && (IsRetval(*consumer) || IsMerge(*consumer))) {\n      return false;\n    }\n    if (IsSwitch(*input)) {\n      for (const string& consumer_input : consumer->input()) {\n        if (consumer_input == AsControlDependency(node.name())) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}", "target": 0}
{"code": "ProcInstallColormap(ClientPtr client)\n{\n    ColormapPtr pcmp;\n    int rc;\n    REQUEST(xResourceReq);\n    REQUEST_SIZE_MATCH(xResourceReq);\n    rc = dixLookupResourceByType((void **) &pcmp, stuff->id, RT_COLORMAP,\n                                 client, DixInstallAccess);\n    if (rc != Success)\n        goto out;\n    rc = XaceHook(XACE_SCREEN_ACCESS, client, pcmp->pScreen, DixSetAttrAccess);\n    if (rc != Success) {\n        if (rc == BadValue)\n            rc = BadColor;\n        goto out;\n    }\n    (*(pcmp->pScreen->InstallColormap)) (pcmp);\n    return Success;\n out:\n    client->errorValue = stuff->id;\n    return rc;\n}", "target": 0}
{"code": "static void pdfobj_flag(struct pdf_struct *pdf, struct pdf_obj *obj, enum pdf_flag flag)\n{\n    const char *s= \"\";\n    pdf->flags |= 1 << flag;\n    if (!cli_debug_flag)\n\treturn;\n    switch (flag) {\n\tcase UNTERMINATED_OBJ_DICT:\n\t    s = \"dictionary not terminated\";\n\t    break;\n\tcase ESCAPED_COMMON_PDFNAME:\n\t    s = \"escaped common pdfname\";\n\t    break;\n\tcase BAD_STREAM_FILTERS:\n\t    s = \"duplicate stream filters\";\n\t    break;\n\tcase BAD_PDF_VERSION:\n\t    s = \"bad pdf version\";\n\t    break;\n\tcase BAD_PDF_HEADERPOS:\n\t    s = \"bad pdf header position\";\n\t    break;\n\tcase BAD_PDF_TRAILER:\n\t    s = \"bad pdf trailer\";\n\t    break;\n\tcase BAD_PDF_TOOMANYOBJS:\n\t    s = \"too many pdf objs\";\n\t    break;\n\tcase BAD_FLATE:\n\t    s = \"bad deflate stream\";\n\t    break;\n\tcase BAD_FLATESTART:\n\t    s = \"bad deflate stream start\";\n\t    break;\n\tcase BAD_STREAMSTART:\n\t    s = \"bad stream start\";\n\t    break;\n\tcase UNKNOWN_FILTER:\n\t    s = \"unknown filter used\";\n\t    break;\n\tcase BAD_ASCIIDECODE:\n\t    s = \"bad ASCII decode\";\n\t    break;\n\tcase HEX_JAVASCRIPT:\n\t    s = \"hex javascript\";\n\t    break;\n\tcase BAD_INDOBJ:\n\t    s = \"referencing nonexistent obj\";\n\t    break;\n\tcase HAS_OPENACTION:\n\t    s = \"has /OpenAction\";\n\t    break;\n\tcase HAS_LAUNCHACTION:\n\t    s = \"has /LaunchAction\";\n\t    break;\n\tcase BAD_STREAMLEN:\n\t    s = \"bad /Length, too small\";\n\t    break;\n\tcase ENCRYPTED_PDF:\n\t    s = \"PDF is encrypted\";\n\t    break;\n\tcase LINEARIZED_PDF:\n\t    s = \"linearized PDF\";\n\t    break;\n\tcase MANY_FILTERS:\n\t    s = \"more than 2 filters per obj\";\n\t    break;\n\tcase DECRYPTABLE_PDF:\n\t    s = \"decryptable PDF\";\n\t    break;\n    }\n    cli_dbgmsg(\"cli_pdf: %s flagged in object %u %u\\n\", s, obj->id>>8, obj->id&0xff);\n}", "target": 0}
{"code": "irc_server_set_prefix_modes_chars (struct t_irc_server *server,\n                                   const char *prefix)\n{\n    char *pos;\n    int i, length_modes, length_chars;\n    if (!server || !prefix)\n        return;\n    if (server->prefix_modes)\n    {\n        free (server->prefix_modes);\n        server->prefix_modes = NULL;\n    }\n    if (server->prefix_chars)\n    {\n        free (server->prefix_chars);\n        server->prefix_chars = NULL;\n    }\n    pos = strchr (prefix, ')');\n    if (pos)\n    {\n        server->prefix_modes = weechat_strndup (prefix + 1,\n                                                pos - prefix - 1);\n        if (server->prefix_modes)\n        {\n            pos++;\n            length_modes = strlen (server->prefix_modes);\n            length_chars = strlen (pos);\n            server->prefix_chars = malloc (length_modes + 1);\n            if (server->prefix_chars)\n            {\n                for (i = 0; i < length_modes; i++)\n                {\n                    server->prefix_chars[i] = (i < length_chars) ? pos[i] : ' ';\n                }\n                server->prefix_chars[length_modes] = '\\0';\n            }\n            else\n            {\n                free (server->prefix_modes);\n                server->prefix_modes = NULL;\n            }\n        }\n    }\n}", "target": 1}
{"code": "static int cit_get_packet_size(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\tintf = usb_ifnum_to_if(gspca_dev->dev, gspca_dev->iface);\n\talt = usb_altnum_to_altsetting(intf, gspca_dev->alt);\n\tif (!alt) {\n\t\tpr_err(\"Couldn't get altsetting\\n\");\n\t\treturn -EIO;\n\t}\n\tif (alt->desc.bNumEndpoints < 1)\n\t\treturn -ENODEV;\n\treturn le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n}", "target": 0}
{"code": "static bool bt_att_disc_cancel(struct bt_att *att, unsigned int id)\n{\n\tstruct att_send_op *op;\n\top = queue_find(att->req_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\top = queue_find(att->ind_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\top = queue_find(att->write_queue, match_op_id, UINT_TO_PTR(id));\ndone:\n\tif (!op)\n\t\treturn false;\n\tcancel_att_send_op(op);\n\treturn true;\n}", "target": 0}
{"code": "bool SecureSocket::verify_cert_fingerprint(const barrier::fs::path& fingerprint_db_path)\n{\n    barrier::FingerprintData fingerprint_sha1, fingerprint_sha256;\n    try {\n        auto* cert = SSL_get_peer_certificate(m_ssl->m_ssl);\n        fingerprint_sha1 = barrier::get_ssl_cert_fingerprint(cert,\n                                                             barrier::FingerprintType::SHA1);\n        fingerprint_sha256 = barrier::get_ssl_cert_fingerprint(cert,\n                                                               barrier::FingerprintType::SHA256);\n    } catch (const std::exception& e) {\n        LOG((CLOG_ERR \"%s\", e.what()));\n        return false;\n    }\n    LOG((CLOG_NOTE \"server fingerprint (SHA1): %s (SHA256): %s\",\n         barrier::format_ssl_fingerprint(fingerprint_sha1.data).c_str(),\n         barrier::format_ssl_fingerprint(fingerprint_sha256.data).c_str()));\n    LOG((CLOG_NOTE \"fingerprint_db_path: %s\", fingerprint_db_path.u8string().c_str()));\n    barrier::FingerprintDatabase db;\n    db.read(fingerprint_db_path);\n    if (!db.fingerprints().empty()) {\n        LOG((CLOG_NOTE \"Read %d fingerprints from: %s\", db.fingerprints().size(),\n             fingerprint_db_path.u8string().c_str()));\n    } else {\n        LOG((CLOG_NOTE \"Could not read fingerprints from: %s\",\n             fingerprint_db_path.u8string().c_str()));\n    }\n    if (db.is_trusted(fingerprint_sha256)) {\n        LOG((CLOG_NOTE \"Fingerprint matches trusted fingerprint\"));\n        return true;\n    } else {\n        LOG((CLOG_NOTE \"Fingerprint does not match trusted fingerprint\"));\n        return false;\n    }\n}", "target": 1}
{"code": "bool FormContainsNonDefaultPasswordValue(const PasswordForm& password_form) {\n  return (!password_form.password_value.empty() &&\n          !password_form.password_value_is_default) ||\n      (!password_form.new_password_value.empty() &&\n       !password_form.new_password_value_is_default);\n}", "target": 0}
{"code": "char *RootdExpandPathName(const char *name)\n{\n   const char *patbuf = name;\n   while (*patbuf == ' ')\n      patbuf++;\n   for (const char *p = patbuf; *p; p++)\n      if (strchr(shellMeta, *p))\n         goto needshell;\n   return strdup(name);\nneedshell:\n   char escPatbuf[kMAXPATHLEN];\n   EscChar(patbuf, escPatbuf, sizeof(escPatbuf), shellStuff, shellEscape);\n   char cmd[kMAXPATHLEN];\n#ifdef __hpux\n   strlcpy(cmd, \"/bin/echo \", sizeof(cmd));\n#else\n   strlcpy(cmd, \"echo \", sizeof(cmd));\n#endif\n   if (escPatbuf[0] == '~') {\n      const char *hd;\n      if (escPatbuf[1] != '\\0' && escPatbuf[1] != '/') {\n         char uname[70], *p, *q;\n         for (p = &escPatbuf[1], q = uname; *p && *p !='/';)\n            *q++ = *p++;\n         *q = '\\0';\n         hd = HomeDirectory(uname);\n         if (hd == 0)\n            strcat(cmd, escPatbuf);\n         else {\n            strcat(cmd, hd);\n            strcat(cmd, p);\n         }\n      } else {\n         hd = HomeDirectory(0);\n         if (hd == 0) {\n            Error(ErrSys, kErrFatal, \"RootdExpandPathName: no home directory\");\n            return 0;\n         }\n         strcat(cmd, hd);\n         strcat(cmd, &escPatbuf[1]);\n      }\n   } else\n      strcat(cmd, escPatbuf);\n   FILE *pf;\n   if ((pf = ::popen(&cmd[0], \"r\")) == 0) {\n      Error(ErrSys, kErrFatal, \"RootdExpandPathName: error in popen(%s)\", cmd);\n      return 0;\n   }\n   char expPatbuf[kMAXPATHLEN];\n   int  ch, i, cnt = 0;\nagain:\n   for (i = 0, ch = fgetc(pf); ch != EOF && ch != ' ' && ch != '\\n'; i++, ch = fgetc(pf)) {\n      expPatbuf[i] = ch;\n      cnt++;\n   }\n   if (cnt == 0 && ch == EOF) goto again;\n   expPatbuf[cnt] = '\\0';\n   while (ch != EOF) {\n      ch = fgetc(pf);\n      if (ch == ' ' || ch == '\\t') {\n         ::pclose(pf);\n         Error(ErrFatal, kErrFatal, \"RootdExpandPathName: expression ambigous\");\n         return 0;\n      }\n   }\n   ::pclose(pf);\n   return strdup(expPatbuf);\n}", "target": 1}
{"code": "size_t HTTP2Codec::generateTrailers(folly::IOBufQueue& writeBuf,\n                                    StreamID stream,\n                                    const HTTPHeaders& trailers) {\n  VLOG(4) << \"generating TRAILERS for stream=\" << stream;\n  std::vector<compress::Header> allHeaders;\n  CodecUtil::appendHeaders(trailers, allHeaders, HTTP_HEADER_NONE);\n  HTTPHeaderSize size;\n  auto out = encodeHeaders(trailers, allHeaders, &size);\n  IOBufQueue queue(IOBufQueue::cacheChainLength());\n  queue.append(std::move(out));\n  auto maxFrameSize = maxSendFrameSize();\n  if (queue.chainLength() > 0) {\n    folly::Optional<http2::PriorityUpdate> pri;\n    auto remainingFrameSize = maxFrameSize;\n    auto chunk = queue.split(std::min(remainingFrameSize, queue.chainLength()));\n    bool endHeaders = queue.chainLength() == 0;\n    generateHeaderCallbackWrapper(stream,\n                                  http2::FrameType::HEADERS,\n                                  http2::writeHeaders(writeBuf,\n                                                      std::move(chunk),\n                                                      stream,\n                                                      pri,\n                                                      http2::kNoPadding,\n                                                      true ,\n                                                      endHeaders));\n    if (!endHeaders) {\n      generateContinuation(writeBuf, queue, stream, maxFrameSize);\n    }\n  }\n  return size.compressed;\n}", "target": 0}
{"code": "static int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_pclr_t *pclr = &box->data.pclr;\n\tint lutsize;\n\tunsigned int i;\n\tunsigned int j;\n\tint_fast32_t x;\n\tpclr->lutdata = 0;\n\tpclr->bpc = 0;\n\tif (jp2_getuint16(in, &pclr->numlutents) ||\n\t  jp2_getuint8(in, &pclr->numchans)) {\n\t\treturn -1;\n\t}\n\tlutsize = pclr->numlutents * pclr->numchans;\n\tif (!(pclr->lutdata = jas_alloc2(lutsize, sizeof(int_fast32_t)))) {\n\t\treturn -1;\n\t}\n\tif (!(pclr->bpc = jas_alloc2(pclr->numchans, sizeof(uint_fast8_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < pclr->numchans; ++i) {\n\t\tif (jp2_getuint8(in, &pclr->bpc[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tfor (i = 0; i < pclr->numlutents; ++i) {\n\t\tfor (j = 0; j < pclr->numchans; ++j) {\n\t\t\tif (jp2_getint(in, (pclr->bpc[j] & 0x80) != 0,\n\t\t\t  (pclr->bpc[j] & 0x7f) + 1, &x)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpclr->lutdata[i * pclr->numchans + j] = x;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,\n\t\t\tstruct rq_map_data *map_data,\n\t\t\tconst struct iov_iter *iter, gfp_t gfp_mask)\n{\n\tbool copy = false;\n\tunsigned long align = q->dma_pad_mask | queue_dma_alignment(q);\n\tstruct bio *bio = NULL;\n\tstruct iov_iter i;\n\tint ret;\n\tif (!iter_is_iovec(iter))\n\t\tgoto fail;\n\tif (map_data)\n\t\tcopy = true;\n\telse if (iov_iter_alignment(iter) & align)\n\t\tcopy = true;\n\telse if (queue_virt_boundary(q))\n\t\tcopy = queue_virt_boundary(q) & iov_iter_gap_alignment(iter);\n\ti = *iter;\n\tdo {\n\t\tret =__blk_rq_map_user_iov(rq, map_data, &i, gfp_mask, copy);\n\t\tif (ret)\n\t\t\tgoto unmap_rq;\n\t\tif (!bio)\n\t\t\tbio = rq->bio;\n\t} while (iov_iter_count(&i));\n\tif (!bio_flagged(bio, BIO_USER_MAPPED))\n\t\trq->cmd_flags |= REQ_COPY_USER;\n\treturn 0;\nunmap_rq:\n\t__blk_rq_unmap_user(bio);\nfail:\n\trq->bio = NULL;\n\treturn -EINVAL;\n}", "target": 0}
{"code": "void LinearAlgebraOp<InputScalar, OutputScalar>::AnalyzeInputs(\n    OpKernelContext* context, TensorInputs* inputs,\n    TensorShapes* input_matrix_shapes, TensorShape* batch_shape) {\n  int input_rank = -1;\n  for (int i = 0; i < NumMatrixInputs(context); ++i) {\n    const Tensor& in = context->input(i);\n    if (i == 0) {\n      input_rank = in.dims();\n      OP_REQUIRES(\n          context, input_rank >= 2,\n          errors::InvalidArgument(\"Input tensor \", i,\n                                  \" must have rank >= 2, got \", input_rank));\n      for (int dim = 0; dim < input_rank - 2; ++dim) {\n        batch_shape->AddDim(in.dim_size(dim));\n      }\n    } else {\n      OP_REQUIRES(context, input_rank == in.dims(),\n                  errors::InvalidArgument(\n                      \"All input tensors must have the same rank.\"));\n      for (int dim = 0; dim < input_rank - 2; ++dim) {\n        OP_REQUIRES(\n            context, in.dim_size(dim) == batch_shape->dim_size(dim),\n            errors::InvalidArgument(\n                \"All input tensors must have the same outer dimensions.\"));\n      }\n    }\n    const int row_dimension = input_rank - 2;\n    const int col_dimension = input_rank - 1;\n    const int64_t num_rows = in.dim_size(row_dimension);\n    const int64_t num_cols = in.dim_size(col_dimension);\n    input_matrix_shapes->emplace_back(\n        std::initializer_list<int64_t>({num_rows, num_cols}));\n    inputs->emplace_back(&in);\n    OP_REQUIRES(\n        context, in.dtype() == DataTypeToEnum<InputScalar>::v(),\n        errors::InvalidArgument(\"Invalid input dtype \", in.dtype(), \" vs \",\n                                DataTypeToEnum<InputScalar>::v()));\n  }\n  ValidateInputMatrixShapes(context, *input_matrix_shapes);\n}", "target": 0}
{"code": "  TfLiteStatus status() const { return status_; }", "target": 0}
{"code": "modify_policy_2_svc(mpol_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->rec.policy;\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_MODIFY, NULL, NULL)) {\n        log_unauth(\"kadm5_modify_policy\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_MODIFY;\n    } else {\n        ret.code = kadm5_modify_policy((void *)handle, &arg->rec,\n                                       arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_modify_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "static int allocDynamic(dynamicPtr *dp, int initialSize, void *data)\n{\n\tif(data == NULL) {\n\t\tdp->logicalSize = 0;\n\t\tdp->dataGood = FALSE;\n\t\tdp->data = gdMalloc(initialSize);\n\t} else {\n\t\tdp->logicalSize = initialSize;\n\t\tdp->dataGood = TRUE;\n\t\tdp->data = data;\n\t}\n\tif(dp->data != NULL) {\n\t\tdp->realSize = initialSize;\n\t\tdp->dataGood = TRUE;\n\t\tdp->pos = 0;\n\t\treturn TRUE;\n\t} else {\n\t\tdp->realSize = 0;\n\t\treturn FALSE;\n\t}\n}", "target": 0}
{"code": "  HistogramInfo* heap_histograms() { return heap_histograms_; }", "target": 0}
{"code": "static void virtio_net_detach_epbf_rss(VirtIONet *n)\n{\n    virtio_net_attach_ebpf_to_backend(n->nic, -1);\n}", "target": 0}
{"code": "static bool torture_smb2_notify_rmdir1(struct torture_context *torture,\n\t\t\t\t       struct smb2_tree *tree)\n{\n\treturn torture_smb2_notify_rmdir(torture, tree, tree, false);\n}", "target": 0}
{"code": "    bool normalizeSipUri( std::string& uri, int brackets ) {\n        su_home_t* home = theOneAndOnlyController->getHome() ;\n        char *s ;\n        char buf[255];\n        char obuf[255] ;\n        char hp[64] ;\n        char const *display = NULL;\n        url_t url[1];\n        msg_param_t const *params = NULL;\n        char const *comment = NULL;\n        int rc ;\n        s = strncpy( buf, uri.c_str(), 255 ) ;\n        rc = sip_name_addr_d(home, &s, &display, url, &params, &comment) ;\n        if( rc < 0 ) {  \n            return false ;\n        }\n        if( NULL == url->url_scheme && NULL == url->url_user && NULL != url->url_host ) {\n            url->url_scheme = \"sip\" ;\n            url->url_user = url->url_host ;\n            url->url_host = \"localhost\" ;   \n         }\n        int nChars = sip_name_addr_e(obuf, 255, 0, display, brackets, url, params, comment) ;\n        if( params ) {\n            su_free(home, (void *) params) ;\n        }\n        if( nChars <= 0 ) {\n            return false ;\n        }\n        uri.assign( obuf ) ;\n        return true ;\n    }", "target": 1}
{"code": "bool AudioContext::isAudioThread() const\n{\n    return currentThread() == m_audioThread;\n}", "target": 0}
{"code": "int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)\n{\n\tstruct sctp_association *asoc = sctp_id2assoc(sk, id);\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct socket *sock;\n\tint err = 0;\n\tif (!asoc)\n\t\treturn -EINVAL;\n\tif (waitqueue_active(&asoc->wait))\n\t\treturn -EBUSY;\n\tif (!sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\terr = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);\n\tif (err < 0)\n\t\treturn err;\n\tsctp_copy_sock(sock->sk, sk, asoc);\n\tsp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);\n\tsctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);\n\t*sockp = sock;\n\treturn err;\n}", "target": 0}
{"code": "  virtual void ForgetWifiNetwork(const std::string& service_path) {}", "target": 0}
{"code": "  bool hasEncodingError() const {\n    return encodingError_;\n  }", "target": 0}
{"code": "uint64_t HeaderMapImpl::refreshByteSize() {\n  if (!cached_byte_size_.has_value()) {\n    cached_byte_size_ = byteSizeInternal();\n  }\n  return cached_byte_size_.value();\n}", "target": 0}
{"code": "static Status ValidateFunctionNotRecursive(const FunctionDef& function) {\n  const auto& function_name = function.signature().name();\n  for (const auto& node : function.node_def()) {\n    if (node.op() == function_name) {\n      return errors::FailedPrecondition(\n          \"Function \", function_name,\n          \" is self recursive and TensorFlow does not support this scenario.\");\n    }\n  }\n  return Status::OK();\n}", "target": 0}
{"code": "static int createFromTiffRgba(TIFF * tif, gdImagePtr im)\n{\n\tint a;\n\tint x, y;\n\tint alphaBlendingFlag = 0;\n\tint color;\n\tint width = im->sx;\n\tint height = im->sy;\n\tuint32 *buffer;\n\tuint32 rgba;\n\talphaBlendingFlag = im->alphaBlendingFlag;\n\tgdImageAlphaBlending(im, 0);\n\tbuffer = (uint32 *) gdCalloc(sizeof(uint32), width * height);\n\tif (!buffer) {\n\t\treturn GD_FAILURE;\n\t}\n\tTIFFReadRGBAImage(tif, width, height, buffer, 0);\n\tfor(y = 0; y < height; y++) {\n\t\tfor(x = 0; x < width; x++) {\n\t\t\trgba = buffer[(y * width + x)];\n\t\t\ta = (0xff - TIFFGetA(rgba)) / 2;\n\t\t\tcolor = gdTrueColorAlpha(TIFFGetR(rgba), TIFFGetG(rgba), TIFFGetB(rgba), a);\n\t\t\tgdImageSetPixel(im, x, height - y - 1, color);\n\t\t}\n\t}\n\tgdFree(buffer);\n\tgdImageAlphaBlending(im, alphaBlendingFlag);\n\treturn GD_SUCCESS;\n}", "target": 1}
{"code": "raw_copy_from_user(void *dst, const void __user *src, unsigned long size)\n{\n\tint ret = 0;\n\tif (!__builtin_constant_p(size))\n\t\treturn copy_user_generic(dst, (__force void *)src, size);\n\tswitch (size) {\n\tcase 1:\n\t\t__uaccess_begin_nospec();\n\t\t__get_user_asm_nozero(*(u8 *)dst, (u8 __user *)src,\n\t\t\t      ret, \"b\", \"b\", \"=q\", 1);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 2:\n\t\t__uaccess_begin_nospec();\n\t\t__get_user_asm_nozero(*(u16 *)dst, (u16 __user *)src,\n\t\t\t      ret, \"w\", \"w\", \"=r\", 2);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 4:\n\t\t__uaccess_begin_nospec();\n\t\t__get_user_asm_nozero(*(u32 *)dst, (u32 __user *)src,\n\t\t\t      ret, \"l\", \"k\", \"=r\", 4);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 8:\n\t\t__uaccess_begin_nospec();\n\t\t__get_user_asm_nozero(*(u64 *)dst, (u64 __user *)src,\n\t\t\t      ret, \"q\", \"\", \"=r\", 8);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 10:\n\t\t__uaccess_begin_nospec();\n\t\t__get_user_asm_nozero(*(u64 *)dst, (u64 __user *)src,\n\t\t\t       ret, \"q\", \"\", \"=r\", 10);\n\t\tif (likely(!ret))\n\t\t\t__get_user_asm_nozero(*(u16 *)(8 + (char *)dst),\n\t\t\t\t       (u16 __user *)(8 + (char __user *)src),\n\t\t\t\t       ret, \"w\", \"w\", \"=r\", 2);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 16:\n\t\t__uaccess_begin_nospec();\n\t\t__get_user_asm_nozero(*(u64 *)dst, (u64 __user *)src,\n\t\t\t       ret, \"q\", \"\", \"=r\", 16);\n\t\tif (likely(!ret))\n\t\t\t__get_user_asm_nozero(*(u64 *)(8 + (char *)dst),\n\t\t\t\t       (u64 __user *)(8 + (char __user *)src),\n\t\t\t\t       ret, \"q\", \"\", \"=r\", 8);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tdefault:\n\t\treturn copy_user_generic(dst, (__force void *)src, size);\n\t}\n}", "target": 1}
{"code": "  void readEOF() noexcept override {}", "target": 0}
{"code": "static void hid_input_field(struct hid_device *hid, struct hid_field *field,\n\t\t\t    __u8 *data, int interrupt)\n{\n\tunsigned n;\n\tunsigned count = field->report_count;\n\tunsigned offset = field->report_offset;\n\tunsigned size = field->report_size;\n\t__s32 min = field->logical_minimum;\n\t__s32 max = field->logical_maximum;\n\t__s32 *value;\n\tvalue = kmalloc(sizeof(__s32) * count, GFP_ATOMIC);\n\tif (!value)\n\t\treturn;\n\tfor (n = 0; n < count; n++) {\n\t\tvalue[n] = min < 0 ?\n\t\t\tsnto32(hid_field_extract(hid, data, offset + n * size,\n\t\t\t       size), size) :\n\t\t\thid_field_extract(hid, data, offset + n * size, size);\n\t\tif (!(field->flags & HID_MAIN_ITEM_VARIABLE) &&\n\t\t    value[n] >= min && value[n] <= max &&\n\t\t    value[n] - min < field->maxusage &&\n\t\t    field->usage[value[n] - min].hid == HID_UP_KEYBOARD + 1)\n\t\t\tgoto exit;\n\t}\n\tfor (n = 0; n < count; n++) {\n\t\tif (HID_MAIN_ITEM_VARIABLE & field->flags) {\n\t\t\thid_process_event(hid, field, &field->usage[n], value[n], interrupt);\n\t\t\tcontinue;\n\t\t}\n\t\tif (field->value[n] >= min && field->value[n] <= max\n\t\t\t&& field->value[n] - min < field->maxusage\n\t\t\t&& field->usage[field->value[n] - min].hid\n\t\t\t&& search(value, field->value[n], count))\n\t\t\t\thid_process_event(hid, field, &field->usage[field->value[n] - min], 0, interrupt);\n\t\tif (value[n] >= min && value[n] <= max\n\t\t\t&& value[n] - min < field->maxusage\n\t\t\t&& field->usage[value[n] - min].hid\n\t\t\t&& search(field->value, value[n], count))\n\t\t\t\thid_process_event(hid, field, &field->usage[value[n] - min], 1, interrupt);\n\t}\n\tmemcpy(field->value, value, count * sizeof(__s32));\nexit:\n\tkfree(value);\n}", "target": 0}
{"code": "GF_Err gf_isom_freeze_order(GF_ISOFile *file)\n{\n\tu32 i=0;\n\tGF_Box *box;\n\tif (!file) return GF_BAD_PARAM;\n\twhile ((box=gf_list_enum(file->TopBoxes, &i))) {\n\t\tgf_isom_box_freeze_order(box);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "static void _out_result(conn_t out, nad_t nad) {\n    int attr;\n    jid_t from, to;\n    char *rkey;\n    int rkeylen;\n    attr = nad_find_attr(nad, 0, -1, \"from\", NULL);\n    if(attr < 0 || (from = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {\n        log_debug(ZONE, \"missing or invalid from on db result packet\");\n        nad_free(nad);\n        return;\n    }\n    attr = nad_find_attr(nad, 0, -1, \"to\", NULL);\n    if(attr < 0 || (to = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {\n        log_debug(ZONE, \"missing or invalid to on db result packet\");\n        jid_free(from);\n        nad_free(nad);\n        return;\n    }\n    rkey = s2s_route_key(NULL, to->domain, from->domain);\n    rkeylen = strlen(rkey);\n    if(nad_find_attr(nad, 0, -1, \"type\", \"valid\") >= 0) {\n        log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] outgoing route '%s' is now valid%s%s\", out->fd->fd, out->ip, out->port, rkey, (out->s->flags & SX_SSL_WRAPPER) ? \", TLS negotiated\" : \"\", out->s->compressed ? \", ZLIB compression enabled\" : \"\");\n        xhash_put(out->states, pstrdup(xhash_pool(out->states), rkey), (void *) conn_VALID);    \n        log_debug(ZONE, \"%s valid, flushing queue\", rkey);\n        out_flush_route_queue(out->s2s, rkey, rkeylen);\n        free(rkey);\n        jid_free(from);\n        jid_free(to);\n        nad_free(nad);\n        return;\n    }\n    log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] outgoing route '%s' is now invalid\", out->fd->fd, out->ip, out->port, rkey);\n    log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] closing connection\", out->fd->fd, out->ip, out->port);\n    sx_error(out->s, stream_err_INVALID_ID, \"dialback negotiation failed\");\n    sx_close(out->s);\n    out_bounce_route_queue(out->s2s, rkey, rkeylen, stanza_err_SERVICE_UNAVAILABLE);\n    free(rkey);\n    jid_free(from);\n    jid_free(to);\n    nad_free(nad);\n}", "target": 1}
{"code": "void nodeRename(Proxy &node, const RegexMatchConfigs &rename_array, extra_settings &ext)\n{\n    std::string &remark = node.Remark, original_remark = node.Remark, returned_remark, real_rule;\n    for(const RegexMatchConfig &x : rename_array)\n    {\n        if(!x.Script.empty())\n        {\n            script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)\n            {\n                std::string script = x.Script;\n                if(startsWith(script, \"path:\"))\n                    script = fileGet(script.substr(5), true);\n                try\n                {\n                    ctx.eval(script);\n                    auto rename = (std::function<std::string(const Proxy&)>) ctx.eval(\"rename\");\n                    returned_remark = rename(node);\n                    if(!returned_remark.empty())\n                        remark = returned_remark;\n                }\n                catch (qjs::exception)\n                {\n                    script_print_stack(ctx);\n                }\n            }, global.scriptCleanContext);\n            continue;\n        }\n        if(applyMatcher(x.Match, real_rule, node) && real_rule.size())\n            remark = regReplace(remark, real_rule, x.Replace);\n    }\n    if(remark.empty())\n        remark = original_remark;\n    return;\n}", "target": 1}
{"code": "int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tstruct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);\n\tint error = 0;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tconst char *name = NULL;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\terror = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (error < 0) {\n\t\t\t\tgossip_err(\"%s: posix_acl_equiv_mode err: %d\\n\",\n\t\t\t\t\t   __func__,\n\t\t\t\t\t   error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tif (inode->i_mode != mode)\n\t\t\t\tSetModeFlag(orangefs_inode);\n\t\t\tinode->i_mode = mode;\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tif (error == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tgossip_err(\"%s: invalid type %d!\\n\", __func__, type);\n\t\treturn -EINVAL;\n\t}\n\tgossip_debug(GOSSIP_ACL_DEBUG,\n\t\t     \"%s: inode %pU, key %s type %d\\n\",\n\t\t     __func__, get_khandle_from_ino(inode),\n\t\t     name,\n\t\t     type);\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn -ENOMEM;\n\t\terror = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\t}\n\tgossip_debug(GOSSIP_ACL_DEBUG,\n\t\t     \"%s: name %s, value %p, size %zd, acl %p\\n\",\n\t\t     __func__, name, value, size, acl);\n\terror = orangefs_inode_setxattr(inode, name, value, size, 0);\nout:\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}", "target": 1}
{"code": "static int check_func_proto(const struct bpf_func_proto *fn, int func_id)\n{\n\treturn check_raw_mode_ok(fn) &&\n\t       check_arg_pair_ok(fn) &&\n\t       check_btf_id_ok(fn) &&\n\t       check_refcount_ok(fn, func_id) ? 0 : -EINVAL;\n}", "target": 0}
{"code": "static u8 BS_ReadByte(GF_BitStream *bs)\n{\n\tBool is_eos;\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tu8 res;\n\t\tif (bs->position >= bs->size) {\n\t\t\tif (bs->EndOfStream) bs->EndOfStream(bs->par);\n\t\t\tif (!bs->overflow_state) bs->overflow_state = 1;\n\t\t\treturn 0;\n\t\t}\n\t\tres = bs->original[bs->position++];\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\tif ((bs->nb_zeros==2) && (res==0x03) && (bs->position<bs->size) && (bs->original[bs->position]<0x04)) {\n\t\t\t\tbs->nb_zeros = 0;\n\t\t\t\tres = bs->original[bs->position++];\n\t\t\t}\n\t\t\tif (!res) bs->nb_zeros++;\n\t\t\telse bs->nb_zeros = 0;\n\t\t}\n\t\treturn res;\n\t}\n\tif (bs->cache_write)\n\t\tbs_flush_write_cache(bs);\n\tis_eos = gf_feof(bs->stream);\n\tif (!is_eos || bs->cache_read) {\n\t\tu8 res;\n\t\tBool loc_eos=GF_FALSE;\n\t\tassert(bs->position<=bs->size);\n\t\tbs->position++;\n\t\tres = gf_bs_load_byte(bs, &loc_eos);\n\t\tif (loc_eos) goto bs_eof;\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\tif ((bs->nb_zeros==2) && (res==0x03) && (bs->position<bs->size)) {\n\t\t\t\tu8 next = gf_bs_load_byte(bs, &loc_eos);\n\t\t\t\tif (next < 0x04) {\n\t\t\t\t\tbs->nb_zeros = 0;\n\t\t\t\t\tres = next;\n\t\t\t\t\tbs->position++;\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_seek(bs, bs->position);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!res) bs->nb_zeros++;\n\t\t\telse bs->nb_zeros = 0;\n\t\t}\n\t\treturn res;\n\t}\nbs_eof:\n\tif (bs->EndOfStream) {\n\t\tbs->EndOfStream(bs->par);\n\t\tif (!bs->overflow_state) bs->overflow_state = 1;\n\t} else {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to overread bitstream\\n\"));\n\t}\n\tassert(bs->position <= 1+bs->size);\n\treturn 0;\n}", "target": 1}
{"code": "bool SQLiteDatabase::ExecuteCommand(const String& sql) {\n  return SQLiteStatement(*this, sql).ExecuteCommand();\n}", "target": 0}
{"code": "GF_Err moof_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs, moof_on_child_box);\n}", "target": 0}
{"code": "int AVI_read_frame(avi_t *AVI, u8 *vidbuf, int *keyframe)\n{\n\tint n;\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->video_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\tif(AVI->video_pos < 0 || AVI->video_pos >= AVI->video_frames) return -1;\n\tn = (u32) AVI->video_index[AVI->video_pos].len;\n\t*keyframe = (AVI->video_index[AVI->video_pos].key==0x10) ? 1:0;\n\tif (vidbuf == NULL) {\n\t\tAVI->video_pos++;\n\t\treturn n;\n\t}\n\tgf_fseek(AVI->fdes, AVI->video_index[AVI->video_pos].pos, SEEK_SET);\n\tif (avi_read(AVI->fdes,vidbuf,n) != (u32) n)\n\t{\n\t\tAVI_errno = AVI_ERR_READ;\n\t\treturn -1;\n\t}\n\tAVI->video_pos++;\n\treturn n;\n}", "target": 1}
{"code": "void PrintWebViewHelper::PrintPreviewContext::InitWithNode(\n    const WebKit::WebNode& web_node) {\n  DCHECK(!web_node.isNull());\n  DCHECK(!IsRendering());\n  state_ = INITIALIZED;\n  frame_ = web_node.document().frame();\n  node_ = web_node;\n}", "target": 0}
{"code": "static ssize_t module_xz_decompress(struct load_info *info,\n\t\t\t\t    const void *buf, size_t size)\n{\n\tstatic const u8 signature[] = { 0xfd, '7', 'z', 'X', 'Z', 0 };\n\tstruct xz_dec *xz_dec;\n\tstruct xz_buf xz_buf;\n\tenum xz_ret xz_ret;\n\tsize_t new_size = 0;\n\tssize_t retval;\n\tif (size < sizeof(signature) ||\n\t    memcmp(buf, signature, sizeof(signature))) {\n\t\tpr_err(\"not an xz compressed module\\n\");\n\t\treturn -EINVAL;\n\t}\n\txz_dec = xz_dec_init(XZ_DYNALLOC, (u32)-1);\n\tif (!xz_dec)\n\t\treturn -ENOMEM;\n\txz_buf.in_size = size;\n\txz_buf.in = buf;\n\txz_buf.in_pos = 0;\n\tdo {\n\t\tstruct page *page = module_get_next_page(info);\n\t\tif (!page) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\txz_buf.out = kmap_local_page(page);\n\t\txz_buf.out_pos = 0;\n\t\txz_buf.out_size = PAGE_SIZE;\n\t\txz_ret = xz_dec_run(xz_dec, &xz_buf);\n\t\tkunmap_local(xz_buf.out);\n\t\tnew_size += xz_buf.out_pos;\n\t} while (xz_buf.out_pos == PAGE_SIZE && xz_ret == XZ_OK);\n\tif (xz_ret != XZ_STREAM_END) {\n\t\tpr_err(\"decompression failed with status %d\\n\", xz_ret);\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\tretval = new_size;\n out:\n\txz_dec_end(xz_dec);\n\treturn retval;\n}", "target": 1}
{"code": "PackLinuxElf64::elf_find_dynamic(unsigned int key) const\n{\n    Elf64_Dyn const *dynp= dynseg;\n    if (dynp)\n    for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg\n            && Elf64_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te64(&dynp->d_tag)==key) {\n        upx_uint64_t const t= elf_get_offset_from_address(get_te64(&dynp->d_val));\n        if (t) {\n            return &((unsigned char const *)file_image)[(size_t)t];\n        }\n        break;\n    }\n    return 0;\n}", "target": 1}
{"code": "validate_commit_metadata (GVariant   *commit_data,\n                          const char *ref,\n                          const char *required_metadata,\n                          gsize       required_metadata_size,\n                          GError   **error)\n{\n  g_autoptr(GVariant) commit_metadata = NULL;\n  g_autoptr(GVariant) xa_metadata_v = NULL;\n  const char *xa_metadata = NULL;\n  gsize xa_metadata_size = 0;\n  commit_metadata = g_variant_get_child_value (commit_data, 0);\n  if (commit_metadata != NULL)\n    {\n      xa_metadata_v = g_variant_lookup_value (commit_metadata,\n                                              \"xa.metadata\",\n                                              G_VARIANT_TYPE_STRING);\n      if (xa_metadata_v)\n        xa_metadata = g_variant_get_string (xa_metadata_v, &xa_metadata_size);\n    }\n  if (xa_metadata == NULL ||\n      xa_metadata_size != required_metadata_size ||\n      memcmp (xa_metadata, required_metadata, xa_metadata_size) != 0)\n    {\n      g_set_error (error, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED,\n                   _(\"Commit metadata for %s not matching expected metadata\"), ref);\n      return FALSE;\n    }\n  return TRUE;\n}", "target": 0}
{"code": "static int seed_from_windows_cryptoapi(uint32_t *seed)\n{\n    HINSTANCE hAdvAPI32 = NULL;\n    CRYPTACQUIRECONTEXTA pCryptAcquireContext = NULL;\n    CRYPTGENRANDOM pCryptGenRandom = NULL;\n    CRYPTRELEASECONTEXT pCryptReleaseContext = NULL;\n    HCRYPTPROV hCryptProv = 0;\n    BYTE data[sizeof(uint32_t)];\n    int ok;\n    hAdvAPI32 = GetModuleHandle(\"advapi32.dll\");\n    if(hAdvAPI32 == NULL)\n        return 1;\n    pCryptAcquireContext = (CRYPTACQUIRECONTEXTA)GetProcAddress(hAdvAPI32, \"CryptAcquireContextA\");\n    if (!pCryptAcquireContext)\n        return 1;\n    pCryptGenRandom = (CRYPTGENRANDOM)GetProcAddress(hAdvAPI32, \"CryptGenRandom\");\n    if (!pCryptGenRandom)\n        return 1;\n    pCryptReleaseContext = (CRYPTRELEASECONTEXT)GetProcAddress(hAdvAPI32, \"CryptReleaseContext\");\n    if (!pCryptReleaseContext)\n        return 1;\n    if (!pCryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))\n        return 1;\n    ok = CryptGenRandom(hCryptProv, sizeof(uint32_t), data);\n    pCryptReleaseContext(hCryptProv, 0);\n    if (!ok)\n        return 1;\n    *seed = buf_to_uint32((char *)data);\n    return 0;\n}", "target": 0}
{"code": "static struct dst_entry *inet6_csk_route_socket(struct sock *sk,\n\t\t\t\t\t\tstruct flowi6 *fl6)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct in6_addr *final_p, final;\n\tstruct dst_entry *dst;\n\tmemset(fl6, 0, sizeof(*fl6));\n\tfl6->flowi6_proto = sk->sk_protocol;\n\tfl6->daddr = sk->sk_v6_daddr;\n\tfl6->saddr = np->saddr;\n\tfl6->flowlabel = np->flow_label;\n\tIP6_ECN_flow_xmit(sk, fl6->flowlabel);\n\tfl6->flowi6_oif = sk->sk_bound_dev_if;\n\tfl6->flowi6_mark = sk->sk_mark;\n\tfl6->fl6_sport = inet->inet_sport;\n\tfl6->fl6_dport = inet->inet_dport;\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(fl6));\n\tfinal_p = fl6_update_dst(fl6, np->opt, &final);\n\tdst = __inet6_csk_dst_check(sk, np->dst_cookie);\n\tif (!dst) {\n\t\tdst = ip6_dst_lookup_flow(sk, fl6, final_p);\n\t\tif (!IS_ERR(dst))\n\t\t\t__inet6_csk_dst_store(sk, dst, NULL, NULL);\n\t}\n\treturn dst;\n}", "target": 1}
{"code": "monitor_init(void)\n{\n\tstruct ssh *ssh = active_state;\t\t\t\n\tstruct monitor *mon;\n\tmon = xcalloc(1, sizeof(*mon));\n\tmonitor_openfds(mon, 1);\n\tif (options.compression) {\n\t\tmon->m_zback = mm_create(NULL, MM_MEMSIZE);\n\t\tmon->m_zlib = mm_create(mon->m_zback, 20 * MM_MEMSIZE);\n\t\tssh_packet_set_compress_hooks(ssh, mon->m_zlib,\n\t\t    (ssh_packet_comp_alloc_func *)mm_zalloc,\n\t\t    (ssh_packet_comp_free_func *)mm_zfree);\n\t}\n\treturn mon;\n}", "target": 1}
{"code": "str_lower_case_match(OnigEncoding enc, int case_fold_flag,\n                     const UChar* t, const UChar* tend,\n                     const UChar* p, const UChar* end)\n{\n  int lowlen;\n  UChar *q, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n  while (t < tend) {\n    lowlen = ONIGENC_MBC_CASE_FOLD(enc, case_fold_flag, &p, end, lowbuf);\n    q = lowbuf;\n    while (lowlen > 0) {\n      if (t >= tend)    return 0;\n      if (*t++ != *q++) return 0;\n      lowlen--;\n    }\n  }\n  return 1;\n}", "target": 0}
{"code": "static void regulator_ena_gpio_free(struct regulator_dev *rdev)\n{\n\tstruct regulator_enable_gpio *pin, *n;\n\tif (!rdev->ena_pin)\n\t\treturn;\n\tlist_for_each_entry_safe(pin, n, &regulator_ena_gpio_list, list) {\n\t\tif (pin->gpiod == rdev->ena_pin->gpiod) {\n\t\t\tif (pin->request_count <= 1) {\n\t\t\t\tpin->request_count = 0;\n\t\t\t\tgpiod_put(pin->gpiod);\n\t\t\t\tlist_del(&pin->list);\n\t\t\t\tkfree(pin);\n\t\t\t\trdev->ena_pin = NULL;\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tpin->request_count--;\n\t\t\t}\n\t\t}\n\t}\n}", "target": 0}
{"code": "static void HttpMultiBufHeaderThreadDataFree(void *data)\n{\n    HttpMultiBufHeaderThreadData *td = data;\n    for (size_t i = 0; i < td->cap; i++) {\n        SCFree(td->items[i].buffer);\n    }\n    SCFree(td->items);\n    SCFree(td);\n}", "target": 0}
{"code": "uint32_t virtio_config_readw(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint16_t val;\n    k->get_config(vdev, vdev->config);\n    if (addr > (vdev->config_len - sizeof(val)))\n        return (uint32_t)-1;\n    val = lduw_p(vdev->config + addr);\n    return val;\n}", "target": 1}
{"code": "static GF_SampleGroupDescriptionBox *get_sgdp(GF_SampleTableBox *stbl, void *traf, u32 grouping_type, Bool *is_traf_sgdp)\n#endif \n{\n\tGF_List *groupList=NULL;\n\tGF_List **parent=NULL;\n\tGF_SampleGroupDescriptionBox *sgdesc=NULL;\n\tu32 count, i;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!stbl && traf && traf->trex->track->Media->information->sampleTable)\n\t\tstbl = traf->trex->track->Media->information->sampleTable;\n#endif\n\tif (stbl) {\n\t\tif (!stbl->sampleGroupsDescription && !traf)\n\t\t\tstbl->sampleGroupsDescription = gf_list_new();\n\t\tgroupList = stbl->sampleGroupsDescription;\n\t\tif (is_traf_sgdp) *is_traf_sgdp = GF_FALSE;\n\t\tparent = &stbl->child_boxes;\n\t\tcount = gf_list_count(groupList);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(groupList, i);\n\t\t\tif (sgdesc->grouping_type==grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!sgdesc && traf) {\n\t\tif (!traf->sampleGroupsDescription)\n\t\t\ttraf->sampleGroupsDescription = gf_list_new();\n\t\tgroupList = traf->sampleGroupsDescription;\n\t\tparent = &traf->child_boxes;\n\t\tif (is_traf_sgdp) *is_traf_sgdp = GF_TRUE;\n\t\tcount = gf_list_count(groupList);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(groupList, i);\n\t\t\tif (sgdesc->grouping_type==grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n#endif\n\tif (!sgdesc) {\n\t\tsgdesc = (GF_SampleGroupDescriptionBox *) gf_isom_box_new_parent(parent, GF_ISOM_BOX_TYPE_SGPD);\n\t\tif (!sgdesc) return NULL;\n\t\tsgdesc->grouping_type = grouping_type;\n\t\tassert(groupList);\n\t\tgf_list_add(groupList, sgdesc);\n\t}\n\treturn sgdesc;\n}", "target": 1}
{"code": "static int tight_compress_data(VncState *vs, int stream_id, size_t bytes,\n                               int level, int strategy)\n{\n    z_streamp zstream = &vs->tight->stream[stream_id];\n    int previous_out;\n    if (bytes < VNC_TIGHT_MIN_TO_COMPRESS) {\n        vnc_write(vs, vs->tight->tight.buffer, vs->tight->tight.offset);\n        return bytes;\n    }\n    if (tight_init_stream(vs, stream_id, level, strategy)) {\n        return -1;\n    }\n    buffer_reserve(&vs->tight->zlib, bytes + 64);\n    zstream->next_in = vs->tight->tight.buffer;\n    zstream->avail_in = vs->tight->tight.offset;\n    zstream->next_out = vs->tight->zlib.buffer + vs->tight->zlib.offset;\n    zstream->avail_out = vs->tight->zlib.capacity - vs->tight->zlib.offset;\n    previous_out = zstream->avail_out;\n    zstream->data_type = Z_BINARY;\n    if (deflate(zstream, Z_SYNC_FLUSH) != Z_OK) {\n        fprintf(stderr, \"VNC: error during tight compression\\n\");\n        return -1;\n    }\n    vs->tight->zlib.offset = vs->tight->zlib.capacity - zstream->avail_out;\n    bytes = previous_out - zstream->avail_out;\n    tight_send_compact_size(vs, bytes);\n    vnc_write(vs, vs->tight->zlib.buffer, bytes);\n    buffer_reset(&vs->tight->zlib);\n    return bytes;\n}", "target": 0}
{"code": "  RectangleRequest(const struct RectangleRequest &req)\n    : Explicit()\n  {\n    memcpy(this,&req,sizeof(struct RectangleRequest));\n    rr_pNext = NULL;\n  }", "target": 1}
{"code": "inline bool ClientImpl::write_request(Stream &strm, Request &req,\n                                      bool close_connection, Error &error) {\n  if (close_connection) {\n    if (!req.has_header(\"Connection\")) {\n      req.headers.emplace(\"Connection\", \"close\");\n    }\n  }\n  if (!req.has_header(\"Host\")) {\n    if (is_ssl()) {\n      if (port_ == 443) {\n        req.headers.emplace(\"Host\", host_);\n      } else {\n        req.headers.emplace(\"Host\", host_and_port_);\n      }\n    } else {\n      if (port_ == 80) {\n        req.headers.emplace(\"Host\", host_);\n      } else {\n        req.headers.emplace(\"Host\", host_and_port_);\n      }\n    }\n  }\n  if (!req.has_header(\"Accept\")) { req.headers.emplace(\"Accept\", \"*", "target": 1}
{"code": "uint32_t mt_random (mtrand *mt) {\n  uint32_t y;\n  unsigned long mag01[2];\n  mag01[0] = 0;\n  mag01[1] = MATRIX_A;\n  if (mt->mt_index_ >= MT_LEN) {\n    int kk;\n    for (kk = 0; kk < MT_LEN - MT_IA; kk++) {\n      y = (mt->mt_buffer_[kk] & UPPER_MASK) | \n\t(mt->mt_buffer_[kk + 1] & LOWER_MASK);\n      mt->mt_buffer_[kk] = mt->mt_buffer_[kk + MT_IA] ^ \n\t(y >> 1) ^ mag01[y & 0x1UL];\n    }\n    for (;kk < MT_LEN - 1; kk++) {\n      y = (mt->mt_buffer_[kk] & UPPER_MASK) | \n\t(mt->mt_buffer_[kk + 1] & LOWER_MASK);\n      mt->mt_buffer_[kk] = mt->mt_buffer_[kk + (MT_IA - MT_LEN)] ^ \n\t(y >> 1) ^ mag01[y & 0x1UL];\n    }\n    y = (mt->mt_buffer_[MT_LEN - 1] & UPPER_MASK) | \n      (mt->mt_buffer_[0] & LOWER_MASK);\n    mt->mt_buffer_[MT_LEN - 1] = mt->mt_buffer_[MT_IA - 1] ^ \n      (y >> 1) ^ mag01[y & 0x1UL];\n    mt->mt_index_ = 0;\n  }\n  y = mt->mt_buffer_[mt->mt_index_++];\n  y ^= (y >> 11);\n  y ^= (y << 7) & 0x9d2c5680UL;\n  y ^= (y << 15) & 0xefc60000UL;\n  y ^= (y >> 18);\n  return y;\n}", "target": 1}
{"code": "gx_default_include_color_space(gx_device *pdev, gs_color_space *cspace,\n        const byte *res_name, int name_length)\n{\n    return 0;\n}", "target": 0}
{"code": "NOEXPORT int dh_init(SERVICE_OPTIONS *section) {\n    DH *dh=NULL;\n    int i, n;\n    char description[128];\n    STACK_OF(SSL_CIPHER) *ciphers;\n    section->option.dh_temp_params=0; \n    ciphers=SSL_CTX_get_ciphers(section->ctx);\n    if(!ciphers)\n        return 1; \n    n=sk_SSL_CIPHER_num(ciphers);\n    for(i=0; i<n; ++i) {\n        *description='\\0';\n        SSL_CIPHER_description(sk_SSL_CIPHER_value(ciphers, i),\n            description, sizeof description);\n        if(strstr(description, \" Kx=DH\")) {\n            s_log(LOG_INFO, \"DH initialization needed for %s\",\n                SSL_CIPHER_get_name(sk_SSL_CIPHER_value(ciphers, i)));\n            break;\n        }\n    }\n    if(i==n) { \n        s_log(LOG_INFO, \"DH initialization not needed\");\n        return 0; \n    }\n    s_log(LOG_DEBUG, \"DH initialization\");\n#ifndef OPENSSL_NO_ENGINE\n    if(!section->engine) \n#endif\n        dh=dh_read(section->cert);\n    if(dh) {\n        SSL_CTX_set_tmp_dh(section->ctx, dh);\n        s_log(LOG_INFO, \"%d-bit DH parameters loaded\", 8*DH_size(dh));\n        DH_free(dh);\n        return 0; \n    }\n    CRYPTO_THREAD_read_lock(stunnel_locks[LOCK_DH]);\n    SSL_CTX_set_tmp_dh(section->ctx, dh_params);\n    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_DH]);\n    dh_temp_params=1; \n    section->option.dh_temp_params=1; \n    s_log(LOG_INFO, \"Using dynamic DH parameters\");\n    return 0; \n}", "target": 1}
{"code": "struct mb2_cache_entry *mb2_cache_entry_find_next(struct mb2_cache *cache,\n\t\t\t\t\t\t  struct mb2_cache_entry *entry)\n{\n\treturn __entry_find(cache, entry, entry->e_key);\n}", "target": 0}
{"code": "TEST(EqOp, ElemMatchKeyWithImplicitAndExplicitTraversal) {\n    BSONObj operand = BSON(\"a.0.b\" << 3);\n    BSONElement operandFirstElt = operand.firstElement();\n    EqualityMatchExpression eq(operandFirstElt.fieldName(), operandFirstElt);\n    MatchDetails details;\n    details.requestElemMatchKey();\n    BSONObj obj = fromjson(\"{a: [{b: [2, 3]}, {b: [4, 5]}]}\");\n    ASSERT(eq.matchesBSON(obj, &details));\n    ASSERT(details.hasElemMatchKey());\n    ASSERT_EQUALS(\"1\", details.elemMatchKey());\n}", "target": 0}
{"code": "static UINT drive_process_irp_write(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tDRIVE_FILE* file;\n\tUINT32 Length;\n\tUINT64 Offset;\n\tif (!drive || !irp || !irp->input || !irp->output || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Read_UINT64(irp->input, Offset);\n\tStream_Seek(irp->input, 20); \n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\tif (!file)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_seek(file, Offset))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_write(file, Stream_Pointer(irp->input), Length))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\tStream_Write_UINT32(irp->output, Length);\n\tStream_Write_UINT8(irp->output, 0); \n\treturn irp->Complete(irp);\n}", "target": 1}
{"code": "rfc2253_name(X509_NAME *name, char **str_out)\n{\n    BIO *b = NULL;\n    char *str;\n    *str_out = NULL;\n    b = BIO_new(BIO_s_mem());\n    if (b == NULL)\n        return ENOMEM;\n    if (X509_NAME_print_ex(b, name, 0, XN_FLAG_SEP_COMMA_PLUS) < 0)\n        goto error;\n    str = calloc(BIO_number_written(b) + 1, 1);\n    if (str == NULL)\n        goto error;\n    BIO_read(b, str, BIO_number_written(b));\n    BIO_free(b);\n    *str_out = str;\n    return 0;\nerror:\n    BIO_free(b);\n    return ENOMEM;\n}", "target": 0}
{"code": "TEST_P(RedirectIntegrationTest, InternalRedirectHandledByDirectResponse) {\n  useAccessLog(\"%RESPONSE_FLAGS% %RESPONSE_CODE% %RESPONSE_CODE_DETAILS% %RESP(test-header)%\");\n  config_helper_.addConfigModifier(\n      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n             hcm) { hcm.set_via(\"via_value\"); });\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  default_request_headers_.setHost(\"handle.internal.redirect\");\n  IntegrationStreamDecoderPtr response =\n      codec_client_->makeHeaderOnlyRequest(default_request_headers_);\n  waitForNextUpstreamRequest();\n  redirect_response_.setLocation(\"http:\n  upstream_request_->encodeHeaders(redirect_response_, true);\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"204\", response->headers().getStatusValue());\n  EXPECT_EQ(1, test_server_->counter(\"cluster.cluster_0.upstream_internal_redirect_succeeded_total\")\n                   ->value());\n  EXPECT_EQ(0, test_server_->counter(\"http.config_test.downstream_rq_3xx\")->value());\n  EXPECT_EQ(1, test_server_->counter(\"http.config_test.downstream_rq_2xx\")->value());\n  EXPECT_THAT(waitForAccessLog(access_log_name_, 0),\n              HasSubstr(\"302 internal_redirect test-header-value\\n\"));\n  EXPECT_THAT(waitForAccessLog(access_log_name_, 1), HasSubstr(\"204 direct_response -\\n\"));\n}", "target": 0}
{"code": "}\nvoid print_udta(GF_ISOFile *file, u32 track_number, Bool has_itags)\n{\n\tu32 i, count;\n\tcount =  gf_isom_get_udta_count(file, track_number);\n\tif (!count) return;\n\tif (has_itags) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu32 type;\n\t\t\tbin128 uuid;\n\t\t\tgf_isom_get_udta_type(file, track_number, i+1, &type, &uuid);\n\t\t\tif (type == GF_ISOM_BOX_TYPE_META) {\n\t\t\t\tcount--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!count) return;\n\t}\n\tfprintf(stderr, \"%d UDTA types: \", count);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j, type, nb_items, first=GF_TRUE;\n\t\tbin128 uuid;\n\t\tgf_isom_get_udta_type(file, track_number, i+1, &type, &uuid);\n\t\tnb_items = gf_isom_get_user_data_count(file, track_number, type, uuid);\n\t\tfprintf(stderr, \"%s (%d) \", gf_4cc_to_str(type), nb_items);\n\t\tfor (j=0; j<nb_items; j++) {\n\t\t\tu8 *udta=NULL;\n\t\t\tu32 udta_size;\n\t\t\tgf_isom_get_user_data(file, track_number, type, uuid, j+1, &udta, &udta_size);\n\t\t\tif (!udta) continue;\n\t\t\tif (gf_utf8_is_legal(udta, udta_size)) {\n\t\t\t\tif (first) {\n\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\tfirst = GF_FALSE;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\t%s\\n\", (char *) udta);\n\t\t\t}\n\t\t\tgf_free(udta);\n\t\t}\n\t}", "target": 1}
{"code": "int cma_get_default_gid_type(struct cma_device *cma_dev,\n\t\t\t     u32 port)\n{\n\tif (!rdma_is_port_valid(cma_dev->device, port))\n\t\treturn -EINVAL;\n\treturn cma_dev->default_gid_type[port - rdma_start_port(cma_dev->device)];\n}", "target": 0}
{"code": "static int ext4_write_end(struct file *file,\n\t\t\t  struct address_space *mapping,\n\t\t\t  loff_t pos, unsigned len, unsigned copied,\n\t\t\t  struct page *page, void *fsdata)\n{\n\thandle_t *handle = ext4_journal_current_handle();\n\tstruct inode *inode = mapping->host;\n\tloff_t old_size = inode->i_size;\n\tint ret = 0, ret2;\n\tint i_size_changed = 0;\n\ttrace_ext4_write_end(inode, pos, len, copied);\n\tif (ext4_test_inode_state(inode, EXT4_STATE_ORDERED_MODE)) {\n\t\tret = ext4_jbd2_file_inode(handle, inode);\n\t\tif (ret) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto errout;\n\t\t}\n\t}\n\tif (ext4_has_inline_data(inode)) {\n\t\tret = ext4_write_inline_data_end(inode, pos, len,\n\t\t\t\t\t\t copied, page);\n\t\tif (ret < 0)\n\t\t\tgoto errout;\n\t\tcopied = ret;\n\t} else\n\t\tcopied = block_write_end(file, mapping, pos,\n\t\t\t\t\t len, copied, page, fsdata);\n\ti_size_changed = ext4_update_inode_size(inode, pos + copied);\n\tunlock_page(page);\n\tput_page(page);\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\tif (i_size_changed)\n\t\text4_mark_inode_dirty(handle, inode);\n\tif (pos + len > inode->i_size && ext4_can_truncate(inode))\n\t\text4_orphan_add(handle, inode);\nerrout:\n\tret2 = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = ret2;\n\tif (pos + len > inode->i_size) {\n\t\text4_truncate_failed_write(inode);\n\t\tif (inode->i_nlink)\n\t\t\text4_orphan_del(NULL, inode);\n\t}\n\treturn ret ? ret : copied;\n}", "target": 1}
{"code": "ppmd_read(void *p)\n{\n  struct archive_read *a = ((IByteIn*)p)->a;\n  struct rar *rar = (struct rar *)(a->format->data);\n  struct rar_br *br = &(rar->br);\n  Byte b;\n  if (!rar_br_read_ahead(a, br, 8))\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Truncated RAR file data\");\n    rar->valid = 0;\n    return 0;\n  }\n  b = rar_br_bits(br, 8);\n  rar_br_consume(br, 8);\n  return b;\n}", "target": 0}
{"code": "test_js (void) {\n    GString *result = g_string_new(\"\");\n    parse_cmd_line(\"js ('x' + 345).toUpperCase()\", result);\n    g_assert_cmpstr(\"X345\", ==, result->str);\n    uzbl.net.useragent = \"Test useragent\";\n    parse_cmd_line(\"js Uzbl.run('print @useragent').toUpperCase();\", result);\n    g_assert_cmpstr(\"TEST USERAGENT\", ==, result->str);\n    g_string_free(result, TRUE);\n}", "target": 1}
{"code": "  explicit FractionalAvgPoolOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"pooling_ratio\", &pooling_ratio_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"pseudo_random\", &pseudo_random_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"overlapping\", &overlapping_));\n    OP_REQUIRES(context, pooling_ratio_.size() == 4,\n                errors::InvalidArgument(\n                    \"pooling_ratio field must specify 4 dimensions\"));\n    for (std::size_t i = 0; i < pooling_ratio_.size(); ++i) {\n      OP_REQUIRES(context, pooling_ratio_[i] >= 1,\n                  errors::InvalidArgument(\n                      \"pooling_ratio cannot be smaller than 1, got: \",\n                      pooling_ratio_[i]));\n    }\n    OP_REQUIRES(\n        context, pooling_ratio_[0] == 1 || pooling_ratio_[3] == 1,\n        errors::Unimplemented(\"Fractional average pooling is not yet \"\n                              \"supported on the batch nor channel dimension.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"deterministic\", &deterministic_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed\", &seed_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed2\", &seed2_));\n    if (deterministic_) {\n      if ((seed_ == 0) && (seed2_ == 0)) {\n        seed_ = random::New64();\n        seed2_ = random::New64();\n      }\n    } else {\n      OP_REQUIRES(\n          context, (seed_ == 0) && (seed2_ == 0),\n          errors::InvalidArgument(\n              \"Both seed and seed2 should be 0 if deterministic is false.\"));\n    }\n  }", "target": 0}
{"code": "header_put_marker (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)\n\t{\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} ", "target": 1}
{"code": "static void bdrv_cloop_init(void)\n{\n    bdrv_register(&bdrv_cloop);\n}", "target": 0}
{"code": "static void run(int argc, const char *const argv[],\n        const char *name, void (*init)(const char * const argv[]))\n{\n    int rv;\n    bool user_config;\n    const char *argv_out[argc+4], *new_argv[argc+4];\n    int argc_out;\n    char conf_file[OGS_MAX_FILEPATH_LEN];\n    user_config = false;\n    for (argc_out = 0; argc_out < argc; argc_out++) {\n        if (strcmp(\"-c\", argv[argc_out]) == 0) {\n            user_config = true; \n        }\n        argv_out[argc_out] = argv[argc_out];\n    }\n    argv_out[argc_out] = NULL;\n    if (!user_config) {\n        ogs_snprintf(conf_file, sizeof conf_file, \"%s%s\",\n            MESON_BUILD_ROOT OGS_DIR_SEPARATOR_S\n            \"configs\" OGS_DIR_SEPARATOR_S, name);\n        argv_out[argc_out++] = \"-c\";\n        argv_out[argc_out++] = conf_file;\n        argv_out[argc_out] = NULL;\n    }\n    argv_out[0] = MESON_BUILD_ROOT OGS_DIR_SEPARATOR_S \n            \"src\" OGS_DIR_SEPARATOR_S \"open5gs-main\";\n    rv = abts_main(argc_out, argv_out, new_argv);\n    ogs_assert(rv == OGS_OK);\n    (*init)(new_argv);\n}", "target": 1}
{"code": "static jboolean Region_getBounds(JNIEnv* env, jobject, jlong regionHandle, jobject rectBounds) {\n SkRegion* region = reinterpret_cast<SkRegion*>(regionHandle);\n GraphicsJNI::irect_to_jrect(region->getBounds(), env, rectBounds);\n bool result = !region->isEmpty();\n return boolTojboolean(result);\n}", "target": 0}
{"code": "router_get_hashes_impl(const char *s, size_t s_len, digests_t *digests,\n                       const char *start_str,\n                       const char *end_str, char end_c)\n{\n  const char *start=NULL, *end=NULL;\n  if (router_get_hash_impl_helper(s,s_len,start_str,end_str,end_c,\n                                  &start,&end)<0)\n    return -1;\n  if (crypto_digest_all(digests, start, end-start)) {\n    log_warn(LD_BUG,\"couldn't compute digests\");\n    return -1;\n  }\n  return 0;\n}", "target": 0}
{"code": "static bool is_valid_guid(const char *guid) {\n\tif (!guid) {\n\t\treturn false;\n\t}\n\tsize_t i;\n\tfor (i = 0; guid[i]; i++) {\n\t\tif (!isxdigit (guid[i])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn i >= 33; \n}", "target": 0}
{"code": "static void cjson_get_object_item_should_not_crash_with_array(void) {\n    cJSON *array = NULL;\n    cJSON *found = NULL;\n    array = cJSON_Parse(\"[1]\");\n    found = cJSON_GetObjectItem(array, \"name\");\n    TEST_ASSERT_NULL(found);\n    cJSON_Delete(array);\n}", "target": 0}
{"code": "void Huff_transmit (huff_t *huff, int ch, byte *fout) {\n\tint i;\n\tif (huff->loc[ch] == NULL) { \n\t\tHuff_transmit(huff, NYT, fout);\n\t\tfor (i = 7; i >= 0; i--) {\n\t\t\tadd_bit((char)((ch >> i) & 0x1), fout);\n\t\t}\n\t} else {\n\t\tsend(huff->loc[ch], NULL, fout);\n\t}\n}", "target": 1}
{"code": "parserule(struct scanner *s, struct environment *env)\n{\n\tstruct rule *r;\n\tchar *var;\n\tstruct evalstring *val;\n\tbool hascommand = false, hasrspfile = false, hasrspcontent = false;\n\tr = mkrule(scanname(s));\n\tscannewline(s);\n\twhile (scanindent(s)) {\n\t\tvar = scanname(s);\n\t\tparselet(s, &val);\n\t\truleaddvar(r, var, val);\n\t\tif (!val)\n\t\t\tcontinue;\n\t\tif (strcmp(var, \"command\") == 0)\n\t\t\thascommand = true;\n\t\telse if (strcmp(var, \"rspfile\") == 0)\n\t\t\thasrspfile = true;\n\t\telse if (strcmp(var, \"rspfile_content\") == 0)\n\t\t\thasrspcontent = true;\n\t}\n\tif (!hascommand)\n\t\tfatal(\"rule '%s' has no command\", r->name);\n\tif (hasrspfile != hasrspcontent)\n\t\tfatal(\"rule '%s' has rspfile and no rspfile_content or vice versa\", r->name);\n\tenvaddrule(env, r);\n}", "target": 0}
{"code": "static int sclp_ctl_ioctl_sccb(void __user *user_area)\n{\n\tstruct sclp_ctl_sccb ctl_sccb;\n\tstruct sccb_header *sccb;\n\tint rc;\n\tif (copy_from_user(&ctl_sccb, user_area, sizeof(ctl_sccb)))\n\t\treturn -EFAULT;\n\tif (!sclp_ctl_cmdw_supported(ctl_sccb.cmdw))\n\t\treturn -EOPNOTSUPP;\n\tsccb = (void *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\n\tif (!sccb)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(sccb, u64_to_uptr(ctl_sccb.sccb), sizeof(*sccb))) {\n\t\trc = -EFAULT;\n\t\tgoto out_free;\n\t}\n\tif (sccb->length > PAGE_SIZE || sccb->length < 8)\n\t\treturn -EINVAL;\n\tif (copy_from_user(sccb, u64_to_uptr(ctl_sccb.sccb), sccb->length)) {\n\t\trc = -EFAULT;\n\t\tgoto out_free;\n\t}\n\trc = sclp_sync_request(ctl_sccb.cmdw, sccb);\n\tif (rc)\n\t\tgoto out_free;\n\tif (copy_to_user(u64_to_uptr(ctl_sccb.sccb), sccb, sccb->length))\n\t\trc = -EFAULT;\nout_free:\n\tfree_page((unsigned long) sccb);\n\treturn rc;\n}", "target": 1}
{"code": "daemon_AuthUserPwd(char *username, char *password, char *errbuf)\n{\n#ifdef _WIN32\n\tHANDLE Token;\n\tif (LogonUser(username, \".\", password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"LogonUser() failed\");\n\t\treturn -1;\n\t}\n\tif (ImpersonateLoggedOnUser(Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"ImpersonateLoggedOnUser() failed\");\n\t\tCloseHandle(Token);\n\t\treturn -1;\n\t}\n\tCloseHandle(Token);\n\treturn 0;\n#else\n\tstruct passwd *user;\n\tchar *user_password;\n#ifdef HAVE_GETSPNAM\n\tstruct spwd *usersp;\n#endif\n\tif ((user = getpwnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n#ifdef HAVE_GETSPNAM\n\tif ((usersp = getspnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n\tuser_password = usersp->sp_pwdp;\n#else\n\tuser_password = user->pw_passwd;\n#endif\n\tif (strcmp(user_password, (char *) crypt(password, user_password)) != 0)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n\tif (setuid(user->pw_uid))\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setuid\");\n\t\treturn -1;\n\t}\n\treturn 0;\n#endif\n}", "target": 1}
{"code": "static int is_fuse_usermount(struct libmnt_context *cxt, int *errsv)\n{\n\tstruct libmnt_ns *ns_old;\n\tconst char *type = mnt_fs_get_fstype(cxt->fs);\n\tconst char *optstr;\n\tchar *user_id = NULL;\n\tsize_t sz;\n\tuid_t uid;\n\tchar uidstr[sizeof(stringify_value(ULONG_MAX))];\n\t*errsv = 0;\n\tif (!type)\n\t\treturn 0;\n\tif (strcmp(type, \"fuse\") != 0 &&\n\t    strcmp(type, \"fuseblk\") != 0 &&\n\t    strncmp(type, \"fuse.\", 5) != 0 &&\n\t    strncmp(type, \"fuseblk.\", 8) != 0)\n\t\treturn 0;\n\toptstr = mnt_fs_get_fs_options(cxt->fs);\n\tif (!optstr)\n\t\treturn 0;\n\tif (mnt_optstr_get_option(optstr, \"user_id\", &user_id, &sz) != 0)\n\t\treturn 0;\n\tif (sz == 0 || user_id == NULL)\n\t\treturn 0;\n\tns_old = mnt_context_switch_origin_ns(cxt);\n\tif (!ns_old) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\tuid = getuid();\n\tif (!mnt_context_switch_ns(cxt, ns_old)) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\tsnprintf(uidstr, sizeof(uidstr), \"%lu\", (unsigned long) uid);\n\treturn strncmp(user_id, uidstr, sz) == 0;\n}", "target": 1}
{"code": "static int rb_head_page_set(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t    struct buffer_page *head,\n\t\t\t    struct buffer_page *prev,\n\t\t\t    int old_flag, int new_flag)\n{\n\tstruct list_head *list;\n\tunsigned long val = (unsigned long)&head->list;\n\tunsigned long ret;\n\tlist = &prev->list;\n\tval &= ~RB_FLAG_MASK;\n\tret = cmpxchg((unsigned long *)&list->next,\n\t\t      val | old_flag, val | new_flag);\n\tif ((ret & ~RB_FLAG_MASK) != val)\n\t\treturn RB_PAGE_MOVED;\n\treturn ret & RB_FLAG_MASK;\n}", "target": 0}
{"code": "void nft_byteorder_eval(const struct nft_expr *expr,\n\t\t\tstruct nft_regs *regs,\n\t\t\tconst struct nft_pktinfo *pkt)\n{\n\tconst struct nft_byteorder *priv = nft_expr_priv(expr);\n\tu32 *src = &regs->data[priv->sreg];\n\tu32 *dst = &regs->data[priv->dreg];\n\tu16 *s16, *d16;\n\tunsigned int i;\n\ts16 = (void *)src;\n\td16 = (void *)dst;\n\tswitch (priv->size) {\n\tcase 8: {\n\t\tu64 src64;\n\t\tswitch (priv->op) {\n\t\tcase NFT_BYTEORDER_NTOH:\n\t\t\tfor (i = 0; i < priv->len / 8; i++) {\n\t\t\t\tsrc64 = nft_reg_load64(&src[i]);\n\t\t\t\tnft_reg_store64(&dst[i],\n\t\t\t\t\t\tbe64_to_cpu((__force __be64)src64));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NFT_BYTEORDER_HTON:\n\t\t\tfor (i = 0; i < priv->len / 8; i++) {\n\t\t\t\tsrc64 = (__force __u64)\n\t\t\t\t\tcpu_to_be64(nft_reg_load64(&src[i]));\n\t\t\t\tnft_reg_store64(&dst[i], src64);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase 4:\n\t\tswitch (priv->op) {\n\t\tcase NFT_BYTEORDER_NTOH:\n\t\t\tfor (i = 0; i < priv->len / 4; i++)\n\t\t\t\tdst[i] = ntohl((__force __be32)src[i]);\n\t\t\tbreak;\n\t\tcase NFT_BYTEORDER_HTON:\n\t\t\tfor (i = 0; i < priv->len / 4; i++)\n\t\t\t\tdst[i] = (__force __u32)htonl(src[i]);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tswitch (priv->op) {\n\t\tcase NFT_BYTEORDER_NTOH:\n\t\t\tfor (i = 0; i < priv->len / 2; i++)\n\t\t\t\td16[i] = ntohs((__force __be16)s16[i]);\n\t\t\tbreak;\n\t\tcase NFT_BYTEORDER_HTON:\n\t\t\tfor (i = 0; i < priv->len / 2; i++)\n\t\t\t\td16[i] = (__force __u16)htons(s16[i]);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "static int dccp_error(struct net *net, struct nf_conn *tmpl,\n\t\t      struct sk_buff *skb, unsigned int dataoff,\n\t\t      enum ip_conntrack_info *ctinfo,\n\t\t      u_int8_t pf, unsigned int hooknum)\n{\n\tstruct dccp_hdr _dh, *dh;\n\tunsigned int dccp_len = skb->len - dataoff;\n\tunsigned int cscov;\n\tconst char *msg;\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n\tif (dh == NULL) {\n\t\tmsg = \"nf_ct_dccp: short packet \";\n\t\tgoto out_invalid;\n\t}\n\tif (dh->dccph_doff * 4 < sizeof(struct dccp_hdr) ||\n\t    dh->dccph_doff * 4 > dccp_len) {\n\t\tmsg = \"nf_ct_dccp: truncated/malformed packet \";\n\t\tgoto out_invalid;\n\t}\n\tcscov = dccp_len;\n\tif (dh->dccph_cscov) {\n\t\tcscov = (dh->dccph_cscov - 1) * 4;\n\t\tif (cscov > dccp_len) {\n\t\t\tmsg = \"nf_ct_dccp: bad checksum coverage \";\n\t\t\tgoto out_invalid;\n\t\t}\n\t}\n\tif (net->ct.sysctl_checksum && hooknum == NF_INET_PRE_ROUTING &&\n\t    nf_checksum_partial(skb, hooknum, dataoff, cscov, IPPROTO_DCCP,\n\t\t\t\tpf)) {\n\t\tmsg = \"nf_ct_dccp: bad checksum \";\n\t\tgoto out_invalid;\n\t}\n\tif (dh->dccph_type >= DCCP_PKT_INVALID) {\n\t\tmsg = \"nf_ct_dccp: reserved packet type \";\n\t\tgoto out_invalid;\n\t}\n\treturn NF_ACCEPT;\nout_invalid:\n\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\tnf_log_packet(net, pf, 0, skb, NULL, NULL, NULL, \"%s\", msg);\n\treturn -NF_ACCEPT;\n}", "target": 1}
{"code": "GF_Err gf_isom_avc_config_update(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_AVCConfig *cfg)\n{\n\treturn gf_isom_avc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, 0, GF_FALSE);\n}", "target": 0}
{"code": "void TestSocketLineReader::badData()\n{\n    const QList<QByteArray> dataToSend = { \"data1\\n\", \"data\" }; \n    for (const QByteArray& line : qAsConst(dataToSend)) {\n        m_conn->write(line);\n    }\n    m_conn->flush();\n    QSignalSpy spy(m_server, &QTcpServer::newConnection);\n    QVERIFY(m_server->hasPendingConnections() || spy.wait(1000));\n    QSslSocket* sock = m_server->nextPendingConnection();\n    QVERIFY2(sock != nullptr, \"Could not open a connection to the client\");\n    m_reader = new SocketLineReader(sock, this);\n    connect(m_reader, &SocketLineReader::readyRead, this, &TestSocketLineReader::newPacket);\n    m_timer.start();\n    m_loop.exec();\n    QCOMPARE(m_packets.count(), 1);\n    QCOMPARE(m_packets[0], dataToSend[0]);\n}", "target": 0}
{"code": "const u32 *gf_isom_get_track_switch_parameter(GF_ISOFile *movie, u32 trackNumber, u32 group_index, u32 *switchGroupID, u32 *criteriaListSize)\n{\n\tGF_TrackBox *trak;\n\tGF_UserDataMap *map;\n\tGF_TrackSelectionBox *tsel;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!group_index || !trak || !trak->udta) return NULL;\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\tif (!map) return NULL;\n\ttsel = (GF_TrackSelectionBox*)gf_list_get(map->boxes, group_index-1);\n\tif (!tsel) return NULL;\n\t*switchGroupID = tsel->switchGroup;\n\t*criteriaListSize = tsel->attributeListCount;\n\treturn (const u32 *) tsel->attributeList;\n}", "target": 0}
{"code": "test_read_integer_error (xd3_stream *stream, usize_t trunto, const char *msg)\n{\n  uint64_t eval = 1ULL << 34;\n  uint32_t rval;\n  xd3_output *buf = NULL;\n  const uint8_t *max;\n  const uint8_t *inp;\n  int ret;\n  buf = xd3_alloc_output (stream, buf);\n  if ((ret = xd3_emit_uint64_t (stream, & buf, eval)))\n    {\n      goto fail;\n    }\n again:\n  inp = buf->base;\n  max = buf->base + buf->next - trunto;\n  if ((ret = xd3_read_uint32_t (stream, & inp, max, & rval)) != \n      XD3_INVALID_INPUT ||\n      !MSG_IS (msg))\n    {\n      ret = XD3_INTERNAL;\n    }\n  else if (trunto && trunto < buf->next)\n    {\n      trunto += 1;\n      goto again;\n    }\n  else\n    {\n      ret = 0;\n    }\n fail:\n  xd3_free_output (stream, buf);\n  return ret;\n}", "target": 1}
{"code": "  Logger* logger() {\n    ASSERT(logger_ != NULL);\n    return logger_;\n  }", "target": 0}
{"code": "search_impl(i_ctx_t *i_ctx_p, bool forward)\n{\n    os_ptr op = osp;\n    os_ptr op1 = op - 1;\n    uint size = r_size(op);\n    uint count;\n    byte *pat;\n    byte *ptr;\n    byte ch;\n    int incr = forward ? 1 : -1;\n    check_read_type(*op1, t_string);\n    check_read_type(*op, t_string);\n    if (size > r_size(op1)) {\t\n        make_false(op);\n        return 0;\n    }\n    count = r_size(op1) - size;\n    ptr = op1->value.bytes;\n    if (size == 0)\n        goto found;\n    if (!forward)\n        ptr += count;\n    pat = op->value.bytes;\n    ch = pat[0];\n    do {\n        if (*ptr == ch && (size == 1 || !memcmp(ptr, pat, size)))\n            goto found;\n        ptr += incr;\n    }\n    while (count--);\n    make_false(op);\n    return 0;\nfound:\n    op->tas.type_attrs = op1->tas.type_attrs;\n    op->value.bytes = ptr;\n    r_set_size(op, size);\n    push(2);\n    op[-1] = *op1;\n    r_set_size(op - 1, ptr - op[-1].value.bytes);\n    op1->value.bytes = ptr + size;\n    r_set_size(op1, count + (!forward ? (size - 1) : 0));\n    make_true(op);\n    return 0;\n}", "target": 1}
{"code": "Napi::Object Statement::Init(Napi::Env env, Napi::Object exports) {\n    Napi::HandleScope scope(env);\n    Napi::Function t = DefineClass(env, \"Statement\", {\n      InstanceMethod(\"bind\", &Statement::Bind),\n      InstanceMethod(\"get\", &Statement::Get),\n      InstanceMethod(\"run\", &Statement::Run),\n      InstanceMethod(\"all\", &Statement::All),\n      InstanceMethod(\"each\", &Statement::Each),\n      InstanceMethod(\"reset\", &Statement::Reset),\n      InstanceMethod(\"finalize\", &Statement::Finalize_),\n    });\n    exports.Set(\"Statement\", t);\n    return exports;\n}", "target": 0}
{"code": "static int read_file_dentry_set(struct exfat_de_iter *iter,\n\t\t\t\tstruct exfat_inode **new_node, int *skip_dentries)\n{\n\tstruct exfat_dentry *file_de, *stream_de, *dentry;\n\tstruct exfat_inode *node = NULL;\n\tint i, ret;\n\tret = exfat_de_iter_get(iter, 0, &file_de);\n\tif (ret || file_de->type != EXFAT_FILE) {\n\t\texfat_debug(\"failed to get file dentry\\n\");\n\t\treturn -EINVAL;\n\t}\n\tret = exfat_de_iter_get(iter, 1, &stream_de);\n\tif (ret || stream_de->type != EXFAT_STREAM) {\n\t\texfat_debug(\"failed to get stream dentry\\n\");\n\t\t*skip_dentries = 2;\n\t\tgoto skip_dset;\n\t}\n\t*new_node = NULL;\n\tnode = exfat_alloc_inode(le16_to_cpu(file_de->file_attr));\n\tif (!node)\n\t\treturn -ENOMEM;\n\tfor (i = 2; i <= file_de->file_num_ext; i++) {\n\t\tret = exfat_de_iter_get(iter, i, &dentry);\n\t\tif (ret || dentry->type != EXFAT_NAME)\n\t\t\tbreak;\n\t\tmemcpy(node->name +\n\t\t       (i - 2) * ENTRY_NAME_MAX, dentry->name_unicode,\n\t\t       sizeof(dentry->name_unicode));\n\t}\n\tnode->first_clus = le32_to_cpu(stream_de->stream_start_clu);\n\tnode->is_contiguous =\n\t\t((stream_de->stream_flags & EXFAT_SF_CONTIGUOUS) != 0);\n\tnode->size = le64_to_cpu(stream_de->stream_size);\n\t*skip_dentries = i;\n\t*new_node = node;\n\treturn 0;\nskip_dset:\n\t*new_node = NULL;\n\texfat_free_inode(node);\n\treturn -EINVAL;\n}", "target": 1}
{"code": "uint32_t virtio_config_readb(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint8_t val;\n    k->get_config(vdev, vdev->config);\n    if (addr > (vdev->config_len - sizeof(val)))\n        return (uint32_t)-1;\n    val = ldub_p(vdev->config + addr);\n    return val;\n}", "target": 1}
{"code": "MONGO_EXPORT int mongo_insert_batch( mongo *conn, const char *ns,\n                                     const bson **bsons, int count, mongo_write_concern *custom_write_concern,\n                                     int flags ) {\n    mongo_message *mm;\n    mongo_write_concern *write_concern = NULL;\n    int i;\n    char *data;\n    int overhead =  16 + 4 + strlen( ns ) + 1;\n    int size = overhead;\n    if( mongo_validate_ns( conn, ns ) != MONGO_OK )\n        return MONGO_ERROR;\n    for( i=0; i<count; i++ ) {\n        size += bson_size( bsons[i] );\n        if( mongo_bson_valid( conn, bsons[i], 1 ) != MONGO_OK )\n            return MONGO_ERROR;\n    }\n    if( ( size - overhead ) > conn->max_bson_size ) {\n        conn->err = MONGO_BSON_TOO_LARGE;\n        return MONGO_ERROR;\n    }\n    if( mongo_choose_write_concern( conn, custom_write_concern,\n                                    &write_concern ) == MONGO_ERROR ) {\n        return MONGO_ERROR;\n    }\n    mm = mongo_message_create( size , 0 , 0 , MONGO_OP_INSERT );\n    data = &mm->data;\n    if( flags & MONGO_CONTINUE_ON_ERROR )\n        data = mongo_data_append32( data, &ONE );\n    else\n        data = mongo_data_append32( data, &ZERO );\n    data = mongo_data_append( data, ns, strlen( ns ) + 1 );\n    for( i=0; i<count; i++ ) {\n        data = mongo_data_append( data, bsons[i]->data, bson_size( bsons[i] ) );\n    }\n    if( write_concern ) {\n        if( mongo_message_send( conn, mm ) == MONGO_ERROR ) {\n            return MONGO_ERROR;\n        }\n        return mongo_check_last_error( conn, ns, write_concern );\n    }\n    else {\n        return mongo_message_send( conn, mm );\n    }\n}", "target": 1}
{"code": "RecordPadAlign(int size, int align)\n{\n    return (align - (size & (align - 1))) & (align - 1);\n}                               ", "target": 0}
{"code": "WebKit::WebView* RenderView::webview() const {\n  return static_cast<WebKit::WebView*>(webwidget());\n}", "target": 0}
{"code": "mm_share_sync(struct mm_master **pmm, struct mm_master **pmmalloc)\n{\n\tstruct mm_master *mm;\n\tstruct mm_master *mmalloc;\n\tstruct mm_master *mmold;\n\tstruct mmtree rb_free, rb_allocated;\n\tdebug3(\"%s: Share sync\", __func__);\n\tmm = *pmm;\n\tmmold = mm->mmalloc;\n\tmm_memvalid(mmold, mm, sizeof(*mm));\n\tmmalloc = mm_create(NULL, mm->size);\n\tmm = mm_xmalloc(mmalloc, sizeof(struct mm_master));\n\tmemcpy(mm, *pmm, sizeof(struct mm_master));\n\tmm->mmalloc = mmalloc;\n\trb_free = mm->rb_free;\n\trb_allocated = mm->rb_allocated;\n\tRB_INIT(&mm->rb_free);\n\tRB_INIT(&mm->rb_allocated);\n\tmm_sync_list(&rb_free, &mm->rb_free, mm, mmold);\n\tmm_sync_list(&rb_allocated, &mm->rb_allocated, mm, mmold);\n\tmm_destroy(mmold);\n\t*pmm = mm;\n\t*pmmalloc = mmalloc;\n\tdebug3(\"%s: Share sync end\", __func__);\n}", "target": 1}
{"code": "int nfc_dep_link_down(struct nfc_dev *dev)\n{\n\tint rc = 0;\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\tif (!dev->ops->dep_link_down)\n\t\treturn -EOPNOTSUPP;\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->dep_link_up == false) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\trc = dev->ops->dep_link_down(dev);\n\tif (!rc) {\n\t\tdev->dep_link_up = false;\n\t\tdev->active_target = NULL;\n\t\tdev->rf_mode = NFC_RF_NONE;\n\t\tnfc_llcp_mac_is_down(dev);\n\t\tnfc_genl_dep_link_down_event(dev);\n\t}\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "static int oidc_request_post_preserved_restore(request_rec *r,\n\t\tconst char *original_url) {\n\toidc_debug(r, \"enter: original_url=%s\", original_url);\n\tconst char *method = \"postOnLoad\";\n\tconst char *script =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function str_decode(string) {\\n\"\n\t\t\t\t\t\"        try {\\n\"\n\t\t\t\t\t\"          result = decodeURIComponent(string);\\n\"\n\t\t\t\t\t\"        } catch (e) {\\n\"\n\t\t\t\t\t\"          result =  unescape(string);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        return result;\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        var mod_auth_openidc_preserve_post_params = JSON.parse(sessionStorage.getItem('mod_auth_openidc_preserve_post_params'));\\n\"\n\t\t\t\t\t\"\t\t sessionStorage.removeItem('mod_auth_openidc_preserve_post_params');\\n\"\n\t\t\t\t\t\"        for (var key in mod_auth_openidc_preserve_post_params) {\\n\"\n\t\t\t\t\t\"          var input = document.createElement(\\\"input\\\");\\n\"\n\t\t\t\t\t\"          input.name = str_decode(key);\\n\"\n\t\t\t\t\t\"          input.value = str_decode(mod_auth_openidc_preserve_post_params[key]);\\n\"\n\t\t\t\t\t\"          input.type = \\\"hidden\\\";\\n\"\n\t\t\t\t\t\"          document.forms[0].appendChild(input);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        document.forms[0].action = '%s';\\n\"\n\t\t\t\t\t\"        document.forms[0].submit();\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", method, original_url);\n\tconst char *body = \"    <p>Restoring...</p>\\n\"\n\t\t\t\"    <form method=\\\"post\\\"></form>\\n\";\n\treturn oidc_util_html_send(r, \"Restoring...\", script, method, body,\n\t\t\tOK);\n}", "target": 1}
{"code": "static int f2fs_mpage_readpages(struct address_space *mapping,\n\t\t\tstruct list_head *pages, struct page *page,\n\t\t\tunsigned nr_pages, bool is_readahead)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct inode *inode = mapping->host;\n\tstruct f2fs_map_blocks map;\n\tint ret = 0;\n\tmap.m_pblk = 0;\n\tmap.m_lblk = 0;\n\tmap.m_len = 0;\n\tmap.m_flags = 0;\n\tmap.m_next_pgofs = NULL;\n\tmap.m_next_extent = NULL;\n\tmap.m_seg_type = NO_CHECK_TYPE;\n\tmap.m_may_create = false;\n\tfor (; nr_pages; nr_pages--) {\n\t\tif (pages) {\n\t\t\tpage = list_last_entry(pages, struct page, lru);\n\t\t\tprefetchw(&page->flags);\n\t\t\tlist_del(&page->lru);\n\t\t\tif (add_to_page_cache_lru(page, mapping,\n\t\t\t\t\t\t  page->index,\n\t\t\t\t\t\t  readahead_gfp_mask(mapping)))\n\t\t\t\tgoto next_page;\n\t\t}\n\t\tret = f2fs_read_single_page(inode, page, nr_pages, &map, &bio,\n\t\t\t\t\t&last_block_in_bio, is_readahead);\n\t\tif (ret) {\n\t\t\tSetPageError(page);\n\t\t\tzero_user_segment(page, 0, PAGE_SIZE);\n\t\t\tunlock_page(page);\n\t\t}\nnext_page:\n\t\tif (pages)\n\t\t\tput_page(page);\n\t}\n\tBUG_ON(pages && !list_empty(pages));\n\tif (bio)\n\t\t__submit_bio(F2FS_I_SB(inode), bio, DATA);\n\treturn pages ? 0 : ret;\n}", "target": 1}
{"code": "\tvoid verifyDirectoryPermissions(const string &path) {\n\t\tTRACE_POINT();\n\t\tstruct stat buf;\n\t\tif (stat(path.c_str(), &buf) == -1) {\n\t\t\tint e = errno;\n\t\t\tthrow FileSystemException(\"Cannot stat() \" + path, e, path);\n\t\t} else if (buf.st_mode != (S_IFDIR | parseModeString(\"u=rwx,g=rx,o=rx\"))) {\n\t\t\tthrow RuntimeException(\"Tried to reuse existing server instance directory \" +\n\t\t\t\tpath + \", but it has wrong permissions\");\n\t\t} else if (buf.st_uid != geteuid() || buf.st_gid != getegid()) {\n\t\t\tthrow RuntimeException(\"Tried to reuse existing server instance directory \" +\n\t\t\t\tpath + \", but it has wrong owner and group\");\n\t\t}\n\t}", "target": 1}
{"code": "void LinkResolver::check_field_loader_constraints(Symbol* field, Symbol* sig,\n                                                  Klass* current_klass,\n                                                  Klass* sel_klass, TRAPS) {\n  Handle ref_loader(THREAD, current_klass->class_loader());\n  Handle sel_loader(THREAD, sel_klass->class_loader());\n  ResourceMark rm(THREAD);  \n  Symbol* failed_type_symbol =\n    SystemDictionary::check_signature_loaders(sig,\n                                              ref_loader, sel_loader,\n                                              false,\n                                              CHECK);\n  if (failed_type_symbol != NULL) {\n    stringStream ss;\n    const char* failed_type_name = failed_type_symbol->as_klass_external_name();\n    ss.print(\"loader constraint violation: when resolving field\"\n             \" \\\"%s\\\" of type %s, the class loader %s of the current class, \"\n             \"%s, and the class loader %s for the field's defining \"\n             \"type, %s, have different Class objects for type %s (%s; %s)\",\n             field->as_C_string(),\n             failed_type_name,\n             current_klass->class_loader_data()->loader_name_and_id(),\n             current_klass->external_name(),\n             sel_klass->class_loader_data()->loader_name_and_id(),\n             sel_klass->external_name(),\n             failed_type_name,\n             current_klass->class_in_module_of_loader(false, true),\n             sel_klass->class_in_module_of_loader(false, true));\n    THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());\n  }\n}", "target": 0}
{"code": "ciEnv::ciEnv(CompileTask* task)\n  : _ciEnv_arena(mtCompiler) {\n  VM_ENTRY_MARK;\n  thread->set_env(this);\n  assert(ciEnv::current() == this, \"sanity\");\n  _oop_recorder = NULL;\n  _debug_info = NULL;\n  _dependencies = NULL;\n  _failure_reason = NULL;\n  _inc_decompile_count_on_failure = true;\n  _compilable = MethodCompilable;\n  _break_at_compile = false;\n  _compiler_data = NULL;\n#ifndef PRODUCT\n  assert(!firstEnv, \"not initialized properly\");\n#endif \n  _num_inlined_bytecodes = 0;\n  assert(task == NULL || thread->task() == task, \"sanity\");\n  if (task != NULL) {\n    task->mark_started(os::elapsed_counter());\n  }\n  _task = task;\n  _log = NULL;\n  _name_buffer = NULL;\n  _name_buffer_len = 0;\n  _arena   = &_ciEnv_arena;\n  _factory = new (_arena) ciObjectFactory(_arena, 128);\n  assert(Universe::is_fully_initialized(), \"should be complete\");\n  oop o = Universe::null_ptr_exception_instance();\n  assert(o != NULL, \"should have been initialized\");\n  _NullPointerException_instance = get_object(o)->as_instance();\n  o = Universe::arithmetic_exception_instance();\n  assert(o != NULL, \"should have been initialized\");\n  _ArithmeticException_instance = get_object(o)->as_instance();\n  _ArrayIndexOutOfBoundsException_instance = NULL;\n  _ArrayStoreException_instance = NULL;\n  _ClassCastException_instance = NULL;\n  _the_null_string = NULL;\n  _the_min_jint_string = NULL;\n  _jvmti_redefinition_count = 0;\n  _jvmti_can_hotswap_or_post_breakpoint = false;\n  _jvmti_can_access_local_variables = false;\n  _jvmti_can_post_on_exceptions = false;\n  _jvmti_can_pop_frame = false;\n}", "target": 0}
{"code": "void SavePackage::Cancel(bool user_action) {\n  if (!canceled()) {\n    if (user_action)\n      user_canceled_ = true;\n    else\n      disk_error_occurred_ = true;\n    Stop();\n  }\n  RecordSavePackageEvent(SAVE_PACKAGE_CANCELLED);\n}", "target": 0}
{"code": "void ieee80211_check_fast_rx_iface(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tmutex_lock(&local->sta_mtx);\n\t__ieee80211_check_fast_rx_iface(sdata);\n\tmutex_unlock(&local->sta_mtx);\n}", "target": 0}
{"code": "static Jsi_RC jsi_ArrayReduceSubCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr, int op) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) \n        return Jsi_LogError(\"expected array\");\n    Jsi_RC rc = JSI_OK;\n    int curlen, i;\n    Jsi_Obj *obj;\n    Jsi_Value *func, *vpargs, *ini = Jsi_ValueArrayIndex(interp, args, 1);\n    func = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!Jsi_ValueIsFunction(interp, func)) \n        return Jsi_LogError(\"expected function\");\n    Jsi_Value *nrPtr = Jsi_ValueNew1(interp);\n    obj = _this->d.obj;\n    curlen = Jsi_ObjGetLength(interp, obj);    \n    if (curlen < 0)\n        Jsi_ObjSetLength(interp, obj, 0);\n    Jsi_ObjListifyArray(interp, obj);\n    Jsi_Value *vobjs[4];\n    int n, rev = (op==2);\n    Jsi_Func *fptr = func->d.obj->d.fobj->func;\n    int maa = (fptr->argnames?fptr->argnames->argCnt:0);\n    if (maa>4)\n        maa = 4;\n    for (n = 0, i = (rev?obj->arrCnt-1:0); (rev?i>=0:i < (int)obj->arrCnt) && rc == JSI_OK; n++, i = (rev?i-1:i+1)) {\n        if (!obj->arr[i]) continue;\n        if (n==0 && !ini) {\n            ini = obj->arr[i];\n            continue;\n        }\n        vobjs[0] = ini;\n        vobjs[1] = obj->arr[i];\n        vobjs[2] = (maa>2?Jsi_ValueNewNumber(interp, i):NULL);\n        vobjs[3] = _this;\n        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vobjs, maa, 0));\n        Jsi_IncrRefCount(interp, vpargs);\n        rc = Jsi_FunctionInvoke(interp, func, vpargs, &nrPtr, NULL);\n        Jsi_DecrRefCount(interp, vpargs);\n        if (rc != JSI_OK)\n            break;\n        ini = nrPtr;\n    }\n    if (rc == JSI_OK && ini)\n        Jsi_ValueCopy(interp, *ret, ini); \n    Jsi_DecrRefCount(interp, nrPtr);\n    return rc;\n}", "target": 1}
{"code": "static int rds_loop_xmit(struct rds_connection *conn, struct rds_message *rm,\n\t\t\t unsigned int hdr_off, unsigned int sg,\n\t\t\t unsigned int off)\n{\n\tif (rm->m_inc.i_hdr.h_flags & RDS_FLAG_CONG_BITMAP) {\n\t\trds_cong_map_updated(conn->c_fcong, ~(u64) 0);\n\t\treturn sizeof(struct rds_header) + RDS_CONG_MAP_BYTES;\n\t}\n\tBUG_ON(hdr_off || sg || off);\n\trds_inc_init(&rm->m_inc, conn, conn->c_laddr);\n\trds_message_addref(rm);\n\trds_recv_incoming(conn, conn->c_laddr, conn->c_faddr, &rm->m_inc,\n\t\t\t  GFP_KERNEL, KM_USER0);\n\trds_send_drop_acked(conn, be64_to_cpu(rm->m_inc.i_hdr.h_sequence),\n\t\t\t    NULL);\n\trds_inc_put(&rm->m_inc);\n\treturn sizeof(struct rds_header) + be32_to_cpu(rm->m_inc.i_hdr.h_len);\n}", "target": 1}
{"code": "static int fsmVerify(int dirfd, const char *path, rpmfi fi)\n{\n    int rc;\n    int saveerrno = errno;\n    struct stat dsb;\n    mode_t mode = rpmfiFMode(fi);\n    rc = fsmStat(dirfd, path, 1, &dsb);\n    if (rc)\n\treturn rc;\n    if (S_ISREG(mode)) {\n\tchar *rmpath = rstrscat(NULL, path, \"-RPMDELETE\", NULL);\n\trc = fsmRename(dirfd, path, dirfd, rmpath);\n\tif (!rc)\n\t    (void) fsmUnlink(dirfd, rmpath);\n\telse\n\t    rc = RPMERR_UNLINK_FAILED;\n\tfree(rmpath);\n        return (rc ? rc : RPMERR_ENOENT);\t\n    } else if (S_ISDIR(mode)) {\n        if (S_ISDIR(dsb.st_mode)) return 0;\n        if (S_ISLNK(dsb.st_mode)) {\n\t    uid_t luid = dsb.st_uid;\n            rc = fsmStat(dirfd, path, 0, &dsb);\n            if (rc == RPMERR_ENOENT) rc = 0;\n            if (rc) return rc;\n            errno = saveerrno;\n            if (S_ISDIR(dsb.st_mode) && (luid == 0 || luid == dsb.st_uid))\n\t\t    return 0;\n        }\n    } else if (S_ISLNK(mode)) {\n        if (S_ISLNK(dsb.st_mode)) {\n            char buf[8 * BUFSIZ];\n            size_t len;\n            rc = fsmReadLink(path, buf, 8 * BUFSIZ, &len);\n            errno = saveerrno;\n            if (rc) return rc;\n            if (rstreq(rpmfiFLink(fi), buf)) return 0;\n        }\n    } else if (S_ISFIFO(mode)) {\n        if (S_ISFIFO(dsb.st_mode)) return 0;\n    } else if (S_ISCHR(mode) || S_ISBLK(mode)) {\n        if ((S_ISCHR(dsb.st_mode) || S_ISBLK(dsb.st_mode)) &&\n            (dsb.st_rdev == rpmfiFRdev(fi))) return 0;\n    } else if (S_ISSOCK(mode)) {\n        if (S_ISSOCK(dsb.st_mode)) return 0;\n    }\n    rc = fsmUnlink(dirfd, path);\n    if (rc == 0)\trc = RPMERR_ENOENT;\n    return (rc ? rc : RPMERR_ENOENT);\t\n}", "target": 0}
{"code": "      return *ptr_min;\n    }\n    const T& min() const {\n      if (is_empty())\n        throw CImgInstanceException(_cimglist_instance\n                                    \"min(): Empty instance.\",\n                                    cimglist_instance);\n      const T *ptr_min = _data->_data;\n      T min_value = *ptr_min;\n      cimglist_for(*this,l) {\n        const CImg<T>& img = _data[l];", "target": 0}
{"code": "static void on_underlying_io_bytes_received(void* context, const unsigned char* buffer, size_t size)\n{\n    if (context != NULL)\n    {\n        TLS_IO_INSTANCE* tls_io_instance = (TLS_IO_INSTANCE*)context;\n        unsigned char* new_socket_io_read_bytes = (unsigned char*)realloc(tls_io_instance->socket_io_read_bytes, tls_io_instance->socket_io_read_byte_count + size);\n        if (new_socket_io_read_bytes == NULL)\n        {\n            LogError(\"Failed allocating memory for received bytes\");\n            tls_io_instance->tlsio_state = TLSIO_STATE_ERROR;\n            indicate_error(tls_io_instance);\n        }\n        else\n        {\n            tls_io_instance->socket_io_read_bytes = new_socket_io_read_bytes;\n            (void)memcpy(tls_io_instance->socket_io_read_bytes + tls_io_instance->socket_io_read_byte_count, buffer, size);\n            tls_io_instance->socket_io_read_byte_count += size;\n        }\n    }\n    else\n    {\n        LogInfo(\"Supplied context is NULL on bytes_received\");\n    }\n}", "target": 1}
{"code": "define_function(foobar)\n{\n  int64_t arg = integer_argument(1);\n  switch (arg)\n  {\n    case 1:\n      return_string(\"foo\");\n      break;\n    case 2:\n      return_string(\"bar\");\n      break;\n  }\n  return_string(\"oops\")\n}", "target": 0}
{"code": "bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)\n{\n\tswitch (chip->usb_id) {\n\tcase USB_ID(0x045E, 0x075D): \n\tcase USB_ID(0x045E, 0x076D): \n\tcase USB_ID(0x045E, 0x076E): \n\tcase USB_ID(0x045E, 0x076F): \n\tcase USB_ID(0x045E, 0x0772): \n\tcase USB_ID(0x045E, 0x0779): \n\tcase USB_ID(0x047F, 0xAA05): \n\tcase USB_ID(0x04D8, 0xFEEA): \n\tcase USB_ID(0x074D, 0x3553): \n\tcase USB_ID(0x21B4, 0x0081): \n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 0}
{"code": "static bool cgm_bind_dir(const char *root, const char *dirname)\n{\n\tnih_local char *cgpath = NULL;\n\tcgpath = NIH_MUST( nih_strdup(NULL, root) );\n\tNIH_MUST( nih_strcat(&cgpath, NULL, \"/sys/fs/cgroup\") );\n\tif (!dir_exists(cgpath)) {\n\t\tERROR(\"%s does not exist\", cgpath);\n\t\treturn false;\n\t}\n\tif (mount(\"cgroup\", cgpath, \"tmpfs\", 0, \"size=10000,mode=755\")) {\n\t\tSYSERROR(\"Failed to mount tmpfs at %s\", cgpath);\n\t\treturn false;\n\t}\n\tNIH_MUST( nih_strcat(&cgpath, NULL, \"/cgmanager\") );\n\tif (mkdir(cgpath, 0755) < 0) {\n\t\tSYSERROR(\"Failed to create %s\", cgpath);\n\t\treturn false;\n\t}\n\tif (mount(dirname, cgpath, \"none\", MS_BIND, 0)) {\n\t\tSYSERROR(\"Failed to bind mount %s to %s\", dirname, cgpath);\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "print_attr_string(netdissect_options *ndo,\n                  register const u_char *data, u_int length, u_short attr_code)\n{\n   register u_int i;\n   ND_TCHECK2(data[0],length);\n   switch(attr_code)\n   {\n      case TUNNEL_PASS:\n           if (length < 3)\n           {\n              ND_PRINT((ndo, \"%s\", tstr));\n              return;\n           }\n           if (*data && (*data <=0x1F) )\n              ND_PRINT((ndo, \"Tag[%u] \", *data));\n           else\n              ND_PRINT((ndo, \"Tag[Unused] \"));\n           data++;\n           length--;\n           ND_PRINT((ndo, \"Salt %u \", EXTRACT_16BITS(data)));\n           data+=2;\n           length-=2;\n        break;\n      case TUNNEL_CLIENT_END:\n      case TUNNEL_SERVER_END:\n      case TUNNEL_PRIV_GROUP:\n      case TUNNEL_ASSIGN_ID:\n      case TUNNEL_CLIENT_AUTH:\n      case TUNNEL_SERVER_AUTH:\n           if (*data <= 0x1F)\n           {\n              if (length < 1)\n              {\n                 ND_PRINT((ndo, \"%s\", tstr));\n                 return;\n              }\n              if (*data)\n                ND_PRINT((ndo, \"Tag[%u] \", *data));\n              else\n                ND_PRINT((ndo, \"Tag[Unused] \"));\n              data++;\n              length--;\n           }\n        break;\n      case EGRESS_VLAN_NAME:\n           ND_PRINT((ndo, \"%s (0x%02x) \",\n                  tok2str(rfc4675_tagged,\"Unknown tag\",*data),\n                  *data));\n           data++;\n           length--;\n        break;\n   }\n   for (i=0; *data && i < length ; i++, data++)\n       ND_PRINT((ndo, \"%c\", (*data < 32 || *data > 126) ? '.' : *data));\n   return;\n   trunc:\n      ND_PRINT((ndo, \"%s\", tstr));\n}", "target": 1}
{"code": "static bool new_idmap_permitted(const struct file *file, \n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *new_map)\n{\n\tif ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {\n\t\tu32 id = new_map->extent[0].lower_first;\n\t\tif (cap_setid == CAP_SETUID) {\n\t\t\tkuid_t uid = make_kuid(ns->parent, id);\n\t\t\tif (uid_eq(uid, file->f_cred->fsuid))\n\t\t\t\treturn true;\n\t\t}\n\t\telse if (cap_setid == CAP_SETGID) {\n\t\t\tkgid_t gid = make_kgid(ns->parent, id);\n\t\t\tif (gid_eq(gid, file->f_cred->fsgid))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\tif (!cap_valid(cap_setid))\n\t\treturn true;\n\tif (ns_capable(ns->parent, cap_setid) &&\n\t    file_ns_capable(file, ns->parent, cap_setid))\n\t\treturn true;\n\treturn false;\n}", "target": 0}
{"code": "static cache_accel_t *read_cache_accel(RBuffer *cache_buf, cache_hdr_t *hdr, cache_map_t *maps) {\n\tif (!cache_buf || !hdr || !hdr->accelerateInfoSize || !hdr->accelerateInfoAddr) {\n\t\treturn NULL;\n\t}\n\tut64 offset = va2pa (hdr->accelerateInfoAddr, hdr->mappingCount, maps, cache_buf, 0, NULL, NULL);\n\tif (!offset) {\n\t\treturn NULL;\n\t}\n\tut64 size = sizeof (cache_accel_t);\n\tcache_accel_t *accel = R_NEW0 (cache_accel_t);\n\tif (!accel) {\n\t\treturn NULL;\n\t}\n\tif (r_buf_fread_at (cache_buf, offset, (ut8*) accel, \"16il\", 1) != size) {\n\t\tR_FREE (accel);\n\t\treturn NULL;\n\t}\n\taccel->imagesExtrasOffset += offset;\n\taccel->bottomUpListOffset += offset;\n\taccel->dylibTrieOffset += offset;\n\taccel->initializersOffset += offset;\n\taccel->dofSectionsOffset += offset;\n\taccel->reExportListOffset += offset;\n\taccel->depListOffset += offset;\n\taccel->rangeTableOffset += offset;\n\treturn accel;\n}", "target": 1}
{"code": "theme_adium_match_with_format (const gchar **str,\n\t\t\t       const gchar *match,\n\t\t\t       gchar **format)\n{\n\tconst gchar *cur = *str;\n\tconst gchar *end;\n\tif (!theme_adium_match (&cur, match)) {\n\t\treturn FALSE;\n\t}\n\tcur++;\n\tend = strstr (cur, \"}%\");\n\tif (!end) {\n\t\treturn FALSE;\n\t}\n\t*format = g_strndup (cur , end - cur);\n\t*str = end + 1;\n\treturn TRUE;\n}", "target": 0}
{"code": "TEST(NNOpsTest, FractionalPool_ShapeFn) {\n  for (const char* op_name : {\"FractionalAvgPool\", \"FractionalMaxPool\"}) {\n    ShapeInferenceTestOp op(op_name);\n    auto set_op = [&op, op_name](const std::vector<float>& pooling_ratio) {\n      TF_ASSERT_OK(NodeDefBuilder(\"test\", op_name)\n                       .Input(\"input\", 0, DT_FLOAT)\n                       .Attr(\"pooling_ratio\", pooling_ratio)\n                       .Finalize(&op.node_def));\n    };\n    set_op(std::vector<float>{2.0f, 1, 1 / 1.5f, 1 / 2.0f});\n    INFER_ERROR(\"must be rank 4\", op, \"[?,?,?]\");\n    INFER_OK(op, \"?\", \"[?,?,?,?];[?];[?]\");\n    INFER_OK(op, \"[?,?,?,?]\", \"[?,?,?,?];[?];[?]\");\n    INFER_OK(op, \"[10,20,30,40]\", \"[5,20,45,80];[20];[45]\");\n    INFER_OK(op, \"[?,20,30,40]\", \"[?,20,45,80];[20];[45]\");\n    INFER_OK(op, \"[10,?,30,40]\", \"[5,?,45,80];[?];[45]\");\n    INFER_OK(op, \"[10,20,?,40]\", \"[5,20,?,80];[20];[?]\");\n    INFER_OK(op, \"[10,20,30,?]\", \"[5,20,45,?];[20];[45]\");\n    set_op(std::vector<float>{.5, 1.0, 1.5});\n    INFER_ERROR(\"pooling_ratio field\", op, \"?\");\n    set_op(std::vector<float>{1, 2, 3, 4, 5});\n    INFER_ERROR(\"pooling_ratio field\", op, \"?\");\n    set_op(std::vector<float>{-1, 2, 3, 4});\n    INFER_ERROR(\"is negative\", op, \"[1,2,3,4]\");\n  }\n}", "target": 1}
{"code": "int sub__messages_queue(const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store **stored)\n{\n\tint rc = MOSQ_ERR_SUCCESS, rc2;\n\tstruct mosquitto__subhier *subhier;\n\tchar **split_topics = NULL;\n\tchar *local_topic = NULL;\n\tassert(topic);\n\tif(sub__topic_tokenise(topic, &local_topic, &split_topics, NULL)) return 1;\n\tdb__msg_store_ref_inc(*stored);\n\tHASH_FIND(hh, db.subs, split_topics[0], strlen(split_topics[0]), subhier);\n\tif(subhier){\n\t\trc = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n\t}\n\tif(retain){\n\t\trc2 = retain__store(topic, *stored, split_topics);\n\t\tif(rc2) rc = rc2;\n\t}\n\tmosquitto__free(split_topics);\n\tmosquitto__free(local_topic);\n\tdb__msg_store_ref_dec(stored);\n\treturn rc;\n}", "target": 1}
{"code": "static VALUE from_document(VALUE klass, VALUE document)\n{\n  xmlDocPtr doc;\n  xmlRelaxNGParserCtxtPtr ctx;\n  xmlRelaxNGPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n  Data_Get_Struct(document, xmlDoc, doc);\n  doc = doc->doc;\n  ctx = xmlRelaxNGNewDocParserCtxt(doc);\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n#ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS\n  xmlRelaxNGSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n  schema = xmlRelaxNGParse(ctx);\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlRelaxNGFreeParserCtxt(ctx);\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n    return Qnil;\n  }\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n  return rb_schema;\n}", "target": 1}
{"code": "BGD_DECLARE(void) gdImageWebpEx (gdImagePtr im, FILE * outFile, int quality)\n{\n\tgdIOCtx *out = gdNewFileCtx(outFile);\n\tif (out == NULL) {\n\t\treturn;\n\t}\n\tgdImageWebpCtx(im, out, quality);\n\tout->gd_free(out);\n}", "target": 1}
{"code": "int main(int argc, char **argv) {\n  mlir::registerAsmPrinterCLOptions();\n  tensorflow::InitMlir y(&argc, &argv);\n  return failed(\n      mlir::mlirTranslateMain(argc, argv, \"Graph(Def)<->TFG Translation Tool\"));\n}", "target": 0}
{"code": "MOBI_RET mobi_decode_infl(unsigned char *decoded, int *decoded_size, const unsigned char *rule) {\n    int pos = *decoded_size;\n    char mod = 'i';\n    char dir = '<';\n    char olddir;\n    unsigned char c;\n    while ((c = *rule++)) {\n        if (c <= 4) {\n            mod = (c <= 2) ? 'i' : 'd'; \n            olddir = dir;\n            dir = (c & 2) ? '<' : '>'; \n            if (olddir != dir && olddir) {\n                pos = (c & 2) ? *decoded_size : 0;\n            }\n        }\n        else if (c > 10 && c < 20) {\n            if (dir == '>') {\n                pos = *decoded_size;\n            }\n            pos -= c - 10;\n            dir = 0;\n            if (pos < 0 || pos > *decoded_size) {\n                debug_print(\"Position setting failed (%s)\\n\", decoded);\n                return MOBI_DATA_CORRUPT;\n            }\n        }\n        else {\n            if (mod == 'i') {\n                const unsigned char *s = decoded + pos;\n                unsigned char *d = decoded + pos + 1;\n                const int l = *decoded_size - pos;\n                if (l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {\n                    debug_print(\"Out of buffer in %s at pos: %i\\n\", decoded, pos);\n                    return MOBI_DATA_CORRUPT;\n                }\n                memmove(d, s, (size_t) l);\n                decoded[pos] = c;\n                (*decoded_size)++;\n                if (dir == '>') { pos++; }\n            } else {\n                if (dir == '<') { pos--; }\n                const unsigned char *s = decoded + pos + 1;\n                unsigned char *d = decoded + pos;\n                const int l = *decoded_size - pos;\n                if (l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {\n                    debug_print(\"Out of buffer in %s at pos: %i\\n\", decoded, pos);\n                    return MOBI_DATA_CORRUPT;\n                }\n                if (decoded[pos] != c) {\n                    debug_print(\"Character mismatch in %s at pos: %i (%c != %c)\\n\", decoded, pos, decoded[pos], c);\n                    return MOBI_DATA_CORRUPT;\n                }\n                memmove(d, s, (size_t) l);\n                (*decoded_size)--;\n            }\n        }\n    }\n    return MOBI_SUCCESS;\n}", "target": 1}
{"code": "static Exit_status safe_connect()\n{\n  mysql= mysql_init(NULL);\n  if (!mysql)\n  {\n    error(\"Failed on mysql_init.\");\n    return ERROR_STOP;\n  }\n#ifdef HAVE_OPENSSL\n  if (opt_use_ssl)\n  {\n    mysql_ssl_set(mysql, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n                  opt_ssl_capath, opt_ssl_cipher);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRL, opt_ssl_crl);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);\n  }\n  mysql_options(mysql, MYSQL_OPT_SSL_VERIFY_SERVER_CERT,\n                (char*) &opt_ssl_verify_server_cert);\n#endif\n  if (opt_plugin_dir && *opt_plugin_dir)\n    mysql_options(mysql, MYSQL_PLUGIN_DIR, opt_plugin_dir);\n  if (opt_default_auth && *opt_default_auth)\n    mysql_options(mysql, MYSQL_DEFAULT_AUTH, opt_default_auth);\n  if (opt_protocol)\n    mysql_options(mysql, MYSQL_OPT_PROTOCOL, (char*) &opt_protocol);\n  if (opt_bind_addr)\n    mysql_options(mysql, MYSQL_OPT_BIND, opt_bind_addr);\n#if defined (_WIN32) && !defined (EMBEDDED_LIBRARY)\n  if (shared_memory_base_name)\n    mysql_options(mysql, MYSQL_SHARED_MEMORY_BASE_NAME,\n                  shared_memory_base_name);\n#endif\n  mysql_options(mysql, MYSQL_OPT_CONNECT_ATTR_RESET, 0);\n  mysql_options4(mysql, MYSQL_OPT_CONNECT_ATTR_ADD,\n                 \"program_name\", \"mysqlbinlog\");\n  if (!mysql_real_connect(mysql, host, user, pass, 0, port, sock, 0))\n  {\n    error(\"Failed on connect: %s\", mysql_error(mysql));\n    return ERROR_STOP;\n  }\n  mysql->reconnect= 1;\n  return OK_CONTINUE;\n}", "target": 1}
{"code": "static int DefragBsdPeose173Ipv6Test(void)\n{\n    DefragInit();\n    default_policy = DEFRAG_POLICY_BSD;\n    Packet *packets[5];\n    packets[0] = BuildIpv6TestPacketWithContent(\n            IPPROTO_ICMP, 189, 16 >> 3, 1, (uint8_t *)\"AABBCCDDAABBDDCC\", 16);\n    packets[1] =\n            BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 189, 40 >> 3, 1, (uint8_t *)\"AACCBBDD\", 8);\n    packets[2] = BuildIpv6TestPacketWithContent(\n            IPPROTO_ICMP, 189, 8 >> 3, 1, (uint8_t *)\"AACCDDBBAADDBBCC\", 16);\n    packets[3] = BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 189, 0, 1, (uint8_t *)\"ZZZZZZZZ\", 8);\n    packets[4] =\n            BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 189, 48 >> 3, 0, (uint8_t *)\"DDCCBBAA\", 8);\n    Packet *r = Defrag(NULL, NULL, packets[0]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[1]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[2]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[3]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[4]);\n    FAIL_IF_NOT_NULL(r);\n#if 0\n    PrintRawDataFp(stdout, GET_PKT_DATA(r) + 40, GET_PKT_LEN(r) - 40);\n#endif\n    for (int i = 0; i < 5; i++) {\n        SCFree(packets[i]);\n    }\n    DefragDestroy();\n    PASS;\n}", "target": 0}
{"code": "const char *string_of_NPNVariable(int variable)\n{\n  const char *str;\n  switch (variable) {\n#define _(VAL) case VAL: str = #VAL; break;\n\t_(NPNVxDisplay);\n\t_(NPNVxtAppContext);\n\t_(NPNVnetscapeWindow);\n\t_(NPNVjavascriptEnabledBool);\n\t_(NPNVasdEnabledBool);\n\t_(NPNVisOfflineBool);\n\t_(NPNVserviceManager);\n\t_(NPNVDOMElement);\n\t_(NPNVDOMWindow);\n\t_(NPNVToolkit);\n\t_(NPNVSupportsXEmbedBool);\n\t_(NPNVWindowNPObject);\n\t_(NPNVPluginElementNPObject);\n\t_(NPNVSupportsWindowless);\n\t_(NPNVprivateModeBool);\n\t_(NPNVsupportsAdvancedKeyHandling);\n#undef _\n  default:\n\tswitch (variable & 0xff) {\n#define _(VAL, VAR) case VAL: str = #VAR; break\n\t  _(10, NPNVserviceManager);\n\t  _(11, NPNVDOMElement);\n\t  _(12, NPNVDOMWindow);\n\t  _(13, NPNVToolkit);\n#undef _\n\tdefault:\n\t  str = \"<unknown variable>\";\n\t  break;\n\t}\n\tbreak;\n  }\n  return str;\n}", "target": 0}
{"code": "static int ivr_probe(AVProbeData *p)\n{\n    if (memcmp(p->buf, \".R1M\\x0\\x1\\x1\", 7) &&\n        memcmp(p->buf, \".REC\", 4))\n        return 0;\n    return AVPROBE_SCORE_MAX;\n}", "target": 0}
{"code": "static void prekey_handler(const char *userid,\n\t\t\t   const uint8_t *key, size_t key_len,\n\t\t\t   uint16_t id, const char *clientid,\n\t\t\t   bool last, void *arg)\n{\n\tstruct session *sess;\n\tchar lclientid[64];\n\tint err;\n\toutput(\"prekey_handler: %zu bytes, user:%s[%u] -> %s\\n\",\n\t       key_len, userid, id, clientid);\n\terr = client_id_load(lclientid, sizeof(lclientid));\n\tif (err) {\n\t\tdebug(\"my clientid not set -- cannot store prekeys\\n\");\n\t\treturn;\n\t}\n\tsess = cryptobox_session_find(g_cryptobox, userid, clientid, lclientid);\n\tif (sess) {\n\t\toutput(\"prekey: session found\\n\");\n\t}\n\telse {\n\t\tinfo(\"conv: adding key to cryptobox for clientid=%s\\n\",\n\t\t     clientid);\n\t\terr = cryptobox_session_add_send(g_cryptobox, userid, clientid, lclientid,\n\t\t\t\t\t\t key, key_len);\n\t\tif (err) {\n\t\t\twarning(\"cryptobox_session_add_send failed (%m)\\n\",\n\t\t\t\terr);\n\t\t}\n\t}\n}", "target": 1}
{"code": "void end_read_record(READ_RECORD *info)\n{\n  free_cache(info);\n  if (info->table)\n  {\n    if (info->table->db_stat) \n      (void) info->table->file->extra(HA_EXTRA_NO_CACHE);\n    if (info->read_record != rr_quick) \n      (void) info->table->file->ha_index_or_rnd_end();\n    info->table=0;\n  }\n}", "target": 0}
{"code": "void RootWindow::RemoveRootWindowObserver(RootWindowObserver* observer) {\n  observers_.RemoveObserver(observer);\n}", "target": 0}
{"code": "static void RemoveICCProfileFromResourceBlock(StringInfo *bim_profile)\n{\n  register const unsigned char\n    *p;\n  size_t\n    length;\n  unsigned char\n    *datum;\n  unsigned int\n    count,\n    long_sans;\n  unsigned short\n    id,\n    short_sans;\n  length=GetStringInfoLength(bim_profile);\n  if (length < 16)\n    return;\n  datum=GetStringInfoDatum(bim_profile);\n  for (p=datum; (p >= datum) && (p < (datum+length-16)); )\n  {\n    register unsigned char\n      *q;\n    q=(unsigned char *) p;\n    if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n      break;\n    p=PushLongPixel(MSBEndian,p,&long_sans);\n    p=PushShortPixel(MSBEndian,p,&id);\n    p=PushShortPixel(MSBEndian,p,&short_sans);\n    p=PushLongPixel(MSBEndian,p,&count);\n    if (id == 0x0000040f)\n      {\n        (void) CopyMagickMemory(q,q+PSDQuantum(count)+12,length-\n          (PSDQuantum(count)+12)-(q-datum));\n        SetStringInfoLength(bim_profile,length-(PSDQuantum(count)+12));\n        break;\n      }\n    p+=count;\n    if ((count & 0x01) != 0)\n      p++;\n  }\n}", "target": 1}
{"code": "free_ice_connection_watch (GsmIceConnectionWatch *data)\n{\n        if (data->watch_id) {\n                g_source_remove (data->watch_id);\n                data->watch_id = 0;\n        }\n        if (data->protocol_timeout) {\n                g_source_remove (data->protocol_timeout);\n                data->protocol_timeout = 0;\n        }\n        g_free (data);\n}", "target": 0}
{"code": "void dns_server_deinit(void)\n{\n\tif (dns_server_pcb != NULL) {\n\t\tudp_remove(dns_server_pcb);\n\t\tdns_server_pcb = NULL;\n\t}\n}", "target": 0}
{"code": "int ZEXPORT deflateCopy (dest, source)\n    z_streamp dest;\n    z_streamp source;\n{\n#ifdef MAXSEG_64K\n    return Z_STREAM_ERROR;\n#else\n    deflate_state *ds;\n    deflate_state *ss;\n    ushf *overlay;\n    if (deflateStateCheck(source) || dest == Z_NULL) {\n        return Z_STREAM_ERROR;\n    }\n    ss = source->state;\n    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));\n    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));\n    if (ds == Z_NULL) return Z_MEM_ERROR;\n    dest->state = (struct internal_state FAR *) ds;\n    zmemcpy((voidpf)ds, (voidpf)ss, sizeof(deflate_state));\n    ds->strm = dest;\n    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));\n    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));\n    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));\n    overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);\n    ds->pending_buf = (uchf *) overlay;\n    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||\n        ds->pending_buf == Z_NULL) {\n        deflateEnd (dest);\n        return Z_MEM_ERROR;\n    }\n    zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));\n    zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w_size * sizeof(Pos));\n    zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash_size * sizeof(Pos));\n    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);\n    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);\n    ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);\n    ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;\n    ds->l_desc.dyn_tree = ds->dyn_ltree;\n    ds->d_desc.dyn_tree = ds->dyn_dtree;\n    ds->bl_desc.dyn_tree = ds->bl_tree;\n    return Z_OK;\n#endif \n}", "target": 1}
{"code": "void gdImageCopyMerge (gdImagePtr dst, gdImagePtr src, int dstX, int dstY, int srcX, int srcY, int w, int h, int pct)\n{\n\tint c, dc;\n\tint x, y;\n\tint tox, toy;\n\tint ncR, ncG, ncB;\n\ttoy = dstY;\n\tfor (y = srcY; y < (srcY + h); y++) {\n\t\ttox = dstX;\n\t\tfor (x = srcX; x < (srcX + w); x++) {\n\t\t\tint nc;\n\t\t\tc = gdImageGetPixel(src, x, y);\n\t\t\tif (gdImageGetTransparent(src) == c) {\n\t\t\t\ttox++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (dst == src) {\n\t\t\t\tnc = c;\n\t\t\t} else {\n\t\t\t\tdc = gdImageGetPixel(dst, tox, toy);\n \t\t\t\tncR = (int)(gdImageRed (src, c) * (pct / 100.0) + gdImageRed (dst, dc) * ((100 - pct) / 100.0));\n \t\t\t\tncG = (int)(gdImageGreen (src, c) * (pct / 100.0) + gdImageGreen (dst, dc) * ((100 - pct) / 100.0));\n \t\t\t\tncB = (int)(gdImageBlue (src, c) * (pct / 100.0) + gdImageBlue (dst, dc) * ((100 - pct) / 100.0));\n\t\t\t\tnc = gdImageColorResolve (dst, ncR, ncG, ncB);\n\t\t\t}\n\t\t\tgdImageSetPixel (dst, tox, toy, nc);\n\t\t\ttox++;\n\t\t}\n\t\ttoy++;\n\t}\n}", "target": 1}
{"code": "pxa3xx_gcu_write(struct file *file, const char *buff,\n\t\t size_t count, loff_t *offp)\n{\n\tint ret;\n\tunsigned long flags;\n\tstruct pxa3xx_gcu_batch\t*buffer;\n\tstruct pxa3xx_gcu_priv *priv = to_pxa3xx_gcu_priv(file);\n\tint words = count / 4;\n\tpriv->shared->num_writes++;\n\tpriv->shared->num_words += words;\n\tif (words >= PXA3XX_GCU_BATCH_WORDS)\n\t\treturn -E2BIG;\n\tif (!priv->free) {\n\t\tret = pxa3xx_gcu_wait_free(priv);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tspin_lock_irqsave(&priv->spinlock, flags);\n\tbuffer = priv->free;\n\tpriv->free = buffer->next;\n\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\tret = copy_from_user(buffer->ptr, buff, words * 4);\n\tif (ret) {\n\t\tspin_lock_irqsave(&priv->spinlock, flags);\n\t\tbuffer->next = priv->free;\n\t\tpriv->free = buffer;\n\t\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\t\treturn -EFAULT;\n\t}\n\tbuffer->length = words;\n\tbuffer->ptr[words] = 0x01000000;\n\tspin_lock_irqsave(&priv->spinlock, flags);\n\tbuffer->next = NULL;\n\tif (priv->ready) {\n\t\tBUG_ON(priv->ready_last == NULL);\n\t\tpriv->ready_last->next = buffer;\n\t} else\n\t\tpriv->ready = buffer;\n\tpriv->ready_last = buffer;\n\tif (!priv->shared->hw_running)\n\t\trun_ready(priv);\n\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\treturn words * 4;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& image = context->input(0);\n    OP_REQUIRES(context, image.dims() == 3,\n                errors::InvalidArgument(\"image must be 3-dimensional\",\n                                        image.shape().DebugString()));\n    OP_REQUIRES(context, image.NumElements() > 0,\n                errors::Internal(\"Invalid image provided.\"));\n    OP_REQUIRES(\n        context,\n        FastBoundsCheck(image.NumElements(), std::numeric_limits<int32>::max()),\n        errors::InvalidArgument(\"image cannot have >= int32 max elements\"));\n    const int32 height = static_cast<int32>(image.dim_size(0));\n    const int32 width = static_cast<int32>(image.dim_size(1));\n    const int32 channels = static_cast<int32>(image.dim_size(2));\n    const int32 max_row_width = std::numeric_limits<int32>::max() / 2;\n    OP_REQUIRES(context, FastBoundsCheck(width * channels, max_row_width),\n                errors::InvalidArgument(\"image too wide to encode\"));\n    OP_REQUIRES(context, channels >= 1 && channels <= 4,\n                errors::InvalidArgument(\n                    \"image must have 1, 2, 3, or 4 channels, got \", channels));\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, TensorShape({}), &output));\n    if (desired_channel_bits_ == 8) {\n      OP_REQUIRES(context,\n                  png::WriteImageToBuffer(\n                      image.flat<uint8>().data(), width, height,\n                      width * channels, channels, desired_channel_bits_,\n                      compression_, &output->scalar<tstring>()(), nullptr),\n                  errors::Internal(\"PNG encoding failed\"));\n    } else {\n      OP_REQUIRES(context,\n                  png::WriteImageToBuffer(\n                      image.flat<uint16>().data(), width, height,\n                      width * channels * 2, channels, desired_channel_bits_,\n                      compression_, &output->scalar<tstring>()(), nullptr),\n                  errors::Internal(\"PNG encoding failed\"));\n    }\n  }", "target": 0}
{"code": "static int ext4_end_io_nolock(ext4_io_end_t *io)\n{\n\tstruct inode *inode = io->inode;\n\tloff_t offset = io->offset;\n\tssize_t size = io->size;\n\tint ret = 0;\n\text4_debug(\"ext4_end_io_nolock: io 0x%p from inode %lu,list->next 0x%p,\"\n\t\t   \"list->prev 0x%p\\n\",\n\t           io, inode->i_ino, io->list.next, io->list.prev);\n\tif (list_empty(&io->list))\n\t\treturn ret;\n\tif (io->flag != EXT4_IO_UNWRITTEN)\n\t\treturn ret;\n\tif (offset + size <= i_size_read(inode))\n\t\tret = ext4_convert_unwritten_extents(inode, offset, size);\n\tif (ret < 0) {\n\t\tprintk(KERN_EMERG \"%s: failed to convert unwritten\"\n\t\t\t\"extents to written extents, error is %d\"\n\t\t\t\" io is still on inode %lu aio dio list\\n\",\n                       __func__, ret, inode->i_ino);\n\t\treturn ret;\n\t}\n\tio->flag = 0;\n\treturn ret;\n}", "target": 1}
{"code": "std::string Network::GetErrorString() const {\n  switch (error_) {\n    case ERROR_UNKNOWN:\n      return l10n_util::GetStringUTF8(IDS_CHROMEOS_NETWORK_ERROR_UNKNOWN);\n    case ERROR_OUT_OF_RANGE:\n      return l10n_util::GetStringUTF8(IDS_CHROMEOS_NETWORK_ERROR_OUT_OF_RANGE);\n    case ERROR_PIN_MISSING:\n      return l10n_util::GetStringUTF8(IDS_CHROMEOS_NETWORK_ERROR_PIN_MISSING);\n    case ERROR_DHCP_FAILED:\n      return l10n_util::GetStringUTF8(IDS_CHROMEOS_NETWORK_ERROR_DHCP_FAILED);\n    case ERROR_CONNECT_FAILED:\n      return l10n_util::GetStringUTF8(\n          IDS_CHROMEOS_NETWORK_ERROR_CONNECT_FAILED);\n    case ERROR_BAD_PASSPHRASE:\n      return l10n_util::GetStringUTF8(\n          IDS_CHROMEOS_NETWORK_ERROR_BAD_PASSPHRASE);\n    case ERROR_BAD_WEPKEY:\n      return l10n_util::GetStringUTF8(IDS_CHROMEOS_NETWORK_ERROR_BAD_WEPKEY);\n    case ERROR_ACTIVATION_FAILED:\n      return l10n_util::GetStringUTF8(\n          IDS_CHROMEOS_NETWORK_ERROR_ACTIVATION_FAILED);\n    case ERROR_NEED_EVDO:\n      return l10n_util::GetStringUTF8(IDS_CHROMEOS_NETWORK_ERROR_NEED_EVDO);\n    case ERROR_NEED_HOME_NETWORK:\n      return l10n_util::GetStringUTF8(\n          IDS_CHROMEOS_NETWORK_ERROR_NEED_HOME_NETWORK);\n    case ERROR_OTASP_FAILED:\n      return l10n_util::GetStringUTF8(IDS_CHROMEOS_NETWORK_ERROR_OTASP_FAILED);\n    case ERROR_AAA_FAILED:\n      return l10n_util::GetStringUTF8(IDS_CHROMEOS_NETWORK_ERROR_AAA_FAILED);\n    default:\n      break;\n  }\n  return l10n_util::GetStringUTF8(IDS_CHROMEOS_NETWORK_STATE_UNRECOGNIZED);\n}", "target": 0}
{"code": "static void spl_array_update_pos(spl_array_object* intern) \n{\n\tBucket *pos = intern->pos;\n\tif (pos != NULL) {\n\t\tintern->pos_h = pos->h;\n\t}\n} ", "target": 0}
{"code": "int authRequired(client *c) {\n    int auth_required = (!(DefaultUser->flags & USER_FLAG_NOPASS) ||\n                          (DefaultUser->flags & USER_FLAG_DISABLED)) &&\n                        !c->authenticated;\n    return auth_required;\n}", "target": 0}
{"code": "check_mime_type(const gchar* uri,GError** error)\n{\n    GError * err = NULL;\n    const gchar* mimeFromFile;\n    mimeFromFile = ev_file_get_mime_type(uri, FALSE, &err);\n    if (mimeFromFile)\n    {\n        const gchar* mimetypes[] = {\"application/epub+zip\", \"application/x-booki+zip\", NULL};\n        guint i;\n        for (i = 0; i < g_strv_length (mimetypes); i++) {\n           if (strcmp(mimeFromFile, mimetypes[i]) == 0)\n                return TRUE;\n\t}\n        if (strcmp (mimeFromFile, \"application/zip\") == 0)\n        {\n            mimeFromFile = ev_file_get_mime_type (uri, TRUE, &err);\n            if (mimeFromFile)\n            {\n                for (i = 0; i < g_strv_length (mimetypes); i++) {\n                    if (g_strcmp0(mimeFromFile, mimetypes[i]) == 0)\n                        return TRUE;\n                }\n                g_set_error_literal (error,\n                                     EV_DOCUMENT_ERROR,\n                                     EV_DOCUMENT_ERROR_INVALID,\n                                     _(\"Not an ePub document\"));\n                return FALSE;\n            }\n        }\n    }\n    if (err)\n        g_propagate_error (error, err);\n    else\n        g_set_error_literal (error,\n                             EV_DOCUMENT_ERROR,\n                             EV_DOCUMENT_ERROR_INVALID,\n                             _(\"Unknown MIME Type\"));\n    return FALSE;\n}", "target": 1}
{"code": "NOEXPORT void reload_config() {\n    static int delay=10; \n#ifdef HAVE_CHROOT\n    struct stat sb;\n#endif \n    if(options_parse(CONF_RELOAD)) {\n        s_log(LOG_ERR, \"Failed to reload the configuration file\");\n        return;\n    }\n    unbind_ports();\n    log_flush(LOG_MODE_BUFFER);\n#ifdef HAVE_CHROOT\n    if(global_options.chroot_dir && stat(\"/dev/log\", &sb))\n        log_close(SINK_OUTFILE);\n    else\n#endif \n        log_close(SINK_SYSLOG|SINK_OUTFILE);\n    options_free();\n    options_apply();\n    log_open(SINK_SYSLOG|SINK_OUTFILE);\n    log_flush(LOG_MODE_CONFIGURED);\n    ui_config_reloaded();\n    if(bind_ports() | exec_connect_start()) {\n        s_poll_sleep(delay/1000, delay%1000); \n        signal_post(SIGNAL_RELOAD_CONFIG); \n        delay*=2;\n        if(delay > 10000) \n            delay=10000;\n    } else {\n        delay=10; \n    }\n}", "target": 1}
{"code": "void HTMLTextAreaElement::setMaxLength(int newValue, ExceptionState& exceptionState)\n{\n    if (newValue < 0)\n        exceptionState.throwDOMException(IndexSizeError, \"The value provided (\" + String::number(newValue) + \") is not positive or 0.\");\n    else\n        setIntegralAttribute(maxlengthAttr, newValue);\n}", "target": 0}
{"code": "void _WM_do_pitch(struct _mdi *mdi, struct _event_data *data) {\n    struct _note *note_data = mdi->note;\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n    mdi->channel[ch].pitch = data->data.value - 0x2000;\n    if (mdi->channel[ch].pitch < 0) {\n        mdi->channel[ch].pitch_adjust = mdi->channel[ch].pitch_range\n        * mdi->channel[ch].pitch / 8192;\n    } else {\n        mdi->channel[ch].pitch_adjust = mdi->channel[ch].pitch_range\n        * mdi->channel[ch].pitch / 8191;\n    }\n    if (note_data) {\n        do {\n            if ((note_data->noteid >> 8) == ch) {\n                note_data->sample_inc = get_inc(mdi, note_data);\n            }\n            note_data = note_data->next;\n        } while (note_data);\n    }\n}", "target": 0}
{"code": "NAN_METHOD(DetectCharacterEncoding) {\n\tNan::HandleScope scope;\n\tv8::Local<v8::Object> inputBuffer = info[0]->ToObject();\n\tUCharsetDetector *charsetDetector;\n\tconst UCharsetMatch *charsetMatch;\n\tUErrorCode errorCode = U_ZERO_ERROR;\n\tcharsetDetector = ucsdet_open(&errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to open ICU charset detector.\");\n\t\treturn;\n\t}\n\tucsdet_setText(\n\t\tcharsetDetector,\n\t\tnode::Buffer::Data(inputBuffer),\n\t\tnode::Buffer::Length(inputBuffer),\n\t\t&errorCode\n\t);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to set ICU charset detectors text.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tcharsetMatch = ucsdet_detect(charsetDetector, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to detect charset.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tif(charsetMatch == NULL) {\n\t\tinfo.GetReturnValue().Set(Nan::Null());\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tconst char *charsetName = ucsdet_getName(charsetMatch, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get name from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tint32_t confidence = ucsdet_getConfidence(charsetMatch, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get confidence from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tv8::Local<v8::Object> obj = Nan::New<v8::Object>();\n\tobj->Set(Nan::New<v8::String>(\"encoding\").ToLocalChecked(), Nan::New<v8::String>(charsetName).ToLocalChecked());\n\tobj->Set(Nan::New<v8::String>(\"confidence\").ToLocalChecked(), Nan::New<v8::Number>(confidence));\n\tinfo.GetReturnValue().Set(obj);\n\tucsdet_close(charsetDetector);\n}", "target": 0}
{"code": "static int ttusbdecfe_dvbs_diseqc_send_master_cmd(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd *cmd)\n{\n\tstruct ttusbdecfe_state* state = (struct ttusbdecfe_state*) fe->demodulator_priv;\n\tu8 b[] = { 0x00, 0xff, 0x00, 0x00,\n\t\t   0x00, 0x00, 0x00, 0x00,\n\t\t   0x00, 0x00 };\n\tif (cmd->msg_len > sizeof(b) - 4)\n\t\treturn -EINVAL;\n\tmemcpy(&b[4], cmd->msg, cmd->msg_len);\n\tstate->config->send_command(fe, 0x72,\n\t\t\t\t    sizeof(b) - (6 - cmd->msg_len), b,\n\t\t\t\t    NULL, NULL);\n\treturn 0;\n}", "target": 0}
{"code": "SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,\n\t\tinfop, int, options, struct rusage __user *, ru)\n{\n\tstruct rusage r;\n\tstruct waitid_info info = {.status = 0};\n\tlong err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);\n\tint signo = 0;\n\tif (err > 0) {\n\t\tsigno = SIGCHLD;\n\t\terr = 0;\n\t}\n\tif (!err) {\n\t\tif (ru && copy_to_user(ru, &r, sizeof(struct rusage)))\n\t\t\treturn -EFAULT;\n\t}\n\tif (!infop)\n\t\treturn err;\n\tuser_access_begin();\n\tunsafe_put_user(signo, &infop->si_signo, Efault);\n\tunsafe_put_user(0, &infop->si_errno, Efault);\n\tunsafe_put_user(info.cause, &infop->si_code, Efault);\n\tunsafe_put_user(info.pid, &infop->si_pid, Efault);\n\tunsafe_put_user(info.uid, &infop->si_uid, Efault);\n\tunsafe_put_user(info.status, &infop->si_status, Efault);\n\tuser_access_end();\n\treturn err;\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}", "target": 1}
{"code": "static struct file *path_openat(int dfd, struct filename *pathname,\n\t\tstruct nameidata *nd, const struct open_flags *op, int flags)\n{\n\tstruct file *file;\n\tstruct path path;\n\tint opened = 0;\n\tint error;\n\tfile = get_empty_filp();\n\tif (IS_ERR(file))\n\t\treturn file;\n\tfile->f_flags = op->open_flag;\n\tif (unlikely(file->f_flags & __O_TMPFILE)) {\n\t\terror = do_tmpfile(dfd, pathname, nd, flags, op, file, &opened);\n\t\tgoto out;\n\t}\n\terror = path_init(dfd, pathname, flags, nd);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = do_last(nd, &path, file, op, &opened, pathname);\n\twhile (unlikely(error > 0)) { \n\t\tstruct path link = path;\n\t\tvoid *cookie;\n\t\tif (!(nd->flags & LOOKUP_FOLLOW)) {\n\t\t\tpath_put_conditional(&path, nd);\n\t\t\tpath_put(&nd->path);\n\t\t\terror = -ELOOP;\n\t\t\tbreak;\n\t\t}\n\t\terror = may_follow_link(&link, nd);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\t\tnd->flags |= LOOKUP_PARENT;\n\t\tnd->flags &= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);\n\t\terror = follow_link(&link, nd, &cookie);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\t\terror = do_last(nd, &path, file, op, &opened, pathname);\n\t\tput_link(nd, &link, cookie);\n\t}\nout:\n\tpath_cleanup(nd);\n\tif (!(opened & FILE_OPENED)) {\n\t\tBUG_ON(!error);\n\t\tput_filp(file);\n\t}\n\tif (unlikely(error)) {\n\t\tif (error == -EOPENSTALE) {\n\t\t\tif (flags & LOOKUP_RCU)\n\t\t\t\terror = -ECHILD;\n\t\t\telse\n\t\t\t\terror = -ESTALE;\n\t\t}\n\t\tfile = ERR_PTR(error);\n\t}\n\treturn file;\n}", "target": 1}
{"code": "  UsageAndQuotaDispatcherTask(\n      QuotaManager* manager,\n      const std::string& host,\n      StorageType type)\n      : QuotaTask(manager),\n        host_(host),\n        type_(type),\n        quota_(-1),\n        global_usage_(-1),\n        global_unlimited_usage_(-1),\n        host_usage_(-1),\n        quota_status_(kQuotaStatusUnknown),\n        waiting_callbacks_(1),\n        callback_factory_(ALLOW_THIS_IN_INITIALIZER_LIST(this)) {}", "target": 0}
{"code": "mldv2_report_print(netdissect_options *ndo, const u_char *bp, u_int len)\n{\n    const struct icmp6_hdr *icp = (const struct icmp6_hdr *) bp;\n    u_int group, nsrcs, ngroups;\n    u_int i, j;\n    if (len < 8) {\n            ND_PRINT((ndo,\" [invalid len %d]\", len));\n            return;\n    }\n    ND_TCHECK(icp->icmp6_data16[1]);\n    ngroups = EXTRACT_16BITS(&icp->icmp6_data16[1]);\n    ND_PRINT((ndo,\", %d group record(s)\", ngroups));\n    if (ndo->ndo_vflag > 0) {\n\tgroup = 8;\n        for (i = 0; i < ngroups; i++) {\n\t    if (len < group + 20) {\n                    ND_PRINT((ndo,\" [invalid number of groups]\"));\n                    return;\n\t    }\n            ND_TCHECK2(bp[group + 4], sizeof(struct in6_addr));\n            ND_PRINT((ndo,\" [gaddr %s\", ip6addr_string(ndo, &bp[group + 4])));\n\t    ND_PRINT((ndo,\" %s\", tok2str(mldv2report2str, \" [v2-report-#%d]\",\n                                         bp[group])));\n            nsrcs = (bp[group + 2] << 8) + bp[group + 3];\n\t    if (len < group + 20 + (nsrcs * sizeof(struct in6_addr))) {\n                    ND_PRINT((ndo,\" [invalid number of sources %d]\", nsrcs));\n                    return;\n\t    }\n            if (ndo->ndo_vflag == 1)\n                    ND_PRINT((ndo,\", %d source(s)\", nsrcs));\n            else {\n                    ND_PRINT((ndo,\" {\"));\n                for (j = 0; j < nsrcs; j++) {\n                    ND_TCHECK2(bp[group + 20 + j * sizeof(struct in6_addr)],\n                            sizeof(struct in6_addr));\n\t\t    ND_PRINT((ndo,\" %s\", ip6addr_string(ndo, &bp[group + 20 + j * sizeof(struct in6_addr)])));\n\t\t}\n                ND_PRINT((ndo,\" }\"));\n            }\n            group += 20 + nsrcs * sizeof(struct in6_addr);\n\t    ND_PRINT((ndo,\"]\"));\n        }\n    }\n    return;\ntrunc:\n    ND_PRINT((ndo,\"[|icmp6]\"));\n    return;\n}", "target": 1}
{"code": "void bnx2x_setup_cnic_irq_info(struct bnx2x *bp)\n{\n\tstruct cnic_eth_dev *cp = &bp->cnic_eth_dev;\n\tif (bp->flags & USING_MSIX_FLAG) {\n\t\tcp->drv_state |= CNIC_DRV_STATE_USING_MSIX;\n\t\tcp->irq_arr[0].irq_flags |= CNIC_IRQ_FL_MSIX;\n\t\tcp->irq_arr[0].vector = bp->msix_table[1].vector;\n\t} else {\n\t\tcp->drv_state &= ~CNIC_DRV_STATE_USING_MSIX;\n\t\tcp->irq_arr[0].irq_flags &= ~CNIC_IRQ_FL_MSIX;\n\t}\n\tif (!CHIP_IS_E1x(bp))\n\t\tcp->irq_arr[0].status_blk = (void *)bp->cnic_sb.e2_sb;\n\telse\n\t\tcp->irq_arr[0].status_blk = (void *)bp->cnic_sb.e1x_sb;\n\tcp->irq_arr[0].status_blk_num =  bnx2x_cnic_fw_sb_id(bp);\n\tcp->irq_arr[0].status_blk_num2 = bnx2x_cnic_igu_sb_id(bp);\n\tcp->irq_arr[1].status_blk = bp->def_status_blk;\n\tcp->irq_arr[1].status_blk_num = DEF_SB_ID;\n\tcp->irq_arr[1].status_blk_num2 = DEF_SB_IGU_ID;\n\tcp->num_irq = 2;\n}", "target": 0}
{"code": "raptor_rdfxml_parse_start(raptor_parser* rdf_parser)\n{\n  raptor_uri *uri = rdf_parser->base_uri;\n  raptor_rdfxml_parser* rdf_xml_parser;\n  rdf_xml_parser = (raptor_rdfxml_parser*)rdf_parser->context;\n  if(!uri)\n    return 1;\n  raptor_sax2_set_option(rdf_xml_parser->sax2,\n                         RAPTOR_OPTION_NORMALIZE_LANGUAGE, NULL,\n                         RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NORMALIZE_LANGUAGE));\n  raptor_sax2_set_option(rdf_xml_parser->sax2, \n                         RAPTOR_OPTION_NO_NET, NULL,\n                         RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NO_NET));\n  raptor_sax2_set_option(rdf_xml_parser->sax2, \n                         RAPTOR_OPTION_NO_FILE, NULL,\n                         RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NO_FILE));\n  raptor_sax2_set_option(rdf_xml_parser->sax2, \n                         RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES, NULL,\n                         RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES));\n  if(rdf_parser->uri_filter)\n    raptor_sax2_set_uri_filter(rdf_xml_parser->sax2, rdf_parser->uri_filter,\n                               rdf_parser->uri_filter_user_data);\n  raptor_sax2_parse_start(rdf_xml_parser->sax2, uri);\n  if(rdf_xml_parser->id_set) {\n    raptor_free_id_set(rdf_xml_parser->id_set);\n    rdf_xml_parser->id_set = NULL;\n  }\n  if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_CHECK_RDF_ID)) {\n    rdf_xml_parser->id_set = raptor_new_id_set(rdf_parser->world);\n    if(!rdf_xml_parser->id_set)\n      return 1;\n  }\n  return 0;\n}", "target": 0}
{"code": "void SSH2_update_kex_myproposal(PTInstVar pvar)\n{\n\tstatic char buf[512]; \n\tint index;\n\tint i;\n\tif (pvar->socket != INVALID_SOCKET) {\n\t\tif (pvar->kex_status & KEX_FLAG_REKEYING) {\n\t\t\tint pos = strlen(myproposal[PROPOSAL_KEX_ALGS]) - strlen(\",ext-info-c\");\n\t\t\tif (strcmp(myproposal[PROPOSAL_KEX_ALGS] + pos, \",ext-info-c\") == 0) {\n\t\t\t\tmyproposal[PROPOSAL_KEX_ALGS][pos] = '\\0';\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tbuf[0] = '\\0';\n\tfor (i = 0 ; pvar->settings.KexOrder[i] != 0 ; i++) {\n\t\tindex = pvar->settings.KexOrder[i] - '0';\n\t\tif (index == KEX_DH_NONE) \n\t\t\tbreak;\n\t\tstrncat_s(buf, sizeof(buf), get_kex_algorithm_name(index), _TRUNCATE);\n\t\tstrncat_s(buf, sizeof(buf), \",\", _TRUNCATE);\n\t}\n\tstrncat_s(buf, sizeof(buf), \"ext-info-c\", _TRUNCATE);\n\tmyproposal[PROPOSAL_KEX_ALGS] = buf; \n}", "target": 1}
{"code": "find_extend_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma, *prev;\n\taddr &= PAGE_MASK;\n\tvma = find_vma_prev(mm, addr, &prev);\n\tif (vma && (vma->vm_start <= addr))\n\t\treturn vma;\n\tif (!prev || expand_stack(prev, addr))\n\t\treturn NULL;\n\tif (prev->vm_flags & VM_LOCKED)\n\t\tpopulate_vma_page_range(prev, addr, prev->vm_end, NULL);\n\treturn prev;\n}", "target": 1}
{"code": "static int cert_verify_ignore_callback(X509_STORE_CTX*, void*)\n{\n    return 1;\n}", "target": 0}
{"code": "TEST(TensorSliceTest, BuildTensorSlice) {\n  TensorSliceProto proto;\n  TensorSlice({{0, -1}, {0, 10}, {14, 1}}).AsProto(&proto);\n  TensorSlice s;\n  {\n    TF_ASSERT_OK(TensorSlice::BuildTensorSlice(proto, &s));\n    EXPECT_EQ(\"-:0,10:14,1\", s.DebugString());\n  }\n  {\n    TensorSliceProto invalid_proto = proto;\n    invalid_proto.mutable_extent(0)->set_start(-1);\n    EXPECT_FALSE(TensorSlice::BuildTensorSlice(invalid_proto, &s).ok());\n  }\n  {\n    TensorSliceProto invalid_proto = proto;\n    invalid_proto.mutable_extent(2)->set_length(-1);\n    EXPECT_FALSE(TensorSlice::BuildTensorSlice(invalid_proto, &s).ok());\n  }\n  {\n    TensorSliceProto invalid_proto = proto;\n    invalid_proto.mutable_extent(2)->clear_length();\n    EXPECT_FALSE(TensorSlice::BuildTensorSlice(invalid_proto, &s).ok());\n  }\n  {\n    TensorSliceProto invalid_proto = proto;\n    invalid_proto.mutable_extent(2)->set_length(\n        std::numeric_limits<int64_t>::max());\n    EXPECT_FALSE(TensorSlice::BuildTensorSlice(invalid_proto, &s).ok());\n  }\n}", "target": 0}
{"code": "int LayerTilerChromium::tileIndex(int i, int j) const\n{\n    ASSERT(i >= 0 && j >= 0 && i < m_layerTileSize.width() && j < m_layerTileSize.height());\n    return i + j * m_layerTileSize.width();\n}", "target": 0}
{"code": "idn2_to_ascii_4i (const uint32_t * input, size_t inlen, char * output, int flags)\n{\n  uint32_t *input_u32;\n  uint8_t *input_u8, *output_u8;\n  size_t length;\n  int rc;\n  if (!input)\n    {\n      if (output)\n\t*output = 0;\n      return IDN2_OK;\n    }\n  input_u32 = (uint32_t *) malloc ((inlen + 1) * sizeof(uint32_t));\n  if (!input_u32)\n    return IDN2_MALLOC;\n  u32_cpy (input_u32, input, inlen);\n  input_u32[inlen] = 0;\n  input_u8 = u32_to_u8 (input_u32, inlen + 1, NULL, &length);\n  free (input_u32);\n  if (!input_u8)\n    {\n      if (errno == ENOMEM)\n\treturn IDN2_MALLOC;\n      return IDN2_ENCODING_ERROR;\n    }\n  rc = idn2_lookup_u8 (input_u8, &output_u8, flags);\n  free (input_u8);\n  if (rc == IDN2_OK)\n    {\n      if (output)\n\tstrcpy (output, (const char *) output_u8);\n      free(output_u8);\n    }\n  return rc;\n}", "target": 1}
{"code": "  cert_chain_t::clear() {\n    _certs.clear();\n  }", "target": 0}
{"code": "    CommentValue::CharsetId CommentValue::CharsetInfo::charsetIdByCode(\n        const std::string& code)\n    {\n        int i = 0;\n        for (;    charsetTable_[i].charsetId_ != lastCharsetId\n               && std::string(charsetTable_[i].code_, 8) != code; ++i) {}\n        return charsetTable_[i].charsetId_ == lastCharsetId ?\n               invalidCharsetId : charsetTable_[i].charsetId_;\n    }", "target": 0}
{"code": "void Interpreter::saveGenerator(\n    Runtime *runtime,\n    PinnedHermesValue *frameRegs,\n    const Inst *resumeIP) {\n  auto *innerFn = vmcast<GeneratorInnerFunction>(FRAME.getCalleeClosure());\n  innerFn->saveStack(runtime);\n  innerFn->setNextIP(resumeIP);\n  innerFn->setState(GeneratorInnerFunction::State::SuspendedYield);\n}", "target": 0}
{"code": "int main()\n{\n    gdImagePtr im;\n    im = gdImageCreate(64970, 65111);\n    gdTestAssert(im == NULL);\n    return gdNumFailures();\n}", "target": 0}
{"code": "static ssize_t bat_socket_read(struct file *file, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct socket_client *socket_client = file->private_data;\n\tstruct socket_packet *socket_packet;\n\tsize_t packet_len;\n\tint error;\n\tif ((file->f_flags & O_NONBLOCK) && (socket_client->queue_len == 0))\n\t\treturn -EAGAIN;\n\tif ((!buf) || (count < sizeof(struct icmp_packet)))\n\t\treturn -EINVAL;\n\tif (!access_ok(VERIFY_WRITE, buf, count))\n\t\treturn -EFAULT;\n\terror = wait_event_interruptible(socket_client->queue_wait,\n\t\t\t\t\t socket_client->queue_len);\n\tif (error)\n\t\treturn error;\n\tspin_lock_bh(&socket_client->lock);\n\tsocket_packet = list_first_entry(&socket_client->queue_list,\n\t\t\t\t\t struct socket_packet, list);\n\tlist_del(&socket_packet->list);\n\tsocket_client->queue_len--;\n\tspin_unlock_bh(&socket_client->lock);\n\terror = copy_to_user(buf, &socket_packet->icmp_packet,\n\t\t\t     socket_packet->icmp_len);\n\tpacket_len = socket_packet->icmp_len;\n\tkfree(socket_packet);\n\tif (error)\n\t\treturn -EFAULT;\n\treturn packet_len;\n}", "target": 1}
{"code": "static bool too_many_pipe_buffers_hard(struct user_struct *user)\n{\n\treturn pipe_user_pages_hard &&\n\t       atomic_long_read(&user->pipe_bufs) >= pipe_user_pages_hard;\n}", "target": 0}
{"code": "static inline void init_idle_pids(struct pid_link *links)\n{\n\tenum pid_type type;\n\tfor (type = PIDTYPE_PID; type < PIDTYPE_MAX; ++type) {\n\t\tINIT_HLIST_NODE(&links[type].node); \n\t\tlinks[type].pid = &init_struct_pid;\n\t}\n}", "target": 0}
{"code": "static int sanitize_val_alu(struct bpf_verifier_env *env,\n\t\t\t    struct bpf_insn *insn)\n{\n\tstruct bpf_insn_aux_data *aux = cur_aux(env);\n\tif (can_skip_alu_sanitation(env, insn))\n\t\treturn 0;\n\treturn update_alu_sanitation_state(aux, BPF_ALU_NON_POINTER, 0);\n}", "target": 0}
{"code": "static pj_status_t STATUS_FROM_SSL_ERR(char *action, pj_ssl_sock_t *ssock,\n\t\t\t\t       unsigned long err)\n{\n    int level = 0;\n    int len = 0; \n    ERROR_LOG(\"STATUS_FROM_SSL_ERR\", err, ssock);\n    level++;\n    if (err == SSL_ERROR_SSL) {\n\terr = ERR_get_error();\n\tERROR_LOG(\"STATUS_FROM_SSL_ERR\", err, ssock);\n    }\n    ssock->last_err = err;\n    return GET_STATUS_FROM_SSL_ERR(err);\n}", "target": 1}
{"code": "cmsSEQ* CMSEXPORT cmsAllocProfileSequenceDescription(cmsContext ContextID, cmsUInt32Number n)\n{\n    cmsSEQ* Seq;\n    cmsUInt32Number i;\n    if (n == 0) return NULL;\n    if (n > 255) return NULL;\n    Seq = (cmsSEQ*) _cmsMallocZero(ContextID, sizeof(cmsSEQ));\n    if (Seq == NULL) return NULL;\n    Seq -> ContextID = ContextID;\n    Seq -> seq      = (cmsPSEQDESC*) _cmsCalloc(ContextID, n, sizeof(cmsPSEQDESC));\n    Seq -> n        = n;\n    if (Seq -> seq == NULL) {\n        _cmsFree(ContextID, Seq);\n        return NULL;\n    }\n    for (i=0; i < n; i++) {\n        Seq -> seq[i].Manufacturer = NULL;\n        Seq -> seq[i].Model        = NULL;\n        Seq -> seq[i].Description  = NULL;\n    }\n    return Seq;\n}", "target": 0}
{"code": "static int ax25_shutdown(struct socket *sk, int how)\n{\n\treturn -EOPNOTSUPP;\n}", "target": 0}
{"code": "static void udf_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, udf_i_callback);\n}", "target": 0}
{"code": "pci_emul_capwrite(struct pci_vdev *dev, int offset, int bytes, uint32_t val)\n{\n\tint capid;\n\tuint8_t capoff, nextoff;\n\tif ((offset & (bytes - 1)) != 0)\n\t\treturn;\n\tcapoff = CAP_START_OFFSET;\n\twhile (1) {\n\t\tnextoff = pci_get_cfgdata8(dev, capoff + 1);\n\t\tif (nextoff == 0)\n\t\t\tbreak;\n\t\tif (offset >= capoff && offset < nextoff)\n\t\t\tbreak;\n\t\tcapoff = nextoff;\n\t}\n\tassert(offset >= capoff);\n\tif (offset == capoff || offset == capoff + 1) {\n\t\tif (offset == capoff && bytes == 4) {\n\t\t\tbytes = 2;\n\t\t\toffset += 2;\n\t\t\tval >>= 16;\n\t\t} else\n\t\t\treturn;\n\t}\n\tcapid = pci_get_cfgdata8(dev, capoff);\n\tswitch (capid) {\n\tcase PCIY_MSI:\n\t\tmsicap_cfgwrite(dev, capoff, offset, bytes, val);\n\t\tbreak;\n\tcase PCIY_MSIX:\n\t\tmsixcap_cfgwrite(dev, capoff, offset, bytes, val);\n\t\tbreak;\n\tcase PCIY_EXPRESS:\n\t\tpciecap_cfgwrite(dev, capoff, offset, bytes, val);\n\t\tbreak;\n\tdefault:\n\t\tCFGWRITE(dev, offset, val, bytes);\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "int main(int argc, char **argv)\n{\n  test_cmp_parameters inParam;\n  FILE *fbase=NULL, *ftest=NULL;\n  int same = 0;\n  char lbase[256];\n  char strbase[256];\n  char ltest[256];\n  char strtest[256];\n  if( parse_cmdline_cmp(argc, argv, &inParam) == 1 )\n    {\n    compare_dump_files_help_display();\n    goto cleanup;\n    }\n  printf(\"******Parameters********* \\n\");\n  printf(\" base_filename = %s\\n\"\n    \" test_filename = %s\\n\",\n    inParam.base_filename, inParam.test_filename);\n  printf(\"************************* \\n\");\n  printf(\"Try to open: %s for reading ... \", inParam.base_filename);\n  if((fbase = fopen(inParam.base_filename, \"rb\"))==NULL)\n    {\n    goto cleanup;\n    }\n  printf(\"Ok.\\n\");\n  printf(\"Try to open: %s for reading ... \", inParam.test_filename);\n  if((ftest = fopen(inParam.test_filename, \"rb\"))==NULL)\n    {\n    goto cleanup;\n    }\n  printf(\"Ok.\\n\");\n  while (fgets(lbase, sizeof(lbase), fbase) && fgets(ltest,sizeof(ltest),ftest))\n    {\n    int nbase = sscanf(lbase, \"%255[^\\r\\n]\", strbase);\n    int ntest = sscanf(ltest, \"%255[^\\r\\n]\", strtest);\n    assert( nbase != 255 && ntest != 255 );\n    if( nbase != 1 || ntest != 1 )\n      {\n      fprintf(stderr, \"could not parse line from files\\n\" );\n      goto cleanup;\n      }\n    if( strcmp( strbase, strtest ) != 0 )\n      {\n      fprintf(stderr,\"<%s> vs. <%s>\\n\", strbase, strtest);\n      goto cleanup;\n      }\n    }\n  same = 1;\n  printf(\"\\n***** TEST SUCCEED: Files are the same. *****\\n\");\ncleanup:\n  if(fbase) fclose(fbase);\n  if(ftest) fclose(ftest);\n  free(inParam.base_filename);\n  free(inParam.test_filename);\n  return same ? EXIT_SUCCESS : EXIT_FAILURE;\n}", "target": 1}
{"code": "bool StringSanMatcher::match(const GENERAL_NAME* general_name) const {\n  if (general_name->type != general_name_type_) {\n    return false;\n  }\n  const std::string san = Utility::generalNameAsString(general_name);\n  return general_name->type == GEN_DNS &&\n                 matcher_.matcher().match_pattern_case() ==\n                     envoy::type::matcher::v3::StringMatcher::MatchPatternCase::kExact\n             ? Utility::dnsNameMatch(matcher_.matcher().exact(), absl::string_view(san))\n             : matcher_.match(san);\n}", "target": 0}
{"code": "static void ext_session_lock_surface_v1_handle_configure(void *data,\n\t\tstruct ext_session_lock_surface_v1 *lock_surface, uint32_t serial,\n\t\tuint32_t width, uint32_t height) {\n\tstruct swaylock_surface *surface = data;\n\tsurface->width = width;\n\tsurface->height = height;\n\tsurface->indicator_width = 0;\n\tsurface->indicator_height = 0;\n\text_session_lock_surface_v1_ack_configure(lock_surface, serial);\n\trender_frame_background(surface);\n\trender_frame(surface);\n}", "target": 0}
{"code": "int sqliteAuthorizer(void* userData,\n                     int code,\n                     const char* arg3,\n                     const char* arg4,\n                     const char* arg5,\n                     const char* arg6) {\n  if (kAllowedSQLiteActionCodes.count(code) > 0) {\n    return SQLITE_OK;\n  }\n  LOG(ERROR) << \"Authorizer denied action \" << code << \" \"\n             << (arg3 ? arg3 : \"null\") << \" \" << (arg4 ? arg4 : \"null\") << \" \"\n             << (arg5 ? arg5 : \"null\") << \" \" << (arg6 ? arg6 : \"null\");\n  return SQLITE_DENY;\n}", "target": 0}
{"code": "update_job_run (updateJobPtr job)\n{\n\tif (*(job->request->source) == '|') {\n\t\tdebug1 (DEBUG_UPDATE, \"Recognized local command: %s\", job->request->source);\n\t\tupdate_exec_cmd (job);\n\t\treturn;\n\t}\n\tif (strstr (job->request->source, \":\n\t\tnetwork_process_request (job);\n\t\treturn;\n\t}\n\t{\n\t\tdebug1 (DEBUG_UPDATE, \"Recognized file URI: %s\", job->request->source);\n\t\tupdate_load_file (job);\n\t\treturn;\n\t}\n}", "target": 1}
{"code": "static int cxusb_ctrl_msg(struct dvb_usb_device *d,\n\t\t\t  u8 cmd, u8 *wbuf, int wlen, u8 *rbuf, int rlen)\n{\n\tstruct cxusb_state *st = d->priv;\n\tint ret, wo;\n\tif (1 + wlen > MAX_XFER_SIZE) {\n\t\twarn(\"i2c wr: len=%d is too big!\\n\", wlen);\n\t\treturn -EOPNOTSUPP;\n\t}\n\two = (rbuf == NULL || rlen == 0); \n\tmutex_lock(&d->data_mutex);\n\tst->data[0] = cmd;\n\tmemcpy(&st->data[1], wbuf, wlen);\n\tif (wo)\n\t\tret = dvb_usb_generic_write(d, st->data, 1 + wlen);\n\telse\n\t\tret = dvb_usb_generic_rw(d, st->data, 1 + wlen,\n\t\t\t\t\t rbuf, rlen, 0);\n\tmutex_unlock(&d->data_mutex);\n\treturn ret;\n}", "target": 1}
{"code": "spnego_gss_wrap_size_limit(\n\tOM_uint32\t*minor_status,\n\tconst gss_ctx_id_t context_handle,\n\tint\t\tconf_req_flag,\n\tgss_qop_t\tqop_req,\n\tOM_uint32\treq_output_size,\n\tOM_uint32\t*max_input_size)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_size_limit(minor_status,\n\t\t\t\tcontext_handle,\n\t\t\t\tconf_req_flag,\n\t\t\t\tqop_req,\n\t\t\t\treq_output_size,\n\t\t\t\tmax_input_size);\n\treturn (ret);\n}", "target": 1}
{"code": "void RenderWidgetHostImpl::DidStopFlinging() {\n  if (view_)\n    view_->DidStopFlinging();\n}", "target": 0}
{"code": "static void bson_append( bson *b, const void *data, int len ) {\n    memcpy( b->cur , data , len );\n    b->cur += len;\n}", "target": 1}
{"code": "bool allow_svhandler_flash_sector(const FlashSector* sector) {\n  return sector->use == FLASH_STORAGE1 ||\n         sector->use == FLASH_STORAGE2 ||\n         sector->use == FLASH_STORAGE3 ||\n         sector->use == FLASH_UNUSED0 ||\n         sector->use == FLASH_APP;\n}", "target": 0}
{"code": "static inline bool set_page_guard(struct zone *zone, struct page *page,\n\t\t\t\tunsigned int order, int migratetype)\n{\n\tstruct page_ext *page_ext;\n\tif (!debug_guardpage_enabled())\n\t\treturn false;\n\tif (order >= debug_guardpage_minorder())\n\t\treturn false;\n\tpage_ext = lookup_page_ext(page);\n\tif (unlikely(!page_ext))\n\t\treturn false;\n\t__set_bit(PAGE_EXT_DEBUG_GUARD, &page_ext->flags);\n\tINIT_LIST_HEAD(&page->lru);\n\tset_page_private(page, order);\n\t__mod_zone_freepage_state(zone, -(1 << order), migratetype);\n\treturn true;\n}", "target": 0}
{"code": "user_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct passwd *pw, const struct member *m)\n{\n    const struct sudoers_context *ctx = parse_tree->ctx;\n    const char *lhost = parse_tree->lhost ? parse_tree->lhost : ctx->runas.host;\n    const char *shost = parse_tree->shost ? parse_tree->shost : ctx->runas.shost;\n    int matched = UNSPEC;\n    struct alias *a;\n    debug_decl(user_matches, SUDOERS_DEBUG_MATCH);\n    switch (m->type) {\n\tcase ALL:\n\t    matched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase NETGROUP:\n\t    if (netgr_matches(parse_tree->nss, m->name,\n\t\tdef_netgroup_tuple ? lhost : NULL,\n\t\tdef_netgroup_tuple ? shost : NULL, pw->pw_name))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase USERGROUP:\n\t    if (usergr_matches(m->name, pw->pw_name, pw))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase ALIAS:\n\t    if ((a = alias_get(parse_tree, m->name, USERALIAS)) != NULL) {\n\t\tconst int rc = userlist_matches(parse_tree, pw, &a->members);\n\t\tif (rc != UNSPEC) {\n\t\t    if (m->negated) {\n\t\t\tmatched = rc == ALLOW ? DENY : ALLOW;\n\t\t    } else {\n\t\t\tmatched = rc;\n\t\t    }\n\t\t}\n\t\talias_put(a);\n\t\tbreak;\n\t    }\n\t    FALLTHROUGH;\n\tcase WORD:\n\t    if (userpw_matches(m->name, pw->pw_name, pw))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 1}
{"code": "void __mb2_cache_entry_free(struct mb2_cache_entry *entry)\n{\n\tkmem_cache_free(mb2_entry_cache, entry);\n}", "target": 0}
{"code": "OpLevelCostEstimator::OpDimensionsFromInputs(\n    const TensorShapeProto& original_image_shape, const OpInfo& op_info,\n    bool* found_unknown_shapes) {\n  VLOG(2) << \"op features: \" << op_info.DebugString();\n  VLOG(2) << \"Original image shape: \" << original_image_shape.DebugString();\n  auto image_shape =\n      MaybeGetMinimumShape(original_image_shape, 4, found_unknown_shapes);\n  VLOG(2) << \"Image shape: \" << image_shape.DebugString();\n  int x_index, y_index, channel_index;\n  const std::string& data_format = GetDataFormat(op_info);\n  if (data_format == \"NCHW\") {\n    channel_index = 1;\n    y_index = 2;\n    x_index = 3;\n  } else {\n    y_index = 1;\n    x_index = 2;\n    channel_index = 3;\n  }\n  int64_t batch = image_shape.dim(0).size();\n  int64_t ix = image_shape.dim(x_index).size();\n  int64_t iy = image_shape.dim(y_index).size();\n  int64_t iz = image_shape.dim(channel_index).size();\n  std::vector<int64_t> ksize = GetKernelSize(op_info);\n  int64_t kx = ksize[x_index];\n  int64_t ky = ksize[y_index];\n  int64_t kz = iz;\n  std::vector<int64_t> strides = GetStrides(op_info);\n  int64_t sx = strides[x_index];\n  int64_t sy = strides[y_index];\n  if (sx == 0 || sy == 0) {\n    return errors::InvalidArgument(\n        \"Stride must be > 0 for Height and Width, but got (\", sy, \", \", sx,\n        \")\");\n  }\n  const auto padding = GetPadding(op_info);\n  int64_t ox = GetOutputSize(ix, kx, sx, padding);\n  int64_t oy = GetOutputSize(iy, ky, sy, padding);\n  int64_t oz = iz;\n  OpLevelCostEstimator::ConvolutionDimensions conv_dims = {\n      batch, ix, iy, iz, kx, ky, kz, oz, ox, oy, sx, sy, padding};\n  return conv_dims;\n}", "target": 0}
{"code": "static void do_change_user(FILE *fin, FILE *fout) {\n  char uname[BUFFER_SIZE];\n  read_buf(fin, uname);\n  if (strlen(uname) > 0) {\n    struct passwd *pw = getpwnam(uname);\n    if (pw) {\n      if (pw->pw_gid) {\n        setgid(pw->pw_gid);\n      }\n      if (pw->pw_uid) {\n        setuid(pw->pw_uid);\n      }\n    }\n  }\n}", "target": 1}
{"code": "static int get_gate_page(struct mm_struct *mm, unsigned long address,\n\t\tunsigned int gup_flags, struct vm_area_struct **vma,\n\t\tstruct page **page)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\tint ret = -EFAULT;\n\tif (gup_flags & FOLL_WRITE)\n\t\treturn -EFAULT;\n\tif (address > TASK_SIZE)\n\t\tpgd = pgd_offset_k(address);\n\telse\n\t\tpgd = pgd_offset_gate(mm, address);\n\tBUG_ON(pgd_none(*pgd));\n\tp4d = p4d_offset(pgd, address);\n\tBUG_ON(p4d_none(*p4d));\n\tpud = pud_offset(p4d, address);\n\tBUG_ON(pud_none(*pud));\n\tpmd = pmd_offset(pud, address);\n\tif (!pmd_present(*pmd))\n\t\treturn -EFAULT;\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\tpte = pte_offset_map(pmd, address);\n\tif (pte_none(*pte))\n\t\tgoto unmap;\n\t*vma = get_gate_vma(mm);\n\tif (!page)\n\t\tgoto out;\n\t*page = vm_normal_page(*vma, address, *pte);\n\tif (!*page) {\n\t\tif ((gup_flags & FOLL_DUMP) || !is_zero_pfn(pte_pfn(*pte)))\n\t\t\tgoto unmap;\n\t\t*page = pte_page(*pte);\n\t\tif (is_device_public_page(*page))\n\t\t\tgoto unmap;\n\t}\n\tget_page(*page);\nout:\n\tret = 0;\nunmap:\n\tpte_unmap(pte);\n\treturn ret;\n}", "target": 1}
{"code": "static int ocfs2_lock_get_block(struct inode *inode, sector_t iblock,\n\t\t    struct buffer_head *bh_result, int create)\n{\n\tint ret = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tdown_read(&oi->ip_alloc_sem);\n\tret = ocfs2_get_block(inode, iblock, bh_result, create);\n\tup_read(&oi->ip_alloc_sem);\n\treturn ret;\n}", "target": 0}
{"code": "static int xfrm_dump_policy_start(struct netlink_callback *cb)\n{\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;\n\tBUILD_BUG_ON(sizeof(*walk) > sizeof(cb->args));\n\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\n\treturn 0;\n}", "target": 0}
{"code": "content::ColorChooser* Browser::OpenColorChooser(\n      WebContents* web_contents,\n      SkColor initial_color,\n      const std::vector<content::ColorSuggestion>& suggestions) {\n  return chrome::ShowColorChooser(web_contents, initial_color);\n}", "target": 0}
{"code": "int main(int argc, char *argv[]) {\n  struct mschm_decompressor *chmd;\n  struct mschmd_header *chm;\n  struct mschmd_file *file, **f;\n  unsigned int numf, i;\n  setbuf(stdout, NULL);\n  setbuf(stderr, NULL);\n  user_umask = umask(0); umask(user_umask);\n  MSPACK_SYS_SELFTEST(i);\n  if (i) return 0;\n  if ((chmd = mspack_create_chm_decompressor(NULL))) {\n    for (argv++; *argv; argv++) {\n      printf(\"%s\\n\", *argv);\n      if ((chm = chmd->open(chmd, *argv))) {\n\tfor (numf=0, file=chm->files; file; file = file->next) numf++;\n\tif ((f = (struct mschmd_file **) calloc(numf, sizeof(struct mschmd_file *)))) {\n\t  for (i=0, file=chm->files; file; file = file->next) f[i++] = file;\n\t  qsort(f, numf, sizeof(struct mschmd_file *), &sortfunc);\n\t  for (i = 0; i < numf; i++) {\n\t    char *outname = create_output_name((unsigned char *)f[i]->filename,NULL,0,1,0);\n\t    printf(\"Extracting %s\\n\", outname);\n\t    ensure_filepath(outname);\n\t    if (chmd->extract(chmd, f[i], outname)) {\n\t      printf(\"%s: extract error on \\\"%s\\\": %s\\n\",\n\t\t     *argv, f[i]->filename, ERROR(chmd));\n\t    }\n\t    free(outname);\n\t  }\n\t  free(f);\n\t}\n\tchmd->close(chmd, chm);\n      }\n      else {\n\tprintf(\"%s: can't open -- %s\\n\", *argv, ERROR(chmd));\n      }\n    }\n    mspack_destroy_chm_decompressor(chmd);\n  }\n  return 0;\n}", "target": 1}
{"code": "static void reds_update_agent_properties(RedsState *reds)\n{\n    if (!reds->agent_dev || reds->config == NULL) {\n        return;\n    }\n    reds->agent_dev->priv->write_filter.copy_paste_enabled = reds->config->agent_copypaste;\n    reds->agent_dev->priv->read_filter.copy_paste_enabled = reds->config->agent_copypaste;\n    reds->agent_dev->priv->write_filter.file_xfer_enabled = reds->config->agent_file_xfer;\n    reds->agent_dev->priv->read_filter.file_xfer_enabled = reds->config->agent_file_xfer;\n}", "target": 0}
{"code": "decode_bytestring(CBORDecoderObject *self, uint8_t subtype)\n{\n    uint64_t length = 0;\n    bool indefinite = true;\n    PyObject *ret;\n    char length_hex[17];\n    if (decode_length(self, subtype, &length, &indefinite) == -1)\n        return NULL;\n    if (length > (uint64_t)PY_SSIZE_T_MAX - (uint64_t)PyBytesObject_SIZE) {\n        sprintf(length_hex, \"%llX\", length);\n        PyErr_Format(\n                _CBOR2_CBORDecodeValueError,\n                \"excessive bytestring size 0x%s\", length_hex);\n        return NULL;\n    }\n    if (indefinite)\n        ret = decode_indefinite_bytestrings(self);\n    else\n        ret = decode_definite_bytestring(self, (Py_ssize_t)length);\n    set_shareable(self, ret);\n    return ret;\n}", "target": 1}
{"code": "static void ieee80211_if_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tdev->netdev_ops = &ieee80211_dataif_ops;\n\tdev->destructor = free_netdev;\n}", "target": 0}
{"code": "vmx_patch_hypercall(struct kvm_vcpu *vcpu, unsigned char *hypercall)\n{\n\thypercall[0] = 0x0f;\n\thypercall[1] = 0x01;\n\thypercall[2] = 0xc1;\n}", "target": 0}
{"code": "static inline void ext2_xattr_destroy_cache(struct mb2_cache *cache)\n{\n}", "target": 0}
{"code": "get_chainname_rulenum(const struct ipt_entry *s, const struct ipt_entry *e,\n\t\t      const char *hookname, const char **chainname,\n\t\t      const char **comment, unsigned int *rulenum)\n{\n\tconst struct xt_standard_target *t = (void *)ipt_get_target_c(s);\n\tif (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {\n\t\t*chainname = t->target.data;\n\t\t(*rulenum) = 0;\n\t} else if (s == e) {\n\t\t(*rulenum)++;\n\t\tif (s->target_offset == sizeof(struct ipt_entry) &&\n\t\t    strcmp(t->target.u.kernel.target->name,\n\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t   t->verdict < 0 &&\n\t\t   unconditional(&s->ip)) {\n\t\t\t*comment = *chainname == hookname\n\t\t\t\t? comments[NF_IP_TRACE_COMMENT_POLICY]\n\t\t\t\t: comments[NF_IP_TRACE_COMMENT_RETURN];\n\t\t}\n\t\treturn 1;\n\t} else\n\t\t(*rulenum)++;\n\treturn 0;\n}", "target": 1}
{"code": "MONGO_EXPORT int mongo_run_command( mongo *conn, const char *db, const bson *command,\n                                    bson *out ) {\n    int ret = MONGO_OK;\n    bson response = {NULL, 0};\n    bson fields;\n    int sl = strlen( db );\n    char *ns = bson_malloc( sl + 5 + 1 ); \n    int res, success = 0;\n    strcpy( ns, db );\n    strcpy( ns+sl, \".$cmd\" );\n    res = mongo_find_one( conn, ns, command, bson_empty( &fields ), &response );\n    bson_free( ns );\n    if( res != MONGO_OK )\n        ret = MONGO_ERROR;\n    else {\n        bson_iterator it;\n        if( bson_find( &it, &response, \"ok\" ) )\n            success = bson_iterator_bool( &it );\n        if( !success ) {\n            conn->err = MONGO_COMMAND_FAILED;\n            bson_destroy( &response );\n            ret = MONGO_ERROR;\n        }\n        else {\n            if( out )\n                *out = response;\n            else\n                bson_destroy( &response );\n        }\n    }\n    return ret;\n}", "target": 1}
{"code": "static void mem_cgroup_usage_unregister_event(struct cgroup *cgrp,\n\tstruct cftype *cft, struct eventfd_ctx *eventfd)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cgrp);\n\tstruct mem_cgroup_thresholds *thresholds;\n\tstruct mem_cgroup_threshold_ary *new;\n\tint type = MEMFILE_TYPE(cft->private);\n\tu64 usage;\n\tint i, j, size;\n\tmutex_lock(&memcg->thresholds_lock);\n\tif (type == _MEM)\n\t\tthresholds = &memcg->thresholds;\n\telse if (type == _MEMSWAP)\n\t\tthresholds = &memcg->memsw_thresholds;\n\telse\n\t\tBUG();\n\tBUG_ON(!thresholds);\n\tusage = mem_cgroup_usage(memcg, type == _MEMSWAP);\n\t__mem_cgroup_threshold(memcg, type == _MEMSWAP);\n\tsize = 0;\n\tfor (i = 0; i < thresholds->primary->size; i++) {\n\t\tif (thresholds->primary->entries[i].eventfd != eventfd)\n\t\t\tsize++;\n\t}\n\tnew = thresholds->spare;\n\tif (!size) {\n\t\tkfree(new);\n\t\tnew = NULL;\n\t\tgoto swap_buffers;\n\t}\n\tnew->size = size;\n\tnew->current_threshold = -1;\n\tfor (i = 0, j = 0; i < thresholds->primary->size; i++) {\n\t\tif (thresholds->primary->entries[i].eventfd == eventfd)\n\t\t\tcontinue;\n\t\tnew->entries[j] = thresholds->primary->entries[i];\n\t\tif (new->entries[j].threshold < usage) {\n\t\t\t++new->current_threshold;\n\t\t}\n\t\tj++;\n\t}\nswap_buffers:\n\tthresholds->spare = thresholds->primary;\n\trcu_assign_pointer(thresholds->primary, new);\n\tsynchronize_rcu();\n\tmutex_unlock(&memcg->thresholds_lock);\n}", "target": 1}
{"code": "is_create_with_attrs(struct nfsd4_open *open)\n{\n\treturn open->op_create == NFS4_OPEN_CREATE\n\t\t&& (open->op_createmode == NFS4_CREATE_UNCHECKED\n\t\t    || open->op_createmode == NFS4_CREATE_GUARDED\n\t\t    || open->op_createmode == NFS4_CREATE_EXCLUSIVE4_1);\n}", "target": 0}
{"code": "struct pico_socket *pico_tcp_open(struct pico_stack *S, uint16_t family)\n{\n    struct pico_socket_tcp *t = PICO_ZALLOC(sizeof(struct pico_socket_tcp));\n    if (!t)\n        return NULL;\n    t->sock.stack = S;\n    t->sock.timestamp = TCP_TIME;\n    pico_socket_set_family(&t->sock, family);\n    t->mss = (uint16_t)(pico_socket_get_mss(&t->sock) - PICO_SIZE_TCPHDR);\n    t->tcpq_in.pool.root = t->tcpq_hold.pool.root = t->tcpq_out.pool.root = &LEAF;\n    t->tcpq_hold.pool.compare = t->tcpq_out.pool.compare = segment_compare;\n    t->tcpq_in.pool.compare = input_segment_compare;\n    t->tcpq_in.max_size = PICO_DEFAULT_SOCKETQ;\n    t->tcpq_out.max_size = PICO_DEFAULT_SOCKETQ;\n    t->tcpq_hold.max_size = 2u * t->mss;\n    rto_set(t, PICO_TCP_RTO_MIN);\n    t->sock.opt_flags |= (1 << PICO_SOCKET_OPT_TCPNODELAY);\n    t->linger_timeout = PICO_SOCKET_LINGER_TIMEOUT;\n#ifdef PICO_TCP_SUPPORT_SOCKET_STATS\n    if (!pico_timer_add(t->sock.stack, 2000, sock_stats, t)) {\n        tcp_dbg(\"TCP: Failed to start socket statistics timer\\n\");\n        PICO_FREE(t);\n        return NULL;\n    }\n#endif\n    t->keepalive_tmr = pico_timer_add(t->sock.stack, 1000, pico_tcp_keepalive, t);\n    if (!t->keepalive_tmr) {\n        tcp_dbg(\"TCP: Failed to start keepalive timer\\n\");\n        PICO_FREE(t);\n        return NULL;\n    }\n    tcp_set_space(t);\n    return &t->sock;\n}", "target": 1}
{"code": "String string_chunk_split(const char *src, int srclen, const char *end,\n                          int endlen, int chunklen) {\n  int chunks = srclen / chunklen; \n  int restlen = srclen - chunks * chunklen; \n  int out_len = (chunks + 1) * endlen + srclen;\n  String ret(out_len, ReserveString);\n  char *dest = ret.bufferSlice().ptr;\n  const char *p; char *q;\n  const char *pMax = src + srclen - chunklen + 1;\n  for (p = src, q = dest; p < pMax; ) {\n    memcpy(q, p, chunklen);\n    q += chunklen;\n    memcpy(q, end, endlen);\n    q += endlen;\n    p += chunklen;\n  }\n  if (restlen) {\n    memcpy(q, p, restlen);\n    q += restlen;\n    memcpy(q, end, endlen);\n    q += endlen;\n  }\n  ret.setSize(q - dest);\n  return ret;\n}", "target": 1}
{"code": "attr_unknown_count (void)\n{\n  return transit_hash->count;\n}", "target": 0}
{"code": "void SetTransferMatrix(double x11,double x12,double x21,double x22,double x,double y)\n{\n    if ( ( fabs(x11-1.) > 0.001 ) || ( fabs(x22-1.) > 0.001 )\n         || ( fabs(x12) > 0.001 ) || ( fabs(x21) > 0.001 )\n         || ( fabs(x) > 0.001 ) || ( fabs(y) > 0.001 ) ) {\n        outpos +=\n        sprintf(outpos,\"%12.3f %12.3f %12.3f %12.3f %12.3f %12.3f cm\\n\",x11,x12,x21,x22,x,y);\n    }\n}", "target": 1}
{"code": "bool DefaultCertValidator::matchSubjectAltName(\n    X509* cert,\n    const std::vector<Matchers::StringMatcherImpl<envoy::type::matcher::v3::StringMatcher>>&\n        subject_alt_name_matchers) {\n  bssl::UniquePtr<GENERAL_NAMES> san_names(\n      static_cast<GENERAL_NAMES*>(X509_get_ext_d2i(cert, NID_subject_alt_name, nullptr, nullptr)));\n  if (san_names == nullptr) {\n    return false;\n  }\n  for (const GENERAL_NAME* general_name : san_names.get()) {\n    const std::string san = Utility::generalNameAsString(general_name);\n    for (auto& config_san_matcher : subject_alt_name_matchers) {\n      if (general_name->type == GEN_DNS &&\n                  config_san_matcher.matcher().match_pattern_case() ==\n                      envoy::type::matcher::v3::StringMatcher::MatchPatternCase::kExact\n              ? Utility::dnsNameMatch(config_san_matcher.matcher().exact(), absl::string_view(san))\n              : config_san_matcher.match(san)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}", "target": 1}
{"code": "int regset_tls_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   const void *kbuf, const void __user *ubuf)\n{\n\tstruct user_desc infobuf[GDT_ENTRY_TLS_ENTRIES];\n\tconst struct user_desc *info;\n\tint i;\n\tif (pos >= GDT_ENTRY_TLS_ENTRIES * sizeof(struct user_desc) ||\n\t    (pos % sizeof(struct user_desc)) != 0 ||\n\t    (count % sizeof(struct user_desc)) != 0)\n\t\treturn -EINVAL;\n\tif (kbuf)\n\t\tinfo = kbuf;\n\telse if (__copy_from_user(infobuf, ubuf, count))\n\t\treturn -EFAULT;\n\telse\n\t\tinfo = infobuf;\n\tfor (i = 0; i < count / sizeof(struct user_desc); i++)\n\t\tif (!tls_desc_okay(info + i))\n\t\t\treturn -EINVAL;\n\tset_tls_desc(target,\n\t\t     GDT_ENTRY_TLS_MIN + (pos / sizeof(struct user_desc)),\n\t\t     info, count / sizeof(struct user_desc));\n\treturn 0;\n}", "target": 0}
{"code": "      static double mp_g(_cimg_math_parser& mp) {\n        cimg::unused(mp);\n        return cimg::grand();", "target": 0}
{"code": "mcs_send_connect_initial(STREAM mcs_data)\n{\n\tint datalen = mcs_data->end - mcs_data->data;\n\tint length = 9 + 3 * 34 + 4 + datalen;\n\tSTREAM s;\n\ts = iso_init(length + 5);\n\tber_out_header(s, MCS_CONNECT_INITIAL, length);\n\tber_out_header(s, BER_TAG_OCTET_STRING, 1);\t\n\tout_uint8(s, 1);\n\tber_out_header(s, BER_TAG_OCTET_STRING, 1);\t\n\tout_uint8(s, 1);\n\tber_out_header(s, BER_TAG_BOOLEAN, 1);\n\tout_uint8(s, 0xff);\t\n\tmcs_out_domain_params(s, 34, 2, 0, 0xffff);\t\n\tmcs_out_domain_params(s, 1, 1, 1, 0x420);\t\n\tmcs_out_domain_params(s, 0xffff, 0xfc17, 0xffff, 0xffff);\t\n\tber_out_header(s, BER_TAG_OCTET_STRING, datalen);\n\tout_uint8p(s, mcs_data->data, datalen);\n\ts_mark_end(s);\n\tiso_send(s);\n}", "target": 0}
{"code": "static Status ValidateKernelSizes(const T& ksizes) {\n  for (size_t i = 0; i < ksizes.size(); ++i) {\n    if (ksizes[i] <= 0) {\n      return errors::InvalidArgument(\n          \"Sliding window ksize field for dimension \", i,\n          \" must be positive but is \", ksizes[i]);\n    }\n  }\n  return OkStatus();\n}", "target": 0}
{"code": "struct sk_buff **udp_gro_receive(struct sk_buff **head, struct sk_buff *skb,\n\t\t\t\t struct udphdr *uh)\n{\n\tstruct udp_offload_priv *uo_priv;\n\tstruct sk_buff *p, **pp = NULL;\n\tstruct udphdr *uh2;\n\tunsigned int off = skb_gro_offset(skb);\n\tint flush = 1;\n\tif (NAPI_GRO_CB(skb)->udp_mark ||\n\t    (skb->ip_summed != CHECKSUM_PARTIAL &&\n\t     NAPI_GRO_CB(skb)->csum_cnt == 0 &&\n\t     !NAPI_GRO_CB(skb)->csum_valid))\n\t\tgoto out;\n\tNAPI_GRO_CB(skb)->udp_mark = 1;\n\trcu_read_lock();\n\tuo_priv = rcu_dereference(udp_offload_base);\n\tfor (; uo_priv != NULL; uo_priv = rcu_dereference(uo_priv->next)) {\n\t\tif (net_eq(read_pnet(&uo_priv->net), dev_net(skb->dev)) &&\n\t\t    uo_priv->offload->port == uh->dest &&\n\t\t    uo_priv->offload->callbacks.gro_receive)\n\t\t\tgoto unflush;\n\t}\n\tgoto out_unlock;\nunflush:\n\tflush = 0;\n\tfor (p = *head; p; p = p->next) {\n\t\tif (!NAPI_GRO_CB(p)->same_flow)\n\t\t\tcontinue;\n\t\tuh2 = (struct udphdr   *)(p->data + off);\n\t\tif ((*(u32 *)&uh->source != *(u32 *)&uh2->source) ||\n\t\t    (!uh->check ^ !uh2->check)) {\n\t\t\tNAPI_GRO_CB(p)->same_flow = 0;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tskb_gro_pull(skb, sizeof(struct udphdr)); \n\tskb_gro_postpull_rcsum(skb, uh, sizeof(struct udphdr));\n\tNAPI_GRO_CB(skb)->proto = uo_priv->offload->ipproto;\n\tpp = uo_priv->offload->callbacks.gro_receive(head, skb,\n\t\t\t\t\t\t     uo_priv->offload);\nout_unlock:\n\trcu_read_unlock();\nout:\n\tNAPI_GRO_CB(skb)->flush |= flush;\n\treturn pp;\n}", "target": 1}
{"code": "void read(Protocol_* iprot, const StructInfo& structInfo, void* object) {\n  DCHECK(object);\n  ProtocolReaderStructReadState<Protocol_> readState;\n  readState.readStructBegin(iprot);\n  if (UNLIKELY(structInfo.unionExt != nullptr)) {\n    readState.fieldId = 0;\n    readState.readFieldBegin(iprot);\n    if (readState.atStop()) {\n      structInfo.unionExt->clear(object);\n      readState.readStructEnd(iprot);\n      return;\n    }\n    const auto* fieldInfo = findFieldInfo(iprot, readState, structInfo);\n    if (fieldInfo) {\n      void* unionVal = getMember(*fieldInfo, object);\n      structInfo.unionExt->initMember[fieldInfo - structInfo.fieldInfos](\n          unionVal);\n      read(iprot, *fieldInfo->typeInfo, readState, unionVal);\n      const_cast<FieldID&>(activeUnionMemberId(\n          object, structInfo.unionExt->unionTypeOffset)) = fieldInfo->id;\n    } else {\n      skip(iprot, readState);\n    }\n    readState.readFieldEnd(iprot);\n    readState.readFieldBegin(iprot);\n    if (UNLIKELY(!readState.atStop())) {\n      TProtocolException::throwUnionMissingStop();\n    }\n    readState.readStructEnd(iprot);\n    return;\n  }\n  FieldID prevFieldId = 0;\n  std::int16_t index = 0;\n  for (;; ++index) {\n    auto* fieldInfo = index < structInfo.numFields\n        ? &structInfo.fieldInfos[index]\n        : &kStopMarker;\n    if (UNLIKELY(!readState.advanceToNextField(\n            iprot, prevFieldId, fieldInfo->id, fieldInfo->typeInfo->type))) {\n      for (;;) {\n        readState.afterAdvanceFailure(iprot);\n        if (readState.atStop()) {\n          readState.readStructEnd(iprot);\n          return;\n        }\n        fieldInfo = findFieldInfo(iprot, readState, structInfo);\n        if (fieldInfo) {\n          index = fieldInfo - structInfo.fieldInfos;\n          break;\n        }\n        skip(iprot, readState);\n      }\n    } else if (UNLIKELY(index >= structInfo.numFields)) {\n      readState.readStructEnd(iprot);\n      return;\n    }\n    prevFieldId = fieldInfo->id;\n    read(iprot, *fieldInfo->typeInfo, readState, getMember(*fieldInfo, object));\n    if (fieldInfo->issetOffset > 0) {\n      const_cast<bool&>(fieldIsSet(object, fieldInfo->issetOffset)) = true;\n    }\n  }\n}", "target": 1}
{"code": "static char *dex_resolve_library(const char *library) {\n\tif (!library || library[0] != 'L') {\n\t\treturn NULL;\n\t}\n\tchar *demangled = strdup(library + 1);\n\trz_str_replace_ch(demangled, '/', '.', 1);\n\tdemangled[strlen(demangled) - 1] = 0;\n\treturn demangled;\n}", "target": 1}
{"code": "  UTF16Ref getUTF16Ref(llvh::SmallVectorImpl<char16_t> &allocator) const {\n    assert(allocator.empty() && \"Shouldn't use a non-empty allocator\");\n    return getUTF16Ref(allocator, false);\n  }", "target": 0}
{"code": "void ParamTraits<ListValue>::Write(Message* m, const param_type& p) {\n  WriteValue(m, &p, 0);\n}", "target": 0}
{"code": "test(int equal, const char *user_input, const char *secret)\n{\n    int out = password_equal(user_input, secret);\n    printf(\"%s: \\\"%s\\\" \\\"%s\\\"\\n\",\n        (equal == out) ? \"PASS\" : \"FAIL\",\n        user_input, secret);\n}", "target": 0}
{"code": "gsm_xsmp_client_connect (GsmXSMPClient *client,\n                         SmsConn        conn,\n                         unsigned long *mask_ret,\n                         SmsCallbacks  *callbacks_ret)\n{\n        client->priv->conn = conn;\n        if (client->priv->protocol_timeout) {\n                g_source_remove (client->priv->protocol_timeout);\n                client->priv->protocol_timeout = 0;\n        }\n        g_debug (\"GsmXSMPClient: Initializing client %s\", client->priv->description);\n        *mask_ret = 0;\n        *mask_ret |= SmsRegisterClientProcMask;\n        callbacks_ret->register_client.callback = register_client_callback;\n        callbacks_ret->register_client.manager_data  = client;\n        *mask_ret |= SmsInteractRequestProcMask;\n        callbacks_ret->interact_request.callback = interact_request_callback;\n        callbacks_ret->interact_request.manager_data = client;\n        *mask_ret |= SmsInteractDoneProcMask;\n        callbacks_ret->interact_done.callback = interact_done_callback;\n        callbacks_ret->interact_done.manager_data = client;\n        *mask_ret |= SmsSaveYourselfRequestProcMask;\n        callbacks_ret->save_yourself_request.callback = save_yourself_request_callback;\n        callbacks_ret->save_yourself_request.manager_data = client;\n        *mask_ret |= SmsSaveYourselfP2RequestProcMask;\n        callbacks_ret->save_yourself_phase2_request.callback = save_yourself_phase2_request_callback;\n        callbacks_ret->save_yourself_phase2_request.manager_data = client;\n        *mask_ret |= SmsSaveYourselfDoneProcMask;\n        callbacks_ret->save_yourself_done.callback = save_yourself_done_callback;\n        callbacks_ret->save_yourself_done.manager_data = client;\n        *mask_ret |= SmsCloseConnectionProcMask;\n        callbacks_ret->close_connection.callback = close_connection_callback;\n        callbacks_ret->close_connection.manager_data  = client;\n        *mask_ret |= SmsSetPropertiesProcMask;\n        callbacks_ret->set_properties.callback = set_properties_callback;\n        callbacks_ret->set_properties.manager_data = client;\n        *mask_ret |= SmsDeletePropertiesProcMask;\n        callbacks_ret->delete_properties.callback = delete_properties_callback;\n        callbacks_ret->delete_properties.manager_data = client;\n        *mask_ret |= SmsGetPropertiesProcMask;\n        callbacks_ret->get_properties.callback = get_properties_callback;\n        callbacks_ret->get_properties.manager_data = client;\n}", "target": 1}
{"code": "midi_synth_load_patch(int dev, int format, const char __user *addr,\n\t\t      int offs, int count, int pmgr_flag)\n{\n\tint             orig_dev = synth_devs[dev]->midi_dev;\n\tstruct sysex_info sysex;\n\tint             i;\n\tunsigned long   left, src_offs, eox_seen = 0;\n\tint             first_byte = 1;\n\tint             hdr_size = (unsigned long) &sysex.data[0] - (unsigned long) &sysex;\n\tleave_sysex(dev);\n\tif (!prefix_cmd(orig_dev, 0xf0))\n\t\treturn 0;\n\tif (format != SYSEX_PATCH)\n\t{\n\t\t  return -EINVAL;\n\t}\n\tif (count < hdr_size)\n\t{\n\t\treturn -EINVAL;\n\t}\n\tcount -= hdr_size;\n\tif(copy_from_user(&((char *) &sysex)[offs], &(addr)[offs], hdr_size - offs))\n\t\treturn -EFAULT;\n \tif (count < sysex.len)\n\t{\n\t\tsysex.len = count;\n\t}\n  \tleft = sysex.len;\n  \tsrc_offs = 0;\n\tfor (i = 0; i < left && !signal_pending(current); i++)\n\t{\n\t\tunsigned char   data;\n\t\tif (get_user(data,\n\t\t    (unsigned char __user *)(addr + hdr_size + i)))\n\t\t\treturn -EFAULT;\n\t\teox_seen = (i > 0 && data & 0x80);\t\n\t\tif (eox_seen && data != 0xf7)\n\t\t\tdata = 0xf7;\n\t\tif (i == 0)\n\t\t{\n\t\t\tif (data != 0xf0)\n\t\t\t{\n\t\t\t\tprintk(KERN_WARNING \"midi_synth: Sysex start missing\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\twhile (!midi_devs[orig_dev]->outputc(orig_dev, (unsigned char) (data & 0xff)) &&\n\t\t\t!signal_pending(current))\n\t\t\tschedule();\n\t\tif (!first_byte && data & 0x80)\n\t\t\treturn 0;\n\t\tfirst_byte = 0;\n\t}\n\tif (!eox_seen)\n\t\tmidi_outc(orig_dev, 0xf7);\n\treturn 0;\n}", "target": 1}
{"code": "static void Process_ipfix_template_withdraw(exporter_ipfix_domain_t *exporter, void *DataPtr, uint32_t size_left, FlowSource_t *fs) {\nipfix_template_record_t *ipfix_template_record;\n\twhile ( size_left ) {\n\t\tuint32_t id;\n\t\tif ( size_left < 4 ) {\n\t\t\tLogError(\"Process_ipfix [%u] Template withdraw size error at %s line %u\" , \n\t\t\t\texporter->info.id, __FILE__, __LINE__, strerror (errno));\n\t\t\tsize_left = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tipfix_template_record = (ipfix_template_record_t *)DataPtr;\n\t\tsize_left \t\t-= 4;\n\t\tid \t  = ntohs(ipfix_template_record->TemplateID);\n\t\tif ( id == IPFIX_TEMPLATE_FLOWSET_ID ) {\n\t\t\tremove_all_translation_tables(exporter);\n\t\t\tReInitExtensionMapList(fs);\n\t\t} else {\n\t\t\tremove_translation_table(fs, exporter, id);\n\t\t}\n\t\tDataPtr = DataPtr + 4;\n\t\tif ( size_left < 4 ) {\n\t\t\tdbg_printf(\"Skip %u bytes padding\\n\", size_left);\n\t\t\tsize_left = 0;\n\t\t}\n\t}\n} ", "target": 0}
{"code": "        bool operator==(const Key& key) const\n        {\n            return    key.tag_ == tag_\n                   && 0 == strncmp(key.ver_, ver_, strlen(ver_))\n                   && (size_ == 0 || key.size_ == size_);\n        }", "target": 0}
{"code": "static int crypto_report(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,\n\t\t\t struct nlattr **attrs)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct crypto_user_alg *p = nlmsg_data(in_nlh);\n\tstruct crypto_alg *alg;\n\tstruct sk_buff *skb;\n\tstruct crypto_dump_info info;\n\tint err;\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\talg = crypto_alg_match(p, 0);\n\tif (!alg)\n\t\treturn -ENOENT;\n\terr = -ENOMEM;\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto drop_alg;\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = in_nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = 0;\n\terr = crypto_report_alg(alg, &info);\ndrop_alg:\n\tcrypto_mod_put(alg);\n\tif (err)\n\t\treturn err;\n\treturn nlmsg_unicast(net->crypto_nlsk, skb, NETLINK_CB(in_skb).portid);\n}", "target": 1}
{"code": "static int oidc_cache_crypto_encrypt(request_rec *r, const char *plaintext,\n\t\tunsigned char *key, char **result) {\n\tchar *encoded = NULL, *p = NULL, *e_tag = NULL;\n\tunsigned char *ciphertext = NULL;\n\tint plaintext_len, ciphertext_len, encoded_len, e_tag_len;\n\tunsigned char tag[OIDC_CACHE_TAG_LEN];\n\tplaintext_len = strlen(plaintext) + 1;\n\tciphertext = apr_pcalloc(r->pool,\n\t\t\t(plaintext_len + EVP_CIPHER_block_size(OIDC_CACHE_CIPHER)));\n\tciphertext_len = oidc_cache_crypto_encrypt_impl(r,\n\t\t\t(unsigned char *) plaintext, plaintext_len,\n\t\t\tOIDC_CACHE_CRYPTO_GCM_AAD, sizeof(OIDC_CACHE_CRYPTO_GCM_AAD), key,\n\t\t\tOIDC_CACHE_CRYPTO_GCM_IV, sizeof(OIDC_CACHE_CRYPTO_GCM_IV),\n\t\t\tciphertext, tag, sizeof(tag));\n\tencoded_len = oidc_base64url_encode(r, &encoded, (const char *) ciphertext,\n\t\t\tciphertext_len, 1);\n\tif (encoded_len > 0) {\n\t\tp = encoded;\n\t\te_tag_len = oidc_base64url_encode(r, &e_tag, (const char *) tag,\n\t\t\t\tOIDC_CACHE_TAG_LEN, 1);\n\t\tencoded = apr_pcalloc(r->pool, encoded_len + 1 + e_tag_len + 1);\n\t\tmemcpy(encoded, p, encoded_len);\n\t\tp = encoded + encoded_len;\n\t\t*p = OIDC_CHAR_DOT;\n\t\tp++;\n\t\tmemcpy(p, e_tag, e_tag_len);\n\t\tencoded_len += e_tag_len + 1;\n\t\tencoded[encoded_len] = '\\0';\n\t\t*result = encoded;\n\t}\n\treturn encoded_len;\n}", "target": 1}
{"code": "DLLIMPORT unsigned int cfg_opt_size(cfg_opt_t *opt)\n{\n\tif (opt)\n\t\treturn opt->nvalues;\n\treturn 0;\n}", "target": 0}
{"code": "processInternalEntity(XML_Parser parser, ENTITY *entity, XML_Bool betweenDecl) {\n  const char *textStart, *textEnd;\n  const char *next;\n  enum XML_Error result;\n  OPEN_INTERNAL_ENTITY *openEntity;\n  if (parser->m_freeInternalEntities) {\n    openEntity = parser->m_freeInternalEntities;\n    parser->m_freeInternalEntities = openEntity->next;\n  } else {\n    openEntity\n        = (OPEN_INTERNAL_ENTITY *)MALLOC(parser, sizeof(OPEN_INTERNAL_ENTITY));\n    if (! openEntity)\n      return XML_ERROR_NO_MEMORY;\n  }\n  entity->open = XML_TRUE;\n#ifdef XML_DTD\n  entityTrackingOnOpen(parser, entity, __LINE__);\n#endif\n  entity->processed = 0;\n  openEntity->next = parser->m_openInternalEntities;\n  parser->m_openInternalEntities = openEntity;\n  openEntity->entity = entity;\n  openEntity->startTagLevel = parser->m_tagLevel;\n  openEntity->betweenDecl = betweenDecl;\n  openEntity->internalEventPtr = NULL;\n  openEntity->internalEventEndPtr = NULL;\n  textStart = (const char *)entity->textPtr;\n  textEnd = (const char *)(entity->textPtr + entity->textLen);\n  next = textStart;\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok\n        = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n                      tok, next, &next, XML_FALSE, XML_FALSE,\n                      XML_ACCOUNT_ENTITY_EXPANSION);\n  } else\n#endif \n    result = doContent(parser, parser->m_tagLevel, parser->m_internalEncoding,\n                       textStart, textEnd, &next, XML_FALSE,\n                       XML_ACCOUNT_ENTITY_EXPANSION);\n  if (result == XML_ERROR_NONE) {\n    if (textEnd != next && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n      entity->processed = (int)(next - textStart);\n      parser->m_processor = internalEntityProcessor;\n    } else {\n#ifdef XML_DTD\n      entityTrackingOnClose(parser, entity, __LINE__);\n#endif \n      entity->open = XML_FALSE;\n      parser->m_openInternalEntities = openEntity->next;\n      openEntity->next = parser->m_freeInternalEntities;\n      parser->m_freeInternalEntities = openEntity;\n    }\n  }\n  return result;\n}", "target": 1}
{"code": "int key_update(key_ref_t key_ref, const void *payload, size_t plen)\n{\n\tstruct key_preparsed_payload prep;\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\tkey_check(key);\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!key->type->update)\n\t\treturn -EOPNOTSUPP;\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = payload;\n\tprep.datalen = plen;\n\tprep.quotalen = key->type->def_datalen;\n\tprep.expiry = TIME_T_MAX;\n\tif (key->type->preparse) {\n\t\tret = key->type->preparse(&prep);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\tdown_write(&key->sem);\n\tret = key->type->update(key, &prep);\n\tif (ret == 0)\n\t\tclear_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\tup_write(&key->sem);\nerror:\n\tif (key->type->preparse)\n\t\tkey->type->free_preparse(&prep);\n\treturn ret;\n}", "target": 1}
{"code": "struct dst_entry *inet6_csk_route_req(const struct sock *sk,\n\t\t\t\t      struct flowi6 *fl6,\n\t\t\t\t      const struct request_sock *req,\n\t\t\t\t      u8 proto)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct in6_addr *final_p, final;\n\tstruct dst_entry *dst;\n\tmemset(fl6, 0, sizeof(*fl6));\n\tfl6->flowi6_proto = proto;\n\tfl6->daddr = ireq->ir_v6_rmt_addr;\n\tfinal_p = fl6_update_dst(fl6, np->opt, &final);\n\tfl6->saddr = ireq->ir_v6_loc_addr;\n\tfl6->flowi6_oif = ireq->ir_iif;\n\tfl6->flowi6_mark = ireq->ir_mark;\n\tfl6->fl6_dport = ireq->ir_rmt_port;\n\tfl6->fl6_sport = htons(ireq->ir_num);\n\tsecurity_req_classify_flow(req, flowi6_to_flowi(fl6));\n\tdst = ip6_dst_lookup_flow(sk, fl6, final_p);\n\tif (IS_ERR(dst))\n\t\treturn NULL;\n\treturn dst;\n}", "target": 1}
{"code": "static GF_AV1Config* AV1_DuplicateConfig(GF_AV1Config const * const cfg) {\n\tu32 i = 0;\n\tGF_AV1Config *out = gf_malloc(sizeof(GF_AV1Config));\n\tout->marker = cfg->marker;\n\tout->version = cfg->version;\n\tout->seq_profile = cfg->seq_profile;\n\tout->seq_level_idx_0 = cfg->seq_level_idx_0;\n\tout->seq_tier_0 = cfg->seq_tier_0;\n\tout->high_bitdepth = cfg->high_bitdepth;\n\tout->twelve_bit = cfg->twelve_bit;\n\tout->monochrome = cfg->monochrome;\n\tout->chroma_subsampling_x = cfg->chroma_subsampling_x;\n\tout->chroma_subsampling_y = cfg->chroma_subsampling_y;\n\tout->chroma_sample_position = cfg->chroma_sample_position;\n\tout->initial_presentation_delay_present = cfg->initial_presentation_delay_present;\n\tout->initial_presentation_delay_minus_one = cfg->initial_presentation_delay_minus_one;\n\tout->obu_array = gf_list_new();\n\tfor (i = 0; i<gf_list_count(cfg->obu_array); ++i) {\n\t\tGF_AV1_OBUArrayEntry *dst = gf_malloc(sizeof(GF_AV1_OBUArrayEntry)), *src = gf_list_get(cfg->obu_array, i);\n\t\tdst->obu_length = src->obu_length;\n\t\tdst->obu_type = src->obu_type;\n\t\tdst->obu = gf_malloc((size_t)dst->obu_length);\n\t\tmemcpy(dst->obu, src->obu, (size_t)src->obu_length);\n\t\tgf_list_add(out->obu_array, dst);\n\t}\n\treturn out;\n}", "target": 1}
{"code": "static void compact(VarEnv* v, Array &ret, const Variant& var) {\n  if (var.isArray()) {\n    for (ArrayIter iter(var.getArrayData()); iter; ++iter) {\n      compact(v, ret, iter.second());\n    }\n  } else {\n    String varname = var.toString();\n    if (!varname.empty() && v->lookup(varname.get()) != NULL) {\n      ret.set(varname, *reinterpret_cast<Variant*>(v->lookup(varname.get())));\n    }\n  }\n}", "target": 1}
{"code": "void xenvif_carrier_off(struct xenvif *vif)\n{\n\tstruct net_device *dev = vif->dev;\n\trtnl_lock();\n\tnetif_carrier_off(dev); \n\tif (netif_running(dev))\n\t\txenvif_down(vif);\n\trtnl_unlock();\n\txenvif_put(vif);\n}", "target": 0}
{"code": "static inline void show_node(struct zone *zone)\n{\n\tif (IS_ENABLED(CONFIG_NUMA))\n\t\tprintk(\"Node %d \", zone_to_nid(zone));\n}", "target": 0}
{"code": "ip_optprint(netdissect_options *ndo,\n            register const u_char *cp, u_int length)\n{\n\tregister u_int option_len;\n\tconst char *sep = \"\";\n\tfor (; length > 0; cp += option_len, length -= option_len) {\n\t\tu_int option_code;\n\t\tND_PRINT((ndo, \"%s\", sep));\n\t\tsep = \",\";\n\t\tND_TCHECK(*cp);\n\t\toption_code = *cp;\n\t\tND_PRINT((ndo, \"%s\",\n\t\t          tok2str(ip_option_values,\"unknown %u\",option_code)));\n\t\tif (option_code == IPOPT_NOP ||\n                    option_code == IPOPT_EOL)\n\t\t\toption_len = 1;\n\t\telse {\n\t\t\tND_TCHECK(cp[1]);\n\t\t\toption_len = cp[1];\n\t\t\tif (option_len < 2) {\n\t\t\t\tND_PRINT((ndo, \" [bad length %u]\", option_len));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (option_len > length) {\n\t\t\tND_PRINT((ndo, \" [bad length %u]\", option_len));\n\t\t\treturn;\n\t\t}\n\t\tND_TCHECK2(*cp, option_len);\n\t\tswitch (option_code) {\n\t\tcase IPOPT_EOL:\n\t\t\treturn;\n\t\tcase IPOPT_TS:\n\t\t\tip_printts(ndo, cp, option_len);\n\t\t\tbreak;\n\t\tcase IPOPT_RR:       \n\t\tcase IPOPT_SSRR:\n\t\tcase IPOPT_LSRR:\n\t\t\tip_printroute(ndo, cp, option_len);\n\t\t\tbreak;\n\t\tcase IPOPT_RA:\n\t\t\tif (option_len < 4) {\n\t\t\t\tND_PRINT((ndo, \" [bad length %u]\", option_len));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tND_TCHECK(cp[3]);\n\t\t\tif (EXTRACT_16BITS(&cp[2]) != 0)\n\t\t\t\tND_PRINT((ndo, \" value %u\", EXTRACT_16BITS(&cp[2])));\n\t\t\tbreak;\n\t\tcase IPOPT_NOP:       \n\t\tcase IPOPT_SECURITY:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\n}", "target": 1}
{"code": "static int rngapi_reset(struct crypto_rng *tfm, const u8 *seed,\n\t\t\tunsigned int slen)\n{\n\tu8 *buf = NULL;\n\tu8 *src = (u8 *)seed;\n\tint err;\n\tif (slen) {\n\t\tbuf = kmalloc(slen, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(buf, seed, slen);\n\t\tsrc = buf;\n\t}\n\terr = crypto_old_rng_alg(tfm)->rng_reset(tfm, src, slen);\n\tkzfree(buf);\n\treturn err;\n}", "target": 1}
{"code": "static int host_start(struct ci13xxx *ci)\n{\n\tstruct usb_hcd *hcd;\n\tstruct ehci_hcd *ehci;\n\tint ret;\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\thcd = usb_create_hcd(&ci_ehci_hc_driver, ci->dev, dev_name(ci->dev));\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\tdev_set_drvdata(ci->dev, ci);\n\thcd->rsrc_start = ci->hw_bank.phys;\n\thcd->rsrc_len = ci->hw_bank.size;\n\thcd->regs = ci->hw_bank.abs;\n\thcd->has_tt = 1;\n\thcd->power_budget = ci->platdata->power_budget;\n\thcd->phy = ci->transceiver;\n\tehci = hcd_to_ehci(hcd);\n\tehci->caps = ci->hw_bank.cap;\n\tehci->has_hostpc = ci->hw_bank.lpm;\n\tret = usb_add_hcd(hcd, 0, 0);\n\tif (ret)\n\t\tusb_put_hcd(hcd);\n\telse\n\t\tci->hcd = hcd;\n\tif (ci->platdata->flags & CI13XXX_DISABLE_STREAMING)\n\t\thw_write(ci, OP_USBMODE, USBMODE_CI_SDIS, USBMODE_CI_SDIS);\n\treturn ret;\n}", "target": 0}
{"code": "static int snd_ctl_elem_user_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\tmutex_lock(&ue->card->user_ctl_lock);\n\tmemcpy(&ucontrol->value, ue->elem_data, ue->elem_data_size);\n\tmutex_unlock(&ue->card->user_ctl_lock);\n\treturn 0;\n}", "target": 0}
{"code": "ospf6_print_lshdr(netdissect_options *ndo,\n                  register const struct lsa6_hdr *lshp, const u_char *dataend)\n{\n\tif ((const u_char *)(lshp + 1) > dataend)\n\t\tgoto trunc;\n\tND_TCHECK(lshp->ls_type);\n\tND_TCHECK(lshp->ls_seq);\n\tND_PRINT((ndo, \"\\n\\t  Advertising Router %s, seq 0x%08x, age %us, length %u\",\n               ipaddr_string(ndo, &lshp->ls_router),\n               EXTRACT_32BITS(&lshp->ls_seq),\n               EXTRACT_16BITS(&lshp->ls_age),\n               EXTRACT_16BITS(&lshp->ls_length)-(u_int)sizeof(struct lsa6_hdr)));\n\tospf6_print_ls_type(ndo, EXTRACT_16BITS(&lshp->ls_type), &lshp->ls_stateid);\n\treturn (0);\ntrunc:\n\treturn (1);\n}", "target": 1}
{"code": "videobuf_vm_close(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\tstruct videobuf_queue *q = map->q;\n\tint i;\n\tdprintk(2,\"vm_close %p [count=%d,vma=%08lx-%08lx]\\n\",map,\n\t\tmap->count,vma->vm_start,vma->vm_end);\n\tmap->count--;\n\tif (0 == map->count) {\n\t\tdprintk(1,\"munmap %p q=%p\\n\",map,q);\n\t\tmutex_lock(&q->lock);\n\t\tfor (i = 0; i < VIDEO_MAX_FRAME; i++) {\n\t\t\tif (NULL == q->bufs[i])\n\t\t\t\tcontinue;\n\t\t\tif (q->bufs[i]->map != map)\n\t\t\t\tcontinue;\n\t\t\tq->ops->buf_release(q,q->bufs[i]);\n\t\t\tq->bufs[i]->map   = NULL;\n\t\t\tq->bufs[i]->baddr = 0;\n\t\t}\n\t\tmutex_unlock(&q->lock);\n\t\tkfree(map);\n\t}\n\treturn;\n}", "target": 1}
{"code": "static ssize_t drop_sync(QIOChannel *ioc, size_t size)\n{\n    ssize_t ret = 0;\n    char small[1024];\n    char *buffer;\n    buffer = sizeof(small) < size ? small : g_malloc(MIN(65536, size));\n    while (size > 0) {\n        ssize_t count = read_sync(ioc, buffer, MIN(65536, size));\n        if (count <= 0) {\n            goto cleanup;\n        }\n        assert(count <= size);\n        size -= count;\n        ret += count;\n    }\n cleanup:\n    if (buffer != small) {\n        g_free(buffer);\n    }\n    return ret;\n}", "target": 1}
{"code": "void gdImageSetBrush (gdImagePtr im, gdImagePtr brush)\n{\n\tint i;\n\tim->brush = brush;\n\tif (!im->trueColor && !im->brush->trueColor) {\n\t\tfor (i = 0; i < gdImageColorsTotal(brush); i++) {\n\t\t\tint index;\n\t\t\tindex = gdImageColorResolveAlpha(im, gdImageRed(brush, i), gdImageGreen(brush, i), gdImageBlue(brush, i), gdImageAlpha(brush, i));\n\t\t\tim->brushColorMap[i] = index;\n\t\t}\n\t}\n}", "target": 0}
{"code": "display_debug_not_supported (struct dwarf_section *section,\n\t\t\t     void *file ATTRIBUTE_UNUSED)\n{\n  printf (_(\"Displaying the debug contents of section %s is not yet supported.\\n\"),\n\t    section->name);\n  return 1;\n}", "target": 0}
{"code": "void LogOmniboxZeroSuggestRequest(\n    ZeroSuggestRequestsHistogramValue request_value) {\n  UMA_HISTOGRAM_ENUMERATION(\"Omnibox.ZeroSuggestRequests\", request_value,\n                            ZERO_SUGGEST_MAX_REQUEST_HISTOGRAM_VALUE);\n}", "target": 0}
{"code": "static int ceph_aes_crypt(const struct ceph_crypto_key *key, bool encrypt,\n\t\t\t  void *buf, int buf_len, int in_len, int *pout_len)\n{\n\tstruct crypto_skcipher *tfm = ceph_crypto_alloc_cipher();\n\tSKCIPHER_REQUEST_ON_STACK(req, tfm);\n\tstruct sg_table sgt;\n\tstruct scatterlist prealloc_sg;\n\tchar iv[AES_BLOCK_SIZE];\n\tint pad_byte = AES_BLOCK_SIZE - (in_len & (AES_BLOCK_SIZE - 1));\n\tint crypt_len = encrypt ? in_len + pad_byte : in_len;\n\tint ret;\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\tWARN_ON(crypt_len > buf_len);\n\tif (encrypt)\n\t\tmemset(buf + in_len, pad_byte, pad_byte);\n\tret = setup_sgtable(&sgt, &prealloc_sg, buf, crypt_len);\n\tif (ret)\n\t\tgoto out_tfm;\n\tcrypto_skcipher_setkey((void *)tfm, key->key, key->len);\n\tmemcpy(iv, aes_iv, AES_BLOCK_SIZE);\n\tskcipher_request_set_tfm(req, tfm);\n\tskcipher_request_set_callback(req, 0, NULL, NULL);\n\tskcipher_request_set_crypt(req, sgt.sgl, sgt.sgl, crypt_len, iv);\n\tif (encrypt)\n\t\tret = crypto_skcipher_encrypt(req);\n\telse\n\t\tret = crypto_skcipher_decrypt(req);\n\tskcipher_request_zero(req);\n\tif (ret) {\n\t\tpr_err(\"%s %scrypt failed: %d\\n\", __func__,\n\t\t       encrypt ? \"en\" : \"de\", ret);\n\t\tgoto out_sgt;\n\t}\n\tif (encrypt) {\n\t\t*pout_len = crypt_len;\n\t} else {\n\t\tpad_byte = *(char *)(buf + in_len - 1);\n\t\tif (pad_byte > 0 && pad_byte <= AES_BLOCK_SIZE &&\n\t\t    in_len >= pad_byte) {\n\t\t\t*pout_len = in_len - pad_byte;\n\t\t} else {\n\t\t\tpr_err(\"%s got bad padding %d on in_len %d\\n\",\n\t\t\t       __func__, pad_byte, in_len);\n\t\t\tret = -EPERM;\n\t\t\tgoto out_sgt;\n\t\t}\n\t}\nout_sgt:\n\tteardown_sgtable(&sgt);\nout_tfm:\n\tcrypto_free_skcipher(tfm);\n\treturn ret;\n}", "target": 0}
{"code": "sysDescr_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_string(varbind, oid, CONTIKI_VERSION_STRING);\n}", "target": 1}
{"code": "bool isCPUDevice() {\n  return false;\n}", "target": 0}
{"code": "DSA_Signature_Operation::raw_sign(const uint8_t msg[], size_t msg_len,\n                                  RandomNumberGenerator& rng)\n   {\n   const BigInt& q = m_group.get_q();\n   BigInt i(msg, msg_len, q.bits());\n   while(i >= q)\n      i -= q;\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n   BOTAN_UNUSED(rng);\n   const BigInt k = generate_rfc6979_nonce(m_x, q, i, m_rfc6979_hash);\n#else\n   const BigInt k = BigInt::random_integer(rng, 1, q);\n#endif\n   BigInt s = inverse_mod(k, q);\n   const BigInt r = m_mod_q.reduce(m_group.power_g_p(k));\n   s = m_mod_q.multiply(s, mul_add(m_x, r, i));\n   if(r.is_zero() || s.is_zero())\n      throw Internal_Error(\"Computed zero r/s during DSA signature\");\n   return BigInt::encode_fixed_length_int_pair(r, s, q.bytes());\n   }", "target": 1}
{"code": "imapx_untagged_list (CamelIMAPXServer *is,\n                     GInputStream *input_stream,\n                     GCancellable *cancellable,\n                     GError **error)\n{\n\tCamelIMAPXListResponse *response;\n\tCamelIMAPXStore *imapx_store;\n\tconst gchar *mailbox_name;\n\tgchar separator;\n\tg_return_val_if_fail (CAMEL_IS_IMAPX_SERVER (is), FALSE);\n\tresponse = camel_imapx_list_response_new (\n\t\tCAMEL_IMAPX_INPUT_STREAM (input_stream), cancellable, error);\n\tif (response == NULL)\n\t\treturn FALSE;\n\tmailbox_name = camel_imapx_list_response_get_mailbox_name (response);\n\tseparator = camel_imapx_list_response_get_separator (response);\n\tif (camel_imapx_mailbox_is_inbox (mailbox_name))\n\t\tis->priv->inbox_separator = separator;\n\timapx_store = camel_imapx_server_ref_store (is);\n\tcamel_imapx_store_handle_list_response (imapx_store, is, response);\n\tg_clear_object (&imapx_store);\n\tg_clear_object (&response);\n\treturn TRUE;\n}", "target": 0}
{"code": "static Jsi_Value *jsi_treeFmtKey(Jsi_MapEntry* h, struct Jsi_MapOpts *opts, int flags)\n{\n    Jsi_TreeEntry* hPtr = (Jsi_TreeEntry*)h;\n    void *key = Jsi_TreeKeyGet(hPtr);\n    if (opts->keyType == JSI_KEYS_ONEWORD)\n        return Jsi_ValueNewNumber(opts->interp, (Jsi_Number)(intptr_t)key);\n    char nbuf[100];\n    snprintf(nbuf, sizeof(nbuf), \"%p\", key);\n    return Jsi_ValueNewStringDup(opts->interp, nbuf);\n}", "target": 1}
{"code": "main_get_appheader (xd3_stream *stream, main_file *ifile,\n\t\t    main_file *output, main_file *sfile)\n{\n  uint8_t *apphead;\n  usize_t appheadsz;\n  int ret;\n  if (! option_use_appheader) { return; }\n  ret = xd3_get_appheader (stream, & apphead, & appheadsz);\n  if (ret != 0) { return; }\n  if (appheadsz > 0)\n    {\n      char *start = (char*)apphead;\n      char *slash;\n      int   place = 0;\n      char *parsed[4];\n      memset (parsed, 0, sizeof (parsed));\n      while ((slash = strchr (start, '/')) != NULL)\n\t{\n\t  *slash = 0;\n\t  parsed[place++] = start;\n\t  start = slash + 1;\n\t}\n      parsed[place++] = start;\n      if (place == 2 || place == 4)\n\t{\n\t  main_get_appheader_params (output, parsed, 1, \"output\", ifile);\n\t}\n      if (place == 4)\n\t{\n\t  main_get_appheader_params (sfile, parsed+2, 0, \"source\", ifile);\n\t}\n    }\n  option_use_appheader = 0;\n  return;\n}", "target": 1}
{"code": "static void singlevar (LexState *ls, expdesc *var) {\n  TString *varname = str_checkname(ls);\n  FuncState *fs = ls->fs;\n  singlevaraux(fs, varname, var, 1);\n  if (var->k == VVOID) {  \n    expdesc key;\n    singlevaraux(fs, ls->envn, var, 1);  \n    lua_assert(var->k != VVOID);  \n    luaK_exp2anyregup(fs, var);  \n    codestring(&key, varname);  \n    luaK_indexed(fs, var, &key);  \n  }\n}", "target": 0}
{"code": "static int kvm_vcpu_initialized(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.target >= 0;\n}", "target": 0}
{"code": "Status ValidateNumThreads(int32_t num_threads) {\n  if (num_threads < 0) {\n    return errors::InvalidArgument(\"`num_threads` must be >= 0\");\n  }\n  if (num_threads >= kThreadLimit) {\n    return errors::InvalidArgument(\"`num_threads` must be < \", kThreadLimit);\n  }\n  return Status::OK();\n}", "target": 0}
{"code": "static void gen_vector_table16(TrueMotion1Context *s, const uint8_t *sel_vector_table)\n{\n    int len, i, j;\n    unsigned char delta_pair;\n    for (i = 0; i < 1024; i += 4)\n    {\n        len = *sel_vector_table++ / 2;\n        for (j = 0; j < len; j++)\n        {\n            delta_pair = *sel_vector_table++;\n            s->y_predictor_table[i+j] = 0xfffffffe &\n                make_ydt16_entry(delta_pair >> 4, delta_pair & 0xf, s->ydt);\n            s->c_predictor_table[i+j] = 0xfffffffe &\n                make_cdt16_entry(delta_pair >> 4, delta_pair & 0xf, s->cdt);\n        }\n        s->y_predictor_table[i+(j-1)] |= 1;\n        s->c_predictor_table[i+(j-1)] |= 1;\n    }\n}", "target": 0}
{"code": "HTTP_HANDLE HTTPAPI_CreateConnection(const char* hostName)\n{\n    HTTP_HANDLE_DATA* result;\n    if (g_HTTPAPIState != HTTPAPI_INITIALIZED)\n    {\n        LogError(\"g_HTTPAPIState not HTTPAPI_INITIALIZED\");\n        result = NULL;\n    }\n    else\n    {\n        result = (HTTP_HANDLE_DATA*)malloc(sizeof(HTTP_HANDLE_DATA));\n        if (result == NULL)\n        {\n            LogError(\"malloc returned NULL.\");\n        }\n        else\n        {\n            memset(result, 0, sizeof(*result));\n            wchar_t* hostNameTemp;\n            size_t hostNameTemp_size = MultiByteToWideChar(CP_ACP, 0, hostName, -1, NULL, 0);\n            if (hostNameTemp_size == 0)\n            {\n                LogError(\"MultiByteToWideChar failed\");\n                free(result);\n                result = NULL;\n            }\n            else\n            {\n                hostNameTemp = (wchar_t*)malloc(sizeof(wchar_t) * hostNameTemp_size);\n                if (hostNameTemp == NULL)\n                {\n                    LogError(\"malloc failed\");\n                    free(result);\n                    result = NULL;\n                }\n                else\n                {\n                    if (MultiByteToWideChar(CP_ACP, 0, hostName, -1, hostNameTemp, (int)hostNameTemp_size) == 0)\n                    {\n                        LogError(\"MultiByteToWideChar failed\");\n                        free(result);\n                        result = NULL;\n                    }\n                    else\n                    {\n                        result->ConnectionHandle = WinHttpConnect(\n                            g_SessionHandle,\n                            hostNameTemp,\n                            INTERNET_DEFAULT_HTTPS_PORT,\n                            0);\n                        if (result->ConnectionHandle == NULL)\n                        {\n                            LogErrorWinHTTPWithGetLastErrorAsString(\"WinHttpConnect returned NULL.\");\n                            free(result);\n                            result = NULL;\n                        }\n                        else\n                        {\n                            result->timeout = 60000;\n                        }\n                    }\n                    free(hostNameTemp);\n                }\n            }\n        }\n    }\n    return (HTTP_HANDLE)result;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& sorted_inputs_t = ctx->input(0);\n    const Tensor& values_t = ctx->input(1);\n    OP_REQUIRES(\n        ctx, sorted_inputs_t.shape().dims() >= 2,\n        errors::InvalidArgument(\"sorted input argument must be a matrix\"));\n    OP_REQUIRES(ctx, sorted_inputs_t.dim_size(0) == values_t.dim_size(0),\n                Status(error::INVALID_ARGUMENT,\n                       \"Leading dim_size of both tensors must match.\"));\n    OP_REQUIRES(ctx, values_t.NumElements() < std::numeric_limits<int>::max(),\n                Status(error::INVALID_ARGUMENT,\n                       \"values tensor size must less than INT_MAX\"));\n    Tensor* output_t;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, values_t.shape(), &output_t));\n    if (output_t->dtype() == DT_INT32) {\n      OP_REQUIRES(ctx,\n                  FastBoundsCheck(sorted_inputs_t.dim_size(1),\n                                  std::numeric_limits<int>::max()),\n                  errors::InvalidArgument(\"trailing dim_size must less than \"\n                                          \"INT_MAX for int32 output type, was \",\n                                          sorted_inputs_t.dim_size(1)));\n    }\n    auto output = output_t->template flat<OutType>();\n    const auto sorted_inputs = sorted_inputs_t.template flat<T>();\n    const auto values = values_t.template flat<T>();\n    if (sorted_inputs.size() == 0) {\n      functor::SetZeroFunctor<Device, OutType> set_zero;\n      set_zero(ctx->eigen_device<Device>(), output);\n      return;\n    }\n    OP_REQUIRES_OK(\n        ctx, functor::LowerBoundFunctor<Device, T, OutType>::Compute(\n                 ctx, sorted_inputs, values, sorted_inputs_t.dim_size(0),\n                 sorted_inputs_t.dim_size(1), values_t.dim_size(1), &output));\n  }", "target": 0}
{"code": "static void perform_renew(void)\n{\n\tbb_info_msg(\"Performing a DHCP renew\");\n\tswitch (state) {\n\tcase BOUND:\n\t\tchange_listen_mode(LISTEN_KERNEL);\n\tcase RENEWING:\n\tcase REBINDING:\n\t\tstate = RENEW_REQUESTED;\n\t\tbreak;\n\tcase RENEW_REQUESTED: \n\t\tudhcp_run_script(NULL, \"deconfig\");\n\tcase REQUESTING:\n\tcase RELEASED:\n\t\tchange_listen_mode(LISTEN_RAW);\n\t\tstate = INIT_SELECTING;\n\t\tbreak;\n\tcase INIT_SELECTING:\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "static void sctp_skb_set_owner_r_frag(struct sk_buff *skb, struct sock *sk)\n{\n\tstruct sk_buff *frag;\n\tif (!skb->data_len)\n\t\tgoto done;\n\tfor (frag = skb_shinfo(skb)->frag_list; frag; frag = frag->next)\n\t\tsctp_skb_set_owner_r_frag(frag, sk);\ndone:\n\tsctp_skb_set_owner_r(skb, sk);\n}", "target": 0}
{"code": "void GfxCalGrayColorSpace::getDefaultColor(GfxColor *color) const\n{\n    color->c[0] = 0;\n}", "target": 0}
{"code": "parseuid(const char *s, uid_t *uid)\n{\n\tstruct passwd *pw;\n\tconst char *errstr;\n\tif ((pw = getpwnam(s)) != NULL) {\n\t\t*uid = pw->pw_uid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*uid = strtonum(s, 0, UID_MAX, &errstr);\n\t#else\n\tsscanf(s, \"%d\", uid);\n\t#endif\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}", "target": 1}
{"code": "void IndexedDBDatabase::RequestComplete(ConnectionRequest* request) {\n  DCHECK_EQ(request, active_request_.get());\n  active_request_.reset();\n  if (!pending_requests_.empty())\n    ProcessRequestQueue();\n}", "target": 0}
{"code": "int __anon_vma_prepare(struct vm_area_struct *vma)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct anon_vma *anon_vma, *allocated;\n\tstruct anon_vma_chain *avc;\n\tmight_sleep();\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_enomem;\n\tanon_vma = find_mergeable_anon_vma(vma);\n\tallocated = NULL;\n\tif (!anon_vma) {\n\t\tanon_vma = anon_vma_alloc();\n\t\tif (unlikely(!anon_vma))\n\t\t\tgoto out_enomem_free_avc;\n\t\tallocated = anon_vma;\n\t}\n\tanon_vma_lock_write(anon_vma);\n\tspin_lock(&mm->page_table_lock);\n\tif (likely(!vma->anon_vma)) {\n\t\tvma->anon_vma = anon_vma;\n\t\tanon_vma_chain_link(vma, avc, anon_vma);\n\t\tanon_vma->degree++;\n\t\tallocated = NULL;\n\t\tavc = NULL;\n\t}\n\tspin_unlock(&mm->page_table_lock);\n\tanon_vma_unlock_write(anon_vma);\n\tif (unlikely(allocated))\n\t\tput_anon_vma(allocated);\n\tif (unlikely(avc))\n\t\tanon_vma_chain_free(avc);\n\treturn 0;\n out_enomem_free_avc:\n\tanon_vma_chain_free(avc);\n out_enomem:\n\treturn -ENOMEM;\n}", "target": 1}
{"code": "bool ArcMemory::Unload()\n{\n  if (!Loaded)\n    return false;\n  Loaded=false;\n  return true;\n}", "target": 0}
{"code": "void HeaderMapImpl::insertByKey(HeaderString&& key, HeaderString&& value) {\n  EntryCb cb = ConstSingleton<StaticLookupTable>::get().find(key.getStringView());\n  if (cb) {\n    key.clear();\n    StaticLookupResponse ref_lookup_response = cb(*this);\n    if (*ref_lookup_response.entry_ == nullptr) {\n      maybeCreateInline(ref_lookup_response.entry_, *ref_lookup_response.key_, std::move(value));\n    } else {\n      appendToHeader((*ref_lookup_response.entry_)->value(), value.getStringView());\n      value.clear();\n    }\n  } else {\n    std::list<HeaderEntryImpl>::iterator i = headers_.insert(std::move(key), std::move(value));\n    i->entry_ = i;\n  }\n}", "target": 1}
{"code": "void UpstreamRequest::onPerTryTimeout() {\n  if (per_try_idle_timeout_) {\n    per_try_idle_timeout_.reset();\n  }\n  if (!parent_.downstreamResponseStarted()) {\n    ENVOY_STREAM_LOG(debug, \"upstream per try timeout\", *parent_.callbacks());\n    stream_info_.setResponseFlag(StreamInfo::CoreResponseFlag::UpstreamRequestTimeout);\n    parent_.onPerTryTimeout(*this);\n  } else {\n    ENVOY_STREAM_LOG(debug,\n                     \"ignored upstream per try timeout due to already started downstream response\",\n                     *parent_.callbacks());\n  }\n}", "target": 0}
{"code": "qedi_dbg_notice(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t\tconst char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\tchar nfunc[32];\n\tmemset(nfunc, 0, sizeof(nfunc));\n\tmemcpy(nfunc, func, sizeof(nfunc) - 1);\n\tva_start(va, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\tif (!(qedi_dbg_log & QEDI_LOG_NOTICE))\n\t\tgoto ret;\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_notice(\"[%s]:[%s:%d]:%d: %pV\",\n\t\t\t  dev_name(&qedi->pdev->dev), nfunc, line,\n\t\t\t  qedi->host_no, &vaf);\n\telse\n\t\tpr_notice(\"[0000:00:00.0]:[%s:%d]: %pV\", nfunc, line, &vaf);\nret:\n\tva_end(va);\n}", "target": 1}
{"code": "decode_definite_short_string(CBORDecoderObject *self, Py_ssize_t length)\n{\n    PyObject *bytes_obj = fp_read_object(self, length);\n    if (!bytes_obj)\n        return NULL;\n    const char *bytes = PyBytes_AS_STRING(bytes_obj);\n    PyObject *ret = PyUnicode_FromStringAndSize(bytes, length);\n    Py_DECREF(bytes_obj);\n    if (ret && string_namespace_add(self, ret, length) == -1) {\n        Py_DECREF(ret);\n        return NULL;\n    }\n    return ret;\n}", "target": 0}
{"code": "static int crypto_shash_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_hash rhash;\n\tstruct shash_alg *salg = __crypto_shash_alg(alg);\n\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"shash\");\n\trhash.blocksize = alg->cra_blocksize;\n\trhash.digestsize = salg->digestsize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_HASH,\n\t\t    sizeof(struct crypto_report_hash), &rhash))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "static GF_Err av1dmx_parse_flush_sample(GF_Filter *filter, GF_AV1DmxCtx *ctx)\n{\n\tu32 pck_size;\n\tGF_FilterPacket *pck;\n\tu8 *output;\n\tif (!ctx->opid)\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\tgf_bs_get_content_no_truncate(ctx->state.bs, &ctx->state.frame_obus, &pck_size, &ctx->state.frame_obus_alloc);\n\tif (!pck_size) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1Dmx] no frame OBU, skipping OBU\\n\"));\n\t\treturn GF_OK;\n\t}\n\tpck = gf_filter_pck_new_alloc(ctx->opid, pck_size, &output);\n\tif (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, pck);\n\tgf_filter_pck_set_cts(pck, ctx->cts);\n\tgf_filter_pck_set_sap(pck, ctx->state.frame_state.key_frame ? GF_FILTER_SAP_1 : 0);\n\tmemcpy(output, ctx->state.frame_obus, pck_size);\n\tif (ctx->deps) {\n\t\tu8 flags = 0;\n\t\tflags = ( ctx->state.frame_state.key_frame) ? 2 : 1;\n\t\tflags <<= 2;\n\t \tflags |= ctx->state.frame_state.refresh_frame_flags ? 1 : 2;\n\t\tflags <<= 2;\n\t \tgf_filter_pck_set_dependency_flags(pck, flags);\n\t}\n\tgf_filter_pck_send(pck);\n\tav1dmx_update_cts(ctx);\n\tgf_av1_reset_state(&ctx->state, GF_FALSE);\n\treturn GF_OK;\n}", "target": 0}
{"code": "valid_weeknum_sub(int argc, VALUE *argv, VALUE klass, int need_jd)\n{\n    VALUE nth, y;\n    int w, d, f, ry, rw, rd;\n    double sg;\n    y = argv[0];\n    w = NUM2INT(argv[1]);\n    d = NUM2INT(argv[2]);\n    f = NUM2INT(argv[3]);\n    sg = NUM2DBL(argv[4]);\n    valid_sg(sg);\n    {\n\tint rjd, ns;\n\tVALUE rjd2;\n\tif (!valid_weeknum_p(y, w, d, f, sg,\n\t\t\t     &nth, &ry,\n\t\t\t     &rw, &rd, &rjd,\n\t\t\t     &ns))\n\t    return Qnil;\n\tif (!need_jd)\n\t    return INT2FIX(0); \n\tencode_jd(nth, rjd, &rjd2);\n\treturn rjd2;\n    }\n}", "target": 0}
{"code": "static void sunkbd_enable(struct sunkbd *sunkbd, bool enable)\n{\n\tserio_pause_rx(sunkbd->serio);\n\tsunkbd->enabled = enable;\n\tserio_continue_rx(sunkbd->serio);\n\tif (!enable) {\n\t\twake_up_interruptible(&sunkbd->wait);\n\t\tcancel_work_sync(&sunkbd->tq);\n\t}\n}", "target": 0}
{"code": "xfs_da3_fixhashpath(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\txfs_dahash_t\t\tlasthash=0;\n\tint\t\t\tlevel;\n\tint\t\t\tcount;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\ttrace_xfs_da_fixhashpath(state->args);\n\tlevel = path->active-1;\n\tblk = &path->blk[ level ];\n\tswitch (blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tlasthash = xfs_attr_leaf_lasthash(blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tlasthash = xfs_dir2_leafn_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\t\tlasthash = xfs_da3_node_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\t}\n\tfor (blk--, level--; level >= 0; blk--, level--) {\n\t\tstruct xfs_da3_icnode_hdr nodehdr;\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\tif (be32_to_cpu(btree->hashval) == lasthash)\n\t\t\tbreak;\n\t\tblk->hashval = lasthash;\n\t\tbtree[blk->index].hashval = cpu_to_be32(lasthash);\n\t\txfs_trans_log_buf(state->args->trans, blk->bp,\n\t\t\t\t  XFS_DA_LOGRANGE(node, &btree[blk->index],\n\t\t\t\t\t\t  sizeof(*btree)));\n\t\tlasthash = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t}\n}", "target": 1}
{"code": "GetSamplingFrequencyIndex(unsigned int sampling_frequency)\n{\n    switch (sampling_frequency) {\n        case 96000: return 0;\n        case 88200: return 1;\n        case 64000: return 2;\n        case 48000: return 3;\n        case 44100: return 4;\n        case 32000: return 5;\n        case 24000: return 6;\n        case 22050: return 7;\n        case 16000: return 8;\n        case 12000: return 9;\n        case 11025: return 10;\n        case 8000:  return 11;\n        case 7350:  return 12;\n        default:    return 0;\n    }\n}", "target": 0}
{"code": "SQLiteDatabase::SQLiteDatabase()\n    : db_(nullptr),\n      page_size_(-1),\n      transaction_in_progress_(false),\n      opening_thread_(0),\n      open_error_(SQLITE_ERROR),\n      open_error_message_(),\n      last_changes_count_(0) {\n}", "target": 0}
{"code": "static void uv__process_child_init(const uv_process_options_t* options,\n                                   int stdio_count,\n                                   int (*pipes)[2],\n                                   int error_fd) {\n  int close_fd;\n  int use_fd;\n  int fd;\n  if (options->flags & UV_PROCESS_DETACHED)\n    setsid();\n  for (fd = 0; fd < stdio_count; fd++) {\n    close_fd = pipes[fd][0];\n    use_fd = pipes[fd][1];\n    if (use_fd < 0) {\n      if (fd >= 3)\n        continue;\n      else {\n        use_fd = open(\"/dev/null\", fd == 0 ? O_RDONLY : O_RDWR);\n        close_fd = use_fd;\n        if (use_fd == -1) {\n        uv__write_int(error_fd, -errno);\n          perror(\"failed to open stdio\");\n          _exit(127);\n        }\n      }\n    }\n    if (fd == use_fd)\n      uv__cloexec(use_fd, 0);\n    else\n      dup2(use_fd, fd);\n    if (fd <= 2)\n      uv__nonblock(fd, 0);\n    if (close_fd != -1)\n      uv__close(close_fd);\n  }\n  for (fd = 0; fd < stdio_count; fd++) {\n    use_fd = pipes[fd][1];\n    if (use_fd >= 0 && fd != use_fd)\n      close(use_fd);\n  }\n  if (options->cwd != NULL && chdir(options->cwd)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"chdir()\");\n    _exit(127);\n  }\n  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {\n    SAVE_ERRNO(setgroups(0, NULL));\n  }\n  if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"setgid()\");\n    _exit(127);\n  }\n  if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"setuid()\");\n    _exit(127);\n  }\n  if (options->env != NULL) {\n    environ = options->env;\n  }\n  execvp(options->file, options->args);\n  uv__write_int(error_fd, -errno);\n  perror(\"execvp()\");\n  _exit(127);\n}", "target": 0}
{"code": "static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)\n{\n    VirtQueueElement elem;\n    VirtQueue *vq;\n    vq = vser->c_ivq;\n    if (!virtio_queue_ready(vq)) {\n        return 0;\n    }\n    if (!virtqueue_pop(vq, &elem)) {\n        return 0;\n    }\n    memcpy(elem.in_sg[0].iov_base, buf, len);\n    virtqueue_push(vq, &elem, len);\n    virtio_notify(VIRTIO_DEVICE(vser), vq);\n    return len;\n}", "target": 1}
{"code": "static void start_auth_request(PgSocket *client, const char *username)\n{\n\tint res;\n\tPktBuf *buf;\n\tclient->auth_user = client->db->auth_user;\n\tclient->pool = get_pool(client->db, client->db->auth_user);\n\tif (!find_server(client)) {\n\t\tclient->wait_for_user_conn = true;\n\t\treturn;\n\t}\n\tslog_noise(client, \"Doing auth_conn query\");\n\tclient->wait_for_user_conn = false;\n\tclient->wait_for_user = true;\n\tif (!sbuf_pause(&client->sbuf)) {\n\t\trelease_server(client->link);\n\t\tdisconnect_client(client, true, \"pause failed\");\n\t\treturn;\n\t}\n\tclient->link->ready = 0;\n\tres = 0;\n\tbuf = pktbuf_dynamic(512);\n\tif (buf) {\n\t\tpktbuf_write_ExtQuery(buf, cf_auth_query, 1, username);\n\t\tres = pktbuf_send_immediate(buf, client->link);\n\t\tpktbuf_free(buf);\n\t}\n\tif (!res)\n\t\tdisconnect_server(client->link, false, \"unable to send login query\");\n}", "target": 1}
{"code": "void HTMLMediaElement::setPlaybackRate(double rate,\n                                       ExceptionState& exception_state) {\n  BLINK_MEDIA_LOG << \"setPlaybackRate(\" << (void*)this << \", \" << rate << \")\";\n  if (GetLoadType() == WebMediaPlayer::kLoadTypeMediaStream)\n    return;\n  if (rate != 0.0 && (rate < kMinRate || rate > kMaxRate)) {\n    UseCounter::Count(GetDocument(),\n                      WebFeature::kHTMLMediaElementMediaPlaybackRateOutOfRange);\n    exception_state.ThrowDOMException(\n        DOMExceptionCode::kNotSupportedError,\n        \"The provided playback rate (\" + String::Number(rate) +\n            \") is not in the \" + \"supported playback range.\");\n    return;\n  }\n  if (playback_rate_ != rate) {\n    playback_rate_ = rate;\n    ScheduleEvent(event_type_names::kRatechange);\n  }\n  UpdatePlaybackRate();\n}", "target": 0}
{"code": "check_sudo (GError **error)\n{\n  const char *sudo_command_env = g_getenv (\"SUDO_COMMAND\");\n  g_auto(GStrv) split_command = NULL;\n  if (!sudo_command_env)\n    return TRUE;\n  split_command = g_strsplit (sudo_command_env, \" \", 2);\n  if (g_str_has_suffix (split_command[0], \"flatpak\"))\n    return flatpak_fail_error (error, FLATPAK_ERROR, _(\"\\\"flatpak run\\\" is not intended to be run as `sudo flatpak run`, use `sudo -i` or `su -l` instead and invoke \\\"flatpak run\\\" from inside the new shell\"));\n  return TRUE;\n}", "target": 0}
{"code": "static void encode_compound_hdr(struct xdr_stream *xdr,\n\t\t\t\tstruct rpc_rqst *req,\n\t\t\t\tstruct compound_hdr *hdr)\n{\n\t__be32 *p;\n\tstruct rpc_auth *auth = req->rq_cred->cr_auth;\n\thdr->replen = RPC_REPHDRSIZE + auth->au_rslack + 3 + hdr->taglen;\n\tBUG_ON(hdr->taglen > NFS4_MAXTAGLEN);\n\tencode_string(xdr, hdr->taglen, hdr->tag);\n\tp = reserve_space(xdr, 8);\n\t*p++ = cpu_to_be32(hdr->minorversion);\n\thdr->nops_p = p;\n\t*p = cpu_to_be32(hdr->nops);\n}", "target": 0}
{"code": "void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick)\n{\n  const char *quote = \"`\\\"\\\\\";\n  if (!quote_backtick)\n    quote++;\n  char *pt = dest;\n  const char *s = src;\n  *pt++ = '\"';\n  dlen -= 3;\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      if (dlen < 2)\n        break;\n      dlen -= 2;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = '\\0';\n}", "target": 0}
{"code": "xmlAddRef(xmlValidCtxtPtr ctxt, xmlDocPtr doc, const xmlChar *value,\n    xmlAttrPtr attr) {\n    xmlRefPtr ret;\n    xmlRefTablePtr table;\n    xmlListPtr ref_list;\n    if (doc == NULL) {\n        return(NULL);\n    }\n    if (value == NULL) {\n        return(NULL);\n    }\n    if (attr == NULL) {\n        return(NULL);\n    }\n    table = (xmlRefTablePtr) doc->refs;\n    if (table == NULL) {\n        doc->refs = table = xmlHashCreateDict(0, doc->dict);\n    }\n    if (table == NULL) {\n\txmlVErrMemory(ctxt,\n            \"xmlAddRef: Table creation failed!\\n\");\n        return(NULL);\n    }\n    ret = (xmlRefPtr) xmlMalloc(sizeof(xmlRef));\n    if (ret == NULL) {\n\txmlVErrMemory(ctxt, \"malloc failed\");\n        return(NULL);\n    }\n    ret->value = xmlStrdup(value);\n    if ((ctxt != NULL) && (ctxt->vstateNr != 0)) {\n\tret->name = xmlStrdup(attr->name);\n\tret->attr = NULL;\n    } else {\n\tret->name = NULL;\n\tret->attr = attr;\n    }\n    ret->lineno = xmlGetLineNo(attr->parent);\n    if (NULL == (ref_list = xmlHashLookup(table, value))) {\n        if (NULL == (ref_list = xmlListCreate(xmlFreeRef, xmlDummyCompare))) {\n\t    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t    \"xmlAddRef: Reference list creation failed!\\n\",\n\t\t    NULL);\n\t    goto failed;\n        }\n        if (xmlHashAddEntry(table, value, ref_list) < 0) {\n            xmlListDelete(ref_list);\n\t    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t    \"xmlAddRef: Reference list insertion failed!\\n\",\n\t\t    NULL);\n\t    goto failed;\n        }\n    }\n    if (xmlListAppend(ref_list, ret) != 0) {\n\txmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t    \"xmlAddRef: Reference list insertion failed!\\n\",\n\t\t    NULL);\n        goto failed;\n    }\n    return(ret);\nfailed:\n    if (ret != NULL) {\n        if (ret->value != NULL)\n\t    xmlFree((char *)ret->value);\n        if (ret->name != NULL)\n\t    xmlFree((char *)ret->name);\n        xmlFree(ret);\n    }\n    return(NULL);\n}", "target": 1}
{"code": "Status QuantizeV2Shape(InferenceContext* c) {\n  int axis = -1;\n  Status s = c->GetAttr(\"axis\", &axis);\n  if (!s.ok() && s.code() != error::NOT_FOUND) {\n    return s;\n  }\n  if (axis < -1) {\n    return errors::InvalidArgument(\"axis should be at least -1, got \", axis);\n  }\n  const int minmax_rank = (axis == -1) ? 0 : 1;\n  TF_RETURN_IF_ERROR(shape_inference::UnchangedShape(c));\n  ShapeHandle minmax;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(1), minmax_rank, &minmax));\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(2), minmax_rank, &minmax));\n  if (axis != -1) {\n    ShapeHandle input;\n    TF_RETURN_IF_ERROR(c->WithRankAtLeast(c->input(0), axis + 1, &input));\n    DimensionHandle depth;\n    TF_RETURN_IF_ERROR(\n        c->Merge(c->Dim(minmax, 0), c->Dim(input, axis), &depth));\n  }\n  c->set_output(1, minmax);\n  c->set_output(2, minmax);\n  return Status::OK();\n}", "target": 0}
{"code": "void AverageEvalQuantizedUint8(TfLiteContext* context, TfLiteNode* node,\n                               TfLitePoolParams* params, OpData* data,\n                               const TfLiteTensor* input,\n                               TfLiteTensor* output) {\n  int32_t activation_min;\n  int32_t activation_max;\n  (void)CalculateActivationRangeQuantized(context, params->activation, output,\n                                          &activation_min, &activation_max);\n#define TF_LITE_AVERAGE_POOL(type)                                         \\\n  tflite::PoolParams op_params;                                            \\\n  op_params.stride_height = params->stride_height;                         \\\n  op_params.stride_width = params->stride_width;                           \\\n  op_params.filter_height = params->filter_height;                         \\\n  op_params.filter_width = params->filter_width;                           \\\n  op_params.padding_values.height = data->padding.height;                  \\\n  op_params.padding_values.width = data->padding.width;                    \\\n  op_params.quantized_activation_min = activation_min;                     \\\n  op_params.quantized_activation_max = activation_max;                     \\\n  type::AveragePool(op_params, GetTensorShape(input),                      \\\n                    GetTensorData<uint8_t>(input), GetTensorShape(output), \\\n                    GetTensorData<uint8_t>(output))\n  if (kernel_type == kReference) {\n    TF_LITE_AVERAGE_POOL(reference_ops);\n  } else {\n    TF_LITE_AVERAGE_POOL(optimized_ops);\n  }\n#undef TF_LITE_AVERAGE_POOL\n}", "target": 1}
{"code": "setup_secureChannel(void) {\n    TestingPolicy(&dummyPolicy, dummyCertificate, &fCalled, &keySizes);\n    UA_SecureChannel_init(&testChannel, &UA_ConnectionConfig_default);\n    UA_SecureChannel_setSecurityPolicy(&testChannel, &dummyPolicy, &dummyCertificate);\n    testingConnection = createDummyConnection(65535, &sentData);\n    UA_Connection_attachSecureChannel(&testingConnection, &testChannel);\n    testChannel.connection = &testingConnection;\n    testChannel.state = UA_SECURECHANNELSTATE_OPEN;\n}", "target": 1}
{"code": "static void process_COM (const uchar * Data, int length)\n{\n    int ch;\n    char Comment[MAX_COMMENT_SIZE+1];\n    int nch;\n    int a;\n    nch = 0;\n    if (length > MAX_COMMENT_SIZE) length = MAX_COMMENT_SIZE; \n    for (a=2;a<length;a++){\n        ch = Data[a];\n        if (ch == '\\r' && Data[a+1] == '\\n') continue; \n        if (ch >= 32 || ch == '\\n' || ch == '\\t'){\n            Comment[nch++] = (char)ch;\n        }else{\n            Comment[nch++] = '?';\n        }\n    }\n    Comment[nch] = '\\0'; \n    if (ShowTags){\n        printf(\"COM marker comment: %s\\n\",Comment);\n    }\n    strcpy(ImageInfo.Comments,Comment);\n}", "target": 1}
{"code": "static void huffman_decode_row(x3f_info_t *I, x3f_directory_entry_t *DE,\n                               int bits, int row, int offset, int *minimum)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n  x3f_huffman_t *HUF = ID->huffman;\n  int16_t c[3] = {(int16_t)offset, (int16_t)offset, (int16_t)offset};\n  int col;\n  bit_state_t BS;\n  if (HUF->row_offsets.element[row] > ID->data_size - 1)\n\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  set_bit_state(&BS, (uint8_t *)ID->data + HUF->row_offsets.element[row]);\n  for (col = 0; col < ID->columns; col++)\n  {\n    int color;\n    for (color = 0; color < 3; color++)\n    {\n      uint16_t c_fix;\n      c[color] += get_huffman_diff(&BS, &HUF->tree);\n      if (c[color] < 0)\n      {\n        c_fix = 0;\n        if (c[color] < *minimum)\n          *minimum = c[color];\n      }\n      else\n      {\n        c_fix = c[color];\n      }\n      switch (ID->type_format)\n      {\n      case X3F_IMAGE_RAW_HUFFMAN_X530:\n      case X3F_IMAGE_RAW_HUFFMAN_10BIT:\n        HUF->x3rgb16.data[3 * (row * ID->columns + col) + color] =\n            (uint16_t)c_fix;\n        break;\n      case X3F_IMAGE_THUMB_HUFFMAN:\n        HUF->rgb8.data[3 * (row * ID->columns + col) + color] = (uint8_t)c_fix;\n        break;\n      default:\n        throw LIBRAW_EXCEPTION_IO_CORRUPT;\n      }\n    }\n  }\n}", "target": 0}
{"code": "int delete_sdp_line( struct sip_msg * msg, char * s, struct sdp_stream_cell *stream)\n{\n\tchar * start,*end;\n\tif( !s )\n\t\treturn 1;\n\tstart = s;\n\tend  = s;\n\twhile(*start != '\\n' && start > stream->body.s)\n\t\tstart--;\n\tstart++;\n\twhile(*end != '\\n' && end < (stream->body.s+stream->body.len) )\n\t\tend++;\n\tif ( *end == '\\n')\n\t\tend++;\n\tif( del_lump(msg, start - msg->buf, end - start,0) == NULL )\n\t{\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static grub_err_t read_foo (struct grub_disk *disk, grub_disk_addr_t sector, grub_size_t size, char *buf) {\n\tif (disk != NULL) {\n\t\tconst int blocksize = 512; \n\t\tint ret;\n\t\tRIOBind *iob = disk->data;\n\t\tif (bio) iob = bio;\n\t\tret = iob->read_at (iob->io, delta+(blocksize*sector),\n\t\t\t(ut8*)buf, size*blocksize);\n\t\tif (ret == -1)\n\t\t\treturn 1;\n\t} else eprintf (\"oops. no disk\\n\");\n\treturn 0; \n}", "target": 1}
{"code": "void RenderWidgetHostImpl::SetView(RenderWidgetHostViewBase* view) {\n  if (view)\n    view_ = view->GetWeakPtr();\n  else\n    view_.reset();\n  if (view_ && renderer_initialized_) {\n    Send(new ViewMsg_SetSurfaceIdNamespace(routing_id_,\n                                           view_->GetSurfaceIdNamespace()));\n  }\n  synthetic_gesture_controller_.reset();\n}", "target": 0}
{"code": "int netdev_printk(const char *level, const struct net_device *dev,\n\t\t  const char *format, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint r;\n\tva_start(args, format);\n\tvaf.fmt = format;\n\tvaf.va = &args;\n\tr = __netdev_printk(level, dev, &vaf);\n\tva_end(args);\n\treturn r;\n}", "target": 0}
{"code": "static void coroutine_fn v9fs_symlink(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    V9fsString name;\n    V9fsString symname;\n    V9fsFidState *dfidp;\n    V9fsQID qid;\n    struct stat stbuf;\n    int32_t dfid;\n    int err = 0;\n    gid_t gid;\n    size_t offset = 7;\n    v9fs_string_init(&name);\n    v9fs_string_init(&symname);\n    err = pdu_unmarshal(pdu, offset, \"dssd\", &dfid, &name, &symname, &gid);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_symlink(pdu->tag, pdu->id, dfid, name.data, symname.data, gid);\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n    dfidp = get_fid(pdu, dfid);\n    if (dfidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    err = v9fs_co_symlink(pdu, dfidp, &name, symname.data, gid, &stbuf);\n    if (err < 0) {\n        goto out;\n    }\n    err = stat_to_qid(pdu, &stbuf, &qid);\n    if (err < 0) {\n        goto out;\n    }\n    err =  pdu_marshal(pdu, offset, \"Q\", &qid);\n    if (err < 0) {\n        goto out;\n    }\n    err += offset;\n    trace_v9fs_symlink_return(pdu->tag, pdu->id,\n                              qid.type, qid.version, qid.path);\nout:\n    put_fid(pdu, dfidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n    v9fs_string_free(&symname);\n}", "target": 0}
{"code": "static handler_t wstunnel_create_env(gw_handler_ctx *gwhctx) {\n    handler_ctx *hctx = (handler_ctx *)gwhctx;\n    request_st * const r = hctx->gw.r;\n    handler_t rc;\n    if (0 == r->reqbody_length || r->http_version > HTTP_VERSION_1_1) {\n        http_response_upgrade_read_body_unknown(r);\n        chunkqueue_append_chunkqueue(&r->reqbody_queue, &r->read_queue);\n    }\n    rc = mod_wstunnel_handshake_create_response(hctx);\n    if (rc != HANDLER_GO_ON) return rc;\n    r->http_status = (r->http_version > HTTP_VERSION_1_1)\n      ? 200  \n      : 101; \n    r->resp_body_started = 1;\n    hctx->ping_ts = log_monotonic_secs;\n    gw_set_transparent(&hctx->gw);\n    return HANDLER_GO_ON;\n}", "target": 0}
{"code": "static void hog_exit(void)\n{\n\tif (suspend_supported)\n\t\tsuspend_exit();\n\tbtd_profile_unregister(&hog_profile);\n}", "target": 0}
{"code": "hybiWsFrameComplete(ws_ctx_t *wsctx)\n{\n  return wsctx != NULL && hybiRemaining(wsctx) == 0;\n}", "target": 0}
{"code": "left_is_superset(DTCollation *left, DTCollation *right)\n{\n  if (left->collation->state & MY_CS_UNICODE &&\n      (left->derivation < right->derivation ||\n       (left->derivation == right->derivation &&\n        (!(right->collation->state & MY_CS_UNICODE) ||\n         (left->collation->state & MY_CS_UNICODE_SUPPLEMENT &&\n          !(right->collation->state & MY_CS_UNICODE_SUPPLEMENT) &&\n          left->collation->mbmaxlen > right->collation->mbmaxlen &&\n          left->collation->mbminlen == right->collation->mbminlen)))))\n    return TRUE;\n  if (right->repertoire == MY_REPERTOIRE_ASCII &&\n      (left->derivation < right->derivation ||\n       (left->derivation == right->derivation &&\n        !(left->repertoire == MY_REPERTOIRE_ASCII))))\n    return TRUE;\n  return FALSE;\n}", "target": 0}
{"code": "http_splitheader(struct http *hp, int req)\n{\n\tchar *p, *q, **hh;\n\tint n;\n\tchar buf[20];\n\tCHECK_OBJ_NOTNULL(hp, HTTP_MAGIC);\n\tif (req) {\n\t\tmemset(hp->req, 0, sizeof hp->req);\n\t\thh = hp->req;\n\t} else {\n\t\tmemset(hp->resp, 0, sizeof hp->resp);\n\t\thh = hp->resp;\n\t}\n\tn = 0;\n\tp = hp->rxbuf;\n\twhile (vct_islws(*p))\n\t\tp++;\n\thh[n++] = p;\n\twhile (!vct_islws(*p))\n\t\tp++;\n\tassert(!vct_iscrlf(*p));\n\t*p++ = '\\0';\n\twhile (vct_issp(*p))\t\t\n\t\tp++;\n\tassert(!vct_iscrlf(*p));\n\thh[n++] = p;\n\twhile (!vct_islws(*p))\n\t\tp++;\n\tif (vct_iscrlf(*p)) {\n\t\thh[n++] = NULL;\n\t\tq = p;\n\t\tp += vct_skipcrlf(p);\n\t\t*q = '\\0';\n\t} else {\n\t\t*p++ = '\\0';\n\t\twhile (vct_issp(*p))\t\t\n\t\t\tp++;\n\t\thh[n++] = p;\n\t\twhile (!vct_iscrlf(*p))\n\t\t\tp++;\n\t\tq = p;\n\t\tp += vct_skipcrlf(p);\n\t\t*q = '\\0';\n\t}\n\tassert(n == 3);\n\twhile (*p != '\\0') {\n\t\tassert(n < MAX_HDR);\n\t\tif (vct_iscrlf(*p))\n\t\t\tbreak;\n\t\thh[n++] = p++;\n\t\twhile (*p != '\\0' && !vct_iscrlf(*p))\n\t\t\tp++;\n\t\tq = p;\n\t\tp += vct_skipcrlf(p);\n\t\t*q = '\\0';\n\t}\n\tp += vct_skipcrlf(p);\n\tassert(*p == '\\0');\n\tfor (n = 0; n < 3 || hh[n] != NULL; n++) {\n\t\tsprintf(buf, \"http[%2d] \", n);\n\t\tvtc_dump(hp->vl, 4, buf, hh[n], -1);\n\t}\n}", "target": 1}
{"code": "TEST_P(SslIntegrationTest, LogPeerIpSanUnsupportedIpVersion) {\n  useListenerAccessLog(\"%DOWNSTREAM_PEER_IP_SAN%\");\n  config_helper_.addFilter(\"name: sni-to-header-filter\");\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection(ClientSslTransportOptions().setSni(\"host.com\"));\n  };\n  initialize();\n  codec_client_ = makeHttpConnection(\n      makeSslClientConnection(ClientSslTransportOptions().setSni(\"www.host.com\")));\n  auto disabler = (version_ == Network::Address::IpVersion::v4)\n                      ? Network::Address::Ipv6Instance::forceProtocolUnsupportedForTest\n                      : Network::Address::Ipv4Instance::forceProtocolUnsupportedForTest;\n  Cleanup cleaner(disabler(true));\n  Http::TestRequestHeaderMapImpl request_headers{\n      {\":method\", \"GET\"}, {\":path\", \"/\"}, {\":scheme\", \"https\"}, {\":authority\", \"host.com\"}};\n  auto response = codec_client_->makeHeaderOnlyRequest(request_headers);\n  waitForNextUpstreamRequest();\n  EXPECT_EQ(\"www.host.com\", upstream_request_->headers()\n                                .get(Http::LowerCaseString(\"x-envoy-client-sni\"))[0]\n                                ->value()\n                                .getStringView());\n  Http::TestResponseHeaderMapImpl response_headers{{\":status\", \"200\"}};\n  upstream_request_->encodeHeaders(response_headers, true);\n  RELEASE_ASSERT(response->waitForEndStream(), \"unexpected timeout\");\n  codec_client_->close();\n  checkStats();\n  auto result = waitForAccessLog(listener_access_log_name_);\n  if (version_ == Network::Address::IpVersion::v4) {\n    EXPECT_EQ(result, \"1.2.3.4\");\n  } else {\n    EXPECT_EQ(result, \"0:1:2:3::4\");\n  }\n}", "target": 0}
{"code": "mlx5_fw_fatal_reporter_dump(struct devlink_health_reporter *reporter,\n\t\t\t    struct devlink_fmsg *fmsg, void *priv_ctx)\n{\n\tstruct mlx5_core_dev *dev = devlink_health_reporter_priv(reporter);\n\tu32 crdump_size = dev->priv.health.crdump_size;\n\tu32 *cr_data;\n\tu32 data_size;\n\tu32 offset;\n\tint err;\n\tif (!mlx5_core_is_pf(dev))\n\t\treturn -EPERM;\n\tcr_data = kvmalloc(crdump_size, GFP_KERNEL);\n\tif (!cr_data)\n\t\treturn -ENOMEM;\n\terr = mlx5_crdump_collect(dev, cr_data);\n\tif (err)\n\t\treturn err;\n\tif (priv_ctx) {\n\t\tstruct mlx5_fw_reporter_ctx *fw_reporter_ctx = priv_ctx;\n\t\terr = mlx5_fw_reporter_ctx_pairs_put(fmsg, fw_reporter_ctx);\n\t\tif (err)\n\t\t\tgoto free_data;\n\t}\n\terr = devlink_fmsg_arr_pair_nest_start(fmsg, \"crdump_data\");\n\tif (err)\n\t\tgoto free_data;\n\tfor (offset = 0; offset < crdump_size; offset += data_size) {\n\t\tif (crdump_size - offset < MLX5_CR_DUMP_CHUNK_SIZE)\n\t\t\tdata_size = crdump_size - offset;\n\t\telse\n\t\t\tdata_size = MLX5_CR_DUMP_CHUNK_SIZE;\n\t\terr = devlink_fmsg_binary_put(fmsg, (char *)cr_data + offset,\n\t\t\t\t\t      data_size);\n\t\tif (err)\n\t\t\tgoto free_data;\n\t}\n\terr = devlink_fmsg_arr_pair_nest_end(fmsg);\nfree_data:\n\tkvfree(cr_data);\n\treturn err;\n}", "target": 1}
{"code": "WebProcessProxy::WebProcessProxy(PassRefPtr<WebContext> context)\n    : ChildProcessProxy(this)\n    , m_responsivenessTimer(this)\n    , m_context(context)\n    , m_mayHaveUniversalFileReadSandboxExtension(false)\n#if ENABLE(CUSTOM_PROTOCOLS)\n    , m_customProtocolManagerProxy(this)\n#endif\n#if PLATFORM(MAC)\n    , m_processSuppressionEnabled(false)\n#endif\n{\n    connect();\n}", "target": 0}
{"code": "R_API char *r_str_escape_sh(const char *buf) {\n\tr_return_val_if_fail (buf, NULL);\n\tchar *new_buf = malloc (1 + strlen (buf) * 2);\n\tif (!new_buf) {\n\t\treturn NULL;\n\t}\n\tconst char *p = buf;\n\tchar *q = new_buf;\n\twhile (*p) {\n\t\tswitch (*p) {\n#if __UNIX__\n\t\tcase '$':\n\t\tcase '`':\n#endif\n\t\tcase '\\\\':\n\t\tcase '\"':\n\t\t\t*q++ = '\\\\';\n\t\tdefault:\n\t\t\t*q++ = *p++;\n\t\t\tbreak;\n\t\t}\n\t}\n\t*q = '\\0';\n\treturn new_buf;\n}", "target": 0}
{"code": "sshsk_open(const char *path)\n{\n\tstruct sshsk_provider *ret = NULL;\n\tuint32_t version;\n\tif (path == NULL || *path == '\\0') {\n\t\terror(\"No FIDO SecurityKeyProvider specified\");\n\t\treturn NULL;\n\t}\n\tif ((ret = calloc(1, sizeof(*ret))) == NULL) {\n\t\terror_f(\"calloc failed\");\n\t\treturn NULL;\n\t}\n\tif ((ret->path = strdup(path)) == NULL) {\n\t\terror_f(\"strdup failed\");\n\t\tgoto fail;\n\t}\n\tif (strcasecmp(ret->path, \"internal\") == 0) {\n\t\tret->sk_enroll = ssh_sk_enroll;\n\t\tret->sk_sign = ssh_sk_sign;\n\t\tret->sk_load_resident_keys = ssh_sk_load_resident_keys;\n\t\treturn ret;\n\t}\n\tif ((ret->dlhandle = dlopen(path, RTLD_NOW)) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlopen failed: %s\", path, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_api_version = dlsym(ret->dlhandle,\n\t    \"sk_api_version\")) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlsym(sk_api_version) failed: %s\",\n\t\t    path, dlerror());\n\t\tgoto fail;\n\t}\n\tversion = ret->sk_api_version();\n\tdebug_f(\"provider %s implements version 0x%08lx\", ret->path,\n\t    (u_long)version);\n\tif ((version & SSH_SK_VERSION_MAJOR_MASK) != SSH_SK_VERSION_MAJOR) {\n\t\terror(\"Provider \\\"%s\\\" implements unsupported \"\n\t\t    \"version 0x%08lx (supported: 0x%08lx)\",\n\t\t    path, (u_long)version, (u_long)SSH_SK_VERSION_MAJOR);\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_enroll = dlsym(ret->dlhandle, \"sk_enroll\")) == NULL) {\n\t\terror(\"Provider %s dlsym(sk_enroll) failed: %s\",\n\t\t    path, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_sign = dlsym(ret->dlhandle, \"sk_sign\")) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlsym(sk_sign) failed: %s\",\n\t\t    path, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_load_resident_keys = dlsym(ret->dlhandle,\n\t    \"sk_load_resident_keys\")) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlsym(sk_load_resident_keys) \"\n\t\t    \"failed: %s\", path, dlerror());\n\t\tgoto fail;\n\t}\n\treturn ret;\nfail:\n\tsshsk_free(ret);\n\treturn NULL;\n}", "target": 1}
{"code": "static bool freelist_state_initialize(union freelist_init_state *state,\n\t\t\t\tstruct kmem_cache *cachep,\n\t\t\t\tunsigned int count)\n{\n\tbool ret;\n\tunsigned int rand;\n\trand = get_random_int();\n\tif (!cachep->random_seq) {\n\t\tprandom_seed_state(&state->rnd_state, rand);\n\t\tret = false;\n\t} else {\n\t\tstate->list = cachep->random_seq;\n\t\tstate->count = count;\n\t\tstate->pos = 0;\n\t\tstate->rand = rand;\n\t\tret = true;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "PHP_FUNCTION(pg_result_seek)\n{\n\tzval *result;\n\tzend_long row;\n\tpgsql_result_handle *pg_result;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rl\", &result, &row) == FAILURE) {\n\t\treturn;\n\t}\n\tZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, result, -1, \"PostgreSQL result\", le_result);\n\tif (row < 0 || row >= PQntuples(pg_result->result)) {\n\t\tRETURN_FALSE;\n\t}\n\tpg_result->row = (int)row;\n\tRETURN_TRUE;\n}", "target": 0}
{"code": "_client_list_free_node(t_client *client)\n{\n\tchar *msg;\n\tchar *cidinfo;\n\tif (client->cid) {\n\t\tif (strlen(client->cid) > 0) {\n\t\t\tmsg = safe_calloc(SMALL_BUF);\n\t\t\tcidinfo = safe_calloc(MID_BUF);\n\t\t\tsafe_snprintf(cidinfo, MID_BUF, \"cid=\\\"%s\\\"\", client->cid);\n\t\t\twrite_client_info(msg, SMALL_BUF, \"rmcid\", client->cid, cidinfo);\n\t\t\tfree(msg);\n\t\t\tfree(cidinfo);\n\t\t}\n\t}\n\tfree(client->token);\n\tfree(client->hid);\n\tfree(client->custom);\n\tfree(client->client_type);\n\tfree(client->cid);\n\tif (strcmp(client->cpi_query, \"\") == 0) {\n\t\tfree(client->cpi_query);\n\t}\n\tfree(client);\n}", "target": 0}
{"code": "static void nfs_set_open_stateid_locked(struct nfs4_state *state, nfs4_stateid *stateid, int open_flags)\n{\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0)\n\t\tmemcpy(state->stateid.data, stateid->data, sizeof(state->stateid.data));\n\tmemcpy(state->open_stateid.data, stateid->data, sizeof(state->open_stateid.data));\n\tswitch (open_flags) {\n\t\tcase FMODE_READ:\n\t\t\tset_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tset_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tset_bit(NFS_O_RDWR_STATE, &state->flags);\n\t}\n}", "target": 1}
{"code": "grub_ext4_find_leaf (struct grub_ext2_data *data, char *buf,\n                     struct grub_ext4_extent_header *ext_block,\n                     grub_uint32_t fileblock)\n{\n  struct grub_ext4_extent_idx *index;\n  while (1)\n    {\n      int i;\n      grub_disk_addr_t block;\n      index = (struct grub_ext4_extent_idx *) (ext_block + 1);\n      if (grub_le_to_cpu16(ext_block->magic) != EXT4_EXT_MAGIC)\n        return 0;\n      if (ext_block->depth == 0)\n        return ext_block;\n      for (i = 0; i < grub_le_to_cpu16 (ext_block->entries); i++)\n        {\n          if (fileblock < grub_le_to_cpu32(index[i].block))\n            break;\n        }\n      if (--i < 0)\n        return 0;\n      block = grub_le_to_cpu16 (index[i].leaf_hi);\n      block = (block << 32) + grub_le_to_cpu32 (index[i].leaf);\n      if (grub_disk_read (data->disk,\n                          block << LOG2_EXT2_BLOCK_SIZE (data),\n                          0, EXT2_BLOCK_SIZE(data), buf))\n        return 0;\n      ext_block = (struct grub_ext4_extent_header *) buf;\n    }\n}", "target": 1}
{"code": "char* oidc_util_javascript_escape(apr_pool_t *pool, const char *s) {\n    const char *cp;\n    char *output;\n    size_t outputlen;\n    int i;\n    if (s == NULL) {\n        return NULL;\n    }\n    outputlen = 0;\n    for (cp = s; *cp; cp++) {\n        switch (*cp) {\n        case '\\'':\n        case '\"':\n        case '\\\\':\n        case '/':\n        case 0x0D:\n        case 0x0A:\n            outputlen += 2;\n            break;\n        case '<':\n        case '>':\n            outputlen += 4;\n            break;\n        default:\n            outputlen += 1;\n            break;\n        }\n    }\n    i = 0;\n    output = apr_palloc(pool, outputlen + 1);\n    for (cp = s; *cp; cp++) {\n        switch (*cp) {\n        case '\\'':\n            (void)strcpy(&output[i], \"\\\\'\");\n            i += 2;\n            break;\n        case '\"':\n            (void)strcpy(&output[i], \"\\\\\\\"\");\n            i += 2;\n            break;\n        case '\\\\':\n            (void)strcpy(&output[i], \"\\\\\\\\\");\n            i += 2;\n            break;\n        case '/':\n            (void)strcpy(&output[i], \"\\\\/\");\n            i += 2;\n            break;\n        case 0x0D:\n            (void)strcpy(&output[i], \"\\\\r\");\n            i += 2;\n            break;\n        case 0x0A:\n            (void)strcpy(&output[i], \"\\\\n\");\n            i += 2;\n            break;\n        case '<':\n            (void)strcpy(&output[i], \"\\\\x3c\");\n            i += 4;\n            break;\n        case '>':\n            (void)strcpy(&output[i], \"\\\\x3e\");\n            i += 4;\n            break;\n        default:\n            output[i] = *cp;\n            i += 1;\n            break;\n        }\n    }\n    output[i] = '\\0';\n    return output;\n}", "target": 0}
{"code": "void send( char* str ) {\n    fprintf(outfile, \"%s\",str);\n}", "target": 0}
{"code": "static int em_fxrstor(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct fxregs_state fx_state;\n\tint rc;\n\trc = check_fxsr(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = segmented_read(ctxt, ctxt->memop.addr.mem, &fx_state, 512);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tif (fx_state.mxcsr >> 16)\n\t\treturn emulate_gp(ctxt, 0);\n\tctxt->ops->get_fpu(ctxt);\n\tif (ctxt->mode < X86EMUL_MODE_PROT64)\n\t\trc = fxrstor_fixup(ctxt, &fx_state);\n\tif (rc == X86EMUL_CONTINUE)\n\t\trc = asm_safe(\"fxrstor %[fx]\", : [fx] \"m\"(fx_state));\n\tctxt->ops->put_fpu(ctxt);\n\treturn rc;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* c) override {\n    const TensorList* input_list = nullptr;\n    OP_REQUIRES_OK(c, GetInputList(c, 0, &input_list));\n    OP_REQUIRES(c, TensorShapeUtils::IsScalar(c->input(1).shape()),\n                errors::InvalidArgument(\"size must be a scalar\"));\n    int32_t size = c->input(1).scalar<int32>()();\n    OP_REQUIRES(\n        c, size >= 0,\n        errors::InvalidArgument(\n            \"TensorListSlice expects size to be non-negative. Got: \", size));\n    std::unique_ptr<Tensor> maybe_result =\n        c->forward_input(0, 0, DT_VARIANT, TensorShape{},\n                         c->input_memory_type(0), AllocatorAttributes());\n    if (maybe_result != nullptr) {\n      TensorList* out = maybe_result->scalar<Variant>()().get<TensorList>();\n      if (out->RefCountIsOne()) {\n        out->tensors().resize(size, Tensor(DT_INVALID));\n        c->set_output(0, *maybe_result);\n        return;\n      }\n    }\n    Tensor* result;\n    AllocatorAttributes attr;\n    attr.set_on_host(true);\n    OP_REQUIRES_OK(c, c->allocate_output(0, TensorShape{}, &result, attr));\n    TensorList output_list;\n    output_list.element_shape = input_list->element_shape;\n    output_list.element_dtype = input_list->element_dtype;\n    output_list.max_num_elements = input_list->max_num_elements;\n    if (size > input_list->tensors().size()) {\n      output_list.tensors().insert(output_list.tensors().begin(),\n                                   input_list->tensors().begin(),\n                                   input_list->tensors().end());\n      output_list.tensors().resize(size, Tensor(DT_INVALID));\n    } else {\n      output_list.tensors().insert(output_list.tensors().begin(),\n                                   input_list->tensors().begin(),\n                                   input_list->tensors().begin() + size);\n    }\n    result->scalar<Variant>()() = std::move(output_list);\n  }", "target": 0}
{"code": "__u32 secure_tcpv6_sequence_number(__be32 *saddr, __be32 *daddr,\n\t\t\t\t   __be16 sport, __be16 dport)\n{\n\t__u32 seq;\n\t__u32 hash[12];\n\tstruct keydata *keyptr = get_keyptr();\n\tmemcpy(hash, saddr, 16);\n\thash[4] = ((__force u16)sport << 16) + (__force u16)dport;\n\tmemcpy(&hash[5], keyptr->secret, sizeof(__u32) * 7);\n\tseq = twothirdsMD4Transform((const __u32 *)daddr, hash) & HASH_MASK;\n\tseq += keyptr->count;\n\tseq += ktime_to_ns(ktime_get_real());\n\treturn seq;\n}", "target": 1}
{"code": "bool WebContents::SendIPCMessageToFrame(bool internal,\n                                        int32_t frame_id,\n                                        const std::string& channel,\n                                        v8::Local<v8::Value> args) {\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  blink::CloneableMessage message;\n  if (!gin::ConvertFromV8(isolate, args, &message)) {\n    isolate->ThrowException(v8::Exception::Error(\n        gin::StringToV8(isolate, \"Failed to serialize arguments\")));\n    return false;\n  }\n  auto frames = web_contents()->GetAllFrames();\n  auto iter = std::find_if(frames.begin(), frames.end(), [frame_id](auto* f) {\n    return f->GetRoutingID() == frame_id;\n  });\n  if (iter == frames.end())\n    return false;\n  if (!(*iter)->IsRenderFrameLive())\n    return false;\n  mojo::AssociatedRemote<mojom::ElectronRenderer> electron_renderer;\n  (*iter)->GetRemoteAssociatedInterfaces()->GetInterface(&electron_renderer);\n  electron_renderer->Message(internal, channel, std::move(message),\n                             0 );\n  return true;\n}", "target": 1}
{"code": "juniper_atm2_print(netdissect_options *ndo,\n                   const struct pcap_pkthdr *h, register const u_char *p)\n{\n        int llc_hdrlen;\n        struct juniper_l2info_t l2info;\n        l2info.pictype = DLT_JUNIPER_ATM2;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        if (l2info.cookie[7] & ATM2_PKT_TYPE_MASK) { \n            oam_print(ndo, p, l2info.length, ATM_OAM_NOHEC);\n            return l2info.header_len;\n        }\n        ND_TCHECK2(p[0], 3);\n        if (EXTRACT_24BITS(p) == 0xfefe03 || \n            EXTRACT_24BITS(p) == 0xaaaa03) { \n            llc_hdrlen = llc_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);\n            if (llc_hdrlen > 0)\n                return l2info.header_len;\n        }\n        if (l2info.direction != JUNIPER_BPF_PKT_IN && \n            (EXTRACT_32BITS(l2info.cookie) & ATM2_GAP_COUNT_MASK)) {\n            ether_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);\n            return l2info.header_len;\n        }\n        if (p[0] == 0x03) { \n            isoclns_print(ndo, p + 1, l2info.length - 1);\n            return l2info.header_len;\n        }\n        if(juniper_ppp_heuristic_guess(ndo, p, l2info.length) != 0) \n            return l2info.header_len;\n        if (ip_heuristic_guess(ndo, p, l2info.length) != 0) \n            return l2info.header_len;\n\treturn l2info.header_len;\ntrunc:\n\tND_PRINT((ndo, \"[|juniper_atm2]\"));\n\treturn l2info.header_len;\n}", "target": 0}
{"code": "static inline long div_ll_X_l_rem(long long divs, long div, long *rem)\n{\n\tlong dum2;\n\tasm(\"divl %2\":\"=a\"(dum2), \"=d\"(*rem)\n\t    : \"rm\"(div), \"A\"(divs));\n\treturn dum2;\n}", "target": 1}
{"code": "static int key_verify(pam_handle_t *pamh, int flags, PKCS11_KEY *authkey)\n{\n\tint ok = 0;\n\tunsigned char challenge[30];\n\tunsigned char signature[256];\n\tunsigned int siglen = sizeof signature;\n\tconst EVP_MD *md = EVP_sha1();\n\tEVP_MD_CTX *md_ctx = EVP_MD_CTX_new();\n\tEVP_PKEY *privkey = PKCS11_get_private_key(authkey);\n\tEVP_PKEY *pubkey = PKCS11_get_public_key(authkey);\n\tif (1 != randomize(pamh, challenge, sizeof challenge)) {\n\t\tgoto err;\n\t}\n\tif (NULL == pubkey || NULL == privkey || NULL == md_ctx || NULL == md\n\t\t\t|| !EVP_SignInit(md_ctx, md)\n\t\t\t|| !EVP_SignUpdate(md_ctx, challenge, sizeof challenge)\n\t\t\t|| !EVP_SignFinal(md_ctx, signature, &siglen, privkey)\n\t\t\t|| !EVP_MD_CTX_reset(md_ctx)\n\t\t\t|| !EVP_VerifyInit(md_ctx, md)\n\t\t\t|| !EVP_VerifyUpdate(md_ctx, challenge, sizeof challenge)\n\t\t\t|| 1 != EVP_VerifyFinal(md_ctx, signature, siglen, pubkey)) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"Error verifying key: %s\\n\",\n\t\t\t\tERR_reason_error_string(ERR_get_error()));\n\t\tprompt(flags, pamh, PAM_ERROR_MSG, NULL, _(\"Error verifying key\"));\n\t\tgoto err;\n\t}\n\tok = 1;\nerr:\n\tif (NULL != pubkey)\n\t\tEVP_PKEY_free(pubkey);\n\tif (NULL != privkey)\n\t\tEVP_PKEY_free(privkey);\n\tif (NULL != md_ctx) {\n\t\tEVP_MD_CTX_free(md_ctx);\n\t}\n\treturn ok;\n}", "target": 1}
{"code": "struct clock_source *dce100_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\tif (!clk_src)\n\t\treturn NULL;\n\tif (dce110_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 0}
{"code": "static inline void nft_reg_store64(u32 *dreg, u64 val)\n{\n\tput_unaligned(val, (u64 *)dreg);\n}", "target": 1}
{"code": "static int em_sysexit(struct x86_emulate_ctxt *ctxt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tint usermode;\n\tu16 cs_sel = 0, ss_sel = 0;\n\tif (ctxt->mode == X86EMUL_MODE_REAL ||\n\t    ctxt->mode == X86EMUL_MODE_VM86)\n\t\treturn emulate_gp(ctxt, 0);\n\tsetup_syscalls_segments(ctxt, &cs, &ss);\n\tif ((ctxt->rex_prefix & 0x8) != 0x0)\n\t\tusermode = X86EMUL_MODE_PROT64;\n\telse\n\t\tusermode = X86EMUL_MODE_PROT32;\n\tcs.dpl = 3;\n\tss.dpl = 3;\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_CS, &msr_data);\n\tswitch (usermode) {\n\tcase X86EMUL_MODE_PROT32:\n\t\tcs_sel = (u16)(msr_data + 16);\n\t\tif ((msr_data & 0xfffc) == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tss_sel = (u16)(msr_data + 24);\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT64:\n\t\tcs_sel = (u16)(msr_data + 32);\n\t\tif (msr_data == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tss_sel = cs_sel + 8;\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t\tbreak;\n\t}\n\tcs_sel |= SELECTOR_RPL_MASK;\n\tss_sel |= SELECTOR_RPL_MASK;\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n\tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n\tctxt->_eip = reg_read(ctxt, VCPU_REGS_RDX);\n\t*reg_write(ctxt, VCPU_REGS_RSP) = reg_read(ctxt, VCPU_REGS_RCX);\n\treturn X86EMUL_CONTINUE;\n}", "target": 1}
{"code": "struct sctp_chunk *sctp_assoc_lookup_asconf_ack(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\t__be32 serial)\n{\n\tstruct sctp_chunk *ack;\n\tlist_for_each_entry(ack, &asoc->asconf_ack_list, transmitted_list) {\n\t\tif (sctp_chunk_pending(ack))\n\t\t\tcontinue;\n\t\tif (ack->subh.addip_hdr->serial == serial) {\n\t\t\tsctp_chunk_hold(ack);\n\t\t\treturn ack;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "void handle_get_plugin_schema(nng_aio *aio)\n{\n    size_t      len                        = 0;\n    char *      schema_path                = NULL;\n    char        param[NEU_PLUGIN_NAME_LEN] = { 0 };\n    const char *schema_name                = param;\n    NEU_VALIDATE_JWT(aio);\n    int rv = neu_http_get_param_str(aio, \"schema_name\", param, sizeof(param));\n    if (-2 == rv) {\n        rv = neu_http_get_param_str(aio, \"plugin_name\", param, sizeof(param));\n        schema_name = plugin_name_to_schema_name(param);\n    }\n    if (rv < 0) {\n        neu_http_bad_request(aio, \"{\\\"error\\\": 1002}\");\n        return;\n    }\n    if (0 > neu_asprintf(&schema_path, \"%s/schema/%s.json\", g_plugin_dir,\n                         schema_name)) {\n        NEU_JSON_RESPONSE_ERROR(NEU_ERR_EINTERNAL, {\n            neu_http_response(aio, error_code.error, result_error);\n        });\n        return;\n    }\n    char *buf = NULL;\n    buf = file_string_read(&len, schema_path);\n    if (NULL == buf) {\n        free(schema_path);\n        if (0 > neu_asprintf(&schema_path, \"%s/custom/schema/%s.json\",\n                             g_plugin_dir, schema_name)) {\n            NEU_JSON_RESPONSE_ERROR(NEU_ERR_EINTERNAL, {\n                neu_http_response(aio, error_code.error, result_error);\n            });\n            return;\n        }\n        buf = file_string_read(&len, schema_path);\n    }\n    if (NULL == buf) {\n        free(schema_path);\n        if (0 > neu_asprintf(&schema_path, \"%s/system/schema/%s.json\",\n                             g_plugin_dir, schema_name)) {\n            NEU_JSON_RESPONSE_ERROR(NEU_ERR_EINTERNAL, {\n                neu_http_response(aio, error_code.error, result_error);\n            });\n            return;\n        }\n        buf = file_string_read(&len, schema_path);\n    }\n    if (NULL == buf) {\n        nlog_info(\"open %s error: %d\", schema_path, errno);\n        neu_http_not_found(aio, \"{\\\"status\\\": \\\"error\\\"}\");\n        free(schema_path);\n        return;\n    }\n    neu_http_ok(aio, buf);\n    free(buf);\n    free(schema_path);\n}", "target": 1}
{"code": "inline TfLiteTensor* GetMutableInput(const TfLiteContext* context,\n                                     const TfLiteNode* node, int index) {\n  const int tensor_index = ValidateTensorIndexing(\n      context, index, node->inputs->size, node->inputs->data);\n  if (tensor_index < 0) {\n    return nullptr;\n  }\n  return GetTensorAtIndex(context, tensor_index);\n}", "target": 0}
{"code": "static struct dentry *proc_task_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *error = ERR_PTR(-ENOENT);\n\tstruct inode *inode;\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\tinode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;\n\tinode->i_op = &proc_tid_base_inode_operations;\n\tinode->i_fop = &proc_tid_base_operations;\n\tinode->i_flags|=S_IMMUTABLE;\n\tinode->i_nlink = 4;\n#ifdef CONFIG_SECURITY\n\tinode->i_nlink += 1;\n#endif\n\tdentry->d_op = &pid_dentry_operations;\n\td_add(dentry, inode);\n\tif (pid_revalidate(dentry, NULL))\n\t\terror = NULL;\nout:\n\treturn error;\n}", "target": 0}
{"code": "bool Archive::Open(const wchar *Name,uint Mode)\n{\n#ifdef USE_QOPEN\n  QOpen.Unload();\n#endif\n#ifdef USE_ARCMEM\n  if (Cmd->ArcInMem)\n  {\n    wcsncpyz(FileName,Name,ASIZE(FileName));\n    ArcMem.Load(Cmd->ArcMemData,Cmd->ArcMemSize);\n    Cmd->SetArcInMem(NULL,0); \n    return true;\n  }\n#endif\n  return File::Open(Name,Mode);\n}", "target": 0}
{"code": "NavigationControllerImpl& WebContentsImpl::GetControllerForRenderManager() {\n  return GetController();\n}", "target": 0}
{"code": "pixBlockconv(PIX     *pix,\n             l_int32  wc,\n             l_int32  hc)\n{\nl_int32  w, h, d;\nPIX     *pixs, *pixd, *pixr, *pixrc, *pixg, *pixgc, *pixb, *pixbc;\n    PROCNAME(\"pixBlockconv\");\n    if (!pix)\n        return (PIX *)ERROR_PTR(\"pix not defined\", procName, NULL);\n    if (wc < 0) wc = 0;\n    if (hc < 0) hc = 0;\n    pixGetDimensions(pix, &w, &h, &d);\n    if (w < 2 * wc + 1 || h < 2 * hc + 1) {\n        wc = L_MIN(wc, (w - 1) / 2);\n        hc = L_MIN(hc, (h - 1) / 2);\n        L_WARNING(\"kernel too large; reducing!\\n\", procName);\n        L_INFO(\"wc = %d, hc = %d\\n\", procName, wc, hc);\n    }\n    if (wc == 0 && hc == 0)   \n        return pixCopy(NULL, pix);\n    if ((d == 2 || d == 4 || d == 8) && pixGetColormap(pix)) {\n        L_WARNING(\"pix has colormap; removing\\n\", procName);\n        pixs = pixRemoveColormap(pix, REMOVE_CMAP_BASED_ON_SRC);\n        d = pixGetDepth(pixs);\n    } else {\n        pixs = pixClone(pix);\n    }\n    if (d != 8 && d != 32) {\n        pixDestroy(&pixs);\n        return (PIX *)ERROR_PTR(\"depth not 8 or 32 bpp\", procName, NULL);\n    }\n    if (d == 8) {\n        pixd = pixBlockconvGray(pixs, NULL, wc, hc);\n    } else { \n        pixr = pixGetRGBComponent(pixs, COLOR_RED);\n        pixrc = pixBlockconvGray(pixr, NULL, wc, hc);\n        pixDestroy(&pixr);\n        pixg = pixGetRGBComponent(pixs, COLOR_GREEN);\n        pixgc = pixBlockconvGray(pixg, NULL, wc, hc);\n        pixDestroy(&pixg);\n        pixb = pixGetRGBComponent(pixs, COLOR_BLUE);\n        pixbc = pixBlockconvGray(pixb, NULL, wc, hc);\n        pixDestroy(&pixb);\n        pixd = pixCreateRGBImage(pixrc, pixgc, pixbc);\n        pixDestroy(&pixrc);\n        pixDestroy(&pixgc);\n        pixDestroy(&pixbc);\n    }\n    pixDestroy(&pixs);\n    return pixd;\n}", "target": 1}
{"code": "AP4_VisualSampleEntry::ReadFields(AP4_ByteStream& stream)\n{\n    AP4_Result result = AP4_SampleEntry::ReadFields(stream);\n    if (result < 0) return result;\n    stream.ReadUI16(m_Predefined1);\n    stream.ReadUI16(m_Reserved2);\n    stream.Read(m_Predefined2, sizeof(m_Predefined2));\n    stream.ReadUI16(m_Width);\n    stream.ReadUI16(m_Height);\n    stream.ReadUI32(m_HorizResolution);\n    stream.ReadUI32(m_VertResolution);\n    stream.ReadUI32(m_Reserved3);\n    stream.ReadUI16(m_FrameCount);\n    char compressor_name[33];\n    compressor_name[32] = 0;\n    stream.Read(compressor_name, 32);\n    int name_length = compressor_name[0];\n    if (name_length < 32) {\n        compressor_name[name_length+1] = 0; \n        m_CompressorName = &compressor_name[1];\n    }\n    stream.ReadUI16(m_Depth);\n    stream.ReadUI16(m_Predefined3);\n    return AP4_SUCCESS;\n}", "target": 1}
{"code": "static Jsi_RC jsi_ArrayForeachCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) \n{\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) \n        return Jsi_LogError(\"expected array object\");\n    Jsi_Obj *obj;\n    int curlen;\n    uint i;\n    Jsi_Value *func, *vpargs;\n    func = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!Jsi_ValueIsFunction(interp, func)) \n        return Jsi_LogError(\"expected function\");\n    Jsi_Value *sthis = Jsi_ValueArrayIndex(interp, args, 1);\n    Jsi_Value *nthis = NULL;\n    if (!sthis)\n        sthis = nthis = Jsi_ValueNew1(interp);\n    obj = _this->d.obj;\n    curlen = Jsi_ObjGetLength(interp, obj);    \n    if (curlen < 0) {\n        Jsi_ObjSetLength(interp, obj, 0);\n    }\n    Jsi_ObjListifyArray(interp, obj);\n    Jsi_RC rc = JSI_OK;\n    Jsi_Value *vobjs[3];\n    Jsi_Func *fptr = func->d.obj->d.fobj->func;\n    int maa = (fptr->argnames?fptr->argnames->argCnt:0);\n    if (maa>3)\n        maa = 3;\n    for (i = 0; i < obj->arrCnt && rc == JSI_OK; i++) {\n        if (!obj->arr[i]) continue;\n        vobjs[0] = obj->arr[i];\n        vobjs[1] = (maa>1?Jsi_ValueNewNumber(interp, i):NULL);\n        vobjs[2] = _this;\n        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vobjs, maa, 0));\n        Jsi_IncrRefCount(interp, vpargs);\n        rc = Jsi_FunctionInvoke(interp, func, vpargs, ret, sthis);\n        Jsi_DecrRefCount(interp, vpargs);\n    }\n    if (nthis)\n        Jsi_DecrRefCount(interp, nthis);\n    return rc;\n}", "target": 1}
{"code": "void XfccIntegrationTest::initialize() {\n  config_helper_.addConfigModifier(\n      [&](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n              hcm) -> void {\n        hcm.set_forward_client_cert_details(fcc_);\n        hcm.mutable_set_current_client_cert_details()->CopyFrom(sccd_);\n      });\n  config_helper_.addConfigModifier([&](envoy::config::bootstrap::v3::Bootstrap& bootstrap) -> void {\n    auto transport_socket =\n        bootstrap.mutable_static_resources()->mutable_clusters(0)->mutable_transport_socket();\n    envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext context;\n    auto* validation_context = context.mutable_common_tls_context()->mutable_validation_context();\n    validation_context->mutable_trusted_ca()->set_filename(\n        TestEnvironment::runfilesPath(\"test/config/integration/certs/upstreamcacert.pem\"));\n    validation_context->add_match_subject_alt_names()->set_suffix(\"lyft.com\");\n    transport_socket->set_name(\"envoy.transport_sockets.tls\");\n    transport_socket->mutable_typed_config()->PackFrom(context);\n  });\n  if (tls_) {\n    config_helper_.addSslConfig();\n  }\n  context_manager_ =\n      std::make_unique<Extensions::TransportSockets::Tls::ContextManagerImpl>(timeSystem());\n  client_tls_ssl_ctx_ = createClientSslContext(false);\n  client_mtls_ssl_ctx_ = createClientSslContext(true);\n  HttpIntegrationTest::initialize();\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, CantUseHashedIndexToProvideSortWithIndexablePred) {\n    addIndex(BSON(\"x\"\n                  << \"hashed\"));\n    runQuerySortProj(BSON(\"x\" << BSON(\"$in\" << BSON_ARRAY(0 << 1))), BSON(\"x\" << 1), BSONObj());\n    ASSERT_EQUALS(getNumSolutions(), 2U);\n    assertSolutionExists(\n        \"{sort: {pattern: {x: 1}, limit: 0, node: {sortKeyGen: {node: \"\n        \"{fetch: {node: \"\n        \"{ixscan: {pattern: {x: 'hashed'}}}}}}}}}\");\n    assertSolutionExists(\n        \"{sort: {pattern: {x: 1}, limit: 0, node: {sortKeyGen: {node:\"\n        \"{cscan: {dir: 1, filter: {x: {$in: [0, 1]}}}}}}}}\");\n}", "target": 0}
{"code": "static int sctp_v6_xmit(struct sk_buff *skb, struct sctp_transport *transport)\n{\n\tstruct sock *sk = skb->sk;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct flowi6 fl6;\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_proto = sk->sk_protocol;\n\tfl6.daddr = transport->ipaddr.v6.sin6_addr;\n\tfl6.saddr = transport->saddr.v6.sin6_addr;\n\tfl6.flowlabel = np->flow_label;\n\tIP6_ECN_flow_xmit(sk, fl6.flowlabel);\n\tif (ipv6_addr_type(&fl6.saddr) & IPV6_ADDR_LINKLOCAL)\n\t\tfl6.flowi6_oif = transport->saddr.v6.sin6_scope_id;\n\telse\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\tif (np->opt && np->opt->srcrt) {\n\t\tstruct rt0_hdr *rt0 = (struct rt0_hdr *) np->opt->srcrt;\n\t\tfl6.daddr = *rt0->addr;\n\t}\n\tpr_debug(\"%s: skb:%p, len:%d, src:%pI6 dst:%pI6\\n\", __func__, skb,\n\t\t skb->len, &fl6.saddr, &fl6.daddr);\n\tSCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);\n\tif (!(transport->param_flags & SPP_PMTUD_ENABLE))\n\t\tskb->local_df = 1;\n\treturn ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);\n}", "target": 1}
{"code": "update_request_allow_commands (UpdateRequest *request, gboolean allowCommands)\n{\n\trequest->allowCommands = allowCommands;\n}", "target": 0}
{"code": "static av_cold void uninit(AVFilterContext *ctx)\n{\n    ColorCorrectContext *s = ctx->priv;\n    av_freep(&s->analyzeret);\n    av_freep(&s->uhistogram);\n    av_freep(&s->vhistogram);\n}", "target": 0}
{"code": "int infra_ip_ratelimit_inc(struct infra_cache* infra,\n\tstruct sockaddr_storage* addr, socklen_t addrlen, time_t timenow,\n\tint has_cookie, int backoff, struct sldns_buffer* buffer)\n{\n\tint max;\n\tstruct lruhash_entry* entry;\n\tif(!infra_ip_ratelimit) {\n\t\treturn 1;\n\t}\n\tentry = infra_find_ip_ratedata(infra, addr, addrlen, 1);\n\tif(entry) {\n\t\tint premax = infra_rate_max(entry->data, timenow, backoff);\n\t\tint* cur = infra_rate_give_second(entry->data, timenow);\n\t\t(*cur)++;\n\t\tmax = infra_rate_max(entry->data, timenow, backoff);\n\t\tlock_rw_unlock(&entry->lock);\n\t\treturn check_ip_ratelimit(addr, addrlen, buffer, premax, max,\n\t\t\thas_cookie);\n\t}\n\tinfra_ip_create_ratedata(infra, addr, addrlen, timenow);\n\treturn 1;\n}", "target": 1}
{"code": "bool Monitor::ms_verify_authorizer(Connection *con, int peer_type,\n\t\t\t\t   int protocol, bufferlist& authorizer_data,\n\t\t\t\t   bufferlist& authorizer_reply,\n\t\t\t\t   bool& isvalid, CryptoKey& session_key)\n{\n  dout(10) << \"ms_verify_authorizer \" << con->get_peer_addr()\n\t   << \" \" << ceph_entity_type_name(peer_type)\n\t   << \" protocol \" << protocol << dendl;\n  if (is_shutdown())\n    return false;\n  if (peer_type == CEPH_ENTITY_TYPE_MON &&\n      auth_cluster_required.is_supported_auth(CEPH_AUTH_CEPHX)) {\n    isvalid = false;\n    if (protocol == CEPH_AUTH_CEPHX) {\n      bufferlist::iterator iter = authorizer_data.begin();\n      CephXServiceTicketInfo auth_ticket_info;\n      if (authorizer_data.length()) {\n\tbool ret = cephx_verify_authorizer(g_ceph_context, &keyring, iter,\n\t\t\t\t\t  auth_ticket_info, authorizer_reply);\n\tif (ret) {\n\t  session_key = auth_ticket_info.session_key;\n\t  isvalid = true;\n\t} else {\n\t  dout(0) << \"ms_verify_authorizer bad authorizer from mon \" << con->get_peer_addr() << dendl;\n        }\n      }\n    } else {\n      dout(0) << \"ms_verify_authorizer cephx enabled, but no authorizer (required for mon)\" << dendl;\n    }\n  } else {\n    isvalid = true;\n  }\n  return true;\n}", "target": 1}
{"code": "static int add_array_entry(const char* loc_name, zval* hash_arr, char* key_name TSRMLS_DC)\n{\n\tchar*   key_value \t= NULL;\n\tchar*   cur_key_name\t= NULL;\n\tchar*   token        \t= NULL;\n\tchar*   last_ptr  \t= NULL;\n\tint\tresult\t\t= 0;\n\tint \tcur_result  \t= 0;\n\tint \tcnt  \t\t= 0;\n\tif( strcmp(key_name , LOC_PRIVATE_TAG)==0 ){\n\t\tkey_value = get_private_subtags( loc_name );\n\t\tresult = 1;\n\t} else {\n\t\tkey_value = get_icu_value_internal( loc_name , key_name , &result,1 );\n\t}\n\tif( (strcmp(key_name , LOC_PRIVATE_TAG)==0) || \n\t\t( strcmp(key_name , LOC_VARIANT_TAG)==0) ){\n\t\tif( result > 0 && key_value){\n\t\t\ttoken = php_strtok_r( key_value , DELIMITER ,&last_ptr);\t\n\t\t\tif( cur_key_name ){\n\t\t\t\tefree( cur_key_name);\n\t\t\t}\n\t\t\tcur_key_name = (char*)ecalloc( 25,  25);\n\t\t\tsprintf( cur_key_name , \"%s%d\", key_name , cnt++);\t\n\t\t\tadd_assoc_string( hash_arr, cur_key_name , token ,TRUE );\n\t\t\twhile( (token = php_strtok_r(NULL , DELIMITER , &last_ptr)) && (strlen(token)>1) ){\n\t\t\t\tsprintf( cur_key_name , \"%s%d\", key_name , cnt++);\t\n\t\t\t\tadd_assoc_string( hash_arr, cur_key_name , token , TRUE );\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif( result == 1 ){\n\t\t\tadd_assoc_string( hash_arr, key_name , key_value , TRUE );\n\t\t\tcur_result = 1;\n\t\t}\n\t}\n\tif( cur_key_name ){\n\t\tefree( cur_key_name);\n\t}\n\tif( key_value){\n\t\tefree(key_value);\t\n\t}\n\treturn cur_result;\n}", "target": 1}
{"code": "static unsigned int help(struct sk_buff *skb,\n\t\t\t enum ip_conntrack_info ctinfo,\n\t\t\t unsigned int protoff,\n\t\t\t unsigned int matchoff,\n\t\t\t unsigned int matchlen,\n\t\t\t struct nf_conntrack_expect *exp)\n{\n\tchar buffer[sizeof(\"4294967296 65635\")];\n\tu_int16_t port;\n\tunsigned int ret;\n\texp->saved_proto.tcp.port = exp->tuple.dst.u.tcp.port;\n\texp->dir = IP_CT_DIR_REPLY;\n\texp->expectfn = nf_nat_follow_master;\n\tfor (port = ntohs(exp->saved_proto.tcp.port); port != 0; port++) {\n\t\tint ret;\n\t\texp->tuple.dst.u.tcp.port = htons(port);\n\t\tret = nf_ct_expect_related(exp);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\telse if (ret != -EBUSY) {\n\t\t\tport = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (port == 0) {\n\t\tnf_ct_helper_log(skb, exp->master, \"all ports in use\");\n\t\treturn NF_DROP;\n\t}\n\tret = nf_nat_mangle_tcp_packet(skb, exp->master, ctinfo,\n\t\t\t\t       protoff, matchoff, matchlen, buffer,\n\t\t\t\t       strlen(buffer));\n\tif (ret != NF_ACCEPT) {\n\t\tnf_ct_helper_log(skb, exp->master, \"cannot mangle packet\");\n\t\tnf_ct_unexpect_related(exp);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "CONCRETE_IO_HANDLE socketio_create(void* io_create_parameters)\n{\n    SOCKETIO_CONFIG* socket_io_config = io_create_parameters;\n    SOCKET_IO_INSTANCE* result;\n    if (socket_io_config == NULL)\n    {\n        LogError(\"Invalid argument: socket_io_config is NULL\");\n        result = NULL;\n    }\n    else\n    {\n        result = malloc(sizeof(SOCKET_IO_INSTANCE));\n        if (result != NULL)\n        {\n            (void)memset(result, 0, sizeof(SOCKET_IO_INSTANCE));\n            result->address_type = ADDRESS_TYPE_IP;\n            result->pending_io_list = singlylinkedlist_create();\n            if (result->pending_io_list == NULL)\n            {\n                LogError(\"Failure: singlylinkedlist_create unable to create pending list.\");\n                destroy_socket_io_instance(result);\n                result = NULL;\n            }\n            else\n            {\n                if (socket_io_config->hostname != NULL)\n                {\n                    result->hostname = (char*)malloc(strlen(socket_io_config->hostname) + 1);\n                    if (result->hostname != NULL)\n                    {\n                        (void)strcpy(result->hostname, socket_io_config->hostname);\n                    }\n                    result->socket = INVALID_SOCKET;\n                }\n                else\n                {\n                    result->hostname = NULL;\n                    result->socket = *((int*)socket_io_config->accepted_socket);\n                }\n                if ((result->hostname == NULL) && (result->socket == INVALID_SOCKET))\n                {\n                    LogError(\"Failure: hostname == NULL and socket is invalid.\");\n                    destroy_socket_io_instance(result);\n                    result = NULL;\n                }\n                else\n                {\n                    result->port = socket_io_config->port;\n                    result->on_io_open_complete = NULL;\n                    result->dns_resolver = dns_resolver_create(result->hostname, socket_io_config->port, NULL);\n                    result->target_mac_address = NULL;\n                    result->on_bytes_received = NULL;\n                    result->on_io_error = NULL;\n                    result->on_bytes_received_context = NULL;\n                    result->on_io_error_context = NULL;\n                    result->io_state = IO_STATE_CLOSED;\n                }\n            }\n        }\n        else\n        {\n            LogError(\"Allocation Failure: SOCKET_IO_INSTANCE\");\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "void RenderWidgetHostImpl::ForwardMouseEvent(const WebMouseEvent& mouse_event) {\n  ForwardMouseEventWithLatencyInfo(mouse_event, ui::LatencyInfo());\n  if (owner_delegate_)\n    owner_delegate_->RenderWidgetDidForwardMouseEvent(mouse_event);\n}", "target": 0}
{"code": "DECLARESepPutFunc(putRGBseparate16bittile)\n{\n\tuint16 *wr = (uint16*) r;\n\tuint16 *wg = (uint16*) g;\n\tuint16 *wb = (uint16*) b;\n\t(void) img; (void) y; (void) a;\n\twhile (h-- > 0) {\n\t\tfor (x = 0; x < w; x++)\n\t\t\t*cp++ = PACK(img->Bitdepth16To8[*wr++],\n\t\t\t    img->Bitdepth16To8[*wg++],\n\t\t\t    img->Bitdepth16To8[*wb++]);\n\t\tSKEW(wr, wg, wb, fromskew);\n\t\tcp += toskew;\n\t}\n}", "target": 0}
{"code": "call_backend(char *uri,                 \n\t     int  argc,                 \n\t     char **argv,\t\t\n\t     char *filename)            \n{\n  const char\t*cups_serverbin;\t\n  char\t\tscheme[1024],           \n                *ptr,\t\t\t\n\t\tcmdline[65536];\t\t\n  int           retval;\n  strncpy(scheme, uri, sizeof(scheme) - 1);\n  if (strlen(uri) > 1023)\n    scheme[1023] = '\\0';\n  if ((ptr = strchr(scheme, ':')) != NULL)\n    *ptr = '\\0';\n  if ((cups_serverbin = getenv(\"CUPS_SERVERBIN\")) == NULL)\n    cups_serverbin = CUPS_SERVERBIN;\n  if (!strncasecmp(uri, \"file:\", 5) || uri[0] == '/')\n  {\n    fprintf(stderr,\n\t    \"ERROR: beh: Direct output into a file not supported.\\n\");\n    exit (CUPS_BACKEND_FAILED);\n  }\n  else\n    snprintf(cmdline, sizeof(cmdline),\n\t     \"%s/backend/%s '%s' '%s' '%s' '%s' '%s' %s\",\n\t     cups_serverbin, scheme, argv[1], argv[2], argv[3],\n\t     (argc == 6 ? \"1\" : argv[4]),\n\t     argv[5], filename);\n  setenv(\"DEVICE_URI\", uri, 1);\n  fprintf(stderr,\n\t  \"DEBUG: beh: Executing backend command line \\\"%s\\\"...\\n\",\n\t  cmdline);\n  fprintf(stderr,\n\t  \"DEBUG: beh: Using device URI: %s\\n\",\n\t  uri);\n  retval = system(cmdline) >> 8;\n  if (retval == -1)\n    fprintf(stderr, \"ERROR: Unable to execute backend command line: %s\\n\",\n\t    strerror(errno));\n  return (retval);\n}", "target": 1}
{"code": "mwifiex_cmd_append_vsie_tlv(struct mwifiex_private *priv,\n\t\t\t    u16 vsie_mask, u8 **buffer)\n{\n\tint id, ret_len = 0;\n\tstruct mwifiex_ie_types_vendor_param_set *vs_param_set;\n\tif (!buffer)\n\t\treturn 0;\n\tif (!(*buffer))\n\t\treturn 0;\n\tfor (id = 0; id < MWIFIEX_MAX_VSIE_NUM; id++) {\n\t\tif (priv->vs_ie[id].mask & vsie_mask) {\n\t\t\tvs_param_set =\n\t\t\t\t(struct mwifiex_ie_types_vendor_param_set *)\n\t\t\t\t*buffer;\n\t\t\tvs_param_set->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_PASSTHROUGH);\n\t\t\tvs_param_set->header.len =\n\t\t\t\tcpu_to_le16((((u16) priv->vs_ie[id].ie[1])\n\t\t\t\t& 0x00FF) + 2);\n\t\t\tif (le16_to_cpu(vs_param_set->header.len) >\n\t\t\t\tMWIFIEX_MAX_VSIE_LEN) {\n\t\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t\t    \"Invalid param length!\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(vs_param_set->ie, priv->vs_ie[id].ie,\n\t\t\t       le16_to_cpu(vs_param_set->header.len));\n\t\t\t*buffer += le16_to_cpu(vs_param_set->header.len) +\n\t\t\t\t   sizeof(struct mwifiex_ie_types_header);\n\t\t\tret_len += le16_to_cpu(vs_param_set->header.len) +\n\t\t\t\t   sizeof(struct mwifiex_ie_types_header);\n\t\t}\n\t}\n\treturn ret_len;\n}", "target": 0}
{"code": "TEE_Result syscall_authenc_update_aad(unsigned long state,\n\t\t\tconst void *aad_data, size_t aad_data_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t) aad_data,\n\t\t\t\t\t  aad_data_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\tres = crypto_authenc_update_aad(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\taad_data, aad_data_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\treturn TEE_SUCCESS;\n}", "target": 0}
{"code": "Bool gf_isom_is_self_contained(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\treturn Media_IsSelfContained(trak->Media, sampleDescriptionIndex);\n}", "target": 0}
{"code": "Item_func_ne::add_key_fields(JOIN *join, KEY_FIELD **key_fields,\n                             uint *and_level, table_map usable_tables,\n                             SARGABLE_PARAM **sargables)\n{\n  if (!(used_tables() & OUTER_REF_TABLE_BIT))\n  {\n    if (is_local_field(args[0]) && !is_local_field(args[1]))\n      add_key_equal_fields(join, key_fields, *and_level, this,\n                           (Item_field*) (args[0]->real_item()), false,\n                           &args[1], 1, usable_tables, sargables);\n    if (is_local_field(args[1]) && !is_local_field(args[0]))\n      add_key_equal_fields(join, key_fields, *and_level, this,\n                           (Item_field*) (args[1]->real_item()), false,\n                           &args[0], 1, usable_tables, sargables);\n  }\n}", "target": 0}
{"code": "static void *nested_svm_map(struct vcpu_svm *svm, u64 gpa, struct page **_page)\n{\n\tstruct page *page;\n\tmight_sleep();\n\tpage = gfn_to_page(svm->vcpu.kvm, gpa >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\tgoto error;\n\t*_page = page;\n\treturn kmap(page);\nerror:\n\tkvm_inject_gp(&svm->vcpu, 0);\n\treturn NULL;\n}", "target": 0}
{"code": "\t__releases(rcu_bh)\n{\n\trcu_read_unlock_bh();\n}", "target": 0}
{"code": "NOEXPORT int verify_callback(int preverify_ok, X509_STORE_CTX *callback_ctx) {\n    SSL *ssl;\n    CLI *c;\n    ssl=X509_STORE_CTX_get_ex_data(callback_ctx,\n        SSL_get_ex_data_X509_STORE_CTX_idx());\n    c=SSL_get_ex_data(ssl, index_ssl_cli);\n    if(!c->opt->option.verify_chain && !c->opt->option.verify_peer) {\n        s_log(LOG_INFO, \"Certificate verification disabled\");\n        return 1; \n    }\n    if(verify_checks(c, preverify_ok, callback_ctx)) {\n        SSL_SESSION *sess=SSL_get1_session(c->ssl);\n        if(sess) {\n            int ok=SSL_SESSION_set_ex_data(sess, index_session_authenticated,\n                (void *)(-1));\n            SSL_SESSION_free(sess);\n            if(!ok) {\n                sslerror(\"SSL_SESSION_set_ex_data\");\n                return 0; \n            }\n        }\n        return 1; \n    }\n    if(c->opt->option.client || c->opt->protocol)\n        return 0; \n    if(c->opt->redirect_addr.names)\n        return 1; \n    return 0; \n}", "target": 1}
{"code": "String roamingUserSpecificStorageDirectory()\n{\n    return cachedStorageDirectory(CSIDL_APPDATA);\n}", "target": 0}
{"code": "int blkdev_issue_flush(struct block_device *bdev, gfp_t gfp_mask,\n\t\tsector_t *error_sector)\n{\n\tstruct request_queue *q;\n\tstruct bio *bio;\n\tint ret = 0;\n\tif (bdev->bd_disk == NULL)\n\t\treturn -ENXIO;\n\tq = bdev_get_queue(bdev);\n\tif (!q)\n\t\treturn -ENXIO;\n\tif (!q->make_request_fn)\n\t\treturn -ENXIO;\n\tbio = bio_alloc(gfp_mask, 0);\n\tbio->bi_bdev = bdev;\n\tret = submit_bio_wait(WRITE_FLUSH, bio);\n\tif (error_sector)\n\t\t*error_sector = bio->bi_iter.bi_sector;\n\tbio_put(bio);\n\treturn ret;\n}", "target": 0}
{"code": "static int dump_seek(struct file *file, loff_t off)\n{\n\tif (file->f_op->llseek && file->f_op->llseek != no_llseek) {\n\t\tif (file->f_op->llseek(file, off, SEEK_CUR) < 0)\n\t\t\treturn 0;\n\t} else {\n\t\tchar *buf = (char *)get_zeroed_page(GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn 0;\n\t\twhile (off > 0) {\n\t\t\tunsigned long n = off;\n\t\t\tif (n > PAGE_SIZE)\n\t\t\t\tn = PAGE_SIZE;\n\t\t\tif (!dump_write(file, buf, n))\n\t\t\t\treturn 0;\n\t\t\toff -= n;\n\t\t}\n\t\tfree_page((unsigned long)buf);\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "update_bar_address(struct vmctx *ctx, struct pci_vdev *dev, uint64_t addr,\n\tint idx, int type, bool ignore_reg_unreg)\n{\n\tbool decode = false;\n\tuint64_t orig_addr = dev->bar[idx].addr;\n\tif (!ignore_reg_unreg) {\n\t\tif (dev->bar[idx].type == PCIBAR_IO)\n\t\t\tdecode = porten(dev);\n\t\telse\n\t\t\tdecode = memen(dev);\n\t}\n\tif (decode)\n\t\tunregister_bar(dev, idx);\n\tswitch (type) {\n\tcase PCIBAR_IO:\n\tcase PCIBAR_MEM32:\n\t\tdev->bar[idx].addr = addr;\n\t\tbreak;\n\tcase PCIBAR_MEM64:\n\t\tdev->bar[idx].addr &= ~0xffffffffUL;\n\t\tdev->bar[idx].addr |= addr;\n\t\tbreak;\n\tcase PCIBAR_MEMHI64:\n\t\tdev->bar[idx].addr &= 0xffffffff;\n\t\tdev->bar[idx].addr |= addr;\n\t\tbreak;\n\tdefault:\n\t\tassert(0);\n\t}\n\tif (decode)\n\t\tregister_bar(dev, idx);\n\tif (dev->dev_ops->vdev_update_bar_map && decode)\n\t\tdev->dev_ops->vdev_update_bar_map(ctx, dev, idx, orig_addr);\n}", "target": 1}
{"code": "static int ip_setup_cork(struct sock *sk, struct inet_cork *cork,\n\t\t\t struct ipcm_cookie *ipc, struct rtable **rtp)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_options *opt;\n\tstruct rtable *rt;\n\topt = ipc->opt;\n\tif (opt) {\n\t\tif (cork->opt == NULL) {\n\t\t\tcork->opt = kmalloc(sizeof(struct ip_options) + 40,\n\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (unlikely(cork->opt == NULL))\n\t\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tmemcpy(cork->opt, opt, sizeof(struct ip_options) + opt->optlen);\n\t\tcork->flags |= IPCORK_OPT;\n\t\tcork->addr = ipc->addr;\n\t}\n\trt = *rtp;\n\tif (unlikely(!rt))\n\t\treturn -EFAULT;\n\t*rtp = NULL;\n\tcork->fragsize = inet->pmtudisc == IP_PMTUDISC_PROBE ?\n\t\t\t rt->dst.dev->mtu : dst_mtu(rt->dst.path);\n\tcork->dst = &rt->dst;\n\tcork->length = 0;\n\tcork->tx_flags = ipc->tx_flags;\n\tcork->page = NULL;\n\tcork->off = 0;\n\treturn 0;\n}", "target": 1}
{"code": "static int gasp_source_id(__be32 *p)\n{\n\treturn be32_to_cpu(p[0]) >> 16;\n}", "target": 0}
{"code": "Envoy::Ssl::ClientValidationStatus DefaultCertValidator::verifyCertificate(\n    X509* cert, const std::vector<std::string>& verify_san_list,\n    const std::vector<Matchers::StringMatcherImpl<envoy::type::matcher::v3::StringMatcher>>&\n        subject_alt_name_matchers) {\n  Envoy::Ssl::ClientValidationStatus validated = Envoy::Ssl::ClientValidationStatus::NotValidated;\n  if (!verify_san_list.empty()) {\n    if (!verifySubjectAltName(cert, verify_san_list)) {\n      stats_.fail_verify_san_.inc();\n      return Envoy::Ssl::ClientValidationStatus::Failed;\n    }\n    validated = Envoy::Ssl::ClientValidationStatus::Validated;\n  }\n  if (!subject_alt_name_matchers.empty()) {\n    if (!matchSubjectAltName(cert, subject_alt_name_matchers)) {\n      stats_.fail_verify_san_.inc();\n      return Envoy::Ssl::ClientValidationStatus::Failed;\n    }\n    validated = Envoy::Ssl::ClientValidationStatus::Validated;\n  }\n  if (!verify_certificate_hash_list_.empty() || !verify_certificate_spki_list_.empty()) {\n    const bool valid_certificate_hash =\n        !verify_certificate_hash_list_.empty() &&\n        verifyCertificateHashList(cert, verify_certificate_hash_list_);\n    const bool valid_certificate_spki =\n        !verify_certificate_spki_list_.empty() &&\n        verifyCertificateSpkiList(cert, verify_certificate_spki_list_);\n    if (!valid_certificate_hash && !valid_certificate_spki) {\n      stats_.fail_verify_cert_hash_.inc();\n      return Envoy::Ssl::ClientValidationStatus::Failed;\n    }\n    validated = Envoy::Ssl::ClientValidationStatus::Validated;\n  }\n  return validated;\n}", "target": 1}
{"code": "void flush_tlb_mm_range(struct mm_struct *mm, unsigned long start,\n\t\t\t\tunsigned long end, unsigned long vmflag)\n{\n\tunsigned long addr;\n\tunsigned long base_pages_to_flush = TLB_FLUSH_ALL;\n\tpreempt_disable();\n\tif (current->active_mm != mm)\n\t\tgoto out;\n\tif (!current->mm) {\n\t\tleave_mm(smp_processor_id());\n\t\tgoto out;\n\t}\n\tif ((end != TLB_FLUSH_ALL) && !(vmflag & VM_HUGETLB))\n\t\tbase_pages_to_flush = (end - start) >> PAGE_SHIFT;\n\tif (base_pages_to_flush > tlb_single_page_flush_ceiling) {\n\t\tbase_pages_to_flush = TLB_FLUSH_ALL;\n\t\tcount_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);\n\t\tlocal_flush_tlb();\n\t} else {\n\t\tfor (addr = start; addr < end;\taddr += PAGE_SIZE) {\n\t\t\tcount_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ONE);\n\t\t\t__flush_tlb_single(addr);\n\t\t}\n\t}\n\ttrace_tlb_flush(TLB_LOCAL_MM_SHOOTDOWN, base_pages_to_flush);\nout:\n\tif (base_pages_to_flush == TLB_FLUSH_ALL) {\n\t\tstart = 0UL;\n\t\tend = TLB_FLUSH_ALL;\n\t}\n\tif (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids)\n\t\tflush_tlb_others(mm_cpumask(mm), mm, start, end);\n\tpreempt_enable();\n}", "target": 1}
{"code": "static struct dst_entry *ip6_sk_dst_check(struct sock *sk,\n\t\t\t\t\t  struct dst_entry *dst,\n\t\t\t\t\t  const struct flowi6 *fl6)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct rt6_info *rt = (struct rt6_info *)dst;\n\tif (!dst)\n\t\tgoto out;\n\tif (ip6_rt_check(&rt->rt6i_dst, &fl6->daddr, np->daddr_cache) ||\n#ifdef CONFIG_IPV6_SUBTREES\n\t    ip6_rt_check(&rt->rt6i_src, &fl6->saddr, np->saddr_cache) ||\n#endif\n\t    (fl6->flowi6_oif && fl6->flowi6_oif != dst->dev->ifindex)) {\n\t\tdst_release(dst);\n\t\tdst = NULL;\n\t}\nout:\n\treturn dst;\n}", "target": 1}
{"code": "TfLiteStatus GatherStrings(TfLiteContext* context, const TfLiteTensor* input,\n                           const TfLiteTensor* positions,\n                           TfLiteTensor* output) {\n  DynamicBuffer buffer;\n  const PositionT* indexes = GetTensorData<PositionT>(positions);\n  bool indices_has_only_positive_elements = true;\n  const size_t num_indices = positions->bytes / sizeof(PositionT);\n  for (size_t i = 0; i < num_indices; i++) {\n    if (indexes[i] < 0) {\n      indices_has_only_positive_elements = false;\n      break;\n    }\n  }\n  TF_LITE_ENSURE(context, indices_has_only_positive_elements);\n  const PositionT num_strings = GetStringCount(input);\n  const int num_indexes = NumElements(positions);\n  for (int i = 0; i < num_indexes; ++i) {\n    const PositionT pos = indexes[i];\n    TF_LITE_ENSURE(context, pos < num_strings);\n    const auto string_ref = GetString(input, pos);\n    buffer.AddString(string_ref.str, string_ref.len);\n  }\n  buffer.WriteToTensor(output, nullptr);\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n                                const uint8_t *buf, int buf_size)\n{\n    ParseContext *pc = &dctx->pc;\n    uint64_t state = pc->state64;\n    int pic_found = pc->frame_start_found;\n    int i = 0;\n    if (!pic_found) {\n        for (i = 0; i < buf_size; i++) {\n            state = (state << 8) | buf[i];\n            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {\n                i++;\n                pic_found = 1;\n                dctx->cur_byte = 0;\n                dctx->remaining = 0;\n                break;\n            }\n        }\n    }\n    if (pic_found && !dctx->remaining) {\n        if (!buf_size) \n            return 0;\n        for (; i < buf_size; i++) {\n            dctx->cur_byte++;\n            state = (state << 8) | buf[i];\n            if (dctx->cur_byte == 24) {\n                dctx->h = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 26) {\n                dctx->w = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 42) {\n                int cid = (state >> 32) & 0xFFFFFFFF;\n                if (cid <= 0)\n                    continue;\n                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);\n                if (dctx->remaining <= 0) {\n                    dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n                    if (dctx->remaining <= 0)\n                        return dctx->remaining;\n                }\n                if (buf_size - i + 47 >= dctx->remaining) {\n                    int remaining = dctx->remaining;\n                    pc->frame_start_found = 0;\n                    pc->state64 = -1;\n                    dctx->cur_byte = 0;\n                    dctx->remaining = 0;\n                    return remaining;\n                } else {\n                    dctx->remaining -= buf_size;\n                }\n            }\n        }\n    } else if (pic_found) {\n        if (dctx->remaining > buf_size) {\n            dctx->remaining -= buf_size;\n        } else {\n            int remaining = dctx->remaining;\n            pc->frame_start_found = 0;\n            pc->state64 = -1;\n            dctx->cur_byte = 0;\n            dctx->remaining = 0;\n            return remaining;\n        }\n    }\n    pc->frame_start_found = pic_found;\n    pc->state64 = state;\n    return END_NOT_FOUND;\n}", "target": 1}
{"code": "void pdf_load_pages_kids(FILE *fp, pdf_t *pdf)\n{\n    int     i, id, dummy;\n    char   *buf, *c;\n    long    start, sz;\n    start = ftell(fp);\n    for (i=0; i<pdf->n_xrefs; i++)\n    {\n        if (pdf->xrefs[i].version && (pdf->xrefs[i].end != 0))\n        {\n            fseek(fp, pdf->xrefs[i].start, SEEK_SET);\n            while (SAFE_F(fp, (fgetc(fp) != 't')))\n                ; \n            sz = pdf->xrefs[i].end - ftell(fp);\n            buf = malloc(sz + 1);\n            SAFE_E(fread(buf, 1, sz, fp), sz, \"Failed to load /Root.\\n\");\n            buf[sz] = '\\0';\n            if (!(c = strstr(buf, \"/Root\")))\n            {\n                free(buf);\n                continue;\n            }\n            id = atoi(c + strlen(\"/Root\") + 1);\n            free(buf);\n            buf = get_object(fp, id, &pdf->xrefs[i], NULL, &dummy);\n            if (!buf || !(c = strstr(buf, \"/Pages\")))\n            {\n                free(buf);\n                continue;\n            }\n            id = atoi(c + strlen(\"/Pages\") + 1);\n            load_kids(fp, id, &pdf->xrefs[i]);\n            free(buf); \n        }\n    }\n    fseek(fp, start, SEEK_SET);\n}", "target": 1}
{"code": "void testPartialDataHandling(const T& val, size_t bytesToPassTheCheck) {\n  auto buf = Serializer::template serialize<folly::IOBufQueue>(val).move();\n  buf->coalesce();\n  EXPECT_NO_THROW(Serializer::template deserialize<T>(buf.get()));\n  buf->trimEnd(buf->length() - bytesToPassTheCheck);\n  EXPECT_THROW(\n      Serializer::template deserialize<T>(buf.get()), std::out_of_range);\n  buf->trimEnd(1);\n  EXPECT_THROW(\n      Serializer::template deserialize<T>(buf.get()),\n      apache::thrift::protocol::TProtocolException);\n}", "target": 0}
{"code": "static int store_icy(URLContext *h, int size)\n{\n    HTTPContext *s = h->priv_data;\n    int remaining = s->icy_metaint - s->icy_data_read;\n    if (remaining < 0)\n        return AVERROR_INVALIDDATA;\n    if (!remaining) {\n        uint8_t ch;\n        int len = http_read_stream_all(h, &ch, 1);\n        if (len < 0)\n            return len;\n        if (ch > 0) {\n            char data[255 * 16 + 1];\n            int ret;\n            len = ch * 16;\n            ret = http_read_stream_all(h, data, len);\n            if (ret < 0)\n                return ret;\n            data[len + 1] = 0;\n            if ((ret = av_opt_set(s, \"icy_metadata_packet\", data, 0)) < 0)\n                return ret;\n            update_metadata(s, data);\n        }\n        s->icy_data_read = 0;\n        remaining        = s->icy_metaint;\n    }\n    return FFMIN(size, remaining);\n}", "target": 1}
{"code": "TEST(UriSuite, TestIpSixOverread) {\n\t\tUriUriA uri;\n\t\tconst char * errorPos;\n\t\tchar uriText[2 + 3 + 2 + 1 + 1];\n\t\tstrncpy(uriText, \"\n\t\tEXPECT_EQ(uriParseSingleUriExA(&uri, uriText,\n\t\t\t\turiText + sizeof(uriText), &errorPos), URI_ERROR_SYNTAX);\n\t\tEXPECT_EQ(errorPos, uriText + sizeof(uriText));\n}", "target": 0}
{"code": "  void readErr(const AsyncSocketException& ex) noexcept override {\n    LOG(ERROR) << ex.what();\n  }", "target": 0}
{"code": "static struct ast_sip_endpoint *transport_identify(pjsip_rx_data *rdata)\n{\n\tchar buffer[PJ_INET6_ADDRSTRLEN];\n\tpj_status_t status;\n\tstruct ast_sockaddr_with_tp addr_with_tp = { { { 0, } }, };\n\tunion pj_sockaddr sock = rdata->tp_info.transport->local_addr;\n\tpj_ansi_strxcpy(addr_with_tp.tp, rdata->tp_info.transport->type_name, sizeof(addr_with_tp.tp));\n\tif (sock.addr.sa_family == PJ_AF_INET6) {\n\t\tstatus = pj_inet_ntop(PJ_AF_INET6, &(sock.ipv6.sin6_addr), buffer, PJ_INET6_ADDRSTRLEN);\n\t\tif (status == PJ_SUCCESS && !strcmp(buffer, \"::\")) {\n\t\t\tast_log(LOG_WARNING, \"Matching against '::' may be unpredictable.\\n\");\n\t\t}\n\t} else {\n\t\tstatus = pj_inet_ntop(PJ_AF_INET, &(sock.ipv4.sin_addr), buffer, PJ_INET_ADDRSTRLEN);\n\t\tif (status == PJ_SUCCESS && !strcmp(buffer, \"0.0.0.0\")) {\n\t\t\tast_log(LOG_WARNING, \"Matching against '0.0.0.0' may be unpredictable.\\n\");\n\t\t}\n\t}\n\tif (status == PJ_SUCCESS) {\n\t\tast_sockaddr_parse(&addr_with_tp.addr, buffer, PARSE_PORT_FORBID);\n\t\tast_sockaddr_set_port(&addr_with_tp.addr, rdata->tp_info.transport->local_name.port);\n\t\treturn common_identify(ip_identify_match_check, &addr_with_tp);\n\t} else {\n\t\treturn NULL;\n\t}\n}", "target": 1}
{"code": "TEST_F(HTTP2DownstreamSessionTest, TestDuplicateRequestStream) {\n  auto handler2 = addSimpleStrictHandler();\n  auto handler1 = addSimpleStrictHandler();\n  auto streamID1 = sendRequest(\"/withtrailers\", 0, false);\n  auto streamID2 = sendRequest();\n  HTTPHeaders trailers;\n  trailers.add(\"Foo\", \"Bar\");\n  clientCodec_->generateTrailers(requests_, streamID1, trailers);\n  clientCodec_->generateEOM(requests_, streamID1);\n  clientCodec_->generateHeader(requests_, streamID2, getGetRequest(), false);\n  handler1->expectHeaders();\n  handler2->expectHeaders();\n  handler2->expectEOM();\n  handler1->expectTrailers();\n  handler1->expectEOM([&] {\n      handler1->sendReplyWithBody(200, 100);\n      handler2->sendReplyWithBody(200, 100);\n    });\n  handler1->expectDetachTransaction();\n  handler2->expectDetachTransaction();\n  flushRequestsAndLoop();\n  gracefulShutdown();\n}", "target": 0}
{"code": "translate_hex_string(char *s, char *saved_orphan)\n{\n  int c1 = *saved_orphan;\n  char *start = s;\n  char *t = s;\n  for (; *s; s++) {\n    if (isspace(*s))\n      continue;\n    if (c1) {\n      *t++ = (hexval(c1) << 4) + hexval(*s);\n      c1 = 0;\n    } else\n      c1 = *s;\n  }\n  *saved_orphan = c1;\n  return t - start;\n}", "target": 1}
{"code": "nfs4_atomic_open(struct inode *dir, struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct path path = {\n\t\t.mnt = nd->path.mnt,\n\t\t.dentry = dentry,\n\t};\n\tstruct dentry *parent;\n\tstruct iattr attr;\n\tstruct rpc_cred *cred;\n\tstruct nfs4_state *state;\n\tstruct dentry *res;\n\tif (nd->flags & LOOKUP_CREATE) {\n\t\tattr.ia_mode = nd->intent.open.create_mode;\n\t\tattr.ia_valid = ATTR_MODE;\n\t\tif (!IS_POSIXACL(dir))\n\t\t\tattr.ia_mode &= ~current->fs->umask;\n\t} else {\n\t\tattr.ia_valid = 0;\n\t\tBUG_ON(nd->intent.open.flags & O_CREAT);\n\t}\n\tcred = rpc_lookup_cred();\n\tif (IS_ERR(cred))\n\t\treturn (struct dentry *)cred;\n\tparent = dentry->d_parent;\n\tnfs_block_sillyrename(parent);\n\tstate = nfs4_do_open(dir, &path, nd->intent.open.flags, &attr, cred);\n\tput_rpccred(cred);\n\tif (IS_ERR(state)) {\n\t\tif (PTR_ERR(state) == -ENOENT) {\n\t\t\td_add(dentry, NULL);\n\t\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\t}\n\t\tnfs_unblock_sillyrename(parent);\n\t\treturn (struct dentry *)state;\n\t}\n\tres = d_add_unique(dentry, igrab(state->inode));\n\tif (res != NULL)\n\t\tpath.dentry = res;\n\tnfs_set_verifier(path.dentry, nfs_save_change_attribute(dir));\n\tnfs_unblock_sillyrename(parent);\n\tnfs4_intent_set_file(nd, &path, state);\n\treturn res;\n}", "target": 1}
{"code": "static void msg_read_tiny(const uint8_t *msg, size_t len) {\n    if (len != 64)\n        return;\n    uint8_t buf[64];\n    memcpy(buf, msg, sizeof(buf));\n    if (buf[0] != '?' || buf[1] != '#' || buf[2] != '#') {\n        (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed tiny packet\");\n        return;\n    }\n    uint16_t msgId = buf[4] | ((uint16_t)buf[3]) << 8;\n    uint32_t msgSize = buf[8]        |\n            ((uint32_t)buf[7]) <<  8 |\n            ((uint32_t)buf[6]) << 16 |\n            ((uint32_t)buf[5]) << 24;\n    if (msgSize > 64 - 9) {\n        (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed tiny packet\");\n        return;\n    }\n    const pb_field_t *fields = NULL;\n    pb_istream_t stream = pb_istream_from_buffer(buf + 9, msgSize);\n    switch (msgId) {\n    case MessageType_MessageType_PinMatrixAck:\n        fields = PinMatrixAck_fields;\n        break;\n    case MessageType_MessageType_ButtonAck:\n        fields = ButtonAck_fields;\n        break;\n    case MessageType_MessageType_PassphraseAck:\n        fields = PassphraseAck_fields;\n        break;\n    case MessageType_MessageType_Cancel:\n        fields = Cancel_fields;\n        break;\n    case MessageType_MessageType_Initialize:\n        fields = Initialize_fields;\n        break;\n#if DEBUG_LINK\n    case MessageType_MessageType_DebugLinkDecision:\n        fields = DebugLinkDecision_fields;\n        break;\n    case MessageType_MessageType_DebugLinkGetState:\n        fields = DebugLinkGetState_fields;\n        break;\n#endif\n    }\n    if (fields) {\n        bool status = pb_decode(&stream, fields, msg_tiny);\n        if (status) {\n            msg_tiny_id = msgId;\n        } else {\n            (*msg_failure)(FailureType_Failure_SyntaxError, stream.errmsg);\n            msg_tiny_id = 0xffff;\n        }\n    } else {\n        (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Unknown message\");\n        msg_tiny_id = 0xffff;\n    }\n}", "target": 0}
{"code": "static inline int pfkey_mode_to_xfrm(int mode)\n{\n\tswitch(mode) {\n\tcase IPSEC_MODE_ANY:\t\n\tcase IPSEC_MODE_TRANSPORT:\n\t\treturn XFRM_MODE_TRANSPORT;\n\tcase IPSEC_MODE_TUNNEL:\n\t\treturn XFRM_MODE_TUNNEL;\n\tcase IPSEC_MODE_BEET:\n\t\treturn XFRM_MODE_BEET;\n\tdefault:\n\t\treturn -1;\n\t}\n}", "target": 0}
{"code": "static int http_read_header(URLContext *h, int *new_location)\n{\n    HTTPContext *s = h->priv_data;\n    char line[MAX_URL_SIZE];\n    int err = 0;\n    s->chunksize = -1;\n    for (;;) {\n        if ((err = http_get_line(s, line, sizeof(line))) < 0)\n            return err;\n        av_log(h, AV_LOG_TRACE, \"header='%s'\\n\", line);\n        err = process_line(h, line, s->line_count, new_location);\n        if (err < 0)\n            return err;\n        if (err == 0)\n            break;\n        s->line_count++;\n    }\n    if (s->seekable == -1 && s->is_mediagateway && s->filesize == 2000000000)\n        h->is_streamed = 1; \n    cookie_string(s->cookie_dict, &s->cookies);\n    av_dict_free(&s->cookie_dict);\n    return err;\n}", "target": 1}
{"code": "FPDF_SYSTEMTIME PDFiumEngine::Form_GetLocalTime(FPDF_FORMFILLINFO* param) {\n  base::Time time = base::Time::Now();\n  base::Time::Exploded exploded;\n  time.LocalExplode(&exploded);\n  FPDF_SYSTEMTIME rv;\n  rv.wYear = exploded.year;\n  rv.wMonth = exploded.month;\n  rv.wDayOfWeek = exploded.day_of_week;\n  rv.wDay = exploded.day_of_month;\n  rv.wHour = exploded.hour;\n  rv.wMinute = exploded.minute;\n  rv.wSecond = exploded.second;\n  rv.wMilliseconds = exploded.millisecond;\n  return rv;\n}", "target": 0}
{"code": "cherokee_validator_ldap_check (cherokee_validator_ldap_t *ldap,\n                               cherokee_connection_t     *conn)\n{\n\tint                              re;\n\tret_t                            ret;\n\tsize_t                           size;\n\tchar                            *dn;\n\tLDAPMessage                     *message;\n\tLDAPMessage                     *first;\n\tchar                            *attrs[] = { LDAP_NO_ATTRS, NULL };\n\tcherokee_validator_ldap_props_t *props   = VAL_LDAP_PROP(ldap);\n\tif ((conn->validator == NULL) ||\n\t    cherokee_buffer_is_empty (&conn->validator->user))\n\t\treturn ret_error;\n\tsize = cherokee_buffer_cnt_cspn (&conn->validator->user, 0, \"*()\");\n\tif (size != conn->validator->user.len)\n\t\treturn ret_error;\n\tret = init_filter (ldap, props, conn);\n\tif (ret != ret_ok)\n\t\treturn ret;\n\tre = ldap_search_s (ldap->conn, props->basedn.buf, LDAP_SCOPE_SUBTREE, ldap->filter.buf, attrs, 0, &message);\n\tif (re != LDAP_SUCCESS) {\n\t\tLOG_ERROR (CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH,\n\t\t           props->filter.buf ? props->filter.buf : \"\");\n\t\treturn ret_error;\n\t}\n\tTRACE (ENTRIES, \"subtree search (%s): done\\n\", ldap->filter.buf ? ldap->filter.buf : \"\");\n\tre = ldap_count_entries (ldap->conn, message);\n\tif (re != 1) {\n\t\tldap_msgfree (message);\n\t\treturn ret_not_found;\n\t}\n\tfirst = ldap_first_entry (ldap->conn, message);\n\tif (first == NULL) {\n\t\tldap_msgfree (message);\n\t\treturn ret_not_found;\n\t}\n\tdn = ldap_get_dn (ldap->conn, first);\n\tif (dn == NULL) {\n\t\tldap_msgfree (message);\n\t\treturn ret_error;\n\t}\n\tldap_msgfree (message);\n\tret = validate_dn (props, dn, conn->validator->passwd.buf);\n\tif (ret != ret_ok)\n\t\treturn ret;\n\tre = ldap_unbind_s (ldap->conn);\n\tif (re != LDAP_SUCCESS)\n\t\treturn ret_error;\n\tTRACE (ENTRIES, \"Access to use %s has been granted\\n\", conn->validator->user.buf);\n\treturn ret_ok;\n}", "target": 1}
{"code": "static ssize_t ucma_write(struct file *filp, const char __user *buf,\n\t\t\t  size_t len, loff_t *pos)\n{\n\tstruct ucma_file *file = filp->private_data;\n\tstruct rdma_ucm_cmd_hdr hdr;\n\tssize_t ret;\n\tif (WARN_ON_ONCE(!ib_safe_file_access(filp)))\n\t\treturn -EACCES;\n\tif (len < sizeof(hdr))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&hdr, buf, sizeof(hdr)))\n\t\treturn -EFAULT;\n\tif (hdr.cmd >= ARRAY_SIZE(ucma_cmd_table))\n\t\treturn -EINVAL;\n\tif (hdr.in + sizeof(hdr) > len)\n\t\treturn -EINVAL;\n\tif (!ucma_cmd_table[hdr.cmd])\n\t\treturn -ENOSYS;\n\tret = ucma_cmd_table[hdr.cmd](file, buf + sizeof(hdr), hdr.in, hdr.out);\n\tif (!ret)\n\t\tret = len;\n\treturn ret;\n}", "target": 0}
{"code": "gopher_request_parse(const HttpRequest * req, char *type_id, char *request)\n{\n    ::Parser::Tokenizer tok(req->url.path());\n    if (request)\n        *request = 0;\n    tok.skip('/'); \n    if (tok.atEnd()) {\n        *type_id = GOPHER_DIRECTORY;\n        return;\n    }\n    static const CharacterSet anyByte(\"UTF-8\",0x00, 0xFF);\n    SBuf typeId;\n    (void)tok.prefix(typeId, anyByte, 1); \n    *type_id = typeId[0];\n    if (request) {\n        SBufToCstring(request, tok.remaining().substr(0, MAX_URL-1));\n        rfc1738_unescape(request);\n    }\n}", "target": 1}
{"code": "x509stack_pop(struct cert_stack *stack)\n{\n\tX509 *cert;\n\tstruct metadata_node *meta;\n\tstruct repo_level_node *repo;\n\tcert = sk_X509_pop(stack->x509s);\n\tif (cert == NULL)\n\t\tpr_crit(\"Attempted to pop empty X509 stack\");\n\tX509_free(cert);\n\tmeta = SLIST_FIRST(&stack->metas);\n\tif (meta == NULL)\n\t\tpr_crit(\"Attempted to pop empty metadata stack\");\n\tSLIST_REMOVE_HEAD(&stack->metas, next);\n\tmeta_destroy(meta);\n\trepo = SLIST_FIRST(&stack->levels);\n\tif (repo == NULL)\n\t\tpr_crit(\"Attempted to pop empty repo level stack\");\n\tSLIST_REMOVE_HEAD(&stack->levels, next);\n\tfree(repo);\n}", "target": 1}
{"code": "is_url(const char *source)\n{\n\tchar *colonp;\n\tcolonp = strchr(source, ':');\n\tif (colonp == NULL)\n\t{\n\t\treturn (0);\n\t}\n\tif (strncmp(colonp + 1, \"\n\t{\n\t\treturn (0);\n\t}\n\treturn (1);\n}", "target": 0}
{"code": "  static void operator delete(void *, MEM_ROOT*) {}", "target": 0}
{"code": "Cleanup Ipv6Instance::forceProtocolUnsupportedForTest(bool new_val) {\n  bool old_val = force_ipv6_unsupported_for_test;\n  force_ipv6_unsupported_for_test = new_val;\n  return Cleanup([old_val]() { force_ipv6_unsupported_for_test = old_val; });\n}", "target": 0}
{"code": "static int save_dev(blkid_dev dev, FILE *file)\n{\n\tstruct list_head *p;\n\tif (!dev || dev->bid_name[0] != '/')\n\t\treturn 0;\n\tDBG(SAVE, ul_debug(\"device %s, type %s\", dev->bid_name, dev->bid_type ?\n\t\t   dev->bid_type : \"(null)\"));\n\tfprintf(file, \"<device DEVNO=\\\"0x%04lx\\\" TIME=\\\"%ld.%ld\\\"\",\n\t\t\t(unsigned long) dev->bid_devno,\n\t\t\t(long) dev->bid_time,\n\t\t\t(long) dev->bid_utime);\n\tif (dev->bid_pri)\n\t\tfprintf(file, \" PRI=\\\"%d\\\"\", dev->bid_pri);\n\tlist_for_each(p, &dev->bid_tags) {\n\t\tblkid_tag tag = list_entry(p, struct blkid_struct_tag, bit_tags);\n\t\tfprintf(file, \" %s=\\\"%s\\\"\", tag->bit_name,tag->bit_val);\n\t}\n\tfprintf(file, \">%s</device>\\n\", dev->bid_name);\n\treturn 0;\n}", "target": 1}
{"code": "BGD_DECLARE(void *) gdImageJpegPtr(gdImagePtr im, int *size, int quality)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) return NULL;\n\tgdImageJpegCtx(im, out, quality);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}", "target": 1}
{"code": "int hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,\n\t\tint type)\n{\n\tint err;\n\tchar *xattr_name;\n\tsize_t size = 0;\n\tchar *value = NULL;\n\thfs_dbg(ACL_MOD, \"[%s]: ino %lu\\n\", __func__, inode->i_ino);\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\txattr_name = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terr = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\terr = 0;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\txattr_name = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tif (unlikely(size > HFSPLUS_MAX_INLINE_DATA_SIZE))\n\t\t\treturn -ENOMEM;\n\t\tvalue = (char *)hfsplus_alloc_attr_entry();\n\t\tif (unlikely(!value))\n\t\t\treturn -ENOMEM;\n\t\terr = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (unlikely(err < 0))\n\t\t\tgoto end_set_acl;\n\t}\n\terr = __hfsplus_setxattr(inode, xattr_name, value, size, 0);\nend_set_acl:\n\thfsplus_destroy_attr_entry((hfsplus_attr_entry *)value);\n\tif (!err)\n\t\tset_cached_acl(inode, type, acl);\n\treturn err;\n}", "target": 1}
{"code": "void PDFiumEngine::ScrollToPage(int page) {\n  in_flight_visible_page_ = page;\n  client_->ScrollToPage(page);\n}", "target": 0}
{"code": "ext4_xattr_block_get(struct inode *inode, int name_index, const char *name,\n\t\t     void *buffer, size_t buffer_size)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct ext4_xattr_entry *entry;\n\tsize_t size;\n\tint error;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\tea_idebug(inode, \"name=%d.%s, buffer=%p, buffer_size=%ld\",\n\t\t  name_index, name, buffer, (long)buffer_size);\n\terror = -ENODATA;\n\tif (!EXT4_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %llu\",\n\t\t  (unsigned long long)EXT4_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));\n\tif (ext4_xattr_check_block(inode, bh)) {\nbad_block:\n\t\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t\t EXT4_I(inode)->i_file_acl);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto cleanup;\n\t}\n\text4_xattr_cache_insert(ext4_mb_cache, bh);\n\tentry = BFIRST(bh);\n\terror = ext4_xattr_find_entry(&entry, name_index, name, bh->b_size, 1);\n\tif (error == -EFSCORRUPTED)\n\t\tgoto bad_block;\n\tif (error)\n\t\tgoto cleanup;\n\tsize = le32_to_cpu(entry->e_value_size);\n\tif (buffer) {\n\t\terror = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\tmemcpy(buffer, bh->b_data + le16_to_cpu(entry->e_value_offs),\n\t\t       size);\n\t}\n\terror = size;\ncleanup:\n\tbrelse(bh);\n\treturn error;\n}", "target": 1}
{"code": "int flush_completed_IO(struct inode *inode)\n{\n\text4_io_end_t *io;\n\tint ret = 0;\n\tint ret2 = 0;\n\tif (list_empty(&EXT4_I(inode)->i_completed_io_list))\n\t\treturn ret;\n\tdump_completed_IO(inode);\n\twhile (!list_empty(&EXT4_I(inode)->i_completed_io_list)){\n\t\tio = list_entry(EXT4_I(inode)->i_completed_io_list.next,\n\t\t\t\text4_io_end_t, list);\n\t\tret = ext4_end_io_nolock(io);\n\t\tif (ret < 0)\n\t\t\tret2 = ret;\n\t\telse\n\t\t\tlist_del_init(&io->list);\n\t}\n\treturn (ret2 < 0) ? ret2 : 0;\n}", "target": 1}
{"code": "static u32 __ipv6_select_ident(struct net *net, u32 hashrnd,\n\t\t\t       const struct in6_addr *dst,\n\t\t\t       const struct in6_addr *src)\n{\n\tu32 hash, id;\n\thash = __ipv6_addr_jhash(dst, hashrnd);\n\thash = __ipv6_addr_jhash(src, hash);\n\thash ^= net_hash_mix(net);\n\tid = ip_idents_reserve(hash, 1);\n\tif (unlikely(!id))\n\t\tid = 1 << 31;\n\treturn id;\n}", "target": 1}
{"code": "CBORTag_hash(CBORTagObject *self)\n{\n    if (!_CBOR2_thread_locals && _CBOR2_init_thread_locals() == -1)\n        return -1;\n    Py_hash_t ret = -1;\n    PyObject *running_hashes = NULL;\n    PyObject *tmp = NULL;\n    PyObject *self_id = PyLong_FromVoidPtr(self);\n    if (!self_id)\n        goto exit;\n    running_hashes = PyObject_GetAttrString(_CBOR2_thread_locals, \"running_hashes\");\n    if (!running_hashes) {\n        PyErr_Clear();\n        running_hashes = PySet_New(NULL);\n        if (PyObject_SetAttrString(_CBOR2_thread_locals, \"running_hashes\", running_hashes) == -1)\n            goto exit;\n    } else {\n        switch (PySet_Contains(running_hashes, self_id)) {\n            case -1:  \n                goto exit;\n            case 1:  \n                PyErr_SetString(\n                    PyExc_RuntimeError,\n                    \"This CBORTag is not hashable because it contains a reference to itself\"\n                );\n                goto exit;\n        }\n    }\n    if (PySet_Add(running_hashes, self_id) == -1)\n        goto exit;\n    tmp = Py_BuildValue(\"(KO)\", self->tag, self->value);\n    if (!tmp)\n        goto exit;\n    ret = PyObject_Hash(tmp);\n    if (PySet_Discard(running_hashes, self_id) == -1) {\n        ret = -1;\n        goto exit;\n    }\n    Py_ssize_t length = PySequence_Length(running_hashes);\n    if (length == 1) {\n        ret = -1;\n        goto exit;\n    }\n    if (length == 0 && PyObject_DelAttrString(_CBOR2_thread_locals, \"running_hashes\") == -1) {\n        ret = -1;\n        goto exit;\n    }\nexit:\n    Py_CLEAR(self_id);\n    Py_CLEAR(running_hashes);\n    Py_CLEAR(tmp);\n    return ret;\n}", "target": 1}
{"code": "static void voutf(struct GlobalConfig *config,\n                  const char *prefix,\n                  const char *fmt,\n                  va_list ap)\n{\n  size_t width = (79 - strlen(prefix));\n  if(!config->mute) {\n    size_t len;\n    char *ptr;\n    char *print_buffer;\n    print_buffer = curlx_mvaprintf(fmt, ap);\n    if(!print_buffer)\n      return;\n    len = strlen(print_buffer);\n    ptr = print_buffer;\n    while(len > 0) {\n      fputs(prefix, config->errors);\n      if(len > width) {\n        size_t cut = width-1;\n        while(!ISSPACE(ptr[cut]) && cut) {\n          cut--;\n        }\n        if(0 == cut)\n          cut = width-1;\n        (void)fwrite(ptr, cut + 1, 1, config->errors);\n        fputs(\"\\n\", config->errors);\n        ptr += cut + 1; \n        len -= cut;\n      }\n      else {\n        fputs(ptr, config->errors);\n        len = 0;\n      }\n    }\n    curl_free(print_buffer);\n  }\n}", "target": 1}
{"code": "size_t mobi_get_attribute_value(char *value, const unsigned char *data, const size_t size, const char *attribute, bool only_quoted) {\n    if (!data) {\n        debug_print(\"Data is null%s\", \"\\n\");\n        return SIZE_MAX;\n    }\n    size_t length = size;\n    size_t attr_length = strlen(attribute);\n    if (attr_length > MOBI_ATTRNAME_MAXSIZE) {\n        debug_print(\"Attribute too long: %zu\\n\", attr_length);\n        return SIZE_MAX;\n    }\n    char attr[MOBI_ATTRNAME_MAXSIZE + 2];\n    strcpy(attr, attribute);\n    strcat(attr, \"=\");\n    attr_length++;\n    if (size < attr_length) {\n        return SIZE_MAX;\n    }\n    unsigned char last_border = '\\0';\n    do {\n        if (*data == '<' || *data == '>') {\n            last_border = *data;\n        }\n        if (length > attr_length + 1 && memcmp(data, attr, attr_length) == 0) {\n            size_t offset = size - length;\n            if (last_border == '>') {\n                data += attr_length;\n                length -= attr_length - 1;\n                continue;\n            }\n            if (offset > 0) {\n                if (data[-1] != '<' && !isspace(data[-1])) {\n                    data += attr_length;\n                    length -= attr_length - 1;\n                    continue;\n                }\n            }\n            data += attr_length;\n            length -= attr_length;\n            unsigned char separator;\n            if (*data != '\\'' && *data != '\"') {\n                if (only_quoted) {\n                    continue;\n                }\n                separator = ' ';\n            } else {\n                separator = *data;\n                data++;\n                length--;\n            }\n            size_t j;\n            for (j = 0; j < MOBI_ATTRVALUE_MAXSIZE && length && *data != separator && *data != '>'; j++) {\n                *value++ = (char) *data++;\n                length--;\n            }\n            if (*(data - 1) == '/' && *data == '>') {\n                value--;\n            }\n            *value = '\\0';\n            return size - length - j;\n        }\n        data++;\n    } while (--length);\n    value[0] = '\\0';\n    return SIZE_MAX;\n}", "target": 1}
{"code": "static void Sp_split_regexp(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tint limit, len, k;\n\tconst char *p, *a, *b, *c, *e;\n\tResub m;\n\ttext = checkstring(J, 0);\n\tre = js_toregexp(J, 1);\n\tlimit = js_isdefined(J, 2) ? js_tointeger(J, 2) : 1 << 30;\n\tjs_newarray(J);\n\tlen = 0;\n\te = text + strlen(text);\n\tif (e == text) {\n\t\tif (js_regexec(re->prog, text, &m, 0)) {\n\t\t\tif (len == limit) return;\n\t\t\tjs_pushliteral(J, \"\");\n\t\t\tjs_setindex(J, -2, 0);\n\t\t}\n\t\treturn;\n\t}\n\tp = a = text;\n\twhile (a < e) {\n\t\tif (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n\t\t\tbreak; \n\t\tb = m.sub[0].sp;\n\t\tc = m.sub[0].ep;\n\t\tif (b == p) {\n\t\t\t++a;\n\t\t\tcontinue;\n\t\t}\n\t\tif (len == limit) return;\n\t\tjs_pushlstring(J, p, b - p);\n\t\tjs_setindex(J, -2, len++);\n\t\tfor (k = 1; k < m.nsub; ++k) {\n\t\t\tif (len == limit) return;\n\t\t\tjs_pushlstring(J, m.sub[k].sp, m.sub[k].ep - m.sub[k].sp);\n\t\t\tjs_setindex(J, -2, len++);\n\t\t}\n\t\ta = p = c;\n\t}\n\tif (len == limit) return;\n\tjs_pushstring(J, p);\n\tjs_setindex(J, -2, len);\n}", "target": 1}
{"code": "static int rawsock_create(struct net *net, struct socket *sock,\n\t\t\t  const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\tpr_debug(\"sock=%p\\n\", sock);\n\tif ((sock->type != SOCK_SEQPACKET) && (sock->type != SOCK_RAW))\n\t\treturn -ESOCKTNOSUPPORT;\n\tif (sock->type == SOCK_RAW)\n\t\tsock->ops = &rawsock_raw_ops;\n\telse\n\t\tsock->ops = &rawsock_ops;\n\tsk = sk_alloc(net, PF_NFC, GFP_ATOMIC, nfc_proto->proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\tsock_init_data(sock, sk);\n\tsk->sk_protocol = nfc_proto->id;\n\tsk->sk_destruct = rawsock_destruct;\n\tsock->state = SS_UNCONNECTED;\n\tif (sock->type == SOCK_RAW)\n\t\tnfc_sock_link(&raw_sk_list, sk);\n\telse {\n\t\tINIT_WORK(&nfc_rawsock(sk)->tx_work, rawsock_tx_work);\n\t\tnfc_rawsock(sk)->tx_work_scheduled = false;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "const char *string_of_NPPVariable(int variable)\n{\n  const char *str;\n  switch (variable) {\n#define _(VAL) case VAL: str = #VAL; break;\n\t_(NPPVpluginNameString);\n\t_(NPPVpluginDescriptionString);\n\t_(NPPVpluginWindowBool);\n\t_(NPPVpluginTransparentBool);\n\t_(NPPVjavaClass);\n\t_(NPPVpluginWindowSize);\n\t_(NPPVpluginTimerInterval);\n\t_(NPPVpluginScriptableInstance);\n\t_(NPPVpluginScriptableIID);\n\t_(NPPVjavascriptPushCallerBool);\n\t_(NPPVpluginKeepLibraryInMemory);\n\t_(NPPVpluginNeedsXEmbed);\n\t_(NPPVpluginScriptableNPObject);\n\t_(NPPVformValue);\n\t_(NPPVpluginUrlRequestsDisplayedBool);\n\t_(NPPVpluginWantsAllNetworkStreams);\n\t_(NPPVpluginNativeAccessibleAtkPlugId);\n\t_(NPPVpluginCancelSrcStream);\n\t_(NPPVSupportsAdvancedKeyHandling);\n#undef _\n  default:\n\tswitch (variable & 0xff) {\n#define _(VAL, VAR) case VAL: str = #VAR; break\n\t  _(10, NPPVpluginScriptableInstance);\n#undef _\n\tdefault:\n\t  str = \"<unknown variable>\";\n\t  break;\n\t}\n\tbreak;\n  }\n  return str;\n}", "target": 0}
{"code": "R_API int r_socket_block_time(RSocket *s, int block, int sec, int usec) {\n#if __UNIX__\n\tint ret, flags;\n#endif\n\tif (!s) {\n\t\treturn false;\n\t}\n#if __UNIX__\n\tflags = fcntl (s->fd, F_GETFL, 0);\n\tif (flags < 0) {\n\t\treturn false;\n\t}\n\tret = fcntl (s->fd, F_SETFL, block?\n\t\t\t(flags & ~O_NONBLOCK):\n\t\t\t(flags | O_NONBLOCK));\n\tif (ret < 0) {\n\t\treturn false;\n\t}\n#elif __WINDOWS__\n\tioctlsocket (s->fd, FIONBIO, (u_long FAR*)&block);\n#endif\n\tif (sec > 0 || usec > 0) {\n\t\tstruct timeval tv = {0};\n\t\ttv.tv_sec = sec;\n\t\ttv.tv_usec = usec;\n\t\tif (setsockopt (s->fd, SOL_SOCKET, SO_RCVTIMEO, (char *)&tv, sizeof (tv)) < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static bool set_reg_profile(RAnal *anal) {\n\tconst char *p =\n\t\t\"=PC\tpc\\n\"\n\t\t\"=SP\tr14\\n\" \n\t\t\"=BP\tsrp\\n\" \n\t\t\"=SN\tr0\\n\"\n\t\t\"=A0\tr0\\n\"\n\t\t\"=A1\tr1\\n\"\n\t\t\"=A2\tr2\\n\"\n\t\t\"=A3\tr3\\n\"\n\t\t\"gpr\tsp\t.32\t56\t0\\n\" \n\t\t\"gpr\tacr\t.32\t60\t0\\n\" \n\t\t\"gpr\tpc\t.32\t64\t0\\n\" \n\t\t\"gpr\tsrp\t.32\t68\t0\\n\" \n\t\t\"gpr\tr0\t.32\t0\t0\\n\"\n\t\t\"gpr\tr1\t.32\t4\t0\\n\"\n\t\t\"gpr\tr2\t.32\t8\t0\\n\"\n\t\t\"gpr\tr3\t.32\t12\t0\\n\"\n\t\t\"gpr\tr4\t.32\t16\t0\\n\"\n\t\t\"gpr\tr5\t.32\t20\t0\\n\"\n\t\t\"gpr\tr6\t.32\t24\t0\\n\"\n\t\t\"gpr\tr7\t.32\t28\t0\\n\"\n\t\t\"gpr\tr8\t.32\t32\t0\\n\"\n\t\t\"gpr\tr9\t.32\t36\t0\\n\"\n\t\t\"gpr\tr10\t.32\t40\t0\\n\"\n\t\t\"gpr\tr11\t.32\t44\t0\\n\"\n\t\t\"gpr\tr12\t.32\t48\t0\\n\"\n\t\t\"gpr\tr13\t.32\t52\t0\\n\"\n\t\t\"gpr\tr14\t.32\t56\t0\\n\"\n\t\t\"gpr\tr15\t.32\t60\t0\\n\"\n\t\t;\n\treturn r_reg_set_profile_string (anal->reg, p);\n}", "target": 0}
{"code": "bool capable_wrt_inode_uidgid(const struct inode *inode, int cap)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\treturn ns_capable(ns, cap) && kuid_has_mapping(ns, inode->i_uid) &&\n\t\tkgid_has_mapping(ns, inode->i_gid);\n}", "target": 0}
{"code": "static int handle_interrupt_window(struct kvm_vcpu *vcpu)\n{\n\tu32 cpu_based_vm_exec_control;\n\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tcpu_based_vm_exec_control &= ~CPU_BASED_VIRTUAL_INTR_PENDING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t++vcpu->stat.irq_window_exits;\n\tif (!irqchip_in_kernel(vcpu->kvm) &&\n\t    vcpu->run->request_interrupt_window &&\n\t    !kvm_cpu_has_interrupt(vcpu)) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_IRQ_WINDOW_OPEN;\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "static int dccp_v6_send_response(const struct sock *sk, struct request_sock *req)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sk_buff *skb;\n\tstruct in6_addr *final_p, final;\n\tstruct flowi6 fl6;\n\tint err = -1;\n\tstruct dst_entry *dst;\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_proto = IPPROTO_DCCP;\n\tfl6.daddr = ireq->ir_v6_rmt_addr;\n\tfl6.saddr = ireq->ir_v6_loc_addr;\n\tfl6.flowlabel = 0;\n\tfl6.flowi6_oif = ireq->ir_iif;\n\tfl6.fl6_dport = ireq->ir_rmt_port;\n\tfl6.fl6_sport = htons(ireq->ir_num);\n\tsecurity_req_classify_flow(req, flowi6_to_flowi(&fl6));\n\tfinal_p = fl6_update_dst(&fl6, np->opt, &final);\n\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tdst = NULL;\n\t\tgoto done;\n\t}\n\tskb = dccp_make_response(sk, dst, req);\n\tif (skb != NULL) {\n\t\tstruct dccp_hdr *dh = dccp_hdr(skb);\n\t\tdh->dccph_checksum = dccp_v6_csum_finish(skb,\n\t\t\t\t\t\t\t &ireq->ir_v6_loc_addr,\n\t\t\t\t\t\t\t &ireq->ir_v6_rmt_addr);\n\t\tfl6.daddr = ireq->ir_v6_rmt_addr;\n\t\terr = ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);\n\t\terr = net_xmit_eval(err);\n\t}\ndone:\n\tdst_release(dst);\n\treturn err;\n}", "target": 1}
{"code": "NOEXPORT void cb_new_auth(void *parent, void *ptr, CRYPTO_EX_DATA *ad,\n        int idx, long argl, void *argp) {\n    (void)parent; \n    (void)ptr; \n    (void)argl; \n    s_log(LOG_DEBUG, \"Initializing application specific data for %s\",\n        (char *)argp);\n    if(!CRYPTO_set_ex_data(ad, idx, (void *)(-1)))\n        sslerror(\"CRYPTO_set_ex_data\");\n}", "target": 0}
{"code": "static void test_on_link_flow_on(void* context)\n{\n    (void)context;\n}", "target": 0}
{"code": "void bnep_net_setup(struct net_device *dev)\n{\n\tmemset(dev->broadcast, 0xff, ETH_ALEN);\n\tdev->addr_len = ETH_ALEN;\n\tether_setup(dev);\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tdev->netdev_ops = &bnep_netdev_ops;\n\tdev->watchdog_timeo  = HZ * 2;\n}", "target": 0}
{"code": "njs_function_prototype_apply(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    int64_t         i, length;\n    njs_int_t       ret;\n    njs_frame_t     *frame;\n    njs_value_t     *this, *arr_like;\n    njs_array_t     *arr;\n    njs_function_t  *func;\n    if (!njs_is_function(njs_argument(args, 0))) {\n        njs_type_error(vm, \"\\\"this\\\" argument is not a function\");\n        return NJS_ERROR;\n    }\n    func = njs_function(njs_argument(args, 0));\n    this = njs_arg(args, nargs, 1);\n    arr_like = njs_arg(args, nargs, 2);\n    if (njs_is_null_or_undefined(arr_like)) {\n        length = 0;\n        goto activate;\n    } else if (njs_is_array(arr_like)) {\n        arr = arr_like->data.u.array;\n        args = arr->start;\n        length = arr->length;\n        goto activate;\n    } else if (njs_slow_path(!njs_is_object(arr_like))) {\n        njs_type_error(vm, \"second argument is not an array-like object\");\n        return NJS_ERROR;\n    }\n    ret = njs_object_length(vm, arr_like, &length);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    arr = njs_array_alloc(vm, 1, length, NJS_ARRAY_SPARE);\n    if (njs_slow_path(arr == NULL)) {\n        return NJS_ERROR;\n    }\n    args = arr->start;\n    for (i = 0; i < length; i++) {\n        ret = njs_value_property_i64(vm, arr_like, i, &args[i]);\n        if (njs_slow_path(ret == NJS_ERROR)) {\n            return ret;\n        }\n    }\nactivate:\n    vm->top_frame->skip = 1;\n    frame = (njs_frame_t *) vm->top_frame;\n    ret = njs_function_frame(vm, func, this, args, length, 0);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    ret = njs_function_frame_invoke(vm, frame->native.retval);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    return NJS_DECLINED;\n}", "target": 1}
{"code": "get_number(int *numptr, int low, const char *names[], int ch, FILE *file,\n    const char *terms) {\n\tchar temp[MAX_TEMPSTR], *pc;\n\tint len, i;\n\tpc = temp;\n\tlen = 0;\n\twhile (isdigit((unsigned char)ch)) {\n\t\tif (++len >= MAX_TEMPSTR)\n\t\t\tgoto bad;\n\t\t*pc++ = ch;\n\t\tch = get_char(file);\n\t}\n\t*pc = '\\0';\n\tif (len != 0) {\n\t\tif (!strchr(terms, ch))\n\t\t\tgoto bad;\n\t\t*numptr = atoi(temp);\n\t\treturn (ch);\n\t}\n\tif (names) {\n\t\twhile (isalpha((unsigned char)ch)) {\n\t\t\tif (++len >= MAX_TEMPSTR)\n\t\t\t\tgoto bad;\n\t\t\t*pc++ = ch;\n\t\t\tch = get_char(file);\n\t\t}\n\t\t*pc = '\\0';\n\t\tif (len != 0 && strchr(terms, ch)) {\n\t\t\tfor (i = 0;  names[i] != NULL;  i++) {\n\t\t\t\tDebug(DPARS|DEXT,\n\t\t\t\t\t(\"get_num, compare(%s,%s)\\n\", names[i],\n\t\t\t\t\ttemp))\n\t\t\t\tif (!strcasecmp(names[i], temp)) {\n\t\t\t\t\t*numptr = i+low;\n\t\t\t\t\treturn (ch);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nbad:\n\tunget_char(ch, file);\n\treturn (EOF);\n}", "target": 1}
{"code": "bool CoinSpend::HasValidSerial() const\n{\n\treturn coinSerialNumber > 0 && coinSerialNumber < params->coinCommitmentGroup.groupOrder;\n}", "target": 0}
{"code": "cib_recv_plaintext(int sock)\n{\n    char *buf = NULL;\n    ssize_t rc = 0;\n    ssize_t len = 0;\n    ssize_t chunk_size = 512;\n    buf = calloc(1, chunk_size);\n    while (1) {\n        errno = 0;\n        rc = read(sock, buf + len, chunk_size);\n        crm_trace(\"Got %d more bytes. errno=%d\", (int)rc, errno);\n        if (errno == EINTR || errno == EAGAIN) {\n            crm_trace(\"Retry: %d\", (int)rc);\n            if (rc > 0) {\n                len += rc;\n                buf = realloc(buf, len + chunk_size);\n                CRM_ASSERT(buf != NULL);\n            }\n        } else if (rc < 0) {\n            crm_perror(LOG_ERR, \"Error receiving message: %d\", (int)rc);\n            goto bail;\n        } else if (rc == chunk_size) {\n            len += rc;\n            chunk_size *= 2;\n            buf = realloc(buf, len + chunk_size);\n            crm_trace(\"Retry with %d more bytes\", (int)chunk_size);\n            CRM_ASSERT(buf != NULL);\n        } else if (buf[len + rc - 1] != 0) {\n            crm_trace(\"Last char is %d '%c'\", buf[len + rc - 1], buf[len + rc - 1]);\n            crm_trace(\"Retry with %d more bytes\", (int)chunk_size);\n            len += rc;\n            buf = realloc(buf, len + chunk_size);\n            CRM_ASSERT(buf != NULL);\n        } else {\n            return buf;\n        }\n    }\n  bail:\n    free(buf);\n    return NULL;\n}", "target": 1}
{"code": "int nfc_llcp_set_remote_gb(struct nfc_dev *dev, const u8 *gb, u8 gb_len)\n{\n\tstruct nfc_llcp_local *local;\n\tif (gb_len < 3 || gb_len > NFC_MAX_GT_LEN)\n\t\treturn -EINVAL;\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tpr_err(\"No LLCP device\\n\");\n\t\treturn -ENODEV;\n\t}\n\tmemset(local->remote_gb, 0, NFC_MAX_GT_LEN);\n\tmemcpy(local->remote_gb, gb, gb_len);\n\tlocal->remote_gb_len = gb_len;\n\tif (memcmp(local->remote_gb, llcp_magic, 3)) {\n\t\tpr_err(\"MAC does not support LLCP\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn nfc_llcp_parse_gb_tlv(local,\n\t\t\t\t     &local->remote_gb[3],\n\t\t\t\t     local->remote_gb_len - 3);\n}", "target": 1}
{"code": "struct tcp_conn_t *tcp_conn_accept(struct tcp_sock_t *sock)\n{\n\tstruct tcp_conn_t *conn = calloc(1, sizeof *conn);\n\tif (conn == NULL) {\n\t\tERR(\"Calloc for connection struct failed\");\n\t\tgoto error;\n\t}\n\tconn->sd = accept(sock->sd, NULL, NULL);\n\tif (conn->sd < 0) {\n\t\tERR(\"accept failed\");\n\t\tgoto error;\n\t}\n\treturn conn;\nerror:\n\tif (conn != NULL)\n\t\tfree(conn);\n\treturn NULL;\n}", "target": 1}
{"code": "static inline uint16_t ok_inflater_can_write_total(const ok_inflater *inflater) {\n    return inflater->buffer_start_pos - inflater->buffer_end_pos - 1;\n}", "target": 0}
{"code": "static void handle_external_interrupt_irqoff(struct kvm_vcpu *vcpu)\n{\n\tu32 intr_info = vmx_get_intr_info(vcpu);\n\tunsigned int vector = intr_info & INTR_INFO_VECTOR_MASK;\n\tgate_desc *desc = (gate_desc *)host_idt_base + vector;\n\tif (KVM_BUG(!is_external_intr(intr_info), vcpu->kvm,\n\t    \"KVM: unexpected VM-Exit interrupt info: 0x%x\", intr_info))\n\t\treturn;\n\thandle_interrupt_nmi_irqoff(vcpu, gate_offset(desc));\n\tvcpu->arch.at_instruction_boundary = true;\n}", "target": 0}
{"code": "ZEND_API int zend_declare_property(zend_class_entry *ce, const char *name, int name_length, zval *property, int access_type TSRMLS_DC) \n{\n\treturn zend_declare_property_ex(ce, name, name_length, property, access_type, NULL, 0 TSRMLS_CC);\n}", "target": 0}
{"code": "int BUFFER_append_build(BUFFER_HANDLE handle, const unsigned char* source, size_t size)\n{\n    int result;\n    if (handle == NULL || source == NULL || size == 0)\n    {\n        LogError(\"BUFFER_append_build failed invalid parameter handle: %p, source: %p, size: %lu\", handle, source, (unsigned long)size);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        if (handle->buffer == NULL)\n        {\n            if (BUFFER_safemalloc(handle, size) != 0 || handle->buffer == NULL)\n            {\n                LogError(\"Failure with BUFFER_safemalloc\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                (void)memcpy(handle->buffer, source, size);\n                result = 0;\n            }\n        }\n        else\n        {\n            unsigned char* temp = (unsigned char*)realloc(handle->buffer, handle->size + size);\n            if (temp == NULL)\n            {\n                LogError(\"Failure reallocating temporary buffer\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                handle->buffer = temp;\n                (void)memcpy(&handle->buffer[handle->size], source, size);\n                handle->size += size;\n                result = 0;\n            }\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "inline uint char_val(char X)\n{\n  return (uint) (X >= '0' && X <= '9' ? X-'0' :\n\t\t X >= 'A' && X <= 'Z' ? X-'A'+10 :\n\t\t X-'a'+10);\n}", "target": 0}
{"code": "ff_layout_choose_valid_ds_for_read(struct pnfs_layout_segment *lseg,\n\t\t\t\t   u32 start_idx, u32 *best_idx)\n{\n\treturn ff_layout_choose_ds_for_read(lseg, start_idx, best_idx, true);\n}", "target": 0}
{"code": "String StringUtil::Implode(const Variant& items, const String& delim,\n                           const bool checkIsContainer ) {\n  if (checkIsContainer && !isContainer(items)) {\n    throw_param_is_not_container();\n  }\n  int size = getContainerSize(items);\n  if (size == 0) return empty_string();\n  req::vector<String> sitems;\n  sitems.reserve(size);\n  int len = 0;\n  int lenDelim = delim.size();\n  for (ArrayIter iter(items); iter; ++iter) {\n    sitems.emplace_back(iter.second().toString());\n    len += sitems.back().size() + lenDelim;\n  }\n  len -= lenDelim; \n  assert(sitems.size() == size);\n  String s = String(len, ReserveString);\n  char *buffer = s.mutableData();\n  const char *sdelim = delim.data();\n  char *p = buffer;\n  String &init_str = sitems[0];\n  int init_len = init_str.size();\n  memcpy(p, init_str.data(), init_len);\n  p += init_len;\n  for (int i = 1; i < size; i++) {\n    String &item = sitems[i];\n    memcpy(p, sdelim, lenDelim);\n    p += lenDelim;\n    int lenItem = item.size();\n    memcpy(p, item.data(), lenItem);\n    p += lenItem;\n  }\n  assert(p - buffer == len);\n  s.setSize(len);\n  return s;\n}", "target": 1}
{"code": "is_apple_double (const char *name)\n{\n\tchar *basename;\n\tgboolean ret = FALSE;\n\tbasename = g_path_get_basename (name);\n\tif (basename == NULL) {\n\t\tg_debug (\"Filename '%s' doesn't have a basename?\", name);\n\t\treturn ret;\n\t}\n\tret = g_str_has_prefix (basename, APPLE_DOUBLE_PREFIX);\n\tg_free (basename);\n\treturn ret;\n}", "target": 0}
{"code": "int expand_downwards(struct vm_area_struct *vma,\n\t\t\t\t   unsigned long address)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tstruct vm_area_struct *prev;\n\tint error;\n\taddress &= PAGE_MASK;\n\terror = security_mmap_addr(address);\n\tif (error)\n\t\treturn error;\n\tprev = vma->vm_prev;\n\tif (prev && !(prev->vm_flags & VM_GROWSDOWN) &&\n\t\t\t(prev->vm_flags & (VM_WRITE|VM_READ|VM_EXEC))) {\n\t\tif (address - prev->vm_end < stack_guard_gap)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\treturn -ENOMEM;\n\tanon_vma_lock_write(vma->anon_vma);\n\tif (address < vma->vm_start) {\n\t\tunsigned long size, grow;\n\t\tsize = vma->vm_end - address;\n\t\tgrow = (vma->vm_start - address) >> PAGE_SHIFT;\n\t\terror = -ENOMEM;\n\t\tif (grow <= vma->vm_pgoff) {\n\t\t\terror = acct_stack_growth(vma, size, grow);\n\t\t\tif (!error) {\n\t\t\t\tspin_lock(&mm->page_table_lock);\n\t\t\t\tif (vma->vm_flags & VM_LOCKED)\n\t\t\t\t\tmm->locked_vm += grow;\n\t\t\t\tvm_stat_account(mm, vma->vm_flags, grow);\n\t\t\t\tanon_vma_interval_tree_pre_update_vma(vma);\n\t\t\t\tvma->vm_start = address;\n\t\t\t\tvma->vm_pgoff -= grow;\n\t\t\t\tanon_vma_interval_tree_post_update_vma(vma);\n\t\t\t\tvma_gap_update(vma);\n\t\t\t\tspin_unlock(&mm->page_table_lock);\n\t\t\t\tperf_event_mmap(vma);\n\t\t\t}\n\t\t}\n\t}\n\tanon_vma_unlock_write(vma->anon_vma);\n\tkhugepaged_enter_vma_merge(vma, vma->vm_flags);\n\tvalidate_mm(mm);\n\treturn error;\n}", "target": 1}
{"code": "static int asn1_find_indefinite_length(const unsigned char *data, size_t datalen,\n\t\t\t\t       size_t *_dp, size_t *_len,\n\t\t\t\t       const char **_errmsg)\n{\n\tunsigned char tag, tmp;\n\tsize_t dp = *_dp, len, n;\n\tint indef_level = 1;\nnext_tag:\n\tif (unlikely(datalen - dp < 2)) {\n\t\tif (datalen == dp)\n\t\t\tgoto missing_eoc;\n\t\tgoto data_overrun_error;\n\t}\n\ttag = data[dp++];\n\tif (tag == 0) {\n\t\tif (data[dp++] != 0)\n\t\t\tgoto invalid_eoc;\n\t\tif (--indef_level <= 0) {\n\t\t\t*_len = dp - *_dp;\n\t\t\t*_dp = dp;\n\t\t\treturn 0;\n\t\t}\n\t\tgoto next_tag;\n\t}\n\tif (unlikely((tag & 0x1f) == ASN1_LONG_TAG)) {\n\t\tdo {\n\t\t\tif (unlikely(datalen - dp < 2))\n\t\t\t\tgoto data_overrun_error;\n\t\t\ttmp = data[dp++];\n\t\t} while (tmp & 0x80);\n\t}\n\tlen = data[dp++];\n\tif (len <= 0x7f) {\n\t\tdp += len;\n\t\tgoto next_tag;\n\t}\n\tif (unlikely(len == ASN1_INDEFINITE_LENGTH)) {\n\t\tif (unlikely((tag & ASN1_CONS_BIT) == ASN1_PRIM << 5))\n\t\t\tgoto indefinite_len_primitive;\n\t\tindef_level++;\n\t\tgoto next_tag;\n\t}\n\tn = len - 0x80;\n\tif (unlikely(n > sizeof(size_t) - 1))\n\t\tgoto length_too_long;\n\tif (unlikely(n > datalen - dp))\n\t\tgoto data_overrun_error;\n\tfor (len = 0; n > 0; n--) {\n\t\tlen <<= 8;\n\t\tlen |= data[dp++];\n\t}\n\tdp += len;\n\tgoto next_tag;\nlength_too_long:\n\t*_errmsg = \"Unsupported length\";\n\tgoto error;\nindefinite_len_primitive:\n\t*_errmsg = \"Indefinite len primitive not permitted\";\n\tgoto error;\ninvalid_eoc:\n\t*_errmsg = \"Invalid length EOC\";\n\tgoto error;\ndata_overrun_error:\n\t*_errmsg = \"Data overrun error\";\n\tgoto error;\nmissing_eoc:\n\t*_errmsg = \"Missing EOC in indefinite len cons\";\nerror:\n\t*_dp = dp;\n\treturn -1;\n}", "target": 1}
{"code": "static void print_primaries(WriterContext *w, enum AVColorPrimaries color_primaries)\n{\n    const char *val = av_color_primaries_name(color_primaries);\n    if (!val || color_primaries == AVCOL_PRI_UNSPECIFIED) {\n        print_str_opt(\"color_primaries\", \"unknown\");\n    } else {\n        print_str(\"color_primaries\", val);\n    }\n}", "target": 0}
{"code": "clamp_indexed(const fz_colorspace *cs, const float *in, float *out)\n{\n\tstruct indexed *idx = cs->data;\n\t*out = fz_clamp(*in, 0, idx->high) / 255.0f; \n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, MergeSortReverseSubtreeContainedOr) {\n    addIndex(BSON(\"a\" << 1 << \"e\" << 1));\n    addIndex(BSON(\"c\" << 1 << \"e\" << -1));\n    addIndex(BSON(\"d\" << 1 << \"e\" << -1));\n    runQueryAsCommand(fromjson(\n        \"{find: 'testns', filter: {$or: [{a: 1}, {b: 1, $or: [{c: 1}, {d: 1}]}]}, sort: {e: 1}}\"));\n    assertNumSolutions(2U);\n    assertSolutionExists(\n        \"{sort: {pattern: {e: 1}, limit: 0, node: {sortKeyGen: {node: \"\n        \"{cscan: {dir: 1}}}}}}\");\n    assertSolutionExists(\n        \"{fetch: {node: {mergeSort: {nodes: \"\n        \"[{ixscan: {pattern: {a: 1, e: 1}, dir: 1}}, {fetch: {node: {mergeSort: {nodes: \"\n        \"[{ixscan: {pattern: {c: 1, e: -1}, dir: -1}}, {ixscan: {pattern: {d: 1, e: -1}, dir: \"\n        \"-1}}]}}}}]}}}}\");\n}", "target": 0}
{"code": "void AuthenticationFeature::validateOptions(std::shared_ptr<ProgramOptions> options) {\n  if (!_jwtSecretKeyfileProgramOption.empty() && !_jwtSecretFolderProgramOption.empty()) {\n    LOG_TOPIC(\"d3515\", FATAL, Logger::STARTUP)\n        << \"please specify either '--server.jwt-\"\n           \"secret-keyfile' or '--server.jwt-secret-folder' but not both.\";\n    FATAL_ERROR_EXIT();\n  }\n  if (!_jwtSecretKeyfileProgramOption.empty() || !_jwtSecretFolderProgramOption.empty()) {\n    Result res = loadJwtSecretsFromFile();\n    if (res.fail()) {\n      LOG_TOPIC(\"d3617\", FATAL, Logger::STARTUP) << res.errorMessage();\n      FATAL_ERROR_EXIT();\n    }\n  }\n  if (!_jwtSecretProgramOption.empty()) {\n    if (_jwtSecretProgramOption.length() > _maxSecretLength) {\n      LOG_TOPIC(\"9abfc\", FATAL, arangodb::Logger::STARTUP)\n          << \"Given JWT secret too long. Max length is \" << _maxSecretLength;\n      FATAL_ERROR_EXIT();\n    }\n  }\n  if (_sessionTimeout <= 1.0) {\n    LOG_TOPIC(\"85046\", FATAL, arangodb::Logger::AUTHENTICATION)\n        << \"--server.session-timeout has an invalid value: \" << _sessionTimeout;\n    FATAL_ERROR_EXIT();\n  }\n  if (options->processingResult().touched(\"server.jwt-secret\")) {\n    LOG_TOPIC(\"1aaae\", WARN, arangodb::Logger::AUTHENTICATION)\n        << \"--server.jwt-secret is insecure. Use --server.jwt-secret-keyfile \"\n           \"instead.\";\n  }\n}", "target": 0}
{"code": "goto_tabpage_tp(\n    tabpage_T\t*tp,\n    int\t\ttrigger_enter_autocmds,\n    int\t\ttrigger_leave_autocmds)\n{\n    set_keep_msg(NULL, 0);\n    if (tp != curtab && leave_tabpage(tp->tp_curwin->w_buffer,\n\t\t\t\t\ttrigger_leave_autocmds) == OK)\n    {\n\tif (valid_tabpage(tp))\n\t    enter_tabpage(tp, curbuf, trigger_enter_autocmds,\n\t\t    trigger_leave_autocmds);\n\telse\n\t    enter_tabpage(curtab, curbuf, trigger_enter_autocmds,\n\t\t    trigger_leave_autocmds);\n    }\n}", "target": 0}
{"code": "njs_promise_perform_all_settled_handler(njs_vm_t *vm, njs_iterator_args_t *args,\n    njs_value_t *value, int64_t index)\n{\n    njs_int_t                    ret;\n    njs_array_t                  *array;\n    njs_value_t                  arguments[2], next;\n    njs_function_t               *on_fulfilled, *on_rejected;\n    njs_promise_capability_t     *capability;\n    njs_promise_all_context_t    *context;\n    njs_promise_iterator_args_t  *pargs;\n    if (!njs_is_valid(value)) {\n        value = njs_value_arg(&njs_value_undefined);\n    }\n    pargs = (njs_promise_iterator_args_t *) args;\n    capability = pargs->capability;\n    array = args->data;\n    njs_set_undefined(&array->start[index]);\n    ret = njs_function_call(vm, pargs->function, pargs->constructor, value,\n                            1, &next);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n    on_fulfilled = njs_promise_create_function(vm,\n                                            sizeof(njs_promise_all_context_t));\n    if (njs_slow_path(on_fulfilled == NULL)) {\n        return NJS_ERROR;\n    }\n    context = on_fulfilled->context;\n    context->already_called = 0;\n    context->index = (uint32_t) index;\n    context->values = pargs->args.data;\n    context->capability = capability;\n    context->remaining_elements = pargs->remaining;\n    on_rejected = njs_promise_create_function(vm, 0);\n    if (njs_slow_path(on_rejected == NULL)) {\n        return NJS_ERROR;\n    }\n    on_fulfilled->u.native = njs_promise_all_settled_element_functions;\n    on_rejected->u.native = njs_promise_all_settled_element_functions;\n    on_rejected->magic8 = 1; \n    on_fulfilled->args_count = 1;\n    on_rejected->args_count = 1;\n    on_rejected->context = context;\n    (*pargs->remaining)++;\n    njs_set_function(&arguments[0], on_fulfilled);\n    njs_set_function(&arguments[1], on_rejected);\n    ret = njs_promise_invoke_then(vm, &next, arguments, 2);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n    return NJS_OK;\n}", "target": 0}
{"code": "EXPORTED const char *dlist_reserve_path(const char *part, int isarchive,\n                                        const struct message_guid *guid)\n{\n    static char buf[MAX_MAILBOX_PATH];\n    const char *base;\n    if (strchr(part, '/')) {\n        base = part;\n    }\n    else {\n        base = isarchive ? config_archivepartitiondir(part)\n                         : config_partitiondir(part);\n    }\n    assert(base != NULL);\n    snprintf(buf, MAX_MAILBOX_PATH, \"%s/sync./%lu/%s\",\n                  base, (unsigned long)getpid(),\n                  message_guid_encode(guid));\n    if (cyrus_mkdir(buf, 0755)) {\n        syslog(LOG_ERR, \"IOERROR: failed to create %s/sync./%lu/ for reserve: %m\",\n                        base, (unsigned long)getpid());\n    }\n    return buf;\n}", "target": 1}
{"code": "static void kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     struct kvm_debugregs *dbgregs)\n{\n\tunsigned long val;\n\tmemcpy(dbgregs->db, vcpu->arch.db, sizeof(vcpu->arch.db));\n\tkvm_get_dr(vcpu, 6, &val);\n\tdbgregs->dr6 = val;\n\tdbgregs->dr7 = vcpu->arch.dr7;\n\tdbgregs->flags = 0;\n\tmemset(&dbgregs->reserved, 0, sizeof(dbgregs->reserved));\n}", "target": 1}
{"code": "    bool IsLoaded() {return Loaded;}", "target": 0}
{"code": "static void inet6_net_exit(struct net *net)\n{\n#ifdef CONFIG_PROC_FS\n\tudp6_proc_exit(net);\n\ttcp6_proc_exit(net);\n\tac6_proc_exit(net);\n#endif\n}", "target": 0}
{"code": "u8 *nfc_llcp_general_bytes(struct nfc_dev *dev, size_t *general_bytes_len)\n{\n\tstruct nfc_llcp_local *local;\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\t*general_bytes_len = 0;\n\t\treturn NULL;\n\t}\n\tnfc_llcp_build_gb(local);\n\t*general_bytes_len = local->gb_len;\n\tnfc_llcp_local_put(local);\n\treturn local->gb;\n}", "target": 0}
{"code": "GF_Err gf_isom_get_media_time(GF_ISOFile *the_file, u32 trackNumber, u32 movieTime, u64 *MediaTime)\n{\n\tGF_TrackBox *trak;\n\tu8 useEdit;\n\ts64 SegmentStartTime, mediaOffset;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !MediaTime) return GF_BAD_PARAM;\n\tSegmentStartTime = 0;\n\treturn GetMediaTime(trak, GF_FALSE, movieTime, MediaTime, &SegmentStartTime, &mediaOffset, &useEdit, NULL);\n}", "target": 0}
{"code": "static int decode_dds1(GetByteContext *gb, uint8_t *frame, int width, int height)\n{\n    const uint8_t *frame_start = frame;\n    const uint8_t *frame_end   = frame + width * height;\n    int mask = 0x10000, bitbuf = 0;\n    int i, v, offset, count, segments;\n    segments = bytestream2_get_le16(gb);\n    while (segments--) {\n        if (bytestream2_get_bytes_left(gb) < 2)\n            return AVERROR_INVALIDDATA;\n        if (mask == 0x10000) {\n            bitbuf = bytestream2_get_le16u(gb);\n            mask = 1;\n        }\n        if (bitbuf & mask) {\n            v = bytestream2_get_le16(gb);\n            offset = (v & 0x1FFF) << 2;\n            count = ((v >> 13) + 2) << 1;\n            if (frame - frame_start < offset || frame_end - frame < count*2 + width)\n                return AVERROR_INVALIDDATA;\n            for (i = 0; i < count; i++) {\n                frame[0] = frame[1] =\n                frame[width] = frame[width + 1] = frame[-offset];\n                frame += 2;\n            }\n        } else if (bitbuf & (mask << 1)) {\n            v = bytestream2_get_le16(gb)*2;\n            if (frame - frame_end < v)\n                return AVERROR_INVALIDDATA;\n            frame += v;\n        } else {\n            if (frame_end - frame < width + 3)\n                return AVERROR_INVALIDDATA;\n            frame[0] = frame[1] =\n            frame[width] = frame[width + 1] =  bytestream2_get_byte(gb);\n            frame += 2;\n            frame[0] = frame[1] =\n            frame[width] = frame[width + 1] =  bytestream2_get_byte(gb);\n            frame += 2;\n        }\n        mask <<= 2;\n    }\n    return 0;\n}", "target": 1}
{"code": "static void* my_gballoc_malloc(size_t size)\n{\n    return malloc(size);\n}", "target": 0}
{"code": "void APE::Properties::analyzeCurrent()\n{\n  d->file->seek(2, File::Current);\n  ByteVector descriptor = d->file->readBlock(44);\n  uint descriptorBytes = descriptor.mid(0,4).toUInt(false);\n  if ((descriptorBytes - 52) > 0)\n    d->file->seek(descriptorBytes - 52, File::Current);\n  ByteVector header = d->file->readBlock(24);\n  d->channels = header.mid(18, 2).toShort(false);\n  d->sampleRate = header.mid(20, 4).toUInt(false);\n  d->bitsPerSample = header.mid(16, 2).toShort(false);\n  uint totalFrames = header.mid(12, 4).toUInt(false);\n  uint blocksPerFrame = header.mid(4, 4).toUInt(false);\n  uint finalFrameBlocks = header.mid(8, 4).toUInt(false);\n  uint totalBlocks = totalFrames > 0 ? (totalFrames -  1) * blocksPerFrame + finalFrameBlocks : 0;\n  d->length = totalBlocks / d->sampleRate;\n  d->bitrate = d->length > 0 ? ((d->streamLength * 8L) / d->length) / 1000 : 0;\n}", "target": 1}
{"code": "bool_t xdr_nullstring(XDR *xdrs, char **objp)\n{\n     u_int size;\n     if (xdrs->x_op == XDR_ENCODE) {\n\t  if (*objp == NULL)\n\t       size = 0;\n\t  else\n\t       size = strlen(*objp) + 1;\n     }\n     if (! xdr_u_int(xdrs, &size)) {\n\t  return FALSE;\n\t}\n     switch (xdrs->x_op) {\n     case XDR_DECODE:\n\t  if (size == 0) {\n\t       *objp = NULL;\n\t       return TRUE;\n\t  } else if (*objp == NULL) {\n\t       *objp = (char *) mem_alloc(size);\n\t       if (*objp == NULL) {\n\t\t    errno = ENOMEM;\n\t\t    return FALSE;\n\t       }\n\t  }\n\t  return (xdr_opaque(xdrs, *objp, size));\n     case XDR_ENCODE:\n\t  if (size != 0)\n\t       return (xdr_opaque(xdrs, *objp, size));\n\t  return TRUE;\n     case XDR_FREE:\n\t  if (*objp != NULL)\n\t       mem_free(*objp, size);\n\t  *objp = NULL;\n\t  return TRUE;\n     }\n     return FALSE;\n}", "target": 1}
{"code": "static Jsi_RC jsi_ArrayShiftCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    Jsi_Value *v;\n    Jsi_Obj *obj = _this->d.obj;\n    Jsi_ObjListifyArray(interp, obj);\n    uint n = Jsi_ObjGetLength(interp, obj);\n    assert(n <= obj->arrCnt);\n    if (n<=0) {\n        Jsi_ValueMakeUndef(interp, ret);\n    } else {\n        n--;\n        v = obj->arr[0];\n        memmove(obj->arr, obj->arr+1, n*sizeof(Jsi_Value*));\n        obj->arr[n] = NULL;\n        Jsi_ValueDup2(interp, ret, v);\n        Jsi_DecrRefCount(interp, v);\n        Jsi_ObjSetLength(interp, obj, n);\n    }\n    return JSI_OK;\n}", "target": 1}
{"code": "  static void launch(OpKernelContext* context, const PoolParameters& params,\n                     const Tensor& grad_in, const Tensor& argmax,\n                     Tensor* grad_out, const bool include_batch_in_index) {\n    const DeviceBase::CpuWorkerThreads& worker_threads =\n        *(context->device()->tensorflow_cpu_worker_threads());\n    auto shard = [&grad_in, &argmax, &grad_out, include_batch_in_index](\n                     int64 start, int64 limit) {\n      const int64 batch_size =\n          GetTensorDim(grad_out->shape(), FORMAT_NHWC, 'N');\n      const int64 output_size_per_batch = grad_out->NumElements() / batch_size;\n      const int64 input_size_per_batch = grad_in.NumElements() / batch_size;\n      {\n        auto grad_out_flat = grad_out->flat<T>();\n        auto argmax_flat = argmax.flat<int64>();\n        auto grad_in_flat = grad_in.flat<T>();\n        const int64 output_start = start * output_size_per_batch;\n        const int64 output_end = limit * output_size_per_batch;\n        EigenMatrixMap inputShard(grad_out_flat.data() + output_start, 1,\n                                  output_end - output_start);\n        inputShard.setConstant(T(0));\n        const int input_start = start * input_size_per_batch;\n        const int input_end = limit * input_size_per_batch;\n        for (int64 index = input_start; index < input_end; index++) {\n          if (index >= argmax.NumElements()) {\n            break;\n          }\n          int64 grad_out_index = argmax_flat(index);\n          if (!include_batch_in_index) {\n            const int64 cur_batch = index / input_size_per_batch;\n            grad_out_index += cur_batch * output_size_per_batch;\n          }\n          CHECK(grad_out_index >= output_start && grad_out_index < output_end)\n              << \"Invalid output gradient index: \" << grad_out_index << \", \"\n              << output_start << \", \" << output_end;\n          grad_out_flat(grad_out_index) += grad_in_flat(index);\n        }\n      }\n    };\n    const int64 batch_size = GetTensorDim(grad_out->shape(), FORMAT_NHWC, 'N');\n    const int64 shard_cost = grad_out->NumElements() / batch_size;\n    Shard(worker_threads.num_threads, worker_threads.workers, batch_size,\n          shard_cost, shard);\n  }", "target": 0}
{"code": "static unsigned int get_exif_ui16(struct iw_exif_state *e, unsigned int pos)\n{\n\tif(e->d_len<2 || pos>e->d_len-2) return 0;\n\treturn iw_get_ui16_e(&e->d[pos], e->endian);\n}", "target": 0}
{"code": "void RootWindowHostLinux::ShowCursor(bool show) {\n  if (show == cursor_shown_)\n    return;\n  cursor_shown_ = show;\n  SetCursorInternal(show ? current_cursor_ : ui::kCursorNone);\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::ClearDisplayedGraphics() {\n  NotifyNewContentRenderingTimeoutForTesting();\n  if (view_)\n    view_->ClearCompositorFrame();\n}", "target": 0}
{"code": "int nfc_llcp_send_symm(struct nfc_dev *dev)\n{\n\tstruct sk_buff *skb;\n\tstruct nfc_llcp_local *local;\n\tu16 size = 0;\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\tsize += LLCP_HEADER_SIZE;\n\tsize += dev->tx_headroom + dev->tx_tailroom + NFC_HEADER_SIZE;\n\tskb = alloc_skb(size, GFP_KERNEL);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\tskb_reserve(skb, dev->tx_headroom + NFC_HEADER_SIZE);\n\tskb = llcp_add_header(skb, 0, 0, LLCP_PDU_SYMM);\n\t__net_timestamp(skb);\n\tnfc_llcp_send_to_raw_sock(local, skb, NFC_DIRECTION_TX);\n\treturn nfc_data_exchange(dev, local->target_idx, skb,\n\t\t\t\t nfc_llcp_recv, local);\n}", "target": 1}
{"code": "int nbd_client(int fd)\n{\n    return -ENOTSUP;\n}", "target": 0}
{"code": "void dmar_free_irte(const struct intr_source *intr_src, uint16_t index)\n{\n\tstruct dmar_drhd_rt *dmar_unit;\n\tunion dmar_ir_entry *ir_table, *ir_entry;\n\tunion pci_bdf sid;\n\tif (intr_src->is_msi) {\n\t\tdmar_unit = device_to_dmaru((uint8_t)intr_src->src.msi.bits.b, intr_src->src.msi.fields.devfun);\n\t} else {\n\t\tdmar_unit = ioapic_to_dmaru(intr_src->src.ioapic_id, &sid);\n\t}\n\tif (is_dmar_unit_valid(dmar_unit, sid)) {\n\t\tir_table = (union dmar_ir_entry *)hpa2hva(dmar_unit->ir_table_addr);\n\t\tir_entry = ir_table + index;\n\t\tir_entry->bits.remap.present = 0x0UL;\n\t\tiommu_flush_cache(ir_entry, sizeof(union dmar_ir_entry));\n\t\tdmar_invalid_iec(dmar_unit, index, 0U, false);\n\t\tif (!is_irte_reserved(dmar_unit, index)) {\n\t\t\tspinlock_obtain(&dmar_unit->lock);\n\t\t\tbitmap_clear_nolock(index & 0x3FU, &dmar_unit->irte_alloc_bitmap[index >> 6U]);\n\t\t\tspinlock_release(&dmar_unit->lock);\n\t\t}\n\t}\n}", "target": 1}
{"code": "void nfs_idmap_quit(void)\n{\n\tnfs_idmap_quit_keyring();\n}", "target": 0}
{"code": "static int dns_resolver_match_preparse(struct key_match_data *match_data)\n{\n\tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n\tmatch_data->cmp = dns_resolver_cmp;\n\treturn 0;\n}", "target": 0}
{"code": "        int          Read(void* pDestBuffer, int nSize)\n        {\n            if ( m_nPos + nSize >= m_nLen )\n                nSize = m_nLen - m_nPos - 1;\n            memcpy( pDestBuffer, (m_sFile + m_nPos), nSize );\n            m_nPos += nSize;\n            return nSize;\n        }", "target": 1}
{"code": "static void vmx_refresh_apicv_exec_ctrl(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tvmcs_write32(PIN_BASED_VM_EXEC_CONTROL, vmx_pin_based_exec_ctrl(vmx));\n\tif (cpu_has_secondary_exec_ctrls()) {\n\t\tif (kvm_vcpu_apicv_active(vcpu))\n\t\t\tvmcs_set_bits(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t\t      SECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t      SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\t\telse\n\t\t\tvmcs_clear_bits(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t\t\tSECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\t}\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmx_set_msr_bitmap(vcpu);\n}", "target": 0}
{"code": "mm_freelist(struct mm_master *mmalloc, struct mmtree *head)\n{\n\tstruct mm_share *mms, *next;\n\tfor (mms = RB_ROOT(head); mms; mms = next) {\n\t\tnext = RB_NEXT(mmtree, head, mms);\n\t\tRB_REMOVE(mmtree, head, mms);\n\t\tif (mmalloc == NULL)\n\t\t\tfree(mms);\n\t\telse\n\t\t\tmm_free(mmalloc, mms);\n\t}\n}", "target": 1}
{"code": "static int apparmor_setprocattr(struct task_struct *task, char *name,\n\t\t\t\tvoid *value, size_t size)\n{\n\tstruct common_audit_data sa;\n\tstruct apparmor_audit_data aad = {0,};\n\tchar *command, *args = value;\n\tsize_t arg_size;\n\tint error;\n\tif (size == 0)\n\t\treturn -EINVAL;\n\tif (args[size - 1] != '\\0') {\n\t\tif (size == PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\targs[size] = '\\0';\n\t}\n\tif (current != task)\n\t\treturn -EACCES;\n\targs = value;\n\targs = strim(args);\n\tcommand = strsep(&args, \" \");\n\tif (!args)\n\t\treturn -EINVAL;\n\targs = skip_spaces(args);\n\tif (!*args)\n\t\treturn -EINVAL;\n\targ_size = size - (args - (char *) value);\n\tif (strcmp(name, \"current\") == 0) {\n\t\tif (strcmp(command, \"changehat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permhat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_DO_TEST);\n\t\t} else if (strcmp(command, \"changeprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     AA_DO_TEST);\n\t\t} else\n\t\t\tgoto fail;\n\t} else if (strcmp(name, \"exec\") == 0) {\n\t\tif (strcmp(command, \"exec\") == 0)\n\t\t\terror = aa_setprocattr_changeprofile(args, AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\telse\n\t\t\tgoto fail;\n\t} else\n\t\treturn -EINVAL;\n\tif (!error)\n\t\terror = size;\n\treturn error;\nfail:\n\tsa.type = LSM_AUDIT_DATA_NONE;\n\tsa.aad = &aad;\n\taad.profile = aa_current_profile();\n\taad.op = OP_SETPROCATTR;\n\taad.info = name;\n\taad.error = -EINVAL;\n\taa_audit_msg(AUDIT_APPARMOR_DENIED, &sa, NULL);\n\treturn -EINVAL;\n}", "target": 1}
{"code": "match_to_s(VALUE match)\n{\n    VALUE str = rb_reg_last_match(match);\n    match_check(match);\n    if (NIL_P(str)) str = rb_str_new(0,0);\n    if (OBJ_TAINTED(match)) OBJ_TAINT(str);\n    if (OBJ_TAINTED(RMATCH(match)->str)) OBJ_TAINT(str);\n    return str;\n}", "target": 0}
{"code": "inline int ComputeOutSize(TfLitePadding padding, int image_size,\n                          int filter_size, int stride, int dilation_rate = 1) {\n  int effective_filter_size = (filter_size - 1) * dilation_rate + 1;\n  if (stride == 0) return 0;\n  switch (padding) {\n    case kTfLitePaddingSame:\n      return (image_size + stride - 1) / stride;\n    case kTfLitePaddingValid:\n      return (image_size + stride - effective_filter_size) / stride;\n    default:\n      return 0;\n  }\n}", "target": 0}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  OpData* data = static_cast<OpData*>(node->user_data);\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  TF_LITE_ENSURE(context, input1 != nullptr);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TF_LITE_ENSURE(context, input2 != nullptr);\n  if (input1->type == kTfLiteUInt8 || input1->type == kTfLiteInt8) {\n    auto input1_offset = -input1->params.zero_point;\n    auto input2_offset = -input2->params.zero_point;\n    const int kLeftShift = 8;\n    int32_t input1_multiplier;\n    int input1_shift;\n    QuantizeMultiplierSmallerThanOneExp(\n        static_cast<double>(input1->params.scale), &input1_multiplier,\n        &input1_shift);\n    int32_t input2_multiplier;\n    int input2_shift;\n    QuantizeMultiplierSmallerThanOneExp(\n        static_cast<double>(input2->params.scale), &input2_multiplier,\n        &input2_shift);\n    data->params.left_shift = kLeftShift;\n    data->params.input1_offset = input1_offset;\n    data->params.input1_multiplier = input1_multiplier;\n    data->params.input1_shift = input1_shift;\n    data->params.input2_offset = input2_offset;\n    data->params.input2_multiplier = input2_multiplier;\n    data->params.input2_shift = input2_shift;\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,\n\t\t\t\t   const struct sk_buff *skb,\n\t\t\t\t   int flags, pol_lookup_t lookup)\n{\n\tstruct rt6_info *rt;\n\trt = lookup(net, net->ipv6.fib6_main_tbl, fl6, skb, flags);\n\tif (rt->dst.error == -EAGAIN) {\n\t\tip6_rt_put_flags(rt, flags);\n\t\trt = net->ipv6.ip6_null_entry;\n\t\tif (!(flags | RT6_LOOKUP_F_DST_NOREF))\n\t\t\tdst_hold(&rt->dst);\n\t}\n\treturn &rt->dst;\n}", "target": 1}
{"code": "catch_handler_set(codegen_scope *s, int ent, enum mrb_catch_type type, uint32_t begin, uint32_t end, uint32_t target)\n{\n  struct mrb_irep_catch_handler *e;\n  mrb_assert(ent >= 0 && ent < s->irep->clen);\n  e = &s->catch_table[ent];\n  uint8_to_bin(type, &e->type);\n  mrb_irep_catch_handler_pack(begin, e->begin);\n  mrb_irep_catch_handler_pack(end, e->end);\n  mrb_irep_catch_handler_pack(target, e->target);\n}", "target": 0}
{"code": "bool RenderViewImpl::isPointerLocked() {\n  return mouse_lock_dispatcher_->IsMouseLockedTo(\n      webwidget_mouse_lock_target_.get());\n }", "target": 0}
{"code": "static int me_unknown(struct page *p, unsigned long pfn)\n{\n\tpr_err(\"Memory failure: %#lx: Unknown page state\\n\", pfn);\n\treturn MF_FAILED;\n}", "target": 0}
{"code": "void invalidate_lstat_cache(void)\n{\n\treset_lstat_cache(&default_cache);\n}", "target": 0}
{"code": "i915_gem_execbuffer_retire_commands(struct drm_device *dev,\n\t\t\t\t    struct drm_file *file,\n\t\t\t\t    struct intel_ring_buffer *ring)\n{\n\tring->gpu_caches_dirty = true;\n\t(void)i915_add_request(ring, file, NULL);\n}", "target": 0}
{"code": "static bool meta_set(RAnal *a, RAnalMetaType type, int subtype, ut64 from, ut64 to, const char *str) {\n\tif (to < from) {\n\t\treturn false;\n\t}\n\tRSpace *space = r_spaces_current (&a->meta_spaces);\n\tRIntervalNode *node = find_node_at (a, type, space, from);\n\tRAnalMetaItem *item = node ? node->data : R_NEW0 (RAnalMetaItem);\n\tif (!item) {\n\t\treturn false;\n\t}\n\titem->type = type;\n\titem->subtype = subtype;\n\titem->space = space;\n\tfree (item->str);\n\titem->str = str ? strdup (str) : NULL;\n\tif (str && !item->str) {\n\t\tif (!node) { \n\t\t\tfree (item);\n\t\t}\n\t\treturn false;\n\t}\n\tR_DIRTY (a);\n\tif (!node) {\n\t\tr_interval_tree_insert (&a->meta, from, to, item);\n\t} else if (node->end != to) {\n\t\tr_interval_tree_resize (&a->meta, node, from, to);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static int pppoe_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t  struct msghdr *m, size_t total_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint error = 0;\n\tif (sk->sk_state & PPPOX_BOUND) {\n\t\terror = -EIO;\n\t\tgoto end;\n\t}\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &error);\n\tif (error < 0)\n\t\tgoto end;\n\tm->msg_namelen = 0;\n\tif (skb) {\n\t\ttotal_len = min_t(size_t, total_len, skb->len);\n\t\terror = skb_copy_datagram_iovec(skb, 0, m->msg_iov, total_len);\n\t\tif (error == 0) {\n\t\t\tconsume_skb(skb);\n\t\t\treturn total_len;\n\t\t}\n\t}\n\tkfree_skb(skb);\nend:\n\treturn error;\n}", "target": 1}
{"code": "static int delete_path(const char *dump_dir_name)\n{\n    if (!dir_is_in_dump_location(dump_dir_name))\n    {\n        error_msg(\"Bad problem directory name '%s', should start with: '%s'\", dump_dir_name, g_settings_dump_location);\n        return 400; \n    }\n    if (!dir_has_correct_permissions(dump_dir_name))\n    {\n        error_msg(\"Problem directory '%s' isn't owned by root:abrt or others are not restricted from access\", dump_dir_name);\n        return 400; \n    }\n    if (!dump_dir_accessible_by_uid(dump_dir_name, client_uid))\n    {\n        if (errno == ENOTDIR)\n        {\n            error_msg(\"Path '%s' isn't problem directory\", dump_dir_name);\n            return 404; \n        }\n        error_msg(\"Problem directory '%s' can't be accessed by user with uid %ld\", dump_dir_name, (long)client_uid);\n        return 403; \n    }\n    delete_dump_dir(dump_dir_name);\n    return 0; \n}", "target": 0}
{"code": "static struct ast_sip_endpoint *ip_identify(pjsip_rx_data *rdata)\n{\n\tstruct ast_sockaddr_with_tp addr_with_tp = { { { 0, } }, };\n\tpj_ansi_strxcpy(addr_with_tp.tp, rdata->tp_info.transport->type_name, sizeof(addr_with_tp.tp));\n\tast_sockaddr_parse(&addr_with_tp.addr, rdata->pkt_info.src_name, PARSE_PORT_FORBID);\n\tast_sockaddr_set_port(&addr_with_tp.addr, rdata->pkt_info.src_port);\n\treturn common_identify(ip_identify_match_check, &addr_with_tp);\n}", "target": 1}
{"code": "void __init kvmclock_init(void)\n{\n\tif (!kvm_para_available())\n\t\treturn;\n\tif (kvmclock && kvm_para_has_feature(KVM_FEATURE_CLOCKSOURCE2)) {\n\t\tmsr_kvm_system_time = MSR_KVM_SYSTEM_TIME_NEW;\n\t\tmsr_kvm_wall_clock = MSR_KVM_WALL_CLOCK_NEW;\n\t} else if (!(kvmclock && kvm_para_has_feature(KVM_FEATURE_CLOCKSOURCE)))\n\t\treturn;\n\tprintk(KERN_INFO \"kvm-clock: Using msrs %x and %x\",\n\t\tmsr_kvm_system_time, msr_kvm_wall_clock);\n\tif (kvm_register_clock(\"boot clock\"))\n\t\treturn;\n\tpv_time_ops.sched_clock = kvm_clock_read;\n\tx86_platform.calibrate_tsc = kvm_get_tsc_khz;\n\tx86_platform.get_wallclock = kvm_get_wallclock;\n\tx86_platform.set_wallclock = kvm_set_wallclock;\n#ifdef CONFIG_X86_LOCAL_APIC\n\tx86_cpuinit.setup_percpu_clockev =\n\t\tkvm_setup_secondary_clock;\n#endif\n\tmachine_ops.shutdown  = kvm_shutdown;\n#ifdef CONFIG_KEXEC\n\tmachine_ops.crash_shutdown  = kvm_crash_shutdown;\n#endif\n\tkvm_get_preset_lpj();\n\tclocksource_register_hz(&kvm_clock, NSEC_PER_SEC);\n\tpv_info.paravirt_enabled = 1;\n\tpv_info.name = \"KVM\";\n\tif (kvm_para_has_feature(KVM_FEATURE_CLOCKSOURCE_STABLE_BIT))\n\t\tpvclock_set_flags(PVCLOCK_TSC_STABLE_BIT);\n}", "target": 0}
{"code": "static int oidc_cache_crypto_decrypt(request_rec *r, const char *cache_value,\n\t\tunsigned char *key, unsigned char **plaintext) {\n\tint len = -1;\n\tchar *encoded_tag = strstr(cache_value, \".\");\n\tif (encoded_tag == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"corrupted cache value: no tag separator found in encrypted value\");\n\t\treturn FALSE;\n\t}\n\tcache_value = apr_pstrmemdup(r->pool, cache_value,\n\t\t\tstrlen(cache_value) - strlen(encoded_tag));\n\tencoded_tag++;\n\tchar *d_bytes = NULL;\n\tint d_len = oidc_base64url_decode(r->pool, &d_bytes, cache_value);\n\tchar *t_bytes = NULL;\n\tint t_len = oidc_base64url_decode(r->pool, &t_bytes, encoded_tag);\n\tif ((d_len > 0) && (t_len > 0)) {\n\t\t*plaintext = apr_pcalloc(r->pool,\n\t\t\t\t(d_len + EVP_CIPHER_block_size(OIDC_CACHE_CIPHER) - 1));\n\t\tlen = oidc_cache_crypto_decrypt_impl(r, (unsigned char *) d_bytes,\n\t\t\t\td_len, OIDC_CACHE_CRYPTO_GCM_AAD,\n\t\t\t\tsizeof(OIDC_CACHE_CRYPTO_GCM_AAD), (unsigned char *) t_bytes,\n\t\t\t\tt_len, key, OIDC_CACHE_CRYPTO_GCM_IV,\n\t\t\t\tsizeof(OIDC_CACHE_CRYPTO_GCM_IV), *plaintext);\n\t\tif (len > -1) {\n\t\t\t(*plaintext)[len] = '\\0';\n\t\t} else {\n\t\t\t*plaintext = NULL;\n\t\t}\n\t}\n\treturn len;\n}", "target": 1}
{"code": "ev_archive_open_filename (EvArchive   *archive,\n\t\t\t  const char  *path,\n\t\t\t  GError     **error)\n{\n\tint r;\n\tg_return_val_if_fail (EV_IS_ARCHIVE (archive), FALSE);\n\tg_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, FALSE);\n\tg_return_val_if_fail (path != NULL, FALSE);\n\tswitch (archive->type) {\n\tcase EV_ARCHIVE_TYPE_NONE:\n\t\tg_assert_not_reached ();\n\tcase EV_ARCHIVE_TYPE_RAR:\n\tcase EV_ARCHIVE_TYPE_ZIP:\n\tcase EV_ARCHIVE_TYPE_7Z:\n\tcase EV_ARCHIVE_TYPE_TAR:\n\t\tr = archive_read_open_filename (archive->libar, path, BUFFER_SIZE);\n\t\tif (r != ARCHIVE_OK) {\n\t\t\tg_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,\n\t\t\t\t     \"Error opening archive: %s\", archive_error_string (archive->libar));\n\t\t\treturn FALSE;\n\t\t}\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}", "target": 0}
{"code": "comics_decompress_temp_dir (const gchar *command_decompress_tmp,\n\t\t\t    const gchar *command, \n\t\t\t    GError      **error)\n{\n\tgboolean success;\n\tgchar *std_out, *basename;\n\tGError *err = NULL;\n\tgint retval;\n\tsuccess = g_spawn_command_line_sync (command_decompress_tmp, &std_out, \n\t\t\t\t\t     NULL, &retval, &err);\n\tbasename = g_path_get_basename (command);\n\tif (!success) {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR, \n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"Error launching the command %s in order to \"\n\t\t\t     \"decompress the comic book: %s\"),\n\t\t\t     basename,\n\t\t\t     err->message);\n\t\tg_error_free (err);\n\t} else if (WIFEXITED (retval)) {\n\t\tif (WEXITSTATUS (retval) == EXIT_SUCCESS) {\n\t\t\tg_free (std_out);\n\t\t\tg_free (basename);\n\t\t\treturn TRUE;\n\t\t} else {\n\t\t\tg_set_error (error,\n\t\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t\t     _(\"The command %s failed at \"\n\t\t\t\t     \"decompressing the comic book.\"),\n\t\t\t\t     basename);\n\t\t\tg_free (std_out);\n\t\t}\n\t} else {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"The command %s did not end normally.\"),\n\t\t\t     basename);\n\t\tg_free (std_out);\n\t}\n\tg_free (basename);\n\treturn FALSE;\n}", "target": 1}
{"code": "static void test_on_link_state_changed(void* context, LINK_STATE new_link_state, LINK_STATE previous_link_state)\n{\n    (void)context;\n    test_on_link_state_changed_new_link_state = new_link_state;\n    test_on_link_state_changed_previous_link_state = previous_link_state;\n}", "target": 0}
{"code": "static GF_Err xml_sax_append_string(GF_SAXParser *parser, char *string)\n{\n\tu32 size = parser->line_size;\n\tu32 nl_size = (u32) strlen(string);\n\tif (!nl_size) return GF_OK;\n\tif ( (parser->alloc_size < size+nl_size+1)\n\t   )\n\t{\n\t\tparser->alloc_size = size+nl_size+1;\n\t\tparser->alloc_size = 3 * parser->alloc_size / 2;\n\t\tparser->buffer = (char*)gf_realloc(parser->buffer, sizeof(char) * parser->alloc_size);\n\t\tif (!parser->buffer ) return GF_OUT_OF_MEM;\n\t}\n\tmemcpy(parser->buffer+size, string, sizeof(char)*nl_size);\n\tparser->buffer[size+nl_size] = 0;\n\tparser->line_size = size+nl_size;\n\treturn GF_OK;\n}", "target": 1}
{"code": "static int sched_read_attr(struct sched_attr __user *uattr,\n\t\t\t   struct sched_attr *attr,\n\t\t\t   unsigned int usize)\n{\n\tint ret;\n\tif (!access_ok(VERIFY_WRITE, uattr, usize))\n\t\treturn -EFAULT;\n\tif (usize < sizeof(*attr)) {\n\t\tunsigned char *addr;\n\t\tunsigned char *end;\n\t\taddr = (void *)attr + usize;\n\t\tend  = (void *)attr + sizeof(*attr);\n\t\tfor (; addr < end; addr++) {\n\t\t\tif (*addr)\n\t\t\t\tgoto err_size;\n\t\t}\n\t\tattr->size = usize;\n\t}\n\tret = copy_to_user(uattr, attr, usize);\n\tif (ret)\n\t\treturn -EFAULT;\nout:\n\treturn ret;\nerr_size:\n\tret = -E2BIG;\n\tgoto out;\n}", "target": 1}
{"code": "void hexdump(msg_info msg_info, const char *mem, unsigned int len)\n{\n    unsigned int i, j;\n    char str[10 + HEXDUMP_COLS * 4 + 2];\n    int c = 0; \n    for(i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++)\n    {\n        if(i % HEXDUMP_COLS == 0)\n            c += sprintf(&str[c], \"0x%06x: \", i);\n        if(i < len)\n            c += sprintf(&str[c], \"%02x \", 0xFF & mem[i]);\n        else \n            c+= sprintf(&str[c], \"   \");\n        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {\n            for(j = i - (HEXDUMP_COLS - 1); j <= i; j++) {\n                if(j >= len) \n                    str[c++] = ' ';\n                else if(isprint(mem[j])) \n                    str[c++] = 0xFF & mem[j];\n                else \n                    str[c++] = '.';\n            }\n            str[c++] = '\\n';\n            str[c++] = 0;\n            print_message(msg_info, str);\n            c = 0;\n        }\n    }\n}", "target": 1}
{"code": "ResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,\n                         xkb_mod_mask_t *mods_rtrn, CompatInfo *info)\n{\n    if (expr == NULL) {\n        *pred_rtrn = MATCH_ANY_OR_NONE;\n        *mods_rtrn = MOD_REAL_MASK_ALL;\n        return true;\n    }\n    *pred_rtrn = MATCH_EXACTLY;\n    if (expr->expr.op == EXPR_ACTION_DECL) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);\n        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn)) {\n            log_err(info->ctx,\n                    \"Illegal modifier predicate \\\"%s\\\"; Ignored\\n\", pred_txt);\n            return false;\n        }\n        expr = expr->action.args;\n    }\n    else if (expr->expr.op == EXPR_IDENT) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->ident.ident);\n        if (pred_txt && istreq(pred_txt, \"any\")) {\n            *pred_rtrn = MATCH_ANY;\n            *mods_rtrn = MOD_REAL_MASK_ALL;\n            return true;\n        }\n    }\n    return ExprResolveModMask(info->ctx, expr, MOD_REAL, &info->mods,\n                              mods_rtrn);\n}", "target": 1}
{"code": "TEST(DepthToSpaceOpModel, NoBlockSize) {\n  EXPECT_DEATH(DepthToSpaceOpModel({TensorType_FLOAT32, {1, 1, 1, 4}}, 0),\n               \"Cannot allocate tensors\");\n}", "target": 0}
{"code": "test_all_FFs(void **state)\n{\n    (void) state;\n    const char *e = Tss2_RC_Decode(0xFFFFFFFF);\n    assert_string_equal(e, \"255:0xFFFFFF\");\n}", "target": 0}
{"code": "static int atusb_get_and_show_build(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tchar build[ATUSB_BUILD_SIZE + 1];\n\tint ret;\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_BUILD, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuild, ATUSB_BUILD_SIZE, 1000);\n\tif (ret >= 0) {\n\t\tbuild[ret] = 0;\n\t\tdev_info(&usb_dev->dev, \"Firmware: build %s\\n\", build);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "fbCombineConjointInReverseC (CARD32 *dest, CARD32 *src, CARD32 *mask, int width)\n{\n    fbCombineConjointGeneralC (dest, src, mask, width, CombineBIn);\n}", "target": 0}
{"code": "static int adpt_show_info(struct seq_file *m, struct Scsi_Host *host)\n{\n\tstruct adpt_device* d;\n\tint id;\n\tint chan;\n\tadpt_hba* pHba;\n\tint unit;\n\tmutex_lock(&adpt_configuration_lock);\n\tfor (pHba = hba_chain; pHba; pHba = pHba->next) {\n\t\tif (pHba->host == host) {\n\t\t\tbreak;\t\n\t\t}\n\t}\n\tmutex_unlock(&adpt_configuration_lock);\n\tif (pHba == NULL) {\n\t\treturn 0;\n\t}\n\thost = pHba->host;\n\tseq_printf(m, \"Adaptec I2O RAID Driver Version: %s\\n\\n\", DPT_I2O_VERSION);\n\tseq_printf(m, \"%s\\n\", pHba->detail);\n\tseq_printf(m, \"SCSI Host=scsi%d  Control Node=/dev/%s  irq=%d\\n\", \n\t\t\tpHba->host->host_no, pHba->name, host->irq);\n\tseq_printf(m, \"\\tpost fifo size  = %d\\n\\treply fifo size = %d\\n\\tsg table size   = %d\\n\\n\",\n\t\t\thost->can_queue, (int) pHba->reply_fifo_size , host->sg_tablesize);\n\tseq_puts(m, \"Devices:\\n\");\n\tfor(chan = 0; chan < MAX_CHANNEL; chan++) {\n\t\tfor(id = 0; id < MAX_ID; id++) {\n\t\t\td = pHba->channel[chan].device[id];\n\t\t\twhile(d) {\n\t\t\t\tseq_printf(m,\"\\t%-24.24s\", d->pScsi_dev->vendor);\n\t\t\t\tseq_printf(m,\" Rev: %-8.8s\\n\", d->pScsi_dev->rev);\n\t\t\t\tunit = d->pI2o_dev->lct_data.tid;\n\t\t\t\tseq_printf(m, \"\\tTID=%d, (Channel=%d, Target=%d, Lun=%llu)  (%s)\\n\\n\",\n\t\t\t\t\t       unit, (int)d->scsi_channel, (int)d->scsi_id, d->scsi_lun,\n\t\t\t\t\t       scsi_device_online(d->pScsi_dev)? \"online\":\"offline\"); \n\t\t\t\td = d->next_lun;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int htc_config_pipe_credits(struct htc_target *target)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_config_pipe_msg *cp_msg;\n\tint ret;\n\tunsigned long time_left;\n\tskb = alloc_skb(50 + sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"failed to allocate send buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\tcp_msg = skb_put(skb, sizeof(struct htc_config_pipe_msg));\n\tcp_msg->message_id = cpu_to_be16(HTC_MSG_CONFIG_PIPE_ID);\n\tcp_msg->pipe_id = USB_WLAN_TX_PIPE;\n\tcp_msg->credits = target->credits;\n\ttarget->htc_flags |= HTC_OP_CONFIG_PIPE_CREDITS;\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"HTC credit config timeout\\n\");\n\t\tkfree_skb(skb);\n\t\treturn -ETIMEDOUT;\n\t}\n\treturn 0;\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}", "target": 0}
{"code": "pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr)\n{\n\tInitializeCriticalSection(mutex);\n\treturn 0;\n}", "target": 1}
{"code": "static inline int mb2_cache_entry_put(struct mb2_cache *cache,\n\t\t\t\t      struct mb2_cache_entry *entry)\n{\n\tif (!atomic_dec_and_test(&entry->e_refcnt))\n\t\treturn 0;\n\t__mb2_cache_entry_free(entry);\n\treturn 1;\n}", "target": 0}
{"code": "static uint32_t mp_clzll(unsigned long long x) {\n    unsigned long lz = 0;\n    return _BitScanReverse64(&lz, x) ? (sizeof(x) * 8 - 1) - lz : 0;\n}", "target": 0}
{"code": "TEST_F(AutoParallelTest, SimpleParallelNoDequeue) {\n  tensorflow::Scope s = tensorflow::Scope::DisabledShapeInferenceScope();\n  Output constant_a = ops::Const(s.WithOpName(\"constant_a\"), 1.0f, {1});\n  Output constant_c = ops::Const(s.WithOpName(\"constant_c\"), 1.0f, {1});\n  Output constant_b = ops::Const(s.WithOpName(\"constant_b\"), 1, {1});\n  Output var = ops::Variable(s.WithOpName(\"var\"), {1}, DT_FLOAT);\n  Output assign = ops::Assign(s.WithOpName(\"assign\"), {var}, {constant_a});\n  Output add = ops::AddN(s.WithOpName(\"add\"), {constant_a, constant_c});\n  Output learning_rate = ops::Const(s.WithOpName(\"learning_rate\"), 0.01f, {1});\n  Output apply_gradient = ops::ApplyGradientDescent(\n      s.WithOpName(\"apply_gradient\"), {var}, {learning_rate}, {add});\n  GrapplerItem item;\n  item.init_ops.push_back(\"assign\");\n  item.fetch.push_back(\"apply_gradient\");\n  item.init_ops.push_back(\"assign\");\n  TF_CHECK_OK(s.ToGraphDef(&item.graph));\n  AutoParallel parallel(2);\n  GraphDef output;\n  Status status = parallel.Optimize(nullptr, item, &output);\n  TF_EXPECT_OK(status);\n}", "target": 0}
{"code": "static RList *r_bin_wasm_get_element_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\tRList *ret = NULL;\n\tRBinWasmElementEntry *ptr = NULL;\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 count = sec->count;\n\tut32 i = 0, r = 0;\n\twhile (i < len && r < count) {\n\t\tif (!(ptr = R_NEW0 (RBinWasmElementEntry))) {\n\t\t\treturn ret;\n\t\t}\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\t\tif (!(consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->num_elem, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\t\tut32 j = 0;\n\t\twhile (i < len && j < ptr->num_elem\t) {\n\t\t\tut32 e;\n\t\t\tif (!(consume_u32 (buf + i, buf + len, &e, &i))) {\n\t\t\t\tfree (ptr);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tr_list_append (ret, ptr);\n\t\tr += 1;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "spawn_child()\n{\n        pid_t pid;\n        sigset_t newset;\n        sigset_t oldset;\n        sigemptyset(&newset);\n        sigaddset(&newset, SIGCHLD);\n        sigaddset(&newset, SIGTERM);\n        sigprocmask(SIG_BLOCK, &newset, &oldset);\n        pid = fork();\n        if (pid < 0) {\n                msg(LOG_ERR, \"Could not fork (%s)\", strerror(errno));\n                goto out;\n        }\n        if (pid > 0) { \n                pid_t *pidp;\n                pidp = g_malloc(sizeof(pid_t));\n                *pidp = pid;\n                g_hash_table_insert(children, pidp, pidp);\n                goto out;\n        }\n        signal(SIGCHLD, SIG_DFL);\n        signal(SIGTERM, SIG_DFL);\n        signal(SIGHUP, SIG_DFL);\nout:\n        sigprocmask(SIG_SETMASK, &oldset, NULL);\n        return pid;\n}", "target": 0}
{"code": "\t\tAccessorRunner(ReferenceHandle& target, Local<Value> key_handle) :\n\t\tcontext{target.context},\n\t\ttarget{target.reference},\n\t\tkey{ExternalCopy::CopyIfPrimitive(key_handle)} {\n\t\t\ttarget.CheckDisposed();\n\t\t\tif (!key || (!key_handle->IsName() && !key_handle->IsUint32())) {\n\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n\t\t\t} else if (target.type_of != decltype(target.type_of)::Object) {\n\t\t\t\tthrow RuntimeTypeError(\"Reference is not an object\");\n\t\t\t}\n\t\t}", "target": 0}
{"code": "static bool packet_use_direct_xmit(const struct packet_sock *po)\n{\n\treturn po->xmit == packet_direct_xmit;\n}", "target": 0}
{"code": "ByteVector ByteVector::mid(uint index, uint length) const\n{\n  ByteVector v;\n  if(index > size())\n    return v;\n  ConstIterator endIt;\n  if(length < 0xffffffff && length + index < size())\n    endIt = d->data.begin() + index + length;\n  else\n    endIt = d->data.end();\n  v.d->data.insert(v.d->data.begin(), ConstIterator(d->data.begin() + index), endIt);\n  v.d->size = v.d->data.size();\n  return v;\n}", "target": 1}
{"code": "PGTYPESinterval_from_asc(char *str, char **endptr)\n{\n\tinterval   *result = NULL;\n\tfsec_t\t\tfsec;\n\tstruct tm\ttt,\n\t\t\t   *tm = &tt;\n\tint\t\t\tdtype;\n\tint\t\t\tnf;\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tftype[MAXDATEFIELDS];\n\tchar\t\tlowstr[MAXDATELEN + MAXDATEFIELDS];\n\tchar\t   *realptr;\n\tchar\t  **ptr = (endptr != NULL) ? endptr : &realptr;\n\ttm->tm_year = 0;\n\ttm->tm_mon = 0;\n\ttm->tm_mday = 0;\n\ttm->tm_hour = 0;\n\ttm->tm_min = 0;\n\ttm->tm_sec = 0;\n\tfsec = 0;\n\tif (strlen(str) >= sizeof(lowstr))\n\t{\n\t\terrno = PGTYPES_INTVL_BAD_INTERVAL;\n\t\treturn NULL;\n\t}\n\tif (ParseDateTime(str, lowstr, field, ftype, &nf, ptr) != 0 ||\n\t\t(DecodeInterval(field, ftype, nf, &dtype, tm, &fsec) != 0 &&\n\t\t DecodeISO8601Interval(str, &dtype, tm, &fsec) != 0))\n\t{\n\t\terrno = PGTYPES_INTVL_BAD_INTERVAL;\n\t\treturn NULL;\n\t}\n\tresult = (interval *) pgtypes_alloc(sizeof(interval));\n\tif (!result)\n\t\treturn NULL;\n\tif (dtype != DTK_DELTA)\n\t{\n\t\terrno = PGTYPES_INTVL_BAD_INTERVAL;\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\tif (tm2interval(tm, fsec, result) != 0)\n\t{\n\t\terrno = PGTYPES_INTVL_BAD_INTERVAL;\n\t\tfree(result);\n\t\treturn NULL;\n\t}\n\terrno = 0;\n\treturn result;\n}", "target": 1}
{"code": "print_arrays_for(char *set)\n{\n  FILE *f;\n  sprintf(buf, \"%s.conf\", set);\n  if ((f = fopen(buf, \"r\")) == NULL) {\n    fprintf(stderr, \"%s: can't read conf file for charset %s\\n\", prog, set);\n    exit(EXIT_FAILURE);\n  }\n  printf(\"\\\n\\n\\n\",\n\t set, prog);\n  print_array(f, set, \"ctype\",      CTYPE_TABLE_SIZE);\n  print_array(f, set, \"to_lower\",   TO_LOWER_TABLE_SIZE);\n  print_array(f, set, \"to_upper\",   TO_UPPER_TABLE_SIZE);\n  print_array(f, set, \"sort_order\", SORT_ORDER_TABLE_SIZE);\n  printf(\"\\n\");\n  fclose(f);\n  return;\n}", "target": 1}
{"code": "Map1to1(SDL_Palette * src, SDL_Palette * dst, int *identical)\n{\n    Uint8 *map;\n    int i;\n    if (identical) {\n        if (src->ncolors <= dst->ncolors) {\n            if (src == dst\n                ||\n                (SDL_memcmp\n                 (src->colors, dst->colors,\n                  src->ncolors * sizeof(SDL_Color)) == 0)) {\n                *identical = 1;\n                return (NULL);\n            }\n        }\n        *identical = 0;\n    }\n    map = (Uint8 *) SDL_malloc(src->ncolors);\n    if (map == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n    for (i = 0; i < src->ncolors; ++i) {\n        map[i] = SDL_FindColor(dst,\n                               src->colors[i].r, src->colors[i].g,\n                               src->colors[i].b, src->colors[i].a);\n    }\n    return (map);\n}", "target": 1}
{"code": "int processCommand(redisClient *c) {\n    struct redisCommand *cmd;\n    if (!strcasecmp(c->argv[0]->ptr,\"quit\")) {\n        addReply(c,shared.ok);\n        c->flags |= REDIS_CLOSE_AFTER_REPLY;\n        return REDIS_ERR;\n    }\n    cmd = lookupCommand(c->argv[0]->ptr);\n    if (!cmd) {\n        addReplyErrorFormat(c,\"unknown command '%s'\",\n            (char*)c->argv[0]->ptr);\n        return REDIS_OK;\n    } else if ((cmd->arity > 0 && cmd->arity != c->argc) ||\n               (c->argc < -cmd->arity)) {\n        addReplyErrorFormat(c,\"wrong number of arguments for '%s' command\",\n            cmd->name);\n        return REDIS_OK;\n    }\n    if (server.requirepass && !c->authenticated && cmd->proc != authCommand) {\n        addReplyError(c,\"operation not permitted\");\n        return REDIS_OK;\n    }\n    if (server.maxmemory) freeMemoryIfNeeded();\n    if (server.maxmemory && (cmd->flags & REDIS_CMD_DENYOOM) &&\n        zmalloc_used_memory() > server.maxmemory)\n    {\n        addReplyError(c,\"command not allowed when used memory > 'maxmemory'\");\n        return REDIS_OK;\n    }\n    if ((dictSize(c->pubsub_channels) > 0 || listLength(c->pubsub_patterns) > 0)\n        &&\n        cmd->proc != subscribeCommand && cmd->proc != unsubscribeCommand &&\n        cmd->proc != psubscribeCommand && cmd->proc != punsubscribeCommand) {\n        addReplyError(c,\"only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context\");\n        return REDIS_OK;\n    }\n    if (server.masterhost && server.replstate != REDIS_REPL_CONNECTED &&\n        server.repl_serve_stale_data == 0 &&\n        cmd->proc != infoCommand && cmd->proc != slaveofCommand)\n    {\n        addReplyError(c,\n            \"link with MASTER is down and slave-serve-stale-data is set to no\");\n        return REDIS_OK;\n    }\n    if (server.loading && cmd->proc != infoCommand) {\n        addReply(c, shared.loadingerr);\n        return REDIS_OK;\n    }\n    if (c->flags & REDIS_MULTI &&\n        cmd->proc != execCommand && cmd->proc != discardCommand &&\n        cmd->proc != multiCommand && cmd->proc != watchCommand)\n    {\n        queueMultiCommand(c,cmd);\n        addReply(c,shared.queued);\n    } else {\n        if (server.vm_enabled && server.vm_max_threads > 0 &&\n            blockClientOnSwappedKeys(c,cmd)) return REDIS_ERR;\n        call(c,cmd);\n    }\n    return REDIS_OK;\n}", "target": 1}
{"code": "void test_path_dotgit__dotgit_modules_symlink(void)\n{\n\tcl_assert_equal_b(true, git_path_isvalid(NULL, \".gitmodules\", 0, GIT_PATH_REJECT_DOT_GIT_HFS|GIT_PATH_REJECT_DOT_GIT_NTFS));\n\tcl_assert_equal_b(false, git_path_isvalid(NULL, \".gitmodules\", S_IFLNK, GIT_PATH_REJECT_DOT_GIT_HFS));\n\tcl_assert_equal_b(false, git_path_isvalid(NULL, \".gitmodules\", S_IFLNK, GIT_PATH_REJECT_DOT_GIT_NTFS));\n\tcl_assert_equal_b(false, git_path_isvalid(NULL, \".gitmodules . .::$DATA\", S_IFLNK, GIT_PATH_REJECT_DOT_GIT_NTFS));\n}", "target": 0}
{"code": "_TIFFmalloc(tsize_t s)\n{\n        if (s == 0)\n                return ((void *) NULL);\n\treturn (malloc((size_t) s));\n}", "target": 0}
{"code": "String BuildElementErrorMessage(const String& error) {\n  DEFINE_STATIC_LOCAL(const String, element_error_prefix,\n                      (\"MEDIA_ELEMENT_ERROR: \"));\n  StringBuilder builder;\n  builder.Append(element_error_prefix);\n  builder.Append(error);\n  return builder.ToString();\n}", "target": 0}
{"code": "static void kvm_pv_disable_apf(void)\n{\n\tif (!__this_cpu_read(apf_reason.enabled))\n\t\treturn;\n\twrmsrl(MSR_KVM_ASYNC_PF_EN, 0);\n\t__this_cpu_write(apf_reason.enabled, 0);\n\tprintk(KERN_INFO\"Unregister pv shared memory for cpu %d\\n\",\n\t       smp_processor_id());\n}", "target": 0}
{"code": "void log_flush(LOG_MODE new_mode) {\n    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_LOG_MODE]);\n    if(log_mode!=LOG_MODE_CONFIGURED || new_mode!=LOG_MODE_ERROR)\n        log_mode=new_mode;\n    if(new_mode!=LOG_MODE_BUFFER) {\n        CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_LOG_BUFFER]);\n        while(head) {\n            struct LIST *tmp=head;\n            head=head->next;\n            log_raw(tmp->opt, tmp->level, tmp->stamp, tmp->id, tmp->text);\n            str_free(tmp);\n        }\n        head=tail=NULL;\n        CRYPTO_THREAD_unlock(stunnel_locks[LOCK_LOG_BUFFER]);\n    }\n    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_LOG_MODE]);\n}", "target": 1}
{"code": "smix(uint8_t * B, size_t r, uint64_t N, uint32_t * V, uint32_t * XY)\n{\n  uint32_t * X = XY;\n  uint32_t * Y = &XY[32 * r];\n  uint32_t * Z = &XY[64 * r];\n  uint64_t i;\n  uint64_t j;\n  size_t k;\n  for (k = 0; k < 32 * r; k++) {\n    X[k] = folly::Endian::little32(*((uint32_t *) &B[4 * k]));\n  }\n  for (i = 0; i < N; i += 2) {\n    blkcpy(&V[i * (32 * r)], X, 128 * r);\n    blockmix_salsa8(X, Y, Z, r);\n    blkcpy(&V[(i + 1) * (32 * r)], Y, 128 * r);\n    blockmix_salsa8(Y, X, Z, r);\n  }\n  for (i = 0; i < N; i += 2) {\n    j = integerify(X, r) & (N - 1);\n    blkxor(X, &V[j * (32 * r)], 128 * r);\n    blockmix_salsa8(X, Y, Z, r);\n    j = integerify(Y, r) & (N - 1);\n    blkxor(Y, &V[j * (32 * r)], 128 * r);\n    blockmix_salsa8(Y, X, Z, r);\n  }\n  for (k = 0; k < 32 * r; k++) {\n    *((uint32_t *) &B[4 * k]) = folly::Endian::little32(X[k]);\n  }\n}", "target": 1}
{"code": "static struct rq *__migrate_task(struct rq *rq, struct task_struct *p, int dest_cpu)\n{\n\tif (unlikely(!cpu_active(dest_cpu)))\n\t\treturn rq;\n\tif (!cpumask_test_cpu(dest_cpu, tsk_cpus_allowed(p)))\n\t\treturn rq;\n\trq = move_queued_task(rq, p, dest_cpu);\n\treturn rq;\n}", "target": 0}
{"code": "void build_ntlmssp_negotiate_blob(unsigned char *pbuffer,\n\t\t\t\t\t struct cifs_ses *ses)\n{\n\tNEGOTIATE_MESSAGE *sec_blob = (NEGOTIATE_MESSAGE *)pbuffer;\n\t__u32 flags;\n\tmemset(pbuffer, 0, sizeof(NEGOTIATE_MESSAGE));\n\tmemcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);\n\tsec_blob->MessageType = NtLmNegotiate;\n\tflags = NTLMSSP_NEGOTIATE_56 |\tNTLMSSP_REQUEST_TARGET |\n\t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;\n\tif (ses->server->sign) {\n\t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n\t\tif (!ses->server->session_estab ||\n\t\t\t\tses->ntlmssp->sesskey_per_smbsess)\n\t\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n\t}\n\tsec_blob->NegotiateFlags = cpu_to_le32(flags);\n\tsec_blob->WorkstationName.BufferOffset = 0;\n\tsec_blob->WorkstationName.Length = 0;\n\tsec_blob->WorkstationName.MaximumLength = 0;\n\tsec_blob->DomainName.BufferOffset = 0;\n\tsec_blob->DomainName.Length = 0;\n\tsec_blob->DomainName.MaximumLength = 0;\n}", "target": 1}
{"code": "void* WebGraphicsContext3DDefaultImpl::mapBufferSubDataCHROMIUM(unsigned target, int offset, int size, unsigned access)\n{\n    return 0;\n}", "target": 0}
{"code": "int ipmi_si_port_setup(struct si_sm_io *io)\n{\n\tunsigned int addr = io->addr_data;\n\tint          idx;\n\tif (!addr)\n\t\treturn -ENODEV;\n\tio->io_cleanup = port_cleanup;\n\tswitch (io->regsize) {\n\tcase 1:\n\t\tio->inputb = port_inb;\n\t\tio->outputb = port_outb;\n\t\tbreak;\n\tcase 2:\n\t\tio->inputb = port_inw;\n\t\tio->outputb = port_outw;\n\t\tbreak;\n\tcase 4:\n\t\tio->inputb = port_inl;\n\t\tio->outputb = port_outl;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(io->dev, \"Invalid register size: %d\\n\",\n\t\t\t io->regsize);\n\t\treturn -EINVAL;\n\t}\n\tfor (idx = 0; idx < io->io_size; idx++) {\n\t\tif (request_region(addr + idx * io->regspacing,\n\t\t\t\t   io->regsize, DEVICE_NAME) == NULL) {\n\t\t\twhile (idx--)\n\t\t\t\trelease_region(addr + idx * io->regspacing,\n\t\t\t\t\t       io->regsize);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "SessionStorageNamespace* WebContentsImpl::GetSessionStorageNamespace(\n    SiteInstance* instance) {\n  return controller_.GetSessionStorageNamespace(instance);\n}", "target": 0}
{"code": "static char *pool_strdup(const char *s)\n{\n\tchar *r = pool_alloc(strlen(s) + 1);\n\tstrcpy(r, s);\n\treturn r;\n}", "target": 1}
{"code": "bittok2str_internal(register const struct tok *lp, register const char *fmt,\n\t   register u_int v, const char *sep)\n{\n        static char buf[256]; \n        int buflen=0;\n        register u_int rotbit; \n        register u_int tokval;\n        const char * sepstr = \"\";\n\twhile (lp != NULL && lp->s != NULL) {\n            tokval=lp->v;   \n            rotbit=1;\n            while (rotbit != 0) {\n\t\tif (tokval == (v&rotbit)) {\n                    buflen+=snprintf(buf+buflen, sizeof(buf)-buflen, \"%s%s\",\n                                     sepstr, lp->s);\n                    sepstr = sep;\n                    break;\n                }\n                rotbit=rotbit<<1; \n            }\n            lp++;\n\t}\n        if (buflen == 0)\n            (void)snprintf(buf, sizeof(buf), fmt == NULL ? \"#%08x\" : fmt, v);\n        return (buf);\n}", "target": 1}
{"code": "int compat_sock_common_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t\t  char __user *optval, int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tif (sk->sk_prot->compat_setsockopt != NULL)\n\t\treturn sk->sk_prot->compat_setsockopt(sk, level, optname,\n\t\t\t\t\t\t      optval, optlen);\n\treturn sk->sk_prot->setsockopt(sk, level, optname, optval, optlen);\n}", "target": 0}
{"code": "void ImapModelOpenConnectionTest::testPreauthWithStartTlsWanted()\n{\n    cleanup(); init(true); \n    cEmpty();\n    cServer(\"* PREAUTH hi there\\r\\n\");\n    QCOMPARE(failedSpy->size(), 1);\n    QVERIFY(completedSpy->isEmpty());\n    QVERIFY(authSpy->isEmpty());\n    QVERIFY(startTlsUpgradeSpy->isEmpty());\n}", "target": 0}
{"code": "  void expectTrailers(\n      std::function<void()> callback = std::function<void()>()) {\n    if (callback) {\n      EXPECT_CALL(*this, onTrailers(testing::_))\n          .WillOnce(testing::InvokeWithoutArgs(callback))\n          .RetiresOnSaturation();\n    } else {\n      EXPECT_CALL(*this, onTrailers(testing::_));\n    }\n  }", "target": 0}
{"code": "mm_answer_pam_init_ctx(int sock, Buffer *m)\n{\n\tdebug3(\"%s\", __func__);\n\tauthctxt->user = buffer_get_string(m, NULL);\n\tsshpam_ctxt = (sshpam_device.init_ctx)(authctxt);\n\tsshpam_authok = NULL;\n\tbuffer_clear(m);\n\tif (sshpam_ctxt != NULL) {\n\t\tmonitor_permit(mon_dispatch, MONITOR_REQ_PAM_FREE_CTX, 1);\n\t\tbuffer_put_int(m, 1);\n\t} else {\n\t\tbuffer_put_int(m, 0);\n\t}\n\tmm_request_send(sock, MONITOR_ANS_PAM_INIT_CTX, m);\n\treturn (0);\n}", "target": 1}
{"code": "uint32_t WasmBinaryWriter::getTableIndex(Name name) const {\n  auto it = indexes.tableIndexes.find(name);\n  assert(it != indexes.tableIndexes.end());\n  return it->second;\n}", "target": 0}
{"code": "l2tp_accm_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tuint16_t val_h, val_l;\n\tptr++;\t\t\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"send=%08x \", (val_h<<16) + val_l));\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"recv=%08x \", (val_h<<16) + val_l));\n}", "target": 1}
{"code": "read_file(gchar* filepath)\n{\n\tFILE * f;\n\tsize_t length;\n\tgchar *ret = NULL;\n\tf = fopen(filepath, \"rb\");\n\tif (f) {\n\t\tfseek(f, 0, SEEK_END);\n\t\tlength = (size_t)ftell(f);\n\t\tfseek(f, 0, SEEK_SET);\n\t\tret = MALLOC(length + 1);\n\t\tif (ret) {\n\t\t\tif (fread(ret, length, 1, f) != 1) {\n\t\t\t\tlog_message(LOG_INFO, \"Failed to read all of %s\", filepath);\n\t\t\t}\n\t\t\tret[length] = '\\0';\n\t\t}\n\t\telse\n\t\t\tlog_message(LOG_INFO, \"Unable to read Dbus file %s\", filepath);\n\t\tfclose(f);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "unsigned char *base64decode(const char *buf, size_t *size)\n{\n\tif (!buf || !size) return NULL;\n\tsize_t len = (*size > 0) ? *size : strlen(buf);\n\tif (len <= 0) return NULL;\n\tunsigned char *outbuf = (unsigned char*)malloc((len/4)*3+3);\n\tconst char *ptr = buf;\n\tint p = 0;\n\tsize_t l = 0;\n\tdo {\n\t\tptr += strspn(ptr, \"\\r\\n\\t \");\n\t\tif (*ptr == '\\0' || ptr >= buf+len) {\n\t\t\tbreak;\n\t\t}\n\t\tl = strcspn(ptr, \"\\r\\n\\t \");\n\t\tif (l > 3 && ptr+l <= buf+len) {\n\t\t\tp+=base64decode_block(outbuf+p, ptr, l);\n\t\t\tptr += l;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t} while (1);\n\toutbuf[p] = 0;\n\t*size = p;\n\treturn outbuf;\n}", "target": 1}
{"code": "void luaT_adjustvarargs (lua_State *L, int nfixparams, CallInfo *ci,\n                         const Proto *p) {\n  int i;\n  int actual = cast_int(L->top - ci->func) - 1;  \n  int nextra = actual - nfixparams;  \n  ci->u.l.nextraargs = nextra;\n  checkstackGC(L, p->maxstacksize + 1);\n  setobjs2s(L, L->top++, ci->func);\n  for (i = 1; i <= nfixparams; i++) {\n    setobjs2s(L, L->top++, ci->func + i);\n    setnilvalue(s2v(ci->func + i));  \n  }\n  ci->func += actual + 1;\n  ci->top += actual + 1;\n  lua_assert(L->top <= ci->top && ci->top <= L->stack_last);\n}", "target": 1}
{"code": "register_for_each_vma(struct uprobe *uprobe, struct uprobe_consumer *new)\n{\n\tbool is_register = !!new;\n\tstruct map_info *info;\n\tint err = 0;\n\tpercpu_down_write(&dup_mmap_sem);\n\tinfo = build_map_info(uprobe->inode->i_mapping,\n\t\t\t\t\tuprobe->offset, is_register);\n\tif (IS_ERR(info)) {\n\t\terr = PTR_ERR(info);\n\t\tgoto out;\n\t}\n\twhile (info) {\n\t\tstruct mm_struct *mm = info->mm;\n\t\tstruct vm_area_struct *vma;\n\t\tif (err && is_register)\n\t\t\tgoto free;\n\t\tdown_write(&mm->mmap_sem);\n\t\tvma = find_vma(mm, info->vaddr);\n\t\tif (!vma || !valid_vma(vma, is_register) ||\n\t\t    file_inode(vma->vm_file) != uprobe->inode)\n\t\t\tgoto unlock;\n\t\tif (vma->vm_start > info->vaddr ||\n\t\t    vaddr_to_offset(vma, info->vaddr) != uprobe->offset)\n\t\t\tgoto unlock;\n\t\tif (is_register) {\n\t\t\tif (consumer_filter(new,\n\t\t\t\t\tUPROBE_FILTER_REGISTER, mm))\n\t\t\t\terr = install_breakpoint(uprobe, mm, vma, info->vaddr);\n\t\t} else if (test_bit(MMF_HAS_UPROBES, &mm->flags)) {\n\t\t\tif (!filter_chain(uprobe,\n\t\t\t\t\tUPROBE_FILTER_UNREGISTER, mm))\n\t\t\t\terr |= remove_breakpoint(uprobe, mm, info->vaddr);\n\t\t}\n unlock:\n\t\tup_write(&mm->mmap_sem);\n free:\n\t\tmmput(mm);\n\t\tinfo = free_map_info(info);\n\t}\n out:\n\tpercpu_up_write(&dup_mmap_sem);\n\treturn err;\n}", "target": 0}
{"code": "static void *bpf_obj_do_get(const struct filename *pathname,\n\t\t\t    enum bpf_type *type)\n{\n\tstruct inode *inode;\n\tstruct path path;\n\tvoid *raw;\n\tint ret;\n\tret = kern_path(pathname->name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tinode = d_backing_inode(path.dentry);\n\tret = inode_permission(inode, MAY_WRITE);\n\tif (ret)\n\t\tgoto out;\n\tret = bpf_inode_type(inode, type);\n\tif (ret)\n\t\tgoto out;\n\traw = bpf_any_get(inode->i_private, *type);\n\ttouch_atime(&path);\n\tpath_put(&path);\n\treturn raw;\nout:\n\tpath_put(&path);\n\treturn ERR_PTR(ret);\n}", "target": 1}
{"code": "static u32 gasp_version(__be32 *p)\n{\n\treturn be32_to_cpu(p[1]) & 0xffffff;\n}", "target": 0}
{"code": "int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t\tstruct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint err;\n\tBT_DBG(\"sock %p sk %p len %zu\", sock, sk, len);\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb) {\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN) {\n\t\t\tmsg->msg_namelen = 0;\n\t\t\treturn 0;\n\t\t}\n\t\treturn err;\n\t}\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err == 0) {\n\t\tsock_recv_ts_and_drops(msg, sk, skb);\n\t\tif (bt_sk(sk)->skb_msg_name)\n\t\t\tbt_sk(sk)->skb_msg_name(skb, msg->msg_name,\n\t\t\t\t\t\t&msg->msg_namelen);\n\t\telse\n\t\t\tmsg->msg_namelen = 0;\n\t}\n\tskb_free_datagram(sk, skb);\n\treturn err ? : copied;\n}", "target": 1}
{"code": "    template<typename t>\n    CImg<_cimg_Ttfloat> get_correlate(const CImg<t>& kernel, const bool boundary_conditions=true,\n                                      const bool is_normalized=false) const {\n      return _correlate(kernel,boundary_conditions,is_normalized,false);", "target": 0}
{"code": "mrb_singleton_class_ptr(mrb_state *mrb, mrb_value v)\n{\n  struct RBasic *obj;\n  switch (mrb_type(v)) {\n  case MRB_TT_FALSE:\n    if (mrb_nil_p(v))\n      return mrb->nil_class;\n    return mrb->false_class;\n  case MRB_TT_TRUE:\n    return mrb->true_class;\n  case MRB_TT_CPTR:\n  case MRB_TT_SYMBOL:\n  case MRB_TT_INTEGER:\n#ifndef MRB_NO_FLOAT\n  case MRB_TT_FLOAT:\n#endif\n    return NULL;\n  default:\n    break;\n  }\n  obj = mrb_basic_ptr(v);\n  if (obj->c == NULL) return NULL;\n  prepare_singleton_class(mrb, obj);\n  return obj->c;\n}", "target": 0}
{"code": "set_string_2_svc(sstring_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,\n                               arg->princ, NULL)) {\n        ret.code = KADM5_AUTH_MODIFY;\n        log_unauth(\"kadm5_mod_strings\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_set_string((void *)handle, arg->princ, arg->key,\n                                    arg->value);\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_mod_strings\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "void Curl_attach_connnection(struct Curl_easy *data,\n                             struct connectdata *conn)\n{\n  DEBUGASSERT(!data->conn);\n  DEBUGASSERT(conn);\n  data->conn = conn;\n  Curl_llist_insert_next(&conn->easyq, conn->easyq.tail, data,\n                         &data->conn_queue);\n  if(conn->handler->attach)\n    conn->handler->attach(data, conn);\n  Curl_ssl_associate_conn(data, conn);\n}", "target": 0}
{"code": "static bool reg_type_may_be_null(enum bpf_reg_type type)\n{\n\treturn type == PTR_TO_MAP_VALUE_OR_NULL ||\n\t       type == PTR_TO_SOCKET_OR_NULL ||\n\t       type == PTR_TO_SOCK_COMMON_OR_NULL ||\n\t       type == PTR_TO_TCP_SOCK_OR_NULL;\n}", "target": 0}
{"code": "finalize_subnode_array(apr_array_header_t *array,\n                       limited_rights_t *sum,\n                       apr_pool_t *scratch_pool)\n{\n  if (array)\n    {\n      int i;\n      for (i = 0; i < array->nelts; ++i)\n        finalize_tree(APR_ARRAY_IDX(array, i, sorted_pattern_t).node, sum,\n                      scratch_pool);\n    }\n}", "target": 0}
{"code": "parse_CT_CLEAR(char *arg OVS_UNUSED, const struct ofpact_parse_params *pp)\n{\n    ofpact_put_CT_CLEAR(pp->ofpacts);\n    return NULL;\n}", "target": 0}
{"code": "void FrameLoader::frameDetached()\n{\n    stopAllLoaders();\n    m_frame->document()->stopActiveDOMObjects();\n    detachFromParent();\n}", "target": 0}
{"code": "  absl::string_view failureReason() const override { return NotReadyReason; }", "target": 0}
{"code": "optional<ARN> ARN::parse(const string& s, bool wildcards) {\n  static const char str_wild[] = \"arn:([^:]*):([^:]*):([^:]*):([^:]*):([^:]*)\";\n  static const regex rx_wild(str_wild,\n\t\t\t\t    sizeof(str_wild) - 1,\n\t\t\t\t    ECMAScript | optimize);\n  static const char str_no_wild[]\n    = \"arn:([^:*]*):([^:*]*):([^:*]*):([^:*]*):([^:*]*)\";\n  static const regex rx_no_wild(str_no_wild,\n\t\t\t\tsizeof(str_no_wild) - 1,\n\t\t\t\tECMAScript | optimize);\n  smatch match;\n  if ((s == \"*\") && wildcards) {\n    return ARN(Partition::wildcard, Service::wildcard, \"*\", \"*\", \"*\");\n  } else if (regex_match(s, match, wildcards ? rx_wild : rx_no_wild)) {\n    ceph_assert(match.size() == 6);\n    ARN a;\n    {\n      auto p = to_partition(match[1], wildcards);\n      if (!p)\n\treturn none;\n      a.partition = *p;\n    }\n    {\n      auto s = to_service(match[2], wildcards);\n      if (!s) {\n\treturn none;\n      }\n      a.service = *s;\n    }\n    a.region = match[3];\n    a.account = match[4];\n    a.resource = match[5];\n    return a;\n  }\n  return none;\n}", "target": 1}
{"code": "chpass_principal_2_svc(chpass_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ)) {\n        ret.code = chpass_principal_wrapper_3((void *)handle, arg->princ,\n                                              FALSE, 0, NULL, arg->pass);\n    } else if (!(CHANGEPW_SERVICE(rqstp)) &&\n               kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                  ACL_CHANGEPW, arg->princ, NULL)) {\n        ret.code = kadm5_chpass_principal((void *)handle, arg->princ,\n                                          arg->pass);\n    } else {\n        log_unauth(\"kadm5_chpass_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_CHANGEPW;\n    }\n    if (ret.code != KADM5_AUTH_CHANGEPW) {\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_chpass_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "ImagingConvertInPlace(Imaging imIn, const char *mode) {\n    ImagingSectionCookie cookie;\n    ImagingShuffler convert;\n    int y;\n    if (strcmp(imIn->mode, \"L\") == 0 && strcmp(mode, \"1\") == 0) {\n        convert = l2bit;\n    } else if (strcmp(imIn->mode, \"1\") == 0 && strcmp(mode, \"L\") == 0) {\n        convert = bit2l;\n    } else {\n        return ImagingError_ModeError();\n    }\n    ImagingSectionEnter(&cookie);\n    for (y = 0; y < imIn->ysize; y++) {\n        (*convert)((UINT8 *)imIn->image[y], (UINT8 *)imIn->image[y], imIn->xsize);\n    }\n    ImagingSectionLeave(&cookie);\n    return imIn;\n}", "target": 0}
{"code": "static int write_empty_blocks(struct page *page, unsigned from, unsigned to,\n\t\t\t      int mode)\n{\n\tstruct inode *inode = page->mapping->host;\n\tunsigned start, end, next, blksize;\n\tsector_t block = page->index << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tint ret;\n\tblksize = 1 << inode->i_blkbits;\n\tnext = end = 0;\n\twhile (next < from) {\n\t\tnext += blksize;\n\t\tblock++;\n\t}\n\tstart = next;\n\tdo {\n\t\tnext += blksize;\n\t\tret = needs_empty_write(block, inode);\n\t\tif (unlikely(ret < 0))\n\t\t\treturn ret;\n\t\tif (ret == 0) {\n\t\t\tif (end) {\n\t\t\t\tret = __block_write_begin(page, start, end - start,\n\t\t\t\t\t\t\t  gfs2_block_map);\n\t\t\t\tif (unlikely(ret))\n\t\t\t\t\treturn ret;\n\t\t\t\tret = empty_write_end(page, start, end, mode);\n\t\t\t\tif (unlikely(ret))\n\t\t\t\t\treturn ret;\n\t\t\t\tend = 0;\n\t\t\t}\n\t\t\tstart = next;\n\t\t}\n\t\telse\n\t\t\tend = next;\n\t\tblock++;\n\t} while (next < to);\n\tif (end) {\n\t\tret = __block_write_begin(page, start, end - start, gfs2_block_map);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t\tret = empty_write_end(page, start, end, mode);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void rose_idletimer_expiry(struct timer_list *t)\n{\n\tstruct rose_sock *rose = from_timer(rose, t, idletimer);\n\tstruct sock *sk = &rose->sock;\n\tbh_lock_sock(sk);\n\trose_clear_queues(sk);\n\trose_write_internal(sk, ROSE_CLEAR_REQUEST);\n\trose_sk(sk)->state = ROSE_STATE_2;\n\trose_start_t3timer(sk);\n\tsk->sk_state     = TCP_CLOSE;\n\tsk->sk_err       = 0;\n\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tsk->sk_state_change(sk);\n\t\tsock_set_flag(sk, SOCK_DEAD);\n\t}\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}", "target": 0}
{"code": "static bool append_rets(RStrBuf *sb, RBinWasmTypeVec *rets) {\n\tbool ret = true;\n\tif (!rets->count) {\n\t\tret &= r_strbuf_append (sb, \"nil\");\n\t} else if (rets->count == 1) {\n\t\tret &= r_strbuf_append (sb, r_bin_wasm_valuetype_to_string (rets->types[0]));\n\t} else {\n\t\tret &= strbuf_append_type_vec (sb, rets);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "bool is_valid_status(const string& s) {\n  return (s == \"Enabled\" ||\n          s == \"Disabled\");\n}", "target": 0}
{"code": "static int _gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)\n{\n\tint x, y, pos;\n\tWbmp *wbmp;\n\tif((wbmp = createwbmp(gdImageSX(image), gdImageSY(image), WBMP_WHITE)) == NULL) {\n\t\tgd_error(\"Could not create WBMP\\n\");\n\t\treturn 1;\n\t}\n\tpos = 0;\n\tfor(y = 0; y < gdImageSY(image); y++) {\n\t\tfor(x = 0; x < gdImageSX(image); x++) {\n\t\t\tif(gdImageGetPixel(image, x, y) == fg) {\n\t\t\t\twbmp->bitmap[pos] = WBMP_BLACK;\n\t\t\t}\n\t\t\tpos++;\n\t\t}\n\t}\n\tif(writewbmp(wbmp, &gd_putout, out)) {\n\t\tfreewbmp(wbmp);\n\t\tgd_error(\"Could not save WBMP\\n\");\n\t\treturn 1;\n\t}\n\tfreewbmp(wbmp);\n\treturn 0;\n}", "target": 0}
{"code": "void test_checkout_nasty__dotgit_alternate_data_stream(void)\n{\n\ttest_checkout_fails(\"refs/heads/dotgit_alternate_data_stream\", \".git/dummy-file\");\n\ttest_checkout_fails(\"refs/heads/dotgit_alternate_data_stream\", \".git::$INDEX_ALLOCATION/dummy-file\");\n}", "target": 0}
{"code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteDivParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n  const TfLiteTensor* input1;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor1, &input1));\n  const TfLiteTensor* input2;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor2, &input2));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n#define TF_LITE_CHECK_DIV_NON_ZERO(data_type)                       \\\n  const auto* input2_data = GetTensorData<data_type>(input2);       \\\n  const size_t input2_elements = input2->bytes / sizeof(data_type); \\\n  for (size_t i = 0; i < input2_elements; i++) {                    \\\n    TF_LITE_ENSURE(context, input2_data[i] != 0);                   \\\n  }\n  if (output->type == kTfLiteFloat32) {\n    EvalDiv<kernel_type>(context, node, params, data, input1, input2, output);\n  } else if (output->type == kTfLiteInt32) {\n    TF_LITE_CHECK_DIV_NON_ZERO(int32_t);\n    EvalDiv<kernel_type>(context, node, params, data, input1, input2, output);\n  } else if (output->type == kTfLiteUInt8) {\n    TF_LITE_CHECK_DIV_NON_ZERO(uint8_t);\n    TF_LITE_ENSURE_OK(\n        context, EvalQuantized<kernel_type>(context, node, params, data, input1,\n                                            input2, output));\n  } else {\n    context->ReportError(\n        context,\n        \"Div only supports FLOAT32, INT32 and quantized UINT8 now, got %d.\",\n        output->type);\n    return kTfLiteError;\n  }\n#undef TF_LITE_CHECK_DIV_NON_ZERO\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static RzList *classes_from_symbols(RzBinFile *bf) {\n\tRzBinSymbol *sym;\n\tRzListIter *iter;\n\trz_list_foreach (bf->o->symbols, iter, sym) {\n\t\tif (sym->name[0] != '_') {\n\t\t\tcontinue;\n\t\t}\n\t\tconst char *cn = sym->classname;\n\t\tif (cn) {\n\t\t\tRzBinClass *c = rz_bin_file_add_class(bf, sym->classname, NULL, 0);\n\t\t\tif (!c) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tchar *dn = sym->dname;\n\t\t\tchar *fn = swiftField(dn, cn);\n\t\t\tif (fn) {\n\t\t\t\tRzBinField *f = rz_bin_field_new(sym->paddr, sym->vaddr, sym->size, fn, NULL, NULL, false);\n\t\t\t\trz_list_append(c->fields, f);\n\t\t\t\tfree(fn);\n\t\t\t} else {\n\t\t\t\tchar *mn = strstr(dn, \"..\");\n\t\t\t\tif (!mn) {\n\t\t\t\t\tmn = strstr(dn, cn);\n\t\t\t\t\tif (mn && mn[strlen(cn)] == '.') {\n\t\t\t\t\t\trz_list_append(c->methods, sym);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn bf->o->classes;\n}", "target": 1}
{"code": "static Image *ExtractPostscript(Image *image,const ImageInfo *image_info,\n  MagickOffsetType PS_Offset,ssize_t PS_Size,ExceptionInfo *exception)\n{\n  char\n    postscript_file[MagickPathExtent];\n  const MagicInfo\n    *magic_info;    \n  FILE\n    *ps_file;\n  ImageInfo\n    *clone_info;\n  Image\n    *image2;\n  unsigned char\n    magick[2*MagickPathExtent];    \n  if ((clone_info=CloneImageInfo(image_info)) == NULL)\n    return(image);\n  clone_info->blob=(void *) NULL;\n  clone_info->length=0;\n  (void) AcquireUniqueFilename(postscript_file);\n  ps_file=fopen_utf8(postscript_file,\"wb\");\n  if (ps_file == (FILE *) NULL)\n    goto FINISH;\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  (void) ReadBlob(image, 2*MagickPathExtent, magick);\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  while(PS_Size-- > 0)\n    {\n      (void) fputc(ReadBlobByte(image),ps_file);\n    }\n  (void) fclose(ps_file);\n  magic_info=GetMagicInfo(magick,2*MagickPathExtent,exception);\n  if(magic_info == (const MagicInfo *) NULL) goto FINISH_UNL;\n  if(exception->severity != UndefinedException) goto FINISH_UNL;     \n  if(magic_info->name == (char *) NULL) goto FINISH_UNL;\n  (void) CopyMagickMemory(clone_info->magick,magic_info->name,MagickPathExtent);\n  FormatLocaleString(clone_info->filename,MagickPathExtent,\"%s\",postscript_file);\n  image2=ReadImage(clone_info,exception);\n  if (!image2)\n    goto FINISH_UNL;\n  (void) CopyMagickMemory(image2->filename,image->filename,MagickPathExtent);\n  (void) CopyMagickMemory(image2->magick_filename,image->magick_filename,MagickPathExtent);\n  (void) CopyMagickMemory(image2->magick,image->magick,MagickPathExtent);\n  image2->depth=image->depth;\n  DestroyBlob(image2);\n  image2->blob=ReferenceBlob(image->blob);\n  if ((image->rows == 0) || (image->columns == 0))\n    DeleteImageFromList(&image);\n  AppendImageToList(&image,image2);\n FINISH_UNL:    \n  (void) RelinquishUniqueFileResource(postscript_file);\n FINISH:\n  DestroyImageInfo(clone_info);\n  return(image);\n}", "target": 1}
{"code": "static int jpeg_size(unsigned char* data, unsigned int data_size,\n                     int *width, int *height)\n{\n    int i = 0;\n    if (i + 3 < data_size && data[i] == 0xFF && data[i+1] == 0xD8 &&\n            data[i+2] == 0xFF && data[i+3] == 0xE0) {\n        i += 4;\n        if(i + 6 < data_size &&\n                data[i+2] == 'J' && data[i+3] == 'F' && data[i+4] == 'I' &&\n                data[i+5] == 'F' && data[i+6] == 0x00) {\n            unsigned short block_length = data[i] * 256 + data[i+1];\n            while(i<data_size) {\n                i+=block_length;\n                if((i + 1) >= data_size)\n                    return -1;\n                if(data[i] != 0xFF)\n                    return -1;\n                if(data[i+1] == 0xC0) {\n                    *height = data[i+5]*256 + data[i+6];\n                    *width = data[i+7]*256 + data[i+8];\n                    return 0;\n                }\n                i+=2;\n                block_length = data[i] * 256 + data[i+1];\n            }\n        }\n    }\n    return -1;\n}", "target": 1}
{"code": "void AICast_ScriptLoad( void ) {\n\tchar filename[MAX_QPATH];\n\tvmCvar_t mapname;\n\tfileHandle_t f;\n\tint len;\n\tlevel.scriptAI = NULL;\n\ttrap_Cvar_VariableStringBuffer( \"ai_scriptName\", filename, sizeof( filename ) );\n\tif ( strlen( filename ) > 0 ) {\n\t\ttrap_Cvar_Register( &mapname, \"ai_scriptName\", \"\", CVAR_ROM );\n\t} else {\n\t\ttrap_Cvar_Register( &mapname, \"mapname\", \"\", CVAR_SERVERINFO | CVAR_ROM );\n\t}\n\tQ_strncpyz( filename, \"maps/\", sizeof( filename ) );\n\tQ_strcat( filename, sizeof( filename ), mapname.string );\n\tif ( g_gametype.integer <= GT_COOP ) {\n\t\tQ_strcat( filename, sizeof( filename ), \".coop.ai\" );\n\t} else {\n\t\tQ_strcat( filename, sizeof( filename ), \".ai\" );\n\t}\n\tlen = trap_FS_FOpenFile( filename, &f, FS_READ );\n\tG_Printf( \"Loading: %s\\n\", filename );\n\tif ( len < 0 ) {\n\t\treturn;\n\t}\n\tlevel.scriptAI = G_Alloc( len );\n\ttrap_FS_Read( level.scriptAI, len, f );\n\ttrap_FS_FCloseFile( f );\n\treturn;\n}", "target": 1}
{"code": "EXPORTED int examine_request(struct transaction_t *txn, const char *uri)\n{\n    int ret = 0, sasl_result = 0;\n    const char *query;\n    const struct namespace_t *namespace;\n    struct request_line_t *req_line = &txn->req_line;\n    if (!uri) uri = req_line->uri;\n    if ((ret = check_method(txn))) return ret;\n    if (!(txn->req_uri = parse_uri(txn->meth, uri, 1, &txn->error.desc))) {\n        return HTTP_BAD_REQUEST;\n    }\n    if ((ret = preauth_check_hdrs(txn))) return ret;\n    if ((ret = check_namespace(txn))) return ret;\n    ret = auth_check_hdrs(txn, &sasl_result);\n    if (ret && ret != HTTP_UNAUTHORIZED) return ret;\n    namespace = txn->req_tgt.namespace;\n    buf_printf(&txn->buf, \"%s%s\", config_ident,\n               namespace->well_known ? strrchr(namespace->well_known, '/') :\n               namespace->prefix);\n    proc_register(buf_cstring(&txn->buf), txn->conn->clienthost, httpd_userid,\n                  txn->req_tgt.path, txn->req_line.meth);\n    buf_reset(&txn->buf);\n    if (!httpd_userid && namespace->need_auth(txn)) {\n        ret = HTTP_UNAUTHORIZED;\n    }\n    if (ret) return client_need_auth(txn, sasl_result);\n    construct_hash_table(&txn->req_qparams, 10, 1);\n    query = URI_QUERY(txn->req_uri);\n    if (query) parse_query_params(txn, query);\n    postauth_check_hdrs(txn);\n    return 0;\n}", "target": 0}
{"code": "int hashtable_init(hashtable_t *hashtable)\n{\n    size_t i;\n    hashtable->size = 0;\n    hashtable->num_buckets = 0;  \n    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));\n    if(!hashtable->buckets)\n        return -1;\n    list_init(&hashtable->list);\n    for(i = 0; i < num_buckets(hashtable); i++)\n    {\n        hashtable->buckets[i].first = hashtable->buckets[i].last =\n            &hashtable->list;\n    }\n    return 0;\n}", "target": 1}
{"code": "int SSL_select_next_proto(unsigned char **out, unsigned char *outlen,\n                          const unsigned char *server,\n                          unsigned int server_len,\n                          const unsigned char *client, unsigned int client_len)\n{\n    unsigned int i, j;\n    const unsigned char *result;\n    int status = OPENSSL_NPN_UNSUPPORTED;\n    for (i = 0; i < server_len;) {\n        for (j = 0; j < client_len;) {\n            if (server[i] == client[j] &&\n                memcmp(&server[i + 1], &client[j + 1], server[i]) == 0) {\n                result = &server[i];\n                status = OPENSSL_NPN_NEGOTIATED;\n                goto found;\n            }\n            j += client[j];\n            j++;\n        }\n        i += server[i];\n        i++;\n    }\n    result = client;\n    status = OPENSSL_NPN_NO_OVERLAP;\n found:\n    *out = (unsigned char *)result + 1;\n    *outlen = result[0];\n    return status;\n}", "target": 1}
{"code": "static void copyIPv6IfDifferent(void * dest, const void * src)\n{\n\tif(dest != src) {\n\t\tmemcpy(dest, src, sizeof(struct in6_addr));\n\t}\n}", "target": 1}
{"code": "int BN_bn2bin(const BIGNUM *a, unsigned char *to)\n{\n    return bn2binpad(a, to, -1);\n}", "target": 0}
{"code": "mm_destroy(struct mm_master *mm)\n{\n\tmm_freelist(mm->mmalloc, &mm->rb_free);\n\tmm_freelist(mm->mmalloc, &mm->rb_allocated);\n\tif (munmap(mm->address, mm->size) == -1)\n\t\tfatal(\"munmap(%p, %zu): %s\", mm->address, mm->size,\n\t\t    strerror(errno));\n\tif (mm->mmalloc == NULL)\n\t\tfree(mm);\n\telse\n\t\tmm_free(mm->mmalloc, mm);\n}", "target": 1}
{"code": "rad_get_vendor_attr(u_int32_t *vendor, const void **data, size_t *len)\n{\n\tstruct vendor_attribute *attr;\n\tattr = (struct vendor_attribute *)*data;\n\t*vendor = ntohl(attr->vendor_value);\n\t*data = attr->attrib_data;\n\t*len = attr->attrib_len - 2;\n\treturn (attr->attrib_type);\n}", "target": 1}
{"code": "void CharToWideMap(const char *Src,wchar *Dest,size_t DestSize,bool &Success)\n{\n  Success=false;\n  bool MarkAdded=false;\n  uint SrcPos=0,DestPos=0;\n  while (DestPos<DestSize)\n  {\n    if (Src[SrcPos]==0)\n    {\n      Success=true;\n      break;\n    }\n    mbstate_t ps;\n    memset(&ps,0,sizeof(ps));\n    if (mbrtowc(Dest+DestPos,Src+SrcPos,MB_CUR_MAX,&ps)==-1)\n    {\n      if (byte(Src[SrcPos])>=0x80)\n      {\n        if (!MarkAdded)\n        {\n          Dest[DestPos++]=MappedStringMark;\n          MarkAdded=true;\n          if (DestPos>=DestSize)\n            break;\n        }\n        Dest[DestPos++]=byte(Src[SrcPos++])+MapAreaStart;\n      }\n      else\n        break;\n    }\n    else\n    {\n      memset(&ps,0,sizeof(ps));\n      int Length=mbrlen(Src+SrcPos,MB_CUR_MAX,&ps);\n      SrcPos+=Max(Length,1);\n      DestPos++;\n    }\n  }\n  Dest[Min(DestPos,DestSize-1)]=0;\n}", "target": 1}
{"code": "bool SVGAnimateElement::calculateFromAndToValues(const String& fromString, const String& toString)\n{\n    SVGElement* targetElement = this->targetElement();\n    if (!targetElement)\n        return false;\n    determinePropertyValueTypes(fromString, toString);\n    ensureAnimator()->calculateFromAndToValues(m_fromType, m_toType, fromString, toString);\n    ASSERT(m_animatedPropertyType == m_animator->type());\n    return true;\n}", "target": 0}
{"code": "MONGO_EXPORT mongo_cursor *gridfile_get_chunks( gridfile *gfile, int start, int size ) {\n    bson_iterator it;\n    bson_oid_t id;\n    bson gte;\n    bson query;\n    bson orderby;\n    bson command;\n    mongo_cursor *cursor;\n    bson_find( &it, gfile->meta, \"_id\" );\n    id = *bson_iterator_oid( &it );\n    bson_init( &query );\n    bson_append_oid( &query, \"files_id\", &id );\n    if ( size == 1 ) {\n        bson_append_int( &query, \"n\", start );\n    }\n    else {\n        bson_init( &gte );\n        bson_append_int( &gte, \"$gte\", start );\n        bson_finish( &gte );\n        bson_append_bson( &query, \"n\", &gte );\n        bson_destroy( &gte );\n    }\n    bson_finish( &query );\n    bson_init( &orderby );\n    bson_append_int( &orderby, \"n\", 1 );\n    bson_finish( &orderby );\n    bson_init( &command );\n    bson_append_bson( &command, \"query\", &query );\n    bson_append_bson( &command, \"orderby\", &orderby );\n    bson_finish( &command );\n    cursor = mongo_find( gfile->gfs->client, gfile->gfs->chunks_ns,\n                         &command, NULL, size, 0, 0 );\n    bson_destroy( &command );\n    bson_destroy( &query );\n    bson_destroy( &orderby );\n    return cursor;\n}", "target": 1}
{"code": "static BYTE get_bpp_bmf(UINT32 bpp, BOOL* pValid)\n{\n\tif (pValid)\n\t\t*pValid = TRUE;\n\tswitch (bpp)\n\t{\n\t\tcase 1:\n\t\t\treturn 1;\n\t\tcase 8:\n\t\t\treturn 3;\n\t\tcase 16:\n\t\t\treturn 4;\n\t\tcase 24:\n\t\t\treturn 5;\n\t\tcase 32:\n\t\t\treturn 6;\n\t\tdefault:\n\t\t\tWLog_WARN(TAG, \"Invalid color depth %\" PRIu32, bpp);\n\t\t\tif (pValid)\n\t\t\t\t*pValid = FALSE;\n\t\t\treturn 0;\n\t}\n}", "target": 0}
{"code": "load_kernel_module_list (void)\n{\n  GHashTable *modules = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n  g_autofree char *modules_data = NULL;\n  g_autoptr(GError) error = NULL;\n  char *start, *end;\n  if (!g_file_get_contents (\"/proc/modules\", &modules_data, NULL, &error))\n    {\n      g_info (\"Failed to read /proc/modules: %s\", error->message);\n      return modules;\n    }\n  start = modules_data;\n  while (TRUE)\n    {\n      end = strchr (start, ' ');\n      if (end == NULL)\n        break;\n      g_hash_table_add (modules, g_strndup (start, (end - start)));\n      start = strchr (end, '\\n');\n      if (start == NULL)\n        break;\n      start++;\n    }\n  return modules;\n}", "target": 1}
{"code": "u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport)\n{\n\tstruct keydata *keyptr = get_keyptr();\n\tu32 hash[4];\n\thash[0] = (__force u32)saddr;\n\thash[1] = (__force u32)daddr;\n\thash[2] = (__force u32)dport ^ keyptr->secret[10];\n\thash[3] = keyptr->secret[11];\n\treturn half_md4_transform(hash, keyptr->secret);\n}", "target": 1}
{"code": "static int sd_isoc_init(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_host_interface *alt;\n\tint max_packet_size;\n\tswitch (gspca_dev->pixfmt.width) {\n\tcase 160:\n\t\tmax_packet_size = 450;\n\t\tbreak;\n\tcase 176:\n\t\tmax_packet_size = 600;\n\t\tbreak;\n\tdefault:\n\t\tmax_packet_size = 1022;\n\t\tbreak;\n\t}\n\talt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];\n\talt->endpoint[0].desc.wMaxPacketSize = cpu_to_le16(max_packet_size);\n\treturn 0;\n}", "target": 1}
{"code": "const AtomicString& HTMLInputElement::defaultValue() const\n{\n    return fastGetAttribute(valueAttr);\n}", "target": 0}
{"code": "void AllocateDataSet(cmsIT8* it8)\n{\n    TABLE* t = GetTable(it8);\n    if (t -> Data) return;    \n    t-> nSamples   = atoi(cmsIT8GetProperty(it8, \"NUMBER_OF_FIELDS\"));\n    t-> nPatches   = atoi(cmsIT8GetProperty(it8, \"NUMBER_OF_SETS\"));\n    t-> Data = (char**)AllocChunk (it8, ((cmsUInt32Number) t->nSamples + 1) * ((cmsUInt32Number) t->nPatches + 1) *sizeof (char*));\n    if (t->Data == NULL) {\n        SynError(it8, \"AllocateDataSet: Unable to allocate data array\");\n    }\n}", "target": 1}
{"code": "DeletePortMappingRange(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r = -1;\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"</u:%sResponse>\";\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tconst char * protocol;\n\tconst char * startport_s, * endport_s;\n\tunsigned short startport, endport;\n\tunsigned short * port_list;\n\tunsigned int i, number = 0;\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tstartport_s = GetValueFromNameValueList(&data, \"NewStartPort\");\n\tendport_s = GetValueFromNameValueList(&data, \"NewEndPort\");\n\tprotocol = GetValueFromNameValueList(&data, \"NewProtocol\");\n\tif(startport_s == NULL || endport_s == NULL || protocol == NULL ||\n\t   !is_numeric(startport_s) || !is_numeric(endport_s)) {\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\tClearNameValueList(&data);\n\t\treturn;\n\t}\n\tstartport = (unsigned short)atoi(startport_s);\n\tendport = (unsigned short)atoi(endport_s);\n\tif(startport > endport)\n\t{\n\t\tSoapError(h, 733, \"InconsistentParameter\");\n\t\tClearNameValueList(&data);\n\t\treturn;\n\t}\n\tsyslog(LOG_INFO, \"%s: deleting external ports: %hu-%hu, protocol: %s\",\n\t       action, startport, endport, protocol);\n\tport_list = upnp_get_portmappings_in_range(startport, endport,\n\t                                           protocol, &number);\n\tif(number == 0)\n\t{\n\t\tSoapError(h, 730, \"PortMappingNotFound\");\n\t\tClearNameValueList(&data);\n\t\tfree(port_list);\n\t\treturn;\n\t}\n\tfor(i = 0; i < number; i++)\n\t{\n\t\tr = upnp_delete_redirection(port_list[i], protocol);\n\t\tsyslog(LOG_INFO, \"%s: deleting external port: %hu, protocol: %s: %s\",\n\t\t       action, port_list[i], protocol, r < 0 ? \"failed\" : \"ok\");\n\t}\n\tfree(port_list);\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t                   action, ns, action);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\tClearNameValueList(&data);\n}", "target": 0}
{"code": "static int java_switch_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\n\tut8 op_byte = data[0];\n\tut64 offset = addr - java_get_method_start ();\n\tut8 pos = (offset+1)%4 ? 1 + 4 - (offset+1)%4 : 1;\n\tif (op_byte == 0xaa) {\n\t\tif (pos + 8 > len) {\n\t\t\treturn op->size;\n\t\t}\n\t\tint min_val = (ut32)(UINT (data, pos + 4)),\n\t\t\tmax_val = (ut32)(UINT (data, pos + 8));\n\t\tut32 default_loc = (ut32) (UINT (data, pos)), cur_case = 0;\n\t\top->switch_op = r_anal_switch_op_new (addr, min_val, default_loc);\n\t\tRAnalCaseOp *caseop = NULL;\n\t\tpos += 12;\n\t\tif (max_val > min_val && ((max_val - min_val)<(UT16_MAX/4))) {\n\t\t\tfor (cur_case = 0; cur_case <= max_val - min_val; pos += 4, cur_case++) {\n\t\t\t\tif (pos + 4 >= len) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint offset = (int)(ut32)(R_BIN_JAVA_UINT (data, pos));\n\t\t\t\tcaseop = r_anal_switch_op_add_case (op->switch_op,\n\t\t\t\t\taddr + pos, cur_case + min_val, addr + offset);\n\t\t\t\tif (caseop) {\n\t\t\t\t\tcaseop->bb_ref_to = addr+offset;\n\t\t\t\t\tcaseop->bb_ref_from = addr; \n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Invalid switch boundaries at 0x%\"PFMT64x\"\\n\", addr);\n\t\t}\n\t}\n\top->size = pos;\n\treturn op->size;\n}", "target": 1}
{"code": "vhost_scsi_send_evt(struct vhost_scsi *vs,\n\t\t   struct vhost_scsi_tpg *tpg,\n\t\t   struct se_lun *lun,\n\t\t   u32 event,\n\t\t   u32 reason)\n{\n\tstruct vhost_scsi_evt *evt;\n\tevt = vhost_scsi_allocate_evt(vs, event, reason);\n\tif (!evt)\n\t\treturn;\n\tif (tpg && lun) {\n\t\tevt->event.lun[0] = 0x01;\n\t\tevt->event.lun[1] = tpg->tport_tpgt & 0xFF;\n\t\tif (lun->unpacked_lun >= 256)\n\t\t\tevt->event.lun[2] = lun->unpacked_lun >> 8 | 0x40 ;\n\t\tevt->event.lun[3] = lun->unpacked_lun & 0xFF;\n\t}\n\tllist_add(&evt->list, &vs->vs_event_list);\n\tvhost_work_queue(&vs->dev, &vs->vs_event_work);\n}", "target": 1}
{"code": "static void blk_mq_freeze_queue_wait(struct request_queue *q)\n{\n\twait_event(q->mq_freeze_wq, percpu_ref_is_zero(&q->mq_usage_counter));\n}", "target": 0}
{"code": "wchar* ConvertPath(const wchar *SrcPath,wchar *DestPath,size_t DestSize)\n{\n  const wchar *DestPtr=SrcPath;\n  for (const wchar *s=DestPtr;*s!=0;s++)\n    if (IsPathDiv(s[0]) && s[1]=='.' && s[2]=='.' && IsPathDiv(s[3]))\n      DestPtr=s+4;\n  while (*DestPtr!=0)\n  {\n    const wchar *s=DestPtr;\n    if (s[0]!=0 && IsDriveDiv(s[1]))\n      s+=2;\n    if (s[0]=='\\\\' && s[1]=='\\\\')\n    {\n      const wchar *Slash=wcschr(s+2,'\\\\');\n      if (Slash!=NULL && (Slash=wcschr(Slash+1,'\\\\'))!=NULL)\n        s=Slash+1;\n    }\n    for (const wchar *t=s;*t!=0;t++)\n      if (IsPathDiv(*t))\n        s=t+1;\n      else\n        if (*t!='.')\n          break;\n    if (s==DestPtr)\n      break;\n    DestPtr=s;\n  }\n  if (DestPtr[0]=='.' && DestPtr[1]=='.' && DestPtr[2]==0)\n    DestPtr+=2;\n  if (DestPath!=NULL)\n  {\n    wchar TmpStr[NM];\n    wcsncpyz(TmpStr,DestPtr,ASIZE(TmpStr));\n    wcsncpyz(DestPath,TmpStr,DestSize);\n  }\n  return (wchar *)DestPtr;\n}", "target": 1}
{"code": "OE_INLINE void _handle_oret(\n    oe_sgx_td_t* td,\n    uint16_t func,\n    uint16_t result,\n    uint64_t arg)\n{\n    oe_callsite_t* callsite = td->callsites;\n    if (!callsite)\n        return;\n    td->oret_func = func;\n    td->oret_result = result;\n    td->oret_arg = arg;\n    asm volatile(\"pushq %[rflags] \\n\\t\" \n                 \"popfq \\n\\t\"\n                 \"fldcw %[fcw] \\n\\t\"     \n                 \"ldmxcsr %[mxcsr] \\n\\t\" \n                 : [mxcsr] \"=m\"(callsite->mxcsr),\n                   [fcw] \"=m\"(callsite->fcw),\n                   [rflags] \"=m\"(callsite->rflags)\n                 :\n                 : \"cc\");\n    oe_longjmp(&callsite->jmpbuf, 1);\n}", "target": 1}
{"code": "bool LIRGenerator::can_store_as_constant(Value v, BasicType type) const {\n  if (type == T_SHORT || type == T_CHAR) {\n    return false;\n  }\n  Constant* c = v->as_Constant();\n  if (c && c->state_before() == NULL) {\n    return true;\n  }\n  return false;\n}", "target": 0}
{"code": "static inline ut8 r_read_ble8(const void *src) {\n\tif (!src) {\n\t\treturn UT8_MAX;\n\t}\n\treturn *(ut8 *)src;\n}", "target": 0}
{"code": "void MSG_WriteBits( msg_t *msg, int value, int bits ) {\n\tint\ti;\n\toldsize += bits;\n\tif ( msg->maxsize - msg->cursize < 4 ) {\n\t\tmsg->overflowed = qtrue;\n\t\treturn;\n\t}\n\tif ( bits == 0 || bits < -31 || bits > 32 ) {\n\t\tCom_Error( ERR_DROP, \"MSG_WriteBits: bad bits %i\", bits );\n\t}\n\tif ( bits < 0 ) {\n\t\tbits = -bits;\n\t}\n\tif ( msg->oob ) {\n\t\tif ( bits == 8 ) {\n\t\t\tmsg->data[msg->cursize] = value;\n\t\t\tmsg->cursize += 1;\n\t\t\tmsg->bit += 8;\n\t\t} else if ( bits == 16 ) {\n\t\t\tshort temp = value;\n\t\t\tCopyLittleShort( &msg->data[msg->cursize], &temp );\n\t\t\tmsg->cursize += 2;\n\t\t\tmsg->bit += 16;\n\t\t} else if ( bits==32 ) {\n\t\t\tCopyLittleLong( &msg->data[msg->cursize], &value );\n\t\t\tmsg->cursize += 4;\n\t\t\tmsg->bit += 32;\n\t\t} else {\n\t\t\tCom_Error( ERR_DROP, \"can't write %d bits\", bits );\n\t\t}\n\t} else {\n\t\tvalue &= (0xffffffff >> (32 - bits));\n\t\tif ( bits&7 ) {\n\t\t\tint nbits;\n\t\t\tnbits = bits&7;\n\t\t\tfor( i = 0; i < nbits; i++ ) {\n\t\t\t\tHuff_putBit( (value & 1), msg->data, &msg->bit );\n\t\t\t\tvalue = (value >> 1);\n\t\t\t}\n\t\t\tbits = bits - nbits;\n\t\t}\n\t\tif ( bits ) {\n\t\t\tfor( i = 0; i < bits; i += 8 ) {\n\t\t\t\tHuff_offsetTransmit( &msgHuff.compressor, (value & 0xff), msg->data, &msg->bit );\n\t\t\t\tvalue = (value >> 8);\n\t\t\t}\n\t\t}\n\t\tmsg->cursize = (msg->bit >> 3) + 1;\n\t}\n}", "target": 1}
{"code": "int gru_set_context_option(unsigned long arg)\n{\n\tstruct gru_thread_state *gts;\n\tstruct gru_set_context_option_req req;\n\tint ret = 0;\n\tSTAT(set_context_option);\n\tif (copy_from_user(&req, (void __user *)arg, sizeof(req)))\n\t\treturn -EFAULT;\n\tgru_dbg(grudev, \"op %d, gseg 0x%lx, value1 0x%lx\\n\", req.op, req.gseg, req.val1);\n\tgts = gru_find_lock_gts(req.gseg);\n\tif (!gts) {\n\t\tgts = gru_alloc_locked_gts(req.gseg);\n\t\tif (IS_ERR(gts))\n\t\t\treturn PTR_ERR(gts);\n\t}\n\tswitch (req.op) {\n\tcase sco_blade_chiplet:\n\t\tif (req.val0 < -1 || req.val0 >= GRU_CHIPLETS_PER_HUB ||\n\t\t    req.val1 < -1 || req.val1 >= GRU_MAX_BLADES ||\n\t\t    (req.val1 >= 0 && !gru_base[req.val1])) {\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\tgts->ts_user_blade_id = req.val1;\n\t\t\tgts->ts_user_chiplet_id = req.val0;\n\t\t\tgru_check_context_placement(gts);\n\t\t}\n\t\tbreak;\n\tcase sco_gseg_owner:\n\t\tgts->ts_tgid_owner = current->tgid;\n\t\tbreak;\n\tcase sco_cch_req_slice:\n\t\tgts->ts_cch_req_slice = req.val1 & 3;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tgru_unlock_gts(gts);\n\treturn ret;\n}", "target": 1}
{"code": "xfs_inode_ag_iterator(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\t(*execute)(struct xfs_inode *ip, int flags,\n\t\t\t\t\t   void *args),\n\tint\t\t\tflags,\n\tvoid\t\t\t*args)\n{\n\treturn xfs_inode_ag_iterator_flags(mp, execute, flags, args, 0);\n}", "target": 0}
{"code": "int af_alg_make_sg(struct af_alg_sgl *sgl, struct iov_iter *iter, int len)\n{\n\tsize_t off;\n\tssize_t n;\n\tint npages, i;\n\tn = iov_iter_get_pages(iter, sgl->pages, len, ALG_MAX_PAGES, &off);\n\tif (n < 0)\n\t\treturn n;\n\tnpages = PAGE_ALIGN(off + n);\n\tif (WARN_ON(npages == 0))\n\t\treturn -EINVAL;\n\tsg_init_table(sgl->sg, npages);\n\tfor (i = 0, len = n; i < npages; i++) {\n\t\tint plen = min_t(int, len, PAGE_SIZE - off);\n\t\tsg_set_page(sgl->sg + i, sgl->pages[i], plen, off);\n\t\toff = 0;\n\t\tlen -= plen;\n\t}\n\treturn n;\n}", "target": 1}
{"code": "inline int TensorProtoDataSize<Eigen::half>(const TensorProto& t) {\n  return t.half_val_size();\n}", "target": 0}
{"code": "int irssi_ssl_handshake(GIOChannel *handle)\n{\n\tGIOSSLChannel *chan = (GIOSSLChannel *)handle;\n\tint ret, err;\n\tX509 *cert;\n\tconst char *errstr;\n\tret = SSL_connect(chan->ssl);\n\tif (ret <= 0) {\n\t\terr = SSL_get_error(chan->ssl, ret);\n\t\tswitch (err) {\n\t\t\tcase SSL_ERROR_WANT_READ:\n\t\t\t\treturn 1;\n\t\t\tcase SSL_ERROR_WANT_WRITE:\n\t\t\t\treturn 3;\n\t\t\tcase SSL_ERROR_ZERO_RETURN:\n\t\t\t\tg_warning(\"SSL handshake failed: %s\", \"server closed connection\");\n\t\t\t\treturn -1;\n\t\t\tcase SSL_ERROR_SYSCALL:\n\t\t\t\terrstr = ERR_reason_error_string(ERR_get_error());\n\t\t\t\tif (errstr == NULL && ret == -1)\n\t\t\t\t\terrstr = strerror(errno);\n\t\t\t\tg_warning(\"SSL handshake failed: %s\", errstr != NULL ? errstr : \"server closed connection unexpectedly\");\n\t\t\t\treturn -1;\n\t\t\tdefault:\n\t\t\t\terrstr = ERR_reason_error_string(ERR_get_error());\n\t\t\t\tg_warning(\"SSL handshake failed: %s\", errstr != NULL ? errstr : \"unknown SSL error\");\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\tcert = SSL_get_peer_certificate(chan->ssl);\n\tif (cert == NULL) {\n\t\tg_warning(\"SSL server supplied no certificate\");\n\t\treturn -1;\n\t}\n\tret = !chan->verify || irssi_ssl_verify(chan->ssl, chan->ctx, cert);\n\tX509_free(cert);\n\treturn ret ? 0 : -1;\n}", "target": 1}
{"code": "static int hidp_setup_hid(struct hidp_session *session,\n\t\t\t\tstruct hidp_connadd_req *req)\n{\n\tstruct hid_device *hid;\n\tint err;\n\tsession->rd_data = kzalloc(req->rd_size, GFP_KERNEL);\n\tif (!session->rd_data)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(session->rd_data, req->rd_data, req->rd_size)) {\n\t\terr = -EFAULT;\n\t\tgoto fault;\n\t}\n\tsession->rd_size = req->rd_size;\n\thid = hid_allocate_device();\n\tif (IS_ERR(hid)) {\n\t\terr = PTR_ERR(hid);\n\t\tgoto fault;\n\t}\n\tsession->hid = hid;\n\thid->driver_data = session;\n\thid->bus     = BUS_BLUETOOTH;\n\thid->vendor  = req->vendor;\n\thid->product = req->product;\n\thid->version = req->version;\n\thid->country = req->country;\n\tstrncpy(hid->name, req->name, 128);\n\tsnprintf(hid->phys, sizeof(hid->phys), \"%pMR\",\n\t\t &bt_sk(session->ctrl_sock->sk)->src);\n\tsnprintf(hid->uniq, sizeof(hid->uniq), \"%pMR\",\n\t\t &bt_sk(session->ctrl_sock->sk)->dst);\n\thid->dev.parent = &session->conn->dev;\n\thid->ll_driver = &hidp_hid_driver;\n\thid->hid_get_raw_report = hidp_get_raw_report;\n\thid->hid_output_raw_report = hidp_output_raw_report;\n\tif (hid_ignore(hid)) {\n\t\thid_destroy_device(session->hid);\n\t\tsession->hid = NULL;\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\nfault:\n\tkfree(session->rd_data);\n\tsession->rd_data = NULL;\n\treturn err;\n}", "target": 1}
{"code": "GF_Box *prft_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProducerReferenceTimeBox, GF_ISOM_BOX_TYPE_PRFT);\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "static int get_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\n{\n\tint ret;\n\tret = usb_control_msg(pegasus->usb, usb_rcvctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_GET_REGS, PEGASUS_REQT_READ, 0,\n\t\t\t      indx, data, size, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}", "target": 1}
{"code": "static void begin_read(TsHashTable *ht)\n{\n#ifdef ZTS\n\ttsrm_mutex_lock(ht->mx_reader);\n\tif ((++(ht->reader)) == 1) {\n\t\ttsrm_mutex_lock(ht->mx_writer);\n\t}\n\ttsrm_mutex_unlock(ht->mx_reader);\n#endif\n}", "target": 0}
{"code": "nvkm_vmm_free_remove(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n{\n\trb_erase(&vma->tree, &vmm->free);\n}", "target": 0}
{"code": "static Fixed lsr_translate_coords(GF_LASeRCodec *lsr, u32 val, u32 nb_bits)\n{\n\tif (!nb_bits) return 0;\n#ifdef GPAC_FIXED_POINT\n\tif (val >> (nb_bits-1) ) {\n\t\ts32 neg = (s32) val - (1<<nb_bits);\n\t\tif (neg < -FIX_ONE / 2)\n\t\t\treturn 2 * gf_divfix(INT2FIX(neg/2), lsr->res_factor);\n\t\treturn gf_divfix(INT2FIX(neg), lsr->res_factor);\n\t} else {\n\t\tif (val > FIX_ONE / 2)\n\t\t\treturn 2 * gf_divfix(INT2FIX(val/2), lsr->res_factor);\n\t\treturn gf_divfix(INT2FIX(val), lsr->res_factor);\n\t}\n#else\n\tif (val >> (nb_bits-1) ) {\n\t\ts32 neg = (s32) val - (1<<nb_bits);\n\t\treturn gf_divfix(INT2FIX(neg), lsr->res_factor);\n\t} else {\n\t\treturn gf_divfix(INT2FIX(val), lsr->res_factor);\n\t}\n#endif\n}", "target": 0}
{"code": "bool AES_GCM_EncryptContext::Encrypt(\n\tconst void *pPlaintextData, size_t cbPlaintextData,\n\tconst void *pIV,\n\tvoid *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag,\n\tconst void *pAdditionalAuthenticationData, size_t cbAuthenticationData\n) {\n    unsigned long long pcbEncryptedDataAndTag_longlong = *pcbEncryptedDataAndTag;\n    crypto_aead_aes256gcm_encrypt_afternm(\n\t\tstatic_cast<unsigned char*>( pEncryptedDataAndTag ), &pcbEncryptedDataAndTag_longlong,\n\t\tstatic_cast<const unsigned char*>( pPlaintextData ), cbPlaintextData,\n\t\tstatic_cast<const unsigned char*>(pAdditionalAuthenticationData), cbAuthenticationData,\n\t\tnullptr,\n\t\tstatic_cast<const unsigned char*>( pIV ),\n\t\tstatic_cast<const crypto_aead_aes256gcm_state*>( m_ctx )\n\t);\n    *pcbEncryptedDataAndTag = pcbEncryptedDataAndTag_longlong;\n    return true;\n}", "target": 1}
{"code": "static int burl_normalize_2F_to_slash_fix (buffer *b, int qs, int i)\n{\n    char * const s = b->ptr;\n    const int blen = (int)buffer_string_length(b);\n    const int used = qs < 0 ? blen : qs;\n    int j = i;\n    for (; i < used; ++i, ++j) {\n        s[j] = s[i];\n        if (s[i] == '%' && s[i+1] == '2' && s[i+2] == 'F') {\n            s[j] = '/';\n            i+=2;\n        }\n    }\n    if (qs >= 0) {\n        memmove(s+j, s+qs, blen - qs);\n        j += blen - qs;\n    }\n    buffer_string_set_length(b, j);\n    return qs;\n}", "target": 1}
{"code": "Bool gf_isom_has_time_offset_table(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media->information->sampleTable->CompositionOffset) return GF_FALSE;\n\treturn GF_TRUE;\n}", "target": 0}
{"code": "void Document::setCookie(const String& value, ExceptionState& exception_state) {\n  if (GetSettings() && !GetSettings()->GetCookieEnabled())\n    return;\n  UseCounter::Count(*this, WebFeature::kCookieSet);\n  if (!GetSecurityOrigin()->CanAccessCookies()) {\n    if (IsSandboxed(kSandboxOrigin))\n      exception_state.ThrowSecurityError(\n          \"The document is sandboxed and lacks the 'allow-same-origin' flag.\");\n    else if (Url().ProtocolIs(\"data\"))\n      exception_state.ThrowSecurityError(\n          \"Cookies are disabled inside 'data:' URLs.\");\n    else\n      exception_state.ThrowSecurityError(\"Access is denied for this document.\");\n    return;\n  }\n  if (GetSecurityOrigin()->HasSuborigin() &&\n      !GetSecurityOrigin()->GetSuborigin()->PolicyContains(\n          Suborigin::SuboriginPolicyOptions::kUnsafeCookies))\n    return;\n  KURL cookie_url = CookieURL();\n  if (cookie_url.IsEmpty())\n    return;\n  SetCookies(this, cookie_url, value);\n}", "target": 0}
{"code": "static void __free_slab(struct kmem_cache *s, struct page *page)\n{\n\tint order = compound_order(page);\n\tint pages = 1 << order;\n\tif (s->flags & SLAB_CONSISTENCY_CHECKS) {\n\t\tvoid *p;\n\t\tslab_pad_check(s, page);\n\t\tfor_each_object(p, s, page_address(page),\n\t\t\t\t\t\tpage->objects)\n\t\t\tcheck_object(s, page, p, SLUB_RED_INACTIVE);\n\t}\n\t__ClearPageSlabPfmemalloc(page);\n\t__ClearPageSlab(page);\n\tpage->mapping = NULL;\n\tif (current->reclaim_state)\n\t\tcurrent->reclaim_state->reclaimed_slab += pages;\n\tuncharge_slab_page(page, order, s);\n\t__free_pages(page, order);\n}", "target": 0}
{"code": "static int32_t check_load_area(uintptr_t dst, uintptr_t len)\n{\n\tuint32_t legacy = dst + len <= UINT32_MAX - 1 ? 1 : 0;\n\tuintptr_t dram_start, dram_end;\n\tuintptr_t prot_start, prot_end;\n\tint32_t result = IO_SUCCESS;\n\tdram_start = legacy ? DRAM1_NS_BASE : DRAM_40BIT_BASE;\n\tdram_end = legacy ? DRAM1_NS_BASE + DRAM1_NS_SIZE :\n\t    DRAM_40BIT_BASE + DRAM_40BIT_SIZE;\n\tprot_start = legacy ? DRAM_PROTECTED_BASE : DRAM_40BIT_PROTECTED_BASE;\n\tprot_end = prot_start + DRAM_PROTECTED_SIZE;\n\tif (dst < dram_start || dst > dram_end - len || dram_end < len) {\n\t\tERROR(\"BL2: dst address is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t\tgoto done;\n\t}\n\tif (dst >= prot_start && dst < prot_end) {\n\t\tERROR(\"BL2: dst address is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t}\n\tif ((dst < prot_start && dst > prot_start - len) || prot_start < len) {\n\t\tERROR(\"BL2: loaded data is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t}\ndone:\n\tif (result == IO_FAIL) {\n\t\tERROR(\"BL2: Out of range : dst=0x%lx len=0x%lx\\n\", dst, len);\n\t}\n\tif (addr_loaded_cnt >= CHECK_IMAGE_AREA_CNT) {\n\t\tERROR(\"BL2: max loadable non secure images reached\\n\");\n\t\tresult = IO_FAIL;\n\t}\n\taddr_loaded[addr_loaded_cnt].dest = dst;\n\taddr_loaded[addr_loaded_cnt].length = len;\n\tfor(int n=0; n<addr_loaded_cnt; n++) {\n\t\tif (((dst > addr_loaded[n].dest) &&\n\t\t     (dst <  addr_loaded[n].dest + addr_loaded[n].length)) ||\n\t\t    (((dst < addr_loaded[n].dest) &&\n\t\t      (dst + len)) > addr_loaded[n].dest)) {\n\t\t\tERROR(\"BL2: image is inside a previous image area.\\n\");\n\t\t\tresult = IO_FAIL;\n\t\t}\n\t}\n\taddr_loaded_cnt++;\n\treturn result;\n}", "target": 1}
{"code": "static void fts3SnippetAdvance(char **ppIter, int *piIter, int iNext){\n  char *pIter = *ppIter;\n  if( pIter ){\n    int iIter = *piIter;\n    while( iIter<iNext ){\n      if( 0==(*pIter & 0xFE) ){\n        iIter = -1;\n        pIter = 0;\n        break;\n      }\n      fts3GetDeltaPosition(&pIter, &iIter);\n    }\n    *piIter = iIter;\n    *ppIter = pIter;\n  }\n}", "target": 0}
{"code": "has_supported_extension (const char *name,\n\t\t\t GHashTable *supported_extensions)\n{\n\tgboolean ret = FALSE;\n\tgchar *suffix;\n\tsuffix = g_strrstr (name, \".\");\n\tif (!suffix)\n\t\treturn ret;\n\tsuffix = g_ascii_strdown (suffix + 1, -1);\n\tret = GPOINTER_TO_INT (g_hash_table_lookup (supported_extensions, suffix));\n\tg_free (suffix);\n\treturn ret;\n}", "target": 0}
{"code": "CURLcode Curl_smtp_escape_eob(struct connectdata *conn, const ssize_t nread)\n{\n  ssize_t i;\n  ssize_t si;\n  struct Curl_easy *data = conn->data;\n  struct SMTP *smtp = data->req.protop;\n  char *scratch = data->state.scratch;\n  char *newscratch = NULL;\n  char *oldscratch = NULL;\n  size_t eob_sent;\n  if(!scratch || data->set.crlf) {\n    oldscratch = scratch;\n    scratch = newscratch = malloc(2 * data->set.buffer_size);\n    if(!newscratch) {\n      failf(data, \"Failed to alloc scratch buffer!\");\n      return CURLE_OUT_OF_MEMORY;\n    }\n  }\n  eob_sent = smtp->eob;\n  for(i = 0, si = 0; i < nread; i++) {\n    if(SMTP_EOB[smtp->eob] == data->req.upload_fromhere[i]) {\n      smtp->eob++;\n      if(2 == smtp->eob || SMTP_EOB_LEN == smtp->eob)\n        smtp->trailing_crlf = TRUE;\n      else\n        smtp->trailing_crlf = FALSE;\n    }\n    else if(smtp->eob) {\n      memcpy(&scratch[si], &SMTP_EOB[eob_sent], smtp->eob - eob_sent);\n      si += smtp->eob - eob_sent;\n      if(SMTP_EOB[0] == data->req.upload_fromhere[i])\n        smtp->eob = 1;\n      else\n        smtp->eob = 0;\n      eob_sent = 0;\n      smtp->trailing_crlf = FALSE;\n    }\n    if(SMTP_EOB_FIND_LEN == smtp->eob) {\n      memcpy(&scratch[si], &SMTP_EOB_REPL[eob_sent],\n             SMTP_EOB_REPL_LEN - eob_sent);\n      si += SMTP_EOB_REPL_LEN - eob_sent;\n      smtp->eob = 0;\n      eob_sent = 0;\n    }\n    else if(!smtp->eob)\n      scratch[si++] = data->req.upload_fromhere[i];\n  }\n  if(smtp->eob - eob_sent) {\n    memcpy(&scratch[si], &SMTP_EOB[eob_sent], smtp->eob - eob_sent);\n    si += smtp->eob - eob_sent;\n  }\n  if(si != nread) {\n    data->req.upload_fromhere = scratch;\n    data->state.scratch = scratch;\n    free(oldscratch);\n    data->req.upload_present = si;\n  }\n  else\n    free(newscratch);\n  return CURLE_OK;\n}", "target": 1}
{"code": "static Jsi_Value *jsi_hashFmtKey(Jsi_MapEntry* h, struct Jsi_MapOpts *opts, int flags)\n{\n    Jsi_HashEntry* hPtr = (Jsi_HashEntry*)h;\n    void *key = Jsi_HashKeyGet(hPtr);\n    if (opts->keyType == JSI_KEYS_ONEWORD)\n        return Jsi_ValueNewNumber(opts->interp, (Jsi_Number)(intptr_t)key);\n    char nbuf[100];\n    snprintf(nbuf, sizeof(nbuf), \"%p\", key);\n    return Jsi_ValueNewStringDup(opts->interp, nbuf);\n}", "target": 1}
{"code": "bbuf_clone(BBuf** rto, BBuf* from)\n{\n  int r;\n  BBuf *to;\n  *rto = to = (BBuf* )xmalloc(sizeof(BBuf));\n  CHECK_NULL_RETURN_MEMERR(to);\n  r = BB_INIT(to, from->alloc);\n  if (r != 0) {\n    xfree(to->p);\n    *rto = 0;\n    return r;\n  }\n  to->used = from->used;\n  xmemcpy(to->p, from->p, from->used);\n  return 0;\n}", "target": 0}
{"code": "_blackbox_vlogger(int32_t target,\n\t\t  struct qb_log_callsite *cs, struct timespec *timestamp, va_list ap)\n{\n\tsize_t max_size;\n\tsize_t actual_size;\n\tuint32_t fn_size;\n\tchar *chunk;\n\tchar *msg_len_pt;\n\tuint32_t msg_len;\n\tstruct qb_log_target *t = qb_log_target_get(target);\n\tif (t->instance == NULL) {\n\t\treturn;\n\t}\n\tfn_size = strlen(cs->function) + 1;\n\tactual_size = 4 * sizeof(uint32_t) + sizeof(uint8_t) + fn_size + sizeof(struct timespec);\n\tmax_size = actual_size + t->max_line_length;\n\tchunk = qb_rb_chunk_alloc(t->instance, max_size);\n\tif (chunk == NULL) {\n\t\tqb_util_perror(LOG_ERR, \"Blackbox allocation error, aborting blackbox log %s\", t->filename);\n\t\tqb_rb_close(qb_rb_lastref_and_ret(\n\t\t\t(struct qb_ringbuffer_s **) &t->instance\n\t\t));\n\t\treturn;\n\t}\n\tmemcpy(chunk, &cs->lineno, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\tmemcpy(chunk, &cs->tags, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\tmemcpy(chunk, &cs->priority, sizeof(uint8_t));\n\tchunk += sizeof(uint8_t);\n\tmemcpy(chunk, &fn_size, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\tmemcpy(chunk, cs->function, fn_size);\n\tchunk += fn_size;\n\tmemcpy(chunk, timestamp, sizeof(struct timespec));\n\tchunk += sizeof(struct timespec);\n\tmsg_len_pt = chunk;\n\tchunk += sizeof(uint32_t);\n\tmsg_len = qb_vsnprintf_serialize(chunk, max_size, cs->format, ap);\n\tif (msg_len >= max_size) {\n\t    chunk = msg_len_pt + sizeof(uint32_t); \n\t    msg_len = qb_vsnprintf_serialize(chunk, QB_LOG_MAX_LEN,\n\t\t\"Log message too long to be stored in the blackbox.  \"\\\n\t\t\"Maximum is QB_LOG_MAX_LEN\" , ap);\n\t}\n\tactual_size += msg_len;\n\tmemcpy(msg_len_pt, &msg_len, sizeof(uint32_t));\n\t(void)qb_rb_chunk_commit(t->instance, actual_size);\n}", "target": 1}
{"code": "static int scanbraces(const char* in) {\n    if (strncmp(in, \"{\\\\an\", 4) != 0) {\n        return 0;\n    }\n    if (!isdigit(in[4])) {\n        return 0;\n    }\n    if (in[5] != '}') {\n        return 0;\n    }\n    return 1;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, MaxMinSelectCorrectlyOrderedIndex) {\n    addIndex(BSON(\"a\" << 1));\n    addIndex(BSON(\"a\" << -1));\n    runQueryFull(\n        BSONObj(), BSONObj(), BSONObj(), 0, 0, BSONObj(), fromjson(\"{a: 8}\"), fromjson(\"{a: 2}\"));\n    assertNumSolutions(1);\n    assertSolutionExists(\"{fetch: {node: {ixscan: {filter: null, dir: 1, pattern: {a: -1}}}}}\");\n    runQueryFull(\n        BSONObj(), BSONObj(), BSONObj(), 0, 0, BSONObj(), fromjson(\"{a: 2}\"), fromjson(\"{a: 8}\"));\n    assertNumSolutions(1);\n    assertSolutionExists(\"{fetch: {node: {ixscan: {filter: null, dir: 1, pattern: {a: 1}}}}}\");\n}", "target": 0}
{"code": "TEST_FUNCTION_CLEANUP(test_cleanup)\n{\n    TEST_MUTEX_RELEASE(g_testByTest);\n}", "target": 0}
{"code": "static int http_buf_read(URLContext *h, uint8_t *buf, int size)\n{\n    HTTPContext *s = h->priv_data;\n    int len;\n    len = s->buf_end - s->buf_ptr;\n    if (len > 0) {\n        if (len > size)\n            len = size;\n        memcpy(buf, s->buf_ptr, len);\n        s->buf_ptr += len;\n    } else {\n        int64_t target_end = s->end_off ? s->end_off : s->filesize;\n        if ((!s->willclose || s->chunksize < 0) &&\n            target_end >= 0 && s->off >= target_end)\n            return AVERROR_EOF;\n        len = ffurl_read(s->hd, buf, size);\n        if (!len && (!s->willclose || s->chunksize < 0) &&\n            target_end >= 0 && s->off < target_end) {\n            av_log(h, AV_LOG_ERROR,\n                   \"Stream ends prematurely at %\"PRId64\", should be %\"PRId64\"\\n\",\n                   s->off, target_end\n                  );\n            return AVERROR(EIO);\n        }\n    }\n    if (len > 0) {\n        s->off += len;\n        if (s->chunksize > 0)\n            s->chunksize -= len;\n    }\n    return len;\n}", "target": 1}
{"code": "get_manuf_name_if_known(const guint8 *addr)\n{\n    hashmanuf_t *manuf_value;\n    guint manuf_key;\n    guint8 oct;\n    manuf_key = addr[0];\n    manuf_key = manuf_key<<8;\n    oct = addr[1];\n    manuf_key = manuf_key | oct;\n    manuf_key = manuf_key<<8;\n    oct = addr[2];\n    manuf_key = manuf_key | oct;\n    manuf_value = (hashmanuf_t *)wmem_map_lookup(manuf_hashtable, GUINT_TO_POINTER(manuf_key));\n    if (manuf_value != NULL && manuf_value->status != HASHETHER_STATUS_UNRESOLVED) {\n        return manuf_value->resolved_longname;\n    }\n    const char *short_name, *long_name;\n    short_name = ws_manuf_lookup_str(addr, &long_name);\n    if (short_name != NULL) {\n        return long_name;\n    }\n    return NULL;\n} ", "target": 1}
{"code": "static s16 swf_get_s16(SWFReader *read)\n{\n\ts16 val;\n\tu8 v1;\n\tv1 = swf_read_int(read, 8);\n\tval = swf_read_sint(read, 8);\n\tval = (val<<8)&0xFF00;\n\tval |= (v1&0xFF);\n\treturn val;\n}", "target": 1}
{"code": "TEST_SUITE_CLEANUP(suite_cleanup)\n{\n    umock_c_deinit();\n    TEST_MUTEX_DESTROY(g_testByTest);\n}", "target": 0}
{"code": "static int bson_validate_string( bson *b, const unsigned char *string,\n                                 const int length, const char check_utf8, const char check_dot,\n                                 const char check_dollar ) {\n    int position = 0;\n    int sequence_length = 1;\n    if( check_dollar && string[0] == '$' ) {\n        if( !bson_string_is_db_ref( string, length ) )\n            b->err |= BSON_FIELD_INIT_DOLLAR;\n    }\n    while ( position < length ) {\n        if ( check_dot && *( string + position ) == '.' ) {\n            b->err |= BSON_FIELD_HAS_DOT;\n        }\n        if ( check_utf8 ) {\n            sequence_length = trailingBytesForUTF8[*( string + position )] + 1;\n            if ( ( position + sequence_length ) > length ) {\n                b->err |= BSON_NOT_UTF8;\n                return BSON_ERROR;\n            }\n            if ( !isLegalUTF8( string + position, sequence_length ) ) {\n                b->err |= BSON_NOT_UTF8;\n                return BSON_ERROR;\n            }\n        }\n        position += sequence_length;\n    }\n    return BSON_OK;\n}", "target": 1}
{"code": "std::string decodeBase64(\n    const std::string& encoded) {\n  if (encoded.size() == 0) {\n    return \"\";\n  }\n  using namespace boost::archive::iterators;\n  using b64it =\n    transform_width<binary_from_base64<std::string::const_iterator>, 8, 6>;\n  std::string decoded = std::string(b64it(std::begin(encoded)),\n                                    b64it(std::end(encoded)));\n  uint32_t numPadding = std::count(encoded.begin(), encoded.end(), '=');\n  decoded.erase(decoded.end() - numPadding, decoded.end());\n  return decoded;\n}", "target": 1}
{"code": "PGTYPEStimestamp_from_asc(char *str, char **endptr)\n{\n\ttimestamp\tresult;\n#ifdef HAVE_INT64_TIMESTAMP\n\tint64\t\tnoresult = 0;\n#else\n\tdouble\t\tnoresult = 0.0;\n#endif\n\tfsec_t\t\tfsec;\n\tstruct tm\ttt,\n\t\t\t   *tm = &tt;\n\tint\t\t\tdtype;\n\tint\t\t\tnf;\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tftype[MAXDATEFIELDS];\n\tchar\t\tlowstr[MAXDATELEN + MAXDATEFIELDS];\n\tchar\t   *realptr;\n\tchar\t  **ptr = (endptr != NULL) ? endptr : &realptr;\n\tif (strlen(str) >= sizeof(lowstr))\n\t{\n\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\treturn (noresult);\n\t}\n\tif (ParseDateTime(str, lowstr, field, ftype, &nf, ptr) != 0 ||\n\t\tDecodeDateTime(field, ftype, nf, &dtype, tm, &fsec, 0) != 0)\n\t{\n\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\treturn (noresult);\n\t}\n\tswitch (dtype)\n\t{\n\t\tcase DTK_DATE:\n\t\t\tif (tm2timestamp(tm, fsec, NULL, &result) != 0)\n\t\t\t{\n\t\t\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\t\t\treturn (noresult);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DTK_EPOCH:\n\t\t\tresult = SetEpochTimestamp();\n\t\t\tbreak;\n\t\tcase DTK_LATE:\n\t\t\tTIMESTAMP_NOEND(result);\n\t\t\tbreak;\n\t\tcase DTK_EARLY:\n\t\t\tTIMESTAMP_NOBEGIN(result);\n\t\t\tbreak;\n\t\tcase DTK_INVALID:\n\t\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\t\treturn (noresult);\n\t\tdefault:\n\t\t\terrno = PGTYPES_TS_BAD_TIMESTAMP;\n\t\t\treturn (noresult);\n\t}\n\terrno = 0;\n\treturn result;\n}", "target": 1}
{"code": "static void init_once(void *foo)\n{\n\tstruct ext4_inode_info *ei = (struct ext4_inode_info *) foo;\n\tINIT_LIST_HEAD(&ei->i_orphan);\n\tinit_rwsem(&ei->xattr_sem);\n\tinit_rwsem(&ei->i_data_sem);\n\tinit_rwsem(&ei->i_mmap_sem);\n\tinode_init_once(&ei->vfs_inode);\n}", "target": 0}
{"code": "static void unix_dgram_peer_wake_disconnect_wakeup(struct sock *sk,\n\t\t\t\t\t\t   struct sock *other)\n{\n\tunix_dgram_peer_wake_disconnect(sk, other);\n\twake_up_interruptible_poll(sk_sleep(sk),\n\t\t\t\t   POLLOUT |\n\t\t\t\t   POLLWRNORM |\n\t\t\t\t   POLLWRBAND);\n}", "target": 0}
{"code": "juniper_mlfr_print(netdissect_options *ndo,\n                   const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        l2info.pictype = DLT_JUNIPER_MLFR;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        if (ndo->ndo_eflag && EXTRACT_32BITS(l2info.cookie) != 1)\n            ND_PRINT((ndo, \"Bundle-ID %u, \", l2info.bundle));\n        switch (l2info.proto) {\n        case (LLC_UI):\n        case (LLC_UI<<8):\n            isoclns_print(ndo, p, l2info.length, l2info.caplen);\n            break;\n        case (LLC_UI<<8 | NLPID_Q933):\n        case (LLC_UI<<8 | NLPID_IP):\n        case (LLC_UI<<8 | NLPID_IP6):\n            isoclns_print(ndo, p - 1, l2info.length + 1, l2info.caplen + 1);\n            break;\n        default:\n            ND_PRINT((ndo, \"unknown protocol 0x%04x, length %u\", l2info.proto, l2info.length));\n        }\n        return l2info.header_len;\n}", "target": 1}
{"code": "static int get_filter(struct sss_certmap_ctx *ctx,\n                      struct ldap_mapping_rule *parsed_mapping_rule,\n                      struct sss_cert_content *cert_content,\n                      char **filter)\n{\n    struct ldap_mapping_rule_comp *comp;\n    char *result = NULL;\n    char *expanded = NULL;\n    int ret;\n    result = talloc_strdup(ctx, \"\");\n    if (result == NULL) {\n        return ENOMEM;\n    }\n    for (comp = parsed_mapping_rule->list; comp != NULL; comp = comp->next) {\n        if (comp->type == comp_string) {\n            result = talloc_strdup_append(result, comp->val);\n        } else if (comp->type == comp_template) {\n            ret = expand_template(ctx, comp->parsed_template, cert_content,\n                                  &expanded);\n            if (ret != 0) {\n                CM_DEBUG(ctx, \"Failed to expanded template.\");\n                goto done;\n            }\n            result = talloc_strdup_append(result, expanded);\n            talloc_free(expanded);\n            expanded = NULL;\n            if (result == NULL) {\n                ret = ENOMEM;\n                goto done;\n            }\n        } else {\n            ret = EINVAL;\n            CM_DEBUG(ctx, \"Unsupported component type.\");\n            goto done;\n        }\n    }\n    ret = 0;\ndone:\n    talloc_free(expanded);\n    if (ret == 0) {\n        *filter = result;\n    } else {\n        talloc_free(result);\n    }\n    return ret;\n}", "target": 1}
{"code": "void UpstreamRequest::onPerTryIdleTimeout() {\n  ENVOY_STREAM_LOG(debug, \"upstream per try idle timeout\", *parent_.callbacks());\n  if (per_try_timeout_) {\n    per_try_timeout_->disableTimer();\n  }\n  stream_info_.setResponseFlag(StreamInfo::CoreResponseFlag::StreamIdleTimeout);\n  parent_.onPerTryIdleTimeout(*this);\n}", "target": 0}
{"code": "gfx::Size OverlayWindowViews::GetMinimumSize() const {\n  return min_size_;\n}", "target": 0}
{"code": "void stl_le_phys(AddressSpace *as, hwaddr addr, uint32_t val)\n{\n    address_space_stl_le(as, addr, val, MEMTXATTRS_UNSPECIFIED, NULL);\n}", "target": 0}
{"code": "BOOL CEAnsi::ReportString(LPCWSTR asRet)\n{\n\tif (!asRet || !*asRet)\n\t\treturn FALSE;\n\tINPUT_RECORD ir[16] = {};\n\tconst size_t nLen = wcslen(asRet);\n\tif (nLen > std::numeric_limits<DWORD>::max())\n\t\treturn false;\n\tINPUT_RECORD* pir = (nLen <= static_cast<int>(countof(ir))) ? ir : static_cast<INPUT_RECORD*>(calloc(nLen, sizeof(INPUT_RECORD)));\n\tif (!pir)\n\t\treturn FALSE;\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (size_t i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}\n\tDumpKnownEscape(asRet, nLen, de_Report);\n\tDWORD nWritten = 0;\n\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\n\tconst BOOL bSuccess = WriteConsoleInput(hIn, pir, static_cast<DWORD>(nLen), &nWritten) && (nWritten == nLen);\n\tif (pir != ir)\n\t\tfree(pir);\n\treturn bSuccess;\n}", "target": 1}
{"code": "static int crypto_blkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_blkcipher rblkcipher;\n\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"blkcipher\");\n\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t alg->cra_blkcipher.geniv ?: \"<default>\");\n\trblkcipher.blocksize = alg->cra_blocksize;\n\trblkcipher.min_keysize = alg->cra_blkcipher.min_keysize;\n\trblkcipher.max_keysize = alg->cra_blkcipher.max_keysize;\n\trblkcipher.ivsize = alg->cra_blkcipher.ivsize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\n\t\t    sizeof(struct crypto_report_blkcipher), &rblkcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "static int smb2_resp_buf_len(struct ksmbd_work *work, unsigned short hdr2_len)\n{\n\tint free_len;\n\tfree_len = (int)(work->response_sz -\n\t\t(get_rfc1002_len(work->response_buf) + 4)) - hdr2_len;\n\treturn free_len;\n}", "target": 0}
{"code": "static inline int mystrcmp(char **p, const char *sample)\n{\n    int len = strlen(sample);\n    if (strncmp(*p, sample, len) == 0) {\n        (*p) += len;\n        return 1;\n    } else\n        return 0;\n}", "target": 0}
{"code": "static const char *jsi_evalprint(Jsi_Value *v)\n{\n    static char buf[100];\n    if (!v)\n        return \"nil\";\n    if (v->vt == JSI_VT_NUMBER) {\n        snprintf(buf, 100, \"NUM:%\" JSI_NUMGFMT \" \", v->d.num);\n    } else if (v->vt == JSI_VT_BOOL) {\n        snprintf(buf, 100, \"BOO:%d\", v->d.val);\n    } else if (v->vt == JSI_VT_STRING) {\n        snprintf(buf, 100, \"STR:'%s'\", v->d.s.str);\n    } else if (v->vt == JSI_VT_VARIABLE) {\n        snprintf(buf, 100, \"VAR:%p\", v->d.lval);\n    } else if (v->vt == JSI_VT_NULL) {\n        snprintf(buf, 100, \"NULL\");\n    } else if (v->vt == JSI_VT_OBJECT) {\n        snprintf(buf, 100, \"OBJ:%p\", v->d.obj);\n    } else if (v->vt == JSI_VT_UNDEF) {\n        snprintf(buf, 100, \"UNDEFINED\");\n    }\n    return buf;\n}", "target": 1}
{"code": "static RList* sections(RBinFile* bf) {\n\tRList* ret = NULL;\n\tRBinSection* sect = NULL;\n\tpsxexe_header psxheader = {0};\n\tut64 sz = 0;\n\tif (!(ret = r_list_new ())) {\n\t\treturn NULL;\n\t}\n\tif (!(sect = R_NEW0 (RBinSection))) {\n\t\tr_list_free (ret);\n\t\treturn NULL;\n\t}\n\tif (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, \"8c17i\", 1) < sizeof (psxexe_header)) {\n\t\teprintf (\"Truncated Header\\n\");\n\t\tfree (sect);\n\t\tr_list_free (ret);\n\t\treturn NULL;\n\t}\n\tsz = r_buf_size (bf->buf);\n\tsect->name = strdup (\"TEXT\");\n\tsect->paddr = PSXEXE_TEXTSECTION_OFFSET;\n\tsect->size = sz - PSXEXE_TEXTSECTION_OFFSET;\n\tsect->vaddr = psxheader.t_addr;\n\tsect->vsize = psxheader.t_size;\n\tsect->perm = R_PERM_RX;\n\tsect->add = true;\n\tsect->has_strings = true;\n\tr_list_append (ret, sect);\n\treturn ret;\n}", "target": 1}
{"code": "  bool isReference() const { return type() == Type::Reference; }", "target": 0}
{"code": "rrd_info_t *rrd_graph_v(\n    int argc,\n    char **argv)\n{\n    image_desc_t im;\n    rrd_info_t *grinfo;\n    rrd_graph_init(&im);\n    rrd_graph_options(argc, argv, &im);\n    if (rrd_test_error()) {\n        rrd_info_free(im.grinfo);\n        im_free(&im);\n        return NULL;\n    }\n    if (optind >= argc) {\n        rrd_info_free(im.grinfo);\n        im_free(&im);\n        rrd_set_error(\"missing filename\");\n        return NULL;\n    }\n    if (strlen(argv[optind]) >= MAXPATH) {\n        rrd_set_error(\"filename (including path) too long\");\n        rrd_info_free(im.grinfo);\n        im_free(&im);\n        return NULL;\n    }\n    strncpy(im.graphfile, argv[optind], MAXPATH - 1);\n    im.graphfile[MAXPATH - 1] = '\\0';\n    if (strcmp(im.graphfile, \"-\") == 0) {\n        im.graphfile[0] = '\\0';\n    }\n    rrd_graph_script(argc, argv, &im, 1);\n    if (rrd_test_error()) {\n        rrd_info_free(im.grinfo);\n        im_free(&im);\n        return NULL;\n    }\n    if (graph_paint(&im) == -1) {\n      rrd_info_free(im.grinfo);\n      im_free(&im);\n      return NULL;\n    }\n    if (im.imginfo && *im.imginfo) {\n        rrd_infoval_t info;\n        char     *path;\n        char     *filename;\n        if (bad_format_imginfo(im.imginfo)) {\n            rrd_info_free(im.grinfo);\n            im_free(&im);\n            rrd_set_error(\"bad format for imginfo\");\n            return NULL;\n        }\n        path = strdup(im.graphfile);\n        filename = basename(path);\n        info.u_str =\n            sprintf_alloc(im.imginfo,\n                          filename,\n                          (long) (im.zoom *\n                                  im.ximg), (long) (im.zoom * im.yimg));\n        grinfo_push(&im, sprintf_alloc(\"image_info\"), RD_I_STR, info);\n        free(info.u_str);\n        free(path);\n    }\n    if (im.rendered_image) {\n        rrd_infoval_t img;\n        img.u_blo.size = im.rendered_image_size;\n        img.u_blo.ptr = im.rendered_image;\n        grinfo_push(&im, sprintf_alloc(\"image\"), RD_I_BLO, img);\n    }\n    grinfo = im.grinfo;\n    im_free(&im);\n    return grinfo;\n}", "target": 1}
{"code": "static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct sockaddr_l2tpip *addr = (struct sockaddr_l2tpip *) uaddr;\n\tstruct net *net = sock_net(sk);\n\tint ret;\n\tint chk_addr_ret;\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\treturn -EINVAL;\n\tif (addr_len < sizeof(struct sockaddr_l2tpip))\n\t\treturn -EINVAL;\n\tif (addr->l2tp_family != AF_INET)\n\t\treturn -EINVAL;\n\tret = -EADDRINUSE;\n\tread_lock_bh(&l2tp_ip_lock);\n\tif (__l2tp_ip_bind_lookup(net, addr->l2tp_addr.s_addr,\n\t\t\t\t  sk->sk_bound_dev_if, addr->l2tp_conn_id))\n\t\tgoto out_in_use;\n\tread_unlock_bh(&l2tp_ip_lock);\n\tlock_sock(sk);\n\tif (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))\n\t\tgoto out;\n\tchk_addr_ret = inet_addr_type(net, addr->l2tp_addr.s_addr);\n\tret = -EADDRNOTAVAIL;\n\tif (addr->l2tp_addr.s_addr && chk_addr_ret != RTN_LOCAL &&\n\t    chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST)\n\t\tgoto out;\n\tif (addr->l2tp_addr.s_addr)\n\t\tinet->inet_rcv_saddr = inet->inet_saddr = addr->l2tp_addr.s_addr;\n\tif (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)\n\t\tinet->inet_saddr = 0;  \n\tsk_dst_reset(sk);\n\tl2tp_ip_sk(sk)->conn_id = addr->l2tp_conn_id;\n\twrite_lock_bh(&l2tp_ip_lock);\n\tsk_add_bind_node(sk, &l2tp_ip_bind_table);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip_lock);\n\tret = 0;\n\tsock_reset_flag(sk, SOCK_ZAPPED);\nout:\n\trelease_sock(sk);\n\treturn ret;\nout_in_use:\n\tread_unlock_bh(&l2tp_ip_lock);\n\treturn ret;\n}", "target": 1}
{"code": "static void packet_dev_mclist_delete(struct net_device *dev,\n\t\t\t\t     struct packet_mclist **mlp)\n{\n\tstruct packet_mclist *ml;\n\twhile ((ml = *mlp) != NULL) {\n\t\tif (ml->ifindex == dev->ifindex) {\n\t\t\tpacket_dev_mc(dev, ml, -1);\n\t\t\t*mlp = ml->next;\n\t\t\tkfree(ml);\n\t\t} else\n\t\t\tmlp = &ml->next;\n\t}\n}", "target": 0}
{"code": "static inline short key_read_state(const struct key *key)\n{\n\treturn smp_load_acquire(&key->state);\n}", "target": 0}
{"code": "blockmix_salsa8(__m128i * Bin, __m128i * Bout, __m128i * X, size_t r)\n{\n  size_t i;\n  blkcpy(X, &Bin[8 * r - 4], 64);\n  for (i = 0; i < r; i++) {\n    blkxor(X, &Bin[i * 8], 64);\n    salsa20_8(X);\n    blkcpy(&Bout[i * 4], X, 64);\n    blkxor(X, &Bin[i * 8 + 4], 64);\n    salsa20_8(X);\n    blkcpy(&Bout[(r + i) * 4], X, 64);\n  }\n}", "target": 1}
{"code": "bool copyaudiodata (AFfilehandle infile, AFfilehandle outfile, int trackid)\n{\n\tint frameSize = afGetVirtualFrameSize(infile, trackid, 1);\n\tconst int kBufferFrameCount = 65536;\n\tvoid *buffer = malloc(kBufferFrameCount * frameSize);\n\tAFframecount totalFrames = afGetFrameCount(infile, AF_DEFAULT_TRACK);\n\tAFframecount totalFramesWritten = 0;\n\tbool success = true;\n\twhile (totalFramesWritten < totalFrames)\n\t{\n\t\tAFframecount framesToRead = totalFrames - totalFramesWritten;\n\t\tif (framesToRead > kBufferFrameCount)\n\t\t\tframesToRead = kBufferFrameCount;\n\t\tAFframecount framesRead = afReadFrames(infile, trackid, buffer,\n\t\t\tframesToRead);\n\t\tif (framesRead < framesToRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad read of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\t\tAFframecount framesWritten = afWriteFrames(outfile, trackid, buffer,\n\t\t\tframesRead);\n\t\tif (framesWritten < framesRead)\n\t\t{\n\t\t\tfprintf(stderr, \"Bad write of audio track data.\\n\");\n\t\t\tsuccess = false;\n\t\t\tbreak;\n\t\t}\n\t\ttotalFramesWritten += framesWritten;\n\t}\n\tfree(buffer);\n\treturn success;\n}", "target": 1}
{"code": "spnego_gss_context_time(\n\t\t\tOM_uint32\t*minor_status,\n\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\tOM_uint32\t*time_rec)\n{\n\tOM_uint32 ret;\n\tret = gss_context_time(minor_status,\n\t\t\t    context_handle,\n\t\t\t    time_rec);\n\treturn (ret);\n}", "target": 1}
{"code": "static inline bool key_is_positive(const struct key *key)\n{\n\treturn key_read_state(key) == KEY_IS_POSITIVE;\n}", "target": 0}
{"code": "read_packet(int fd, gss_buffer_t buf, int timeout, int first)\n{\n\tint\t  ret;\n\tstatic uint32_t\t\tlen = 0;\n\tstatic char\t\tlen_buf[4];\n\tstatic int\t\tlen_buf_pos = 0;\n\tstatic char *\t\ttmpbuf = 0;\n\tstatic int\t\ttmpbuf_pos = 0;\n\tif (first) {\n\t\tlen_buf_pos = 0;\n\t\treturn -2;\n\t}\n\tif (len_buf_pos < 4) {\n\t\tret = timed_read(fd, &len_buf[len_buf_pos], 4 - len_buf_pos,\n\t\t    timeout);\n\t\tif (ret == -1) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\treturn -2;\n\t\t\tLOG(LOG_ERR, (\"%s\", strerror(errno)));\n\t\t\treturn -1;\n\t\t}\n\t\tif (ret == 0) {\t\t\n\t\t\tif (len_buf_pos == 0)\n\t\t\t\treturn 0;\n\t\t\tLOG(LOG_INFO, (\"EOF reading packet len\"));\n\t\t\treturn -1;\n\t\t}\n\t\tlen_buf_pos += ret;\n\t}\n\tif (len_buf_pos != 4)\n\t\treturn -2;\n\tlen = ntohl(*(uint32_t *)len_buf);\n\tif (len > GSTD_MAXPACKETCONTENTS + 512) {\n\t\tLOG(LOG_ERR, (\"ridiculous length, %ld\", len));\n\t\treturn -1;\n\t}\n\tif (!tmpbuf) {\n\t\tif ((tmpbuf = malloc(len)) == NULL) {\n\t\t\tLOG(LOG_CRIT, (\"malloc failure, %ld bytes\", len));\n\t\t\treturn -1;\n\t\t}\n\t}\n\tret = timed_read(fd, tmpbuf + tmpbuf_pos, len - tmpbuf_pos, timeout);\n\tif (ret == -1) {\n\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\treturn -2;\n\t\tLOG(LOG_ERR, (\"%s\", strerror(errno)));\n\t\treturn -1;\n\t}\n\tif (ret == 0) {\n\t\tLOG(LOG_ERR, (\"EOF while reading packet (len=%d)\", len));\n\t\treturn -1;\n\t}\n\ttmpbuf_pos += ret;\n\tif (tmpbuf_pos == len) {\n\t\tbuf->length = len;\n\t\tbuf->value = tmpbuf;\n\t\tlen = len_buf_pos = tmpbuf_pos = 0;\n\t\ttmpbuf = NULL;\n\t\tLOG(LOG_DEBUG, (\"read packet of length %d\", buf->length));\n\t\treturn 1;\n\t}\n\treturn -2;\n}", "target": 1}
{"code": "int dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\twrite_metapage(mp);\n\tIREAD_UNLOCK(ipbmap);\n\treturn (0);\n}", "target": 1}
{"code": "int re_yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )\n{\n    struct yyguts_t dummy_yyguts;\n    re_yyset_extra (yy_user_defined, &dummy_yyguts);\n    if (ptr_yy_globals == NULL){\n        errno = EINVAL;\n        return 1;\n    }\n    *ptr_yy_globals = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );\n    if (*ptr_yy_globals == NULL){\n        errno = ENOMEM;\n        return 1;\n    }\n    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));\n    re_yyset_extra (yy_user_defined, *ptr_yy_globals);\n    return yy_init_globals ( *ptr_yy_globals );", "target": 1}
{"code": "mainloop_destroy_trigger(crm_trigger_t * source)\n{\n    source->trigger = FALSE;\n    if (source->id > 0) {\n        g_source_remove(source->id);\n        source->id = 0;\n    }\n    return TRUE;\n}", "target": 0}
{"code": "static int file_exp(STANZA *s)\n{\n    BIGNUM *a = NULL, *e = NULL, *exp = NULL, *ret = NULL;\n    int st = 0;\n    if (!TEST_ptr(a = getBN(s, \"A\"))\n            || !TEST_ptr(e = getBN(s, \"E\"))\n            || !TEST_ptr(exp = getBN(s, \"Exp\"))\n            || !TEST_ptr(ret = BN_new()))\n        goto err;\n    if (!TEST_true(BN_exp(ret, a, e, ctx))\n            || !equalBN(\"A ^ E\", exp, ret))\n        goto err;\n    st = 1;\n err:\n    BN_free(a);\n    BN_free(e);\n    BN_free(exp);\n    BN_free(ret);\n    return st;\n}", "target": 0}
{"code": "int ieee80211_radiotap_iterator_init(\n\tstruct ieee80211_radiotap_iterator *iterator,\n\tstruct ieee80211_radiotap_header *radiotap_header,\n\tint max_length, const struct ieee80211_radiotap_vendor_namespaces *vns)\n{\n\tif (radiotap_header->it_version)\n\t\treturn -EINVAL;\n\tif (max_length < get_unaligned_le16(&radiotap_header->it_len))\n\t\treturn -EINVAL;\n\titerator->_rtheader = radiotap_header;\n\titerator->_max_length = get_unaligned_le16(&radiotap_header->it_len);\n\titerator->_arg_index = 0;\n\titerator->_bitmap_shifter = get_unaligned_le32(&radiotap_header->it_present);\n\titerator->_arg = (uint8_t *)radiotap_header + sizeof(*radiotap_header);\n\titerator->_reset_on_ext = 0;\n\titerator->_next_bitmap = &radiotap_header->it_present;\n\titerator->_next_bitmap++;\n\titerator->_vns = vns;\n\titerator->current_namespace = &radiotap_ns;\n\titerator->is_radiotap_ns = 1;\n\tif (iterator->_bitmap_shifter & (1<<IEEE80211_RADIOTAP_EXT)) {\n\t\twhile (get_unaligned_le32(iterator->_arg) &\n\t\t\t\t\t(1 << IEEE80211_RADIOTAP_EXT)) {\n\t\t\titerator->_arg += sizeof(uint32_t);\n\t\t\tif ((unsigned long)iterator->_arg -\n\t\t\t    (unsigned long)iterator->_rtheader >\n\t\t\t    (unsigned long)iterator->_max_length)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\titerator->_arg += sizeof(uint32_t);\n\t}\n\titerator->this_arg = iterator->_arg;\n\treturn 0;\n}", "target": 1}
{"code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* params;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kParams, &params));\n  const TfLiteTensor* indices;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kIndices, &indices));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  TF_LITE_ENSURE(context, NumElements(params) > 0);\n  switch (indices->type) {\n    case kTfLiteInt32:\n      return EvalGatherNd<int32_t>(context, params, indices, output);\n    case kTfLiteInt64:\n      return EvalGatherNd<int64_t>(context, params, indices, output);\n    default:\n      context->ReportError(\n          context, \"Indices of type '%s' are not supported by gather_nd.\",\n          TfLiteTypeGetName(indices->type));\n      return kTfLiteError;\n  }\n}", "target": 0}
{"code": "static char *rfc2047_decode_word(const char *s, size_t len, enum ContentEncoding enc)\n{\n  const char *it = s;\n  const char *end = s + len;\n  if (enc == ENCQUOTEDPRINTABLE)\n  {\n    struct Buffer buf = { 0 };\n    for (; it < end; ++it)\n    {\n      if (*it == '_')\n      {\n        mutt_buffer_addch(&buf, ' ');\n      }\n      else if ((*it == '=') && (!(it[1] & ~127) && hexval(it[1]) != -1) &&\n               (!(it[2] & ~127) && hexval(it[2]) != -1))\n      {\n        mutt_buffer_addch(&buf, (hexval(it[1]) << 4) | hexval(it[2]));\n        it += 2;\n      }\n      else\n      {\n        mutt_buffer_addch(&buf, *it);\n      }\n    }\n    mutt_buffer_addch(&buf, '\\0');\n    return buf.data;\n  }\n  else if (enc == ENCBASE64)\n  {\n    char *out = mutt_mem_malloc(3 * len / 4 + 1);\n    int dlen = mutt_b64_decode(out, it);\n    if (dlen == -1)\n    {\n      FREE(&out);\n      return NULL;\n    }\n    out[dlen] = '\\0';\n    return out;\n  }\n  assert(0); \n  return NULL;\n}", "target": 1}
{"code": "static int decode_font(ASS_Track *track)\n{\n    unsigned char *p;\n    unsigned char *q;\n    size_t i;\n    size_t size;                   \n    size_t dsize;                  \n    unsigned char *buf = 0;\n    ass_msg(track->library, MSGL_V, \"Font: %d bytes encoded data\",\n            track->parser_priv->fontdata_used);\n    size = track->parser_priv->fontdata_used;\n    if (size % 4 == 1) {\n        ass_msg(track->library, MSGL_ERR, \"Bad encoded data size\");\n        goto error_decode_font;\n    }\n    buf = malloc(size / 4 * 3 + FFMAX(size % 4 - 1, 0));\n    if (!buf)\n        goto error_decode_font;\n    q = buf;\n    for (i = 0, p = (unsigned char *) track->parser_priv->fontdata;\n         i < size / 4; i++, p += 4) {\n        q = decode_chars(p, q, 4);\n    }\n    if (size % 4 == 2) {\n        q = decode_chars(p, q, 2);\n    } else if (size % 4 == 3) {\n        q = decode_chars(p, q, 3);\n    }\n    dsize = q - buf;\n    assert(dsize == size / 4 * 3 + FFMAX(size % 4 - 1, 0));\n    if (track->library->extract_fonts) {\n        ass_add_font(track->library, track->parser_priv->fontname,\n                     (char *) buf, dsize);\n    }\nerror_decode_font:\n    free(buf);\n    reset_embedded_font_parsing(track->parser_priv);\n    return 0;\n}", "target": 1}
{"code": "static unsigned int ip6_hashfn(struct inet_frag_queue *q)\n{\n\tstruct frag_queue *fq;\n\tfq = container_of(q, struct frag_queue, q);\n\treturn inet6_hash_frag(fq->id, &fq->saddr, &fq->daddr, ip6_frags.rnd);\n}", "target": 0}
{"code": "read_nextline(void)\n{\nint len;\nuschar *p, *q;\nif (next_line != NULL)\n  {\n  uschar *yield = next_line;\n  next_line = NULL;\n  return yield;\n  }\nif (popto == 0)\n  {\n  pushstr *ps = pushed;\n  if (ps == NULL) error(12); else\n    {\n    popto = -1;\n    (void)sprintf(CS inbuffer, \"%s\\n\", ps->string);\n    pushed = ps->next;\n    free(ps);\n    return inbuffer;\n    }\n  }\nif (popto > 0)\n  {\n  pushstr *ps = pushed;\n  if (ps->letter == popto) popto = -1;  \n  (void)sprintf(CS inbuffer, \"%s\\n\", ps->string);\n  pushed = ps->next;\n  free(ps);\n  return inbuffer;\n  }\nif (from_type_ptr < 0) return NULL;\nfor (;;)\n  {\n  if (from_type[from_type_ptr] == FROM_MACRO)\n    {\n    if (macrocurrent->nextline == NULL)\n      {\n      macroexe *temp = macrocurrent;\n      macrocurrent = macrocurrent->prev;\n      macro_free(temp);\n      }\n    else\n      {\n      read_process_macroline(macrocurrent->nextline->string, inbuffer);\n      macrocurrent->nextline = macrocurrent->nextline->next;\n      break;\n      }\n    }\n  else\n    {\n    len = get_nextline(istack->file, inbuffer, INBUFFSIZE);\n    if (len < 0)\n      {\n      istackstr *prev = istack->prev;\n      fclose(istack->file);\n      free(istack);\n      istack = prev;\n      }\n    else\n      {\n      istack->linenumber++;\n      q = inbuffer;\n      for (;;)\n        {\n        p = q + len;\n        while (p > q && isspace(p[-1])) p--;\n        if (p - q < 3 || Ustrncmp(p - 3, \"&&&\", 3) != 0) break;\n        q = p - 3;\n        *q = 0;\n        if (istack == NULL) break;\n        len = get_nextline(istack->file, q, INBUFFSIZE - (q - inbuffer));\n        if (len < 0) break;\n        istack->linenumber++;\n        p = q;\n        while (*p == ' ' || *p == '\\t') { p++; len--; }\n        if (p > q) memmove(q, p, len + 1);\n        }\n      break;\n      }\n    }\n  if (--from_type_ptr < 0) return NULL;\n  }\nreturn inbuffer;\n}", "target": 1}
{"code": "static void drop_privs(void)\n{\n\tif (getuid() != 0) {\n\t\toldfsuid = setfsuid(getuid());\n\t\toldfsgid = setfsgid(getgid());\n\t}\n}", "target": 0}
{"code": "static void vmx_slot_disable_log_dirty(struct kvm *kvm,\n\t\t\t\t       struct kvm_memory_slot *slot)\n{\n\tkvm_mmu_slot_set_dirty(kvm, slot);\n}", "target": 0}
{"code": "AnimatedPropertyType SVGAnimateElement::determineAnimatedPropertyType(SVGElement* targetElement) const\n{\n    ASSERT(targetElement);\n    Vector<AnimatedPropertyType> propertyTypes;\n    targetElement->animatedPropertyTypeForAttribute(attributeName(), propertyTypes);\n    if (propertyTypes.isEmpty())\n        return AnimatedUnknown;\n    ASSERT(propertyTypes.size() <= 2);\n    AnimatedPropertyType type = propertyTypes[0];\n    if (hasTagName(SVGNames::animateColorTag) && type != AnimatedColor)\n        return AnimatedUnknown;\n    if (type == AnimatedTransformList && !hasTagName(SVGNames::animateTransformTag))\n        return AnimatedUnknown;\n    if (targetElement->hasTagName(SVGNames::markerTag) && type == AnimatedAngle) {\n        ASSERT(propertyTypes.size() == 2);\n        ASSERT(propertyTypes[0] == AnimatedAngle);\n        ASSERT(propertyTypes[1] == AnimatedEnumeration);\n    } else if (propertyTypes.size() == 2)\n        ASSERT(propertyTypes[0] == propertyTypes[1]);\n    return type;\n}", "target": 0}
{"code": "SslSocket::create(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,\n                  const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,\n                  Ssl::HandshakerFactoryCb handshaker_factory_cb) {\n  std::unique_ptr<SslSocket> socket(new SslSocket(ctx, transport_socket_options));\n  auto status = socket->initialize(state, handshaker_factory_cb);\n  if (status.ok()) {\n    return socket;\n  } else {\n    return status;\n  }\n}", "target": 0}
{"code": "static void __mark_reg32_unbounded(struct bpf_reg_state *reg)\n{\n\treg->s32_min_value = S32_MIN;\n\treg->s32_max_value = S32_MAX;\n\treg->u32_min_value = 0;\n\treg->u32_max_value = U32_MAX;\n}", "target": 0}
{"code": "mptctl_eventquery (unsigned long arg)\n{\n\tstruct mpt_ioctl_eventquery __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_eventquery\t karg;\n\tMPT_ADAPTER *ioc;\n\tint iocnum;\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventquery))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_eventquery - \"\n\t\t\t\"Unable to read in mpt_ioctl_eventquery struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_eventquery() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_eventquery called.\\n\",\n\t    ioc->name));\n\tkarg.eventEntries = MPTCTL_EVENT_LOG_SIZE;\n\tkarg.eventTypes = ioc->eventTypes;\n\tif (copy_to_user((char __user *)arg, &karg, sizeof(struct mpt_ioctl_eventquery))) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_eventquery - \"\n\t\t\t\"Unable to write out mpt_ioctl_eventquery struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "int kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr)\n{\n\tif (__kvm_set_xcr(vcpu, index, xcr)) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int discovery_stop(struct discovery_client *client)\n{\n\tstruct btd_adapter *adapter = client->adapter;\n\tstruct mgmt_cp_stop_discovery cp;\n\tif (g_slist_next(adapter->discovery_list)) {\n\t\tdiscovery_remove(client);\n\t\tupdate_discovery_filter(adapter);\n\t\treturn 0;\n\t}\n\tif (adapter->discovery_discoverable)\n\t\tset_discovery_discoverable(adapter, false);\n\tif (adapter->discovery_enable == 0x00) {\n\t\tdiscovery_remove(client);\n\t\tadapter->discovering = false;\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Discovering\");\n\t\ttrigger_passive_scanning(adapter);\n\t\treturn 0;\n\t}\n\tcp.type = adapter->discovery_type;\n\tadapter->client = client;\n\tmgmt_send(adapter->mgmt, MGMT_OP_STOP_DISCOVERY,\n\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\tstop_discovery_complete, adapter, NULL);\n\treturn -EINPROGRESS;\n}", "target": 1}
{"code": "static char *get_pid_environ_val(pid_t pid,char *val){\n  char temp[500];\n  int i=0;\n  int foundit=0;\n  FILE *fp;\n  sprintf(temp,\"/proc/%d/environ\",pid);\n  fp=fopen(temp,\"r\");\n  if(fp==NULL)\n    return NULL;\n  for(;;){\n    temp[i]=fgetc(fp);    \n    if(foundit==1 && (temp[i]==0 || temp[i]=='\\0' || temp[i]==EOF)){\n      char *ret;\n      temp[i]=0;\n      ret=malloc(strlen(temp)+10);\n      sprintf(ret,\"%s\",temp);\n      fclose(fp);\n      return ret;\n    }\n    switch(temp[i]){\n    case EOF:\n      fclose(fp);\n      return NULL;\n    case '=':\n      temp[i]=0;\n      if(!strcmp(temp,val)){\n\tfoundit=1;\n      }\n      i=0;\n      break;\n    case '\\0':\n      i=0;\n      break;\n    default:\n      i++;\n    }\n  }\n}", "target": 1}
{"code": "int backport_getrandom(void *buf, size_t buflen, unsigned int flags)\n{\n\treturn (int)syscall(SYS_getrandom, buf, buflen, flags);\n}", "target": 0}
{"code": "BOOL update_write_cache_brush_order(wStream* s, const CACHE_BRUSH_ORDER* cache_brush, UINT16* flags)\n{\n\tint i;\n\tBYTE iBitmapFormat;\n\tBOOL compressed = FALSE;\n\tif (!Stream_EnsureRemainingCapacity(s,\n\t                                    update_approximate_cache_brush_order(cache_brush, flags)))\n\t\treturn FALSE;\n\tiBitmapFormat = BPP_BMF[cache_brush->bpp];\n\tStream_Write_UINT8(s, cache_brush->index);  \n\tStream_Write_UINT8(s, iBitmapFormat);       \n\tStream_Write_UINT8(s, cache_brush->cx);     \n\tStream_Write_UINT8(s, cache_brush->cy);     \n\tStream_Write_UINT8(s, cache_brush->style);  \n\tStream_Write_UINT8(s, cache_brush->length); \n\tif ((cache_brush->cx == 8) && (cache_brush->cy == 8))\n\t{\n\t\tif (cache_brush->bpp == 1)\n\t\t{\n\t\t\tif (cache_brush->length != 8)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"incompatible 1bpp brush of length:%\" PRIu32 \"\", cache_brush->length);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t{\n\t\t\t\tStream_Write_UINT8(s, cache_brush->data[i]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((iBitmapFormat == BMF_8BPP) && (cache_brush->length == 20))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_16BPP) && (cache_brush->length == 24))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_32BPP) && (cache_brush->length == 32))\n\t\t\t\tcompressed = TRUE;\n\t\t\tif (compressed != FALSE)\n\t\t\t{\n\t\t\t\tif (!update_compress_brush(s, cache_brush->data, cache_brush->bpp))\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint scanline = (cache_brush->bpp / 8) * 8;\n\t\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t\t{\n\t\t\t\t\tStream_Write(s, &cache_brush->data[i * scanline], scanline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "PGTYPESdate_from_asc(char *str, char **endptr)\n{\n\tdate\t\tdDate;\n\tfsec_t\t\tfsec;\n\tstruct tm\ttt,\n\t\t\t   *tm = &tt;\n\tint\t\t\tdtype;\n\tint\t\t\tnf;\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tftype[MAXDATEFIELDS];\n\tchar\t\tlowstr[MAXDATELEN + 1];\n\tchar\t   *realptr;\n\tchar\t  **ptr = (endptr != NULL) ? endptr : &realptr;\n\tbool\t\tEuroDates = FALSE;\n\terrno = 0;\n\tif (strlen(str) >= sizeof(lowstr))\n\t{\n\t\terrno = PGTYPES_DATE_BAD_DATE;\n\t\treturn INT_MIN;\n\t}\n\tif (ParseDateTime(str, lowstr, field, ftype, &nf, ptr) != 0 ||\n\t\tDecodeDateTime(field, ftype, nf, &dtype, tm, &fsec, EuroDates) != 0)\n\t{\n\t\terrno = PGTYPES_DATE_BAD_DATE;\n\t\treturn INT_MIN;\n\t}\n\tswitch (dtype)\n\t{\n\t\tcase DTK_DATE:\n\t\t\tbreak;\n\t\tcase DTK_EPOCH:\n\t\t\tif (GetEpochTime(tm) < 0)\n\t\t\t{\n\t\t\t\terrno = PGTYPES_DATE_BAD_DATE;\n\t\t\t\treturn INT_MIN;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terrno = PGTYPES_DATE_BAD_DATE;\n\t\t\treturn INT_MIN;\n\t}\n\tdDate = (date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - date2j(2000, 1, 1));\n\treturn dDate;\n}", "target": 1}
{"code": "void ConnPoolImplBase::closeIdleConnectionsForDrainingPool() {\n  Common::AutoDebugRecursionChecker assert_not_in(recursion_checker_);\n  std::list<ActiveClient*> to_close;\n  for (auto& client : ready_clients_) {\n    if (client->numActiveStreams() == 0) {\n      to_close.push_back(client.get());\n    }\n  }\n  if (pending_streams_.empty()) {\n    for (auto& client : connecting_clients_) {\n      to_close.push_back(client.get());\n    }\n  }\n  for (auto& entry : to_close) {\n    ENVOY_LOG_EVENT(debug, \"closing_idle_client\", \"closing idle client {} for cluster {}\",\n                    entry->id(), host_->cluster().name());\n    entry->close();\n  }\n}", "target": 0}
{"code": "get_page_size_prepared_cb (GdkPixbufLoader *loader,\n\t\t\t   int              width,\n\t\t\t   int              height,\n\t\t\t   PixbufInfo      *info)\n{\n\tinfo->got_info = TRUE;\n\tinfo->height = height;\n\tinfo->width = width;\n}", "target": 0}
{"code": "int drm_mode_dirtyfb_ioctl(struct drm_device *dev,\n\t\t\t   void *data, struct drm_file *file_priv)\n{\n\tstruct drm_clip_rect __user *clips_ptr;\n\tstruct drm_clip_rect *clips = NULL;\n\tstruct drm_mode_fb_dirty_cmd *r = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_framebuffer *fb;\n\tunsigned flags;\n\tint num_clips;\n\tint ret = 0;\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, r->fb_id, DRM_MODE_OBJECT_FB);\n\tif (!obj) {\n\t\tDRM_ERROR(\"invalid framebuffer id\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\tfb = obj_to_fb(obj);\n\tnum_clips = r->num_clips;\n\tclips_ptr = (struct drm_clip_rect *)(unsigned long)r->clips_ptr;\n\tif (!num_clips != !clips_ptr) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\tflags = DRM_MODE_FB_DIRTY_FLAGS & r->flags;\n\tif (flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY && (num_clips % 2)) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\tif (num_clips && clips_ptr) {\n\t\tif (num_clips < 0 || num_clips > DRM_MODE_FB_DIRTY_MAX_CLIPS) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_err1;\n\t\t}\n\t\tclips = kzalloc(num_clips * sizeof(*clips), GFP_KERNEL);\n\t\tif (!clips) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_err1;\n\t\t}\n\t\tret = copy_from_user(clips, clips_ptr,\n\t\t\t\t     num_clips * sizeof(*clips));\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_err2;\n\t\t}\n\t}\n\tif (fb->funcs->dirty) {\n\t\tret = fb->funcs->dirty(fb, file_priv, flags, r->color,\n\t\t\t\t       clips, num_clips);\n\t} else {\n\t\tret = -ENOSYS;\n\t\tgoto out_err2;\n\t}\nout_err2:\n\tkfree(clips);\nout_err1:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}", "target": 0}
{"code": "rb_event_data(struct ring_buffer_event *event)\n{\n\tif (event->type_len == RINGBUF_TYPE_TIME_EXTEND)\n\t\tevent = skip_time_extend(event);\n\tBUG_ON(event->type_len > RINGBUF_TYPE_DATA_TYPE_LEN_MAX);\n\tif (event->type_len)\n\t\treturn (void *)&event->array[0];\n\treturn (void *)&event->array[1];\n}", "target": 0}
{"code": "blockmix_salsa8(uint32_t * Bin, uint32_t * Bout, uint32_t * X, size_t r)\n{\n  size_t i;\n  blkcpy(X, &Bin[(2 * r - 1) * 16], 64);\n  for (i = 0; i < 2 * r; i += 2) {\n    blkxor(X, &Bin[i * 16], 64);\n    salsa20_8(X);\n    blkcpy(&Bout[i * 8], X, 64);\n    blkxor(X, &Bin[i * 16 + 16], 64);\n    salsa20_8(X);\n    blkcpy(&Bout[i * 8 + r * 16], X, 64);\n  }\n}", "target": 1}
{"code": "static int filter_frame(AVFilterLink *inlink, AVFrame *frame)\n{\n    AVFilterContext   *ctx     = inlink->dst;\n    FieldOrderContext *s       = ctx->priv;\n    AVFilterLink      *outlink = ctx->outputs[0];\n    int h, plane, line_step, line_size, line;\n    uint8_t *data;\n    if (!frame->interlaced_frame ||\n        frame->top_field_first == s->dst_tff)\n        return ff_filter_frame(outlink, frame);\n    av_dlog(ctx,\n            \"picture will move %s one line\\n\",\n            s->dst_tff ? \"up\" : \"down\");\n    h = frame->height;\n    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {\n        line_step = frame->linesize[plane];\n        line_size = s->line_size[plane];\n        data = frame->data[plane];\n        if (s->dst_tff) {\n            for (line = 0; line < h; line++) {\n                if (1 + line < frame->height) {\n                    memcpy(data, data + line_step, line_size);\n                } else {\n                    memcpy(data, data - line_step - line_step, line_size);\n                }\n                data += line_step;\n            }\n        } else {\n            data += (h - 1) * line_step;\n            for (line = h - 1; line >= 0 ; line--) {\n                if (line > 0) {\n                    memcpy(data, data - line_step, line_size);\n                } else {\n                    memcpy(data, data + line_step + line_step, line_size);\n                }\n                data -= line_step;\n            }\n        }\n    }\n    frame->top_field_first = s->dst_tff;\n    return ff_filter_frame(outlink, frame);\n}", "target": 1}
{"code": "_SSL_match_hostname (const char *cert_hostname, const char *hostname)\n{\n\tconst char *cert_domain, *domain, *next_dot;\n\tif (g_ascii_strcasecmp (cert_hostname, hostname) == 0)\n\t\treturn 0;\n\tif (cert_hostname[0] == '*')\n\t{\n\t\tcert_domain = &cert_hostname[1];\n\t\tif (cert_domain[0] == '\\0')\n\t\t\treturn -1;\n\t\tif (cert_domain[0] != '.')\n\t\t\treturn -1;\n\t\tif (cert_domain[1] == '.')\n\t\t\treturn -1;\n\t\tnext_dot = strchr (&cert_domain[1], '.');\n\t\tif (next_dot == NULL)\n\t\t\treturn -1;\n\t\tif (next_dot[1] == '.')\n\t\t\treturn -1;\n\t\tdomain = strchr (hostname, '.');\n\t\tif (domain == NULL || strlen(domain) == 1)\n\t\t\treturn -1;\n\t\tif (g_ascii_strcasecmp (cert_domain, domain) == 0)\n\t\t\treturn 0;\n\t}\n\treturn -1;\n}", "target": 0}
{"code": "void ChildProcessSecurityPolicy::GrantInspectElement(int renderer_id) {\n  AutoLock lock(lock_);\n  SecurityStateMap::iterator state = security_state_.find(renderer_id);\n  if (state == security_state_.end())\n    return;\n  state->second->GrantScheme(chrome::kChromeUIScheme);\n}", "target": 0}
{"code": "lookup_bytestring(netdissect_options *ndo, register const u_char *bs,\n\t\t  const unsigned int nlen)\n{\n\tstruct enamemem *tp;\n\tregister u_int i, j, k;\n\tif (nlen >= 6) {\n\t\tk = (bs[0] << 8) | bs[1];\n\t\tj = (bs[2] << 8) | bs[3];\n\t\ti = (bs[4] << 8) | bs[5];\n\t} else if (nlen >= 4) {\n\t\tk = (bs[0] << 8) | bs[1];\n\t\tj = (bs[2] << 8) | bs[3];\n\t\ti = 0;\n\t} else\n\t\ti = j = k = 0;\n\ttp = &bytestringtable[(i ^ j) & (HASHNAMESIZE-1)];\n\twhile (tp->e_nxt)\n\t\tif (tp->e_addr0 == i &&\n\t\t    tp->e_addr1 == j &&\n\t\t    tp->e_addr2 == k &&\n\t\t    memcmp((const char *)bs, (const char *)(tp->e_bs), nlen) == 0)\n\t\t\treturn tp;\n\t\telse\n\t\t\ttp = tp->e_nxt;\n\ttp->e_addr0 = i;\n\ttp->e_addr1 = j;\n\ttp->e_addr2 = k;\n\ttp->e_bs = (u_char *) calloc(1, nlen + 1);\n\tif (tp->e_bs == NULL)\n\t\t(*ndo->ndo_error)(ndo, \"lookup_bytestring: calloc\");\n\tmemcpy(tp->e_bs, bs, nlen);\n\ttp->e_nxt = (struct enamemem *)calloc(1, sizeof(*tp));\n\tif (tp->e_nxt == NULL)\n\t\t(*ndo->ndo_error)(ndo, \"lookup_bytestring: calloc\");\n\treturn tp;\n}", "target": 1}
{"code": "parsegid(const char *s, gid_t *gid)\n{\n\tstruct group *gr;\n\tconst char *errstr;\n\tif ((gr = getgrnam(s)) != NULL) {\n\t\t*gid = gr->gr_gid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*gid = strtonum(s, 0, GID_MAX, &errstr);\n\t#else\n\tsscanf(s, \"%d\", gid);\n\t#endif\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}", "target": 1}
{"code": "static int handle_pause(struct kvm_vcpu *vcpu)\n{\n\tif (ple_gap)\n\t\tgrow_ple_window(vcpu);\n\tkvm_vcpu_on_spin(vcpu, true);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}", "target": 0}
{"code": "static void infra_ip_create_ratedata(struct infra_cache* infra,\n\tstruct sockaddr_storage* addr, socklen_t addrlen, time_t timenow)\n{\n\thashvalue_type h = hash_addr(addr, addrlen, 0);\n\tstruct ip_rate_key* k = (struct ip_rate_key*)calloc(1, sizeof(*k));\n\tstruct ip_rate_data* d = (struct ip_rate_data*)calloc(1, sizeof(*d));\n\tif(!k || !d) {\n\t\tfree(k);\n\t\tfree(d);\n\t\treturn; \n\t}\n\tk->addr = *addr;\n\tk->addrlen = addrlen;\n\tlock_rw_init(&k->entry.lock);\n\tk->entry.hash = h;\n\tk->entry.key = k;\n\tk->entry.data = d;\n\td->qps[0] = 1;\n\td->timestamp[0] = timenow;\n\tslabhash_insert(infra->client_ip_rates, h, &k->entry, d, NULL);\n}", "target": 1}
{"code": "wb_id(netdissect_options *ndo,\n      const struct pkt_id *id, u_int len)\n{\n\tint i;\n\tconst char *cp;\n\tconst struct id_off *io;\n\tchar c;\n\tint nid;\n\tND_PRINT((ndo, \" wb-id:\"));\n\tif (len < sizeof(*id) || !ND_TTEST(*id))\n\t\treturn (-1);\n\tlen -= sizeof(*id);\n\tND_PRINT((ndo, \" %u/%s:%u (max %u/%s:%u) \",\n\t       EXTRACT_32BITS(&id->pi_ps.slot),\n\t       ipaddr_string(ndo, &id->pi_ps.page.p_sid),\n\t       EXTRACT_32BITS(&id->pi_ps.page.p_uid),\n\t       EXTRACT_32BITS(&id->pi_mslot),\n\t       ipaddr_string(ndo, &id->pi_mpage.p_sid),\n\t       EXTRACT_32BITS(&id->pi_mpage.p_uid)));\n\tnid = EXTRACT_16BITS(&id->pi_ps.nid);\n\tlen -= sizeof(*io) * nid;\n\tio = (struct id_off *)(id + 1);\n\tcp = (char *)(io + nid);\n\tif (!ND_TTEST2(cp, len)) {\n\t\tND_PRINT((ndo, \"\\\"\"));\n\t\tfn_print(ndo, (u_char *)cp, (u_char *)cp + len);\n\t\tND_PRINT((ndo, \"\\\"\"));\n\t}\n\tc = '<';\n\tfor (i = 0; i < nid && ND_TTEST(*io); ++io, ++i) {\n\t\tND_PRINT((ndo, \"%c%s:%u\",\n\t\t    c, ipaddr_string(ndo, &io->id), EXTRACT_32BITS(&io->off)));\n\t\tc = ',';\n\t}\n\tif (i >= nid) {\n\t\tND_PRINT((ndo, \">\"));\n\t\treturn (0);\n\t}\n\treturn (-1);\n}", "target": 1}
{"code": "decode_sequence_of(const uint8_t *asn1, size_t len,\n                   const struct atype_info *elemtype, void **seq_out,\n                   size_t *count_out)\n{\n    krb5_error_code ret;\n    void *seq = NULL, *elem, *newseq;\n    const uint8_t *contents;\n    size_t clen, count = 0;\n    taginfo t;\n    *seq_out = NULL;\n    *count_out = 0;\n    while (len > 0) {\n        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);\n        if (ret)\n            goto error;\n        if (!check_atype_tag(elemtype, &t)) {\n            ret = ASN1_BAD_ID;\n            goto error;\n        }\n        newseq = realloc(seq, (count + 1) * elemtype->size);\n        if (newseq == NULL) {\n            ret = ENOMEM;\n            goto error;\n        }\n        seq = newseq;\n        elem = (char *)seq + count * elemtype->size;\n        memset(elem, 0, elemtype->size);\n        ret = decode_atype(&t, contents, clen, elemtype, elem);\n        if (ret)\n            goto error;\n        count++;\n    }\n    *seq_out = seq;\n    *count_out = count;\n    return 0;\nerror:\n    free_sequence_of(elemtype, seq, count);\n    free(seq);\n    return ret;\n}", "target": 1}
{"code": "dns_resolver_match(const struct key *key,\n\t\t   const struct key_match_data *match_data)\n{\n\tint slen, dlen, ret = 0;\n\tconst char *src = key->description, *dsp = match_data->raw_data;\n\tkenter(\"%s,%s\", src, dsp);\n\tif (!src || !dsp)\n\t\tgoto no_match;\n\tif (strcasecmp(src, dsp) == 0)\n\t\tgoto matched;\n\tslen = strlen(src);\n\tdlen = strlen(dsp);\n\tif (slen <= 0 || dlen <= 0)\n\t\tgoto no_match;\n\tif (src[slen - 1] == '.')\n\t\tslen--;\n\tif (dsp[dlen - 1] == '.')\n\t\tdlen--;\n\tif (slen != dlen || strncasecmp(src, dsp, slen) != 0)\n\t\tgoto no_match;\nmatched:\n\tret = 1;\nno_match:\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}", "target": 1}
{"code": "static inline void verify_event(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t void *event)\n{\n}", "target": 0}
{"code": "bool WddxPacket::recursiveAddVar(const String& varName,\n                                 const Variant& varVariant,\n                                 bool hasVarTag) {\n  bool isArray = varVariant.isArray();\n  bool isObject = varVariant.isObject();\n  if (isArray || isObject) {\n    if (hasVarTag) {\n      m_packetString += \"<var name='\";\n      m_packetString += varName.data();\n      m_packetString += \"'>\";\n    }\n    Array varAsArray;\n    Object varAsObject = varVariant.toObject();\n    if (isArray) varAsArray = varVariant.toArray();\n    if (isObject) varAsArray = varAsObject.toArray();\n    int length = varAsArray.length();\n    if (length > 0) {\n      ArrayIter it = ArrayIter(varAsArray);\n      if (it.first().isString()) isObject = true;\n      if (isObject) {\n        m_packetString += \"<struct>\";\n        if (!isArray) {\n          m_packetString += \"<var name='php_class_name'><string>\";\n          m_packetString += varAsObject->o_getClassName().c_str();\n          m_packetString += \"</string></var>\";\n        }\n      } else {\n        m_packetString += \"<array length='\";\n        m_packetString += std::to_string(length);\n        m_packetString += \"'>\";\n      }\n      for (ArrayIter it(varAsArray); it; ++it) {\n        Variant key = it.first();\n        Variant value = it.second();\n        recursiveAddVar(key.toString(), value, isObject);\n      }\n      if (isObject) {\n        m_packetString += \"</struct>\";\n      }\n      else {\n        m_packetString += \"</array>\";\n      }\n    }\n    else {\n      if (isObject) {\n        m_packetString += \"<struct>\";\n        if (!isArray) {\n          m_packetString += \"<var name='php_class_name'><string>\";\n          m_packetString += varAsObject->o_getClassName().c_str();\n          m_packetString += \"</string></var>\";\n        }\n        m_packetString += \"</struct>\";\n      }\n    }\n    if (hasVarTag) {\n      m_packetString += \"</var>\";\n    }\n    return true;\n  }\n  std::string varType = getDataTypeString(varVariant.getType()).data();\n  if (!getWddxEncoded(varType, \"\", varName, false).empty()) {\n    std::string varValue = varVariant.toString().data();\n    if (varType.compare(\"boolean\") == 0) {\n      varValue = varVariant.toBoolean() ? \"true\" : \"false\";\n    }\n    m_packetString += getWddxEncoded(varType, varValue, varName, hasVarTag);\n    return true;\n  }\n  return false;\n}", "target": 1}
{"code": "int git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\t\treturn (int)len;\n\t}\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\tif (len != 0 && len < PKT_LEN_SIZE)\n\t\treturn GIT_ERROR;\n\tline += PKT_LEN_SIZE;\n\tif (len == PKT_LEN_SIZE) {\n\t\t*head = NULL;\n\t\t*out = line;\n\t\treturn 0;\n\t}\n\tif (len == 0) { \n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\tlen -= PKT_LEN_SIZE; \n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\t*out = line + len;\n\treturn ret;\n}", "target": 0}
{"code": "void WasmBinaryWriter::writeDebugLocationEnd(Expression* curr, Function* func) {\n  if (func && !func->expressionLocations.empty()) {\n    auto& span = binaryLocations.expressions.at(curr);\n    span.end = o.size();\n  }\n}", "target": 0}
{"code": "static int ext4_statfs_project(struct super_block *sb,\n\t\t\t       kprojid_t projid, struct kstatfs *buf)\n{\n\tstruct kqid qid;\n\tstruct dquot *dquot;\n\tu64 limit;\n\tu64 curblock;\n\tqid = make_kqid_projid(projid);\n\tdquot = dqget(sb, qid);\n\tif (IS_ERR(dquot))\n\t\treturn PTR_ERR(dquot);\n\tspin_lock(&dquot->dq_dqb_lock);\n\tlimit = (dquot->dq_dqb.dqb_bsoftlimit ?\n\t\t dquot->dq_dqb.dqb_bsoftlimit :\n\t\t dquot->dq_dqb.dqb_bhardlimit) >> sb->s_blocksize_bits;\n\tif (limit && buf->f_blocks > limit) {\n\t\tcurblock = dquot->dq_dqb.dqb_curspace >> sb->s_blocksize_bits;\n\t\tbuf->f_blocks = limit;\n\t\tbuf->f_bfree = buf->f_bavail =\n\t\t\t(buf->f_blocks > curblock) ?\n\t\t\t (buf->f_blocks - curblock) : 0;\n\t}\n\tlimit = dquot->dq_dqb.dqb_isoftlimit ?\n\t\tdquot->dq_dqb.dqb_isoftlimit :\n\t\tdquot->dq_dqb.dqb_ihardlimit;\n\tif (limit && buf->f_files > limit) {\n\t\tbuf->f_files = limit;\n\t\tbuf->f_ffree =\n\t\t\t(buf->f_files > dquot->dq_dqb.dqb_curinodes) ?\n\t\t\t (buf->f_files - dquot->dq_dqb.dqb_curinodes) : 0;\n\t}\n\tspin_unlock(&dquot->dq_dqb_lock);\n\tdqput(dquot);\n\treturn 0;\n}", "target": 0}
{"code": "void ModuleSQL::init()\n{\n\tif (mysql_library_init(0, NULL, NULL))\n\t\tthrow ModuleException(\"Unable to initialise the MySQL library!\");\n\tDispatcher = new DispatcherThread(this);\n\tServerInstance->Threads->Start(Dispatcher);\n\tImplementation eventlist[] = { I_OnRehash, I_OnUnloadModule };\n\tServerInstance->Modules->Attach(eventlist, this, sizeof(eventlist)/sizeof(Implementation));\n\tOnRehash(NULL);\n}", "target": 0}
{"code": "Bool rfbOptPamAuth(void)\n{\n  SecTypeData *s;\n  for (s = secTypes; s->name != NULL; s++) {\n    if ((!strcmp(s->name, \"unixlogin\") ||\n         !strcmp(&s->name[strlen(s->name) - 5], \"plain\")) && s->enabled)\n      return TRUE;\n  }\n  return FALSE;\n}", "target": 1}
{"code": "static int check_ci(const struct atm_vcc *vcc, short vpi, int vci)\n{\n\tstruct hlist_head *head = &vcc_hash[vci & (VCC_HTABLE_SIZE - 1)];\n\tstruct hlist_node *node;\n\tstruct sock *s;\n\tstruct atm_vcc *walk;\n\tsk_for_each(s, node, head) {\n\t\twalk = atm_sk(s);\n\t\tif (walk->dev != vcc->dev)\n\t\t\tcontinue;\n\t\tif (test_bit(ATM_VF_ADDR, &walk->flags) && walk->vpi == vpi &&\n\t\t    walk->vci == vci && ((walk->qos.txtp.traffic_class !=\n\t\t    ATM_NONE && vcc->qos.txtp.traffic_class != ATM_NONE) ||\n\t\t    (walk->qos.rxtp.traffic_class != ATM_NONE &&\n\t\t    vcc->qos.rxtp.traffic_class != ATM_NONE)))\n\t\t\treturn -EADDRINUSE;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static void ext4_end_io_buffer_write(struct buffer_head *bh, int uptodate)\n{\n\text4_io_end_t *io_end = bh->b_private;\n\tstruct workqueue_struct *wq;\n\tstruct inode *inode;\n\tunsigned long flags;\n\tif (!test_clear_buffer_uninit(bh) || !io_end)\n\t\tgoto out;\n\tif (!(io_end->inode->i_sb->s_flags & MS_ACTIVE)) {\n\t\tprintk(\"sb umounted, discard end_io request for inode %lu\\n\",\n\t\t\tio_end->inode->i_ino);\n\t\text4_free_io_end(io_end);\n\t\tgoto out;\n\t}\n\tio_end->flag = EXT4_IO_UNWRITTEN;\n\tinode = io_end->inode;\n\tspin_lock_irqsave(&EXT4_I(inode)->i_completed_io_lock, flags);\n\tlist_add_tail(&io_end->list, &EXT4_I(inode)->i_completed_io_list);\n\tspin_unlock_irqrestore(&EXT4_I(inode)->i_completed_io_lock, flags);\n\twq = EXT4_SB(inode->i_sb)->dio_unwritten_wq;\n\tqueue_work(wq, &io_end->work);\nout:\n\tbh->b_private = NULL;\n\tbh->b_end_io = NULL;\n\tclear_buffer_uninit(bh);\n\tend_buffer_async_write(bh, uptodate);\n}", "target": 0}
{"code": "static inline int rb_null_event(struct ring_buffer_event *event)\n{\n\treturn event->type_len == RINGBUF_TYPE_PADDING && !event->time_delta;\n}", "target": 0}
{"code": "void IndexedDBDatabase::RenameObjectStore(IndexedDBTransaction* transaction,\n                                          int64_t object_store_id,\n                                          const base::string16& new_name) {\n  DCHECK(transaction);\n  IDB_TRACE1(\"IndexedDBDatabase::RenameObjectStore\", \"txn.id\",\n             transaction->id());\n  DCHECK_EQ(transaction->mode(),\n            blink::mojom::IDBTransactionMode::VersionChange);\n  if (!ValidateObjectStoreId(object_store_id))\n    return;\n  IndexedDBObjectStoreMetadata& object_store_metadata =\n      metadata_.object_stores[object_store_id];\n  base::string16 old_name;\n  Status s = metadata_coding_->RenameObjectStore(\n      transaction->BackingStoreTransaction()->transaction(),\n      transaction->database()->id(), new_name, &old_name,\n      &object_store_metadata);\n  if (!s.ok()) {\n    ReportErrorWithDetails(s, \"Internal error renaming object store.\");\n    return;\n  }\n  DCHECK_EQ(object_store_metadata.name, new_name);\n  transaction->ScheduleAbortTask(\n      base::BindOnce(&IndexedDBDatabase::RenameObjectStoreAbortOperation, this,\n                     object_store_id, std::move(old_name)));\n}", "target": 0}
{"code": "static UINT parallel_process_irp_create(PARALLEL_DEVICE* parallel, IRP* irp)\n{\n\tchar* path = NULL;\n\tint status;\n\tUINT32 PathLength;\n\tStream_Seek(irp->input, 28);\n\tStream_Read_UINT32(irp->input, PathLength);\n\tstatus = ConvertFromUnicode(CP_UTF8, 0, (WCHAR*)Stream_Pointer(irp->input), PathLength / 2,\n\t                            &path, 0, NULL, NULL);\n\tif (status < 1)\n\t\tif (!(path = (char*)calloc(1, 1)))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\tparallel->id = irp->devman->id_sequence++;\n\tparallel->file = open(parallel->path, O_RDWR);\n\tif (parallel->file < 0)\n\t{\n\t\tirp->IoStatus = STATUS_ACCESS_DENIED;\n\t\tparallel->id = 0;\n\t}\n\telse\n\t{\n\t\tif (fcntl(parallel->file, F_SETFL, O_NONBLOCK) == -1)\n\t\t{\n\t\t}\n\t}\n\tStream_Write_UINT32(irp->output, parallel->id);\n\tStream_Write_UINT8(irp->output, 0);\n\tfree(path);\n\treturn irp->Complete(irp);\n}", "target": 1}
{"code": "static int adpt_hba_reset(adpt_hba* pHba)\n{\n\tint rcode;\n\tpHba->state |= DPTI_STATE_RESET;\n\tif ((rcode=adpt_i2o_activate_hba(pHba)) < 0) {\n\t\tprintk(KERN_ERR \"%s: Could not activate\\n\", pHba->name);\n\t\tadpt_i2o_delete_hba(pHba);\n\t\treturn rcode;\n\t}\n\tif ((rcode=adpt_i2o_build_sys_table()) < 0) {\n\t\tadpt_i2o_delete_hba(pHba);\n\t\treturn rcode;\n\t}\n\tPDEBUG(\"%s: in HOLD state\\n\",pHba->name);\n\tif ((rcode=adpt_i2o_online_hba(pHba)) < 0) {\n\t\tadpt_i2o_delete_hba(pHba);\t\n\t\treturn rcode;\n\t}\n\tPDEBUG(\"%s: in OPERATIONAL state\\n\",pHba->name);\n\tif ((rcode=adpt_i2o_lct_get(pHba)) < 0){\n\t\tadpt_i2o_delete_hba(pHba);\n\t\treturn rcode;\n\t}\n\tif ((rcode=adpt_i2o_reparse_lct(pHba)) < 0){\n\t\tadpt_i2o_delete_hba(pHba);\n\t\treturn rcode;\n\t}\n\tpHba->state &= ~DPTI_STATE_RESET;\n\tscsi_host_complete_all_commands(pHba->host, DID_RESET);\n\treturn 0;\t\n}", "target": 1}
{"code": "void ewk_view_scrollbars_visible_get(Evas_Object* ewkView, bool* visible)\n{\n    DBG(\"%s, o=%p\", __func__, ewkView);\n    *visible = false;\n    evas_object_smart_callback_call(ewkView, \"scrollbars,visible,get\", visible);\n}", "target": 0}
{"code": "sudoers_lookup(struct sudo_nss_list *snl, struct sudoers_context *ctx,\n    time_t now, sudoers_lookup_callback_fn_t callback, void *cb_data,\n    int *cmnd_status, int pwflag)\n{\n    struct defaults_list *defs = NULL;\n    struct sudoers_parse_tree *parse_tree = NULL;\n    struct cmndspec *cs = NULL;\n    struct sudo_nss *nss;\n    struct cmnd_info info;\n    unsigned int validated = FLAG_NO_USER | FLAG_NO_HOST;\n    int m, match = UNSPEC;\n    debug_decl(sudoers_lookup, SUDOERS_DEBUG_PARSER);\n    if (pwflag) {\n\tdebug_return_uint(sudoers_lookup_pseudo(snl, ctx, now, callback,\n\t    cb_data, pwflag));\n    }\n    if (!set_perms(ctx, PERM_RUNAS))\n\tdebug_return_uint(validated);\n    TAILQ_FOREACH(nss, snl, entries) {\n\tif (nss->query(ctx, nss, ctx->user.pw) == -1) {\n\t    SET(validated, VALIDATE_ERROR);\n\t    break;\n\t}\n\tm = sudoers_lookup_check(nss, ctx, &validated, &info, now, callback,\n\t    cb_data, &cs, &defs);\n\tif (m != UNSPEC) {\n\t    match = m;\n\t    parse_tree = nss->parse_tree;\n\t}\n\tif (!sudo_nss_can_continue(nss, m))\n\t    break;\n    }\n    if (match != UNSPEC) {\n\tif (info.cmnd_path != NULL) {\n\t    free(ctx->user.cmnd);\n\t    ctx->user.cmnd = info.cmnd_path;\n\t    if (ctx->user.cmnd_stat != NULL)\n\t\t*ctx->user.cmnd_stat = info.cmnd_stat;\n\t    *cmnd_status = info.status;\n\t}\n\tif (defs != NULL)\n\t    (void)update_defaults(ctx, parse_tree, defs, SETDEF_GENERIC, false);\n\tif (!apply_cmndspec(ctx, cs))\n\t    SET(validated, VALIDATE_ERROR);\n\telse if (match == ALLOW)\n\t    SET(validated, VALIDATE_SUCCESS);\n\telse\n\t    SET(validated, VALIDATE_FAILURE);\n    }\n    if (!restore_perms())\n\tSET(validated, VALIDATE_ERROR);\n    debug_return_uint(validated);\n}", "target": 1}
{"code": "int sub__add(struct mosquitto *context, const char *sub, uint8_t qos, uint32_t identifier, int options)\n{\n\tint rc = 0;\n\tstruct mosquitto__subhier *subhier;\n\tconst char *sharename = NULL;\n\tchar *local_sub;\n\tchar **topics;\n\tsize_t topiclen;\n\tassert(sub);\n\trc = sub__topic_tokenise(sub, &local_sub, &topics, &sharename);\n\tif(rc) return rc;\n\ttopiclen = strlen(topics[0]);\n\tif(topiclen > UINT16_MAX){\n\t\tmosquitto__free(local_sub);\n\t\tmosquitto__free(topics);\n\t\treturn MOSQ_ERR_INVAL;\n\t}\n\tHASH_FIND(hh, db.subs, topics[0], topiclen, subhier);\n\tif(!subhier){\n\t\tsubhier = sub__add_hier_entry(NULL, &db.subs, topics[0], (uint16_t)topiclen);\n\t\tif(!subhier){\n\t\t\tmosquitto__free(local_sub);\n\t\t\tmosquitto__free(topics);\n\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t}\n\t}\n\trc = sub__add_context(context, sub, qos, identifier, options, subhier, topics, sharename);\n\tmosquitto__free(local_sub);\n\tmosquitto__free(topics);\n\treturn rc;\n}", "target": 1}
{"code": "PermissionRequestType PermissionUtil::GetRequestType(ContentSettingsType type) {\n  switch (type) {\n    case CONTENT_SETTINGS_TYPE_GEOLOCATION:\n      return PermissionRequestType::PERMISSION_GEOLOCATION;\n    case CONTENT_SETTINGS_TYPE_NOTIFICATIONS:\n      return PermissionRequestType::PERMISSION_NOTIFICATIONS;\n    case CONTENT_SETTINGS_TYPE_MIDI_SYSEX:\n      return PermissionRequestType::PERMISSION_MIDI_SYSEX;\n    case CONTENT_SETTINGS_TYPE_PUSH_MESSAGING:\n      return PermissionRequestType::PERMISSION_PUSH_MESSAGING;\n    case CONTENT_SETTINGS_TYPE_PROTECTED_MEDIA_IDENTIFIER:\n      return PermissionRequestType::PERMISSION_PROTECTED_MEDIA_IDENTIFIER;\n    case CONTENT_SETTINGS_TYPE_PLUGINS:\n      return PermissionRequestType::PERMISSION_FLASH;\n    default:\n      NOTREACHED();\n      return PermissionRequestType::UNKNOWN;\n  }\n}", "target": 0}
{"code": "static void atomic2gen (lua_State *L, global_State *g) {\n  g->gcstate = GCSswpallgc;\n  sweep2old(L, &g->allgc);\n  g->reallyold = g->old = g->survival = g->allgc;\n  sweep2old(L, &g->finobj);\n  g->finobjrold = g->finobjold = g->finobjsur = g->finobj;\n  sweep2old(L, &g->tobefnz);\n  g->gckind = KGC_GEN;\n  g->lastatomic = 0;\n  g->GCestimate = gettotalbytes(g);  \n  finishgencycle(L, g);\n}", "target": 0}
{"code": "spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n\t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n\t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n{\n    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n\t\t\t\t  iov_count);\n}", "target": 1}
{"code": "rb_reg_error_desc(VALUE str, int options, const char *err)\n{\n    return rb_enc_reg_error_desc(RSTRING_PTR(str), RSTRING_LEN(str),\n\t\t\t\t rb_enc_get(str), options, err);\n}", "target": 0}
{"code": "get_principal_2_svc(gprinc_arg *arg, struct svc_req *rqstp)\n{\n    static gprinc_ret               ret;\n    char                            *prime_arg, *funcname;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_gprinc_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    funcname = \"kadm5_get_principal\";\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (! cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ) &&\n        (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                        rqst2name(rqstp),\n                                                        ACL_INQUIRE,\n                                                        arg->princ,\n                                                        NULL))) {\n        ret.code = KADM5_AUTH_GET;\n        log_unauth(funcname, prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_get_principal(handle, arg->princ, &ret.rec,\n                                       arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(funcname, prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "context_parse_args (FlatpakContext *context,\n                    ...)\n{\n  g_autoptr(GError) local_error = NULL;\n  g_autoptr(GOptionContext) oc = NULL;\n  g_autoptr(GOptionGroup) group = NULL;\n  g_autoptr(GPtrArray) args = g_ptr_array_new_with_free_func (g_free);\n  g_auto(GStrv) argv = NULL;\n  const char *arg;\n  va_list ap;\n  g_ptr_array_add (args, g_strdup (\"argv[0]\"));\n  va_start (ap, context);\n  while ((arg = va_arg (ap, const char *)) != NULL)\n    g_ptr_array_add (args, g_strdup (arg));\n  va_end (ap);\n  g_ptr_array_add (args, NULL);\n  argv = (GStrv) g_ptr_array_free (g_steal_pointer (&args), FALSE);\n  oc = g_option_context_new (\"\");\n  group = flatpak_context_get_options (context);\n  g_option_context_add_group (oc, group);\n  g_option_context_parse_strv (oc, &argv, &local_error);\n  g_assert_no_error (local_error);\n}", "target": 1}
{"code": "ev_archive_get_archive_type (EvArchive *archive)\n{\n\tg_return_val_if_fail (EV_IS_ARCHIVE (archive), EV_ARCHIVE_TYPE_NONE);\n\treturn archive->type;\n}", "target": 0}
{"code": "static ssize_t cm_write(struct file *file, const char __user * user_buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstatic char *buf;\n\tstatic u32 max_size;\n\tstatic u32 uncopied_bytes;\n\tstruct acpi_table_header table;\n\tacpi_status status;\n\tif (!(*ppos)) {\n\t\tif (count <= sizeof(struct acpi_table_header))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&table, user_buf,\n\t\t\t\t   sizeof(struct acpi_table_header)))\n\t\t\treturn -EFAULT;\n\t\tuncopied_bytes = max_size = table.length;\n\t\tbuf = kzalloc(max_size, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (buf == NULL)\n\t\treturn -EINVAL;\n\tif ((*ppos > max_size) ||\n\t    (*ppos + count > max_size) ||\n\t    (*ppos + count < count) ||\n\t    (count > uncopied_bytes))\n\t\treturn -EINVAL;\n\tif (copy_from_user(buf + (*ppos), user_buf, count)) {\n\t\tkfree(buf);\n\t\tbuf = NULL;\n\t\treturn -EFAULT;\n\t}\n\tuncopied_bytes -= count;\n\t*ppos += count;\n\tif (!uncopied_bytes) {\n\t\tstatus = acpi_install_method(buf);\n\t\tkfree(buf);\n\t\tbuf = NULL;\n\t\tif (ACPI_FAILURE(status))\n\t\t\treturn -EINVAL;\n\t\tadd_taint(TAINT_OVERRIDDEN_ACPI_TABLE);\n\t}\n\treturn count;\n}", "target": 0}
{"code": "cib_send_tls(gnutls_session * session, xmlNode * msg)\n{\n    char *xml_text = NULL;\n#  if 0\n    const char *name = crm_element_name(msg);\n    if (safe_str_neq(name, \"cib_command\")) {\n        xmlNodeSetName(msg, \"cib_result\");\n    }\n#  endif\n    xml_text = dump_xml_unformatted(msg);\n    if (xml_text != NULL) {\n        char *unsent = xml_text;\n        int len = strlen(xml_text);\n        int rc = 0;\n        len++;                  \n        crm_trace(\"Message size: %d\", len);\n        while (TRUE) {\n            rc = gnutls_record_send(*session, unsent, len);\n            crm_debug(\"Sent %d bytes\", rc);\n            if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN) {\n                crm_debug(\"Retry\");\n            } else if (rc < 0) {\n                crm_debug(\"Connection terminated\");\n                break;\n            } else if (rc < len) {\n                crm_debug(\"Only sent %d of %d bytes\", rc, len);\n                len -= rc;\n                unsent += rc;\n            } else {\n                break;\n            }\n        }\n    }\n    free(xml_text);\n    return NULL;\n}", "target": 1}
{"code": "enum ImapAuthRes imap_auth_login(struct ImapData *idata, const char *method)\n{\n  char q_user[SHORT_STRING], q_pass[SHORT_STRING];\n  char buf[STRING];\n  int rc;\n  if (mutt_bit_isset(idata->capabilities, LOGINDISABLED))\n  {\n    mutt_message(_(\"LOGIN disabled on this server.\"));\n    return IMAP_AUTH_UNAVAIL;\n  }\n  if (mutt_account_getuser(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n  if (mutt_account_getpass(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n  mutt_message(_(\"Logging in...\"));\n  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user);\n  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass);\n  if (DebugLevel < IMAP_LOG_PASS)\n    mutt_debug(2, \"Sending LOGIN command for %s...\\n\", idata->conn->account.user);\n  snprintf(buf, sizeof(buf), \"LOGIN %s %s\", q_user, q_pass);\n  rc = imap_exec(idata, buf, IMAP_CMD_FAIL_OK | IMAP_CMD_PASS);\n  if (!rc)\n  {\n    mutt_clear_error(); \n    return IMAP_AUTH_SUCCESS;\n  }\n  mutt_error(_(\"Login failed.\"));\n  return IMAP_AUTH_FAILURE;\n}", "target": 1}
{"code": "TfLiteTensor* GetVariableInput(TfLiteContext* context, const TfLiteNode* node,\n                               int index) {\n  TfLiteTensor* tensor = GetMutableInput(context, node, index);\n  if (tensor == nullptr) return nullptr;\n  return tensor->is_variable ? tensor : nullptr;\n}", "target": 0}
{"code": "static void do_free_keypair(struct rsa_keypair *s)\n{\n\tsss_status_t st = kStatus_SSS_Fail;\n\tsss_se05x_object_t k_object = { };\n\tuint32_t key_id = 0;\n\tif (!s)\n\t\treturn;\n\tkey_id = se050_rsa_keypair_from_nvm(s);\n\tif (key_id) {\n\t\tst = sss_se05x_key_object_get_handle(&k_object, key_id);\n\t\tif (st == kStatus_SSS_Success)\n\t\t\tsss_se05x_key_store_erase_key(se050_kstore, &k_object);\n\t}\n\tcrypto_bignum_free(s->e);\n\tcrypto_bignum_free(s->d);\n\tcrypto_bignum_free(s->n);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\tcrypto_bignum_free(s->qp);\n\tcrypto_bignum_free(s->dp);\n\tcrypto_bignum_free(s->dq);\n}", "target": 1}
{"code": "void rose_start_t3timer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tdel_timer(&rose->timer);\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->t3;\n\tadd_timer(&rose->timer);\n}", "target": 1}
{"code": "Opal::Call::get_remote_party_name () const\n{\n  return remote_party_name;\n}", "target": 0}
{"code": "static inline pmd_t pmd_read_atomic(pmd_t *pmdp)\n{\n\treturn *pmdp;\n}", "target": 0}
{"code": "static Jsi_RC NumberToExponentialCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[100];\n    int prec = 0, skip = 0;\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    if (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &prec) != JSI_OK)\n        return JSI_ERROR;\n    if (prec<0) prec = 0;\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    snprintf(buf, sizeof(buf), \"%.*\" JSI_NUMEFMT, prec, num);\n#ifdef __WIN32\n    char *e = strrchr(buf, 'e');\n    if (e && (e[1]=='+' || e[1]=='-')) {\n        e++;\n        int eNum = atoi(e);\n        if (e[0]=='-')\n            eNum = -eNum;\n        e++;\n        snprintf(e, (e-buf), \"%02d\", eNum);\n    }\n#endif\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}", "target": 1}
{"code": "BGD_DECLARE(gdImagePtr) gdImageCropThreshold(gdImagePtr im, const unsigned int color, const float threshold)\n{\n\tconst int width = gdImageSX(im);\n\tconst int height = gdImageSY(im);\n\tint x,y;\n\tint match;\n\tgdRect crop;\n\tcrop.x = 0;\n\tcrop.y = 0;\n\tcrop.width = 0;\n\tcrop.height = 0;\n\tif (threshold > 100.0) {\n\t\treturn NULL;\n\t}\n\tif (color < 0 || (!gdImageTrueColor(im) && color >= gdImageColorsTotal(im))) {\n\t\treturn NULL;\n\t}\n\tmatch = 1;\n\tfor (y = 0; match && y < height; y++) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tif (y == height - 1) {\n\t\treturn NULL;\n\t}\n\tcrop.y = y -1;\n\tmatch = 1;\n\tfor (y = height - 1; match && y >= 0; y--) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x, y), threshold)) > 0;\n\t\t}\n\t}\n\tif (y == 0) {\n\t\tcrop.height = height - crop.y + 1;\n\t} else {\n\t\tcrop.height = y - crop.y + 2;\n\t}\n\tmatch = 1;\n\tfor (x = 0; match && x < width; x++) {\n\t\tfor (y = 0; match && y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.x = x - 1;\n\tmatch = 1;\n\tfor (x = width - 1; match && x >= 0; x--) {\n\t\tfor (y = 0; match &&  y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.width = x - crop.x + 2;\n\treturn gdImageCrop(im, &crop);\n}", "target": 0}
{"code": "BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageWebpCtx(im, out, quality);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}", "target": 1}
{"code": "static int get_bitmap_file(struct mddev *mddev, void __user * arg)\n{\n\tmdu_bitmap_file_t *file = NULL; \n\tchar *ptr;\n\tint err;\n\tfile = kmalloc(sizeof(*file), GFP_NOIO);\n\tif (!file)\n\t\treturn -ENOMEM;\n\terr = 0;\n\tspin_lock(&mddev->lock);\n\tif (!mddev->bitmap_info.file)\n\t\tfile->pathname[0] = '\\0';\n\telse if ((ptr = file_path(mddev->bitmap_info.file,\n\t\t\t       file->pathname, sizeof(file->pathname))),\n\t\t IS_ERR(ptr))\n\t\terr = PTR_ERR(ptr);\n\telse\n\t\tmemmove(file->pathname, ptr,\n\t\t\tsizeof(file->pathname)-(ptr-file->pathname));\n\tspin_unlock(&mddev->lock);\n\tif (err == 0 &&\n\t    copy_to_user(arg, file, sizeof(*file)))\n\t\terr = -EFAULT;\n\tkfree(file);\n\treturn err;\n}", "target": 1}
{"code": "  Status CalculateOutputIndexValueRowID(\n      const RowPartitionTensor& value_rowids,\n      const vector<INDEX_TYPE>& parent_output_index,\n      INDEX_TYPE output_index_multiplier, INDEX_TYPE output_size,\n      vector<INDEX_TYPE>* result) {\n    const INDEX_TYPE index_size = value_rowids.size();\n    result->reserve(index_size);\n    if (index_size == 0) {\n      return Status::OK();\n    }\n    INDEX_TYPE current_output_column = 0;\n    INDEX_TYPE current_value_rowid = value_rowids(0);\n    if (current_value_rowid >= parent_output_index.size()) {\n      return errors::InvalidArgument(\n          \"Got current_value_rowid=\", current_value_rowid,\n          \" which is not less than \", parent_output_index.size());\n    }\n    INDEX_TYPE current_output_index = parent_output_index[current_value_rowid];\n    result->push_back(current_output_index);\n    for (INDEX_TYPE i = 1; i < index_size; ++i) {\n      INDEX_TYPE next_value_rowid = value_rowids(i);\n      if (next_value_rowid == current_value_rowid) {\n        if (current_output_index >= 0) {\n          ++current_output_column;\n          if (current_output_column < output_size) {\n            current_output_index += output_index_multiplier;\n          } else {\n            current_output_index = -1;\n          }\n        }\n      } else {\n        current_output_column = 0;\n        current_value_rowid = next_value_rowid;\n        if (next_value_rowid >= parent_output_index.size()) {\n          return errors::InvalidArgument(\n              \"Got next_value_rowid=\", next_value_rowid,\n              \" which is not less than \", parent_output_index.size());\n        }\n        current_output_index = parent_output_index[next_value_rowid];\n      }\n      result->push_back(current_output_index);\n    }\n    if (result->size() != value_rowids.size()) {\n      return errors::InvalidArgument(\"Invalid row ids.\");\n    }\n    return Status::OK();\n  }", "target": 0}
{"code": "segment_size (Elf_Internal_Phdr *segment)\n{\n  return (segment->p_memsz > segment->p_filesz\n\t  ? segment->p_memsz : segment->p_filesz);\n}", "target": 0}
{"code": "static void ptirq_free_irte(const struct ptirq_remapping_info *entry)\n{\n\tstruct intr_source intr_src;\n\tif (entry->irte_idx < CONFIG_MAX_IR_ENTRIES) {\n\t\tif (entry->intr_type == PTDEV_INTR_MSI) {\n\t\t\tintr_src.is_msi = true;\n\t\t\tintr_src.src.msi.value = entry->phys_sid.msi_id.bdf;\n\t\t} else {\n\t\t\tintr_src.is_msi = false;\n\t\t\tintr_src.src.ioapic_id = ioapic_irq_to_ioapic_id(entry->allocated_pirq);\n\t\t}\n\t\tdmar_free_irte(&intr_src, entry->irte_idx);\n\t}\n}", "target": 1}
{"code": "static void upnp_event_prepare(struct upnp_event_notify * obj)\n{\n\tstatic const char notifymsg[] =\n\t\t\"NOTIFY %s HTTP/1.1\\r\\n\"\n\t\t\"Host: %s%s\\r\\n\"\n#if (UPNP_VERSION_MAJOR == 1) && (UPNP_VERSION_MINOR == 0)\n\t\t\"Content-Type: text/xml\\r\\n\"\t\n#else\n\t\t\"Content-Type: text/xml; charset=\\\"utf-8\\\"\\r\\n\"\t\n#endif\n\t\t\"Content-Length: %d\\r\\n\"\n\t\t\"NT: upnp:event\\r\\n\"\n\t\t\"NTS: upnp:propchange\\r\\n\"\n\t\t\"SID: %s\\r\\n\"\n\t\t\"SEQ: %u\\r\\n\"\n\t\t\"Connection: close\\r\\n\"\n\t\t\"Cache-Control: no-cache\\r\\n\"\n\t\t\"\\r\\n\"\n\t\t\"%.*s\\r\\n\";\n\tchar * xml;\n\tint l;\n\tif(obj->sub == NULL) {\n\t\tobj->state = EError;\n\t\treturn;\n\t}\n\tswitch(obj->sub->service) {\n\tcase EWanCFG:\n\t\txml = getVarsWANCfg(&l);\n\t\tbreak;\n\tcase EWanIPC:\n\t\txml = getVarsWANIPCn(&l);\n\t\tbreak;\n#ifdef ENABLE_L3F_SERVICE\n\tcase EL3F:\n\t\txml = getVarsL3F(&l);\n\t\tbreak;\n#endif\n#ifdef ENABLE_6FC_SERVICE\n\tcase E6FC:\n\t\txml = getVars6FC(&l);\n\t\tbreak;\n#endif\n#ifdef ENABLE_DP_SERVICE\n\tcase EDP:\n\t\txml = getVarsDP(&l);\n\t\tbreak;\n#endif\n\tdefault:\n\t\txml = NULL;\n\t\tl = 0;\n\t}\n\tobj->buffersize = 1024;\n\tobj->buffer = malloc(obj->buffersize);\n\tif(!obj->buffer) {\n\t\tsyslog(LOG_ERR, \"%s: malloc returned NULL\", \"upnp_event_prepare\");\n\t\tif(xml) {\n\t\t\tfree(xml);\n\t\t}\n\t\tobj->state = EError;\n\t\treturn;\n\t}\n\tobj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,\n\t                       obj->path, obj->addrstr, obj->portstr, l+2,\n\t                       obj->sub->uuid, obj->sub->seq,\n\t                       l, xml);\n\tif(xml) {\n\t\tfree(xml);\n\t\txml = NULL;\n\t}\n\tobj->state = ESending;\n}", "target": 1}
{"code": "std::wstring MB2WC(const std::string& input, unsigned int code_page) {\n  if (input.empty()) {\n    return L\"\";\n  }\n  int length = ::MultiByteToWideChar(code_page, 0, &input[0],\n                                     static_cast<int>(input.size()),\n                                     NULL, 0);\n  std::wstring output(length, '\\0');\n  ::MultiByteToWideChar(code_page, 0, &input[0], static_cast<int>(input.size()),\n                        &output[0], static_cast<int>(output.size()));\n  return output;\n}", "target": 1}
{"code": "bool Item_trigger_field::fix_fields(THD *thd, Item **items)\n{\n  DBUG_ASSERT(fixed == 0);\n  if (field_idx != (uint)-1)\n  {\n#ifndef NO_EMBEDDED_ACCESS_CHECKS\n    if (table_grants)\n    {\n      table_grants->want_privilege= want_privilege;\n      if (check_grant_column(thd, table_grants, triggers->trigger_table->s->db.str,\n                             triggers->trigger_table->s->table_name.str, field_name,\n                             strlen(field_name), thd->security_ctx))\n        return TRUE;\n    }\n#endif \n    field= (row_version == OLD_ROW) ? triggers->old_field[field_idx] :\n                                      triggers->new_field[field_idx];\n    set_field(field);\n    fixed= 1;\n    return FALSE;\n  }\n  my_error(ER_BAD_FIELD_ERROR, MYF(0), field_name,\n           (row_version == NEW_ROW) ? \"NEW\" : \"OLD\");\n  return TRUE;\n}", "target": 0}
{"code": "static int ims_pcu_parse_cdc_data(struct usb_interface *intf, struct ims_pcu *pcu)\n{\n\tconst struct usb_cdc_union_desc *union_desc;\n\tstruct usb_host_interface *alt;\n\tunion_desc = ims_pcu_get_cdc_union_desc(intf);\n\tif (!union_desc)\n\t\treturn -EINVAL;\n\tpcu->ctrl_intf = usb_ifnum_to_if(pcu->udev,\n\t\t\t\t\t union_desc->bMasterInterface0);\n\tif (!pcu->ctrl_intf)\n\t\treturn -EINVAL;\n\talt = pcu->ctrl_intf->cur_altsetting;\n\tpcu->ep_ctrl = &alt->endpoint[0].desc;\n\tpcu->max_ctrl_size = usb_endpoint_maxp(pcu->ep_ctrl);\n\tpcu->data_intf = usb_ifnum_to_if(pcu->udev,\n\t\t\t\t\t union_desc->bSlaveInterface0);\n\tif (!pcu->data_intf)\n\t\treturn -EINVAL;\n\talt = pcu->data_intf->cur_altsetting;\n\tif (alt->desc.bNumEndpoints != 2) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Incorrect number of endpoints on data interface (%d)\\n\",\n\t\t\talt->desc.bNumEndpoints);\n\t\treturn -EINVAL;\n\t}\n\tpcu->ep_out = &alt->endpoint[0].desc;\n\tif (!usb_endpoint_is_bulk_out(pcu->ep_out)) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"First endpoint on data interface is not BULK OUT\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpcu->max_out_size = usb_endpoint_maxp(pcu->ep_out);\n\tif (pcu->max_out_size < 8) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Max OUT packet size is too small (%zd)\\n\",\n\t\t\tpcu->max_out_size);\n\t\treturn -EINVAL;\n\t}\n\tpcu->ep_in = &alt->endpoint[1].desc;\n\tif (!usb_endpoint_is_bulk_in(pcu->ep_in)) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Second endpoint on data interface is not BULK IN\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpcu->max_in_size = usb_endpoint_maxp(pcu->ep_in);\n\tif (pcu->max_in_size < 8) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Max IN packet size is too small (%zd)\\n\",\n\t\t\tpcu->max_in_size);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;", "target": 0}
{"code": "inline uint32_t mult_alpha(uint32_t a, uint32_t b)\n{\n    return 0xFF - (0xFF - a) * (0xFF - b) / 0xFF;\n}", "target": 0}
{"code": "static int adjust_insn_aux_data(struct bpf_verifier_env *env, u32 prog_len,\n\t\t\t\tu32 off, u32 cnt)\n{\n\tstruct bpf_insn_aux_data *new_data, *old_data = env->insn_aux_data;\n\tint i;\n\tif (cnt == 1)\n\t\treturn 0;\n\tnew_data = vzalloc(sizeof(struct bpf_insn_aux_data) * prog_len);\n\tif (!new_data)\n\t\treturn -ENOMEM;\n\tmemcpy(new_data, old_data, sizeof(struct bpf_insn_aux_data) * off);\n\tmemcpy(new_data + off + cnt - 1, old_data + off,\n\t       sizeof(struct bpf_insn_aux_data) * (prog_len - off - cnt + 1));\n\tfor (i = off; i < off + cnt - 1; i++)\n\t\tnew_data[i].seen = true;\n\tenv->insn_aux_data = new_data;\n\tvfree(old_data);\n\treturn 0;\n}", "target": 0}
{"code": "int cipso_v4_sock_setattr(struct sock *sk,\n\t\t\t  const struct cipso_v4_doi *doi_def,\n\t\t\t  const struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val = -EPERM;\n\tunsigned char *buf = NULL;\n\tu32 buf_len;\n\tu32 opt_len;\n\tstruct ip_options *opt = NULL;\n\tstruct inet_sock *sk_inet;\n\tstruct inet_connection_sock *sk_conn;\n\tif (sk == NULL)\n\t\treturn 0;\n\tbuf_len = CIPSO_V4_OPT_LEN_MAX;\n\tbuf = kmalloc(buf_len, GFP_ATOMIC);\n\tif (buf == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto socket_setattr_failure;\n\t}\n\tret_val = cipso_v4_genopt(buf, buf_len, doi_def, secattr);\n\tif (ret_val < 0)\n\t\tgoto socket_setattr_failure;\n\tbuf_len = ret_val;\n\topt_len = (buf_len + 3) & ~3;\n\topt = kzalloc(sizeof(*opt) + opt_len, GFP_ATOMIC);\n\tif (opt == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto socket_setattr_failure;\n\t}\n\tmemcpy(opt->__data, buf, buf_len);\n\topt->optlen = opt_len;\n\topt->cipso = sizeof(struct iphdr);\n\tkfree(buf);\n\tbuf = NULL;\n\tsk_inet = inet_sk(sk);\n\tif (sk_inet->is_icsk) {\n\t\tsk_conn = inet_csk(sk);\n\t\tif (sk_inet->opt)\n\t\t\tsk_conn->icsk_ext_hdr_len -= sk_inet->opt->optlen;\n\t\tsk_conn->icsk_ext_hdr_len += opt->optlen;\n\t\tsk_conn->icsk_sync_mss(sk, sk_conn->icsk_pmtu_cookie);\n\t}\n\topt = xchg(&sk_inet->opt, opt);\n\tkfree(opt);\n\treturn 0;\nsocket_setattr_failure:\n\tkfree(buf);\n\tkfree(opt);\n\treturn ret_val;\n}", "target": 1}
{"code": "static void __exit acpi_custom_method_exit(void)\n{\n\tif (cm_dentry)\n\t\tdebugfs_remove(cm_dentry);\n }", "target": 0}
{"code": "static int parse_timecode_in_framenum_format(AVFormatContext *s, AVStream *st,\n                                             int64_t value, int flags)\n{\n    AVTimecode tc;\n    char buf[AV_TIMECODE_STR_SIZE];\n    AVRational rate = st->avg_frame_rate;\n    int ret = av_timecode_init(&tc, rate, flags, 0, s);\n    if (ret < 0)\n        return ret;\n    av_dict_set(&st->metadata, \"timecode\",\n                av_timecode_make_string(&tc, buf, value), 0);\n    return 0;\n}", "target": 0}
{"code": "auth_line_is_valid (guint8 *line, guint8 *line_end)\n{\n  guint8 *p;\n  for (p = line; p < line_end; p++)\n    {\n      if (!_DBUS_ISASCII(*p))\n        return FALSE;\n      if (*p < ' ')\n        return FALSE;\n    }\n  if (line[0] < 'A' || line[0] > 'Z')\n    return FALSE;\n  return TRUE;\n}", "target": 0}
{"code": "void test_stat(const char *path)\n{\n\tstruct stat sb;\n\tif (stat(path, &sb) >= 0) {\n\t\tfprintf(stderr, \"leak at stat of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at stat of %s: errno was %d\\n\", path, errno);\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "bool Filter::parseTlvs(const uint8_t* buf, size_t len) {\n  size_t idx{0};\n  while (idx < len) {\n    const uint8_t tlv_type = buf[idx];\n    idx++;\n    if ((idx + 1) >= len) {\n      ENVOY_LOG(debug,\n                fmt::format(\"failed to read proxy protocol extension. No bytes for TLV length. \"\n                            \"Extension length is {}, current index is {}, current type is {}.\",\n                            len, idx, tlv_type));\n      return false;\n    }\n    const uint8_t tlv_length_upper = buf[idx];\n    const uint8_t tlv_length_lower = buf[idx + 1];\n    const size_t tlv_value_length = (tlv_length_upper << 8) + tlv_length_lower;\n    idx += 2;\n    if ((idx + tlv_value_length - 1) >= len) {\n      ENVOY_LOG(\n          debug,\n          fmt::format(\"failed to read proxy protocol extension. No bytes for TLV value. \"\n                      \"Extension length is {}, current index is {}, current type is {}, current \"\n                      \"value length is {}.\",\n                      len, idx, tlv_type, tlv_length_upper));\n      return false;\n    }\n    absl::string_view tlv_value(reinterpret_cast<char const*>(buf + idx), tlv_value_length);\n    auto key_value_pair = config_->isTlvTypeNeeded(tlv_type);\n    if (nullptr != key_value_pair) {\n      ProtobufWkt::Value metadata_value;\n      metadata_value.set_string_value(tlv_value.data(), tlv_value.size());\n      std::string metadata_key = key_value_pair->metadata_namespace().empty()\n                                     ? \"envoy.filters.listener.proxy_protocol\"\n                                     : key_value_pair->metadata_namespace();\n      ProtobufWkt::Struct metadata(\n          (*cb_->dynamicMetadata().mutable_filter_metadata())[metadata_key]);\n      metadata.mutable_fields()->insert({key_value_pair->key(), metadata_value});\n      cb_->setDynamicMetadata(metadata_key, metadata);\n    } else {\n      ENVOY_LOG(trace,\n                \"proxy_protocol: Skip TLV of type {} since it's not needed for dynamic metadata\",\n                tlv_type);\n    }\n    if (config_->isPassThroughTlvTypeNeeded(tlv_type)) {\n      ENVOY_LOG(trace, \"proxy_protocol: Storing parsed TLV of type {} to filter state.\", tlv_type);\n      parsed_tlvs_.push_back({tlv_type, {tlv_value.begin(), tlv_value.end()}});\n    }\n    idx += tlv_value_length;\n    ASSERT(idx <= len);\n  }\n  return true;\n}", "target": 1}
{"code": "static inline int ok_jpg_peek_bits(ok_jpg_decoder *decoder, int num_bits) {\n    return (int)((decoder->input_buffer_bits >> (decoder->input_buffer_bit_count - num_bits)) &\n                 ((1 << num_bits) - 1));\n}", "target": 0}
{"code": "static CPINLINE zend_class_entry* swoole_try_get_ce(zend_string *class_name)\n{\n    zend_class_entry *ce = zend_lookup_class(class_name);\n    if (ce)\n    {\n        return ce;\n    }\n    zval user_func, args[1], retval;\n    if ((PG(unserialize_callback_func) == NULL) || (PG(unserialize_callback_func)[0] == '\\0'))\n    {\n        zend_throw_exception_ex(NULL, 0, \"can not find class %s\", class_name->val TSRMLS_CC);\n        return NULL;\n    }\n    zend_string *fname = swoole_string_init(ZEND_STRL(PG(unserialize_callback_func)));\n    Z_STR(user_func) = fname;\n    Z_TYPE_INFO(user_func) = IS_STRING_EX;\n    ZVAL_STR(&args[0], class_name);\n    call_user_function_ex(CG(function_table), NULL, &user_func, &retval, 1, args, 0, NULL);\n    swoole_string_release(fname);\n    ce = zend_lookup_class(class_name);\n    if (!ce)\n    {\n        zend_throw_exception_ex(NULL, 0, \"can not find class %s\", class_name->val TSRMLS_CC);\n        return NULL;\n    }\n    else\n    {\n        return ce;\n    }\n}", "target": 1}
{"code": "TEST_P(JSITest, HostObjectProtoTest) {\n  class ProtoHostObject : public HostObject {\n    Value get(Runtime& rt, const PropNameID&) override {\n      return String::createFromAscii(rt, \"phoprop\");\n    }\n  };\n  rt.global().setProperty(\n      rt,\n      \"pho\",\n      Object::createFromHostObject(rt, std::make_shared<ProtoHostObject>()));\n  EXPECT_EQ(\n      eval(\"({__proto__: pho})[Symbol.toPrimitive]\").getString(rt).utf8(rt),\n      \"phoprop\");\n}", "target": 0}
{"code": "sg_common_write(Sg_fd * sfp, Sg_request * srp,\n\t\tunsigned char *cmnd, int timeout, int blocking)\n{\n\tint k, at_head;\n\tSg_device *sdp = sfp->parentdp;\n\tsg_io_hdr_t *hp = &srp->header;\n\tsrp->data.cmd_opcode = cmnd[0];\t\n\thp->status = 0;\n\thp->masked_status = 0;\n\thp->msg_status = 0;\n\thp->info = 0;\n\thp->host_status = 0;\n\thp->driver_status = 0;\n\thp->resid = 0;\n\tSCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\"sg_common_write:  scsi opcode=0x%02x, cmd_size=%d\\n\",\n\t\t\t(int) cmnd[0], (int) hp->cmd_len));\n\tk = sg_start_req(srp, cmnd);\n\tif (k) {\n\t\tSCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\"sg_common_write: start_req err=%d\\n\", k));\n\t\tsg_finish_rem_req(srp);\n\t\treturn k;\t\n\t}\n\tif (atomic_read(&sdp->detaching)) {\n\t\tif (srp->bio)\n\t\t\tblk_end_request_all(srp->rq, -EIO);\n\t\tsg_finish_rem_req(srp);\n\t\treturn -ENODEV;\n\t}\n\thp->duration = jiffies_to_msecs(jiffies);\n\tif (hp->interface_id != '\\0' &&\t\n\t    (SG_FLAG_Q_AT_TAIL & hp->flags))\n\t\tat_head = 0;\n\telse\n\t\tat_head = 1;\n\tsrp->rq->timeout = timeout;\n\tkref_get(&sfp->f_ref); \n\tblk_execute_rq_nowait(sdp->device->request_queue, sdp->disk,\n\t\t\t      srp->rq, at_head, sg_rq_end_io);\n\treturn 0;\n}", "target": 1}
{"code": "TfLiteStatus GetIntermediatesSafe(const TfLiteContext* context,\n                                  const TfLiteNode* node, int index,\n                                  TfLiteTensor** tensor) {\n  int tensor_index;\n  TF_LITE_ENSURE_OK(context, ValidateTensorIndexingSafe(\n                                 context, index, node->intermediates->size,\n                                 node->intermediates->data, &tensor_index));\n  *tensor = GetTensorAtIndex(context, tensor_index);\n  return kTfLiteOk;\n}", "target": 0}
{"code": "unsigned long OPENSSL_LH_get_down_load(const OPENSSL_LHASH *lh)\n{\n    return lh->down_load;\n}", "target": 0}
{"code": "ice_protocol_timeout (IceConn ice_conn)\n{\n        GsmIceConnectionWatch *data;\n        g_debug (\"GsmXsmpServer: ice_protocol_timeout for IceConn %p with status %d\",\n                 ice_conn, IceConnectionStatus (ice_conn));\n        data = ice_conn->context;\n        free_ice_connection_watch (data);\n        disconnect_ice_connection (ice_conn);\n        return FALSE;\n}", "target": 0}
{"code": "xmlIsStreaming(xmlValidCtxtPtr ctxt) {\n    xmlParserCtxtPtr pctxt;\n    if (ctxt == NULL)\n        return(0);\n    if ((ctxt->finishDtd != XML_CTXT_FINISH_DTD_0) &&\n        (ctxt->finishDtd != XML_CTXT_FINISH_DTD_1))\n        return(0);\n    pctxt = ctxt->userData;\n    return(pctxt->parseMode == XML_PARSE_READER);\n}", "target": 0}
{"code": "static void audit_log_execve_info(struct audit_context *context,\n\t\t\t\t  struct audit_buffer **ab)\n{\n\tint i, len;\n\tsize_t len_sent = 0;\n\tconst char __user *p;\n\tchar *buf;\n\tp = (const char __user *)current->mm->arg_start;\n\taudit_log_format(*ab, \"argc=%d\", context->execve.argc);\n\tbuf = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);\n\tif (!buf) {\n\t\taudit_panic(\"out of memory for argv string\");\n\t\treturn;\n\t}\n\tfor (i = 0; i < context->execve.argc; i++) {\n\t\tlen = audit_log_single_execve_arg(context, ab, i,\n\t\t\t\t\t\t  &len_sent, p, buf);\n\t\tif (len <= 0)\n\t\t\tbreak;\n\t\tp += len;\n\t}\n\tkfree(buf);\n}", "target": 1}
{"code": "static unsigned int UTFCharLength(uint8 lead)\n{\n  if (lead < 0x80)\n    return 1;\n  else if ((lead >> 5) == 0x6)\n    return 2;\n  else if ((lead >> 4) == 0xe)\n    return 3;\n  else if ((lead >> 3) == 0x1e)\n    return 4;\n  else\n    return 0;\n}", "target": 0}
{"code": "static UINT printer_process_irp_write(PRINTER_DEVICE* printer_dev, IRP* irp)\n{\n\tUINT32 Length;\n\tUINT64 Offset;\n\trdpPrintJob* printjob = NULL;\n\tUINT error = CHANNEL_RC_OK;\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Read_UINT64(irp->input, Offset);\n\tStream_Seek(irp->input, 20); \n\tif (printer_dev->printer)\n\t\tprintjob = printer_dev->printer->FindPrintJob(printer_dev->printer, irp->FileId);\n\tif (!printjob)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tLength = 0;\n\t}\n\telse\n\t{\n\t\terror = printjob->Write(printjob, Stream_Pointer(irp->input), Length);\n\t}\n\tif (error)\n\t{\n\t\tWLog_ERR(TAG, \"printjob->Write failed with error %\" PRIu32 \"!\", error);\n\t\treturn error;\n\t}\n\tStream_Write_UINT32(irp->output, Length);\n\tStream_Write_UINT8(irp->output, 0); \n\treturn irp->Complete(irp);\n}", "target": 1}
{"code": "static int __socket_slurp (RSocket *s, ut8 *buf, int bufsz) {\n\tint i;\n\tint chsz = 1;\n\tif (r_socket_read_block (s, (ut8 *) buf, 1) != 1) {\n\t\treturn 0;\n\t}\n\tfor (i = 1; i < bufsz; i += chsz) {\n\t\tbuf[i] =0;\n\t\tr_socket_block_time (s, 1, 0, 1000);\n\t\tint olen = r_socket_read_block (s, (ut8 *) buf + i , chsz);\n\t\tif (olen != chsz) {\n\t\t\tbuf[i] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn i;\n}", "target": 1}
{"code": "static void dbEvalSetColumnJSON(DbEvalContext *p, int iCol, Jsi_DString *dStr) {\n    Jsi_Interp *interp = p->jdb->interp;\n    char nbuf[200];\n    sqlite3_stmt *pStmt = p->pPreStmt->pStmt;\n    switch( sqlite3_column_type(pStmt, iCol) ) {\n    case SQLITE_BLOB: {\n        int bytes = sqlite3_column_bytes(pStmt, iCol);\n        const char *zBlob = (char*)sqlite3_column_blob(pStmt, iCol);\n        if( !zBlob ) {\n            Jsi_DSAppend(dStr, \"null\", NULL);\n            return;\n        }\n        Jsi_JSONQuote(interp, zBlob, bytes, dStr);\n        return;\n    }\n    case SQLITE_INTEGER: {\n        sqlite_int64 v = sqlite3_column_int64(pStmt, iCol);\n        if (v==0 || v==1) {\n            const char *dectyp = sqlite3_column_decltype(pStmt, iCol);\n            if (dectyp && !Jsi_Strncasecmp(dectyp,\"bool\", 4)) {\n                Jsi_DSAppend(dStr, (v?\"true\":\"false\"), NULL);\n                return;\n            }\n        }\n#ifdef __WIN32\n        snprintf(nbuf, sizeof(nbuf), \"%\" PRId64, (Jsi_Wide)v);\n#else\n        snprintf(nbuf, sizeof(nbuf), \"%lld\", v);\n#endif\n        Jsi_DSAppend(dStr, nbuf, NULL);\n        return;\n    }\n    case SQLITE_FLOAT: {\n        Jsi_NumberToString(interp, sqlite3_column_double(pStmt, iCol), nbuf, sizeof(nbuf));\n        Jsi_DSAppend(dStr, nbuf, NULL);\n        return;\n    }\n    case SQLITE_NULL: {\n        Jsi_DSAppend(dStr, \"null\", NULL);\n        return;\n    }\n    }\n    const char *str = (char*)sqlite3_column_text(pStmt, iCol );\n    if (!str)\n        str = p->jdb->optPtr->nullvalue;\n    Jsi_JSONQuote(interp, str?str:\"\", -1, dStr);\n}", "target": 1}
{"code": "sanitize_speculative_path(struct bpf_verifier_env *env,\n\t\t\t  const struct bpf_insn *insn,\n\t\t\t  u32 next_idx, u32 curr_idx)\n{\n\tstruct bpf_verifier_state *branch;\n\tstruct bpf_reg_state *regs;\n\tbranch = push_stack(env, next_idx, curr_idx, true);\n\tif (branch && insn) {\n\t\tregs = branch->frame[branch->curframe]->regs;\n\t\tif (BPF_SRC(insn->code) == BPF_K) {\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t} else if (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tmark_reg_unknown(env, regs, insn->src_reg);\n\t\t}\n\t}\n\treturn branch;\n}", "target": 0}
{"code": "void GfxDeviceGrayColorSpace::getGray(const GfxColor *color, GfxGray *gray) const\n{\n    *gray = clip01(color->c[0]);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& rhs = context->input(1);\n    context->forward_ref_input_to_ref_output(0, 0);\n    OP_REQUIRES(\n        context, rhs.IsInitialized(),\n        errors::Internal(\"Right hand side of AssignOp is not initialized\"));\n    AllocatorAttributes attr;\n    if (!relax_constraints_) {\n      attr.set_gpu_compatible(true);\n      attr.set_nic_compatible(true);\n    }\n    {\n      mutex_lock l(*context->input_ref_mutex(0));\n      const Tensor& old_lhs = context->mutable_input(0,  true);\n      const bool same_shape = old_lhs.shape().IsSameSize(rhs.shape());\n      if (validate_shape_) {\n        OP_REQUIRES(context, same_shape,\n                    errors::InvalidArgument(\n                        \"Assign requires shapes of both tensors to match. \"\n                        \"lhs shape= \",\n                        old_lhs.shape().DebugString(),\n                        \" rhs shape= \", rhs.shape().DebugString()));\n      }\n      if (old_lhs.IsInitialized() &&\n          old_lhs.shape().num_elements() == rhs.shape().num_elements()) {\n        Tensor reshaped_old_lhs;\n        if (same_shape) {\n          reshaped_old_lhs = old_lhs;\n        } else {\n          CHECK(reshaped_old_lhs.CopyFrom(old_lhs, rhs.shape()));\n          context->replace_ref_input(0, reshaped_old_lhs,\n                                      true);\n        }\n        if (use_exclusive_lock_) {\n          Copy(context, &reshaped_old_lhs, rhs);\n          return;\n        }\n      } else {\n        std::unique_ptr<Tensor> input_alias = context->forward_input(\n            1, OpKernelContext::Params::kNoReservation ,\n            rhs.dtype(), rhs.shape(), DEVICE_MEMORY, attr);\n        if (input_alias != nullptr) {\n          context->replace_ref_input(0, *input_alias,  true);\n          return;\n        }\n        Tensor copy_tensor;\n        OP_REQUIRES_OK(context,\n                       context->allocate_temp(old_lhs.dtype(), rhs.shape(),\n                                              &copy_tensor, attr));\n        context->clear_recorded_memory();\n        context->replace_ref_input(0, copy_tensor,  true);\n        if (use_exclusive_lock_) {\n          Copy(context, &copy_tensor, rhs);\n          return;\n        }\n      }\n    }\n    Tensor old_unlocked_lhs = context->mutable_input(0,  false);\n    Copy(context, &old_unlocked_lhs, rhs);\n  }", "target": 0}
{"code": "snmp_mib_add(snmp_mib_resource_t *new_resource)\n{\n  snmp_mib_resource_t *resource;\n  for(resource = list_head(snmp_mib);\n      resource; resource = resource->next) {\n    if(snmp_oid_cmp_oid(resource->oid, new_resource->oid) > 0) {\n      break;\n    }\n  }\n  if(resource == NULL) {\n    list_add(snmp_mib, new_resource);\n  } else {\n    list_insert(snmp_mib, new_resource, resource);\n  }\n#if LOG_LEVEL == LOG_LEVEL_DBG\n  LOG_DBG(\"Table after insert.\\n\");\n  for(resource = list_head(snmp_mib);\n      resource; resource = resource->next) {\n    snmp_oid_print(resource->oid);\n  }\n#endif \n}", "target": 1}
{"code": "MONGO_EXPORT int bson_append_finish_object( bson *b ) {\n    char *start;\n    int i;\n    if ( bson_ensure_space( b, 1 ) == BSON_ERROR ) return BSON_ERROR;\n    bson_append_byte( b , 0 );\n    start = b->data + b->stack[ --b->stackPos ];\n    i = b->cur - start;\n    bson_little_endian32( start, &i );\n    return BSON_OK;\n}", "target": 1}
{"code": "int mg_http_parse(const char *s, size_t len, struct mg_http_message *hm) {\n  int is_response, req_len = mg_http_get_request_len((unsigned char *) s, len);\n  const char *end = s == NULL ? NULL : s + req_len, *qs;  \n  struct mg_str *cl;\n  memset(hm, 0, sizeof(*hm));\n  if (req_len <= 0) return req_len;\n  hm->message.ptr = hm->head.ptr = s;\n  hm->body.ptr = end;\n  hm->head.len = (size_t) req_len;\n  hm->chunk.ptr = end;\n  hm->message.len = hm->body.len = (size_t) ~0;  \n  s = skip(s, end, \" \", &hm->method);\n  s = skip(s, end, \" \", &hm->uri);\n  s = skip(s, end, \"\\r\\n\", &hm->proto);\n  if (hm->method.len == 0 || hm->uri.len == 0) return -1;\n  if ((qs = (const char *) memchr(hm->uri.ptr, '?', hm->uri.len)) != NULL) {\n    hm->query.ptr = qs + 1;\n    hm->query.len = (size_t) (&hm->uri.ptr[hm->uri.len] - (qs + 1));\n    hm->uri.len = (size_t) (qs - hm->uri.ptr);\n  }\n  mg_http_parse_headers(s, end, hm->headers,\n                        sizeof(hm->headers) / sizeof(hm->headers[0]));\n  if ((cl = mg_http_get_header(hm, \"Content-Length\")) != NULL) {\n    hm->body.len = (size_t) mg_to64(*cl);\n    hm->message.len = (size_t) req_len + hm->body.len;\n  }\n  is_response = mg_ncasecmp(hm->method.ptr, \"HTTP/\", 5) == 0;\n  if (hm->body.len == (size_t) ~0 && !is_response &&\n      mg_vcasecmp(&hm->method, \"PUT\") != 0 &&\n      mg_vcasecmp(&hm->method, \"POST\") != 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n  if (hm->body.len == (size_t) ~0 && is_response &&\n      mg_vcasecmp(&hm->uri, \"204\") == 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n  return req_len;\n}", "target": 1}
{"code": "static InspectionBuffer *GetHttp1HeaderData(DetectEngineThreadCtx *det_ctx, const uint8_t flags,\n        const DetectEngineTransforms *transforms, Flow *f, const struct MpmListIdDataArgs *cbdata,\n        int list_id)\n{\n    SCEnter();\n    InspectionBuffer *buffer =\n            InspectionBufferMultipleForListGet(det_ctx, list_id, cbdata->local_id);\n    if (buffer == NULL)\n        return NULL;\n    if (buffer->initialized)\n        return buffer;\n    HttpHeaderThreadData *hdr_td = NULL;\n    HttpHeaderBuffer *buf =\n            HttpHeaderGetBufferSpace(det_ctx, f, flags, g_keyword_thread_id, &hdr_td);\n    if (unlikely(buf == NULL)) {\n        return NULL;\n    }\n    htp_tx_t *tx = (htp_tx_t *)cbdata->txv;\n    htp_table_t *headers;\n    if (flags & STREAM_TOSERVER) {\n        headers = tx->request_headers;\n    } else {\n        headers = tx->response_headers;\n    }\n    if (cbdata->local_id < htp_table_size(headers)) {\n        htp_header_t *h = htp_table_get_index(headers, cbdata->local_id, NULL);\n        size_t size1 = bstr_size(h->name);\n        size_t size2 = bstr_size(h->value);\n        size_t b_len = size1 + 2 + size2;\n        if (b_len > buf->size) {\n            if (HttpHeaderExpandBuffer(hdr_td, buf, b_len) != 0) {\n                return NULL;\n            }\n        }\n        memcpy(buf->buffer, bstr_ptr(h->name), bstr_size(h->name));\n        buf->buffer[size1] = ':';\n        buf->buffer[size1 + 1] = ' ';\n        memcpy(buf->buffer + size1 + 2, bstr_ptr(h->value), bstr_size(h->value));\n        buf->len = b_len;\n    } else {\n        InspectionBufferSetupMultiEmpty(buffer);\n        return NULL;\n    }\n    if (buf->len == 0) {\n        InspectionBufferSetupMultiEmpty(buffer);\n        return NULL;\n    }\n    InspectionBufferSetupMulti(buffer, transforms, buf->buffer, buf->len);\n    SCReturnPtr(buffer, \"InspectionBuffer\");\n}", "target": 1}
{"code": "void handle_usb_rx(const void *msg, size_t len)\n{\n    if (msg_tiny_flag) {\n        uint8_t buf[64];\n        memcpy(buf, msg, sizeof(buf));\n        uint16_t msgId = buf[4] | ((uint16_t)buf[3]) << 8;\n        uint32_t msgSize = buf[8]        |\n                ((uint32_t)buf[7]) <<  8 |\n                ((uint32_t)buf[6]) << 16 |\n                ((uint32_t)buf[5]) << 24;\n        if (msgSize > 64 - 9) {\n            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed tiny packet\");\n            return;\n        }\n        const MessagesMap_t *entry = message_map_entry(NORMAL_MSG, msgId, IN_MSG);\n        if (!entry) {\n            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Unknown message\");\n            return;\n        }\n        tiny_dispatch(entry, buf + 9, msgSize);\n    } else {\n        usb_rx_helper(msg, len, NORMAL_MSG);\n    }\n}", "target": 1}
{"code": "gplotMakeOutput(GPLOT  *gplot)\n{\nchar     buf[L_BUF_SIZE];\nchar    *cmdname;\nl_int32  ignore;\n    PROCNAME(\"gplotMakeOutput\");\n    if (!gplot)\n        return ERROR_INT(\"gplot not defined\", procName, 1);\n    gplotGenCommandFile(gplot);\n    gplotGenDataFiles(gplot);\n    cmdname = genPathname(gplot->cmdname, NULL);\n#ifndef _WIN32\n    snprintf(buf, L_BUF_SIZE, \"gnuplot %s\", cmdname);\n#else\n    snprintf(buf, L_BUF_SIZE, \"wgnuplot %s\", cmdname);\n#endif  \n#ifndef OS_IOS \n    ignore = system(buf);  \n#endif \n    LEPT_FREE(cmdname);\n    return 0;\n}", "target": 1}
{"code": "lys_getnext_data(const struct lys_module *mod, const struct lys_node *parent, const char *name, int nam_len,\n                 LYS_NODE type, const struct lys_node **ret)\n{\n    const struct lys_node *node;\n    assert((mod || parent) && name);\n    assert(!(type & (LYS_AUGMENT | LYS_USES | LYS_GROUPING | LYS_CHOICE | LYS_CASE | LYS_INPUT | LYS_OUTPUT)));\n    if (!mod) {\n        mod = lys_node_module(parent);\n    }\n    node = NULL;\n    while ((node = lys_getnext(node, parent, mod, 0))) {\n        if (!type || (node->nodetype & type)) {\n            if (lys_node_module(node) != lys_main_module(mod)) {\n                continue;\n            }\n            if (!strncmp(node->name, name, nam_len) && !node->name[nam_len]) {\n                if (ret) {\n                    *ret = node;\n                }\n                return EXIT_SUCCESS;\n            }\n        }\n    }\n    return EXIT_FAILURE;\n}", "target": 1}
{"code": "GF_Err infe_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tchar *buf;\n\tu32 buf_len, i, string_len, string_start;\n\tGF_ItemInfoEntryBox *ptr = (GF_ItemInfoEntryBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->item_ID = gf_bs_read_u16(bs);\n\tptr->item_protection_index = gf_bs_read_u16(bs);\n\tif (ptr->version == 2) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->item_type = gf_bs_read_u32(bs);\n\t}\n\tbuf_len = (u32) (ptr->size);\n\tbuf = (char*)gf_malloc(buf_len);\n\tif (!buf) return GF_OUT_OF_MEM;\n\tif (buf_len != gf_bs_read_data(bs, buf, buf_len)) {\n\t\tgf_free(buf);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tstring_len = 1;\n\tstring_start = 0;\n\tfor (i = 0; i < buf_len; i++) {\n\t\tif (buf[i] == 0) {\n\t\t\tif (!ptr->item_name) {\n\t\t\t\tptr->item_name = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->item_name) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->item_name, buf+string_start, string_len);\n\t\t\t} else if (!ptr->content_type) {\n\t\t\t\tptr->content_type = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->content_type) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->content_type, buf+string_start, string_len);\n\t\t\t} else {\n\t\t\t\tptr->content_encoding = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->content_encoding) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->content_encoding, buf+string_start, string_len);\n\t\t\t}\n\t\t\tstring_start += string_len;\n\t\t\tstring_len = 0;\n\t\t\tif (ptr->content_encoding && ptr->version == 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tstring_len++;\n\t}\n\tgf_free(buf);\n\tif (!ptr->item_name || (!ptr->content_type && ptr->version < 2)) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isoff] Infe without name or content type !\\n\"));\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "static void ip_expire(unsigned long arg)\n{\n\tstruct ipq *qp;\n\tstruct net *net;\n\tqp = container_of((struct inet_frag_queue *) arg, struct ipq, q);\n\tnet = container_of(qp->q.net, struct net, ipv4.frags);\n\tspin_lock(&qp->q.lock);\n\tif (qp->q.last_in & INET_FRAG_COMPLETE)\n\t\tgoto out;\n\tipq_kill(qp);\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_REASMTIMEOUT);\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_REASMFAILS);\n\tif ((qp->q.last_in & INET_FRAG_FIRST_IN) && qp->q.fragments != NULL) {\n\t\tstruct sk_buff *head = qp->q.fragments;\n\t\trcu_read_lock();\n\t\thead->dev = dev_get_by_index_rcu(net, qp->iif);\n\t\tif (!head->dev)\n\t\t\tgoto out_rcu_unlock;\n\t\tif (qp->user == IP_DEFRAG_CONNTRACK_IN && !skb_dst(head)) {\n\t\t\tconst struct iphdr *iph = ip_hdr(head);\n\t\t\tint err = ip_route_input(head, iph->daddr, iph->saddr,\n\t\t\t\t\t\t iph->tos, head->dev);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto out_rcu_unlock;\n\t\t\tif (skb_rtable(head)->rt_type != RTN_LOCAL)\n\t\t\t\tgoto out_rcu_unlock;\n\t\t}\n\t\ticmp_send(head, ICMP_TIME_EXCEEDED, ICMP_EXC_FRAGTIME, 0);\nout_rcu_unlock:\n\t\trcu_read_unlock();\n\t}\nout:\n\tspin_unlock(&qp->q.lock);\n\tipq_put(qp);\n}", "target": 1}
{"code": "mptctl_replace_fw (unsigned long arg)\n{\n\tstruct mpt_ioctl_replace_fw __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_replace_fw\t karg;\n\tMPT_ADAPTER\t\t *ioc;\n\tint\t\t\t iocnum;\n\tint\t\t\t newFwSize;\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_replace_fw))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_replace_fw - \"\n\t\t\t\"Unable to read in mpt_ioctl_replace_fw struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_replace_fw() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_replace_fw called.\\n\",\n\t    ioc->name));\n\tif (ioc->cached_fw == NULL)\n\t\treturn 0;\n\tmpt_free_fw_memory(ioc);\n\tnewFwSize = ALIGN(karg.newImageSize, 4);\n\tmpt_alloc_fw_memory(ioc, newFwSize);\n\tif (ioc->cached_fw == NULL)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(ioc->cached_fw, uarg->newImage, newFwSize)) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_replace_fw - \"\n\t\t\t\t\"Unable to read in mpt_ioctl_replace_fw image \"\n\t\t\t\t\"@ %p\\n\", ioc->name, __FILE__, __LINE__, uarg);\n\t\tmpt_free_fw_memory(ioc);\n\t\treturn -EFAULT;\n\t}\n\tioc->facts.FWImageSize = newFwSize;\n\treturn 0;\n}", "target": 1}
{"code": "    bool fetch(const string & url, const string & expectedETag = \"\")\n    {\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        data.clear();\n        if (requestHeaders) {\n            curl_slist_free_all(requestHeaders);\n            requestHeaders = 0;\n        }\n        if (!expectedETag.empty()) {\n            this->expectedETag = expectedETag;\n            requestHeaders = curl_slist_append(requestHeaders, (\"If-None-Match: \" + expectedETag).c_str());\n        }\n        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, requestHeaders);\n        if (showProgress) {\n            std::cerr << (format(\"downloading %1%... \") % url);\n            std::cerr.flush();\n            startTime = getTime();\n        }\n        CURLcode res = curl_easy_perform(curl);\n        if (showProgress)\n            std::cerr << \"\\n\";\n        checkInterrupt();\n        if (res == CURLE_WRITE_ERROR && etag == expectedETag) return false;\n        if (res != CURLE_OK)\n            throw DownloadError(format(\"unable to download %1%: %2% (%3%)\")\n                % url % curl_easy_strerror(res) % res);\n        long httpStatus = 0;\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &httpStatus);\n        if (httpStatus == 304) return false;\n        return true;\n    }", "target": 1}
{"code": "static void error_handler(int err, void *arg)\n{\n\terror(\"Engine just broken: %m.\\n\", err);\n}", "target": 0}
{"code": "void free_sched_domains(cpumask_var_t doms[], unsigned int ndoms)\n{\n\tunsigned int i;\n\tfor (i = 0; i < ndoms; i++)\n\t\tfree_cpumask_var(doms[i]);\n\tkfree(doms);\n}", "target": 0}
{"code": "static int kvm_create_dirty_bitmap(struct kvm_memory_slot *memslot)\n{\n\tunsigned long dirty_bytes = 2 * kvm_dirty_bitmap_bytes(memslot);\n\tmemslot->dirty_bitmap = kvm_kvzalloc(dirty_bytes);\n\tif (!memslot->dirty_bitmap)\n\t\treturn -ENOMEM;\n\treturn 0;\n}", "target": 0}
{"code": "_mibindex_add( const char *dirname, int i )\n{\n    const int old_mibindex_max = _mibindex_max;\n    DEBUGMSGTL((\"mibindex\", \"add: %s (%d)\\n\", dirname, i ));\n    if ( i == -1 )\n        i = _mibindex++;\n    if ( i >= _mibindex_max ) {\n        _mibindex_max = i + 10;\n        _mibindexes = realloc(_mibindexes,\n                              _mibindex_max * sizeof(_mibindexes[0]));\n        netsnmp_assert(_mibindexes);\n        memset(_mibindexes + old_mibindex_max, 0,\n               (_mibindex_max - old_mibindex_max) * sizeof(_mibindexes[0]));\n    }\n    _mibindexes[ i ] = strdup( dirname );\n    if ( i >= _mibindex )\n        _mibindex = i+1;\n    DEBUGMSGTL((\"mibindex\", \"add: %d/%d/%d\\n\", i, _mibindex, _mibindex_max ));\n    return i;\n}", "target": 1}
{"code": "newkeys_to_blob(struct sshbuf *m, struct ssh *ssh, int mode)\n{\n\tstruct sshbuf *b;\n\tstruct sshcipher_ctx *cc;\n\tstruct sshcomp *comp;\n\tstruct sshenc *enc;\n\tstruct sshmac *mac;\n\tstruct newkeys *newkey;\n\tint r;\n\tif ((newkey = ssh->state->newkeys[mode]) == NULL)\n\t\treturn SSH_ERR_INTERNAL_ERROR;\n\tenc = &newkey->enc;\n\tmac = &newkey->mac;\n\tcomp = &newkey->comp;\n\tcc = (mode == MODE_OUT) ? ssh->state->send_context :\n\t    ssh->state->receive_context;\n\tif ((r = cipher_get_keyiv(cc, enc->iv, enc->iv_len)) != 0)\n\t\treturn r;\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif ((r = sshbuf_put_cstring(b, enc->name)) != 0 ||\n\t    (r = sshbuf_put(b, &enc->cipher, sizeof(enc->cipher))) != 0 ||\n\t    (r = sshbuf_put_u32(b, enc->enabled)) != 0 ||\n\t    (r = sshbuf_put_u32(b, enc->block_size)) != 0 ||\n\t    (r = sshbuf_put_string(b, enc->key, enc->key_len)) != 0 ||\n\t    (r = sshbuf_put_string(b, enc->iv, enc->iv_len)) != 0)\n\t\tgoto out;\n\tif (cipher_authlen(enc->cipher) == 0) {\n\t\tif ((r = sshbuf_put_cstring(b, mac->name)) != 0 ||\n\t\t    (r = sshbuf_put_u32(b, mac->enabled)) != 0 ||\n\t\t    (r = sshbuf_put_string(b, mac->key, mac->key_len)) != 0)\n\t\t\tgoto out;\n\t}\n\tif ((r = sshbuf_put_u32(b, comp->type)) != 0 ||\n\t    (r = sshbuf_put_u32(b, comp->enabled)) != 0 ||\n\t    (r = sshbuf_put_cstring(b, comp->name)) != 0)\n\t\tgoto out;\n\tr = sshbuf_put_stringb(m, b);\n out:\n\tsshbuf_free(b);\n\treturn r;\n}", "target": 1}
{"code": "struct key *find_keyring_by_name(const char *name, bool skip_perm_check)\n{\n\tstruct key *keyring;\n\tint bucket;\n\tif (!name)\n\t\treturn ERR_PTR(-EINVAL);\n\tbucket = keyring_hash(name);\n\tread_lock(&keyring_name_lock);\n\tif (keyring_name_hash[bucket].next) {\n\t\tlist_for_each_entry(keyring,\n\t\t\t\t    &keyring_name_hash[bucket],\n\t\t\t\t    name_link\n\t\t\t\t    ) {\n\t\t\tif (!kuid_has_mapping(current_user_ns(), keyring->user->uid))\n\t\t\t\tcontinue;\n\t\t\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(keyring->description, name) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!skip_perm_check &&\n\t\t\t    key_permission(make_key_ref(keyring, 0),\n\t\t\t\t\t   KEY_NEED_SEARCH) < 0)\n\t\t\t\tcontinue;\n\t\t\tif (!refcount_inc_not_zero(&keyring->usage))\n\t\t\t\tcontinue;\n\t\t\tkeyring->last_used_at = current_kernel_time().tv_sec;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tkeyring = ERR_PTR(-ENOKEY);\nout:\n\tread_unlock(&keyring_name_lock);\n\treturn keyring;\n}", "target": 1}
{"code": "static inline void tcp_check_send_head(struct sock *sk, struct sk_buff *skb_unlinked)\n{\n\tif (sk->sk_send_head == skb_unlinked)\n\t\tsk->sk_send_head = NULL;\n\tif (tcp_sk(sk)->highest_sack == skb_unlinked)\n\t\ttcp_sk(sk)->highest_sack = NULL;\n}", "target": 0}
{"code": "bool DNP3_Base::ParseAppLayer(Endpoint* endp)\n\t{\n\tbool orig = (endp == &orig_state);\n\tbinpac::DNP3::DNP3_Flow* flow = orig ? interp->upflow() : interp->downflow();\n\tu_char* data = endp->buffer + PSEUDO_TRANSPORT_INDEX; \n\tint len = endp->pkt_length - 5;\n\tint is_first = (endp->tpflags & 0x40) >> 6; \n\tint is_last = (endp->tpflags & 0x80) >> 7; \n\tint transport = PSEUDO_TRANSPORT_LEN;\n\tint i = 0;\n\twhile ( len > 0 )\n\t\t{\n\t\tint n = min(len, 16);\n\t\tif ( ! CheckCRC(n, data, data + n, \"app_chunk\") )\n\t\t\treturn false;\n\t\tassert(data + n < endp->buffer + endp->buffer_len);\n\t\tflow->flow_buffer()->BufferData(data + transport, data + n);\n\t\ttransport = 0;\n\t\tdata += n + 2;\n\t\tlen -= n;\n\t\t}\n\tif ( is_first )\n\t\tendp->encountered_first_chunk = true;\n\tif ( ! is_first && ! endp->encountered_first_chunk )\n\t\t{\n\t\tanalyzer->Weird(\"dnp3_first_application_layer_chunk_missing\");\n\t\treturn false;\n\t\t}\n\tif ( is_last )\n\t\t{\n\t\tflow->flow_buffer()->FinishBuffer();\n\t\tflow->FlowEOF();\n\t\tClearEndpointState(orig);\n\t\t}\n\treturn true;\n\t}", "target": 1}
{"code": "static int list_devices(struct file *filp, struct dm_ioctl *param, size_t param_size)\n{\n\tunsigned int i;\n\tstruct hash_cell *hc;\n\tsize_t len, needed = 0;\n\tstruct gendisk *disk;\n\tstruct dm_name_list *orig_nl, *nl, *old_nl = NULL;\n\tuint32_t *event_nr;\n\tdown_write(&_hash_lock);\n\tfor (i = 0; i < NUM_BUCKETS; i++) {\n\t\tlist_for_each_entry (hc, _name_buckets + i, name_list) {\n\t\t\tneeded += align_val(offsetof(struct dm_name_list, name) + strlen(hc->name) + 1);\n\t\t\tneeded += align_val(sizeof(uint32_t));\n\t\t}\n\t}\n\tnl = orig_nl = get_result_buffer(param, param_size, &len);\n\tif (len < needed) {\n\t\tparam->flags |= DM_BUFFER_FULL_FLAG;\n\t\tgoto out;\n\t}\n\tparam->data_size = param->data_start + needed;\n\tnl->dev = 0;\t\n\tfor (i = 0; i < NUM_BUCKETS; i++) {\n\t\tlist_for_each_entry (hc, _name_buckets + i, name_list) {\n\t\t\tif (old_nl)\n\t\t\t\told_nl->next = (uint32_t) ((void *) nl -\n\t\t\t\t\t\t\t   (void *) old_nl);\n\t\t\tdisk = dm_disk(hc->md);\n\t\t\tnl->dev = huge_encode_dev(disk_devt(disk));\n\t\t\tnl->next = 0;\n\t\t\tstrcpy(nl->name, hc->name);\n\t\t\told_nl = nl;\n\t\t\tevent_nr = align_ptr(nl->name + strlen(hc->name) + 1);\n\t\t\t*event_nr = dm_get_event_nr(hc->md);\n\t\t\tnl = align_ptr(event_nr + 1);\n\t\t}\n\t}\n\tBUG_ON((char *)nl - (char *)orig_nl != needed);\n out:\n\tup_write(&_hash_lock);\n\treturn 0;\n}", "target": 1}
{"code": "pdf_t *pdf_new(const char *name)\n{\n    const char *n;\n    pdf_t      *pdf;\n    pdf = calloc(1, sizeof(pdf_t));\n    if (name)\n    {\n        if ((n = strrchr(name, '/')))\n          ++n;\n        else\n          n = name;\n        pdf->name = malloc(strlen(n) + 1);\n        strcpy(pdf->name, n);\n    }\n    else \n    {\n        pdf->name = malloc(strlen(\"Unknown\") + 1);\n        strcpy(pdf->name, \"Unknown\");\n    }\n    return pdf;\n}", "target": 1}
{"code": "static int ion_handle_put_nolock(struct ion_handle *handle)\n{\n\tint ret;\n\tret = kref_put(&handle->ref, ion_handle_destroy);\n\treturn ret;\n}", "target": 0}
{"code": "static void lwp_read_int64(FILE *fin, int64_t &d) {\n  fread(&d, sizeof(d), 1, fin);\n}", "target": 0}
{"code": "static int cqspi_setup_flash(struct cqspi_st *cqspi, struct device_node *np)\n{\n\tstruct platform_device *pdev = cqspi->pdev;\n\tstruct device *dev = &pdev->dev;\n\tstruct cqspi_flash_pdata *f_pdata;\n\tstruct spi_nor *nor;\n\tstruct mtd_info *mtd;\n\tunsigned int cs;\n\tint i, ret;\n\tfor_each_available_child_of_node(dev->of_node, np) {\n\t\tif (of_property_read_u32(np, \"reg\", &cs)) {\n\t\t\tdev_err(dev, \"Couldn't determine chip select.\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\tif (cs > CQSPI_MAX_CHIPSELECT) {\n\t\t\tdev_err(dev, \"Chip select %d out of range.\\n\", cs);\n\t\t\tgoto err;\n\t\t}\n\t\tf_pdata = &cqspi->f_pdata[cs];\n\t\tf_pdata->cqspi = cqspi;\n\t\tf_pdata->cs = cs;\n\t\tret = cqspi_of_get_flash_pdata(pdev, f_pdata, np);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tnor = &f_pdata->nor;\n\t\tmtd = &nor->mtd;\n\t\tmtd->priv = nor;\n\t\tnor->dev = dev;\n\t\tspi_nor_set_flash_node(nor, np);\n\t\tnor->priv = f_pdata;\n\t\tnor->read_reg = cqspi_read_reg;\n\t\tnor->write_reg = cqspi_write_reg;\n\t\tnor->read = cqspi_read;\n\t\tnor->write = cqspi_write;\n\t\tnor->erase = cqspi_erase;\n\t\tnor->prepare = cqspi_prep;\n\t\tnor->unprepare = cqspi_unprep;\n\t\tmtd->name = devm_kasprintf(dev, GFP_KERNEL, \"%s.%d\",\n\t\t\t\t\t   dev_name(dev), cs);\n\t\tif (!mtd->name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tret = spi_nor_scan(nor, NULL, SPI_NOR_QUAD);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = mtd_device_register(mtd, NULL, 0);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tf_pdata->registered = true;\n\t}\n\treturn 0;\nerr:\n\tfor (i = 0; i < CQSPI_MAX_CHIPSELECT; i++)\n\t\tif (cqspi->f_pdata[i].registered)\n\t\t\tmtd_device_unregister(&cqspi->f_pdata[i].nor.mtd);\n\treturn ret;\n}", "target": 1}
{"code": "pkinit_check_kdc_pkid(krb5_context context,\n                      pkinit_plg_crypto_context plg_cryptoctx,\n                      pkinit_req_crypto_context req_cryptoctx,\n                      pkinit_identity_crypto_context id_cryptoctx,\n                      unsigned char *pdid_buf,\n                      unsigned int pkid_len,\n                      int *valid_kdcPkId)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n    PKCS7_ISSUER_AND_SERIAL *is = NULL;\n    const unsigned char *p = pdid_buf;\n    int status = 1;\n    X509 *kdc_cert = sk_X509_value(id_cryptoctx->my_certs, id_cryptoctx->cert_index);\n    *valid_kdcPkId = 0;\n    pkiDebug(\"found kdcPkId in AS REQ\\n\");\n    is = d2i_PKCS7_ISSUER_AND_SERIAL(NULL, &p, (int)pkid_len);\n    if (is == NULL)\n        goto cleanup;\n    status = X509_NAME_cmp(X509_get_issuer_name(kdc_cert), is->issuer);\n    if (!status) {\n        status = ASN1_INTEGER_cmp(X509_get_serialNumber(kdc_cert), is->serial);\n        if (!status)\n            *valid_kdcPkId = 1;\n    }\n    retval = 0;\ncleanup:\n    X509_NAME_free(is->issuer);\n    ASN1_INTEGER_free(is->serial);\n    free(is);\n    return retval;\n}", "target": 1}
{"code": "static ssize_t module_gzip_decompress(struct load_info *info,\n\t\t\t\t      const void *buf, size_t size)\n{\n\tstruct z_stream_s s = { 0 };\n\tsize_t new_size = 0;\n\tsize_t gzip_hdr_len;\n\tssize_t retval;\n\tint rc;\n\tgzip_hdr_len = module_gzip_header_len(buf, size);\n\tif (!gzip_hdr_len) {\n\t\tpr_err(\"not a gzip compressed module\\n\");\n\t\treturn -EINVAL;\n\t}\n\ts.next_in = buf + gzip_hdr_len;\n\ts.avail_in = size - gzip_hdr_len;\n\ts.workspace = kmalloc(zlib_inflate_workspacesize(), GFP_KERNEL);\n\tif (!s.workspace)\n\t\treturn -ENOMEM;\n\trc = zlib_inflateInit2(&s, -MAX_WBITS);\n\tif (rc != Z_OK) {\n\t\tpr_err(\"failed to initialize decompressor: %d\\n\", rc);\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\tdo {\n\t\tstruct page *page = module_get_next_page(info);\n\t\tif (!page) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out_inflate_end;\n\t\t}\n\t\ts.next_out = kmap_local_page(page);\n\t\ts.avail_out = PAGE_SIZE;\n\t\trc = zlib_inflate(&s, 0);\n\t\tkunmap_local(s.next_out);\n\t\tnew_size += PAGE_SIZE - s.avail_out;\n\t} while (rc == Z_OK);\n\tif (rc != Z_STREAM_END) {\n\t\tpr_err(\"decompression failed with status %d\\n\", rc);\n\t\tretval = -EINVAL;\n\t\tgoto out_inflate_end;\n\t}\n\tretval = new_size;\nout_inflate_end:\n\tzlib_inflateEnd(&s);\nout:\n\tkfree(s.workspace);\n\treturn retval;\n}", "target": 1}
{"code": "process_open(u_int32_t id)\n{\n\tu_int32_t pflags;\n\tAttrib a;\n\tchar *name;\n\tint r, handle, fd, flags, mode, status = SSH2_FX_FAILURE;\n\tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(iqueue, &pflags)) != 0 || \n\t    (r = decode_attrib(iqueue, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tdebug3(\"request %u: open flags %d\", id, pflags);\n\tflags = flags_from_portable(pflags);\n\tmode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a.perm : 0666;\n\tlogit(\"open \\\"%s\\\" flags %s mode 0%o\",\n\t    name, string_from_portable(pflags), mode);\n\tif (readonly &&\n\t    ((flags & O_ACCMODE) == O_WRONLY ||\n\t    (flags & O_ACCMODE) == O_RDWR)) {\n\t\tverbose(\"Refusing open request in read-only mode\");\n\t\tstatus = SSH2_FX_PERMISSION_DENIED;\n\t} else {\n\t\tfd = open(name, flags, mode);\n\t\tif (fd < 0) {\n\t\t\tstatus = errno_to_portable(errno);\n\t\t} else {\n\t\t\thandle = handle_new(HANDLE_FILE, name, fd, flags, NULL);\n\t\t\tif (handle < 0) {\n\t\t\t\tclose(fd);\n\t\t\t} else {\n\t\t\t\tsend_handle(id, handle);\n\t\t\t\tstatus = SSH2_FX_OK;\n\t\t\t}\n\t\t}\n\t}\n\tif (status != SSH2_FX_OK)\n\t\tsend_status(id, status);\n\tfree(name);\n}", "target": 1}
{"code": "TypedValue HHVM_FUNCTION(array_uintersect,\n                         const Variant& array1,\n                         const Variant& array2,\n                         const Variant& data_compare_func,\n                         const Array& args ) {\n  Variant func = data_compare_func;\n  Array extra = args;\n  if (!extra.empty()) {\n    extra.prepend(func);\n    func = extra.pop();\n  }\n  diff_intersect_body(intersect, extra, false COMMA true COMMA NULL COMMA NULL\n                      COMMA cmp_func COMMA &func);\n}", "target": 0}
{"code": "struct key *request_key_and_link(struct key_type *type,\n\t\t\t\t const char *description,\n\t\t\t\t const void *callout_info,\n\t\t\t\t size_t callout_len,\n\t\t\t\t void *aux,\n\t\t\t\t struct key *dest_keyring,\n\t\t\t\t unsigned long flags)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= type->match,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t};\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tint ret;\n\tkenter(\"%s,%s,%p,%zu,%p,%p,%lx\",\n\t       ctx.index_key.type->name, ctx.index_key.description,\n\t       callout_info, callout_len, aux, dest_keyring, flags);\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0) {\n\t\t\tkey = ERR_PTR(ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\tkey_ref = search_process_keyrings(&ctx);\n\tif (!IS_ERR(key_ref)) {\n\t\tkey = key_ref_to_ptr(key_ref);\n\t\tif (dest_keyring) {\n\t\t\tconstruct_get_dest_keyring(&dest_keyring);\n\t\t\tret = key_link(dest_keyring, key);\n\t\t\tkey_put(dest_keyring);\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_put(key);\n\t\t\t\tkey = ERR_PTR(ret);\n\t\t\t\tgoto error_free;\n\t\t\t}\n\t\t}\n\t} else if (PTR_ERR(key_ref) != -EAGAIN) {\n\t\tkey = ERR_CAST(key_ref);\n\t} else  {\n\t\tkey = ERR_PTR(-ENOKEY);\n\t\tif (!callout_info)\n\t\t\tgoto error_free;\n\t\tkey = construct_key_and_link(&ctx, callout_info, callout_len,\n\t\t\t\t\t     aux, dest_keyring, flags);\n\t}\nerror_free:\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\nerror:\n\tkleave(\" = %p\", key);\n\treturn key;\n}", "target": 1}
{"code": "fs::path TranslatePath(const std::string& utf8_url_path) {\n#if (defined(_WIN32) || defined(_WIN64))\n  std::wstring url_path = Utf8To16(utf8_url_path);\n  std::vector<std::wstring> words;\n  boost::split(words, url_path, boost::is_any_of(L\"/\"),\n               boost::token_compress_on);\n#else\n  std::vector<std::string> words;\n  boost::split(words, utf8_url_path, boost::is_any_of(\"/\"),\n               boost::token_compress_on);\n#endif  \n  fs::path path;\n  for (auto& word : words) {\n#if (defined(_WIN32) || defined(_WIN64))\n    if (word == L\".\" || word == L\"..\") {\n#else\n    if (word == \".\" || word == \"..\") {\n#endif\n      continue;\n    }\n    fs::path p{ word };\n    if (!p.parent_path().empty()) {\n      continue;\n    }\n    path /= p;\n  }\n  return path;\n}\n}  ", "target": 0}
{"code": "void __init(RBuffer *buf, r_bin_ne_obj_t *bin) {\n\tbin->header_offset = r_buf_read_le16_at (buf, 0x3c);\n\tbin->ne_header = R_NEW0 (NE_image_header);\n\tif (!bin->ne_header) {\n\t\treturn;\n\t}\n\tbin->buf = buf;\n\tr_buf_read_at (buf, bin->header_offset, (ut8 *)bin->ne_header, sizeof (NE_image_header));\n\tbin->alignment = 1 << bin->ne_header->FileAlnSzShftCnt;\n\tif (!bin->alignment) {\n\t\tbin->alignment = 1 << 9;\n\t}\n\tbin->os = __get_target_os (bin);\n\tut16 offset = bin->ne_header->SegTableOffset + bin->header_offset;\n\tut16 size = bin->ne_header->SegCount * sizeof (NE_image_segment_entry);\n\tbin->segment_entries = calloc (1, size);\n\tif (!bin->segment_entries) {\n\t\treturn;\n\t}\n\tr_buf_read_at (buf, offset, (ut8 *)bin->segment_entries, size);\n\tbin->entry_table = calloc (1, bin->ne_header->EntryTableLength);\n\tr_buf_read_at (buf, (ut64)bin->header_offset + bin->ne_header->EntryTableOffset, bin->entry_table, bin->ne_header->EntryTableLength);\n\tbin->imports = r_bin_ne_get_imports (bin);\n\t__ne_get_resources (bin);\n}", "target": 1}
{"code": "static int pppol2tp_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len,\n\t\t\t    int flags)\n{\n\tint err;\n\tstruct sk_buff *skb;\n\tstruct sock *sk = sock->sk;\n\terr = -EIO;\n\tif (sk->sk_state & PPPOX_BOUND)\n\t\tgoto end;\n\tmsg->msg_namelen = 0;\n\terr = 0;\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\tgoto end;\n\tif (len > skb->len)\n\t\tlen = skb->len;\n\telse if (len < skb->len)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, len);\n\tif (likely(err == 0))\n\t\terr = len;\n\tkfree_skb(skb);\nend:\n\treturn err;\n}", "target": 1}
{"code": "setkey_principal3_2_svc(setkey3_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (!(CHANGEPW_SERVICE(rqstp)) &&\n        kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                           ACL_SETKEY, arg->princ, NULL)) {\n        ret.code = kadm5_setkey_principal_3((void *)handle, arg->princ,\n                                            arg->keepold,\n                                            arg->n_ks_tuple,\n                                            arg->ks_tuple,\n                                            arg->keyblocks, arg->n_keys);\n    } else {\n        log_unauth(\"kadm5_setkey_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_SETKEY;\n    }\n    if(ret.code != KADM5_AUTH_SETKEY) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_setkey_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "NavigatorServiceWorker* NavigatorServiceWorker::from(Document& document)\n{\n    if (!document.frame() || !document.frame()->domWindow())\n        return nullptr;\n    Navigator& navigator = *document.frame()->domWindow()->navigator();\n    return &from(navigator);\n}", "target": 0}
{"code": "req_remote_addr(agooReq r) {\n    if (NULL == r) {\n\trb_raise(rb_eArgError, \"Request is no longer valid.\");\n    }\n    return rb_str_new(r->remote, strlen(r->remote));\n}", "target": 0}
{"code": "static void calc_load_migrate(struct rq *rq)\n{\n\tlong delta = calc_load_fold_active(rq);\n\tif (delta)\n\t\tatomic_long_add(delta, &calc_load_tasks);\n}", "target": 0}
{"code": "int bt_sock_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,\n\t\t    int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tsize_t skblen;\n\tint err;\n\tBT_DBG(\"sock %p sk %p len %zu\", sock, sk, len);\n\tif (flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\tskb = skb_recv_datagram(sk, flags, &err);\n\tif (!skb) {\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\tskblen = skb->len;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_msg(skb, 0, msg, copied);\n\tif (err == 0) {\n\t\tsock_recv_cmsgs(msg, sk, skb);\n\t\tif (msg->msg_name && bt_sk(sk)->skb_msg_name)\n\t\t\tbt_sk(sk)->skb_msg_name(skb, msg->msg_name,\n\t\t\t\t\t\t&msg->msg_namelen);\n\t\tif (test_bit(BT_SK_PKT_STATUS, &bt_sk(sk)->flags)) {\n\t\t\tu8 pkt_status = hci_skb_pkt_status(skb);\n\t\t\tput_cmsg(msg, SOL_BLUETOOTH, BT_SCM_PKT_STATUS,\n\t\t\t\t sizeof(pkt_status), &pkt_status);\n\t\t}\n\t}\n\tskb_free_datagram(sk, skb);\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skblen;\n\treturn err ? : copied;\n}", "target": 1}
{"code": "Value sendrawtransaction(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() < 1 || params.size() > 1)\n        throw runtime_error(\n            \"sendrawtransaction <hex string>\\n\"\n            \"Submits raw transaction (serialized, hex-encoded) to local node and network.\");\n    RPCTypeCheck(params, list_of(str_type));\n    vector<unsigned char> txData(ParseHex(params[0].get_str()));\n    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n    CTransaction tx;\n    try {\n        ssData >> tx;\n    }\n    catch (std::exception &e) {\n        throw JSONRPCError(-22, \"TX decode failed\");\n    }\n    uint256 hashTx = tx.GetHash();\n    CTransaction existingTx;\n    uint256 hashBlock = 0;\n    if (GetTransaction(hashTx, existingTx, hashBlock))\n    {\n        if (hashBlock != 0)\n            throw JSONRPCError(-5, string(\"transaction already in block \")+hashBlock.GetHex());\n    }\n    else\n    {\n        CTxDB txdb(\"r\");\n        if (!tx.AcceptToMemoryPool(txdb))\n            throw JSONRPCError(-22, \"TX rejected\");\n        SyncWithWallets(tx, NULL, true);\n    }\n    RelayMessage(CInv(MSG_TX, hashTx), tx);\n    return hashTx.GetHex();\n}", "target": 1}
{"code": "nvkm_vmm_put_locked(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n{\n\tconst struct nvkm_vmm_page *page = vmm->func->page;\n\tstruct nvkm_vma *next = vma;\n\tBUG_ON(vma->part);\n\tif (vma->mapref || !vma->sparse) {\n\t\tdo {\n\t\t\tconst bool map = next->memory != NULL;\n\t\t\tconst u8  refd = next->refd;\n\t\t\tconst u64 addr = next->addr;\n\t\t\tu64 size = next->size;\n\t\t\twhile ((next = node(next, next)) && next->part &&\n\t\t\t       (next->memory != NULL) == map &&\n\t\t\t       (next->refd == refd))\n\t\t\t\tsize += next->size;\n\t\t\tif (map) {\n\t\t\t\tnvkm_vmm_ptes_unmap_put(vmm, &page[refd], addr,\n\t\t\t\t\t\t\tsize, vma->sparse);\n\t\t\t} else\n\t\t\tif (refd != NVKM_VMA_PAGE_NONE) {\n\t\t\t\tnvkm_vmm_ptes_put(vmm, &page[refd], addr, size);\n\t\t\t}\n\t\t} while (next && next->part);\n\t}\n\tnext = vma;\n\tdo {\n\t\tif (next->memory)\n\t\t\tnvkm_vmm_unmap_region(vmm, next);\n\t} while ((next = node(vma, next)) && next->part);\n\tif (vma->sparse && !vma->mapref) {\n\t\tnvkm_vmm_ptes_sparse_put(vmm, &page[vma->refd], vma->addr, vma->size);\n\t} else\n\tif (vma->sparse) {\n\t\tnvkm_vmm_ptes_sparse(vmm, vma->addr, vma->size, false);\n\t}\n\trb_erase(&vma->tree, &vmm->root);\n\tvma->page = NVKM_VMA_PAGE_NONE;\n\tvma->refd = NVKM_VMA_PAGE_NONE;\n\tvma->used = false;\n\tvma->user = false;\n\tnvkm_vmm_put_region(vmm, vma);\n}", "target": 1}
{"code": "is_apple_double (const char *name)\n{\nchar *basename;\n\tgboolean ret = FALSE;\n\tbasename = g_path_get_basename (name);\n\tif (basename == NULL) {\n\t\tg_debug (\"Filename '%s' doesn't have a basename?\", name);\n\t\treturn ret;\n\t}\n\tret = g_str_has_prefix (basename, APPLE_DOUBLE_PREFIX);\n\tg_free (basename);\n\treturn ret;\n}", "target": 0}
{"code": "Eina_Bool ewk_view_disable_render(const Evas_Object* ewkView)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    EINA_SAFETY_ON_NULL_RETURN_VAL(smartData->api->disable_render, false);\n    return smartData->api->disable_render(smartData);\n}", "target": 0}
{"code": "int64_t OpLevelCostEstimator::CalculateOutputSize(const OpInfo& op_info,\n                                                  bool* found_unknown_shapes) {\n  int64_t total_output_size = 0;\n  for (const auto& output : op_info.outputs()) {\n    DataType dt = output.dtype();\n    const auto& original_output_shape = output.shape();\n    int64_t output_size = DataTypeSize(BaseType(dt));\n    int num_dims = std::max(1, original_output_shape.dim_size());\n    auto output_shape = MaybeGetMinimumShape(original_output_shape, num_dims,\n                                             found_unknown_shapes);\n    for (const auto& dim : output_shape.dim()) {\n      output_size *= dim.size();\n    }\n    total_output_size += output_size;\n    VLOG(1) << \"Output Size: \" << output_size\n            << \" Total Output Size:\" << total_output_size;\n  }\n  return total_output_size;\n}", "target": 1}
{"code": "_dbus_get_monotonic_time (long *tv_sec,\n                          long *tv_usec)\n{\n#ifdef HAVE_MONOTONIC_CLOCK\n  struct timespec ts;\n  clock_gettime (CLOCK_MONOTONIC, &ts);\n  if (tv_sec)\n    *tv_sec = ts.tv_sec;\n  if (tv_usec)\n    *tv_usec = ts.tv_nsec / 1000;\n#else\n  struct timeval t;\n  gettimeofday (&t, NULL);\n  if (tv_sec)\n    *tv_sec = t.tv_sec;\n  if (tv_usec)\n    *tv_usec = t.tv_usec;\n#endif\n}", "target": 0}
{"code": "static int cypress_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct cypress_private *priv = usb_get_serial_port_data(port);\n\tstruct usb_serial *serial = port->serial;\n\tunsigned long flags;\n\tint result = 0;\n\tif (!priv->comm_is_ok)\n\t\treturn -EIO;\n\tusb_clear_halt(serial->dev, 0x81);\n\tusb_clear_halt(serial->dev, 0x02);\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpriv->bytes_in = 0;\n\tpriv->bytes_out = 0;\n\tpriv->cmd_count = 0;\n\tpriv->rx_flags = 0;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\tcypress_send(port);\n\tif (tty)\n\t\tcypress_set_termios(tty, port, &priv->tmp_termios);\n\tif (!port->interrupt_in_urb) {\n\t\tdev_err(&port->dev, \"%s - interrupt_in_urb is empty!\\n\",\n\t\t\t__func__);\n\t\treturn -1;\n\t}\n\tusb_fill_int_urb(port->interrupt_in_urb, serial->dev,\n\t\tusb_rcvintpipe(serial->dev, port->interrupt_in_endpointAddress),\n\t\tport->interrupt_in_urb->transfer_buffer,\n\t\tport->interrupt_in_urb->transfer_buffer_length,\n\t\tcypress_read_int_callback, port, priv->read_urb_interval);\n\tresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\n\tif (result) {\n\t\tdev_err(&port->dev,\n\t\t\t\"%s - failed submitting read urb, error %d\\n\",\n\t\t\t\t\t\t\t__func__, result);\n\t\tcypress_set_dead(port);\n\t}\n\treturn result;\n} ", "target": 1}
{"code": "void HTPStateFree(void *state)\n{\n    SCEnter();\n    HtpState *s = (HtpState *)state;\n    if (s == NULL) {\n        SCReturn;\n    }\n    if (s->connp != NULL) {\n        SCLogDebug(\"freeing HTP state\");\n        uint64_t tx_id;\n        uint64_t total_txs = HTPStateGetTxCnt(state);\n        if (s->conn != NULL) {\n            for (tx_id = 0; tx_id < total_txs; tx_id++) {\n                htp_tx_t *tx = HTPStateGetTx(s, tx_id);\n                if (tx != NULL) {\n                    HtpTxUserData *htud = (HtpTxUserData *) htp_tx_get_user_data(tx);\n                    HtpTxUserDataFree(s, htud);\n                    htp_tx_set_user_data(tx, NULL);\n                }\n            }\n        }\n        htp_connp_destroy_all(s->connp);\n    }\n    HTPFree(s, sizeof(HtpState));\n#ifdef DEBUG\n    SCMutexLock(&htp_state_mem_lock);\n    htp_state_memcnt--;\n    htp_state_memuse -= sizeof(HtpState);\n    SCLogDebug(\"htp memory %\"PRIu64\" (%\"PRIu64\")\", htp_state_memuse, htp_state_memcnt);\n    SCMutexUnlock(&htp_state_mem_lock);\n#endif\n    SCReturn;\n}", "target": 1}
{"code": "int user_match(const struct key *key, const struct key_match_data *match_data)\n{\n\treturn strcmp(key->description, match_data->raw_data) == 0;\n}", "target": 1}
{"code": "static int cg_opendir(const char *path, struct fuse_file_info *fi)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tconst char *cgroup;\n\tstruct file_info *dir_info;\n\tchar *controller = NULL;\n\tif (!fc)\n\t\treturn -EIO;\n\tif (strcmp(path, \"/cgroup\") == 0) {\n\t\tcgroup = NULL;\n\t\tcontroller = NULL;\n\t} else {\n\t\tcontroller = pick_controller_from_path(fc, path);\n\t\tif (!controller)\n\t\t\treturn -EIO;\n\t\tcgroup = find_cgroup_in_path(path);\n\t\tif (!cgroup) {\n\t\t\tcgroup = \"/\";\n\t\t}\n\t}\n\tif (cgroup && !fc_may_access(fc, controller, cgroup, NULL, O_RDONLY)) {\n\t\treturn -EACCES;\n\t}\n\tdir_info = malloc(sizeof(*dir_info));\n\tif (!dir_info)\n\t\treturn -ENOMEM;\n\tdir_info->controller = must_copy_string(controller);\n\tdir_info->cgroup = must_copy_string(cgroup);\n\tdir_info->type = LXC_TYPE_CGDIR;\n\tdir_info->buf = NULL;\n\tdir_info->file = NULL;\n\tdir_info->buflen = 0;\n\tfi->fh = (unsigned long)dir_info;\n\treturn 0;\n}", "target": 1}
{"code": "static int ras_putdata(jas_stream_t *out, ras_hdr_t *hdr, jas_image_t *image, int numcmpts, int *cmpts)\n{\n\tint ret;\n\tswitch (hdr->type) {\n\tcase RAS_TYPE_STD:\n\t\tret = ras_putdatastd(out, hdr, image, numcmpts, cmpts);\n\t\tbreak;\n\tdefault:\n\t\tret = -1;\n\t\tbreak;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "spnego_gss_inquire_saslname_for_mech(OM_uint32 *minor_status,\n                                     const gss_OID desired_mech,\n                                     gss_buffer_t sasl_mech_name,\n                                     gss_buffer_t mech_name,\n                                     gss_buffer_t mech_description)\n{\n\t*minor_status = 0;\n\tif (!g_OID_equal(desired_mech, gss_mech_spnego))\n\t\treturn (GSS_S_BAD_MECH);\n\tif (!g_make_string_buffer(SPNEGO_SASL_NAME, sasl_mech_name) ||\n\t    !g_make_string_buffer(\"spnego\", mech_name) ||\n\t    !g_make_string_buffer(\"Simple and Protected GSS-API \"\n\t\t\t\t  \"Negotiation Mechanism\", mech_description))\n\t\tgoto fail;\n\treturn (GSS_S_COMPLETE);\nfail:\n\t*minor_status = ENOMEM;\n\treturn (GSS_S_FAILURE);\n}", "target": 0}
{"code": "static int fastrpc_dma_buf_attach(struct dma_buf *dmabuf,\n\t\t\t\t  struct dma_buf_attachment *attachment)\n{\n\tstruct fastrpc_dma_buf_attachment *a;\n\tstruct fastrpc_buf *buffer = dmabuf->priv;\n\tint ret;\n\ta = kzalloc(sizeof(*a), GFP_KERNEL);\n\tif (!a)\n\t\treturn -ENOMEM;\n\tret = dma_get_sgtable(buffer->dev, &a->sgt, buffer->virt,\n\t\t\t      FASTRPC_PHYS(buffer->phys), buffer->size);\n\tif (ret < 0) {\n\t\tdev_err(buffer->dev, \"failed to get scatterlist from DMA API\\n\");\n\t\tkfree(a);\n\t\treturn -EINVAL;\n\t}\n\ta->dev = attachment->dev;\n\tINIT_LIST_HEAD(&a->node);\n\tattachment->priv = a;\n\tmutex_lock(&buffer->lock);\n\tlist_add(&a->node, &buffer->attachments);\n\tmutex_unlock(&buffer->lock);\n\treturn 0;\n}", "target": 0}
{"code": "inline static jas_int_asl(int x, int n)\n{\n\tassert(n >= 0);\n\treturn x << n;\n}", "target": 0}
{"code": "TEST_CASE(\"Start rule with ignore operator test\", \"[general]\")\n{\n    parser parser(R\"(\n        ~ROOT <- _\n        _ <- ' '\n    )\");\n    bool ret = parser;\n    REQUIRE(ret == false);\n}", "target": 0}
{"code": "static int sgi_clock_get(clockid_t clockid, struct timespec *tp)\n{\n\tu64 nsec;\n\tnsec = rtc_time() * sgi_clock_period\n\t\t\t+ sgi_clock_offset.tv_nsec;\n\ttp->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &tp->tv_nsec)\n\t\t\t+ sgi_clock_offset.tv_sec;\n\treturn 0;\n};", "target": 1}
{"code": "GF_Err xtra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_XtraBox *ptr = (GF_XtraBox *)s;\n\twhile (ptr->size) {\n\t\tGF_XtraTag *tag;\n\t\tu32 prop_type = 0;\n\t\tchar *data=NULL, *data2=NULL;\n\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, 8)\n\t\ts32 tag_size = gf_bs_read_u32(bs);\n\t\tu32 name_size = gf_bs_read_u32(bs);\n\t\tif (tag_size < 8) return GF_ISOM_INVALID_FILE;\n\t\ttag_size -= 8;\n\t\tif ((tag_size>ptr->size) || (name_size>ptr->size)) {\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, 10)\n\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, name_size)\n\t\tdata = gf_malloc(sizeof(char) * (name_size+1));\n\t\tgf_bs_read_data(bs, data, name_size);\n\t\tdata[name_size] = 0;\n\t\ttag_size-=name_size;\n\t\tu32 flags = gf_bs_read_u32(bs);\n\t\tu32 prop_size = gf_bs_read_u32(bs);\n\t\ttag_size-=8;\n\t\tif (prop_size>4) {\n\t\t\ttag_size-=2;\n\t\t\tprop_type = gf_bs_read_u16(bs);\n\t\t\tprop_size -= 6;\n\t\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, prop_size)\n\t\t\tdata2 = gf_malloc(sizeof(char) * (prop_size+2));\n\t\t\tgf_bs_read_data(bs, data2, prop_size);\n\t\t\tdata2[prop_size] = 0;\n\t\t\tdata2[prop_size+1] = 0;\n\t\t\ttag_size-=prop_size;\n\t\t} else {\n\t\t\tprop_size = 0;\n\t\t}\n\t\tGF_SAFEALLOC(tag, GF_XtraTag)\n\t\ttag->flags = flags;\n\t\ttag->name = data;\n\t\ttag->prop_size = prop_size;\n\t\ttag->prop_value = data2;\n\t\ttag->prop_type = prop_type;\n\t\tgf_list_add(ptr->tags, tag);\n\t\tif (tag_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isom] invalid tag size in Xtra !\\n\"));\n\t\t}\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "RenderObject::SelectionState InlineFlowBox::selectionState()\n{\n    return RenderObject::SelectionNone;\n}", "target": 0}
{"code": "intrusive_ptr<DocumentSource> DocumentSourceGroup::optimize() {\n    for (size_t i = 0; i < _idExpressions.size(); i++) {\n        _idExpressions[i] = _idExpressions[i]->optimize();\n    }\n    for (auto&& accumulatedField : _accumulatedFields) {\n        accumulatedField.expr.initializer = accumulatedField.expr.initializer->optimize();\n        accumulatedField.expr.argument = accumulatedField.expr.argument->optimize();\n    }\n    return this;\n}", "target": 0}
{"code": "void UnbufferedAsioTlsStream::BeforeHandshake(handshake_type type)\n{\n\tnamespace ssl = boost::asio::ssl;\n\tif (!m_Hostname.IsEmpty()) {\n\t\tX509_VERIFY_PARAM_set1_host(SSL_get0_param(native_handle()), m_Hostname.CStr(), m_Hostname.GetLength());\n\t}\n\tset_verify_mode(ssl::verify_peer | ssl::verify_client_once);\n\tset_verify_callback([this](bool preverified, ssl::verify_context& ctx) {\n\t\tif (!preverified) {\n\t\t\tm_VerifyOK = false;\n\t\t\tstd::ostringstream msgbuf;\n\t\t\tint err = X509_STORE_CTX_get_error(ctx.native_handle());\n\t\t\tmsgbuf << \"code \" << err << \": \" << X509_verify_cert_error_string(err);\n\t\t\tm_VerifyError = msgbuf.str();\n\t\t}\n\t\treturn true;\n\t});\n#ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME\n\tif (type == client && !m_Hostname.IsEmpty()) {\n\t\tString environmentName = Application::GetAppEnvironment();\n\t\tString serverName = m_Hostname;\n\t\tif (!environmentName.IsEmpty())\n\t\t\tserverName += \":\" + environmentName;\n\t\tSSL_set_tlsext_host_name(native_handle(), serverName.CStr());\n\t}\n#endif \n}", "target": 1}
{"code": "  explicit FractionalMaxPoolOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"pooling_ratio\", &pooling_ratio_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"pseudo_random\", &pseudo_random_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"overlapping\", &overlapping_));\n    OP_REQUIRES(context, pooling_ratio_.size() == 4,\n                errors::InvalidArgument(\"pooling_ratio field must \"\n                                        \"specify 4 dimensions\"));\n    for (std::size_t i = 0; i < pooling_ratio_.size(); ++i) {\n      OP_REQUIRES(context, pooling_ratio_[i] >= 1,\n                  errors::InvalidArgument(\n                      \"pooling_ratio cannot be smaller than 1, got: \",\n                      pooling_ratio_[i]));\n    }\n    OP_REQUIRES(\n        context, pooling_ratio_[0] == 1 || pooling_ratio_[3] == 1,\n        errors::Unimplemented(\"Fractional max pooling is not yet \"\n                              \"supported on the batch nor channel dimension.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"deterministic\", &deterministic_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed\", &seed_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed2\", &seed2_));\n    if (deterministic_) {\n      if ((seed_ == 0) && (seed2_ == 0)) {\n        seed_ = random::New64();\n        seed2_ = random::New64();\n      }\n    } else {\n      OP_REQUIRES(\n          context, (seed_ == 0) && (seed2_ == 0),\n          errors::InvalidArgument(\n              \"Both seed and seed2 should be 0 if deterministic is false.\"));\n    }\n  }", "target": 0}
{"code": "static int fallocate_chunk(struct inode *inode, loff_t offset, loff_t len,\n\t\t\t   int mode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct buffer_head *dibh;\n\tint error;\n\tu64 start = offset >> PAGE_CACHE_SHIFT;\n\tunsigned int start_offset = offset & ~PAGE_CACHE_MASK;\n\tu64 end = (offset + len - 1) >> PAGE_CACHE_SHIFT;\n\tpgoff_t curr;\n\tstruct page *page;\n\tunsigned int end_offset = (offset + len) & ~PAGE_CACHE_MASK;\n\tunsigned int from, to;\n\tif (!end_offset)\n\t\tend_offset = PAGE_CACHE_SIZE;\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (unlikely(error))\n\t\tgoto out;\n\tgfs2_trans_add_bh(ip->i_gl, dibh, 1);\n\tif (gfs2_is_stuffed(ip)) {\n\t\terror = gfs2_unstuff_dinode(ip, NULL);\n\t\tif (unlikely(error))\n\t\t\tgoto out;\n\t}\n\tcurr = start;\n\toffset = start << PAGE_CACHE_SHIFT;\n\tfrom = start_offset;\n\tto = PAGE_CACHE_SIZE;\n\twhile (curr <= end) {\n\t\tpage = grab_cache_page_write_begin(inode->i_mapping, curr,\n\t\t\t\t\t\t   AOP_FLAG_NOFS);\n\t\tif (unlikely(!page)) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tif (curr == end)\n\t\t\tto = end_offset;\n\t\terror = write_empty_blocks(page, from, to, mode);\n\t\tif (!error && offset + to > inode->i_size &&\n\t\t    !(mode & FALLOC_FL_KEEP_SIZE)) {\n\t\t\ti_size_write(inode, offset + to);\n\t\t}\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tcurr++;\n\t\toffset += PAGE_CACHE_SIZE;\n\t\tfrom = 0;\n\t}\n\tmark_inode_dirty(inode);\n\tbrelse(dibh);\nout:\n\treturn error;\n}", "target": 1}
{"code": "mptctl_eventreport (unsigned long arg)\n{\n\tstruct mpt_ioctl_eventreport __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_eventreport\t karg;\n\tMPT_ADAPTER\t\t *ioc;\n\tint\t\t\t iocnum;\n\tint\t\t\t numBytes, maxEvents, max;\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventreport))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_eventreport - \"\n\t\t\t\"Unable to read in mpt_ioctl_eventreport struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_eventreport() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_eventreport called.\\n\",\n\t    ioc->name));\n\tnumBytes = karg.hdr.maxDataSize - sizeof(mpt_ioctl_header);\n\tmaxEvents = numBytes/sizeof(MPT_IOCTL_EVENTS);\n\tmax = MPTCTL_EVENT_LOG_SIZE < maxEvents ? MPTCTL_EVENT_LOG_SIZE : maxEvents;\n\tif ((max < 1) || !ioc->events)\n\t\treturn -ENODATA;\n\tioc->aen_event_read_flag=0;\n\tnumBytes = max * sizeof(MPT_IOCTL_EVENTS);\n\tif (copy_to_user(uarg->eventData, ioc->events, numBytes)) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_eventreport - \"\n\t\t\t\"Unable to write out mpt_ioctl_eventreport struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, ioc->events);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_read_next_attr_from_buffer(ut8 *buffer, st64 sz, st64 buf_offset) {\n\tRBinJavaAttrInfo *attr = NULL;\n\tchar *name = NULL;\n\tut64 offset = 0;\n\tut16 name_idx;\n\tst64 nsz;\n\tRBinJavaAttrMetas *type_info = NULL;\n\tif (!buffer || ((int) sz) < 4 || buf_offset < 0) {\n\t\teprintf (\"r_bin_Java_read_next_attr_from_buffer: invalid buffer size %d\\n\", (int) sz);\n\t\treturn NULL;\n\t}\n\tname_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tnsz = R_BIN_JAVA_UINT (buffer, offset);\n\toffset += 4;\n\tname = r_bin_java_get_utf8_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, name_idx);\n\tif (!name) {\n\t\tname = strdup (\"unknown\");\n\t}\n\tIFDBG eprintf(\"r_bin_java_read_next_attr: name_idx = %d is %s\\n\", name_idx, name);\n\ttype_info = r_bin_java_get_attr_type_by_name (name);\n\tif (type_info) {\n\t\tIFDBG eprintf(\"Typeinfo: %s, was %s\\n\", type_info->name, name);\n\t\tif (nsz > sz) {\n\t\t\tfree (name);\n\t\t\treturn NULL;\n\t\t}\n\t\tif ((attr = type_info->allocs->new_obj (buffer, nsz, buf_offset))) {\n\t\t\tattr->metas->ord = (R_BIN_JAVA_GLOBAL_BIN->attr_idx++);\n\t\t}\n\t} else {\n\t\teprintf (\"r_bin_java_read_next_attr_from_buffer: Cannot find type_info for %s\\n\", name);\n\t}\n\tfree (name);\n\treturn attr;\n}", "target": 1}
{"code": "key_ref_t keyring_search(key_ref_t keyring,\n\t\t\t struct key_type *type,\n\t\t\t const char *description)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= type->match,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tkey_ref_t key;\n\tint ret;\n\tif (!ctx.match_data.cmp)\n\t\treturn ERR_PTR(-ENOKEY);\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\tkey = keyring_search_aux(keyring, &ctx);\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\n\treturn key;\n}", "target": 1}
{"code": "static int __net_init sctp_ctrlsock_init(struct net *net)\n{\n\tint status;\n\tstatus = sctp_ctl_sock_init(net);\n\tif (status)\n\t\tpr_err(\"Failed to initialize the SCTP control sock\\n\");\n\treturn status;\n}", "target": 0}
{"code": "h2_end_headers(struct worker *wrk, struct h2_sess *h2,\n    struct req *req, struct h2_req *r2)\n{\n\th2_error h2e;\n\tconst char *b;\n\tASSERT_RXTHR(h2);\n\tassert(r2->state == H2_S_OPEN);\n\th2e = h2h_decode_fini(h2);\n\th2->new_req = NULL;\n\tif (r2->req->req_body_status == REQ_BODY_NONE) {\n\t\tr2->state = H2_S_CLOS_REM;\n\t}\n\tif (h2e != NULL) {\n\t\tLck_Lock(&h2->sess->mtx);\n\t\tVSLb(h2->vsl, SLT_Debug, \"HPACK/FINI %s\", h2e->name);\n\t\tLck_Unlock(&h2->sess->mtx);\n\t\tAZ(r2->req->ws->r);\n\t\th2_del_req(wrk, r2);\n\t\treturn (h2e);\n\t}\n\tVSLb_ts_req(req, \"Req\", req->t_req);\n\thttp_CollectHdrSep(req->http, H_Cookie, \"; \");\t\n\tif (req->req_body_status == REQ_BODY_INIT) {\n\t\tif (!http_GetHdr(req->http, H_Content_Length, &b))\n\t\t\treq->req_body_status = REQ_BODY_WITHOUT_LEN;\n\t\telse\n\t\t\treq->req_body_status = REQ_BODY_WITH_LEN;\n\t} else {\n\t\tassert (req->req_body_status == REQ_BODY_NONE);\n\t\tif (http_GetContentLength(req->http) > 0)\n\t\t\treturn (H2CE_PROTOCOL_ERROR); \n\t}\n\tif (req->http->hd[HTTP_HDR_METHOD].b == NULL) {\n\t\tVSLb(h2->vsl, SLT_Debug, \"Missing :method\");\n\t\treturn (H2SE_PROTOCOL_ERROR); \n\t}\n\tif (req->http->hd[HTTP_HDR_URL].b == NULL) {\n\t\tVSLb(h2->vsl, SLT_Debug, \"Missing :path\");\n\t\treturn (H2SE_PROTOCOL_ERROR); \n\t}\n\tAN(req->http->hd[HTTP_HDR_PROTO].b);\n\treq->req_step = R_STP_TRANSPORT;\n\treq->task.func = h2_do_req;\n\treq->task.priv = req;\n\tr2->scheduled = 1;\n\tif (Pool_Task(wrk->pool, &req->task, TASK_QUEUE_STR) != 0) {\n\t\tr2->scheduled = 0;\n\t\tr2->state = H2_S_CLOSED;\n\t\treturn (H2SE_REFUSED_STREAM); \n\t}\n\treturn (0);\n}", "target": 1}
{"code": "void DetectHttpRequestHeaderRegister(void)\n{\n    sigmatch_table[DETECT_HTTP_REQUEST_HEADER].name = \"http.request_header\";\n    sigmatch_table[DETECT_HTTP_REQUEST_HEADER].desc =\n            \"sticky buffer to match on only one HTTP header name and value\";\n    sigmatch_table[DETECT_HTTP_REQUEST_HEADER].url = \"/rules/http-keywords.html#request_header\";\n    sigmatch_table[DETECT_HTTP_REQUEST_HEADER].Setup = DetectHTTPRequestHeaderSetup;\n    sigmatch_table[DETECT_HTTP_REQUEST_HEADER].flags |=\n            SIGMATCH_NOOPT | SIGMATCH_INFO_STICKY_BUFFER;\n    DetectAppLayerMpmRegister2(\"http_request_header\", SIG_FLAG_TOSERVER, 2,\n            PrefilterMpmHttp2HeaderRegister, NULL, ALPROTO_HTTP2, HTTP2StateOpen);\n    DetectAppLayerInspectEngineRegister2(\"http_request_header\", ALPROTO_HTTP2, SIG_FLAG_TOSERVER,\n            HTTP2StateOpen, DetectEngineInspectHttp2Header, NULL);\n    DetectAppLayerMpmRegister2(\"http_request_header\", SIG_FLAG_TOSERVER, 2,\n            PrefilterMpmHttp1HeaderRegister, NULL, ALPROTO_HTTP1, 0);\n    DetectAppLayerInspectEngineRegister2(\"http_request_header\", ALPROTO_HTTP1, SIG_FLAG_TOSERVER,\n            HTP_REQUEST_HEADERS, DetectEngineInspectHttp1Header, NULL);\n    DetectBufferTypeSetDescriptionByName(\"http_request_header\", \"HTTP header name and value\");\n    g_http_request_header_buffer_id = DetectBufferTypeGetByName(\"http_request_header\");\n    DetectBufferTypeSupportsMultiInstance(\"http_request_header\");\n    g_request_header_thread_id = DetectRegisterThreadCtxGlobalFuncs(\"http_request_header\",\n            HttpMultiBufHeaderThreadDataInit, NULL, HttpMultiBufHeaderThreadDataFree);\n}", "target": 0}
{"code": "static void opl3_setup_voice(int dev, int voice, int chn)\n{\n\tstruct channel_info *info =\n\t&synth_devs[dev]->chn_info[chn];\n\topl3_set_instr(dev, voice, info->pgm_num);\n\tdevc->voc[voice].bender = 0;\n\tdevc->voc[voice].bender_range = info->bender_range;\n\tdevc->voc[voice].volume = info->controllers[CTL_MAIN_VOLUME];\n\tdevc->voc[voice].panning = (info->controllers[CTL_PAN] * 2) - 128;\n}", "target": 1}
{"code": "ut32 armass_assemble(const char *str, ut64 off, int thumb) {\n\tint i, j;\n\tchar buf[128];\n\tArmOpcode aop = {.off = off};\n\tfor (i = j = 0; i < sizeof (buf) - 1 && str[i]; i++, j++) {\n\t\tif (str[j] == '#') {\n\t\t\ti--; continue;\n\t\t}\n\t\tbuf[i] = tolower ((const ut8)str[j]);\n\t}\n\tbuf[i] = 0;\n\tarm_opcode_parse (&aop, buf);\n\taop.off = off;\n\tif (thumb < 0 || thumb > 1) {\n\t\treturn -1;\n\t}\n\tif (!assemble[thumb] (&aop, off, buf)) {\n\t\treturn -1;\n\t}\n\treturn aop.o;\n}", "target": 1}
{"code": "static int udf_load_sparable_map(struct super_block *sb,\n\t\t\t\t struct udf_part_map *map,\n\t\t\t\t struct sparablePartitionMap *spm)\n{\n\tuint32_t loc;\n\tuint16_t ident;\n\tstruct sparingTable *st;\n\tstruct udf_sparing_data *sdata = &map->s_type_specific.s_sparing;\n\tint i;\n\tstruct buffer_head *bh;\n\tmap->s_partition_type = UDF_SPARABLE_MAP15;\n\tsdata->s_packet_len = le16_to_cpu(spm->packetLength);\n\tif (!is_power_of_2(sdata->s_packet_len)) {\n\t\tudf_err(sb, \"error loading logical volume descriptor: \"\n\t\t\t\"Invalid packet length %u\\n\",\n\t\t\t(unsigned)sdata->s_packet_len);\n\t\treturn -EIO;\n\t}\n\tif (spm->numSparingTables > 4) {\n\t\tudf_err(sb, \"error loading logical volume descriptor: \"\n\t\t\t\"Too many sparing tables (%d)\\n\",\n\t\t\t(int)spm->numSparingTables);\n\t\treturn -EIO;\n\t}\n\tfor (i = 0; i < spm->numSparingTables; i++) {\n\t\tloc = le32_to_cpu(spm->locSparingTable[i]);\n\t\tbh = udf_read_tagged(sb, loc, loc, &ident);\n\t\tif (!bh)\n\t\t\tcontinue;\n\t\tst = (struct sparingTable *)bh->b_data;\n\t\tif (ident != 0 ||\n\t\t    strncmp(st->sparingIdent.ident, UDF_ID_SPARING,\n\t\t\t    strlen(UDF_ID_SPARING)) ||\n\t\t    sizeof(*st) + le16_to_cpu(st->reallocationTableLen) >\n\t\t\t\t\t\t\tsb->s_blocksize) {\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\t\t}\n\t\tsdata->s_spar_map[i] = bh;\n\t}\n\tmap->s_partition_func = udf_get_pblock_spar15;\n\treturn 0;\n}", "target": 0}
{"code": "void bpf_int_jit_compile(struct bpf_prog *prog)\n{\n\tstruct bpf_binary_header *header = NULL;\n\tint proglen, oldproglen = 0;\n\tstruct jit_context ctx = {};\n\tu8 *image = NULL;\n\tint *addrs;\n\tint pass;\n\tint i;\n\tif (!bpf_jit_enable)\n\t\treturn;\n\tif (!prog || !prog->len)\n\t\treturn;\n\taddrs = kmalloc(prog->len * sizeof(*addrs), GFP_KERNEL);\n\tif (!addrs)\n\t\treturn;\n\tfor (proglen = 0, i = 0; i < prog->len; i++) {\n\t\tproglen += 64;\n\t\taddrs[i] = proglen;\n\t}\n\tctx.cleanup_addr = proglen;\n\tfor (pass = 0; pass < 10; pass++) {\n\t\tproglen = do_jit(prog, addrs, image, oldproglen, &ctx);\n\t\tif (proglen <= 0) {\n\t\t\timage = NULL;\n\t\t\tif (header)\n\t\t\t\tbpf_jit_binary_free(header);\n\t\t\tgoto out;\n\t\t}\n\t\tif (image) {\n\t\t\tif (proglen != oldproglen) {\n\t\t\t\tpr_err(\"bpf_jit: proglen=%d != oldproglen=%d\\n\",\n\t\t\t\t       proglen, oldproglen);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (proglen == oldproglen) {\n\t\t\theader = bpf_jit_binary_alloc(proglen, &image,\n\t\t\t\t\t\t      1, jit_fill_hole);\n\t\t\tif (!header)\n\t\t\t\tgoto out;\n\t\t}\n\t\toldproglen = proglen;\n\t}\n\tif (bpf_jit_enable > 1)\n\t\tbpf_jit_dump(prog->len, proglen, 0, image);\n\tif (image) {\n\t\tbpf_flush_icache(header, image + proglen);\n\t\tset_memory_ro((unsigned long)header, header->pages);\n\t\tprog->bpf_func = (void *)image;\n\t\tprog->jited = true;\n\t}\nout:\n\tkfree(addrs);\n}", "target": 1}
{"code": "null_if_print(netdissect_options *ndo, const struct pcap_pkthdr *h, const u_char *p)\n{\n\tu_int length = h->len;\n\tu_int caplen = h->caplen;\n\tu_int family;\n\tif (caplen < NULL_HDRLEN) {\n\t\tND_PRINT((ndo, \"[|null]\"));\n\t\treturn (NULL_HDRLEN);\n\t}\n\tmemcpy((char *)&family, (const char *)p, sizeof(family));\n\tif ((family & 0xFFFF0000) != 0)\n\t\tfamily = SWAPLONG(family);\n\tif (ndo->ndo_eflag)\n\t\tnull_hdr_print(ndo, family, length);\n\tlength -= NULL_HDRLEN;\n\tcaplen -= NULL_HDRLEN;\n\tp += NULL_HDRLEN;\n\tswitch (family) {\n\tcase BSD_AFNUM_INET:\n\t\tip_print(ndo, p, length);\n\t\tbreak;\n\tcase BSD_AFNUM_INET6_BSD:\n\tcase BSD_AFNUM_INET6_FREEBSD:\n\tcase BSD_AFNUM_INET6_DARWIN:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\tcase BSD_AFNUM_ISO:\n\t\tisoclns_print(ndo, p, length, caplen);\n\t\tbreak;\n\tcase BSD_AFNUM_APPLETALK:\n\t\tatalk_print(ndo, p, length);\n\t\tbreak;\n\tcase BSD_AFNUM_IPX:\n\t\tipx_print(ndo, p, length);\n\t\tbreak;\n\tdefault:\n\t\tif (!ndo->ndo_eflag)\n\t\t\tnull_hdr_print(ndo, family, length + NULL_HDRLEN);\n\t\tif (!ndo->ndo_suppress_default_print)\n\t\t\tND_DEFAULTPRINT(p, caplen);\n\t}\n\treturn (NULL_HDRLEN);\n}", "target": 1}
{"code": "int avcodec_default_execute2(AVCodecContext *c, int (*func)(AVCodecContext *c2, void *arg2, int jobnr, int threadnr), void *arg, int *ret, int count)\n{\n    int i;\n    for (i = 0; i < count; i++) {\n        int r = func(c, arg, i, 0);\n        if (ret)\n            ret[i] = r;\n    }\n    return 0;\n}", "target": 0}
{"code": "QByteArray Cipher::blowfishECB(QByteArray cipherText, bool direction)\n{\n    QCA::Initializer init;\n    QByteArray temp = cipherText;\n    if (direction)\n    {\n        while ((temp.length() % 8) != 0) temp.append('\\0');\n    }\n    else\n    {\n        temp = b64ToByte(temp);\n        while ((temp.length() % 8) != 0) temp.append('\\0');\n    }\n    QCA::Direction dir = (direction) ? QCA::Encode : QCA::Decode;\n    QCA::Cipher cipher(m_type, QCA::Cipher::ECB, QCA::Cipher::NoPadding, dir, m_key);\n    QByteArray temp2 = cipher.update(QCA::MemoryRegion(temp)).toByteArray();\n    temp2 += cipher.final().toByteArray();\n    if (!cipher.ok())\n        return cipherText;\n    if (direction)\n        temp2 = byteToB64(temp2);\n    return temp2;\n}", "target": 1}
{"code": "static int efi_capsule_release(struct inode *inode, struct file *file)\n{\n\tstruct capsule_info *cap_info = file->private_data;\n\tif (cap_info->index > 0 &&\n\t    (cap_info->header.headersize == 0 ||\n\t     cap_info->count < cap_info->total_size)) {\n\t\tpr_err(\"capsule upload not complete\\n\");\n\t\tefi_free_all_buff_pages(cap_info);\n\t}\n\tkfree(cap_info->pages);\n\tkfree(cap_info->phys);\n\tkfree(file->private_data);\n\tfile->private_data = NULL;\n\treturn 0;\n}", "target": 0}
{"code": "static int edit_ext(char* editor, char* name, char* date, char* data)\n{\n\tint fd;\n\tint st;\n\tint sz;\n\tchar* b;\n\tchar* l;\n\tchar buff[512];\n\tpid_t pid;\n\tstrcpy(buff,\"/tmp/nodau.XXXXXX\");\n\tfd = mkstemp(buff);\n\tif (fd < 0)\n\t\treturn 1;\n\tpid = fork();\n\tif (pid < 0) {\n\t\treturn 1;\n\t}else if (pid) {\n\t\tclose(fd);\n\t\twaitpid(pid,&st,0);\n\t\tif (!st) {\n\t\t\tif ((fd = open(buff,O_RDONLY)) < 0)\n\t\t\t\treturn 1;\n\t\t\tsz = lseek(fd,0,SEEK_END);\n\t\t\tlseek(fd,0,SEEK_SET);\n\t\t\tif (sz) {\n\t\t\t\tb = alloca(sz+1);\n\t\t\t\tif (sz != read(fd,b,sz))\n\t\t\t\t\treturn 1;\n\t\t\t\tclose(fd);\n\t\t\t\tremove(buff);\n\t\t\t\tb[sz] = 0;\n\t\t\t\tl = strstr(b,\"-----\");\n\t\t\t\tif (l) {\n\t\t\t\t\tl += 6;\n\t\t\t\t\tif (db_update(name,l))\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\tprintf(\"%s saved\\n\",name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn st;\n\t}\n\tsz = strlen(name)+strlen(date)+strlen(data)+50;\n\tb = alloca(sz);\n\tsz = sprintf(\n\t\tb,\n\t\t\"%s (%s)\\nText above this line is ignored\\n-----\\n%s\",\n\t\tname,\n\t\tdate,\n\t\tdata\n\t);\n\tif (write(fd,b,sz) != sz) {\n\t\texit(1);\n\t}\n\tfsync(fd);\n\tclose(fd);\n\tst = execl(editor,editor,buff,(char*)NULL);\n\texit(st);\n\treturn 1;\n}", "target": 1}
{"code": "static void sunkbd_reinit(struct work_struct *work)\n{\n\tstruct sunkbd *sunkbd = container_of(work, struct sunkbd, tq);\n\twait_event_interruptible_timeout(sunkbd->wait, sunkbd->reset >= 0, HZ);\n\tserio_write(sunkbd->serio, SUNKBD_CMD_SETLED);\n\tserio_write(sunkbd->serio,\n\t\t(!!test_bit(LED_CAPSL,   sunkbd->dev->led) << 3) |\n\t\t(!!test_bit(LED_SCROLLL, sunkbd->dev->led) << 2) |\n\t\t(!!test_bit(LED_COMPOSE, sunkbd->dev->led) << 1) |\n\t\t !!test_bit(LED_NUML,    sunkbd->dev->led));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_NOCLICK - !!test_bit(SND_CLICK, sunkbd->dev->snd));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_BELLOFF - !!test_bit(SND_BELL, sunkbd->dev->snd));\n}", "target": 1}
{"code": "R_API char *r_socket_http_get(const char *url, int *code, int *rlen) {\n\tchar *curl_env = r_sys_getenv (\"R2_CURL\");\n\tif (curl_env && *curl_env) {\n\t\tchar *encoded_url = r_str_escape (url);\n\t\tchar *res = r_sys_cmd_strf (\"curl '%s'\", encoded_url);\n\t\tfree (encoded_url);\n\t\tif (res) {\n\t\t\tif (code) {\n\t\t\t\t*code = 200;\n\t\t\t}\n\t\t\tif (rlen) {\n\t\t\t\t*rlen = strlen (res);\n\t\t\t}\n\t\t}\n\t\tfree (curl_env);\n\t\treturn res;\n\t}\n\tfree (curl_env);\n\tRSocket *s;\n\tint ssl = r_str_startswith (url, \"https:\n\tchar *response, *host, *path, *port = \"80\";\n\tchar *uri = strdup (url);\n\tif (!uri) {\n\t\treturn NULL;\n\t}\n\tif (code) {\n\t\t*code = 0;\n\t}\n\tif (rlen) {\n\t\t*rlen = 0;\n\t}\n\thost = strstr (uri, \":\n\tif (!host) {\n\t\tfree (uri);\n\t\teprintf (\"r_socket_http_get: Invalid URI\");\n\t\treturn NULL;\n\t}\n\thost += 3;\n\tport = strchr (host, ':');\n\tif (!port) {\n\t\tport = ssl? \"443\": \"80\";\n\t\tpath = host;\n\t} else {\n\t\t*port++ = 0;\n\t\tpath = port;\n\t}\n\tpath = strchr (path, '/');\n\tif (!path) {\n\t\tpath = \"\";\n\t} else {\n\t\t*path++ = 0;\n\t}\n\ts = r_socket_new (ssl);\n\tif (!s) {\n\t\teprintf (\"r_socket_http_get: Cannot create socket\\n\");\n\t\tfree (uri);\n\t\treturn NULL;\n\t}\n\tif (r_socket_connect_tcp (s, host, port, 0)) {\n\t\tr_socket_printf (s,\n\t\t\t\t\"GET /%s HTTP/1.1\\r\\n\"\n\t\t\t\t\"User-Agent: radare2 \"R2_VERSION\"\\r\\n\"\n\t\t\t\t\"Accept: *", "target": 1}
{"code": "p_ntp_time(netdissect_options *ndo,\n\t   const struct l_fixedpt *lfp)\n{\n\tuint32_t i;\n\tuint32_t uf;\n\tuint32_t f;\n\tdouble ff;\n\ti = GET_BE_U_4(lfp->int_part);\n\tuf = GET_BE_U_4(lfp->fraction);\n\tff = uf;\n\tif (ff < 0.0)\t\t\n\t\tff += FMAXINT;\n\tff = ff / FMAXINT;\t\t\t\n\tf = (uint32_t)(ff * 1000000000.0);\t\n\tND_PRINT(\"%u.%09u\", i, f);\n\tif (i) {\n\t    int64_t seconds_64bit = (int64_t)i - JAN_1970;\n\t    time_t seconds;\n\t    struct tm *tm;\n\t    char time_buf[128];\n\t    seconds = (time_t)seconds_64bit;\n\t    if (seconds != seconds_64bit) {\n\t\tND_PRINT(\" (unrepresentable)\");\n\t    } else {\n\t\ttm = gmtime(&seconds);\n\t\tif (tm == NULL) {\n\t\t    ND_PRINT(\" (unrepresentable)\");\n\t\t} else {\n\t\t    strftime(time_buf, sizeof (time_buf), \"%Y-%m-%dT%H:%M:%SZ\", tm);\n\t\t    ND_PRINT(\" (%s)\", time_buf);\n\t\t}\n\t    }\n\t}\n}", "target": 1}
{"code": "static int uas_use_uas_driver(struct usb_interface *intf,\n\t\t\t      const struct usb_device_id *id,\n\t\t\t      unsigned long *flags_ret)\n{\n\tstruct usb_host_endpoint *eps[4] = { };\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\tunsigned long flags = id->driver_info;\n\tint r, alt;\n\talt = uas_find_uas_alt_setting(intf);\n\tif (alt < 0)\n\t\treturn 0;\n\tr = uas_find_endpoints(&intf->altsetting[alt], eps);\n\tif (r < 0)\n\t\treturn 0;\n\tif (le16_to_cpu(udev->descriptor.idVendor) == 0x174c &&\n\t\t\t(le16_to_cpu(udev->descriptor.idProduct) == 0x5106 ||\n\t\t\t le16_to_cpu(udev->descriptor.idProduct) == 0x55aa)) {\n\t\tif (udev->actconfig->desc.bMaxPower == 0) {\n\t\t} else if (udev->speed < USB_SPEED_SUPER) {\n\t\t\tflags |= US_FL_IGNORE_UAS;\n\t\t} else if (usb_ss_max_streams(&eps[1]->ss_ep_comp) == 32) {\n\t\t\tflags |= US_FL_IGNORE_UAS;\n\t\t} else {\n\t\t\tflags |= US_FL_MAX_SECTORS_240;\n\t\t}\n\t}\n\tusb_stor_adjust_quirks(udev, &flags);\n\tif (flags & US_FL_IGNORE_UAS) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"UAS is blacklisted for this device, using usb-storage instead\\n\");\n\t\treturn 0;\n\t}\n\tif (udev->bus->sg_tablesize == 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"The driver for the USB controller %s does not support scatter-gather which is\\n\",\n\t\t\thcd->driver->description);\n\t\tdev_warn(&udev->dev,\n\t\t\t\"required by the UAS driver. Please try an other USB controller if you wish to use UAS.\\n\");\n\t\treturn 0;\n\t}\n\tif (udev->speed >= USB_SPEED_SUPER && !hcd->can_do_streams) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"USB controller %s does not support streams, which are required by the UAS driver.\\n\",\n\t\t\thcd_to_bus(hcd)->bus_name);\n\t\tdev_warn(&udev->dev,\n\t\t\t\"Please try an other USB controller if you wish to use UAS.\\n\");\n\t\treturn 0;\n\t}\n\tif (flags_ret)\n\t\t*flags_ret = flags;\n\treturn 1;\n}", "target": 1}
{"code": "int kvm_arch_init_vm(struct kvm *kvm, unsigned long type)\n{\n\tif (type)\n\t\treturn -EINVAL;\n\tINIT_LIST_HEAD(&kvm->arch.active_mmu_pages);\n\tINIT_LIST_HEAD(&kvm->arch.assigned_dev_head);\n\tset_bit(KVM_USERSPACE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);\n\tset_bit(KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID,\n\t\t&kvm->arch.irq_sources_bitmap);\n\traw_spin_lock_init(&kvm->arch.tsc_write_lock);\n\tmutex_init(&kvm->arch.apic_map_lock);\n\tspin_lock_init(&kvm->arch.pvclock_gtod_sync_lock);\n\tpvclock_update_vm_gtod_copy(kvm);\n\treturn 0;\n}", "target": 0}
{"code": "Server::Server(boost::asio::ip::tcp protocol, std::uint16_t port,\n               const fs::path& doc_root)\n    : protocol_(protocol),\n      port_(port),\n      doc_root_(doc_root),\n      acceptor_(io_context_),\n      signals_(io_context_) {\n  CheckDocRoot();\n  AddSignals();\n}", "target": 0}
{"code": "int32_t *enc_untrusted_create_wait_queue() {\n  MessageWriter input;\n  MessageReader output;\n  input.Push<uint64_t>(sizeof(int32_t));\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kLocalLifetimeAllocHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_create_wait_queue\",\n                           2);\n  int32_t *queue = reinterpret_cast<int32_t *>(output.next<uintptr_t>());\n  if (!TrustedPrimitives::IsOutsideEnclave(queue, sizeof(int32_t))) {\n    TrustedPrimitives::BestEffortAbort(\n        \"enc_untrusted_create_wait_queue: queue should be in untrusted memory\");\n  }\n  int klinux_errno = output.next<int>();\n  if (queue == nullptr) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n  enc_untrusted_disable_waiting(queue);\n  return queue;\n}", "target": 0}
{"code": "static int __init proc_genhd_init(void)\n{\n\tproc_create(\"diskstats\", 0, NULL, &proc_diskstats_operations);\n\tproc_create(\"partitions\", 0, NULL, &proc_partitions_operations);\n\treturn 0;\n}", "target": 0}
{"code": "int MSG_ReadBits( msg_t *msg, int bits ) {\n\tint\t\t\tvalue;\n\tint\t\t\tget;\n\tqboolean\tsgn;\n\tint\t\t\ti, nbits;\n\tvalue = 0;\n\tif ( bits < 0 ) {\n\t\tbits = -bits;\n\t\tsgn = qtrue;\n\t} else {\n\t\tsgn = qfalse;\n\t}\n\tif (msg->oob) {\n\t\tif(bits==8)\n\t\t{\n\t\t\tvalue = msg->data[msg->readcount];\n\t\t\tmsg->readcount += 1;\n\t\t\tmsg->bit += 8;\n\t\t}\n\t\telse if(bits==16)\n\t\t{\n\t\t\tshort temp;\n\t\t\tCopyLittleShort(&temp, &msg->data[msg->readcount]);\n\t\t\tvalue = temp;\n\t\t\tmsg->readcount += 2;\n\t\t\tmsg->bit += 16;\n\t\t}\n\t\telse if(bits==32)\n\t\t{\n\t\t\tCopyLittleLong(&value, &msg->data[msg->readcount]);\n\t\t\tmsg->readcount += 4;\n\t\t\tmsg->bit += 32;\n\t\t}\n\t\telse\n\t\t\tCom_Error(ERR_DROP, \"can't read %d bits\", bits);\n\t} else {\n\t\tnbits = 0;\n\t\tif (bits&7) {\n\t\t\tnbits = bits&7;\n\t\t\tfor(i=0;i<nbits;i++) {\n\t\t\t\tvalue |= (Huff_getBit(msg->data, &msg->bit)<<i);\n\t\t\t}\n\t\t\tbits = bits - nbits;\n\t\t}\n\t\tif (bits) {\n\t\t\tfor(i=0;i<bits;i+=8) {\n\t\t\t\tHuff_offsetReceive (msgHuff.decompressor.tree, &get, msg->data, &msg->bit);\n\t\t\t\tvalue |= (get<<(i+nbits));\n\t\t\t}\n\t\t}\n\t\tmsg->readcount = (msg->bit>>3)+1;\n\t}\n\tif ( sgn && bits > 0 && bits < 32 ) {\n\t\tif ( value & ( 1 << ( bits - 1 ) ) ) {\n\t\t\tvalue |= -1 ^ ( ( 1 << bits ) - 1 );\n\t\t}\n\t}\n\treturn value;\n}", "target": 1}
{"code": "static void follow_dotdot(struct nameidata *nd)\n{\n\tif (!nd->root.mnt)\n\t\tset_root(nd);\n\twhile(1) {\n\t\tstruct dentry *old = nd->path.dentry;\n\t\tif (nd->path.dentry == nd->root.dentry &&\n\t\t    nd->path.mnt == nd->root.mnt) {\n\t\t\tbreak;\n\t\t}\n\t\tif (nd->path.dentry != nd->path.mnt->mnt_root) {\n\t\t\tnd->path.dentry = dget_parent(nd->path.dentry);\n\t\t\tdput(old);\n\t\t\tbreak;\n\t\t}\n\t\tif (!follow_up(&nd->path))\n\t\t\tbreak;\n\t}\n\tfollow_mount(&nd->path);\n\tnd->inode = nd->path.dentry->d_inode;\n}", "target": 1}
{"code": "static int threaded_has_dirs_only_path(struct cache_def *cache, const char *name, int len, int prefix_len)\n{\n\treturn lstat_cache(cache, name, len,\n\t\t\t   FL_DIR|FL_FULLPATH, prefix_len) &\n\t\tFL_DIR;\n}", "target": 0}
{"code": "SSecurityTLS::~SSecurityTLS()\n{\n  shutdown();\n  if (fis)\n    delete fis;\n  if (fos)\n    delete fos;\n  delete[] keyfile;\n  delete[] certfile;\n  gnutls_global_deinit();\n}", "target": 0}
{"code": "TEST_P(TcpTunnelingIntegrationTest, UpstreamConnectingDownstreamDisconnect) {\n  if (upstreamProtocol() == Http::CodecType::HTTP1) {\n    return;\n  }\n#if defined(WIN32)\n  return;\n#endif\n  config_helper_.addConfigModifier([&](envoy::config::bootstrap::v3::Bootstrap& bootstrap) -> void {\n    envoy::extensions::filters::network::tcp_proxy::v3::TcpProxy proxy_config;\n    proxy_config.set_stat_prefix(\"tcp_stats\");\n    proxy_config.set_cluster(\"cluster_0\");\n    proxy_config.mutable_tunneling_config()->set_hostname(\"host.com:80\");\n    proxy_config.mutable_max_connect_attempts()->set_value(2);\n    auto* listeners = bootstrap.mutable_static_resources()->mutable_listeners();\n    for (auto& listener : *listeners) {\n      if (listener.name() != \"tcp_proxy\") {\n        continue;\n      }\n      auto* filter_chain = listener.mutable_filter_chains(0);\n      auto* filter = filter_chain->mutable_filters(0);\n      filter->mutable_typed_config()->PackFrom(proxy_config);\n      envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n      ConfigHelper::initializeTls({}, *tls_context.mutable_common_tls_context());\n      filter_chain->mutable_transport_socket()->set_name(\"envoy.transport_sockets.tls\");\n      filter_chain->mutable_transport_socket()->mutable_typed_config()->PackFrom(tls_context);\n      break;\n    }\n  });\n  enableHalfClose(false);\n  initialize();\n  IntegrationTcpClientPtr tcp_client = makeTcpConnection(lookupPort(\"tcp_proxy\"));\n  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));\n  ASSERT_TRUE(fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_));\n  ASSERT_TRUE(upstream_request_->waitForHeadersComplete());\n  tcp_client->close();\n  ASSERT_TRUE(upstream_request_->waitForReset());\n  ASSERT_TRUE(fake_upstream_connection_->close());\n}", "target": 0}
{"code": "static inline int preempt_count_equals(int preempt_offset)\n{\n\tint nested = preempt_count() + rcu_preempt_depth();\n\treturn (nested == preempt_offset);\n}", "target": 0}
{"code": "static pj_status_t decode_errcode_attr(pj_pool_t *pool, \n                                       const pj_uint8_t *buf,\n                                       const pj_stun_msg_hdr *msghdr, \n                                       void **p_attr)\n{\n    pj_stun_errcode_attr *attr;\n    pj_str_t value;\n    PJ_UNUSED_ARG(msghdr);\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_errcode_attr);\n    GETATTRHDR(buf, &attr->hdr);\n    attr->err_code = buf[6] * 100 + buf[7];\n    value.ptr = ((char*)buf + ATTR_HDR_LEN + 4);\n    value.slen = attr->hdr.length - 4;\n    if (value.slen < 0)\n        value.slen = 0;\n    pj_strdup(pool, &attr->reason, &value);\n    *p_attr = attr;\n    return PJ_SUCCESS;\n}", "target": 1}
{"code": "static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)\n{\n\tint rlen, remain;\n\tdpIOCtxPtr dctx;\n\tdynamicPtr *dp;\n\tdctx = (dpIOCtxPtr) ctx;\n\tdp = dctx->dp;\n\tremain = dp->logicalSize - dp->pos;\n\tif(remain >= len) {\n\t\trlen = len;\n\t} else {\n\t\tif(remain == 0) {\n\t\t\treturn 0; \n\t\t}\n\t\trlen = remain;\n\t}\n\tmemcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);\n\tdp->pos += rlen;\n\treturn rlen;\n}", "target": 1}
{"code": "count_new_keys(int n_key_data, krb5_key_data *key_data)\n{\n    int n;\n    for (n = 1; n < n_key_data; n++) {\n        if (key_data[n - 1].key_data_kvno != key_data[n].key_data_kvno)\n            return n;\n    }\n    return n_key_data;\n}", "target": 0}
{"code": "gfx::Rect WebContentsImpl::GetRootWindowResizerRect() const {\n  if (delegate_)\n    return delegate_->GetRootWindowResizerRect();\n  return gfx::Rect();\n}", "target": 0}
{"code": "static int parse_import_ptr(struct MACH0_(obj_t)* bin, struct reloc_t *reloc, int idx) {\n\tint i, j, sym, wordsize;\n\tut32 stype;\n\twordsize = MACH0_(get_bits)(bin) / 8;\n\tif (idx < 0 || idx >= bin->nsymtab) {\n\t\treturn 0;\n\t}\n\tif ((bin->symtab[idx].n_desc & REFERENCE_TYPE) == REFERENCE_FLAG_UNDEFINED_LAZY) {\n\t\tstype = S_LAZY_SYMBOL_POINTERS;\n\t} else {\n\t\tstype = S_NON_LAZY_SYMBOL_POINTERS;\n\t}\n\treloc->offset = 0;\n\treloc->addr = 0;\n\treloc->addend = 0;\n#define CASE(T) case (T / 8): reloc->type = R_BIN_RELOC_ ## T; break\n\tswitch (wordsize) {\n\t\tCASE(8);\n\t\tCASE(16);\n\t\tCASE(32);\n\t\tCASE(64);\n\t\tdefault: return false;\n\t}\n#undef CASE\n\tfor (i = 0; i < bin->nsects; i++) {\n\t\tif ((bin->sects[i].flags & SECTION_TYPE) == stype) {\n\t\t\tfor (j=0, sym=-1; bin->sects[i].reserved1+j < bin->nindirectsyms; j++)\n\t\t\t\tif (idx == bin->indirectsyms[bin->sects[i].reserved1 + j]) {\n\t\t\t\t\tsym = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\treloc->offset = sym == -1 ? 0 : bin->sects[i].offset + sym * wordsize;\n\t\t\treloc->addr = sym == -1 ? 0 : bin->sects[i].addr + sym * wordsize;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 1}
{"code": "inline TfLiteStatus GetMutableInputSafe(const TfLiteContext* context,\n                                        const TfLiteNode* node, int index,\n                                        const TfLiteTensor** tensor) {\n  int tensor_index;\n  TF_LITE_ENSURE_OK(\n      context, ValidateTensorIndexingSafe(context, index, node->inputs->size,\n                                          node->inputs->data, &tensor_index));\n  *tensor = GetTensorAtIndex(context, tensor_index);\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static int futex_wait(u32 __user *uaddr, int fshared,\n\t\t      u32 val, ktime_t *abs_time, u32 bitset, int clockrt)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct restart_block *restart;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q q;\n\tint ret;\n\tif (!bitset)\n\t\treturn -EINVAL;\n\tq.pi_state = NULL;\n\tq.bitset = bitset;\n\tq.rt_waiter = NULL;\n\tq.requeue_pi_key = NULL;\n\tif (abs_time) {\n\t\tto = &timeout;\n\t\thrtimer_init_on_stack(&to->timer, clockrt ? CLOCK_REALTIME :\n\t\t\t\t      CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n\t}\nretry:\n\tret = futex_wait_setup(uaddr, val, fshared, &q, &hb);\n\tif (ret)\n\t\tgoto out;\n\tfutex_wait_queue_me(hb, &q, to);\n\tret = 0;\n\tif (!unqueue_me(&q))\n\t\tgoto out_put_key;\n\tret = -ETIMEDOUT;\n\tif (to && !to->task)\n\t\tgoto out_put_key;\n\tif (!signal_pending(current)) {\n\t\tput_futex_key(fshared, &q.key);\n\t\tgoto retry;\n\t}\n\tret = -ERESTARTSYS;\n\tif (!abs_time)\n\t\tgoto out_put_key;\n\trestart = &current_thread_info()->restart_block;\n\trestart->fn = futex_wait_restart;\n\trestart->futex.uaddr = (u32 *)uaddr;\n\trestart->futex.val = val;\n\trestart->futex.time = abs_time->tv64;\n\trestart->futex.bitset = bitset;\n\trestart->futex.flags = FLAGS_HAS_TIMEOUT;\n\tif (fshared)\n\t\trestart->futex.flags |= FLAGS_SHARED;\n\tif (clockrt)\n\t\trestart->futex.flags |= FLAGS_CLOCKRT;\n\tret = -ERESTART_RESTARTBLOCK;\nout_put_key:\n\tput_futex_key(fshared, &q.key);\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "int __ref online_pages(unsigned long pfn, unsigned long nr_pages)\n{\n\tunsigned long onlined_pages = 0;\n\tstruct zone *zone;\n\tint need_zonelists_rebuild = 0;\n\tint nid;\n\tint ret;\n\tstruct memory_notify arg;\n\tlock_memory_hotplug();\n\targ.start_pfn = pfn;\n\targ.nr_pages = nr_pages;\n\targ.status_change_nid = -1;\n\tnid = page_to_nid(pfn_to_page(pfn));\n\tif (node_present_pages(nid) == 0)\n\t\targ.status_change_nid = nid;\n\tret = memory_notify(MEM_GOING_ONLINE, &arg);\n\tret = notifier_to_errno(ret);\n\tif (ret) {\n\t\tmemory_notify(MEM_CANCEL_ONLINE, &arg);\n\t\tunlock_memory_hotplug();\n\t\treturn ret;\n\t}\n\tzone = page_zone(pfn_to_page(pfn));\n\tmutex_lock(&zonelists_mutex);\n\tif (!populated_zone(zone))\n\t\tneed_zonelists_rebuild = 1;\n\tret = walk_system_ram_range(pfn, nr_pages, &onlined_pages,\n\t\tonline_pages_range);\n\tif (ret) {\n\t\tmutex_unlock(&zonelists_mutex);\n\t\tprintk(KERN_DEBUG \"online_pages [mem %#010llx-%#010llx] failed\\n\",\n\t\t       (unsigned long long) pfn << PAGE_SHIFT,\n\t\t       (((unsigned long long) pfn + nr_pages)\n\t\t\t    << PAGE_SHIFT) - 1);\n\t\tmemory_notify(MEM_CANCEL_ONLINE, &arg);\n\t\tunlock_memory_hotplug();\n\t\treturn ret;\n\t}\n\tzone->present_pages += onlined_pages;\n\tzone->zone_pgdat->node_present_pages += onlined_pages;\n\tif (need_zonelists_rebuild)\n\t\tbuild_all_zonelists(NULL, zone);\n\telse\n\t\tzone_pcp_update(zone);\n\tmutex_unlock(&zonelists_mutex);\n\tinit_per_zone_wmark_min();\n\tif (onlined_pages) {\n\t\tkswapd_run(zone_to_nid(zone));\n\t\tnode_set_state(zone_to_nid(zone), N_HIGH_MEMORY);\n\t}\n\tvm_total_pages = nr_free_pagecache_pages();\n\twriteback_set_ratelimit();\n\tif (onlined_pages)\n\t\tmemory_notify(MEM_ONLINE, &arg);\n\tunlock_memory_hotplug();\n\treturn 0;\n}", "target": 1}
{"code": "oftrace_node_list_destroy(struct ovs_list *nodes)\n{\n    if (nodes) {\n        struct oftrace_node *node, *next;\n        LIST_FOR_EACH_SAFE (node, next, node, nodes) {\n            ovs_list_remove(&node->node);\n            oftrace_node_destroy(node);\n        }\n    }\n}", "target": 0}
{"code": "void FrameLoader::begin(const KURL& url, bool dispatch, SecurityOrigin* origin)\n{\n    RefPtr<SecurityOrigin> forcedSecurityOrigin = origin;\n    RefPtr<Document> document;\n    if (!m_isDisplayingInitialEmptyDocument && m_client->shouldUsePluginDocument(m_responseMIMEType))\n        document = PluginDocument::create(m_frame);\n    else if (!m_client->hasHTMLView())\n        document = PlaceholderDocument::create(m_frame);\n    else\n        document = DOMImplementation::createDocument(m_responseMIMEType, m_frame, m_frame->inViewSourceMode());\n    bool resetScripting = !(m_isDisplayingInitialEmptyDocument && m_frame->document()->securityOrigin()->isSecureTransitionTo(url));\n    clear(resetScripting, resetScripting);\n    if (resetScripting)\n        m_frame->script()->updatePlatformScriptObjects();\n    m_needsClear = true;\n    m_isComplete = false;\n    m_didCallImplicitClose = false;\n    m_isLoadingMainResource = true;\n    m_isDisplayingInitialEmptyDocument = m_creatingInitialEmptyDocument;\n    KURL ref(url);\n    ref.setUser(String());\n    ref.setPass(String());\n    ref.removeFragmentIdentifier();\n    m_outgoingReferrer = ref.string();\n    m_URL = url;\n    document->setURL(m_URL);\n    m_frame->setDocument(document);\n    if (m_decoder)\n        document->setDecoder(m_decoder.get());\n    if (forcedSecurityOrigin)\n        document->setSecurityOrigin(forcedSecurityOrigin.get());\n    m_frame->domWindow()->setURL(document->url());\n    m_frame->domWindow()->setSecurityOrigin(document->securityOrigin());\n    if (dispatch)\n        dispatchWindowObjectAvailable();\n    updateFirstPartyForCookies();\n    Settings* settings = document->settings();\n    document->docLoader()->setAutoLoadImages(settings && settings->loadsImagesAutomatically());\n    if (m_documentLoader) {\n        String dnsPrefetchControl = m_documentLoader->response().httpHeaderField(\"X-DNS-Prefetch-Control\");\n        if (!dnsPrefetchControl.isEmpty())\n            document->parseDNSPrefetchControlHeader(dnsPrefetchControl);\n    }\n    history()->restoreDocumentState();\n    document->implicitOpen();\n    if (m_frame->view() && m_client->hasHTMLView())\n        m_frame->view()->setContentsSize(IntSize());\n}", "target": 0}
{"code": "int ConnectionImpl::onHeadersCompleteBase() {\n  ENVOY_CONN_LOG(trace, \"headers complete\", connection_);\n  completeLastHeader();\n  ASSERT(current_header_map_->byteSize().has_value() &&\n         current_header_map_->byteSize() == current_header_map_->byteSizeInternal());\n  if (!(parser_.http_major == 1 && parser_.http_minor == 1)) {\n    protocol_ = Protocol::Http10;\n  }\n  if (Utility::isUpgrade(*current_header_map_)) {\n    if (current_header_map_->Upgrade() &&\n        absl::EqualsIgnoreCase(current_header_map_->Upgrade()->value().getStringView(),\n                               Http::Headers::get().UpgradeValues.H2c)) {\n      ENVOY_CONN_LOG(trace, \"removing unsupported h2c upgrade headers.\", connection_);\n      current_header_map_->removeUpgrade();\n      if (current_header_map_->Connection()) {\n        const auto& tokens_to_remove = caseUnorderdSetContainingUpgradeAndHttp2Settings();\n        std::string new_value = StringUtil::removeTokens(\n            current_header_map_->Connection()->value().getStringView(), \",\", tokens_to_remove, \",\");\n        if (new_value.empty()) {\n          current_header_map_->removeConnection();\n        } else {\n          current_header_map_->Connection()->value(new_value);\n        }\n      }\n      current_header_map_->remove(Headers::get().Http2Settings);\n    } else {\n      ENVOY_CONN_LOG(trace, \"codec entering upgrade mode.\", connection_);\n      handling_upgrade_ = true;\n    }\n  }\n  int rc = onHeadersComplete(std::move(current_header_map_));\n  current_header_map_.reset();\n  header_parsing_state_ = HeaderParsingState::Done;\n  return handling_upgrade_ ? 2 : rc;\n}", "target": 0}
{"code": "GF_EXPORT\nBool gf_isom_get_oinf_info(GF_ISOFile *file, u32 trackNumber, GF_OperatingPointsInformation **ptr)\n{\n\tu32 oref_track, def_index=0;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(file, trackNumber);\n\tif (!ptr) return GF_FALSE;\n\toref_track=0;\n\tgf_isom_get_reference(file, trackNumber, GF_ISOM_REF_OREF, 1, &oref_track);\n\tif (oref_track) {\n\t\ttrak = gf_isom_get_track_from_file(file, oref_track);\n\t\tif (!trak) return GF_FALSE;\n\t}\n\t*ptr = (GF_OperatingPointsInformation *) gf_isom_get_sample_group_info_entry(file, trak, GF_ISOM_SAMPLE_GROUP_OINF, 1, &def_index, NULL);\n\treturn *ptr ? GF_TRUE : GF_FALSE;", "target": 0}
{"code": "int install_process_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\tif (new->process_keyring)\n\t\treturn -EEXIST;\n\tkeyring = keyring_alloc(\"_pid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\tnew->process_keyring = keyring;\n\treturn 0;\n}", "target": 1}
{"code": "static int uvesafb_setcmap(struct fb_cmap *cmap, struct fb_info *info)\n{\n\tstruct uvesafb_pal_entry *entries;\n\tint shift = 16 - dac_width;\n\tint i, err = 0;\n\tif (info->var.bits_per_pixel == 8) {\n\t\tif (cmap->start + cmap->len > info->cmap.start +\n\t\t    info->cmap.len || cmap->start < info->cmap.start)\n\t\t\treturn -EINVAL;\n\t\tentries = kmalloc(sizeof(*entries) * cmap->len, GFP_KERNEL);\n\t\tif (!entries)\n\t\t\treturn -ENOMEM;\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\tentries[i].red   = cmap->red[i]   >> shift;\n\t\t\tentries[i].green = cmap->green[i] >> shift;\n\t\t\tentries[i].blue  = cmap->blue[i]  >> shift;\n\t\t\tentries[i].pad   = 0;\n\t\t}\n\t\terr = uvesafb_setpalette(entries, cmap->len, cmap->start, info);\n\t\tkfree(entries);\n\t} else {\n\t\tfor (i = 0; i < cmap->len; i++) {\n\t\t\terr |= uvesafb_setcolreg(cmap->start + i, cmap->red[i],\n\t\t\t\t\t\tcmap->green[i], cmap->blue[i],\n\t\t\t\t\t\t0, info);\n\t\t}\n\t}\n\treturn err;\n}", "target": 1}
{"code": "PrintBackend *cpdbCreateBackendFromFile(GDBusConnection *connection,\n                                        const char *backend_file_name)\n{\n    FILE *file = NULL;\n    PrintBackend *proxy;\n    GError *error = NULL;\n    char *path, *backend_name;\n    const char *info_dir_name;\n    char obj_path[CPDB_BSIZE];\n    backend_name = cpdbGetStringCopy(backend_file_name);\n    if ((info_dir_name = getenv(\"CPDB_BACKEND_INFO_DIR\")) == NULL)\n      info_dir_name = CPDB_BACKEND_INFO_DIR;\n    path = cpdbConcatPath(info_dir_name, backend_file_name);\n    if ((file = fopen(path, \"r\")) == NULL)\n    {\n        logerror(\"Error creating backend %s : Couldn't open %s for reading\\n\",\n                    backend_name, path);\n        free(path);\n        return NULL;\n    }\n    if (fscanf(file, \"%s\", obj_path) == 0)\n    {\n        logerror(\"Error creating backend %s : Couldn't parse %s\\n\",\n                    backend_name, path);\n        free(path);\n        fclose(file);\n        return NULL;\n    }\n    free(path);\n    fclose(file);\n    proxy = print_backend_proxy_new_sync(connection,\n                                         0,\n                                         backend_name,\n                                         obj_path,\n                                         NULL,\n                                         &error);\n    if (error)\n    {\n        logerror(\"Error creating backend proxy for %s : %s\\n\",\n                    backend_name, error->message);\n        return NULL;\n    }\n    return proxy;\n}", "target": 1}
{"code": "int main(void) {\n    if (siphash_test() == 0) {\n        printf(\"SipHash test: OK\\n\");\n        return 0;\n    } else {\n        printf(\"SipHash test: FAILED\\n\");\n        return 1;\n    }\n}", "target": 0}
{"code": "handle_ppp(netdissect_options *ndo,\n           u_int proto, const u_char *p, int length)\n{\n\tif ((proto & 0xff00) == 0x7e00) { \n\t\tppp_hdlc(ndo, p - 1, length);\n\t\treturn;\n\t}\n\tswitch (proto) {\n\tcase PPP_LCP: \n\tcase PPP_IPCP:\n\tcase PPP_OSICP:\n\tcase PPP_MPLSCP:\n\tcase PPP_IPV6CP:\n\tcase PPP_CCP:\n\tcase PPP_BACP:\n\t\thandle_ctrl_proto(ndo, proto, p, length);\n\t\tbreak;\n\tcase PPP_ML:\n\t\thandle_mlppp(ndo, p, length);\n\t\tbreak;\n\tcase PPP_CHAP:\n\t\thandle_chap(ndo, p, length);\n\t\tbreak;\n\tcase PPP_PAP:\n\t\thandle_pap(ndo, p, length);\n\t\tbreak;\n\tcase PPP_BAP:\t\t\n\t\thandle_bap(ndo, p, length);\n\t\tbreak;\n\tcase ETHERTYPE_IP:\t\n        case PPP_VJNC:\n\tcase PPP_IP:\n\t\tip_print(ndo, p, length);\n\t\tbreak;\n\tcase ETHERTYPE_IPV6:\t\n\tcase PPP_IPV6:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\tcase ETHERTYPE_IPX:\t\n\tcase PPP_IPX:\n\t\tipx_print(ndo, p, length);\n\t\tbreak;\n\tcase PPP_OSI:\n\t\tisoclns_print(ndo, p, length, length);\n\t\tbreak;\n\tcase PPP_MPLS_UCAST:\n\tcase PPP_MPLS_MCAST:\n\t\tmpls_print(ndo, p, length);\n\t\tbreak;\n\tcase PPP_COMP:\n\t\tND_PRINT((ndo, \"compressed PPP data\"));\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"%s \", tok2str(ppptype2str, \"unknown PPP protocol (0x%04x)\", proto)));\n\t\tprint_unknown_data(ndo, p, \"\\n\\t\", length);\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "write_stacktrace(const char *file_name, const char *str)\n{\n\tint fd;\n\tvoid *buffer[100];\n\tint nptrs;\n\tint i;\n\tchar **strs;\n\tnptrs = backtrace(buffer, 100);\n\tif (file_name) {\n\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT, 0644);\n\t\tif (str)\n\t\t\tdprintf(fd, \"%s\\n\", str);\n\t\tbacktrace_symbols_fd(buffer, nptrs, fd);\n\t\tif (write(fd, \"\\n\", 1) != 1) {\n\t\t}\n\t\tclose(fd);\n\t} else {\n\t\tif (str)\n\t\t\tlog_message(LOG_INFO, \"%s\", str);\n\t\tstrs = backtrace_symbols(buffer, nptrs);\n\t\tif (strs == NULL) {\n\t\t\tlog_message(LOG_INFO, \"Unable to get stack backtrace\");\n\t\t\treturn;\n\t\t}\n\t\tfor (i = 1; i < nptrs - 2; i++)\n\t\t\tlog_message(LOG_INFO, \"  %s\", strs[i]);\n\t\tfree(strs);\n\t}\n}", "target": 1}
{"code": "static bool shm_may_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp)\n{\n\treturn (shp->shm_nattch == 0) &&\n\t       (ns->shm_rmid_forced ||\n\t\t(shp->shm_perm.mode & SHM_DEST));\n}", "target": 0}
{"code": "pq_buffer_has_data(void)\n{\n\treturn (PqRecvPointer < PqRecvLength);\n}", "target": 0}
{"code": "unsigned paravirt_patch_jmp(void *insnbuf, const void *target,\n\t\t\t    unsigned long addr, unsigned len)\n{\n\tstruct branch *b = insnbuf;\n\tunsigned long delta = (unsigned long)target - (addr+5);\n\tif (len < 5)\n\t\treturn len;\t\n\tb->opcode = 0xe9;\t\n\tb->delta = delta;\n\treturn 5;\n}", "target": 1}
{"code": "int CommandData::IsProcessFile(FileHeader &FileHead,bool *ExactMatch,int MatchType,\n                               wchar *MatchedArg,uint MatchedArgSize)\n{\n  if (MatchedArg!=NULL && MatchedArgSize>0)\n    *MatchedArg=0;\n  if (wcslen(FileHead.FileName)>=NM)\n    return 0;\n  bool Dir=FileHead.Dir;\n  if (ExclCheck(FileHead.FileName,Dir,false,true))\n    return 0;\n#ifndef SFX_MODULE\n  if (TimeCheck(FileHead.mtime))\n    return 0;\n  if ((FileHead.FileAttr & ExclFileAttr)!=0 || InclAttrSet && (FileHead.FileAttr & InclFileAttr)==0)\n    return 0;\n  if (!Dir && SizeCheck(FileHead.UnpSize))\n    return 0;\n#endif\n  wchar *ArgName;\n  FileArgs.Rewind();\n  for (int StringCount=1;(ArgName=FileArgs.GetString())!=NULL;StringCount++)\n    if (CmpName(ArgName,FileHead.FileName,MatchType))\n    {\n      if (ExactMatch!=NULL)\n        *ExactMatch=wcsicompc(ArgName,FileHead.FileName)==0;\n      if (MatchedArg!=NULL)\n        wcsncpyz(MatchedArg,ArgName,MatchedArgSize);\n      return StringCount;\n    }\n  return 0;\n}", "target": 1}
{"code": "static void seek_floppy(void)\n{\n\tint track;\n\tblind_seek = 0;\n\tdebug_dcl(DP->flags, \"calling disk change from %s\\n\", __func__);\n\tif (!test_bit(FD_DISK_NEWCHANGE_BIT, &DRS->flags) &&\n\t    disk_change(current_drive) && (raw_cmd->flags & FD_RAW_NEED_DISK)) {\n\t\tset_bit(FD_DISK_CHANGED_BIT, &DRS->flags);\n\t\tcont->done(0);\n\t\tcont->redo();\n\t\treturn;\n\t}\n\tif (DRS->track <= NEED_1_RECAL) {\n\t\trecalibrate_floppy();\n\t\treturn;\n\t} else if (test_bit(FD_DISK_NEWCHANGE_BIT, &DRS->flags) &&\n\t\t   (raw_cmd->flags & FD_RAW_NEED_DISK) &&\n\t\t   (DRS->track <= NO_TRACK || DRS->track == raw_cmd->track)) {\n\t\tif (raw_cmd->track)\n\t\t\ttrack = raw_cmd->track - 1;\n\t\telse {\n\t\t\tif (DP->flags & FD_SILENT_DCL_CLEAR) {\n\t\t\t\tset_dor(fdc, ~(0x10 << UNIT(current_drive)), 0);\n\t\t\t\tblind_seek = 1;\n\t\t\t\traw_cmd->flags |= FD_RAW_NEED_SEEK;\n\t\t\t}\n\t\t\ttrack = 1;\n\t\t}\n\t} else {\n\t\tcheck_wp();\n\t\tif (raw_cmd->track != DRS->track &&\n\t\t    (raw_cmd->flags & FD_RAW_NEED_SEEK))\n\t\t\ttrack = raw_cmd->track;\n\t\telse {\n\t\t\tsetup_rw_floppy();\n\t\t\treturn;\n\t\t}\n\t}\n\tdo_floppy = seek_interrupt;\n\toutput_byte(FD_SEEK);\n\toutput_byte(UNIT(current_drive));\n\tif (output_byte(track) < 0) {\n\t\treset_fdc();\n\t\treturn;\n\t}\n\tdebugt(__func__, \"\");\n}", "target": 0}
{"code": "int BN_bn2binpad(const BIGNUM *a, unsigned char *to, int tolen)\n{\n    if (tolen < 0)\n        return -1;\n    return bn2binpad(a, to, tolen);\n}", "target": 0}
{"code": "void Ppmd8_Construct(CPpmd8 *p)\n{\n  unsigned i, k, m;\n  p->Base = 0;\n  for (i = 0, k = 0; i < PPMD_NUM_INDEXES; i++)\n  {\n    unsigned step = (i >= 12 ? 4 : (i >> 2) + 1);\n    do { p->Units2Indx[k++] = (Byte)i; } while (--step);\n    p->Indx2Units[i] = (Byte)k;\n  }\n  p->NS2BSIndx[0] = (0 << 1);\n  p->NS2BSIndx[1] = (1 << 1);\n  memset(p->NS2BSIndx + 2, (2 << 1), 9);\n  memset(p->NS2BSIndx + 11, (3 << 1), 256 - 11);\n  for (i = 0; i < 5; i++)\n    p->NS2Indx[i] = (Byte)i;\n  for (m = i, k = 1; i < 260; i++)\n  {\n    p->NS2Indx[i] = (Byte)m;\n    if (--k == 0)\n      k = (++m) - 4;\n  }\n}", "target": 0}
{"code": "Integer InvertibleRWFunction::CalculateInverse(RandomNumberGenerator &rng, const Integer &x) const\n{\n\tDoQuickSanityCheck();\n\tModularArithmetic modn(m_n);\n\tInteger r, rInv;\n\tdo {\t\n\t\tr.Randomize(rng, Integer::One(), m_n - Integer::One());\n\t\trInv = modn.MultiplicativeInverse(r);\n\t} while (rInv.IsZero());\n\tInteger re = modn.Square(r);\n\tre = modn.Multiply(re, x);\t\t\t\n\tInteger cp=re%m_p, cq=re%m_q;\n\tif (Jacobi(cp, m_p) * Jacobi(cq, m_q) != 1)\n\t{\n\t\tcp = cp.IsOdd() ? (cp+m_p) >> 1 : cp >> 1;\n\t\tcq = cq.IsOdd() ? (cq+m_q) >> 1 : cq >> 1;\n\t}\n\t#pragma omp parallel\n\t\t#pragma omp sections\n\t\t{\n\t\t\t#pragma omp section\n\t\t\t\tcp = ModularSquareRoot(cp, m_p);\n\t\t\t#pragma omp section\n\t\t\t\tcq = ModularSquareRoot(cq, m_q);\n\t\t}\n\tInteger y = CRT(cq, m_q, cp, m_p, m_u);\n\ty = modn.Multiply(y, rInv);\t\t\t\t\n\ty = STDMIN(y, m_n-y);\n\tif (ApplyFunction(y) != x)\t\t\t\t\n\t\tthrow Exception(Exception::OTHER_ERROR, \"InvertibleRWFunction: computational error during private key operation\");\n\treturn y;\n}", "target": 1}
{"code": "int SetNonBlocking(int fd) {\n#if defined(OS_WIN)\n  unsigned long no_block = 1;\n  return ioctlsocket(fd, FIONBIO, &no_block);\n#elif defined(OS_POSIX)\n  int flags = fcntl(fd, F_GETFL, 0);\n  if (-1 == flags)\n    flags = 0;\n  return fcntl(fd, F_SETFL, flags | O_NONBLOCK);\n#endif\n}", "target": 0}
{"code": "pim_print(netdissect_options *ndo,\n          register const u_char *bp, register u_int len, const u_char *bp2)\n{\n\tregister const u_char *ep;\n\tregister const struct pim *pim = (const struct pim *)bp;\n\tep = (const u_char *)ndo->ndo_snapend;\n\tif (bp >= ep)\n\t\treturn;\n#ifdef notyet\t\t\t\n\tND_TCHECK(pim->pim_rsv);\n#endif\n\tswitch (PIM_VER(pim->pim_typever)) {\n\tcase 2:\n\t\tif (!ndo->ndo_vflag) {\n\t\t\tND_PRINT((ndo, \"PIMv%u, %s, length %u\",\n\t\t\t          PIM_VER(pim->pim_typever),\n\t\t\t          tok2str(pimv2_type_values,\"Unknown Type\",PIM_TYPE(pim->pim_typever)),\n\t\t\t          len));\n\t\t\treturn;\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"PIMv%u, length %u\\n\\t%s\",\n\t\t\t          PIM_VER(pim->pim_typever),\n\t\t\t          len,\n\t\t\t          tok2str(pimv2_type_values,\"Unknown Type\",PIM_TYPE(pim->pim_typever))));\n\t\t\tpimv2_print(ndo, bp, len, bp2);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"PIMv%u, length %u\",\n\t\t          PIM_VER(pim->pim_typever),\n\t\t          len));\n\t\tbreak;\n\t}\n\treturn;\n}", "target": 1}
{"code": "archive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n#if !ARCHIVE_ACL_LIBRICHACL\n\t(void)mode;\t\n#endif\n#if ARCHIVE_ACL_LIBRICHACL\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_richacl(a, fd, name, abstract_acl, mode,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n\t}\n#if ARCHIVE_ACL_LIBACL\n\telse\n#endif\n#endif\t\n#if ARCHIVE_ACL_LIBACL\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_ACCESS) != 0) {\n\t\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_ACCESS, \"access\");\n\t\t\tif (ret != ARCHIVE_OK)\n\t\t\t\treturn (ret);\n\t\t}\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_DEFAULT) != 0)\n\t\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT, \"default\");\n\t}\n#endif\t\n\treturn (ret);\n}", "target": 1}
{"code": "int snmp_version(void *context, size_t hdrlen, unsigned char tag,\n\t\t const void *data, size_t datalen)\n{\n\tif (datalen != 1)\n\t\treturn -EINVAL;\n\tif (*(unsigned char *)data > 1)\n\t\treturn -ENOTSUPP;\n\treturn 1;\n}", "target": 0}
{"code": "static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *segment)\n{\n    int i, length;\n    segment->nb_index_entries = avio_rb32(pb);\n    length = avio_rb32(pb);\n    if(segment->nb_index_entries && length < 11)\n        return AVERROR_INVALIDDATA;\n    if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||\n        !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||\n        !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries)))) {\n        av_freep(&segment->temporal_offset_entries);\n        av_freep(&segment->flag_entries);\n        return AVERROR(ENOMEM);\n    }\n    for (i = 0; i < segment->nb_index_entries; i++) {\n        if(avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n        segment->temporal_offset_entries[i] = avio_r8(pb);\n        avio_r8(pb);                                        \n        segment->flag_entries[i] = avio_r8(pb);\n        segment->stream_offset_entries[i] = avio_rb64(pb);\n        avio_skip(pb, length - 11);\n    }\n    return 0;\n}", "target": 0}
{"code": "TEE_Result syscall_cipher_init(unsigned long state, const void *iv,\n\t\t\tsize_t iv_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key1;\n\tstruct user_ta_ctx *utc;\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_CIPHER)\n\t\treturn TEE_ERROR_BAD_STATE;\n\tres = tee_mmu_check_access_rights(utc,\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t) iv, iv_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_obj_get(utc, cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\tkey1 = o->attr;\n\tif (tee_obj_get(utc, cs->key2, &o) == TEE_SUCCESS) {\n\t\tstruct tee_cryp_obj_secret *key2 = o->attr;\n\t\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tres = crypto_cipher_init(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t (uint8_t *)(key1 + 1), key1->key_size,\n\t\t\t\t\t (uint8_t *)(key2 + 1), key2->key_size,\n\t\t\t\t\t iv, iv_len);\n\t} else {\n\t\tres = crypto_cipher_init(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t (uint8_t *)(key1 + 1), key1->key_size,\n\t\t\t\t\t NULL, 0, iv, iv_len);\n\t}\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tcs->ctx_finalize = crypto_cipher_final;\n\tcs->state = CRYP_STATE_INITIALIZED;\n\treturn TEE_SUCCESS;\n}", "target": 0}
{"code": "static INLINE UINT16 ntlm_av_pair_get_id(const NTLM_AV_PAIR* pAvPair)\n{\n\tUINT16 AvId;\n\tData_Read_UINT16(&pAvPair->AvId, AvId);\n\treturn AvId;\n}", "target": 1}
{"code": "gen_hash(codegen_scope *s, node *tree, int val, int limit)\n{\n  int slimit = GEN_VAL_STACK_MAX;\n  if (cursp() >= GEN_LIT_ARY_MAX) slimit = INT16_MAX;\n  int len = 0;\n  mrb_bool update = FALSE;\n  while (tree) {\n    if (nint(tree->car->car->car) == NODE_KW_REST_ARGS) {\n      if (len > 0) {\n        pop_n(len*2);\n        if (!update) {\n          genop_2(s, OP_HASH, cursp(), len);\n        }\n        else {\n          pop();\n          genop_2(s, OP_HASHADD, cursp(), len);\n        }\n        push();\n      }\n      codegen(s, tree->car->cdr, val);\n      if (len > 0 || update) {\n        pop(); pop();\n        genop_1(s, OP_HASHCAT, cursp());\n        push();\n      }\n      update = TRUE;\n      len = 0;\n    }\n    else {\n      codegen(s, tree->car->car, val);\n      codegen(s, tree->car->cdr, val);\n      len++;\n    }\n    tree = tree->cdr;\n    if (val && cursp() >= slimit) {\n      pop_n(len*2);\n      if (!update) {\n        genop_2(s, OP_HASH, cursp(), len);\n      }\n      else {\n        pop();\n        genop_2(s, OP_HASHADD, cursp(), len);\n      }\n      push();\n      update = TRUE;\n      len = 0;\n    }\n  }\n  if (update) {\n    if (len > 0) {\n      pop_n(len*2+1);\n      genop_2(s, OP_HASHADD, cursp(), len);\n      push();\n    }\n    return -1;                  \n  }\n  if (update) return -1;\n  return len;\n}", "target": 1}
{"code": "void gf_av1_reset_state(AV1State *state, Bool is_destroy)\n{\n\tGF_List *l1, *l2;\n\tif (state->frame_state.header_obus) {\n\t\twhile (gf_list_count(state->frame_state.header_obus)) {\n\t\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_pop_back(state->frame_state.header_obus);\n\t\t\tif (a->obu) gf_free(a->obu);\n\t\t\tgf_free(a);\n\t\t}\n\t}\n\tif (state->frame_state.frame_obus) {\n\t\twhile (gf_list_count(state->frame_state.frame_obus)) {\n\t\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_pop_back(state->frame_state.frame_obus);\n\t\t\tif (a->obu) gf_free(a->obu);\n\t\t\tgf_free(a);\n\t\t}\n\t}\n\tl1 = state->frame_state.frame_obus;\n\tl2 = state->frame_state.header_obus;\n\tmemset(&state->frame_state, 0, sizeof(AV1StateFrame));\n\tstate->frame_state.is_first_frame = GF_TRUE;\n\tif (is_destroy) {\n\t\tgf_list_del(l1);\n\t\tgf_list_del(l2);\n\t\tif (state->bs) {\n\t\t\tif (gf_bs_get_position(state->bs)) {\n\t\t\t\tu32 size;\n\t\t\t\tgf_bs_get_content_no_truncate(state->bs, &state->frame_obus, &size, &state->frame_obus_alloc);\n\t\t\t}\n\t\t\tgf_bs_del(state->bs);\n\t\t}\n\t\tstate->bs = NULL;\n\t}\n\telse {\n\t\tstate->frame_state.frame_obus = l1;\n\t\tstate->frame_state.header_obus = l2;\n\t\tif (state->bs)\n\t\t\tgf_bs_seek(state->bs, 0);\n\t}\n}", "target": 1}
{"code": "int ossl_dsa_check_params(const DSA *dsa, int checktype, int *ret)\n{\n    if (!dsa_precheck_params(dsa, ret))\n        return 0;\n    if (checktype == OSSL_KEYMGMT_VALIDATE_QUICK_CHECK)\n        return ossl_ffc_params_simple_validate(dsa->libctx, &dsa->params,\n                                               FFC_PARAM_TYPE_DSA, ret);\n    else\n        return ossl_ffc_params_full_validate(dsa->libctx, &dsa->params,\n                                             FFC_PARAM_TYPE_DSA, ret);\n}", "target": 0}
{"code": "WebContents* WebContents::FromRenderViewHost(const RenderViewHost* rvh) {\n  return rvh->GetDelegate()->GetAsWebContents();\n}", "target": 0}
{"code": "x86_reg X86_insn_reg_intel(unsigned int id, enum cs_ac_type *access)\n{\n\tunsigned int first = 0;\n\tunsigned int last = ARR_SIZE(insn_regs_intel) - 1;\n\tunsigned int mid = ARR_SIZE(insn_regs_intel) / 2;\n\tif (!intel_regs_sorted) {\n\t\tmemcpy(insn_regs_intel_sorted, insn_regs_intel,\n\t\t\t\tsizeof(insn_regs_intel_sorted));\n\t\tqsort(insn_regs_intel_sorted,\n\t\t\t\tARR_SIZE(insn_regs_intel_sorted),\n\t\t\t\tsizeof(struct insn_reg), regs_cmp);\n\t\tintel_regs_sorted = true;\n\t}\n\twhile (first <= last) {\n\t\tif (insn_regs_intel_sorted[mid].insn < id) {\n\t\t\tfirst = mid + 1;\n\t\t} else if (insn_regs_intel_sorted[mid].insn == id) {\n\t\t\tif (access) {\n\t\t\t\t*access = insn_regs_intel_sorted[mid].access;\n\t\t\t}\n\t\t\treturn insn_regs_intel_sorted[mid].reg;\n\t\t} else {\n\t\t\tif (mid == 0)\n\t\t\t\tbreak;\n\t\t\tlast = mid - 1;\n\t\t}\n\t\tmid = (first + last) / 2;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static WCHAR* drive_file_combine_fullpath(const WCHAR* base_path, const WCHAR* path,\n                                          size_t PathLength)\n{\n\tWCHAR* fullpath;\n\tsize_t base_path_length;\n\tif (!base_path || (!path && (PathLength > 0)))\n\t\treturn NULL;\n\tbase_path_length = _wcslen(base_path) * 2;\n\tfullpath = (WCHAR*)calloc(1, base_path_length + PathLength + sizeof(WCHAR));\n\tif (!fullpath)\n\t{\n\t\tWLog_ERR(TAG, \"malloc failed!\");\n\t\treturn NULL;\n\t}\n\tCopyMemory(fullpath, base_path, base_path_length);\n\tif (path)\n\t\tCopyMemory((char*)fullpath + base_path_length, path, PathLength);\n\tdrive_file_fix_path(fullpath);\n\treturn fullpath;\n}", "target": 1}
{"code": "static void draw_block_rectangle(uint8_t *buf, int sx, int sy, int w, int h, ptrdiff_t stride, int color)\n{\n    for (int x = sx; x < sx + w; x++)\n        buf[x] = color;\n    for (int y = sy; y < sy + h; y++) {\n        buf[sx] = color;\n        buf[sx + w - 1] = color;\n        buf += stride;\n    }\n    for (int x = sx; x < sx + w; x++)\n        buf[x] = color;\n}", "target": 1}
{"code": "int BUFFER_enlarge(BUFFER_HANDLE handle, size_t enlargeSize)\n{\n    int result;\n    if (handle == NULL)\n    {\n        LogError(\"Failure: handle is invalid.\");\n        result = MU_FAILURE;\n    }\n    else if (enlargeSize == 0)\n    {\n        LogError(\"Failure: enlargeSize size is 0.\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        BUFFER* b = (BUFFER*)handle;\n        unsigned char* temp = (unsigned char*)realloc(b->buffer, b->size + enlargeSize);\n        if (temp == NULL)\n        {\n            LogError(\"Failure: allocating temp buffer.\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            b->buffer = temp;\n            b->size += enlargeSize;\n            result = 0;\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "static void http1_on_data_first_time(intptr_t uuid, fio_protocol_s *protocol) {\n  http1pr_s *p = (http1pr_s *)protocol;\n  ssize_t i;\n  i = fio_read(uuid, p->buf + p->buf_len, HTTP_MAX_HEADER_LENGTH - p->buf_len);\n  if (i <= 0)\n    return;\n  p->buf_len += i;\n  p->p.protocol.on_data = http1_on_data;\n  if (i >= 24 && !memcmp(p->buf, \"PRI * HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\n\", 24)) {\n    FIO_LOG_WARNING(\"client claimed unsupported HTTP/2 prior knowledge.\");\n    fio_close(uuid);\n    return;\n  }\n  http1_consume_data(uuid, p);\n}", "target": 1}
{"code": "static void sctp_process_ext_param(struct sctp_association *asoc,\n\t\t\t\t   union sctp_params param)\n{\n\t__u16 num_ext = ntohs(param.p->length) - sizeof(struct sctp_paramhdr);\n\tstruct net *net = sock_net(asoc->base.sk);\n\tint i;\n\tfor (i = 0; i < num_ext; i++) {\n\t\tswitch (param.ext->chunks[i]) {\n\t\tcase SCTP_CID_RECONF:\n\t\t\tif (asoc->reconf_enable &&\n\t\t\t    !asoc->peer.reconf_capable)\n\t\t\t\tasoc->peer.reconf_capable = 1;\n\t\t\tbreak;\n\t\tcase SCTP_CID_FWD_TSN:\n\t\t\tif (asoc->prsctp_enable && !asoc->peer.prsctp_capable)\n\t\t\t\tasoc->peer.prsctp_capable = 1;\n\t\t\tbreak;\n\t\tcase SCTP_CID_AUTH:\n\t\t\tif (asoc->ep->auth_enable)\n\t\t\t\tasoc->peer.auth_capable = 1;\n\t\t\tbreak;\n\t\tcase SCTP_CID_ASCONF:\n\t\tcase SCTP_CID_ASCONF_ACK:\n\t\t\tif (net->sctp.addip_enable)\n\t\t\t\tasoc->peer.asconf_capable = 1;\n\t\t\tbreak;\n\t\tcase SCTP_CID_I_DATA:\n\t\t\tif (sctp_sk(asoc->base.sk)->strm_interleave)\n\t\t\t\tasoc->intl_enable = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}", "target": 0}
{"code": "void TestDecodeGif(Env* env, DecodeGifTestCase testcase) {\n  string gif;\n  ReadFileToStringOrDie(env, testcase.filepath, &gif);\n  std::unique_ptr<uint8[]> imgdata;\n  int nframes, w, h, c;\n  string error_string;\n  imgdata.reset(gif::Decode(\n      gif.data(), gif.size(),\n      [&](int frame_cnt, int width, int height, int channels) -> uint8* {\n        nframes = frame_cnt;\n        w = width;\n        h = height;\n        c = channels;\n        return new uint8[frame_cnt * height * width * channels];\n      },\n      &error_string));\n  ASSERT_NE(imgdata, nullptr);\n  ASSERT_EQ(nframes, testcase.num_frames);\n  ASSERT_EQ(w, testcase.width);\n  ASSERT_EQ(h, testcase.height);\n  ASSERT_EQ(c, testcase.channels);\n}", "target": 1}
{"code": "void SetClipboardText(const char *text)\n{\n#if defined(PLATFORM_DESKTOP)\n    glfwSetClipboardString(CORE.Window.handle, text);\n#endif\n#if defined(PLATFORM_WEB)\n    emscripten_run_script(TextFormat(\"navigator.clipboard.writeText('%s')\", text));\n#endif\n}", "target": 1}
{"code": "static Jsi_RC jsi_ArrayPopCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    Jsi_Value *v;\n    Jsi_Obj *obj;\n    obj = _this->d.obj;\n    int i = Jsi_ObjGetLength(interp, obj) - 1;\n    if (i < 0) {\n        Jsi_ValueMakeUndef(interp, ret);\n        return JSI_OK;\n    }\n    if (obj->arr) {\n        if ((v = obj->arr[i])) {\n            obj->arr[i] = NULL;\n            obj->arrCnt--;\n        }\n    } else {\n        v = Jsi_ValueArrayIndex(interp, _this, i);\n    }\n    if (v) {\n        Jsi_DecrRefCount(interp, *ret);\n        *ret = v;\n    }\n    Jsi_ObjSetLength(interp, obj, i);\n    return JSI_OK;\n}", "target": 1}
{"code": "inline bool canReadNElements(\n    NimbleProtocolReader& ,\n    uint32_t ,\n    std::initializer_list<detail::nimble::NimbleType> ) {\n  return true;\n}", "target": 0}
{"code": "bool CWalletTx::AcceptWalletTransaction(CTxDB& txdb, bool fCheckInputs)\n{\n    {\n        LOCK(mempool.cs);\n        BOOST_FOREACH(CMerkleTx& tx, vtxPrev)\n        {\n            if (!tx.IsCoinBase())\n            {\n                uint256 hash = tx.GetHash();\n                if (!mempool.exists(hash) && !txdb.ContainsTx(hash))\n                    tx.AcceptToMemoryPool(txdb, fCheckInputs);\n            }\n        }\n        return AcceptToMemoryPool(txdb, fCheckInputs);\n    }\n    return false;\n}", "target": 1}
{"code": "static inline void http1_consume_data(intptr_t uuid, http1pr_s *p) {\n  if (fio_pending(uuid) > 4) {\n    goto throttle;\n  }\n  ssize_t i = 0;\n  size_t org_len = p->buf_len;\n  int pipeline_limit = 8;\n  if (!p->buf_len)\n    return;\n  do {\n    i = http1_fio_parser(.parser = &p->parser,\n                         .buffer = p->buf + (org_len - p->buf_len),\n                         .length = p->buf_len, .on_request = http1_on_request,\n                         .on_response = http1_on_response,\n                         .on_method = http1_on_method,\n                         .on_status = http1_on_status, .on_path = http1_on_path,\n                         .on_query = http1_on_query,\n                         .on_http_version = http1_on_http_version,\n                         .on_header = http1_on_header,\n                         .on_body_chunk = http1_on_body_chunk,\n                         .on_error = http1_on_error);\n    p->buf_len -= i;\n    --pipeline_limit;\n  } while (i && p->buf_len && pipeline_limit && !p->stop);\n  if (p->buf_len && org_len != p->buf_len) {\n    memmove(p->buf, p->buf + (org_len - p->buf_len), p->buf_len);\n  }\n  if (p->buf_len == HTTP_MAX_HEADER_LENGTH) {\n    if (p->request.method)\n      http_send_error(&p->request, 413);\n    else {\n      p->request.method = fiobj_str_tmp();\n      http_send_error(&p->request, 413);\n    }\n  }\n  if (!pipeline_limit) {\n    fio_force_event(uuid, FIO_EVENT_ON_DATA);\n  }\n  return;\nthrottle:\n  fio_suspend(uuid);\n  p->stop |= 4;\n  FIO_LOG_DEBUG(\"(HTTP/1,1) throttling client at %.*s\",\n                (int)fio_peer_addr(uuid).len, fio_peer_addr(uuid).data);\n}", "target": 1}
{"code": "bool HTMLTextAreaElement::hasCustomFocusLogic() const\n{\n    return true;\n}", "target": 0}
{"code": "static int semctl_down(struct ipc_namespace *ns, int semid,\n\t\t       int cmd, int version, void __user *p)\n{\n\tstruct sem_array *sma;\n\tint err;\n\tstruct semid64_ds semid64;\n\tstruct kern_ipc_perm *ipcp;\n\tif(cmd == IPC_SET) {\n\t\tif (copy_semid_from_user(&semid64, p, version))\n\t\t\treturn -EFAULT;\n\t}\n\tipcp = ipcctl_pre_down_nolock(ns, &sem_ids(ns), semid, cmd,\n\t\t\t\t      &semid64.sem_perm, 0);\n\tif (IS_ERR(ipcp))\n\t\treturn PTR_ERR(ipcp);\n\tsma = container_of(ipcp, struct sem_array, sem_perm);\n\terr = security_sem_semctl(sma, cmd);\n\tif (err) {\n\t\trcu_read_unlock();\n\t\tgoto out_unlock;\n\t}\n\tswitch(cmd){\n\tcase IPC_RMID:\n\t\tipc_lock_object(&sma->sem_perm);\n\t\tfreeary(ns, ipcp);\n\t\tgoto out_up;\n\tcase IPC_SET:\n\t\tipc_lock_object(&sma->sem_perm);\n\t\terr = ipc_update_perm(&semid64.sem_perm, ipcp);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t\tsma->sem_ctime = get_seconds();\n\t\tbreak;\n\tdefault:\n\t\trcu_read_unlock();\n\t\terr = -EINVAL;\n\t\tgoto out_up;\n\t}\nout_unlock:\n\tsem_unlock(sma);\nout_up:\n\tup_write(&sem_ids(ns).rw_mutex);\n\treturn err;\n}", "target": 1}
{"code": "static void wdm_in_callback(struct urb *urb)\n{\n\tstruct wdm_device *desc = urb->context;\n\tint status = urb->status;\n\tspin_lock(&desc->iuspin);\n\tclear_bit(WDM_RESPONDING, &desc->flags);\n\tif (status) {\n\t\tswitch (status) {\n\t\tcase -ENOENT:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ENOENT\");\n\t\t\tgoto skip_error;\n\t\tcase -ECONNRESET:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ECONNRESET\");\n\t\t\tgoto skip_error;\n\t\tcase -ESHUTDOWN:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ESHUTDOWN\");\n\t\t\tgoto skip_error;\n\t\tcase -EPIPE:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -EPIPE\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"Unexpected error %d\\n\", status);\n\t\t\tbreak;\n\t\t}\n\t}\n\tdesc->rerr = status;\n\tdesc->reslength = urb->actual_length;\n\tmemmove(desc->ubuf + desc->length, desc->inbuf, desc->reslength);\n\tdesc->length += desc->reslength;\nskip_error:\n\twake_up(&desc->wait);\n\tset_bit(WDM_READ, &desc->flags);\n\tspin_unlock(&desc->iuspin);\n}", "target": 1}
{"code": "static int pppol2tp_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel;\n\tstruct pppol2tp_session *ps;\n\tint val;\n\tint err;\n\tif (level != SOL_PPPOL2TP)\n\t\treturn udp_prot.setsockopt(sk, level, optname, optval, optlen);\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\terr = -ENOTCONN;\n\tif (sk->sk_user_data == NULL)\n\t\tgoto end;\n\terr = -EBADF;\n\tsession = pppol2tp_sock_to_session(sk);\n\tif (session == NULL)\n\t\tgoto end;\n\tps = l2tp_session_priv(session);\n\tif ((session->session_id == 0) &&\n\t    (session->peer_session_id == 0)) {\n\t\terr = -EBADF;\n\t\ttunnel = l2tp_sock_to_tunnel(ps->tunnel_sock);\n\t\tif (tunnel == NULL)\n\t\t\tgoto end_put_sess;\n\t\terr = pppol2tp_tunnel_setsockopt(sk, tunnel, optname, val);\n\t\tsock_put(ps->tunnel_sock);\n\t} else\n\t\terr = pppol2tp_session_setsockopt(sk, session, optname, val);\n\terr = 0;\nend_put_sess:\n\tsock_put(sk);\nend:\n\treturn err;\n}", "target": 1}
{"code": "kg_unseal(minor_status, context_handle, input_token_buffer,\n          message_buffer, conf_state, qop_state, toktype)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    gss_buffer_t input_token_buffer;\n    gss_buffer_t message_buffer;\n    int *conf_state;\n    gss_qop_t *qop_state;\n    int toktype;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    unsigned char *ptr;\n    unsigned int bodysize;\n    int err;\n    int toktype2;\n    int vfyflags = 0;\n    OM_uint32 ret;\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n    if (! ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n    ptr = (unsigned char *) input_token_buffer->value;\n    err = g_verify_token_header(ctx->mech_used,\n                                &bodysize, &ptr, -1,\n                                input_token_buffer->length,\n                                vfyflags);\n    if (err) {\n        *minor_status = err;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n    if (bodysize < 2) {\n        *minor_status = (OM_uint32)G_BAD_TOK_HEADER;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n    toktype2 = load_16_be(ptr);\n    ptr += 2;\n    bodysize -= 2;\n    switch (toktype2) {\n    case KG2_TOK_MIC_MSG:\n    case KG2_TOK_WRAP_MSG:\n    case KG2_TOK_DEL_CTX:\n        ret = gss_krb5int_unseal_token_v3(&ctx->k5_context, minor_status, ctx,\n                                          ptr, bodysize, message_buffer,\n                                          conf_state, qop_state, toktype);\n        break;\n    case KG_TOK_MIC_MSG:\n    case KG_TOK_WRAP_MSG:\n    case KG_TOK_DEL_CTX:\n        ret = kg_unseal_v1(ctx->k5_context, minor_status, ctx, ptr, bodysize,\n                           message_buffer, conf_state, qop_state,\n                           toktype);\n        break;\n    default:\n        *minor_status = (OM_uint32)G_BAD_TOK_HEADER;\n        ret = GSS_S_DEFECTIVE_TOKEN;\n        break;\n    }\n    if (ret != 0)\n        save_error_info (*minor_status, ctx->k5_context);\n    return ret;\n}", "target": 1}
{"code": "PHP_MINFO_FUNCTION(exif)\n{\n\tphp_info_print_table_start();\n\tphp_info_print_table_row(2, \"EXIF Support\", \"enabled\");\n\tphp_info_print_table_row(2, \"Supported EXIF Version\", \"0220\");\n\tphp_info_print_table_row(2, \"Supported filetypes\", \"JPEG, TIFF\");\n\tif (zend_hash_str_exists(&module_registry, \"mbstring\", sizeof(\"mbstring\")-1)) {\n\t\tphp_info_print_table_row(2, \"Multibyte decoding support using mbstring\", \"enabled\");\n\t} else {\n\t\tphp_info_print_table_row(2, \"Multibyte decoding support using mbstring\", \"disabled\");\n\t}\n\tphp_info_print_table_row(2, \"Extended EXIF tag formats\", \"Canon, Casio, Fujifilm, Nikon, Olympus, Samsung, Panasonic, DJI, Sony, Pentax, Minolta, Sigma, Foveon, Kyocera, Ricoh, AGFA, Epson\");\n\tphp_info_print_table_end();\n\tDISPLAY_INI_ENTRIES();\n}", "target": 0}
{"code": "  absl::Status IsSupported(const TfLiteContext* context,\n                           const TfLiteNode* tflite_node,\n                           const TfLiteRegistration* registration) final {\n    RETURN_IF_ERROR(CheckMaxSupportedOpVersion(registration, 3));\n    if (tflite_node->inputs->size != 2) {\n      return absl::UnimplementedError(\"MUL requires two input tensors.\");\n    }\n    auto input0 = tflite::GetInput(context, tflite_node, 0);\n    auto input1 = tflite::GetInput(context, tflite_node, 1);\n    if (input0 == nullptr || input1 == nullptr) {\n      return absl::InvalidArgumentError(\"At least one input tensor is null\");\n    }\n    if (input0->dims->size == input1->dims->size) {\n      bool first_has_smaller_dim = false;\n      bool second_has_smaller_dim = false;\n      for (int i = 0; i < input0->dims->size; ++i) {\n        if (input0->dims->data[i] < input1->dims->data[i]) {\n          first_has_smaller_dim = true;\n        }\n        if (input1->dims->data[i] < input0->dims->data[i]) {\n          second_has_smaller_dim = true;\n        }\n      }\n      if (first_has_smaller_dim && second_has_smaller_dim) {\n        return absl::UnimplementedError(\n            \"MUL requires one tensor that not less than second in all \"\n            \"dimensions.\");\n      }\n    }\n    const TfLiteMulParams* tf_options;\n    RETURN_IF_ERROR(RetrieveBuiltinData(tflite_node, &tf_options));\n    return IsActivationSupported(tf_options->activation);\n  }", "target": 0}
{"code": "static int install_permanent_handler(int num_cpus, uintptr_t smbase,\n\t\t\t\t\tsize_t smsize, size_t save_state_size)\n{\n\tstruct smm_loader_params smm_params = {\n\t\t.per_cpu_stack_size = CONFIG_SMM_MODULE_STACK_SIZE,\n\t\t.num_concurrent_stacks = num_cpus,\n\t\t.per_cpu_save_state_size = save_state_size,\n\t\t.num_concurrent_save_states = num_cpus,\n\t};\n\tif (mp_state.ops.adjust_smm_params != NULL)\n\t\tmp_state.ops.adjust_smm_params(&smm_params, 1);\n\tprintk(BIOS_DEBUG, \"Installing SMM handler to 0x%08lx\\n\", smbase);\n\tif (smm_load_module((void *)smbase, smsize, &smm_params))\n\t\treturn -1;\n\tadjust_smm_apic_id_map(&smm_params);\n\treturn 0;\n}", "target": 1}
{"code": "selaGetCombName(SELA    *sela,\n                l_int32  size,\n                l_int32  direction)\n{\nchar    *selname;\nchar     combname[L_BUF_SIZE];\nl_int32  i, nsels, sx, sy, found;\nSEL     *sel;\n    PROCNAME(\"selaGetCombName\");\n    if (!sela)\n        return (char *)ERROR_PTR(\"sela not defined\", procName, NULL);\n    if (direction != L_HORIZ && direction != L_VERT)\n        return (char *)ERROR_PTR(\"invalid direction\", procName, NULL);\n    if (direction == L_HORIZ)\n        snprintf(combname, L_BUF_SIZE, \"sel_comb_%dh\", size);\n    else  \n        snprintf(combname, L_BUF_SIZE, \"sel_comb_%dv\", size);\n    found = FALSE;\n    nsels = selaGetCount(sela);\n    for (i = 0; i < nsels; i++) {\n        sel = selaGetSel(sela, i);\n        selGetParameters(sel, &sy, &sx, NULL, NULL);\n        if (sy != 1 && sx != 1)  \n            continue;\n        selname = selGetName(sel);\n        if (!strcmp(selname, combname)) {\n            found = TRUE;\n            break;\n        }\n    }\n    if (found)\n        return stringNew(selname);\n    else\n        return (char *)ERROR_PTR(\"sel not found\", procName, NULL);\n}", "target": 1}
{"code": "snmp_oid_copy(uint32_t *dst, uint32_t *src)\n{\n  uint8_t i;\n  i = 0;\n  while(src[i] != ((uint32_t)-1)) {\n    dst[i] = src[i];\n    i++;\n  }\n  dst[i] = src[i];\n}", "target": 1}
{"code": "TRIO_PRIVATE void TrioWriteString TRIO_ARGS5((self, string, flags, width, precision),\n                                             trio_class_t* self, TRIO_CONST char* string,\n                                             trio_flags_t flags, int width, int precision)\n{\n\tint length;\n\tint ch;\n\tassert(VALID(self));\n\tassert(VALID(self->OutStream));\n\tif (string == NULL)\n\t{\n\t\tstring = internalNullString;\n\t\tlength = sizeof(internalNullString) - 1;\n#if TRIO_FEATURE_QUOTE\n\t\tflags &= (~FLAGS_QUOTE);\n#endif\n\t\twidth = 0;\n\t}\n\telse\n\t{\n\t\tif (precision == 0)\n\t\t{\n\t\t\tlength = trio_length(string);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlength = trio_length_max(string, precision);\n\t\t}\n\t}\n\tif ((NO_PRECISION != precision) && (precision < length))\n\t{\n\t\tlength = precision;\n\t}\n\twidth -= length;\n#if TRIO_FEATURE_QUOTE\n\tif (flags & FLAGS_QUOTE)\n\t\tself->OutStream(self, CHAR_QUOTE);\n#endif\n\tif (!(flags & FLAGS_LEFTADJUST))\n\t{\n\t\twhile (width-- > 0)\n\t\t\tself->OutStream(self, CHAR_ADJUST);\n\t}\n\twhile (length-- > 0)\n\t{\n\t\tch = (int)((unsigned char)(*string++));\n\t\tTrioWriteStringCharacter(self, ch, flags);\n\t}\n\tif (flags & FLAGS_LEFTADJUST)\n\t{\n\t\twhile (width-- > 0)\n\t\t\tself->OutStream(self, CHAR_ADJUST);\n\t}\n#if TRIO_FEATURE_QUOTE\n\tif (flags & FLAGS_QUOTE)\n\t\tself->OutStream(self, CHAR_QUOTE);\n#endif\n}", "target": 1}
{"code": "HIDDEN int zlib_compress(struct transaction_t *txn, unsigned flags,\n                         const char *buf, unsigned len)\n{\n    z_stream *zstrm = txn->zstrm;\n    unsigned flush;\n    if (flags & COMPRESS_START) deflateReset(zstrm);\n    if (txn->ws_ctx) flush = Z_SYNC_FLUSH;\n    else {\n        if (flags & COMPRESS_END) flush = Z_FINISH;\n        else flush = Z_NO_FLUSH;\n    }\n    zstrm->next_in = (Bytef *) buf;\n    zstrm->avail_in = len;\n    buf_ensure(&txn->zbuf, deflateBound(zstrm, zstrm->avail_in));\n    buf_reset(&txn->zbuf);\n    do {\n        int zr;\n        if (!zstrm->avail_out) {\n            unsigned pending;\n            zr = deflatePending(zstrm, &pending, Z_NULL);\n            if (zr != Z_OK) {\n                syslog(LOG_ERR, \"zlib deflate error: %d %s\", zr, zstrm->msg);\n                return -1;\n            }\n            buf_ensure(&txn->zbuf, pending);\n        }\n        zstrm->next_out = (Bytef *) txn->zbuf.s + txn->zbuf.len;\n        zstrm->avail_out = txn->zbuf.alloc - txn->zbuf.len;\n        zr = deflate(zstrm, flush);\n        if (!(zr == Z_OK || zr == Z_STREAM_END || zr == Z_BUF_ERROR)) {\n            syslog(LOG_ERR, \"zlib deflate error: %d %s\", zr, zstrm->msg);\n            return -1;\n        }\n        txn->zbuf.len = txn->zbuf.alloc - zstrm->avail_out;\n    } while (!zstrm->avail_out);\n    return 0;\n}", "target": 0}
{"code": "static void dump_usage_categories_info(Formatter *formatter, const rgw_usage_log_entry& entry, map<string, bool> *categories)\n{\n  formatter->open_array_section(\"categories\");\n  map<string, rgw_usage_data>::const_iterator uiter;\n  for (uiter = entry.usage_map.begin(); uiter != entry.usage_map.end(); ++uiter) {\n    if (categories && !categories->empty() && !categories->count(uiter->first))\n      continue;\n    const rgw_usage_data& usage = uiter->second;\n    formatter->open_object_section(\"Entry\");\n    encode_json(\"Category\", uiter->first, formatter);\n    encode_json(\"BytesSent\", usage.bytes_sent, formatter);\n    encode_json(\"BytesReceived\", usage.bytes_received, formatter);\n    encode_json(\"Ops\", usage.ops, formatter);\n    encode_json(\"SuccessfulOps\", usage.successful_ops, formatter);\n    formatter->close_section(); \n  }\n  formatter->close_section(); \n}", "target": 0}
{"code": "static inline void PrefetchPixelCacheNexusPixels(const NexusInfo *nexus_info,\n  const MapMode mode)\n{\n  if (mode == ReadMode)\n    {\n      MagickCachePrefetch((unsigned char *) nexus_info->pixels,0,1);\n      return;\n    }\n  MagickCachePrefetch((unsigned char *) nexus_info->pixels,1,1);\n}", "target": 0}
{"code": "TEST_F(PlaintextRecordTest, TestSkipOversizedRecord) {\n  read_.setSkipEncryptedRecords(true);\n  addToQueue(\"170301fffb\");\n  auto longBuf = IOBuf::create(0xfffb);\n  longBuf->append(0xfffb);\n  queue_.append(std::move(longBuf));\n  EXPECT_FALSE(read_.read(queue_).hasValue());\n  EXPECT_TRUE(queue_.empty());\n}", "target": 0}
{"code": "int nfc_dev_up(struct nfc_dev *dev)\n{\n\tint rc = 0;\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->rfkill && rfkill_blocked(dev->rfkill)) {\n\t\trc = -ERFKILL;\n\t\tgoto error;\n\t}\n\tif (dev->fw_download_in_progress) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (dev->dev_up) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\tif (dev->ops->dev_up)\n\t\trc = dev->ops->dev_up(dev);\n\tif (!rc)\n\t\tdev->dev_up = true;\n\tif (dev->ops->discover_se && dev->ops->discover_se(dev))\n\t\tpr_err(\"SE discovery failed\\n\");\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "static int pvc_getname(struct socket *sock, struct sockaddr *sockaddr,\n\t\t       int *sockaddr_len, int peer)\n{\n\tstruct sockaddr_atmpvc *addr;\n\tstruct atm_vcc *vcc = ATM_SD(sock);\n\tif (!vcc->dev || !test_bit(ATM_VF_ADDR, &vcc->flags))\n\t\treturn -ENOTCONN;\n\t*sockaddr_len = sizeof(struct sockaddr_atmpvc);\n\taddr = (struct sockaddr_atmpvc *)sockaddr;\n\tmemset(addr, 0, sizeof(*addr));\n\taddr->sap_family = AF_ATMPVC;\n\taddr->sap_addr.itf = vcc->dev->number;\n\taddr->sap_addr.vpi = vcc->vpi;\n\taddr->sap_addr.vci = vcc->vci;\n\treturn 0;\n}", "target": 0}
{"code": "  void SetContextState(AudioContext* audio_context,\n                       AudioContext::AudioContextState state) {\n    audio_context->SetContextState(state);\n  }", "target": 0}
{"code": "static u32 gasp_specifier_id(__be32 *p)\n{\n\treturn (be32_to_cpu(p[0]) & 0xffff) << 8 |\n\t       (be32_to_cpu(p[1]) & 0xff000000) >> 24;\n}", "target": 0}
{"code": "\t\tvoid CWebServer::GetFloorplanImage(WebEmSession & session, const request& req, reply & rep)\n\t\t{\n\t\t\tstd::string idx = request::findValue(&req, \"idx\");\n\t\t\tif (idx == \"\") {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstd::vector<std::vector<std::string> > result;\n\t\t\tresult = m_sql.safe_queryBlob(\"SELECT Image FROM Floorplans WHERE ID=%s\", idx.c_str());\n\t\t\tif (result.empty())\n\t\t\t\treturn;\n\t\t\treply::set_content(&rep, result[0][0].begin(), result[0][0].end());\n\t\t\tstd::string oname = \"floorplan\";\n\t\t\tif (result[0][0].size() > 10)\n\t\t\t{\n\t\t\t\tif (result[0][0][0] == 'P')\n\t\t\t\t\toname += \".png\";\n\t\t\t\telse if (result[0][0][0] == -1)\n\t\t\t\t\toname += \".jpg\";\n\t\t\t\telse if (result[0][0][0] == 'B')\n\t\t\t\t\toname += \".bmp\";\n\t\t\t\telse if (result[0][0][0] == 'G')\n\t\t\t\t\toname += \".gif\";\n\t\t\t}\n\t\t\treply::add_header_attachment(&rep, oname);\n\t\t}", "target": 1}
{"code": "static int iax2_provision(struct sockaddr_in *end, int sockfd, char *dest, const char *template, int force)\n{\n\tstruct iax_ie_data provdata;\n\tstruct iax_ie_data ied;\n\tunsigned int sig;\n\tstruct sockaddr_in sin;\n\tint callno;\n\tstruct create_addr_info cai;\n\tmemset(&cai, 0, sizeof(cai));\n\tast_debug(1, \"Provisioning '%s' from template '%s'\\n\", dest, template);\n\tif (iax_provision_build(&provdata, &sig, template, force)) {\n\t\tast_debug(1, \"No provisioning found for template '%s'\\n\", template);\n\t\treturn 0;\n\t}\n\tif (end) {\n\t\tmemcpy(&sin, end, sizeof(sin));\n\t\tcai.sockfd = sockfd;\n\t} else if (create_addr(dest, NULL, &sin, &cai))\n\t\treturn -1;\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_raw(&ied, IAX_IE_PROVISIONING, provdata.buf, provdata.pos);\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (!callno)\n\t\treturn -1;\n\tif (iaxs[callno]) {\n\t\tiaxs[callno]->autoid = iax2_sched_replace(iaxs[callno]->autoid, \n\t\t\tsched, 15000, auto_hangup, (void *)(long)callno);\n\t\tast_set_flag(iaxs[callno], IAX_PROVISION);\n\t\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_PROVISION, 0, ied.buf, ied.pos, -1);\n\t}\n\tast_mutex_unlock(&iaxsl[callno]);\n\treturn 1;\n}", "target": 1}
{"code": "ECDSA_Signature_Operation::raw_sign(const uint8_t msg[], size_t msg_len,\n                                    RandomNumberGenerator& rng)\n   {\n   BigInt m(msg, msg_len, m_group.get_order_bits());\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n   const BigInt k = generate_rfc6979_nonce(m_x, m_group.get_order(), m, m_rfc6979_hash);\n#else\n   const BigInt k = m_group.random_scalar(rng);\n#endif\n   const BigInt k_inv = m_group.inverse_mod_order(k);\n   const BigInt r = m_group.mod_order(\n      m_group.blinded_base_point_multiply_x(k, rng, m_ws));\n   const BigInt xrm = m_group.mod_order(m_group.multiply_mod_order(m_x, r) + m);\n   const BigInt s = m_group.multiply_mod_order(k_inv, xrm);\n   if(r.is_zero() || s.is_zero())\n      throw Internal_Error(\"During ECDSA signature generated zero r/s\");\n   return BigInt::encode_fixed_length_int_pair(r, s, m_group.get_order_bytes());\n   }", "target": 1}
{"code": "static void numtostr(js_State *J, const char *fmt, int w, double n)\n{\n\tchar buf[32], *e;\n\tsprintf(buf, fmt, w, n);\n\te = strchr(buf, 'e');\n\tif (e) {\n\t\tint exp = atoi(e+1);\n\t\tsprintf(e, \"e%+d\", exp);\n\t}\n\tjs_pushstring(J, buf);\n}", "target": 1}
{"code": "static int pagemap_open(struct inode *inode, struct file *file)\n{\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tpr_warn_once(\"Bits 55-60 of /proc/PID/pagemap entries are about \"\n\t\t\t\"to stop being page-shift some time soon. See the \"\n\t\t\t\"linux/Documentation/vm/pagemap.txt for details.\\n\");\n\treturn 0;\n}", "target": 0}
{"code": "sasl_handle_login(struct sasl_session *const restrict p, struct user *const u, struct myuser *mu)\n{\n\tbool was_killed = false;\n\tif (! mu)\n\t{\n\t\tif (! *p->authzeid)\n\t\t{\n\t\t\t(void) slog(LG_INFO, \"%s: session for '%s' without an authzeid (BUG)\",\n\t\t\t                     MOWGLI_FUNC_NAME, u->nick);\n\t\t\t(void) notice(saslsvs->nick, u->nick, LOGIN_CANCELLED_STR);\n\t\t\treturn false;\n\t\t}\n\t\tif (! (mu = myuser_find_uid(p->authzeid)))\n\t\t{\n\t\t\tif (*p->authzid)\n\t\t\t\t(void) notice(saslsvs->nick, u->nick, \"Account %s dropped; login cancelled\",\n\t\t\t\t                                      p->authzid);\n\t\t\telse\n\t\t\t\t(void) notice(saslsvs->nick, u->nick, \"Account dropped; login cancelled\");\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (u->myuser && u->myuser != mu)\n\t{\n\t\tif (is_soper(u->myuser))\n\t\t\t(void) logcommand_user(saslsvs, u, CMDLOG_ADMIN, \"DESOPER: \\2%s\\2 as \\2%s\\2\",\n\t\t\t                                                 u->nick, entity(u->myuser)->name);\n\t\t(void) logcommand_user(saslsvs, u, CMDLOG_LOGIN, \"LOGOUT\");\n\t\tif (! (was_killed = ircd_on_logout(u, entity(u->myuser)->name)))\n\t\t{\n\t\t\tmowgli_node_t *n;\n\t\t\tMOWGLI_ITER_FOREACH(n, u->myuser->logins.head)\n\t\t\t{\n\t\t\t\tif (n->data == u)\n\t\t\t\t{\n\t\t\t\t\t(void) mowgli_node_delete(n, &u->myuser->logins);\n\t\t\t\t\t(void) mowgli_node_free(n);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tu->myuser = NULL;\n\t\t}\n\t}\n\tif (! was_killed)\n\t{\n\t\tif (u->myuser != mu)\n\t\t{\n\t\t\t(void) myuser_login(saslsvs, u, mu, false);\n\t\t\t(void) logcommand_user(saslsvs, u, CMDLOG_LOGIN, \"LOGIN (%s)\", p->mechptr->name);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmu->lastlogin = CURRTIME;\n\t\t\t(void) logcommand_user(saslsvs, u, CMDLOG_LOGIN, \"REAUTHENTICATE (%s)\", p->mechptr->name);\n\t\t}\n\t}\n\treturn true;\n}", "target": 1}
{"code": "void sctp_auth_calculate_hmac(const struct sctp_association *asoc,\n\t\t\t      struct sk_buff *skb,\n\t\t\t      struct sctp_auth_chunk *auth,\n\t\t\t      gfp_t gfp)\n{\n\tstruct scatterlist sg;\n\tstruct hash_desc desc;\n\tstruct sctp_auth_bytes *asoc_key;\n\t__u16 key_id, hmac_id;\n\t__u8 *digest;\n\tunsigned char *end;\n\tint free_key = 0;\n\tkey_id = ntohs(auth->auth_hdr.shkey_id);\n\thmac_id = ntohs(auth->auth_hdr.hmac_id);\n\tif (key_id == asoc->active_key_id)\n\t\tasoc_key = asoc->asoc_shared_key;\n\telse {\n\t\tstruct sctp_shared_key *ep_key;\n\t\tep_key = sctp_auth_get_shkey(asoc, key_id);\n\t\tif (!ep_key)\n\t\t\treturn;\n\t\tasoc_key = sctp_auth_asoc_create_secret(asoc, ep_key, gfp);\n\t\tif (!asoc_key)\n\t\t\treturn;\n\t\tfree_key = 1;\n\t}\n\tend = skb_tail_pointer(skb);\n\tsg_init_one(&sg, auth, end - (unsigned char *)auth);\n\tdesc.tfm = asoc->ep->auth_hmacs[hmac_id];\n\tdesc.flags = 0;\n\tdigest = auth->auth_hdr.hmac;\n\tif (crypto_hash_setkey(desc.tfm, &asoc_key->data[0], asoc_key->len))\n\t\tgoto free;\n\tcrypto_hash_digest(&desc, &sg, sg.length, digest);\nfree:\n\tif (free_key)\n\t\tsctp_auth_key_put(asoc_key);\n}", "target": 0}
{"code": "parse_device(dev_t *pdev, struct archive *a, char *val)\n{\n#define MAX_PACK_ARGS 3\n\tunsigned long numbers[MAX_PACK_ARGS];\n\tchar *p, *dev;\n\tint argc;\n\tpack_t *pack;\n\tdev_t result;\n\tconst char *error = NULL;\n\tmemset(pdev, 0, sizeof(*pdev));\n\tif ((dev = strchr(val, ',')) != NULL) {\n\t\t*dev++ = '\\0';\n\t\tif ((pack = pack_find(val)) == NULL) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Unknown format `%s'\", val);\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t\targc = 0;\n\t\twhile ((p = la_strsep(&dev, \",\")) != NULL) {\n\t\t\tif (*p == '\\0') {\n\t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Missing number\");\n\t\t\t\treturn ARCHIVE_WARN;\n\t\t\t}\n\t\t\tnumbers[argc++] = (unsigned long)mtree_atol(&p);\n\t\t\tif (argc > MAX_PACK_ARGS) {\n\t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Too many arguments\");\n\t\t\t\treturn ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t\tif (argc < 2) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Not enough arguments\");\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t\tresult = (*pack)(argc, numbers, &error);\n\t\tif (error != NULL) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"%s\", error);\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t} else {\n\t\tresult = (dev_t)mtree_atol(&val);\n\t}\n\t*pdev = result;\n\treturn ARCHIVE_OK;\n#undef MAX_PACK_ARGS\n}", "target": 1}
{"code": "TfLiteStatus EvalSimple(TfLiteContext* context, TfLiteNode* node,\n                        const TfLiteTensor* lookup, const TfLiteTensor* value,\n                        TfLiteTensor* output) {\n  const int row_size = SizeOfDimension(value, 0);\n  if (row_size == 0) {\n    return kTfLiteOk;\n  }\n  const int row_bytes = value->bytes / row_size;\n  char* output_raw = GetTensorData<char>(output);\n  const char* value_raw = GetTensorData<char>(value);\n  const int32_t* lookup_data = GetTensorData<int32_t>(lookup);\n  for (int i = 0; i < SizeOfDimension(lookup, 0); i++) {\n    int idx = lookup_data[i];\n    if (idx >= row_size || idx < 0) {\n      context->ReportError(context,\n                           \"Embedding Lookup: index out of bounds. \"\n                           \"Got %d, and bounds are [0, %d]\",\n                           idx, row_size - 1);\n      return kTfLiteError;\n    } else {\n      std::memcpy(output_raw + i * row_bytes, value_raw + idx * row_bytes,\n                  row_bytes);\n    }\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "void svhandler_flash_pgm_blk(void) {\n  uint32_t beginAddr = _param_1;\n  uint32_t data = _param_2;\n  uint32_t length = _param_3;\n  if (beginAddr + length < beginAddr) return;\n  if (((beginAddr >= BSTRP_FLASH_SECT_START) &&\n       (beginAddr <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN - 1))) ||\n      (((beginAddr + length) >= BSTRP_FLASH_SECT_START) &&\n       ((beginAddr + length) <=\n        (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN - 1)))) {\n    return;\n  }\n  if (((beginAddr >= BLDR_FLASH_SECT_START) &&\n       (beginAddr <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN - 1))) ||\n      (((beginAddr + length) >= BLDR_FLASH_SECT_START) &&\n       ((beginAddr + length) <=\n        (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN - 1)))) {\n    return;\n  }\n  flash_clear_status_flags();\n  flash_unlock();\n  flash_program(beginAddr, (uint8_t *)data, length);\n  _param_1 = !!flash_chk_status();\n  _param_2 = 0;\n  _param_3 = 0;\n  flash_wait_for_last_operation();\n  FLASH_CR &= ~FLASH_CR_PG;\n  FLASH_CR |= FLASH_CR_LOCK;\n}", "target": 1}
{"code": "bool DevToolsDownloadManagerDelegate::ShouldOpenDownload(\n    content::DownloadItem* item,\n    const content::DownloadOpenDelayedCallback& callback) {\n  DevToolsDownloadManagerHelper* download_helper =\n      DevToolsDownloadManagerHelper::FromWebContents(item->GetWebContents());\n  if (download_helper)\n    return true;\n  if (proxy_download_delegate_)\n    return proxy_download_delegate_->ShouldOpenDownload(item, callback);\n  return false;\n}", "target": 0}
{"code": "static u64 vmx_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)\n{\n\tu64 tsc_offset;\n\ttsc_offset = is_guest_mode(vcpu) ?\n\t\tto_vmx(vcpu)->nested.vmcs01_tsc_offset :\n\t\tvmcs_read64(TSC_OFFSET);\n\treturn host_tsc + tsc_offset;\n}", "target": 0}
{"code": "string handleGet(map<string, string>* reqHeaders) {\n  long long sessionId = -1;\n  long uid = -1;\n  string uri = (*reqHeaders)[\"uri\"];\n  string body;\n  if (reqHeaders->count(\"Cookie\") != 0) {\n    string cookies = (*reqHeaders)[\"Cookie\"];\n    string sessionIdString = cookies.substr(cookies.find(\"=\") + 1);\n    sessionId = stoll(sessionIdString, nullptr);\n    auto usersessionIt = sessionMap.find(sessionId);\n    if (usersessionIt == sessionMap.end()){\n      cout << \"Bad session ID, redirecting to login.\" << endl;\n      body = getLogin();\n    } else\n      uid = sessionMap[sessionId];\n  }\n  map<string, string> resHeaders;\n  resHeaders[\"Server\"] = \"CSE461\";\n  resHeaders[\"Content-Type\"] = \"text/html; charset=UTF-8\";\n  if (uri.compare(\"/cal\") == 0 && uid == -1) {\n    cout << \"login page\" << endl;\n    body = getLogin();\n  } else if (uri.compare(\"/cal\") == 0 && uid != -1) {\n    cout << \"cal page\" << endl;\n    string username = userNameById(uid);\n    body = getHeader(username);\n    body += getEmptyCalendar();\n    body += getFooter();\n  } else if (uri.compare(\"/getEvents\") == 0 && uid != -1) {\n    body = getEventsJson(uid);\n    resHeaders[\"Content-Type\"] = \"application/json; charset=UTF-8\";\n  } else {\n    cout << \"error page\" << endl;\n    string message = \"404 Page Not Found\";\n    return getResponseHeader(\"HTTP/1.1 404 Not Found\", &resHeaders, body.size())\n      + \"\\r\\n\" + message;\n  }\n  return getResponseHeader(\"HTTP/1.1 200 OK\", &resHeaders, body.size()) + \"\\r\\n\" + body;\n}", "target": 1}
{"code": "MOBI_RET mobi_find_attrvalue(MOBIResult *result, const unsigned char *data_start, const unsigned char *data_end, const MOBIFiletype type, const char *needle) {\n    if (!result) {\n        debug_print(\"Result structure is null%s\", \"\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    result->start = result->end = NULL;\n    *(result->value) = '\\0';\n    if (!data_start || !data_end) {\n        debug_print(\"Data is null%s\", \"\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    size_t needle_length = strlen(needle);\n    if (needle_length > MOBI_ATTRNAME_MAXSIZE) {\n        debug_print(\"Attribute too long: %zu\\n\", needle_length);\n        return MOBI_PARAM_ERR;\n    }\n    if (data_start + needle_length > data_end) {\n        return MOBI_SUCCESS;\n    }\n    unsigned char *data = (unsigned char *) data_start;\n    unsigned char tag_open;\n    unsigned char tag_close;\n    if (type == T_CSS) {\n        tag_open = '{';\n        tag_close = '}';\n    } else {\n        tag_open = '<';\n        tag_close = '>';\n    }\n    unsigned char last_border = tag_close;\n    while (data <= data_end) {\n        if (*data == tag_open || *data == tag_close) {\n            last_border = *data;\n        }\n        if (data + needle_length <= data_end && memcmp(data, needle, needle_length) == 0) {\n            if (last_border != tag_open) {\n                data += needle_length;\n                continue;\n            }\n            while (data >= data_start && !isspace(*data) && *data != tag_open && *data != '=' && *data != '(') {\n                data--;\n            }\n            result->is_url = (*data == '(');\n            result->start = ++data;\n            int i = 0;\n            while (data <= data_end && !isspace(*data) && *data != tag_close && *data != ')' && i < MOBI_ATTRVALUE_MAXSIZE) {\n                result->value[i++] = (char) *data++;\n            }\n            if (*(data - 1) == '/' && *data == '>') {\n                --data; --i;\n            }\n            result->end = data;\n            result->value[i] = '\\0';\n            return MOBI_SUCCESS;\n        }\n        data++;\n    }\n    return MOBI_SUCCESS;\n}", "target": 1}
{"code": "TEST(BasicFlatBufferModel, TestHandleMalformedModel) {\n  const auto model_paths = {\n      \"tensorflow/lite/testdata/add_shared_tensors.bin\",\n  };\n  for (const auto& model_path : model_paths) {\n    std::unique_ptr<tflite::FlatBufferModel> model =\n        FlatBufferModel::BuildFromFile(model_path);\n    ASSERT_NE(model, nullptr);\n    tflite::ops::builtin::BuiltinOpResolver resolver;\n    InterpreterBuilder builder(*model, resolver);\n    std::unique_ptr<Interpreter> interpreter;\n    ASSERT_EQ(builder(&interpreter), kTfLiteOk);\n    ASSERT_NE(interpreter, nullptr);\n    ASSERT_NE(interpreter->AllocateTensors(), kTfLiteOk);\n  }\n}", "target": 0}
{"code": "WifiNetwork::WifiNetwork(const ServiceInfo* service)\n    : WirelessNetwork(service) {\n  encryption_ = service->security;\n  passphrase_ = SafeString(service->passphrase);\n  identity_ = SafeString(service->identity);\n  cert_path_ = SafeString(service->cert_path);\n  type_ = TYPE_WIFI;\n}", "target": 0}
{"code": "LogicalSize NGColumnLayoutAlgorithm::CalculateColumnSize(\n    const LogicalSize& content_box_size) {\n  LogicalSize column_size = content_box_size;\n  DCHECK_GE(column_size.inline_size, LayoutUnit());\n  column_size.inline_size =\n      ResolveUsedColumnInlineSize(column_size.inline_size, Style());\n  if (NeedsColumnBalancing(column_size.block_size, Style())) {\n    int used_count =\n        ResolveUsedColumnCount(content_box_size.inline_size, Style());\n    column_size.block_size =\n        CalculateBalancedColumnBlockSize(column_size, used_count);\n  }\n  return column_size;\n}", "target": 0}
{"code": "static void vmclear_local_loaded_vmcss(void)\n{\n\tint cpu = raw_smp_processor_id();\n\tstruct loaded_vmcs *v, *n;\n\tlist_for_each_entry_safe(v, n, &per_cpu(loaded_vmcss_on_cpu, cpu),\n\t\t\t\t loaded_vmcss_on_cpu_link)\n\t\t__loaded_vmcs_clear(v);\n}", "target": 0}
{"code": "static int klsi_105_get_line_state(struct usb_serial_port *port,\n\t\t\t\t   unsigned long *line_state_p)\n{\n\tint rc;\n\tu8 *status_buf;\n\t__u16 status;\n\tdev_info(&port->serial->dev->dev, \"sending SIO Poll request\\n\");\n\tstatus_buf = kmalloc(KLSI_STATUSBUF_LEN, GFP_KERNEL);\n\tif (!status_buf)\n\t\treturn -ENOMEM;\n\tstatus_buf[0] = 0xff;\n\tstatus_buf[1] = 0xff;\n\trc = usb_control_msg(port->serial->dev,\n\t\t\t     usb_rcvctrlpipe(port->serial->dev, 0),\n\t\t\t     KL5KUSB105A_SIO_POLL,\n\t\t\t     USB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t     0, \n\t\t\t     0, \n\t\t\t     status_buf, KLSI_STATUSBUF_LEN,\n\t\t\t     10000\n\t\t\t     );\n\tif (rc < 0)\n\t\tdev_err(&port->dev, \"Reading line status failed (error = %d)\\n\",\n\t\t\trc);\n\telse {\n\t\tstatus = get_unaligned_le16(status_buf);\n\t\tdev_info(&port->serial->dev->dev, \"read status %x %x\\n\",\n\t\t\t status_buf[0], status_buf[1]);\n\t\t*line_state_p = klsi_105_status2linestate(status);\n\t}\n\tkfree(status_buf);\n\treturn rc;\n}", "target": 1}
{"code": "cmsUInt8Number Word2Byte(cmsUInt16Number w)\n{\n    return (cmsUInt8Number) floor((cmsFloat64Number) w / 257.0 + 0.5);\n}", "target": 0}
{"code": "void CSecurityTLS::shutdown(bool needbye)\n{\n  if (session && needbye)\n    if (gnutls_bye(session, GNUTLS_SHUT_RDWR) != GNUTLS_E_SUCCESS)\n      vlog.error(\"gnutls_bye failed\");\n  if (anon_cred) {\n    gnutls_anon_free_client_credentials(anon_cred);\n    anon_cred = 0;\n  }\n  if (cert_cred) {\n    gnutls_certificate_free_credentials(cert_cred);\n    cert_cred = 0;\n  }\n  if (session) {\n    gnutls_deinit(session);\n    session = 0;\n    gnutls_global_deinit();\n  }\n}", "target": 1}
{"code": "PJ_DEF(void) pj_scan_get_n( pj_scanner *scanner,\n\t\t\t    unsigned N, pj_str_t *out)\n{\n    if (scanner->curptr + N > scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    pj_strset(out, scanner->curptr, N);\n    scanner->curptr += N;\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*scanner->curptr) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}", "target": 1}
{"code": "int enc_untrusted_inet_pton(int af, const char *src, void *dst) {\n  if (!src || !dst) {\n    return 0;\n  }\n  MessageWriter input;\n  input.Push<int>(TokLinuxAfFamily(af));\n  input.PushByReference(Extent{\n      src, std::min(strlen(src) + 1, static_cast<size_t>(INET6_ADDRSTRLEN))});\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kInetPtonHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_inet_pton\", 3);\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return -1;\n  }\n  auto klinux_addr_buffer = output.next();\n  size_t max_size = 0;\n  if (af == AF_INET) {\n    if (klinux_addr_buffer.size() != sizeof(klinux_in_addr)) {\n      ::asylo::primitives::TrustedPrimitives::BestEffortAbort(\n          \"enc_untrusted_inet_pton: unexpected output size\");\n    }\n    max_size = sizeof(struct in_addr);\n  } else if (af == AF_INET6) {\n    if (klinux_addr_buffer.size() != sizeof(klinux_in6_addr)) {\n      ::asylo::primitives::TrustedPrimitives::BestEffortAbort(\n          \"enc_untrusted_inet_pton: unexpected output size\");\n    }\n    max_size = sizeof(struct in6_addr);\n  }\n  memcpy(dst, klinux_addr_buffer.data(),\n         std::min(klinux_addr_buffer.size(), max_size));\n  return result;\n}", "target": 0}
{"code": "static inline int may_ptrace_stop(void)\n{\n\tif (!likely(current->ptrace))\n\t\treturn 0;\n\tif (unlikely(current->mm->core_state) &&\n\t    unlikely(current->mm == current->parent->mm))\n\t\treturn 0;\n\treturn 1;\n}", "target": 0}
{"code": "is_blank_line(char *line, int indent)\n{\n    int i, is_blank = 0;\n    for (i = 0; i < indent; i++) {\n\tif (line[i] == '\\0') {\n\t    is_blank = 1;\n\t}\n\telse if (line[i] != ' ') {\n\t    break;\n\t}\n    }\n    if (i == indent && line[i] == '\\0')\n\tis_blank = 1;\n    return is_blank;\n}", "target": 0}
{"code": "uint64_t siphash(const uint8_t *in, const size_t inlen, const uint8_t *k) {\n    uint64_t hash;\n    uint8_t *out = (uint8_t*) &hash;\n    uint64_t v0 = 0x736f6d6570736575ULL;\n    uint64_t v1 = 0x646f72616e646f6dULL;\n    uint64_t v2 = 0x6c7967656e657261ULL;\n    uint64_t v3 = 0x7465646279746573ULL;\n    uint64_t k0 = U8TO64_LE(k);\n    uint64_t k1 = U8TO64_LE(k + 8);\n    uint64_t m;\n    const uint8_t *end = in + inlen - (inlen % sizeof(uint64_t));\n    const int left = inlen & 7;\n    uint64_t b = ((uint64_t)inlen) << 56;\n    v3 ^= k1;\n    v2 ^= k0;\n    v1 ^= k1;\n    v0 ^= k0;\n    for (; in != end; in += 8) {\n        m = U8TO64_LE(in);\n        v3 ^= m;\n        SIPROUND;\n        SIPROUND;\n        v0 ^= m;\n    }\n    switch (left) {\n    case 7: b |= ((uint64_t)in[6]) << 48;\n    case 6: b |= ((uint64_t)in[5]) << 40;\n    case 5: b |= ((uint64_t)in[4]) << 32;\n    case 4: b |= ((uint64_t)in[3]) << 24;\n    case 3: b |= ((uint64_t)in[2]) << 16;\n    case 2: b |= ((uint64_t)in[1]) << 8;\n    case 1: b |= ((uint64_t)in[0]); break;\n    case 0: break;\n    }\n    v3 ^= b;\n    SIPROUND;\n    SIPROUND;\n    v0 ^= b;\n    v2 ^= 0xff;\n    SIPROUND;\n    SIPROUND;\n    SIPROUND;\n    SIPROUND;\n    b = v0 ^ v1 ^ v2 ^ v3;\n    U64TO8_LE(out, b);\n    return hash;\n}", "target": 0}
{"code": "static void nested_svm_uninit_mmu_context(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.walk_mmu = &vcpu->arch.mmu;\n}", "target": 0}
{"code": "void test_refs_revparse__parses_at_head(void)\n{\n\ttest_id(\"HEAD\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", NULL, GIT_REVSPEC_SINGLE);\n\ttest_id(\"@{0}\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", NULL, GIT_REVSPEC_SINGLE);\n\ttest_id(\"@\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", NULL, GIT_REVSPEC_SINGLE);\n}", "target": 0}
{"code": "static void recovery_abort(void) {\n    if (!dry_run) {\n        storage_reset();\n    }\n    recovery_started = false;\n    awaiting_character = false;\n    memzero(mnemonic, sizeof(mnemonic));\n    memzero(cipher, sizeof(cipher));\n}", "target": 0}
{"code": "ossl_cipher_set_key(VALUE self, VALUE key)\n{\n    EVP_CIPHER_CTX *ctx;\n    int key_len;\n    StringValue(key);\n    GetCipher(self, ctx);\n    key_len = EVP_CIPHER_CTX_key_length(ctx);\n    if (RSTRING_LEN(key) != key_len)\n\tossl_raise(rb_eArgError, \"key must be %d bytes\", key_len);\n    if (EVP_CipherInit_ex(ctx, NULL, NULL, (unsigned char *)RSTRING_PTR(key), NULL, -1) != 1)\n\tossl_raise(eCipherError, NULL);\n    rb_ivar_set(self, id_key_set, Qtrue);\n    return key;\n}", "target": 0}
{"code": "static void __net_exit pfkey_net_exit(struct net *net)\n{\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\tpfkey_exit_proc(net);\n\tWARN_ON(!hlist_empty(&net_pfkey->table));\n}", "target": 0}
{"code": "ikev1_ke_print(netdissect_options *ndo, u_char tpay _U_,\n\t       const struct isakmp_gen *ext, u_int item_len _U_,\n\t       const u_char *ep _U_, uint32_t phase _U_, uint32_t doi _U_,\n\t       uint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_KE)));\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" key len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_KE)));\n\treturn NULL;\n}", "target": 0}
{"code": "static bool pmc_overflow(unsigned long val)\n{\n\tif ((int)val < 0)\n\t\treturn true;\n\tif (__is_processor(PV_POWER7) && ((0x80000000 - val) <= 256))\n\t\treturn true;\n\treturn false;\n}", "target": 0}
{"code": "void Document::ImplicitClose() {\n  DCHECK(!InStyleRecalc());\n  DCHECK(parser_);\n  load_event_progress_ = kLoadEventInProgress;\n  DetachParser();\n  if (SvgExtensions())\n    AccessSVGExtensions().DispatchSVGLoadEventToOutermostSVGElements();\n  if (domWindow())\n    domWindow()->DocumentWasClosed();\n  if (GetFrame()) {\n    GetFrame()->Client()->DispatchDidHandleOnloadEvents();\n    Loader()->GetApplicationCacheHost()->StopDeferringEvents();\n  }\n  if (!GetFrame()) {\n    load_event_progress_ = kLoadEventCompleted;\n    return;\n  }\n  if (GetFrame()->GetNavigationScheduler().LocationChangePending() &&\n      ElapsedTime() < kCLayoutScheduleThreshold) {\n    load_event_progress_ = kLoadEventCompleted;\n    return;\n  }\n  if (!LocalOwner() || (LocalOwner()->GetLayoutObject() &&\n                        !LocalOwner()->GetLayoutObject()->NeedsLayout())) {\n    UpdateStyleAndLayoutTree();\n    if (View() && !GetLayoutViewItem().IsNull() &&\n        (!GetLayoutViewItem().FirstChild() ||\n         GetLayoutViewItem().NeedsLayout()))\n      View()->UpdateLayout();\n  }\n  load_event_progress_ = kLoadEventCompleted;\n  if (GetFrame() && !GetLayoutViewItem().IsNull() &&\n      GetSettings()->GetAccessibilityEnabled()) {\n    if (AXObjectCache* cache = GetOrCreateAXObjectCache()) {\n      if (this == &AXObjectCacheOwner())\n        cache->HandleLoadComplete(this);\n      else\n        cache->HandleLayoutComplete(this);\n    }\n  }\n  if (SvgExtensions())\n    AccessSVGExtensions().StartAnimations();\n}", "target": 0}
{"code": "void PeerListWidget::updatePeer(const QString &ip, BitTorrent::TorrentHandle *const torrent, const BitTorrent::PeerInfo &peer)\n{\n    QStandardItem *item = m_peerItems.value(ip);\n    int row = item->row();\n    if (m_resolveCountries) {\n        const QIcon ico = GuiIconProvider::instance()->getFlagIcon(peer.country());\n        if (!ico.isNull()) {\n            m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), ico, Qt::DecorationRole);\n            const QString countryName = Net::GeoIPManager::CountryName(peer.country());\n            m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), countryName, Qt::ToolTipRole);\n            m_missingFlags.remove(ip);\n        }\n    }\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CONNECTION), peer.connectionType());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::PORT), peer.address().port);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flags());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flagsDescription(), Qt::ToolTipRole);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CLIENT), peer.client());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::PROGRESS), peer.progress());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWN_SPEED), peer.payloadDownSpeed());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::UP_SPEED), peer.payloadUpSpeed());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_DOWN), peer.totalDownload());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_UP), peer.totalUpload());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::RELEVANCE), peer.relevance());\n    QStringList downloadingFiles(torrent->info().filesForPiece(peer.downloadingPieceIndex()));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(\";\")));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(\"\\n\")), Qt::ToolTipRole);\n}", "target": 1}
{"code": "static int filter_frame(AVFilterLink *inlink, AVFrame *in)\n{\n    PadContext *s = inlink->dst->priv;\n    AVFrame *out;\n    int needs_copy = frame_needs_copy(s, in);\n    if (needs_copy) {\n        av_log(inlink->dst, AV_LOG_DEBUG, \"Direct padding impossible allocating new frame\\n\");\n        out = ff_get_video_buffer(inlink->dst->outputs[0],\n                                  FFMAX(inlink->w, s->w),\n                                  FFMAX(inlink->h, s->h));\n        if (!out) {\n            av_frame_free(&in);\n            return AVERROR(ENOMEM);\n        }\n        av_frame_copy_props(out, in);\n    } else {\n        int i;\n        out = in;\n        for (i = 0; i < 4 && out->data[i]; i++) {\n            int hsub = s->draw.hsub[i];\n            int vsub = s->draw.vsub[i];\n            out->data[i] -= (s->x >> hsub) * s->draw.pixelstep[i] +\n                            (s->y >> vsub) * out->linesize[i];\n        }\n    }\n    if (s->y) {\n        ff_fill_rectangle(&s->draw, &s->color,\n                          out->data, out->linesize,\n                          0, 0, s->w, s->y);\n    }\n    if (s->h > s->y + s->in_h) {\n        ff_fill_rectangle(&s->draw, &s->color,\n                          out->data, out->linesize,\n                          0, s->y + s->in_h, s->w, s->h - s->y - s->in_h);\n    }\n    ff_fill_rectangle(&s->draw, &s->color, out->data, out->linesize,\n                      0, s->y, s->x, in->height);\n    if (needs_copy) {\n        ff_copy_rectangle2(&s->draw,\n                          out->data, out->linesize, in->data, in->linesize,\n                          s->x, s->y, 0, 0, in->width, in->height);\n    }\n    ff_fill_rectangle(&s->draw, &s->color, out->data, out->linesize,\n                      s->x + s->in_w, s->y, s->w - s->x - s->in_w,\n                      in->height);\n    out->width  = s->w;\n    out->height = s->h;\n    if (in != out)\n        av_frame_free(&in);\n    return ff_filter_frame(inlink->dst->outputs[0], out);\n}", "target": 1}
{"code": "void mp_encode_lua_table_as_map(lua_State *L, mp_buf *buf, int level) {\n    size_t len = 0;\n    luaL_checkstack(L, 3, \"in function mp_encode_lua_table_as_map\");\n    lua_pushnil(L);\n    while(lua_next(L,-2)) {\n        lua_pop(L,1); \n        len++;\n    }\n    mp_encode_map(L,buf,len);\n    lua_pushnil(L);\n    while(lua_next(L,-2)) {\n        lua_pushvalue(L,-2); \n        mp_encode_lua_type(L,buf,level+1); \n        mp_encode_lua_type(L,buf,level+1); \n    }\n}", "target": 0}
{"code": "server_request_direct_streamlocal(void)\n{\n\tChannel *c = NULL;\n\tchar *target, *originator;\n\tu_short originator_port;\n\ttarget = packet_get_string(NULL);\n\toriginator = packet_get_string(NULL);\n\toriginator_port = packet_get_int();\n\tpacket_check_eom();\n\tdebug(\"server_request_direct_streamlocal: originator %s port %d, target %s\",\n\t    originator, originator_port, target);\n\tif ((options.allow_streamlocal_forwarding & FORWARD_LOCAL) != 0 &&\n\t    !no_port_forwarding_flag && !options.disable_forwarding) {\n\t\tc = channel_connect_to_path(target,\n\t\t    \"direct-streamlocal@openssh.com\", \"direct-streamlocal\");\n\t} else {\n\t\tlogit(\"refused streamlocal port forward: \"\n\t\t    \"originator %s port %d, target %s\",\n\t\t    originator, originator_port, target);\n\t}\n\tfree(originator);\n\tfree(target);\n\treturn c;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    if (input.dims() > 0) {\n      OP_REQUIRES(\n          context, input.dim_size(0) != 0,\n          errors::InvalidArgument(\"Invalid input first dimension. Found 0.\"));\n    }\n    const Tensor& dims = context->input(1);\n    if (TensorShapeUtils::IsScalar(input.shape())) {\n      context->set_output(0, input);\n    } else {\n      const int input_dims = input.dims();\n      OP_REQUIRES(context, TensorShapeUtils::IsVector(dims.shape()),\n                  errors::InvalidArgument(\"'dims' must be 1-dimension, not \",\n                                          dims.dims()));\n      OP_REQUIRES(\n          context, input_dims == dims.dim_size(0),\n          errors::InvalidArgument(\n              \"'dims' must have the same number of values as 'input' has \"\n              \"dimensions. 'input' has \",\n              input_dims, \"'dims' has \", dims.dim_size(0), \" values\"));\n      OP_REQUIRES(context, input_dims <= 8,\n                  errors::Unimplemented(\n                      \"reverse is not implemented for tensors of rank > 8.\"));\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK(context,\n                     context->allocate_output(0, input.shape(), &output));\n#define HANDLE_REVERSE(NDIMS)                                               \\\n  case NDIMS:                                                               \\\n    HandleReverseCase<Device, T, NDIMS>(context, dims.vec<bool>(), output); \\\n    return;\n      switch (input_dims) {\n        HANDLE_REVERSE(0);\n        HANDLE_REVERSE(1);\n        HANDLE_REVERSE(2);\n        HANDLE_REVERSE(3);\n        HANDLE_REVERSE(4);\n        HANDLE_REVERSE(5);\n        HANDLE_REVERSE(6);\n        HANDLE_REVERSE(7);\n        HANDLE_REVERSE(8);\n      }\n#undef HANDLE_REVERSE\n    }\n  }", "target": 0}
{"code": "void ax25_disconnect(ax25_cb *ax25, int reason)\n{\n\tax25_clear_queues(ax25);\n\tif (!ax25->sk || !sock_flag(ax25->sk, SOCK_DESTROY))\n\t\tax25_stop_heartbeat(ax25);\n\tax25_stop_t1timer(ax25);\n\tax25_stop_t2timer(ax25);\n\tax25_stop_t3timer(ax25);\n\tax25_stop_idletimer(ax25);\n\tax25->state = AX25_STATE_0;\n\tax25_link_failed(ax25, reason);\n\tif (ax25->sk != NULL) {\n\t\tlocal_bh_disable();\n\t\tbh_lock_sock(ax25->sk);\n\t\tax25->sk->sk_state     = TCP_CLOSE;\n\t\tax25->sk->sk_err       = reason;\n\t\tax25->sk->sk_shutdown |= SEND_SHUTDOWN;\n\t\tif (!sock_flag(ax25->sk, SOCK_DEAD)) {\n\t\t\tax25->sk->sk_state_change(ax25->sk);\n\t\t\tsock_set_flag(ax25->sk, SOCK_DEAD);\n\t\t}\n\t\tbh_unlock_sock(ax25->sk);\n\t\tlocal_bh_enable();\n\t}\n}", "target": 1}
{"code": "static void jsiDumpInstr(Jsi_Interp *interp, jsi_Pstate *ps, Jsi_Value *_this,\n    jsi_TryList *trylist, jsi_OpCode *ip, Jsi_OpCodes *opcodes)\n{\n    int i;\n    char buf[200];\n    jsi_code_decode(interp, ip, ip - opcodes->codes, buf, sizeof(buf));\n    Jsi_Printf(interp, jsi_Stderr, \"%p: %-30.200s : THIS=%s, STACK=[\", ip, buf, jsi_evalprint(_this));\n    for (i = 0; i < interp->framePtr->Sp; ++i) {\n        Jsi_Printf(interp, jsi_Stderr, \"%s%s\", (i>0?\", \":\"\"), jsi_evalprint(_jsi_STACKIDX(i)));\n    }\n    Jsi_Printf(interp, jsi_Stderr, \"]\");\n    if (ip->fname) {\n        const char *fn = ip->fname,  *cp = Jsi_Strrchr(fn, '/');\n        if (cp) fn = cp+1;\n        Jsi_Printf(interp, jsi_Stderr, \", %s:%d\", fn, ip->Line);\n    }\n    Jsi_Printf(interp, jsi_Stderr, \"\\n\");\n    jsi_TryList *tlt = trylist;\n    for (i = 0; tlt; tlt = tlt->next) i++;\n    if (ps->last_exception)\n        Jsi_Printf(interp, jsi_Stderr, \"TL: %d, excpt: %s\\n\", i, jsi_evalprint(ps->last_exception));\n}", "target": 1}
{"code": "static void r_bin_dwarf_dump_debug_info(FILE *f, const RBinDwarfDebugInfo *inf) {\n\tsize_t i, j, k;\n\tRBinDwarfDIE *dies;\n\tRBinDwarfAttrValue *values;\n\tif (!inf || !f) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < inf->length; i++) {\n\t\tfprintf (f, \"  Compilation Unit @ offset 0x%\"PFMT64x\":\\n\", inf->comp_units [i].offset);\n\t\tfprintf (f, \"   Length:        0x%x\\n\", inf->comp_units [i].hdr.length);\n\t\tfprintf (f, \"   Version:       %d\\n\", inf->comp_units [i].hdr.version);\n\t\tfprintf (f, \"   Abbrev Offset: 0x%x\\n\", inf->comp_units [i].hdr.abbrev_offset);\n\t\tfprintf (f, \"   Pointer Size:  %d\\n\", inf->comp_units [i].hdr.pointer_size);\n\t\tdies = inf->comp_units[i].dies;\n\t\tfor (j = 0; j < inf->comp_units[i].length; j++) {\n\t\t\tfprintf (f, \"    Abbrev Number: %\"PFMT64u\" \", dies[j].abbrev_code);\n\t\t\tif (dies[j].tag && dies[j].tag <= DW_TAG_volatile_type &&\n\t\t\t\t       dwarf_tag_name_encodings[dies[j].tag]) {\n\t\t\t\tfprintf (f, \"(%s)\\n\", dwarf_tag_name_encodings[dies[j].tag]);\n\t\t\t} else {\n\t\t\t\tfprintf (f, \"(Unknown abbrev tag)\\n\");\n\t\t\t}\n\t\t\tif (!dies[j].abbrev_code) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvalues = dies[j].attr_values;\n\t\t\tfor (k = 0; k < dies[j].length; k++) {\n\t\t\t\tif (!values[k].name)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (values[k].name < DW_AT_vtable_elem_location &&\n\t\t\t\t\t\tdwarf_attr_encodings[values[k].name]) {\n\t\t\t\t\tfprintf (f, \"     %-18s : \", dwarf_attr_encodings[values[k].name]);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf (f, \"     TODO\\t\");\n\t\t\t\t}\n\t\t\t\tr_bin_dwarf_dump_attr_value (&values[k], f);\n\t\t\t\tfprintf (f, \"\\n\");\n\t\t\t}\n\t\t}\n\t}\n}", "target": 1}
{"code": "h2_vfp_body(struct vfp_ctx *vc, struct vfp_entry *vfe, void *ptr, ssize_t *lp)\n{\n\tstruct h2_req *r2;\n\tstruct h2_sess *h2;\n\tunsigned l;\n\tenum vfp_status retval = VFP_OK;\n\tCHECK_OBJ_NOTNULL(vc, VFP_CTX_MAGIC);\n\tCHECK_OBJ_NOTNULL(vfe, VFP_ENTRY_MAGIC);\n\tCAST_OBJ_NOTNULL(r2, vfe->priv1, H2_REQ_MAGIC);\n\th2 = r2->h2sess;\n\tAN(ptr);\n\tAN(lp);\n\tl = *lp;\n\t*lp = 0;\n\tLck_Lock(&h2->sess->mtx);\n\tassert (r2->state == H2_S_OPEN);\n\tr2->cond = &vc->wrk->cond;\n\twhile (h2->mailcall != r2 && h2->error == 0 && r2->error == 0)\n\t\tAZ(Lck_CondWait(r2->cond, &h2->sess->mtx, 0));\n\tr2->cond = NULL;\n\tif (h2->error || r2->error) {\n\t\tretval = VFP_ERROR;\n\t} else {\n\t\tassert(h2->mailcall == r2);\n\t\tif (l > h2->rxf_len)\n\t\t\tl = h2->rxf_len;\n\t\tif (l > 0) {\n\t\t\tmemcpy(ptr, h2->rxf_data, l);\n\t\t\th2->rxf_data += l;\n\t\t\th2->rxf_len -= l;\n\t\t}\n\t\t*lp = l;\n\t\tif (h2->rxf_len > 0) {\n\t\t\tLck_Unlock(&h2->sess->mtx);\n\t\t\treturn (VFP_OK);\n\t\t}\n\t\tif (h2->rxf_len == 0) {\n\t\t\tif (h2->rxf_flags & H2FF_DATA_END_STREAM) {\n\t\t\t\tretval = VFP_END;\n\t\t\t\tr2->state = H2_S_CLOS_REM;\n\t\t\t}\n\t\t}\n\t\th2->mailcall = NULL;\n\t\tAZ(pthread_cond_signal(h2->cond));\n\t}\n\tLck_Unlock(&h2->sess->mtx);\n\treturn (retval);\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, IntersectCompoundInsteadThreeCompoundIndices) {\n    params.options = QueryPlannerParams::NO_TABLE_SCAN | QueryPlannerParams::INDEX_INTERSECTION;\n    addIndex(BSON(\"a\" << 1 << \"b\" << 1));\n    addIndex(BSON(\"c\" << 1 << \"d\" << 1));\n    addIndex(BSON(\"a\" << 1 << \"c\" << -1 << \"b\" << -1 << \"d\" << 1));\n    runQuery(fromjson(\"{a: 1, b: 1, c: 1, d: 1}\"));\n    assertNumSolutions(3U);\n    assertSolutionExists(\n        \"{fetch: {filter: {$and: [{c:1},{d:1}]}, node: \"\n        \"{ixscan: {filter: null, pattern: {a:1,b:1}}}}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: {$and:[{a:1},{b:1}]}, node: \"\n        \"{ixscan: {filter: null, pattern: {c:1,d:1}}}}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: \"\n        \"{ixscan: {filter: null, pattern: {a:1,c:-1,b:-1,d:1}}}}}\");\n}", "target": 0}
{"code": "relay_websocket_decode_frame (const unsigned char *buffer,\n                              unsigned long long buffer_length,\n                              unsigned char *decoded,\n                              unsigned long long *decoded_length)\n{\n    unsigned long long i, index_buffer, length_frame_size, length_frame;\n    unsigned char opcode;\n    *decoded_length = 0;\n    index_buffer = 0;\n    while (index_buffer + 1 < buffer_length)\n    {\n        opcode = buffer[index_buffer] & 15;\n        if (!(buffer[index_buffer + 1] & 128))\n            return 0;\n        length_frame_size = 1;\n        length_frame = buffer[index_buffer + 1] & 127;\n        index_buffer += 2;\n        if (index_buffer >= buffer_length)\n            return 0;\n        if ((length_frame == 126) || (length_frame == 127))\n        {\n            length_frame_size = (length_frame == 126) ? 2 : 8;\n            if (index_buffer + length_frame_size > buffer_length)\n                return 0;\n            length_frame = 0;\n            for (i = 0; i < length_frame_size; i++)\n            {\n                length_frame += (unsigned long long)buffer[index_buffer + i] << ((length_frame_size - i - 1) * 8);\n            }\n            index_buffer += length_frame_size;\n        }\n        if (index_buffer + 4 > buffer_length)\n            return 0;\n        int masks[4];\n        for (i = 0; i < 4; i++)\n        {\n            masks[i] = (int)((unsigned char)buffer[index_buffer + i]);\n        }\n        index_buffer += 4;\n        switch (opcode)\n        {\n            case WEBSOCKET_FRAME_OPCODE_PING:\n                decoded[*decoded_length] = RELAY_CLIENT_MSG_PING;\n                break;\n            case WEBSOCKET_FRAME_OPCODE_CLOSE:\n                decoded[*decoded_length] = RELAY_CLIENT_MSG_CLOSE;\n                break;\n            default:\n                decoded[*decoded_length] = RELAY_CLIENT_MSG_STANDARD;\n                break;\n        }\n        *decoded_length += 1;\n        if ((length_frame > buffer_length)\n            || (index_buffer + length_frame > buffer_length))\n        {\n            return 0;\n        }\n        for (i = 0; i < length_frame; i++)\n        {\n            decoded[*decoded_length + i] = (int)((unsigned char)buffer[index_buffer + i]) ^ masks[i % 4];\n        }\n        decoded[*decoded_length + length_frame] = '\\0';\n        *decoded_length += length_frame + 1;\n        index_buffer += length_frame;\n    }\n    return 1;\n}", "target": 0}
{"code": "void SetGray(double grayscale,int par)\n{\n    if ( par == STROKING ) {\n        outpos += sprintf(outpos,\" %12.3f G\",grayscale);\n    }\n    else {\n        outpos += sprintf(outpos,\" %12.3f g\",grayscale);\n    }\n}", "target": 1}
{"code": "static Jsi_RC StringSearchCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int sLen, bLen;\n    const char *source_str;\n    ChkString(_this, funcPtr, source_str, &sLen, &bLen);\n    char *v = _this->d.obj->d.s.str;\n    Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, skip);\n    if (Jsi_ValueIsString(interp, seq)) {\n        char *ce, *cp = Jsi_ValueString(interp, seq, NULL);\n        int n = -1;\n        if ((ce = Jsi_Strstr(source_str, cp))) {\n            n = (ce-source_str);\n        }\n        Jsi_ValueMakeNumber(interp, ret, n);\n        return JSI_OK;\n    }\n    if (!seq || seq->vt != JSI_VT_OBJECT || seq->d.obj->ot != JSI_OT_REGEXP) {\n        Jsi_ValueMakeNumber(interp, ret, -1);\n        return JSI_OK;\n    }\n    regex_t *reg = &seq->d.obj->d.robj->reg;\n    regmatch_t pos[MAX_SUBREGEX] = {};\n    int r;\n    if ((r = regexec(reg, v, MAX_SUBREGEX, pos, 0)) != 0) {\n        if (r == REG_NOMATCH) {\n            Jsi_ValueMakeNumber(interp, ret, -1.0);\n            return JSI_OK;\n        }\n        if (r >= REG_BADPAT) {\n            char buf[100];\n            regerror(r, reg, buf, sizeof(buf));\n            Jsi_LogError(\"error while matching pattern: %s\", buf);\n            return JSI_ERROR;\n        }\n    }\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)pos[0].rm_so);\n    return JSI_OK;\n}", "target": 1}
{"code": "NOEXPORT unsigned __stdcall daemon_thread(void *arg) {\n    (void)arg; \n    tls_alloc(NULL, NULL, \"main\"); \n    main_init();\n    SetEvent(main_initialized); \n    while(main_configure(cmdline.config_file, NULL)) {\n        if(cmdline.config_file && *cmdline.config_file=='-')\n            cmdline.config_file=NULL; \n        unbind_ports(); \n        log_flush(LOG_MODE_ERROR); \n        PostMessage(hwnd, WM_INVALID_CONFIG, 0, 0); \n        WaitForSingleObject(config_ready, INFINITE);\n    }\n    PostMessage(hwnd, WM_VALID_CONFIG, 0, 0);\n    daemon_loop();\n    main_cleanup();\n    _endthreadex(0); \n    return 0;\n}", "target": 1}
{"code": "static int walk_hugetlb_range(unsigned long addr, unsigned long end,\n\t\t\t      struct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct hstate *h = hstate_vma(vma);\n\tunsigned long next;\n\tunsigned long hmask = huge_page_mask(h);\n\tunsigned long sz = huge_page_size(h);\n\tpte_t *pte;\n\tint err = 0;\n\tdo {\n\t\tnext = hugetlb_entry_end(h, addr, end);\n\t\tpte = huge_pte_offset(walk->mm, addr & hmask, sz);\n\t\tif (pte && walk->hugetlb_entry)\n\t\t\terr = walk->hugetlb_entry(pte, hmask, addr, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (addr = next, addr != end);\n\treturn err;\n}", "target": 1}
{"code": "static int rfcomm_get_dev_list(void __user *arg)\n{\n\tstruct rfcomm_dev *dev;\n\tstruct rfcomm_dev_list_req *dl;\n\tstruct rfcomm_dev_info *di;\n\tint n = 0, size, err;\n\tu16 dev_num;\n\tBT_DBG(\"\");\n\tif (get_user(dev_num, (u16 __user *) arg))\n\t\treturn -EFAULT;\n\tif (!dev_num || dev_num > (PAGE_SIZE * 4) / sizeof(*di))\n\t\treturn -EINVAL;\n\tsize = sizeof(*dl) + dev_num * sizeof(*di);\n\tdl = kmalloc(size, GFP_KERNEL);\n\tif (!dl)\n\t\treturn -ENOMEM;\n\tdi = dl->dev_info;\n\tspin_lock(&rfcomm_dev_lock);\n\tlist_for_each_entry(dev, &rfcomm_dev_list, list) {\n\t\tif (test_bit(RFCOMM_TTY_RELEASED, &dev->flags))\n\t\t\tcontinue;\n\t\t(di + n)->id      = dev->id;\n\t\t(di + n)->flags   = dev->flags;\n\t\t(di + n)->state   = dev->dlc->state;\n\t\t(di + n)->channel = dev->channel;\n\t\tbacpy(&(di + n)->src, &dev->src);\n\t\tbacpy(&(di + n)->dst, &dev->dst);\n\t\tif (++n >= dev_num)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&rfcomm_dev_lock);\n\tdl->dev_num = n;\n\tsize = sizeof(*dl) + n * sizeof(*di);\n\terr = copy_to_user(arg, dl, size);\n\tkfree(dl);\n\treturn err ? -EFAULT : 0;\n}", "target": 1}
{"code": "static __u8 *nci_extract_rf_params_nfcb_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfcb_poll *nfcb_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfcb_poll->sensb_res_len = *data++;\n\tpr_debug(\"sensb_res_len %d\\n\", nfcb_poll->sensb_res_len);\n\tmemcpy(nfcb_poll->sensb_res, data, nfcb_poll->sensb_res_len);\n\tdata += nfcb_poll->sensb_res_len;\n\treturn data;\n}", "target": 1}
{"code": "int hugetlb_reserve_pages(struct inode *inode,\n\t\t\t\t\tlong from, long to,\n\t\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\t\tvm_flags_t vm_flags)\n{\n\tlong ret, chg;\n\tstruct hstate *h = hstate_inode(inode);\n\tstruct hugepage_subpool *spool = subpool_inode(inode);\n\tif (vm_flags & VM_NORESERVE)\n\t\treturn 0;\n\tif (!vma || vma->vm_flags & VM_MAYSHARE)\n\t\tchg = region_chg(&inode->i_mapping->private_list, from, to);\n\telse {\n\t\tstruct resv_map *resv_map = resv_map_alloc();\n\t\tif (!resv_map)\n\t\t\treturn -ENOMEM;\n\t\tchg = to - from;\n\t\tset_vma_resv_map(vma, resv_map);\n\t\tset_vma_resv_flags(vma, HPAGE_RESV_OWNER);\n\t}\n\tif (chg < 0) {\n\t\tret = chg;\n\t\tgoto out_err;\n\t}\n\tif (hugepage_subpool_get_pages(spool, chg)) {\n\t\tret = -ENOSPC;\n\t\tgoto out_err;\n\t}\n\tret = hugetlb_acct_memory(h, chg);\n\tif (ret < 0) {\n\t\thugepage_subpool_put_pages(spool, chg);\n\t\tgoto out_err;\n\t}\n\tif (!vma || vma->vm_flags & VM_MAYSHARE)\n\t\tregion_add(&inode->i_mapping->private_list, from, to);\n\treturn 0;\nout_err:\n\tresv_map_put(vma);\n\treturn ret;\n}", "target": 0}
{"code": "void kvm_arch_flush_shadow_memslot(struct kvm *kvm,\n\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tkvm_arch_flush_shadow_all(kvm);\n}", "target": 0}
{"code": "static int emulate_store_desc_ptr(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t  void (*get)(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t      struct desc_ptr *ptr))\n{\n\tstruct desc_ptr desc_ptr;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tctxt->op_bytes = 8;\n\tget(ctxt, &desc_ptr);\n\tif (ctxt->op_bytes == 2) {\n\t\tctxt->op_bytes = 4;\n\t\tdesc_ptr.address &= 0x00ffffff;\n\t}\n\tctxt->dst.type = OP_NONE;\n\treturn segmented_write_std(ctxt, ctxt->dst.addr.mem,\n\t\t\t\t   &desc_ptr, 2 + ctxt->op_bytes);\n}", "target": 0}
{"code": "mt76_add_fragment(struct mt76_dev *dev, struct mt76_queue *q, void *data,\n\t\t  int len, bool more)\n{\n\tstruct page *page = virt_to_head_page(data);\n\tint offset = data - page_address(page);\n\tstruct sk_buff *skb = q->rx_head;\n\toffset += q->buf_offset;\n\tskb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page, offset, len,\n\t\t\tq->buf_size);\n\tif (more)\n\t\treturn;\n\tq->rx_head = NULL;\n\tdev->drv->rx_skb(dev, q - dev->q_rx, skb);\n}", "target": 1}
{"code": "static void make_response(struct xen_blkif_ring *ring, u64 id,\n\t\t\t  unsigned short op, int st)\n{\n\tstruct blkif_response  resp;\n\tunsigned long     flags;\n\tunion blkif_back_rings *blk_rings;\n\tint notify;\n\tresp.id        = id;\n\tresp.operation = op;\n\tresp.status    = st;\n\tspin_lock_irqsave(&ring->blk_ring_lock, flags);\n\tblk_rings = &ring->blk_rings;\n\tswitch (ring->blkif->blk_protocol) {\n\tcase BLKIF_PROTOCOL_NATIVE:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->native, blk_rings->native.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n\t\tbreak;\n\tcase BLKIF_PROTOCOL_X86_32:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->x86_32, blk_rings->x86_32.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n\t\tbreak;\n\tcase BLKIF_PROTOCOL_X86_64:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->x86_64, blk_rings->x86_64.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tblk_rings->common.rsp_prod_pvt++;\n\tRING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);\n\tspin_unlock_irqrestore(&ring->blk_ring_lock, flags);\n\tif (notify)\n\t\tnotify_remote_via_irq(ring->irq);\n}", "target": 1}
{"code": "int nego_recv(rdpTransport* transport, wStream* s, void* extra)\n{\n\tBYTE li;\n\tBYTE type;\n\tUINT16 length;\n\trdpNego* nego = (rdpNego*)extra;\n\tif (!tpkt_read_header(s, &length))\n\t\treturn -1;\n\tif (!tpdu_read_connection_confirm(s, &li, length))\n\t\treturn -1;\n\tif (li > 6)\n\t{\n\t\tStream_Read_UINT8(s, type); \n\t\tswitch (type)\n\t\t{\n\t\t\tcase TYPE_RDP_NEG_RSP:\n\t\t\t\tnego_process_negotiation_response(nego, s);\n\t\t\t\tWLog_DBG(TAG, \"selected_protocol: %\" PRIu32 \"\", nego->SelectedProtocol);\n\t\t\t\tif (nego->SelectedProtocol)\n\t\t\t\t{\n\t\t\t\t\tif ((nego->SelectedProtocol == PROTOCOL_HYBRID) &&\n\t\t\t\t\t    (!nego->EnabledProtocols[PROTOCOL_HYBRID]))\n\t\t\t\t\t{\n\t\t\t\t\t\tnego->state = NEGO_STATE_FAIL;\n\t\t\t\t\t}\n\t\t\t\t\tif ((nego->SelectedProtocol == PROTOCOL_SSL) &&\n\t\t\t\t\t    (!nego->EnabledProtocols[PROTOCOL_SSL]))\n\t\t\t\t\t{\n\t\t\t\t\t\tnego->state = NEGO_STATE_FAIL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (!nego->EnabledProtocols[PROTOCOL_RDP])\n\t\t\t\t{\n\t\t\t\t\tnego->state = NEGO_STATE_FAIL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TYPE_RDP_NEG_FAILURE:\n\t\t\t\tnego_process_negotiation_failure(nego, s);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse if (li == 6)\n\t{\n\t\tWLog_DBG(TAG, \"no rdpNegData\");\n\t\tif (!nego->EnabledProtocols[PROTOCOL_RDP])\n\t\t\tnego->state = NEGO_STATE_FAIL;\n\t\telse\n\t\t\tnego->state = NEGO_STATE_FINAL;\n\t}\n\telse\n\t{\n\t\tWLog_ERR(TAG, \"invalid negotiation response\");\n\t\tnego->state = NEGO_STATE_FAIL;\n\t}\n\tif (!tpkt_ensure_stream_consumed(s, length))\n\t\treturn -1;\n\treturn 0;\n}", "target": 1}
{"code": "static Jsi_RC DebugRemoveCmd_(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr, int op)\n{\n    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);\n    if (interp->breakpointHash)\n    {\n        int num;\n        char nbuf[100];\n        if (Jsi_GetIntFromValue(interp, val, &num) != JSI_OK) \n            return Jsi_LogError(\"bad number\");\n        snprintf(nbuf, sizeof(nbuf), \"%d\", num);\n        Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->breakpointHash, nbuf);\n        jsi_BreakPoint* bptr;\n        if (hPtr && (bptr = (jsi_BreakPoint*)Jsi_HashValueGet(hPtr))) {\n            switch (op) {\n                case 1: bptr->enabled = 0; break;\n                case 2: bptr->enabled = 1; break;\n                default:\n                    Jsi_HashEntryDelete(hPtr);\n            }\n            return JSI_OK;\n        }\n    }\n    return Jsi_LogError(\"unknown breakpoint\");\n}", "target": 1}
{"code": "PassRefPtr<WebProcessProxy> WebProcessProxy::create(PassRefPtr<WebContext> context)\n{\n    return adoptRef(new WebProcessProxy(context));\n}", "target": 0}
{"code": "static void inotify_free_group_priv(struct fsnotify_group *group)\n{\n\tidr_for_each(&group->inotify_data.idr, idr_callback, group);\n\tidr_remove_all(&group->inotify_data.idr);\n\tidr_destroy(&group->inotify_data.idr);\n\tatomic_dec(&group->inotify_data.user->inotify_devs);\n\tfree_uid(group->inotify_data.user);\n}", "target": 0}
{"code": "poly_path(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *poly = PG_GETARG_POLYGON_P(0);\n\tPATH\t   *path;\n\tint\t\t\tsize;\n\tint\t\t\ti;\n\tsize = offsetof(PATH, p[0]) +sizeof(path->p[0]) * poly->npts;\n\tpath = (PATH *) palloc(size);\n\tSET_VARSIZE(path, size);\n\tpath->npts = poly->npts;\n\tpath->closed = TRUE;\n\tpath->dummy = 0;\n\tfor (i = 0; i < poly->npts; i++)\n\t{\n\t\tpath->p[i].x = poly->p[i].x;\n\t\tpath->p[i].y = poly->p[i].y;\n\t}\n\tPG_RETURN_PATH_P(path);\n}", "target": 0}
{"code": "void rose_start_t2timer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tdel_timer(&rose->timer);\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->t2;\n\tadd_timer(&rose->timer);\n}", "target": 1}
{"code": "static struct nfs4_state *nfs4_opendata_to_nfs4_state(struct nfs4_opendata *data)\n{\n\tstruct inode *inode;\n\tstruct nfs4_state *state = NULL;\n\tstruct nfs_delegation *delegation;\n\tint ret;\n\tif (!data->rpc_done) {\n\t\tstate = nfs4_try_open_cached(data);\n\t\tgoto out;\n\t}\n\tret = -EAGAIN;\n\tif (!(data->f_attr.valid & NFS_ATTR_FATTR))\n\t\tgoto err;\n\tinode = nfs_fhget(data->dir->d_sb, &data->o_res.fh, &data->f_attr);\n\tret = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto err;\n\tret = -ENOMEM;\n\tstate = nfs4_get_open_state(inode, data->owner);\n\tif (state == NULL)\n\t\tgoto err_put_inode;\n\tif (data->o_res.delegation_type != 0) {\n\t\tint delegation_flags = 0;\n\t\trcu_read_lock();\n\t\tdelegation = rcu_dereference(NFS_I(inode)->delegation);\n\t\tif (delegation)\n\t\t\tdelegation_flags = delegation->flags;\n\t\trcu_read_unlock();\n\t\tif ((delegation_flags & 1UL<<NFS_DELEGATION_NEED_RECLAIM) == 0)\n\t\t\tnfs_inode_set_delegation(state->inode,\n\t\t\t\t\tdata->owner->so_cred,\n\t\t\t\t\t&data->o_res);\n\t\telse\n\t\t\tnfs_inode_reclaim_delegation(state->inode,\n\t\t\t\t\tdata->owner->so_cred,\n\t\t\t\t\t&data->o_res);\n\t}\n\tupdate_open_stateid(state, &data->o_res.stateid, NULL,\n\t\t\tdata->o_arg.open_flags);\n\tiput(inode);\nout:\n\treturn state;\nerr_put_inode:\n\tiput(inode);\nerr:\n\treturn ERR_PTR(ret);\n}", "target": 1}
{"code": "static inline neu_msg_t *neu_msg_new(neu_reqresp_type_e t, void *ctx,\n                                     void *data)\n{\n    size_t data_size = neu_reqresp_size(t);\n    size_t body_size = 0;\n    switch (t) {\n    case NEU_REQ_CHECK_SCHEMA:\n        body_size = neu_reqresp_size(NEU_RESP_CHECK_SCHEMA);\n        break;\n    case NEU_REQ_GET_PLUGIN:\n        body_size = neu_reqresp_size(NEU_RESP_GET_PLUGIN);\n        break;\n    case NEU_REQ_UPDATE_GROUP:\n    case NEU_REQ_UPDATE_DRIVER_GROUP:\n        body_size = neu_reqresp_size(NEU_RESP_UPDATE_DRIVER_GROUP);\n        break;\n    case NEU_REQ_UPDATE_NODE:\n    case NEU_REQ_NODE_RENAME:\n        body_size = neu_reqresp_size(NEU_RESP_NODE_RENAME);\n        break;\n    case NEU_REQ_DEL_NODE:\n        body_size = neu_reqresp_size(NEU_RESP_NODE_UNINIT);\n        break;\n    case NEU_REQ_GET_NODE_SETTING:\n        body_size = neu_reqresp_size(NEU_RESP_GET_NODE_SETTING);\n        break;\n    case NEU_REQ_GET_NODES_STATE:\n        body_size = neu_reqresp_size(NEU_RESP_GET_NODES_STATE);\n        break;\n    default:\n        body_size = data_size;\n    }\n    size_t     total = sizeof(neu_msg_t) + body_size;\n    neu_msg_t *msg   = calloc(1, total);\n    if (msg) {\n        msg->head.type = t;\n        msg->head.len  = total;\n        msg->head.ctx  = ctx;\n        if (data) {\n            memcpy(msg->body, data, data_size);\n        }\n    }\n    return msg;\n}", "target": 0}
{"code": "blkcpy(void * dest, void * src, size_t len)\n{\n  __m128i * D = (__m128i *) dest;\n  __m128i * S = (__m128i *) src;\n  size_t L = len / 16;\n  size_t i;\n  for (i = 0; i < L; i++)\n    D[i] = S[i];\n}", "target": 1}
{"code": "uint16_t mesg_id (void) {\n\tstatic uint16_t id = 0;\n\tif (!id) {\n\t\tsrandom (time (NULL));\n\t\tid = random ();\n\t}\n\tid++;\n\tif (T.debug > 4)\n\t\tsyslog (LOG_DEBUG, \"mesg_id() = %d\", id);\n\treturn id;\n}", "target": 1}
{"code": "bool hostuid_to_ns(uid_t uid, pid_t pid, uid_t *answer)\n{\n\tFILE *f;\n\tchar line[400];\n\tsprintf(line, \"/proc/%d/uid_map\", pid);\n\tif ((f = fopen(line, \"r\")) == NULL) {\n\t\treturn false;\n\t}\n\t*answer = convert_id_to_ns(f, uid);\n\tfclose(f);\n\tif (*answer == -1)\n\t\treturn false;\n\treturn true;\n}", "target": 0}
{"code": "static void parse_relocation_info(struct MACH0_(obj_t) *bin, RSkipList *relocs, ut32 offset, ut32 num) {\n\tif (!num || !offset || (st32)num < 0) {\n\t\treturn;\n\t}\n\tut64 total_size = num * sizeof (struct relocation_info);\n\tif (offset > bin->size) {\n\t\treturn;\n\t}\n\tif (total_size > bin->size) {\n\t\ttotal_size = bin->size - offset;\n\t\tnum = total_size /= sizeof (struct relocation_info);\n\t}\n\tstruct relocation_info *info = calloc (num, sizeof (struct relocation_info));\n\tif (!info) {\n\t\treturn;\n\t}\n\tif (r_buf_read_at (bin->b, offset, (ut8 *) info, total_size) < total_size) {\n\t\tfree (info);\n\t\treturn;\n\t}\n\tsize_t i;\n\tfor (i = 0; i < num; i++) {\n\t\tstruct relocation_info a_info = info[i];\n\t\tut32 sym_num = a_info.r_symbolnum;\n\t\tif (sym_num > bin->nsymtab) {\n\t\t\tcontinue;\n\t\t}\n\t\tut32 stridx = bin->symtab[sym_num].n_strx;\n\t\tchar *sym_name = get_name (bin, stridx, false);\n\t\tif (!sym_name) {\n\t\t\tcontinue;\n\t\t}\n\t\tstruct reloc_t *reloc = R_NEW0 (struct reloc_t);\n\t\tif (!reloc) {\n\t\t\tfree (info);\n\t\t\tfree (sym_name);\n\t\t\treturn;\n\t\t}\n\t\treloc->addr = offset_to_vaddr (bin, a_info.r_address);\n\t\treloc->offset = a_info.r_address;\n\t\treloc->ord = sym_num;\n\t\treloc->type = a_info.r_type; \n\t\treloc->external = a_info.r_extern;\n\t\treloc->pc_relative = a_info.r_pcrel;\n\t\treloc->size = a_info.r_length;\n\t\tr_str_ncpy (reloc->name, sym_name, sizeof (reloc->name) - 1);\n\t\tr_skiplist_insert (relocs, reloc);\n\t\tfree (sym_name);\n\t}\n\tfree (info);\n}", "target": 1}
{"code": "void LanLinkProvider::dataReceived()\n{\n    QSslSocket* socket = qobject_cast<QSslSocket*>(sender());\n    if (socket->bytesAvailable() > 8192) {\n        qCWarning(KDECONNECT_CORE) << \"LanLinkProvider/newConnection: Suspiciously long identity package received. Closing connection.\" << socket->peerAddress() << socket->bytesAvailable();\n        socket->disconnectFromHost();\n        return;\n    }\n#if QT_VERSION < QT_VERSION_CHECK(5,7,0)\n    if (!socket->canReadLine())\n        return;\n#else\n    socket->startTransaction();\n#endif\n    const QByteArray data = socket->readLine();\n    qCDebug(KDECONNECT_CORE) << \"LanLinkProvider received reply:\" << data;\n    NetworkPacket* np = new NetworkPacket(QLatin1String(\"\"));\n    bool success = NetworkPacket::unserialize(data, np);\n#if QT_VERSION < QT_VERSION_CHECK(5,7,0)\n    if (!success) {\n        delete np;\n        return;\n    }\n#else\n    if (!success) {\n        delete np;\n        socket->rollbackTransaction();\n        return;\n    }\n    socket->commitTransaction();\n#endif\n    if (np->type() != PACKET_TYPE_IDENTITY) {\n        qCWarning(KDECONNECT_CORE) << \"LanLinkProvider/newConnection: Expected identity, received \" << np->type();\n        delete np;\n        return;\n    }\n    m_receivedIdentityPackets[socket].np = np;\n    const QString& deviceId = np->get<QString>(QStringLiteral(\"deviceId\"));\n    disconnect(socket, &QIODevice::readyRead, this, &LanLinkProvider::dataReceived);\n    if (np->get<int>(QStringLiteral(\"protocolVersion\")) >= MIN_VERSION_WITH_SSL_SUPPORT) {\n        bool isDeviceTrusted = KdeConnectConfig::instance().trustedDevices().contains(deviceId);\n        configureSslSocket(socket, deviceId, isDeviceTrusted);\n        qCDebug(KDECONNECT_CORE) << \"Starting client ssl (but I'm the server TCP socket)\";\n        connect(socket, &QSslSocket::encrypted, this, &LanLinkProvider::encrypted);\n        if (isDeviceTrusted) {\n            connect(socket, QOverload<const QList<QSslError> &>::of(&QSslSocket::sslErrors), this, &LanLinkProvider::sslErrors);\n        }\n        socket->startClientEncryption();\n    } else {\n        qWarning() << np->get<QString>(QStringLiteral(\"deviceName\")) << \"uses an old protocol version, this won't work\";\n        delete m_receivedIdentityPackets.take(socket).np;\n    }\n}", "target": 0}
{"code": "RenderWidgetHostViewPort* GetRenderWidgetHostViewFromSurfaceID(\n    int surface_id) {\n  int render_process_id = 0;\n  int render_widget_id = 0;\n  if (!GpuSurfaceTracker::Get()->GetRenderWidgetIDForSurface(\n        surface_id, &render_process_id, &render_widget_id))\n    return NULL;\n  content::RenderProcessHost* process =\n      content::RenderProcessHost::FromID(render_process_id);\n  if (!process)\n    return NULL;\n  content::RenderWidgetHost* host = process->GetRenderWidgetHostByID(\n      render_widget_id);\n  return host ? RenderWidgetHostViewPort::FromRWHV(host->GetView()) : NULL;\n}", "target": 0}
{"code": "static void zep_print_ts(netdissect_options *ndo, const u_char *p)\n{\n\tint32_t i;\n\tuint32_t uf;\n\tuint32_t f;\n\tfloat ff;\n\ti = GET_BE_U_4(p);\n\tuf = GET_BE_U_4(p + 4);\n\tff = (float) uf;\n\tif (ff < 0.0)           \n\t\tff += FMAXINT;\n\tff = (float) (ff / FMAXINT); \n\tf = (uint32_t) (ff * 1000000000.0);  \n\tND_PRINT(\"%u.%09d\", i, f);\n\tif (i) {\n\t\ttime_t seconds = i - JAN_1970;\n\t\tstruct tm *tm;\n\t\tchar time_buf[128];\n\t\ttm = localtime(&seconds);\n\t\tstrftime(time_buf, sizeof (time_buf), \"%Y/%m/%d %H:%M:%S\", tm);\n\t\tND_PRINT(\" (%s)\", time_buf);\n\t}\n}", "target": 1}
{"code": "nvkm_vmm_free_delete(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n{\n\tnvkm_vmm_free_remove(vmm, vma);\n\tlist_del(&vma->head);\n\tkfree(vma);\n}", "target": 0}
{"code": "int CServer::SendMsg(CMsgPacker *pMsg, int Flags, int ClientID)\n{\n\tCNetChunk Packet;\n\tif(!pMsg)\n\t\treturn -1;\n\tif(0 <= ClientID && ClientID < MAX_CLIENTS && GameServer()->IsClientBot(ClientID))\n\t\treturn 0;\n\tmem_zero(&Packet, sizeof(CNetChunk));\n\tPacket.m_ClientID = ClientID;\n\tPacket.m_pData = pMsg->Data();\n\tPacket.m_DataSize = pMsg->Size();\n\tif(Flags&MSGFLAG_VITAL)\n\t\tPacket.m_Flags |= NETSENDFLAG_VITAL;\n\tif(Flags&MSGFLAG_FLUSH)\n\t\tPacket.m_Flags |= NETSENDFLAG_FLUSH;\n\tif(!(Flags&MSGFLAG_NORECORD))\n\t\tm_DemoRecorder.RecordMessage(pMsg->Data(), pMsg->Size());\n\tif(!(Flags&MSGFLAG_NOSEND))\n\t{\n\t\tif(ClientID == -1)\n\t\t{\n\t\t\tint i;\n\t\t\tfor(i = 0; i < MAX_CLIENTS; i++)\n\t\t\t\tif(m_aClients[i].m_State == CClient::STATE_INGAME && !m_aClients[i].m_Quitting)\n\t\t\t\t{\n\t\t\t\t\tPacket.m_ClientID = i;\n\t\t\t\t\tm_NetServer.Send(&Packet);\n\t\t\t\t}\n\t\t}\n\t\telse\n\t\t\tm_NetServer.Send(&Packet);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "log_close_all(void)\n{\nif (mainlogfd >= 0)\n  { (void)close(mainlogfd); mainlogfd = -1; }\nif (rejectlogfd >= 0)\n  { (void)close(rejectlogfd); rejectlogfd = -1; }\ncloselog();\nsyslog_open = FALSE;\n}", "target": 0}
{"code": "static int scantag(const char* in, char* buffer, int* lenp) {\n    int len;\n    for (len = 0; len < 128; len++) {\n        const char c = *in++;\n        switch (c) {\n        case '\\0':\n            return 0;\n        case '<':\n            return 0;\n        case '>':\n            buffer[len] = '\\0';\n            *lenp = len+1;\n            return 1;\n        default:\n            break;\n        }\n        buffer[len] = c;\n    }\n    return 0;\n}", "target": 0}
{"code": "static NTSTATUS dcesrv_interface_dnsserver_bind(struct dcesrv_connection_context *context,\n\t\t\t\t\t        const struct dcesrv_interface *iface)\n{\n\treturn dcesrv_interface_bind_require_integrity(context, iface);\n}", "target": 0}
{"code": "mem_log_init(const char* prog_name, const char *banner)\n{\n\tsize_t log_name_len;\n\tchar *log_name;\n\tif (__test_bit(LOG_CONSOLE_BIT, &debug)) {\n\t\tlog_op = stderr;\n\t\treturn;\n\t}\n\tif (log_op)\n\t\tfclose(log_op);\n\tlog_name_len = 5 + strlen(prog_name) + 5 + 7 + 4 + 1;\t\n\tlog_name = malloc(log_name_len);\n\tif (!log_name) {\n\t\tlog_message(LOG_INFO, \"Unable to malloc log file name\");\n\t\tlog_op = stderr;\n\t\treturn;\n\t}\n\tsnprintf(log_name, log_name_len, \"/tmp/%s_mem.%d.log\", prog_name, getpid());\n\tlog_op = fopen(log_name, \"a\");\n\tif (log_op == NULL) {\n\t\tlog_message(LOG_INFO, \"Unable to open %s for appending\", log_name);\n\t\tlog_op = stderr;\n\t}\n\telse {\n\t\tint fd = fileno(log_op);\n\t\tfcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);\n\t\tsetlinebuf(log_op);\n\t\tfprintf(log_op, \"\\n\");\n\t}\n\tfree(log_name);\n\tterminate_banner = banner;\n}", "target": 1}
{"code": "Eina_Bool ewk_view_stop(Evas_Object* ewkView)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    return ewk_frame_stop(smartData->main_frame);\n}", "target": 0}
{"code": "soup_server_get_listener (SoupServer *server)\n{\n\tSoupServerPrivate *priv;\n\tg_return_val_if_fail (SOUP_IS_SERVER (server), NULL);\n\tpriv = SOUP_SERVER_GET_PRIVATE (server);\n\treturn priv->listen_sock;\n}", "target": 0}
{"code": "cmnd_matches_all(const struct sudoers_parse_tree *parse_tree,\n    const struct member *m, const char *runchroot, struct cmnd_info *info)\n{\n    const bool negated = m->negated;\n    struct sudo_command *c;\n    int matched = UNSPEC;\n    struct alias *a;\n    debug_decl(cmnd_matches_all, SUDOERS_DEBUG_MATCH);\n    switch (m->type) {\n\tcase ALL:\n\t    c = (struct sudo_command *)m->name;\n\t    if (command_matches(parse_tree->ctx, c->cmnd, c->args, runchroot,\n\t\t    info, &c->digests))\n\t\tmatched = negated ? DENY : ALLOW;\n\t    break;\n\tcase ALIAS:\n\t    a = alias_get(parse_tree, m->name, CMNDALIAS);\n\t    if (a != NULL) {\n\t\tTAILQ_FOREACH_REVERSE(m, &a->members, member_list, entries) {\n\t\t    matched = cmnd_matches_all(parse_tree, m, runchroot, info);\n\t\t    if (matched != UNSPEC) {\n\t\t\tif (negated)\n\t\t\t    matched = matched == ALLOW ? DENY : ALLOW;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\talias_put(a);\n\t    }\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 1}
{"code": "RenderSVGResourceContainer* SVGDocumentExtensions::resourceById(const AtomicString& id) const\n{\n    if (id.isEmpty())\n        return 0;\n    return m_resources.get(id);\n}", "target": 0}
{"code": "static void mark_key_instantiated(struct key *key, int reject_error)\n{\n\tsmp_store_release(&key->state,\n\t\t\t  (reject_error < 0) ? reject_error : KEY_IS_POSITIVE);\n}", "target": 0}
{"code": "static void sas_unregister_devs_sas_addr(struct domain_device *parent,\n\t\t\t\t\t int phy_id, bool last)\n{\n\tstruct expander_device *ex_dev = &parent->ex_dev;\n\tstruct ex_phy *phy = &ex_dev->ex_phy[phy_id];\n\tstruct domain_device *child, *n, *found = NULL;\n\tif (last) {\n\t\tlist_for_each_entry_safe(child, n,\n\t\t\t&ex_dev->children, siblings) {\n\t\t\tif (SAS_ADDR(child->sas_addr) ==\n\t\t\t    SAS_ADDR(phy->attached_sas_addr)) {\n\t\t\t\tset_bit(SAS_DEV_GONE, &child->state);\n\t\t\t\tif (child->dev_type == SAS_EDGE_EXPANDER_DEVICE ||\n\t\t\t\t    child->dev_type == SAS_FANOUT_EXPANDER_DEVICE)\n\t\t\t\t\tsas_unregister_ex_tree(parent->port, child);\n\t\t\t\telse\n\t\t\t\t\tsas_unregister_dev(parent->port, child);\n\t\t\t\tfound = child;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsas_disable_routing(parent, phy->attached_sas_addr);\n\t}\n\tmemset(phy->attached_sas_addr, 0, SAS_ADDR_SIZE);\n\tif (phy->port) {\n\t\tsas_port_delete_phy(phy->port, phy->phy);\n\t\tsas_device_set_phy(found, phy->port);\n\t\tif (phy->port->num_phys == 0)\n\t\t\tsas_port_delete(phy->port);\n\t\tphy->port = NULL;\n\t}\n}", "target": 1}
{"code": "GF_Err diST_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tchar str[1024];\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\ti=0;\n\tstr[0]=0;\n\twhile (1) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tif (!str[i]) break;\n\t\ti++;\n\t}\n\tISOM_DECREASE_SIZE(p, i);\n\tp->content_script_types = gf_strdup(str);\n\treturn GF_OK;\n}", "target": 1}
{"code": "static void mdbEvalSetColumn(MyDbEvalContext *p, int iCol, Jsi_DString *dStr) {\n    char nbuf[200];\n    MysqlPrep *prep = p->prep;\n    SqlFieldResults *field = prep->fieldResult+iCol;\n    Jsi_Interp *interp = p->jdb->interp;\n    if (field->isnull)\n        return;\n    switch(field->jsiTypeMap) {\n        case JSI_OPTION_STRING: {\n            int bytes = field->len;\n            const char *zBlob = field->buffer.vstring;\n            if( !zBlob ) {\n                const char *nv = p->jdb->optPtr->nullvalue;\n                Jsi_DSAppend(dStr, nv?nv:\"null\", NULL);\n                return;\n            }\n            Jsi_DSAppendLen(dStr, zBlob, bytes);\n            return;\n        }\n        case JSI_OPTION_BOOL: {\n            snprintf(nbuf, sizeof(nbuf), \"%s\", field->buffer.vchar?\"true\":\"false\");\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_INT64: {\n            snprintf(nbuf, sizeof(nbuf), \"%lld\", field->buffer.vlonglong);\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_TIME_D:\n        case JSI_OPTION_TIME_W: {\n            Jsi_Number jtime = mdbMyTimeToJS(&field->buffer.timestamp);\n            Jsi_NumberToString(interp, jtime, nbuf, sizeof(nbuf));\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_DOUBLE: {\n            Jsi_NumberToString(interp, field->buffer.vdouble, nbuf, sizeof(nbuf));\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        default:\n            Jsi_LogWarn(\"unknown type: %d\", field->jsiTypeMap);\n    }\n}", "target": 1}
{"code": "}\nGF_Err jp2h_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read_ex(s, bs, jp2h_on_child_box, s->type);", "target": 0}
{"code": "bool DelegatedFrameHost::TransformPointToLocalCoordSpace(\n    const gfx::Point& point,\n    const viz::SurfaceId& original_surface,\n    gfx::Point* transformed_point) {\n  viz::SurfaceId surface_id(frame_sink_id_, local_surface_id_);\n  if (!surface_id.is_valid())\n    return false;\n  *transformed_point = point;\n  if (original_surface == surface_id)\n    return true;\n  viz::SurfaceHittest hittest(nullptr,\n                              GetFrameSinkManager()->surface_manager());\n  return hittest.TransformPointToTargetSurface(original_surface, surface_id,\n                                               transformed_point);\n}", "target": 0}
{"code": "noko_init_xml_sax_parser_context()\n{\n  cNokogiriXmlSaxParserContext = rb_define_class_under(mNokogiriXmlSax, \"ParserContext\", rb_cObject);\n  rb_undef_alloc_func(cNokogiriXmlSaxParserContext);\n  rb_define_singleton_method(cNokogiriXmlSaxParserContext, \"io\", parse_io, 2);\n  rb_define_singleton_method(cNokogiriXmlSaxParserContext, \"memory\", parse_memory, 1);\n  rb_define_singleton_method(cNokogiriXmlSaxParserContext, \"file\", parse_file, 1);\n  rb_define_method(cNokogiriXmlSaxParserContext, \"parse_with\", parse_with, 1);\n  rb_define_method(cNokogiriXmlSaxParserContext, \"replace_entities=\", set_replace_entities, 1);\n  rb_define_method(cNokogiriXmlSaxParserContext, \"replace_entities\", get_replace_entities, 0);\n  rb_define_method(cNokogiriXmlSaxParserContext, \"recovery=\", set_recovery, 1);\n  rb_define_method(cNokogiriXmlSaxParserContext, \"recovery\", get_recovery, 0);\n  rb_define_method(cNokogiriXmlSaxParserContext, \"line\", line, 0);\n  rb_define_method(cNokogiriXmlSaxParserContext, \"column\", column, 0);\n  id_read = rb_intern(\"read\");\n}", "target": 0}
{"code": "mm_free(struct mm_master *mm, void *address)\n{\n\tstruct mm_share *mms, *prev, tmp;\n\ttmp.address = address;\n\tmms = RB_FIND(mmtree, &mm->rb_allocated, &tmp);\n\tif (mms == NULL)\n\t\tfatal(\"mm_free(%p): can not find %p\", mm, address);\n\tmemset(mms->address, 0xd0, mms->size);\n\tRB_REMOVE(mmtree, &mm->rb_allocated, mms);\n\tif (RB_INSERT(mmtree, &mm->rb_free, mms) != NULL)\n\t\tfatal(\"mm_free(%p): double address %p\", mm, address);\n\tprev = mms;\n\tif (RB_LEFT(prev, next)) {\n\t\tprev = RB_LEFT(prev, next);\n\t\twhile (RB_RIGHT(prev, next))\n\t\t\tprev = RB_RIGHT(prev, next);\n\t} else {\n\t\tif (RB_PARENT(prev, next) &&\n\t\t    (prev == RB_RIGHT(RB_PARENT(prev, next), next)))\n\t\t\tprev = RB_PARENT(prev, next);\n\t\telse {\n\t\t\twhile (RB_PARENT(prev, next) &&\n\t\t\t    (prev == RB_LEFT(RB_PARENT(prev, next), next)))\n\t\t\t\tprev = RB_PARENT(prev, next);\n\t\t\tprev = RB_PARENT(prev, next);\n\t\t}\n\t}\n\tif (prev != NULL && MM_ADDRESS_END(prev) > address)\n\t\tfatal(\"mm_free: memory corruption: %p(%zu) > %p\",\n\t\t    prev->address, prev->size, address);\n\tif (prev != NULL && MM_ADDRESS_END(prev) == address) {\n\t\tprev->size += mms->size;\n\t\tRB_REMOVE(mmtree, &mm->rb_free, mms);\n\t\tif (mm->mmalloc == NULL)\n\t\t\tfree(mms);\n\t\telse\n\t\t\tmm_free(mm->mmalloc, mms);\n\t} else\n\t\tprev = mms;\n\tif (prev == NULL)\n\t\treturn;\n\tmms = RB_NEXT(mmtree, &mm->rb_free, prev);\n\tif (mms == NULL)\n\t\treturn;\n\tif (MM_ADDRESS_END(prev) > mms->address)\n\t\tfatal(\"mm_free: memory corruption: %p < %p(%zu)\",\n\t\t    mms->address, prev->address, prev->size);\n\tif (MM_ADDRESS_END(prev) != mms->address)\n\t\treturn;\n\tprev->size += mms->size;\n\tRB_REMOVE(mmtree, &mm->rb_free, mms);\n\tif (mm->mmalloc == NULL)\n\t\tfree(mms);\n\telse\n\t\tmm_free(mm->mmalloc, mms);\n}", "target": 1}
{"code": "exo_open_find_scheme (const gchar *string)\n{\n  gchar *current_dir;\n  gchar *uri;\n  gchar *path;\n  if (g_path_is_absolute (string))\n    return exo_open_get_path (string);\n  current_dir = g_get_current_dir ();\n  path = g_build_filename (current_dir, string, NULL);\n  g_free (current_dir);\n  if (g_file_test (path, G_FILE_TEST_EXISTS))\n    {\n       uri = exo_open_get_path (path);\n       g_free (path);\n       return uri;\n    }\n  g_free (path);\n  if (g_regex_match_simple (MATCH_PATTERN_EMAIL, string, G_REGEX_CASELESS, 0))\n    return g_strconcat (\"mailto:\", string, NULL);\n  if (g_regex_match_simple (MATCH_PATTERN_HTTP, string, G_REGEX_CASELESS, 0))\n    return g_strconcat (\"http:\n  return NULL;\n}", "target": 0}
{"code": "struct resource_pool *dce112_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\tif (!pool)\n\t\treturn NULL;\n\tif (construct(num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\tkfree(pool);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 0}
{"code": "static char *tls_text_name(X509_NAME *name, int nid)\n{\n\tint     pos;\n\tX509_NAME_ENTRY *entry;\n\tASN1_STRING *entry_str;\n\tint     utf8_length;\n\tunsigned char *utf8_value;\n\tchar *result;\n\tif (name == 0 || (pos = X509_NAME_get_index_by_NID(name, nid, -1)) < 0) {\n\t\treturn NULL;\n    }\n    entry = X509_NAME_get_entry(name, pos);\n    g_return_val_if_fail(entry != NULL, NULL);\n    entry_str = X509_NAME_ENTRY_get_data(entry);\n    g_return_val_if_fail(entry_str != NULL, NULL);\n    if ((utf8_length = ASN1_STRING_to_UTF8(&utf8_value, entry_str)) < 0) {\n    \tg_warning(\"Error decoding ASN.1 type=%d\", ASN1_STRING_type(entry_str));\n    \treturn NULL;\n    }\n    if (has_internal_nul((char *)utf8_value, utf8_length)) {\n    \tg_warning(\"NUL character in hostname in certificate\");\n    \tOPENSSL_free(utf8_value);\n    \treturn NULL;\n    }\n    result = g_strdup((char *) utf8_value);\n\tOPENSSL_free(utf8_value);\n\treturn result;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& filter = context->input(1);\n    const Tensor& out_backprop = context->input(2);\n    int stride_rows = 0, stride_cols = 0;\n    int rate_rows = 0, rate_cols = 0;\n    int64 pad_top = 0, pad_left = 0;\n    int64 out_rows = 0, out_cols = 0;\n    ParseSizes(context, strides_, rates_, padding_, &stride_rows, &stride_cols,\n               &rate_rows, &rate_cols, &pad_top, &pad_left, &out_rows,\n               &out_cols);\n    if (!context->status().ok()) return;\n    const int batch = input.dim_size(0);\n    const int depth = input.dim_size(3);\n    OP_REQUIRES(context,\n                batch == out_backprop.dim_size(0) &&\n                    out_rows == out_backprop.dim_size(1) &&\n                    out_cols == out_backprop.dim_size(2) &&\n                    depth == out_backprop.dim_size(3),\n                errors::InvalidArgument(\"out_backprop has incompatible size.\"));\n    Tensor* in_backprop = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input.shape(), &in_backprop));\n    if (input.shape().num_elements() == 0) {\n      return;\n    }\n    functor::DilationBackpropInput<Device, T>()(\n        context->eigen_device<Device>(), input.tensor<T, 4>(),\n        filter.tensor<T, 3>(), out_backprop.tensor<T, 4>(), stride_rows,\n        stride_cols, rate_rows, rate_cols, pad_top, pad_left,\n        in_backprop->tensor<T, 4>());\n  }", "target": 0}
{"code": "void NavigationControllerImpl::LoadIfNecessary() {\n  if (!needs_reload_)\n    return;\n  if (pending_entry_) {\n    NavigateToPendingEntry(ReloadType::NONE, nullptr );\n  } else if (last_committed_entry_index_ != -1) {\n    pending_entry_ = entries_[last_committed_entry_index_].get();\n    pending_entry_index_ = last_committed_entry_index_;\n    NavigateToPendingEntry(ReloadType::NONE, nullptr );\n  } else {\n    needs_reload_ = false;\n  }\n}", "target": 0}
{"code": "ORDER *simple_remove_const(ORDER *order, COND *where)\n{\n  if (!order || !where)\n    return order;\n  ORDER *first= NULL, *prev= NULL;\n  for (; order; order= order->next)\n  {\n    DBUG_ASSERT(!order->item[0]->with_sum_func()); \n    if (!const_expression_in_where(where, order->item[0]))\n    {\n      if (!first)\n        first= order;\n      if (prev)\n        prev->next= order;\n      prev= order;\n    }\n  }\n  if (prev)\n    prev->next= NULL;\n  return first;\n}", "target": 0}
{"code": "uint32_t negate_negative_int32(int32_t x)\n{\n  assert(x <= 0);\n  if (x == INT32_MIN) {\n    return static_cast<uint32_t>(INT32_MAX) + 1;\n  }\n  else {\n    return static_cast<uint32_t>(-x);\n  }\n}", "target": 0}
{"code": "static void spl_filesystem_dir_it_current_data(zend_object_iterator *iter, zval ***data TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n\t*data = &iterator->current;\n}", "target": 0}
{"code": "para_macro_process(uschar *p, uschar *q)\n{\nint length = q - p;\nargstr **pp;\nmacrodef *md;\nmacroexe *me;\nfor (md = macrolist; md != NULL; md = md->next)\n  {\n  if (length == md->namelength && Ustrncmp(p, md->name, length) == 0) break;\n  }\nif (md == NULL)\n  {\n  error(23, length, p);\n  (void)fprintf(outfile, \"&\");\n  return p;\n  }\nme = misc_malloc(sizeof(macroexe));\nme->prev = macrocurrent;\nmacrocurrent = me;\nme->macro = md;\nme->nextline = md->lines;\nif (from_type_ptr >= FROM_TYPE_STACKSIZE - 1) error(32);  \nfrom_type[++from_type_ptr] = FROM_MACRO;\nme->args = NULL;\npp = &(me->args);\nwhile (isspace(*(++q)));\nwhile (*q != 0 && *q != ')')\n  {\n  argstr *as = misc_malloc(sizeof(argstr));\n  as->next = NULL;\n  *pp = as;\n  pp = &(as->next);\n  as->string = misc_readitem(q, US\",)\", &length, NULL, 0);\n  q += length;\n  if (*q == ',') while (isspace(*(++q)));\n  }\nif (*q != ')')\n  {\n  error(24, p);\n  (void)fprintf(outfile, \"&\");\n  return p;\n  }\npara_inline_macro++;\nfor (;;)\n  {\n  uschar buffer[INBUFFSIZE];\n  read_process_macroline(macrocurrent->nextline->string, buffer);\n  if (*buffer == '.')\n    {\n    dot_process(buffer);\n    if (macrocurrent != me) break;\n    }\n  else\n    {\n    uschar *qq = buffer + Ustrlen(buffer);\n    while (qq > buffer && isspace(qq[-1])) qq--;\n    *qq = 0;\n    para_process(buffer);\n    }\n  macrocurrent->nextline = macrocurrent->nextline->next;\n  if (macrocurrent->nextline == NULL)\n    {\n    macroexe *temp = macrocurrent;\n    macrocurrent = macrocurrent->prev;\n    macro_free(temp);\n    from_type_ptr--;\n    break;\n    }\n  }\npara_inline_macro--;\nreturn q + 1;\n}", "target": 1}
{"code": "static void lateeoi_list_add(struct irq_info *info)\n{\n\tstruct lateeoi_work *eoi = &per_cpu(lateeoi, info->eoi_cpu);\n\tstruct irq_info *elem;\n\tu64 now = get_jiffies_64();\n\tunsigned long delay;\n\tunsigned long flags;\n\tif (now < info->eoi_time)\n\t\tdelay = info->eoi_time - now;\n\telse\n\t\tdelay = 1;\n\tspin_lock_irqsave(&eoi->eoi_list_lock, flags);\n\tif (list_empty(&eoi->eoi_list)) {\n\t\tlist_add(&info->eoi_list, &eoi->eoi_list);\n\t\tmod_delayed_work_on(info->eoi_cpu, system_wq,\n\t\t\t\t    &eoi->delayed, delay);\n\t} else {\n\t\tlist_for_each_entry_reverse(elem, &eoi->eoi_list, eoi_list) {\n\t\t\tif (elem->eoi_time <= info->eoi_time)\n\t\t\t\tbreak;\n\t\t}\n\t\tlist_add(&info->eoi_list, &elem->eoi_list);\n\t}\n\tspin_unlock_irqrestore(&eoi->eoi_list_lock, flags);\n}", "target": 0}
{"code": "BOOL rdp_read_share_control_header(wStream* s, UINT16* length, UINT16* type, UINT16* channel_id)\n{\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\tStream_Read_UINT16(s, *length); \n\tif (*length == 0x8000)\n\t{\n\t\trdp_read_flow_control_pdu(s, type);\n\t\t*channel_id = 0;\n\t\t*length = 8; \n\t\treturn TRUE;\n\t}\n\tif (((size_t)*length - 2) > Stream_GetRemainingLength(s))\n\t\treturn FALSE;\n\tStream_Read_UINT16(s, *type); \n\t*type &= 0x0F;                \n\tif (*length > 4)\n\t\tStream_Read_UINT16(s, *channel_id); \n\telse\n\t\t*channel_id = 0; \n\treturn TRUE;\n}", "target": 1}
{"code": "const char* ewk_view_setting_encoding_custom_get(const Evas_Object* ewkView)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, 0);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, 0);\n    Evas_Object* main_frame = ewk_view_frame_main_get(ewkView);\n    WebCore::Frame* core_frame = EWKPrivate::coreFrame(main_frame);\n    String overrideEncoding = core_frame->loader()->documentLoader()->overrideEncoding();\n    if (overrideEncoding.isEmpty())\n        return 0;\n    eina_stringshare_replace(&priv->settings.encodingCustom, overrideEncoding.utf8().data());\n    return priv->settings.encodingCustom;\n}", "target": 0}
{"code": "static void xcopy_pt_undepend_remotedev(struct xcopy_op *xop)\n{\n\tstruct se_device *remote_dev;\n\tif (xop->op_origin == XCOL_SOURCE_RECV_OP)\n\t\tremote_dev = xop->dst_dev;\n\telse\n\t\tremote_dev = xop->src_dev;\n\tpr_debug(\"Calling configfs_undepend_item for\"\n\t\t  \" remote_dev: %p remote_dev->dev_group: %p\\n\",\n\t\t  remote_dev, &remote_dev->dev_group.cg_item);\n\ttarget_undepend_item(&remote_dev->dev_group.cg_item);\n}", "target": 1}
{"code": "static int emulate_store_desc_ptr(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t  void (*get)(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t      struct desc_ptr *ptr))\n{\n\tstruct desc_ptr desc_ptr;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tctxt->op_bytes = 8;\n\tget(ctxt, &desc_ptr);\n\tif (ctxt->op_bytes == 2) {\n\t\tctxt->op_bytes = 4;\n\t\tdesc_ptr.address &= 0x00ffffff;\n\t}\n\tctxt->dst.type = OP_NONE;\n\treturn segmented_write(ctxt, ctxt->dst.addr.mem,\n\t\t\t       &desc_ptr, 2 + ctxt->op_bytes);\n}", "target": 1}
{"code": "CmdExtract::CmdExtract(CommandData *Cmd)\n{\n  CmdExtract::Cmd=Cmd;\n  *ArcName=0;\n  *DestFileName=0;\n  ArcAnalyzed=false;\n  Analyze=new AnalyzeData;\n  memset(Analyze,0,sizeof(*Analyze));\n  TotalFileCount=0;\n  UpLinkExtracted=false;\n  Unp=new Unpack(&DataIO);\n#ifdef RAR_SMP\n  Unp->SetThreads(Cmd->Threads);\n#endif\n}", "target": 0}
{"code": "static inline struct sec_path *skb_sec_path(struct sk_buff *skb)\n{\n\treturn NULL;\n}", "target": 0}
{"code": "static inline bool nvme_is_write(NvmeRequest *req)\n{\n    NvmeRwCmd *rw = (NvmeRwCmd *)&req->cmd;\n    return rw->opcode == NVME_CMD_WRITE ||\n           rw->opcode == NVME_CMD_ZONE_APPEND ||\n           rw->opcode == NVME_CMD_WRITE_ZEROES;\n}", "target": 0}
{"code": "vhost_scsi_make_tpg(struct se_wwn *wwn,\n\t\t   struct config_group *group,\n\t\t   const char *name)\n{\n\tstruct vhost_scsi_tport *tport = container_of(wwn,\n\t\t\tstruct vhost_scsi_tport, tport_wwn);\n\tstruct vhost_scsi_tpg *tpg;\n\tunsigned long tpgt;\n\tint ret;\n\tif (strstr(name, \"tpgt_\") != name)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (kstrtoul(name + 5, 10, &tpgt) || tpgt > UINT_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\ttpg = kzalloc(sizeof(struct vhost_scsi_tpg), GFP_KERNEL);\n\tif (!tpg) {\n\t\tpr_err(\"Unable to allocate struct vhost_scsi_tpg\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tmutex_init(&tpg->tv_tpg_mutex);\n\tINIT_LIST_HEAD(&tpg->tv_tpg_list);\n\ttpg->tport = tport;\n\ttpg->tport_tpgt = tpgt;\n\tret = core_tpg_register(&vhost_scsi_fabric_configfs->tf_ops, wwn,\n\t\t\t\t&tpg->se_tpg, tpg, TRANSPORT_TPG_TYPE_NORMAL);\n\tif (ret < 0) {\n\t\tkfree(tpg);\n\t\treturn NULL;\n\t}\n\tmutex_lock(&vhost_scsi_mutex);\n\tlist_add_tail(&tpg->tv_tpg_list, &vhost_scsi_list);\n\tmutex_unlock(&vhost_scsi_mutex);\n\treturn &tpg->se_tpg;\n}", "target": 1}
{"code": "Item *Item_hex_constant::safe_charset_converter(CHARSET_INFO *tocs)\n{\n  Item_string *conv;\n  String tmp, *str= val_str(&tmp);\n  if (!(conv= new Item_string(str->ptr(), str->length(), tocs)))\n    return NULL;\n  conv->str_value.copy();\n  conv->str_value.mark_as_const();\n  return conv;\n}", "target": 0}
{"code": "service_info *FindServiceEventURLPath(\n\tservice_table *table, const char *eventURLPath)\n{\n\tservice_info *finger = NULL;\n\turi_type parsed_url;\n\turi_type parsed_url_in;\n\tif (table &&\n\t\tparse_uri(eventURLPath, strlen(eventURLPath), &parsed_url_in) ==\n\t\t\tHTTP_SUCCESS) {\n\t\tfinger = table->serviceList;\n\t\twhile (finger) {\n\t\t\tif (finger->eventURL) {\n\t\t\t\tif (parse_uri(finger->eventURL,\n\t\t\t\t\t    strlen(finger->eventURL),\n\t\t\t\t\t    &parsed_url) == HTTP_SUCCESS) {\n\t\t\t\t\tif (!token_cmp(&parsed_url.pathquery,\n\t\t\t\t\t\t    &parsed_url_in.pathquery)) {\n\t\t\t\t\t\treturn finger;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinger = finger->next;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "add_mibfile(const char* tmpstr, const char* d_name, FILE *ip )\n{\n    FILE           *fp;\n    char            token[MAXTOKEN], token2[MAXTOKEN];\n    if ((fp = fopen(tmpstr, \"r\")) == NULL) {\n        snmp_log_perror(tmpstr);\n        return 1;\n    }\n    DEBUGMSGTL((\"parse-mibs\", \"Checking file: %s...\\n\",\n                tmpstr));\n    mibLine = 1;\n    File = tmpstr;\n    if (get_token(fp, token, MAXTOKEN) != LABEL) {\n\t    fclose(fp);\n\t    return 1;\n    }\n    if (get_token(fp, token2, MAXTOKEN) == DEFINITIONS) {\n        new_module(token, tmpstr);\n        if (ip)\n            fprintf(ip, \"%s %s\\n\", token, d_name);\n        fclose(fp);\n        return 0;\n    } else {\n        fclose(fp);\n        return 1;\n    }\n}", "target": 1}
{"code": "void HeaderMapImpl::removePrefix(const LowerCaseString& prefix) {\n  headers_.remove_if([&](const HeaderEntryImpl& entry) {\n    bool to_remove = absl::StartsWith(entry.key().getStringView(), prefix.get());\n    if (to_remove) {\n      EntryCb cb = ConstSingleton<StaticLookupTable>::get().find(entry.key().getStringView());\n      if (cb) {\n        StaticLookupResponse ref_lookup_response = cb(*this);\n        if (ref_lookup_response.entry_) {\n          *ref_lookup_response.entry_ = nullptr;\n        }\n      }\n    }\n    return to_remove;\n  });\n}", "target": 1}
{"code": "static pdf_creator_t *new_creator(int *n_elements)\n{\n    pdf_creator_t *daddy;\n    static const pdf_creator_t creator_template[] = \n    {\n        {\"Title\",        \"\"},\n        {\"Author\",       \"\"},\n        {\"Subject\",      \"\"},\n        {\"Keywords\",     \"\"},\n        {\"Creator\",      \"\"},\n        {\"Producer\",     \"\"},\n        {\"CreationDate\", \"\"},\n        {\"ModDate\",      \"\"},\n        {\"Trapped\",      \"\"},\n    };\n    daddy = malloc(sizeof(creator_template));\n    memcpy(daddy, creator_template, sizeof(creator_template));\n    if (n_elements)\n      *n_elements = sizeof(creator_template) / sizeof(creator_template[0]);\n    return daddy;\n}", "target": 1}
{"code": "suppress_quant_table (JPEGState* sp, int tblno)\n{\n\tJQUANT_TBL* qtbl;\n\tif ((qtbl = sp->cinfo.c.quant_tbl_ptrs[tblno]) != NULL)\n\t\tqtbl->sent_table = TRUE;\n}", "target": 0}
{"code": "GF_Err ainf_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_AssetInformationBox *ptr = (GF_AssetInformationBox *) s;\n\tISOM_DECREASE_SIZE(s, 4)\n\tptr->profile_version = gf_bs_read_u32(bs);\n\treturn gf_isom_read_null_terminated_string(s, bs, s->size, &ptr->APID);\n}", "target": 0}
{"code": "static TEE_Result do_allocate_publickey(struct dsa_public_key *key,\n\t\t\t\t\tsize_t l_bits, size_t n_bits)\n{\n\tDSA_TRACE(\"DSA Allocate Public of L=%zu bits and N=%zu bits\", l_bits,\n\t\t  n_bits);\n\tmemset(key, 0, sizeof(*key));\n\tkey->g = crypto_bignum_allocate(l_bits);\n\tif (!key->g)\n\t\tgoto err;\n\tkey->p = crypto_bignum_allocate(l_bits);\n\tif (!key->p)\n\t\tgoto err;\n\tkey->q = crypto_bignum_allocate(n_bits);\n\tif (!key->q)\n\t\tgoto err;\n\tkey->y = crypto_bignum_allocate(l_bits);\n\tif (!key->y)\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tDSA_TRACE(\"Allocation error\");\n\tcrypto_bignum_free(key->g);\n\tcrypto_bignum_free(key->p);\n\tcrypto_bignum_free(key->q);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "void AudioManagerBase::GetAudioInputDeviceNames(\n    media::AudioDeviceNames* device_names) {\n}", "target": 0}
{"code": "  double sessionTimeout() const { return _sessionTimeout; }", "target": 0}
{"code": "static void jpeg2000_init_static_data(AVCodec *codec)\n{\n    ff_jpeg2000_init_tier1_luts();\n    ff_mqc_init_context_tables();\n}", "target": 0}
{"code": "int pico_tcp_initconn(struct pico_socket *s)\n{\n    struct pico_socket_tcp *ts = TCP_SOCK(s);\n    struct pico_frame *syn;\n    struct pico_tcp_hdr *hdr;\n    uint16_t mtu, opt_len = tcp_options_size(ts, PICO_TCP_SYN);\n    syn = s->net->alloc(s->stack, s->net, NULL, (uint16_t)(PICO_SIZE_TCPHDR + opt_len));\n    if (!syn)\n        return -1;\n    hdr = (struct pico_tcp_hdr *) syn->transport_hdr;\n    if (!ts->snd_nxt)\n        ts->snd_nxt = long_be(pico_paws());\n    ts->snd_last = ts->snd_nxt;\n    ts->cwnd = PICO_TCP_IW;\n    mtu = (uint16_t)pico_socket_get_mss(s);\n    ts->mss = (uint16_t)(mtu - PICO_SIZE_TCPHDR);\n    ts->ssthresh = (uint16_t)((uint16_t)(PICO_DEFAULT_SOCKETQ / ts->mss) -  (((uint16_t)(PICO_DEFAULT_SOCKETQ / ts->mss)) >> 3u));\n    syn->sock = s;\n    hdr->seq = long_be(ts->snd_nxt);\n    hdr->len = (uint8_t)((PICO_SIZE_TCPHDR + opt_len) << 2);\n    hdr->flags = PICO_TCP_SYN;\n    tcp_set_space(ts);\n    hdr->rwnd = short_be(ts->wnd);\n    tcp_add_options(ts, syn, PICO_TCP_SYN, opt_len);\n    hdr->trans.sport = ts->sock.local_port;\n    hdr->trans.dport = ts->sock.remote_port;\n    hdr->crc = 0;\n    hdr->crc = short_be(pico_tcp_checksum(syn));\n    tcp_dbg(\"Sending SYN... (ports: %d - %d) size: %d\\n\", short_be(ts->sock.local_port), short_be(ts->sock.remote_port), syn->buffer_len);\n    ts->retrans_tmr = pico_timer_add(s->stack, PICO_TCP_SYN_TO << ts->backoff, initconn_retry, ts);\n    if (!ts->retrans_tmr) {\n        tcp_dbg(\"TCP: Failed to start initconn_retry timer\\n\");\n        PICO_FREE(syn);\n        return -1;\n    }\n    pico_enqueue(&s->stack->q_tcp.out, syn);\n    return 0;\n}", "target": 1}
{"code": "spnego_gss_verify_mic(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tconst gss_buffer_t msg_buffer,\n\t\tconst gss_buffer_t token_buffer,\n\t\tgss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tret = gss_verify_mic(minor_status,\n\t\t\t    context_handle,\n\t\t\t    msg_buffer,\n\t\t\t    token_buffer,\n\t\t\t    qop_state);\n\treturn (ret);\n}", "target": 1}
{"code": "static unsigned int caif_poll(struct file *file,\n\t\t\t\tstruct socket *sock, poll_table *wait)\n{\n\tstruct sock *sk = sock->sk;\n\tunsigned int mask;\n\tstruct caifsock *cf_sk = container_of(sk, struct caifsock, sk);\n\tsock_poll_wait(file, sk_sleep(sk), wait);\n\tmask = 0;\n\tif (sk->sk_err)\n\t\tmask |= POLLERR;\n\tif (sk->sk_shutdown == SHUTDOWN_MASK)\n\t\tmask |= POLLHUP;\n\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\tmask |= POLLRDHUP;\n\tif (!skb_queue_empty(&sk->sk_receive_queue) ||\n\t\t(sk->sk_shutdown & RCV_SHUTDOWN))\n\t\tmask |= POLLIN | POLLRDNORM;\n\tif (sock_writeable(sk) && tx_flow_is_on(cf_sk))\n\t\tmask |= POLLOUT | POLLWRNORM | POLLWRBAND;\n\treturn mask;\n}", "target": 0}
{"code": "print_line_header(Dwarf_Debug dbg,\n    Dwarf_Bool is_single_tab,\n    Dwarf_Bool is_actuals_tab)\n{\nif (!is_single_tab) {\nif (is_actuals_tab) {\n_dwarf_printf(dbg,\"\\nActuals Table\\n\");\n_dwarf_printf(dbg,\n\"                                                         be\\n\"\n\"                                                         ls\\n\"\n\"                                                         ce\\n\"\n\" section    op                                           kq\\n\"\n\" offset     code                address/index    row isa ??\\n\");\n    return;\n} else {\n_dwarf_printf(dbg,\"\\nLogicals Table\\n\");\n_dwarf_printf(dbg,\n\"                                                                              s pe\\n\"\n\"                                                                              tirp\\n\"\n\"                                                                              msoi\\n\"\n\" section          op                                                          tall\\n\"\n\" offset      row  code                address/indx fil lne col disc cntx subp ????\\n\");\n    return;\n}\n}\n_dwarf_printf(dbg,\n\"                                                         s b e p e i d\\n\"\n\"                                                         t l s r p s i\\n\"\n\"                                                         m c e o i a s\\n\"\n\" section    op                                       col t k q l l   c\\n\"\n\" offset     code               address     file line umn ? ? ? ? ?\\n\");\n} ", "target": 1}
{"code": "static void adpt_i2o_report_hba_unit(adpt_hba* pHba, struct i2o_device *d)\n{\n\tchar buf[64];\n\tint unit = d->lct_data.tid;\n\tprintk(KERN_INFO \"TID %3.3d \", unit);\n\tif(adpt_i2o_query_scalar(pHba, unit, 0xF100, 3, buf, 16)>=0)\n\t{\n\t\tbuf[16]=0;\n\t\tprintk(\" Vendor: %-12.12s\", buf);\n\t}\n\tif(adpt_i2o_query_scalar(pHba, unit, 0xF100, 4, buf, 16)>=0)\n\t{\n\t\tbuf[16]=0;\n\t\tprintk(\" Device: %-12.12s\", buf);\n\t}\n\tif(adpt_i2o_query_scalar(pHba, unit, 0xF100, 6, buf, 8)>=0)\n\t{\n\t\tbuf[8]=0;\n\t\tprintk(\" Rev: %-12.12s\\n\", buf);\n\t}\n#ifdef DEBUG\n\t printk(KERN_INFO \"\\tClass: %.21s\\n\", adpt_i2o_get_class_name(d->lct_data.class_id));\n\t printk(KERN_INFO \"\\tSubclass: 0x%04X\\n\", d->lct_data.sub_class);\n\t printk(KERN_INFO \"\\tFlags: \");\n\t if(d->lct_data.device_flags&(1<<0))\n\t\t  printk(\"C\");\t     \n\t if(d->lct_data.device_flags&(1<<1))\n\t\t  printk(\"U\");\t     \n\t if(!(d->lct_data.device_flags&(1<<4)))\n\t\t  printk(\"P\");\t     \n\t if(!(d->lct_data.device_flags&(1<<5)))\n\t\t  printk(\"M\");\t     \n\t printk(\"\\n\");\n#endif\n}", "target": 1}
{"code": "static size_t ssl_compute_padding_length( size_t len,\n                                          size_t granularity )\n{\n    return( ( granularity - ( len + 1 ) % granularity ) % granularity );\n}", "target": 0}
{"code": "static inline int restore_fpu_checking(struct task_struct *tsk)\n{\n\talternative_input(\n\t\tASM_NOP8 ASM_NOP2,\n\t\t\"emms\\n\\t\"\t\t\n\t\t\"fildl %P[addr]\",\t\n\t\tX86_FEATURE_FXSAVE_LEAK,\n\t\t[addr] \"m\" (tsk->thread.fpu.has_fpu));\n\treturn fpu_restore_checking(&tsk->thread.fpu);\n}", "target": 1}
{"code": "_dbus_fd_set_close_on_exec (intptr_t fd)\n{\n  int val;\n  val = fcntl (fd, F_GETFD, 0);\n  if (val < 0)\n    return;\n  val |= FD_CLOEXEC;\n  fcntl (fd, F_SETFD, val);\n}", "target": 0}
{"code": "void decodingXOR(char* extractedString, char* keyString, char* xoredString, int bufferLength)\n{\n\tint i;\n\tif(isCodingInverted){\n\t\tfor (i = 0; i < bufferLength; ++i)\n\t\t{\n\t\t\txoredString[i] = unscrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)extractedString[i]] ^ keyString[i];\n\t\t}\n\t}else{\n\t\tfor (i = 0; i < bufferLength; ++i)\n\t\t{\n\t\t\txoredString[i] = unscrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)(extractedString[i] ^ keyString[i])];\n\t\t}\n\t}\n}", "target": 1}
{"code": "void test_open(const char *path)\n{\n\tint fd = open(path, O_RDONLY);\n\tif (fd >= 0) {\n\t\tfprintf(stderr, \"leak at open of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at open of %s: errno was %d\\n\", path, errno);\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "void ext4_es_insert_delayed_block(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t\t  bool allocated)\n{\n\tstruct extent_status newes;\n\tint err1 = 0;\n\tint err2 = 0;\n\tstruct extent_status *es1 = NULL;\n\tstruct extent_status *es2 = NULL;\n\tif (EXT4_SB(inode->i_sb)->s_mount_state & EXT4_FC_REPLAY)\n\t\treturn;\n\tes_debug(\"add [%u/1) delayed to extent status tree of inode %lu\\n\",\n\t\t lblk, inode->i_ino);\n\tnewes.es_lblk = lblk;\n\tnewes.es_len = 1;\n\text4_es_store_pblock_status(&newes, ~0, EXTENT_STATUS_DELAYED);\n\ttrace_ext4_es_insert_delayed_block(inode, &newes, allocated);\n\text4_es_insert_extent_check(inode, &newes);\nretry:\n\tif (err1 && !es1)\n\t\tes1 = __es_alloc_extent(true);\n\tif ((err1 || err2) && !es2)\n\t\tes2 = __es_alloc_extent(true);\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\terr1 = __es_remove_extent(inode, lblk, lblk, NULL, es1);\n\tif (err1 != 0)\n\t\tgoto error;\n\terr2 = __es_insert_extent(inode, &newes, es2);\n\tif (err2 != 0)\n\t\tgoto error;\n\tif (allocated)\n\t\t__insert_pending(inode, lblk);\n\tif (es1 && !es1->es_len)\n\t\t__es_free_extent(es1);\n\tif (es2 && !es2->es_len)\n\t\t__es_free_extent(es2);\nerror:\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\tif (err1 || err2)\n\t\tgoto retry;\n\text4_es_print_tree(inode);\n\text4_print_pending_tree(inode);\n\treturn;\n}", "target": 1}
{"code": "static int hexagon_v6_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAnalOpMask mask) {\n\tHexInsn hi = {0};;\n\tut32 data = 0;\n\tdata = r_read_le32 (buf);\n\tint size = hexagon_disasm_instruction (data, &hi, (ut32) addr);\n\top->size = size;\n\tif (size <= 0) {\n\t\treturn size;\n\t}\n\top->addr = addr;\n\treturn hexagon_anal_instruction (&hi, op);\n}", "target": 1}
{"code": "set_cs_start(const char* line)\n{\n    static int cs_start_set = 0;\n    char *p, *q, *r;\n    if ((p = strstr(line, \"string currentfile\"))\n        && strstr(line, \"readstring\")) {\n        for (q = p; q != line && q[-1] != '/'; --q)\n            ;\n        if (q != line) {\n            for (r = q; r != p && !isspace((unsigned char) *r) && *r != '{'; ++r)\n                ;\n            if (cs_start_set)\n                free((char*) cs_start);\n            cs_start = p = malloc(r - q + 1);\n            memcpy(p, q, r - q);\n            p[r - q] = 0;\n            cs_start_set = 1;\n        }\n    }\n}", "target": 0}
{"code": "size_t CxMemFile::Read(void *buffer, size_t size, size_t count)\n{\n\tif (buffer==NULL) return 0;\n\tif (m_pBuffer==NULL) return 0;\n\tif (m_Position >= (int32_t)m_Size){\n\t\tm_bEOF = true;\n\t\treturn 0;\n\t}\n\tint32_t nCount = (int32_t)(count*size);\n\tif (nCount == 0) return 0;\n\tint32_t nRead;\n\tif (m_Position + nCount > (int32_t)m_Size){\n\t\tm_bEOF = true;\n\t\tnRead = (m_Size - m_Position);\n\t} else\n\t\tnRead = nCount;\n\tmemcpy(buffer, m_pBuffer + m_Position, nRead);\n\tm_Position += nRead;\n\treturn (size_t)(nRead/size);\n}", "target": 1}
{"code": "static int mmac_rotate(const MMacro *mac, unsigned int n)\n{\n    if (--n < mac->nparam)\n        n = (n + mac->rotate) % mac->nparam;\n    return n+1;\n}", "target": 0}
{"code": "static int lua_websocket_close(lua_State *L) \n{\n    apr_socket_t *sock;\n    char prelude[2];\n    request_rec *r = ap_lua_check_request_rec(L, 1);\n    sock = ap_get_conn_socket(r->connection);\n    prelude[0] = 0x88; \n    prelude[1] = 0; \n    ap_rwrite(prelude, 2, r);\n    apr_socket_close(sock);\n    r->output_filters = NULL;\n    r->connection->keepalive = AP_CONN_CLOSE;\n    return 0;\n}", "target": 0}
{"code": "static inline bool StateSynSentValidateTimestamp(TcpSession *ssn, Packet *p)\n{\n    if (PKT_IS_TOSERVER(p) || !(TCP_HAS_TS(p))) {\n        return true;\n    }\n    TcpStream *receiver_stream = &ssn->client;\n    uint32_t ts_echo = TCP_GET_TSECR(p);\n    if ((receiver_stream->flags & STREAMTCP_STREAM_FLAG_TIMESTAMP) != 0) {\n        if (receiver_stream->last_ts != 0 && ts_echo != 0 &&\n            ts_echo != receiver_stream->last_ts)\n        {\n            SCLogDebug(\"ssn %p: BAD TSECR echo %u recv %u\", ssn,\n                    ts_echo, receiver_stream->last_ts);\n            return false;\n        }\n    } else {\n        if (receiver_stream->last_ts == 0 && ts_echo != 0) {\n            SCLogDebug(\"ssn %p: BAD TSECR echo %u recv %u\", ssn,\n                    ts_echo, receiver_stream->last_ts);\n            return false;\n        }\n    }\n    return true;\n}", "target": 0}
{"code": "spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n\t\t      gss_ctx_id_t context_handle,\n\t\t      int *conf_state,\n\t\t      gss_qop_t *qop_state,\n\t\t      gss_iov_buffer_desc *iov,\n\t\t      int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_unwrap_iov(minor_status,\n\t\t\t     context_handle,\n\t\t\t     conf_state,\n\t\t\t     qop_state,\n\t\t\t     iov,\n\t\t\t     iov_count);\n\treturn (ret);\n}", "target": 1}
{"code": "static int rename_in_ns(int pid, char *oldname, char **newnamep)\n{\n\tint fd = -1, ofd = -1, ret, ifindex = -1;\n\tbool grab_newname = false;\n\tofd = lxc_preserve_ns(getpid(), \"net\");\n\tif (ofd < 0) {\n\t\tfprintf(stderr, \"Failed opening network namespace path for '%d'.\", getpid());\n\t\treturn -1;\n\t}\n\tfd = lxc_preserve_ns(pid, \"net\");\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Failed opening network namespace path for '%d'.\", pid);\n\t\treturn -1;\n\t}\n\tif (setns(fd, 0) < 0) {\n\t\tfprintf(stderr, \"setns to container network namespace\\n\");\n\t\tgoto out_err;\n\t}\n\tclose(fd); fd = -1;\n\tif (!*newnamep) {\n\t\tgrab_newname = true;\n\t\t*newnamep = VETH_DEF_NAME;\n\t\tif (!(ifindex = if_nametoindex(oldname))) {\n\t\t\tfprintf(stderr, \"failed to get netdev index\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\tif ((ret = lxc_netdev_rename_by_name(oldname, *newnamep)) < 0) {\n\t\tfprintf(stderr, \"Error %d renaming netdev %s to %s in container\\n\", ret, oldname, *newnamep);\n\t\tgoto out_err;\n\t}\n\tif (grab_newname) {\n\t\tchar ifname[IFNAMSIZ], *namep = ifname;\n\t\tif (!if_indextoname(ifindex, namep)) {\n\t\t\tfprintf(stderr, \"Failed to get new netdev name\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t\t*newnamep = strdup(namep);\n\t\tif (!*newnamep)\n\t\t\tgoto out_err;\n\t}\n\tif (setns(ofd, 0) < 0) {\n\t\tfprintf(stderr, \"Error returning to original netns\\n\");\n\t\tclose(ofd);\n\t\treturn -1;\n\t}\n\tclose(ofd);\n\treturn 0;\nout_err:\n\tif (ofd >= 0)\n\t\tclose(ofd);\n\tif (setns(ofd, 0) < 0)\n\t\tfprintf(stderr, \"Error returning to original network namespace\\n\");\n\tif (fd >= 0)\n\t\tclose(fd);\n\treturn -1;\n}", "target": 1}
{"code": "TEST(Random, SecureFork) {\n  unsigned char buffer = 0;\n  folly::Random::secureRandom(&buffer, 1);\n  auto pid = fork();\n  EXPECT_NE(pid, -1);\n  if (pid) {\n    int status = 0;\n    folly::Random::secureRandom(&buffer, 1);\n    auto pid2 = wait(&status);\n    EXPECT_NE(WEXITSTATUS(status), buffer);\n    EXPECT_EQ(pid, pid2);\n  } else {\n    folly::Random::secureRandom(&buffer, 1);\n    exit(buffer); \n  }\n}", "target": 0}
{"code": "struct clock_source *dcn20_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\tif (!clk_src)\n\t\treturn NULL;\n\tif (dcn20_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 0}
{"code": "kg_seal_iov(OM_uint32 *minor_status,\n            gss_ctx_id_t context_handle,\n            int conf_req_flag,\n            gss_qop_t qop_req,\n            int *conf_state,\n            gss_iov_buffer_desc *iov,\n            int iov_count,\n            int toktype)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    krb5_error_code code;\n    krb5_context context;\n    if (qop_req != 0) {\n        *minor_status = (OM_uint32)G_UNKNOWN_QOP;\n        return GSS_S_FAILURE;\n    }\n    ctx = (krb5_gss_ctx_id_rec *)context_handle;\n    if (!ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return GSS_S_NO_CONTEXT;\n    }\n    if (conf_req_flag && kg_integ_only_iov(iov, iov_count)) {\n        conf_req_flag = FALSE;\n    }\n    context = ctx->k5_context;\n    switch (ctx->proto) {\n    case 0:\n        code = make_seal_token_v1_iov(context, ctx, conf_req_flag,\n                                      conf_state, iov, iov_count, toktype);\n        break;\n    case 1:\n        code = gss_krb5int_make_seal_token_v3_iov(context, ctx, conf_req_flag,\n                                                  conf_state, iov, iov_count, toktype);\n        break;\n    default:\n        code = G_UNKNOWN_QOP;\n        break;\n    }\n    if (code != 0) {\n        *minor_status = code;\n        save_error_info(*minor_status, context);\n        return GSS_S_FAILURE;\n    }\n    *minor_status = 0;\n    return GSS_S_COMPLETE;\n}", "target": 1}
{"code": "static inline void tss_invalidate_io_bitmap(void)\n{\n\tPVOP_VCALL0(cpu.invalidate_io_bitmap);\n}", "target": 0}
{"code": "test_validate_path_meta (void)\n{\n  gsize idx;\n  for (idx = 0; idx < G_N_ELEMENTS (invalid_path_meta); idx++)\n    {\n      g_autoptr(FlatpakContext) context = flatpak_context_new ();\n      g_autoptr(GKeyFile) metakey = g_key_file_new ();\n      g_autoptr(GError) local_error = NULL;\n      PathValidityData *data = &invalid_path_meta[idx];\n      gboolean ret = FALSE;\n      g_key_file_set_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                  data->key, &data->value, 1);\n      ret = flatpak_context_load_metadata (context, metakey, &local_error);\n      g_assert_false (ret);\n      g_assert_error (local_error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA);\n      g_assert (strstr (local_error->message, \"Non-graphical character\"));\n    }\n}", "target": 0}
{"code": "bool OmniboxViewWin::IsSelectAll() {\n  CHARRANGE selection;\n  GetSel(selection);\n  return IsSelectAllForRange(selection);\n}", "target": 0}
{"code": "  bool Messageheader::Parser::state_fieldbody_crlf(char ch)\n  {\n    if (ch == '\\r')\n      SET_STATE(state_end_cr);\n    else if (ch == '\\n')\n    {\n      log_debug(\"header \" << fieldnamePtr << \": \" << fieldbodyPtr);\n      switch (header.onField(fieldnamePtr, fieldbodyPtr))\n      {\n        case OK:\n        case END:  return true;\n                   break;\n        case FAIL: failedFlag = true;\n                   log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody\");\n                   break;\n      }\n      *headerdataPtr = '\\0';\n      return true;\n    }\n    else if (std::isspace(ch))\n    {\n      checkHeaderspace(1);\n      *(headerdataPtr - 1) = '\\n';\n      *headerdataPtr++ = ch;\n      SET_STATE(state_fieldbody);\n    }\n    else if (ch >= 33 && ch <= 126)\n    {\n      switch (header.onField(fieldnamePtr, fieldbodyPtr))\n      {\n        case OK:   SET_STATE(state_fieldname);\n                   break;\n        case FAIL: failedFlag = true;\n                   log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody\");\n                   break;\n        case END:  return true;\n                   break;\n      }\n      fieldnamePtr = headerdataPtr;\n      checkHeaderspace(1);\n      *headerdataPtr++ = ch;\n    }\n    return false;\n  }", "target": 0}
{"code": "zisofs_rewind_boot_file(struct archive_write *a)\n{\n\tstruct iso9660 *iso9660 = a->format_data;\n\tif (iso9660->el_torito.boot->file->zisofs.header_size != 0) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"We cannot extract the zisofs imaged boot file;\"\n\t\t    \" this may not boot in being zisofs imaged\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\treturn (ARCHIVE_OK);\n}", "target": 0}
{"code": "static void start_daemon()\n{\n\tstruct usb_sock_t *usb_sock;\n\tif (g_options.noprinter_mode == 0) {\n\t\tusb_sock = usb_open();\n\t\tif (usb_sock == NULL)\n\t\t\tgoto cleanup_usb;\n\t} else\n\t\tusb_sock = NULL;\n\tuint16_t desired_port = g_options.desired_port;\n\tstruct tcp_sock_t *tcp_socket;\n\twhile ((tcp_socket = tcp_open(desired_port)) == NULL &&\n\t       g_options.only_desired_port == 0) {\n\t\tdesired_port ++;\n\t\tif (desired_port == 1 || desired_port == 0)\n\t\t\tdesired_port = 49152;\n\t}\n\tif (tcp_socket == NULL)\n\t\tgoto cleanup_tcp;\n\tuint16_t real_port = tcp_port_number_get(tcp_socket);\n\tif (desired_port != 0 && g_options.only_desired_port == 1 &&\n\t    desired_port != real_port) {\n\t\tERR(\"Received port number did not match requested port number.\"\n\t\t    \" The requested port number may be too high.\");\n\t\tgoto cleanup_tcp;\n\t}\n\tprintf(\"%u|\", real_port);\n\tfflush(stdout);\n\tuint16_t pid;\n\tif (!g_options.nofork_mode && (pid = fork()) > 0) {\n\t\tprintf(\"%u|\", pid);\n\t\texit(0);\n\t}\n\tif (usb_can_callback(usb_sock))\n\t\tusb_register_callback(usb_sock);\n\tfor (;;) {\n\t\tstruct service_thread_param *args = calloc(1, sizeof(*args));\n\t\tif (args == NULL) {\n\t\t\tERR(\"Failed to alloc space for thread args\");\n\t\t\tgoto cleanup_thread;\n\t\t}\n\t\targs->usb_sock = usb_sock;\n\t\targs->tcp = tcp_conn_accept(tcp_socket);\n\t\tif (args->tcp == NULL) {\n\t\t\tERR(\"Failed to open tcp connection\");\n\t\t\tgoto cleanup_thread;\n\t\t}\n\t\tint status = pthread_create(&args->thread_handle, NULL,\n\t\t                            &service_connection, args);\n\t\tif (status) {\n\t\t\tERR(\"Failed to spawn thread, error %d\", status);\n\t\t\tgoto cleanup_thread;\n\t\t}\n\t\tcontinue;\n\tcleanup_thread:\n\t\tif (args != NULL) {\n\t\t\tif (args->tcp != NULL)\n\t\t\t\ttcp_conn_close(args->tcp);\n\t\t\tfree(args);\n\t\t}\n\t\tbreak;\n\t}\ncleanup_tcp:\n\tif (tcp_socket!= NULL)\n\t\ttcp_close(tcp_socket);\ncleanup_usb:\n\tif (usb_sock != NULL)\n\t\tusb_close(usb_sock);\n\treturn;\n}", "target": 1}
{"code": "void FrameLoader::checkCompleted()\n{\n    RefPtr<Frame> protect(m_frame);\n    m_shouldCallCheckCompleted = false;\n    if (m_frame->view())\n        m_frame->view()->handleLoadCompleted();\n    if (m_isComplete)\n        return;\n    if (m_frame->document()->parsing())\n        return;\n    if (m_frame->document()->fetcher()->requestCount())\n        return;\n    if (m_frame->document()->isDelayingLoadEvent())\n        return;\n    if (!allChildrenAreComplete())\n        return;\n    m_isComplete = true;\n    m_requestedHistoryItem = 0;\n    m_frame->document()->setReadyState(Document::Complete);\n    if (m_frame->document()->loadEventStillNeeded())\n        m_frame->document()->implicitClose();\n    m_frame->navigationScheduler()->startTimer();\n    completed();\n    if (m_frame->page())\n        checkLoadComplete();\n    if (m_frame->view())\n        m_frame->view()->handleLoadCompleted();\n}", "target": 0}
{"code": "local unsigned long crc32_big(crc, buf, len)\n    unsigned long crc;\n    const unsigned char FAR *buf;\n    unsigned len;\n{\n    register z_crc_t c;\n    register const z_crc_t FAR *buf4;\n    c = ZSWAP32((z_crc_t)crc);\n    c = ~c;\n    while (len && ((ptrdiff_t)buf & 3)) {\n        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);\n        len--;\n    }\n    buf4 = (const z_crc_t FAR *)(const void FAR *)buf;\n    buf4--;\n    while (len >= 32) {\n        DOBIG32;\n        len -= 32;\n    }\n    while (len >= 4) {\n        DOBIG4;\n        len -= 4;\n    }\n    buf4++;\n    buf = (const unsigned char FAR *)buf4;\n    if (len) do {\n        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);\n    } while (--len);\n    c = ~c;\n    return (unsigned long)(ZSWAP32(c));\n}", "target": 1}
{"code": "rs_filter_graph(RSFilter *filter)\n{\n\tg_return_if_fail(RS_IS_FILTER(filter));\n\tGString *str = g_string_new(\"digraph G {\\n\");\n\trs_filter_graph_helper(str, filter);\n\tg_string_append_printf(str, \"}\\n\");\n\tg_file_set_contents(\"/tmp/rs-filter-graph\", str->str, str->len, NULL);\n\tif (0 != system(\"dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph\"))\n\t\tg_warning(\"Calling dot failed\");\n\tif (0 != system(\"gnome-open /tmp/rs-filter-graph.png\"))\n\t\tg_warning(\"Calling gnome-open failed.\");\n\tg_string_free(str, TRUE);\n}", "target": 1}
{"code": "static int fdt_check_no_at(const void *fit, int parent)\n{\n\tconst char *name;\n\tint node;\n\tint ret;\n\tname = fdt_get_name(fit, parent, NULL);\n\tif (!name || strchr(name, '@'))\n\t\treturn -EADDRNOTAVAIL;\n\tfdt_for_each_subnode(node, fit, parent) {\n\t\tret = fdt_check_no_at(fit, node);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int getlblockinc(Jpeg2000DecoderContext *s)\n{\n    int res = 0, ret;\n    while (ret = get_bits(s, 1)) {\n        if (ret < 0)\n            return ret;\n        res++;\n    }\n    return res;\n}", "target": 0}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* data =\n      reinterpret_cast<TfLiteAudioMicrofrontendParams*>(node->user_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 1);\n  TF_LITE_ENSURE_EQ(context, input->type, kTfLiteInt16);\n  output->type = kTfLiteInt32;\n  if (data->out_float) {\n    output->type = kTfLiteFloat32;\n  }\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(2);\n  int num_frames = 0;\n  if (input->dims->data[0] >= data->state->window.size) {\n    num_frames = (input->dims->data[0] - data->state->window.size) /\n                     data->state->window.step / data->frame_stride +\n                 1;\n  }\n  output_size->data[0] = num_frames;\n  output_size->data[1] = data->state->filterbank.num_channels *\n                         (1 + data->left_context + data->right_context);\n  return context->ResizeTensor(context, output, output_size);\n}", "target": 1}
{"code": "QList<QList<QByteArray>> CoreNetwork::splitMessage(const QString &cmd, const QString &message, std::function<QList<QByteArray>(QString &)> cmdGenerator)\n{\n    QString wrkMsg(message);\n    QList<QList<QByteArray>> msgsToSend;\n    do {\n        int splitPos = wrkMsg.size();\n        QList<QByteArray> initialSplitMsgEnc = cmdGenerator(wrkMsg);\n        int initialOverrun = userInputHandler()->lastParamOverrun(cmd, initialSplitMsgEnc);\n        if (initialOverrun) {\n            QString splitMsg(wrkMsg);\n            QTextBoundaryFinder qtbf(QTextBoundaryFinder::Word, splitMsg);\n            qtbf.setPosition(initialSplitMsgEnc[1].size() - initialOverrun);\n            QList<QByteArray> splitMsgEnc;\n            int overrun = initialOverrun;\n            while (overrun) {\n                splitPos = qtbf.toPreviousBoundary();\n                if (splitPos > 0) {\n                    splitMsg = splitMsg.left(splitPos);\n                    splitMsgEnc = cmdGenerator(splitMsg);\n                    overrun = userInputHandler()->lastParamOverrun(cmd, splitMsgEnc);\n                }\n                else {\n                    if (qtbf.type() == QTextBoundaryFinder::Word) {\n                        splitMsg = wrkMsg;\n                        splitPos = splitMsg.size();\n                        QTextBoundaryFinder graphemeQtbf(QTextBoundaryFinder::Grapheme, splitMsg);\n                        graphemeQtbf.setPosition(initialSplitMsgEnc[1].size() - initialOverrun);\n                        qtbf = graphemeQtbf;\n                    }\n                    else {\n                        qWarning() << \"Unexpected failure to split message!\";\n                        return msgsToSend;\n                    }\n                }\n            }\n            wrkMsg.remove(0, splitPos);\n            msgsToSend.append(splitMsgEnc);\n        }\n        else{\n            wrkMsg.remove(0, splitPos);\n            msgsToSend.append(initialSplitMsgEnc);\n        }\n    } while (wrkMsg.size() > 0);\n    return msgsToSend;\n}", "target": 0}
{"code": "static int sgi_timer_set(struct k_itimer *timr, int flags,\n\tstruct itimerspec * new_setting,\n\tstruct itimerspec * old_setting)\n{\n\tunsigned long when, period, irqflags;\n\tint err = 0;\n\tcnodeid_t nodeid;\n\tstruct mmtimer *base;\n\tstruct rb_node *n;\n\tif (old_setting)\n\t\tsgi_timer_get(timr, old_setting);\n\tsgi_timer_del(timr);\n\twhen = timespec_to_ns(new_setting->it_value);\n\tperiod = timespec_to_ns(new_setting->it_interval);\n\tif (when == 0)\n\t\treturn 0;\n\tbase = kmalloc(sizeof(struct mmtimer), GFP_KERNEL);\n\tif (base == NULL)\n\t\treturn -ENOMEM;\n\tif (flags & TIMER_ABSTIME) {\n\t\tstruct timespec n;\n\t\tunsigned long now;\n\t\tgetnstimeofday(&n);\n\t\tnow = timespec_to_ns(n);\n\t\tif (when > now)\n\t\t\twhen -= now;\n\t\telse\n\t\t\twhen = 0;\n\t}\n\twhen = (when + sgi_clock_period - 1) / sgi_clock_period + rtc_time();\n\tperiod = (period + sgi_clock_period - 1)  / sgi_clock_period;\n\tpreempt_disable();\n\tnodeid =  cpu_to_node(smp_processor_id());\n\tspin_lock_irqsave(&timers[nodeid].lock, irqflags);\n\tbase->timer = timr;\n\tbase->cpu = smp_processor_id();\n\ttimr->it.mmtimer.clock = TIMER_SET;\n\ttimr->it.mmtimer.node = nodeid;\n\ttimr->it.mmtimer.incr = period;\n\ttimr->it.mmtimer.expires = when;\n\tn = timers[nodeid].next;\n\tmmtimer_add_list(base);\n\tif (timers[nodeid].next == n) {\n\t\tspin_unlock_irqrestore(&timers[nodeid].lock, irqflags);\n\t\tpreempt_enable();\n\t\treturn err;\n\t}\n\tif (n)\n\t\tmmtimer_disable_int(cnodeid_to_nasid(nodeid), COMPARATOR);\n\tmmtimer_set_next_timer(nodeid);\n\tspin_unlock_irqrestore(&timers[nodeid].lock, irqflags);\n\tpreempt_enable();\n\treturn err;\n}", "target": 1}
{"code": "static int propagate_one(struct mount *m)\n{\n\tstruct mount *child;\n\tint type;\n\tif (IS_MNT_NEW(m))\n\t\treturn 0;\n\tif (!is_subdir(mp->m_dentry, m->mnt.mnt_root))\n\t\treturn 0;\n\tif (peers(m, last_dest)) {\n\t\ttype = CL_MAKE_SHARED;\n\t} else {\n\t\tstruct mount *n, *p;\n\t\tfor (n = m; ; n = p) {\n\t\t\tp = n->mnt_master;\n\t\t\tif (p == dest_master || IS_MNT_MARKED(p)) {\n\t\t\t\twhile (last_dest->mnt_master != p) {\n\t\t\t\t\tlast_source = last_source->mnt_master;\n\t\t\t\t\tlast_dest = last_source->mnt_parent;\n\t\t\t\t}\n\t\t\t\tif (!peers(n, last_dest)) {\n\t\t\t\t\tlast_source = last_source->mnt_master;\n\t\t\t\t\tlast_dest = last_source->mnt_parent;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttype = CL_SLAVE;\n\t\tif (IS_MNT_SHARED(m))\n\t\t\ttype |= CL_MAKE_SHARED;\n\t}\n\tif (m->mnt_ns->user_ns != user_ns)\n\t\ttype |= CL_UNPRIVILEGED;\n\tchild = copy_tree(last_source, last_source->mnt.mnt_root, type);\n\tif (IS_ERR(child))\n\t\treturn PTR_ERR(child);\n\tchild->mnt.mnt_flags &= ~MNT_LOCKED;\n\tmnt_set_mountpoint(m, mp, child);\n\tlast_dest = m;\n\tlast_source = child;\n\tif (m->mnt_master != dest_master) {\n\t\tread_seqlock_excl(&mount_lock);\n\t\tSET_MNT_MARK(m->mnt_master);\n\t\tread_sequnlock_excl(&mount_lock);\n\t}\n\thlist_add_head(&child->mnt_hash, list);\n\treturn 0;\n}", "target": 1}
{"code": "static int redirect_to_splashpage(struct MHD_Connection *connection, t_client *client, const char *host, const char *url)\n{\n\tchar *originurl_raw;\n\tchar *originurl;\n\tchar *query;\n\tint ret = 0;\n\tconst char *separator = \"&\";\n\tchar *querystr;\n\tquery = safe_calloc(QUERYMAXLEN);\n\tif (!query) {\n\t\tret = send_error(connection, 503);\n\t\tfree(query);\n\t\treturn ret;\n\t}\n\tquerystr = safe_calloc(QUERYMAXLEN);\n\tif (!querystr) {\n\t\tret = send_error(connection, 503);\n\t\tfree(querystr);\n\t\treturn ret;\n\t}\n\toriginurl_raw = safe_calloc(MID_BUF);\n\tif (!originurl_raw) {\n\t\tret = send_error(connection, 503);\n\t\tfree(originurl_raw);\n\t\treturn ret;\n\t}\n\toriginurl = safe_calloc(CUSTOM_ENC);\n\tif (!originurl) {\n\t\tret = send_error(connection, 503);\n\t\tfree(originurl);\n\t\treturn ret;\n\t}\n\tget_query(connection, &query, separator);\n\tif (!query) {\n\t\tdebug(LOG_DEBUG, \"Unable to get query string - error 503\");\n\t\tfree(query);\n\t\treturn send_error(connection, 503);\n\t}\n\tdebug(LOG_DEBUG, \"Query string is [ %s ]\", query);\n\tsafe_asprintf(&originurl_raw, \"http:\n\tuh_urlencode(originurl, CUSTOM_ENC, originurl_raw, strlen(originurl_raw));\n\tif (strcmp(url, \"/login\") == 0) {\n\t\tclient->cpi_query = safe_strdup(originurl);\n\t\tdebug(LOG_DEBUG, \"RFC8910 request: %s\", client->cpi_query);\n\t} else {\n\t\tclient->cpi_query = \"none\";\n\t}\n\tdebug(LOG_DEBUG, \"originurl_raw: %s\", originurl_raw);\n\tdebug(LOG_DEBUG, \"originurl: %s\", originurl);\n\tquerystr=construct_querystring(connection, client, originurl, querystr);\n\tret = encode_and_redirect_to_splashpage(connection, client, originurl, querystr);\n\tfree(originurl_raw);\n\tfree(originurl);\n\tfree(query);\n\tfree(querystr);\n\treturn ret;\n}", "target": 1}
{"code": "YCPBoolean as_boolean (const YCPValue& v, const char * context)\n{\n    if (v->isBoolean ())\n\treturn v->asBoolean ();\n    ycp2error (\"Expected a boolean for %s, got %s %s\",\n\t       context, v->valuetype_str(), v->toString().c_str());\n    return YCPNull ();\n}", "target": 0}
{"code": "Status SparseReduceShapeFn(InferenceContext* c) {\n  bool keep_dims = false;\n  TF_RETURN_IF_ERROR(c->GetAttr(\"keep_dims\", &keep_dims));\n  const Tensor* shape_tensor = c->input_tensor(2);\n  const Tensor* axes_tensor = c->input_tensor(3);\n  if (shape_tensor != nullptr && axes_tensor != nullptr) {\n    auto shape_vec = shape_tensor->flat<int64>();\n    auto axes_vec = axes_tensor->flat<int32>();\n    int64_t ndims = shape_vec.size();\n    absl::flat_hash_set<int64> axes;\n    if (ndims == 0)\n      return errors::InvalidArgument(\n          \"Number of dims in shape tensor must not be 0\");\n    for (int i = 0; i < axes_vec.size(); i++) {\n      axes.insert((axes_vec(i) + ndims) % ndims);\n    }\n    std::vector<DimensionHandle> dims;\n    if (keep_dims) {\n      dims.reserve(ndims);\n      for (int d = 0; d < ndims; ++d) {\n        if (axes.find(d) == axes.end()) {\n          dims.push_back(c->MakeDim(shape_vec(d)));\n        } else {\n          dims.push_back(c->MakeDim(1));\n        }\n      }\n    } else {\n      for (int d = 0; d < ndims; ++d) {\n        if (axes.find(d) == axes.end()) {\n          dims.push_back(c->MakeDim(shape_vec(d)));\n        }\n      }\n    }\n    c->set_output(0, c->MakeShape(dims));\n    return Status::OK();\n  }\n  return UnknownShape(c);\n}", "target": 0}
{"code": "ModHandle CModules::OpenModule(const CString& sModule, const CString& sModPath,\n                               CModInfo& Info, CString& sRetMsg) {\n    sRetMsg.clear();\n    for (unsigned int a = 0; a < sModule.length(); a++) {\n        if (((sModule[a] < '0') || (sModule[a] > '9')) &&\n            ((sModule[a] < 'a') || (sModule[a] > 'z')) &&\n            ((sModule[a] < 'A') || (sModule[a] > 'Z')) && (sModule[a] != '_')) {\n            sRetMsg =\n                t_f(\"Module names can only contain letters, numbers and \"\n                    \"underscores, [{1}] is invalid\")(sModule);\n            return nullptr;\n        }\n    }\n    ModHandle p = dlopen((sModPath).c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!p) {\n        const char* cDlError = dlerror();\n        CString sDlError = cDlError ? cDlError : t_s(\"Unknown error\");\n        sRetMsg = t_f(\"Unable to open module {1}: {2}\")(sModule, sDlError);\n        return nullptr;\n    }\n    const CModuleEntry* (*fpZNCModuleEntry)() = nullptr;\n    *reinterpret_cast<void**>(&fpZNCModuleEntry) = dlsym(p, \"ZNCModuleEntry\");\n    if (!fpZNCModuleEntry) {\n        dlclose(p);\n        sRetMsg = t_f(\"Could not find ZNCModuleEntry in module {1}\")(sModule);\n        return nullptr;\n    }\n    const CModuleEntry* pModuleEntry = fpZNCModuleEntry();\n    if (std::strcmp(pModuleEntry->pcVersion, VERSION_STR) ||\n        std::strcmp(pModuleEntry->pcVersionExtra, VERSION_EXTRA)) {\n        sRetMsg = t_f(\n            \"Version mismatch for module {1}: core is {2}, module is built for \"\n            \"{3}. Recompile this module.\")(\n            sModule, VERSION_STR VERSION_EXTRA,\n            CString(pModuleEntry->pcVersion) + pModuleEntry->pcVersionExtra);\n        dlclose(p);\n        return nullptr;\n    }\n    if (std::strcmp(pModuleEntry->pcCompileOptions,\n                    ZNC_COMPILE_OPTIONS_STRING)) {\n        sRetMsg = t_f(\n            \"Module {1} is built incompatibly: core is '{2}', module is '{3}'. \"\n            \"Recompile this module.\")(sModule, ZNC_COMPILE_OPTIONS_STRING,\n                                      pModuleEntry->pcCompileOptions);\n        dlclose(p);\n        return nullptr;\n    }\n    CTranslationDomainRefHolder translation(\"znc-\" + sModule);\n    pModuleEntry->fpFillModInfo(Info);\n    sRetMsg = \"\";\n    return p;\n}", "target": 1}
{"code": "static int cac_cac1_get_certificate(sc_card_t *card, u8 **out_buf, size_t *out_len)\n{\n\tu8 buf[CAC_MAX_SIZE];\n\tu8 *out_ptr;\n\tsize_t size = 0;\n\tsize_t left = 0;\n\tsize_t len, next_len;\n\tsc_apdu_t apdu;\n\tint r = SC_SUCCESS;\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tsize = left = *out_buf ? *out_len : sizeof(buf);\n\tout_ptr = *out_buf ? *out_buf : buf;\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, CAC_INS_GET_CERTIFICATE, 0, 0 );\n\tnext_len = MIN(left, 100);\n\tfor (; left > 0; left -= len, out_ptr += len) {\n\t\tlen = next_len;\n\t\tapdu.resp = out_ptr;\n\t\tapdu.le = len;\n\t\tapdu.resplen = left;\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tif (r < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (apdu.resplen == 0) {\n\t\t\tr = SC_ERROR_INTERNAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (apdu.sw1 != 0x63 || apdu.sw2 < 1)  {\n\t\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\t\tleft -= len;\n\t\t\tbreak;\n\t\t}\n\t\tnext_len = MIN(left, apdu.sw2);\n\t}\n\tif (r < 0) {\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n\t}\n\tr = size - left;\n\tif (*out_buf == NULL) {\n\t\t*out_buf = malloc(r);\n\t\tif (*out_buf == NULL) {\n\t\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,\n\t\t\t\tSC_ERROR_OUT_OF_MEMORY);\n\t\t}\n\t\tmemcpy(*out_buf, buf, r);\n\t}\n\t*out_len = r;\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n}", "target": 1}
{"code": "MakeFilename(char *buffer, char *orig_name, int cnt, int max_chars)\n{\n        char *filename = malloc(PATH_MAX + 1);\n        if (filename == NULL)\n            error(\"%s: malloc\", __func__);\n        if (Gflag != 0) {\n          struct tm *local_tm;\n          if ((local_tm = localtime(&Gflag_time)) == NULL) {\n                  error(\"%s: localtime\", __func__);\n          }\n          strftime(filename, PATH_MAX, orig_name, local_tm);\n        } else {\n          strncpy(filename, orig_name, PATH_MAX);\n        }\n\tif (cnt == 0 && max_chars == 0)\n\t\tstrncpy(buffer, filename, PATH_MAX + 1);\n\telse\n\t\tif (snprintf(buffer, PATH_MAX + 1, \"%s%0*d\", filename, max_chars, cnt) > PATH_MAX)\n                  error(\"too many output files or filename is too long (> %d)\", PATH_MAX);\n        free(filename);\n}", "target": 1}
{"code": "inline TfLiteStatus ValidateTensorIndexingSafe(const TfLiteContext* context,\n                                               int index, int max_size,\n                                               const int* tensor_indices,\n                                               int* tensor_index) {\n  if (index < 0 || index >= max_size) {\n    TF_LITE_KERNEL_LOG(const_cast<TfLiteContext*>(context),\n                       \"Invalid tensor index %d (not in [0, %d))\\n\", index,\n                       max_size);\n    return kTfLiteError;\n  }\n  if (tensor_indices[index] == kTfLiteOptionalTensor) {\n    TF_LITE_KERNEL_LOG(const_cast<TfLiteContext*>(context),\n                       \"Tensor at index %d was optional but was expected\\n\",\n                       index);\n    return kTfLiteError;\n  }\n  *tensor_index = tensor_indices[index];\n  return kTfLiteOk;\n}", "target": 0}
{"code": "txid_snapshot_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tTxidSnapshot *snap;\n\ttxid\t\tlast = 0;\n\tint\t\t\tnxip;\n\tint\t\t\ti;\n\tint\t\t\tavail;\n\tint\t\t\texpect;\n\ttxid\t\txmin,\n\t\t\t\txmax;\n\tnxip = pq_getmsgint(buf, 4);\n\tavail = buf->len - buf->cursor;\n\texpect = 8 + 8 + nxip * 8;\n\tif (nxip < 0 || nxip > avail || expect > avail)\n\t\tgoto bad_format;\n\txmin = pq_getmsgint64(buf);\n\txmax = pq_getmsgint64(buf);\n\tif (xmin == 0 || xmax == 0 || xmin > xmax || xmax > MAX_TXID)\n\t\tgoto bad_format;\n\tsnap = palloc(TXID_SNAPSHOT_SIZE(nxip));\n\tsnap->xmin = xmin;\n\tsnap->xmax = xmax;\n\tsnap->nxip = nxip;\n\tSET_VARSIZE(snap, TXID_SNAPSHOT_SIZE(nxip));\n\tfor (i = 0; i < nxip; i++)\n\t{\n\t\ttxid\t\tcur = pq_getmsgint64(buf);\n\t\tif (cur <= last || cur < xmin || cur >= xmax)\n\t\t\tgoto bad_format;\n\t\tsnap->xip[i] = cur;\n\t\tlast = cur;\n\t}\n\tPG_RETURN_POINTER(snap);\nbad_format:\n\telog(ERROR, \"invalid snapshot data\");\n\treturn (Datum) NULL;\n}", "target": 1}
{"code": "static int t220_frontend_attach(struct dvb_usb_adapter *d)\n{\n\tu8 obuf[3] = { 0xe, 0x87, 0 };\n\tu8 ibuf[] = { 0 };\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x86;\n\tobuf[2] = 1;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x80;\n\tobuf[2] = 0;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tmsleep(50);\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x80;\n\tobuf[2] = 1;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tobuf[0] = 0x51;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x51 transfer failed.\");\n\td->fe_adap[0].fe = dvb_attach(cxd2820r_attach, &cxd2820r_config,\n\t\t\t\t\t&d->dev->i2c_adap, NULL);\n\tif (d->fe_adap[0].fe != NULL) {\n\t\tif (dvb_attach(tda18271_attach, d->fe_adap[0].fe, 0x60,\n\t\t\t\t\t&d->dev->i2c_adap, &tda18271_config)) {\n\t\t\tinfo(\"Attached TDA18271HD/CXD2820R!\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tinfo(\"Failed to attach TDA18271HD/CXD2820R!\");\n\treturn -EIO;\n}", "target": 1}
{"code": "MYSQL_PARAMETERS *STDCALL mysql_get_parameters(void)\n{\n  return &mysql_internal_parameters;\n}", "target": 0}
{"code": "static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    int item_num = avio_rb32(pb);\n    int item_len = avio_rb32(pb);\n    if (item_len != 18) {\n        avpriv_request_sample(pb, \"Primer pack item length %d\", item_len);\n        return AVERROR_PATCHWELCOME;\n    }\n    if (item_num > 65536) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"item_num %d is too large\\n\", item_num);\n        return AVERROR_INVALIDDATA;\n    }\n    if (mxf->local_tags)\n        av_log(mxf->fc, AV_LOG_VERBOSE, \"Multiple primer packs\\n\");\n    av_free(mxf->local_tags);\n    mxf->local_tags_count = 0;\n    mxf->local_tags = av_calloc(item_num, item_len);\n    if (!mxf->local_tags)\n        return AVERROR(ENOMEM);\n    mxf->local_tags_count = item_num;\n    avio_read(pb, mxf->local_tags, item_num*item_len);\n    return 0;\n}", "target": 1}
{"code": "#ifndef GPAC_DISABLE_ISOM_HINTING\nvoid dump_isom_sdp(GF_ISOFile *file, char *inName, Bool is_final_name)\n{\n\tconst char *sdp;\n\tu32 size, i;\n\tFILE *dump;\n\tif (inName) {\n\t\tchar szBuf[1024];\n\t\tstrcpy(szBuf, inName);\n\t\tif (!is_final_name) {\n\t\t\tchar *ext = strchr(szBuf, '.');\n\t\t\tif (ext) ext[0] = 0;\n\t\t\tstrcat(szBuf, \"_sdp.txt\");\n\t\t}\n\t\tdump = gf_fopen(szBuf, \"wt\");\n\t\tif (!dump) {\n\t\t\tfprintf(stderr, \"Failed to open %s for dumping\\n\", szBuf);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tdump = stdout;\n\t\tfprintf(dump, \"* File SDP content *\\n\\n\");\n\t}\n\tgf_isom_sdp_get(file, &sdp, &size);\n\tfprintf(dump, \"%s\", sdp);\n\tfprintf(dump, \"\\r\\n\");\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tif (gf_isom_get_media_type(file, i+1) != GF_ISOM_MEDIA_HINT) continue;\n\t\tgf_isom_sdp_track_get(file, i+1, &sdp, &size);\n\t\tfprintf(dump, \"%s\", sdp);\n\t}\n\tfprintf(dump, \"\\n\\n\");", "target": 1}
{"code": "static int nl80211_dump_survey(struct sk_buff *skb,\n\t\t\tstruct netlink_callback *cb)\n{\n\tstruct survey_info survey;\n\tstruct cfg80211_registered_device *dev;\n\tstruct net_device *netdev;\n\tint survey_idx = cb->args[1];\n\tint res;\n\tres = nl80211_prepare_netdev_dump(skb, cb, &dev, &netdev);\n\tif (res)\n\t\treturn res;\n\tif (!dev->ops->dump_survey) {\n\t\tres = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\twhile (1) {\n\t\tstruct ieee80211_channel *chan;\n\t\tres = rdev_dump_survey(dev, netdev, survey_idx, &survey);\n\t\tif (res == -ENOENT)\n\t\t\tbreak;\n\t\tif (res)\n\t\t\tgoto out_err;\n\t\tif (!survey.channel) {\n\t\t\tres = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tchan = ieee80211_get_channel(&dev->wiphy,\n\t\t\t\t\t     survey.channel->center_freq);\n\t\tif (!chan || chan->flags & IEEE80211_CHAN_DISABLED) {\n\t\t\tsurvey_idx++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (nl80211_send_survey(skb,\n\t\t\t\tNETLINK_CB(cb->skb).portid,\n\t\t\t\tcb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\tnetdev,\n\t\t\t\t&survey) < 0)\n\t\t\tgoto out;\n\t\tsurvey_idx++;\n\t}\n out:\n\tcb->args[1] = survey_idx;\n\tres = skb->len;\n out_err:\n\tnl80211_finish_netdev_dump(dev);\n\treturn res;\n}", "target": 0}
{"code": "static void parse_media(pj_scanner *scanner, pjmedia_sdp_media *med,\n\t\t\tvolatile parse_context *ctx)\n{\n    pj_str_t str;\n    ctx->last_error = PJMEDIA_SDP_EINMEDIA;\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n    pj_scan_get_until_ch(scanner, ' ', &med->desc.media);\n    pj_scan_get_char(scanner);\n    pj_scan_get(scanner, &cs_token, &str);\n    med->desc.port = (unsigned short)pj_strtoul(&str);\n    if (*scanner->curptr == '/') {\n\tpj_scan_get_char(scanner);\n\tpj_scan_get(scanner, &cs_token, &str);\n\tmed->desc.port_count = pj_strtoul(&str);\n    } else {\n\tmed->desc.port_count = 0;\n    }\n    if (pj_scan_get_char(scanner) != ' ') {\n\tPJ_THROW(SYNTAX_ERROR);\n    }\n    pj_scan_get_until_chr(scanner, \" \\t\\r\\n\", &med->desc.transport);\n    med->desc.fmt_count = 0;\n    while (*scanner->curptr == ' ') {\n\tpj_str_t fmt;\n\tpj_scan_get_char(scanner);\n\tif ((*scanner->curptr == '\\r') || (*scanner->curptr == '\\n'))\n\t\tbreak;\n\tpj_scan_get(scanner, &cs_token, &fmt);\n\tif (med->desc.fmt_count < PJMEDIA_MAX_SDP_FMT)\n\t    med->desc.fmt[med->desc.fmt_count++] = fmt;\n\telse\n\t    PJ_PERROR(2,(THIS_FILE, PJ_ETOOMANY, \n\t\t         \"Error adding SDP media format %.*s, \"\n\t\t\t \"format is ignored\",\n\t\t\t (int)fmt.slen, fmt.ptr));\n    }\n    pj_scan_skip_line(scanner);\n}", "target": 1}
{"code": "static void dp8393x_instance_init(Object *obj)\n{\n    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);\n    dp8393xState *s = DP8393X(obj);\n    sysbus_init_mmio(sbd, &s->mmio);\n    sysbus_init_mmio(sbd, &s->prom);\n    sysbus_init_irq(sbd, &s->irq);\n}", "target": 0}
{"code": "struct tcp_sock_t *tcp_open(uint16_t port)\n{\n\tstruct tcp_sock_t *this = calloc(1, sizeof *this);\n\tif (this == NULL) {\n\t\tERR(\"callocing this failed\");\n\t\tgoto error;\n\t}\n\tthis->sd = -1;\n\tthis->sd = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (this->sd < 0) {\n\t\tERR(\"sockect open failed\");\n\t\tgoto error;\n\t}\n\tstruct sockaddr_in6 addr;\n\tmemset(&addr, 0, sizeof addr);\n\taddr.sin6_family = AF_INET6;\n\taddr.sin6_port = htons(port);\n\taddr.sin6_addr = in6addr_any;\n\tif (bind(this->sd,\n\t        (struct sockaddr *)&addr,\n\t        sizeof addr) < 0) {\n\t\tif (g_options.only_desired_port == 1)\n\t\t\tERR(\"Bind on port failed. \"\n\t\t\t    \"Requested port may be taken or require root permissions.\");\n\t\tgoto error;\n\t}\n\tif (listen(this->sd, HTTP_MAX_PENDING_CONNS) < 0) {\n\t\tERR(\"listen failed on socket\");\n\t\tgoto error;\n\t}\n\treturn this;\nerror:\n\tif (this != NULL) {\n\t\tif (this->sd != -1) {\n\t\t\tclose(this->sd);\n\t\t}\n\t\tfree(this);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "PJ_DEF(pj_status_t) pjmedia_rtp_decode_rtp2(\n\t\t\t\t\t    pjmedia_rtp_session *ses,\n\t\t\t\t\t    const void *pkt, int pkt_len,\n\t\t\t\t\t    const pjmedia_rtp_hdr **hdr,\n\t\t\t\t\t    pjmedia_rtp_dec_hdr *dec_hdr,\n\t\t\t\t\t    const void **payload,\n\t\t\t\t\t    unsigned *payloadlen)\n{\n    int offset;\n    PJ_UNUSED_ARG(ses);\n    *hdr = (pjmedia_rtp_hdr*)pkt;\n    if ((*hdr)->v != RTP_VERSION) {\n\treturn PJMEDIA_RTP_EINVER;\n    }\n    offset = sizeof(pjmedia_rtp_hdr) + ((*hdr)->cc * sizeof(pj_uint32_t));\n    if ((*hdr)->x) {\n        if (offset + sizeof (pjmedia_rtp_ext_hdr) > (unsigned)pkt_len)\n            return PJMEDIA_RTP_EINLEN;\n        dec_hdr->ext_hdr = (pjmedia_rtp_ext_hdr*)(((pj_uint8_t*)pkt) + offset);\n        dec_hdr->ext = (pj_uint32_t*)(dec_hdr->ext_hdr + 1);\n        dec_hdr->ext_len = pj_ntohs((dec_hdr->ext_hdr)->length);\n        offset += ((dec_hdr->ext_len + 1) * sizeof(pj_uint32_t));\n    } else {\n\tdec_hdr->ext_hdr = NULL;\n\tdec_hdr->ext = NULL;\n\tdec_hdr->ext_len = 0;\n    }\n    if (offset > pkt_len)\n\treturn PJMEDIA_RTP_EINLEN;\n    *payload = ((pj_uint8_t*)pkt) + offset;\n    *payloadlen = pkt_len - offset;\n    if ((*hdr)->p && *payloadlen > 0) {\n\tpj_uint8_t pad_len;\n\tpad_len = ((pj_uint8_t*)(*payload))[*payloadlen - 1];\n\tif (pad_len <= *payloadlen)\n\t    *payloadlen -= pad_len;\n    }\n    return PJ_SUCCESS;\n}", "target": 1}
{"code": "static int crypto_skcipher_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);\n\tstruct skcipher_alg *alg = crypto_skcipher_alg(skcipher);\n\tif (tfm->__crt_alg->cra_type == &crypto_blkcipher_type)\n\t\treturn crypto_init_skcipher_ops_blkcipher(tfm);\n\tif (tfm->__crt_alg->cra_type == &crypto_ablkcipher_type ||\n\t    tfm->__crt_alg->cra_type == &crypto_givcipher_type)\n\t\treturn crypto_init_skcipher_ops_ablkcipher(tfm);\n\tskcipher->setkey = alg->setkey;\n\tskcipher->encrypt = alg->encrypt;\n\tskcipher->decrypt = alg->decrypt;\n\tskcipher->ivsize = alg->ivsize;\n\tskcipher->keysize = alg->max_keysize;\n\tif (alg->exit)\n\t\tskcipher->base.exit = crypto_skcipher_exit_tfm;\n\tif (alg->init)\n\t\treturn alg->init(skcipher);\n\treturn 0;\n}", "target": 1}
{"code": "static int _process_tokenize(mcp_parser_t *pr, const size_t max) {\n    const char *s = pr->request;\n    int len = pr->reqlen - 2;\n    if (len > PARSER_MAXLEN) {\n        len = PARSER_MAXLEN;\n    }\n    const char *end = s + len;\n    int curtoken = 0;\n    int state = 0;\n    while (s != end) {\n        switch (state) {\n            case 0:\n                if (*s != ' ') {\n                    pr->tokens[curtoken] = s - pr->request;\n                    if (++curtoken == max) {\n                        s++;\n                        state = 2;\n                        break;\n                    }\n                    state = 1;\n                }\n                s++;\n                break;\n            case 1:\n                if (*s != ' ') {\n                    s++;\n                } else {\n                    state = 0;\n                }\n                break;\n            case 2:\n                if (*s == ' ') {\n                    goto endloop;\n                }\n                s++;\n                break;\n        }\n    }\nendloop:\n    pr->tokens[curtoken] = s - pr->request;\n    pr->ntokens = curtoken;\n    P_DEBUG(\"%s: cur_tokens: %d\\n\", __func__, curtoken);\n    return 0;\n}", "target": 1}
{"code": "void js_rot(js_State *J, int n)\n{\n\tint i;\n\tjs_Value tmp = STACK[TOP-1];\n\tfor (i = 1; i < n; ++i)\n\t\tSTACK[TOP-i] = STACK[TOP-i-1];\n\tSTACK[TOP-i] = tmp;\n}", "target": 0}
{"code": "static uint64_t unpack_timestamp(const struct efi_time *timestamp)\n{\n\tuint64_t val = 0;\n\tuint16_t year = le32_to_cpu(timestamp->year);\n\tval |= ((uint64_t) timestamp->pad1 & 0xFF) << 0;\n\tval |= ((uint64_t) timestamp->second & 0xFF) << (1*8);\n\tval |= ((uint64_t) timestamp->minute & 0xFF) << (2*8);\n\tval |= ((uint64_t) timestamp->hour & 0xFF) << (3*8);\n\tval |= ((uint64_t) timestamp->day & 0xFF) << (4*8);\n\tval |= ((uint64_t) timestamp->month & 0xFF) << (5*8);\n\tval |= ((uint64_t) year) << (6*8);\n\treturn val;\n}", "target": 1}
{"code": "static void flush_cmd(void)\n{\n    scanned = readnbd = (size_t) 0U;\n}", "target": 0}
{"code": "static netdev_tx_t mcba_usb_start_xmit(struct sk_buff *skb,\n\t\t\t\t       struct net_device *netdev)\n{\n\tstruct mcba_priv *priv = netdev_priv(netdev);\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tstruct mcba_usb_ctx *ctx = NULL;\n\tstruct net_device_stats *stats = &priv->netdev->stats;\n\tu16 sid;\n\tint err;\n\tstruct mcba_usb_msg_can usb_msg = {\n\t\t.cmd_id = MBCA_CMD_TRANSMIT_MESSAGE_EV\n\t};\n\tif (can_dropped_invalid_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\tctx = mcba_usb_get_free_ctx(priv, cf);\n\tif (!ctx)\n\t\treturn NETDEV_TX_BUSY;\n\tif (cf->can_id & CAN_EFF_FLAG) {\n\t\tsid = MCBA_SIDL_EXID_MASK;\n\t\tsid |= (cf->can_id & 0x1ffc0000) >> 13;\n\t\tsid |= (cf->can_id & 0x30000) >> 16;\n\t\tput_unaligned_be16(sid, &usb_msg.sid);\n\t\tput_unaligned_be16(cf->can_id & 0xffff, &usb_msg.eid);\n\t} else {\n\t\tput_unaligned_be16((cf->can_id & CAN_SFF_MASK) << 5,\n\t\t\t\t   &usb_msg.sid);\n\t\tusb_msg.eid = 0;\n\t}\n\tusb_msg.dlc = cf->len;\n\tmemcpy(usb_msg.data, cf->data, usb_msg.dlc);\n\tif (cf->can_id & CAN_RTR_FLAG)\n\t\tusb_msg.dlc |= MCBA_DLC_RTR_MASK;\n\tcan_put_echo_skb(skb, priv->netdev, ctx->ndx, 0);\n\terr = mcba_usb_xmit(priv, (struct mcba_usb_msg *)&usb_msg, ctx);\n\tif (err)\n\t\tgoto xmit_failed;\n\treturn NETDEV_TX_OK;\nxmit_failed:\n\tcan_free_echo_skb(priv->netdev, ctx->ndx, NULL);\n\tmcba_usb_free_ctx(ctx);\n\tdev_kfree_skb(skb);\n\tstats->tx_dropped++;\n\treturn NETDEV_TX_OK;\n}", "target": 1}
{"code": "inline void ImageLoader::ClearFailedLoadURL() {\n  failed_load_url_ = AtomicString();\n}", "target": 0}
{"code": "static SQLRETURN qt_string_SQLSetConnectAttr(SQLHDBC handle, SQLINTEGER attr, const QString &val)\n{\n    auto encoded = toSQLTCHAR(val);\n    return SQLSetConnectAttr(handle, attr,\n                             encoded.data(),\n                             SQLINTEGER(encoded.size() * sizeof(SQLTCHAR))); \n}", "target": 0}
{"code": "void vers_select_conds_t::print(String *str, enum_query_type query_type) const\n{\n  switch (orig_type) {\n  case SYSTEM_TIME_UNSPECIFIED:\n    break;\n  case SYSTEM_TIME_AS_OF:\n    start.print(str, query_type, STRING_WITH_LEN(\" FOR SYSTEM_TIME AS OF \"));\n    break;\n  case SYSTEM_TIME_FROM_TO:\n    start.print(str, query_type, STRING_WITH_LEN(\" FOR SYSTEM_TIME FROM \"));\n    end.print(str, query_type, STRING_WITH_LEN(\" TO \"));\n    break;\n  case SYSTEM_TIME_BETWEEN:\n    start.print(str, query_type, STRING_WITH_LEN(\" FOR SYSTEM_TIME BETWEEN \"));\n    end.print(str, query_type, STRING_WITH_LEN(\" AND \"));\n    break;\n  case SYSTEM_TIME_BEFORE:\n    start.print(str, query_type, STRING_WITH_LEN(\" FOR SYSTEM_TIME BEFORE \"));\n    break;\n  case SYSTEM_TIME_HISTORY:\n    break;\n  case SYSTEM_TIME_ALL:\n    str->append(\" FOR SYSTEM_TIME ALL\");\n    break;\n  }\n}", "target": 0}
{"code": "void RenderView::OnUndo() {\n  if (!webview())\n    return;\n  webview()->focusedFrame()->executeCommand(WebString::fromUTF8(\"Undo\"));\n  UserMetricsRecordAction(\"Undo\");\n}", "target": 0}
{"code": "ElectronNavigationThrottle::WillStartRequest() {\n  auto* handle = navigation_handle();\n  auto* contents = handle->GetWebContents();\n  if (!contents) {\n    NOTREACHED();\n    return PROCEED;\n  }\n  v8::Isolate* isolate = v8::Isolate::GetCurrent();\n  v8::HandleScope scope(isolate);\n  auto api_contents = electron::api::WebContents::From(isolate, contents);\n  if (api_contents.IsEmpty()) {\n    return PROCEED;\n  }\n  if (handle->IsRendererInitiated() && handle->IsInMainFrame() &&\n      api_contents->EmitNavigationEvent(\"will-navigate\", handle)) {\n    return CANCEL;\n  }\n  return PROCEED;\n}", "target": 0}
{"code": "static void lent_destructor(void *arg)\n{\n\tstruct lookup_entry *lent = arg;\n\tmem_deref(lent->host);\n}", "target": 0}
{"code": "void kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP &&\n\t    kvm_is_linear_rip(vcpu, vcpu->arch.singlestep_rip))\n\t\trflags |= X86_EFLAGS_TF;\n\tkvm_x86_ops->set_rflags(vcpu, rflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}", "target": 0}
{"code": "static void draw_fill_color_rgb( wmfAPI* API, const wmfRGB* rgb )\n{\n  PixelWand\n    *fill_color;\n  fill_color=NewPixelWand();\n  PixelSetRedQuantum(fill_color,ScaleCharToQuantum(rgb->r));\n  PixelSetGreenQuantum(fill_color,ScaleCharToQuantum(rgb->g));\n  PixelSetBlueQuantum(fill_color,ScaleCharToQuantum(rgb->b));\n  PixelSetAlphaQuantum(fill_color,OpaqueAlpha);\n  DrawSetFillColor(WmfDrawingWand,fill_color);\n  fill_color=DestroyPixelWand(fill_color);\n}", "target": 0}
{"code": "static int handle_emulation_failure(struct kvm_vcpu *vcpu)\n{\n\tint r = EMULATE_DONE;\n\t++vcpu->stat.insn_emulation_fail;\n\ttrace_kvm_emulate_insn_failed(vcpu);\n\tif (!is_guest_mode(vcpu) && kvm_x86_ops->get_cpl(vcpu) == 0) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\tvcpu->run->internal.ndata = 0;\n\t\tr = EMULATE_FAIL;\n\t}\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn r;\n}", "target": 0}
{"code": "static int segmented_write_std(struct x86_emulate_ctxt *ctxt,\n\t\t\t       struct segmented_address addr,\n\t\t\t       void *data,\n\t\t\t       unsigned int size)\n{\n\tint rc;\n\tulong linear;\n\trc = linearize(ctxt, addr, size, true, &linear);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\treturn ctxt->ops->write_std(ctxt, linear, data, size, &ctxt->exception);\n}", "target": 0}
{"code": "RawTile KakaduImage::getRegion( int seq, int ang, unsigned int res, int layers, int x, int y, unsigned int w, unsigned int h )\n{\n  unsigned int obpc = bpc;\n  if( bpc <= 16 && bpc > 8 ) obpc = 16;\n  else if( bpc <= 8 ) obpc = 8;\n#ifdef DEBUG\n  Timer timer;\n  timer.start();\n#endif\n  RawTile rawtile( 0, res, seq, ang, w, h, channels, obpc );\n  if( obpc == 16 ) rawtile.data = new unsigned short[w*h*channels];\n  else if( obpc == 8 ) rawtile.data = new unsigned char[w*h*channels];\n  else throw file_error( \"Kakadu :: Unsupported number of bits\" );\n  rawtile.dataLength = w*h*channels*(obpc/8);\n  rawtile.filename = getImagePath();\n  rawtile.timestamp = timestamp;\n  process( res, layers, x, y, w, h, rawtile.data );\n#ifdef DEBUG\n  logfile << \"Kakadu :: getRegion() :: \" << timer.getTime() << \" microseconds\" << endl;\n#endif\n  return rawtile;\n}", "target": 1}
{"code": "static int read_payload_length_info(struct LATMContext *ctx, GetBitContext *gb)\n{\n    uint8_t tmp;\n    if (ctx->frame_length_type == 0) {\n        int mux_slot_length = 0;\n        do {\n            tmp = get_bits(gb, 8);\n            mux_slot_length += tmp;\n        } while (tmp == 255);\n        return mux_slot_length;\n    } else if (ctx->frame_length_type == 1) {\n        return ctx->frame_length;\n    } else if (ctx->frame_length_type == 3 ||\n               ctx->frame_length_type == 5 ||\n               ctx->frame_length_type == 7) {\n        skip_bits(gb, 2);          \n    }\n    return 0;\n}", "target": 0}
{"code": "  static bool TryParse(const char* inp, int length,\n                       TypedValue* buf, Variant& out,\n                       JSONContainerType container_type, bool is_tsimplejson) {\n    SimpleParser parser(inp, length, buf, container_type, is_tsimplejson);\n    bool ok = parser.parseValue();\n    parser.skipSpace();\n    if (!ok || parser.p != inp + length) {\n      tvDecRefRange(buf, parser.top);\n      return false;\n    }\n    out = Variant::attach(*--parser.top);\n    return true;\n  }", "target": 1}
{"code": "luks_unlock_start_waiting_for_cleartext_device (UnlockEncryptionData *data)\n{\n  Device *cleartext_device;\n  cleartext_device = find_cleartext_device (data->device);\n  if (cleartext_device != NULL)\n    {\n      update_info (data->device);\n      drain_pending_changes (data->device, FALSE);\n      if (data->hook_func != NULL)\n        {\n          data->hook_func (data->context, cleartext_device, data->hook_user_data);\n        }\n      else\n        {\n          dbus_g_method_return (data->context, cleartext_device->priv->object_path);\n        }\n      unlock_encryption_data_unref (data);\n    }\n  else\n    {\n      data->device_added_signal_handler_id = g_signal_connect_after (data->device->priv->daemon,\n                                                                     \"device-added\",\n                                                                     (GCallback) luks_unlock_device_added_cb,\n                                                                     data);\n      data->device_changed_signal_handler_id = g_signal_connect_after (data->device->priv->daemon,\n                                                                       \"device-changed\",\n                                                                       (GCallback) luks_unlock_device_added_cb,\n                                                                       data);\n      data->device_added_timeout_id = g_timeout_add (15 * 1000, luks_unlock_device_not_seen_cb, data);\n    }\n}", "target": 0}
{"code": "static void *CFRdbLoad(RedisModuleIO *io, int encver) {\n    if (encver > CF_MIN_EXPANSION_VERSION) {\n        return NULL;\n    }\n    CuckooFilter *cf = RedisModule_Calloc(1, sizeof(*cf));\n    cf->numFilters = RedisModule_LoadUnsigned(io);\n    cf->numBuckets = RedisModule_LoadUnsigned(io);\n    cf->numItems = RedisModule_LoadUnsigned(io);\n    if (encver < CF_MIN_EXPANSION_VERSION) { \n        cf->numDeletes = 0;                  \n        cf->bucketSize = CF_DEFAULT_BUCKETSIZE;\n        cf->maxIterations = CF_MAX_ITERATIONS;\n        cf->expansion = CF_DEFAULT_EXPANSION;\n    } else {\n        cf->numDeletes = RedisModule_LoadUnsigned(io);\n        cf->bucketSize = RedisModule_LoadUnsigned(io);\n        cf->maxIterations = RedisModule_LoadUnsigned(io);\n        cf->expansion = RedisModule_LoadUnsigned(io);\n    }\n    cf->filters = RedisModule_Calloc(cf->numFilters, sizeof(*cf->filters));\n    for (size_t ii = 0, exp = 1; ii < cf->numFilters; ++ii, exp *= cf->expansion) {\n        cf->filters[ii].bucketSize = cf->bucketSize;\n        if (encver < CF_MIN_EXPANSION_VERSION) {\n            cf->filters[ii].numBuckets = cf->numBuckets;\n        } else {\n            cf->filters[ii].numBuckets = RedisModule_LoadUnsigned(io);\n        }\n        size_t lenDummy = 0;\n        cf->filters[ii].data = (MyCuckooBucket *)RedisModule_LoadStringBuffer(io, &lenDummy);\n        assert(cf->filters[ii].data != NULL && lenDummy == cf->filters[ii].bucketSize *\n                                                               cf->filters[ii].numBuckets *\n                                                               sizeof(*cf->filters[ii].data));\n    }\n    return cf;\n}", "target": 1}
{"code": "int main()\n{\n\tgdImagePtr im;\n\tFILE *fp;\n\tchar path[1024];\n\tsprintf(path, \"%s/gd2/invalid_neg_size.gd2\", GDTEST_TOP_DIR);\n\tfp = fopen(path, \"rb\");\n\tif (!fp) {\n\t\tprintf(\"failed, cannot open file\\n\");\n\t\treturn 1;\n\t}\n\tim = gdImageCreateFromGd2(fp);\n\tfclose(fp);\n\treturn im == NULL ? 0 : 1;\n}", "target": 0}
{"code": "addnode(struct env *env, const char *key, const char *value)\n{\n\tstruct envnode *node;\n\tnode = createnode(key, value);\n\tRB_INSERT(envtree, &env->root, node);\n\tenv->count++;\n}", "target": 0}
{"code": "static void on_bytes_received(void* context, const unsigned char* buffer, size_t size)\n{\n    unsigned char* new_received_bytes;\n    HTTP_HANDLE_DATA* http_instance = (HTTP_HANDLE_DATA*)context;\n    if (http_instance != NULL)\n    {\n        if (buffer == NULL)\n        {\n            http_instance->is_io_error = 1;\n            LogError(\"NULL pointer error\");\n        }\n        else\n        {\n            new_received_bytes = (unsigned char*)realloc(http_instance->received_bytes, http_instance->received_bytes_count + size);\n            if (new_received_bytes == NULL)\n            {\n                http_instance->is_io_error = 1;\n                LogError(\"Error allocating memory for received data\");\n            }\n            else\n            {\n                http_instance->received_bytes = new_received_bytes;\n                if (memcpy(http_instance->received_bytes + http_instance->received_bytes_count, buffer, size) == NULL)\n                {\n                    http_instance->is_io_error = 1;\n                    LogError(\"Error copping received data to the HTTP bufffer\");\n                }\n                else\n                {\n                    http_instance->received_bytes_count += size;\n                }\n            }\n        }\n    }\n}", "target": 1}
{"code": "encodeJsonStructure(const void *src, const UA_DataType *type, CtxJson *ctx) {\n    if(ctx->depth > UA_JSON_ENCODING_MAX_RECURSION)\n        return UA_STATUSCODE_BADENCODINGERROR;\n    ctx->depth++;\n    status ret = writeJsonObjStart(ctx);\n    uintptr_t ptr = (uintptr_t) src;\n    u8 membersSize = type->membersSize;\n    const UA_DataType * typelists[2] = {UA_TYPES, &type[-type->typeIndex]};\n    for(size_t i = 0; i < membersSize && ret == UA_STATUSCODE_GOOD; ++i) {\n        const UA_DataTypeMember *m = &type->members[i];\n        const UA_DataType *mt = &typelists[!m->namespaceZero][m->memberTypeIndex];\n        if(m->memberName != NULL && *m->memberName != 0)\n            ret |= writeJsonKey(ctx, m->memberName);\n        if(!m->isArray) {\n            ptr += m->padding;\n            size_t memSize = mt->memSize;\n            ret |= encodeJsonJumpTable[mt->typeKind]((const void*) ptr, mt, ctx);\n            ptr += memSize;\n        } else {\n            ptr += m->padding;\n            const size_t length = *((const size_t*) ptr);\n            ptr += sizeof (size_t);\n            ret |= encodeJsonArray(ctx, *(void * const *)ptr, length, mt);\n            ptr += sizeof (void*);\n        }\n    }\n    ret |= writeJsonObjEnd(ctx);\n    ctx->depth--;\n    return ret;\n}", "target": 1}
{"code": "apr_byte_t oidc_post_preserve_javascript(request_rec *r, const char *location,\n\t\tchar **javascript, char **javascript_method) {\n\tif (oidc_cfg_dir_preserve_post(r) == 0)\n\t\treturn FALSE;\n\toidc_debug(r, \"enter\");\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\tconst char *method = oidc_original_request_method(r, cfg, FALSE);\n\tif (apr_strnatcmp(method, OIDC_METHOD_FORM_POST) != 0)\n\t\treturn FALSE;\n\tapr_table_t *params = apr_table_make(r->pool, 8);\n\tif (oidc_util_read_post_params(r, params, FALSE, NULL) == FALSE) {\n\t\toidc_error(r, \"something went wrong when reading the POST parameters\");\n\t\treturn FALSE;\n\t}\n\tconst apr_array_header_t *arr = apr_table_elts(params);\n\tconst apr_table_entry_t *elts = (const apr_table_entry_t*) arr->elts;\n\tint i;\n\tchar *json = \"\";\n\tfor (i = 0; i < arr->nelts; i++) {\n\t\tjson = apr_psprintf(r->pool, \"%s'%s': '%s'%s\", json,\n\t\t\t\toidc_util_escape_string(r, elts[i].key),\n\t\t\t\toidc_util_escape_string(r, elts[i].val),\n\t\t\t\ti < arr->nelts - 1 ? \",\" : \"\");\n\t}\n\tjson = apr_psprintf(r->pool, \"{ %s }\", json);\n\tconst char *jmethod = \"preserveOnLoad\";\n\tconst char *jscript =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        sessionStorage.setItem('mod_auth_openidc_preserve_post_params', JSON.stringify(%s));\\n\"\n\t\t\t\t\t\"        %s\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", jmethod, json,\n\t\t\t\t\tlocation ?\n\t\t\t\t\t\t\tapr_psprintf(r->pool, \"window.location='%s';\\n\",\n\t\t\t\t\t\t\t\t\tlocation) :\n\t\t\t\t\t\t\t\t\t\"\");\n\tif (location == NULL) {\n\t\tif (javascript_method)\n\t\t\t*javascript_method = apr_pstrdup(r->pool, jmethod);\n\t\tif (javascript)\n\t\t\t*javascript = apr_pstrdup(r->pool, jscript);\n\t} else {\n\t\toidc_util_html_send(r, \"Preserving...\", jscript, jmethod,\n\t\t\t\t\"<p>Preserving...</p>\", OK);\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "void * CAPSTONE_API cs_winkernel_malloc(size_t size)\n{\n\tNT_ASSERT(size);\n#pragma prefast(suppress : 30030)\t\t\n\tCS_WINKERNEL_MEMBLOCK *block = (CS_WINKERNEL_MEMBLOCK *)ExAllocatePoolWithTag(\n\t\t\tNonPagedPool, size + sizeof(CS_WINKERNEL_MEMBLOCK), CS_WINKERNEL_POOL_TAG);\n\tif (!block) {\n\t\treturn NULL;\n\t}\n\tblock->size = size;\n\treturn block->data;\n}", "target": 1}
{"code": "getlogin_r (name, name_len)\n     char *name;\n     size_t name_len;\n{\n  char tty_pathname[2 + 2 * NAME_MAX];\n  char *real_tty_path = tty_pathname;\n  int result = 0;\n  struct utmp *ut, line, buffer;\n  {\n    int d = __open (\"/dev/tty\", 0);\n    if (d < 0)\n      return errno;\n    result = __ttyname_r (d, real_tty_path, sizeof (tty_pathname));\n    (void) __close (d);\n    if (result != 0)\n      {\n\t__set_errno (result);\n\treturn result;\n      }\n  }\n  real_tty_path += 5;\t\t\n  __setutent ();\n  strncpy (line.ut_line, real_tty_path, sizeof line.ut_line);\n  if (__getutline_r (&line, &buffer, &ut) < 0)\n    {\n      if (errno == ESRCH)\n\tresult = ENOENT;\n      else\n\tresult = errno;\n    }\n  else\n    {\n      size_t needed = strlen (ut->ut_line) + 1;\n      if (needed < name_len)\n\t{\n\t  __set_errno (ERANGE);\n\t  result = ERANGE;\n\t}\n      else\n\t{\n\t  memcpy (name, ut->ut_line, needed);\n\t  result = 0;\n\t}\n    }\n  __endutent ();\n  return result;\n}", "target": 1}
{"code": "void LayerTilerChromium::growLayerToContain(const IntRect& contentRect)\n{\n    IntRect layerRect = contentRectToLayerRect(contentRect);\n    IntSize layerSize = IntSize(layerRect.maxX(), layerRect.maxY());\n    IntSize newSize = layerSize.expandedTo(m_layerSize);\n    resizeLayer(newSize);\n}", "target": 0}
{"code": "CURLcode Curl_auth_create_plain_message(struct Curl_easy *data,\n                                        const char *userp,\n                                        const char *passwdp,\n                                        char **outptr, size_t *outlen)\n{\n  CURLcode result;\n  char *plainauth;\n  size_t ulen;\n  size_t plen;\n  size_t plainlen;\n  *outlen = 0;\n  *outptr = NULL;\n  ulen = strlen(userp);\n  plen = strlen(passwdp);\n  if((ulen > SIZE_T_MAX/2) || (plen > (SIZE_T_MAX/2 - 2)))\n    return CURLE_OUT_OF_MEMORY;\n  plainlen = 2 * ulen + plen + 2;\n  plainauth = malloc(plainlen);\n  if(!plainauth)\n    return CURLE_OUT_OF_MEMORY;\n  memcpy(plainauth, userp, ulen);\n  plainauth[ulen] = '\\0';\n  memcpy(plainauth + ulen + 1, userp, ulen);\n  plainauth[2 * ulen + 1] = '\\0';\n  memcpy(plainauth + 2 * ulen + 2, passwdp, plen);\n  result = Curl_base64_encode(data, plainauth, plainlen, outptr, outlen);\n  free(plainauth);\n  return result;\n}", "target": 1}
{"code": "static MagickBooleanType ReadPSDChannelRLE(Image *image,const PSDInfo *psd_info,\n  const ssize_t type,MagickOffsetType *sizes,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n  size_t\n    length,\n    row_size;\n  ssize_t\n    count,\n    y;\n  unsigned char\n    *compact_pixels,\n    *pixels;\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"      layer data is RLE compressed\");\n  row_size=GetPSDRowSize(image);\n  pixels=(unsigned char *) AcquireQuantumMemory(row_size,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  length=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n    if ((MagickOffsetType) length < sizes[y])\n      length=(size_t) sizes[y];\n  if (length > row_size + 256) \n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowBinaryException(ResourceLimitError,\"InvalidLength\",\n        image->filename);\n    }\n  compact_pixels=(unsigned char *) AcquireQuantumMemory(length,sizeof(*pixels));\n  if (compact_pixels == (unsigned char *) NULL)\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  (void) ResetMagickMemory(compact_pixels,0,length*sizeof(*compact_pixels));\n  status=MagickTrue;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    status=MagickFalse;\n    count=ReadBlob(image,(size_t) sizes[y],compact_pixels);\n    if (count != (ssize_t) sizes[y])\n      break;\n    count=DecodePSDPixels((size_t) sizes[y],compact_pixels,\n      (ssize_t) (image->depth == 1 ? 123456 : image->depth),row_size,pixels);\n    if (count != (ssize_t) row_size)\n      break;\n    status=ReadPSDChannelPixels(image,psd_info->channels,y,type,pixels,\n      exception);\n    if (status == MagickFalse)\n      break;\n  }\n  compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  return(status);\n}", "target": 1}
{"code": "bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n{\n    {\n        LOCK2(cs_main, cs_wallet);\n        printf(\"CommitTransaction:\\n%s\", wtxNew.ToString().c_str());\n        {\n            CWalletDB* pwalletdb = fFileBacked ? new CWalletDB(strWalletFile,\"r\") : NULL;\n            reservekey.KeepKey();\n            AddToWallet(wtxNew);\n            set<CWalletTx*> setCoins;\n            BOOST_FOREACH(const CTxIn& txin, wtxNew.vin)\n            {\n                CWalletTx &coin = mapWallet[txin.prevout.hash];\n                coin.BindWallet(this);\n                coin.MarkSpent(txin.prevout.n);\n                coin.WriteToDisk();\n                NotifyTransactionChanged(this, coin.GetHash(), CT_UPDATED);\n            }\n            if (fFileBacked)\n                delete pwalletdb;\n        }\n        mapRequestCount[wtxNew.GetHash()] = 0;\n        if (!wtxNew.AcceptToMemoryPool())\n        {\n            printf(\"CommitTransaction() : Error: Transaction not valid\");\n            return false;\n        }\n        wtxNew.RelayWalletTransaction();\n    }\n    return true;\n}", "target": 1}
{"code": "            AuthenticationInfo(\n                    AuthenticationStatus auth_status)\n                : identity_handle_(nullptr)\n                , handshake_handle_(nullptr)\n                , auth_status_(auth_status)\n                , expected_sequence_number_(0)\n                , change_sequence_number_(SequenceNumber_t::unknown())\n                , handshake_requests_sent_(0)\n            {\n            }", "target": 0}
{"code": "static inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tret = mount_entry_create_dir_file(mntent, path);\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\tcull_mntent_opt(mntent);\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,\n\t\t\t  mntflags, mntdata, optional);\n\tfree(mntdata);\n\treturn ret;\n}", "target": 1}
{"code": "int main()\n{\n    gdImagePtr im;\n    FILE *fp;\n    fp = gdTestFileOpen2(\"gd2\", \"too_few_image_data.gd2\");\n    gdTestAssert(fp != NULL);\n    im = gdImageCreateFromGd2(fp);\n    gdTestAssert(im == NULL);\n    fclose(fp);\n    return gdNumFailures();\n}", "target": 0}
{"code": "crm_initiate_client_tls_handshake(void *session_data, int timeout_ms)\n{\n    int rc = 0;\n    int pollrc = 0;\n    time_t start = time(NULL);\n    gnutls_session *session = session_data;\n    do {\n        rc = gnutls_handshake(*session);\n        if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN) {\n            pollrc = crm_recv_remote_ready(session, TRUE, 1000);\n            if (pollrc < 0) {\n                rc = -1;\n            }\n        }\n    } while (((time(NULL) - start) < (timeout_ms/1000)) &&\n            (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN));\n    return rc;\n}", "target": 0}
{"code": "GF_Err dOps_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_OpusSpecificBox *ptr = (GF_OpusSpecificBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs,  0);\n\tgf_bs_write_u8(bs, ptr->opcfg.OutputChannelCount);\n\tgf_bs_write_u16(bs, ptr->opcfg.PreSkip);\n\tgf_bs_write_u32(bs, ptr->opcfg.InputSampleRate);\n\tgf_bs_write_u16(bs, ptr->opcfg.OutputGain);\n\tgf_bs_write_u8(bs, ptr->opcfg.ChannelMappingFamily);\n\tif (ptr->opcfg.ChannelMappingFamily) {\n\t\tgf_bs_write_u8(bs, ptr->opcfg.StreamCount);\n\t\tgf_bs_write_u8(bs, ptr->opcfg.CoupledCount);\n\t\tgf_bs_write_data(bs, (char *) ptr->opcfg.ChannelMapping, ptr->opcfg.OutputChannelCount);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "static void iwjpeg_scan_exif(struct iwjpegrcontext *rctx,\n\t\tconst iw_byte *d, size_t d_len)\n{\n\tstruct iw_exif_state e;\n\tiw_uint32 ifd;\n\tif(d_len<8) return;\n\tiw_zeromem(&e,sizeof(struct iw_exif_state));\n\te.d = d;\n\te.d_len = d_len;\n\te.endian = d[0]=='I' ? IW_ENDIAN_LITTLE : IW_ENDIAN_BIG;\n\tifd = iw_get_ui32_e(&d[4],e.endian);\n\tiwjpeg_scan_exif_ifd(rctx,&e,ifd);\n}", "target": 1}
{"code": "static void get_nb10(ut8* dbg_data, SCV_NB10_HEADER* res) {\n\tconst int nb10sz = 16;\n\tmemcpy (res, dbg_data, nb10sz);\n\tres->file_name = (ut8*) strdup ((const char*) dbg_data + nb10sz);\n}", "target": 1}
{"code": "de_dotdot( char* file )\n    {\n    char* cp;\n    char* cp2;\n    int l;\n    while ( ( cp = strstr( file, \"\n\t{\n\tfor ( cp2 = cp + 2; *cp2 == '/'; ++cp2 )\n\t    continue;\n\t(void) strcpy( cp + 1, cp2 );\n\t}\n    while ( strncmp( file, \"./\", 2 ) == 0 )\n\t(void) memmove( file, file + 2, strlen( file ) - 1 );\n    while ( ( cp = strstr( file, \"/./\") ) != (char*) 0 )\n\t(void) memmove( cp, cp + 2, strlen( file ) - 1 );\n    for (;;)\n\t{\n\twhile ( strncmp( file, \"../\", 3 ) == 0 )\n\t    (void) memmove( file, file + 3, strlen( file ) - 2 );\n\tcp = strstr( file, \"/../\" );\n\tif ( cp == (char*) 0 )\n\t    break;\n\tfor ( cp2 = cp - 1; cp2 >= file && *cp2 != '/'; --cp2 )\n\t    continue;\n\t(void) strcpy( cp2 + 1, cp + 4 );\n\t}\n    while ( ( l = strlen( file ) ) > 3 &&\n\t    strcmp( ( cp = file + l - 3 ), \"/..\" ) == 0 )\n\t{\n\tfor ( cp2 = cp - 1; cp2 >= file && *cp2 != '/'; --cp2 )\n\t    continue;\n\tif ( cp2 < file )\n\t    break;\n\t*cp2 = '\\0';\n\t}\n    }", "target": 1}
{"code": "R_API bool r_sys_mkdirp(const char *dir) {\n\tbool ret = true;\n\tchar slash = R_SYS_DIR[0];\n\tchar *path = strdup (dir), *ptr = path;\n\tif (!path) {\n\t\teprintf (\"r_sys_mkdirp: Unable to allocate memory\\n\");\n\t\treturn false;\n\t}\n\tif (*ptr == slash) {\n\t\tptr++;\n\t}\n#if __WINDOWS__\n\t{\n\t\tchar *p = strstr (ptr, \":\\\\\");\n\t\tif (p) {\n\t\t\tptr = p + 2;\n\t\t}\n\t}\n#endif\n\tfor (;;) {\n\t\tfor (; *ptr; ptr++) {\n\t\t\tif (*ptr == '/' || *ptr == '\\\\') {\n\t\t\t\tslash = *ptr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!*ptr) {\n\t\t\tbreak;\n\t\t}\n\t\t*ptr = 0;\n\t\tif (!r_sys_mkdir (path) && r_sys_mkdir_failed ()) {\n\t\t\teprintf (\"r_sys_mkdirp: fail '%s' of '%s'\\n\", path, dir);\n\t\t\tfree (path);\n\t\t\treturn false;\n\t\t}\n\t\t*ptr = slash;\n\t\tptr++;\n\t}\n\tif (!r_sys_mkdir (path) && r_sys_mkdir_failed ()) {\n\t\tret = false;\n\t}\n\tfree (path);\n\treturn ret;\n}", "target": 1}
{"code": "u32 gf_isom_get_nalu_length_field(GF_ISOFile *file, u32 track, u32 StreamDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_MPEGVisualSampleEntryBox *ve;\n\tGF_SampleDescriptionBox *stsd;\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) {\n\t\tfile->LastError = GF_BAD_PARAM;\n\t\treturn 0;\n\t}\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd || !StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\tfile->LastError = GF_BAD_PARAM;\n\t\treturn 0;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\tif (!entry || ! gf_isom_is_nalu_based_entry(trak->Media, entry)) {\n\t\tfile->LastError = GF_BAD_PARAM;\n\t\treturn 0;\n\t}\n\tve = (GF_MPEGVisualSampleEntryBox*)entry;\n\tif (ve->avc_config) return ve->avc_config->config->nal_unit_size;\n\tif (ve->svc_config) return ve->svc_config->config->nal_unit_size;\n\tif (ve->hevc_config) return ve->hevc_config->config->nal_unit_size;\n\tif (ve->lhvc_config) return ve->lhvc_config->config->nal_unit_size;\n\treturn 0;\n}", "target": 0}
{"code": "static Jsi_RC jsi_ArraySliceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n   if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    Jsi_RC rc = JSI_OK;\n    int istart = 0, iend, n, nsiz;\n    Jsi_Number nstart;\n    Jsi_Obj *nobj, *obj;\n    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, 0),\n        *end = Jsi_ValueArrayIndex(interp, args, 1);\n    if (!start) {\n        goto bail;\n    }\n    obj = _this->d.obj;\n    n = Jsi_ObjGetLength(interp, obj);\n    if (Jsi_GetNumberFromValue(interp,start, &nstart) == JSI_OK) {\n        istart = (int)nstart;\n        if (istart > n)\n            goto done;\n        if (istart < 0)\n            istart = (n+istart);\n        if (istart<0)\n            goto bail;\n    }\n    if (n == 0) {\ndone:\n        Jsi_ValueMakeArrayObject(interp, ret, Jsi_ObjNewType(interp, JSI_OT_ARRAY));\n        return JSI_OK;\n    }\n    Jsi_Number nend;\n    iend = n-1;\n    if (end && Jsi_GetNumberFromValue(interp,end, &nend) == JSI_OK) {\n        iend = (int) nend;\n        if (iend >= n)\n            iend = n;\n        if (iend < 0)\n            iend = (n+iend);\n        if (iend<0)\n            goto bail;\n    }\n    nsiz = iend-istart+1;\n    if (nsiz<=0)\n        goto done;\n    Jsi_ObjListifyArray(interp, obj);\n    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    if (Jsi_ObjArraySizer(interp, nobj, nsiz) <= 0) {\n        rc = Jsi_LogError(\"index too large: %d\", nsiz);\n        goto bail;\n    }\n    int i, m;\n    for (m = 0, i = istart; i <= iend; i++, m++)\n    {\n        if (!obj->arr[i]) continue;\n        nobj->arr[m] = NULL;\n        Jsi_ValueDup2(interp, nobj->arr+m, obj->arr[i]);\n    }\n    Jsi_ObjSetLength(interp, nobj, nsiz);\n    Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    return JSI_OK;\nbail:\n    Jsi_ValueMakeNull(interp, ret);\n    return rc;\n}", "target": 1}
{"code": "static int rb_check_list(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t struct list_head *list)\n{\n\tif (RB_WARN_ON(cpu_buffer, rb_list_head(list->prev) != list->prev))\n\t\treturn 1;\n\tif (RB_WARN_ON(cpu_buffer, rb_list_head(list->next) != list->next))\n\t\treturn 1;\n\treturn 0;\n}", "target": 0}
{"code": "static int dsa_precheck_params(const DSA *dsa, int *ret)\n{\n    if (dsa->params.p == NULL || dsa->params.q == NULL) {\n        ERR_raise(ERR_LIB_DSA, DSA_R_BAD_FFC_PARAMETERS);\n        *ret = FFC_CHECK_INVALID_PQ;\n        return 0;\n    }\n    if (BN_num_bits(dsa->params.p) > OPENSSL_DSA_MAX_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DSA, DSA_R_MODULUS_TOO_LARGE);\n        *ret = FFC_CHECK_INVALID_PQ;\n        return 0;\n    }\n    if (BN_num_bits(dsa->params.q) >= BN_num_bits(dsa->params.p)) {\n        ERR_raise(ERR_LIB_DSA, DSA_R_BAD_Q_VALUE);\n        *ret = FFC_CHECK_INVALID_PQ;\n        return 0;\n    }\n    return 1;\n}", "target": 0}
{"code": "netsnmp_mibindex_lookup( const char *dirname )\n{\n    int i;\n    static char tmpbuf[300];\n    for (i=0; i<_mibindex; i++) {\n        if ( _mibindexes[i] &&\n             strcmp( _mibindexes[i], dirname ) == 0) {\n             snprintf(tmpbuf, sizeof(tmpbuf), \"%s/mib_indexes/%d\",\n                      get_persistent_directory(), i);\n             tmpbuf[sizeof(tmpbuf)-1] = 0;\n             DEBUGMSGTL((\"mibindex\", \"lookup: %s (%d) %s\\n\", dirname, i, tmpbuf ));\n             return tmpbuf;\n        }\n    }\n    DEBUGMSGTL((\"mibindex\", \"lookup: (none)\\n\"));\n    return NULL;\n}", "target": 1}
{"code": "init_device (u2fh_devs * devs, struct u2fdevice *dev)\n{\n  unsigned char resp[1024];\n  unsigned char nonce[8];\n  if (obtain_nonce(nonce) != 0)\n    {\n      return U2FH_TRANSPORT_ERROR;\n    }\n  size_t resplen = sizeof (resp);\n  dev->cid = CID_BROADCAST;\n  if (u2fh_sendrecv\n      (devs, dev->id, U2FHID_INIT, nonce, sizeof (nonce), resp,\n       &resplen) == U2FH_OK)\n    {\n      U2FHID_INIT_RESP initresp;\n      if (resplen > sizeof (initresp))\n\t{\n\t  return U2FH_MEMORY_ERROR;\n\t}\n      memcpy (&initresp, resp, resplen);\n      dev->cid = initresp.cid;\n      dev->versionInterface = initresp.versionInterface;\n      dev->versionMajor = initresp.versionMajor;\n      dev->versionMinor = initresp.versionMinor;\n      dev->capFlags = initresp.capFlags;\n    }\n  else\n    {\n      return U2FH_TRANSPORT_ERROR;\n    }\n  return U2FH_OK;\n}", "target": 1}
{"code": "static int8_t sn_coap_parser_add_u16_limit(uint16_t a, uint16_t b, uint16_t *result)\n{\n    uint16_t c;\n    c = a + b;\n    if (c < a || c < b)\n    {\n        return -1;\n    }\n    *result = c;\n    return 0;\n}", "target": 0}
{"code": "static int xennet_get_sset_count(struct net_device *dev, int string_set)\n{\n\tswitch (string_set) {\n\tcase ETH_SS_STATS:\n\t\treturn ARRAY_SIZE(xennet_stats);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}", "target": 0}
{"code": "static int asf_read_marker(AVFormatContext *s, int64_t size)\n{\n    AVIOContext *pb = s->pb;\n    ASFContext *asf = s->priv_data;\n    int i, count, name_len, ret;\n    char name[1024];\n    avio_rl64(pb);            \n    avio_rl64(pb);            \n    count = avio_rl32(pb);    \n    avio_rl16(pb);            \n    name_len = avio_rl16(pb); \n    for (i = 0; i < name_len; i++)\n        avio_r8(pb); \n    for (i = 0; i < count; i++) {\n        int64_t pres_time;\n        int name_len;\n        avio_rl64(pb);             \n        pres_time = avio_rl64(pb); \n        pres_time -= asf->hdr.preroll * 10000;\n        avio_rl16(pb);             \n        avio_rl32(pb);             \n        avio_rl32(pb);             \n        name_len = avio_rl32(pb);  \n        if ((ret = avio_get_str16le(pb, name_len * 2, name,\n                                    sizeof(name))) < name_len)\n            avio_skip(pb, name_len - ret);\n        avpriv_new_chapter(s, i, (AVRational) { 1, 10000000 }, pres_time,\n                           AV_NOPTS_VALUE, name);\n    }\n    return 0;\n}", "target": 1}
{"code": "static int _anetTcpServer(char *err, int port, char *bindaddr, int af, int backlog)\n{\n    int s = -1, rv;\n    char _port[6];  \n    struct addrinfo hints, *servinfo, *p;\n    snprintf(_port,6,\"%d\",port);\n    memset(&hints,0,sizeof(hints));\n    hints.ai_family = af;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_flags = AI_PASSIVE;    \n    if (bindaddr && !strcmp(\"*\", bindaddr))\n        bindaddr = NULL;\n    if (af == AF_INET6 && bindaddr && !strcmp(\"::*\", bindaddr))\n        bindaddr = NULL;\n    if ((rv = getaddrinfo(bindaddr,_port,&hints,&servinfo)) != 0) {\n        anetSetError(err, \"%s\", gai_strerror(rv));\n        return ANET_ERR;\n    }\n    for (p = servinfo; p != NULL; p = p->ai_next) {\n        if ((s = socket(p->ai_family,p->ai_socktype,p->ai_protocol)) == -1)\n            continue;\n        if (af == AF_INET6 && anetV6Only(err,s) == ANET_ERR) goto error;\n        if (anetSetReuseAddr(err,s) == ANET_ERR) goto error;\n        if (anetListen(err,s,p->ai_addr,p->ai_addrlen,backlog) == ANET_ERR) s = ANET_ERR;\n        goto end;\n    }\n    if (p == NULL) {\n        anetSetError(err, \"unable to bind socket, errno: %d\", errno);\n        goto error;\n    }\nerror:\n    if (s != -1) close(s);\n    s = ANET_ERR;\nend:\n    freeaddrinfo(servinfo);\n    return s;\n}", "target": 1}
{"code": "static int put_chars(u32 vtermno, const char *buf, int count)\n{\n\tstruct port *port;\n\tstruct scatterlist sg[1];\n\tif (unlikely(early_put_chars))\n\t\treturn early_put_chars(vtermno, buf, count);\n\tport = find_port_by_vtermno(vtermno);\n\tif (!port)\n\t\treturn -EPIPE;\n\tsg_init_one(sg, buf, count);\n\treturn __send_to_port(port, sg, 1, count, (void *)buf, false);\n}", "target": 1}
{"code": "pci_vtrnd_notify(void *vsc, struct vqueue_info *vq)\n{\n\tstruct iovec iov;\n\tstruct pci_vtrnd_softc *sc;\n\tint len;\n\tuint16_t idx;\n\tsc = vsc;\n\tif (sc->vrsc_fd < 0) {\n\t\tvq_endchains(vq, 0);\n\t\treturn;\n\t}\n\twhile (vq_has_descs(vq)) {\n\t\tvq_getchain(vq, &idx, &iov, 1, NULL);\n\t\tlen = (int) read(sc->vrsc_fd, iov.iov_base, iov.iov_len);\n\t\tDPRINTF((\"vtrnd: vtrnd_notify(): %d\\r\\n\", len));\n\t\tassert(len > 0);\n\t\tvq_relchain(vq, idx, (uint32_t)len);\n\t}\n\tvq_endchains(vq, 1);\t\n}", "target": 1}
{"code": "untrusted_launcher_response_callback (GtkDialog                 *dialog,\n                                      int                        response_id,\n                                      ActivateParametersDesktop *parameters)\n{\n    GdkScreen *screen;\n    char *uri;\n    GFile *file;\n    switch (response_id)\n    {\n        case RESPONSE_RUN:\n        {\n            screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\n            uri = nautilus_file_get_uri (parameters->file);\n            DEBUG (\"Launching untrusted launcher %s\", uri);\n            nautilus_launch_desktop_file (screen, uri, NULL,\n                                          parameters->parent_window);\n            g_free (uri);\n        }\n        break;\n        case RESPONSE_MARK_TRUSTED:\n        {\n            file = nautilus_file_get_location (parameters->file);\n            nautilus_file_mark_desktop_file_trusted (file,\n                                                     parameters->parent_window,\n                                                     TRUE,\n                                                     NULL, NULL);\n            g_object_unref (file);\n        }\n        break;\n        default:\n        {\n        }\n        break;\n    }\n    gtk_widget_destroy (GTK_WIDGET (dialog));\n    activate_parameters_desktop_free (parameters);\n}", "target": 1}
{"code": "int MSADPCM::decodeBlock(const uint8_t *encoded, int16_t *decoded)\n{\n\tms_adpcm_state decoderState[2];\n\tms_adpcm_state *state[2];\n\tint channelCount = m_track->f.channelCount;\n\tint outputLength = m_framesPerPacket * sizeof (int16_t) * channelCount;\n\tstate[0] = &decoderState[0];\n\tif (channelCount == 2)\n\t\tstate[1] = &decoderState[1];\n\telse\n\t\tstate[1] = &decoderState[0];\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->predictorIndex = *encoded++;\n\t\tassert(state[i]->predictorIndex < m_numCoefficients);\n\t}\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->delta = (encoded[1]<<8) | encoded[0];\n\t\tencoded += sizeof (uint16_t);\n\t}\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->sample1 = (encoded[1]<<8) | encoded[0];\n\t\tencoded += sizeof (uint16_t);\n\t}\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->sample2 = (encoded[1]<<8) | encoded[0];\n\t\tencoded += sizeof (uint16_t);\n\t}\n\tconst int16_t *coefficient[2] =\n\t{\n\t\tm_coefficients[state[0]->predictorIndex],\n\t\tm_coefficients[state[1]->predictorIndex]\n\t};\n\tfor (int i=0; i<channelCount; i++)\n\t\t*decoded++ = state[i]->sample2;\n\tfor (int i=0; i<channelCount; i++)\n\t\t*decoded++ = state[i]->sample1;\n\tint samplesRemaining = (m_framesPerPacket - 2) * m_track->f.channelCount;\n\twhile (samplesRemaining > 0)\n\t{\n\t\tuint8_t code;\n\t\tint16_t newSample;\n\t\tcode = *encoded >> 4;\n\t\tnewSample = decodeSample(*state[0], code, coefficient[0]);\n\t\t*decoded++ = newSample;\n\t\tcode = *encoded & 0x0f;\n\t\tnewSample = decodeSample(*state[1], code, coefficient[1]);\n\t\t*decoded++ = newSample;\n\t\tencoded++;\n\t\tsamplesRemaining -= 2;\n\t}\n\treturn outputLength;\n}", "target": 1}
{"code": "CSecurityTLS::~CSecurityTLS()\n{\n  shutdown(true);\n  if (fis)\n    delete fis;\n  if (fos)\n    delete fos;\n  delete[] cafile;\n  delete[] crlfile;\n  gnutls_global_deinit();\n}", "target": 0}
{"code": "static int myrecvfrom6(int sockfd, void *buf, size_t *buflen, int flags,\n\t\t       struct in6_addr *addr, uint32_t *ifindex)\n{\n\tstruct sockaddr_in6 sin6;\n\tunsigned char cbuf[CMSG_SPACE(sizeof(struct in6_pktinfo))];\n\tstruct iovec iovec;\n\tstruct msghdr msghdr;\n\tstruct cmsghdr *cmsghdr;\n\tssize_t len;\n\tiovec.iov_len = *buflen;\n\tiovec.iov_base = buf;\n\tmemset(&msghdr, 0, sizeof(msghdr));\n\tmsghdr.msg_name = &sin6;\n\tmsghdr.msg_namelen = sizeof(sin6);\n\tmsghdr.msg_iov = &iovec;\n\tmsghdr.msg_iovlen = 1;\n\tmsghdr.msg_control = cbuf;\n\tmsghdr.msg_controllen = sizeof(cbuf);\n\tlen = recvmsg(sockfd, &msghdr, flags);\n\tif (len == -1)\n\t\treturn -errno;\n\t*buflen = len;\n\t*ifindex = sin6.sin6_scope_id;\n        for (cmsghdr = CMSG_FIRSTHDR(&msghdr); cmsghdr;\n\t     cmsghdr = CMSG_NXTHDR(&msghdr, cmsghdr)) {\n\t\tif (cmsghdr->cmsg_level == IPPROTO_IPV6 &&\n\t\t    cmsghdr->cmsg_type == IPV6_PKTINFO &&\n\t\t    cmsghdr->cmsg_len == CMSG_LEN(sizeof(struct in6_pktinfo))) {\n\t\t\tstruct in6_pktinfo *pktinfo;\n\t\t\tpktinfo = (struct in6_pktinfo *) CMSG_DATA(cmsghdr);\n\t\t\t*ifindex = pktinfo->ipi6_ifindex;\n\t\t}\n\t}\n\t*addr = sin6.sin6_addr;\n\treturn 0;\n}", "target": 1}
{"code": "ikev1_sub_print(netdissect_options *ndo,\n\t\tu_char np, const struct isakmp_gen *ext, const u_char *ep,\n\t\tuint32_t phase, uint32_t doi, uint32_t proto, int depth)\n{\n\tconst u_char *cp;\n\tint i;\n\tstruct isakmp_gen e;\n\tcp = (const u_char *)ext;\n\twhile (np) {\n\t\tND_TCHECK(*ext);\n\t\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\t\tND_TCHECK2(*ext, ntohs(e.len));\n\t\tdepth++;\n\t\tND_PRINT((ndo,\"\\n\"));\n\t\tfor (i = 0; i < depth; i++)\n\t\t\tND_PRINT((ndo,\"    \"));\n\t\tND_PRINT((ndo,\"(\"));\n\t\tcp = ike_sub0_print(ndo, np, ext, ep, phase, doi, proto, depth);\n\t\tND_PRINT((ndo,\")\"));\n\t\tdepth--;\n\t\tif (cp == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t\tnp = e.np;\n\t\text = (const struct isakmp_gen *)cp;\n\t}\n\treturn cp;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(np)));\n\treturn NULL;\n}", "target": 1}
{"code": "static inline void SetPSDPixel(Image *image,const size_t channels,\n  const ssize_t type,const size_t packet_size,const Quantum pixel,Quantum *q,\n  ExceptionInfo *exception)\n{\n  if (image->storage_class == PseudoClass)\n    {\n      if (packet_size == 1)\n        SetPixelIndex(image,ScaleQuantumToChar(pixel),q);\n      else\n        SetPixelIndex(image,ScaleQuantumToShort(pixel),q);\n      SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n        ConstrainColormapIndex(image,GetPixelIndex(image,q),exception),q);\n      return;\n    }\n  switch (type)\n  {\n    case -1:\n    {\n      SetPixelAlpha(image, pixel,q);\n      break;\n    }\n    case -2:\n    case 0:\n    {\n      SetPixelRed(image,pixel,q);\n      if (channels == 1 || type == -2)\n        SetPixelGray(image,pixel,q);\n      break;\n    }\n    case 1:\n    {\n      if (image->storage_class == PseudoClass)\n        SetPixelAlpha(image,pixel,q);\n      else\n        SetPixelGreen(image,pixel,q);\n      break;\n    }\n    case 2:\n    {\n      if (image->storage_class == PseudoClass)\n        SetPixelAlpha(image,pixel,q);\n      else\n        SetPixelBlue(image,pixel,q);\n      break;\n    }\n    case 3:\n    {\n      if (image->colorspace == CMYKColorspace)\n        SetPixelBlack(image,pixel,q);\n      else\n        if (image->alpha_trait != UndefinedPixelTrait)\n          SetPixelAlpha(image,pixel,q);\n      break;\n    }\n    case 4:\n    {\n      if ((IssRGBCompatibleColorspace(image->colorspace) != MagickFalse) &&\n          (channels > 3))\n        break;\n      if (image->alpha_trait != UndefinedPixelTrait)\n        SetPixelAlpha(image,pixel,q);\n      break;\n    }\n  }\n}", "target": 0}
{"code": "static void destroy_surface(struct swaylock_surface *surface) {\n\twl_list_remove(&surface->link);\n\tif (surface->layer_surface != NULL) {\n\t\tzwlr_layer_surface_v1_destroy(surface->layer_surface);\n\t}\n\tif (surface->ext_session_lock_surface_v1 != NULL) {\n\t\text_session_lock_surface_v1_destroy(surface->ext_session_lock_surface_v1);\n\t}\n\tif (surface->surface != NULL) {\n\t\twl_surface_destroy(surface->surface);\n\t}\n\tdestroy_buffer(&surface->buffers[0]);\n\tdestroy_buffer(&surface->buffers[1]);\n\tdestroy_buffer(&surface->indicator_buffers[0]);\n\tdestroy_buffer(&surface->indicator_buffers[1]);\n\twl_output_destroy(surface->output);\n\tfree(surface);\n}", "target": 0}
{"code": "static inline int ip_ufo_append_data(struct sock *sk,\n\t\t\tstruct sk_buff_head *queue,\n\t\t\tint getfrag(void *from, char *to, int offset, int len,\n\t\t\t       int odd, struct sk_buff *skb),\n\t\t\tvoid *from, int length, int hh_len, int fragheaderlen,\n\t\t\tint transhdrlen, int maxfraglen, unsigned int flags)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\tif ((skb = skb_peek_tail(queue)) == NULL) {\n\t\tskb = sock_alloc_send_skb(sk,\n\t\t\thh_len + fragheaderlen + transhdrlen + 20,\n\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\tif (skb == NULL)\n\t\t\treturn err;\n\t\tskb_reserve(skb, hh_len);\n\t\tskb_put(skb, fragheaderlen + transhdrlen);\n\t\tskb_reset_network_header(skb);\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\tskb->csum = 0;\n\t\tskb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;\n\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\t\t__skb_queue_tail(queue, skb);\n\t}\n\treturn skb_append_datato_frags(sk, skb, getfrag, from,\n\t\t\t\t       (length - transhdrlen));\n}", "target": 1}
{"code": "level_cost(unsigned int n)\n{\n    static const double log_1_1 = 0.09531017980432493;\n\treturn ceil(log(n + 0.1)/log_1_1);\n}", "target": 0}
{"code": "void NotificationService::RemoveObserver(NotificationObserver* observer,\n                                          NotificationType type,\n                                          const NotificationSource& source) {\n   DCHECK(type.value < NotificationType::NOTIFICATION_TYPE_COUNT);\n  CHECK(HasKey(observers_[type.value], source));\n   NotificationObserverList* observer_list =\n       observers_[type.value][source.map_key()];\n  if (observer_list) {\n    observer_list->RemoveObserver(observer);\n#ifndef NDEBUG\n    --observer_counts_[type.value];\n#endif\n  }\n}", "target": 0}
{"code": "static inline ut8 r_read_le8(const void *src) {\n\tif (!src) {\n\t\treturn UT8_MAX;\n\t}\n\treturn r_read_ble8 (src);\n}", "target": 0}
{"code": "TfLiteStatus PrepareSimple(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TF_LITE_ENSURE_EQ(context, node->inputs->size, 2);\n  TF_LITE_ENSURE_EQ(context, node->outputs->size, 1);\n  const TfLiteTensor* axis = GetInput(context, node, 1);\n  TF_LITE_ENSURE(context, axis != nullptr);\n  TF_LITE_ENSURE_TYPES_EQ(context, axis->type, kTfLiteInt32);\n  if (input->type == kTfLiteInt8) {\n    OpData* data = static_cast<OpData*>(node->user_data);\n    const TfLiteTensor* output = GetOutput(context, node, 0);\n    const double real_multiplier = static_cast<double>(input->params.scale) /\n                                   static_cast<double>(output->params.scale);\n    QuantizeMultiplier(real_multiplier, &data->multiplier, &data->shift);\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static int ati_remote2_probe(struct usb_interface *interface, const struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(interface);\n\tstruct usb_host_interface *alt = interface->cur_altsetting;\n\tstruct ati_remote2 *ar2;\n\tint r;\n\tif (alt->desc.bInterfaceNumber)\n\t\treturn -ENODEV;\n\tar2 = kzalloc(sizeof (struct ati_remote2), GFP_KERNEL);\n\tif (!ar2)\n\t\treturn -ENOMEM;\n\tar2->udev = udev;\n\tar2->intf[0] = interface;\n\tar2->ep[0] = &alt->endpoint[0].desc;\n\tar2->intf[1] = usb_ifnum_to_if(udev, 1);\n\tr = usb_driver_claim_interface(&ati_remote2_driver, ar2->intf[1], ar2);\n\tif (r)\n\t\tgoto fail1;\n\talt = ar2->intf[1]->cur_altsetting;\n\tar2->ep[1] = &alt->endpoint[0].desc;\n\tr = ati_remote2_urb_init(ar2);\n\tif (r)\n\t\tgoto fail2;\n\tar2->channel_mask = channel_mask;\n\tar2->mode_mask = mode_mask;\n\tr = ati_remote2_setup(ar2, ar2->channel_mask);\n\tif (r)\n\t\tgoto fail2;\n\tusb_make_path(udev, ar2->phys, sizeof(ar2->phys));\n\tstrlcat(ar2->phys, \"/input0\", sizeof(ar2->phys));\n\tstrlcat(ar2->name, \"ATI Remote Wonder II\", sizeof(ar2->name));\n\tr = sysfs_create_group(&udev->dev.kobj, &ati_remote2_attr_group);\n\tif (r)\n\t\tgoto fail2;\n\tr = ati_remote2_input_init(ar2);\n\tif (r)\n\t\tgoto fail3;\n\tusb_set_intfdata(interface, ar2);\n\tinterface->needs_remote_wakeup = 1;\n\treturn 0;\n fail3:\n\tsysfs_remove_group(&udev->dev.kobj, &ati_remote2_attr_group);\n fail2:\n\tati_remote2_urb_cleanup(ar2);\n\tusb_driver_release_interface(&ati_remote2_driver, ar2->intf[1]);\n fail1:\n\tkfree(ar2);\n\treturn r;\n}", "target": 1}
{"code": "size_t jsuGetFreeStack() {\n#ifdef ARM\n  void *frame = __builtin_frame_address(0);\n  size_t stackPos = (size_t)((char*)frame);\n  size_t stackEnd = (size_t)((char*)&LINKER_END_VAR);\n  if (stackPos < stackEnd) return 0; \n  return  stackPos - stackEnd;\n#elif defined(LINUX)\n  char ptr; \n  extern void *STACK_BASE;\n  uint32_t count =  (uint32_t)((size_t)STACK_BASE - (size_t)&ptr);\n  return 1000000 - count; \n#else\n  return 1000000; \n#endif\n}", "target": 1}
{"code": "static void ram_block_add(struct uc_struct *uc, RAMBlock *new_block)\n{\n    RAMBlock *block;\n    RAMBlock *last_block = NULL;\n    new_block->offset = find_ram_offset(uc, new_block->max_length);\n    if (!new_block->host) {\n        new_block->host = phys_mem_alloc(uc, new_block->max_length,\n                &new_block->mr->align);\n        if (!new_block->host) {\n            return;\n        }\n    }\n    RAMBLOCK_FOREACH(block) {\n        last_block = block;\n        if (block->max_length < new_block->max_length) {\n            break;\n        }\n    }\n    if (block) {\n        QLIST_INSERT_BEFORE(block, new_block, next);\n    } else if (last_block) {\n        QLIST_INSERT_AFTER(last_block, new_block, next);\n    } else { \n        QLIST_INSERT_HEAD(&uc->ram_list.blocks, new_block, next);\n    }\n    uc->ram_list.mru_block = NULL;\n    cpu_physical_memory_set_dirty_range(new_block->offset,\n                                        new_block->used_length,\n                                        DIRTY_CLIENTS_ALL);\n}", "target": 1}
{"code": "xid_map_enter(netdissect_options *ndo,\n              const struct sunrpc_msg *rp, const u_char *bp)\n{\n\tconst struct ip *ip = NULL;\n\tconst struct ip6_hdr *ip6 = NULL;\n\tstruct xid_map_entry *xmep;\n\tif (!ND_TTEST(rp->rm_call.cb_vers))\n\t\treturn (0);\n\tswitch (IP_V((const struct ip *)bp)) {\n\tcase 4:\n\t\tip = (const struct ip *)bp;\n\t\tbreak;\n\tcase 6:\n\t\tip6 = (const struct ip6_hdr *)bp;\n\t\tbreak;\n\tdefault:\n\t\treturn (1);\n\t}\n\txmep = &xid_map[xid_map_next];\n\tif (++xid_map_next >= XIDMAPSIZE)\n\t\txid_map_next = 0;\n\tUNALIGNED_MEMCPY(&xmep->xid, &rp->rm_xid, sizeof(xmep->xid));\n\tif (ip) {\n\t\txmep->ipver = 4;\n\t\tUNALIGNED_MEMCPY(&xmep->client, &ip->ip_src, sizeof(ip->ip_src));\n\t\tUNALIGNED_MEMCPY(&xmep->server, &ip->ip_dst, sizeof(ip->ip_dst));\n\t}\n\telse if (ip6) {\n\t\txmep->ipver = 6;\n\t\tUNALIGNED_MEMCPY(&xmep->client, &ip6->ip6_src, sizeof(ip6->ip6_src));\n\t\tUNALIGNED_MEMCPY(&xmep->server, &ip6->ip6_dst, sizeof(ip6->ip6_dst));\n\t}\n\tif (!ND_TTEST(rp->rm_call.cb_proc))\n\t\treturn (0);\n\txmep->proc = EXTRACT_32BITS(&rp->rm_call.cb_proc);\n\tif (!ND_TTEST(rp->rm_call.cb_vers))\n\t\treturn (0);\n\txmep->vers = EXTRACT_32BITS(&rp->rm_call.cb_vers);\n\treturn (1);\n}", "target": 0}
{"code": "spnego_gss_wrap_iov(OM_uint32 *minor_status,\n\t\t    gss_ctx_id_t context_handle,\n\t\t    int conf_req_flag,\n\t\t    gss_qop_t qop_req,\n\t\t    int *conf_state,\n\t\t    gss_iov_buffer_desc *iov,\n\t\t    int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_iov(minor_status,\n\t\t\t   context_handle,\n\t\t\t   conf_req_flag,\n\t\t\t   qop_req,\n\t\t\t   conf_state,\n\t\t\t   iov,\n\t\t\t   iov_count);\n\treturn (ret);\n}", "target": 1}
{"code": "static int atusb_read_reg(struct atusb *atusb, uint8_t reg)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tint ret;\n\tuint8_t value;\n\tdev_dbg(&usb_dev->dev, \"atusb: reg = 0x%x\\n\", reg);\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_REG_READ, ATUSB_REQ_FROM_DEV,\n\t\t\t\t0, reg, &value, 1, 1000);\n\treturn ret >= 0 ? value : ret;\n}", "target": 1}
{"code": "struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned int flags,\n\t\t\t\t    int *peeked, int *off, int *err)\n{\n\tstruct sk_buff *skb;\n\tlong timeo;\n\tint error = sock_error(sk);\n\tif (error)\n\t\tgoto no_packet;\n\ttimeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n\tdo {\n\t\tunsigned long cpu_flags;\n\t\tstruct sk_buff_head *queue = &sk->sk_receive_queue;\n\t\tspin_lock_irqsave(&queue->lock, cpu_flags);\n\t\tskb_queue_walk(queue, skb) {\n\t\t\t*peeked = skb->peeked;\n\t\t\tif (flags & MSG_PEEK) {\n\t\t\t\tif (*off >= skb->len) {\n\t\t\t\t\t*off -= skb->len;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tskb->peeked = 1;\n\t\t\t\tatomic_inc(&skb->users);\n\t\t\t} else\n\t\t\t\t__skb_unlink(skb, queue);\n\t\t\tspin_unlock_irqrestore(&queue->lock, cpu_flags);\n\t\t\treturn skb;\n\t\t}\n\t\tspin_unlock_irqrestore(&queue->lock, cpu_flags);\n\t\terror = -EAGAIN;\n\t\tif (!timeo)\n\t\t\tgoto no_packet;\n\t} while (!wait_for_packet(sk, err, &timeo));\n\treturn NULL;\nno_packet:\n\t*err = error;\n\treturn NULL;\n}", "target": 1}
{"code": "kdc_process_s4u_x509_user(krb5_context context,\n                          krb5_kdc_req *request,\n                          krb5_pa_data *pa_data,\n                          krb5_keyblock *tgs_subkey,\n                          krb5_keyblock *tgs_session,\n                          krb5_pa_s4u_x509_user **s4u_x509_user,\n                          const char **status)\n{\n    krb5_error_code             code;\n    krb5_data                   req_data;\n    req_data.length = pa_data->length;\n    req_data.data = (char *)pa_data->contents;\n    code = decode_krb5_pa_s4u_x509_user(&req_data, s4u_x509_user);\n    if (code)\n        return code;\n    code = verify_s4u_x509_user_checksum(context,\n                                         tgs_subkey ? tgs_subkey :\n                                         tgs_session,\n                                         &req_data,\n                                         request->nonce, *s4u_x509_user);\n    if (code) {\n        *status = \"INVALID_S4U2SELF_CHECKSUM\";\n        krb5_free_pa_s4u_x509_user(context, *s4u_x509_user);\n        *s4u_x509_user = NULL;\n        return code;\n    }\n    if (krb5_princ_size(context, (*s4u_x509_user)->user_id.user) == 0 ||\n        (*s4u_x509_user)->user_id.subject_cert.length != 0) {\n        *status = \"INVALID_S4U2SELF_REQUEST\";\n        krb5_free_pa_s4u_x509_user(context, *s4u_x509_user);\n        *s4u_x509_user = NULL;\n        return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n    }\n    return 0;\n}", "target": 1}
{"code": "static int crypto_report_one(struct crypto_alg *alg,\n\t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n{\n\tmemcpy(&ualg->cru_name, &alg->cra_name, sizeof(ualg->cru_name));\n\tmemcpy(&ualg->cru_driver_name, &alg->cra_driver_name,\n\t       sizeof(ualg->cru_driver_name));\n\tmemcpy(&ualg->cru_module_name, module_name(alg->cra_module),\n\t       CRYPTO_MAX_ALG_NAME);\n\tualg->cru_flags = alg->cra_flags;\n\tualg->cru_refcnt = atomic_read(&alg->cra_refcnt);\n\tif (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))\n\t\tgoto nla_put_failure;\n\tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n\t\tstruct crypto_report_larval rl;\n\t\tsnprintf(rl.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"larval\");\n\t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n\t\t\t    sizeof(struct crypto_report_larval), &rl))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\tif (alg->cra_type && alg->cra_type->report) {\n\t\tif (alg->cra_type->report(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\tswitch (alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL)) {\n\tcase CRYPTO_ALG_TYPE_CIPHER:\n\t\tif (crypto_report_cipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_COMPRESS:\n\t\tif (crypto_report_comp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\t}\nout:\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "int BN_is_one(const BIGNUM *a)\n{\n    return BN_abs_is_word(a, 1) && !a->neg;\n}", "target": 0}
{"code": "static void jsonNewDString(Jsi_Interp *interp, Jsi_DString *dStr, const char* str, int len)\n{\n    char buf[100], *dp = buf;\n    const char *cp = str;\n    int ulen;\n    while ((cp-str)<len) {\n        if (*cp == '\\\\') {\n            switch (cp[1]) {\n                case 'b': *dp++ = '\\b'; break;\n                case 'n': *dp++ = '\\n'; break;\n                case 'r': *dp++ = '\\r'; break;\n                case 'f': *dp++ = '\\f'; break;\n                case 't': *dp++ = '\\t'; break;\n                case '\\\"': *dp++ = '\\\"'; break;\n                case '\\\\': *dp++ = '\\\\'; break;\n                case 'u': \n                    if ((ulen=Jsi_UtfDecode(cp+2, dp))) {\n                        dp += ulen;\n                        cp += 4;\n                    } else {                    \n                        *dp++ = '\\\\';\n                        *dp++ = 'u';\n                    }\n                    break;\n            }\n            cp+=2;\n        } else {\n            *dp++ = *cp++;\n        }\n        if ((dp-buf)>90) {\n            *dp = 0;\n            Jsi_DSAppendLen(dStr, buf, dp-buf);\n            dp = buf;\n        }\n    }\n    *dp = 0;\n    Jsi_DSAppendLen(dStr, buf, dp-buf);\n}", "target": 1}
{"code": "int digest_generic_verify(struct digest *d, const unsigned char *md)\n{\n\tint ret;\n\tint len = digest_length(d);\n\tunsigned char *tmp;\n\ttmp = xmalloc(len);\n\tret = digest_final(d, tmp);\n\tif (ret)\n\t\tgoto end;\n\tret = memcmp(md, tmp, len);\n\tret = ret ? -EINVAL : 0;\nend:\n\tfree(tmp);\n\treturn ret;\n}", "target": 1}
{"code": "void DelegatedFrameHost::ResetCompositorFrameSinkSupport() {\n  if (!support_)\n    return;\n  if (compositor_)\n    compositor_->RemoveFrameSink(frame_sink_id_);\n  support_.reset();\n}", "target": 0}
{"code": "Status GetInitOp(const string& export_dir, const MetaGraphDef& meta_graph_def,\n                 string* init_op_name) {\n  const auto& sig_def_map = meta_graph_def.signature_def();\n  const auto& init_op_sig_it =\n      meta_graph_def.signature_def().find(kSavedModelInitOpSignatureKey);\n  if (init_op_sig_it != sig_def_map.end()) {\n    *init_op_name = init_op_sig_it->second.outputs()\n                        .find(kSavedModelInitOpSignatureKey)\n                        ->second.name();\n    return Status::OK();\n  }\n  const auto& collection_def_map = meta_graph_def.collection_def();\n  string init_op_collection_key;\n  if (collection_def_map.find(kSavedModelMainOpKey) !=\n      collection_def_map.end()) {\n    init_op_collection_key = kSavedModelMainOpKey;\n  } else {\n    init_op_collection_key = kSavedModelLegacyInitOpKey;\n  }\n  const auto init_op_it = collection_def_map.find(init_op_collection_key);\n  if (init_op_it != collection_def_map.end()) {\n    if (init_op_it->second.node_list().value_size() != 1) {\n      return errors::FailedPrecondition(\n          strings::StrCat(\"Expected exactly one main op in : \", export_dir));\n    }\n    *init_op_name = init_op_it->second.node_list().value(0);\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "static void update_attr(struct vc_data *vc)\n{\n\tvc->vc_attr = build_attr(vc, vc->vc_color, vc->vc_intensity,\n\t              vc->vc_blink, vc->vc_underline,\n\t              vc->vc_reverse ^ vc->vc_decscnm, vc->vc_italic);\n\tvc->vc_video_erase_char = (build_attr(vc, vc->vc_color, 1, vc->vc_blink, 0, vc->vc_decscnm, 0) << 8) | ' ';\n}", "target": 0}
{"code": "void RenderView::OnFindReplyAck() {\n  if (queued_find_reply_message_.get()) {\n    Send(queued_find_reply_message_.release());\n  }\n}", "target": 0}
{"code": "static struct mnt_namespace *alloc_mnt_ns(struct user_namespace *user_ns)\n{\n\tstruct mnt_namespace *new_ns;\n\tstruct ucounts *ucounts;\n\tint ret;\n\tucounts = inc_mnt_namespaces(user_ns);\n\tif (!ucounts)\n\t\treturn ERR_PTR(-ENOSPC);\n\tnew_ns = kmalloc(sizeof(struct mnt_namespace), GFP_KERNEL);\n\tif (!new_ns) {\n\t\tdec_mnt_namespaces(ucounts);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tret = ns_alloc_inum(&new_ns->ns);\n\tif (ret) {\n\t\tkfree(new_ns);\n\t\tdec_mnt_namespaces(ucounts);\n\t\treturn ERR_PTR(ret);\n\t}\n\tnew_ns->ns.ops = &mntns_operations;\n\tnew_ns->seq = atomic64_add_return(1, &mnt_ns_seq);\n\tatomic_set(&new_ns->count, 1);\n\tnew_ns->root = NULL;\n\tINIT_LIST_HEAD(&new_ns->list);\n\tinit_waitqueue_head(&new_ns->poll);\n\tnew_ns->event = 0;\n\tnew_ns->user_ns = get_user_ns(user_ns);\n\tnew_ns->ucounts = ucounts;\n\tnew_ns->mounts = 0;\n\tnew_ns->pending_mounts = 0;\n\treturn new_ns;\n}", "target": 0}
{"code": "static void tokenadd(struct jv_parser* p, char c) {\n  assert(p->tokenpos <= p->tokenlen);\n  if (p->tokenpos == p->tokenlen) {\n    p->tokenlen = p->tokenlen*2 + 256;\n    p->tokenbuf = jv_mem_realloc(p->tokenbuf, p->tokenlen);\n  }\n  assert(p->tokenpos < p->tokenlen);\n  p->tokenbuf[p->tokenpos++] = c;\n}", "target": 1}
{"code": "static void read_buf(FILE *fin, char *buf) {\n  if (!fgets(buf, BUFFER_SIZE, fin)) {\n    buf[0] = '\\0';\n    return;\n  }\n  buf[strlen(buf) - 1] = '\\0';\n}", "target": 1}
{"code": "void snd_msndmidi_input_read(void *mpuv)\n{\n\tunsigned long flags;\n\tstruct snd_msndmidi *mpu = mpuv;\n\tvoid *pwMIDQData = mpu->dev->mappedbase + MIDQ_DATA_BUFF;\n\tspin_lock_irqsave(&mpu->input_lock, flags);\n\twhile (readw(mpu->dev->MIDQ + JQS_wTail) !=\n\t       readw(mpu->dev->MIDQ + JQS_wHead)) {\n\t\tu16 wTmp, val;\n\t\tval = readw(pwMIDQData + 2 * readw(mpu->dev->MIDQ + JQS_wHead));\n\t\t\tif (test_bit(MSNDMIDI_MODE_BIT_INPUT_TRIGGER,\n\t\t\t\t     &mpu->mode))\n\t\t\t\tsnd_rawmidi_receive(mpu->substream_input,\n\t\t\t\t\t\t    (unsigned char *)&val, 1);\n\t\twTmp = readw(mpu->dev->MIDQ + JQS_wHead) + 1;\n\t\tif (wTmp > readw(mpu->dev->MIDQ + JQS_wSize))\n\t\t\twritew(0,  mpu->dev->MIDQ + JQS_wHead);\n\t\telse\n\t\t\twritew(wTmp,  mpu->dev->MIDQ + JQS_wHead);\n\t}\n\tspin_unlock_irqrestore(&mpu->input_lock, flags);\n}", "target": 1}
{"code": "static inline void add_sdb_addrline(Sdb *s, ut64 addr, const char *file, ut64 line, int mode, PrintfCallback print) {\n\tconst char *p;\n\tchar *fileline;\n\tchar offset[SDB_NUM_BUFSZ];\n\tchar *offset_ptr;\n\tif (!s || !file) {\n\t\treturn;\n\t}\n\tp = r_str_rchr (file, NULL, '/');\n\tif (p) {\n\t\tp++;\n\t} else {\n\t\tp = file;\n\t}\n\tswitch (mode) {\n\tcase 1:\n\tcase 'r':\n\tcase '*':\n\t\tprint (\"CL %s:%d 0x%08\"PFMT64x\"\\n\", p, (int)line, addr);\n\t\tbreak;\n\t}\n#if 0\n\tif (r_file_exists (file)) {\n\t\tp = file;\n\t}\n#else\n\tp = file;\n#endif\n\tfileline = r_str_newf (\"%s|%\"PFMT64d, p, line);\n\toffset_ptr = sdb_itoa (addr, 16, offset, sizeof (offset));\n\tsdb_add (s, offset_ptr, fileline, 0);\n\tsdb_add (s, fileline, offset_ptr, 0);\n\tfree (fileline);\n}", "target": 1}
{"code": "escape(unsigned char ch, char *buf)\n{\n    const int len = ch < 0100 ? (ch < 010 ? 3 : 4) : 5;\n    switch (len) {\n    case 5:\n\tbuf[4] = (ch & 7) + '0';\n\tch >>= 3;\n\tFALLTHROUGH;\n    case 4:\n\tbuf[3] = (ch & 7) + '0';\n\tch >>= 3;\n\tFALLTHROUGH;\n    case 3:\n\tbuf[2] = (ch & 7) + '0';\n\tbuf[1] = '0';\n\tbuf[0] = '#';\n\tbreak;\n    }\n    buf[len] = '\\0';\n    return len;\n}", "target": 0}
{"code": "  DllDef int libraw_get_raw_height(libraw_data_t *lr)\n  {\n    if (!lr)\n      return EINVAL;\n    return lr->sizes.raw_height;\n  }", "target": 0}
{"code": "struct clock_source *dce110_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\tif (!clk_src)\n\t\treturn NULL;\n\tif (dce110_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 0}
{"code": "    void StackMsg::appendLine( char *szLine, bool complete ) {\n        if( complete ) {\n            m_os.flush() ;\n            m_sipMessage = m_os.str() ;\n            m_sipMessage.resize( m_sipMessage.length() - 1) ;\n            boost::replace_all(m_sipMessage, \"\\n\", DR_CRLF);\n        }\n        else if( 0 == strcmp(szLine, \"\\n\") ) {\n            m_os << endl ;\n        }\n        else {\n            int i = 0 ;\n            while( ' ' == szLine[i] && '\\0' != szLine[i]) i++ ;\n            m_os << ( szLine + i ) ;\n        }\n    }", "target": 1}
{"code": "    long PreviewImage::writeFile(const std::wstring& wpath) const\n    {\n        std::wstring name = wpath + wextension();\n        DataBuf buf(pData_, size_);\n        return Exiv2::writeFile(buf, name);\n    }", "target": 0}
{"code": "qedi_dbg_warn(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t      const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\tchar nfunc[32];\n\tmemset(nfunc, 0, sizeof(nfunc));\n\tmemcpy(nfunc, func, sizeof(nfunc) - 1);\n\tva_start(va, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\tif (!(qedi_dbg_log & QEDI_LOG_WARN))\n\t\tgoto ret;\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_warn(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t\tnfunc, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_warn(\"[0000:00:00.0]:[%s:%d]: %pV\", nfunc, line, &vaf);\nret:\n\tva_end(va);\n}", "target": 1}
{"code": "static ext3_fsblk_t get_sb_block(void **data, struct super_block *sb)\n{\n\text3_fsblk_t\tsb_block;\n\tchar\t\t*options = (char *) *data;\n\tif (!options || strncmp(options, \"sb=\", 3) != 0)\n\t\treturn 1;\t\n\toptions += 3;\n\tsb_block = simple_strtoul(options, &options, 0);\n\tif (*options && *options != ',') {\n\t\text3_msg(sb, \"error: invalid sb specification: %s\",\n\t\t       (char *) *data);\n\t\treturn 1;\n\t}\n\tif (*options == ',')\n\t\toptions++;\n\t*data = (void *) options;\n\treturn sb_block;\n}", "target": 1}
{"code": "static int ng_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_ng *pkt;\n\tconst char *ptr;\n\tsize_t alloclen;\n\tpkt = git__malloc(sizeof(*pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\tpkt->ref = NULL;\n\tpkt->type = GIT_PKT_NG;\n\tline += 3; \n\tif (!(ptr = strchr(line, ' ')))\n\t\tgoto out_err;\n\tlen = ptr - line;\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->ref = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->ref);\n\tmemcpy(pkt->ref, line, len);\n\tpkt->ref[len] = '\\0';\n\tline = ptr + 1;\n\tif (!(ptr = strchr(line, '\\n')))\n\t\tgoto out_err;\n\tlen = ptr - line;\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->msg = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->msg);\n\tmemcpy(pkt->msg, line, len);\n\tpkt->msg[len] = '\\0';\n\t*out = (git_pkt *)pkt;\n\treturn 0;\nout_err:\n\tgiterr_set(GITERR_NET, \"invalid packet line\");\n\tgit__free(pkt->ref);\n\tgit__free(pkt);\n\treturn -1;\n}", "target": 1}
{"code": "format_nstime_as_iso8601(gchar *buf, size_t buflen, const nstime_t *ns,\n    char *decimal_point, gboolean local, int precision)\n{\n\tstruct tm tm, *tmp;\n\tgchar *ptr;\n\tsize_t buf_remaining;\n\tint num_chars;\n\tif (local)\n\t\ttmp = ws_localtime_r(&ns->secs, &tm);\n\telse\n\t\ttmp = ws_gmtime_r(&ns->secs, &tm);\n\tif (tmp == NULL) {\n\t\tsnprintf(buf, buflen, \"Not representable\");\n\t\treturn;\n\t}\n\tptr = buf;\n\tbuf_remaining = buflen;\n\tnum_chars = snprintf(ptr, buf_remaining,\n\t    \"%04d-%02d-%02d %02d:%02d:%02d\",\n\t    tmp->tm_year + 1900,\n\t    tmp->tm_mon + 1,\n\t    tmp->tm_mday,\n\t    tmp->tm_hour,\n\t    tmp->tm_min,\n\t    tmp->tm_sec);\n\tif (num_chars < 0) {\n\t\tsnprintf(buf, buflen, \"snprintf() failed\");\n\t\treturn;\n\t}\n\tif ((unsigned int)num_chars >= buf_remaining) {\n\t\treturn;\n\t}\n\tptr += num_chars;\n\tbuf_remaining -= num_chars;\n\tif (precision == 0) {\n\t\treturn;\n\t}\n\tformat_fractional_part_nsecs(ptr, buf_remaining, (guint32)ns->nsecs, decimal_point, precision);\n}", "target": 1}
{"code": "bool ParamTraits<base::Time>::Read(const Message* m, PickleIterator* iter,\n                                   param_type* r) {\n  int64 value;\n  if (!ParamTraits<int64>::Read(m, iter, &value))\n    return false;\n  *r = base::Time::FromInternalValue(value);\n  return true;\n}", "target": 0}
{"code": "static int hash_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tstruct ahash_request *req = &ctx->req;\n\tchar state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];\n\tstruct sock *sk2;\n\tstruct alg_sock *ask2;\n\tstruct hash_ctx *ctx2;\n\tint err;\n\terr = crypto_ahash_export(req, state);\n\tif (err)\n\t\treturn err;\n\terr = af_alg_accept(ask->parent, newsock);\n\tif (err)\n\t\treturn err;\n\tsk2 = newsock->sk;\n\task2 = alg_sk(sk2);\n\tctx2 = ask2->private;\n\tctx2->more = 1;\n\terr = crypto_ahash_import(&ctx2->req, state);\n\tif (err) {\n\t\tsock_orphan(sk2);\n\t\tsock_put(sk2);\n\t}\n\treturn err;\n}", "target": 1}
{"code": "setkey_principal_2_svc(setkey_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (!(CHANGEPW_SERVICE(rqstp)) &&\n        kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                           ACL_SETKEY, arg->princ, NULL)) {\n        ret.code = kadm5_setkey_principal((void *)handle, arg->princ,\n                                          arg->keyblocks, arg->n_keys);\n    } else {\n        log_unauth(\"kadm5_setkey_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_SETKEY;\n    }\n    if(ret.code != KADM5_AUTH_SETKEY) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_setkey_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "EXPORTED int http_allow_noauth_get(struct transaction_t *txn)\n{\n    switch (txn->meth) {\n    case METH_GET:\n    case METH_HEAD:\n        return 0;\n    default:\n        return 1;\n    }\n}", "target": 0}
{"code": "xfs_lock_inodes(\n\tstruct xfs_inode\t**ips,\n\tint\t\t\tinodes,\n\tuint\t\t\tlock_mode)\n{\n\tint\t\t\tattempts = 0, i, j, try_lock;\n\tstruct xfs_log_item\t*lp;\n\tASSERT(ips && inodes >= 2 && inodes <= 5);\n\tASSERT(lock_mode & (XFS_IOLOCK_EXCL | XFS_MMAPLOCK_EXCL |\n\t\t\t    XFS_ILOCK_EXCL));\n\tASSERT(!(lock_mode & (XFS_IOLOCK_SHARED | XFS_MMAPLOCK_SHARED |\n\t\t\t      XFS_ILOCK_SHARED)));\n\tASSERT(!(lock_mode & XFS_MMAPLOCK_EXCL) ||\n\t\tinodes <= XFS_MMAPLOCK_MAX_SUBCLASS + 1);\n\tASSERT(!(lock_mode & XFS_ILOCK_EXCL) ||\n\t\tinodes <= XFS_ILOCK_MAX_SUBCLASS + 1);\n\tif (lock_mode & XFS_IOLOCK_EXCL) {\n\t\tASSERT(!(lock_mode & (XFS_MMAPLOCK_EXCL | XFS_ILOCK_EXCL)));\n\t} else if (lock_mode & XFS_MMAPLOCK_EXCL)\n\t\tASSERT(!(lock_mode & XFS_ILOCK_EXCL));\n\ttry_lock = 0;\n\ti = 0;\nagain:\n\tfor (; i < inodes; i++) {\n\t\tASSERT(ips[i]);\n\t\tif (i && (ips[i] == ips[i - 1]))\t\n\t\t\tcontinue;\n\t\tif (!try_lock) {\n\t\t\tfor (j = (i - 1); j >= 0 && !try_lock; j--) {\n\t\t\t\tlp = &ips[j]->i_itemp->ili_item;\n\t\t\t\tif (lp && test_bit(XFS_LI_IN_AIL, &lp->li_flags))\n\t\t\t\t\ttry_lock++;\n\t\t\t}\n\t\t}\n\t\tif (!try_lock) {\n\t\t\txfs_ilock(ips[i], xfs_lock_inumorder(lock_mode, i));\n\t\t\tcontinue;\n\t\t}\n\t\tASSERT(i != 0);\n\t\tif (xfs_ilock_nowait(ips[i], xfs_lock_inumorder(lock_mode, i)))\n\t\t\tcontinue;\n\t\tattempts++;\n\t\tfor (j = i - 1; j >= 0; j--) {\n\t\t\tif (j != (i - 1) && ips[j] == ips[j + 1])\n\t\t\t\tcontinue;\n\t\t\txfs_iunlock(ips[j], lock_mode);\n\t\t}\n\t\tif ((attempts % 5) == 0) {\n\t\t\tdelay(1); \n\t\t}\n\t\ti = 0;\n\t\ttry_lock = 0;\n\t\tgoto again;\n\t}\n}", "target": 0}
{"code": "static int oidc_session_redirect_parent_window_to_logout(request_rec *r,\n\t\toidc_cfg *c) {\n\toidc_debug(r, \"enter\");\n\tchar *java_script = apr_psprintf(r->pool,\n\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\"      window.top.location.href = '%s?session=logout';\\n\"\n\t\t\t\"    </script>\\n\", oidc_get_redirect_uri(r, c));\n\treturn oidc_util_html_send(r, \"Redirecting...\", java_script, NULL, NULL,\n\t\t\tOK);\n}", "target": 1}
{"code": "static noinline_for_stack void scrub_workers_put(struct btrfs_fs_info *fs_info)\n{\n\tif (--fs_info->scrub_workers_refcnt == 0) {\n\t\tbtrfs_destroy_workqueue(fs_info->scrub_workers);\n\t\tbtrfs_destroy_workqueue(fs_info->scrub_wr_completion_workers);\n\t\tbtrfs_destroy_workqueue(fs_info->scrub_parity_workers);\n\t}\n\tWARN_ON(fs_info->scrub_workers_refcnt < 0);\n}", "target": 0}
{"code": "LIR_Opr LIRGenerator::result_register_for(ValueType* type, bool callee) {\n  LIR_Opr opr;\n  switch (type->tag()) {\n    case intTag:     opr = FrameMap::rax_opr;          break;\n    case objectTag:  opr = FrameMap::rax_oop_opr;      break;\n    case longTag:    opr = FrameMap::long0_opr;        break;\n    case floatTag:   opr = UseSSE >= 1 ? FrameMap::xmm0_float_opr  : FrameMap::fpu0_float_opr;  break;\n    case doubleTag:  opr = UseSSE >= 2 ? FrameMap::xmm0_double_opr : FrameMap::fpu0_double_opr;  break;\n    case addressTag:\n    default: ShouldNotReachHere(); return LIR_OprFact::illegalOpr;\n  }\n  assert(opr->type_field() == as_OprType(as_BasicType(type)), \"type mismatch\");\n  return opr;\n}", "target": 0}
{"code": "void CLASS panasonic_load_raw()\n{\n  int row, col, i, j, sh = 0, pred[2], nonz[2];\n  pana_bits(0);\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < raw_width; col++)\n    {\n      if ((i = col % 14) == 0)\n        pred[0] = pred[1] = nonz[0] = nonz[1] = 0;\n      if (i % 3 == 2)\n        sh = 4 >> (3 - pana_bits(2));\n      if (nonz[i & 1])\n      {\n        if ((j = pana_bits(8)))\n        {\n          if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)\n            pred[i & 1] &= ~((~0u) << sh);\n          pred[i & 1] += j << sh;\n        }\n      }\n      else if ((nonz[i & 1] = pana_bits(8)) || i > 11)\n        pred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);\n      if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width)\n        derror();\n    }\n  }\n}", "target": 1}
{"code": "nl80211_parse_mcast_rate(struct cfg80211_registered_device *rdev,\n\t\t\t int mcast_rate[IEEE80211_NUM_BANDS],\n\t\t\t int rateval)\n{\n\tstruct wiphy *wiphy = &rdev->wiphy;\n\tbool found = false;\n\tint band, i;\n\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++) {\n\t\tstruct ieee80211_supported_band *sband;\n\t\tsband = wiphy->bands[band];\n\t\tif (!sband)\n\t\t\tcontinue;\n\t\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\t\tif (sband->bitrates[i].bitrate == rateval) {\n\t\t\t\tmcast_rate[band] = i + 1;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn found;\n}", "target": 0}
{"code": "blkxor(void * dest, void * src, size_t len)\n{\n  size_t * D = (size_t *) dest;\n  size_t * S = (size_t *) src;\n  size_t L = len / sizeof(size_t);\n  size_t i;\n  for (i = 0; i < L; i++)\n    D[i] ^= S[i];\n}", "target": 1}
{"code": "static void __exit mb2cache_exit(void)\n{\n\tkmem_cache_destroy(mb2_entry_cache);\n}", "target": 0}
{"code": "cmsBool  CMSEXPORT cmsAppendNamedColor(cmsNAMEDCOLORLIST* NamedColorList,\n                                       const char* Name,\n                                       cmsUInt16Number PCS[3], cmsUInt16Number Colorant[cmsMAXCHANNELS])\n{\n    cmsUInt32Number i;\n    if (NamedColorList == NULL) return FALSE;\n    if (NamedColorList ->nColors + 1 > NamedColorList ->Allocated) {\n        if (!GrowNamedColorList(NamedColorList)) return FALSE;\n    }\n    for (i=0; i < NamedColorList ->ColorantCount; i++)\n        NamedColorList ->List[NamedColorList ->nColors].DeviceColorant[i] = Colorant == NULL? 0 : Colorant[i];\n    for (i=0; i < 3; i++)\n        NamedColorList ->List[NamedColorList ->nColors].PCS[i] = PCS == NULL ? 0 : PCS[i];\n    if (Name != NULL) {\n        strncpy(NamedColorList ->List[NamedColorList ->nColors].Name, Name,\n                    sizeof(NamedColorList ->List[NamedColorList ->nColors].Name));\n        NamedColorList ->List[NamedColorList ->nColors].Name[cmsMAX_PATH-1] = 0;\n    }\n    else\n        NamedColorList ->List[NamedColorList ->nColors].Name[0] = 0;\n    NamedColorList ->nColors++;\n    return TRUE;\n}", "target": 1}
{"code": "Archive::Archive(RAROptions *InitCmd)\n{\n  Cmd=NULL; \n  DummyCmd=(InitCmd==NULL);\n  Cmd=DummyCmd ? (new RAROptions):InitCmd;\n  OpenShared=Cmd->OpenShared;\n  Format=RARFMT15;\n  Solid=false;\n  Volume=false;\n  MainComment=false;\n  Locked=false;\n  Signed=false;\n  FirstVolume=false;\n  NewNumbering=false;\n  SFXSize=0;\n  LatestTime.Reset();\n  Protected=false;\n  Encrypted=false;\n  FailedHeaderDecryption=false;\n  BrokenHeader=false;\n  LastReadBlock=0;\n  CurBlockPos=0;\n  NextBlockPos=0;\n  RecoverySize=-1;\n  RecoveryPercent=-1;\n  memset(&MainHead,0,sizeof(MainHead));\n  memset(&CryptHead,0,sizeof(CryptHead));\n  memset(&EndArcHead,0,sizeof(EndArcHead));\n  VolNumber=0;\n  VolWrite=0;\n  AddingFilesSize=0;\n  AddingHeadersSize=0;\n  *FirstVolumeName=0;\n  Splitting=false;\n  NewArchive=false;\n  SilentOpen=false;\n#ifdef USE_QOPEN\n  ProhibitQOpen=false;\n#endif\n}", "target": 0}
{"code": "static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_blkcipher rblkcipher;\n\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"ablkcipher\");\n\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t alg->cra_ablkcipher.geniv ?: \"<default>\");\n\trblkcipher.blocksize = alg->cra_blocksize;\n\trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\n\trblkcipher.max_keysize = alg->cra_ablkcipher.max_keysize;\n\trblkcipher.ivsize = alg->cra_ablkcipher.ivsize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\n\t\t    sizeof(struct crypto_report_blkcipher), &rblkcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\twhile (!list_empty(&tmp_list)) {\n\t\tbool disconnect;\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\t\tdisconnect = disconnect_mount(p, how);\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,\n\t\t\t\t disconnect ? &unmounted : NULL);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tif (!disconnect) {\n\t\t\t\tlist_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);\n\t\t\t} else {\n\t\t\t\tumount_mnt(p);\n\t\t\t}\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}", "target": 1}
{"code": "static Fixed lsr_translate_coords(GF_LASeRCodec *lsr, u32 val, u32 nb_bits)\n{\n\tif (!nb_bits) return 0;\n\tif (nb_bits>=32) return 0;\n#ifdef GPAC_FIXED_POINT\n\tif (val >> (nb_bits-1) ) {\n\t\ts64 neg = (s64) val - (0x00000001UL << nb_bits);\n\t\tif (neg < -FIX_ONE / 2)\n\t\t\treturn 2 * gf_divfix(INT2FIX(neg/2), lsr->res_factor);\n\t\treturn gf_divfix(INT2FIX(neg), lsr->res_factor);\n\t} else {\n\t\tif (val > FIX_ONE / 2)\n\t\t\treturn 2 * gf_divfix(INT2FIX(val/2), lsr->res_factor);\n\t\treturn gf_divfix(INT2FIX(val), lsr->res_factor);\n\t}\n#else\n\tif (val >> (nb_bits-1) ) {\n\t\ts64 neg = (s64) val - (0x00000001UL << nb_bits);\n\t\treturn ((Fixed)neg) / lsr->res_factor;\n\t} else {\n\t\treturn ((Fixed)val) / lsr->res_factor;\n\t}\n#endif\n}", "target": 0}
{"code": "copy_thread(unsigned long clone_flags, unsigned long stack_start,\n\t    unsigned long stk_sz, struct task_struct *p)\n{\n\tstruct thread_info *thread = task_thread_info(p);\n\tstruct pt_regs *childregs = task_pt_regs(p);\n\tmemset(&thread->cpu_context, 0, sizeof(struct cpu_context_save));\n\tif (likely(!(p->flags & PF_KTHREAD))) {\n\t\t*childregs = *current_pt_regs();\n\t\tchildregs->ARM_r0 = 0;\n\t\tif (stack_start)\n\t\t\tchildregs->ARM_sp = stack_start;\n\t} else {\n\t\tmemset(childregs, 0, sizeof(struct pt_regs));\n\t\tthread->cpu_context.r4 = stk_sz;\n\t\tthread->cpu_context.r5 = stack_start;\n\t\tchildregs->ARM_cpsr = SVC_MODE;\n\t}\n\tthread->cpu_context.pc = (unsigned long)ret_from_fork;\n\tthread->cpu_context.sp = (unsigned long)childregs;\n\tclear_ptrace_hw_breakpoint(p);\n\tif (clone_flags & CLONE_SETTLS)\n\t\tthread->tp_value = childregs->ARM_r3;\n\tthread_notify(THREAD_NOTIFY_COPY, thread);\n\treturn 0;\n}", "target": 1}
{"code": "static VALUE read_memory(VALUE klass, VALUE content)\n{\n  xmlSchemaPtr schema;\n  xmlSchemaParserCtxtPtr ctx = xmlSchemaNewMemParserCtxt(\n      (const char *)StringValuePtr(content),\n      (int)RSTRING_LEN(content)\n  );\n  VALUE rb_schema;\n  VALUE errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n#ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS\n  xmlSchemaSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n   schema = xmlSchemaParse(ctx);\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlSchemaFreeParserCtxt(ctx);\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n    return Qnil;\n  }\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n  return rb_schema;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const float min_input = context->input(1).flat<float>()(0);\n    const float max_input = context->input(2).flat<float>()(0);\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input.shape(), &output));\n    const T min_as_quantized = FloatToQuantized<T>(0.0f, min_input, max_input);\n    if (meta::IsSupportedAndEnabled() && std::is_same<T, quint8>()) {\n      auto input_ui8_array = input.flat<quint8>();\n      meta::Clamp(context, input_ui8_array.data(), input_ui8_array.size(),\n                  min_as_quantized, 255, output->flat<quint8>().data());\n    } else {\n      output->flat<T>().device(context->eigen_cpu_device()) =\n          input.flat<T>().cwiseMax(min_as_quantized).template cast<T>();\n    }\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));\n    output_min->flat<float>()(0) = min_input;\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max));\n    output_max->flat<float>()(0) = max_input;\n  }", "target": 1}
{"code": "u32 secure_ipv6_port_ephemeral(const __be32 *saddr, const __be32 *daddr,\n\t\t\t       __be16 dport)\n{\n\tstruct keydata *keyptr = get_keyptr();\n\tu32 hash[12];\n\tmemcpy(hash, saddr, 16);\n\thash[4] = (__force u32)dport;\n\tmemcpy(&hash[5], keyptr->secret, sizeof(__u32) * 7);\n\treturn twothirdsMD4Transform((const __u32 *)daddr, hash);\n}", "target": 1}
{"code": "ssh_packet_set_compress_state(struct ssh *ssh, struct sshbuf *m)\n{\n\tstruct session_state *state = ssh->state;\n\tstruct sshbuf *b = NULL;\n\tint r;\n\tconst u_char *inblob, *outblob;\n\tsize_t inl, outl;\n\tif ((r = sshbuf_froms(m, &b)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_get_string_direct(b, &inblob, &inl)) != 0 ||\n\t    (r = sshbuf_get_string_direct(b, &outblob, &outl)) != 0)\n\t\tgoto out;\n\tif (inl == 0)\n\t\tstate->compression_in_started = 0;\n\telse if (inl != sizeof(state->compression_in_stream)) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t} else {\n\t\tstate->compression_in_started = 1;\n\t\tmemcpy(&state->compression_in_stream, inblob, inl);\n\t}\n\tif (outl == 0)\n\t\tstate->compression_out_started = 0;\n\telse if (outl != sizeof(state->compression_out_stream)) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t} else {\n\t\tstate->compression_out_started = 1;\n\t\tmemcpy(&state->compression_out_stream, outblob, outl);\n\t}\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}", "target": 1}
{"code": "_pdfioTokenGet(_pdfio_token_t *tb,\t\n\t       char           *buffer,\t\n\t       size_t         bufsize)\t\n{\n  if (tb->num_tokens > 0)\n  {\n    tb->num_tokens --;\n    strncpy(buffer, tb->tokens[tb->num_tokens], bufsize - 1);\n    buffer[bufsize - 1] = '\\0';\n    PDFIO_DEBUG(\"_pdfioTokenGet(tb=%p, buffer=%p, bufsize=%u): Popping '%s' from stack.\\n\", tb, buffer, (unsigned)bufsize, buffer);\n    free(tb->tokens[tb->num_tokens]);\n    tb->tokens[tb->num_tokens] = NULL;\n    return (true);\n  }\n  return (_pdfioTokenRead(tb, buffer, bufsize));\n}", "target": 1}
{"code": "static char *oidc_cache_get_hashed_key(request_rec *r, const char *passphrase,\n\t\tconst char *key) {\n\tchar *input = apr_psprintf(r->pool, \"%s:%s\", passphrase, key);\n\tchar *output = NULL;\n\tif (oidc_util_hash_string_and_base64url_encode(r, OIDC_JOSE_ALG_SHA256,\n\t\t\tinput, &output) == FALSE) {\n\t\toidc_error(r,\n\t\t\t\t\"oidc_util_hash_string_and_base64url_encode returned an error\");\n\t\treturn NULL;\n\t}\n\treturn output;\n}", "target": 1}
{"code": "void fslib_copy_libs(const char *full_path) {\n\tassert(full_path);\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"    fslib_copy_libs %s\\n\", full_path);\n\tif (access(full_path, R_OK)) {\n\t\tif (arg_debug || arg_debug_private_lib)\n\t\t\tprintf(\"cannot find %s for private-lib, skipping...\\n\", full_path);\n\t\treturn;\n\t}\n\tunlink(RUN_LIB_FILE);\t\t\t  \n\tcreate_empty_file_as_root(RUN_LIB_FILE, 0644);\n\tif (chown(RUN_LIB_FILE, getuid(), getgid()))\n\t\terrExit(\"chown\");\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"    running fldd %s\\n\", full_path);\n\tsbox_run(SBOX_USER | SBOX_SECCOMP | SBOX_CAPS_NONE, 3, PATH_FLDD, full_path, RUN_LIB_FILE);\n\tFILE *fp = fopen(RUN_LIB_FILE, \"r\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tchar *ptr = strchr(buf, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\t\tfslib_duplicate(buf);\n\t}\n\tfclose(fp);\n\tunlink(RUN_LIB_FILE);\n}", "target": 0}
{"code": "init_ext2_xattr(void)\n{\n\text2_xattr_cache = mb_cache_create(\"ext2_xattr\", 6);\n\tif (!ext2_xattr_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}", "target": 1}
{"code": "int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)\n{\n\tu8 *buf = NULL;\n\tint err;\n\tif (!seed && slen) {\n\t\tbuf = kmalloc(slen, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t\tget_random_bytes(buf, slen);\n\t\tseed = buf;\n\t}\n\terr = tfm->seed(tfm, seed, slen);\n\tkfree(buf);\n\treturn err;\n}", "target": 1}
{"code": "void TightDecoder::FilterGradient(const rdr::U8* inbuf,\n                                  const PixelFormat& pf, PIXEL_T* outbuf,\n                                  int stride, const Rect& r)\n{\n  int x, y, c;\n  static rdr::U8 prevRow[TIGHT_MAX_WIDTH*3];\n  static rdr::U8 thisRow[TIGHT_MAX_WIDTH*3];\n  rdr::U8 pix[3]; \n  int est[3]; \n  memset(prevRow, 0, sizeof(prevRow));\n  int rectHeight = r.height();\n  int rectWidth = r.width();\n  for (y = 0; y < rectHeight; y++) {\n    pf.rgbFromBuffer(pix, &inbuf[y*rectWidth], 1);\n    for (c = 0; c < 3; c++)\n      pix[c] += prevRow[c];\n    memcpy(thisRow, pix, sizeof(pix));\n    pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride], pix, 1);\n    for (x = 1; x < rectWidth; x++) {\n      for (c = 0; c < 3; c++) {\n        est[c] = prevRow[x*3+c] + pix[c] - prevRow[(x-1)*3+c];\n        if (est[c] > 255) {\n          est[c] = 255;\n        } else if (est[c] < 0) {\n          est[c] = 0;\n        }\n      }\n      pf.rgbFromBuffer(pix, &inbuf[y*rectWidth+x], 1);\n      for (c = 0; c < 3; c++)\n        pix[c] += est[c];\n      memcpy(&thisRow[x*3], pix, sizeof(pix));\n      pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride+x], pix, 1);\n    }\n    memcpy(prevRow, thisRow, sizeof(prevRow));\n  }\n}", "target": 1}
{"code": "void OfflineAudioDestinationHandler::SuspendOfflineRendering() {\n  DCHECK(!IsMainThread());\n  PostCrossThreadTask(\n      *main_thread_task_runner_, FROM_HERE,\n      CrossThreadBind(&OfflineAudioDestinationHandler::NotifySuspend,\n                      WrapRefCounted(this), Context()->CurrentSampleFrame()));\n}", "target": 0}
{"code": "const char *jsi_GetHomeDir(Jsi_Interp *interp) {\n    const char *str = NULL;\n    if (interp->homeDir)\n        return interp->homeDir;\n#ifdef __WIN32\n    str = getenv(\"USERPROFILE\"); \n#else\n    if ((str = getenv(\"HOME\")) == NULL) {\n        struct passwd pwd, *pw;\n        char buf[20000];\n        if (getpwuid_r(getuid(), &pwd, buf, sizeof(buf), &pw) == 0 && pw->pw_dir)        \n            str = pw->pw_dir;\n    }\n#endif\n    if (!str) {\n        Jsi_LogBug(\"no home dir\");\n        str = \"/\";\n    }\n#ifdef JSI_LITE_ONLY\n    return str;\n#else\n    return (interp->homeDir = Jsi_KeyAdd(interp, str));\n#endif\n}", "target": 1}
{"code": "char *LibRaw_file_datastream::gets(char *str, int sz)\n{\n  if(sz<1) return NULL;\n  LR_STREAM_CHK();\n  std::istream is(f.get());\n  is.getline(str, sz);\n  if (is.fail())\n    return 0;\n  return str;\n}", "target": 0}
{"code": "bool WebContentsImpl::UpdateTitleForEntry(NavigationEntryImpl* entry,\n                                          const string16& title) {\n  string16 final_title;\n  bool explicit_set;\n  if (entry && entry->GetURL().SchemeIsFile() && title.empty()) {\n    final_title = UTF8ToUTF16(entry->GetURL().ExtractFileName());\n    explicit_set = false;  \n  } else {\n    TrimWhitespace(title, TRIM_ALL, &final_title);\n    explicit_set = true;\n  }\n  if (entry) {\n    if (final_title == entry->GetTitle())\n      return false;  \n    entry->SetTitle(final_title);\n  } else {\n    if (page_title_when_no_navigation_entry_ == final_title)\n      return false;  \n    page_title_when_no_navigation_entry_ = final_title;\n  }\n  view_->SetPageTitle(final_title);\n  std::pair<NavigationEntry*, bool> details =\n      std::make_pair(entry, explicit_set);\n  NotificationService::current()->Notify(\n      NOTIFICATION_WEB_CONTENTS_TITLE_UPDATED,\n      Source<WebContents>(this),\n      Details<std::pair<NavigationEntry*, bool> >(&details));\n  return true;\n}", "target": 0}
{"code": "static CACHE_BITMAP_V3_ORDER* update_read_cache_bitmap_v3_order(rdpUpdate* update, wStream* s,\n                                                                UINT16 flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\tUINT32 new_len;\n\tBYTE* new_data;\n\tCACHE_BITMAP_V3_ORDER* cache_bitmap_v3;\n\tif (!update || !s)\n\t\treturn NULL;\n\tcache_bitmap_v3 = calloc(1, sizeof(CACHE_BITMAP_V3_ORDER));\n\tif (!cache_bitmap_v3)\n\t\tgoto fail;\n\tcache_bitmap_v3->cacheId = flags & 0x00000003;\n\tcache_bitmap_v3->flags = (flags & 0x0000FF80) >> 7;\n\tbitsPerPixelId = (flags & 0x00000078) >> 3;\n\tcache_bitmap_v3->bpp = CBR23_BPP[bitsPerPixelId];\n\tif (Stream_GetRemainingLength(s) < 21)\n\t\tgoto fail;\n\tStream_Read_UINT16(s, cache_bitmap_v3->cacheIndex); \n\tStream_Read_UINT32(s, cache_bitmap_v3->key1);       \n\tStream_Read_UINT32(s, cache_bitmap_v3->key2);       \n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tStream_Read_UINT8(s, bitmapData->bpp);\n\tif ((bitmapData->bpp < 1) || (bitmapData->bpp > 32))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"invalid bpp value %\" PRIu32 \"\", bitmapData->bpp);\n\t\tgoto fail;\n\t}\n\tStream_Seek_UINT8(s);                      \n\tStream_Seek_UINT8(s);                      \n\tStream_Read_UINT8(s, bitmapData->codecID); \n\tStream_Read_UINT16(s, bitmapData->width);  \n\tStream_Read_UINT16(s, bitmapData->height); \n\tStream_Read_UINT32(s, new_len);            \n\tif (Stream_GetRemainingLength(s) < new_len)\n\t\tgoto fail;\n\tnew_data = (BYTE*)realloc(bitmapData->data, new_len);\n\tif (!new_data)\n\t\tgoto fail;\n\tbitmapData->data = new_data;\n\tbitmapData->length = new_len;\n\tStream_Read(s, bitmapData->data, bitmapData->length);\n\treturn cache_bitmap_v3;\nfail:\n\tfree_cache_bitmap_v3_order(update->context, cache_bitmap_v3);\n\treturn NULL;\n}", "target": 1}
{"code": "list_table_status(MYSQL *mysql,const char *db,const char *wild)\n{\n  char query[1024],*end;\n  MYSQL_RES *result;\n  MYSQL_ROW row;\n  end=strxmov(query,\"show table status from `\",db,\"`\",NullS);\n  if (wild && wild[0])\n    strxmov(end,\" like '\",wild,\"'\",NullS);\n  if (mysql_query(mysql,query) || !(result=mysql_store_result(mysql)))\n  {\n    fprintf(stderr,\"%s: Cannot get status for db: %s, table: %s: %s\\n\",\n\t    my_progname,db,wild ? wild : \"\",mysql_error(mysql));\n    if (mysql_errno(mysql) == ER_PARSE_ERROR)\n      fprintf(stderr,\"This error probably means that your MySQL server doesn't support the\\n\\'show table status' command.\\n\");\n    return 1;\n  }\n  printf(\"Database: %s\",db);\n  if (wild)\n    printf(\"  Wildcard: %s\",wild);\n  putchar('\\n');\n  print_res_header(result);\n  while ((row=mysql_fetch_row(result)))\n    print_res_row(result,row);\n  print_res_top(result);\n  mysql_free_result(result);\n  return 0;\n}", "target": 1}
{"code": "Resource* ResourceHost::getResource(std::string uri) {\n\tif (uri.length() > 255 || uri.empty())\n\t\treturn NULL;\n\tif (uri.find(\"../\") != std::string::npos)\n\t\treturn NULL;\n\tstd::string path = baseDiskPath + uri;\n\tResource* res = NULL;\n\tstruct stat sb;\n\tif (stat(path.c_str(), &sb) == -1)\n\t\treturn NULL; \n\tif (sb.st_mode & S_IFDIR) { \n\t\tres = readDirectory(path, sb);\n\t} else if (sb.st_mode & S_IFREG) { \n\t\tres = readFile(path, sb);\n\t} else { \n\t\treturn NULL;\n\t}\n\treturn res;\n}", "target": 0}
{"code": "static int __br_mdb_del(struct net_bridge *br, struct br_mdb_entry *entry)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tstruct br_ip ip;\n\tint err = -EINVAL;\n\tif (!netif_running(br->dev) || br->multicast_disabled)\n\t\treturn -EINVAL;\n\tif (timer_pending(&br->multicast_querier_timer))\n\t\treturn -EBUSY;\n\tip.proto = entry->addr.proto;\n\tif (ip.proto == htons(ETH_P_IP))\n\t\tip.u.ip4 = entry->addr.u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\telse\n\t\tip.u.ip6 = entry->addr.u.ip6;\n#endif\n\tspin_lock_bh(&br->multicast_lock);\n\tmdb = mlock_dereference(br->mdb, br);\n\tmp = br_mdb_ip_get(mdb, &ip);\n\tif (!mp)\n\t\tgoto unlock;\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (!p->port || p->port->dev->ifindex != entry->ifindex)\n\t\t\tcontinue;\n\t\tif (p->port->state == BR_STATE_DISABLED)\n\t\t\tgoto unlock;\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n\t\tdel_timer(&p->timer);\n\t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n\t\terr = 0;\n\t\tif (!mp->ports && !mp->mglist &&\n\t\t    netif_running(br->dev))\n\t\t\tmod_timer(&mp->timer, jiffies);\n\t\tbreak;\n\t}\nunlock:\n\tspin_unlock_bh(&br->multicast_lock);\n\treturn err;\n}", "target": 1}
{"code": "do_bid_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap __attribute__((__unused__)), uint32_t namesz, uint32_t descsz,\n    size_t noff, size_t doff, int *flags)\n{\n\tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"GNU\") == 0 &&\n\t    type == NT_GNU_BUILD_ID && (descsz >= 4 || descsz <= 20)) {\n\t\tuint8_t desc[20];\n\t\tconst char *btype;\n\t\tuint32_t i;\n\t\t*flags |= FLAGS_DID_BUILD_ID;\n\t\tswitch (descsz) {\n\t\tcase 8:\n\t\t    btype = \"xxHash\";\n\t\t    break;\n\t\tcase 16:\n\t\t    btype = \"md5/uuid\";\n\t\t    break;\n\t\tcase 20:\n\t\t    btype = \"sha1\";\n\t\t    break;\n\t\tdefault:\n\t\t    btype = \"unknown\";\n\t\t    break;\n\t\t}\n\t\tif (file_printf(ms, \", BuildID[%s]=\", btype) == -1)\n\t\t\treturn 1;\n\t\t(void)memcpy(desc, &nbuf[doff], descsz);\n\t\tfor (i = 0; i < descsz; i++)\n\t\t    if (file_printf(ms, \"%02x\", desc[i]) == -1)\n\t\t\treturn 1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int snd_compr_allocate_buffer(struct snd_compr_stream *stream,\n\t\tstruct snd_compr_params *params)\n{\n\tunsigned int buffer_size;\n\tvoid *buffer;\n\tif (params->buffer.fragment_size == 0 ||\n\t    params->buffer.fragments > SIZE_MAX / params->buffer.fragment_size)\n\t\treturn -EINVAL;\n\tbuffer_size = params->buffer.fragment_size * params->buffer.fragments;\n\tif (stream->ops->copy) {\n\t\tbuffer = NULL;\n\t} else {\n\t\tbuffer = kmalloc(buffer_size, GFP_KERNEL);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t}\n\tstream->runtime->fragment_size = params->buffer.fragment_size;\n\tstream->runtime->fragments = params->buffer.fragments;\n\tstream->runtime->buffer = buffer;\n\tstream->runtime->buffer_size = buffer_size;\n\treturn 0;\n}", "target": 0}
{"code": "void SFS_ObjectMethodCall(ScriptParser *parser)\n{\n\tif (parser->codec->LastError) return;\n\tSFS_Expression(parser);\n\tif (parser->codec->LastError) return;\n\tSFS_AddString(parser, \".\");\n\tSFS_Identifier(parser);\n\tSFS_AddString(parser, \"(\");\n\tSFS_Params(parser);\n\tSFS_AddString(parser, \")\");\n}", "target": 0}
{"code": "static int adpt_queue_lck(struct scsi_cmnd *cmd)\n{\n\tadpt_hba* pHba = NULL;\n\tstruct adpt_device* pDev = NULL;\t\n\tif ((cmd->cmnd[0] == REQUEST_SENSE) && (cmd->sense_buffer[0] != 0)) {\n\t\tcmd->result = (DID_OK << 16);\n\t\tscsi_done(cmd);\n\t\treturn 0;\n\t}\n\tpHba = (adpt_hba*)cmd->device->host->hostdata[0];\n\tif (!pHba) {\n\t\treturn FAILED;\n\t}\n\trmb();\n\tif ((pHba->state) & DPTI_STATE_RESET)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\tif((pDev = (struct adpt_device*) (cmd->device->hostdata)) == NULL) {\n\t\tif ((pDev = adpt_find_device(pHba, (u32)cmd->device->channel, (u32)cmd->device->id, cmd->device->lun)) == NULL) {\n\t\t\tcmd->result = (DID_NO_CONNECT << 16);\n\t\t\tscsi_done(cmd);\n\t\t\treturn 0;\n\t\t}\n\t\tcmd->device->hostdata = pDev;\n\t}\n\tpDev->pScsi_dev = cmd->device;\n\tif (pDev->state & DPTI_DEV_RESET ) {\n\t\treturn FAILED;\n\t}\n\treturn adpt_scsi_to_i2o(pHba, cmd, pDev);\n}", "target": 1}
{"code": "show_tree(tree_t *t,                    \n          int    indent)                \n{\n  while (t)\n  {\n    if (t->markup == MARKUP_NONE)\n      printf(\"%*s\\\"%s\\\"\\n\", indent, \"\", t->data);\n    else\n      printf(\"%*s%s\\n\", indent, \"\", _htmlMarkups[t->markup]);\n    if (t->child)\n      show_tree(t->child, indent + 2);\n    t = t->next;\n  }\n}", "target": 1}
{"code": "pktap_if_print(netdissect_options *ndo,\n               const struct pcap_pkthdr *h, const u_char *p)\n{\n\tuint32_t dlt, hdrlen, rectype;\n\tu_int caplen = h->caplen;\n\tu_int length = h->len;\n\tif_printer printer;\n\tconst pktap_header_t *hdr;\n\tif (caplen < sizeof(pktap_header_t) || length < sizeof(pktap_header_t)) {\n\t\tND_PRINT((ndo, \"[|pktap]\"));\n\t\treturn (0);\n\t}\n\thdr = (const pktap_header_t *)p;\n\tdlt = EXTRACT_LE_32BITS(&hdr->pkt_dlt);\n\thdrlen = EXTRACT_LE_32BITS(&hdr->pkt_len);\n\tif (hdrlen < sizeof(pktap_header_t)) {\n\t\tND_PRINT((ndo, \"[|pktap]\"));\n\t\treturn (0);\n\t}\n\tif (caplen < hdrlen || length < hdrlen) {\n\t\tND_PRINT((ndo, \"[|pktap]\"));\n\t\treturn (hdrlen);\n\t}\n\tif (ndo->ndo_eflag)\n\t\tpktap_header_print(ndo, p, length);\n\tlength -= hdrlen;\n\tcaplen -= hdrlen;\n\tp += hdrlen;\n\trectype = EXTRACT_LE_32BITS(&hdr->pkt_rectype);\n\tswitch (rectype) {\n\tcase PKT_REC_NONE:\n\t\tND_PRINT((ndo, \"no data\"));\n\t\tbreak;\n\tcase PKT_REC_PACKET:\n\t\tif ((printer = lookup_printer(dlt)) != NULL) {\n\t\t\thdrlen += printer(ndo, h, p);\n\t\t} else {\n\t\t\tif (!ndo->ndo_eflag)\n\t\t\t\tpktap_header_print(ndo, (const u_char *)hdr,\n\t\t\t\t\t\tlength + hdrlen);\n\t\t\tif (!ndo->ndo_suppress_default_print)\n\t\t\t\tND_DEFAULTPRINT(p, caplen);\n\t\t}\n\t\tbreak;\n\t}\n\treturn (hdrlen);\n}", "target": 1}
{"code": "static __be32 nfsacld_proc_setacl(struct svc_rqst * rqstp,\n\t\tstruct nfsd3_setaclargs *argp,\n\t\tstruct nfsd_attrstat *resp)\n{\n\tstruct inode *inode;\n\tsvc_fh *fh;\n\t__be32 nfserr = 0;\n\tint error;\n\tdprintk(\"nfsd: SETACL(2acl)   %s\\n\", SVCFH_fmt(&argp->fh));\n\tfh = fh_copy(&resp->fh, &argp->fh);\n\tnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);\n\tif (nfserr)\n\t\tgoto out;\n\tinode = d_inode(fh->fh_dentry);\n\tif (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {\n\t\terror = -EOPNOTSUPP;\n\t\tgoto out_errno;\n\t}\n\terror = fh_want_write(fh);\n\tif (error)\n\t\tgoto out_errno;\n\terror = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);\n\tif (error)\n\t\tgoto out_drop_write;\n\terror = inode->i_op->set_acl(inode, argp->acl_default,\n\t\t\t\t     ACL_TYPE_DEFAULT);\n\tif (error)\n\t\tgoto out_drop_write;\n\tfh_drop_write(fh);\n\tnfserr = fh_getattr(fh, &resp->stat);\nout:\n\tposix_acl_release(argp->acl_access);\n\tposix_acl_release(argp->acl_default);\n\treturn nfserr;\nout_drop_write:\n\tfh_drop_write(fh);\nout_errno:\n\tnfserr = nfserrno(error);\n\tgoto out;\n}", "target": 1}
{"code": "static bool do_write_pids(pid_t tpid, const char *contrl, const char *cg, const char *file, const char *buf)\n{\n\tint sock[2] = {-1, -1};\n\tpid_t qpid, cpid = -1;\n\tFILE *pids_file = NULL;\n\tbool answer = false, fail = false;\n\tpids_file = open_pids_file(contrl, cg);\n\tif (!pids_file)\n\t\treturn false;\n\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, sock) < 0) {\n\t\tperror(\"socketpair\");\n\t\tgoto out;\n\t}\n\tcpid = fork();\n\tif (cpid == -1)\n\t\tgoto out;\n\tif (!cpid) { \n\t\tfclose(pids_file);\n\t\tpid_from_ns_wrapper(sock[1], tpid);\n\t}\n\tconst char *ptr = buf;\n\twhile (sscanf(ptr, \"%d\", &qpid) == 1) {\n\t\tstruct ucred cred;\n\t\tchar v;\n\t\tif (write(sock[0], &qpid, sizeof(qpid)) != sizeof(qpid)) {\n\t\t\tfprintf(stderr, \"%s: error writing pid to child: %s\\n\",\n\t\t\t\t__func__, strerror(errno));\n\t\t\tgoto out;\n\t\t}\n\t\tif (recv_creds(sock[0], &cred, &v)) {\n\t\t\tif (v == '0') {\n\t\t\t\tif (fprintf(pids_file, \"%d\", (int) cred.pid) < 0)\n\t\t\t\t\tfail = true;\n\t\t\t}\n\t\t}\n\t\tptr = strchr(ptr, '\\n');\n\t\tif (!ptr)\n\t\t\tbreak;\n\t\tptr++;\n\t}\n\tqpid = -1;\n\tif (write(sock[0], &qpid ,sizeof(qpid)) != sizeof(qpid))\n\t\tfprintf(stderr, \"Warning: failed to ask child to exit\\n\");\n\tif (!fail)\n\t\tanswer = true;\nout:\n\tif (cpid != -1)\n\t\twait_for_pid(cpid);\n\tif (sock[0] != -1) {\n\t\tclose(sock[0]);\n\t\tclose(sock[1]);\n\t}\n\tif (pids_file) {\n\t\tif (fclose(pids_file) != 0)\n\t\t\tanswer = false;\n\t}\n\treturn answer;\n}", "target": 1}
{"code": "void SFS_CompoundExpression(ScriptParser *parser)\n{\n\tif (parser->codec->LastError) return;\n\tSFS_Expression(parser);\n\tif (! gf_bs_read_int(parser->bs, 1)) return;\n\tif (parser->codec->LastError) return;\n\tSFS_AddString(parser, \",\");\n\tSFS_CompoundExpression(parser);\n}", "target": 0}
{"code": "void setScaleAndScrollAndLayout(WebKit::WebView* webView, WebPoint scroll, float scale)\n{\n    webView->setPageScaleFactor(scale, WebPoint(scroll.x, scroll.y));\n    webView->layout();\n}", "target": 0}
{"code": "sudo_lbuf_append_esc_v1(struct sudo_lbuf *lbuf, int flags, const char *fmt, ...)\n{\n    unsigned int saved_len = lbuf->len;\n    bool ret = false;\n    const char *s;\n    va_list ap;\n    debug_decl(sudo_lbuf_append_esc, SUDO_DEBUG_UTIL);\n    if (sudo_lbuf_error(lbuf))\n\tdebug_return_bool(false);\n#define should_escape(ch) \\\n    ((ISSET(flags, LBUF_ESC_CNTRL) && iscntrl((unsigned char)ch)) || \\\n    (ISSET(flags, LBUF_ESC_BLANK) && isblank((unsigned char)ch)))\n#define should_quote(ch) \\\n    (ISSET(flags, LBUF_ESC_QUOTE) && (ch == '\\'' || ch == '\\\\'))\n    va_start(ap, fmt);\n    while (*fmt != '\\0') {\n\tif (fmt[0] == '%' && fmt[1] == 's') {\n\t    if ((s = va_arg(ap, char *)) == NULL)\n\t\ts = \"(NULL)\";\n\t    while (*s != '\\0') {\n\t\tif (should_escape(*s)) {\n\t\t    if (!sudo_lbuf_expand(lbuf, sizeof(\"#0177\") - 1))\n\t\t\tgoto done;\n\t\t    lbuf->len += escape(*s++, lbuf->buf + lbuf->len);\n\t\t    continue;\n\t\t}\n\t\tif (should_quote(*s)) {\n\t\t    if (!sudo_lbuf_expand(lbuf, 2))\n\t\t\tgoto done;\n\t\t    lbuf->buf[lbuf->len++] = '\\\\';\n\t\t    lbuf->buf[lbuf->len++] = *s++;\n\t\t    continue;\n\t\t}\n\t\tif (!sudo_lbuf_expand(lbuf, 1))\n\t\t    goto done;\n\t\tlbuf->buf[lbuf->len++] = *s++;\n\t    }\n\t    fmt += 2;\n\t    continue;\n\t}\n\tif (should_escape(*fmt)) {\n\t    if (!sudo_lbuf_expand(lbuf, sizeof(\"#0177\") - 1))\n\t\tgoto done;\n\t    if (*fmt == '\\'') {\n\t\tlbuf->buf[lbuf->len++] = '\\\\';\n\t\tlbuf->buf[lbuf->len++] = *fmt++;\n\t    } else {\n\t\tlbuf->len += escape(*fmt++, lbuf->buf + lbuf->len);\n\t    }\n\t    continue;\n\t}\n\tif (!sudo_lbuf_expand(lbuf, 1))\n\t    goto done;\n\tlbuf->buf[lbuf->len++] = *fmt++;\n    }\n    ret = true;\ndone:\n    if (!ret)\n\tlbuf->len = saved_len;\n    if (lbuf->size != 0)\n\tlbuf->buf[lbuf->len] = '\\0';\n    va_end(ap);\n    debug_return_bool(ret);\n}", "target": 0}
{"code": "pam_converse (int num_msg, PAM_CONVERSE_ARG2_TYPE **msg,\n  struct pam_response **resp, void *appdata_ptr)\n{\nint sep = 0;\nstruct pam_response *reply;\nif (  pam_arg_ended\n   || !(reply = malloc(sizeof(struct pam_response) * num_msg)))\n  return PAM_CONV_ERR;\nfor (int i = 0; i < num_msg; i++)\n  {\n  uschar *arg;\n  switch (msg[i]->msg_style)\n    {\n    case PAM_PROMPT_ECHO_ON:\n    case PAM_PROMPT_ECHO_OFF:\n      if (!(arg = string_nextinlist(&pam_args, &sep, NULL, 0)))\n\t{\n\targ = US\"\";\n\tpam_arg_ended = TRUE;\n\t}\n      reply[i].resp = CS string_copy_malloc(arg); \n      reply[i].resp_retcode = PAM_SUCCESS;\n      break;\n    case PAM_TEXT_INFO:    \n    case PAM_ERROR_MSG:\n      reply[i].resp_retcode = PAM_SUCCESS;\n      reply[i].resp = NULL;\n      break;\n    default:  \n      free(reply);\n      pam_conv_had_error = TRUE;\n      return PAM_CONV_ERR;\n    }\n  }\n*resp = reply;\nreturn PAM_SUCCESS;\n}", "target": 1}
{"code": "nvkm_vmm_node_delete(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n{\n\tnvkm_vmm_node_remove(vmm, vma);\n\tlist_del(&vma->head);\n\tkfree(vma);\n}", "target": 0}
{"code": "get_authname(int type)\n{\n\tstatic char buf[1024];\n\tswitch (type) {\n\tcase SSH_CMSG_AUTH_PASSWORD:\n\t\treturn \"password\";\n\tcase SSH_CMSG_AUTH_RSA:\n\t\treturn \"rsa\";\n\tcase SSH_CMSG_AUTH_RHOSTS_RSA:\n\t\treturn \"rhosts-rsa\";\n\tcase SSH_CMSG_AUTH_RHOSTS:\n\t\treturn \"rhosts\";\n\tcase SSH_CMSG_AUTH_TIS:\n\tcase SSH_CMSG_AUTH_TIS_RESPONSE:\n\t\treturn \"challenge-response\";\n#if defined(KRB4) || defined(KRB5)\n\tcase SSH_CMSG_AUTH_KERBEROS:\n\t\treturn \"kerberos\";\n#endif\n\t}\n\tsnprintf(buf, sizeof buf, \"bad-auth-msg-%d\", type);\n\treturn buf;\n}", "target": 0}
{"code": "process_pointer_pdu(STREAM s)\n{\n\tuint16 message_type;\n\tuint16 x, y;\n\tin_uint16_le(s, message_type);\n\tin_uint8s(s, 2);\t\n\tswitch (message_type)\n\t{\n\t\tcase RDP_POINTER_MOVE:\n\t\t\tin_uint16_le(s, x);\n\t\t\tin_uint16_le(s, y);\n\t\t\tif (s_check(s))\n\t\t\t\tui_move_pointer(x, y);\n\t\t\tbreak;\n\t\tcase RDP_POINTER_COLOR:\n\t\t\tprocess_colour_pointer_pdu(s);\n\t\t\tbreak;\n\t\tcase RDP_POINTER_CACHED:\n\t\t\tprocess_cached_pointer_pdu(s);\n\t\t\tbreak;\n\t\tcase RDP_POINTER_SYSTEM:\n\t\t\tprocess_system_pointer_pdu(s);\n\t\t\tbreak;\n\t\tcase RDP_POINTER_NEW:\n\t\t\tprocess_new_pointer_pdu(s);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tunimpl(\"Pointer message 0x%x\\n\", message_type);\n\t}\n}", "target": 0}
{"code": "static int websocket_send(lua_State *L) {\n    lastCFunction = __func__;\n    std::string str = checkstring(L, 1);\n    if (config.http_max_websocket_message > 0 && str.size() > (unsigned)config.http_max_websocket_message) luaL_error(L, \"Message is too large\");\n    ws_handle * ws = *(ws_handle**)lua_touserdata(L, lua_upvalueindex(1));\n    if (ws == NULL) luaL_error(L, \"attempt to use a closed file\");\n    std::lock_guard<std::mutex> lock(ws->lock);\n    if (ws->ws == NULL) return luaL_error(L, \"attempt to use a closed file\");\n    if (ws->ws->sendFrame(str.c_str(), str.size(), (int)WebSocket::FRAME_FLAG_FIN | (int)(lua_toboolean(L, 2) ? WebSocket::FRAME_BINARY : WebSocket::FRAME_TEXT)) < 1) \n        websocket_close(L);\n    return 0;\n}", "target": 1}
{"code": "static int dispatch_discard_io(struct xen_blkif *blkif,\n\t\t\t\tstruct blkif_request *req)\n{\n\tint err = 0;\n\tint status = BLKIF_RSP_OKAY;\n\tstruct block_device *bdev = blkif->vbd.bdev;\n\tunsigned long secure;\n\tblkif->st_ds_req++;\n\txen_blkif_get(blkif);\n\tsecure = (blkif->vbd.discard_secure &&\n\t\t (req->u.discard.flag & BLKIF_DISCARD_SECURE)) ?\n\t\t BLKDEV_DISCARD_SECURE : 0;\n\terr = blkdev_issue_discard(bdev, req->u.discard.sector_number,\n\t\t\t\t   req->u.discard.nr_sectors,\n\t\t\t\t   GFP_KERNEL, secure);\n\tif (err == -EOPNOTSUPP) {\n\t\tpr_debug(DRV_PFX \"discard op failed, not supported\\n\");\n\t\tstatus = BLKIF_RSP_EOPNOTSUPP;\n\t} else if (err)\n\t\tstatus = BLKIF_RSP_ERROR;\n\tmake_response(blkif, req->u.discard.id, req->operation, status);\n\txen_blkif_put(blkif);\n\treturn err;\n}", "target": 1}
{"code": "void xenvif_disconnect(struct xenvif *vif)\n{\n\tstruct net_device *dev = vif->dev;\n\tif (netif_carrier_ok(dev)) {\n\t\trtnl_lock();\n\t\tnetif_carrier_off(dev); \n\t\tif (netif_running(dev))\n\t\t\txenvif_down(vif);\n\t\trtnl_unlock();\n\t\txenvif_put(vif);\n\t}\n\tatomic_dec(&vif->refcnt);\n\twait_event(vif->waiting_to_free, atomic_read(&vif->refcnt) == 0);\n\tdel_timer_sync(&vif->credit_timeout);\n\tif (vif->irq)\n\t\tunbind_from_irqhandler(vif->irq, vif);\n\tunregister_netdev(vif->dev);\n\txen_netbk_unmap_frontend_rings(vif);\n\tfree_netdev(vif->dev);\n}", "target": 1}
{"code": "    template<typename tc>\n    CImg<T>& draw_circle(const int x0, const int y0, int radius,\n                         const tc *const color, const float opacity=1) {\n      if (is_empty()) return *this;\n      if (!color)\n        throw CImgArgumentException(_cimg_instance\n                                    \"draw_circle(): Specified color is (null).\",\n                                    cimg_instance);\n      cimg_init_scanline(color,opacity);\n      if (radius<0 || x0 - radius>=width() || y0 + radius<0 || y0 - radius>=height()) return *this;\n      if (y0>=0 && y0<height()) cimg_draw_scanline(x0 - radius,x0 + radius,y0,color,opacity,1);\n      for (int f = 1 - radius, ddFx = 0, ddFy = -(radius<<1), x = 0, y = radius; x<y; ) {\n        if (f>=0) {\n          const int x1 = x0 - x, x2 = x0 + x, y1 = y0 - y, y2 = y0 + y;\n          if (y1>=0 && y1<height()) cimg_draw_scanline(x1,x2,y1,color,opacity,1);\n          if (y2>=0 && y2<height()) cimg_draw_scanline(x1,x2,y2,color,opacity,1);\n          f+=(ddFy+=2); --y;\n        }\n        const bool no_diag = y!=(x++);\n        ++(f+=(ddFx+=2));\n        const int x1 = x0 - y, x2 = x0 + y, y1 = y0 - x, y2 = y0 + x;\n        if (no_diag) {\n          if (y1>=0 && y1<height()) cimg_draw_scanline(x1,x2,y1,color,opacity,1);\n          if (y2>=0 && y2<height()) cimg_draw_scanline(x1,x2,y2,color,opacity,1);\n        }\n      }\n      return *this;", "target": 0}
{"code": "int use_env()\n{\n    int indent;\n    size_t flags = 0;\n    json_t *json;\n    json_error_t error;\n    #ifdef _WIN32\n    _setmode(_fileno(stdout), _O_BINARY);\n    _setmode(_fileno(stderr), _O_BINARY);\n    #endif\n    indent = getenv_int(\"JSON_INDENT\");\n    if(indent < 0 || indent > 255) {\n        fprintf(stderr, \"invalid value for JSON_INDENT: %d\\n\", indent);\n        return 2;\n    }\n    if(indent > 0)\n        flags |= JSON_INDENT(indent);\n    if(getenv_int(\"JSON_COMPACT\") > 0)\n        flags |= JSON_COMPACT;\n    if(getenv_int(\"JSON_ENSURE_ASCII\"))\n        flags |= JSON_ENSURE_ASCII;\n    if(getenv_int(\"JSON_PRESERVE_ORDER\"))\n        flags |= JSON_PRESERVE_ORDER;\n    if(getenv_int(\"JSON_SORT_KEYS\"))\n         flags |= JSON_SORT_KEYS;\n    if(getenv_int(\"STRIP\")) {\n        size_t size = 0, used = 0;\n        char *buffer = NULL;\n        while(1) {\n            size_t count;\n            size = (size == 0 ? 128 : size * 2);\n            buffer = realloc(buffer, size);\n            if(!buffer) {\n                fprintf(stderr, \"Unable to allocate %d bytes\\n\", (int)size);\n                return 1;\n            }\n            count = fread(buffer + used, 1, size - used, stdin);\n            if(count < size - used) {\n                buffer[used + count] = '\\0';\n                break;\n            }\n            used += count;\n        }\n        json = json_loads(strip(buffer), 0, &error);\n        free(buffer);\n    }\n    else\n        json = json_loadf(stdin, 0, &error);\n    if(!json) {\n        fprintf(stderr, \"%d %d %d\\n%s\\n\",\n            error.line, error.column,\n            error.position, error.text);\n        return 1;\n    }\n    json_dumpf(json, stdout, flags);\n    json_decref(json);\n    return 0;\n}", "target": 1}
{"code": "static void __xen_evtchn_do_upcall(void)\n{\n\tstruct vcpu_info *vcpu_info = __this_cpu_read(xen_vcpu);\n\tint cpu = smp_processor_id();\n\tread_lock(&evtchn_rwlock);\n\tdo {\n\t\tvcpu_info->evtchn_upcall_pending = 0;\n\t\txen_evtchn_handle_events(cpu);\n\t\tBUG_ON(!irqs_disabled());\n\t\tvirt_rmb(); \n\t} while (vcpu_info->evtchn_upcall_pending);\n\tread_unlock(&evtchn_rwlock);\n}", "target": 0}
{"code": "static inline bool can_follow_write_pte(pte_t pte, unsigned int flags)\n{\n\treturn pte_write(pte) ||\n\t\t((flags & FOLL_FORCE) && (flags & FOLL_COW) && pte_dirty(pte));\n}", "target": 0}
{"code": "void G711::describe()\n{\n\tif (mode() == Compress)\n\t{\n\t\tm_outChunk->f.compressionType = m_track->f.compressionType;\n\t}\n\telse\n\t{\n\t\tm_outChunk->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\t\tm_outChunk->f.compressionType = AF_COMPRESSION_NONE;\n\t}\n}", "target": 0}
{"code": "should_hex_escape (gunichar           c,\n                   FlatpakEscapeFlags flags)\n{\n  if ((flags & FLATPAK_ESCAPE_ALLOW_NEWLINES) && c == '\\n')\n    return FALSE;\n  return !is_char_safe (c);\n}", "target": 0}
{"code": "static int orinoco_ioctl_set_auth(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\thermes_t *hw = &priv->hw;\n\tstruct iw_param *param = &wrqu->param;\n\tunsigned long flags;\n\tint ret = -EINPROGRESS;\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\tswitch (param->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_WPA_VERSION:\n\tcase IW_AUTH_CIPHER_PAIRWISE:\n\tcase IW_AUTH_CIPHER_GROUP:\n\tcase IW_AUTH_RX_UNENCRYPTED_EAPOL:\n\tcase IW_AUTH_PRIVACY_INVOKED:\n\tcase IW_AUTH_DROP_UNENCRYPTED:\n\t\tbreak;\n\tcase IW_AUTH_KEY_MGMT:\n\t\tpriv->key_mgmt = param->value;\n\t\tbreak;\n\tcase IW_AUTH_TKIP_COUNTERMEASURES:\n\t\tif (param->value) {\n\t\t\tpriv->tkip_cm_active = 1;\n\t\t\tret = hermes_enable_port(hw, 0);\n\t\t} else {\n\t\t\tpriv->tkip_cm_active = 0;\n\t\t\tret = hermes_disable_port(hw, 0);\n\t\t}\n\t\tbreak;\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tif (param->value & IW_AUTH_ALG_SHARED_KEY)\n\t\t\tpriv->wep_restrict = 1;\n\t\telse if (param->value & IW_AUTH_ALG_OPEN_SYSTEM)\n\t\t\tpriv->wep_restrict = 0;\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tif (priv->has_wpa) {\n\t\t\tpriv->wpa_enabled = param->value ? 1 : 0;\n\t\t} else {\n\t\t\tif (param->value)\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\tpriv->wpa_enabled = 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t}\n\torinoco_unlock(priv, &flags);\n\treturn ret;\n}", "target": 1}
{"code": "static gg_action_t gg_handle_connecting(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state)\n{\n\tint res;\n\tsess->soft_timeout = 0;\n\tif (gg_async_connect_failed(sess, &res)) {\n\t\tgg_debug_session(sess, GG_DEBUG_MISC, \"\n\t\tclose(sess->fd);\n\t\tsess->fd = -1;\n\t\tsess->resolver_index++;\n\t\tsess->state = alt_state;\n\t} else {\n\t\tif (sess->state != GG_STATE_CONNECTING_PROXY_HUB) {\n\t\t\tfree(sess->resolver_result);\n\t\t\tsess->resolver_result = NULL;\n\t\t}\n\t\tsess->state = next_state;\n\t}\n\treturn GG_ACTION_NEXT;\n}", "target": 0}
{"code": "static void remove_full(struct kmem_cache *s, struct kmem_cache_node *n, struct page *page)\n{\n\tif (!(s->flags & SLAB_STORE_USER))\n\t\treturn;\n\tlockdep_assert_held(&n->list_lock);\n\tlist_del(&page->slab_list);\n}", "target": 0}
{"code": "static int decode_bit_string(const u8 * inbuf, size_t inlen, void *outbuf,\n\t\t\t     size_t outlen, int invert)\n{\n\tconst u8 *in = inbuf;\n\tu8 *out = (u8 *) outbuf;\n\tint zero_bits = *in & 0x07;\n\tsize_t octets_left = inlen - 1;\n\tint i, count = 0;\n\tmemset(outbuf, 0, outlen);\n\tin++;\n\tif (outlen < octets_left)\n\t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n\tif (inlen < 1)\n\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\twhile (octets_left) {\n\t\tint bits_to_go;\n\t\t*out = 0;\n\t\tif (octets_left == 1)\n\t\t\tbits_to_go = 8 - zero_bits;\n\t\telse\n\t\t\tbits_to_go = 8;\n\t\tif (invert)\n\t\t\tfor (i = 0; i < bits_to_go; i++) {\n\t\t\t\t*out |= ((*in >> (7 - i)) & 1) << i;\n\t\t\t}\n\t\telse {\n\t\t\t*out = *in;\n\t\t}\n\t\tout++;\n\t\tin++;\n\t\toctets_left--;\n\t\tcount++;\n\t}\n\treturn (count * 8) - zero_bits;\n}", "target": 1}
{"code": "bool RenderWidgetHostImpl::SurfacePropertiesMismatch(\n    const RenderWidgetSurfaceProperties& first,\n    const RenderWidgetSurfaceProperties& second) const {\n#ifdef OS_ANDROID\n  if (enable_surface_synchronization_) {\n    RenderWidgetSurfaceProperties second_reduced = second;\n    second_reduced.top_controls_height = first.top_controls_height;\n    second_reduced.top_controls_shown_ratio = first.top_controls_shown_ratio;\n    second_reduced.bottom_controls_height = first.bottom_controls_height;\n    second_reduced.bottom_controls_shown_ratio =\n        first.bottom_controls_shown_ratio;\n    second_reduced.selection = first.selection;\n    return first != second_reduced;\n  }\n#endif\n  return first != second;\n}", "target": 0}
{"code": "B44Compressor::B44Compressor\n    (const Header &hdr,\n     size_t maxScanLineSize,\n     size_t numScanLines,\n     bool optFlatFields)\n:\n    Compressor (hdr),\n    _maxScanLineSize (maxScanLineSize),\n    _optFlatFields (optFlatFields),\n    _format (XDR),\n    _numScanLines (numScanLines),\n    _tmpBuffer (0),\n    _outBuffer (0),\n    _numChans (0),\n    _channels (hdr.channels()),\n    _channelData (0)\n{\n    (void)_maxScanLineSize;\n    _tmpBuffer = new unsigned short\n        [checkArraySize (uiMult (maxScanLineSize, numScanLines),\n                         sizeof (unsigned short))];\n    const ChannelList &channels = header().channels();\n    int numHalfChans = 0;\n    for (ChannelList::ConstIterator c = channels.begin();\n\t c != channels.end();\n\t ++c)\n    {\n\tassert (pixelTypeSize (c.channel().type) % pixelTypeSize (HALF) == 0);\n\t++_numChans;\n\tif (c.channel().type == HALF)\n\t    ++numHalfChans;\n    }\n    size_t padding = 12 * numHalfChans * (numScanLines + 3) / 4;\n    _outBuffer = new char\n        [uiAdd (uiMult (maxScanLineSize, numScanLines), padding)];\n    _channelData = new ChannelData[_numChans];\n    int i = 0;\n    for (ChannelList::ConstIterator c = channels.begin();\n\t c != channels.end();\n\t ++c, ++i)\n    {\n\t_channelData[i].ys = c.channel().ySampling;\n\t_channelData[i].type = c.channel().type;\n\t_channelData[i].pLinear = c.channel().pLinear;\n\t_channelData[i].size =\n\t    pixelTypeSize (c.channel().type) / pixelTypeSize (HALF);\n    }\n    const Box2i &dataWindow = hdr.dataWindow();\n    _minX = dataWindow.min.x;\n    _maxX = dataWindow.max.x;\n    _maxY = dataWindow.max.y;\n    assert (sizeof (unsigned short) == pixelTypeSize (HALF));\n    if (_numChans == numHalfChans)\n\t_format = NATIVE;\n}", "target": 1}
{"code": "static Status ValidateSavedTensors(const GraphDef& graph_def) {\n  for (const auto& node : graph_def.node()) {\n    TF_RETURN_IF_ERROR(ValidateNode(node));\n  }\n  if (graph_def.has_library()) {\n    const FunctionDefLibrary& library = graph_def.library();\n    for (const auto& function : library.function()) {\n      for (const auto& node : function.node_def()) {\n        TF_RETURN_IF_ERROR(ValidateNode(node));\n      }\n      TF_RETURN_IF_ERROR(ValidateFunctionNotRecursive(function));\n    }\n  }\n  return Status::OK();\n}", "target": 0}
{"code": "int mpol_parse_str(char *str, struct mempolicy **mpol)\n{\n\tstruct mempolicy *new = NULL;\n\tunsigned short mode_flags;\n\tnodemask_t nodes;\n\tchar *nodelist = strchr(str, ':');\n\tchar *flags = strchr(str, '=');\n\tint err = 1, mode;\n\tif (flags)\n\t\t*flags++ = '\\0';\t\n\tif (nodelist) {\n\t\t*nodelist++ = '\\0';\n\t\tif (nodelist_parse(nodelist, nodes))\n\t\t\tgoto out;\n\t\tif (!nodes_subset(nodes, node_states[N_MEMORY]))\n\t\t\tgoto out;\n\t} else\n\t\tnodes_clear(nodes);\n\tmode = match_string(policy_modes, MPOL_MAX, str);\n\tif (mode < 0)\n\t\tgoto out;\n\tswitch (mode) {\n\tcase MPOL_PREFERRED:\n\t\tif (nodelist) {\n\t\t\tchar *rest = nodelist;\n\t\t\twhile (isdigit(*rest))\n\t\t\t\trest++;\n\t\t\tif (*rest)\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase MPOL_INTERLEAVE:\n\t\tif (!nodelist)\n\t\t\tnodes = node_states[N_MEMORY];\n\t\tbreak;\n\tcase MPOL_LOCAL:\n\t\tif (nodelist)\n\t\t\tgoto out;\n\t\tmode = MPOL_PREFERRED;\n\t\tbreak;\n\tcase MPOL_DEFAULT:\n\t\tif (!nodelist)\n\t\t\terr = 0;\n\t\tgoto out;\n\tcase MPOL_BIND:\n\t\tif (!nodelist)\n\t\t\tgoto out;\n\t}\n\tmode_flags = 0;\n\tif (flags) {\n\t\tif (!strcmp(flags, \"static\"))\n\t\t\tmode_flags |= MPOL_F_STATIC_NODES;\n\t\telse if (!strcmp(flags, \"relative\"))\n\t\t\tmode_flags |= MPOL_F_RELATIVE_NODES;\n\t\telse\n\t\t\tgoto out;\n\t}\n\tnew = mpol_new(mode, mode_flags, &nodes);\n\tif (IS_ERR(new))\n\t\tgoto out;\n\tif (mode != MPOL_PREFERRED)\n\t\tnew->v.nodes = nodes;\n\telse if (nodelist)\n\t\tnew->v.preferred_node = first_node(nodes);\n\telse\n\t\tnew->flags |= MPOL_F_LOCAL;\n\tnew->w.user_nodemask = nodes;\n\terr = 0;\nout:\n\tif (nodelist)\n\t\t*--nodelist = ':';\n\tif (flags)\n\t\t*--flags = '=';\n\tif (!err)\n\t\t*mpol = new;\n\treturn err;\n}", "target": 1}
{"code": "static gboolean has_internal_nul(const char* str, int len) {\n\twhile (len > 0 && str[len-1] == 0)\n\t\tlen--;\n\treturn strlen(str) != len;\n}", "target": 0}
{"code": "static xmlParserInputPtr plist_xml_external_entity_loader(const char *URL, const char *ID, xmlParserCtxtPtr ctxt)\n{\n    return NULL;\n}", "target": 0}
{"code": "void KPasswordDlg::keyPressed( QKeyEvent *e )\n{\n  static bool waitForAuthentication = false;\n  if (!waitForAuthentication) {\n\tswitch ( e->key() )\n\t{\n\t\tcase Key_Backspace:\n\t\t\t{\n\t\t\t\tint len = password.length();\n\t\t\t\tif ( len ) {\n\t\t\t\t\tpassword.truncate( len - 1 );\n\t\t\t\t\tif( stars )\n\t\t\t\t\t\tshowStars();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Key_Return:\n            timer.stop();\n\t\t\twaitForAuthentication = true;\n\t\t\tif ( tryPassword() )\n\t\t\t\temit passOk();\n\t\t\telse\n\t\t\t{\n\t\t\t\tlabel->setText( glocale->translate(\"Failed\") );\n\t\t\t\tpassword = \"\";\n\t\t\t\ttimerMode = 1;\n\t\t\t\ttimer.start( 1500, TRUE );\n\t\t\t}\n\t\t\twaitForAuthentication = false;\n\t\t\tbreak;\n\t\tcase Key_Escape:\n\t\t\temit passCancel();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif ( password.length() < MAX_PASSWORD_LENGTH )\n\t\t\t{\n\t\t\t\tpassword += (char)e->ascii();\n\t\t\t\tif( stars )\n\t\t\t\t\tshowStars();\n\t\t\t\ttimer.changeInterval( 10000 );\n\t\t\t}\n\t}\n  }\n}", "target": 0}
{"code": "static void vgacon_putc(struct vc_data *vc, int c, int ypos, int xpos) { }", "target": 0}
{"code": "add_key_equal_fields(JOIN *join, KEY_FIELD **key_fields, uint and_level,\n                     Item_bool_func *cond, Item *field_item,\n                     bool eq_func, Item **val,\n                     uint num_values, table_map usable_tables,\n                     SARGABLE_PARAM **sargables, uint row_col_no= 0)\n{\n  Field *field= ((Item_field *) (field_item->real_item()))->field;\n  add_key_field(join, key_fields, and_level, cond, field,\n                eq_func, val, num_values, usable_tables, sargables,\n                row_col_no);\n  Item_equal *item_equal= field_item->get_item_equal();\n  if (item_equal)\n  { \n    Item_equal_fields_iterator it(*item_equal);\n    while (it++)\n    {\n      Field *equal_field= it.get_curr_field();\n      if (!field->eq(equal_field))\n      {\n        add_key_field(join, key_fields, and_level, cond, equal_field,\n                      eq_func, val, num_values, usable_tables,\n                      sargables, row_col_no);\n      }\n    }\n  }\n}", "target": 0}
{"code": "bool WasmBinaryBuilder::maybeVisitRefCast(Expression*& out, uint32_t code) {\n  if (code == BinaryConsts::RefCast) {\n    auto* rtt = popNonVoidExpression();\n    auto* ref = popNonVoidExpression();\n    out = Builder(wasm).makeRefCast(ref, rtt);\n    return true;\n  } else if (code == BinaryConsts::RefCastStatic) {\n    auto intendedType = getIndexedHeapType();\n    auto* ref = popNonVoidExpression();\n    out = Builder(wasm).makeRefCast(ref, intendedType);\n    return true;\n  }\n  return false;\n}", "target": 0}
{"code": "pick_table_access_method(JOIN_TAB *tab)\n{\n  switch (tab->type) \n  {\n  case JT_REF:\n    tab->read_first_record= join_read_always_key;\n    tab->read_record.read_record_func= join_read_next_same;\n    break;\n  case JT_REF_OR_NULL:\n    tab->read_first_record= join_read_always_key_or_null;\n    tab->read_record.read_record_func= join_read_next_same_or_null;\n    break;\n  case JT_CONST:\n    tab->read_first_record= join_read_const;\n    tab->read_record.read_record_func= join_no_more_records;\n    break;\n  case JT_EQ_REF:\n    tab->read_first_record= join_read_key;\n    tab->read_record.read_record_func= join_no_more_records;\n    break;\n  case JT_FT:\n    tab->read_first_record= join_ft_read_first;\n    tab->read_record.read_record_func= join_ft_read_next;\n    break;\n  case JT_SYSTEM:\n    tab->read_first_record= join_read_system;\n    tab->read_record.read_record_func= join_no_more_records;\n    break;\n  default:\n    break;  \n  }\n}", "target": 0}
{"code": "append_hex_escaped_character (GString *result,\n                              gunichar c)\n{\n  if (c <= 0xFF)\n    g_string_append_printf (result, \"\\\\x%02X\", c);\n  else if (c <= 0xFFFF)\n    g_string_append_printf (result, \"\\\\u%04X\", c);\n  else\n    g_string_append_printf (result, \"\\\\U%08X\", c);\n}", "target": 0}
{"code": "QStringList JlCompress::extractDir(QuaZip &zip, const QString &dir)\n{\n    if(!zip.open(QuaZip::mdUnzip)) {\n        return QStringList();\n    }\n    QDir directory(dir);\n    QStringList extracted;\n    if (!zip.goToFirstFile()) {\n        return QStringList();\n    }\n    do {\n        QString name = zip.getCurrentFileName();\n        QString absFilePath = directory.absoluteFilePath(name);\n        if (!extractFile(&zip, \"\", absFilePath)) {\n            removeFile(extracted);\n            return QStringList();\n        }\n        extracted.append(absFilePath);\n    } while (zip.goToNextFile());\n    zip.close();\n    if(zip.getZipError()!=0) {\n        removeFile(extracted);\n        return QStringList();\n    }\n    return extracted;\n}", "target": 1}
{"code": "void big_key_revoke(struct key *key)\n{\n\tstruct path *path = (struct path *)&key->payload.data[big_key_path];\n\tkey_payload_reserve(key, 0);\n\tif (key_is_instantiated(key) &&\n\t    (size_t)key->payload.data[big_key_len] > BIG_KEY_FILE_THRESHOLD)\n\t\tvfs_truncate(path, 0);\n}", "target": 1}
{"code": "static int translate_desc(struct vhost_dev *dev, u64 addr, u32 len,\n\t\t\t  struct iovec iov[], int iov_size)\n{\n\tconst struct vhost_memory_region *reg;\n\tstruct vhost_memory *mem;\n\tstruct iovec *_iov;\n\tu64 s = 0;\n\tint ret = 0;\n\trcu_read_lock();\n\tmem = rcu_dereference(dev->memory);\n\twhile ((u64)len > s) {\n\t\tu64 size;\n\t\tif (unlikely(ret >= iov_size)) {\n\t\t\tret = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\treg = find_region(mem, addr, len);\n\t\tif (unlikely(!reg)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\t_iov = iov + ret;\n\t\tsize = reg->memory_size - addr + reg->guest_phys_addr;\n\t\t_iov->iov_len = min((u64)len, size);\n\t\t_iov->iov_base = (void __user *)(unsigned long)\n\t\t\t(reg->userspace_addr + addr - reg->guest_phys_addr);\n\t\ts += size;\n\t\taddr += size;\n\t\t++ret;\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}", "target": 1}
{"code": "void CLASS bad_pixels (const char *cfname)\n{\n  FILE *fp=NULL;\n#ifndef LIBRAW_LIBRARY_BUILD\n  char *fname, *cp, line[128];\n  int len, time, row, col, r, c, rad, tot, n, fixed=0;\n#else\n  char *cp, line[128];\n  int time, row, col, r, c, rad, tot, n;\n#ifdef DCRAW_VERBOSE\n  int fixed = 0;\n#endif\n#endif\n  if (!filters) return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,0,2);\n#endif\n  if (cfname)\n    fp = fopen (cfname, \"r\");\n#line 4009 \"dcraw/dcraw.c\"\n  if (!fp)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_BADPIXELMAP;\n#endif\n          return;\n      }\n  while (fgets (line, 128, fp)) {\n    cp = strchr (line, '#');\n    if (cp) *cp = 0;\n    if (sscanf (line, \"%d %d %d\", &col, &row, &time) != 3) continue;\n    if ((unsigned) col >= width || (unsigned) row >= height) continue;\n    if (time > timestamp) continue;\n    for (tot=n=0, rad=1; rad < 3 && n==0; rad++)\n      for (r = row-rad; r <= row+rad; r++)\n\tfor (c = col-rad; c <= col+rad; c++)\n\t  if ((unsigned) r < height && (unsigned) c < width &&\n\t\t(r != row || c != col) && fcol(r,c) == fcol(row,col)) {\n\t    tot += BAYER2(r,c);\n\t    n++;\n\t  }\n    BAYER2(row,col) = tot/n;\n#ifdef DCRAW_VERBOSE\n    if (verbose) {\n      if (!fixed++)\n\tfprintf (stderr,_(\"Fixed dead pixels at:\"));\n      fprintf (stderr, \" %d,%d\", col, row);\n    }\n#endif\n  }\n#ifdef DCRAW_VERBOSE\n  if (fixed) fputc ('\\n', stderr);\n#endif\n  fclose (fp);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,1,2);\n#endif\n}", "target": 1}
{"code": "static int ScaKwdTab(GmfMshSct *msh)\n{\n   int      KwdCod, c;\n   int64_t  NexPos, EndPos, LstPos;\n   char     str[ GmfStrSiz ];\n   if(msh->typ & Asc)\n   {\n      while(fscanf(msh->hdl, \"%s\", str) != EOF)\n      {\n         if(isalpha(str[0]))\n         {\n            for(KwdCod=1; KwdCod<= GmfMaxKwd; KwdCod++)\n               if(!strcmp(str, GmfKwdFmt[ KwdCod ][0]))\n               {\n                  ScaKwdHdr(msh, KwdCod);\n                  break;\n               }\n         }\n         else if(str[0] == '#')\n            while((c = fgetc(msh->hdl)) != '\\n' && c != EOF);\n      }\n   }\n   else\n   {\n      EndPos = GetFilSiz(msh);\n      LstPos = -1;\n      do\n      {\n         ScaWrd(msh, ( char *)&KwdCod);\n         NexPos = GetPos(msh);\n         if(NexPos > EndPos)\n            longjmp(msh->err, -24);\n         if(NexPos && (NexPos <= LstPos))\n            longjmp(msh->err, -30);\n         LstPos = NexPos;\n         if( (KwdCod >= 1) && (KwdCod <= GmfMaxKwd) )\n            ScaKwdHdr(msh, KwdCod);\n         if(NexPos && !(SetFilPos(msh, NexPos)))\n            longjmp(msh->err, -25);\n      }while(NexPos && (KwdCod != GmfEnd));\n   }\n   return(1);\n}", "target": 1}
{"code": "sort_page_names (gconstpointer a,\n                 gconstpointer b)\n{\n\tconst char *name_1, *name_2;\n\tgchar *key_1, *key_2;\n\tgboolean sort_last_1, sort_last_2;\n\tint compare;\n\tname_1 = * (const char **) a;\n\tname_2 = * (const char **) b;\n\t#define SORT_LAST_CHAR1 '.'\n\t#define SORT_LAST_CHAR2 '#'\n\tsort_last_1 = name_1[0] == SORT_LAST_CHAR1 || name_1[0] == SORT_LAST_CHAR2;\n\tsort_last_2 = name_2[0] == SORT_LAST_CHAR1 || name_2[0] == SORT_LAST_CHAR2;\n\t#undef SORT_LAST_CHAR1\n\t#undef SORT_LAST_CHAR2\n\tif (sort_last_1 && !sort_last_2)\n\t{\n\t\tcompare = +1;\n\t}\n\telse if (!sort_last_1 && sort_last_2)\n\t{\n\t\tcompare = -1;\n\t}\n\telse\n\t{\n\t\tkey_1 = g_utf8_collate_key_for_filename (name_1, -1);\n\t\tkey_2 = g_utf8_collate_key_for_filename (name_2, -1);\n\t\tcompare = strcmp (key_1, key_2);\n\t\tg_free (key_1);\n\t\tg_free (key_2);\n\t}\n\treturn compare;\n}", "target": 1}
{"code": "static ext4_io_end_t *ext4_init_io_end (struct inode *inode)\n{\n\text4_io_end_t *io = NULL;\n\tio = kmalloc(sizeof(*io), GFP_NOFS);\n\tif (io) {\n\t\tigrab(inode);\n\t\tio->inode = inode;\n\t\tio->flag = 0;\n\t\tio->offset = 0;\n\t\tio->size = 0;\n\t\tio->error = 0;\n\t\tINIT_WORK(&io->work, ext4_end_io_work);\n\t\tINIT_LIST_HEAD(&io->list);\n\t}\n\treturn io;\n}", "target": 1}
{"code": "    **/\n    CImg<T>& autocrop(const T *const color=0, const char *const axes=\"zyx\") {\n      if (is_empty()) return *this;\n      if (!color) { \n        const CImg<T> col1 = get_vector_at(0,0,0);\n        const unsigned int w = _width, h = _height, d = _depth, s = _spectrum;\n        autocrop(col1,axes);\n        if (_width==w && _height==h && _depth==d && _spectrum==s) {\n          const CImg<T> col2 = get_vector_at(w - 1,h - 1,d - 1);\n          autocrop(col2,axes);\n        }\n        return *this;\n      }\n      for (const char *s = axes; *s; ++s) {\n        const char axis = cimg::lowercase(*s);\n        switch (axis) {\n        case 'x' : {\n\t  int x0 = width(), x1 = -1;\n\t  cimg_forC(*this,c) {\n\t    const CImg<intT> coords = get_shared_channel(c)._autocrop(color[c],'x');\n\t    const int nx0 = coords[0], nx1 = coords[1];\n\t    if (nx0>=0 && nx1>=0) { x0 = std::min(x0,nx0); x1 = std::max(x1,nx1); }\n\t  }\n          if (x0==width() && x1==-1) return assign(); else crop(x0,x1);\n\t} break;\n        case 'y' : {\n\t  int y0 = height(), y1 = -1;\n\t  cimg_forC(*this,c) {\n\t    const CImg<intT> coords = get_shared_channel(c)._autocrop(color[c],'y');\n\t    const int ny0 = coords[0], ny1 = coords[1];\n\t    if (ny0>=0 && ny1>=0) { y0 = std::min(y0,ny0); y1 = std::max(y1,ny1); }\n\t  }\n          if (y0==height() && y1==-1) return assign(); else crop(0,y0,_width - 1,y1);\n\t} break;\n        default : {\n\t  int z0 = depth(), z1 = -1;\n\t  cimg_forC(*this,c) {\n\t    const CImg<intT> coords = get_shared_channel(c)._autocrop(color[c],'z');\n\t    const int nz0 = coords[0], nz1 = coords[1];\n\t    if (nz0>=0 && nz1>=0) { z0 = std::min(z0,nz0); z1 = std::max(z1,nz1); }\n\t  }\n\t  if (z0==depth() && z1==-1) return assign(); else crop(0,0,z0,_width - 1,_height - 1,z1);\n\t}\n        }\n      }\n      return *this;", "target": 0}
{"code": "save_positions (GPtrArray *page_names)\n{\n\tguint i;\n\tGHashTable *ht;\n\tht = g_hash_table_new (g_str_hash, g_str_equal);\n\tfor (i = 0; i < page_names->len; i++)\n\t\tg_hash_table_insert (ht, page_names->pdata[i], GUINT_TO_POINTER(i + 1));\n\treturn ht;\n}", "target": 0}
{"code": "add_link_ref(\n\tstruct link_ref **references,\n\tconst uint8_t *name, size_t name_size)\n{\n\tstruct link_ref *ref = calloc(1, sizeof(struct link_ref));\n\tif (!ref)\n\t\treturn NULL;\n\tref->id = hash_link_ref(name, name_size);\n\tref->next = references[ref->id % REF_TABLE_SIZE];\n\treferences[ref->id % REF_TABLE_SIZE] = ref;\n\treturn ref;\n}", "target": 1}
{"code": "int LibRaw_bigfile_datastream::seek(INT64 o, int whence)\n{\n  LR_BF_CHK();\n#if defined(_WIN32)\n#ifdef WIN32SECURECALLS\n  return _fseeki64(f, o, whence);\n#else\n  return fseek(f, (long)o, whence);\n#endif\n#else\n  return fseeko(f, o, whence);\n#endif\n}", "target": 0}
{"code": "void EditorClientBlackBerry::didWriteSelectionToPasteboard()\n{\n    notImplemented();\n}", "target": 0}
{"code": "static void wait_limit_netblock_del(rbnode_type* n, void* ATTR_UNUSED(arg))\n{\n\tfree(n);\n}", "target": 0}
{"code": "MagickExport int LocaleUppercase(const int c)\n{\n  if (c == EOF)\n    return(c);\n#if defined(MAGICKCORE_LOCALE_SUPPORT)\n  if (c_locale != (locale_t) NULL)\n    return(toupper_l((int) ((unsigned char) c),c_locale));\n#endif\n  return(toupper((int) ((unsigned char) c)));\n}", "target": 0}
{"code": "void BlockCodec::runPull()\n{\n\tAFframecount framesToRead = m_outChunk->frameCount;\n\tAFframecount framesRead = 0;\n\tassert(framesToRead % m_framesPerPacket == 0);\n\tint blockCount = framesToRead / m_framesPerPacket;\n\tssize_t bytesRead = read(m_inChunk->buffer, m_bytesPerPacket * blockCount);\n\tint blocksRead = bytesRead >= 0 ? bytesRead / m_bytesPerPacket : 0;\n\tfor (int i=0; i<blocksRead; i++)\n\t{\n\t\tdecodeBlock(static_cast<const uint8_t *>(m_inChunk->buffer) + i * m_bytesPerPacket,\n\t\t\tstatic_cast<int16_t *>(m_outChunk->buffer) + i * m_framesPerPacket * m_track->f.channelCount);\n\t\tframesRead += m_framesPerPacket;\n\t}\n\tm_track->nextfframe += framesRead;\n\tassert(tell() == m_track->fpos_next_frame);\n\tif (framesRead < framesToRead)\n\t\treportReadError(framesRead, framesToRead);\n\tm_outChunk->frameCount = framesRead;\n}", "target": 1}
{"code": "static SDL_Surface* Create_Surface_Solid(int width, int height, SDL_Color fg, Uint32 *color)\n{\n    const int alignment = Get_Alignement() - 1;\n    SDL_Surface *textbuf;\n    Sint64 size;\n    void *pixels, *ptr;\n    Sint64 pitch = width + alignment;\n    pitch += alignment;\n    pitch &= ~alignment;\n    size = height * pitch + sizeof (void *) + alignment;\n    if (size < 0 || size > SDL_MAX_SINT32) {\n        return NULL;\n    }\n    ptr = SDL_malloc((size_t)size);\n    if (ptr == NULL) {\n        return NULL;\n    }\n    pixels = (void *)(((uintptr_t)ptr + sizeof(void *) + alignment) & ~alignment);\n    ((void **)pixels)[-1] = ptr;\n    textbuf = SDL_CreateRGBSurfaceWithFormatFrom(pixels, width, height, 0, pitch, SDL_PIXELFORMAT_INDEX8);\n    if (textbuf == NULL) {\n        SDL_free(ptr);\n        return NULL;\n    }\n    textbuf->flags &= ~SDL_PREALLOC;\n    textbuf->flags |= SDL_SIMD_ALIGNED;\n    SDL_memset(pixels, 0, height * pitch);\n    *color = 1;\n    {\n        SDL_Palette *palette = textbuf->format->palette;\n        palette->colors[0].r = 255 - fg.r;\n        palette->colors[0].g = 255 - fg.g;\n        palette->colors[0].b = 255 - fg.b;\n        palette->colors[1].r = fg.r;\n        palette->colors[1].g = fg.g;\n        palette->colors[1].b = fg.b;\n        palette->colors[1].a = fg.a;\n    }\n    SDL_SetColorKey(textbuf, SDL_TRUE, 0);\n    return textbuf;", "target": 1}
{"code": "int adis_update_scan_mode(struct iio_dev *indio_dev,\n\tconst unsigned long *scan_mask)\n{\n\tstruct adis *adis = iio_device_get_drvdata(indio_dev);\n\tconst struct iio_chan_spec *chan;\n\tunsigned int scan_count;\n\tunsigned int i, j;\n\t__be16 *tx, *rx;\n\tkfree(adis->xfer);\n\tkfree(adis->buffer);\n\tif (adis->burst && adis->burst->en)\n\t\treturn adis_update_scan_mode_burst(indio_dev, scan_mask);\n\tscan_count = indio_dev->scan_bytes / 2;\n\tadis->xfer = kcalloc(scan_count + 1, sizeof(*adis->xfer), GFP_KERNEL);\n\tif (!adis->xfer)\n\t\treturn -ENOMEM;\n\tadis->buffer = kcalloc(indio_dev->scan_bytes, 2, GFP_KERNEL);\n\tif (!adis->buffer)\n\t\treturn -ENOMEM;\n\trx = adis->buffer;\n\ttx = rx + scan_count;\n\tspi_message_init(&adis->msg);\n\tfor (j = 0; j <= scan_count; j++) {\n\t\tadis->xfer[j].bits_per_word = 8;\n\t\tif (j != scan_count)\n\t\t\tadis->xfer[j].cs_change = 1;\n\t\tadis->xfer[j].len = 2;\n\t\tadis->xfer[j].delay_usecs = adis->data->read_delay;\n\t\tif (j < scan_count)\n\t\t\tadis->xfer[j].tx_buf = &tx[j];\n\t\tif (j >= 1)\n\t\t\tadis->xfer[j].rx_buf = &rx[j - 1];\n\t\tspi_message_add_tail(&adis->xfer[j], &adis->msg);\n\t}\n\tchan = indio_dev->channels;\n\tfor (i = 0; i < indio_dev->num_channels; i++, chan++) {\n\t\tif (!test_bit(chan->scan_index, scan_mask))\n\t\t\tcontinue;\n\t\tif (chan->scan_type.storagebits == 32)\n\t\t\t*tx++ = cpu_to_be16((chan->address + 2) << 8);\n\t\t*tx++ = cpu_to_be16(chan->address << 8);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int crypto_ccm_auth(struct aead_request *req, struct scatterlist *plain,\n\t\t\t   unsigned int cryptlen)\n{\n\tstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\n\tAHASH_REQUEST_ON_STACK(ahreq, ctx->mac);\n\tunsigned int assoclen = req->assoclen;\n\tstruct scatterlist sg[3];\n\tu8 odata[16];\n\tu8 idata[16];\n\tint ilen, err;\n\terr = format_input(odata, req, cryptlen);\n\tif (err)\n\t\tgoto out;\n\tsg_init_table(sg, 3);\n\tsg_set_buf(&sg[0], odata, 16);\n\tif (assoclen) {\n\t\tilen = format_adata(idata, assoclen);\n\t\tsg_set_buf(&sg[1], idata, ilen);\n\t\tsg_chain(sg, 3, req->src);\n\t} else {\n\t\tilen = 0;\n\t\tsg_chain(sg, 2, req->src);\n\t}\n\tahash_request_set_tfm(ahreq, ctx->mac);\n\tahash_request_set_callback(ahreq, pctx->flags, NULL, NULL);\n\tahash_request_set_crypt(ahreq, sg, NULL, assoclen + ilen + 16);\n\terr = crypto_ahash_init(ahreq);\n\tif (err)\n\t\tgoto out;\n\terr = crypto_ahash_update(ahreq);\n\tif (err)\n\t\tgoto out;\n\tilen = 16 - (assoclen + ilen) % 16;\n\tif (ilen < 16) {\n\t\tmemset(idata, 0, ilen);\n\t\tsg_init_table(sg, 2);\n\t\tsg_set_buf(&sg[0], idata, ilen);\n\t\tif (plain)\n\t\t\tsg_chain(sg, 2, plain);\n\t\tplain = sg;\n\t\tcryptlen += ilen;\n\t}\n\tahash_request_set_crypt(ahreq, plain, pctx->odata, cryptlen);\n\terr = crypto_ahash_finup(ahreq);\nout:\n\treturn err;\n}", "target": 1}
{"code": "static void dp8393x_do_load_cam(dp8393xState *s)\n{\n    int width, size;\n    uint16_t index = 0;\n    width = (s->regs[SONIC_DCR] & SONIC_DCR_DW) ? 2 : 1;\n    size = sizeof(uint16_t) * 4 * width;\n    while (s->regs[SONIC_CDC] & 0x1f) {\n        address_space_read(&s->as, dp8393x_cdp(s),\n                           MEMTXATTRS_UNSPECIFIED, s->data, size);\n        s->cam[index][0] = dp8393x_get(s, width, 1) & 0xff;\n        s->cam[index][1] = dp8393x_get(s, width, 1) >> 8;\n        s->cam[index][2] = dp8393x_get(s, width, 2) & 0xff;\n        s->cam[index][3] = dp8393x_get(s, width, 2) >> 8;\n        s->cam[index][4] = dp8393x_get(s, width, 3) & 0xff;\n        s->cam[index][5] = dp8393x_get(s, width, 3) >> 8;\n        DPRINTF(\"load cam[%d] with %02x%02x%02x%02x%02x%02x\\n\", index,\n            s->cam[index][0], s->cam[index][1], s->cam[index][2],\n            s->cam[index][3], s->cam[index][4], s->cam[index][5]);\n        s->regs[SONIC_CDC]--;\n        s->regs[SONIC_CDP] += size;\n        index++;\n    }\n    address_space_read(&s->as, dp8393x_cdp(s),\n                       MEMTXATTRS_UNSPECIFIED, s->data, size);\n    s->regs[SONIC_CE] = dp8393x_get(s, width, 0);\n    DPRINTF(\"load cam done. cam enable mask 0x%04x\\n\", s->regs[SONIC_CE]);\n    s->regs[SONIC_CR] &= ~SONIC_CR_LCAM;\n    s->regs[SONIC_ISR] |= SONIC_ISR_LCD;\n    dp8393x_update_irq(s);\n}", "target": 0}
{"code": "void rose_link_failed(ax25_cb *ax25, int reason)\n{\n\tstruct rose_neigh *rose_neigh;\n\tspin_lock_bh(&rose_neigh_list_lock);\n\trose_neigh = rose_neigh_list;\n\twhile (rose_neigh != NULL) {\n\t\tif (rose_neigh->ax25 == ax25)\n\t\t\tbreak;\n\t\trose_neigh = rose_neigh->next;\n\t}\n\tif (rose_neigh != NULL) {\n\t\trose_neigh->ax25 = NULL;\n\t\tax25_cb_put(ax25);\n\t\trose_del_route_by_neigh(rose_neigh);\n\t\trose_kill_by_neigh(rose_neigh);\n\t}\n\tspin_unlock_bh(&rose_neigh_list_lock);\n}", "target": 0}
{"code": "static char* umocktypes_stringify_FLOW_HANDLE(const FLOW_HANDLE* value)\n{\n    char temp_buffer[32];\n    char* result;\n    size_t length = sprintf(temp_buffer, \"%p\", (void*)*value);\n    if (length < 0)\n    {\n        result = NULL;\n    }\n    else\n    {\n        result = (char*)malloc(length + 1);\n        if (result != NULL)\n        {\n            (void)memcpy(result, temp_buffer, length + 1);\n        }\n    }\n    return result;\n}", "target": 0}
{"code": "static inline bool cpu_has_vmx_invept_context(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_EXTENT_CONTEXT_BIT;\n}", "target": 0}
{"code": "void kvm_arch_mmu_notifier_invalidate_page(struct kvm *kvm,\n\t\t\t\t\t   unsigned long address)\n{\n\tif (address == gfn_to_hva(kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT))\n\t\tkvm_make_all_cpus_request(kvm, KVM_REQ_APIC_PAGE_RELOAD);\n}", "target": 0}
{"code": "static void exif_process_APP12(image_info_type *ImageInfo,\n                               char *buffer, size_t length) {\n  size_t l1, l2=0;\n  if ((l1 = php_strnlen(buffer+2, length-2)) > 0) {\n    exif_iif_add_tag(ImageInfo, SECTION_APP12, \"Company\",\n                     TAG_NONE, TAG_FMT_STRING, l1, buffer+2);\n    if (length > 2+l1+1) {\n      l2 = php_strnlen(buffer+2+l1+1, length-2-l1+1);\n      exif_iif_add_tag(ImageInfo, SECTION_APP12, \"Info\",\n                       TAG_NONE, TAG_FMT_STRING, l2, buffer+2+l1+1);\n    }\n  }\n}", "target": 1}
{"code": "batchCopyElem(batch_obj_t *pDest, batch_obj_t *pSrc) {\n\tmemcpy(pDest, pSrc, sizeof(batch_obj_t));\n}", "target": 1}
{"code": "static void emulator_get_fpu(struct x86_emulate_ctxt *ctxt)\n{\n\tpreempt_disable();\n\tkvm_load_guest_fpu(emul_to_vcpu(ctxt));\n\tclts();\n}", "target": 0}
{"code": "String *Item_decimal::val_str(String *result)\n{\n  result->set_charset(&my_charset_numeric);\n  my_decimal2string(E_DEC_FATAL_ERROR, &decimal_value, 0, 0, 0, result);\n  return result;\n}", "target": 0}
{"code": "static int oidc_cache_crypto_decrypt_impl(request_rec *r,\n\t\tunsigned char *ciphertext, int ciphertext_len, const unsigned char *aad,\n\t\tint aad_len, const unsigned char *tag, int tag_len, unsigned char *key,\n\t\tconst unsigned char *iv, int iv_len, unsigned char *plaintext) {\n\tEVP_CIPHER_CTX *ctx;\n\tint len;\n\tint plaintext_len;\n\tint ret;\n\tif (!(ctx = EVP_CIPHER_CTX_new())) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_CIPHER_CTX_new\");\n\t\treturn -1;\n\t}\n\tif (!EVP_DecryptInit_ex(ctx, OIDC_CACHE_CIPHER, NULL, NULL, NULL)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_DecryptInit_ex\");\n\t\treturn -1;\n\t}\n\tif (!EVP_CIPHER_CTX_ctrl(ctx, OIDC_CACHE_CRYPTO_SET_IVLEN, iv_len, NULL)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_CIPHER_CTX_ctrl\");\n\t\treturn -1;\n\t}\n\tif (!EVP_DecryptInit_ex(ctx, NULL, NULL, key, iv)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_DecryptInit_ex\");\n\t\treturn -1;\n\t}\n\tif (!EVP_DecryptUpdate(ctx, NULL, &len, aad, aad_len)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_DecryptUpdate aad: aad_len=%d\",\n\t\t\t\taad_len);\n\t\treturn -1;\n\t}\n\tif (!EVP_DecryptUpdate(ctx, plaintext, &len, ciphertext, ciphertext_len)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_DecryptUpdate ciphertext\");\n\t\treturn -1;\n\t}\n\tplaintext_len = len;\n\tif (!EVP_CIPHER_CTX_ctrl(ctx, OIDC_CACHE_CRYPTO_SET_TAG, tag_len,\n\t\t\t(void *) tag)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_CIPHER_CTX_ctrl\");\n\t\treturn -1;\n\t}\n\tret = EVP_DecryptFinal_ex(ctx, plaintext + len, &len);\n\tEVP_CIPHER_CTX_free(ctx);\n\tif (ret > 0) {\n\t\tplaintext_len += len;\n\t\treturn plaintext_len;\n\t} else {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_DecryptFinal_ex\");\n\t\treturn -1;\n\t}\n}", "target": 1}
{"code": "static void do_bad_area(unsigned long addr, unsigned int esr, struct pt_regs *regs)\n{\n\tstruct task_struct *tsk = current;\n\tstruct mm_struct *mm = tsk->active_mm;\n\tif (user_mode(regs))\n\t\t__do_user_fault(tsk, addr, esr, SIGSEGV, SEGV_MAPERR, regs);\n\telse\n\t\t__do_kernel_fault(mm, addr, esr, regs);\n}", "target": 0}
{"code": "TfLiteTensor* GetTemporary(TfLiteContext* context, const TfLiteNode* node,\n                           int index) {\n  const int tensor_index = ValidateTensorIndexing(\n      context, index, node->temporaries->size, node->temporaries->data);\n  if (tensor_index < 0) {\n    return nullptr;\n  }\n  return GetTensorAtIndex(context, tensor_index);\n}", "target": 0}
{"code": "void builtinFetchurl(const BasicDerivation & drv)\n{\n    auto url = drv.env.find(\"url\");\n    if (url == drv.env.end()) throw Error(\"attribute url missing\");\n    printMsg(lvlInfo, format(\"downloading %1%...\") % url->second);\n    auto data = downloadFile(url->second); \n    auto out = drv.env.find(\"out\");\n    if (out == drv.env.end()) throw Error(\"attribute url missing\");\n    writeFile(out->second, data.data);\n    auto executable = drv.env.find(\"executable\");\n    if (executable != drv.env.end() && executable->second == \"1\") {\n        if (chmod(out->second.c_str(), 0755) == -1)\n            throw SysError(format(\"making %1% executable\") % out->second);\n    }\n}", "target": 1}
{"code": "escape_character (gunichar c)\n{\n  g_autoptr(GString) res = g_string_new (\"\");\n  append_hex_escaped_character (res, c);\n  return g_string_free (g_steal_pointer (&res), FALSE);\n}", "target": 0}
{"code": "key_set(const char *key) {\n    int\t\tlen = (int)strlen(key);\n    int64_t\th = calc_hash(key, &len);\n    Slot\t*bucket = get_bucketp(h);\n    Slot\ts;\n    if (NULL != (s = (Slot)AGOO_MALLOC(sizeof(struct _slot)))) {\n\ts->hash = h;\n\ts->klen = len;\n\ts->key = key;\n\ts->next = *bucket;\n\t*bucket = s;\n    }\n}", "target": 1}
{"code": "static QString mountPoint(const RemoteFsDevice::Details &details, bool create)\n{\n    if (details.isLocalFile()) {\n        return details.url.path();\n    }\n    return Utils::cacheDir(QLatin1String(\"mount/\")+details.name, create);\n}", "target": 0}
{"code": "w3m_exit(int i)\n{\n#ifdef USE_MIGEMO\n    init_migemo();\t\t\n#endif\n    stopDownload();\n    deleteFiles();\n#ifdef USE_SSL\n    free_ssl_ctx();\n#endif\n    disconnectFTP();\n#ifdef USE_NNTP\n    disconnectNews();\n#endif\n#ifdef __MINGW32_VERSION\n    WSACleanup();\n#endif\n#ifdef HAVE_MKDTEMP\n    if (no_rc_dir && tmp_dir != rc_dir)\n\tif (rmdir(tmp_dir) != 0) {\n\t    fprintf(stderr, \"Can't remove temporary directory (%s)!\\n\", tmp_dir);\n\t    exit(1);\n\t}\n#endif\n    exit(i);\n}", "target": 0}
{"code": "void jas_deprecated(const char *s)\n{\n\tstatic char message[] =\n\t\"WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!!\\n\"\n\t\"WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!!\\n\"\n\t\"WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!! WARNING!!!\\n\"\n\t\"YOUR CODE IS RELYING ON DEPRECATED FUNCTIONALTIY IN THE JASPER LIBRARY.\\n\"\n\t\"THIS FUNCTIONALITY WILL BE REMOVED IN THE NEAR FUTURE.\\n\"\n\t\"PLEASE FIX THIS PROBLEM BEFORE YOUR CODE STOPS WORKING!\\n\"\n\t;\n\tjas_eprintf(\"%s\", message);\n\tjas_eprintf(\"The specific problem is as follows:\\n%s\\n\", s);\n}", "target": 0}
{"code": "BGD_DECLARE(gdImagePtr) gdImageCreate (int sx, int sy)\n{\n\tint i;\n\tgdImagePtr im;\n\tif (overflow2(sx, sy)) {\n\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof (unsigned char *), sy)) {\n\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof (unsigned char), sx)) {\n\t\treturn NULL;\n\t}\n\tim = (gdImage *) gdCalloc(1, sizeof(gdImage));\n\tif (!im) {\n\t\treturn NULL;\n\t}\n\tim->pixels = (unsigned char **) gdMalloc (sizeof (unsigned char *) * sy);\n\tif (!im->pixels) {\n\t\tgdFree(im);\n\t\treturn NULL;\n\t}\n\tim->polyInts = 0;\n\tim->polyAllocated = 0;\n\tim->brush = 0;\n\tim->tile = 0;\n\tim->style = 0;\n\tfor (i = 0; (i < sy); i++) {\n\t\tim->pixels[i] = (unsigned char *) gdCalloc (sx, sizeof (unsigned char));\n\t\tif (!im->pixels[i]) {\n\t\t\tfor (--i ; i >= 0; i--) {\n\t\t\t\tgdFree(im->pixels[i]);\n\t\t\t}\n\t\t\tgdFree(im->pixels);\n\t\t\tgdFree(im);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tim->sx = sx;\n\tim->sy = sy;\n\tim->colorsTotal = 0;\n\tim->transparent = (-1);\n\tim->interlace = 0;\n\tim->thick = 1;\n\tim->AA = 0;\n\tfor (i = 0; (i < gdMaxColors); i++) {\n\t\tim->open[i] = 1;\n\t};\n\tim->trueColor = 0;\n\tim->tpixels = 0;\n\tim->cx1 = 0;\n\tim->cy1 = 0;\n\tim->cx2 = im->sx - 1;\n\tim->cy2 = im->sy - 1;\n\tim->res_x = GD_RESOLUTION;\n\tim->res_y = GD_RESOLUTION;\n\tim->interpolation = NULL;\n\tim->interpolation_id = GD_BILINEAR_FIXED;\n\treturn im;\n}", "target": 0}
{"code": "static int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct trusted_key_payload *p;\n\tstruct trusted_key_payload *new_p;\n\tstruct trusted_key_options *new_o;\n\tsize_t datalen = prep->datalen;\n\tchar *datablob;\n\tint ret = 0;\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n\t\treturn -ENOKEY;\n\tp = key->payload.data[0];\n\tif (!p->migratable)\n\t\treturn -EPERM;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tnew_o = trusted_options_alloc();\n\tif (!new_o) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tnew_p = trusted_payload_alloc(key);\n\tif (!new_p) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmemcpy(datablob, prep->data, datalen);\n\tdatablob[datalen] = '\\0';\n\tret = datablob_parse(datablob, new_p, new_o);\n\tif (ret != Opt_update) {\n\t\tret = -EINVAL;\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\tif (!new_o->keyhandle) {\n\t\tret = -EINVAL;\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\tnew_p->migratable = p->migratable;\n\tnew_p->key_len = p->key_len;\n\tmemcpy(new_p->key, p->key, p->key_len);\n\tdump_payload(p);\n\tdump_payload(new_p);\n\tret = key_seal(new_p, new_o);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: key_seal failed (%d)\\n\", ret);\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\tif (new_o->pcrlock) {\n\t\tret = pcrlock(new_o->pcrlock);\n\t\tif (ret < 0) {\n\t\t\tpr_info(\"trusted_key: pcrlock failed (%d)\\n\", ret);\n\t\t\tkzfree(new_p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\trcu_assign_keypointer(key, new_p);\n\tcall_rcu(&p->rcu, trusted_rcu_free);\nout:\n\tkzfree(datablob);\n\tkzfree(new_o);\n\treturn ret;\n}", "target": 1}
{"code": "static OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *\n        p_code_block)\n{\n    OPJ_UINT32 l_data_size;\n    l_data_size = 2 + (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) *\n                                   (p_code_block->y1 - p_code_block->y0) * (OPJ_INT32)sizeof(OPJ_UINT32));\n    if (l_data_size > p_code_block->data_size) {\n        if (p_code_block->data) {\n            opj_free(p_code_block->data - 1);\n        }\n        p_code_block->data = (OPJ_BYTE*) opj_malloc(l_data_size + 1);\n        if (! p_code_block->data) {\n            p_code_block->data_size = 0U;\n            return OPJ_FALSE;\n        }\n        p_code_block->data_size = l_data_size;\n        p_code_block->data[0] = 0;\n        p_code_block->data += 1; \n    }\n    return OPJ_TRUE;\n}", "target": 0}
{"code": "  void operator()(OpKernelContext* ctx, const Index num_segments,\n                  const TensorShape& segment_ids_shape,\n                  typename TTypes<Index>::ConstFlat segment_ids,\n                  const Index data_size, const T* data,\n                  typename TTypes<T, 2>::Tensor output) {\n    if (output.size() == 0) {\n      return;\n    }\n    GPUDevice d = ctx->template eigen_device<GPUDevice>();\n    GpuLaunchConfig config = GetGpuLaunchConfig(output.size(), d);\n    TF_CHECK_OK(GpuLaunchKernel(\n        SetToValue<T>, config.block_count, config.thread_per_block, 0,\n        d.stream(), output.size(), output.data(), InitialValueF()()));\n    if (data_size == 0 || segment_ids_shape.num_elements() == 0) {\n      return;\n    }\n    const Index input_outer_dim_size = segment_ids.dimension(0);\n    const Index input_inner_dim_size = data_size / input_outer_dim_size;\n    config = GetGpuLaunchConfig(data_size, d);\n    TF_CHECK_OK(\n        GpuLaunchKernel(UnsortedSegmentCustomKernel<T, Index, ReductionF>,\n                        config.block_count, config.thread_per_block, 0,\n                        d.stream(), input_outer_dim_size, input_inner_dim_size,\n                        num_segments, segment_ids.data(), data, output.data()));\n  }", "target": 1}
{"code": "cp949_mbc_to_code(const UChar* p, const UChar* end, OnigEncoding enc)\n{\n  return onigenc_mbn_mbc_to_code(enc, p, end);\n}", "target": 0}
{"code": "int snd_ctl_create(struct snd_card *card)\n{\n\tstatic struct snd_device_ops ops = {\n\t\t.dev_free = snd_ctl_dev_free,\n\t\t.dev_register =\tsnd_ctl_dev_register,\n\t\t.dev_disconnect = snd_ctl_dev_disconnect,\n\t};\n\tif (snd_BUG_ON(!card))\n\t\treturn -ENXIO;\n\treturn snd_device_new(card, SNDRV_DEV_CONTROL, card, &ops);\n}", "target": 0}
{"code": "atmarp_spaddr_print(netdissect_options *ndo,\n\t\t    const struct atmarp_pkthdr *ap, u_short pro)\n{\n\tif (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)\n\t\tND_PRINT((ndo, \"<wrong proto type>\"));\n\telse if (ATMSPROTO_LEN(ap) != 4)\n\t\tND_PRINT((ndo, \"<wrong splen>\"));\n\telse\n\t\tND_PRINT((ndo, \"%s\", ipaddr_string(ndo, ATMSPA(ap))));\n}", "target": 0}
{"code": "static bool vtable_is_addr_vtable_start_msvc(RVTableContext *context, ut64 curAddress) {\n\tRAnalRef *xref;\n\tRListIter *xrefIter;\n\tif (!curAddress || curAddress == UT64_MAX) {\n\t\treturn false;\n\t}\n\tif (curAddress && !vtable_is_value_in_text_section (context, curAddress, NULL)) {\n\t\treturn false;\n\t}\n\tRList *xrefs = r_anal_xrefs_get (context->anal, curAddress);\n\tif (r_list_empty (xrefs)) {\n\t\tr_list_free (xrefs);\n\t\treturn false;\n\t}\n\tr_list_foreach (xrefs, xrefIter, xref) {\n\t\tif (vtable_addr_in_text_section (context, xref->addr)) {\n\t\t\tut8 buf[VTABLE_BUFF_SIZE];\n\t\t\tcontext->anal->iob.read_at (context->anal->iob.io, xref->addr, buf, sizeof(buf));\n\t\t\tRAnalOp analop = {0};\n\t\t\tr_anal_op (context->anal, &analop, xref->addr, buf, sizeof(buf), R_ANAL_OP_MASK_BASIC);\n\t\t\tif (analop.type == R_ANAL_OP_TYPE_MOV\n\t\t\t\t|| analop.type == R_ANAL_OP_TYPE_LEA) {\n\t\t\t\tr_list_free (xrefs);\n\t\t\t\tr_anal_op_fini (&analop);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tr_anal_op_fini (&analop);\n\t\t}\n\t}\n\tr_list_free (xrefs);\n\treturn false;\n}", "target": 1}
{"code": "vm_fault_t gru_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct gru_thread_state *gts;\n\tunsigned long paddr, vaddr;\n\tunsigned long expires;\n\tvaddr = vmf->address;\n\tgru_dbg(grudev, \"vma %p, vaddr 0x%lx (0x%lx)\\n\",\n\t\tvma, vaddr, GSEG_BASE(vaddr));\n\tSTAT(nopfn);\n\tgts = gru_find_thread_state(vma, TSID(vaddr, vma));\n\tif (!gts)\n\t\treturn VM_FAULT_SIGBUS;\nagain:\n\tmutex_lock(&gts->ts_ctxlock);\n\tpreempt_disable();\n\tgru_check_context_placement(gts);\n\tif (!gts->ts_gru) {\n\t\tSTAT(load_user_context);\n\t\tif (!gru_assign_gru_context(gts)) {\n\t\t\tpreempt_enable();\n\t\t\tmutex_unlock(&gts->ts_ctxlock);\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tschedule_timeout(GRU_ASSIGN_DELAY);  \n\t\t\texpires = gts->ts_steal_jiffies + GRU_STEAL_DELAY;\n\t\t\tif (time_before(expires, jiffies))\n\t\t\t\tgru_steal_context(gts);\n\t\t\tgoto again;\n\t\t}\n\t\tgru_load_context(gts);\n\t\tpaddr = gseg_physical_address(gts->ts_gru, gts->ts_ctxnum);\n\t\tremap_pfn_range(vma, vaddr & ~(GRU_GSEG_PAGESIZE - 1),\n\t\t\t\tpaddr >> PAGE_SHIFT, GRU_GSEG_PAGESIZE,\n\t\t\t\tvma->vm_page_prot);\n\t}\n\tpreempt_enable();\n\tmutex_unlock(&gts->ts_ctxlock);\n\treturn VM_FAULT_NOPAGE;\n}", "target": 1}
{"code": "int iscsi_decode_text_input(\n\tu8 phase,\n\tu8 sender,\n\tchar *textbuf,\n\tu32 length,\n\tstruct iscsi_conn *conn)\n{\n\tstruct iscsi_param_list *param_list = conn->param_list;\n\tchar *tmpbuf, *start = NULL, *end = NULL;\n\ttmpbuf = kzalloc(length + 1, GFP_KERNEL);\n\tif (!tmpbuf) {\n\t\tpr_err(\"Unable to allocate memory for tmpbuf.\\n\");\n\t\treturn -1;\n\t}\n\tmemcpy(tmpbuf, textbuf, length);\n\ttmpbuf[length] = '\\0';\n\tstart = tmpbuf;\n\tend = (start + length);\n\twhile (start < end) {\n\t\tchar *key, *value;\n\t\tstruct iscsi_param *param;\n\t\tif (iscsi_extract_key_value(start, &key, &value) < 0) {\n\t\t\tkfree(tmpbuf);\n\t\t\treturn -1;\n\t\t}\n\t\tpr_debug(\"Got key: %s=%s\\n\", key, value);\n\t\tif (phase & PHASE_SECURITY) {\n\t\t\tif (iscsi_check_for_auth_key(key) > 0) {\n\t\t\t\tchar *tmpptr = key + strlen(key);\n\t\t\t\t*tmpptr = '=';\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tparam = iscsi_check_key(key, phase, sender, param_list);\n\t\tif (!param) {\n\t\t\tif (iscsi_add_notunderstood_response(key,\n\t\t\t\t\tvalue, param_list) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tstart += strlen(key) + strlen(value) + 2;\n\t\t\tcontinue;\n\t\t}\n\t\tif (iscsi_check_value(param, value) < 0) {\n\t\t\tkfree(tmpbuf);\n\t\t\treturn -1;\n\t\t}\n\t\tstart += strlen(key) + strlen(value) + 2;\n\t\tif (IS_PSTATE_PROPOSER(param)) {\n\t\t\tif (iscsi_check_proposer_state(param, value) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tSET_PSTATE_RESPONSE_GOT(param);\n\t\t} else {\n\t\t\tif (iscsi_check_acceptor_state(param, value, conn) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tSET_PSTATE_ACCEPTOR(param);\n\t\t}\n\t}\n\tkfree(tmpbuf);\n\treturn 0;\n}", "target": 1}
{"code": "void ImplPolygon::ImplSplit( sal_uInt16 nPos, sal_uInt16 nSpace, ImplPolygon const * pInitPoly )\n{\n    if (mnPoints + nSpace > USHRT_MAX)\n        return;\n    const sal_uInt16    nNewSize = mnPoints + nSpace;\n    const std::size_t   nSpaceSize = static_cast<std::size_t>(nSpace) * sizeof(Point);\n    if( nPos >= mnPoints )\n    {\n        nPos = mnPoints;\n        ImplSetSize( nNewSize );\n        if( pInitPoly )\n        {\n            memcpy( mpPointAry + nPos, pInitPoly->mpPointAry, nSpaceSize );\n            if( pInitPoly->mpFlagAry )\n                memcpy( mpFlagAry + nPos, pInitPoly->mpFlagAry, nSpace );\n        }\n    }\n    else\n    {\n        const sal_uInt16    nSecPos = nPos + nSpace;\n        const sal_uInt16    nRest = mnPoints - nPos;\n        Point* pNewAry = reinterpret_cast<Point*>(new char[ static_cast<std::size_t>(nNewSize) * sizeof(Point) ]);\n        memcpy( pNewAry, mpPointAry, nPos * sizeof( Point ) );\n        if( pInitPoly )\n            memcpy( pNewAry + nPos, pInitPoly->mpPointAry, nSpaceSize );\n        else\n            memset( pNewAry + nPos, 0, nSpaceSize );\n        memcpy( pNewAry + nSecPos, mpPointAry + nPos, nRest * sizeof( Point ) );\n        delete[] reinterpret_cast<char*>(mpPointAry);\n        if( mpFlagAry )\n        {\n            PolyFlags* pNewFlagAry = new PolyFlags[ nNewSize ];\n            memcpy( pNewFlagAry, mpFlagAry, nPos );\n            if( pInitPoly && pInitPoly->mpFlagAry )\n                memcpy( pNewFlagAry + nPos, pInitPoly->mpFlagAry, nSpace );\n            else\n                memset( pNewFlagAry + nPos, 0, nSpace );\n            memcpy( pNewFlagAry + nSecPos, mpFlagAry + nPos, nRest );\n            delete[] mpFlagAry;\n            mpFlagAry = pNewFlagAry;\n        }\n        mpPointAry = pNewAry;\n        mnPoints   = nNewSize;\n    }\n}", "target": 1}
{"code": "void hincrbyfloatCommand(client *c) {\n    long double value, incr;\n    long long ll;\n    robj *o;\n    sds new;\n    unsigned char *vstr;\n    unsigned int vlen;\n    if (getLongDoubleFromObjectOrReply(c,c->argv[3],&incr,NULL) != C_OK) return;\n    if (isnan(incr) || isinf(incr)) {\n        addReplyError(c,\"value is NaN or Infinity\");\n        return;\n    }\n    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n    if (hashTypeGetValue(o,c->argv[2]->ptr,&vstr,&vlen,&ll) == C_OK) {\n        if (vstr) {\n            if (string2ld((char*)vstr,vlen,&value) == 0) {\n                addReplyError(c,\"hash value is not a float\");\n                return;\n            }\n        } else {\n            value = (long double)ll;\n        }\n    } else {\n        value = 0;\n    }\n    value += incr;\n    if (isnan(value) || isinf(value)) {\n        addReplyError(c,\"increment would produce NaN or Infinity\");\n        return;\n    }\n    char buf[MAX_LONG_DOUBLE_CHARS];\n    int len = ld2string(buf,sizeof(buf),value,LD_STR_HUMAN);\n    new = sdsnewlen(buf,len);\n    hashTypeSet(o,c->argv[2]->ptr,new,HASH_SET_TAKE_VALUE);\n    addReplyBulkCBuffer(c,buf,len);\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_HASH,\"hincrbyfloat\",c->argv[1],c->db->id);\n    server.dirty++;\n    robj *newobj;\n    newobj = createRawStringObject(buf,len);\n    rewriteClientCommandArgument(c,0,shared.hset);\n    rewriteClientCommandArgument(c,3,newobj);\n    decrRefCount(newobj);\n}", "target": 0}
{"code": "  Status CalculateOutputIndex(OpKernelContext* context, int dimension,\n                              const vector<INDEX_TYPE>& parent_output_index,\n                              INDEX_TYPE output_index_multiplier,\n                              INDEX_TYPE output_size,\n                              vector<INDEX_TYPE>* result) {\n    const RowPartitionTensor row_partition_tensor =\n        GetRowPartitionTensor(context, dimension);\n    auto partition_type = GetRowPartitionTypeByDimension(dimension);\n    switch (partition_type) {\n      case RowPartitionType::VALUE_ROWIDS:\n        CalculateOutputIndexValueRowID(\n            context, row_partition_tensor, parent_output_index,\n            output_index_multiplier, output_size, result);\n        return tensorflow::Status::OK();\n      case RowPartitionType::ROW_SPLITS:\n        if (row_partition_tensor.size() - 1 > parent_output_index.size()) {\n          return errors::InvalidArgument(\n              \"Row partition size is greater than output size: \",\n              row_partition_tensor.size() - 1, \" > \",\n              parent_output_index.size());\n        }\n        CalculateOutputIndexRowSplit(\n            context, row_partition_tensor, parent_output_index,\n            output_index_multiplier, output_size, result);\n        return tensorflow::Status::OK();\n      default:\n        return errors::InvalidArgument(\n            \"Unsupported partition type:\",\n            RowPartitionTypeToString(partition_type));\n    }\n  }", "target": 0}
{"code": "  virtual bool ethernet_available() const { return true; }", "target": 0}
{"code": "static s32 adpt_send_nop(adpt_hba*pHba,u32 m)\n{\n\tu32 __iomem *msg;\n\tulong timeout = jiffies + 5*HZ;\n\twhile(m == EMPTY_QUEUE){\n\t\trmb();\n\t\tm = readl(pHba->post_port);\n\t\tif(m != EMPTY_QUEUE){\n\t\t\tbreak;\n\t\t}\n\t\tif(time_after(jiffies,timeout)){\n\t\t\tprintk(KERN_ERR \"%s: Timeout waiting for message frame!\\n\",pHba->name);\n\t\t\treturn 2;\n\t\t}\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n\tmsg = (u32 __iomem *)(pHba->msg_addr_virt + m);\n\twritel( THREE_WORD_MSG_SIZE | SGL_OFFSET_0,&msg[0]);\n\twritel( I2O_CMD_UTIL_NOP << 24 | HOST_TID << 12 | 0,&msg[1]);\n\twritel( 0,&msg[2]);\n\twmb();\n\twritel(m, pHba->post_port);\n\twmb();\n\treturn 0;\n}", "target": 1}
{"code": "PHPAPI int php_lint_script(zend_file_handle *file)\n{\n\tzend_op_array *op_array;\n\tint retval = FAILURE;\n\tzend_try {\n\t\top_array = zend_compile_file(file, ZEND_INCLUDE);\n\t\tzend_destroy_file_handle(file);\n\t\tif (op_array) {\n\t\t\tdestroy_op_array(op_array);\n\t\t\tefree(op_array);\n\t\t\tretval = SUCCESS;\n\t\t}\n\t} zend_end_try();\n\tif (EG(exception)) {\n\t\tzend_exception_error(EG(exception), E_ERROR);\n\t}\n\treturn retval;\n}", "target": 0}
{"code": "static struct nfs4_opendata *nfs4_opendata_alloc(struct path *path,\n\t\tstruct nfs4_state_owner *sp, int flags,\n\t\tconst struct iattr *attrs)\n{\n\tstruct dentry *parent = dget_parent(path->dentry);\n\tstruct inode *dir = parent->d_inode;\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs4_opendata *p;\n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (p == NULL)\n\t\tgoto err;\n\tp->o_arg.seqid = nfs_alloc_seqid(&sp->so_seqid);\n\tif (p->o_arg.seqid == NULL)\n\t\tgoto err_free;\n\tp->path.mnt = mntget(path->mnt);\n\tp->path.dentry = dget(path->dentry);\n\tp->dir = parent;\n\tp->owner = sp;\n\tatomic_inc(&sp->so_count);\n\tp->o_arg.fh = NFS_FH(dir);\n\tp->o_arg.open_flags = flags,\n\tp->o_arg.clientid = server->nfs_client->cl_clientid;\n\tp->o_arg.id = sp->so_owner_id.id;\n\tp->o_arg.name = &p->path.dentry->d_name;\n\tp->o_arg.server = server;\n\tp->o_arg.bitmask = server->attr_bitmask;\n\tp->o_arg.claim = NFS4_OPEN_CLAIM_NULL;\n\tif (flags & O_EXCL) {\n\t\tu32 *s = (u32 *) p->o_arg.u.verifier.data;\n\t\ts[0] = jiffies;\n\t\ts[1] = current->pid;\n\t} else if (flags & O_CREAT) {\n\t\tp->o_arg.u.attrs = &p->attrs;\n\t\tmemcpy(&p->attrs, attrs, sizeof(p->attrs));\n\t}\n\tp->c_arg.fh = &p->o_res.fh;\n\tp->c_arg.stateid = &p->o_res.stateid;\n\tp->c_arg.seqid = p->o_arg.seqid;\n\tnfs4_init_opendata_res(p);\n\tkref_init(&p->kref);\n\treturn p;\nerr_free:\n\tkfree(p);\nerr:\n\tdput(parent);\n\treturn NULL;\n}", "target": 1}
{"code": "smb3_free_compound_rqst(int num_rqst, struct smb_rqst *rqst)\n{\n\tint i, j;\n\tfor (i = 0; i < num_rqst; i++) {\n\t\tif (rqst[i].rq_pages) {\n\t\t\tfor (j = rqst[i].rq_npages - 1; j >= 0; j--)\n\t\t\t\tput_page(rqst[i].rq_pages[j]);\n\t\t\tkfree(rqst[i].rq_pages);\n\t\t}\n\t}\n}", "target": 0}
{"code": "repodata_schema2id(Repodata *data, Id *schema, int create)\n{\n  int h, len, i;\n  Id *sp, cid;\n  Id *schematahash;\n  if (!*schema)\n    return 0;\t\n  if ((schematahash = data->schematahash) == 0)\n    {\n      data->schematahash = schematahash = solv_calloc(256, sizeof(Id));\n      for (i = 1; i < data->nschemata; i++)\n\t{\n\t  for (sp = data->schemadata + data->schemata[i], h = 0; *sp;)\n\t    h = h * 7 + *sp++;\n\t  h &= 255;\n\t  schematahash[h] = i;\n\t}\n      data->schemadata = solv_extend_resize(data->schemadata, data->schemadatalen, sizeof(Id), SCHEMATADATA_BLOCK);\n      data->schemata = solv_extend_resize(data->schemata, data->nschemata, sizeof(Id), SCHEMATA_BLOCK);\n    }\n  for (sp = schema, len = 0, h = 0; *sp; len++)\n    h = h * 7 + *sp++;\n  h &= 255;\n  len++;\n  cid = schematahash[h];\n  if (cid)\n    {\n      if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n        return cid;\n      for (cid = 1; cid < data->nschemata; cid++)\n        if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n          return cid;\n    }\n  if (!create)\n    return 0;\n  data->schemadata = solv_extend(data->schemadata, data->schemadatalen, len, sizeof(Id), SCHEMATADATA_BLOCK);\n  data->schemata = solv_extend(data->schemata, data->nschemata, 1, sizeof(Id), SCHEMATA_BLOCK);\n  memcpy(data->schemadata + data->schemadatalen, schema, len * sizeof(Id));\n  data->schemata[data->nschemata] = data->schemadatalen;\n  data->schemadatalen += len;\n  schematahash[h] = data->nschemata;\n#if 0\nfprintf(stderr, \"schema2id: new schema\\n\");\n#endif\n  return data->nschemata++;\n}", "target": 1}
{"code": "static pyc_object *get_array_object_generic(RBuffer *buffer, ut32 size) {\n\tpyc_object *tmp = NULL;\n\tpyc_object *ret = NULL;\n\tut32 i = 0;\n\tret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->data = r_list_newf ((RListFree)free_object);\n\tif (!ret->data) {\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < size; i++) {\n\t\ttmp = get_object (buffer);\n\t\tif (!tmp) {\n\t\t\tr_list_free (ret->data);\n\t\t\tR_FREE (ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!r_list_append (ret->data, tmp)) {\n\t\t\tfree_object (tmp);\n\t\t\tr_list_free (ret->data);\n\t\t\tfree (ret);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static void mark_all_scalars_precise(struct bpf_verifier_env *env,\n\t\t\t\t     struct bpf_verifier_state *st)\n{\n\tstruct bpf_func_state *func;\n\tstruct bpf_reg_state *reg;\n\tint i, j;\n\tfor (; st; st = st->parent)\n\t\tfor (i = 0; i <= st->curframe; i++) {\n\t\t\tfunc = st->frame[i];\n\t\t\tfor (j = 0; j < BPF_REG_FP; j++) {\n\t\t\t\treg = &func->regs[j];\n\t\t\t\tif (reg->type != SCALAR_VALUE)\n\t\t\t\t\tcontinue;\n\t\t\t\treg->precise = true;\n\t\t\t}\n\t\t\tfor (j = 0; j < func->allocated_stack / BPF_REG_SIZE; j++) {\n\t\t\t\tif (!is_spilled_reg(&func->stack[j]))\n\t\t\t\t\tcontinue;\n\t\t\t\treg = &func->stack[j].spilled_ptr;\n\t\t\t\tif (reg->type != SCALAR_VALUE)\n\t\t\t\t\tcontinue;\n\t\t\t\treg->precise = true;\n\t\t\t}\n\t\t}\n}", "target": 0}
{"code": "  void TearDown() override {\n    peparse::DestructParsedPE(pe);\n  }", "target": 0}
{"code": "BOOL freerdp_bitmap_planar_context_reset(BITMAP_PLANAR_CONTEXT* context, UINT32 width,\n                                         UINT32 height)\n{\n\tif (!context)\n\t\treturn FALSE;\n\tcontext->bgr = FALSE;\n\tcontext->maxWidth = PLANAR_ALIGN(width, 4);\n\tcontext->maxHeight = PLANAR_ALIGN(height, 4);\n\tcontext->maxPlaneSize = context->maxWidth * context->maxHeight;\n\tcontext->nTempStep = context->maxWidth * 4;\n\tfree(context->planesBuffer);\n\tfree(context->pTempData);\n\tfree(context->deltaPlanesBuffer);\n\tfree(context->rlePlanesBuffer);\n\tcontext->planesBuffer = calloc(context->maxPlaneSize, 4);\n\tcontext->pTempData = calloc(context->maxPlaneSize, 6);\n\tcontext->deltaPlanesBuffer = calloc(context->maxPlaneSize, 4);\n\tcontext->rlePlanesBuffer = calloc(context->maxPlaneSize, 4);\n\tif (!context->planesBuffer || !context->pTempData || !context->deltaPlanesBuffer ||\n\t    !context->rlePlanesBuffer)\n\t\treturn FALSE;\n\tcontext->planes[0] = &context->planesBuffer[context->maxPlaneSize * 0];\n\tcontext->planes[1] = &context->planesBuffer[context->maxPlaneSize * 1];\n\tcontext->planes[2] = &context->planesBuffer[context->maxPlaneSize * 2];\n\tcontext->planes[3] = &context->planesBuffer[context->maxPlaneSize * 3];\n\tcontext->deltaPlanes[0] = &context->deltaPlanesBuffer[context->maxPlaneSize * 0];\n\tcontext->deltaPlanes[1] = &context->deltaPlanesBuffer[context->maxPlaneSize * 1];\n\tcontext->deltaPlanes[2] = &context->deltaPlanesBuffer[context->maxPlaneSize * 2];\n\tcontext->deltaPlanes[3] = &context->deltaPlanesBuffer[context->maxPlaneSize * 3];\n\treturn TRUE;\n}", "target": 1}
{"code": "static int netlink_dump(struct sock *sk)\n{\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tstruct netlink_callback *cb;\n\tstruct sk_buff *skb = NULL;\n\tstruct nlmsghdr *nlh;\n\tint len, err = -ENOBUFS;\n\tint alloc_min_size;\n\tint alloc_size;\n\tmutex_lock(nlk->cb_mutex);\n\tif (!nlk->cb_running) {\n\t\terr = -EINVAL;\n\t\tgoto errout_skb;\n\t}\n\tif (atomic_read(&sk->sk_rmem_alloc) >= sk->sk_rcvbuf)\n\t\tgoto errout_skb;\n\tcb = &nlk->cb;\n\talloc_min_size = max_t(int, cb->min_dump_alloc, NLMSG_GOODSIZE);\n\tif (alloc_min_size < nlk->max_recvmsg_len) {\n\t\talloc_size = nlk->max_recvmsg_len;\n\t\tskb = alloc_skb(alloc_size, GFP_KERNEL |\n\t\t\t\t\t    __GFP_NOWARN | __GFP_NORETRY);\n\t}\n\tif (!skb) {\n\t\talloc_size = alloc_min_size;\n\t\tskb = alloc_skb(alloc_size, GFP_KERNEL);\n\t}\n\tif (!skb)\n\t\tgoto errout_skb;\n\tskb_reserve(skb, skb_tailroom(skb) - alloc_size);\n\tnetlink_skb_set_owner_r(skb, sk);\n\tlen = cb->dump(skb, cb);\n\tif (len > 0) {\n\t\tmutex_unlock(nlk->cb_mutex);\n\t\tif (sk_filter(sk, skb))\n\t\t\tkfree_skb(skb);\n\t\telse\n\t\t\t__netlink_sendskb(sk, skb);\n\t\treturn 0;\n\t}\n\tnlh = nlmsg_put_answer(skb, cb, NLMSG_DONE, sizeof(len), NLM_F_MULTI);\n\tif (!nlh)\n\t\tgoto errout_skb;\n\tnl_dump_check_consistent(cb, nlh);\n\tmemcpy(nlmsg_data(nlh), &len, sizeof(len));\n\tif (sk_filter(sk, skb))\n\t\tkfree_skb(skb);\n\telse\n\t\t__netlink_sendskb(sk, skb);\n\tif (cb->done)\n\t\tcb->done(cb);\n\tnlk->cb_running = false;\n\tmutex_unlock(nlk->cb_mutex);\n\tmodule_put(cb->module);\n\tconsume_skb(cb->skb);\n\treturn 0;\nerrout_skb:\n\tmutex_unlock(nlk->cb_mutex);\n\tkfree_skb(skb);\n\treturn err;\n}", "target": 1}
{"code": "int pam_modutil_drop_priv(pam_handle_t *pamh, struct _ykpam_privs *privs, struct passwd *pw) {\n    privs->saved_euid = geteuid();\n    privs->saved_egid = getegid();\n    if ((privs->saved_euid == pw->pw_uid) && (privs->saved_egid == pw->pw_gid)) {\n        D (privs->debug_file, \"Privilges already dropped, pretend it is all right\");\n        return 0;\n    }\n    privs->saved_groups_length = getgroups(0, NULL);\n    if (privs->saved_groups_length < 0) {\n        D (privs->debug_file, \"getgroups: %s\", strerror(errno));\n        return -1;\n    }\n    if (privs->saved_groups_length > SAVED_GROUPS_MAX_LEN) {\n        D (privs->debug_file, \"too many groups, limiting.\");\n        privs->saved_groups_length = SAVED_GROUPS_MAX_LEN;\n    }\n    if (privs->saved_groups_length > 0) {\n        if (getgroups(privs->saved_groups_length, privs->saved_groups) < 0) {\n            D (privs->debug_file, \"getgroups: %s\", strerror(errno));\n            goto free_out;\n        }\n    }\n    if (initgroups(pw->pw_name, pw->pw_gid) < 0) {\n        D (privs->debug_file, \"initgroups: %s\", strerror(errno));\n        goto free_out;\n    }\n    if (setegid(pw->pw_gid) < 0) {\n        D (privs->debug_file, \"setegid: %s\", strerror(errno));\n        goto free_out;\n    }\n    if (seteuid(pw->pw_uid) < 0) {\n        D (privs->debug_file, \"seteuid: %s\", strerror(errno));\n        goto free_out;\n    }\n    return 0;\nfree_out:\n    return -1;\n}", "target": 0}
{"code": "status_t Parcel::setDataSize(size_t size)\n{\n if (size > INT32_MAX) {\n return BAD_VALUE;\n }\n status_t err;\n    err = continueWrite(size);\n if (err == NO_ERROR) {\n        mDataSize = size;\n        ALOGV(\"setDataSize Setting data size of %p to %zu\", this, mDataSize);\n }\n return err;\n}", "target": 0}
{"code": "static int m88rs2000_frontend_attach(struct dvb_usb_adapter *d)\n{\n\tu8 obuf[] = { 0x51 };\n\tu8 ibuf[] = { 0 };\n\tif (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x51 transfer failed.\");\n\td->fe_adap[0].fe = dvb_attach(m88rs2000_attach, &s421_m88rs2000_config,\n\t\t\t\t\t&d->dev->i2c_adap);\n\tif (d->fe_adap[0].fe == NULL)\n\t\treturn -EIO;\n\tif (dvb_attach(ts2020_attach, d->fe_adap[0].fe,\n\t\t\t\t&dw2104_ts2020_config,\n\t\t\t\t&d->dev->i2c_adap)) {\n\t\tinfo(\"Attached RS2000/TS2020!\");\n\t\treturn 0;\n\t}\n\tinfo(\"Failed to attach RS2000/TS2020!\");\n\treturn -EIO;\n}", "target": 1}
{"code": "fp_read(CBORDecoderObject *self, char *buf, const Py_ssize_t size)\n{\n    PyObject *obj, *size_obj;\n    char *data;\n    int ret = -1;\n    size_obj = PyLong_FromSsize_t(size);\n    if (size_obj) {\n        obj = PyObject_CallFunctionObjArgs(self->read, size_obj, NULL);\n        if (obj) {\n            assert(PyBytes_CheckExact(obj));\n            if (PyBytes_GET_SIZE(obj) == (Py_ssize_t) size) {\n                data = PyBytes_AS_STRING(obj);\n                memcpy(buf, data, size);\n                ret = 0;\n            } else {\n                PyErr_Format(\n                    _CBOR2_CBORDecodeEOF,\n                    \"premature end of stream (expected to read %zd bytes, \"\n                    \"got %zd instead)\", size, PyBytes_GET_SIZE(obj));\n            }\n            Py_DECREF(obj);\n        }\n        Py_DECREF(size_obj);\n    }\n    return ret;\n}", "target": 1}
{"code": "static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt)\n{\n\tstruct epitem *epi = ep_item_from_epqueue(pt);\n\tstruct eppoll_entry *pwq;\n\tif (epi->nwait >= 0 && (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) {\n\t\tinit_waitqueue_func_entry(&pwq->wait, ep_poll_callback);\n\t\tpwq->whead = whead;\n\t\tpwq->base = epi;\n\t\tadd_wait_queue(whead, &pwq->wait);\n\t\tlist_add_tail(&pwq->llink, &epi->pwqlist);\n\t\tepi->nwait++;\n\t} else {\n\t\tepi->nwait = -1;\n\t}\n}", "target": 0}
{"code": "_TIFFmalloc(tmsize_t s)\n{\n        if (s == 0)\n                return ((void *) NULL);\n\treturn (malloc((size_t) s));\n}", "target": 0}
{"code": "void ntlm_populate_message_header(NTLM_MESSAGE_HEADER* header, UINT32 MessageType)\n{\n\tCopyMemory(header->Signature, NTLM_SIGNATURE, sizeof(NTLM_SIGNATURE));\n\theader->MessageType = MessageType;\n}", "target": 1}
{"code": "static void gf_dump_vrml_simple_field(GF_SceneDumper *sdump, GF_FieldInfo field, GF_Node *parent)\n{\n\tu32 i, sf_type;\n\tGF_ChildNodeItem *list;\n\tvoid *slot_ptr;\n\tswitch (field.fieldType) {\n\tcase GF_SG_VRML_SFNODE:\n\t\tgf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);\n\t\treturn;\n\tcase GF_SG_VRML_MFNODE:\n\t\tlist = * ((GF_ChildNodeItem **) field.far_ptr);\n\t\tassert( list );\n\t\tsdump->indent++;\n\t\twhile (list) {\n\t\t\tgf_dump_vrml_node(sdump, list->node, 1, NULL);\n\t\t\tlist = list->next;\n\t\t}\n\t\tsdump->indent--;\n\t\treturn;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t\treturn;\n\t}\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\tif (sdump->XMLDump) StartAttribute(sdump, \"value\");\n\t\tgf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, parent);\n\t\tif (sdump->XMLDump) EndAttribute(sdump);\n\t} else {\n\t\tGenMFField *mffield;\n\t\tmffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"[\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \" value=\\'\");\n\t\t} else {\n\t\t\tStartAttribute(sdump, \"value\");\n\t\t}\n\t\tfor (i=0; mffield && (i<mffield->count); i++) {\n\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, parent);\n\t\t}\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"]\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \"\\'\");\n\t\t} else {\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t}\n}", "target": 0}
{"code": "static int __copy_insn(struct address_space *mapping, struct file *filp,\n\t\t\tvoid *insn, int nbytes, loff_t offset)\n{\n\tstruct page *page;\n\tif (mapping->a_ops->readpage)\n\t\tpage = read_mapping_page(mapping, offset >> PAGE_SHIFT, filp);\n\telse\n\t\tpage = shmem_read_mapping_page(mapping, offset >> PAGE_SHIFT);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\tcopy_from_page(page, offset, insn, nbytes);\n\tput_page(page);\n\treturn 0;\n}", "target": 0}
{"code": "int DynamicMetadataMapIterator::luaPairsIterator(lua_State* state) {\n  if (current_ == parent_.streamInfo().dynamicMetadata().filter_metadata().end()) {\n    parent_.iterator_.reset();\n    return 0;\n  }\n  lua_pushstring(state, current_->first.c_str());\n  Filters::Common::Lua::MetadataMapHelper::createTable(state, current_->second.fields());\n  current_++;\n  return 2;\n}", "target": 0}
{"code": "compat_mpt_command(struct file *filp, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct mpt_ioctl_command32 karg32;\n\tstruct mpt_ioctl_command32 __user *uarg = (struct mpt_ioctl_command32 __user *) arg;\n\tstruct mpt_ioctl_command karg;\n\tMPT_ADAPTER *iocp = NULL;\n\tint iocnum, iocnumX;\n\tint nonblock = (filp->f_flags & O_NONBLOCK);\n\tint ret;\n\tif (copy_from_user(&karg32, (char __user *)arg, sizeof(karg32)))\n\t\treturn -EFAULT;\n\tiocnumX = karg32.hdr.iocnum & 0xFF;\n\tif (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||\n\t    (iocp == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"::compat_mpt_command @%d - ioc%d not found!\\n\",\n\t\t\t__LINE__, iocnumX);\n\t\treturn -ENODEV;\n\t}\n\tif ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)\n\t\treturn ret;\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT \"compat_mpt_command() called\\n\",\n\t    iocp->name));\n\tkarg.hdr.iocnum = karg32.hdr.iocnum;\n\tkarg.hdr.port = karg32.hdr.port;\n\tkarg.timeout = karg32.timeout;\n\tkarg.maxReplyBytes = karg32.maxReplyBytes;\n\tkarg.dataInSize = karg32.dataInSize;\n\tkarg.dataOutSize = karg32.dataOutSize;\n\tkarg.maxSenseBytes = karg32.maxSenseBytes;\n\tkarg.dataSgeOffset = karg32.dataSgeOffset;\n\tkarg.replyFrameBufPtr = (char __user *)(unsigned long)karg32.replyFrameBufPtr;\n\tkarg.dataInBufPtr = (char __user *)(unsigned long)karg32.dataInBufPtr;\n\tkarg.dataOutBufPtr = (char __user *)(unsigned long)karg32.dataOutBufPtr;\n\tkarg.senseDataPtr = (char __user *)(unsigned long)karg32.senseDataPtr;\n\tret = mptctl_do_mpt_command (karg, &uarg->MF);\n\tmutex_unlock(&iocp->ioctl_cmds.mutex);\n\treturn ret;\n}", "target": 1}
{"code": "static void show_object(struct object *obj,\n\t\t\tstruct strbuf *path, const char *last,\n\t\t\tvoid *data)\n{\n\tchar *name = path_name(path, last);\n\tadd_preferred_base_object(name);\n\tadd_object_entry(obj->oid.hash, obj->type, name, 0);\n\tobj->flags |= OBJECT_ADDED;\n\tfree((char *)name);\n}", "target": 1}
{"code": "bgp_capability_mp (struct peer *peer, struct capability *cap)\n{\n  if (ntohs (cap->mpc.afi) == AFI_IP)\n    {\n      if (cap->mpc.safi == SAFI_UNICAST)\n\t{\n\t  peer->afc_recv[AFI_IP][SAFI_UNICAST] = 1;\n\t  if (peer->afc[AFI_IP][SAFI_UNICAST])\n\t    peer->afc_nego[AFI_IP][SAFI_UNICAST] = 1;\n\t  else\n\t    return -1;\n\t}\n      else if (cap->mpc.safi == SAFI_MULTICAST) \n\t{\n\t  peer->afc_recv[AFI_IP][SAFI_MULTICAST] = 1;\n\t  if (peer->afc[AFI_IP][SAFI_MULTICAST])\n\t    peer->afc_nego[AFI_IP][SAFI_MULTICAST] = 1;\n\t  else\n\t    return -1;\n\t}\n      else if (cap->mpc.safi == BGP_SAFI_VPNV4)\n\t{\n\t  peer->afc_recv[AFI_IP][SAFI_MPLS_VPN] = 1;\n\t  if (peer->afc[AFI_IP][SAFI_MPLS_VPN])\n\t    peer->afc_nego[AFI_IP][SAFI_MPLS_VPN] = 1;\n\t  else\n\t    return -1;\n\t}\n      else\n\treturn -1;\n    }\n#ifdef HAVE_IPV6\n  else if (ntohs (cap->mpc.afi) == AFI_IP6)\n    {\n      if (cap->mpc.safi == SAFI_UNICAST)\n\t{\n\t  peer->afc_recv[AFI_IP6][SAFI_UNICAST] = 1;\n\t  if (peer->afc[AFI_IP6][SAFI_UNICAST])\n\t    peer->afc_nego[AFI_IP6][SAFI_UNICAST] = 1;\n\t  else\n\t    return -1;\n\t}\n      else if (cap->mpc.safi == SAFI_MULTICAST)\n\t{\n\t  peer->afc_recv[AFI_IP6][SAFI_MULTICAST] = 1;\n\t  if (peer->afc[AFI_IP6][SAFI_MULTICAST])\n\t    peer->afc_nego[AFI_IP6][SAFI_MULTICAST] = 1;\n\t  else\n\t    return -1;\n\t}\n      else\n\treturn -1;\n    }\n#endif \n  else\n    {\n      return -1;\n    }\n  return 0;\n}", "target": 1}
{"code": "static int mem_resize(jas_stream_memobj_t *m, int bufsize)\n{\n\tunsigned char *buf;\n\tassert(m->buf_);\n\tassert(bufsize >= 0);\n\tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char)))) {\n\t\treturn -1;\n\t}\n\tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}", "target": 1}
{"code": "gopherSendRequest(int, void *data)\n{\n    GopherStateData *gopherState = (GopherStateData *)data;\n    MemBuf mb;\n    mb.init();\n    if (gopherState->type_id == GOPHER_CSO) {\n        const char *t = strchr(gopherState->request, '?');\n        if (t)\n            ++t;        \n        else\n            t = \"\";\n        mb.appendf(\"query %s\\r\\nquit\", t);\n    } else {\n        if (gopherState->type_id == GOPHER_INDEX) {\n            if (char *t = strchr(gopherState->request, '?'))\n                *t = '\\t';\n        }\n        mb.append(gopherState->request, strlen(gopherState->request));\n    }\n    mb.append(\"\\r\\n\", 2);\n    debugs(10, 5, gopherState->serverConn);\n    AsyncCall::Pointer call = commCbCall(5,5, \"gopherSendComplete\",\n                                         CommIoCbPtrFun(gopherSendComplete, gopherState));\n    Comm::Write(gopherState->serverConn, &mb, call);\n    if (!gopherState->entry->makePublic())\n        gopherState->entry->makePrivate(true);\n}", "target": 1}
{"code": "    ExprMatchTest() : _expCtx(new ExpressionContextForTest()) {}", "target": 0}
{"code": "void hashtable_clear(hashtable_t *hashtable)\n{\n    size_t i;\n    hashtable_do_clear(hashtable);\n    for(i = 0; i < num_buckets(hashtable); i++)\n    {\n        hashtable->buckets[i].first = hashtable->buckets[i].last =\n            &hashtable->list;\n    }\n    list_init(&hashtable->list);\n    hashtable->size = 0;\n}", "target": 1}
{"code": "static void dns_resolver_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key)) {\n\t\tint err = PTR_ERR(key->payload.data[dns_key_error]);\n\t\tif (err)\n\t\t\tseq_printf(m, \": %d\", err);\n\t\telse\n\t\t\tseq_printf(m, \": %u\", key->datalen);\n\t}\n}", "target": 1}
{"code": "static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,\n\t\t\t\t   size_t count, loff_t *offset)\n{\n\tstruct snd_timer_user *tu;\n\tlong result = 0, unit;\n\tint qhead;\n\tint err = 0;\n\ttu = file->private_data;\n\tunit = tu->tread ? sizeof(struct snd_timer_tread) : sizeof(struct snd_timer_read);\n\tspin_lock_irq(&tu->qlock);\n\twhile ((long)count - result >= unit) {\n\t\twhile (!tu->qused) {\n\t\t\twait_queue_t wait;\n\t\t\tif ((file->f_flags & O_NONBLOCK) != 0 || result > 0) {\n\t\t\t\terr = -EAGAIN;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tinit_waitqueue_entry(&wait, current);\n\t\t\tadd_wait_queue(&tu->qchange_sleep, &wait);\n\t\t\tspin_unlock_irq(&tu->qlock);\n\t\t\tschedule();\n\t\t\tspin_lock_irq(&tu->qlock);\n\t\t\tremove_wait_queue(&tu->qchange_sleep, &wait);\n\t\t\tif (tu->disconnected) {\n\t\t\t\terr = -ENODEV;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t\tif (signal_pending(current)) {\n\t\t\t\terr = -ERESTARTSYS;\n\t\t\t\tgoto _error;\n\t\t\t}\n\t\t}\n\t\tqhead = tu->qhead++;\n\t\ttu->qhead %= tu->queue_size;\n\t\ttu->qused--;\n\t\tspin_unlock_irq(&tu->qlock);\n\t\tmutex_lock(&tu->ioctl_lock);\n\t\tif (tu->tread) {\n\t\t\tif (copy_to_user(buffer, &tu->tqueue[qhead],\n\t\t\t\t\t sizeof(struct snd_timer_tread)))\n\t\t\t\terr = -EFAULT;\n\t\t} else {\n\t\t\tif (copy_to_user(buffer, &tu->queue[qhead],\n\t\t\t\t\t sizeof(struct snd_timer_read)))\n\t\t\t\terr = -EFAULT;\n\t\t}\n\t\tmutex_unlock(&tu->ioctl_lock);\n\t\tspin_lock_irq(&tu->qlock);\n\t\tif (err < 0)\n\t\t\tgoto _error;\n\t\tresult += unit;\n\t\tbuffer += unit;\n\t}\n _error:\n\tspin_unlock_irq(&tu->qlock);\n\treturn result > 0 ? result : err;\n}", "target": 1}
{"code": "static int set_evtchn_to_irq(evtchn_port_t evtchn, unsigned int irq)\n{\n\tunsigned row;\n\tunsigned col;\n\tif (evtchn >= xen_evtchn_max_channels())\n\t\treturn -EINVAL;\n\trow = EVTCHN_ROW(evtchn);\n\tcol = EVTCHN_COL(evtchn);\n\tif (evtchn_to_irq[row] == NULL) {\n\t\tif (irq == -1)\n\t\t\treturn 0;\n\t\tevtchn_to_irq[row] = (int *)get_zeroed_page(GFP_KERNEL);\n\t\tif (evtchn_to_irq[row] == NULL)\n\t\t\treturn -ENOMEM;\n\t\tclear_evtchn_to_irq_row(row);\n\t}\n\tevtchn_to_irq[row][col] = irq;\n\treturn 0;\n}", "target": 1}
{"code": "cfm_network_addr_print(netdissect_options *ndo,\n                       register const u_char *tptr)\n{\n    u_int network_addr_type;\n    u_int hexdump =  FALSE;\n    network_addr_type = *tptr;\n    ND_PRINT((ndo, \"\\n\\t  Network Address Type %s (%u)\",\n           tok2str(af_values, \"Unknown\", network_addr_type),\n           network_addr_type));\n    switch(network_addr_type) {\n    case AFNUM_INET:\n        ND_PRINT((ndo, \", %s\", ipaddr_string(ndo, tptr + 1)));\n        break;\n    case AFNUM_INET6:\n        ND_PRINT((ndo, \", %s\", ip6addr_string(ndo, tptr + 1)));\n        break;\n    default:\n        hexdump = TRUE;\n        break;\n    }\n    return hexdump;\n}", "target": 1}
{"code": "koi8_u_mbc_case_fold(OnigCaseFoldType flag ARG_UNUSED,\n\t\t     const UChar** pp, const UChar* end ARG_UNUSED,\n\t\t     UChar* lower, OnigEncoding enc ARG_UNUSED)\n{\n  const UChar* p = *pp;\n  *lower = ENC_KOI8_U_TO_LOWER_CASE(*p);\n  (*pp)++;\n  return 1;\n}", "target": 0}
{"code": "off_t FileModule::tell()\n{\n\treturn m_fh->tell();\n}", "target": 0}
{"code": "void init_tls_dissector(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\tu_int32_t *id, NDPI_PROTOCOL_BITMASK *detection_bitmask) {\n  ndpi_set_bitmask_protocol_detection(\"TLS\", ndpi_struct, detection_bitmask, *id,\n\t\t\t\t      NDPI_PROTOCOL_TLS,\n\t\t\t\t      ndpi_search_tls_wrapper,\n\t\t\t\t      NDPI_SELECTION_BITMASK_PROTOCOL_V4_V6_TCP_WITH_PAYLOAD_WITHOUT_RETRANSMISSION,\n\t\t\t\t      SAVE_DETECTION_BITMASK_AS_UNKNOWN,\n\t\t\t\t      ADD_TO_DETECTION_BITMASK);\n  *id += 1;\n  ndpi_set_bitmask_protocol_detection(\"TLS\", ndpi_struct, detection_bitmask, *id,\n\t\t\t\t      NDPI_PROTOCOL_TLS,\n\t\t\t\t      ndpi_search_tls_wrapper,\n\t\t\t\t      NDPI_SELECTION_BITMASK_PROTOCOL_V4_V6_UDP_WITH_PAYLOAD,\n\t\t\t\t      SAVE_DETECTION_BITMASK_AS_UNKNOWN,\n\t\t\t\t      ADD_TO_DETECTION_BITMASK);\n  *id += 1;\n}", "target": 0}
{"code": "public char * shell_quoten(constant char *s, size_t slen)\n{\n\tconstant char *p;\n\tchar *np;\n\tchar *newstr;\n\tsize_t len;\n\tconstant char *esc = get_meta_escape();\n\tsize_t esclen = strlen(esc);\n\tlbool use_quotes = FALSE;\n\tlbool have_quotes = FALSE;\n\tlen = 1; \n\tfor (p = s;  p < s + slen;  p++)\n\t{\n\t\tlen++;\n\t\tif (*p == openquote || *p == closequote)\n\t\t\thave_quotes = TRUE;\n\t\tif (metachar(*p))\n\t\t{\n\t\t\tif (esclen == 0)\n\t\t\t{\n\t\t\t\tuse_quotes = TRUE;\n\t\t\t} else\n\t\t\t{\n\t\t\t\tlen += esclen;\n\t\t\t}\n\t\t}\n\t}\n\tif (use_quotes)\n\t{\n\t\tif (have_quotes)\n\t\t\treturn (NULL);\n\t\tlen = slen + 3;\n\t}\n\tnewstr = np = (char *) ecalloc(len, sizeof(char));\n\tif (use_quotes)\n\t{\n\t\tSNPRINTF4(newstr, len, \"%c%.*s%c\", openquote, (int) slen, s, closequote);\n\t} else\n\t{\n\t\tconstant char *es = s + slen;\n\t\twhile (s < es)\n\t\t{\n\t\t\tif (metachar(*s))\n\t\t\t{\n\t\t\t\tstrcpy(np, esc);\n\t\t\t\tnp += esclen;\n\t\t\t}\n\t\t\t*np++ = *s++;\n\t\t}\n\t\t*np = '\\0';\n\t}\n\treturn (newstr);\n}", "target": 1}
{"code": "INST_HANDLER (cpse) {\t\n\tint r = (buf[0] & 0xf) | ((buf[1] & 0x2) << 3);\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tRAnalOp next_op;\n\tavr_op_analyze (anal,\n\t\t\t&next_op,\n\t\t\top->addr + op->size, buf + op->size, len - op->size,\n\t\t\tcpu);\n\tr_strbuf_fini (&next_op.esil);\n\top->jump = op->addr + next_op.size + 2;\n\top->cycles = 1;\t\n\tESIL_A (\"r%d,r%d,^,!,\", r, d);\t\t\t\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t\n}", "target": 1}
{"code": "static INLINE BOOL update_read_brush(wStream* s, rdpBrush* brush, BYTE fieldFlags)\n{\n\tif (fieldFlags & ORDER_FIELD_01)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, brush->x);\n\t}\n\tif (fieldFlags & ORDER_FIELD_02)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, brush->y);\n\t}\n\tif (fieldFlags & ORDER_FIELD_03)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, brush->style);\n\t}\n\tif (fieldFlags & ORDER_FIELD_04)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t\treturn FALSE;\n\t\tStream_Read_UINT8(s, brush->hatch);\n\t}\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tbrush->index = brush->hatch;\n\t\tbrush->bpp = BMF_BPP[brush->style & 0x07];\n\t\tif (brush->bpp == 0)\n\t\t\tbrush->bpp = 1;\n\t}\n\tif (fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 7)\n\t\t\treturn FALSE;\n\t\tbrush->data = (BYTE*)brush->p8x8;\n\t\tStream_Read_UINT8(s, brush->data[7]);\n\t\tStream_Read_UINT8(s, brush->data[6]);\n\t\tStream_Read_UINT8(s, brush->data[5]);\n\t\tStream_Read_UINT8(s, brush->data[4]);\n\t\tStream_Read_UINT8(s, brush->data[3]);\n\t\tStream_Read_UINT8(s, brush->data[2]);\n\t\tStream_Read_UINT8(s, brush->data[1]);\n\t\tbrush->data[0] = brush->hatch;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "    FIO_NAME(_find_map_pos_)(FIO_NAME(s) * set, FIO_SET_HASH_TYPE hash_value,\n                             FIO_SET_TYPE obj) {\n  if (FIO_SET_HASH_COMPARE(hash_value, FIO_SET_HASH_INVALID))\n    hash_value = FIO_SET_HASH_FORCE;\n  if (set->map) {\n    if (set->has_collisions && set->pos != set->count) {\n      FIO_NAME(rehash)(set);\n    }\n    size_t full_collisions_counter = 0;\n    FIO_NAME(_map_s_) * pos;\n    const uintptr_t mask = (1ULL << set->used_bits) - 1;\n    uintptr_t i;\n    const uintptr_t hash_value_i = FIO_SET_HASH2UINTPTR(hash_value, 0);\n    uintptr_t hash_alt = FIO_SET_HASH2UINTPTR(hash_value, set->used_bits);\n    pos = set->map + (hash_alt & mask);\n    if (FIO_SET_HASH_COMPARE(FIO_SET_HASH_INVALID, pos->hash))\n      return pos;\n    if (FIO_SET_HASH_COMPARE(pos->hash, hash_value_i)) {\n      if (!pos->pos || FIO_SET_COMPARE(pos->pos->obj, obj))\n        return pos;\n      set->has_collisions = 1;\n      ++full_collisions_counter;\n    }\n    i = 0;\n    const uintptr_t limit =\n        FIO_SET_CUCKOO_STEPS * (set->capa > (FIO_SET_MAX_MAP_SEEK << 2)\n                                    ? FIO_SET_MAX_MAP_SEEK\n                                    : (set->capa >> 2));\n    while (i < limit) {\n      i += FIO_SET_CUCKOO_STEPS;\n      pos = set->map + ((hash_alt + i) & mask);\n      if (FIO_SET_HASH_COMPARE(FIO_SET_HASH_INVALID, pos->hash))\n        return pos;\n      if (FIO_SET_HASH_COMPARE(pos->hash, hash_value_i)) {\n        if (!pos->pos || FIO_SET_COMPARE(pos->pos->obj, obj))\n          return pos;\n        set->has_collisions = 1;\n        if (++full_collisions_counter >= FIO_SET_MAX_MAP_FULL_COLLISIONS) {\n          FIO_LOG_WARNING(\n              \"(fio hash map) too many full collisions - under attack?\");\n          set->under_attack = 1;\n        }\n        if (set->under_attack) {\n          return pos;\n        }\n      }\n    }\n  }\n  return NULL;\n  (void)obj; \n}", "target": 1}
{"code": "uint32_t sftp_parse_handle(struct sftpjob *job, struct handleid *id) {\n  uint32_t len, rc;\n  if((rc = sftp_parse_uint32(job, &len)) != SSH_FX_OK || len != 8 ||\n     (rc = sftp_parse_uint32(job, &id->id)) != SSH_FX_OK ||\n     (rc = sftp_parse_uint32(job, &id->tag) != SSH_FX_OK))\n    return rc;\n  return SSH_FX_OK;\n}", "target": 1}
{"code": "bool dir_is_in_dump_location(const char *dir_name)\n{\n    unsigned len = strlen(g_settings_dump_location);\n    if (strncmp(dir_name, g_settings_dump_location, len) != 0)\n    {\n        log_debug(\"Bad parent directory: '%s' not in '%s'\", g_settings_dump_location, dir_name);\n        return false;\n    }\n    const char *base_name = dir_name + len;\n    while (*base_name && *base_name == '/')\n        ++base_name;\n    if (*(base_name - 1) != '/' || !str_is_correct_filename(base_name))\n    {\n        log_debug(\"Invalid dump directory name: '%s'\", base_name);\n        return false;\n    }\n    struct stat sb;\n    if (lstat(dir_name, &sb) < 0)\n    {\n        VERB2 perror_msg(\"stat('%s')\", dir_name);\n        return errno== ENOENT;\n    }\n    return S_ISDIR(sb.st_mode);\n}", "target": 0}
{"code": "pci_set_cfgdata8(struct pci_vdev *dev, int offset, uint8_t val)\n{\n\tassert(offset <= PCI_REGMAX);\n\t*(uint8_t *)(dev->cfgdata + offset) = val;\n}", "target": 1}
{"code": "pci_emul_add_msicap(struct pci_vdev *dev, int msgnum)\n{\n\tstruct msicap msicap;\n\tpci_populate_msicap(&msicap, msgnum, 0);\n\treturn pci_emul_add_capability(dev, (u_char *)&msicap, sizeof(msicap));\n}", "target": 1}
{"code": "static int __init dev_prepare_static_identity_mapping(struct device *dev, int hw)\n{\n\tint ret;\n\tif (!iommu_should_identity_map(dev, 1))\n\t\treturn 0;\n\tret = domain_add_dev_info(si_domain, dev);\n\tif (!ret)\n\t\tdev_info(dev, \"%s identity mapping\\n\",\n\t\t\t hw ? \"Hardware\" : \"Software\");\n\telse if (ret == -ENODEV)\n\t\tret = 0;\n\treturn ret;\n}", "target": 0}
{"code": "void groupGenerate(const std::string &rule, std::vector<Proxy> &nodelist, string_array &filtered_nodelist, bool add_direct, extra_settings &ext)\n{\n    std::string real_rule;\n    if(startsWith(rule, \"[]\") && add_direct)\n    {\n        filtered_nodelist.emplace_back(rule.substr(2));\n    }\n#ifndef NO_JS_RUNTIME\n    else if(startsWith(rule, \"script:\"))\n    {\n        script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx){\n            std::string script = fileGet(rule.substr(7), true);\n            try\n            {\n                ctx.eval(script);\n                auto filter = (std::function<std::string(const std::vector<Proxy>&)>) ctx.eval(\"filter\");\n                std::string result_list = filter(nodelist);\n                filtered_nodelist = split(regTrim(result_list), \"\\n\");\n            }\n            catch (qjs::exception)\n            {\n                script_print_stack(ctx);\n            }\n        }, global.scriptCleanContext);\n    }\n#endif \n    else\n    {\n        for(Proxy &x : nodelist)\n        {\n            if(applyMatcher(rule, real_rule, x) && (real_rule.empty() || regFind(x.Remark, real_rule)) && std::find(filtered_nodelist.begin(), filtered_nodelist.end(), x.Remark) == filtered_nodelist.end())\n                filtered_nodelist.emplace_back(x.Remark);\n        }\n    }\n}", "target": 1}
{"code": "static void credential_write_item(FILE *fp, const char *key, const char *value)\n{\n\tif (!value)\n\t\treturn;\n\tif (strchr(value, '\\n'))\n\t\tdie(\"credential value for %s contains newline\", key);\n\tfprintf(fp, \"%s=%s\\n\", key, value);\n}", "target": 0}
{"code": "static int af9005_identify_state(struct usb_device *udev,\n\t\t\t\t struct dvb_usb_device_properties *props,\n\t\t\t\t struct dvb_usb_device_description **desc,\n\t\t\t\t int *cold)\n{\n\tint ret;\n\tu8 reply, *buf;\n\tbuf = kmalloc(FW_BULKOUT_SIZE + 2, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tret = af9005_boot_packet(udev, FW_CONFIG, &reply,\n\t\t\t\t buf, FW_BULKOUT_SIZE + 2);\n\tif (ret)\n\t\tgoto err;\n\tdeb_info(\"result of FW_CONFIG in identify state %d\\n\", reply);\n\tif (reply == 0x01)\n\t\t*cold = 1;\n\telse if (reply == 0x02)\n\t\t*cold = 0;\n\telse\n\t\treturn -EIO;\n\tdeb_info(\"Identify state cold = %d\\n\", *cold);\nerr:\n\tkfree(buf);\n\treturn ret;\n}", "target": 1}
{"code": "void HTMLMediaElement::UpdatePlaybackRate() {\n  if (web_media_player_ && PotentiallyPlaying())\n    GetWebMediaPlayer()->SetRate(playbackRate());\n}", "target": 0}
{"code": "parserep(netdissect_options *ndo,\n         register const struct sunrpc_msg *rp, register u_int length)\n{\n\tregister const uint32_t *dp;\n\tu_int len;\n\tenum sunrpc_accept_stat astat;\n\tdp = ((const uint32_t *)&rp->rm_reply) + 1;\n\tND_TCHECK(dp[1]);\n\tlen = EXTRACT_32BITS(&dp[1]);\n\tif (len >= length)\n\t\treturn (NULL);\n\tdp += (len + (2*sizeof(uint32_t) + 3)) / sizeof(uint32_t);\n\tND_TCHECK2(dp[0], 0);\n\tastat = (enum sunrpc_accept_stat) EXTRACT_32BITS(dp);\n\tif (astat != SUNRPC_SUCCESS) {\n\t\tND_PRINT((ndo, \" %s\", tok2str(sunrpc_str, \"ar_stat %d\", astat)));\n\t\tnfserr = 1;\t\t\n\t\treturn (NULL);\n\t}\n\tND_TCHECK2(*dp, sizeof(astat));\n\treturn ((const uint32_t *) (sizeof(astat) + ((const char *)dp)));\ntrunc:\n\treturn (0);\n}", "target": 1}
{"code": "snmp_process_data(void)\n{\n  static unsigned char packet[SNMP_MAX_PACKET_SIZE];\n  unsigned char *packet_end;\n  static uint32_t packet_len;\n  packet_end = packet + sizeof(packet) - 1;\n  packet_len = 0;\n  LOG_DBG(\"receiving UDP datagram from [\");\n  LOG_DBG_6ADDR(&UIP_IP_BUF->srcipaddr);\n  LOG_DBG_(\"]:%u\", uip_ntohs(UIP_UDP_BUF->srcport));\n  LOG_DBG_(\" Length: %u\\n\", uip_datalen());\n  if((packet_end = snmp_engine(uip_appdata, uip_datalen(), packet_end, &packet_len)) == NULL) {\n    LOG_DBG(\"Error while handling the request\\n\");\n  } else {\n    LOG_DBG(\"Sending response\\n\");\n    uip_udp_packet_sendto(snmp_udp_conn, packet_end, packet_len, &UIP_IP_BUF->srcipaddr, UIP_UDP_BUF->srcport);\n  }\n}", "target": 1}
{"code": "pci_emul_add_msixcap(struct pci_vdev *dev, int msgnum, int barnum)\n{\n\tuint32_t tab_size;\n\tstruct msixcap msixcap;\n\tassert(msgnum >= 1 && msgnum <= MAX_MSIX_TABLE_ENTRIES);\n\tassert(barnum >= 0 && barnum <= PCIR_MAX_BAR_0);\n\ttab_size = msgnum * MSIX_TABLE_ENTRY_SIZE;\n\ttab_size = roundup2(tab_size, 4096);\n\tdev->msix.table_bar = barnum;\n\tdev->msix.pba_bar   = barnum;\n\tdev->msix.table_offset = 0;\n\tdev->msix.table_count = msgnum;\n\tdev->msix.pba_offset = tab_size;\n\tdev->msix.pba_size = PBA_SIZE(msgnum);\n\tpci_msix_table_init(dev, msgnum);\n\tpci_populate_msixcap(&msixcap, msgnum, barnum, tab_size);\n\tpci_emul_alloc_bar(dev, barnum, PCIBAR_MEM32,\n\t\t\t\ttab_size + dev->msix.pba_size);\n\treturn (pci_emul_add_capability(dev, (u_char *)&msixcap,\n\t\t\t\t\tsizeof(msixcap)));\n}", "target": 1}
{"code": "void initialize_CABAC_models(thread_context* tctx)\n{\n  const int QPY = tctx->shdr->SliceQPY;\n  const int initType = tctx->shdr->initType;\n  assert(initType >= 0 && initType <= 2);\n  tctx->ctx_model.init(initType, QPY);\n  for (int i=0;i<4;i++) {\n    tctx->StatCoeff[i] = 0;\n  }\n}", "target": 0}
{"code": "int IMA::decodeBlockQT(const uint8_t *encoded, int16_t *decoded)\n{\n\tint channelCount = m_track->f.channelCount;\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\tadpcmState state;\n\t\tint predictor = (encoded[0] << 8) | (encoded[1] & 0x80);\n\t\tif (predictor & 0x8000)\n\t\t\tpredictor -= 0x10000;\n\t\tstate.previousValue = clamp(predictor, MIN_INT16, MAX_INT16);\n\t\tstate.index = encoded[1] & 0x7f;\n\t\tencoded += 2;\n\t\tfor (int n=0; n<m_framesPerPacket; n+=2)\n\t\t{\n\t\t\tuint8_t e = *encoded;\n\t\t\tdecoded[n*channelCount + c] = decodeSample(state, e & 0xf);\n\t\t\tdecoded[(n+1)*channelCount + c] = decodeSample(state, e >> 4);\n\t\t\tencoded++;\n\t\t}\n\t}\n\treturn m_framesPerPacket * channelCount * sizeof (int16_t);\n}", "target": 1}
{"code": "MONGO_EXPORT gridfs_offset gridfile_read( gridfile *gfile, gridfs_offset size, char *buf ) {\n    mongo_cursor *chunks;\n    bson chunk;\n    int first_chunk;\n    int last_chunk;\n    int total_chunks;\n    gridfs_offset chunksize;\n    gridfs_offset contentlength;\n    gridfs_offset bytes_left;\n    int i;\n    bson_iterator it;\n    gridfs_offset chunk_len;\n    const char *chunk_data;\n    contentlength = gridfile_get_contentlength( gfile );\n    chunksize = gridfile_get_chunksize( gfile );\n    size = ( contentlength - gfile->pos < size )\n           ? contentlength - gfile->pos\n           : size;\n    bytes_left = size;\n    first_chunk = ( gfile->pos )/chunksize;\n    last_chunk = ( gfile->pos+size-1 )/chunksize;\n    total_chunks = last_chunk - first_chunk + 1;\n    chunks = gridfile_get_chunks( gfile, first_chunk, total_chunks );\n    for ( i = 0; i < total_chunks; i++ ) {\n        mongo_cursor_next( chunks );\n        chunk = chunks->current;\n        bson_find( &it, &chunk, \"data\" );\n        chunk_len = bson_iterator_bin_len( &it );\n        chunk_data = bson_iterator_bin_data( &it );\n        if ( i == 0 ) {\n            chunk_data += ( gfile->pos )%chunksize;\n            chunk_len -= ( gfile->pos )%chunksize;\n        }\n        if ( bytes_left > chunk_len ) {\n            memcpy( buf, chunk_data, chunk_len );\n            bytes_left -= chunk_len;\n            buf += chunk_len;\n        }\n        else {\n            memcpy( buf, chunk_data, bytes_left );\n        }\n    }\n    mongo_cursor_destroy( chunks );\n    gfile->pos = gfile->pos + size;\n    return size;\n}", "target": 1}
{"code": "static void cfg_resp_handler(int err, const struct http_msg *msg,\n\t\t\t     struct mbuf *mb, struct json_object *jobj,\n\t\t\t     void *arg)\n{\n\tchar *json_str = NULL;\n\tstruct zapi_ice_server *servers;\n\tsize_t nservers = 0;\n\tsize_t i;\n\tre_printf(\"config ready! err=%d\\n\");\n\tif (err == ECONNABORTED)\n\t\tgoto out;\n\tif (!err && jobj) {\n\t\terr = jzon_encode(&json_str, jobj);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\tre_printf(\"CONFIG: %s\\n\", json_str);\n\tconfig_update(g_config, err, json_str, str_len(json_str));\n\tmem_deref(json_str);\n\tservers = config_get_iceservers(g_config, &nservers);\n\tre_printf(\"Probing: %d servers\\n\", nservers);\n\tfor (i = 0; i < nservers; ++i) {\n\t\tstruct zapi_ice_server *turn = &servers[i];\n\t\tstruct stun_uri uri;\n\t\terr = stun_uri_decode(&uri, turn->url);\n\t\tif (err)\n\t\t\terr = turn_dns_lookup(turn, &uri);\n\t\telse {\n\t\t\tstart_netprobe(&uri.addr, uri.proto, uri.secure,\n\t\t\t\t       turn->username, turn->credential);\n\t\t}\n\t}\n out:\n\tif (err)\n\t\terror(\"config request failed: %m\\n\", err);\n}", "target": 0}
{"code": "static inline bool cma_any_addr(const struct sockaddr *addr)\n{\n\treturn cma_zero_addr(addr) || cma_loopback_addr(addr);\n}", "target": 0}
{"code": "utils::Status NgxEspRequest::AddHeaderToBackend(const std::string &key,\n                                                const std::string &value) {\n  ngx_table_elt_t *h = nullptr;\n  for (auto &h_in : r_->headers_in) {\n    if (key.size() == h_in.key.len &&\n        strncasecmp(key.c_str(), reinterpret_cast<const char *>(h_in.key.data),\n                    h_in.key.len) == 0) {\n      h = &h_in;\n      break;\n    }\n  }\n  if (h == nullptr) {\n    h = reinterpret_cast<ngx_table_elt_t *>(\n        ngx_list_push(&r_->headers_in.headers));\n    if (h == nullptr) {\n      return utils::Status(Code::INTERNAL, \"Out of memory\");\n    }\n    h->lowcase_key =\n        reinterpret_cast<u_char *>(ngx_pcalloc(r_->pool, key.size()));\n    if (h->lowcase_key == nullptr) {\n      return utils::Status(Code::INTERNAL, \"Out of memory\");\n    }\n    h->hash = ngx_hash_strlow(\n        h->lowcase_key,\n        reinterpret_cast<u_char *>(const_cast<char *>(key.c_str())),\n        key.size());\n  }\n  if (ngx_str_copy_from_std(r_->pool, key, &h->key) != NGX_OK ||\n      ngx_str_copy_from_std(r_->pool, value, &h->value) != NGX_OK) {\n    return utils::Status(Code::INTERNAL, \"Out of memory\");\n  }\n  ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r_->connection->log, 0,\n                 \"updates header to backend: \\\"%V: %V\\\"\", &h->key, &h->value);\n  return utils::Status::OK;\n}", "target": 1}
{"code": "static void add_send_options(GDHCPClient *dhcp_client,\n\t\t\t\tstruct dhcp_packet *packet)\n{\n\tg_hash_table_foreach(dhcp_client->send_value_hash,\n\t\t\t\tadd_binary_option, packet);\n}", "target": 0}
{"code": "int wc_SignatureGenerate(\n    enum wc_HashType hash_type, enum wc_SignatureType sig_type,\n    const byte* data, word32 data_len,\n    byte* sig, word32 *sig_len,\n    const void* key, word32 key_len, WC_RNG* rng)\n{\n    return wc_SignatureGenerate_ex(hash_type, sig_type, data, data_len, sig,\n        sig_len, key, key_len, rng, 1);\n}", "target": 0}
{"code": "static bool checkCurl() {\n\tconst char nul[] = R_SYS_DEVNULL;\n\tif (r_sys_cmdf (\"curl --version > %s\", nul) != 0) {\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static bool pb_release_union_field(pb_istream_t *stream, pb_field_iter_t *field)\n{\n    pb_field_iter_t old_field = *field;\n    pb_size_t old_tag = *(pb_size_t*)field->pSize; \n    pb_size_t new_tag = field->tag; \n    if (old_tag == 0)\n        return true; \n    if (old_tag == new_tag)\n        return true; \n    if (!pb_field_iter_find(&old_field, old_tag))\n        PB_RETURN_ERROR(stream, \"invalid union tag\");\n    pb_release_single_field(&old_field);\n    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)\n    {\n        *(void**)field->pField = NULL;\n        field->pData = NULL;\n    }\n    return true;\n}", "target": 0}
{"code": "static void test_map_big_memory(void)\n{\n    uc_engine *uc;\n    OK(uc_open(UC_ARCH_X86, UC_MODE_64, &uc));\n    uc_assert_err(UC_ERR_NOMEM,\n                  uc_mem_map(uc, 0x0, 0xfffffffffffff000, UC_PROT_ALL));\n    OK(uc_close(uc));\n}", "target": 0}
{"code": "int h1_parse_cont_len_header(struct h1m *h1m, struct ist *value)\n{\n\tchar *e, *n;\n\tlong long cl;\n\tint not_first = !!(h1m->flags & H1_MF_CLEN);\n\tstruct ist word;\n\tword.ptr = value->ptr - 1; \n\te = value->ptr + value->len;\n\twhile (++word.ptr < e) {\n\t\tif (unlikely(HTTP_IS_LWS(*word.ptr)))\n\t\t\tcontinue;\n\t\tfor (cl = 0, n = word.ptr; n < e; n++) {\n\t\t\tunsigned int c = *n - '0';\n\t\t\tif (unlikely(c > 9)) {\n\t\t\t\tif (unlikely(n == word.ptr)) \n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(cl > ULLONG_MAX / 10ULL))\n\t\t\t\tgoto fail; \n\t\t\tcl = cl * 10ULL;\n\t\t\tif (unlikely(cl + c < cl))\n\t\t\t\tgoto fail; \n\t\t\tcl = cl + c;\n\t\t}\n\t\tword.len = n - word.ptr;\n\t\tfor (; n < e; n++) {\n\t\t\tif (!HTTP_IS_LWS(*n)) {\n\t\t\t\tif (unlikely(*n != ','))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (h1m->flags & H1_MF_CLEN && cl != h1m->body_len)\n\t\t\tgoto fail;\n\t\th1m->flags |= H1_MF_CLEN;\n\t\th1m->curr_len = h1m->body_len = cl;\n\t\t*value = word;\n\t\tword.ptr = n;\n\t}\n\treturn !not_first;\n fail:\n\treturn -1;\n}", "target": 1}
{"code": "static bool ParseSparseAccessor(Accessor *accessor, std::string *err,\n                                const json &o) {\n  accessor->sparse.isSparse = true;\n  int count = 0;\n  if (!ParseIntegerProperty(&count, err, o, \"count\", true, \"SparseAccessor\")) {\n    return false;\n  }\n  json_const_iterator indices_iterator;\n  json_const_iterator values_iterator;\n  if (!FindMember(o, \"indices\", indices_iterator)) {\n    (*err) = \"the sparse object of this accessor doesn't have indices\";\n    return false;\n  }\n  if (!FindMember(o, \"values\", values_iterator)) {\n    (*err) = \"the sparse object ob ths accessor doesn't have values\";\n    return false;\n  }\n  const json &indices_obj = GetValue(indices_iterator);\n  const json &values_obj = GetValue(values_iterator);\n  int indices_buffer_view = 0, indices_byte_offset = 0, component_type = 0;\n  if (!ParseIntegerProperty(&indices_buffer_view, err, indices_obj, \"bufferView\",\n                       true, \"SparseAccessor\")) {\n    return false;\n  }\n  ParseIntegerProperty(&indices_byte_offset, err, indices_obj, \"byteOffset\",\n                       false);\n  if (!ParseIntegerProperty(&component_type, err, indices_obj, \"componentType\",\n                       true, \"SparseAccessor\")) {\n    return false;\n  }\n  int values_buffer_view = 0, values_byte_offset = 0;\n  if (!ParseIntegerProperty(&values_buffer_view, err, values_obj, \"bufferView\",\n                       true, \"SparseAccessor\")) {\n    return false;\n  }\n  ParseIntegerProperty(&values_byte_offset, err, values_obj, \"byteOffset\",\n                       false);\n  accessor->sparse.count = count;\n  accessor->sparse.indices.bufferView = indices_buffer_view;\n  accessor->sparse.indices.byteOffset = indices_byte_offset;\n  accessor->sparse.indices.componentType = component_type;\n  accessor->sparse.values.bufferView = values_buffer_view;\n  accessor->sparse.values.byteOffset = values_byte_offset;\n  return true;\n}", "target": 1}
{"code": "lt_dlhandle_fetch (lt_dlinterface_id iface, const char *module_name)\n{\n  lt_dlhandle handle = 0;\n  assert (iface); \n  while ((handle = lt_dlhandle_iterate (iface, handle)))\n    {\n      lt_dlhandle cur = handle;\n      if (cur && cur->info.name && streq (cur->info.name, module_name))\n\tbreak;\n    }\n  return handle;\n}", "target": 0}
{"code": "static void process_constructors(RKernelCacheObj *obj, struct MACH0_(obj_t) *mach0, RList *ret, ut64 paddr, bool is_first, int mode, const char *prefix) {\n\tconst RVector *sections = MACH0_(load_sections) (mach0);\n\tif (!sections) {\n\t\treturn;\n\t}\n\tint type;\n\tstruct section_t *section;\n\tr_vector_foreach (sections, section) {\n\t\tif (section->size == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr (section->name, \"_mod_fini_func\") || strstr (section->name, \"_mod_term_func\")) {\n\t\t\ttype  = R_BIN_ENTRY_TYPE_FINI;\n\t\t} else if (strstr (section->name, \"_mod_init_func\")) {\n\t\t\ttype  = is_first ? 0 : R_BIN_ENTRY_TYPE_INIT;\n\t\t\tis_first = false;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tut8 *buf = calloc (section->size, 1);\n\t\tif (!buf) {\n\t\t\tbreak;\n\t\t}\n\t\tif (r_buf_read_at (obj->cache_buf, section->paddr + paddr, buf, section->size) < section->size) {\n\t\t\tfree (buf);\n\t\t\tbreak;\n\t\t}\n\t\tint j;\n\t\tint count = 0;\n\t\tfor (j = 0; j < section->size; j += 8) {\n\t\t\tut64 addr64 = K_RPTR (buf + j);\n\t\t\tut64 paddr64 = section->paddr + paddr + j;\n\t\t\tif (mode == R_K_CONSTRUCTOR_TO_ENTRY) {\n\t\t\t\tRBinAddr *ba = newEntry (paddr64, addr64, type);\n\t\t\t\tr_list_append (ret, ba);\n\t\t\t} else if (mode == R_K_CONSTRUCTOR_TO_SYMBOL) {\n\t\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\t\tif (!sym) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsym->name = r_str_newf (\"%s.%s.%d\", prefix, (type == R_BIN_ENTRY_TYPE_INIT) ? \"init\" : \"fini\", count++);\n\t\t\t\tsym->vaddr = addr64;\n\t\t\t\tsym->paddr = paddr64;\n\t\t\t\tsym->size = 0;\n\t\t\t\tsym->forwarder = \"NONE\";\n\t\t\t\tsym->bind = \"GLOBAL\";\n\t\t\t\tsym->type = \"FUNC\";\n\t\t\t\tr_list_append (ret, sym);\n\t\t\t}\n\t\t}\n\t\tfree (buf);\n\t}\n}", "target": 1}
{"code": "deltas_head_add(struct deltas_head *deltas, unsigned long max_serial,\n    unsigned long serial, char *uri, unsigned char *hash, size_t hash_len)\n{\n\tstruct delta_head *elem;\n\tsize_t position;\n\tint error;\n\tposition = deltas->capacity - 1 - (max_serial - serial);\n\tif (position < 0 || position > deltas->capacity - 1)\n\t\treturn -EINVAL;\n\tif (deltas->array[position] != NULL)\n\t\treturn -EEXIST;\n\telem = NULL;\n\terror = delta_head_create(&elem);\n\tif (error)\n\t\treturn error;\n\telem->serial = serial;\n\telem->doc_data.uri = strdup(uri);\n\tif (elem->doc_data.uri == NULL) {\n\t\tfree(elem);\n\t\treturn pr_enomem();\n\t}\n\telem->doc_data.hash_len = hash_len;\n\telem->doc_data.hash = malloc(hash_len);\n\tif (elem->doc_data.hash == NULL) {\n\t\tfree(elem->doc_data.uri);\n\t\tfree(elem);\n\t\treturn pr_enomem();\n\t}\n\tmemcpy(elem->doc_data.hash, hash, hash_len);\n\tdeltas->array[position] = elem;\n\tdeltas->len++;\n\treturn 0;\n}", "target": 1}
{"code": "int sock_present2network(const char *address, struct sockaddr_storage *sockaddr, int addr_family, char *errbuf, int errbuflen)\n{\n\tstruct addrinfo *addrinfo;\n\tstruct addrinfo hints;\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = addr_family;\n\tif (sock_initaddress(address, \"22222\" , &hints, &addrinfo, errbuf, errbuflen) == -1)\n\t\treturn 0;\n\tif (addrinfo->ai_family == PF_INET)\n\t\tmemcpy(sockaddr, addrinfo->ai_addr, sizeof(struct sockaddr_in));\n\telse\n\t\tmemcpy(sockaddr, addrinfo->ai_addr, sizeof(struct sockaddr_in6));\n\tif (addrinfo->ai_next != NULL)\n\t{\n\t\tfreeaddrinfo(addrinfo);\n\t\tif (errbuf)\n\t\t\tsnprintf(errbuf, errbuflen, \"More than one socket requested; using the first one returned\");\n\t\treturn -2;\n\t}\n\tfreeaddrinfo(addrinfo);\n\treturn -1;\n}", "target": 1}
{"code": "TfLiteIntArray* TfLiteIntArrayCreate(int size) {\n  size_t alloc_size = TfLiteIntArrayGetSizeInBytes(size);\n  if (alloc_size <= 0) return NULL;\n  TfLiteIntArray* ret = (TfLiteIntArray*)malloc(alloc_size);\n  if (!ret) return ret;\n  ret->size = size;\n  return ret;\n}", "target": 0}
{"code": "isAlphaNum(char ch) {\n\treturn (ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');\n}", "target": 0}
{"code": "unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)\n{\n\tstruct desc_struct *desc;\n\tshort sel;\n\tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn -1L;\n\tif (v8086_mode(regs))\n\t\treturn (unsigned long)(sel << 4);\n\tif (user_64bit_mode(regs)) {\n\t\tunsigned long base;\n\t\tif (seg_reg_idx == INAT_SEG_REG_FS)\n\t\t\trdmsrl(MSR_FS_BASE, base);\n\t\telse if (seg_reg_idx == INAT_SEG_REG_GS)\n\t\t\trdmsrl(MSR_KERNEL_GS_BASE, base);\n\t\telse\n\t\t\tbase = 0;\n\t\treturn base;\n\t}\n\tif (!sel)\n\t\treturn -1L;\n\tdesc = get_desc(sel);\n\tif (!desc)\n\t\treturn -1L;\n\treturn get_desc_base(desc);\n}", "target": 1}
{"code": "static BOOL drive_file_remove_dir(const WCHAR* path)\n{\n\tWIN32_FIND_DATAW findFileData;\n\tBOOL ret = TRUE;\n\tHANDLE dir;\n\tWCHAR* fullpath;\n\tWCHAR* path_slash;\n\tsize_t base_path_length;\n\tif (!path)\n\t\treturn FALSE;\n\tbase_path_length = _wcslen(path) * 2;\n\tpath_slash = (WCHAR*)calloc(1, base_path_length + sizeof(WCHAR) * 3);\n\tif (!path_slash)\n\t{\n\t\tWLog_ERR(TAG, \"malloc failed!\");\n\t\treturn FALSE;\n\t}\n\tCopyMemory(path_slash, path, base_path_length);\n\tpath_slash[base_path_length / 2] = L'/';\n\tpath_slash[base_path_length / 2 + 1] = L'*';\n\tDEBUG_WSTR(\"Search in %s\", path_slash);\n\tdir = FindFirstFileW(path_slash, &findFileData);\n\tpath_slash[base_path_length / 2 + 1] = 0;\n\tif (dir == INVALID_HANDLE_VALUE)\n\t{\n\t\tfree(path_slash);\n\t\treturn FALSE;\n\t}\n\tdo\n\t{\n\t\tsize_t len = _wcslen(findFileData.cFileName);\n\t\tif ((len == 1 && findFileData.cFileName[0] == L'.') ||\n\t\t    (len == 2 && findFileData.cFileName[0] == L'.' && findFileData.cFileName[1] == L'.'))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tfullpath = drive_file_combine_fullpath(path_slash, findFileData.cFileName, len * 2);\n\t\tDEBUG_WSTR(\"Delete %s\", fullpath);\n\t\tif (findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)\n\t\t{\n\t\t\tret = drive_file_remove_dir(fullpath);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tret = DeleteFileW(fullpath);\n\t\t}\n\t\tfree(fullpath);\n\t\tif (!ret)\n\t\t\tbreak;\n\t} while (ret && FindNextFileW(dir, &findFileData) != 0);\n\tFindClose(dir);\n\tif (ret)\n\t{\n\t\tif (!RemoveDirectoryW(path))\n\t\t{\n\t\t\tret = FALSE;\n\t\t}\n\t}\n\tfree(path_slash);\n\treturn ret;\n}", "target": 1}
{"code": "static bool is_spilled_reg(const struct bpf_stack_state *stack)\n{\n\treturn stack->slot_type[BPF_REG_SIZE - 1] == STACK_SPILL;\n}", "target": 0}
{"code": "static void LodePNGIText_init(LodePNGInfo* info)\n{\n  info->itext_num = 0;\n  info->itext_keys = NULL;\n  info->itext_langtags = NULL;\n  info->itext_transkeys = NULL;\n  info->itext_strings = NULL;\n}", "target": 0}
{"code": "static int ct_play(struct media_player *mp, void *user_data)\n{\n\tstruct avrcp_player *player = user_data;\n\treturn ct_press(player, AVC_PLAY);\n}", "target": 0}
{"code": "on_response(void *data, krb5_error_code retval, otp_response response)\n{\n    struct request_state rs = *(struct request_state *)data;\n    free(data);\n    if (retval == 0 && response != otp_response_success)\n        retval = KRB5_PREAUTH_FAILED;\n    if (retval == 0)\n        rs.enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n    rs.respond(rs.arg, retval, NULL, NULL, NULL);\n}", "target": 0}
{"code": "__switch_to(struct task_struct *prev_p, struct task_struct *next_p)\n{\n\tstruct thread_struct *prev = &prev_p->thread;\n\tstruct thread_struct *next = &next_p->thread;\n\tint cpu = smp_processor_id();\n\tstruct tss_struct *tss = &per_cpu(init_tss, cpu);\n\tunsigned fsindex, gsindex;\n\tfpu_switch_t fpu;\n\tfpu = switch_fpu_prepare(prev_p, next_p, cpu);\n\tload_sp0(tss, next);\n\tsavesegment(es, prev->es);\n\tif (unlikely(next->es | prev->es))\n\t\tloadsegment(es, next->es);\n\tsavesegment(ds, prev->ds);\n\tif (unlikely(next->ds | prev->ds))\n\t\tloadsegment(ds, next->ds);\n\tsavesegment(fs, fsindex);\n\tsavesegment(gs, gsindex);\n\tload_TLS(next, cpu);\n\tarch_end_context_switch(next_p);\n\tif (unlikely(fsindex | next->fsindex | prev->fs)) {\n\t\tloadsegment(fs, next->fsindex);\n\t\tif (fsindex)\n\t\t\tprev->fs = 0;\n\t}\n\tif (next->fs)\n\t\twrmsrl(MSR_FS_BASE, next->fs);\n\tprev->fsindex = fsindex;\n\tif (unlikely(gsindex | next->gsindex | prev->gs)) {\n\t\tload_gs_index(next->gsindex);\n\t\tif (gsindex)\n\t\t\tprev->gs = 0;\n\t}\n\tif (next->gs)\n\t\twrmsrl(MSR_KERNEL_GS_BASE, next->gs);\n\tprev->gsindex = gsindex;\n\tswitch_fpu_finish(next_p, fpu);\n\tprev->usersp = this_cpu_read(old_rsp);\n\tthis_cpu_write(old_rsp, next->usersp);\n\tthis_cpu_write(current_task, next_p);\n\ttask_thread_info(prev_p)->saved_preempt_count = this_cpu_read(__preempt_count);\n\tthis_cpu_write(__preempt_count, task_thread_info(next_p)->saved_preempt_count);\n\tthis_cpu_write(kernel_stack,\n\t\t  (unsigned long)task_stack_page(next_p) +\n\t\t  THREAD_SIZE - KERNEL_STACK_OFFSET);\n\tif (unlikely(task_thread_info(next_p)->flags & _TIF_WORK_CTXSW_NEXT ||\n\t\t     task_thread_info(prev_p)->flags & _TIF_WORK_CTXSW_PREV))\n\t\t__switch_to_xtra(prev_p, next_p, tss);\n\treturn prev_p;\n}", "target": 1}
{"code": "static int f_midi_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\n{\n\tstruct f_midi *midi = func_to_midi(f);\n\tunsigned i;\n\tint err;\n\tif (intf != midi->ms_id)\n\t\treturn 0;\n\terr = f_midi_start_ep(midi, f, midi->in_ep);\n\tif (err)\n\t\treturn err;\n\terr = f_midi_start_ep(midi, f, midi->out_ep);\n\tif (err)\n\t\treturn err;\n\twhile (kfifo_avail(&midi->in_req_fifo)) {\n\t\tstruct usb_request *req =\n\t\t\tmidi_alloc_ep_req(midi->in_ep, midi->buflen);\n\t\tif (req == NULL)\n\t\t\treturn -ENOMEM;\n\t\treq->length = 0;\n\t\treq->complete = f_midi_complete;\n\t\tkfifo_put(&midi->in_req_fifo, req);\n\t}\n\tfor (i = 0; i < midi->qlen && err == 0; i++) {\n\t\tstruct usb_request *req =\n\t\t\tmidi_alloc_ep_req(midi->out_ep, midi->buflen);\n\t\tif (req == NULL)\n\t\t\treturn -ENOMEM;\n\t\treq->complete = f_midi_complete;\n\t\terr = usb_ep_queue(midi->out_ep, req, GFP_ATOMIC);\n\t\tif (err) {\n\t\t\tERROR(midi, \"%s: couldn't enqueue request: %d\\n\",\n\t\t\t\t    midi->out_ep->name, err);\n\t\t\tfree_ep_req(midi->out_ep, req);\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static CURLcode smtp_connect(struct connectdata *conn,\n                             bool *done) \n{\n  CURLcode result;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n  struct SessionHandle *data = conn->data;\n  struct pingpong *pp = &smtpc->pp;\n  const char *path = conn->data->state.path;\n  int len;\n  char localhost[HOSTNAME_MAX + 1];\n  *done = FALSE; \n  Curl_reset_reqproto(conn);\n  result = smtp_init(conn);\n  if(CURLE_OK != result)\n    return result;\n  conn->bits.close = FALSE;\n  pp->response_time = RESP_TIMEOUT; \n  pp->statemach_act = smtp_statemach_act;\n  pp->endofresp = smtp_endofresp;\n  pp->conn = conn;\n  if(conn->bits.tunnel_proxy && conn->bits.httpproxy) {\n    struct HTTP http_proxy;\n    struct FTP *smtp_save;\n    smtp_save = data->state.proto.smtp;\n    memset(&http_proxy, 0, sizeof(http_proxy));\n    data->state.proto.http = &http_proxy;\n    result = Curl_proxyCONNECT(conn, FIRSTSOCKET,\n                               conn->host.name, conn->remote_port);\n    data->state.proto.smtp = smtp_save;\n    if(CURLE_OK != result)\n      return result;\n  }\n  if((conn->handler->protocol & CURLPROTO_SMTPS) &&\n      data->state.used_interface != Curl_if_multi) {\n    result = Curl_ssl_connect(conn, FIRSTSOCKET);\n    if(result)\n      return result;\n  }\n  Curl_pp_init(pp); \n  pp->response_time = RESP_TIMEOUT; \n  pp->statemach_act = smtp_statemach_act;\n  pp->endofresp = smtp_endofresp;\n  pp->conn = conn;\n  if(!*path) {\n    if(!Curl_gethostname(localhost, sizeof localhost))\n      path = localhost;\n    else\n      path = \"localhost\";\n  }\n  smtpc->domain = curl_easy_unescape(conn->data, path, 0, &len);\n  if(!smtpc->domain)\n    return CURLE_OUT_OF_MEMORY;\n  state(conn, SMTP_SERVERGREET);\n  if(data->state.used_interface == Curl_if_multi)\n    result = smtp_multi_statemach(conn, done);\n  else {\n    result = smtp_easy_statemach(conn);\n    if(!result)\n      *done = TRUE;\n  }\n  return result;\n}", "target": 1}
{"code": "static void netbk_fatal_tx_err(struct xenvif *vif)\n{\n\tnetdev_err(vif->dev, \"fatal error; disabling device\\n\");\n\txenvif_carrier_off(vif);\n\txenvif_put(vif);\n}", "target": 0}
{"code": "callbacks_show_selection_on_invisible (GtkMenuItem *menuitem, gpointer user_data)\n{\n\tmainProject->show_invisible_selection = GTK_CHECK_MENU_ITEM(menuitem)->active;\n\trender_refresh_rendered_image_on_screen();\n}", "target": 0}
{"code": "xfs_attr3_leaf_clearflag(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen;\n\tchar *name;\n#endif \n\ttrace_xfs_attr_leaf_clearflag(args);\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn(error);\n\tleaf = bp->b_addr;\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tASSERT(entry->flags & XFS_ATTR_INCOMPLETE);\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index < ichdr.count);\n\tASSERT(args->index >= 0);\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tnamelen = name_loc->namelen;\n\t\tname = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tnamelen = name_rmt->namelen;\n\t\tname = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry->hashval) == args->hashval);\n\tASSERT(namelen == args->namelen);\n\tASSERT(memcmp(name, args->name, namelen) == 0);\n#endif \n\tentry->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\tif (args->rmtblkno) {\n\t\tASSERT((entry->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->valuelen);\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n\t}\n\treturn xfs_trans_roll(&args->trans, args->dp);\n}", "target": 1}
{"code": "static int ipv6_route_open(struct inode *inode, struct file *file)\n{\n\treturn single_open_net(inode, file, ipv6_route_show);\n}", "target": 0}
{"code": "static void mrled(u8 * RESTRICT in, u8 * RESTRICT out, s32 outlen) {\n    s32 op = 0, ip = 0;\n    s32 c, pc = -1;\n    s32 t[256] = { 0 };\n    s32 run = 0;\n    for (s32 i = 0; i < 32; ++i) {\n        c = in[ip++];\n        for (s32 j = 0; j < 8; ++j) t[i * 8 + j] = (c >> j) & 1;\n    }\n    while (op < outlen) {\n        c = in[ip++];\n        if (t[c]) {\n            for (run = 0; (pc = in[ip++]) == 255; run += 255)\n                ;\n            run += pc + 1;\n            for (; run > 0 && op < outlen; --run) out[op++] = c;\n        } else\n            out[op++] = c;\n    }\n}", "target": 1}
{"code": "static bool parse_reconnect(struct pool *pool, json_t *val)\n{\n\tchar *sockaddr_url, *stratum_port, *tmp;\n\tchar *url, *port, address[256];\n\tmemset(address, 0, 255);\n\turl = (char *)json_string_value(json_array_get(val, 0));\n\tif (!url)\n\t\turl = pool->sockaddr_url;\n\telse {\n\t\tchar *dot_pool, *dot_reconnect;\n\t\tdot_pool = strchr(pool->sockaddr_url, '.');\n\t\tif (!dot_pool) {\n\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request for pool without domain '%s'\",\n\t\t\t       pool->sockaddr_url);\n\t\t\treturn false;\n\t\t}\n\t\tdot_reconnect = strchr(url, '.');\n\t\tif (!dot_reconnect) {\n\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request to url without domain '%s'\",\n\t\t\t       url);\n\t\t\treturn false;\n\t\t}\n\t\tif (strcmp(dot_pool, dot_reconnect)) {\n\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request to non-matching domain url '%s'\",\n\t\t\t\tpool->sockaddr_url);\n\t\t\treturn false;\n\t\t}\n\t}\n\tport = (char *)json_string_value(json_array_get(val, 1));\n\tif (!port)\n\t\tport = pool->stratum_port;\n\tsprintf(address, \"%s:%s\", url, port);\n\tif (!extract_sockaddr(address, &sockaddr_url, &stratum_port))\n\t\treturn false;\n\tapplog(LOG_WARNING, \"Stratum reconnect requested from pool %d to %s\", pool->pool_no, address);\n\tclear_pool_work(pool);\n\tmutex_lock(&pool->stratum_lock);\n\t__suspend_stratum(pool);\n\ttmp = pool->sockaddr_url;\n\tpool->sockaddr_url = sockaddr_url;\n\tpool->stratum_url = pool->sockaddr_url;\n\tfree(tmp);\n\ttmp = pool->stratum_port;\n\tpool->stratum_port = stratum_port;\n\tfree(tmp);\n\tmutex_unlock(&pool->stratum_lock);\n\tif (!restart_stratum(pool)) {\n\t\tpool_failed(pool);\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "int imap_exec(struct ImapAccountData *adata, const char *cmdstr, ImapCmdFlags flags)\n{\n  int rc;\n  if (flags & IMAP_CMD_SINGLE)\n  {\n    if (adata->nextcmd != adata->lastcmd)\n      imap_exec(adata, NULL, IMAP_CMD_POLL);\n  }\n  rc = cmd_start(adata, cmdstr, flags);\n  if (rc < 0)\n  {\n    cmd_handle_fatal(adata);\n    return IMAP_EXEC_FATAL;\n  }\n  if (flags & IMAP_CMD_QUEUE)\n    return IMAP_EXEC_SUCCESS;\n  if ((flags & IMAP_CMD_POLL) && (C_ImapPollTimeout > 0) &&\n      ((mutt_socket_poll(adata->conn, C_ImapPollTimeout)) == 0))\n  {\n    mutt_error(_(\"Connection to %s timed out\"), adata->conn->account.host);\n    cmd_handle_fatal(adata);\n    return IMAP_EXEC_FATAL;\n  }\n  mutt_sig_allow_interrupt(true);\n  do\n  {\n    rc = imap_cmd_step(adata);\n    if ((flags & IMAP_CMD_SINGLE) && (adata->nextcmd == adata->lastcmd))\n      break;\n  } while (rc == IMAP_RES_CONTINUE);\n  mutt_sig_allow_interrupt(false);\n  if (rc == IMAP_RES_NO)\n    return IMAP_EXEC_ERROR;\n  if (rc != IMAP_RES_OK)\n  {\n    if (adata->status != IMAP_FATAL)\n      return IMAP_EXEC_ERROR;\n    mutt_debug(LL_DEBUG1, \"command failed: %s\\n\", adata->buf);\n    return IMAP_EXEC_FATAL;\n  }\n  return IMAP_EXEC_SUCCESS;\n}", "target": 0}
{"code": "static void vmx_cpuid_update(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 exec_control;\n\tvmx->rdtscp_enabled = false;\n\tif (vmx_rdtscp_supported()) {\n\t\texec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);\n\t\tif (exec_control & SECONDARY_EXEC_RDTSCP) {\n\t\t\tbest = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\t\t\tif (best && (best->edx & bit(X86_FEATURE_RDTSCP)))\n\t\t\t\tvmx->rdtscp_enabled = true;\n\t\t\telse {\n\t\t\t\texec_control &= ~SECONDARY_EXEC_RDTSCP;\n\t\t\t\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t\t\t\texec_control);\n\t\t\t}\n\t\t}\n\t}\n\tbest = kvm_find_cpuid_entry(vcpu, 0x7, 0);\n\tif (vmx_invpcid_supported() &&\n\t    best && (best->ebx & bit(X86_FEATURE_INVPCID)) &&\n\t    guest_cpuid_has_pcid(vcpu)) {\n\t\texec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);\n\t\texec_control |= SECONDARY_EXEC_ENABLE_INVPCID;\n\t\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t     exec_control);\n\t} else {\n\t\tif (cpu_has_secondary_exec_ctrls()) {\n\t\t\texec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);\n\t\t\texec_control &= ~SECONDARY_EXEC_ENABLE_INVPCID;\n\t\t\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t\t     exec_control);\n\t\t}\n\t\tif (best)\n\t\t\tbest->ebx &= ~bit(X86_FEATURE_INVPCID);\n\t}\n}", "target": 0}
{"code": "xfs_attr3_leaf_getvalue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tint\t\t\tvaluelen;\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(ichdr.count < XFS_LBSIZE(args->dp->i_mount) / 8);\n\tASSERT(args->index < ichdr.count);\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tASSERT(name_loc->namelen == args->namelen);\n\t\tASSERT(memcmp(args->name, name_loc->nameval, args->namelen) == 0);\n\t\tvaluelen = be16_to_cpu(name_loc->valuelen);\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn 0;\n\t\t}\n\t\tif (args->valuelen < valuelen) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn XFS_ERROR(ERANGE);\n\t\t}\n\t\targs->valuelen = valuelen;\n\t\tmemcpy(args->value, &name_loc->nameval[args->namelen], valuelen);\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tASSERT(name_rmt->namelen == args->namelen);\n\t\tASSERT(memcmp(args->name, name_rmt->name, args->namelen) == 0);\n\t\tvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(args->dp->i_mount,\n\t\t\t\t\t\t       valuelen);\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn 0;\n\t\t}\n\t\tif (args->valuelen < valuelen) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn XFS_ERROR(ERANGE);\n\t\t}\n\t\targs->valuelen = valuelen;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void ftoa_bounded_extra(JsVarFloat val,char *str, size_t len, int radix, int fractionalDigits) {\n  const JsVarFloat stopAtError = 0.0000001;\n  if (isnan(val)) strncpy(str,\"NaN\",len);\n  else if (!isfinite(val)) {\n    if (val<0) strncpy(str,\"-Infinity\",len);\n    else strncpy(str,\"Infinity\",len);\n  } else {\n    if (val<0) {\n      if (--len <= 0) { *str=0; return; } \n      *(str++) = '-';\n      val = -val;\n    }\n    if (((JsVarInt)(val+stopAtError)) == (1+(JsVarInt)val))\n      val = (JsVarFloat)(1+(JsVarInt)val);\n    JsVarFloat d = 1;\n    while (d*radix <= val) d*=radix;\n    while (d >= 1) {\n      int v = (int)(val / d);\n      val -= v*d;\n      if (--len <= 0) { *str=0; return; } \n      *(str++) = itoch(v);\n      d /= radix;\n    }\n#ifndef USE_NO_FLOATS\n    if (((fractionalDigits<0) && val>0) || fractionalDigits>0) {\n      bool hasPt = false;\n      val*=radix;\n      while (((fractionalDigits<0) && (fractionalDigits>-12) && (val > stopAtError)) || (fractionalDigits > 0)) {\n        int v = (int)(val+((fractionalDigits==1) ? 0.4 : 0.00000001) );\n        val = (val-v)*radix;\n\tif (v==radix) v=radix-1;\n        if (!hasPt) {\t\n\t  hasPt = true;\n          if (--len <= 0) { *str=0; return; } \n          *(str++)='.';\n        }\n        if (--len <= 0) { *str=0; return; } \n        *(str++)=itoch(v);\n        fractionalDigits--;\n      }\n    }\n#endif\n    *(str++)=0;\n  }\n}", "target": 1}
{"code": "static int follow_dotdot_rcu(struct nameidata *nd)\n{\n\tstruct inode *inode = nd->inode;\n\tif (!nd->root.mnt)\n\t\tset_root_rcu(nd);\n\twhile (1) {\n\t\tif (path_equal(&nd->path, &nd->root))\n\t\t\tbreak;\n\t\tif (nd->path.dentry != nd->path.mnt->mnt_root) {\n\t\t\tstruct dentry *old = nd->path.dentry;\n\t\t\tstruct dentry *parent = old->d_parent;\n\t\t\tunsigned seq;\n\t\t\tinode = parent->d_inode;\n\t\t\tseq = read_seqcount_begin(&parent->d_seq);\n\t\t\tif (unlikely(read_seqcount_retry(&old->d_seq, nd->seq)))\n\t\t\t\treturn -ECHILD;\n\t\t\tnd->path.dentry = parent;\n\t\t\tnd->seq = seq;\n\t\t\tif (unlikely(!path_connected(&nd->path)))\n\t\t\t\treturn -ENOENT;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tstruct mount *mnt = real_mount(nd->path.mnt);\n\t\t\tstruct mount *mparent = mnt->mnt_parent;\n\t\t\tstruct dentry *mountpoint = mnt->mnt_mountpoint;\n\t\t\tstruct inode *inode2 = mountpoint->d_inode;\n\t\t\tunsigned seq = read_seqcount_begin(&mountpoint->d_seq);\n\t\t\tif (unlikely(read_seqretry(&mount_lock, nd->m_seq)))\n\t\t\t\treturn -ECHILD;\n\t\t\tif (&mparent->mnt == nd->path.mnt)\n\t\t\t\tbreak;\n\t\t\tnd->path.dentry = mountpoint;\n\t\t\tnd->path.mnt = &mparent->mnt;\n\t\t\tinode = inode2;\n\t\t\tnd->seq = seq;\n\t\t}\n\t}\n\twhile (unlikely(d_mountpoint(nd->path.dentry))) {\n\t\tstruct mount *mounted;\n\t\tmounted = __lookup_mnt(nd->path.mnt, nd->path.dentry);\n\t\tif (unlikely(read_seqretry(&mount_lock, nd->m_seq)))\n\t\t\treturn -ECHILD;\n\t\tif (!mounted)\n\t\t\tbreak;\n\t\tnd->path.mnt = &mounted->mnt;\n\t\tnd->path.dentry = mounted->mnt.mnt_root;\n\t\tinode = nd->path.dentry->d_inode;\n\t\tnd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);\n\t}\n\tnd->inode = inode;\n\treturn 0;\n}", "target": 0}
{"code": "static bool gguf_ex_read_0(const std::string & fname) {\n    struct gguf_init_params params = {\n         false,\n         NULL,\n    };\n    struct gguf_context * ctx = gguf_init_from_file(fname.c_str(), params);\n    if (!ctx) {\n        fprintf(stderr, \"%s: failed to load '%s'\\n\", __func__, fname.c_str());\n        return false;\n    }\n    printf(\"%s: version:      %d\\n\", __func__, gguf_get_version(ctx));\n    printf(\"%s: alignment:   %zu\\n\", __func__, gguf_get_alignment(ctx));\n    printf(\"%s: data offset: %zu\\n\", __func__, gguf_get_data_offset(ctx));\n    {\n        const int n_kv = gguf_get_n_kv(ctx);\n        printf(\"%s: n_kv: %d\\n\", __func__, n_kv);\n        for (int i = 0; i < n_kv; ++i) {\n            const char * key = gguf_get_key(ctx, i);\n            printf(\"%s: kv[%d]: key = %s\\n\", __func__, i, key);\n        }\n    }\n    {\n        const char * findkey = \"some.parameter.string\";\n        const int keyidx = gguf_find_key(ctx, findkey);\n        if (keyidx == -1) {\n            printf(\"%s: find key: %s not found.\\n\", __func__, findkey);\n        } else {\n            const char * key_value = gguf_get_val_str(ctx, keyidx);\n            printf(\"%s: find key: %s found, kv[%d] value = %s\\n\", __func__, findkey, keyidx, key_value);\n        }\n    }\n    {\n        const int n_tensors = gguf_get_n_tensors(ctx);\n        printf(\"%s: n_tensors: %d\\n\", __func__, n_tensors);\n        for (int i = 0; i < n_tensors; ++i) {\n            const char * name   = gguf_get_tensor_name  (ctx, i);\n            const size_t offset = gguf_get_tensor_offset(ctx, i);\n            printf(\"%s: tensor[%d]: name = %s, offset = %zu\\n\", __func__, i, name, offset);\n        }\n    }\n    gguf_free(ctx);\n    return true;\n}", "target": 0}
{"code": "static int raw_cmd_copyin(int cmd, void __user *param,\n\t\t\t\t struct floppy_raw_cmd **rcmd)\n{\n\tstruct floppy_raw_cmd *ptr;\n\tint ret;\n\tint i;\n\t*rcmd = NULL;\nloop:\n\tptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_USER);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\t*rcmd = ptr;\n\tret = copy_from_user(ptr, param, sizeof(*ptr));\n\tif (ret)\n\t\treturn -EFAULT;\n\tptr->next = NULL;\n\tptr->buffer_length = 0;\n\tparam += sizeof(struct floppy_raw_cmd);\n\tif (ptr->cmd_count > 33)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < 16; i++)\n\t\tptr->reply[i] = 0;\n\tptr->resultcode = 0;\n\tptr->kernel_data = NULL;\n\tif (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\n\t\tif (ptr->length <= 0)\n\t\t\treturn -EINVAL;\n\t\tptr->kernel_data = (char *)fd_dma_mem_alloc(ptr->length);\n\t\tfallback_on_nodma_alloc(&ptr->kernel_data, ptr->length);\n\t\tif (!ptr->kernel_data)\n\t\t\treturn -ENOMEM;\n\t\tptr->buffer_length = ptr->length;\n\t}\n\tif (ptr->flags & FD_RAW_WRITE) {\n\t\tret = fd_copyin(ptr->data, ptr->kernel_data, ptr->length);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (ptr->flags & FD_RAW_MORE) {\n\t\trcmd = &(ptr->next);\n\t\tptr->rate &= 0x43;\n\t\tgoto loop;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void perf_callchain_user_64(struct perf_callchain_entry *entry,\n\t\t\t\t   struct pt_regs *regs)\n{\n\tunsigned long sp, next_sp;\n\tunsigned long next_ip;\n\tunsigned long lr;\n\tlong level = 0;\n\tstruct signal_frame_64 __user *sigframe;\n\tunsigned long __user *fp, *uregs;\n\tnext_ip = perf_instruction_pointer(regs);\n\tlr = regs->link;\n\tsp = regs->gpr[1];\n\tperf_callchain_store(entry, next_ip);\n\tfor (;;) {\n\t\tfp = (unsigned long __user *) sp;\n\t\tif (!valid_user_sp(sp, 1) || read_user_stack_64(fp, &next_sp))\n\t\t\treturn;\n\t\tif (level > 0 && read_user_stack_64(&fp[2], &next_ip))\n\t\t\treturn;\n\t\tif (next_sp - sp >= sizeof(struct signal_frame_64) &&\n\t\t    (is_sigreturn_64_address(next_ip, sp) ||\n\t\t     (level <= 1 && is_sigreturn_64_address(lr, sp))) &&\n\t\t    sane_signal_64_frame(sp)) {\n\t\t\tsigframe = (struct signal_frame_64 __user *) sp;\n\t\t\turegs = sigframe->uc.uc_mcontext.gp_regs;\n\t\t\tif (read_user_stack_64(&uregs[PT_NIP], &next_ip) ||\n\t\t\t    read_user_stack_64(&uregs[PT_LNK], &lr) ||\n\t\t\t    read_user_stack_64(&uregs[PT_R1], &sp))\n\t\t\t\treturn;\n\t\t\tlevel = 0;\n\t\t\tperf_callchain_store(entry, PERF_CONTEXT_USER);\n\t\t\tperf_callchain_store(entry, next_ip);\n\t\t\tcontinue;\n\t\t}\n\t\tif (level == 0)\n\t\t\tnext_ip = lr;\n\t\tperf_callchain_store(entry, next_ip);\n\t\t++level;\n\t\tsp = next_sp;\n\t}\n}", "target": 1}
{"code": "int ssl_init( ssl_context *ssl )\n{\n    int ret;\n    int len = SSL_BUFFER_LEN;\n    memset( ssl, 0, sizeof( ssl_context ) );\n    ssl->rsa_decrypt = ssl_rsa_decrypt;\n    ssl->rsa_sign = ssl_rsa_sign;\n    ssl->rsa_key_len = ssl_rsa_key_len;\n    ssl->min_major_ver = SSL_MAJOR_VERSION_3;\n    ssl->min_minor_ver = SSL_MINOR_VERSION_0;\n    ssl->ciphersuites = ssl_default_ciphersuites;\n#if defined(POLARSSL_DHM_C)\n    if( ( ret = mpi_read_string( &ssl->dhm_P, 16,\n                                 POLARSSL_DHM_RFC5114_MODP_1024_P) ) != 0 ||\n        ( ret = mpi_read_string( &ssl->dhm_G, 16,\n                                 POLARSSL_DHM_RFC5114_MODP_1024_G) ) != 0 )\n    {\n        SSL_DEBUG_RET( 1, \"mpi_read_string\", ret );\n        return( ret );\n    }\n#endif\n    ssl->in_ctr = (unsigned char *) malloc( len );\n    ssl->in_hdr = ssl->in_ctr +  8;\n    ssl->in_msg = ssl->in_ctr + 13;\n    if( ssl->in_ctr == NULL )\n    {\n        SSL_DEBUG_MSG( 1, ( \"malloc(%d bytes) failed\", len ) );\n        return( POLARSSL_ERR_SSL_MALLOC_FAILED );\n    }\n    ssl->out_ctr = (unsigned char *) malloc( len );\n    ssl->out_hdr = ssl->out_ctr +  8;\n    ssl->out_msg = ssl->out_ctr + 40;\n    if( ssl->out_ctr == NULL )\n    {\n        SSL_DEBUG_MSG( 1, ( \"malloc(%d bytes) failed\", len ) );\n        free( ssl-> in_ctr );\n        return( POLARSSL_ERR_SSL_MALLOC_FAILED );\n    }\n    memset( ssl-> in_ctr, 0, SSL_BUFFER_LEN );\n    memset( ssl->out_ctr, 0, SSL_BUFFER_LEN );\n    ssl->hostname = NULL;\n    ssl->hostname_len = 0;\n    if( ( ret = ssl_handshake_init( ssl ) ) != 0 )\n        return( ret );\n    return( 0 );\n}", "target": 0}
{"code": "DECLAREcpFunc(cpDecodedStrips)\n{\n\ttsize_t stripsize  = TIFFStripSize(in);\n\ttdata_t buf = _TIFFmalloc(stripsize);\n\t(void) imagewidth; (void) spp;\n\tif (buf) {\n\t\ttstrip_t s, ns = TIFFNumberOfStrips(in);\n\t\tuint32 row = 0;\n\t\t_TIFFmemset(buf, 0, stripsize);\n\t\tfor (s = 0; s < ns; s++) {\n\t\t\ttsize_t cc = (row + rowsperstrip > imagelength) ?\n\t\t\t    TIFFVStripSize(in, imagelength - row) : stripsize;\n\t\t\tif (TIFFReadEncodedStrip(in, s, buf, cc) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read strip %lu\",\n\t\t\t\t    (unsigned long) s);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (TIFFWriteEncodedStrip(out, s, buf, cc) < 0) {\n\t\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t\t    \"Error, can't write strip %lu\",\n\t\t\t\t    (unsigned long) s);\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\trow += rowsperstrip;\n\t\t}\n\t\t_TIFFfree(buf);\n\t\treturn 1;\n\t} else {\n\t\tTIFFError(TIFFFileName(in),\n\t\t    \"Error, can't allocate memory buffer of size %lu \"\n\t\t    \"to read strips\", (unsigned long) stripsize);\n\t\treturn 0;\n\t}\nbad:\n\t_TIFFfree(buf);\n\treturn 0;\n}", "target": 1}
{"code": "bool use_client_socket(int fd, PgAddr *addr,\n\t\t       const char *dbname, const char *username,\n\t\t       uint64_t ckey, int oldfd, int linkfd,\n\t\t       const char *client_enc, const char *std_string,\n\t\t       const char *datestyle, const char *timezone)\n{\n\tPgSocket *client;\n\tPktBuf tmp;\n\tclient = accept_client(fd, pga_is_unix(addr));\n\tif (client == NULL)\n\t\treturn false;\n\tclient->suspended = 1;\n\tif (!set_pool(client, dbname, username))\n\t\treturn false;\n\tchange_client_state(client, CL_ACTIVE);\n\tpktbuf_static(&tmp, client->cancel_key, 8);\n\tpktbuf_put_uint64(&tmp, ckey);\n\tclient->tmp_sk_oldfd = oldfd;\n\tclient->tmp_sk_linkfd = linkfd;\n\tvarcache_set(&client->vars, \"client_encoding\", client_enc);\n\tvarcache_set(&client->vars, \"standard_conforming_strings\", std_string);\n\tvarcache_set(&client->vars, \"datestyle\", datestyle);\n\tvarcache_set(&client->vars, \"timezone\", timezone);\n\treturn true;\n}", "target": 0}
{"code": "static void do_proc_open(FILE *fin, FILE *fout, int afdt_fd) {\n  char cmd[BUFFER_SIZE];\n  read_buf(fin, cmd);\n  if (strlen(cmd) == 0) {\n    fprintf(fout, \"error\\n%d\\n\", ENOENT);\n    fflush(fout);\n    return;\n  }\n  char cwd[BUFFER_SIZE];\n  read_buf(fin, cwd);\n  char buf[BUFFER_SIZE];\n  int env_size = 0;\n  std::vector<std::string> env;\n  read_buf(fin, buf);\n  sscanf(buf, \"%d\", &env_size);\n  for (int i = 0; i < env_size; i++) {\n    read_buf(fin, buf);\n    env.push_back(buf);\n  }\n  int pipe_size = 0;\n  read_buf(fin, buf);\n  sscanf(buf, \"%d\", &pipe_size);\n  std::vector<int> pvals;\n  for (int i = 0; i < pipe_size; i++) {\n    int fd_value;\n    read_buf(fin, buf);\n    sscanf(buf, \"%d\", &fd_value);\n    pvals.push_back(fd_value);\n  }\n  std::vector<int> pkeys;\n  for (int i = 0; i < pipe_size; i++) {\n    int fd = recv_fd(afdt_fd);\n    if (fd < 0) {\n      fprintf(fout, \"error\\n%d\\n\", EPROTO);\n      fflush(fout);\n      close_fds(pkeys);\n      return;\n    }\n    pkeys.push_back(fd);\n  }\n  pid_t child = fork();\n  if (child == 0) {\n    for (int i = 0; i < pipe_size; i++) {\n      dup2(pkeys[i], pvals[i]);\n    }\n    if (strlen(cwd) > 0 && chdir(cwd)) {\n    }\n    if (!env.empty()) {\n      char **envp = build_envp(env);\n      execle(\"/bin/sh\", \"sh\", \"-c\", cmd, nullptr, envp);\n      free(envp);\n    } else {\n      execl(\"/bin/sh\", \"sh\", \"-c\", cmd, nullptr);\n    }\n    _exit(127);\n  } else if (child > 0) {\n    fprintf(fout, \"%\" PRId64 \"\\n\", (int64_t)child);\n    fflush(fout);\n  } else {\n    fprintf(fout, \"error\\n%d\\n\", errno);\n    fflush(fout);\n  }\n  close_fds(pkeys);\n}", "target": 1}
{"code": "static uint get_alen(char *arg, int default_len)\n{\n\tint\tj;\n\tint\talen;\n\talen = default_len;\n\tfor (j = 0; j < 8; j++) {\n\t\tif (arg[j] == '.') {\n\t\t\talen = arg[j+1] - '0';\n\t\t\tbreak;\n\t\t} else if (arg[j] == '\\0')\n\t\t\tbreak;\n\t}\n\treturn alen;\n}", "target": 1}
{"code": "my_ulonglong STDCALL mysql_insert_id(MYSQL *mysql)\n{\n  return mysql->insert_id;\n}", "target": 0}
{"code": "NCR_CheckAccessRestriction(IPAddr *ip_addr)\n{\n  return ADF_IsAllowed(access_auth_table, ip_addr);\n}", "target": 0}
{"code": "spnego_gss_set_sec_context_option(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t *context_handle,\n\t\tconst gss_OID desired_object,\n\t\tconst gss_buffer_t value)\n{\n\tOM_uint32 ret;\n\tret = gss_set_sec_context_option(minor_status,\n\t\t\t    context_handle,\n\t\t\t    desired_object,\n\t\t\t    value);\n\treturn (ret);\n}", "target": 1}
{"code": "static int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n\tint ret;\n\tspin_lock_irqsave(&dev->lock, flags);\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\tbuf[1] &= ~(1 << offset);\n\tbuf[2] = gpio_push_pull;\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error setting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\tret = 0;\nexit:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn ret <= 0 ? ret : -EIO;\n}", "target": 1}
{"code": "ext2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\tswitch(type) {\n\t\tcase ACL_TYPE_ACCESS:\n\t\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\t\tif (acl) {\n\t\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\t\tif (error < 0)\n\t\t\t\t\treturn error;\n\t\t\t\telse {\n\t\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\t\t\t\tmark_inode_dirty(inode);\n\t\t\t\t\tif (error == 0)\n\t\t\t\t\t\tacl = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ACL_TYPE_DEFAULT:\n\t\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\t\treturn acl ? -EACCES : 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n \tif (acl) {\n\t\tvalue = ext2_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\terror = ext2_xattr_set(inode, name_index, \"\", value, size, 0);\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}", "target": 1}
{"code": "dcinit()\n{\n\tstrsize = 1; \n\tstrmaxsize=DCSTRSIZE;\n\tdcstr=calloc(DCSTRSIZE,1);\n\tdcptr=dcstr;\n}", "target": 0}
{"code": "check_mul_overflow(size_t a, size_t b, size_t* res)\n{\n    size_t tmp = a * b;\n    if (a != 0 && tmp / a != b) return 1;\n    *res = tmp;\n    return 0;\n}", "target": 0}
{"code": "char *uwsgi_expand_path(char *dir, int dir_len, char *ptr) {\n\tchar src[PATH_MAX + 1];\n\tmemcpy(src, dir, dir_len);\n\tsrc[dir_len] = 0;\n\tchar *dst = ptr;\n\tif (!dst)\n\t\tdst = uwsgi_malloc(PATH_MAX + 1);\n\tif (!realpath(src, dst)) {\n\t\tuwsgi_error_realpath(src);\n\t\tif (!ptr)\n\t\t\tfree(dst);\n\t\treturn NULL;\n\t}\n\treturn dst;\n}", "target": 1}
{"code": "static void vhost_vdpa_reset(struct vhost_vdpa *v)\n{\n\tstruct vdpa_device *vdpa = v->vdpa;\n\tvdpa_reset(vdpa);\n\tv->in_batch = 0;\n}", "target": 0}
{"code": "int main()\n{\n    gdImagePtr src, dst;\n    int size;\n    src = gdImageCreateTrueColor(1, 10);\n    gdTestAssert(src != NULL);\n    src->sx = 0; \n    dst = gdImageJpegPtr(src, &size, 0);\n    gdTestAssert(dst == NULL);\n    gdImageDestroy(src);\n    return gdNumFailures();\n}", "target": 0}
{"code": "static int xen_netbk_get_extras(struct xenvif *vif,\n\t\t\t\tstruct xen_netif_extra_info *extras,\n\t\t\t\tint work_to_do)\n{\n\tstruct xen_netif_extra_info extra;\n\tRING_IDX cons = vif->tx.req_cons;\n\tdo {\n\t\tif (unlikely(work_to_do-- <= 0)) {\n\t\t\tnetdev_dbg(vif->dev, \"Missing extra info\\n\");\n\t\t\treturn -EBADR;\n\t\t}\n\t\tmemcpy(&extra, RING_GET_REQUEST(&vif->tx, cons),\n\t\t       sizeof(extra));\n\t\tif (unlikely(!extra.type ||\n\t\t\t     extra.type >= XEN_NETIF_EXTRA_TYPE_MAX)) {\n\t\t\tvif->tx.req_cons = ++cons;\n\t\t\tnetdev_dbg(vif->dev,\n\t\t\t\t   \"Invalid extra type: %d\\n\", extra.type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmemcpy(&extras[extra.type - 1], &extra, sizeof(extra));\n\t\tvif->tx.req_cons = ++cons;\n\t} while (extra.flags & XEN_NETIF_EXTRA_FLAG_MORE);\n\treturn work_to_do;\n}", "target": 1}
{"code": "bool L2NormalizeReduceAxis(Value sq_op, DenseElementsAttr axis) {\n  if (axis.getNumElements() == 0) {\n    return false;\n  }\n  if (sq_op.getType().cast<ShapedType>().getRank() - 1 ==\n          *axis.getValues<int>().begin() ||\n      *axis.getValues<int>().begin() == -1) {\n    return true;\n  }\n  if (sq_op.getType().cast<ShapedType>().getRank() != axis.getNumElements()) {\n    return false;\n  }\n  auto shape = sq_op.getType().cast<ShapedType>();\n  SmallVector<int, 4> elems{axis.getValues<int>().begin(),\n                            axis.getValues<int>().end()};\n  for (int i = 0; i < shape.getRank(); ++i) {\n    if (i != elems[i]) return false;\n  }\n  return true;\n}", "target": 0}
{"code": "NOEXPORT int init_section(int eof, SERVICE_OPTIONS **section_ptr) {\n    char *errstr;\n#ifndef USE_WIN32\n    (*section_ptr)->option.log_stderr=new_global_options.option.log_stderr;\n#endif \n    if(*section_ptr==&new_service_options) {\n        errstr=parse_global_option(CMD_INITIALIZE, NULL, NULL);\n        if(errstr) {\n            s_log(LOG_ERR, \"Global options: %s\", errstr);\n            return 1;\n        }\n    }\n    if(*section_ptr!=&new_service_options || eof) {\n        if(*section_ptr==&new_service_options)\n            s_log(LOG_INFO, \"Initializing inetd mode configuration\");\n        else\n            s_log(LOG_INFO, \"Initializing service [%s]\",\n                (*section_ptr)->servname);\n        errstr=parse_service_option(CMD_INITIALIZE, section_ptr, NULL, NULL);\n        if(errstr) {\n            if(*section_ptr==&new_service_options)\n                s_log(LOG_ERR, \"Inetd mode: %s\", errstr);\n            else\n                s_log(LOG_ERR, \"Service [%s]: %s\",\n                    (*section_ptr)->servname, errstr);\n            return 1;\n        }\n    }\n    return 0;\n}", "target": 1}
{"code": "YCPBoolean IniAgent::Write(const YCPPath &path, const YCPValue& value, const YCPValue& arg)\n{\n    if (!parser.isStarted())\n    {\n\ty2warning(\"Can't execute Write before being mounted.\");\n\treturn YCPBoolean (false);\n    }\n    bool ok = false; \n    YCPBoolean b (true);\n    if (0 == path->length ())\n    {\n\tif (value->isString() && value->asString()->value() == \"force\")\n\t    parser.inifile.setDirty();\n\telse if (value->isString () && value->asString()->value() == \"clean\")\n\t    parser.inifile.clean ();\n\tif (0 != parser.write ())\n\t    b = false;\n\tok = true;\n    }\n    else\n    {\n\tif (( parser.repeatNames () && value->isList ()) ||\n\t    (!parser.repeatNames () &&  (value->isString () || value->isInteger())) ||\n\t    path->component_str(0) == \"all\"\n\t    )\n\t    {\n\t\tok = true;\n\t\tif (parser.inifile.Write (path, value, parser.HaveRewrites ()))\n\t\t    b = false;\n\t    }\n        else if (value->isVoid ())\n\t    {\n\t\tint wb  = -1;\n\t\tstring del_sec = \"\";\n\t\tok = true;\n\t\tif (2 == path->length ())\n\t\t{\n\t\t    string pc = path->component_str(0);\n\t\t    if (\"s\" == pc || \"section\" == pc)\n\t\t    {\t\n\t\t\tdel_sec = path->component_str (1);\n\t\t\twb = parser.inifile.getSubSectionRewriteBy (del_sec.c_str());\n\t\t    }\n\t\t}\n\t\tif (parser.inifile.Delete (path))\n\t\t    b = false;\n\t\telse if (del_sec != \"\")\n\t\t{\n\t\t    parser.deleted_sections.insert (parser.getFileName (del_sec, wb));\n\t\t}\n\t    }\n\telse\n\t{\n\t    ycp2error (\"Wrong value for path %s: %s\", path->toString ().c_str (), value->toString ().c_str ());\n\t    b = false;\n\t}\n    }\n    if (!ok)\n    {\n    \tycp2error ( \"Wrong path '%s' in Write().\", path->toString().c_str () );\n    }\n    return b;\n}", "target": 1}
{"code": "PHP_FUNCTION(mb_ereg_search_setpos)\n{\n\tlong position;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &position) == FAILURE) {\n\t\treturn;\n\t}\n\tif (position < 0 || (MBREX(search_str) != NULL && Z_TYPE_P(MBREX(search_str)) == IS_STRING && position >= Z_STRLEN_P(MBREX(search_str)))) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Position is out of range\");\n\t\tMBREX(search_pos) = 0;\n\t\tRETURN_FALSE;\n\t}\n\tMBREX(search_pos) = position;\n\tRETURN_TRUE;\n}", "target": 0}
{"code": "static int hmac_create(struct crypto_template *tmpl, struct rtattr **tb)\n{\n\tstruct shash_instance *inst;\n\tstruct crypto_alg *alg;\n\tstruct shash_alg *salg;\n\tint err;\n\tint ds;\n\tint ss;\n\terr = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_SHASH);\n\tif (err)\n\t\treturn err;\n\tsalg = shash_attr_alg(tb[1], 0, 0);\n\tif (IS_ERR(salg))\n\t\treturn PTR_ERR(salg);\n\terr = -EINVAL;\n\tds = salg->digestsize;\n\tss = salg->statesize;\n\talg = &salg->base;\n\tif (ds > alg->cra_blocksize ||\n\t    ss < alg->cra_blocksize)\n\t\tgoto out_put_alg;\n\tinst = shash_alloc_instance(\"hmac\", alg);\n\terr = PTR_ERR(inst);\n\tif (IS_ERR(inst))\n\t\tgoto out_put_alg;\n\terr = crypto_init_shash_spawn(shash_instance_ctx(inst), salg,\n\t\t\t\t      shash_crypto_instance(inst));\n\tif (err)\n\t\tgoto out_free_inst;\n\tinst->alg.base.cra_priority = alg->cra_priority;\n\tinst->alg.base.cra_blocksize = alg->cra_blocksize;\n\tinst->alg.base.cra_alignmask = alg->cra_alignmask;\n\tss = ALIGN(ss, alg->cra_alignmask + 1);\n\tinst->alg.digestsize = ds;\n\tinst->alg.statesize = ss;\n\tinst->alg.base.cra_ctxsize = sizeof(struct hmac_ctx) +\n\t\t\t\t     ALIGN(ss * 2, crypto_tfm_ctx_alignment());\n\tinst->alg.base.cra_init = hmac_init_tfm;\n\tinst->alg.base.cra_exit = hmac_exit_tfm;\n\tinst->alg.init = hmac_init;\n\tinst->alg.update = hmac_update;\n\tinst->alg.final = hmac_final;\n\tinst->alg.finup = hmac_finup;\n\tinst->alg.export = hmac_export;\n\tinst->alg.import = hmac_import;\n\tinst->alg.setkey = hmac_setkey;\n\terr = shash_register_instance(tmpl, inst);\n\tif (err) {\nout_free_inst:\n\t\tshash_free_instance(shash_crypto_instance(inst));\n\t}\nout_put_alg:\n\tcrypto_mod_put(alg);\n\treturn err;\n}", "target": 1}
{"code": "R_API bool r_crbtree_insert(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree && data && cmp, false);\n\tbool inserted = false;\n\tif (tree->root == NULL) {\n\t\ttree->root = _node_new (data, NULL);\n\t\tif (tree->root == NULL) {\n\t\t\treturn false;\n\t\t}\n\t\tinserted = true;\n\t\tgoto out_exit;\n\t}\n\tRRBNode head; \n\tmemset (&head, 0, sizeof (RRBNode));\n\tRRBNode *g = NULL, *parent = &head; \n\tRRBNode *p = NULL, *q = tree->root; \n\tint dir = 0, last = 0; \n\t_set_link (parent, q, 1);\n\tfor (;;) {\n\t\tif (!q) {\n\t\t\tq = _node_new (data, p);\n\t\t\tif (!q) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tp->link[dir] = q;\n\t\t\tinserted = true;\n\t\t} else if (IS_RED (q->link[0]) && IS_RED (q->link[1])) {\n\t\t\tq->red = 1;\n\t\t\tq->link[0]->red = 0;\n\t\t\tq->link[1]->red = 0;\n\t\t}\n\t\tif (IS_RED (q) && IS_RED (p)) {\n#if 0\n\t\t\tif (!parent) {\n\t\t\t\treturn false;\n\t\t\t}\n#endif\n\t\t\tint dir2 = parent->link[1] == g;\n\t\t\tif (q == p->link[last]) {\n\t\t\t\t_set_link (parent, _rot_once (g, !last), dir2);\n\t\t\t} else {\n\t\t\t\t_set_link (parent, _rot_twice (g, !last), dir2);\n\t\t\t}\n\t\t}\n\t\tif (inserted) {\n\t\t\tbreak;\n\t\t}\n\t\tlast = dir;\n\t\tdir = cmp (data, q->data, user) >= 0;\n\t\tif (g) {\n\t\t\tparent = g;\n\t\t}\n\t\tg = p;\n\t\tp = q;\n\t\tq = q->link[dir];\n\t}\n\ttree->root = head.link[1];\nout_exit:\n\ttree->root->red = 0;\n\ttree->root->parent = NULL;\n\tif (inserted) {\n\t\ttree->size++;\n\t}\n\treturn inserted;\n}", "target": 1}
{"code": "void Huff_Compress(msg_t *mbuf, int offset) {\n\tint\t\t\ti, ch, size;\n\tbyte\t\tseq[65536];\n\tbyte*\t\tbuffer;\n\thuff_t\t\thuff;\n\tsize = mbuf->cursize - offset;\n\tbuffer = mbuf->data+ + offset;\n\tif (size<=0) {\n\t\treturn;\n\t}\n\tCom_Memset(&huff, 0, sizeof(huff_t));\n\thuff.tree = huff.lhead = huff.loc[NYT] =  &(huff.nodeList[huff.blocNode++]);\n\thuff.tree->symbol = NYT;\n\thuff.tree->weight = 0;\n\thuff.lhead->next = huff.lhead->prev = NULL;\n\thuff.tree->parent = huff.tree->left = huff.tree->right = NULL;\n\tseq[0] = (size>>8);\n\tseq[1] = size&0xff;\n\tbloc = 16;\n\tfor (i=0; i<size; i++ ) {\n\t\tch = buffer[i];\n\t\tHuff_transmit(&huff, ch, seq);\t\t\t\t\t\t\n\t\tHuff_addRef(&huff, (byte)ch);\t\t\t\t\t\t\t\t\n\t}\n\tbloc += 8;\t\t\t\t\t\t\t\t\t\t\t\t\n\tmbuf->cursize = (bloc>>3) + offset;\n\tCom_Memcpy(mbuf->data+offset, seq, (bloc>>3));\n}", "target": 1}
{"code": "static int ssl_parse_server_psk_hint( mbedtls_ssl_context *ssl,\n                                      unsigned char **p,\n                                      unsigned char *end )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n    size_t  len;\n    ((void) ssl);\n    if( (*p) > end - 2 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                    \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n    len = (*p)[0] << 8 | (*p)[1];\n    *p += 2;\n    if( (*p) + len > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                    \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n    *p += len;\n    ret = 0;\n    return( ret );\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, NaturalSortAndHint) {\n    addIndex(BSON(\"x\" << 1));\n    runQuerySortHint(fromjson(\"{x: {$exists: true}}\"), BSON(\"$natural\" << -1), BSONObj());\n    assertNumSolutions(1U);\n    assertSolutionExists(\"{cscan: {dir: -1}}\");\n    runQuerySortHint(fromjson(\"{x: {$exists: true}}\"), BSON(\"$natural\" << 1), BSONObj());\n    assertNumSolutions(1U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    runQuerySortHint(\n        fromjson(\"{x: {$exists: true}}\"), BSON(\"$natural\" << -1), BSON(\"$natural\" << -1));\n    assertNumSolutions(1U);\n    assertSolutionExists(\"{cscan: {dir: -1}}\");\n    runQuerySortHint(\n        fromjson(\"{x: {$exists: true}}\"), BSON(\"$natural\" << 1), BSON(\"$natural\" << 1));\n    assertNumSolutions(1U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    runQuerySortHint(BSONObj(), BSON(\"$natural\" << -1), BSONObj());\n    assertNumSolutions(1U);\n    assertSolutionExists(\"{cscan: {dir: -1}}\");\n    runQuerySortHint(BSONObj(), BSON(\"$natural\" << 1), BSONObj());\n    assertNumSolutions(1U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    runQuerySortHint(BSONObj(), BSON(\"$natural\" << -1), BSON(\"$natural\" << -1));\n    assertNumSolutions(1U);\n    assertSolutionExists(\"{cscan: {dir: -1}}\");\n    runQuerySortHint(BSONObj(), BSON(\"$natural\" << 1), BSON(\"$natural\" << 1));\n    assertNumSolutions(1U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n}", "target": 0}
{"code": "static int ext4_writepage(struct page *page,\n\t\t\t  struct writeback_control *wbc)\n{\n\tint ret = 0;\n\tloff_t size;\n\tunsigned int len;\n\tstruct buffer_head *page_bufs;\n\tstruct inode *inode = page->mapping->host;\n\ttrace_ext4_writepage(inode, page);\n\tsize = i_size_read(inode);\n\tif (page->index == size >> PAGE_CACHE_SHIFT)\n\t\tlen = size & ~PAGE_CACHE_MASK;\n\telse\n\t\tlen = PAGE_CACHE_SIZE;\n\tif (page_has_buffers(page)) {\n\t\tpage_bufs = page_buffers(page);\n\t\tif (walk_page_buffers(NULL, page_bufs, 0, len, NULL,\n\t\t\t\t\text4_bh_delay_or_unwritten)) {\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tunlock_page(page);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tret = block_prepare_write(page, 0, len,\n\t\t\t\t\t  noalloc_get_block_write);\n\t\tif (!ret) {\n\t\t\tpage_bufs = page_buffers(page);\n\t\t\tif (walk_page_buffers(NULL, page_bufs, 0, len, NULL,\n\t\t\t\t\t\text4_bh_delay_or_unwritten)) {\n\t\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\t\tunlock_page(page);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tunlock_page(page);\n\t\t\treturn 0;\n\t\t}\n\t\tblock_commit_write(page, 0, len);\n\t}\n\tif (PageChecked(page) && ext4_should_journal_data(inode)) {\n\t\tClearPageChecked(page);\n\t\treturn __ext4_journalled_writepage(page, len);\n\t}\n\tif (test_opt(inode->i_sb, NOBH) && ext4_should_writeback_data(inode))\n\t\tret = nobh_writepage(page, noalloc_get_block_write, wbc);\n\telse\n\t\tret = block_write_full_page(page, noalloc_get_block_write,\n\t\t\t\t\t    wbc);\n\treturn ret;\n}", "target": 1}
{"code": "snmp_engine_get(snmp_header_t *header, snmp_varbind_t *varbinds, uint32_t varbinds_length)\n{\n  snmp_mib_resource_t *resource;\n  uint32_t i;\n  for(i = 0; i < varbinds_length; i++) {\n    resource = snmp_mib_find(varbinds[i].oid);\n    if(!resource) {\n      switch(header->version) {\n      case SNMP_VERSION_1:\n        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n        header->error_index_max_repetitions.error_index = i + 1;\n        break;\n      case SNMP_VERSION_2C:\n        (&varbinds[i])->value_type = SNMP_DATA_TYPE_NO_SUCH_INSTANCE;\n        break;\n      default:\n        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n        header->error_index_max_repetitions.error_index = 0;\n      }\n    } else {\n      resource->handler(&varbinds[i], resource->oid);\n    }\n  }\n  return 0;\n}", "target": 1}
{"code": "static int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tstruct sk_buff *supp_skb;\n\tif (hdr->sadb_msg_satype > SADB_SATYPE_MAX)\n\t\treturn -EINVAL;\n\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) {\n\t\tif (pfk->registered&(1<<hdr->sadb_msg_satype))\n\t\t\treturn -EEXIST;\n\t\tpfk->registered |= (1<<hdr->sadb_msg_satype);\n\t}\n\tmutex_lock(&pfkey_mutex);\n\txfrm_probe_algs();\n\tsupp_skb = compose_sadb_supported(hdr, GFP_KERNEL | __GFP_ZERO);\n\tmutex_unlock(&pfkey_mutex);\n\tif (!supp_skb) {\n\t\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC)\n\t\t\tpfk->registered &= ~(1<<hdr->sadb_msg_satype);\n\t\treturn -ENOBUFS;\n\t}\n\tpfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk,\n\t\t\tsock_net(sk));\n\treturn 0;\n}", "target": 0}
{"code": "static int config_req_handler(void *arg)\n{\n\tprintf(\"requesing config\\n\");\n\treturn rest_request(NULL, engine_get_restcli(engine), 0,\n\t\t\t    \"GET\", cfg_resp_handler, NULL,\n\t\t\t    \"/calls/config/v2\", NULL);\n}", "target": 0}
{"code": "static pj_status_t pjsip_auth_verify( const pjsip_authorization_hdr *hdr,\n\t\t\t\t      const pj_str_t *method,\n\t\t\t\t      const pjsip_cred_info *cred_info )\n{\n    if (pj_stricmp(&hdr->scheme, &pjsip_DIGEST_STR) == 0) {\n\tchar digest_buf[PJSIP_MD5STRLEN];\n\tpj_str_t digest;\n\tconst pjsip_digest_credential *dig = &hdr->credential.digest;\n\tPJ_ASSERT_RETURN(pj_strcmp(&dig->username, &cred_info->username) == 0,\n\t\t\t PJ_EINVALIDOP);\n\tPJ_ASSERT_RETURN(pj_strcmp(&dig->realm, &cred_info->realm) == 0,\n\t\t\t PJ_EINVALIDOP);\n\tdigest.ptr = digest_buf;\n\tdigest.slen = PJSIP_MD5STRLEN;\n\tpjsip_auth_create_digest(&digest, \n\t\t\t\t &hdr->credential.digest.nonce,\n\t\t\t\t &hdr->credential.digest.nc, \n\t\t\t\t &hdr->credential.digest.cnonce,\n\t\t\t\t &hdr->credential.digest.qop,\n\t\t\t\t &hdr->credential.digest.uri,\n\t\t\t\t &cred_info->realm,\n\t\t\t\t cred_info, \n\t\t\t\t method );\n\treturn (pj_stricmp(&digest, &hdr->credential.digest.response) == 0) ?\n\t       PJ_SUCCESS : PJSIP_EAUTHINVALIDDIGEST;\n    } else {\n\tpj_assert(!\"Unsupported authentication scheme\");\n\treturn PJSIP_EINVALIDAUTHSCHEME;\n    }\n}", "target": 1}
{"code": "cib_connect(gboolean full)\n{\n    int rc = pcmk_ok;\n    static gboolean need_pass = TRUE;\n    CRM_CHECK(cib != NULL, return -EINVAL);\n    if (getenv(\"CIB_passwd\") != NULL) {\n        need_pass = FALSE;\n    }\n    if(watch_fencing && st == NULL) {\n        st = stonith_api_new();\n    }\n    if(watch_fencing && st->state == stonith_disconnected) {\n        crm_trace(\"Connecting to stonith\");\n        rc = st->cmds->connect(st, crm_system_name, NULL);\n        if(rc == pcmk_ok) {\n            crm_trace(\"Setting up stonith callbacks\");\n            st->cmds->register_notification(st, T_STONITH_NOTIFY_FENCE, mon_st_callback);\n        }\n    }\n    if (cib->state != cib_connected_query && cib->state != cib_connected_command) {\n        crm_trace(\"Connecting to the CIB\");\n        if (as_console && need_pass && cib->variant == cib_remote) {\n            need_pass = FALSE;\n            print_as(\"Password:\");\n        }\n        rc = cib->cmds->signon(cib, crm_system_name, cib_query);\n        if (rc != pcmk_ok) {\n            return rc;\n        }\n        current_cib = get_cib_copy(cib);\n        mon_refresh_display(NULL);\n        if (full) {\n            if (rc == pcmk_ok) {\n                rc = cib->cmds->set_connection_dnotify(cib, mon_cib_connection_destroy);\n                if (rc == -EPROTONOSUPPORT) {\n                    print_as(\"Notification setup failed, won't be able to reconnect after failure\");\n                    if (as_console) {\n                        sleep(2);\n                    }\n                    rc = pcmk_ok;\n                }\n            }\n            if (rc == pcmk_ok) {\n                cib->cmds->del_notify_callback(cib, T_CIB_DIFF_NOTIFY, crm_diff_update);\n                rc = cib->cmds->add_notify_callback(cib, T_CIB_DIFF_NOTIFY, crm_diff_update);\n            }\n            if (rc != pcmk_ok) {\n                print_as(\"Notification setup failed, could not monitor CIB actions\");\n                if (as_console) {\n                    sleep(2);\n                }\n                clean_up(-rc);\n            }\n        }\n    }\n    return rc;\n}", "target": 1}
{"code": "static void process_request(struct connection *conn) {\n    num_requests++;\n    if (!parse_request(conn)) {\n        default_reply(conn, 400, \"Bad Request\",\n            \"You sent a request that the server couldn't understand.\");\n    }\n    else if (is_https_redirect(conn)) {\n        redirect_https(conn);\n    }\n    else if (auth_key != NULL &&\n            (conn->authorization == NULL ||\n             strcmp(conn->authorization, auth_key)))\n    {\n        default_reply(conn, 401, \"Unauthorized\",\n            \"Access denied due to invalid credentials.\");\n    }\n    else if (strcmp(conn->method, \"GET\") == 0) {\n        process_get(conn);\n    }\n    else if (strcmp(conn->method, \"HEAD\") == 0) {\n        process_get(conn);\n        conn->header_only = 1;\n    }\n    else {\n        default_reply(conn, 501, \"Not Implemented\",\n                      \"The method you specified is not implemented.\");\n    }\n    conn->state = SEND_HEADER;\n    free(conn->request);\n    conn->request = NULL; \n}", "target": 1}
{"code": "static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tstruct userfaultfd_ctx *release_new_ctx;\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\trelease_new_ctx = NULL;\n\tspin_lock(&ctx->event_wqh.lock);\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (READ_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\t\t\t\trelease_new_ctx = new;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\twake_up_poll(&ctx->fd_wqh, EPOLLIN);\n\t\tschedule();\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\n\tif (release_new_ctx) {\n\t\tstruct vm_area_struct *vma;\n\t\tstruct mm_struct *mm = release_new_ctx->mm;\n\t\tdown_write(&mm->mmap_sem);\n\t\tVM_WARN_ON(!mmget_still_valid(mm));\n\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next)\n\t\t\tif (vma->vm_userfaultfd_ctx.ctx == release_new_ctx) {\n\t\t\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\t\t\t\tvma->vm_flags &= ~(VM_UFFD_WP | VM_UFFD_MISSING);\n\t\t\t}\n\t\tup_write(&mm->mmap_sem);\n\t\tuserfaultfd_ctx_put(release_new_ctx);\n\t}\nout:\n\tWRITE_ONCE(ctx->mmap_changing, false);\n\tuserfaultfd_ctx_put(ctx);\n}", "target": 0}
{"code": "privsep_preauth(Authctxt *authctxt)\n{\n\tint status, r;\n\tpid_t pid;\n\tstruct ssh_sandbox *box = NULL;\n\tpmonitor = monitor_init();\n\tpmonitor->m_pkex = &active_state->kex;\n\tif (use_privsep == PRIVSEP_ON)\n\t\tbox = ssh_sandbox_init();\n\tpid = fork();\n\tif (pid == -1) {\n\t\tfatal(\"fork of unprivileged child failed\");\n\t} else if (pid != 0) {\n\t\tdebug2(\"Network child is on pid %ld\", (long)pid);\n\t\tpmonitor->m_pid = pid;\n\t\tif (have_agent) {\n\t\t\tr = ssh_get_authentication_socket(&auth_sock);\n\t\t\tif (r != 0) {\n\t\t\t\terror(\"Could not get agent socket: %s\",\n\t\t\t\t    ssh_err(r));\n\t\t\t\thave_agent = 0;\n\t\t\t}\n\t\t}\n\t\tif (box != NULL)\n\t\t\tssh_sandbox_parent_preauth(box, pid);\n\t\tmonitor_child_preauth(authctxt, pmonitor);\n\t\tmonitor_sync(pmonitor);\n\t\twhile (waitpid(pid, &status, 0) < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tpmonitor->m_pid = -1;\n\t\t\tfatal(\"%s: waitpid: %s\", __func__, strerror(errno));\n\t\t}\n\t\tprivsep_is_preauth = 0;\n\t\tpmonitor->m_pid = -1;\n\t\tif (WIFEXITED(status)) {\n\t\t\tif (WEXITSTATUS(status) != 0)\n\t\t\t\tfatal(\"%s: preauth child exited with status %d\",\n\t\t\t\t    __func__, WEXITSTATUS(status));\n\t\t} else if (WIFSIGNALED(status))\n\t\t\tfatal(\"%s: preauth child terminated by signal %d\",\n\t\t\t    __func__, WTERMSIG(status));\n\t\tif (box != NULL)\n\t\t\tssh_sandbox_parent_finish(box);\n\t\treturn 1;\n\t} else {\n\t\tclose(pmonitor->m_sendfd);\n\t\tclose(pmonitor->m_log_recvfd);\n\t\tset_log_handler(mm_log_handler, pmonitor);\n\t\tprivsep_preauth_child();\n\t\tsetproctitle(\"%s\", \"[net]\");\n\t\tif (box != NULL)\n\t\t\tssh_sandbox_child(box);\n\t\treturn 0;\n\t}\n}", "target": 1}
{"code": "void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,\n\t\t    gfp_t gfp, struct dma_attrs *attrs)\n{\n\tpgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);\n\tvoid *memory;\n\tif (dma_alloc_from_coherent(dev, size, handle, &memory))\n\t\treturn memory;\n\treturn __dma_alloc(dev, size, handle, gfp, prot, false,\n\t\t\t   __builtin_return_address(0));\n}", "target": 1}
{"code": "void AsfVideo::decodeHeader() {\n  DataBuf nbHeadersBuf(DWORD + 1);\n  io_->read(nbHeadersBuf.data(), DWORD);\n  uint32_t nb_headers = Exiv2::getULong(nbHeadersBuf.data(), littleEndian);\n  Internal::enforce(nb_headers < std::numeric_limits<uint32_t>::max(), Exiv2::ErrorCode::kerCorruptedMetadata);\n  io_->seekOrThrow(io_->tell() + BYTE * 2, BasicIo::beg,\n                   ErrorCode::kerFailedToReadImageData);  \n  for (uint32_t i = 0; i < nb_headers; i++) {\n    decodeBlock();\n  }\n}", "target": 1}
{"code": "static ssize_t k90_show_macro_mode(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tconst char *macro_mode;\n\tchar data[8];\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_GET_MODE,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 2,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial mode (error %d).\\n\",\n\t\t\t ret);\n\t\treturn -EIO;\n\t}\n\tswitch (data[0]) {\n\tcase K90_MACRO_MODE_HW:\n\t\tmacro_mode = \"HW\";\n\t\tbreak;\n\tcase K90_MACRO_MODE_SW:\n\t\tmacro_mode = \"SW\";\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"K90 in unknown mode: %02hhx.\\n\",\n\t\t\t data[0]);\n\t\treturn -EIO;\n\t}\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", macro_mode);\n}", "target": 1}
{"code": "int bad_format_print(char *fmt){\n    return bad_format_check(\"^\" SAFE_STRING FLOAT_STRING SAFE_STRING \"%s\" SAFE_STRING \"$\",fmt);\n}", "target": 0}
{"code": "static bool max_queue_pairs_gt_1(void *opaque, int version_id)\n{\n    return VIRTIO_NET(opaque)->max_queue_pairs > 1;\n}", "target": 0}
{"code": "list_session(char *log_dir, regex_t *re, const char *user, const char *tty)\n{\n    char idbuf[7], *idstr, *cp;\n    struct eventlog *evlog = NULL;\n    const char *timestr;\n    int ret = -1;\n    debug_decl(list_session, SUDO_DEBUG_UTIL);\n    if ((evlog = iolog_parse_loginfo(-1, log_dir)) == NULL)\n\tgoto done;\n    if (evlog->command == NULL || evlog->submituser == NULL ||\n\t    evlog->runuser == NULL) {\n\tgoto done;\n    }\n    if (!STAILQ_EMPTY(&search_expr) && !match_expr(&search_expr, evlog, true))\n\tgoto done;\n    cp = log_dir + strlen(session_dir) + 1;\n    if (IS_IDLOG(cp)) {\n\tidbuf[0] = cp[0];\n\tidbuf[1] = cp[1];\n\tidbuf[2] = cp[3];\n\tidbuf[3] = cp[4];\n\tidbuf[4] = cp[6];\n\tidbuf[5] = cp[7];\n\tidbuf[6] = '\\0';\n\tidstr = idbuf;\n    } else {\n\tidstr = cp;\n    }\n    timestr = get_timestr(evlog->submit_time.tv_sec, 1);\n    printf(\"%s : %s : \", timestr ? timestr : \"invalid date\", evlog->submituser);\n    if (evlog->submithost != NULL)\n\tprintf(\"HOST=%s ; \", evlog->submithost);\n    if (evlog->ttyname != NULL)\n\tprintf(\"TTY=%s ; \", evlog->ttyname);\n    if (evlog->runchroot != NULL)\n\tprintf(\"CHROOT=%s ; \", evlog->runchroot);\n    if (evlog->runcwd != NULL || evlog->cwd != NULL)\n\tprintf(\"CWD=%s ; \", evlog->runcwd ? evlog->runcwd : evlog->cwd);\n    printf(\"USER=%s ; \", evlog->runuser);\n    if (evlog->rungroup != NULL)\n\tprintf(\"GROUP=%s ; \", evlog->rungroup);\n    printf(\"TSID=%s ; COMMAND=%s\\n\", idstr, evlog->command);\n    ret = 0;\ndone:\n    eventlog_free(evlog);\n    debug_return_int(ret);\n}", "target": 1}
{"code": "static ssize_t generic_perform_write(struct file *file,\n\t\t\t\tstruct iov_iter *i, loff_t pos)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\tconst struct address_space_operations *a_ops = mapping->a_ops;\n\tlong status = 0;\n\tssize_t written = 0;\n\tunsigned int flags = 0;\n\tif (segment_eq(get_fs(), KERNEL_DS))\n\t\tflags |= AOP_FLAG_UNINTERRUPTIBLE;\n\tdo {\n\t\tstruct page *page;\n\t\tpgoff_t index;\t\t\n\t\tunsigned long offset;\t\n\t\tunsigned long bytes;\t\n\t\tsize_t copied;\t\t\n\t\tvoid *fsdata;\n\t\toffset = (pos & (PAGE_CACHE_SIZE - 1));\n\t\tindex = pos >> PAGE_CACHE_SHIFT;\n\t\tbytes = min_t(unsigned long, PAGE_CACHE_SIZE - offset,\n\t\t\t\t\t\tiov_iter_count(i));\nagain:\n\t\tif (unlikely(iov_iter_fault_in_readable(i, bytes))) {\n\t\t\tstatus = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tstatus = a_ops->write_begin(file, mapping, pos, bytes, flags,\n\t\t\t\t\t\t&page, &fsdata);\n\t\tif (unlikely(status))\n\t\t\tbreak;\n\t\tpagefault_disable();\n\t\tcopied = iov_iter_copy_from_user_atomic(page, i, offset, bytes);\n\t\tpagefault_enable();\n\t\tflush_dcache_page(page);\n\t\tstatus = a_ops->write_end(file, mapping, pos, bytes, copied,\n\t\t\t\t\t\tpage, fsdata);\n\t\tif (unlikely(status < 0))\n\t\t\tbreak;\n\t\tcopied = status;\n\t\tcond_resched();\n\t\tif (unlikely(copied == 0)) {\n\t\t\tbytes = min_t(unsigned long, PAGE_CACHE_SIZE - offset,\n\t\t\t\t\t\tiov_iter_single_seg_count(i));\n\t\t\tgoto again;\n\t\t}\n\t\tiov_iter_advance(i, copied);\n\t\tpos += copied;\n\t\twritten += copied;\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t} while (iov_iter_count(i));\n\treturn written ? written : status;\n}", "target": 1}
{"code": "queryin(char *buf)\n{\n\tQPRS_STATE\tstate;\n\tint32\t\ti;\n\tltxtquery  *query;\n\tint32\t\tcommonlen;\n\tITEM\t   *ptr;\n\tNODE\t   *tmp;\n\tint32\t\tpos = 0;\n#ifdef BS_DEBUG\n\tchar\t\tpbuf[16384],\n\t\t\t   *cur;\n#endif\n\tstate.buf = buf;\n\tstate.state = WAITOPERAND;\n\tstate.count = 0;\n\tstate.num = 0;\n\tstate.str = NULL;\n\tstate.sumlen = 0;\n\tstate.lenop = 64;\n\tstate.curop = state.op = (char *) palloc(state.lenop);\n\t*(state.curop) = '\\0';\n\tmakepol(&state);\n\tif (!state.num)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t errmsg(\"syntax error\"),\n\t\t\t\t errdetail(\"Empty query.\")));\n\tcommonlen = COMPUTESIZE(state.num, state.sumlen);\n\tquery = (ltxtquery *) palloc(commonlen);\n\tSET_VARSIZE(query, commonlen);\n\tquery->size = state.num;\n\tptr = GETQUERY(query);\n\tfor (i = 0; i < state.num; i++)\n\t{\n\t\tptr[i].type = state.str->type;\n\t\tptr[i].val = state.str->val;\n\t\tptr[i].distance = state.str->distance;\n\t\tptr[i].length = state.str->length;\n\t\tptr[i].flag = state.str->flag;\n\t\ttmp = state.str->next;\n\t\tpfree(state.str);\n\t\tstate.str = tmp;\n\t}\n\tmemcpy((void *) GETOPERAND(query), (void *) state.op, state.sumlen);\n\tpfree(state.op);\n\tpos = 0;\n\tfindoprnd(ptr, &pos);\n\treturn query;\n}", "target": 1}
{"code": "raw_copy_to_user(void __user *dst, const void *src, unsigned long size)\n{\n\tint ret = 0;\n\tif (!__builtin_constant_p(size))\n\t\treturn copy_user_generic((__force void *)dst, src, size);\n\tswitch (size) {\n\tcase 1:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u8 *)src, (u8 __user *)dst,\n\t\t\t      ret, \"b\", \"b\", \"iq\", 1);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 2:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u16 *)src, (u16 __user *)dst,\n\t\t\t      ret, \"w\", \"w\", \"ir\", 2);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 4:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u32 *)src, (u32 __user *)dst,\n\t\t\t      ret, \"l\", \"k\", \"ir\", 4);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 8:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u64 *)src, (u64 __user *)dst,\n\t\t\t      ret, \"q\", \"\", \"er\", 8);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 10:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u64 *)src, (u64 __user *)dst,\n\t\t\t       ret, \"q\", \"\", \"er\", 10);\n\t\tif (likely(!ret)) {\n\t\t\tasm(\"\":::\"memory\");\n\t\t\t__put_user_asm(4[(u16 *)src], 4 + (u16 __user *)dst,\n\t\t\t\t       ret, \"w\", \"w\", \"ir\", 2);\n\t\t}\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 16:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u64 *)src, (u64 __user *)dst,\n\t\t\t       ret, \"q\", \"\", \"er\", 16);\n\t\tif (likely(!ret)) {\n\t\t\tasm(\"\":::\"memory\");\n\t\t\t__put_user_asm(1[(u64 *)src], 1 + (u64 __user *)dst,\n\t\t\t\t       ret, \"q\", \"\", \"er\", 8);\n\t\t}\n\t\t__uaccess_end();\n\t\treturn ret;\n\tdefault:\n\t\treturn copy_user_generic((__force void *)dst, src, size);\n\t}\n}", "target": 1}
{"code": "static inline Quantum ScaleLongLongToQuantum(const MagickSizeType value)\n{\n#if !defined(MAGICKCORE_HDRI_SUPPORT)\n  return((Quantum) ((value)/MagickULLConstant(281479271743489)));\n#else\n  return((Quantum) (value/281479271743489.0));\n#endif\n}", "target": 0}
{"code": "int main() {\n  int selftest;\n  MSPACK_SYS_SELFTEST(selftest);\n  TEST(selftest == MSPACK_ERR_OK);\n  kwajd_open_test_01();\n  printf(\"ALL %d TESTS PASSED.\\n\", test_count);\n  return 0;\n}", "target": 0}
{"code": "DownloadProxy* WebProcessProxy::createDownloadProxy()\n{\n#if ENABLE(NETWORK_PROCESS)\n    ASSERT(!m_context->usesNetworkProcess());\n#endif\n    if (!m_downloadProxyMap)\n        m_downloadProxyMap = adoptPtr(new DownloadProxyMap(m_messageReceiverMap));\n    return m_downloadProxyMap->createDownloadProxy(m_context.get());\n}", "target": 0}
{"code": "      BigInt square_mod_order(const BigInt& x) const\n         {\n         return m_mod_order.square(x);\n         }", "target": 0}
{"code": "rpcap_remoteact_getsock(const char *host, int *error, char *errbuf)\n{\n\tstruct activehosts *temp;\t\t\t\n\tstruct addrinfo hints, *addrinfo, *ai_next;\t\n\tint retval;\n\taddrinfo = NULL;\n\tmemset(&hints, 0, sizeof(struct addrinfo));\n\thints.ai_family = PF_UNSPEC;\n\thints.ai_socktype = SOCK_STREAM;\n\tretval = sock_initaddress(host, NULL, &hints, &addrinfo, errbuf,\n\t    PCAP_ERRBUF_SIZE);\n\tif (retval != 0)\n\t{\n\t\t*error = 1;\n\t\treturn NULL;\n\t}\n\ttemp = activeHosts;\n\twhile (temp)\n\t{\n\t\tai_next = addrinfo;\n\t\twhile (ai_next)\n\t\t{\n\t\t\tif (sock_cmpaddr(&temp->host, (struct sockaddr_storage *) ai_next->ai_addr) == 0)\n\t\t\t{\n\t\t\t\t*error = 0;\n\t\t\t\tfreeaddrinfo(addrinfo);\n\t\t\t\treturn temp;\n\t\t\t}\n\t\t\tai_next = ai_next->ai_next;\n\t\t}\n\t\ttemp = temp->next;\n\t}\n\tif (addrinfo)\n\t\tfreeaddrinfo(addrinfo);\n\t*error = 0;\n\treturn NULL;\n}", "target": 1}
{"code": "gfx::Rect OverlayWindowViews::GetVideoBounds() {\n  return video_bounds_;\n}", "target": 0}
{"code": "static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs)\n{\n    FILE *fp = fopen(dest_filename, \"w\");\n    if (!fp)\n        return false;\n    unsigned fd = 0;\n    while (fd <= 99999) \n    {\n        sprintf(source_filename + source_base_ofs, \"fd/%u\", fd);\n        char *name = malloc_readlink(source_filename);\n        if (!name)\n            break;\n        fprintf(fp, \"%u:%s\\n\", fd, name);\n        free(name);\n        sprintf(source_filename + source_base_ofs, \"fdinfo/%u\", fd);\n        fd++;\n        FILE *in = fopen(source_filename, \"r\");\n        if (!in)\n            continue;\n        char buf[128];\n        while (fgets(buf, sizeof(buf)-1, in))\n        {\n            char *eol = strchrnul(buf, '\\n');\n            eol[0] = '\\n';\n            eol[1] = '\\0';\n            fputs(buf, fp);\n        }\n        fclose(in);\n    }\n    fclose(fp);\n    return true;\n}", "target": 1}
{"code": "NOEXPORT char *pgsql_server(CLI *c, SERVICE_OPTIONS *opt, const PHASE phase) {\n    uint8_t buffer[8], ssl_ok[1]={'S'};\n    static const uint8_t gss_request[8]={0, 0, 0, 8, 0x04, 0xd2, 0x16, 0x30};\n    static const uint8_t gss_response[62]=\n        {'E', 0, 0, 0, 61, 'S', 'E', 'R', 'R', 'O', 'R', 0, 'C', 'X', 'X', '0',\n        '0', '0', 0, 'M', 'S', 'S', 'L', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',\n        ' ', 'b', 'u', 't', ' ', 'n', 'o', 't', ' ', 'r', 'e', 'q', 'u', 'e', 's', 't',\n        'e', 'd', ' ', 'b', 'y', ' ', 'c', 'l', 'i', 'e', 'n', 't', 0, 0};\n    (void)opt; \n    if(phase!=PROTOCOL_EARLY)\n        return NULL;\n    s_log(LOG_DEBUG, \"Started server-side psql protcol negotiation\");\n    memset(buffer, 0, sizeof buffer);\n    s_read(c, c->local_rfd.fd, buffer, sizeof buffer);\n    if(!safe_memcmp(buffer, gss_request, sizeof gss_request)) {\n        s_log(LOG_INFO, \"GSSAPI encryption requested, rejecting gracefully\");\n        s_write(c, c->local_wfd.fd, gss_response, sizeof gss_response);\n        throw_exception(c, 2); \n    }\n    if(safe_memcmp(buffer, ssl_request, sizeof ssl_request)) {\n        s_log(LOG_ERR, \"PostgreSQL client did not request TLS, rejecting\");\n        throw_exception(c, 1);\n    }\n    s_log(LOG_DEBUG, \"SSLRequest received\");\n    s_write(c, c->local_wfd.fd, ssl_ok, sizeof ssl_ok);\n    return NULL;\n}", "target": 0}
{"code": "static int open_port(struct inode *inode, struct file *filp)\n{\n\treturn capable(CAP_SYS_RAWIO) ? 0 : -EPERM;\n}", "target": 0}
{"code": "smtp_log_no_mail(void)\n{\nint i;\nuschar * sep, * s;\ngstring * g = NULL;\nif (smtp_mailcmd_count > 0 || !LOGGING(smtp_no_mail))\n  return;\nif (sender_host_authenticated)\n  {\n  g = string_append(g, 2, US\" A=\", sender_host_authenticated);\n  if (authenticated_id) g = string_append(g, 2, US\":\", authenticated_id);\n  }\n#ifdef SUPPORT_TLS\ng = s_tlslog(g);\n#endif\nsep = smtp_connection_had[SMTP_HBUFF_SIZE-1] != SCH_NONE ?  US\" C=...\" : US\" C=\";\nfor (i = smtp_ch_index; i < SMTP_HBUFF_SIZE; i++)\n  if (smtp_connection_had[i] != SCH_NONE)\n    {\n    g = string_append(g, 2, sep, smtp_names[smtp_connection_had[i]]);\n    sep = US\",\";\n    }\nfor (i = 0; i < smtp_ch_index; i++)\n  {\n  g = string_append(g, 2, sep, smtp_names[smtp_connection_had[i]]);\n  sep = US\",\";\n  }\nif (!(s = string_from_gstring(g))) s = US\"\";\nlog_write(0, LOG_MAIN, \"no MAIL in %sSMTP connection from %s D=%s%s\",\n  f.tcp_in_fastopen ? f.tcp_in_fastopen_data ? US\"TFO* \" : US\"TFO \" : US\"\",\n  host_and_ident(FALSE), string_timesince(&smtp_connection_start), s);\n}", "target": 0}
{"code": "static Status ValidateStrides(const T& strides) {\n  for (size_t i = 0; i < strides.size(); ++i) {\n    if (strides[i] <= 0) {\n      return errors::InvalidArgument(\n          \"Sliding window stride field for dimension \", i,\n          \" must be positive but is \", strides[i]);\n    }\n  }\n  return OkStatus();\n}", "target": 0}
{"code": "static int filter_frame(AVFilterLink *inlink, AVFrame *in)\n{\n    AVFilterContext *ctx = inlink->dst;\n    BoxBlurContext *s = ctx->priv;\n    AVFilterLink *outlink = inlink->dst->outputs[0];\n    AVFrame *out;\n    int plane;\n    int cw = FF_CEIL_RSHIFT(inlink->w, s->hsub), ch = FF_CEIL_RSHIFT(in->height, s->vsub);\n    int w[4] = { inlink->w, cw, cw, inlink->w };\n    int h[4] = { in->height, ch, ch, in->height };\n    out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n    if (!out) {\n        av_frame_free(&in);\n        return AVERROR(ENOMEM);\n    }\n    av_frame_copy_props(out, in);\n    for (plane = 0; in->data[plane] && plane < 4; plane++)\n        hblur(out->data[plane], out->linesize[plane],\n              in ->data[plane], in ->linesize[plane],\n              w[plane], h[plane], s->radius[plane], s->power[plane],\n              s->temp);\n    for (plane = 0; in->data[plane] && plane < 4; plane++)\n        vblur(out->data[plane], out->linesize[plane],\n              out->data[plane], out->linesize[plane],\n              w[plane], h[plane], s->radius[plane], s->power[plane],\n              s->temp);\n    av_frame_free(&in);\n    return ff_filter_frame(outlink, out);\n}", "target": 1}
{"code": "static char *decode_text_string(const char *str, size_t str_len)\n{\n    int   idx, is_hex, is_utf16be, ascii_idx;\n    char *ascii, hex_buf[5] = {0};\n    is_hex = is_utf16be = idx = ascii_idx = 0;\n    if (str[0] == '(')\n    {\n        ascii = malloc(strlen(str) + 1);\n        strncpy(ascii, str, strlen(str) + 1);\n        return ascii;\n    }\n    else if (str[0] == '<')\n    {\n        is_hex = 1;\n        ++idx;\n    }\n    if (is_hex && (str_len > 5) && \n        (str[idx] == 'F') && (str[idx+1] == 'E') &&\n        (str[idx+2] == 'F') && (str[idx+3] == 'F'))\n    {\n        is_utf16be = 1;\n        idx += 4;\n    }\n    else\n      return NULL;\n    ascii = malloc(str_len);\n    for ( ; idx<str_len; ++idx)\n    {\n        hex_buf[0] = str[idx++];\n        hex_buf[1] = str[idx++];\n        hex_buf[2] = str[idx++];\n        hex_buf[3] = str[idx];\n        ascii[ascii_idx++] = strtol(hex_buf, NULL, 16);\n    }\n    return ascii;\n}", "target": 1}
{"code": "static ssize_t write_mem(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tphys_addr_t p = *ppos;\n\tssize_t written, sz;\n\tunsigned long copied;\n\tvoid *ptr;\n\tif (p != *ppos)\n\t\treturn -EFBIG;\n\tif (!valid_phys_addr_range(p, count))\n\t\treturn -EFAULT;\n\twritten = 0;\n#ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED\n\tif (p < PAGE_SIZE) {\n\t\tsz = size_inside_page(p, count);\n\t\tbuf += sz;\n\t\tp += sz;\n\t\tcount -= sz;\n\t\twritten += sz;\n\t}\n#endif\n\twhile (count > 0) {\n\t\tsz = size_inside_page(p, count);\n\t\tif (!range_is_allowed(p >> PAGE_SHIFT, sz))\n\t\t\treturn -EPERM;\n\t\tptr = xlate_dev_mem_ptr(p);\n\t\tif (!ptr) {\n\t\t\tif (written)\n\t\t\t\tbreak;\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tcopied = copy_from_user(ptr, buf, sz);\n\t\tunxlate_dev_mem_ptr(p, ptr);\n\t\tif (copied) {\n\t\t\twritten += sz - copied;\n\t\t\tif (written)\n\t\t\t\tbreak;\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tbuf += sz;\n\t\tp += sz;\n\t\tcount -= sz;\n\t\twritten += sz;\n\t}\n\t*ppos += written;\n\treturn written;\n}", "target": 1}
{"code": "void HTTPSession::onCertificate(uint16_t certId,\n                                std::unique_ptr<IOBuf> authenticator) {\n  DestructorGuard dg(this);\n  VLOG(4) << \"CERTIFICATE on\" << *this << \", certId=\" << certId;\n  if (!secondAuthManager_) {\n    return;\n  }\n  bool isValid = false;\n  auto fizzBase = getTransport()->getUnderlyingTransport<AsyncFizzBase>();\n  if (fizzBase) {\n    if (isUpstream()) {\n      isValid = secondAuthManager_->validateAuthenticator(\n          *fizzBase,\n          TransportDirection::UPSTREAM,\n          certId,\n          std::move(authenticator));\n    } else {\n      isValid = secondAuthManager_->validateAuthenticator(\n          *fizzBase,\n          TransportDirection::DOWNSTREAM,\n          certId,\n          std::move(authenticator));\n    }\n  } else {\n    VLOG(4) << \"Underlying transport does not support secondary \"\n               \"authentication.\";\n    return;\n  }\n  if (isValid) {\n    VLOG(4) << \"Successfully validated the authenticator provided by the peer.\";\n  } else {\n    VLOG(4) << \"Failed to validate the authenticator provided by the peer\";\n  }\n}", "target": 0}
{"code": "SYSCALL_DEFINE5(add_key, const char __user *, _type,\n\t\tconst char __user *, _description,\n\t\tconst void __user *, _payload,\n\t\tsize_t, plen,\n\t\tkey_serial_t, ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tchar type[32], *description;\n\tvoid *payload;\n\tlong ret;\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\tret = key_get_type_from_user(type, _type, sizeof(type));\n\tif (ret < 0)\n\t\tgoto error;\n\tdescription = NULL;\n\tif (_description) {\n\t\tdescription = strndup_user(_description, KEY_MAX_DESC_SIZE);\n\t\tif (IS_ERR(description)) {\n\t\t\tret = PTR_ERR(description);\n\t\t\tgoto error;\n\t\t}\n\t\tif (!*description) {\n\t\t\tkfree(description);\n\t\t\tdescription = NULL;\n\t\t} else if ((description[0] == '.') &&\n\t\t\t   (strncmp(type, \"keyring\", 7) == 0)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto error2;\n\t\t}\n\t}\n\tpayload = NULL;\n\tif (_payload) {\n\t\tret = -ENOMEM;\n\t\tpayload = kvmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error2;\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error3;\n\t}\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error3;\n\t}\n\tkey_ref = key_create_or_update(keyring_ref, type, description,\n\t\t\t\t       payload, plen, KEY_PERM_UNDEF,\n\t\t\t\t       KEY_ALLOC_IN_QUOTA);\n\tif (!IS_ERR(key_ref)) {\n\t\tret = key_ref_to_ptr(key_ref)->serial;\n\t\tkey_ref_put(key_ref);\n\t}\n\telse {\n\t\tret = PTR_ERR(key_ref);\n\t}\n\tkey_ref_put(keyring_ref);\n error3:\n\tkvfree(payload);\n error2:\n\tkfree(description);\n error:\n\treturn ret;\n}", "target": 1}
{"code": "njs_module_path(njs_vm_t *vm, const njs_str_t *dir, njs_module_info_t *info)\n{\n    char        *p;\n    size_t      length;\n    njs_bool_t  trail;\n    char        src[NJS_MAX_PATH + 1];\n    trail = 0;\n    length = info->name.length;\n    if (dir != NULL) {\n        length = dir->length;\n        if (length == 0) {\n            return NJS_DECLINED;\n        }\n        trail = (dir->start[dir->length - 1] != '/');\n        if (trail) {\n            length++;\n        }\n    }\n    if (njs_slow_path(length > NJS_MAX_PATH)) {\n        return NJS_ERROR;\n    }\n    p = &src[0];\n    if (dir != NULL) {\n        p = (char *) njs_cpymem(p, dir->start, dir->length);\n        if (trail) {\n            *p++ = '/';\n        }\n    }\n    p = (char *) njs_cpymem(p, info->name.start, info->name.length);\n    *p = '\\0';\n    p = realpath(&src[0], &info->path[0]);\n    if (p == NULL) {\n        return NJS_DECLINED;\n    }\n    info->fd = open(&info->path[0], O_RDONLY);\n    if (info->fd < 0) {\n        return NJS_DECLINED;\n    }\n    info->file.start = (u_char *) &info->path[0];\n    info->file.length = njs_strlen(info->file.start);\n    return NJS_OK;\n}", "target": 1}
{"code": "static void show_object(struct object *object, struct strbuf *path,\n\t\t\tconst char *last, void *data)\n{\n\tstruct bitmap *base = data;\n\tint bitmap_pos;\n\tbitmap_pos = bitmap_position(object->oid.hash);\n\tif (bitmap_pos < 0) {\n\t\tchar *name = path_name(path, last);\n\t\tbitmap_pos = ext_index_add_object(object, name);\n\t\tfree(name);\n\t}\n\tbitmap_set(base, bitmap_pos);\n}", "target": 1}
{"code": "void die_upon_dubious_ownership(const char *gitfile, const char *worktree,\n\t\t\t\tconst char *gitdir)\n{\n\tstruct strbuf report = STRBUF_INIT, quoted = STRBUF_INIT;\n\tconst char *path;\n\tif (ensure_valid_ownership(gitfile, worktree, gitdir, &report))\n\t\treturn;\n\tstrbuf_complete(&report, '\\n');\n\tpath = gitfile ? gitfile : gitdir;\n\tsq_quote_buf_pretty(&quoted, path);\n\tdie(_(\"detected dubious ownership in repository at '%s'\\n\"\n\t      \"%s\"\n\t      \"To add an exception for this directory, call:\\n\"\n\t      \"\\n\"\n\t      \"\\tgit config --global --add safe.directory %s\"),\n\t    path, report.buf, quoted.buf);\n}", "target": 0}
{"code": "static void xml_parser_dtor(zend_rsrc_list_entry *rsrc TSRMLS_DC)\n{\n\txml_parser *parser = (xml_parser *)rsrc->ptr;\n\tif (parser->parser) {\n\t\tXML_ParserFree(parser->parser);\n\t}\n\tif (parser->ltags) {\n\t\tint inx;\n\t\tfor (inx = 0; ((inx < parser->level) && (inx < XML_MAXLEVEL)); inx++)\n\t\t\tefree(parser->ltags[ inx ]);\n\t\tefree(parser->ltags);\n\t}\n\tif (parser->startElementHandler) {\n\t\tzval_ptr_dtor(&parser->startElementHandler);\n\t}\n\tif (parser->endElementHandler) {\n\t\tzval_ptr_dtor(&parser->endElementHandler);\n\t}\n\tif (parser->characterDataHandler) {\n\t\tzval_ptr_dtor(&parser->characterDataHandler);\n\t}\n\tif (parser->processingInstructionHandler) {\n\t\tzval_ptr_dtor(&parser->processingInstructionHandler);\n\t}\n\tif (parser->defaultHandler) {\n\t\tzval_ptr_dtor(&parser->defaultHandler);\n\t}\n\tif (parser->unparsedEntityDeclHandler) {\n\t\tzval_ptr_dtor(&parser->unparsedEntityDeclHandler);\n\t}\n\tif (parser->notationDeclHandler) {\n\t\tzval_ptr_dtor(&parser->notationDeclHandler);\n\t}\n\tif (parser->externalEntityRefHandler) {\n\t\tzval_ptr_dtor(&parser->externalEntityRefHandler);\n\t}\n\tif (parser->unknownEncodingHandler) {\n\t\tzval_ptr_dtor(&parser->unknownEncodingHandler);\n\t}\n\tif (parser->startNamespaceDeclHandler) {\n\t\tzval_ptr_dtor(&parser->startNamespaceDeclHandler);\n\t}\n\tif (parser->endNamespaceDeclHandler) {\n\t\tzval_ptr_dtor(&parser->endNamespaceDeclHandler);\n\t}\n\tif (parser->baseURI) {\n\t\tefree(parser->baseURI);\n\t}\n\tif (parser->object) {\n\t\tzval_ptr_dtor(&parser->object);\n\t}\n\tefree(parser);\n}", "target": 0}
{"code": "static int check_symlink(int fd)\n{\n\tstruct stat sb;\n\tint ret = fstat(fd, &sb);\n\tif (ret < 0)\n\t\treturn -ENOENT;\n\tif (S_ISLNK(sb.st_mode))\n\t\treturn -ELOOP;\n\treturn 0;\n}", "target": 0}
{"code": "void PrintWebViewHelper::DidFinishPrinting(PrintingResult result) {\n  switch (result) {\n    case OK:\n      break;\n    case FAIL_PRINT_INIT:\n      DCHECK(!notify_browser_of_print_failure_);\n      break;\n    case FAIL_PRINT:\n      if (notify_browser_of_print_failure_ && print_pages_params_) {\n        int cookie = print_pages_params_->params.document_cookie;\n        Send(new PrintHostMsg_PrintingFailed(routing_id(), cookie));\n      }\n      break;\n    case FAIL_PREVIEW:\n      int cookie =\n          print_pages_params_ ? print_pages_params_->params.document_cookie : 0;\n      if (notify_browser_of_print_failure_) {\n        LOG(ERROR) << \"CreatePreviewDocument failed\";\n        Send(new PrintHostMsg_PrintPreviewFailed(routing_id(), cookie));\n      } else {\n        Send(new PrintHostMsg_PrintPreviewCancelled(routing_id(), cookie));\n      }\n      print_preview_context_.Failed(notify_browser_of_print_failure_);\n      break;\n  }\n  prep_frame_view_.reset();\n  print_pages_params_.reset();\n  notify_browser_of_print_failure_ = true;\n}", "target": 0}
{"code": "static inline bool crypto_shash_alg_has_setkey(struct shash_alg *alg)\n{\n\treturn alg->setkey != shash_no_setkey;\n}", "target": 0}
{"code": "void HTMLSelectElement::dispatchFocusEvent(Element* oldFocusedElement, FocusDirection direction)\n{\n    if (usesMenuList())\n        saveLastSelection();\n    HTMLFormControlElementWithState::dispatchFocusEvent(oldFocusedElement, direction);\n}", "target": 0}
{"code": "static int on_version_message(struct nvnc_client* client)\n{\n\tstruct nvnc* server = client->server;\n\tif (client->buffer_len - client->buffer_index < 12)\n\t\treturn 0;\n\tchar version_string[13];\n\tmemcpy(version_string, client->msg_buffer + client->buffer_index, 12);\n\tversion_string[12] = '\\0';\n\tif (strcmp(RFB_VERSION_MESSAGE, version_string) != 0)\n\t\treturn handle_unsupported_version(client);\n\tuint8_t buf[sizeof(struct rfb_security_types_msg) +\n\t\tSECURITY_TYPES_MAX] = {};\n\tstruct rfb_security_types_msg* security =\n\t\t(struct rfb_security_types_msg*)buf;\n\tsecurity->n = 0;\n\tif (server->auth_flags & NVNC_AUTH_REQUIRE_AUTH) {\n\t\tassert(server->auth_fn);\n#ifdef ENABLE_TLS\n\t\tif (server->tls_creds) {\n\t\t\tsecurity->types[security->n++] = RFB_SECURITY_TYPE_VENCRYPT;\n\t\t}\n#endif\n#ifdef HAVE_CRYPTO\n\t\tsecurity->types[security->n++] = RFB_SECURITY_TYPE_RSA_AES256;\n\t\tsecurity->types[security->n++] = RFB_SECURITY_TYPE_RSA_AES;\n\t\tif (!(server->auth_flags & NVNC_AUTH_REQUIRE_ENCRYPTION)) {\n\t\t\tsecurity->types[security->n++] = RFB_SECURITY_TYPE_APPLE_DH;\n\t\t}\n#endif\n\t} else {\n\t\tsecurity->n = 1;\n\t\tsecurity->types[0] = RFB_SECURITY_TYPE_NONE;\n\t}\n\tif (security->n == 0) {\n\t\tnvnc_log(NVNC_LOG_PANIC, \"Failed to satisfy requested security constraints\");\n\t}\n\tstream_write(client->net_stream, security, sizeof(*security) +\n\t\t\tsecurity->n, NULL, NULL);\n\tclient->state = VNC_CLIENT_STATE_WAITING_FOR_SECURITY;\n\treturn 12;\n}", "target": 1}
{"code": "u64 secure_dccp_sequence_number(__be32 saddr, __be32 daddr,\n\t\t\t\t__be16 sport, __be16 dport)\n{\n\tu64 seq;\n\t__u32 hash[4];\n\tstruct keydata *keyptr = get_keyptr();\n\thash[0] = (__force u32)saddr;\n\thash[1] = (__force u32)daddr;\n\thash[2] = ((__force u16)sport << 16) + (__force u16)dport;\n\thash[3] = keyptr->secret[11];\n\tseq = half_md4_transform(hash, keyptr->secret);\n\tseq |= ((u64)keyptr->count) << (32 - HASH_BITS);\n\tseq += ktime_to_ns(ktime_get_real());\n\tseq &= (1ull << 48) - 1;\n\treturn seq;\n}", "target": 1}
{"code": "static TEE_Result do_alloc_keypair(struct rsa_keypair *s,\n\t\t\t\t   size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->e))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->d))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->n))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->p))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->q))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->qp))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->dp))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->dq))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->e);\n\tcrypto_bignum_free(s->d);\n\tcrypto_bignum_free(s->n);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\tcrypto_bignum_free(s->qp);\n\tcrypto_bignum_free(s->dp);\n\tcrypto_bignum_free(s->dq);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "flatpak_validate_path_characters (const char *path,\n                                  GError    **error)\n{\n  while (*path)\n    {\n      gunichar c = g_utf8_get_char_validated (path, -1);\n      if (c == (gunichar)-1 || c == (gunichar)-2)\n        {\n          g_autofree char *escaped_char = escape_character ((unsigned char)*path);\n          g_autofree char *escaped = flatpak_escape_string (path, FLATPAK_ESCAPE_DEFAULT);\n          g_set_error (error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA,\n                       \"Non-UTF8 byte %s in path %s\", escaped_char, escaped);\n          return FALSE;\n        }\n      else if (!is_char_safe (c))\n        {\n          g_autofree char *escaped_char = escape_character (c);\n          g_autofree char *escaped = flatpak_escape_string (path, FLATPAK_ESCAPE_DEFAULT);\n          g_set_error (error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA,\n                       \"Non-graphical character %s in path %s\", escaped_char, escaped);\n          return FALSE;\n        }\n      path = g_utf8_find_next_char (path, NULL);\n    }\n  return TRUE;\n}", "target": 0}
{"code": "void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n\t{\n#ifdef BN_LLONG\n\tBN_ULLONG t;\n#else\n\tBN_ULONG bl,bh;\n#endif\n\tBN_ULONG t1,t2;\n\tBN_ULONG c1,c2,c3;\n\tc1=0;\n\tc2=0;\n\tc3=0;\n\tmul_add_c(a[0],b[0],c1,c2,c3);\n\tr[0]=c1;\n\tc1=0;\n\tmul_add_c(a[0],b[1],c2,c3,c1);\n\tmul_add_c(a[1],b[0],c2,c3,c1);\n\tr[1]=c2;\n\tc2=0;\n\tmul_add_c(a[2],b[0],c3,c1,c2);\n\tmul_add_c(a[1],b[1],c3,c1,c2);\n\tmul_add_c(a[0],b[2],c3,c1,c2);\n\tr[2]=c3;\n\tc3=0;\n\tmul_add_c(a[0],b[3],c1,c2,c3);\n\tmul_add_c(a[1],b[2],c1,c2,c3);\n\tmul_add_c(a[2],b[1],c1,c2,c3);\n\tmul_add_c(a[3],b[0],c1,c2,c3);\n\tr[3]=c1;\n\tc1=0;\n\tmul_add_c(a[3],b[1],c2,c3,c1);\n\tmul_add_c(a[2],b[2],c2,c3,c1);\n\tmul_add_c(a[1],b[3],c2,c3,c1);\n\tr[4]=c2;\n\tc2=0;\n\tmul_add_c(a[2],b[3],c3,c1,c2);\n\tmul_add_c(a[3],b[2],c3,c1,c2);\n\tr[5]=c3;\n\tc3=0;\n\tmul_add_c(a[3],b[3],c1,c2,c3);\n\tr[6]=c1;\n\tr[7]=c2;\n\t}", "target": 1}
{"code": "set_interface_var(const char *iface,\n\t\t  const char *var, const char *name,\n\t\t  uint32_t val)\n{\n\tFILE *fp;\n\tchar spath[64+IFNAMSIZ];\t\n\tif (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))\n\t\treturn -1;\n\tif (strstr(name, \"..\") || strchr(name, '/'))\n\t\treturn -1;\n\tif (access(spath, F_OK) != 0)\n\t\treturn -1;\n\tfp = fopen(spath, \"w\");\n\tif (!fp) {\n\t\tif (name)\n\t\t\tflog(LOG_ERR, \"failed to set %s (%u) for %s: %s\",\n\t\t\t     name, val, iface, strerror(errno));\n\t\treturn -1;\n\t}\n\tfprintf(fp, \"%u\", val);\n\tfclose(fp);\n\treturn 0;\n}", "target": 0}
{"code": "le64addr_string(netdissect_options *ndo, const u_char *ep)\n{\n\tconst unsigned int len = 8;\n\tregister u_int i;\n\tregister char *cp;\n\tregister struct enamemem *tp;\n\tchar buf[BUFSIZE];\n\ttp = lookup_bytestring(ndo, ep, len);\n\tif (tp->e_name)\n\t\treturn (tp->e_name);\n\tcp = buf;\n\tfor (i = len; i > 0 ; --i) {\n\t\t*cp++ = hex[*(ep + i - 1) >> 4];\n\t\t*cp++ = hex[*(ep + i - 1) & 0xf];\n\t\t*cp++ = ':';\n\t}\n\tcp --;\n\t*cp = '\\0';\n\ttp->e_name = strdup(buf);\n\tif (tp->e_name == NULL)\n\t\t(*ndo->ndo_error)(ndo, \"le64addr_string: strdup(buf)\");\n\treturn (tp->e_name);\n}", "target": 1}
{"code": "Status GraphConstructor::MakeEdge(Node* src, int output_index, Node* dst,\n                                  int input_index) {\n  if (output_index >= src->num_outputs()) {\n    return errors::InvalidArgument(\n        \"Output \", output_index, \" of node \", src->name(),\n        \" does not exist. Node only has \", src->num_outputs(), \" outputs.\");\n  }\n  if (input_index >= dst->num_inputs()) {\n    return errors::InvalidArgument(\n        \"Input \", input_index, \" of node \", dst->name(),\n        \" does not exist. Node only has \", dst->num_inputs(), \" inputs.\");\n  }\n  DataType src_out = src->output_type(output_index);\n  DataType dst_in = dst->input_type(input_index);\n  if (!TypesCompatible(dst_in, src_out)) {\n    return errors::InvalidArgument(\n        \"Input \", input_index, \" of node \", dst->name(), \" was passed \",\n        DataTypeString(src_out), \" from \", src->name(), \":\", output_index,\n        \" incompatible with expected \", DataTypeString(dst_in), \".\");\n  }\n  g_->AddEdge(src, output_index, dst, input_index);\n  return Status::OK();\n}", "target": 0}
{"code": "ProcCloseFont(ClientPtr client)\n{\n    FontPtr pFont;\n    int rc;\n    REQUEST(xResourceReq);\n    REQUEST_SIZE_MATCH(xResourceReq);\n    rc = dixLookupResourceByType((void **) &pFont, stuff->id, RT_FONT,\n                                 client, DixDestroyAccess);\n    if (rc == Success) {\n        FreeResource(stuff->id, RT_NONE);\n        return Success;\n    }\n    else {\n        client->errorValue = stuff->id;\n        return rc;\n    }\n}", "target": 0}
{"code": "void InputMethodBase::OnFocus() {\n  DCHECK(!system_toplevel_window_focused_);\n  system_toplevel_window_focused_ = true;\n}", "target": 0}
{"code": "TEST(RegexMatchExpression, MatchesNull) {\n    RegexMatchExpression regex(\"a\", \"b\", \"\");\n    ASSERT(!regex.matchesBSON(BSONObj(), NULL));\n    ASSERT(!regex.matchesBSON(BSON(\"a\" << BSONNULL), NULL));\n}", "target": 0}
{"code": "static struct child_process *git_connect_git(int fd[2], char *hostandport,\n\t\t\t\t\t     const char *path, const char *prog,\n\t\t\t\t\t     enum protocol_version version,\n\t\t\t\t\t     int flags)\n{\n\tstruct child_process *conn;\n\tstruct strbuf request = STRBUF_INIT;\n\tchar *target_host = getenv(\"GIT_OVERRIDE_VIRTUAL_HOST\");\n\tif (target_host)\n\t\ttarget_host = xstrdup(target_host);\n\telse\n\t\ttarget_host = xstrdup(hostandport);\n\ttransport_check_allowed(\"git\");\n\tif (strchr(target_host, '\\n') || strchr(path, '\\n'))\n\t\tdie(_(\"newline is forbidden in git:\n\tif (git_use_proxy(hostandport))\n\t\tconn = git_proxy_connect(fd, hostandport);\n\telse\n\t\tconn = git_tcp_connect(fd, hostandport, flags);\n\tstrbuf_addf(&request,\n\t\t    \"%s %s%chost=%s%c\",\n\t\t    prog, path, 0,\n\t\t    target_host, 0);\n\tif (version > 0) {\n\t\tstrbuf_addch(&request, '\\0');\n\t\tstrbuf_addf(&request, \"version=%d%c\",\n\t\t\t    version, '\\0');\n\t}\n\tpacket_write(fd[1], request.buf, request.len);\n\tfree(target_host);\n\tstrbuf_release(&request);\n\treturn conn;\n}", "target": 0}
{"code": "static FILE * pw_tmpfile(int lockfd)\n{\n\tFILE *fd;\n\tchar *tmpname = NULL;\n\tchar *dir = \"/etc\";\n\tif ((fd = xfmkstemp(&tmpname, dir)) == NULL) {\n\t\tulckpwdf();\n\t\terr(EXIT_FAILURE, _(\"can't open temporary file\"));\n\t}\n\tcopyfile(lockfd, fileno(fd));\n\ttmp_file = tmpname;\n\treturn fd;\n}", "target": 1}
{"code": "int cipso_v4_sock_getattr(struct sock *sk, struct netlbl_lsm_secattr *secattr)\n{\n\tstruct ip_options *opt;\n\topt = inet_sk(sk)->opt;\n\tif (opt == NULL || opt->cipso == 0)\n\t\treturn -ENOMSG;\n\treturn cipso_v4_getattr(opt->__data + opt->cipso - sizeof(struct iphdr),\n\t\t\t\tsecattr);\n}", "target": 1}
{"code": "bool InstanceKlass::remove_osr_nmethod(nmethod* n) {\n  MutexLockerEx ml(OsrList_lock, Mutex::_no_safepoint_check_flag);\n  assert(n->is_osr_method(), \"wrong kind of nmethod\");\n  nmethod* last = NULL;\n  nmethod* cur  = osr_nmethods_head();\n  int max_level = CompLevel_none;  \n  Method* m = n->method();\n  bool found = false;\n  while(cur != NULL && cur != n) {\n    if (TieredCompilation && m == cur->method()) {\n      max_level = MAX2(max_level, cur->comp_level());\n    }\n    last = cur;\n    cur = cur->osr_link();\n  }\n  nmethod* next = NULL;\n  if (cur == n) {\n    found = true;\n    next = cur->osr_link();\n    if (last == NULL) {\n      set_osr_nmethods_head(next);\n    } else {\n      last->set_osr_link(next);\n    }\n  }\n  n->set_osr_link(NULL);\n  if (TieredCompilation) {\n    cur = next;\n    while (cur != NULL) {\n      if (m == cur->method()) {\n        max_level = MAX2(max_level, cur->comp_level());\n      }\n      cur = cur->osr_link();\n    }\n    m->set_highest_osr_comp_level(max_level);\n  }\n  return found;\n}", "target": 0}
{"code": "kg_seal(minor_status, context_handle, conf_req_flag, qop_req,\n        input_message_buffer, conf_state, output_message_buffer, toktype)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    int conf_req_flag;\n    gss_qop_t qop_req;\n    gss_buffer_t input_message_buffer;\n    int *conf_state;\n    gss_buffer_t output_message_buffer;\n    int toktype;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    krb5_error_code code;\n    krb5_context context;\n    output_message_buffer->length = 0;\n    output_message_buffer->value = NULL;\n    if (qop_req != 0) {\n        *minor_status = (OM_uint32) G_UNKNOWN_QOP;\n        return GSS_S_FAILURE;\n    }\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n    if (! ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n    context = ctx->k5_context;\n    switch (ctx->proto)\n    {\n    case 0:\n        code = make_seal_token_v1(context, ctx->enc, ctx->seq,\n                                  &ctx->seq_send, ctx->initiate,\n                                  input_message_buffer, output_message_buffer,\n                                  ctx->signalg, ctx->cksum_size, ctx->sealalg,\n                                  conf_req_flag, toktype, ctx->mech_used);\n        break;\n    case 1:\n        code = gss_krb5int_make_seal_token_v3(context, ctx,\n                                              input_message_buffer,\n                                              output_message_buffer,\n                                              conf_req_flag, toktype);\n        break;\n    default:\n        code = G_UNKNOWN_QOP;   \n        break;\n    }\n    if (code) {\n        *minor_status = code;\n        save_error_info(*minor_status, context);\n        return(GSS_S_FAILURE);\n    }\n    if (conf_state)\n        *conf_state = conf_req_flag;\n    *minor_status = 0;\n    return(GSS_S_COMPLETE);\n}", "target": 1}
{"code": "static int fsmMkfile(rpmfi fi, const char *dest, rpmfiles files,\n\t\t     rpmpsm psm, int nodigest, int *setmeta,\n\t\t     int * firsthardlink)\n{\n    int rc = 0;\n    int numHardlinks = rpmfiFNlink(fi);\n    if (numHardlinks > 1) {\n\tif (*firsthardlink < 0) {\n\t    *firsthardlink = rpmfiFX(fi);\n\t    rc = expandRegular(fi, dest, psm, nodigest, 1);\n\t} else {\n\t    char *fn = rpmfilesFN(files, *firsthardlink);\n\t    rc = link(fn, dest);\n\t    if (rc < 0) {\n\t\trc = RPMERR_LINK_FAILED;\n\t    }\n\t    free(fn);\n\t}\n    }\n    if (numHardlinks<=1) {\n\tif (!rc)\n\t    rc = expandRegular(fi, dest, psm, nodigest, 0);\n    } else if (rpmfiArchiveHasContent(fi)) {\n\tif (!rc)\n\t    rc = expandRegular(fi, dest, psm, nodigest, 0);\n\t*firsthardlink = -1;\n    } else {\n\t*setmeta = 0;\n    }\n    return rc;\n}", "target": 1}
{"code": "test_copy_to (const char *from, const char *to)\n{\n  char buf[TESTBUFSIZE];\n  int ret;\n  snprintf_func (buf, TESTBUFSIZE, \"cp -f %s %s\", from, to);\n  if ((ret = system (buf)) != 0)\n    {\n      return XD3_INTERNAL;\n    }\n  return 0;\n}", "target": 0}
{"code": "Jsi_RC Jsi_ValueInsertArray(Jsi_Interp *interp, Jsi_Value *target, int key, Jsi_Value *val, int flags)\n{\n    if (target->vt != JSI_VT_OBJECT) {\n        if (interp->strict)\n            Jsi_LogWarn(\"Target is not object\");\n        return JSI_ERROR;\n    }\n    Jsi_Obj *obj = target->d.obj;\n    if (obj->isarrlist) {\n        if (key >= 0 && key < interp->maxArrayList) {\n            Jsi_ObjArraySet(interp, obj, val, key);\n            return JSI_OK;\n        }\n        return JSI_ERROR;\n    }\n    char unibuf[100];\n    Jsi_NumberItoA10(key, unibuf, sizeof(unibuf));\n    Jsi_ObjInsert(interp, obj, unibuf, val, flags);\n    return JSI_OK;\n}", "target": 1}
{"code": "static void rb_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t      struct ring_buffer_event *event)\n{\n\tlocal_inc(&cpu_buffer->entries);\n\trb_update_write_stamp(cpu_buffer, event);\n\trb_end_commit(cpu_buffer);\n}", "target": 0}
{"code": "static void nfs4_close_prepare(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_closedata *calldata = data;\n\tstruct nfs4_state *state = calldata->state;\n\tint clear_rd, clear_wr, clear_rdwr;\n\tif (nfs_wait_on_sequence(calldata->arg.seqid, task) != 0)\n\t\treturn;\n\tclear_rd = clear_wr = clear_rdwr = 0;\n\tspin_lock(&state->owner->so_lock);\n\tif (state->n_rdwr == 0) {\n\t\tif (state->n_rdonly == 0) {\n\t\t\tclear_rd |= test_and_clear_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tclear_rdwr |= test_and_clear_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t\tif (state->n_wronly == 0) {\n\t\t\tclear_wr |= test_and_clear_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tclear_rdwr |= test_and_clear_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t}\n\tspin_unlock(&state->owner->so_lock);\n\tif (!clear_rd && !clear_wr && !clear_rdwr) {\n\t\ttask->tk_action = NULL;\n\t\treturn;\n\t}\n\tnfs_fattr_init(calldata->res.fattr);\n\tif (test_bit(NFS_O_RDONLY_STATE, &state->flags) != 0) {\n\t\ttask->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_DOWNGRADE];\n\t\tcalldata->arg.open_flags = FMODE_READ;\n\t} else if (test_bit(NFS_O_WRONLY_STATE, &state->flags) != 0) {\n\t\ttask->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_DOWNGRADE];\n\t\tcalldata->arg.open_flags = FMODE_WRITE;\n\t}\n\tcalldata->timestamp = jiffies;\n\trpc_call_start(task);\n}", "target": 1}
{"code": "inline static jas_int_asr(int x, int n)\n{\n\tassert(n >= 0);\n\treturn x >> n;\n}", "target": 0}
{"code": "void ChildProcessSecurityPolicy::GrantReadRawCookies(int renderer_id) {\n  AutoLock lock(lock_);\n  SecurityStateMap::iterator state = security_state_.find(renderer_id);\n  if (state == security_state_.end())\n    return;\n  state->second->GrantReadRawCookies();\n}", "target": 0}
{"code": "int inet6_csk_xmit(struct sock *sk, struct sk_buff *skb, struct flowi *fl_unused)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst;\n\tint res;\n\tdst = inet6_csk_route_socket(sk, &fl6);\n\tif (IS_ERR(dst)) {\n\t\tsk->sk_err_soft = -PTR_ERR(dst);\n\t\tsk->sk_route_caps = 0;\n\t\tkfree_skb(skb);\n\t\treturn PTR_ERR(dst);\n\t}\n\trcu_read_lock();\n\tskb_dst_set_noref(skb, dst);\n\tfl6.daddr = sk->sk_v6_daddr;\n\tres = ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);\n\trcu_read_unlock();\n\treturn res;\n}", "target": 1}
{"code": "spnego_gss_get_mic(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tgss_qop_t  qop_req,\n\t\tconst gss_buffer_t message_buffer,\n\t\tgss_buffer_t message_token)\n{\n\tOM_uint32 ret;\n\tret = gss_get_mic(minor_status,\n\t\t    context_handle,\n\t\t    qop_req,\n\t\t    message_buffer,\n\t\t    message_token);\n\treturn (ret);\n}", "target": 1}
{"code": "static void evdev_hangup(struct evdev *evdev)\n{\n\tstruct evdev_client *client;\n\tspin_lock(&evdev->client_lock);\n\tlist_for_each_entry(client, &evdev->client_list, node)\n\t\tkill_fasync(&client->fasync, SIGIO, POLL_HUP);\n\tspin_unlock(&evdev->client_lock);\n\twake_up_interruptible(&evdev->wait);\n}", "target": 0}
{"code": "int main()\n{\n    gdImagePtr im;\n    FILE *fp;\n    fp = gdTestFileOpen2(\"gd2\", \"bug00354a.gd2\");\n    gdTestAssert(fp != NULL);\n    im = gdImageCreateFromGd2(fp);\n    gdTestAssert(im == NULL);\n    fclose(fp);\n    fp = gdTestFileOpen2(\"gd2\", \"bug00354b.gd2\");\n    gdTestAssert(fp != NULL);\n    im = gdImageCreateFromGd2(fp);\n    gdTestAssert(im == NULL);\n    fclose(fp);\n    return gdNumFailures();\n}", "target": 0}
{"code": "static bool comp_add_to_data(zckCtx *zck, zckComp *comp, const char *src,\n                             size_t src_size) {\n    VALIDATE_BOOL(zck);\n    ALLOCD_BOOL(zck, comp);\n    ALLOCD_BOOL(zck, src);\n    if((comp->data_size > comp->data_size + src_size) ||\n       (src_size > comp->data_size + src_size)) {\n        zck_log(ZCK_LOG_ERROR, \"Integer overflow when reading data\");\n        return false;\n    }\n    comp->data = zrealloc(comp->data, comp->data_size + src_size);\n    if (!comp->data) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return false;\n    }\n    zck_log(ZCK_LOG_DEBUG, \"Adding %llu bytes to compressed buffer\",\n        (long long unsigned) src_size);\n    memcpy(comp->data + comp->data_size, src, src_size);\n    comp->data_size += src_size;\n    comp->data_loc += src_size;\n    return true;\n}", "target": 0}
{"code": "parse_memory(VALUE klass, VALUE data, VALUE encoding)\n{\n  htmlParserCtxtPtr ctxt;\n  if (NIL_P(data)) {\n    rb_raise(rb_eArgError, \"data cannot be nil\");\n  }\n  if (!(int)RSTRING_LEN(data)) {\n    rb_raise(rb_eRuntimeError, \"data cannot be empty\");\n  }\n  ctxt = htmlCreateMemoryParserCtxt(StringValuePtr(data),\n                                    (int)RSTRING_LEN(data));\n  if (ctxt->sax) {\n    xmlFree(ctxt->sax);\n    ctxt->sax = NULL;\n  }\n  if (RTEST(encoding)) {\n    xmlCharEncodingHandlerPtr enc = xmlFindCharEncodingHandler(StringValueCStr(encoding));\n    if (enc != NULL) {\n      xmlSwitchToEncoding(ctxt, enc);\n      if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {\n        rb_raise(rb_eRuntimeError, \"Unsupported encoding %s\",\n                 StringValueCStr(encoding));\n      }\n    }\n  }\n  return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);\n}", "target": 1}
{"code": "static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end = NULL;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\tif (reading_from_buf) {\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\t\tline_len -= (line_end - line);\n\t\tline = line_end;\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\t\terror = add_push_report_pkt(push, pkt);\n\t\tgit_pkt_free(pkt);\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\terror = 0;\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}", "target": 1}
{"code": "void ip_send_reply(struct sock *sk, struct sk_buff *skb, struct ip_reply_arg *arg,\n\t\t   unsigned int len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct {\n\t\tstruct ip_options\topt;\n\t\tchar\t\t\tdata[40];\n\t} replyopts;\n\tstruct ipcm_cookie ipc;\n\t__be32 daddr;\n\tstruct rtable *rt = skb_rtable(skb);\n\tif (ip_options_echo(&replyopts.opt, skb))\n\t\treturn;\n\tdaddr = ipc.addr = rt->rt_src;\n\tipc.opt = NULL;\n\tipc.tx_flags = 0;\n\tif (replyopts.opt.optlen) {\n\t\tipc.opt = &replyopts.opt;\n\t\tif (ipc.opt->srr)\n\t\t\tdaddr = replyopts.opt.faddr;\n\t}\n\t{\n\t\tstruct flowi4 fl4;\n\t\tflowi4_init_output(&fl4, arg->bound_dev_if, 0,\n\t\t\t\t   RT_TOS(ip_hdr(skb)->tos),\n\t\t\t\t   RT_SCOPE_UNIVERSE, sk->sk_protocol,\n\t\t\t\t   ip_reply_arg_flowi_flags(arg),\n\t\t\t\t   daddr, rt->rt_spec_dst,\n\t\t\t\t   tcp_hdr(skb)->source, tcp_hdr(skb)->dest);\n\t\tsecurity_skb_classify_flow(skb, flowi4_to_flowi(&fl4));\n\t\trt = ip_route_output_key(sock_net(sk), &fl4);\n\t\tif (IS_ERR(rt))\n\t\t\treturn;\n\t}\n\tbh_lock_sock(sk);\n\tinet->tos = ip_hdr(skb)->tos;\n\tsk->sk_priority = skb->priority;\n\tsk->sk_protocol = ip_hdr(skb)->protocol;\n\tsk->sk_bound_dev_if = arg->bound_dev_if;\n\tip_append_data(sk, ip_reply_glue_bits, arg->iov->iov_base, len, 0,\n\t\t       &ipc, &rt, MSG_DONTWAIT);\n\tif ((skb = skb_peek(&sk->sk_write_queue)) != NULL) {\n\t\tif (arg->csumoffset >= 0)\n\t\t\t*((__sum16 *)skb_transport_header(skb) +\n\t\t\t  arg->csumoffset) = csum_fold(csum_add(skb->csum,\n\t\t\t\t\t\t\t\targ->csum));\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\tip_push_pending_frames(sk);\n\t}\n\tbh_unlock_sock(sk);\n\tip_rt_put(rt);\n}", "target": 1}
{"code": "Status CompressElement(const std::vector<Tensor>& element,\n                       CompressedElement* out) {\n  std::vector<TensorProto> non_memcpy_components;\n  int64 total_size = 0;\n  for (auto& component : element) {\n    if (DataTypeCanUseMemcpy(component.dtype())) {\n      total_size += DMAHelper::buffer(&component)->size();\n    } else {\n      non_memcpy_components.emplace_back();\n      component.AsProtoTensorContent(&non_memcpy_components.back());\n      total_size += non_memcpy_components.back().ByteSizeLong();\n    }\n  }\n  tstring uncompressed;\n  uncompressed.resize_uninitialized(total_size);\n  char* position = uncompressed.mdata();\n  int non_memcpy_component_index = 0;\n  for (auto& component : element) {\n    CompressedComponentMetadata* metadata =\n        out->mutable_component_metadata()->Add();\n    metadata->set_dtype(component.dtype());\n    component.shape().AsProto(metadata->mutable_tensor_shape());\n    if (DataTypeCanUseMemcpy(component.dtype())) {\n      const TensorBuffer* buffer = DMAHelper::buffer(&component);\n      memcpy(position, buffer->data(), buffer->size());\n      metadata->set_tensor_size_bytes(buffer->size());\n    } else {\n      TensorProto& proto = non_memcpy_components[non_memcpy_component_index++];\n      proto.SerializeToArray(position, proto.ByteSizeLong());\n      metadata->set_tensor_size_bytes(proto.ByteSizeLong());\n    }\n    position += metadata->tensor_size_bytes();\n  }\n  DCHECK_EQ(position, uncompressed.mdata() + total_size);\n  if (!port::Snappy_Compress(uncompressed.mdata(), total_size,\n                             out->mutable_data())) {\n    return errors::Internal(\"Failed to compress using snappy.\");\n  }\n  VLOG(3) << \"Compressed element from \" << total_size << \" bytes to \"\n          << out->data().size() << \" bytes\";\n  return Status::OK();\n}", "target": 1}
{"code": "mountpoint_last(struct nameidata *nd, struct path *path)\n{\n\tint error = 0;\n\tstruct dentry *dentry;\n\tstruct dentry *dir = nd->path.dentry;\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tif (unlazy_walk(nd, NULL)) {\n\t\t\terror = -ECHILD;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tnd->flags &= ~LOOKUP_PARENT;\n\tif (unlikely(nd->last_type != LAST_NORM)) {\n\t\terror = handle_dots(nd, nd->last_type);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tdentry = dget(nd->path.dentry);\n\t\tgoto done;\n\t}\n\tmutex_lock(&dir->d_inode->i_mutex);\n\tdentry = d_lookup(dir, &nd->last);\n\tif (!dentry) {\n\t\tdentry = d_alloc(dir, &nd->last);\n\t\tif (!dentry) {\n\t\t\terror = -ENOMEM;\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t\tdentry = lookup_real(dir->d_inode, dentry, nd->flags);\n\t\terror = PTR_ERR(dentry);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_unlock(&dir->d_inode->i_mutex);\ndone:\n\tif (!dentry->d_inode || d_is_negative(dentry)) {\n\t\terror = -ENOENT;\n\t\tdput(dentry);\n\t\tgoto out;\n\t}\n\tpath->dentry = dentry;\n\tpath->mnt = mntget(nd->path.mnt);\n\tif (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))\n\t\treturn 1;\n\tfollow_mount(path);\n\terror = 0;\nout:\n\tterminate_walk(nd);\n\treturn error;\n}", "target": 1}
{"code": "MagickExport size_t GetQuantumExtent(const Image *image,\n  const QuantumInfo *quantum_info,const QuantumType quantum_type)\n{\n  size_t\n    extent,\n    packet_size;\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  packet_size=1;\n  switch (quantum_type)\n  {\n    case GrayAlphaQuantum: packet_size=2; break;\n    case IndexAlphaQuantum: packet_size=2; break;\n    case RGBQuantum: packet_size=3; break;\n    case BGRQuantum: packet_size=3; break;\n    case RGBAQuantum: packet_size=4; break;\n    case RGBOQuantum: packet_size=4; break;\n    case BGRAQuantum: packet_size=4; break;\n    case CMYKQuantum: packet_size=4; break;\n    case CMYKAQuantum: packet_size=5; break;\n    case CbYCrAQuantum: packet_size=4; break;\n    case CbYCrQuantum: packet_size=3; break;\n    case CbYCrYQuantum: packet_size=4; break;\n    default: break;\n  }\n  extent=MagickMax(image->columns,image->rows);\n  if (quantum_info->pack == MagickFalse)\n    return((size_t) (packet_size*extent*((quantum_info->depth+7)/8)));\n  return((size_t) ((packet_size*extent*quantum_info->depth+7)/8));\n}", "target": 0}
{"code": "GF_Err pcmC_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_PCMConfigBox *ptr = (GF_PCMConfigBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->format_flags);\n\tgf_bs_write_u8(bs, ptr->PCM_sample_size);\n\treturn GF_OK;\n}", "target": 0}
{"code": "generic_ret *init_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)\n{\n    static generic_ret         ret;\n    gss_buffer_desc            client_name,\n        service_name;\n    kadm5_server_handle_t      handle;\n    OM_uint32                  minor_stat;\n    const char                 *errmsg = NULL;\n    size_t clen, slen;\n    char *cdots, *sdots;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(*arg, rqstp, &handle)))\n        goto exit_func;\n    if (! (ret.code = check_handle((void *)handle))) {\n        ret.api_version = handle->api_version;\n    }\n    free_server_handle(handle);\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (ret.code != 0)\n        errmsg = krb5_get_error_message(NULL, ret.code);\n    clen = client_name.length;\n    trunc_name(&clen, &cdots);\n    slen = service_name.length;\n    trunc_name(&slen, &sdots);\n    krb5_klog_syslog(LOG_NOTICE, _(\"Request: kadm5_init, %.*s%s, %s, \"\n                                   \"client=%.*s%s, service=%.*s%s, addr=%s, \"\n                                   \"vers=%d, flavor=%d\"),\n                     (int)clen, (char *)client_name.value, cdots,\n                     errmsg ? errmsg : _(\"success\"),\n                     (int)clen, (char *)client_name.value, cdots,\n                     (int)slen, (char *)service_name.value, sdots,\n                     client_addr(rqstp->rq_xprt),\n                     ret.api_version & ~(KADM5_API_VERSION_MASK),\n                     rqstp->rq_cred.oa_flavor);\n    if (errmsg != NULL)\n        krb5_free_error_message(NULL, errmsg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    return(&ret);\n}", "target": 1}
{"code": "folly::Optional<TLSMessage> EncryptedReadRecordLayer::read(\n    folly::IOBufQueue& buf) {\n  auto decryptedBuf = getDecryptedBuf(buf);\n  if (!decryptedBuf) {\n    return folly::none;\n  }\n  TLSMessage msg;\n  auto currentBuf = decryptedBuf->get();\n  bool nonZeroFound = false;\n  do {\n    currentBuf = currentBuf->prev();\n    size_t i = currentBuf->length();\n    while (i > 0 && !nonZeroFound) {\n      nonZeroFound = (currentBuf->data()[i - 1] != 0);\n      i--;\n    }\n    if (nonZeroFound) {\n      msg.type = static_cast<ContentType>(currentBuf->data()[i]);\n    }\n    currentBuf->trimEnd(currentBuf->length() - i);\n  } while (!nonZeroFound && currentBuf != decryptedBuf->get());\n  if (!nonZeroFound) {\n    throw std::runtime_error(\"No content type found\");\n  }\n  msg.fragment = std::move(*decryptedBuf);\n  switch (msg.type) {\n    case ContentType::handshake:\n    case ContentType::alert:\n    case ContentType::application_data:\n      break;\n    default:\n      throw std::runtime_error(folly::to<std::string>(\n          \"received encrypted content type \",\n          static_cast<ContentTypeType>(msg.type)));\n  }\n  if (!msg.fragment) {\n    if (msg.type == ContentType::application_data) {\n      msg.fragment = folly::IOBuf::create(0);\n    } else {\n      throw std::runtime_error(\"received empty fragment\");\n    }\n  }\n  return msg;\n}", "target": 1}
{"code": "int cipso_v4_req_setattr(struct request_sock *req,\n\t\t\t const struct cipso_v4_doi *doi_def,\n\t\t\t const struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val = -EPERM;\n\tunsigned char *buf = NULL;\n\tu32 buf_len;\n\tu32 opt_len;\n\tstruct ip_options *opt = NULL;\n\tstruct inet_request_sock *req_inet;\n\tbuf_len = CIPSO_V4_OPT_LEN_MAX;\n\tbuf = kmalloc(buf_len, GFP_ATOMIC);\n\tif (buf == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto req_setattr_failure;\n\t}\n\tret_val = cipso_v4_genopt(buf, buf_len, doi_def, secattr);\n\tif (ret_val < 0)\n\t\tgoto req_setattr_failure;\n\tbuf_len = ret_val;\n\topt_len = (buf_len + 3) & ~3;\n\topt = kzalloc(sizeof(*opt) + opt_len, GFP_ATOMIC);\n\tif (opt == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto req_setattr_failure;\n\t}\n\tmemcpy(opt->__data, buf, buf_len);\n\topt->optlen = opt_len;\n\topt->cipso = sizeof(struct iphdr);\n\tkfree(buf);\n\tbuf = NULL;\n\treq_inet = inet_rsk(req);\n\topt = xchg(&req_inet->opt, opt);\n\tkfree(opt);\n\treturn 0;\nreq_setattr_failure:\n\tkfree(buf);\n\tkfree(opt);\n\treturn ret_val;\n}", "target": 1}
{"code": "static int dwc3_qcom_acpi_register_core(struct platform_device *pdev)\n{\n\tstruct dwc3_qcom\t*qcom = platform_get_drvdata(pdev);\n\tstruct device\t\t*dev = &pdev->dev;\n\tstruct resource\t\t*res, *child_res = NULL;\n\tstruct platform_device\t*pdev_irq = qcom->urs_usb ? qcom->urs_usb :\n\t\t\t\t\t\t\t    pdev;\n\tint\t\t\tirq;\n\tint\t\t\tret;\n\tqcom->dwc3 = platform_device_alloc(\"dwc3\", PLATFORM_DEVID_AUTO);\n\tif (!qcom->dwc3)\n\t\treturn -ENOMEM;\n\tqcom->dwc3->dev.parent = dev;\n\tqcom->dwc3->dev.type = dev->type;\n\tqcom->dwc3->dev.dma_mask = dev->dma_mask;\n\tqcom->dwc3->dev.dma_parms = dev->dma_parms;\n\tqcom->dwc3->dev.coherent_dma_mask = dev->coherent_dma_mask;\n\tchild_res = kcalloc(2, sizeof(*child_res), GFP_KERNEL);\n\tif (!child_res)\n\t\treturn -ENOMEM;\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"failed to get memory resource\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\tchild_res[0].flags = res->flags;\n\tchild_res[0].start = res->start;\n\tchild_res[0].end = child_res[0].start +\n\t\tqcom->acpi_pdata->dwc3_core_base_size;\n\tirq = platform_get_irq(pdev_irq, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto out;\n\t}\n\tchild_res[1].flags = IORESOURCE_IRQ;\n\tchild_res[1].start = child_res[1].end = irq;\n\tret = platform_device_add_resources(qcom->dwc3, child_res, 2);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to add resources\\n\");\n\t\tgoto out;\n\t}\n\tret = device_add_software_node(&qcom->dwc3->dev, &dwc3_qcom_swnode);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to add properties\\n\");\n\t\tgoto out;\n\t}\n\tret = platform_device_add(qcom->dwc3);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to add device\\n\");\n\t\tdevice_remove_software_node(&qcom->dwc3->dev);\n\t}\nout:\n\tkfree(child_res);\n\treturn ret;\n}", "target": 1}
{"code": "static void pcrypt_free(struct crypto_instance *inst)\n{\n\tstruct pcrypt_instance_ctx *ctx = crypto_instance_ctx(inst);\n\tcrypto_drop_aead(&ctx->spawn);\n\tkfree(inst);\n}", "target": 1}
{"code": "  BasicWriter<Char>::prepare_int_buffer(\n    unsigned num_digits, const Spec &spec,\n    const char *prefix, unsigned prefix_size) {\n  unsigned width = spec.width();\n  Alignment align = spec.align();\n  Char fill = internal::CharTraits<Char>::cast(spec.fill());\n  if (spec.precision() > static_cast<int>(num_digits)) {\n    if (prefix_size > 0 && prefix[prefix_size - 1] == '0')\n      --prefix_size;\n    unsigned number_size =\n        prefix_size + internal::to_unsigned(spec.precision());\n    AlignSpec subspec(number_size, '0', ALIGN_NUMERIC);\n    if (number_size >= width)\n      return prepare_int_buffer(num_digits, subspec, prefix, prefix_size);\n    buffer_.reserve(width);\n    unsigned fill_size = width - number_size;\n    if (align != ALIGN_LEFT) {\n      CharPtr p = grow_buffer(fill_size);\n      std::uninitialized_fill(p, p + fill_size, fill);\n    }\n    CharPtr result = prepare_int_buffer(\n        num_digits, subspec, prefix, prefix_size);\n    if (align == ALIGN_LEFT) {\n      CharPtr p = grow_buffer(fill_size);\n      std::uninitialized_fill(p, p + fill_size, fill);\n    }\n    return result;\n  }\n  unsigned size = prefix_size + num_digits;\n  if (width <= size) {\n    CharPtr p = grow_buffer(size);\n    std::uninitialized_copy(prefix, prefix + prefix_size, p);\n    return p + size - 1;\n  }\n  CharPtr p = grow_buffer(width);\n  CharPtr end = p + width;\n  if (align == ALIGN_LEFT) {\n    std::uninitialized_copy(prefix, prefix + prefix_size, p);\n    p += size;\n    std::uninitialized_fill(p, end, fill);\n  } else if (align == ALIGN_CENTER) {\n    p = fill_padding(p, width, size, fill);\n    std::uninitialized_copy(prefix, prefix + prefix_size, p);\n    p += size;\n  } else {\n    if (align == ALIGN_NUMERIC) {\n      if (prefix_size != 0) {\n        p = std::uninitialized_copy(prefix, prefix + prefix_size, p);\n        size -= prefix_size;\n      }\n    } else {\n      std::uninitialized_copy(prefix, prefix + prefix_size, end - size);\n    }\n    std::uninitialized_fill(p, end - size, fill);\n    p = end;\n  }\n  return p - 1;\n}", "target": 1}
{"code": "static mp_obj_t int_to_bytes(size_t n_args, const mp_obj_t *args) {\n    (void)n_args;\n    mp_int_t len = mp_obj_get_int(args[1]);\n    if (len < 0) {\n        mp_raise_ValueError(NULL);\n    }\n    bool big_endian = args[2] != MP_OBJ_NEW_QSTR(MP_QSTR_little);\n    vstr_t vstr;\n    vstr_init_len(&vstr, len);\n    byte *data = (byte *)vstr.buf;\n    memset(data, 0, len);\n    #if MICROPY_LONGINT_IMPL != MICROPY_LONGINT_IMPL_NONE\n    if (!mp_obj_is_small_int(args[0])) {\n        mp_obj_int_to_bytes_impl(args[0], big_endian, len, data);\n    } else\n    #endif\n    {\n        mp_int_t val = MP_OBJ_SMALL_INT_VALUE(args[0]);\n        size_t l = MIN((size_t)len, sizeof(val));\n        mp_binary_set_int(l, big_endian, data + (big_endian ? (len - l) : 0), val);\n    }\n    return mp_obj_new_bytes_from_vstr(&vstr);\n}", "target": 1}
{"code": "archive_wstring_append_from_mbs(struct archive_wstring *dest,\n    const char *p, size_t len)\n{\n\tsize_t r;\n\tint ret_val = 0;\n\tsize_t wcs_length = len;\n\tsize_t mbs_length = len;\n\tconst char *mbs = p;\n\twchar_t *wcs;\n#if HAVE_MBRTOWC\n\tmbstate_t shift_state;\n\tmemset(&shift_state, 0, sizeof(shift_state));\n#endif\n\tif (NULL == archive_wstring_ensure(dest, dest->length + wcs_length + 1))\n\t\treturn (-1);\n\twcs = dest->s + dest->length;\n\twhile (*mbs && mbs_length > 0) {\n\t\tif (wcs_length == 0) {\n\t\t\tdest->length = wcs - dest->s;\n\t\t\tdest->s[dest->length] = L'\\0';\n\t\t\twcs_length = mbs_length;\n\t\t\tif (NULL == archive_wstring_ensure(dest,\n\t\t\t    dest->length + wcs_length + 1))\n\t\t\t\treturn (-1);\n\t\t\twcs = dest->s + dest->length;\n\t\t}\n#if HAVE_MBRTOWC\n\t\tr = mbrtowc(wcs, mbs, wcs_length, &shift_state);\n#else\n\t\tr = mbtowc(wcs, mbs, wcs_length);\n#endif\n\t\tif (r == (size_t)-1 || r == (size_t)-2) {\n\t\t\tret_val = -1;\n\t\t\tif (errno == EILSEQ) {\n\t\t\t\t++mbs;\n\t\t\t\t--mbs_length;\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t\tif (r == 0 || r > mbs_length)\n\t\t\tbreak;\n\t\twcs++;\n\t\twcs_length--;\n\t\tmbs += r;\n\t\tmbs_length -= r;\n\t}\n\tdest->length = wcs - dest->s;\n\tdest->s[dest->length] = L'\\0';\n\treturn (ret_val);\n}", "target": 1}
{"code": "void FrameLoader::finishedLoadingDocument(DocumentLoader* loader)\n{\n#if PLATFORM(WIN) || PLATFORM(CHROMIUM)\n    if (m_creatingInitialEmptyDocument)\n        return;\n#endif\n    const String& responseMIMEType = loader->responseMIMEType();\n#if PLATFORM(MAC)\n    m_client->finishedLoading(loader);\n    if (!ArchiveFactory::isArchiveMimeType(responseMIMEType))\n        return;\n#else\n    if (!ArchiveFactory::isArchiveMimeType(responseMIMEType)) {\n        m_client->finishedLoading(loader);\n        return;\n    }\n#endif\n    RefPtr<Archive> archive(ArchiveFactory::create(loader->mainResourceData().get(), responseMIMEType));\n    if (!archive)\n        return;\n    loader->addAllArchiveResources(archive.get());\n    ArchiveResource* mainResource = archive->mainResource();\n    loader->setParsedArchiveData(mainResource->data());\n    m_responseMIMEType = mainResource->mimeType();\n    closeURL();\n    didOpenURL(mainResource->url());\n    String userChosenEncoding = documentLoader()->overrideEncoding();\n    bool encodingIsUserChosen = !userChosenEncoding.isNull();\n    setEncoding(encodingIsUserChosen ? userChosenEncoding : mainResource->textEncoding(), encodingIsUserChosen);\n    ASSERT(m_frame->document());\n    addData(mainResource->data()->data(), mainResource->data()->size());\n}", "target": 0}
{"code": "snmp_ber_encode_null(unsigned char *out, uint32_t *out_len, uint8_t type)\n{\n  (*out_len)++;\n  *out-- = 0x00;\n  out = snmp_ber_encode_type(out, out_len, type);\n  return out;\n}", "target": 1}
{"code": "char *oidc_util_get_chunked_cookie(request_rec *r, const char *cookieName, int chunkSize) {\n\tchar *cookieValue = NULL;\n\tchar *chunkValue = NULL;\n\tint i = 0;\n\tif (chunkSize == 0) {\n\t\tcookieValue = oidc_util_get_cookie(r, cookieName);\n\t} else {\n\t\tint chunkCount = oidc_util_get_chunked_count(r, cookieName);\n\t\tif (chunkCount > 0) {\n\t\t\tcookieValue = \"\";\n\t\t\tfor (i = 0; i < chunkCount; i++) {\n\t\t\t\tchunkValue = oidc_util_get_cookie(r, oidc_util_get_chunk_cookie_name(r, cookieName, i));\n\t\t\t\tif (chunkValue != NULL)\n\t\t\t\t\tcookieValue = apr_psprintf(r->pool, \"%s%s\", cookieValue, chunkValue);\n\t\t\t}\n\t\t} else {\n\t\t\tcookieValue = oidc_util_get_cookie(r, cookieName);\n\t\t}\n\t}\n\treturn cookieValue;\n}", "target": 1}
{"code": "MOBI_RET mobi_search_links_kf7(MOBIResult *result, const unsigned char *data_start, const unsigned char *data_end) {\n    if (!result) {\n        debug_print(\"Result structure is null%s\", \"\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    result->start = result->end = NULL;\n    *(result->value) = '\\0';\n    if (!data_start || !data_end) {\n        debug_print(\"Data is null%s\", \"\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    const char *needle1 = \"filepos=\";\n    const char *needle2 = \"recindex=\";\n    const size_t needle1_length = strlen(needle1);\n    const size_t needle2_length = strlen(needle2);\n    const size_t needle_length = max(needle1_length,needle2_length);\n    if (data_start + needle_length > data_end) {\n        return MOBI_SUCCESS;\n    }\n    unsigned char *data = (unsigned char *) data_start;\n    const unsigned char tag_open = '<';\n    const unsigned char tag_close = '>';\n    unsigned char last_border = tag_open;\n    while (data <= data_end) {\n        if (*data == tag_open || *data == tag_close) {\n            last_border = *data;\n        }\n        if (data + needle_length <= data_end &&\n            (memcmp(data, needle1, needle1_length) == 0 ||\n             memcmp(data, needle2, needle2_length) == 0)) {\n                if (last_border != tag_open) {\n                    data += needle_length;\n                    continue;\n                }\n                while (data >= data_start && !isspace(*data) && *data != tag_open) {\n                    data--;\n                }\n                result->start = ++data;\n                int i = 0;\n                while (data <= data_end && !isspace(*data) && *data != tag_close && i < MOBI_ATTRVALUE_MAXSIZE) {\n                    result->value[i++] = (char) *data++;\n                }\n                if (*(data - 1) == '/' && *data == '>') {\n                    --data; --i;\n                }\n                result->end = data;\n                result->value[i] = '\\0';\n                return MOBI_SUCCESS;\n            }\n        data++;\n    }\n    return MOBI_SUCCESS;\n}", "target": 1}
{"code": "section_size (asection *section, Elf_Internal_Phdr *segment)\n{\n  if ((section->flags & SEC_HAS_CONTENTS) != 0\n      || (section->flags & SEC_THREAD_LOCAL) == 0\n      || segment->p_type == PT_TLS)\n    return section->size;\n  return 0;\n}", "target": 0}
{"code": "SECURITY_STATUS SEC_ENTRY DeleteSecurityContext(PCtxtHandle phContext)\n{\n\tchar* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phContext);\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\tif (table->DeleteSecurityContext == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\tstatus = table->DeleteSecurityContext(phContext);\n\treturn status;\n}", "target": 1}
{"code": "void ipc_rcu_putref(void *ptr)\n{\n\tif (--container_of(ptr, struct ipc_rcu_hdr, data)->refcount > 0)\n\t\treturn;\n\tif (container_of(ptr, struct ipc_rcu_hdr, data)->is_vmalloc) {\n\t\tcall_rcu(&container_of(ptr, struct ipc_rcu_grace, data)->rcu,\n\t\t\t\tipc_schedule_free);\n\t} else {\n\t\tkfree_rcu(container_of(ptr, struct ipc_rcu_grace, data), rcu);\n\t}\n}", "target": 1}
{"code": "struct r_bin_pe_addr_t *PE_(check_unknow)(RBinPEObj *pe) {\n\tstruct r_bin_pe_addr_t *entry;\n\tif (!pe || !pe->b) {\n\t\treturn 0LL;\n\t}\n\tut8 b[512];\n\tZERO_FILL (b);\n\tentry = PE_ (r_bin_pe_get_entrypoint) (pe);\n\tif (r_buf_read_at (pe->b, entry->paddr, b, 512) < 1) {\n\t\tpe_printf (\"Warning: Cannot read entry at 0x%08\"PFMT64x\"\\n\", entry->paddr);\n\t\tfree (entry);\n\t\treturn NULL;\n\t}\n\tif (b[367] == 0xe8) {\n\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 367);\n\t\treturn entry;\n\t}\n\tsize_t i;\n\tfor (i = 0; i < 512 - 16 ; i++) {\n\t\tif (!memcmp (b + i, \"\\xff\\x15\", 2)) {\n\t\t\tif (b[i + 6] == 0x50) {\n\t\t\t\tif (b[i + 7] == 0xe8) {\n\t\t\t\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, i + 7);\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfree (entry);\n\treturn NULL;\n}", "target": 1}
{"code": "void lodepng_state_cleanup(LodePNGState* state)\n{\n  lodepng_color_mode_cleanup(&state->info_raw);\n  lodepng_info_cleanup(&state->info_png);\n}", "target": 0}
{"code": "static __always_inline int slab_trylock(struct page *page)\n{\n\tint rc = 1;\n\trc = bit_spin_trylock(PG_locked, &page->flags);\n\treturn rc;\n}", "target": 0}
{"code": "void jspReplaceWithOrAddToRoot(JsVar *dst, JsVar *src) {\n  if (!jsvGetRefs(dst) && jsvIsName(dst)) {\n    if (!jsvIsArrayBufferName(dst) && !jsvIsNewChild(dst))\n      jsvAddName(execInfo.root, dst);\n  }\n  jspReplaceWith(dst, src);\n}", "target": 0}
{"code": "static bool vgacon_scroll(struct vc_data *c, unsigned int t, unsigned int b,\n\t\tenum con_scroll dir, unsigned int lines)\n{\n\tunsigned long oldo;\n\tunsigned int delta;\n\tif (t || b != c->vc_rows || vga_is_gfx || c->vc_mode != KD_TEXT)\n\t\treturn false;\n\tif (!vga_hardscroll_enabled || lines >= c->vc_rows / 2)\n\t\treturn false;\n\tvgacon_restore_screen(c);\n\toldo = c->vc_origin;\n\tdelta = lines * c->vc_size_row;\n\tif (dir == SM_UP) {\n\t\tvgacon_scrollback_update(c, t, lines);\n\t\tif (c->vc_scr_end + delta >= vga_vram_end) {\n\t\t\tscr_memcpyw((u16 *) vga_vram_base,\n\t\t\t\t    (u16 *) (oldo + delta),\n\t\t\t\t    c->vc_screenbuf_size - delta);\n\t\t\tc->vc_origin = vga_vram_base;\n\t\t\tvga_rolled_over = oldo - vga_vram_base;\n\t\t} else\n\t\t\tc->vc_origin += delta;\n\t\tscr_memsetw((u16 *) (c->vc_origin + c->vc_screenbuf_size -\n\t\t\t\t     delta), c->vc_video_erase_char,\n\t\t\t    delta);\n\t} else {\n\t\tif (oldo - delta < vga_vram_base) {\n\t\t\tscr_memmovew((u16 *) (vga_vram_end -\n\t\t\t\t\t      c->vc_screenbuf_size +\n\t\t\t\t\t      delta), (u16 *) oldo,\n\t\t\t\t     c->vc_screenbuf_size - delta);\n\t\t\tc->vc_origin = vga_vram_end - c->vc_screenbuf_size;\n\t\t\tvga_rolled_over = 0;\n\t\t} else\n\t\t\tc->vc_origin -= delta;\n\t\tc->vc_scr_end = c->vc_origin + c->vc_screenbuf_size;\n\t\tscr_memsetw((u16 *) (c->vc_origin), c->vc_video_erase_char,\n\t\t\t    delta);\n\t}\n\tc->vc_scr_end = c->vc_origin + c->vc_screenbuf_size;\n\tc->vc_visible_origin = c->vc_origin;\n\tvga_set_mem_top(c);\n\tc->vc_pos = (c->vc_pos - oldo) + c->vc_origin;\n\treturn true;\n}", "target": 1}
{"code": "static void mdbEvalSetColumnJSON(MyDbEvalContext *p, int iCol, Jsi_DString *dStr) {\n    Jsi_Interp *interp = p->jdb->interp;\n    char nbuf[200];\n    MysqlPrep *prep = p->prep;\n    SqlFieldResults *field = prep->fieldResult+iCol;\n    if (field->isnull) {\n        Jsi_DSAppend(dStr, \"null\", NULL);\n        return;\n    }\n    const char *zBlob = \"\";\n    int bytes = 0;\n    switch(field->jsiTypeMap) {\n        case JSI_OPTION_BOOL: {\n            snprintf(nbuf, sizeof(nbuf), \"%s\", field->buffer.vchar?\"true\":\"false\");\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_INT64: {\n            snprintf(nbuf, sizeof(nbuf), \"%lld\", field->buffer.vlonglong);\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_DOUBLE: {\n            Jsi_NumberToString(interp, field->buffer.vdouble, nbuf, sizeof(nbuf));\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_TIME_D:\n        case JSI_OPTION_TIME_W: {\n            Jsi_Number jtime = mdbMyTimeToJS(&field->buffer.timestamp);\n            Jsi_NumberToString(interp, jtime, nbuf, sizeof(nbuf));\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_STRING:\n            zBlob = field->buffer.vstring;\n        default:\n        {\n            if( !zBlob ) {\n                Jsi_DSAppend(dStr, \"null\", NULL);\n                return;\n            }\n            Jsi_JSONQuote(interp, zBlob, bytes, dStr);\n            return;\n        }\n    }\n}", "target": 1}
{"code": "static const gchar* fcwwn_name_res_str(const address* addr)\n{\n    const guint8 *addrp = (const guint8*)addr->data;\n    int fmt;\n    guint8 oui[6];\n    fmt = (addrp[0] & 0xF0) >> 4;\n    switch (fmt) {\n    case FC_NH_NAA_IEEE:\n    case FC_NH_NAA_IEEE_E:\n        memcpy (oui, &addrp[2], 6);\n        return get_manuf_name(oui);\n    case FC_NH_NAA_IEEE_R:\n        oui[0] = ((addrp[0] & 0x0F) << 4) | ((addrp[1] & 0xF0) >> 4);\n        oui[1] = ((addrp[1] & 0x0F) << 4) | ((addrp[2] & 0xF0) >> 4);\n        oui[2] = ((addrp[2] & 0x0F) << 4) | ((addrp[3] & 0xF0) >> 4);\n        oui[3] = ((addrp[3] & 0x0F) << 4) | ((addrp[4] & 0xF0) >> 4);\n        oui[4] = ((addrp[4] & 0x0F) << 4) | ((addrp[5] & 0xF0) >> 4);\n        oui[5] = ((addrp[5] & 0x0F) << 4) | ((addrp[6] & 0xF0) >> 4);\n        return get_manuf_name(oui);\n    }\n    return \"\";\n}", "target": 1}
{"code": "void WasmBinaryBuilder::requireFunctionContext(const char* error) {\n  if (!currFunction) {\n    throwError(std::string(\"in a non-function context: \") + error);\n  }\n}", "target": 0}
{"code": "slice_unit::slice_unit(decoder_context* decctx)\n  : nal(NULL),\n    shdr(NULL),\n    imgunit(NULL),\n    flush_reorder_buffer(false),\n    nThreads(0),\n    first_decoded_CTB_RS(-1),\n    last_decoded_CTB_RS(-1),\n    thread_contexts(NULL),\n    ctx(decctx)\n{\n  state = Unprocessed;\n  nThreadContexts = 0;\n}", "target": 0}
{"code": "find_referral_tgs(kdc_realm_t *kdc_active_realm, krb5_kdc_req *request,\n                  krb5_principal *krbtgt_princ)\n{\n    krb5_error_code retval = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n    char **realms = NULL, *hostname = NULL;\n    krb5_data srealm = request->server->realm;\n    if (!is_referral_req(kdc_active_realm, request))\n        goto cleanup;\n    hostname = data2string(krb5_princ_component(kdc_context,\n                                                request->server, 1));\n    if (hostname == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    if (strchr(hostname, '.') == NULL)\n        goto cleanup;\n    retval = krb5_get_host_realm(kdc_context, hostname, &realms);\n    if (retval) {\n        kdc_err(kdc_context, retval, \"unable to find realm of host\");\n        goto cleanup;\n    }\n    if (realms == NULL || realms[0] == '\\0' ||\n        data_eq_string(srealm, realms[0])) {\n        retval = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        goto cleanup;\n    }\n    retval = krb5_build_principal(kdc_context, krbtgt_princ,\n                                  srealm.length, srealm.data,\n                                  \"krbtgt\", realms[0], (char *)0);\ncleanup:\n    krb5_free_host_realm(kdc_context, realms);\n    free(hostname);\n    return retval;\n}", "target": 1}
{"code": "JSON_read(int fd)\n{\n    uint32_t hsize, nsize;\n    char *str;\n    cJSON *json = NULL;\n    int rc;\n    if (Nread(fd, (char*) &nsize, sizeof(nsize), Ptcp) >= 0) {\n\thsize = ntohl(nsize);\n\tstr = (char *) calloc(sizeof(char), hsize+1);\t\n\tif (str != NULL) {\n\t    rc = Nread(fd, str, hsize, Ptcp);\n\t    if (rc >= 0) {\n\t\tif (rc == hsize) {\n\t\t    json = cJSON_Parse(str);\n\t\t}\n\t\telse {\n\t\t    printf(\"WARNING:  Size of data read does not correspond to offered length\\n\");\n\t\t}\n\t    }\n\t}\n\tfree(str);\n    }\n    return json;\n}", "target": 1}
{"code": "bit_write_UMC (Bit_Chain *dat, BITCODE_UMC val)\n{\n  int i, j;\n  int negative;\n  unsigned char byte[5];\n  BITCODE_UMC mask;\n  BITCODE_UMC value;\n  value = val;\n  mask = 0x0000007f;\n  for (i = 4, j = 0; i >= 0; i--, j += 7)\n    {\n      byte[i] = (unsigned char)((value & mask) >> j);\n      byte[i] |= 0x80;\n      mask = mask << 7;\n    }\n  for (i = 0; i < 4; i++)\n    if (byte[i] & 0x7f)\n      break;\n  if (byte[i] & 0x40)\n    i--;\n  byte[i] &= 0x7f;\n  for (j = 4; j >= i; j--)\n    bit_write_RC (dat, byte[j]);\n}", "target": 1}
{"code": "ikev2_auth_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct ikev2_auth a;\n\tconst char *v2_auth[]={ \"invalid\", \"rsasig\",\n\t\t\t\t\"shared-secret\", \"dsssig\" };\n\tconst u_char *authdata = (const u_char*)ext + sizeof(a);\n\tunsigned int len;\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&a, ext, sizeof(a));\n\tikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);\n\tlen = ntohs(a.h.len);\n\tND_PRINT((ndo,\" len=%d method=%s\", len-4,\n\t\t  STR_OR_ID(a.auth_method, v2_auth)));\n\tif (1 < ndo->ndo_vflag && 4 < len) {\n\t\tND_PRINT((ndo,\" authdata=(\"));\n\t\tif (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))\n\t\t\tgoto trunc;\n\t\tND_PRINT((ndo,\") \"));\n\t} else if(ndo->ndo_vflag && 4 < len) {\n\t\tif(!ike_show_somedata(ndo, authdata, ep)) goto trunc;\n\t}\n\treturn (const u_char *)ext + len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 1}
{"code": "static int fill_autodev(const struct lxc_rootfs *rootfs)\n{\n\tint ret;\n\tchar path[MAXPATHLEN];\n\tint i;\n\tmode_t cmask;\n\tINFO(\"Creating initial consoles under container /dev\");\n\tret = snprintf(path, MAXPATHLEN, \"%s/dev\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tERROR(\"Error calculating container /dev location\");\n\t\treturn -1;\n\t}\n\tif (!dir_exists(path))  \n\t\treturn 0;\n\tINFO(\"Populating container /dev\");\n\tcmask = umask(S_IXUSR | S_IXGRP | S_IXOTH);\n\tfor (i = 0; i < sizeof(lxc_devs) / sizeof(lxc_devs[0]); i++) {\n\t\tconst struct lxc_devs *d = &lxc_devs[i];\n\t\tret = snprintf(path, MAXPATHLEN, \"%s/dev/%s\", rootfs->path ? rootfs->mount : \"\", d->name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn -1;\n\t\tret = mknod(path, d->mode, makedev(d->maj, d->min));\n\t\tif (ret && errno != EEXIST) {\n\t\t\tchar hostpath[MAXPATHLEN];\n\t\t\tFILE *pathfile;\n\t\t\tret = snprintf(hostpath, MAXPATHLEN, \"/dev/%s\", d->name);\n\t\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\t\treturn -1;\n\t\t\tpathfile = fopen(path, \"wb\");\n\t\t\tif (!pathfile) {\n\t\t\t\tSYSERROR(\"Failed to create device mount target '%s'\", path);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfclose(pathfile);\n\t\t\tif (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {\n\t\t\t\tSYSERROR(\"Failed bind mounting device %s from host into container\",\n\t\t\t\t\td->name);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\tumask(cmask);\n\tINFO(\"Populated container /dev\");\n\treturn 0;\n}", "target": 1}
{"code": "int ssl_init(void) { \n#if OPENSSL_VERSION_NUMBER>=0x10100000L\n    OPENSSL_init_ssl(OPENSSL_INIT_LOAD_SSL_STRINGS |\n        OPENSSL_INIT_LOAD_CRYPTO_STRINGS | OPENSSL_INIT_LOAD_CONFIG, NULL);\n#else\n    OPENSSL_config(NULL);\n    SSL_load_error_strings();\n    SSL_library_init();\n#endif\n    index_ssl_cli=SSL_get_ex_new_index(0,\n        \"CLI pointer\", NULL, NULL, NULL);\n    index_ssl_ctx_opt=SSL_CTX_get_ex_new_index(0,\n        \"SERVICE_OPTIONS pointer\", NULL, NULL, NULL);\n    index_session_authenticated=SSL_SESSION_get_ex_new_index(0,\n        \"session authenticated\", NULL, NULL, NULL);\n    index_session_connect_address=SSL_SESSION_get_ex_new_index(0,\n        \"session connect address\", NULL, cb_dup_addr, cb_free_addr);\n    if(index_ssl_cli<0 || index_ssl_ctx_opt<0 ||\n            index_session_authenticated<0 ||\n            index_session_connect_address<0) {\n        s_log(LOG_ERR, \"Application specific data initialization failed\");\n        return 1;\n    }\n#ifndef OPENSSL_NO_ENGINE\n    ENGINE_load_builtin_engines();\n#endif\n#ifndef OPENSSL_NO_DH\n    dh_params=get_dh2048();\n    if(!dh_params) {\n        s_log(LOG_ERR, \"Failed to get default DH parameters\");\n        return 1;\n    }\n#endif \n    return 0;\n}", "target": 1}
{"code": "int VP8LDecodeImage(VP8LDecoder* const dec) {\n  VP8Io* io = NULL;\n  WebPDecParams* params = NULL;\n  if (dec == NULL) return 0;\n  assert(dec->hdr_.huffman_tables_ != NULL);\n  assert(dec->hdr_.htree_groups_ != NULL);\n  assert(dec->hdr_.num_htree_groups_ > 0);\n  io = dec->io_;\n  assert(io != NULL);\n  params = (WebPDecParams*)io->opaque;\n  assert(params != NULL);\n  if (dec->state_ != READ_DATA) {\n    dec->output_ = params->output;\n    assert(dec->output_ != NULL);\n    if (!WebPIoInitFromOptions(params->options, io, MODE_BGRA)) {\n      VP8LSetError(dec, VP8_STATUS_INVALID_PARAM);\n      goto Err;\n    }\n    if (!AllocateInternalBuffers32b(dec, io->width)) goto Err;\n#if !defined(WEBP_REDUCE_SIZE)\n    if (io->use_scaling && !AllocateAndInitRescaler(dec, io)) goto Err;\n#else\n    if (io->use_scaling) {\n      VP8LSetError(dec, VP8_STATUS_INVALID_PARAM);\n      goto Err;\n    }\n#endif\n    if (io->use_scaling || WebPIsPremultipliedMode(dec->output_->colorspace)) {\n      WebPInitAlphaProcessing();\n    }\n    if (!WebPIsRGBMode(dec->output_->colorspace)) {\n      WebPInitConvertARGBToYUV();\n      if (dec->output_->u.YUVA.a != NULL) WebPInitAlphaProcessing();\n    }\n    if (dec->incremental_) {\n      if (dec->hdr_.color_cache_size_ > 0 &&\n          dec->hdr_.saved_color_cache_.colors_ == NULL) {\n        if (!VP8LColorCacheInit(&dec->hdr_.saved_color_cache_,\n                                dec->hdr_.color_cache_.hash_bits_)) {\n          VP8LSetError(dec, VP8_STATUS_OUT_OF_MEMORY);\n          goto Err;\n        }\n      }\n    }\n    dec->state_ = READ_DATA;\n  }\n  if (!DecodeImageData(dec, dec->pixels_, dec->width_, dec->height_,\n                       io->crop_bottom, ProcessRows)) {\n    goto Err;\n  }\n  params->last_y = dec->last_out_row_;\n  return 1;\n Err:\n  VP8LClear(dec);\n  assert(dec->status_ != VP8_STATUS_OK);\n  return 0;\n}", "target": 1}
{"code": "static int snd_ctl_elem_read_user(struct snd_card *card,\n\t\t\t\t  struct snd_ctl_elem_value __user *_control)\n{\n\tstruct snd_ctl_elem_value *control;\n\tint result;\n\tcontrol = memdup_user(_control, sizeof(*control));\n\tif (IS_ERR(control))\n\t\treturn PTR_ERR(control);\n\tdown_read(&card->controls_rwsem);\n\tresult = snd_ctl_elem_read(card, control);\n\tup_read(&card->controls_rwsem);\n\tif (result < 0)\n\t\tgoto error;\n\tif (copy_to_user(_control, control, sizeof(*control)))\n\t\tresult = -EFAULT;\n error:\n\tkfree(control);\n\treturn result;\n}", "target": 1}
{"code": "static int __key_instantiate_and_link(struct key *key,\n\t\t\t\t      struct key_preparsed_payload *prep,\n\t\t\t\t      struct key *keyring,\n\t\t\t\t      struct key *authkey,\n\t\t\t\t      struct assoc_array_edit **_edit)\n{\n\tint ret, awaken;\n\tkey_check(key);\n\tkey_check(keyring);\n\tawaken = 0;\n\tret = -EBUSY;\n\tmutex_lock(&key_construction_mutex);\n\tif (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n\t\tret = key->type->instantiate(key, prep);\n\t\tif (ret == 0) {\n\t\t\tatomic_inc(&key->user->nikeys);\n\t\t\tset_bit(KEY_FLAG_INSTANTIATED, &key->flags);\n\t\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\t\tawaken = 1;\n\t\t\tif (keyring) {\n\t\t\t\tif (test_bit(KEY_FLAG_KEEP, &keyring->flags))\n\t\t\t\t\tset_bit(KEY_FLAG_KEEP, &key->flags);\n\t\t\t\t__key_link(key, _edit);\n\t\t\t}\n\t\t\tif (authkey)\n\t\t\t\tkey_revoke(authkey);\n\t\t\tif (prep->expiry != TIME_T_MAX) {\n\t\t\t\tkey->expiry = prep->expiry;\n\t\t\t\tkey_schedule_gc(prep->expiry + key_gc_delay);\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&key_construction_mutex);\n\tif (awaken)\n\t\twake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT);\n\treturn ret;\n}", "target": 1}
{"code": "static int snd_seq_ioctl_remove_events(struct snd_seq_client *client,\n\t\t\t\t       void __user *arg)\n{\n\tstruct snd_seq_remove_events info;\n\tif (copy_from_user(&info, arg, sizeof(info)))\n\t\treturn -EFAULT;\n\tif (info.remove_mode & SNDRV_SEQ_REMOVE_INPUT) {\n\t\tif (client->type == USER_CLIENT)\n\t\t\tsnd_seq_fifo_clear(client->data.user.fifo);\n\t}\n\tif (info.remove_mode & SNDRV_SEQ_REMOVE_OUTPUT)\n\t\tsnd_seq_queue_remove_cells(client->number, &info);\n\treturn 0;\n}", "target": 1}
{"code": "pci_emul_mem_handler(struct vmctx *ctx, int vcpu, int dir, uint64_t addr,\n\t\t     int size, uint64_t *val, void *arg1, long arg2)\n{\n\tstruct pci_vdev *pdi = arg1;\n\tstruct pci_vdev_ops *ops = pdi->dev_ops;\n\tuint64_t offset;\n\tint bidx = (int) arg2;\n\tif (addr + size > pdi->bar[bidx].addr + pdi->bar[bidx].size) {\n\t\tprintf(\"%s, Out of emulated memory range.\\n\", __func__);\n\t\treturn -ESRCH;\n\t}\n\toffset = addr - pdi->bar[bidx].addr;\n\tif (dir == MEM_F_WRITE) {\n\t\tif (size == 8) {\n\t\t\t(*ops->vdev_barwrite)(ctx, vcpu, pdi, bidx, offset,\n\t\t\t\t\t   4, *val & 0xffffffff);\n\t\t\t(*ops->vdev_barwrite)(ctx, vcpu, pdi, bidx, offset + 4,\n\t\t\t\t\t   4, *val >> 32);\n\t\t} else {\n\t\t\t(*ops->vdev_barwrite)(ctx, vcpu, pdi, bidx, offset,\n\t\t\t\t\t   size, bar_value(size, *val));\n\t\t}\n\t} else {\n\t\tif (size == 8) {\n\t\t\tuint64_t val_lo, val_hi;\n\t\t\tval_lo = (*ops->vdev_barread)(ctx, vcpu, pdi, bidx,\n\t\t\t                              offset, 4);\n\t\t\tval_lo = bar_value(4, val_lo);\n\t\t\tval_hi = (*ops->vdev_barread)(ctx, vcpu, pdi, bidx,\n\t\t\t                              offset + 4, 4);\n\t\t\t*val = val_lo | (val_hi << 32);\n\t\t} else {\n\t\t\t*val = (*ops->vdev_barread)(ctx, vcpu, pdi, bidx,\n\t\t\t                            offset, size);\n\t\t\t*val = bar_value(size, *val);\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "BGD_DECLARE(void) gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color)\n{\n\tint lastBorder;\n\tint leftLimit, rightLimit;\n\tint i;\n\tint restoreAlphaBleding;\n\tif (border < 0) {\n\t\treturn;\n\t}\n\tleftLimit = (-1);\n\trestoreAlphaBleding = im->alphaBlendingFlag;\n\tim->alphaBlendingFlag = 0;\n\tif (x >= im->sx) {\n\t\tx = im->sx - 1;\n\t} else if (x < 0) {\n\t\tx = 0;\n\t}\n\tif (y >= im->sy) {\n\t\ty = im->sy - 1;\n\t} else if (y < 0) {\n\t\ty = 0;\n\t}\n\tfor (i = x; (i >= 0); i--) {\n\t\tif (gdImageGetPixel (im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel (im, i, y, color);\n\t\tleftLimit = i;\n\t}\n\tif (leftLimit == (-1)) {\n\t\tim->alphaBlendingFlag = restoreAlphaBleding;\n\t\treturn;\n\t}\n\trightLimit = x;\n\tfor (i = (x + 1); (i < im->sx); i++) {\n\t\tif (gdImageGetPixel (im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel (im, i, y, color);\n\t\trightLimit = i;\n\t}\n\tif (y > 0) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; (i <= rightLimit); i++) {\n\t\t\tint c;\n\t\t\tc = gdImageGetPixel (im, i, y - 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder (im, i, y - 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (y < ((im->sy) - 1)) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; (i <= rightLimit); i++) {\n\t\t\tint c = gdImageGetPixel (im, i, y + 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder (im, i, y + 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\tim->alphaBlendingFlag = restoreAlphaBleding;\n}", "target": 1}
{"code": "MONGO_EXPORT void __mongo_set_error( mongo *conn, mongo_error_t err, const char *str,\n                                     int errcode ) {\n    int errstr_size, str_size;\n    conn->err = err;\n    conn->errcode = errcode;\n    if( str ) {\n        str_size = strlen( str ) + 1;\n        errstr_size = str_size > MONGO_ERR_LEN ? MONGO_ERR_LEN : str_size;\n        memcpy( conn->errstr, str, errstr_size );\n        conn->errstr[errstr_size-1] = '\\0';\n    }\n}", "target": 1}
{"code": "mm_sync_list(struct mmtree *oldtree, struct mmtree *newtree,\n    struct mm_master *mm, struct mm_master *mmold)\n{\n\tstruct mm_master *mmalloc = mm->mmalloc;\n\tstruct mm_share *mms, *new;\n\tRB_FOREACH(mms, mmtree, oldtree) {\n\t\tmm_memvalid(mmold, mms, sizeof(struct mm_share));\n\t\tmm_memvalid(mm, mms->address, mms->size);\n\t\tnew = mm_xmalloc(mmalloc, sizeof(struct mm_share));\n\t\tmemcpy(new, mms, sizeof(struct mm_share));\n\t\tRB_INSERT(mmtree, newtree, new);\n\t}\n}", "target": 1}
{"code": "static int smb311_decode_neg_context(struct smb2_negotiate_rsp *rsp,\n\t\t\t\t     struct TCP_Server_Info *server,\n\t\t\t\t     unsigned int len_of_smb)\n{\n\tstruct smb2_neg_context *pctx;\n\tunsigned int offset = le32_to_cpu(rsp->NegotiateContextOffset);\n\tunsigned int ctxt_cnt = le16_to_cpu(rsp->NegotiateContextCount);\n\tunsigned int len_of_ctxts, i;\n\tint rc = 0;\n\tcifs_dbg(FYI, \"decoding %d negotiate contexts\\n\", ctxt_cnt);\n\tif (len_of_smb <= offset) {\n\t\tcifs_dbg(VFS, \"Invalid response: negotiate context offset\\n\");\n\t\treturn -EINVAL;\n\t}\n\tlen_of_ctxts = len_of_smb - offset;\n\tfor (i = 0; i < ctxt_cnt; i++) {\n\t\tint clen;\n\t\tif (len_of_ctxts == 0)\n\t\t\tbreak;\n\t\tif (len_of_ctxts < sizeof(struct smb2_neg_context))\n\t\t\tbreak;\n\t\tpctx = (struct smb2_neg_context *)(offset + (char *)rsp);\n\t\tclen = le16_to_cpu(pctx->DataLength);\n\t\tif (clen > len_of_ctxts)\n\t\t\tbreak;\n\t\tif (pctx->ContextType == SMB2_PREAUTH_INTEGRITY_CAPABILITIES)\n\t\t\tdecode_preauth_context(\n\t\t\t\t(struct smb2_preauth_neg_context *)pctx);\n\t\telse if (pctx->ContextType == SMB2_ENCRYPTION_CAPABILITIES)\n\t\t\trc = decode_encrypt_ctx(server,\n\t\t\t\t(struct smb2_encryption_neg_context *)pctx);\n\t\telse if (pctx->ContextType == SMB2_POSIX_EXTENSIONS_AVAILABLE)\n\t\t\tserver->posix_ext_supported = true;\n\t\telse\n\t\t\tcifs_dbg(VFS, \"unknown negcontext of type %d ignored\\n\",\n\t\t\t\tle16_to_cpu(pctx->ContextType));\n\t\tif (rc)\n\t\t\tbreak;\n\t\tclen = (clen + 7) & ~0x7;\n\t\toffset += clen + sizeof(struct smb2_neg_context);\n\t\tlen_of_ctxts -= clen;\n\t}\n\treturn rc;\n}", "target": 0}
{"code": "RestStatus RestAuthHandler::execute() {\n  auto const type = _request->requestType();\n  if (type != rest::RequestType::POST) {\n    generateError(rest::ResponseCode::METHOD_NOT_ALLOWED, TRI_ERROR_HTTP_METHOD_NOT_ALLOWED);\n    return RestStatus::DONE;\n  }\n  bool parseSuccess = false;\n  VPackSlice slice = this->parseVPackBody(parseSuccess);\n  if (!parseSuccess) { \n    return RestStatus::DONE;\n  }\n  if (!slice.isObject()) {\n    return badRequest();\n  }\n  VPackSlice usernameSlice = slice.get(\"username\");\n  VPackSlice passwordSlice = slice.get(\"password\");\n  if (!usernameSlice.isString() || !passwordSlice.isString()) {\n    return badRequest();\n  }\n  _username = usernameSlice.copyString();\n  std::string const password = passwordSlice.copyString();\n  auth::UserManager* um = AuthenticationFeature::instance()->userManager();\n  if (um == nullptr) {\n    std::string msg = \"This server does not support users\";\n    LOG_TOPIC(\"2e7d4\", ERR, Logger::AUTHENTICATION) << msg;\n    generateError(rest::ResponseCode::UNAUTHORIZED, TRI_ERROR_HTTP_UNAUTHORIZED, msg);\n  } else if (um->checkPassword(_username, password)) {\n    VPackBuilder resultBuilder;\n    {\n      VPackObjectBuilder b(&resultBuilder);\n      std::string jwt = generateJwt(_username, password);\n      resultBuilder.add(\"jwt\", VPackValue(jwt));\n    }\n    _isValid = true;\n    generateDocument(resultBuilder.slice(), true, &VPackOptions::Defaults);\n  } else {\n    generateError(rest::ResponseCode::UNAUTHORIZED, TRI_ERROR_HTTP_UNAUTHORIZED,\n                  \"Wrong credentials\");\n  }\n  return RestStatus::DONE;\n}", "target": 1}
{"code": "unsigned int munlock_vma_page(struct page *page)\n{\n\tunsigned int nr_pages;\n\tstruct zone *zone = page_zone(page);\n\tBUG_ON(!PageLocked(page));\n\tspin_lock_irq(&zone->lru_lock);\n\tnr_pages = hpage_nr_pages(page);\n\tif (!TestClearPageMlocked(page))\n\t\tgoto unlock_out;\n\t__mod_zone_page_state(zone, NR_MLOCK, -nr_pages);\n\tif (__munlock_isolate_lru_page(page, true)) {\n\t\tspin_unlock_irq(&zone->lru_lock);\n\t\t__munlock_isolated_page(page);\n\t\tgoto out;\n\t}\n\t__munlock_isolation_failed(page);\nunlock_out:\n\tspin_unlock_irq(&zone->lru_lock);\nout:\n\treturn nr_pages - 1;\n}", "target": 0}
{"code": "std::vector<std::string> Utility::getSubjectAltNames(X509& cert, int type) {\n  std::vector<std::string> subject_alt_names;\n  bssl::UniquePtr<GENERAL_NAMES> san_names(\n      static_cast<GENERAL_NAMES*>(X509_get_ext_d2i(&cert, NID_subject_alt_name, nullptr, nullptr)));\n  if (san_names == nullptr) {\n    return subject_alt_names;\n  }\n  for (const GENERAL_NAME* san : san_names.get()) {\n    if (san->type == type) {\n      subject_alt_names.push_back(generalNameAsString(san));\n    }\n  }\n  return subject_alt_names;\n}", "target": 1}
{"code": "static CURLcode error_init_writer(struct Curl_easy *data,\n                                  struct contenc_writer *writer)\n{\n  (void) data;\n  return writer->downstream? CURLE_OK: CURLE_WRITE_ERROR;\n}", "target": 0}
{"code": "GF_Err SFScript_Parse(GF_BifsDecoder *codec, SFScript *script_field, GF_BitStream *bs, GF_Node *n)\n{\n\tGF_Err e;\n\tu32 i, count, nbBits;\n\tchar *ptr;\n\tScriptParser parser;\n\te = GF_OK;\n\tif (gf_node_get_tag(n) != TAG_MPEG4_Script) return GF_NON_COMPLIANT_BITSTREAM;\n\tmemset(&parser, 0, sizeof(ScriptParser));\n\tparser.codec = codec;\n\tparser.script = n;\n\tparser.bs = bs;\n\tparser.length = 500;\n\tparser.string = (char *) gf_malloc(sizeof(char)* parser.length);\n\tparser.string[0] = 0;\n\tparser.identifiers = gf_list_new();\n\tparser.new_line = (char *) (codec->dec_memory_mode ? \"\\n\" : NULL);\n\tparser.indent = 0;\n\tif (gf_bs_read_int(bs, 1)) {\n\t\twhile (!gf_bs_read_int(bs, 1)) {\n\t\t\te = ParseScriptField(&parser);\n\t\t\tif (e) goto exit;\n\t\t}\n\t} else {\n\t\tnbBits = gf_bs_read_int(bs, 4);\n\t\tcount = gf_bs_read_int(bs, nbBits);\n\t\tfor (i=0; i<count; i++) {\n\t\t\te = ParseScriptField(&parser);\n\t\t\tif (e) goto exit;\n\t\t}\n\t}\n\tgf_bs_read_int(bs, 1);\n\tSFS_AddString(&parser, \"javascript:\");\n\tSFS_AddString(&parser, parser.new_line);\n\twhile (gf_bs_read_int(bs, 1)) {\n\t\tSFS_AddString(&parser, \"function \");\n\t\tSFS_Identifier(&parser);\n\t\tSFS_Arguments(&parser, GF_FALSE);\n\t\tSFS_Space(&parser);\n\t\tSFS_StatementBlock(&parser, GF_TRUE);\n\t\tSFS_Line(&parser);\n\t\tif (codec->LastError) {\n\t\t\te = codec->LastError;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\tSFS_Line(&parser);\n\tif (script_field->script_text) gf_free(script_field->script_text);\n\tscript_field->script_text = (char *) gf_strdup(parser.string);\nexit:\n\twhile (gf_list_count(parser.identifiers)) {\n\t\tptr = (char *)gf_list_get(parser.identifiers, 0);\n\t\tgf_free(ptr);\n\t\tgf_list_rem(parser.identifiers, 0);\n\t}\n\tgf_list_del(parser.identifiers);\n\tif (parser.string) gf_free(parser.string);\n\treturn e;\n}", "target": 0}
{"code": "TEST(MultiplyAndCheckOverflow, Validate) {\n  size_t res = 0;\n  EXPECT_TRUE(MultiplyAndCheckOverflow(1, 2, &res) == kTfLiteOk);\n  EXPECT_FALSE(MultiplyAndCheckOverflow(static_cast<size_t>(123456789023),\n                                        1223423425, &res) == kTfLiteOk);\n}", "target": 0}
{"code": "Jsi_Value *jsi_ValueObjKeyAssign(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *keyval, Jsi_Value *value, int flag)\n{\n    int arrayindex = -1;\n    if (keyval->vt == JSI_VT_NUMBER && Jsi_NumberIsInteger(keyval->d.num) && keyval->d.num >= 0) {\n        arrayindex = (int)keyval->d.num;\n    }\n    if (arrayindex >= 0 && arrayindex < MAX_ARRAY_LIST &&\n        target->vt == JSI_VT_OBJECT && target->d.obj->arr) {\n        return jsi_ObjArraySetDup(interp, target->d.obj, value, arrayindex);\n    }\n    const char *kstr = Jsi_ValueToString(interp, keyval, NULL);\n#if (defined(JSI_HAS___PROTO__) && JSI_HAS___PROTO__==2)\n    if (Jsi_Strcmp(kstr, \"__proto__\")==0) {\n        Jsi_Obj *obj = target->d.obj;\n        obj->__proto__ = Jsi_ValueDup(interp, value);\n        return obj->__proto__;\n    }\n#endif\n    Jsi_Value *v = Jsi_ValueNew1(interp);\n    if (value)\n        Jsi_ValueCopy(interp, v, value);\n    jsi_ValueObjSet(interp, target, kstr, v, flag, (Jsi_ValueIsStringKey(interp, keyval)? JSI_OM_ISSTRKEY:0));\n    Jsi_DecrRefCount(interp, v);\n    return v;\n}", "target": 1}
{"code": "qedi_dbg_err(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t     const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\tchar nfunc[32];\n\tmemset(nfunc, 0, sizeof(nfunc));\n\tmemcpy(nfunc, func, sizeof(nfunc) - 1);\n\tva_start(va, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_err(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t       nfunc, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_err(\"[0000:00:00.0]:[%s:%d]: %pV\", nfunc, line, &vaf);\n\tva_end(va);\n}", "target": 1}
{"code": "static int digi_startup(struct usb_serial *serial)\n{\n\tstruct device *dev = &serial->interface->dev;\n\tstruct digi_serial *serial_priv;\n\tint ret;\n\tint i;\n\tif (serial->num_port_pointers < serial->type->num_ports + 1) {\n\t\tdev_err(dev, \"OOB endpoints missing\\n\");\n\t\treturn -ENODEV;\n\t}\n\tfor (i = 0; i < serial->type->num_ports + 1 ; i++) {\n\t\tif (!serial->port[i]->read_urb) {\n\t\t\tdev_err(dev, \"bulk-in endpoint missing\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tif (!serial->port[i]->write_urb) {\n\t\t\tdev_err(dev, \"bulk-out endpoint missing\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\tserial_priv = kzalloc(sizeof(*serial_priv), GFP_KERNEL);\n\tif (!serial_priv)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&serial_priv->ds_serial_lock);\n\tserial_priv->ds_oob_port_num = serial->type->num_ports;\n\tserial_priv->ds_oob_port = serial->port[serial_priv->ds_oob_port_num];\n\tret = digi_port_init(serial_priv->ds_oob_port,\n\t\t\t\t\t\tserial_priv->ds_oob_port_num);\n\tif (ret) {\n\t\tkfree(serial_priv);\n\t\treturn ret;\n\t}\n\tusb_set_serial_data(serial, serial_priv);\n\treturn 0;\n}", "target": 0}
{"code": "static inline bool siphash_key_is_zero(const siphash_key_t *key)\n{\n\treturn !(key->key[0] | key->key[1]);\n}", "target": 0}
{"code": "static void hardware_enable(void *junk)\n{\n\traw_spin_lock(&kvm_lock);\n\thardware_enable_nolock(junk);\n\traw_spin_unlock(&kvm_lock);\n}", "target": 0}
{"code": "l2tp_ppp_discon_cc_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tND_PRINT((ndo, \"%04x, \", EXTRACT_16BITS(ptr))); ptr++;\t\n\tND_PRINT((ndo, \"%04x \",  EXTRACT_16BITS(ptr))); ptr++;\t\n\tND_PRINT((ndo, \"%s\", tok2str(l2tp_cc_direction2str,\n\t\t\t     \"Direction-#%u\", *((const u_char *)ptr++))));\n\tif (length > 5) {\n\t\tND_PRINT((ndo, \" \"));\n\t\tprint_string(ndo, (const u_char *)ptr, length-5);\n\t}\n}", "target": 1}
{"code": "int usbip_recv_xbuff(struct usbip_device *ud, struct urb *urb)\n{\n\tint ret;\n\tint size;\n\tif (ud->side == USBIP_STUB) {\n\t\tif (usb_pipein(urb->pipe))\n\t\t\treturn 0;\n\t\tsize = urb->transfer_buffer_length;\n\t} else {\n\t\tif (usb_pipeout(urb->pipe))\n\t\t\treturn 0;\n\t\tsize = urb->actual_length;\n\t}\n\tif (!(size > 0))\n\t\treturn 0;\n\tif (size > urb->transfer_buffer_length) {\n\t\tif (ud->side == USBIP_STUB) {\n\t\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_TCP);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);\n\t\t\treturn -EPIPE;\n\t\t}\n\t}\n\tret = usbip_recv(ud->tcp_socket, urb->transfer_buffer, size);\n\tif (ret != size) {\n\t\tdev_err(&urb->dev->dev, \"recv xbuf, %d\\n\", ret);\n\t\tif (ud->side == USBIP_STUB) {\n\t\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_TCP);\n\t\t} else {\n\t\t\tusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);\n\t\t\treturn -EPIPE;\n\t\t}\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "cib_recv_tls(gnutls_session * session)\n{\n    char *buf = NULL;\n    int rc = 0;\n    int len = 0;\n    int chunk_size = 1024;\n    if (session == NULL) {\n        return NULL;\n    }\n    buf = calloc(1, chunk_size);\n    while (TRUE) {\n        errno = 0;\n        rc = gnutls_record_recv(*session, buf + len, chunk_size);\n        crm_trace(\"Got %d more bytes. errno=%d\", rc, errno);\n        if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN) {\n            crm_trace(\"Retry\");\n        } else if (rc == GNUTLS_E_UNEXPECTED_PACKET_LENGTH) {\n            crm_trace(\"Session disconnected\");\n            goto bail;\n        } else if (rc < 0) {\n            crm_err(\"Error receiving message: %s (%d)\", gnutls_strerror(rc), rc);\n            goto bail;\n        } else if (rc == chunk_size) {\n            len += rc;\n            chunk_size *= 2;\n            buf = realloc(buf, len + chunk_size);\n            crm_trace(\"Retry with %d more bytes\", (int)chunk_size);\n            CRM_ASSERT(buf != NULL);\n        } else if (buf[len + rc - 1] != 0) {\n            crm_trace(\"Last char is %d '%c'\", buf[len + rc - 1], buf[len + rc - 1]);\n            crm_trace(\"Retry with %d more bytes\", (int)chunk_size);\n            len += rc;\n            buf = realloc(buf, len + chunk_size);\n            CRM_ASSERT(buf != NULL);\n        } else {\n            crm_trace(\"Got %d more bytes\", (int)rc);\n            return buf;\n        }\n    }\n  bail:\n    free(buf);\n    return NULL;\n}", "target": 1}
{"code": "static int fill_thread_core_info(struct elf_thread_core_info *t,\n\t\t\t\t const struct user_regset_view *view,\n\t\t\t\t long signr, size_t *total)\n{\n\tunsigned int i;\n\tfill_prstatus(&t->prstatus, t->task, signr);\n\t(void) view->regsets[0].get(t->task, &view->regsets[0],\n\t\t\t\t    0, sizeof(t->prstatus.pr_reg),\n\t\t\t\t    &t->prstatus.pr_reg, NULL);\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(t->prstatus), &t->prstatus);\n\t*total += notesize(&t->notes[0]);\n\tdo_thread_regset_writeback(t->task, &view->regsets[0]);\n\tfor (i = 1; i < view->n; ++i) {\n\t\tconst struct user_regset *regset = &view->regsets[i];\n\t\tdo_thread_regset_writeback(t->task, regset);\n\t\tif (regset->core_note_type &&\n\t\t    (!regset->active || regset->active(t->task, regset))) {\n\t\t\tint ret;\n\t\t\tsize_t size = regset->n * regset->size;\n\t\t\tvoid *data = kmalloc(size, GFP_KERNEL);\n\t\t\tif (unlikely(!data))\n\t\t\t\treturn 0;\n\t\t\tret = regset->get(t->task, regset,\n\t\t\t\t\t  0, size, data, NULL);\n\t\t\tif (unlikely(ret))\n\t\t\t\tkfree(data);\n\t\t\telse {\n\t\t\t\tif (regset->core_note_type != NT_PRFPREG)\n\t\t\t\t\tfill_note(&t->notes[i], \"LINUX\",\n\t\t\t\t\t\t  regset->core_note_type,\n\t\t\t\t\t\t  size, data);\n\t\t\t\telse {\n\t\t\t\t\tt->prstatus.pr_fpvalid = 1;\n\t\t\t\t\tfill_note(&t->notes[i], \"CORE\",\n\t\t\t\t\t\t  NT_PRFPREG, size, data);\n\t\t\t\t}\n\t\t\t\t*total += notesize(&t->notes[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "init_level(struct cert_stack *stack, unsigned int *_result)\n{\n\tstruct metadata_node *head_meta;\n\tunsigned int work_repo_level;\n\tunsigned int result;\n\tresult = 0;\n\twork_repo_level = working_repo_peek_level();\n\thead_meta = SLIST_FIRST(&stack->metas);\n\tif (head_meta != NULL && work_repo_level > head_meta->level)\n\t\tresult = work_repo_level;\n\t*_result = result;\n\treturn 0;\n}", "target": 0}
{"code": "njs_function_frame_save(njs_vm_t *vm, njs_frame_t *frame, u_char *pc)\n{\n    size_t              value_count, n;\n    njs_value_t         *start, *end, *p, **new, *value, **local;\n    njs_function_t      *function;\n    njs_native_frame_t  *active, *native;\n    *frame = *vm->active_frame;\n    frame->previous_active_frame = NULL;\n    native = &frame->native;\n    native->size = 0;\n    native->free = NULL;\n    native->free_size = 0;\n    active = &vm->active_frame->native;\n    value_count = njs_function_frame_value_count(active);\n    function = active->function;\n    new = (njs_value_t **) ((u_char *) native + NJS_FRAME_SIZE);\n    value = (njs_value_t *) (new + value_count\n                             + function->u.lambda->temp);\n    native->arguments = value;\n    native->arguments_offset = value + (function->args_offset - 1);\n    native->local = new + njs_function_frame_args_count(active);\n    native->temp = new + value_count;\n    native->pc = pc;\n    start = njs_function_frame_values(active, &end);\n    p = native->arguments;\n    while (start < end) {\n        *p = *start++;\n        *new++ = p++;\n    }\n    p = native->arguments;\n    local = native->local + function->args_offset;\n    for (n = 0; n < function->args_count; n++) {\n        if (!njs_is_valid(p)) {\n            njs_set_undefined(p);\n        }\n        *local++ = p++;\n    }\n    return NJS_OK;\n}", "target": 0}
{"code": "static int l2tp_ip6_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t    int *uaddr_len, int peer)\n{\n\tstruct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct l2tp_ip6_sock *lsk = l2tp_ip6_sk(sk);\n\tlsa->l2tp_family = AF_INET6;\n\tlsa->l2tp_flowinfo = 0;\n\tlsa->l2tp_scope_id = 0;\n\tlsa->l2tp_unused = 0;\n\tif (peer) {\n\t\tif (!lsk->peer_conn_id)\n\t\t\treturn -ENOTCONN;\n\t\tlsa->l2tp_conn_id = lsk->peer_conn_id;\n\t\tlsa->l2tp_addr = np->daddr;\n\t\tif (np->sndflow)\n\t\t\tlsa->l2tp_flowinfo = np->flow_label;\n\t} else {\n\t\tif (ipv6_addr_any(&np->rcv_saddr))\n\t\t\tlsa->l2tp_addr = np->saddr;\n\t\telse\n\t\t\tlsa->l2tp_addr = np->rcv_saddr;\n\t\tlsa->l2tp_conn_id = lsk->conn_id;\n\t}\n\tif (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tlsa->l2tp_scope_id = sk->sk_bound_dev_if;\n\t*uaddr_len = sizeof(*lsa);\n\treturn 0;\n}", "target": 0}
{"code": "void __detach_mounts(struct dentry *dentry)\n{\n\tstruct mountpoint *mp;\n\tstruct mount *mnt;\n\tnamespace_lock();\n\tmp = lookup_mountpoint(dentry);\n\tif (IS_ERR_OR_NULL(mp))\n\t\tgoto out_unlock;\n\tlock_mount_hash();\n\twhile (!hlist_empty(&mp->m_list)) {\n\t\tmnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);\n\t\tif (mnt->mnt.mnt_flags & MNT_UMOUNT) {\n\t\t\tstruct mount *p, *tmp;\n\t\t\tlist_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {\n\t\t\t\thlist_add_head(&p->mnt_umount.s_list, &unmounted);\n\t\t\t\tumount_mnt(p);\n\t\t\t}\n\t\t}\n\t\telse umount_tree(mnt, 0);\n\t}\n\tunlock_mount_hash();\n\tput_mountpoint(mp);\nout_unlock:\n\tnamespace_unlock();\n}", "target": 1}
{"code": "static bool ParseSampler(Sampler *sampler, std::string *err, const json &o,\n                         bool store_original_json_for_extras_and_extensions) {\n  ParseStringProperty(&sampler->name, err, o, \"name\", false);\n  int minFilter = -1;\n  int magFilter = -1;\n  int wrapS = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  int wrapT = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  ParseIntegerProperty(&minFilter, err, o, \"minFilter\", false);\n  ParseIntegerProperty(&magFilter, err, o, \"magFilter\", false);\n  ParseIntegerProperty(&wrapS, err, o, \"wrapS\", false);\n  ParseIntegerProperty(&wrapT, err, o, \"wrapT\", false);\n  sampler->minFilter = minFilter;\n  sampler->magFilter = magFilter;\n  sampler->wrapS = wrapS;\n  sampler->wrapT = wrapT;\n  ParseExtensionsProperty(&(sampler->extensions), err, o);\n  ParseExtrasProperty(&(sampler->extras), o);\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        sampler->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        sampler->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n  return true;\n}", "target": 1}
{"code": "static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rcomp;\n\tsnprintf(rcomp.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"compression\");\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n\t\t    sizeof(struct crypto_report_comp), &rcomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "gvdb_table_write_contents_async (GHashTable          *table,\n                                 const gchar         *filename,\n                                 gboolean             byteswap,\n                                 GCancellable        *cancellable,\n                                 GAsyncReadyCallback  callback,\n                                 gpointer             user_data)\n{\n  struct gvdb_pointer root;\n  FileBuilder *fb;\n  WriteContentsData *data;\n  GString *str;\n  GBytes *bytes;\n  GFile *file;\n  GTask *task;\n  g_return_if_fail (table != NULL);\n  g_return_if_fail (filename != NULL);\n  g_return_if_fail (cancellable == NULL || G_IS_CANCELLABLE (cancellable));\n  fb = file_builder_new (byteswap);\n  file_builder_add_hash (fb, table, &root);\n  str = file_builder_serialise (fb, root);\n  bytes = g_string_free_to_bytes (str);\n  file_builder_free (fb);\n  file = g_file_new_for_path (filename);\n  data = write_contents_data_new (bytes, file);\n  task = g_task_new (NULL, cancellable, callback, user_data);\n  g_task_set_task_data (task, data, (GDestroyNotify)write_contents_data_free);\n  g_task_set_source_tag (task, gvdb_table_write_contents_async);\n  g_file_replace_contents_async (file, str->str, str->len,\n                                 NULL, FALSE,\n                                 G_FILE_CREATE_PRIVATE | G_FILE_CREATE_REPLACE_DESTINATION,\n                                 cancellable, replace_contents_cb, g_steal_pointer (&task));\n  g_bytes_unref (bytes);\n  g_object_unref (file);\n}", "target": 1}
{"code": "static int core_map_to_storage(request_rec *r)\n{\n    int access_status;\n    if ((access_status = ap_directory_walk(r))) {\n        return access_status;\n    }\n    if ((access_status = ap_file_walk(r))) {\n        return access_status;\n    }\n    return OK;\n}", "target": 0}
{"code": "int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t\tstruct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint err;\n\tBT_DBG(\"sock %p sk %p len %zu\", sock, sk, len);\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb) {\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\tmsg->msg_namelen = 0;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err == 0)\n\t\tsock_recv_ts_and_drops(msg, sk, skb);\n\tskb_free_datagram(sk, skb);\n\treturn err ? : copied;\n}", "target": 1}
{"code": "dane_query_status_t dane_query_status(dane_query_t q)\n{\n\treturn q->status;\n}", "target": 0}
{"code": "static int init_nss_hash(struct crypto_instance *instance)\n{\n\tPK11SlotInfo*\thash_slot = NULL;\n\tSECItem\t\thash_param;\n\tif (!hash_to_nss[instance->crypto_hash_type]) {\n\t\treturn 0;\n\t}\n\thash_param.type = siBuffer;\n\thash_param.data = 0;\n\thash_param.len = 0;\n\thash_slot = PK11_GetBestSlot(hash_to_nss[instance->crypto_hash_type], NULL);\n\tif (hash_slot == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Unable to find security slot (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\tinstance->nss_sym_key_sign = PK11_ImportSymKey(hash_slot,\n\t\t\t\t\t\t       hash_to_nss[instance->crypto_hash_type],\n\t\t\t\t\t\t       PK11_OriginUnwrap, CKA_SIGN,\n\t\t\t\t\t\t       &hash_param, NULL);\n\tif (instance->nss_sym_key_sign == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Failure to import key into NSS (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\tPK11_FreeSlot(hash_slot);\n\treturn 0;\n}", "target": 1}
{"code": "static int einj_error_inject(u32 type, u32 flags, u64 param1, u64 param2,\n\t\t\t     u64 param3, u64 param4)\n{\n\tint rc;\n\tu64 base_addr, size;\n\tif (get_securelevel() > 0)\n\t\treturn -EPERM;\n\tif (flags && (flags &\n\t\t~(SETWA_FLAGS_APICID|SETWA_FLAGS_MEM|SETWA_FLAGS_PCIE_SBDF)))\n\t\treturn -EINVAL;\n\tif (!(param_extension || acpi5))\n\t\tgoto inject;\n\tif (type & ACPI5_VENDOR_BIT) {\n\t\tif (vendor_flags != SETWA_FLAGS_MEM)\n\t\t\tgoto inject;\n\t} else if (!(type & MEM_ERROR_MASK) && !(flags & SETWA_FLAGS_MEM))\n\t\tgoto inject;\n\tbase_addr = param1 & param2;\n\tsize = ~param2 + 1;\n\tif (((param2 & PAGE_MASK) != PAGE_MASK) ||\n\t    ((region_intersects(base_addr, size, IORESOURCE_SYSTEM_RAM, IORES_DESC_NONE)\n\t\t\t\t!= REGION_INTERSECTS) &&\n\t     (region_intersects(base_addr, size, IORESOURCE_MEM, IORES_DESC_PERSISTENT_MEMORY)\n\t\t\t\t!= REGION_INTERSECTS)))\n\t\treturn -EINVAL;\ninject:\n\tmutex_lock(&einj_mutex);\n\trc = __einj_error_inject(type, flags, param1, param2, param3, param4);\n\tmutex_unlock(&einj_mutex);\n\treturn rc;\n}", "target": 0}
{"code": "static ssize_t lbs_debugfs_write(struct file *f, const char __user *buf,\n\t\t\t    size_t cnt, loff_t *ppos)\n{\n\tint r, i;\n\tchar *pdata;\n\tchar *p;\n\tchar *p0;\n\tchar *p1;\n\tchar *p2;\n\tstruct debug_data *d = f->private_data;\n\tpdata = kmalloc(cnt, GFP_KERNEL);\n\tif (pdata == NULL)\n\t\treturn 0;\n\tif (copy_from_user(pdata, buf, cnt)) {\n\t\tlbs_deb_debugfs(\"Copy from user failed\\n\");\n\t\tkfree(pdata);\n\t\treturn 0;\n\t}\n\tp0 = pdata;\n\tfor (i = 0; i < num_of_items; i++) {\n\t\tdo {\n\t\t\tp = strstr(p0, d[i].name);\n\t\t\tif (p == NULL)\n\t\t\t\tbreak;\n\t\t\tp1 = strchr(p, '\\n');\n\t\t\tif (p1 == NULL)\n\t\t\t\tbreak;\n\t\t\tp0 = p1++;\n\t\t\tp2 = strchr(p, '=');\n\t\t\tif (!p2)\n\t\t\t\tbreak;\n\t\t\tp2++;\n\t\t\tr = simple_strtoul(p2, NULL, 0);\n\t\t\tif (d[i].size == 1)\n\t\t\t\t*((u8 *) d[i].addr) = (u8) r;\n\t\t\telse if (d[i].size == 2)\n\t\t\t\t*((u16 *) d[i].addr) = (u16) r;\n\t\t\telse if (d[i].size == 4)\n\t\t\t\t*((u32 *) d[i].addr) = (u32) r;\n\t\t\telse if (d[i].size == 8)\n\t\t\t\t*((u64 *) d[i].addr) = (u64) r;\n\t\t\tbreak;\n\t\t} while (1);\n\t}\n\tkfree(pdata);\n\treturn (ssize_t)cnt;\n}", "target": 1}
{"code": "void PrintWebViewHelper::PrintPreviewContext::Failed(bool report_error) {\n  DCHECK(state_ == INITIALIZED || state_ == RENDERING);\n  state_ = INITIALIZED;\n  if (report_error) {\n    DCHECK_NE(PREVIEW_ERROR_NONE, error_);\n    UMA_HISTOGRAM_ENUMERATION(\"PrintPreview.RendererError\", error_,\n                              PREVIEW_ERROR_LAST_ENUM);\n  }\n  ClearContext();\n}", "target": 0}
{"code": "static void tcp_cwnd_reduction(struct sock *sk, const int prior_unsacked,\n\t\t\t       int fast_rexmit, int flag)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint sndcnt = 0;\n\tint delta = tp->snd_ssthresh - tcp_packets_in_flight(tp);\n\tint newly_acked_sacked = prior_unsacked -\n\t\t\t\t (tp->packets_out - tp->sacked_out);\n\tif (newly_acked_sacked <= 0 || WARN_ON_ONCE(!tp->prior_cwnd))\n\t\treturn;\n\ttp->prr_delivered += newly_acked_sacked;\n\tif (delta < 0) {\n\t\tu64 dividend = (u64)tp->snd_ssthresh * tp->prr_delivered +\n\t\t\t       tp->prior_cwnd - 1;\n\t\tsndcnt = div_u64(dividend, tp->prior_cwnd) - tp->prr_out;\n\t} else if ((flag & FLAG_RETRANS_DATA_ACKED) &&\n\t\t   !(flag & FLAG_LOST_RETRANS)) {\n\t\tsndcnt = min_t(int, delta,\n\t\t\t       max_t(int, tp->prr_delivered - tp->prr_out,\n\t\t\t\t     newly_acked_sacked) + 1);\n\t} else {\n\t\tsndcnt = min(delta, newly_acked_sacked);\n\t}\n\tsndcnt = max(sndcnt, (fast_rexmit ? 1 : 0));\n\ttp->snd_cwnd = tcp_packets_in_flight(tp) + sndcnt;\n}", "target": 0}
{"code": "int CephxSessionHandler::_calc_signature(Message *m, uint64_t *psig)\n{\n  const ceph_msg_header& header = m->get_header();\n  const ceph_msg_footer& footer = m->get_footer();\n  struct {\n    __u8 v;\n    __le64 magic;\n    __le32 len;\n    __le32 header_crc;\n    __le32 front_crc;\n    __le32 middle_crc;\n    __le32 data_crc;\n  } __attribute__ ((packed)) sigblock = {\n    1, mswab(AUTH_ENC_MAGIC), mswab<uint32_t>(4*4),\n    mswab<uint32_t>(header.crc), mswab<uint32_t>(footer.front_crc),\n    mswab<uint32_t>(footer.middle_crc), mswab<uint32_t>(footer.data_crc)\n  };\n  char exp_buf[CryptoKey::get_max_outbuf_size(sizeof(sigblock))];\n  try {\n    const CryptoKey::in_slice_t in {\n      sizeof(sigblock),\n      reinterpret_cast<const unsigned char*>(&sigblock)\n    };\n    const CryptoKey::out_slice_t out {\n      sizeof(exp_buf),\n      reinterpret_cast<unsigned char*>(&exp_buf)\n    };\n    key.encrypt(cct, in, out);\n  } catch (std::exception& e) {\n    lderr(cct) << __func__ << \" failed to encrypt signature block\" << dendl;\n    return -1;\n  }\n  *psig = *reinterpret_cast<__le64*>(exp_buf);\n  ldout(cct, 10) << __func__ << \" seq \" << m->get_seq()\n\t\t << \" front_crc_ = \" << footer.front_crc\n\t\t << \" middle_crc = \" << footer.middle_crc\n\t\t << \" data_crc = \" << footer.data_crc\n\t\t << \" sig = \" << *psig\n\t\t << dendl;\n  return 0;\n}", "target": 1}
{"code": "int ocfs2_set_acl(handle_t *handle,\n\t\t\t struct inode *inode,\n\t\t\t struct buffer_head *di_bh,\n\t\t\t int type,\n\t\t\t struct posix_acl *acl,\n\t\t\t struct ocfs2_alloc_context *meta_ac,\n\t\t\t struct ocfs2_alloc_context *data_ac)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint ret;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\tret = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\t\t\tret = ocfs2_acl_set_mode(inode, di_bh,\n\t\t\t\t\t\t handle, mode);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tvalue = ocfs2_acl_to_xattr(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\tif (handle)\n\t\tret = ocfs2_xattr_set_handle(handle, inode, di_bh, name_index,\n\t\t\t\t\t     \"\", value, size, 0,\n\t\t\t\t\t     meta_ac, data_ac);\n\telse\n\t\tret = ocfs2_xattr_set(inode, name_index, \"\", value, size, 0);\n\tkfree(value);\n\treturn ret;\n}", "target": 1}
{"code": "  void SetUp() override {\n    auto *file = UTHENTICODE_TEST_ASSETS \"/YourPhone.exe\";\n    pe = peparse::ParsePEFromFile(file);\n    ASSERT_TRUE(pe != nullptr);\n  }", "target": 0}
{"code": "void AsfVideo::fileProperties() {\n  DataBuf FileIddBuf = io_->read(GUID);\n  xmpData()[\"Xmp.video.FileID\"] = GUIDTag(FileIddBuf.data()).to_string();\n  xmpData()[\"Xmp.video.FileLength\"] = readQWORDTag(io_);\n  xmpData()[\"Xmp.video.CreationDate\"] = readQWORDTag(io_);\n  xmpData()[\"Xmp.video.DataPackets\"] = readQWORDTag(io_);\n  xmpData()[\"Xmp.video.duration\"] = readQWORDTag(io_);\n  xmpData()[\"Xmp.video.SendDuration\"] = readQWORDTag(io_);\n  xmpData()[\"Xmp.video.Preroll\"] = readQWORDTag(io_);\n  io_->seek(io_->tell() + DWORD + DWORD + DWORD,\n            BasicIo::beg);  \n  xmpData()[\"Xmp.video.MaxBitRate\"] = readDWORDTag(io_);\n}  ", "target": 1}
{"code": "void comps_rtree_unite(COMPS_RTree *rt1, COMPS_RTree *rt2) {\n    COMPS_HSList *tmplist, *tmp_subnodes;\n    COMPS_HSListItem *it;\n    struct Pair {\n        COMPS_HSList * subnodes;\n        char * key;\n        char added;\n    } *pair, *parent_pair;\n    pair = malloc(sizeof(struct Pair));\n    pair->subnodes = rt2->subnodes;\n    pair->key = NULL;\n    tmplist = comps_hslist_create();\n    comps_hslist_init(tmplist, NULL, NULL, &free);\n    comps_hslist_append(tmplist, pair, 0);\n    while (tmplist->first != NULL) {\n        it = tmplist->first;\n        comps_hslist_remove(tmplist, tmplist->first);\n        tmp_subnodes = ((struct Pair*)it->data)->subnodes;\n        parent_pair = (struct Pair*) it->data;\n        free(it);\n        for (it = tmp_subnodes->first; it != NULL; it=it->next) {\n            pair = malloc(sizeof(struct Pair));\n            pair->subnodes = ((COMPS_RTreeData*)it->data)->subnodes;\n            if (parent_pair->key != NULL) {\n                pair->key = malloc(sizeof(char)\n                               * (strlen(((COMPS_RTreeData*)it->data)->key)\n                               + strlen(parent_pair->key) + 1));\n                memcpy(pair->key, parent_pair->key,\n                       sizeof(char) * strlen(parent_pair->key));\n                memcpy(pair->key + strlen(parent_pair->key),\n                       ((COMPS_RTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_RTreeData*)it->data)->key)+1));\n            } else {\n                pair->key = malloc(sizeof(char)*\n                                (strlen(((COMPS_RTreeData*)it->data)->key) +1));\n                memcpy(pair->key, ((COMPS_RTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_RTreeData*)it->data)->key)+1));\n            }\n            if (((COMPS_RTreeData*)it->data)->data != NULL) {\n                    comps_rtree_set(rt1,\n                                    pair->key,\n                        rt2->data_cloner(((COMPS_RTreeData*)it->data)->data));\n            }\n            if (((COMPS_RTreeData*)it->data)->subnodes->first) {\n                comps_hslist_append(tmplist, pair, 0);\n            } else {\n                free(pair->key);\n                free(pair);\n            }\n        }\n        free(parent_pair->key);\n        free(parent_pair);\n    }\n    comps_hslist_destroy(&tmplist);\n}", "target": 1}
{"code": "sysContact_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_string(varbind, oid, \"Contiki-NG, https:\n}", "target": 1}
{"code": "batchInit(batch_t *pBatch, int maxElem) {\n\tDEFiRet;\n\tpBatch->iDoneUpTo = 0;\n\tpBatch->maxElem = maxElem;\n\tCHKmalloc(pBatch->pElem = calloc((size_t)maxElem, sizeof(batch_obj_t)));\nfinalize_it:\n\tRETiRet;\n}", "target": 0}
{"code": "int nntp_add_group(char *line, void *data)\n{\n  struct NntpServer *nserv = data;\n  struct NntpData *nntp_data = NULL;\n  char group[LONG_STRING];\n  char desc[HUGE_STRING] = \"\";\n  char mod;\n  anum_t first, last;\n  if (!nserv || !line)\n    return 0;\n  if (sscanf(line, \"%s \" ANUM \" \" ANUM \" %c %[^\\n]\", group, &last, &first, &mod, desc) < 4)\n    return 0;\n  nntp_data = nntp_data_find(nserv, group);\n  nntp_data->deleted = false;\n  nntp_data->first_message = first;\n  nntp_data->last_message = last;\n  nntp_data->allowed = (mod == 'y') || (mod == 'm');\n  mutt_str_replace(&nntp_data->desc, desc);\n  if (nntp_data->newsrc_ent || nntp_data->last_cached)\n    nntp_group_unread_stat(nntp_data);\n  else if (nntp_data->last_message && nntp_data->first_message <= nntp_data->last_message)\n    nntp_data->unread = nntp_data->last_message - nntp_data->first_message + 1;\n  else\n    nntp_data->unread = 0;\n  return 0;\n}", "target": 1}
{"code": "process_add_smartcard_key(SocketEntry *e)\n{\n\tchar *provider = NULL, *pin;\n\tint r, i, version, count = 0, success = 0, confirm = 0;\n\tu_int seconds;\n\ttime_t death = 0;\n\tu_char type;\n\tstruct sshkey **keys = NULL, *k;\n\tIdentity *id;\n\tIdtab *tab;\n\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\twhile (sshbuf_len(e->request)) {\n\t\tif ((r = sshbuf_get_u8(e->request, &type)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tswitch (type) {\n\t\tcase SSH_AGENT_CONSTRAIN_LIFETIME:\n\t\t\tif ((r = sshbuf_get_u32(e->request, &seconds)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tdeath = monotime() + seconds;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_CONFIRM:\n\t\t\tconfirm = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"process_add_smartcard_key: \"\n\t\t\t    \"Unknown constraint type %d\", type);\n\t\t\tgoto send;\n\t\t}\n\t}\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\tcount = pkcs11_add_provider(provider, pin, &keys);\n\tfor (i = 0; i < count; i++) {\n\t\tk = keys[i];\n\t\tversion = k->type == KEY_RSA1 ? 1 : 2;\n\t\ttab = idtab_lookup(version);\n\t\tif (lookup_identity(k, version) == NULL) {\n\t\t\tid = xcalloc(1, sizeof(Identity));\n\t\t\tid->key = k;\n\t\t\tid->provider = xstrdup(provider);\n\t\t\tid->comment = xstrdup(provider); \n\t\t\tid->death = death;\n\t\t\tid->confirm = confirm;\n\t\t\tTAILQ_INSERT_TAIL(&tab->idlist, id, next);\n\t\t\ttab->nentries++;\n\t\t\tsuccess = 1;\n\t\t} else {\n\t\t\tsshkey_free(k);\n\t\t}\n\t\tkeys[i] = NULL;\n\t}\nsend:\n\tfree(pin);\n\tfree(provider);\n\tfree(keys);\n\tsend_status(e, success);\n}", "target": 1}
{"code": "static void vgacon_scrollback_init(int vc_num)\n{\n\tint pitch = vga_video_num_columns * 2;\n\tsize_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;\n\tint rows = size / pitch;\n\tvoid *data;\n\tdata = kmalloc_array(CONFIG_VGACON_SOFT_SCROLLBACK_SIZE, 1024,\n\t\t\t     GFP_NOWAIT);\n\tvgacon_scrollbacks[vc_num].data = data;\n\tvgacon_scrollback_cur = &vgacon_scrollbacks[vc_num];\n\tvgacon_scrollback_cur->rows = rows - 1;\n\tvgacon_scrollback_cur->size = rows * pitch;\n\tvgacon_scrollback_reset(vc_num, size);\n}", "target": 1}
{"code": "mbc_case_fold(OnigCaseFoldType flag,\n\t      const UChar** pp, const UChar* end ARG_UNUSED, UChar* lower,\n\t      OnigEncoding enc ARG_UNUSED)\n{\n  const UChar* p = *pp;\n  if (*p == SHARP_s && (flag & INTERNAL_ONIGENC_CASE_FOLD_MULTI_CHAR) != 0) {\n    *lower++ = 's';\n    *lower   = 's';\n    (*pp)++;\n    return 2;\n  }\n  *lower = ENC_CP1254_TO_LOWER_CASE(*p);\n  (*pp)++;\n  return 1;\n}", "target": 0}
{"code": "static void udf_pc_to_char(struct super_block *sb, unsigned char *from,\n\t\t\t   int fromlen, unsigned char *to)\n{\n\tstruct pathComponent *pc;\n\tint elen = 0;\n\tunsigned char *p = to;\n\twhile (elen < fromlen) {\n\t\tpc = (struct pathComponent *)(from + elen);\n\t\tswitch (pc->componentType) {\n\t\tcase 1:\n\t\t\tif (pc->lengthComponentIdent > 0)\n\t\t\t\tbreak;\n\t\tcase 2:\n\t\t\tp = to;\n\t\t\t*p++ = '/';\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tmemcpy(p, \"../\", 3);\n\t\t\tp += 3;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tmemcpy(p, \"./\", 2);\n\t\t\tp += 2;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tp += udf_get_filename(sb, pc->componentIdent, p,\n\t\t\t\t\t      pc->lengthComponentIdent);\n\t\t\t*p++ = '/';\n\t\t\tbreak;\n\t\t}\n\t\telen += sizeof(struct pathComponent) + pc->lengthComponentIdent;\n\t}\n\tif (p > to + 1)\n\t\tp[-1] = '\\0';\n\telse\n\t\tp[0] = '\\0';\n}", "target": 1}
{"code": "static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,\n\t\t\t\t\t    const char *page,\n\t\t\t\t\t    size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n\tint ret, i;\n\tstruct rb_node **p, *parent;\n\tunsigned int octets[4];\n\t__be32 ipv4_addr = 0;\n\tret = sscanf(page, \"%3u.%3u.%3u.%3u\", &octets[3], &octets[2],\n\t\t     &octets[1], &octets[0]);\n\tif (ret != 4)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < ARRAY_SIZE(octets); i++) {\n\t\tif (octets[i] > 255)\n\t\t\treturn -ERANGE;\n\t\tbe32_add_cpu(&ipv4_addr, octets[i] << (i * 8));\n\t}\n\tret = 0;\n\twrite_lock(&cluster->cl_nodes_lock);\n\tif (o2nm_node_ip_tree_lookup(cluster, ipv4_addr, &p, &parent))\n\t\tret = -EEXIST;\n\telse if (test_and_set_bit(O2NM_NODE_ATTR_ADDRESS,\n\t\t\t&node->nd_set_attributes))\n\t\tret = -EBUSY;\n\telse {\n\t\trb_link_node(&node->nd_ip_node, parent, p);\n\t\trb_insert_color(&node->nd_ip_node, &cluster->cl_node_ip_tree);\n\t}\n\twrite_unlock(&cluster->cl_nodes_lock);\n\tif (ret)\n\t\treturn ret;\n\tmemcpy(&node->nd_ipv4_address, &ipv4_addr, sizeof(ipv4_addr));\n\treturn count;\n}", "target": 1}
{"code": "static inline bool mmget_still_valid(struct mm_struct *mm)\n{\n\treturn likely(!mm->core_state);\n}", "target": 0}
{"code": "u32 gf_isom_find_od_id_for_track(GF_ISOFile *file, u32 track)\n{\n\tu32 i, j, di, the_od_id;\n\tGF_TrackBox *od_tk;\n\tGF_TrackBox *tk = gf_isom_get_track_from_file(file, track);\n\tif (!tk) return 0;\n\ti=0;\n\twhile ( (od_tk = (GF_TrackBox*)gf_list_enum(file->moov->trackList, &i))) {\n\t\tif (!od_tk || !od_tk->Media || !od_tk->Media->handler  || !od_tk->Media->information ||\n\t\t\t!od_tk->Media->information->sampleTable || !od_tk->Media->information->sampleTable->SampleSize ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (od_tk->Media->handler->handlerType != GF_ISOM_MEDIA_OD) continue;\n\t\tfor (j=0; j<od_tk->Media->information->sampleTable->SampleSize->sampleCount; j++) {\n\t\t\tGF_ISOSample *samp = gf_isom_get_sample(file, i, j+1, &di);\n\t\t\tthe_od_id = Media_FindOD_ID(od_tk->Media, samp, tk->Header->trackID);\n\t\t\tgf_isom_sample_del(&samp);\n\t\t\tif (the_od_id) return the_od_id;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int bnx2x_get_cmng_fns_mode(struct bnx2x *bp)\n{\n\tif (CHIP_REV_IS_SLOW(bp))\n\t\treturn CMNG_FNS_NONE;\n\tif (IS_MF(bp))\n\t\treturn CMNG_FNS_MINMAX;\n\treturn CMNG_FNS_NONE;\n}", "target": 0}
{"code": "static void nfs4_open_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state_owner *sp = data->owner;\n\tif (nfs_wait_on_sequence(data->o_arg.seqid, task) != 0)\n\t\treturn;\n\tif (data->state != NULL) {\n\t\tstruct nfs_delegation *delegation;\n\t\tif (can_open_cached(data->state, data->o_arg.open_flags & (FMODE_READ|FMODE_WRITE|O_EXCL)))\n\t\t\tgoto out_no_action;\n\t\trcu_read_lock();\n\t\tdelegation = rcu_dereference(NFS_I(data->state->inode)->delegation);\n\t\tif (delegation != NULL &&\n\t\t    test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags) == 0) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto out_no_action;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\tdata->o_arg.id = sp->so_owner_id.id;\n\tdata->o_arg.clientid = sp->so_client->cl_clientid;\n\tif (data->o_arg.claim == NFS4_OPEN_CLAIM_PREVIOUS) {\n\t\ttask->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_NOATTR];\n\t\tnfs_copy_fh(&data->o_res.fh, data->o_arg.fh);\n\t}\n\tdata->timestamp = jiffies;\n\trpc_call_start(task);\n\treturn;\nout_no_action:\n\ttask->tk_action = NULL;\n}", "target": 1}
{"code": "      static double mp_normp(_cimg_math_parser& mp) {\n        const unsigned int i_end = (unsigned int)mp.opcode[2];\n        if (i_end==4) return cimg::abs(_mp_arg(3));\n        const double p = (double)mp.opcode[3];\n        double res = 0;\n        for (unsigned int i = 4; i<i_end; ++i)\n          res+=std::pow(cimg::abs(_mp_arg(i)),p);\n        res = std::pow(res,1/p);\n        return res>0?res:0.0;", "target": 0}
{"code": "static int override_release(char __user *release, int len)\n{\n\tint ret = 0;\n\tchar buf[65];\n\tif (current->personality & UNAME26) {\n\t\tchar *rest = UTS_RELEASE;\n\t\tint ndots = 0;\n\t\tunsigned v;\n\t\twhile (*rest) {\n\t\t\tif (*rest == '.' && ++ndots >= 3)\n\t\t\t\tbreak;\n\t\t\tif (!isdigit(*rest) && *rest != '.')\n\t\t\t\tbreak;\n\t\t\trest++;\n\t\t}\n\t\tv = ((LINUX_VERSION_CODE >> 8) & 0xff) + 40;\n\t\tsnprintf(buf, len, \"2.6.%u%s\", v, rest);\n\t\tret = copy_to_user(release, buf, len);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "bool Decode(string_view encoded, std::string* raw) {\n  for (auto iter = encoded.begin(); iter != encoded.end(); ++iter) {\n    if (*iter == '%') {\n      if (++iter == encoded.end()) {\n        return false;\n      }\n      int h_decimal = 0;\n      if (!HexToDecimal(*iter, &h_decimal)) {\n        return false;\n      }\n      if (++iter == encoded.end()) {\n        return false;\n      }\n      int l_decimal = 0;\n      if (!HexToDecimal(*iter, &l_decimal)) {\n        return false;\n      }\n      raw->push_back(static_cast<char>((h_decimal << 4) + l_decimal));\n    } else if (*iter > 127 || *iter < 0) {\n      return false;\n    } else {\n      raw->push_back(*iter);\n    }\n  }\n  return true;\n}", "target": 1}
{"code": "AP4_AvccAtom::AP4_AvccAtom(AP4_UI32 size, const AP4_UI08* payload) :\n    AP4_Atom(AP4_ATOM_TYPE_AVCC, size)\n{\n    unsigned int payload_size = size-AP4_ATOM_HEADER_SIZE;\n    m_RawBytes.SetData(payload, payload_size);\n    m_ConfigurationVersion = payload[0];\n    m_Profile              = payload[1];\n    m_ProfileCompatibility = payload[2];\n    m_Level                = payload[3];\n    m_NaluLengthSize       = 1+(payload[4]&3);\n    AP4_UI08 num_seq_params = payload[5]&31;\n    m_SequenceParameters.EnsureCapacity(num_seq_params);\n    unsigned int cursor = 6;\n    for (unsigned int i=0; i<num_seq_params; i++) {\n        m_SequenceParameters.Append(AP4_DataBuffer());\n        AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n        m_SequenceParameters[i].SetData(&payload[cursor]+2, param_length);\n        cursor += 2+param_length;\n    }\n    AP4_UI08 num_pic_params = payload[cursor++];\n    m_PictureParameters.EnsureCapacity(num_pic_params);\n    for (unsigned int i=0; i<num_pic_params; i++) {\n        m_PictureParameters.Append(AP4_DataBuffer());\n        AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n        m_PictureParameters[i].SetData(&payload[cursor]+2, param_length);\n        cursor += 2+param_length;\n    }\n}", "target": 1}
{"code": "  ErrorSslSocket(absl::string_view error) : error_(error) {}", "target": 0}
{"code": "static void dbEvalSetColumn(DbEvalContext *p, int iCol, Jsi_DString *dStr) {\n    Jsi_Interp *interp = p->jdb->interp;\n    char nbuf[200];\n    sqlite3_stmt *pStmt = p->pPreStmt->pStmt;\n    switch( sqlite3_column_type(pStmt, iCol) ) {\n    case SQLITE_BLOB: {\n        int bytes = sqlite3_column_bytes(pStmt, iCol);\n        const char *zBlob = (char*)sqlite3_column_blob(pStmt, iCol);\n        if( !zBlob ) {\n            return;\n        }\n        Jsi_DSAppendLen(dStr, zBlob, bytes);\n        return;\n    }\n    case SQLITE_INTEGER: {\n        sqlite_int64 v = sqlite3_column_int64(pStmt, iCol);\n        if (v==0 || v==1) {\n            const char *dectyp = sqlite3_column_decltype(pStmt, iCol);\n            if (dectyp && !Jsi_Strncasecmp(dectyp,\"bool\", 4)) {\n                Jsi_DSAppend(dStr, (v?\"true\":\"false\"), NULL);\n                return;\n            }\n        }\n#ifdef __WIN32\n        snprintf(nbuf, sizeof(nbuf), \"%\" PRId64, (Jsi_Wide)v);\n#else\n        snprintf(nbuf, sizeof(nbuf), \"%lld\", v);\n#endif\n        Jsi_DSAppend(dStr, nbuf, NULL);\n        return;\n    }\n    case SQLITE_FLOAT: {\n        Jsi_NumberToString(interp, sqlite3_column_double(pStmt, iCol), nbuf, sizeof(nbuf));\n        Jsi_DSAppend(dStr, nbuf, NULL);\n        return;\n    }\n    case SQLITE_NULL: {\n        return;\n    }\n    }\n    const char *str = (char*)sqlite3_column_text(pStmt, iCol );\n    if (!str)\n        str = p->jdb->optPtr->nullvalue;\n    Jsi_DSAppend(dStr, str?str:\"\", NULL);\n}", "target": 1}
{"code": "static long madvise_remove(struct vm_area_struct *vma,\n\t\t\t\tstruct vm_area_struct **prev,\n\t\t\t\tunsigned long start, unsigned long end)\n{\n\tloff_t offset;\n\tint error;\n\t*prev = NULL;\t\n\tif (vma->vm_flags & (VM_LOCKED|VM_NONLINEAR|VM_HUGETLB))\n\t\treturn -EINVAL;\n\tif (!vma->vm_file || !vma->vm_file->f_mapping\n\t\t|| !vma->vm_file->f_mapping->host) {\n\t\t\treturn -EINVAL;\n\t}\n\tif ((vma->vm_flags & (VM_SHARED|VM_WRITE)) != (VM_SHARED|VM_WRITE))\n\t\treturn -EACCES;\n\toffset = (loff_t)(start - vma->vm_start)\n\t\t\t+ ((loff_t)vma->vm_pgoff << PAGE_SHIFT);\n\tup_read(&current->mm->mmap_sem);\n\terror = do_fallocate(vma->vm_file,\n\t\t\t\tFALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE,\n\t\t\t\toffset, end - start);\n\tdown_read(&current->mm->mmap_sem);\n\treturn error;\n}", "target": 1}
{"code": "dump_threads(void)\n{\n\tFILE *fp;\n\tchar time_buf[26];\n\telement e;\n\tvrrp_t *vrrp;\n\tchar *file_name;\n\tfile_name = make_file_name(\"/tmp/thread_dump.dat\",\n\t\t\t\t\t\"vrrp\",\n#if HAVE_DECL_CLONE_NEWNET\n\t\t\t\t\tglobal_data->network_namespace,\n#else\n\t\t\t\t\tNULL,\n#endif\n\t\t\t\t\tglobal_data->instance_name);\n\tfp = fopen(file_name, \"a\");\n\tFREE(file_name);\n\tset_time_now();\n\tctime_r(&time_now.tv_sec, time_buf);\n\tfprintf(fp, \"\\n%.19s.%6.6ld: Thread dump\\n\", time_buf, time_now.tv_usec);\n\tdump_thread_data(master, fp);\n\tfprintf(fp, \"alloc = %lu\\n\", master->alloc);\n\tfprintf(fp, \"\\n\");\n\tLIST_FOREACH(vrrp_data->vrrp, vrrp, e) {\n\t\tctime_r(&vrrp->sands.tv_sec, time_buf);\n\t\tfprintf(fp, \"VRRP instance %s, sands %.19s.%6.6lu, status %s\\n\", vrrp->iname, time_buf, vrrp->sands.tv_usec,\n\t\t\t\tvrrp->state == VRRP_STATE_INIT ? \"INIT\" :\n\t\t\t\tvrrp->state == VRRP_STATE_BACK ? \"BACKUP\" :\n\t\t\t\tvrrp->state == VRRP_STATE_MAST ? \"MASTER\" :\n\t\t\t\tvrrp->state == VRRP_STATE_FAULT ? \"FAULT\" :\n\t\t\t\tvrrp->state == VRRP_STATE_STOP ? \"STOP\" :\n\t\t\t\tvrrp->state == VRRP_DISPATCHER ? \"DISPATCHER\" : \"unknown\");\n\t}\n\tfclose(fp);\n}", "target": 1}
{"code": "    size_t operator()(const ArrayOrObject data) const {\n      return data.toOpaque();\n    }", "target": 0}
{"code": "static inline bool rt6_qualify_for_ecmp(struct rt6_info *rt)\n{\n\treturn (rt->rt6i_flags & (RTF_GATEWAY|RTF_ADDRCONF|RTF_DYNAMIC)) ==\n\t       RTF_GATEWAY;\n}", "target": 0}
{"code": "unsigned long perf_instruction_pointer(struct pt_regs *regs)\n{\n\tbool use_siar = regs_use_siar(regs);\n\tunsigned long siar = mfspr(SPRN_SIAR);\n\tif (ppmu->flags & PPMU_P10_DD1) {\n\t\tif (siar)\n\t\t\treturn siar;\n\t\telse\n\t\t\treturn regs->nip;\n\t} else if (use_siar && siar_valid(regs))\n\t\treturn mfspr(SPRN_SIAR) + perf_ip_adjust(regs);\n\telse if (use_siar)\n\t\treturn 0;\t\t\n\telse\n\t\treturn regs->nip;\n}", "target": 1}
{"code": "HttpStateData::continueAfterParsingHeader()\n{\n    if (flags.handling1xx) {\n        debugs(11, 5, HERE << \"wait for 1xx handling\");\n        Must(!flags.headers_parsed);\n        return false;\n    }\n    if (!flags.headers_parsed && !eof) {\n        debugs(11, 9, \"needs more at \" << inBuf.length());\n        flags.do_next_read = true;\n        maybeReadVirginBody(); \n        return false;\n    }\n    err_type error = ERR_NONE;\n    if (flags.headers_parsed) { \n        if (HttpReply *vrep = virginReply()) {\n            const Http::StatusCode s = vrep->sline.status();\n            const AnyP::ProtocolVersion &v = vrep->sline.version;\n            if (s == Http::scInvalidHeader && v != Http::ProtocolVersion(0,9)) {\n                debugs(11, DBG_IMPORTANT, \"WARNING: HTTP: Invalid Response: Bad header encountered from \" << entry->url() << \" AKA \" << request->url);\n                error = ERR_INVALID_RESP;\n            } else if (s == Http::scHeaderTooLarge) {\n                fwd->dontRetry(true);\n                error = ERR_TOO_BIG;\n            } else if (vrep->header.conflictingContentLength()) {\n                fwd->dontRetry(true);\n                error = ERR_INVALID_RESP;\n            } else if (vrep->header.unsupportedTe()) {\n                fwd->dontRetry(true);\n                error = ERR_INVALID_RESP;\n            } else {\n                return true; \n            }\n        } else {\n            debugs(11, DBG_IMPORTANT, \"WARNING: HTTP: Invalid Response: No reply at all for \" << entry->url() << \" AKA \" << request->url);\n            error = ERR_INVALID_RESP;\n        }\n    } else {\n        assert(eof);\n        if (inBuf.length()) {\n            error = ERR_INVALID_RESP;\n            debugs(11, DBG_IMPORTANT, \"WARNING: HTTP: Invalid Response: Headers did not parse at all for \" << entry->url() << \" AKA \" << request->url);\n        } else {\n            error = ERR_ZERO_SIZE_OBJECT;\n            debugs(11, (request->flags.accelerated?DBG_IMPORTANT:2), \"WARNING: HTTP: Invalid Response: No object data received for \" << entry->url() << \" AKA \" << request->url);\n        }\n    }\n    assert(error != ERR_NONE);\n    entry->reset();\n    fwd->fail(new ErrorState(error, Http::scBadGateway, fwd->request));\n    flags.do_next_read = false;\n    closeServer();\n    mustStop(\"HttpStateData::continueAfterParsingHeader\");\n    return false; \n}", "target": 0}
{"code": "static void rb_inc_iter(struct ring_buffer_iter *iter)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer = iter->cpu_buffer;\n\tif (iter->head_page == cpu_buffer->reader_page)\n\t\titer->head_page = rb_set_head_page(cpu_buffer);\n\telse\n\t\trb_inc_page(&iter->head_page);\n\titer->page_stamp = iter->read_stamp = iter->head_page->page->time_stamp;\n\titer->head = 0;\n\titer->next_event = 0;\n}", "target": 0}
{"code": "    CImg<intT> get_select(CImgDisplay &disp,\n\t\t          const unsigned int feature_type=2, unsigned int *const XYZ=0,\n                          const bool exit_on_anykey=false) const {\n      return _select(disp,0,feature_type,XYZ,0,0,0,exit_on_anykey,true,false);", "target": 0}
{"code": "extract_option(uschar **name, uschar **value)\n{\nuschar *n;\nuschar *v = smtp_cmd_data + Ustrlen(smtp_cmd_data) - 1;\nwhile (isspace(*v)) v--;\nv[1] = 0;\nwhile (v > smtp_cmd_data && *v != '=' && !isspace(*v))\n  {\n  if (*v == '\"') do v--; while (*v != '\"' && v > smtp_cmd_data+1);\n  v--;\n  }\nn = v;\nif (*v == '=')\n  {\n  while(isalpha(n[-1])) n--;\n  if (!isspace(n[-1])) return FALSE;\n  n[-1] = 0;\n  }\nelse\n  {\n  n++;\n  if (v == smtp_cmd_data) return FALSE;\n  }\n*v++ = 0;\n*name = n;\n*value = v;\nreturn TRUE;\n}", "target": 0}
{"code": "std::string queueloader::get_filename(const std::string& str) {\n\tstd::string fn = ctrl->get_dlpath();\n\tif (fn[fn.length()-1] != NEWSBEUTER_PATH_SEP[0])\n\t\tfn.append(NEWSBEUTER_PATH_SEP);\n\tchar buf[1024];\n\tsnprintf(buf, sizeof(buf), \"%s\", str.c_str());\n\tchar * base = basename(buf);\n\tif (!base || strlen(base) == 0) {\n\t\tchar lbuf[128];\n\t\ttime_t t = time(NULL);\n\t\tstrftime(lbuf, sizeof(lbuf), \"%Y-%b-%d-%H%M%S.unknown\", localtime(&t));\n\t\tfn.append(lbuf);\n\t} else {\n\t\tfn.append(base);\n\t}\n\treturn fn;\n}", "target": 1}
{"code": "void SecurityManager::on_validation_failed(\n        const ParticipantProxyData& participant_data,\n        const SecurityException& exception) const\n{\n    if (participant_->security_attributes().allow_unauthenticated_participants)\n    {\n        participant_->pdp()->notifyAboveRemoteEndpoints(participant_data, false);\n    }\n    if (strlen(exception.what()) > 0)\n    {\n        EPROSIMA_LOG_ERROR(SECURITY_AUTHENTICATION, exception.what());\n    }\n    EPROSIMA_LOG_INFO(SECURITY, \"Authentication failed for participant \" <<\n            participant_data.m_guid);\n    if (participant_->getListener() != nullptr)\n    {\n        ParticipantAuthenticationInfo info;\n        info.status = ParticipantAuthenticationInfo::UNAUTHORIZED_PARTICIPANT;\n        info.guid = participant_data.m_guid;\n        participant_->getListener()->onParticipantAuthentication(\n            participant_->getUserRTPSParticipant(), std::move(info));\n    }\n}", "target": 0}
{"code": "TEST_F(ExtractorTest, TestPrefixHeaderMatch) {\n  auto headers = TestRequestHeaderMapImpl{{\"prefix-header\", \"AAABBBjwt_token\"}};\n  auto tokens = extractor_->extract(headers);\n  EXPECT_EQ(tokens.size(), 2);\n  EXPECT_TRUE(tokens[0]->isIssuerSpecified(\"issuer5\"));\n  EXPECT_EQ(tokens[0]->token(), \"BBBjwt_token\");\n  EXPECT_TRUE(tokens[1]->isIssuerSpecified(\"issuer6\"));\n  EXPECT_EQ(tokens[1]->token(), \"jwt_token\");\n  tokens[0]->removeJwt(headers);\n  EXPECT_FALSE(headers.get(Http::LowerCaseString(\"prefix-header\")));\n}", "target": 0}
{"code": "static int ac_interception(struct vcpu_svm *svm)\n{\n\tkvm_queue_exception_e(&svm->vcpu, AC_VECTOR, 0);\n\treturn 1;\n}", "target": 0}
{"code": "static HTTPAPI_RESULT ConstructHeadersString(HTTP_HEADERS_HANDLE httpHeadersHandle, wchar_t** httpHeaders)\n{\n    HTTPAPI_RESULT result;\n    size_t headersCount;\n    if (HTTPHeaders_GetHeaderCount(httpHeadersHandle, &headersCount) != HTTP_HEADERS_OK)\n    {\n        result = HTTPAPI_ERROR;\n        LogError(\"HTTPHeaders_GetHeaderCount failed (result = %\" PRI_MU_ENUM \").\", MU_ENUM_VALUE(HTTPAPI_RESULT, result));\n    }\n    else\n    {\n        size_t i;\n        size_t toAlloc = 0;\n        for (i = 0; i < headersCount; i++)\n        {\n            char *temp;\n            if (HTTPHeaders_GetHeader(httpHeadersHandle, i, &temp) == HTTP_HEADERS_OK)\n            {\n                toAlloc += strlen(temp);\n                toAlloc += 2;\n                free(temp);\n            }\n            else\n            {\n                LogError(\"HTTPHeaders_GetHeader failed\");\n                break;\n            }\n        }\n        if (i < headersCount)\n        {\n            result = HTTPAPI_ERROR;\n        }\n        else\n        {\n            char *httpHeadersA;\n            size_t requiredCharactersForHeaders;\n            if ((httpHeadersA = ConcatHttpHeaders(httpHeadersHandle, toAlloc, headersCount)) == NULL)\n            {\n                result = HTTPAPI_ERROR;\n                LogError(\"Cannot concatenate headers\");\n            }\n            else if ((requiredCharactersForHeaders = MultiByteToWideChar(CP_ACP, 0, httpHeadersA, -1, NULL, 0)) == 0)\n            {\n                result = HTTPAPI_STRING_PROCESSING_ERROR;\n                LogError(\"MultiByteToWideChar failed, GetLastError=0x%08x (result = %\" PRI_MU_ENUM \")\", GetLastError(), MU_ENUM_VALUE(HTTPAPI_RESULT, result));\n            }\n            else if ((*httpHeaders = (wchar_t*)malloc((requiredCharactersForHeaders + 1) * sizeof(wchar_t))) == NULL)\n            {\n                result = HTTPAPI_ALLOC_FAILED;\n                LogError(\"Cannot allocate memory (result = %\" PRI_MU_ENUM \")\", MU_ENUM_VALUE(HTTPAPI_RESULT, result));\n            }\n            else if (MultiByteToWideChar(CP_ACP, 0, httpHeadersA, -1, *httpHeaders, (int)requiredCharactersForHeaders) == 0)\n            {\n                result = HTTPAPI_STRING_PROCESSING_ERROR;\n                LogError(\"MultiByteToWideChar failed, GetLastError=0x%08x (result = %\" PRI_MU_ENUM \")\", GetLastError(), MU_ENUM_VALUE(HTTPAPI_RESULT, result));\n                free(*httpHeaders);\n                *httpHeaders = NULL;\n            }\n            else\n            {\n                result = HTTPAPI_OK;\n            }\n            free(httpHeadersA);\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "struct se_portal_group *tcm_loop_make_naa_tpg(\n\tstruct se_wwn *wwn,\n\tstruct config_group *group,\n\tconst char *name)\n{\n\tstruct tcm_loop_hba *tl_hba = container_of(wwn,\n\t\t\tstruct tcm_loop_hba, tl_hba_wwn);\n\tstruct tcm_loop_tpg *tl_tpg;\n\tchar *tpgt_str, *end_ptr;\n\tint ret;\n\tunsigned short int tpgt;\n\ttpgt_str = strstr(name, \"tpgt_\");\n\tif (!tpgt_str) {\n\t\tprintk(KERN_ERR \"Unable to locate \\\"tpgt_#\\\" directory\"\n\t\t\t\t\" group\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\ttpgt_str += 5; \n\ttpgt = (unsigned short int) simple_strtoul(tpgt_str, &end_ptr, 0);\n\tif (tpgt > TL_TPGS_PER_HBA) {\n\t\tprintk(KERN_ERR \"Passed tpgt: %hu exceeds TL_TPGS_PER_HBA:\"\n\t\t\t\t\" %u\\n\", tpgt, TL_TPGS_PER_HBA);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\ttl_tpg = &tl_hba->tl_hba_tpgs[tpgt];\n\ttl_tpg->tl_hba = tl_hba;\n\ttl_tpg->tl_tpgt = tpgt;\n\tret = core_tpg_register(&tcm_loop_fabric_configfs->tf_ops,\n\t\t\twwn, &tl_tpg->tl_se_tpg, tl_tpg,\n\t\t\tTRANSPORT_TPG_TYPE_NORMAL);\n\tif (ret < 0)\n\t\treturn ERR_PTR(-ENOMEM);\n\tprintk(KERN_INFO \"TCM_Loop_ConfigFS: Allocated Emulated %s\"\n\t\t\" Target Port %s,t,0x%04x\\n\", tcm_loop_dump_proto_id(tl_hba),\n\t\tconfig_item_name(&wwn->wwn_group.cg_item), tpgt);\n\treturn &tl_tpg->tl_se_tpg;\n}", "target": 1}
{"code": "int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],\n\t\t     unsigned char multicast_spec, u8 protocol_version)\n{\n\tstruct hsr_priv *hsr;\n\tstruct hsr_port *port;\n\tint res;\n\thsr = netdev_priv(hsr_dev);\n\tINIT_LIST_HEAD(&hsr->ports);\n\tINIT_LIST_HEAD(&hsr->node_db);\n\tINIT_LIST_HEAD(&hsr->self_node_db);\n\tether_addr_copy(hsr_dev->dev_addr, slave[0]->dev_addr);\n\tres = hsr_create_self_node(&hsr->self_node_db, hsr_dev->dev_addr,\n\t\t\t\t   slave[1]->dev_addr);\n\tif (res < 0)\n\t\treturn res;\n\tspin_lock_init(&hsr->seqnr_lock);\n\thsr->sequence_nr = HSR_SEQNR_START;\n\thsr->sup_sequence_nr = HSR_SUP_SEQNR_START;\n\ttimer_setup(&hsr->announce_timer, hsr_announce, 0);\n\ttimer_setup(&hsr->prune_timer, hsr_prune_nodes, 0);\n\tether_addr_copy(hsr->sup_multicast_addr, def_multicast_addr);\n\thsr->sup_multicast_addr[ETH_ALEN - 1] = multicast_spec;\n\thsr->protVersion = protocol_version;\n\tnetif_carrier_off(hsr_dev);\n\tres = hsr_add_port(hsr, hsr_dev, HSR_PT_MASTER);\n\tif (res)\n\t\treturn res;\n\tres = register_netdevice(hsr_dev);\n\tif (res)\n\t\tgoto fail;\n\tres = hsr_add_port(hsr, slave[0], HSR_PT_SLAVE_A);\n\tif (res)\n\t\tgoto fail;\n\tres = hsr_add_port(hsr, slave[1], HSR_PT_SLAVE_B);\n\tif (res)\n\t\tgoto fail;\n\tmod_timer(&hsr->prune_timer, jiffies + msecs_to_jiffies(PRUNE_PERIOD));\n\treturn 0;\nfail:\n\thsr_for_each_port(hsr, port)\n\t\thsr_del_port(port);\n\treturn res;\n}", "target": 1}
{"code": "QString KNSResource::longDescription()\n{\n    QString ret = m_entry.summary();\n    if (m_entry.shortSummary().isEmpty()) {\n        const int newLine = ret.indexOf(QLatin1Char('\\n'));\n        if (newLine<0)\n            ret.clear();\n        else\n            ret = ret.mid(newLine+1).trimmed();\n    }\n    ret.remove(QLatin1Char('\\r'));\n    ret.replace(QStringLiteral(\"[li]\"), QStringLiteral(\"\\n* \"));\n    ret.remove(QRegularExpression(QStringLiteral(\"\\\\[\\\\/?[a-z]*\\\\]\")));\n    static const QRegularExpression urlRegExp(QStringLiteral(\"(^|\\\\s)([-a-zA-Z0-9@:%_\\\\+.~#?&\n    ret.replace(urlRegExp, QStringLiteral(\"<a href=\\\"\\\\2\\\">\\\\2</a>\"));\n    return ret;\n}", "target": 1}
{"code": "void LanLinkProvider::addLink(const QString& deviceId, QSslSocket* socket, NetworkPacket* receivedPacket, LanDeviceLink::ConnectionStarted connectionOrigin)\n{\n    disconnect(socket, &QAbstractSocket::disconnected, socket, &QObject::deleteLater);\n    LanDeviceLink* deviceLink;\n    QMap< QString, LanDeviceLink* >::iterator linkIterator = m_links.find(deviceId);\n    if (linkIterator != m_links.end()) {\n        deviceLink = linkIterator.value();\n        deviceLink->reset(socket, connectionOrigin);\n    } else {\n        deviceLink = new LanDeviceLink(deviceId, this, socket, connectionOrigin);\n        disconnect(socket, &QAbstractSocket::disconnected, socket, &QObject::deleteLater);\n        bool isDeviceTrusted = KdeConnectConfig::instance().trustedDevices().contains(deviceId);\n        if (!isDeviceTrusted && m_links.size() > MAX_UNPAIRED_CONNECTIONS) {\n            qCWarning(KDECONNECT_CORE) << \"Too many unpaired devices to remember them all. Ignoring \" << deviceId;\n            socket->disconnectFromHost();\n            socket->deleteLater();\n            return;\n        }\n        connect(deviceLink, &QObject::destroyed, this, &LanLinkProvider::deviceLinkDestroyed);\n        m_links[deviceId] = deviceLink;\n        if (m_pairingHandlers.contains(deviceId)) {\n            Q_ASSERT(m_pairingHandlers.contains(deviceId));\n            m_pairingHandlers[deviceId]->setDeviceLink(deviceLink);\n        }\n    }\n    Q_EMIT onConnectionReceived(*receivedPacket, deviceLink);\n}", "target": 0}
{"code": "Status genTableRowsForSqliteTable(const fs::path& sqlite_db,\n                                  const std::string& sqlite_query,\n                                  TableRows& results,\n                                  bool respect_locking) {\n  sqlite3* db = nullptr;\n  if (!pathExists(sqlite_db).ok()) {\n    return Status(1, \"Database path does not exist\");\n  }\n  auto rc = sqlite3_open_v2(\n      sqlite_db.string().c_str(),\n      &db,\n      (SQLITE_OPEN_READONLY | SQLITE_OPEN_PRIVATECACHE | SQLITE_OPEN_NOMUTEX),\n      getSystemVFS(respect_locking));\n  if (rc != SQLITE_OK || db == nullptr) {\n    VLOG(1) << \"Cannot open specified database: \"\n            << getStringForSQLiteReturnCode(rc);\n    if (db != nullptr) {\n      sqlite3_close(db);\n    }\n    return Status(1, \"Could not open database\");\n  }\n  rc = sqlite3_set_authorizer(db, &sqliteAuthorizer, nullptr);\n  if (rc != SQLITE_OK) {\n    sqlite3_close(db);\n    auto errMsg =\n        std::string(\"Failed to set sqlite authorizer: \") + sqlite3_errmsg(db);\n    return Status(1, errMsg);\n  }\n  sqlite3_stmt* stmt = nullptr;\n  rc = sqlite3_prepare_v2(db, sqlite_query.c_str(), -1, &stmt, nullptr);\n  if (rc != SQLITE_OK) {\n    sqlite3_close(db);\n    VLOG(1) << \"ATC table: Could not prepare database at path: \" << sqlite_db;\n    return Status(rc, \"Could not prepare database\");\n  }\n  while ((sqlite3_step(stmt)) == SQLITE_ROW) {\n    auto s = genSqliteTableRow(stmt, results, sqlite_db);\n    if (!s.ok()) {\n      break;\n    }\n  }\n  sqlite3_finalize(stmt);\n  sqlite3_close(db);\n  return Status{};\n}", "target": 0}
{"code": "MONGO_EXPORT int bson_append_regex( bson *b, const char *name, const char *pattern, const char *opts ) {\n    const int plen = strlen( pattern )+1;\n    const int olen = strlen( opts )+1;\n    if ( bson_append_estart( b, BSON_REGEX, name, plen + olen ) == BSON_ERROR )\n        return BSON_ERROR;\n    if ( bson_check_string( b, pattern, plen - 1 ) == BSON_ERROR )\n        return BSON_ERROR;\n    bson_append( b , pattern , plen );\n    bson_append( b , opts , olen );\n    return BSON_OK;\n}", "target": 1}
{"code": "static int atalk_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tint rc = -ENOIOCTLCMD;\n\tstruct sock *sk = sock->sk;\n\tvoid __user *argp = (void __user *)arg;\n\tswitch (cmd) {\n\tcase TIOCOUTQ: {\n\t\tlong amount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\n\t\tif (amount < 0)\n\t\t\tamount = 0;\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\tcase TIOCINQ: {\n\t\tstruct sk_buff *skb = skb_peek(&sk->sk_receive_queue);\n\t\tlong amount = 0;\n\t\tif (skb)\n\t\t\tamount = skb->len - sizeof(struct ddpehdr);\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\t\trc = -EPERM;\n\t\tif (capable(CAP_NET_ADMIN))\n\t\t\trc = atrtr_ioctl(cmd, argp);\n\t\tbreak;\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFADDR:\n\tcase SIOCGIFBRDADDR:\n\tcase SIOCATALKDIFADDR:\n\tcase SIOCDIFADDR:\n\tcase SIOCSARP:\t\t\n\tcase SIOCDARP:\t\t\n\t\trtnl_lock();\n\t\trc = atif_ioctl(cmd, argp);\n\t\trtnl_unlock();\n\t\tbreak;\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "void deletesuccessor(file_t **existing, file_t *duplicate, int matchconfirmed,\n      int (*comparef)(file_t *f1, file_t *f2), struct log_info *loginfo)\n{\n  file_t *to_keep;\n  file_t *to_delete;\n  if (comparef(duplicate, *existing) >= 0)\n  {\n    to_keep = *existing;\n    to_delete = duplicate;\n  }\n  else\n  {\n    to_keep = duplicate;\n    to_delete = *existing;\n    *existing = duplicate;\n  }\n  if (!ISFLAG(flags, F_HIDEPROGRESS)) fprintf(stderr, \"\\r%40s\\r\", \" \");\n  if (loginfo)\n    log_begin_set(loginfo);\n  printf(\"   [+] %s\\n\", to_keep->d_name);\n  if (loginfo)\n    log_file_remaining(loginfo, to_keep->d_name);\n  if (matchconfirmed)\n  {\n    if (remove(to_delete->d_name) == 0) {\n      printf(\"   [-] %s\\n\", to_delete->d_name);\n      if (loginfo)\n        log_file_deleted(loginfo, to_delete->d_name);\n    } else {\n      printf(\"   [!] %s \", to_delete->d_name);\n      printf(\"-- unable to delete file!\\n\");\n      if (loginfo)\n        log_file_remaining(loginfo, to_delete->d_name);\n    }\n  }\n  else\n  {\n    printf(\"   [!] %s\\n\", to_delete->d_name);\n    printf(\" -- unable to confirm match; file not deleted!\\n\");\n    if (loginfo)\n      log_file_remaining(loginfo, to_delete->d_name);\n  }\n  if (loginfo)\n    log_end_set(loginfo);\n  printf(\"\\n\");\n}", "target": 1}
{"code": "PHPAPI int php_swoole_unserialize(void *buffer, size_t len, zval *return_value, zval *object_args, long flag)\n{\n    SBucketType type = *(SBucketType*) (buffer);\n    zend_uchar real_type = type.data_type;\n    buffer += sizeof (SBucketType);\n    switch (real_type)\n    {\n        case IS_NULL:\n        case IS_TRUE:\n        case IS_FALSE:\n            Z_TYPE_INFO_P(return_value) = real_type;\n            break;\n        case IS_LONG:\n            swoole_unserialize_long(buffer, return_value, type);\n            Z_TYPE_INFO_P(return_value) = real_type;\n            break;\n        case IS_DOUBLE:\n            swoole_unserialize_raw(buffer, return_value);\n            Z_TYPE_INFO_P(return_value) = real_type;\n            break;\n        case IS_STRING:\n            len -= sizeof (SBucketType);\n            zend_string *str = swoole_unserialize_string(buffer, len);\n            ZVAL_STR(return_value, str);\n            break;\n        case IS_ARRAY:\n        {\n            if (swoole_seria_check_eof(buffer, len) < 0)\n            {\n                  php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"detect the error eof\");\n                  return SW_FALSE;\n            }\n            unser_start = buffer - sizeof (SBucketType);\n            uint32_t num = 0;\n            buffer = get_array_real_len(buffer, type.data_len, &num);\n            if (!swoole_unserialize_arr(buffer, return_value, num, flag))\n            {\n                return SW_FALSE;\n            }\n            break;\n        }\n        case IS_UNDEF:\n            if (swoole_seria_check_eof(buffer, len) < 0)\n            {\n                  php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"detect the error eof\");\n                  return SW_FALSE;\n            }\n            unser_start = buffer - sizeof (SBucketType);\n            if (!swoole_unserialize_object(buffer, return_value, type.data_len, object_args, flag))\n            {\n                return SW_FALSE;\n            }\n            break;\n        default:\n            php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"the type is not supported by swoole serialize.\");\n            return SW_FALSE;\n    }\n    return SW_TRUE;\n}", "target": 1}
{"code": "static void new_huffman_tree(x3f_hufftree_t *HTP, int bits)\n{\n  int leaves = 1 << bits;\n  HTP->free_node_index = 0;\n  HTP->total_node_index = HUF_TREE_MAX_NODES(leaves);\n  HTP->nodes = (x3f_huffnode_t *)calloc(1, HUF_TREE_MAX_NODES(leaves) *\n                                               sizeof(x3f_huffnode_t));\n}", "target": 0}
{"code": "  void resizeTable(HeaderTable& table, uint32_t newCapacity, uint32_t newMax) {\n    table.setCapacity(newCapacity);\n    EXPECT_LE(table.size(), newMax);\n  }", "target": 0}
{"code": "static int encrypt(struct blkcipher_desc *desc,\n\t\t   struct scatterlist *dst, struct scatterlist *src,\n\t\t   unsigned int nbytes)\n{\n\tstruct blkcipher_walk walk;\n\tstruct crypto_blkcipher *tfm = desc->tfm;\n\tstruct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);\n\tint err;\n\tblkcipher_walk_init(&walk, dst, src, nbytes);\n\terr = blkcipher_walk_virt_block(desc, &walk, 64);\n\tsalsa20_ivsetup(ctx, walk.iv);\n\tif (likely(walk.nbytes == nbytes))\n\t{\n\t\tsalsa20_encrypt_bytes(ctx, walk.src.virt.addr,\n\t\t\t\t      walk.dst.virt.addr, nbytes);\n\t\treturn blkcipher_walk_done(desc, &walk, 0);\n\t}\n\twhile (walk.nbytes >= 64) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.src.virt.addr,\n\t\t\t\t      walk.dst.virt.addr,\n\t\t\t\t      walk.nbytes - (walk.nbytes % 64));\n\t\terr = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);\n\t}\n\tif (walk.nbytes) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.src.virt.addr,\n\t\t\t\t      walk.dst.virt.addr, walk.nbytes);\n\t\terr = blkcipher_walk_done(desc, &walk, 0);\n\t}\n\treturn err;\n}", "target": 1}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_rtv_annotations_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tut64 offset = 0;\n\tif (buf_offset + 8 > sz) {\n\t\treturn NULL;\n\t}\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_RUNTIME_VISIBLE_ANNOTATION_ATTR;\n\t\tattr->info.annotation_array.num_annotations = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->info.annotation_array.annotations = r_list_newf (r_bin_java_annotation_free);\n\t\tfor (i = 0; i < attr->info.annotation_array.num_annotations; i++) {\n\t\t\tif (offset >= sz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRBinJavaAnnotation *annotation = r_bin_java_annotation_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (annotation) {\n\t\t\t\toffset += annotation->size;\n\t\t\t\tr_list_append (attr->info.annotation_array.annotations, (void *) annotation);\n\t\t\t}\n\t\t}\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}", "target": 1}
{"code": "mptctl_fw_download(unsigned long arg)\n{\n\tstruct mpt_fw_xfer __user *ufwdl = (void __user *) arg;\n\tstruct mpt_fw_xfer\t kfwdl;\n\tif (copy_from_user(&kfwdl, ufwdl, sizeof(struct mpt_fw_xfer))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::_ioctl_fwdl - \"\n\t\t\t\t\"Unable to copy mpt_fw_xfer struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, ufwdl);\n\t\treturn -EFAULT;\n\t}\n\treturn mptctl_do_fw_download(kfwdl.iocnum, kfwdl.bufp, kfwdl.fwlen);\n}", "target": 1}
{"code": "static void do_popen(FILE *fin, FILE *fout, int afdt_fd) {\n  char buf[BUFFER_SIZE];\n  char cwd[BUFFER_SIZE];\n  if (!fgets(buf, BUFFER_SIZE, fin)) buf[0] = '\\0';\n  bool read_only = (buf[0] == 'r');\n  read_buf(fin, buf);\n  std::string old_cwd = Process::GetCurrentDirectory();\n  read_buf(fin, cwd);\n  if (old_cwd != cwd) {\n    if (chdir(cwd)) {\n      Logger::Warning(\"Light Process failed chdir to %s.\", cwd);\n    }\n  }\n  FILE *f = buf[0] ? ::popen(buf, read_only ? \"r\" : \"w\") : nullptr;\n  if (old_cwd != cwd && chdir(old_cwd.c_str())) {\n  }\n  if (f == nullptr) {\n    Logger::Error(\"Light process failed popen: %d (%s).\", errno,\n                  folly::errnoStr(errno).c_str());\n    fprintf(fout, \"error\\n\");\n    fflush(fout);\n  } else {\n    fprintf(fout, \"success\\n%\" PRId64 \"\\n\", (int64_t)f);\n    fflush(fout);\n    int fd = fileno(f);\n    send_fd(afdt_fd, fd);\n  }\n}", "target": 1}
{"code": "linkaddr_string(netdissect_options *ndo, const u_char *ep,\n\t\tconst unsigned int type, const unsigned int len)\n{\n\tregister u_int i;\n\tregister char *cp;\n\tregister struct enamemem *tp;\n\tif (len == 0)\n\t\treturn (\"<empty>\");\n\tif (type == LINKADDR_ETHER && len == ETHER_ADDR_LEN)\n\t\treturn (etheraddr_string(ndo, ep));\n\tif (type == LINKADDR_FRELAY)\n\t\treturn (q922_string(ndo, ep, len));\n\ttp = lookup_bytestring(ndo, ep, len);\n\tif (tp->e_name)\n\t\treturn (tp->e_name);\n\ttp->e_name = cp = (char *)malloc(len*3);\n\tif (tp->e_name == NULL)\n\t\t(*ndo->ndo_error)(ndo, \"linkaddr_string: malloc\");\n\t*cp++ = hex[*ep >> 4];\n\t*cp++ = hex[*ep++ & 0xf];\n\tfor (i = len-1; i > 0 ; --i) {\n\t\t*cp++ = ':';\n\t\t*cp++ = hex[*ep >> 4];\n\t\t*cp++ = hex[*ep++ & 0xf];\n\t}\n\t*cp = '\\0';\n\treturn (tp->e_name);\n}", "target": 1}
{"code": "struct l2tp_packet_t *l2tp_packet_alloc(int ver, int msg_type,\n\t\t\t\t\tconst struct sockaddr_in *addr, int H,\n\t\t\t\t\tconst char *secret, size_t secret_len)\n{\n\tstruct l2tp_packet_t *pack = mempool_alloc(pack_pool);\n\tif (!pack)\n\t\treturn NULL;\n\tmemset(pack, 0, sizeof(*pack));\n\tINIT_LIST_HEAD(&pack->attrs);\n\tpack->hdr.ver = ver;\n\tpack->hdr.T = 1;\n\tpack->hdr.L = 1;\n\tpack->hdr.S = 1;\n\tmemcpy(&pack->addr, addr, sizeof(*addr));\n\tpack->hide_avps = H;\n\tpack->secret = secret;\n\tpack->secret_len = secret_len;\n\tif (msg_type) {\n\t\tif (l2tp_packet_add_int16(pack, Message_Type, msg_type, 1)) {\n\t\t\tmempool_free(pack);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn pack;\n}", "target": 1}
{"code": "static int count_channels(uint8_t (*layout)[3], int tags)\n{\n    int i, sum = 0;\n    for (i = 0; i < tags; i++) {\n        int syn_ele = layout[i][0];\n        int pos     = layout[i][2];\n        sum += (1 + (syn_ele == TYPE_CPE)) *\n               (pos != AAC_CHANNEL_OFF && pos != AAC_CHANNEL_CC);\n    }\n    return sum;\n}", "target": 0}
{"code": "containsNonAlphaNumDash(const LString &s) {\n\tconst LString::Part *part = s.start;\n\twhile (part != NULL) {\n\t\tfor (unsigned int i = 0; i < part->size; i++) {\n\t\t\tconst char start = part->data[i];\n\t\t\tif (start != '-' && !isAlphaNum(start)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tpart = part->next;\n\t}\n\treturn false;\n}", "target": 0}
{"code": "INST_HANDLER (sbrx) {\t\n\tint b = buf[0] & 0x7;\n\tint r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x01) << 4);\n\tRAnalOp next_op;\n\tavr_op_analyze (anal,\n\t\t\t&next_op,\n\t\t\top->addr + op->size, buf + op->size, len - op->size,\n\t\t\tcpu);\n\tr_strbuf_fini (&next_op.esil);\n\top->jump = op->addr + next_op.size + 2;\n\top->cycles = 1;\t\n\tESIL_A (\"%d,1,<<,r%d,&,\", b, r);\t\t\t\n\tESIL_A ((buf[1] & 0xe) == 0xc\n\t\t\t? \"!,\"\t\t\n\t\t\t: \"!,!,\");\t\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t\n}", "target": 1}
{"code": "void beforeSleep(struct aeEventLoop *eventLoop) {\n    REDIS_NOTUSED(eventLoop);\n    listNode *ln;\n    redisClient *c;\n    if (server.vm_enabled && listLength(server.io_ready_clients)) {\n        listIter li;\n        listRewind(server.io_ready_clients,&li);\n        while((ln = listNext(&li))) {\n            c = ln->value;\n            struct redisCommand *cmd;\n            listDelNode(server.io_ready_clients,ln);\n            c->flags &= (~REDIS_IO_WAIT);\n            server.vm_blocked_clients--;\n            aeCreateFileEvent(server.el, c->fd, AE_READABLE,\n                readQueryFromClient, c);\n            cmd = lookupCommand(c->argv[0]->ptr);\n            redisAssert(cmd != NULL);\n            call(c,cmd);\n            resetClient(c);\n            if (c->querybuf && sdslen(c->querybuf) > 0)\n                processInputBuffer(c);\n        }\n    }\n    while (listLength(server.unblocked_clients)) {\n        ln = listFirst(server.unblocked_clients);\n        redisAssert(ln != NULL);\n        c = ln->value;\n        listDelNode(server.unblocked_clients,ln);\n        if (c->querybuf && sdslen(c->querybuf) > 0)\n            processInputBuffer(c);\n    }\n    flushAppendOnlyFile();\n}", "target": 1}
{"code": "authDigestNonceLink(digest_nonce_h * nonce)\n{\n    assert(nonce != NULL);\n    ++nonce->references;\n    assert(nonce->references != 0); \n    debugs(29, 9, \"nonce '\" << nonce << \"' now at '\" << nonce->references << \"'.\");\n}", "target": 0}
{"code": "static int __init pf_init(void)\n{\t\t\t\t\n\tstruct pf_unit *pf;\n\tint unit;\n\tif (disable)\n\t\treturn -EINVAL;\n\tpf_init_units();\n\tif (pf_detect())\n\t\treturn -ENODEV;\n\tpf_busy = 0;\n\tif (register_blkdev(major, name)) {\n\t\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++)\n\t\t\tput_disk(pf->disk);\n\t\treturn -EBUSY;\n\t}\n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tstruct gendisk *disk = pf->disk;\n\t\tif (!pf->present)\n\t\t\tcontinue;\n\t\tdisk->private_data = pf;\n\t\tadd_disk(disk);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void OmniboxViewWin::BuildContextMenu() {\n  if (context_menu_contents_.get())\n    return;\n  context_menu_contents_.reset(new ui::SimpleMenuModel(this));\n  if (popup_window_mode_) {\n    context_menu_contents_->AddItemWithStringId(IDC_COPY, IDS_COPY);\n  } else {\n    context_menu_contents_->AddItemWithStringId(IDS_UNDO, IDS_UNDO);\n    context_menu_contents_->AddSeparator();\n    context_menu_contents_->AddItemWithStringId(IDC_CUT, IDS_CUT);\n    context_menu_contents_->AddItemWithStringId(IDC_COPY, IDS_COPY);\n    context_menu_contents_->AddItemWithStringId(IDC_PASTE, IDS_PASTE);\n    context_menu_contents_->AddItemWithStringId(IDS_PASTE_AND_GO,\n                                                IDS_PASTE_AND_GO);\n    context_menu_contents_->AddSeparator();\n    context_menu_contents_->AddItemWithStringId(IDS_SELECT_ALL, IDS_SELECT_ALL);\n    context_menu_contents_->AddSeparator();\n    context_menu_contents_->AddItemWithStringId(IDS_EDIT_SEARCH_ENGINES,\n                                                IDS_EDIT_SEARCH_ENGINES);\n  }\n  context_menu_.reset(new views::Menu2(context_menu_contents_.get()));\n}", "target": 0}
{"code": "local block_state deflate_rle(s, flush)\n    deflate_state *s;\n    int flush;\n{\n    int bflush;             \n    uInt prev;              \n    Bytef *scan, *strend;   \n    for (;;) {\n        if (s->lookahead <= MAX_MATCH) {\n            fill_window(s);\n            if (s->lookahead <= MAX_MATCH && flush == Z_NO_FLUSH) {\n                return need_more;\n            }\n            if (s->lookahead == 0) break; \n        }\n        s->match_length = 0;\n        if (s->lookahead >= MIN_MATCH && s->strstart > 0) {\n            scan = s->window + s->strstart - 1;\n            prev = *scan;\n            if (prev == *++scan && prev == *++scan && prev == *++scan) {\n                strend = s->window + s->strstart + MAX_MATCH;\n                do {\n                } while (prev == *++scan && prev == *++scan &&\n                         prev == *++scan && prev == *++scan &&\n                         prev == *++scan && prev == *++scan &&\n                         prev == *++scan && prev == *++scan &&\n                         scan < strend);\n                s->match_length = MAX_MATCH - (uInt)(strend - scan);\n                if (s->match_length > s->lookahead)\n                    s->match_length = s->lookahead;\n            }\n            Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n        }\n        if (s->match_length >= MIN_MATCH) {\n            check_match(s, s->strstart, s->strstart - 1, s->match_length);\n            _tr_tally_dist(s, 1, s->match_length - MIN_MATCH, bflush);\n            s->lookahead -= s->match_length;\n            s->strstart += s->match_length;\n            s->match_length = 0;\n        } else {\n            Tracevv((stderr,\"%c\", s->window[s->strstart]));\n            _tr_tally_lit (s, s->window[s->strstart], bflush);\n            s->lookahead--;\n            s->strstart++;\n        }\n        if (bflush) FLUSH_BLOCK(s, 0);\n    }\n    s->insert = 0;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->last_lit)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}", "target": 1}
{"code": "static bool check_client_passwd(PgSocket *client, const char *passwd)\n{\n\tchar md5[MD5_PASSWD_LEN + 1];\n\tconst char *correct;\n\tPgUser *user = client->auth_user;\n\tif (!user) {\n\t\tslog_error(client, \"Password packet before auth packet?\");\n\t\treturn false;\n\t}\n\tif (!*passwd || !*user->passwd)\n\t\treturn false;\n\tswitch (cf_auth_type) {\n\tcase AUTH_PLAIN:\n\t\treturn strcmp(user->passwd, passwd) == 0;\n\tcase AUTH_CRYPT:\n\t\tcorrect = crypt(user->passwd, (char *)client->tmp_login_salt);\n\t\treturn correct && strcmp(correct, passwd) == 0;\n\tcase AUTH_MD5:\n\t\tif (strlen(passwd) != MD5_PASSWD_LEN)\n\t\t\treturn false;\n\t\tif (!isMD5(user->passwd))\n\t\t\tpg_md5_encrypt(user->passwd, user->name, strlen(user->name), user->passwd);\n\t\tpg_md5_encrypt(user->passwd + 3, (char *)client->tmp_login_salt, 4, md5);\n\t\treturn strcmp(md5, passwd) == 0;\n\t}\n\treturn false;\n}", "target": 0}
{"code": "void show_object_with_name(FILE *out, struct object *obj,\n\t\t\t   struct strbuf *path, const char *component)\n{\n\tchar *name = path_name(path, component);\n\tchar *p;\n\tfprintf(out, \"%s \", oid_to_hex(&obj->oid));\n\tfor (p = name; *p && *p != '\\n'; p++)\n\t\tfputc(*p, out);\n\tfputc('\\n', out);\n\tfree(name);\n}", "target": 1}
{"code": "std::wstring CreateUniqueTempDirectory()\n{\n    wchar_t tmpdir[MAX_PATH+1];\n    if ( GetTempPath(MAX_PATH+1, tmpdir) == 0 )\n        throw Win32Exception(\"Cannot create temporary directory\");\n    for ( ;; )\n    {\n        std::wstring dir(tmpdir);\n        dir += L\"Update-\";\n        UUID uuid;\n        UuidCreate(&uuid);\n        RPC_WSTR uuidStr;\n        RPC_STATUS status = UuidToString(&uuid, &uuidStr);\n        dir += reinterpret_cast<wchar_t*>(uuidStr);\n        RpcStringFree(&uuidStr);\n        if ( CreateDirectory(dir.c_str(), NULL) )\n            return dir;\n        else if ( GetLastError() != ERROR_ALREADY_EXISTS )\n            throw Win32Exception(\"Cannot create temporary directory\");\n    }\n}", "target": 1}
{"code": "void irsock_cleanup(void)\n{\n\tsock_unregister(PF_IRDA);\n\tproto_unregister(&irda_proto);\n}", "target": 0}
{"code": "static void sctp_close(struct sock *sk, long timeout)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_endpoint *ep;\n\tstruct sctp_association *asoc;\n\tstruct list_head *pos, *temp;\n\tunsigned int data_was_unread;\n\tpr_debug(\"%s: sk:%p, timeout:%ld\\n\", __func__, sk, timeout);\n\tlock_sock(sk);\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\tsk->sk_state = SCTP_SS_CLOSING;\n\tep = sctp_sk(sk)->ep;\n\tdata_was_unread = sctp_queue_purge_ulpevents(&sk->sk_receive_queue);\n\tdata_was_unread += sctp_queue_purge_ulpevents(&sctp_sk(sk)->pd_lobby);\n\tlist_for_each_safe(pos, temp, &ep->asocs) {\n\t\tasoc = list_entry(pos, struct sctp_association, asocs);\n\t\tif (sctp_style(sk, TCP)) {\n\t\t\tif (sctp_state(asoc, CLOSED)) {\n\t\t\t\tsctp_unhash_established(asoc);\n\t\t\t\tsctp_association_free(asoc);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (data_was_unread || !skb_queue_empty(&asoc->ulpq.lobby) ||\n\t\t    !skb_queue_empty(&asoc->ulpq.reasm) ||\n\t\t    (sock_flag(sk, SOCK_LINGER) && !sk->sk_lingertime)) {\n\t\t\tstruct sctp_chunk *chunk;\n\t\t\tchunk = sctp_make_abort_user(asoc, NULL, 0);\n\t\t\tif (chunk)\n\t\t\t\tsctp_primitive_ABORT(net, asoc, chunk);\n\t\t} else\n\t\t\tsctp_primitive_SHUTDOWN(net, asoc, NULL);\n\t}\n\tif (sctp_style(sk, TCP) && timeout)\n\t\tsctp_wait_for_close(sk, timeout);\n\trelease_sock(sk);\n\tlocal_bh_disable();\n\tbh_lock_sock(sk);\n\tsock_hold(sk);\n\tsk_common_release(sk);\n\tbh_unlock_sock(sk);\n\tlocal_bh_enable();\n\tsock_put(sk);\n\tSCTP_DBG_OBJCNT_DEC(sock);\n}", "target": 1}
{"code": "void VariableUnserializer::unserializeProp(ObjectData* obj,\n                                           const String& key,\n                                           Class* ctx,\n                                           const String& realKey,\n                                           int nProp) {\n  auto const cls = obj->getVMClass();\n  auto const lookup = cls->getDeclPropSlot(ctx, key.get());\n  auto const slot = lookup.slot;\n  tv_lval t;\n  if (slot == kInvalidSlot || !lookup.accessible) {\n    obj->reserveDynProps(nProp);\n    t = obj->makeDynProp(realKey.get());\n  } else {\n    t = obj->getPropLval(ctx, key.get());\n  }\n  unserializePropertyValue(t, nProp);\n  if (!RuntimeOption::RepoAuthoritative) return;\n  if (!Repo::get().global().HardPrivatePropInference) return;\n  if (UNLIKELY(slot == kInvalidSlot)) return;\n  auto const repoTy = cls->declPropRepoAuthType(slot);\n  if (LIKELY(tvMatchesRepoAuthType(*t, repoTy))) return;\n  if (t.type() == KindOfUninit &&\n      (cls->declProperties()[slot].attrs & AttrLateInit)) {\n    return;\n  }\n  throwUnexpectedType(key, obj, *t);\n}", "target": 0}
{"code": "FragmentedSampleReader::ReadSample(AP4_Sample& sample, AP4_DataBuffer& sample_data)\n{\n    return m_FragmentReader.ReadNextSample(m_TrackId, sample, sample_data);\n}", "target": 0}
{"code": "header_gets (SF_PRIVATE *psf, char *ptr, int bufsize)\n{\tint\t\tk ;\n\tfor (k = 0 ; k < bufsize - 1 ; k++)\n\t{\tif (psf->headindex < psf->headend)\n\t\t{\tptr [k] = psf->header [psf->headindex] ;\n\t\t\tpsf->headindex ++ ;\n\t\t\t}\n\t\telse\n\t\t{\tpsf->headend += psf_fread (psf->header + psf->headend, 1, 1, psf) ;\n\t\t\tptr [k] = psf->header [psf->headindex] ;\n\t\t\tpsf->headindex = psf->headend ;\n\t\t\t} ;\n\t\tif (ptr [k] == '\\n')\n\t\t\tbreak ;\n\t\t} ;\n\tptr [k] = 0 ;\n\treturn k ;\n} ", "target": 1}
{"code": "static struct task_struct *dup_task_struct(struct task_struct *orig)\n{\n\tstruct task_struct *tsk;\n\tstruct thread_info *ti;\n\tunsigned long *stackend;\n\tint err;\n\tprepare_to_copy(orig);\n\ttsk = alloc_task_struct();\n\tif (!tsk)\n\t\treturn NULL;\n\tti = alloc_thread_info(tsk);\n\tif (!ti) {\n\t\tfree_task_struct(tsk);\n\t\treturn NULL;\n\t}\n \terr = arch_dup_task_struct(tsk, orig);\n\tif (err)\n\t\tgoto out;\n\ttsk->stack = ti;\n\terr = prop_local_init_single(&tsk->dirties);\n\tif (err)\n\t\tgoto out;\n\tsetup_thread_stack(tsk, orig);\n\tclear_user_return_notifier(tsk);\n\tclear_tsk_need_resched(tsk);\n\tstackend = end_of_stack(tsk);\n\t*stackend = STACK_END_MAGIC;\t\n#ifdef CONFIG_CC_STACKPROTECTOR\n\ttsk->stack_canary = get_random_int();\n#endif\n\tatomic_set(&tsk->usage,2);\n\tatomic_set(&tsk->fs_excl, 0);\n#ifdef CONFIG_BLK_DEV_IO_TRACE\n\ttsk->btrace_seq = 0;\n#endif\n\ttsk->splice_pipe = NULL;\n\taccount_kernel_stack(ti, 1);\n\treturn tsk;\nout:\n\tfree_thread_info(ti);\n\tfree_task_struct(tsk);\n\treturn NULL;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    OpInputList indices_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"indices\", &indices_list_in));\n    OpInputList values_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"values\", &values_list_in));\n    OpInputList shapes_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"shapes\", &shapes_list_in));\n    OpInputList dense_list_in;\n    OP_REQUIRES_OK(context,\n                   context->input_list(\"dense_inputs\", &dense_list_in));\n    OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,\n                                          shapes_list_in, dense_list_in));\n    std::vector<std::unique_ptr<ColumnInterface<InternalType>>> columns =\n        GenerateColumnsFromInput<InternalType>(indices_list_in, values_list_in,\n                                               shapes_list_in, dense_list_in);\n    const tstring k_feature_separator = \"_X_\";\n    typename CrossTraits<HASHED_OUTPUT, InternalType>::Crosser crosser(\n        columns, num_buckets_, hash_key_, k_feature_separator);\n    Tensor* indices_out;\n    Tensor* values_out;\n    Tensor* shape_out;\n    const int64 batch_size = CalculateBatchSize(shapes_list_in, dense_list_in);\n    std::vector<int64> output_start_indices(batch_size);\n    OP_REQUIRES_OK(\n        context,\n        CreateOutputTensors(columns, batch_size, context, &indices_out,\n                            &values_out, &shape_out, &output_start_indices));\n    typename CrossTraits<HASHED_OUTPUT, InternalType>::Updater updater(\n        output_start_indices, indices_out, values_out);\n    auto do_work = [&columns, crosser, updater](int64 begin, int64 end) {\n      for (int b = begin; b < end; b++) {\n        ProductIterator<InternalType> product_iterator(columns, b);\n        int64 cross_count = 0;\n        while (product_iterator.HasNext()) {\n          const auto permutation = product_iterator.Next();\n          updater.Update(b, cross_count,\n                         crosser.Generate(b, permutation, false));\n          cross_count++;\n        }\n      }\n    };\n    auto* worker_threads = context->device()->tensorflow_cpu_worker_threads();\n    const int kCostPerUnit = 5000 * indices_list_in.size();\n    Shard(worker_threads->num_threads, worker_threads->workers, batch_size,\n          kCostPerUnit, do_work);\n  }", "target": 1}
{"code": "TEST_F(QueryPlannerTest, OrWithExactAndInexact3) {\n    addIndex(BSON(\"a\" << 1));\n    addIndex(BSON(\"b\" << 1));\n    runQuery(\n        fromjson(\"{$or: [{a: {$in: [/z/, /x/]}}, {a: 'w'},\"\n                 \"{b: {$exists: false}}, {b: {$in: ['p']}}]}\"));\n    assertNumSolutions(2U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: {or: {nodes: [\"\n        \"{ixscan: {filter: {$or:[{a:{$in:[/z/, /x/]}}, {a:'w'}]}, \"\n        \"pattern: {a: 1}}}, \"\n        \"{fetch: {filter: {$or:[{b:{$exists:false}}, {b:{$eq:'p'}}]},\"\n        \"node: {ixscan: {filter: null, pattern: {b: 1}}}}}]}}}}\");\n}", "target": 0}
{"code": "deinit_pci(struct vmctx *ctx)\n{\n\tstruct pci_vdev_ops *ops;\n\tstruct businfo *bi;\n\tstruct slotinfo *si;\n\tstruct funcinfo *fi;\n\tint bus, slot, func;\n\tsize_t lowmem;\n\tstruct mem_range mr;\n\tbzero(&mr, sizeof(struct mem_range));\n\tmr.name = \"PCI ECFG\";\n\tmr.base = PCI_EMUL_ECFG_BASE;\n\tmr.size = PCI_EMUL_ECFG_SIZE;\n\tunregister_mem(&mr);\n\tlowmem = vm_get_lowmem_size(ctx);\n\tbzero(&mr, sizeof(struct mem_range));\n\tmr.name = \"PCI hole (32-bit)\";\n\tmr.base = lowmem;\n\tmr.size = (4ULL * 1024 * 1024 * 1024) - lowmem;\n\tunregister_mem_fallback(&mr);\n\tbzero(&mr, sizeof(struct mem_range));\n\tmr.name = \"PCI hole (64-bit)\";\n\tmr.base = PCI_EMUL_MEMBASE64;\n\tmr.size = PCI_EMUL_MEMLIMIT64 - PCI_EMUL_MEMBASE64;\n\tunregister_mem_fallback(&mr);\n\tfor (bus = 0; bus < MAXBUSES; bus++) {\n\t\tbi = pci_businfo[bus];\n\t\tif (bi == NULL)\n\t\t\tcontinue;\n\t\tfor (slot = 0; slot < MAXSLOTS; slot++) {\n\t\t\tsi = &bi->slotinfo[slot];\n\t\t\tfor (func = 0; func < MAXFUNCS; func++) {\n\t\t\t\tfi = &si->si_funcs[func];\n\t\t\t\tif (fi->fi_name == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t\tops = pci_emul_finddev(fi->fi_name);\n\t\t\t\tassert(ops != NULL);\n\t\t\t\tpr_notice(\"pci deinit %s\\n\", fi->fi_name);\n\t\t\t\tpci_emul_deinit(ctx, ops, bus, slot,\n\t\t\t\t    func, fi);\n\t\t\t}\n\t\t}\n\t}\n}", "target": 1}
{"code": "void CreateWindowForRequest(const FrameLoadRequest& request,\n                            LocalFrame& opener_frame,\n                            NavigationPolicy policy) {\n  DCHECK(request.GetResourceRequest().RequestorOrigin() ||\n         (opener_frame.GetDocument() &&\n          opener_frame.GetDocument()->Url().IsEmpty()));\n  if (opener_frame.GetDocument()->PageDismissalEventBeingDispatched() !=\n      Document::kNoDismissal)\n    return;\n  if (opener_frame.GetDocument() &&\n      opener_frame.GetDocument()->IsSandboxed(kSandboxPopups))\n    return;\n  if (policy == kNavigationPolicyCurrentTab)\n    policy = kNavigationPolicyNewForegroundTab;\n  WebWindowFeatures features;\n  features.noopener = request.GetShouldSetOpener() == kNeverSetOpener;\n  bool created;\n  Frame* new_frame =\n      CreateWindowHelper(opener_frame, opener_frame, opener_frame, request,\n                         features, policy, created);\n  if (!new_frame)\n    return;\n  if (request.GetShouldSendReferrer() == kMaybeSendReferrer) {\n    if (new_frame->IsLocalFrame())\n      ToLocalFrame(new_frame)->GetDocument()->SetReferrerPolicy(\n          opener_frame.GetDocument()->GetReferrerPolicy());\n  }\n  FrameLoadRequest new_request(0, request.GetResourceRequest());\n  new_request.SetForm(request.Form());\n  if (new_frame->IsLocalFrame())\n    ToLocalFrame(new_frame)->Loader().Load(new_request);\n}", "target": 0}
{"code": "xml_unload_external_entity(const char *URI, xmlCharEncoding enc)    {\n    return NULL;\n}", "target": 0}
{"code": "XML_SetCommentHandler(XML_Parser parser, XML_CommentHandler handler) {\n  if (parser != NULL)\n    parser->m_commentHandler = handler;\n}", "target": 0}
{"code": "header_put_be_int (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)\n\t{\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} ", "target": 1}
{"code": "void rose_start_t1timer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tdel_timer(&rose->timer);\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->t1;\n\tadd_timer(&rose->timer);\n}", "target": 1}
{"code": "bool ArcMemory::Read(void *Data,size_t Size,size_t &Result)\n{\n  if (!Loaded)\n    return false;\n  Result=(size_t)Min(Size,ArcData.Size()-SeekPos);\n  memcpy(Data,&ArcData[(size_t)SeekPos],Result);\n  SeekPos+=Result;\n  return true;\n}", "target": 0}
{"code": "void RenderWidgetHostViewAura::SoftwareFrameWasFreed(\n    uint32 output_surface_id, unsigned frame_id) {\n  ReleaseSoftwareFrame(output_surface_id, frame_id);\n}", "target": 0}
{"code": "void ServerSecurityFeature::collectOptions(\n    std::shared_ptr<ProgramOptions> options) {\n  options\n      ->addOption(\n          \"--server.harden\",\n          \"lock down REST APIs that reveal version information or server \"\n          \"internals for non-admin users\",\n          new BooleanParameter(&_hardenedRestApi))\n      .setIntroducedIn(30500);\n  options\n      ->addOption(\"--foxx.api\", \"enables Foxx management REST APIs\",\n                  new BooleanParameter(&_enableFoxxApi),\n                  arangodb::options::makeFlags(\n                      arangodb::options::Flags::DefaultNoComponents,\n                      arangodb::options::Flags::OnCoordinator,\n                      arangodb::options::Flags::OnSingle))\n      .setIntroducedIn(30500);\n  options\n      ->addOption(\"--foxx.store\", \"enables Foxx store in web interface\",\n                  new BooleanParameter(&_enableFoxxStore),\n                  arangodb::options::makeFlags(\n                      arangodb::options::Flags::DefaultNoComponents,\n                      arangodb::options::Flags::OnCoordinator,\n                      arangodb::options::Flags::OnSingle))\n      .setIntroducedIn(30500);\n  options\n      ->addOption(\n          \"--foxx.allow-install-from-remote\",\n          \"allow installing Foxx apps from remote URLs other than Github\",\n          new BooleanParameter(&_foxxAllowInstallFromRemote),\n          arangodb::options::makeFlags(\n              arangodb::options::Flags::DefaultNoComponents,\n              arangodb::options::Flags::OnCoordinator,\n              arangodb::options::Flags::OnSingle))\n      .setIntroducedIn(30805);\n}", "target": 0}
{"code": "static struct nlattr *reserve_sfa_size(struct sw_flow_actions **sfa,\n\t\t\t\t       int attr_len, bool log)\n{\n\tstruct sw_flow_actions *acts;\n\tint new_acts_size;\n\tsize_t req_size = NLA_ALIGN(attr_len);\n\tint next_offset = offsetof(struct sw_flow_actions, actions) +\n\t\t\t\t\t(*sfa)->actions_len;\n\tif (req_size <= (ksize(*sfa) - next_offset))\n\t\tgoto out;\n\tnew_acts_size = max(next_offset + req_size, ksize(*sfa) * 2);\n\tif (new_acts_size > MAX_ACTIONS_BUFSIZE) {\n\t\tif ((MAX_ACTIONS_BUFSIZE - next_offset) < req_size) {\n\t\t\tOVS_NLERR(log, \"Flow action size exceeds max %u\",\n\t\t\t\t  MAX_ACTIONS_BUFSIZE);\n\t\t\treturn ERR_PTR(-EMSGSIZE);\n\t\t}\n\t\tnew_acts_size = MAX_ACTIONS_BUFSIZE;\n\t}\n\tacts = nla_alloc_flow_actions(new_acts_size);\n\tif (IS_ERR(acts))\n\t\treturn (void *)acts;\n\tmemcpy(acts->actions, (*sfa)->actions, (*sfa)->actions_len);\n\tacts->actions_len = (*sfa)->actions_len;\n\tacts->orig_len = (*sfa)->orig_len;\n\tkfree(*sfa);\n\t*sfa = acts;\nout:\n\t(*sfa)->actions_len += req_size;\n\treturn  (struct nlattr *) ((unsigned char *)(*sfa) + next_offset);\n}", "target": 1}
{"code": "static void svm_handle_exit_irqoff(struct kvm_vcpu *vcpu)\n{\n\tif (to_svm(vcpu)->vmcb->control.exit_code == SVM_EXIT_INTR)\n\t\tvcpu->arch.at_instruction_boundary = true;\n}", "target": 0}
{"code": "    std::string Converter::computeExifDigest(bool)\n    {\n        return std::string(\"\");\n    }", "target": 0}
{"code": "header_put_le_short (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 2)\n\t{\tpsf->header [psf->headindex++] = x ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\t} ;\n} ", "target": 1}
{"code": "vrrp_print_stats(void)\n{\n\tFILE *file;\n\tfile = fopen (stats_file, \"w\");\n\tif (!file) {\n\t\tlog_message(LOG_INFO, \"Can't open %s (%d: %s)\",\n\t\t\tstats_file, errno, strerror(errno));\n\t\treturn;\n\t}\n\tlist l = vrrp_data->vrrp;\n\telement e;\n\tvrrp_t *vrrp;\n\tfor (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {\n\t\tvrrp = ELEMENT_DATA(e);\n\t\tfprintf(file, \"VRRP Instance: %s\\n\", vrrp->iname);\n\t\tfprintf(file, \"  Advertisements:\\n\");\n\t\tfprintf(file, \"    Received: %\" PRIu64 \"\\n\", vrrp->stats->advert_rcvd);\n\t\tfprintf(file, \"    Sent: %d\\n\", vrrp->stats->advert_sent);\n\t\tfprintf(file, \"  Became master: %d\\n\", vrrp->stats->become_master);\n\t\tfprintf(file, \"  Released master: %d\\n\",\n\t\t\tvrrp->stats->release_master);\n\t\tfprintf(file, \"  Packet Errors:\\n\");\n\t\tfprintf(file, \"    Length: %\" PRIu64 \"\\n\", vrrp->stats->packet_len_err);\n\t\tfprintf(file, \"    TTL: %\" PRIu64 \"\\n\", vrrp->stats->ip_ttl_err);\n\t\tfprintf(file, \"    Invalid Type: %\" PRIu64 \"\\n\",\n\t\t\tvrrp->stats->invalid_type_rcvd);\n\t\tfprintf(file, \"    Advertisement Interval: %\" PRIu64 \"\\n\",\n\t\t\tvrrp->stats->advert_interval_err);\n\t\tfprintf(file, \"    Address List: %\" PRIu64 \"\\n\",\n\t\t\tvrrp->stats->addr_list_err);\n\t\tfprintf(file, \"  Authentication Errors:\\n\");\n\t\tfprintf(file, \"    Invalid Type: %d\\n\",\n\t\t\tvrrp->stats->invalid_authtype);\n#ifdef _WITH_VRRP_AUTH_\n\t\tfprintf(file, \"    Type Mismatch: %d\\n\",\n\t\t\tvrrp->stats->authtype_mismatch);\n\t\tfprintf(file, \"    Failure: %d\\n\",\n\t\t\tvrrp->stats->auth_failure);\n#endif\n\t\tfprintf(file, \"  Priority Zero:\\n\");\n\t\tfprintf(file, \"    Received: %\" PRIu64 \"\\n\", vrrp->stats->pri_zero_rcvd);\n\t\tfprintf(file, \"    Sent: %\" PRIu64 \"\\n\", vrrp->stats->pri_zero_sent);\n\t}\n\tfclose(file);\n}", "target": 1}
{"code": "static int setup_ttydir_console(const struct lxc_rootfs *rootfs,\n\t\t\t const struct lxc_console *console,\n\t\t\t char *ttydir)\n{\n\tchar path[MAXPATHLEN], lxcpath[MAXPATHLEN];\n\tint ret;\n\tret = snprintf(path, sizeof(path), \"%s/dev/%s\", rootfs->mount,\n\t\t       ttydir);\n\tif (ret >= sizeof(path))\n\t\treturn -1;\n\tret = mkdir(path, 0755);\n\tif (ret && errno != EEXIST) {\n\t\tSYSERROR(\"failed with errno %d to create %s\", errno, path);\n\t\treturn -1;\n\t}\n\tINFO(\"created %s\", path);\n\tret = snprintf(lxcpath, sizeof(lxcpath), \"%s/dev/%s/console\",\n\t\t       rootfs->mount, ttydir);\n\tif (ret >= sizeof(lxcpath)) {\n\t\tERROR(\"console path too long\");\n\t\treturn -1;\n\t}\n\tsnprintf(path, sizeof(path), \"%s/dev/console\", rootfs->mount);\n\tret = unlink(path);\n\tif (ret && errno != ENOENT) {\n\t\tSYSERROR(\"error unlinking %s\", path);\n\t\treturn -1;\n\t}\n\tret = creat(lxcpath, 0660);\n\tif (ret==-1 && errno != EEXIST) {\n\t\tSYSERROR(\"error %d creating %s\", errno, lxcpath);\n\t\treturn -1;\n\t}\n\tif (ret >= 0)\n\t\tclose(ret);\n\tif (console->master < 0) {\n\t\tINFO(\"no console\");\n\t\treturn 0;\n\t}\n\tif (mount(console->name, lxcpath, \"none\", MS_BIND, 0)) {\n\t\tERROR(\"failed to mount '%s' on '%s'\", console->name, lxcpath);\n\t\treturn -1;\n\t}\n\tret = snprintf(lxcpath, sizeof(lxcpath), \"%s/console\", ttydir);\n\tif (ret >= sizeof(lxcpath)) {\n\t\tERROR(\"lxc/console path too long\");\n\t\treturn -1;\n\t}\n\tret = symlink(lxcpath, path);\n\tif (ret) {\n\t\tSYSERROR(\"failed to create symlink for console\");\n\t\treturn -1;\n\t}\n\tINFO(\"console has been setup on %s\", lxcpath);\n\treturn 0;\n}", "target": 1}
{"code": "static int __adpt_reset(struct scsi_cmnd* cmd)\n{\n\tadpt_hba* pHba;\n\tint rcode;\n\tchar name[32];\n\tpHba = (adpt_hba*)cmd->device->host->hostdata[0];\n\tstrncpy(name, pHba->name, sizeof(name));\n\tprintk(KERN_WARNING\"%s: Hba Reset: scsi id %d: tid: %d\\n\", name, cmd->device->channel, pHba->channel[cmd->device->channel].tid);\n\trcode =  adpt_hba_reset(pHba);\n\tif(rcode == 0){\n\t\tprintk(KERN_WARNING\"%s: HBA reset complete\\n\", name);\n\t\treturn SUCCESS;\n\t} else {\n\t\tprintk(KERN_WARNING\"%s: HBA reset failed (%x)\\n\", name, rcode);\n\t\treturn FAILED;\n\t}\n}", "target": 1}
{"code": "htp_status_t htp_connp_REQ_PROTOCOL(htp_connp_t *connp) {\n    if (connp->in_tx->is_protocol_0_9 == 0) {\n        connp->in_state = htp_connp_REQ_HEADERS;\n        connp->in_tx->request_progress = HTP_REQUEST_HEADERS;\n    } else {\n        int64_t pos = connp->in_current_read_offset;\n        if (connp->in_current_len > connp->in_current_read_offset + HTTP09_MAX_JUNK_LEN) {\n            htp_log(connp, HTP_LOG_MARK, HTP_LOG_WARNING, 0, \"Request line: missing protocol\");\n            connp->in_tx->is_protocol_0_9 = 0;\n            connp->in_state = htp_connp_REQ_HEADERS;\n            connp->in_tx->request_progress = HTP_REQUEST_HEADERS;\n            return HTP_OK;\n        }\n        while (pos < connp->in_current_len) {\n            if (!htp_is_space(connp->in_current_data[pos])) {\n                htp_log(connp, HTP_LOG_MARK, HTP_LOG_WARNING, 0, \"Request line: missing protocol\");\n                connp->in_tx->is_protocol_0_9 = 0;\n                connp->in_state = htp_connp_REQ_HEADERS;\n                connp->in_tx->request_progress = HTP_REQUEST_HEADERS;\n                return HTP_OK;\n            }\n            pos++;\n        }\n        connp->in_state = htp_connp_REQ_FINALIZE;\n    }\n    return HTP_OK;\n}", "target": 0}
{"code": "static void check_file(char *basename)\n{\n    gdImagePtr im;\n    char *buffer;\n    size_t size;\n    size = read_test_file(&buffer, basename);\n    im = gdImageCreateFromTiffPtr(size, (void *) buffer);\n    gdTestAssert(im == NULL);\n    free(buffer);\n}", "target": 0}
{"code": "int nft_chain_validate_dependency(const struct nft_chain *chain,\n\t\t\t\t  enum nft_chain_type type)\n{\n\tconst struct nft_base_chain *basechain;\n\tif (chain->flags & NFT_BASE_CHAIN) {\n\t\tbasechain = nft_base_chain(chain);\n\t\tif (basechain->type->type != type)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static void unix_copy_addr(struct msghdr *msg, struct sock *sk)\n{\n\tstruct unix_sock *u = unix_sk(sk);\n\tmsg->msg_namelen = 0;\n\tif (u->addr) {\n\t\tmsg->msg_namelen = u->addr->len;\n\t\tmemcpy(msg->msg_name, u->addr->name, u->addr->len);\n\t}\n}", "target": 1}
{"code": "struct clock_source *dce80_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\tif (!clk_src)\n\t\treturn NULL;\n\tif (dce110_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 0}
{"code": "static struct ib_ucontext *hns_roce_alloc_ucontext(struct ib_device *ib_dev,\n\t\t\t\t\t\t   struct ib_udata *udata)\n{\n\tint ret = 0;\n\tstruct hns_roce_ucontext *context;\n\tstruct hns_roce_ib_alloc_ucontext_resp resp;\n\tstruct hns_roce_dev *hr_dev = to_hr_dev(ib_dev);\n\tresp.qp_tab_size = hr_dev->caps.num_qps;\n\tcontext = kmalloc(sizeof(*context), GFP_KERNEL);\n\tif (!context)\n\t\treturn ERR_PTR(-ENOMEM);\n\tret = hns_roce_uar_alloc(hr_dev, &context->uar);\n\tif (ret)\n\t\tgoto error_fail_uar_alloc;\n\tif (hr_dev->caps.flags & HNS_ROCE_CAP_FLAG_RECORD_DB) {\n\t\tINIT_LIST_HEAD(&context->page_list);\n\t\tmutex_init(&context->page_mutex);\n\t}\n\tret = ib_copy_to_udata(udata, &resp, sizeof(resp));\n\tif (ret)\n\t\tgoto error_fail_copy_to_udata;\n\treturn &context->ibucontext;\nerror_fail_copy_to_udata:\n\thns_roce_uar_free(hr_dev, &context->uar);\nerror_fail_uar_alloc:\n\tkfree(context);\n\treturn ERR_PTR(ret);\n}", "target": 1}
{"code": "NOEXPORT char *base64(int encode, const char *in, int len) {\n    BIO *bio, *b64;\n    char *out;\n    int n;\n    b64=BIO_new(BIO_f_base64());\n    if(!b64)\n        return NULL;\n    BIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL);\n    bio=BIO_new(BIO_s_mem());\n    if(!bio) {\n        str_free(b64);\n        return NULL;\n    }\n    if(encode)\n        bio=BIO_push(b64, bio);\n    BIO_write(bio, in, len);\n    (void)BIO_flush(bio); \n    if(encode) {\n        bio=BIO_pop(bio);\n        BIO_free(b64);\n    } else {\n        bio=BIO_push(b64, bio);\n    }\n    n=BIO_pending(bio);\n    out=str_alloc(n<32?32:(size_t)n+1);\n    n=BIO_read(bio, out, n);\n    if(n<0) {\n        BIO_free_all(bio);\n        str_free(out);\n        return NULL;\n    }\n    BIO_free_all(bio);\n    return out;\n}", "target": 1}
{"code": "struct dst_entry *inet_csk_route_req(struct sock *sk,\n\t\t\t\t     const struct request_sock *req)\n{\n\tstruct rtable *rt;\n\tconst struct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ip_options *opt = inet_rsk(req)->opt;\n\tstruct net *net = sock_net(sk);\n\tstruct flowi4 fl4;\n\tflowi4_init_output(&fl4, sk->sk_bound_dev_if, sk->sk_mark,\n\t\t\t   RT_CONN_FLAGS(sk), RT_SCOPE_UNIVERSE,\n\t\t\t   sk->sk_protocol, inet_sk_flowi_flags(sk),\n\t\t\t   (opt && opt->srr) ? opt->faddr : ireq->rmt_addr,\n\t\t\t   ireq->loc_addr, ireq->rmt_port, inet_sk(sk)->inet_sport);\n\tsecurity_req_classify_flow(req, flowi4_to_flowi(&fl4));\n\trt = ip_route_output_flow(net, &fl4, sk);\n\tif (IS_ERR(rt))\n\t\tgoto no_route;\n\tif (opt && opt->is_strictroute && rt->rt_dst != rt->rt_gateway)\n\t\tgoto route_err;\n\treturn &rt->dst;\nroute_err:\n\tip_rt_put(rt);\nno_route:\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_OUTNOROUTES);\n\treturn NULL;\n}", "target": 1}
{"code": "TfLiteStatus GetInputSafe(const TfLiteContext* context, const TfLiteNode* node,\n                          int index, const TfLiteTensor** tensor) {\n  return GetMutableInputSafe(context, node, index, tensor);\n}", "target": 0}
{"code": "  void libraw_recycle(libraw_data_t *lr)\n  {\n    if (!lr)\n      return;\n    LibRaw *ip = (LibRaw *)lr->parent_class;\n    ip->recycle();\n  }", "target": 0}
{"code": "static void mark_verifier_state_clean(struct bpf_verifier_env *env)\n{\n\tenv->scratched_regs = 0U;\n\tenv->scratched_stack_slots = 0ULL;\n}", "target": 0}
{"code": "  DllDef float libraw_get_pre_mul(libraw_data_t *lr, int index)\n  {\n    if (!lr)\n      return EINVAL;\n    return lr->color.pre_mul[LIM(index, 0, 3)];\n  }", "target": 0}
{"code": "int ff_combine_frame(ParseContext *pc, int next, const uint8_t **buf, int *buf_size)\n{\n    if(pc->overread){\n        av_dlog(NULL, \"overread %d, state:%X next:%d index:%d o_index:%d\\n\",\n                pc->overread, pc->state, next, pc->index, pc->overread_index);\n        av_dlog(NULL, \"%X %X %X %X\\n\", (*buf)[0], (*buf)[1], (*buf)[2], (*buf)[3]);\n    }\n    for(; pc->overread>0; pc->overread--){\n        pc->buffer[pc->index++]= pc->buffer[pc->overread_index++];\n    }\n    if(!*buf_size && next == END_NOT_FOUND){\n        next= 0;\n    }\n    pc->last_index= pc->index;\n    if(next == END_NOT_FOUND){\n        void* new_buffer = av_fast_realloc(pc->buffer, &pc->buffer_size, (*buf_size) + pc->index + FF_INPUT_BUFFER_PADDING_SIZE);\n        if(!new_buffer)\n            return AVERROR(ENOMEM);\n        pc->buffer = new_buffer;\n        memcpy(&pc->buffer[pc->index], *buf, *buf_size);\n        pc->index += *buf_size;\n        return -1;\n    }\n    *buf_size=\n    pc->overread_index= pc->index + next;\n    if(pc->index){\n        void* new_buffer = av_fast_realloc(pc->buffer, &pc->buffer_size, next + pc->index + FF_INPUT_BUFFER_PADDING_SIZE);\n        if(!new_buffer)\n            return AVERROR(ENOMEM);\n        pc->buffer = new_buffer;\n        if (next > -FF_INPUT_BUFFER_PADDING_SIZE)\n            memcpy(&pc->buffer[pc->index], *buf,\n                   next + FF_INPUT_BUFFER_PADDING_SIZE);\n        pc->index = 0;\n        *buf= pc->buffer;\n    }\n    for(;next < 0; next++){\n        pc->state = (pc->state<<8) | pc->buffer[pc->last_index + next];\n        pc->state64 = (pc->state64<<8) | pc->buffer[pc->last_index + next];\n        pc->overread++;\n    }\n    if(pc->overread){\n        av_dlog(NULL, \"overread %d, state:%X next:%d index:%d o_index:%d\\n\",\n                pc->overread, pc->state, next, pc->index, pc->overread_index);\n        av_dlog(NULL, \"%X %X %X %X\\n\", (*buf)[0], (*buf)[1],(*buf)[2],(*buf)[3]);\n    }\n    return 0;\n}", "target": 1}
{"code": "static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n                                const uint8_t *buf, int buf_size)\n{\n    ParseContext *pc = &dctx->pc;\n    uint64_t state = pc->state64;\n    int pic_found = pc->frame_start_found;\n    int i = 0;\n    if (!pic_found) {\n        for (i = 0; i < buf_size; i++) {\n            state = (state << 8) | buf[i];\n            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {\n                i++;\n                pic_found = 1;\n                dctx->cur_byte = 0;\n                dctx->remaining = 0;\n                break;\n            }\n        }\n    }\n    if (pic_found && !dctx->remaining) {\n        if (!buf_size) \n            return 0;\n        for (; i < buf_size; i++) {\n            dctx->cur_byte++;\n            state = (state << 8) | buf[i];\n            if (dctx->cur_byte == 24) {\n                dctx->h = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 26) {\n                dctx->w = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 42) {\n                int cid = (state >> 32) & 0xFFFFFFFF;\n                if (cid <= 0)\n                    continue;\n                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);\n                if (dctx->remaining <= 0) {\n                    dctx->remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n                    if (dctx->remaining <= 0)\n                        return dctx->remaining;\n                }\n                if (buf_size - i + 47 >= dctx->remaining) {\n                    int remaining = dctx->remaining;\n                    pc->frame_start_found = 0;\n                    pc->state64 = -1;\n                    dctx->cur_byte = 0;\n                    dctx->remaining = 0;\n                    return remaining;\n                } else {\n                    dctx->remaining -= buf_size;\n                }\n            }\n        }\n    } else if (pic_found) {\n        if (dctx->remaining > buf_size) {\n            dctx->remaining -= buf_size;\n        } else {\n            int remaining = dctx->remaining;\n            pc->frame_start_found = 0;\n            pc->state64 = -1;\n            dctx->cur_byte = 0;\n            dctx->remaining = 0;\n            return remaining;\n        }\n    }\n    pc->frame_start_found = pic_found;\n    pc->state64 = state;\n    return END_NOT_FOUND;\n}", "target": 1}
{"code": "static void vhost_net_ubuf_put_and_wait(struct vhost_net_ubuf_ref *ubufs)\n{\n\tkref_put(&ubufs->kref, vhost_net_zerocopy_done_signal);\n\twait_event(ubufs->wait, !atomic_read(&ubufs->kref.refcount));\n}", "target": 0}
{"code": "get_image_extensions(void)\n{\n\tGHashTable *extensions;\n\tGSList *formats = gdk_pixbuf_get_formats ();\n\tGSList *l;\n\tguint i;\n\tconst char *known_image_formats[] = {\n\t\t\"png\",\n\t\t\"jpg\",\n\t\t\"jpeg\",\n\t\t\"webp\"\n\t};\n\textensions = g_hash_table_new_full (g_str_hash, g_str_equal,\n\t\t\t\t\t    g_free, NULL);\n\tfor (l = formats; l != NULL; l = l->next) {\n\t\tint i;\n\t\tgchar **ext = gdk_pixbuf_format_get_extensions (l->data);\n\t\tfor (i = 0; ext[i] != NULL; i++) {\n\t\t\tg_hash_table_insert (extensions,\n\t\t\t\t\t     g_strdup (ext[i]),\n\t\t\t\t\t     GINT_TO_POINTER (FORMAT_SUPPORTED));\n\t\t}\n\t\tg_strfreev (ext);\n\t}\n\tg_slist_free (formats);\n\tfor (i = 0; i < G_N_ELEMENTS (known_image_formats); i++) {\n\t\tif (!g_hash_table_lookup (extensions, known_image_formats[i])) {\n\t\t\tg_hash_table_insert (extensions,\n\t\t\t\t\t     g_strdup (known_image_formats[i]),\n\t\t\t\t\t     GINT_TO_POINTER (FORMAT_UNSUPPORTED));\n\t\t}\n\t}\n\treturn extensions;\n}", "target": 0}
{"code": "static unsigned int xdr_set_page_base(struct xdr_stream *xdr,\n\t\t\t\t      unsigned int base, unsigned int len)\n{\n\tunsigned int pgnr;\n\tunsigned int maxlen;\n\tunsigned int pgoff;\n\tunsigned int pgend;\n\tvoid *kaddr;\n\tmaxlen = xdr->buf->page_len;\n\tif (base >= maxlen) {\n\t\tbase = maxlen;\n\t\tmaxlen = 0;\n\t} else\n\t\tmaxlen -= base;\n\tif (len > maxlen)\n\t\tlen = maxlen;\n\txdr_stream_page_set_pos(xdr, base);\n\tbase += xdr->buf->page_base;\n\tpgnr = base >> PAGE_SHIFT;\n\txdr->page_ptr = &xdr->buf->pages[pgnr];\n\tkaddr = page_address(*xdr->page_ptr);\n\tpgoff = base & ~PAGE_MASK;\n\txdr->p = (__be32*)(kaddr + pgoff);\n\tpgend = pgoff + len;\n\tif (pgend > PAGE_SIZE)\n\t\tpgend = PAGE_SIZE;\n\txdr->end = (__be32*)(kaddr + pgend);\n\txdr->iov = NULL;\n\treturn len;\n}", "target": 1}
{"code": "static int get_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)\n{\n\treturn usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),\n\t\t\t       RTL8150_REQ_GET_REGS, RTL8150_REQT_READ,\n\t\t\t       indx, 0, data, size, 500);\n}", "target": 1}
{"code": "AP4_HdlrAtom::AP4_HdlrAtom(AP4_UI32        size, \n                           AP4_UI08        version,\n                           AP4_UI32        flags,\n                           AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_HDLR, size, version, flags)\n{\n    AP4_UI32 predefined;\n    stream.ReadUI32(predefined);\n    stream.ReadUI32(m_HandlerType);\n    stream.ReadUI32(m_Reserved[0]);\n    stream.ReadUI32(m_Reserved[1]);\n    stream.ReadUI32(m_Reserved[2]);\n    int name_size = size-(AP4_FULL_ATOM_HEADER_SIZE+20);\n    if (name_size == 0) return;\n    char* name = new char[name_size+1];\n    stream.Read(name, name_size);\n    name[name_size] = '\\0'; \n    if (name[0] == name_size-1) {\n        m_HandlerName = name+1;\n    } else {\n        m_HandlerName = name;\n    }\n    delete[] name;\n}", "target": 1}
{"code": "static void enqueue_huge_page(struct hstate *h, struct page *page)\n{\n\tint nid = page_to_nid(page);\n\tlockdep_assert_held(&hugetlb_lock);\n\tVM_BUG_ON_PAGE(page_count(page), page);\n\tlist_move(&page->lru, &h->hugepage_freelists[nid]);\n\th->free_huge_pages++;\n\th->free_huge_pages_node[nid]++;\n\tSetHPageFreed(page);\n}", "target": 0}
{"code": "find_link_ref(struct link_ref **references, uint8_t *name, size_t length)\n{\n\tunsigned int hash = hash_link_ref(name, length);\n\tstruct link_ref *ref = NULL;\n\tref = references[hash % REF_TABLE_SIZE];\n\twhile (ref != NULL) {\n\t\tif (ref->id == hash)\n\t\t\treturn ref;\n\t\tref = ref->next;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "int ossl_dsa_check_pub_key_partial(const DSA *dsa, const BIGNUM *pub_key, int *ret)\n{\n    if (!dsa_precheck_params(dsa, ret))\n        return 0;\n    return ossl_ffc_validate_public_key_partial(&dsa->params, pub_key, ret)\n           && *ret == 0;\n}", "target": 0}
{"code": "void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)\n\t{\n\tBN_ULONG t1,t2;\n\tBN_ULONG c1,c2,c3;\n\tc1=0;\n\tc2=0;\n\tc3=0;\n\tsqr_add_c(a,0,c1,c2,c3);\n\tr[0]=c1;\n\tc1=0;\n\tsqr_add_c2(a,1,0,c2,c3,c1);\n\tr[1]=c2;\n\tc2=0;\n\tsqr_add_c(a,1,c3,c1,c2);\n\tsqr_add_c2(a,2,0,c3,c1,c2);\n\tr[2]=c3;\n\tc3=0;\n\tsqr_add_c2(a,3,0,c1,c2,c3);\n\tsqr_add_c2(a,2,1,c1,c2,c3);\n\tr[3]=c1;\n\tc1=0;\n\tsqr_add_c(a,2,c2,c3,c1);\n\tsqr_add_c2(a,3,1,c2,c3,c1);\n\tr[4]=c2;\n\tc2=0;\n\tsqr_add_c2(a,3,2,c3,c1,c2);\n\tr[5]=c3;\n\tc3=0;\n\tsqr_add_c(a,3,c1,c2,c3);\n\tr[6]=c1;\n\tr[7]=c2;\n\t}", "target": 1}
{"code": "static inline void inc_slabs_node(struct kmem_cache *s, int node,\n\t\t\t\t\t\t\tint objects) {}", "target": 0}
{"code": "int __cil_build_ast_first_child_helper(__attribute__((unused)) struct cil_tree_node *parse_current, void *extra_args)\n{\n\tstruct cil_args_build *args = extra_args;\n\tstruct cil_tree_node *ast = args->ast;\n\tif (ast->flavor == CIL_TUNABLEIF) {\n\t\targs->tunif = ast;\n\t}\n\tif (ast->flavor == CIL_IN) {\n\t\targs->in = ast;\n\t}\n\tif (ast->flavor == CIL_MACRO) {\n\t\targs->macro = ast;\n\t}\n\tif (ast->flavor == CIL_OPTIONAL) {\n\t\targs->optional = ast;\n\t}\n\tif (ast->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = ast;\n\t}\n\treturn SEPOL_OK;\n}", "target": 0}
{"code": "_dbus_get_monotonic_time (long *tv_sec,\n                          long *tv_usec)\n{\n  _dbus_get_real_time (tv_sec, tv_usec);\n}", "target": 0}
{"code": "static int read_new_config_info (WavpackContext *wpc, WavpackMetadata *wpmd)\n{\n    int bytecnt = wpmd->byte_length;\n    unsigned char *byteptr = wpmd->data;\n    wpc->version_five = 1;      \n    wpc->file_format = wpc->config.qmode = wpc->channel_layout = 0;\n    if (wpc->channel_reordering) {\n        free (wpc->channel_reordering);\n        wpc->channel_reordering = NULL;\n    }\n    if (bytecnt) {\n        wpc->file_format = *byteptr++;\n        wpc->config.qmode = (wpc->config.qmode & ~0xff) | *byteptr++;\n        bytecnt -= 2;\n        if (bytecnt) {\n            int nchans, i;\n            wpc->channel_layout = (int32_t) *byteptr++ << 16;\n            bytecnt--;\n            if (bytecnt) {\n                wpc->channel_layout += nchans = *byteptr++;\n                bytecnt--;\n                if (bytecnt) {\n                    if (bytecnt > nchans)\n                        return FALSE;\n                    wpc->channel_reordering = malloc (nchans);\n                    if (wpc->channel_reordering) {\n                        for (i = 0; i < nchans; ++i)\n                            if (bytecnt) {\n                                wpc->channel_reordering [i] = *byteptr++;\n                                bytecnt--;\n                            }\n                            else\n                                wpc->channel_reordering [i] = i;\n                    }\n                }\n            }\n            else\n                wpc->channel_layout += wpc->config.num_channels;\n        }\n    }\n    return TRUE;\n}", "target": 1}
{"code": "gerb_fclose(gerb_file_t *fd)\n{\n    if (fd) {\n        g_free(fd->filename);\n#ifdef HAVE_SYS_MMAN_H\n\tif (munmap(fd->data, fd->datalen) < 0)\n\t    GERB_FATAL_ERROR(\"munmap: %s\", strerror(errno));\n#else\n\tg_free(fd->data);\n#endif   \n\tif (fclose(fd->fd) == EOF)\n\t    GERB_FATAL_ERROR(\"fclose: %s\", strerror(errno));\n\tg_free(fd);\n    }\n    return;\n} ", "target": 0}
{"code": "PHPAPI zend_string *php_escape_shell_cmd(char *str)\n{\n\tregister int x, y, l = (int)strlen(str);\n\tsize_t estimate = (2 * l) + 1;\n\tzend_string *cmd;\n#ifndef PHP_WIN32\n\tchar *p = NULL;\n#endif\n\tcmd = zend_string_alloc(2 * l, 0);\n\tfor (x = 0, y = 0; x < l; x++) {\n\t\tint mb_len = php_mblen(str + x, (l - x));\n\t\tif (mb_len < 0) {\n\t\t\tcontinue;\n\t\t} else if (mb_len > 1) {\n\t\t\tmemcpy(ZSTR_VAL(cmd) + y, str + x, mb_len);\n\t\t\ty += mb_len;\n\t\t\tx += mb_len - 1;\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (str[x]) {\n#ifndef PHP_WIN32\n\t\t\tcase '\"':\n\t\t\tcase '\\'':\n\t\t\t\tif (!p && (p = memchr(str + x + 1, str[x], l - x - 1))) {\n\t\t\t\t} else if (p && *p == str[x]) {\n\t\t\t\t\tp = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tZSTR_VAL(cmd)[y++] = '\\\\';\n\t\t\t\t}\n\t\t\t\tZSTR_VAL(cmd)[y++] = str[x];\n\t\t\t\tbreak;\n#else\n\t\t\tcase '%':\n\t\t\tcase '!':\n\t\t\tcase '\"':\n\t\t\tcase '\\'':\n#endif\n\t\t\tcase '#': \n\t\t\tcase '&':\n\t\t\tcase ';':\n\t\t\tcase '`':\n\t\t\tcase '|':\n\t\t\tcase '*':\n\t\t\tcase '?':\n\t\t\tcase '~':\n\t\t\tcase '<':\n\t\t\tcase '>':\n\t\t\tcase '^':\n\t\t\tcase '(':\n\t\t\tcase ')':\n\t\t\tcase '[':\n\t\t\tcase ']':\n\t\t\tcase '{':\n\t\t\tcase '}':\n\t\t\tcase '$':\n\t\t\tcase '\\\\':\n\t\t\tcase '\\x0A': \n\t\t\tcase '\\xFF':\n#ifdef PHP_WIN32\n\t\t\t\tZSTR_VAL(cmd)[y++] = '^';\n#else\n\t\t\t\tZSTR_VAL(cmd)[y++] = '\\\\';\n#endif\n\t\t\tdefault:\n\t\t\t\tZSTR_VAL(cmd)[y++] = str[x];\n\t\t}\n\t}\n\tZSTR_VAL(cmd)[y] = '\\0';\n\tif ((estimate - y) > 4096) {\n\t\tcmd = zend_string_truncate(cmd, y, 0);\n\t}\n\tZSTR_LEN(cmd) = y;\n\treturn cmd;\n}", "target": 1}
{"code": "static int start_netprobe(const struct sa *turn_srv,\n\t\t\t  int proto, bool secure,\n\t\t\t  const char *username, const char *password)\n{\n\tint err;\n\tre_printf(\"starting netprobe with TURN%s-server %J\"\n\t\t  \" (proto=%s) ..\\n\",\n\t\t  secure ? \"S\" : \"\", turn_srv,\n\t\t  net_proto2name(proto));\n#define PACKET_COUNT 50\n#define PACKET_INTERVAL 20\n\tif (netprobec >= ARRAY_SIZE(netprobev)) {\n\t\twarning(\"reached maximum %zu netprobes\\n\", netprobec);\n\t\treturn 0;\n\t}\n\tnetprobev[netprobec].turn_srv = *turn_srv;\n\tnetprobev[netprobec].secure = secure;\n\tnetprobev[netprobec].proto = proto;\n\terr = netprobe_alloc(&netprobev[netprobec].np,\n\t\t\t     turn_srv, proto, secure,\n\t\t\t     username, password,\n\t\t\t     PACKET_COUNT, PACKET_INTERVAL,\n\t\t\t     netprobe_handler, (void *)netprobec);\n\tif (err) {\n\t\twarning(\"could not create netprobe (%m)\\n\", err);\n\t\tgoto out;\n\t}\n\tnetprobec++;\n out:\n\treturn err;\n}", "target": 0}
{"code": "void* CxImage::GetDIBLimit() const\n{\n    return pDibLimit;\n}", "target": 0}
{"code": "setup_arch (char **cmdline_p)\n{\n\tunw_init();\n\tia64_patch_vtop((u64) __start___vtop_patchlist, (u64) __end___vtop_patchlist);\n\t*cmdline_p = __va(ia64_boot_param->command_line);\n\tstrlcpy(boot_command_line, *cmdline_p, COMMAND_LINE_SIZE);\n\tefi_init();\n\tio_port_init();\n#ifdef CONFIG_IA64_GENERIC\n\tmachvec_init_from_cmdline(*cmdline_p);\n#endif\n\tparse_early_param();\n\tif (early_console_setup(*cmdline_p) == 0)\n\t\tmark_bsp_online();\n#ifdef CONFIG_ACPI\n\tacpi_table_init();\n# ifdef CONFIG_ACPI_NUMA\n\tacpi_numa_init();\n\tper_cpu_scan_finalize((cpus_weight(early_cpu_possible_map) == 0 ?\n\t\t32 : cpus_weight(early_cpu_possible_map)), additional_cpus);\n# endif\n#else\n# ifdef CONFIG_SMP\n\tsmp_build_cpu_map();\t\n# endif\n#endif \n\tfind_memory();\n\tia64_sal_init(__va(efi.sal_systab));\n#ifdef CONFIG_ITANIUM\n\tia64_patch_rse((u64) __start___rse_patchlist, (u64) __end___rse_patchlist);\n#else\n\t{\n\t\tu64 num_phys_stacked;\n\t\tif (ia64_pal_rse_info(&num_phys_stacked, 0) == 0 && num_phys_stacked > 96)\n\t\t\tia64_patch_rse((u64) __start___rse_patchlist, (u64) __end___rse_patchlist);\n\t}\n#endif\n#ifdef CONFIG_SMP\n\tcpu_physical_id(0) = hard_smp_processor_id();\n#endif\n\tcpu_init();\t\n\tmmu_context_init();\t\n\tcheck_sal_cache_flush();\n#ifdef CONFIG_ACPI\n\tacpi_boot_init();\n#endif\n#ifdef CONFIG_VT\n\tif (!conswitchp) {\n# if defined(CONFIG_DUMMY_CONSOLE)\n\t\tconswitchp = &dummy_con;\n# endif\n# if defined(CONFIG_VGA_CONSOLE)\n\t\tif (efi_mem_type(0xA0000) != EFI_CONVENTIONAL_MEMORY)\n\t\t\tconswitchp = &vga_con;\n# endif\n\t}\n#endif\n\tif (!nomca)\n\t\tia64_mca_init();\n\tplatform_setup(cmdline_p);\n\tpaging_init();\n}", "target": 0}
{"code": "int razer_get_usb_response(struct usb_device *usb_dev, uint report_index, struct razer_report* request_report, uint response_index, struct razer_report* response_report, ulong wait_min, ulong wait_max)\n{\n    uint request = HID_REQ_GET_REPORT; \n    uint request_type = USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN; \n    uint value = 0x300;\n    uint size = RAZER_USB_REPORT_LEN; \n    int len;\n    int retval;\n    int result = 0;\n    char *buf;\n    buf = kzalloc(sizeof(struct razer_report), GFP_KERNEL);\n    if (buf == NULL)\n        return -ENOMEM;\n    retval = razer_send_control_msg(usb_dev, request_report, report_index, wait_min, wait_max);\n    len = usb_control_msg(usb_dev, usb_rcvctrlpipe(usb_dev, 0),\n                          request,         \n                          request_type,    \n                          value,           \n                          response_index,  \n                          buf,             \n                          size,\n                          USB_CTRL_SET_TIMEOUT);\n    memcpy(response_report, buf, sizeof(struct razer_report));\n    kfree(buf);\n    if(len != 90) {\n        printk(KERN_WARNING \"razer driver: Invalid USB response. USB Report length: %d\\n\", len);\n        result = 1;\n    }\n    if (WARN_ONCE(response_report->data_size > ARRAY_SIZE(response_report->arguments),\n                  \"Field data_size %d in response is bigger than arguments\\n\",\n                  response_report->data_size)) {\n        response_report->data_size = ARRAY_SIZE(response_report->arguments);\n        return -EINVAL;\n    }\n    return result;\n}", "target": 0}
{"code": "    const char* Image::typeName(uint16_t tag) const\n    {\n        const char* result = nullptr;\n        switch (tag ) {\n            case Exiv2::unsignedByte     : result = \"BYTE\"      ; break;\n            case Exiv2::asciiString      : result = \"ASCII\"     ; break;\n            case Exiv2::unsignedShort    : result = \"SHORT\"     ; break;\n            case Exiv2::unsignedLong     : result = \"LONG\"      ; break;\n            case Exiv2::unsignedRational : result = \"RATIONAL\"  ; break;\n            case Exiv2::signedByte       : result = \"SBYTE\"     ; break;\n            case Exiv2::undefined        : result = \"UNDEFINED\" ; break;\n            case Exiv2::signedShort      : result = \"SSHORT\"    ; break;\n            case Exiv2::signedLong       : result = \"SLONG\"     ; break;\n            case Exiv2::signedRational   : result = \"SRATIONAL\" ; break;\n            case Exiv2::tiffFloat        : result = \"FLOAT\"     ; break;\n            case Exiv2::tiffDouble       : result = \"DOUBLE\"    ; break;\n            case Exiv2::tiffIfd          : result = \"IFD\"       ; break;\n            default                      : result = \"unknown\"   ; break;\n        }\n        return result;\n    }", "target": 0}
{"code": "static struct sctp_auth_bytes *sctp_auth_make_key_vector(\n\t\t\tsctp_random_param_t *random,\n\t\t\tsctp_chunks_param_t *chunks,\n\t\t\tsctp_hmac_algo_param_t *hmacs,\n\t\t\tgfp_t gfp)\n{\n\tstruct sctp_auth_bytes *new;\n\t__u32\tlen;\n\t__u32\toffset = 0;\n\tlen = ntohs(random->param_hdr.length) + ntohs(hmacs->param_hdr.length);\n        if (chunks)\n\t\tlen += ntohs(chunks->param_hdr.length);\n\tnew = kmalloc(sizeof(struct sctp_auth_bytes) + len, gfp);\n\tif (!new)\n\t\treturn NULL;\n\tnew->len = len;\n\tmemcpy(new->data, random, ntohs(random->param_hdr.length));\n\toffset += ntohs(random->param_hdr.length);\n\tif (chunks) {\n\t\tmemcpy(new->data + offset, chunks,\n\t\t\tntohs(chunks->param_hdr.length));\n\t\toffset += ntohs(chunks->param_hdr.length);\n\t}\n\tmemcpy(new->data + offset, hmacs, ntohs(hmacs->param_hdr.length));\n\treturn new;\n}", "target": 0}
{"code": "STACK_OF(PKCS12_SAFEBAG) *PKCS12_unpack_p7data(PKCS7 *p7)\n{\n    if (!PKCS7_type_is_data(p7)) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_CONTENT_TYPE_NOT_DATA);\n        return NULL;\n    }\n    if (p7->d.data == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_DECODE_ERROR);\n        return NULL;\n    }\n    return ASN1_item_unpack(p7->d.data, ASN1_ITEM_rptr(PKCS12_SAFEBAGS));\n}", "target": 0}
{"code": "sort_page_names (gconstpointer a,\n                 gconstpointer b)\n{\n\tconst char *name_1, *name_2;\n\tgchar *key_1, *key_2;\n\tgboolean sort_last_1, sort_last_2;\n\tint compare;\n\tname_1 = * (const char **) a;\n\tname_2 = * (const char **) b;\n\t#define SORT_LAST_CHAR1 '.'\n\t#define SORT_LAST_CHAR2 '#'\n\tsort_last_1 = name_1[0] == SORT_LAST_CHAR1 || name_1[0] == SORT_LAST_CHAR2;\n\tsort_last_2 = name_2[0] == SORT_LAST_CHAR1 || name_2[0] == SORT_LAST_CHAR2;\n\t#undef SORT_LAST_CHAR1\n\t#undef SORT_LAST_CHAR2\n\tif (sort_last_1 && !sort_last_2)\n\t{\n\t\tcompare = +1;\n\t}\n\telse if (!sort_last_1 && sort_last_2)\n\t{\n\t\tcompare = -1;\n\t} \n\telse\n\t{\n\t\tkey_1 = g_utf8_collate_key_for_filename (name_1, -1);\n\t\tkey_2 = g_utf8_collate_key_for_filename (name_2, -1);\n\t\tcompare = strcmp (key_1, key_2);\n\t\tg_free (key_1);\n\t\tg_free (key_2);\n\t}\n\treturn compare;\n}", "target": 1}
{"code": "inline int TensorProtoDataSize<tstring>(const TensorProto& t) {\n  return t.string_val_size();\n}", "target": 0}
{"code": "void CefVideoConsumerOSR::OnFrameCaptured(\n    media::mojom::VideoBufferHandlePtr data,\n    media::mojom::VideoFrameInfoPtr info,\n    const gfx::Rect& content_rect,\n    mojo::PendingRemote<viz::mojom::FrameSinkVideoConsumerFrameCallbacks>\n        callbacks) {\n  ScopedVideoFrameDone scoped_done(std::move(callbacks));\n  if (info->pixel_format != media::PIXEL_FORMAT_ARGB) {\n    DLOG(ERROR) << \"Unsupported pixel format \" << info->pixel_format;\n    return;\n  }\n  CHECK(data->is_read_only_shmem_region());\n  base::ReadOnlySharedMemoryRegion& shmem_region =\n      data->get_read_only_shmem_region();\n  DCHECK(shmem_region.IsValid());\n  base::ReadOnlySharedMemoryMapping mapping = shmem_region.Map();\n  if (!mapping.IsValid()) {\n    DLOG(ERROR) << \"Shared memory mapping failed.\";\n    return;\n  }\n  if (mapping.size() <\n      media::VideoFrame::AllocationSize(info->pixel_format, info->coded_size)) {\n    DLOG(ERROR) << \"Shared memory size was less than expected.\";\n    return;\n  }\n  void* const pixels = const_cast<void*>(mapping.memory());\n  media::VideoFrameMetadata metadata = info->metadata;\n  gfx::Rect damage_rect;\n  if (bounds_in_pixels_) {\n    damage_rect = gfx::Rect(info->coded_size);\n    damage_rect.Intersect(*bounds_in_pixels_);\n    bounds_in_pixels_ = absl::nullopt;\n  } else {\n    if (metadata.capture_update_rect) {\n      damage_rect = *metadata.capture_update_rect;\n    }\n    if (damage_rect.IsEmpty()) {\n      damage_rect = gfx::Rect(info->coded_size);\n    }\n  }\n  view_->OnPaint(damage_rect, info->coded_size, pixels);\n}", "target": 0}
{"code": "is_contained_by (asection *section, Elf_Internal_Phdr *segment,\n\t\t bfd_vma paddr, bfd_vma vaddr, unsigned int opb,\n\t\t const struct elf_backend_data *bed)\n{\n  bfd_vma seg_addr = !bed->want_p_paddr_set_to_zero ? paddr : vaddr;\n  bfd_vma addr = !bed->want_p_paddr_set_to_zero ? section->lma : section->vma;\n  bfd_vma octet;\n  if (_bfd_mul_overflow (addr, opb, &octet))\n    return false;\n  return (octet >= seg_addr\n\t  && segment_size (segment) >= section_size (section, segment)\n\t  && (octet - seg_addr\n\t      <= segment_size (segment) - section_size (section, segment)));\n}", "target": 0}
{"code": "flush_buf_tls(tor_tls_t *tls, buf_t *buf, size_t flushlen,\n              size_t *buf_flushlen)\n{\n  int r;\n  size_t flushed = 0;\n  ssize_t sz;\n  tor_assert(buf_flushlen);\n  tor_assert(*buf_flushlen <= buf->datalen);\n  tor_assert(flushlen <= *buf_flushlen);\n  sz = (ssize_t) flushlen;\n  check_no_tls_errors();\n  check();\n  do {\n    size_t flushlen0;\n    if (buf->head) {\n      if ((ssize_t)buf->head->datalen >= sz)\n        flushlen0 = sz;\n      else\n        flushlen0 = buf->head->datalen;\n    } else {\n      flushlen0 = 0;\n    }\n    r = flush_chunk_tls(tls, buf, buf->head, flushlen0, buf_flushlen);\n    check();\n    if (r < 0)\n      return r;\n    flushed += r;\n    sz -= r;\n    if (r == 0) \n      break;\n  } while (sz > 0);\n  tor_assert(flushed < INT_MAX);\n  return (int)flushed;\n}", "target": 0}
{"code": "TfLiteStatus Resize(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteLSHProjectionParams*>(node->builtin_data);\n  TF_LITE_ENSURE(context, NumInputs(node) == 2 || NumInputs(node) == 3);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* hash;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &hash));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(hash), 2);\n  TF_LITE_ENSURE(context, SizeOfDimension(hash, 1) <= 32);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &input));\n  TF_LITE_ENSURE(context, NumDimensions(input) >= 1);\n  TF_LITE_ENSURE(context, SizeOfDimension(input, 0) >= 1);\n  if (NumInputs(node) == 3) {\n    const TfLiteTensor* weight;\n    TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &weight));\n    TF_LITE_ENSURE_EQ(context, NumDimensions(weight), 1);\n    TF_LITE_ENSURE_EQ(context, SizeOfDimension(weight, 0),\n                      SizeOfDimension(input, 0));\n  }\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  TfLiteIntArray* outputSize = TfLiteIntArrayCreate(1);\n  switch (params->type) {\n    case kTfLiteLshProjectionSparse:\n      outputSize->data[0] = SizeOfDimension(hash, 0);\n      break;\n    case kTfLiteLshProjectionDense:\n      outputSize->data[0] = SizeOfDimension(hash, 0) * SizeOfDimension(hash, 1);\n      break;\n    default:\n      return kTfLiteError;\n  }\n  return context->ResizeTensor(context, output, outputSize);\n}", "target": 0}
{"code": "static inline const unsigned char *fsnotify_oldname_init(const unsigned char *name)\n{\n\treturn kstrdup(name, GFP_KERNEL);\n}", "target": 1}
{"code": "int main(void)\n{\n    size_t failedTestCount = 0;\n    RUN_TEST_SUITE(link_ut, failedTestCount);\n    return (int)failedTestCount;\n}", "target": 0}
{"code": "get_matching_model_microcode(int cpu, unsigned long start,\n\t\t\t     void *data, size_t size,\n\t\t\t     struct mc_saved_data *mc_saved_data,\n\t\t\t     unsigned long *mc_saved_in_initrd,\n\t\t\t     struct ucode_cpu_info *uci)\n{\n\tu8 *ucode_ptr = data;\n\tunsigned int leftover = size;\n\tenum ucode_state state = UCODE_OK;\n\tunsigned int mc_size;\n\tstruct microcode_header_intel *mc_header;\n\tstruct microcode_intel *mc_saved_tmp[MAX_UCODE_COUNT];\n\tunsigned int mc_saved_count = mc_saved_data->mc_saved_count;\n\tint i;\n\twhile (leftover) {\n\t\tmc_header = (struct microcode_header_intel *)ucode_ptr;\n\t\tmc_size = get_totalsize(mc_header);\n\t\tif (!mc_size || mc_size > leftover ||\n\t\t\tmicrocode_sanity_check(ucode_ptr, 0) < 0)\n\t\t\tbreak;\n\t\tleftover -= mc_size;\n\t\tif (matching_model_microcode(mc_header, uci->cpu_sig.sig) !=\n\t\t\t UCODE_OK) {\n\t\t\tucode_ptr += mc_size;\n\t\t\tcontinue;\n\t\t}\n\t\t_save_mc(mc_saved_tmp, ucode_ptr, &mc_saved_count);\n\t\tucode_ptr += mc_size;\n\t}\n\tif (leftover) {\n\t\tstate = UCODE_ERROR;\n\t\tgoto out;\n\t}\n\tif (mc_saved_count == 0) {\n\t\tstate = UCODE_NFOUND;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < mc_saved_count; i++)\n\t\tmc_saved_in_initrd[i] = (unsigned long)mc_saved_tmp[i] - start;\n\tmc_saved_data->mc_saved_count = mc_saved_count;\nout:\n\treturn state;\n}", "target": 1}
{"code": "int ossl_dsa_check_pub_key(const DSA *dsa, const BIGNUM *pub_key, int *ret)\n{\n    if (!dsa_precheck_params(dsa, ret))\n        return 0;\n    return ossl_ffc_validate_public_key(&dsa->params, pub_key, ret)\n           && *ret == 0;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* const context) override {\n    const Tensor* node_ids_t;\n    OP_REQUIRES_OK(context, context->input(\"node_ids\", &node_ids_t));\n    const auto node_ids = node_ids_t->vec<int32>();\n    const Tensor* gradients_t;\n    OP_REQUIRES_OK(context, context->input(\"gradients\", &gradients_t));\n    const auto gradients = gradients_t->matrix<float>();\n    OP_REQUIRES(\n        context, node_ids.size() == gradients.dimension(0),\n        errors::InvalidArgument(\n            \"node_ids size should match 0th dim of gradients. node ids \"\n            \"size: \",\n            node_ids.size(), \", gradients dim0: \", gradients.dimension(0)));\n    const Tensor* hessians_t;\n    OP_REQUIRES_OK(context, context->input(\"hessians\", &hessians_t));\n    const auto hessians = hessians_t->matrix<float>();\n    OpInputList bucketized_features_list;\n    OP_REQUIRES_OK(context, context->input_list(\"bucketized_features_list\",\n                                                &bucketized_features_list));\n    const int64_t batch_size = node_ids_t->dim_size(0);\n    Tensor temp_stats_double_t;\n    OP_REQUIRES_OK(context, context->allocate_temp(\n                                DT_DOUBLE,\n                                {num_features_, max_splits_, num_buckets_, 2},\n                                &temp_stats_double_t));\n    auto temp_stats_double = temp_stats_double_t.tensor<double, 4>();\n    temp_stats_double.setZero();\n    for (int feature_idx = 0; feature_idx < num_features_; ++feature_idx) {\n      const auto& features = bucketized_features_list[feature_idx].vec<int32>();\n      for (int i = 0; i < batch_size; ++i) {\n        const int32_t node = node_ids(i);\n        const int32_t bucket = features(i);\n        temp_stats_double(feature_idx, node, bucket, 0) += gradients(i, 0);\n        temp_stats_double(feature_idx, node, bucket, 1) += hessians(i, 0);\n      }\n    }\n    Tensor* output_stats_summary_t = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                \"stats_summary\", temp_stats_double_t.shape(),\n                                &output_stats_summary_t));\n    output_stats_summary_t->tensor<float, 4>() =\n        temp_stats_double.template cast<float>();\n  }", "target": 0}
{"code": "create_separator(void)\n{\n\tstruct defer_node *result;\n\tresult = malloc(sizeof(struct defer_node));\n\tif (result == NULL)\n\t\treturn NULL;\n\tresult->type = DNT_SEPARATOR;\n\treturn result;\n}", "target": 0}
{"code": "int ecall_start(struct ecall *ecall, enum icall_call_type call_type,\n\t\tbool audio_cbr)\n{\n\tint err;\n\tinfo(\"ecall(%p): start\\n\", ecall);\n\tif (!ecall)\n\t\treturn EINVAL;\n#ifdef ECALL_CBR_ALWAYS_ON\n\taudio_cbr = true;\n#endif\n\tif (ecall->econn) {\n\t\tif (ECONN_PENDING_INCOMING == econn_current_state(ecall->econn)) {\n\t\t\treturn ecall_answer(ecall, call_type, audio_cbr);\n\t\t}\n\t\telse {\n\t\t\twarning(\"ecall: start: already in progress (econn=%s)\\n\",\n\t\t\t\teconn_state_name(econn_current_state(ecall->econn)));\n\t\t\treturn EALREADY;\n\t\t}\n\t}\n#if 0\n\tif (ecall->turnc == 0) {\n\t\twarning(\"ecall: start: no TURN servers -- cannot start\\n\");\n\t\treturn EINTR;\n\t}\n#endif\n\tecall->call_type = call_type;\n\terr = ecall_create_econn(ecall);\n\tif (err) {\n\t\twarning(\"ecall: start: create_econn failed: %m\\n\", err);\n\t\treturn err;\n\t}\n\teconn_set_state(ecall_get_econn(ecall), ECONN_PENDING_OUTGOING);\n\terr = alloc_flow(ecall, ASYNC_OFFER, ecall->call_type, audio_cbr);\n\tif (err) {\n\t\twarning(\"ecall: start: alloc_flow failed: %m\\n\", err);\n\t\tgoto out;\n\t}\n\tIFLOW_CALL(ecall->flow, set_audio_cbr, audio_cbr);\n\tif (ecall->props_local &&\n\t    (call_type == ICALL_CALL_TYPE_VIDEO\n\t     && ecall->vstate == ICALL_VIDEO_STATE_STARTED)) {\n\t\tconst char *vstate_string = \"true\";\n\t\tint err2 = econn_props_update(ecall->props_local,\n\t\t\t\t\t      \"videosend\", vstate_string);\n\t\tif (err2) {\n\t\t\twarning(\"ecall(%p): econn_props_update(videosend)\",\n\t\t\t\t\" failed (%m)\\n\", ecall, err2);\n\t\t}\n\t}\n\tecall->sdp.async = ASYNC_NONE;\n\terr = generate_offer(ecall);\n\tif (err) {\n\t\twarning(\"ecall(%p): start: generate_offer\"\n\t\t\t\" failed (%m)\\n\", ecall, err);\n\t\tgoto out;\n\t}\n\tecall->ts_started = tmr_jiffies();\n\tecall->call_setup_time = -1;\n out:\n\treturn err;\n}", "target": 1}
{"code": "static ssize_t read_mem(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tphys_addr_t p = *ppos;\n\tssize_t read, sz;\n\tvoid *ptr;\n\tif (p != *ppos)\n\t\treturn 0;\n\tif (!valid_phys_addr_range(p, count))\n\t\treturn -EFAULT;\n\tread = 0;\n#ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED\n\tif (p < PAGE_SIZE) {\n\t\tsz = size_inside_page(p, count);\n\t\tif (sz > 0) {\n\t\t\tif (clear_user(buf, sz))\n\t\t\t\treturn -EFAULT;\n\t\t\tbuf += sz;\n\t\t\tp += sz;\n\t\t\tcount -= sz;\n\t\t\tread += sz;\n\t\t}\n\t}\n#endif\n\twhile (count > 0) {\n\t\tunsigned long remaining;\n\t\tsz = size_inside_page(p, count);\n\t\tif (!range_is_allowed(p >> PAGE_SHIFT, count))\n\t\t\treturn -EPERM;\n\t\tptr = xlate_dev_mem_ptr(p);\n\t\tif (!ptr)\n\t\t\treturn -EFAULT;\n\t\tremaining = copy_to_user(buf, ptr, sz);\n\t\tunxlate_dev_mem_ptr(p, ptr);\n\t\tif (remaining)\n\t\t\treturn -EFAULT;\n\t\tbuf += sz;\n\t\tp += sz;\n\t\tcount -= sz;\n\t\tread += sz;\n\t}\n\t*ppos += read;\n\treturn read;\n}", "target": 1}
{"code": "static void ConvertLoopSlice(ModSample &src, ModSample &dest, SmpLength start, SmpLength len, bool loop)\n{\n\tif(!src.HasSampleData()) return;\n\tdest.FreeSample();\n\tdest = src;\n\tdest.nLength = len;\n\tdest.pSample = nullptr;\n\tif(!dest.AllocateSample())\n\t{\n\t\treturn;\n\t}\n\tif(len != src.nLength)\n\t\tMemsetZero(dest.cues);\n\tstd::memcpy(dest.pSample8, src.pSample8 + start, len);\n\tdest.uFlags.set(CHN_LOOP, loop);\n\tif(loop)\n\t{\n\t\tdest.nLoopStart = 0;\n\t\tdest.nLoopEnd = len;\n\t} else\n\t{\n\t\tdest.nLoopStart = 0;\n\t\tdest.nLoopEnd = 0;\n\t}\n}", "target": 1}
{"code": "void V8DOMWrapper::setJSWrapperForActiveDOMObject(void* object, v8::Persistent<v8::Object> wrapper)\n{\n    ASSERT(V8DOMWrapper::maybeDOMWrapper(wrapper));\n#ifndef NDEBUG\n    V8ClassIndex::V8WrapperType type = V8DOMWrapper::domWrapperType(wrapper);\n    switch (type) {\n#define MAKE_CASE(TYPE, NAME) case V8ClassIndex::TYPE: break;\n        ACTIVE_DOM_OBJECT_TYPES(MAKE_CASE)\n    default: \n        ASSERT_NOT_REACHED();\n#undef MAKE_CASE\n    }\n#endif\n    getActiveDOMObjectMap().set(object, wrapper);\n}", "target": 0}
{"code": "TIFFReadEncodedStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size)\n{\n\tstatic const char module[] = \"TIFFReadEncodedStrip\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 rowsperstrip;\n\tuint32 stripsperplane;\n\tuint32 stripinplane;\n\tuint16 plane;\n\tuint32 rows;\n\ttmsize_t stripsize;\n\tif (!TIFFCheckRead(tif,0))\n\t\treturn((tmsize_t)(-1));\n\tif (strip>=td->td_nstrips)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t    \"%lu: Strip out of range, max %lu\",(unsigned long)strip,\n\t\t    (unsigned long)td->td_nstrips);\n\t\treturn((tmsize_t)(-1));\n\t}\n\trowsperstrip=td->td_rowsperstrip;\n\tif (rowsperstrip>td->td_imagelength)\n\t\trowsperstrip=td->td_imagelength;\n\tstripsperplane=((td->td_imagelength+rowsperstrip-1)/rowsperstrip);\n\tstripinplane=(strip%stripsperplane);\n\tplane=(uint16)(strip/stripsperplane);\n\trows=td->td_imagelength-stripinplane*rowsperstrip;\n\tif (rows>rowsperstrip)\n\t\trows=rowsperstrip;\n\tstripsize=TIFFVStripSize(tif,rows);\n\tif (stripsize==0)\n\t\treturn((tmsize_t)(-1));\n    if( td->td_compression == COMPRESSION_NONE &&\n        size!=(tmsize_t)(-1) && size >= stripsize &&\n        !isMapped(tif) &&\n        ((tif->tif_flags&TIFF_NOREADRAW)==0) )\n    {\n        if (TIFFReadRawStrip1(tif, strip, buf, stripsize, module) != stripsize)\n            return ((tmsize_t)(-1));\n        if (!isFillOrder(tif, td->td_fillorder) &&\n            (tif->tif_flags & TIFF_NOBITREV) == 0)\n            TIFFReverseBits(buf,stripsize);\n        (*tif->tif_postdecode)(tif,buf,stripsize);\n        return (stripsize);\n    }\n\tif ((size!=(tmsize_t)(-1))&&(size<stripsize))\n\t\tstripsize=size;\n\tif (!TIFFFillStrip(tif,strip))\n\t\treturn((tmsize_t)(-1));\n\tif ((*tif->tif_decodestrip)(tif,buf,stripsize,plane)<=0)\n\t\treturn((tmsize_t)(-1));\n\t(*tif->tif_postdecode)(tif,buf,stripsize);\n\treturn(stripsize);\n}", "target": 1}
{"code": "\t\tvoid PdfTranslator::setSource ( const std::string & source )\n\t\t{\n\t\t\tint dbg(0);\n\t\t\tstd::cerr<< ++dbg <<std::endl;\n\t\t\tif ( checkIsPDF ( source ) )\n\t\t\t{\n\t\t\t\tmultiSource.push_back ( source );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tifstream in ( source.c_str(), ifstream::in );\n\t\t\t\tif ( !in.good() )\n\t\t\t\t\tthrow runtime_error ( \"setSource() failed to open input file\" );\n\t\t\t\tchar *filenameBuffer = new char[1000];\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tin.getline ( filenameBuffer, 1000 );\n\t\t\t\t\tstd::string ts ( filenameBuffer, in.gcount() );\n\t\t\t\t\tif ( ts.size() > 4 ) \n\t\t\t\t\t{\n\t\t\t\t\t\tmultiSource.push_back ( ts );\n\t\t\t\t\t\tstd::cerr << \"Appending \"<< ts <<\" to source\" << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile ( !in.eof() );\n\t\t\t\tin.close();\n\t\t\t\tdelete [] filenameBuffer;\n\t\t\t}\n\t\t\tstd::cerr<< ++dbg <<std::endl;\n\t\t\tfor ( std::vector<std::string>::const_iterator ms = multiSource.begin(); ms != multiSource.end(); ++ms )\n\t\t\t{\n\t\t\t\tif ( ms == multiSource.begin() )\n\t\t\t\t{\n\t\t\t\t\ttry{\n\t\t\t\t\t\tsourceDoc = new PdfMemDocument ( ( *ms ).c_str() );\n\t\t\t\t\t}\n\t\t\t\t\tcatch(PdfError& e)\n\t\t\t\t\t{\n                        std::cerr << \"Unable to create Document: \" << PdfError::ErrorMessage( e.GetError() ) << std::endl;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tPdfMemDocument mdoc ( ( *ms ).c_str() );\n\t\t\t\t\tsourceDoc->InsertPages ( mdoc, 0, mdoc.GetPageCount() );\n\t\t\t\t}\n\t\t\t}\n\t\t\tpcount = sourceDoc->GetPageCount();\n\t\t\tif ( pcount > 0 ) \n\t\t\t{\n\t\t\t\tPoDoFo::PdfRect rect ( sourceDoc->GetPage ( 0 )->GetMediaBox() );\n\t\t\t\tsourceWidth =  rect.GetWidth() - rect.GetLeft();\n\t\t\t\tsourceHeight =  rect.GetHeight() - rect.GetBottom() ;\n\t\t\t}\n\t\t}", "target": 1}
{"code": "m_split(struct mbuf *m0, int len0, int wait)\n{\n\tstruct mbuf *m, *n;\n\tunsigned len = len0, remain, olen;\n\tfor (m = m0; m && len > m->m_len; m = m->m_next)\n\t\tlen -= m->m_len;\n\tif (m == NULL)\n\t\treturn (NULL);\n\tremain = m->m_len - len;\n\tif (m0->m_flags & M_PKTHDR) {\n\t\tMGETHDR(n, wait, m0->m_type);\n\t\tif (n == NULL)\n\t\t\treturn (NULL);\n\t\tif (m_dup_pkthdr(n, m0, wait)) {\n\t\t\tm_freem(n);\n\t\t\treturn (NULL);\n\t\t}\n\t\tn->m_pkthdr.len -= len0;\n\t\tolen = m0->m_pkthdr.len;\n\t\tm0->m_pkthdr.len = len0;\n\t\tif (remain == 0) {\n\t\t\tn->m_next = m->m_next;\n\t\t\tm->m_next = NULL;\n\t\t\tn->m_len = 0;\n\t\t\treturn (n);\n\t\t}\n\t\tif (m->m_flags & M_EXT)\n\t\t\tgoto extpacket;\n\t\tif (remain > MHLEN) {\n\t\t\tm_align(n, 0);\n\t\t\tn->m_next = m_split(m, len, wait);\n\t\t\tif (n->m_next == NULL) {\n\t\t\t\t(void) m_free(n);\n\t\t\t\tm0->m_pkthdr.len = olen;\n\t\t\t\treturn (NULL);\n\t\t\t} else {\n\t\t\t\tn->m_len = 0;\n\t\t\t\treturn (n);\n\t\t\t}\n\t\t} else\n\t\t\tm_align(n, remain);\n\t} else if (remain == 0) {\n\t\tn = m->m_next;\n\t\tm->m_next = NULL;\n\t\treturn (n);\n\t} else {\n\t\tMGET(n, wait, m->m_type);\n\t\tif (n == NULL)\n\t\t\treturn (NULL);\n\t\tm_align(n, remain);\n\t}\nextpacket:\n\tif (m->m_flags & M_EXT) {\n\t\tn->m_ext = m->m_ext;\n\t\tMCLADDREFERENCE(m, n);\n\t\tn->m_data = m->m_data + len;\n\t} else {\n\t\tmemcpy(mtod(n, caddr_t), mtod(m, caddr_t) + len, remain);\n\t}\n\tn->m_len = remain;\n\tm->m_len = len;\n\tn->m_next = m->m_next;\n\tm->m_next = NULL;\n\treturn (n);\n}", "target": 1}
{"code": "rx_cache_insert(netdissect_options *ndo,\n                const u_char *bp, const struct ip *ip, int dport)\n{\n\tstruct rx_cache_entry *rxent;\n\tconst struct rx_header *rxh = (const struct rx_header *) bp;\n\tif (ndo->ndo_snapend - bp + 1 <= (int)(sizeof(struct rx_header) + sizeof(int32_t)))\n\t\treturn;\n\trxent = &rx_cache[rx_cache_next];\n\tif (++rx_cache_next >= RX_CACHE_SIZE)\n\t\trx_cache_next = 0;\n\trxent->callnum = EXTRACT_32BITS(&rxh->callNumber);\n\tUNALIGNED_MEMCPY(&rxent->client, &ip->ip_src, sizeof(uint32_t));\n\tUNALIGNED_MEMCPY(&rxent->server, &ip->ip_dst, sizeof(uint32_t));\n\trxent->dport = dport;\n\trxent->serviceId = EXTRACT_32BITS(&rxh->serviceId);\n\trxent->opcode = EXTRACT_32BITS(bp + sizeof(struct rx_header));\n}", "target": 1}
{"code": "static bool ldm_frag_add (const u8 *data, int size, struct list_head *frags)\n{\n\tstruct frag *f;\n\tstruct list_head *item;\n\tint rec, num, group;\n\tBUG_ON (!data || !frags);\n\tif (size < 2 * VBLK_SIZE_HEAD) {\n\t\tldm_error(\"Value of size is to small.\");\n\t\treturn false;\n\t}\n\tgroup = get_unaligned_be32(data + 0x08);\n\trec   = get_unaligned_be16(data + 0x0C);\n\tnum   = get_unaligned_be16(data + 0x0E);\n\tif ((num < 1) || (num > 4)) {\n\t\tldm_error (\"A VBLK claims to have %d parts.\", num);\n\t\treturn false;\n\t}\n\tif (rec >= num) {\n\t\tldm_error(\"REC value (%d) exceeds NUM value (%d)\", rec, num);\n\t\treturn false;\n\t}\n\tlist_for_each (item, frags) {\n\t\tf = list_entry (item, struct frag, list);\n\t\tif (f->group == group)\n\t\t\tgoto found;\n\t}\n\tf = kmalloc (sizeof (*f) + size*num, GFP_KERNEL);\n\tif (!f) {\n\t\tldm_crit (\"Out of memory.\");\n\t\treturn false;\n\t}\n\tf->group = group;\n\tf->num   = num;\n\tf->rec   = rec;\n\tf->map   = 0xFF << num;\n\tlist_add_tail (&f->list, frags);\nfound:\n\tif (rec >= f->num) {\n\t\tldm_error(\"REC value (%d) exceeds NUM value (%d)\", rec, f->num);\n\t\treturn false;\n\t}\n\tif (f->map & (1 << rec)) {\n\t\tldm_error (\"Duplicate VBLK, part %d.\", rec);\n\t\tf->map &= 0x7F;\t\t\t\n\t\treturn false;\n\t}\n\tf->map |= (1 << rec);\n\tdata += VBLK_SIZE_HEAD;\n\tsize -= VBLK_SIZE_HEAD;\n\tmemcpy (f->data+rec*(size-VBLK_SIZE_HEAD)+VBLK_SIZE_HEAD, data, size);\n\treturn true;\n}", "target": 0}
{"code": "TEST_F(HeaderToMetadataTest, CookieValueUsed) {\n  const std::string response_config_yaml = R\"EOF(\nresponse_rules:\n  - cookie: bar\n    on_header_present:\n      key: bar\n      type: STRING\n    remove: false\n)EOF\";\n  initializeFilter(response_config_yaml);\n  Http::TestResponseHeaderMapImpl incoming_headers{{\"cookie\", \"bar=foo\"}};\n  std::map<std::string, std::string> expected = {{\"bar\", \"foo\"}};\n  EXPECT_CALL(encoder_callbacks_, streamInfo()).WillRepeatedly(ReturnRef(req_info_));\n  EXPECT_CALL(req_info_,\n              setDynamicMetadata(HttpFilterNames::get().HeaderToMetadata, MapEq(expected)));\n  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->encodeHeaders(incoming_headers, false));\n}", "target": 0}
{"code": "usage (const char *prog)\n{\n\tg_print (\"- Lists file in a supported archive format\\n\");\n\tg_print (\"Usage: %s archive-type filename\\n\", prog);\n\tg_print (\"Where archive-type is one of rar, zip, 7z or tar\\n\");\n}", "target": 0}
{"code": "GF_Err stbl_AppendSize(GF_SampleTableBox *stbl, u32 size, u32 nb_pack)\n{\n\tu32 i;\n\tif (!nb_pack) nb_pack = 1;\n\tif (!stbl->SampleSize->sampleCount) {\n\t\tstbl->SampleSize->sampleSize = size;\n\t\tstbl->SampleSize->sampleCount += nb_pack;\n\t\treturn GF_OK;\n\t}\n\tif (stbl->SampleSize->sampleSize && (stbl->SampleSize->sampleSize==size)) {\n\t\tstbl->SampleSize->sampleCount += nb_pack;\n\t\treturn GF_OK;\n\t}\n\tif (!stbl->SampleSize->sizes || (stbl->SampleSize->sampleCount+nb_pack > stbl->SampleSize->alloc_size)) {\n\t\tBool init_table = (stbl->SampleSize->sizes==NULL) ? 1 : 0;\n\t\tALLOC_INC(stbl->SampleSize->alloc_size);\n\t\tif (stbl->SampleSize->sampleCount+nb_pack > stbl->SampleSize->alloc_size)\n\t\t\tstbl->SampleSize->alloc_size = stbl->SampleSize->sampleCount+nb_pack;\n\t\tstbl->SampleSize->sizes = (u32 *)gf_realloc(stbl->SampleSize->sizes, sizeof(u32)*stbl->SampleSize->alloc_size);\n\t\tif (!stbl->SampleSize->sizes) return GF_OUT_OF_MEM;\n\t\tmemset(&stbl->SampleSize->sizes[stbl->SampleSize->sampleCount], 0, sizeof(u32) * (stbl->SampleSize->alloc_size - stbl->SampleSize->sampleCount) );\n\t\tif (init_table) {\n\t\t\tfor (i=0; i<stbl->SampleSize->sampleCount; i++)\n\t\t\t\tstbl->SampleSize->sizes[i] = stbl->SampleSize->sampleSize;\n\t\t}\n\t}\n\tstbl->SampleSize->sampleSize = 0;\n\tfor (i=0; i<nb_pack; i++) {\n\t\tstbl->SampleSize->sizes[stbl->SampleSize->sampleCount+i] = size;\n\t}\n\tstbl->SampleSize->sampleCount += nb_pack;\n\tif (size > stbl->SampleSize->max_size)\n\t\tstbl->SampleSize->max_size = size;\n\tstbl->SampleSize->total_size += size;\n\tstbl->SampleSize->total_samples += nb_pack;\n\treturn GF_OK;\n}", "target": 1}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  OpData* data = static_cast<OpData*>(node->user_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE_EQ(context, output->quantization.type,\n                    kTfLiteAffineQuantization);\n  const auto* affine_quantization =\n      reinterpret_cast<TfLiteAffineQuantization*>(output->quantization.params);\n  TF_LITE_ENSURE(context, affine_quantization);\n  TF_LITE_ENSURE(context, affine_quantization->scale);\n  TF_LITE_ENSURE(context, affine_quantization->scale->size == 1);\n  TF_LITE_ENSURE(context, input->type == kTfLiteFloat32 ||\n                              input->type == kTfLiteInt16 ||\n                              input->type == kTfLiteInt8);\n  TF_LITE_ENSURE(context, output->type == kTfLiteUInt8 ||\n                              output->type == kTfLiteInt8 ||\n                              output->type == kTfLiteInt16);\n  if (((input->type == kTfLiteInt16 || input->type == kTfLiteInt8) &&\n       output->type == kTfLiteInt8) ||\n      (input->type == kTfLiteInt16 && output->type == kTfLiteInt16)) {\n    double effective_scale = static_cast<double>(input->params.scale) /\n                             static_cast<double>(output->params.scale);\n    QuantizeMultiplier(effective_scale, &data->output_multiplier,\n                       &data->output_shift);\n  }\n  data->quantization_params.zero_point = output->params.zero_point;\n  data->quantization_params.scale = static_cast<double>(output->params.scale);\n  data->input_zero_point = input->params.zero_point;\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static void vmx_complete_atomic_exit(struct vcpu_vmx *vmx)\n{\n\tu32 exit_intr_info;\n\tif (!(vmx->exit_reason == EXIT_REASON_MCE_DURING_VMENTRY\n\t      || vmx->exit_reason == EXIT_REASON_EXCEPTION_NMI))\n\t\treturn;\n\tvmx->exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\texit_intr_info = vmx->exit_intr_info;\n\tif (is_machine_check(exit_intr_info))\n\t\tkvm_machine_check();\n\tif ((exit_intr_info & INTR_INFO_INTR_TYPE_MASK) == INTR_TYPE_NMI_INTR &&\n\t    (exit_intr_info & INTR_INFO_VALID_MASK)) {\n\t\tkvm_before_handle_nmi(&vmx->vcpu);\n\t\tasm(\"int $2\");\n\t\tkvm_after_handle_nmi(&vmx->vcpu);\n\t}\n}", "target": 1}
{"code": "void faad_resetbits(bitfile *ld, int bits)\n{\n    uint32_t tmp;\n    int words = bits >> 5;\n    int remainder = bits & 0x1F;\n    ld->bytes_left = ld->buffer_size - words*4;\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(&ld->start[words]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(&ld->start[words], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufa = tmp;\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(&ld->start[words+1]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(&ld->start[words+1], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufb = tmp;\n    ld->bits_left = 32 - remainder;\n    ld->tail = &ld->start[words+2];\n    ld->error = 0;\n}", "target": 1}
{"code": "DROGON_TEST(HttpFile)\n{\n    SUBSECTION(Save)\n    {\n        HttpFileImpl file;\n        file.setFileName(\"test_file_name\");\n        file.setFile(\"test\", 4);\n        auto out = file.save(\"./test_uploads_dir\");\n        CHECK(out == 0);\n        CHECK(filesystem::exists(\"./test_uploads_dir/test_file_name\"));\n        filesystem::remove_all(\"./test_uploads_dir\");\n    }\n    SUBSECTION(SavePathRelativeTraversal)\n    {\n        auto uploadPath = filesystem::current_path() / \"test_uploads_dir\";\n        HttpFileImpl file;\n        file.setFileName(\"../test_malicious_file_name\");\n        file.setFile(\"test\", 4);\n        auto out = file.save(uploadPath.string());\n        CHECK(out == -1);\n        CHECK(!filesystem::exists(uploadPath / \"../test_malicious_file_name\"));\n        filesystem::remove_all(uploadPath);\n        filesystem::remove(uploadPath / \"../test_malicious_file_name\");\n    }\n    SUBSECTION(SavePathAbsoluteTraversal)\n    {\n        HttpFileImpl file;\n        file.setFileName(\"/tmp/test_malicious_file_name\");\n        file.setFile(\"test\", 4);\n        auto out = file.save(\"./test_uploads_dir\");\n        CHECK(out == -1);\n        CHECK(!filesystem::exists(\"/tmp/test_malicious_file_name\"));\n        filesystem::remove_all(\"test_uploads_dir\");\n        filesystem::remove_all(\"/tmp/test_malicious_file_name\");\n    }\n}", "target": 0}
{"code": "void test_mknod(const char *path)\n{\n\tif (mknod(path, 0755, makedev(0, 0)) == 0) {\n\t\tfprintf(stderr, \"leak at mknod of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at mknod of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "    void XmpSidecar::writeMetadata()\n    {\n        if (io_->open() != 0) {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        if (writeXmpFromPacket() == false) {\n            Exiv2::XmpData  copy   ;\n            for (Exiv2::XmpData::const_iterator it = xmpData_.begin(); it != xmpData_.end(); ++it) {\n                if ( !matchi(it->key(),\"exif\") && !matchi(it->key(),\"iptc\") ) {\n                    copy[it->key()] = it->value();\n                }\n            }\n            copyExifToXmp(exifData_, xmpData_);\n            copyIptcToXmp(iptcData_, xmpData_);\n            for (Exiv2::XmpData::const_iterator it = copy.begin(); it != copy.end(); ++it) {\n                xmpData_[it->key()] = it->value() ;\n            }\n            for ( Exiv2::Dictionary_i it = dates_.begin() ; it != dates_.end() ; ++it ) {\n                std::string   sKey = it->first;\n                Exiv2::XmpKey key(sKey);\n                if ( xmpData_.findKey(key) != xmpData_.end() ) {\n                    std::string value_orig(it->second);\n                    std::string value_now(xmpData_[sKey].value().toString());\n                    if ( value_orig.find(value_now.substr(0,10)) != std::string::npos ) {\n                        xmpData_[sKey] = value_orig ;\n                    }\n                }\n            }\n            if (XmpParser::encode(xmpPacket_, xmpData_,\n                                  XmpParser::omitPacketWrapper|XmpParser::useCompactFormat) > 1) {\n#ifndef SUPPRESS_WARNINGS\n                EXV_ERROR << \"Failed to encode XMP metadata.\\n\";\n#endif\n            }\n        }\n        if (xmpPacket_.size() > 0) {\n            if (xmpPacket_.substr(0, 5)  != \"<?xml\") {\n                xmpPacket_ = xmlHeader + xmpPacket_ + xmlFooter;\n            }\n            BasicIo::UniquePtr tempIo(new MemIo);\n            assert(tempIo.get() != 0);\n            if (tempIo->write(reinterpret_cast<const byte*>(xmpPacket_.data()), xmpPacket_.size()) != xmpPacket_.size())\n                throw Error(kerImageWriteFailed);\n            if (tempIo->error()) throw Error(kerImageWriteFailed);\n            io_->close();\n            io_->transfer(*tempIo); \n        }\n    } ", "target": 0}
{"code": "int gdAlphaBlend (int dst, int src) {\n    int src_alpha = gdTrueColorGetAlpha(src);\n    int dst_alpha, alpha, red, green, blue;\n    int src_weight, dst_weight, tot_weight;\n    if( src_alpha == gdAlphaOpaque )\n        return src;\n    dst_alpha = gdTrueColorGetAlpha(dst);\n    if( src_alpha == gdAlphaTransparent )\n        return dst;\n    if( dst_alpha == gdAlphaTransparent )\n        return src;\n    src_weight = gdAlphaTransparent - src_alpha;\n    dst_weight = (gdAlphaTransparent - dst_alpha) * src_alpha / gdAlphaMax;\n    tot_weight = src_weight + dst_weight;\n    alpha = src_alpha * dst_alpha / gdAlphaMax;\n    red = (gdTrueColorGetRed(src) * src_weight\n           + gdTrueColorGetRed(dst) * dst_weight) / tot_weight;\n    green = (gdTrueColorGetGreen(src) * src_weight\n           + gdTrueColorGetGreen(dst) * dst_weight) / tot_weight;\n    blue = (gdTrueColorGetBlue(src) * src_weight\n           + gdTrueColorGetBlue(dst) * dst_weight) / tot_weight;\n    return ((alpha << 24) + (red << 16) + (green << 8) + blue);\n}", "target": 1}
{"code": "  virtual void DisconnectFromWirelessNetwork(const WirelessNetwork* network) {\n    DCHECK(network);\n    if (!EnsureCrosLoaded() || !network)\n      return;\n    if (DisconnectFromNetwork(network->service_path().c_str())) {\n      if (network->type() == TYPE_WIFI) {\n        WifiNetwork* wifi = GetWirelessNetworkByPath(\n            wifi_networks_, network->service_path());\n        if (wifi) {\n          wifi->set_connected(false);\n          wifi_ = NULL;\n        }\n      } else if (network->type() == TYPE_CELLULAR) {\n        CellularNetwork* cellular = GetWirelessNetworkByPath(\n            cellular_networks_, network->service_path());\n        if (cellular) {\n          cellular->set_connected(false);\n          cellular_ = NULL;\n        }\n      }\n      NotifyNetworkManagerChanged();\n    }\n  }", "target": 0}
{"code": "void l2tp_packet_print(const struct l2tp_packet_t *pack,\n\t\t       void (*print)(const char *fmt, ...))\n{\n\tconst struct l2tp_attr_t *attr;\n\tconst struct l2tp_dict_value_t *val;\n\tif (pack->hdr.ver == 2) {\n\t\tprint(\"[L2TP tid=%u sid=%u\", ntohs(pack->hdr.tid), ntohs(pack->hdr.sid));\n\t\tlog_ppp_debug(\" Ns=%u Nr=%u\", ntohs(pack->hdr.Ns), ntohs(pack->hdr.Nr));\n\t} else {\n\t\tprint(\"[L2TP cid=%u\", pack->hdr.cid);\n\t\tlog_ppp_debug(\" Ns=%u Nr=%u\", ntohs(pack->hdr.Ns), ntohs(pack->hdr.Nr));\n\t}\n\tlist_for_each_entry(attr, &pack->attrs, entry) {\n\t\tprint(\" <%s\", attr->attr->name);\n\t\tval = l2tp_dict_find_value(attr->attr, attr->val);\n\t\tif (val)\n\t\t\tprint(\" %s\", val->name);\n\t\telse if (attr->H)\n\t\t\tprint(\" (hidden, %hu bytes)\", attr->length);\n\t\telse {\n\t\t\tswitch (attr->attr->type) {\n\t\t\t\tcase ATTR_TYPE_INT16:\n\t\t\t\t\tprint(\" %i\", attr->val.int16);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_INT32:\n\t\t\t\t\tprint(\" %i\", attr->val.int32);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_STRING:\n\t\t\t\t\tprint(\" %s\", attr->val.string);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprint(\">\");\n\t}\n\tprint(\"]\\n\");\n}", "target": 1}
{"code": "void WasmBinaryWriter::writeIndexedHeapType(HeapType type) {\n  o << U32LEB(getTypeIndex(type));\n}", "target": 0}
{"code": "static int gup_huge_pmd(pmd_t orig, pmd_t *pmdp, unsigned long addr,\n\t\tunsigned long end, int write, struct page **pages, int *nr)\n{\n\tstruct page *head, *page;\n\tint refs;\n\tif (!pmd_access_permitted(orig, write))\n\t\treturn 0;\n\tif (pmd_devmap(orig))\n\t\treturn __gup_device_huge_pmd(orig, pmdp, addr, end, pages, nr);\n\trefs = 0;\n\tpage = pmd_page(orig) + ((addr & ~PMD_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\thead = compound_head(pmd_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\tif (unlikely(pmd_val(orig) != pmd_val(*pmdp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\tSetPageReferenced(head);\n\treturn 1;\n}", "target": 1}
{"code": "static bool set_reg_profile(RAnal *anal) {\n\tconst char *p = \\\n\t\t\"=PC\tpc\\n\"\n\t\t\"=SP\tsp\\n\"\n\t\t\"=SN\tr0\\n\"\n\t\t\"=A0\tr12\\n\"\n\t\t\"=A1\tr13\\n\"\n\t\t\"=A2\tr14\\n\"\n\t\t\"=A3\tr15\\n\"\n\t\t\"gpr\tr0\t.16 0   0\\n\"\n\t\t\"gpr\tr1\t.16 2   0\\n\"\n\t\t\"gpr\tr2\t.16 4   0\\n\"\n\t\t\"gpr\tr3\t.16 6   0\\n\"\n\t\t\"gpr\tr4\t.16 8   0\\n\"\n\t\t\"gpr\tr5\t.16 10  0\\n\"\n\t\t\"gpr\tr6\t.16 12  0\\n\"\n\t\t\"gpr\tr7\t.16 14  0\\n\"\n\t\t\"gpr\tr8\t.16 16  0\\n\"\n\t\t\"gpr\tr9\t.16 18  0\\n\"\n\t\t\"gpr\tr10   .16 20  0\\n\"\n\t\t\"gpr\tr11   .16 22  0\\n\"\n\t\t\"gpr\tr12   .16 24  0\\n\"\n\t\t\"gpr\tr13   .16 26  0\\n\"\n\t\t\"gpr\tr14   .16 28  0\\n\"\n\t\t\"gpr\tr15   .16 30  0\\n\"\n\t\t\"gpr\tpc\t.16 0 0\\n\" \n\t\t\"gpr\tsp\t.16 2 0\\n\" \n\t\t\"flg\tsr\t.16 4 0\\n\" \n\t\t\"flg\tc\t.1  4 0\\n\"\n\t\t\"flg\tz\t.1  4.1 0\\n\"\n\t\t\"flg\tn\t.1  4.2 0\\n\"\n\t\t\"flg\tv\t.1  4.8 0\\n\";\n\treturn r_reg_set_profile_string (anal->reg, p);\n}", "target": 0}
{"code": "static char* getPreferredTag(const char* gf_tag)\n{ \n\tchar* result = NULL;\n\tint grOffset = 0;\n\tgrOffset = findOffset( LOC_GRANDFATHERED ,gf_tag);\n\tif(grOffset < 0) {\n\t\treturn NULL;\n\t}\n\tif( grOffset < LOC_PREFERRED_GRANDFATHERED_LEN ){\n\t\tresult = estrdup( LOC_PREFERRED_GRANDFATHERED[grOffset] );\n\t} else {\n\t\tresult = estrdup( LOC_GRANDFATHERED[grOffset] );\n\t}\n\treturn result;\n}", "target": 1}
{"code": "char *url_canonize2(char *d, char const * const s, size_t n,\n\t\t    unsigned syn33,\n\t\t    unsigned m32, unsigned m64, unsigned m96)\n{\n  size_t i = 0;\n  if (d == s)\n    for (;s[i] && i < n; d++, i++)\n      if (s[i] == '%')\n\tbreak;\n  for (;s[i] && i < n; d++, i++) {\n    unsigned char c = s[i], h1, h2;\n    if (c != '%') {\n      if (!IS_SYN33(syn33, c) && IS_EXCLUDED(c, m32, m64, m96))\n\treturn NULL;\n      *d = c;\n      continue;\n    }\n    h1 = s[i + 1];\n    if (!h1) {\n        *d = '\\0';\n        return NULL;\n    }\n    h2 = s[i + 2];\n    if (!IS_HEX(h1) || !IS_HEX(h2)) {\n      *d = '\\0';\n      return NULL;\n    }\n#define UNHEX(a) (a - (a >= 'a' ? 'a' - 10 : (a >= 'A' ? 'A' - 10 : '0')))\n    c = (UNHEX(h1) << 4) | UNHEX(h2);\n    if (!IS_EXCLUDED(c, m32, m64, m96)) {\n      *d = c, i += 2;\n      continue;\n    }\n    if (h1 >= 'a' )\n      h1 = h1 - 'a' + 'A';\n    if (h2 >= 'a' )\n      h2 = h2 - 'a' + 'A';\n    d[0] = '%', d[1] = h1, d[2] = h2;\n    d +=2, i += 2;\n#undef    UNHEX\n  }\n  *d = '\\0';\n  return d;\n}", "target": 0}
{"code": "ecma_op_function_call_constructor (vm_frame_ctx_shared_args_t *shared_args_p, \n                                   ecma_object_t *scope_p, \n                                   ecma_value_t this_binding) \n{\n  ECMA_CHECK_STACK_USAGE ();\n  shared_args_p->header.status_flags |= VM_FRAME_CTX_SHARED_NON_ARROW_FUNC;\n  ecma_value_t ret_value;\n  if (JERRY_CONTEXT (current_new_target_p) == NULL)\n  {\n    ret_value = ecma_raise_type_error (ECMA_ERR_CLASS_CONSTRUCTOR_REQUIRES_NEW);\n    goto exit;\n  }\n  ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) shared_args_p->header.function_object_p;\n  if (ECMA_GET_THIRD_BIT_FROM_POINTER_TAG (ext_func_p->u.function.scope_cp))\n  {\n    this_binding = ECMA_VALUE_UNINITIALIZED;\n  }\n  ecma_op_create_environment_record (scope_p, this_binding, shared_args_p->header.function_object_p);\n#if JERRY_BUILTIN_REALMS\n  ecma_global_object_t *saved_global_object_p = JERRY_CONTEXT (global_object_p);\n  JERRY_CONTEXT (global_object_p) = ecma_op_function_get_realm (shared_args_p->header.bytecode_header_p);\n#endif \n  ret_value = vm_run (&shared_args_p->header, this_binding, scope_p);\n#if JERRY_BUILTIN_REALMS\n  JERRY_CONTEXT (global_object_p) = saved_global_object_p;\n#endif \n  if (JERRY_UNLIKELY (this_binding == ECMA_VALUE_UNINITIALIZED))\n  {\n    if (!ECMA_IS_VALUE_ERROR (ret_value) && !ecma_is_value_object (ret_value))\n    {\n      if (!ecma_is_value_undefined (ret_value))\n      {\n        ecma_free_value (ret_value);\n        ret_value = ecma_raise_type_error (ECMA_ERR_DERIVED_CTOR_RETURN_NOR_OBJECT_OR_UNDEFINED);\n      }\n      else\n      {\n        ret_value = ecma_op_get_this_binding (scope_p);\n      }\n    }\n  }\nexit:\n  if (JERRY_UNLIKELY (shared_args_p->header.status_flags & VM_FRAME_CTX_SHARED_FREE_LOCAL_ENV))\n  {\n    ecma_deref_object (scope_p);\n  }\n  return ret_value;\n} ", "target": 0}
{"code": "    const char* ExifThumbC::extension() const\n    {\n        Thumbnail::UniquePtr thumbnail = Thumbnail::create(exifData_);\n        if (thumbnail.get() == 0) return \"\";\n        return thumbnail->extension();\n    }", "target": 0}
{"code": "void main_cleanup() {\n#ifdef USE_OS_THREADS\n    CLI *c;\n    unsigned i, threads;\n    THREAD_ID *thread_list;\n    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_THREAD_LIST]);\n    threads=0;\n    for(c=thread_head; c; c=c->thread_next) \n        threads++;\n    thread_list=str_alloc((threads+1)*sizeof(THREAD_ID));\n    i=0;\n    for(c=thread_head; c; c=c->thread_next) { \n        thread_list[i++]=c->thread_id;\n        s_log(LOG_DEBUG, \"Terminating a thread for [%s]\", c->opt->servname);\n    }\n    if(cron_thread_id) { \n        thread_list[threads++]=cron_thread_id;\n        s_log(LOG_DEBUG, \"Terminating the cron thread\");\n    }\n    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_THREAD_LIST]);\n    if(threads) {\n        s_log(LOG_NOTICE, \"Terminating %u service thread(s)\", threads);\n        writesocket(terminate_pipe[1], \"\", 1);\n        for(i=0; i<threads; ++i) { \n#ifdef USE_PTHREAD\n            if(pthread_join(thread_list[i], NULL))\n                s_log(LOG_ERR, \"pthread_join() failed\");\n#endif\n#ifdef USE_WIN32\n            if(WaitForSingleObject(thread_list[i], INFINITE)==WAIT_FAILED)\n                ioerror(\"WaitForSingleObject\");\n            if(!CloseHandle(thread_list[i]))\n                ioerror(\"CloseHandle\");\n#endif\n        }\n        s_log(LOG_NOTICE, \"Service threads terminated\");\n    }\n    str_free(thread_list);\n#endif \n    unbind_ports();\n    s_poll_free(fds);\n    fds=NULL;\n#if 0\n    str_stats(); \n#endif\n    log_flush(LOG_MODE_ERROR);\n    log_close(SINK_SYSLOG|SINK_OUTFILE);\n}", "target": 1}
{"code": "hybiRemaining(ws_ctx_t *wsctx)\n{\n  return wsctx->nToRead - wsctx->nReadRaw;\n}", "target": 0}
{"code": "exif_data_load_data_entry (ExifData *data, ExifEntry *entry,\n\t\t\t   const unsigned char *d,\n\t\t\t   unsigned int size, unsigned int offset)\n{\n\tunsigned int s, doff;\n\tentry->tag        = exif_get_short (d + offset + 0, data->priv->order);\n\tentry->format     = exif_get_short (d + offset + 2, data->priv->order);\n\tentry->components = exif_get_long  (d + offset + 4, data->priv->order);\n\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t  \"Loading entry 0x%x ('%s')...\", entry->tag,\n\t\t  exif_tag_get_name (entry->tag));\n\ts = exif_format_get_size(entry->format) * entry->components;\n\tif ((s < entry->components) || (s == 0)){\n\t\treturn 0;\n\t}\n\tif (s > 4)\n\t\tdoff = exif_get_long (d + offset + 8, data->priv->order);\n\telse\n\t\tdoff = offset + 8;\n\tif ((doff + s < doff) || (doff + s < s) || (doff + s > size)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t  \"Tag data past end of buffer (%u > %u)\", doff+s, size);\t\n\t\treturn 0;\n\t}\n\tentry->data = exif_data_alloc (data, s);\n\tif (entry->data) {\n\t\tentry->size = s;\n\t\tmemcpy (entry->data, d + doff, s);\n\t} else {\n\t\tEXIF_LOG_NO_MEMORY(data->priv->log, \"ExifData\", s);\n\t\treturn 0;\n\t}\n\tif (entry->tag == EXIF_TAG_MAKER_NOTE) {\n\t\tif (!entry->data) {\n\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t\t  \"MakerNote found with empty data\");\t\n\t\t} else if (entry->size > 6) {\n\t\t\texif_log (data->priv->log,\n\t\t\t\t\t       EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t\t       \"MakerNote found (%02x %02x %02x %02x \"\n\t\t\t\t\t       \"%02x %02x %02x...).\",\n\t\t\t\t\t       entry->data[0], entry->data[1], entry->data[2],\n\t\t\t\t\t       entry->data[3], entry->data[4], entry->data[5],\n\t\t\t\t\t       entry->data[6]);\n\t\t}\n\t\tdata->priv->offset_mnote = doff;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n{\n\tuint8_t *argb;\n\tint x, y;\n\tuint8_t *p;\n\tuint8_t *out;\n\tsize_t out_size;\n\tif (im == NULL) {\n\t\treturn;\n\t}\n\tif (!gdImageTrueColor(im)) {\n\t\tgd_error(\"Paletter image not supported by webp\");\n\t\treturn;\n\t}\n\tif (quality == -1) {\n\t\tquality = 80;\n\t}\n\tif (overflow2(gdImageSX(im), 4)) {\n\t\treturn;\n\t}\n\tif (overflow2(gdImageSX(im) * 4, gdImageSY(im))) {\n\t\treturn;\n\t}\n\targb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));\n\tif (!argb) {\n\t\treturn;\n\t}\n\tp = argb;\n\tfor (y = 0; y < gdImageSY(im); y++) {\n\t\tfor (x = 0; x < gdImageSX(im); x++) {\n\t\t\tregister int c;\n\t\t\tregister char a;\n\t\t\tc = im->tpixels[y][x];\n\t\t\ta = gdTrueColorGetAlpha(c);\n\t\t\tif (a == 127) {\n\t\t\t\ta = 0;\n\t\t\t} else {\n\t\t\t\ta = 255 - ((a << 1) + (a >> 6));\n\t\t\t}\n\t\t\t*(p++) = gdTrueColorGetRed(c);\n\t\t\t*(p++) = gdTrueColorGetGreen(c);\n\t\t\t*(p++) = gdTrueColorGetBlue(c); \n\t\t\t*(p++) = a;\n\t\t}\n\t}\n\tout_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);\n\tif (out_size == 0) {\n\t\tgd_error(\"gd-webp encoding failed\");\n\t\tgoto freeargb;\n\t}\n\tgdPutBuf(out, out_size, outfile);\n\tfree(out);\nfreeargb:\n\tgdFree(argb);\n}", "target": 1}
{"code": "static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user *argp)\n{\n\tstruct hidp_connadd_req ca;\n\tstruct hidp_conndel_req cd;\n\tstruct hidp_connlist_req cl;\n\tstruct hidp_conninfo ci;\n\tstruct socket *csock;\n\tstruct socket *isock;\n\tint err;\n\tBT_DBG(\"cmd %x arg %p\", cmd, argp);\n\tswitch (cmd) {\n\tcase HIDPCONNADD:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (copy_from_user(&ca, argp, sizeof(ca)))\n\t\t\treturn -EFAULT;\n\t\tcsock = sockfd_lookup(ca.ctrl_sock, &err);\n\t\tif (!csock)\n\t\t\treturn err;\n\t\tisock = sockfd_lookup(ca.intr_sock, &err);\n\t\tif (!isock) {\n\t\t\tsockfd_put(csock);\n\t\t\treturn err;\n\t\t}\n\t\tca.name[sizeof(ca.name)-1] = 0;\n\t\terr = hidp_connection_add(&ca, csock, isock);\n\t\tif (!err && copy_to_user(argp, &ca, sizeof(ca)))\n\t\t\terr = -EFAULT;\n\t\tsockfd_put(csock);\n\t\tsockfd_put(isock);\n\t\treturn err;\n\tcase HIDPCONNDEL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (copy_from_user(&cd, argp, sizeof(cd)))\n\t\t\treturn -EFAULT;\n\t\treturn hidp_connection_del(&cd);\n\tcase HIDPGETCONNLIST:\n\t\tif (copy_from_user(&cl, argp, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\t\tif (cl.cnum <= 0)\n\t\t\treturn -EINVAL;\n\t\terr = hidp_get_connlist(&cl);\n\t\tif (!err && copy_to_user(argp, &cl, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\t\treturn err;\n\tcase HIDPGETCONNINFO:\n\t\tif (copy_from_user(&ci, argp, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\t\terr = hidp_get_conninfo(&ci);\n\t\tif (!err && copy_to_user(argp, &ci, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\t\treturn err;\n\t}\n\treturn -EINVAL;\n}", "target": 0}
{"code": "static inline int mk_vhost_fdt_open(int id, unsigned int hash,\n                                    struct session_request *sr)\n{\n    int i;\n    int fd;\n    struct vhost_fdt_hash_table *ht = NULL;\n    struct vhost_fdt_hash_chain *hc;\n    if (config->fdt == MK_FALSE) {\n        return open(sr->real_path.data, sr->file_info.flags_read_only);\n    }\n    ht = mk_vhost_fdt_table_lookup(id, sr->host_conf);\n    if (mk_unlikely(!ht)) {\n        return open(sr->real_path.data, sr->file_info.flags_read_only);\n    }\n    hc = mk_vhost_fdt_chain_lookup(hash, ht);\n    if (hc) {\n        hc->readers++;\n        return hc->fd;\n    }\n    fd = open(sr->real_path.data, sr->file_info.flags_read_only);\n    if (fd == -1) {\n        return -1;\n    }\n    if (ht->av_slots <= 0) {\n        return fd;\n    }\n    for (i = 0; i < VHOST_FDT_HASHTABLE_CHAINS; i++) {\n        hc = &ht->chain[i];\n        if (hc->fd == -1) {\n            hc->fd   = fd;\n            hc->hash = hash;\n            hc->readers++;\n            ht->av_slots--;\n            sr->vhost_fdt_id   = id;\n            sr->vhost_fdt_hash = hash;\n            sr->fd_is_fdt      = MK_TRUE;\n            return fd;\n        }\n    }\n    return -1;\n}", "target": 0}
{"code": "static int _sqlite_rollback_txn(void *db, const sasl_utils_t *utils)\n{\n    return _sqlite_exec(db, \"ROLLBACK TRANSACTION\", NULL, 0, NULL, utils);\n}", "target": 0}
{"code": "Status CreateTempFileBadString(Env* env, char value, uint64 size,\n                               const string suffix, string* filename) {\n  const string dir = testing::TmpDir();\n  *filename = io::JoinPath(dir, strings::StrCat(\"file_\", suffix));\n  std::unique_ptr<WritableFile> file;\n  TF_RETURN_IF_ERROR(env->NewWritableFile(*filename, &file));\n  TF_RETURN_IF_ERROR(file->Append(std::string(size, value)));\n  TF_RETURN_IF_ERROR(file->Close());\n  return Status::OK();\n}", "target": 0}
{"code": "void CMsgReader::readExtendedClipboard(rdr::S32 len)\n{\n  rdr::U32 flags;\n  rdr::U32 action;\n  if (len < 4)\n    throw Exception(\"Invalid extended clipboard message\");\n  if (len > maxCutText) {\n    vlog.error(\"Extended clipboard message too long (%d bytes) - ignoring\", len);\n    is->skip(len);\n    return;\n  }\n  flags = is->readU32();\n  action = flags & clipboardActionMask;\n  if (action & clipboardCaps) {\n    int i;\n    size_t num;\n    rdr::U32 lengths[16];\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (flags & (1 << i))\n        num++;\n    }\n    if (len < (rdr::S32)(4 + 4*num))\n      throw Exception(\"Invalid extended clipboard message\");\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (flags & (1 << i))\n        lengths[num++] = is->readU32();\n    }\n    handler->handleClipboardCaps(flags, lengths);\n  } else if (action == clipboardProvide) {\n    rdr::ZlibInStream zis;\n    int i;\n    size_t num;\n    size_t lengths[16];\n    rdr::U8* buffers[16];\n    zis.setUnderlying(is, len - 4);\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (!(flags & 1 << i))\n        continue;\n      lengths[num] = zis.readU32();\n      if (lengths[num] > (size_t)maxCutText) {\n        vlog.error(\"Extended clipboard data too long (%d bytes) - ignoring\",\n                   (unsigned)lengths[num]);\n        zis.skip(lengths[num]);\n        flags &= ~(1 << i);\n        continue;\n      }\n      buffers[num] = new rdr::U8[lengths[num]];\n      zis.readBytes(buffers[num], lengths[num]);\n      num++;\n    }\n    zis.removeUnderlying();\n    handler->handleClipboardProvide(flags, lengths, buffers);\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (!(flags & 1 << i))\n        continue;\n      delete [] buffers[num++];\n    }\n  } else {\n    switch (action) {\n    case clipboardRequest:\n      handler->handleClipboardRequest(flags);\n      break;\n    case clipboardPeek:\n      handler->handleClipboardPeek(flags);\n      break;\n    case clipboardNotify:\n      handler->handleClipboardNotify(flags);\n      break;\n    default:\n      throw Exception(\"Invalid extended clipboard action\");\n    }\n  }\n}", "target": 1}
{"code": "static void __timerfd_remove_cancel(struct timerfd_ctx *ctx)\n{\n\tif (ctx->might_cancel) {\n\t\tctx->might_cancel = false;\n\t\tspin_lock(&cancel_lock);\n\t\tlist_del_rcu(&ctx->clist);\n\t\tspin_unlock(&cancel_lock);\n\t}\n}", "target": 0}
{"code": "static void parse_origin(pj_scanner *scanner, pjmedia_sdp_session *ses,\n\t\t\t volatile parse_context *ctx)\n{\n    pj_str_t str;\n    ctx->last_error = PJMEDIA_SDP_EINORIGIN;\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n    pj_scan_get_until_ch(scanner, ' ', &ses->origin.user);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_ch(scanner, ' ', &str);\n    ses->origin.id = pj_strtoul(&str);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_ch(scanner, ' ', &str);\n    ses->origin.version = pj_strtoul(&str);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_ch(scanner, ' ', &ses->origin.net_type);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_ch(scanner, ' ', &ses->origin.addr_type);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_chr(scanner, \" \\t\\r\\n\", &ses->origin.addr);\n    pj_scan_skip_line(scanner);\n}", "target": 1}
{"code": "void SFS_ArrayDeref(ScriptParser *parser)\n{\n\tif (parser->codec->LastError) return;\n\tSFS_Expression(parser);\n\tif (parser->codec->LastError) return;\n\tSFS_AddString(parser, \"[\");\n\tSFS_CompoundExpression(parser);\n\tSFS_AddString(parser, \"]\");\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, InSparseIndex) {\n    addIndex(fromjson(\"{a: 1}\"),\n             false,  \n             true);  \n    runQuery(fromjson(\"{a: {$in: [null]}}\"));\n    assertNumSolutions(1U);\n    assertSolutionExists(\"{cscan: {dir: 1, filter: {a: {$eq: null}}}}\");\n}", "target": 0}
{"code": "UnicodeString::doAppend(const UChar *srcChars, int32_t srcStart, int32_t srcLength) {\n  if(!isWritable() || srcLength == 0 || srcChars == NULL) {\n    return *this;\n  }\n  srcChars += srcStart;\n  if(srcLength < 0) {\n    if((srcLength = u_strlen(srcChars)) == 0) {\n      return *this;\n    }\n  }\n  int32_t oldLength = length();\n  int32_t newLength = oldLength + srcLength;\n  const UChar* oldArray = getArrayStart();\n  if (isBufferWritable() &&\n      oldArray < srcChars + srcLength &&\n      srcChars < oldArray + oldLength) {\n    UnicodeString copy(srcChars, srcLength);\n    if (copy.isBogus()) {\n      setToBogus();\n      return *this;\n    }\n    return doAppend(copy.getArrayStart(), 0, srcLength);\n  }\n  if((newLength <= getCapacity() && isBufferWritable()) ||\n      cloneArrayIfNeeded(newLength, getGrowCapacity(newLength))) {\n    UChar *newArray = getArrayStart();\n    if(srcChars != newArray + oldLength) {\n      us_arrayCopy(srcChars, 0, newArray, oldLength, srcLength);\n    }\n    setLength(newLength);\n  }\n  return *this;\n}", "target": 1}
{"code": "dissect_ac_if_hdr_body(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\n        proto_tree *tree, usb_conv_info_t *usb_conv_info)\n{\n    gint     offset_start;\n    guint16  bcdADC;\n    guint8   ver_major;\n    double   ver;\n    guint8   if_in_collection, i;\n    audio_conv_info_t *audio_conv_info;\n    offset_start = offset;\n    bcdADC = tvb_get_letohs(tvb, offset);\n    ver_major = USB_AUDIO_BCD44_TO_DEC(bcdADC>>8);\n    ver = ver_major + USB_AUDIO_BCD44_TO_DEC(bcdADC&0xFF) / 100.0;\n    proto_tree_add_double_format_value(tree, hf_ac_if_hdr_ver,\n            tvb, offset, 2, ver, \"%2.2f\", ver);\n    audio_conv_info = (audio_conv_info_t *)usb_conv_info->class_data;\n    if(!audio_conv_info) {\n        audio_conv_info = wmem_new(wmem_file_scope(), audio_conv_info_t);\n        usb_conv_info->class_data = audio_conv_info;\n        usb_conv_info->class_data_type = USB_CONV_AUDIO;\n    } else if (usb_conv_info->class_data_type != USB_CONV_AUDIO) {\n        return 0;\n    }\n    audio_conv_info->ver_major = ver_major;\n    offset += 2;\n    if (ver_major==1) {\n        proto_tree_add_item(tree, hf_ac_if_hdr_total_len,\n                tvb, offset, 2, ENC_LITTLE_ENDIAN);\n        offset += 2;\n        if_in_collection = tvb_get_guint8(tvb, offset);\n        proto_tree_add_item(tree, hf_ac_if_hdr_bInCollection,\n                tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset++;\n        for (i=0; i<if_in_collection; i++) {\n            proto_tree_add_item(tree, hf_ac_if_hdr_if_num,\n                    tvb, offset, 1, ENC_LITTLE_ENDIAN);\n            offset++;\n        }\n    }\n    return offset-offset_start;\n}", "target": 0}
{"code": "void FormatConverter<T>::Populate(const T* src_data, std::vector<int> indices,\n                                  int level, int prev_idx, int* src_data_ptr,\n                                  T* dest_data) {\n  if (level == indices.size()) {\n    int orig_rank = dense_shape_.size();\n    std::vector<int> orig_idx;\n    orig_idx.resize(orig_rank);\n    int i = 0;\n    for (; i < orig_idx.size(); i++) {\n      int orig_dim = traversal_order_[i];\n      orig_idx[orig_dim] = indices[i];\n    }\n    for (; i < indices.size(); i++) {\n      const int block_idx = traversal_order_[i] - orig_rank;\n      const int orig_dim = block_map_[block_idx];\n      orig_idx[orig_dim] =\n          orig_idx[orig_dim] * block_size_[block_idx] + indices[i];\n    }\n    dest_data[GetFlattenedIndex(orig_idx, dense_shape_)] =\n        src_data[*src_data_ptr];\n    *src_data_ptr = *src_data_ptr + 1;\n    return;\n  }\n  const int metadata_idx = 2 * level;\n  const int shape_of_level = dim_metadata_[metadata_idx][0];\n  if (format_[level] == kTfLiteDimDense) {\n    for (int i = 0; i < shape_of_level; i++) {\n      indices[level] = i;\n      Populate(src_data, indices, level + 1, prev_idx * shape_of_level + i,\n               src_data_ptr, dest_data);\n    }\n  } else {\n    const auto& array_segments = dim_metadata_[metadata_idx];\n    const auto& array_indices = dim_metadata_[metadata_idx + 1];\n    for (int i = array_segments[prev_idx]; i < array_segments[prev_idx + 1];\n         i++) {\n      indices[level] = array_indices[i];\n      Populate(src_data, indices, level + 1, i, src_data_ptr, dest_data);\n    }\n  }\n}", "target": 1}
{"code": "static const ut8 *parse_die(const ut8 *buf, const ut8 *buf_end, RzBinDwarfDebugInfo *info, RzBinDwarfAbbrevDecl *abbrev,\n\tRzBinDwarfCompUnitHdr *hdr, RzBinDwarfDie *die, const ut8 *debug_str, size_t debug_str_len, bool big_endian) {\n\tsize_t i;\n\tconst char *comp_dir = NULL;\n\tut64 line_info_offset = UT64_MAX;\n\tfor (i = 0; i < abbrev->count - 1; i++) {\n\t\tmemset(&die->attr_values[i], 0, sizeof(die->attr_values[i]));\n\t\tbuf = parse_attr_value(buf, buf_end - buf, &abbrev->defs[i],\n\t\t\t&die->attr_values[i], hdr, debug_str, debug_str_len, big_endian);\n\t\tRzBinDwarfAttrValue *attribute = &die->attr_values[i];\n\t\tif (attribute->attr_name == DW_AT_comp_dir && (attribute->attr_form == DW_FORM_strp || attribute->attr_form == DW_FORM_string) && attribute->string.content) {\n\t\t\tcomp_dir = attribute->string.content;\n\t\t}\n\t\tif (attribute->attr_name == DW_AT_stmt_list) {\n\t\t\tif (attribute->kind == DW_AT_KIND_CONSTANT) {\n\t\t\t\tline_info_offset = attribute->uconstant;\n\t\t\t} else if (attribute->kind == DW_AT_KIND_REFERENCE) {\n\t\t\t\tline_info_offset = attribute->reference;\n\t\t\t}\n\t\t}\n\t\tdie->count++;\n\t}\n\tif (comp_dir && line_info_offset != UT64_MAX) {\n\t\tchar *name = strdup(comp_dir);\n\t\tif (name) {\n\t\t\tif (!ht_up_insert(info->line_info_offset_comp_dir, line_info_offset, name)) {\n\t\t\t\tfree(name);\n\t\t\t}\n\t\t}\n\t}\n\treturn buf;\n}", "target": 1}
{"code": "char* _multi_string_alloc_and_copy( LPCWSTR in )\n{\n    char *chr;\n    int len = 0;\n    if ( !in )\n    {\n        return in;\n    }\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        len ++;\n    }\n    chr = malloc( len + 2 );\n    len = 0;\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        chr[ len ] = 0xFF & in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = '\\0';\n    chr[ len ++ ] = '\\0';\n    return chr;\n}", "target": 1}
{"code": "libxlDomainObjPrivateAlloc(void *opaque G_GNUC_UNUSED)\n{\n    libxlDomainObjPrivate *priv;\n    priv = g_new0(libxlDomainObjPrivate, 1);\n    if (!(priv->devs = virChrdevAlloc())) {\n        g_free(priv);\n        return NULL;\n    }\n    if (libxlDomainObjInitJob(priv) < 0) {\n        virChrdevFree(priv->devs);\n        g_free(priv);\n        return NULL;\n    }\n    return priv;\n}", "target": 0}
{"code": "static Jsi_RC DebugInfoCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (!interp->breakpointHash) {\n        Jsi_ValueMakeArrayObject(interp, ret, NULL);\n        return JSI_OK;\n    }\n    int argc = Jsi_ValueGetLength(interp, args);\n    if (argc == 0)\n        return Jsi_HashKeysDump(interp, interp->breakpointHash, ret, 0);\n    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);\n    int num;\n    char nbuf[100];\n    if (Jsi_GetIntFromValue(interp, val, &num) != JSI_OK) \n        return Jsi_LogError(\"bad number\");\n    snprintf(nbuf, sizeof(nbuf), \"%d\", num);\n    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->breakpointHash, nbuf);\n    if (!hPtr) \n        return Jsi_LogError(\"unknown breakpoint\");\n    jsi_BreakPoint* bp = (jsi_BreakPoint*)Jsi_HashValueGet(hPtr);\n    if (!bp) return JSI_ERROR;\n    Jsi_DString dStr = {};\n    if (bp->func)\n        Jsi_DSPrintf(&dStr, \"{id:%d, type:\\\"func\\\", func:\\\"%s\\\", hits:%d, enabled:%s, temporary:%s}\",\n         bp->id, bp->func, bp->hits, bp->enabled?\"true\":\"false\", bp->temp?\"true\":\"false\");\n    else\n        Jsi_DSPrintf(&dStr, \"{id:%d, type:\\\"line\\\", file:\\\"%s\\\", line:%d, hits:%d, enabled:%s}\",\n            bp->id, bp->file?bp->file:\"\", bp->line, bp->hits, bp->enabled?\"true\":\"false\");\n    Jsi_RC rc = Jsi_JSONParse(interp, Jsi_DSValue(&dStr), ret, 0);\n    Jsi_DSFree(&dStr);\n    return rc;\n}", "target": 1}
{"code": "static int adpt_abort(struct scsi_cmnd * cmd)\n{\n\tadpt_hba* pHba = NULL;\t\n\tstruct adpt_device* dptdevice;\t\n\tu32 msg[5];\n\tint rcode;\n\tpHba = (adpt_hba*) cmd->device->host->hostdata[0];\n\tprintk(KERN_INFO\"%s: Trying to Abort\\n\",pHba->name);\n\tif ((dptdevice = (void*) (cmd->device->hostdata)) == NULL) {\n\t\tprintk(KERN_ERR \"%s: Unable to abort: No device in cmnd\\n\",pHba->name);\n\t\treturn FAILED;\n\t}\n\tmemset(msg, 0, sizeof(msg));\n\tmsg[0] = FIVE_WORD_MSG_SIZE|SGL_OFFSET_0;\n\tmsg[1] = I2O_CMD_SCSI_ABORT<<24|HOST_TID<<12|dptdevice->tid;\n\tmsg[2] = 0;\n\tmsg[3]= 0;\n\tmsg[4] = scsi_cmd_to_rq(cmd)->tag + 1;\n\tif (pHba->host)\n\t\tspin_lock_irq(pHba->host->host_lock);\n\trcode = adpt_i2o_post_wait(pHba, msg, sizeof(msg), FOREVER);\n\tif (pHba->host)\n\t\tspin_unlock_irq(pHba->host->host_lock);\n\tif (rcode != 0) {\n\t\tif(rcode == -EOPNOTSUPP ){\n\t\t\tprintk(KERN_INFO\"%s: Abort cmd not supported\\n\",pHba->name);\n\t\t\treturn FAILED;\n\t\t}\n\t\tprintk(KERN_INFO\"%s: Abort failed.\\n\",pHba->name);\n\t\treturn FAILED;\n\t} \n\tprintk(KERN_INFO\"%s: Abort complete.\\n\",pHba->name);\n\treturn SUCCESS;\n}", "target": 1}
{"code": "hb_buffer_get_reference_count (hb_buffer_t *buffer)\n{\n  HB_OBJECT_DO_GET_REFERENCE_COUNT (buffer);\n}", "target": 0}
{"code": "static inline int alloc_debug_processing(struct kmem_cache *s,\n\tstruct page *page, void *object, void *addr) { return 0; }", "target": 0}
{"code": "static void do_pclose(FILE *fin, FILE *fout) {\n  char buf[BUFFER_SIZE];\n  int64_t fptr = 0;\n  read_buf(fin, buf);\n  sscanf(buf, \"%\" PRId64, &fptr);\n  FILE *f = (FILE *)fptr;\n  int ret = ::pclose(f);\n  fprintf(fout, \"%d\\n\", ret);\n  if (ret < 0) {\n    fprintf(fout, \"%d\\n\", errno);\n  }\n  fflush(fout);\n}", "target": 1}
{"code": "void DCR_CLASS dcr_parse_riff(DCRAW* p)\n{\n\tunsigned i, size, end;\n\tchar tag[4], date[64], month[64];\n\tstatic const char mon[12][4] =\n\t{ \"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\" };\n\tstruct tm t;\n\tp->order = 0x4949;\n\tdcr_fread(p->obj_, tag, 4, 1);\n\tsize = dcr_get4(p);\n\tend = dcr_ftell(p->obj_) + size;\n\tif (!memcmp(tag,\"RIFF\",4) || !memcmp(tag,\"LIST\",4)) {\n\t\tdcr_get4(p);\n\t\twhile (dcr_ftell(p->obj_)+7 < (long)end)\n\t\t\tdcr_parse_riff(p);\n\t} else if (!memcmp(tag,\"nctg\",4)) {\n\t\twhile (dcr_ftell(p->obj_)+7 < (long)end) {\n\t\t\ti = dcr_get2(p);\n\t\t\tsize = dcr_get2(p);\n\t\t\tif ((i+1) >> 1 == 10 && size == 20)\n\t\t\t\tdcr_get_timestamp(p,0);\n\t\t\telse dcr_fseek(p->obj_, size, SEEK_CUR);\n\t\t}\n\t} else if (!memcmp(tag,\"IDIT\",4) && size < 64) {\n\t\tdcr_fread(p->obj_, date, 64, 1);\n\t\tdate[size] = 0;\n\t\tmemset (&t, 0, sizeof t);\n\t\tif (sscanf (date, \"%*s %s %d %d:%d:%d %d\", month, &t.tm_mday,\n\t\t\t&t.tm_hour, &t.tm_min, &t.tm_sec, &t.tm_year) == 6) {\n\t\t\tfor (i=0; i < 12 && strcasecmp(mon[i],month); i++);\n\t\t\tt.tm_mon = i;\n\t\t\tt.tm_year -= 1900;\n\t\t\tif (mktime(&t) > 0)\n\t\t\t\tp->timestamp = mktime(&t);\n\t\t}\n\t} else\n\t\tdcr_fseek(p->obj_, size, SEEK_CUR);\n}", "target": 1}
{"code": "DwaCompressor::uncompress\n    (const char *inPtr,\n     int inSize,\n     int minY,\n     const char *&outPtr)\n{\n    return uncompress (inPtr,\n                       inSize,\n                       IMATH_NAMESPACE::Box2i (IMATH_NAMESPACE::V2i (_min[0], minY),\n                       IMATH_NAMESPACE::V2i (_max[0], minY + numScanLines() - 1)),\n                       outPtr);\n}", "target": 0}
{"code": "static int php_curl_option_url(php_curl *ch, const char *url, const int len) \n{\n\tif (PG(open_basedir) && *PG(open_basedir)) {\n#if LIBCURL_VERSION_NUM >= 0x071304\n\t\tcurl_easy_setopt(ch->cp, CURLOPT_PROTOCOLS, CURLPROTO_ALL & ~CURLPROTO_FILE);\n#else\n\t\tphp_url *uri;\n\t\tif (!(uri = php_url_parse_ex(url, len))) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Invalid URL '%s'\", url);\n\t\t\treturn FAILURE;\n\t\t}\n\t\tif (uri->scheme && !strncasecmp(\"file\", uri->scheme, sizeof(\"file\"))) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Protocol 'file' disabled in cURL\");\n\t\t\tphp_url_free(uri);\n\t\t\treturn FAILURE;\n\t\t}\n\t\tphp_url_free(uri);\n#endif\n\t}\n\treturn php_curl_option_str(ch, CURLOPT_URL, url, len, 0);\n}", "target": 0}
{"code": "get_parent_resource(const dav_resource *resource,\n                    dav_resource **parent_resource)\n{\n  dav_resource *parent;\n  dav_resource_private *parentinfo;\n  svn_stringbuf_t *path = resource->info->uri_path;\n  *parent_resource = NULL;\n  if (path->len == 1 && *path->data == '/')\n    return NULL;\n  switch (resource->type)\n    {\n    case DAV_RESOURCE_TYPE_REGULAR:\n      parent = apr_pcalloc(resource->pool, sizeof(*parent));\n      parentinfo  = apr_pcalloc(resource->pool, sizeof(*parentinfo));\n      parent->type = DAV_RESOURCE_TYPE_REGULAR;\n      parent->exists = 1;\n      parent->collection = 1;\n      parent->versioned = 1;\n      parent->hooks = resource->hooks;\n      parent->pool = resource->pool;\n      parent->uri = get_parent_path(svn_urlpath__canonicalize(resource->uri,\n                                                              resource->pool),\n                                    TRUE, resource->pool);\n      parent->info = parentinfo;\n      parentinfo->uri_path =\n        svn_stringbuf_create(get_parent_path(resource->info->uri_path->data,\n                                             TRUE, resource->pool),\n                             resource->pool);\n      parentinfo->repos = resource->info->repos;\n      parentinfo->root = resource->info->root;\n      parentinfo->r = resource->info->r;\n      parentinfo->svn_client_options = resource->info->svn_client_options;\n      parentinfo->repos_path = get_parent_path(resource->info->repos_path,\n                                               FALSE, resource->pool);\n      *parent_resource = parent;\n      break;\n    case DAV_RESOURCE_TYPE_WORKING:\n      *parent_resource =\n        create_private_resource(resource, DAV_SVN_RESTYPE_WRK_COLLECTION);\n      break;\n    case DAV_RESOURCE_TYPE_ACTIVITY:\n      *parent_resource =\n        create_private_resource(resource, DAV_SVN_RESTYPE_ACT_COLLECTION);\n      break;\n    case DAV_RESOURCE_TYPE_PRIVATE:\n      if ((resource->info->restype == DAV_SVN_RESTYPE_TXN_COLLECTION)\n          || (resource->info->restype == DAV_SVN_RESTYPE_REV_COLLECTION))\n        *parent_resource =\n          create_private_resource(resource, resource->info->restype);\n      break;\n    default:\n      break;\n    }\n  if (! *parent_resource)\n    return dav_svn__new_error(resource->pool, HTTP_INTERNAL_SERVER_ERROR, 0,\n                              apr_psprintf(resource->pool,\n                                           \"get_parent_resource was called for \"\n                                           \"%s (type %d)\",\n                                           resource->uri, resource->type));\n  return NULL;\n}", "target": 1}
{"code": "static enum led_brightness k90_backlight_get(struct led_classdev *led_cdev)\n{\n\tint ret;\n\tstruct k90_led *led = container_of(led_cdev, struct k90_led, cdev);\n\tstruct device *dev = led->cdev.dev->parent;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint brightness;\n\tchar data[8];\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_STATUS,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n\t\t\t ret);\n\t\treturn -EIO;\n\t}\n\tbrightness = data[4];\n\tif (brightness < 0 || brightness > 3) {\n\t\tdev_warn(dev,\n\t\t\t \"Read invalid backlight brightness: %02hhx.\\n\",\n\t\t\t data[4]);\n\t\treturn -EIO;\n\t}\n\treturn brightness;\n}", "target": 1}
{"code": "static MagickBooleanType ReadPSDChannelPixels(Image *image,const ssize_t row,\n  const PixelChannel channel,const unsigned char *pixels,\n  ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n  const unsigned char\n    *p;\n  Quantum\n    *q;\n  ssize_t\n    x;\n  size_t\n    packet_size;\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (Quantum *) NULL)\n    return MagickFalse;\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      if (packet_size == 2)\n        {\n          unsigned short\n            nibble;\n          p=PushShortPixel(MSBEndian,p,&nibble);\n          pixel=ScaleShortToQuantum(nibble);\n        }\n      else\n        {\n          MagickFloatType\n            nibble;\n          p=PushFloatPixel(MSBEndian,p,&nibble);\n          pixel=ClampToQuantum(((MagickRealType) QuantumRange)*nibble);\n        }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channel,packet_size,pixel,q,exception);\n        q+=GetPixelChannels(image);\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n        number_bits=(ssize_t) image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit = 0; bit < (ssize_t) number_bits; bit++)\n        {\n          SetPSDPixel(image,channel,packet_size,(((unsigned char) pixel)\n            & (0x01 << (7-bit))) != 0 ? 0 : QuantumRange,q,exception);\n          q+=GetPixelChannels(image);\n          x++;\n        }\n        if (x != (ssize_t) image->columns)\n          x--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}", "target": 1}
{"code": "efind(name)\nchar *name;\n{\n\tstatic char efbuf[100];\n\tmy_regex_t re;\n\tsprintf(efbuf, \"REG_%s\", name);\n\tassert(strlen(efbuf) < sizeof(efbuf));\n\tre.re_endp = efbuf;\n\t(void) my_regerror(REG_ATOI, &re, efbuf, sizeof(efbuf));\n\treturn(atoi(efbuf));\n}", "target": 1}
{"code": "gbk_mbc_case_fold(OnigCaseFoldType flag, const UChar** pp, const UChar* end,\n                    UChar* lower, OnigEncoding enc)\n{\n  return onigenc_mbn_mbc_case_fold(enc, flag,\n                                   pp, end, lower);\n}", "target": 0}
{"code": "static void vmx_set_constant_host_state(struct vcpu_vmx *vmx)\n{\n\tu32 low32, high32;\n\tunsigned long tmpl;\n\tstruct desc_ptr dt;\n\tvmcs_writel(HOST_CR0, read_cr0() & ~X86_CR0_TS);  \n\tvmcs_writel(HOST_CR4, read_cr4());  \n\tvmcs_writel(HOST_CR3, read_cr3());  \n\tvmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);  \n#ifdef CONFIG_X86_64\n\tvmcs_write16(HOST_DS_SELECTOR, 0);\n\tvmcs_write16(HOST_ES_SELECTOR, 0);\n#else\n\tvmcs_write16(HOST_DS_SELECTOR, __KERNEL_DS);  \n\tvmcs_write16(HOST_ES_SELECTOR, __KERNEL_DS);  \n#endif\n\tvmcs_write16(HOST_SS_SELECTOR, __KERNEL_DS);  \n\tvmcs_write16(HOST_TR_SELECTOR, GDT_ENTRY_TSS*8);  \n\tnative_store_idt(&dt);\n\tvmcs_writel(HOST_IDTR_BASE, dt.address);   \n\tvmx->host_idt_base = dt.address;\n\tvmcs_writel(HOST_RIP, vmx_return); \n\trdmsr(MSR_IA32_SYSENTER_CS, low32, high32);\n\tvmcs_write32(HOST_IA32_SYSENTER_CS, low32);\n\trdmsrl(MSR_IA32_SYSENTER_EIP, tmpl);\n\tvmcs_writel(HOST_IA32_SYSENTER_EIP, tmpl);   \n\tif (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT) {\n\t\trdmsr(MSR_IA32_CR_PAT, low32, high32);\n\t\tvmcs_write64(HOST_IA32_PAT, low32 | ((u64) high32 << 32));\n\t}\n}", "target": 1}
{"code": "*/\nPHP_METHOD(DateTimeImmutable, __set_state)\n{\n\tphp_date_obj     *dateobj;\n\tzval             *array;\n\tHashTable        *myht;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"a\", &array) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tmyht = HASH_OF(array);\n\tphp_date_instantiate(date_ce_immutable, return_value TSRMLS_CC);\n\tdateobj = (php_date_obj *) zend_object_store_get_object(return_value TSRMLS_CC);\n\tif (!php_date_initialize_from_hash(&dateobj, myht TSRMLS_CC)) {\n\t\tphp_error(E_ERROR, \"Invalid serialization data for DateTimeImmutable object\");\n\t}", "target": 0}
{"code": "kvp_respond_to_host(char *key, char *value, int error)\n{\n\tstruct hv_kvp_msg  *kvp_msg;\n\tstruct hv_kvp_msg_enumerate  *kvp_data;\n\tchar\t*key_name;\n\tstruct icmsg_hdr *icmsghdrp;\n\tint\tkeylen, valuelen;\n\tu32\tbuf_len;\n\tstruct vmbus_channel *channel;\n\tu64\treq_id;\n\tif (!kvp_transaction.active) {\n\t\tpr_warn(\"KVP: Transaction not active\\n\");\n\t\treturn;\n\t}\n\tbuf_len = kvp_transaction.recv_len;\n\tchannel = kvp_transaction.recv_channel;\n\treq_id = kvp_transaction.recv_req_id;\n\tkvp_transaction.active = false;\n\tif (channel->onchannel_callback == NULL)\n\t\treturn;\n\ticmsghdrp = (struct icmsg_hdr *)\n\t\t\t&recv_buffer[sizeof(struct vmbuspipe_hdr)];\n\tkvp_msg = (struct hv_kvp_msg *)\n\t\t\t&recv_buffer[sizeof(struct vmbuspipe_hdr) +\n\t\t\tsizeof(struct icmsg_hdr)];\n\tkvp_data = &kvp_msg->kvp_data;\n\tkey_name = key;\n\tif (error) {\n\t\ticmsghdrp->status = HV_E_FAIL;\n\t\tgoto response_done;\n\t}\n\tkeylen = utf8s_to_utf16s(key_name, strlen(key_name),\n\t\t\t\t(wchar_t *)kvp_data->data.key);\n\tkvp_data->data.key_size = 2*(keylen + 1); \n\tvaluelen = utf8s_to_utf16s(value, strlen(value),\n\t\t\t\t(wchar_t *)kvp_data->data.value);\n\tkvp_data->data.value_size = 2*(valuelen + 1); \n\tkvp_data->data.value_type = REG_SZ; \n\ticmsghdrp->status = HV_S_OK;\nresponse_done:\n\ticmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION | ICMSGHDRFLAG_RESPONSE;\n\tvmbus_sendpacket(channel, recv_buffer, buf_len, req_id,\n\t\t\t\tVM_PKT_DATA_INBAND, 0);\n}", "target": 1}
{"code": "smb2_flush(smb_request_t *sr)\n{\n\tsmb_ofile_t *of = NULL;\n\tuint16_t StructSize;\n\tuint16_t reserved1;\n\tuint32_t reserved2;\n\tsmb2fid_t smb2fid;\n\tuint32_t status;\n\tint rc = 0;\n\trc = smb_mbc_decodef(\n\t    &sr->smb_data, \"wwlqq\",\n\t    &StructSize,\t\t\n\t    &reserved1,\t\t\t\n\t    &reserved2,\t\t\t\n\t    &smb2fid.persistent,\t\n\t    &smb2fid.temporal);\t\t\n\tif (rc)\n\t\treturn (SDRC_ERROR);\n\tif (StructSize != 24)\n\t\treturn (SDRC_ERROR);\n\tstatus = smb2sr_lookup_fid(sr, &smb2fid);\n\tif (status) {\n\t\tsmb2sr_put_error(sr, status);\n\t\treturn (SDRC_SUCCESS);\n\t}\n\tof = sr->fid_ofile;\n\tif ((of->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n\t\t(void) smb_fsop_commit(sr, of->f_cr, of->f_node);\n\t(void) smb_mbc_encodef(\n\t    &sr->reply, \"wwl\",\n\t    4,\t\t\n\t    0); \t\t\n\treturn (SDRC_SUCCESS);\n}", "target": 1}
{"code": "void cgit_tag_link(const char *name, const char *title, const char *class,\n\t\t   const char *tag)\n{\n\treporevlink(\"tag\", name, title, class, tag, NULL, NULL);\n}", "target": 0}
{"code": "flatpak_proxy_client_finalize (GObject *object)\n{\n  FlatpakProxyClient *client = FLATPAK_PROXY_CLIENT (object);\n  client->proxy->clients = g_list_remove (client->proxy->clients, client);\n  g_clear_object (&client->proxy);\n  g_byte_array_free (client->auth_buffer, TRUE);\n  g_hash_table_destroy (client->rewrite_reply);\n  g_hash_table_destroy (client->get_owner_reply);\n  g_hash_table_destroy (client->unique_id_policy);\n  free_side (&client->client_side);\n  free_side (&client->bus_side);\n  G_OBJECT_CLASS (flatpak_proxy_client_parent_class)->finalize (object);\n}", "target": 0}
{"code": "static int l2cap_build_conf_req(struct sock *sk, void *data)\n{\n\tstruct l2cap_pinfo *pi = l2cap_pi(sk);\n\tstruct l2cap_conf_req *req = data;\n\tstruct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };\n\tvoid *ptr = req->data;\n\tBT_DBG(\"sk %p\", sk);\n\tswitch (pi->mode) {\n\tcase L2CAP_MODE_BASIC:\n\t\tif (pi->imtu != L2CAP_DEFAULT_MTU)\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->imtu);\n\t\tbreak;\n\tcase L2CAP_MODE_ERTM:\n\t\trfc.mode            = L2CAP_MODE_ERTM;\n\t\trfc.txwin_size      = L2CAP_DEFAULT_RX_WINDOW;\n\t\trfc.max_transmit    = L2CAP_DEFAULT_MAX_RECEIVE;\n\t\trfc.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO);\n\t\trfc.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO);\n\t\trfc.max_pdu_size    = cpu_to_le16(L2CAP_DEFAULT_MAX_RX_APDU);\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n\t\t\t\t\tsizeof(rfc), (unsigned long) &rfc);\n\t\tbreak;\n\t}\n\treq->dcid  = cpu_to_le16(pi->dcid);\n\treq->flags = cpu_to_le16(0);\n\treturn ptr - data;\n}", "target": 1}
{"code": "static void prep_new_huge_page(struct hstate *h, struct page *page, int nid)\n{\n\t__prep_new_huge_page(h, page);\n\tspin_lock_irq(&hugetlb_lock);\n\t__prep_account_new_huge_page(h, nid);\n\tspin_unlock_irq(&hugetlb_lock);\n}", "target": 0}
{"code": "TEST_FUNCTION_INITIALIZE(test_init)\n{\n    if (TEST_MUTEX_ACQUIRE(g_testByTest))\n    {\n        ASSERT_FAIL(\"our mutex is ABANDONED. Failure in test framework\");\n    }\n    umock_c_reset_all_calls();\n}", "target": 0}
{"code": "static int __init pcd_init(void)\n{\n\tstruct pcd_unit *cd;\n\tint unit;\n\tif (disable)\n\t\treturn -EINVAL;\n\tpcd_init_units();\n\tif (pcd_detect())\n\t\treturn -ENODEV;\n\tpcd_probe_capabilities();\n\tif (register_blkdev(major, name)) {\n\t\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++)\n\t\t\tput_disk(cd->disk);\n\t\treturn -EBUSY;\n\t}\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tif (cd->present) {\n\t\t\tregister_cdrom(&cd->info);\n\t\t\tcd->disk->private_data = cd;\n\t\t\tadd_disk(cd->disk);\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "const char* ExpressionRandom::getOpName() const {\n    return \"$rand\";\n}", "target": 0}
{"code": "UrlQuery::UrlQuery(const std::string& encoded_str) {\n  if (!encoded_str.empty()) {\n    for (std::size_t i = 0; i != std::string::npos;) {\n      std::size_t j = encoded_str.find_first_of('&', i);\n      std::string kv;\n      if (j == std::string::npos) {\n        kv = encoded_str.substr(i);\n        i = std::string::npos;\n      } else {\n        kv = encoded_str.substr(i, j - i);\n        i = j + 1;\n      }\n      string_view key;\n      string_view value;\n      if (SplitKV(kv, '=', false, &key, &value)) {\n        parameters_.push_back({ DecodeUnsafe(key), DecodeUnsafe(value) });\n      }\n    }\n  }\n}", "target": 1}
{"code": "static const ut8 *parse_die(const ut8 *buf, const ut8 *buf_end, RBinDwarfAbbrevDecl *abbrev,\n\t\tRBinDwarfCompUnitHdr *hdr, RBinDwarfDie *die, const ut8 *debug_str, size_t debug_str_len, Sdb *sdb) {\n\tsize_t i;\n\tfor (i = 0; i < abbrev->count - 1; i++) {\n\t\tmemset (&die->attr_values[i], 0, sizeof (die->attr_values[i]));\n\t\tbuf = parse_attr_value (buf, buf_end - buf, &abbrev->defs[i],\n\t\t\t&die->attr_values[i], hdr, debug_str, debug_str_len);\n\t\tRBinDwarfAttrValue *attribute = &die->attr_values[i];\n\t\tbool is_valid_string_form = (attribute->attr_form == DW_FORM_strp ||\n\t\t\tattribute->attr_form == DW_FORM_string) &&\n\t\t\tattribute->string.content;\n\t\tif (attribute->attr_name == DW_AT_comp_dir && is_valid_string_form) {\n\t\t\tconst char *name = attribute->string.content;\n\t\t\tsdb_set (sdb, \"DW_AT_comp_dir\", name, 0);\n\t\t}\n\t\tdie->count++;\n\t}\n\treturn buf;\n}", "target": 1}
{"code": "expand_command(struct eventlog *evlog, char **newbuf)\n{\n    size_t len, bufsize = strlen(evlog->command) + 1;\n    char *cp, *buf;\n    int ac;\n    debug_decl(expand_command, SUDO_DEBUG_UTIL);\n    if (evlog->argv == NULL || evlog->argv[0] == NULL || evlog->argv[1] == NULL) {\n\t*newbuf = NULL;\n\tdebug_return_str(evlog->command);\n    }\n    for (ac = 1; evlog->argv[ac] != NULL; ac++)\n\tbufsize += strlen(evlog->argv[ac]) + 1;\n    if ((buf = malloc(bufsize)) == NULL)\n\tsudo_fatalx(U_(\"%s: %s\"), __func__, U_(\"unable to allocate memory\"));\n    cp = buf;\n    len = strlcpy(cp, evlog->command, bufsize);\n    if (len >= bufsize)\n\tsudo_fatalx(U_(\"internal error, %s overflow\"), __func__);\n    cp += len;\n    bufsize -= len;\n    for (ac = 1; evlog->argv[ac] != NULL; ac++) {\n\tif (bufsize < 2)\n\t    sudo_fatalx(U_(\"internal error, %s overflow\"), __func__);\n\t*cp++ = ' ';\n\tbufsize--;\n\tlen = strlcpy(cp, evlog->argv[ac], bufsize);\n\tif (len >= bufsize)\n\t    sudo_fatalx(U_(\"internal error, %s overflow\"), __func__);\n\tcp += len;\n\tbufsize -= len;\n    }\n    *newbuf = buf;\n    debug_return_str(buf);\n}", "target": 0}
{"code": "static int make_ydt24_entry(int p1, int p2, int16_t *ydt)\n{\n    int lo, hi;\n    lo = ydt[p1];\n    hi = ydt[p2];\n    return (lo + (hi << 8) + (hi << 16)) << 1;\n}", "target": 0}
{"code": "wsemul_vt100_output_csi(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tu_int newstate = VT100_EMUL_STATE_CSI;\n\tint oargs;\n\tint rc = 0;\n\tswitch (instate->inchar) {\n\tcase '0': case '1': case '2': case '3': case '4':\n\tcase '5': case '6': case '7': case '8': case '9':\n\t\tif (edp->nargs > VT100_EMUL_NARGS - 1)\n\t\t\tbreak;\n\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\tcase ';': \n\t\tedp->nargs++;\n\t\tbreak;\n\tcase '?': \n\tcase '>': \n\t\tedp->modif1 = (char)instate->inchar;\n\t\tbreak;\n\tcase '!':\n\tcase '\"':\n\tcase '$':\n\tcase '&':\n\t\tedp->modif2 = (char)instate->inchar;\n\t\tbreak;\n\tdefault: \n\t\toargs = edp->nargs++;\n\t\tif (edp->nargs > VT100_EMUL_NARGS) {\n#ifdef VT100_DEBUG\n\t\t\tprintf(\"vt100: too many arguments\\n\");\n#endif\n\t\t\tedp->nargs = VT100_EMUL_NARGS;\n\t\t}\n\t\trc = wsemul_vt100_handle_csi(edp, instate);\n\t\tif (rc != 0) {\n\t\t\tedp->nargs = oargs;\n\t\t\treturn rc;\n\t\t}\n\t\tnewstate = VT100_EMUL_STATE_NORMAL;\n\t\tbreak;\n\t}\n\tif (COLS_LEFT != 0)\n\t\tedp->flags &= ~VTFL_LASTCHAR;\n\tedp->state = newstate;\n\treturn 0;\n}", "target": 1}
{"code": "static int adis_update_scan_mode_burst(struct iio_dev *indio_dev,\n\tconst unsigned long *scan_mask)\n{\n\tstruct adis *adis = iio_device_get_drvdata(indio_dev);\n\tunsigned int burst_length;\n\tu8 *tx;\n\tburst_length = (indio_dev->num_channels - 1) * sizeof(u16);\n\tburst_length += adis->burst->extra_len;\n\tadis->xfer = kcalloc(2, sizeof(*adis->xfer), GFP_KERNEL);\n\tif (!adis->xfer)\n\t\treturn -ENOMEM;\n\tadis->buffer = kzalloc(burst_length + sizeof(u16), GFP_KERNEL);\n\tif (!adis->buffer)\n\t\treturn -ENOMEM;\n\ttx = adis->buffer + burst_length;\n\ttx[0] = ADIS_READ_REG(adis->burst->reg_cmd);\n\ttx[1] = 0;\n\tadis->xfer[0].tx_buf = tx;\n\tadis->xfer[0].bits_per_word = 8;\n\tadis->xfer[0].len = 2;\n\tadis->xfer[1].rx_buf = adis->buffer;\n\tadis->xfer[1].bits_per_word = 8;\n\tadis->xfer[1].len = burst_length;\n\tspi_message_init(&adis->msg);\n\tspi_message_add_tail(&adis->xfer[0], &adis->msg);\n\tspi_message_add_tail(&adis->xfer[1], &adis->msg);\n\treturn 0;\n}", "target": 1}
{"code": "TightDecoder::FilterGradient24(const rdr::U8 *inbuf,\n                               const PixelFormat& pf, PIXEL_T* outbuf,\n                               int stride, const Rect& r)\n{\n  int x, y, c;\n  rdr::U8 prevRow[TIGHT_MAX_WIDTH*3];\n  rdr::U8 thisRow[TIGHT_MAX_WIDTH*3];\n  rdr::U8 pix[3]; \n  int est[3]; \n  memset(prevRow, 0, sizeof(prevRow));\n  int rectHeight = r.height();\n  int rectWidth = r.width();\n  for (y = 0; y < rectHeight; y++) {\n    for (c = 0; c < 3; c++) {\n      pix[c] = inbuf[y*rectWidth*3+c] + prevRow[c];\n      thisRow[c] = pix[c];\n    }\n    pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride], pix, 1);\n    for (x = 1; x < rectWidth; x++) {\n      for (c = 0; c < 3; c++) {\n        est[c] = prevRow[x*3+c] + pix[c] - prevRow[(x-1)*3+c];\n        if (est[c] > 0xff) {\n          est[c] = 0xff;\n        } else if (est[c] < 0) {\n          est[c] = 0;\n        }\n        pix[c] = inbuf[(y*rectWidth+x)*3+c] + est[c];\n        thisRow[x*3+c] = pix[c];\n      }\n      pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride+x], pix, 1);\n    }\n    memcpy(prevRow, thisRow, sizeof(prevRow));\n  }\n}", "target": 1}
{"code": "static struct ucounts *get_ucounts(struct user_namespace *ns, kuid_t uid)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ns, uid);\n\tstruct ucounts *ucounts, *new;\n\tspin_lock_irq(&ucounts_lock);\n\tucounts = find_ucounts(ns, uid, hashent);\n\tif (!ucounts) {\n\t\tspin_unlock_irq(&ucounts_lock);\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn NULL;\n\t\tnew->ns = ns;\n\t\tnew->uid = uid;\n\t\tatomic_set(&new->count, 0);\n\t\tspin_lock_irq(&ucounts_lock);\n\t\tucounts = find_ucounts(ns, uid, hashent);\n\t\tif (ucounts) {\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\thlist_add_head(&new->node, hashent);\n\t\t\tucounts = new;\n\t\t}\n\t}\n\tif (!atomic_add_unless(&ucounts->count, 1, INT_MAX))\n\t\tucounts = NULL;\n\tspin_unlock_irq(&ucounts_lock);\n\treturn ucounts;\n}", "target": 1}
{"code": "static UINT serial_process_irp_write(SERIAL_DEVICE* serial, IRP* irp)\n{\n\tUINT32 Length;\n\tUINT64 Offset;\n\tDWORD nbWritten = 0;\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT32(irp->input, Length); \n\tStream_Read_UINT64(irp->input, Offset); \n\tStream_Seek(irp->input, 20);            \n\tWLog_Print(serial->log, WLOG_DEBUG, \"writing %\" PRIu32 \" bytes to %s\", Length,\n\t           serial->device.name);\n\tif (CommWriteFile(serial->hComm, Stream_Pointer(irp->input), Length, &nbWritten, NULL))\n\t{\n\t\tirp->IoStatus = STATUS_SUCCESS;\n\t}\n\telse\n\t{\n\t\tWLog_Print(serial->log, WLOG_DEBUG,\n\t\t           \"write failure to %s, nbWritten=%\" PRIu32 \", last-error: 0x%08\" PRIX32 \"\",\n\t\t           serial->device.name, nbWritten, GetLastError());\n\t\tirp->IoStatus = _GetLastErrorToIoStatus(serial);\n\t}\n\tWLog_Print(serial->log, WLOG_DEBUG, \"%\" PRIu32 \" bytes written to %s\", nbWritten,\n\t           serial->device.name);\n\tStream_Write_UINT32(irp->output, nbWritten); \n\tStream_Write_UINT8(irp->output, 0);          \n\treturn CHANNEL_RC_OK;\n}", "target": 1}
{"code": "sdev_iter_snapshots(struct vnode *dvp, char *name)\n{\n\tsdev_iter_datasets(dvp, ZFS_IOC_SNAPSHOT_LIST_NEXT, name);\n}", "target": 0}
{"code": "void SparseFillEmptyRowsOpImpl(OpKernelContext* context,\n                               AsyncOpKernel::DoneCallback done = nullptr) {\n  if (!done) {\n    done = [] {};\n  }\n  const int kIndicesInput = 0;\n  const int kValuesInput = 1;\n  const int kDenseShapeInput = 2;\n  const int kDefaultValueInput = 3;\n  const Tensor& indices_t = context->input(kIndicesInput);\n  const Tensor& values_t = context->input(kValuesInput);\n  const Tensor& dense_shape_t = context->input(kDenseShapeInput);\n  const Tensor& default_value_t = context->input(kDefaultValueInput);\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsVector(dense_shape_t.shape()),\n      errors::InvalidArgument(\"dense_shape must be a vector, saw: \",\n                              dense_shape_t.shape().DebugString()),\n      done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsMatrix(indices_t.shape()),\n                    errors::InvalidArgument(\"indices must be a matrix, saw: \",\n                                            indices_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsVector(values_t.shape()),\n                    errors::InvalidArgument(\"values must be a vector, saw: \",\n                                            values_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(\n      context, indices_t.dim_size(0) == values_t.dim_size(0),\n      errors::InvalidArgument(\"The length of `values` (\", values_t.dim_size(0),\n                              \") must match the first dimension of `indices` (\",\n                              indices_t.dim_size(0), \").\"),\n      done);\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsScalar(default_value_t.shape()),\n      errors::InvalidArgument(\"default_value must be a scalar, saw: \",\n                              default_value_t.shape().DebugString()),\n      done);\n  OP_REQUIRES_ASYNC(context, dense_shape_t.NumElements() != 0,\n                    errors::InvalidArgument(\"Dense shape cannot be empty.\"),\n                    done);\n  using FunctorType = functor::SparseFillEmptyRows<Device, T, Tindex>;\n  OP_REQUIRES_OK_ASYNC(context,\n                       FunctorType()(context, default_value_t, indices_t,\n                                     values_t, dense_shape_t, done),\n                       done);\n}", "target": 0}
{"code": "\tclass BadDistanceErr : public Err {public: BadDistanceErr() : Err(INVALID_DATA_FORMAT, \"Inflator: error in bit distance\") {}};", "target": 0}
{"code": "wb_prep(netdissect_options *ndo,\n        const struct pkt_prep *prep, u_int len)\n{\n\tint n;\n\tconst struct pgstate *ps;\n\tconst u_char *ep = ndo->ndo_snapend;\n\tND_PRINT((ndo, \" wb-prep:\"));\n\tif (len < sizeof(*prep)) {\n\t\treturn (-1);\n\t}\n\tn = EXTRACT_32BITS(&prep->pp_n);\n\tps = (const struct pgstate *)(prep + 1);\n\twhile (--n >= 0 && !ND_TTEST(*ps)) {\n\t\tconst struct id_off *io, *ie;\n\t\tchar c = '<';\n\t\tND_PRINT((ndo, \" %u/%s:%u\",\n\t\t    EXTRACT_32BITS(&ps->slot),\n\t\t    ipaddr_string(ndo, &ps->page.p_sid),\n\t\t    EXTRACT_32BITS(&ps->page.p_uid)));\n\t\tio = (struct id_off *)(ps + 1);\n\t\tfor (ie = io + ps->nid; io < ie && !ND_TTEST(*io); ++io) {\n\t\t\tND_PRINT((ndo, \"%c%s:%u\", c, ipaddr_string(ndo, &io->id),\n\t\t\t    EXTRACT_32BITS(&io->off)));\n\t\t\tc = ',';\n\t\t}\n\t\tND_PRINT((ndo, \">\"));\n\t\tps = (struct pgstate *)io;\n\t}\n\treturn ((u_char *)ps <= ep? 0 : -1);\n}", "target": 1}
{"code": "static void coroutine_fn v9fs_getattr(void *opaque)\n{\n    int32_t fid;\n    size_t offset = 7;\n    ssize_t retval = 0;\n    struct stat stbuf;\n    V9fsFidState *fidp;\n    uint64_t request_mask;\n    V9fsStatDotl v9stat_dotl;\n    V9fsPDU *pdu = opaque;\n    retval = pdu_unmarshal(pdu, offset, \"dq\", &fid, &request_mask);\n    if (retval < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_getattr(pdu->tag, pdu->id, fid, request_mask);\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        retval = -ENOENT;\n        goto out_nofid;\n    }\n    retval = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n    if (retval < 0) {\n        goto out;\n    }\n    retval = stat_to_v9stat_dotl(pdu, &stbuf, &v9stat_dotl);\n    if (retval < 0) {\n        goto out;\n    }\n    if (request_mask & P9_STATS_GEN) {\n        retval = v9fs_co_st_gen(pdu, &fidp->path, stbuf.st_mode, &v9stat_dotl);\n        switch (retval) {\n        case 0:\n            v9stat_dotl.st_result_mask |= P9_STATS_GEN;\n            break;\n        case -EINTR:\n            goto out;\n        default:\n            break;\n        }\n    }\n    retval = pdu_marshal(pdu, offset, \"A\", &v9stat_dotl);\n    if (retval < 0) {\n        goto out;\n    }\n    retval += offset;\n    trace_v9fs_getattr_return(pdu->tag, pdu->id, v9stat_dotl.st_result_mask,\n                              v9stat_dotl.st_mode, v9stat_dotl.st_uid,\n                              v9stat_dotl.st_gid);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, retval);\n}", "target": 0}
{"code": "void test_link(const char *path)\n{\n\tchar *d = strdupa(path), *tmpname;\n\td = dirname(d);\n\tsize_t len = strlen(path) + 30;\n\ttmpname = alloca(len);\n\tsnprintf(tmpname, len, \"%s/%d\", d, (int)getpid());\n\tif (link(path, tmpname) == 0) {\n\t\tfprintf(stderr, \"leak at link of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at link of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n\tif (link(tmpname, path) == 0) {\n\t\tfprintf(stderr, \"leak at link (2) of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at link (2) of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "static int adts_decode_extradata(AVFormatContext *s, ADTSContext *adts, const uint8_t *buf, int size)\n{\n    GetBitContext gb;\n    PutBitContext pb;\n    MPEG4AudioConfig m4ac;\n    int off;\n    init_get_bits(&gb, buf, size * 8);\n    off = avpriv_mpeg4audio_get_config2(&m4ac, buf, size, 1, s);\n    if (off < 0)\n        return off;\n    skip_bits_long(&gb, off);\n    adts->objecttype        = m4ac.object_type - 1;\n    adts->sample_rate_index = m4ac.sampling_index;\n    adts->channel_conf      = m4ac.chan_config;\n    if (adts->objecttype > 3U) {\n        av_log(s, AV_LOG_ERROR, \"MPEG-4 AOT %d is not allowed in ADTS\\n\", adts->objecttype+1);\n        return AVERROR_INVALIDDATA;\n    }\n    if (adts->sample_rate_index == 15) {\n        av_log(s, AV_LOG_ERROR, \"Escape sample rate index illegal in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"960/120 MDCT window is not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"Scalable configurations are not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"Extension flag is not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (!adts->channel_conf) {\n        init_put_bits(&pb, adts->pce_data, MAX_PCE_SIZE);\n        put_bits(&pb, 3, 5); \n        adts->pce_size = (ff_copy_pce_data(&pb, &gb) + 3) / 8;\n        flush_put_bits(&pb);\n    }\n    adts->write_adts = 1;\n    return 0;\n}", "target": 1}
{"code": "bool WideToCharMap(const wchar *Src,char *Dest,size_t DestSize,bool &Success)\n{\n  if (wcschr(Src,(wchar)MappedStringMark)==NULL)\n    return false;\n  Success=true;\n  uint SrcPos=0,DestPos=0;\n  while (Src[SrcPos]!=0 && DestPos<DestSize-MB_CUR_MAX)\n  {\n    if (uint(Src[SrcPos])==MappedStringMark)\n    {\n      SrcPos++;\n      continue;\n    }\n    if (uint(Src[SrcPos])>=MapAreaStart+0x80 && uint(Src[SrcPos])<MapAreaStart+0x100)\n      Dest[DestPos++]=char(uint(Src[SrcPos++])-MapAreaStart);\n    else\n    {\n      mbstate_t ps;\n      memset(&ps,0,sizeof(ps));\n      if (wcrtomb(Dest+DestPos,Src[SrcPos],&ps)==-1)\n      {\n        Dest[DestPos]='_';\n        Success=false;\n      }\n      SrcPos++;\n      memset(&ps,0,sizeof(ps));\n      int Length=mbrlen(Dest+DestPos,MB_CUR_MAX,&ps);\n      DestPos+=Max(Length,1);\n    }\n  }\n  Dest[Min(DestPos,DestSize-1)]=0;\n  return true;\n}", "target": 1}
{"code": "static int crypto_report_acomp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_acomp racomp;\n\tstrlcpy(racomp.type, \"acomp\", sizeof(racomp.type));\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_ACOMP,\n\t\t    sizeof(struct crypto_report_acomp), &racomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "TfLiteStatus Relu6Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  Relu6OpData* data = static_cast<Relu6OpData*>(node->user_data);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  if (input->type == kTfLiteInt8) {\n    data->six_int8 = FloatToAsymmetricQuantizedInt8(6.0f, input->params.scale,\n                                                    input->params.zero_point);\n    data->zero_int8 = input->params.zero_point;\n  } else if (input->type == kTfLiteUInt8) {\n    data->six_uint8 = FloatToAsymmetricQuantizedUInt8(6.0f, input->params.scale,\n                                                      input->params.zero_point);\n    data->zero_uint8 = input->params.zero_point;\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "void Jsi_ValueArrayShift(Jsi_Interp *interp, Jsi_Value *v)\n{\n    if (v->vt != JSI_VT_OBJECT) {\n        Jsi_LogBug(\"Jsi_ValueArrayShift, target is not object\");\n        return;\n    }\n    Jsi_Obj *o = v->d.obj;\n    if (o->isarrlist) {\n        uint i;\n        if (!o->arrCnt)\n            return;\n        if (o->arr[0])\n            Jsi_DecrRefCount(interp, o->arr[0]);\n        for (i=1; i<o->arrCnt; i++) {\n            o->arr[i-1] = o->arr[i];\n        }\n        o->arr[o->arrCnt--] = NULL;\n        return;\n    }\n    int len = Jsi_ObjGetLength(interp, v->d.obj);\n    if (len <= 0) return;\n    Jsi_Value *v0 = Jsi_ValueArrayIndex(interp, v, 0);\n    if (!v0) return;\n    Jsi_ValueReset(interp, &v0);\n    int i;\n    Jsi_Value *last = v0;\n    for (i = 1; i < len; ++i) {\n        Jsi_Value *t = Jsi_ValueArrayIndex(interp, v, i);\n        if (!t) return;\n        Jsi_ValueCopy(interp, last, t);\n        Jsi_ValueReset(interp, &t);\n        last = t;\n    }\n    Jsi_ObjSetLength(interp, v->d.obj, len - 1);\n}", "target": 1}
{"code": "static int amdgpu_cs_wait_all_fences(struct amdgpu_device *adev,\n\t\t\t\t     struct drm_file *filp,\n\t\t\t\t     union drm_amdgpu_wait_fences *wait,\n\t\t\t\t     struct drm_amdgpu_fence *fences)\n{\n\tuint32_t fence_count = wait->in.fence_count;\n\tunsigned int i;\n\tlong r = 1;\n\tfor (i = 0; i < fence_count; i++) {\n\t\tstruct dma_fence *fence;\n\t\tunsigned long timeout = amdgpu_gem_timeout(wait->in.timeout_ns);\n\t\tfence = amdgpu_cs_get_fence(adev, filp, &fences[i]);\n\t\tif (IS_ERR(fence))\n\t\t\treturn PTR_ERR(fence);\n\t\telse if (!fence)\n\t\t\tcontinue;\n\t\tr = dma_fence_wait_timeout(fence, true, timeout);\n\t\tdma_fence_put(fence);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t\tif (r == 0)\n\t\t\tbreak;\n\t\tif (fence->error)\n\t\t\treturn fence->error;\n\t}\n\tmemset(wait, 0, sizeof(*wait));\n\twait->out.status = (r > 0);\n\treturn 0;\n}", "target": 1}
{"code": "GF_Err load_svg_run(GF_SceneLoader *load)\n{\n\tu32 in_time;\n\tGF_Err e;\n\tGF_SVG_Parser *parser = (GF_SVG_Parser *)load->loader_priv;\n\tif (!parser) {\n\t\te = gf_sm_load_initialize_svg(load, NULL, GF_FALSE);\n\t\tif (e) return e;\n\t\tparser = (GF_SVG_Parser *)load->loader_priv;\n\t}\n\tin_time = gf_sys_clock();\n\te = gf_xml_sax_parse_file(parser->sax_parser, (const char *)load->fileName, svg_progress);\n\tif (parser->last_error<0) e = parser->last_error;\n\tif (e<0) return svg_report(parser, e, \"Unable to parse file %s: %s\", load->fileName, gf_xml_sax_get_error(parser->sax_parser) );\n\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"[Parser] Scene parsed and Scene Graph built in %d ms\\n\", gf_sys_clock() - in_time));\n\tsvg_flush_animations(parser);\n\tgf_sm_svg_flush_state(parser);\n\treturn e;\n}", "target": 1}
{"code": "TEST_F(ZNCTest, StatusEchoMessage) {\n    auto znc = Run();\n    auto ircd = ConnectIRCd();\n    auto client = LoginClient();\n    client.Write(\"CAP REQ :echo-message\");\n    client.Write(\"PRIVMSG *status :blah\");\n    client.ReadUntil(\":nick!user@irc.znc.in PRIVMSG *status :blah\");\n    client.ReadUntil(\":*status!znc@znc.in PRIVMSG nick :Unknown command\");\n    client.Write(\"znc delnetwork test\");\n    client.ReadUntil(\"Network deleted\");\n    auto client2 = LoginClient();\n    client2.Write(\"PRIVMSG *status :blah2\");\n    client2.ReadUntil(\":*status!znc@znc.in PRIVMSG nick :Unknown command\");\n    auto client3 = LoginClient();\n    client3.Write(\"PRIVMSG *status :blah3\");\n    client3.ReadUntil(\":*status!znc@znc.in PRIVMSG nick :Unknown command\");\n}", "target": 0}
{"code": "InputMethodBase::~InputMethodBase() {\n}", "target": 0}
{"code": "sudo_passwd_verify(const struct sudoers_context *ctx, struct passwd *pw,\n    const char *pass, sudo_auth *auth, struct sudo_conv_callback *callback)\n{\n    char des_pass[9], *epass;\n    char *pw_epasswd = auth->data;\n    size_t pw_len;\n    int matched = 0;\n    debug_decl(sudo_passwd_verify, SUDOERS_DEBUG_AUTH);\n    if (pass[0] == '\\0')\n\tdebug_return_int(pw_epasswd[0] ? AUTH_FAILURE : AUTH_SUCCESS);\n    pw_len = strlen(pw_epasswd);\n    if (pw_len == DESLEN || HAS_AGEINFO(pw_epasswd, pw_len)) {\n\tstrlcpy(des_pass, pass, sizeof(des_pass));\n\tpass = des_pass;\n    }\n    epass = (char *) crypt(pass, pw_epasswd);\n    if (epass != NULL) {\n\tif (HAS_AGEINFO(pw_epasswd, pw_len) && strlen(epass) == DESLEN)\n\t    matched = !strncmp(pw_epasswd, epass, DESLEN);\n\telse\n\t    matched = !strcmp(pw_epasswd, epass);\n    }\n    explicit_bzero(des_pass, sizeof(des_pass));\n    debug_return_int(matched ? AUTH_SUCCESS : AUTH_FAILURE);\n}", "target": 1}
{"code": "void * malloc(size_t lb)\n{\n#   if defined(I386) && defined(GC_SOLARIS_THREADS)\n      if (!EXPECT(GC_is_initialized, TRUE)) return sbrk(lb);\n#   endif \n    return((void *)REDIRECT_MALLOC(lb));\n}", "target": 0}
{"code": "static int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tint n;\n\tint ret;\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tlong newbufsize;\n\tlong newpos;\n\tassert(buf);\n\tassert(cnt >= 0);\n\tJAS_DBGLOG(100, (\"mem_write(%p, %p, %d)\\n\", obj, buf, cnt));\n\tnewpos = m->pos_ + cnt;\n\tif (newpos > m->bufsize_ && m->growable_) {\n\t\tnewbufsize = m->bufsize_;\n\t\twhile (newbufsize < newpos) {\n\t\t\tnewbufsize <<= 1;\n\t\t\tassert(newbufsize >= 0);\n\t\t}\n\t\tJAS_DBGLOG(100, (\"mem_write resizing from %d to %z\\n\", m->bufsize_,\n\t\t  newbufsize));\n\t\tJAS_DBGLOG(100, (\"mem_write resizing from %d to %ul\\n\", m->bufsize_,\n\t\t  JAS_CAST(unsigned long, newbufsize)));\n\t\tif (mem_resize(m, newbufsize)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (m->pos_ > m->len_) {\n\t\tn = JAS_MIN(m->pos_, m->bufsize_) - m->len_;\n\t\tif (n > 0) {\n\t\t\tmemset(&m->buf_[m->len_], 0, n);\n\t\t\tm->len_ += n;\n\t\t}\n\t\tif (m->pos_ != m->len_) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tn = m->bufsize_ - m->pos_;\n\tret = JAS_MIN(n, cnt);\n\tif (ret > 0) {\n\t\tmemcpy(&m->buf_[m->pos_], buf, ret);\n\t\tm->pos_ += ret;\n\t}\n\tif (m->pos_ > m->len_) {\n\t\tm->len_ = m->pos_;\n\t}\n\tassert(ret == cnt);\n\treturn ret;\n}", "target": 1}
{"code": "int jvp_number_cmp(jv a, jv b) {\n  assert(JVP_HAS_KIND(a, JV_KIND_NUMBER));\n  assert(JVP_HAS_KIND(b, JV_KIND_NUMBER));\n#ifdef USE_DECNUM\n  if (JVP_HAS_FLAGS(a, JVP_FLAGS_NUMBER_LITERAL) && JVP_HAS_FLAGS(b, JVP_FLAGS_NUMBER_LITERAL)) {\n    decNumber res;\n    decNumberCompare(&res,\n                     jvp_dec_number_ptr(a),\n                     jvp_dec_number_ptr(b),\n                     DEC_CONTEXT()\n                     );\n    if (decNumberIsZero(&res)) {\n      return 0;\n    } else if (decNumberIsNegative(&res)) {\n      return -1;\n    } else {\n      return 1;\n    }\n  }\n#endif\n  double da = jv_number_value(a), db = jv_number_value(b);\n  if (da < db) {\n    return -1;\n  } else if (da == db) {\n    return 0;\n  } else {\n    return 1;\n  }\n}", "target": 1}
{"code": "static int setup_dev_console(const struct lxc_rootfs *rootfs,\n\t\t\t const struct lxc_console *console)\n{\n\tchar path[MAXPATHLEN];\n\tstruct stat s;\n\tint ret;\n\tret = snprintf(path, sizeof(path), \"%s/dev/console\", rootfs->mount);\n\tif (ret >= sizeof(path)) {\n\t\tERROR(\"console path too long\");\n\t\treturn -1;\n\t}\n\tif (access(path, F_OK)) {\n\t\tWARN(\"rootfs specified but no console found at '%s'\", path);\n\t\treturn 0;\n\t}\n\tif (console->master < 0) {\n\t\tINFO(\"no console\");\n\t\treturn 0;\n\t}\n\tif (stat(path, &s)) {\n\t\tSYSERROR(\"failed to stat '%s'\", path);\n\t\treturn -1;\n\t}\n\tif (chmod(console->name, s.st_mode)) {\n\t\tSYSERROR(\"failed to set mode '0%o' to '%s'\",\n\t\t\t s.st_mode, console->name);\n\t\treturn -1;\n\t}\n\tif (mount(console->name, path, \"none\", MS_BIND, 0)) {\n\t\tERROR(\"failed to mount '%s' on '%s'\", console->name, path);\n\t\treturn -1;\n\t}\n\tINFO(\"console has been setup\");\n\treturn 0;\n}", "target": 1}
{"code": "OJPEGDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)\n{\n        static const char module[]=\"OJPEGDecode\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\t(void)s;\n        if( !sp->decoder_ok )\n        {\n            TIFFErrorExt(tif->tif_clientdata,module,\"Cannot decode: decoder not correctly initialized\");\n            return 0;\n        }\n\tif (sp->libjpeg_jpeg_query_style==0)\n\t{\n\t\tif (OJPEGDecodeRaw(tif,buf,cc)==0)\n\t\t\treturn(0);\n\t}\n\telse\n\t{\n\t\tif (OJPEGDecodeScanlines(tif,buf,cc)==0)\n\t\t\treturn(0);\n\t}\n\treturn(1);\n}", "target": 0}
{"code": "ecma_op_function_call_native_built_in (ecma_object_t *func_obj_p, \n                                       ecma_value_t this_arg_value, \n                                       const ecma_value_t *arguments_list_p, \n                                       uint32_t arguments_list_len) \n{\n  JERRY_ASSERT (ecma_get_object_type (func_obj_p) == ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION);\n  ECMA_CHECK_STACK_USAGE ();\n#if JERRY_BUILTIN_REALMS\n  ecma_global_object_t *saved_global_object_p = JERRY_CONTEXT (global_object_p);\n  ecma_extended_object_t *ext_func_obj_p = (ecma_extended_object_t *) func_obj_p;\n  JERRY_CONTEXT (global_object_p) =\n    ECMA_GET_INTERNAL_VALUE_POINTER (ecma_global_object_t, ext_func_obj_p->u.built_in.realm_value);\n#endif \n  ecma_value_t ret_value =\n    ecma_builtin_dispatch_call (func_obj_p, this_arg_value, arguments_list_p, arguments_list_len);\n#if JERRY_BUILTIN_REALMS\n  JERRY_CONTEXT (global_object_p) = saved_global_object_p;\n#endif \n  return ret_value;\n} ", "target": 0}
{"code": "static void *__ns_get_path(struct path *path, struct ns_common *ns)\n{\n\tstruct vfsmount *mnt = nsfs_mnt;\n\tstruct qstr qname = { .name = \"\", };\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tunsigned long d;\n\trcu_read_lock();\n\td = atomic_long_read(&ns->stashed);\n\tif (!d)\n\t\tgoto slow;\n\tdentry = (struct dentry *)d;\n\tif (!lockref_get_not_dead(&dentry->d_lockref))\n\t\tgoto slow;\n\trcu_read_unlock();\n\tns->ops->put(ns);\ngot_it:\n\tpath->mnt = mntget(mnt);\n\tpath->dentry = dentry;\n\treturn NULL;\nslow:\n\trcu_read_unlock();\n\tinode = new_inode_pseudo(mnt->mnt_sb);\n\tif (!inode) {\n\t\tns->ops->put(ns);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tinode->i_ino = ns->inum;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);\n\tinode->i_flags |= S_IMMUTABLE;\n\tinode->i_mode = S_IFREG | S_IRUGO;\n\tinode->i_fop = &ns_file_operations;\n\tinode->i_private = ns;\n\tdentry = d_alloc_pseudo(mnt->mnt_sb, &qname);\n\tif (!dentry) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\td_instantiate(dentry, inode);\n\tdentry->d_flags |= DCACHE_RCUACCESS;\n\tdentry->d_fsdata = (void *)ns->ops;\n\td = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);\n\tif (d) {\n\t\td_delete(dentry);\t\n\t\tdput(dentry);\n\t\tcpu_relax();\n\t\treturn ERR_PTR(-EAGAIN);\n\t}\n\tgoto got_it;\n}", "target": 0}
{"code": "double AccessibilityUIElement::maxValue()\n{\n    if (!m_element || !ATK_IS_OBJECT(m_element))\n        return 0.0f;\n    GValue value = G_VALUE_INIT;\n    atk_value_get_maximum_value(ATK_VALUE(m_element), &value);\n    if (!G_VALUE_HOLDS_FLOAT(&value))\n        return 0.0f;\n    return g_value_get_float(&value);\n}", "target": 0}
{"code": "void slice_segment_header::set_defaults()\n{\n  slice_index = 0;\n  first_slice_segment_in_pic_flag = 1;\n  no_output_of_prior_pics_flag = 0;\n  slice_pic_parameter_set_id = 0;\n  dependent_slice_segment_flag = 0;\n  slice_segment_address = 0;\n  slice_type = SLICE_TYPE_I;\n  pic_output_flag = 1;\n  colour_plane_id = 0;\n  slice_pic_order_cnt_lsb = 0;\n  short_term_ref_pic_set_sps_flag = 1;\n  short_term_ref_pic_set_idx = 0;\n  num_long_term_sps = 0;\n  num_long_term_pics = 0;\n  slice_temporal_mvp_enabled_flag = 0;\n  slice_sao_luma_flag = 0;\n  slice_sao_chroma_flag = 0;\n  num_ref_idx_active_override_flag = 0;\n  num_ref_idx_l0_active=1; \n  num_ref_idx_l1_active=1; \n  ref_pic_list_modification_flag_l0 = 0;\n  ref_pic_list_modification_flag_l1 = 0;\n  mvd_l1_zero_flag = 0;\n  cabac_init_flag = 0;\n  collocated_from_l0_flag = 0;\n  collocated_ref_idx = 0;\n  luma_log2_weight_denom=0; \n  ChromaLog2WeightDenom=0;  \n  five_minus_max_num_merge_cand = 0;\n  slice_qp_delta = 0;\n  slice_cb_qp_offset = 0;\n  slice_cr_qp_offset = 0;\n  cu_chroma_qp_offset_enabled_flag = 0;\n  deblocking_filter_override_flag = 0;\n  slice_deblocking_filter_disabled_flag = 0;\n  slice_beta_offset=0; \n  slice_tc_offset=0;   \n  slice_loop_filter_across_slices_enabled_flag = 0;\n  num_entry_point_offsets = 0;\n  slice_segment_header_extension_length = 0;\n  SliceAddrRS = slice_segment_address;\n}", "target": 0}
{"code": "TEST_IMPL(utf8_decode1_overrun) {\n  const char* p;\n  char b[1];\n  char c[1];\n  p = b;\n  b[0] = 0x7F;\n  ASSERT_EQ(0x7F, uv__utf8_decode1(&p, b + 1));\n  ASSERT_PTR_EQ(p, b + 1);\n  p = b;\n  b[0] = 0xC0;\n  ASSERT_EQ((unsigned) -1, uv__utf8_decode1(&p, b + 1));\n  ASSERT_PTR_EQ(p, b + 1);\n  b[0] = 0x7F;\n  ASSERT_EQ(UV_EINVAL, uv__idna_toascii(b, b + 1, c, c + 1));\n  return 0;\n}", "target": 0}
{"code": "void QuantizeMultiplier(double double_multiplier, int32_t* quantized_multiplier,\n                        int* left_shift) {\n  if (double_multiplier < 1.0) {\n    QuantizeMultiplierSmallerThanOneExp(double_multiplier, quantized_multiplier,\n                                        left_shift);\n  } else {\n    QuantizeMultiplierGreaterThanOne(double_multiplier, quantized_multiplier,\n                                     left_shift);\n  }\n}", "target": 0}
{"code": "SSLNetVConnection::populate_protocol(std::string_view *results, int n) const\n{\n  int retval = 0;\n  if (n > retval) {\n    results[retval] = map_tls_protocol_to_tag(getSSLProtocol());\n    if (!results[retval].empty()) {\n      ++retval;\n    }\n    if (n > retval) {\n      retval += super::populate_protocol(results + retval, n - retval);\n    }\n  }\n  return retval;\n}", "target": 0}
{"code": "CompositeDeepScanLine::setFrameBuffer(const FrameBuffer& fr)\n{\n    _Data->_channels.resize(3);\n    _Data->_channels[0]=\"Z\";\n    _Data->_channels[1]=_Data->_zback ? \"ZBack\" : \"Z\";\n    _Data->_channels[2]=\"A\";\n    _Data->_bufferMap.resize(0);\n    for(FrameBuffer::ConstIterator q=fr.begin();q!=fr.end();q++)\n    {\n        if(q.slice().xSampling!=1 || q.slice().ySampling!=1)\n        {\n             THROW (IEX_NAMESPACE::ArgExc, \"X and/or y subsampling factors \"\n\t\t\t\t\"of \\\"\" << q.name() << \"\\\" channel in framebuffer \"\n\t\t\t\t\"are not 1\");\n        }\n        string name(q.name());\n        if(name==\"ZBack\")\n        {\n            _Data->_bufferMap.push_back(1);\n        }else if(name==\"Z\")\n        {\n            _Data->_bufferMap.push_back(0);\n        }else if(name==\"A\")\n        {\n            _Data->_bufferMap.push_back(2);\n        }else{\n            _Data->_bufferMap.push_back(static_cast<int>(_Data->_channels.size()));\n            _Data->_channels.push_back(name);\n        }\n    }\n  _Data->_outputFrameBuffer=fr;\n}", "target": 0}
{"code": "ImmutableConstantOp::ImmutableConstantOp(OpKernelConstruction* context)\n    : OpKernel(context) {\n  OP_REQUIRES_OK(context,\n                 context->GetAttr(kMemoryRegionNameAttr, &region_name_));\n  OP_REQUIRES_OK(context, context->GetAttr(kDTypeAttr, &dtype_));\n  OP_REQUIRES(context, dtype_ != DT_RESOURCE && dtype_ != DT_VARIANT,\n              errors::InvalidArgument(\n                  \"Resource and variant dtypes are invalid for this op.\"));\n  OP_REQUIRES_OK(context, context->GetAttr(kShapeAttr, &shape_));\n}", "target": 0}
{"code": "static void Rp_test(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tint opts;\n\tResub m;\n\tre = js_toregexp(J, 0);\n\ttext = js_tostring(J, 1);\n\topts = 0;\n\tif (re->flags & JS_REGEXP_G) {\n\t\tif (re->last > strlen(text)) {\n\t\t\tre->last = 0;\n\t\t\tjs_pushboolean(J, 0);\n\t\t\treturn;\n\t\t}\n\t\tif (re->last > 0) {\n\t\t\ttext += re->last;\n\t\t\topts |= REG_NOTBOL;\n\t\t}\n\t}\n\tif (!js_regexec(re->prog, text, &m, opts)) {\n\t\tif (re->flags & JS_REGEXP_G)\n\t\t\tre->last = re->last + (m.sub[0].ep - text);\n\t\tjs_pushboolean(J, 1);\n\t\treturn;\n\t}\n\tif (re->flags & JS_REGEXP_G)\n\t\tre->last = 0;\n\tjs_pushboolean(J, 0);\n}", "target": 1}
{"code": "usm_clone(netsnmp_pdu *pdu, netsnmp_pdu *new_pdu)\n{\n    struct usmStateReference *ref = pdu->securityStateRef;\n    struct usmStateReference **new_ref =\n        (struct usmStateReference **)&new_pdu->securityStateRef;\n    int ret = 0;\n    if (!ref)\n        return ret;\n    if (pdu->command == SNMP_MSG_TRAP2) {\n        netsnmp_assert(pdu->securityModel == SNMP_DEFAULT_SECMODEL);\n        ret = usm_clone_usmStateReference(ref, new_ref);\n    } else {\n        netsnmp_assert(ref == *new_ref);\n        ref->refcnt++;\n    }\n    return ret;\n}", "target": 0}
{"code": "DWORD OmniboxViewWin::EditDropTarget::OnDragOver(IDataObject* data_object,\n                                                 DWORD key_state,\n                                                 POINT cursor_position,\n                                                 DWORD effect) {\n  if (drag_has_url_)\n    return CopyOrLinkDropEffect(effect);\n  if (drag_has_string_) {\n    UpdateDropHighlightPosition(cursor_position);\n    if (edit_->drop_highlight_position() == -1 && edit_->in_drag())\n      return DROPEFFECT_NONE;\n    if (edit_->in_drag()) {\n      DCHECK((effect & DROPEFFECT_COPY) && (effect & DROPEFFECT_MOVE));\n      return (key_state & MK_CONTROL) ? DROPEFFECT_COPY : DROPEFFECT_MOVE;\n    }\n    return CopyOrLinkDropEffect(effect);\n  }\n  return DROPEFFECT_NONE;\n}", "target": 0}
{"code": "static NETWORK_INTERFACE_DESCRIPTION* create_network_interface_description(struct ifreq *ifr, NETWORK_INTERFACE_DESCRIPTION* previous_nid)\n{\n    NETWORK_INTERFACE_DESCRIPTION* result;\n    if ((result = (NETWORK_INTERFACE_DESCRIPTION*)malloc(sizeof(NETWORK_INTERFACE_DESCRIPTION))) == NULL)\n    {\n        LogError(\"Failed allocating NETWORK_INTERFACE_DESCRIPTION\");\n    }\n    else if ((result->name = (char*)malloc(sizeof(char) * (strlen(ifr->ifr_name) + 1))) == NULL)\n    {\n        LogError(\"failed setting interface description name (malloc failed)\");\n        destroy_network_interface_descriptions(result);\n        result = NULL;\n    }\n    else\n    {\n        strcpy(result->name, ifr->ifr_name);\n        char* ip_address;\n        unsigned char* mac = (unsigned char*)ifr->ifr_hwaddr.sa_data;\n        if ((result->mac_address = (char*)malloc(sizeof(char) * MAC_ADDRESS_STRING_LENGTH)) == NULL)\n        {\n            LogError(\"failed formatting mac address (malloc failed)\");\n            destroy_network_interface_descriptions(result);\n            result = NULL;\n        }\n        else if (sprintf(result->mac_address, \"%02X:%02X:%02X:%02X:%02X:%02X\", mac[0],mac[1],mac[2],mac[3],mac[4],mac[5]) <= 0)\n        {\n            LogError(\"failed formatting mac address (sprintf failed)\");\n            destroy_network_interface_descriptions(result);\n            result = NULL;\n        }\n        else if ((ip_address = inet_ntoa(((struct sockaddr_in*)&ifr->ifr_addr)->sin_addr)) == NULL)\n        {\n            LogError(\"failed setting the ip address (inet_ntoa failed)\");\n            destroy_network_interface_descriptions(result);\n            result = NULL;\n        }\n        else if ((result->ip_address = (char*)malloc(sizeof(char) * (strlen(ip_address) + 1))) == NULL)\n        {\n            LogError(\"failed setting the ip address (malloc failed)\");\n            destroy_network_interface_descriptions(result);\n            result = NULL;\n        }\n        else\n        {\n            strcpy(result->ip_address, ip_address);\n            result->next = NULL;\n            if (previous_nid != NULL)\n            {\n                previous_nid->next = result;\n            }\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "static void vvc_parse_general_timing_hrd_parameters(GF_BitStream *bs, VVC_SPS *sps, VVC_VPS *vps, Bool *general_nal_hrd_params_present_flag, Bool *general_vcl_hrd_params_present_flag, Bool *general_du_hrd_params_present_flag, u32 *hrd_cpb_cnt_minus1)\n{\n\tsps->has_timing_info = 1;\n\tsps->num_units_in_tick = gf_bs_read_int_log(bs, 32, \"num_units_in_tick\");\n\tsps->time_scale = gf_bs_read_int_log(bs, 32, \"timescale\");\n\t*general_du_hrd_params_present_flag = GF_FALSE;\n\t*general_nal_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \"general_nal_hrd_params_present_flag\");\n\t*general_vcl_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \"general_vcl_hrd_params_present_flag\");\n\tif (*general_nal_hrd_params_present_flag || *general_vcl_hrd_params_present_flag) {\n\t\tgf_bs_read_int_log(bs, 1, \"general_same_pic_timing_in_all_ols_flag\");\n\t\t*general_du_hrd_params_present_flag = gf_bs_read_int_log(bs, 1, \"general_du_hrd_params_present_flag\");\n\t\tif (*general_du_hrd_params_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 8, \"tick_divisor_minus2\");\n\t\tgf_bs_read_int_log(bs, 4, \"bit_rate_scale\");\n\t\tgf_bs_read_int_log(bs, 4, \"cpb_size_scale\");\n\t\tif (*general_du_hrd_params_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 4, \"cpb_size_du_scale\");\n\t\t*hrd_cpb_cnt_minus1 = gf_bs_read_ue_log(bs, \"hrd_cpb_cnt_minus1\");\n\t}\n}", "target": 0}
{"code": "char *M_fs_path_tmpdir(M_fs_system_t sys_type)\n{\n\tchar         *d   = NULL;\n\tchar         *out = NULL;\n\tM_fs_error_t  res;\n#ifdef _WIN32\n\tsize_t len = M_fs_path_get_path_max(M_FS_SYSTEM_WINDOWS)+1;\n\td = M_malloc_zero(len);\n\tif (GetTempPath((DWORD)len, d) >= len) {\n\t\tM_free(d);\n\t\td = NULL;\n\t}\n#elif defined(__APPLE__)\n\td = M_fs_path_mac_tmpdir();\n#else\n\tconst char *const_temp;\n#  ifdef HAVE_SECURE_GETENV\n\tconst_temp = secure_getenv(\"TMPDIR\");\n#  else\n\tconst_temp = getenv(\"TMPDIR\");\n#  endif\n\tif (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {\n\t\td = M_strdup(const_temp);\n\t}\n\tif (d == NULL) {\n\t\tconst_temp = \"/tmp\";\n\t\tif (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {\n\t\t\td = M_strdup(const_temp);\n\t\t}\n\t}\n\tif (d == NULL) {\n\t\tconst_temp = \"/var/tmp\";\n\t\tif (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {\n\t\t\td = M_strdup(const_temp);\n\t\t}\n\t}\n#endif\n\tif (d != NULL) {\n\t\tres = M_fs_path_norm(&out, d, M_FS_PATH_NORM_ABSOLUTE, sys_type);\n\t\tif (res != M_FS_ERROR_SUCCESS) {\n\t\t\tout = NULL;\n\t\t}\n\t}\n\tM_free(d);\n\treturn out;\n}", "target": 1}
{"code": "static netdev_tx_t veth_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct net_device *rcv = NULL;\n\tstruct veth_priv *priv, *rcv_priv;\n\tstruct veth_net_stats *stats, *rcv_stats;\n\tint length;\n\tpriv = netdev_priv(dev);\n\trcv = priv->peer;\n\trcv_priv = netdev_priv(rcv);\n\tstats = this_cpu_ptr(priv->stats);\n\trcv_stats = this_cpu_ptr(rcv_priv->stats);\n\tif (!(rcv->flags & IFF_UP))\n\t\tgoto tx_drop;\n\tif (dev->features & NETIF_F_NO_CSUM)\n\t\tskb->ip_summed = rcv_priv->ip_summed;\n\tlength = skb->len + ETH_HLEN;\n\tif (dev_forward_skb(rcv, skb) != NET_RX_SUCCESS)\n\t\tgoto rx_drop;\n\tstats->tx_bytes += length;\n\tstats->tx_packets++;\n\trcv_stats->rx_bytes += length;\n\trcv_stats->rx_packets++;\n\treturn NETDEV_TX_OK;\ntx_drop:\n\tkfree_skb(skb);\n\tstats->tx_dropped++;\n\treturn NETDEV_TX_OK;\nrx_drop:\n\tkfree_skb(skb);\n\trcv_stats->rx_dropped++;\n\treturn NETDEV_TX_OK;\n}", "target": 1}
{"code": "void cliprdr_free_format_list(CLIPRDR_FORMAT_LIST* formatList)\n{\n\tUINT index = 0;\n\tif (formatList == NULL)\n\t\treturn;\n\tif (formatList->formats)\n\t{\n\t\tfor (index = 0; index < formatList->numFormats; index++)\n\t\t{\n\t\t\tfree(formatList->formats[index].formatName);\n\t\t}\n\t\tfree(formatList->formats);\n\t\tformatList->formats = NULL;\n\t\tformatList->numFormats = 0;\n\t}\n}", "target": 0}
{"code": "mmsClient_handleFileOpenRequest(\n    MmsConnection connection,\n    uint8_t* buffer, int bufPos, int maxBufPos,\n    uint32_t invokeId, ByteBuffer* response)\n{\n    char filename[256];\n    bool hasFileName = false;\n    uint32_t filePosition = 0;\n    while (bufPos < maxBufPos) {\n        uint8_t tag = buffer[bufPos++];\n        int length;\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n        if (bufPos < 0) goto exit_reject_invalid_pdu;\n        switch(tag) {\n        case 0xa0: \n            if (!mmsMsg_parseFileName(filename, buffer, &bufPos, bufPos + length, invokeId, response))\n                return;\n            hasFileName = true;\n            break;\n        case 0x81: \n            filePosition = BerDecoder_decodeUint32(buffer, length, bufPos);\n            bufPos += length;\n            break;\n        case 0x00: \n            break;\n        default: \n            bufPos += length;\n            goto exit_reject_invalid_pdu;\n        }\n    }\n    if (hasFileName) {\n        MmsFileReadStateMachine* frsm = getFreeFrsm(connection);\n        if (frsm != NULL) {\n            MmsOutstandingCall obtainFileCall = mmsClient_getMatchingObtainFileRequest(connection, filename);\n            if (obtainFileCall) {\n                if (DEBUG_MMS_CLIENT)\n                    printf(\"MMS_CLIENT: file open is matching obtain file request for file %s\\n\", filename);\n                obtainFileCall->timeout = Hal_getTimeInMs() + connection->requestTimeout;\n            }\n            FileHandle fileHandle = mmsMsg_openFile(MmsConnection_getFilestoreBasepath(connection), filename, false);\n            if (fileHandle != NULL) {\n                frsm->fileHandle = fileHandle;\n                frsm->readPosition = filePosition;\n                frsm->frsmId = getNextFrsmId(connection);\n                frsm->obtainRequest = obtainFileCall;\n                mmsMsg_createFileOpenResponse(MmsConnection_getFilestoreBasepath(connection),\n                        invokeId, response, filename, frsm);\n            }\n            else\n                mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n        }\n        else\n            mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_RESOURCE_OTHER);\n    }\n    else\n        goto exit_invalid_parameter;\n    return;\nexit_invalid_parameter:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT, response);\n    return;\nexit_reject_invalid_pdu:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n}", "target": 1}
{"code": "static int encode_open_downgrade(struct xdr_stream *xdr, const struct nfs_closeargs *arg)\n{\n\t__be32 *p;\n\tRESERVE_SPACE(4+NFS4_STATEID_SIZE+4);\n\tWRITE32(OP_OPEN_DOWNGRADE);\n\tWRITEMEM(arg->stateid->data, NFS4_STATEID_SIZE);\n\tWRITE32(arg->seqid->sequence->counter);\n\tencode_share_access(xdr, arg->open_flags);\n\treturn 0;\n}", "target": 1}
{"code": "irc_nick_realloc_prefixes (struct t_irc_server *server,\n                           int old_length, int new_length)\n{\n    struct t_irc_channel *ptr_channel;\n    struct t_irc_nick *ptr_nick;\n    char *new_prefixes;\n    for (ptr_channel = server->channels; ptr_channel;\n         ptr_channel = ptr_channel->next_channel)\n    {\n        for (ptr_nick = ptr_channel->nicks; ptr_nick;\n             ptr_nick = ptr_nick->next_nick)\n        {\n            if (ptr_nick->prefixes)\n            {\n                new_prefixes = realloc (ptr_nick->prefixes, new_length + 1);\n                if (new_prefixes)\n                {\n                    ptr_nick->prefixes = new_prefixes;\n                    if (new_length > old_length)\n                    {\n                        memset (ptr_nick->prefixes + old_length,\n                                ' ',\n                                new_length - old_length);\n                    }\n                    ptr_nick->prefixes[new_length] = '\\0';\n                }\n            }\n            else\n            {\n                ptr_nick->prefixes = malloc (new_length + 1);\n                if (ptr_nick->prefixes)\n                {\n                    memset (ptr_nick->prefixes, ' ', new_length);\n                    ptr_nick->prefixes[new_length] = '\\0';\n                }\n            }\n        }\n    }\n}", "target": 0}
{"code": "static int io_files_update_with_index_alloc(struct io_kiocb *req,\n\t\t\t\t\t    unsigned int issue_flags)\n{\n\t__s32 __user *fds = u64_to_user_ptr(req->rsrc_update.arg);\n\tunsigned int done;\n\tstruct file *file;\n\tint ret, fd;\n\tif (!req->ctx->file_data)\n\t\treturn -ENXIO;\n\tfor (done = 0; done < req->rsrc_update.nr_args; done++) {\n\t\tif (copy_from_user(&fd, &fds[done], sizeof(fd))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tfile = fget(fd);\n\t\tif (!file) {\n\t\t\tret = -EBADF;\n\t\t\tbreak;\n\t\t}\n\t\tret = io_fixed_fd_install(req, issue_flags, file,\n\t\t\t\t\t  IORING_FILE_INDEX_ALLOC);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (copy_to_user(&fds[done], &ret, sizeof(ret))) {\n\t\t\t__io_close_fixed(req, issue_flags, ret);\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (done)\n\t\treturn done;\n\treturn ret;", "target": 0}
{"code": "static int handle_invvpid(struct kvm_vcpu *vcpu)\n{\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn 1;\n}", "target": 0}
{"code": "GetStartupData(HANDLE pipe, STARTUP_DATA *sud)\n{\n    size_t size, len;\n    BOOL ret = FALSE;\n    WCHAR *data = NULL;\n    DWORD bytes, read;\n    bytes = PeekNamedPipeAsync(pipe, 1, &exit_event);\n    if (bytes == 0)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"PeekNamedPipeAsync failed\"));\n        ReturnLastError(pipe, L\"PeekNamedPipeAsync\");\n        goto out;\n    }\n    size = bytes / sizeof(*data);\n    if (size == 0)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"malformed startup data: 1 byte received\"));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n    }\n    data = malloc(bytes);\n    if (data == NULL)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"malloc failed\"));\n        ReturnLastError(pipe, L\"malloc\");\n        goto out;\n    }\n    read = ReadPipeAsync(pipe, data, bytes, 1, &exit_event);\n    if (bytes != read)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"ReadPipeAsync failed\"));\n        ReturnLastError(pipe, L\"ReadPipeAsync\");\n        goto out;\n    }\n    if (data[size - 1] != 0)\n    {\n        MsgToEventLog(M_ERR, TEXT(\"Startup data is not NULL terminated\"));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n    }\n    sud->directory = data;\n    len = wcslen(sud->directory) + 1;\n    size -= len;\n    if (size <= 0)\n    {\n        MsgToEventLog(M_ERR, TEXT(\"Startup data ends at working directory\"));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n    }\n    sud->options = sud->directory + len;\n    len = wcslen(sud->options) + 1;\n    size -= len;\n    if (size <= 0)\n    {\n        MsgToEventLog(M_ERR, TEXT(\"Startup data ends at command line options\"));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n    }\n    sud->std_input = sud->options + len;\n    data = NULL; \n    ret = TRUE;\nout:\n    free(data);\n    return ret;\n}", "target": 1}
{"code": "sixel_allocator_malloc(\n    sixel_allocator_t    *allocator,  \n    size_t               n)           \n{\n    assert(allocator);\n    assert(allocator->fn_malloc);\n    if (n == 0) {\n        sixel_helper_set_additional_message(\n            \"sixel_allocator_malloc: called with n == 0\");\n        return NULL;\n    }\n    if (n > SIXEL_ALLOCATE_BYTES_MAX) {\n        return NULL;\n    }\n    return allocator->fn_malloc(n);\n}", "target": 0}
{"code": "void receive_tcppacket(connection_t *c, const char *buffer, int len) {\n\tvpn_packet_t outpkt;\n\tif(len > sizeof outpkt.data)\n\t\treturn;\n\toutpkt.len = len;\n\tif(c->options & OPTION_TCPONLY)\n\t\toutpkt.priority = 0;\n\telse\n\t\toutpkt.priority = -1;\n\tmemcpy(outpkt.data, buffer, len);\n\treceive_packet(c->node, &outpkt);\n}", "target": 0}
{"code": "void SFS_ObjectMemberAccess(ScriptParser *parser)\n{\n\tif (parser->codec->LastError) return;\n\tSFS_Expression(parser);\n\tif (parser->codec->LastError) return;\n\tSFS_AddString(parser, \".\");\n\tSFS_Identifier(parser);\n}", "target": 0}
{"code": "static char *r_socket_http_answer (RSocket *s, int *code, int *rlen) {\n\tr_return_val_if_fail (s, NULL);\n\tconst char *p;\n\tint ret, len = 0, bufsz = 32768, delta = 0;\n\tchar *dn, *buf = calloc (1, bufsz + 32); \n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\tchar *res = NULL;\n\tint olen = __socket_slurp (s, (ut8*)buf, bufsz);\n\tif ((dn = (char*)r_str_casestr (buf, \"\\n\\n\"))) {\n\t\tdelta += 2;\n\t} else if ((dn = (char*)r_str_casestr (buf, \"\\r\\n\\r\\n\"))) {\n\t\tdelta += 4;\n\t} else {\n\t\tgoto fail;\n\t}\n\tolen -= delta;\n\t*dn = 0; \n\tp = r_str_casestr (buf, \"Content-Length: \");\n\tif (p) {\n\t\tlen = atoi (p + 16);\n\t} else {\n\t\tlen = olen - (dn - buf);\n\t}\n\tif (len > 0) {\n\t\tif (len > olen) {\n\t\t\tres = malloc (len + 2);\n\t\t\tmemcpy (res, dn + delta, olen);\n\t\t\tdo {\n\t\t\t\tret = r_socket_read_block (s, (ut8*) res + olen, len - olen);\n\t\t\t\tif (ret < 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tolen += ret;\n\t\t\t} while (olen < len);\n\t\t\tres[len] = 0;\n\t\t} else {\n\t\t\tres = malloc (len + 1);\n\t\t\tif (res) {\n\t\t\t\tmemcpy (res, dn + delta, len);\n\t\t\t\tres[len] = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tres = NULL;\n\t}\nfail:\n\tfree (buf);\n\tr_socket_close (s);\n\tif (rlen) {\n\t\t*rlen = len;\n\t}\n\treturn res;\n}", "target": 1}
{"code": "static void domain_remove_dev_info(struct dmar_domain *domain)\n{\n\tstruct device_domain_info *info, *tmp;\n\tunsigned long flags;\n\tspin_lock_irqsave(&device_domain_lock, flags);\n\tlist_for_each_entry_safe(info, tmp, &domain->devices, link)\n\t\t__dmar_remove_one_dev_info(info);\n\tspin_unlock_irqrestore(&device_domain_lock, flags);\n}", "target": 0}
{"code": "static inline int GetFirstGlobbingEntry(const std::vector<std::string>& dirs) {\n  int i = 0;\n  for (const auto& d : dirs) {\n    if (IsGlobbingPattern(d)) {\n      break;\n    }\n    i++;\n  }\n  return i;\n}", "target": 0}
{"code": "static uint32_t dp8393x_crda(dp8393xState *s)\n{\n    return (s->regs[SONIC_URDA] << 16) |\n           (s->regs[SONIC_CRDA] & SONIC_DESC_ADDR);\n}", "target": 0}
{"code": "static int mwifiex_pcie_alloc_cmdrsp_buf(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct sk_buff *skb;\n\tskb = dev_alloc_skb(MWIFIEX_UPLD_SIZE);\n\tif (!skb) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Unable to allocate skb for command response data.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, MWIFIEX_UPLD_SIZE);\n\tif (mwifiex_map_pci_memory(adapter, skb, MWIFIEX_UPLD_SIZE,\n\t\t\t\t   PCI_DMA_FROMDEVICE))\n\t\treturn -1;\n\tcard->cmdrsp_buf = skb;\n\treturn 0;\n}", "target": 1}
{"code": "long keyctl_set_reqkey_keyring(int reqkey_defl)\n{\n\tstruct cred *new;\n\tint ret, old_setting;\n\told_setting = current_cred_xxx(jit_keyring);\n\tif (reqkey_defl == KEY_REQKEY_DEFL_NO_CHANGE)\n\t\treturn old_setting;\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tswitch (reqkey_defl) {\n\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\tret = install_thread_keyring_to_cred(new);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tgoto set;\n\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\tret = install_process_keyring_to_cred(new);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -EEXIST)\n\t\t\t\tgoto error;\n\t\t\tret = 0;\n\t\t}\n\t\tgoto set;\n\tcase KEY_REQKEY_DEFL_DEFAULT:\n\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\tgoto set;\n\tcase KEY_REQKEY_DEFL_NO_CHANGE:\n\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\nset:\n\tnew->jit_keyring = reqkey_defl;\n\tcommit_creds(new);\n\treturn old_setting;\nerror:\n\tabort_creds(new);\n\treturn ret;\n}", "target": 1}
{"code": "  void readErr(const AsyncSocketException&) noexcept override {}", "target": 0}
{"code": "gx_default_get_alpha_bits(gx_device * dev, graphics_object_type type)\n{\n    return (type == go_text ? dev->color_info.anti_alias.text_bits :\n            dev->color_info.anti_alias.graphics_bits);\n}", "target": 0}
{"code": "dn2ancestor(\n    Slapi_Backend *be,\n    const Slapi_DN\t*sdn,\n\tSlapi_DN *ancestordn,\n    back_txn\t\t*txn,\n    int\t\t\t*err\n)\n{\n\tstruct backentry *e = NULL;\n\tLDAPDebug( LDAP_DEBUG_TRACE, \"=> dn2ancestor \\\"%s\\\"\\n\", slapi_sdn_get_dn(sdn), 0, 0 );\n    if (!slapi_sdn_isempty(sdn) && !slapi_be_issuffix( be, sdn )) {\n        Slapi_DN ancestorndn;\n        const char *ptr;\n        ptr = slapi_dn_find_parent(slapi_sdn_get_dn(sdn));\n        slapi_sdn_set_normdn_byref(ancestordn, ptr); \n        ptr = slapi_dn_find_parent(slapi_sdn_get_ndn(sdn));\n        slapi_sdn_init_ndn_byref(&ancestorndn, ptr);\n        while (!e && !slapi_sdn_isempty(&ancestorndn) && !slapi_be_issuffix( be, &ancestorndn )) {\n            e= dn2entry(be,&ancestorndn,txn,err);\n            if (!e) {\n                ptr = slapi_dn_find_parent(slapi_sdn_get_ndn(&ancestorndn));\n                slapi_sdn_set_ndn_byref(&ancestorndn, ptr); \n                ptr = slapi_dn_find_parent(slapi_sdn_get_dn(ancestordn));\n                slapi_sdn_set_normdn_byref(ancestordn, ptr); \n            }\n        }\n        slapi_sdn_done(&ancestorndn);\n    }\n    LDAPDebug( LDAP_DEBUG_TRACE, \"<= dn2ancestor %p\\n\", e, 0, 0 );\n    return( e );\n}", "target": 1}
{"code": "static void configureIOD(EctEnhancedCT *ct)\n{\n    if (!ct)\n        return;\n}", "target": 0}
{"code": "rdpCredssp* credssp_new(freerdp* instance, rdpTransport* transport, rdpSettings* settings)\n{\n\trdpCredssp* credssp;\n\tcredssp = (rdpCredssp*) malloc(sizeof(rdpCredssp));\n\tZeroMemory(credssp, sizeof(rdpCredssp));\n\tif (credssp != NULL)\n\t{\n\t\tHKEY hKey;\n\t\tLONG status;\n\t\tDWORD dwType;\n\t\tDWORD dwSize;\n\t\tcredssp->instance = instance;\n\t\tcredssp->settings = settings;\n\t\tcredssp->server = settings->ServerMode;\n\t\tcredssp->transport = transport;\n\t\tcredssp->send_seq_num = 0;\n\t\tcredssp->recv_seq_num = 0;\n\t\tZeroMemory(&credssp->negoToken, sizeof(SecBuffer));\n\t\tZeroMemory(&credssp->pubKeyAuth, sizeof(SecBuffer));\n\t\tZeroMemory(&credssp->authInfo, sizeof(SecBuffer));\n\t\tSecInvalidateHandle(&credssp->context);\n\t\tif (credssp->server)\n\t\t{\n\t\t\tstatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T(\"Software\\\\FreeRDP\\\\Server\"),\n\t\t\t\t\t0, KEY_READ | KEY_WOW64_64KEY, &hKey);\n\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t{\n\t\t\t\tstatus = RegQueryValueEx(hKey, _T(\"SspiModule\"), NULL, &dwType, NULL, &dwSize);\n\t\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t\t{\n\t\t\t\t\tcredssp->SspiModule = (LPTSTR) malloc(dwSize + sizeof(TCHAR));\n\t\t\t\t\tstatus = RegQueryValueEx(hKey, _T(\"SspiModule\"), NULL, &dwType,\n\t\t\t\t\t\t\t(BYTE*) credssp->SspiModule, &dwSize);\n\t\t\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t\t\t{\n\t\t\t\t\t\t_tprintf(_T(\"Using SSPI Module: %s\\n\"), credssp->SspiModule);\n\t\t\t\t\t\tRegCloseKey(hKey);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn credssp;\n}", "target": 0}
{"code": "    template<typename tp, typename tf, typename tc, typename to>\n    CImg<T>& draw_object3d(LibBoard::Board& board,\n                           const float x0, const float y0, const float z0,\n                           const CImg<tp>& vertices, const CImgList<tf>& primitives,\n                           const CImgList<tc>& colors, const CImgList<to>& opacities,\n                           const unsigned int render_type=4,\n                           const bool is_double_sided=false, const float focale=700,\n                           const float lightx=0, const float lighty=0, const float lightz=-5e8,\n                           const float specular_lightness=0.2f, const float specular_shininess=0.1f) {\n      return draw_object3d(board,x0,y0,z0,vertices,primitives,colors,opacities,render_type,\n                           is_double_sided,focale,lightx,lighty,lightz,\n                           specular_lightness,specular_shininess,CImg<floatT>::empty());", "target": 0}
{"code": "void set_fat(DOS_FS * fs, uint32_t cluster, int32_t new)\n{\n    unsigned char *data = NULL;\n    int size;\n    loff_t offs;\n    if (new == -1)\n\tnew = FAT_EOF(fs);\n    else if ((long)new == -2)\n\tnew = FAT_BAD(fs);\n    switch (fs->fat_bits) {\n    case 12:\n\tdata = fs->fat + cluster * 3 / 2;\n\toffs = fs->fat_start + cluster * 3 / 2;\n\tif (cluster & 1) {\n\t    FAT_ENTRY prevEntry;\n\t    get_fat(&prevEntry, fs->fat, cluster - 1, fs);\n\t    data[0] = ((new & 0xf) << 4) | (prevEntry.value >> 8);\n\t    data[1] = new >> 4;\n\t} else {\n\t    FAT_ENTRY subseqEntry;\n\t    if (cluster != fs->clusters - 1)\n\t\tget_fat(&subseqEntry, fs->fat, cluster + 1, fs);\n\t    else\n\t\tsubseqEntry.value = 0;\n\t    data[0] = new & 0xff;\n\t    data[1] = (new >> 8) | ((0xff & subseqEntry.value) << 4);\n\t}\n\tsize = 2;\n\tbreak;\n    case 16:\n\tdata = fs->fat + cluster * 2;\n\toffs = fs->fat_start + cluster * 2;\n\t*(unsigned short *)data = htole16(new);\n\tsize = 2;\n\tbreak;\n    case 32:\n\t{\n\t    FAT_ENTRY curEntry;\n\t    get_fat(&curEntry, fs->fat, cluster, fs);\n\t    data = fs->fat + cluster * 4;\n\t    offs = fs->fat_start + cluster * 4;\n\t    *(uint32_t *)data = htole32((new & 0xfffffff) |\n\t\t\t\t\t     (curEntry.reserved << 28));\n\t    size = 4;\n\t}\n\tbreak;\n    default:\n\tdie(\"Bad FAT entry size: %d bits.\", fs->fat_bits);\n    }\n    fs_write(offs, size, data);\n    if (fs->nfats > 1) {\n\tfs_write(offs + fs->fat_size, size, data);\n    }\n}", "target": 1}
{"code": "int read_escaped_char(\n    yyscan_t yyscanner,\n    uint8_t* escaped_char)\n{\n  char text[4] = {0, 0, 0, 0};\n  text[0] = '\\\\';\n  text[1] = RE_YY_INPUT(yyscanner);\n  if (text[1] == EOF)\n    return 0;\n  if (text[1] == 'x')\n  {\n    text[2] = RE_YY_INPUT(yyscanner);\n    if (text[2] == EOF)\n      return 0;\n    text[3] = RE_YY_INPUT(yyscanner);\n    if (text[3] == EOF)\n      return 0;\n  }\n  *escaped_char = escaped_char_value(text);\n  return 1;", "target": 1}
{"code": "SQLWCHAR* _single_string_alloc_and_expand( LPCSTR in )\n{\n    SQLWCHAR *chr;\n    int len = 0;\n    if ( !in )\n    {\n        return in;\n    }\n    while ( in[ len ] != 0 )\n    {\n        len ++;\n    }\n    chr = malloc( sizeof( SQLWCHAR ) * ( len + 1 ));\n    len = 0;\n    while ( in[ len ] != 0 )\n    {\n        chr[ len ] = in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = 0;\n    return chr;\n}", "target": 1}
{"code": "smbhash(unsigned char *out, const unsigned char *in, unsigned char *key)\n{\n\tint rc;\n\tunsigned char key2[8];\n\tstruct crypto_skcipher *tfm_des;\n\tstruct scatterlist sgin, sgout;\n\tstruct skcipher_request *req;\n\tstr_to_key(key, key2);\n\ttfm_des = crypto_alloc_skcipher(\"ecb(des)\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm_des)) {\n\t\trc = PTR_ERR(tfm_des);\n\t\tcifs_dbg(VFS, \"could not allocate des crypto API\\n\");\n\t\tgoto smbhash_err;\n\t}\n\treq = skcipher_request_alloc(tfm_des, GFP_KERNEL);\n\tif (!req) {\n\t\trc = -ENOMEM;\n\t\tcifs_dbg(VFS, \"could not allocate des crypto API\\n\");\n\t\tgoto smbhash_free_skcipher;\n\t}\n\tcrypto_skcipher_setkey(tfm_des, key2, 8);\n\tsg_init_one(&sgin, in, 8);\n\tsg_init_one(&sgout, out, 8);\n\tskcipher_request_set_callback(req, 0, NULL, NULL);\n\tskcipher_request_set_crypt(req, &sgin, &sgout, 8, NULL);\n\trc = crypto_skcipher_encrypt(req);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"could not encrypt crypt key rc: %d\\n\", rc);\n\tskcipher_request_free(req);\nsmbhash_free_skcipher:\n\tcrypto_free_skcipher(tfm_des);\nsmbhash_err:\n\treturn rc;\n}", "target": 1}
{"code": "R_API RBinJavaAnnotation *r_bin_java_annotation_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaAnnotation *annotation = NULL;\n\tRBinJavaElementValuePair *evps = NULL;\n\tut64 offset = 0;\n\tannotation = R_NEW0 (RBinJavaAnnotation);\n\tif (!annotation) {\n\t\treturn NULL;\n\t}\n\tannotation->type_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tannotation->num_element_value_pairs = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tannotation->element_value_pairs = r_list_newf (r_bin_java_element_pair_free);\n\tfor (i = 0; i < annotation->num_element_value_pairs; i++) {\n\t\tif (offset > sz) {\n\t\t\tbreak;\n\t\t}\n\t\tevps = r_bin_java_element_pair_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\tif (evps) {\n\t\t\toffset += evps->size;\n\t\t\tr_list_append (annotation->element_value_pairs, (void *) evps);\n\t\t}\n\t}\n\tannotation->size = offset;\n\treturn annotation;\n}", "target": 1}
{"code": "static int cp2112_gpio_get_all(struct gpio_chip *chip)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n\tint ret;\n\tspin_lock_irqsave(&dev->lock, flags);\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_GET, buf,\n\t\t\t\t CP2112_GPIO_GET_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_GET_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO values: %d\\n\", ret);\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tgoto exit;\n\t}\n\tret = buf[1];\nexit:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn ret;\n}", "target": 1}
{"code": "uint64_t HeaderMapImpl::byteSizeInternal() const {\n  uint64_t byte_size = 0;\n  for (const HeaderEntryImpl& header : headers_) {\n    byte_size += header.key().size();\n    byte_size += header.value().size();\n  }\n  return byte_size;\n}", "target": 0}
{"code": "_XimEncodeSavedStatusValue(\n    Xic\t\t\t  ic,\n    XIMResourceList\t  res,\n    XPointer\t\t  value)\n{\n    int\t\t\t  list_ret;\n    XFontStruct\t\t**struct_list;\n    char\t\t**name_list;\n    char\t\t *tmp;\n    int\t\t\t  len;\n    register int\t  i;\n    if (res->xrm_name == XrmStringToQuark(XNFontSet)) {\n\tif (!value)\n\t    return False;\n\tXfree(ic->private.proto.status_font);\n\tlist_ret = XFontsOfFontSet((XFontSet)value,\n\t\t\t\t\t\t&struct_list, &name_list);\n\tfor(i = 0, len = 0; i < list_ret; i++) {\n\t    len += (strlen(name_list[i]) + sizeof(char));\n\t}\n\tif(!(tmp = Xmalloc(len + 1))) {\n\t    ic->private.proto.status_font = NULL;\n\t    return False;\n\t}\n\ttmp[0] = '\\0';\n\tfor(i = 0; i < list_ret; i++) {\n\t    strcat(tmp, name_list[i]);\n\t    strcat(tmp, \",\");\n\t}\n\ttmp[len - 1] = 0;\n\tic->private.proto.status_font        = tmp;\n\tic->private.proto.status_font_length = len - 1;\n    }\n    return True;\n}", "target": 0}
{"code": "l2tp_result_code_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tND_PRINT((ndo, \"%u\", EXTRACT_16BITS(ptr))); ptr++;\t\n\tif (length > 2) {\t\t\t\t\n\t        ND_PRINT((ndo, \"/%u\", EXTRACT_16BITS(ptr))); ptr++;\n\t}\n\tif (length > 4) {\t\t\t\t\n\t\tND_PRINT((ndo, \" \"));\n\t\tprint_string(ndo, (const u_char *)ptr, length - 4);\n\t}\n}", "target": 1}
{"code": "MONGO_EXPORT bson_bool_t mongo_cmd_authenticate( mongo *conn, const char *db, const char *user, const char *pass ) {\n    bson from_db;\n    bson cmd;\n    const char *nonce;\n    int result;\n    mongo_md5_state_t st;\n    mongo_md5_byte_t digest[16];\n    char hex_digest[33];\n    if( mongo_simple_int_command( conn, db, \"getnonce\", 1, &from_db ) == MONGO_OK ) {\n        bson_iterator it;\n        bson_find( &it, &from_db, \"nonce\" );\n        nonce = bson_iterator_string( &it );\n    }\n    else {\n        return MONGO_ERROR;\n    }\n    mongo_pass_digest( user, pass, hex_digest );\n    mongo_md5_init( &st );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )nonce, strlen( nonce ) );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )user, strlen( user ) );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )hex_digest, 32 );\n    mongo_md5_finish( &st, digest );\n    digest2hex( digest, hex_digest );\n    bson_init( &cmd );\n    bson_append_int( &cmd, \"authenticate\", 1 );\n    bson_append_string( &cmd, \"user\", user );\n    bson_append_string( &cmd, \"nonce\", nonce );\n    bson_append_string( &cmd, \"key\", hex_digest );\n    bson_finish( &cmd );\n    bson_destroy( &from_db );\n    result = mongo_run_command( conn, db, &cmd, NULL );\n    bson_destroy( &cmd );\n    return result;\n}", "target": 1}
{"code": "void __scm_destroy(struct scm_cookie *scm)\n{\n\tstruct scm_fp_list *fpl = scm->fp;\n\tint i;\n\tif (fpl) {\n\t\tscm->fp = NULL;\n\t\tfor (i=fpl->count-1; i>=0; i--)\n\t\t\tfput(fpl->fp[i]);\n\t\tfree_uid(fpl->user);\n\t\tkfree(fpl);\n\t}\n}", "target": 0}
{"code": "  virtual void AddCellularDataPlanObserver(CellularDataPlanObserver* observer) {\n    if (!data_plan_observers_.HasObserver(observer))\n      data_plan_observers_.AddObserver(observer);\n  }", "target": 0}
{"code": "main(int argc, char* argv[])\n{\n    (void) argc;\n    (void) argv;\n    const struct CMUnitTest tests[] = {\n            cmocka_unit_test(test_layers),\n            cmocka_unit_test(test_tpm_format_0_version2_0_error),\n            cmocka_unit_test(test_tpm_format_0_version2_0_warn),\n            cmocka_unit_test(test_tpm2_format_0_unknown),\n            cmocka_unit_test(test_tpm_format_1_unk_handle),\n            cmocka_unit_test(test_tpm_format_1_unk_parameter),\n            cmocka_unit_test(test_tpm_format_1_unk_session),\n            cmocka_unit_test(test_tpm_format_1_5_handle),\n            cmocka_unit_test(test_tpm2_format_1_unknown),\n            cmocka_unit_test(test_tpm2_format_1_success),\n            cmocka_unit_test(test_custom_handler),\n            cmocka_unit_test(test_zero_length_name),\n            cmocka_unit_test(test_over_length_name),\n            cmocka_unit_test(test_null_name),\n            cmocka_unit_test(test_sys),\n            cmocka_unit_test(test_esys),\n            cmocka_unit_test(test_mu),\n            cmocka_unit_test(test_tcti),\n            cmocka_unit_test(test_info_fmt0),\n            cmocka_unit_test(test_info_fmt1_parameter),\n            cmocka_unit_test(test_info_fmt1_handle),\n            cmocka_unit_test(test_info_fmt1_session),\n            cmocka_unit_test(test_info_null),\n            cmocka_unit_test(test_info_str_fmt1),\n            cmocka_unit_test(test_info_str_fmt1_ff),\n            cmocka_unit_test(test_info_str_fmt0_err),\n            cmocka_unit_test(test_info_str_fmt0_warn),\n            cmocka_unit_test(test_info_str_fmt0_ff),\n            cmocka_unit_test(test_info_str_null),\n            cmocka_unit_test(test_all_FFs),\n            cmocka_unit_test(test_all_FFs_set_handler)\n    };\n    return cmocka_run_group_tests(tests, NULL, NULL);\n}", "target": 0}
{"code": "void jp2_box_dump(jp2_box_t *box, FILE *out)\n{\n\tjp2_boxinfo_t *boxinfo;\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tassert(boxinfo);\n\tfprintf(out, \"JP2 box: \");\n\tfprintf(out, \"type=%c%s%c (0x%08\"PRIxFAST32\"); length=%\"PRIuFAST32\"\\n\", '\"', boxinfo->name,\n\t  '\"', box->type, box->len);\n\tif (box->ops->dumpdata) {\n\t\t(*box->ops->dumpdata)(box, out);\n\t}\n}", "target": 1}
{"code": "sort_keyuse(KEYUSE *a,KEYUSE *b)\n{\n  int res;\n  if (a->table->tablenr != b->table->tablenr)\n    return (int) (a->table->tablenr - b->table->tablenr);\n  if (a->key != b->key)\n    return (int) (a->key - b->key);\n  if (a->key == MAX_KEY && b->key == MAX_KEY && \n      a->used_tables != b->used_tables)\n    return (int) ((ulong) a->used_tables - (ulong) b->used_tables);\n  if (a->keypart != b->keypart)\n    return (int) (a->keypart - b->keypart);\n  if ((res= MY_TEST((a->used_tables & ~OUTER_REF_TABLE_BIT)) -\n       MY_TEST((b->used_tables & ~OUTER_REF_TABLE_BIT))))\n    return res;\n  return (int) ((a->optimize & KEY_OPTIMIZE_REF_OR_NULL) -\n\t\t(b->optimize & KEY_OPTIMIZE_REF_OR_NULL));\n}", "target": 0}
{"code": "      \\param[out] colors At return, contains the list of 3d object colors.\n      \\return List of 3d object vertices.\n    **/\n    template<typename tf, typename tc>", "target": 0}
{"code": "del_aubio_filterbank (aubio_filterbank_t * fb)\n{\n  del_fmat (fb->filters);\n  AUBIO_FREE (fb);\n}", "target": 0}
{"code": "static ssize_t ext4_ext_direct_IO(int rw, struct kiocb *iocb,\n\t\t\t      const struct iovec *iov, loff_t offset,\n\t\t\t      unsigned long nr_segs)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tssize_t ret;\n\tsize_t count = iov_length(iov, nr_segs);\n\tloff_t final_size = offset + count;\n\tif (rw == WRITE && final_size <= inode->i_size) {\n\t\tiocb->private = NULL;\n\t\tEXT4_I(inode)->cur_aio_dio = NULL;\n\t\tif (!is_sync_kiocb(iocb)) {\n\t\t\tiocb->private = ext4_init_io_end(inode);\n\t\t\tif (!iocb->private)\n\t\t\t\treturn -ENOMEM;\n\t\t\tEXT4_I(inode)->cur_aio_dio = iocb->private;\n\t\t}\n\t\tret = blockdev_direct_IO(rw, iocb, inode,\n\t\t\t\t\t inode->i_sb->s_bdev, iov,\n\t\t\t\t\t offset, nr_segs,\n\t\t\t\t\t ext4_get_block_write,\n\t\t\t\t\t ext4_end_io_dio);\n\t\tif (iocb->private)\n\t\t\tEXT4_I(inode)->cur_aio_dio = NULL;\n\t\tif (ret != -EIOCBQUEUED && ret <= 0 && iocb->private) {\n\t\t\text4_free_io_end(iocb->private);\n\t\t\tiocb->private = NULL;\n\t\t} else if (ret > 0 && ext4_test_inode_state(inode,\n\t\t\t\t\t\tEXT4_STATE_DIO_UNWRITTEN)) {\n\t\t\tint err;\n\t\t\terr = ext4_convert_unwritten_extents(inode,\n\t\t\t\t\t\t\t     offset, ret);\n\t\t\tif (err < 0)\n\t\t\t\tret = err;\n\t\t\text4_clear_inode_state(inode, EXT4_STATE_DIO_UNWRITTEN);\n\t\t}\n\t\treturn ret;\n\t}\n\treturn ext4_ind_direct_IO(rw, iocb, iov, offset, nr_segs);\n}", "target": 1}
{"code": "pci_emul_mem_handler(struct vmctx *ctx, int vcpu, int dir, uint64_t addr,\n\t\t     int size, uint64_t *val, void *arg1, long arg2)\n{\n\tstruct pci_vdev *pdi = arg1;\n\tstruct pci_vdev_ops *ops = pdi->dev_ops;\n\tuint64_t offset;\n\tint bidx = (int) arg2;\n\tassert(bidx <= PCI_BARMAX);\n\tassert(pdi->bar[bidx].type == PCIBAR_MEM32 ||\n\t       pdi->bar[bidx].type == PCIBAR_MEM64);\n\tassert(addr >= pdi->bar[bidx].addr &&\n\t       addr + size <= pdi->bar[bidx].addr + pdi->bar[bidx].size);\n\toffset = addr - pdi->bar[bidx].addr;\n\tif (dir == MEM_F_WRITE) {\n\t\tif (size == 8) {\n\t\t\t(*ops->vdev_barwrite)(ctx, vcpu, pdi, bidx, offset,\n\t\t\t\t\t   4, *val & 0xffffffff);\n\t\t\t(*ops->vdev_barwrite)(ctx, vcpu, pdi, bidx, offset + 4,\n\t\t\t\t\t   4, *val >> 32);\n\t\t} else {\n\t\t\t(*ops->vdev_barwrite)(ctx, vcpu, pdi, bidx, offset,\n\t\t\t\t\t   size, bar_value(size, *val));\n\t\t}\n\t} else {\n\t\tif (size == 8) {\n\t\t\tuint64_t val_lo, val_hi;\n\t\t\tval_lo = (*ops->vdev_barread)(ctx, vcpu, pdi, bidx,\n\t\t\t                              offset, 4);\n\t\t\tval_lo = bar_value(4, val_lo);\n\t\t\tval_hi = (*ops->vdev_barread)(ctx, vcpu, pdi, bidx,\n\t\t\t                              offset + 4, 4);\n\t\t\t*val = val_lo | (val_hi << 32);\n\t\t} else {\n\t\t\t*val = (*ops->vdev_barread)(ctx, vcpu, pdi, bidx,\n\t\t\t                            offset, size);\n\t\t\t*val = bar_value(size, *val);\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "compat_mptfwxfer_ioctl(struct file *filp, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct mpt_fw_xfer32 kfw32;\n\tstruct mpt_fw_xfer kfw;\n\tMPT_ADAPTER *iocp = NULL;\n\tint iocnum, iocnumX;\n\tint nonblock = (filp->f_flags & O_NONBLOCK);\n\tint ret;\n\tif (copy_from_user(&kfw32, (char __user *)arg, sizeof(kfw32)))\n\t\treturn -EFAULT;\n\tiocnumX = kfw32.iocnum & 0xFF;\n\tif (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||\n\t    (iocp == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"::compat_mptfwxfer_ioctl @%d - ioc%d not found!\\n\",\n\t\t\t__LINE__, iocnumX);\n\t\treturn -ENODEV;\n\t}\n\tif ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)\n\t\treturn ret;\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT \"compat_mptfwxfer_ioctl() called\\n\",\n\t    iocp->name));\n\tkfw.iocnum = iocnum;\n\tkfw.fwlen = kfw32.fwlen;\n\tkfw.bufp = compat_ptr(kfw32.bufp);\n\tret = mptctl_do_fw_download(kfw.iocnum, kfw.bufp, kfw.fwlen);\n\tmutex_unlock(&iocp->ioctl_cmds.mutex);\n\treturn ret;\n}", "target": 1}
{"code": "static void opl3_panning(int dev, int voice, int value)\n{\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn;\n\tdevc->voc[voice].panning = value;\n}", "target": 0}
{"code": "values_equal_for_ipcp_p (tree x, tree y)\n{\n  gcc_checking_assert (x != NULL_TREE && y != NULL_TREE);\n  if (x == y)\n    return true;\n  if (TREE_CODE (x) ==  ADDR_EXPR\n      && TREE_CODE (y) ==  ADDR_EXPR\n      && TREE_CODE (TREE_OPERAND (x, 0)) == CONST_DECL\n      && TREE_CODE (TREE_OPERAND (y, 0)) == CONST_DECL)\n    return operand_equal_p (DECL_INITIAL (TREE_OPERAND (x, 0)),\n\t\t\t    DECL_INITIAL (TREE_OPERAND (y, 0)), 0);\n  else\n    return operand_equal_p (x, y, 0);\n}", "target": 0}
{"code": "static int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir,\n\t\t\t      struct dentry *dentry, struct path *lowerpath,\n\t\t\t      struct kstat *stat, struct iattr *attr,\n\t\t\t      const char *link)\n{\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *newdentry = NULL;\n\tstruct dentry *upper = NULL;\n\tumode_t mode = stat->mode;\n\tint err;\n\tnewdentry = ovl_lookup_temp(workdir, dentry);\n\terr = PTR_ERR(newdentry);\n\tif (IS_ERR(newdentry))\n\t\tgoto out;\n\tupper = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t       dentry->d_name.len);\n\terr = PTR_ERR(upper);\n\tif (IS_ERR(upper))\n\t\tgoto out1;\n\tstat->mode &= S_IFMT;\n\terr = ovl_create_real(wdir, newdentry, stat, link, NULL, true);\n\tstat->mode = mode;\n\tif (err)\n\t\tgoto out2;\n\tif (S_ISREG(stat->mode)) {\n\t\tstruct path upperpath;\n\t\tovl_path_upper(dentry, &upperpath);\n\t\tBUG_ON(upperpath.dentry != NULL);\n\t\tupperpath.dentry = newdentry;\n\t\terr = ovl_copy_up_data(lowerpath, &upperpath, stat->size);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\t}\n\terr = ovl_copy_xattr(lowerpath->dentry, newdentry);\n\tif (err)\n\t\tgoto out_cleanup;\n\tmutex_lock(&newdentry->d_inode->i_mutex);\n\terr = ovl_set_attr(newdentry, stat);\n\tif (!err && attr)\n\t\terr = notify_change(newdentry, attr, NULL);\n\tmutex_unlock(&newdentry->d_inode->i_mutex);\n\tif (err)\n\t\tgoto out_cleanup;\n\terr = ovl_do_rename(wdir, newdentry, udir, upper, 0);\n\tif (err)\n\t\tgoto out_cleanup;\n\tovl_dentry_update(dentry, newdentry);\n\tnewdentry = NULL;\n\tif (!S_ISDIR(stat->mode))\n\t\tovl_dentry_set_opaque(dentry, true);\nout2:\n\tdput(upper);\nout1:\n\tdput(newdentry);\nout:\n\treturn err;\nout_cleanup:\n\tovl_cleanup(wdir, newdentry);\n\tgoto out;\n}", "target": 1}
{"code": "static ssize_t aio_setup_vectored_rw(int type, struct kiocb *kiocb, bool compat)\n{\n\tssize_t ret;\n#ifdef CONFIG_COMPAT\n\tif (compat)\n\t\tret = compat_rw_copy_check_uvector(type,\n\t\t\t\t(struct compat_iovec __user *)kiocb->ki_buf,\n\t\t\t\tkiocb->ki_nbytes, 1, &kiocb->ki_inline_vec,\n\t\t\t\t&kiocb->ki_iovec, 1);\n\telse\n#endif\n\t\tret = rw_copy_check_uvector(type,\n\t\t\t\t(struct iovec __user *)kiocb->ki_buf,\n\t\t\t\tkiocb->ki_nbytes, 1, &kiocb->ki_inline_vec,\n\t\t\t\t&kiocb->ki_iovec, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = rw_verify_area(type, kiocb->ki_filp, &kiocb->ki_pos, ret);\n\tif (ret < 0)\n\t\tgoto out;\n\tkiocb->ki_nr_segs = kiocb->ki_nbytes;\n\tkiocb->ki_cur_seg = 0;\n\tkiocb->ki_nbytes = ret;\n\tkiocb->ki_left = ret;\n\tret = 0;\nout:\n\treturn ret;\n}", "target": 0}
{"code": "void FrameFactory::rebuildAggregateFrames(ID3v2::Tag *tag) const\n{\n  if(tag->header()->majorVersion() < 4 &&\n     tag->frameList(\"TDRC\").size() == 1 &&\n     tag->frameList(\"TDAT\").size() == 1)\n  {\n    TextIdentificationFrame *tdrc =\n      static_cast<TextIdentificationFrame *>(tag->frameList(\"TDRC\").front());\n    UnknownFrame *tdat = static_cast<UnknownFrame *>(tag->frameList(\"TDAT\").front());\n    if(tdrc->fieldList().size() == 1 &&\n       tdrc->fieldList().front().size() == 4 &&\n       tdat->data().size() >= 5)\n    {\n      String date(tdat->data().mid(1), String::Type(tdat->data()[0]));\n      if(date.length() == 4) {\n        tdrc->setText(tdrc->toString() + '-' + date.substr(2, 2) + '-' + date.substr(0, 2));\n        if(tag->frameList(\"TIME\").size() == 1) {\n          UnknownFrame *timeframe = static_cast<UnknownFrame *>(tag->frameList(\"TIME\").front());\n          if(timeframe->data().size() >= 5) {\n            String time(timeframe->data().mid(1), String::Type(timeframe->data()[0]));\n            if(time.length() == 4) {\n              tdrc->setText(tdrc->toString() + 'T' + time.substr(0, 2) + ':' + time.substr(2, 2));\n            }\n          }\n        }\n      }\n    }\n  }\n}", "target": 1}
{"code": "_SSL_check_hostname (X509 *cert, const char *host)\n{\n\tint rv;\n\trv = _SSL_check_subject_altname (cert, host);\n\tif (rv == 0 || rv == -2)\n\t\treturn rv;\n\treturn _SSL_check_common_name (cert, host);\n}", "target": 0}
{"code": "avp_enum(struct l2tp_avp *avp, const u_char *pkt, int pktlen, int filldata)\n{\n\tuint16_t flags;\n\tL2TP_SUBR_ASSERT(pktlen >= 6);\n\tif (pktlen < 6)\n\t\treturn -1;\n\tGETSHORT(flags, pkt);\n\tavp->is_mandatory = ((flags & 0x8000) != 0)? 1 : 0;\n\tavp->is_hidden = ((flags & 0x4000) != 0)? 1 : 0;\n\tavp->length = flags & 0x03ff;\n\tGETSHORT(avp->vendor_id, pkt);\n\tavp->attr_type = *pkt << 8;\n\tavp->attr_type |= *(pkt + 1);\n\tpkt += 2;\n\tif (avp->length > pktlen)\n\t\treturn -1;\n\tif (filldata != 0)\n\t\tmemcpy(avp->attr_value, pkt, avp->length - 6);\n\treturn avp->length;\n}", "target": 1}
{"code": "    Iptcdatum& Iptcdatum::operator=(const Iptcdatum& rhs)\n    {\n        if (this == &rhs) return *this;\n        Metadatum::operator=(rhs);\n        key_.reset();\n        if (rhs.key_.get() != 0) key_ = rhs.key_->clone(); \n        value_.reset();\n        if (rhs.value_.get() != 0) value_ = rhs.value_->clone(); \n        return *this;\n    } ", "target": 0}
{"code": "static void destroy_compound_gigantic_page(struct page *page,\n\t\t\t\t\tunsigned int order)\n{\n\t__destroy_compound_gigantic_page(page, order, false);\n}", "target": 0}
{"code": "find_entry_internal_uniqueid(\n\tSlapi_PBlock\t*pb,\n    backend *be,\n\tconst char \t\t\t*uniqueid,\n    int\t\t\t\tlock,\n\tback_txn\t\t*txn\n)\n{\n\tldbm_instance *inst = (ldbm_instance *) be->be_instance_info;\n\tstruct backentry\t*e;\n\tint\t\t\terr;\n\tsize_t tries = 0;\n\twhile ( (tries < LDBM_CACHE_RETRY_COUNT) && \n\t\t\t(e = uniqueid2entry(be, uniqueid, txn, &err ))\n\t    != NULL ) {\n\t\tif ( !lock || cache_lock_entry( &inst->inst_cache, e ) == 0 ) {\n\t\t\tLDAPDebug( LDAP_DEBUG_TRACE,\n\t\t\t    \"<= find_entry_internal_uniqueid found; uniqueid = (%s)\\n\", \n\t\t\tuniqueid, 0, 0 );\n\t\t\treturn( e );\n\t\t}\n\t\tLDAPDebug( LDAP_DEBUG_ARGS,\n\t\t\t\"   find_entry_internal_uniqueid retrying; uniqueid = (%s)\\n\", \n\t\t\tuniqueid, 0, 0 );\n\t\tCACHE_RETURN( &inst->inst_cache, &e );\n\t\ttries++;\n\t}\n\tif (tries >= LDBM_CACHE_RETRY_COUNT) {\n\t\tLDAPDebug( LDAP_DEBUG_ANY,\n\t\t\t\"find_entry_internal_uniqueid retry count exceeded; uniqueid = (%s)\\n\", \n\t\t\tuniqueid , 0, 0 );\n\t}\n\tslapi_send_ldap_result( pb, ( 0 == err || DB_NOTFOUND == err ) ?\n\t\tLDAP_NO_SUCH_OBJECT : LDAP_OPERATIONS_ERROR, NULL , NULL,\n\t\t0, NULL );\n\tLDAPDebug( LDAP_DEBUG_TRACE, \n\t\t\"<= find_entry_internal_uniqueid not found; uniqueid = (%s)\\n\",\n\t    uniqueid, 0, 0 );\n\treturn( NULL );\n}", "target": 1}
{"code": "void kvm_queue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, false);\n}", "target": 0}
{"code": "relay_websocket_decode_frame (const unsigned char *buffer,\n                              unsigned long long buffer_length,\n                              unsigned char *decoded,\n                              unsigned long long *decoded_length)\n{\n    unsigned long long i, index_buffer, length_frame_size, length_frame;\n    unsigned char opcode;\n    *decoded_length = 0;\n    index_buffer = 0;\n    while (index_buffer + 2 <= buffer_length)\n    {\n        opcode = buffer[index_buffer] & 15;\n        if (!(buffer[index_buffer + 1] & 128))\n            return 0;\n        length_frame_size = 1;\n        length_frame = buffer[index_buffer + 1] & 127;\n        index_buffer += 2;\n        if ((length_frame == 126) || (length_frame == 127))\n        {\n            length_frame_size = (length_frame == 126) ? 2 : 8;\n            if (buffer_length < 1 + length_frame_size)\n                return 0;\n            length_frame = 0;\n            for (i = 0; i < length_frame_size; i++)\n            {\n                length_frame += (unsigned long long)buffer[index_buffer + i] << ((length_frame_size - i - 1) * 8);\n            }\n            index_buffer += length_frame_size;\n        }\n        if (buffer_length < 1 + length_frame_size + 4 + length_frame)\n            return 0;\n        int masks[4];\n        for (i = 0; i < 4; i++)\n        {\n            masks[i] = (int)((unsigned char)buffer[index_buffer + i]);\n        }\n        index_buffer += 4;\n        switch (opcode)\n        {\n            case WEBSOCKET_FRAME_OPCODE_PING:\n                decoded[*decoded_length] = RELAY_CLIENT_MSG_PING;\n                break;\n            case WEBSOCKET_FRAME_OPCODE_CLOSE:\n                decoded[*decoded_length] = RELAY_CLIENT_MSG_CLOSE;\n                break;\n            default:\n                decoded[*decoded_length] = RELAY_CLIENT_MSG_STANDARD;\n                break;\n        }\n        *decoded_length += 1;\n        for (i = 0; i < length_frame; i++)\n        {\n            decoded[*decoded_length + i] = (int)((unsigned char)buffer[index_buffer + i]) ^ masks[i % 4];\n        }\n        decoded[*decoded_length + length_frame] = '\\0';\n        *decoded_length += length_frame + 1;\n        index_buffer += length_frame;\n    }\n    return 1;\n}", "target": 1}
{"code": "PHP_FUNCTION(number_format)\n{\n\tdouble num;\n\tlong dec = 0;\n\tchar *thousand_sep = NULL, *dec_point = NULL;\n\tchar thousand_sep_chr = ',', dec_point_chr = '.';\n\tint thousand_sep_len = 0, dec_point_len = 0;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"d|ls!s!\", &num, &dec, &dec_point, &dec_point_len, &thousand_sep, &thousand_sep_len) == FAILURE) {\n\t\treturn;\n\t}\n\tswitch(ZEND_NUM_ARGS()) {\n\tcase 1:\n\t\tRETURN_STRING(_php_math_number_format(num, 0, dec_point_chr, thousand_sep_chr), 0);\n\t\tbreak;\n\tcase 2:\n\t\tRETURN_STRING(_php_math_number_format(num, dec, dec_point_chr, thousand_sep_chr), 0);\n\t\tbreak;\n\tcase 4:\n\t\tif (dec_point == NULL) {\n\t\t\tdec_point = &dec_point_chr;\n\t\t\tdec_point_len = 1;\n\t\t}\n\t\tif (thousand_sep == NULL) {\n\t\t\tthousand_sep = &thousand_sep_chr;\n\t\t\tthousand_sep_len = 1;\n\t\t}\n\t\tZ_TYPE_P(return_value) = IS_STRING;\n\t\tZ_STRVAL_P(return_value) = _php_math_number_format_ex_len(num, dec,\n\t\t\t\tdec_point, dec_point_len, thousand_sep, thousand_sep_len,\n\t\t\t\t&Z_STRLEN_P(return_value));\n\t\tbreak;\n\tdefault:\n\t\tWRONG_PARAM_COUNT;\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "int ScriptController::contextDebugId(v8::Handle<v8::Context> context)\n{\n    return V8PerContextDebugData::contextDebugId(context);\n}", "target": 0}
{"code": "void SMsgReader::readExtendedClipboard(rdr::S32 len)\n{\n  rdr::U32 flags;\n  rdr::U32 action;\n  if (len < 4)\n    throw Exception(\"Invalid extended clipboard message\");\n  if (len > maxCutText) {\n    vlog.error(\"Extended clipboard message too long (%d bytes) - ignoring\", len);\n    is->skip(len);\n    return;\n  }\n  flags = is->readU32();\n  action = flags & clipboardActionMask;\n  if (action & clipboardCaps) {\n    int i;\n    size_t num;\n    rdr::U32 lengths[16];\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (flags & (1 << i))\n        num++;\n    }\n    if (len < (rdr::S32)(4 + 4*num))\n      throw Exception(\"Invalid extended clipboard message\");\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (flags & (1 << i))\n        lengths[num++] = is->readU32();\n    }\n    handler->handleClipboardCaps(flags, lengths);\n  } else if (action == clipboardProvide) {\n    rdr::ZlibInStream zis;\n    int i;\n    size_t num;\n    size_t lengths[16];\n    rdr::U8* buffers[16];\n    zis.setUnderlying(is, len - 4);\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (!(flags & 1 << i))\n        continue;\n      lengths[num] = zis.readU32();\n      if (lengths[num] > (size_t)maxCutText) {\n        vlog.error(\"Extended clipboard data too long (%d bytes) - ignoring\",\n                   (unsigned)lengths[num]);\n        zis.skip(lengths[num]);\n        flags &= ~(1 << i);\n        continue;\n      }\n      buffers[num] = new rdr::U8[lengths[num]];\n      zis.readBytes(buffers[num], lengths[num]);\n      num++;\n    }\n    zis.removeUnderlying();\n    handler->handleClipboardProvide(flags, lengths, buffers);\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (!(flags & 1 << i))\n        continue;\n      delete [] buffers[num++];\n    }\n  } else {\n    switch (action) {\n    case clipboardRequest:\n      handler->handleClipboardRequest(flags);\n      break;\n    case clipboardPeek:\n      handler->handleClipboardPeek(flags);\n      break;\n    case clipboardNotify:\n      handler->handleClipboardNotify(flags);\n      break;\n    default:\n      throw Exception(\"Invalid extended clipboard action\");\n    }\n  }\n}", "target": 1}
{"code": "R_API int r_socket_read_block(RSocket *s, ut8 *buf, int len) {\n\tint ret = 0;\n\tfor (ret = 0; ret < len; ) {\n\t\tint r = r_socket_read (s, buf + ret, len - ret);\n\t\tif (r == -1) {\n#if HAVE_LIB_SSL\n\t\t\tif (SSL_get_error (s->sfd, r) == SSL_ERROR_WANT_READ) {\n\t\t\t\tif (r_socket_ready (s, 1, 0) == 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\treturn -1;\n\t\t}\n\t\tif (r < 1) {\n\t\t\tbreak;\n\t\t}\n\t\tret += r;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static int _nfs4_do_open(struct inode *dir, struct path *path, int flags, struct iattr *sattr, struct rpc_cred *cred, struct nfs4_state **res)\n{\n\tstruct nfs4_state_owner  *sp;\n\tstruct nfs4_state     *state = NULL;\n\tstruct nfs_server       *server = NFS_SERVER(dir);\n\tstruct nfs4_opendata *opendata;\n\tint status;\n\tstatus = -ENOMEM;\n\tif (!(sp = nfs4_get_state_owner(server, cred))) {\n\t\tdprintk(\"nfs4_do_open: nfs4_get_state_owner failed!\\n\");\n\t\tgoto out_err;\n\t}\n\tstatus = nfs4_recover_expired_lease(server);\n\tif (status != 0)\n\t\tgoto err_put_state_owner;\n\tif (path->dentry->d_inode != NULL)\n\t\tnfs4_return_incompatible_delegation(path->dentry->d_inode, flags & (FMODE_READ|FMODE_WRITE));\n\tstatus = -ENOMEM;\n\topendata = nfs4_opendata_alloc(path, sp, flags, sattr);\n\tif (opendata == NULL)\n\t\tgoto err_put_state_owner;\n\tif (path->dentry->d_inode != NULL)\n\t\topendata->state = nfs4_get_open_state(path->dentry->d_inode, sp);\n\tstatus = _nfs4_proc_open(opendata);\n\tif (status != 0)\n\t\tgoto err_opendata_put;\n\tif (opendata->o_arg.open_flags & O_EXCL)\n\t\tnfs4_exclusive_attrset(opendata, sattr);\n\tstate = nfs4_opendata_to_nfs4_state(opendata);\n\tstatus = PTR_ERR(state);\n\tif (IS_ERR(state))\n\t\tgoto err_opendata_put;\n\tnfs4_opendata_put(opendata);\n\tnfs4_put_state_owner(sp);\n\t*res = state;\n\treturn 0;\nerr_opendata_put:\n\tnfs4_opendata_put(opendata);\nerr_put_state_owner:\n\tnfs4_put_state_owner(sp);\nout_err:\n\t*res = NULL;\n\treturn status;\n}", "target": 1}
{"code": "static int core_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp)\n{\n    ap_mutex_init(pconf);\n    if (!saved_server_config_defines)\n        init_config_defines(pconf);\n    apr_pool_cleanup_register(pconf, NULL, reset_config_defines,\n                              apr_pool_cleanup_null);\n    mpm_common_pre_config(pconf);\n    return OK;\n}", "target": 0}
{"code": "static int em_jmp_far(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned short sel, old_sel;\n\tstruct desc_struct old_desc, new_desc;\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tu8 cpl = ctxt->ops->cpl(ctxt);\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tops->get_segment(ctxt, &old_sel, &old_desc, NULL,\n\t\t\t\t VCPU_SREG_CS);\n\tmemcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2);\n\trc = __load_segment_descriptor(ctxt, sel, VCPU_SREG_CS, cpl,\n\t\t\t\t       X86_TRANSFER_CALL_JMP,\n\t\t\t\t       &new_desc);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = assign_eip_far(ctxt, ctxt->src.val, &new_desc);\n\tif (rc != X86EMUL_CONTINUE) {\n\t\tWARN_ON(ctxt->mode != X86EMUL_MODE_PROT64);\n\t\tops->set_segment(ctxt, old_sel, &old_desc, 0, VCPU_SREG_CS);\n\t\treturn rc;\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "static struct btf *find_kfunc_desc_btf(struct bpf_verifier_env *env,\n\t\t\t\t       u32 func_id, s16 offset,\n\t\t\t\t       struct module **btf_modp)\n{\n\tif (offset) {\n\t\tif (offset < 0) {\n\t\t\tverbose(env, \"negative offset disallowed for kernel module function call\\n\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\treturn __find_kfunc_desc_btf(env, offset, btf_modp);\n\t}\n\treturn btf_vmlinux ?: ERR_PTR(-ENOENT);\n}", "target": 0}
{"code": "static ssize_t qrtr_tun_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct qrtr_tun *tun = filp->private_data;\n\tsize_t len = iov_iter_count(from);\n\tssize_t ret;\n\tvoid *kbuf;\n\tkbuf = kzalloc(len, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\tif (!copy_from_iter_full(kbuf, len, from))\n\t\treturn -EFAULT;\n\tret = qrtr_endpoint_post(&tun->ep, kbuf, len);\n\treturn ret < 0 ? ret : len;\n}", "target": 1}
{"code": "  void operator()(OpKernelContext* context, const Tensor& input_tensor,\n                  Tensor& output_tensor, int n, bool reverse) {\n    const T* input = input_tensor.flat<T>().data();\n    T* output = output_tensor.flat<T>().data();\n    const int num_rows = output_tensor.NumElements();\n    const int last_dim = input_tensor.dim_size(input_tensor.dims() - 1);\n    auto SubNthElement = [&, input, output, last_dim, n](int start, int limit) {\n      std::vector<T> buf(last_dim);\n      for (int b = start; b < limit; ++b) {\n        const T* input_start = input + b * last_dim;\n        const T* input_end = input + (b + 1) * last_dim;\n        std::copy(input_start, input_end, buf.begin());\n        std::nth_element(buf.begin(), buf.begin() + n, buf.end());\n        output[b] = buf[n];\n      }\n    };\n    auto worker_threads = *(context->device()->tensorflow_cpu_worker_threads());\n    Shard(worker_threads.num_threads, worker_threads.workers, num_rows,\n          20 * last_dim, SubNthElement);\n  }", "target": 1}
{"code": "static void update_bp_intercept(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tclr_exception_intercept(svm, BP_VECTOR);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_ENABLE) {\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\tset_exception_intercept(svm, BP_VECTOR);\n\t} else\n\t\tvcpu->guest_debug = 0;\n}", "target": 0}
{"code": "void test_parser_hvi(void) {\n\ttest_parser_param(1);\n}", "target": 0}
{"code": "GF_Err paen_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}", "target": 0}
{"code": "void sqlite3WithPush(Parse *pParse, With *pWith, u8 bFree){\n  assert( bFree==0 || (pParse->pWith==0 && pParse->pWithToFree==0) );\n  if( pWith ){\n    assert( pParse->pWith!=pWith );\n    pWith->pOuter = pParse->pWith;\n    pParse->pWith = pWith;\n    if( bFree ) pParse->pWithToFree = pWith;\n  }\n}", "target": 0}
{"code": "krb5_gss_context_time(minor_status, context_handle, time_rec)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    OM_uint32 *time_rec;\n{\n    krb5_error_code code;\n    krb5_gss_ctx_id_rec *ctx;\n    krb5_timestamp now;\n    krb5_deltat lifetime;\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n    if (! ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n    if ((code = krb5_timeofday(ctx->k5_context, &now))) {\n        *minor_status = code;\n        save_error_info(*minor_status, ctx->k5_context);\n        return(GSS_S_FAILURE);\n    }\n    if ((lifetime = ctx->krb_times.endtime - now) <= 0) {\n        *time_rec = 0;\n        *minor_status = 0;\n        return(GSS_S_CONTEXT_EXPIRED);\n    } else {\n        *time_rec = lifetime;\n        *minor_status = 0;\n        return(GSS_S_COMPLETE);\n    }\n}", "target": 1}
{"code": "static inline bool nested_cpu_has_pml(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_ENABLE_PML);\n}", "target": 0}
{"code": "MONGO_EXPORT bson_type bson_iterator_next( bson_iterator *i ) {\n    int ds;\n    if ( i->first ) {\n        i->first = 0;\n        return ( bson_type )( *i->cur );\n    }\n    switch ( bson_iterator_type( i ) ) {\n    case BSON_EOO:\n        return BSON_EOO; \n    case BSON_UNDEFINED:\n    case BSON_NULL:\n        ds = 0;\n        break;\n    case BSON_BOOL:\n        ds = 1;\n        break;\n    case BSON_INT:\n        ds = 4;\n        break;\n    case BSON_LONG:\n    case BSON_DOUBLE:\n    case BSON_TIMESTAMP:\n    case BSON_DATE:\n        ds = 8;\n        break;\n    case BSON_OID:\n        ds = 12;\n        break;\n    case BSON_STRING:\n    case BSON_SYMBOL:\n    case BSON_CODE:\n        ds = 4 + bson_iterator_int_raw( i );\n        break;\n    case BSON_BINDATA:\n        ds = 5 + bson_iterator_int_raw( i );\n        break;\n    case BSON_OBJECT:\n    case BSON_ARRAY:\n    case BSON_CODEWSCOPE:\n        ds = bson_iterator_int_raw( i );\n        break;\n    case BSON_DBREF:\n        ds = 4+12 + bson_iterator_int_raw( i );\n        break;\n    case BSON_REGEX: {\n        const char *s = bson_iterator_value( i );\n        const char *p = s;\n        p += strlen( p )+1;\n        p += strlen( p )+1;\n        ds = p-s;\n        break;\n    }\n    default: {\n        char msg[] = \"unknown type: 000000000000\";\n        bson_numstr( msg+14, ( unsigned )( i->cur[0] ) );\n        bson_fatal_msg( 0, msg );\n        return 0;\n    }\n    }\n    i->cur += 1 + strlen( i->cur + 1 ) + 1 + ds;\n    return ( bson_type )( *i->cur );\n}", "target": 1}
{"code": "static void dnss_receive_udp_packet_handler(void *arg, struct udp_pcb *udp_pcb,\nstruct pbuf *udp_packet_buffer, struct ip_addr *sender_addr, uint16_t sender_port)\n{\n\tint ret=0;\n\tstruct dns_hdr *dns_rsp;\n\tdns_rsp = (struct dns_hdr*) udp_packet_buffer->payload;\n\tdns_rsp->flags1 |= 0x80; \n\tdns_rsp->flags2 = 0x05;  \n\tret = udp_sendto(udp_pcb, udp_packet_buffer, sender_addr, sender_port);\n\tudp_disconnect(udp_pcb);\n\tpbuf_free(udp_packet_buffer);\n}", "target": 0}
{"code": "int mutt_b64_decode(char *out, const char *in)\n{\n  int len = 0;\n  unsigned char digit4;\n  do\n  {\n    const unsigned char digit1 = in[0];\n    if ((digit1 > 127) || (base64val(digit1) == BAD))\n      return -1;\n    const unsigned char digit2 = in[1];\n    if ((digit2 > 127) || (base64val(digit2) == BAD))\n      return -1;\n    const unsigned char digit3 = in[2];\n    if ((digit3 > 127) || ((digit3 != '=') && (base64val(digit3) == BAD)))\n      return -1;\n    digit4 = in[3];\n    if ((digit4 > 127) || ((digit4 != '=') && (base64val(digit4) == BAD)))\n      return -1;\n    in += 4;\n    *out++ = (base64val(digit1) << 2) | (base64val(digit2) >> 4);\n    len++;\n    if (digit3 != '=')\n    {\n      *out++ = ((base64val(digit2) << 4) & 0xf0) | (base64val(digit3) >> 2);\n      len++;\n      if (digit4 != '=')\n      {\n        *out++ = ((base64val(digit3) << 6) & 0xc0) | base64val(digit4);\n        len++;\n      }\n    }\n  } while (*in && digit4 != '=');\n  return len;\n}", "target": 1}
{"code": "parse_key_constraint_extension(struct sshbuf *m, char **sk_providerp)\n{\n\tchar *ext_name = NULL;\n\tint r;\n\tif ((r = sshbuf_get_cstring(m, &ext_name, NULL)) != 0) {\n\t\terror_fr(r, \"parse constraint extension\");\n\t\tgoto out;\n\t}\n\tdebug_f(\"constraint ext %s\", ext_name);\n\tif (strcmp(ext_name, \"sk-provider@openssh.com\") == 0) {\n\t\tif (sk_providerp == NULL) {\n\t\t\terror_f(\"%s not valid here\", ext_name);\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (*sk_providerp != NULL) {\n\t\t\terror_f(\"%s already set\", ext_name);\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_cstring(m, sk_providerp, NULL)) != 0) {\n\t\t\terror_fr(r, \"parse %s\", ext_name);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\terror_f(\"unsupported constraint \\\"%s\\\"\", ext_name);\n\t\tr = SSH_ERR_FEATURE_UNSUPPORTED;\n\t\tgoto out;\n\t}\n\tr = 0;\n out:\n\tfree(ext_name);\n\treturn r;\n}", "target": 0}
{"code": "void mb2_cache_entry_delete_block(struct mb2_cache *cache, u32 key,\n\t\t\t\t  sector_t block)\n{\n\tstruct hlist_bl_node *node;\n\tstruct hlist_bl_head *head;\n\tstruct mb2_cache_entry *entry;\n\thead = &cache->c_hash[hash_32(key, cache->c_bucket_bits)];\n\thlist_bl_lock(head);\n\thlist_bl_for_each_entry(entry, node, head, e_hash_list) {\n\t\tif (entry->e_key == key && entry->e_block == block) {\n\t\t\thlist_bl_del_init(&entry->e_hash_list);\n\t\t\thlist_bl_unlock(head);\n\t\t\tspin_lock(&cache->c_lru_list_lock);\n\t\t\tif (!list_empty(&entry->e_lru_list)) {\n\t\t\t\tlist_del_init(&entry->e_lru_list);\n\t\t\t\tcache->c_entry_count--;\n\t\t\t\tatomic_dec(&entry->e_refcnt);\n\t\t\t}\n\t\t\tspin_unlock(&cache->c_lru_list_lock);\n\t\t\tmb2_cache_entry_put(cache, entry);\n\t\t\treturn;\n\t\t}\n\t}\n\thlist_bl_unlock(head);\n}", "target": 0}
{"code": "static struct sem_undo *find_alloc_undo(struct ipc_namespace *ns, int semid)\n{\n\tstruct sem_array *sma;\n\tstruct sem_undo_list *ulp;\n\tstruct sem_undo *un, *new;\n\tint nsems;\n\tint error;\n\terror = get_undo_list(&ulp);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\trcu_read_lock();\n\tspin_lock(&ulp->lock);\n\tun = lookup_undo(ulp, semid);\n\tspin_unlock(&ulp->lock);\n\tif (likely(un!=NULL))\n\t\tgoto out;\n\tsma = sem_obtain_object_check(ns, semid);\n\tif (IS_ERR(sma)) {\n\t\trcu_read_unlock();\n\t\treturn ERR_CAST(sma);\n\t}\n\tnsems = sma->sem_nsems;\n\tipc_rcu_getref(sma);\n\trcu_read_unlock();\n\tnew = kzalloc(sizeof(struct sem_undo) + sizeof(short)*nsems, GFP_KERNEL);\n\tif (!new) {\n\t\tsem_putref(sma);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tsem_lock_and_putref(sma);\n\tif (sma->sem_perm.deleted) {\n\t\tsem_unlock(sma);\n\t\tkfree(new);\n\t\tun = ERR_PTR(-EIDRM);\n\t\tgoto out;\n\t}\n\tspin_lock(&ulp->lock);\n\tun = lookup_undo(ulp, semid);\n\tif (un) {\n\t\tkfree(new);\n\t\tgoto success;\n\t}\n\tnew->semadj = (short *) &new[1];\n\tnew->ulp = ulp;\n\tnew->semid = semid;\n\tassert_spin_locked(&ulp->lock);\n\tlist_add_rcu(&new->list_proc, &ulp->list_proc);\n\tassert_spin_locked(&sma->sem_perm.lock);\n\tlist_add(&new->list_id, &sma->list_id);\n\tun = new;\nsuccess:\n\tspin_unlock(&ulp->lock);\n\trcu_read_lock();\n\tsem_unlock(sma);\nout:\n\treturn un;\n}", "target": 1}
{"code": "SWFShape_addGradientFillStyle(SWFShape shape, SWFGradient gradient, byte flags)\n{\n\tSWFFillStyle fill = newSWFGradientFillStyle(gradient, flags);\n\tif(addFillStyle(shape, fill) < 0)\n\t{\n\t\tdestroySWFFillStyle(fill);\n\t\treturn NULL;\n\t}\n\treturn fill;\t\t\n}", "target": 0}
{"code": "static Jsi_RC NumberToStringCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[500];\n    int radix = 10, skip = 0, argc = Jsi_ValueGetLength(interp, args);\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    if (argc>skip && (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &radix) != JSI_OK\n        || radix<2))\n        return JSI_ERROR;\n    if (argc==skip)\n        return jsi_ObjectToStringCmd(interp, args, _this, ret, funcPtr);\n    switch (radix) {\n        case 16: snprintf(buf, sizeof(buf), \"%\" PRIx64, (Jsi_Wide)num); break;\n        case 8: snprintf(buf, sizeof(buf), \"%\" PRIo64, (Jsi_Wide)num); break;\n        case 10: snprintf(buf, sizeof(buf), \"%\" PRId64, (Jsi_Wide)num); break;\n        default: return jsi_ObjectToStringCmd(interp, args, _this, ret, funcPtr);\n    }\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}", "target": 1}
{"code": "__reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,\n\t\t int type, struct posix_acl *acl)\n{\n\tchar *name;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\telse {\n\t\t\t\tif (error == 0)\n\t\t\t\t\tacl = NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tvalue = reiserfs_posix_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\terror = reiserfs_xattr_set_handle(th, inode, name, value, size, 0);\n\tif (error == -ENODATA) {\n\t\terror = 0;\n\t\tif (type == ACL_TYPE_ACCESS) {\n\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t}\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}", "target": 1}
{"code": "void IndexedDBDatabase::DeleteDatabase(\n    scoped_refptr<IndexedDBCallbacks> callbacks,\n    bool force_close) {\n  AppendRequest(std::make_unique<DeleteRequest>(this, callbacks));\n  if (force_close)\n    ForceClose();\n}", "target": 0}
{"code": "TEST(TF_CTStringTest, OffsetType) {\n  {\n    TF_TString s71;\n    TF_TString_Init(&s71);\n    size_t header_length = 24;\n    size_t size = 8;\n    TF_TString_ResizeUninitialized(&s71, header_length + size);\n    uint32_t save_size = s71.u.offset.size;\n    uint32_t save_offset = s71.u.offset.offset;\n    uint32_t save_count = s71.u.offset.count;\n    s71.u.offset.size = TF_TString_ToInternalSizeT(size, TF_TSTR_OFFSET);\n    s71.u.offset.offset = header_length;\n    s71.u.offset.count = 0;\n    EXPECT_EQ(size, TF_TString_GetSize(&s71));\n    EXPECT_EQ(TF_TSTR_OFFSET, TF_TString_GetType(&s71));\n    s71.u.offset.size = save_size;\n    s71.u.offset.offset = save_offset;\n    s71.u.offset.count = save_count;\n    TF_TString_Dealloc(&s71);\n  }\n}", "target": 0}
{"code": "X509_NAME_oneline_ex(X509_NAME * a,\n                     char *buf,\n                     unsigned int *size,\n                     unsigned long flag)\n{\n    BIO *out = NULL;\n    out = BIO_new(BIO_s_mem ());\n    if (X509_NAME_print_ex(out, a, 0, flag) > 0) {\n        if (buf != NULL && (*size) >  (unsigned int) BIO_number_written(out)) {\n            memset(buf, 0, *size);\n            BIO_read(out, buf, (int) BIO_number_written(out));\n        }\n        else {\n            *size = BIO_number_written(out);\n        }\n    }\n    BIO_free(out);\n    return (buf);\n}", "target": 1}
{"code": "usage (void)\n{\n  g_print (\"%s\\n\", _(\"Usage: exo-open [URLs...]\"));\n  g_print (\"%s\\n\", _(\"       exo-open --launch TYPE [PARAMETERs...]\"));\n  g_print (\"\\n\");\n  g_print (\"%s\\n\", _(\"  -?, --help                          Print this help message and exit\"));\n  g_print (\"%s\\n\", _(\"  -V, --version                       Print version information and exit\"));\n  g_print (\"\\n\");\n  g_print (\"%s\\n\", _(\"  --launch TYPE [PARAMETERs...]       Launch the preferred application of\\n\"\n                     \"                                      TYPE with the optional PARAMETERs, where\\n\"\n                     \"                                      TYPE is one of the following values.\"));\n  g_print (\"\\n\");\n  g_print (\"%s\\n\", _(\"  --working-directory DIRECTORY       Default working directory for applications\\n\"\n                     \"                                      when using the --launch option.\"));\n  g_print (\"\\n\");\n  g_print (\"%s\\n\", _(\"The following TYPEs are supported for the --launch command:\"));\n  g_print (\"\\n\");\n  g_print (\"%s\\n\", _(\"  WebBrowser       - The preferred Web Browser.\\n\"\n                     \"  MailReader       - The preferred Mail Reader.\\n\"\n                     \"  FileManager      - The preferred File Manager.\\n\"\n                     \"  TerminalEmulator - The preferred Terminal Emulator.\"));\n  g_print (\"\\n\");\n  g_print (\"%s\\n\", _(\"If you don't specify the --launch option, exo-open will open all specified\\n\"\n                     \"URLs with their preferred URL handlers. Else, if you specify the --launch\\n\"\n                     \"option, you can select which preferred application you want to run, and\\n\"\n                     \"pass additional parameters to the application (i.e. for TerminalEmulator\\n\"\n                     \"you can pass the command line that should be run in the terminal).\"));\n  g_print (\"\\n\");\n}", "target": 0}
{"code": "inline void ImageLoader::crossSiteOrCSPViolationOccurred(\n    AtomicString imageSourceURL) {\n  m_failedLoadURL = imageSourceURL;\n}", "target": 0}
{"code": "writefile(const char *name, struct string *s)\n{\n\tFILE *f;\n\tint ret;\n\tf = fopen(name, \"w\");\n\tif (!f) {\n\t\twarn(\"open %s:\", name);\n\t\treturn -1;\n\t}\n\tret = 0;\n\tif (fwrite(s->s, 1, s->n, f) != s->n || fflush(f) != 0) {\n\t\twarn(\"write %s:\", name);\n\t\tret = -1;\n\t}\n\tfclose(f);\n\treturn ret;\n}", "target": 1}
{"code": "Opal::Call::get_local_party_name () const\n{\n  return local_party_name;\n}", "target": 0}
{"code": "CBORTag_hash(CBORTagObject *self)\n{\n    if (!_CBOR2_thread_locals && _CBOR2_init_thread_locals() == -1)\n        return -1;\n    Py_hash_t ret = -1;\n    PyObject *running_hashes = NULL;\n    PyObject *tmp = NULL;\n    PyObject *self_id = PyLong_FromVoidPtr(self);\n    if (!self_id)\n        goto exit;\n    running_hashes = PyObject_GetAttrString(_CBOR2_thread_locals, \"running_hashes\");\n    if (!running_hashes) {\n        PyErr_Clear();\n        running_hashes = PySet_New(NULL);\n        if (PyObject_SetAttrString(_CBOR2_thread_locals, \"running_hashes\", running_hashes) == -1)\n            goto exit;\n    } else {\n        switch (PySet_Contains(running_hashes, self_id)) {\n            case -1:  \n                goto exit;\n            case 1:  \n                PyErr_SetString(\n                    PyExc_RuntimeError,\n                    \"This CBORTag is not hashable because it contains a reference to itself\"\n                );\n                goto exit;\n        }\n    }\n    if (PySet_Add(running_hashes, self_id) == -1)\n        goto exit;\n    tmp = Py_BuildValue(\"(KO)\", self->tag, self->value);\n    if (!tmp)\n        goto exit;\n    ret = PyObject_Hash(tmp);\n    if (ret == -1)\n        goto exit;\n    if (PySet_Discard(running_hashes, self_id) == -1) {\n        ret = -1;\n        goto exit;\n    }\n    Py_ssize_t length = PySequence_Length(running_hashes);\n    if (length == -1) {\n        ret = -1;\n        goto exit;\n    }\n    if (length == 0 && PyObject_DelAttrString(_CBOR2_thread_locals, \"running_hashes\") == -1) {\n        ret = -1;\n        goto exit;\n    }\nexit:\n    Py_CLEAR(self_id);\n    Py_CLEAR(running_hashes);\n    Py_CLEAR(tmp);\n    return ret;\n}", "target": 0}
{"code": "GF_Err chnl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ChannelLayoutBox *ptr = (GF_ChannelLayoutBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->layout.stream_structure);\n\tif (ptr->layout.stream_structure & 1) {\n\t\tgf_bs_write_u8(bs, ptr->layout.definedLayout);\n\t\tif (ptr->layout.definedLayout==0) {\n\t\t\tu32 i;\n\t\t\tfor (i=0; i<ptr->layout.channels_count; i++) {\n\t\t\t\tgf_bs_write_u8(bs, ptr->layout.layouts[i].position);\n\t\t\t\tif (ptr->layout.layouts[i].position==126) {\n\t\t\t\t\tgf_bs_write_int(bs, ptr->layout.layouts[i].azimuth, 16);\n\t\t\t\t\tgf_bs_write_int(bs, ptr->layout.layouts[i].elevation, 8);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tgf_bs_write_u64(bs, ptr->layout.omittedChannelsMap);\n\t\t}\n\t}\n\tif (ptr->layout.stream_structure & 2) {\n\t\tgf_bs_write_u8(bs, ptr->layout.object_count);\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "mp_dss_print(netdissect_options *ndo,\n             const u_char *opt, u_int opt_len, u_char flags)\n{\n        const struct mp_dss *mdss = (const struct mp_dss *) opt;\n        if ((opt_len != mp_dss_len(mdss, 1) &&\n             opt_len != mp_dss_len(mdss, 0)) || flags & TH_SYN)\n                return 0;\n        if (mdss->flags & MP_DSS_F)\n                ND_PRINT((ndo, \" fin\"));\n        opt += 4;\n        if (mdss->flags & MP_DSS_A) {\n                ND_PRINT((ndo, \" ack \"));\n                if (mdss->flags & MP_DSS_a) {\n                        ND_PRINT((ndo, \"%\" PRIu64, EXTRACT_64BITS(opt)));\n                        opt += 8;\n                } else {\n                        ND_PRINT((ndo, \"%u\", EXTRACT_32BITS(opt)));\n                        opt += 4;\n                }\n        }\n        if (mdss->flags & MP_DSS_M) {\n                ND_PRINT((ndo, \" seq \"));\n                if (mdss->flags & MP_DSS_m) {\n                        ND_PRINT((ndo, \"%\" PRIu64, EXTRACT_64BITS(opt)));\n                        opt += 8;\n                } else {\n                        ND_PRINT((ndo, \"%u\", EXTRACT_32BITS(opt)));\n                        opt += 4;\n                }\n                ND_PRINT((ndo, \" subseq %u\", EXTRACT_32BITS(opt)));\n                opt += 4;\n                ND_PRINT((ndo, \" len %u\", EXTRACT_16BITS(opt)));\n                opt += 2;\n                if (opt_len == mp_dss_len(mdss, 1))\n                        ND_PRINT((ndo, \" csum 0x%x\", EXTRACT_16BITS(opt)));\n        }\n        return 1;\n}", "target": 1}
{"code": "win_free_lsize(win_T *wp)\n{\n    if (wp != NULL)\n\tVIM_CLEAR(wp->w_lines);\n}", "target": 0}
{"code": "const char* menu_cache_item_get_file_basename( MenuCacheItem* item )\n{\n    return item->file_name;\n}", "target": 0}
{"code": "static int op_get_data(OggOpusFile *_of,int _nbytes){\n  unsigned char *buffer;\n  int            nbytes;\n  OP_ASSERT(_nbytes>0);\n  buffer=(unsigned char *)ogg_sync_buffer(&_of->oy,_nbytes);\n  if(OP_UNLIKELY(buffer==NULL))return OP_EFAULT;\n  nbytes=(int)(*_of->callbacks.read)(_of->stream,buffer,_nbytes);\n  OP_ASSERT(nbytes<=_nbytes);\n  if(OP_LIKELY(nbytes>0))ogg_sync_wrote(&_of->oy,nbytes);\n  return nbytes;\n}", "target": 0}
{"code": "void SSecurityTLS::shutdown()\n{\n  if (session) {\n    if (gnutls_bye(session, GNUTLS_SHUT_RDWR) != GNUTLS_E_SUCCESS) {\n      vlog.error(\"TLS session wasn't terminated gracefully\");\n    }\n  }\n  if (dh_params) {\n    gnutls_dh_params_deinit(dh_params);\n    dh_params = 0;\n  }\n  if (anon_cred) {\n    gnutls_anon_free_server_credentials(anon_cred);\n    anon_cred = 0;\n  }\n  if (cert_cred) {\n    gnutls_certificate_free_credentials(cert_cred);\n    cert_cred = 0;\n  }\n  if (session) {\n    gnutls_deinit(session);\n    session = 0;\n    gnutls_global_deinit();\n  }\n}", "target": 1}
{"code": "void dwc3_gadget_giveback(struct dwc3_ep *dep, struct dwc3_request *req,\n\t\tint status)\n{\n\tstruct dwc3\t\t\t*dwc = dep->dwc;\n\treq->started = false;\n\tlist_del(&req->list);\n\treq->remaining = 0;\n\tif (req->request.status == -EINPROGRESS)\n\t\treq->request.status = status;\n\tif (req->trb)\n\t\tusb_gadget_unmap_request_by_dev(dwc->sysdev,\n\t\t\t\t\t\t&req->request, req->direction);\n\treq->trb = NULL;\n\ttrace_dwc3_gadget_giveback(req);\n\tspin_unlock(&dwc->lock);\n\tusb_gadget_giveback_request(&dep->endpoint, &req->request);\n\tspin_lock(&dwc->lock);\n\tif (dep->number > 1)\n\t\tpm_runtime_put(dwc->dev);\n}", "target": 1}
{"code": "    Curl()\n    {\n        requestHeaders = 0;\n        curl = curl_easy_init();\n        if (!curl) throw Error(\"unable to initialize curl\");\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n        curl_easy_setopt(curl, CURLOPT_CAINFO, getEnv(\"SSL_CERT_FILE\", \"/etc/ssl/certs/ca-certificates.crt\").c_str());\n        curl_easy_setopt(curl, CURLOPT_USERAGENT, (\"Nix/\" + nixVersion).c_str());\n        curl_easy_setopt(curl, CURLOPT_FAILONERROR, 1);\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *) &curl);\n        curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, headerCallback);\n        curl_easy_setopt(curl, CURLOPT_HEADERDATA, (void *) &curl);\n        curl_easy_setopt(curl, CURLOPT_PROGRESSFUNCTION, progressCallback_);\n        curl_easy_setopt(curl, CURLOPT_PROGRESSDATA, (void *) &curl);\n        curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 0);\n        showProgress = isatty(STDERR_FILENO);\n    }", "target": 1}
{"code": "QString Utils::String::toHtmlEscaped(const QString &str)\n{\n#ifdef QBT_USES_QT5\n    return str.toHtmlEscaped();\n#else\n    return Qt::escape(str);\n#endif\n}", "target": 0}
{"code": "epilogProcessor(XML_Parser parser, const char *s, const char *end,\n                const char **nextPtr) {\n  parser->m_processor = epilogProcessor;\n  parser->m_eventPtr = s;\n  for (;;) {\n    const char *next = NULL;\n    int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n#ifdef XML_DTD\n    if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                  XML_ACCOUNT_DIRECT)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif\n    parser->m_eventEndPtr = next;\n    switch (tok) {\n    case -XML_TOK_PROLOG_S:\n      if (parser->m_defaultHandler) {\n        reportDefault(parser, parser->m_encoding, s, next);\n        if (parser->m_parsingStatus.parsing == XML_FINISHED)\n          return XML_ERROR_ABORTED;\n      }\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_TOK_NONE:\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    case XML_TOK_PROLOG_S:\n      if (parser->m_defaultHandler)\n        reportDefault(parser, parser->m_encoding, s, next);\n      break;\n    case XML_TOK_PI:\n      if (! reportProcessingInstruction(parser, parser->m_encoding, s, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_COMMENT:\n      if (! reportComment(parser, parser->m_encoding, s, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_INVALID:\n      parser->m_eventPtr = next;\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      if (! parser->m_parsingStatus.finalBuffer) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      if (! parser->m_parsingStatus.finalBuffer) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_PARTIAL_CHAR;\n    default:\n      return XML_ERROR_JUNK_AFTER_DOC_ELEMENT;\n    }\n    parser->m_eventPtr = s = next;\n    switch (parser->m_parsingStatus.parsing) {\n    case XML_SUSPENDED:\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_FINISHED:\n      return XML_ERROR_ABORTED;\n    default:;\n    }\n  }\n}", "target": 1}
{"code": "static void process_tree(struct rev_info *revs,\n\t\t\t struct tree *tree,\n\t\t\t show_object_fn show,\n\t\t\t struct strbuf *base,\n\t\t\t const char *name,\n\t\t\t void *cb_data)\n{\n\tstruct object *obj = &tree->object;\n\tstruct tree_desc desc;\n\tstruct name_entry entry;\n\tenum interesting match = revs->diffopt.pathspec.nr == 0 ?\n\t\tall_entries_interesting: entry_not_interesting;\n\tint baselen = base->len;\n\tif (!revs->tree_objects)\n\t\treturn;\n\tif (!obj)\n\t\tdie(\"bad tree object\");\n\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\treturn;\n\tif (parse_tree_gently(tree, revs->ignore_missing_links) < 0) {\n\t\tif (revs->ignore_missing_links)\n\t\t\treturn;\n\t\tdie(\"bad tree object %s\", oid_to_hex(&obj->oid));\n\t}\n\tobj->flags |= SEEN;\n\tshow(obj, base, name, cb_data);\n\tstrbuf_addstr(base, name);\n\tif (base->len)\n\t\tstrbuf_addch(base, '/');\n\tinit_tree_desc(&desc, tree->buffer, tree->size);\n\twhile (tree_entry(&desc, &entry)) {\n\t\tif (match != all_entries_interesting) {\n\t\t\tmatch = tree_entry_interesting(&entry, base, 0,\n\t\t\t\t\t\t       &revs->diffopt.pathspec);\n\t\t\tif (match == all_entries_not_interesting)\n\t\t\t\tbreak;\n\t\t\tif (match == entry_not_interesting)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (S_ISDIR(entry.mode))\n\t\t\tprocess_tree(revs,\n\t\t\t\t     lookup_tree(entry.sha1),\n\t\t\t\t     show, base, entry.path,\n\t\t\t\t     cb_data);\n\t\telse if (S_ISGITLINK(entry.mode))\n\t\t\tprocess_gitlink(revs, entry.sha1,\n\t\t\t\t\tshow, base, entry.path,\n\t\t\t\t\tcb_data);\n\t\telse\n\t\t\tprocess_blob(revs,\n\t\t\t\t     lookup_blob(entry.sha1),\n\t\t\t\t     show, base, entry.path,\n\t\t\t\t     cb_data);\n\t}\n\tstrbuf_setlen(base, baselen);\n\tfree_tree_buffer(tree);\n}", "target": 1}
{"code": "static char* ConcatHttpHeaders(HTTP_HEADERS_HANDLE httpHeadersHandle, size_t toAlloc, size_t headersCount)\n{\n    char *result = (char*)malloc(toAlloc * sizeof(char) + 1);\n    size_t i;\n    if (result == NULL)\n    {\n        LogError(\"unable to malloc\");\n    }\n    else\n    {\n        result[0] = '\\0';\n        for (i = 0; i < headersCount; i++)\n        {\n            char* temp;\n            if (HTTPHeaders_GetHeader(httpHeadersHandle, i, &temp) != HTTP_HEADERS_OK)\n            {\n                LogError(\"unable to HTTPHeaders_GetHeader\");\n                break;\n            }\n            else\n            {\n                (void)strcat(result, temp);\n                (void)strcat(result, \"\\r\\n\");\n                free(temp);\n            }\n        }\n        if (i < headersCount)\n        {\n            free(result);\n            result = NULL;\n        }\n        else\n        {\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "static void sock_def_wakeup(struct sock *sk)\n{\n\tread_lock(&sk->sk_callback_lock);\n\tif (sk->sk_sleep && waitqueue_active(sk->sk_sleep))\n\t\twake_up_interruptible_all(sk->sk_sleep);\n\tread_unlock(&sk->sk_callback_lock);\n}", "target": 0}
{"code": "static lbool must_quote(char c)\n{\n\treturn (c == '\\n'); \n}", "target": 0}
{"code": "gopherHTMLHeader(StoreEntry * e, const char *title, const char *substring)\n{\n    storeAppendPrintf(e, \"<!DOCTYPE HTML PUBLIC \\\"-\n    storeAppendPrintf(e, \"<HTML><HEAD><TITLE>\");\n    storeAppendPrintf(e, title, substring);\n    storeAppendPrintf(e, \"</TITLE>\");\n    storeAppendPrintf(e, \"<STYLE type=\\\"text/css\\\"><!--BODY{background-color:#ffffff;font-family:verdana,sans-serif}--></STYLE>\\n\");\n    storeAppendPrintf(e, \"</HEAD>\\n<BODY><H1>\");\n    storeAppendPrintf(e, title, substring);\n    storeAppendPrintf(e, \"</H1>\\n\");\n}", "target": 1}
{"code": "TEST(VulnerabilityTest, CRLFInjection) {\n  Server svr;\n  svr.Post(\"/test1\", [](const Request &, Response &res) {\n    res.set_content(\"Hello 1\", \"text/plain\");\n  });\n  svr.Delete(\"/test2\", [](const Request &, Response &res) {\n    res.set_content(\"Hello 2\", \"text/plain\");\n  });\n  svr.Put(\"/test3\", [](const Request &, Response &res) {\n    res.set_content(\"Hello 3\", \"text/plain\");\n  });\n  svr.Patch(\"/test4\", [](const Request &, Response &res) {\n    res.set_content(\"Hello 4\", \"text/plain\");\n  });\n  svr.set_logger([](const Request &req, const Response & ) {\n    for (const auto &x : req.headers) {\n      auto key = x.first;\n      EXPECT_STRNE(\"evil\", key.c_str());\n    }\n  });\n  auto thread = std::thread([&]() { svr.listen(HOST, PORT); });\n  auto se = detail::scope_exit([&] {\n    svr.stop();\n    thread.join();\n    ASSERT_FALSE(svr.is_running());\n  });\n  std::this_thread::sleep_for(std::chrono::seconds(1));\n  {\n    Client cli(HOST, PORT);\n    cli.Post(\"/test1\", \"A=B\",\n             \"application/x-www-form-urlencoded\\r\\nevil: hello1\");\n    cli.Delete(\"/test2\", \"A=B\", \"text/plain\\r\\nevil: hello2\");\n    cli.Put(\"/test3\", \"text\", \"text/plain\\r\\nevil: hello3\");\n    cli.Patch(\"/test4\", \"content\", \"text/plain\\r\\nevil: hello4\");\n  }\n}", "target": 0}
{"code": "void PDFiumEngine::Form_DoGoToAction(FPDF_FORMFILLINFO* param,\n                                     int page_index,\n                                     int zoom_mode,\n                                     float* position_array,\n                                     int size_of_array) {\n  PDFiumEngine* engine = static_cast<PDFiumEngine*>(param);\n  engine->ScrollToPage(page_index);\n}", "target": 0}
{"code": "static int target_xcopy_locate_se_dev_e4(const unsigned char *dev_wwn,\n\t\t\t\t\tstruct se_device **found_dev)\n{\n\tstruct xcopy_dev_search_info info;\n\tint ret;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.dev_wwn = dev_wwn;\n\tret = target_for_each_device(target_xcopy_locate_se_dev_e4_iter, &info);\n\tif (ret == 1) {\n\t\t*found_dev = info.found_dev;\n\t\treturn 0;\n\t} else {\n\t\tpr_debug_ratelimited(\"Unable to locate 0xe4 descriptor for EXTENDED_COPY\\n\");\n\t\treturn -EINVAL;\n\t}\n}", "target": 1}
{"code": "static int snd_ctl_elem_user_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tint change;\n\tstruct user_element *ue = kcontrol->private_data;\n\tchange = memcmp(&ucontrol->value, ue->elem_data, ue->elem_data_size) != 0;\n\tif (change)\n\t\tmemcpy(ue->elem_data, &ucontrol->value, ue->elem_data_size);\n\treturn change;\n}", "target": 1}
{"code": "static inline void encode_openhdr(struct xdr_stream *xdr, const struct nfs_openargs *arg)\n{\n\t__be32 *p;\n\tRESERVE_SPACE(8);\n\tWRITE32(OP_OPEN);\n\tWRITE32(arg->seqid->sequence->counter);\n\tencode_share_access(xdr, arg->open_flags);\n\tRESERVE_SPACE(28);\n\tWRITE64(arg->clientid);\n\tWRITE32(16);\n\tWRITEMEM(\"open id:\", 8);\n\tWRITE64(arg->id);\n}", "target": 1}
{"code": "    PreviewProperties LoaderExifJpeg::getProperties() const\n    {\n        PreviewProperties prop = Loader::getProperties();\n        prop.mimeType_ = \"image/jpeg\";\n        prop.extension_ = \".jpg\";\n#ifdef EXV_UNICODE_PATH\n        prop.wextension_ = EXV_WIDEN(\".jpg\");\n#endif\n        return prop;\n    }", "target": 0}
{"code": "jinit_merged_upsampler(j_decompress_ptr cinfo)\n{\n  my_upsample_ptr upsample;\n  upsample = (my_upsample_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(my_upsampler));\n  cinfo->upsample = (struct jpeg_upsampler *)upsample;\n  upsample->pub.start_pass = start_pass_merged_upsample;\n  upsample->pub.need_context_rows = FALSE;\n  upsample->out_row_width = cinfo->output_width * cinfo->out_color_components;\n  if (cinfo->max_v_samp_factor == 2) {\n    upsample->pub.upsample = merged_2v_upsample;\n    if (jsimd_can_h2v2_merged_upsample())\n      upsample->upmethod = jsimd_h2v2_merged_upsample;\n    else\n      upsample->upmethod = h2v2_merged_upsample;\n    if (cinfo->out_color_space == JCS_RGB565) {\n      if (cinfo->dither_mode != JDITHER_NONE) {\n        upsample->upmethod = h2v2_merged_upsample_565D;\n      } else {\n        upsample->upmethod = h2v2_merged_upsample_565;\n      }\n    }\n    upsample->spare_row = (JSAMPROW)\n      (*cinfo->mem->alloc_large) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                (size_t)(upsample->out_row_width * sizeof(JSAMPLE)));\n  } else {\n    upsample->pub.upsample = merged_1v_upsample;\n    if (jsimd_can_h2v1_merged_upsample())\n      upsample->upmethod = jsimd_h2v1_merged_upsample;\n    else\n      upsample->upmethod = h2v1_merged_upsample;\n    if (cinfo->out_color_space == JCS_RGB565) {\n      if (cinfo->dither_mode != JDITHER_NONE) {\n        upsample->upmethod = h2v1_merged_upsample_565D;\n      } else {\n        upsample->upmethod = h2v1_merged_upsample_565;\n      }\n    }\n    upsample->spare_row = NULL;\n  }\n  build_ycc_rgb_table(cinfo);\n}", "target": 1}
{"code": "static int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_rng rrng;\n\tsnprintf(rrng.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"rng\");\n\trrng.seedsize = alg->cra_rng.seedsize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_RNG,\n\t\t    sizeof(struct crypto_report_rng), &rrng))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "BOOL rdp_decrypt(rdpRdp* rdp, STREAM* s, int length, UINT16 securityFlags)\n{\n\tBYTE cmac[8];\n\tBYTE wmac[8];\n\tif (rdp->settings->EncryptionMethods == ENCRYPTION_METHOD_FIPS)\n\t{\n\t\tUINT16 len;\n\t\tBYTE version, pad;\n\t\tBYTE* sig;\n\t\tif (stream_get_left(s) < 12)\n\t\t\treturn FALSE;\n\t\tstream_read_UINT16(s, len); \n\t\tstream_read_BYTE(s, version); \n\t\tstream_read_BYTE(s, pad);\n\t\tsig = s->p;\n\t\tstream_seek(s, 8);\t\n\t\tlength -= 12;\n\t\tif (!security_fips_decrypt(s->p, length, rdp))\n\t\t{\n\t\t\tprintf(\"FATAL: cannot decrypt\\n\");\n\t\t\treturn FALSE; \n\t\t}\n\t\tif (!security_fips_check_signature(s->p, length - pad, sig, rdp))\n\t\t{\n\t\t\tprintf(\"FATAL: invalid packet signature\\n\");\n\t\t\treturn FALSE; \n\t\t}\n\t\ts->size -= pad;\n\t\treturn TRUE;\n\t}\n\tif (stream_get_left(s) < 8)\n\t\treturn FALSE;\n\tstream_read(s, wmac, sizeof(wmac));\n\tlength -= sizeof(wmac);\n\tsecurity_decrypt(s->p, length, rdp);\n\tif (securityFlags & SEC_SECURE_CHECKSUM)\n\t\tsecurity_salted_mac_signature(rdp, s->p, length, FALSE, cmac);\n\telse\n\t\tsecurity_mac_signature(rdp, s->p, length, cmac);\n\tif (memcmp(wmac, cmac, sizeof(wmac)) != 0)\n\t{\n\t\tprintf(\"WARNING: invalid packet signature\\n\");\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "static void bq24190_remove(struct i2c_client *client)\n{\n\tstruct bq24190_dev_info *bdi = i2c_get_clientdata(client);\n\tint error;\n\tcancel_delayed_work_sync(&bdi->input_current_limit_work);\n\terror = pm_runtime_resume_and_get(bdi->dev);\n\tif (error < 0)\n\t\tdev_warn(bdi->dev, \"pm_runtime_get failed: %i\\n\", error);\n\tbq24190_register_reset(bdi);\n\tif (bdi->battery)\n\t\tpower_supply_unregister(bdi->battery);\n\tpower_supply_unregister(bdi->charger);\n\tif (error >= 0)\n\t\tpm_runtime_put_sync(bdi->dev);\n\tpm_runtime_dont_use_autosuspend(bdi->dev);\n\tpm_runtime_disable(bdi->dev);\n}", "target": 0}
{"code": "static unsigned long mb2_cache_scan(struct shrinker *shrink,\n\t\t\t\t    struct shrink_control *sc)\n{\n\tint nr_to_scan = sc->nr_to_scan;\n\tstruct mb2_cache *cache = container_of(shrink, struct mb2_cache,\n\t\t\t\t\t      c_shrink);\n\tstruct mb2_cache_entry *entry;\n\tstruct hlist_bl_head *head;\n\tunsigned int shrunk = 0;\n\tspin_lock(&cache->c_lru_list_lock);\n\twhile (nr_to_scan-- && !list_empty(&cache->c_lru_list)) {\n\t\tentry = list_first_entry(&cache->c_lru_list,\n\t\t\t\t\t struct mb2_cache_entry, e_lru_list);\n\t\tlist_del_init(&entry->e_lru_list);\n\t\tcache->c_entry_count--;\n\t\tspin_unlock(&cache->c_lru_list_lock);\n\t\thead = entry->e_hash_list_head;\n\t\thlist_bl_lock(head);\n\t\tif (!hlist_bl_unhashed(&entry->e_hash_list)) {\n\t\t\thlist_bl_del_init(&entry->e_hash_list);\n\t\t\tatomic_dec(&entry->e_refcnt);\n\t\t}\n\t\thlist_bl_unlock(head);\n\t\tif (mb2_cache_entry_put(cache, entry))\n\t\t\tshrunk++;\n\t\tcond_resched();\n\t\tspin_lock(&cache->c_lru_list_lock);\n\t}\n\tspin_unlock(&cache->c_lru_list_lock);\n\treturn shrunk;\n}", "target": 0}
{"code": "int tpm_open(struct inode *inode, struct file *file)\n{\n\tint minor = iminor(inode);\n\tstruct tpm_chip *chip = NULL, *pos;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pos, &tpm_chip_list, list) {\n\t\tif (pos->vendor.miscdev.minor == minor) {\n\t\t\tchip = pos;\n\t\t\tget_device(chip->dev);\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (!chip)\n\t\treturn -ENODEV;\n\tif (test_and_set_bit(0, &chip->is_open)) {\n\t\tdev_dbg(chip->dev, \"Another process owns this TPM\\n\");\n\t\tput_device(chip->dev);\n\t\treturn -EBUSY;\n\t}\n\tchip->data_buffer = kmalloc(TPM_BUFSIZE * sizeof(u8), GFP_KERNEL);\n\tif (chip->data_buffer == NULL) {\n\t\tclear_bit(0, &chip->is_open);\n\t\tput_device(chip->dev);\n\t\treturn -ENOMEM;\n\t}\n\tatomic_set(&chip->data_pending, 0);\n\tfile->private_data = chip;\n\treturn 0;\n}", "target": 1}
{"code": "void MainWindow::showUpgradePrompt()\n{\n    if (Settings.checkUpgradeAutomatic()) {\n        showStatusMessage(\"Checking for upgrade...\");\n        QNetworkRequest request(QUrl(\"https:\n        QSslConfiguration sslConfig = request.sslConfiguration();\n        sslConfig.setPeerVerifyMode(QSslSocket::VerifyNone);\n        request.setSslConfiguration(sslConfig);\n        m_network.get(request);\n    } else {\n        m_network.setStrictTransportSecurityEnabled(false);\n        QAction* action = new QAction(tr(\"Click here to check for a new version of Shotcut.\"), 0);\n        connect(action, SIGNAL(triggered(bool)), SLOT(on_actionUpgrade_triggered()));\n        showStatusMessage(action, 15 );\n    }\n}", "target": 1}
{"code": "static int do_i2c_mw(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t     char *const argv[])\n{\n\tuint\tchip;\n\tulong\taddr;\n\tint\talen;\n\tuchar\tbyte;\n\tint\tcount;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\tif ((argc < 4) || (argc > 5))\n\t\treturn CMD_RET_USAGE;\n\tchip = hextoul(argv[1], NULL);\n\taddr = hextoul(argv[2], NULL);\n\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn CMD_RET_USAGE;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n#endif\n\tbyte = hextoul(argv[3], NULL);\n\tif (argc == 5)\n\t\tcount = hextoul(argv[4], NULL);\n\telse\n\t\tcount = 1;\n\twhile (count-- > 0) {\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_write(dev, addr++, &byte, 1);\n#else\n\t\tret = i2c_write(chip, addr++, alen, &byte, 1);\n#endif\n\t\tif (ret)\n\t\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n#if !defined(CONFIG_SYS_I2C_FRAM)\n\t\tudelay(11000);\n#endif\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int __init mbochs_dev_init(void)\n{\n\tint ret = 0;\n\tatomic_set(&mbochs_avail_mbytes, max_mbytes);\n\tret = alloc_chrdev_region(&mbochs_devt, 0, MINORMASK + 1, MBOCHS_NAME);\n\tif (ret < 0) {\n\t\tpr_err(\"Error: failed to register mbochs_dev, err: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tcdev_init(&mbochs_cdev, &vd_fops);\n\tcdev_add(&mbochs_cdev, mbochs_devt, MINORMASK + 1);\n\tpr_info(\"%s: major %d\\n\", __func__, MAJOR(mbochs_devt));\n\tret = mdev_register_driver(&mbochs_driver);\n\tif (ret)\n\t\tgoto err_cdev;\n\tmbochs_class = class_create(THIS_MODULE, MBOCHS_CLASS_NAME);\n\tif (IS_ERR(mbochs_class)) {\n\t\tpr_err(\"Error: failed to register mbochs_dev class\\n\");\n\t\tret = PTR_ERR(mbochs_class);\n\t\tgoto err_driver;\n\t}\n\tmbochs_dev.class = mbochs_class;\n\tmbochs_dev.release = mbochs_device_release;\n\tdev_set_name(&mbochs_dev, \"%s\", MBOCHS_NAME);\n\tret = device_register(&mbochs_dev);\n\tif (ret)\n\t\tgoto err_class;\n\tret = mdev_register_device(&mbochs_dev, &mdev_fops);\n\tif (ret)\n\t\tgoto err_device;\n\treturn 0;\nerr_device:\n\tdevice_unregister(&mbochs_dev);\nerr_class:\n\tclass_destroy(mbochs_class);\nerr_driver:\n\tmdev_unregister_driver(&mbochs_driver);\nerr_cdev:\n\tcdev_del(&mbochs_cdev);\n\tunregister_chrdev_region(mbochs_devt, MINORMASK + 1);\n\treturn ret;\n}", "target": 0}
{"code": "bool __fastcall TSiteRawDialog::Execute(TSessionData * Data)\n{\n  std::unique_ptr<TSessionData> FactoryDefaults(new TSessionData(L\"\"));\n  std::unique_ptr<TSessionData> RawData(new TSessionData(L\"\"));\n  RawData->Assign(Data);\n  if (RawData->FSProtocol != fsSFTPonly)\n  {\n    RawData->FSProtocol = FactoryDefaults->FSProtocol;\n  }\n  RawData->HostName = FactoryDefaults->HostName;\n  RawData->PortNumber = FactoryDefaults->PortNumber;\n  RawData->UserName = FactoryDefaults->UserName;\n  RawData->Password = FactoryDefaults->Password;\n  RawData->Ftps = FactoryDefaults->Ftps;\n  std::unique_ptr<TStrings> Options(RawData->SaveToOptions(FactoryDefaults.get(), false, false));\n  SettingsMemo->Lines = Options.get();\n  bool Result = TCustomDialog::Execute();\n  if (Result)\n  {\n    std::unique_ptr<TSessionData> BackupData(new TSessionData(L\"\"));\n    BackupData->Assign(Data);\n    Data->DefaultSettings();\n    Data->FSProtocol = BackupData->FSProtocol;\n    Data->HostName = BackupData->HostName;\n    Data->PortNumber = BackupData->PortNumber;\n    Data->UserName = BackupData->UserName;\n    Data->Password = BackupData->Password;\n    Data->Ftps = BackupData->Ftps;\n    Data->ApplyRawSettings(SettingsMemo->Lines);\n  }\n  return Result;\n}", "target": 1}
{"code": "PHP_FUNCTION(mb_regex_encoding)\n{\n\tsize_t argc = ZEND_NUM_ARGS();\n\tchar *encoding;\n\tint encoding_len;\n\tOnigEncoding mbctype;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|s\", &encoding, &encoding_len) == FAILURE) {\n\t\treturn;\n\t}\n\tif (argc == 0) {\n\t\tconst char *retval = _php_mb_regex_mbctype2name(MBREX(current_mbctype));\n\t\tif (retval == NULL) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tRETURN_STRING((char *)retval, 1);\n\t} else if (argc == 1) {\n\t\tmbctype = _php_mb_regex_name2mbctype(encoding);\n\t\tif (mbctype == ONIG_ENCODING_UNDEF) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown encoding \\\"%s\\\"\", encoding);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tMBREX(current_mbctype) = mbctype;\n\t\tRETURN_TRUE;\n\t}\n}", "target": 0}
{"code": "bool GTextFieldIsEmpty(GGadget *g) {\n    GTextField *gt = (GTextField *) g;\n    return gt->text == NULL || *gt->text == '\\0';\n}", "target": 0}
{"code": "runas_grouplist_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct member_list *group_list, struct member **matching_group)\n{\n    const struct sudoers_context *ctx = parse_tree->ctx;\n    int group_matched = UNSPEC;\n    struct member *m;\n    struct alias *a;\n    debug_decl(runas_grouplist_matches, SUDOERS_DEBUG_MATCH);\n    if (group_list != NULL) {\n\tTAILQ_FOREACH_REVERSE(m, group_list, member_list, entries) {\n\t    switch (m->type) {\n\t\tcase ALL:\n\t\t    group_matched = m->negated ? DENY : ALLOW;\n\t\t    break;\n\t\tcase ALIAS:\n\t\t    a = alias_get(parse_tree, m->name, RUNASALIAS);\n\t\t    if (a != NULL) {\n\t\t\tconst int rc = runas_grouplist_matches(parse_tree,\n\t\t\t    &a->members, matching_group);\n\t\t\tif (rc != UNSPEC) {\n\t\t\t    if (m->negated) {\n\t\t\t\tgroup_matched = rc == ALLOW ? DENY : ALLOW;\n\t\t\t    } else {\n\t\t\t\tgroup_matched = rc;\n\t\t\t    }\n\t\t\t}\n\t\t\talias_put(a);\n\t\t\tbreak;\n\t\t    }\n\t\t    FALLTHROUGH;\n\t\tcase WORD:\n\t\t    if (group_matches(m->name, ctx->runas.gr))\n\t\t\tgroup_matched = m->negated ? DENY : ALLOW;\n\t\t    break;\n\t    }\n\t    if (group_matched != UNSPEC) {\n\t\tif (matching_group != NULL && m->type != ALIAS)\n\t\t    *matching_group = m;\n\t\tbreak;\n\t    }\n\t}\n    }\n    if (group_matched == UNSPEC) {\n\tstruct gid_list *runas_groups;\n\tif (ctx->runas.pw->pw_gid == ctx->runas.gr->gr_gid) {\n\t    group_matched = ALLOW;\t\n\t} else if ((runas_groups = runas_getgroups(ctx)) != NULL) {\n\t    int i;\n\t    for (i = 0; i < runas_groups->ngids; i++) {\n\t\tif (runas_groups->gids[i] == ctx->runas.gr->gr_gid) {\n\t\t    group_matched = ALLOW;\t\n\t\t    break;\n\t\t}\n\t    }\n\t    sudo_gidlist_delref(runas_groups);\n\t}\n    }\n    debug_return_int(group_matched);\n}", "target": 1}
{"code": "pipe_iov_copy_from_user(void *to, struct iovec *iov, unsigned long len,\n\t\t\tint atomic)\n{\n\tunsigned long copy;\n\twhile (len > 0) {\n\t\twhile (!iov->iov_len)\n\t\t\tiov++;\n\t\tcopy = min_t(unsigned long, len, iov->iov_len);\n\t\tif (atomic) {\n\t\t\tif (__copy_from_user_inatomic(to, iov->iov_base, copy))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\tif (copy_from_user(to, iov->iov_base, copy))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t\tto += copy;\n\t\tlen -= copy;\n\t\tiov->iov_base += copy;\n\t\tiov->iov_len -= copy;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int ext4_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t    loff_t pos, unsigned len, unsigned flags,\n\t\t\t    struct page **pagep, void **fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tint ret, needed_blocks;\n\thandle_t *handle;\n\tint retries = 0;\n\tstruct page *page;\n\tpgoff_t index;\n\tunsigned from, to;\n\ttrace_ext4_write_begin(inode, pos, len, flags);\n\tneeded_blocks = ext4_writepage_trans_blocks(inode) + 1;\n\tindex = pos >> PAGE_CACHE_SHIFT;\n\tfrom = pos & (PAGE_CACHE_SIZE - 1);\n\tto = from + len;\nretry:\n\thandle = ext4_journal_start(inode, needed_blocks);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\tflags |= AOP_FLAG_NOFS;\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page) {\n\t\text4_journal_stop(handle);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\t*pagep = page;\n\tret = block_write_begin(file, mapping, pos, len, flags, pagep, fsdata,\n\t\t\t\text4_get_block);\n\tif (!ret && ext4_should_journal_data(inode)) {\n\t\tret = walk_page_buffers(handle, page_buffers(page),\n\t\t\t\tfrom, to, NULL, do_journal_get_write_access);\n\t}\n\tif (ret) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (pos + len > inode->i_size && ext4_can_truncate(inode))\n\t\t\text4_orphan_add(handle, inode);\n\t\text4_journal_stop(handle);\n\t\tif (pos + len > inode->i_size) {\n\t\t\text4_truncate_failed_write(inode);\n\t\t\tif (inode->i_nlink)\n\t\t\t\text4_orphan_del(NULL, inode);\n\t\t}\n\t}\n\tif (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\tgoto retry;\nout:\n\treturn ret;\n}", "target": 1}
{"code": "long video_ioctl2(struct file *file,\n\t       unsigned int cmd, unsigned long arg)\n{\n\tchar\tsbuf[128];\n\tvoid    *mbuf = NULL;\n\tvoid\t*parg = (void *)arg;\n\tlong\terr  = -EINVAL;\n\tbool\thas_array_args;\n\tsize_t  array_size = 0;\n\tvoid __user *user_ptr = NULL;\n\tvoid\t**kernel_ptr = NULL;\n\tif (_IOC_DIR(cmd) != _IOC_NONE) {\n\t\tif (_IOC_SIZE(cmd) <= sizeof(sbuf)) {\n\t\t\tparg = sbuf;\n\t\t} else {\n\t\t\tmbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);\n\t\t\tif (NULL == mbuf)\n\t\t\t\treturn -ENOMEM;\n\t\t\tparg = mbuf;\n\t\t}\n\t\terr = -EFAULT;\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\t\tunsigned long n = cmd_input_size(cmd);\n\t\t\tif (copy_from_user(parg, (void __user *)arg, n))\n\t\t\t\tgoto out;\n\t\t\tif (n < _IOC_SIZE(cmd))\n\t\t\t\tmemset((u8 *)parg + n, 0, _IOC_SIZE(cmd) - n);\n\t\t} else {\n\t\t\tmemset(parg, 0, _IOC_SIZE(cmd));\n\t\t}\n\t}\n\terr = check_array_args(cmd, parg, &array_size, &user_ptr, &kernel_ptr);\n\tif (err < 0)\n\t\tgoto out;\n\thas_array_args = err;\n\tif (has_array_args) {\n\t\tmbuf = kmalloc(array_size, GFP_KERNEL);\n\t\terr = -ENOMEM;\n\t\tif (NULL == mbuf)\n\t\t\tgoto out_array_args;\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(mbuf, user_ptr, array_size))\n\t\t\tgoto out_array_args;\n\t\t*kernel_ptr = mbuf;\n\t}\n\terr = __video_do_ioctl(file, cmd, parg);\n\tif (err == -ENOIOCTLCMD)\n\t\terr = -EINVAL;\n\tif (has_array_args) {\n\t\t*kernel_ptr = user_ptr;\n\t\tif (copy_to_user(user_ptr, mbuf, array_size))\n\t\t\terr = -EFAULT;\n\t\tgoto out_array_args;\n\t}\n\tif (err < 0)\n\t\tgoto out;\nout_array_args:\n\tswitch (_IOC_DIR(cmd)) {\n\tcase _IOC_READ:\n\tcase (_IOC_WRITE | _IOC_READ):\n\t\tif (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\t}\nout:\n\tkfree(mbuf);\n\treturn err;\n}", "target": 1}
{"code": "static void __pam_log(const pam_handle_t *pamh, int ctrl, int err, const char *format, ...)\n{\n\tva_list args;\n\tif (_pam_log_is_silent(ctrl)) {\n\t\treturn;\n\t}\n\tva_start(args, format);\n\t_pam_log_int(pamh, err, format, args);\n\tva_end(args);\n}", "target": 0}
{"code": "PHP_FUNCTION(pg_field_type_oid)\n{\n\tphp_pgsql_get_field_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_FIELD_TYPE_OID);\n}", "target": 0}
{"code": "int propagate_mnt(struct mount *dest_mnt, struct mountpoint *dest_mp,\n\t\t    struct mount *source_mnt, struct hlist_head *tree_list)\n{\n\tstruct mount *m, *n;\n\tint ret = 0;\n\tuser_ns = current->nsproxy->mnt_ns->user_ns;\n\tlast_dest = dest_mnt;\n\tfirst_source = source_mnt;\n\tlast_source = source_mnt;\n\tmp = dest_mp;\n\tlist = tree_list;\n\tdest_master = dest_mnt->mnt_master;\n\tfor (n = next_peer(dest_mnt); n != dest_mnt; n = next_peer(n)) {\n\t\tret = propagate_one(n);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tfor (m = next_group(dest_mnt, dest_mnt); m;\n\t\t\tm = next_group(m, dest_mnt)) {\n\t\tn = m;\n\t\tdo {\n\t\t\tret = propagate_one(n);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tn = next_peer(n);\n\t\t} while (n != m);\n\t}\nout:\n\tread_seqlock_excl(&mount_lock);\n\thlist_for_each_entry(n, tree_list, mnt_hash) {\n\t\tm = n->mnt_parent;\n\t\tif (m->mnt_master != dest_mnt->mnt_master)\n\t\t\tCLEAR_MNT_MARK(m->mnt_master);\n\t}\n\tread_sequnlock_excl(&mount_lock);\n\treturn ret;\n}", "target": 0}
{"code": "static void nvme_zone_reset_cancel(BlockAIOCB *aiocb)\n{\n    NvmeZoneResetAIOCB *iocb = container_of(aiocb, NvmeZoneResetAIOCB, common);\n    NvmeRequest *req = iocb->req;\n    NvmeNamespace *ns = req->ns;\n    iocb->idx = ns->num_zones;\n    iocb->ret = -ECANCELED;\n    if (iocb->aiocb) {\n        blk_aio_cancel_async(iocb->aiocb);\n        iocb->aiocb = NULL;\n    }\n}", "target": 0}
{"code": "inline bool loadModule(const char* filename, IR::Module& outModule)\n{\n\tstd::vector<U8> fileBytes;\n\tif(!loadFile(filename, fileBytes)) { return false; }\n\tif(*(U32*)fileBytes.data() == 0x6d736100)\n\t{ return loadBinaryModule(fileBytes.data(), fileBytes.size(), outModule); }\n\telse\n\t{\n\t\tfileBytes.push_back(0);\n\t\tstd::vector<WAST::Error> parseErrors;\n\t\tif(!WAST::parseModule(\n\t\t\t   (const char*)fileBytes.data(), fileBytes.size(), outModule, parseErrors))\n\t\t{\n\t\t\tLog::printf(Log::error, \"Error parsing WebAssembly text file:\\n\");\n\t\t\treportParseErrors(filename, parseErrors);\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}", "target": 1}
{"code": "struct chunk *error_message(struct session *s, int msgnum)\n{\n\tif (s->be->errmsg[msgnum].str)\n\t\treturn &s->be->errmsg[msgnum];\n\telse if (s->fe->errmsg[msgnum].str)\n\t\treturn &s->fe->errmsg[msgnum];\n\telse\n\t\treturn &http_err_chunks[msgnum];\n}", "target": 0}
{"code": "clamp_lab(const fz_colorspace *cs, const float *src, float *dst)\n{\n\tint i;\n\tfor (i = 0; i < 3; i++)\n\t\tdst[i] = fz_clamp(src[i], i ? -128 : 0, i ? 127 : 100);\n}", "target": 0}
{"code": "static int __init disable_acpi_irq(struct dmi_system_id *d)\n{\n\tif (!acpi_force) {\n\t\tprintk(KERN_NOTICE \"%s detected: force use of acpi=noirq\\n\",\n\t\t       d->ident);\n\t\tacpi_noirq_set();\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "BGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageWebpCtx(im, out, -1);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}", "target": 1}
{"code": "int acpi_register_debugger(struct module *owner,\n\t\t\t   const struct acpi_debugger_ops *ops)\n{\n\tint ret = 0;\n\tmutex_lock(&acpi_debugger.lock);\n\tif (acpi_debugger.ops) {\n\t\tret = -EBUSY;\n\t\tgoto err_lock;\n\t}\n\tacpi_debugger.owner = owner;\n\tacpi_debugger.ops = ops;\nerr_lock:\n\tmutex_unlock(&acpi_debugger.lock);\n\treturn ret;\n}", "target": 0}
{"code": "static void add_offer_options(uint8_t *option_start_address)\n{\n\tuint8_t *temp_option_addr;\n\ttemp_option_addr = fill_one_option_content(option_start_address,\n\t\t\tDHCP_OPTION_CODE_SUBNET_MASK, DHCP_OPTION_LENGTH_FOUR,\n\t\t\t\t\t(void *)&dhcps_local_mask);\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\t\tDHCP_OPTION_CODE_ROUTER, DHCP_OPTION_LENGTH_FOUR,\n\t\t\t\t\t(void *)&dhcps_local_address);\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\t\tDHCP_OPTION_CODE_DNS_SERVER, DHCP_OPTION_LENGTH_FOUR,\n\t\t\t\t\t(void *)&dhcps_local_address);\t\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\t\tDHCP_OPTION_CODE_LEASE_TIME, DHCP_OPTION_LENGTH_FOUR,\n\t\t\t\t\t(void *)&dhcp_option_lease_time);\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\t\tDHCP_OPTION_CODE_SERVER_ID, DHCP_OPTION_LENGTH_FOUR,\n\t\t\t\t(void *)&dhcps_local_address);\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\tDHCP_OPTION_CODE_BROADCAST_ADDRESS, DHCP_OPTION_LENGTH_FOUR,\n\t\t\t\t(void *)&dhcps_subnet_broadcast);\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\tDHCP_OPTION_CODE_INTERFACE_MTU, DHCP_OPTION_LENGTH_TWO,\n\t\t\t\t\t(void *) &dhcp_option_interface_mtu);\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\tDHCP_OPTION_CODE_PERFORM_ROUTER_DISCOVERY, DHCP_OPTION_LENGTH_ONE,\n\t\t\t\t\t\t\t\tNULL);\n\t*temp_option_addr++ = DHCP_OPTION_CODE_END;\n}", "target": 1}
{"code": "void client_reset(t_client *client)\n{\n\tchar *hash;\n\tchar *msg;\n\tchar *cidinfo;\n\tdebug(LOG_DEBUG, \"Resetting client [%s]\", client->mac);\n\tclient->counters.incoming = 0;\n\tclient->counters.outgoing = 0;\n\tclient->counters.last_updated = time(NULL);\n\tclient->session_start = 0;\n\tclient->session_end = 0;\n\thash = safe_calloc(STATUS_BUF);\n\tclient->token = safe_calloc(STATUS_BUF);\n\tsafe_snprintf(client->token, STATUS_BUF, \"%04hx%04hx\", rand16(), rand16());\n\thash_str(hash, STATUS_BUF, client->token);\n\tclient->hid = safe_strdup(hash);\n\tfree(hash);\n\tclient->custom = safe_calloc(MID_BUF);\n\tclient->client_type = safe_calloc(STATUS_BUF);\n\tif (client->cid) {\n\t\tif (strlen(client->cid) > 0) {\n\t\t\tmsg = safe_calloc(SMALL_BUF);\n\t\t\tcidinfo = safe_calloc(MID_BUF);\n\t\t\tsafe_snprintf(cidinfo, MID_BUF, \"cid=\\\"%s\\\"\", client->cid);\n\t\t\twrite_client_info(msg, SMALL_BUF, \"rmcid\", client->cid, cidinfo);\n\t\t\tfree(msg);\n\t\t\tfree(cidinfo);\n\t\t}\n\t\tclient->cid = safe_calloc(SMALL_BUF);\n\t}\n}", "target": 1}
{"code": "static void nested_vmx_failInvalid(struct kvm_vcpu *vcpu)\n{\n\tvmx_set_rflags(vcpu, (vmx_get_rflags(vcpu)\n\t\t\t& ~(X86_EFLAGS_PF | X86_EFLAGS_AF | X86_EFLAGS_ZF |\n\t\t\t    X86_EFLAGS_SF | X86_EFLAGS_OF))\n\t\t\t| X86_EFLAGS_CF);\n}", "target": 0}
{"code": "l2tp_call_errors_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tuint16_t val_h, val_l;\n\tptr++;\t\t\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"CRCErr=%u \", (val_h<<16) + val_l));\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"FrameErr=%u \", (val_h<<16) + val_l));\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"HardOver=%u \", (val_h<<16) + val_l));\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"BufOver=%u \", (val_h<<16) + val_l));\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"Timeout=%u \", (val_h<<16) + val_l));\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"AlignErr=%u \", (val_h<<16) + val_l));\n}", "target": 1}
{"code": "TEST_F(ExtractorTest, TestDefaultHeaderLocation) {\n  auto headers = TestRequestHeaderMapImpl{{\"Authorization\", \"Bearer jwt_token\"}};\n  auto tokens = extractor_->extract(headers);\n  EXPECT_EQ(tokens.size(), 1);\n  EXPECT_EQ(tokens[0]->token(), \"jwt_token\");\n  EXPECT_TRUE(tokens[0]->isIssuerSpecified(\"issuer1\"));\n  EXPECT_FALSE(tokens[0]->isIssuerSpecified(\"issuer2\"));\n  EXPECT_FALSE(tokens[0]->isIssuerSpecified(\"issuer3\"));\n  EXPECT_FALSE(tokens[0]->isIssuerSpecified(\"issuer4\"));\n  EXPECT_FALSE(tokens[0]->isIssuerSpecified(\"issuer5\"));\n  EXPECT_FALSE(tokens[0]->isIssuerSpecified(\"unknown_issuer\"));\n  tokens[0]->removeJwt(headers);\n  EXPECT_FALSE(headers.has(Http::CustomHeaders::get().Authorization));\n}", "target": 0}
{"code": "unsigned long get_zeroed_page(gfp_t gfp_mask)\n{\n\treturn __get_free_pages(gfp_mask | __GFP_ZERO, 0);\n}", "target": 0}
{"code": "bool Browser::CanCloseWithInProgressDownloads() {\n  if (cancel_download_confirmation_state_ != NOT_PROMPTED)\n    return cancel_download_confirmation_state_ != WAITING_FOR_RESPONSE;\n  int num_downloads_blocking;\n  Browser::DownloadClosePreventionType dialog_type =\n      OkToCloseWithInProgressDownloads(&num_downloads_blocking);\n  if (dialog_type == DOWNLOAD_CLOSE_OK)\n    return true;\n  cancel_download_confirmation_state_ = WAITING_FOR_RESPONSE;\n  window_->ConfirmBrowserCloseWithPendingDownloads(\n      num_downloads_blocking,\n      dialog_type,\n      false,\n      base::Bind(&Browser::InProgressDownloadResponse,\n                 weak_factory_.GetWeakPtr()));\n  return false;\n}", "target": 0}
{"code": "  void writeSuccess() noexcept override {}", "target": 0}
{"code": "int stringmatchlen(const char *pattern, int patternLen,\n        const char *string, int stringLen, int nocase) {\n    int skipLongerMatches = 0;\n    return stringmatchlen_impl(pattern,patternLen,string,stringLen,nocase,&skipLongerMatches,0);\n}", "target": 0}
{"code": "mp_obj_t mp_vfs_umount(mp_obj_t mnt_in) {\n    mp_vfs_mount_t *vfs = NULL;\n    size_t mnt_len;\n    const char *mnt_str = NULL;\n    if (mp_obj_is_str(mnt_in)) {\n        mnt_str = mp_obj_str_get_data(mnt_in, &mnt_len);\n    }\n    for (mp_vfs_mount_t **vfsp = &MP_STATE_VM(vfs_mount_table); *vfsp != NULL; vfsp = &(*vfsp)->next) {\n        if ((mnt_str != NULL && !memcmp(mnt_str, (*vfsp)->str, mnt_len + 1)) || (*vfsp)->obj == mnt_in) {\n            vfs = *vfsp;\n            *vfsp = (*vfsp)->next;\n            break;\n        }\n    }\n    if (vfs == NULL) {\n        mp_raise_OSError(MP_EINVAL);\n    }\n    if (MP_STATE_VM(vfs_cur) == vfs) {\n        MP_STATE_VM(vfs_cur) = MP_VFS_ROOT;\n    }\n    mp_vfs_proxy_call(vfs, MP_QSTR_umount, 0, NULL);\n    return mp_const_none;\n}", "target": 1}
{"code": "sf_open\t(const char *path, int mode, SF_INFO *sfinfo)\n{\tSF_PRIVATE \t*psf ;\n\tassert (sizeof (sf_count_t) == 8) ;\n\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\tpsf_init_files (psf) ;\n\tpsf_log_printf (psf, \"File : %s\\n\", path) ;\n\tif (copy_filename (psf, path) != 0)\n\t{\tsf_errno = psf->error ;\n\t\treturn\tNULL ;\n\t\t} ;\n\tpsf->file.mode = mode ;\n\tif (strcmp (path, \"-\") == 0)\n\t\tpsf->error = psf_set_stdio (psf) ;\n\telse\n\t\tpsf->error = psf_fopen (psf) ;\n\treturn psf_open_file (psf, sfinfo) ;\n} ", "target": 1}
{"code": "static BYTE get_cbr2_bpp(UINT32 bpp, BOOL* pValid)\n{\n\tif (pValid)\n\t\t*pValid = TRUE;\n\tswitch (bpp)\n\t{\n\t\tcase 3:\n\t\t\treturn 8;\n\t\tcase 4:\n\t\t\treturn 16;\n\t\tcase 5:\n\t\t\treturn 24;\n\t\tcase 6:\n\t\t\treturn 32;\n\t\tdefault:\n\t\t\tWLog_WARN(TAG, \"Invalid bpp %\" PRIu32, bpp);\n\t\t\tif (pValid)\n\t\t\t\t*pValid = FALSE;\n\t\t\treturn 0;\n\t}\n}", "target": 0}
{"code": "static int em_grp45(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc = X86EMUL_CONTINUE;\n\tswitch (ctxt->modrm_reg) {\n\tcase 2:  {\n\t\tlong int old_eip;\n\t\told_eip = ctxt->_eip;\n\t\tctxt->_eip = ctxt->src.val;\n\t\tctxt->src.val = old_eip;\n\t\trc = em_push(ctxt);\n\t\tbreak;\n\t}\n\tcase 4: \n\t\tctxt->_eip = ctxt->src.val;\n\t\tbreak;\n\tcase 5: \n\t\trc = em_jmp_far(ctxt);\n\t\tbreak;\n\tcase 6:\t\n\t\trc = em_push(ctxt);\n\t\tbreak;\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "cmnd_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct member *m, const char *runchroot, struct cmnd_info *info)\n{\n    struct alias *a;\n    struct sudo_command *c;\n    int rc, matched = UNSPEC;\n    debug_decl(cmnd_matches, SUDOERS_DEBUG_MATCH);\n    switch (m->type) {\n\tcase ALL:\n\tcase COMMAND:\n\t    c = (struct sudo_command *)m->name;\n\t    if (command_matches(parse_tree->ctx, c->cmnd, c->args, runchroot,\n\t\t    info, &c->digests))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase ALIAS:\n\t    a = alias_get(parse_tree, m->name, CMNDALIAS);\n\t    if (a != NULL) {\n\t\trc = cmndlist_matches(parse_tree, &a->members, runchroot, info);\n\t\tif (rc != UNSPEC) {\n\t\t    if (m->negated) {\n\t\t\tmatched = rc == ALLOW ? DENY : ALLOW;\n\t\t    } else {\n\t\t\tmatched = rc;\n\t\t    }\n\t\t}\n\t\talias_put(a);\n\t    }\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 1}
{"code": "static int rm_rf_inner_child(\n                int fd,\n                const char *fname,\n                int is_dir,\n                RemoveFlags flags,\n                const struct stat *root_dev,\n                bool allow_recursion) {\n        struct stat st;\n        int r, q = 0;\n        assert(fd >= 0);\n        assert(fname);\n        if (is_dir < 0 ||\n            root_dev ||\n            (is_dir > 0 && (root_dev || (flags & REMOVE_SUBVOLUME)))) {\n                r = fstatat_harder(fd, fname, &st, AT_SYMLINK_NOFOLLOW, flags);\n                if (r < 0)\n                        return r;\n                is_dir = S_ISDIR(st.st_mode);\n        }\n        if (is_dir) {\n                if (root_dev && st.st_dev != root_dev->st_dev)\n                        return 0;\n                r = fd_is_mount_point(fd, fname, 0);\n                if (r < 0)\n                        return r;\n                if (r > 0)\n                        return 0;\n                if ((flags & REMOVE_SUBVOLUME) && btrfs_might_be_subvol(&st)) {\n                        r = btrfs_subvol_remove_fd(fd, fname, BTRFS_REMOVE_RECURSIVE|BTRFS_REMOVE_QUOTA);\n                        if (r < 0) {\n                                if (!IN_SET(r, -ENOTTY, -EINVAL))\n                                        return r;\n                        } else\n                                return 1;\n                }\n                if (!allow_recursion)\n                        return -EISDIR;\n                int subdir_fd = openat(fd, fname, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);\n                if (subdir_fd < 0)\n                        return -errno;\n                q = rm_rf_children(subdir_fd, flags | REMOVE_PHYSICAL, root_dev);\n        } else if (flags & REMOVE_ONLY_DIRECTORIES)\n                return 0;\n        r = unlinkat_harder(fd, fname, is_dir ? AT_REMOVEDIR : 0, flags);\n        if (r < 0)\n                return r;\n        if (q < 0)\n                return q;\n        return 1;\n}", "target": 0}
{"code": "static void php_imagepolygon(INTERNAL_FUNCTION_PARAMETERS, int filled)\n{\n\tzval *IM, *POINTS;\n\tlong NPOINTS, COL;\n\tzval **var = NULL;\n\tgdImagePtr im;\n\tgdPointPtr points;\n\tint npoints, col, nelem, i;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rall\", &IM, &POINTS, &NPOINTS, &COL) == FAILURE) {\n\t\treturn;\n\t}\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tnpoints = NPOINTS;\n\tcol = COL;\n\tnelem = zend_hash_num_elements(Z_ARRVAL_P(POINTS));\n\tif (nelem < 6) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must have at least 3 points in your array\");\n\t\tRETURN_FALSE;\n\t}\n\tif (npoints <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must give a positive number of points\");\n\t\tRETURN_FALSE;\n\t}\n\tif (nelem < npoints * 2) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Trying to use %d points in array with only %d points\", npoints, nelem/2);\n\t\tRETURN_FALSE;\n\t}\n\tpoints = (gdPointPtr) safe_emalloc(npoints, sizeof(gdPoint), 0);\n\tfor (i = 0; i < npoints; i++) {\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2), (void **) &var) == SUCCESS) {\n\t\t\tSEPARATE_ZVAL((var));\n\t\t\tconvert_to_long(*var);\n\t\t\tpoints[i].x = Z_LVAL_PP(var);\n\t\t}\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2) + 1, (void **) &var) == SUCCESS) {\n\t\t\tSEPARATE_ZVAL(var);\n\t\t\tconvert_to_long(*var);\n\t\t\tpoints[i].y = Z_LVAL_PP(var);\n\t\t}\n\t}\n\tif (filled) {\n\t\tgdImageFilledPolygon(im, points, npoints, col);\n\t} else {\n\t\tgdImagePolygon(im, points, npoints, col);\n\t}\n\tefree(points);\n\tRETURN_TRUE;\n}", "target": 1}
{"code": "header_put_le_8byte (SF_PRIVATE *psf, sf_count_t x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)\n\t{\tpsf->header [psf->headindex++] = x ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\t} ;\n} ", "target": 1}
{"code": "GF_Err void_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tif (s->size) return GF_ISOM_INVALID_FILE;\n\treturn GF_OK;\n}", "target": 0}
{"code": "d_lite_next_day(int argc, VALUE *argv, VALUE self)\n{\n    VALUE n;\n    rb_scan_args(argc, argv, \"01\", &n);\n    if (argc < 1)\n\tn = INT2FIX(1);\n    return d_lite_plus(self, n);\n}", "target": 0}
{"code": "host_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct passwd *pw, const char *lhost, const char *shost,\n    const struct member *m)\n{\n    struct alias *a;\n    int matched = UNSPEC;\n    debug_decl(host_matches, SUDOERS_DEBUG_MATCH);\n    switch (m->type) {\n\tcase ALL:\n\t    matched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase NETGROUP:\n\t    if (netgr_matches(parse_tree->nss, m->name, lhost, shost,\n\t\tdef_netgroup_tuple ? pw->pw_name : NULL))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase NTWKADDR:\n\t    if (addr_matches(m->name))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase ALIAS:\n\t    a = alias_get(parse_tree, m->name, HOSTALIAS);\n\t    if (a != NULL) {\n\t\tconst int rc = hostlist_matches_int(parse_tree, pw, lhost,\n\t\t    shost, &a->members);\n\t\tif (rc != UNSPEC) {\n\t\t    if (m->negated) {\n\t\t\tmatched = rc == ALLOW ? DENY : ALLOW;\n\t\t    } else {\n\t\t\tmatched = rc;\n\t\t    }\n\t\t}\n\t\talias_put(a);\n\t\tbreak;\n\t    }\n\t    FALLTHROUGH;\n\tcase WORD:\n\t    if (hostname_matches(shost, lhost, m->name))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n    }\n    sudo_debug_printf(SUDO_DEBUG_DEBUG,\n\t\"host %s (%s) matches sudoers host %s%s: %s\", lhost, shost,\n\tm->negated ? \"!\" : \"\", m->name ? m->name : \"ALL\",\n\tmatched == true ? \"true\" : \"false\");\n    debug_return_int(matched);\n}", "target": 1}
{"code": "static void Sp_match(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tint len;\n\tconst char *a, *b, *c, *e;\n\tResub m;\n\ttext = checkstring(J, 0);\n\tif (js_isregexp(J, 1))\n\t\tjs_copy(J, 1);\n\telse if (js_isundefined(J, 1))\n\t\tjs_newregexp(J, \"\", 0);\n\telse\n\t\tjs_newregexp(J, js_tostring(J, 1), 0);\n\tre = js_toregexp(J, -1);\n\tif (!(re->flags & JS_REGEXP_G)) {\n\t\tjs_RegExp_prototype_exec(J, re, text);\n\t\treturn;\n\t}\n\tre->last = 0;\n\tjs_newarray(J);\n\tlen = 0;\n\ta = text;\n\te = text + strlen(text);\n\twhile (a <= e) {\n\t\tif (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n\t\t\tbreak;\n\t\tb = m.sub[0].sp;\n\t\tc = m.sub[0].ep;\n\t\tjs_pushlstring(J, b, c - b);\n\t\tjs_setindex(J, -2, len++);\n\t\ta = c;\n\t\tif (c - b == 0)\n\t\t\t++a;\n\t}\n\tif (len == 0) {\n\t\tjs_pop(J, 1);\n\t\tjs_pushnull(J);\n\t}\n}", "target": 1}
{"code": "void key_set_timeout(struct key *key, unsigned timeout)\n{\n\tstruct timespec now;\n\ttime_t expiry = 0;\n\tdown_write(&key->sem);\n\tif (timeout > 0) {\n\t\tnow = current_kernel_time();\n\t\texpiry = now.tv_sec + timeout;\n\t}\n\tkey->expiry = expiry;\n\tkey_schedule_gc(key->expiry + key_gc_delay);\n\tup_write(&key->sem);\n}", "target": 0}
{"code": "char* parse_content_length( char* buffer, char* end, int* length)\n{\n\tint number;\n\tchar *p;\n\tint  size;\n\tp = buffer;\n\twhile ( p<end && (*p==' ' || *p=='\\t' || (*p=='\\r' && *(p+1)=='\\n') ||\n\t(*p=='\\n' && (*(p+1)==' '||*(p+1)=='\\t')) ))\n\t\tp++;\n\tif (p==end)\n\t\tgoto error;\n\tsize = 0;\n\tnumber = 0;\n\twhile (p<end && *p>='0' && *p<='9') {\n\t\tnumber = number*10 + (*p)-'0';\n\t\tif (number<0) {\n\t\t\tLM_ERR(\"number overflow at pos %d in len number [%.*s]\\n\",\n\t\t\t\t(int)(p-buffer),(int)(end-buffer), buffer);\n\t\t\treturn 0;\n\t\t}\n\t\tsize ++;\n\t\tp++;\n\t}\n\tif (p==end || size==0)\n\t\tgoto error;\n\twhile ( p<end && (*p==' ' || *p=='\\t' ||\n\t(*p=='\\n' && (*(p+1)==' '||*(p+1)=='\\t')) ))\n\t\tp++;\n\tif (p==end)\n\t\tgoto error;\n\tif ( (*(p++)!='\\n') && (*(p-1)!='\\r' || *(p++)!='\\n' ) )\n\t\tgoto error;\n\t*length = number;\n\treturn p;\nerror:\n\tLM_ERR(\"parse error near char [%d][%c]\\n\",*p,*p);\n\treturn 0;\n}", "target": 1}
{"code": "static int ext4_dax_pmd_fault(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\t\t\tpmd_t *pmd, unsigned int flags)\n{\n\tint result;\n\thandle_t *handle = NULL;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct super_block *sb = inode->i_sb;\n\tbool write = flags & FAULT_FLAG_WRITE;\n\tif (write) {\n\t\tsb_start_pagefault(sb);\n\t\tfile_update_time(vma->vm_file);\n\t\thandle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,\n\t\t\t\text4_chunk_trans_blocks(inode,\n\t\t\t\t\t\t\tPMD_SIZE / PAGE_SIZE));\n\t}\n\tif (IS_ERR(handle))\n\t\tresult = VM_FAULT_SIGBUS;\n\telse\n\t\tresult = __dax_pmd_fault(vma, addr, pmd, flags,\n\t\t\t\text4_get_block_dax, ext4_end_io_unwritten);\n\tif (write) {\n\t\tif (!IS_ERR(handle))\n\t\t\text4_journal_stop(handle);\n\t\tsb_end_pagefault(sb);\n\t}\n\treturn result;\n}", "target": 1}
{"code": "Error HeifContext::get_id_of_non_virtual_child_image(heif_item_id id, heif_item_id& out) const\n{\n  std::string image_type = m_heif_file->get_item_type(id);\n  if (image_type==\"grid\" ||\n      image_type==\"iden\" ||\n      image_type==\"iovl\") {\n    auto iref_box = m_heif_file->get_iref_box();\n    if (!iref_box) {\n      return Error(heif_error_Invalid_input,\n                   heif_suberror_No_item_data,\n                   \"Derived image does not reference any other image items\");\n    }\n    std::vector<heif_item_id> image_references = iref_box->get_references(id, fourcc(\"dimg\"));\n    if (image_references.empty()) {\n      return Error(heif_error_Invalid_input,\n                   heif_suberror_No_item_data,\n                   \"Derived image does not reference any other image items\");\n    }\n    else {\n      return get_id_of_non_virtual_child_image(image_references[0], out);\n    }\n  }\n  else {\n    out = id;\n    return Error::Ok;\n  }\n}", "target": 0}
{"code": "static int nut_read_header(AVFormatContext *s)\n{\n    NUTContext *nut = s->priv_data;\n    AVIOContext *bc = s->pb;\n    int64_t pos;\n    int initialized_stream_count;\n    nut->avf = s;\n    pos = 0;\n    do {\n        pos = find_startcode(bc, MAIN_STARTCODE, pos) + 1;\n        if (pos < 0 + 1) {\n            av_log(s, AV_LOG_ERROR, \"No main startcode found.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    } while (decode_main_header(nut) < 0);\n    pos = 0;\n    for (initialized_stream_count = 0; initialized_stream_count < s->nb_streams;) {\n        pos = find_startcode(bc, STREAM_STARTCODE, pos) + 1;\n        if (pos < 0 + 1) {\n            av_log(s, AV_LOG_ERROR, \"Not all stream headers found.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        if (decode_stream_header(nut) >= 0)\n            initialized_stream_count++;\n    }\n    pos = 0;\n    for (;;) {\n        uint64_t startcode = find_any_startcode(bc, pos);\n        pos = avio_tell(bc);\n        if (startcode == 0) {\n            av_log(s, AV_LOG_ERROR, \"EOF before video frames\\n\");\n            return AVERROR_INVALIDDATA;\n        } else if (startcode == SYNCPOINT_STARTCODE) {\n            nut->next_startcode = startcode;\n            break;\n        } else if (startcode != INFO_STARTCODE) {\n            continue;\n        }\n        decode_info_header(nut);\n    }\n    ffformatcontext(s)->data_offset = pos - 8;\n    if (bc->seekable & AVIO_SEEKABLE_NORMAL) {\n        int64_t orig_pos = avio_tell(bc);\n        find_and_decode_index(nut);\n        avio_seek(bc, orig_pos, SEEK_SET);\n    }\n    av_assert0(nut->next_startcode == SYNCPOINT_STARTCODE);\n    ff_metadata_conv_ctx(s, NULL, ff_nut_metadata_conv);\n    return 0;\n}", "target": 1}
{"code": "int use_conf(char *test_path)\n{\n    int ret;\n    size_t flags = 0;\n    char filename[1024], errstr[1024];\n    char *buffer;\n    FILE *infile, *conffile;\n    json_t *json;\n    json_error_t error;\n    sprintf(filename, \"%s%cinput\", test_path, dir_sep);\n    if (!(infile = fopen(filename, \"rb\"))) {\n        fprintf(stderr, \"Could not open \\\"%s\\\"\\n\", filename);\n        return 2;\n    }\n    sprintf(filename, \"%s%cenv\", test_path, dir_sep);\n    conffile = fopen(filename, \"rb\");\n    if (conffile) {\n        read_conf(conffile);\n        fclose(conffile);\n    }\n    if (conf.indent < 0 || conf.indent > 255) {\n        fprintf(stderr, \"invalid value for JSON_INDENT: %d\\n\", conf.indent);\n        return 2;\n    }\n    if (conf.indent)\n        flags |= JSON_INDENT(conf.indent);\n    if (conf.compact)\n        flags |= JSON_COMPACT;\n    if (conf.ensure_ascii)\n        flags |= JSON_ENSURE_ASCII;\n    if (conf.preserve_order)\n        flags |= JSON_PRESERVE_ORDER;\n    if (conf.sort_keys)\n        flags |= JSON_SORT_KEYS;\n    if (conf.have_hashseed)\n        json_object_seed(conf.hashseed);\n    if (conf.strip) {\n        buffer = loadfile(infile);\n        json = json_loads(strip(buffer), 0, &error);\n        free(buffer);\n    }\n    else\n        json = json_loadf(infile, 0, &error);\n    fclose(infile);\n    if (!json) {\n        sprintf(errstr, \"%d %d %d\\n%s\\n\",\n                error.line, error.column, error.position,\n                error.text);\n        ret = cmpfile(errstr, test_path, \"error\");\n        return ret;\n    }\n    buffer = json_dumps(json, flags);\n    ret = cmpfile(buffer, test_path, \"output\");\n    free(buffer);\n    json_decref(json);\n    return ret;\n}", "target": 0}
{"code": "static RList *r_bin_wasm_get_global_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\tRList *ret = NULL;\n\tRBinWasmGlobalEntry *ptr = NULL;\n\tint buflen = bin->buf->length;\n\tif (sec->payload_data + 32 > buflen) {\n\t\treturn NULL;\n\t}\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 count = sec->count;\n\tut32 i = 0, r = 0;\n\twhile (i < len && len < buflen && r < count) {\n\t\tif (!(ptr = R_NEW0 (RBinWasmGlobalEntry))) {\n\t\t\treturn ret;\n\t\t}\n\t\tif (len + 8 > buflen || !(consume_u8 (buf + i, buf + len, (ut8*)&ptr->content_type, &i))) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (len + 8 > buflen || !(consume_u8 (buf + i, buf + len, &ptr->mutability, &i))) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (len + 8 > buflen || !(consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {\n\t\t\tgoto beach;\n\t\t}\n\t\tr_list_append (ret, ptr);\n\t\tr++;\n\t}\n\treturn ret;\nbeach:\n\tfree (ptr);\n\treturn ret;\n}", "target": 1}
{"code": "  Value GetValueOrCreatePlaceholder(StringRef full_name) {\n    StringRef node_name;\n    StringRef output_name = \"\";\n    bool is_control_dep = full_name[0] == '^';\n    int output_num = 0;\n    if (is_control_dep) full_name = full_name.drop_front();\n    {\n      size_t colon_sep = full_name.find_first_of(':');\n      if (colon_sep == StringRef::npos) {\n        node_name = full_name;\n      } else {\n        node_name = full_name.take_front(colon_sep);\n        output_name = full_name.drop_front(colon_sep + 1);\n      }\n      colon_sep = output_name.find_last_of(':');\n      if (colon_sep != StringRef::npos) {\n        unsigned long long value;\n        if (!llvm::getAsUnsignedInteger(output_name.drop_front(colon_sep + 1),\n                                        10, value))\n          output_num = value;\n        output_name = output_name.take_front(colon_sep);\n      }\n    }\n    llvm::StringMap<SmallVector<Value, 1>>& op_info = values_map_[node_name];\n    SmallVector<Value, 1>& base_operation = op_info[\"^\"];\n    if (base_operation.empty()) {\n      OperationState state(loc_, mlir_placeholder_);\n      state.addAttribute(TFGraphDialect::getNameAttrKey(),\n                         builder_.getStringAttr(node_name));\n      state.types.push_back(placeholder_ty_);\n      state.types.push_back(control_ty_);\n      Operation* placeholder = builder_.create(state);\n      base_operation.push_back(placeholder->getResult(1));\n      base_operation.push_back(placeholder->getResult(0));\n    }\n    if (is_control_dep) return base_operation[0];\n    SmallVector<Value, 1>& value_info = op_info[output_name];\n    if (value_info.size() <= output_num)\n      value_info.resize(output_num + 1, Value{});\n    if (!value_info[output_num]) {\n      value_info[output_num] = builder_.create<GetResultOp>(\n          loc_, base_operation[1], output_name, output_num);\n    }\n    return value_info[output_num];\n  }", "target": 1}
{"code": "mptctl_eventenable (unsigned long arg)\n{\n\tstruct mpt_ioctl_eventenable __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_eventenable\t karg;\n\tMPT_ADAPTER *ioc;\n\tint iocnum;\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventenable))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_eventenable - \"\n\t\t\t\"Unable to read in mpt_ioctl_eventenable struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_eventenable() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_eventenable called.\\n\",\n\t    ioc->name));\n\tif (ioc->events == NULL) {\n\t\tint sz = MPTCTL_EVENT_LOG_SIZE * sizeof(MPT_IOCTL_EVENTS);\n\t\tioc->events = kzalloc(sz, GFP_KERNEL);\n\t\tif (!ioc->events) {\n\t\t\tprintk(MYIOC_s_ERR_FMT\n\t\t\t    \": ERROR - Insufficient memory to add adapter!\\n\",\n\t\t\t    ioc->name);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tioc->alloc_total += sz;\n\t\tioc->eventContext = 0;\n        }\n\tioc->eventTypes = karg.eventTypes;\n\treturn 0;\n}", "target": 1}
{"code": "static void* socketio_CloneOption(const char* name, const void* value)\n{\n    void* result;\n    if (name != NULL)\n    {\n        result = NULL;\n        if (strcmp(name, OPTION_NET_INT_MAC_ADDRESS) == 0)\n        {\n            if (value == NULL)\n            {\n                LogError(\"Failed cloning option %s (value is NULL)\", name);\n            }\n            else\n            {\n                if ((result = malloc(sizeof(char) * (strlen((char*)value) + 1))) == NULL)\n                {\n                    LogError(\"Failed cloning option %s (malloc failed)\", name);\n                }\n                else\n                {\n                    strcpy((char *)result, (char *)value);\n                }\n            }\n        }\n        else\n        {\n            LogError(\"Cannot clone option %s (not suppported)\", name);\n        }\n    }\n    else\n    {\n        result = NULL;\n    }\n    return result;\n}", "target": 1}
{"code": "static void mirror_abort(Job *job)\n{\n    int ret = mirror_exit_common(job);\n    assert(ret == 0);\n}", "target": 0}
{"code": "QStringList QODBCDriver::tables(QSql::TableType type) const\n{\n    Q_D(const QODBCDriver);\n    QStringList tl;\n    if (!isOpen())\n        return tl;\n    SQLHANDLE hStmt;\n    SQLRETURN r = SQLAllocHandle(SQL_HANDLE_STMT,\n                                  d->hDbc,\n                                  &hStmt);\n    if (r != SQL_SUCCESS) {\n        qSqlWarning(\"QODBCDriver::tables: Unable to allocate handle\"_L1, d);\n        return tl;\n    }\n    r = SQLSetStmtAttr(hStmt,\n                        SQL_ATTR_CURSOR_TYPE,\n                        (SQLPOINTER)SQL_CURSOR_FORWARD_ONLY,\n                        SQL_IS_UINTEGER);\n    QStringList tableType;\n    if (type & QSql::Tables)\n        tableType += \"TABLE\"_L1;\n    if (type & QSql::Views)\n        tableType += \"VIEW\"_L1;\n    if (type & QSql::SystemTables)\n        tableType += \"SYSTEM TABLE\"_L1;\n    if (tableType.isEmpty())\n        return tl;\n    QString joinedTableTypeString = tableType.join(u',');\n    r = SQLTables(hStmt,\n                   NULL,\n                   0,\n                   NULL,\n                   0,\n                   NULL,\n                   0,\n                   toSQLTCHAR(joinedTableTypeString).data(),\n                   joinedTableTypeString.length() );\n    if (r != SQL_SUCCESS)\n        qSqlWarning(\"QODBCDriver::tables Unable to execute table list\"_L1, d);\n    if (d->hasSQLFetchScroll)\n        r = SQLFetchScroll(hStmt,\n                           SQL_FETCH_NEXT,\n                           0);\n    else\n        r = SQLFetch(hStmt);\n    if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO && r != SQL_NO_DATA) {\n        qWarning() << \"QODBCDriver::tables failed to retrieve table/view list: (\" << r << \",\" << qWarnODBCHandle(SQL_HANDLE_STMT, hStmt) << \")\";\n        return QStringList();\n    }\n    while (r == SQL_SUCCESS) {\n        tl.append(qGetStringData(hStmt, 2, -1, d->unicode).toString());\n        if (d->hasSQLFetchScroll)\n            r = SQLFetchScroll(hStmt,\n                               SQL_FETCH_NEXT,\n                               0);\n        else\n            r = SQLFetch(hStmt);\n    }\n    r = SQLFreeHandle(SQL_HANDLE_STMT, hStmt);\n    if (r!= SQL_SUCCESS)\n        qSqlWarning(\"QODBCDriver: Unable to free statement handle\"_L1 + QString::number(r), d);\n    return tl;\n}", "target": 1}
{"code": "static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cmap_t *cmap = &box->data.cmap;\n\tjp2_cmapent_t *ent;\n\tunsigned int i;\n\tcmap->ents = 0;\n\tcmap->numchans = (box->datalen) / 4;\n\tif (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < cmap->numchans; ++i) {\n\t\tent = &cmap->ents[i];\n\t\tif (jp2_getuint16(in, &ent->cmptno) ||\n\t\t  jp2_getuint8(in, &ent->map) ||\n\t\t  jp2_getuint8(in, &ent->pcol)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static bool anal_fcn_data (RCore *core, const char *input) {\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\tut32 fcn_size = r_anal_function_size_from_entry (fcn);\n\tif (fcn) {\n\t\tint i;\n\t\tbool gap = false;\n\t\tut64 gap_addr = UT64_MAX;\n\t\tchar *bitmap = calloc (1, fcn_size);\n\t\tif (bitmap) {\n\t\t\tRAnalBlock *b;\n\t\t\tRListIter *iter;\n\t\t\tr_list_foreach (fcn->bbs, iter, b) {\n\t\t\t\tint f = b->addr - fcn->addr;\n\t\t\t\tint t = R_MIN (f + b->size, fcn_size);\n\t\t\t\tif (f >= 0) {\n\t\t\t\t\twhile (f < t) {\n\t\t\t\t\t\tbitmap[f++] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < fcn_size; i++) {\n\t\t\tut64 here = fcn->addr + i;\n\t\t\tif (bitmap && bitmap[i]) {\n\t\t\t\tif (gap) {\n\t\t\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"PFMT64x\"\\n\", here - gap_addr, gap_addr);\n\t\t\t\t\tgap = false;\n\t\t\t\t}\n\t\t\t\tgap_addr = UT64_MAX;\n\t\t\t} else {\n\t\t\t\tif (!gap) {\n\t\t\t\t\tgap = true;\n\t\t\t\t\tgap_addr = here;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (gap) {\n\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"PFMT64x\"\\n\", fcn->addr + fcn_size - gap_addr, gap_addr);\n\t\t}\n\t\tfree (bitmap);\n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "blkcpy(void * dest, void * src, size_t len)\n{\n  memcpy(dest, src, len);\n}", "target": 1}
{"code": "RPVector *r_bin_wasm_get_types(RBinWasmObj *bin) {\n\tr_return_val_if_fail (bin && bin->g_sections, NULL);\n\treturn bin->g_types? bin->g_types: parse_unique_subsec_vec_by_id (bin, R_BIN_WASM_SECTION_TYPE);\n}", "target": 0}
{"code": "inline void GatherNd(const RuntimeShape& params_shape,\n                     const ParamsT* params_data,\n                     const RuntimeShape& indices_shape,\n                     const IndicesT* indices_data,\n                     const RuntimeShape& output_shape, ParamsT* output_data) {\n  ruy::profiler::ScopeLabel label(\"GatherNd\");\n  const GatherNdHelperResult res = GatherNdHelper(params_shape, indices_shape);\n  for (int i = 0; i < res.n_slices; ++i) {\n    int from_pos = 0;\n    for (int j = 0; j < res.indices_nd; ++j) {\n      from_pos += indices_data[i * res.indices_nd + j] * res.dims_to_count[j];\n    }\n    std::memcpy(output_data + i * res.slice_size, params_data + from_pos,\n                sizeof(ParamsT) * res.slice_size);\n  }\n}", "target": 1}
{"code": "int main()\n{\n    gdImagePtr im1, im2;\n    FILE *fp;\n    int size;\n    fp = gdTestFileOpen2(\"webp\", \"bug_double_free.jpg\");\n    gdTestAssert(fp != NULL);\n    im1 = gdImageCreateFromJpeg(fp);\n    gdTestAssert(im1 != NULL);\n    fclose(fp);\n    im2 = gdImageWebpPtr(im1, &size);\n    gdTestAssert(im2 == NULL);\n    gdImageDestroy(im1);\n    return gdNumFailures();\n}", "target": 0}
{"code": "SYSCALL_DEFINE6(recvfrom, int, fd, void __user *, ubuf, size_t, size,\n\t\tunsigned int, flags, struct sockaddr __user *, addr,\n\t\tint __user *, addr_len)\n{\n\tstruct socket *sock;\n\tstruct iovec iov;\n\tstruct msghdr msg;\n\tstruct sockaddr_storage address;\n\tint err, err2;\n\tint fput_needed;\n\tif (size > INT_MAX)\n\t\tsize = INT_MAX;\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\tmsg.msg_control = NULL;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_iovlen = 1;\n\tmsg.msg_iov = &iov;\n\tiov.iov_len = size;\n\tiov.iov_base = ubuf;\n\tmsg.msg_name = (struct sockaddr *)&address;\n\tmsg.msg_namelen = sizeof(address);\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\terr = sock_recvmsg(sock, &msg, size, flags);\n\tif (err >= 0 && addr != NULL) {\n\t\terr2 = move_addr_to_user(&address,\n\t\t\t\t\t msg.msg_namelen, addr, addr_len);\n\t\tif (err2 < 0)\n\t\t\terr = err2;\n\t}\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}", "target": 1}
{"code": "print_al(const gs_memory_t *mem, const char *label, const active_line * alp)\n{\n    if (gs_debug_c('F'))\n        print_active_line(mem, label, alp);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& handle = ctx->input(0);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(handle.shape()),\n                errors::InvalidArgument(\"`handle` must be scalar\"));\n    const string& name = handle.scalar<tstring>()();\n    auto session_state = ctx->session_state();\n    OP_REQUIRES(ctx, session_state != nullptr,\n                errors::FailedPrecondition(\n                    \"DeleteSessionTensor called on null session state\"));\n    OP_REQUIRES_OK(ctx, session_state->DeleteTensor(name));\n  }", "target": 0}
{"code": "void RtmpProtocol::handle_C1_simple(const char *data){\n    char handshake_head = HANDSHAKE_PLAINTEXT;\n    onSendRawData(obtainBuffer(&handshake_head, 1));\n    RtmpHandshake s1(0);\n    onSendRawData(obtainBuffer((char *) &s1, C1_HANDSHARK_SIZE));\n    onSendRawData(obtainBuffer(data + 1, C1_HANDSHARK_SIZE));\n    _next_step_func = [this](const char *data, size_t len) {\n        return handle_C2(data, len);\n    };\n}", "target": 0}
{"code": "DocumentLoader* FrameLoader::activeDocumentLoader() const\n{\n    if (m_state == FrameStateProvisional)\n        return m_provisionalDocumentLoader.get();\n    return m_documentLoader.get();\n}", "target": 0}
{"code": "close_msg_fds(struct VhostUserMsg *msg)\n{\n\tint i;\n\tfor (i = 0; i < msg->fd_num; i++)\n\t\tclose(msg->fds[i]);\n}", "target": 0}
{"code": "void mp_obj_int_to_bytes_impl(mp_obj_t self_in, bool big_endian, size_t len, byte *buf) {\n    assert(mp_obj_is_exact_type(self_in, &mp_type_int));\n    mp_obj_int_t *self = self_in;\n    long long val = self->val;\n    if (big_endian) {\n        byte *b = buf + len;\n        while (b > buf) {\n            *--b = val;\n            val >>= 8;\n        }\n    } else {\n        for (; len > 0; --len) {\n            *buf++ = val;\n            val >>= 8;\n        }\n    }\n}", "target": 1}
{"code": "static int open_handlers(void)\n{\n\tstruct dirent **dirent_list;\n\tint num_handlers;\n\tint num_good = 0;\n\tint i;\n\tnum_handlers = scandir(handler_path, &dirent_list, is_handler, alphasort);\n\tif (num_handlers == -1)\n\t\treturn -1;\n\tfor (i = 0; i < num_handlers; i++) {\n\t\tchar *path;\n\t\tvoid *handle;\n\t\tint (*handler_init)(void);\n\t\tint ret;\n\t\tret = asprintf(&path, \"%s/%s\", handler_path, dirent_list[i]->d_name);\n\t\tif (ret == -1) {\n\t\t\ttcmu_err(\"ENOMEM\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\thandle = dlopen(path, RTLD_NOW|RTLD_LOCAL);\n\t\tif (!handle) {\n\t\t\ttcmu_err(\"Could not open handler at %s: %s\\n\", path, dlerror());\n\t\t\tfree(path);\n\t\t\tcontinue;\n\t\t}\n\t\thandler_init = dlsym(handle, \"handler_init\");\n\t\tif (!handler_init) {\n\t\t\ttcmu_err(\"dlsym failure on %s\\n\", path);\n\t\t\tfree(path);\n\t\t\tcontinue;\n\t\t}\n\t\tret = handler_init();\n\t\tfree(path);\n\t\tif (ret == 0)\n\t\t\tnum_good++;\n\t}\n\tfor (i = 0; i < num_handlers; i++)\n\t\tfree(dirent_list[i]);\n\tfree(dirent_list);\n\treturn num_good;\n}", "target": 0}
{"code": "  void Clear() {\n    size_ = 0;\n    SetOffset(0);\n  }", "target": 0}
{"code": "nft_meta_get_eval_time(enum nft_meta_keys key,\n\t\t       u32 *dest)\n{\n\tswitch (key) {\n\tcase NFT_META_TIME_NS:\n\t\tnft_reg_store64(dest, ktime_get_real_ns());\n\t\tbreak;\n\tcase NFT_META_TIME_DAY:\n\t\tnft_reg_store8(dest, nft_meta_weekday());\n\t\tbreak;\n\tcase NFT_META_TIME_HOUR:\n\t\t*dest = nft_meta_hour(ktime_get_real_seconds());\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& filter = context->input(1);\n    const Tensor& out_backprop = context->input(2);\n    int stride_rows = 0, stride_cols = 0;\n    int rate_rows = 0, rate_cols = 0;\n    int64 pad_top = 0, pad_left = 0;\n    int64 out_rows = 0, out_cols = 0;\n    ParseSizes(context, strides_, rates_, padding_, &stride_rows, &stride_cols,\n               &rate_rows, &rate_cols, &pad_top, &pad_left, &out_rows,\n               &out_cols);\n    if (!context->status().ok()) return;\n    const int batch = input.dim_size(0);\n    const int depth = input.dim_size(3);\n    OP_REQUIRES(context,\n                batch == out_backprop.dim_size(0) &&\n                    out_rows == out_backprop.dim_size(1) &&\n                    out_cols == out_backprop.dim_size(2) &&\n                    depth == out_backprop.dim_size(3),\n                errors::InvalidArgument(\"out_backprop has incompatible size.\"));\n    Tensor* filter_backprop = nullptr;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(0, filter.shape(), &filter_backprop));\n    if (filter.shape().num_elements() == 0) {\n      return;\n    }\n    functor::DilationBackpropFilter<Device, T>()(\n        context->eigen_device<Device>(), input.tensor<T, 4>(),\n        filter.tensor<T, 3>(), out_backprop.tensor<T, 4>(), stride_rows,\n        stride_cols, rate_rows, rate_cols, pad_top, pad_left,\n        filter_backprop->tensor<T, 3>());\n  }", "target": 0}
{"code": "int utf8s_to_utf16s(const u8 *s, int len, wchar_t *pwcs)\n{\n\tu16 *op;\n\tint size;\n\tunicode_t u;\n\top = pwcs;\n\twhile (*s && len > 0) {\n\t\tif (*s & 0x80) {\n\t\t\tsize = utf8_to_utf32(s, len, &u);\n\t\t\tif (size < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (u >= PLANE_SIZE) {\n\t\t\t\tu -= PLANE_SIZE;\n\t\t\t\t*op++ = (wchar_t) (SURROGATE_PAIR |\n\t\t\t\t\t\t((u >> 10) & SURROGATE_BITS));\n\t\t\t\t*op++ = (wchar_t) (SURROGATE_PAIR |\n\t\t\t\t\t\tSURROGATE_LOW |\n\t\t\t\t\t\t(u & SURROGATE_BITS));\n\t\t\t} else {\n\t\t\t\t*op++ = (wchar_t) u;\n\t\t\t}\n\t\t\ts += size;\n\t\t\tlen -= size;\n\t\t} else {\n\t\t\t*op++ = *s++;\n\t\t\tlen--;\n\t\t}\n\t}\n\treturn op - pwcs;\n}", "target": 1}
{"code": "static int __init big_key_crypto_init(void)\n{\n\tint ret = -EINVAL;\n\tbig_key_rng = crypto_alloc_rng(big_key_rng_name, 0, 0);\n\tif (IS_ERR(big_key_rng)) {\n\t\tbig_key_rng = NULL;\n\t\treturn -EFAULT;\n\t}\n\tret = crypto_rng_reset(big_key_rng, NULL, crypto_rng_seedsize(big_key_rng));\n\tif (ret)\n\t\tgoto error;\n\tbig_key_skcipher = crypto_alloc_skcipher(big_key_alg_name,\n\t\t\t\t\t\t 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(big_key_skcipher)) {\n\t\tbig_key_skcipher = NULL;\n\t\tret = -EFAULT;\n\t\tgoto error;\n\t}\n\treturn 0;\nerror:\n\tcrypto_free_rng(big_key_rng);\n\tbig_key_rng = NULL;\n\treturn ret;\n}", "target": 1}
{"code": "int Jsi_ObjArraySizer(Jsi_Interp *interp, Jsi_Obj *obj, uint len)\n{\n    int nsiz = len + 1, mod = ALLOC_MOD_SIZE;\n    assert(obj->isarrlist);\n    if (mod>1)\n        nsiz = nsiz + ((mod-1) - (nsiz + mod - 1)%mod);\n    if (nsiz > MAX_ARRAY_LIST) {\n        Jsi_LogError(\"array size too large\");\n        return 0;\n    }\n    if (len >= obj->arrMaxSize) {\n        int oldsz = (nsiz-obj->arrMaxSize);\n        obj->arr = (Jsi_Value**)Jsi_Realloc(obj->arr, nsiz*sizeof(Jsi_Value*));\n        memset(obj->arr+obj->arrMaxSize, 0, oldsz*sizeof(Jsi_Value*));\n        obj->arrMaxSize = nsiz;\n    }\n    if (len>obj->arrCnt)\n        obj->arrCnt = len;\n    return nsiz;\n}", "target": 1}
{"code": "void ParamTraits<string16>::Log(const param_type& p, std::string* l) {\n  l->append(UTF16ToUTF8(p));\n}", "target": 0}
{"code": "static int kvaser_usb_leaf_simple_cmd_async(struct kvaser_usb_net_priv *priv,\n\t\t\t\t\t    u8 cmd_id)\n{\n\tstruct kvaser_cmd *cmd;\n\tint err;\n\tcmd = kmalloc(sizeof(*cmd), GFP_ATOMIC);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_simple);\n\tcmd->id = cmd_id;\n\tcmd->u.simple.channel = priv->channel;\n\terr = kvaser_usb_send_cmd_async(priv, cmd, cmd->len);\n\tif (err)\n\t\tkfree(cmd);\n\treturn err;\n}", "target": 1}
{"code": "char *M_fs_path_join_parts(const M_list_str_t *path, M_fs_system_t sys_type)\n{\n\tM_list_str_t *parts;\n\tconst char   *part;\n\tchar         *out;\n\tsize_t        len;\n\tsize_t        i;\n\tsize_t        count;\n\tif (path == NULL) {\n\t\treturn NULL;\n\t}\n\tlen = M_list_str_len(path);\n\tif (len == 0) {\n\t\treturn NULL;\n\t}\n\tsys_type = M_fs_path_get_system_type(sys_type);\n\tparts = M_list_str_duplicate(path);\n\tfor (i=len-1; i>0; i--) {\n\t\tpart = M_list_str_at(parts, i);\n\t\tif (part == NULL || *part == '\\0') {\n\t\t\tM_list_str_remove_at(parts, i);\n\t\t}\n\t}\n\tlen = M_list_str_len(parts);\n\tpart = M_list_str_at(parts, 0);\n\tif (len == 1 && (part == NULL || *part == '\\0')) {\n\t\tM_list_str_destroy(parts);\n\t\tif (sys_type == M_FS_SYSTEM_WINDOWS) {\n\t\t\treturn M_strdup(\"\\\\\\\\\");\n\t\t}\n\t\treturn M_strdup(\"/\");\n\t}\n\tif (sys_type == M_FS_SYSTEM_WINDOWS && len > 0) {\n\t\tpart  = M_list_str_at(parts, 0);\n\t\tcount = (len == 1) ? 2 : 1;\n\t\tif (part != NULL && *part == '\\0') {\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tM_list_str_insert_at(parts, \"\", 0);\n\t\t\t}\n\t\t} else if (M_fs_path_isabs(part, sys_type) && len == 1) {\n\t\t\tM_list_str_insert_at(parts, \"\", 1);\n\t\t}\n\t}\n\tout = M_list_str_join(parts, (unsigned char)M_fs_path_get_system_sep(sys_type));\n\tM_list_str_destroy(parts);\n\treturn out;\n}", "target": 1}
{"code": "int main()\n{\n    check_file(\"heap_overflow_1.tga\");\n    check_file(\"heap_overflow_2.tga\");\n    return gdNumFailures();\n}", "target": 0}
{"code": "static void outbound_phy_packet_callback(struct fw_packet *packet,\n\t\t\t\t\t struct fw_card *card, int status)\n{\n\tstruct outbound_phy_packet_event *e =\n\t\tcontainer_of(packet, struct outbound_phy_packet_event, p);\n\tswitch (status) {\n\tcase ACK_COMPLETE:\te->phy_packet.rcode = RCODE_COMPLETE;\tbreak;\n\tcase ACK_PENDING:\te->phy_packet.rcode = RCODE_COMPLETE;\tbreak;\n\tcase ACK_BUSY_X:\n\tcase ACK_BUSY_A:\n\tcase ACK_BUSY_B:\te->phy_packet.rcode = RCODE_BUSY;\tbreak;\n\tcase ACK_DATA_ERROR:\te->phy_packet.rcode = RCODE_DATA_ERROR;\tbreak;\n\tcase ACK_TYPE_ERROR:\te->phy_packet.rcode = RCODE_TYPE_ERROR;\tbreak;\n\tdefault:\t\te->phy_packet.rcode = status;\t\tbreak;\n\t}\n\te->phy_packet.data[0] = packet->timestamp;\n\tqueue_event(e->client, &e->event, &e->phy_packet,\n\t\t    sizeof(e->phy_packet) + e->phy_packet.length, NULL, 0);\n\tclient_put(e->client);\n}", "target": 1}
{"code": "void error_handler(int priority, const char *format, ...)\n{\n    gdTestAssert(priority == GD_WARNING);\n    gdTestAssert(!strcmp(format, MSG));\n}", "target": 0}
{"code": "int ecryptfs_privileged_open(struct file **lower_file,\n\t\t\t     struct dentry *lower_dentry,\n\t\t\t     struct vfsmount *lower_mnt,\n\t\t\t     const struct cred *cred)\n{\n\tstruct ecryptfs_open_req req;\n\tint flags = O_LARGEFILE;\n\tint rc = 0;\n\tinit_completion(&req.done);\n\treq.lower_file = lower_file;\n\treq.path.dentry = lower_dentry;\n\treq.path.mnt = lower_mnt;\n\tflags |= IS_RDONLY(d_inode(lower_dentry)) ? O_RDONLY : O_RDWR;\n\t(*lower_file) = dentry_open(&req.path, flags, cred);\n\tif (!IS_ERR(*lower_file))\n\t\tgoto out;\n\tif ((flags & O_ACCMODE) == O_RDONLY) {\n\t\trc = PTR_ERR((*lower_file));\n\t\tgoto out;\n\t}\n\tmutex_lock(&ecryptfs_kthread_ctl.mux);\n\tif (ecryptfs_kthread_ctl.flags & ECRYPTFS_KTHREAD_ZOMBIE) {\n\t\trc = -EIO;\n\t\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\t\tprintk(KERN_ERR \"%s: We are in the middle of shutting down; \"\n\t\t       \"aborting privileged request to open lower file\\n\",\n\t\t\t__func__);\n\t\tgoto out;\n\t}\n\tlist_add_tail(&req.kthread_ctl_list, &ecryptfs_kthread_ctl.req_list);\n\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\twake_up(&ecryptfs_kthread_ctl.wait);\n\twait_for_completion(&req.done);\n\tif (IS_ERR(*lower_file))\n\t\trc = PTR_ERR(*lower_file);\nout:\n\treturn rc;\n}", "target": 1}
{"code": "void RenderFrameHostImpl::OnCrossSiteResponse(\n    const GlobalRequestID& global_request_id,\n    scoped_ptr<CrossSiteTransferringRequest> cross_site_transferring_request,\n    const std::vector<GURL>& transfer_url_chain,\n    const Referrer& referrer,\n    PageTransition page_transition,\n    bool should_replace_current_entry) {\n  frame_tree_node_->render_manager()->OnCrossSiteResponse(\n      this, global_request_id, cross_site_transferring_request.Pass(),\n      transfer_url_chain, referrer, page_transition,\n      should_replace_current_entry);\n}", "target": 0}
{"code": "BGD_DECLARE(void) gdImageFilledRectangle (gdImagePtr im, int x1, int y1, int x2, int y2,\n\t\tint color)\n{\n\t_gdImageFilledVRectangle(im, x1, y1, x2, y2, color);\n}", "target": 0}
{"code": "int CF_LoadEncodedChunk(const CuckooFilter *cf, long long pos, const char *data, size_t datalen) {\n    if (datalen == 0) {\n        return REDISMODULE_ERR;\n    }\n    long long offset = pos - datalen - 1;\n    long long currentSize;\n    int filterIx = 0;\n    SubCF *filter = NULL;\n    for (; filterIx < cf->numFilters; ++filterIx) {\n        filter = cf->filters + filterIx;\n        currentSize = filter->bucketSize * filter->numBuckets;\n        if (offset < currentSize) {\n            break;\n        }\n        offset -= currentSize;\n    }\n    memcpy(filter->data + offset, data, datalen);\n    return REDISMODULE_OK;\n}", "target": 1}
{"code": "static void rtrs_clt_dev_release(struct device *dev)\n{\n\tstruct rtrs_clt_sess *clt = container_of(dev, struct rtrs_clt_sess,\n\t\t\t\t\t\t dev);\n\tmutex_destroy(&clt->paths_ev_mutex);\n\tmutex_destroy(&clt->paths_mutex);\n\tkfree(clt);\n}", "target": 0}
{"code": "void GHASH::key_schedule(std::span<const uint8_t> key) {\n   m_H.assign(key.begin(), key.end());  \n   m_H_ad.resize(GCM_BS);\n   m_ad_len = 0;\n   m_text_len = 0;\n   uint64_t H0 = load_be<uint64_t>(m_H.data(), 0);\n   uint64_t H1 = load_be<uint64_t>(m_H.data(), 1);\n   const uint64_t R = 0xE100000000000000;\n   m_HM.resize(256);\n   for(size_t i = 0; i != 2; ++i) {\n      for(size_t j = 0; j != 64; ++j) {\n         m_HM[4 * j + 2 * i] = H0;\n         m_HM[4 * j + 2 * i + 1] = H1;\n         const uint64_t carry = R * (H1 & 1);\n         H1 = (H1 >> 1) | (H0 << 63);\n         H0 = (H0 >> 1) ^ carry;\n      }\n   }\n#if defined(BOTAN_HAS_GHASH_CLMUL_CPU)\n   if(CPUID::has_carryless_multiply()) {\n      m_H_pow.resize(8);\n      ghash_precompute_cpu(m_H.data(), m_H_pow.data());\n   }\n#endif\n}", "target": 1}
{"code": "void WebGLRenderingContextBase::PushFrame() {\n  if (!marked_canvas_dirty_)\n    return;\n  marked_canvas_dirty_ = false;\n  int width = GetDrawingBuffer()->Size().Width();\n  int height = GetDrawingBuffer()->Size().Height();\n  if (!GetDrawingBuffer()) {\n    return Host()->PushFrame(nullptr, SkIRect::MakeWH(width, height));\n  }\n  std::unique_ptr<viz::SingleReleaseCallback> image_release_callback;\n  scoped_refptr<StaticBitmapImage> image =\n      GetStaticBitmapImage(&image_release_callback);\n  GetDrawingBuffer()->SwapPreviousFrameCallback(\n      std::move(image_release_callback));\n  return Host()->PushFrame(std::move(image), SkIRect::MakeWH(width, height));\n}", "target": 0}
{"code": "Jsi_RC Jsi_RegExpMatch(Jsi_Interp *interp, Jsi_Value *pattern, const char *v, int *rc, Jsi_DString *dStr)\n{\n    Jsi_Regex *re;\n    int regexec_flags = 0;\n    if (rc)\n        *rc = 0;\n    if (pattern == NULL || pattern->vt != JSI_VT_OBJECT || pattern->d.obj->ot != JSI_OT_REGEXP) \n        return Jsi_LogError(\"expected pattern\");\n    re = pattern->d.obj->d.robj;\n    regex_t *reg = &re->reg;\n    regmatch_t pos = {};\n    if (dStr)\n        Jsi_DSInit(dStr);\n    int r  = regexec(reg, v, 1, &pos, regexec_flags);\n    if (r >= REG_BADPAT) {\n        char buf[100];\n        regerror(r, reg, buf, sizeof(buf));\n        return Jsi_LogError(\"error while matching pattern: %s\", buf);\n    }\n    if (r != REG_NOMATCH) {\n        if (rc) *rc = 1;\n        if (dStr && pos.rm_so >= 0 && pos.rm_eo >= 0 &&  pos.rm_eo >= pos.rm_so)\n            Jsi_DSAppendLen(dStr, v + pos.rm_so, pos.rm_eo - pos.rm_so);\n    }\n    return JSI_OK;\n}", "target": 1}
{"code": "imap_client_notify_starttls(struct client *client,\n\t\t\t    bool success, const char *text)\n{\n\tif (success)\n\t\tclient_send_reply(client, IMAP_CMD_REPLY_OK, text);\n\telse\n\t\tclient_send_reply(client, IMAP_CMD_REPLY_BAD, text);\n}", "target": 0}
{"code": "std::shared_ptr<EC_Group_Data> EC_Group::BER_decode_EC_group(const uint8_t bits[], size_t len,\n                                                             EC_Group_Source source)\n   {\n   BER_Decoder ber(bits, len);\n   BER_Object obj = ber.get_next_object();\n   if(obj.type() == NULL_TAG)\n      {\n      throw Decoding_Error(\"Cannot handle ImplicitCA ECC parameters\");\n      }\n   else if(obj.type() == OBJECT_ID)\n      {\n      OID dom_par_oid;\n      BER_Decoder(bits, len).decode(dom_par_oid);\n      return ec_group_data().lookup(dom_par_oid);\n      }\n   else if(obj.type() == SEQUENCE)\n      {\n      BigInt p, a, b, order, cofactor;\n      std::vector<uint8_t> base_pt;\n      std::vector<uint8_t> seed;\n      BER_Decoder(bits, len)\n         .start_cons(SEQUENCE)\n           .decode_and_check<size_t>(1, \"Unknown ECC param version code\")\n           .start_cons(SEQUENCE)\n            .decode_and_check(OID(\"1.2.840.10045.1.1\"),\n                              \"Only prime ECC fields supported\")\n             .decode(p)\n           .end_cons()\n           .start_cons(SEQUENCE)\n             .decode_octet_string_bigint(a)\n             .decode_octet_string_bigint(b)\n             .decode_optional_string(seed, BIT_STRING, BIT_STRING)\n           .end_cons()\n           .decode(base_pt, OCTET_STRING)\n           .decode(order)\n           .decode(cofactor)\n         .end_cons()\n         .verify_end();\n      if(p.bits() < 64 || p.is_negative() || !is_bailie_psw_probable_prime(p))\n         throw Decoding_Error(\"Invalid ECC p parameter\");\n      if(a.is_negative() || a >= p)\n         throw Decoding_Error(\"Invalid ECC a parameter\");\n      if(b <= 0 || b >= p)\n         throw Decoding_Error(\"Invalid ECC b parameter\");\n      if(order <= 0 || !is_bailie_psw_probable_prime(order))\n         throw Decoding_Error(\"Invalid ECC order parameter\");\n      if(cofactor <= 0 || cofactor >= 16)\n         throw Decoding_Error(\"Invalid ECC cofactor parameter\");\n      std::pair<BigInt, BigInt> base_xy = Botan::OS2ECP(base_pt.data(), base_pt.size(), p, a, b);\n      return ec_group_data().lookup_or_create(p, a, b, base_xy.first, base_xy.second,\n                                              order, cofactor, OID(), source);\n      }\n   else\n      {\n      throw Decoding_Error(\"Unexpected tag while decoding ECC domain params\");\n      }\n   }", "target": 1}
{"code": "double Item_cache_str::val_real()\n{\n  DBUG_ASSERT(fixed == 1);\n  int err_not_used;\n  char *end_not_used;\n  if (!has_value())\n    return 0.0;\n  if (value)\n    return my_strntod(value->charset(), (char*) value->ptr(),\n\t\t      value->length(), &end_not_used, &err_not_used);\n  return (double) 0;\n}", "target": 0}
{"code": "static int do_remount(struct path *path, int flags, int mnt_flags,\n\t\t      void *data)\n{\n\tint err;\n\tstruct super_block *sb = path->mnt->mnt_sb;\n\tstruct mount *mnt = real_mount(path->mnt);\n\tif (!check_mnt(mnt))\n\t\treturn -EINVAL;\n\tif (path->dentry != path->mnt->mnt_root)\n\t\treturn -EINVAL;\n\terr = security_sb_remount(sb, data);\n\tif (err)\n\t\treturn err;\n\tdown_write(&sb->s_umount);\n\tif (flags & MS_BIND)\n\t\terr = change_mount_flags(path->mnt, flags);\n\telse if (!capable(CAP_SYS_ADMIN))\n\t\terr = -EPERM;\n\telse\n\t\terr = do_remount_sb(sb, flags, data, 0);\n\tif (!err) {\n\t\tlock_mount_hash();\n\t\tmnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;\n\t\tmnt->mnt.mnt_flags = mnt_flags;\n\t\ttouch_mnt_namespace(mnt->mnt_ns);\n\t\tunlock_mount_hash();\n\t}\n\tup_write(&sb->s_umount);\n\treturn err;\n}", "target": 1}
{"code": "static void read_version(struct pbap_data *pbap, GObexApparam *apparam)\n{\n\tconst guint8 *data;\n\tuint8_t value[16];\n\tgsize len;\n\tif (!(pbap->supported_features & FOLDER_VERSION_FEATURE))\n\t\treturn;\n\tif (!g_obex_apparam_get_bytes(apparam, PRIMARY_COUNTER_TAG, &data,\n\t\t\t\t\t\t\t\t&len)) {\n\t\tlen = sizeof(value);\n\t\tmemset(value, 0, len);\n\t\tdata = value;\n\t}\n\tif (memcmp(pbap->primary, data, len)) {\n\t\tmemcpy(pbap->primary, data, len);\n\t\tg_dbus_emit_property_changed(conn,\n\t\t\t\t\tobc_session_get_path(pbap->session),\n\t\t\t\t\tPBAP_INTERFACE, \"PrimaryCounter\");\n\t}\n\tif (!g_obex_apparam_get_bytes(apparam, SECONDARY_COUNTER_TAG, &data,\n\t\t\t\t\t\t\t\t&len)) {\n\t\tlen = sizeof(value);\n\t\tmemset(value, 0, len);\n\t\tdata = value;\n\t}\n\tif (memcmp(pbap->secondary, data, len)) {\n\t\tmemcpy(pbap->secondary, data, len);\n\t\tg_dbus_emit_property_changed(conn,\n\t\t\t\t\tobc_session_get_path(pbap->session),\n\t\t\t\t\tPBAP_INTERFACE, \"SecondaryCounter\");\n\t}\n}", "target": 1}
{"code": "int dns_add_HTTPS_start(struct dns_rr_nested *svcparam_buffer, struct dns_packet *packet, dns_rr_type type,\n\t\t\t\t\t\tconst char *domain, int ttl, int priority, const char *target)\n{\n\tsvcparam_buffer = dns_add_rr_nested_start(svcparam_buffer, packet, type, DNS_T_HTTPS, domain, ttl);\n\tif (svcparam_buffer == NULL) {\n\t\treturn -1;\n\t}\n\tint target_len = strnlen(target, DNS_MAX_CNAME_LEN) + 1;\n\tif (_dns_left_len(&svcparam_buffer->context) < 2 + target_len) {\n\t\treturn -1;\n\t}\n\t_dns_write_short(&svcparam_buffer->context.ptr, priority);\n\tsafe_strncpy((char *)svcparam_buffer->context.ptr, target, target_len);\n\tsvcparam_buffer->context.ptr += target_len;\n\treturn 0;\n}", "target": 1}
{"code": "static int ext4_get_block_write(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create)\n{\n\thandle_t *handle = NULL;\n\tint ret = 0;\n\tunsigned max_blocks = bh_result->b_size >> inode->i_blkbits;\n\tint dio_credits;\n\text4_debug(\"ext4_get_block_write: inode %lu, create flag %d\\n\",\n\t\t   inode->i_ino, create);\n\tcreate = EXT4_GET_BLOCKS_IO_CREATE_EXT;\n\tif (max_blocks > DIO_MAX_BLOCKS)\n\t\tmax_blocks = DIO_MAX_BLOCKS;\n\tdio_credits = ext4_chunk_trans_blocks(inode, max_blocks);\n\thandle = ext4_journal_start(inode, dio_credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\tret = ext4_get_blocks(handle, inode, iblock, max_blocks, bh_result,\n\t\t\t      create);\n\tif (ret > 0) {\n\t\tbh_result->b_size = (ret << inode->i_blkbits);\n\t\tret = 0;\n\t}\n\text4_journal_stop(handle);\nout:\n\treturn ret;\n}", "target": 1}
{"code": "decode_sequence(const uint8_t *asn1, size_t len, const struct seq_info *seq,\n                void *val)\n{\n    krb5_error_code ret;\n    const uint8_t *contents;\n    size_t i, j, clen;\n    taginfo t;\n    assert(seq->n_fields > 0);\n    for (i = 0; i < seq->n_fields; i++) {\n        if (len == 0)\n            break;\n        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);\n        if (ret)\n            goto error;\n        for (; i < seq->n_fields; i++) {\n            if (check_atype_tag(seq->fields[i], &t))\n                break;\n            ret = omit_atype(seq->fields[i], val);\n            if (ret)\n                goto error;\n        }\n        if (i == seq->n_fields)\n            break;\n        ret = decode_atype(&t, contents, clen, seq->fields[i], val);\n        if (ret)\n            goto error;\n    }\n    for (; i < seq->n_fields; i++) {\n        ret = omit_atype(seq->fields[i], val);\n        if (ret)\n            goto error;\n    }\n    return 0;\nerror:\n    for (j = 0; j < i; j++)\n        free_atype(seq->fields[j], val);\n    for (j = 0; j < i; j++)\n        free_atype_ptr(seq->fields[j], val);\n    return ret;\n}", "target": 1}
{"code": "CHUNK_REMAINING_CAPACITY(const chunk_t *chunk)\n{\n  return (chunk->mem + chunk->memlen) - (chunk->data + chunk->datalen);\n}", "target": 0}
{"code": "static int adpt_i2o_issue_params(int cmd, adpt_hba* pHba, int tid, \n\t\t  void *opblk_va,  dma_addr_t opblk_pa, int oplen,\n\t\tvoid *resblk_va, dma_addr_t resblk_pa, int reslen)\n{\n\tu32 msg[9]; \n\tu32 *res = (u32 *)resblk_va;\n\tint wait_status;\n\tmsg[0] = NINE_WORD_MSG_SIZE | SGL_OFFSET_5;\n\tmsg[1] = cmd << 24 | HOST_TID << 12 | tid; \n\tmsg[2] = 0;\n\tmsg[3] = 0;\n\tmsg[4] = 0;\n\tmsg[5] = 0x54000000 | oplen;\t\n\tmsg[6] = (u32)opblk_pa;\n\tmsg[7] = 0xD0000000 | reslen;\t\n\tmsg[8] = (u32)resblk_pa;\n\tif ((wait_status = adpt_i2o_post_wait(pHba, msg, sizeof(msg), 20))) {\n\t\tprintk(\"adpt_i2o_issue_params: post_wait failed (%p)\\n\", resblk_va);\n   \t\treturn wait_status; \t\n\t}\n\tif (res[1]&0x00FF0000) { \t\n\t\tprintk(KERN_WARNING \"%s: %s - Error:\\n  ErrorInfoSize = 0x%02x, \"\n\t\t\t\"BlockStatus = 0x%02x, BlockSize = 0x%04x\\n\",\n\t\t\tpHba->name,\n\t\t\t(cmd == I2O_CMD_UTIL_PARAMS_SET) ? \"PARAMS_SET\"\n\t\t\t\t\t\t\t : \"PARAMS_GET\",   \n\t\t\tres[1]>>24, (res[1]>>16)&0xFF, res[1]&0xFFFF);\n\t\treturn -((res[1] >> 16) & 0xFF); \n\t}\n\treturn 4 + ((res[1] & 0x0000FFFF) << 2); \n}", "target": 1}
{"code": "static int mcryptd_create_hash(struct crypto_template *tmpl, struct rtattr **tb,\n\t\t\t      struct mcryptd_queue *queue)\n{\n\tstruct hashd_instance_ctx *ctx;\n\tstruct ahash_instance *inst;\n\tstruct hash_alg_common *halg;\n\tstruct crypto_alg *alg;\n\tu32 type = 0;\n\tu32 mask = 0;\n\tint err;\n\tmcryptd_check_internal(tb, &type, &mask);\n\thalg = ahash_attr_alg(tb[1], type, mask);\n\tif (IS_ERR(halg))\n\t\treturn PTR_ERR(halg);\n\talg = &halg->base;\n\tpr_debug(\"crypto: mcryptd hash alg: %s\\n\", alg->cra_name);\n\tinst = mcryptd_alloc_instance(alg, ahash_instance_headroom(),\n\t\t\t\t\tsizeof(*ctx));\n\terr = PTR_ERR(inst);\n\tif (IS_ERR(inst))\n\t\tgoto out_put_alg;\n\tctx = ahash_instance_ctx(inst);\n\tctx->queue = queue;\n\terr = crypto_init_ahash_spawn(&ctx->spawn, halg,\n\t\t\t\t      ahash_crypto_instance(inst));\n\tif (err)\n\t\tgoto out_free_inst;\n\ttype = CRYPTO_ALG_ASYNC;\n\tif (alg->cra_flags & CRYPTO_ALG_INTERNAL)\n\t\ttype |= CRYPTO_ALG_INTERNAL;\n\tinst->alg.halg.base.cra_flags = type;\n\tinst->alg.halg.digestsize = halg->digestsize;\n\tinst->alg.halg.statesize = halg->statesize;\n\tinst->alg.halg.base.cra_ctxsize = sizeof(struct mcryptd_hash_ctx);\n\tinst->alg.halg.base.cra_init = mcryptd_hash_init_tfm;\n\tinst->alg.halg.base.cra_exit = mcryptd_hash_exit_tfm;\n\tinst->alg.init   = mcryptd_hash_init_enqueue;\n\tinst->alg.update = mcryptd_hash_update_enqueue;\n\tinst->alg.final  = mcryptd_hash_final_enqueue;\n\tinst->alg.finup  = mcryptd_hash_finup_enqueue;\n\tinst->alg.export = mcryptd_hash_export;\n\tinst->alg.import = mcryptd_hash_import;\n\tinst->alg.setkey = mcryptd_hash_setkey;\n\tinst->alg.digest = mcryptd_hash_digest_enqueue;\n\terr = ahash_register_instance(tmpl, inst);\n\tif (err) {\n\t\tcrypto_drop_ahash(&ctx->spawn);\nout_free_inst:\n\t\tkfree(inst);\n\t}\nout_put_alg:\n\tcrypto_mod_put(alg);\n\treturn err;\n}", "target": 1}
{"code": "auth_line_is_begin (guint8 *line)\n{\n  guint8 next_char;\n  if (!g_str_has_prefix ((char *)line, AUTH_BEGIN))\n    return FALSE;\n  next_char = line[strlen (AUTH_BEGIN)];\n  return (next_char == 0 ||\n          next_char == ' ' ||\n          next_char == '\\t');\n}", "target": 0}
{"code": "exim_tvcmp(struct timeval *t1, struct timeval *t2)\n{\nif (t1->tv_sec > t2->tv_sec) return +1;\nif (t1->tv_sec < t2->tv_sec) return -1;\nif (t1->tv_usec > t2->tv_usec) return +1;\nif (t1->tv_usec < t2->tv_usec) return -1;\nreturn 0;\n}", "target": 0}
{"code": "AP_DECLARE(int) ap_some_authn_required(request_rec *r)\n{\n    int access_status;\n    switch (ap_satisfies(r)) {\n    case SATISFY_ALL:\n    case SATISFY_NOSPEC:\n        if ((access_status = ap_run_access_checker(r)) != OK) {\n            break;\n        }\n        access_status = ap_run_access_checker_ex(r);\n        if (access_status == DECLINED) {\n            return TRUE;\n        }\n        break;\n    case SATISFY_ANY:\n        if ((access_status = ap_run_access_checker(r)) == OK) {\n            break;\n        }\n        access_status = ap_run_access_checker_ex(r);\n        if (access_status == DECLINED) {\n            return TRUE;\n        }\n        break;\n    }\n    return FALSE;\n}", "target": 0}
{"code": "void LibRaw::remove_caseSubstr(char *string, char *subStr) \n{\n  char *found;\n  while ((found = strcasestr(string,subStr))) {\n    if (!found) return;\n    int fill_len = strlen(subStr);\n    int p = found - string;\n    for (int i=p; i<p+fill_len; i++) {\n      string[i] = 32;\n    }\n  }\n  trimSpaces (string);\n}", "target": 0}
{"code": "static int __mincore_unmapped_range(unsigned long addr, unsigned long end,\n\t\t\t\tstruct vm_area_struct *vma, unsigned char *vec)\n{\n\tunsigned long nr = (end - addr) >> PAGE_SHIFT;\n\tint i;\n\tif (vma->vm_file) {\n\t\tpgoff_t pgoff;\n\t\tpgoff = linear_page_index(vma, addr);\n\t\tfor (i = 0; i < nr; i++, pgoff++)\n\t\t\tvec[i] = mincore_page(vma->vm_file->f_mapping, pgoff);\n\t} else {\n\t\tfor (i = 0; i < nr; i++)\n\t\t\tvec[i] = 0;\n\t}\n\treturn nr;\n}", "target": 1}
{"code": "static int decode_server_caps(struct xdr_stream *xdr, struct nfs4_server_caps_res *res)\n{\n\tunsigned int savep;\n\tuint32_t attrlen, bitmap[3] = {0};\n\tint status;\n\tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_supported(xdr, bitmap, res->attr_bitmask)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_fh_expire_type(xdr, bitmap,\n\t\t\t\t\t\t &res->fh_expire_type)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_link_support(xdr, bitmap, &res->has_links)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_symlink_support(xdr, bitmap, &res->has_symlinks)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_aclsupport(xdr, bitmap, &res->acl_bitmask)) != 0)\n\t\tgoto xdr_error;\n\tstatus = verify_attr_len(xdr, savep, attrlen);\nxdr_error:\n\tdprintk(\"%s: xdr returned %d!\\n\", __func__, -status);\n\treturn status;\n}", "target": 0}
{"code": "static uint jsi_SizeOfArray(Jsi_Interp *interp, Jsi_Obj *obj) {\n    if (!obj || !obj->arr)\n        return 0;\n    return obj->arrCnt;\n}", "target": 0}
{"code": "bool ECDSA_Verification_Operation::verify(const uint8_t msg[], size_t msg_len,\n                                          const uint8_t sig[], size_t sig_len)\n   {\n   if(sig_len != m_group.get_order_bytes() * 2)\n      return false;\n   const BigInt e(msg, msg_len, m_group.get_order_bits());\n   const BigInt r(sig, sig_len / 2);\n   const BigInt s(sig + sig_len / 2, sig_len / 2);\n   if(r <= 0 || r >= m_group.get_order() || s <= 0 || s >= m_group.get_order())\n      return false;\n   const BigInt w = m_group.inverse_mod_order(s);\n   const BigInt u1 = m_group.multiply_mod_order(e, w);\n   const BigInt u2 = m_group.multiply_mod_order(r, w);\n   const PointGFp R = m_gy_mul.multi_exp(u1, u2);\n   if(R.is_zero())\n      return false;\n   const BigInt v = m_group.mod_order(R.get_affine_x());\n   return (v == r);\n   }", "target": 1}
{"code": "inline std::unique_ptr<Response> ClientImpl::send_with_content_provider(\n    Request &req, const char *body, size_t content_length,\n    ContentProvider content_provider,\n    ContentProviderWithoutLength content_provider_without_length,\n    const std::string &content_type, Error &error) {\n  if (!content_type.empty()) {\n    req.headers.emplace(\"Content-Type\", content_type);\n  }\n#ifdef CPPHTTPLIB_ZLIB_SUPPORT\n  if (compress_) { req.headers.emplace(\"Content-Encoding\", \"gzip\"); }\n#endif\n#ifdef CPPHTTPLIB_ZLIB_SUPPORT\n  if (compress_ && !content_provider_without_length) {\n    detail::gzip_compressor compressor;\n    if (content_provider) {\n      auto ok = true;\n      size_t offset = 0;\n      DataSink data_sink;\n      data_sink.write = [&](const char *data, size_t data_len) -> bool {\n        if (ok) {\n          auto last = offset + data_len == content_length;\n          auto ret = compressor.compress(\n              data, data_len, last,\n              [&](const char *compressed_data, size_t compressed_data_len) {\n                req.body.append(compressed_data, compressed_data_len);\n                return true;\n              });\n          if (ret) {\n            offset += data_len;\n          } else {\n            ok = false;\n          }\n        }\n        return ok;\n      };\n      while (ok && offset < content_length) {\n        if (!content_provider(offset, content_length - offset, data_sink)) {\n          error = Error::Canceled;\n          return nullptr;\n        }\n      }\n    } else {\n      if (!compressor.compress(body, content_length, true,\n                               [&](const char *data, size_t data_len) {\n                                 req.body.append(data, data_len);\n                                 return true;\n                               })) {\n        error = Error::Compression;\n        return nullptr;\n      }\n    }\n  } else\n#endif\n  {\n    if (content_provider) {\n      req.content_length_ = content_length;\n      req.content_provider_ = std::move(content_provider);\n      req.is_chunked_content_provider_ = false;\n    } else if (content_provider_without_length) {\n      req.content_length_ = 0;\n      req.content_provider_ = detail::ContentProviderAdapter(\n          std::move(content_provider_without_length));\n      req.is_chunked_content_provider_ = true;\n      req.headers.emplace(\"Transfer-Encoding\", \"chunked\");\n    } else {\n      req.body.assign(body, content_length);\n      ;\n    }\n  }\n  auto res = detail::make_unique<Response>();\n  return send(req, *res, error) ? std::move(res) : nullptr;\n}", "target": 1}
{"code": "sctp_disposition_t sctp_sf_ootb(struct net *net,\n\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\tvoid *arg,\n\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sk_buff *skb = chunk->skb;\n\tsctp_chunkhdr_t *ch;\n\tsctp_errhdr_t *err;\n\t__u8 *ch_end;\n\tint ootb_shut_ack = 0;\n\tint ootb_cookie_ack = 0;\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\tch = (sctp_chunkhdr_t *) chunk->chunk_hdr;\n\tdo {\n\t\tif (ntohs(ch->length) < sizeof(sctp_chunkhdr_t))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t\tif (SCTP_CID_SHUTDOWN_ACK == ch->type)\n\t\t\tootb_shut_ack = 1;\n\t\tif (SCTP_CID_ABORT == ch->type)\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\tif (SCTP_CID_COOKIE_ACK == ch->type)\n\t\t\tootb_cookie_ack = 1;\n\t\tif (SCTP_CID_ERROR == ch->type) {\n\t\t\tsctp_walk_errors(err, ch) {\n\t\t\t\tif (SCTP_ERROR_STALE_COOKIE == err->cause) {\n\t\t\t\t\tootb_cookie_ack = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));\n\t\tif (ch_end > skb_tail_pointer(skb))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t\tch = (sctp_chunkhdr_t *) ch_end;\n\t} while (ch_end < skb_tail_pointer(skb));\n\tif (ootb_shut_ack)\n\t\treturn sctp_sf_shut_8_4_5(net, ep, asoc, type, arg, commands);\n\telse if (ootb_cookie_ack)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\telse\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n}", "target": 1}
{"code": "is_note (Elf_Internal_Phdr *p, asection *s)\n{\n  return (p->p_type == PT_NOTE\n\t  && elf_section_type (s) == SHT_NOTE\n\t  && (ufile_ptr) s->filepos >= p->p_offset\n\t  && p->p_filesz >= s->size\n\t  && ((ufile_ptr) s->filepos - p->p_offset\n\t      <= p->p_filesz - s->size));\n}", "target": 0}
{"code": "static entity_table_opt determine_entity_table(int all, int doctype)\n{\n\tentity_table_opt retval = {NULL};\n\tassert(!(doctype == ENT_HTML_DOC_XML1 && all));\n\tif (all) {\n\t\tretval.ms_table = (doctype == ENT_HTML_DOC_HTML5) ?\n\t\t\tentity_ms_table_html5 : entity_ms_table_html4;\n\t} else {\n\t\tretval.table = (doctype == ENT_HTML_DOC_HTML401) ?\n\t\t\tstage3_table_be_noapos_00000 : stage3_table_be_apos_00000;\n\t}\n\treturn retval;\n}", "target": 0}
{"code": "static char *get_cert_prompt(TALLOC_CTX *mem_ctx,\n                             struct cert_auth_info *cert_info)\n{\n    int ret;\n    struct sss_certmap_ctx *ctx = NULL;\n    unsigned char *der = NULL;\n    size_t der_size;\n    char *prompt = NULL;\n    char *filter = NULL;\n    char **domains = NULL;\n    ret = sss_certmap_init(mem_ctx, NULL, NULL, &ctx);\n    if (ret != 0) {\n        DEBUG(SSSDBG_OP_FAILURE, \"sss_certmap_init failed.\\n\");\n        return NULL;\n    }\n    ret = sss_certmap_add_rule(ctx, 10, \"KRB5:<ISSUER>.*\",\n                               \"LDAP:{subject_dn!nss}\", NULL);\n    if (ret != 0) {\n        DEBUG(SSSDBG_OP_FAILURE, \"sss_certmap_add_rule failed.\\n\");\n        goto done;\n    }\n    der = sss_base64_decode(mem_ctx, sss_cai_get_cert(cert_info), &der_size);\n    if (der == NULL) {\n        DEBUG(SSSDBG_OP_FAILURE, \"sss_base64_decode failed.\\n\");\n        goto done;\n    }\n    ret = sss_certmap_get_search_filter(ctx, der, der_size, &filter, &domains);\n    if (ret != 0) {\n        DEBUG(SSSDBG_OP_FAILURE, \"sss_certmap_get_search_filter failed.\\n\");\n        goto done;\n    }\n    prompt = talloc_asprintf(mem_ctx, \"%s\\n%s\", sss_cai_get_label(cert_info),\n                                                filter);\n    if (prompt == NULL) {\n        DEBUG(SSSDBG_OP_FAILURE, \"talloc_strdup failed.\\n\");\n    }\ndone:\n    sss_certmap_free_filter_and_domains(filter, domains);\n    sss_certmap_free_ctx(ctx);\n    talloc_free(der);\n    return prompt;\n}", "target": 1}
{"code": "http_splitline(struct worker *w, int fd, struct http *hp,\n    const struct http_conn *htc, int h1, int h2, int h3)\n{\n\tchar *p, *q;\n\tCHECK_OBJ_NOTNULL(htc, HTTP_CONN_MAGIC);\n\tCHECK_OBJ_NOTNULL(hp, HTTP_MAGIC);\n\tTcheck(htc->rxbuf);\n\tfor (p = htc->rxbuf.b ; vct_islws(*p); p++)\n\t\tcontinue;\n\tq = p;\n\tfor (; !vct_issp(*p); p++) {\n\t\tif (vct_isctl(*p))\n\t\t\treturn (400);\n\t}\n\thp->hd[h1].b = q;\n\thp->hd[h1].e = p;\n\tfor (; vct_issp(*p); p++) {\n\t\tif (vct_isctl(*p))\n\t\t\treturn (400);\n\t}\n\tq = p;\n\tfor (; !vct_islws(*p); p++) {\n\t\tif (vct_isctl(*p))\n\t\t\treturn (400);\n\t}\n\thp->hd[h2].b = q;\n\thp->hd[h2].e = p;\n\tif (!Tlen(hp->hd[h2]))\n\t\treturn (400);\n\tfor (; vct_issp(*p); p++) {\n\t\tif (vct_isctl(*p))\n\t\t\treturn (400);\n\t}\n\tq = p;\n\tif (!vct_iscrlf(*p)) {\n\t\tfor (; !vct_iscrlf(*p); p++)\n\t\t\tif (!vct_issep(*p) && vct_isctl(*p))\n\t\t\t\treturn (400);\n\t}\n\thp->hd[h3].b = q;\n\thp->hd[h3].e = p;\n\tp += vct_skipcrlf(p);\n\t*hp->hd[h1].e = '\\0';\n\tWSLH(w, fd, hp, h1);\n\t*hp->hd[h2].e = '\\0';\n\tWSLH(w, fd, hp, h2);\n\tif (hp->hd[h3].e != NULL) {\n\t\t*hp->hd[h3].e = '\\0';\n\t\tWSLH(w, fd, hp, h3);\n\t}\n\treturn (http_dissect_hdrs(w, hp, fd, p, htc));\n}", "target": 1}
{"code": "static int iax2_poke_peer(struct iax2_peer *peer, int heldcall)\n{\n\tif (!peer->maxms || (!peer->addr.sin_addr.s_addr && !peer->dnsmgr)) {\n\t\tpeer->lastms = 0;\n\t\tpeer->historicms = 0;\n\t\tpeer->pokeexpire = -1;\n\t\tpeer->callno = 0;\n\t\treturn 0;\n\t}\n\tif (peer->callno > 0) {\n\t\tast_log(LOG_NOTICE, \"Still have a callno...\\n\");\n\t\tast_mutex_lock(&iaxsl[peer->callno]);\n\t\tiax2_destroy(peer->callno);\n\t\tast_mutex_unlock(&iaxsl[peer->callno]);\n\t}\n\tif (heldcall)\n\t\tast_mutex_unlock(&iaxsl[heldcall]);\n\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);\n\tif (heldcall)\n\t\tast_mutex_lock(&iaxsl[heldcall]);\n\tif (peer->callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to allocate call for poking peer '%s'\\n\", peer->name);\n\t\treturn -1;\n\t}\n\tiaxs[peer->callno]->pingtime = peer->maxms / 4 + 1;\n\tiaxs[peer->callno]->peerpoke = peer;\n \tif (peer->pokeexpire > -1) {\n \t\tif (!ast_sched_del(sched, peer->pokeexpire)) {\n \t\t\tpeer->pokeexpire = -1;\n \t\t\tpeer_unref(peer);\n \t\t}\n \t}\n\tif (peer->lastms < 0)\n \t\tpeer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_noanswer, peer_ref(peer));\n\telse\n \t\tpeer->pokeexpire = iax2_sched_add(sched, DEFAULT_MAXMS * 2, iax2_poke_noanswer, peer_ref(peer));\n \tif (peer->pokeexpire == -1)\n \t\tpeer_unref(peer);\n\tsend_command(iaxs[peer->callno], AST_FRAME_IAX, IAX_COMMAND_POKE, 0, NULL, 0, -1);\n\treturn 0;\n}", "target": 1}
{"code": "get_indent_lnum(linenr_T lnum)\n{\n#ifdef FEAT_VARTABS\n    return get_indent_str_vtab(ml_get(lnum), (int)curbuf->b_p_ts,\n\t\t\t\t\t\t curbuf->b_p_vts_array, FALSE);\n#else\n    return get_indent_str(ml_get(lnum), (int)curbuf->b_p_ts, FALSE);\n#endif\n}", "target": 0}
{"code": "void ThreadWatcher::StartWatching(const WatchingParams& params) {\n  DCHECK_GE(params.sleep_time.InMilliseconds(), 0);\n  DCHECK_GE(params.unresponsive_time.InMilliseconds(),\n            params.sleep_time.InMilliseconds());\n  if (!WatchDogThread::CurrentlyOnWatchDogThread()) {\n    WatchDogThread::PostTask(\n        FROM_HERE,\n        base::Bind(&ThreadWatcher::StartWatching, params));\n    return;\n  }\n  DCHECK(WatchDogThread::CurrentlyOnWatchDogThread());\n  ThreadWatcher* watcher = new ThreadWatcher(params);\n  DCHECK(watcher);\n  if (!ThreadWatcherList::IsRegistered(params.thread_id))\n    return;\n  watcher->ActivateThreadWatching();\n}", "target": 0}
{"code": "static void cma_id_get(struct rdma_id_private *id_priv)\n{\n\trefcount_inc(&id_priv->refcount);\n}", "target": 0}
{"code": "ip_printts(netdissect_options *ndo,\n           register const u_char *cp, u_int length)\n{\n\tregister u_int ptr;\n\tregister u_int len;\n\tint hoplen;\n\tconst char *type;\n\tif (length < 4) {\n\t\tND_PRINT((ndo, \"[bad length %u]\", length));\n\t\treturn;\n\t}\n\tND_PRINT((ndo, \" TS{\"));\n\thoplen = ((cp[3]&0xF) != IPOPT_TS_TSONLY) ? 8 : 4;\n\tif ((length - 4) & (hoplen-1))\n\t\tND_PRINT((ndo, \"[bad length %u]\", length));\n\tptr = cp[2] - 1;\n\tlen = 0;\n\tif (ptr < 4 || ((ptr - 4) & (hoplen-1)) || ptr > length + 1)\n\t\tND_PRINT((ndo, \"[bad ptr %u]\", cp[2]));\n\tswitch (cp[3]&0xF) {\n\tcase IPOPT_TS_TSONLY:\n\t\tND_PRINT((ndo, \"TSONLY\"));\n\t\tbreak;\n\tcase IPOPT_TS_TSANDADDR:\n\t\tND_PRINT((ndo, \"TS+ADDR\"));\n\t\tbreak;\n\tcase 2:\n\t\tND_PRINT((ndo, \"PRESPEC2.0\"));\n\t\tbreak;\n\tcase 3:\t\t\t\n\t\tND_PRINT((ndo, \"PRESPEC\"));\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"[bad ts type %d]\", cp[3]&0xF));\n\t\tgoto done;\n\t}\n\ttype = \" \";\n\tfor (len = 4; len < length; len += hoplen) {\n\t\tif (ptr == len)\n\t\t\ttype = \" ^ \";\n\t\tND_PRINT((ndo, \"%s%d@%s\", type, EXTRACT_32BITS(&cp[len+hoplen-4]),\n\t\t       hoplen!=8 ? \"\" : ipaddr_string(ndo, &cp[len])));\n\t\ttype = \" \";\n\t}\ndone:\n\tND_PRINT((ndo, \"%s\", ptr == len ? \" ^ \" : \"\"));\n\tif (cp[3]>>4)\n\t\tND_PRINT((ndo, \" [%d hops not recorded]} \", cp[3]>>4));\n\telse\n\t\tND_PRINT((ndo, \"}\"));\n}", "target": 1}
{"code": "static void* my_gballoc_calloc(size_t nmemb, size_t size)\n{\n    return calloc(nmemb, size);\n}", "target": 0}
{"code": "COMPAT_SYSCALL_DEFINE5(waitid,\n\t\tint, which, compat_pid_t, pid,\n\t\tstruct compat_siginfo __user *, infop, int, options,\n\t\tstruct compat_rusage __user *, uru)\n{\n\tstruct rusage ru;\n\tstruct waitid_info info = {.status = 0};\n\tlong err = kernel_waitid(which, pid, &info, options, uru ? &ru : NULL);\n\tint signo = 0;\n\tif (err > 0) {\n\t\tsigno = SIGCHLD;\n\t\terr = 0;\n\t}\n\tif (!err && uru) {\n\t\tif (COMPAT_USE_64BIT_TIME)\n\t\t\terr = copy_to_user(uru, &ru, sizeof(ru));\n\t\telse\n\t\t\terr = put_compat_rusage(&ru, uru);\n\t\tif (err)\n\t\t\treturn -EFAULT;\n\t}\n\tif (!infop)\n\t\treturn err;\n\tuser_access_begin();\n\tunsafe_put_user(signo, &infop->si_signo, Efault);\n\tunsafe_put_user(0, &infop->si_errno, Efault);\n\tunsafe_put_user(info.cause, &infop->si_code, Efault);\n\tunsafe_put_user(info.pid, &infop->si_pid, Efault);\n\tunsafe_put_user(info.uid, &infop->si_uid, Efault);\n\tunsafe_put_user(info.status, &infop->si_status, Efault);\n\tuser_access_end();\n\treturn err;\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}", "target": 1}
{"code": "NOEXPORT void tray_update(const int num) {\n    NOTIFYICONDATA nid;\n    static ICON_TYPE previous_icon=ICON_NONE;\n    ICON_TYPE current_icon;\n    LPTSTR tip;\n    if(!global_options.option.taskbar) { \n        tray_delete(); \n        return;\n    }\n    if(!tray_menu_handle) \n        tray_menu_handle=LoadMenu(ghInst, MAKEINTRESOURCE(IDM_TRAYMENU));\n    if(!tray_menu_handle) {\n        ioerror(\"LoadMenu\");\n        return;\n    }\n    if(cmdline.service)\n        EnableMenuItem(tray_menu_handle, IDM_EDIT_CONFIG, MF_GRAYED);\n    ZeroMemory(&nid, sizeof nid);\n    nid.cbSize=sizeof nid;\n    nid.uID=1; \n    nid.uFlags=NIF_MESSAGE|NIF_TIP;\n    nid.uCallbackMessage=WM_SYSTRAY; \n    nid.hWnd=hwnd; \n    if(num<0) {\n        tip=str_tprintf(TEXT(\"Server is down\"));\n        current_icon=ICON_ERROR;\n    } else if(num>0) {\n        tip=str_tprintf(TEXT(\"%d active session(s)\"), num);\n        current_icon=ICON_ACTIVE;\n    } else {\n        tip=str_tprintf(TEXT(\"Server is idle\"));\n        current_icon=ICON_IDLE;\n    }\n    _tcsncpy(nid.szTip, tip, 63);\n    nid.szTip[63]=TEXT('\\0');\n    str_free(tip);\n    nid.hIcon=global_options.icon[current_icon];\n    if(current_icon!=previous_icon) {\n        nid.uFlags|=NIF_ICON;\n        previous_icon=current_icon;\n    }\n    if(Shell_NotifyIcon(NIM_MODIFY, &nid)) \n        return; \n    nid.uFlags|=NIF_ICON;\n    Shell_NotifyIcon(NIM_ADD, &nid);\n}", "target": 1}
{"code": "void RootWindowHostWin::OnPaint(HDC dc) {\n  root_window_->Draw();\n  ValidateRect(hwnd(), NULL);\n}", "target": 0}
{"code": "GF_Err dfla_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_FLACConfigBox *ptr = (GF_FLACConfigBox *) s;\n\tptr->dataSize = (u32) ptr->size;\n\tptr->size=0;\n\tptr->data = gf_malloc(ptr->dataSize);\n\tgf_bs_read_data(bs, ptr->data, ptr->dataSize);\n\treturn GF_OK;\n}", "target": 0}
{"code": "void Splash::setOverprintMask(Guint overprintMask, GBool additive) {\n  state->overprintMask = overprintMask;\n  state->overprintAdditive = additive;\n}", "target": 0}
{"code": "isdn_receive_skb_callback(int di, int channel, struct sk_buff *skb)\n{\n\tint i;\n\tif ((i = isdn_dc2minor(di, channel)) == -1) {\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\tdev->ibytes[i] += skb->len;\n\tif (isdn_net_rcv_skb(i, skb))\n\t\treturn;\n\tif (dev->v110[i]) {\n\t\tatomic_inc(&dev->v110use[i]);\n\t\tskb = isdn_v110_decode(dev->v110[i], skb);\n\t\tatomic_dec(&dev->v110use[i]);\n\t\tif (!skb)\n\t\t\treturn;\n\t}\n\tif (skb->len) {\n\t\tif (isdn_tty_rcv_skb(i, di, channel, skb))\n\t\t\treturn;\n\t\twake_up_interruptible(&dev->drv[di]->rcv_waitq[channel]);\n\t} else\n\t\tdev_kfree_skb(skb);\n}", "target": 0}
{"code": "void GLES2DecoderImpl::DeleteRenderbuffersHelper(\n    GLsizei n, const GLuint* client_ids) {\n  for (GLsizei ii = 0; ii < n; ++ii) {\n    RenderbufferManager::RenderbufferInfo* info =\n        GetRenderbufferInfo(client_ids[ii]);\n    if (info) {\n      GLuint service_id = info->service_id();\n      glDeleteRenderbuffersEXT(1, &service_id);\n      RemoveRenderbufferInfo(client_ids[ii]);\n    }\n  }\n}", "target": 0}
{"code": "static void ext_session_lock_v1_handle_locked(void *data, struct ext_session_lock_v1 *lock) {\n}", "target": 0}
{"code": "static void enable_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tif (vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) & GUEST_INTR_STATE_STI) {\n\t\tenable_irq_window(vcpu);\n\t\treturn;\n\t}\n\tvmcs_set_bits(CPU_BASED_VM_EXEC_CONTROL,\n\t\t      CPU_BASED_VIRTUAL_NMI_PENDING);\n}", "target": 0}
{"code": "static int mpeg4video_probe(AVProbeData *probe_packet)\n{\n    uint32_t temp_buffer = -1;\n    int VO = 0, VOL = 0, VOP = 0, VISO = 0, res = 0;\n    int i;\n    for (i = 0; i < probe_packet->buf_size; i++) {\n        temp_buffer = (temp_buffer << 8) + probe_packet->buf[i];\n        if ((temp_buffer & 0xffffff00) != 0x100)\n            continue;\n        if (temp_buffer == VOP_START_CODE)\n            VOP++;\n        else if (temp_buffer == VISUAL_OBJECT_START_CODE)\n            VISO++;\n        else if (temp_buffer < 0x120)\n            VO++;\n        else if (temp_buffer < 0x130)\n            VOL++;\n        else if (!(0x1AF < temp_buffer && temp_buffer < 0x1B7) &&\n                 !(0x1B9 < temp_buffer && temp_buffer < 0x1C4))\n            res++;\n    }\n    if (VOP >= VISO && VOP >= VOL && VO >= VOL && VOL > 0 && res == 0)\n        return AVPROBE_SCORE_EXTENSION;\n    return 0;\n}", "target": 1}
{"code": "  erase_all_clients() {\n    map_id_client.clear();\n    cert_chain.clear();\n    save_state();\n  }", "target": 0}
{"code": "void PDFiumEngine::FinishPaint(int progressive_index,\n                               pp::ImageData* image_data) {\n  DCHECK_GE(progressive_index, 0);\n  DCHECK_LT(static_cast<size_t>(progressive_index), progressive_paints_.size());\n  DCHECK(image_data);\n  int page_index = progressive_paints_[progressive_index].page_index;\n  pp::Rect dirty_in_screen = progressive_paints_[progressive_index].rect;\n  FPDF_BITMAP bitmap = progressive_paints_[progressive_index].bitmap;\n  int start_x, start_y, size_x, size_y;\n  GetPDFiumRect(\n      page_index, dirty_in_screen, &start_x, &start_y, &size_x, &size_y);\n  FPDF_FFLDraw(\n      form_, bitmap, pages_[page_index]->GetPage(), start_x, start_y, size_x,\n      size_y, current_rotation_, GetRenderingFlags());\n  FillPageSides(progressive_index);\n  PaintPageShadow(progressive_index, image_data);\n  DrawSelections(progressive_index, image_data);\n  FPDF_RenderPage_Close(pages_[page_index]->GetPage());\n  FPDFBitmap_Destroy(bitmap);\n  progressive_paints_.erase(progressive_paints_.begin() + progressive_index);\n  client_->DocumentPaintOccurred();\n}", "target": 0}
{"code": "static void _clean_slate_datagram(gnrc_sixlowpan_frag_fb_t *fbuf)\n{\n    clist_node_t new_queue = { .next = NULL };\n    fbuf->sfr.arq_timeout_event.msg.content.ptr = NULL;\n    evtimer_del((evtimer_t *)(&_arq_timer),\n                &fbuf->sfr.arq_timeout_event.event);\n    fbuf->sfr.arq_timeout_event.event.next = NULL;\n    if (gnrc_sixlowpan_frag_sfr_congure_snd_has_inter_frame_gap()) {\n        for (clist_node_t *node = clist_lpop(&_frame_queue);\n             node != NULL; node = clist_lpop(&_frame_queue)) {\n            _frame_queue_t *entry = (_frame_queue_t *)node;\n            if (entry->datagram_tag == fbuf->tag) {\n                gnrc_pktbuf_release(entry->frame);\n                entry->frame = NULL;\n                clist_rpush(&_frag_descs_free, node);\n            }\n            else {\n                clist_rpush(&new_queue, node);\n            }\n        }\n        _frame_queue = new_queue;\n    }\n    fbuf->offset = 0U;\n    fbuf->sfr.cur_seq = 0U;\n    fbuf->sfr.frags_sent = 0U;\n    for (clist_node_t *node = clist_lpop(&fbuf->sfr.window);\n         node != NULL; node = clist_lpop(&fbuf->sfr.window)) {\n        clist_rpush(&_frag_descs_free, node);\n    }\n}", "target": 1}
{"code": "static int xfrm6_tunnel_rcv(struct sk_buff *skb)\n{\n\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n\t__be32 spi;\n\tspi = xfrm6_tunnel_spi_lookup((xfrm_address_t *)&iph->saddr);\n\treturn xfrm6_rcv_spi(skb, spi);\n}", "target": 1}
{"code": "static int hashtable_do_rehash(hashtable_t *hashtable)\n{\n    list_t *list, *next;\n    pair_t *pair;\n    size_t i, index, new_size;\n    jsonp_free(hashtable->buckets);\n    hashtable->num_buckets++;\n    new_size = num_buckets(hashtable);\n    hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));\n    if(!hashtable->buckets)\n        return -1;\n    for(i = 0; i < num_buckets(hashtable); i++)\n    {\n        hashtable->buckets[i].first = hashtable->buckets[i].last =\n            &hashtable->list;\n    }\n    list = hashtable->list.next;\n    list_init(&hashtable->list);\n    for(; list != &hashtable->list; list = next) {\n        next = list->next;\n        pair = list_to_pair(list);\n        index = pair->hash % new_size;\n        insert_to_bucket(hashtable, &hashtable->buckets[index], &pair->list);\n    }\n    return 0;\n}", "target": 1}
{"code": "u_int32_t ndpi_bytestream_to_ipv4(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read) {\n  u_int32_t val;\n  u_int16_t read = 0;\n  u_int16_t oldread;\n  u_int32_t c;\n  oldread = read;\n  c = ndpi_bytestream_to_number(str, max_chars_to_read, &read);\n  if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')\n    return(0);\n  read++;\n  val = c << 24;\n  oldread = read;\n  c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);\n  if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')\n    return(0);\n  read++;\n  val = val + (c << 16);\n  oldread = read;\n  c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);\n  if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')\n    return(0);\n  read++;\n  val = val + (c << 8);\n  oldread = read;\n  c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);\n  if(c > 255 || oldread == read || max_chars_to_read == read)\n    return(0);\n  val = val + c;\n  *bytes_read = *bytes_read + read;\n  return(htonl(val));\n}", "target": 0}
{"code": "static apr_byte_t oidc_validate_post_logout_url(request_rec *r, const char *url,\n\t\tchar **err_str, char **err_desc) {\n\tapr_uri_t uri;\n\tconst char *c_host = NULL;\n\tif (apr_uri_parse(r->pool, url, &uri) != APR_SUCCESS) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n\t\t*err_desc = apr_psprintf(r->pool, \"Logout URL malformed: %s\", url);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t}\n\tc_host = oidc_get_current_url_host(r);\n\tif ((uri.hostname != NULL)\n\t\t\t&& ((strstr(c_host, uri.hostname) == NULL)\n\t\t\t\t\t|| (strstr(uri.hostname, c_host) == NULL))) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Invalid Request\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"logout value \\\"%s\\\" does not match the hostname of the current request \\\"%s\\\"\",\n\t\t\t\t\t\tapr_uri_unparse(r->pool, &uri, 0), c_host);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t} else if ((uri.hostname == NULL) && (strstr(url, \"/\") != url)) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"No hostname was parsed and it does not seem to be relative, i.e starting with '/': %s\",\n\t\t\t\t\t\turl);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t}\n\tif (((strstr(url, \"\\n\") != NULL) || strstr(url, \"\\r\") != NULL)) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Invalid Request\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"logout value \\\"%s\\\" contains illegal \\\"\\n\\\" or \\\"\\r\\\" character(s)\",\n\t\t\t\t\t\turl);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 0}
{"code": "TEST(SpecializeType, ForEachRejectsMalformedInput) {\n  OpDef op;\n  FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();\n  t->set_type_id(TFT_FOR_EACH);\n  t->add_args()->set_type_id(TFT_PRODUCT);\n  NodeDef ndef;\n  AttrSlice attrs(ndef);\n  FullTypeDef ft;\n  EXPECT_FALSE(SpecializeType(attrs, op, ft).ok());\n}", "target": 0}
{"code": "DLLIMPORT const char *cfg_title(cfg_t *cfg)\n{\n\tif (cfg)\n\t\treturn cfg->title;\n\treturn NULL;\n}", "target": 0}
{"code": "mp_capable_print(netdissect_options *ndo,\n                 const u_char *opt, u_int opt_len, u_char flags)\n{\n        const struct mp_capable *mpc = (const struct mp_capable *) opt;\n        if (!(opt_len == 12 && flags & TH_SYN) &&\n            !(opt_len == 20 && (flags & (TH_SYN | TH_ACK)) == TH_ACK))\n                return 0;\n        if (MP_CAPABLE_OPT_VERSION(mpc->sub_ver) != 0) {\n                ND_PRINT((ndo, \" Unknown Version (%d)\", MP_CAPABLE_OPT_VERSION(mpc->sub_ver)));\n                return 1;\n        }\n        if (mpc->flags & MP_CAPABLE_C)\n                ND_PRINT((ndo, \" csum\"));\n        ND_PRINT((ndo, \" {0x%\" PRIx64, EXTRACT_64BITS(mpc->sender_key)));\n        if (opt_len == 20) \n                ND_PRINT((ndo, \",0x%\" PRIx64, EXTRACT_64BITS(mpc->receiver_key)));\n        ND_PRINT((ndo, \"}\"));\n        return 1;\n}", "target": 1}
{"code": "void Statement::GetRow(Row* row, sqlite3_stmt* stmt) {\n    int rows = sqlite3_column_count(stmt);\n    for (int i = 0; i < rows; i++) {\n        int type = sqlite3_column_type(stmt, i);\n        const char* name = sqlite3_column_name(stmt, i);\n        switch (type) {\n            case SQLITE_INTEGER: {\n                row->push_back(new Values::Integer(name, sqlite3_column_int64(stmt, i)));\n            }   break;\n            case SQLITE_FLOAT: {\n                row->push_back(new Values::Float(name, sqlite3_column_double(stmt, i)));\n            }   break;\n            case SQLITE_TEXT: {\n                const char* text = (const char*)sqlite3_column_text(stmt, i);\n                int length = sqlite3_column_bytes(stmt, i);\n                row->push_back(new Values::Text(name, length, text));\n            } break;\n            case SQLITE_BLOB: {\n                const void* blob = sqlite3_column_blob(stmt, i);\n                int length = sqlite3_column_bytes(stmt, i);\n                row->push_back(new Values::Blob(name, length, blob));\n            }   break;\n            case SQLITE_NULL: {\n                row->push_back(new Values::Null(name));\n            }   break;\n            default:\n                assert(false);\n        }\n    }\n}", "target": 0}
{"code": "read_mysql_variables_from_result(MYSQL_RES *mysql_result, mysql_variable *vars,\n\tbool vertical_result)\n{\n\tMYSQL_ROW row;\n\tmysql_variable *var;\n\tut_ad(!vertical_result || mysql_num_fields(mysql_result) == 2);\n\tint rows_read = 0;\n\tif (vertical_result) {\n\t\twhile ((row = mysql_fetch_row(mysql_result))) {\n\t\t\t++rows_read;\n\t\t\tchar *name = row[0];\n\t\t\tchar *value = row[1];\n\t\t\tfor (var = vars; var->name; var++) {\n\t\t\t\tif (strcmp(var->name, name) == 0\n\t\t\t\t    && value != NULL) {\n\t\t\t\t\t*(var->value) = strdup(value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tMYSQL_FIELD *field;\n\t\tif ((row = mysql_fetch_row(mysql_result)) != NULL) {\n\t\t\tmysql_field_seek(mysql_result, 0);\n\t\t\t++rows_read;\n\t\t\tint i = 0;\n\t\t\twhile ((field = mysql_fetch_field(mysql_result))\n\t\t\t\t!= NULL) {\n\t\t\t\tchar *name = field->name;\n\t\t\t\tchar *value = row[i];\n\t\t\t\tfor (var = vars; var->name; var++) {\n\t\t\t\t\tif (strcmp(var->name, name) == 0\n\t\t\t\t\t    && value != NULL) {\n\t\t\t\t\t\t*(var->value) = strdup(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t}\n\treturn rows_read;\n}", "target": 0}
{"code": "static BOOL handle_SSH2_newkeys(PTInstVar pvar)\n{\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_NEWKEYS was received(DH key generation is completed).\");\n\tif (LogLevel(pvar, LOG_LEVEL_SSHDUMP)) {\n\t\tsave_memdump(LOGDUMP);\n\t}\n\tfinish_memdump();\n\tpvar->kex_status |= KEX_FLAG_NEWKEYS_RECEIVED;\n\tssh2_set_newkeys(pvar, MODE_IN);\n\tif (!CRYPT_start_encryption(pvar, 0, 1)) {\n\t}\n\tpvar->ssh2_keys[MODE_IN].mac.enabled = 1;\n\tpvar->ssh2_keys[MODE_IN].comp.enabled = 1;\n\tenable_recv_compression(pvar);\n\tif (pvar->server_strict_kex) {\n\t\tpvar->ssh_state.receiver_sequence_number = 0;\n\t}\n\tSSH2_dispatch_add_message(SSH2_MSG_EXT_INFO);\n\tif (pvar->kex_status & KEX_FLAG_NEWKEYS_SENT) {\n\t\tif (pvar->kex_status & KEX_FLAG_REKEYING) {\n\t\t\tint i;\n\t\t\tChannel_t *c;\n\t\t\tdo_SSH2_dispatch_setup_for_transfer(pvar);\n\t\t\tfor (i = 0 ; i < CHANNEL_MAX ; i++) {\n\t\t\t\tc = &channels[i];\n\t\t\t\tif (c->used) {\n\t\t\t\t\tssh2_channel_retry_send_bufchain(pvar, c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tssh2_finish_encryption_setup(pvar);\n\t\t\tssh2_prep_userauth(pvar);\n\t\t}\n\t\tpvar->kex_status = KEX_FLAG_KEXDONE;\n\t}\n\treturn TRUE;\n}", "target": 0}
{"code": "static LINK_HANDLE create_link(role link_role)\n{\n    umock_c_reset_all_calls();\n    STRICT_EXPECTED_CALL(gballoc_calloc(IGNORED_NUM_ARG, IGNORED_NUM_ARG));\n    STRICT_EXPECTED_CALL(amqpvalue_clone(IGNORED_PTR_ARG));\n    STRICT_EXPECTED_CALL(amqpvalue_clone(IGNORED_PTR_ARG));\n    STRICT_EXPECTED_CALL(tickcounter_create());\n    STRICT_EXPECTED_CALL(singlylinkedlist_create());\n    STRICT_EXPECTED_CALL(gballoc_malloc(IGNORED_NUM_ARG));\n    STRICT_EXPECTED_CALL(session_create_link_endpoint(TEST_SESSION_HANDLE, TEST_LINK_NAME_1));\n    STRICT_EXPECTED_CALL(session_set_link_endpoint_callback(TEST_LINK_ENDPOINT, IGNORED_PTR_ARG, IGNORED_PTR_ARG));\n    return link_create(TEST_SESSION_HANDLE, TEST_LINK_NAME_1, link_role, TEST_LINK_SOURCE, TEST_LINK_TARGET);\n}", "target": 0}
{"code": "cleanup_pathname(struct archive_write_disk *a)\n{\n\tstruct archive_string error_string;\n\tint error_number;\n\tint rc;\n\tarchive_string_init(&error_string);\n\trc = cleanup_pathname_fsobj(a->name, &error_number, &error_string, a->flags);\n\tif (rc != ARCHIVE_OK) {\n\t\tarchive_set_error(&a->archive, error_number, \"%s\", error_string.s);\n\t}\n\tarchive_string_free(&error_string);\n\treturn rc;\n}", "target": 0}
{"code": "ssh_packet_set_compress_hooks(struct ssh *ssh, void *ctx,\n    void *(*allocfunc)(void *, u_int, u_int),\n    void (*freefunc)(void *, void *))\n{\n\tssh->state->compression_out_stream.zalloc = (alloc_func)allocfunc;\n\tssh->state->compression_out_stream.zfree = (free_func)freefunc;\n\tssh->state->compression_out_stream.opaque = ctx;\n\tssh->state->compression_in_stream.zalloc = (alloc_func)allocfunc;\n\tssh->state->compression_in_stream.zfree = (free_func)freefunc;\n\tssh->state->compression_in_stream.opaque = ctx;\n}", "target": 1}
{"code": "static unsigned int get_exif_ui32(struct iw_exif_state *e, unsigned int pos)\n{\n\tif(e->d_len<4 || pos>e->d_len-4) return 0;\n\treturn iw_get_ui32_e(&e->d[pos], e->endian);\n}", "target": 0}
{"code": "TEST_P(MultiplexedRingHashIntegrationTest,\n       CookieRoutingNoCookieWithNonzeroTtlSetAndWithAttributes) {\n  config_helper_.addConfigModifier(\n      [&](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n              hcm) -> void {\n        auto* hash_policy = hcm.mutable_route_config()\n                                ->mutable_virtual_hosts(0)\n                                ->mutable_routes(0)\n                                ->mutable_route()\n                                ->add_hash_policy();\n        auto* cookie = hash_policy->mutable_cookie();\n        cookie->set_name(\"foo\");\n        cookie->mutable_ttl()->set_seconds(15);\n        auto* attribute_1 = cookie->mutable_attributes()->Add();\n        attribute_1->set_name(\"test1\");\n        attribute_1->set_value(\"value1\");\n        auto* attribute_2 = cookie->mutable_attributes()->Add();\n        attribute_2->set_name(\"test2\");\n        attribute_2->set_value(\"value2\");\n      });\n  std::set<std::string> set_cookies;\n  sendMultipleRequests(\n      1024,\n      Http::TestRequestHeaderMapImpl{{\":method\", \"POST\"},\n                                     {\":path\", \"/test/long/url\"},\n                                     {\":scheme\", \"http\"},\n                                     {\":authority\", \"host\"}},\n      [&](IntegrationStreamDecoder& response) {\n        EXPECT_EQ(\"200\", response.headers().getStatusValue());\n        std::string value(\n            response.headers().get(Http::Headers::get().SetCookie)[0]->value().getStringView());\n        set_cookies.insert(value);\n        EXPECT_THAT(value,\n                    MatchesRegex(\"foo=.*; Max-Age=15; test1=value1; test2=value2; HttpOnly\"));\n      });\n  EXPECT_EQ(set_cookies.size(), 1);\n}", "target": 0}
{"code": "void big_key_describe(const struct key *key, struct seq_file *m)\n{\n\tsize_t datalen = (size_t)key->payload.data[big_key_len];\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \": %zu [%s]\",\n\t\t\t   datalen,\n\t\t\t   datalen > BIG_KEY_FILE_THRESHOLD ? \"file\" : \"buff\");\n}", "target": 1}
{"code": "DECLAREreadFunc(readContigTilesIntoBuffer)\n{\n\tint status = 1;\n\ttsize_t tilesize = TIFFTileSize(in);\n\ttdata_t tilebuf;\n\tuint32 imagew = TIFFScanlineSize(in);\n\tuint32 tilew  = TIFFTileRowSize(in);\n\tint iskew = imagew - tilew;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tw, tl;\n\tuint32 row;\n\t(void) spp;\n\ttilebuf = _TIFFmalloc(tilesize);\n\tif (tilebuf == 0)\n\t\treturn 0;\n\t_TIFFmemset(tilebuf, 0, tilesize);\n\t(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n\t(void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n\tfor (row = 0; row < imagelength; row += tl) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\t\tfor (col = 0; col < imagewidth; col += tw) {\n\t\t\tif (TIFFReadTile(in, tilebuf, col, row, 0, 0) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read tile at %lu %lu\",\n\t\t\t\t    (unsigned long) col,\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (colb + tilew > imagew) {\n\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\tuint32 oskew = tilew - width;\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, width,\n\t\t\t\t    oskew + iskew, oskew );\n\t\t\t} else\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, tilew,\n\t\t\t\t    iskew, 0);\n\t\t\tcolb += tilew;\n\t\t}\n\t\tbufp += imagew * nrow;\n\t}\ndone:\n\t_TIFFfree(tilebuf);\n\treturn status;\n}", "target": 1}
{"code": "void NumberFormatTest::Test20037_ScientificIntegerOverflow() {\n    IcuTestErrorCode status(*this, \"Test20037_ScientificIntegerOverflow\");\n    LocalPointer<NumberFormat> nf(NumberFormat::createInstance(status));\n    if (U_FAILURE(status)) {\n        dataerrln(\"Unable to create NumberFormat instance.\");\n        return;\n    }\n    Formattable result;\n    nf->parse(u\"1E-2147483648\", result, status);\n    StringPiece sp = result.getDecimalNumber(status);\n    assertEquals(u\"Should snap to zero\",\n                 u\"0\",\n                 {sp.data(), sp.length(), US_INV});\n    result = Formattable();\n    nf->parse(u\"1E-2147483647E-1\", result, status);\n    sp = result.getDecimalNumber(status);\n    assertEquals(u\"Should not overflow and should parse only the first exponent\",\n                 u\"1E-2147483647\",\n                 {sp.data(), sp.length(), US_INV});\n    result = Formattable();\n    nf->parse(u\".0003e-2147483644\", result, status);\n    sp = result.getDecimalNumber(status);\n    assertEquals(u\"Should not overflow\",\n                 u\"3E-2147483648\",\n                 {sp.data(), sp.length(), US_INV});\n}", "target": 0}
{"code": "    std::string& attrf(int ncid, int varId, const char * attrName, std::string& alloc)\n    {\n        alloc = \"\";\n        size_t len = 0;\n        nc_inq_attlen(ncid, varId, attrName, &len);\n        if(len < 1)\n        {\n            return alloc;\n        }\n        char attr_vals[NC_MAX_NAME + 1];\n        memset(attr_vals, 0, NC_MAX_NAME + 1);\n        if(nc_get_att_text(ncid, varId, attrName, attr_vals) != NC_NOERR)\n        {\n            return alloc;\n        }\n        alloc = std::string(attr_vals);\n        return alloc;\n    }", "target": 1}
{"code": "wsemul_sun_output_control(struct wsemul_sun_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tint oargs;\n\tint rc;\n\tswitch (instate->inchar) {\n\tcase '0': case '1': case '2': case '3': case '4': \n\tcase '5': case '6': case '7': case '8': case '9':\n\t\tif (edp->nargs > SUN_EMUL_NARGS - 1) {\n\t\t\tbcopy(edp->args + 1, edp->args,\n\t\t\t    (SUN_EMUL_NARGS - 1) * sizeof(edp->args[0]));\n\t\t\tedp->args[edp->nargs = SUN_EMUL_NARGS - 1] = 0;\n\t\t}\n\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\tcase ';':\t\t\n\t\tedp->nargs++;\n\t\tbreak;\n\tdefault:\t\t\n\t\toargs = edp->nargs++;\n\t\tif (edp->nargs > SUN_EMUL_NARGS)\n\t\t\tedp->nargs = SUN_EMUL_NARGS;\n\t\trc = wsemul_sun_control(edp, instate);\n\t\tif (rc != 0) {\n\t\t\tedp->nargs = oargs;\n\t\t\treturn rc;\n\t\t}\n\t\tedp->state = SUN_EMUL_STATE_NORMAL;\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "TEST(TensorSliceReaderTest, NegativeTensorShapeDimension) {\n  const string fname =\n      io::JoinPath(testing::TmpDir(), \"negative_dim_checkpoint\");\n  TensorSliceWriter writer(fname, CreateTableTensorSliceBuilder);\n  const int32 data[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n  TF_CHECK_OK(writer.Add(\"test\", TensorShape({4, 5}),\n                         TensorSlice::ParseOrDie(\"0,2:-\"), data));\n  TF_CHECK_OK(writer.Finish());\n  MutateSavedTensorSlices(fname, [](SavedTensorSlices sts) {\n    if (sts.has_meta()) {\n      for (auto& tensor : *sts.mutable_meta()->mutable_tensor()) {\n        for (auto& dim : *tensor.mutable_shape()->mutable_dim()) {\n          dim.set_size(-dim.size());\n        }\n      }\n    }\n    return sts.SerializeAsString();\n  });\n  TensorSliceReader reader(fname, OpenTableTensorSliceReader);\n  EXPECT_FALSE(reader.status().ok());\n}", "target": 0}
{"code": "mptctl_mpt_command (unsigned long arg)\n{\n\tstruct mpt_ioctl_command __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_command  karg;\n\tMPT_ADAPTER\t*ioc;\n\tint\t\tiocnum;\n\tint\t\trc;\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_command))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_mpt_command - \"\n\t\t\t\"Unable to read in mpt_ioctl_command struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_mpt_command() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\trc = mptctl_do_mpt_command (karg, &uarg->MF);\n\treturn rc;\n}", "target": 1}
{"code": "log2vis_unicode (PyObject * unicode, FriBidiParType base_direction, int clean, int reordernsm)\n{\n\tPyObject *logical = NULL;\t\n\tPyObject *visual = NULL;\t\n\tPyObject *result = NULL;\t\n\tint length = PyUnicode_GET_SIZE (unicode);\n\tlogical = PyUnicode_AsUTF8String (unicode);\n\tif (logical == NULL)\n\t\tgoto cleanup;\n\tvisual = log2vis_utf8 (logical, length, base_direction, clean, reordernsm);\n\tif (visual == NULL)\n\t\tgoto cleanup;\n\tresult = PyUnicode_DecodeUTF8 (PyString_AS_STRING (visual),\n\t\t\t\t       PyString_GET_SIZE (visual), \"strict\");\n      cleanup:\n\tPy_XDECREF (logical);\n\tPy_XDECREF (visual);\n\treturn result;\n}", "target": 1}
{"code": "static ssize_t exitcode_proc_write(struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tchar *end, buf[sizeof(\"nnnnn\\0\")];\n\tint tmp;\n\tif (copy_from_user(buf, buffer, count))\n\t\treturn -EFAULT;\n\ttmp = simple_strtol(buf, &end, 0);\n\tif ((*end != '\\0') && !isspace(*end))\n\t\treturn -EINVAL;\n\tuml_exitcode = tmp;\n\treturn count;\n}", "target": 1}
{"code": "static int8_t parse_ext_option(uint16_t *dst, uint8_t **packet_data_pptr, uint8_t *packet_data_start_ptr, uint16_t packet_len, uint16_t *message_left)\n{\n    uint16_t option_number = *dst;\n    if (option_number == 13) {\n        uint8_t option_ext;\n        int8_t read_result = sn_coap_parser_read_packet_u8(&option_ext,\n                                                            *packet_data_pptr,\n                                                            packet_data_start_ptr,\n                                                            packet_len);\n        if (read_result != 0) {\n            tr_error(\"sn_coap_parser_options_parse - **packet_data_pptr overflow !\");\n            return -1;\n        }\n        else {\n                option_number += option_ext;\n                *message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                               packet_data_start_ptr,\n                                                               packet_len,\n                                                               1);\n        }\n    } else if (option_number == 14) {\n            int8_t read_result = sn_coap_parser_read_packet_u16(&option_number,\n                                                                *packet_data_pptr,\n                                                                packet_data_start_ptr,\n                                                                packet_len);\n            if (read_result != 0) {\n                tr_error(\"sn_coap_parser_options_parse - **packet_data_pptr overflow !\");\n                return -1;\n            }\n            else {\n            option_number += 269;\n            *message_left = sn_coap_parser_move_packet_ptr(packet_data_pptr,\n                                                           packet_data_start_ptr,\n                                                           packet_len,\n                                                           2);\n            }\n    }\n    else if (option_number == 15) {\n        tr_error(\"sn_coap_parser_options_parse - invalid option number(15)!\");\n        return -1;\n    }\n    *dst = option_number;\n    return 0;\n}", "target": 1}
{"code": "static void kvm_unload_vcpu_mmu(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tr = vcpu_load(vcpu);\n\tBUG_ON(r);\n\tkvm_mmu_unload(vcpu);\n\tvcpu_put(vcpu);\n}", "target": 0}
{"code": "void TableLookUp::setTable(int ntable, const std::vector<ushort16>& table) {\n  assert(!table.empty());\n  const int nfilled = table.size();\n  if (nfilled >= 65536)\n    ThrowRDE(\"Table lookup with %i entries is unsupported\", nfilled);\n  if (ntable > ntables) {\n    ThrowRDE(\"Table lookup with number greater than number of tables.\");\n  }\n  ushort16* t = &tables[ntable * TABLE_SIZE];\n  if (!dither) {\n    for (int i = 0; i < 65536; i++) {\n      t[i] = (i < nfilled) ? table[i] : table[nfilled - 1];\n    }\n    return;\n  }\n  for (int i = 0; i < nfilled; i++) {\n    int center = table[i];\n    int lower = i > 0 ? table[i - 1] : center;\n    int upper = i < (nfilled - 1) ? table[i + 1] : center;\n    int delta = upper - lower;\n    t[i * 2] = center - ((upper - lower + 2) / 4);\n    t[i * 2 + 1] = delta;\n  }\n  for (int i = nfilled; i < 65536; i++) {\n    t[i * 2] = table[nfilled - 1];\n    t[i * 2 + 1] = 0;\n  }\n  t[0] = t[1];\n  t[TABLE_SIZE - 1] = t[TABLE_SIZE - 2];\n}", "target": 0}
{"code": "void Statement::Work_Bind(napi_env e, void* data) {\n    STATEMENT_INIT(Baton);\n    STATEMENT_MUTEX(mtx);\n    sqlite3_mutex_enter(mtx);\n    stmt->Bind(baton->parameters);\n    sqlite3_mutex_leave(mtx);\n}", "target": 0}
{"code": "static int msg_parse_fetch(struct ImapHeader *h, char *s)\n{\n  char tmp[SHORT_STRING];\n  char *ptmp = NULL;\n  if (!s)\n    return -1;\n  while (*s)\n  {\n    SKIPWS(s);\n    if (mutt_str_strncasecmp(\"FLAGS\", s, 5) == 0)\n    {\n      s = msg_parse_flags(h, s);\n      if (!s)\n        return -1;\n    }\n    else if (mutt_str_strncasecmp(\"UID\", s, 3) == 0)\n    {\n      s += 3;\n      SKIPWS(s);\n      if (mutt_str_atoui(s, &h->data->uid) < 0)\n        return -1;\n      s = imap_next_word(s);\n    }\n    else if (mutt_str_strncasecmp(\"INTERNALDATE\", s, 12) == 0)\n    {\n      s += 12;\n      SKIPWS(s);\n      if (*s != '\\\"')\n      {\n        mutt_debug(1, \"bogus INTERNALDATE entry: %s\\n\", s);\n        return -1;\n      }\n      s++;\n      ptmp = tmp;\n      while (*s && *s != '\\\"')\n        *ptmp++ = *s++;\n      if (*s != '\\\"')\n        return -1;\n      s++; \n      *ptmp = '\\0';\n      h->received = mutt_date_parse_imap(tmp);\n    }\n    else if (mutt_str_strncasecmp(\"RFC822.SIZE\", s, 11) == 0)\n    {\n      s += 11;\n      SKIPWS(s);\n      ptmp = tmp;\n      while (isdigit((unsigned char) *s))\n        *ptmp++ = *s++;\n      *ptmp = '\\0';\n      if (mutt_str_atol(tmp, &h->content_length) < 0)\n        return -1;\n    }\n    else if ((mutt_str_strncasecmp(\"BODY\", s, 4) == 0) ||\n             (mutt_str_strncasecmp(\"RFC822.HEADER\", s, 13) == 0))\n    {\n      return -2;\n    }\n    else if (*s == ')')\n      s++; \n    else if (*s)\n    {\n      imap_error(\"msg_parse_fetch\", s);\n      return -1;\n    }\n  }\n  return 0;\n}", "target": 1}
{"code": "get_princs_2_svc(gprincs_arg *arg, struct svc_req *rqstp)\n{\n    static gprincs_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_gprincs_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->exp;\n    if (prime_arg == NULL)\n        prime_arg = \"*\";\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_LIST,\n                                                       NULL,\n                                                       NULL)) {\n        ret.code = KADM5_AUTH_LIST;\n        log_unauth(\"kadm5_get_principals\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code  = kadm5_get_principals((void *)handle,\n                                         arg->exp, &ret.princs,\n                                         &ret.count);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_get_principals\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "nvmet_fc_find_target_queue(struct nvmet_fc_tgtport *tgtport,\n\t\t\t\tu64 connection_id)\n{\n\tstruct nvmet_fc_tgt_assoc *assoc;\n\tstruct nvmet_fc_tgt_queue *queue;\n\tu64 association_id = nvmet_fc_getassociationid(connection_id);\n\tu16 qid = nvmet_fc_getqueueid(connection_id);\n\tunsigned long flags;\n\tif (qid > NVMET_NR_QUEUES)\n\t\treturn NULL;\n\tspin_lock_irqsave(&tgtport->lock, flags);\n\tlist_for_each_entry(assoc, &tgtport->assoc_list, a_list) {\n\t\tif (association_id == assoc->association_id) {\n\t\t\tqueue = assoc->queues[qid];\n\t\t\tif (queue &&\n\t\t\t    (!atomic_read(&queue->connected) ||\n\t\t\t     !nvmet_fc_tgt_q_get(queue)))\n\t\t\t\tqueue = NULL;\n\t\t\tspin_unlock_irqrestore(&tgtport->lock, flags);\n\t\t\treturn queue;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&tgtport->lock, flags);\n\treturn NULL;\n}", "target": 0}
{"code": "  absl::optional<uint64_t> evaluate(const Network::Address::Instance*,\n                                    const RequestHeaderMap& headers,\n                                    const HashPolicy::AddCookieCallback add_cookie,\n                                    const StreamInfo::FilterStateSharedPtr) const override {\n    absl::optional<uint64_t> hash;\n    std::string value = Utility::parseCookieValue(headers, key_);\n    if (value.empty() && ttl_.has_value()) {\n      value = add_cookie(key_, path_, ttl_.value(), attributes_);\n      hash = HashUtil::xxHash64(value);\n    } else if (!value.empty()) {\n      hash = HashUtil::xxHash64(value);\n    }\n    return hash;\n  }", "target": 1}
{"code": "static RzList  *__io_maps(RzDebug *dbg) {\n\tRzList *list = rz_list_new();\n\tchar *str = dbg->iob.system(dbg->iob.io, \"dm\");\n\tif (!str) {\n\t\trz_list_free(list);\n\t\treturn NULL;\n\t}\n\tchar *ostr = str;\n\tut64 map_start, map_end;\n\tchar perm[32];\n\tchar name[512];\n\tfor (;;) {\n\t\tchar *nl = strchr(str, '\\n');\n\t\tif (nl) {\n\t\t\t*nl = 0;\n\t\t\t*name = 0;\n\t\t\t*perm = 0;\n\t\t\tmap_start = map_end = 0LL;\n\t\t\tif (!strncmp(str, \"sys \", 4)) {\n\t\t\t\tchar *sp = strchr(str + 4, ' ');\n\t\t\t\tif (sp) {\n\t\t\t\t\tstr = sp + 1;\n\t\t\t\t} else {\n\t\t\t\t\tstr += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tchar *_s_ = strstr(str, \" s \");\n\t\t\tif (_s_) {\n\t\t\t\tmemmove(_s_, _s_ + 2, strlen(_s_));\n\t\t\t}\n\t\t\t_s_ = strstr(str, \" ? \");\n\t\t\tif (_s_) {\n\t\t\t\tmemmove(_s_, _s_ + 2, strlen(_s_));\n\t\t\t}\n\t\t\tsscanf(str, \"0x%\" PFMT64x \" - 0x%\" PFMT64x \" %s %s\",\n\t\t\t\t&map_start, &map_end, perm, name);\n\t\t\tif (map_end != 0LL) {\n\t\t\t\tRzDebugMap *map = rz_debug_map_new(name, map_start, map_end, rz_str_rwx(perm), 0);\n\t\t\t\trz_list_append(list, map);\n\t\t\t}\n\t\t\tstr = nl + 1;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(ostr);\n\trz_cons_reset();\n\treturn list;\n}", "target": 1}
{"code": "TEST_F(ExprMatchTest, AndNestedWithinOrMatchesCorrectly) {\n    createMatcher(fromjson(\n        \"{$expr: {$or: [{$and: [{$eq: ['$x', 3]}, {$gt: ['$z', 5]}]}, {$lt: ['$y', 4]}]}}\"));\n    ASSERT_TRUE(matches(BSON(\"x\" << 3 << \"z\" << 7)));\n    ASSERT_TRUE(matches(BSON(\"y\" << 1)));\n    ASSERT_FALSE(matches(BSON(\"y\" << 5)));\n}", "target": 0}
{"code": "static int atalk_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n\t\t\t size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_at *sat = (struct sockaddr_at *)msg->msg_name;\n\tstruct ddpehdr *ddp;\n\tint copied = 0;\n\tint offset = 0;\n\tint err = 0;\n\tstruct sk_buff *skb;\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tlock_sock(sk);\n\tif (!skb)\n\t\tgoto out;\n\tddp = ddp_hdr(skb);\n\tcopied = ntohs(ddp->deh_len_hops) & 1023;\n\tif (sk->sk_type != SOCK_RAW) {\n\t\toffset = sizeof(*ddp);\n\t\tcopied -= offset;\n\t}\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\terr = skb_copy_datagram_iovec(skb, offset, msg->msg_iov, copied);\n\tif (!err) {\n\t\tif (sat) {\n\t\t\tsat->sat_family      = AF_APPLETALK;\n\t\t\tsat->sat_port        = ddp->deh_sport;\n\t\t\tsat->sat_addr.s_node = ddp->deh_snode;\n\t\t\tsat->sat_addr.s_net  = ddp->deh_snet;\n\t\t}\n\t\tmsg->msg_namelen = sizeof(*sat);\n\t}\n\tskb_free_datagram(sk, skb);\t\nout:\n\trelease_sock(sk);\n\treturn err ? : copied;\n}", "target": 1}
{"code": "extract_epub_from_container (const gchar* uri,\n                             EpubDocument *epub_document,\n                             GError ** error)\n{\n    GError *err = NULL;\n    epub_document->archivename = g_filename_from_uri(uri,NULL,error);\n    if ( !epub_document->archivename )\n    {\n        if (err) {\n            g_propagate_error (error, err);\n        }\n        else {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not retrieve filename\"));\n        }\n        return FALSE;\n    }\n    gchar *epubfilename = g_strrstr(epub_document->archivename,\"/\");\n    if ( *epubfilename == '/' )\n        epubfilename++ ;\n    GString *temporary_sub_directory = g_string_new(epubfilename);\n    g_string_append(temporary_sub_directory,\"XXXXXX\") ;\n    epub_document->tmp_archive_dir = ev_mkdtemp(temporary_sub_directory->str, error);\n    g_string_free(temporary_sub_directory, TRUE);\n    if (!epub_document->tmp_archive_dir) {\n        return FALSE;\n    }\n    epub_document->epubDocument = unzOpen64(epub_document->archivename);\n    if ( epub_document->epubDocument == NULL )\n    {\n        if (err)    {\n            g_propagate_error (error, err);\n        }\n        else    {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not open archive\"));\n        }\n        return FALSE;\n    }\n    gboolean result = FALSE;\n    if ( unzGoToFirstFile(epub_document->epubDocument) != UNZ_OK )\n    {\n        if (err) {\n            g_propagate_error (error, err);\n        }\n        else    {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not extract archive\"));\n        }\n        goto out;\n    }\n    while ( TRUE )\n    {\n        if ( extract_one_file(epub_document,&err) == FALSE )\n        {\n            if (err) {\n                g_propagate_error (error, err);\n            }\n            else    {\n                g_set_error_literal (error,\n                             EV_DOCUMENT_ERROR,\n                             EV_DOCUMENT_ERROR_INVALID,\n                             _(\"could not extract archive\"));\n            }\n            goto out;\n        }\n        if ( unzGoToNextFile(epub_document->epubDocument) == UNZ_END_OF_LIST_OF_FILE ) {\n            result = TRUE;\n            break;\n        }\n    }\nout:\n    unzClose(epub_document->epubDocument);\n    return result;\n}", "target": 1}
{"code": "static int mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt)\n{\n\tstruct serial_icounter_struct icount;\n\tstruct sb_uart_icount cnow;\n\tstruct sb_uart_port *port = state->port;\n\tspin_lock_irq(&port->lock);\n\tmemcpy(&cnow, &port->icount, sizeof(struct sb_uart_icount));\n\tspin_unlock_irq(&port->lock);\n\ticount.cts         = cnow.cts;\n\ticount.dsr         = cnow.dsr;\n\ticount.rng         = cnow.rng;\n\ticount.dcd         = cnow.dcd;\n\ticount.rx          = cnow.rx;\n\ticount.tx          = cnow.tx;\n\ticount.frame       = cnow.frame;\n\ticount.overrun     = cnow.overrun;\n\ticount.parity      = cnow.parity;\n\ticount.brk         = cnow.brk;\n\ticount.buf_overrun = cnow.buf_overrun;\n\treturn copy_to_user(icnt, &icount, sizeof(icount)) ? -EFAULT : 0;\n}", "target": 1}
{"code": "void test_utimes(const char *path)\n{\n\tstruct utimbuf times;\n\ttimes.actime = 0;\n\ttimes.modtime = 0;\n\tif (utime(path, &times) == 0) {\n\t\tfprintf(stderr, \"leak at utime of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at utime of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "static int cg_rmdir(const char *path)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tchar *fpath = NULL, *cgdir = NULL, *controller;\n\tconst char *cgroup;\n\tint ret;\n\tif (!fc)\n\t\treturn -EIO;\n\tcontroller = pick_controller_from_path(fc, path);\n\tif (!controller)\n\t\treturn -EINVAL;\n\tcgroup = find_cgroup_in_path(path);\n\tif (!cgroup)\n\t\treturn -EINVAL;\n\tget_cgdir_and_path(cgroup, &cgdir, &fpath);\n\tif (!fpath) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tfprintf(stderr, \"rmdir: verifying access to %s:%s (req path %s)\\n\",\n\t\t\tcontroller, cgdir, path);\n\tif (!fc_may_access(fc, controller, cgdir, NULL, O_WRONLY)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tif (!caller_is_in_ancestor(fc->pid, controller, cgroup, NULL)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tif (!cgfs_remove(controller, cgroup)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tfree(cgdir);\n\treturn ret;\n}", "target": 1}
{"code": "static ssize_t fuse_fill_write_pages(struct fuse_req *req,\n\t\t\t       struct address_space *mapping,\n\t\t\t       struct iov_iter *ii, loff_t pos)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(mapping->host);\n\tunsigned offset = pos & (PAGE_CACHE_SIZE - 1);\n\tsize_t count = 0;\n\tint err;\n\treq->in.argpages = 1;\n\treq->page_descs[0].offset = offset;\n\tdo {\n\t\tsize_t tmp;\n\t\tstruct page *page;\n\t\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\t\tsize_t bytes = min_t(size_t, PAGE_CACHE_SIZE - offset,\n\t\t\t\t     iov_iter_count(ii));\n\t\tbytes = min_t(size_t, bytes, fc->max_write - count);\n again:\n\t\terr = -EFAULT;\n\t\tif (iov_iter_fault_in_readable(ii, bytes))\n\t\t\tbreak;\n\t\terr = -ENOMEM;\n\t\tpage = grab_cache_page_write_begin(mapping, index, 0);\n\t\tif (!page)\n\t\t\tbreak;\n\t\tif (mapping_writably_mapped(mapping))\n\t\t\tflush_dcache_page(page);\n\t\ttmp = iov_iter_copy_from_user_atomic(page, ii, offset, bytes);\n\t\tflush_dcache_page(page);\n\t\tif (!tmp) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tbytes = min(bytes, iov_iter_single_seg_count(ii));\n\t\t\tgoto again;\n\t\t}\n\t\terr = 0;\n\t\treq->pages[req->num_pages] = page;\n\t\treq->page_descs[req->num_pages].length = tmp;\n\t\treq->num_pages++;\n\t\tiov_iter_advance(ii, tmp);\n\t\tcount += tmp;\n\t\tpos += tmp;\n\t\toffset += tmp;\n\t\tif (offset == PAGE_CACHE_SIZE)\n\t\t\toffset = 0;\n\t\tif (!fc->big_writes)\n\t\t\tbreak;\n\t} while (iov_iter_count(ii) && count < fc->max_write &&\n\t\t req->num_pages < req->max_pages && offset == 0);\n\treturn count > 0 ? count : err;\n}", "target": 1}
{"code": "static void process_constructors (RBinFile *bf, RList *ret, int bits) {\n\tRList *secs = sections (bf);\n\tRListIter *iter;\n\tRBinSection *sec;\n\tint i, type;\n\tr_list_foreach (secs, iter, sec) {\n\t\ttype = -1;\n\t\tif (!strcmp (sec->name, \".fini_array\")) {\n\t\t\ttype = R_BIN_ENTRY_TYPE_FINI;\n\t\t} else if (!strcmp (sec->name, \".init_array\")) {\n\t\t\ttype = R_BIN_ENTRY_TYPE_INIT;\n\t\t} else if (!strcmp (sec->name, \".preinit_array\")) {\n\t\t\ttype = R_BIN_ENTRY_TYPE_PREINIT;\n\t\t}\n\t\tif (type != -1) {\n\t\t\tut8 *buf = calloc (sec->size, 1);\n\t\t\tif (!buf) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t(void)r_buf_read_at (bf->buf, sec->paddr, buf, sec->size);\n\t\t\tif (bits == 32) {\n\t\t\t\tfor (i = 0; i < sec->size; i += 4) {\n\t\t\t\t\tut32 addr32 = r_read_le32 (buf + i);\n\t\t\t\t\tif (addr32) {\n\t\t\t\t\t\tRBinAddr *ba = newEntry (sec->paddr + i, (ut64)addr32, type, bits);\n\t\t\t\t\t\tr_list_append (ret, ba);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < sec->size; i += 8) {\n\t\t\t\t\tut64 addr64 = r_read_le64 (buf + i);\n\t\t\t\t\tif (addr64) {\n\t\t\t\t\t\tRBinAddr *ba = newEntry (sec->paddr + i, addr64, type, bits);\n\t\t\t\t\t\tr_list_append (ret, ba);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (buf);\n\t\t}\n\t}\n\tr_list_free (secs);\n}", "target": 1}
{"code": "int button_open(Button *b) {\n        char *p, name[256];\n        int r;\n        assert(b);\n        b->fd = safe_close(b->fd);\n        p = strjoina(\"/dev/input/\", b->name);\n        b->fd = open(p, O_RDWR|O_CLOEXEC|O_NOCTTY|O_NONBLOCK);\n        if (b->fd < 0)\n                return log_warning_errno(errno, \"Failed to open %s: %m\", p);\n        r = button_suitable(b);\n        if (r < 0)\n                return log_warning_errno(r, \"Failed to determine whether input device is relevant to us: %m\");\n        if (r == 0)\n                return log_debug_errno(SYNTHETIC_ERRNO(EADDRNOTAVAIL),\n                                       \"Device %s does not expose keys or switches relevant to us, ignoring.\",\n                                       p);\n        if (ioctl(b->fd, EVIOCGNAME(sizeof(name)), name) < 0) {\n                r = log_error_errno(errno, \"Failed to get input name: %m\");\n                goto fail;\n        }\n        (void) button_set_mask(b);\n        r = sd_event_add_io(b->manager->event, &b->io_event_source, b->fd, EPOLLIN, button_dispatch, b);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to add button event: %m\");\n                goto fail;\n        }\n        log_info(\"Watching system buttons on /dev/input/%s (%s)\", b->name, name);\n        return 0;\nfail:\n        b->fd = safe_close(b->fd);\n        return r;\n}", "target": 1}
{"code": "static int isansicode(int x)\n{\n    return x == 0x1B || x == 0x0A || x == 0x0D || (x >= 0x20 && x < 0x7f);\n}", "target": 0}
{"code": "void FullFramePixelBuffer::setBuffer(int width, int height,\n                                     rdr::U8* data_, int stride_)\n{\n  if ((width < 0) || (width > maxPixelBufferWidth))\n    throw rfb::Exception(\"Invalid PixelBuffer width of %d pixels requested\", width);\n  if ((height < 0) || (height > maxPixelBufferHeight))\n    throw rfb::Exception(\"Invalid PixelBuffer height of %d pixels requested\", height);\n  if ((stride_ < 0) || (stride_ > maxPixelBufferStride) || (stride_ < width))\n    throw rfb::Exception(\"Invalid PixelBuffer stride of %d pixels requested\", stride_);\n  if ((width != 0) && (height != 0) && (data_ == NULL))\n    throw rfb::Exception(\"PixelBuffer requested without a valid memory area\");\n  ModifiablePixelBuffer::setSize(width, height);\n  stride = stride_;\n  data = data_;\n}", "target": 0}
{"code": "void lremCommand(client *c) {\n    robj *subject, *obj;\n    obj = c->argv[3];\n    long toremove;\n    long removed = 0;\n    if (sdslen(obj->ptr) > LIST_MAX_ITEM_SIZE) {\n        addReplyError(c, \"Element too large\");\n        return;\n    }\n    if ((getLongFromObjectOrReply(c, c->argv[2], &toremove, NULL) != C_OK))\n        return;\n    subject = lookupKeyWriteOrReply(c,c->argv[1],shared.czero);\n    if (subject == NULL || checkType(c,subject,OBJ_LIST)) return;\n    listTypeIterator *li;\n    if (toremove < 0) {\n        toremove = -toremove;\n        li = listTypeInitIterator(subject,-1,LIST_HEAD);\n    } else {\n        li = listTypeInitIterator(subject,0,LIST_TAIL);\n    }\n    listTypeEntry entry;\n    while (listTypeNext(li,&entry)) {\n        if (listTypeEqual(&entry,obj)) {\n            listTypeDelete(li, &entry);\n            server.dirty++;\n            removed++;\n            if (toremove && removed == toremove) break;\n        }\n    }\n    listTypeReleaseIterator(li);\n    if (removed) {\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_LIST,\"lrem\",c->argv[1],c->db->id);\n    }\n    if (listTypeLength(subject) == 0) {\n        dbDelete(c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",c->argv[1],c->db->id);\n    }\n    addReplyLongLong(c,removed);\n}", "target": 0}
{"code": "static struct desc_struct *get_desc(unsigned short sel)\n{\n\tstruct desc_ptr gdt_desc = {0, 0};\n\tunsigned long desc_base;\n#ifdef CONFIG_MODIFY_LDT_SYSCALL\n\tif ((sel & SEGMENT_TI_MASK) == SEGMENT_LDT) {\n\t\tstruct desc_struct *desc = NULL;\n\t\tstruct ldt_struct *ldt;\n\t\tsel >>= 3;\n\t\tmutex_lock(&current->active_mm->context.lock);\n\t\tldt = current->active_mm->context.ldt;\n\t\tif (ldt && sel < ldt->nr_entries)\n\t\t\tdesc = &ldt->entries[sel];\n\t\tmutex_unlock(&current->active_mm->context.lock);\n\t\treturn desc;\n\t}\n#endif\n\tnative_store_gdt(&gdt_desc);\n\tdesc_base = sel & ~(SEGMENT_RPL_MASK | SEGMENT_TI_MASK);\n\tif (desc_base > gdt_desc.size)\n\t\treturn NULL;\n\treturn (struct desc_struct *)(gdt_desc.address + desc_base);\n}", "target": 1}
{"code": "void BinaryProtocolReader::readStringBody(StrType& str, int32_t size) {\n  checkStringSize(size);\n  if (size == 0) {\n    str.clear();\n    return;\n  }\n  if (static_cast<int32_t>(in_.length()) < size) {\n    if (!in_.canAdvance(size)) {\n      protocol::TProtocolException::throwTruncatedData();\n    }\n    str.reserve(size); \n  }\n  str.clear();\n  size_t size_left = size;\n  while (size_left > 0) {\n    auto data = in_.peekBytes();\n    auto data_avail = std::min(data.size(), size_left);\n    if (data.empty()) {\n      TProtocolException::throwExceededSizeLimit();\n    }\n    str.append((const char*)data.data(), data_avail);\n    size_left -= data_avail;\n    in_.skipNoAdvance(data_avail);\n  }\n}", "target": 0}
{"code": "LIBOPENMPT_MODPLUG_API unsigned int ModPlug_SampleName(ModPlugFile* file, unsigned int qual, char* buff)\n{\n\tconst char* str;\n\tunsigned int retval;\n\tsize_t tmpretval;\n\tif(!file) return 0;\n\tstr = openmpt_module_get_sample_name(file->mod,qual-1);\n\tif(!str){\n\t\tif(buff){\n\t\t\t*buff = '\\0';\n\t\t}\n\t\treturn 0;\n\t}\n\ttmpretval = strlen(str);\n\tif(tmpretval>=INT_MAX){\n\t\ttmpretval = INT_MAX-1;\n\t}\n\tretval = (int)tmpretval;\n\tif(buff){\n\t\tmemcpy(buff,str,retval+1);\n\t\tbuff[retval] = '\\0';\n\t}\n\topenmpt_free_string(str);\n\treturn retval;\n}", "target": 1}
{"code": "static size_t exif_convert_any_to_int(void *value, int format, int motorola_intel TSRMLS_DC)\n{\n\tint \t\ts_den;\n\tunsigned \tu_den;\n\tswitch(format) {\n\t\tcase TAG_FMT_SBYTE:     return *(signed char *)value;\n\t\tcase TAG_FMT_BYTE:      return *(uchar *)value;\n\t\tcase TAG_FMT_USHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_ULONG:     return php_ifd_get32u(value, motorola_intel);\n\t\tcase TAG_FMT_URATIONAL:\n\t\t\tu_den = php_ifd_get32u(4+(char *)value, motorola_intel);\n\t\t\tif (u_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32u(value, motorola_intel) / u_den;\n\t\t\t}\n\t\tcase TAG_FMT_SRATIONAL:\n\t\t\ts_den = php_ifd_get32s(4+(char *)value, motorola_intel);\n\t\t\tif (s_den == 0) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn php_ifd_get32s(value, motorola_intel) / s_den;\n\t\t\t}\n\t\tcase TAG_FMT_SSHORT:    return php_ifd_get16u(value, motorola_intel);\n\t\tcase TAG_FMT_SLONG:     return php_ifd_get32s(value, motorola_intel);\n\t\tcase TAG_FMT_SINGLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type single\");\n#endif\n\t\t\treturn (size_t)*(float *)value;\n\t\tcase TAG_FMT_DOUBLE:\n#ifdef EXIF_DEBUG\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"Found value of type double\");\n#endif\n\t\t\treturn (size_t)*(double *)value;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "int pure_strcmp(const char * const s1, const char * const s2)\n{\n    return pure_memcmp(s1, s2, strlen(s1) + 1U);\n}", "target": 1}
{"code": "CallResult<PseudoHandle<>> JSObject::getComputedWithReceiver_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    Handle<> receiver) {\n  if (selfHandle->flags_.fastIndexProperties) {\n    if (auto arrayIndex = toArrayIndexFastPath(*nameValHandle)) {\n      PseudoHandle<> ourValue = createPseudoHandle(\n          getOwnIndexed(selfHandle.get(), runtime, *arrayIndex));\n      if (LLVM_LIKELY(!ourValue->isEmpty()))\n        return ourValue;\n    }\n  }\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto nameValPrimitiveHandle = *converted;\n  ComputedPropertyDescriptor desc;\n  MutableHandle<JSObject> propObj{runtime};\n  if (LLVM_UNLIKELY(\n          getComputedPrimitiveDescriptor(\n              selfHandle, runtime, nameValPrimitiveHandle, propObj, desc) ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  if (!propObj)\n    return createPseudoHandle(HermesValue::encodeUndefinedValue());\n  if (LLVM_LIKELY(\n          !desc.flags.accessor && !desc.flags.hostObject &&\n          !desc.flags.proxyObject))\n    return createPseudoHandle(\n        getComputedSlotValue(propObj.get(), runtime, desc));\n  if (desc.flags.accessor) {\n    auto *accessor = vmcast<PropertyAccessor>(\n        getComputedSlotValue(propObj.get(), runtime, desc));\n    if (!accessor->getter)\n      return createPseudoHandle(HermesValue::encodeUndefinedValue());\n    return accessor->getter.get(runtime)->executeCall0(\n        runtime->makeHandle(accessor->getter), runtime, receiver);\n  } else if (desc.flags.hostObject) {\n    SymbolID id{};\n    LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n    auto propRes = vmcast<HostObject>(selfHandle.get())->get(id);\n    if (propRes == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return createPseudoHandle(*propRes);\n  } else {\n    assert(desc.flags.proxyObject && \"descriptor flags are impossible\");\n    CallResult<Handle<>> key = toPropertyKey(runtime, nameValPrimitiveHandle);\n    if (key == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return JSProxy::getComputed(propObj, runtime, *key, receiver);\n  }\n}", "target": 1}
{"code": "void RenderWidgetHostImpl::SetNeedsFlush() {\n  if (view_)\n    view_->OnSetNeedsFlushInput();\n}", "target": 0}
{"code": "std::string WC2MB(const std::wstring& input, unsigned int code_page) {\n  if (input.empty()) {\n    return \"\";\n  }\n  DWORD flags = 0;\n  if (code_page != 65001 && code_page != 54936) {\n    flags = WC_NO_BEST_FIT_CHARS | WC_COMPOSITECHECK | WC_DEFAULTCHAR;\n  }\n  int length = ::WideCharToMultiByte(code_page, flags, &input[0],\n                                     static_cast<int>(input.size()), NULL, 0,\n                                     NULL, NULL);\n  std::string output(length, '\\0');\n  ::WideCharToMultiByte(code_page, flags, &input[0],\n                        static_cast<int>(input.size()), &output[0],\n                        static_cast<int>(output.size()), NULL, NULL);\n  return output;\n}", "target": 1}
{"code": "MagickExport void *DetachBlob(BlobInfo *blob_info)\n{\n  void\n    *data;\n  assert(blob_info != (BlobInfo *) NULL);\n  if (blob_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  if (blob_info->mapped != MagickFalse)\n    {\n      (void) UnmapBlob(blob_info->data,blob_info->length);\n      blob_info->data=NULL;\n      RelinquishMagickResource(MapResource,blob_info->length);\n    }\n  blob_info->mapped=MagickFalse;\n  blob_info->length=0;\n  blob_info->offset=0;\n  blob_info->eof=MagickFalse;\n  blob_info->error=0;\n  blob_info->exempt=MagickFalse;\n  blob_info->type=UndefinedStream;\n  blob_info->file_info.file=(FILE *) NULL;\n  data=blob_info->data;\n  blob_info->data=(unsigned char *) NULL;\n  blob_info->stream=(StreamHandler) NULL;\n  blob_info->custom_stream=(CustomStreamInfo *) NULL;\n  return(data);\n}", "target": 0}
{"code": "GF_EXPORT\nGF_Err gf_isom_set_byte_offset(GF_ISOFile *file, s64 byte_offset)\n{\n\tif (!file) return GF_BAD_PARAM;\n\tfile->read_byte_offset = byte_offset;\n\treturn GF_OK;", "target": 0}
{"code": "cib_send_plaintext(int sock, xmlNode * msg)\n{\n    char *xml_text = dump_xml_unformatted(msg);\n    if (xml_text != NULL) {\n        int rc = 0;\n        char *unsent = xml_text;\n        int len = strlen(xml_text);\n        len++;                  \n        crm_trace(\"Message on socket %d: size=%d\", sock, len);\n  retry:\n        rc = write(sock, unsent, len);\n        if (rc < 0) {\n            switch (errno) {\n                case EINTR:\n                case EAGAIN:\n                    crm_trace(\"Retry\");\n                    goto retry;\n                default:\n                    crm_perror(LOG_ERR, \"Could only write %d of the remaining %d bytes\", rc, len);\n                    break;\n            }\n        } else if (rc < len) {\n            crm_trace(\"Only sent %d of %d remaining bytes\", rc, len);\n            len -= rc;\n            unsent += rc;\n            goto retry;\n        } else {\n            crm_trace(\"Sent %d bytes: %.100s\", rc, xml_text);\n        }\n    }\n    free(xml_text);\n    return NULL;\n}", "target": 1}
{"code": "bool ArcMemory::Tell(int64 *Pos)\n{\n  if (!Loaded)\n    return false;\n  *Pos=SeekPos;\n  return true;\n}", "target": 0}
{"code": "cluster_free (struct cluster_list *cluster)\n{\n  if (cluster->list)\n    XFREE (MTYPE_CLUSTER_VAL, cluster->list);\n  XFREE (MTYPE_CLUSTER, cluster);\n}", "target": 0}
{"code": "int rose_add_loopback_node(const rose_address *address)\n{\n\tstruct rose_node *rose_node;\n\tint err = 0;\n\tspin_lock_bh(&rose_node_list_lock);\n\trose_node = rose_node_list;\n\twhile (rose_node != NULL) {\n\t\tif ((rose_node->mask == 10) &&\n\t\t     (rosecmpm(address, &rose_node->address, 10) == 0) &&\n\t\t     rose_node->loopback)\n\t\t\tbreak;\n\t\trose_node = rose_node->next;\n\t}\n\tif (rose_node != NULL)\n\t\tgoto out;\n\tif ((rose_node = kmalloc(sizeof(*rose_node), GFP_ATOMIC)) == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\trose_node->address      = *address;\n\trose_node->mask         = 10;\n\trose_node->count        = 1;\n\trose_node->loopback     = 1;\n\trose_node->neighbour[0] = rose_loopback_neigh;\n\trose_node->next = rose_node_list;\n\trose_node_list  = rose_node;\n\trose_loopback_neigh->count++;\nout:\n\tspin_unlock_bh(&rose_node_list_lock);\n\treturn err;\n}", "target": 0}
{"code": "do_macro(uschar *p)\n{\nint length;\nint nest = 0;\nargstr **pp;\nmacrodef *md = misc_malloc(sizeof(macrodef));\nmd->name = misc_readitem(p, NULL, &length, NULL, 0);\nmd->namelength = Ustrlen(md->name);\np += length;\nif (length == 0)\n  {\n  error(14);\n  return;\n  }\nmd->lines = md->args = NULL;\nmd->next = macrolist;\nmacrolist = md;\npp = &(md->args);\nwhile (*p != 0)\n  {\n  argstr *as = misc_malloc(sizeof(argstr));\n  as->next = NULL;\n  *pp = as;\n  pp = &(as->next);\n  as->string = misc_readitem(p, NULL, &length, NULL, 0);\n  p += length;\n  }\npp = &(md->lines);\nfor (;;)\n  {\n  argstr *as;\n  uschar *line = read_nextline();\n  if (line == NULL) { error(13, \".endmacro\"); return; }\n  if (Ustrncmp(line, \".macro \", 7) == 0) nest++;\n  else if (Ustrncmp(line, \".endmacro\", 9) == 0)\n    {\n    if (isspace(line[9]) || line[9] == '\\n')\n    if (--nest < 0) break;\n    }\n  as = misc_malloc(sizeof(argstr));\n  as->next = NULL;\n  *pp = as;\n  pp = &(as->next);\n  as->string = misc_copystring(line, Ustrlen(line));\n  }\nif (md->lines == NULL)\n  {\n  md->lines = misc_malloc(sizeof(argstr));\n  md->lines->next = NULL;\n  md->lines->string = misc_copystring(US\". Dummy line\\n\", 13);\n  }\n}", "target": 1}
{"code": "end_write(JOIN *join, JOIN_TAB *join_tab __attribute__((unused)),\n\t  bool end_of_records)\n{\n  TABLE *const table= join_tab->table;\n  DBUG_ENTER(\"end_write\");\n  if (!end_of_records)\n  {\n    copy_fields(join_tab->tmp_table_param);\n    if (copy_funcs(join_tab->tmp_table_param->items_to_copy, join->thd))\n      DBUG_RETURN(NESTED_LOOP_ERROR);           \n    if (likely(!join_tab->having || join_tab->having->val_int()))\n    {\n      int error;\n      join->found_records++;\n      if ((error= table->file->ha_write_tmp_row(table->record[0])))\n      {\n        if (likely(!table->file->is_fatal_error(error, HA_CHECK_DUP)))\n\t  goto end;                             \n        bool is_duplicate;\n\tif (create_internal_tmp_table_from_heap(join->thd, table, \n                                                join_tab->tmp_table_param->start_recinfo,\n                                                &join_tab->tmp_table_param->recinfo,\n                                                error, 1, &is_duplicate))\n\t  DBUG_RETURN(NESTED_LOOP_ERROR);        \n        if (is_duplicate)\n          goto end;\n\ttable->s->uniques=0;\t\t\t\n      }\n      if (++join_tab->send_records >=\n            join_tab->tmp_table_param->end_write_records &&\n\t  join->do_send_rows)\n      {\n\tif (!(join->select_options & OPTION_FOUND_ROWS))\n\t  DBUG_RETURN(NESTED_LOOP_QUERY_LIMIT);\n\tjoin->do_send_rows=0;\n\tjoin->unit->select_limit_cnt = HA_POS_ERROR;\n      }\n    }\n  }\nend:\n  if (unlikely(join->thd->check_killed()))\n  {\n    DBUG_RETURN(NESTED_LOOP_KILLED);             \n  }\n  DBUG_RETURN(NESTED_LOOP_OK);\n}", "target": 0}
{"code": "void ParamTraits<NullableString16>::Log(const param_type& p, std::string* l) {\n  l->append(\"(\");\n  LogParam(p.string(), l);\n  l->append(\", \");\n  LogParam(p.is_null(), l);\n  l->append(\")\");\n}", "target": 0}
{"code": "static struct dentry *bad_inode_lookup(struct inode *dir,\n\t\t\tstruct dentry *dentry, struct nameidata *nd)\n{\n\treturn ERR_PTR(-EIO);\n}", "target": 0}
{"code": "ppp_unregister_channel(struct ppp_channel *chan)\n{\n\tstruct channel *pch = chan->ppp;\n\tstruct ppp_net *pn;\n\tif (!pch)\n\t\treturn;\t\t\n\tchan->ppp = NULL;\n\tdown_write(&pch->chan_sem);\n\tspin_lock_bh(&pch->downl);\n\tpch->chan = NULL;\n\tspin_unlock_bh(&pch->downl);\n\tup_write(&pch->chan_sem);\n\tppp_disconnect_channel(pch);\n\tpn = ppp_pernet(pch->chan_net);\n\tspin_lock_bh(&pn->all_channels_lock);\n\tlist_del(&pch->list);\n\tspin_unlock_bh(&pn->all_channels_lock);\n\tput_net(pch->chan_net);\n\tpch->chan_net = NULL;\n\tpch->file.dead = 1;\n\twake_up_interruptible(&pch->file.rwait);\n\tif (atomic_dec_and_test(&pch->file.refcnt))\n\t\tppp_destroy_channel(pch);\n}", "target": 0}
{"code": "bool SrvAnsiImpl::ReportString(LPCWSTR asRet)\n{\n\tif (!asRet || !*asRet)\n\t\treturn FALSE;\n\tINPUT_RECORD ir[16] = {};\n\tint nLen = lstrlen(asRet);\n\tINPUT_RECORD* pir = (nLen <= (int)countof(ir)) ? ir : (INPUT_RECORD*)calloc(nLen,sizeof(INPUT_RECORD));\n\tif (!pir)\n\t\treturn FALSE;\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (int i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}\n\tDumpKnownEscape(asRet, nLen, SrvAnsi::de_Report);\n\tDWORD nWritten = 0;\n\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\n\tbool bSuccess = WriteConsoleInput(hIn, pir, nLen, &nWritten) && (nWritten == nLen);\n\tif (pir != ir)\n\t\tfree(pir);\n\treturn bSuccess;\n}", "target": 1}
{"code": "create_tls_session(int csock, int type  )\n{\n    int rc = 0;\n    gnutls_session *session = gnutls_malloc(sizeof(gnutls_session));\n    gnutls_init(session, type);\n#  ifdef HAVE_GNUTLS_PRIORITY_SET_DIRECT\n    gnutls_priority_set_direct(*session, \"NORMAL:+ANON-DH\", NULL);\n#  else\n    gnutls_set_default_priority(*session);\n    gnutls_kx_set_priority(*session, tls_kx_order);\n#  endif\n    gnutls_transport_set_ptr(*session, (gnutls_transport_ptr) GINT_TO_POINTER(csock));\n    switch (type) {\n        case GNUTLS_SERVER:\n            gnutls_credentials_set(*session, GNUTLS_CRD_ANON, anon_cred_s);\n            break;\n        case GNUTLS_CLIENT:\n            gnutls_credentials_set(*session, GNUTLS_CRD_ANON, anon_cred_c);\n            break;\n    }\n    do {\n        rc = gnutls_handshake(*session);\n    } while (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN);\n    if (rc < 0) {\n        crm_err(\"Handshake failed: %s\", gnutls_strerror(rc));\n        gnutls_deinit(*session);\n        gnutls_free(session);\n        return NULL;\n    }\n    return session;\n}", "target": 1}
{"code": "ZEND_API void zend_update_property_null(zend_class_entry *scope, zval *object, const char *name, int name_length TSRMLS_DC) \n{\n\tzval *tmp;\n\tALLOC_ZVAL(tmp);\n\tZ_UNSET_ISREF_P(tmp);\n\tZ_SET_REFCOUNT_P(tmp, 0);\n\tZVAL_NULL(tmp);\n\tzend_update_property(scope, object, name, name_length, tmp TSRMLS_CC);\n}", "target": 0}
{"code": "*/\nPHP_FUNCTION(date_sub)\n{\n\tzval *object, *interval;\n\tif (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"OO\", &object, date_ce_date, &interval, date_ce_interval) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tphp_date_sub(object, interval, return_value TSRMLS_CC);\n\tRETURN_ZVAL(object, 1, 0);", "target": 0}
{"code": "void DCR_CLASS dcr_cam_xyz_coeff (DCRAW* p, double cam_xyz[4][3])\n{\n\tdouble cam_rgb[4][3], inverse[4][3], num;\n\tint i, j, k;\n\tfor (i=0; i < p->colors; i++)\t\t\n\t\tfor (j=0; j < 3; j++)\n\t\t\tfor (cam_rgb[i][j] = k=0; k < 3; k++)\n\t\t\t\tcam_rgb[i][j] += cam_xyz[i][k] * xyz_rgb[k][j];\n\tfor (i=0; i < p->colors; i++) {\t\t\n\t\tfor (num=j=0; j < 3; j++)\t\t\n\t\t\tnum += cam_rgb[i][j];\n\t\tfor (j=0; j < 3; j++)\n\t\t\tcam_rgb[i][j] /= num;\n\t\tp->pre_mul[i] = 1 / (float)num;\n\t}\n\tdcr_pseudoinverse (cam_rgb, inverse, p->colors);\n\tfor (p->raw_color = i=0; i < 3; i++)\n\t\tfor (j=0; j < p->colors; j++)\n\t\t\tp->rgb_cam[i][j] = (float)inverse[j][i];\n}", "target": 1}
{"code": "unknown_layer_handler(TSS2_RC rc)\n{\n    static __thread char buf[32];\n    clearbuf(buf);\n    catbuf(buf, \"0x%X\", tpm2_error_get(rc));\n    return buf;\n}", "target": 1}
{"code": "GF_Box *subs_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubSampleInformationBox, GF_ISOM_BOX_TYPE_SUBS);\n\ttmp->Samples = gf_list_new();\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "static int validate_user_key(struct fscrypt_info *crypt_info,\n\t\t\tstruct fscrypt_context *ctx, u8 *raw_key,\n\t\t\tconst char *prefix)\n{\n\tchar *description;\n\tstruct key *keyring_key;\n\tstruct fscrypt_key *master_key;\n\tconst struct user_key_payload *ukp;\n\tint res;\n\tdescription = kasprintf(GFP_NOFS, \"%s%*phN\", prefix,\n\t\t\t\tFS_KEY_DESCRIPTOR_SIZE,\n\t\t\t\tctx->master_key_descriptor);\n\tif (!description)\n\t\treturn -ENOMEM;\n\tkeyring_key = request_key(&key_type_logon, description, NULL);\n\tkfree(description);\n\tif (IS_ERR(keyring_key))\n\t\treturn PTR_ERR(keyring_key);\n\tif (keyring_key->type != &key_type_logon) {\n\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"%s: key type must be logon\\n\", __func__);\n\t\tres = -ENOKEY;\n\t\tgoto out;\n\t}\n\tdown_read(&keyring_key->sem);\n\tukp = user_key_payload(keyring_key);\n\tif (ukp->datalen != sizeof(struct fscrypt_key)) {\n\t\tres = -EINVAL;\n\t\tup_read(&keyring_key->sem);\n\t\tgoto out;\n\t}\n\tmaster_key = (struct fscrypt_key *)ukp->data;\n\tBUILD_BUG_ON(FS_AES_128_ECB_KEY_SIZE != FS_KEY_DERIVATION_NONCE_SIZE);\n\tif (master_key->size != FS_AES_256_XTS_KEY_SIZE) {\n\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"%s: key size incorrect: %d\\n\",\n\t\t\t\t__func__, master_key->size);\n\t\tres = -ENOKEY;\n\t\tup_read(&keyring_key->sem);\n\t\tgoto out;\n\t}\n\tres = derive_key_aes(ctx->nonce, master_key->raw, raw_key);\n\tup_read(&keyring_key->sem);\n\tif (res)\n\t\tgoto out;\n\tcrypt_info->ci_keyring_key = keyring_key;\n\treturn 0;\nout:\n\tkey_put(keyring_key);\n\treturn res;\n}", "target": 1}
{"code": "void sctp_generate_heartbeat_event(unsigned long data)\n{\n\tint error = 0;\n\tstruct sctp_transport *transport = (struct sctp_transport *) data;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct net *net = sock_net(asoc->base.sk);\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\t\tif (!mod_timer(&transport->hb_timer, jiffies + (HZ/20)))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\tif (transport->dead)\n\t\tgoto out_unlock;\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_HEARTBEAT),\n\t\t\t   asoc->state, asoc->ep, asoc,\n\t\t\t   transport, GFP_ATOMIC);\n\tif (error)\n\t\tasoc->base.sk->sk_err = -error;\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_transport_put(transport);\n}", "target": 1}
{"code": "static __u8 *nci_extract_rf_params_nfcf_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfcf_poll *nfcf_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfcf_poll->bit_rate = *data++;\n\tnfcf_poll->sensf_res_len = *data++;\n\tpr_debug(\"bit_rate %d, sensf_res_len %d\\n\",\n\t\t nfcf_poll->bit_rate, nfcf_poll->sensf_res_len);\n\tmemcpy(nfcf_poll->sensf_res, data, nfcf_poll->sensf_res_len);\n\tdata += nfcf_poll->sensf_res_len;\n\treturn data;\n}", "target": 1}
{"code": "void nfc_unregister_device(struct nfc_dev *dev)\n{\n\tint rc;\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\trc = nfc_genl_device_removed(dev);\n\tif (rc)\n\t\tpr_debug(\"The userspace won't be notified that the device %s \"\n\t\t\t \"was removed\\n\", dev_name(&dev->dev));\n\tdevice_lock(&dev->dev);\n\tif (dev->rfkill) {\n\t\trfkill_unregister(dev->rfkill);\n\t\trfkill_destroy(dev->rfkill);\n\t}\n\tdevice_unlock(&dev->dev);\n\tif (dev->ops->check_presence) {\n\t\tdevice_lock(&dev->dev);\n\t\tdev->shutting_down = true;\n\t\tdevice_unlock(&dev->dev);\n\t\tdel_timer_sync(&dev->check_pres_timer);\n\t\tcancel_work_sync(&dev->check_pres_work);\n\t}\n\tnfc_llcp_unregister_device(dev);\n\tmutex_lock(&nfc_devlist_mutex);\n\tnfc_devlist_generation++;\n\tdevice_del(&dev->dev);\n\tmutex_unlock(&nfc_devlist_mutex);\n}", "target": 1}
{"code": "static int llcp_raw_sock_bind(struct socket *sock, struct sockaddr *addr,\n\t\t\t      int alen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tstruct nfc_llcp_local *local;\n\tstruct nfc_dev *dev;\n\tstruct sockaddr_nfc_llcp llcp_addr;\n\tint len, ret = 0;\n\tif (!addr || alen < offsetofend(struct sockaddr, sa_family) ||\n\t    addr->sa_family != AF_NFC)\n\t\treturn -EINVAL;\n\tpr_debug(\"sk %p addr %p family %d\\n\", sk, addr, addr->sa_family);\n\tmemset(&llcp_addr, 0, sizeof(llcp_addr));\n\tlen = min_t(unsigned int, sizeof(llcp_addr), alen);\n\tmemcpy(&llcp_addr, addr, len);\n\tlock_sock(sk);\n\tif (sk->sk_state != LLCP_CLOSED) {\n\t\tret = -EBADFD;\n\t\tgoto error;\n\t}\n\tdev = nfc_get_device(llcp_addr.dev_idx);\n\tif (dev == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto put_dev;\n\t}\n\tllcp_sock->dev = dev;\n\tllcp_sock->local = nfc_llcp_local_get(local);\n\tllcp_sock->nfc_protocol = llcp_addr.nfc_protocol;\n\tnfc_llcp_sock_link(&local->raw_sockets, sk);\n\tsk->sk_state = LLCP_BOUND;\nput_dev:\n\tnfc_put_device(dev);\nerror:\n\trelease_sock(sk);\n\treturn ret;\n}", "target": 1}
{"code": "STACK_OF(PKCS12_SAFEBAG) *PKCS12_unpack_p7data(PKCS7 *p7)\n{\n    if (!PKCS7_type_is_data(p7)) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_CONTENT_TYPE_NOT_DATA);\n        return NULL;\n    }\n    if (p7->d.data == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_DECODE_ERROR);\n        return NULL;\n    }\n    return ASN1_item_unpack_ex(p7->d.data, ASN1_ITEM_rptr(PKCS12_SAFEBAGS),\n                               ossl_pkcs7_ctx_get0_libctx(&p7->ctx),\n                               ossl_pkcs7_ctx_get0_propq(&p7->ctx));\n}", "target": 0}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteSpaceToDepthParams*>(node->builtin_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n  auto data_type = output->type;\n  TF_LITE_ENSURE(context,\n                 data_type == kTfLiteFloat32 || data_type == kTfLiteUInt8 ||\n                     data_type == kTfLiteInt8 || data_type == kTfLiteInt32 ||\n                     data_type == kTfLiteInt64);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  const int block_size = params->block_size;\n  TF_LITE_ENSURE(context, block_size > 0);\n  const int input_height = input->dims->data[1];\n  const int input_width = input->dims->data[2];\n  int output_height = input_height / block_size;\n  int output_width = input_width / block_size;\n  TF_LITE_ENSURE_EQ(context, input_height, output_height * block_size);\n  TF_LITE_ENSURE_EQ(context, input_width, output_width * block_size);\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(4);\n  output_size->data[0] = input->dims->data[0];\n  output_size->data[1] = output_height;\n  output_size->data[2] = output_width;\n  output_size->data[3] = input->dims->data[3] * block_size * block_size;\n  return context->ResizeTensor(context, output, output_size);\n}", "target": 0}
{"code": "int Dispatcher::getparam( size_t N, int defaultval )\n{\n  int ret = defaultval;\n  if ( !parsed ) {\n    parse_params();\n  }\n  if ( parsed_params.size() > N ) {\n    ret = parsed_params[ N ];\n  }\n  if ( ret > PARAM_MAX ) {\n    ret = defaultval;\n  }\n  if ( ret < 1 ) ret = defaultval;\n  return ret;\n}", "target": 0}
{"code": "static inline int process_numeric_entity(const char **buf, unsigned *code_point)\n{\n\tlong code_l;\n\tint hexadecimal = (**buf == 'x' || **buf == 'X'); \n\tchar *endptr;\n\tif (hexadecimal && (**buf != '\\0'))\n\t\t(*buf)++;\n\tif ((hexadecimal && !isxdigit(**buf)) ||\n\t\t\t(!hexadecimal && !isdigit(**buf))) {\n\t\treturn FAILURE;\n\t}\n\tcode_l = strtol(*buf, &endptr, hexadecimal ? 16 : 10);\n\t*buf = endptr;\n\tif (**buf != ';')\n\t\treturn FAILURE;\n\tif (code_l > 0x10FFFFL)\n\t\treturn FAILURE;\n\tif (code_point != NULL)\n\t\t*code_point = (unsigned)code_l;\n\treturn SUCCESS;\n}", "target": 1}
{"code": "check_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\tif (!ip6_checkentry(&e->ipv6))\n\t\treturn -EINVAL;\n\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1}
{"code": "PJ_DEF(void) pj_scan_get_until_chr( pj_scanner *scanner,\n\t\t\t\t     const char *until_spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n    pj_size_t speclen;\n    if (s >= scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    speclen = strlen(until_spec);\n    while (PJ_SCAN_CHECK_EOF(s) && !memchr(until_spec, *s, speclen)) {\n\t++s;\n    }\n    pj_strset3(out, scanner->curptr, s);\n    scanner->curptr = s;\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}", "target": 1}
{"code": "xfs_ip2xflags(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_icdinode\t*dic = &ip->i_d;\n\treturn _xfs_dic2xflags(dic->di_flags, dic->di_flags2, XFS_IFORK_Q(ip));\n}", "target": 0}
{"code": "static void umocktypes_free_FLOW_HANDLE(FLOW_HANDLE* value)\n{\n    (void)value;\n}", "target": 0}
{"code": "findNextBorderPixel(l_int32    w,\n                    l_int32    h,\n                    l_uint32  *data,\n                    l_int32    wpl,\n                    l_int32    px,\n                    l_int32    py,\n                    l_int32   *pqpos,\n                    l_int32   *pnpx,\n                    l_int32   *pnpy)\n{\nl_int32    qpos, i, pos, npx, npy, val;\nl_uint32  *line;\n    qpos = *pqpos;\n    for (i = 1; i < 8; i++) {\n        pos = (qpos + i) % 8;\n        npx = px + xpostab[pos];\n        npy = py + ypostab[pos];\n        if (npx < 0 || npx >= w || npy < 0 || npy >= h)\n            continue;\n        line = data + npy * wpl;\n        val = GET_DATA_BIT(line, npx);\n        if (val) {\n            *pnpx = npx;\n            *pnpy = npy;\n            *pqpos = qpostab[pos];\n            return 0;\n        }\n    }\n    return 1;\n}", "target": 0}
{"code": "bool all_tests () {\n\tmu_run_test (test_r_str_newf);\n\tmu_run_test (test_r_str_replace_char_once);\n\tmu_run_test (test_r_str_replace_char);\n\tmu_run_test (test_r_str_replace);\n\tmu_run_test (test_r_str_bits64);\n\tmu_run_test (test_r_str_rwx);\n\tmu_run_test (test_r_str_rwx_i);\n\tmu_run_test (test_r_str_bool);\n\tmu_run_test (test_r_str_trim);\n\tmu_run_test (test_r_str_case);\n\tmu_run_test (test_r_str_split);\n\tmu_run_test (test_r_str_tokenize);\n\tmu_run_test (test_r_str_char_count);\n\tmu_run_test (test_r_str_word_count);\n\tmu_run_test (test_r_str_ichr);\n\tmu_run_test (test_r_str_lchr);\n\tmu_run_test (test_r_sub_str_lchr);\n\tmu_run_test (test_r_sub_str_rchr);\n\tmu_run_test (test_r_str_rchr);\n\tmu_run_test (test_r_str_ansi_len);\n\tmu_run_test (test_r_str_len_utf8_ansi);\n\tmu_run_test (test_r_str_utf8_charsize);\n\tmu_run_test (test_r_str_utf8_charsize_prev);\n\tmu_run_test (test_r_str_sanitize_sdb_key);\n\tmu_run_test (test_r_str_escape_sh);\n\tmu_run_test (test_r_str_unescape);\n\tmu_run_test (test_r_str_constpool);\n\tmu_run_test (test_r_str_format_msvc_argv);\n\tmu_run_test (test_r_str_str_xy);\n\treturn tests_passed != tests_run;\n}", "target": 0}
{"code": "set_bm_backward_skip(UChar* s, UChar* end, OnigEncoding enc ARG_UNUSED,\n\t\t     int** skip)\n{\n  int i, len;\n  if (IS_NULL(*skip)) {\n    *skip = (int* )xmalloc(sizeof(int) * ONIG_CHAR_TABLE_SIZE);\n    if (IS_NULL(*skip)) return ONIGERR_MEMORY;\n  }\n  len = (int )(end - s);\n  for (i = 0; i < ONIG_CHAR_TABLE_SIZE; i++)\n    (*skip)[i] = len;\n  for (i = len - 1; i > 0; i--)\n    (*skip)[s[i]] = i;\n  return 0;\n}", "target": 0}
{"code": "int NCR_IsSyncPeer(NCR_Instance inst)\n{\n  return SRC_IsSyncPeer(inst->source);\n}", "target": 0}
{"code": "static struct sk_buff *ipv6_gso_segment(struct sk_buff *skb, int features)\n{\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tstruct ipv6hdr *ipv6h;\n\tstruct inet6_protocol *ops;\n\tif (!(features & NETIF_F_V6_CSUM))\n\t\tfeatures &= ~NETIF_F_SG;\n\tif (unlikely(skb_shinfo(skb)->gso_type &\n\t\t     ~(SKB_GSO_UDP |\n\t\t       SKB_GSO_DODGY |\n\t\t       SKB_GSO_TCP_ECN |\n\t\t       SKB_GSO_TCPV6 |\n\t\t       0)))\n\t\tgoto out;\n\tif (unlikely(!pskb_may_pull(skb, sizeof(*ipv6h))))\n\t\tgoto out;\n\tipv6h = ipv6_hdr(skb);\n\t__skb_pull(skb, sizeof(*ipv6h));\n\tsegs = ERR_PTR(-EPROTONOSUPPORT);\n\trcu_read_lock();\n\tops = ipv6_gso_pull_exthdrs(skb, ipv6h->nexthdr);\n\tif (likely(ops && ops->gso_segment)) {\n\t\tskb_reset_transport_header(skb);\n\t\tsegs = ops->gso_segment(skb, features);\n\t}\n\trcu_read_unlock();\n\tif (unlikely(IS_ERR(segs)))\n\t\tgoto out;\n\tfor (skb = segs; skb; skb = skb->next) {\n\t\tipv6h = ipv6_hdr(skb);\n\t\tipv6h->payload_len = htons(skb->len - skb->mac_len -\n\t\t\t\t\t   sizeof(*ipv6h));\n\t}\nout:\n\treturn segs;\n}", "target": 0}
{"code": "static bool extractFileTo(zip* zip, const std::string &file, std::string& to,\n                          char* buf, size_t len) {\n  auto sep = file.rfind('/');\n  if (sep != std::string::npos) {\n    auto path = to + file.substr(0, sep);\n    if (!HHVM_FN(is_dir)(path) && !HHVM_FN(mkdir)(path, 0777, true)) {\n      return false;\n    }\n    if (sep == file.length() - 1) {\n      return true;\n    }\n  }\n  to.append(file);\n  struct zip_stat zipStat;\n  if (zip_stat(zip, file.c_str(), 0, &zipStat) != 0) {\n    return false;\n  }\n  auto zipFile = zip_fopen_index(zip, zipStat.index, 0);\n  FAIL_IF_INVALID_PTR(zipFile);\n  auto outFile = fopen(to.c_str(), \"wb\");\n  if (outFile == nullptr) {\n    zip_fclose(zipFile);\n    return false;\n  }\n  for (auto n = zip_fread(zipFile, buf, len); n != 0;\n       n = zip_fread(zipFile, buf, len)) {\n    if (n < 0 || fwrite(buf, sizeof(char), n, outFile) != n) {\n      zip_fclose(zipFile);\n      fclose(outFile);\n      remove(to.c_str());\n      return false;\n    }\n  }\n  zip_fclose(zipFile);\n  if (fclose(outFile) != 0) {\n    return false;\n  }\n  return true;\n}", "target": 1}
{"code": "static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof)\n{\n\tchar *ksep, *vsep, *val;\n\tsize_t klen, vlen;\n\tsize_t new_vlen;\n\tif (var->ptr >= var->end) {\n\t\treturn 0;\n\t}\n\tvsep = memchr(var->ptr, '&', var->end - var->ptr);\n\tif (!vsep) {\n\t\tif (!eof) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tvsep = var->end;\n\t\t}\n\t}\n\tksep = memchr(var->ptr, '=', vsep - var->ptr);\n\tif (ksep) {\n\t\t*ksep = '\\0';\n\t\tklen = ksep - var->ptr;\n\t\tvlen = vsep - ++ksep;\n\t} else {\n\t\tksep = \"\";\n\t\tklen = vsep - var->ptr;\n\t\tvlen = 0;\n\t}\n\tphp_url_decode(var->ptr, klen);\n\tval = estrndup(ksep, vlen);\n\tif (vlen) {\n\t\tvlen = php_url_decode(val, vlen);\n\t}\n\tif (sapi_module.input_filter(PARSE_POST, var->ptr, &val, vlen, &new_vlen)) {\n\t\tphp_register_variable_safe(var->ptr, val, new_vlen, arr);\n\t}\n\tefree(val);\n\tvar->ptr = vsep + (vsep != var->end);\n\treturn 1;\n}", "target": 1}
{"code": "int kvm_read_guest_page(struct kvm *kvm, gfn_t gfn, void *data, int offset,\n\t\t\tint len)\n{\n\tint r;\n\tunsigned long addr;\n\taddr = gfn_to_hva(kvm, gfn);\n\tif (kvm_is_error_hva(addr))\n\t\treturn -EFAULT;\n\tr = copy_from_user(data, (void __user *)addr + offset, len);\n\tif (r)\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "TEST_P(ProxyFilterIntegrationTest, UpstreamTlsWithTooLongSni) {\n  upstream_tls_ = true;\n  initializeWithArgs(1024, 1024, \"x-host\");\n  std::string too_long_sni(300, 'a');\n  ASSERT_EQ(too_long_sni.size(), 300); \n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  const Http::TestRequestHeaderMapImpl request_headers{{\":method\", \"POST\"},\n                                                       {\":path\", \"/test/long/url\"},\n                                                       {\":scheme\", \"http\"},\n                                                       {\":authority\", \"localhost\"},\n                                                       {\"x-host\", too_long_sni}};\n  auto response = codec_client_->makeHeaderOnlyRequest(request_headers);\n  ASSERT_TRUE(response->waitForEndStream());\n  EXPECT_EQ(\"503\", response->headers().getStatusValue());\n}", "target": 0}
{"code": "static unsigned long ioapic_read_indirect(struct kvm_ioapic *ioapic,\n\t\t\t\t\t  unsigned long addr,\n\t\t\t\t\t  unsigned long length)\n{\n\tunsigned long result = 0;\n\tswitch (ioapic->ioregsel) {\n\tcase IOAPIC_REG_VERSION:\n\t\tresult = ((((IOAPIC_NUM_PINS - 1) & 0xff) << 16)\n\t\t\t  | (IOAPIC_VERSION_ID & 0xff));\n\t\tbreak;\n\tcase IOAPIC_REG_APIC_ID:\n\tcase IOAPIC_REG_ARB_ID:\n\t\tresult = ((ioapic->id & 0xf) << 24);\n\t\tbreak;\n\tdefault:\n\t\t{\n\t\t\tu32 redir_index = (ioapic->ioregsel - 0x10) >> 1;\n\t\t\tu64 redir_content;\n\t\t\tASSERT(redir_index < IOAPIC_NUM_PINS);\n\t\t\tredir_content = ioapic->redirtbl[redir_index].bits;\n\t\t\tresult = (ioapic->ioregsel & 0x1) ?\n\t\t\t    (redir_content >> 32) & 0xffffffff :\n\t\t\t    redir_content & 0xffffffff;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}", "target": 1}
{"code": "TEST_P(RBACIntegrationTest, PathIgnoreCase) {\n  config_helper_.addFilter(RBAC_CONFIG_WITH_PATH_IGNORE_CASE_MATCH);\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  const std::vector<std::string> paths{\"/ignore_case\", \"/IGNORE_CASE\", \"/ignore_CASE\"};\n  for (const auto& path : paths) {\n    auto response = codec_client_->makeRequestWithBody(\n        Http::TestRequestHeaderMapImpl{\n            {\":method\", \"POST\"},\n            {\":path\", path},\n            {\":scheme\", \"http\"},\n            {\":authority\", \"host\"},\n            {\"x-forwarded-for\", \"10.0.0.1\"},\n        },\n        1024);\n    waitForNextUpstreamRequest();\n    upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}}, true);\n    response->waitForEndStream();\n    ASSERT_TRUE(response->complete());\n    EXPECT_EQ(\"200\", response->headers().getStatusValue());\n  }\n}", "target": 0}
{"code": "static int handle_vmread(struct kvm_vcpu *vcpu)\n{\n\tunsigned long field;\n\tu64 field_value;\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\tgva_t gva = 0;\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\tif (!nested_vmx_check_vmcs12(vcpu))\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\tfield = kvm_register_readl(vcpu, (((vmx_instruction_info) >> 28) & 0xf));\n\tif (vmcs12_read_any(vcpu, field, &field_value) < 0) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_UNSUPPORTED_VMCS_COMPONENT);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\tif (vmx_instruction_info & (1u << 10)) {\n\t\tkvm_register_writel(vcpu, (((vmx_instruction_info) >> 3) & 0xf),\n\t\t\tfield_value);\n\t} else {\n\t\tif (get_vmx_mem_address(vcpu, exit_qualification,\n\t\t\t\tvmx_instruction_info, true, &gva))\n\t\t\treturn 1;\n\t\tkvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, gva,\n\t\t\t     &field_value, (is_long_mode(vcpu) ? 8 : 4), NULL);\n\t}\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}", "target": 1}
{"code": "static void perf_event_interrupt(struct pt_regs *regs)\n{\n\tint i;\n\tstruct cpu_hw_events *cpuhw = &__get_cpu_var(cpu_hw_events);\n\tstruct perf_event *event;\n\tunsigned long val;\n\tint found = 0;\n\tint nmi;\n\tif (cpuhw->n_limited)\n\t\tfreeze_limited_counters(cpuhw, mfspr(SPRN_PMC5),\n\t\t\t\t\tmfspr(SPRN_PMC6));\n\tperf_read_regs(regs);\n\tnmi = perf_intr_is_nmi(regs);\n\tif (nmi)\n\t\tnmi_enter();\n\telse\n\t\tirq_enter();\n\tfor (i = 0; i < cpuhw->n_events; ++i) {\n\t\tevent = cpuhw->event[i];\n\t\tif (!event->hw.idx || is_limited_pmc(event->hw.idx))\n\t\t\tcontinue;\n\t\tval = read_pmc(event->hw.idx);\n\t\tif ((int)val < 0) {\n\t\t\tfound = 1;\n\t\t\trecord_and_restart(event, val, regs, nmi);\n\t\t}\n\t}\n\tif (!found) {\n\t\tfor (i = 0; i < ppmu->n_counter; ++i) {\n\t\t\tif (is_limited_pmc(i + 1))\n\t\t\t\tcontinue;\n\t\t\tval = read_pmc(i + 1);\n\t\t\tif ((int)val < 0)\n\t\t\t\twrite_pmc(i + 1, 0);\n\t\t}\n\t}\n\twrite_mmcr0(cpuhw, cpuhw->mmcr[0]);\n\tif (nmi)\n\t\tnmi_exit();\n\telse\n\t\tirq_exit();\n}", "target": 1}
{"code": "void IndexedDBDatabase::CallUpgradeTransactionStartedForTesting(\n    int64_t old_version) {\n  DCHECK(active_request_);\n  active_request_->UpgradeTransactionStarted(old_version);\n}", "target": 0}
{"code": "void RGWDelBucketMetaSearch_ObjStore_S3::send_response()\n{\n  if (op_ret)\n    set_req_state_err(s, op_ret);\n  dump_errno(s);\n  end_header(s, this);\n}", "target": 0}
{"code": "static void dbOutputHexBlob(Jsi_DString *dStr, const void *pBlob, int nBlob){\n  int i;\n  char out[100], *zBlob = (char *)pBlob;\n  Jsi_DSAppend(dStr, \"X'\", NULL);\n  for(i=0; i<nBlob; i++){ snprintf(out, sizeof(out),\"%02x\",zBlob[i]&0xff);Jsi_DSAppend(dStr, out, NULL); }\n  Jsi_DSAppend(dStr, \"'\", NULL);\n}", "target": 1}
{"code": "size_t EncodedSizeOfKey(HttpSchemeMetadata, HttpSchemeMetadata::ValueType x) {\n  switch (x) {\n    case HttpSchemeMetadata::kHttp:\n      return 4;\n    case HttpSchemeMetadata::kHttps:\n      return 5;\n    default:\n      return 0;\n  }\n}", "target": 0}
{"code": "bool GLES2DecoderImpl::IsDrawValid(GLuint max_vertex_accessed) {\n  if (!current_program_ || current_program_->IsDeleted()) {\n    return false;\n  }\n  const VertexAttribManager::VertexAttribInfoList& infos =\n      vertex_attrib_manager_.GetEnabledVertexAttribInfos();\n  for (VertexAttribManager::VertexAttribInfoList::const_iterator it =\n           infos.begin(); it != infos.end(); ++it) {\n    const VertexAttribManager::VertexAttribInfo* info = *it;\n    const ProgramManager::ProgramInfo::VertexAttribInfo* attrib_info =\n        current_program_->GetAttribInfoByLocation(info->index());\n    if (attrib_info) {\n      if (!info->CanAccess(max_vertex_accessed)) {\n        SetGLError(GL_INVALID_OPERATION,\n                   \"glDrawXXX: attempt to access out of range vertices\");\n        return false;\n      }\n    } else {\n      if (!info->buffer() || info->buffer()->IsDeleted()) {\n        SetGLError(\n            GL_INVALID_OPERATION,\n            \"glDrawXXX: attempt to render with no buffer attached to enabled \"\n            \"attrib\");\n        return false;\n      }\n    }\n  }\n  return true;\n}", "target": 0}
{"code": "void fmtutil_macbitmap_read_pixmap_only_fields(deark *c, dbuf *f, struct fmtutil_macbitmap_info *bi,\n\ti64 pos)\n{\n\ti64 pixmap_version;\n\ti64 pack_size;\n\ti64 plane_bytes;\n\ti64 n;\n\tde_dbg(c, \"additional PixMap header fields, at %d\", (int)pos);\n\tde_dbg_indent(c, 1);\n\tpixmap_version = dbuf_getu16be(f, pos+0);\n\tde_dbg(c, \"pixmap version: %d\", (int)pixmap_version);\n\tbi->packing_type = dbuf_getu16be(f, pos+2);\n\tde_dbg(c, \"packing type: %d\", (int)bi->packing_type);\n\tpack_size = dbuf_getu32be(f, pos+4);\n\tde_dbg(c, \"pixel data length: %d\", (int)pack_size);\n\tbi->hdpi = pict_read_fixed(f, pos+8);\n\tbi->vdpi = pict_read_fixed(f, pos+12);\n\tde_dbg(c, \"dpi: %.2f\"DE_CHAR_TIMES\"%.2f\", bi->hdpi, bi->vdpi);\n\tbi->pixeltype = dbuf_getu16be(f, pos+16);\n\tbi->pixelsize = dbuf_getu16be(f, pos+18);\n\tbi->cmpcount = dbuf_getu16be(f, pos+20);\n\tbi->cmpsize = dbuf_getu16be(f, pos+22);\n\tde_dbg(c, \"pixel type=%d, bits/pixel=%d, components/pixel=%d, bits/comp=%d\",\n\t\t(int)bi->pixeltype, (int)bi->pixelsize, (int)bi->cmpcount, (int)bi->cmpsize);\n\tbi->pdwidth = (bi->rowbytes*8)/bi->pixelsize;\n\tif(bi->pdwidth < bi->npwidth) {\n\t\tbi->pdwidth = bi->npwidth;\n\t}\n\tplane_bytes = dbuf_getu32be(f, pos+24);\n\tde_dbg(c, \"plane bytes: %d\", (int)plane_bytes);\n\tbi->pmTable = (u32)dbuf_getu32be(f, pos+28);\n\tde_dbg(c, \"pmTable: 0x%08x\", (unsigned int)bi->pmTable);\n\tn = dbuf_getu32be(f, pos+32);\n\tde_dbg(c, \"pmReserved: 0x%08x\", (unsigned int)n);\n\tde_dbg_indent(c, -1);\n}", "target": 1}
{"code": "ev_archive_get_entry_pathname (EvArchive *archive)\n{\n\tg_return_val_if_fail (EV_IS_ARCHIVE (archive), NULL);\n\tg_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, NULL);\n\tswitch (archive->type) {\n\tcase EV_ARCHIVE_TYPE_NONE:\n\t\tg_assert_not_reached ();\n\tcase EV_ARCHIVE_TYPE_RAR:\n\tcase EV_ARCHIVE_TYPE_ZIP:\n\tcase EV_ARCHIVE_TYPE_7Z:\n\tcase EV_ARCHIVE_TYPE_TAR:\n\t\tg_return_val_if_fail (archive->libar_entry != NULL, NULL);\n\t\treturn archive_entry_pathname (archive->libar_entry);\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "TfLiteStatus Subgraph::CheckInputAndOutputForOverlap(const int* input_indices,\n                                                     int num_inputs,\n                                                     const int* output_indices,\n                                                     int num_outputs) {\n  for (int i = 0; i < num_inputs; i++) {\n    for (int j = 0; j < num_outputs; j++) {\n      if (input_indices[i] == output_indices[j]) {\n        ReportError(\"Tensor %d is both input %d and output %d\\n\",\n                    input_indices[i], i, j);\n        consistent_ = false;\n        return kTfLiteError;\n      }\n    }\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static BOOL nsc_rle_decode(BYTE* in, BYTE* out, UINT32 outSize, UINT32 originalSize)\n{\n\tUINT32 left = originalSize;\n\twhile (left > 4)\n\t{\n\t\tconst BYTE value = *in++;\n\t\tUINT32 len = 0;\n\t\tif (left == 5)\n\t\t{\n\t\t\tif (outSize < 1)\n\t\t\t\treturn FALSE;\n\t\t\toutSize--;\n\t\t\t*out++ = value;\n\t\t\tleft--;\n\t\t}\n\t\telse if (value == *in)\n\t\t{\n\t\t\tin++;\n\t\t\tif (*in < 0xFF)\n\t\t\t{\n\t\t\t\tlen = (UINT32)*in++;\n\t\t\t\tlen += 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tin++;\n\t\t\t\tlen = ((UINT32)(*in++));\n\t\t\t\tlen |= ((UINT32)(*in++)) << 8U;\n\t\t\t\tlen |= ((UINT32)(*in++)) << 16U;\n\t\t\t\tlen |= ((UINT32)(*in++)) << 24U;\n\t\t\t}\n\t\t\tif (outSize < len)\n\t\t\t\treturn FALSE;\n\t\t\toutSize -= len;\n\t\t\tFillMemory(out, len, value);\n\t\t\tout += len;\n\t\t\tleft -= len;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (outSize < 1)\n\t\t\t\treturn FALSE;\n\t\t\toutSize--;\n\t\t\t*out++ = value;\n\t\t\tleft--;\n\t\t}\n\t}\n\tif ((outSize < 4) || (left < 4))\n\t\treturn FALSE;\n\tmemcpy(out, in, 4);\n\treturn TRUE;\n}", "target": 1}
{"code": "mrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)\n{\n  mrb_value orig;\n  mrb_value buf;\n  struct mrb_io *fptr_copy;\n  struct mrb_io *fptr_orig;\n  mrb_bool failed = TRUE;\n  mrb_get_args(mrb, \"o\", &orig);\n  fptr_copy = (struct mrb_io *)DATA_PTR(copy);\n  if (fptr_copy != NULL) {\n    fptr_finalize(mrb, fptr_copy, FALSE);\n    mrb_free(mrb, fptr_copy);\n  }\n  fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);\n  fptr_orig = io_get_open_fptr(mrb, orig);\n  DATA_TYPE(copy) = &mrb_io_type;\n  DATA_PTR(copy) = fptr_copy;\n  buf = mrb_iv_get(mrb, orig, mrb_intern_cstr(mrb, \"@buf\"));\n  mrb_iv_set(mrb, copy, mrb_intern_cstr(mrb, \"@buf\"), buf);\n  fptr_copy->fd = mrb_dup(mrb, fptr_orig->fd, &failed);\n  if (failed) {\n    mrb_sys_fail(mrb, 0);\n  }\n  mrb_fd_cloexec(mrb, fptr_copy->fd);\n  if (fptr_orig->fd2 != -1) {\n    fptr_copy->fd2 = mrb_dup(mrb, fptr_orig->fd2, &failed);\n    if (failed) {\n      close(fptr_copy->fd);\n      mrb_sys_fail(mrb, 0);\n    }\n    mrb_fd_cloexec(mrb, fptr_copy->fd2);\n  }\n  fptr_copy->pid = fptr_orig->pid;\n  fptr_copy->readable = fptr_orig->readable;\n  fptr_copy->writable = fptr_orig->writable;\n  fptr_copy->sync = fptr_orig->sync;\n  fptr_copy->is_socket = fptr_orig->is_socket;\n  return copy;\n}", "target": 1}
{"code": "init_pyfribidi (void)\n{\n        PyObject *module = Py_InitModule (\"_pyfribidi\", PyfribidiMethods);\n\tPyModule_AddIntConstant (module, \"RTL\", (long) FRIBIDI_TYPE_RTL);\n\tPyModule_AddIntConstant (module, \"LTR\", (long) FRIBIDI_TYPE_LTR);\n\tPyModule_AddIntConstant (module, \"ON\", (long) FRIBIDI_TYPE_ON);\n}", "target": 0}
{"code": "void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)\n\t{\n#ifdef BN_LLONG\n\tBN_ULLONG t,tt;\n#else\n\tBN_ULONG bl,bh;\n#endif\n\tBN_ULONG t1,t2;\n\tBN_ULONG c1,c2,c3;\n\tc1=0;\n\tc2=0;\n\tc3=0;\n\tsqr_add_c(a,0,c1,c2,c3);\n\tr[0]=c1;\n\tc1=0;\n\tsqr_add_c2(a,1,0,c2,c3,c1);\n\tr[1]=c2;\n\tc2=0;\n\tsqr_add_c(a,1,c3,c1,c2);\n\tsqr_add_c2(a,2,0,c3,c1,c2);\n\tr[2]=c3;\n\tc3=0;\n\tsqr_add_c2(a,3,0,c1,c2,c3);\n\tsqr_add_c2(a,2,1,c1,c2,c3);\n\tr[3]=c1;\n\tc1=0;\n\tsqr_add_c(a,2,c2,c3,c1);\n\tsqr_add_c2(a,3,1,c2,c3,c1);\n\tr[4]=c2;\n\tc2=0;\n\tsqr_add_c2(a,3,2,c3,c1,c2);\n\tr[5]=c3;\n\tc3=0;\n\tsqr_add_c(a,3,c1,c2,c3);\n\tr[6]=c1;\n\tr[7]=c2;\n\t}", "target": 1}
{"code": "int64 Archive::Tell()\n{\n#ifdef USE_QOPEN\n  int64 QPos;\n  if (QOpen.Tell(&QPos))\n    return QPos;\n#endif\n#ifdef USE_ARCMEM\n  int64 APos;\n  if (ArcMem.Tell(&APos))\n    return APos;\n#endif\n  return File::Tell();\n}", "target": 0}
{"code": "void inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t\telse if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP) &&\n\t\t\t !in_group_p(inode->i_gid) &&\n\t\t\t !capable_wrt_inode_uidgid(dir, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}", "target": 0}
{"code": "std::wstring GetUniqueTempDirectoryPrefix()\n{\n    wchar_t tmpdir[MAX_PATH + 1];\n    if (GetTempPath(MAX_PATH + 1, tmpdir) == 0)\n        throw Win32Exception(\"Cannot create temporary directory\");\n    std::wstring dir(tmpdir);\n    dir += L\"Update-\";\n    return dir;\n}", "target": 0}
{"code": "rpmRC rpmReadPackageFile(rpmts ts, FD_t fd, const char * fn, Header * hdrp)\n{\n    char *msg = NULL;\n    Header h = NULL;\n    Header sigh = NULL;\n    hdrblob blob = NULL;\n    hdrblob sigblob = NULL;\n    rpmVSFlags vsflags = rpmtsVSFlags(ts) | RPMVSF_NEEDPAYLOAD;\n    rpmKeyring keyring = rpmtsGetKeyring(ts, 1);\n    struct rpmvs_s *vs = rpmvsCreate(0, vsflags, keyring);\n    struct pkgdata_s pkgdata = {\n\t.msgfunc = loghdrmsg,\n\t.fn = fn ? fn : Fdescr(fd),\n\t.msg = NULL,\n\t.rc = RPMRC_OK,\n    };\n    if (hdrp)\n\t*hdrp = NULL;\n    rpmRC rc = rpmpkgRead(vs, fd, &sigblob, &blob, &msg);\n    if (rc)\n\tgoto exit;\n    rc = RPMRC_FAIL;\n    if (!rpmvsVerify(vs, RPMSIG_VERIFIABLE_TYPE, handleHdrVS, &pkgdata)) {\n\tif (hdrp) {\n\t    if (hdrblobImport(sigblob, 0, &sigh, &msg))\n\t\tgoto exit;\n\t    if (hdrblobImport(blob, 0, &h, &msg))\n\t\tgoto exit;\n\t    headerMergeLegacySigs(h, sigh);\n\t    applyRetrofits(h);\n\t    *hdrp = headerLink(h);\n\t}\n\trc = RPMRC_OK;\n    }\n    if (rc == RPMRC_OK && pkgdata.rc)\n\trc = pkgdata.rc;\nexit:\n    if (rc && msg)\n\trpmlog(RPMLOG_ERR, \"%s: %s\\n\", Fdescr(fd), msg);\n    hdrblobFree(sigblob);\n    hdrblobFree(blob);\n    headerFree(sigh);\n    headerFree(h);\n    rpmKeyringFree(keyring);\n    rpmvsFree(vs);\n    free(msg);\n    return rc;\n}", "target": 1}
{"code": "ext4_xattr_block_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct buffer_head *bh = NULL;\n\tint error;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\tea_idebug(inode, \"buffer=%p, buffer_size=%ld\",\n\t\t  buffer, (long)buffer_size);\n\terror = 0;\n\tif (!EXT4_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %llu\",\n\t\t  (unsigned long long)EXT4_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);\n\terror = -EIO;\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));\n\tif (ext4_xattr_check_block(inode, bh)) {\n\t\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t\t EXT4_I(inode)->i_file_acl);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto cleanup;\n\t}\n\text4_xattr_cache_insert(ext4_mb_cache, bh);\n\terror = ext4_xattr_list_entries(dentry, BFIRST(bh), buffer, buffer_size);\ncleanup:\n\tbrelse(bh);\n\treturn error;\n}", "target": 1}
{"code": "static void vmx_sync_pir_to_irr(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tif (!pi_test_and_clear_on(&vmx->pi_desc))\n\t\treturn;\n\tkvm_apic_update_irr(vcpu, vmx->pi_desc.pir);\n}", "target": 0}
{"code": "static void _pam_log_int(const pam_handle_t *pamh,\n\t\t\t int err,\n\t\t\t const char *format,\n\t\t\t va_list args)\n{\n\tpam_vsyslog(pamh, err, format, args);\n}", "target": 0}
{"code": "void jfs_evict_inode(struct inode *inode)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\tjfs_info(\"In jfs_evict_inode, inode = 0x%p\", inode);\n\tif (!inode->i_nlink && !is_bad_inode(inode)) {\n\t\tdquot_initialize(inode);\n\t\tif (JFS_IP(inode)->fileset == FILESYSTEM_I) {\n\t\t\ttruncate_inode_pages_final(&inode->i_data);\n\t\t\tif (test_cflag(COMMIT_Freewmap, inode))\n\t\t\t\tjfs_free_zero_link(inode);\n\t\t\tif (JFS_SBI(inode->i_sb)->ipimap)\n\t\t\t\tdiFree(inode);\n\t\t\tdquot_free_inode(inode);\n\t\t}\n\t} else {\n\t\ttruncate_inode_pages_final(&inode->i_data);\n\t}\n\tclear_inode(inode);\n\tdquot_drop(inode);\n\tBUG_ON(!list_empty(&ji->anon_inode_list));\n\tspin_lock_irq(&ji->ag_lock);\n\tif (ji->active_ag != -1) {\n\t\tstruct bmap *bmap = JFS_SBI(inode->i_sb)->bmap;\n\t\tatomic_dec(&bmap->db_active[ji->active_ag]);\n\t\tji->active_ag = -1;\n\t}\n\tspin_unlock_irq(&ji->ag_lock);\n}", "target": 1}
{"code": "http_error_t::make_body (int n, const str &si, const str &aux)\n{\n  strbuf b;\n  str ldesc;\n  const str sdesc = http_status.get_desc (n, &ldesc);\n  b << \"<html>\\n\"\n    << \" <head>\\n\"\n    << \"  <title>\" << n << \" \" << sdesc << \"</title>\\n\"\n    << \" </head>\\n\"\n    << \" <body>\\n\"\n    << \" <h1>Error \" << n << \" \" << sdesc << \"</h1><br><br>\\n\"\n    ;\n  if (n == HTTP_NOT_FOUND && aux) {\n    b << \"The file <tt>\" << aux \n      << \"</tt> was not found on this server.<br><br>\\n\\n\";\n  }\n  b << \"  <hr>\\n\"\n    << \"  <i>\" << si << \"</i>\\n\"\n    << \" <br>\\n\"\n    << \" </body>\\n\"\n    << \"</html>\\n\"\n    ;\n  return b;\n}", "target": 1}
{"code": "SYSCALL_DEFINE1(inotify_init1, int, flags)\n{\n\tstruct fsnotify_group *group;\n\tint ret;\n\tBUILD_BUG_ON(IN_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON(IN_NONBLOCK != O_NONBLOCK);\n\tif (flags & ~(IN_CLOEXEC | IN_NONBLOCK))\n\t\treturn -EINVAL;\n\tgroup = inotify_new_group(inotify_max_queued_events);\n\tif (IS_ERR(group))\n\t\treturn PTR_ERR(group);\n\tret = anon_inode_getfd(\"inotify\", &inotify_fops, group,\n\t\t\t\t  O_RDONLY | flags);\n\tif (ret < 0)\n\t\tfsnotify_put_group(group);\n\treturn ret;\n}", "target": 0}
{"code": "TfLiteStatus CalculateArithmeticOpData(TfLiteContext* context, TfLiteNode* node,\n                                       OpData* data) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  if (input->type == kTfLiteInt8) {\n    TF_LITE_ENSURE_EQ(context, output->params.zero_point,\n                      std::numeric_limits<int8_t>::min());\n    static constexpr int kInputIntegerBits = 4;\n    const double input_real_multiplier =\n        static_cast<double>(input->params.scale) *\n        static_cast<double>(1 << (31 - kInputIntegerBits));\n    data->input_zero_point = input->params.zero_point;\n    const double q = std::frexp(input_real_multiplier, &data->input_left_shift);\n    data->input_multiplier = static_cast<int32_t>(TfLiteRound(q * (1ll << 31)));\n    data->input_range_radius =\n        CalculateInputRadius(kInputIntegerBits, data->input_left_shift, 31);\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "  void ClearSchemes() {\n    schemes_.clear();\n  }", "target": 0}
{"code": "d_lite_inspect(VALUE self)\n{\n    get_d1(self);\n    return mk_inspect(dat, rb_obj_class(self), self);\n}", "target": 0}
{"code": "void ImageLoader::DecodeRequest::Trace(blink::Visitor* visitor) {\n  visitor->Trace(resolver_);\n  visitor->Trace(loader_);\n}", "target": 0}
{"code": "htp_status_t htp_tx_req_process_body_data(htp_tx_t *tx, const void *data, size_t len) {\n    if ((tx == NULL) || (data == NULL)) return HTP_ERROR;\n    if (len == 0) return HTP_OK;\n    return htp_tx_req_process_body_data_ex(tx, data, len);\n}", "target": 0}
{"code": "static void on_umock_c_error(UMOCK_C_ERROR_CODE error_code)\n{\n    ASSERT_FAIL(\"umock_c reported error :%\" PRI_MU_ENUM \"\", MU_ENUM_VALUE(UMOCK_C_ERROR_CODE, error_code));\n}", "target": 0}
{"code": "static void progress_handler(int progress, void *arg)\n{\n\tprintf(\"Progress=%d\\n\", progress);\n}", "target": 0}
{"code": "        unsigned int GetU32BE (int nPos, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos + 3 >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            unsigned int nRes = m_sFile[nPos];\n            nRes = (nRes << 8) + m_sFile[nPos + 1];\n            nRes = (nRes << 8) + m_sFile[nPos + 2];\n            nRes = (nRes << 8) + m_sFile[nPos + 3];\n            return nRes;\n        }", "target": 1}
{"code": "static const char *set_trace_enable(cmd_parms *cmd, void *dummy,\n                                    const char *arg1)\n{\n    core_server_config *conf =\n        ap_get_core_module_config(cmd->server->module_config);\n    if (ap_cstr_casecmp(arg1, \"on\") == 0) {\n        conf->trace_enable = AP_TRACE_ENABLE;\n    }\n    else if (ap_cstr_casecmp(arg1, \"off\") == 0) {\n        conf->trace_enable = AP_TRACE_DISABLE;\n    }\n    else if (ap_cstr_casecmp(arg1, \"extended\") == 0) {\n        conf->trace_enable = AP_TRACE_EXTENDED;\n    }\n    else {\n        return \"TraceEnable must be one of 'on', 'off', or 'extended'\";\n    }\n    return NULL;\n}", "target": 0}
{"code": "comics_check_decompress_support\t(gchar          *mime_type,\n\t\t\t\t ComicsDocument *comics_document,\n\t\t\t\t GError         **error)\n{\n\tif (g_content_type_is_a (mime_type, \"application/x-cbr\") ||\n\t    g_content_type_is_a (mime_type, \"application/x-rar\")) {\n\t\tif (ev_archive_set_archive_type (comics_document->archive, EV_ARCHIVE_TYPE_RAR))\n\t\t\treturn TRUE;\n\t} else if (g_content_type_is_a (mime_type, \"application/x-cbz\") ||\n\t\t   g_content_type_is_a (mime_type, \"application/zip\")) {\n\t\tif (ev_archive_set_archive_type (comics_document->archive, EV_ARCHIVE_TYPE_ZIP))\n\t\t\treturn TRUE;\n\t} else if (g_content_type_is_a (mime_type, \"application/x-cb7\") ||\n\t\t   g_content_type_is_a (mime_type, \"application/x-7z-compressed\")) {\n\t\tif (ev_archive_set_archive_type (comics_document->archive, EV_ARCHIVE_TYPE_7Z))\n\t\t\treturn TRUE;\n\t} else if (g_content_type_is_a (mime_type, \"application/x-cbt\") ||\n\t\t   g_content_type_is_a (mime_type, \"application/x-tar\")) {\n\tif (ev_archive_set_archive_type (comics_document->archive, EV_ARCHIVE_TYPE_TAR))\n\t\t\treturn TRUE;\n\t} else {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"Not a comic book MIME type: %s\"),\n\t\t\t     mime_type);\n\t\t\t     return FALSE;\n\t}\n\tg_set_error_literal (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t             _(\"libarchive lacks support for this comic books \"\n\t\t\t     \"compression, please contact your distributor\"));\n\treturn FALSE;\n}", "target": 0}
{"code": "Opal::Call::emit_established_in_main ()\n{\n  established ();\n}", "target": 0}
{"code": "struct MACH0_(obj_t) {\n\tstruct MACH0_(mach_header) hdr;\n\tstruct MACH0_(segment_command) *segs;\n\tchar *intrp;\n\tchar *compiler;\n\tint nsegs;\n\tint segs_count;\n\tstruct r_dyld_chained_starts_in_segment **chained_starts;\n\tstruct dyld_chained_fixups_header fixups_header;\n\tut64 fixups_offset;\n\tut64 fixups_size;\n\tstruct MACH0_(section) *sects;\n\tint nsects;\n\tstruct MACH0_(nlist) *symtab;\n\tut8 *symstr;\n\tut8 *func_start; \n\tint symstrlen;\n\tint nsymtab;\n\tut32 *indirectsyms;\n\tint nindirectsyms;\n\tRBinImport **imports_by_ord;\n\tsize_t imports_by_ord_size;\n\tHtPP *imports_by_name;\n\tstruct dysymtab_command dysymtab;\n\tstruct load_command main_cmd;\n\tstruct dyld_info_command *dyld_info;\n\tstruct dylib_table_of_contents *toc;\n\tint ntoc;\n\tstruct MACH0_(dylib_module) *modtab;\n\tint nmodtab;\n\tstruct thread_command thread;\n\tut8 *signature;\n\tunion {\n\t\tstruct x86_thread_state32 x86_32;\n\t\tstruct x86_thread_state64 x86_64;\n\t\tstruct ppc_thread_state32 ppc_32;\n\t\tstruct ppc_thread_state64 ppc_64;\n\t\tstruct arm_thread_state32 arm_32;\n\t\tstruct arm_thread_state64 arm_64;\n\t} thread_state;\n\tchar (*libs)[R_BIN_MACH0_STRING_LENGTH];\n\tint nlibs;\n\tint size;\n\tut64 baddr;\n\tut64 entry;\n\tbool big_endian;\n\tconst char *file;\n\tRBuffer *b;\n\tint os;\n\tSdb *kv;\n\tint has_crypto;\n\tint has_canary;\n\tint has_retguard;\n\tint has_sanitizers;\n\tint has_blocks_ext;\n\tint dbg_info;\n\tconst char *lang;\n\tint uuidn;\n\tint func_size;\n\tbool verbose;\n\tut64 header_at;\n\tut64 symbols_off;\n\tvoid *user;\n\tut64 (*va2pa)(ut64 p, ut32 *offset, ut32 *left, RBinFile *bf);\n\tstruct symbol_t *symbols;\n\tut64 main_addr;\n\tint (*original_io_read)(RIO *io, RIODesc *fd, ut8 *buf, int count);\n\tbool rebasing_buffer;\n};", "target": 0}
{"code": "static MagickOffsetType TIFFSeekCustomStream(const MagickOffsetType offset,\n  const int whence,void *user_data)\n{\n  PhotoshopProfile\n    *profile;\n  profile=(PhotoshopProfile *) user_data;\n  switch (whence)\n  {\n    case SEEK_SET:\n    default:\n    {\n      if (offset < 0)\n        return(-1);\n      profile->offset=offset;\n      break;\n    }\n    case SEEK_CUR:\n    {\n      if (((offset > 0) && (profile->offset > (SSIZE_MAX-offset))) ||\n          ((offset < 0) && (profile->offset < (-SSIZE_MAX-offset))))\n        {\n          errno=EOVERFLOW;\n          return(-1);\n        }\n      if ((profile->offset+offset) < 0)\n        return(-1);\n      profile->offset+=offset;\n      break;\n    }\n    case SEEK_END:\n    {\n      if (((MagickOffsetType) profile->length+offset) < 0)\n        return(-1);\n      profile->offset=profile->length+offset;\n      break;\n    }\n  }\n  return(profile->offset);\n}", "target": 0}
{"code": "void mesh_state_remove_reply(struct mesh_area* mesh, struct mesh_state* m,\n\tstruct comm_point* cp)\n{\n\tstruct mesh_reply* n, *prev = NULL;\n\tn = m->reply_list;\n\tif(!n) return; \n\twhile(n) {\n\t\tif(n->query_reply.c == cp) {\n\t\t\tif(prev) prev->next = n->next;\n\t\t\telse m->reply_list = n->next;\n\t\t\tlog_assert(mesh->num_reply_addrs > 0);\n\t\t\tmesh->num_reply_addrs--;\n\t\t\tinfra_wait_limit_dec(mesh->env->infra_cache,\n\t\t\t\t&n->query_reply, mesh->env->cfg);\n\t\t\tn = n->next;\n\t\t\tcontinue;\n\t\t}\n\t\tprev = n;\n\t\tn = n->next;\n\t}\n\tif(!m->reply_list && !m->cb_list\n\t\t&& m->super_set.count == 0) {\n\t\tmesh->num_detached_states++;\n\t}\n\tif(!m->reply_list && !m->cb_list) {\n\t\tlog_assert(mesh->num_reply_states > 0);\n\t\tmesh->num_reply_states--;\n\t}\n}", "target": 0}
{"code": "void rdma_lock_handler(struct rdma_cm_id *id)\n{\n\tstruct rdma_id_private *id_priv =\n\t\tcontainer_of(id, struct rdma_id_private, id);\n\tmutex_lock(&id_priv->handler_mutex);\n}", "target": 0}
{"code": "int pipe_resize_ring(struct pipe_inode_info *pipe, unsigned int nr_slots)\n{\n\tstruct pipe_buffer *bufs;\n\tunsigned int head, tail, mask, n;\n\tmask = pipe->ring_size - 1;\n\thead = pipe->head;\n\ttail = pipe->tail;\n\tn = pipe_occupancy(pipe->head, pipe->tail);\n\tif (nr_slots < n)\n\t\treturn -EBUSY;\n\tbufs = kcalloc(nr_slots, sizeof(*bufs),\n\t\t       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);\n\tif (unlikely(!bufs))\n\t\treturn -ENOMEM;\n\tif (n > 0) {\n\t\tunsigned int h = head & mask;\n\t\tunsigned int t = tail & mask;\n\t\tif (h > t) {\n\t\t\tmemcpy(bufs, pipe->bufs + t,\n\t\t\t       n * sizeof(struct pipe_buffer));\n\t\t} else {\n\t\t\tunsigned int tsize = pipe->ring_size - t;\n\t\t\tif (h > 0)\n\t\t\t\tmemcpy(bufs + tsize, pipe->bufs,\n\t\t\t\t       h * sizeof(struct pipe_buffer));\n\t\t\tmemcpy(bufs, pipe->bufs + t,\n\t\t\t       tsize * sizeof(struct pipe_buffer));\n\t\t}\n\t}\n\thead = n;\n\ttail = 0;\n\tkfree(pipe->bufs);\n\tpipe->bufs = bufs;\n\tpipe->ring_size = nr_slots;\n\tif (pipe->max_usage > nr_slots)\n\t\tpipe->max_usage = nr_slots;\n\tpipe->tail = tail;\n\tpipe->head = head;\n\twake_up_interruptible(&pipe->wr_wait);\n\treturn 0;\n}", "target": 1}
{"code": "safe_add (int a, int b)\n{\n  if (a > INT_MAX/2 || b > INT_MAX/2)\n    return a > b ? a : b;\n  else\n    return a + b;\n}", "target": 0}
{"code": "static inline zend_object_value date_object_new_date_ex(zend_class_entry *class_type, php_date_obj **ptr TSRMLS_DC)\n{\n\tphp_date_obj *intern;\n\tzend_object_value retval;\n\tintern = emalloc(sizeof(php_date_obj));\n\tmemset(intern, 0, sizeof(php_date_obj));\n\tif (ptr) {\n\t\t*ptr = intern;\n\t}\n\tzend_object_std_init(&intern->std, class_type TSRMLS_CC);\n\tobject_properties_init(&intern->std, class_type);\n\tretval.handle = zend_objects_store_put(intern, (zend_objects_store_dtor_t)zend_objects_destroy_object, (zend_objects_free_object_storage_t) date_object_free_storage_date, NULL TSRMLS_CC);\n\tretval.handlers = &date_object_handlers_date;\n\treturn retval;", "target": 0}
{"code": "struct dentry *debugfs_rename(struct dentry *old_dir, struct dentry *old_dentry,\n\t\tstruct dentry *new_dir, const char *new_name)\n{\n\tint error;\n\tstruct dentry *dentry = NULL, *trap;\n\tconst char *old_name;\n\ttrap = lock_rename(new_dir, old_dir);\n\tif (d_really_is_negative(old_dir) || d_really_is_negative(new_dir))\n\t\tgoto exit;\n\tif (d_really_is_negative(old_dentry) || old_dentry == trap ||\n\t    d_mountpoint(old_dentry))\n\t\tgoto exit;\n\tdentry = lookup_one_len(new_name, new_dir, strlen(new_name));\n\tif (IS_ERR(dentry) || dentry == trap || d_really_is_positive(dentry))\n\t\tgoto exit;\n\told_name = fsnotify_oldname_init(old_dentry->d_name.name);\n\terror = simple_rename(d_inode(old_dir), old_dentry, d_inode(new_dir),\n\t\t\t      dentry, 0);\n\tif (error) {\n\t\tfsnotify_oldname_free(old_name);\n\t\tgoto exit;\n\t}\n\td_move(old_dentry, dentry);\n\tfsnotify_move(d_inode(old_dir), d_inode(new_dir), old_name,\n\t\td_is_dir(old_dentry),\n\t\tNULL, old_dentry);\n\tfsnotify_oldname_free(old_name);\n\tunlock_rename(new_dir, old_dir);\n\tdput(dentry);\n\treturn old_dentry;\nexit:\n\tif (dentry && !IS_ERR(dentry))\n\t\tdput(dentry);\n\tunlock_rename(new_dir, old_dir);\n\treturn NULL;\n}", "target": 1}
{"code": "spnego_gss_inquire_context(\n\t\t\tOM_uint32\t*minor_status,\n\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\tgss_name_t\t*src_name,\n\t\t\tgss_name_t\t*targ_name,\n\t\t\tOM_uint32\t*lifetime_rec,\n\t\t\tgss_OID\t\t*mech_type,\n\t\t\tOM_uint32\t*ctx_flags,\n\t\t\tint\t\t*locally_initiated,\n\t\t\tint\t\t*opened)\n{\n\tOM_uint32 ret = GSS_S_COMPLETE;\n\tret = gss_inquire_context(minor_status,\n\t\t\t\tcontext_handle,\n\t\t\t\tsrc_name,\n\t\t\t\ttarg_name,\n\t\t\t\tlifetime_rec,\n\t\t\t\tmech_type,\n\t\t\t\tctx_flags,\n\t\t\t\tlocally_initiated,\n\t\t\t\topened);\n\treturn (ret);\n}", "target": 1}
{"code": "static void JS_FoxxAllowInstallFromRemote(\n    v8::FunctionCallbackInfo<v8::Value> const& args) {\n  TRI_V8_TRY_CATCH_BEGIN(isolate)\n  v8::HandleScope scope(isolate);\n  TRI_GET_GLOBALS();\n  ServerSecurityFeature& security =\n      v8g->_server.getFeature<ServerSecurityFeature>();\n  TRI_V8_RETURN_BOOL(security.foxxAllowInstallFromRemote());\n  TRI_V8_TRY_CATCH_END\n}", "target": 0}
{"code": "extract_epub_from_container (const gchar* uri,\n                             EpubDocument *epub_document,\n                             GError ** error)\n{\n    GError *err = NULL;\n    epub_document->archivename = g_filename_from_uri(uri,NULL,error);\n    if ( !epub_document->archivename )\n    {\n        if (err) {\n            g_propagate_error (error, err);\n        }\n        else {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not retrieve filename\"));\n        }\n        return FALSE;\n    }\n    gchar *epubfilename = g_strrstr(epub_document->archivename,\"/\");\n    if ( *epubfilename == '/' )\n        epubfilename++ ;\n    GString *temporary_sub_directory = g_string_new(epubfilename);\n    g_string_append(temporary_sub_directory,\"XXXXXX\") ;\n    epub_document->tmp_archive_dir = ev_mkdtemp(temporary_sub_directory->str, error);\n    g_string_free(temporary_sub_directory, TRUE);\n    if (!epub_document->tmp_archive_dir) {\n        return FALSE;\n    }\n    epub_document->epubDocument = unzOpen64(epub_document->archivename);\n    if ( epub_document->epubDocument == NULL )\n    {\n        if (err)    {\n            g_propagate_error (error, err);\n        }\n        else    {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not open archive\"));\n        }\n        return FALSE;\n    }\n    gboolean result = FALSE;\n    if ( unzGoToFirstFile(epub_document->epubDocument) != UNZ_OK )\n    {\n        if (err) {\n            g_propagate_error (error, err);\n        }\n        else    {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not extract archive\"));\n        }\n        goto out;\n    }\n    while ( TRUE )\n    {\n        if ( extract_one_file(epub_document,&err) == FALSE )\n        {\n            if (err) {\n                g_propagate_error (error, err);\n            }\n            else    {\n                g_set_error_literal (error,\n                             EV_DOCUMENT_ERROR,\n                             EV_DOCUMENT_ERROR_INVALID,\n                             _(\"could not extract archive\"));\n            }\n\t\t\tgoto out;\n        }\n        if ( unzGoToNextFile(epub_document->epubDocument) == UNZ_END_OF_LIST_OF_FILE ) {\n            result = TRUE;\n            break;\n        }\n    }\nout:\n    unzClose(epub_document->epubDocument);\n    return result;\n}", "target": 1}
{"code": "int fz_colorspace_is_subtractive(fz_context *ctx, const fz_colorspace *cs)\n{\n\treturn cs && (cs->type == FZ_COLORSPACE_CMYK || cs->type == FZ_COLORSPACE_SEPARATION);\n}", "target": 0}
{"code": "TfLiteStatus SimpleStatefulOp::Invoke(TfLiteContext* context,\n                                      TfLiteNode* node) {\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n  *data->invoke_count += 1;\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const uint8_t* input_data = GetTensorData<uint8_t>(input);\n  int size = NumElements(input->dims);\n  uint8_t* sorting_buffer = reinterpret_cast<uint8_t*>(\n      context->GetScratchBuffer(context, data->sorting_buffer));\n  for (int i = 0; i < size; i++) {\n    sorting_buffer[i] = input_data[i];\n  }\n  for (int i = 1; i < size; i++) {\n    for (int j = i; j > 0 && sorting_buffer[j] < sorting_buffer[j - 1]; j--) {\n      std::swap(sorting_buffer[j], sorting_buffer[j - 1]);\n    }\n  }\n  TfLiteTensor* median = GetOutput(context, node, kMedianTensor);\n  uint8_t* median_data = GetTensorData<uint8_t>(median);\n  TfLiteTensor* invoke_count = GetOutput(context, node, kInvokeCount);\n  int32_t* invoke_count_data = GetTensorData<int32_t>(invoke_count);\n  median_data[0] = sorting_buffer[size / 2];\n  invoke_count_data[0] = *data->invoke_count;\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static s32 adpt_rescan(adpt_hba* pHba)\n{\n\ts32 rcode;\n\tulong flags = 0;\n\tif(pHba->host)\n\t\tspin_lock_irqsave(pHba->host->host_lock, flags);\n\tif ((rcode=adpt_i2o_lct_get(pHba)) < 0)\n\t\tgoto out;\n\tif ((rcode=adpt_i2o_reparse_lct(pHba)) < 0)\n\t\tgoto out;\n\trcode = 0;\nout:\tif(pHba->host)\n\t\tspin_unlock_irqrestore(pHba->host->host_lock, flags);\n\treturn rcode;\n}", "target": 1}
{"code": "TEST(BCastTest, Basic_Tensor_Scalar) {\n  EXPECT_EQ(BCast({11, 7, 5, 3, 2}, {1}),\n            \"[2310][1][1][2310]\"\n            \"[2310]\"\n            \"[11,7,5,3,2]\"\n            \"[][0,1,2,3,4]\");\n  EXPECT_EQ(BCast({11, 7, 5, 3, 2}, {1}, false),\n            \"[11,7,5,3,2][1,1,1,1,1][1,1,1,1,1][11,7,5,3,2]\"\n            \"[11,7,5,3,2]\"\n            \"[11,7,5,3,2]\"\n            \"[][0,1,2,3,4]\");\n  EXPECT_EQ(BCast({1}, {11, 7, 5, 3, 2}),\n            \"[1][2310][2310][1]\"\n            \"[2310]\"\n            \"[11,7,5,3,2]\"\n            \"[0,1,2,3,4][]\");\n  EXPECT_EQ(BCast({1}, {11, 7, 5, 3, 2}, false),\n            \"[1,1,1,1,1][11,7,5,3,2][11,7,5,3,2][1,1,1,1,1]\"\n            \"[11,7,5,3,2]\"\n            \"[11,7,5,3,2]\"\n            \"[0,1,2,3,4][]\");\n  EXPECT_EQ(BCast({1, 2147483648}, {1}),\n            \"[2147483648][1][1][2147483648]\"\n            \"[2147483648]\"\n            \"[1,2147483648]\"\n            \"[0][0,1]\");\n}", "target": 0}
{"code": "yy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule, void *yyscanner, RE_LEX_ENVIRONMENT *lex_env)\n{\n  unsigned long int yylno = yyrline[yyrule];\n  int yynrhs = yyr2[yyrule];\n  int yyi;\n  YYFPRINTF (stderr, \"Reducing stack by rule %d (line %lu):\\n\",\n             yyrule - 1, yylno);\n  for (yyi = 0; yyi < yynrhs; yyi++)\n    {\n      YYFPRINTF (stderr, \"   $%d = \", yyi + 1);\n      yy_symbol_print (stderr,\n                       yystos[yyssp[yyi + 1 - yynrhs]],\n                       &(yyvsp[(yyi + 1) - (yynrhs)])\n                                              , yyscanner, lex_env);\n      YYFPRINTF (stderr, \"\\n\");\n    }\n}", "target": 0}
{"code": "int sr_do_ioctl(Scsi_CD *cd, struct packet_command *cgc)\n{\n\tstruct scsi_device *SDev;\n\tstruct scsi_sense_hdr sshdr;\n\tint result, err = 0, retries = 0;\n\tSDev = cd->device;\n      retry:\n\tif (!scsi_block_when_processing_errors(SDev)) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\tresult = scsi_execute(SDev, cgc->cmd, cgc->data_direction,\n\t\t\t      cgc->buffer, cgc->buflen,\n\t\t\t      (unsigned char *)cgc->sense, &sshdr,\n\t\t\t      cgc->timeout, IOCTL_RETRIES, 0, 0, NULL);\n\tif (driver_byte(result) != 0) {\n\t\tswitch (sshdr.sense_key) {\n\t\tcase UNIT_ATTENTION:\n\t\t\tSDev->changed = 1;\n\t\t\tif (!cgc->quiet)\n\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t  \"disc change detected.\\n\");\n\t\t\tif (retries++ < 10)\n\t\t\t\tgoto retry;\n\t\t\terr = -ENOMEDIUM;\n\t\t\tbreak;\n\t\tcase NOT_READY:\t\n\t\t\tif (sshdr.asc == 0x04 &&\n\t\t\t    sshdr.ascq == 0x01) {\n\t\t\t\tif (!cgc->quiet)\n\t\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t\t  \"CDROM not ready yet.\\n\");\n\t\t\t\tif (retries++ < 10) {\n\t\t\t\t\tssleep(2);\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else {\n\t\t\t\t\terr = -ENOMEDIUM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!cgc->quiet)\n\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t  \"CDROM not ready.  Make sure there \"\n\t\t\t\t\t  \"is a disc in the drive.\\n\");\n\t\t\terr = -ENOMEDIUM;\n\t\t\tbreak;\n\t\tcase ILLEGAL_REQUEST:\n\t\t\terr = -EIO;\n\t\t\tif (sshdr.asc == 0x20 &&\n\t\t\t    sshdr.ascq == 0x00)\n\t\t\t\terr = -EDRIVE_CANT_DO_THIS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EIO;\n\t\t}\n\t}\n      out:\n\tcgc->stat = err;\n\treturn err;\n}", "target": 1}
{"code": "bool ServerSecurityFeature::foxxAllowInstallFromRemote() const {\n  return _foxxAllowInstallFromRemote;\n}", "target": 0}
{"code": "void AdsIntegrationTest::initializeAds(const bool rate_limiting) {\n  config_helper_.addRuntimeOverride(\"envoy.restart_features.explicit_wildcard_resource\",\n                                    oldDssOrNewDss() == OldDssOrNewDss::Old ? \"false\" : \"true\");\n  config_helper_.addConfigModifier([this, &rate_limiting](\n                                       envoy::config::bootstrap::v3::Bootstrap& bootstrap) {\n    auto* ads_config = bootstrap.mutable_dynamic_resources()->mutable_ads_config();\n    if (rate_limiting) {\n      ads_config->mutable_rate_limit_settings();\n    }\n    auto* grpc_service = ads_config->add_grpc_services();\n    setGrpcService(*grpc_service, \"ads_cluster\", xds_upstream_->localAddress());\n    auto* ads_cluster = bootstrap.mutable_static_resources()->add_clusters();\n    ads_cluster->MergeFrom(bootstrap.static_resources().clusters()[0]);\n    ads_cluster->set_name(\"ads_cluster\");\n    envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext context;\n    auto* validation_context = context.mutable_common_tls_context()->mutable_validation_context();\n    validation_context->mutable_trusted_ca()->set_filename(\n        TestEnvironment::runfilesPath(\"test/config/integration/certs/upstreamcacert.pem\"));\n    validation_context->add_match_subject_alt_names()->set_suffix(\"lyft.com\");\n    if (clientType() == Grpc::ClientType::GoogleGrpc) {\n      auto* google_grpc = grpc_service->mutable_google_grpc();\n      auto* ssl_creds = google_grpc->mutable_channel_credentials()->mutable_ssl_credentials();\n      ssl_creds->mutable_root_certs()->set_filename(\n          TestEnvironment::runfilesPath(\"test/config/integration/certs/upstreamcacert.pem\"));\n    }\n    ads_cluster->mutable_transport_socket()->set_name(\"envoy.transport_sockets.tls\");\n    ads_cluster->mutable_transport_socket()->mutable_typed_config()->PackFrom(context);\n  });\n  HttpIntegrationTest::initialize();\n  if (xds_stream_ == nullptr) {\n    createXdsConnection();\n    AssertionResult result = xds_connection_->waitForNewStream(*dispatcher_, xds_stream_);\n    RELEASE_ASSERT(result, result.message());\n    xds_stream_->startGrpcStream();\n  }\n}", "target": 1}
{"code": "mark_desktop_file_executable_task_thread_func (GTask        *task,\n                                               gpointer      source_object,\n                                               gpointer      task_data,\n                                               GCancellable *cancellable)\n{\n    MarkTrustedJob *job = task_data;\n    CommonJob *common;\n    common = (CommonJob *) job;\n    nautilus_progress_info_start (job->common.progress);\n    mark_desktop_file_executable (common,\n                                  cancellable,\n                                  job->file,\n                                  job->interactive);\n}", "target": 0}
{"code": "void GLES2DecoderImpl::DoVertexAttrib1f(GLuint index, GLfloat v0) {\n  VertexAttribManager::VertexAttribInfo* info =\n      vertex_attrib_manager_->GetVertexAttribInfo(index);\n  if (!info) {\n    SetGLError(GL_INVALID_VALUE, \"glVertexAttrib1f: index out of range\");\n    return;\n  }\n  VertexAttribManager::VertexAttribInfo::Vec4 value;\n  value.v[0] = v0;\n  value.v[1] = 0.0f;\n  value.v[2] = 0.0f;\n  value.v[3] = 1.0f;\n  info->set_value(value);\n  glVertexAttrib1f(index, v0);\n}", "target": 0}
{"code": "static int input_default_setkeycode(struct input_dev *dev,\n\t\t\t\t    const struct input_keymap_entry *ke,\n\t\t\t\t    unsigned int *old_keycode)\n{\n\tunsigned int index;\n\tint error;\n\tint i;\n\tif (!dev->keycodesize)\n\t\treturn -EINVAL;\n\tif (ke->flags & INPUT_KEYMAP_BY_INDEX) {\n\t\tindex = ke->index;\n\t} else {\n\t\terror = input_scancode_to_scalar(ke, &index);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (index >= dev->keycodemax)\n\t\treturn -EINVAL;\n\tif (dev->keycodesize < sizeof(ke->keycode) &&\n\t\t\t(ke->keycode >> (dev->keycodesize * 8)))\n\t\treturn -EINVAL;\n\tswitch (dev->keycodesize) {\n\t\tcase 1: {\n\t\t\tu8 *k = (u8 *)dev->keycode;\n\t\t\t*old_keycode = k[index];\n\t\t\tk[index] = ke->keycode;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2: {\n\t\t\tu16 *k = (u16 *)dev->keycode;\n\t\t\t*old_keycode = k[index];\n\t\t\tk[index] = ke->keycode;\n\t\t\tbreak;\n\t\t}\n\t\tdefault: {\n\t\t\tu32 *k = (u32 *)dev->keycode;\n\t\t\t*old_keycode = k[index];\n\t\t\tk[index] = ke->keycode;\n\t\t\tbreak;\n\t\t}\n\t}\n\t__clear_bit(*old_keycode, dev->keybit);\n\t__set_bit(ke->keycode, dev->keybit);\n\tfor (i = 0; i < dev->keycodemax; i++) {\n\t\tif (input_fetch_keycode(dev, i) == *old_keycode) {\n\t\t\t__set_bit(*old_keycode, dev->keybit);\n\t\t\tbreak; \n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "cib_remote_signon(cib_t * cib, const char *name, enum cib_conn_type type)\n{\n    int rc = pcmk_ok;\n    cib_remote_opaque_t *private = cib->variant_opaque;\n    if (private->passwd == NULL) {\n        struct termios settings;\n        int rc;\n        rc = tcgetattr(0, &settings);\n        settings.c_lflag &= ~ECHO;\n        rc = tcsetattr(0, TCSANOW, &settings);\n        fprintf(stderr, \"Password: \");\n        private->passwd = calloc(1, 1024);\n        rc = scanf(\"%s\", private->passwd);\n        fprintf(stdout, \"\\n\");\n        if (rc < 1) {\n            private->passwd = NULL;\n        }\n        settings.c_lflag |= ECHO;\n        rc = tcsetattr(0, TCSANOW, &settings);\n    }\n    if (private->server == NULL || private->user == NULL) {\n        rc = -EINVAL;\n    }\n    if (rc == pcmk_ok) {\n        rc = cib_tls_signon(cib, &(private->command));\n    }\n    if (rc == pcmk_ok) {\n        rc = cib_tls_signon(cib, &(private->callback));\n    }\n    if (rc == pcmk_ok) {\n        xmlNode *hello =\n            cib_create_op(0, private->callback.token, CRM_OP_REGISTER, NULL, NULL, NULL, 0, NULL);\n        crm_xml_add(hello, F_CIB_CLIENTNAME, name);\n        crm_send_remote_msg(private->command.session, hello, private->command.encrypted);\n        free_xml(hello);\n    }\n    if (rc == pcmk_ok) {\n        fprintf(stderr, \"%s: Opened connection to %s:%d\\n\", name, private->server, private->port);\n        cib->state = cib_connected_command;\n        cib->type = cib_command;\n    } else {\n        fprintf(stderr, \"%s: Connection to %s:%d failed: %s\\n\",\n                name, private->server, private->port, pcmk_strerror(rc));\n    }\n    return rc;\n}", "target": 1}
{"code": "    bool load_face(Face & face, unsigned int options)\n    {\n#ifdef GRAPHITE2_TELEMETRY\n        telemetry::category _misc_cat(face.tele.misc);\n#endif\n        Face::Table silf(face, Tag::Silf, 0x00050000);\n        if (silf)   options &= ~gr_face_dumbRendering;\n        else if (!(options &  gr_face_dumbRendering))\n            return false;\n        if (!face.readGlyphs(options))\n            return false;\n        if (silf)\n        {\n            if (!face.readFeatures() || !face.readGraphite(silf))\n            {\n#if !defined GRAPHITE2_NTRACING\n                if (global_log)\n                {\n                    *global_log << json::object\n                        << \"type\" << \"fontload\"\n                        << \"failure\" << face.error()\n                        << \"context\" << face.error_context()\n                    << json::close;\n                }\n#endif\n                return false;\n            }\n            else\n                return true;\n        }\n        else\n            return options & gr_face_dumbRendering;\n    }", "target": 1}
{"code": "static int decode_zbuf(AVBPrint *bp, const uint8_t *data,\n                       const uint8_t *data_end)\n{\n    z_stream zstream;\n    unsigned char *buf;\n    unsigned buf_size;\n    int ret;\n    zstream.zalloc = ff_png_zalloc;\n    zstream.zfree  = ff_png_zfree;\n    zstream.opaque = NULL;\n    if (inflateInit(&zstream) != Z_OK)\n        return AVERROR_EXTERNAL;\n    zstream.next_in  = (unsigned char *)data;\n    zstream.avail_in = data_end - data;\n    av_bprint_init(bp, 0, -1);\n    while (zstream.avail_in > 0) {\n        av_bprint_get_buffer(bp, 1, &buf, &buf_size);\n        if (!buf_size) {\n            ret = AVERROR(ENOMEM);\n            goto fail;\n        }\n        zstream.next_out  = buf;\n        zstream.avail_out = buf_size;\n        ret = inflate(&zstream, Z_PARTIAL_FLUSH);\n        if (ret != Z_OK && ret != Z_STREAM_END) {\n            ret = AVERROR_EXTERNAL;\n            goto fail;\n        }\n        bp->len += zstream.next_out - buf;\n        if (ret == Z_STREAM_END)\n            break;\n    }\n    inflateEnd(&zstream);\n    bp->str[bp->len] = 0;\n    return 0;\nfail:\n    inflateEnd(&zstream);\n    av_bprint_finalize(bp, NULL);\n    return ret;\n}", "target": 1}
{"code": "static void CorrectPhaseLHS(const size_t width,const size_t height,\n  double *fourier_pixels)\n{\n  register ssize_t\n    x;\n  ssize_t\n    y;\n  for (y=0L; y < (ssize_t) height; y++)\n    for (x=0L; x < (ssize_t) (width/2L); x++)\n      fourier_pixels[y*width+x]*=(-1.0);\n}", "target": 0}
{"code": "uint32_t virtio_config_readl(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint32_t val;\n    k->get_config(vdev, vdev->config);\n    if (addr > (vdev->config_len - sizeof(val)))\n        return (uint32_t)-1;\n    val = ldl_p(vdev->config + addr);\n    return val;\n}", "target": 1}
{"code": "AP4_HdlrAtom::AP4_HdlrAtom(AP4_UI32        size, \n                           AP4_UI08        version,\n                           AP4_UI32        flags,\n                           AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_HDLR, size, version, flags)\n{\n    AP4_UI32 predefined;\n    stream.ReadUI32(predefined);\n    stream.ReadUI32(m_HandlerType);\n    stream.ReadUI32(m_Reserved[0]);\n    stream.ReadUI32(m_Reserved[1]);\n    stream.ReadUI32(m_Reserved[2]);\n    if (size < AP4_FULL_ATOM_HEADER_SIZE+20) return;\n    AP4_UI32 name_size = size-(AP4_FULL_ATOM_HEADER_SIZE+20);\n    char* name = new char[name_size+1];\n    if (name == NULL) return;\n    stream.Read(name, name_size);\n    name[name_size] = '\\0'; \n    if ((AP4_UI08)name[0] == (AP4_UI08)(name_size-1)) {\n        m_HandlerName = name+1;\n    } else {\n        m_HandlerName = name;\n    }\n    delete[] name;\n}", "target": 0}
{"code": "    TiffBinaryArray::~TiffBinaryArray()\n    {\n        for (Components::iterator i = elements_.begin(); i != elements_.end(); ++i) {\n            delete *i;\n        }\n    }", "target": 0}
{"code": "static inline void GetStandardDeviationPixelList(PixelList *pixel_list,\n  Quantum *pixel)\n{\n  double\n    sum,\n    sum_squared;\n  register SkipList\n    *p;\n  size_t\n    color;\n  ssize_t\n    count;\n  p=(&pixel_list->skip_list);\n  color=65536L;\n  count=0;\n  sum=0.0;\n  sum_squared=0.0;\n  do\n  {\n    register ssize_t\n      i;\n    color=p->nodes[color].next[0];\n    sum+=(double) p->nodes[color].count*color;\n    for (i=0; i < (ssize_t) p->nodes[color].count; i++)\n      sum_squared+=((double) color)*((double) color);\n    count+=p->nodes[color].count;\n  } while (count < (ssize_t) pixel_list->length);\n  sum/=pixel_list->length;\n  sum_squared/=pixel_list->length;\n  *pixel=ScaleShortToQuantum((unsigned short) sqrt(sum_squared-(sum*sum)));\n}", "target": 0}
{"code": "void test_unlink(const char *path)\n{\n\tif (unlink(path) == 0) {\n\t\tfprintf(stderr, \"leak at unlink of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at unlink of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "mm_malloc(struct mm_master *mm, size_t size)\n{\n\tstruct mm_share *mms, *tmp;\n\tif (size == 0)\n\t\tfatal(\"mm_malloc: try to allocate 0 space\");\n\tif (size > SIZE_MAX - MM_MINSIZE + 1)\n\t\tfatal(\"mm_malloc: size too big\");\n\tsize = ((size + (MM_MINSIZE - 1)) / MM_MINSIZE) * MM_MINSIZE;\n\tRB_FOREACH(mms, mmtree, &mm->rb_free) {\n\t\tif (mms->size >= size)\n\t\t\tbreak;\n\t}\n\tif (mms == NULL)\n\t\treturn (NULL);\n\tmemset(mms->address, 0xd0, size);\n\ttmp = mm_make_entry(mm, &mm->rb_allocated, mms->address, size);\n\tmms->size -= size;\n\tmms->address = (char *)mms->address + size;\n\tif (mms->size == 0) {\n\t\tRB_REMOVE(mmtree, &mm->rb_free, mms);\n\t\tif (mm->mmalloc == NULL)\n\t\t\tfree(mms);\n\t\telse\n\t\t\tmm_free(mm->mmalloc, mms);\n\t}\n\treturn (tmp->address);\n}", "target": 1}
{"code": "static int do_i2c_read(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t       char *const argv[])\n{\n\tuint\tchip;\n\tuint\tdevaddr, length;\n\tint alen;\n\tu_char  *memaddr;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\tif (argc != 5)\n\t\treturn CMD_RET_USAGE;\n\tchip = hextoul(argv[1], NULL);\n\tdevaddr = hextoul(argv[2], NULL);\n\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn CMD_RET_USAGE;\n\tlength = hextoul(argv[3], NULL);\n\tmemaddr = (u_char *)hextoul(argv[4], NULL);\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (!ret)\n\t\tret = dm_i2c_read(dev, devaddr, memaddr, length);\n#else\n\tret = i2c_read(chip, devaddr, alen, memaddr, length);\n#endif\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n\treturn 0;\n}", "target": 1}
{"code": "bool extract_sockaddr(char *url, char **sockaddr_url, char **sockaddr_port)\n{\n\tchar *url_begin, *url_end, *ipv6_begin, *ipv6_end, *port_start = NULL;\n\tchar url_address[256], port[6];\n\tint url_len, port_len = 0;\n\t*sockaddr_url = url;\n\turl_begin = strstr(url, \"\n\tif (!url_begin)\n\t\turl_begin = url;\n\telse\n\t\turl_begin += 2;\n\tipv6_begin = strstr(url_begin, \"[\");\n\tipv6_end = strstr(url_begin, \"]\");\n\tif (ipv6_begin && ipv6_end && ipv6_end > ipv6_begin)\n\t\turl_end = strstr(ipv6_end, \":\");\n\telse\n\t\turl_end = strstr(url_begin, \":\");\n\tif (url_end) {\n\t\turl_len = url_end - url_begin;\n\t\tport_len = strlen(url_begin) - url_len - 1;\n\t\tif (port_len < 1)\n\t\t\treturn false;\n\t\tport_start = url_end + 1;\n\t} else\n\t\turl_len = strlen(url_begin);\n\tif (url_len < 1)\n\t\treturn false;\n\tsprintf(url_address, \"%.*s\", url_len, url_begin);\n\tif (port_len) {\n\t\tchar *slash;\n\t\tsnprintf(port, 6, \"%.*s\", port_len, port_start);\n\t\tslash = strchr(port, '/');\n\t\tif (slash)\n\t\t\t*slash = '\\0';\n\t} else\n\t\tstrcpy(port, \"80\");\n\t*sockaddr_port = strdup(port);\n\t*sockaddr_url = strdup(url_address);\n\treturn true;\n}", "target": 1}
{"code": "static const struct usb_cdc_union_desc *\nims_pcu_get_cdc_union_desc(struct usb_interface *intf)\n{\n\tconst void *buf = intf->altsetting->extra;\n\tsize_t buflen = intf->altsetting->extralen;\n\tstruct usb_cdc_union_desc *union_desc;\n\tif (!buf) {\n\t\tdev_err(&intf->dev, \"Missing descriptor data\\n\");\n\t\treturn NULL;\n\t}\n\tif (!buflen) {\n\t\tdev_err(&intf->dev, \"Zero length descriptor\\n\");\n\t\treturn NULL;\n\t}\n\twhile (buflen > 0) {\n\t\tunion_desc = (struct usb_cdc_union_desc *)buf;\n\t\tif (union_desc->bDescriptorType == USB_DT_CS_INTERFACE &&\n\t\t    union_desc->bDescriptorSubType == USB_CDC_UNION_TYPE) {\n\t\t\tdev_dbg(&intf->dev, \"Found union header\\n\");\n\t\t\treturn union_desc;\n\t\t}\n\t\tbuflen -= union_desc->bLength;\n\t\tbuf += union_desc->bLength;\n\t}\n\tdev_err(&intf->dev, \"Missing CDC union descriptor\\n\");\n\treturn NULL;", "target": 1}
{"code": "void LibRaw::exp_bef(float shift, float smooth)\n{\n    if(shift>8) shift = 8;\n    if(shift<0.25) shift = 0.25;\n    if(smooth < 0.0) smooth = 0.0;\n    if(smooth > 1.0) smooth = 1.0;\n    unsigned short *lut = (ushort*)malloc((TBLN+1)*sizeof(unsigned short));\n    if(shift <=1.0)\n        {\n            for(int i=0;i<=TBLN;i++)\n                lut[i] = (unsigned short)((float)i*shift);\n        }\n    else\n        {\n            float x1,x2,y1,y2;\n            float cstops = log(shift)/log(2.0f);\n            float room = cstops*2;\n            float roomlin = powf(2.0f,room);\n            x2 = (float)TBLN;\n            x1 = (x2+1)/roomlin-1;\n            y1 = x1*shift;\n            y2 = x2*(1+(1-smooth)*(shift-1));\n            float sq3x=powf(x1*x1*x2,1.0f/3.0f);\n            float B = (y2-y1+shift*(3*x1-3.0f*sq3x)) / (x2+2.0f*x1-3.0f*sq3x);\n            float A = (shift - B)*3.0f*powf(x1*x1,1.0f/3.0f);\n            float CC = y2 - A*powf(x2,1.0f/3.0f)-B*x2;\n            for(int i=0;i<=TBLN;i++)\n                {\n                    float X = (float)i;\n                    float Y = A*powf(X,1.0f/3.0f)+B*X+CC;\n                    if(i<x1)\n                        lut[i] = (unsigned short)((float)i*shift);\n                    else\n                        lut[i] = Y<0?0:(Y>TBLN?TBLN:(unsigned short)(Y));\n                }\n        }\n    for(int i=0; i< S.height*S.width; i++)\n        {\n            imgdata.image[i][0] = lut[imgdata.image[i][0]];\n            imgdata.image[i][1] = lut[imgdata.image[i][1]];\n            imgdata.image[i][2] = lut[imgdata.image[i][2]];\n            imgdata.image[i][3] = lut[imgdata.image[i][3]];\n        }\n    C.data_maximum = lut[C.data_maximum];\n    C.maximum = lut[C.maximum];\n    free(lut);\n}", "target": 1}
{"code": "static int read_probe(const AVProbeData *p)\n{\n    int cnt = 0;\n    for (int i = 0; i < p->buf_size; i++)\n        cnt += !!isansicode(p->buf[i]);\n    return (cnt * 100LL / p->buf_size) * (cnt > 400) *\n        !!av_match_ext(p->filename, tty_extensions);\n}", "target": 0}
{"code": "jsi_wsGetHeaders(jsi_wsPss *pss, struct lws *wsi, Jsi_DString* dStr, int lens[], int hmax)\n{\n    int n = 0, i = 0, nlen;\n    char buf[1000];\n    const char *cp;\n    while ((cp = (char*)lws_token_to_string((enum lws_token_indexes)n))) {\n        int len = lws_hdr_copy(wsi, buf, sizeof(buf), ( enum lws_token_indexes)n);\n        n++;\n        if (i>=(n*2+2)) break;\n        if (len<=0) continue;\n        buf[sizeof(buf)-1] = 0;\n        if (!buf[0]) continue;\n        nlen = Jsi_Strlen(cp);\n        if (nlen>0 && cp[nlen-1]==' ') nlen--;\n        if (nlen>0 && cp[nlen-1]==':') nlen--;\n        Jsi_DSAppendLen(dStr, cp, nlen);\n        Jsi_DSAppend(dStr, \"=\", buf, \"\\n\", NULL);\n        if (lens) {\n            lens[i++] = nlen;\n            lens[i++] = Jsi_Strlen(buf);\n        }\n    }\n    return i;\n}", "target": 1}
{"code": "_public_ int sd_bus_enqueue_for_read(sd_bus *bus, sd_bus_message *m) {\n        int r;\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(m, -EINVAL);\n        assert_return(m->sealed, -EINVAL);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n        if (!BUS_IS_OPEN(bus->state))\n                return -ENOTCONN;\n        r = bus_rqueue_make_room(bus);\n        if (r < 0)\n                return r;\n        bus->rqueue[bus->rqueue_size++] = bus_message_ref_queued(m, bus);\n        return 0;\n}", "target": 0}
{"code": "int unlinkat_harder(int dfd, const char *filename, int unlink_flags, RemoveFlags remove_flags) {\n        mode_t old_mode;\n        int r;\n        if (unlinkat(dfd, filename, unlink_flags) >= 0)\n                return 0;\n        if (errno != EACCES || !FLAGS_SET(remove_flags, REMOVE_CHMOD))\n                return -errno;\n        r = patch_dirfd_mode(dfd, &old_mode);\n        if (r < 0)\n                return r;\n        if (unlinkat(dfd, filename, unlink_flags) < 0) {\n                r = -errno;\n                (void) fchmod(dfd, old_mode);\n                return r;\n        }\n        if (FLAGS_SET(remove_flags, REMOVE_CHMOD_RESTORE) && fchmod(dfd, old_mode) < 0)\n                return -errno;\n        return 0;\n}", "target": 1}
{"code": "static int cipso_v4_delopt(struct ip_options **opt_ptr)\n{\n\tint hdr_delta = 0;\n\tstruct ip_options *opt = *opt_ptr;\n\tif (opt->srr || opt->rr || opt->ts || opt->router_alert) {\n\t\tu8 cipso_len;\n\t\tu8 cipso_off;\n\t\tunsigned char *cipso_ptr;\n\t\tint iter;\n\t\tint optlen_new;\n\t\tcipso_off = opt->cipso - sizeof(struct iphdr);\n\t\tcipso_ptr = &opt->__data[cipso_off];\n\t\tcipso_len = cipso_ptr[1];\n\t\tif (opt->srr > opt->cipso)\n\t\t\topt->srr -= cipso_len;\n\t\tif (opt->rr > opt->cipso)\n\t\t\topt->rr -= cipso_len;\n\t\tif (opt->ts > opt->cipso)\n\t\t\topt->ts -= cipso_len;\n\t\tif (opt->router_alert > opt->cipso)\n\t\t\topt->router_alert -= cipso_len;\n\t\topt->cipso = 0;\n\t\tmemmove(cipso_ptr, cipso_ptr + cipso_len,\n\t\t\topt->optlen - cipso_off - cipso_len);\n\t\titer = 0;\n\t\toptlen_new = 0;\n\t\twhile (iter < opt->optlen)\n\t\t\tif (opt->__data[iter] != IPOPT_NOP) {\n\t\t\t\titer += opt->__data[iter + 1];\n\t\t\t\toptlen_new = iter;\n\t\t\t} else\n\t\t\t\titer++;\n\t\thdr_delta = opt->optlen;\n\t\topt->optlen = (optlen_new + 3) & ~3;\n\t\thdr_delta -= opt->optlen;\n\t} else {\n\t\t*opt_ptr = NULL;\n\t\thdr_delta = opt->optlen;\n\t\tkfree(opt);\n\t}\n\treturn hdr_delta;\n}", "target": 1}
{"code": "void RenderWidgetHostViewAura::SwapBuffersCompleted(\n    const BufferPresentedCallback& ack_callback,\n    const scoped_refptr<ui::Texture>& texture_to_return) {\n  ui::Compositor* compositor = GetCompositor();\n  if (!compositor) {\n    ack_callback.Run(false, texture_to_return);\n  } else {\n    AddOnCommitCallbackAndDisableLocks(\n        base::Bind(ack_callback, false, texture_to_return));\n  }\n  DidReceiveFrameFromRenderer();\n}", "target": 0}
{"code": "build_config(char *prefix, struct server *server)\n{\n    char *path    = NULL;\n    int path_size = strlen(prefix) + strlen(server->port) + 20;\n    path = ss_malloc(path_size);\n    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n    FILE *f = fopen(path, \"w+\");\n    if (f == NULL) {\n        if (verbose) {\n            LOGE(\"unable to open config file\");\n        }\n        ss_free(path);\n        return;\n    }\n    fprintf(f, \"{\\n\");\n    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n    fprintf(f, \"\\n}\\n\");\n    fclose(f);\n    ss_free(path);\n}", "target": 1}
{"code": "nfsd4_encode_getdeviceinfo(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\tstruct nfsd4_getdeviceinfo *gdev)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tconst struct nfsd4_layout_ops *ops =\n\t\tnfsd4_layout_ops[gdev->gd_layout_type];\n\tu32 starting_len = xdr->buf->len, needed_len;\n\t__be32 *p;\n\tdprintk(\"%s: err %d\\n\", __func__, be32_to_cpu(nfserr));\n\tif (nfserr)\n\t\tgoto out;\n\tnfserr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out;\n\t*p++ = cpu_to_be32(gdev->gd_layout_type);\n\tif (gdev->gd_maxcount != 0) {\n\t\tnfserr = ops->encode_getdeviceinfo(xdr, gdev);\n\t\tif (nfserr) {\n\t\t\tif (xdr->buf->len + 4 > gdev->gd_maxcount)\n\t\t\t\tgoto toosmall;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tnfserr = nfserr_resource;\n\tif (gdev->gd_notify_types) {\n\t\tp = xdr_reserve_space(xdr, 4 + 4);\n\t\tif (!p)\n\t\t\tgoto out;\n\t\t*p++ = cpu_to_be32(1);\t\t\t\n\t\t*p++ = cpu_to_be32(gdev->gd_notify_types);\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out;\n\t\t*p++ = 0;\n\t}\n\tnfserr = 0;\nout:\n\tkfree(gdev->gd_device);\n\tdprintk(\"%s: done: %d\\n\", __func__, be32_to_cpu(nfserr));\n\treturn nfserr;\ntoosmall:\n\tdprintk(\"%s: maxcount too small\\n\", __func__);\n\tneeded_len = xdr->buf->len + 4 ;\n\txdr_truncate_encode(xdr, starting_len);\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p) {\n\t\tnfserr = nfserr_resource;\n\t} else {\n\t\t*p++ = cpu_to_be32(needed_len);\n\t\tnfserr = nfserr_toosmall;\n\t}\n\tgoto out;\n}", "target": 1}
{"code": "static int ext4_fill_flex_info(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_desc *gdp = NULL;\n\text4_group_t flex_group_count;\n\text4_group_t flex_group;\n\tint groups_per_flex = 0;\n\tsize_t size;\n\tint i;\n\tsbi->s_log_groups_per_flex = sbi->s_es->s_log_groups_per_flex;\n\tgroups_per_flex = 1 << sbi->s_log_groups_per_flex;\n\tif (groups_per_flex < 2) {\n\t\tsbi->s_log_groups_per_flex = 0;\n\t\treturn 1;\n\t}\n\tflex_group_count = ((sbi->s_groups_count + groups_per_flex - 1) +\n\t\t\t((le16_to_cpu(sbi->s_es->s_reserved_gdt_blocks) + 1) <<\n\t\t\t      EXT4_DESC_PER_BLOCK_BITS(sb))) / groups_per_flex;\n\tsize = flex_group_count * sizeof(struct flex_groups);\n\tsbi->s_flex_groups = ext4_kvzalloc(size, GFP_KERNEL);\n\tif (sbi->s_flex_groups == NULL) {\n\t\text4_msg(sb, KERN_ERR, \"not enough memory for %u flex groups\",\n\t\t\t flex_group_count);\n\t\tgoto failed;\n\t}\n\tfor (i = 0; i < sbi->s_groups_count; i++) {\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tflex_group = ext4_flex_group(sbi, i);\n\t\tatomic_add(ext4_free_inodes_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].free_inodes);\n\t\tatomic_add(ext4_free_group_clusters(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].free_clusters);\n\t\tatomic_add(ext4_used_dirs_count(sb, gdp),\n\t\t\t   &sbi->s_flex_groups[flex_group].used_dirs);\n\t}\n\treturn 1;\nfailed:\n\treturn 0;\n}", "target": 1}
{"code": "static struct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,\n\t\t\t      struct btrfs_path *path,\n\t\t\t      const char *name, int name_len)\n{\n\tstruct btrfs_dir_item *dir_item;\n\tunsigned long name_ptr;\n\tu32 total_len;\n\tu32 cur = 0;\n\tu32 this_len;\n\tstruct extent_buffer *leaf;\n\tleaf = path->nodes[0];\n\tdir_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dir_item);\n\tif (verify_dir_item(root, leaf, dir_item))\n\t\treturn NULL;\n\ttotal_len = btrfs_item_size_nr(leaf, path->slots[0]);\n\twhile (cur < total_len) {\n\t\tthis_len = sizeof(*dir_item) +\n\t\t\tbtrfs_dir_name_len(leaf, dir_item) +\n\t\t\tbtrfs_dir_data_len(leaf, dir_item);\n\t\tname_ptr = (unsigned long)(dir_item + 1);\n\t\tif (btrfs_dir_name_len(leaf, dir_item) == name_len &&\n\t\t    memcmp_extent_buffer(leaf, name, name_ptr, name_len) == 0)\n\t\t\treturn dir_item;\n\t\tcur += this_len;\n\t\tdir_item = (struct btrfs_dir_item *)((char *)dir_item +\n\t\t\t\t\t\t     this_len);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "archive_read_format_zip_read_data_skip_seekable(struct archive_read *a)\n{\n\tstruct zip *zip;\n\tzip = (struct zip *)(a->format->data);\n\tzip->unconsumed = 0;\n\treturn (ARCHIVE_OK);\n}", "target": 0}
{"code": "static void set_ntacl_dacl(struct user_namespace *user_ns,\n\t\t\t   struct smb_acl *pndacl,\n\t\t\t   struct smb_acl *nt_dacl,\n\t\t\t   const struct smb_sid *pownersid,\n\t\t\t   const struct smb_sid *pgrpsid,\n\t\t\t   struct smb_fattr *fattr)\n{\n\tstruct smb_ace *ntace, *pndace;\n\tint nt_num_aces = le32_to_cpu(nt_dacl->num_aces), num_aces = 0;\n\tunsigned short size = 0;\n\tint i;\n\tpndace = (struct smb_ace *)((char *)pndacl + sizeof(struct smb_acl));\n\tif (nt_num_aces) {\n\t\tntace = (struct smb_ace *)((char *)nt_dacl + sizeof(struct smb_acl));\n\t\tfor (i = 0; i < nt_num_aces; i++) {\n\t\t\tmemcpy((char *)pndace + size, ntace, le16_to_cpu(ntace->size));\n\t\t\tsize += le16_to_cpu(ntace->size);\n\t\t\tntace = (struct smb_ace *)((char *)ntace + le16_to_cpu(ntace->size));\n\t\t\tnum_aces++;\n\t\t}\n\t}\n\tset_posix_acl_entries_dacl(user_ns, pndace, fattr,\n\t\t\t\t   &num_aces, &size, nt_num_aces);\n\tpndacl->num_aces = cpu_to_le32(num_aces);\n\tpndacl->size = cpu_to_le16(le16_to_cpu(pndacl->size) + size);\n}", "target": 1}
{"code": "static int _gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n{\n\tgdImagePtr pim = 0, tim = im;\n\tint interlace, BitsPerPixel;\n\tinterlace = im->interlace;\n\tif(im->trueColor) {\n\t\tpim = gdImageCreatePaletteFromTrueColor(im, 1, 256);\n\t\tif(!pim) {\n\t\t\treturn 1;\n\t\t}\n\t\ttim = pim;\n\t}\n\tBitsPerPixel = colorstobpp(tim->colorsTotal);\n\tGIFEncode(\n\t    out, tim->sx, tim->sy, interlace, 0, tim->transparent, BitsPerPixel,\n\t    tim->red, tim->green, tim->blue, tim);\n\tif(pim) {\n\t\tgdImageDestroy(\tpim);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int umocktypes_copy_FLOW_HANDLE(FLOW_HANDLE* destination, const FLOW_HANDLE* source)\n{\n    int result = 0;\n    *(destination) = *(source);\n    return result;\n}", "target": 0}
{"code": "delete_principal_2_svc(dprinc_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_DELETE,\n                               arg->princ, NULL)) {\n        ret.code = KADM5_AUTH_DELETE;\n        log_unauth(\"kadm5_delete_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_delete_principal((void *)handle, arg->princ);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_delete_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "static inline struct page *try_get_compound_head(struct page *page, int refs)\n{\n\tstruct page *head = compound_head(page);\n\tif (WARN_ON_ONCE(page_ref_count(head) < 0))\n\t\treturn NULL;\n\tif (unlikely(!page_cache_add_speculative(head, refs)))\n\t\treturn NULL;\n\treturn head;\n}", "target": 0}
{"code": "int smm_setup_relocation_handler(struct smm_loader_params *params)\n{\n\tvoid *smram = (void *)(SMM_DEFAULT_BASE);\n\tprintk(BIOS_SPEW, \"%s: enter\\n\", __func__);\n\tif (params->num_concurrent_save_states > 1)\n\t\treturn -1;\n\tif (params->handler == NULL)\n\t\treturn -1;\n\tif (params->num_concurrent_stacks == 0)\n\t\tparams->num_concurrent_stacks = CONFIG_MAX_CPUS;\n\tparams->smm_main_entry_offset = SMM_ENTRY_OFFSET;\n\tparams->smram_start = SMM_DEFAULT_BASE;\n\tparams->smram_end = SMM_DEFAULT_BASE + SMM_DEFAULT_SIZE;\n\treturn smm_module_setup_stub(smram, SMM_DEFAULT_SIZE,\n\t\t\t\tparams, fxsave_area_relocation);\n\tprintk(BIOS_SPEW, \"%s: exit\\n\", __func__);\n}", "target": 0}
{"code": "ins_ctrl_hat(void)\n{\n    if (map_to_exists_mode((char_u *)\"\", LANGMAP, FALSE))\n    {\n\tif (State & LANGMAP)\n\t{\n\t    curbuf->b_p_iminsert = B_IMODE_NONE;\n\t    State &= ~LANGMAP;\n\t}\n\telse\n\t{\n\t    curbuf->b_p_iminsert = B_IMODE_LMAP;\n\t    State |= LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n\t    im_set_active(FALSE);\n#endif\n\t}\n    }\n#ifdef HAVE_INPUT_METHOD\n    else\n    {\n\tif (im_get_status())\n\t{\n\t    curbuf->b_p_iminsert = B_IMODE_NONE;\n\t    im_set_active(FALSE);\n\t}\n\telse\n\t{\n\t    curbuf->b_p_iminsert = B_IMODE_IM;\n\t    State &= ~LANGMAP;\n\t    im_set_active(TRUE);\n\t}\n    }\n#endif\n    set_iminsert_global();\n    showmode();\n#ifdef FEAT_GUI\n    if (gui.in_use)\n\tgui_update_cursor(TRUE, FALSE);\n#endif\n#if defined(FEAT_KEYMAP)\n    status_redraw_curbuf();\n#endif\n}", "target": 0}
{"code": "next_line(struct archive_read *a,\n    const char **b, ssize_t *avail, ssize_t *ravail, ssize_t *nl)\n{\n\tssize_t len;\n\tint quit;\n\tquit = 0;\n\tif (*avail == 0) {\n\t\t*nl = 0;\n\t\tlen = 0;\n\t} else\n\t\tlen = get_line_size(*b, *avail, nl);\n\twhile (*nl == 0 && len == *avail && !quit) {\n\t\tssize_t diff = *ravail - *avail;\n\t\tsize_t nbytes_req = (*ravail+1023) & ~1023U;\n\t\tssize_t tested;\n\t\tif (nbytes_req < (size_t)*ravail + 160)\n\t\t\tnbytes_req <<= 1;\n\t\t*b = __archive_read_ahead(a, nbytes_req, avail);\n\t\tif (*b == NULL) {\n\t\t\tif (*ravail >= *avail)\n\t\t\t\treturn (0);\n\t\t\t*b = __archive_read_ahead(a, *avail, avail);\n\t\t\tquit = 1;\n\t\t}\n\t\t*ravail = *avail;\n\t\t*b += diff;\n\t\t*avail -= diff;\n\t\ttested = len;\n\t\tlen = get_line_size(*b, *avail, nl);\n\t\tif (len >= 0)\n\t\t\tlen += tested;\n\t}\n\treturn (len);\n}", "target": 1}
{"code": "static GF_Err swf_svg_add_iso_sample(void *user, const u8 *data, u32 length, u64 timestamp, Bool isRap)\n{\n\tGF_FilterPacket *pck;\n\tu8 *pck_data;\n\tGF_TXTIn *ctx = (GF_TXTIn *)user;\n\tif (!data || !length) return GF_BAD_PARAM;\n\tif (ctx->seek_state==2) {\n\t\tDouble ts = (Double) timestamp;\n\t\tts/=1000;\n\t\tif (ts<ctx->start_range) return GF_OK;\n\t\tctx->seek_state = 0;\n\t}\n\tpck = gf_filter_pck_new_alloc(ctx->opid, length, &pck_data);\n\tif (pck) {\n\t\tmemcpy(pck_data, data, length);\n\t\tgf_filter_pck_set_cts(pck, (u64) (ctx->timescale*timestamp/1000) );\n\t\tgf_filter_pck_set_sap(pck, isRap ? GF_FILTER_SAP_1 : GF_FILTER_SAP_NONE);\n\t\tgf_filter_pck_set_framing(pck, GF_TRUE, GF_FALSE);\n\t\tgf_filter_pck_send(pck);\n\t}\n\tif (txtin_check_blocking(ctx))\n\t\tctx->is_suspended = GF_TRUE;\n\treturn GF_OK;", "target": 0}
{"code": "char *compose_path(ctrl_t *ctrl, char *path)\n{\n\tstruct stat st;\n\tstatic char rpath[PATH_MAX];\n\tchar *name, *ptr;\n\tchar dir[PATH_MAX] = { 0 };\n\tstrlcpy(dir, ctrl->cwd, sizeof(dir));\n\tDBG(\"Compose path from cwd: %s, arg: %s\", ctrl->cwd, path ?: \"\");\n\tif (!path || !strlen(path))\n\t\tgoto check;\n\tif (path) {\n\t\tif (path[0] != '/') {\n\t\t\tif (dir[strlen(dir) - 1] != '/')\n\t\t\t\tstrlcat(dir, \"/\", sizeof(dir));\n\t\t}\n\t\tstrlcat(dir, path, sizeof(dir));\n\t}\ncheck:\n\twhile ((ptr = strstr(dir, \"\n\t\tmemmove(ptr, &ptr[1], strlen(&ptr[1]) + 1);\n\tif (!chrooted) {\n\t\tsize_t len = strlen(home);\n\t\tDBG(\"Server path from CWD: %s\", dir);\n\t\tif (len > 0 && home[len - 1] == '/')\n\t\t\tlen--;\n\t\tmemmove(dir + len, dir, strlen(dir) + 1);\n\t\tmemcpy(dir, home, len);\n\t\tDBG(\"Resulting non-chroot path: %s\", dir);\n\t}\n\tif (!stat(dir, &st) && S_ISDIR(st.st_mode)) {\n\t\tif (!realpath(dir, rpath))\n\t\t\treturn NULL;\n\t} else {\n\t\tname = basename(path);\n\t\tptr = dirname(dir);\n\t\tmemset(rpath, 0, sizeof(rpath));\n\t\tif (!realpath(ptr, rpath)) {\n\t\t\tINFO(\"Failed realpath(%s): %m\", ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (rpath[1] != 0)\n\t\t\tstrlcat(rpath, \"/\", sizeof(rpath));\n\t\tstrlcat(rpath, name, sizeof(rpath));\n\t}\n\tif (!chrooted && strncmp(dir, home, strlen(home))) {\n\t\tDBG(\"Failed non-chroot dir:%s vs home:%s\", dir, home);\n\t\treturn NULL;\n\t}\n\treturn rpath;\n}", "target": 1}
{"code": "static int32_t check_load_area(uintptr_t dst, uintptr_t len)\n{\n\tuint32_t legacy = dst + len <= UINT32_MAX - 1 ? 1 : 0;\n\tuintptr_t dram_start, dram_end;\n\tuintptr_t prot_start, prot_end;\n\tint32_t result = IO_SUCCESS;\n\tdram_start = legacy ? DRAM1_BASE : DRAM_40BIT_BASE;\n\tdram_end = legacy ? DRAM1_BASE + DRAM1_SIZE :\n\t    DRAM_40BIT_BASE + DRAM_40BIT_SIZE;\n\tprot_start = legacy ? DRAM_PROTECTED_BASE : DRAM_40BIT_PROTECTED_BASE;\n\tprot_end = prot_start + DRAM_PROTECTED_SIZE;\n\tif (dst < dram_start || dst > dram_end - len) {\n\t\tERROR(\"BL2: dst address is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t\tgoto done;\n\t}\n\tif (dst >= prot_start && dst < prot_end) {\n\t\tERROR(\"BL2: dst address is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t}\n\tif (dst < prot_start && dst > prot_start - len) {\n\t\tERROR(\"BL2: loaded data is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t}\ndone:\n\tif (result == IO_FAIL) {\n\t\tERROR(\"BL2: Out of range : dst=0x%lx len=0x%lx\\n\", dst, len);\n\t}\n\treturn result;\n}", "target": 1}
{"code": "static void kvm_vcpu_ioctl_x86_get_xcrs(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_xcrs *guest_xcrs)\n{\n\tif (!cpu_has_xsave) {\n\t\tguest_xcrs->nr_xcrs = 0;\n\t\treturn;\n\t}\n\tguest_xcrs->nr_xcrs = 1;\n\tguest_xcrs->flags = 0;\n\tguest_xcrs->xcrs[0].xcr = XCR_XFEATURE_ENABLED_MASK;\n\tguest_xcrs->xcrs[0].value = vcpu->arch.xcr0;\n}", "target": 0}
{"code": "static void vector64_dst_append(RStrBuf *sb, csh *handle, cs_insn *insn, int n, int i) {\n\tcs_arm64_op op = INSOP64 (n);\n\tif (op.vector_index != -1) {\n\t\ti = op.vector_index;\n\t}\n#if CS_API_MAJOR == 4\n\tconst bool isvessas = (op.vess || op.vas);\n#else\n\tconst bool isvessas = op.vas;\n#endif\n\tif (isvessas && i != -1) {\n\t\tint size = vector_size (&op);\n\t\tint shift = i * size;\n\t\tchar *regc = \"l\";\n\t\tsize_t s = sizeof (bitmask_by_width) / sizeof (*bitmask_by_width);\n\t\tsize_t index = size > 0? (size - 1) % s: 0;\n\t\tif (index >= BITMASK_BY_WIDTH_COUNT) {\n\t\t\tindex = 0;\n\t\t}\n\t\tut64 mask = bitmask_by_width[index];\n\t\tif (shift >= 64) {\n\t\t\tshift -= 64;\n\t\t\tregc = \"h\";\n\t\t}\n\t\tif (shift > 0 && shift < 64) {\n\t\t\tr_strbuf_appendf (sb, \"%d,SWAP,0x%\"PFMT64x\",&,<<,%s%s,0x%\"PFMT64x\",&,|,%s%s\",\n\t\t\t\tshift, mask, REG64 (n), regc, VEC64_MASK (shift, size), REG64 (n), regc);\n\t\t} else {\n\t\t\tint dimsize = size % 64;\n\t\t\tr_strbuf_appendf (sb, \"0x%\"PFMT64x\",&,%s%s,0x%\"PFMT64x\",&,|,%s%s\",\n\t\t\t\tmask, REG64 (n), regc, VEC64_MASK (shift, dimsize), REG64 (n), regc);\n\t\t}\n\t} else {\n\t\tr_strbuf_appendf (sb, \"%s\", REG64 (n));\n\t}\n}", "target": 1}
{"code": "cifs_find_smb_ses(struct TCP_Server_Info *server, char *username)\n{\n\tstruct list_head *tmp;\n\tstruct cifsSesInfo *ses;\n\twrite_lock(&cifs_tcp_ses_lock);\n\tlist_for_each(tmp, &server->smb_ses_list) {\n\t\tses = list_entry(tmp, struct cifsSesInfo, smb_ses_list);\n\t\tif (strncmp(ses->userName, username, MAX_USERNAME_SIZE))\n\t\t\tcontinue;\n\t\t++ses->ses_count;\n\t\twrite_unlock(&cifs_tcp_ses_lock);\n\t\treturn ses;\n\t}\n\twrite_unlock(&cifs_tcp_ses_lock);\n\treturn NULL;\n}", "target": 1}
{"code": "no_peephole(codegen_scope *s)\n{\n  return no_optimize(s) || s->lastlabel == s->pc || s->pc == 0 || s->pc == s->lastpc;\n}", "target": 0}
{"code": "double JOIN_TAB::scan_time()\n{\n  double res;\n  if (table->is_created())\n  {\n    if (table->is_filled_at_execution())\n    {\n      get_delayed_table_estimates(table, &records, &read_time,\n                                    &startup_cost);\n      found_records= records;\n      table->quick_condition_rows= records;\n    }\n    else\n    {\n      found_records= records= table->stat_records();\n      read_time= table->file->scan_time();\n    }\n    res= read_time;\n  }\n  else\n  {\n    found_records= records=table->stat_records();\n    read_time= found_records ? (double)found_records: 10.0;\n    res= read_time;\n  }\n  return res;\n}", "target": 0}
{"code": "void TakeScreenshot(const char *fileName)\n{\n#if defined(SUPPORT_MODULE_RTEXTURES)\n    if (strchr(fileName, '\\'') != NULL) { TRACELOG(LOG_WARNING, \"SYSTEM: Provided fileName could be potentially malicious, avoid [\\'] character\");  return; }\n    Vector2 scale = GetWindowScaleDPI();\n    unsigned char *imgData = rlReadScreenPixels((int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y));\n    Image image = { imgData, (int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y), 1, PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 };\n    char path[2048] = { 0 };\n    strcpy(path, TextFormat(\"%s/%s\", CORE.Storage.basePath, fileName));\n    ExportImage(image, path);           \n    RL_FREE(imgData);\n#if defined(PLATFORM_WEB)\n    emscripten_run_script(TextFormat(\"saveFileFromMEMFSToDisk('%s','%s')\", GetFileName(path), GetFileName(path)));\n#endif\n    TRACELOG(LOG_INFO, \"SYSTEM: [%s] Screenshot taken successfully\", path);\n#else\n    TRACELOG(LOG_WARNING,\"IMAGE: ExportImage() requires module: rtextures\");\n#endif\n}", "target": 0}
{"code": " bool RenderFrameHostImpl::OnMessageReceived(const IPC::Message &msg) {\n  if (render_view_host_->IsSwappedOut()) {\n    if (!SwappedOutMessages::CanHandleWhileSwappedOut(msg)) {\n      if (msg.is_sync()) {\n        IPC::Message* reply = IPC::SyncMessage::GenerateReply(&msg);\n        reply->set_reply_error();\n        Send(reply);\n      }\n      return true;\n    }\n  }\n   if (delegate_->OnMessageReceived(this, msg))\n     return true;\n  if (cross_process_frame_connector_ &&\n      cross_process_frame_connector_->OnMessageReceived(msg))\n    return true;\n  bool handled = true;\n  bool msg_is_ok = true;\n  IPC_BEGIN_MESSAGE_MAP_EX(RenderFrameHostImpl, msg, msg_is_ok)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_Detach, OnDetach)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_FrameFocused, OnFrameFocused)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidStartProvisionalLoadForFrame,\n                        OnDidStartProvisionalLoadForFrame)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidFailProvisionalLoadWithError,\n                        OnDidFailProvisionalLoadWithError)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidRedirectProvisionalLoad,\n                        OnDidRedirectProvisionalLoad)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidFailLoadWithError,\n                        OnDidFailLoadWithError)\n    IPC_MESSAGE_HANDLER_GENERIC(FrameHostMsg_DidCommitProvisionalLoad,\n                                OnNavigate(msg))\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidStartLoading, OnDidStartLoading)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidStopLoading, OnDidStopLoading)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_OpenURL, OnOpenURL)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_BeforeUnload_ACK, OnBeforeUnloadACK)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_SwapOut_ACK, OnSwapOutACK)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_ContextMenu, OnContextMenu)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_JavaScriptExecuteResponse,\n                        OnJavaScriptExecuteResponse)\n  IPC_END_MESSAGE_MAP_EX()\n  if (!msg_is_ok) {\n    RecordAction(base::UserMetricsAction(\"BadMessageTerminate_RFH\"));\n    GetProcess()->ReceivedBadMessage();\n  }\n  return handled;\n}", "target": 0}
{"code": "static int pfkey_add(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct xfrm_state *x;\n\tint err;\n\tstruct km_event c;\n\tx = pfkey_msg2xfrm_state(net, hdr, ext_hdrs);\n\tif (IS_ERR(x))\n\t\treturn PTR_ERR(x);\n\txfrm_state_hold(x);\n\tif (hdr->sadb_msg_type == SADB_ADD)\n\t\terr = xfrm_state_add(x);\n\telse\n\t\terr = xfrm_state_update(x);\n\txfrm_audit_state_add(x, err ? 0 : 1, true);\n\tif (err < 0) {\n\t\tx->km.state = XFRM_STATE_DEAD;\n\t\t__xfrm_state_put(x);\n\t\tgoto out;\n\t}\n\tif (hdr->sadb_msg_type == SADB_ADD)\n\t\tc.event = XFRM_MSG_NEWSA;\n\telse\n\t\tc.event = XFRM_MSG_UPDSA;\n\tc.seq = hdr->sadb_msg_seq;\n\tc.portid = hdr->sadb_msg_pid;\n\tkm_state_notify(x, &c);\nout:\n\txfrm_state_put(x);\n\treturn err;\n}", "target": 0}
{"code": "sds *ldbReplParseCommand(int *argcp) {\n    sds *argv = NULL;\n    int argc = 0;\n    if (sdslen(ldb.cbuf) == 0) return NULL;\n    sds copy = sdsdup(ldb.cbuf);\n    char *p = copy;\n    p = strchr(p,'*'); if (!p) goto protoerr;\n    char *plen = p+1; \n    p = strstr(p,\"\\r\\n\"); if (!p) goto protoerr;\n    *p = '\\0'; p += 2;\n    *argcp = atoi(plen);\n    if (*argcp <= 0 || *argcp > 1024) goto protoerr;\n    argv = zmalloc(sizeof(sds)*(*argcp));\n    argc = 0;\n    while(argc < *argcp) {\n        if (*p != '$') goto protoerr;\n        plen = p+1; \n        p = strstr(p,\"\\r\\n\"); if (!p) goto protoerr;\n        *p = '\\0'; p += 2;\n        int slen = atoi(plen); \n        if (slen <= 0 || slen > 1024) goto protoerr;\n        argv[argc++] = sdsnewlen(p,slen);\n        p += slen; \n        if (p[0] != '\\r' || p[1] != '\\n') goto protoerr;\n        p += 2; \n    }\n    sdsfree(copy);\n    return argv;\nprotoerr:\n    sdsfreesplitres(argv,argc);\n    sdsfree(copy);\n    return NULL;\n}", "target": 1}
{"code": "activate_desktop_file (ActivateParameters *parameters,\n                       NautilusFile       *file)\n{\n    ActivateParametersDesktop *parameters_desktop;\n    char *primary, *secondary, *display_name;\n    GtkWidget *dialog;\n    GdkScreen *screen;\n    char *uri;\n    screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\n    if (!nautilus_file_is_trusted_link (file))\n    {\n        parameters_desktop = g_new0 (ActivateParametersDesktop, 1);\n        if (parameters->parent_window)\n        {\n            parameters_desktop->parent_window = parameters->parent_window;\n            g_object_add_weak_pointer (G_OBJECT (parameters_desktop->parent_window), (gpointer *) &parameters_desktop->parent_window);\n        }\n        parameters_desktop->file = nautilus_file_ref (file);\n        primary = _(\"Untrusted application launcher\");\n        display_name = nautilus_file_get_display_name (file);\n        secondary =\n            g_strdup_printf (_(\"The application launcher %s has not been marked as trusted. \"\n                               \"If you do not know the source of this file, launching it may be unsafe.\"\n                               ),\n                             display_name);\n        dialog = gtk_message_dialog_new (parameters->parent_window,\n                                         0,\n                                         GTK_MESSAGE_WARNING,\n                                         GTK_BUTTONS_NONE,\n                                         NULL);\n        g_object_set (dialog,\n                      \"text\", primary,\n                      \"secondary-text\", secondary,\n                      NULL);\n        gtk_dialog_add_button (GTK_DIALOG (dialog),\n                               _(\"_Launch Anyway\"), RESPONSE_RUN);\n        if (nautilus_file_can_set_permissions (file))\n        {\n            gtk_dialog_add_button (GTK_DIALOG (dialog),\n                                   _(\"Mark as _Trusted\"), RESPONSE_MARK_TRUSTED);\n        }\n        gtk_dialog_add_button (GTK_DIALOG (dialog),\n                               _(\"_Cancel\"), GTK_RESPONSE_CANCEL);\n        gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_CANCEL);\n        g_signal_connect (dialog, \"response\",\n                          G_CALLBACK (untrusted_launcher_response_callback),\n                          parameters_desktop);\n        gtk_widget_show (dialog);\n        g_free (display_name);\n        g_free (secondary);\n        return;\n    }\n    uri = nautilus_file_get_uri (file);\n    DEBUG (\"Launching trusted launcher %s\", uri);\n    nautilus_launch_desktop_file (screen, uri, NULL,\n                                  parameters->parent_window);\n    g_free (uri);\n}", "target": 1}
{"code": "static RList *r_bin_wasm_get_data_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\tRList *ret = NULL;\n\tRBinWasmDataEntry *ptr = NULL;\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 count = sec->count;\n\tut32 i = 0, r = 0;\n\tsize_t n = 0;\n\twhile (i < len && r < count) {\n\t\tif (!(ptr = R_NEW0 (RBinWasmDataEntry))) {\n\t\t\treturn ret;\n\t\t}\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\t\tif (!(n = consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\t\tptr->offset.len = n;\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->size, &i))) {\t\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\t\tptr->data = sec->payload_data + i;\n\t\tr_list_append (ret, ptr);\n\t\tr += 1;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static long vbg_misc_device_ioctl(struct file *filp, unsigned int req,\n\t\t\t\t  unsigned long arg)\n{\n\tstruct vbg_session *session = filp->private_data;\n\tsize_t returned_size, size;\n\tstruct vbg_ioctl_hdr hdr;\n\tbool is_vmmdev_req;\n\tint ret = 0;\n\tvoid *buf;\n\tif (copy_from_user(&hdr, (void *)arg, sizeof(hdr)))\n\t\treturn -EFAULT;\n\tif (hdr.version != VBG_IOCTL_HDR_VERSION)\n\t\treturn -EINVAL;\n\tif (hdr.size_in < sizeof(hdr) ||\n\t    (hdr.size_out && hdr.size_out < sizeof(hdr)))\n\t\treturn -EINVAL;\n\tsize = max(hdr.size_in, hdr.size_out);\n\tif (_IOC_SIZE(req) && _IOC_SIZE(req) != size)\n\t\treturn -EINVAL;\n\tif (size > SZ_16M)\n\t\treturn -E2BIG;\n\tis_vmmdev_req = (req & ~IOCSIZE_MASK) == VBG_IOCTL_VMMDEV_REQUEST(0) ||\n\t\t\t req == VBG_IOCTL_VMMDEV_REQUEST_BIG;\n\tif (is_vmmdev_req)\n\t\tbuf = vbg_req_alloc(size, VBG_IOCTL_HDR_TYPE_DEFAULT);\n\telse\n\t\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(buf, (void *)arg, hdr.size_in)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\tif (hdr.size_in < size)\n\t\tmemset(buf + hdr.size_in, 0, size -  hdr.size_in);\n\tret = vbg_core_ioctl(session, req, buf);\n\tif (ret)\n\t\tgoto out;\n\treturned_size = ((struct vbg_ioctl_hdr *)buf)->size_out;\n\tif (returned_size > size) {\n\t\tvbg_debug(\"%s: too much output data %zu > %zu\\n\",\n\t\t\t  __func__, returned_size, size);\n\t\treturned_size = size;\n\t}\n\tif (copy_to_user((void *)arg, buf, returned_size) != 0)\n\t\tret = -EFAULT;\nout:\n\tif (is_vmmdev_req)\n\t\tvbg_req_free(buf, size);\n\telse\n\t\tkfree(buf);\n\treturn ret;\n}", "target": 1}
{"code": "mm_create(struct mm_master *mmalloc, size_t size)\n{\n\tvoid *address;\n\tstruct mm_master *mm;\n\tif (mmalloc == NULL)\n\t\tmm = xcalloc(1, sizeof(struct mm_master));\n\telse\n\t\tmm = mm_xmalloc(mmalloc, sizeof(struct mm_master));\n\tmm->mmalloc = mmalloc;\n\taddress = mmap(NULL, size, PROT_WRITE|PROT_READ, MAP_ANON|MAP_SHARED,\n\t    -1, 0);\n\tif (address == MAP_FAILED)\n\t\tfatal(\"mmap(%zu): %s\", size, strerror(errno));\n\tmm->address = address;\n\tmm->size = size;\n\tRB_INIT(&mm->rb_free);\n\tRB_INIT(&mm->rb_allocated);\n\tmm_make_entry(mm, &mm->rb_free, address, size);\n\treturn (mm);\n}", "target": 1}
{"code": "int removeifnotchanged(const file_t *file, char **errorstring)\n{\n  int result;\n  struct stat st;\n  static char *filechanged = \"File contents changed during processing\";\n  static char *unknownerror = \"Unknown error\";\n  stat(file->d_name, &st);\n  if (file->device != st.st_dev ||\n      file->inode != st.st_ino ||\n      file->ctime != st.st_ctime ||\n      file->mtime != st.st_mtime ||\n      file->size != st.st_size)\n  {\n    if (errorstring != 0)\n        *errorstring = filechanged;\n    return -2;\n  }\n  else\n  {\n    result = remove(file->d_name);\n    if (result != 0 && errorstring != 0)\n    {\n      *errorstring = strerror(errno);\n      if (*errorstring == 0)\n        *errorstring = unknownerror;\n    }\n    return result;\n  }\n}", "target": 0}
{"code": "bool req_is_in_chain(struct smb_request *req)\n{\n\tif (req->vwv != (uint16_t *)(req->inbuf+smb_vwv)) {\n\t\treturn true;\n\t}\n\tif (!is_andx_req(req->cmd)) {\n\t\treturn false;\n\t}\n\tif (req->wct < 2) {\n\t\treturn false;\n\t}\n\treturn (CVAL(req->vwv+0, 0) != 0xFF);\n}", "target": 0}
{"code": "struct mosquitto *context__init(mosq_sock_t sock)\n{\n\tstruct mosquitto *context;\n\tchar address[1024];\n\tcontext = mosquitto__calloc(1, sizeof(struct mosquitto));\n\tif(!context) return NULL;\n#ifdef WITH_EPOLL\n\tcontext->ident = id_client;\n#else\n\tcontext->pollfd_index = -1;\n#endif\n\tmosquitto__set_state(context, mosq_cs_new);\n\tcontext->sock = sock;\n\tcontext->last_msg_in = db.now_s;\n\tcontext->next_msg_out = db.now_s + 60;\n\tcontext->keepalive = 60; \n\tcontext->clean_start = true;\n\tcontext->id = NULL;\n\tcontext->last_mid = 0;\n\tcontext->will = NULL;\n\tcontext->username = NULL;\n\tcontext->password = NULL;\n\tcontext->listener = NULL;\n\tcontext->acl_list = NULL;\n\tcontext->retain_available = true;\n\tcontext->is_bridge = false;\n\tcontext->in_packet.payload = NULL;\n\tpacket__cleanup(&context->in_packet);\n\tcontext->out_packet = NULL;\n\tcontext->current_out_packet = NULL;\n\tcontext->out_packet_count = 0;\n\tcontext->address = NULL;\n\tif((int)sock >= 0){\n\t\tif(!net__socket_get_address(sock, address, 1024, &context->remote_port)){\n\t\t\tcontext->address = mosquitto__strdup(address);\n\t\t}\n\t\tif(!context->address){\n\t\t\tmosquitto__free(context);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tcontext->bridge = NULL;\n\tcontext->msgs_in.inflight_maximum = db.config->max_inflight_messages;\n\tcontext->msgs_out.inflight_maximum = db.config->max_inflight_messages;\n\tcontext->msgs_in.inflight_quota = db.config->max_inflight_messages;\n\tcontext->msgs_out.inflight_quota = db.config->max_inflight_messages;\n\tcontext->max_qos = 2;\n#ifdef WITH_TLS\n\tcontext->ssl = NULL;\n#endif\n\tif((int)context->sock >= 0){\n\t\tHASH_ADD(hh_sock, db.contexts_by_sock, sock, sizeof(context->sock), context);\n\t}\n\treturn context;\n}", "target": 1}
{"code": "error(int n, ...)\n{\nint ec;\nmacroexe *me;\nistackstr *fe;\nva_list ap;\nva_start(ap, n);\nif (n > error_maxerror)\n  {\n  (void)fprintf(stderr, \"** Unknown error number %d\\n\", n);\n  ec = ec_disaster;\n  }\nelse\n  {\n  ec = error_data[n].ec;\n  if (ec == ec_warning)\n    {\n    if (suppress_warnings) return;\n    (void)fprintf(stderr, \"** Warning: \");\n    }\n  else if (ec > ec_warning)\n    (void)fprintf(stderr, \"** Error: \");\n  (void)vfprintf(stderr, error_data[n].text, ap);\n  (void)fprintf(stderr, \"\\n\");\n  }\nva_end(ap);\nme = macrocurrent;\nfe = istack;\nif (from_type_ptr < 0) (void)fprintf(stderr, \"   Detected near end of file\\n\");\nelse for (int i = from_type_ptr; i >= 0; i--)\n  {\n  if (from_type[i] == FROM_MACRO)\n    {\n    const char *eof = (i == 0)? \" at end of input\" : \"\";\n    (void)fprintf(stderr, \"   Processing macro %s%s\\n\", me->macro->name, eof);\n    me = me->prev;\n    }\n  else\n    {\n    if (fe != NULL)\n      {\n      if (fe->linenumber > 0) \n        (void)fprintf(stderr, \"   Detected near line %d of %s\\n\",\n          fe->linenumber, fe->filename);\n      fe = fe->prev;\n      }\n    else\n      {\n      (void)fprintf(stderr, \"   Detected near end of file\\n\"); \n      }\n    }\n  }\nif (ec == ec_warning)\n  {\n  warning_count++;\n  if (warning_count > 40)\n    {\n    (void)fprintf(stderr, \"** Too many warnings - subsequent ones suppressed\\n\");\n    suppress_warnings = TRUE;\n    }\n  }\nelse if (ec > ec_warning)\n  {\n  return_code = EXIT_FAILURE;\n  error_count++;\n  if (error_count > 40)\n    {\n    (void)fprintf(stderr, \"** Too many errors\\n\");\n    ec = ec_failed;\n    }\n  }\nif (ec >= ec_failed)\n  {\n  (void)fprintf(stderr, \"** xfpt abandoned\\n\");\n  suppress_warnings = TRUE;  \n  exit(EXIT_FAILURE);\n  }\n(void)fprintf(stderr, \"\\n\");   \n}", "target": 1}
{"code": "static void ip6_append_data_mtu(int *mtu,\n\t\t\t\tint *maxfraglen,\n\t\t\t\tunsigned int fragheaderlen,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tstruct rt6_info *rt)\n{\n\tif (!(rt->dst.flags & DST_XFRM_TUNNEL)) {\n\t\tif (skb == NULL) {\n\t\t\t*mtu = *mtu - rt->dst.header_len;\n\t\t} else {\n\t\t\t*mtu = dst_mtu(rt->dst.path);\n\t\t}\n\t\t*maxfraglen = ((*mtu - fragheaderlen) & ~7)\n\t\t\t      + fragheaderlen - sizeof(struct frag_hdr);\n\t}\n}", "target": 1}
{"code": "int WebContentsImpl::GetEmbeddedInstanceID() const {\n  BrowserPluginGuest* guest = GetBrowserPluginGuest();\n  if (guest)\n    return guest->instance_id();\n  return 0;\n}", "target": 0}
{"code": "convert_to_decimal (mpn_t a, size_t extra_zeroes)\n{\n  mp_limb_t *a_ptr = a.limbs;\n  size_t a_len = a.nlimbs;\n  size_t c_len = 9 * ((size_t)(a_len * (GMP_LIMB_BITS * 0.03345f)) + 1);\n  char *c_ptr = (char *) malloc (xsum (c_len, extra_zeroes));\n  if (c_ptr != NULL)\n    {\n      char *d_ptr = c_ptr;\n      for (; extra_zeroes > 0; extra_zeroes--)\n        *d_ptr++ = '0';\n      while (a_len > 0)\n        {\n          mp_limb_t remainder = 0;\n          mp_limb_t *ptr = a_ptr + a_len;\n          size_t count;\n          for (count = a_len; count > 0; count--)\n            {\n              mp_twolimb_t num =\n                ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--ptr;\n              *ptr = num / 1000000000;\n              remainder = num % 1000000000;\n            }\n          for (count = 9; count > 0; count--)\n            {\n              *d_ptr++ = '0' + (remainder % 10);\n              remainder = remainder / 10;\n            }\n          if (a_ptr[a_len - 1] == 0)\n            a_len--;\n        }\n      while (d_ptr > c_ptr && d_ptr[-1] == '0')\n        d_ptr--;\n      if (d_ptr == c_ptr)\n        *d_ptr++ = '0';\n      *d_ptr = '\\0';\n    }\n  return c_ptr;\n}", "target": 1}
{"code": "static int stellaris_enet_load(QEMUFile *f, void *opaque, int version_id)\n{\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n    int i;\n    if (version_id != 1)\n        return -EINVAL;\n    s->ris = qemu_get_be32(f);\n    s->im = qemu_get_be32(f);\n    s->rctl = qemu_get_be32(f);\n    s->tctl = qemu_get_be32(f);\n    s->thr = qemu_get_be32(f);\n    s->mctl = qemu_get_be32(f);\n    s->mdv = qemu_get_be32(f);\n    s->mtxd = qemu_get_be32(f);\n    s->mrxd = qemu_get_be32(f);\n    s->np = qemu_get_be32(f);\n    s->tx_fifo_len = qemu_get_be32(f);\n    qemu_get_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));\n    for (i = 0; i < 31; i++) {\n        s->rx[i].len = qemu_get_be32(f);\n        qemu_get_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));\n    }\n    s->next_packet = qemu_get_be32(f);\n    s->rx_fifo_offset = qemu_get_be32(f);\n    return 0;\n}", "target": 1}
{"code": "http_dissect_hdrs(struct worker *w, struct http *hp, int fd, char *p,\n    const struct http_conn *htc)\n{\n\tchar *q, *r;\n\ttxt t = htc->rxbuf;\n\tif (*p == '\\r')\n\t\tp++;\n\thp->nhd = HTTP_HDR_FIRST;\n\thp->conds = 0;\n\tr = NULL;\t\t\n\tfor (; p < t.e; p = r) {\n\t\tq = r = p;\n\t\twhile (r < t.e) {\n\t\t\tif (!vct_iscrlf(*r)) {\n\t\t\t\tr++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tq = r;\n\t\t\tassert(r < t.e);\n\t\t\tr += vct_skipcrlf(r);\n\t\t\tif (r >= t.e)\n\t\t\t\tbreak;\n\t\t\tif (!vct_issp(*r))\n\t\t\t\tbreak;\n\t\t\twhile (vct_islws(*q))\n\t\t\t\t*q++ = ' ';\n\t\t}\n\t\tif (q - p > htc->maxhdr) {\n\t\t\tVSC_C_main->losthdr++;\n\t\t\tWSL(w, SLT_LostHeader, fd, \"%.*s\",\n\t\t\t    q - p > 20 ? 20 : q - p, p);\n\t\t\treturn (413);\n\t\t}\n\t\tif (p == q)\n\t\t\tbreak;\n\t\tif ((p[0] == 'i' || p[0] == 'I') &&\n\t\t    (p[1] == 'f' || p[1] == 'F') &&\n\t\t    p[2] == '-')\n\t\t\thp->conds = 1;\n\t\twhile (q > p && vct_issp(q[-1]))\n\t\t\tq--;\n\t\t*q = '\\0';\n\t\tif (hp->nhd < hp->shd) {\n\t\t\thp->hdf[hp->nhd] = 0;\n\t\t\thp->hd[hp->nhd].b = p;\n\t\t\thp->hd[hp->nhd].e = q;\n\t\t\tWSLH(w, fd, hp, hp->nhd);\n\t\t\thp->nhd++;\n\t\t} else {\n\t\t\tVSC_C_main->losthdr++;\n\t\t\tWSL(w, SLT_LostHeader, fd, \"%.*s\",\n\t\t\t    q - p > 20 ? 20 : q - p, p);\n\t\t\treturn (413);\n\t\t}\n\t}\n\treturn (0);\n}", "target": 1}
{"code": "static void bond_setup(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\trwlock_init(&bond->lock);\n\trwlock_init(&bond->curr_slave_lock);\n\tbond->params = bonding_defaults;\n\tbond->dev = bond_dev;\n\tINIT_LIST_HEAD(&bond->vlan_list);\n\tether_setup(bond_dev);\n\tbond_dev->netdev_ops = &bond_netdev_ops;\n\tbond_dev->ethtool_ops = &bond_ethtool_ops;\n\tbond_set_mode_ops(bond, bond->params.mode);\n\tbond_dev->destructor = bond_destructor;\n\tbond_dev->tx_queue_len = 0;\n\tbond_dev->flags |= IFF_MASTER|IFF_MULTICAST;\n\tbond_dev->priv_flags |= IFF_BONDING;\n\tbond_dev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n\tbond_dev->features |= NETIF_F_VLAN_CHALLENGED;\n\tbond_dev->features |= NETIF_F_LLTX;\n\tbond_dev->hw_features = BOND_VLAN_FEATURES |\n\t\t\t\tNETIF_F_HW_VLAN_TX |\n\t\t\t\tNETIF_F_HW_VLAN_RX |\n\t\t\t\tNETIF_F_HW_VLAN_FILTER;\n\tbond_dev->hw_features &= ~(NETIF_F_ALL_CSUM & ~NETIF_F_NO_CSUM);\n\tbond_dev->features |= bond_dev->hw_features;\n}", "target": 1}
{"code": "selaComputeCompositeParameters(const char  *fileout)\n{\nchar    *str, *nameh1, *nameh2, *namev1, *namev2;\nchar     buf[L_BUF_SIZE];\nl_int32  size, size1, size2, len;\nSARRAY  *sa;\nSELA    *selabasic, *selacomb;\n    selabasic = selaAddBasic(NULL);\n    selacomb = selaAddDwaCombs(NULL);\n    sa = sarrayCreate(64);\n    for (size = 2; size < 64; size++) {\n        selectComposableSizes(size, &size1, &size2);\n        nameh1 = selaGetBrickName(selabasic, size1, 1);\n        namev1 = selaGetBrickName(selabasic, 1, size1);\n        if (size2 > 1) {\n            nameh2 = selaGetCombName(selacomb, size1 * size2, L_HORIZ);\n            namev2 = selaGetCombName(selacomb, size1 * size2, L_VERT);\n        } else {\n            nameh2 = stringNew(\"\");\n            namev2 = stringNew(\"\");\n        }\n        snprintf(buf, L_BUF_SIZE,\n                 \"      { %d, %d, %d, \\\"%s\\\", \\\"%s\\\", \\\"%s\\\", \\\"%s\\\" },\",\n                 size, size1, size2, nameh1, nameh2, namev1, namev2);\n        sarrayAddString(sa, buf, L_COPY);\n        LEPT_FREE(nameh1);\n        LEPT_FREE(nameh2);\n        LEPT_FREE(namev1);\n        LEPT_FREE(namev2);\n    }\n    str = sarrayToString(sa, 1);\n    len = strlen(str);\n    l_binaryWrite(fileout, \"w\", str, len + 1);\n    LEPT_FREE(str);\n    sarrayDestroy(&sa);\n    selaDestroy(&selabasic);\n    selaDestroy(&selacomb);\n    return;\n}", "target": 1}
{"code": "void test_chdir(const char *path)\n{\n\tif (chdir(path) == 0) {\n\t\tfprintf(stderr, \"leak at chdir to %s\\n\", path);\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "bool PrintMsg_Print_Params_IsEqual(\n    const PrintMsg_PrintPages_Params& oldParams,\n    const PrintMsg_PrintPages_Params& newParams) {\n  return PageLayoutIsEqual(oldParams, newParams) &&\n         oldParams.params.max_shrink == newParams.params.max_shrink &&\n         oldParams.params.min_shrink == newParams.params.min_shrink &&\n         oldParams.params.selection_only == newParams.params.selection_only &&\n         oldParams.params.supports_alpha_blend ==\n             newParams.params.supports_alpha_blend &&\n         oldParams.pages.size() == newParams.pages.size() &&\n         oldParams.params.display_header_footer ==\n             newParams.params.display_header_footer &&\n         oldParams.params.date == newParams.params.date &&\n         oldParams.params.title == newParams.params.title &&\n         oldParams.params.url == newParams.params.url &&\n         std::equal(oldParams.pages.begin(), oldParams.pages.end(),\n             newParams.pages.begin());\n}", "target": 0}
{"code": "static inline bool is_noncanonical_address(u64 la)\n{\n#ifdef CONFIG_X86_64\n\treturn get_canonical(la) != la;\n#else\n\treturn false;\n#endif\n}", "target": 0}
{"code": "ClearServer2Client(rfbClient* client, int messageType)\n{\n  client->supportedMessages.server2client[((messageType & 0xFF)/8)] &= (!(1<<(messageType % 8)));\n}", "target": 0}
{"code": "AP_DECLARE(void) ap_set_last_modified(request_rec *r)\n{\n    if (!r->assbackwards) {\n        apr_time_t mod_time = ap_rationalize_mtime(r, r->mtime);\n        char *datestr = apr_palloc(r->pool, APR_RFC822_DATE_LEN);\n        apr_rfc822_date(datestr, mod_time);\n        apr_table_setn(r->headers_out, \"Last-Modified\", datestr);\n    }\n}", "target": 0}
{"code": "  void whenInputIs(const char *json, size_t len) {\n    memcpy(_jsonString, json, len);\n    _result = QuotedString::extractFrom(_jsonString, &_trailing);\n  }", "target": 0}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_annotation_default_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 0;\n\tRBinJavaAttrInfo *attr = NULL;\n\tattr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr && sz >= offset) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_ANNOTATION_DEFAULT_ATTR;\n\t\tattr->info.annotation_default_attr.default_value = r_bin_java_element_value_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\tif (attr->info.annotation_default_attr.default_value) {\n\t\t\toffset += attr->info.annotation_default_attr.default_value->size;\n\t\t}\n\t}\n\tr_bin_java_print_annotation_default_attr_summary (attr);\n\treturn attr;\n}", "target": 1}
{"code": "static int fbcon_set_font(struct vc_data *vc, struct console_font *font,\n\t\t\t  unsigned int flags)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tunsigned charcount = font->charcount;\n\tint w = font->width;\n\tint h = font->height;\n\tint size;\n\tint i, csum;\n\tu8 *new_data, *data = font->data;\n\tint pitch = PITCH(font->width);\n\tif (charcount != 256 && charcount != 512)\n\t\treturn -EINVAL;\n\tif (w > FBCON_SWAP(info->var.rotate, info->var.xres, info->var.yres) ||\n\t    h > FBCON_SWAP(info->var.rotate, info->var.yres, info->var.xres))\n\t\treturn -EINVAL;\n\tif (!(info->pixmap.blit_x & (1 << (font->width - 1))) ||\n\t    !(info->pixmap.blit_y & (1 << (font->height - 1))))\n\t\treturn -EINVAL;\n\tif (fbcon_invalid_charcount(info, charcount))\n\t\treturn -EINVAL;\n\tsize = CALC_FONTSZ(h, pitch, charcount);\n\tnew_data = kmalloc(FONT_EXTRA_WORDS * sizeof(int) + size, GFP_USER);\n\tif (!new_data)\n\t\treturn -ENOMEM;\n\tmemset(new_data, 0, FONT_EXTRA_WORDS * sizeof(int));\n\tnew_data += FONT_EXTRA_WORDS * sizeof(int);\n\tFNTSIZE(new_data) = size;\n\tREFCOUNT(new_data) = 0;\t\n\tfor (i=0; i< charcount; i++) {\n\t\tmemcpy(new_data + i*h*pitch, data +  i*32*pitch, h*pitch);\n\t}\n\tcsum = crc32(0, new_data, size);\n\tFNTSUM(new_data) = csum;\n\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\tstruct vc_data *tmp = vc_cons[i].d;\n\t\tif (fb_display[i].userfont &&\n\t\t    fb_display[i].fontdata &&\n\t\t    FNTSUM(fb_display[i].fontdata) == csum &&\n\t\t    FNTSIZE(fb_display[i].fontdata) == size &&\n\t\t    tmp->vc_font.width == w &&\n\t\t    !memcmp(fb_display[i].fontdata, new_data, size)) {\n\t\t\tkfree(new_data - FONT_EXTRA_WORDS * sizeof(int));\n\t\t\tnew_data = (u8 *)fb_display[i].fontdata;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn fbcon_do_set_font(vc, font->width, font->height, charcount, new_data, 1);\n}", "target": 1}
{"code": "void jpc_qmfb_split_col(jpc_fix_t *a, int numrows, int stride,\n  int parity)\n{\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE];\n\tjpc_fix_t *buf = splitbuf;\n\tregister jpc_fix_t *srcptr;\n\tregister jpc_fix_t *dstptr;\n\tregister int n;\n\tregister int m;\n\tint hstartcol;\n\tif (bufsize > QMFB_SPLITBUFSIZE) {\n\t\tif (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {\n\t\t\tabort();\n\t\t}\n\t}\n\tif (numrows >= 2) {\n\t\thstartcol = (numrows + 1 - parity) >> 1;\n\t\tm = numrows - hstartcol;\n\t\tn = m;\n\t\tdstptr = buf;\n\t\tsrcptr = &a[(1 - parity) * stride];\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\t++dstptr;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\tdstptr = &a[(1 - parity) * stride];\n\t\tsrcptr = &a[(2 - parity) * stride];\n\t\tn = numrows - m - (!parity);\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\tdstptr = &a[hstartcol * stride];\n\t\tsrcptr = buf;\n\t\tn = m;\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\tdstptr += stride;\n\t\t\t++srcptr;\n\t\t}\n\t}\n\tif (buf != splitbuf) {\n\t\tjas_free(buf);\n\t}\n}", "target": 1}
{"code": "const git_tree_entry *git_treebuilder_get(git_treebuilder *bld, const char *filename)\n{\n\treturn treebuilder_get(bld, filename);\n}", "target": 0}
{"code": "int kvm_arch_vcpu_ioctl_translate(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_translation *tr)\n{\n\tunsigned long vaddr = tr->linear_address;\n\tgpa_t gpa;\n\tint idx;\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tgpa = kvm_mmu_gva_to_gpa_system(vcpu, vaddr, NULL);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\ttr->physical_address = gpa;\n\ttr->valid = gpa != UNMAPPED_GVA;\n\ttr->writeable = 1;\n\ttr->usermode = 0;\n\treturn 0;\n}", "target": 0}
{"code": "ResponsePtr Server::ServeStatic(RequestPtr request) {\n  assert(request->method() == methods::kGet);\n  if (doc_root_.empty()) {\n    LOG_INFO(\"The doc root was not specified\");\n    return {};\n  }\n  fs::path path = doc_root_ / request->url().path();\n  try {\n    auto body = std::make_shared<FileBody>(path, file_chunk_size_);\n    auto response = std::make_shared<Response>(Status::kOK);\n    std::string extension = path.extension().string();\n    response->SetContentType(media_types::FromExtension(extension), \"\");\n    response->SetBody(body, true);\n    return response;\n  } catch (const Error& error) {\n    LOG_ERRO(\"File error: %s\", error.message().c_str());\n    return {};\n  }\n}", "target": 1}
{"code": "ahcp_time_print(netdissect_options *ndo,\n                const u_char *cp, uint8_t len)\n{\n\ttime_t t;\n\tstruct tm *tm;\n\tchar buf[BUFSIZE];\n\tif (len != 4)\n\t\tgoto invalid;\n\tt = GET_BE_U_4(cp);\n\tif (NULL == (tm = gmtime(&t)))\n\t\tND_PRINT(\": gmtime() error\");\n\telse if (0 == strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", tm))\n\t\tND_PRINT(\": strftime() error\");\n\telse\n\t\tND_PRINT(\": %s UTC\", buf);\n\treturn;\ninvalid:\n\tnd_print_invalid(ndo);\n\tND_TCHECK_LEN(cp, len);\n}", "target": 1}
{"code": "folly::Optional<TLSMessage> PlaintextReadRecordLayer::read(\n    folly::IOBufQueue& buf) {\n  while (true) {\n    folly::io::Cursor cursor(buf.front());\n    if (buf.empty() || !cursor.canAdvance(kPlaintextHeaderSize)) {\n      return folly::none;\n    }\n    TLSMessage msg;\n    msg.type = static_cast<ContentType>(cursor.readBE<ContentTypeType>());\n    if (skipEncryptedRecords_) {\n      if (msg.type == ContentType::application_data) {\n        cursor.skip(sizeof(ProtocolVersion));\n        auto length = cursor.readBE<uint16_t>();\n        if (buf.chainLength() < (cursor - buf.front()) + length) {\n          return folly::none;\n        }\n        length +=\n            sizeof(ContentType) + sizeof(ProtocolVersion) + sizeof(uint16_t);\n        buf.trimStart(length);\n        continue;\n      } else if (msg.type != ContentType::change_cipher_spec) {\n        skipEncryptedRecords_ = false;\n      }\n    }\n    switch (msg.type) {\n      case ContentType::handshake:\n      case ContentType::alert:\n        break;\n      case ContentType::change_cipher_spec:\n        break;\n      default:\n        throw std::runtime_error(folly::to<std::string>(\n            \"received plaintext content type \",\n            static_cast<ContentTypeType>(msg.type),\n            \", header: \",\n            folly::hexlify(buf.splitAtMost(10)->coalesce())));\n    }\n    receivedRecordVersion_ =\n        static_cast<ProtocolVersion>(cursor.readBE<ProtocolVersionType>());\n    auto length = cursor.readBE<uint16_t>();\n    if (length > kMaxPlaintextRecordSize) {\n      throw std::runtime_error(\"received too long plaintext record\");\n    }\n    if (length == 0) {\n      throw std::runtime_error(\"received empty plaintext record\");\n    }\n    if (buf.chainLength() < (cursor - buf.front()) + length) {\n      return folly::none;\n    }\n    cursor.clone(msg.fragment, length);\n    buf.trimStart(cursor - buf.front());\n    if (msg.type == ContentType::change_cipher_spec) {\n      msg.fragment->coalesce();\n      if (msg.fragment->length() == 1 && *msg.fragment->data() == 0x01) {\n        continue;\n      } else {\n        throw FizzException(\n            \"received ccs\", AlertDescription::illegal_parameter);\n      }\n    }\n    return std::move(msg);\n  }\n}", "target": 1}
{"code": "static intset *intsetResize(intset *is, uint32_t len) {\n    uint32_t size = len*intrev32ifbe(is->encoding);\n    is = zrealloc(is,sizeof(intset)+size);\n    return is;\n}", "target": 1}
{"code": "void gtkui_conf_read(void) {\n   FILE *fd;\n   const char *path;\n   char line[100], name[30];\n   short value;\n#ifdef OS_WINDOWS\n   path = ec_win_get_user_dir();\n#else\n   path = g_get_tmp_dir();\n#endif\n   filename = g_build_filename(path, \".ettercap_gtk\", NULL);\n   DEBUG_MSG(\"gtkui_conf_read: %s\", filename);\n   fd = fopen(filename, \"r\");\n   if(!fd) \n      return;\n   while(fgets(line, 100, fd)) {\n      sscanf(line, \"%s = %hd\", name, &value);\n      gtkui_conf_set(name, value);\n   }\n   fclose(fd);\n}", "target": 1}
{"code": "static Jsi_RC NumberToPrecisionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[100];\n    int prec = 0, skip = 0;\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    if (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &prec) != JSI_OK)\n        return JSI_ERROR;\n    if (prec<=0) return JSI_ERROR;\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    snprintf(buf, sizeof(buf),\"%.*\" JSI_NUMFFMT, prec, num);\n    if (num<0)\n        prec++;\n    buf[prec+1] = 0;\n    if (buf[prec] == '.')\n        buf[prec] = 0;\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}", "target": 1}
{"code": "void WasmBinaryWriter::prepare() {\n  ModuleUtils::collectHeapTypes(*wasm, types, typeIndices);\n  importInfo = wasm::make_unique<ImportInfo>(*wasm);\n}", "target": 0}
{"code": "static inline void get_conn_text(const conn *c, const int af,\n                char* addr, struct sockaddr *sock_addr) {\n    char addr_text[MAXPATHLEN];\n    addr_text[0] = '\\0';\n    const char *protoname = \"?\";\n    unsigned short port = 0;\n    switch (af) {\n        case AF_INET:\n            (void) inet_ntop(af,\n                    &((struct sockaddr_in *)sock_addr)->sin_addr,\n                    addr_text,\n                    sizeof(addr_text) - 1);\n            port = ntohs(((struct sockaddr_in *)sock_addr)->sin_port);\n            protoname = IS_UDP(c->transport) ? \"udp\" : \"tcp\";\n            break;\n        case AF_INET6:\n            addr_text[0] = '[';\n            addr_text[1] = '\\0';\n            if (inet_ntop(af,\n                    &((struct sockaddr_in6 *)sock_addr)->sin6_addr,\n                    addr_text + 1,\n                    sizeof(addr_text) - 2)) {\n                strcat(addr_text, \"]\");\n            }\n            port = ntohs(((struct sockaddr_in6 *)sock_addr)->sin6_port);\n            protoname = IS_UDP(c->transport) ? \"udp6\" : \"tcp6\";\n            break;\n        case AF_UNIX:\n            strncpy(addr_text,\n                    ((struct sockaddr_un *)sock_addr)->sun_path,\n                    sizeof(addr_text) - 1);\n            addr_text[sizeof(addr_text)-1] = '\\0';\n            protoname = \"unix\";\n            break;\n    }\n    if (strlen(addr_text) < 2) {\n        sprintf(addr_text, \"<AF %d>\", af);\n    }\n    if (port) {\n        sprintf(addr, \"%s:%s:%u\", protoname, addr_text, port);\n    } else {\n        sprintf(addr, \"%s:%s\", protoname, addr_text);\n    }\n}", "target": 1}
{"code": "int install_user_keyrings(void)\n{\n\tstruct user_struct *user;\n\tconst struct cred *cred;\n\tstruct key *uid_keyring, *session_keyring;\n\tkey_perm_t user_keyring_perm;\n\tchar buf[20];\n\tint ret;\n\tuid_t uid;\n\tuser_keyring_perm = (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_ALL;\n\tcred = current_cred();\n\tuser = cred->user;\n\tuid = from_kuid(cred->user_ns, user->uid);\n\tkenter(\"%p{%u}\", user, uid);\n\tif (user->uid_keyring && user->session_keyring) {\n\t\tkleave(\" = 0 [exist]\");\n\t\treturn 0;\n\t}\n\tmutex_lock(&key_user_keyring_mutex);\n\tret = 0;\n\tif (!user->uid_keyring) {\n\t\tsprintf(buf, \"_uid.%u\", uid);\n\t\tuid_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(uid_keyring)) {\n\t\t\tuid_keyring = keyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t\t    cred, user_keyring_perm,\n\t\t\t\t\t\t    KEY_ALLOC_IN_QUOTA,\n\t\t\t\t\t\t    NULL, NULL);\n\t\t\tif (IS_ERR(uid_keyring)) {\n\t\t\t\tret = PTR_ERR(uid_keyring);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tsprintf(buf, \"_uid_ses.%u\", uid);\n\t\tsession_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(session_keyring)) {\n\t\t\tsession_keyring =\n\t\t\t\tkeyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t      cred, user_keyring_perm,\n\t\t\t\t\t      KEY_ALLOC_IN_QUOTA,\n\t\t\t\t\t      NULL, NULL);\n\t\t\tif (IS_ERR(session_keyring)) {\n\t\t\t\tret = PTR_ERR(session_keyring);\n\t\t\t\tgoto error_release;\n\t\t\t}\n\t\t\tret = key_link(session_keyring, uid_keyring);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_release_both;\n\t\t}\n\t\tuser->uid_keyring = uid_keyring;\n\t\tuser->session_keyring = session_keyring;\n\t}\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = 0\");\n\treturn 0;\nerror_release_both:\n\tkey_put(session_keyring);\nerror_release:\n\tkey_put(uid_keyring);\nerror:\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}", "target": 1}
{"code": "static char *lxclock_name(const char *p, const char *n)\n{\n\tint ret;\n\tint len;\n\tchar *dest;\n\tchar *rundir;\n\tlen = strlen(\"/lock/lxc/\") + strlen(n) + strlen(p) + 3;\n\trundir = get_rundir();\n\tif (!rundir)\n\t\treturn NULL;\n\tlen += strlen(rundir);\n\tif ((dest = malloc(len)) == NULL) {\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\tret = snprintf(dest, len, \"%s/lock/lxc/%s\", rundir, p);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(dest);\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\tret = mkdir_p(dest, 0755);\n\tif (ret < 0) {\n\t\tint l2 = 22 + strlen(n) + strlen(p);\n\t\tif (l2 > len) {\n\t\t\tchar *d;\n\t\t\td = realloc(dest, l2);\n\t\t\tif (!d) {\n\t\t\t\tfree(dest);\n\t\t\t\tfree(rundir);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tlen = l2;\n\t\t\tdest = d;\n\t\t}\n\t\tret = snprintf(dest, len, \"/tmp/%d/lxc%s\", geteuid(), p);\n\t\tif (ret < 0 || ret >= len) {\n\t\t\tfree(dest);\n\t\t\tfree(rundir);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = mkdir_p(dest, 0755);\n\t\tif (ret < 0) {\n\t\t\tfree(dest);\n\t\t\tfree(rundir);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = snprintf(dest, len, \"/tmp/%d/lxc%s/.%s\", geteuid(), p, n);\n\t} else\n\t\tret = snprintf(dest, len, \"%s/lock/lxc/%s/.%s\", rundir, p, n);\n\tfree(rundir);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(dest);\n\t\treturn NULL;\n\t}\n\treturn dest;\n}", "target": 1}
{"code": "noscale(j_decompress_ptr cinfo,\n        JDIFFROW diff_buf, _JSAMPROW output_buf, JDIMENSION width)\n{\n  do {\n#if BITS_IN_JSAMPLE == 12\n    *output_buf++ = (_JSAMPLE)((*diff_buf++) & 0xFFF);\n#else\n    *output_buf++ = (_JSAMPLE)(*diff_buf++);\n#endif\n  } while (--width);\n}", "target": 0}
{"code": "choose_windows(s)\nconst char *s;\n{\n    register int i;\n    for (i = 0; winchoices[i].procs; i++) {\n        if ('+' == winchoices[i].procs->name[0])\n            continue;\n        if ('-' == winchoices[i].procs->name[0])\n            continue;\n        if (!strcmpi(s, winchoices[i].procs->name)) {\n            windowprocs = *winchoices[i].procs;\n            if (last_winchoice && last_winchoice->ini_routine)\n                (*last_winchoice->ini_routine)(WININIT_UNDO);\n            if (winchoices[i].ini_routine)\n                (*winchoices[i].ini_routine)(WININIT);\n            last_winchoice = &winchoices[i];\n            return;\n        }\n    }\n    if (!windowprocs.win_raw_print)\n        windowprocs.win_raw_print = def_raw_print;\n    if (!windowprocs.win_wait_synch)\n        windowprocs.win_wait_synch = def_wait_synch;\n    if (!winchoices[0].procs) {\n        raw_printf(\"No window types?\");\n        nh_terminate(EXIT_FAILURE);\n    }\n    if (!winchoices[1].procs) {\n        config_error_add(\n                     \"Window type %s not recognized.  The only choice is: %s\",\n                         s, winchoices[0].procs->name);\n    } else {\n        char buf[BUFSZ];\n        boolean first = TRUE;\n        buf[0] = '\\0';\n        for (i = 0; winchoices[i].procs; i++) {\n            if ('+' == winchoices[i].procs->name[0])\n                continue;\n            if ('-' == winchoices[i].procs->name[0])\n                continue;\n            Sprintf(eos(buf), \"%s%s\",\n                    first ? \"\" : \", \", winchoices[i].procs->name);\n            first = FALSE;\n        }\n        config_error_add(\"Window type %s not recognized.  Choices are:  %s\",\n                         s, buf);\n    }\n    if (windowprocs.win_raw_print == def_raw_print\n            || WINDOWPORT(\"safe-startup\"))\n        nh_terminate(EXIT_SUCCESS);\n}", "target": 1}
{"code": "int CJSON_CDECL main(void)\n{\n    UNITY_BEGIN();\n    RUN_TEST(cjson_array_foreach_should_loop_over_arrays);\n    RUN_TEST(cjson_array_foreach_should_not_dereference_null_pointer);\n    RUN_TEST(cjson_get_object_item_should_get_object_items);\n    RUN_TEST(cjson_get_object_item_case_sensitive_should_get_object_items);\n    RUN_TEST(cjson_get_object_item_should_not_crash_with_array);\n    RUN_TEST(cjson_get_object_item_case_sensitive_should_not_crash_with_array);\n    RUN_TEST(typecheck_functions_should_check_type);\n    RUN_TEST(cjson_should_not_parse_to_deeply_nested_jsons);\n    RUN_TEST(cjson_set_number_value_should_set_numbers);\n    RUN_TEST(cjson_detach_item_via_pointer_should_detach_items);\n    RUN_TEST(cjson_replace_item_via_pointer_should_replace_items);\n    RUN_TEST(cjson_replace_item_in_object_should_preserve_name);\n    RUN_TEST(cjson_functions_shouldnt_crash_with_null_pointers);\n    RUN_TEST(ensure_should_fail_on_failed_realloc);\n    RUN_TEST(skip_utf8_bom_should_skip_bom);\n    RUN_TEST(skip_utf8_bom_should_not_skip_bom_if_not_at_beginning);\n    RUN_TEST(cjson_get_string_value_should_get_a_string);\n    RUN_TEST(cjson_create_string_reference_should_create_a_string_reference);\n    RUN_TEST(cjson_create_object_reference_should_create_an_object_reference);\n    RUN_TEST(cjson_create_array_reference_should_create_an_array_reference);\n    RUN_TEST(cjson_add_item_to_object_should_not_use_after_free_when_string_is_aliased);\n    return UNITY_END();\n}", "target": 0}
{"code": "rb_xml_reader_attribute_hash(VALUE rb_reader)\n{\n  VALUE rb_attributes = rb_hash_new();\n  xmlTextReaderPtr c_reader;\n  xmlNodePtr c_node;\n  xmlAttrPtr c_property;\n  Data_Get_Struct(rb_reader, xmlTextReader, c_reader);\n  if (!has_attributes(c_reader)) {\n    return rb_attributes;\n  }\n  c_node = xmlTextReaderExpand(c_reader);\n  if (c_node == NULL) {\n    return Qnil;\n  }\n  c_property = c_node->properties;\n  while (c_property != NULL) {\n    VALUE rb_name = NOKOGIRI_STR_NEW2(c_property->name);\n    VALUE rb_value = Qnil;\n    xmlChar *c_value = xmlNodeGetContent((xmlNode *)c_property);\n    if (c_value) {\n      rb_value = NOKOGIRI_STR_NEW2(c_value);\n      xmlFree(c_value);\n    }\n    rb_hash_aset(rb_attributes, rb_name, rb_value);\n    c_property = c_property->next;\n  }\n  return rb_attributes;\n}", "target": 0}
{"code": "SMB2_sess_establish_session(struct SMB2_sess_data *sess_data)\n{\n\tint rc = 0;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tmutex_lock(&ses->server->srv_mutex);\n\tif (ses->server->sign && ses->server->ops->generate_signingkey) {\n\t\trc = ses->server->ops->generate_signingkey(ses);\n\t\tkfree(ses->auth_key.response);\n\t\tses->auth_key.response = NULL;\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI,\n\t\t\t\t\"SMB3 session key generation failed\\n\");\n\t\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t\tgoto keygen_exit;\n\t\t}\n\t}\n\tif (!ses->server->session_estab) {\n\t\tses->server->sequence_number = 0x2;\n\t\tses->server->session_estab = true;\n\t}\n\tmutex_unlock(&ses->server->srv_mutex);\n\tcifs_dbg(FYI, \"SMB2/3 session established successfully\\n\");\n\tspin_lock(&GlobalMid_Lock);\n\tses->status = CifsGood;\n\tses->need_reconnect = false;\n\tspin_unlock(&GlobalMid_Lock);\nkeygen_exit:\n\tif (!ses->server->sign) {\n\t\tkfree(ses->auth_key.response);\n\t\tses->auth_key.response = NULL;\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "int credential_from_url_gently(struct credential *c, const char *url,\n\t\t\t       int quiet)\n{\n\tconst char *at, *colon, *cp, *slash, *host, *proto_end;\n\tcredential_clear(c);\n\tproto_end = strstr(url, \":\n\tif (!proto_end)\n\t\treturn 0;\n\tcp = proto_end + 3;\n\tat = strchr(cp, '@');\n\tcolon = strchr(cp, ':');\n\tslash = strchrnul(cp, '/');\n\tif (!at || slash <= at) {\n\t\thost = cp;\n\t}\n\telse if (!colon || at <= colon) {\n\t\tc->username = url_decode_mem(cp, at - cp);\n\t\thost = at + 1;\n\t} else {\n\t\tc->username = url_decode_mem(cp, colon - cp);\n\t\tc->password = url_decode_mem(colon + 1, at - (colon + 1));\n\t\thost = at + 1;\n\t}\n\tif (proto_end - url > 0)\n\t\tc->protocol = xmemdupz(url, proto_end - url);\n\tc->host = url_decode_mem(host, slash - host);\n\twhile (*slash == '/')\n\t\tslash++;\n\tif (*slash) {\n\t\tchar *p;\n\t\tc->path = url_decode(slash);\n\t\tp = c->path + strlen(c->path) - 1;\n\t\twhile (p > c->path && *p == '/')\n\t\t\t*p-- = '\\0';\n\t}\n\tif (check_url_component(url, quiet, \"username\", c->username) < 0 ||\n\t    check_url_component(url, quiet, \"password\", c->password) < 0 ||\n\t    check_url_component(url, quiet, \"protocol\", c->protocol) < 0 ||\n\t    check_url_component(url, quiet, \"host\", c->host) < 0 ||\n\t    check_url_component(url, quiet, \"path\", c->path) < 0)\n\t\treturn -1;\n\treturn 0;\n}", "target": 1}
{"code": "TfLiteStatus EvalGatherNd(TfLiteContext* context, const TfLiteTensor* params,\n                          const TfLiteTensor* indices, TfLiteTensor* output) {\n  bool indices_has_only_positive_elements = true;\n  const auto* indices_values = GetTensorData<IndicesT>(indices);\n  const size_t num_indices = indices->bytes / sizeof(IndicesT);\n  for (size_t i = 0; i < num_indices; i++) {\n    if (indices_values[i] < 0) {\n      indices_has_only_positive_elements = false;\n      break;\n    }\n  }\n  TF_LITE_ENSURE(context, indices_has_only_positive_elements);\n  switch (params->type) {\n    case kTfLiteFloat32:\n      return GatherNd<float, IndicesT>(params, indices, output);\n    case kTfLiteUInt8:\n      return GatherNd<uint8_t, IndicesT>(params, indices, output);\n    case kTfLiteInt8:\n      return GatherNd<int8_t, IndicesT>(params, indices, output);\n    case kTfLiteInt16:\n      return GatherNd<int16_t, IndicesT>(params, indices, output);\n    case kTfLiteInt32:\n      return GatherNd<int32_t, IndicesT>(params, indices, output);\n    case kTfLiteInt64:\n      return GatherNd<int64_t, IndicesT>(params, indices, output);\n    case kTfLiteString:\n      return GatherNdString<IndicesT>(params, indices, output);\n    default:\n      context->ReportError(context,\n                           \"Params type '%s' are not supported by gather_nd.\",\n                           TfLiteTypeGetName(params->type));\n      return kTfLiteError;\n  }\n}", "target": 0}
{"code": "gx_default_create_compositor(gx_device * dev, gx_device ** pcdev,\n                             const gs_composite_t * pcte,\n                             gs_gstate * pgs, gs_memory_t * memory,\n                             gx_device *cdev)\n{\n    return pcte->type->procs.create_default_compositor\n        (pcte, pcdev, dev, pgs, memory);\n}", "target": 0}
{"code": "int ip_build_and_send_pkt(struct sk_buff *skb, struct sock *sk,\n\t\t\t  __be32 saddr, __be32 daddr, struct ip_options *opt)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct rtable *rt = skb_rtable(skb);\n\tstruct iphdr *iph;\n\tskb_push(skb, sizeof(struct iphdr) + (opt ? opt->optlen : 0));\n\tskb_reset_network_header(skb);\n\tiph = ip_hdr(skb);\n\tiph->version  = 4;\n\tiph->ihl      = 5;\n\tiph->tos      = inet->tos;\n\tif (ip_dont_fragment(sk, &rt->dst))\n\t\tiph->frag_off = htons(IP_DF);\n\telse\n\t\tiph->frag_off = 0;\n\tiph->ttl      = ip_select_ttl(inet, &rt->dst);\n\tiph->daddr    = rt->rt_dst;\n\tiph->saddr    = rt->rt_src;\n\tiph->protocol = sk->sk_protocol;\n\tip_select_ident(iph, &rt->dst, sk);\n\tif (opt && opt->optlen) {\n\t\tiph->ihl += opt->optlen>>2;\n\t\tip_options_build(skb, opt, daddr, rt, 0);\n\t}\n\tskb->priority = sk->sk_priority;\n\tskb->mark = sk->sk_mark;\n\treturn ip_local_out(skb);\n}", "target": 1}
{"code": "gif_read_image(FILE       *fp,\t\t\n\t       image_t    *img,\t\t\n\t       gif_cmap_t cmap,\t\t\n\t       int        interlace,\t\n\t       int        transparent)\t\n{\n  uchar\t\tcode_size,\t\t\n\t\t*temp;\t\t\t\n  int\t\txpos,\t\t\t\n\t\typos,\t\t\t\n\t\tpass;\t\t\t\n  int\t\tpixel;\t\t\t\n  static int\txpasses[4] = { 8, 8, 4, 2 },\n\t\typasses[5] = { 0, 4, 2, 1, 999999 };\n  xpos      = 0;\n  ypos      = 0;\n  pass      = 0;\n  code_size = (uchar)getc(fp);\n  if (code_size > 12)\n  {\n    progress_error(HD_ERROR_READ_ERROR, \"Bad GIF file \\\"%s\\\" - invalid code size %d.\", img->filename, code_size);\n    return (-1);\n  }\n  if (gif_read_lzw(fp, 1, code_size) < 0)\n    return (-1);\n  temp = img->pixels;\n  while ((pixel = gif_read_lzw(fp, 0, code_size)) >= 0 && pixel < 256)\n  {\n    temp[0] = cmap[pixel][0];\n    if (img->depth > 1)\n    {\n      temp[1] = cmap[pixel][1];\n      temp[2] = cmap[pixel][2];\n    }\n    if (pixel == transparent)\n      image_set_mask(img, xpos, ypos);\n    xpos ++;\n    temp += img->depth;\n    if (xpos == img->width)\n    {\n      xpos = 0;\n      if (interlace)\n      {\n        ypos += xpasses[pass];\n        temp += (xpasses[pass] - 1) * img->width * img->depth;\n        if (ypos >= img->height)\n\t{\n\t  pass ++;\n          ypos = ypasses[pass];\n          temp = img->pixels + ypos * img->width * img->depth;\n\t}\n      }\n      else\n\typos ++;\n    }\n    if (ypos >= img->height)\n      break;\n  }\n  return (0);\n}", "target": 0}
{"code": "create_principal3_2_svc(cprinc3_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg;\n    gss_buffer_desc             client_name, service_name;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    restriction_t               *rp;\n    const char                  *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->rec.principal, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_ADD,\n                               arg->rec.principal, &rp)\n        || kadm5int_acl_impose_restrictions(handle->context,\n                                            &arg->rec, &arg->mask, rp)) {\n        ret.code = KADM5_AUTH_ADD;\n        log_unauth(\"kadm5_create_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_create_principal_3((void *)handle,\n                                            &arg->rec, arg->mask,\n                                            arg->n_ks_tuple,\n                                            arg->ks_tuple,\n                                            arg->passwd);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_create_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "static void mpls_dev_sysctl_unregister(struct net_device *dev,\n\t\t\t\t       struct mpls_dev *mdev)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct ctl_table *table;\n\tif (!mdev->sysctl)\n\t\treturn;\n\ttable = mdev->sysctl->ctl_table_arg;\n\tunregister_net_sysctl_table(mdev->sysctl);\n\tkfree(table);\n\tmpls_netconf_notify_devconf(net, RTM_DELNETCONF, 0, mdev);\n}", "target": 0}
{"code": "void WidgetUtils::openUrlByDesktop(const QUrl &p_url)\n{\n    const auto scheme = p_url.scheme();\n    if (scheme != \"http\" && scheme != \"https\") {\n        int ret = MessageBoxHelper::questionYesNo(MessageBoxHelper::Warning,\n                                                  MainWindow::tr(\"Are you sure to open link (%1)?\").arg(p_url.toString()),\n                                                  MainWindow::tr(\"Malicious link might do harm to your device.\"),\n                                                  QString(),\n                                                  nullptr);\n        if (ret == QMessageBox::No) {\n            return;\n        }\n    }\n    QDesktopServices::openUrl(p_url);\n}", "target": 0}
{"code": "int tcp_read_sock(struct sock *sk, read_descriptor_t *desc,\n\t\t  sk_read_actor_t recv_actor)\n{\n\tstruct sk_buff *skb;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 seq = tp->copied_seq;\n\tu32 offset;\n\tint copied = 0;\n\tif (sk->sk_state == TCP_LISTEN)\n\t\treturn -ENOTCONN;\n\twhile ((skb = tcp_recv_skb(sk, seq, &offset)) != NULL) {\n\t\tif (offset < skb->len) {\n\t\t\tint used;\n\t\t\tsize_t len;\n\t\t\tlen = skb->len - offset;\n\t\t\tif (tp->urg_data) {\n\t\t\t\tu32 urg_offset = tp->urg_seq - seq;\n\t\t\t\tif (urg_offset < len)\n\t\t\t\t\tlen = urg_offset;\n\t\t\t\tif (!len)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tused = recv_actor(desc, skb, offset, len);\n\t\t\tif (used < 0) {\n\t\t\t\tif (!copied)\n\t\t\t\t\tcopied = used;\n\t\t\t\tbreak;\n\t\t\t} else if (used <= len) {\n\t\t\t\tseq += used;\n\t\t\t\tcopied += used;\n\t\t\t\toffset += used;\n\t\t\t}\n\t\t\tskb = tcp_recv_skb(sk, seq-1, &offset);\n\t\t\tif (!skb || (offset+1 != skb->len))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (tcp_hdr(skb)->fin) {\n\t\t\tsk_eat_skb(sk, skb, 0);\n\t\t\t++seq;\n\t\t\tbreak;\n\t\t}\n\t\tsk_eat_skb(sk, skb, 0);\n\t\tif (!desc->count)\n\t\t\tbreak;\n\t\ttp->copied_seq = seq;\n\t}\n\ttp->copied_seq = seq;\n\ttcp_rcv_space_adjust(sk);\n\tif (copied > 0)\n\t\ttcp_cleanup_rbuf(sk, copied);\n\treturn copied;\n}", "target": 0}
{"code": "unsigned WebGraphicsContext3DDefaultImpl::createRenderbuffer()\n{\n    makeContextCurrent();\n    GLuint o;\n    glGenRenderbuffersEXT(1, &o);\n    return o;\n}", "target": 0}
{"code": "static int ghash_final(struct shash_desc *desc, u8 *dst)\n{\n\tstruct ghash_desc_ctx *dctx = shash_desc_ctx(desc);\n\tstruct ghash_ctx *ctx = crypto_shash_ctx(desc->tfm);\n\tu8 *buf = dctx->buffer;\n\tif (!ctx->gf128)\n\t\treturn -ENOKEY;\n\tghash_flush(ctx, dctx);\n\tmemcpy(dst, buf, GHASH_BLOCK_SIZE);\n\treturn 0;\n}", "target": 0}
{"code": "cib_handle_remote_msg(cib_client_t *client, xmlNode *command)\n{\n    const char *value = NULL;\n    value = crm_element_name(command);\n    if (safe_str_neq(value, \"cib_command\")) {\n        crm_log_xml_trace(command, \"Bad command: \");\n        return;\n    }\n    if (client->name == NULL) {\n        value = crm_element_value(command, F_CLIENTNAME);\n        if (value == NULL) {\n            client->name = strdup(client->id);\n        } else {\n            client->name = strdup(value);\n        }\n    }\n    if (client->callback_id == NULL) {\n        value = crm_element_value(command, F_CIB_CALLBACK_TOKEN);\n        if (value != NULL) {\n            client->callback_id = strdup(value);\n            crm_trace(\"Callback channel for %s is %s\", client->id, client->callback_id);\n        } else {\n            client->callback_id = strdup(client->id);\n        }\n    }\n    xml_remove_prop(command, F_ORIG);\n    xml_remove_prop(command, F_CIB_HOST);\n    xml_remove_prop(command, F_CIB_GLOBAL_UPDATE);\n    crm_xml_add(command, F_TYPE, T_CIB);\n    crm_xml_add(command, F_CIB_CLIENTID, client->id);\n    crm_xml_add(command, F_CIB_CLIENTNAME, client->name);\n#if ENABLE_ACL\n    crm_xml_add(command, F_CIB_USER, client->user);\n#endif\n    if (crm_element_value(command, F_CIB_CALLID) == NULL) {\n        char *call_uuid = crm_generate_uuid();\n        crm_xml_add(command, F_CIB_CALLID, call_uuid);\n        free(call_uuid);\n    }\n    if (crm_element_value(command, F_CIB_CALLOPTS) == NULL) {\n        crm_xml_add_int(command, F_CIB_CALLOPTS, 0);\n    }\n    crm_log_xml_trace(command, \"Remote command: \");\n    cib_common_callback_worker(0, 0, command, client, TRUE);\n}", "target": 0}
{"code": "static Jsi_RC jsi_ArrayPushCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Obj *obj;\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    obj = _this->d.obj;\n    int argc = Jsi_ValueGetLength(interp, args);\n    int curlen = Jsi_ObjGetLength(interp, obj);\n    if (curlen < 0) {\n        Jsi_ObjSetLength(interp, obj, 0);\n    }\n    int i;\n    for (i = 0; i < argc; ++i) {\n        Jsi_Value *ov = Jsi_ValueArrayIndex(interp, args, i);\n        if (!ov) { Jsi_LogBug(\"Arguments Error\"); ov = Jsi_ValueNew(interp); }\n        Jsi_ValueInsertArray(interp, _this, curlen + i, ov, 0);\n    }\n    Jsi_ValueMakeNumber(interp, ret, Jsi_ObjGetLength(interp, obj));\n    return JSI_OK;\n}", "target": 1}
{"code": "NOEXPORT int ssl_tlsext_ticket_key_cb(SSL *ssl, unsigned char *key_name,\n        unsigned char *iv, EVP_CIPHER_CTX *ctx, HMAC_CTX *hctx, int enc) {\n    CLI *c;\n    const EVP_CIPHER *cipher;\n    int iv_len;\n    (void)key_name; \n    s_log(LOG_DEBUG, \"Session ticket processing callback\");\n    c=SSL_get_ex_data(ssl, index_ssl_cli);\n    if(!HMAC_Init_ex(hctx, (const unsigned char *)(c->opt->ticket_mac->key_val),\n        c->opt->ticket_mac->key_len, EVP_sha256(), NULL)) {\n        s_log(LOG_ERR, \"HMAC_Init_ex failed\");\n        return -1;\n    }\n    if(c->opt->ticket_key->key_len == 16)\n        cipher = EVP_aes_128_cbc();\n    else \n        cipher = EVP_aes_256_cbc();\n    if(enc) { \n        iv_len = EVP_CIPHER_iv_length(cipher);\n        if(RAND_bytes(iv, iv_len) <= 0) { \n            s_log(LOG_ERR, \"RAND_bytes failed\");\n            return -1;\n        }\n        if(!EVP_EncryptInit_ex(ctx, cipher, NULL,\n            (const unsigned char *)(c->opt->ticket_key->key_val), iv)) {\n            s_log(LOG_ERR, \"EVP_EncryptInit_ex failed\");\n            return -1;\n        }\n    } else \n        if(!EVP_DecryptInit_ex(ctx, cipher, NULL,\n            (const unsigned char *)(c->opt->ticket_key->key_val), iv)) {\n            s_log(LOG_ERR, \"EVP_DecryptInit_ex failed\");\n            return -1;\n        }\n    if(strcmp(SSL_get_version(c->ssl), \"TLSv1.3\"))\n        return 1; \n    else\n        return 2; \n}", "target": 1}
{"code": "resolve_list_keys(struct lys_node_list *list, const char *keys_str)\n{\n    int i, len, rc;\n    const char *value;\n    char *s = NULL;\n    struct ly_ctx *ctx = list->module->ctx;\n    for (i = 0; i < list->keys_size; ++i) {\n        assert(keys_str);\n        if (!list->child) {\n            LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, list, \"list keys\", keys_str);\n            return EXIT_FAILURE;\n        }\n        if ((value = strpbrk(keys_str, \" \\t\\n\"))) {\n            len = value - keys_str;\n            while (isspace(value[0])) {\n                value++;\n            }\n        } else {\n            len = strlen(keys_str);\n        }\n        rc = lys_getnext_data(lys_node_module((struct lys_node *)list), (struct lys_node *)list, keys_str, len, LYS_LEAF,\n                              (const struct lys_node **)&list->keys[i]);\n        if (rc) {\n            LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, list, \"list key\", keys_str);\n            return EXIT_FAILURE;\n        }\n        if (check_key(list, i, keys_str, len)) {\n            return -1;\n        }\n        if (lyp_check_status(list->flags, list->module, list->name,\n                             list->keys[i]->flags, list->keys[i]->module, list->keys[i]->name,\n                             (struct lys_node *)list->keys[i])) {\n            return -1;\n        }\n        if (list->keys[i]->dflt) {\n            assert(log_opt == ILO_STORE);\n            log_opt = ILO_LOG;\n            LOGWRN(ctx, \"Default value \\\"%s\\\" in the list key \\\"%s\\\" is ignored. (%s)\", list->keys[i]->dflt,\n                   list->keys[i]->name, s = lys_path((struct lys_node*)list, LYS_PATH_FIRST_PREFIX));\n            log_opt = ILO_STORE;\n            free(s);\n        }\n        while (value && isspace(value[0])) {\n            value++;\n        }\n        keys_str = value;\n    }\n    return EXIT_SUCCESS;\n}", "target": 1}
{"code": "static MagickBooleanType ConcatenateImages(int argc,char **argv,\n     ExceptionInfo *exception )\n{\n  FILE\n    *input,\n    *output;\n  int\n    c;\n  register ssize_t\n    i;\n  if (ExpandFilenames(&argc,&argv) == MagickFalse)\n    ThrowFileException(exception,ResourceLimitError,\"MemoryAllocationFailed\",\n         GetExceptionMessage(errno));\n  output=fopen_utf8(argv[argc-1],\"wb\");\n  if (output == (FILE *) NULL) {\n    ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",argv[argc-1]);\n    return(MagickFalse);\n  }\n  for (i=2; i < (ssize_t) (argc-1); i++) {\n#if 0\n    fprintf(stderr, \"DEBUG: Concatenate Image: \\\"%s\\\"\\n\", argv[i]);\n#endif\n    input=fopen_utf8(argv[i],\"rb\");\n    if (input == (FILE *) NULL) {\n        ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",argv[i]);\n        continue;\n      }\n    for (c=fgetc(input); c != EOF; c=fgetc(input))\n      (void) fputc((char) c,output);\n    (void) fclose(input);\n    (void) remove_utf8(argv[i]);\n  }\n  (void) fclose(output);\n  return(MagickTrue);\n}", "target": 1}
{"code": "static CONSTBUFFER_HANDLE CONSTBUFFER_Create_Internal(const unsigned char* source, size_t size)\n{\n    CONSTBUFFER_HANDLE result;\n    result = (CONSTBUFFER_HANDLE)calloc(1, (sizeof(CONSTBUFFER_HANDLE_DATA) + size));\n    if (result == NULL)\n    {\n        LogError(\"unable to malloc\");\n    }\n    else\n    {\n        INIT_REF_VAR(result->count);\n        result->alias.size = size;\n        if (size == 0)\n        {\n            result->alias.buffer = NULL;\n        }\n        else\n        {\n            unsigned char* temp = (unsigned char*)(result + 1);\n            (void)memcpy(temp, source, size);\n            result->alias.buffer = temp;\n        }\n        result->buffer_type = CONSTBUFFER_TYPE_COPIED;\n    }\n    return result;\n}", "target": 1}
{"code": "static int f2fs_read_data_page(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint ret = -EAGAIN;\n\ttrace_f2fs_readpage(page, DATA);\n\tif (f2fs_has_inline_data(inode))\n\t\tret = f2fs_read_inline_data(inode, page);\n\tif (ret == -EAGAIN)\n\t\tret = f2fs_mpage_readpages(page->mapping, NULL, page, 1, false);\n\treturn ret;\n}", "target": 1}
{"code": "      JpegInput( String filename ) : filename_( std::move( filename )) {\n         infile_ = std::fopen( filename_.c_str(), \"rb\" );\n         if( infile_ == nullptr ) {\n            if( !FileHasExtension( filename_ )) {\n               filename_ = FileAddExtension( filename_, \"jpg\" ); \n               infile_ = std::fopen( filename_.c_str(), \"rb\" );\n               if( infile_ == nullptr ) {\n                  filename_ = FileAddExtension( filename_, \"jpeg\" ); \n                  infile_ = std::fopen( filename_.c_str(), \"rb\" );\n               }\n            }\n         }\n         if( infile_ == nullptr ) {\n            DIP_THROW_RUNTIME( \"Could not open the specified JPEG file\" );\n         }\n         cinfo_.err = jpeg_std_error( &jerr_.pub );\n         jerr_.pub.error_exit = my_error_exit;\n         jerr_.pub.output_message = my_output_message;\n         if( setjmp( jerr_.setjmp_buffer )) {\n            DIP_THROW_RUNTIME( \"Error reading JPEG file.\" );\n         }\n         jpeg_create_decompress( &cinfo_ );\n         initialized_ = true;\n         jpeg_stdio_src( &cinfo_, infile_ );\n         jpeg_read_header( &cinfo_, TRUE );\n      }", "target": 1}
{"code": "static int cp2112_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\tunsigned offset, int value)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n\tint ret;\n\tspin_lock_irqsave(&dev->lock, flags);\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\tbuf[1] |= 1 << offset;\n\tbuf[2] = gpio_push_pull;\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error setting GPIO config: %d\\n\", ret);\n\t\tgoto fail;\n\t}\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\tcp2112_gpio_set(chip, offset, value);\n\treturn 0;\nfail:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn ret < 0 ? ret : -EIO;\n}", "target": 1}
{"code": "static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\t\tsecurity_key_free(key);\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\t\tatomic_dec(&key->user->nkeys);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n\t\t\tatomic_dec(&key->user->nikeys);\n\t\tkey_user_put(key->user);\n\t\tif (key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\t\tkfree(key->description);\n#ifdef KEY_DEBUGGING\n\t\tkey->magic = KEY_DEBUG_MAGIC_X;\n#endif\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}", "target": 1}
{"code": "void gdImageSetThickness (gdImagePtr im, int thickness)\n{\n\tim->thick = thickness;\n}", "target": 0}
{"code": "static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n\t\t\t\t\t  const struct lxc_rootfs *rootfs,\n\t\t\t\t\t  const char *lxc_name)\n{\n\tchar *aux;\n\tchar path[MAXPATHLEN];\n\tint r, ret = 0, offset;\n\tconst char *lxcpath;\n\tlxcpath = lxc_global_config_value(\"lxc.lxcpath\");\n\tif (!lxcpath) {\n\t\tERROR(\"Out of memory\");\n\t\treturn -1;\n\t}\n\tr = snprintf(path, MAXPATHLEN, \"%s/%s/rootfs\", lxcpath, lxc_name);\n\tif (r < 0 || r >= MAXPATHLEN)\n\t\tgoto skipvarlib;\n\taux = strstr(mntent->mnt_dir, path);\n\tif (aux) {\n\t\toffset = strlen(path);\n\t\tgoto skipabs;\n\t}\nskipvarlib:\n\taux = strstr(mntent->mnt_dir, rootfs->path);\n\tif (!aux) {\n\t\tWARN(\"ignoring mount point '%s'\", mntent->mnt_dir);\n\t\treturn ret;\n\t}\n\toffset = strlen(rootfs->path);\nskipabs:\n\tr = snprintf(path, MAXPATHLEN, \"%s/%s\", rootfs->mount,\n\t\t aux + offset);\n\tif (r < 0 || r >= MAXPATHLEN) {\n\t\tWARN(\"pathnme too long for '%s'\", mntent->mnt_dir);\n\t\treturn -1;\n\t}\n\treturn mount_entry_on_generic(mntent, path);\n}", "target": 1}
{"code": "std::string addEmoji(const Proxy &node, const RegexMatchConfigs &emoji_array, extra_settings &ext)\n{\n    std::string real_rule, ret;\n    for(const RegexMatchConfig &x : emoji_array)\n    {\n        if(!x.Script.empty())\n        {\n            std::string result;\n            script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)\n            {\n                std::string script = x.Script;\n                if(startsWith(script, \"path:\"))\n                    script = fileGet(script.substr(5), true);\n                try\n                {\n                    ctx.eval(script);\n                    auto getEmoji = (std::function<std::string(const Proxy&)>) ctx.eval(\"getEmoji\");\n                    ret = getEmoji(node);\n                    if(!ret.empty())\n                        result = ret + \" \" + node.Remark;\n                }\n                catch (qjs::exception)\n                {\n                    script_print_stack(ctx);\n                }\n            }, global.scriptCleanContext);\n            if(!result.empty())\n                return result;\n            continue;\n        }\n        if(x.Replace.empty())\n            continue;\n        if(applyMatcher(x.Match, real_rule, node) && real_rule.size() && regFind(node.Remark, real_rule))\n            return x.Replace + \" \" + node.Remark;\n    }\n    return node.Remark;\n}", "target": 1}
{"code": "static void save_text_if_changed(const char *name, const char *new_value)\n{\n    if (!g_hash_table_lookup(g_loaded_texts, name))\n        return;\n    const char *old_value = g_cd ? problem_data_get_content_or_NULL(g_cd, name) : \"\";\n    if (!old_value)\n        old_value = \"\";\n    if (strcmp(new_value, old_value) != 0)\n    {\n        struct dump_dir *dd = wizard_open_directory_for_writing(g_dump_dir_name);\n        if (dd)\n            dd_save_text(dd, name, new_value);\n        dd_close(dd);\n        problem_data_reload_from_dump_dir();\n        update_gui_state_from_problem_data( 0);\n    }\n}", "target": 1}
{"code": "Status ImportNodes(ValueMapManager value_manager,\n                   const RepeatedPtrField<NodeDef>& nodes, OpBuilder& builder) {\n  Location unknown_loc = builder.getUnknownLoc();\n  MLIRContext* context = builder.getContext();\n  Type placeholder_ty = OpaqueTensorType::get(context);\n  Type control_ty = ControlType::get(context);\n  TFGraphDialect* tfgDialect =\n      cast<TFGraphDialect>(context->getLoadedDialect(\"tfg\"));\n  StringAttr device_attr = tfgDialect->getDeviceAttrIdentifier();\n  StringAttr name_attr = tfgDialect->getNameAttrIdentifier();\n  StringAttr fulltype_attr = tfgDialect->getFullTypeAttrIdentifier();\n  for (const NodeDef& node : nodes) {\n    DVLOG(1) << \"Processing node \" << node.name() << \"\\n\";\n    if (node.op().empty()) return InvalidArgument(\"empty op type\");\n    OperationState state(unknown_loc, absl::StrCat(\"tfg.\", node.op()));\n    for (const std::string& input : node.input()) {\n      if (input.empty())\n        return InvalidArgument(\"Node '\", node.name(), \"' has an empty input\");\n      state.operands.push_back(\n          value_manager.GetValueOrCreatePlaceholder(input));\n    }\n    state.types.push_back(placeholder_ty);\n    state.types.push_back(control_ty);\n    for (const auto& namedAttr : node.attr()) {\n      const std::string& name = namedAttr.first;\n      const AttrValue& tf_attr = namedAttr.second;\n      TF_ASSIGN_OR_RETURN(Attribute attr,\n                          ConvertAttributeValue(tf_attr, builder));\n      state.addAttribute(name, attr);\n    }\n    if (!node.device().empty())\n      state.addAttribute(device_attr, StringAttr::get(context, node.device()));\n    if (!node.name().empty())\n      state.addAttribute(name_attr, StringAttr::get(context, node.name()));\n    if (node.has_experimental_type()) {\n      TF_ASSIGN_OR_RETURN(tf_type::FullTypeAttr type,\n                          ConvertAttribute(node.experimental_type(), builder));\n      state.addAttribute(fulltype_attr, type);\n    }\n    Operation* op = builder.create(state);\n    StringRef node_name = node.name();\n    {\n      size_t colon_sep = node_name.find_first_of(':');\n      if (colon_sep != StringRef::npos)\n        node_name = node_name.take_front(colon_sep);\n    }\n    TF_RETURN_IF_ERROR(value_manager.DefineOperation(op, node_name));\n  }\n  for (Operation& op : *builder.getInsertionBlock()) {\n    if (op.getName().getStringRef() == \"tfg.__mlir_placeholder\") {\n      return InvalidArgument(absl::StrCat(\n          \"Couldn't import graph: placeholder left \",\n          op.getAttrOfType<StringAttr>(name_attr).getValue().str()));\n    }\n  }\n  return ::tensorflow::OkStatus();\n}", "target": 1}
{"code": "static BOOL zgfx_append(ZGFX_CONTEXT* zgfx, BYTE** ppConcatenated, size_t uncompressedSize,\n                        size_t* pUsed)\n{\n\tWINPR_ASSERT(zgfx);\n\tWINPR_ASSERT(ppConcatenated);\n\tWINPR_ASSERT(pUsed);\n\tconst size_t used = *pUsed;\n\tif (zgfx->OutputCount > UINT32_MAX - used)\n\t\treturn FALSE;\n\tif (used + zgfx->OutputCount > uncompressedSize)\n\t\treturn FALSE;\n\tBYTE* tmp = realloc(*ppConcatenated, used + zgfx->OutputCount + 64ull);\n\tif (!tmp)\n\t\treturn FALSE;\n\t*ppConcatenated = tmp;\n\tCopyMemory(&tmp[used], zgfx->OutputBuffer, zgfx->OutputCount);\n\t*pUsed = used + zgfx->OutputCount;\n\treturn TRUE;\n}", "target": 0}
{"code": "void xmlrpc_char_encode(char *outbuffer, const char *s1)\n{\n\tlong unsigned int i;\n\tunsigned char c;\n\tchar buf2[15];\n\tmowgli_string_t *s = mowgli_string_create();\n\t*buf2 = '\\0';\n\t*outbuffer = '\\0';\n\tif ((!(s1) || (*(s1) == '\\0')))\n\t{\n\t\treturn;\n\t}\n\tfor (i = 0; s1[i] != '\\0'; i++)\n\t{\n\t\tc = s1[i];\n\t\tif (c > 127)\n\t\t{\n\t\t\tsnprintf(buf2, sizeof buf2, \"&#%d;\", c);\n\t\t\ts->append(s, buf2, strlen(buf2));\n\t\t}\n\t\telse if (c == '&')\n\t\t{\n\t\t\ts->append(s, \"&amp;\", 5);\n\t\t}\n\t\telse if (c == '<')\n\t\t{\n\t\t\ts->append(s, \"&lt;\", 4);\n\t\t}\n\t\telse if (c == '>')\n\t\t{\n\t\t\ts->append(s, \"&gt;\", 4);\n\t\t}\n\t\telse if (c == '\"')\n\t\t{\n\t\t\ts->append(s, \"&quot;\", 6);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts->append_char(s, c);\n\t\t}\n\t}\n\tmemcpy(outbuffer, s->str, XMLRPC_BUFSIZE);\n}", "target": 1}
{"code": "static bool too_many_pipe_buffers_soft(struct user_struct *user)\n{\n\treturn pipe_user_pages_soft &&\n\t       atomic_long_read(&user->pipe_bufs) >= pipe_user_pages_soft;\n}", "target": 0}
{"code": "static int nested_vmx_check_msr_switch(struct kvm_vcpu *vcpu,\n\t\t\t\t       unsigned long count_field,\n\t\t\t\t       unsigned long addr_field)\n{\n\tint maxphyaddr;\n\tu64 count, addr;\n\tif (vmcs12_read_any(vcpu, count_field, &count) ||\n\t    vmcs12_read_any(vcpu, addr_field, &addr)) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\tif (count == 0)\n\t\treturn 0;\n\tmaxphyaddr = cpuid_maxphyaddr(vcpu);\n\tif (!IS_ALIGNED(addr, 16) || addr >> maxphyaddr ||\n\t    (addr + count * sizeof(struct vmx_msr_entry) - 1) >> maxphyaddr) {\n\t\tpr_warn_ratelimited(\n\t\t\t\"nVMX: invalid MSR switch (0x%lx, %d, %llu, 0x%08llx)\",\n\t\t\taddr_field, maxphyaddr, count, addr);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "int JOIN::optimize()\n{\n  int res= 0;\n  create_explain_query_if_not_exists(thd->lex, thd->mem_root);\n  join_optimization_state init_state= optimization_state;\n  if (select_lex->pushdown_select)\n  {\n    if (!(select_options & SELECT_DESCRIBE))\n    {\n      res= select_lex->pushdown_select->init();\n    }\n    with_two_phase_optimization= false;\n  }\n  else if (optimization_state == JOIN::OPTIMIZATION_PHASE_1_DONE)\n    res= optimize_stage2();\n  else\n  {\n    if (optimization_state != JOIN::NOT_OPTIMIZED)\n      return FALSE;\n    optimization_state= JOIN::OPTIMIZATION_IN_PROGRESS;\n    res= optimize_inner();\n  }\n  if (!with_two_phase_optimization ||\n      init_state == JOIN::OPTIMIZATION_PHASE_1_DONE)\n  {\n    if (!res && have_query_plan != QEP_DELETED)\n      res= build_explain();\n    optimization_state= JOIN::OPTIMIZATION_DONE;\n  }\n  return res;\n}", "target": 0}
{"code": "flatpak_run_get_cups_server_name (void)\n{\n  g_autofree char * cups_server = NULL;\n  g_autofree char * cups_config_path = NULL;\n  cups_server = g_strdup (g_getenv (\"CUPS_SERVER\"));\n  if (cups_server && flatpak_run_cups_check_server_is_socket (cups_server))\n    return g_steal_pointer (&cups_server);\n  g_clear_pointer (&cups_server, g_free);\n  cups_config_path = g_build_filename (g_get_home_dir (), \".cups/client.conf\", NULL);\n  cups_server = flatpak_run_get_cups_server_name_config (cups_config_path);\n  if (cups_server && flatpak_run_cups_check_server_is_socket (cups_server))\n    return g_steal_pointer (&cups_server);\n  g_clear_pointer (&cups_server, g_free);\n  cups_server = flatpak_run_get_cups_server_name_config (\"/etc/cups/client.conf\");\n  if (cups_server && flatpak_run_cups_check_server_is_socket (cups_server))\n    return g_steal_pointer (&cups_server);\n  return g_strdup (\"/var/run/cups/cups.sock\");\n}", "target": 0}
{"code": "    bool Image::isShortType(uint16_t type) {\n         return type == Exiv2::unsignedShort\n             || type == Exiv2::signedShort\n             ;\n    }", "target": 0}
{"code": "static int ref_pic_list_struct(GetBitContext *gb, RefPicListStruct *rpl)\n{\n    uint32_t delta_poc_st, strp_entry_sign_flag = 0;\n    rpl->ref_pic_num = get_ue_golomb_long(gb);\n    if (rpl->ref_pic_num > 0) {\n        delta_poc_st = get_ue_golomb_long(gb);\n        rpl->ref_pics[0] = delta_poc_st;\n        if (rpl->ref_pics[0] != 0) {\n            strp_entry_sign_flag = get_bits(gb, 1);\n            rpl->ref_pics[0] *= 1 - (strp_entry_sign_flag << 1);\n        }\n    }\n    for (int i = 1; i < rpl->ref_pic_num; ++i) {\n        delta_poc_st = get_ue_golomb_long(gb);\n        if (delta_poc_st != 0)\n            strp_entry_sign_flag = get_bits(gb, 1);\n        rpl->ref_pics[i] = rpl->ref_pics[i - 1] + delta_poc_st * (1 - (strp_entry_sign_flag << 1));\n    }\n    return 0;\n}", "target": 1}
{"code": "static int pdf_findobj(struct pdf_struct *pdf)\n{\n    const char *start, *q, *q2, *q3, *eof;\n    struct pdf_obj *obj;\n    off_t bytesleft;\n    unsigned genid, objid;\n    pdf->nobjs++;\n    pdf->objs = cli_realloc2(pdf->objs, sizeof(*pdf->objs)*pdf->nobjs);\n    if (!pdf->objs) {\n\tcli_warnmsg(\"cli_pdf: out of memory parsing objects (%u)\\n\", pdf->nobjs);\n\treturn -1;\n    }\n    obj = &pdf->objs[pdf->nobjs-1];\n    memset(obj, 0, sizeof(*obj));\n    start = pdf->map+pdf->offset;\n    bytesleft = pdf->size - pdf->offset;\n    q2 = cli_memstr(start, bytesleft, \" obj\", 4);\n    if (!q2)\n\treturn 0;\n    bytesleft -= q2 - start;\n    q = findNextNonWSBack(q2-1, start);\n    while (q > start && isdigit(*q)) { q--; }\n    genid = atoi(q);\n    q = findNextNonWSBack(q-1,start);\n    while (q > start && isdigit(*q)) { q--; }\n    objid = atoi(q);\n    obj->id = (objid << 8) | (genid&0xff);\n    obj->start = q2+4 - pdf->map;\n    obj->flags = 0;\n    bytesleft -= 4;\n    eof = pdf->map + pdf->size;\n    q = pdf->map + obj->start;\n    while (q < eof && bytesleft > 0) {\n\toff_t p_stream, p_endstream;\n\tq2 = pdf_nextobject(q, bytesleft);\n\tif (!q2)\n\t    return 0;\n\tbytesleft -= q2 - q;\n\tif (find_stream_bounds(q-1, q2-q, bytesleft + (q2-q), &p_stream, &p_endstream)) {\n\t    obj->flags |= 1 << OBJ_STREAM;\n\t    q2 = q-1 + p_endstream + 6;\n\t    bytesleft -= q2 - q + 1;\n\t} else if ((q3 = cli_memstr(q-1, q2-q+1, \"endobj\", 6))) {\n\t    q2 = q3 + 6;\n\t    pdf->offset = q2 - pdf->map;\n\t    return 1; \n\t} else {\n\t    q2++;\n\t}\n\tq = q2;\n    }\n    return 0;\n}", "target": 0}
{"code": "int usb_cypress_load_firmware(struct usb_device *udev, const struct firmware *fw, int type)\n{\n\tstruct hexline *hx;\n\tu8 reset;\n\tint ret,pos=0;\n\thx = kmalloc(sizeof(*hx), GFP_KERNEL);\n\tif (!hx)\n\t\treturn -ENOMEM;\n\treset = 1;\n\tif ((ret = usb_cypress_writemem(udev,cypress[type].cpu_cs_register,&reset,1)) != 1)\n\t\terr(\"could not stop the USB controller CPU.\");\n\twhile ((ret = dvb_usb_get_hexline(fw, hx, &pos)) > 0) {\n\t\tdeb_fw(\"writing to address 0x%04x (buffer: 0x%02x %02x)\\n\", hx->addr, hx->len, hx->chk);\n\t\tret = usb_cypress_writemem(udev, hx->addr, hx->data, hx->len);\n\t\tif (ret != hx->len) {\n\t\t\terr(\"error while transferring firmware (transferred size: %d, block size: %d)\",\n\t\t\t\tret, hx->len);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ret < 0) {\n\t\terr(\"firmware download failed at %d with %d\",pos,ret);\n\t\tkfree(hx);\n\t\treturn ret;\n\t}\n\tif (ret == 0) {\n\t\treset = 0;\n\t\tif (ret || usb_cypress_writemem(udev,cypress[type].cpu_cs_register,&reset,1) != 1) {\n\t\t\terr(\"could not restart the USB controller CPU.\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else\n\t\tret = -EIO;\n\tkfree(hx);\n\treturn ret;\n}", "target": 1}
{"code": "TEST_CASE(\"Invalid UTF-8 text test\", \"[general]\")\n{\n    std::string s = \"a <- '\";\n    s += static_cast<char>(0xe8); \n    parser parser(s.c_str());\n    bool ret = parser;\n    REQUIRE(ret == false);\n}", "target": 0}
{"code": "static int mwifiex_pcie_init_evt_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct mwifiex_evt_buf_desc *desc;\n\tstruct sk_buff *skb;\n\tdma_addr_t buf_pa;\n\tint i;\n\tfor (i = 0; i < MWIFIEX_MAX_EVT_BD; i++) {\n\t\tskb = dev_alloc_skb(MAX_EVENT_SIZE);\n\t\tif (!skb) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Unable to allocate skb for EVENT buf.\\n\");\n\t\t\tkfree(card->evtbd_ring_vbase);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb_put(skb, MAX_EVENT_SIZE);\n\t\tif (mwifiex_map_pci_memory(adapter, skb, MAX_EVENT_SIZE,\n\t\t\t\t\t   PCI_DMA_FROMDEVICE))\n\t\t\treturn -1;\n\t\tbuf_pa = MWIFIEX_SKB_DMA_ADDR(skb);\n\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t    \"info: EVT ring: skb=%p len=%d data=%p buf_pa=%#x:%x\\n\",\n\t\t\t    skb, skb->len, skb->data, (u32)buf_pa,\n\t\t\t    (u32)((u64)buf_pa >> 32));\n\t\tcard->evt_buf_list[i] = skb;\n\t\tcard->evtbd_ring[i] = (void *)(card->evtbd_ring_vbase +\n\t\t\t\t      (sizeof(*desc) * i));\n\t\tdesc = card->evtbd_ring[i];\n\t\tdesc->paddr = buf_pa;\n\t\tdesc->len = (u16)skb->len;\n\t\tdesc->flags = 0;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "unique_ptr<IOBuf> IOBuf::takeOwnership(\n    void* buf,\n    std::size_t capacity,\n    std::size_t offset,\n    std::size_t length,\n    FreeFunction freeFn,\n    void* userData,\n    bool freeOnError,\n    TakeOwnershipOption option) {\n  if (capacity > kMaxIOBufSize) {\n    throw_exception<std::bad_alloc>();\n  }\n  DCHECK(\n      !userData || (userData && freeFn) ||\n      (userData && !freeFn && (option == TakeOwnershipOption::STORE_SIZE)));\n  HeapFullStorage* storage = nullptr;\n  auto rollback = makeGuard([&] {\n    if (storage) {\n      free(storage);\n    }\n    takeOwnershipError(freeOnError, buf, freeFn, userData);\n  });\n  size_t requiredStorage = sizeof(HeapFullStorage);\n  size_t mallocSize = goodMallocSize(requiredStorage);\n  storage = static_cast<HeapFullStorage*>(checkedMalloc(mallocSize));\n  new (&storage->hs.prefix)\n      HeapPrefix(kIOBufInUse | kSharedInfoInUse, mallocSize);\n  new (&storage->shared)\n      SharedInfo(freeFn, userData, true );\n  auto result = unique_ptr<IOBuf>(new (&storage->hs.buf) IOBuf(\n      InternalConstructor(),\n      packFlagsAndSharedInfo(0, &storage->shared),\n      static_cast<uint8_t*>(buf),\n      capacity,\n      static_cast<uint8_t*>(buf) + offset,\n      length));\n  rollback.dismiss();\n  if (io_buf_alloc_cb) {\n    io_buf_alloc_cb(storage, mallocSize);\n    if (userData && !freeFn && (option == TakeOwnershipOption::STORE_SIZE)) {\n      io_buf_alloc_cb(buf, capacity);\n    }\n  }\n  return result;\n}", "target": 0}
{"code": "batadv_frag_merge_packets(struct hlist_head *chain, struct sk_buff *skb)\n{\n\tstruct batadv_frag_packet *packet;\n\tstruct batadv_frag_list_entry *entry;\n\tstruct sk_buff *skb_out = NULL;\n\tint size, hdr_size = sizeof(struct batadv_frag_packet);\n\tpacket = (struct batadv_frag_packet *)skb->data;\n\tsize = ntohs(packet->total_size);\n\tif (size > batadv_frag_size_limit())\n\t\tgoto free;\n\tentry = hlist_entry(chain->first, struct batadv_frag_list_entry, list);\n\thlist_del(&entry->list);\n\tskb_out = entry->skb;\n\tkfree(entry);\n\tif (pskb_expand_head(skb_out, 0, size - skb->len, GFP_ATOMIC) < 0) {\n\t\tkfree_skb(skb_out);\n\t\tskb_out = NULL;\n\t\tgoto free;\n\t}\n\tskb_pull_rcsum(skb_out, hdr_size);\n\tmemmove(skb_out->data - ETH_HLEN, skb_mac_header(skb_out), ETH_HLEN);\n\tskb_set_mac_header(skb_out, -ETH_HLEN);\n\tskb_reset_network_header(skb_out);\n\tskb_reset_transport_header(skb_out);\n\thlist_for_each_entry(entry, chain, list) {\n\t\tsize = entry->skb->len - hdr_size;\n\t\tmemcpy(skb_put(skb_out, size), entry->skb->data + hdr_size,\n\t\t       size);\n\t}\nfree:\n\tbatadv_frag_clear_chain(chain);\n\treturn skb_out;\n}", "target": 1}
{"code": "static TEE_Result do_allocate_keypair(struct dh_keypair *key, size_t size_bits)\n{\n\tDH_TRACE(\"Allocate Keypair of %zu bits\", size_bits);\n\tmemset(key, 0, sizeof(*key));\n\tkey->g = crypto_bignum_allocate(size_bits);\n\tif (!key->g)\n\t\tgoto err;\n\tkey->p = crypto_bignum_allocate(size_bits);\n\tif (!key->p)\n\t\tgoto err;\n\tkey->x = crypto_bignum_allocate(size_bits);\n\tif (!key->x)\n\t\tgoto err;\n\tkey->y = crypto_bignum_allocate(size_bits);\n\tif (!key->y)\n\t\tgoto err;\n\tkey->q = crypto_bignum_allocate(size_bits);\n\tif (!key->q)\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tDH_TRACE(\"Allocation error\");\n\tcrypto_bignum_free(key->g);\n\tcrypto_bignum_free(key->p);\n\tcrypto_bignum_free(key->x);\n\tcrypto_bignum_free(key->y);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "smtp_log_to_file(smtp_t *smtp)\n{\n\tFILE *fp = fopen(\"/tmp/smtp-alert.log\", \"a\");\n\ttime_t now;\n\tstruct tm tm;\n\tchar time_buf[25];\n\tint time_buf_len;\n\ttime(&now);\n\tlocaltime_r(&now, &tm);\n\ttime_buf_len = strftime(time_buf, sizeof time_buf, \"%a %b %e %X %Y\", &tm);\n\tfprintf(fp, \"%s: %s -> %s\\n\"\n\t\t    \"%*sSubject: %s\\n\"\n\t\t    \"%*sBody:    %s\\n\\n\",\n\t\t    time_buf, global_data->email_from, smtp->email_to,\n\t\t    time_buf_len - 7, \"\", smtp->subject,\n\t\t    time_buf_len - 7, \"\", smtp->body);\n\tfclose(fp);\n\tfree_smtp_all(smtp);\n}", "target": 1}
{"code": "static int load_script(struct linux_binprm *bprm)\n{\n\tconst char *i_arg, *i_name;\n\tchar *cp;\n\tstruct file *file;\n\tchar interp[BINPRM_BUF_SIZE];\n\tint retval;\n\tif ((bprm->buf[0] != '#') || (bprm->buf[1] != '!'))\n\t\treturn -ENOEXEC;\n\tallow_write_access(bprm->file);\n\tfput(bprm->file);\n\tbprm->file = NULL;\n\tbprm->buf[BINPRM_BUF_SIZE - 1] = '\\0';\n\tif ((cp = strchr(bprm->buf, '\\n')) == NULL)\n\t\tcp = bprm->buf+BINPRM_BUF_SIZE-1;\n\t*cp = '\\0';\n\twhile (cp > bprm->buf) {\n\t\tcp--;\n\t\tif ((*cp == ' ') || (*cp == '\\t'))\n\t\t\t*cp = '\\0';\n\t\telse\n\t\t\tbreak;\n\t}\n\tfor (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\\t'); cp++);\n\tif (*cp == '\\0') \n\t\treturn -ENOEXEC; \n\ti_name = cp;\n\ti_arg = NULL;\n\tfor ( ; *cp && (*cp != ' ') && (*cp != '\\t'); cp++)\n\t\t ;\n\twhile ((*cp == ' ') || (*cp == '\\t'))\n\t\t*cp++ = '\\0';\n\tif (*cp)\n\t\ti_arg = cp;\n\tstrcpy (interp, i_name);\n\tretval = remove_arg_zero(bprm);\n\tif (retval)\n\t\treturn retval;\n\tretval = copy_strings_kernel(1, &bprm->interp, bprm);\n\tif (retval < 0) return retval; \n\tbprm->argc++;\n\tif (i_arg) {\n\t\tretval = copy_strings_kernel(1, &i_arg, bprm);\n\t\tif (retval < 0) return retval; \n\t\tbprm->argc++;\n\t}\n\tretval = copy_strings_kernel(1, &i_name, bprm);\n\tif (retval) return retval; \n\tbprm->argc++;\n\tbprm->interp = interp;\n\tfile = open_exec(interp);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\tbprm->file = file;\n\tretval = prepare_binprm(bprm);\n\tif (retval < 0)\n\t\treturn retval;\n\treturn search_binary_handler(bprm);\n}", "target": 1}
{"code": "unsigned long get_pfnblock_flags_mask(struct page *page, unsigned long pfn,\n\t\t\t\t\tunsigned long end_bitidx,\n\t\t\t\t\tunsigned long mask)\n{\n\treturn __get_pfnblock_flags_mask(page, pfn, end_bitidx, mask);\n}", "target": 0}
{"code": "static inline int perf_intr_is_nmi(struct pt_regs *regs)\n{\n\treturn !regs->softe;\n}", "target": 0}
{"code": "static const char *cmd_xml_external_entity(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n    if (strcasecmp(p1, \"on\") == 0)  {\n        dcfg->xml_external_entity = 1;\n    }\n    else if (strcasecmp(p1, \"off\") == 0)    {\n        dcfg->xml_external_entity = 0;\n    }\n    else return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecXmlExternalEntity: %s\", p1);\n    return NULL;\n}", "target": 0}
{"code": "fribidi_cap_rtl_to_unicode (\n  const char *s,\n  FriBidiStrIndex len,\n  FriBidiChar *us\n)\n{\n  FriBidiStrIndex i, j;\n  if (!caprtl_to_unicode)\n    init_cap_rtl ();\n  j = 0;\n  for (i = 0; i < len; i++)\n    {\n      char ch;\n      ch = s[i];\n      if (ch == '_')\n\t{\n\t  switch (ch = s[++i])\n\t    {\n\t    case '>':\n\t      us[j++] = FRIBIDI_CHAR_LRM;\n\t      break;\n\t    case '<':\n\t      us[j++] = FRIBIDI_CHAR_RLM;\n\t      break;\n\t    case 'l':\n\t      us[j++] = FRIBIDI_CHAR_LRE;\n\t      break;\n\t    case 'r':\n\t      us[j++] = FRIBIDI_CHAR_RLE;\n\t      break;\n\t    case 'o':\n\t      us[j++] = FRIBIDI_CHAR_PDF;\n\t      break;\n\t    case 'L':\n\t      us[j++] = FRIBIDI_CHAR_LRO;\n\t      break;\n\t    case 'R':\n\t      us[j++] = FRIBIDI_CHAR_RLO;\n\t      break;\n            case 'i':\n              us[j++] = FRIBIDI_CHAR_LRI;\n\t      break;\n            case 'y':\n              us[j++] = FRIBIDI_CHAR_RLI;\n\t      break;\n            case 'f':\n              us[j++] = FRIBIDI_CHAR_FSI;\n\t      break;\n            case 'I':\n              us[j++] = FRIBIDI_CHAR_PDI;\n\t      break;\n\t    case '_':\n\t      us[j++] = '_';\n\t      break;\n\t    default:\n\t      us[j++] = '_';\n\t      i--;\n\t      break;\n\t    }\n\t}\n      else\n\tus[j++] = caprtl_to_unicode[(int) s[i]];\n    }\n  return j;\n}", "target": 1}
{"code": "snmp_ber_encode_unsigned_integer(unsigned char *out, uint32_t *out_len, uint8_t type, uint32_t number)\n{\n  uint32_t original_out_len;\n  original_out_len = *out_len;\n  do {\n    (*out_len)++;\n    *out-- = (uint8_t)(number & 0xFF);\n    number >>= 8;\n  } while(number);\n  out = snmp_ber_encode_length(out, out_len, ((*out_len - original_out_len) & 0xFF));\n  out = snmp_ber_encode_type(out, out_len, type);\n  return out;\n}", "target": 1}
{"code": "MagickExport void *AcquireAlignedMemory(const size_t count,const size_t quantum)\n{\n#define AlignedExtent(size,alignment) \\\n  (((size)+((alignment)-1)) & ~((alignment)-1))\n  size_t\n    alignment,\n    extent,\n    size;\n  void\n    *memory;\n  if (CheckMemoryOverflow(count,quantum) != MagickFalse)\n    return((void *) NULL);\n  memory=NULL;\n  alignment=CACHE_LINE_SIZE;\n  size=count*quantum;\n  extent=AlignedExtent(size,alignment);\n  if ((size == 0) || (alignment < sizeof(void *)) || (extent < size))\n    return((void *) NULL);\n#if defined(MAGICKCORE_HAVE_POSIX_MEMALIGN)\n  if (posix_memalign(&memory,alignment,extent) != 0)\n    memory=NULL;\n#elif defined(MAGICKCORE_HAVE__ALIGNED_MALLOC)\n  memory=_aligned_malloc(extent,alignment);\n#else\n  {\n    void\n      *p;\n    extent=(size+alignment-1)+sizeof(void *);\n    if (extent > size)\n      {\n        p=malloc(extent);\n        if (p != NULL)\n          {\n            memory=(void *) AlignedExtent((size_t) p+sizeof(void *),alignment);\n            *((void **) memory-1)=p;\n          }\n      }\n  }\n#endif\n  return(memory);\n}", "target": 1}
{"code": "static inline int l2cap_config_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)\n{\n\tstruct l2cap_conf_rsp *rsp = (struct l2cap_conf_rsp *)data;\n\tu16 scid, flags, result;\n\tstruct sock *sk;\n\tscid   = __le16_to_cpu(rsp->scid);\n\tflags  = __le16_to_cpu(rsp->flags);\n\tresult = __le16_to_cpu(rsp->result);\n\tBT_DBG(\"scid 0x%4.4x flags 0x%2.2x result 0x%2.2x\",\n\t\t\tscid, flags, result);\n\tsk = l2cap_get_chan_by_scid(&conn->chan_list, scid);\n\tif (!sk)\n\t\treturn 0;\n\tswitch (result) {\n\tcase L2CAP_CONF_SUCCESS:\n\t\tbreak;\n\tcase L2CAP_CONF_UNACCEPT:\n\t\tif (++l2cap_pi(sk)->conf_retry < L2CAP_CONF_MAX_RETRIES) {\n\t\t\tchar req[128];\n\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t\t\t\t\tl2cap_build_conf_req(sk, req), req);\n\t\t\tgoto done;\n\t\t}\n\tdefault:\n\t\tsk->sk_state = BT_DISCONN;\n\t\tsk->sk_err = ECONNRESET;\n\t\tl2cap_sock_set_timer(sk, HZ * 5);\n\t\t{\n\t\t\tstruct l2cap_disconn_req req;\n\t\t\treq.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);\n\t\t\treq.scid = cpu_to_le16(l2cap_pi(sk)->scid);\n\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn),\n\t\t\t\t\tL2CAP_DISCONN_REQ, sizeof(req), &req);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (flags & 0x01)\n\t\tgoto done;\n\tl2cap_pi(sk)->conf_state |= L2CAP_CONF_INPUT_DONE;\n\tif (l2cap_pi(sk)->conf_state & L2CAP_CONF_OUTPUT_DONE) {\n\t\tsk->sk_state = BT_CONNECTED;\n\t\tl2cap_chan_ready(sk);\n\t}\ndone:\n\tbh_unlock_sock(sk);\n\treturn 0;\n}", "target": 1}
{"code": "    bool PamBackend::start(const QString &user) {\n        bool result;\n        QString service = QStringLiteral(\"sddm\");\n        if (user == QStringLiteral(\"sddm\") && m_greeter)\n            service = QStringLiteral(\"sddm-greeter\");\n        else if (m_app->session()->path().isEmpty())\n            service = QStringLiteral(\"sddm-check\");\n        else if (m_autologin)\n            service = QStringLiteral(\"sddm-autologin\");\n        result = m_pam->start(service, user);\n        if (!result)\n            m_app->error(m_pam->errorString(), Auth::ERROR_INTERNAL);\n        return result;\n    }", "target": 1}
{"code": "mwifiex_set_uap_rates(struct mwifiex_uap_bss_param *bss_cfg,\n\t\t      struct cfg80211_ap_settings *params)\n{\n\tstruct ieee_types_header *rate_ie;\n\tint var_offset = offsetof(struct ieee80211_mgmt, u.beacon.variable);\n\tconst u8 *var_pos = params->beacon.head + var_offset;\n\tint len = params->beacon.head_len - var_offset;\n\tu8 rate_len = 0;\n\trate_ie = (void *)cfg80211_find_ie(WLAN_EID_SUPP_RATES, var_pos, len);\n\tif (rate_ie) {\n\t\tmemcpy(bss_cfg->rates, rate_ie + 1, rate_ie->len);\n\t\trate_len = rate_ie->len;\n\t}\n\trate_ie = (void *)cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES,\n\t\t\t\t\t   params->beacon.tail,\n\t\t\t\t\t   params->beacon.tail_len);\n\tif (rate_ie)\n\t\tmemcpy(bss_cfg->rates + rate_len, rate_ie + 1, rate_ie->len);\n\treturn;\n}", "target": 1}
{"code": "device_drive_benchmark (Device *device,\n                        gboolean do_write_benchmark,\n                        char **options,\n                        DBusGMethodInvocation *context)\n{\n  if (!device->priv->device_is_drive)\n    {\n      throw_error (context, ERROR_FAILED, \"Device is not a drive\");\n      goto out;\n    }\n  daemon_local_check_auth (device->priv->daemon,\n                           device,\n                           \"org.freedesktop.udisks.change\",\n                           \"DriveBenchmark\",\n                           TRUE,\n                           device_drive_benchmark_authorized_cb,\n                           context,\n                           2,\n                           GINT_TO_POINTER (do_write_benchmark),\n                           NULL,\n                           g_strdupv (options),\n                           g_strfreev);\n out:\n  return TRUE;\n}", "target": 0}
{"code": "vips_foreign_load_start( VipsImage *out, void *a, void *b )\n{\n\tVipsForeignLoad *load = VIPS_FOREIGN_LOAD( b );\n\tVipsForeignLoadClass *class = VIPS_FOREIGN_LOAD_GET_CLASS( load );\n\tif( !load->real ) {\n\t\tif( !(load->real = vips_foreign_load_temp( load )) )\n\t\t\treturn( NULL );\n#ifdef DEBUG\n\t\tprintf( \"vips_foreign_load_start: triggering ->load()\\n\" );\n#endif \n\t\tload->real->progress_signal = load->out;\n\t\tg_object_set_qdata( G_OBJECT( load->real ), \n\t\t\tvips__foreign_load_operation, load ); \n\t\tif( class->load( load ) ||\n\t\t\tvips_image_pio_input( load->real ) ) \n\t\t\treturn( NULL );\n\t\tif( !vips_foreign_load_iscompat( load->real, out ) )\n\t\t\treturn( NULL );\n\t\tvips_image_pipelinev( load->out, load->out->dhint, \n\t\t\tload->real, NULL );\n\t}\n\treturn( vips_region_new( load->real ) );\n}", "target": 1}
{"code": "void fiin_box_del(GF_Box *s)\n{\n\tFDItemInformationBox *ptr = (FDItemInformationBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->partition_entries) gf_list_del(ptr->partition_entries);\n\tgf_free(ptr);\n}", "target": 0}
{"code": "static int irda_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n\tstruct sock *sk;\n\tstruct irda_sock *self;\n\tif (protocol < 0 || protocol > SK_PROTOCOL_MAX)\n\t\treturn -EINVAL;\n\tif (net != &init_net)\n\t\treturn -EAFNOSUPPORT;\n\tswitch (sock->type) {\n\tcase SOCK_STREAM:     \n\tcase SOCK_SEQPACKET:  \n\tcase SOCK_DGRAM:      \n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\tsk = sk_alloc(net, PF_IRDA, GFP_KERNEL, &irda_proto, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\tself = irda_sk(sk);\n\tpr_debug(\"%s() : self is %p\\n\", __func__, self);\n\tinit_waitqueue_head(&self->query_wait);\n\tswitch (sock->type) {\n\tcase SOCK_STREAM:\n\t\tsock->ops = &irda_stream_ops;\n\t\tself->max_sdu_size_rx = TTP_SAR_DISABLE;\n\t\tbreak;\n\tcase SOCK_SEQPACKET:\n\t\tsock->ops = &irda_seqpacket_ops;\n\t\tself->max_sdu_size_rx = TTP_SAR_UNBOUND;\n\t\tbreak;\n\tcase SOCK_DGRAM:\n\t\tswitch (protocol) {\n#ifdef CONFIG_IRDA_ULTRA\n\t\tcase IRDAPROTO_ULTRA:\n\t\t\tsock->ops = &irda_ultra_ops;\n\t\t\tself->max_data_size = ULTRA_MAX_DATA - LMP_PID_HEADER;\n\t\t\tself->max_header_size = IRDA_MAX_HEADER + LMP_PID_HEADER;\n\t\t\tbreak;\n#endif \n\t\tcase IRDAPROTO_UNITDATA:\n\t\t\tsock->ops = &irda_dgram_ops;\n\t\t\tself->max_sdu_size_rx = TTP_SAR_UNBOUND;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsk_free(sk);\n\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tsk_free(sk);\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\tsock_init_data(sock, sk);\t\n\tsk->sk_family = PF_IRDA;\n\tsk->sk_protocol = protocol;\n\tself->ckey = irlmp_register_client(0, NULL, NULL, NULL);\n\tself->mask.word = 0xffff;\n\tself->rx_flow = self->tx_flow = FLOW_START;\n\tself->nslots = DISCOVERY_DEFAULT_SLOTS;\n\tself->daddr = DEV_ADDR_ANY;\t\n\tself->saddr = 0x0;\t\t\n\treturn 0;\n}", "target": 0}
{"code": "static long pipe_set_size(struct pipe_inode_info *pipe, unsigned long nr_pages)\n{\n\tstruct pipe_buffer *bufs;\n\tif (nr_pages < pipe->nrbufs)\n\t\treturn -EBUSY;\n\tbufs = kcalloc(nr_pages, sizeof(*bufs), GFP_KERNEL | __GFP_NOWARN);\n\tif (unlikely(!bufs))\n\t\treturn -ENOMEM;\n\tif (pipe->nrbufs) {\n\t\tunsigned int tail;\n\t\tunsigned int head;\n\t\ttail = pipe->curbuf + pipe->nrbufs;\n\t\tif (tail < pipe->buffers)\n\t\t\ttail = 0;\n\t\telse\n\t\t\ttail &= (pipe->buffers - 1);\n\t\thead = pipe->nrbufs - tail;\n\t\tif (head)\n\t\t\tmemcpy(bufs, pipe->bufs + pipe->curbuf, head * sizeof(struct pipe_buffer));\n\t\tif (tail)\n\t\t\tmemcpy(bufs + head, pipe->bufs, tail * sizeof(struct pipe_buffer));\n\t}\n\taccount_pipe_buffers(pipe, pipe->buffers, nr_pages);\n\tpipe->curbuf = 0;\n\tkfree(pipe->bufs);\n\tpipe->bufs = bufs;\n\tpipe->buffers = nr_pages;\n\treturn nr_pages * PAGE_SIZE;\n}", "target": 0}
{"code": "RunTerminationHelper(HANDLE console_token, DWORD pid) {\n  WCHAR module_path[MAX_PATH];\n  GetModuleFileNameW(NULL, module_path, _countof(module_path));\n  std::wstring command { module_path };\n  command += L\" --terminate \" + std::to_wstring(pid);\n  STARTUPINFOW startup_info = {};\n  startup_info.cb = sizeof(startup_info);\n  startup_info.lpDesktop = (LPWSTR) L\"winsta0\\\\default\";\n  PROCESS_INFORMATION process_info;\n  if (!CreateProcessAsUserW(console_token,\n        NULL,\n        (LPWSTR) command.c_str(),\n        NULL,\n        NULL,\n        FALSE,\n        CREATE_UNICODE_ENVIRONMENT | DETACHED_PROCESS,\n        NULL,\n        NULL,\n        &startup_info,\n        &process_info)) {\n    return false;\n  }\n  WaitForSingleObject(process_info.hProcess, INFINITE);\n  DWORD exit_code;\n  GetExitCodeProcess(process_info.hProcess, &exit_code);\n  CloseHandle(process_info.hProcess);\n  CloseHandle(process_info.hThread);\n  return exit_code == 0;\n}", "target": 1}
{"code": "static bool isFloat(FormatCode code) { return code >= kFloat && code <= kDouble; }", "target": 0}
{"code": "void test_access(const char *path)\n{\n\tif (access(path, O_RDONLY) >= 0) {\n\t\tfprintf(stderr, \"leak at access of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at access of %s: errno was %d\\n\", path, errno);\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "static int fts3ExprGlobalHitsCb(\n  Fts3Expr *pExpr,                \n  int iPhrase,                    \n  void *pCtx                      \n){\n  MatchInfo *p = (MatchInfo *)pCtx;\n  return sqlite3Fts3EvalPhraseStats(\n      p->pCursor, pExpr, &p->aMatchinfo[3*iPhrase*p->nCol]\n  );\n}", "target": 0}
{"code": "lldpd_alloc_mgmt(int family, void *addrptr, size_t addrsize, u_int32_t iface)\n{\n\tstruct lldpd_mgmt *mgmt;\n\tlog_debug(\"alloc\", \"allocate a new management address (family: %d)\", family);\n\tif (family <= LLDPD_AF_UNSPEC || family >= LLDPD_AF_LAST) {\n\t\terrno = EAFNOSUPPORT;\n\t\treturn NULL;\n\t}\n\tif (addrsize > LLDPD_MGMT_MAXADDRSIZE) {\n\t\terrno = EOVERFLOW;\n\t\treturn NULL;\n\t}\n\tmgmt = calloc(1, sizeof(struct lldpd_mgmt));\n\tif (mgmt == NULL) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\tmgmt->m_family = family;\n\tassert(addrsize <= LLDPD_MGMT_MAXADDRSIZE);\n\tmemcpy(&mgmt->m_addr, addrptr, addrsize);\n\tmgmt->m_addrsize = addrsize;\n\tmgmt->m_iface = iface;\n\treturn mgmt;\n}", "target": 1}
{"code": "static int udf_load_vrs(struct super_block *sb, struct udf_options *uopt,\n\t\t\tint silent, struct kernel_lb_addr *fileset)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tloff_t nsr_off;\n\tif (!sb_set_blocksize(sb, uopt->blocksize)) {\n\t\tif (!silent)\n\t\t\tudf_warn(sb, \"Bad block size\\n\");\n\t\treturn 0;\n\t}\n\tsbi->s_last_block = uopt->lastblock;\n\tif (!uopt->novrs) {\n\t\tnsr_off = udf_check_vsd(sb);\n\t\tif (!nsr_off) {\n\t\t\tif (!silent)\n\t\t\t\tudf_warn(sb, \"No VRS found\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (nsr_off == -1)\n\t\t\tudf_debug(\"Failed to read byte 32768. Assuming open disc. Skipping validity check\\n\");\n\t\tif (!sbi->s_last_block)\n\t\t\tsbi->s_last_block = udf_get_last_block(sb);\n\t} else {\n\t\tudf_debug(\"Validity check skipped because of novrs option\\n\");\n\t}\n\tsbi->s_anchor = uopt->anchor;\n\tif (!udf_find_anchor(sb, fileset)) {\n\t\tif (!silent)\n\t\t\tudf_warn(sb, \"No anchor found\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* axis = GetInput(context, node, 0);\n  TF_LITE_ENSURE(context, axis != nullptr);\n  TF_LITE_ENSURE_MSG(context, IsConstantTensor(axis),\n                     \"Non constant axis tensor not supported\");\n  return kTfLiteOk;\n}", "target": 0}
{"code": "xfs_attr_fork_reset(\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_trans\t*tp)\n{\n\txfs_idestroy_fork(ip, XFS_ATTR_FORK);\n\tip->i_d.di_forkoff = 0;\n\tip->i_d.di_aformat = XFS_DINODE_FMT_EXTENTS;\n\tASSERT(ip->i_d.di_anextents == 0);\n\tASSERT(ip->i_afp == NULL);\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n}", "target": 0}
{"code": "merged_2v_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                   JDIMENSION *in_row_group_ctr,\n                   JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf,\n                   JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  JSAMPROW work_ptrs[2];\n  JDIMENSION num_rows;          \n  if (upsample->spare_full) {\n    JDIMENSION size = upsample->out_row_width;\n    if (cinfo->out_color_space == JCS_RGB565)\n      size = cinfo->output_width * 2;\n    jcopy_sample_rows(&upsample->spare_row, 0, output_buf + *out_row_ctr, 0, 1,\n                      size);\n    num_rows = 1;\n    upsample->spare_full = FALSE;\n  } else {\n    num_rows = 2;\n    if (num_rows > upsample->rows_to_go)\n      num_rows = upsample->rows_to_go;\n    out_rows_avail -= *out_row_ctr;\n    if (num_rows > out_rows_avail)\n      num_rows = out_rows_avail;\n    work_ptrs[0] = output_buf[*out_row_ctr];\n    if (num_rows > 1) {\n      work_ptrs[1] = output_buf[*out_row_ctr + 1];\n    } else {\n      work_ptrs[1] = upsample->spare_row;\n      upsample->spare_full = TRUE;\n    }\n    (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr, work_ptrs);\n  }\n  *out_row_ctr += num_rows;\n  upsample->rows_to_go -= num_rows;\n  if (!upsample->spare_full)\n    (*in_row_group_ctr)++;\n}", "target": 1}
{"code": "static int v2g_incoming_v2gtp(struct v2g_connection* conn) {\n    int rv;\n    rv = connection_read(conn, conn->buffer, V2GTP_HEADER_LENGTH);\n    if (rv < 0) {\n        dlog(DLOG_LEVEL_ERROR, \"connection_read(header) failed: %s\",\n             (rv == -1) ? strerror(errno) : \"connection terminated\");\n        return -1;\n    }\n    if (rv == 0)\n        return 1;\n    if (rv != V2GTP_HEADER_LENGTH) {\n        dlog(DLOG_LEVEL_ERROR, \"connection_read(header) too short: expected %d, got %d\", V2GTP_HEADER_LENGTH, rv);\n        return -1;\n    }\n    rv = read_v2gtpHeader(conn->buffer, &conn->payload_len);\n    if (rv == -1) {\n        dlog(DLOG_LEVEL_ERROR, \"Invalid v2gtp header\");\n        return -1;\n    }\n    if (conn->payload_len + V2GTP_HEADER_LENGTH > DEFAULT_BUFFER_SIZE) {\n        dlog(DLOG_LEVEL_ERROR, \"payload too long: have %d, would need %d\", DEFAULT_BUFFER_SIZE,\n             conn->payload_len + V2GTP_HEADER_LENGTH);\n        return -1;\n    }\n    rv = connection_read(conn, &conn->buffer[V2GTP_HEADER_LENGTH], conn->payload_len);\n    if (rv < 0) {\n        dlog(DLOG_LEVEL_ERROR, \"connection_read(payload) failed: %s\",\n             (rv == -1) ? strerror(errno) : \"connection terminated\");\n        return -1;\n    }\n    if (rv != conn->payload_len) {\n        dlog(DLOG_LEVEL_ERROR, \"connection_read(payload) too short: expected %d, got %d\", conn->payload_len, rv);\n        return -1;\n    }\n    conn->buffer_pos = V2GTP_HEADER_LENGTH;\n    conn->stream.size = conn->payload_len + V2GTP_HEADER_LENGTH;\n    return 0;\n}", "target": 1}
{"code": "static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)\n{\n    long i;\n    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {\n        long a = *(long *)(src1 + i);\n        long b = *(long *)(src2 + i);\n        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);\n    }\n    for (; i < w; i++)\n        dst[i] = src1[i] + src2[i];\n}", "target": 1}
{"code": "std::unique_ptr<BytecodeModule> hbc::generateBytecode(\n    Module *M,\n    raw_ostream &OS,\n    const BytecodeGenerationOptions &options,\n    const SHA1 &sourceHash,\n    hermes::OptValue<uint32_t> segment,\n    SourceMapGenerator *sourceMapGen,\n    std::unique_ptr<BCProviderBase> baseBCProvider) {\n  auto BM = generateBytecodeModule(\n      M,\n      M->getTopLevelFunction(),\n      options,\n      segment,\n      sourceMapGen,\n      std::move(baseBCProvider));\n  if (!BM) {\n    return {};\n  }\n  if (options.format == OutputFormatKind::EmitBundle) {\n    assert(BM != nullptr);\n    BytecodeSerializer BS{OS, options};\n    BS.serialize(*BM, sourceHash);\n  }\n  if (sourceMapGen)\n    BM->populateSourceMap(sourceMapGen);\n  return BM;\n}", "target": 0}
{"code": "void setrangeCommand(client *c) {\n    robj *o;\n    long offset;\n    sds value = c->argv[3]->ptr;\n    if (getLongFromObjectOrReply(c,c->argv[2],&offset,NULL) != C_OK)\n        return;\n    if (offset < 0) {\n        addReplyError(c,\"offset is out of range\");\n        return;\n    }\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (o == NULL) {\n        if (sdslen(value) == 0) {\n            addReply(c,shared.czero);\n            return;\n        }\n        if (checkStringLength(c,offset+sdslen(value)) != C_OK)\n            return;\n        o = createObject(OBJ_STRING,sdsnewlen(NULL, offset+sdslen(value)));\n        dbAdd(c->db,c->argv[1],o);\n    } else {\n        size_t olen;\n        if (checkType(c,o,OBJ_STRING))\n            return;\n        olen = stringObjectLen(o);\n        if (sdslen(value) == 0) {\n            addReplyLongLong(c,olen);\n            return;\n        }\n        if (checkStringLength(c,offset+sdslen(value)) != C_OK)\n            return;\n        o = dbUnshareStringValue(c->db,c->argv[1],o);\n    }\n    if (sdslen(value) > 0) {\n        o->ptr = sdsgrowzero(o->ptr,offset+sdslen(value));\n        memcpy((char*)o->ptr+offset,value,sdslen(value));\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_STRING,\n            \"setrange\",c->argv[1],c->db->id);\n        server.dirty++;\n    }\n    addReplyLongLong(c,sdslen(o->ptr));\n}", "target": 1}
{"code": "int __hnbad(const char *dotted)\n{\n\tunsigned char c, n, *cp;\n\tunsigned char buf[NS_MAXCDNAME];\n\tcp = (unsigned char *)dotted;\n\twhile ((c = *cp++))\n\t\tif (c < 0x21 || c > 0x7E)\n\t\t\treturn (1);\n\tif (ns_name_pton(dotted, buf, sizeof(buf)) < 0)\n\t\treturn (2);\n\tif (buf[0] > 0 && buf[1] == '-')\n\t\treturn (3);\n\tcp = buf;\n\twhile ((n = *cp++)) {\n\t\tif (n > 63)\n\t\t\treturn (4);\n\t\twhile (n--) {\n\t\t\tc = *cp++;\n\t\t\tif (c < '-' ||\n\t\t\t    (c > '-' && c < '0') ||\n\t\t\t    (c > '9' && c < 'A') ||\n\t\t\t    (c > 'Z' && c < '_') ||\n\t\t\t    (c > '_' && c < 'a') ||\n\t\t\t    c > 'z')\n\t\t\t\treturn (5);\n\t\t}\n\t}\n\treturn (0);\n}", "target": 0}
{"code": "static inline pgd_t *pgd_alloc(struct mm_struct *mm)\n{\n\tspin_lock_init(&mm->context.list_lock);\n\tINIT_LIST_HEAD(&mm->context.pgtable_list);\n\tINIT_LIST_HEAD(&mm->context.gmap_list);\n\treturn (pgd_t *) crst_table_alloc(mm);\n}", "target": 1}
{"code": "uint WavInFile::getSampleRate() const\n{\n    return header.format.sample_rate;\n}", "target": 0}
{"code": "void free_pipe_info(struct pipe_inode_info *pipe)\n{\n\tint i;\n\taccount_pipe_buffers(pipe, pipe->buffers, 0);\n\tfree_uid(pipe->user);\n\tfor (i = 0; i < pipe->buffers; i++) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + i;\n\t\tif (buf->ops)\n\t\t\tbuf->ops->release(pipe, buf);\n\t}\n\tif (pipe->tmp_page)\n\t\t__free_page(pipe->tmp_page);\n\tkfree(pipe->bufs);\n\tkfree(pipe);\n}", "target": 0}
{"code": "static int pfkey_recvmsg(struct kiocb *kiocb,\n\t\t\t struct socket *sock, struct msghdr *msg, size_t len,\n\t\t\t int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tstruct sk_buff *skb;\n\tint copied, err;\n\terr = -EINVAL;\n\tif (flags & ~(MSG_PEEK|MSG_DONTWAIT|MSG_TRUNC|MSG_CMSG_COMPAT))\n\t\tgoto out;\n\tmsg->msg_namelen = 0;\n\tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &err);\n\tif (skb == NULL)\n\t\tgoto out;\n\tcopied = skb->len;\n\tif (copied > len) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto out_free;\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\terr = (flags & MSG_TRUNC) ? skb->len : copied;\n\tif (pfk->dump.dump != NULL &&\n\t    3 * atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf)\n\t\tpfkey_do_dump(pfk);\nout_free:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err;\n}", "target": 1}
{"code": "static inline void skb_reset_mac_header(struct sk_buff *skb)\n{\n\tskb->mac_header = skb->data - skb->head;\n}", "target": 0}
{"code": "SQLiteDBInstanceRef SQLiteDBManager::getConnection(bool primary) {\n  auto& self = instance();\n  WriteLock lock(self.create_mutex_);\n  if (self.db_ == nullptr) {\n    openOptimized(self.db_);\n    self.connection_ = SQLiteDBInstanceRef(new SQLiteDBInstance(self.db_));\n    attachVirtualTables(self.connection_);\n  }\n  if (primary) {\n    return self.connection_;\n  }\n  auto instance = std::make_shared<SQLiteDBInstance>(self.db_, self.mutex_);\n  if (!instance->isPrimary()) {\n    attachVirtualTables(instance);\n  }\n  return instance;\n}", "target": 0}
{"code": "ZEND_API int ZEND_FASTCALL shift_left_function(zval *result, zval *op1, zval *op2) \n{\n\tzend_long op1_lval, op2_lval;\n\tconvert_op1_op2_long(op1, op1_lval, op2, op2_lval, result, ZEND_SL, shift_left_function);\n\tif (UNEXPECTED((zend_ulong)op2_lval >= SIZEOF_ZEND_LONG * 8)) {\n\t\tif (EXPECTED(op2_lval > 0)) {\n\t\t\tif (op1 == result) {\n\t\t\t\tzval_ptr_dtor(result);\n\t\t\t}\n\t\t\tZVAL_LONG(result, 0);\n\t\t\treturn SUCCESS;\n\t\t} else {\n\t\t\tif (EG(current_execute_data) && !CG(in_compilation)) {\n\t\t\t\tzend_throw_exception_ex(zend_ce_arithmetic_error, 0, \"Bit shift by negative number\");\n\t\t\t} else {\n\t\t\t\tzend_error_noreturn(E_ERROR, \"Bit shift by negative number\");\n\t\t\t}\n\t\t\tif (op1 != result) {\n\t\t\t\tZVAL_UNDEF(result);\n\t\t\t}\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\tif (op1 == result) {\n\t\tzval_ptr_dtor(result);\n\t}\n\tZVAL_LONG(result, (zend_long) ((zend_ulong) op1_lval << op2_lval));\n\treturn SUCCESS;\n}", "target": 0}
{"code": "  bool AllocatesOpaqueHandle() const override { return true; }", "target": 0}
{"code": "void ntlm_print_av_pair_list(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList)\n{\n\tsize_t cbAvPair = cbAvPairList;\n\tNTLM_AV_PAIR* pAvPair = pAvPairList;\n\tif (!ntlm_av_pair_check(pAvPair, cbAvPair))\n\t\treturn;\n\tWLog_INFO(TAG, \"AV_PAIRs =\");\n\twhile (pAvPair && ntlm_av_pair_get_id(pAvPair) != MsvAvEOL)\n\t{\n\t\tWLog_INFO(TAG, \"\\t%s AvId: %\" PRIu16 \" AvLen: %\" PRIu16 \"\",\n\t\t          AV_PAIR_STRINGS[ntlm_av_pair_get_id(pAvPair)], ntlm_av_pair_get_id(pAvPair),\n\t\t          ntlm_av_pair_get_len(pAvPair));\n\t\twinpr_HexDump(TAG, WLOG_INFO, ntlm_av_pair_get_value_pointer(pAvPair),\n\t\t              ntlm_av_pair_get_len(pAvPair));\n\t\tpAvPair = ntlm_av_pair_next(pAvPair, &cbAvPair);\n\t}\n}", "target": 1}
{"code": "static void my_output_message( j_common_ptr ) {} ", "target": 0}
{"code": "static enum sctp_ierror sctp_process_unk_param(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tunion sctp_params param,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tstruct sctp_chunk **errp)\n{\n\tint retval = SCTP_IERROR_NO_ERROR;\n\tswitch (param.p->type & SCTP_PARAM_ACTION_MASK) {\n\tcase SCTP_PARAM_ACTION_DISCARD:\n\t\tretval =  SCTP_IERROR_ERROR;\n\t\tbreak;\n\tcase SCTP_PARAM_ACTION_SKIP:\n\t\tbreak;\n\tcase SCTP_PARAM_ACTION_DISCARD_ERR:\n\t\tretval =  SCTP_IERROR_ERROR;\n\tcase SCTP_PARAM_ACTION_SKIP_ERR:\n\t\tif (NULL == *errp)\n\t\t\t*errp = sctp_make_op_error_fixed(asoc, chunk);\n\t\tif (*errp) {\n\t\t\tif (!sctp_init_cause_fixed(*errp, SCTP_ERROR_UNKNOWN_PARAM,\n\t\t\t\t\tSCTP_PAD4(ntohs(param.p->length))))\n\t\t\t\tsctp_addto_chunk_fixed(*errp,\n\t\t\t\t\t\tSCTP_PAD4(ntohs(param.p->length)),\n\t\t\t\t\t\tparam.v);\n\t\t} else {\n\t\t\tretval = SCTP_IERROR_NOMEM;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn retval;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* const context) override {\n    core::RefCountPtr<BoostedTreesEnsembleResource> resource;\n    OP_REQUIRES_OK(context, LookupResource(context, HandleFromInput(context, 0),\n                                           &resource));\n    OpInputList bucketized_features_list;\n    OP_REQUIRES_OK(context, context->input_list(\"bucketized_features\",\n                                                &bucketized_features_list));\n    std::vector<tensorflow::TTypes<int32>::ConstMatrix> bucketized_features;\n    bucketized_features.reserve(bucketized_features_list.size());\n    ConvertVectorsToMatrices(bucketized_features_list, bucketized_features);\n    const int batch_size = bucketized_features[0].dimension(0);\n    Tensor* output_logits_t = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                \"logits\", {batch_size, logits_dimension_},\n                                &output_logits_t));\n    auto output_logits = output_logits_t->matrix<float>();\n    if (resource->num_trees() <= 0) {\n      output_logits.setZero();\n      return;\n    }\n    const int32 last_tree = resource->num_trees() - 1;\n    auto do_work = [&resource, &bucketized_features, &output_logits, last_tree,\n                    this](int32 start, int32 end) {\n      for (int32 i = start; i < end; ++i) {\n        std::vector<float> tree_logits(logits_dimension_, 0.0);\n        int32 tree_id = 0;\n        int32 node_id = 0;\n        while (true) {\n          if (resource->is_leaf(tree_id, node_id)) {\n            const float tree_weight = resource->GetTreeWeight(tree_id);\n            const auto& leaf_logits = resource->node_value(tree_id, node_id);\n            DCHECK_EQ(leaf_logits.size(), logits_dimension_);\n            for (int32 j = 0; j < logits_dimension_; ++j) {\n              tree_logits[j] += tree_weight * leaf_logits[j];\n            }\n            if (tree_id == last_tree) {\n              break;\n            }\n            ++tree_id;\n            node_id = 0;\n          } else {\n            node_id =\n                resource->next_node(tree_id, node_id, i, bucketized_features);\n          }\n        }\n        for (int32 j = 0; j < logits_dimension_; ++j) {\n          output_logits(i, j) = tree_logits[j];\n        }\n      }\n    };\n    const int64 cost = (last_tree + 1) * 10;\n    thread::ThreadPool* const worker_threads =\n        context->device()->tensorflow_cpu_worker_threads()->workers;\n    Shard(worker_threads->NumThreads(), worker_threads, batch_size,\n          cost, do_work);\n  }", "target": 1}
{"code": "findoprnd(ITEM *ptr, int32 *pos)\n{\n\tcheck_stack_depth();\n\tif (ptr[*pos].type == VAL || ptr[*pos].type == VALTRUE)\n\t{\n\t\tptr[*pos].left = 0;\n\t\t(*pos)++;\n\t}\n\telse if (ptr[*pos].val == (int32) '!')\n\t{\n\t\tptr[*pos].left = 1;\n\t\t(*pos)++;\n\t\tfindoprnd(ptr, pos);\n\t}\n\telse\n\t{\n\t\tITEM\t   *curitem = &ptr[*pos];\n\t\tint32\t\ttmp = *pos;\n\t\t(*pos)++;\n\t\tfindoprnd(ptr, pos);\n\t\tcuritem->left = *pos - tmp;\n\t\tfindoprnd(ptr, pos);\n\t}\n}", "target": 0}
{"code": "static void ext_session_lock_v1_handle_finished(void *data, struct ext_session_lock_v1 *lock) {\n\tswaylock_log(LOG_ERROR, \"Failed to lock session -- \"\n\t\t\t\"is another lockscreen running?\");\n\texit(2);\n}", "target": 0}
{"code": "TEST(ComparisonsTest,\n     QuantizedInt8GreaterWithBroadcastMultiplierGreaterThanOne) {\n  const float kMin = -127.f;\n  const float kMax = 127.f;\n  std::vector<std::vector<int>> test_shapes = {\n      {6}, {2, 3}, {2, 1, 3}, {1, 3, 1, 2}};\n  for (int i = 0; i < test_shapes.size(); ++i) {\n    ComparisonOpModel model({TensorType_INT8, test_shapes[i], kMin, kMax},\n                            {TensorType_INT8, {}, kMin, kMax}, TensorType_INT8,\n                            BuiltinOperator_GREATER);\n    model.QuantizeAndPopulate<int8_t>(model.input1(),\n                                      {572, -2, -71, 8, 11, 20});\n    model.QuantizeAndPopulate<int8_t>(model.input2(), {8});\n    model.Invoke();\n    EXPECT_THAT(model.GetOutput(),\n                ElementsAre(true, false, false, false, true, true))\n        << \"With shape number \" << i;\n  }\n}", "target": 0}
{"code": "static int newary(struct ipc_namespace *ns, struct ipc_params *params)\n{\n\tint id;\n\tint retval;\n\tstruct sem_array *sma;\n\tint size;\n\tkey_t key = params->key;\n\tint nsems = params->u.nsems;\n\tint semflg = params->flg;\n\tint i;\n\tif (!nsems)\n\t\treturn -EINVAL;\n\tif (ns->used_sems + nsems > ns->sc_semmns)\n\t\treturn -ENOSPC;\n\tsize = sizeof (*sma) + nsems * sizeof (struct sem);\n\tsma = ipc_rcu_alloc(size);\n\tif (!sma) {\n\t\treturn -ENOMEM;\n\t}\n\tmemset (sma, 0, size);\n\tsma->sem_perm.mode = (semflg & S_IRWXUGO);\n\tsma->sem_perm.key = key;\n\tsma->sem_perm.security = NULL;\n\tretval = security_sem_alloc(sma);\n\tif (retval) {\n\t\tipc_rcu_putref(sma);\n\t\treturn retval;\n\t}\n\tid = ipc_addid(&sem_ids(ns), &sma->sem_perm, ns->sc_semmni);\n\tif (id < 0) {\n\t\tsecurity_sem_free(sma);\n\t\tipc_rcu_putref(sma);\n\t\treturn id;\n\t}\n\tns->used_sems += nsems;\n\tsma->sem_base = (struct sem *) &sma[1];\n\tfor (i = 0; i < nsems; i++)\n\t\tINIT_LIST_HEAD(&sma->sem_base[i].sem_pending);\n\tsma->complex_count = 0;\n\tINIT_LIST_HEAD(&sma->sem_pending);\n\tINIT_LIST_HEAD(&sma->list_id);\n\tsma->sem_nsems = nsems;\n\tsma->sem_ctime = get_seconds();\n\tsem_unlock(sma);\n\treturn sma->sem_perm.id;\n}", "target": 1}
{"code": "TEST(TensorSliceReaderTest, MissingTensorData) {\n  const string fname =\n      io::JoinPath(testing::TmpDir(), \"missing_data_checkpoint\");\n  TensorSliceWriter writer(fname, CreateTableTensorSliceBuilder);\n  const int32 data[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n  TF_ASSERT_OK(writer.Add(\"test\", TensorShape({4, 5}),\n                          TensorSlice::ParseOrDie(\"0,2:-\"), data));\n  TF_ASSERT_OK(writer.Finish());\n  MutateSavedTensorSlices(fname, [&](SavedTensorSlices sts) {\n    if (sts.has_data()) {\n      Fill(data, 4, sts.mutable_data()->mutable_data());\n    }\n    return sts.SerializeAsString();\n  });\n  TensorSliceReader reader(fname, OpenTableTensorSliceReader);\n  TF_ASSERT_OK(reader.status());\n  EXPECT_TRUE(reader.HasTensor(\"test\", nullptr, nullptr));\n  std::unique_ptr<Tensor> tensor;\n  EXPECT_FALSE(reader.GetTensor(\"test\", &tensor).ok());\n}", "target": 0}
{"code": "my_bool STDCALL mysql_stmt_free_result(MYSQL_STMT *stmt)\n{\n  DBUG_ENTER(\"mysql_stmt_free_result\");\n  DBUG_RETURN(reset_stmt_handle(stmt, RESET_LONG_DATA | RESET_STORE_RESULT |\n                                RESET_CLEAR_ERROR));\n}", "target": 0}
{"code": "static bool is_allowed_security_type(const struct nvnc* server, uint8_t type)\n{\n\tfor (int i = 0; i < server->n_security_types; ++i) {\n\t\tif ((uint8_t)server->security_types[i] == type) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 0}
{"code": "ldbm_config_search_entry_callback(Slapi_PBlock *pb __attribute__((unused)),\n                                  Slapi_Entry *e,\n                                  Slapi_Entry *entryAfter __attribute__((unused)),\n                                  int *returncode,\n                                  char *returntext,\n                                  void *arg)\n{\n    char buf[BUFSIZ];\n    struct berval *vals[2];\n    struct berval val;\n    struct ldbminfo *li = (struct ldbminfo *)arg;\n    config_info *config;\n    int scope;\n    vals[0] = &val;\n    vals[1] = NULL;\n    returntext[0] = '\\0';\n    PR_Lock(li->li_config_mutex);\n    if (pb) {\n        slapi_pblock_get(pb, SLAPI_SEARCH_SCOPE, &scope);\n        if (scope == LDAP_SCOPE_BASE) {\n            char **attrs = NULL;\n            slapi_pblock_get(pb, SLAPI_SEARCH_ATTRS, &attrs);\n            if (attrs) {\n                for (size_t i = 0; attrs[i]; i++) {\n                    if (ldbm_config_moved_attr(attrs[i])) {\n                        slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, \"at least one required attribute has been moved to the BDB scecific configuration entry\");\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    for (config = ldbm_config; config->config_name != NULL; config++) {\n        if (!(config->config_flags & (CONFIG_FLAG_ALWAYS_SHOW | CONFIG_FLAG_PREVIOUSLY_SET))) {\n            continue;\n        }\n        ldbm_config_get((void *)li, config, buf);\n        val.bv_val = buf;\n        val.bv_len = strlen(buf);\n        slapi_entry_attr_replace(e, config->config_name, vals);\n    }\n    PR_Unlock(li->li_config_mutex);\n    *returncode = LDAP_SUCCESS;\n    return SLAPI_DSE_CALLBACK_OK;\n}", "target": 1}
{"code": "static int IsDigit(int enc ARG_UNUSED, int c)\n{\n  if (c >= 0x30 && c <= 0x39) return 1;\n  return 0;\n}", "target": 0}
{"code": "static Jsi_RC jsi_ArrayIndexSubCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr, int op) {\n    int istart = 0, n, i = 0, dir=1, idx=-1;\n    Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, 0),\n        *start = Jsi_ValueArrayIndex(interp, args, 1);\n    Jsi_Obj *obj = _this->d.obj;\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    if (!seq) {\n        goto bail;\n    }\n    n = Jsi_ObjGetLength(interp, obj);    \n    if (n == 0) {\n        goto bail;\n    }\n    Jsi_Number nstart;\n    if (op == 2) {\n        istart = n-1;\n    }\n    if (start && Jsi_GetNumberFromValue(interp,start, &nstart)==JSI_OK) {\n        istart = (int)nstart;\n        if (istart > n)\n            goto bail;\n        if (istart < 0)\n            istart = (n+istart);\n        if (istart<0)\n            goto bail;\n    }\n    if (op == 2) {\n        istart = n-1;\n        dir = -1;\n    }\n    Jsi_ObjListifyArray(interp, obj);\n    for (i = istart; ; i+=dir)\n    {\n        if ((dir>0 && i>=n) || (dir<0 && i<0) || i>=(int)obj->arrCnt)\n            break;\n        if (obj->arr[i] && Jsi_ValueCmp(interp, obj->arr[i], seq, JSI_CMP_EXACT)==0) {\n            idx = i;\n            break;\n        }\n    }\nbail:\n    if (op == 3)\n        Jsi_ValueMakeBool(interp, ret, (idx!=-1));\n    else\n        Jsi_ValueMakeNumber(interp, ret, idx);\n    return JSI_OK;\n}", "target": 1}
{"code": "void rose_start_heartbeat(struct sock *sk)\n{\n\tdel_timer(&sk->sk_timer);\n\tsk->sk_timer.function = rose_heartbeat_expiry;\n\tsk->sk_timer.expires  = jiffies + 5 * HZ;\n\tadd_timer(&sk->sk_timer);\n}", "target": 1}
{"code": "static int ReadHuffmanCode(int alphabet_size, VP8LDecoder* const dec,\n                           int* const code_lengths, HuffmanCode* const table) {\n  int ok = 0;\n  int size = 0;\n  VP8LBitReader* const br = &dec->br_;\n  const int simple_code = VP8LReadBits(br, 1);\n  memset(code_lengths, 0, alphabet_size * sizeof(*code_lengths));\n  if (simple_code) {  \n    const int num_symbols = VP8LReadBits(br, 1) + 1;\n    const int first_symbol_len_code = VP8LReadBits(br, 1);\n    int symbol = VP8LReadBits(br, (first_symbol_len_code == 0) ? 1 : 8);\n    code_lengths[symbol] = 1;\n    if (num_symbols == 2) {\n      symbol = VP8LReadBits(br, 8);\n      code_lengths[symbol] = 1;\n    }\n    ok = 1;\n  } else {  \n    int i;\n    int code_length_code_lengths[NUM_CODE_LENGTH_CODES] = { 0 };\n    const int num_codes = VP8LReadBits(br, 4) + 4;\n    assert(num_codes <= NUM_CODE_LENGTH_CODES);\n    for (i = 0; i < num_codes; ++i) {\n      code_length_code_lengths[kCodeLengthCodeOrder[i]] = VP8LReadBits(br, 3);\n    }\n    ok = ReadHuffmanCodeLengths(dec, code_length_code_lengths, alphabet_size,\n                                code_lengths);\n  }\n  ok = ok && !br->eos_;\n  if (ok) {\n    size = VP8LBuildHuffmanTable(table, HUFFMAN_TABLE_BITS,\n                                 code_lengths, alphabet_size);\n  }\n  if (!ok || size == 0) {\n    return VP8LSetError(dec, VP8_STATUS_BITSTREAM_ERROR);\n  }\n  return size;\n}", "target": 1}
{"code": "static inline Quantum ScaleLongLongToQuantum(const MagickSizeType value)\n{\n  return((Quantum) (value));\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, NonPrefixRegexOrCovering) {\n    addIndex(BSON(\"a\" << 1));\n    runQuerySortProj(\n        fromjson(\"{$or: [{a: /0/}, {a: /1/}]}\"), BSONObj(), fromjson(\"{_id: 0, a: 1}\"));\n    ASSERT_EQUALS(getNumSolutions(), 2U);\n    assertSolutionExists(\n        \"{proj: {spec: {_id: 0, a: 1}, node: \"\n        \"{cscan: {dir: 1, filter: {$or: [{a: /0/}, {a: /1/}]}}}}}\");\n    assertSolutionExists(\n        \"{proj: {spec: {_id: 0, a: 1}, node: \"\n        \"{ixscan: {filter: {$or: [{a: /0/}, {a: /1/}]}, pattern: {a: 1}}}}}\");\n}", "target": 0}
{"code": "static int crypto_ahash_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_hash rhash;\n\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"ahash\");\n\trhash.blocksize = alg->cra_blocksize;\n\trhash.digestsize = __crypto_hash_alg_common(alg)->digestsize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_HASH,\n\t\t    sizeof(struct crypto_report_hash), &rhash))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "char *strdup(const char *s1)\n{\n\tchar *s2 = 0;\n\tif (s1) {\n\t\ts2 = malloc(strlen(s1) + 1);\n\t\tstrcpy(s2, s1);\n\t}\n\treturn s2;\n}", "target": 1}
{"code": "static php_mb_regex_t *php_mbregex_compile_pattern(const char *pattern, int patlen, OnigOptionType options, OnigEncoding enc, OnigSyntaxType *syntax TSRMLS_DC)\n{\n\tint err_code = 0;\n\tint found = 0;\n\tphp_mb_regex_t *retval = NULL, **rc = NULL;\n\tOnigErrorInfo err_info;\n\tOnigUChar err_str[ONIG_MAX_ERROR_MESSAGE_LEN];\n\tfound = zend_hash_find(&MBREX(ht_rc), (char *)pattern, patlen+1, (void **) &rc);\n\tif (found == FAILURE || (*rc)->options != options || (*rc)->enc != enc || (*rc)->syntax != syntax) {\n\t\tif ((err_code = onig_new(&retval, (OnigUChar *)pattern, (OnigUChar *)(pattern + patlen), options, enc, syntax, &err_info)) != ONIG_NORMAL) {\n\t\t\tonig_error_code_to_str(err_str, err_code, err_info);\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"mbregex compile err: %s\", err_str);\n\t\t\tretval = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tzend_hash_update(&MBREX(ht_rc), (char *) pattern, patlen + 1, (void *) &retval, sizeof(retval), NULL);\n\t} else if (found == SUCCESS) {\n\t\tretval = *rc;\n\t}\nout:\n\treturn retval; \n}", "target": 1}
{"code": "apply_all_case_fold(OnigCaseFoldType flag,\n\t\t    OnigApplyAllCaseFoldFunc f, void* arg,\n\t\t    OnigEncoding enc ARG_UNUSED)\n{\n  return onigenc_apply_all_case_fold_with_map(\n             sizeof(CaseFoldMap)/sizeof(OnigPairCaseFoldCodes), CaseFoldMap, 1,\n             flag, f, arg);\n}", "target": 0}
{"code": "static bool nf_generic_should_process(u8 proto)\n{\n\tswitch (proto) {\n#ifdef CONFIG_NF_CT_PROTO_SCTP_MODULE\n\tcase IPPROTO_SCTP:\n\t\treturn false;\n#endif\n#ifdef CONFIG_NF_CT_PROTO_DCCP_MODULE\n\tcase IPPROTO_DCCP:\n\t\treturn false;\n#endif\n#ifdef CONFIG_NF_CT_PROTO_GRE_MODULE\n\tcase IPPROTO_GRE:\n\t\treturn false;\n#endif\n#ifdef CONFIG_NF_CT_PROTO_UDPLITE_MODULE\n\tcase IPPROTO_UDPLITE:\n\t\treturn false;\n#endif\n\tdefault:\n\t\treturn true;\n\t}\n}", "target": 0}
{"code": "std::string TarFileReader::extract(const string &_path) {\n  if (_path.empty()) THROW(\"path cannot be empty\");\n  if (!hasMore()) THROW(\"No more tar files\");\n  string path = _path;\n  if (SystemUtilities::isDirectory(path)) path += \"/\" + getFilename();\n  LOG_DEBUG(5, \"Extracting: \" << path);\n  return extract(*SystemUtilities::oopen(path));\n}", "target": 1}
{"code": "suffix_requires_dir_check (char const *end)\n{\n  while (ISSLASH (*end))\n    {\n      do\n        end++;\n      while (ISSLASH (*end));\n      switch (*end++)\n        {\n        default: return false;  \n        case '\\0': return true; \n        case '.': break;        \n        }\n      if (!*end || (*end == '.' && (!end[1] || ISSLASH (end[1]))))\n        return true;\n    }\n  return false;\n}", "target": 0}
{"code": "static void test_bug17512527()\n{\n  MYSQL *conn1, *conn2;\n  MYSQL_STMT *stmt1, *stmt2;\n  const char *stmt1_txt= \"SELECT NOW();\";\n  const char *stmt2_txt= \"SELECT 1;\";\n  unsigned long thread_id;\n  char query[MAX_TEST_QUERY_LENGTH];\n  int rc;\n  conn1= client_connect(0, MYSQL_PROTOCOL_DEFAULT, 1);\n  conn2= client_connect(0, MYSQL_PROTOCOL_DEFAULT, 0);\n  stmt1 = mysql_stmt_init(conn1);\n  check_stmt(stmt1);\n  rc= mysql_stmt_prepare(stmt1, stmt1_txt, strlen(stmt1_txt));\n  check_execute(stmt1, rc);\n  thread_id= mysql_thread_id(conn1);\n  sprintf(query, \"KILL %lu\", thread_id);\n  if (thread_query(query))\n    exit(1);\n  stmt2 = mysql_stmt_init(conn1);\n  check_stmt(stmt2);\n  rc= mysql_stmt_prepare(stmt2, stmt2_txt, strlen(stmt2_txt));\n  check_execute(stmt1, rc);\n  mysql_stmt_close(stmt2);\n  mysql_stmt_close(stmt1);\n  mysql_close(conn1);\n  mysql_close(conn2);\n}", "target": 0}
{"code": "static int update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, nfs4_stateid *delegation, int open_flags)\n{\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_delegation *deleg_cur;\n\tint ret = 0;\n\topen_flags &= (FMODE_READ|FMODE_WRITE);\n\trcu_read_lock();\n\tdeleg_cur = rcu_dereference(nfsi->delegation);\n\tif (deleg_cur == NULL)\n\t\tgoto no_delegation;\n\tspin_lock(&deleg_cur->lock);\n\tif (nfsi->delegation != deleg_cur ||\n\t    (deleg_cur->type & open_flags) != open_flags)\n\t\tgoto no_delegation_unlock;\n\tif (delegation == NULL)\n\t\tdelegation = &deleg_cur->stateid;\n\telse if (memcmp(deleg_cur->stateid.data, delegation->data, NFS4_STATEID_SIZE) != 0)\n\t\tgoto no_delegation_unlock;\n\tnfs_mark_delegation_referenced(deleg_cur);\n\t__update_open_stateid(state, open_stateid, &deleg_cur->stateid, open_flags);\n\tret = 1;\nno_delegation_unlock:\n\tspin_unlock(&deleg_cur->lock);\nno_delegation:\n\trcu_read_unlock();\n\tif (!ret && open_stateid != NULL) {\n\t\t__update_open_stateid(state, open_stateid, NULL, open_flags);\n\t\tret = 1;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "ikev2_sub_print(netdissect_options *ndo,\n\t\tstruct isakmp *base,\n\t\tu_char np, const struct isakmp_gen *ext, const u_char *ep,\n\t\tuint32_t phase, uint32_t doi, uint32_t proto, int depth)\n{\n\tconst u_char *cp;\n\tint i;\n\tstruct isakmp_gen e;\n\tcp = (const u_char *)ext;\n\twhile (np) {\n\t\tND_TCHECK(*ext);\n\t\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\t\tND_TCHECK2(*ext, ntohs(e.len));\n\t\tdepth++;\n\t\tND_PRINT((ndo,\"\\n\"));\n\t\tfor (i = 0; i < depth; i++)\n\t\t\tND_PRINT((ndo,\"    \"));\n\t\tND_PRINT((ndo,\"(\"));\n\t\tcp = ikev2_sub0_print(ndo, base, np,\n\t\t\t\t      ext, ep, phase, doi, proto, depth);\n\t\tND_PRINT((ndo,\")\"));\n\t\tdepth--;\n\t\tif (cp == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t\tnp = e.np;\n\t\text = (const struct isakmp_gen *)cp;\n\t}\n\treturn cp;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(np)));\n\treturn NULL;\n}", "target": 1}
{"code": "rpl_dio_printopt(netdissect_options *ndo,\n                 const struct rpl_dio_genoption *opt,\n                 u_int length)\n{\n        if(length < RPL_DIO_GENOPTION_LEN) return;\n        length -= RPL_DIO_GENOPTION_LEN;\n        ND_TCHECK(opt->rpl_dio_len);\n        while((opt->rpl_dio_type == RPL_OPT_PAD0 &&\n               (const u_char *)opt < ndo->ndo_snapend) ||\n              ND_TTEST2(*opt,(opt->rpl_dio_len+2))) {\n                unsigned int optlen = opt->rpl_dio_len+2;\n                if(opt->rpl_dio_type == RPL_OPT_PAD0) {\n                        optlen = 1;\n                        ND_PRINT((ndo, \" opt:pad0\"));\n                } else {\n                        ND_PRINT((ndo, \" opt:%s len:%u \",\n                                  tok2str(rpl_subopt_values, \"subopt:%u\", opt->rpl_dio_type),\n                                  optlen));\n                        if(ndo->ndo_vflag > 2) {\n                                unsigned int paylen = opt->rpl_dio_len;\n                                if(paylen > length) paylen = length;\n                                hex_print(ndo,\n                                          \" \",\n                                          ((const uint8_t *)opt) + RPL_DIO_GENOPTION_LEN,  \n                                          paylen);\n                        }\n                }\n                opt = (const struct rpl_dio_genoption *)(((const char *)opt) + optlen);\n                length -= optlen;\n        }\n        return;\ntrunc:\n\tND_PRINT((ndo,\" [|truncated]\"));\n\treturn;\n}", "target": 1}
{"code": "strncat_from_utf8_libarchive2(struct archive_string *as,\n    const void *_p, size_t len, struct archive_string_conv *sc)\n{\n\tconst char *s;\n\tint n;\n\tchar *p;\n\tchar *end;\n\tuint32_t unicode;\n#if HAVE_WCRTOMB\n\tmbstate_t shift_state;\n\tmemset(&shift_state, 0, sizeof(shift_state));\n#else\n\twctomb(NULL, L'\\0');\n#endif\n\t(void)sc; \n\tif (archive_string_ensure(as, as->length + len + 1) == NULL)\n\t\treturn (-1);\n\ts = (const char *)_p;\n\tp = as->s + as->length;\n\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n\twhile ((n = _utf8_to_unicode(&unicode, s, len)) != 0) {\n\t\twchar_t wc;\n\t\tif (p >= end) {\n\t\t\tas->length = p - as->s;\n\t\t\tif (archive_string_ensure(as,\n\t\t\t    as->length + len * 2 + 1) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tp = as->s + as->length;\n\t\t\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n\t\t}\n\t\tif (n < 0) {\n\t\t\tn *= -1;\n\t\t\twc = L'?';\n\t\t} else\n\t\t\twc = (wchar_t)unicode;\n\t\ts += n;\n\t\tlen -= n;\n#if HAVE_WCRTOMB\n\t\tn = (int)wcrtomb(p, wc, &shift_state);\n#else\n\t\tn = (int)wctomb(p, wc);\n#endif\n\t\tif (n == -1)\n\t\t\treturn (-1);\n\t\tp += n;\n\t}\n\tas->length = p - as->s;\n\tas->s[as->length] = '\\0';\n\treturn (0);\n}", "target": 1}
{"code": "void RenderWidgetHostViewAura::UpdateExternalTexture() {\n  if (accelerated_compositing_state_changed_)\n    accelerated_compositing_state_changed_ = false;\n  bool is_compositing_active = host_->is_accelerated_compositing_active();\n  if (is_compositing_active && current_surface_.get()) {\n    window_->layer()->SetExternalTexture(current_surface_.get());\n    current_frame_size_ = ConvertSizeToDIP(\n        current_surface_->device_scale_factor(), current_surface_->size());\n    CheckResizeLock();\n    software_frame_manager_->DiscardCurrentFrame();\n  } else if (is_compositing_active &&\n             software_frame_manager_->HasCurrentFrame()) {\n    cc::TextureMailbox mailbox;\n    scoped_ptr<cc::SingleReleaseCallback> callback;\n    software_frame_manager_->GetCurrentFrameMailbox(&mailbox, &callback);\n    window_->layer()->SetTextureMailbox(mailbox,\n                                        callback.Pass(),\n                                        last_swapped_surface_scale_factor_);\n    current_frame_size_ = ConvertSizeToDIP(last_swapped_surface_scale_factor_,\n                                           mailbox.shared_memory_size());\n    CheckResizeLock();\n  } else {\n    window_->layer()->SetShowPaintedContent();\n    resize_lock_.reset();\n    host_->WasResized();\n    software_frame_manager_->DiscardCurrentFrame();\n  }\n}", "target": 0}
{"code": "static bool add_ref_to_table_cond(THD *thd, JOIN_TAB *join_tab)\n{\n  DBUG_ENTER(\"add_ref_to_table_cond\");\n  if (!join_tab->ref.key_parts)\n    DBUG_RETURN(FALSE);\n  Item_cond_and *cond= new (thd->mem_root) Item_cond_and(thd);\n  TABLE *table=join_tab->table;\n  int error= 0;\n  if (!cond)\n    DBUG_RETURN(TRUE);\n  for (uint i=0 ; i < join_tab->ref.key_parts ; i++)\n  {\n    Field *field=table->field[table->key_info[join_tab->ref.key].key_part[i].\n\t\t\t      fieldnr-1];\n    Item *value=join_tab->ref.items[i];\n    cond->add(new (thd->mem_root)\n              Item_func_equal(thd, new (thd->mem_root) Item_field(thd, field),\n                              value),\n              thd->mem_root);\n  }\n  if (thd->is_fatal_error)\n    DBUG_RETURN(TRUE);\n  if (!cond->fixed)\n  {\n    Item *tmp_item= (Item*) cond;\n    cond->fix_fields(thd, &tmp_item);\n    DBUG_ASSERT(cond == tmp_item);\n  }\n  if (join_tab->select)\n  {\n    Item *UNINIT_VAR(cond_copy);\n    if (join_tab->select->pre_idx_push_select_cond)\n      cond_copy= cond->copy_andor_structure(thd);\n    if (join_tab->select->cond)\n      error=(int) cond->add(join_tab->select->cond, thd->mem_root);\n    join_tab->select->cond= cond;\n    if (join_tab->select->pre_idx_push_select_cond)\n    {\n      Item *new_cond= and_conds(thd, cond_copy,\n                                join_tab->select->pre_idx_push_select_cond);\n      if (!new_cond->fixed && new_cond->fix_fields(thd, &new_cond))\n        error= 1;\n      join_tab->pre_idx_push_select_cond=\n        join_tab->select->pre_idx_push_select_cond= new_cond;\n    }\n    join_tab->set_select_cond(cond, __LINE__);\n  }\n  else if ((join_tab->select= make_select(join_tab->table, 0, 0, cond,\n                                          (SORT_INFO*) 0, 0, &error)))\n    join_tab->set_select_cond(cond, __LINE__);\n  DBUG_RETURN(error ? TRUE : FALSE);\n}", "target": 0}
{"code": "BOOL update_recv(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc = FALSE;\n\tUINT16 updateType;\n\trdpContext* context = update->context;\n\tif (Stream_GetRemainingLength(s) < 2)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 2\");\n\t\treturn FALSE;\n\t}\n\tStream_Read_UINT16(s, updateType); \n\tWLog_Print(update->log, WLOG_TRACE, \"%s Update Data PDU\", UPDATE_TYPE_STRINGS[updateType]);\n\tif (!update_begin_paint(update))\n\t\tgoto fail;\n\tswitch (updateType)\n\t{\n\t\tcase UPDATE_TYPE_ORDERS:\n\t\t\trc = update_recv_orders(update, s);\n\t\t\tbreak;\n\t\tcase UPDATE_TYPE_BITMAP:\n\t\t{\n\t\t\tBITMAP_UPDATE* bitmap_update = update_read_bitmap_update(update, s);\n\t\t\tif (!bitmap_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_BITMAP - update_read_bitmap_update() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\trc = IFCALLRESULT(FALSE, update->BitmapUpdate, context, bitmap_update);\n\t\t\tfree_bitmap_update(update->context, bitmap_update);\n\t\t}\n\t\tbreak;\n\t\tcase UPDATE_TYPE_PALETTE:\n\t\t{\n\t\t\tPALETTE_UPDATE* palette_update = update_read_palette(update, s);\n\t\t\tif (!palette_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_PALETTE - update_read_palette() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\trc = IFCALLRESULT(FALSE, update->Palette, context, palette_update);\n\t\t\tfree_palette_update(context, palette_update);\n\t\t}\n\t\tbreak;\n\t\tcase UPDATE_TYPE_SYNCHRONIZE:\n\t\t\tupdate_read_synchronize(update, s);\n\t\t\trc = IFCALLRESULT(TRUE, update->Synchronize, context);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\nfail:\n\tif (!update_end_paint(update))\n\t\trc = FALSE;\n\tif (!rc)\n\t{\n\t\tWLog_ERR(TAG, \"UPDATE_TYPE %s [%\" PRIu16 \"] failed\", update_type_to_string(updateType),\n\t\t         updateType);\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "static int asymmetric_key_match_preparse(struct key_match_data *match_data)\n{\n\tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n\tmatch_data->cmp = asymmetric_key_cmp;\n\treturn 0;\n}", "target": 0}
{"code": "monitor_apply_keystate(struct monitor *pmonitor)\n{\n\tstruct ssh *ssh = active_state;\t\n\tstruct kex *kex;\n\tint r;\n\tdebug3(\"%s: packet_set_state\", __func__);\n\tif ((r = ssh_packet_set_state(ssh, child_state)) != 0)\n                fatal(\"%s: packet_set_state: %s\", __func__, ssh_err(r));\n\tsshbuf_free(child_state);\n\tchild_state = NULL;\n\tif ((kex = ssh->kex) != NULL) {\n#ifdef WITH_OPENSSL\n\t\tkex->kex[KEX_DH_GRP1_SHA1] = kexdh_server;\n\t\tkex->kex[KEX_DH_GRP14_SHA1] = kexdh_server;\n\t\tkex->kex[KEX_DH_GRP14_SHA256] = kexdh_server;\n\t\tkex->kex[KEX_DH_GRP16_SHA512] = kexdh_server;\n\t\tkex->kex[KEX_DH_GRP18_SHA512] = kexdh_server;\n\t\tkex->kex[KEX_DH_GEX_SHA1] = kexgex_server;\n\t\tkex->kex[KEX_DH_GEX_SHA256] = kexgex_server;\n\t\tkex->kex[KEX_ECDH_SHA2] = kexecdh_server;\n#endif\n\t\tkex->kex[KEX_C25519_SHA256] = kexc25519_server;\n\t\tkex->load_host_public_key=&get_hostkey_public_by_type;\n\t\tkex->load_host_private_key=&get_hostkey_private_by_type;\n\t\tkex->host_key_index=&get_hostkey_index;\n\t\tkex->sign = sshd_hostkey_sign;\n\t}\n\tif (options.compression) {\n\t\tssh_packet_set_compress_hooks(ssh, pmonitor->m_zlib,\n\t\t    (ssh_packet_comp_alloc_func *)mm_zalloc,\n\t\t    (ssh_packet_comp_free_func *)mm_zfree);\n\t}\n}", "target": 1}
{"code": "static int rr_handle_error(READ_RECORD *info, int error)\n{\n  if (info->thd->killed)\n  {\n    info->thd->send_kill_message();\n    return 1;\n  }\n  if (error == HA_ERR_END_OF_FILE)\n    error= -1;\n  else\n  {\n    if (info->print_error)\n      info->table->file->print_error(error, MYF(0));\n    if (error < 0)                            \n      error= 1;\n  }\n  return error;\n}", "target": 0}
{"code": "struct bpf_prog *bpf_prog_inc(struct bpf_prog *prog)\n{\n\tif (atomic_inc_return(&prog->aux->refcnt) > BPF_MAX_REFCNT) {\n\t\tatomic_dec(&prog->aux->refcnt);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\treturn prog;\n}", "target": 0}
{"code": "void Shell::DeleteInstance() {\n  delete instance_;\n  instance_ = nullptr;\n}", "target": 0}
{"code": "static void bnx2x_hw_enable_status(struct bnx2x *bp)\n{\n\tu32 val;\n\tval = REG_RD(bp, CFC_REG_WEAK_ENABLE_PF);\n\tDP(BNX2X_MSG_SP, \"CFC_REG_WEAK_ENABLE_PF is 0x%x\\n\", val);\n\tval = REG_RD(bp, PBF_REG_DISABLE_PF);\n\tDP(BNX2X_MSG_SP, \"PBF_REG_DISABLE_PF is 0x%x\\n\", val);\n\tval = REG_RD(bp, IGU_REG_PCI_PF_MSI_EN);\n\tDP(BNX2X_MSG_SP, \"IGU_REG_PCI_PF_MSI_EN is 0x%x\\n\", val);\n\tval = REG_RD(bp, IGU_REG_PCI_PF_MSIX_EN);\n\tDP(BNX2X_MSG_SP, \"IGU_REG_PCI_PF_MSIX_EN is 0x%x\\n\", val);\n\tval = REG_RD(bp, IGU_REG_PCI_PF_MSIX_FUNC_MASK);\n\tDP(BNX2X_MSG_SP, \"IGU_REG_PCI_PF_MSIX_FUNC_MASK is 0x%x\\n\", val);\n\tval = REG_RD(bp, PGLUE_B_REG_SHADOW_BME_PF_7_0_CLR);\n\tDP(BNX2X_MSG_SP, \"PGLUE_B_REG_SHADOW_BME_PF_7_0_CLR is 0x%x\\n\", val);\n\tval = REG_RD(bp, PGLUE_B_REG_FLR_REQUEST_PF_7_0_CLR);\n\tDP(BNX2X_MSG_SP, \"PGLUE_B_REG_FLR_REQUEST_PF_7_0_CLR is 0x%x\\n\", val);\n\tval = REG_RD(bp, PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER);\n\tDP(BNX2X_MSG_SP, \"PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER is 0x%x\\n\",\n\t   val);\n}", "target": 0}
{"code": "    Value::UniquePtr Xmpdatum::getValue() const\n    {\n        return p_->value_.get() == 0 ? nullptr : p_->value_->clone();\n    }", "target": 0}
{"code": "Variant HHVM_FUNCTION(mcrypt_get_block_size, const String& cipher,\n                                    const Variant& module ) {\n  MCRYPT td = mcrypt_module_open((char*)cipher.data(),\n                                 (char*)MCG(algorithms_dir).data(),\n                                 (char*)module.asCStrRef().data(),\n                                 (char*)MCG(modes_dir).data());\n  if (td == MCRYPT_FAILED) {\n    MCRYPT_OPEN_MODULE_FAILED(\"mcrypt_get_block_size\");\n    return false;\n  }\n  int64_t ret = mcrypt_enc_get_block_size(td);\n  mcrypt_module_close(td);\n  return ret;\n}", "target": 1}
{"code": "    void setPrivate(bool p) { is_private = p; }", "target": 0}
{"code": "int wvlan_set_station_nickname(struct net_device *dev,\n\t\t      struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu,\n\t\t      char *extra)\n{\n\tstruct wl_private *lp = wl_priv(dev);\n\tunsigned long flags;\n\tint         ret = 0;\n\tDBG_FUNC(\"wvlan_set_station_nickname\");\n\tDBG_ENTER(DbgInfo);\n\twl_lock(lp, &flags);\n\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\tmemcpy(lp->StationName, extra, wrqu->data.length);\n\twl_apply(lp);\n\twl_unlock(lp, &flags);\n\tDBG_LEAVE(DbgInfo);\n\treturn ret;\n} ", "target": 1}
{"code": "    TiffIfdMakernote::TiffIfdMakernote(uint16_t  tag,\n                                       IfdId     group,\n                                       IfdId     mnGroup,\n                                       MnHeader* pHeader,\n                                       bool      hasNext)\n        : TiffComponent(tag, group),\n          pHeader_(pHeader),\n          ifd_(tag, mnGroup, hasNext),\n          mnOffset_(0),\n          imageByteOrder_(invalidByteOrder)\n    {\n    }", "target": 0}
{"code": "  static Handle<Value> Reinitialize(const Arguments& args) {\n    HandleScope scope;\n    http_parser_type type =\n        static_cast<http_parser_type>(args[0]->Int32Value());\n    if (type != HTTP_REQUEST && type != HTTP_RESPONSE) {\n      return ThrowException(Exception::Error(String::New(\n          \"Argument must be HTTPParser.REQUEST or HTTPParser.RESPONSE\")));\n    }\n    Parser* parser = ObjectWrap::Unwrap<Parser>(args.This());\n    parser->Init(type);\n    return Undefined();\n  }", "target": 0}
{"code": "bool ReadDictionaryValue(const Message* m, PickleIterator* iter,\n                         DictionaryValue* value, int recursion) {\n  int size;\n  if (!ReadParam(m, iter, &size))\n    return false;\n  for (int i = 0; i < size; ++i) {\n    std::string key;\n    Value* subval;\n    if (!ReadParam(m, iter, &key) ||\n        !ReadValue(m, iter, &subval, recursion + 1))\n      return false;\n    value->SetWithoutPathExpansion(key, subval);\n  }\n  return true;\n}", "target": 0}
{"code": "TEST_P(ProxyProtocolTest, V2LocalConnectionFilterState) {\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54,\n                                0x0a, 0x20, 0x00, 0x00, 0x07, 0x00, 0x00, 0x04, 0x0a, 0x0b, 0x0c,\n                                0x0d, 'm',  'o',  'r',  'e',  'd',  'a',  't',  'a'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  expectData(\"moredata\");\n  auto& filter_state = server_connection_->streamInfo().filterState();\n  const auto& proxy_proto_data = filter_state\n                                     ->getDataReadOnly<Network::ProxyProtocolFilterState>(\n                                         Network::ProxyProtocolFilterState::key())\n                                     ->value();\n  if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n      Envoy::Network::Address::IpVersion::v6) {\n    EXPECT_EQ(proxy_proto_data.dst_addr_->ip()->addressAsString(), \"::1\");\n  } else if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n             Envoy::Network::Address::IpVersion::v4) {\n    EXPECT_EQ(proxy_proto_data.dst_addr_->ip()->addressAsString(), \"127.0.0.1\");\n  }\n  EXPECT_FALSE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}", "target": 0}
{"code": "pipe_iov_copy_to_user(struct iovec *iov, const void *from, unsigned long len,\n\t\t      int atomic)\n{\n\tunsigned long copy;\n\twhile (len > 0) {\n\t\twhile (!iov->iov_len)\n\t\t\tiov++;\n\t\tcopy = min_t(unsigned long, len, iov->iov_len);\n\t\tif (atomic) {\n\t\t\tif (__copy_to_user_inatomic(iov->iov_base, from, copy))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\tif (copy_to_user(iov->iov_base, from, copy))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t\tfrom += copy;\n\t\tlen -= copy;\n\t\tiov->iov_base += copy;\n\t\tiov->iov_len -= copy;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    Buffer* buf = nullptr;\n    OP_REQUIRES_OK(ctx, GetBuffer(ctx, def(), &buf));\n    core::ScopedUnref scope(buf);\n    Buffer::Tuple tuple;\n    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(ctx->input(0).shape()),\n                errors::InvalidArgument(\"index must be scalar\"));\n    std::size_t index = ctx->input(0).scalar<int>()();\n    OP_REQUIRES_OK(ctx, buf->Peek(index, &tuple));\n    OP_REQUIRES(\n        ctx, tuple.size() == (size_t)ctx->num_outputs(),\n        errors::InvalidArgument(\"Mismatch stage/unstage: \", tuple.size(),\n                                \" vs. \", ctx->num_outputs()));\n    for (size_t i = 0; i < tuple.size(); ++i) {\n      ctx->set_output(i, tuple[i]);\n    }\n  }", "target": 0}
{"code": "static int serdes_probe(struct platform_device *pdev)\n{\n\tstruct phy_provider *provider;\n\tstruct serdes_ctrl *ctrl;\n\tunsigned int i;\n\tint ret;\n\tctrl = devm_kzalloc(&pdev->dev, sizeof(*ctrl), GFP_KERNEL);\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\tctrl->dev = &pdev->dev;\n\tctrl->regs = syscon_node_to_regmap(pdev->dev.parent->of_node);\n\tif (IS_ERR(ctrl->regs))\n\t\treturn PTR_ERR(ctrl->regs);\n\tfor (i = 0; i <= SERDES_MAX; i++) {\n\t\tret = serdes_phy_create(ctrl, i, &ctrl->phys[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tdev_set_drvdata(&pdev->dev, ctrl);\n\tprovider = devm_of_phy_provider_register(ctrl->dev,\n\t\t\t\t\t\t serdes_simple_xlate);\n\treturn PTR_ERR_OR_ZERO(provider);\n}", "target": 1}
{"code": "disconnect_ice_connection (IceConn ice_conn)\n{\n        IceSetShutdownNegotiation (ice_conn, FALSE);\n        IceCloseConnection (ice_conn);\n}", "target": 0}
{"code": "mysql_stmt_prepare(MYSQL_STMT *stmt, const char *query, ulong length)\n{\n  MYSQL *mysql= stmt->mysql;\n  DBUG_ENTER(\"mysql_stmt_prepare\");\n  if (!mysql)\n  {\n    set_stmt_error(stmt, CR_SERVER_LOST, unknown_sqlstate, NULL);\n    DBUG_RETURN(1);\n  }\n  stmt->last_errno= 0;\n  stmt->last_error[0]= '\\0';\n  if ((int) stmt->state > (int) MYSQL_STMT_INIT_DONE)\n  {\n    uchar buff[MYSQL_STMT_HEADER];               \n    if (reset_stmt_handle(stmt, RESET_LONG_DATA | RESET_STORE_RESULT))\n      DBUG_RETURN(1);\n    stmt->bind_param_done= stmt->bind_result_done= FALSE;\n    stmt->param_count= stmt->field_count= 0;\n    free_root(&stmt->mem_root, MYF(MY_KEEP_PREALLOC));\n    free_root(&stmt->extension->fields_mem_root, MYF(0));\n    int4store(buff, stmt->stmt_id);\n    stmt->state= MYSQL_STMT_INIT_DONE;\n    if (stmt_command(mysql, COM_STMT_CLOSE, buff, 4, stmt))\n    {\n      set_stmt_errmsg(stmt, &mysql->net);\n      DBUG_RETURN(1);\n    }\n  }\n  if (stmt_command(mysql, COM_STMT_PREPARE, (const uchar*) query, length, stmt))\n  {\n    set_stmt_errmsg(stmt, &mysql->net);\n    DBUG_RETURN(1);\n  }\n  if ((*mysql->methods->read_prepare_result)(mysql, stmt))\n  {\n    set_stmt_errmsg(stmt, &mysql->net);\n    DBUG_RETURN(1);\n  }\n  if (!(stmt->params= (MYSQL_BIND *) alloc_root(&stmt->mem_root,\n\t\t\t\t\t\tsizeof(MYSQL_BIND)*\n                                                (stmt->param_count +\n                                                 stmt->field_count))))\n  {\n    set_stmt_error(stmt, CR_OUT_OF_MEMORY, unknown_sqlstate, NULL);\n    DBUG_RETURN(1);\n  }\n  stmt->bind= stmt->params + stmt->param_count;\n  stmt->state= MYSQL_STMT_PREPARE_DONE;\n  DBUG_PRINT(\"info\", (\"Parameter count: %u\", stmt->param_count));\n  DBUG_RETURN(0);\n}", "target": 0}
{"code": "const char *osdp_reply_name(int reply_id)\n{\n\tconst char *name;\n\tstatic const char * const names[] = {\n\t\t[REPLY_ACK       - REPLY_ACK] = \"ACK\",\n\t\t[REPLY_NAK       - REPLY_ACK] = \"NAK\",\n\t\t[REPLY_PDID      - REPLY_ACK] = \"PDID\",\n\t\t[REPLY_PDCAP     - REPLY_ACK] = \"PDCAP\",\n\t\t[REPLY_LSTATR    - REPLY_ACK] = \"LSTATR\",\n\t\t[REPLY_ISTATR    - REPLY_ACK] = \"ISTATR\",\n\t\t[REPLY_OSTATR    - REPLY_ACK] = \"OSTATR\",\n\t\t[REPLY_RSTATR    - REPLY_ACK] = \"RSTATR\",\n\t\t[REPLY_RAW       - REPLY_ACK] = \"RAW\",\n\t\t[REPLY_FMT       - REPLY_ACK] = \"FMT\",\n\t\t[REPLY_KEYPPAD   - REPLY_ACK] = \"KEYPPAD\",\n\t\t[REPLY_COM       - REPLY_ACK] = \"COM\",\n\t\t[REPLY_BIOREADR  - REPLY_ACK] = \"BIOREADR\",\n\t\t[REPLY_BIOMATCHR - REPLY_ACK] = \"BIOMATCHR\",\n\t\t[REPLY_CCRYPT    - REPLY_ACK] = \"CCRYPT\",\n\t\t[REPLY_RMAC_I    - REPLY_ACK] = \"RMAC_I\",\n\t\t[REPLY_FTSTAT    - REPLY_ACK] = \"FTSTAT\",\n\t\t[REPLY_MFGREP    - REPLY_ACK] = \"MFGREP\",\n\t\t[REPLY_BUSY      - REPLY_ACK] = \"BUSY\",\n\t\t[REPLY_PIVDATAR  - REPLY_ACK] = \"PIVDATA\",\n\t\t[REPLY_CRAUTHR   - REPLY_ACK] = \"CRAUTH\",\n\t\t[REPLY_MFGSTATR  - REPLY_ACK] = \"MFGSTATR\",\n\t\t[REPLY_MFGERRR   - REPLY_ACK] = \"MFGERR\",\n\t\t[REPLY_XRD       - REPLY_ACK] = \"XRD\",\n\t};\n\tif (reply_id < REPLY_ACK || reply_id > REPLY_XRD) {\n\t\treturn \"INVALID\";\n\t}\n\tname = names[reply_id - REPLY_ACK];\n\tif (name[0] == '\\0') {\n\t\treturn \"UNKNOWN\";\n\t}\n\treturn name;\n}", "target": 1}
{"code": "    uint32_t TiffIfdMakernote::doSizeImage() const\n    {\n        return ifd_.sizeImage();\n    } ", "target": 0}
{"code": "static void sanitize_dead_code(struct bpf_verifier_env *env)\n{\n\tstruct bpf_insn_aux_data *aux_data = env->insn_aux_data;\n\tstruct bpf_insn nop = BPF_MOV64_REG(BPF_REG_0, BPF_REG_0);\n\tstruct bpf_insn *insn = env->prog->insnsi;\n\tconst int insn_cnt = env->prog->len;\n\tint i;\n\tfor (i = 0; i < insn_cnt; i++) {\n\t\tif (aux_data[i].seen)\n\t\t\tcontinue;\n\t\tmemcpy(insn + i, &nop, sizeof(nop));\n\t}\n}", "target": 0}
{"code": "static int smacker_decode_tree(BitstreamContext *bc, HuffContext *hc,\n                               uint32_t prefix, int length)\n{\n    if (length > SMKTREE_DECODE_MAX_RECURSION) {\n        av_log(NULL, AV_LOG_ERROR, \"Maximum tree recursion level exceeded.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (!bitstream_read_bit(bc)) { \n        if(hc->current >= 256){\n            av_log(NULL, AV_LOG_ERROR, \"Tree size exceeded!\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        if(length){\n            hc->bits[hc->current] = prefix;\n            hc->lengths[hc->current] = length;\n        } else {\n            hc->bits[hc->current] = 0;\n            hc->lengths[hc->current] = 0;\n        }\n        hc->values[hc->current] = bitstream_read(bc, 8);\n        hc->current++;\n        if(hc->maxlength < length)\n            hc->maxlength = length;\n        return 0;\n    } else { \n        int r;\n        length++;\n        r = smacker_decode_tree(bc, hc, prefix, length);\n        if(r)\n            return r;\n        return smacker_decode_tree(bc, hc, prefix | (1 << (length - 1)), length);\n    }\n}", "target": 0}
{"code": "snmp_ber_decode_string_len_buffer(unsigned char *buf, uint32_t *buff_len, const char **str, uint32_t *length)\n{\n  uint8_t type, i, length_bytes;\n  buf = snmp_ber_decode_type(buf, buff_len, &type);\n  if(buf == NULL || type != BER_DATA_TYPE_OCTET_STRING) {\n    return NULL;\n  }\n  if((*buf & 0x80) == 0) {\n    *length = (uint32_t)*buf++;\n    (*buff_len)--;\n  } else {\n    length_bytes = (uint8_t)(*buf++ & 0x7F);\n    (*buff_len)--;\n    if(length_bytes > 4) {\n      return NULL;\n    }\n    *length = (uint32_t)*buf++;\n    (*buff_len)--;\n    for(i = 1; i < length_bytes; ++i) {\n      *length <<= 8;\n      *length |= *buf++;\n      (*buff_len)--;\n    }\n  }\n  *str = (const char *)buf;\n  *buff_len -= *length;\n  return buf + *length;\n}", "target": 1}
{"code": "static void add_binary_option(gpointer key, gpointer value, gpointer user_data)\n{\n\tuint8_t *option = value;\n\tstruct dhcp_packet *packet = user_data;\n\tdhcp_add_binary_option(packet, option);\n}", "target": 0}
{"code": "file_extension(const char *s)\t\n{\n  const char\t*extension;\t\n  static char\tbuf[1024];\t\n  if (s == NULL)\n    return (NULL);\n  else if (!strncmp(s, \"data:image/bmp;\", 15))\n    return (\"bmp\");\n  else if (!strncmp(s, \"data:image/gif;\", 15))\n    return (\"gif\");\n  else if (!strncmp(s, \"data:image/jpeg;\", 16))\n    return (\"jpg\");\n  else if (!strncmp(s, \"data:image/png;\", 15))\n    return (\"png\");\n  else if ((extension = strrchr(s, '/')) != NULL)\n    extension ++;\n  else if ((extension = strrchr(s, '\\\\')) != NULL)\n    extension ++;\n  else\n    extension = s;\n  if ((extension = strrchr(extension, '.')) == NULL)\n    return (\"\");\n  else\n    extension ++;\n  if (strchr(extension, '#') == NULL)\n    return (extension);\n  strlcpy(buf, extension, sizeof(buf));\n  *(char *)strchr(buf, '#') = '\\0';\n  return (buf);\n}", "target": 1}
{"code": "static void utee_param_to_param(struct tee_ta_param *p, struct utee_params *up)\n{\n\tsize_t n;\n\tuint32_t types = up->types;\n\tp->types = types;\n\tfor (n = 0; n < TEE_NUM_PARAMS; n++) {\n\t\tuintptr_t a = up->vals[n * 2];\n\t\tsize_t b = up->vals[n * 2 + 1];\n\t\tswitch (TEE_PARAM_TYPE_GET(types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_INPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n\t\t\tp->u[n].mem.mobj = &mobj_virt;\n\t\t\tp->u[n].mem.offs = a;\n\t\t\tp->u[n].mem.size = b;\n\t\t\tbreak;\n\t\tcase TEE_PARAM_TYPE_VALUE_INPUT:\n\t\tcase TEE_PARAM_TYPE_VALUE_INOUT:\n\t\t\tp->u[n].val.a = a;\n\t\t\tp->u[n].val.b = b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmemset(&p->u[n], 0, sizeof(p->u[n]));\n\t\t\tbreak;\n\t\t}\n\t}\n}", "target": 1}
{"code": "  static ::tensorflow::Status ValidateInputs(\n      std::vector<ConstFlatSplits> rt_nested_splits,\n      const Tensor& rt_dense_values_in) {\n    for (int i = 0; i < rt_nested_splits.size(); ++i) {\n      if (rt_nested_splits[i].size() == 0) {\n        return InvalidArgument(\"ragged splits may not be empty.\");\n      }\n      if (rt_nested_splits[i](0) != 0) {\n        return InvalidArgument(\"First value of ragged splits must be 0.\");\n      }\n      for (int j = 1; j < rt_nested_splits[i].size(); ++j) {\n        if (rt_nested_splits[i](j) < rt_nested_splits[i](j - 1)) {\n          return InvalidArgument(\n              \"Ragged splits should be non decreasing, but we got \",\n              rt_nested_splits[i](j - 1), \" followed by \",\n              rt_nested_splits[i](j));\n        }\n      }\n      if (i > 0) {\n        SPLITS_TYPE last_split =\n            rt_nested_splits[i - 1](rt_nested_splits[i - 1].size() - 1);\n        if (rt_nested_splits[i].size() != last_split + 1) {\n          return InvalidArgument(\n              \"Final value of ragged splits must match the length \"\n              \"the corresponding ragged values.\");\n        }\n      }\n    }\n    if (rt_dense_values_in.dim_size(0) !=\n        rt_nested_splits.back()(rt_nested_splits.back().size() - 1)) {\n      return InvalidArgument(\n          \"Final value of ragged splits must match the length \"\n          \"the corresponding ragged values.\");\n    }\n    return ::tensorflow::Status::OK();\n  }", "target": 0}
{"code": "static void bio_map_kern_endio(struct bio *bio)\n{\n\tbio_put(bio);\n}", "target": 0}
{"code": "void UTFstring::UpdateFromUTF8()\n{\n  delete [] _Data;\n  size_t i;\n  for (_Length=0, i=0; i<UTF8string.length(); _Length++) {\n    uint8 lead = static_cast<uint8>(UTF8string[i]);\n    if (lead < 0x80)\n      i++;\n    else if ((lead >> 5) == 0x6)\n      i += 2;\n    else if ((lead >> 4) == 0xe)\n      i += 3;\n    else if ((lead >> 3) == 0x1e)\n      i += 4;\n    else\n      break;\n  }\n  _Data = new wchar_t[_Length+1];\n  size_t j;\n  for (j=0, i=0; i<UTF8string.length(); j++) {\n    uint8 lead = static_cast<uint8>(UTF8string[i]);\n    if (lead < 0x80) {\n      _Data[j] = lead;\n      i++;\n    } else if ((lead >> 5) == 0x6) {\n      _Data[j] = ((lead & 0x1F) << 6) + (UTF8string[i+1] & 0x3F);\n      i += 2;\n    } else if ((lead >> 4) == 0xe) {\n      _Data[j] = ((lead & 0x0F) << 12) + ((UTF8string[i+1] & 0x3F) << 6) + (UTF8string[i+2] & 0x3F);\n      i += 3;\n    } else if ((lead >> 3) == 0x1e) {\n      _Data[j] = ((lead & 0x07) << 18) + ((UTF8string[i+1] & 0x3F) << 12) + ((UTF8string[i+2] & 0x3F) << 6) + (UTF8string[i+3] & 0x3F);\n      i += 4;\n    } else\n      break;\n  }\n  _Data[j] = 0;\n}", "target": 1}
{"code": "static void listdir(unsigned int depth, int f, void * const tls_fd,\n                    const char *name)\n{\n    PureFileInfo *dir;\n    char *names;\n    PureFileInfo *s;\n    PureFileInfo *r;\n    int d;\n    if (depth >= max_ls_depth || matches >= max_ls_files) {\n        return;\n    }\n    if ((dir = sreaddir(&names)) == NULL) {\n        addreply(226, MSG_CANT_READ_FILE, name);\n        return;\n    }\n    s = dir;\n    while (s->name_offset != (size_t) -1) {\n        d = 0;\n        if (FI_NAME(s)[0] != '.') {\n            d = listfile(s, NULL);\n        } else if (opt_a) {\n            if (FI_NAME(s)[1] == 0 ||\n                (FI_NAME(s)[1] == '.' && FI_NAME(s)[2] == 0)) {\n                listfile(s, NULL);\n            } else {\n                d = listfile(s, NULL);\n            }\n        }\n        if (!d) {\n            s->name_offset = (size_t) -1;\n        }\n        s++;\n    }\n    outputfiles(f, tls_fd);\n    r = dir;\n    while (opt_R && r != s) {\n        if (r->name_offset != (size_t) -1 && !chdir(FI_NAME(r))) {\n            char *alloca_subdir;\n            const size_t sizeof_subdir = PATH_MAX + 1U;\n            if ((alloca_subdir = ALLOCA(sizeof_subdir)) == NULL) {\n                goto toomany;\n            }\n            if (SNCHECK(snprintf(alloca_subdir, sizeof_subdir, \"%s/%s\",\n                                 name, FI_NAME(r)), sizeof_subdir)) {\n                goto nolist;\n            }\n            wrstr(f, tls_fd, \"\\r\\n\\r\\n\");\n            wrstr(f, tls_fd, alloca_subdir);\n            wrstr(f, tls_fd, \":\\r\\n\\r\\n\");\n            listdir(depth + 1U, f, tls_fd, alloca_subdir);\n            nolist:\n            ALLOCA_FREE(alloca_subdir);\n            if (matches >= max_ls_files) {\n                goto toomany;\n            }\n            if (chdir(\"..\")) {    \n                if (chdir(wd) || chdir(name)) {    \n                    die(421, LOG_ERR, \"chdir: %s\", strerror(errno));\n                }\n            }\n        }\n        r++;\n    }\n    toomany:\n    free(names);\n    free(dir);\n    names = NULL;\n}", "target": 1}
{"code": "register_disks_device (Device *device)\n{\n  DBusConnection *connection;\n  GError *error = NULL;\n  device->priv->system_bus_connection = dbus_g_bus_get (DBUS_BUS_SYSTEM, &error);\n  if (device->priv->system_bus_connection == NULL)\n    {\n      if (error != NULL)\n        {\n          g_critical (\"error getting system bus: %s\", error->message);\n          g_error_free (error);\n        }\n      goto error;\n    }\n  connection = dbus_g_connection_get_connection (device->priv->system_bus_connection);\n  device->priv->object_path = compute_object_path (device->priv->native_path);\n  if (dbus_g_connection_lookup_g_object (device->priv->system_bus_connection, device->priv->object_path) != NULL)\n    {\n      g_error (\"**** HACK: Wanting to register object at path `%s' but there is already an \"\n               \"object there. This is an internal error in the daemon. Aborting.\\n\", device->priv->object_path);\n    }\n  dbus_g_connection_register_g_object (device->priv->system_bus_connection,\n                                       device->priv->object_path,\n                                       G_OBJECT (device));\n  return TRUE;\n error:\n  return FALSE;\n}", "target": 0}
{"code": "int fpm_unix_resolve_socket_premissions(struct fpm_worker_pool_s *wp) \n{\n\tstruct fpm_worker_pool_config_s *c = wp->config;\n\twp->socket_uid = -1;\n\twp->socket_gid = -1;\n\twp->socket_mode = 0666;\n\tif (!c) {\n\t\treturn 0;\n\t}\n\tif (c->listen_owner && *c->listen_owner) {\n\t\tstruct passwd *pwd;\n\t\tpwd = getpwnam(c->listen_owner);\n\t\tif (!pwd) {\n\t\t\tzlog(ZLOG_SYSERROR, \"[pool %s] cannot get uid for user '%s'\", wp->config->name, c->listen_owner);\n\t\t\treturn -1;\n\t\t}\n\t\twp->socket_uid = pwd->pw_uid;\n\t\twp->socket_gid = pwd->pw_gid;\n\t}\n\tif (c->listen_group && *c->listen_group) {\n\t\tstruct group *grp;\n\t\tgrp = getgrnam(c->listen_group);\n\t\tif (!grp) {\n\t\t\tzlog(ZLOG_SYSERROR, \"[pool %s] cannot get gid for group '%s'\", wp->config->name, c->listen_group);\n\t\t\treturn -1;\n\t\t}\n\t\twp->socket_gid = grp->gr_gid;\n\t}\n\tif (c->listen_mode && *c->listen_mode) {\n\t\twp->socket_mode = strtoul(c->listen_mode, 0, 8);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void ConvertLoopSequence(ModSample &smp, STPLoopList &loopList)\n{\n\tif(!smp.HasSampleData() || loopList.size() < 2) return;\n\tModSample newSmp = smp;\n\tnewSmp.nLength = 0;\n\tnewSmp.pSample = nullptr;\n\tsize_t numLoops = loopList.size();\n\tfor(size_t i = 0; i < numLoops; i++)\n\t{\n\t\tSTPLoopInfo &info = loopList[i];\n\t\tif((newSmp.nLength + info.loopLength > MAX_SAMPLE_LENGTH) ||\n\t\t   (info.loopLength > MAX_SAMPLE_LENGTH) ||\n\t\t   (info.loopStart + info.loopLength > smp.nLength))\n\t\t{\n\t\t\tnumLoops = i;\n\t\t\tbreak;\n\t\t}\n\t\tnewSmp.nLength += info.loopLength;\n\t}\n\tif(!newSmp.AllocateSample())\n\t{\n\t\treturn;\n\t}\n\tSmpLength start = 0;\n\tfor(size_t i = 0; i < numLoops; i++)\n\t{\n\t\tSTPLoopInfo &info = loopList[i];\n\t\tmemcpy(newSmp.pSample8 + start, smp.pSample8 + info.loopStart, info.loopLength);\n\t\tinfo.loopStart = start;\n\t\tif(i > 0 && i <= mpt::size(newSmp.cues))\n\t\t{\n\t\t\tnewSmp.cues[i - 1] = start;\n\t\t}\n\t\tstart += info.loopLength;\n\t}\n\tsmp.FreeSample();\n\tsmp = newSmp;\n\tsmp.nLoopStart = 0;\n\tsmp.nLoopEnd = smp.nLength;\n\tsmp.uFlags.set(CHN_LOOP);\n}", "target": 1}
{"code": "STATIC struct pollfd *poll_set_add_fd(poll_set_t *poll_set, int fd) {\n    struct pollfd *free_slot = NULL;\n    if (poll_set->used == poll_set->max_used) {\n        if (poll_set->max_used >= poll_set->alloc) {\n            poll_set->pollfds = m_renew(struct pollfd, poll_set->pollfds, poll_set->alloc, poll_set->alloc + 4);\n            poll_set->alloc += 4;\n        }\n        free_slot = &poll_set->pollfds[poll_set->max_used++];\n    } else {\n        for (unsigned int i = 0; i < poll_set->max_used; ++i) {\n            struct pollfd *slot = &poll_set->pollfds[i];\n            if (slot->fd == -1) {\n                free_slot = slot;\n                break;\n            }\n        }\n        assert(free_slot != NULL);\n    }\n    free_slot->fd = fd;\n    ++poll_set->used;\n    return free_slot;\n}", "target": 1}
{"code": "void SetLineWidth(double w) {\n    outpos +=\n    sprintf(outpos,\" %12.3f w\",w);\n}", "target": 1}
{"code": "void ConnectDialogEdit::accept() {\n\tvalidate();\n\tif (bOk) {\n\t\tQString server = qleServer->text().simplified();\n\t\tconst int schemaPos = server.indexOf(QLatin1String(\":\n\t\tif (schemaPos != -1) {\n\t\t\tserver.remove(0, schemaPos + 3);\n\t\t}\n\t\tconst int pathPos = server.indexOf(QLatin1Char('/'));\n\t\tif (pathPos != -1) {\n\t\t\tserver.resize(pathPos);\n\t\t}\n\t\tqleServer->setText(server);\n\t\tif (qleName->text().simplified().isEmpty() || !bCustomLabel) {\n\t\t\tqleName->setText(server);\n\t\t}\n\t\tQDialog::accept();\n\t}\n}", "target": 0}
{"code": "struct clock_source *dce112_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\tif (!clk_src)\n\t\treturn NULL;\n\tif (dce112_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 0}
{"code": "static wStream* rdg_receive_packet(rdpRdg* rdg)\n{\n\twStream* s;\n\tconst size_t header = sizeof(RdgPacketHeader);\n\tsize_t packetLength;\n\tassert(header <= INT_MAX);\n\ts = Stream_New(NULL, 1024);\n\tif (!s)\n\t\treturn NULL;\n\tif (!rdg_read_all(rdg->tlsOut, Stream_Buffer(s), header))\n\t{\n\t\tStream_Free(s, TRUE);\n\t\treturn NULL;\n\t}\n\tStream_Seek(s, 4);\n\tStream_Read_UINT32(s, packetLength);\n\tif ((packetLength > INT_MAX) || !Stream_EnsureCapacity(s, packetLength))\n\t{\n\t\tStream_Free(s, TRUE);\n\t\treturn NULL;\n\t}\n\tif (!rdg_read_all(rdg->tlsOut, Stream_Buffer(s) + header, (int)packetLength - (int)header))\n\t{\n\t\tStream_Free(s, TRUE);\n\t\treturn NULL;\n\t}\n\tStream_SetLength(s, packetLength);\n\treturn s;\n}", "target": 1}
{"code": "std::string ExpandFilePath(const std::string &filepath, void *) {\n  return filepath;\n#if 0\n#ifdef _WIN32\n  std::wstring wfilepath = UTF8ToWchar(filepath);\n  DWORD wlen = ExpandEnvironmentStringsW(wfilepath.c_str(), nullptr, 0);\n  wchar_t *wstr = new wchar_t[wlen];\n  ExpandEnvironmentStringsW(wfilepath.c_str(), wstr, wlen);\n  std::wstring ws(wstr);\n  delete[] wstr;\n  return WcharToUTF8(ws);\n#else\n#if defined(TARGET_OS_IPHONE) || defined(TARGET_IPHONE_SIMULATOR) || \\\n    defined(__ANDROID__) || defined(__EMSCRIPTEN__) || defined(__OpenBSD__)\n  std::string s = filepath;\n#else\n  std::string s;\n  wordexp_t p;\n  if (filepath.empty()) {\n    return \"\";\n  }\n  std::string quoted_path = \"\\\"\" + filepath + \"\\\"\";\n  int ret = wordexp(quoted_path.c_str(), &p, 0);\n  if (ret) {\n    s = filepath;\n    return s;\n  }\n  if (p.we_wordv) {\n    s = std::string(p.we_wordv[0]);\n    wordfree(&p);\n  } else {\n    s = filepath;\n  }\n#endif\n  return s;\n#endif\n#endif\n}", "target": 0}
{"code": "static int filter_frame(AVFilterLink *inlink, AVFrame *in)\n{\n    DelogoContext *s = inlink->dst->priv;\n    AVFilterLink *outlink = inlink->dst->outputs[0];\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);\n    AVFrame *out;\n    int hsub0 = desc->log2_chroma_w;\n    int vsub0 = desc->log2_chroma_h;\n    int direct = 0;\n    int plane;\n    AVRational sar;\n    if (av_frame_is_writable(in)) {\n        direct = 1;\n        out = in;\n    } else {\n        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n        if (!out) {\n            av_frame_free(&in);\n            return AVERROR(ENOMEM);\n        }\n        av_frame_copy_props(out, in);\n    }\n    sar = in->sample_aspect_ratio;\n    if (!sar.num)\n        sar.num = sar.den = 1;\n    for (plane = 0; plane < 4 && in->data[plane]; plane++) {\n        int hsub = plane == 1 || plane == 2 ? hsub0 : 0;\n        int vsub = plane == 1 || plane == 2 ? vsub0 : 0;\n        apply_delogo(out->data[plane], out->linesize[plane],\n                     in ->data[plane], in ->linesize[plane],\n                     FF_CEIL_RSHIFT(inlink->w, hsub),\n                     FF_CEIL_RSHIFT(inlink->h, vsub),\n                     sar, s->x>>hsub, s->y>>vsub,\n                     FF_CEIL_RSHIFT(s->w + (s->x & ((1<<hsub)-1)), hsub),\n                     FF_CEIL_RSHIFT(s->h + (s->y & ((1<<vsub)-1)), vsub),\n                     s->band>>FFMIN(hsub, vsub),\n                     s->show, direct);\n    }\n    if (!direct)\n        av_frame_free(&in);\n    return ff_filter_frame(outlink, out);\n}", "target": 1}
{"code": "uipbuf_clear(void)\n{\n  uip_len = 0;\n  uip_ext_len = 0;\n  uip_last_proto = 0;\n  uipbuf_clear_attr();\n}", "target": 0}
{"code": "static const uint8_t *get_signature(const uint8_t *asn1_sig, int *len)\n{\n    int offset = 0;\n    const uint8_t *ptr = NULL;\n    if (asn1_next_obj(asn1_sig, &offset, ASN1_SEQUENCE) < 0 || \n            asn1_skip_obj(asn1_sig, &offset, ASN1_SEQUENCE))\n        goto end_get_sig;\n    if (asn1_sig[offset++] != ASN1_OCTET_STRING)\n        goto end_get_sig;\n    *len = get_asn1_length(asn1_sig, &offset);\n    ptr = &asn1_sig[offset];          \nend_get_sig:\n    return ptr;\n}", "target": 1}
{"code": "unsigned char *ziplistResize(unsigned char *zl, unsigned int len) {\n    zl = zrealloc(zl,len);\n    ZIPLIST_BYTES(zl) = intrev32ifbe(len);\n    zl[len-1] = ZIP_END;\n    return zl;\n}", "target": 1}
{"code": "void __ip_select_ident(struct net *net, struct iphdr *iph, int segs)\n{\n\tstatic u32 ip_idents_hashrnd __read_mostly;\n\tu32 hash, id;\n\tnet_get_random_once(&ip_idents_hashrnd, sizeof(ip_idents_hashrnd));\n\thash = jhash_3words((__force u32)iph->daddr,\n\t\t\t    (__force u32)iph->saddr,\n\t\t\t    iph->protocol ^ net_hash_mix(net),\n\t\t\t    ip_idents_hashrnd);\n\tid = ip_idents_reserve(hash, segs);\n\tiph->id = htons(id);\n}", "target": 1}
{"code": "Pl_ASCII85Decoder::flush()\n{\n    if (this->pos == 0)\n    {\n\tQTC::TC(\"libtests\", \"Pl_ASCII85Decoder no-op flush\");\n\treturn;\n    }\n    unsigned long lval = 0;\n    for (int i = 0; i < 5; ++i)\n    {\n\tlval *= 85;\n\tlval += (this->inbuf[i] - 33U);\n    }\n    unsigned char outbuf[4];\n    memset(outbuf, 0, 4);\n    for (int i = 3; i >= 0; --i)\n    {\n\toutbuf[i] = lval & 0xff;\n\tlval >>= 8;\n    }\n    QTC::TC(\"libtests\", \"Pl_ASCII85Decoder partial flush\",\n\t    (this->pos == 5) ? 0 : 1);\n    getNext()->write(outbuf, this->pos - 1);\n    this->pos = 0;\n    memset(this->inbuf, 117, 5);\n}", "target": 1}
{"code": "static int __btrfs_set_acl(struct btrfs_trans_handle *trans,\n\t\t\t struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint ret, size = 0;\n\tconst char *name;\n\tchar *value = NULL;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tret = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EINVAL : 0;\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tret = __btrfs_setxattr(trans, inode, name, value, size, 0);\nout:\n\tkfree(value);\n\tif (!ret)\n\t\tset_cached_acl(inode, type, acl);\n\treturn ret;\n}", "target": 1}
{"code": "static Jsi_RC SysRunMainCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (jsi_isMain(interp))\n        return SysRunModuleCmd(interp, args, _this, ret, funcPtr);\n    return JSI_OK;\n}", "target": 0}
{"code": "    std::ostream& operator<<(std::ostream& os, const Rational& r)\n    {\n        return os << r.first << \"/\" << r.second;\n    }", "target": 0}
{"code": "void codingXOR(char* extractedString, char* keyString, char* xoredString, int bufferLength)\n{\n\tint i;\n\tif(isCodingInverted){\n\t\tfor (i = 0; i < bufferLength; ++i)\n\t\t{\n\t\t\txoredString[i] = scrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)(extractedString[i] ^ keyString[i])];\n\t\t}\n\t}else{\n\t\tfor (i = 0; i < bufferLength; ++i)\n\t\t{\n\t\t\txoredString[i] = scrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)extractedString[i]] ^ keyString[i];\n\t\t}\n\t}\n}", "target": 1}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteFloat32);\n  TF_LITE_ENSURE_TYPES_EQ(context, output->type, input->type);\n  TF_LITE_ENSURE_EQ(context, output->bytes, input->bytes);\n  TF_LITE_ENSURE_EQ(context, output->dims->size, input->dims->size);\n  for (int i = 0; i < output->dims->size; ++i) {\n    TF_LITE_ENSURE_EQ(context, output->dims->data[i], input->dims->data[i]);\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "void ldapsrv_recv(struct stream_connection *c, uint16_t flags)\n{\n\tsmb_panic(__location__);\n}", "target": 0}
{"code": "static int rb_head_page_set_head(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t struct buffer_page *head,\n\t\t\t\t struct buffer_page *prev,\n\t\t\t\t int old_flag)\n{\n\treturn rb_head_page_set(cpu_buffer, head, prev,\n\t\t\t\told_flag, RB_PAGE_HEAD);\n}", "target": 0}
{"code": "int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,\n\t\t     int flen)\n{\n\tstruct ustr *filename, *unifilename;\n\tint len = 0;\n\tfilename = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!filename)\n\t\treturn 0;\n\tunifilename = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!unifilename)\n\t\tgoto out1;\n\tif (udf_build_ustr_exact(unifilename, sname, flen))\n\t\tgoto out2;\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {\n\t\tif (!udf_CS0toUTF8(filename, unifilename)) {\n\t\t\tudf_debug(\"Failed in udf_get_filename: sname = %s\\n\",\n\t\t\t\t  sname);\n\t\t\tgoto out2;\n\t\t}\n\t} else if (UDF_QUERY_FLAG(sb, UDF_FLAG_NLS_MAP)) {\n\t\tif (!udf_CS0toNLS(UDF_SB(sb)->s_nls_map, filename,\n\t\t\t\t  unifilename)) {\n\t\t\tudf_debug(\"Failed in udf_get_filename: sname = %s\\n\",\n\t\t\t\t  sname);\n\t\t\tgoto out2;\n\t\t}\n\t} else\n\t\tgoto out2;\n\tlen = udf_translate_to_linux(dname, filename->u_name, filename->u_len,\n\t\t\t\t     unifilename->u_name, unifilename->u_len);\nout2:\n\tkfree(unifilename);\nout1:\n\tkfree(filename);\n\treturn len;\n}", "target": 1}
{"code": "int vfs_open(const struct path *path, struct file *file,\n\t     const struct cred *cred)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tfile->f_path = *path;\n\tif (dentry->d_flags & DCACHE_OP_SELECT_INODE) {\n\t\tinode = dentry->d_op->d_select_inode(dentry, file->f_flags);\n\t\tif (IS_ERR(inode))\n\t\t\treturn PTR_ERR(inode);\n\t}\n\treturn do_dentry_open(file, inode, NULL, cred);\n}", "target": 1}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_source_code_file_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tif (!sz) {\n\t\treturn NULL;\n\t}\n\tut64 offset = 0;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_SOURCE_FILE_ATTR;\n\tattr->info.source_file_attr.sourcefile_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->size = offset;\n\treturn attr;\n}", "target": 1}
{"code": "    void resetTriggered() { m_triggered = false; }", "target": 0}
{"code": "void appendCommand(client *c) {\n    size_t totlen;\n    robj *o, *append;\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (o == NULL) {\n        c->argv[2] = tryObjectEncoding(c->argv[2]);\n        dbAdd(c->db,c->argv[1],c->argv[2]);\n        incrRefCount(c->argv[2]);\n        totlen = stringObjectLen(c->argv[2]);\n    } else {\n        if (checkType(c,o,OBJ_STRING))\n            return;\n        append = c->argv[2];\n        totlen = stringObjectLen(o)+sdslen(append->ptr);\n        if (checkStringLength(c,totlen) != C_OK)\n            return;\n        o = dbUnshareStringValue(c->db,c->argv[1],o);\n        o->ptr = sdscatlen(o->ptr,append->ptr,sdslen(append->ptr));\n        totlen = sdslen(o->ptr);\n    }\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_STRING,\"append\",c->argv[1],c->db->id);\n    server.dirty++;\n    addReplyLongLong(c,totlen);\n}", "target": 1}
{"code": "acc_ctx_hints(OM_uint32 *minor_status,\n\t      gss_ctx_id_t *ctx,\n\t      spnego_gss_cred_id_t spcred,\n\t      gss_buffer_t *mechListMIC,\n\t      OM_uint32 *negState,\n\t      send_token_flag *return_token)\n{\n\tOM_uint32 tmpmin, ret;\n\tgss_OID_set supported_mechSet;\n\tspnego_gss_ctx_id_t sc = NULL;\n\t*mechListMIC = GSS_C_NO_BUFFER;\n\tsupported_mechSet = GSS_C_NO_OID_SET;\n\t*return_token = NO_TOKEN_SEND;\n\t*negState = REJECT;\n\t*minor_status = 0;\n\tif (*ctx != GSS_C_NO_CONTEXT)\n\t    return GSS_S_DEFECTIVE_TOKEN;\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_ACCEPT,\n\t\t\t\t   &supported_mechSet);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\tret = make_NegHints(minor_status, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\tsc = create_spnego_ctx();\n\tif (sc == NULL) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tif (put_mech_set(supported_mechSet, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tsc->internal_mech = GSS_C_NO_OID;\n\t*negState = ACCEPT_INCOMPLETE;\n\t*return_token = INIT_TOKEN_SEND;\n\tsc->firstpass = 1;\n\t*ctx = (gss_ctx_id_t)sc;\n\tsc = NULL;\n\tret = GSS_S_COMPLETE;\ncleanup:\n\trelease_spnego_ctx(&sc);\n\tgss_release_oid_set(&tmpmin, &supported_mechSet);\n\treturn ret;\n}", "target": 1}
{"code": "int password_equal(const char *user_input, const char *secret) {\n    size_t i = 0;\n    size_t j = 0;\n    char out = 0;\n    while (1) {\n        out |= user_input[i] ^ secret[j];\n        if (user_input[i] == 0) break;\n        i++;\n        if (secret[j] != 0) j++;\n    }\n    out |= (i != j); \n    out |= (secret[j] != 0); \n    return out == 0;\n}", "target": 0}
{"code": "STACK_OF(PKCS7) *PKCS12_unpack_authsafes(const PKCS12 *p12)\n{\n    STACK_OF(PKCS7) *p7s;\n    PKCS7 *p7;\n    int i;\n    if (!PKCS7_type_is_data(p12->authsafes)) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_CONTENT_TYPE_NOT_DATA);\n        return NULL;\n    }\n    if (p12->authsafes->d.data == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_DECODE_ERROR);\n        return NULL;\n    }\n    p7s = ASN1_item_unpack(p12->authsafes->d.data,\n                           ASN1_ITEM_rptr(PKCS12_AUTHSAFES));\n    if (p7s != NULL) {\n        for (i = 0; i < sk_PKCS7_num(p7s); i++) {\n            p7 = sk_PKCS7_value(p7s, i);\n            if (!ossl_pkcs7_ctx_propagate(p12->authsafes, p7))\n                goto err;\n        }\n    }\n    return p7s;\nerr:\n    sk_PKCS7_free(p7s);\n    return NULL;\n}", "target": 0}
{"code": "int CLASS parse_jpeg(int offset)\n{\n  int len, save, hlen, mark;\n  fseek(ifp, offset, SEEK_SET);\n  if (fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8)\n    return 0;\n  while (fgetc(ifp) == 0xff && (mark = fgetc(ifp)) != 0xda)\n  {\n    order = 0x4d4d;\n    len = get2() - 2;\n    save = ftell(ifp);\n    if (mark == 0xc0 || mark == 0xc3 || mark == 0xc9)\n    {\n      fgetc(ifp);\n      raw_height = get2();\n      raw_width = get2();\n    }\n    order = get2();\n    hlen = get4();\n    if (get4() == 0x48454150) \n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n#endif\n      parse_ciff(save + hlen, len - hlen, 0);\n    }\n    if (parse_tiff(save + 6))\n      apply_tiff();\n    fseek(ifp, save + len, SEEK_SET);\n  }\n  return 1;\n}", "target": 1}
{"code": "netsnmp_mibindex_new( const char *dirname )\n{\n    FILE *fp;\n    char  tmpbuf[300];\n    char *cp;\n    int   i;\n    cp = netsnmp_mibindex_lookup( dirname );\n    if (!cp) {\n        i  = _mibindex_add( dirname, -1 );\n        snprintf( tmpbuf, sizeof(tmpbuf), \"%s/mib_indexes/%d\",\n                  get_persistent_directory(), i );\n        tmpbuf[sizeof(tmpbuf)-1] = 0;\n        cp = tmpbuf;\n    }\n    DEBUGMSGTL((\"mibindex\", \"new: %s (%s)\\n\", dirname, cp ));\n    fp = fopen( cp, \"w\" );\n    if (fp)\n        fprintf( fp, \"DIR %s\\n\", dirname );\n    return fp;\n}", "target": 1}
{"code": "static gboolean irssi_ssl_verify(SSL *ssl, SSL_CTX *ctx, X509 *cert)\n{\n\tif (SSL_get_verify_result(ssl) != X509_V_OK) {\n\t\tunsigned char md[EVP_MAX_MD_SIZE];\n\t\tunsigned int n;\n\t\tchar *str;\n\t\tg_warning(\"Could not verify SSL servers certificate:\");\n\t\tif ((str = X509_NAME_oneline(X509_get_subject_name(cert), 0, 0)) == NULL)\n\t\t\tg_warning(\"  Could not get subject-name from peer certificate\");\n\t\telse {\n\t\t\tg_warning(\"  Subject : %s\", str);\n\t\t\tfree(str);\n\t\t}\n\t\tif ((str = X509_NAME_oneline(X509_get_issuer_name(cert), 0, 0)) == NULL)\n\t\t\tg_warning(\"  Could not get issuer-name from peer certificate\");\n\t\telse {\n\t\t\tg_warning(\"  Issuer  : %s\", str);\n\t\t\tfree(str);\n\t\t}\n\t\tif (! X509_digest(cert, EVP_md5(), md, &n))\n\t\t\tg_warning(\"  Could not get fingerprint from peer certificate\");\n\t\telse {\n\t\t\tchar hex[] = \"0123456789ABCDEF\";\n\t\t\tchar fp[EVP_MAX_MD_SIZE*3];\n\t\t\tif (n < sizeof(fp)) {\n\t\t\t\tunsigned int i;\n\t\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\t\tfp[i*3+0] = hex[(md[i] >> 4) & 0xF];\n\t\t\t\t\tfp[i*3+1] = hex[(md[i] >> 0) & 0xF];\n\t\t\t\t\tfp[i*3+2] = i == n - 1 ? '\\0' : ':';\n\t\t\t\t}\n\t\t\t\tg_warning(\"  MD5 Fingerprint : %s\", fp);\n\t\t\t}\n\t\t}\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "static inline LineContribType * _gdContributionsAlloc(unsigned int line_length, unsigned int windows_size)\n{\n\tunsigned int u = 0;\n\tLineContribType *res;\n\tint overflow_error = 0;\n\tres = (LineContribType *) gdMalloc(sizeof(LineContribType));\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\tres->WindowSize = windows_size;\n\tres->LineLength = line_length;\n\tif (overflow2(line_length, sizeof(ContributionType))) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tres->ContribRow = (ContributionType *) gdMalloc(line_length * sizeof(ContributionType));\n\tif (res->ContribRow == NULL) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tfor (u = 0 ; u < line_length ; u++) {\n\t\tif (overflow2(windows_size, sizeof(double))) {\n\t\t\toverflow_error = 1;\n\t\t} else {\n\t\t\tres->ContribRow[u].Weights = (double *) gdMalloc(windows_size * sizeof(double));\n\t\t}\n\t\tif (overflow_error == 1 || res->ContribRow[u].Weights == NULL) {\n\t\t\tunsigned int i;\n\t\t\tu--;\n\t\t\tfor (i=0;i<=u;i++) {\n\t\t\t\tgdFree(res->ContribRow[i].Weights);\n\t\t\t}\n\t\t\tgdFree(res->ContribRow);\n\t\t\tgdFree(res);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn res;\n}", "target": 1}
{"code": "bool CephxAuthorizeHandler::verify_authorizer(CephContext *cct, KeyStore *keys,\n\t\t\t\t\t      bufferlist& authorizer_data, bufferlist& authorizer_reply,\n                                              EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info, CryptoKey& session_key,  uint64_t *auid)\n{\n  bufferlist::iterator iter = authorizer_data.begin();\n  if (!authorizer_data.length()) {\n    ldout(cct, 1) << \"verify authorizer, authorizer_data.length()=0\" << dendl;\n    return false;\n  }\n  CephXServiceTicketInfo auth_ticket_info;\n  bool isvalid = cephx_verify_authorizer(cct, keys, iter, auth_ticket_info, authorizer_reply);\n  if (isvalid) {\n    caps_info = auth_ticket_info.ticket.caps;\n    entity_name = auth_ticket_info.ticket.name;\n    global_id = auth_ticket_info.ticket.global_id;\n    session_key = auth_ticket_info.session_key;\n    if (auid) *auid = auth_ticket_info.ticket.auid;\n  }\n  return isvalid;\n}", "target": 1}
{"code": "BGD_DECLARE(void *) gdImageWBMPPtr(gdImagePtr im, int *size, int fg)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) return NULL;\n\tgdImageWBMPCtx(im, fg, out);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}", "target": 1}
{"code": "void Item::cleanup()\n{\n  DBUG_ENTER(\"Item::cleanup\");\n  DBUG_PRINT(\"enter\", (\"this: %p\", this));\n  fixed=0;\n  marker= 0;\n  join_tab_idx= MAX_TABLES;\n  if (orig_name)\n    name= orig_name;\n  DBUG_VOID_RETURN;\n}", "target": 0}
{"code": "R_API bool r_io_bank_read_at(RIO *io, const ut32 bankid, ut64 addr, ut8 *buf, int len) {\n\tr_return_val_if_fail (io, false);\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tif (!bank) {\n\t\treturn false;\n\t}\n\tRIOSubMap fake_sm = {{0}};\n\tfake_sm.itv.addr = addr;\n\tfake_sm.itv.size = len;\n\tRRBNode *node;\n\tif (R_LIKELY (bank->last_used && r_io_submap_contain (((RIOSubMap *)bank->last_used->data), addr))) {\n\t\tnode = bank->last_used;\n\t} else {\n\t\tnode = _find_entry_submap_node (bank, &fake_sm);\n\t}\n\tmemset (buf, io->Oxff, len);\n\tRIOSubMap *sm = node ? (RIOSubMap *)node->data : NULL;\n\tbool ret = true;\n\twhile (sm && r_io_submap_overlap ((&fake_sm), sm)) {\n\t\tbank->last_used = node;\n\t\tRIOMap *map = r_io_map_get_by_ref (io, &sm->mapref);\n\t\tif (!map) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!(map->perm & R_PERM_R)) {\n\t\t\tnode = r_rbnode_next (node);\n\t\t\tsm = node ? (RIOSubMap *)node->data : NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tconst ut64 buf_off = R_MAX (addr, r_io_submap_from (sm)) - addr;\n\t\tconst int read_len = R_MIN (r_io_submap_to ((&fake_sm)),\n\t\t\t\t\t     r_io_submap_to (sm)) - (addr + buf_off) + 1;\n\t\tif (map->perm & R_PERM_RELOC) {\n\t\t\tret &= map->reloc_map->read (io, map, addr + buf_off, &buf[buf_off], read_len);\n\t\t} else {\n\t\t\tconst ut64 paddr = addr + buf_off - r_io_map_from (map) + map->delta;\n\t\t\tret &= (r_io_fd_read_at (io, map->fd, paddr, &buf[buf_off], read_len) == read_len);\n\t\t}\n\t\tnode = r_rbnode_next (node);\n\t\tsm = node ? (RIOSubMap *)node->data : NULL;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "snmp_engine_get_next(snmp_header_t *header, snmp_varbind_t *varbinds, uint32_t varbinds_length)\n{\n  snmp_mib_resource_t *resource;\n  uint32_t i;\n  for(i = 0; i < varbinds_length; i++) {\n    resource = snmp_mib_find_next(varbinds[i].oid);\n    if(!resource) {\n      switch(header->version) {\n      case SNMP_VERSION_1:\n        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n        header->error_index_max_repetitions.error_index = i + 1;\n        break;\n      case SNMP_VERSION_2C:\n        (&varbinds[i])->value_type = SNMP_DATA_TYPE_END_OF_MIB_VIEW;\n        break;\n      default:\n        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n        header->error_index_max_repetitions.error_index = 0;\n      }\n    } else {\n      resource->handler(&varbinds[i], resource->oid);\n    }\n  }\n  return 0;\n}", "target": 1}
{"code": "EventQueue* Document::GetEventQueue() const {\n  if (!dom_window_)\n    return nullptr;\n  return dom_window_->GetEventQueue();\n}", "target": 0}
{"code": "static char *http_get_w32(const char *url, int *code, int *rlen) {\n\tHINTERNET hInternet = InternetOpenA (\"radare2 \"R2_VERSION, INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);\n\tif (!hInternet) {\n\t\tr_sys_perror (\"InternetOpenA\");\n\t\treturn NULL;\n\t}\n\tHINTERNET hOpenUrl = InternetOpenUrlA (hInternet, url, NULL, 0, 0, 0);\n\tif (!hOpenUrl) {\n\t\tr_sys_perror (\"InternetOpenUrlA\");\n\t\tInternetCloseHandle (hInternet);\n\t\treturn NULL;\n\t}\n\tchar *ret = NULL;\n\tsize_t read_sz = 0x100000;\n\tDWORD r = 0, w = 0;\n\tbool res = true;\n\tdo {\n\t\tw += r;\n\t\tif (!res && GetLastError () == ERROR_INSUFFICIENT_BUFFER) {\n\t\t\tread_sz *= 2;\n\t\t}\n\t\tchar *tmp = realloc (ret, read_sz + w);\n\t\tif (!tmp) {\n\t\t\tR_FREE (ret);\n\t\t\tgoto exit;\n\t\t}\n\t\tret = tmp;\n\t} while (!(res = InternetReadFile (hOpenUrl, ret + w, read_sz, &r)) || r);\n\tif (w) {\n\t\tchar *tmp = realloc (ret, (size_t)w + 1);\n\t\tif (tmp) {\n\t\t\tret = tmp;\n\t\t\tret[w] = 0;\n\t\t} else {\n\t\t\tR_FREE (ret);\n\t\t}\n\t} else {\n\t\tR_FREE (ret);\n\t}\nexit:\n\tif (rlen) {\n\t\t*rlen = w;\n\t}\n\tif (code && w) {\n\t\t*code = 200;\n\t}\n\tInternetCloseHandle (hInternet);\n\tInternetCloseHandle (hOpenUrl);\n\treturn ret;\n}", "target": 0}
{"code": "cib_tls_close(cib_t * cib)\n{\n    cib_remote_opaque_t *private = cib->variant_opaque;\n    shutdown(private->command.socket, SHUT_RDWR);       \n    shutdown(private->callback.socket, SHUT_RDWR);      \n    close(private->command.socket);\n    close(private->callback.socket);\n#ifdef HAVE_GNUTLS_GNUTLS_H\n    if (private->command.encrypted) {\n        gnutls_bye(*(private->command.session), GNUTLS_SHUT_RDWR);\n        gnutls_deinit(*(private->command.session));\n        gnutls_free(private->command.session);\n        gnutls_bye(*(private->callback.session), GNUTLS_SHUT_RDWR);\n        gnutls_deinit(*(private->callback.session));\n        gnutls_free(private->callback.session);\n        gnutls_anon_free_client_credentials(anon_cred_c);\n        gnutls_global_deinit();\n    }\n#endif\n    return 0;\n}", "target": 1}
{"code": "void mlock_vma_page(struct page *page)\n{\n\tBUG_ON(!PageLocked(page));\n\tif (!TestSetPageMlocked(page)) {\n\t\tmod_zone_page_state(page_zone(page), NR_MLOCK,\n\t\t\t\t    hpage_nr_pages(page));\n\t\tcount_vm_event(UNEVICTABLE_PGMLOCKED);\n\t\tif (!isolate_lru_page(page))\n\t\t\tputback_lru_page(page);\n\t}\n}", "target": 0}
{"code": "        unsigned int GetU32LE (int nPos, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos + 3 >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            unsigned int nRes = m_sFile[nPos + 3];\n            nRes = (nRes << 8) + m_sFile[nPos + 2];\n            nRes = (nRes << 8) + m_sFile[nPos + 1];\n            nRes = (nRes << 8) + m_sFile[nPos + 0];\n            return nRes;\n        }", "target": 1}
{"code": "bdat_flush_data(void)\n{\nwhile (chunking_data_left)\n  {\n  unsigned n = chunking_data_left;\n  if (!bdat_getbuf(&n)) break;\n  }\nreceive_getc = lwr_receive_getc;\nreceive_getbuf = lwr_receive_getbuf;\nreceive_ungetc = lwr_receive_ungetc;\nif (chunking_state != CHUNKING_LAST)\n  {\n  chunking_state = CHUNKING_OFFERED;\n  DEBUG(D_receive) debug_printf(\"chunking state %d\\n\", (int)chunking_state);\n  }\n}", "target": 0}
{"code": "wb_prep(netdissect_options *ndo,\n        const struct pkt_prep *prep, u_int len)\n{\n\tint n;\n\tconst struct pgstate *ps;\n\tconst u_char *ep = ndo->ndo_snapend;\n\tND_PRINT((ndo, \" wb-prep:\"));\n\tif (len < sizeof(*prep)) {\n\t\treturn (-1);\n\t}\n\tn = EXTRACT_32BITS(&prep->pp_n);\n\tps = (const struct pgstate *)(prep + 1);\n\twhile (--n >= 0 && ND_TTEST(*ps)) {\n\t\tconst struct id_off *io, *ie;\n\t\tchar c = '<';\n\t\tND_PRINT((ndo, \" %u/%s:%u\",\n\t\t    EXTRACT_32BITS(&ps->slot),\n\t\t    ipaddr_string(ndo, &ps->page.p_sid),\n\t\t    EXTRACT_32BITS(&ps->page.p_uid)));\n\t\tio = (const struct id_off *)(ps + 1);\n\t\tfor (ie = io + ps->nid; io < ie && ND_TTEST(*io); ++io) {\n\t\t\tND_PRINT((ndo, \"%c%s:%u\", c, ipaddr_string(ndo, &io->id),\n\t\t\t    EXTRACT_32BITS(&io->off)));\n\t\t\tc = ',';\n\t\t}\n\t\tND_PRINT((ndo, \">\"));\n\t\tps = (const struct pgstate *)io;\n\t}\n\treturn ((const u_char *)ps <= ep? 0 : -1);\n}", "target": 1}
{"code": "static void construct_get_dest_keyring(struct key **_dest_keyring)\n{\n\tstruct request_key_auth *rka;\n\tconst struct cred *cred = current_cred();\n\tstruct key *dest_keyring = *_dest_keyring, *authkey;\n\tkenter(\"%p\", dest_keyring);\n\tif (dest_keyring) {\n\t\tkey_get(dest_keyring);\n\t} else {\n\t\tswitch (cred->jit_keyring) {\n\t\tcase KEY_REQKEY_DEFL_DEFAULT:\n\t\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\t\tif (cred->request_key_auth) {\n\t\t\t\tauthkey = cred->request_key_auth;\n\t\t\t\tdown_read(&authkey->sem);\n\t\t\t\trka = authkey->payload.data[0];\n\t\t\t\tif (!test_bit(KEY_FLAG_REVOKED,\n\t\t\t\t\t      &authkey->flags))\n\t\t\t\t\tdest_keyring =\n\t\t\t\t\t\tkey_get(rka->dest_keyring);\n\t\t\t\tup_read(&authkey->sem);\n\t\t\t\tif (dest_keyring)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\t\tdest_keyring = key_get(cred->thread_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\t\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\t\tdest_keyring = key_get(cred->process_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\t\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\t\t\trcu_read_lock();\n\t\t\tdest_keyring = key_get(\n\t\t\t\trcu_dereference(cred->session_keyring));\n\t\t\trcu_read_unlock();\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\t\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\t\t\tdest_keyring =\n\t\t\t\tkey_get(cred->user->session_keyring);\n\t\t\tbreak;\n\t\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\t\t\tdest_keyring = key_get(cred->user->uid_keyring);\n\t\t\tbreak;\n\t\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\t*_dest_keyring = dest_keyring;\n\tkleave(\" [dk %d]\", key_serial(dest_keyring));\n\treturn;\n}", "target": 1}
{"code": "zend_op_array *compile_string(zval *source_string, char *filename TSRMLS_DC)\n{\n\tzend_lex_state original_lex_state;\n\tzend_op_array *op_array = (zend_op_array *) emalloc(sizeof(zend_op_array));\n\tzend_op_array *original_active_op_array = CG(active_op_array);\n\tzend_op_array *retval;\n\tzval tmp;\n\tint compiler_result;\n\tzend_bool original_in_compilation = CG(in_compilation);\n\tif (source_string->value.str.len==0) {\n\t\tefree(op_array);\n\t\treturn NULL;\n\t}\n\tCG(in_compilation) = 1;\n\ttmp = *source_string;\n\tzval_copy_ctor(&tmp);\n\tconvert_to_string(&tmp);\n\tsource_string = &tmp;\n\tzend_save_lexical_state(&original_lex_state TSRMLS_CC);\n\tif (zend_prepare_string_for_scanning(source_string, filename TSRMLS_CC)==FAILURE) {\n\t\tefree(op_array);\n\t\tretval = NULL;\n\t} else {\n\t\tzend_bool orig_interactive = CG(interactive);\n\t\tCG(interactive) = 0;\n\t\tinit_op_array(op_array, ZEND_EVAL_CODE, INITIAL_OP_ARRAY_SIZE TSRMLS_CC);\n\t\tCG(interactive) = orig_interactive;\n\t\tCG(active_op_array) = op_array;\n\t\tzend_stack_push(&CG(context_stack), (void *) &CG(context), sizeof(CG(context)));\n\t\tzend_init_compiler_context(TSRMLS_C);\n\t\tBEGIN(ST_IN_SCRIPTING);\n\t\tcompiler_result = zendparse(TSRMLS_C);\n\t\tif (SCNG(script_filtered)) {\n\t\t\tefree(SCNG(script_filtered));\n\t\t\tSCNG(script_filtered) = NULL;\n\t\t}\n\t\tif (compiler_result==1) {\n\t\t\tCG(active_op_array) = original_active_op_array;\n\t\t\tCG(unclean_shutdown)=1;\n\t\t\tdestroy_op_array(op_array TSRMLS_CC);\n\t\t\tefree(op_array);\n\t\t\tretval = NULL;\n\t\t} else {\n\t\t\tzend_do_return(NULL, 0 TSRMLS_CC);\n\t\t\tCG(active_op_array) = original_active_op_array;\n\t\t\tpass_two(op_array TSRMLS_CC);\n\t\t\tzend_release_labels(0 TSRMLS_CC);\n\t\t\tretval = op_array;\n\t\t}\n\t}\n\tzend_restore_lexical_state(&original_lex_state TSRMLS_CC);\n\tzval_dtor(&tmp);\n\tCG(in_compilation) = original_in_compilation;\n\treturn retval;\n}", "target": 1}
{"code": "void preprocessNodes(std::vector<Proxy> &nodes, extra_settings &ext)\n{\n    std::for_each(nodes.begin(), nodes.end(), [&ext](Proxy &x)\n    {\n        if(ext.remove_emoji)\n            x.Remark = trim(removeEmoji(x.Remark));\n        nodeRename(x, ext.rename_array, ext);\n        if(ext.add_emoji)\n            x.Remark = addEmoji(x, ext.emoji_array, ext);\n    });\n    if(ext.sort_flag)\n    {\n        bool failed = true;\n        if(ext.sort_script.size())\n        {\n            std::string script = ext.sort_script;\n            if(startsWith(script, \"path:\"))\n                script = fileGet(script.substr(5), false);\n            script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)\n            {\n                try\n                {\n                    ctx.eval(script);\n                    auto compare = (std::function<int(const Proxy&, const Proxy&)>) ctx.eval(\"compare\");\n                    auto comparer = [&](const Proxy &a, const Proxy &b)\n                    {\n                        if(a.Type == ProxyType::Unknow)\n                            return 1;\n                        if(b.Type == ProxyType::Unknow)\n                            return 0;\n                        return compare(a, b);\n                    };\n                    std::stable_sort(nodes.begin(), nodes.end(), comparer);\n                    failed = false;\n                }\n                catch(qjs::exception)\n                {\n                    script_print_stack(ctx);\n                }\n            }, global.scriptCleanContext);\n        }\n        if(failed) std::stable_sort(nodes.begin(), nodes.end(), [](const Proxy &a, const Proxy &b)\n        {\n            return a.Remark < b.Remark;\n        });\n    }\n}", "target": 1}
{"code": "static int decode_level3_header(LHAFileHeader **header, LHAInputStream *stream)\n{\n\tunsigned int header_len;\n\tif (lha_decode_uint16(&RAW_DATA(header, 0)) != 4) {\n\t\treturn 0;\n\t}\n\tif (!extend_raw_data(header, stream,\n\t                     LEVEL_3_HEADER_LEN - RAW_DATA_LEN(header))) {\n\t\treturn 0;\n\t}\n\theader_len = lha_decode_uint32(&RAW_DATA(header, 24));\n\tif (header_len > LEVEL_3_MAX_HEADER_LEN) {\n\t\treturn 0;\n\t}\n\tif (!extend_raw_data(header, stream,\n\t                     header_len - RAW_DATA_LEN(header))) {\n\t\treturn 0;\n\t}\n\tmemcpy((*header)->compress_method, &RAW_DATA(header, 2), 5);\n\t(*header)->compress_method[5] = '\\0';\n\t(*header)->compressed_length = lha_decode_uint32(&RAW_DATA(header, 7));\n\t(*header)->length = lha_decode_uint32(&RAW_DATA(header, 11));\n\t(*header)->timestamp = lha_decode_uint32(&RAW_DATA(header, 15));\n\t(*header)->crc = lha_decode_uint16(&RAW_DATA(header, 21));\n\t(*header)->os_type = RAW_DATA(header, 23);\n\tif (!decode_extended_headers(header, 28)) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "NAN_METHOD(TxnWrap::putString) {\n    if (!info[2]->IsString())\n        return Nan::ThrowError(\"Value must be a string.\");\n    return putCommon(info, [](Nan::NAN_METHOD_ARGS_TYPE info, MDB_val &data) -> void {\n        CustomExternalStringResource::writeTo(Local<String>::Cast(info[2]), &data);\n    }, [](MDB_val &data) -> void {\n        delete[] (uint16_t*)data.mv_data;\n    });\n}", "target": 0}
{"code": "static int nci_extract_activation_params_iso_dep(struct nci_dev *ndev,\n\t\t\tstruct nci_rf_intf_activated_ntf *ntf, __u8 *data)\n{\n\tstruct activation_params_nfca_poll_iso_dep *nfca_poll;\n\tstruct activation_params_nfcb_poll_iso_dep *nfcb_poll;\n\tswitch (ntf->activation_rf_tech_and_mode) {\n\tcase NCI_NFC_A_PASSIVE_POLL_MODE:\n\t\tnfca_poll = &ntf->activation_params.nfca_poll_iso_dep;\n\t\tnfca_poll->rats_res_len = *data++;\n\t\tpr_debug(\"rats_res_len %d\\n\", nfca_poll->rats_res_len);\n\t\tif (nfca_poll->rats_res_len > 0) {\n\t\t\tmemcpy(nfca_poll->rats_res,\n\t\t\t       data, nfca_poll->rats_res_len);\n\t\t}\n\t\tbreak;\n\tcase NCI_NFC_B_PASSIVE_POLL_MODE:\n\t\tnfcb_poll = &ntf->activation_params.nfcb_poll_iso_dep;\n\t\tnfcb_poll->attrib_res_len = *data++;\n\t\tpr_debug(\"attrib_res_len %d\\n\", nfcb_poll->attrib_res_len);\n\t\tif (nfcb_poll->attrib_res_len > 0) {\n\t\t\tmemcpy(nfcb_poll->attrib_res,\n\t\t\t       data, nfcb_poll->attrib_res_len);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unsupported activation_rf_tech_and_mode 0x%x\\n\",\n\t\t       ntf->activation_rf_tech_and_mode);\n\t\treturn NCI_STATUS_RF_PROTOCOL_ERROR;\n\t}\n\treturn NCI_STATUS_OK;\n}", "target": 1}
{"code": "static inline struct blk_align_bitmap *get_bm(struct blk_mq_hw_ctx *hctx,\n\t\t\t\t\t      struct blk_mq_ctx *ctx)\n{\n\treturn &hctx->ctx_map.map[ctx->index_hw / hctx->ctx_map.bits_per_word];\n}", "target": 0}
{"code": "void PrintWebViewHelper::Print(WebKit::WebFrame* frame,\n                               const WebKit::WebNode& node) {\n  if (print_web_view_)\n    return;\n  scoped_ptr<PrepareFrameAndViewForPrint> prepare;\n  if (!InitPrintSettingsAndPrepareFrame(frame, node, &prepare)) {\n    DidFinishPrinting(FAIL_PRINT);\n    return;  \n  }\n  int expected_page_count = 0;\n  bool use_browser_overlays = true;\n  expected_page_count = prepare->GetExpectedPageCount();\n  if (expected_page_count)\n    use_browser_overlays = prepare->ShouldUseBrowserOverlays();\n  prepare.reset();\n  if (!expected_page_count) {\n    DidFinishPrinting(OK);  \n    return;\n  }\n  if (!GetPrintSettingsFromUser(frame, node, expected_page_count,\n                                use_browser_overlays)) {\n    DidFinishPrinting(OK);  \n    return;\n  }\n  if (!RenderPagesForPrint(frame, node, NULL)) {\n    LOG(ERROR) << \"RenderPagesForPrint failed\";\n    DidFinishPrinting(FAIL_PRINT);\n  }\n  ResetScriptedPrintCount();\n}", "target": 0}
{"code": "gdImageScaleTwoPass(const gdImagePtr src, const unsigned int new_width,\n                    const unsigned int new_height)\n{\n    const unsigned int src_width = src->sx;\n    const unsigned int src_height = src->sy;\n\tgdImagePtr tmp_im = NULL;\n\tgdImagePtr dst = NULL;\n    if (src_width == new_width && src_height == new_height) {\n        return gdImageClone(src);\n    }\n\tif (!src->trueColor) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n    if (src_width == new_width) {\n        tmp_im = src;\n    } else {\n        tmp_im = gdImageCreateTrueColor(new_width, src_height);\n        if (tmp_im == NULL) {\n            return NULL;\n        }\n        gdImageSetInterpolationMethod(tmp_im, src->interpolation_id);\n        _gdScalePass(src, src_width, tmp_im, new_width, src_height, HORIZONTAL);\n    }\n    if (src_height == new_height) {\n        assert(tmp_im != src);\n        return tmp_im;\n    }\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (dst != NULL) {\n        gdImageSetInterpolationMethod(dst, src->interpolation_id);\n        _gdScalePass(tmp_im, src_height, dst, new_height, new_width, VERTICAL);\n    }\n    if (src != tmp_im) {\n        gdFree(tmp_im);\n    }\n\treturn dst;\n}", "target": 1}
{"code": "static void set_last_stream_little_endian(AVFormatContext *fc)\n{\n    AVStream *st;\n    if (fc->nb_streams < 1)\n        return;\n    st = fc->streams[fc->nb_streams-1];\n    switch (st->codecpar->codec_id) {\n    case AV_CODEC_ID_PCM_S16BE:\n        st->codecpar->codec_id = AV_CODEC_ID_PCM_S16LE;\n        break;\n    case AV_CODEC_ID_PCM_S24BE:\n        st->codecpar->codec_id = AV_CODEC_ID_PCM_S24LE;\n        break;\n    case AV_CODEC_ID_PCM_S32BE:\n        st->codecpar->codec_id = AV_CODEC_ID_PCM_S32LE;\n        break;\n    case AV_CODEC_ID_PCM_F32BE:\n        st->codecpar->codec_id = AV_CODEC_ID_PCM_F32LE;\n        break;\n    case AV_CODEC_ID_PCM_F64BE:\n        st->codecpar->codec_id = AV_CODEC_ID_PCM_F64LE;\n        break;\n    default:\n        break;\n    }\n}", "target": 0}
{"code": "static bool can_skip_alu_sanitation(const struct bpf_verifier_env *env,\n\t\t\t\t    const struct bpf_insn *insn)\n{\n\treturn env->allow_ptr_leaks || BPF_SRC(insn->code) == BPF_K;\n}", "target": 0}
{"code": "u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport)\n{\n\tu32 hash[MD5_DIGEST_WORDS];\n\thash[0] = (__force u32)saddr;\n\thash[1] = (__force u32)daddr;\n\thash[2] = (__force u32)dport ^ net_secret[14];\n\thash[3] = net_secret[15];\n\tmd5_transform(hash, net_secret);\n\treturn hash[0];\n}", "target": 0}
{"code": "static void __iov_iter_advance_iov(struct iov_iter *i, size_t bytes)\n{\n\tif (likely(i->nr_segs == 1)) {\n\t\ti->iov_offset += bytes;\n\t} else {\n\t\tconst struct iovec *iov = i->iov;\n\t\tsize_t base = i->iov_offset;\n\t\twhile (bytes) {\n\t\t\tint copy = min(bytes, iov->iov_len - base);\n\t\t\tbytes -= copy;\n\t\t\tbase += copy;\n\t\t\tif (iov->iov_len == base) {\n\t\t\t\tiov++;\n\t\t\t\tbase = 0;\n\t\t\t}\n\t\t}\n\t\ti->iov = iov;\n\t\ti->iov_offset = base;\n\t}\n}", "target": 1}
{"code": "rfbHandleAuthResult(rfbClient* client)\n{\n    uint32_t authResult=0, reasonLen=0;\n    char *reason=NULL;\n    if (!ReadFromRFBServer(client, (char *)&authResult, 4)) return FALSE;\n    authResult = rfbClientSwap32IfLE(authResult);\n    switch (authResult) {\n    case rfbVncAuthOK:\n      rfbClientLog(\"VNC authentication succeeded\\n\");\n      return TRUE;\n      break;\n    case rfbVncAuthFailed:\n      if (client->major==3 && client->minor>7)\n      {\n        if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return FALSE;\n        reasonLen = rfbClientSwap32IfLE(reasonLen);\n        reason = malloc((uint64_t)reasonLen+1);\n        if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return FALSE; }\n        reason[reasonLen]=0;\n        rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n        free(reason);\n        return FALSE;\n      }\n      rfbClientLog(\"VNC authentication failed\\n\");\n      return FALSE;\n    case rfbVncAuthTooMany:\n      rfbClientLog(\"VNC authentication failed - too many tries\\n\");\n      return FALSE;\n    }\n    rfbClientLog(\"Unknown VNC authentication result: %d\\n\",\n                 (int)authResult);\n    return FALSE;\n}", "target": 1}
{"code": "int init_aliases(void)\n{\n    FILE *fp;\n    char alias[MAXALIASLEN + 1U];\n    char dir[PATH_MAX + 1U];\n    if ((fp = fopen(ALIASES_FILE, \"r\")) == NULL) {\n        return 0;\n    }\n    while (fgets(alias, sizeof alias, fp) != NULL) {\n        if (*alias == '#' || *alias == '\\n' || *alias == 0) {\n            continue;\n        }\n        {\n            char * const z = alias + strlen(alias) - 1U;\n            if (*z != '\\n') {\n                goto bad;\n            }\n            *z = 0;\n        }\n        do {\n            if (fgets(dir, sizeof dir, fp) == NULL || *dir == 0) {\n                goto bad;\n            }\n            {\n                char * const z = dir + strlen(dir) - 1U;\n                if (*z == '\\n') {\n                    *z = 0;\n                }\n            }\n        } while (*dir == '#' || *dir == 0);\n        if (head == NULL) {\n            if ((head = tail = malloc(sizeof *head)) == NULL ||\n                (tail->alias = strdup(alias)) == NULL ||\n                (tail->dir = strdup(dir)) == NULL) {\n                die_mem();\n            }\n            tail->next = NULL;\n        } else {\n            DirAlias *curr;\n            if ((curr = malloc(sizeof *curr)) == NULL ||\n                (curr->alias = strdup(alias)) == NULL ||\n                (curr->dir = strdup(dir)) == NULL) {\n                die_mem();\n            }\n            tail->next = curr;\n            tail = curr;\n        }\n    }\n    fclose(fp);\n    aliases_up++;\n    return 0;\n    bad:\n    fclose(fp);\n    logfile(LOG_ERR, MSG_ALIASES_BROKEN_FILE \" [\" ALIASES_FILE \"]\");\n    return -1;\n}", "target": 1}
{"code": "static int on_data_chunk_recv(nghttp2_session *session, uint8_t flags,\n                              int32_t stream_id, const uint8_t *data,\n                              size_t len, void *user_data)\n{\n    ogs_sbi_stream_t *stream = NULL;\n    ogs_sbi_request_t *request = NULL;\n    size_t offset = 0;\n    ogs_assert(session);\n    stream = nghttp2_session_get_stream_user_data(session, stream_id);\n    if (!stream) {\n        ogs_error(\"no stream [%d]\", stream_id);\n        return 0;\n    }\n    request = stream->request;\n    ogs_assert(request);\n    ogs_assert(data);\n    ogs_assert(len);\n    if (request->http.content == NULL) {\n        request->http.content_length = len;\n        request->http.content =\n            (char*)ogs_malloc(request->http.content_length + 1);\n        ogs_assert(request->http.content);\n    } else {\n        offset = request->http.content_length;\n        if ((request->http.content_length + len) > OGS_HUGE_LEN) {\n            ogs_error(\"Overflow : Content-Length[%d], len[%d]\",\n                        (int)request->http.content_length, (int)len);\n            ogs_assert_if_reached();\n        }\n        request->http.content_length += len;\n        request->http.content = (char *)ogs_realloc(\n                request->http.content, request->http.content_length + 1);\n        ogs_assert(request->http.content);\n    }\n    memcpy(request->http.content + offset, data, len);\n    request->http.content[request->http.content_length] = '\\0';\n    return 0;\n}", "target": 1}
{"code": "void CommandData::ParseArg(wchar *Arg)\n{\n  if (IsSwitch(*Arg) && !NoMoreSwitches)\n    if (Arg[1]=='-' && Arg[2]==0)\n      NoMoreSwitches=true;\n    else\n      ProcessSwitch(Arg+1);\n  else\n    if (*Command==0)\n    {\n      wcsncpy(Command,Arg,ASIZE(Command));\n      *Command=toupperw(*Command);\n      if (*Command!='I' && *Command!='S')\n        wcsupper(Command);\n    }\n    else\n      if (*ArcName==0)\n        wcsncpyz(ArcName,Arg,ASIZE(ArcName));\n      else\n      {\n        size_t Length=wcslen(Arg);\n        wchar EndChar=Length==0 ? 0:Arg[Length-1];\n        bool EndSeparator=IsDriveDiv(EndChar) || IsPathDiv(EndChar);\n        wchar CmdChar=toupperw(*Command);\n        bool Add=wcschr(L\"AFUM\",CmdChar)!=NULL;\n        bool Extract=CmdChar=='X' || CmdChar=='E';\n        if (EndSeparator && !Add)\n          wcsncpyz(ExtrPath,Arg,ASIZE(ExtrPath));\n        else\n          if ((Add || CmdChar=='T') && (*Arg!='@' || ListMode==RCLM_REJECT_LISTS))\n            FileArgs.AddString(Arg);\n          else\n          {\n            FindData FileData;\n            bool Found=FindFile::FastFind(Arg,&FileData);\n            if ((!Found || ListMode==RCLM_ACCEPT_LISTS) && \n                ListMode!=RCLM_REJECT_LISTS && *Arg=='@' && !IsWildcard(Arg))\n            {\n              FileLists=true;\n              ReadTextFile(Arg+1,&FileArgs,false,true,FilelistCharset,true,true,true);\n            }\n            else\n              if (Found && FileData.IsDir && Extract && *ExtrPath==0)\n              {\n                wcsncpyz(ExtrPath,Arg,ASIZE(ExtrPath));\n                AddEndSlash(ExtrPath,ASIZE(ExtrPath));\n              }\n              else\n                FileArgs.AddString(Arg);\n          }\n      }\n}", "target": 1}
{"code": "static char* get_private_subtags(const char* loc_name)\n{\n\tchar* \tresult =NULL;\n\tint \tsingletonPos = 0;\n\tint \tlen =0; \n\tconst char* \tmod_loc_name =NULL;\n\tif( loc_name && (len = strlen(loc_name)>0 ) ){\n\t\tmod_loc_name = loc_name ; \n\t\tlen   = strlen(mod_loc_name);\n\t\twhile( (singletonPos = getSingletonPos(mod_loc_name))!= -1){\n\t\t\tif( singletonPos!=-1){ \n\t\t\t\tif( (*(mod_loc_name+singletonPos)=='x') || (*(mod_loc_name+singletonPos)=='X') ){\t\t\n\t\t\t\t\tif( singletonPos + 2 ==  len){\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tresult = estrndup(mod_loc_name + singletonPos+2  , (len -( singletonPos +2) ) );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif( singletonPos + 1 >=  len){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmod_loc_name = mod_loc_name + singletonPos +1;\n\t\t\t\t\t\tlen = strlen(mod_loc_name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t}\n\treturn result;\n}", "target": 1}
{"code": "int ip_options_get(struct net *net, struct ip_options **optp,\n\t\t   unsigned char *data, int optlen)\n{\n\tstruct ip_options *opt = ip_options_get_alloc(optlen);\n\tif (!opt)\n\t\treturn -ENOMEM;\n\tif (optlen)\n\t\tmemcpy(opt->__data, data, optlen);\n\treturn ip_options_get_finish(net, optp, opt, optlen);\n}", "target": 1}
{"code": "_clone_pdu_header(netsnmp_pdu *pdu)\n{\n    netsnmp_pdu    *newpdu;\n    struct snmp_secmod_def *sptr;\n    int ret;\n    if (!pdu)\n        return NULL;\n    newpdu = (netsnmp_pdu *) malloc(sizeof(netsnmp_pdu));\n    if (!newpdu)\n        return NULL;\n    memmove(newpdu, pdu, sizeof(netsnmp_pdu));\n    newpdu->variables = NULL;\n    newpdu->enterprise = NULL;\n    newpdu->community = NULL;\n    newpdu->securityEngineID = NULL;\n    newpdu->securityName = NULL;\n    newpdu->contextEngineID = NULL;\n    newpdu->contextName = NULL;\n    newpdu->transport_data = NULL;\n    if (snmp_clone_mem((void **) &newpdu->enterprise, pdu->enterprise,\n                       sizeof(oid) * pdu->enterprise_length) ||\n        snmp_clone_mem((void **) &newpdu->community, pdu->community,\n                       pdu->community_len) ||\n        snmp_clone_mem((void **) &newpdu->contextEngineID,\n                       pdu->contextEngineID, pdu->contextEngineIDLen)\n        || snmp_clone_mem((void **) &newpdu->securityEngineID,\n                          pdu->securityEngineID, pdu->securityEngineIDLen)\n        || snmp_clone_mem((void **) &newpdu->contextName, pdu->contextName,\n                          pdu->contextNameLen)\n        || snmp_clone_mem((void **) &newpdu->securityName,\n                          pdu->securityName, pdu->securityNameLen)\n        || snmp_clone_mem((void **) &newpdu->transport_data,\n                          pdu->transport_data,\n                          pdu->transport_data_length)) {\n        snmp_free_pdu(newpdu);\n        return NULL;\n    }\n    if (pdu->securityStateRef &&\n        pdu->command == SNMP_MSG_TRAP2) {\n        netsnmp_assert(pdu->securityModel == SNMP_DEFAULT_SECMODEL);\n        ret = usm_clone_usmStateReference((struct usmStateReference *) pdu->securityStateRef,\n                (struct usmStateReference **) &newpdu->securityStateRef );\n        if (ret)\n        {\n            snmp_free_pdu(newpdu);\n            return NULL;\n        }\n    }\n    if ((sptr = find_sec_mod(newpdu->securityModel)) != NULL &&\n        sptr->pdu_clone != NULL) {\n        (*sptr->pdu_clone) (pdu, newpdu);\n    }\n    return newpdu;\n}", "target": 1}
{"code": "int main(int argc, char **argv)\n{\n    gdImagePtr im;\n    FILE *fp = gdTestFileOpen(\"tga/bug00247a.tga\");\n    im = gdImageCreateFromTga(fp);\n    gdTestAssert(im == NULL);\n    fclose(fp);\n    return gdNumFailures();\n}", "target": 0}
{"code": "kdc_process_for_user(kdc_realm_t *kdc_active_realm,\n                     krb5_pa_data *pa_data,\n                     krb5_keyblock *tgs_session,\n                     krb5_pa_s4u_x509_user **s4u_x509_user,\n                     const char **status)\n{\n    krb5_error_code             code;\n    krb5_pa_for_user            *for_user;\n    krb5_data                   req_data;\n    req_data.length = pa_data->length;\n    req_data.data = (char *)pa_data->contents;\n    code = decode_krb5_pa_for_user(&req_data, &for_user);\n    if (code)\n        return code;\n    code = verify_for_user_checksum(kdc_context, tgs_session, for_user);\n    if (code) {\n        *status = \"INVALID_S4U2SELF_CHECKSUM\";\n        krb5_free_pa_for_user(kdc_context, for_user);\n        return code;\n    }\n    *s4u_x509_user = calloc(1, sizeof(krb5_pa_s4u_x509_user));\n    if (*s4u_x509_user == NULL) {\n        krb5_free_pa_for_user(kdc_context, for_user);\n        return ENOMEM;\n    }\n    (*s4u_x509_user)->user_id.user = for_user->user;\n    for_user->user = NULL;\n    krb5_free_pa_for_user(kdc_context, for_user);\n    return 0;\n}", "target": 1}
{"code": "#else\n    static int input  (yyscan_t yyscanner)\n#endif\n{\n\tint c;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\t*yyg->yy_c_buf_p = yyg->yy_hold_char;\n\tif ( *yyg->yy_c_buf_p == YY_END_OF_BUFFER_CHAR )\n\t\t{\n\t\tif ( yyg->yy_c_buf_p < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )\n\t\t\t*yyg->yy_c_buf_p = '\\0';\n\t\telse\n\t\t\t{ \n\t\t\tyy_size_t offset = yyg->yy_c_buf_p - yyg->yytext_ptr;\n\t\t\t++yyg->yy_c_buf_p;\n\t\t\tswitch ( yy_get_next_buffer( yyscanner ) )\n\t\t\t\t{\n\t\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\t\tre_yyrestart(yyin ,yyscanner);\n\t\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t\t{\n\t\t\t\t\tif ( re_yywrap(yyscanner ) )\n\t\t\t\t\t\treturn EOF;\n\t\t\t\t\tif ( ! yyg->yy_did_buffer_switch_on_eof )\n\t\t\t\t\t\tYY_NEW_FILE;\n#ifdef __cplusplus\n\t\t\t\t\treturn yyinput(yyscanner);\n#else\n\t\t\t\t\treturn input(yyscanner);\n#endif\n\t\t\t\t\t}\n\t\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + offset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tc = *(unsigned char *) yyg->yy_c_buf_p;\t\n\t*yyg->yy_c_buf_p = '\\0';\t\n\tyyg->yy_hold_char = *++yyg->yy_c_buf_p;\n\tif ( c == '\\n' )\n    do{ yylineno++;\n        yycolumn=0;\n    }while(0)\n;\n\treturn c;", "target": 1}
{"code": "unsigned long _copy_from_user(void *to, const void __user *from, unsigned long n)\n{\n\tunsigned long res = n;\n\tmight_fault();\n\tif (!should_fail_usercopy() && likely(access_ok(from, n))) {\n\t\tbarrier_nospec();\n\t\tinstrument_copy_from_user_before(to, from, n);\n\t\tres = raw_copy_from_user(to, from, n);\n\t\tinstrument_copy_from_user_after(to, from, n, res);\n\t}\n\tif (unlikely(res))\n\t\tmemset(to + (n - res), 0, res);\n\treturn res;\n}", "target": 0}
{"code": "static FORCEINLINE NEDMALLOCNOALIASATTR NEDMALLOCPTRATTR void *CallMalloc(void *RESTRICT mspace, size_t size, size_t alignment, unsigned flags) THROWSPEC\n{\n\tvoid *RESTRICT ret=0;\n#if USE_MAGIC_HEADERS\n\tsize_t _alignment=alignment;\n\tsize_t *_ret=0;\n\tsize+=alignment+3*sizeof(size_t);\n\t_alignment=0;\n#endif\n#if USE_ALLOCATOR==0\n\tret=(flags & M2_ZERO_MEMORY) ? syscalloc(1, size) : sysmalloc(size);\t\n#elif USE_ALLOCATOR==1\n\tret=mspace_malloc2((mstate) mspace, size, alignment, flags);\n#ifndef ENABLE_FAST_HEAP_DETECTION\n\tif(ret)\n\t{\n\t\tmchunkptr p=mem2chunk(ret);\n\t\tsize_t truesize=chunksize(p) - overhead_for(p);\n\t\tif(!leastusedaddress || (void *)((mstate) mspace)->least_addr<leastusedaddress) leastusedaddress=(void *)((mstate) mspace)->least_addr;\n\t\tif(!largestusedblock || truesize>largestusedblock) largestusedblock=(truesize+mparams.page_size) & ~(mparams.page_size-1);\n\t}\n#endif\n#endif\n\tif(!ret) return 0;\n#if DEBUG\n\tif(flags & M2_ZERO_MEMORY)\n\t{\n\t\tconst char *RESTRICT n;\n\t\tfor(n=(const char *)ret; n<(const char *)ret+size; n++)\n\t\t{\n\t\t\tassert(!*n);\n\t\t}\n\t}\n#endif\n#if USE_MAGIC_HEADERS\n\t_ret=(size_t *) ret;\n\tret=(void *)(_ret+3);\n\tif(alignment) ret=(void *)(((size_t) ret+alignment-1)&~(alignment-1));\n\tfor(; _ret<(size_t *)ret-2; _ret++) *_ret=*(size_t *)\"NEDMALOC\";\n\t_ret[0]=(size_t) mspace;\n\t_ret[1]=size-3*sizeof(size_t);\n#endif\n\treturn ret;\n}", "target": 1}
{"code": "int unit_name_path_escape(const char *f, char **ret) {\n        char *p, *s;\n        assert(f);\n        assert(ret);\n        p = strdupa(f);\n        if (!p)\n                return -ENOMEM;\n        path_simplify(p);\n        if (empty_or_root(p))\n                s = strdup(\"-\");\n        else {\n                if (!path_is_normalized(p))\n                        return -EINVAL;\n                delete_trailing_chars(p, \"/\");\n                p = skip_leading_chars(p, \"/\");\n                s = unit_name_escape(p);\n        }\n        if (!s)\n                return -ENOMEM;\n        *ret = s;\n        return 0;\n}", "target": 1}
{"code": "struct dns_https_param *dns_get_HTTPS_svcparm_start(struct dns_rrs *rrs, char *domain, int maxsize, int *ttl,\n\t\t\t\t\t\t\t\t\t\t\t\t\tint *priority, char *target, int target_size)\n{\n\tint qtype = 0;\n\tunsigned char *data = NULL;\n\tint rr_len = 0;\n\tdata = dns_get_rr_nested_start(rrs, domain, maxsize, &qtype, ttl, &rr_len);\n\tif (data == NULL) {\n\t\treturn NULL;\n\t}\n\tif (qtype != DNS_T_HTTPS) {\n\t\treturn NULL;\n\t}\n\tif (rr_len < 2) {\n\t\treturn NULL;\n\t}\n\t*priority = _dns_read_short(&data);\n\trr_len -= 2;\n\tif (rr_len <= 0) {\n\t\treturn NULL;\n\t}\n\tint len = strnlen((char *)data, rr_len);\n\tsafe_strncpy(target, (char *)data, target_size);\n\tdata += len + 1;\n\trr_len -= len + 1;\n\tif (rr_len <= 0) {\n\t\treturn NULL;\n\t}\n\treturn (struct dns_https_param *)data;\n}", "target": 1}
{"code": "nfs4_open_revalidate(struct inode *dir, struct dentry *dentry, int openflags, struct nameidata *nd)\n{\n\tstruct path path = {\n\t\t.mnt = nd->path.mnt,\n\t\t.dentry = dentry,\n\t};\n\tstruct rpc_cred *cred;\n\tstruct nfs4_state *state;\n\tcred = rpc_lookup_cred();\n\tif (IS_ERR(cred))\n\t\treturn PTR_ERR(cred);\n\tstate = nfs4_do_open(dir, &path, openflags, NULL, cred);\n\tput_rpccred(cred);\n\tif (IS_ERR(state)) {\n\t\tswitch (PTR_ERR(state)) {\n\t\t\tcase -EPERM:\n\t\t\tcase -EACCES:\n\t\t\tcase -EDQUOT:\n\t\t\tcase -ENOSPC:\n\t\t\tcase -EROFS:\n\t\t\t\tlookup_instantiate_filp(nd, (struct dentry *)state, NULL);\n\t\t\t\treturn 1;\n\t\t\tdefault:\n\t\t\t\tgoto out_drop;\n\t\t}\n\t}\n\tif (state->inode == dentry->d_inode) {\n\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\tnfs4_intent_set_file(nd, &path, state);\n\t\treturn 1;\n\t}\n\tnfs4_close_sync(&path, state, openflags);\nout_drop:\n\td_drop(dentry);\n\treturn 0;\n}", "target": 1}
{"code": "mwifiex_set_wmm_params(struct mwifiex_private *priv,\n\t\t       struct mwifiex_uap_bss_param *bss_cfg,\n\t\t       struct cfg80211_ap_settings *params)\n{\n\tconst u8 *vendor_ie;\n\tconst u8 *wmm_ie;\n\tu8 wmm_oui[] = {0x00, 0x50, 0xf2, 0x02};\n\tvendor_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t    WLAN_OUI_TYPE_MICROSOFT_WMM,\n\t\t\t\t\t    params->beacon.tail,\n\t\t\t\t\t    params->beacon.tail_len);\n\tif (vendor_ie) {\n\t\twmm_ie = vendor_ie;\n\t\tif (*(wmm_ie + 1) > sizeof(struct mwifiex_types_wmm_info))\n\t\t\treturn;\n\t\tmemcpy(&bss_cfg->wmm_info, wmm_ie +\n\t\t       sizeof(struct ieee_types_header), *(wmm_ie + 1));\n\t\tpriv->wmm_enabled = 1;\n\t} else {\n\t\tmemset(&bss_cfg->wmm_info, 0, sizeof(bss_cfg->wmm_info));\n\t\tmemcpy(&bss_cfg->wmm_info.oui, wmm_oui, sizeof(wmm_oui));\n\t\tbss_cfg->wmm_info.subtype = MWIFIEX_WMM_SUBTYPE;\n\t\tbss_cfg->wmm_info.version = MWIFIEX_WMM_VERSION;\n\t\tpriv->wmm_enabled = 0;\n\t}\n\tbss_cfg->qos_info = 0x00;\n\treturn;\n}", "target": 0}
{"code": "static long ioctl_file_dedupe_range(struct file *file, void __user *arg)\n{\n\tstruct file_dedupe_range __user *argp = arg;\n\tstruct file_dedupe_range *same = NULL;\n\tint ret;\n\tunsigned long size;\n\tu16 count;\n\tif (get_user(count, &argp->dest_count)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\tsize = offsetof(struct file_dedupe_range __user, info[count]);\n\tsame = memdup_user(argp, size);\n\tif (IS_ERR(same)) {\n\t\tret = PTR_ERR(same);\n\t\tsame = NULL;\n\t\tgoto out;\n\t}\n\tsame->dest_count = count;\n\tret = vfs_dedupe_file_range(file, same);\n\tif (ret)\n\t\tgoto out;\n\tret = copy_to_user(argp, same, size);\n\tif (ret)\n\t\tret = -EFAULT;\nout:\n\tkfree(same);\n\treturn ret;\n}", "target": 0}
{"code": "cifs_put_tcp_session(struct TCP_Server_Info *server, int from_reconnect)\n{\n\tstruct task_struct *task;\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--server->srv_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\tWARN_ON(server->srv_count < 0);\n\tput_net(cifs_net_ns(server));\n\tlist_del_init(&server->tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\tif (CIFS_SERVER_IS_CHAN(server))\n\t\tcifs_put_tcp_session(server->primary_server, from_reconnect);\n\tcancel_delayed_work_sync(&server->echo);\n\tcancel_delayed_work_sync(&server->resolve);\n\tif (from_reconnect)\n\t\tcancel_delayed_work(&server->reconnect);\n\telse\n\t\tcancel_delayed_work_sync(&server->reconnect);\n\tspin_lock(&server->srv_lock);\n\tserver->tcpStatus = CifsExiting;\n\tspin_unlock(&server->srv_lock);\n\tcifs_crypto_secmech_release(server);\n\tkfree_sensitive(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\tkfree(server->hostname);\n\tserver->hostname = NULL;\n\ttask = xchg(&server->tsk, NULL);\n\tif (task)\n\t\tsend_sig(SIGKILL, task, 1);\n}", "target": 0}
{"code": "int mount_proc_if_needed(const char *rootfs)\n{\n\tchar path[MAXPATHLEN];\n\tchar link[20];\n\tint linklen, ret;\n\tint mypid;\n\tret = snprintf(path, MAXPATHLEN, \"%s/proc/self\", rootfs);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"proc path name too long\");\n\t\treturn -1;\n\t}\n\tmemset(link, 0, 20);\n\tlinklen = readlink(path, link, 20);\n\tmypid = (int)getpid();\n\tINFO(\"I am %d, /proc/self points to '%s'\", mypid, link);\n\tret = snprintf(path, MAXPATHLEN, \"%s/proc\", rootfs);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"proc path name too long\");\n\t\treturn -1;\n\t}\n\tif (linklen < 0) \n\t\tgoto domount;\n\tif (atoi(link) != mypid) {\n\t\tumount2(path, MNT_DETACH); \n\t\tgoto domount;\n\t}\n\treturn 0;\ndomount:\n\tif (mount(\"proc\", path, \"proc\", 0, NULL))\n\t\treturn -1;\n\tINFO(\"Mounted /proc in container for security transition\");\n\treturn 1;\n}", "target": 1}
{"code": "int dns_add_rr_nested_memcpy(struct dns_rr_nested *rr_nested, void *data, int data_len)\n{\n\tif (rr_nested == NULL || data == NULL || data_len <= 0) {\n\t\treturn -1;\n\t}\n\tif (_dns_left_len(&rr_nested->context) < data_len) {\n\t\treturn -1;\n\t}\n\tmemcpy(rr_nested->context.ptr, data, data_len);\n\trr_nested->context.ptr += data_len;\n\treturn 0;\n}", "target": 1}
{"code": "uint64_t ldq_be_phys(AddressSpace *as, hwaddr addr)\n{\n    return address_space_ldq_be(as, addr, MEMTXATTRS_UNSPECIFIED, NULL);\n}", "target": 0}
{"code": "static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {\n\tRDyldCache *cache = R_NEW0 (RDyldCache);\n\tmemcpy (cache->magic, \"dyldcac\", 7);\n\tcache->buf = r_buf_ref (buf);\n\tpopulate_cache_headers (cache);\n\tif (!cache->hdr) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}\n\tpopulate_cache_maps (cache);\n\tif (!cache->maps) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}\n\tcache->accel = read_cache_accel (cache->buf, cache->hdr, cache->maps);\n\tcache->bins = create_cache_bins (bf, cache);\n\tif (!cache->bins) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}\n\tcache->locsym = r_dyld_locsym_new (cache);\n\tcache->rebase_infos = get_rebase_infos (bf, cache);\n\tif (cache->rebase_infos) {\n\t\tif (!rebase_infos_get_slide (cache)) {\n\t\t\tif (!pending_bin_files) {\n\t\t\t\tpending_bin_files = r_list_new ();\n\t\t\t\tif (!pending_bin_files) {\n\t\t\t\t\tr_dyldcache_free (cache);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_list_push (pending_bin_files, bf);\n\t\t\tswizzle_io_read (cache, bf->rbin->iob.io);\n\t\t}\n\t}\n\t*bin_obj = cache;\n\treturn true;\n}", "target": 1}
{"code": "vg_send_msg(VuGpu *vg, const VhostUserGpuMsg *msg, int fd)\n{\n    if (vg_sock_fd_write(vg->sock_fd, msg,\n                         VHOST_USER_GPU_HDR_SIZE + msg->size, fd) < 0) {\n        vg_sock_fd_close(vg);\n    }\n}", "target": 0}
{"code": "static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_cipher rcipher;\n\tsnprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"cipher\");\n\trcipher.blocksize = alg->cra_blocksize;\n\trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\n\trcipher.max_keysize = alg->cra_cipher.cia_max_keysize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,\n\t\t    sizeof(struct crypto_report_cipher), &rcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "    uint32_t TiffEntryBase::doSizeImage() const\n    {\n        return 0;\n    } ", "target": 0}
{"code": "nfs_printfh(netdissect_options *ndo,\n            register const uint32_t *dp, const u_int len)\n{\n\tmy_fsid fsid;\n\tuint32_t ino;\n\tconst char *sfsname = NULL;\n\tchar *spacep;\n\tif (ndo->ndo_uflag) {\n\t\tu_int i;\n\t\tchar const *sep = \"\";\n\t\tND_PRINT((ndo, \" fh[\"));\n\t\tfor (i=0; i<len; i++) {\n\t\t\tND_PRINT((ndo, \"%s%x\", sep, dp[i]));\n\t\t\tsep = \":\";\n\t\t}\n\t\tND_PRINT((ndo, \"]\"));\n\t\treturn;\n\t}\n\tParse_fh((const u_char *)dp, len, &fsid, &ino, NULL, &sfsname, 0);\n\tif (sfsname) {\n\t\tstatic char temp[NFSX_V3FHMAX+1];\n\t\tstrncpy(temp, sfsname, NFSX_V3FHMAX);\n\t\ttemp[sizeof(temp) - 1] = '\\0';\n\t\tspacep = strchr(temp, ' ');\n\t\tif (spacep)\n\t\t\t*spacep = '\\0';\n\t\tND_PRINT((ndo, \" fh %s/\", temp));\n\t} else {\n\t\tND_PRINT((ndo, \" fh %d,%d/\",\n\t\t\t     fsid.Fsid_dev.Major, fsid.Fsid_dev.Minor));\n\t}\n\tif(fsid.Fsid_dev.Minor == 257)\n\t\tND_PRINT((ndo, \"%s\", fsid.Opaque_Handle));\n\telse\n\t\tND_PRINT((ndo, \"%ld\", (long) ino));\n}", "target": 1}
{"code": "void HTPStateFree(void *state)\n{\n    SCEnter();\n    HtpState *s = (HtpState *)state;\n    if (s == NULL) {\n        SCReturn;\n    }\n    if (s->connp != NULL) {\n        SCLogDebug(\"freeing HTP state\");\n        uint64_t tx_id;\n        uint64_t total_txs = HTPStateGetTxCnt(state);\n        if (s->conn != NULL) {\n            for (tx_id = 0; tx_id < total_txs; tx_id++) {\n                htp_tx_t *tx = HTPStateGetTx(s, tx_id);\n                if (tx != NULL) {\n                    HtpTxUserData *htud = (HtpTxUserData *) htp_tx_get_user_data(tx);\n                    HtpTxUserDataFree(s, htud);\n                    htp_tx_set_user_data(tx, NULL);\n                }\n            }\n        }\n        htp_connp_destroy_all(s->connp);\n    }\n    FileContainerFree(s->files_ts);\n    FileContainerFree(s->files_tc);\n    HTPFree(s, sizeof(HtpState));\n#ifdef DEBUG\n    SCMutexLock(&htp_state_mem_lock);\n    htp_state_memcnt--;\n    htp_state_memuse -= sizeof(HtpState);\n    SCLogDebug(\"htp memory %\"PRIu64\" (%\"PRIu64\")\", htp_state_memuse, htp_state_memcnt);\n    SCMutexUnlock(&htp_state_mem_lock);\n#endif\n    SCReturn;\n}", "target": 1}
{"code": "void pb_controller::play_file(const std::string& file) {\n\tstd::string cmdline;\n\tstd::string player = cfg->get_configvalue(\"player\");\n\tif (player == \"\")\n\t\treturn;\n\tcmdline.append(player);\n\tcmdline.append(\" \\\"\");\n\tcmdline.append(utils::replace_all(file,\"\\\"\", \"\\\\\\\"\"));\n\tcmdline.append(\"\\\"\");\n\tstfl::reset();\n\tLOG(LOG_DEBUG, \"pb_controller::play_file: running `%s'\", cmdline.c_str());\n\t::system(cmdline.c_str());\n}", "target": 1}
{"code": "void rose_start_hbtimer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tdel_timer(&rose->timer);\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->hb;\n\tadd_timer(&rose->timer);\n}", "target": 1}
{"code": "static inline int use_cpu_reloc(struct drm_i915_gem_object *obj)\n{\n\treturn (obj->base.write_domain == I915_GEM_DOMAIN_CPU ||\n\t\t!obj->map_and_fenceable ||\n\t\tobj->cache_level != I915_CACHE_NONE);\n}", "target": 0}
{"code": "    static size_t size() {\n      return ConstSingleton<StaticLookupTable>::get().size_;\n    }", "target": 0}
{"code": "int cg_mkdir(const char *path, mode_t mode)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tchar *fpath = NULL, *path1, *cgdir = NULL, *controller;\n\tconst char *cgroup;\n\tint ret;\n\tif (!fc)\n\t\treturn -EIO;\n\tcontroller = pick_controller_from_path(fc, path);\n\tif (!controller)\n\t\treturn -EINVAL;\n\tcgroup = find_cgroup_in_path(path);\n\tif (!cgroup)\n\t\treturn -EINVAL;\n\tget_cgdir_and_path(cgroup, &cgdir, &fpath);\n\tif (!fpath)\n\t\tpath1 = \"/\";\n\telse\n\t\tpath1 = cgdir;\n\tif (!fc_may_access(fc, controller, path1, NULL, O_RDWR)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tif (!caller_is_in_ancestor(fc->pid, controller, path1, NULL)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tret = cgfs_create(controller, cgroup, fc->uid, fc->gid);\n\tprintf(\"cgfs_create returned %d for %s %s\\n\", ret, controller, cgroup);\nout:\n\tfree(cgdir);\n\treturn ret;\n}", "target": 1}
{"code": "static void get_icu_value_src_php( char* tag_name, INTERNAL_FUNCTION_PARAMETERS) \n{\n\tconst char* loc_name        \t= NULL;\n\tint         loc_name_len    \t= 0;\n\tchar*       tag_value\t\t= NULL;\n\tchar*       empty_result\t= \"\";\n\tint         result    \t\t= 0;\n\tchar*       msg        \t\t= NULL;\n\tUErrorCode  status          \t= U_ZERO_ERROR;\n\tintl_error_reset( NULL TSRMLS_CC );\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"s\",\n\t&loc_name ,&loc_name_len ) == FAILURE) {\n\t\tspprintf(&msg , 0, \"locale_get_%s : unable to parse input params\", tag_name );\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,  msg , 1 TSRMLS_CC );\n\t\tefree(msg);\n\t\tRETURN_FALSE;\n    }\n\tif(loc_name_len == 0) {\n\t\tloc_name = intl_locale_get_default(TSRMLS_C);\n\t}\n\ttag_value = get_icu_value_internal( loc_name , tag_name , &result ,0);\n\tif( result == -1 ) {\n\t\tif( tag_value){\n\t\t\tefree( tag_value);\n\t\t}\n\t\tRETURN_STRING( empty_result , TRUE);\n\t}\n\tif( tag_value){\n\t\tRETURN_STRING( tag_value , FALSE);\n\t}\n\tif( result ==0) {\n\t\tspprintf(&msg , 0, \"locale_get_%s : unable to get locale %s\", tag_name , tag_name );\n\t\tintl_error_set( NULL, status, msg , 1 TSRMLS_CC );\n\t\tefree(msg);\n\t\tRETURN_NULL();\n\t}\n}", "target": 1}
{"code": "ossl_cipher_pkcs5_keyivgen(int argc, VALUE *argv, VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n    const EVP_MD *digest;\n    VALUE vpass, vsalt, viter, vdigest;\n    unsigned char key[EVP_MAX_KEY_LENGTH], iv[EVP_MAX_IV_LENGTH], *salt = NULL;\n    int iter;\n    rb_scan_args(argc, argv, \"13\", &vpass, &vsalt, &viter, &vdigest);\n    StringValue(vpass);\n    if(!NIL_P(vsalt)){\n\tStringValue(vsalt);\n\tif(RSTRING_LEN(vsalt) != PKCS5_SALT_LEN)\n\t    ossl_raise(eCipherError, \"salt must be an 8-octet string\");\n\tsalt = (unsigned char *)RSTRING_PTR(vsalt);\n    }\n    iter = NIL_P(viter) ? 2048 : NUM2INT(viter);\n    digest = NIL_P(vdigest) ? EVP_md5() : GetDigestPtr(vdigest);\n    GetCipher(self, ctx);\n    EVP_BytesToKey(EVP_CIPHER_CTX_cipher(ctx), digest, salt,\n\t\t   (unsigned char *)RSTRING_PTR(vpass), RSTRING_LENINT(vpass), iter, key, iv);\n    if (EVP_CipherInit_ex(ctx, NULL, NULL, key, iv, -1) != 1)\n\tossl_raise(eCipherError, NULL);\n    OPENSSL_cleanse(key, sizeof key);\n    OPENSSL_cleanse(iv, sizeof iv);\n    rb_ivar_set(self, id_key_set, Qtrue);\n    return Qnil;\n}", "target": 0}
{"code": "pidfile_write(const char *pid_file, int pid)\n{\n\tFILE *pidfile = NULL;\n\tint pidfd = creat(pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\tif (pidfd != -1) pidfile = fdopen(pidfd, \"w\");\n\tif (!pidfile) {\n\t\tlog_message(LOG_INFO, \"pidfile_write : Cannot open %s pidfile\",\n\t\t       pid_file);\n\t\treturn 0;\n\t}\n\tfprintf(pidfile, \"%d\\n\", pid);\n\tfclose(pidfile);\n\treturn 1;\n}", "target": 1}
{"code": "static inline struct rb_node *first_fair(struct cfs_rq *cfs_rq)\n{\n\treturn cfs_rq->rb_leftmost;\n}", "target": 0}
{"code": "Status IndexedDBDatabase::DeleteIndexOperation(\n    int64_t object_store_id,\n    int64_t index_id,\n    IndexedDBTransaction* transaction) {\n  IDB_TRACE1(\n      \"IndexedDBDatabase::DeleteIndexOperation\", \"txn.id\", transaction->id());\n  IndexedDBIndexMetadata index_metadata =\n      RemoveIndex(object_store_id, index_id);\n  Status s = metadata_coding_->DeleteIndex(\n      transaction->BackingStoreTransaction()->transaction(),\n      transaction->database()->id(), object_store_id, index_metadata);\n  if (!s.ok())\n    return s;\n  s = backing_store_->ClearIndex(transaction->BackingStoreTransaction(),\n                                 transaction->database()->id(), object_store_id,\n                                 index_id);\n  if (!s.ok()) {\n    AddIndex(object_store_id, std::move(index_metadata),\n             IndexedDBIndexMetadata::kInvalidId);\n    return s;\n  }\n  transaction->ScheduleAbortTask(\n      base::BindOnce(&IndexedDBDatabase::DeleteIndexAbortOperation, this,\n                     object_store_id, std::move(index_metadata)));\n  return s;\n}", "target": 0}
{"code": "static int crypto_pcomp_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rpcomp;\n\tsnprintf(rpcomp.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"pcomp\");\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n\t\t    sizeof(struct crypto_report_comp), &rpcomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "bgp_capability_receive (struct peer *peer, bgp_size_t size)\n{\n  u_char *pnt;\n  int ret;\n  pnt = stream_pnt (peer->ibuf);\n  if (BGP_DEBUG (normal, NORMAL))\n    zlog_debug (\"%s rcv CAPABILITY\", peer->host);\n  if (! CHECK_FLAG (peer->cap, PEER_CAP_DYNAMIC_ADV))\n    {\n      plog_err (peer->log, \"%s [Error] BGP dynamic capability is not enabled\",\n\t\tpeer->host);\n      bgp_notify_send (peer,\n\t\t       BGP_NOTIFY_HEADER_ERR,\n\t\t       BGP_NOTIFY_HEADER_BAD_MESTYPE);\n      return;\n    }\n  if (peer->status != Established)\n    {\n      plog_err (peer->log,\n\t\t\"%s [Error] Dynamic capability packet received under status %s\", peer->host, LOOKUP (bgp_status_msg, peer->status));\n      bgp_notify_send (peer, BGP_NOTIFY_FSM_ERR, 0);\n      return;\n    }\n  ret = bgp_capability_msg_parse (peer, pnt, size);\n}", "target": 1}
{"code": "TRIO_PUBLIC trio_pointer_t trio_register TRIO_ARGS2((callback, name), trio_callback_t callback,\n                                                    TRIO_CONST char* name)\n{\n\ttrio_userdef_t* def;\n\ttrio_userdef_t* prev = NULL;\n\tif (callback == NULL)\n\t\treturn NULL;\n\tif (name)\n\t{\n\t\tif (name[0] == ':')\n\t\t{\n\t\t\tif (trio_equal(name, \":enter\"))\n\t\t\t{\n\t\t\t\tinternalEnterCriticalRegion = callback;\n\t\t\t}\n\t\t\telse if (trio_equal(name, \":leave\"))\n\t\t\t{\n\t\t\t\tinternalLeaveCriticalRegion = callback;\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\tif (trio_length(name) >= MAX_USER_NAME)\n\t\t\treturn NULL;\n\t\tdef = TrioFindNamespace(name, &prev);\n\t\tif (def)\n\t\t\treturn NULL;\n\t}\n\tdef = (trio_userdef_t*)TRIO_MALLOC(sizeof(trio_userdef_t));\n\tif (def)\n\t{\n\t\tif (internalEnterCriticalRegion)\n\t\t\t(void)internalEnterCriticalRegion(NULL);\n\t\tif (name)\n\t\t{\n\t\t\tif (prev == NULL)\n\t\t\t\tinternalUserDef = def;\n\t\t\telse\n\t\t\t\tprev->next = def;\n\t\t}\n\t\tdef->callback = callback;\n\t\tdef->name = (name == NULL) ? NULL : trio_duplicate(name);\n\t\tdef->next = NULL;\n\t\tif (internalLeaveCriticalRegion)\n\t\t\t(void)internalLeaveCriticalRegion(NULL);\n\t}\n\treturn (trio_pointer_t)def;\n}", "target": 1}
{"code": "static inline bool nested_cpu_has_posted_intr(struct vmcs12 *vmcs12)\n{\n\treturn vmcs12->pin_based_vm_exec_control & PIN_BASED_POSTED_INTR;\n}", "target": 0}
{"code": "static void vmcs_set_bits(unsigned long field, u32 mask)\n{\n\tvmcs_writel(field, vmcs_readl(field) | mask);\n}", "target": 0}
{"code": "static int virtio_net_set_vnet_endian_one(VirtIODevice *vdev,\n                                          NetClientState *peer,\n                                          bool enable)\n{\n    if (virtio_is_big_endian(vdev)) {\n        return qemu_set_vnet_be(peer, enable);\n    } else {\n        return qemu_set_vnet_le(peer, enable);\n    }\n}", "target": 0}
{"code": "ikev2_sa_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext1,\n\t\tu_int osa_length, const u_char *ep,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth)\n{\n\tconst struct isakmp_gen *ext;\n\tstruct isakmp_gen e;\n\tu_int sa_length;\n\tconst u_char *cp;\n\tint i;\n\tint pcount;\n\tu_char np;\n\tu_int item_len;\n\tND_TCHECK(*ext1);\n\tUNALIGNED_MEMCPY(&e, ext1, sizeof(e));\n\tikev2_pay_print(ndo, \"sa\", e.critical);\n\tosa_length= ntohs(e.len);\n\tsa_length = osa_length - 4;\n\tND_PRINT((ndo,\" len=%d\", sa_length));\n\tcp = (const u_char *)(ext1 + 1);\n\tpcount = 0;\n\tfor (np = ISAKMP_NPTYPE_P; np != 0; np = e.np) {\n\t\tpcount++;\n\t\text = (const struct isakmp_gen *)cp;\n\t\tif (sa_length < sizeof(*ext))\n\t\t\tgoto toolong;\n\t\tND_TCHECK(*ext);\n\t\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\t\titem_len = ntohs(e.len);\n\t\tif (item_len <= 4)\n\t\t\tgoto trunc;\n\t\tif (sa_length < item_len)\n\t\t\tgoto toolong;\n\t\tND_TCHECK2(*cp, item_len);\n\t\tdepth++;\n\t\tND_PRINT((ndo,\"\\n\"));\n\t\tfor (i = 0; i < depth; i++)\n\t\t\tND_PRINT((ndo,\"    \"));\n\t\tND_PRINT((ndo,\"(\"));\n\t\tif (np == ISAKMP_NPTYPE_P) {\n\t\t\tcp = ikev2_p_print(ndo, np, pcount, ext, item_len,\n\t\t\t\t\t   ep, depth);\n\t\t\tif (cp == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"%s\", NPSTR(np)));\n\t\t\tcp += item_len;\n\t\t}\n\t\tND_PRINT((ndo,\")\"));\n\t\tdepth--;\n\t\tsa_length -= item_len;\n\t}\n\treturn cp;\ntoolong:\n\tcp += sa_length;\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn cp;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 1}
{"code": "static Quantum *GetAuthenticPixelsCache(Image *image,const ssize_t x,\n  const ssize_t y,const size_t columns,const size_t rows,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n  const int\n    id = GetOpenMPThreadId();\n  Quantum\n    *magick_restrict pixels;\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  if (cache_info == (Cache) NULL)\n    return((Quantum *) NULL);\n  assert(cache_info->signature == MagickCoreSignature);\n  assert(id < (int) cache_info->number_threads);\n  pixels=GetAuthenticPixelCacheNexus(image,x,y,columns,rows,\n    cache_info->nexus_info[id],exception);\n  return(pixels);\n}", "target": 0}
{"code": "static int xfrm_dump_policy_start(struct netlink_callback *cb)\n{\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;\n\tBUILD_BUG_ON(sizeof(*walk) > sizeof(cb->args));\n\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\n\treturn 0;\n}", "target": 0}
{"code": "static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, const char *lxcpath)\n{\n\tint ret;\n\tsize_t clen;\n\tchar *path;\n\tINFO(\"Mounting container /dev\");\n\tclen = (rootfs->path ? strlen(rootfs->mount) : 0) + 9;\n\tpath = alloca(clen);\n\tret = snprintf(path, clen, \"%s/dev\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= clen)\n\t\treturn -1;\n\tif (!dir_exists(path)) {\n\t\tWARN(\"No /dev in container.\");\n\t\tWARN(\"Proceeding without autodev setup\");\n\t\treturn 0;\n\t}\n\tif (mount(\"none\", path, \"tmpfs\", 0, \"size=100000,mode=755\")) {\n\t\tSYSERROR(\"Failed mounting tmpfs onto %s\\n\", path);\n\t\treturn false;\n\t}\n\tINFO(\"Mounted tmpfs onto %s\",  path);\n\tret = snprintf(path, clen, \"%s/dev/pts\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= clen)\n\t\treturn -1;\n\tif (!dir_exists(path)) {\n\t\tret = mkdir(path, S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);\n\t\tif (ret) {\n\t\t\tSYSERROR(\"Failed to create /dev/pts in container\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tINFO(\"Mounted container /dev\");\n\treturn 0;\n}", "target": 1}
{"code": "static ssize_t yurex_read(struct file *file, char __user *buffer, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct usb_yurex *dev;\n\tint retval = 0;\n\tint bytes_read = 0;\n\tchar in_buffer[20];\n\tunsigned long flags;\n\tdev = file->private_data;\n\tmutex_lock(&dev->io_mutex);\n\tif (!dev->interface) {\t\t\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\tspin_lock_irqsave(&dev->lock, flags);\n\tbytes_read = snprintf(in_buffer, 20, \"%lld\\n\", dev->bbu);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\tif (*ppos < bytes_read) {\n\t\tif (copy_to_user(buffer, in_buffer + *ppos, bytes_read - *ppos))\n\t\t\tretval = -EFAULT;\n\t\telse {\n\t\t\tretval = bytes_read - *ppos;\n\t\t\t*ppos += bytes_read;\n\t\t}\n\t}\nexit:\n\tmutex_unlock(&dev->io_mutex);\n\treturn retval;\n}", "target": 1}
{"code": "void zend_extension_dtor(zend_extension *extension)\n{\n#if ZEND_EXTENSIONS_SUPPORT && !ZEND_DEBUG\n\tif (extension->handle) {\n\t\tDL_UNLOAD(extension->handle);\n\t}\n#endif\n}", "target": 0}
{"code": "static int omninet_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct usb_serial\t*serial = port->serial;\n\tstruct usb_serial_port\t*wport;\n\twport = serial->port[1];\n\ttty_port_tty_set(&wport->port, tty);\n\treturn usb_serial_generic_open(tty, port);\n}", "target": 1}
{"code": "  base::WaitableEvent* event() { return event_.get(); }", "target": 0}
{"code": "archive_read_format_cpio_read_data(struct archive_read *a,\n    const void **buff, size_t *size, int64_t *offset)\n{\n\tssize_t bytes_read;\n\tstruct cpio *cpio;\n\tcpio = (struct cpio *)(a->format->data);\n\tif (cpio->entry_bytes_unconsumed) {\n\t\t__archive_read_consume(a, cpio->entry_bytes_unconsumed);\n\t\tcpio->entry_bytes_unconsumed = 0;\n\t}\n\tif (cpio->entry_bytes_remaining > 0) {\n\t\t*buff = __archive_read_ahead(a, 1, &bytes_read);\n\t\tif (bytes_read <= 0)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tif (bytes_read > cpio->entry_bytes_remaining)\n\t\t\tbytes_read = (ssize_t)cpio->entry_bytes_remaining;\n\t\t*size = bytes_read;\n\t\tcpio->entry_bytes_unconsumed = bytes_read;\n\t\t*offset = cpio->entry_offset;\n\t\tcpio->entry_offset += bytes_read;\n\t\tcpio->entry_bytes_remaining -= bytes_read;\n\t\treturn (ARCHIVE_OK);\n\t} else {\n\t\tif (cpio->entry_padding !=\n\t\t\t__archive_read_consume(a, cpio->entry_padding)) {\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tcpio->entry_padding = 0;\n\t\t*buff = NULL;\n\t\t*size = 0;\n\t\t*offset = cpio->entry_offset;\n\t\treturn (ARCHIVE_EOF);\n\t}\n}", "target": 0}
{"code": "snmp_engine(unsigned char *buff, uint32_t buff_len, unsigned char *out, uint32_t *out_len)\n{\n  static snmp_header_t header;\n  static snmp_varbind_t varbinds[SNMP_MAX_NR_VALUES];\n  static uint32_t varbind_length = SNMP_MAX_NR_VALUES;\n  buff = snmp_message_decode(buff, buff_len, &header, varbinds, &varbind_length);\n  if(buff == NULL) {\n    return NULL;\n  }\n  if(header.version != SNMP_VERSION_1) {\n    if(strncmp(header.community.community, SNMP_COMMUNITY, header.community.length)) {\n      LOG_ERR(\"Request with invalid community\\n\");\n      return NULL;\n    }\n  }\n  switch(header.pdu_type) {\n  case SNMP_DATA_TYPE_PDU_GET_REQUEST:\n    if(snmp_engine_get(&header, varbinds, varbind_length) == -1) {\n      return NULL;\n    }\n    break;\n  case SNMP_DATA_TYPE_PDU_GET_NEXT_REQUEST:\n    if(snmp_engine_get_next(&header, varbinds, varbind_length) == -1) {\n      return NULL;\n    }\n    break;\n  case SNMP_DATA_TYPE_PDU_GET_BULK:\n    if(snmp_engine_get_bulk(&header, varbinds, &varbind_length) == -1) {\n      return NULL;\n    }\n    break;\n  default:\n    LOG_ERR(\"Invalid request type\");\n    return NULL;\n  }\n  header.pdu_type = SNMP_DATA_TYPE_PDU_GET_RESPONSE;\n  out = snmp_message_encode(out, out_len, &header, varbinds, varbind_length);\n  return ++out;\n}", "target": 1}
{"code": "  Number_Ptr Parser::lexed_dimension(const ParserState& pstate, const std::string& parsed)\n  {\n    size_t L = parsed.length();\n    size_t num_pos = parsed.find_first_not_of(\" \\n\\r\\t\");\n    if (num_pos == std::string::npos) num_pos = L;\n    size_t unit_pos = parsed.find_first_not_of(\"-+0123456789.\", num_pos);\n    if (parsed[unit_pos] == 'e' && is_number(parsed[unit_pos+1]) ) {\n      unit_pos = parsed.find_first_not_of(\"-+0123456789.\", ++ unit_pos);\n    }\n    if (unit_pos == std::string::npos) unit_pos = L;\n    const std::string& num = parsed.substr(num_pos, unit_pos - num_pos);\n    Number_Ptr nr = SASS_MEMORY_NEW(Number,\n                                    pstate,\n                                    sass_strtod(num.c_str()),\n                                    Token(number(parsed.c_str())),\n                                    number_has_zero(parsed));\n    nr->is_interpolant(false);\n    nr->is_delayed(true);\n    return nr;\n  }", "target": 0}
{"code": "static inline int mpeg4_get_dc_length(int level, int n)\n{\n    if (n < 4)\n        return uni_DCtab_lum_len[level + 256];\n    else\n        return uni_DCtab_chrom_len[level + 256];\n}", "target": 0}
{"code": "void SSH_init(PTInstVar pvar)\n{\n\tint i;\n\tbuf_create(&pvar->ssh_state.outbuf, &pvar->ssh_state.outbuflen);\n\tbuf_create(&pvar->ssh_state.precompress_outbuf,\n\t           &pvar->ssh_state.precompress_outbuflen);\n\tbuf_create(&pvar->ssh_state.postdecompress_inbuf,\n\t           &pvar->ssh_state.postdecompress_inbuflen);\n\tpvar->ssh_state.payload = NULL;\n\tpvar->ssh_state.compressing = FALSE;\n\tpvar->ssh_state.decompressing = FALSE;\n\tpvar->ssh_state.status_flags =\n\t\tSTATUS_DONT_SEND_USER_NAME | STATUS_DONT_SEND_CREDENTIALS;\n\tpvar->ssh_state.payload_datalen = 0;\n\tpvar->ssh_state.hostname = NULL;\n\tpvar->ssh_state.server_ID = NULL;\n\tpvar->ssh_state.receiver_sequence_number = 0;\n\tpvar->ssh_state.sender_sequence_number = 0;\n\tfor (i = 0; i < NUM_ELEM(pvar->ssh_state.packet_handlers); i++) {\n\t\tpvar->ssh_state.packet_handlers[i] = NULL;\n\t}\n\tmemset(pvar->ssh2_keys, 0, sizeof(pvar->ssh2_keys));\n\tpvar->userauth_success = 0;\n\tpvar->shell_id = SSH_CHANNEL_INVALID;\n\tpvar->session_nego_status = 0;\n\tpvar->settings.ssh_protocol_version = 2;  \n\tpvar->kex_status = 0;\n\tpvar->ssh2_autologin = 0;  \n\tpvar->ask4passwd = 0; \n\tpvar->userauth_retry_count = 0;\n\tpvar->decomp_buffer = NULL;\n\tpvar->authbanner_buffer = NULL;\n\tpvar->ssh2_authlist = NULL; \n\tpvar->tryed_ssh2_authlist = FALSE;\n\tpvar->agentfwd_enable = FALSE;\n\tpvar->use_subsystem = FALSE;\n\tpvar->nosession = FALSE;\n\tpvar->server_sig_algs = NULL;\n\tpvar->server_strict_kex = FALSE;\n}", "target": 0}
{"code": "void RtmpProtocol::reset() {\n    _chunk_size_in = DEFAULT_CHUNK_LEN;\n    _chunk_size_out = DEFAULT_CHUNK_LEN;\n    _bytes_sent = 0;\n    _bytes_sent_last = 0;\n    _windows_size = 0;\n    _bandwidth = 2500000;\n    _band_limit_type = 2;\n    _map_chunk_data.clear();\n    _now_stream_index = 0;\n    _now_chunk_id = 0;\n    _send_req_id = 0;\n    HttpRequestSplitter::reset();\n    _stream_index = STREAM_CONTROL;\n    _next_step_func = [this](const char *data, size_t len) {\n        return handle_C0C1(data, len);\n    };\n}", "target": 0}
{"code": "static int sctp_getsockopt_assoc_stats(struct sock *sk, int len,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       int __user *optlen)\n{\n\tstruct sctp_assoc_stats sas;\n\tstruct sctp_association *asoc = NULL;\n\tif (len < sizeof(sctp_assoc_t))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&sas, optval, len))\n\t\treturn -EFAULT;\n\tasoc = sctp_id2assoc(sk, sas.sas_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\tsas.sas_rtxchunks = asoc->stats.rtxchunks;\n\tsas.sas_gapcnt = asoc->stats.gapcnt;\n\tsas.sas_outofseqtsns = asoc->stats.outofseqtsns;\n\tsas.sas_osacks = asoc->stats.osacks;\n\tsas.sas_isacks = asoc->stats.isacks;\n\tsas.sas_octrlchunks = asoc->stats.octrlchunks;\n\tsas.sas_ictrlchunks = asoc->stats.ictrlchunks;\n\tsas.sas_oodchunks = asoc->stats.oodchunks;\n\tsas.sas_iodchunks = asoc->stats.iodchunks;\n\tsas.sas_ouodchunks = asoc->stats.ouodchunks;\n\tsas.sas_iuodchunks = asoc->stats.iuodchunks;\n\tsas.sas_idupchunks = asoc->stats.idupchunks;\n\tsas.sas_opackets = asoc->stats.opackets;\n\tsas.sas_ipackets = asoc->stats.ipackets;\n\tsas.sas_maxrto = asoc->stats.max_obs_rto;\n\tmemcpy(&sas.sas_obs_rto_ipaddr, &asoc->stats.obs_rto_ipaddr,\n\t\tsizeof(struct sockaddr_storage));\n\tasoc->stats.max_obs_rto = asoc->rto_min;\n\tlen = min_t(size_t, len, sizeof(sas));\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tSCTP_DEBUG_PRINTK(\"sctp_getsockopt_assoc_stat(%d): %d\\n\",\n\t\t\t  len, sas.sas_assoc_id);\n\tif (copy_to_user(optval, &sas, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)\n{\n\tstruct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;\n\tstruct tipc_aead_key *skey = NULL;\n\tu16 key_gen = msg_key_gen(hdr);\n\tu16 size = msg_data_sz(hdr);\n\tu8 *data = msg_data(hdr);\n\tspin_lock(&rx->lock);\n\tif (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {\n\t\tpr_err(\"%s: key existed <%p>, gen %d vs %d\\n\", rx->name,\n\t\t       rx->skey, key_gen, rx->key_gen);\n\t\tgoto exit;\n\t}\n\tskey = kmalloc(size, GFP_ATOMIC);\n\tif (unlikely(!skey)) {\n\t\tpr_err(\"%s: unable to allocate memory for skey\\n\", rx->name);\n\t\tgoto exit;\n\t}\n\tskey->keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));\n\tmemcpy(skey->alg_name, data, TIPC_AEAD_ALG_NAME);\n\tmemcpy(skey->key, data + TIPC_AEAD_ALG_NAME + sizeof(__be32),\n\t       skey->keylen);\n\tif (unlikely(size != tipc_aead_key_size(skey))) {\n\t\tkfree(skey);\n\t\tskey = NULL;\n\t\tgoto exit;\n\t}\n\trx->key_gen = key_gen;\n\trx->skey_mode = msg_key_mode(hdr);\n\trx->skey = skey;\n\trx->nokey = 0;\n\tmb(); \nexit:\n\tspin_unlock(&rx->lock);\n\tif (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))\n\t\treturn true;\n\treturn false;\n}", "target": 1}
{"code": "    bool read(ReadonlyBytes buffer)\n    {\n        auto fields_size = sizeof(CentralDirectoryRecord) - (sizeof(u8*) * 3);\n        if (buffer.size() < fields_size)\n            return false;\n        if (memcmp(buffer.data(), central_directory_record_signature, sizeof(central_directory_record_signature)) != 0)\n            return false;\n        memcpy(reinterpret_cast<void*>(&made_by_version), buffer.data() + sizeof(central_directory_record_signature), fields_size);\n        name = buffer.data() + sizeof(central_directory_record_signature) + fields_size;\n        extra_data = name + name_length;\n        comment = extra_data + extra_data_length;\n        return true;\n    }", "target": 1}
{"code": "int bad_format(\n    char *fmt)\n{\n    char     *ptr;\n    int       n = 0;\n    ptr = fmt;\n    while (*ptr != '\\0')\n        if (*ptr++ == '%') {\n            if (*ptr == '\\0')\n                return 1;\n            if (*ptr == 's' || *ptr == 'S' || *ptr == '%')\n                ptr++;\n            else if (*ptr == 'c') {\n                ptr++;\n                n = 1;\n            }\n            else {\n                if (*ptr == ' ' || *ptr == '+' || *ptr == '-')\n                    ptr++;\n                while (*ptr >= '0' && *ptr <= '9')\n                    ptr++;\n                if (*ptr == '.')\n                    ptr++;\n                while (*ptr >= '0' && *ptr <= '9')\n                    ptr++;\n                if (*ptr++ != 'l')\n                    return 1;\n                if (*ptr == 'e' || *ptr == 'f' || *ptr == 'g')\n                    ptr++;\n                else\n                    return 1;\n                n++;\n            }\n        }\n    return (n != 1);\n}", "target": 1}
{"code": "static int atusb_get_and_show_revision(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tunsigned char buffer[3];\n\tint ret;\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuffer, 3, 1000);\n\tif (ret >= 0) {\n\t\tatusb->fw_ver_maj = buffer[0];\n\t\tatusb->fw_ver_min = buffer[1];\n\t\tatusb->fw_hw_type = buffer[2];\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware: major: %u, minor: %u, hardware type: %u\\n\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min, atusb->fw_hw_type);\n\t}\n\tif (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 2) {\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware version (%u.%u) predates our first public release.\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min);\n\t\tdev_info(&usb_dev->dev, \"Please update to version 0.2 or newer\");\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static void srpt_handle_tsk_mgmt(struct srpt_rdma_ch *ch,\n\t\t\t\t struct srpt_recv_ioctx *recv_ioctx,\n\t\t\t\t struct srpt_send_ioctx *send_ioctx)\n{\n\tstruct srp_tsk_mgmt *srp_tsk;\n\tstruct se_cmd *cmd;\n\tstruct se_session *sess = ch->sess;\n\tuint64_t unpacked_lun;\n\tuint32_t tag = 0;\n\tint tcm_tmr;\n\tint rc;\n\tBUG_ON(!send_ioctx);\n\tsrp_tsk = recv_ioctx->ioctx.buf;\n\tcmd = &send_ioctx->cmd;\n\tpr_debug(\"recv tsk_mgmt fn %d for task_tag %lld and cmd tag %lld\"\n\t\t \" cm_id %p sess %p\\n\", srp_tsk->tsk_mgmt_func,\n\t\t srp_tsk->task_tag, srp_tsk->tag, ch->cm_id, ch->sess);\n\tsrpt_set_cmd_state(send_ioctx, SRPT_STATE_MGMT);\n\tsend_ioctx->cmd.tag = srp_tsk->tag;\n\ttcm_tmr = srp_tmr_to_tcm(srp_tsk->tsk_mgmt_func);\n\tif (tcm_tmr < 0) {\n\t\tsend_ioctx->cmd.se_tmr_req->response =\n\t\t\tTMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED;\n\t\tgoto fail;\n\t}\n\tunpacked_lun = srpt_unpack_lun((uint8_t *)&srp_tsk->lun,\n\t\t\t\t       sizeof(srp_tsk->lun));\n\tif (srp_tsk->tsk_mgmt_func == SRP_TSK_ABORT_TASK) {\n\t\trc = srpt_rx_mgmt_fn_tag(send_ioctx, srp_tsk->task_tag);\n\t\tif (rc < 0) {\n\t\t\tsend_ioctx->cmd.se_tmr_req->response =\n\t\t\t\t\tTMR_TASK_DOES_NOT_EXIST;\n\t\t\tgoto fail;\n\t\t}\n\t\ttag = srp_tsk->task_tag;\n\t}\n\trc = target_submit_tmr(&send_ioctx->cmd, sess, NULL, unpacked_lun,\n\t\t\t\tsrp_tsk, tcm_tmr, GFP_KERNEL, tag,\n\t\t\t\tTARGET_SCF_ACK_KREF);\n\tif (rc != 0) {\n\t\tsend_ioctx->cmd.se_tmr_req->response = TMR_FUNCTION_REJECTED;\n\t\tgoto fail;\n\t}\n\treturn;\nfail:\n\ttransport_send_check_condition_and_sense(cmd, 0, 0); \n}", "target": 1}
{"code": "snmp_oid_print(uint32_t *oid)\n{\n  uint8_t i;\n  i = 0;\n  LOG_DBG(\"{\");\n  while(oid[i] != ((uint32_t)-1)) {\n    LOG_DBG_(\"%lu\", (unsigned long)oid[i]);\n    i++;\n    if(oid[i] != ((uint32_t)-1)) {\n      LOG_DBG_(\".\");\n    }\n  }\n  LOG_DBG_(\"}\\n\");\n}", "target": 1}
{"code": "void infra_wait_limit_inc(struct infra_cache* infra, struct comm_reply* rep,\n\ttime_t timenow, struct config_file* cfg)\n{\n\tstruct lruhash_entry* entry;\n\tif(cfg->wait_limit == 0)\n\t\treturn;\n\tentry = infra_find_ip_ratedata(infra, &rep->client_addr,\n\t\trep->client_addrlen, 1);\n\tif(entry) {\n\t\tstruct rate_data* d = (struct rate_data*)entry->data;\n\t\td->mesh_wait++;\n\t\tlock_rw_unlock(&entry->lock);\n\t\treturn;\n\t}\n\tinfra_ip_create_ratedata(infra, &rep->client_addr,\n\t\trep->client_addrlen, timenow, 1);\n}", "target": 0}
{"code": "bool do_memory_ranges_overlap(size_t range1Start, size_t range1End, size_t range2Start, size_t range2End) {\n  if (range1Start <= range2Start) {\n    return range2Start < range1End;\n  } else {\n    return range1Start < range2End;\n  }\n}", "target": 0}
{"code": "static int ida_checks(void)\n{\n\tIDA_BUG_ON(&ida, !ida_is_empty(&ida));\n\tida_check_alloc(&ida);\n\tida_check_destroy(&ida);\n\tida_check_leaf(&ida, 0);\n\tida_check_leaf(&ida, 1024);\n\tida_check_leaf(&ida, 1024 * 64);\n\tida_check_max(&ida);\n\tida_check_conv(&ida);\n\tida_check_bad_free(&ida);\n\tprintk(\"IDA: %u of %u tests passed\\n\", tests_passed, tests_run);\n\treturn (tests_run != tests_passed) ? 0 : -EINVAL;\n}", "target": 0}
{"code": "ExpressionMap::ExpressionMap(ExpressionContext* const expCtx,\n                             const string& varName,\n                             Variables::Id varId,\n                             intrusive_ptr<Expression> input,\n                             intrusive_ptr<Expression> each)\n    : Expression(expCtx, {std::move(input), std::move(each)}),\n      _varName(varName),\n      _varId(varId),\n      _input(_children[0]),\n      _each(_children[1]) {}", "target": 0}
{"code": "TfLiteStatus AverageEval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLitePoolParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n  switch (input->type) {  \n    case kTfLiteFloat32:\n      return AverageEvalFloat<kernel_type>(context, node, params, data, input,\n                                           output);\n    case kTfLiteUInt8:\n      return AverageEvalQuantizedUint8<kernel_type>(context, node, params, data,\n                                                    input, output);\n    case kTfLiteInt8:\n      return AverageEvalQuantizedInt8<kernel_type>(context, node, params, data,\n                                                   input, output);\n    case kTfLiteInt16:\n      return AverageEvalQuantizedInt16<kernel_type>(context, node, params, data,\n                                                    input, output);\n    default:\n      TF_LITE_KERNEL_LOG(context, \"Type %s not currently supported.\",\n                         TfLiteTypeGetName(input->type));\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "gplotAddPlot(GPLOT       *gplot,\n             NUMA        *nax,\n             NUMA        *nay,\n             l_int32      plotstyle,\n             const char  *plottitle)\n{\nchar       buf[L_BUF_SIZE];\nchar       emptystring[] = \"\";\nchar      *datastr, *title;\nl_int32    n, i;\nl_float32  valx, valy, startx, delx;\nSARRAY    *sa;\n    PROCNAME(\"gplotAddPlot\");\n    if (!gplot)\n        return ERROR_INT(\"gplot not defined\", procName, 1);\n    if (!nay)\n        return ERROR_INT(\"nay not defined\", procName, 1);\n    if (plotstyle < 0 || plotstyle >= NUM_GPLOT_STYLES)\n        return ERROR_INT(\"invalid plotstyle\", procName, 1);\n    if ((n = numaGetCount(nay)) == 0)\n        return ERROR_INT(\"no points to plot\", procName, 1);\n    if (nax && (n != numaGetCount(nax)))\n        return ERROR_INT(\"nax and nay sizes differ\", procName, 1);\n    if (n == 1 && plotstyle == GPLOT_LINES) {\n        L_INFO(\"only 1 pt; changing style to points\\n\", procName);\n        plotstyle = GPLOT_POINTS;\n    }\n    numaGetParameters(nay, &startx, &delx);\n    numaAddNumber(gplot->plotstyles, plotstyle);\n    if (plottitle) {\n        title = stringNew(plottitle);\n        sarrayAddString(gplot->plottitles, title, L_INSERT);\n    } else {\n        sarrayAddString(gplot->plottitles, emptystring, L_COPY);\n    }\n    gplot->nplots++;\n    snprintf(buf, L_BUF_SIZE, \"%s.data.%d\", gplot->rootname, gplot->nplots);\n    sarrayAddString(gplot->datanames, buf, L_COPY);\n    sa = sarrayCreate(n);\n    for (i = 0; i < n; i++) {\n        if (nax)\n            numaGetFValue(nax, i, &valx);\n        else\n            valx = startx + i * delx;\n        numaGetFValue(nay, i, &valy);\n        snprintf(buf, L_BUF_SIZE, \"%f %f\\n\", valx, valy);\n        sarrayAddString(sa, buf, L_COPY);\n    }\n    datastr = sarrayToString(sa, 0);\n    sarrayAddString(gplot->plotdata, datastr, L_INSERT);\n    sarrayDestroy(&sa);\n    return 0;\n}", "target": 1}
{"code": "static long gethugepagesize(const char *path, Error **errp)\n{\n    struct statfs fs;\n    int ret;\n    do {\n        ret = statfs(path, &fs);\n    } while (ret != 0 && errno == EINTR);\n    if (ret != 0) {\n        error_setg_errno(errp, errno, \"failed to get page size of file %s\",\n                         path);\n        return 0;\n    }\n    if (fs.f_type != HUGETLBFS_MAGIC)\n        fprintf(stderr, \"Warning: path not on HugeTLBFS: %s\\n\", path);\n    return fs.f_bsize;\n}", "target": 0}
{"code": "static inline unsigned long nested_read_cr4(struct vmcs12 *fields)\n{\n\treturn (fields->guest_cr4 & ~fields->cr4_guest_host_mask) |\n\t\t(fields->cr4_read_shadow & fields->cr4_guest_host_mask);\n}", "target": 0}
{"code": "static bool IsAudible(const AudioBus* rendered_data) {\n  float energy = 0;\n  uint32_t data_size = rendered_data->length();\n  for (uint32_t k = 0; k < rendered_data->NumberOfChannels(); ++k) {\n    const float* data = rendered_data->Channel(k)->Data();\n    float channel_energy;\n    vector_math::Vsvesq(data, 1, &channel_energy, data_size);\n    energy += channel_energy;\n  }\n  return energy > 0;\n}", "target": 0}
{"code": "static bool ndp_msg_addrto_validate_link_local(struct in6_addr *addr)\n{\n\treturn IN6_IS_ADDR_LINKLOCAL (addr);\n}", "target": 0}
{"code": "int string_rfind(const char *input, int len, const char *s, int s_len,\n                 int pos, bool case_sensitive) {\n  assertx(input);\n  assertx(s);\n  if (!s_len || pos < -len || pos > len) {\n    return -1;\n  }\n  void *ptr;\n  if (case_sensitive) {\n    if (pos >= 0) {\n      ptr = bstrrstr(input + pos, len - pos, s, s_len);\n    } else {\n      ptr = bstrrstr(input, len + pos + s_len, s, s_len);\n    }\n  } else {\n    if (pos >= 0) {\n      ptr = bstrrcasestr(input + pos, len - pos, s, s_len);\n    } else {\n      ptr = bstrrcasestr(input, len + pos + s_len, s, s_len);\n    }\n  }\n  if (ptr != nullptr) {\n    return (int)((const char *)ptr - input);\n  }\n  return -1;\n}", "target": 1}
{"code": "int nfc_dep_link_up(struct nfc_dev *dev, int target_index, u8 comm_mode)\n{\n\tint rc = 0;\n\tu8 *gb;\n\tsize_t gb_len;\n\tstruct nfc_target *target;\n\tpr_debug(\"dev_name=%s comm %d\\n\", dev_name(&dev->dev), comm_mode);\n\tif (!dev->ops->dep_link_up)\n\t\treturn -EOPNOTSUPP;\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->dep_link_up == true) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\tgb = nfc_llcp_general_bytes(dev, &gb_len);\n\tif (gb_len > NFC_MAX_GT_LEN) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\ttarget = nfc_find_target(dev, target_index);\n\tif (target == NULL) {\n\t\trc = -ENOTCONN;\n\t\tgoto error;\n\t}\n\trc = dev->ops->dep_link_up(dev, target, comm_mode, gb, gb_len);\n\tif (!rc) {\n\t\tdev->active_target = target;\n\t\tdev->rf_mode = NFC_RF_INITIATOR;\n\t}\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "kick_delayed_job(tube t)\n{\n    int r;\n    job j;\n    size_t z;\n    j = pq_take(&t->delay);\n    if (!j) return 0;\n    z = binlog_reserve_space_update(j);\n    if (!z) return pq_give(&t->delay, j), 0; \n    j->reserved_binlog_space += z;\n    j->kick_ct++;\n    r = enqueue_job(j, 0, 1);\n    if (r == 1) return 1;\n    r = enqueue_job(j, j->delay, 0);\n    if (r == 1) return 0;\n    bury_job(j, 0);\n    return 0;\n}", "target": 0}
{"code": "isakmp_rfc3948_print(netdissect_options *ndo,\n\t\t     const u_char *bp, u_int length,\n\t\t     const u_char *bp2)\n{\n\tif(length == 1 && bp[0]==0xff) {\n\t\tND_PRINT((ndo, \"isakmp-nat-keep-alive\"));\n\t\treturn;\n\t}\n\tif(length < 4) {\n\t\tgoto trunc;\n\t}\n\tif(bp[0]==0 && bp[1]==0 && bp[2]==0 && bp[3]==0) {\n\t\tND_PRINT((ndo, \"NONESP-encap: \"));\n\t\tisakmp_print(ndo, bp+4, length-4, bp2);\n\t\treturn;\n\t}\n\t{\n\t\tint nh, enh, padlen;\n\t\tint advance;\n\t\tND_PRINT((ndo, \"UDP-encap: \"));\n\t\tadvance = esp_print(ndo, bp, length, bp2, &enh, &padlen);\n\t\tif(advance <= 0)\n\t\t\treturn;\n\t\tbp += advance;\n\t\tlength -= advance + padlen;\n\t\tnh = enh & 0xff;\n\t\tip_print_inner(ndo, bp, length, nh, bp2);\n\t\treturn;\n\t}\ntrunc:\n\tND_PRINT((ndo,\"[|isakmp]\"));\n\treturn;\n}", "target": 1}
{"code": "valid_hostname(const char *s)\n{\n\tsize_t i;\n\tif (*s == '-')\n\t\treturn 0;\n\tfor (i = 0; s[i] != 0; i++) {\n\t\tif (strchr(\"'`\\\"$\\\\;&<>|(){}\", s[i]) != NULL ||\n\t\t    isspace((u_char)s[i]) || iscntrl((u_char)s[i]))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "static inline bool IsGlobbingPattern(const std::string& pattern) {\n  return (pattern.find_first_of(kGlobbingChars) != std::string::npos);\n}", "target": 0}
{"code": "krb5_gss_process_context_token(minor_status, context_handle,\n                               token_buffer)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    gss_buffer_t token_buffer;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    OM_uint32 majerr;\n    ctx = (krb5_gss_ctx_id_t) context_handle;\n    if (! ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n    if (GSS_ERROR(majerr = kg_unseal(minor_status, context_handle,\n                                     token_buffer,\n                                     GSS_C_NO_BUFFER, NULL, NULL,\n                                     KG_TOK_DEL_CTX)))\n        return(majerr);\n    return(krb5_gss_delete_sec_context(minor_status, &context_handle,\n                                       GSS_C_NO_BUFFER));\n}", "target": 1}
{"code": "header_put_le_int (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)\n\t{\tpsf->header [psf->headindex++] = x ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\t} ;\n} ", "target": 1}
{"code": "static int proc_sys_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct ctl_table_header *head = grab_header(file_inode(file));\n\tstruct ctl_table_header *h = NULL;\n\tstruct ctl_table *entry;\n\tstruct ctl_dir *ctl_dir;\n\tunsigned long pos;\n\tif (IS_ERR(head))\n\t\treturn PTR_ERR(head);\n\tctl_dir = container_of(head, struct ctl_dir, header);\n\tif (!dir_emit_dots(file, ctx))\n\t\treturn 0;\n\tpos = 2;\n\tfor (first_entry(ctl_dir, &h, &entry); h; next_entry(&h, &entry)) {\n\t\tif (!scan(h, entry, &pos, file, ctx)) {\n\t\t\tsysctl_head_finish(h);\n\t\t\tbreak;\n\t\t}\n\t}\n\tsysctl_head_finish(head);\n\treturn 0;\n}", "target": 1}
{"code": "k5_asn1_full_decode(const krb5_data *code, const struct atype_info *a,\n                    void **retrep)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n    taginfo t;\n    *retrep = NULL;\n    ret = get_tag((uint8_t *)code->data, code->length, &t, &contents,\n                  &clen, &remainder, &rlen);\n    if (ret)\n        return ret;\n    if (!check_atype_tag(a, &t))\n        return ASN1_BAD_ID;\n    return decode_atype_to_ptr(&t, contents, clen, a, retrep);\n}", "target": 1}
{"code": "char *reds_get_video_codec_fullname(RedVideoCodec *codec)\n{\n    int i;\n    const char *encoder_name = NULL;\n    const char *codec_name = get_index_name(video_codec_names, codec->type);\n    spice_assert(codec_name);\n    for (i = 0; i < G_N_ELEMENTS(video_encoder_procs); i++) {\n        if (video_encoder_procs[i] == codec->create) {\n            encoder_name = get_index_name(video_encoder_names, i);\n            break;\n        }\n    }\n    spice_assert(encoder_name);\n    return g_strdup_printf(\"%s:%s\", encoder_name, codec_name);\n}", "target": 0}
{"code": "Client::connect()\n{\n    if (m_stream != NULL) {\n        return;\n    }\n    if (m_suspended) {\n        m_connectOnResume = true;\n        return;\n    }\n    auto security_level = ConnectionSecurityLevel::PLAINTEXT;\n    if (m_useSecureNetwork) {\n        security_level = ConnectionSecurityLevel::ENCRYPTED;\n    }\n    try {\n        m_serverAddress.resolve();\n        if (m_serverAddress.getAddress() != NULL) {\n          LOG((CLOG_NOTE \"connecting to '%s': %s:%i\",\n          m_serverAddress.getHostname().c_str(),\n          ARCH->addrToString(m_serverAddress.getAddress()).c_str(),\n          m_serverAddress.getPort()));\n        }\n        IDataSocket* socket = m_socketFactory->create(ARCH->getAddrFamily(m_serverAddress.getAddress()),\n                                                      security_level);\n        m_socket = dynamic_cast<TCPSocket*>(socket);\n        m_stream = socket;\n        m_stream = new PacketStreamFilter(m_events, m_stream, true);\n        LOG((CLOG_DEBUG1 \"connecting to server\"));\n        setupConnecting();\n        setupTimer();\n        socket->connect(m_serverAddress);\n    }\n    catch (XBase& e) {\n        cleanupTimer();\n        cleanupConnecting();\n        cleanupStream();\n        LOG((CLOG_DEBUG1 \"connection failed\"));\n        sendConnectionFailedEvent(e.what());\n        return;\n    }\n}", "target": 1}
{"code": "    OFCondition operator()(ImagePixel& pixel)\n    {\n        (void)pixel;\n        Uint16 rows = 0;\n        Uint16 cols = 0;\n        m_CT.getRows(rows);\n        m_CT.getColumns(cols);\n        const size_t numFrames      = m_CT.m_Frames.size();\n        const size_t numBytesFrame  = m_CT.m_Frames[0]->length;\n        const size_t numPixelsFrame = rows * cols;\n        DcmPixelData* pixData = new DcmPixelData(DCM_PixelData);\n        OFCondition result;\n        if (pixData)\n        {\n            pixData->setVR(EVR_OW);\n            Uint16* ptr          = NULL;\n            size_t numBytesTotal = numBytesFrame * numFrames / 2;\n            if (numBytesTotal <= 4294967294UL)\n            {\n                result = pixData->createUint16Array(OFstatic_cast(Uint32, numBytesTotal), ptr);\n                if (ptr)\n                {\n                    for (size_t f = 0; f < numFrames; ++f)\n                    {\n                        memcpy(ptr, m_CT.m_Frames[f]->pixData, numBytesFrame);\n                        ptr += numPixelsFrame;\n                    }\n                    return m_Item.insert(pixData);\n                }\n            }\n            else\n            {\n                result = FG_EC_PixelDataTooLarge;\n                delete pixData;\n            }\n        }\n        return result;\n    }", "target": 1}
{"code": "smtp_mailaddr(struct mailaddr *maddr, char *line, int mailfrom, char **args,\n    const char *domain)\n{\n\tchar   *p, *e;\n\tif (line == NULL)\n\t\treturn (0);\n\tif (*line != '<')\n\t\treturn (0);\n\te = strchr(line, '>');\n\tif (e == NULL)\n\t\treturn (0);\n\t*e++ = '\\0';\n\twhile (*e == ' ')\n\t\te++;\n\t*args = e;\n\tif (!text_to_mailaddr(maddr, line + 1))\n\t\treturn (0);\n\tp = strchr(maddr->user, ':');\n\tif (p != NULL) {\n\t\tp++;\n\t\tmemmove(maddr->user, p, strlen(p) + 1);\n\t}\n\tif (!valid_localpart(maddr->user) ||\n\t    !valid_domainpart(maddr->domain)) {\n\t\tif (mailfrom && maddr->user[0] == '\\0' && maddr->domain[0] == '\\0')\n\t\t\treturn (1);\n\t\tif (maddr->user[0] == '\\0')\n\t\t\treturn (0);\n\t\tif (maddr->domain[0] == '\\0') {\n\t\t\t(void)strlcpy(maddr->domain, domain,\n\t\t\t    sizeof(maddr->domain));\n\t\t\treturn (1);\n\t\t}\n\t\treturn (0);\n\t}\n\treturn (1);\n}", "target": 1}
{"code": "const int& getActiveId(const void* object, const StructInfo& info) {\n  return *reinterpret_cast<const int*>(\n      static_cast<const char*>(object) + info.unionExt->unionTypeOffset);\n}", "target": 0}
{"code": "char *curl_easy_unescape(CURL *handle, const char *string, int length,\n                         int *olen)\n{\n  int alloc = (length?length:(int)strlen(string))+1;\n  char *ns = malloc(alloc);\n  unsigned char in;\n  int strindex=0;\n  unsigned long hex;\n  CURLcode res;\n  if(!ns)\n    return NULL;\n  while(--alloc > 0) {\n    in = *string;\n    if(('%' == in) && ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {\n      char hexstr[3];\n      char *ptr;\n      hexstr[0] = string[1];\n      hexstr[1] = string[2];\n      hexstr[2] = 0;\n      hex = strtoul(hexstr, &ptr, 16);\n      in = curlx_ultouc(hex); \n      res = Curl_convert_from_network(handle, &in, 1);\n      if(res) {\n        free(ns);\n        return NULL;\n      }\n      string+=2;\n      alloc-=2;\n    }\n    ns[strindex++] = in;\n    string++;\n  }\n  ns[strindex]=0; \n  if(olen)\n    *olen = strindex;\n  return ns;\n}", "target": 1}
{"code": "static int zipfileRollback(sqlite3_vtab *pVtab){\n  return zipfileCommit(pVtab);\n}", "target": 0}
{"code": "static ssize_t aio_setup_single_vector(struct kiocb *kiocb,\n\t\t\t\t       int rw, char __user *buf,\n\t\t\t\t       unsigned long *nr_segs,\n\t\t\t\t       size_t len,\n\t\t\t\t       struct iovec *iovec)\n{\n\tif (unlikely(!access_ok(!rw, buf, len)))\n\t\treturn -EFAULT;\n\tiovec->iov_base = buf;\n\tiovec->iov_len = len;\n\t*nr_segs = 1;\n\treturn 0;\n}", "target": 1}
{"code": "DEFINE_TRACE(ContainerNode)\n{\n    visitor->trace(m_firstChild);\n    visitor->trace(m_lastChild);\n    Node::trace(visitor);\n}", "target": 0}
{"code": "static int adpt_open(struct inode *inode, struct file *file)\n{\n\tint minor;\n\tadpt_hba* pHba;\n\tmutex_lock(&adpt_mutex);\n\tminor = iminor(inode);\n\tif (minor >= hba_count) {\n\t\tmutex_unlock(&adpt_mutex);\n\t\treturn -ENXIO;\n\t}\n\tmutex_lock(&adpt_configuration_lock);\n\tfor (pHba = hba_chain; pHba; pHba = pHba->next) {\n\t\tif (pHba->unit == minor) {\n\t\t\tbreak;\t\n\t\t}\n\t}\n\tif (pHba == NULL) {\n\t\tmutex_unlock(&adpt_configuration_lock);\n\t\tmutex_unlock(&adpt_mutex);\n\t\treturn -ENXIO;\n\t}\n\tpHba->in_use = 1;\n\tmutex_unlock(&adpt_configuration_lock);\n\tmutex_unlock(&adpt_mutex);\n\treturn 0;\n}", "target": 1}
{"code": "TEST_F(HTTP2CodecTest, TrailersNotLatest) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  upstreamCodec_.generateHeader(output_, 1, req);\n  upstreamCodec_.generateHeader(output_, 3, req);\n  HTTPHeaders trailers;\n  trailers.add(\"x-trailer-1\", \"pico-de-gallo\");\n  upstreamCodec_.generateTrailers(output_, 1, trailers);\n  upstreamCodec_.generateHeader(output_, 3, req);\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 2);\n  EXPECT_EQ(callbacks_.headersComplete, 2);\n  EXPECT_EQ(callbacks_.bodyCalls, 0);\n  EXPECT_EQ(callbacks_.trailers, 1);\n  EXPECT_NE(nullptr, callbacks_.msg->getTrailers());\n  EXPECT_EQ(\"pico-de-gallo\",\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-1\"));\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}", "target": 0}
{"code": "void test_delta_apply__read_after_limit(void)\n{\n\tunsigned char base[16] = { 0 }, delta[] = { 0x10, 0x70, 0xff };\n\tvoid *out;\n\tsize_t outlen;\n\tcl_git_fail(git_delta_apply(&out, &outlen, base, sizeof(base), delta, sizeof(delta)));\n}", "target": 0}
{"code": "DECLAREwriteFunc(writeBufferToContigTiles)\n{\n\tuint32 imagew = TIFFScanlineSize(out);\n\tuint32 tilew  = TIFFTileRowSize(out);\n\tint iskew = imagew - tilew;\n\ttsize_t tilesize = TIFFTileSize(out);\n\ttdata_t obuf;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tl, tw;\n\tuint32 row;\n\t(void) spp;\n\tobuf = _TIFFmalloc(TIFFTileSize(out));\n\tif (obuf == NULL)\n\t\treturn 0;\n\t_TIFFmemset(obuf, 0, tilesize);\n\t(void) TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);\n\t(void) TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);\n\tfor (row = 0; row < imagelength; row += tilelength) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\t\tfor (col = 0; col < imagewidth; col += tw) {\n\t\t\tif (colb + tilew > imagew) {\n\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\tint oskew = tilew - width;\n\t\t\t\tcpStripToTile(obuf, bufp + colb, nrow, width,\n\t\t\t\t    oskew, oskew + iskew);\n\t\t\t} else\n\t\t\t\tcpStripToTile(obuf, bufp + colb, nrow, tilew,\n\t\t\t\t    0, iskew);\n\t\t\tif (TIFFWriteTile(out, obuf, col, row, 0, 0) < 0) {\n\t\t\t\tTIFFError(TIFFFileName(out),\n\t\t\t\t    \"Error, can't write tile at %lu %lu\",\n\t\t\t\t    (unsigned long) col,\n\t\t\t\t    (unsigned long) row);\n\t\t\t\t_TIFFfree(obuf);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcolb += tilew;\n\t\t}\n\t\tbufp += nrow * imagew;\n\t}\n\t_TIFFfree(obuf);\n\treturn 1;\n}", "target": 1}
{"code": "static inline void perf_cgroup_sched_out(struct task_struct *task,\n\t\t\t\t\t struct task_struct *next)\n{\n}", "target": 0}
{"code": "static inline int copy_pmd_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\tpud_t *dst_pud, pud_t *src_pud, struct vm_area_struct *vma,\n\t\tunsigned long addr, unsigned long end)\n{\n\tpmd_t *src_pmd, *dst_pmd;\n\tunsigned long next;\n\tdst_pmd = pmd_alloc(dst_mm, dst_pud, addr);\n\tif (!dst_pmd)\n\t\treturn -ENOMEM;\n\tsrc_pmd = pmd_offset(src_pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_none_or_clear_bad(src_pmd))\n\t\t\tcontinue;\n\t\tif (copy_pte_range(dst_mm, src_mm, dst_pmd, src_pmd,\n\t\t\t\t\t\tvma, addr, next))\n\t\t\treturn -ENOMEM;\n\t} while (dst_pmd++, src_pmd++, addr = next, addr != end);\n\treturn 0;\n}", "target": 0}
{"code": "xsltSort(xsltTransformContextPtr ctxt,\n\txmlNodePtr node ATTRIBUTE_UNUSED, xmlNodePtr inst,\n\txsltStylePreCompPtr comp) {\n    if (comp == NULL) {\n\txsltTransformError(ctxt, NULL, inst,\n\t     \"xsl:sort : compilation failed\\n\");\n\treturn;\n    }\n    xsltTransformError(ctxt, NULL, inst,\n\t \"xsl:sort : improper use this should not be reached\\n\");\n}", "target": 0}
{"code": "static int db_dict_iter_lookup_key_values(struct db_dict_value_iter *iter)\n{\n\tstruct db_dict_iter_key *key;\n\tstring_t *path;\n\tconst char *error;\n\tint ret;\n\tarray_sort(&iter->keys, db_dict_iter_key_cmp);\n\tpath = t_str_new(128);\n\tstr_append(path, DICT_PATH_SHARED);\n\tarray_foreach_modifiable(&iter->keys, key) {\n\t\tif (!key->used)\n\t\t\tcontinue;\n\t\tstr_truncate(path, strlen(DICT_PATH_SHARED));\n\t\tret = var_expand(path, key->key->key, iter->var_expand_table, &error);\n\t\tif (ret <= 0) {\n\t\t\tauth_request_log_error(iter->auth_request, AUTH_SUBSYS_DB,\n\t\t\t\t\"Failed to expand key %s: %s\", key->key->key, error);\n\t\t\treturn -1;\n\t\t}\n\t\tret = dict_lookup(iter->conn->dict, iter->pool,\n\t\t\t\t  str_c(path), &key->value, &error);\n\t\tif (ret > 0) {\n\t\t\tauth_request_log_debug(iter->auth_request, AUTH_SUBSYS_DB,\n\t\t\t\t\t       \"Lookup: %s = %s\", str_c(path),\n\t\t\t\t\t       key->value);\n\t\t} else if (ret < 0) {\n\t\t\tauth_request_log_error(iter->auth_request, AUTH_SUBSYS_DB,\n\t\t\t\t\"Failed to lookup key %s: %s\", str_c(path), error);\n\t\t\treturn -1;\n\t\t} else if (key->key->default_value != NULL) {\n\t\t\tauth_request_log_debug(iter->auth_request, AUTH_SUBSYS_DB,\n\t\t\t\t\"Lookup: %s not found, using default value %s\",\n\t\t\t\tstr_c(path), key->key->default_value);\n\t\t\tkey->value = key->key->default_value;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "static int iax2_do_register(struct iax2_registry *reg)\n{\n\tstruct iax_ie_data ied;\n\tif (iaxdebug)\n\t\tast_debug(1, \"Sending registration request for '%s'\\n\", reg->username);\n\tif (reg->dnsmgr && \n\t    ((reg->regstate == REG_STATE_TIMEOUT) || !reg->addr.sin_addr.s_addr)) {\n\t\tast_dnsmgr_refresh(reg->dnsmgr);\n\t}\n\tif (reg->dnsmgr && ast_dnsmgr_changed(reg->dnsmgr) && (reg->callno > 0)) {\n\t\tast_mutex_lock(&iaxsl[reg->callno]);\n\t\tiax2_destroy(reg->callno);\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t\treg->callno = 0;\n\t}\n\tif (!reg->addr.sin_addr.s_addr) {\n\t\tif (iaxdebug)\n\t\t\tast_debug(1, \"Unable to send registration request for '%s' without IP address\\n\", reg->username);\n\t\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t\treturn -1;\n\t}\n\tif (!reg->callno) {\n\t\tast_debug(1, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tast_debug(1, \"Registration created on call %d\\n\", reg->callno);\n\t\tiaxs[reg->callno]->reg = reg;\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t}\n\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_str(&ied, IAX_IE_USERNAME, reg->username);\n\tiax_ie_append_short(&ied, IAX_IE_REFRESH, reg->refresh);\n\tsend_command(iaxs[reg->callno],AST_FRAME_IAX, IAX_COMMAND_REGREQ, 0, ied.buf, ied.pos, -1);\n\treg->regstate = REG_STATE_REGSENT;\n\treturn 0;\n}", "target": 1}
{"code": "ev_archive_set_archive_type (EvArchive *archive,\n\t\t\t     EvArchiveType archive_type)\n{\n\tg_return_val_if_fail (EV_IS_ARCHIVE (archive), FALSE);\n\tg_return_val_if_fail (archive->type == EV_ARCHIVE_TYPE_NONE, FALSE);\n\tswitch (archive_type) {\n\tcase EV_ARCHIVE_TYPE_RAR:\n\tcase EV_ARCHIVE_TYPE_ZIP:\n\tcase EV_ARCHIVE_TYPE_7Z:\n\tcase EV_ARCHIVE_TYPE_TAR:\n\t\tlibarchive_set_archive_type (archive, archive_type);\n\t\tbreak;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\treturn TRUE;\n}", "target": 0}
{"code": "static int ndp_sock_open(struct ndp *ndp)\n{\n\tint sock;\n\tint ret;\n\tint err;\n\tint val;\n\tsock = socket(PF_INET6, SOCK_RAW, IPPROTO_ICMPV6);\n\tif (sock == -1) {\n\t\terr(ndp, \"Failed to create ICMP6 socket.\");\n\t\treturn -errno;\n\t}\n\tval = 1;\n\tret = setsockopt(sock, IPPROTO_IPV6, IPV6_RECVPKTINFO,\n\t\t\t &val, sizeof(val));\n\tif (ret == -1) {\n\t\terr(ndp, \"Failed to setsockopt IPV6_RECVPKTINFO.\");\n\t\terr = -errno;\n\t\tgoto close_sock;\n\t}\n\tval = 255;\n\tret = setsockopt(sock, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,\n\t\t\t &val, sizeof(val));\n\tif (ret == -1) {\n\t\terr(ndp, \"Failed to setsockopt IPV6_MULTICAST_HOPS.\");\n\t\terr = -errno;\n\t\tgoto close_sock;\n\t}\n\tval = 1;\n\tret = setsockopt(sock, IPPROTO_IPV6, IPV6_RECVHOPLIMIT,\n\t\t\t &val, sizeof(val));\n\tif (ret == -1) {\n\t\terr(ndp, \"Failed to setsockopt IPV6_RECVHOPLIMIT,.\");\n\t\terr = -errno;\n\t\tgoto close_sock;\n\t}\n\tndp->sock = sock;\n\treturn 0;\nclose_sock:\n\tclose(sock);\n\treturn err;\n}", "target": 0}
{"code": "static void _ewk_view_on_mouse_move(void* data, Evas* eventType, Evas_Object* callback, void* eventInfo)\n{\n    Evas_Event_Mouse_Move* moveEvent = static_cast<Evas_Event_Mouse_Move*>(eventInfo);\n    Ewk_View_Smart_Data* smartData = static_cast<Ewk_View_Smart_Data*>(data);\n    EINA_SAFETY_ON_NULL_RETURN(smartData->api);\n    EINA_SAFETY_ON_NULL_RETURN(smartData->api->mouse_move);\n    smartData->api->mouse_move(smartData, moveEvent);\n}", "target": 0}
{"code": "static int io_timeout_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe,\n\t\t\t   bool is_timeout_link)\n{\n\tstruct io_timeout_data *data;\n\tunsigned flags;\n\tu32 off = READ_ONCE(sqe->off);\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (sqe->ioprio || sqe->buf_index || sqe->len != 1 ||\n\t    sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\tif (off && is_timeout_link)\n\t\treturn -EINVAL;\n\tflags = READ_ONCE(sqe->timeout_flags);\n\tif (flags & ~(IORING_TIMEOUT_ABS | IORING_TIMEOUT_CLOCK_MASK |\n\t\t      IORING_TIMEOUT_ETIME_SUCCESS))\n\t\treturn -EINVAL;\n\tif (hweight32(flags & IORING_TIMEOUT_CLOCK_MASK) > 1)\n\t\treturn -EINVAL;\n\tINIT_LIST_HEAD(&req->timeout.list);\n\treq->timeout.off = off;\n\tif (unlikely(off && !req->ctx->off_timeout_used))\n\t\treq->ctx->off_timeout_used = true;\n\tif (WARN_ON_ONCE(req_has_async_data(req)))\n\t\treturn -EFAULT;\n\tif (io_alloc_async_data(req))\n\t\treturn -ENOMEM;\n\tdata = req->async_data;\n\tdata->req = req;\n\tdata->flags = flags;\n\tif (get_timespec64(&data->ts, u64_to_user_ptr(sqe->addr)))\n\t\treturn -EFAULT;\n\tif (data->ts.tv_sec < 0 || data->ts.tv_nsec < 0)\n\t\treturn -EINVAL;\n\tINIT_LIST_HEAD(&req->timeout.list);\n\tdata->mode = io_translate_timeout_mode(flags);\n\thrtimer_init(&data->timer, io_timeout_get_clock(data), data->mode);\n\tif (is_timeout_link) {\n\t\tstruct io_submit_link *link = &req->ctx->submit_state.link;\n\t\tif (!link->head)\n\t\t\treturn -EINVAL;\n\t\tif (link->last->opcode == IORING_OP_LINK_TIMEOUT)\n\t\t\treturn -EINVAL;\n\t\treq->timeout.head = link->last;\n\t\tlink->last->flags |= REQ_F_ARM_LTIMEOUT;\n\t}\n\treturn 0;", "target": 0}
{"code": "static void ssdp_recv(int sd)\n{\n\tssize_t len;\n\tstruct sockaddr sa;\n\tsocklen_t salen;\n\tchar buf[MAX_PKT_SIZE];\n\tmemset(buf, 0, sizeof(buf));\n\tlen = recvfrom(sd, buf, sizeof(buf), MSG_DONTWAIT, &sa, &salen);\n\tif (len > 0) {\n\t\tbuf[len] = 0;\n\t\tif (sa.sa_family != AF_INET)\n\t\t\treturn;\n\t\tif (strstr(buf, \"M-SEARCH *\")) {\n\t\t\tsize_t i;\n\t\t\tchar *ptr, *type;\n\t\t\tstruct ifsock *ifs;\n\t\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)&sa;\n\t\t\tifs = find_outbound(&sa);\n\t\t\tif (!ifs) {\n\t\t\t\tlogit(LOG_DEBUG, \"No matching socket for client %s\", inet_ntoa(sin->sin_addr));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlogit(LOG_DEBUG, \"Matching socket for client %s\", inet_ntoa(sin->sin_addr));\n\t\t\ttype = strcasestr(buf, \"\\r\\nST:\");\n\t\t\tif (!type) {\n\t\t\t\tlogit(LOG_DEBUG, \"No Search Type (ST:) found in M-SEARCH *, assuming \" SSDP_ST_ALL);\n\t\t\t\ttype = SSDP_ST_ALL;\n\t\t\t\tsend_message(ifs, type, &sa);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttype = strchr(type, ':');\n\t\t\tif (!type)\n\t\t\t\treturn;\n\t\t\ttype++;\n\t\t\twhile (isspace(*type))\n\t\t\t\ttype++;\n\t\t\tptr = strstr(type, \"\\r\\n\");\n\t\t\tif (!ptr)\n\t\t\t\treturn;\n\t\t\t*ptr = 0;\n\t\t\tfor (i = 0; supported_types[i]; i++) {\n\t\t\t\tif (!strcmp(supported_types[i], type)) {\n\t\t\t\t\tlogit(LOG_DEBUG, \"M-SEARCH * ST: %s from %s port %d\", type,\n\t\t\t\t\t      inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\t\t\t\tsend_message(ifs, type, &sa);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlogit(LOG_DEBUG, \"M-SEARCH * for unsupported ST: %s from %s\", type,\n\t\t\t      inet_ntoa(sin->sin_addr));\n\t\t}\n\t}\n}", "target": 1}
{"code": "static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSRMLS_DC)\n{\n\tchar *ksep, *vsep, *val;\n\tsize_t klen, vlen;\n\tunsigned int new_vlen;\n\tif (var->ptr >= var->end) {\n\t\treturn 0;\n\t}\n\tvsep = memchr(var->ptr, '&', var->end - var->ptr);\n\tif (!vsep) {\n\t\tif (!eof) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tvsep = var->end;\n\t\t}\n\t}\n\tksep = memchr(var->ptr, '=', vsep - var->ptr);\n\tif (ksep) {\n\t\t*ksep = '\\0';\n\t\tklen = ksep - var->ptr;\n\t\tvlen = vsep - ++ksep;\n\t} else {\n\t\tksep = \"\";\n\t\tklen = vsep - var->ptr;\n\t\tvlen = 0;\n\t}\n\tphp_url_decode(var->ptr, klen);\n\tval = estrndup(ksep, vlen);\n\tif (vlen) {\n\t\tvlen = php_url_decode(val, vlen);\n\t}\n\tif (sapi_module.input_filter(PARSE_POST, var->ptr, &val, vlen, &new_vlen TSRMLS_CC)) {\n\t\tphp_register_variable_safe(var->ptr, val, new_vlen, arr TSRMLS_CC);\n\t}\n\tefree(val);\n\tvar->ptr = vsep + (vsep != var->end);\n\treturn 1;\n}", "target": 1}
{"code": "static int tcp_v6_send_synack(const struct sock *sk, struct dst_entry *dst,\n\t\t\t      struct flowi *fl,\n\t\t\t      struct request_sock *req,\n\t\t\t      struct tcp_fastopen_cookie *foc,\n\t\t\t      bool attach_req)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct flowi6 *fl6 = &fl->u.ip6;\n\tstruct sk_buff *skb;\n\tint err = -ENOMEM;\n\tif (!dst && (dst = inet6_csk_route_req(sk, fl6, req,\n\t\t\t\t\t       IPPROTO_TCP)) == NULL)\n\t\tgoto done;\n\tskb = tcp_make_synack(sk, dst, req, foc, attach_req);\n\tif (skb) {\n\t\t__tcp_v6_send_check(skb, &ireq->ir_v6_loc_addr,\n\t\t\t\t    &ireq->ir_v6_rmt_addr);\n\t\tfl6->daddr = ireq->ir_v6_rmt_addr;\n\t\tif (np->repflow && ireq->pktopts)\n\t\t\tfl6->flowlabel = ip6_flowlabel(ipv6_hdr(ireq->pktopts));\n\t\terr = ip6_xmit(sk, skb, fl6, np->opt, np->tclass);\n\t\terr = net_xmit_eval(err);\n\t}\ndone:\n\treturn err;\n}", "target": 1}
{"code": "static void lwp_write_int64(FILE *fout, int64_t d) {\n  fwrite(&d, sizeof(d), 1, fout);\n  fflush(fout);\n}", "target": 0}
{"code": "list_fields(MYSQL *mysql,const char *db,const char *table,\n\t    const char *wild)\n{\n  char query[1024],*end;\n  MYSQL_RES *result;\n  MYSQL_ROW row;\n  ulong UNINIT_VAR(rows);\n  if (mysql_select_db(mysql,db))\n  {\n    fprintf(stderr,\"%s: Cannot connect to db: %s: %s\\n\",my_progname,db,\n\t    mysql_error(mysql));\n    return 1;\n  }\n  if (opt_count)\n  {\n    sprintf(query,\"select count(*) from `%s`\", table);\n    if (mysql_query(mysql,query) || !(result=mysql_store_result(mysql)))\n    {\n      fprintf(stderr,\"%s: Cannot get record count for db: %s, table: %s: %s\\n\",\n              my_progname,db,table,mysql_error(mysql));\n      return 1;\n    }\n    row= mysql_fetch_row(result);\n    rows= (ulong) strtoull(row[0], (char**) 0, 10);\n    mysql_free_result(result);\n  }\n  end=strmov(strmov(strmov(query,\"show  columns from `\"),table),\"`\");\n  if (wild && wild[0])\n    strxmov(end,\" like '\",wild,\"'\",NullS);\n  if (mysql_query(mysql,query) || !(result=mysql_store_result(mysql)))\n  {\n    fprintf(stderr,\"%s: Cannot list columns in db: %s, table: %s: %s\\n\",\n\t    my_progname,db,table,mysql_error(mysql));\n    return 1;\n  }\n  printf(\"Database: %s  Table: %s\", db, table);\n  if (opt_count)\n    printf(\"  Rows: %lu\", rows);\n  if (wild && wild[0])\n    printf(\"  Wildcard: %s\",wild);\n  putchar('\\n');\n  print_res_header(result);\n  while ((row=mysql_fetch_row(result)))\n    print_res_row(result,row);\n  print_res_top(result);\n  if (opt_show_keys)\n  {\n    end=strmov(strmov(strmov(query,\"show keys from `\"),table),\"`\");\n    if (mysql_query(mysql,query) || !(result=mysql_store_result(mysql)))\n    {\n      fprintf(stderr,\"%s: Cannot list keys in db: %s, table: %s: %s\\n\",\n\t      my_progname,db,table,mysql_error(mysql));\n      return 1;\n    }\n    if (mysql_num_rows(result))\n    {\n      print_res_header(result);\n      while ((row=mysql_fetch_row(result)))\n\tprint_res_row(result,row);\n      print_res_top(result);\n    }\n    else\n      puts(\"Table has no keys\");\n  }\n  mysql_free_result(result);\n  return 0;\n}", "target": 1}
{"code": "  Status ArgSortByRows(OpKernelContext* context, const GPUDevice& device,\n                       Tindex N, int rank, Tindex dense_rows,\n                       typename TTypes<Tindex>::ConstMatrix indices,\n                       Tensor* input_index_map_t) {\n    DataType index_type = DataTypeToEnum<Tindex>::value;\n    Tensor row_indices_t;\n    TF_RETURN_IF_ERROR(\n        context->allocate_temp(index_type, TensorShape({N}), &row_indices_t));\n    auto row_indices = row_indices_t.flat<Tindex>();\n    TF_RETURN_IF_ERROR(wrap_kernel_call(CopyRowIndicesKernel<Tindex>,\n                                        device, N, rank,\n                                        indices, row_indices));\n    TF_RETURN_IF_ERROR(context->allocate_temp(index_type, TensorShape({N}),\n                                              input_index_map_t));\n    Tindex* input_index_map = input_index_map_t->flat<Tindex>().data();\n    return GpuRadixSort(context, N, row_indices.data(),\n                        static_cast<Tindex*>(nullptr),\n                        static_cast<Tindex*>(nullptr),\n                        input_index_map,\n                        Log2Ceiling64(dense_rows));\n  }", "target": 1}
{"code": "int ZEXPORT deflatePrime (strm, bits, value)\n    z_streamp strm;\n    int bits;\n    int value;\n{\n    deflate_state *s;\n    int put;\n    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;\n    s = strm->state;\n    if ((Bytef *)(s->d_buf) < s->pending_out + ((Buf_size + 7) >> 3))\n        return Z_BUF_ERROR;\n    do {\n        put = Buf_size - s->bi_valid;\n        if (put > bits)\n            put = bits;\n        s->bi_buf |= (ush)((value & ((1 << put) - 1)) << s->bi_valid);\n        s->bi_valid += put;\n        _tr_flush_bits(s);\n        value >>= put;\n        bits -= put;\n    } while (bits);\n    return Z_OK;\n}", "target": 1}
{"code": "  HTTP_CB(on_message_begin) {\n    num_fields_ = num_values_ = 0;\n    url_.Reset();\n    return 0;\n  }", "target": 0}
{"code": "void HeaderMapImpl::subtractSize(uint64_t size) {\n  if (cached_byte_size_.has_value()) {\n    ASSERT(cached_byte_size_ >= size);\n    cached_byte_size_.value() -= size;\n  }\n}", "target": 0}
{"code": "int xmkstemp(char **tmpname, char *dir)\n{\n\tchar *localtmp;\n\tchar *tmpenv;\n\tmode_t old_mode;\n\tint fd, rc;\n\tif (dir != NULL)\n\t\ttmpenv = dir;\n\telse\n\t\ttmpenv = getenv(\"TMPDIR\");\n\tif (tmpenv)\n\t\trc = asprintf(&localtmp, \"%s/%s.XXXXXX\", tmpenv,\n\t\t\t  program_invocation_short_name);\n\telse\n\t\trc = asprintf(&localtmp, \"%s/%s.XXXXXX\", _PATH_TMP,\n\t\t\t  program_invocation_short_name);\n\tif (rc < 0)\n\t\treturn -1;\n\told_mode = umask(077);\n\tfd = mkostemp(localtmp, O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC);\n\tumask(old_mode);\n\tif (fd == -1) {\n\t\tfree(localtmp);\n\t\tlocaltmp = NULL;\n\t}\n\t*tmpname = localtmp;\n\treturn fd;\n}", "target": 1}
{"code": "static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_cipher rcipher;\n\tstrlcpy(rcipher.type, \"cipher\", sizeof(rcipher.type));\n\trcipher.blocksize = alg->cra_blocksize;\n\trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\n\trcipher.max_keysize = alg->cra_cipher.cia_max_keysize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,\n\t\t    sizeof(struct crypto_report_cipher), &rcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "cdf_tole2(uint16_t sv)\n{\n\treturn CDF_TOLE2(sv);\n}", "target": 0}
{"code": "int net_get(int s, void *arg, int *len)\n{\n\tstruct net_hdr nh;\n\tint plen;\n\tif (net_read_exact(s, &nh, sizeof(nh)) == -1)\n        {\n\t\treturn -1;\n        }\n\tplen = ntohl(nh.nh_len);\n\tif (!(plen <= *len))\n\t\tprintf(\"PLEN %d type %d len %d\\n\",\n\t\t\tplen, nh.nh_type, *len);\n\tassert(plen <= *len); \n\t*len = plen;\n\tif ((*len) && (net_read_exact(s, arg, *len) == -1))\n        {\n            return -1;\n        }\n\treturn nh.nh_type;\n}", "target": 1}
{"code": "void ParamTraits<FilePath>::Write(Message* m, const param_type& p) {\n  ParamTraits<FilePath::StringType>::Write(m, p.value());\n}", "target": 0}
{"code": "static void draw_pattern_push( wmfAPI* API,\n                               unsigned long id,\n                               unsigned long columns,\n                               unsigned long rows )\n{\n  char\n    pattern_id[MagickPathExtent];\n  (void) FormatLocaleString(pattern_id,MagickPathExtent,\"brush_%lu\",id);\n  (void) DrawPushPattern(WmfDrawingWand,pattern_id,0,0,columns,rows);\n}", "target": 0}
{"code": "static void add_password(AUTH_HDR *request, unsigned char type, CONST char *password, char *secret)\n{\n\tMD5_CTX md5_secret, my_md5;\n\tunsigned char misc[AUTH_VECTOR_LEN];\n\tint i;\n\tint length = strlen(password);\n\tunsigned char hashed[256 + AUTH_PASS_LEN];\t\n\tunsigned char *vector;\n\tattribute_t *attr;\n\tif (length > MAXPASS) {\t\t\t\t\n\t\tlength = MAXPASS;\n\t}\n\tif (length == 0) {\n\t\tlength = AUTH_PASS_LEN;\t\t\t\n\t} if ((length & (AUTH_PASS_LEN - 1)) != 0) {\n\t\tlength += (AUTH_PASS_LEN - 1);\t\t\n\t\tlength &= ~(AUTH_PASS_LEN - 1);\t\t\n\t}\t\t\t\t\t\t\n\tmemset(hashed, 0, length);\n\tmemcpy(hashed, password, strlen(password));\n\tattr = find_attribute(request, PW_PASSWORD);\n\tif (type == PW_PASSWORD) {\n\t\tvector = request->vector;\n\t} else {\n\t\tvector = attr->data;\t\t\t\n\t}\n\tMD5Init(&md5_secret);\n\tMD5Update(&md5_secret, (unsigned char *) secret, strlen(secret));\n\tmy_md5 = md5_secret;\t\t\t\t\n\tMD5Update(&my_md5, vector, AUTH_VECTOR_LEN);\n\tMD5Final(misc, &my_md5);\t\t\t\n\txor(hashed, misc, AUTH_PASS_LEN);\n\tfor (i = 1; i < (length >> 4); i++) {\n\t\tmy_md5 = md5_secret;\t\t\t\n\t\tMD5Update(&my_md5, &hashed[(i-1) * AUTH_PASS_LEN], AUTH_PASS_LEN);\n\t\tMD5Final(misc, &my_md5);\t\t\t\n\t\txor(&hashed[i * AUTH_PASS_LEN], misc, AUTH_PASS_LEN);\n\t}\n\tif (type == PW_OLD_PASSWORD) {\n\t\tattr = find_attribute(request, PW_OLD_PASSWORD);\n\t}\n\tif (!attr) {\n\t\tadd_attribute(request, type, hashed, length);\n\t} else {\n\t\tmemcpy(attr->data, hashed, length); \n\t}\n}", "target": 1}
{"code": "devzvol_readdir(struct vnode *dvp, struct uio *uiop, struct cred *cred,\n    int *eofp, caller_context_t *ct_unused, int flags_unused)\n{\n\tstruct sdev_node *sdvp = VTOSDEV(dvp);\n\tchar *ptr;\n\tsdcmn_err13((\"zv readdir of '%s' %s'\", sdvp->sdev_path,\n\t    sdvp->sdev_name));\n\tif (strcmp(sdvp->sdev_path, ZVOL_DIR) == 0) {\n\t\tstruct vnode *vp;\n\t\trw_exit(&sdvp->sdev_contents);\n\t\t(void) devname_lookup_func(sdvp, \"dsk\", &vp, cred,\n\t\t    devzvol_create_dir, SDEV_VATTR);\n\t\tVN_RELE(vp);\n\t\t(void) devname_lookup_func(sdvp, \"rdsk\", &vp, cred,\n\t\t    devzvol_create_dir, SDEV_VATTR);\n\t\tVN_RELE(vp);\n\t\trw_enter(&sdvp->sdev_contents, RW_READER);\n\t\treturn (devname_readdir_func(dvp, uiop, cred, eofp, 0));\n\t}\n\tif (uiop->uio_offset == 0)\n\t\tdevzvol_prunedir(sdvp);\n\tptr = sdvp->sdev_path + strlen(ZVOL_DIR);\n\tif ((strcmp(ptr, \"/dsk\") == 0) || (strcmp(ptr, \"/rdsk\") == 0)) {\n\t\trw_exit(&sdvp->sdev_contents);\n\t\tdevzvol_create_pool_dirs(dvp);\n\t\trw_enter(&sdvp->sdev_contents, RW_READER);\n\t\treturn (devname_readdir_func(dvp, uiop, cred, eofp, 0));\n\t}\n\tptr = strchr(ptr + 1, '/') + 1;\n\trw_exit(&sdvp->sdev_contents);\n\tsdev_iter_datasets(dvp, ZFS_IOC_DATASET_LIST_NEXT, ptr);\n\trw_enter(&sdvp->sdev_contents, RW_READER);\n\treturn (devname_readdir_func(dvp, uiop, cred, eofp, 0));\n}", "target": 1}
{"code": "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tint ret = 0, nbuf;\n\tbool input_wakeup = false;\nretry:\n\tret = ipipe_prep(ipipe, flags);\n\tif (ret)\n\t\treturn ret;\n\tret = opipe_prep(opipe, flags);\n\tif (ret)\n\t\treturn ret;\n\tpipe_double_lock(ipipe, opipe);\n\tdo {\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\t\tif (!ipipe->nrbufs && !ipipe->writers)\n\t\t\tbreak;\n\t\tif (!ipipe->nrbufs || opipe->nrbufs >= opipe->buffers) {\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpipe_unlock(ipipe);\n\t\t\tpipe_unlock(opipe);\n\t\t\tgoto retry;\n\t\t}\n\t\tibuf = ipipe->bufs + ipipe->curbuf;\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\t\tobuf = opipe->bufs + nbuf;\n\t\tif (len >= ibuf->len) {\n\t\t\t*obuf = *ibuf;\n\t\t\tibuf->ops = NULL;\n\t\t\topipe->nrbufs++;\n\t\t\tipipe->curbuf = (ipipe->curbuf + 1) & (ipipe->buffers - 1);\n\t\t\tipipe->nrbufs--;\n\t\t\tinput_wakeup = true;\n\t\t} else {\n\t\t\tpipe_buf_get(ipipe, ibuf);\n\t\t\t*obuf = *ibuf;\n\t\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\t\t\tobuf->len = len;\n\t\t\topipe->nrbufs++;\n\t\t\tibuf->offset += obuf->len;\n\t\t\tibuf->len -= obuf->len;\n\t\t}\n\t\tret += obuf->len;\n\t\tlen -= obuf->len;\n\t} while (len);\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\tif (input_wakeup)\n\t\twakeup_pipe_writers(ipipe);\n\treturn ret;\n}", "target": 1}
{"code": "GF_EXPORT\nvoid gf_isom_reset_sample_count(GF_ISOFile *movie)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i;\n\tif (!movie) return;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\ttrak->Media->information->sampleTable->SampleSize->sampleCount = 0;\n\t\ttrak->sample_count_at_seg_start = 0;\n\t}\n\tmovie->NextMoofNumber = 0;\n#endif", "target": 0}
{"code": "int decomp_get_rddata(js_string *compressed, js_string *out,\n                      unsigned int compressed_offset, int type, int rdlength) {\n    char *desc;\n    int subtype, total, len;\n    desc = decomp_get_rrdesc(type);\n    if(desc == 0) { \n        if(rdlength == 0) {\n            return JS_SUCCESS;\n            }\n        if(decomp_append_bytes(compressed,out,compressed_offset,\n                               rdlength) != JS_SUCCESS) {\n            return JS_ERROR;\n            }\n        else {\n            return JS_SUCCESS;\n            }\n        }\n    else {\n        subtype = *desc;\n        total = 0;\n        while(subtype != 0) {\n            if(subtype > 0 && subtype < 64) {\n                if(decomp_append_bytes(compressed,out,\n                   compressed_offset,subtype) != JS_SUCCESS) {\n                       return JS_ERROR;\n                       }\n                total += subtype;\n                compressed_offset += subtype;\n                }\n            else if(subtype == RRSUB_DLABEL) {\n                len = decomp_append_dlabel(compressed,out,\n                        compressed_offset);\n                if(len == JS_ERROR) {\n                    return JS_ERROR;\n                    }\n                total += len;\n                compressed_offset += len;\n                }\n            else if(subtype == RRSUB_TEXT) {\n                len = *(compressed->string + compressed_offset);\n                len += 1; \n                if(len < 0 || len > 256) {\n                    return JS_ERROR;\n                    }\n                if(decomp_append_bytes(compressed,out,\n                                       compressed_offset,len) !=\n                   JS_SUCCESS) {\n                    return JS_ERROR;\n                    }\n                total += len;\n                compressed_offset += len;\n                }\n            else if(subtype == RRSUB_VARIABLE) {\n                len = rdlength - total;\n                if(len == 0) {\n                    break;\n                    }\n                if(decomp_append_bytes(compressed,out,\n                                       compressed_offset,len) != JS_SUCCESS) {\n                    return JS_ERROR;\n                    }\n                total += len;\n                compressed_offset += len;\n                }\n            else { \n                return JS_ERROR;\n                }\n            desc++;\n            if(subtype != RRSUB_VARIABLE)\n                subtype = *desc;\n            else\n                subtype = 0; \n            }\n        if(rdlength != total) {\n            return JS_ERROR;\n            }\n        }\n    return JS_SUCCESS;\n    }", "target": 1}
{"code": "static inline void x86_assign_hw_event(struct perf_event *event,\n\t\t\t\tstruct cpu_hw_events *cpuc, int i)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\thwc->idx = cpuc->assign[i];\n\thwc->last_cpu = smp_processor_id();\n\thwc->last_tag = ++cpuc->tags[i];\n\tif (hwc->idx == X86_PMC_IDX_FIXED_BTS) {\n\t\thwc->config_base = 0;\n\t\thwc->event_base\t= 0;\n\t} else if (hwc->idx >= X86_PMC_IDX_FIXED) {\n\t\thwc->config_base = MSR_ARCH_PERFMON_FIXED_CTR_CTRL;\n\t\thwc->event_base = MSR_ARCH_PERFMON_FIXED_CTR0;\n\t} else {\n\t\thwc->config_base = x86_pmu_config_addr(hwc->idx);\n\t\thwc->event_base  = x86_pmu_event_addr(hwc->idx);\n\t}\n}", "target": 1}
{"code": "static inline int pri2fac(const int pri)\n{\n\tunsigned fac = pri >> 3;\n\treturn (fac > 23) ? LOG_FAC_INVLD : fac;\n}", "target": 0}
{"code": "static int inet6_fill_ifla6_attrs(struct sk_buff *skb, struct inet6_dev *idev)\n{\n\tstruct nlattr *nla;\n\tstruct ifla_cacheinfo ci;\n\tif (nla_put_u32(skb, IFLA_INET6_FLAGS, idev->if_flags))\n\t\tgoto nla_put_failure;\n\tci.max_reasm_len = IPV6_MAXPLEN;\n\tci.tstamp = cstamp_delta(idev->tstamp);\n\tci.reachable_time = jiffies_to_msecs(idev->nd_parms->reachable_time);\n\tci.retrans_time = jiffies_to_msecs(idev->nd_parms->retrans_time);\n\tif (nla_put(skb, IFLA_INET6_CACHEINFO, sizeof(ci), &ci))\n\t\tgoto nla_put_failure;\n\tnla = nla_reserve(skb, IFLA_INET6_CONF, DEVCONF_MAX * sizeof(s32));\n\tif (nla == NULL)\n\t\tgoto nla_put_failure;\n\tipv6_store_devconf(&idev->cnf, nla_data(nla), nla_len(nla));\n\tnla = nla_reserve(skb, IFLA_INET6_STATS, IPSTATS_MIB_MAX * sizeof(u64));\n\tif (nla == NULL)\n\t\tgoto nla_put_failure;\n\tsnmp6_fill_stats(nla_data(nla), idev, IFLA_INET6_STATS, nla_len(nla));\n\tnla = nla_reserve(skb, IFLA_INET6_ICMP6STATS, ICMP6_MIB_MAX * sizeof(u64));\n\tif (nla == NULL)\n\t\tgoto nla_put_failure;\n\tsnmp6_fill_stats(nla_data(nla), idev, IFLA_INET6_ICMP6STATS, nla_len(nla));\n\tnla = nla_reserve(skb, IFLA_INET6_TOKEN, sizeof(struct in6_addr));\n\tif (nla == NULL)\n\t\tgoto nla_put_failure;\n\tread_lock_bh(&idev->lock);\n\tmemcpy(nla_data(nla), idev->token.s6_addr, nla_len(nla));\n\tread_unlock_bh(&idev->lock);\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 0}
{"code": "static int xfrm_expand_policies(const struct flowi *fl, u16 family,\n\t\t\t\tstruct xfrm_policy **pols,\n\t\t\t\tint *num_pols, int *num_xfrms)\n{\n\tint i;\n\tif (*num_pols == 0 || !pols[0]) {\n\t\t*num_pols = 0;\n\t\t*num_xfrms = 0;\n\t\treturn 0;\n\t}\n\tif (IS_ERR(pols[0]))\n\t\treturn PTR_ERR(pols[0]);\n\t*num_xfrms = pols[0]->xfrm_nr;\n#ifdef CONFIG_XFRM_SUB_POLICY\n\tif (pols[0]->action == XFRM_POLICY_ALLOW &&\n\t    pols[0]->type != XFRM_POLICY_TYPE_MAIN) {\n\t\tpols[1] = xfrm_policy_lookup_bytype(xp_net(pols[0]),\n\t\t\t\t\t\t    XFRM_POLICY_TYPE_MAIN,\n\t\t\t\t\t\t    fl, family,\n\t\t\t\t\t\t    XFRM_POLICY_OUT,\n\t\t\t\t\t\t    pols[0]->if_id);\n\t\tif (pols[1]) {\n\t\t\tif (IS_ERR(pols[1])) {\n\t\t\t\txfrm_pols_put(pols, *num_pols);\n\t\t\t\treturn PTR_ERR(pols[1]);\n\t\t\t}\n\t\t\t(*num_pols)++;\n\t\t\t(*num_xfrms) += pols[1]->xfrm_nr;\n\t\t}\n\t}\n#endif\n\tfor (i = 0; i < *num_pols; i++) {\n\t\tif (pols[i]->action != XFRM_POLICY_ALLOW) {\n\t\t\t*num_xfrms = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void* ipc_rcu_alloc(int size)\n{\n\tvoid* out;\n\tif (rcu_use_vmalloc(size)) {\n\t\tout = vmalloc(HDRLEN_VMALLOC + size);\n\t\tif (out) {\n\t\t\tout += HDRLEN_VMALLOC;\n\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 1;\n\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->refcount = 1;\n\t\t}\n\t} else {\n\t\tout = kmalloc(HDRLEN_KMALLOC + size, GFP_KERNEL);\n\t\tif (out) {\n\t\t\tout += HDRLEN_KMALLOC;\n\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 0;\n\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->refcount = 1;\n\t\t}\n\t}\n\treturn out;\n}", "target": 1}
{"code": "void ExtractStreams(Archive &Arc,const wchar *FileName,bool TestMode)\n{\n  wchar FullName[NM+2];\n  if (FileName[0]!=0 && FileName[1]==0)\n  {\n    wcsncpyz(FullName,L\".\\\\\",ASIZE(FullName));\n    wcsncatz(FullName,FileName,ASIZE(FullName));\n  }\n  else\n    wcsncpyz(FullName,FileName,ASIZE(FullName));\n  wchar StreamName[NM];\n  GetStreamNameNTFS(Arc,StreamName,ASIZE(StreamName));\n  if (*StreamName!=':')\n  {\n    uiMsg(UIERROR_STREAMBROKEN,Arc.FileName,FileName);\n    ErrHandler.SetErrorCode(RARX_CRC);\n    return;\n  }\n  if (TestMode)\n  {\n    File CurFile;\n    Arc.ReadSubData(NULL,&CurFile,true);\n    return;\n  }\n  wcsncatz(FullName,StreamName,ASIZE(FullName));\n  FindData fd;\n  bool HostFound=FindFile::FastFind(FileName,&fd);\n  if ((fd.FileAttr & FILE_ATTRIBUTE_READONLY)!=0)\n    SetFileAttr(FileName,fd.FileAttr & ~FILE_ATTRIBUTE_READONLY);\n  File CurFile;\n  if (CurFile.WCreate(FullName) && Arc.ReadSubData(NULL,&CurFile,false))\n    CurFile.Close();\n  File HostFile;\n  if (HostFound && HostFile.Open(FileName,FMF_OPENSHARED|FMF_UPDATE))\n    SetFileTime(HostFile.GetHandle(),&fd.ftCreationTime,&fd.ftLastAccessTime,\n                &fd.ftLastWriteTime);\n  SetFileAttr(FileName,fd.FileAttr);\n}", "target": 1}
{"code": "static int __nla_validate_parse(const struct nlattr *head, int len, int maxtype,\n\t\t\t\tconst struct nla_policy *policy,\n\t\t\t\tunsigned int validate,\n\t\t\t\tstruct netlink_ext_ack *extack,\n\t\t\t\tstruct nlattr **tb)\n{\n\tconst struct nlattr *nla;\n\tint rem;\n\tif (tb)\n\t\tmemset(tb, 0, sizeof(struct nlattr *) * (maxtype + 1));\n\tnla_for_each_attr(nla, head, len, rem) {\n\t\tu16 type = nla_type(nla);\n\t\tif (type == 0 || type > maxtype) {\n\t\t\tif (validate & NL_VALIDATE_MAXTYPE) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t\t\t    \"Unknown attribute type\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (policy) {\n\t\t\tint err = validate_nla(nla, maxtype, policy,\n\t\t\t\t\t       validate, extack);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (tb)\n\t\t\ttb[type] = (struct nlattr *)nla;\n\t}\n\tif (unlikely(rem > 0)) {\n\t\tpr_warn_ratelimited(\"netlink: %d bytes leftover after parsing attributes in process `%s'.\\n\",\n\t\t\t\t    rem, current->comm);\n\t\tNL_SET_ERR_MSG(extack, \"bytes leftover after parsing attributes\");\n\t\tif (validate & NL_VALIDATE_TRAILING)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void write_version(\n    FILE       *fp,\n    const char *fname,\n    const char *dirname,\n    xref_t     *xref)\n{\n    long  start;\n    char *c, *new_fname, data;\n    FILE *new_fp;\n    start = ftell(fp);\n    if ((c = strstr(fname, \".pdf\")))\n      *c = '\\0';\n    new_fname = malloc(strlen(fname) + strlen(dirname) + 16);\n    snprintf(new_fname, strlen(fname) + strlen(dirname) + 16,\n             \"%s/%s-version-%d.pdf\", dirname, fname, xref->version);\n    if (!(new_fp = fopen(new_fname, \"w\")))\n    {\n        ERR(\"Could not create file '%s'\\n\", new_fname);\n        fseek(fp, start, SEEK_SET);\n        free(new_fname);\n        return;\n    }\n    fseek(fp, 0, SEEK_SET);\n    while (fread(&data, 1, 1, fp))\n      fwrite(&data, 1, 1, new_fp);\n    fprintf(new_fp, \"\\r\\nstartxref\\r\\n%ld\\r\\n%%%%EOF\", xref->start);\n    fclose(new_fp);\n    free(new_fname);\n    fseek(fp, start, SEEK_SET);\n}", "target": 1}
{"code": "getSystemTempDir() {\n\tconst char *temp_dir = getenv(\"PASSENGER_TEMP_DIR\");\n\tif (temp_dir == NULL || *temp_dir == '\\0') {\n\t\ttemp_dir = getenv(\"PASSENGER_TMPDIR\");\n\t\tif (temp_dir == NULL || *temp_dir == '\\0') {\n\t\t\ttemp_dir = \"/tmp\";\n\t\t}\n\t}\n\treturn temp_dir;\n}", "target": 0}
{"code": "snmp_oid_decode_oid(uint8_t *buf, uint32_t *buff_len, uint32_t *oid, uint32_t *oid_len)\n{\n  uint32_t *start;\n  uint8_t *buf_end, type;\n  uint8_t len;\n  div_t first;\n  start = oid;\n  buf = snmp_ber_decode_type(buf, buff_len, &type);\n  if(buf == NULL) {\n    return NULL;\n  }\n  if(type != SNMP_DATA_TYPE_OBJECT) {\n    return NULL;\n  }\n  buf = snmp_ber_decode_length(buf, buff_len, &len);\n  if(buf == NULL) {\n    return NULL;\n  }\n  buf_end = buf + len;\n  (*buff_len)--;\n  first = div(*buf++, 40);\n  *oid++ = (uint32_t)first.quot;\n  *oid++ = (uint32_t)first.rem;\n  while(buf != buf_end) {\n    --(*oid_len);\n    if(*oid_len == 0) {\n      return NULL;\n    }\n    int i;\n    *oid = (uint32_t)(*buf & 0x7F);\n    for(i = 0; i < 4; i++) {\n      (*buff_len)--;\n      if((*buf++ & 0x80) == 0) {\n        break;\n      }\n      *oid <<= 7;\n      *oid |= (*buf & 0x7F);\n    }\n    ++oid;\n  }\n  *oid++ = ((uint32_t)-1);\n  *oid_len = (uint32_t)(oid - start);\n  return buf;\n}", "target": 1}
{"code": "  virtual ~GatherHostUsageTask() {}", "target": 0}
{"code": "void AsfVideo::streamProperties() {\n  DataBuf streamTypedBuf = io_->read(GUID);\n  enum class streamTypeInfo { Audio = 1, Video = 2 };\n  auto stream = static_cast<streamTypeInfo>(0);\n  auto tag_stream_type = GUIDReferenceTags.find(GUIDTag(streamTypedBuf.data()));\n  if (tag_stream_type != GUIDReferenceTags.end()) {\n    if (tag_stream_type->second == \"Audio_Media\")\n      stream = streamTypeInfo::Audio;\n    else if (tag_stream_type->second == \"Video_Media\")\n      stream = streamTypeInfo::Video;\n    io_->seek(io_->tell() + GUID, BasicIo::beg);  \n    uint64_t time_offset = readQWORDTag(io_);\n    if (stream == streamTypeInfo::Video)\n      xmpData()[\"Xmp.video.TimeOffset\"] = time_offset;\n    else if (stream == streamTypeInfo::Audio)\n      xmpData()[\"Xmp.audio.TimeOffset\"] = time_offset;\n    auto specific_data_length = readDWORDTag(io_);\n    auto correction_data_length = readDWORDTag(io_);\n    io_->seek(io_->tell() + WORD  + DWORD  + specific_data_length + correction_data_length,\n              BasicIo::beg);\n  }\n}  ", "target": 1}
{"code": "        friend std::ostream& operator<<(std::ostream& os, const query_string& qs)\n        {\n            os << \"[ \";\n            for (size_t i = 0; i < qs.key_value_pairs_.size(); ++i)\n            {\n                if (i)\n                    os << \", \";\n                os << qs.key_value_pairs_[i];\n            }\n            os << \" ]\";\n            return os;\n        }", "target": 0}
{"code": "KCleanup::operator= ( const KCleanup &src )\n{\n    copy( src );\n    return *this;\n}", "target": 0}
{"code": "snmp_api_set_string(snmp_varbind_t *varbind, uint32_t *oid, char *string)\n{\n  snmp_api_replace_oid(varbind, oid);\n  varbind->value_type = BER_DATA_TYPE_OCTET_STRING;\n  varbind->value.string.string = string;\n  varbind->value.string.length = strlen(string);\n}", "target": 1}
{"code": "RawTile OpenJPEGImage::getRegion( int ha, int va, unsigned int res, int layers, int x, int y, unsigned int w, unsigned int h ){\n  unsigned int obpc = bpc;\n  if( bpc <= 16 && bpc > 8 ) obpc = 16;\n  else if( bpc <= 8 ) obpc = 8;\n#ifdef DEBUG\n  Timer timer;\n  timer.start();\n#endif\n  RawTile rawtile( 0, res, ha, va, w, h, channels, obpc );\n  if( obpc == 16 ) rawtile.data = new unsigned short[w * h * channels];\n  else if( obpc == 8 ) rawtile.data = new unsigned char[w * h * channels];\n  else throw file_error( \"OpenJPEG :: Unsupported number of bits\" );\n  rawtile.dataLength = w*h*channels*(obpc/8);\n  rawtile.filename = getImagePath();\n  rawtile.timestamp = timestamp;\n  process( res, layers, x, y, w, h, rawtile.data );\n#ifdef DEBUG\n  logfile << \"OpenJPEG :: getRegion() :: \" << timer.getTime() << \" microseconds\" << endl;\n#endif\n  return rawtile;\n}", "target": 1}
{"code": "Status ValidatePaddingValues(absl::Span<const int64_t> input_dimensions,\n                             absl::Span<const int64_t> window_dimensions,\n                             absl::Span<const int64_t> window_strides) {\n  bool ok = input_dimensions.size() == window_dimensions.size() &&\n            input_dimensions.size() == window_strides.size();\n  if (!ok) {\n    return InvalidArgument(\n        \"Want input dimensions size %u = window dimensions size %u = window \"\n        \"strides size %u\",\n        input_dimensions.size(), window_dimensions.size(),\n        window_strides.size());\n  }\n  for (size_t i = 0; i < input_dimensions.size(); ++i) {\n    if (window_dimensions[i] <= 0) {\n      return InvalidArgument(\"Window dimension %u has non-positive size %d\", i,\n                             window_dimensions[i]);\n    }\n    if (window_strides[i] <= 0) {\n      return InvalidArgument(\"Window dimension %u has non-positive stride %d\",\n                             i, window_strides[i]);\n    }\n  }\n  return OkStatus();\n}", "target": 0}
{"code": "int nfs4_do_close(struct path *path, struct nfs4_state *state, int wait)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_closedata *calldata;\n\tstruct nfs4_state_owner *sp = state->owner;\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_CLOSE],\n\t\t.rpc_cred = state->owner->so_cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_close_ops,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tint status = -ENOMEM;\n\tcalldata = kmalloc(sizeof(*calldata), GFP_KERNEL);\n\tif (calldata == NULL)\n\t\tgoto out;\n\tcalldata->inode = state->inode;\n\tcalldata->state = state;\n\tcalldata->arg.fh = NFS_FH(state->inode);\n\tcalldata->arg.stateid = &state->open_stateid;\n\tcalldata->arg.seqid = nfs_alloc_seqid(&state->owner->so_seqid);\n\tif (calldata->arg.seqid == NULL)\n\t\tgoto out_free_calldata;\n\tcalldata->arg.open_flags = 0;\n\tcalldata->arg.bitmask = server->attr_bitmask;\n\tcalldata->res.fattr = &calldata->fattr;\n\tcalldata->res.seqid = calldata->arg.seqid;\n\tcalldata->res.server = server;\n\tcalldata->path.mnt = mntget(path->mnt);\n\tcalldata->path.dentry = dget(path->dentry);\n\tmsg.rpc_argp = &calldata->arg,\n\tmsg.rpc_resp = &calldata->res,\n\ttask_setup_data.callback_data = calldata;\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tstatus = 0;\n\tif (wait)\n\t\tstatus = rpc_wait_for_completion_task(task);\n\trpc_put_task(task);\n\treturn status;\nout_free_calldata:\n\tkfree(calldata);\nout:\n\tnfs4_put_open_state(state);\n\tnfs4_put_state_owner(sp);\n\treturn status;\n}", "target": 1}
{"code": " */\nstatic inline zval *add_next_index_object(zval *arg, zval *tmp)\n{\n\tHashTable *symtable;\n\tif (Z_TYPE_P(arg) == IS_OBJECT) {\n\t\tsymtable = Z_OBJPROP_P(arg);\n\t} else {\n\t\tsymtable = Z_ARRVAL_P(arg);\n\t}\n\treturn zend_hash_next_index_insert(symtable, tmp);", "target": 0}
{"code": "bool PrintWebViewHelper::InitPrintSettingsAndPrepareFrame(\n    WebKit::WebFrame* frame, const WebKit::WebNode& node,\n    scoped_ptr<PrepareFrameAndViewForPrint>* prepare) {\n  if (!InitPrintSettings(frame, node))\n    return false;\n  DCHECK(!prepare->get());\n  prepare->reset(new PrepareFrameAndViewForPrint(print_pages_params_->params,\n                                                 frame, node));\n  UpdatePrintableSizeInPrintParameters(frame, node, prepare->get(),\n                                       &print_pages_params_->params);\n  Send(new PrintHostMsg_DidGetDocumentCookie(\n        routing_id(), print_pages_params_->params.document_cookie));\n  return true;\n}", "target": 0}
{"code": "static int udp_v6_push_pending_frames(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\tstruct udphdr *uh;\n\tstruct udp_sock  *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct flowi6 *fl6 = &inet->cork.fl.u.ip6;\n\tint err = 0;\n\tint is_udplite = IS_UDPLITE(sk);\n\t__wsum csum = 0;\n\tif ((skb = skb_peek(&sk->sk_write_queue)) == NULL)\n\t\tgoto out;\n\tuh = udp_hdr(skb);\n\tuh->source = fl6->fl6_sport;\n\tuh->dest = fl6->fl6_dport;\n\tuh->len = htons(up->len);\n\tuh->check = 0;\n\tif (is_udplite)\n\t\tcsum = udplite_csum_outgoing(sk, skb);\n\telse if (skb->ip_summed == CHECKSUM_PARTIAL) { \n\t\tudp6_hwcsum_outgoing(sk, skb, &fl6->saddr, &fl6->daddr,\n\t\t\t\t     up->len);\n\t\tgoto send;\n\t} else\n\t\tcsum = udp_csum_outgoing(sk, skb);\n\tuh->check = csum_ipv6_magic(&fl6->saddr, &fl6->daddr,\n\t\t\t\t    up->len, fl6->flowi6_proto, csum);\n\tif (uh->check == 0)\n\t\tuh->check = CSUM_MANGLED_0;\nsend:\n\terr = ip6_push_pending_frames(sk);\n\tif (err) {\n\t\tif (err == -ENOBUFS && !inet6_sk(sk)->recverr) {\n\t\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\t    UDP_MIB_SNDBUFERRORS, is_udplite);\n\t\t\terr = 0;\n\t\t}\n\t} else\n\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t    UDP_MIB_OUTDATAGRAMS, is_udplite);\nout:\n\tup->len = 0;\n\tup->pending = 0;\n\treturn err;\n}", "target": 1}
{"code": "win_init_some(win_T *newp, win_T *oldp)\n{\n    newp->w_alist = oldp->w_alist;\n    ++newp->w_alist->al_refcount;\n    newp->w_arg_idx = oldp->w_arg_idx;\n    win_copy_options(oldp, newp);\n}", "target": 0}
{"code": "static void adapter_stop(struct btd_adapter *adapter)\n{\n\treply_pending_requests(adapter);\n\tcancel_passive_scanning(adapter);\n\tremove_discovery_list(adapter);\n\tdiscovery_cleanup(adapter, 0);\n\tadapter->filtered_discovery = false;\n\tadapter->no_scan_restart_delay = false;\n\tg_free(adapter->current_discovery_filter);\n\tadapter->current_discovery_filter = NULL;\n\tset_discovery_discoverable(adapter, false);\n\tadapter->discovering = false;\n\twhile (adapter->connections) {\n\t\tstruct btd_device *device = adapter->connections->data;\n\t\tuint8_t addr_type = btd_device_get_bdaddr_type(device);\n\t\tadapter_remove_connection(adapter, device, BDADDR_BREDR);\n\t\tif (addr_type != BDADDR_BREDR)\n\t\t\tadapter_remove_connection(adapter, device, addr_type);\n\t}\n\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Discovering\");\n\tif (adapter->dev_class) {\n\t\tadapter->dev_class = 0;\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\t\tADAPTER_INTERFACE, \"Class\");\n\t}\n\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\t\tADAPTER_INTERFACE, \"Powered\");\n\tDBG(\"adapter %s has been disabled\", adapter->path);\n}", "target": 0}
{"code": "spnego_gss_wrap(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t context_handle,\n\t\tint conf_req_flag,\n\t\tgss_qop_t qop_req,\n\t\tgss_buffer_t input_message_buffer,\n\t\tint *conf_state,\n\t\tgss_buffer_t output_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap(minor_status,\n\t\t    context_handle,\n\t\t    conf_req_flag,\n\t\t    qop_req,\n\t\t    input_message_buffer,\n\t\t    conf_state,\n\t\t    output_message_buffer);\n\treturn (ret);\n}", "target": 1}
{"code": "void HTMLMediaElement::SetSrc(const USVStringOrTrustedURL& stringOrURL,\n                              ExceptionState& exception_state) {\n  setAttribute(kSrcAttr, stringOrURL, exception_state);\n}", "target": 0}
{"code": "bool Item_splocal::set_value(THD *thd, sp_rcontext *ctx, Item **it)\n{\n  return ctx->set_variable(thd, get_var_idx(), it);\n}", "target": 0}
{"code": "vte_sequence_handler_dc (VteTerminal *terminal, GValueArray *params)\n{\n\tVteScreen *screen;\n\tVteRowData *rowdata;\n\tlong col;\n\tscreen = terminal->pvt->screen;\n\tif (_vte_ring_next(screen->row_data) > screen->cursor_current.row) {\n\t\tlong len;\n\t\trowdata = _vte_ring_index(screen->row_data,\n\t\t\t\t\t  VteRowData *,\n\t\t\t\t\t  screen->cursor_current.row);\n\t\tg_assert(rowdata != NULL);\n\t\tcol = screen->cursor_current.col;\n\t\tlen = rowdata->cells->len;\n\t\tif (col < len) {\n\t\t\tg_array_remove_index(rowdata->cells, col);\n\t\t\tif (screen->fill_defaults.attr.back != VTE_DEF_BG) {\n\t\t\t\tvte_g_array_fill (rowdata->cells,\n\t\t\t\t\t\t&screen->fill_defaults,\n\t\t\t\t\t\tterminal->column_count);\n\t\t\t\tlen = terminal->column_count;\n\t\t\t}\n\t\t\t_vte_invalidate_cells(terminal,\n\t\t\t\t\tcol, len - col,\n\t\t\t\t\tscreen->cursor_current.row, 1);\n\t\t}\n\t}\n\tterminal->pvt->text_deleted_flag = TRUE;\n}", "target": 0}
{"code": "code_to_mbclen(OnigCodePoint code, OnigEncoding enc ARG_UNUSED)\n{\n  if      ((code & 0xffffff80) == 0) return 1;\n  else if ((code & 0xfffff800) == 0) return 2;\n  else if ((code & 0xffff0000) == 0) return 3;\n  else if ((code & 0xffe00000) == 0) return 4;\n  else if ((code & 0xfc000000) == 0) return 5;\n  else if ((code & 0x80000000) == 0) return 6;\n#ifdef USE_INVALID_CODE_SCHEME\n  else if (code == INVALID_CODE_FE) return 1;\n  else if (code == INVALID_CODE_FF) return 1;\n#endif\n  else\n    return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;\n}", "target": 0}
{"code": "static int crypto_aead_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_aead raead;\n\tstruct aead_alg *aead = &alg->cra_aead;\n\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"aead\");\n\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t aead->geniv ?: \"<built-in>\");\n\traead.blocksize = alg->cra_blocksize;\n\traead.maxauthsize = aead->maxauthsize;\n\traead.ivsize = aead->ivsize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_AEAD,\n\t\t    sizeof(struct crypto_report_aead), &raead))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "static int open_url(AVFormatContext *s, AVIOContext **pb, const char *url,\n                    AVDictionary *opts, AVDictionary *opts2, int *is_http)\n{\n    HLSContext *c = s->priv_data;\n    AVDictionary *tmp = NULL;\n    const char *proto_name = NULL;\n    int ret;\n    av_dict_copy(&tmp, opts, 0);\n    av_dict_copy(&tmp, opts2, 0);\n    if (av_strstart(url, \"crypto\", NULL)) {\n        if (url[6] == '+' || url[6] == ':')\n            proto_name = avio_find_protocol_name(url + 7);\n    }\n    if (!proto_name)\n        proto_name = avio_find_protocol_name(url);\n    if (!proto_name)\n        return AVERROR_INVALIDDATA;\n    if (!av_strstart(proto_name, \"http\", NULL) && !av_strstart(proto_name, \"file\", NULL))\n        return AVERROR_INVALIDDATA;\n    if (!strncmp(proto_name, url, strlen(proto_name)) && url[strlen(proto_name)] == ':')\n        ;\n    else if (av_strstart(url, \"crypto\", NULL) && !strncmp(proto_name, url + 7, strlen(proto_name)) && url[7 + strlen(proto_name)] == ':')\n        ;\n    else if (strcmp(proto_name, \"file\") || !strncmp(url, \"file,\", 5))\n        return AVERROR_INVALIDDATA;\n    ret = s->io_open(s, pb, url, AVIO_FLAG_READ, &tmp);\n    if (ret >= 0) {\n        char *new_cookies = NULL;\n        if (!(s->flags & AVFMT_FLAG_CUSTOM_IO))\n            av_opt_get(*pb, \"cookies\", AV_OPT_SEARCH_CHILDREN, (uint8_t**)&new_cookies);\n        if (new_cookies) {\n            av_free(c->cookies);\n            c->cookies = new_cookies;\n        }\n        av_dict_set(&opts, \"cookies\", c->cookies, 0);\n    }\n    av_dict_free(&tmp);\n    if (is_http)\n        *is_http = av_strstart(proto_name, \"http\", NULL);\n    return ret;\n}", "target": 1}
{"code": "bgp_capability_vty_out (struct vty *vty, struct peer *peer)\n{\n  char *pnt;\n  char *end;\n  struct capability cap;\n  pnt = peer->notify.data;\n  end = pnt + peer->notify.length;\n  while (pnt < end)\n    {\n      memcpy(&cap, pnt, sizeof(struct capability));\n      if (pnt + 2 > end)\n\treturn;\n      if (pnt + (cap.length + 2) > end)\n\treturn;\n      if (cap.code == CAPABILITY_CODE_MP)\n\t{\n\t  vty_out (vty, \"  Capability error for: Multi protocol \");\n\t  switch (ntohs (cap.mpc.afi))\n\t    {\n\t    case AFI_IP:\n\t      vty_out (vty, \"AFI IPv4, \");\n\t      break;\n\t    case AFI_IP6:\n\t      vty_out (vty, \"AFI IPv6, \");\n\t      break;\n\t    default:\n\t      vty_out (vty, \"AFI Unknown %d, \", ntohs (cap.mpc.afi));\n\t      break;\n\t    }\n\t  switch (cap.mpc.safi)\n\t    {\n\t    case SAFI_UNICAST:\n\t      vty_out (vty, \"SAFI Unicast\");\n\t      break;\n\t    case SAFI_MULTICAST:\n\t      vty_out (vty, \"SAFI Multicast\");\n\t      break;\n\t    case SAFI_UNICAST_MULTICAST:\n\t      vty_out (vty, \"SAFI Unicast Multicast\");\n\t      break;\n\t    case BGP_SAFI_VPNV4:\n\t      vty_out (vty, \"SAFI MPLS-VPN\");\n\t      break;\n\t    default:\n\t      vty_out (vty, \"SAFI Unknown %d \", cap.mpc.safi);\n\t      break;\n\t    }\n\t  vty_out (vty, \"%s\", VTY_NEWLINE);\n\t}\n      else if (cap.code >= 128)\n\tvty_out (vty, \"  Capability error: vendor specific capability code %d\",\n\t\t cap.code);\n      else\n\tvty_out (vty, \"  Capability error: unknown capability code %d\", \n\t\t cap.code);\n      pnt += cap.length + 2;\n    }\n}", "target": 1}
{"code": "static int decode_band_types(AACContext *ac, enum BandType band_type[120],\n                             int band_type_run_end[120], GetBitContext *gb,\n                             IndividualChannelStream *ics)\n{\n    int g, idx = 0;\n    const int bits = (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) ? 3 : 5;\n    for (g = 0; g < ics->num_window_groups; g++) {\n        int k = 0;\n        while (k < ics->max_sfb) {\n            uint8_t sect_end = k;\n            int sect_len_incr;\n            int sect_band_type = get_bits(gb, 4);\n            if (sect_band_type == 12) {\n                av_log(ac->avctx, AV_LOG_ERROR, \"invalid band type\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n            do {\n                sect_len_incr = get_bits(gb, bits);\n                sect_end += sect_len_incr;\n                if (get_bits_left(gb) < 0) {\n                    av_log(ac->avctx, AV_LOG_ERROR, \"decode_band_types: \"overread_err);\n                    return AVERROR_INVALIDDATA;\n                }\n                if (sect_end > ics->max_sfb) {\n                    av_log(ac->avctx, AV_LOG_ERROR,\n                           \"Number of bands (%d) exceeds limit (%d).\\n\",\n                           sect_end, ics->max_sfb);\n                    return AVERROR_INVALIDDATA;\n                }\n            } while (sect_len_incr == (1 << bits) - 1);\n            for (; k < sect_end; k++) {\n                band_type        [idx]   = sect_band_type;\n                band_type_run_end[idx++] = sect_end;\n            }\n        }\n    }\n    return 0;\n}", "target": 0}
{"code": "absl::Status CompressTensorAsProto(const tensorflow::Tensor& tensor,\n                                   tensorflow::TensorProto* proto) {\n  if (!IsSupported(tensor.dtype())) {\n    return absl::InvalidArgumentError(absl::StrCat(\n        \"Tensor of dtype \", tensorflow::DataTypeString(tensor.dtype()),\n        \" is not supported for compression.\"));\n  }\n  if (tensor.dtype() == tensorflow::DT_STRING) {\n    tensor.AsProtoTensorContent(proto);\n    return absl::OkStatus();\n  } else {\n    proto->set_dtype(tensor.dtype());\n    tensor.shape().AsProto(proto->mutable_tensor_shape());\n    SnappyCompressFromString(tensor.tensor_data(),\n                             proto->mutable_tensor_content());\n    return absl::OkStatus();\n  }\n}", "target": 0}
{"code": "hybiDecodeCleanup(ws_ctx_t *wsctx)\n{\n  wsctx->header.payloadLen = 0;\n  wsctx->header.mask.u = 0;\n  wsctx->nReadRaw = 0;\n  wsctx->nToRead= 0;\n  wsctx->carrylen = 0;\n  wsctx->readPos = (unsigned char *)wsctx->codeBufDecode;\n  wsctx->readlen = 0;\n  wsctx->hybiDecodeState = WS_HYBI_STATE_HEADER_PENDING;\n  wsctx->writePos = NULL;\n  rfbLog(\"cleaned up wsctx\\n\");\n}", "target": 0}
{"code": "GF_Err hdlr_dump(GF_Box *a, FILE * trace)\n{\n\tGF_HandlerBox *p = (GF_HandlerBox *)a;\n\tgf_isom_box_dump_start(a, \"HandlerBox\", trace);\n\tif (p->nameUTF8 && (u32) p->nameUTF8[0] == strlen(p->nameUTF8+1)) {\n\t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8+1);\n\t} else {\n\t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8);\n\t}\n\tfprintf(trace, \"reserved1=\\\"%d\\\" reserved2=\\\"\", p->reserved1);\n\tdump_data(trace, (char *) p->reserved2, 12);\n\tfprintf(trace, \"\\\"\");\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"HandlerBox\", a, trace);\n\treturn GF_OK;\n}", "target": 1}
{"code": "static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)\n{\n\tstruct snd_seq_port_info *info = arg;\n\tstruct snd_seq_client_port *port;\n\tstruct snd_seq_port_callback *callback;\n\tif (info->addr.client != client->number)\n\t\treturn -EPERM;\n\tport = snd_seq_create_port(client, (info->flags & SNDRV_SEQ_PORT_FLG_GIVEN_PORT) ? info->addr.port : -1);\n\tif (port == NULL)\n\t\treturn -ENOMEM;\n\tif (client->type == USER_CLIENT && info->kernel) {\n\t\tsnd_seq_delete_port(client, port->addr.port);\n\t\treturn -EINVAL;\n\t}\n\tif (client->type == KERNEL_CLIENT) {\n\t\tif ((callback = info->kernel) != NULL) {\n\t\t\tif (callback->owner)\n\t\t\t\tport->owner = callback->owner;\n\t\t\tport->private_data = callback->private_data;\n\t\t\tport->private_free = callback->private_free;\n\t\t\tport->event_input = callback->event_input;\n\t\t\tport->c_src.open = callback->subscribe;\n\t\t\tport->c_src.close = callback->unsubscribe;\n\t\t\tport->c_dest.open = callback->use;\n\t\t\tport->c_dest.close = callback->unuse;\n\t\t}\n\t}\n\tinfo->addr = port->addr;\n\tsnd_seq_set_port_info(port, info);\n\tsnd_seq_system_client_ev_port_start(port->addr.client, port->addr.port);\n\treturn 0;\n}", "target": 1}
{"code": "TEST_P(Http2IntegrationTest, LargeRequestTrailersRejected) { testLargeRequestTrailers(66, 60); }", "target": 0}
{"code": "static int nfs4_intent_set_file(struct nameidata *nd, struct path *path, struct nfs4_state *state)\n{\n\tstruct file *filp;\n\tint ret;\n\tif (nd->intent.open.flags & FMODE_EXEC) {\n\t\tret = nfs_may_open(state->inode,\n\t\t\t\tstate->owner->so_cred,\n\t\t\t\tnd->intent.open.flags);\n\t\tif (ret < 0)\n\t\t\tgoto out_close;\n\t}\n\tfilp = lookup_instantiate_filp(nd, path->dentry, NULL);\n\tif (!IS_ERR(filp)) {\n\t\tstruct nfs_open_context *ctx;\n\t\tctx = nfs_file_open_context(filp);\n\t\tctx->state = state;\n\t\treturn 0;\n\t}\n\tret = PTR_ERR(filp);\nout_close:\n\tnfs4_close_sync(path, state, nd->intent.open.flags);\n\treturn ret;\n}", "target": 1}
{"code": "static PHP_NAMED_FUNCTION(zif_zip_entry_read)\n{\n\tzval * zip_entry;\n\tzend_long len = 0;\n\tzip_read_rsrc * zr_rsrc;\n\tzend_string *buffer;\n\tint n = 0;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r|l\", &zip_entry, &len) == FAILURE) {\n\t\treturn;\n\t}\n\tif ((zr_rsrc = (zip_read_rsrc *)zend_fetch_resource(Z_RES_P(zip_entry), le_zip_entry_name, le_zip_entry)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tif (len <= 0) {\n\t\tlen = 1024;\n\t}\n\tif (zr_rsrc->zf) {\n\t\tbuffer = zend_string_alloc(len, 0);\n\t\tn = zip_fread(zr_rsrc->zf, ZSTR_VAL(buffer), ZSTR_LEN(buffer));\n\t\tif (n > 0) {\n\t\t\tZSTR_VAL(buffer)[n] = '\\0';\n\t\t\tZSTR_LEN(buffer) = n;\n\t\t\tRETURN_NEW_STR(buffer);\n\t\t} else {\n\t\t\tzend_string_free(buffer);\n\t\t\tRETURN_EMPTY_STRING()\n\t\t}\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}", "target": 1}
{"code": "err_t verify_signed_hash(const struct RSA_public_key *k\n                         , u_char *s, unsigned int s_max_octets\n                         , u_char **psig\n                         , size_t hash_len\n                         , const u_char *sig_val, size_t sig_len)\n{\n    unsigned int padlen;\n    {\n\tchunk_t temp_s;\n\tMP_INT c;\n\tn_to_mpz(&c, sig_val, sig_len);\n\toswcrypto.mod_exp(&c, &c, &k->e, &k->n);\n\ttemp_s = mpz_to_n(&c, sig_len);\t\n        if(s_max_octets < sig_len) {\n            return \"2\"\"exponentiation failed; too many octets\";\n        }\n\tmemcpy(s, temp_s.ptr, sig_len);\n\tpfree(temp_s.ptr);\n\tmpz_clear(&c);\n    }\n    padlen = sig_len - 3 - hash_len;\n    DBG(DBG_CRYPT,\n\tDBG_dump(\"verify_sh decrypted SIG1:\", s, sig_len));\n    DBG(DBG_CRYPT, DBG_log(\"pad_len calculated: %d hash_len: %d\", padlen, (int)hash_len));\n    if(s[0]    != 0x00\n       || s[1] != 0x01\n       || s[padlen+2] != 0x00) {\n\treturn \"3\"\"SIG padding does not check out\";\n    }\n    s += padlen + 3;\n    (*psig) = s;\n    return NULL;\n}", "target": 1}
{"code": "void CScreenshotPortal::onScreenshot(sdbus::MethodCall& call) {\n    sdbus::ObjectPath requestHandle;\n    call >> requestHandle;\n    std::string appID;\n    call >> appID;\n    std::string parentWindow;\n    call >> parentWindow;\n    std::unordered_map<std::string, sdbus::Variant> options;\n    call >> options;\n    Debug::log(LOG, \"[screenshot] New screenshot request:\");\n    Debug::log(LOG, \"[screenshot]  | {}\", requestHandle.c_str());\n    Debug::log(LOG, \"[screenshot]  | appid: {}\", appID);\n    bool isInteractive = options.count(\"interactive\") && options[\"interactive\"].get<bool>() && inShellPath(\"slurp\");\n    const std::string HYPR_DIR             = \"/tmp/hypr/\";\n    const std::string SNAP_FILE            = \"xdph_screenshot.png\";\n    const std::string FILE_PATH            = HYPR_DIR + SNAP_FILE;\n    const std::string SNAP_CMD             = \"grim \" + FILE_PATH;\n    const std::string SNAP_INTERACTIVE_CMD = \"grim -g \\\"$(slurp)\\\" \" + FILE_PATH;\n    std::unordered_map<std::string, sdbus::Variant> results;\n    results[\"uri\"] = \"file:\n    std::filesystem::remove(FILE_PATH);\n    std::filesystem::create_directory(HYPR_DIR);\n    if (isInteractive)\n        execAndGet(SNAP_INTERACTIVE_CMD.c_str());\n    else\n        execAndGet(SNAP_CMD.c_str());\n    uint32_t responseCode = std::filesystem::exists(FILE_PATH) ? 0 : 1;\n    auto reply = call.createReply();\n    reply << responseCode;\n    reply << results;\n    reply.send();\n}", "target": 1}
{"code": "    long XmpValue::size() const\n    {\n        std::ostringstream os;\n        write(os);\n        return static_cast<long>(os.str().size());\n    }", "target": 0}
{"code": "eval_js(WebKitWebView * web_view, gchar *script, GString *result) {\n    WebKitWebFrame *frame;\n    JSGlobalContextRef context;\n    JSObjectRef globalobject;\n    JSStringRef var_name;\n    JSStringRef js_script;\n    JSValueRef js_result;\n    JSStringRef js_result_string;\n    size_t js_result_size;\n    js_init();\n    frame = webkit_web_view_get_main_frame(WEBKIT_WEB_VIEW(web_view));\n    context = webkit_web_frame_get_global_context(frame);\n    globalobject = JSContextGetGlobalObject(context);\n    var_name = JSStringCreateWithUTF8CString(\"Uzbl\");\n    JSObjectSetProperty(context, globalobject, var_name,\n                        JSObjectMake(context, uzbl.js.classref, NULL),\n                        kJSClassAttributeNone, NULL);\n    js_script = JSStringCreateWithUTF8CString(script);\n    js_result = JSEvaluateScript(context, js_script, globalobject, NULL, 0, NULL);\n    if (js_result && !JSValueIsUndefined(context, js_result)) {\n        js_result_string = JSValueToStringCopy(context, js_result, NULL);\n        js_result_size = JSStringGetMaximumUTF8CStringSize(js_result_string);\n        if (js_result_size) {\n            char js_result_utf8[js_result_size];\n            JSStringGetUTF8CString(js_result_string, js_result_utf8, js_result_size);\n            g_string_assign(result, js_result_utf8);\n        }\n        JSStringRelease(js_result_string);\n    }\n    JSObjectDeleteProperty(context, globalobject, var_name, NULL);\n    JSStringRelease(var_name);\n    JSStringRelease(js_script);\n}", "target": 1}
{"code": "Variant HHVM_FUNCTION(imageaffinematrixget,\n                      int64_t type,\n                      const Variant& options ) {\n  Array ret = Array::Create();\n  double affine[6];\n  int res = GD_FALSE, i;\n  switch((gdAffineStandardMatrix)type) {\n    case GD_AFFINE_TRANSLATE:\n    case GD_AFFINE_SCALE: {\n      double x, y;\n      Array aoptions = options.toArray();\n      if (aoptions.empty()) {\n        raise_warning(\"imageaffinematrixget(): Array expected as options\");\n        return false;\n      }\n      if (aoptions.exists(s_x)) {\n        x = aoptions[s_x].toDouble();\n      } else {\n        raise_warning(\"imageaffinematrixget(): Missing x position\");\n        return false;\n      }\n      if (aoptions.exists(s_y)) {\n        y = aoptions[s_y].toDouble();\n      } else {\n        raise_warning(\"imageaffinematrixget(): Missing x position\");\n        return false;\n      }\n      if (type == GD_AFFINE_TRANSLATE) {\n        res = gdAffineTranslate(affine, x, y);\n      } else {\n        res = gdAffineScale(affine, x, y);\n      }\n      break;\n    }\n    case GD_AFFINE_ROTATE:\n    case GD_AFFINE_SHEAR_HORIZONTAL:\n    case GD_AFFINE_SHEAR_VERTICAL: {\n      double angle;\n      double doptions = options.toDouble();\n      if (!doptions) {\n        raise_warning(\"imageaffinematrixget(): Number is expected as option\");\n        return false;\n      }\n      angle = doptions;\n      if (type == GD_AFFINE_SHEAR_HORIZONTAL) {\n        res = gdAffineShearHorizontal(affine, angle);\n      } else if (type == GD_AFFINE_SHEAR_VERTICAL) {\n        res = gdAffineShearVertical(affine, angle);\n      } else {\n        res = gdAffineRotate(affine, angle);\n      }\n      break;\n    }\n    default:\n      raise_warning(\"imageaffinematrixget():Invalid type for \"\n                    \"element %\" PRId64, type);\n      return false;\n  }\n  if (res == GD_FALSE) {\n    return false;\n  } else {\n    for (i = 0; i < 6; i++) {\n      ret.set(String(i, CopyString), affine[i]);\n    }\n  }\n  return ret;\n}", "target": 0}
{"code": "\tSilenceMessage(const std::string& mask, const std::string& flags)\n\t\t: ClientProtocol::Message(\"SILENCE\")\n\t{\n\t\tPushParam(mask);\n\t\tPushParam(flags);\n\t}", "target": 0}
{"code": "get_next_file(FILE *VFile, char *ptr)\n{\n\tchar *ret;\n\tret = fgets(ptr, PATH_MAX, VFile);\n\tif (!ret)\n\t\treturn NULL;\n\tif (ptr[strlen(ptr) - 1] == '\\n')\n\t\tptr[strlen(ptr) - 1] = '\\0';\n\treturn ret;\n}", "target": 1}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_bootstrap_methods_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaBootStrapMethod *bsm = NULL;\n\tut64 offset = 0;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_BOOTSTRAP_METHODS_ATTR;\n\t\tif (offset + 8 > sz)  {\n\t\t\tfree (attr);\n\t\t\treturn NULL;\n\t\t}\n\t\tattr->info.bootstrap_methods_attr.num_bootstrap_methods = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->info.bootstrap_methods_attr.bootstrap_methods = r_list_newf (r_bin_java_bootstrap_method_free);\n\t\tfor (i = 0; i < attr->info.bootstrap_methods_attr.num_bootstrap_methods; i++) {\n\t\t\tif (offset >= sz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbsm = r_bin_java_bootstrap_method_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (bsm) {\n\t\t\t\toffset += bsm->size;\n\t\t\t\tr_list_append (attr->info.bootstrap_methods_attr.bootstrap_methods, (void *) bsm);\n\t\t\t} else {\n\t\t\t}\n\t\t}\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}", "target": 0}
{"code": "spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n\t\t\t   gss_ctx_id_t context_handle,\n\t\t\t   int conf_req_flag,\n\t\t\t   gss_qop_t qop_req,\n\t\t\t   int *conf_state,\n\t\t\t   gss_iov_buffer_desc *iov,\n\t\t\t   int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_iov_length(minor_status,\n\t\t\t\t  context_handle,\n\t\t\t\t  conf_req_flag,\n\t\t\t\t  qop_req,\n\t\t\t\t  conf_state,\n\t\t\t\t  iov,\n\t\t\t\t  iov_count);\n\treturn (ret);\n}", "target": 1}
{"code": "static void f_parser (lua_State *L, void *ud) {\n  int i;\n  Proto *tf;\n  Closure *cl;\n  struct SParser *p = cast(struct SParser *, ud);\n  int c = luaZ_lookahead(p->z);\n  luaC_checkGC(L);\n  tf = ((c == LUA_SIGNATURE[0]) ? luaU_undump : luaY_parser)(L, p->z,\n                                                             &p->buff, p->name);\n  cl = luaF_newLclosure(L, tf->nups, hvalue(gt(L)));\n  cl->l.p = tf;\n  for (i = 0; i < tf->nups; i++)  \n    cl->l.upvals[i] = luaF_newupval(L);\n  setclvalue(L, L->top, cl);\n  incr_top(L);\n}", "target": 1}
{"code": "static int DefragBsdMissingFragmentIpv6Test(void)\n{\n    DefragInit();\n    default_policy = DEFRAG_POLICY_BSD;\n    Packet *packets[5];\n    packets[0] = BuildIpv6TestPacketWithContent(\n            IPPROTO_ICMP, 189, 16 >> 3, 1, (uint8_t *)\"AABBCCDDAABBDDCC\", 16);\n    packets[1] =\n            BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 189, 40 >> 3, 1, (uint8_t *)\"AACCBBDD\", 8);\n    packets[2] = BuildIpv6TestPacketWithContent(\n            IPPROTO_ICMP, 189, 8 >> 3, 1, (uint8_t *)\"AACCDDBBAADDBBCC\", 16);\n    packets[3] = BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 189, 0, 1, (uint8_t *)\"ZZZZZZZZ\", 8);\n    packets[4] =\n            BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 189, 48 >> 3, 0, (uint8_t *)\"DDCCBBAA\", 8);\n    Packet *r = Defrag(NULL, NULL, packets[0]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[1]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[2]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[3]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[4]);\n    FAIL_IF_NOT_NULL(r);\n#if 0\n    PrintRawDataFp(stdout, GET_PKT_DATA(r) + 40, GET_PKT_LEN(r) - 40);\n#endif\n    for (int i = 0; i < 5; i++) {\n        SCFree(packets[i]);\n    }\n    DefragDestroy();\n    PASS;\n}", "target": 0}
{"code": "snmp_ber_encode_oid(snmp_packet_t *snmp_packet, snmp_oid_t *oid)\n{\n  uint32_t val;\n  uint16_t original_out_len;\n  uint8_t pos;\n  original_out_len = snmp_packet->used;\n  pos = oid->length - 1;\n  while(pos) {\n    val = oid->data[pos];\n    if(snmp_packet->used == snmp_packet->max) {\n      return 0;\n    }\n    *snmp_packet->out-- = (uint8_t)(val & 0x7F);\n    snmp_packet->used++;\n    val >>= 7;\n    while(val) {\n      if(snmp_packet->used == snmp_packet->max) {\n        return 0;\n      }\n      *snmp_packet->out-- = (uint8_t)((val & 0x7F) | 0x80);\n      snmp_packet->used++;\n      val >>= 7;\n    }\n    pos--;\n  }\n  if(snmp_packet->used == snmp_packet->max) {\n    return 0;\n  }\n  val = *(snmp_packet->out + 1) + 40 * oid->data[pos];\n  snmp_packet->used--;\n  snmp_packet->out++;\n  if(snmp_packet->used == snmp_packet->max) {\n    return 0;\n  }\n  *snmp_packet->out-- = (uint8_t)(val & 0x7F);\n  snmp_packet->used++;\n  val >>= 7;\n  while(val) {\n    if(snmp_packet->used == snmp_packet->max) {\n      return 0;\n    }\n    *snmp_packet->out-- = (uint8_t)((val & 0x7F) | 0x80);\n    snmp_packet->used++;\n    val >>= 7;\n  }\n  if(!snmp_ber_encode_length(snmp_packet, snmp_packet->used - original_out_len)) {\n    return 0;\n  }\n  if(!snmp_ber_encode_type(snmp_packet, BER_DATA_TYPE_OBJECT_IDENTIFIER)) {\n    return 0;\n  }\n  return 1;\n}", "target": 0}
{"code": "static int add_push_report_sideband_pkt(git_push *push, git_pkt_data *data_pkt, git_buf *data_pkt_buf)\n{\n\tgit_pkt *pkt;\n\tconst char *line, *line_end;\n\tsize_t line_len;\n\tint error;\n\tint reading_from_buf = data_pkt_buf->size > 0;\n\tif (reading_from_buf) {\n\t\tgit_buf_put(data_pkt_buf, data_pkt->data, data_pkt->len);\n\t\tline = data_pkt_buf->ptr;\n\t\tline_len = data_pkt_buf->size;\n\t}\n\telse {\n\t\tline = data_pkt->data;\n\t\tline_len = data_pkt->len;\n\t}\n\twhile (line_len > 0) {\n\t\terror = git_pkt_parse_line(&pkt, line, &line_end, line_len);\n\t\tif (error == GIT_EBUFS) {\n\t\t\tif (!reading_from_buf)\n\t\t\t\tgit_buf_put(data_pkt_buf, line, line_len);\n\t\t\terror = 0;\n\t\t\tgoto done;\n\t\t}\n\t\telse if (error < 0)\n\t\t\tgoto done;\n\t\tline_len -= (line_end - line);\n\t\tline = line_end;\n\t\tif (pkt == NULL)\n\t\t\tcontinue;\n\t\terror = add_push_report_pkt(push, pkt);\n\t\tgit_pkt_free(pkt);\n\t\tif (error < 0 && error != GIT_ITEROVER)\n\t\t\tgoto done;\n\t}\n\terror = 0;\ndone:\n\tif (reading_from_buf)\n\t\tgit_buf_consume(data_pkt_buf, line_end);\n\treturn error;\n}", "target": 1}
{"code": "std::wstring Utf8To16(const std::string& utf8_string) {\n  return MB2WC(utf8_string, CP_UTF8);\n}", "target": 0}
{"code": "static int do_cmd (xd3_stream *stream, const char *buf)\n{\n  int ret;\n  if ((ret = system (buf)) != 0)\n    {\n      if (WIFEXITED (ret))\n\t{\n\t  stream->msg = \"command exited non-zero\";\n\t  IF_DEBUG1 (XPR(NT \"command was: %s\\n\", buf));\n\t}\n      else\n\t{\n\t  stream->msg = \"abnormal command termination\";\n\t}\n      return XD3_INTERNAL;\n    }\n  return 0;\n}", "target": 1}
{"code": "int socket_create(uint16_t port)\n{\n\tint sfd = -1;\n\tint yes = 1;\n#ifdef WIN32\n\tWSADATA wsa_data;\n\tif (!wsa_init) {\n\t\tif (WSAStartup(MAKEWORD(2,2), &wsa_data) != ERROR_SUCCESS) {\n\t\t\tfprintf(stderr, \"WSAStartup failed!\\n\");\n\t\t\tExitProcess(-1);\n\t\t}\n\t\twsa_init = 1;\n\t}\n#endif\n\tstruct sockaddr_in saddr;\n\tif (0 > (sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP))) {\n\t\tperror(\"socket()\");\n\t\treturn -1;\n\t}\n\tif (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) {\n\t\tperror(\"setsockopt()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\tmemset((void *) &saddr, 0, sizeof(saddr));\n\tsaddr.sin_family = AF_INET;\n\tsaddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\tsaddr.sin_port = htons(port);\n\tif (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {\n\t\tperror(\"bind()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\tif (listen(sfd, 1) == -1) {\n\t\tperror(\"listen()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\treturn sfd;\n}", "target": 1}
{"code": "filter_session_io(struct io *io, int evt, void *arg)\n{\n\tstruct filter_session *fs = arg;\n\tchar *line = NULL;\n\tssize_t len;\n\tlog_trace(TRACE_IO, \"filter session: %p: %s %s\", fs, io_strevent(evt),\n\t    io_strio(io));\n\tswitch (evt) {\n\tcase IO_DATAIN:\n\tnextline:\n\t\tline = io_getline(fs->io, &len);\n\t\tif (line == NULL)\n\t\t\treturn;\n\t\tfilter_data(fs->id, line);\n\t\tgoto nextline;\n\tcase IO_DISCONNECTED:\n\t\tio_free(fs->io);\n\t\tfs->io = NULL;\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "void Item_hex_string::print(String *str, enum_query_type query_type)\n{\n  str->append(\"X'\");\n  str->append_hex(str_value.ptr(), str_value.length());\n  str->append(\"'\");\n}", "target": 0}
{"code": "static void xen_netbk_fill_frags(struct xen_netbk *netbk, struct sk_buff *skb)\n{\n\tstruct skb_shared_info *shinfo = skb_shinfo(skb);\n\tint nr_frags = shinfo->nr_frags;\n\tint i;\n\tfor (i = 0; i < nr_frags; i++) {\n\t\tskb_frag_t *frag = shinfo->frags + i;\n\t\tstruct xen_netif_tx_request *txp;\n\t\tstruct page *page;\n\t\tu16 pending_idx;\n\t\tpending_idx = frag_get_pending_idx(frag);\n\t\ttxp = &netbk->pending_tx_info[pending_idx].req;\n\t\tpage = virt_to_page(idx_to_kaddr(netbk, pending_idx));\n\t\t__skb_fill_page_desc(skb, i, page, txp->offset, txp->size);\n\t\tskb->len += txp->size;\n\t\tskb->data_len += txp->size;\n\t\tskb->truesize += txp->size;\n\t\tget_page(netbk->mmap_pages[pending_idx]);\n\t\txen_netbk_idx_release(netbk, pending_idx);\n\t}\n}", "target": 1}
{"code": "int oidc_handle_redirect_uri_request(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\tif (oidc_proto_is_redirect_authorization_response(r, c)) {\n\t\treturn oidc_handle_redirect_authorization_response(r, c, session);\n\t} else if (oidc_proto_is_post_authorization_response(r, c)) {\n\t\treturn oidc_handle_post_authorization_response(r, c, session);\n\t} else if (oidc_is_discovery_response(r, c)) {\n\t\treturn oidc_handle_discovery_response(r, c);\n\t} else if (oidc_util_request_has_parameter(r, \"logout\")) {\n\t\treturn oidc_handle_logout(r, c, session);\n\t} else if (oidc_util_request_has_parameter(r, \"jwks\")) {\n\t\treturn oidc_handle_jwks(r, c);\n\t} else if (oidc_util_request_has_parameter(r, \"session\")) {\n\t\treturn oidc_handle_session_management(r, c, session);\n\t} else if (oidc_util_request_has_parameter(r, \"refresh\")) {\n\t\treturn oidc_handle_refresh_token_request(r, c, session);\n\t} else if (oidc_util_request_has_parameter(r, \"request_uri\")) {\n\t\treturn oidc_handle_request_uri(r, c);\n\t} else if (oidc_util_request_has_parameter(r, \"remove_at_cache\")) {\n\t\treturn oidc_handle_remove_at_cache(r, c);\n\t} else if ((r->args == NULL) || (apr_strnatcmp(r->args, \"\") == 0)) {\n\t\treturn oidc_proto_javascript_implicit(r, c);\n\t}\n\tif (oidc_util_request_has_parameter(r, \"error\")) {\n\t\toidc_handle_redirect_authorization_response(r, c, session);\n\t}\n\treturn oidc_util_html_send_error(r, c->error_template, \"Invalid Request\",\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"The OpenID Connect callback URL received an invalid request: %s\",\n\t\t\t\t\tr->args), HTTP_INTERNAL_SERVER_ERROR);\n}", "target": 1}
{"code": "__u32 secure_tcp_sequence_number(__be32 saddr, __be32 daddr,\n\t\t\t\t __be16 sport, __be16 dport)\n{\n\t__u32 seq;\n\t__u32 hash[4];\n\tstruct keydata *keyptr = get_keyptr();\n\thash[0] = (__force u32)saddr;\n\thash[1] = (__force u32)daddr;\n\thash[2] = ((__force u16)sport << 16) + (__force u16)dport;\n\thash[3] = keyptr->secret[11];\n\tseq = half_md4_transform(hash, keyptr->secret) & HASH_MASK;\n\tseq += keyptr->count;\n\tseq += ktime_to_ns(ktime_get_real()) >> 6;\n\treturn seq;\n}", "target": 1}
{"code": "static int mem_read(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tint n;\n\tassert(cnt >= 0);\n\tassert(buf);\n\tJAS_DBGLOG(100, (\"mem_read(%p, %p, %d)\\n\", obj, buf, cnt));\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tn = m->len_ - m->pos_;\n\tcnt = JAS_MIN(n, cnt);\n\tmemcpy(buf, &m->buf_[m->pos_], cnt);\n\tm->pos_ += cnt;\n\treturn cnt;\n}", "target": 1}
{"code": "static int bson_append_estart( bson *b, int type, const char *name, const int dataSize ) {\n    const int len = strlen( name ) + 1;\n    if ( b->finished ) {\n        b->err |= BSON_ALREADY_FINISHED;\n        return BSON_ERROR;\n    }\n    if ( bson_ensure_space( b, 1 + len + dataSize ) == BSON_ERROR ) {\n        return BSON_ERROR;\n    }\n    if( bson_check_field_name( b, ( const char * )name, len - 1 ) == BSON_ERROR ) {\n        bson_builder_error( b );\n        return BSON_ERROR;\n    }\n    bson_append_byte( b, ( char )type );\n    bson_append( b, name, len );\n    return BSON_OK;\n}", "target": 1}
{"code": "void Rectangle(double x,double y,double w,double h) {\n    outpos += sprintf(outpos,\"\\n %12.3f %12.3f %12.3f %12.3f re\",x,y,w,h);\n}", "target": 1}
{"code": "TEST_IMPL(utf8_decode1_overrun) {\n  const char* p;\n  char b[1];\n  char c[1];\n  p = b;\n  b[0] = 0x7F;\n  ASSERT_EQ(0x7F, uv__utf8_decode1(&p, b + 1));\n  ASSERT_PTR_EQ(p, b + 1);\n  p = b;\n  b[0] = 0xC0;\n  ASSERT_EQ((unsigned) -1, uv__utf8_decode1(&p, b + 1));\n  ASSERT_PTR_EQ(p, b + 1);\n  b[0] = 0x7F;\n  ASSERT_EQ(UV_EINVAL, uv__idna_toascii(b, b + 0, c, c + 1));\n  ASSERT_EQ(UV_EINVAL, uv__idna_toascii(b, b + 1, c, c + 1));\n  return 0;\n}", "target": 0}
{"code": "static void spl_array_rewind_ex(spl_array_object *intern, HashTable *aht TSRMLS_DC) \n{\n\tzend_hash_internal_pointer_reset_ex(aht, &intern->pos);\n\tspl_array_update_pos(intern);\n\tspl_array_skip_protected(intern, aht TSRMLS_CC);\n} ", "target": 0}
{"code": "static int ReadHuffmanCodeLengths(\n    VP8LDecoder* const dec, const int* const code_length_code_lengths,\n    int num_symbols, int* const code_lengths) {\n  int ok = 0;\n  VP8LBitReader* const br = &dec->br_;\n  int symbol;\n  int max_symbol;\n  int prev_code_len = DEFAULT_CODE_LENGTH;\n  HuffmanCode table[1 << LENGTHS_TABLE_BITS];\n  if (!VP8LBuildHuffmanTable(table, LENGTHS_TABLE_BITS,\n                             code_length_code_lengths,\n                             NUM_CODE_LENGTH_CODES)) {\n    goto End;\n  }\n  if (VP8LReadBits(br, 1)) {    \n    const int length_nbits = 2 + 2 * VP8LReadBits(br, 3);\n    max_symbol = 2 + VP8LReadBits(br, length_nbits);\n    if (max_symbol > num_symbols) {\n      goto End;\n    }\n  } else {\n    max_symbol = num_symbols;\n  }\n  symbol = 0;\n  while (symbol < num_symbols) {\n    const HuffmanCode* p;\n    int code_len;\n    if (max_symbol-- == 0) break;\n    VP8LFillBitWindow(br);\n    p = &table[VP8LPrefetchBits(br) & LENGTHS_TABLE_MASK];\n    VP8LSetBitPos(br, br->bit_pos_ + p->bits);\n    code_len = p->value;\n    if (code_len < kCodeLengthLiterals) {\n      code_lengths[symbol++] = code_len;\n      if (code_len != 0) prev_code_len = code_len;\n    } else {\n      const int use_prev = (code_len == kCodeLengthRepeatCode);\n      const int slot = code_len - kCodeLengthLiterals;\n      const int extra_bits = kCodeLengthExtraBits[slot];\n      const int repeat_offset = kCodeLengthRepeatOffsets[slot];\n      int repeat = VP8LReadBits(br, extra_bits) + repeat_offset;\n      if (symbol + repeat > num_symbols) {\n        goto End;\n      } else {\n        const int length = use_prev ? prev_code_len : 0;\n        while (repeat-- > 0) code_lengths[symbol++] = length;\n      }\n    }\n  }\n  ok = 1;\n End:\n  if (!ok) return VP8LSetError(dec, VP8_STATUS_BITSTREAM_ERROR);\n  return ok;\n}", "target": 1}
{"code": "void zend_throw_exception_internal(zval *exception TSRMLS_DC) \n{\n#ifdef HAVE_DTRACE\n\tif (DTRACE_EXCEPTION_THROWN_ENABLED()) {\n\t\tconst char *classname;\n\t\tzend_uint name_len;\n\t\tif (exception != NULL) {\n\t\t\tzend_get_object_classname(exception, &classname, &name_len TSRMLS_CC);\n\t\t\tDTRACE_EXCEPTION_THROWN((char *)classname);\n\t\t} else {\n\t\t\tDTRACE_EXCEPTION_THROWN(NULL);\n\t\t}\n\t}\n#endif \n\tif (exception != NULL) {\n\t\tzval *previous = EG(exception);\n\t\tzend_exception_set_previous(exception, EG(exception) TSRMLS_CC);\n\t\tEG(exception) = exception;\n\t\tif (previous) {\n\t\t\treturn;\n\t\t}\n\t}\n\tif (!EG(current_execute_data)) {\n\t\tif(EG(exception)) {\n\t\t\tzend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n\t\t}\n\t\tzend_error(E_ERROR, \"Exception thrown without a stack frame\");\n\t}\n\tif (zend_throw_exception_hook) {\n\t\tzend_throw_exception_hook(exception TSRMLS_CC);\n\t}\n\tif (EG(current_execute_data)->opline == NULL ||\n\t    (EG(current_execute_data)->opline+1)->opcode == ZEND_HANDLE_EXCEPTION) {\n\t\treturn;\n\t}\n\tEG(opline_before_exception) = EG(current_execute_data)->opline;\n\tEG(current_execute_data)->opline = EG(exception_op);\n}", "target": 0}
{"code": "static struct port_buffer *get_inbuf(struct port *port)\n{\n\tstruct port_buffer *buf;\n\tunsigned int len;\n\tif (port->inbuf)\n\t\treturn port->inbuf;\n\tbuf = virtqueue_get_buf(port->in_vq, &len);\n\tif (buf) {\n\t\tbuf->len = len;\n\t\tbuf->offset = 0;\n\t\tport->stats.bytes_received += len;\n\t}\n\treturn buf;\n}", "target": 1}
{"code": "BOOL freerdp_bitmap_planar_context_reset(BITMAP_PLANAR_CONTEXT* context, UINT32 width,\n                                         UINT32 height)\n{\n\tif (!context)\n\t\treturn FALSE;\n\tcontext->bgr = FALSE;\n\tcontext->maxWidth = PLANAR_ALIGN(width, 4);\n\tcontext->maxHeight = PLANAR_ALIGN(height, 4);\n\tcontext->maxPlaneSize = context->maxWidth * context->maxHeight;\n\tcontext->nTempStep = context->maxWidth * 4;\n\tvoid* tmp = winpr_aligned_recalloc(context->planesBuffer, context->maxPlaneSize, 4, 32);\n\tif (!tmp)\n\t\treturn FALSE;\n\tcontext->planesBuffer = tmp;\n\ttmp = winpr_aligned_recalloc(context->pTempData, context->maxPlaneSize, 6, 32);\n\tif (!tmp)\n\t\treturn FALSE;\n\tcontext->pTempData = tmp;\n\ttmp = winpr_aligned_recalloc(context->deltaPlanesBuffer, context->maxPlaneSize, 4, 32);\n\tif (!tmp)\n\t\treturn FALSE;\n\tcontext->deltaPlanesBuffer = tmp;\n\ttmp = winpr_aligned_recalloc(context->rlePlanesBuffer, context->maxPlaneSize, 4, 32);\n\tif (!tmp)\n\t\treturn FALSE;\n\tcontext->rlePlanesBuffer = tmp;\n\tcontext->planes[0] = &context->planesBuffer[context->maxPlaneSize * 0];\n\tcontext->planes[1] = &context->planesBuffer[context->maxPlaneSize * 1];\n\tcontext->planes[2] = &context->planesBuffer[context->maxPlaneSize * 2];\n\tcontext->planes[3] = &context->planesBuffer[context->maxPlaneSize * 3];\n\tcontext->deltaPlanes[0] = &context->deltaPlanesBuffer[context->maxPlaneSize * 0];\n\tcontext->deltaPlanes[1] = &context->deltaPlanesBuffer[context->maxPlaneSize * 1];\n\tcontext->deltaPlanes[2] = &context->deltaPlanesBuffer[context->maxPlaneSize * 2];\n\tcontext->deltaPlanes[3] = &context->deltaPlanesBuffer[context->maxPlaneSize * 3];\n\treturn TRUE;\n}", "target": 1}
{"code": "rpki_rtr_print(netdissect_options *ndo, register const u_char *pptr, register u_int len)\n{\n    u_int tlen, pdu_type, pdu_len;\n    const u_char *tptr;\n    const rpki_rtr_pdu *pdu_header;\n    tptr = pptr;\n    tlen = len;\n    if (!ndo->ndo_vflag) {\n\tND_PRINT((ndo, \", RPKI-RTR\"));\n\treturn;\n    }\n    while (tlen >= sizeof(rpki_rtr_pdu)) {\n        ND_TCHECK2(*tptr, sizeof(rpki_rtr_pdu));\n\tpdu_header = (const rpki_rtr_pdu *)tptr;\n        pdu_type = pdu_header->pdu_type;\n        pdu_len = EXTRACT_32BITS(pdu_header->length);\n        ND_TCHECK2(*tptr, pdu_len);\n        if (!pdu_type || !pdu_len) {\n            break;\n        }\n        if (tlen < pdu_len) {\n            goto trunc;\n        }\n\tif (rpki_rtr_pdu_print(ndo, tptr, 8))\n\t\tgoto trunc;\n        tlen -= pdu_len;\n        tptr += pdu_len;\n    }\n    return;\ntrunc:\n    ND_PRINT((ndo, \"\\n\\t%s\", tstr));\n}", "target": 1}
{"code": "static const ut8 *parse_die(const ut8 *buf, const ut8 *buf_end, RBinDwarfAbbrevDecl *abbrev, RBinDwarfCompUnitHdr *hdr, RBinDwarfDie *die, const ut8 *debug_str, size_t debug_str_len, Sdb *sdb) {\n\tsize_t i;\n\tif (!buf || !buf_end || buf > buf_end) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < die->count; i++) {\n\t\tmemset (&die->attr_values[i], 0, sizeof (RBinDwarfDie));\n\t}\n\tfor (i = 0; i < abbrev->count && i < die->capacity; i++) {\n\t\tmemset (&die->attr_values[i], 0, sizeof (die->attr_values[i]));\n\t\tconst ut8 *nbuf = parse_attr_value (buf, buf_end - buf,\n\t\t\t&abbrev->defs[i],\n\t\t\t&die->attr_values[i],\n\t\t\thdr, debug_str, debug_str_len);\n\t\tif (nbuf) {\n\t\t\tbuf = nbuf;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\tRBinDwarfAttrValue *attribute = &die->attr_values[i];\n\t\tbool is_string = (attribute->attr_form == DW_FORM_strp || attribute->attr_form == DW_FORM_string);\n\t\tbool is_valid_string_form = is_string && attribute->string.content;\n\t\tif (attribute->attr_name == DW_AT_comp_dir && is_valid_string_form) {\n\t\t\tconst char *name = attribute->string.content;\n\t\t\tsdb_set (sdb, \"DW_AT_comp_dir\", name, 0);\n\t\t}\n\t\tdie->count++;\n\t}\n\treturn buf;\n}", "target": 1}
{"code": "static inline int xrstor_state_booting(struct xsave_struct *fx, u64 mask)\n{\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\tint err = 0;\n\tWARN_ON(system_state != SYSTEM_BOOTING);\n\tif (boot_cpu_has(X86_FEATURE_XSAVES))\n\t\tasm volatile(\"1:\"XRSTORS\"\\n\\t\"\n\t\t\t\"2:\\n\\t\"\n\t\t\t: : \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t\t:   \"memory\");\n\telse\n\t\tasm volatile(\"1:\"XRSTOR\"\\n\\t\"\n\t\t\t\"2:\\n\\t\"\n\t\t\t: : \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t\t:   \"memory\");\n\tasm volatile(xstate_fault\n\t\t     : \"0\" (0)\n\t\t     : \"memory\");\n\treturn err;\n}", "target": 1}
{"code": "int ipmi_si_mem_setup(struct si_sm_io *io)\n{\n\tunsigned long addr = io->addr_data;\n\tint           mapsize, idx;\n\tif (!addr)\n\t\treturn -ENODEV;\n\tio->io_cleanup = mem_cleanup;\n\tswitch (io->regsize) {\n\tcase 1:\n\t\tio->inputb = intf_mem_inb;\n\t\tio->outputb = intf_mem_outb;\n\t\tbreak;\n\tcase 2:\n\t\tio->inputb = intf_mem_inw;\n\t\tio->outputb = intf_mem_outw;\n\t\tbreak;\n\tcase 4:\n\t\tio->inputb = intf_mem_inl;\n\t\tio->outputb = intf_mem_outl;\n\t\tbreak;\n#ifdef readq\n\tcase 8:\n\t\tio->inputb = mem_inq;\n\t\tio->outputb = mem_outq;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tdev_warn(io->dev, \"Invalid register size: %d\\n\",\n\t\t\t io->regsize);\n\t\treturn -EINVAL;\n\t}\n\tfor (idx = 0; idx < io->io_size; idx++) {\n\t\tif (request_mem_region(addr + idx * io->regspacing,\n\t\t\t\t       io->regsize, DEVICE_NAME) == NULL) {\n\t\t\tmem_region_cleanup(io, idx);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\tmapsize = ((io->io_size * io->regspacing)\n\t\t   - (io->regspacing - io->regsize));\n\tio->addr = ioremap(addr, mapsize);\n\tif (io->addr == NULL) {\n\t\tmem_region_cleanup(io, io->io_size);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "MagickExport MagickBooleanType DrawClipPath(Image *image,\n  const DrawInfo *draw_info,const char *name,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n  Image\n    *clip_mask;\n  const char\n    *value;\n  DrawInfo\n    *clone_info;\n  MagickStatusType\n    status;\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(draw_info != (const DrawInfo *) NULL);\n  (void) FormatLocaleString(filename,MagickPathExtent,\"%s\",name);\n  value=GetImageArtifact(image,filename);\n  if (value == (const char *) NULL)\n    return(MagickFalse);\n  clip_mask=CloneImage(image,image->columns,image->rows,MagickTrue,exception);\n  if (clip_mask == (Image *) NULL)\n    return(MagickFalse);\n  (void) QueryColorCompliance(\"#0000\",AllCompliance,\n    &clip_mask->background_color,exception);\n  clip_mask->background_color.alpha=(Quantum) TransparentAlpha;\n  (void) SetImageBackgroundColor(clip_mask,exception);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"\\nbegin clip-path %s\",\n      draw_info->clip_mask);\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  (void) CloneString(&clone_info->primitive,value);\n  (void) QueryColorCompliance(\"#ffffff\",AllCompliance,&clone_info->fill,\n    exception);\n  clone_info->clip_mask=(char *) NULL;\n  status=NegateImage(clip_mask,MagickFalse,exception);\n  (void) SetImageMask(image,ReadPixelMask,clip_mask,exception);\n  clip_mask=DestroyImage(clip_mask);\n  status&=DrawImage(image,clone_info,exception);\n  clone_info=DestroyDrawInfo(clone_info);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"end clip-path\");\n  return(status != 0 ? MagickTrue : MagickFalse);\n}", "target": 1}
{"code": "int _yr_re_is_word_char(\n    uint8_t* input,\n    int character_size)\n{\n  int result = ((isalnum(*input) || (*input) == '_'));\n  if (character_size == 2)\n    result = result && (*(input + 1) == 0);\n  return result;\n}", "target": 0}
{"code": "PHP_NAMED_FUNCTION(zif_locale_set_default)\n{\n\tchar* locale_name = NULL;\n\tint   len=0;\t\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  \"s\",\n\t\t&locale_name ,&len ) == FAILURE)\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t \t\"locale_set_default: unable to parse input params\", 0 TSRMLS_CC );\n\t\tRETURN_FALSE;\n\t}\n\tif(len == 0) {\n\t\tlocale_name =  (char *)uloc_getDefault() ;\n\t\tlen = strlen(locale_name);\n\t}\n\tzend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\t\n\tRETURN_TRUE;\n}", "target": 1}
{"code": "exif_data_load_data_thumbnail (ExifData *data, const unsigned char *d,\n\t\t\t       unsigned int ds, ExifLong o, ExifLong s)\n{\n\tif ((o + s < o) || (o + s < s) || (o + s > ds) || (o > ds)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t  \"Bogus thumbnail offset (%u) or size (%u).\",\n\t\t\t  o, s);\n\t\treturn;\n\t}\n\tif (data->data) \n\t\texif_mem_free (data->priv->mem, data->data);\n\tif (!(data->data = exif_data_alloc (data, s))) {\n\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", s);\n\t\tdata->size = 0;\n\t\treturn;\n\t}\n\tdata->size = s;\n\tmemcpy (data->data, d + o, s);\n}", "target": 1}
{"code": "static ssize_t __disk_events_show(unsigned int events, char *buf)\n{\n\tconst char *delim = \"\";\n\tssize_t pos = 0;\n\tint i;\n\tfor (i = 0; i < ARRAY_SIZE(disk_events_strs); i++)\n\t\tif (events & (1 << i)) {\n\t\t\tpos += sprintf(buf + pos, \"%s%s\",\n\t\t\t\t       delim, disk_events_strs[i]);\n\t\t\tdelim = \" \";\n\t\t}\n\tif (pos)\n\t\tpos += sprintf(buf + pos, \"\\n\");\n\treturn pos;\n}", "target": 0}
{"code": "void MoveTo(double x1,double y1) {\n    outpos +=\n    sprintf(outpos,\"\\n %12.3f %12.3f m\",x1,y1);\n}", "target": 1}
{"code": "int __fsnotify_parent(const struct path *path, struct dentry *dentry, __u32 mask)\n{\n\tstruct dentry *parent;\n\tstruct inode *p_inode;\n\tint ret = 0;\n\tif (!dentry)\n\t\tdentry = path->dentry;\n\tif (!(dentry->d_flags & DCACHE_FSNOTIFY_PARENT_WATCHED))\n\t\treturn 0;\n\tparent = dget_parent(dentry);\n\tp_inode = parent->d_inode;\n\tif (unlikely(!fsnotify_inode_watches_children(p_inode)))\n\t\t__fsnotify_update_child_dentry_flags(p_inode);\n\telse if (p_inode->i_fsnotify_mask & mask) {\n\t\tmask |= FS_EVENT_ON_CHILD;\n\t\tif (path)\n\t\t\tret = fsnotify(p_inode, mask, path, FSNOTIFY_EVENT_PATH,\n\t\t\t\t       dentry->d_name.name, 0);\n\t\telse\n\t\t\tret = fsnotify(p_inode, mask, dentry->d_inode, FSNOTIFY_EVENT_INODE,\n\t\t\t\t       dentry->d_name.name, 0);\n\t}\n\tdput(parent);\n\treturn ret;\n}", "target": 1}
{"code": "NativeModule::NativeModule(const std::string& filename) : init(nullptr) {\n\tif (!IsolateEnvironment::GetCurrent()->IsDefault()) {\n\t\tthrow RuntimeGenericError(\"NativeModule may only be instantiated from default nodejs isolate\");\n\t}\n\tif (uv_dlopen(filename.c_str(), &lib) != 0) {\n\t\tthrow RuntimeGenericError(\"Failed to load module\");\n\t}\n\tif (uv_dlsym(&lib, \"InitForContext\", reinterpret_cast<void**>(&init)) != 0 || init == nullptr) {\n\t\tuv_dlclose(&lib);\n\t\tthrow RuntimeGenericError(\"Module is not isolated-vm compatible\");\n\t}\n}", "target": 0}
{"code": "static void update_cr8_intercept(struct kvm_vcpu *vcpu)\n{\n\tint max_irr, tpr;\n\tif (!kvm_x86_ops->update_cr8_intercept)\n\t\treturn;\n\tif (!vcpu->arch.apic)\n\t\treturn;\n\tif (!vcpu->arch.apic->vapic_addr)\n\t\tmax_irr = kvm_lapic_find_highest_irr(vcpu);\n\telse\n\t\tmax_irr = -1;\n\tif (max_irr != -1)\n\t\tmax_irr >>= 4;\n\ttpr = kvm_lapic_get_cr8(vcpu);\n\tkvm_x86_ops->update_cr8_intercept(vcpu, tpr, max_irr);\n}", "target": 0}
{"code": "bool RenderWidgetHostImpl::GetResizeParams(ResizeParams* resize_params) {\n  *resize_params = ResizeParams();\n  GetWebScreenInfo(&resize_params->screen_info);\n  if (delegate_) {\n    resize_params->resizer_rect = delegate_->GetRootWindowResizerRect(this);\n    resize_params->is_fullscreen_granted =\n        delegate_->IsFullscreenForCurrentTab(this);\n    resize_params->display_mode = delegate_->GetDisplayMode(this);\n  } else {\n    resize_params->is_fullscreen_granted = false;\n    resize_params->display_mode = blink::WebDisplayModeBrowser;\n  }\n  if (view_) {\n    resize_params->new_size = view_->GetRequestedRendererSize();\n    resize_params->physical_backing_size = view_->GetPhysicalBackingSize();\n    resize_params->top_controls_height = view_->GetTopControlsHeight();\n    resize_params->top_controls_shrink_blink_size =\n        view_->DoTopControlsShrinkBlinkSize();\n    resize_params->visible_viewport_size = view_->GetVisibleViewportSize();\n  }\n  const bool size_changed =\n      !old_resize_params_ ||\n      old_resize_params_->new_size != resize_params->new_size ||\n      (old_resize_params_->physical_backing_size.IsEmpty() &&\n       !resize_params->physical_backing_size.IsEmpty());\n  bool dirty = size_changed ||\n      old_resize_params_->screen_info != resize_params->screen_info ||\n      old_resize_params_->physical_backing_size !=\n          resize_params->physical_backing_size ||\n      old_resize_params_->is_fullscreen_granted !=\n          resize_params->is_fullscreen_granted ||\n      old_resize_params_->display_mode != resize_params->display_mode ||\n      old_resize_params_->top_controls_height !=\n          resize_params->top_controls_height ||\n      old_resize_params_->top_controls_shrink_blink_size !=\n          resize_params->top_controls_shrink_blink_size ||\n      old_resize_params_->visible_viewport_size !=\n          resize_params->visible_viewport_size;\n  resize_params->needs_resize_ack =\n      g_check_for_pending_resize_ack && !resize_params->new_size.IsEmpty() &&\n      !resize_params->physical_backing_size.IsEmpty() && size_changed;\n  return dirty;\n}", "target": 0}
{"code": "header_put_byte (SF_PRIVATE *psf, char x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 1)\n\t\tpsf->header [psf->headindex++] = x ;\n} ", "target": 1}
{"code": "const aura::Window* Shell::GetContainer(const aura::Window* root_window,\n                                        int container_id) {\n  return root_window->GetChildById(container_id);\n}", "target": 0}
{"code": "static int skcipher_setkey(struct crypto_skcipher *tfm, const u8 *key,\n\t\t\t   unsigned int keylen)\n{\n\tstruct skcipher_alg *cipher = crypto_skcipher_alg(tfm);\n\tunsigned long alignmask = crypto_skcipher_alignmask(tfm);\n\tif (keylen < cipher->min_keysize || keylen > cipher->max_keysize) {\n\t\tcrypto_skcipher_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);\n\t\treturn -EINVAL;\n\t}\n\tif ((unsigned long)key & alignmask)\n\t\treturn skcipher_setkey_unaligned(tfm, key, keylen);\n\treturn cipher->setkey(tfm, key, keylen);\n}", "target": 0}
{"code": "SendScaleSetting(rfbClient* client,int scaleSetting)\n{\n  rfbSetScaleMsg ssm;\n  ssm.scale = scaleSetting;\n  ssm.pad = 0;\n  if (SupportsClient2Server(client, rfbSetScale)) {\n      ssm.type = rfbSetScale;\n      if (!WriteToRFBServer(client, (char *)&ssm, sz_rfbSetScaleMsg))\n          return FALSE;\n  }\n  if (SupportsClient2Server(client, rfbPalmVNCSetScaleFactor)) {\n      ssm.type = rfbPalmVNCSetScaleFactor;\n      if (!WriteToRFBServer(client, (char *)&ssm, sz_rfbSetScaleMsg))\n          return FALSE;\n  }\n  return TRUE;\n}", "target": 0}
{"code": "eui64_to_display(wmem_allocator_t *allocator, const guint64 addr_eui64)\n{\n    guint8 *addr = (guint8 *)wmem_alloc(NULL, 8);\n    hashmanuf_t *manuf_value;\n    gchar *ret;\n    *(guint64 *)(void *)(addr) = pntoh64(&(addr_eui64));\n    manuf_value = manuf_name_lookup(addr);\n    if (!gbl_resolv_flags.mac_name || (manuf_value->status == HASHETHER_STATUS_UNRESOLVED)) {\n        ret = wmem_strdup_printf(allocator, \"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\", addr[0], addr[1], addr[2], addr[3], addr[4], addr[5], addr[6], addr[7]);\n    } else {\n        ret = wmem_strdup_printf(allocator, \"%s_%02x:%02x:%02x:%02x:%02x\", manuf_value->resolved_name, addr[3], addr[4], addr[5], addr[6], addr[7]);\n    }\n    wmem_free(NULL, addr);\n    return ret;\n} ", "target": 1}
{"code": "static void pipe_advance(struct iov_iter *i, size_t size)\n{\n\tstruct pipe_inode_info *pipe = i->pipe;\n\tstruct pipe_buffer *buf;\n\tint idx = i->idx;\n\tsize_t off = i->iov_offset, orig_sz;\n\tif (unlikely(i->count < size))\n\t\tsize = i->count;\n\torig_sz = size;\n\tif (size) {\n\t\tif (off) \n\t\t\tsize += off - pipe->bufs[idx].offset;\n\t\twhile (1) {\n\t\t\tbuf = &pipe->bufs[idx];\n\t\t\tif (size <= buf->len)\n\t\t\t\tbreak;\n\t\t\tsize -= buf->len;\n\t\t\tidx = next_idx(idx, pipe);\n\t\t}\n\t\tbuf->len = size;\n\t\ti->idx = idx;\n\t\toff = i->iov_offset = buf->offset + size;\n\t}\n\tif (off)\n\t\tidx = next_idx(idx, pipe);\n\tif (pipe->nrbufs) {\n\t\tint unused = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);\n\t\twhile (idx != unused) {\n\t\t\tpipe_buf_release(pipe, &pipe->bufs[idx]);\n\t\t\tidx = next_idx(idx, pipe);\n\t\t\tpipe->nrbufs--;\n\t\t}\n\t}\n\ti->count -= orig_sz;\n}", "target": 1}
{"code": "    ThreadId thread_id() const { return thread_id_; }", "target": 0}
{"code": "int __init acpi_debugger_init(void)\n{\n\tmutex_init(&acpi_debugger.lock);\n\tacpi_debugger_initialized = true;\n\treturn 0;\n}", "target": 0}
{"code": "git_commit_list_node *git_commit_list_alloc_node(git_revwalk *walk)\n{\n\treturn (git_commit_list_node *)git_pool_mallocz(&walk->commit_pool, 1);\n}", "target": 0}
{"code": "static ssize_t rpmsg_eptdev_write_iter(struct kiocb *iocb,\n\t\t\t\t       struct iov_iter *from)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct rpmsg_eptdev *eptdev = filp->private_data;\n\tsize_t len = iov_iter_count(from);\n\tvoid *kbuf;\n\tint ret;\n\tkbuf = kzalloc(len, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\tif (!copy_from_iter_full(kbuf, len, from))\n\t\treturn -EFAULT;\n\tif (mutex_lock_interruptible(&eptdev->ept_lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto free_kbuf;\n\t}\n\tif (!eptdev->ept) {\n\t\tret = -EPIPE;\n\t\tgoto unlock_eptdev;\n\t}\n\tif (filp->f_flags & O_NONBLOCK)\n\t\tret = rpmsg_trysend(eptdev->ept, kbuf, len);\n\telse\n\t\tret = rpmsg_send(eptdev->ept, kbuf, len);\nunlock_eptdev:\n\tmutex_unlock(&eptdev->ept_lock);\nfree_kbuf:\n\tkfree(kbuf);\n\treturn ret < 0 ? ret : len;\n}", "target": 1}
{"code": "int user_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *zap = NULL;\n\tint ret;\n\tret = key_payload_reserve(key, prep->datalen);\n\tif (ret < 0)\n\t\treturn ret;\n\tkey->expiry = prep->expiry;\n\tif (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n\t\tzap = dereference_key_locked(key);\n\trcu_assign_keypointer(key, prep->payload.data[0]);\n\tprep->payload.data[0] = NULL;\n\tif (zap)\n\t\tcall_rcu(&zap->rcu, user_free_payload_rcu);\n\treturn ret;\n}", "target": 1}
{"code": "virDomainGetTime(virDomainPtr dom,\n                 long long *seconds,\n                 unsigned int *nseconds,\n                 unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(dom, \"seconds=%p, nseconds=%p, flags=%x\",\n                     seconds, nseconds, flags);\n    virResetLastError();\n    virCheckDomainReturn(dom, -1);\n    virCheckReadOnlyGoto(dom->conn->flags, error);\n    if (dom->conn->driver->domainGetTime) {\n        int ret = dom->conn->driver->domainGetTime(dom, seconds,\n                                                   nseconds, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n    virReportUnsupportedError();\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}", "target": 0}
{"code": "absl::optional<CelValue> RequestWrapper::operator[](CelValue key) const {\n  if (!key.IsString()) {\n    return {};\n  }\n  auto value = key.StringOrDie().value();\n  if (value == Headers) {\n    return CelValue::CreateMap(&headers_);\n  } else if (value == Time) {\n    return CelValue::CreateTimestamp(absl::FromChrono(info_.startTime()));\n  } else if (value == Size) {\n    if (headers_.value_ != nullptr && headers_.value_->ContentLength() != nullptr) {\n      int64_t length;\n      if (absl::SimpleAtoi(headers_.value_->ContentLength()->value().getStringView(), &length)) {\n        return CelValue::CreateInt64(length);\n      }\n    } else {\n      return CelValue::CreateInt64(info_.bytesReceived());\n    }\n  } else if (value == Duration) {\n    auto duration = info_.requestComplete();\n    if (duration.has_value()) {\n      return CelValue::CreateDuration(absl::FromChrono(duration.value()));\n    }\n  }\n  if (headers_.value_ != nullptr) {\n    if (value == Path) {\n      return convertHeaderEntry(headers_.value_->Path());\n    } else if (value == UrlPath) {\n      absl::string_view path = headers_.value_->Path()->value().getStringView();\n      size_t query_offset = path.find('?');\n      if (query_offset == absl::string_view::npos) {\n        return CelValue::CreateString(path);\n      }\n      return CelValue::CreateString(path.substr(0, query_offset));\n    } else if (value == Host) {\n      return convertHeaderEntry(headers_.value_->Host());\n    } else if (value == Scheme) {\n      return convertHeaderEntry(headers_.value_->Scheme());\n    } else if (value == Method) {\n      return convertHeaderEntry(headers_.value_->Method());\n    } else if (value == Referer) {\n      return convertHeaderEntry(headers_.value_->Referer());\n    } else if (value == ID) {\n      return convertHeaderEntry(headers_.value_->RequestId());\n    } else if (value == UserAgent) {\n      return convertHeaderEntry(headers_.value_->UserAgent());\n    } else if (value == TotalSize) {\n      return CelValue::CreateInt64(info_.bytesReceived() + headers_.value_->byteSize());\n    }\n  }\n  return {};\n}", "target": 1}
{"code": "static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct encrypted_key_payload *epayload = key->payload.data[0];\n\tstruct encrypted_key_payload *new_epayload;\n\tchar *buf;\n\tchar *new_master_desc = NULL;\n\tconst char *format = NULL;\n\tsize_t datalen = prep->datalen;\n\tint ret = 0;\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n\t\treturn -ENOKEY;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\tbuf = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tbuf[datalen] = 0;\n\tmemcpy(buf, prep->data, datalen);\n\tret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = valid_master_desc(new_master_desc, epayload->master_desc);\n\tif (ret < 0)\n\t\tgoto out;\n\tnew_epayload = encrypted_key_alloc(key, epayload->format,\n\t\t\t\t\t   new_master_desc, epayload->datalen);\n\tif (IS_ERR(new_epayload)) {\n\t\tret = PTR_ERR(new_epayload);\n\t\tgoto out;\n\t}\n\t__ekey_init(new_epayload, epayload->format, new_master_desc,\n\t\t    epayload->datalen);\n\tmemcpy(new_epayload->iv, epayload->iv, ivsize);\n\tmemcpy(new_epayload->payload_data, epayload->payload_data,\n\t       epayload->payload_datalen);\n\trcu_assign_keypointer(key, new_epayload);\n\tcall_rcu(&epayload->rcu, encrypted_rcu_free);\nout:\n\tkzfree(buf);\n\treturn ret;\n}", "target": 1}
{"code": "ext2_xattr_delete_inode(struct inode *inode)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct mb_cache_entry *ce;\n\tdown_write(&EXT2_I(inode)->xattr_sem);\n\tif (!EXT2_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tbh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);\n\tif (!bh) {\n\t\text2_error(inode->i_sb, \"ext2_xattr_delete_inode\",\n\t\t\t\"inode %ld: block %d read error\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\tea_bdebug(bh, \"b_count=%d\", atomic_read(&(bh->b_count)));\n\tif (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||\n\t    HDR(bh)->h_blocks != cpu_to_le32(1)) {\n\t\text2_error(inode->i_sb, \"ext2_xattr_delete_inode\",\n\t\t\t\"inode %ld: bad block %d\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\tce = mb_cache_entry_get(ext2_xattr_cache, bh->b_bdev, bh->b_blocknr);\n\tlock_buffer(bh);\n\tif (HDR(bh)->h_refcount == cpu_to_le32(1)) {\n\t\tif (ce)\n\t\t\tmb_cache_entry_free(ce);\n\t\text2_free_blocks(inode, EXT2_I(inode)->i_file_acl, 1);\n\t\tget_bh(bh);\n\t\tbforget(bh);\n\t\tunlock_buffer(bh);\n\t} else {\n\t\tle32_add_cpu(&HDR(bh)->h_refcount, -1);\n\t\tif (ce)\n\t\t\tmb_cache_entry_release(ce);\n\t\tea_bdebug(bh, \"refcount now=%d\",\n\t\t\tle32_to_cpu(HDR(bh)->h_refcount));\n\t\tunlock_buffer(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tif (IS_SYNC(inode))\n\t\t\tsync_dirty_buffer(bh);\n\t\tdquot_free_block_nodirty(inode, 1);\n\t}\n\tEXT2_I(inode)->i_file_acl = 0;\ncleanup:\n\tbrelse(bh);\n\tup_write(&EXT2_I(inode)->xattr_sem);\n}", "target": 1}
{"code": "int main(void)\n{\n\tSuite *suite;\n\tSRunner *runner;\n\tint tests_failed;\n\tlog_setup(true);\n\tsuite = xml_load_suite();\n\trunner = srunner_create(suite);\n\tsrunner_run_all(runner, CK_NORMAL);\n\ttests_failed = srunner_ntests_failed(runner);\n\tsrunner_free(runner);\n\treturn (tests_failed == 0) ? EXIT_SUCCESS : EXIT_FAILURE;\n}", "target": 0}
{"code": "static NTLM_AV_PAIR* ntlm_av_pair_next(NTLM_AV_PAIR* pAvPair, size_t* pcbAvPair)\n{\n\tsize_t offset;\n\tif (!pcbAvPair)\n\t\treturn NULL;\n\tif (!ntlm_av_pair_check(pAvPair, *pcbAvPair))\n\t\treturn NULL;\n\toffset = ntlm_av_pair_get_next_offset(pAvPair);\n\t*pcbAvPair -= offset;\n\treturn (NTLM_AV_PAIR*)((PBYTE)pAvPair + offset);\n}", "target": 1}
{"code": "TEST(InMatchExpression, MatchesNull) {\n    BSONObj operand = BSON_ARRAY(BSONNULL);\n    InMatchExpression in(\"a\");\n    std::vector<BSONElement> equalities{operand.firstElement()};\n    ASSERT_OK(in.setEqualities(std::move(equalities)));\n    ASSERT(in.matchesBSON(BSONObj(), NULL));\n    ASSERT(in.matchesBSON(BSON(\"a\" << BSONNULL), NULL));\n    ASSERT(!in.matchesBSON(BSON(\"a\" << 4), NULL));\n    ASSERT(in.matchesBSON(BSON(\"b\" << 4), NULL));\n}", "target": 0}
{"code": "static inline int route4_hash_to(u32 id)\n{\n\treturn id & 0xFF;\n}", "target": 0}
{"code": "static void control_work_handler(struct work_struct *work)\n{\n\tstruct ports_device *portdev;\n\tstruct virtqueue *vq;\n\tstruct port_buffer *buf;\n\tunsigned int len;\n\tportdev = container_of(work, struct ports_device, control_work);\n\tvq = portdev->c_ivq;\n\tspin_lock(&portdev->c_ivq_lock);\n\twhile ((buf = virtqueue_get_buf(vq, &len))) {\n\t\tspin_unlock(&portdev->c_ivq_lock);\n\t\tbuf->len = len;\n\t\tbuf->offset = 0;\n\t\thandle_control_message(vq->vdev, portdev, buf);\n\t\tspin_lock(&portdev->c_ivq_lock);\n\t\tif (add_inbuf(portdev->c_ivq, buf) < 0) {\n\t\t\tdev_warn(&portdev->vdev->dev,\n\t\t\t\t \"Error adding buffer to queue\\n\");\n\t\t\tfree_buf(buf, false);\n\t\t}\n\t}\n\tspin_unlock(&portdev->c_ivq_lock);\n}", "target": 1}
{"code": "void js_RegExp_prototype_exec(js_State *J, js_Regexp *re, const char *text)\n{\n\tint i;\n\tint opts;\n\tResub m;\n\topts = 0;\n\tif (re->flags & JS_REGEXP_G) {\n\t\tif (re->last > strlen(text)) {\n\t\t\tre->last = 0;\n\t\t\tjs_pushnull(J);\n\t\t\treturn;\n\t\t}\n\t\tif (re->last > 0) {\n\t\t\ttext += re->last;\n\t\t\topts |= REG_NOTBOL;\n\t\t}\n\t}\n\tif (!js_regexec(re->prog, text, &m, opts)) {\n\t\tjs_newarray(J);\n\t\tjs_pushstring(J, text);\n\t\tjs_setproperty(J, -2, \"input\");\n\t\tjs_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));\n\t\tjs_setproperty(J, -2, \"index\");\n\t\tfor (i = 0; i < m.nsub; ++i) {\n\t\t\tjs_pushlstring(J, m.sub[i].sp, m.sub[i].ep - m.sub[i].sp);\n\t\t\tjs_setindex(J, -2, i);\n\t\t}\n\t\tif (re->flags & JS_REGEXP_G)\n\t\t\tre->last = re->last + (m.sub[0].ep - text);\n\t\treturn;\n\t}\n\tif (re->flags & JS_REGEXP_G)\n\t\tre->last = 0;\n\tjs_pushnull(J);\n}", "target": 1}
{"code": "int verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr_storage *address, int mode)\n{\n\tint size, ct, err;\n\tif (m->msg_namelen) {\n\t\tif (mode == VERIFY_READ) {\n\t\t\tvoid __user *namep;\n\t\t\tnamep = (void __user __force *) m->msg_name;\n\t\t\terr = move_addr_to_kernel(namep, m->msg_namelen,\n\t\t\t\t\t\t  address);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tm->msg_name = address;\n\t} else {\n\t\tm->msg_name = NULL;\n\t}\n\tsize = m->msg_iovlen * sizeof(struct iovec);\n\tif (copy_from_user(iov, (void __user __force *) m->msg_iov, size))\n\t\treturn -EFAULT;\n\tm->msg_iov = iov;\n\terr = 0;\n\tfor (ct = 0; ct < m->msg_iovlen; ct++) {\n\t\tsize_t len = iov[ct].iov_len;\n\t\tif (len > INT_MAX - err) {\n\t\t\tlen = INT_MAX - err;\n\t\t\tiov[ct].iov_len = len;\n\t\t}\n\t\terr += len;\n\t}\n\treturn err;\n}", "target": 1}
{"code": "static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n\t\t\t\t\t  const char *rootfs)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\tret = snprintf(path, sizeof(path), \"%s/%s\", rootfs, mntent->mnt_dir);\n\tif (ret >= sizeof(path)) {\n\t\tERROR(\"path name too long\");\n\t\treturn -1;\n\t}\n\treturn mount_entry_on_generic(mntent, path);\n}", "target": 1}
{"code": "    size_t Exifdatum::size() const\n    {\n        return value_.get() == 0 ? 0 : value_->size();\n    }", "target": 0}
{"code": "parse_delta(struct rpki_uri *uri, struct delta_head *parents_data,\n    struct proc_upd_args *args)\n{\n\tstruct rdr_delta_ctx ctx;\n\tstruct delta *delta;\n\tstruct doc_data *expected_data;\n\tint error;\n\texpected_data = &parents_data->doc_data;\n\tfnstack_push_uri(uri);\n\terror = hash_validate_file(\"sha256\", uri, expected_data->hash,\n\t    expected_data->hash_len);\n\tif (error)\n\t\tgoto pop_fnstack;\n\terror = delta_create(&delta);\n\tif (error)\n\t\tgoto pop_fnstack;\n\tctx.delta = delta;\n\tctx.parent = args->parent;\n\tctx.visited_uris = args->visited_uris;\n\tctx.expected_serial = parents_data->serial;\n\terror = relax_ng_parse(uri_get_local(uri), xml_read_delta, &ctx);\n\tdelta_destroy(delta);\npop_fnstack:\n\tfnstack_pop();\n\treturn error;\n}", "target": 1}
{"code": "void test_chmod(const char *path)\n{\n\tif (chmod(path, 0755) == 0) {\n\t\tfprintf(stderr, \"leak at chmod of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at chmod of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "BaseAudioContext::~BaseAudioContext() {\n  {\n    GraphAutoLocker locker(this);\n    destination_handler_ = nullptr;\n  }\n  GetDeferredTaskHandler().ContextWillBeDestroyed();\n}", "target": 0}
{"code": "void * pvPortMalloc( size_t xWantedSize )\n{\n    void * pvReturn = NULL;\n    static uint8_t * pucAlignedHeap = NULL;\n    #if ( portBYTE_ALIGNMENT != 1 )\n        {\n            if( xWantedSize & portBYTE_ALIGNMENT_MASK )\n            {\n                xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\n            }\n        }\n    #endif\n    vTaskSuspendAll();\n    {\n        if( pucAlignedHeap == NULL )\n        {\n            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );\n        }\n        if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&\n            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) \n        {\n            pvReturn = pucAlignedHeap + xNextFreeByte;\n            xNextFreeByte += xWantedSize;\n        }\n        traceMALLOC( pvReturn, xWantedSize );\n    }\n    ( void ) xTaskResumeAll();\n    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )\n        {\n            if( pvReturn == NULL )\n            {\n                extern void vApplicationMallocFailedHook( void );\n                vApplicationMallocFailedHook();\n            }\n        }\n    #endif\n    return pvReturn;\n}", "target": 1}
{"code": "psf_asciiheader_printf (SF_PRIVATE *psf, const char *format, ...)\n{\tva_list\targptr ;\n\tint\t\tmaxlen ;\n\tchar\t*start ;\n\tmaxlen = strlen ((char*) psf->header) ;\n\tstart\t= ((char*) psf->header) + maxlen ;\n\tmaxlen\t= sizeof (psf->header) - maxlen ;\n\tva_start (argptr, format) ;\n\tvsnprintf (start, maxlen, format, argptr) ;\n\tva_end (argptr) ;\n\tstart [maxlen - 1] = 0 ;\n\tpsf->headindex = strlen ((char*) psf->header) ;\n\treturn ;\n} ", "target": 1}
{"code": "static inline bool CheckForOverflow(double as_double, T* out) {\n  return (sizeof(T) < sizeof(double) && std::isinf(*out) &&\n          std::isfinite(as_double));\n}", "target": 0}
{"code": "void jpc_qmfb_join_colgrp(jpc_fix_t *a, int numrows, int stride,\n  int parity)\n{\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t joinbuf[QMFB_JOINBUFSIZE * JPC_QMFB_COLGRPSIZE];\n\tjpc_fix_t *buf = joinbuf;\n\tjpc_fix_t *srcptr;\n\tjpc_fix_t *dstptr;\n\tregister jpc_fix_t *srcptr2;\n\tregister jpc_fix_t *dstptr2;\n\tregister int n;\n\tregister int i;\n\tint hstartcol;\n\tif (bufsize > QMFB_JOINBUFSIZE) {\n\t\tif (!(buf = jas_alloc3(bufsize, JPC_QMFB_COLGRPSIZE, sizeof(jpc_fix_t)))) {\n\t\t\tabort();\n\t\t}\n\t}\n\thstartcol = (numrows + 1 - parity) >> 1;\n\tn = hstartcol;\n\tsrcptr = &a[0];\n\tdstptr = buf;\n\twhile (n-- > 0) {\n\t\tdstptr2 = dstptr;\n\t\tsrcptr2 = srcptr;\n\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t*dstptr2 = *srcptr2;\n\t\t\t++dstptr2;\n\t\t\t++srcptr2;\n\t\t}\n\t\tsrcptr += stride;\n\t\tdstptr += JPC_QMFB_COLGRPSIZE;\n\t}\n\tsrcptr = &a[hstartcol * stride];\n\tdstptr = &a[(1 - parity) * stride];\n\tn = numrows - hstartcol;\n\twhile (n-- > 0) {\n\t\tdstptr2 = dstptr;\n\t\tsrcptr2 = srcptr;\n\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t*dstptr2 = *srcptr2;\n\t\t\t++dstptr2;\n\t\t\t++srcptr2;\n\t\t}\n\t\tdstptr += 2 * stride;\n\t\tsrcptr += stride;\n\t}\n\tsrcptr = buf;\n\tdstptr = &a[parity * stride];\n\tn = hstartcol;\n\twhile (n-- > 0) {\n\t\tdstptr2 = dstptr;\n\t\tsrcptr2 = srcptr;\n\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t*dstptr2 = *srcptr2;\n\t\t\t++dstptr2;\n\t\t\t++srcptr2;\n\t\t}\n\t\tdstptr += 2 * stride;\n\t\tsrcptr += JPC_QMFB_COLGRPSIZE;\n\t}\n\tif (buf != joinbuf) {\n\t\tjas_free(buf);\n\t}\n}", "target": 1}
{"code": "MONGO_EXPORT int bson_append_string_n( bson *b, const char *name, const char *value, int len ) {\n    return bson_append_string_base( b, name, value, len, BSON_STRING );\n}", "target": 1}
{"code": "comics_remove_dir (gchar *path_name)\n{\n\tGDir  *content_dir;\n\tconst gchar *filename;\n\tgchar *filename_with_path;\n\tif (g_file_test (path_name, G_FILE_TEST_IS_DIR)) {\n\t\tcontent_dir = g_dir_open  (path_name, 0, NULL);\n\t\tfilename  = g_dir_read_name (content_dir);\n\t\twhile (filename) {\n\t\t\tfilename_with_path =\n\t\t\t\tg_build_filename (path_name,\n\t\t\t\t\t\t  filename, NULL);\n\t\t\tcomics_remove_dir (filename_with_path);\n\t\t\tg_free (filename_with_path);\n\t\t\tfilename = g_dir_read_name (content_dir);\n\t\t}\n\t\tg_dir_close (content_dir);\n\t}\n\treturn (g_remove (path_name));\n}", "target": 1}
{"code": "snmp_oid_encode_oid(unsigned char *out, uint32_t *out_len, uint32_t *oid)\n{\n  uint32_t original_out_len;\n  uint32_t *oid_start = oid;\n  uint32_t num;\n  original_out_len = *out_len;\n  while(*oid != ((uint32_t)-1)) {\n    ++oid;\n  }\n  --oid;\n  while(oid != oid_start) {\n    num = *oid;\n    (*out_len)++;\n    *out-- = (uint8_t)(num & 0x7F);\n    num >>= 7;\n    while(num) {\n      (*out_len)++;\n      *out-- = (uint8_t)((num & 0x7F) | 0x80);\n      num >>= 7;\n    }\n    --oid;\n  }\n  num = *(out + 1) + 40 * *oid;\n  (*out_len)--;\n  out++;\n  (*out_len)++;\n  *out-- = (uint8_t)(num & 0x7F);\n  num >>= 7;\n  while(num) {\n    (*out_len)++;\n    *out-- = (uint8_t)((num & 0x7F) | 0x80);\n    num >>= 7;\n  }\n  out = snmp_ber_encode_length(out, out_len, ((*out_len - original_out_len) & 0xFF));\n  out = snmp_ber_encode_type(out, out_len, SNMP_DATA_TYPE_OBJECT);\n  return out;\n}", "target": 1}
{"code": "messageAddArgument(message *m, const char *arg)\n{\n\tint offset;\n\tchar *p;\n\tassert(m != NULL);\n\tif(arg == NULL)\n\t\treturn;\t\n\twhile(isspace(*arg))\n\t\targ++;\n\tif(*arg == '\\0')\n\t\treturn;\n\tcli_dbgmsg(\"messageAddArgument, arg='%s'\\n\", arg);\n\tif(!usefulArg(arg))\n\t\treturn;\n\tfor(offset = 0; offset < m->numberOfArguments; offset++)\n\t\tif(m->mimeArguments[offset] == NULL)\n\t\t\tbreak;\n\t\telse if(strcasecmp(arg, m->mimeArguments[offset]) == 0)\n\t\t\treturn;\t\n\tif(offset == m->numberOfArguments) {\n\t\tchar **q;\n\t\tm->numberOfArguments++;\n\t\tq = (char **)cli_realloc(m->mimeArguments, m->numberOfArguments * sizeof(char *));\n\t\tif(q == NULL) {\n\t\t\tm->numberOfArguments--;\n\t\t\treturn;\n\t\t}\n\t\tm->mimeArguments = q;\n\t}\n\tp = m->mimeArguments[offset] = rfc2231(arg);\n\tif(!p) {\n\t\tcli_dbgmsg(\"messageAddArgument, error from rfc2231()\\n\");\n\t\treturn;\n\t}\n\tif(strchr(p, '=') == NULL) {\n\t\tif(strncmp(p, \"filename\", 8) == 0) {\n\t\t\tcli_dbgmsg(\"Possible data corruption fixed\\n\");\n\t\t\tp[8] = '=';\n\t\t} else {\n\t\t\tif(*p)\n\t\t\t\tcli_dbgmsg(\"messageAddArgument, '%s' contains no '='\\n\", p);\n\t\t\tfree(m->mimeArguments[offset]);\n\t\t\tm->mimeArguments[offset] = NULL;\n\t\t\treturn;\n\t\t}\n\t}\n\tif((strncasecmp(p, \"filename=\", 9) == 0) || (strncasecmp(p, \"name=\", 5) == 0))\n\t\tif(messageGetMimeType(m) == NOMIME) {\n\t\t\tcli_dbgmsg(\"Force mime encoding to application\\n\");\n\t\t\tmessageSetMimeType(m, \"application\");\n\t\t}\n}", "target": 1}
{"code": "int main(int argc, char *argv[])\n{\n   libettercap_init();\n   ef_globals_alloc();\n   select_text_interface();\n   libettercap_ui_init();\n   fprintf(stdout, \"\\n\" EC_COLOR_BOLD \"%s %s\" EC_COLOR_END \" copyright %s %s\\n\\n\", \n                      PROGRAM, EC_VERSION, EC_COPYRIGHT, EC_AUTHORS);\n   EF_GBL->lineno = 1;\n   parse_options(argc, argv);\n   if (EF_GBL_OPTIONS->source_file) {\n      yyin = fopen(EF_GBL_OPTIONS->source_file, \"r\");\n      if (yyin == NULL)\n         FATAL_ERROR(\"Input file not found !\");\n   } else {\n      FATAL_ERROR(\"No source file.\");\n   }\n   setbuf(yyin, NULL);\n   setbuf(stdout, NULL);\n   setbuf(stderr, NULL);\n   load_tables();\n   load_constants();\n   fprintf(stdout, \"\\n Parsing source file \\'%s\\' \", EF_GBL_OPTIONS->source_file);\n   fflush(stdout);\n   ef_debug(1, \"\\n\");\n   if (yyparse() == 0)\n      fprintf(stdout, \" done.\\n\\n\");\n   else\n      fprintf(stdout, \"\\n\\nThe script contains errors...\\n\\n\");\n   if (write_output() != E_SUCCESS)\n      FATAL_ERROR(\"Cannot write output file (%s)\", EF_GBL_OPTIONS->output_file);\n   ef_globals_free();\n   return 0;\n}", "target": 1}
{"code": "bool ImageLoader::HasPendingEvent() const {\n  if (image_content_ && !image_complete_ && !loading_image_document_)\n    return true;\n  if (pending_load_event_.IsActive() || pending_error_event_.IsActive())\n    return true;\n  return false;\n}", "target": 0}
{"code": "is_word_char(unsigned char *ch)\n{\n    Lineprop ctype = get_mctype(ch);\n#ifdef USE_M17N\n    if (ctype & (PC_CTRL | PC_KANJI | PC_UNKNOWN))\n\treturn 0;\n    if (ctype & (PC_WCHAR1 | PC_WCHAR2))\n\treturn 1;\n#else\n    if (ctype == PC_CTRL)\n\treturn 0;\n#endif\n    if (IS_ALNUM(*ch))\n\treturn 1;\n    switch (*ch) {\n    case ',':\n    case '.':\n    case ':':\n    case '\\\"':\t\t\t\n    case '\\'':\n    case '$':\n    case '%':\n    case '*':\n    case '+':\n    case '-':\n    case '@':\n    case '~':\n    case '_':\n\treturn 1;\n    }\n#ifdef USE_M17N\n    if (*ch == NBSP_CODE)\n\treturn 1;\n#else\n    if (*ch == TIMES_CODE || *ch == DIVIDE_CODE || *ch == ANSP_CODE)\n\treturn 0;\n    if (*ch >= AGRAVE_CODE || *ch == NBSP_CODE)\n\treturn 1;\n#endif\n    return 0;\n}", "target": 0}
{"code": "static bool pp_suppress_error(errflags severity)\n{\n    if (istk && istk->conds &&\n\t((severity & ERR_PP_PRECOND) ?\n\t istk->conds->state == COND_NEVER :\n\t !emitting(istk->conds->state)))\n        return true;\n    return false;\n}", "target": 0}
{"code": "static int update_header(void *obj)\n{\n\tstruct header_data *data = obj;\n\tpjsip_hdr *hdr = NULL;\n\tRAII_VAR(struct ast_datastore *, datastore,\n\t\t\t ast_sip_session_get_datastore(data->channel->session, data->header_datastore->type),\n\t\t\t ao2_cleanup);\n\tif (!datastore || !datastore->data) {\n\t\tast_log(AST_LOG_ERROR, \"No headers had been previously added to this session.\\n\");\n\t\treturn -1;\n\t}\n\thdr = find_header((struct hdr_list *) datastore->data, data->header_name,\n\t\t\t\t\t  data->header_number);\n\tif (!hdr) {\n\t\tast_log(AST_LOG_ERROR, \"There was no header named %s.\\n\", data->header_name);\n\t\treturn -1;\n\t}\n\tpj_strcpy2(&((pjsip_generic_string_hdr *) hdr)->hvalue, data->header_value);\n\treturn 0;\n}", "target": 1}
{"code": "MagickExport MagickBooleanType HeapOverflowSanityCheck(const size_t count,\n  const size_t quantum)\n{\n  size_t\n    size;\n  size=count*quantum;\n  if ((count == 0) || (quantum != (size/count)))\n    {\n      errno=ENOMEM;\n      return(MagickTrue);\n    }\n  return(MagickFalse);\n}", "target": 0}
{"code": "void QuickOpen::Load(uint64 BlockPos)\n{\n  if (!Loaded) \n  {\n    SeekPos=Arc->Tell();\n    UnsyncSeekPos=false;\n    SaveFilePos SavePos(*Arc);\n    Arc->Seek(BlockPos,SEEK_SET);\n    if (Arc->ReadHeader()==0 || Arc->GetHeaderType()!=HEAD_SERVICE ||\n        !Arc->SubHead.CmpName(SUBHEAD_TYPE_QOPEN))\n      return;\n    QLHeaderPos=Arc->CurBlockPos;\n    RawDataStart=Arc->Tell();\n    RawDataSize=Arc->SubHead.UnpSize;\n    Loaded=true; \n  }\n  if (Arc->SubHead.Encrypted)\n  {\n    RAROptions *Cmd=Arc->GetRAROptions();\n#ifndef RAR_NOCRYPT\n    if (Cmd->Password.IsSet())\n      Crypt.SetCryptKeys(false,CRYPT_RAR50,&Cmd->Password,Arc->SubHead.Salt,\n                         Arc->SubHead.InitV,Arc->SubHead.Lg2Count,\n                         Arc->SubHead.HashKey,Arc->SubHead.PswCheck);\n    else\n#endif\n      return;\n  }\n  RawDataPos=0;\n  ReadBufSize=0;\n  ReadBufPos=0;\n  LastReadHeader.Reset();\n  LastReadHeaderPos=0;\n  ReadBuffer();\n}", "target": 1}
{"code": "SanMatcherPtr createStringSanMatcher(\n    envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher const& matcher) {\n  static_assert(envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::SanType_MAX ==\n                4);\n  switch (matcher.san_type()) {\n  case envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::DNS:\n    return SanMatcherPtr{std::make_unique<StringSanMatcher>(GEN_DNS, matcher.matcher())};\n  case envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::EMAIL:\n    return SanMatcherPtr{std::make_unique<StringSanMatcher>(GEN_EMAIL, matcher.matcher())};\n  case envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::URI:\n    return SanMatcherPtr{std::make_unique<StringSanMatcher>(GEN_URI, matcher.matcher())};\n  case envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::IP_ADDRESS:\n    return SanMatcherPtr{std::make_unique<StringSanMatcher>(GEN_IPADD, matcher.matcher())};\n  default:\n    NOT_REACHED_GCOVR_EXCL_LINE;\n  }\n}", "target": 0}
{"code": "[[noreturn]] void TProtocolException::throwInvalidSkipType(TType type) {\n  throw TProtocolException(\n      TProtocolException::INVALID_DATA,\n      folly::sformat(\n          \"Encountered invalid field/element type ({}) during skipping\",\n          static_cast<uint8_t>(type)));\n}", "target": 0}
{"code": "char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n{\n  size_t alloc = (inlength?(size_t)inlength:strlen(string))+1;\n  char *ns;\n  char *testing_ptr = NULL;\n  unsigned char in; \n  size_t newlen = alloc;\n  int strindex=0;\n  size_t length;\n  CURLcode res;\n  ns = malloc(alloc);\n  if(!ns)\n    return NULL;\n  length = alloc-1;\n  while(length--) {\n    in = *string;\n    if(Curl_isunreserved(in))\n      ns[strindex++]=in;\n    else {\n      newlen += 2; \n      if(newlen > alloc) {\n        alloc *= 2;\n        testing_ptr = realloc(ns, alloc);\n        if(!testing_ptr) {\n          free( ns );\n          return NULL;\n        }\n        else {\n          ns = testing_ptr;\n        }\n      }\n      res = Curl_convert_to_network(handle, &in, 1);\n      if(res) {\n        free(ns);\n        return NULL;\n      }\n      snprintf(&ns[strindex], 4, \"%%%02X\", in);\n      strindex+=3;\n    }\n    string++;\n  }\n  ns[strindex]=0; \n  return ns;\n}", "target": 1}
{"code": "lt_dlgetinfo (lt_dlhandle handle)\n{\n  if (!handle)\n    {\n      LT__SETERROR (INVALID_HANDLE);\n      return 0;\n    }\n  return &(handle->info);\n}", "target": 0}
{"code": "int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,\n                   const char *dir) {\n  char offset[40] = \"\", name[200] = \"\", path[256];\n  mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));\n  mg_http_get_var(&hm->query, \"name\", name, sizeof(name));\n  if (name[0] == '\\0') {\n    mg_http_reply(c, 400, \"\", \"%s\", \"name required\");\n    return -1;\n  } else {\n    FILE *fp;\n    size_t oft = strtoul(offset, NULL, 0);\n    snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);\n    LOG(LL_DEBUG,\n        (\"%p %d bytes @ %d [%s]\", c->fd, (int) hm->body.len, (int) oft, name));\n    if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {\n      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", name, errno);\n      return -2;\n    } else {\n      fwrite(hm->body.ptr, 1, hm->body.len, fp);\n      fclose(fp);\n      mg_http_reply(c, 200, \"\", \"\");\n      return (int) hm->body.len;\n    }\n  }\n}", "target": 1}
{"code": "static int bson_append_string_base( bson *b, const char *name,\n                                    const char *value, int len, bson_type type ) {\n    int sl = len + 1;\n    if ( bson_check_string( b, ( const char * )value, sl - 1 ) == BSON_ERROR )\n        return BSON_ERROR;\n    if ( bson_append_estart( b, type, name, 4 + sl ) == BSON_ERROR ) {\n        return BSON_ERROR;\n    }\n    bson_append32( b , &sl );\n    bson_append( b , value , sl - 1 );\n    bson_append( b , \"\\0\" , 1 );\n    return BSON_OK;\n}", "target": 1}
{"code": "TEST_F(QuotedString_ExtractFrom_Tests, UnterminatedEscapeSequence) {\n  whenInputIs(\"\\\"\\\\\\0\\\"\", 4);\n  resultMustBe(0);\n}", "target": 0}
{"code": "static Jsi_RC ObjListifyCallback(Jsi_Tree *tree, Jsi_TreeEntry *hPtr, void *data)\n{\n    Jsi_Interp *interp = tree->opts.interp;\n    Jsi_Obj *obj = (Jsi_Obj*)data;\n    int n;\n    if (!hPtr->f.bits.dontenum) {\n        char *ep = NULL, *cp = (char*)Jsi_TreeKeyGet(hPtr);\n        if (!cp || !isdigit(*cp))\n            return JSI_OK;\n        n = (int)strtol(cp, &ep, 0);\n        if (n<0 || n >= interp->maxArrayList)\n            return JSI_OK;\n        hPtr->f.bits.isarrlist = 1;\n        if (Jsi_ObjArraySizer(interp, obj, n) <= 0) \n            return Jsi_LogError(\"too long\");\n        obj->arr[n] = (Jsi_Value*)Jsi_TreeValueGet(hPtr);\n    }\n    return JSI_OK;\n}", "target": 1}
{"code": "R_API RBinJavaVerificationObj *r_bin_java_read_from_buffer_verification_info_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tif (sz < 8) {\n\t\treturn NULL;\n\t}\n\tut64 offset = 0;\n\tRBinJavaVerificationObj *se = R_NEW0 (RBinJavaVerificationObj);\n\tif (!se) {\n\t\treturn NULL;\n\t}\n\tse->file_offset = buf_offset;\n\tse->tag = buffer[offset];\n\toffset += 1;\n\tif (se->tag == R_BIN_JAVA_STACKMAP_OBJECT) {\n\t\tse->info.obj_val_cp_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t} else if (se->tag == R_BIN_JAVA_STACKMAP_UNINIT) {\n\t\tse->info.uninit_offset = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t}\n\tif (R_BIN_JAVA_STACKMAP_UNINIT < se->tag) {\n\t\tr_bin_java_verification_info_free (se);\n\t\treturn NULL;\n\t}\n\tse->size = offset;\n\treturn se;\n}", "target": 0}
{"code": "void ModifiablePixelBuffer::fillRect(const Rect& r, const void* pix)\n{\n  int stride;\n  U8 *buf;\n  int w, h, b;\n  w = r.width();\n  h = r.height();\n  b = format.bpp/8;\n  if (h == 0)\n    return;\n  buf = getBufferRW(r, &stride);\n  if (b == 1) {\n    while (h--) {\n      memset(buf, *(const U8*)pix, w);\n      buf += stride * b;\n    }\n  } else {\n    U8 *start;\n    int w1;\n    start = buf;\n    w1 = w;\n    while (w1--) {\n      memcpy(buf, pix, b);\n      buf += b;\n    }\n    buf += (stride - w) * b;\n    h--;\n    while (h--) {\n      memcpy(buf, start, w * b);\n      buf += stride * b;\n    }\n  }\n  commitBufferRW(r);\n}", "target": 1}
{"code": "static int check_passwd(unsigned char *passwd, size_t length)\n{\n\tstruct digest *d = NULL;\n\tunsigned char *passwd1_sum;\n\tunsigned char *passwd2_sum;\n\tint ret = 0;\n\tint hash_len;\n\tif (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {\n\t\thash_len = PBKDF2_LENGTH;\n\t} else {\n\t\td = digest_alloc(PASSWD_SUM);\n\t\tif (!d) {\n\t\t\tpr_err(\"No such digest: %s\\n\",\n\t\t\t       PASSWD_SUM ? PASSWD_SUM : \"NULL\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t\thash_len = digest_length(d);\n\t}\n\tpasswd1_sum = calloc(hash_len * 2, sizeof(unsigned char));\n\tif (!passwd1_sum)\n\t\treturn -ENOMEM;\n\tpasswd2_sum = passwd1_sum + hash_len;\n\tif (is_passwd_env_enable())\n\t\tret = read_env_passwd(passwd2_sum, hash_len);\n\telse if (is_passwd_default_enable())\n\t\tret = read_default_passwd(passwd2_sum, hash_len);\n\telse\n\t\tret = -EINVAL;\n\tif (ret < 0)\n\t\tgoto err;\n\tif (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {\n\t\tchar *key = passwd2_sum + PBKDF2_SALT_LEN;\n\t\tchar *salt = passwd2_sum;\n\t\tint keylen = PBKDF2_LENGTH - PBKDF2_SALT_LEN;\n\t\tret = pkcs5_pbkdf2_hmac_sha1(passwd, length, salt,\n\t\t\tPBKDF2_SALT_LEN, PBKDF2_COUNT, keylen, passwd1_sum);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tif (strncmp(passwd1_sum, key, keylen) == 0)\n\t\t\tret = 1;\n\t} else {\n\t\tret = digest_digest(d, passwd, length, passwd1_sum);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tif (strncmp(passwd1_sum, passwd2_sum, hash_len) == 0)\n\t\t\tret = 1;\n\t}\nerr:\n\tfree(passwd1_sum);\n\tdigest_free(d);\n\treturn ret;\n}", "target": 1}
{"code": "  bool add_challenge(CephContext *cct, bufferlist& ch) override { return true; }", "target": 0}
{"code": "GlyphCache::GlyphCache(const Face & face, const uint32 face_options)\n: _glyph_loader(new Loader(face, bool(face_options & gr_face_dumbRendering))),\n  _glyphs(_glyph_loader && *_glyph_loader && _glyph_loader->num_glyphs()\n        ? grzeroalloc<const GlyphFace *>(_glyph_loader->num_glyphs()) : 0),\n  _boxes(_glyph_loader && _glyph_loader->has_boxes() && _glyph_loader->num_glyphs()\n        ? grzeroalloc<GlyphBox *>(_glyph_loader->num_glyphs()) : 0),\n  _num_glyphs(_glyphs ? _glyph_loader->num_glyphs() : 0),\n  _num_attrs(_glyphs ? _glyph_loader->num_attrs() : 0),\n  _upem(_glyphs ? _glyph_loader->units_per_em() : 0)\n{\n    if ((face_options & gr_face_preloadGlyphs) && _glyph_loader && _glyphs)\n    {\n        int numsubs = 0;\n        GlyphFace * const glyphs = new GlyphFace [_num_glyphs];\n        if (!glyphs)\n            return;\n        _glyphs[0] = _glyph_loader->read_glyph(0, glyphs[0], &numsubs);\n        const GlyphFace * loaded = _glyphs[0];\n        for (uint16 gid = 1; loaded && gid != _num_glyphs; ++gid)\n            _glyphs[gid] = loaded = _glyph_loader->read_glyph(gid, glyphs[gid], &numsubs);\n        if (!loaded)\n        {\n            _glyphs[0] = 0;\n            delete [] glyphs;\n        }\n        else if (numsubs > 0 && _boxes)\n        {\n            GlyphBox * boxes = (GlyphBox *)gralloc<char>(_num_glyphs * sizeof(GlyphBox) + numsubs * 8 * sizeof(float));\n            GlyphBox * currbox = boxes;\n            for (uint16 gid = 0; currbox && gid != _num_glyphs; ++gid)\n            {\n                _boxes[gid] = currbox;\n                currbox = _glyph_loader->read_box(gid, currbox, *_glyphs[gid]);\n            }\n            if (!currbox)\n            {\n                free(boxes);\n                _boxes[0] = 0;\n            }\n        }\n        delete _glyph_loader;\n        _glyph_loader = 0;\n    }\n    if (_glyphs && glyph(0) == 0)\n    {\n        free(_glyphs);\n        _glyphs = 0;\n        if (_boxes)\n        {\n            free(_boxes);\n            _boxes = 0;\n        }\n        _num_glyphs = _num_attrs = _upem = 0;\n    }\n}", "target": 1}
{"code": "mark_desktop_file_executable_task_done (GObject      *source_object,\n                                        GAsyncResult *res,\n                                        gpointer      user_data)\n{\n    MarkTrustedJob *job = user_data;\n    g_object_unref (job->file);\n    if (job->done_callback)\n    {\n        job->done_callback (!job_aborted ((CommonJob *) job),\n                            job->done_callback_data);\n    }\n    finalize_common ((CommonJob *) job);\n}", "target": 0}
{"code": "format_fractional_part_nsecs(gchar *buf, size_t buflen, guint32 nsecs, const char *decimal_point, int precision)\n{\n\tgsize decimal_point_len;\n\tgint8 num_buf[CHARS_NANOSECONDS];\n\tgint8 *num_end = &num_buf[CHARS_NANOSECONDS];\n\tgint8 *num_ptr;\n\tsize_t num_len;\n\tws_assert(precision != 0);\n\tif (buflen == 0) {\n\t\treturn;\n\t}\n\tdecimal_point_len = g_strlcpy(buf, decimal_point, buflen);\n\tif (decimal_point_len >= buflen) {\n\t\treturn;\n\t}\n\tbuf += decimal_point_len;\n\tbuflen -= decimal_point_len;\n\tswitch (precision) {\n\tcase 1:\n\t\tnum_ptr = uint_to_str_back_len(num_end,\n\t\t    nsecs / 100000000, precision);\n\t\tbreak;\n\tcase 2:\n\t\tnum_ptr = uint_to_str_back_len(num_end,\n\t\t    nsecs / 10000000, precision);\n\t\tbreak;\n\tcase 3:\n\t\tnum_ptr = uint_to_str_back_len(num_end,\n\t\t    nsecs / 1000000, precision);\n\t\tbreak;\n\tcase 4:\n\t\tnum_ptr = uint_to_str_back_len(num_end,\n\t\t    nsecs / 100000, precision);\n\t\tbreak;\n\tcase 5:\n\t\tnum_ptr = uint_to_str_back_len(num_end,\n\t\t    nsecs / 10000, precision);\n\t\tbreak;\n\tcase 6:\n\t\tnum_ptr = uint_to_str_back_len(num_end,\n\t\t    nsecs / 1000, precision);\n\t\tbreak;\n\tcase 7:\n\t\tnum_ptr = uint_to_str_back_len(num_end,\n\t\t    nsecs / 100, precision);\n\t\tbreak;\n\tcase 8:\n\t\tnum_ptr = uint_to_str_back_len(num_end,\n\t\t    nsecs / 10, precision);\n\t\tbreak;\n\tcase 9:\n\t\tnum_ptr = uint_to_str_back_len(num_end, nsecs,\n\t\t    precision);\n\t\tbreak;\n\tdefault:\n\t\tws_assert_not_reached();\n\t\tbreak;\n\t}\n\tnum_len = MIN((size_t)(num_end - num_ptr), buflen - 1);\n\tif (num_len == 0) {\n\t\treturn;\n\t}\n\tmemcpy(buf, num_ptr, num_len);\n\t*(buf + num_len) = '\\0';\n}", "target": 1}
{"code": "bool CmdExtract::ExtrCreateFile(Archive &Arc,File &CurFile)\n{\n  bool Success=true;\n  wchar Command=Cmd->Command[0];\n#if !defined(SFX_MODULE)\n  if (Command=='P')\n    CurFile.SetHandleType(FILE_HANDLESTD);\n#endif\n  if ((Command=='E' || Command=='X') && !Cmd->Test)\n  {\n    bool UserReject;\n    if (!FileCreate(Cmd,&CurFile,DestFileName,ASIZE(DestFileName),&UserReject,Arc.FileHead.UnpSize,&Arc.FileHead.mtime,true))\n    {\n      Success=false;\n      if (!UserReject)\n      {\n        ErrHandler.CreateErrorMsg(Arc.FileName,DestFileName);\n        if (FileExist(DestFileName) && IsDir(GetFileAttr(DestFileName)))\n          uiMsg(UIERROR_DIRNAMEEXISTS);\n#ifdef RARDLL\n        Cmd->DllError=ERAR_ECREATE;\n#endif\n        if (!IsNameUsable(DestFileName))\n        {\n          uiMsg(UIMSG_CORRECTINGNAME,Arc.FileName);\n          wchar OrigName[ASIZE(DestFileName)];\n          wcsncpyz(OrigName,DestFileName,ASIZE(OrigName));\n          MakeNameUsable(DestFileName,true);\n          if (!Cmd->AbsoluteLinks && UpLinkExtracted)\n            LinksToDirs(DestFileName,Cmd->ExtrPath,LastCheckedSymlink);\n          CreatePath(DestFileName,true,Cmd->DisableNames);\n          if (FileCreate(Cmd,&CurFile,DestFileName,ASIZE(DestFileName),&UserReject,Arc.FileHead.UnpSize,&Arc.FileHead.mtime,true))\n          {\n#ifndef SFX_MODULE\n            uiMsg(UIERROR_RENAMING,Arc.FileName,OrigName,DestFileName);\n#endif\n            Success=true;\n          }\n          else\n            ErrHandler.CreateErrorMsg(Arc.FileName,DestFileName);\n        }\n      }\n    }\n  }\n  return Success;\n}", "target": 0}
{"code": "static int IntensityCompare(const void *x,const void *y)\n{\n  const PixelChannels\n    *color_1,\n    *color_2;\n  double\n    distance;\n  ssize_t\n    i;\n  color_1=(const PixelChannels *) x;\n  color_2=(const PixelChannels *) y;\n  distance=0.0;\n  for (i=0; i < MaxPixelChannels; i++)\n    distance+=color_1->channel[i]-(double) color_2->channel[i];\n  return(distance < 0.0 ? -1 : distance > 0.0 ? 1 : 0);\n}", "target": 0}
{"code": "void test_chroot(const char *path)\n{\n\tif (chroot(path) == 0) {\n\t\tfprintf(stderr, \"leak at chroot of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at chroot of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "int IniParser::write()\n{\n    int bugs = 0;\n    if (!inifile.isDirty())\n    {\n        y2debug (\"File %s did not change. Not saving.\", multiple_files ? files[0].c_str () : file.c_str ());\n\treturn 0;\n    }\n    if (read_only)\n    {\n        y2debug (\"Attempt to write file %s that was mounted read-only. Not saving.\", multiple_files ? files[0].c_str () : file.c_str ());\n\treturn 0;\n    }\n    UpdateIfModif ();\n    if (multiple_files)\n    {\n\tIniIterator\n\t    ci = inifile.getContainerBegin (),\n\t    ce = inifile.getContainerEnd ();\n\tfor (;ci != ce; ++ci)\n\t    {\n\t\tif (ci->t () == SECTION)\n\t\t    {\n\t\t\tIniSection&s = ci->s ();\n\t\t\tint wb = s.getRewriteBy (); \n\t\t\tstring filename = getFileName (s.getName (), wb);\n\t\t\tdeleted_sections.erase (filename);\n\t\t\tif (!s.isDirty ()) {\n\t\t\t    y2debug (\"Skipping file %s that was not changed.\", filename.c_str());\n\t\t\t    continue;\n\t\t\t}\n\t\t\ts.initReadBy ();\n\t\t\tPathname pn (filename);\n\t\t\tPathInfo::assert_dir (pn.dirname ());\n\t\t\tofstream of(filename.c_str());\n\t\t\tif (!of.good())\n\t\t\t{\n\t\t\t    bugs++;\n\t\t\t    y2error (\"Can not open file %s for write\", filename.c_str());\n\t\t\t    continue;\n\t\t\t}\n\t\t\twrite_helper (s, of, 0);\n\t\t\ts.clean();\n\t\t\tof.close ();\n\t\t    }\n\t\telse\n\t\t    {\n\t\t\ty2error (\"Value %s encountered at multifile top level\",\n\t\t\t\t ci->e ().getName ());\n\t\t    }\n\t    }\n\tfor (set<string>::iterator i = deleted_sections.begin (); i!=deleted_sections.end();i++)\n\t    if (multi_files.find (*i) != multi_files.end ()) {\n\t\ty2debug (\"Removing file %s\\n\", (*i).c_str());\n\t\tunlink ((*i).c_str());\n\t    }\n    }\n    else\n    {\n\tPathname pn (file);\n\tPathInfo::assert_dir (pn.dirname ());\n\tofstream of(file.c_str());\n\tif (!of.good())\n\t{\n\t    y2error (\"Can not open file %s for write\", file.c_str());\n\t    return -1;\n\t}\n\twrite_helper (inifile, of, 0);\n\tof.close();\n\ttimestamp = getTimeStamp ();\n    }\n    inifile.clean ();\n    return bugs ? -1 : 0;\n}", "target": 1}
{"code": "static int ax25_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint *uaddr_len, int peer)\n{\n\tstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tunsigned char ndigi, i;\n\tax25_cb *ax25;\n\tint err = 0;\n\tmemset(fsa, 0, sizeof(*fsa));\n\tlock_sock(sk);\n\tax25 = ax25_sk(sk);\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tgoto out;\n\t\t}\n\t\tfsa->fsa_ax25.sax25_family = AF_AX25;\n\t\tfsa->fsa_ax25.sax25_call   = ax25->dest_addr;\n\t\tif (ax25->digipeat != NULL) {\n\t\t\tndigi = ax25->digipeat->ndigi;\n\t\t\tfsa->fsa_ax25.sax25_ndigis = ndigi;\n\t\t\tfor (i = 0; i < ndigi; i++)\n\t\t\t\tfsa->fsa_digipeater[i] =\n\t\t\t\t\t\tax25->digipeat->calls[i];\n\t\t}\n\t} else {\n\t\tfsa->fsa_ax25.sax25_family = AF_AX25;\n\t\tfsa->fsa_ax25.sax25_call   = ax25->source_addr;\n\t\tfsa->fsa_ax25.sax25_ndigis = 1;\n\t\tif (ax25->ax25_dev != NULL) {\n\t\t\tmemcpy(&fsa->fsa_digipeater[0],\n\t\t\t       ax25->ax25_dev->dev->dev_addr, AX25_ADDR_LEN);\n\t\t} else {\n\t\t\tfsa->fsa_digipeater[0] = null_ax25_address;\n\t\t}\n\t}\n\t*uaddr_len = sizeof (struct full_sockaddr_ax25);\nout:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "static pjmedia_sdp_attr *parse_attr( pj_pool_t *pool, pj_scanner *scanner,\n\t\t\t\t    volatile parse_context *ctx)\n{\n    pjmedia_sdp_attr *attr;\n    ctx->last_error = PJMEDIA_SDP_EINATTR;\n    attr = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_attr);\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn NULL;\n    }\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n    pj_scan_get(scanner, &cs_token, &attr->name);\n    if (*scanner->curptr && *scanner->curptr != '\\r' && \n\t*scanner->curptr != '\\n') \n    {\n\tif (*scanner->curptr == ':')\n\t    pj_scan_get_char(scanner);\n\tif (*scanner->curptr != '\\r' && *scanner->curptr != '\\n') {\n\t    pj_scan_get_until_chr(scanner, \"\\r\\n\", &attr->value);\n\t} else {\n\t    attr->value.ptr = NULL;\n\t    attr->value.slen = 0;\n\t}\n    } else {\n\tattr->value.ptr = NULL;\n\tattr->value.slen = 0;\n    }\n    pj_scan_skip_line(scanner);\n    return attr;\n}", "target": 1}
{"code": "dump_keywords(vector_t *keydump, int level, FILE *fp)\n{\n\tunsigned int i;\n\tkeyword_t *keyword_vec;\n\tchar file_name[21];\n\tif (!level) {\n\t\tsnprintf(file_name, sizeof(file_name), \"/tmp/keywords.%d\", getpid());\n\t\tfp = fopen(file_name, \"w\");\n\t\tif (!fp)\n\t\t\treturn;\n\t}\n\tfor (i = 0; i < vector_size(keydump); i++) {\n\t\tkeyword_vec = vector_slot(keydump, i);\n\t\tfprintf(fp, \"%*sKeyword : %s (%s)\\n\", level * 2, \"\", keyword_vec->string, keyword_vec->active ? \"active\": \"disabled\");\n\t\tif (keyword_vec->sub)\n\t\t\tdump_keywords(keyword_vec->sub, level + 1, fp);\n\t}\n\tif (!level)\n\t\tfclose(fp);\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, DottedFieldCovering) {\n    addIndex(BSON(\"a.b\" << 1));\n    runQuerySortProj(fromjson(\"{'a.b': 5}\"), BSONObj(), fromjson(\"{_id: 0, 'a.b': 1}\"));\n    ASSERT_EQUALS(getNumSolutions(), 2U);\n    assertSolutionExists(\n        \"{proj: {spec: {_id: 0, 'a.b': 1}, node: \"\n        \"{cscan: {dir: 1, filter: {'a.b': 5}}}}}\");\n    assertSolutionExists(\n        \"{proj: {spec: {_id: 0, 'a.b': 1}, node: {ixscan: {filter: null, pattern: {'a.b': 1},\"\n        \"bounds: {'a.b': [[5,5,true,true]]}}}}}\");\n}", "target": 0}
{"code": "swap_until_sorted(struct delta_head *deltas, unsigned int i,\n    unsigned long min, unsigned long max)\n{\n\tunsigned int target_slot;\n\tstruct delta_head tmp;\n\twhile (true) {\n\t\tif (deltas[i].serial < min || max < deltas[i].serial) {\n\t\t\treturn pr_val_err(\"Deltas: Serial '%lu' is out of bounds. (min:%lu, max:%lu)\",\n\t\t\t    deltas[i].serial, min, max);\n\t\t}\n\t\ttarget_slot = deltas[i].serial - min;\n\t\tif (i == target_slot)\n\t\t\treturn 0;\n\t\tif (deltas[target_slot].serial == deltas[i].serial) {\n\t\t\treturn pr_val_err(\"Deltas: Serial '%lu' is not unique.\",\n\t\t\t    deltas[i].serial);\n\t\t}\n\t\ttmp = deltas[target_slot];\n\t\tdeltas[target_slot] = deltas[i];\n\t\tdeltas[i] = tmp;\n\t}\n}", "target": 0}
{"code": "void SetSitesMuted(const TabStripModel& tab_strip,\n                   const std::vector<int>& indices,\n                   const bool mute) {\n  for (int tab_index : indices) {\n    content::WebContents* web_contents = tab_strip.GetWebContentsAt(tab_index);\n    GURL url = web_contents->GetLastCommittedURL();\n    if (url.SchemeIs(content::kChromeUIScheme)) {\n      SetTabAudioMuted(web_contents, mute,\n                       TabMutedReason::CONTENT_SETTING_CHROME, std::string());\n    } else {\n      Profile* profile =\n          Profile::FromBrowserContext(web_contents->GetBrowserContext());\n      HostContentSettingsMap* settings =\n          HostContentSettingsMapFactory::GetForProfile(profile);\n      ContentSetting setting =\n          mute ? CONTENT_SETTING_BLOCK : CONTENT_SETTING_ALLOW;\n      if (setting == settings->GetDefaultContentSetting(\n                         CONTENT_SETTINGS_TYPE_SOUND, nullptr)) {\n        setting = CONTENT_SETTING_DEFAULT;\n      }\n      settings->SetContentSettingDefaultScope(\n          url, url, CONTENT_SETTINGS_TYPE_SOUND, std::string(), setting);\n    }\n  }\n}", "target": 0}
{"code": "win_vert_neighbor(tabpage_T *tp, win_T *wp, int up, long count)\n{\n    frame_T\t*fr;\n    frame_T\t*nfr;\n    frame_T\t*foundfr;\n    foundfr = wp->w_frame;\n    while (count--)\n    {\n\tfr = foundfr;\n\tfor (;;)\n\t{\n\t    if (fr == tp->tp_topframe)\n\t\tgoto end;\n\t    if (up)\n\t\tnfr = fr->fr_prev;\n\t    else\n\t\tnfr = fr->fr_next;\n\t    if (fr->fr_parent->fr_layout == FR_COL && nfr != NULL)\n\t\tbreak;\n\t    fr = fr->fr_parent;\n\t}\n\tfor (;;)\n\t{\n\t    if (nfr->fr_layout == FR_LEAF)\n\t    {\n\t\tfoundfr = nfr;\n\t\tbreak;\n\t    }\n\t    fr = nfr->fr_child;\n\t    if (nfr->fr_layout == FR_ROW)\n\t    {\n\t\twhile (fr->fr_next != NULL\n\t\t\t&& frame2win(fr)->w_wincol + fr->fr_width\n\t\t\t\t\t <= wp->w_wincol + wp->w_wcol)\n\t\t    fr = fr->fr_next;\n\t    }\n\t    if (nfr->fr_layout == FR_COL && up)\n\t\twhile (fr->fr_next != NULL)\n\t\t    fr = fr->fr_next;\n\t    nfr = fr;\n\t}\n    }\nend:\n    return foundfr != NULL ? foundfr->fr_win : NULL;\n}", "target": 0}
{"code": "static uint32_t buf_to_uint32(char *data) {\n    size_t i;\n    uint32_t result = 0;\n    for (i = 0; i < sizeof(uint32_t); i++)\n        result = (result << 8) | (unsigned char)data[i];\n    return result;\n}", "target": 0}
{"code": "table_regex_match(const char *string, const char *pattern)\n{\n\tregex_t preg;\n\tint\tcflags = REG_EXTENDED|REG_NOSUB;\n\tif (strncmp(pattern, \"(?i)\", 4) == 0) {\n\t\tcflags |= REG_ICASE;\n\t\tpattern += 4;\n\t}\n\tif (regcomp(&preg, pattern, cflags) != 0)\n\t\treturn (0);\n\tif (regexec(&preg, string, 0, NULL, 0) != 0)\n\t\treturn (0);\n\treturn (1);\n}", "target": 1}
{"code": "v8::Handle<v8::Value> V8ThrowException::throwTypeError(v8::Isolate* isolate, const String& message)\n{\n    v8::Handle<v8::Value> exception = V8ThrowException::createTypeError(isolate, message);\n    return V8ThrowException::throwException(exception, isolate);\n}", "target": 0}
{"code": "header_put_be_3byte (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 3)\n\t{\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} ", "target": 1}
{"code": "  void Compute(OpKernelContext* c) override {\n    const Tensor& tag = c->input(0);\n    OP_REQUIRES(c, TensorShapeUtils::IsScalar(tag.shape()),\n                errors::InvalidArgument(\"tag must be scalar\"));\n    const Tensor& tensor = c->input(1);\n    const Tensor& serialized_summary_metadata_tensor = c->input(2);\n    OP_REQUIRES(\n        c,\n        TensorShapeUtils::IsScalar(serialized_summary_metadata_tensor.shape()),\n        errors::InvalidArgument(\"serialized_summary_metadata must be scalar\"));\n    Summary s;\n    Summary::Value* v = s.add_value();\n    v->set_tag(string(tag.scalar<tstring>()()));  \n    if (tensor.dtype() == DT_STRING) {\n      tensor.AsProtoField(v->mutable_tensor());\n    } else {\n      tensor.AsProtoTensorContent(v->mutable_tensor());\n    }\n    ParseFromTString(serialized_summary_metadata_tensor.scalar<tstring>()(),\n                     v->mutable_metadata());\n    Tensor* summary_tensor = nullptr;\n    OP_REQUIRES_OK(c, c->allocate_output(0, TensorShape({}), &summary_tensor));\n    CHECK(SerializeToTString(s, &summary_tensor->scalar<tstring>()()));\n  }", "target": 0}
{"code": "static int pptp_connect(struct socket *sock, struct sockaddr *uservaddr,\n\tint sockaddr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_pppox *sp = (struct sockaddr_pppox *) uservaddr;\n\tstruct pppox_sock *po = pppox_sk(sk);\n\tstruct pptp_opt *opt = &po->proto.pptp;\n\tstruct rtable *rt;\n\tstruct flowi4 fl4;\n\tint error = 0;\n\tif (sockaddr_len < sizeof(struct sockaddr_pppox))\n\t\treturn -EINVAL;\n\tif (sp->sa_protocol != PX_PROTO_PPTP)\n\t\treturn -EINVAL;\n\tif (lookup_chan_dst(sp->sa_addr.pptp.call_id, sp->sa_addr.pptp.sin_addr.s_addr))\n\t\treturn -EALREADY;\n\tlock_sock(sk);\n\tif (sk->sk_state & PPPOX_CONNECTED) {\n\t\terror = -EBUSY;\n\t\tgoto end;\n\t}\n\tif (sk->sk_state & PPPOX_DEAD) {\n\t\terror = -EALREADY;\n\t\tgoto end;\n\t}\n\tif (!opt->src_addr.sin_addr.s_addr || !sp->sa_addr.pptp.sin_addr.s_addr) {\n\t\terror = -EINVAL;\n\t\tgoto end;\n\t}\n\tpo->chan.private = sk;\n\tpo->chan.ops = &pptp_chan_ops;\n\trt = ip_route_output_ports(sock_net(sk), &fl4, sk,\n\t\t\t\t   opt->dst_addr.sin_addr.s_addr,\n\t\t\t\t   opt->src_addr.sin_addr.s_addr,\n\t\t\t\t   0, 0,\n\t\t\t\t   IPPROTO_GRE, RT_CONN_FLAGS(sk), 0);\n\tif (IS_ERR(rt)) {\n\t\terror = -EHOSTUNREACH;\n\t\tgoto end;\n\t}\n\tsk_setup_caps(sk, &rt->dst);\n\tpo->chan.mtu = dst_mtu(&rt->dst);\n\tif (!po->chan.mtu)\n\t\tpo->chan.mtu = PPP_MRU;\n\tip_rt_put(rt);\n\tpo->chan.mtu -= PPTP_HEADER_OVERHEAD;\n\tpo->chan.hdrlen = 2 + sizeof(struct pptp_gre_header);\n\terror = ppp_register_channel(&po->chan);\n\tif (error) {\n\t\tpr_err(\"PPTP: failed to register PPP channel (%d)\\n\", error);\n\t\tgoto end;\n\t}\n\topt->dst_addr = sp->sa_addr.pptp;\n\tsk->sk_state = PPPOX_CONNECTED;\n end:\n\trelease_sock(sk);\n\treturn error;\n}", "target": 0}
{"code": "spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n\t\t       int iov_count)\n{\n    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n\t\t\t   iov_count);\n}", "target": 1}
{"code": "putstr(int d)\n{\n    addbufspc(1);\n    pputc(d);\n    return 0;\n}", "target": 0}
{"code": "Eina_Bool ewk_view_forward_possible(Evas_Object* ewkView)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    return ewk_frame_forward_possible(smartData->main_frame);\n}", "target": 0}
{"code": "ttwu_do_activate(struct rq *rq, struct task_struct *p, int wake_flags)\n{\n\tlockdep_assert_held(&rq->lock);\n#ifdef CONFIG_SMP\n\tif (p->sched_contributes_to_load)\n\t\trq->nr_uninterruptible--;\n#endif\n\tttwu_activate(rq, p, ENQUEUE_WAKEUP | ENQUEUE_WAKING);\n\tttwu_do_wakeup(rq, p, wake_flags);\n}", "target": 0}
{"code": "vips_tracked_malloc( size_t size )\n{\n        void *buf;\n\tvips_tracked_init(); \n\tsize += 16;\n        if( !(buf = g_try_malloc( size )) ) {\n#ifdef DEBUG\n\t\tg_assert_not_reached();\n#endif \n\t\tvips_error( \"vips_tracked\", \n\t\t\t_( \"out of memory --- size == %dMB\" ), \n\t\t\t(int) (size / (1024.0 * 1024.0))  );\n\t\tg_warning( _( \"out of memory --- size == %dMB\" ), \n\t\t\t(int) (size / (1024.0 * 1024.0))  );\n                return( NULL );\n\t}\n\tg_mutex_lock( vips_tracked_mutex );\n\t*((size_t *)buf) = size;\n\tbuf = (void *) ((char *)buf + 16);\n\tvips_tracked_mem += size;\n\tif( vips_tracked_mem > vips_tracked_mem_highwater ) \n\t\tvips_tracked_mem_highwater = vips_tracked_mem;\n\tvips_tracked_allocs += 1;\n#ifdef DEBUG_VERBOSE\n\tprintf( \"vips_tracked_malloc: %p, %zd bytes\\n\", buf, size ); \n#endif \n\tg_mutex_unlock( vips_tracked_mutex );\n\tVIPS_GATE_MALLOC( size ); \n        return( buf );\n}", "target": 1}
{"code": "        bool erase() const { return erase_; }", "target": 0}
{"code": "static RList *patch_relocs(RBin *b) {\n\tr_return_val_if_fail (b && b->iob.io && b->iob.io->desc, NULL);\n\tRBinObject *bo = r_bin_cur_object (b);\n\tRIO *io = b->iob.io;\n\tif (!bo || !bo->bin_obj) {\n\t\treturn NULL;\n\t}\n\tstruct r_bin_coff_obj *bin = (struct r_bin_coff_obj*)bo->bin_obj;\n\tif (bin->hdr.f_flags & COFF_FLAGS_TI_F_EXEC) {\n\t\treturn NULL;\n\t}\n\tif (!(io->cached & R_PERM_W)) {\n\t\teprintf (\n\t\t\t\"Warning: please run r2 with -e io.cache=true to patch \"\n\t\t\t\"relocations\\n\");\n\t\treturn NULL;\n\t}\n\tsize_t nimports = 0;\n\tint i;\n\tfor (i = 0; i < bin->hdr.f_nsyms; i++) {\n\t\tif (is_imported_symbol (&bin->symbols[i])) {\n\t\t\tnimports++;\n\t\t}\n\t\ti += bin->symbols[i].n_numaux;\n\t}\n\tut64 m_vaddr = UT64_MAX;\n\tif (nimports) {\n\t\tut64 offset = 0;\n\t\tRIOBank *bank = b->iob.bank_get (io, io->bank);\n\t\tRListIter *iter;\n\t\tRIOMapRef *mapref;\n\t\tr_list_foreach (bank->maprefs, iter, mapref) {\n\t\t\tRIOMap *map = b->iob.map_get (io, mapref->id);\n\t\t\tif (r_io_map_end (map) > offset) {\n\t\t\t\toffset = r_io_map_end (map);\n\t\t\t}\n\t\t}\n\t\tm_vaddr = R_ROUND (offset, 16);\n\t\tut64 size = nimports * BYTES_PER_IMP_RELOC;\n\t\tchar *muri = r_str_newf (\"malloc:\n\t\tRIODesc *desc = b->iob.open_at (io, muri, R_PERM_R, 0664, m_vaddr);\n\t\tfree (muri);\n\t\tif (!desc) {\n\t\t\treturn NULL;\n\t\t}\n\t\tRIOMap *map = b->iob.map_get_at (io, m_vaddr);\n\t\tif (!map) {\n\t\t\treturn NULL;\n\t\t}\n\t\tmap->name = strdup (\".imports.r2\");\n\t}\n\treturn _relocs_list (b, bin, true, m_vaddr);\n}", "target": 1}
{"code": "void ZydisFormatterBufferInitTokenized(ZydisFormatterBuffer* buffer,\n    ZydisFormatterToken** first_token, void* user_buffer, ZyanUSize length)\n{\n    ZYAN_ASSERT(buffer);\n    ZYAN_ASSERT(first_token);\n    ZYAN_ASSERT(user_buffer);\n    ZYAN_ASSERT(length);\n    *first_token = user_buffer;\n    (*first_token)->type = ZYDIS_TOKEN_INVALID;\n    (*first_token)->next = 0;\n    user_buffer = (ZyanU8*)user_buffer + sizeof(ZydisFormatterToken);\n    length -= sizeof(ZydisFormatterToken);\n    buffer->is_token_list              = ZYAN_TRUE;\n    buffer->capacity                   = length;\n    buffer->string.flags               = ZYAN_STRING_HAS_FIXED_CAPACITY;\n    buffer->string.vector.allocator    = ZYAN_NULL;\n    buffer->string.vector.element_size = sizeof(char);\n    buffer->string.vector.size         = 1;\n    buffer->string.vector.capacity     = length;\n    buffer->string.vector.data         = user_buffer;\n    *(char*)user_buffer = '\\0';\n}", "target": 1}
{"code": "static bool caller_is_in_ancestor(pid_t pid, const char *contrl, const char *cg, char **nextcg)\n{\n\tchar fnam[PROCLEN];\n\tFILE *f;\n\tbool answer = false;\n\tchar *line = NULL;\n\tsize_t len = 0;\n\tint ret;\n\tret = snprintf(fnam, PROCLEN, \"/proc/%d/cgroup\", pid);\n\tif (ret < 0 || ret >= PROCLEN)\n\t\treturn false;\n\tif (!(f = fopen(fnam, \"r\")))\n\t\treturn false;\n\twhile (getline(&line, &len, f) != -1) {\n\t\tchar *c1, *c2, *linecmp;\n\t\tif (!line[0])\n\t\t\tcontinue;\n\t\tc1 = strchr(line, ':');\n\t\tif (!c1)\n\t\t\tgoto out;\n\t\tc1++;\n\t\tc2 = strchr(c1, ':');\n\t\tif (!c2)\n\t\t\tgoto out;\n\t\t*c2 = '\\0';\n\t\tif (strcmp(c1, contrl) != 0)\n\t\t\tcontinue;\n\t\tc2++;\n\t\tstripnewline(c2);\n\t\tprune_init_slice(c2);\n\t\tlinecmp = *cg == '/' ? c2 : c2+1;\n\t\tif (strncmp(linecmp, cg, strlen(linecmp)) != 0) {\n\t\t\tif (nextcg)\n\t\t\t\t*nextcg = get_next_cgroup_dir(linecmp, cg);\n\t\t\tgoto out;\n\t\t}\n\t\tanswer = true;\n\t\tgoto out;\n\t}\nout:\n\tfclose(f);\n\tfree(line);\n\treturn answer;\n}", "target": 1}
{"code": "static int attach_link(LINK_HANDLE link, ON_ENDPOINT_FRAME_RECEIVED* on_frame_received)\n{\n    umock_c_reset_all_calls();\n    STRICT_EXPECTED_CALL(session_begin(TEST_SESSION_HANDLE));\n    STRICT_EXPECTED_CALL(session_start_link_endpoint(TEST_LINK_ENDPOINT, IGNORED_PTR_ARG, IGNORED_PTR_ARG, IGNORED_PTR_ARG, link))\n        .CaptureArgumentValue_frame_received_callback(on_frame_received);\n    return link_attach(link, test_on_transfer_received, test_on_link_state_changed, test_on_link_flow_on, NULL);\n}", "target": 0}
{"code": "static bool isHexDigit(char ch) {\n  return (ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'f') ||\n         (ch >= 'A' && ch <= 'F');\n}", "target": 0}
{"code": "static void __skb_complete_tx_timestamp(struct sk_buff *skb,\n\t\t\t\t\tstruct sock *sk,\n\t\t\t\t\tint tstype)\n{\n\tstruct sock_exterr_skb *serr;\n\tint err;\n\tserr = SKB_EXT_ERR(skb);\n\tmemset(serr, 0, sizeof(*serr));\n\tserr->ee.ee_errno = ENOMSG;\n\tserr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;\n\tserr->ee.ee_info = tstype;\n\tif (sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID) {\n\t\tserr->ee.ee_data = skb_shinfo(skb)->tskey;\n\t\tif (sk->sk_protocol == IPPROTO_TCP &&\n\t\t    sk->sk_type == SOCK_STREAM)\n\t\t\tserr->ee.ee_data -= sk->sk_tskey;\n\t}\n\terr = sock_queue_err_skb(sk, skb);\n\tif (err)\n\t\tkfree_skb(skb);", "target": 1}
{"code": "static pj_status_t decode_uint_attr(pj_pool_t *pool, \n                                    const pj_uint8_t *buf, \n                                    const pj_stun_msg_hdr *msghdr, \n                                    void **p_attr)\n{\n    pj_stun_uint_attr *attr;\n    PJ_UNUSED_ARG(msghdr);\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint_attr);\n    GETATTRHDR(buf, &attr->hdr);\n    attr->value = GETVAL32H(buf, 4);\n    if (attr->hdr.length != 4)\n        return PJNATH_ESTUNINATTRLEN;\n    *p_attr = attr;\n    return PJ_SUCCESS;\n}", "target": 1}
{"code": "int DefaultCertValidator::doVerifyCertChain(\n    X509_STORE_CTX* store_ctx, Ssl::SslExtendedSocketInfo* ssl_extended_info, X509& leaf_cert,\n    const Network::TransportSocketOptions* transport_socket_options) {\n  if (verify_trusted_ca_) {\n    int ret = X509_verify_cert(store_ctx);\n    if (ssl_extended_info) {\n      ssl_extended_info->setCertificateValidationStatus(\n          ret == 1 ? Envoy::Ssl::ClientValidationStatus::Validated\n                   : Envoy::Ssl::ClientValidationStatus::Failed);\n    }\n    if (ret <= 0) {\n      stats_.fail_verify_error_.inc();\n      ENVOY_LOG(debug, \"{}\", Utility::getX509VerificationErrorInfo(store_ctx));\n      return allow_untrusted_certificate_ ? 1 : ret;\n    }\n  }\n  Envoy::Ssl::ClientValidationStatus validated =\n      verifyCertificate(&leaf_cert,\n                        transport_socket_options != nullptr\n                            ? transport_socket_options->verifySubjectAltNameListOverride()\n                            : std::vector<std::string>{},\n                        subject_alt_name_matchers_);\n  if (ssl_extended_info) {\n    if (ssl_extended_info->certificateValidationStatus() ==\n        Envoy::Ssl::ClientValidationStatus::NotValidated) {\n      ssl_extended_info->setCertificateValidationStatus(validated);\n    } else if (validated != Envoy::Ssl::ClientValidationStatus::NotValidated) {\n      ssl_extended_info->setCertificateValidationStatus(validated);\n    }\n  }\n  int validation_status = verify_trusted_ca_\n                              ? validated != Envoy::Ssl::ClientValidationStatus::Failed\n                              : validated == Envoy::Ssl::ClientValidationStatus::Validated;\n  return allow_untrusted_certificate_ ? 1 : validation_status;\n}", "target": 1}
{"code": "test_validate_path_characters (void)\n{\n  gsize idx;\n  for (idx = 0; idx < G_N_ELEMENTS (paths); idx++)\n    {\n      PathValidityData *data = &paths[idx];\n      gboolean ret = FALSE;\n      ret = flatpak_validate_path_characters (data->path, NULL);\n      g_assert_cmpint (ret, ==, data->ret);\n    }\n}", "target": 0}
{"code": "inline bool ResolveAxis(const int num_dims, const int* axis,\n                        const int64_t num_axis, int* out_axis,\n                        int* out_num_axis) {\n  *out_num_axis = 0;  \n  if (num_dims == 0) {\n    return true;\n  }\n  for (int64_t idx = 0; idx < num_axis; ++idx) {\n    int current = axis[idx] < 0 ? (axis[idx] + num_dims) : axis[idx];\n    TFLITE_DCHECK(current >= 0 && current < num_dims);\n    if (current < 0 || current >= num_dims) {\n      return false;\n    }\n    bool is_dup = false;\n    for (int j = 0; j < *out_num_axis; ++j) {\n      if (out_axis[j] == current) {\n        is_dup = true;\n        break;\n      }\n    }\n    if (!is_dup) {\n      out_axis[*out_num_axis] = current;\n      *out_num_axis += 1;\n    }\n  }\n  return true;\n}", "target": 0}
{"code": "static void sctp_skb_set_owner_r_frag(struct sk_buff *skb, struct sock *sk)\n{\n\tstruct sk_buff *frag;\n\tif (!skb->data_len)\n\t\tgoto done;\n\tfor (frag = skb_shinfo(skb)->frag_list; frag; frag = frag->next)\n\t\tsctp_skb_set_owner_r_frag(frag, sk);\ndone:\n\tsctp_skb_set_owner_r(skb, sk);\n}", "target": 0}
{"code": "pk_transaction_finished_emit (PkTransaction *transaction,\n\t\t\t      PkExitEnum exit_enum,\n\t\t\t      guint time_ms)\n{\n\tg_assert (!transaction->priv->emitted_finished);\n\ttransaction->priv->emitted_finished = TRUE;\n\tg_debug (\"emitting finished '%s', %i\",\n\t\t pk_exit_enum_to_string (exit_enum),\n\t\t time_ms);\n\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t       NULL,\n\t\t\t\t       transaction->priv->tid,\n\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t       \"Finished\",\n\t\t\t\t       g_variant_new (\"(uu)\",\n\t\t\t\t\t\t      exit_enum,\n\t\t\t\t\t\t      time_ms),\n\t\t\t\t       NULL);\n\tg_signal_emit (transaction, signals[SIGNAL_FINISHED], 0);\n}", "target": 0}
{"code": "static int apparmor_setprocattr(struct task_struct *task, char *name,\n\t\t\t\tvoid *value, size_t size)\n{\n\tchar *command, *args = value;\n\tsize_t arg_size;\n\tint error;\n\tif (size == 0)\n\t\treturn -EINVAL;\n\tif (args[size - 1] != '\\0') {\n\t\tif (size == PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\targs[size] = '\\0';\n\t}\n\tif (current != task)\n\t\treturn -EACCES;\n\targs = value;\n\targs = strim(args);\n\tcommand = strsep(&args, \" \");\n\tif (!args)\n\t\treturn -EINVAL;\n\targs = skip_spaces(args);\n\tif (!*args)\n\t\treturn -EINVAL;\n\targ_size = size - (args - (char *) value);\n\tif (strcmp(name, \"current\") == 0) {\n\t\tif (strcmp(command, \"changehat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permhat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_DO_TEST);\n\t\t} else if (strcmp(command, \"changeprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permipc\") == 0) {\n\t\t\terror = aa_setprocattr_permipc(args);\n\t\t} else {\n\t\t\tstruct common_audit_data sa;\n\t\t\tCOMMON_AUDIT_DATA_INIT(&sa, NONE);\n\t\t\tsa.aad.op = OP_SETPROCATTR;\n\t\t\tsa.aad.info = name;\n\t\t\tsa.aad.error = -EINVAL;\n\t\t\treturn aa_audit(AUDIT_APPARMOR_DENIED, NULL, GFP_KERNEL,\n\t\t\t\t\t&sa, NULL);\n\t\t}\n\t} else if (strcmp(name, \"exec\") == 0) {\n\t\terror = aa_setprocattr_changeprofile(args, AA_ONEXEC,\n\t\t\t\t\t\t     !AA_DO_TEST);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\tif (!error)\n\t\terror = size;\n\treturn error;\n}", "target": 1}
{"code": "int fit_check_format(const void *fit, ulong size)\n{\n\tint ret;\n\tret = fdt_check_header(fit);\n\tif (ret) {\n\t\tlog_debug(\"Wrong FIT format: not a flattened device tree (err=%d)\\n\",\n\t\t\t  ret);\n\t\treturn -ENOEXEC;\n\t}\n\tif (CONFIG_IS_ENABLED(FIT_FULL_CHECK)) {\n\t\tif (size == IMAGE_SIZE_INVAL)\n\t\t\tsize = fdt_totalsize(fit);\n\t\tret = fdt_check_full(fit, size);\n\t\tif (ret)\n\t\t\tret = -EINVAL;\n\t\tif (!ret && CONFIG_IS_ENABLED(FIT_SIGNATURE)) {\n\t\t\tret = fdt_check_no_at(fit, 0);\n\t\t\tif (ret) {\n\t\t\t\tlog_debug(\"FIT check error %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tif (ret) {\n\t\t\tlog_debug(\"FIT check error %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tif (!fdt_getprop(fit, 0, FIT_DESC_PROP, NULL)) {\n\t\tlog_debug(\"Wrong FIT format: no description\\n\");\n\t\treturn -ENOMSG;\n\t}\n\tif (IMAGE_ENABLE_TIMESTAMP) {\n\t\tif (!fdt_getprop(fit, 0, FIT_TIMESTAMP_PROP, NULL)) {\n\t\t\tlog_debug(\"Wrong FIT format: no timestamp\\n\");\n\t\t\treturn -ENODATA;\n\t\t}\n\t}\n\tif (fdt_path_offset(fit, FIT_IMAGES_PATH) < 0) {\n\t\tlog_debug(\"Wrong FIT format: no images parent node\\n\");\n\t\treturn -ENOENT;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "TfLiteStatus SoftmaxPrepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = static_cast<TfLiteSoftmaxParams*>(node->builtin_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TF_LITE_ENSURE(context, NumDimensions(input) >= 1);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TFLITE_DCHECK(node->user_data != nullptr);\n  SoftmaxParams* data = static_cast<SoftmaxParams*>(node->user_data);\n  return CalculateSoftmaxParams(context, input, output, params, data);\n}", "target": 0}
{"code": "static int remarkupvals (global_State *g) {\n  lua_State *thread;\n  lua_State **p = &g->twups;\n  int work = 0;\n  while ((thread = *p) != NULL) {\n    work++;\n    lua_assert(!isblack(thread));  \n    if (isgray(thread) && thread->openupval != NULL)\n      p = &thread->twups;  \n    else {  \n      UpVal *uv;\n      lua_assert(!isold(thread) || thread->openupval == NULL);\n      *p = thread->twups;  \n      thread->twups = thread;  \n      for (uv = thread->openupval; uv != NULL; uv = uv->u.open.next) {\n        lua_assert(getage(uv) <= getage(thread));\n        work++;\n        if (!iswhite(uv))  \n          markvalue(g, uv->v);  \n      }\n    }\n  }\n  return work;\n}", "target": 0}
{"code": "static int ext4_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tint result;\n\thandle_t *handle = NULL;\n\tstruct super_block *sb = file_inode(vma->vm_file)->i_sb;\n\tbool write = vmf->flags & FAULT_FLAG_WRITE;\n\tif (write) {\n\t\tsb_start_pagefault(sb);\n\t\tfile_update_time(vma->vm_file);\n\t\thandle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,\n\t\t\t\t\t\tEXT4_DATA_TRANS_BLOCKS(sb));\n\t}\n\tif (IS_ERR(handle))\n\t\tresult = VM_FAULT_SIGBUS;\n\telse\n\t\tresult = __dax_fault(vma, vmf, ext4_get_block_dax,\n\t\t\t\t\t\text4_end_io_unwritten);\n\tif (write) {\n\t\tif (!IS_ERR(handle))\n\t\t\text4_journal_stop(handle);\n\t\tsb_end_pagefault(sb);\n\t}\n\treturn result;\n}", "target": 1}
{"code": "static inline int timer_overrun_to_int(struct k_itimer *timr, int baseval)\n{\n\ts64 sum = timr->it_overrun_last + (s64)baseval;\n\treturn sum > (s64)INT_MAX ? INT_MAX : (int)sum;\n}", "target": 0}
{"code": "  void setInVmContextCreatedForTesting() { in_vm_context_created_ = true; }", "target": 0}
{"code": "static uint32_t qpp_hash(QppEntry e)\n{\n    return qemu_xxhash7(e.ino_prefix, e.dev, 0, 0, 0);\n}", "target": 0}
{"code": "static int ip_identify_match_check(void *obj, void *arg, int flags)\n{\n\tstruct ip_identify_match *identify = obj;\n\tstruct ast_sockaddr_with_tp *addr_with_tp = arg;\n\tstruct ast_sockaddr address = addr_with_tp->addr;\n\tint sense;\n\tsense = ast_apply_ha(identify->matches, &address);\n\tif (sense != AST_SENSE_ALLOW) {\n\t\tast_debug(3, \"Address %s matches identify '%s'\\n\",\n\t\t\t\tast_sockaddr_stringify(&address),\n\t\t\t\tast_sorcery_object_get_id(identify));\n\t\tif (ast_strlen_zero(identify->transport) || !strcasecmp(identify->transport, addr_with_tp->tp)) {\n\t\t\tast_debug(3, \"Transport %s matches identify '%s'\\n\",\n\t\t\t\taddr_with_tp->tp,\n\t\t\t\tast_sorcery_object_get_id(identify));\n\t\t\treturn CMP_MATCH;\n\t\t} else {\n\t\t\tast_debug(3, \"Transport %s match not matched identify '%s'\\n\",\n\t\t\t\taddr_with_tp->tp,\n\t\t\t\tast_sorcery_object_get_id(identify));\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tast_debug(3, \"Address %s does not match identify '%s'\\n\",\n\t\t\t\tast_sockaddr_stringify(&address),\n\t\t\t\tast_sorcery_object_get_id(identify));\n\t\treturn 0;\n\t}\n}", "target": 1}
{"code": "static void __update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, const nfs4_stateid *deleg_stateid, int open_flags)\n{\n\twrite_seqlock(&state->seqlock);\n\tif (deleg_stateid != NULL) {\n\t\tmemcpy(state->stateid.data, deleg_stateid->data, sizeof(state->stateid.data));\n\t\tset_bit(NFS_DELEGATED_STATE, &state->flags);\n\t}\n\tif (open_stateid != NULL)\n\t\tnfs_set_open_stateid_locked(state, open_stateid, open_flags);\n\twrite_sequnlock(&state->seqlock);\n\tspin_lock(&state->owner->so_lock);\n\tupdate_open_stateflags(state, open_flags);\n\tspin_unlock(&state->owner->so_lock);\n}", "target": 1}
{"code": "void CLASS bad_pixels (const char *cfname)\n{\n  FILE *fp=NULL;\n#ifndef LIBRAW_LIBRARY_BUILD\n  char *fname, *cp, line[128];\n  int len, time, row, col, r, c, rad, tot, n, fixed=0;\n#else\n  char *cp, line[128];\n  int time, row, col, r, c, rad, tot, n;\n#ifdef DCRAW_VERBOSE\n  int fixed = 0;\n#endif\n#endif\n  if (!filters) return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,0,2);\n#endif\n  if (cfname)\n    fp = fopen (cfname, \"r\");\n#line 4151 \"dcraw/dcraw.c\"\n  if (!fp)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_BADPIXELMAP;\n#endif\n          return;\n      }\n  while (fgets (line, 128, fp)) {\n    cp = strchr (line, '#');\n    if (cp) *cp = 0;\n    if (sscanf (line, \"%d %d %d\", &col, &row, &time) != 3) continue;\n    if ((unsigned) col >= width || (unsigned) row >= height) continue;\n    if (time > timestamp) continue;\n    for (tot=n=0, rad=1; rad < 3 && n==0; rad++)\n      for (r = row-rad; r <= row+rad; r++)\n\tfor (c = col-rad; c <= col+rad; c++)\n\t  if ((unsigned) r < height && (unsigned) c < width &&\n\t\t(r != row || c != col) && fcol(r,c) == fcol(row,col)) {\n\t    tot += BAYER2(r,c);\n\t    n++;\n\t  }\n    BAYER2(row,col) = tot/n;\n#ifdef DCRAW_VERBOSE\n    if (verbose) {\n      if (!fixed++)\n\tfprintf (stderr,_(\"Fixed dead pixels at:\"));\n      fprintf (stderr, \" %d,%d\", col, row);\n    }\n#endif\n  }\n#ifdef DCRAW_VERBOSE\n  if (fixed) fputc ('\\n', stderr);\n#endif\n  fclose (fp);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,1,2);\n#endif\n}", "target": 1}
{"code": "void nf_tables_unbind_set(const struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t  struct nft_set_binding *binding)\n{\n\tlist_del_rcu(&binding->list);\n\tif (list_empty(&set->bindings) && set->flags & NFT_SET_ANONYMOUS &&\n\t    !(set->flags & NFT_SET_INACTIVE))\n\t\tnf_tables_set_destroy(ctx, set);\n}", "target": 0}
{"code": "static void __reg_deduce_bounds(struct bpf_reg_state *reg)\n{\n\t__reg32_deduce_bounds(reg);\n\t__reg64_deduce_bounds(reg);\n}", "target": 0}
{"code": "static inline bool cpu_has_vmx_ple(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_PAUSE_LOOP_EXITING;\n}", "target": 0}
{"code": "slhc_free(struct slcompress *comp)\n{\n  printk(KERN_DEBUG \"Called IP function on non IP-system: slhc_free\");\n}", "target": 0}
{"code": "static int __tipc_nl_compat_dumpit(struct tipc_nl_compat_cmd_dump *cmd,\n\t\t\t\t   struct tipc_nl_compat_msg *msg,\n\t\t\t\t   struct sk_buff *arg)\n{\n\tint len = 0;\n\tint err;\n\tstruct sk_buff *buf;\n\tstruct nlmsghdr *nlmsg;\n\tstruct netlink_callback cb;\n\tmemset(&cb, 0, sizeof(cb));\n\tcb.nlh = (struct nlmsghdr *)arg->data;\n\tcb.skb = arg;\n\tbuf = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tbuf->sk = msg->dst_sk;\n\tdo {\n\t\tint rem;\n\t\tlen = (*cmd->dumpit)(buf, &cb);\n\t\tnlmsg_for_each_msg(nlmsg, nlmsg_hdr(buf), len, rem) {\n\t\t\tstruct nlattr **attrs;\n\t\t\terr = tipc_nlmsg_parse(nlmsg, &attrs);\n\t\t\tif (err)\n\t\t\t\tgoto err_out;\n\t\t\terr = (*cmd->format)(msg, attrs);\n\t\t\tif (err)\n\t\t\t\tgoto err_out;\n\t\t\tif (tipc_skb_tailroom(msg->rep) <= 1) {\n\t\t\t\terr = -EMSGSIZE;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t}\n\t\tskb_reset_tail_pointer(buf);\n\t\tbuf->len = 0;\n\t} while (len);\n\terr = 0;\nerr_out:\n\tkfree_skb(buf);\n\tif (err == -EMSGSIZE) {\n\t\tif ((TIPC_SKB_MAX - msg->rep->len) <= 1) {\n\t\t\tchar *tail = skb_tail_pointer(msg->rep);\n\t\t\tif (*tail != '\\0')\n\t\t\t\tsprintf(tail - sizeof(REPLY_TRUNCATED) - 1,\n\t\t\t\t\tREPLY_TRUNCATED);\n\t\t}\n\t\treturn 0;\n\t}\n\treturn err;\n}", "target": 0}
{"code": "static int __netdev_printk(const char *level, const struct net_device *dev,\n\t\t\t   struct va_format *vaf)\n{\n\tint r;\n\tif (dev && dev->dev.parent)\n\t\tr = dev_printk(level, dev->dev.parent, \"%s: %pV\",\n\t\t\t       netdev_name(dev), vaf);\n\telse if (dev)\n\t\tr = printk(\"%s%s: %pV\", level, netdev_name(dev), vaf);\n\telse\n\t\tr = printk(\"%s(NULL net_device): %pV\", level, vaf);\n\treturn r;\n}", "target": 0}
{"code": "static void scsi_dma_restart_bh(void *opaque)\n{\n    SCSIDiskState *s = opaque;\n    SCSIRequest *req;\n    SCSIDiskReq *r;\n    qemu_bh_delete(s->bh);\n    s->bh = NULL;\n    QTAILQ_FOREACH(req, &s->qdev.requests, next) {\n        r = DO_UPCAST(SCSIDiskReq, req, req);\n        if (r->status & SCSI_REQ_STATUS_RETRY) {\n            int status = r->status;\n            int ret;\n            r->status &=\n                ~(SCSI_REQ_STATUS_RETRY | SCSI_REQ_STATUS_RETRY_TYPE_MASK);\n            switch (status & SCSI_REQ_STATUS_RETRY_TYPE_MASK) {\n            case SCSI_REQ_STATUS_RETRY_READ:\n                scsi_read_data(&r->req);\n                break;\n            case SCSI_REQ_STATUS_RETRY_WRITE:\n                scsi_write_data(&r->req);\n                break;\n            case SCSI_REQ_STATUS_RETRY_FLUSH:\n                ret = scsi_disk_emulate_command(r, r->iov.iov_base);\n                if (ret == 0) {\n                    scsi_req_complete(&r->req, GOOD);\n                }\n            }\n        }\n    }\n}", "target": 1}
{"code": "static int mailimf_group_parse(const char * message, size_t length,\n\t\t\t       size_t * indx,\n\t\t\t       struct mailimf_group ** result)\n{\n  size_t cur_token;\n  char * display_name;\n  struct mailimf_mailbox_list * mailbox_list;\n  struct mailimf_group * group;\n  int r;\n  int res;\n  clist * list;\n  cur_token = * indx;\n  mailbox_list = NULL;\n  r = mailimf_display_name_parse(message, length, &cur_token, &display_name);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_display_name;\n  }\n  r = mailimf_mailbox_list_parse(message, length, &cur_token, &mailbox_list);\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    break;\n  case MAILIMF_ERROR_PARSE:\n    r = mailimf_cfws_parse(message, length, &cur_token);\n    if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n      res = r;\n      goto free_display_name;\n    }\n    list = clist_new();\n    if (list == NULL) {\n      res = MAILIMF_ERROR_MEMORY;\n      goto free_display_name;\n    }\n    mailbox_list = mailimf_mailbox_list_new(list);\n    if (mailbox_list == NULL) {\n      res = MAILIMF_ERROR_MEMORY;\n      clist_free(list);\n      goto free_display_name;\n    }\n    break;\n  default:\n    res = r;\n    goto free_display_name;\n  }\n  r = mailimf_semi_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_mailbox_list;\n  }\n  group = mailimf_group_new(display_name, mailbox_list);\n  if (group == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_mailbox_list;\n  }\n  * indx = cur_token;\n  * result = group;\n  return MAILIMF_NO_ERROR;\n free_mailbox_list:\n  if (mailbox_list != NULL) {\n    mailimf_mailbox_list_free(mailbox_list);\n  }\n free_display_name:\n  mailimf_display_name_free(display_name);\n err:\n  return res;\n}", "target": 0}
{"code": "add_serials(struct deltas_head *deltas, ...)\n{\n\tstruct delta_head delta;\n\tva_list vl;\n\tdoc_data_init(&delta.doc_data);\n\tva_start(vl, deltas);\n\twhile ((delta.serial = va_arg(vl, unsigned long)) != END)\n\t\tck_assert_int_eq(0, deltas_head_add(deltas, &delta));\n\tva_end(vl);\n}", "target": 0}
{"code": "__attribute__((__always_inline__)) static inline void create_v4_hdr(\n    struct iphdr* iph,\n    __u8 tos,\n    __u32 saddr,\n    __u32 daddr,\n    __u16 pkt_bytes,\n    __u8 proto) {\n  __u64 csum = 0;\n  iph->version = 4;\n  iph->ihl = 5;\n  iph->frag_off = 0;\n  iph->protocol = proto;\n  iph->check = 0;\n#ifdef COPY_INNER_PACKET_TOS\n  iph->tos = tos;\n#else\n  iph->tos = DEFAULT_TOS;\n#endif\n  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));\n  iph->id = 0;\n  iph->daddr = daddr;\n  iph->saddr = saddr;\n  iph->ttl = DEFAULT_TTL;\n  ipv4_csum_inline(iph, &csum);\n  iph->check = csum;\n}", "target": 0}
{"code": "static int CFScanDump_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    RedisModule_AutoMemory(ctx);\n    if (argc != 3) {\n        return RedisModule_WrongArity(ctx);\n    }\n    long long pos;\n    if (RedisModule_StringToLongLong(argv[2], &pos) != REDISMODULE_OK) {\n        return RedisModule_ReplyWithError(ctx, \"Invalid position\");\n    }\n    RedisModuleKey *key = RedisModule_OpenKey(ctx, argv[1], REDISMODULE_READ);\n    CuckooFilter *cf;\n    int status = cfGetFilter(key, &cf);\n    if (status != SB_OK) {\n        return RedisModule_ReplyWithError(ctx, statusStrerror(status));\n    }\n    RedisModule_ReplyWithArray(ctx, 2);\n    if (!cf->numItems) {\n        RedisModule_ReplyWithLongLong(ctx, 0);\n        RedisModule_ReplyWithNull(ctx);\n        return REDISMODULE_OK;\n    }\n    if (pos == 0) {\n        CFHeader header;\n        fillCFHeader(&header, cf);\n        RedisModule_ReplyWithLongLong(ctx, 1);\n        RedisModule_ReplyWithStringBuffer(ctx, (const char *)&header, sizeof header);\n        return REDISMODULE_OK;\n    }\n    size_t chunkLen = 0;\n    const char *chunk = CF_GetEncodedChunk(cf, &pos, &chunkLen, MAX_SCANDUMP_SIZE);\n    if (chunk == NULL) {\n        RedisModule_ReplyWithLongLong(ctx, 0);\n        RedisModule_ReplyWithNull(ctx);\n    } else {\n        RedisModule_ReplyWithLongLong(ctx, pos);\n        RedisModule_ReplyWithStringBuffer(ctx, chunk, chunkLen);\n    }\n    return REDISMODULE_OK;\n}", "target": 1}
{"code": "enum ImapAuthRes imap_auth_cram_md5(struct ImapData *idata, const char *method)\n{\n  char ibuf[LONG_STRING * 2], obuf[LONG_STRING];\n  unsigned char hmac_response[MD5_DIGEST_LEN];\n  int len;\n  int rc;\n  if (!mutt_bit_isset(idata->capabilities, ACRAM_MD5))\n    return IMAP_AUTH_UNAVAIL;\n  mutt_message(_(\"Authenticating (CRAM-MD5)...\"));\n  if (mutt_account_getlogin(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n  if (mutt_account_getpass(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n  imap_cmd_start(idata, \"AUTHENTICATE CRAM-MD5\");\n  do\n    rc = imap_cmd_step(idata);\n  while (rc == IMAP_CMD_CONTINUE);\n  if (rc != IMAP_CMD_RESPOND)\n  {\n    mutt_debug(1, \"Invalid response from server: %s\\n\", ibuf);\n    goto bail;\n  }\n  len = mutt_b64_decode(obuf, idata->buf + 2);\n  if (len == -1)\n  {\n    mutt_debug(1, \"Error decoding base64 response.\\n\");\n    goto bail;\n  }\n  obuf[len] = '\\0';\n  mutt_debug(2, \"CRAM challenge: %s\\n\", obuf);\n  hmac_md5(idata->conn->account.pass, obuf, hmac_response);\n  int off = snprintf(obuf, sizeof(obuf), \"%s \", idata->conn->account.user);\n  mutt_md5_toascii(hmac_response, obuf + off);\n  mutt_debug(2, \"CRAM response: %s\\n\", obuf);\n  mutt_b64_encode(ibuf, obuf, strlen(obuf), sizeof(ibuf) - 2);\n  mutt_str_strcat(ibuf, sizeof(ibuf), \"\\r\\n\");\n  mutt_socket_send(idata->conn, ibuf);\n  do\n    rc = imap_cmd_step(idata);\n  while (rc == IMAP_CMD_CONTINUE);\n  if (rc != IMAP_CMD_OK)\n  {\n    mutt_debug(1, \"Error receiving server response.\\n\");\n    goto bail;\n  }\n  if (imap_code(idata->buf))\n    return IMAP_AUTH_SUCCESS;\nbail:\n  mutt_error(_(\"CRAM-MD5 authentication failed.\"));\n  return IMAP_AUTH_FAILURE;\n}", "target": 1}
{"code": "void pdf_get_version(FILE *fp, pdf_t *pdf)\n{\n    char *header, *c;\n    header = get_header(fp);\n    if ((c = strstr(header, \"%PDF-\")) && \n        (c + strlen(\"%PDF-M.m\") + 2))\n    {\n        pdf->pdf_major_version = atoi(c + strlen(\"%PDF-\"));\n        pdf->pdf_minor_version = atoi(c + strlen(\"%PDF-M.\"));\n    }\n    free(header);\n}", "target": 1}
{"code": "ConnectToRFBServer(rfbClient* client,const char *hostname, int port)\n{\n  if (client->serverPort==-1) {\n    const char* magic=\"vncLog0.0\";\n    char buffer[10];\n    rfbVNCRec* rec = (rfbVNCRec*)malloc(sizeof(rfbVNCRec));\n    client->vncRec = rec;\n    rec->file = fopen(client->serverHost,\"rb\");\n    rec->tv.tv_sec = 0;\n    rec->readTimestamp = FALSE;\n    rec->doNotSleep = FALSE;\n    if (!rec->file) {\n      rfbClientLog(\"Could not open %s.\\n\",client->serverHost);\n      return FALSE;\n    }\n    setbuf(rec->file,NULL);\n    if (fread(buffer,1,strlen(magic),rec->file) != strlen(magic) || strncmp(buffer,magic,strlen(magic))) {\n      rfbClientLog(\"File %s was not recorded by vncrec.\\n\",client->serverHost);\n      fclose(rec->file);\n      return FALSE;\n    }\n    client->sock = -1;\n    return TRUE;\n  }\n#ifndef WIN32\n  if(IsUnixSocket(hostname))\n    client->sock = ConnectClientToUnixSock(hostname);\n  else\n#endif\n  {\n#ifdef LIBVNCSERVER_IPv6\n    client->sock = ConnectClientToTcpAddr6(hostname, port);\n    if (client->sock == -1)\n#endif\n    {\n      unsigned int host;\n      if (!StringToIPAddr(hostname, &host)) {\n        rfbClientLog(\"Couldn't convert '%s' to host address\\n\", hostname);\n        return FALSE;\n      }\n      client->sock = ConnectClientToTcpAddr(host, port);\n    }\n  }\n  if (client->sock < 0) {\n    rfbClientLog(\"Unable to connect to VNC server\\n\");\n    return FALSE;\n  }\n  if(client->QoS_DSCP && !SetDSCP(client->sock, client->QoS_DSCP))\n     return FALSE;\n  return SetNonBlocking(client->sock);\n}", "target": 0}
{"code": "test_string_escape (void)\n{\n  gsize idx;\n  for (idx = 0; idx < G_N_ELEMENTS (escapes); idx++)\n    {\n      EscapeData *data = &escapes[idx];\n      g_autofree char *ret = NULL;\n      ret = flatpak_escape_string (data->in, data->flags);\n      g_assert_cmpstr (ret, ==, data->out);\n    }\n}", "target": 0}
{"code": "size_t _process_request_next_key(mcp_parser_t *pr) {\n    const char *cur = pr->request + pr->parsed;\n    int remain = pr->reqlen - pr->parsed - 2;\n    while (remain) {\n        if (*cur == ' ') {\n            remain--;\n            cur++;\n            pr->parsed++;\n        } else {\n            break;\n        }\n    }\n    const char *s = memchr(cur, ' ', remain);\n    if (s != NULL) {\n        pr->klen = s - cur;\n        pr->parsed += s - cur;\n    } else {\n        pr->klen = remain;\n        pr->parsed += remain;\n    }\n    return cur - pr->request;\n}", "target": 1}
{"code": "static void php_html_entities(INTERNAL_FUNCTION_PARAMETERS, int all)\n{\n\tchar *str, *hint_charset = NULL;\n\tint str_len, hint_charset_len = 0;\n\tsize_t new_len;\n\tlong flags = ENT_COMPAT;\n\tchar *replaced;\n\tzend_bool double_encode = 1;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|ls!b\", &str, &str_len, &flags, &hint_charset, &hint_charset_len, &double_encode) == FAILURE) {\n\t\treturn;\n\t}\n\treplaced = php_escape_html_entities_ex(str, str_len, &new_len, all, (int) flags, hint_charset, double_encode TSRMLS_CC);\n\tif (new_len > INT_MAX) {\n\t\tefree(replaced);\n\t\tRETURN_FALSE;\n\t}\n\tRETVAL_STRINGL(replaced, (int)new_len, 0);\n}", "target": 0}
{"code": "static void icmp_reply(struct icmp_bxm *icmp_param, struct sk_buff *skb)\n{\n\tstruct ipcm_cookie ipc;\n\tstruct rtable *rt = skb_rtable(skb);\n\tstruct net *net = dev_net(rt->dst.dev);\n\tstruct sock *sk;\n\tstruct inet_sock *inet;\n\t__be32 daddr;\n\tif (ip_options_echo(&icmp_param->replyopts, skb))\n\t\treturn;\n\tsk = icmp_xmit_lock(net);\n\tif (sk == NULL)\n\t\treturn;\n\tinet = inet_sk(sk);\n\ticmp_param->data.icmph.checksum = 0;\n\tinet->tos = ip_hdr(skb)->tos;\n\tdaddr = ipc.addr = rt->rt_src;\n\tipc.opt = NULL;\n\tipc.tx_flags = 0;\n\tif (icmp_param->replyopts.optlen) {\n\t\tipc.opt = &icmp_param->replyopts;\n\t\tif (ipc.opt->srr)\n\t\t\tdaddr = icmp_param->replyopts.faddr;\n\t}\n\t{\n\t\tstruct flowi4 fl4 = {\n\t\t\t.daddr = daddr,\n\t\t\t.saddr = rt->rt_spec_dst,\n\t\t\t.flowi4_tos = RT_TOS(ip_hdr(skb)->tos),\n\t\t\t.flowi4_proto = IPPROTO_ICMP,\n\t\t};\n\t\tsecurity_skb_classify_flow(skb, flowi4_to_flowi(&fl4));\n\t\trt = ip_route_output_key(net, &fl4);\n\t\tif (IS_ERR(rt))\n\t\t\tgoto out_unlock;\n\t}\n\tif (icmpv4_xrlim_allow(net, rt, icmp_param->data.icmph.type,\n\t\t\t       icmp_param->data.icmph.code))\n\t\ticmp_push_reply(icmp_param, &ipc, &rt);\n\tip_rt_put(rt);\nout_unlock:\n\ticmp_xmit_unlock(sk);\n}", "target": 1}
{"code": "static const char* get_av_pair_string(UINT16 pair)\n{\n\tswitch (pair)\n\t{\n\t\tcase MsvAvEOL:\n\t\t\treturn \"MsvAvEOL\";\n\t\tcase MsvAvNbComputerName:\n\t\t\treturn \"MsvAvNbComputerName\";\n\t\tcase MsvAvNbDomainName:\n\t\t\treturn \"MsvAvNbDomainName\";\n\t\tcase MsvAvDnsComputerName:\n\t\t\treturn \"MsvAvDnsComputerName\";\n\t\tcase MsvAvDnsDomainName:\n\t\t\treturn \"MsvAvDnsDomainName\";\n\t\tcase MsvAvDnsTreeName:\n\t\t\treturn \"MsvAvDnsTreeName\";\n\t\tcase MsvAvFlags:\n\t\t\treturn \"MsvAvFlags\";\n\t\tcase MsvAvTimestamp:\n\t\t\treturn \"MsvAvTimestamp\";\n\t\tcase MsvAvSingleHost:\n\t\t\treturn \"MsvAvSingleHost\";\n\t\tcase MsvAvTargetName:\n\t\t\treturn \"MsvAvTargetName\";\n\t\tcase MsvChannelBindings:\n\t\t\treturn \"MsvChannelBindings\";\n\t\tdefault:\n\t\t\treturn \"UNKNOWN\";\n\t}\n}", "target": 0}
{"code": "header_put_le_3byte (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 3)\n\t{\tpsf->header [psf->headindex++] = x ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\t} ;\n} ", "target": 1}
{"code": "static gboolean restart_dhcp_timeout(gpointer user_data)\n{\n\tGDHCPClient *dhcp_client = user_data;\n\tdebug(dhcp_client, \"restart DHCP timeout\");\n\tif (dhcp_client->state == REBOOTING) {\n\t\tg_free(dhcp_client->last_address);\n\t\tdhcp_client->last_address = NULL;\n\t\trestart_dhcp(dhcp_client, 0);\n\t} else {\n\t\tdhcp_client->ack_retry_times++;\n\t\trestart_dhcp(dhcp_client, dhcp_client->ack_retry_times);\n\t}\n\treturn FALSE;\n}", "target": 0}
{"code": "int btrfs_scrub_progress(struct btrfs_fs_info *fs_info, u64 devid,\n\t\t\t struct btrfs_scrub_progress *progress)\n{\n\tstruct btrfs_device *dev;\n\tstruct scrub_ctx *sctx = NULL;\n\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL);\n\tif (dev)\n\t\tsctx = dev->scrub_ctx;\n\tif (sctx)\n\t\tmemcpy(progress, &sctx->stat, sizeof(*progress));\n\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\treturn dev ? (sctx ? 0 : -ENOTCONN) : -ENODEV;\n}", "target": 1}
{"code": "static int umocktypes_are_equal_FLOW_HANDLE(FLOW_HANDLE* left, FLOW_HANDLE* right)\n{\n    int result;\n    if (*left == *right)\n    {\n        result = 1;\n    }\n    else\n    {\n        result = 0;\n    }\n    return result;\n}", "target": 0}
{"code": "void SslSPIFFECertValidatorIntegrationTest::addStringMatcher(\n    const envoy::type::matcher::v3::StringMatcher& matcher) {\n  san_matchers_.emplace_back();\n  *san_matchers_.back().mutable_matcher() = matcher;\n  san_matchers_.back().set_san_type(\n      envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::DNS);\n  san_matchers_.emplace_back();\n  *san_matchers_.back().mutable_matcher() = matcher;\n  san_matchers_.back().set_san_type(\n      envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::URI);\n  san_matchers_.emplace_back();\n  *san_matchers_.back().mutable_matcher() = matcher;\n  san_matchers_.back().set_san_type(\n      envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::EMAIL);\n  san_matchers_.emplace_back();\n  *san_matchers_.back().mutable_matcher() = matcher;\n  san_matchers_.back().set_san_type(\n      envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::IP_ADDRESS);\n}", "target": 0}
{"code": "        int    ReadDoubleArray(unsigned char *sString, int nLen, double (&pArray)[nMax])\n        {\n            int nStart = 0;\n            while( sString[nStart] != '[' )\n            {\n                nStart++;\n                if ( nStart >= nLen )\n                    return 0;\n            }\n            int nEnd = ++nStart;\n            while ( sString[nEnd] != ']' )\n            {\n                nEnd++;\n                if ( nEnd >= nLen )\n                    return 0;\n            }\n            sString = sString + nStart;\n            nLen    = nEnd - nStart;\n            int nCount = 0;\n            const int c_nNumLimit = 32;\n            unsigned char sBuffer[c_nNumLimit];\n            int nBufPos = 0;\n            bool bNewItem = true;\n            for ( int nIndex = 0; nIndex < nLen; ++nIndex )\n            {\n                unsigned char unChar = sString[nIndex];\n                if ( ' ' == unChar )\n                {\n                    if ( !bNewItem )\n                        bNewItem = true;\n                    continue;\n                }\n                if ( bNewItem )\n                {\n                    if ( nCount >= nMax )\n                        break;\n                    if ( nCount > 0 )\n                        pArray[nCount - 1] = Utils::GetDouble( (const char *)sBuffer );\n                    memset( sBuffer, 0x00, c_nNumLimit );\n                    nBufPos = 0;\n                    bNewItem = false;\n                    nCount++;\n                }\n                sBuffer[nBufPos++] = unChar;\n                if (nBufPos >= c_nNumLimit)\n                    break;\n            }\n            if ( 0 != sBuffer[0] && nCount > 0 )\n                pArray[nCount - 1] = Utils::GetDouble( (const char *)sBuffer );\n            return nCount;\n        }", "target": 0}
{"code": "MONGO_EXPORT int bson_append_code_w_scope_n( bson *b, const char *name,\n        const char *code, int len, const bson *scope ) {\n    int sl, size;\n    if ( !scope ) return BSON_ERROR;\n    sl = len + 1;\n    size = 4 + 4 + sl + bson_size( scope );\n    if ( bson_append_estart( b, BSON_CODEWSCOPE, name, size ) == BSON_ERROR )\n        return BSON_ERROR;\n    bson_append32( b, &size );\n    bson_append32( b, &sl );\n    bson_append( b, code, sl );\n    bson_append( b, scope->data, bson_size( scope ) );\n    return BSON_OK;\n}", "target": 1}
{"code": "\tconsume_count(type)\n\t\tconst char **type;\n{\n\tint count = 0;\n\tif (!isdigit((unsigned char)**type))\n\t\treturn -1;\n\twhile (isdigit((unsigned char)**type)) {\n\t\tcount *= 10;\n\t\tif ((count % 10) != 0) {\n\t\t\twhile (isdigit((unsigned char)**type))\n\t\t\t\t(*type)++;\n\t\t\treturn -1;\n\t\t}\n\t\tcount += **type - '0';\n\t\t(*type)++;\n\t}\n\treturn (count);\n}", "target": 1}
{"code": "int CLua::loadfile(lua_State *ls, const char *filename, bool trusted,\n                   bool die_on_fail)\n{\n    if (!ls)\n        return -1;\n    if (!is_path_safe(filename, trusted))\n    {\n        lua_pushstring(\n            ls,\n            make_stringf(\"invalid filename: %s\", filename).c_str());\n        return -1;\n    }\n    string file = datafile_path(filename, die_on_fail);\n    if (file.empty())\n    {\n        lua_pushstring(ls,\n                       make_stringf(\"Can't find \\\"%s\\\"\", filename).c_str());\n        return -1;\n    }\n    FileLineInput f(file.c_str());\n    string script;\n    while (!f.eof())\n        script += f.get_line() + \"\\n\";\n    if (script[0] == 0x1b)\n        abort();\n    return luaL_loadbuffer(ls, &script[0], script.length(),\n                           (\"@\" + file).c_str());\n}", "target": 0}
{"code": "NCR_ModifyMaxdelay(NCR_Instance inst, double new_max_delay)\n{\n  inst->max_delay = new_max_delay;\n  LOG(LOGS_INFO, LOGF_NtpCore, \"Source %s new max delay %f\",\n      UTI_IPToString(&inst->remote_addr.ip_addr), new_max_delay);\n}", "target": 0}
{"code": "ApplyChannelMatrix::~ApplyChannelMatrix()\n{\n\tdelete [] m_matrix;\n}", "target": 0}
{"code": "static int tipc_nl_compat_link_dump(struct tipc_nl_compat_msg *msg,\n\t\t\t\t    struct nlattr **attrs)\n{\n\tstruct nlattr *link[TIPC_NLA_LINK_MAX + 1];\n\tstruct tipc_link_info link_info;\n\tint err;\n\tif (!attrs[TIPC_NLA_LINK])\n\t\treturn -EINVAL;\n\terr = nla_parse_nested(link, TIPC_NLA_LINK_MAX, attrs[TIPC_NLA_LINK],\n\t\t\t       NULL);\n\tif (err)\n\t\treturn err;\n\tlink_info.dest = nla_get_flag(link[TIPC_NLA_LINK_DEST]);\n\tlink_info.up = htonl(nla_get_flag(link[TIPC_NLA_LINK_UP]));\n\tstrcpy(link_info.str, nla_data(link[TIPC_NLA_LINK_NAME]));\n\treturn tipc_add_tlv(msg->rep, TIPC_TLV_LINK_INFO,\n\t\t\t    &link_info, sizeof(link_info));\n}", "target": 1}
{"code": "crm_recv_remote_ready(void *session, gboolean encrypted, int timeout )\n{\n    struct pollfd fds = { 0, };\n    int sock = 0;\n    void *sock_ptr = NULL;\n    int rc = 0;\n    time_t start;\n    if (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        gnutls_session *tls_session = session;\n        sock_ptr = gnutls_transport_get_ptr(*tls_session);\n#else\n        CRM_ASSERT(encrypted == FALSE);\n#endif\n    } else {\n        sock_ptr = session;\n    }\n    sock = GPOINTER_TO_INT(sock_ptr);\n    if (sock <= 0) {\n        return -ENOTCONN;\n    }\n    start = time(NULL);\n    errno = 0;\n    do {\n        fds.fd = sock;\n        fds.events = POLLIN;\n        if (errno == EINTR && (timeout > 0)) {\n            timeout = timeout - ((time(NULL) - start) * 1000);\n            if (timeout < 1000) {\n                timeout = 1000;\n            }\n        }\n        rc = poll(&fds, 1, timeout);\n    } while (rc < 0 && errno == EINTR);\n    return rc;\n}", "target": 0}
{"code": "bool CmdExtract::ExtractFileCopy(File &New,wchar *ArcName,const wchar *RedirName,wchar *NameNew,wchar *NameExisting,size_t NameExistingSize,int64 UnpSize)\n{\n  SlashToNative(NameExisting,NameExisting,NameExistingSize); \n  File Existing;\n  if (!Existing.Open(NameExisting))\n  {\n    bool OpenFailed=true;\n    for (size_t I=0;I<RefList.Size();I++)\n      if (wcscmp(RedirName,RefList[I].RefName)==0 && RefList[I].TmpName!=NULL)\n      {\n        bool RefMove=RefList[I].RefCount-- == 1;\n        NameExisting=RefList[I].TmpName;\n        if (RefMove) \n        {\n          New.Delete(); \n          bool MoveFailed=!RenameFile(NameExisting,NameNew);\n          if (MoveFailed)\n          {\n            if (!New.WCreate(NameNew,FMF_WRITE|FMF_SHAREREAD))\n              return false;\n            RefMove=false; \n          }\n          else\n          {\n            if (New.Open(NameNew))\n              New.Seek(0,SEEK_END);\n            free(RefList[I].TmpName);\n            RefList[I].TmpName=NULL;\n            return true;\n          }\n        }\n        if (!RefMove)\n          OpenFailed=!Existing.Open(NameExisting);\n        break;\n      }\n    if (OpenFailed)\n    {\n      ErrHandler.OpenErrorMsg(NameExisting);\n      uiMsg(UIERROR_FILECOPY,ArcName,NameExisting,NameNew);\n      uiMsg(UIERROR_FILECOPYHINT,ArcName);\n#ifdef RARDLL\n      Cmd->DllError=ERAR_EREFERENCE;\n#endif\n      return false;\n    }\n  }\n  Array<byte> Buffer(0x100000);\n  int64 CopySize=0;\n  while (true)\n  {\n    Wait();\n    int ReadSize=Existing.Read(&Buffer[0],Buffer.Size());\n    if (ReadSize==0)\n      break;\n    uiExtractProgress(CopySize,UnpSize,0,0);\n    New.Write(&Buffer[0],ReadSize);\n    CopySize+=ReadSize;\n  }\n  return true;\n}", "target": 1}
{"code": "static unsigned short get_tga_ushort(const unsigned char *data)\n{\n    return data[0] | (data[1] << 8);\n}", "target": 0}
{"code": "void Browser::RendererUnresponsive(\n    WebContents* source,\n    const content::WebContentsUnresponsiveState& unresponsive_state) {\n  int index = tab_strip_model_->GetIndexOfWebContents(source);\n  DCHECK_NE(TabStripModel::kNoTab, index);\n  if (tab_strip_model_->IsTabBlocked(index))\n    return;\n  TabDialogs::FromWebContents(source)->ShowHungRendererDialog(\n      unresponsive_state);\n}", "target": 0}
{"code": "int crypto_reportstat(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,\n\t\t      struct nlattr **attrs)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct crypto_user_alg *p = nlmsg_data(in_nlh);\n\tstruct crypto_alg *alg;\n\tstruct sk_buff *skb;\n\tstruct crypto_dump_info info;\n\tint err;\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\talg = crypto_alg_match(p, 0);\n\tif (!alg)\n\t\treturn -ENOENT;\n\terr = -ENOMEM;\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto drop_alg;\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = in_nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = 0;\n\terr = crypto_reportstat_alg(alg, &info);\ndrop_alg:\n\tcrypto_mod_put(alg);\n\tif (err)\n\t\treturn err;\n\treturn nlmsg_unicast(net->crypto_nlsk, skb, NETLINK_CB(in_skb).portid);\n}", "target": 1}
{"code": "static inline struct htx_blk *htx_add_header(struct htx *htx, const struct ist name,\n\t\t\t\t\t     const struct ist value)\n{\n\tstruct htx_blk *blk;\n\tblk = htx_add_blk(htx, HTX_BLK_HDR, name.len + value.len);\n\tif (!blk)\n\t\treturn NULL;\n\tblk->info += (value.len << 8) + name.len;\n\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\n\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\n\treturn blk;\n}", "target": 1}
{"code": "ZEND_API char* ZEND_FASTCALL zend_str_tolower_copy(char *dest, const char *source, size_t length) \n{\n\tregister unsigned char *str = (unsigned char*)source;\n\tregister unsigned char *result = (unsigned char*)dest;\n\tregister unsigned char *end = str + length;\n\twhile (str < end) {\n\t\t*result++ = zend_tolower_ascii(*str++);\n\t}\n\t*result = '\\0';\n\treturn dest;\n}", "target": 0}
{"code": "static void php_zip_get_from(INTERNAL_FUNCTION_PARAMETERS, int type) \n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tstruct zip_stat sb;\n\tstruct zip_file *zf;\n\tzend_long index = -1;\n\tzend_long flags = 0;\n\tzend_long len = 0;\n\tzend_string *filename;\n\tzend_string *buffer;\n\tint n = 0;\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\tZIP_FROM_OBJECT(intern, self);\n\tif (type == 1) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|ll\", &filename, &len, &flags) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t\tPHP_ZIP_STAT_PATH(intern, ZSTR_VAL(filename), ZSTR_LEN(filename), flags, sb);\n\t} else {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l|ll\", &index, &len, &flags) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t\tPHP_ZIP_STAT_INDEX(intern, index, 0, sb);\n\t}\n\tif (sb.size < 1) {\n\t\tRETURN_EMPTY_STRING();\n\t}\n\tif (len < 1) {\n\t\tlen = sb.size;\n\t}\n\tif (index >= 0) {\n\t\tzf = zip_fopen_index(intern, index, flags);\n\t} else {\n\t\tzf = zip_fopen(intern, ZSTR_VAL(filename), flags);\n\t}\n\tif (zf == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tbuffer = zend_string_alloc(len, 0);\n\tn = zip_fread(zf, ZSTR_VAL(buffer), ZSTR_LEN(buffer));\n\tif (n < 1) {\n\t\tzend_string_free(buffer);\n\t\tRETURN_EMPTY_STRING();\n\t}\n\tzip_fclose(zf);\n\tZSTR_VAL(buffer)[n] = '\\0';\n\tZSTR_LEN(buffer) = n;\n\tRETURN_NEW_STR(buffer);\n}", "target": 1}
{"code": "static Jsi_RC WebSocketVersionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    const char *verStr = NULL;\n    verStr = lws_get_library_version();\n    if (verStr) {\n        char buf[100], *cp;\n        snprintf(buf, sizeof(buf), \"%s\", verStr);\n        cp = Jsi_Strchr(buf, ' ');\n        if (cp) *cp = 0;\n        Jsi_ValueMakeStringDup(interp, ret, buf);\n    }\n    return JSI_OK;\n}", "target": 1}
{"code": "int bad_format_axis(char *fmt){\n    return bad_format_check(\"^\" SAFE_STRING FLOAT_STRING SAFE_STRING \"$\",fmt);\n}", "target": 0}
{"code": "xfs_dinode_verify_fork(\n\tstruct xfs_dinode\t*dip,\n\tstruct xfs_mount\t*mp,\n\tint\t\t\twhichfork)\n{\n\tuint32_t\t\tdi_nextents = XFS_DFORK_NEXTENTS(dip, whichfork);\n\tswitch (XFS_DFORK_FORMAT(dip, whichfork)) {\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tif (whichfork == XFS_DATA_FORK) {\n\t\t\tif (S_ISREG(be16_to_cpu(dip->di_mode)))\n\t\t\t\treturn __this_address;\n\t\t\tif (be64_to_cpu(dip->di_size) >\n\t\t\t\t\tXFS_DFORK_SIZE(dip, mp, whichfork))\n\t\t\t\treturn __this_address;\n\t\t}\n\t\tif (di_nextents)\n\t\t\treturn __this_address;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tif (di_nextents > XFS_DFORK_MAXEXT(dip, mp, whichfork))\n\t\t\treturn __this_address;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tif (whichfork == XFS_ATTR_FORK) {\n\t\t\tif (di_nextents > MAXAEXTNUM)\n\t\t\t\treturn __this_address;\n\t\t} else if (di_nextents > MAXEXTNUM) {\n\t\t\treturn __this_address;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn __this_address;\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "ev_archive_read_next_header (EvArchive *archive,\n\t\t\t     GError   **error)\n{\n\tg_return_val_if_fail (EV_IS_ARCHIVE (archive), FALSE);\n\tg_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, FALSE);\n\tswitch (archive->type) {\n\tcase EV_ARCHIVE_TYPE_NONE:\n\t\tg_assert_not_reached ();\n\tcase EV_ARCHIVE_TYPE_RAR:\n\tcase EV_ARCHIVE_TYPE_ZIP:\n\tcase EV_ARCHIVE_TYPE_7Z:\n\tcase EV_ARCHIVE_TYPE_TAR:\n\t\treturn libarchive_read_next_header (archive, error);\n\t}\n\treturn FALSE;\n}", "target": 0}
{"code": "partition_table_create_data_ref (CreatePartitionTableData *data)\n{\n  data->refcount++;\n  return data;\n}", "target": 0}
{"code": "bool deleteFile(const String& path)\n{\n    String filename = path;\n    return !!DeleteFileW(filename.charactersWithNullTermination());\n}", "target": 0}
{"code": "void HTMLSelectElement::setSize(int size)\n{\n    setIntegralAttribute(sizeAttr, size);\n}", "target": 0}
{"code": "Suite *xml_load_suite(void)\n{\n\tSuite *suite;\n\tTCase *validate;\n\tvalidate = tcase_create(\"Validate\");\n\ttcase_add_test(validate, test_deltas_head_sort);\n\tsuite = suite_create(\"xml_test()\");\n\tsuite_add_tcase(suite, validate);\n\treturn suite;\n}", "target": 0}
{"code": "bool EditorClientBlackBerry::shouldApplyStyle(StylePropertySet*, Range*)\n{\n    notImplemented();\n    return true;\n}", "target": 0}
{"code": "    UNZIPLoadParseError(const std::string &msg) : std::runtime_error(msg) { };", "target": 0}
{"code": "static void encode_reclaim_complete(struct xdr_stream *xdr,\n\t\t\t\t    struct nfs41_reclaim_complete_args *args,\n\t\t\t\t    struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_RECLAIM_COMPLETE, decode_reclaim_complete_maxsz, hdr);\n\tencode_uint32(xdr, args->one_fs);\n}", "target": 0}
{"code": "expand_dynamic_string_token (struct link_map *l, const char *s)\n{\n  size_t cnt;\n  size_t total;\n  char *result;\n  cnt = DL_DST_COUNT (s, 1);\n  if (cnt == 0)\n    return local_strdup (s);\n  total = DL_DST_REQUIRED (l, s, strlen (s), cnt);\n  result = (char *) malloc (total + 1);\n  if (result == NULL)\n    return NULL;\n  return DL_DST_SUBSTITUTE (l, s, result, 1);\n}", "target": 1}
{"code": "gs_heap_resize_object(gs_memory_t * mem, void *obj, uint new_num_elements,\n                      client_name_t cname)\n{\n    gs_malloc_memory_t *mmem = (gs_malloc_memory_t *) mem;\n    gs_malloc_block_t *ptr = (gs_malloc_block_t *) obj - 1;\n    gs_memory_type_ptr_t pstype = ptr->type;\n    uint old_size = gs_object_size(mem, obj) + sizeof(gs_malloc_block_t);\n    uint new_size =\n        gs_struct_type_size(pstype) * new_num_elements +\n        sizeof(gs_malloc_block_t);\n    gs_malloc_block_t *new_ptr;\n    if (new_size == old_size)\n        return obj;\n    if (mmem->monitor)\n        gx_monitor_enter(mmem->monitor);\t\n    new_ptr = (gs_malloc_block_t *) gs_realloc(ptr, old_size, new_size);\n    if (new_ptr == 0)\n        return 0;\n    if (new_ptr->prev)\n        new_ptr->prev->next = new_ptr;\n    else\n        mmem->allocated = new_ptr;\n    if (new_ptr->next)\n        new_ptr->next->prev = new_ptr;\n    new_ptr->size = new_size - sizeof(gs_malloc_block_t);\n    mmem->used -= old_size;\n    mmem->used += new_size;\n    if (mmem->monitor)\n        gx_monitor_leave(mmem->monitor);\t\n    if (new_size > old_size)\n        gs_alloc_fill((byte *) new_ptr + old_size,\n                      gs_alloc_fill_alloc, new_size - old_size);\n    return new_ptr + 1;\n}", "target": 0}
{"code": "hybiPayloadStart(ws_ctx_t *wsctx)\n{\n  return wsctx->codeBufDecode + wsctx->header.headerLen;\n}", "target": 0}
{"code": "MagickExport int LocaleLowercase(const int c)\n{\n  if (c == EOF)\n    return(c);\n#if defined(MAGICKCORE_LOCALE_SUPPORT)\n  if (c_locale != (locale_t) NULL)\n    return(tolower_l((int) ((unsigned char) c),c_locale));\n#endif\n  return(tolower((int) ((unsigned char) c)));\n}", "target": 0}
{"code": "static inline bool _arq_scheduled(gnrc_sixlowpan_frag_fb_t *fbuf)\n{\n    evtimer_event_t *ptr = _arq_timer.events;\n    evtimer_event_t *event = &fbuf->sfr.arq_timeout_event.event;\n    while (ptr) {\n        if (ptr == event) {\n            return true;\n        }\n        ptr = ptr->next;\n    }\n    return false;\n}", "target": 0}
{"code": "static int adpt_i2o_activate_hba(adpt_hba* pHba)\n{\n\tint rcode;\n\tif(pHba->initialized ) {\n\t\tif (adpt_i2o_status_get(pHba) < 0) {\n\t\t\tif((rcode = adpt_i2o_reset_hba(pHba)) != 0){\n\t\t\t\tprintk(KERN_WARNING\"%s: Could NOT reset.\\n\", pHba->name);\n\t\t\t\treturn rcode;\n\t\t\t}\n\t\t\tif (adpt_i2o_status_get(pHba) < 0) {\n\t\t\t\tprintk(KERN_INFO \"HBA not responding.\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif(pHba->status_block->iop_state == ADAPTER_STATE_FAULTED) {\n\t\t\tprintk(KERN_CRIT \"%s: hardware fault\\n\", pHba->name);\n\t\t\treturn -1;\n\t\t}\n\t\tif (pHba->status_block->iop_state == ADAPTER_STATE_READY ||\n\t\t    pHba->status_block->iop_state == ADAPTER_STATE_OPERATIONAL ||\n\t\t    pHba->status_block->iop_state == ADAPTER_STATE_HOLD ||\n\t\t    pHba->status_block->iop_state == ADAPTER_STATE_FAILED) {\n\t\t\tadpt_i2o_reset_hba(pHba);\t\t\t\n\t\t\tif (adpt_i2o_status_get(pHba) < 0 || pHba->status_block->iop_state != ADAPTER_STATE_RESET) {\n\t\t\t\tprintk(KERN_ERR \"%s: Failed to initialize.\\n\", pHba->name);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif((rcode = adpt_i2o_reset_hba(pHba)) != 0){\n\t\t\tprintk(KERN_WARNING\"%s: Could NOT reset.\\n\", pHba->name);\n\t\t\treturn rcode;\n\t\t}\n\t}\n\tif (adpt_i2o_init_outbound_q(pHba) < 0) {\n\t\treturn -1;\n\t}\n\tif (adpt_i2o_hrt_get(pHba) < 0) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static inline bool sctp_chunk_pending(const struct sctp_chunk *chunk)\n{\n\treturn !list_empty(&chunk->list);\n}", "target": 0}
{"code": "static void destroy_pit_timer(struct kvm_pit *pit)\n{\n\thrtimer_cancel(&pit->pit_state.timer);\n\tflush_kthread_work(&pit->expired);\n}", "target": 0}
{"code": "hstoreArrayToPairs(ArrayType *a, int *npairs)\n{\n\tDatum\t   *key_datums;\n\tbool\t   *key_nulls;\n\tint\t\t\tkey_count;\n\tPairs\t   *key_pairs;\n\tint\t\t\tbufsiz;\n\tint\t\t\ti,\n\t\t\t\tj;\n\tdeconstruct_array(a,\n\t\t\t\t\t  TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &key_datums, &key_nulls, &key_count);\n\tif (key_count == 0)\n\t{\n\t\t*npairs = 0;\n\t\treturn NULL;\n\t}\n\tif (key_count > MaxAllocSize / sizeof(Pairs))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t  errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t key_count, (int) (MaxAllocSize / sizeof(Pairs)))));\n\tkey_pairs = palloc(sizeof(Pairs) * key_count);\n\tfor (i = 0, j = 0; i < key_count; i++)\n\t{\n\t\tif (!key_nulls[i])\n\t\t{\n\t\t\tkey_pairs[j].key = VARDATA(key_datums[i]);\n\t\t\tkey_pairs[j].keylen = VARSIZE(key_datums[i]) - VARHDRSZ;\n\t\t\tkey_pairs[j].val = NULL;\n\t\t\tkey_pairs[j].vallen = 0;\n\t\t\tkey_pairs[j].needfree = 0;\n\t\t\tkey_pairs[j].isnull = 1;\n\t\t\tj++;\n\t\t}\n\t}\n\t*npairs = hstoreUniquePairs(key_pairs, j, &bufsiz);\n\treturn key_pairs;\n}", "target": 0}
{"code": "bool OSD::ms_verify_authorizer(Connection *con, int peer_type,\n\t\t\t       int protocol, bufferlist& authorizer_data, bufferlist& authorizer_reply,\n\t\t\t       bool& isvalid, CryptoKey& session_key)\n{\n  AuthAuthorizeHandler *authorize_handler = 0;\n  switch (peer_type) {\n  case CEPH_ENTITY_TYPE_MDS:\n  case CEPH_ENTITY_TYPE_OSD:\n  case CEPH_ENTITY_TYPE_MGR:\n    authorize_handler = authorize_handler_cluster_registry->get_handler(protocol);\n    break;\n  default:\n    authorize_handler = authorize_handler_service_registry->get_handler(protocol);\n  }\n  if (!authorize_handler) {\n    dout(0) << \"No AuthAuthorizeHandler found for protocol \" << protocol << dendl;\n    isvalid = false;\n    return true;\n  }\n  AuthCapsInfo caps_info;\n  EntityName name;\n  uint64_t global_id;\n  uint64_t auid = CEPH_AUTH_UID_DEFAULT;\n  RotatingKeyRing *keys = monc->rotating_secrets.get();\n  if (keys) {\n    isvalid = authorize_handler->verify_authorizer(\n      cct, keys,\n      authorizer_data, authorizer_reply, name, global_id, caps_info, session_key,\n      &auid);\n  } else {\n    dout(10) << __func__ << \" no rotating_keys (yet), denied\" << dendl;\n    isvalid = false;\n  }\n  if (isvalid) {\n    Session *s = static_cast<Session *>(con->get_priv());\n    if (!s) {\n      s = new Session(cct);\n      con->set_priv(s->get());\n      s->con = con;\n      dout(10) << \" new session \" << s << \" con=\" << s->con << \" addr=\" << s->con->get_peer_addr() << dendl;\n    }\n    s->entity_name = name;\n    if (caps_info.allow_all)\n      s->caps.set_allow_all();\n    s->auid = auid;\n    if (caps_info.caps.length() > 0) {\n      bufferlist::iterator p = caps_info.caps.begin();\n      string str;\n      try {\n\t::decode(str, p);\n      }\n      catch (buffer::error& e) {\n      }\n      bool success = s->caps.parse(str);\n      if (success)\n\tdout(10) << \" session \" << s << \" \" << s->entity_name << \" has caps \" << s->caps << \" '\" << str << \"'\" << dendl;\n      else\n\tdout(10) << \" session \" << s << \" \" << s->entity_name << \" failed to parse caps '\" << str << \"'\" << dendl;\n    }\n    s->put();\n  }\n  return true;\n}", "target": 1}
{"code": "Variant HHVM_FUNCTION(mcrypt_create_iv, int size, int source ) {\n  if (size <= 0 || size >= INT_MAX) {\n    raise_warning(\"Can not create an IV with a size of less than 1 or \"\n                    \"greater than %d\", INT_MAX);\n    return false;\n  }\n  int n = 0;\n  char *iv = (char*)calloc(size + 1, 1);\n  if (source == RANDOM || source == URANDOM) {\n    int fd = open(source == RANDOM ? \"/dev/random\" : \"/dev/urandom\", O_RDONLY);\n    if (fd < 0) {\n      free(iv);\n      raise_warning(\"Cannot open source device\");\n      return false;\n    }\n    int read_bytes;\n    for (read_bytes = 0; read_bytes < size && n >= 0; read_bytes += n) {\n      n = read(fd, iv + read_bytes, size - read_bytes);\n    }\n    n = read_bytes;\n    close(fd);\n    if (n < size) {\n      free(iv);\n      raise_warning(\"Could not gather sufficient random data\");\n      return false;\n    }\n  } else {\n    n = size;\n    while (size) {\n      iv[--size] = (char)(255.0 * rand() / RAND_MAX);\n    }\n  }\n  return String(iv, n, AttachString);\n}", "target": 1}
{"code": "void Item_cache_row::set_null()\n{\n  Item_cache::set_null();\n  if (!values)\n    return;\n  for (uint i= 0; i < item_count; i++)\n    values[i]->set_null();\n};", "target": 0}
{"code": "ts_date_hmsfrac_print(netdissect_options *ndo, long sec, long usec,\n\t\t      enum date_flag date_flag, enum time_flag time_flag)\n{\n\ttime_t Time = sec;\n\tstruct tm *tm;\n\tchar timestr[32];\n\tif ((unsigned)sec & 0x80000000) {\n\t\tND_PRINT(\"[Error converting time]\");\n\t\treturn;\n\t}\n\tif (time_flag == LOCAL_TIME)\n\t\ttm = localtime(&Time);\n\telse\n\t\ttm = gmtime(&Time);\n\tif (!tm) {\n\t\tND_PRINT(\"[Error converting time]\");\n\t\treturn;\n\t}\n\tif (date_flag == WITH_DATE)\n\t\tstrftime(timestr, sizeof(timestr), \"%Y-%m-%d %H:%M:%S\", tm);\n\telse\n\t\tstrftime(timestr, sizeof(timestr), \"%H:%M:%S\", tm);\n\tND_PRINT(\"%s\", timestr);\n\tts_frac_print(ndo, usec);\n}", "target": 1}
{"code": "SPL_METHOD(SplFileObject, fgets)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tif (spl_filesystem_file_read(intern, 0 TSRMLS_CC) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_STRINGL(intern->u.file.current_line, intern->u.file.current_line_len, 1);\n} ", "target": 0}
{"code": "static int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t   u16 selector, int seg)\n{\n\tu8 cpl = ctxt->ops->cpl(ctxt);\n\tif (seg == VCPU_SREG_SS && selector == 3 &&\n\t    ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn emulate_exception(ctxt, GP_VECTOR, 0, true);\n\treturn __load_segment_descriptor(ctxt, selector, seg, cpl,\n\t\t\t\t\t X86_TRANSFER_NONE, NULL);\n}", "target": 0}
{"code": "static void uc_invalidate_tb(struct uc_struct *uc, uint64_t start_addr, size_t len) \n{\n    tb_page_addr_t start, end;\n    start = get_page_addr_code(uc->cpu->env_ptr, start_addr) & (target_ulong)(-1);\n    end = (start + len) & (target_ulong)(-1);\n    if (start > end) {\n        return;\n    }\n    tb_invalidate_phys_range(uc, start, end);\n}", "target": 1}
{"code": "ring_buffer_read_finish(struct ring_buffer_iter *iter)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer = iter->cpu_buffer;\n\tunsigned long flags;\n\traw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);\n\trb_check_pages(cpu_buffer);\n\traw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);\n\tatomic_dec(&cpu_buffer->record_disabled);\n\tatomic_dec(&cpu_buffer->buffer->resize_disabled);\n\tkfree(iter);\n}", "target": 0}
{"code": "static UINT ExtractRunLengthRegularFgBg(const BYTE* pbOrderHdr, const BYTE* pbEnd, UINT32* advance)\n{\n\tUINT runLength = 0;\n\tWINPR_ASSERT(pbOrderHdr);\n\tWINPR_ASSERT(pbEnd);\n\tWINPR_ASSERT(advance);\n\trunLength = (*pbOrderHdr) & g_MaskRegularRunLength;\n\tif (runLength == 0)\n\t{\n\t\tif (!buffer_within_range(pbOrderHdr, 1, pbEnd))\n\t\t{\n\t\t\t*advance = 0;\n\t\t\treturn 0;\n\t\t}\n\t\trunLength = *(pbOrderHdr + 1) + 1;\n\t\t(*advance)++;\n\t}\n\telse\n\t\trunLength = runLength * 8;\n\treturn runLength;\n}", "target": 1}
{"code": "SPL_METHOD(Array, valid)\n{\n\tzval *object = getThis();\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);\n\tHashTable *aht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tif (spl_array_object_verify_pos(intern, aht TSRMLS_CC) == FAILURE) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_BOOL(zend_hash_has_more_elements_ex(aht, &intern->pos) == SUCCESS);\n\t}\n}", "target": 0}
{"code": "void mutt_socket_empty(struct Connection *conn)\n{\n  if (!conn)\n    return;\n  char buf[1024];\n  int bytes;\n  while ((bytes = mutt_socket_poll(conn, 0)) > 0)\n  {\n    mutt_socket_read(conn, buf, MIN(bytes, sizeof(buf)));\n  }\n}", "target": 0}
{"code": "  void clear_scheduled_exception() {\n    thread_local_top_.scheduled_exception_ = heap_.the_hole_value();\n  }", "target": 0}
{"code": "sudo_auth_init(const struct sudoers_context *ctx, struct passwd *pw,\n    unsigned int mode)\n{\n    sudo_auth *auth;\n    int status = AUTH_SUCCESS;\n    debug_decl(sudo_auth_init, SUDOERS_DEBUG_AUTH);\n    if (auth_switch[0].name == NULL)\n\tdebug_return_int(0);\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (ISSET(mode, MODE_NONINTERACTIVE))\n\t    SET(auth->flags, FLAG_NONINTERACTIVE);\n\tif (auth->init && !IS_DISABLED(auth)) {\n\t    status = (auth->init)(ctx, pw, auth);\n\t    if (status == AUTH_FAILURE)\n\t\tSET(auth->flags, FLAG_DISABLED);\n\t    else if (status == AUTH_ERROR)\n\t\tbreak;\t\t\n\t}\n    }\n    if ((standalone = IS_STANDALONE(&auth_switch[0]))) {\n\tbool found = false;\n\tfor (auth = auth_switch; auth->name; auth++) {\n\t    if (IS_DISABLED(auth))\n\t\tcontinue;\n\t    if (!IS_STANDALONE(auth)) {\n\t\taudit_failure(ctx, ctx->runas.argv,\n\t\t    N_(\"invalid authentication methods\"));\n\t\tlog_warningx(ctx, SLOG_SEND_MAIL,\n\t\t    N_(\"Invalid authentication methods compiled into sudo!  \"\n\t\t    \"You may not mix standalone and non-standalone authentication.\"));\n\t\tdebug_return_int(-1);\n\t    }\n\t    if (!found) {\n\t\tfound = true;\n\t\tcontinue;\n\t    }\n\t    SET(auth->flags, FLAG_DISABLED);\n\t}\n    }\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (!IS_DISABLED(auth)) {\n\t    sudo_auth *first = auth;\n\t    for (; auth->name; auth++) {\n\t\tif (!IS_DISABLED(auth))\n\t\t    break;\n\t    }\n\t    if (auth->name == NULL)\n\t\tSET(first->flags, FLAG_ONEANDONLY);\n\t    break;\n\t}\n    }\n    debug_return_int(status == AUTH_ERROR ? -1 : 0);\n}", "target": 1}
{"code": "  TfLiteRegistration CopyOpRegistration() {\n    TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n    reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n      const TfLiteTensor* tensor0 = GetInput(context, node, 0);\n      TfLiteTensor* tensor1 = GetOutput(context, node, 0);\n      TfLiteIntArray* newSize = TfLiteIntArrayCopy(tensor0->dims);\n      return context->ResizeTensor(context, tensor1, newSize);\n    };\n    reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n      CallReporting* call_reporting =\n          static_cast<CallReporting*>(node->builtin_data);\n      const TfLiteTensor* a0 = GetInput(context, node, 0);\n      TfLiteTensor* a1 = GetOutput(context, node, 0);\n      int num = a0->dims->data[0];\n      for (int i = 0; i < num; i++) {\n        a1->data.f[i] = a0->data.f[i];\n      }\n      call_reporting->Record();\n      return kTfLiteOk;\n    };\n    return reg;\n  }", "target": 1}
{"code": "static int do_i2c_crc(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t      char *const argv[])\n{\n\tuint\tchip;\n\tulong\taddr;\n\tint\talen;\n\tint\tcount;\n\tuchar\tbyte;\n\tulong\tcrc;\n\tulong\terr;\n\tint ret = 0;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\tif (argc < 4)\n\t\treturn CMD_RET_USAGE;\n\tchip = hextoul(argv[1], NULL);\n\taddr = hextoul(argv[2], NULL);\n\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn CMD_RET_USAGE;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n#endif\n\tcount = hextoul(argv[3], NULL);\n\tprintf (\"CRC32 for %08lx ... %08lx ==> \", addr, addr + count - 1);\n\tcrc = 0;\n\terr = 0;\n\twhile (count-- > 0) {\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_read(dev, addr, &byte, 1);\n#else\n\t\tret = i2c_read(chip, addr, alen, &byte, 1);\n#endif\n\t\tif (ret)\n\t\t\terr++;\n\t\tcrc = crc32(crc, &byte, 1);\n\t\taddr++;\n\t}\n\tif (err > 0)\n\t\ti2c_report_err(ret, I2C_ERR_READ);\n\telse\n\t\tprintf (\"%08lx\\n\", crc);\n\treturn 0;\n}", "target": 1}
{"code": "is_query(const char *query)\n{\n\tconst char *query_list[] = {\"insert\", \"update\", \"delete\", \"replace\",\n\t\t\"alter\", \"load\", \"select\", \"do\", \"handler\", \"call\", \"execute\",\n\t\t\"begin\", NULL};\n\treturn is_query_from_list(query, query_list);\n}", "target": 0}
{"code": "void RootWindow::OnWindowBoundsChanged(Window* window,\n                                       bool contained_mouse_point) {\n  if (contained_mouse_point ||\n      (window->IsVisible() &&\n       window->ContainsPointInRoot(last_mouse_location_))) {\n    PostMouseMoveEventAfterWindowChange();\n  }\n}", "target": 0}
{"code": "void IdentifierHashTable::growAndRehash(uint32_t newCapacity) {\n  if (LLVM_UNLIKELY(newCapacity <= capacity())) {\n    hermes_fatal(\"too many identifiers created\");\n  }\n  assert(llvh::isPowerOf2_32(newCapacity) && \"capacity must be power of 2\");\n  CompactTable tmpTable(newCapacity, table_.getCurrentScale());\n  tmpTable.swap(table_);\n  for (uint32_t oldIdx = 0; oldIdx < tmpTable.size(); ++oldIdx) {\n    if (!tmpTable.isValid(oldIdx)) {\n      continue;\n    }\n    uint32_t idx = 0;\n    uint32_t oldVal = tmpTable.get(oldIdx);\n    auto &lookupTableEntry = identifierTable_->getLookupTableEntry(oldVal);\n    uint32_t hash = lookupTableEntry.getHash();\n    if (lookupTableEntry.isStringPrim()) {\n      idx = lookupString(lookupTableEntry.getStringPrim(), hash, true);\n    } else if (lookupTableEntry.isLazyASCII()) {\n      idx = lookupString(lookupTableEntry.getLazyASCIIRef(), hash, true);\n    } else if (lookupTableEntry.isLazyUTF16()) {\n      idx = lookupString(lookupTableEntry.getLazyUTF16Ref(), hash, true);\n    }\n    table_.set(idx, oldVal);\n  }\n  nonEmptyEntryCount_ = size_;\n}", "target": 0}
{"code": "const char *fz_colorspace_colorant(fz_context *ctx, const fz_colorspace *cs, int i)\n{\n\tif (!cs || i < 0 || i >= cs->n)\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"Colorant out of range\");\n\treturn cs->colorant[i];\n}", "target": 0}
{"code": "win_enter(win_T *wp, int undo_sync)\n{\n    win_enter_ext(wp, undo_sync, FALSE, FALSE, TRUE, TRUE);\n}", "target": 0}
{"code": "static Jsi_RC jsi_ArrayFlatSub(Jsi_Interp *interp, Jsi_Obj* nobj, Jsi_Value *arr, int depth) {\n    int i, n = 0, len = Jsi_ObjGetLength(interp, arr->d.obj);\n    if (len <= 0) return JSI_OK;\n    Jsi_RC rc = JSI_OK;\n    int clen = Jsi_ObjGetLength(interp, nobj);\n    for (i = 0; i < len && rc == JSI_OK; i++) {\n        Jsi_Value *t = Jsi_ValueArrayIndex(interp, arr, i);\n        if (t && depth>0 && Jsi_ValueIsArray(interp, t))\n            rc = jsi_ArrayFlatSub(interp, nobj, t , depth-1);\n        else if (!Jsi_ValueIsUndef(interp, t))\n            Jsi_ObjArrayAdd(interp, nobj, t);\n        if ((++n + clen)>interp->maxArrayList)\n            return Jsi_LogError(\"array size exceeded\");\n    }\n    return rc;\n}", "target": 1}
{"code": "static unsigned long mb2_cache_count(struct shrinker *shrink,\n\t\t\t\t     struct shrink_control *sc)\n{\n\tstruct mb2_cache *cache = container_of(shrink, struct mb2_cache,\n\t\t\t\t\t       c_shrink);\n\treturn cache->c_entry_count;\n}", "target": 0}
{"code": "void ndpi_search_oracle(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow)\n{\n  struct ndpi_packet_struct *packet = &flow->packet;\n  u_int16_t dport = 0, sport = 0;\n  NDPI_LOG_DBG(ndpi_struct, \"search ORACLE\\n\");\n  if(packet->tcp != NULL) {\n    sport = ntohs(packet->tcp->source), dport = ntohs(packet->tcp->dest);\n    NDPI_LOG_DBG2(ndpi_struct, \"calculating ORACLE over tcp\\n\");\n    if ((dport == 1521 || sport == 1521)\n\t&&  (((packet->payload[0] == 0x07) && (packet->payload[1] == 0xff) && (packet->payload[2] == 0x00))\n\t     || ((packet->payload_packet_len >= 232) && ((packet->payload[0] == 0x00) || (packet->payload[0] == 0x01)) \n\t     && (packet->payload[1] != 0x00)\n\t     && (packet->payload[2] == 0x00)\n\t\t && (packet->payload[3] == 0x00)))) {\n      NDPI_LOG_INFO(ndpi_struct, \"found oracle\\n\");\n      ndpi_int_oracle_add_connection(ndpi_struct, flow);\n    } else if (packet->payload_packet_len == 213 && packet->payload[0] == 0x00 &&\n               packet->payload[1] == 0xd5 && packet->payload[2] == 0x00 &&\n               packet->payload[3] == 0x00 ) {\n      NDPI_LOG_INFO(ndpi_struct, \"found oracle\\n\");\n      ndpi_int_oracle_add_connection(ndpi_struct, flow);\n    }\n  } else {\n    NDPI_EXCLUDE_PROTO(ndpi_struct, flow);\n  }\n}", "target": 1}
{"code": "acc_ctx_cont(OM_uint32 *minstat,\n\t     gss_buffer_t buf,\n\t     gss_ctx_id_t *ctx,\n\t     gss_buffer_t *responseToken,\n\t     gss_buffer_t *mechListMIC,\n\t     OM_uint32 *negState,\n\t     send_token_flag *return_token)\n{\n\tOM_uint32 ret, tmpmin;\n\tgss_OID supportedMech;\n\tspnego_gss_ctx_id_t sc;\n\tunsigned int len;\n\tunsigned char *ptr, *bufstart;\n\tsc = (spnego_gss_ctx_id_t)*ctx;\n\tret = GSS_S_DEFECTIVE_TOKEN;\n\t*negState = REJECT;\n\t*minstat = 0;\n\tsupportedMech = GSS_C_NO_OID;\n\t*return_token = ERROR_TOKEN_SEND;\n\t*responseToken = *mechListMIC = GSS_C_NO_BUFFER;\n\tptr = bufstart = buf->value;\n#define REMAIN (buf->length - (ptr - bufstart))\n\tif (REMAIN > INT_MAX)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tif (*ptr == HEADER_ID) {\n\t\tret = g_verify_token_header(gss_mech_spnego,\n\t\t\t\t\t    &len, &ptr, 0, REMAIN);\n\t\tif (ret) {\n\t\t\t*minstat = ret;\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t\t}\n\t}\n\tif (*ptr != (CONTEXT | 0x01)) {\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\tret = get_negTokenResp(minstat, ptr, REMAIN,\n\t\t\t       negState, &supportedMech,\n\t\t\t       responseToken, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\tif (*responseToken == GSS_C_NO_BUFFER &&\n\t    *mechListMIC == GSS_C_NO_BUFFER) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto cleanup;\n\t}\n\tif (supportedMech != GSS_C_NO_OID) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto cleanup;\n\t}\n\tsc->firstpass = 0;\n\t*negState = ACCEPT_INCOMPLETE;\n\t*return_token = CONT_TOKEN_SEND;\ncleanup:\n\tif (supportedMech != GSS_C_NO_OID) {\n\t\tgeneric_gss_release_oid(&tmpmin, &supportedMech);\n\t}\n\treturn ret;\n#undef REMAIN\n}", "target": 1}
{"code": "TEST(RegexMatchExpression, MatchesElementExtendedOn) {\n    BSONObj match = BSON(\"x\"\n                         << \"ab\");\n    BSONObj notMatch = BSON(\"x\"\n                            << \"a b\");\n    RegexMatchExpression regex(\"\", \"a b\", \"x\");\n    ASSERT(regex.matchesSingleElement(match.firstElement()));\n    ASSERT(!regex.matchesSingleElement(notMatch.firstElement()));\n}", "target": 0}
{"code": "SPL_METHOD(SplFileInfo, __construct)\n{\n\tspl_filesystem_object *intern;\n\tchar *path;\n\tint len;\n\tzend_error_handling error_handling;\n\tzend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &path, &len) == FAILURE) {\n\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\treturn;\n\t}\n\tintern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tspl_filesystem_info_set_filename(intern, path, len, 1 TSRMLS_CC);\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}", "target": 0}
{"code": "WebWidget* RenderView::createPopupMenu(WebKit::WebPopupType popup_type) {\n  RenderWidget* widget = RenderWidget::Create(routing_id_,\n                                              render_thread_,\n                                              popup_type);\n  return widget->webwidget();\n}", "target": 0}
{"code": "RenderWidgetHostViewBase* RenderWidgetHostImpl::GetView() const {\n  return view_.get();\n}", "target": 0}
{"code": "void *mempool_getbuffer(MemoryPoolHandle handle, size_t expected_buffer_size) {\n  int rc;\n  int bufs_to_allocate;\n  int bufs_that_can_be_allocated = 0;\n  struct memory_pool_element *pool_item = NULL;\n  struct mempool *pool = (struct mempool *)handle;\n  char *log_msg_fmt =\n      \"mempool(%p): mempool_getbuffer called for invalid \"\n      \"expected_buffer_size(%zu), current pool manages only \"\n      \"mempool_item_size(%zu)\";\n  char log_msg[300];\n  if (pool == NULL) {\n    return NULL;\n  }\n  if (pool->mempool_item_size != expected_buffer_size) {\n    if (pool->log_callback_func) {\n      snprintf(log_msg, sizeof(log_msg), log_msg_fmt, (void *)pool,\n               expected_buffer_size, pool->mempool_item_size);\n      pool->log_callback_func(MEMPOOL_LOG_FATAL, log_msg);\n      return NULL;\n    }\n  }\n  if ((pool->flags & ENABLE_LOCKING) != 0) {\n    pthread_mutex_lock(&pool->lock);\n  }\n  if (pool->free_bufs_in_pool == 0) {\n    bufs_to_allocate = pool->expandable_size / pool->mempool_item_size;\n    bufs_that_can_be_allocated = pool_can_expand_by(pool);\n    if (bufs_that_can_be_allocated > 0) {\n      bufs_to_allocate = ((bufs_to_allocate > bufs_that_can_be_allocated)\n                              ? bufs_that_can_be_allocated\n                              : bufs_to_allocate);\n      rc = freelist_allocate(pool, bufs_to_allocate);\n      if (rc != 0) {\n        if ((pool->flags & ENABLE_LOCKING) != 0) {\n          pthread_mutex_unlock(&pool->lock);\n        }\n        return NULL;\n      }\n    } else {\n      if ((pool->flags & ENABLE_LOCKING) != 0) {\n        pthread_mutex_unlock(&pool->lock);\n      }\n      return NULL;\n    }\n  }\n  if (pool->free_list != NULL) {\n    pool_item = pool->free_list;\n    pool->free_list = pool_item->next;\n    pool_item->next = (struct memory_pool_element *)NULL;\n    pool->free_bufs_in_pool--;\n  }\n  if (pool_item) {\n    pool->number_of_bufs_shared++;\n  }\n  if ((pool->flags & ENABLE_LOCKING) != 0) {\n    pthread_mutex_unlock(&pool->lock);\n  }\n  return (void *)pool_item;\n}", "target": 0}
{"code": "static void dhcps_initialize_message(struct dhcp_msg *dhcp_message_repository)\n{\n        dhcp_message_repository->op = DHCP_MESSAGE_OP_REPLY;\n        dhcp_message_repository->htype = DHCP_MESSAGE_HTYPE;\n        dhcp_message_repository->hlen = DHCP_MESSAGE_HLEN; \n        dhcp_message_repository->hops = 0;\t\t\n        memcpy((char *)dhcp_recorded_xid, (char *) dhcp_message_repository->xid,\n\t\t\t\t\tsizeof(dhcp_message_repository->xid));\n        dhcp_message_repository->secs = 0;\n        dhcp_message_repository->flags = htons(BOOTP_BROADCAST);         \n\tmemcpy((char *)dhcp_message_repository->yiaddr,\n\t\t\t(char *)&dhcps_allocated_client_address,\n\t\t\t\tsizeof(dhcp_message_repository->yiaddr));\n\tmemset((char *)dhcp_message_repository->ciaddr, 0,\n\t\t\t\t\tsizeof(dhcp_message_repository->ciaddr));\n        memset((char *)dhcp_message_repository->siaddr, 0,\n\t\t\t\t\tsizeof(dhcp_message_repository->siaddr));\n        memset((char *)dhcp_message_repository->giaddr, 0,\n\t\t\t\t\tsizeof(dhcp_message_repository->giaddr));\n        memset((char *)dhcp_message_repository->sname,  0,\n\t\t\t\t\tsizeof(dhcp_message_repository->sname));\n        memset((char *)dhcp_message_repository->file,   0,\n\t\t\t\t\tsizeof(dhcp_message_repository->file));\n        memset((char *)dhcp_message_repository->options, 0,\n\t\t\t\t\tdhcp_message_total_options_lenth);\n        memcpy((char *)dhcp_message_repository->options, (char *)dhcp_magic_cookie,\n\t\t\t\t\tsizeof(dhcp_magic_cookie));\n}", "target": 1}
{"code": "int linenoiseHistorySave(const char* filename) {\n    FILE* fp = fopen(filename, \"wt\");\n    if (fp == NULL) {\n        return -1;\n    }\n    for (int j = 0; j < historyLen; ++j) {\n        if (history[j][0] != '\\0') {\n            fprintf(fp, \"%s\\n\", history[j]);\n        }\n    }\n    fclose(fp);\n    return 0;\n}", "target": 1}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->builtin_data != nullptr);\n  auto* params = reinterpret_cast<TfLitePoolParams*>(node->builtin_data);\n  TFLITE_DCHECK(node->user_data != nullptr);\n  OpData* data = static_cast<OpData*>(node->user_data);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE_STATUS(CalculateOpData(context, params, input, output, data));\n  if (input->type == kTfLiteFloat32) {\n    CalculateActivationRange(params->activation, &data->activation_min_f32,\n                             &data->activation_max_f32);\n  } else if (input->type == kTfLiteInt8 || input->type == kTfLiteUInt8) {\n    CalculateActivationRangeQuantized(context, params->activation, output,\n                                      &data->activation_min,\n                                      &data->activation_max);\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "unsigned int get_random_int(void)\n{\n\tstruct keydata *keyptr;\n\t__u32 *hash = get_cpu_var(get_random_int_hash);\n\tint ret;\n\tkeyptr = get_keyptr();\n\thash[0] += current->pid + jiffies + get_cycles();\n\tret = half_md4_transform(hash, keyptr->secret);\n\tput_cpu_var(get_random_int_hash);\n\treturn ret;\n}", "target": 1}
{"code": "id3_skip (SF_PRIVATE * psf)\n{\tunsigned char\tbuf [10] ;\n\tmemset (buf, 0, sizeof (buf)) ;\n\tpsf_binheader_readf (psf, \"pb\", 0, buf, 10) ;\n\tif (buf [0] == 'I' && buf [1] == 'D' && buf [2] == '3')\n\t{\tint\toffset = buf [6] & 0x7f ;\n\t\toffset = (offset << 7) | (buf [7] & 0x7f) ;\n\t\toffset = (offset << 7) | (buf [8] & 0x7f) ;\n\t\toffset = (offset << 7) | (buf [9] & 0x7f) ;\n\t\tpsf_log_printf (psf, \"ID3 length : %d\\n--------------------\\n\", offset) ;\n\t\tif (offset < 0)\n\t\t\treturn 0 ;\n\t\tpsf->fileoffset += offset + 10 ;\n\t\tpsf_binheader_readf (psf, \"p\", psf->fileoffset) ;\n\t\treturn 1 ;\n\t\t} ;\n\treturn 0 ;\n} ", "target": 1}
{"code": "void sctp_generate_t3_rtx_event(unsigned long peer)\n{\n\tint error;\n\tstruct sctp_transport *transport = (struct sctp_transport *) peer;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct net *net = sock_net(asoc->base.sk);\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\t\tif (!mod_timer(&transport->T3_rtx_timer, jiffies + (HZ/20)))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\tif (transport->dead)\n\t\tgoto out_unlock;\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_T3_RTX),\n\t\t\t   asoc->state,\n\t\t\t   asoc->ep, asoc,\n\t\t\t   transport, GFP_ATOMIC);\n\tif (error)\n\t\tasoc->base.sk->sk_err = -error;\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_transport_put(transport);\n}", "target": 1}
{"code": "archive_wstring_append_from_mbs(struct archive_wstring *dest,\n    const char *p, size_t len)\n{\n\tsize_t r;\n\tint ret_val = 0;\n\tsize_t wcs_length = len;\n\tsize_t mbs_length = len;\n\tconst char *mbs = p;\n\twchar_t *wcs;\n#if HAVE_MBRTOWC\n\tmbstate_t shift_state;\n\tmemset(&shift_state, 0, sizeof(shift_state));\n#endif\n\tif (NULL == archive_wstring_ensure(dest, dest->length + wcs_length + 1))\n\t\treturn (-1);\n\twcs = dest->s + dest->length;\n\twhile (*mbs && mbs_length > 0) {\n\t\tif (wcs_length == 0) {\n\t\t\tdest->length = wcs - dest->s;\n\t\t\tdest->s[dest->length] = L'\\0';\n\t\t\twcs_length = mbs_length;\n\t\t\tif (NULL == archive_wstring_ensure(dest,\n\t\t\t    dest->length + wcs_length + 1))\n\t\t\t\treturn (-1);\n\t\t\twcs = dest->s + dest->length;\n\t\t}\n#if HAVE_MBRTOWC\n\t\tr = mbrtowc(wcs, mbs, wcs_length, &shift_state);\n#else\n\t\tr = mbtowc(wcs, mbs, wcs_length);\n#endif\n\t\tif (r == (size_t)-1 || r == (size_t)-2) {\n\t\t\tret_val = -1;\n\t\t\tif (errno == EILSEQ) {\n\t\t\t\t++mbs;\n\t\t\t\t--mbs_length;\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t\tif (r == 0 || r > mbs_length)\n\t\t\tbreak;\n\t\twcs++;\n\t\twcs_length--;\n\t\tmbs += r;\n\t\tmbs_length -= r;\n\t}\n\tdest->length = wcs - dest->s;\n\tdest->s[dest->length] = L'\\0';\n\treturn (ret_val);\n}", "target": 0}
{"code": "void usbredirparser_send_get_configuration(struct usbredirparser *parser,\n    uint64_t id)\n{\n    usbredirparser_queue(parser, usb_redir_get_configuration, id,\n                         NULL, NULL, 0);\n}", "target": 0}
{"code": "int test(char *URL)\n{\n  int errors = 0;\n  (void)URL; \n  errors += test_weird_arguments();\n  errors += test_unsigned_short_formatting();\n  errors += test_signed_short_formatting();\n  errors += test_unsigned_int_formatting();\n  errors += test_signed_int_formatting();\n  errors += test_unsigned_long_formatting();\n  errors += test_signed_long_formatting();\n  errors += test_curl_off_t_formatting();\n  errors += test_string_formatting();\n  errors += test_float_formatting();\n  if(errors)\n    return TEST_ERR_MAJOR_BAD;\n  else\n    return 0;\n}", "target": 0}
{"code": "bool bt_att_cancel(struct bt_att *att, unsigned int id)\n{\n\tconst struct queue_entry *entry;\n\tstruct att_send_op *op;\n\tif (!att || !id)\n\t\treturn false;\n\tfor (entry = queue_get_entries(att->chans); entry;\n\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct bt_att_chan *chan = entry->data;\n\t\tif (bt_att_chan_cancel(chan, id))\n\t\t\treturn true;\n\t}\n\tif (att->in_disc)\n\t\treturn bt_att_disc_cancel(att, id);\n\top = queue_remove_if(att->req_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\top = queue_remove_if(att->ind_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\top = queue_remove_if(att->write_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\tif (!op)\n\t\treturn false;\ndone:\n\tdestroy_att_send_op(op);\n\twakeup_writer(att);\n\treturn true;\n}", "target": 0}
{"code": "int hashtable_set(hashtable_t *hashtable,\n                  const char *key, size_t serial,\n                  json_t *value)\n{\n    pair_t *pair;\n    bucket_t *bucket;\n    size_t hash, index;\n    if(hashtable->size >= num_buckets(hashtable))\n        if(hashtable_do_rehash(hashtable))\n            return -1;\n    hash = hash_str(key);\n    index = hash % num_buckets(hashtable);\n    bucket = &hashtable->buckets[index];\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n    if(pair)\n    {\n        json_decref(pair->value);\n        pair->value = value;\n    }\n    else\n    {\n        pair = jsonp_malloc(offsetof(pair_t, key) + strlen(key) + 1);\n        if(!pair)\n            return -1;\n        pair->hash = hash;\n        pair->serial = serial;\n        strcpy(pair->key, key);\n        pair->value = value;\n        list_init(&pair->list);\n        insert_to_bucket(hashtable, bucket, &pair->list);\n        hashtable->size++;\n    }\n    return 0;\n}", "target": 1}
{"code": "int ppp_register_net_channel(struct net *net, struct ppp_channel *chan)\n{\n\tstruct channel *pch;\n\tstruct ppp_net *pn;\n\tpch = kzalloc(sizeof(struct channel), GFP_KERNEL);\n\tif (!pch)\n\t\treturn -ENOMEM;\n\tpn = ppp_pernet(net);\n\tpch->ppp = NULL;\n\tpch->chan = chan;\n\tpch->chan_net = net;\n\tchan->ppp = pch;\n\tinit_ppp_file(&pch->file, CHANNEL);\n\tpch->file.hdrlen = chan->hdrlen;\n#ifdef CONFIG_PPP_MULTILINK\n\tpch->lastseq = -1;\n#endif \n\tinit_rwsem(&pch->chan_sem);\n\tspin_lock_init(&pch->downl);\n\trwlock_init(&pch->upl);\n\tspin_lock_bh(&pn->all_channels_lock);\n\tpch->file.index = ++pn->last_channel_index;\n\tlist_add(&pch->list, &pn->new_channels);\n\tatomic_inc(&channel_count);\n\tspin_unlock_bh(&pn->all_channels_lock);\n\treturn 0;\n}", "target": 1}
{"code": "static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)\n{\n\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n}", "target": 1}
{"code": "static void *__alloc_from_pool(size_t size, struct page **ret_page, gfp_t flags)\n{\n\tunsigned long val;\n\tvoid *ptr = NULL;\n\tif (!atomic_pool) {\n\t\tWARN(1, \"coherent pool not initialised!\\n\");\n\t\treturn NULL;\n\t}\n\tval = gen_pool_alloc(atomic_pool, size);\n\tif (val) {\n\t\tphys_addr_t phys = gen_pool_virt_to_phys(atomic_pool, val);\n\t\t*ret_page = phys_to_page(phys);\n\t\tptr = (void *)val;\n\t\tif (flags & __GFP_ZERO)\n\t\t\tmemset(ptr, 0, size);\n\t}\n\treturn ptr;\n}", "target": 1}
{"code": "ZEND_API void zend_ts_hash_merge_ex(TsHashTable *target, TsHashTable *source, copy_ctor_func_t pCopyConstructor, uint size, merge_checker_func_t pMergeSource, void *pParam)\n{\n\tbegin_read(source);\n\tbegin_write(target);\n\tzend_hash_merge_ex(TS_HASH(target), TS_HASH(source), pCopyConstructor, size, pMergeSource, pParam);\n\tend_write(target);\n\tend_read(source);\n}", "target": 0}
{"code": "extract_argv (EvDocument *document, gint page)\n{\n\tComicsDocument *comics_document = COMICS_DOCUMENT (document);\n\tchar **argv;\n\tchar *command_line, *quoted_archive, *quoted_filename;\n\tGError *err = NULL;\n\tif (g_strrstr (comics_document->page_names->pdata[page], \"--checkpoint-action=\"))\n\t{\n\t\tg_warning (\"File unsupported\\n\");\n\t\tgtk_main_quit ();\n\t}\n        if (page >= comics_document->page_names->len)\n                return NULL;\n\tif (comics_document->regex_arg) {\n\t\tquoted_archive = g_shell_quote (comics_document->archive);\n\t\tquoted_filename =\n\t\t\tcomics_regex_quote (comics_document->page_names->pdata[page]);\n\t} else {\n\t\tquoted_archive = g_shell_quote (comics_document->archive);\n\t\tquoted_filename = g_shell_quote (comics_document->page_names->pdata[page]);\n\t}\n\tcommand_line = g_strdup_printf (\"%s %s %s\",\n\t\t\t\t\tcomics_document->extract_command,\n\t\t\t\t\tquoted_archive,\n\t\t\t\t\tquoted_filename);\n\tg_free (quoted_archive);\n\tg_free (quoted_filename);\n\tg_shell_parse_argv (command_line, NULL, &argv, &err);\n\tg_free (command_line);\n\tif (err) {\n\t\tg_warning (_(\"Error %s\"), err->message);\n\t\tg_error_free (err);\n\t\treturn NULL;\n\t}\n\treturn argv;\n}", "target": 1}
{"code": "void recovery_character(const char *character)\n{\n    if (!awaiting_character) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");\n        layoutHome();\n        return;\n    }\n    if (strlen(mnemonic) + 1 > MNEMONIC_BUF - 1) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage,\n                        \"Too many characters attempted during recovery\");\n        layoutHome();\n        return;\n    }\n    char *pos = strchr(cipher, character[0]);\n    if (character[0] != ' ' && pos == NULL) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_SyntaxError, \"Character must be from a to z\");\n        layoutHome();\n        return;\n    }\n    static int uncyphered_word_count = 0;\n    static bool definitely_using_cipher = false;\n    static CONFIDENTIAL char coded_word[12];\n    static CONFIDENTIAL char decoded_word[12];\n    if (!mnemonic[0]) {\n        uncyphered_word_count = 0;\n        definitely_using_cipher = false;\n        memzero(coded_word, sizeof(coded_word));\n        memzero(decoded_word, sizeof(decoded_word));\n    }\n    char decoded_character[2] = \" \";\n    if (character[0] != ' ') {\n        decoded_character[0] = english_alphabet[(int)(pos - cipher)];\n        strlcat(coded_word, character, sizeof(coded_word));\n        strlcat(decoded_word, decoded_character, sizeof(decoded_word));\n        if (enforce_wordlist && 4 <= strlen(coded_word)) {\n            bool maybe_not_using_cipher = attempt_auto_complete(coded_word);\n            bool maybe_using_cipher = attempt_auto_complete(decoded_word);\n            if (!maybe_not_using_cipher && maybe_using_cipher) {\n                definitely_using_cipher = true;\n            } else if (maybe_not_using_cipher && !definitely_using_cipher &&\n                       MAX_UNCYPHERED_WORDS < uncyphered_word_count++) {\n                recovery_abort();\n                fsm_sendFailure(FailureType_Failure_SyntaxError,\n                                \"Words were not entered correctly. Make sure you are using the substition cipher.\");\n                layoutHome();\n                return;\n            }\n        }\n    } else {\n        memzero(coded_word, sizeof(coded_word));\n        memzero(decoded_word, sizeof(decoded_word));\n    }\n    strlcat(mnemonic, decoded_character, MNEMONIC_BUF);\n    next_character();\n}", "target": 1}
{"code": "static int parse_token(char **name, char **value, char **cp)\n{\n\tchar *end;\n\tif (!name || !value || !cp)\n\t\treturn -BLKID_ERR_PARAM;\n\tif (!(*value = strchr(*cp, '=')))\n\t\treturn 0;\n\t**value = '\\0';\n\t*name = strip_line(*cp);\n\t*value = skip_over_blank(*value + 1);\n\tif (**value == '\"') {\n\t\tend = strchr(*value + 1, '\"');\n\t\tif (!end) {\n\t\t\tDBG(READ, ul_debug(\"unbalanced quotes at: %s\", *value));\n\t\t\t*cp = *value;\n\t\t\treturn -BLKID_ERR_CACHE;\n\t\t}\n\t\t(*value)++;\n\t\t*end = '\\0';\n\t\tend++;\n\t} else {\n\t\tend = skip_over_word(*value);\n\t\tif (*end) {\n\t\t\t*end = '\\0';\n\t\t\tend++;\n\t\t}\n\t}\n\t*cp = end;\n\treturn 1;\n}", "target": 1}
{"code": "void RequestContext::AddInstanceIdentityToken() {\n  if (!method()) {\n    return;\n  }\n  const auto &audience = method()->backend_jwt_audience();\n  if (!audience.empty()) {\n    auto &token = service_context()\n                      ->global_context()\n                      ->GetInstanceIdentityToken(audience)\n                      ->GetAuthToken();\n    if (!token.empty()) {\n      std::string origin_auth_header;\n      if (request()->FindHeader(kAuthorizationHeader, &origin_auth_header)) {\n        Status status = request()->AddHeaderToBackend(\n            kXForwardedAuthorizationHeader, origin_auth_header);\n        if (!status.ok()) {\n          service_context()->env()->LogError(\n              \"Failed to set X-Forwarded-Authorization header to backend.\");\n        }\n      }\n      Status status = request()->AddHeaderToBackend(kAuthorizationHeader,\n                                                    kBearerPrefix + token);\n      if (!status.ok()) {\n        service_context()->env()->LogError(\n            \"Failed to set authorization header to backend.\");\n      }\n    }\n  }\n}", "target": 1}
{"code": "static void gdCtxPrintf(gdIOCtx * out, const char *format, ...)\n{\n\tchar buf[4096];\n\tint len;\n\tva_list args;\n\tva_start(args, format);\n\tlen = vsnprintf(buf, sizeof(buf)-1, format, args);\n\tva_end(args);\n\tout->putBuf(out, buf, len);\n}", "target": 1}
{"code": "void HTMLMediaElement::OnRemovedFromDocumentTimerFired(TimerBase*) {\n  if (InActiveDocument())\n    return;\n  PauseInternal();\n}", "target": 0}
{"code": "TEST_F(HermesRuntimeTest, SpreadHostObjectWithOwnProperties) {\n  class HostObjectWithPropertyNames : public HostObject {\n    std::vector<PropNameID> getPropertyNames(Runtime &rt) override {\n      return PropNameID::names(rt, \"prop1\", \"1\", \"2\", \"prop2\", \"3\");\n    }\n    Value get(Runtime &runtime, const PropNameID &name) override {\n      return Value();\n    }\n  };\n  Object ho = Object::createFromHostObject(\n      *rt, std::make_shared<HostObjectWithPropertyNames>());\n  rt->global().setProperty(*rt, \"ho\", ho);\n  auto res = eval(R\"###(\nvar spreaded = {...ho};\nvar props = Object.getOwnPropertyNames(spreaded);\nprops.toString();\n)###\")\n                 .getString(*rt)\n                 .utf8(*rt);\n  EXPECT_EQ(res, \"1,2,3,prop1,prop2\");\n}", "target": 0}
{"code": "bool Unpack::ProcessDecoded(UnpackThreadData &D)\n{\n  UnpackDecodedItem *Item=D.Decoded,*Border=D.Decoded+D.DecodedSize;\n  while (Item<Border)\n  {\n    UnpPtr&=MaxWinMask;\n    if (((WriteBorder-UnpPtr) & MaxWinMask)<MAX_LZ_MATCH+3 && WriteBorder!=UnpPtr)\n    {\n      UnpWriteBuf();\n      if (WrittenFileSize>DestUnpSize)\n        return false;\n    }\n    if (Item->Type==UNPDT_LITERAL)\n    {\n#if defined(LITTLE_ENDIAN) && defined(ALLOW_MISALIGNED)\n      if (Item->Length==3 && UnpPtr<MaxWinSize-4)\n      {\n        *(uint32 *)(Window+UnpPtr)=*(uint32 *)Item->Literal;\n        UnpPtr+=4;\n      }\n      else\n#endif\n        for (uint I=0;I<=Item->Length;I++)\n          Window[UnpPtr++ & MaxWinMask]=Item->Literal[I];\n    }\n    else\n      if (Item->Type==UNPDT_MATCH)\n      {\n        InsertOldDist(Item->Distance);\n        LastLength=Item->Length;\n        CopyString(Item->Length,Item->Distance);\n      }\n      else\n        if (Item->Type==UNPDT_REP)\n        {\n          uint Distance=OldDist[Item->Distance];\n          for (uint I=Item->Distance;I>0;I--)\n            OldDist[I]=OldDist[I-1];\n          OldDist[0]=Distance;\n          LastLength=Item->Length;\n          CopyString(Item->Length,Distance);\n        }\n        else\n          if (Item->Type==UNPDT_FULLREP)\n          {\n            if (LastLength!=0)\n              CopyString(LastLength,OldDist[0]);\n          }\n          else\n            if (Item->Type==UNPDT_FILTER)\n            {\n              UnpackFilter Filter;\n              Filter.Type=(byte)Item->Length;\n              Filter.BlockStart=Item->Distance;\n              Item++;\n              Filter.Channels=(byte)Item->Length;\n              Filter.BlockLength=Item->Distance;\n              AddFilter(Filter);\n            }\n    Item++;\n  }\n  return true;\n}", "target": 1}
{"code": "ff_layout_get_ds_info(struct inode *inode)\n{\n\tstruct pnfs_layout_hdr *layout = NFS_I(inode)->layout;\n\tif (layout == NULL)\n\t\treturn NULL;\n\treturn &FF_LAYOUT_FROM_HDR(layout)->commit_info;\n}", "target": 0}
{"code": "*/\nPHP_FUNCTION(date_timestamp_get)\n{\n\tzval         *object;\n\tphp_date_obj *dateobj;\n\tlong          timestamp;\n\tint           error;\n\tif (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"O\", &object, date_ce_interface) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tdateobj = (php_date_obj *) zend_object_store_get_object(object TSRMLS_CC);\n\tDATE_CHECK_INITIALIZED(dateobj->time, DateTime);\n\ttimelib_update_ts(dateobj->time, NULL);\n\ttimestamp = timelib_date_to_int(dateobj->time, &error);\n\tif (error) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETVAL_LONG(timestamp);\n\t}", "target": 0}
{"code": "fifo_open(notify_fifo_t* fifo, int (*script_exit)(thread_t *), const char *type)\n{\n\tint ret;\n\tint sav_errno;\n\tif (fifo->name) {\n\t\tsav_errno = 0;\n\t\tif (!(ret = mkfifo(fifo->name, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)))\n\t\t\tfifo->created_fifo = true;\n\t\telse {\n\t\t\tsav_errno = errno;\n\t\t\tif (sav_errno != EEXIST)\n\t\t\t\tlog_message(LOG_INFO, \"Unable to create %snotify fifo %s\", type, fifo->name);\n\t\t}\n\t\tif (!sav_errno || sav_errno == EEXIST) {\n\t\t\tif (fifo->script)\n\t\t\t\tnotify_fifo_exec(master, script_exit, fifo, fifo->script);\n\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK)) == -1) {\n\t\t\t\tlog_message(LOG_INFO, \"Unable to open %snotify fifo %s - errno %d\", type, fifo->name, errno);\n\t\t\t\tif (fifo->created_fifo) {\n\t\t\t\t\tunlink(fifo->name);\n\t\t\t\t\tfifo->created_fifo = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (fifo->fd == -1) {\n\t\t\tFREE(fifo->name);\n\t\t\tfifo->name = NULL;\n\t\t}\n\t}\n}", "target": 1}
{"code": "static void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,\n\tstruct oz_usb_hdr *usb_hdr, int len)\n{\n\tstruct oz_data *data_hdr = (struct oz_data *)usb_hdr;\n\tswitch (data_hdr->format) {\n\tcase OZ_DATA_F_MULTIPLE_FIXED: {\n\t\t\tstruct oz_multiple_fixed *body =\n\t\t\t\t(struct oz_multiple_fixed *)data_hdr;\n\t\t\tu8 *data = body->data;\n\t\t\tunsigned int n;\n\t\t\tif (!body->unit_size ||\n\t\t\t\tlen < sizeof(struct oz_multiple_fixed) - 1)\n\t\t\t\tbreak;\n\t\t\tn = (len - (sizeof(struct oz_multiple_fixed) - 1))\n\t\t\t\t/ body->unit_size;\n\t\t\twhile (n--) {\n\t\t\t\toz_hcd_data_ind(usb_ctx->hport, body->endpoint,\n\t\t\t\t\tdata, body->unit_size);\n\t\t\t\tdata += body->unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase OZ_DATA_F_ISOC_FIXED: {\n\t\t\tstruct oz_isoc_fixed *body =\n\t\t\t\t(struct oz_isoc_fixed *)data_hdr;\n\t\t\tint data_len = len-sizeof(struct oz_isoc_fixed)+1;\n\t\t\tint unit_size = body->unit_size;\n\t\t\tu8 *data = body->data;\n\t\t\tint count;\n\t\t\tint i;\n\t\t\tif (!unit_size)\n\t\t\t\tbreak;\n\t\t\tcount = data_len/unit_size;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\toz_hcd_data_ind(usb_ctx->hport,\n\t\t\t\t\tbody->endpoint, data, unit_size);\n\t\t\t\tdata += unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "static int ext4_set_bh_endio(struct buffer_head *bh, struct inode *inode)\n{\n\text4_io_end_t *io_end;\n\tstruct page *page = bh->b_page;\n\tloff_t offset = (sector_t)page->index << PAGE_CACHE_SHIFT;\n\tsize_t size = bh->b_size;\nretry:\n\tio_end = ext4_init_io_end(inode, GFP_ATOMIC);\n\tif (!io_end) {\n\t\tif (printk_ratelimit())\n\t\t\tprintk(KERN_WARNING \"%s: allocation fail\\n\", __func__);\n\t\tschedule();\n\t\tgoto retry;\n\t}\n\tio_end->offset = offset;\n\tio_end->size = size;\n\tio_end->page = page;\n\tget_page(io_end->page);\n\tbh->b_private = io_end;\n\tbh->b_end_io = ext4_end_io_buffer_write;\n\treturn 0;\n}", "target": 0}
{"code": "void FastCGITransport::onHeader(std::unique_ptr<folly::IOBuf> key_chain,\n                                std::unique_ptr<folly::IOBuf> value_chain) {\n  Cursor keyCur(key_chain.get());\n  auto key = keyCur.readFixedString(key_chain->computeChainDataLength());\n  if (strcasecmp(key.c_str(), \"HTTP_PROXY\") == 0) return;\n  Cursor valCur(value_chain.get());\n  auto value = valCur.readFixedString(value_chain->computeChainDataLength());\n  m_requestParams[key] = value;\n}", "target": 0}
{"code": "NavigatorServiceWorker::NavigatorServiceWorker(Navigator& navigator)\n    : DOMWindowProperty(navigator.frame())\n{\n}", "target": 0}
{"code": "TEST_F(HTTP2CodecTest, DuplicateBadHeaderPriority) {\n  HTTPMessage req = getGetRequest();\n  req.setHTTP2Priority(HTTPMessage::HTTPPriority(0, false, 7));\n  upstreamCodec_.generateHeader(output_, 1, req, true );\n  EXPECT_TRUE(parse([&](IOBuf* ingress) {\n    folly::io::RWPrivateCursor c(ingress);\n    c.skip(http2::kFrameHeaderSize + http2::kConnectionPreface.length());\n    c.writeBE<uint32_t>(1);\n  }));\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  HTTPMessage nextRequest = getGetRequest();\n  upstreamCodec_.generateHeader(output_, 1, nextRequest, true );\n  parse();\n  EXPECT_EQ(callbacks_.streamErrors, 2);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}", "target": 0}
{"code": "static int handle_pte_fault(struct mm_struct *mm,\n\t\t     struct vm_area_struct *vma, unsigned long address,\n\t\t     pte_t *pte, pmd_t *pmd, unsigned int flags)\n{\n\tpte_t entry;\n\tspinlock_t *ptl;\n\tentry = *pte;\n\tbarrier();\n\tif (!pte_present(entry)) {\n\t\tif (pte_none(entry)) {\n\t\t\tif (vma->vm_ops) {\n\t\t\t\tif (likely(vma->vm_ops->fault))\n\t\t\t\t\treturn do_fault(mm, vma, address, pte,\n\t\t\t\t\t\t\tpmd, flags, entry);\n\t\t\t}\n\t\t\treturn do_anonymous_page(mm, vma, address,\n\t\t\t\t\t\t pte, pmd, flags);\n\t\t}\n\t\treturn do_swap_page(mm, vma, address,\n\t\t\t\t\tpte, pmd, flags, entry);\n\t}\n\tif (pte_protnone(entry))\n\t\treturn do_numa_page(mm, vma, address, entry, pte, pmd);\n\tptl = pte_lockptr(mm, pmd);\n\tspin_lock(ptl);\n\tif (unlikely(!pte_same(*pte, entry)))\n\t\tgoto unlock;\n\tif (flags & FAULT_FLAG_WRITE) {\n\t\tif (!pte_write(entry))\n\t\t\treturn do_wp_page(mm, vma, address,\n\t\t\t\t\tpte, pmd, ptl, entry);\n\t\tentry = pte_mkdirty(entry);\n\t}\n\tentry = pte_mkyoung(entry);\n\tif (ptep_set_access_flags(vma, address, pte, entry, flags & FAULT_FLAG_WRITE)) {\n\t\tupdate_mmu_cache(vma, address, pte);\n\t} else {\n\t\tif (flags & FAULT_FLAG_WRITE)\n\t\t\tflush_tlb_fix_spurious_fault(vma, address);\n\t}\nunlock:\n\tpte_unmap_unlock(pte, ptl);\n\treturn 0;\n}", "target": 1}
{"code": "static BOOL rdp_redirection_read_base64_wchar(UINT32 flag, wStream* s, UINT32* pLength,\n                                              BYTE** pData)\n{\n\tBOOL rc = FALSE;\n\tchar buffer[64] = { 0 };\n\tconst BYTE* ptr = NULL;\n\tif (!rdp_redirection_get_data(s, pLength, &ptr))\n\t\treturn FALSE;\n\tconst WCHAR* wchar = (const WCHAR*)ptr;\n\tsize_t utf8_len = 0;\n\tchar* utf8 = ConvertWCharNToUtf8Alloc(wchar, *pLength, &utf8_len);\n\tif (!utf8)\n\t\tgoto fail;\n\tredirection_free_data(pData, NULL);\n\tutf8_len = strnlen(utf8, utf8_len);\n\t*pData = calloc(utf8_len, sizeof(BYTE));\n\tif (!*pData)\n\t\tgoto fail;\n\tsize_t rlen = utf8_len;\n\tsize_t wpos = 0;\n\tchar* tok = strtok(utf8, \"\\r\\n\");\n\twhile (tok)\n\t{\n\t\tconst size_t len = strnlen(tok, rlen);\n\t\trlen -= len;\n\t\tsize_t bplen = 0;\n\t\tBYTE* bptr = NULL;\n\t\tcrypto_base64_decode(tok, len, &bptr, &bplen);\n\t\tif (!bptr)\n\t\t\tgoto fail;\n\t\tmemcpy(&(*pData)[wpos], bptr, bplen);\n\t\twpos += bplen;\n\t\tfree(bptr);\n\t\ttok = strtok(NULL, \"\\r\\n\");\n\t}\n\t*pLength = wpos;\n\tWLog_DBG(TAG, \"%s:\", rdp_redirection_flags_to_string(flag, buffer, sizeof(buffer)));\n\trc = TRUE;\nfail:\n\tif (!rc)\n\t\tWLog_ERR(TAG, \"failed to read base64 data\");\n\tfree(utf8);\n\treturn rc;\n}", "target": 1}
{"code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf)\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}", "target": 1}
{"code": "USHORT CNB::QueryL4HeaderOffset(PVOID PacketData, ULONG IpHeaderOffset) const\n{\n    USHORT Res;\n    auto ppr = ParaNdis_ReviewIPPacket(RtlOffsetToPointer(PacketData, IpHeaderOffset),\n                                       GetDataLength(), __FUNCTION__);\n    if (ppr.ipStatus != ppresNotIP)\n    {\n        Res = static_cast<USHORT>(IpHeaderOffset + ppr.ipHeaderSize);\n    }\n    else\n    {\n        DPrintf(0, (\"[%s] ERROR: NOT an IP packet - expected troubles!\\n\", __FUNCTION__));\n        Res = 0;\n    }\n    return Res;\n}", "target": 1}
{"code": "static int adpt_i2o_install_device(adpt_hba* pHba, struct i2o_device *d)\n{\n\tmutex_lock(&adpt_configuration_lock);\n\td->controller=pHba;\n\td->owner=NULL;\n\td->next=pHba->devices;\n\td->prev=NULL;\n\tif (pHba->devices != NULL){\n\t\tpHba->devices->prev=d;\n\t}\n\tpHba->devices=d;\n\t*d->dev_name = 0;\n\tmutex_unlock(&adpt_configuration_lock);\n\treturn 0;\n}", "target": 1}
{"code": "redraw_win_toolbar(win_T *wp)\n{\n    vimmenu_T\t*menu;\n    int\t\titem_idx = 0;\n    int\t\titem_count = 0;\n    int\t\tcol = 0;\n    int\t\tnext_col;\n    int\t\toff = (int)(current_ScreenLine - ScreenLines);\n    int\t\tfill_attr = syn_name2attr((char_u *)\"ToolbarLine\");\n    int\t\tbutton_attr = syn_name2attr((char_u *)\"ToolbarButton\");\n    vim_free(wp->w_winbar_items);\n    FOR_ALL_CHILD_MENUS(wp->w_winbar, menu)\n\t++item_count;\n    wp->w_winbar_items = ALLOC_CLEAR_MULT(winbar_item_T, item_count + 1);\n    for (menu = wp->w_winbar->children;\n\t\t\t  menu != NULL && col < wp->w_width; menu = menu->next)\n    {\n\tspace_to_screenline(off + col, fill_attr);\n\tif (++col >= wp->w_width)\n\t    break;\n\tif (col > 1)\n\t{\n\t    space_to_screenline(off + col, fill_attr);\n\t    if (++col >= wp->w_width)\n\t\tbreak;\n\t}\n\twp->w_winbar_items[item_idx].wb_startcol = col;\n\tspace_to_screenline(off + col, button_attr);\n\tif (++col >= wp->w_width)\n\t    break;\n\tnext_col = text_to_screenline(wp, menu->name, col);\n\twhile (col < next_col)\n\t{\n\t    ScreenAttrs[off + col] = button_attr;\n\t    ++col;\n\t}\n\twp->w_winbar_items[item_idx].wb_endcol = col;\n\twp->w_winbar_items[item_idx].wb_menu = menu;\n\t++item_idx;\n\tif (col >= wp->w_width)\n\t    break;\n\tspace_to_screenline(off + col, button_attr);\n\t++col;\n    }\n    while (col < wp->w_width)\n    {\n\tspace_to_screenline(off + col, fill_attr);\n\t++col;\n    }\n    wp->w_winbar_items[item_idx].wb_menu = NULL; \n    screen_line(wp->w_winrow, wp->w_wincol, (int)wp->w_width,\n\t\t\t\t\t\t\t  (int)wp->w_width, 0);\n}", "target": 0}
{"code": "MOBI_RET mobi_parse_huffdic(const MOBIData *m, MOBIHuffCdic *huffcdic) {\n    MOBI_RET ret;\n    const size_t offset = mobi_get_kf8offset(m);\n    if (m->mh == NULL || m->mh->huff_rec_index == NULL || m->mh->huff_rec_count == NULL) {\n        debug_print(\"%s\", \"HUFF/CDIC records metadata not found in MOBI header\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    const size_t huff_rec_index = *m->mh->huff_rec_index + offset;\n    const size_t huff_rec_count = *m->mh->huff_rec_count;\n    if (huff_rec_count > HUFF_RECORD_MAXCNT) {\n        debug_print(\"Too many HUFF record (%zu)\\n\", huff_rec_count);\n        return MOBI_DATA_CORRUPT;\n    }\n    const MOBIPdbRecord *curr = mobi_get_record_by_seqnumber(m, huff_rec_index);\n    if (curr == NULL || huff_rec_count < 2) {\n        debug_print(\"%s\", \"HUFF/CDIC record not found\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    if (curr->size < HUFF_RECORD_MINSIZE) {\n        debug_print(\"HUFF record too short (%zu b)\\n\", curr->size);\n        return MOBI_DATA_CORRUPT;\n    }\n    ret = mobi_parse_huff(huffcdic, curr);\n    if (ret != MOBI_SUCCESS) {\n        debug_print(\"%s\", \"HUFF parsing failed\\n\");\n        return ret;\n    }\n    curr = curr->next;\n    huffcdic->symbols = malloc((huff_rec_count - 1) * sizeof(*huffcdic->symbols));\n    if (huffcdic->symbols == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    size_t i = 0;\n    while (i < huff_rec_count - 1) {\n        if (curr == NULL) {\n            debug_print(\"%s\\n\", \"CDIC record not found\");\n            return MOBI_DATA_CORRUPT;\n        }\n        ret = mobi_parse_cdic(huffcdic, curr, i++);\n        if (ret != MOBI_SUCCESS) {\n            debug_print(\"%s\", \"CDIC parsing failed\\n\");\n            return ret;\n        }\n        curr = curr->next;\n    }\n    if (huffcdic->index_count != huffcdic->index_read) {\n        debug_print(\"CDIC: wrong read index count: %zu, total: %zu\\n\", huffcdic->index_read, huffcdic->index_count);\n        return MOBI_DATA_CORRUPT;\n    }\n    return MOBI_SUCCESS;\n}", "target": 0}
{"code": "kex_input_kexinit(int type, u_int32_t seq, void *ctxt)\n{\n\tstruct ssh *ssh = ctxt;\n\tstruct kex *kex = ssh->kex;\n\tconst u_char *ptr;\n\tu_int i;\n\tsize_t dlen;\n\tint r;\n\tdebug(\"SSH2_MSG_KEXINIT received\");\n\tif (kex == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tssh_dispatch_set(ssh, SSH2_MSG_KEXINIT, NULL);\n\tptr = sshpkt_ptr(ssh, &dlen);\n\tif ((r = sshbuf_put(kex->peer, ptr, dlen)) != 0)\n\t\treturn r;\n\tfor (i = 0; i < KEX_COOKIE_LEN; i++)\n\t\tif ((r = sshpkt_get_u8(ssh, NULL)) != 0)\n\t\t\treturn r;\n\tfor (i = 0; i < PROPOSAL_MAX; i++)\n\t\tif ((r = sshpkt_get_string(ssh, NULL, NULL)) != 0)\n\t\t\treturn r;\n\tif ((r = sshpkt_get_u8(ssh, NULL)) != 0 ||\t\n\t    (r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\t\treturn r;\n\tif (!(kex->flags & KEX_INIT_SENT))\n\t\tif ((r = kex_send_kexinit(ssh)) != 0)\n\t\t\treturn r;\n\tif ((r = kex_choose_conf(ssh)) != 0)\n\t\treturn r;\n\tif (kex->kex_type < KEX_MAX && kex->kex[kex->kex_type] != NULL)\n\t\treturn (kex->kex[kex->kex_type])(ssh);\n\treturn SSH_ERR_INTERNAL_ERROR;\n}", "target": 0}
{"code": "TEST(SerializerTest, DuplicateUnionData) {\n  const char data[] =\n      \"\\x0c\" \n      \"\\x00\\x01\" \n      \"\\x0b\" \n      \"\\x00\\x01\" \n      \"\\x00\\x00\\x00\\x00\" \n      \"\\x00\" \n      \"\\x0c\" \n      \"\\x00\\x01\" \n      \"\\x13\" \n      \"\\x00\\x02\"; \n  EXPECT_THROW(\n      BinarySerializer::deserialize<tablebased::TestStructWithUnion>(\n          folly::StringPiece(data, sizeof(data))),\n      std::out_of_range);\n}", "target": 0}
{"code": "modify_bar_registration(struct pci_vdev *dev, int idx, int registration)\n{\n\tint error;\n\tstruct inout_port iop;\n\tstruct mem_range mr;\n\tif (is_pci_gvt(dev)) {\n\t\tprintf(\"modify_bar_registration: bypass for pci-gvt\\n\");\n\t\treturn;\n\t}\n\tswitch (dev->bar[idx].type) {\n\tcase PCIBAR_IO:\n\t\tbzero(&iop, sizeof(struct inout_port));\n\t\tiop.name = dev->name;\n\t\tiop.port = dev->bar[idx].addr;\n\t\tiop.size = dev->bar[idx].size;\n\t\tif (registration) {\n\t\t\tiop.flags = IOPORT_F_INOUT;\n\t\t\tiop.handler = pci_emul_io_handler;\n\t\t\tiop.arg = dev;\n\t\t\terror = register_inout(&iop);\n\t\t} else\n\t\t\terror = unregister_inout(&iop);\n\t\tbreak;\n\tcase PCIBAR_MEM32:\n\tcase PCIBAR_MEM64:\n\t\tbzero(&mr, sizeof(struct mem_range));\n\t\tmr.name = dev->name;\n\t\tmr.base = dev->bar[idx].addr;\n\t\tmr.size = dev->bar[idx].size;\n\t\tif (registration) {\n\t\t\tmr.flags = MEM_F_RW;\n\t\t\tmr.handler = pci_emul_mem_handler;\n\t\t\tmr.arg1 = dev;\n\t\t\tmr.arg2 = idx;\n\t\t\terror = register_mem(&mr);\n\t\t} else\n\t\t\terror = unregister_mem(&mr);\n\t\tbreak;\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\tassert(error == 0);\n}", "target": 1}
{"code": "AP4_AvccAtom::InspectFields(AP4_AtomInspector& inspector)\n{\n    inspector.AddField(\"Configuration Version\", m_ConfigurationVersion);\n    const char* profile_name = GetProfileName(m_Profile);\n    if (profile_name) {\n        inspector.AddField(\"Profile\", profile_name);\n    } else {\n        inspector.AddField(\"Profile\", m_Profile);\n    }\n    inspector.AddField(\"Profile Compatibility\", m_ProfileCompatibility, AP4_AtomInspector::HINT_HEX);\n    inspector.AddField(\"Level\", m_Level);\n    inspector.AddField(\"NALU Length Size\", m_NaluLengthSize);\n    for (unsigned int i=0; i<m_SequenceParameters.ItemCount(); i++) {\n        inspector.AddField(\"Sequence Parameter\", m_SequenceParameters[i].GetData(), m_SequenceParameters[i].GetDataSize());\n    }\n    for (unsigned int i=0; i<m_SequenceParameters.ItemCount(); i++) {\n        inspector.AddField(\"Picture Parameter\", m_PictureParameters[i].GetData(), m_PictureParameters[i].GetDataSize());\n    }\n    return AP4_SUCCESS;\n}", "target": 1}
{"code": "Status ImportNodes(ValueMapManager value_manager,\n                   const RepeatedPtrField<NodeDef>& nodes, OpBuilder& builder) {\n  Location unknown_loc = builder.getUnknownLoc();\n  MLIRContext* context = builder.getContext();\n  Type placeholder_ty = OpaqueTensorType::get(context);\n  Type control_ty = ControlType::get(context);\n  TFGraphDialect* tfgDialect =\n      cast<TFGraphDialect>(context->getLoadedDialect(\"tfg\"));\n  StringAttr device_attr = tfgDialect->getDeviceAttrIdentifier();\n  StringAttr name_attr = tfgDialect->getNameAttrIdentifier();\n  StringAttr fulltype_attr = tfgDialect->getFullTypeAttrIdentifier();\n  for (const NodeDef& node : nodes) {\n    DVLOG(1) << \"Processing node \" << node.name() << \"\\n\";\n    if (node.op().empty()) return InvalidArgument(\"empty op type\");\n    OperationState state(unknown_loc, absl::StrCat(\"tfg.\", node.op()));\n    for (const std::string& input : node.input())\n      state.operands.push_back(\n          value_manager.GetValueOrCreatePlaceholder(input));\n    state.types.push_back(placeholder_ty);\n    state.types.push_back(control_ty);\n    for (const auto& namedAttr : node.attr()) {\n      const std::string& name = namedAttr.first;\n      const AttrValue& tf_attr = namedAttr.second;\n      TF_ASSIGN_OR_RETURN(Attribute attr,\n                          ConvertAttributeValue(tf_attr, builder, tfgDialect));\n      state.addAttribute(name, attr);\n    }\n    if (!node.device().empty())\n      state.addAttribute(device_attr, StringAttr::get(context, node.device()));\n    if (!node.name().empty())\n      state.addAttribute(name_attr, StringAttr::get(context, node.name()));\n    if (node.has_experimental_type()) {\n      TF_ASSIGN_OR_RETURN(\n          tf_type::FullTypeAttr type,\n          ConvertAttribute(node.experimental_type(), builder, tfgDialect));\n      state.addAttribute(fulltype_attr, type);\n    }\n    Operation* op = builder.create(state);\n    StringRef node_name = node.name();\n    {\n      size_t colon_sep = node_name.find_first_of(':');\n      if (colon_sep != StringRef::npos)\n        node_name = node_name.take_front(colon_sep);\n    }\n    TF_RETURN_IF_ERROR(value_manager.DefineOperation(op, node_name));\n  }\n  for (Operation& op : *builder.getInsertionBlock()) {\n    if (op.getName().getStringRef() == \"tfg.__mlir_placeholder\") {\n      return InvalidArgument(absl::StrCat(\n          \"Couldn't import graph: placeholder left \",\n          op.getAttrOfType<StringAttr>(name_attr).getValue().str()));\n    }\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "GtkTreeModel *bluetooth_client_get_model (BluetoothClient *client)\n{\n\tBluetoothClientPrivate *priv;\n\tGtkTreeModel *model;\n\tg_return_val_if_fail (BLUETOOTH_IS_CLIENT (client), NULL);\n\tpriv = BLUETOOTH_CLIENT_GET_PRIVATE(client);\n\tmodel = GTK_TREE_MODEL (g_object_ref(priv->store));\n\treturn model;\n}", "target": 0}
{"code": "parse_notification(struct rpki_uri *uri, struct update_notification **file)\n{\n\tstruct rdr_notification_ctx ctx;\n\tstruct update_notification *tmp;\n\tchar *dup;\n\tint error;\n\tdup = strdup(uri_get_global(uri));\n\tif (dup == NULL)\n\t\treturn pr_enomem();\n\terror = update_notification_create(&tmp);\n\tif (error)\n\t\treturn error;\n\ttmp->uri = dup;\n\tctx.notification = tmp;\n\terror = relax_ng_parse(uri_get_local(uri), xml_read_notification,\n\t    &ctx);\n\tif (error) {\n\t\tupdate_notification_destroy(tmp);\n\t\treturn error;\n\t}\n\t*file = tmp;\n\treturn 0;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    Tensor encoded_t = context->input(0);\n    OP_REQUIRES(\n        context, encoded_t.flat<Variant>().size() > 0,\n        errors::InvalidArgument(\"Input `encoded` must not be an empty variant \"\n                                \"tensor, but got \",\n                                encoded_t.DebugString()));\n    auto* encoded = encoded_t.flat<Variant>()(0).get<CompositeTensorVariant>();\n    OP_REQUIRES(context, encoded != nullptr,\n                errors::InvalidArgument(\"The input `encoded` is not a valid \"\n                                        \"CompositeTensorVariant tensor, got \",\n                                        encoded_t.DebugString()));\n    auto expected_class = metadata_.type_spec_proto().type_spec_class();\n    auto actual_class = encoded->metadata().type_spec_proto().type_spec_class();\n    OP_REQUIRES(\n        context, expected_class == actual_class,\n        errors::InvalidArgument(\n            \"Expected a \", TypeSpecProto::TypeSpecClass_Name(expected_class),\n            \" (based on `type_spec`), but `encoded` contains a \",\n            TypeSpecProto::TypeSpecClass_Name(actual_class)));\n    OpOutputList components;\n    OP_REQUIRES_OK(context, context->output_list(\"components\", &components));\n    int num_components = encoded->flat_components().size();\n    OP_REQUIRES(context, component_dtypes_.size() == num_components,\n                errors::InvalidArgument(\"Encoded value has \", num_components,\n                                        \" tensor components; expected \",\n                                        component_dtypes_.size(),\n                                        \" components based on type_spec\"));\n    for (int i = 0; i < component_dtypes_.size(); i++) {\n      const Tensor& component = encoded->flat_components()[i];\n      OP_REQUIRES(context, component_dtypes_[i] == component.dtype(),\n                  errors::InvalidArgument(\"Tensor component \", i, \" had dtype \",\n                                          DataType_Name(component.dtype()),\n                                          \"; expected dtype \",\n                                          DataType_Name(component_dtypes_[i])));\n      components.set(i, component);\n    }\n  }", "target": 0}
{"code": "static inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsigned int src_size, double scale_d,  const interpolation_method pFilter)\n{\n\tdouble width_d;\n\tdouble scale_f_d = 1.0;\n\tconst double filter_width_d = DEFAULT_BOX_RADIUS;\n\tint windows_size;\n\tunsigned int u;\n\tLineContribType *res;\n\tif (scale_d < 1.0) {\n\t\twidth_d = filter_width_d / scale_d;\n\t\tscale_f_d = scale_d;\n\t}  else {\n\t\twidth_d= filter_width_d;\n\t}\n\twindows_size = 2 * (int)ceil(width_d) + 1;\n\tres = _gdContributionsAlloc(line_size, windows_size);\n\tfor (u = 0; u < line_size; u++) {\n\t\tconst double dCenter = (double)u / scale_d;\n\t\tregister int iLeft = MAX(0, (int)floor (dCenter - width_d));\n\t\tint iRight = MIN((int)ceil(dCenter + width_d), (int)src_size - 1);\n\t\tdouble dTotalWeight = 0.0;\n\t\tint iSrc;\n\t\tres->ContribRow[u].Left = iLeft;\n\t\tres->ContribRow[u].Right = iRight;\n\t\tif (iRight - iLeft + 1 > windows_size)  {\n\t\t\tif (iLeft < ((int)src_size - 1 / 2))  {\n\t\t\t\tiLeft++;\n\t\t\t} else {\n\t\t\t\tiRight--;\n\t\t\t}\n\t\t}\n\t\tfor (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n\t\t\tdTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc)));\n\t\t}\n\t\tif (dTotalWeight < 0.0) {\n\t\t\t_gdContributionsFree(res);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (dTotalWeight > 0.0) {\n\t\t\tfor (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n\t\t\t\tres->ContribRow[u].Weights[iSrc-iLeft] /= dTotalWeight;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}", "target": 1}
{"code": "PHP_FUNCTION(snmp2_set)\n{\n\tphp_snmp(INTERNAL_FUNCTION_PARAM_PASSTHRU, SNMP_CMD_SET, SNMP_VERSION_2c);\n}", "target": 0}
{"code": "static void rekey_seq_generator(struct work_struct *work)\n{\n\tstruct keydata *keyptr = &ip_keydata[1 ^ (ip_cnt & 1)];\n\tget_random_bytes(keyptr->secret, sizeof(keyptr->secret));\n\tkeyptr->count = (ip_cnt & COUNT_MASK) << HASH_BITS;\n\tsmp_wmb();\n\tip_cnt++;\n\tschedule_delayed_work(&rekey_work,\n\t\t\t      round_jiffies_relative(REKEY_INTERVAL));\n}", "target": 1}
{"code": "apr_byte_t oidc_enabled(request_rec *r) {\n\tif (ap_auth_type(r) == NULL)\n\t\treturn FALSE;\n\tif (apr_strnatcasecmp((const char*) ap_auth_type(r),\n\t\t\tOIDC_AUTH_TYPE_OPENID_CONNECT) == 0)\n\t\treturn TRUE;\n\tif (apr_strnatcasecmp((const char*) ap_auth_type(r),\n\t\t\tOIDC_AUTH_TYPE_OPENID_OAUTH20) == 0)\n\t\treturn TRUE;\n\tif (apr_strnatcasecmp((const char*) ap_auth_type(r),\n\t\t\tOIDC_AUTH_TYPE_OPENID_BOTH) == 0)\n\t\treturn TRUE;\n\treturn FALSE;\n}", "target": 0}
{"code": "static inline bool cpu_has_vmx_ept_mt_wb(void)\n{\n\treturn vmx_capability.ept & VMX_EPTP_WB_BIT;\n}", "target": 0}
{"code": "static long btrfs_ioctl_dev_info(struct btrfs_fs_info *fs_info,\n\t\t\t\t void __user *arg)\n{\n\tstruct btrfs_ioctl_dev_info_args *di_args;\n\tstruct btrfs_device *dev;\n\tint ret = 0;\n\tchar *s_uuid = NULL;\n\tdi_args = memdup_user(arg, sizeof(*di_args));\n\tif (IS_ERR(di_args))\n\t\treturn PTR_ERR(di_args);\n\tif (!btrfs_is_empty_uuid(di_args->uuid))\n\t\ts_uuid = di_args->uuid;\n\trcu_read_lock();\n\tdev = btrfs_find_device(fs_info->fs_devices, di_args->devid, s_uuid,\n\t\t\t\tNULL);\n\tif (!dev) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\tdi_args->devid = dev->devid;\n\tdi_args->bytes_used = btrfs_device_get_bytes_used(dev);\n\tdi_args->total_bytes = btrfs_device_get_total_bytes(dev);\n\tmemcpy(di_args->uuid, dev->uuid, sizeof(di_args->uuid));\n\tif (dev->name) {\n\t\tstrncpy(di_args->path, rcu_str_deref(dev->name),\n\t\t\t\tsizeof(di_args->path) - 1);\n\t\tdi_args->path[sizeof(di_args->path) - 1] = 0;\n\t} else {\n\t\tdi_args->path[0] = '\\0';\n\t}\nout:\n\trcu_read_unlock();\n\tif (ret == 0 && copy_to_user(arg, di_args, sizeof(*di_args)))\n\t\tret = -EFAULT;\n\tkfree(di_args);\n\treturn ret;\n}", "target": 1}
{"code": "static unsigned long pfn_max_align_down(unsigned long pfn)\n{\n\treturn pfn & ~(max_t(unsigned long, MAX_ORDER_NR_PAGES,\n\t\t\t     pageblock_nr_pages) - 1);\n}", "target": 0}
{"code": "BGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)\n{\n\tgdIOCtx *out = gdNewFileCtx(outFile);\n\tif (out == NULL) {\n\t\treturn;\n\t}\n\tgdImageWebpCtx(im, out, -1);\n\tout->gd_free(out);\n}", "target": 1}
{"code": "int secure_decrypt(void *data, unsigned int data_length, int is_signed)\n{\n\tat91_aes_key_size_t key_size;\n\tunsigned int cmac_key[8], cipher_key[8];\n\tunsigned int iv[AT91_AES_IV_SIZE_WORD];\n\tunsigned int computed_cmac[AT91_AES_BLOCK_SIZE_WORD];\n\tunsigned int fixed_length;\n\tconst unsigned int *cmac;\n\tint rc = -1;\n\tinit_keys(&key_size, cipher_key, cmac_key, iv);\n\tat91_aes_init();\n\tif (is_signed) {\n\t\tif (at91_aes_cmac(data_length, data, computed_cmac,\n\t\t\t\t  key_size, cmac_key))\n\t\t\tgoto exit;\n\t\tfixed_length = at91_aes_roundup(data_length);\n\t\tcmac = (const unsigned int *)((char *)data + fixed_length);\n\t\tif (memcmp(cmac, computed_cmac, AT91_AES_BLOCK_SIZE_BYTE))\n\t\t\tgoto exit;\n\t}\n\tif (at91_aes_cbc(data_length, data, data, 0,\n\t\t\t key_size, cipher_key, iv))\n\t\tgoto exit;\n\trc = 0;\nexit:\n\tat91_aes_cleanup();\n\tmemset(cmac_key, 0, sizeof(cmac_key));\n\tmemset(cipher_key, 0, sizeof(cipher_key));\n\tmemset(iv, 0, sizeof(iv));\n\treturn rc;\n}", "target": 1}
{"code": "static void vgacon_scrolldelta(struct vc_data *c, int lines)\n{\n\tint start, end, count, soff;\n\tif (!lines) {\n\t\tvgacon_restore_screen(c);\n\t\treturn;\n\t}\n\tif (!vgacon_scrollback_cur->data)\n\t\treturn;\n\tif (!vgacon_scrollback_cur->save) {\n\t\tvgacon_cursor(c, CM_ERASE);\n\t\tvgacon_save_screen(c);\n\t\tc->vc_origin = (unsigned long)c->vc_screenbuf;\n\t\tvgacon_scrollback_cur->save = 1;\n\t}\n\tvgacon_scrollback_cur->restore = 0;\n\tstart = vgacon_scrollback_cur->cur + lines;\n\tend = start + abs(lines);\n\tif (start < 0)\n\t\tstart = 0;\n\tif (start > vgacon_scrollback_cur->cnt)\n\t\tstart = vgacon_scrollback_cur->cnt;\n\tif (end < 0)\n\t\tend = 0;\n\tif (end > vgacon_scrollback_cur->cnt)\n\t\tend = vgacon_scrollback_cur->cnt;\n\tvgacon_scrollback_cur->cur = start;\n\tcount = end - start;\n\tsoff = vgacon_scrollback_cur->tail -\n\t\t((vgacon_scrollback_cur->cnt - end) * c->vc_size_row);\n\tsoff -= count * c->vc_size_row;\n\tif (soff < 0)\n\t\tsoff += vgacon_scrollback_cur->size;\n\tcount = vgacon_scrollback_cur->cnt - start;\n\tif (count > c->vc_rows)\n\t\tcount = c->vc_rows;\n\tif (count) {\n\t\tint copysize;\n\t\tint diff = c->vc_rows - count;\n\t\tvoid *d = (void *) c->vc_visible_origin;\n\t\tvoid *s = (void *) c->vc_screenbuf;\n\t\tcount *= c->vc_size_row;\n\t\tcopysize = min(count, vgacon_scrollback_cur->size - soff);\n\t\tscr_memcpyw(d, vgacon_scrollback_cur->data + soff, copysize);\n\t\td += copysize;\n\t\tcount -= copysize;\n\t\tif (count) {\n\t\t\tscr_memcpyw(d, vgacon_scrollback_cur->data, count);\n\t\t\td += count;\n\t\t}\n\t\tif (diff)\n\t\t\tscr_memcpyw(d, s, diff * c->vc_size_row);\n\t} else\n\t\tvgacon_cursor(c, CM_MOVE);\n}", "target": 1}
{"code": "skip_varname(const char *s, bool aok)\n{\n\tsize_t alen;\n\tif (s && ksh_isalphx(*s)) {\n\t\twhile (*++s && ksh_isalnux(*s))\n\t\t\t;\n\t\tif (aok && *s == '[' && (alen = array_ref_len(s)))\n\t\t\ts += alen;\n\t}\n\treturn (s);\n}", "target": 0}
{"code": "static inline __attribute__((unused)) ssize_t fiobj_send_free(intptr_t uuid,\n                                                              FIOBJ o) {\n  fio_str_info_s s = fiobj_obj2cstr(o);\n  return fio_write2(uuid, .data.buffer = (void *)(o),\n                    .offset = (((intptr_t)s.data) - ((intptr_t)(o))),\n                    .length = s.len, .after.dealloc = fiobj4sock_dealloc);\n}", "target": 1}
{"code": "bool Router::MatchView(const std::string& method, const std::string& url,\n                       bool* stream) {\n  assert(stream != nullptr);\n  *stream = false;\n  for (auto& route : routes_) {\n    if (std::find(route.methods.begin(), route.methods.end(), method) ==\n        route.methods.end()) {\n      continue;\n    }\n    if (route.url.empty()) {\n      std::smatch match;\n      if (std::regex_match(url, match, route.url_regex)) {\n        *stream = route.view->Stream(method);\n        return true;\n      }\n    } else {\n      if (boost::iequals(route.url, url)) {\n        *stream = route.view->Stream(method);\n        return true;\n      }\n    }\n  }\n  return false;\n}", "target": 1}
{"code": "imapx_unset_folder_flagged_flag (CamelFolderSummary *summary,\n\t\t\t\t GPtrArray *changed_uids,\n\t\t\t\t gboolean except_deleted_messages)\n{\n\tCamelMessageInfo *info;\n\tgboolean changed = FALSE;\n\tgint ii;\n\tg_return_if_fail (CAMEL_IS_FOLDER_SUMMARY (summary));\n\tg_return_if_fail (changed_uids != NULL);\n\tfor (ii = 0; ii < changed_uids->len; ii++) {\n\t\tinfo = camel_folder_summary_get (summary, changed_uids->pdata[ii]);\n\t\tif (info) {\n\t\t\tCamelMessageInfoBase *mi = (CamelMessageInfoBase *) info;\n\t\t\tif ((mi->flags & CAMEL_MESSAGE_FOLDER_FLAGGED) != 0 &&\n\t\t\t   (!except_deleted_messages || (mi->flags & CAMEL_MESSAGE_DELETED) == 0)) {\n\t\t\t\tmi->flags &= ~CAMEL_MESSAGE_FOLDER_FLAGGED;\n\t\t\t\tmi->dirty = TRUE;\n\t\t\t\tchanged = TRUE;\n\t\t\t}\n\t\t\tcamel_message_info_unref (info);\n\t\t}\n\t}\n\tif (changed) {\n\t\tcamel_folder_summary_touch (summary);\n\t\tcamel_folder_summary_save_to_db (summary, NULL);\n\t}\n}", "target": 0}
{"code": "is_char_safe (gunichar c)\n{\n  return g_unichar_isgraph (c) || c == ' ';\n}", "target": 0}
{"code": "char *path_name(const struct name_path *path, const char *name)\n{\n\tconst struct name_path *p;\n\tchar *n, *m;\n\tint nlen = strlen(name);\n\tint len = nlen + 1;\n\tfor (p = path; p; p = p->up) {\n\t\tif (p->elem_len)\n\t\t\tlen += p->elem_len + 1;\n\t}\n\tn = xmalloc(len);\n\tm = n + len - (nlen + 1);\n\tstrcpy(m, name);\n\tfor (p = path; p; p = p->up) {\n\t\tif (p->elem_len) {\n\t\t\tm -= p->elem_len + 1;\n\t\t\tmemcpy(m, p->elem, p->elem_len);\n\t\t\tm[p->elem_len] = '/';\n\t\t}\n\t}\n\treturn n;\n}", "target": 1}
{"code": "apr_byte_t oidc_cache_get(request_rec *r, const char *section, const char *key,\n\t\tchar **value) {\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\tint encrypted = oidc_cfg_cache_encrypt(r);\n\tapr_byte_t rc = TRUE;\n\tchar *msg = NULL;\n\toidc_debug(r, \"enter: %s (section=%s, decrypt=%d, type=%s)\", key, section,\n\t\t\tencrypted, cfg->cache->name);\n\tif (encrypted == 1)\n\t\tkey = oidc_cache_get_hashed_key(r, cfg->crypto_passphrase, key);\n\tconst char *cache_value = NULL;\n\tif (cfg->cache->get(r, section, key, &cache_value) == FALSE) {\n\t\trc = FALSE;\n\t\tgoto out;\n\t}\n\tif (cache_value == NULL)\n\t\tgoto out;\n\tif (encrypted == 0) {\n\t\t*value = apr_pstrdup(r->pool, cache_value);\n\t\tgoto out;\n\t}\n\trc = (oidc_cache_crypto_decrypt(r, cache_value,\n\t\t\toidc_cache_hash_passphrase(r, cfg->crypto_passphrase),\n\t\t\t(unsigned char **) value) > 0);\nout:\n\tmsg = apr_psprintf(r->pool, \"from %s cache backend for %skey %s\",\n\t\t\tcfg->cache->name, encrypted ? \"encrypted \" : \"\", key);\n\tif (rc == TRUE)\n\t\tif (*value != NULL)\n\t\t\toidc_debug(r, \"cache hit: return %d bytes %s\",\n\t\t\t\t\t*value ? (int )strlen(*value) : 0, msg);\n\t\telse\n\t\t\toidc_debug(r, \"cache miss %s\", msg);\n\telse\n\t\toidc_warn(r, \"error retrieving value %s\", msg);\n\treturn rc;\n}", "target": 1}
{"code": "snmp_ber_encode_integer(unsigned char *out, uint32_t *out_len, uint32_t number)\n{\n  uint32_t original_out_len;\n  original_out_len = *out_len;\n  do {\n    (*out_len)++;\n    *out-- = (uint8_t)(number & 0xFF);\n    number >>= 8;\n  } while(number);\n  out = snmp_ber_encode_length(out, out_len, ((*out_len - original_out_len) & 0xFF));\n  out = snmp_ber_encode_type(out, out_len, BER_DATA_TYPE_INTEGER);\n  return out;\n}", "target": 1}
{"code": "static struct scatterlist *alloc_sgtable(int size)\n{\n\tint alloc_size, nents, i;\n\tstruct page *new_page;\n\tstruct scatterlist *iter;\n\tstruct scatterlist *table;\n\tnents = DIV_ROUND_UP(size, PAGE_SIZE);\n\ttable = kcalloc(nents, sizeof(*table), GFP_KERNEL);\n\tif (!table)\n\t\treturn NULL;\n\tsg_init_table(table, nents);\n\titer = table;\n\tfor_each_sg(table, iter, sg_nents(table), i) {\n\t\tnew_page = alloc_page(GFP_KERNEL);\n\t\tif (!new_page) {\n\t\t\titer = table;\n\t\t\tfor_each_sg(table, iter, sg_nents(table), i) {\n\t\t\t\tnew_page = sg_page(iter);\n\t\t\t\tif (new_page)\n\t\t\t\t\t__free_page(new_page);\n\t\t\t}\n\t\t\tkfree(table);\n\t\t\treturn NULL;\n\t\t}\n\t\talloc_size = min_t(int, size, PAGE_SIZE);\n\t\tsize -= PAGE_SIZE;\n\t\tsg_set_page(iter, new_page, alloc_size, 0);\n\t}\n\treturn table;\n}", "target": 0}
{"code": "_dbus_credentials_add_from_current_process (DBusCredentials *credentials)\n{\n  _dbus_assert (sizeof (pid_t) <= sizeof (dbus_pid_t));\n  _dbus_assert (sizeof (uid_t) <= sizeof (dbus_uid_t));\n  _dbus_assert (sizeof (gid_t) <= sizeof (dbus_gid_t));\n  if (!_dbus_credentials_add_unix_pid(credentials, _dbus_getpid()))\n    return FALSE;\n  if (!_dbus_credentials_add_unix_uid(credentials, _dbus_geteuid()))\n    return FALSE;\n  return TRUE;\n}", "target": 0}
{"code": "void PluginInfoMessageFilter::OnGetPluginInfo(\n    int render_view_id,\n    const GURL& url,\n    const GURL& top_origin_url,\n    const std::string& mime_type,\n    IPC::Message* reply_msg) {\n  GetPluginInfo_Params params = {\n    render_view_id,\n    url,\n    top_origin_url,\n    mime_type\n  };\n  PluginService::GetInstance()->GetPlugins(\n      base::Bind(&PluginInfoMessageFilter::PluginsLoaded,\n                 weak_ptr_factory_.GetWeakPtr(),\n                 params, reply_msg));\n}", "target": 0}
{"code": "static size_t write_cb(void *contents, size_t size, size_t nmemb, void *data)\n{\n    size_t realsize = 0;\n    connection_t *conn = NULL;\n    char *ptr = NULL;\n    conn = data;\n    ogs_assert(conn);\n    realsize = size * nmemb;\n    ptr = ogs_realloc(conn->memory, conn->size + realsize + 1);\n    if(!ptr) {\n        ogs_fatal(\"not enough memory (realloc returned NULL)\");\n        ogs_assert_if_reached();\n        return 0;\n    }\n    conn->memory = ptr;\n    memcpy(&(conn->memory[conn->size]), contents, realsize);\n    conn->size += realsize;\n    conn->memory[conn->size] = 0;\n    return realsize;\n}", "target": 1}
{"code": "static void megasas_command_cancelled(SCSIRequest *req)\n{\n    MegasasCmd *cmd = req->hba_private;\n    if (!cmd) {\n        return;\n    }\n    cmd->frame->header.cmd_status = MFI_STAT_SCSI_IO_FAILED;\n    megasas_complete_command(cmd);\n}", "target": 0}
{"code": "static int validate_code_challenge(json_t * j_result_code, const char * code_verifier) {\n  int ret;\n  unsigned char code_verifier_hash[32] = {0}, code_verifier_hash_b64[64] = {0};\n  size_t code_verifier_hash_len = 32, code_verifier_hash_b64_len = 0;\n  gnutls_datum_t key_data;\n  if (!json_string_null_or_empty(json_object_get(j_result_code, \"code_challenge\"))) {\n    if (is_pkce_char_valid(code_verifier)) {\n      if (0 == o_strncmp(GLEWLWYD_CODE_CHALLENGE_S256_PREFIX, json_string_value(json_object_get(j_result_code, \"code_challenge\")), o_strlen(GLEWLWYD_CODE_CHALLENGE_S256_PREFIX))) {\n        key_data.data = (unsigned char *)code_verifier;\n        key_data.size = (unsigned int)o_strlen(code_verifier);\n        if (gnutls_fingerprint(GNUTLS_DIG_SHA256, &key_data, code_verifier_hash, &code_verifier_hash_len) == GNUTLS_E_SUCCESS) {\n          if (o_base64url_encode(code_verifier_hash, code_verifier_hash_len, code_verifier_hash_b64, &code_verifier_hash_b64_len)) {\n            code_verifier_hash_b64[code_verifier_hash_b64_len] = '\\0';\n            if (0 == o_strcmp(json_string_value(json_object_get(j_result_code, \"code_challenge\"))+o_strlen(GLEWLWYD_CODE_CHALLENGE_S256_PREFIX), (const char *)code_verifier_hash_b64)) {\n              ret = G_OK;\n            } else {\n              ret = G_ERROR_UNAUTHORIZED;\n            }\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"validate_code_challenge - Error o_base64url_encode\");\n            ret = G_ERROR;\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"validate_code_challenge - Error gnutls_fingerprint\");\n          ret = G_ERROR;\n        }\n      } else {\n        if (0 == o_strcmp(json_string_value(json_object_get(j_result_code, \"code_challenge\")), code_verifier)) {\n          ret = G_OK;\n        } else {\n          ret = G_ERROR_PARAM;\n        }\n      }\n    } else {\n      ret = G_ERROR_PARAM;\n    }\n  } else {\n    ret = G_OK;\n  }\n  return ret;\n}", "target": 1}
{"code": "BOOL security_decrypt(BYTE* data, int length, rdpRdp* rdp)\n{\n\tif (rdp->rc4_decrypt_key == NULL)\n\t\treturn FALSE;\n\tif (rdp->decrypt_use_count >= 4096)\n\t{\n\t\tsecurity_key_update(rdp->decrypt_key, rdp->decrypt_update_key, rdp->rc4_key_len);\n\t\tcrypto_rc4_free(rdp->rc4_decrypt_key);\n\t\trdp->rc4_decrypt_key = crypto_rc4_init(rdp->decrypt_key, rdp->rc4_key_len);\n\t\trdp->decrypt_use_count = 0;\n\t}\n\tcrypto_rc4(rdp->rc4_decrypt_key, length, data, data);\n\trdp->decrypt_use_count += 1;\n\trdp->decrypt_checksum_use_count++;\n\treturn TRUE;\n}", "target": 0}
{"code": "static uint32_t mp_clzl(unsigned long x) {\n    unsigned long lz = 0;\n    return _BitScanReverse(&lz, x) ? (sizeof(x) * 8 - 1) - lz : 0;\n}", "target": 0}
{"code": "int test_sqr(BIO *bp, BN_CTX *ctx)\n\t{\n\tBIGNUM a,c,d,e;\n\tint i;\n\tBN_init(&a);\n\tBN_init(&c);\n\tBN_init(&d);\n\tBN_init(&e);\n\tfor (i=0; i<num0; i++)\n\t\t{\n\t\tBN_bntest_rand(&a,40+i*10,0,0);\n\t\ta.neg=rand_neg();\n\t\tBN_sqr(&c,&a,ctx);\n\t\tif (bp != NULL)\n\t\t\t{\n\t\t\tif (!results)\n\t\t\t\t{\n\t\t\t\tBN_print(bp,&a);\n\t\t\t\tBIO_puts(bp,\" * \");\n\t\t\t\tBN_print(bp,&a);\n\t\t\t\tBIO_puts(bp,\" - \");\n\t\t\t\t}\n\t\t\tBN_print(bp,&c);\n\t\t\tBIO_puts(bp,\"\\n\");\n\t\t\t}\n\t\tBN_div(&d,&e,&c,&a,ctx);\n\t\tBN_sub(&d,&d,&a);\n\t\tif(!BN_is_zero(&d) || !BN_is_zero(&e))\n\t\t    {\n\t\t    fprintf(stderr,\"Square test failed!\\n\");\n\t\t    return 0;\n\t\t    }\n\t\t}\n\tBN_free(&a);\n\tBN_free(&c);\n\tBN_free(&d);\n\tBN_free(&e);\n\treturn(1);\n\t}", "target": 1}
{"code": "mmsServer_handleFileDeleteRequest(\n    MmsServerConnection connection,\n    uint8_t* buffer, int bufPos, int maxBufPos,\n    uint32_t invokeId,\n    ByteBuffer* response)\n{\n    if (buffer[bufPos++] != 0x19)\n        goto exit_reject_invalid_pdu;\n    int length;\n    bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n    if (bufPos == -1)\n        goto exit_reject_invalid_pdu;\n    if (length > 255) {\n        mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT, response);\n        return;\n    }\n    char filename[256];\n    memcpy(filename, buffer + bufPos, length);\n    filename[length] = 0;\n    if (DEBUG_MMS_SERVER)\n        printf(\"MMS_SERVER: mms_file_service.c: Delete file (%s)\\n\", filename);\n    if (mmsMsg_isFilenameSave(filename) == false)\n    {\n        if (DEBUG_MMS_SERVER)\n            printf(\"MMS_SERVER: remote provided unsave filename -> rejected\\n\");\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n        return;\n    }\n    if (connection->server->fileAccessHandler != NULL) {\n        MmsError access = connection->server->fileAccessHandler(connection->server->fileAccessHandlerParameter,\n                            connection, MMS_FILE_ACCESS_TYPE_DELETE, filename, NULL);\n        if (access != MMS_ERROR_NONE) {\n            mmsMsg_createServiceErrorPdu(invokeId, response, access);\n            return;\n        }\n    }\n    if (!getFileInfo(MmsServerConnection_getFilesystemBasepath(connection), filename, NULL, NULL)) {\n        if (DEBUG_MMS_SERVER)\n            printf(\"MMS_SERVER: mms_file_service.c:  File (%s) not found\\n\", filename);\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n        return;\n    }\n    if (!deleteFile(MmsServerConnection_getFilesystemBasepath(connection), filename)) {\n        if (DEBUG_MMS_SERVER)\n            printf(\"MMS_SERVER: mms_file_service.c:  Delete file (%s) failed\\n\", filename);\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_ACCESS_DENIED);\n        return;\n    }\n    createNullResponseExtendedTag(invokeId, response, 0x4c);\n    return;\nexit_reject_invalid_pdu:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n}", "target": 0}
{"code": "set_cs_start(char *line)\n{\n  char *p, *q, *r;\n  if ((p = strstr(line, \"string currentfile\"))) {\n    if (!strstr(line, \"readstring\"))\n      return;\n    *p = '\\0';\t\t\t\t\t  \n    q = strrchr(line, '/');\n    if (q) {\n      r = cs_start;\n      ++q;\n      while (!isspace(*q) && *q != '{')\n\t*r++ = *q++;\n      *r = '\\0';\n    }\n    *p = 's';\t\t\t\t\t  \n  }\n}", "target": 1}
{"code": "namespace{void nop(){}}", "target": 0}
{"code": "njs_json_parse_iterator_call(njs_vm_t *vm, njs_json_parse_t *parse,\n    njs_json_state_t *state)\n{\n    njs_int_t          ret;\n    njs_value_t        arguments[3], *value;\n    njs_object_prop_t  *prop;\n    prop = state->prop;\n    arguments[0] = state->value;\n    arguments[1] = state->keys->start[state->index++];\n    switch (prop->type) {\n    case NJS_PROPERTY:\n        arguments[2] = prop->value;\n        ret = njs_function_apply(vm, parse->function, arguments, 3,\n                                 &parse->retval);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n        if (njs_is_undefined(&parse->retval)) {\n            prop->type = NJS_WHITEOUT;\n        } else {\n            prop->value = parse->retval;\n        }\n        break;\n    case NJS_PROPERTY_REF:\n        value = prop->value.data.u.value;\n        arguments[2] = *value;\n        ret = njs_function_apply(vm, parse->function, arguments, 3,\n                                 &parse->retval);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n        if (njs_is_undefined(&parse->retval)) {\n            ret = njs_value_property_i64_delete(vm, &state->value,\n                                                state->index - 1, NULL);\n        } else {\n            ret = njs_value_property_i64_set(vm, &state->value,\n                                             state->index - 1, &parse->retval);\n        }\n        if (njs_slow_path(ret == NJS_ERROR)) {\n            return NJS_ERROR;\n        }\n        break;\n    default:\n        njs_internal_error(vm, \"njs_json_parse_iterator_call() unexpected \"\n                         \"property type:%s\", njs_prop_type_string(prop->type));\n    }\n    return NJS_OK;\n}", "target": 1}
{"code": "search_make_new(const struct search_state *const state, int n, const char *const base_name) {\n\tconst size_t base_len = strlen(base_name);\n\tconst char need_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;\n\tstruct search_domain *dom;\n\tfor (dom = state->head; dom; dom = dom->next) {\n\t\tif (!n--) {\n\t\t\tconst u8 *const postfix = ((u8 *) dom) + sizeof(struct search_domain);\n\t\t\tconst int postfix_len = dom->len;\n\t\t\tchar *const newname = (char *) mm_malloc(base_len + need_to_append_dot + postfix_len + 1);\n\t\t\tif (!newname) return NULL;\n\t\t\tmemcpy(newname, base_name, base_len);\n\t\t\tif (need_to_append_dot) newname[base_len] = '.';\n\t\t\tmemcpy(newname + base_len + need_to_append_dot, postfix, postfix_len);\n\t\t\tnewname[base_len + need_to_append_dot + postfix_len] = 0;\n\t\t\treturn newname;\n\t\t}\n\t}\n\tEVUTIL_ASSERT(0);\n\treturn NULL; \n}", "target": 1}
{"code": "static int fsmMkdirs(rpmfiles files, rpmfs fs, rpmPlugins plugins)\n{\n    DNLI_t dnli = dnlInitIterator(files, fs, 0);\n    struct stat sb;\n    const char *dpath;\n    int rc = 0;\n    int i;\n    size_t ldnlen = 0;\n    const char * ldn = NULL;\n    while ((dpath = dnlNextIterator(dnli)) != NULL) {\n\tsize_t dnlen = strlen(dpath);\n\tchar * te, dn[dnlen+1];\n\tif (dnlen <= 1)\n\t    continue;\n\tif (dnlen == ldnlen && rstreq(dpath, ldn))\n\t    continue;\n\t(void) stpcpy(dn, dpath);\n\tfor (i = 1, te = dn + 1; *te != '\\0'; te++, i++) {\n\t    if (*te != '/')\n\t\tcontinue;\n\t    if (i < ldnlen &&\n\t\t(ldn[i] == '/' || ldn[i] == '\\0') && rstreqn(dn, ldn, i))\n\t\tcontinue;\n\t    *te = '\\0';\n\t    rc = fsmStat(dn, 1, &sb); \n\t    *te = '/';\n\t    if (rc == 0 && S_ISDIR(sb.st_mode)) {\n\t\tcontinue;\n\t    } else if (rc == RPMERR_ENOENT) {\n\t\t*te = '\\0';\n\t\tmode_t mode = S_IFDIR | (_dirPerms & 07777);\n\t\trpmFsmOp op = (FA_CREATE|FAF_UNOWNED);\n\t\trc = rpmpluginsCallFsmFilePre(plugins, NULL, dn, mode, op);\n\t\tif (!rc)\n\t\t    rc = fsmMkdir(dn, mode);\n\t\tif (!rc) {\n\t\t    rc = rpmpluginsCallFsmFilePrepare(plugins, NULL, dn, dn,\n\t\t\t\t\t\t      mode, op);\n\t\t}\n\t\trpmpluginsCallFsmFilePost(plugins, NULL, dn, mode, op, rc);\n\t\tif (!rc) {\n\t\t    rpmlog(RPMLOG_DEBUG,\n\t\t\t    \"%s directory created with perms %04o\\n\",\n\t\t\t    dn, (unsigned)(mode & 07777));\n\t\t}\n\t\t*te = '/';\n\t    }\n\t    if (rc)\n\t\tbreak;\n\t}\n\tif (rc) break;\n\tldn = dpath;\n\tldnlen = dnlen;\n    }\n    dnlFreeIterator(dnli);\n    return rc;\n}", "target": 1}
{"code": "int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint rc, xprefix;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\txprefix = JFFS2_XPREFIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\trc = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\tif (inode->i_mode != mode) {\n\t\t\t\tstruct iattr attr;\n\t\t\t\tattr.ia_valid = ATTR_MODE | ATTR_CTIME;\n\t\t\t\tattr.ia_mode = mode;\n\t\t\t\tattr.ia_ctime = CURRENT_TIME_SEC;\n\t\t\t\trc = jffs2_do_setattr(inode, &attr);\n\t\t\t\tif (rc < 0)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tif (rc == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\txprefix = JFFS2_XPREFIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\trc = __jffs2_set_acl(inode, xprefix, acl);\n\tif (!rc)\n\t\tset_cached_acl(inode, type, acl);\n\treturn rc;\n}", "target": 1}
{"code": "s_free(STREAM s)\n{\n\tfree(s->data);\n\tfree(s);\n}", "target": 0}
{"code": "bool WindowsServiceControl::install( const QString& filePath, const QString& displayName  )\n{\n\tm_serviceHandle = CreateService(\n\t\t\t\tm_serviceManager,\t\t\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( m_name ),\t\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( displayName ),\n\t\t\t\tSERVICE_ALL_ACCESS,\t\n\t\t\t\tSERVICE_WIN32_OWN_PROCESS,\n\t\t\t\tSERVICE_AUTO_START,\t\n\t\t\t\tSERVICE_ERROR_NORMAL,\t\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( filePath ),\t\t\n\t\t\t\tnullptr,\t\t\t\n\t\t\t\tnullptr,\t\t\t\n\t\t\t\tL\"Tcpip\\0RpcSs\\0\\0\",\t\t\n\t\t\t\tnullptr,\t\t\t\n\t\t\t\tnullptr );\t\t\t\n\tif( m_serviceHandle == nullptr )\n\t{\n\t\tconst auto error = GetLastError();\n\t\tif( error == ERROR_SERVICE_EXISTS )\n\t\t{\n\t\t\tvCritical() << qUtf8Printable( tr( \"The service \\\"%1\\\" is already installed.\" ).arg( m_name ) );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvCritical() << qUtf8Printable( tr( \"The service \\\"%1\\\" could not be installed.\" ).arg( m_name ) );\n\t\t}\n\t\treturn false;\n\t}\n\tSC_ACTION serviceActions;\n\tserviceActions.Delay = 10000;\n\tserviceActions.Type = SC_ACTION_RESTART;\n\tSERVICE_FAILURE_ACTIONS serviceFailureActions;\n\tserviceFailureActions.dwResetPeriod = 0;\n\tserviceFailureActions.lpRebootMsg = nullptr;\n\tserviceFailureActions.lpCommand = nullptr;\n\tserviceFailureActions.lpsaActions = &serviceActions;\n\tserviceFailureActions.cActions = 1;\n\tChangeServiceConfig2( m_serviceHandle, SERVICE_CONFIG_FAILURE_ACTIONS, &serviceFailureActions );\n\tvInfo() << qUtf8Printable( tr( \"The service \\\"%1\\\" has been installed successfully.\" ).arg( m_name ) );\n\treturn true;\n}", "target": 1}
{"code": "void mb2_cache_entry_touch(struct mb2_cache *cache,\n\t\t\t   struct mb2_cache_entry *entry)\n{\n\tspin_lock(&cache->c_lru_list_lock);\n\tif (!list_empty(&entry->e_lru_list))\n\t\tlist_move_tail(&cache->c_lru_list, &entry->e_lru_list);\n\tspin_unlock(&cache->c_lru_list_lock);\n}", "target": 0}
{"code": "static void dp8393x_register_types(void)\n{\n    type_register_static(&dp8393x_info);\n}", "target": 0}
{"code": "v8::Handle<v8::Value> V8DOMWindow::addEventListenerMethodCustom(const v8::Arguments& args)\n{\n    String eventType = toWebCoreString(args[0]);\n    bool useCapture = args[2]->BooleanValue();\n    DOMWindow* imp = V8DOMWindow::toNative(args.Holder());\n    if (!BindingSecurity::shouldAllowAccessToFrame(imp->frame()))\n        return v8::Undefined();\n    Document* doc = imp->document();\n    if (!doc)\n        return v8::Undefined();\n    if (!imp->frame())\n        return v8::Undefined();\n    RefPtr<EventListener> listener = V8EventListenerList::getEventListener(args[1], false, ListenerFindOrCreate);\n    if (listener) {\n        imp->addEventListener(eventType, listener, useCapture);\n        createHiddenDependency(args.Holder(), args[1], eventListenerCacheIndex, args.GetIsolate());\n    }\n    return v8::Undefined();\n}", "target": 0}
{"code": "static bool identifyCallsites(\n    Function *F,\n    llvh::DenseSet<CallInst *> &callSites) {\n  if (!F->isStrictMode()) {\n    return false;\n  }\n  for (auto *CU : F->getUsers()) {\n    if (auto *CI = llvh::dyn_cast<CallInst>(CU)) {\n      if (!isDirectCallee(F, CI))\n        return false;\n      callSites.insert(CI);\n    } else if (auto *CFI = llvh::dyn_cast<CreateFunctionInst>(CU)) {\n      for (auto *CL : CFI->getUsers()) {\n        auto *CI = llvh::dyn_cast<CallInst>(CL);\n        if (!CI)\n          return false;\n        if (!isDirectCallee(CFI, CI))\n          return false;\n        callSites.insert(CI);\n      }\n    } else {\n      return false;\n    }\n  }\n  return true;\n}", "target": 0}
{"code": "void CConfig::Write(CFile& File, unsigned int iIndentation) {\n    CString sIndentation = CString(iIndentation, '\\t');\n    for (const auto& it : m_ConfigEntries) {\n        for (const CString& sValue : it.second) {\n            File.Write(sIndentation + it.first + \" = \" + sValue + \"\\n\");\n        }\n    }\n    for (const auto& it : m_SubConfigs) {\n        for (const auto& it2 : it.second) {\n            File.Write(\"\\n\");\n            File.Write(sIndentation + \"<\" + it.first + \" \" + it2.first + \">\\n\");\n            it2.second.m_pSubConfig->Write(File, iIndentation + 1);\n            File.Write(sIndentation + \"</\" + it.first + \">\\n\");\n        }\n    }\n}", "target": 1}
{"code": "int fit_image_verify(const void *fit, int image_noffset)\n{\n\tconst void\t*data;\n\tsize_t\t\tsize;\n\tint\t\tnoffset = 0;\n\tchar\t\t*err_msg = \"\";\n\tif (fit_image_get_data_and_size(fit, image_noffset, &data, &size)) {\n\t\terr_msg = \"Can't get image data/size\";\n\t\tprintf(\"error!\\n%s for '%s' hash node in '%s' image node\\n\",\n\t\t       err_msg, fit_get_name(fit, noffset, NULL),\n\t\t       fit_get_name(fit, image_noffset, NULL));\n\t\treturn 0;\n\t}\n\treturn fit_image_verify_with_data(fit, image_noffset, data, size);\n}", "target": 1}
{"code": "split_der(asn1buf *buf, uint8_t *const *der, size_t len, taginfo *tag_out)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n    ret = get_tag(*der, len, tag_out, &contents, &clen, &remainder, &rlen);\n    if (ret)\n        return ret;\n    if (rlen != 0)\n        return ASN1_BAD_LENGTH;\n    insert_bytes(buf, contents, clen);\n    return 0;\n}", "target": 1}
{"code": "void PPB_URLLoader_Impl::didReceiveData(WebURLLoader* loader,\n                                        const char* data,\n                                        int data_length,\n                                        int encoded_data_length) {\n  bytes_received_ += data_length;\n  UpdateStatus();\n  buffer_.insert(buffer_.end(), data, data + data_length);\n  DCHECK(request_data_.prefetch_buffer_lower_threshold <\n         request_data_.prefetch_buffer_upper_threshold);\n  if (!is_streaming_to_file_ &&\n      !is_asynchronous_load_suspended_ &&\n      (buffer_.size() >= static_cast<size_t>(\n          request_data_.prefetch_buffer_upper_threshold))) {\n    DVLOG(1) << \"Suspending async load - buffer size: \" << buffer_.size();\n    SetDefersLoading(true);\n  }\n  if (user_buffer_) {\n    RunCallback(FillUserBuffer());\n  } else {\n    DCHECK(!TrackedCallback::IsPending(pending_callback_));\n  }\n}", "target": 0}
{"code": "int vm_sockets_get_local_cid(void)\n{\n\treturn transport->get_local_cid();\n}", "target": 0}
{"code": "static struct sock *unix_create1(struct net *net, struct socket *sock, int kern)\n{\n\tstruct sock *sk = NULL;\n\tstruct unix_sock *u;\n\tatomic_long_inc(&unix_nr_socks);\n\tif (atomic_long_read(&unix_nr_socks) > 2 * get_max_files())\n\t\tgoto out;\n\tsk = sk_alloc(net, PF_UNIX, GFP_KERNEL, &unix_proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\tsock_init_data(sock, sk);\n\tlockdep_set_class(&sk->sk_receive_queue.lock,\n\t\t\t\t&af_unix_sk_receive_queue_lock_key);\n\tsk->sk_write_space\t= unix_write_space;\n\tsk->sk_max_ack_backlog\t= net->unx.sysctl_max_dgram_qlen;\n\tsk->sk_destruct\t\t= unix_sock_destructor;\n\tu\t  = unix_sk(sk);\n\tu->path.dentry = NULL;\n\tu->path.mnt = NULL;\n\tspin_lock_init(&u->lock);\n\tatomic_long_set(&u->inflight, 0);\n\tINIT_LIST_HEAD(&u->link);\n\tmutex_init(&u->readlock); \n\tinit_waitqueue_head(&u->peer_wait);\n\tinit_waitqueue_func_entry(&u->peer_wake, unix_dgram_peer_wake_relay);\n\tunix_insert_socket(unix_sockets_unbound(sk), sk);\nout:\n\tif (sk == NULL)\n\t\tatomic_long_dec(&unix_nr_socks);\n\telse {\n\t\tlocal_bh_disable();\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\n\t\tlocal_bh_enable();\n\t}\n\treturn sk;\n}", "target": 0}
{"code": "koi8_r_is_mbc_ambiguous(OnigCaseFoldType flag, const UChar** pp,\n\t\t\tconst UChar* end, OnigEncoding enc ARG_UNUSED)\n{\n  int v;\n  const UChar* p = *pp;\n  (*pp)++;\n  v = (EncKOI8_R_CtypeTable[*p] & (BIT_CTYPE_UPPER | BIT_CTYPE_LOWER));\n  return (v != 0 ? TRUE : FALSE);\n}", "target": 0}
{"code": "static int http_open(URLContext *h, const char *uri, int flags,\n                     AVDictionary **options)\n{\n    HTTPContext *s = h->priv_data;\n    int ret;\n    if( s->seekable == 1 )\n        h->is_streamed = 0;\n    else\n        h->is_streamed = 1;\n    s->filesize = -1;\n    s->location = av_strdup(uri);\n    if (!s->location)\n        return AVERROR(ENOMEM);\n    if (options)\n        av_dict_copy(&s->chained_options, *options, 0);\n    if (s->headers) {\n        int len = strlen(s->headers);\n        if (len < 2 || strcmp(\"\\r\\n\", s->headers + len - 2)) {\n            av_log(h, AV_LOG_WARNING,\n                   \"No trailing CRLF found in HTTP header.\\n\");\n            ret = av_reallocp(&s->headers, len + 3);\n            if (ret < 0)\n                return ret;\n            s->headers[len]     = '\\r';\n            s->headers[len + 1] = '\\n';\n            s->headers[len + 2] = '\\0';\n        }\n    }\n    if (s->listen) {\n        return http_listen(h, uri, flags, options);\n    }\n    ret = http_open_cnx(h, options);\n    if (ret < 0)\n        av_dict_free(&s->chained_options);\n    return ret;\n}", "target": 1}
{"code": "  void resizeAndFillTable(\n      HeaderTable& table, HPACKHeader& header, uint32_t newMax,\n      uint32_t fillCount) {\n    uint32_t newCapacity = header.bytes() * newMax;\n    resizeTable(table, newCapacity, newMax);\n    for (size_t i = 0; i <= fillCount; ++i) {\n      EXPECT_EQ(table.add(header), true);\n    }\n    EXPECT_EQ(table.size(), newMax);\n    EXPECT_EQ(table.bytes(), newCapacity);\n  }", "target": 0}
{"code": "    void CrwMap::encode0x1810(const Image&      image,\n                              const CrwMapping* pCrwMapping,\n                                    CiffHeader* pHead)\n    {\n        assert(pCrwMapping != 0);\n        assert(pHead != 0);\n        const ExifKey kX(\"Exif.Photo.PixelXDimension\");\n        const ExifKey kY(\"Exif.Photo.PixelYDimension\");\n        const ExifKey kO(\"Exif.Image.Orientation\");\n        const ExifData &exivData = image.exifData();\n        const ExifData::const_iterator edX = exivData.findKey(kX);\n        const ExifData::const_iterator edY = exivData.findKey(kY);\n        const ExifData::const_iterator edO = exivData.findKey(kO);\n        const ExifData::const_iterator edEnd = exivData.end();\n        CiffComponent* cc = pHead->findComponent(pCrwMapping->crwTagId_,\n                                                 pCrwMapping->crwDir_);\n        if (edX != edEnd || edY != edEnd || edO != edEnd) {\n            uint32_t size = 28;\n            if (cc) {\n              if (cc->size() < size)\n                throw Error(kerCorruptedMetadata);\n              size = cc->size();\n            }\n            DataBuf buf(size);\n            std::memset(buf.pData_, 0x0, buf.size_);\n            if (cc) std::memcpy(buf.pData_ + 8, cc->pData() + 8, cc->size() - 8);\n            if (edX != edEnd && edX->size() == 4) {\n                edX->copy(buf.pData_, pHead->byteOrder());\n            }\n            if (edY != edEnd && edY->size() == 4) {\n                edY->copy(buf.pData_ + 4, pHead->byteOrder());\n            }\n            int32_t d = 0;\n            if (edO != edEnd && edO->count() > 0 && edO->typeId() == unsignedShort) {\n                d = RotationMap::degrees(static_cast<uint16_t>(edO->toLong()));\n            }\n            l2Data(buf.pData_ + 12, d, pHead->byteOrder());\n            pHead->add(pCrwMapping->crwTagId_, pCrwMapping->crwDir_, buf);\n        }\n        else {\n            pHead->remove(pCrwMapping->crwTagId_, pCrwMapping->crwDir_);\n        }\n    } ", "target": 0}
{"code": "vgetcpu_cpu_notifier(struct notifier_block *n, unsigned long action, void *arg)\n{\n\tlong cpu = (long)arg;\n\tif (action == CPU_ONLINE || action == CPU_ONLINE_FROZEN)\n\t\tsmp_call_function_single(cpu, vgetcpu_cpu_init, NULL, 1);\n\treturn NOTIFY_DONE;\n}", "target": 0}
{"code": "max3421_urb_done(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tunsigned long flags;\n\tstruct urb *urb;\n\tint status;\n\tstatus = max3421_hcd->urb_done;\n\tmax3421_hcd->urb_done = 0;\n\tif (status > 0)\n\t\tstatus = 0;\n\turb = max3421_hcd->curr_urb;\n\tif (urb) {\n\t\tu8 hrsl = spi_rd8(hcd, MAX3421_REG_HRSL);\n\t\tint rcvtog = (hrsl >> MAX3421_HRSL_RCVTOGRD_BIT) & 1;\n\t\tint sndtog = (hrsl >> MAX3421_HRSL_SNDTOGRD_BIT) & 1;\n\t\tint epnum = usb_endpoint_num(&urb->ep->desc);\n\t\tusb_settoggle(urb->dev, epnum, 0, rcvtog);\n\t\tusb_settoggle(urb->dev, epnum, 1, sndtog);\n\t\tmax3421_hcd->curr_urb = NULL;\n\t\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\t\tusb_hcd_unlink_urb_from_ep(hcd, urb);\n\t\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\t\tusb_hcd_giveback_urb(hcd, urb, status);\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "pci_get_cfgdata8(struct pci_vdev *dev, int offset)\n{\n\tassert(offset <= PCI_REGMAX);\n\treturn (*(uint8_t *)(dev->cfgdata + offset));\n}", "target": 1}
{"code": "int nfc_data_exchange(struct nfc_dev *dev, u32 target_idx, struct sk_buff *skb,\n\t\t      data_exchange_cb_t cb, void *cb_context)\n{\n\tint rc;\n\tpr_debug(\"dev_name=%s target_idx=%u skb->len=%u\\n\",\n\t\t dev_name(&dev->dev), target_idx, skb->len);\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tkfree_skb(skb);\n\t\tgoto error;\n\t}\n\tif (dev->rf_mode == NFC_RF_INITIATOR && dev->active_target != NULL) {\n\t\tif (dev->active_target->idx != target_idx) {\n\t\t\trc = -EADDRNOTAVAIL;\n\t\t\tkfree_skb(skb);\n\t\t\tgoto error;\n\t\t}\n\t\tif (dev->ops->check_presence)\n\t\t\tdel_timer_sync(&dev->check_pres_timer);\n\t\trc = dev->ops->im_transceive(dev, dev->active_target, skb, cb,\n\t\t\t\t\t     cb_context);\n\t\tif (!rc && dev->ops->check_presence && !dev->shutting_down)\n\t\t\tmod_timer(&dev->check_pres_timer, jiffies +\n\t\t\t\t  msecs_to_jiffies(NFC_CHECK_PRES_FREQ_MS));\n\t} else if (dev->rf_mode == NFC_RF_TARGET && dev->ops->tm_send != NULL) {\n\t\trc = dev->ops->tm_send(dev, skb);\n\t} else {\n\t\trc = -ENOTCONN;\n\t\tkfree_skb(skb);\n\t\tgoto error;\n\t}\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "static int __get_data_block(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh, int create, int flag,\n\t\t\tpgoff_t *next_pgofs)\n{\n\tstruct f2fs_map_blocks map;\n\tint err;\n\tmap.m_lblk = iblock;\n\tmap.m_len = bh->b_size >> inode->i_blkbits;\n\tmap.m_next_pgofs = next_pgofs;\n\terr = f2fs_map_blocks(inode, &map, create, flag);\n\tif (!err) {\n\t\tmap_bh(bh, inode->i_sb, map.m_pblk);\n\t\tbh->b_state = (bh->b_state & ~F2FS_MAP_FLAGS) | map.m_flags;\n\t\tbh->b_size = map.m_len << inode->i_blkbits;\n\t}\n\treturn err;\n}", "target": 1}
{"code": "static void smp_task_done(struct sas_task *task)\n{\n\tif (!del_timer(&task->slow_task->timer))\n\t\treturn;\n\tcomplete(&task->slow_task->completion);\n}", "target": 1}
{"code": "linux_lvm2_vg_remove_pv_completed_cb (DBusGMethodInvocation *context,\n                                      Device *device,\n                                      gboolean job_was_cancelled,\n                                      int status,\n                                      const char *stderr,\n                                      const char *stdout,\n                                      gpointer user_data)\n{\n  if (WEXITSTATUS (status) == 0 && !job_was_cancelled)\n    {\n      dbus_g_method_return (context);\n    }\n  else\n    {\n      if (job_was_cancelled)\n        {\n          throw_error (context, ERROR_CANCELLED, \"Job was cancelled\");\n        }\n      else\n        {\n          throw_error (context,\n                       ERROR_FAILED,\n                       \"Error removing PV for LVM2 Volume Group: vgreduce exited with exit code %d: %s\",\n                       WEXITSTATUS (status),\n                       stderr);\n        }\n    }\n}", "target": 0}
{"code": "git_filemode_t git_tree_entry_filemode(const git_tree_entry *entry)\n{\n\treturn normalize_filemode(entry->attr);\n}", "target": 0}
{"code": "int OmniboxViewWin::OnPerformDrop(const views::DropTargetEvent& event) {\n  return OnPerformDropImpl(event, false);\n}", "target": 0}
{"code": "compat_kex_proposal(struct ssh *ssh, char *p)\n{\n\tif ((ssh->compat & (SSH_BUG_CURVE25519PAD|SSH_OLD_DHGEX)) == 0)\n\t\treturn p;\n\tdebug2_f(\"original KEX proposal: %s\", p);\n\tif ((ssh->compat & SSH_BUG_CURVE25519PAD) != 0)\n\t\tif ((p = match_filter_denylist(p,\n\t\t    \"curve25519-sha256@libssh.org\")) == NULL)\n\t\t\tfatal(\"match_filter_denylist failed\");\n\tif ((ssh->compat & SSH_OLD_DHGEX) != 0) {\n\t\tif ((p = match_filter_denylist(p,\n\t\t    \"diffie-hellman-group-exchange-sha256,\"\n\t\t    \"diffie-hellman-group-exchange-sha1\")) == NULL)\n\t\t\tfatal(\"match_filter_denylist failed\");\n\t}\n\tdebug2_f(\"compat KEX proposal: %s\", p);\n\tif (*p == '\\0')\n\t\tfatal(\"No supported key exchange algorithms found\");\n\treturn p;\n}", "target": 1}
{"code": "static void axfm(RCore *core) {\n\tRVecAnalRef *refs = r_anal_xrefs_get_from (core->anal, UT64_MAX);\n\tif (refs && !RVecAnalRef_empty (refs)) {\n\t\tRVecAnalRef_sort (refs, compare_ref);\n\t\tut64 last_addr = UT64_MAX;\n\t\tRAnalRef *ref;\n\t\tR_VEC_FOREACH (refs, ref) {\n\t\t\tconst bool is_first = ref->addr != last_addr;\n\t\t\tconst char *name;\n\t\t\tif (is_first) {\n\t\t\t\tname = axtm_name (core, ref->addr);\n\t\t\t\tr_cons_printf (\"0x%\"PFMT64x\": %s\\n\", ref->addr, name? name: \"?\");\n\t\t\t}\n\t\t\tname = axtm_name (core, ref->at);\n\t\t\tr_cons_printf (\"  0x%\"PFMT64x\": %s\\n\", ref->at, name? name: \"?\");\n\t\t\tlast_addr = ref->addr;\n\t\t}\n\t}\n\tRVecAnalRef_free (refs);\n}", "target": 1}
{"code": "static int decode_preamble(void *p, struct ceph_frame_desc *desc)\n{\n\tvoid *crcp = p + CEPH_PREAMBLE_LEN - CEPH_CRC_LEN;\n\tu32 crc, expected_crc;\n\tint i;\n\tcrc = crc32c(0, p, crcp - p);\n\texpected_crc = get_unaligned_le32(crcp);\n\tif (crc != expected_crc) {\n\t\tpr_err(\"bad preamble crc, calculated %u, expected %u\\n\",\n\t\t       crc, expected_crc);\n\t\treturn -EBADMSG;\n\t}\n\tmemset(desc, 0, sizeof(*desc));\n\tdesc->fd_tag = ceph_decode_8(&p);\n\tdesc->fd_seg_cnt = ceph_decode_8(&p);\n\tif (desc->fd_seg_cnt < 1 ||\n\t    desc->fd_seg_cnt > CEPH_FRAME_MAX_SEGMENT_COUNT) {\n\t\tpr_err(\"bad segment count %d\\n\", desc->fd_seg_cnt);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < desc->fd_seg_cnt; i++) {\n\t\tdesc->fd_lens[i] = ceph_decode_32(&p);\n\t\tdesc->fd_aligns[i] = ceph_decode_16(&p);\n\t}\n\tif (!desc->fd_lens[desc->fd_seg_cnt - 1]) {\n\t\tpr_err(\"last segment empty\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[0] > CEPH_MSG_MAX_CONTROL_LEN) {\n\t\tpr_err(\"control segment too big %d\\n\", desc->fd_lens[0]);\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[1] > CEPH_MSG_MAX_FRONT_LEN) {\n\t\tpr_err(\"front segment too big %d\\n\", desc->fd_lens[1]);\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[2] > CEPH_MSG_MAX_MIDDLE_LEN) {\n\t\tpr_err(\"middle segment too big %d\\n\", desc->fd_lens[2]);\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[3] > CEPH_MSG_MAX_DATA_LEN) {\n\t\tpr_err(\"data segment too big %d\\n\", desc->fd_lens[3]);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "    Exifdatum& Exifdatum::operator=(const URational& value)\n    {\n        return Exiv2::setValue(*this, value);\n    }", "target": 0}
{"code": "static int http_connect(http_subtransport *t)\n{\n\tint error;\n\tif (t->connected &&\n\t\thttp_should_keep_alive(&t->parser) &&\n\t\tt->parse_finished)\n\t\treturn 0;\n\tif (t->io) {\n\t\tgit_stream_close(t->io);\n\t\tgit_stream_free(t->io);\n\t\tt->io = NULL;\n\t\tt->connected = 0;\n\t}\n\tif (t->connection_data.use_ssl) {\n\t\terror = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n\t} else {\n#ifdef GIT_CURL\n\t\terror = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n#else\n\t\terror = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);\n#endif\n\t}\n\tif (error < 0)\n\t\treturn error;\n\tGITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, \"git_stream\");\n\tapply_proxy_config(t);\n\terror = git_stream_connect(t->io);\n\tif ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&\n\t    git_stream_is_encrypted(t->io)) {\n\t\tgit_cert *cert;\n\t\tint is_valid;\n\t\tif ((error = git_stream_certificate(&cert, t->io)) < 0)\n\t\t\treturn error;\n\t\tgiterr_clear();\n\t\tis_valid = error != GIT_ECERTIFICATE;\n\t\terror = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);\n\t\tif (error < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, \"user cancelled certificate check\");\n\t\t\treturn error;\n\t\t}\n\t}\n\tif (error < 0)\n\t\treturn error;\n\tt->connected = 1;\n\treturn 0;\n}", "target": 1}
{"code": "int nf_ct_frag6_gather(struct net *net, struct sk_buff *skb, u32 user)\n{\n\tstruct net_device *dev = skb->dev;\n\tint fhoff, nhoff, ret;\n\tstruct frag_hdr *fhdr;\n\tstruct frag_queue *fq;\n\tstruct ipv6hdr *hdr;\n\tu8 prevhdr;\n\tif (ipv6_hdr(skb)->payload_len == 0) {\n\t\tpr_debug(\"payload len = 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0)\n\t\treturn -EINVAL;\n\tif (!pskb_may_pull(skb, fhoff + sizeof(*fhdr)))\n\t\treturn -ENOMEM;\n\tskb_set_transport_header(skb, fhoff);\n\thdr = ipv6_hdr(skb);\n\tfhdr = (struct frag_hdr *)skb_transport_header(skb);\n\tfq = fq_find(net, fhdr->identification, user, &hdr->saddr, &hdr->daddr,\n\t\t     skb->dev ? skb->dev->ifindex : 0, ip6_frag_ecn(hdr));\n\tif (fq == NULL) {\n\t\tpr_debug(\"Can't find and can't create new queue\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tspin_lock_bh(&fq->q.lock);\n\tif (nf_ct_frag6_queue(fq, skb, fhdr, nhoff) < 0) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\tret = -EINPROGRESS;\n\tif (fq->q.flags == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&\n\t    fq->q.meat == fq->q.len &&\n\t    nf_ct_frag6_reasm(fq, skb, dev))\n\t\tret = 0;\nout_unlock:\n\tspin_unlock_bh(&fq->q.lock);\n\tinet_frag_put(&fq->q, &nf_frags);\n\treturn ret;\n}", "target": 1}
{"code": "http_rxchunk(struct http *hp)\n{\n\tchar *q;\n\tint l, i;\n\tl = hp->prxbuf;\n\tdo\n\t\t(void)http_rxchar(hp, 1, 0);\n\twhile (hp->rxbuf[hp->prxbuf - 1] != '\\n');\n\tvtc_dump(hp->vl, 4, \"len\", hp->rxbuf + l, -1);\n\ti = strtoul(hp->rxbuf + l, &q, 16);\n\tbprintf(hp->chunklen, \"%d\", i);\n\tif ((q == hp->rxbuf + l) ||\n\t\t(*q != '\\0' && !vct_islws(*q))) {\n\t\tvtc_log(hp->vl, hp->fatal, \"chunked fail %02x @ %d\",\n\t\t    *q, q - (hp->rxbuf + l));\n\t}\n\tassert(q != hp->rxbuf + l);\n\tassert(*q == '\\0' || vct_islws(*q));\n\thp->prxbuf = l;\n\tif (i > 0) {\n\t\t(void)http_rxchar(hp, i, 0);\n\t\tvtc_dump(hp->vl, 4, \"chunk\",\n\t\t    hp->rxbuf + l, i);\n\t}\n\tl = hp->prxbuf;\n\t(void)http_rxchar(hp, 2, 0);\n\tif(!vct_iscrlf(hp->rxbuf[l]))\n\t\tvtc_log(hp->vl, hp->fatal,\n\t\t    \"Wrong chunk tail[0] = %02x\",\n\t\t    hp->rxbuf[l] & 0xff);\n\tif(!vct_iscrlf(hp->rxbuf[l + 1]))\n\t\tvtc_log(hp->vl, hp->fatal,\n\t\t    \"Wrong chunk tail[1] = %02x\",\n\t\t    hp->rxbuf[l + 1] & 0xff);\n\thp->prxbuf = l;\n\thp->rxbuf[l] = '\\0';\n\treturn (i);\n}", "target": 1}
{"code": "bool CxImage::Transfer(CxImage &from, bool bTransferFrames )\n{\n\tif (!Destroy())\n\t\treturn false;\n\tmemcpy(&head,&from.head,sizeof(BITMAPINFOHEADER));\n\tmemcpy(&info,&from.info,sizeof(CXIMAGEINFO));\n\tpDib = from.pDib;\n\tpSelection = from.pSelection;\n\tpAlpha = from.pAlpha;\n\tppLayers = from.ppLayers;\n\tmemset(&from.head,0,sizeof(BITMAPINFOHEADER));\n\tmemset(&from.info,0,sizeof(CXIMAGEINFO));\n\tfrom.pDib = from.pSelection = from.pAlpha = NULL;\n\tfrom.ppLayers = NULL;\n\tif (bTransferFrames){\n\t\tDestroyFrames();\n\t\tppFrames = from.ppFrames;\n\t\tfrom.ppFrames = NULL;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "char* _single_string_alloc_and_copy( LPCWSTR in )\n{\n    char *chr;\n    int len = 0;\n    if ( !in )\n    {\n        return in;\n    }\n    while ( in[ len ] != 0 )\n    {\n        len ++;\n    }\n    chr = malloc( len + 1 );\n    len = 0;\n    while ( in[ len ] != 0 )\n    {\n        chr[ len ] = 0xFF & in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = '\\0';\n    return chr;\n}", "target": 1}
{"code": "void test_truncate(const char *path)\n{\n\tif (truncate(path, 0) == 0) {\n\t\tfprintf(stderr, \"leak at truncate of %s\\n\", path);\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "int ndpi_netbios_name_interpret(char *in, size_t in_len, char *out, u_int out_len) {\n  u_int ret = 0, len, idx = in_len, out_idx = 0;\n  len = (*in++)/2;\n  out_len--;\n  out[out_idx] = 0;\n  if((len > out_len) || (len < 1) || ((2*len) > in_len))\n    return(-1);\n  while((len--) && (out_idx < out_len)) {\n    if((idx < 2) || (in[0] < 'A') || (in[0] > 'P') || (in[1] < 'A') || (in[1] > 'P')) {\n      out[out_idx] = 0;\n      break;\n    }\n    out[out_idx] = ((in[0] - 'A') << 4) + (in[1] - 'A');\n    in += 2, idx -= 2;\n    if(isprint(out[out_idx]))\n      out_idx++, ret++;\n  }\n  if(out_idx > 0) {\n    out[out_idx] = 0;\n    out_idx--;\n    while((out_idx > 0) && (out[out_idx] == ' ')) {\n      out[out_idx] = 0;\n      out_idx--;\n    }\n  }\n  return(ret);\n}", "target": 1}
{"code": "setv4key_principal_2_svc(setv4key_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (!(CHANGEPW_SERVICE(rqstp)) &&\n        kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                           ACL_SETKEY, arg->princ, NULL)) {\n        ret.code = kadm5_setv4key_principal((void *)handle, arg->princ,\n                                            arg->keyblock);\n    } else {\n        log_unauth(\"kadm5_setv4key_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_SETKEY;\n    }\n    if(ret.code != KADM5_AUTH_SETKEY) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_setv4key_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "PHP_FUNCTION(pg_escape_identifier)\n{\n\tphp_pgsql_escape_internal(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);\n}", "target": 0}
{"code": "bool ExtractHardlink(CommandData *Cmd,wchar *NameNew,wchar *NameExisting,size_t NameExistingSize)\n{\n  SlashToNative(NameExisting,NameExisting,NameExistingSize); \n  if (!FileExist(NameExisting))\n  {\n    uiMsg(UIERROR_HLINKCREATE,NameNew);\n    uiMsg(UIERROR_NOLINKTARGET);\n    ErrHandler.SetErrorCode(RARX_CREATE);\n    return false;\n  }\n  CreatePath(NameNew,true,Cmd->DisableNames);\n#ifdef _WIN_ALL\n  bool Success=CreateHardLink(NameNew,NameExisting,NULL)!=0;\n  if (!Success)\n  {\n    uiMsg(UIERROR_HLINKCREATE,NameNew);\n    ErrHandler.SysErrMsg();\n    ErrHandler.SetErrorCode(RARX_CREATE);\n  }\n  return Success;\n#elif defined(_UNIX)\n  char NameExistingA[NM],NameNewA[NM];\n  WideToChar(NameExisting,NameExistingA,ASIZE(NameExistingA));\n  WideToChar(NameNew,NameNewA,ASIZE(NameNewA));\n  bool Success=link(NameExistingA,NameNewA)==0;\n  if (!Success)\n  {\n    uiMsg(UIERROR_HLINKCREATE,NameNew);\n    ErrHandler.SysErrMsg();\n    ErrHandler.SetErrorCode(RARX_CREATE);\n  }\n  return Success;\n#else\n  return false;\n#endif\n}", "target": 1}
{"code": "njs_json_parse_iterator(njs_vm_t *vm, njs_json_parse_t *parse,\n    njs_value_t *object)\n{\n    njs_int_t             ret;\n    njs_value_t           *key, wrapper;\n    njs_object_t          *obj;\n    njs_json_state_t      *state;\n    njs_object_prop_t     *prop;\n    njs_property_query_t  pq;\n    obj = njs_json_wrap_value(vm, &wrapper, object);\n    if (njs_slow_path(obj == NULL)) {\n        return NJS_ERROR;\n    }\n    state = njs_json_push_parse_state(vm, parse, &wrapper);\n    if (njs_slow_path(state == NULL)) {\n        return NJS_ERROR;\n    }\n    for ( ;; ) {\n        if (state->index < state->keys->length) {\n            njs_property_query_init(&pq, NJS_PROPERTY_QUERY_SET, 0);\n            key = &state->keys->start[state->index];\n            ret = njs_property_query(vm, &pq, &state->value, key);\n            if (njs_slow_path(ret != NJS_OK)) {\n                if (ret == NJS_DECLINED) {\n                    state->index++;\n                    continue;\n                }\n                return NJS_ERROR;\n            }\n            prop = pq.lhq.value;\n            if (prop->type == NJS_WHITEOUT) {\n                state->index++;\n                continue;\n            }\n            state->prop = prop;\n            if (prop->type == NJS_PROPERTY && njs_is_object(&prop->value)) {\n                state = njs_json_push_parse_state(vm, parse, &prop->value);\n                if (state == NULL) {\n                    return NJS_ERROR;\n                }\n                continue;\n            }\n            if (prop->type == NJS_PROPERTY_REF\n                && njs_is_object(prop->value.data.u.value))\n            {\n                state = njs_json_push_parse_state(vm, parse,\n                                                  prop->value.data.u.value);\n                if (state == NULL) {\n                    return NJS_ERROR;\n                }\n                continue;\n            }\n        } else {\n            state = njs_json_pop_parse_state(vm, parse);\n            if (state == NULL) {\n                vm->retval = parse->retval;\n                return NJS_OK;\n            }\n        }\n        ret = njs_json_parse_iterator_call(vm, parse, state);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n    }\n}", "target": 1}
{"code": "static void dhcps_send_ack(struct pbuf *packet_buffer)\n{\n\tdhcp_message_repository = (struct dhcp_msg *)packet_buffer->payload;\n\tdhcps_initialize_message(dhcp_message_repository);\n\tadd_offer_options(add_msg_type(&dhcp_message_repository->options[4],\n\t\t\t      \t\t\tDHCP_MESSAGE_TYPE_ACK));\n\tudp_sendto_if(dhcps_pcb, packet_buffer,\n\t\t   &dhcps_send_broadcast_address, DHCP_CLIENT_PORT, dhcps_netif);\n}", "target": 1}
{"code": "static void engine_shutdown_handler(void *arg)\n{\n\t(void) arg;\n\tre_printf(\"The engine shutted down.\\n\");\n\tre_cancel();\n}", "target": 0}
{"code": "static int xc2028_set_config(struct dvb_frontend *fe, void *priv_cfg)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tstruct xc2028_ctrl *p    = priv_cfg;\n\tint                 rc   = 0;\n\ttuner_dbg(\"%s called\\n\", __func__);\n\tmutex_lock(&priv->lock);\n\tkfree(priv->ctrl.fname);\n\tmemcpy(&priv->ctrl, p, sizeof(priv->ctrl));\n\tif (p->fname) {\n\t\tpriv->ctrl.fname = kstrdup(p->fname, GFP_KERNEL);\n\t\tif (priv->ctrl.fname == NULL)\n\t\t\trc = -ENOMEM;\n\t}\n\tif (!firmware_name[0] && p->fname &&\n\t    priv->fname && strcmp(p->fname, priv->fname))\n\t\tfree_firmware(priv);\n\tif (priv->ctrl.max_len < 9)\n\t\tpriv->ctrl.max_len = 13;\n\tif (priv->state == XC2028_NO_FIRMWARE) {\n\t\tif (!firmware_name[0])\n\t\t\tpriv->fname = priv->ctrl.fname;\n\t\telse\n\t\t\tpriv->fname = firmware_name;\n\t\trc = request_firmware_nowait(THIS_MODULE, 1,\n\t\t\t\t\t     priv->fname,\n\t\t\t\t\t     priv->i2c_props.adap->dev.parent,\n\t\t\t\t\t     GFP_KERNEL,\n\t\t\t\t\t     fe, load_firmware_cb);\n\t\tif (rc < 0) {\n\t\t\ttuner_err(\"Failed to request firmware %s\\n\",\n\t\t\t\t  priv->fname);\n\t\t\tpriv->state = XC2028_NODEV;\n\t\t} else\n\t\t\tpriv->state = XC2028_WAITING_FIRMWARE;\n\t}\n\tmutex_unlock(&priv->lock);\n\treturn rc;\n}", "target": 1}
{"code": "static void GTextFieldSaved(GTextField *gt) {\n    GEvent e;\n    e.type = et_controlevent;\n    e.w = gt->g.base;\n    e.u.control.subtype = et_save;\n    e.u.control.g = &gt->g;\n    if ( gt->g.handle_controlevent != NULL )\n\t(gt->g.handle_controlevent)(&gt->g,&e);\n    else\n\tGDrawPostEvent(&e);\n}", "target": 0}
{"code": "int yr_object_array_set_item(\n    YR_OBJECT* object,\n    YR_OBJECT* item,\n    int index)\n{\n  YR_OBJECT_ARRAY* array;\n  int i;\n  int count;\n  assert(index >= 0);\n  assert(object->type == OBJECT_TYPE_ARRAY);\n  array = object_as_array(object);\n  if (array->items == NULL)\n  {\n    count = yr_max(64, (index + 1) * 2);\n    array->items = (YR_ARRAY_ITEMS*) yr_malloc(\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n    memset(array->items->objects, 0, count * sizeof(YR_OBJECT*));\n    array->items->count = count;\n  }\n  else if (index >= array->items->count)\n  {\n    count = array->items->count * 2;\n    array->items = (YR_ARRAY_ITEMS*) yr_realloc(\n        array->items,\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n    for (i = array->items->count; i < count; i++)\n      array->items->objects[i] = NULL;\n    array->items->count = count;\n  }\n  item->parent = object;\n  array->items->objects[index] = item;\n  return ERROR_SUCCESS;\n}", "target": 1}
{"code": "devzvol_create(struct vnode *dvp, char *nm, struct vattr *vap, vcexcl_t excl,\n    int mode, struct vnode **vpp, struct cred *cred, int flag,\n    caller_context_t *ct, vsecattr_t *vsecp)\n{\n\tint error;\n\tstruct vnode *vp;\n\t*vpp = NULL;\n\terror = devzvol_lookup(dvp, nm, &vp, NULL, 0, NULL, cred, ct, NULL,\n\t    NULL);\n\tif (error == 0) {\n\t\tif (excl == EXCL)\n\t\t\terror = EEXIST;\n\t\telse if (vp->v_type == VDIR && (mode & VWRITE))\n\t\t\terror = EISDIR;\n\t\telse\n\t\t\terror = VOP_ACCESS(vp, mode, 0, cred, ct);\n\t\tif (error) {\n\t\t\tVN_RELE(vp);\n\t\t} else\n\t\t\t*vpp = vp;\n\t} else if (error == ENOENT) {\n\t\terror = EROFS;\n\t}\n\treturn (error);\n}", "target": 0}
{"code": "static struct ucma_multicast* ucma_alloc_multicast(struct ucma_context *ctx)\n{\n\tstruct ucma_multicast *mc;\n\tmc = kzalloc(sizeof(*mc), GFP_KERNEL);\n\tif (!mc)\n\t\treturn NULL;\n\tmutex_lock(&mut);\n\tmc->id = idr_alloc(&multicast_idr, mc, 0, 0, GFP_KERNEL);\n\tmutex_unlock(&mut);\n\tif (mc->id < 0)\n\t\tgoto error;\n\tmc->ctx = ctx;\n\tlist_add_tail(&mc->list, &ctx->mc_list);\n\treturn mc;\nerror:\n\tkfree(mc);\n\treturn NULL;\n}", "target": 1}
{"code": "void util_hex_dump(FILE *f, const u8 *in, int len, const char *sep)\n{\n\tint i;\n\tfor (i = 0; i < len; i++) {\n\t\tif (sep != NULL && i)\n\t\t\tfprintf(f, \"%s\", sep);\n\t\tfprintf(f, \"%02X\", in[i]);\n\t}\n}", "target": 0}
{"code": "char *suhosin_decrypt_single_cookie(char *name, int name_len, char *value, int value_len, char *key, char **where TSRMLS_DC)\n{\n\tchar buffer[4096];\n    char buffer2[4096];\n    int o_name_len = name_len;\n\tchar *buf = buffer, *buf2 = buffer2, *d, *d_url;\n\tint l;\n\tif (name_len > sizeof(buffer)-2) {\n\t\tbuf = estrndup(name, name_len);\n\t} else {\n\t\tmemcpy(buf, name, name_len);\n\t\tbuf[name_len] = 0;\n\t}\n\tname_len = php_url_decode(buf, name_len);\n    normalize_varname(buf);\n    name_len = strlen(buf);\n\tif (SUHOSIN_G(cookie_plainlist)) {\n\t\tif (zend_hash_exists(SUHOSIN_G(cookie_plainlist), buf, name_len+1)) {\ndecrypt_return_plain:\n\t\t\tif (buf != buffer) {\n\t\t\t\tefree(buf);\n\t\t\t}\n            memcpy(*where, name, o_name_len);\n            *where += o_name_len;\n            **where = '='; *where +=1;\n\t        memcpy(*where, value, value_len);\n\t        *where += value_len;\n\t\t\treturn *where;\n\t\t}\n\t} else if (SUHOSIN_G(cookie_cryptlist)) {\n\t\tif (!zend_hash_exists(SUHOSIN_G(cookie_cryptlist), buf, name_len+1)) {\n\t\t\tgoto decrypt_return_plain;\n\t\t}\n\t}\n\tif (strlen(value) <= sizeof(buffer2)-2) {\n\t\tmemcpy(buf2, value, value_len);\n\t\tbuf2[value_len] = 0;\n\t} else {\n\t\tbuf2 = estrndup(value, value_len);\n\t}\n\tvalue_len = php_url_decode(buf2, value_len);\n\td = suhosin_decrypt_string(buf2, value_len, buf, name_len, key, &l, SUHOSIN_G(cookie_checkraddr) TSRMLS_CC);\n    if (d == NULL) {\n        goto skip_cookie;\n    }\n\td_url = php_url_encode(d, l, &l);\n\tefree(d);\n    memcpy(*where, name, o_name_len);\n    *where += o_name_len;\n    **where = '=';*where += 1;\n\tmemcpy(*where, d_url, l);\n\t*where += l;\n\tefree(d_url);\nskip_cookie:\n\tif (buf != buffer) {\n\t\tefree(buf);\n\t}\n\tif (buf2 != buffer2) {\n\t\tefree(buf2);\n\t}\n\treturn *where;\n}", "target": 1}
{"code": "    template<typename t>\n    CImg<T>& convolve(const CImg<t>& kernel, const bool boundary_conditions=true, const bool is_normalized=false) {\n      if (is_empty() || !kernel) return *this;\n      return get_convolve(kernel,boundary_conditions,is_normalized).move_to(*this);", "target": 0}
{"code": "hermesInternalIsLazy(void *, Runtime &runtime, NativeArgs args) {\n  auto callable = args.dyncastArg<Callable>(0);\n  if (!callable) {\n    return HermesValue::encodeBoolValue(false);\n  }\n  auto codeBlock = getLeafCodeBlock(callable, runtime);\n  if (!codeBlock) {\n    return HermesValue::encodeBoolValue(false);\n  }\n  RuntimeModule *runtimeModule = codeBlock->getRuntimeModule();\n  return HermesValue::encodeBoolValue(\n      runtimeModule && runtimeModule->getBytecode()->isLazy());\n}", "target": 0}
{"code": "exo_open_uri_known_category (const gchar  *uri,\n                             const gchar  *scheme,\n                             gboolean     *succeed)\n{\n  guint        i;\n  const gchar *category = NULL;\n  g_return_val_if_fail (uri != NULL, FALSE);\n  g_return_val_if_fail (scheme != NULL, FALSE);\n  for (i = 0; category == NULL && i < G_N_ELEMENTS (known_schemes); i++)\n    {\n      if (g_regex_match_simple (known_schemes[i].pattern, scheme, G_REGEX_CASELESS, 0))\n        {\n          *succeed = exo_open_launch_category (known_schemes[i].category, uri);\n          return TRUE;\n        }\n    }\n  return FALSE;\n}", "target": 0}
{"code": "execlists_unwind_incomplete_requests(struct intel_engine_execlists *execlists)\n{\n\tstruct intel_engine_cs *engine =\n\t\tcontainer_of(execlists, typeof(*engine), execlists);\n\treturn __unwind_incomplete_requests(engine);\n}", "target": 0}
{"code": "int yr_object_copy(\n    YR_OBJECT* object,\n    YR_OBJECT** object_copy)\n{\n  YR_OBJECT* copy;\n  YR_OBJECT* o;\n  YR_STRUCTURE_MEMBER* structure_member;\n  YR_OBJECT_FUNCTION* func;\n  YR_OBJECT_FUNCTION* func_copy;\n  int i;\n  *object_copy = NULL;\n  FAIL_ON_ERROR(yr_object_create(\n      object->type,\n      object->identifier,\n      NULL,\n      &copy));\n  switch(object->type)\n  {\n    case OBJECT_TYPE_INTEGER:\n      ((YR_OBJECT_INTEGER*) copy)->value = UNDEFINED;\n      break;\n    case OBJECT_TYPE_STRING:\n      ((YR_OBJECT_STRING*) copy)->value = NULL;\n      break;\n    case OBJECT_TYPE_FUNCTION:\n      func = (YR_OBJECT_FUNCTION*) object;\n      func_copy = (YR_OBJECT_FUNCTION*) copy;\n      FAIL_ON_ERROR_WITH_CLEANUP(\n        yr_object_copy(func->return_obj, &func_copy->return_obj),\n        yr_object_destroy(copy));\n      for (i = 0; i < MAX_OVERLOADED_FUNCTIONS; i++)\n        func_copy->prototypes[i] = func->prototypes[i];\n      break;\n    case OBJECT_TYPE_STRUCTURE:\n      structure_member = ((YR_OBJECT_STRUCTURE*) object)->members;\n      while (structure_member != NULL)\n      {\n        FAIL_ON_ERROR_WITH_CLEANUP(\n            yr_object_copy(structure_member->object, &o),\n            yr_object_destroy(copy));\n        FAIL_ON_ERROR_WITH_CLEANUP(\n            yr_object_structure_set_member(copy, o),\n            yr_free(o);\n            yr_object_destroy(copy));\n        structure_member = structure_member->next;\n      }\n      break;\n    case OBJECT_TYPE_ARRAY:\n      yr_object_copy(\n        ((YR_OBJECT_ARRAY *) object)->prototype_item,\n        &o);\n      ((YR_OBJECT_ARRAY *)copy)->prototype_item = o;\n      break;\n    case OBJECT_TYPE_DICTIONARY:\n      yr_object_copy(\n        ((YR_OBJECT_DICTIONARY *) object)->prototype_item,\n        &o);\n      ((YR_OBJECT_DICTIONARY *)copy)->prototype_item = o;\n      break;\n    default:\n      assert(FALSE);\n  }\n  *object_copy = copy;\n  return ERROR_SUCCESS;\n}", "target": 1}
{"code": "static void fio_cluster_client_handler(struct cluster_pr_s *pr) {\n  switch ((fio_cluster_message_type_e)pr->type) {\n  case FIO_CLUSTER_MSG_FORWARD: \n  case FIO_CLUSTER_MSG_JSON:\n    fio_publish2process(fio_msg_internal_dup(pr->msg));\n    break;\n  case FIO_CLUSTER_MSG_SHUTDOWN:\n    fio_stop();\n    kill(getpid(), SIGINT);\n  case FIO_CLUSTER_MSG_ERROR:         \n  case FIO_CLUSTER_MSG_PING:          \n  case FIO_CLUSTER_MSG_ROOT:          \n  case FIO_CLUSTER_MSG_ROOT_JSON:     \n  case FIO_CLUSTER_MSG_PUBSUB_SUB:    \n  case FIO_CLUSTER_MSG_PUBSUB_UNSUB:  \n  case FIO_CLUSTER_MSG_PATTERN_SUB:   \n  case FIO_CLUSTER_MSG_PATTERN_UNSUB: \n  default:\n    break;\n  }\n}", "target": 0}
{"code": "comics_remove_dir (gchar *path_name) \n{\n\tGDir  *content_dir;\n\tconst gchar *filename;\n\tgchar *filename_with_path;\n\tif (g_file_test (path_name, G_FILE_TEST_IS_DIR)) {\n\t\tcontent_dir = g_dir_open  (path_name, 0, NULL);\n\t\tfilename  = g_dir_read_name (content_dir);\n\t\twhile (filename) {\n\t\t\tfilename_with_path = \n\t\t\t\tg_build_filename (path_name, \n\t\t\t\t\t\t  filename, NULL);\n\t\t\tcomics_remove_dir (filename_with_path);\n\t\t\tg_free (filename_with_path);\n\t\t\tfilename = g_dir_read_name (content_dir);\n\t\t}\n\t\tg_dir_close (content_dir);\n\t}\n\treturn (g_remove (path_name));\n}", "target": 1}
{"code": "\tChunk *outChunk() { return m_outChunk.get(); }", "target": 0}
{"code": "void WifiPacket::handle_prism(const u_char *pc, size_t len)\n{\n    prism2_pkthdr hdr;\n    hdr.host_time \t= EXTRACT_LE_32BITS(pc+32);\n    hdr.mac_time \t= EXTRACT_LE_32BITS(pc+44);\n    hdr.channel \t= EXTRACT_LE_32BITS(pc+56);\n    hdr.rssi \t\t= EXTRACT_LE_32BITS(pc+68);\n    hdr.sq \t\t= EXTRACT_LE_32BITS(pc+80);\n    hdr.signal  \t= EXTRACT_LE_32BITS(pc+92);\n    hdr.noise   \t= EXTRACT_LE_32BITS(pc+104);\n    hdr.rate\t\t= EXTRACT_LE_32BITS(pc+116)/2;\n    hdr.istx\t\t= EXTRACT_LE_32BITS(pc+128);\n    cbs->HandlePrism( *this, &hdr, pc + 144, len - 144);\n    handle_80211(pc+144,len-144);\n}", "target": 1}
{"code": "spnego_gss_inquire_names_for_mech(\n\t\t\t\tOM_uint32\t*minor_status,\n\t\t\t\tgss_OID\t\tmechanism,\n\t\t\t\tgss_OID_set\t*name_types)\n{\n\tOM_uint32   major, minor;\n\tdsyslog(\"Entering inquire_names_for_mech\\n\");\n\tif ((mechanism != GSS_C_NULL_OID) &&\n\t    !g_OID_equal(gss_mech_spnego, mechanism)) {\n\t\t*minor_status = 0;\n\t\treturn (GSS_S_FAILURE);\n\t}\n\tmajor = gss_create_empty_oid_set(minor_status, name_types);\n\tif (major == GSS_S_COMPLETE) {\n\t\tif (((major = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_USER_NAME,\n\t\t\t\tname_types)) == GSS_S_COMPLETE) &&\n\t\t    ((major = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_MACHINE_UID_NAME,\n\t\t\t\tname_types)) == GSS_S_COMPLETE) &&\n\t\t    ((major = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_STRING_UID_NAME,\n\t\t\t\tname_types)) == GSS_S_COMPLETE)) {\n\t\t\tmajor = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_HOSTBASED_SERVICE,\n\t\t\t\tname_types);\n\t\t}\n\t\tif (major != GSS_S_COMPLETE)\n\t\t\t(void) gss_release_oid_set(&minor, name_types);\n\t}\n\tdsyslog(\"Leaving inquire_names_for_mech\\n\");\n\treturn (major);\n}", "target": 0}
{"code": "RAMBlock *qemu_ram_alloc_from_ptr(struct uc_struct *uc, ram_addr_t size, void *host,\n                                   MemoryRegion *mr)\n{\n    RAMBlock *new_block;\n    ram_addr_t max_size = size;\n    size = HOST_PAGE_ALIGN(uc, size);\n    max_size = HOST_PAGE_ALIGN(uc, max_size);\n    new_block = g_malloc0(sizeof(*new_block));\n    if (new_block == NULL)\n        return NULL;\n    new_block->mr = mr;\n    new_block->used_length = size;\n    new_block->max_length = max_size;\n    assert(max_size >= size);\n    new_block->page_size = uc->qemu_real_host_page_size;\n    new_block->host = host;\n    if (host) {\n        new_block->flags |= RAM_PREALLOC;\n    }\n    uc->invalid_addr = UC_ERR_OK;\n    ram_block_add(mr->uc, new_block);\n    if (uc->invalid_error != UC_ERR_OK) {\n        g_free(new_block);\n        return NULL;\n    }\n    return new_block;\n}", "target": 0}
{"code": "void JNIid::deallocate(JNIid* current) {\n  while (current != NULL) {\n    JNIid* next = current->next();\n    delete current;\n    current = next;\n  }\n}", "target": 0}
{"code": "int inet_sk_rebuild_header(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct rtable *rt = (struct rtable *)__sk_dst_check(sk, 0);\n\t__be32 daddr;\n\tint err;\n\tif (rt)\n\t\treturn 0;\n\tdaddr = inet->inet_daddr;\n\tif (inet->opt && inet->opt->srr)\n\t\tdaddr = inet->opt->faddr;\n\trt = ip_route_output_ports(sock_net(sk), sk, daddr, inet->inet_saddr,\n\t\t\t\t   inet->inet_dport, inet->inet_sport,\n\t\t\t\t   sk->sk_protocol, RT_CONN_FLAGS(sk),\n\t\t\t\t   sk->sk_bound_dev_if);\n\tif (!IS_ERR(rt)) {\n\t\terr = 0;\n\t\tsk_setup_caps(sk, &rt->dst);\n\t} else {\n\t\terr = PTR_ERR(rt);\n\t\tsk->sk_route_caps = 0;\n\t\tif (!sysctl_ip_dynaddr ||\n\t\t    sk->sk_state != TCP_SYN_SENT ||\n\t\t    (sk->sk_userlocks & SOCK_BINDADDR_LOCK) ||\n\t\t    (err = inet_sk_reselect_saddr(sk)) != 0)\n\t\t\tsk->sk_err_soft = -err;\n\t}\n\treturn err;\n}", "target": 1}
{"code": "static bool validate_net_dev(struct net_device *net_dev,\n\t\t\t     const struct sockaddr *daddr,\n\t\t\t     const struct sockaddr *saddr)\n{\n\tconst struct sockaddr_in *daddr4 = (const struct sockaddr_in *)daddr;\n\tconst struct sockaddr_in *saddr4 = (const struct sockaddr_in *)saddr;\n\tconst struct sockaddr_in6 *daddr6 = (const struct sockaddr_in6 *)daddr;\n\tconst struct sockaddr_in6 *saddr6 = (const struct sockaddr_in6 *)saddr;\n\tswitch (daddr->sa_family) {\n\tcase AF_INET:\n\t\treturn saddr->sa_family == AF_INET &&\n\t\t       validate_ipv4_net_dev(net_dev, daddr4, saddr4);\n\tcase AF_INET6:\n\t\treturn saddr->sa_family == AF_INET6 &&\n\t\t       validate_ipv6_net_dev(net_dev, daddr6, saddr6);\n\tdefault:\n\t\treturn false;\n\t}\n}", "target": 0}
{"code": "static int sanitize_val_alu(struct bpf_verifier_env *env,\n\t\t\t    struct bpf_insn *insn)\n{\n\tstruct bpf_insn_aux_data *aux = cur_aux(env);\n\tif (can_skip_alu_sanitation(env, insn))\n\t\treturn 0;\n\treturn update_alu_sanitation_state(aux, BPF_ALU_NON_POINTER, 0);\n}", "target": 0}
{"code": "int rtp_packetize_xiph_config( sout_stream_id_sys_t *id, const char *fmtp,\n                               int64_t i_pts )\n{\n    if (fmtp == NULL)\n        return VLC_EGENERIC;\n    char *start = strstr(fmtp, \"configuration=\");\n    assert(start != NULL);\n    start += sizeof(\"configuration=\") - 1;\n    char *end = strchr(start, ';');\n    assert(end != NULL);\n    size_t len = end - start;\n    char b64[len + 1];\n    memcpy(b64, start, len);\n    b64[len] = '\\0';\n    int     i_max   = rtp_mtu (id) - 6; \n    uint8_t *p_orig, *p_data;\n    int i_data;\n    i_data = vlc_b64_decode_binary(&p_orig, b64);\n    if (i_data <= 9)\n    {\n        free(p_orig);\n        return VLC_EGENERIC;\n    }\n    p_data = p_orig + 9;\n    i_data -= 9;\n    int i_count = ( i_data + i_max - 1 ) / i_max;\n    for( int i = 0; i < i_count; i++ )\n    {\n        int           i_payload = __MIN( i_max, i_data );\n        block_t *out = block_Alloc( 18 + i_payload );\n        unsigned fragtype, numpkts;\n        if (i_count == 1)\n        {\n            fragtype = 0;\n            numpkts = 1;\n        }\n        else\n        {\n            numpkts = 0;\n            if (i == 0)\n                fragtype = 1;\n            else if (i == i_count - 1)\n                fragtype = 3;\n            else\n                fragtype = 2;\n        }\n        uint32_t header = ((XIPH_IDENT & 0xffffff) << 8) |\n                          (fragtype << 6) | (1 << 4) | numpkts;\n        rtp_packetize_common( id, out, 0, i_pts );\n        SetDWBE( out->p_buffer + 12, header);\n        SetWBE( out->p_buffer + 16, i_payload);\n        memcpy( &out->p_buffer[18], p_data, i_payload );\n        out->i_dts    = i_pts;\n        rtp_packetize_send( id, out );\n        p_data += i_payload;\n        i_data -= i_payload;\n    }\n    free(p_orig);\n    return VLC_SUCCESS;\n}", "target": 1}
{"code": "void SmallVectorTemplateBase<T, isPodLike>::grow(size_t MinSize) {\n  if (MinSize > UINT32_MAX)\n    report_bad_alloc_error(\"SmallVector capacity overflow during allocation\");\n  size_t NewCapacity = size_t(NextPowerOf2(this->capacity() + 2));\n  NewCapacity = std::min(std::max(NewCapacity, MinSize), size_t(UINT32_MAX));\n  T *NewElts = static_cast<T*>(llvh::safe_malloc(NewCapacity*sizeof(T)));\n  this->uninitialized_move(this->begin(), this->end(), NewElts);\n  destroy_range(this->begin(), this->end());\n  if (!this->isSmall())\n    free(this->begin());\n  this->BeginX = NewElts;\n  this->Capacity = NewCapacity;\n}", "target": 1}
{"code": "do_local_notify(xmlNode * notify_src, const char *client_id,\n                gboolean sync_reply, gboolean from_peer)\n{\n    cib_client_t *client_obj = NULL;\n    int local_rc = pcmk_ok;\n    if (client_id != NULL) {\n        client_obj = g_hash_table_lookup(client_list, client_id);\n    } else {\n        crm_trace(\"No client to sent the response to. F_CIB_CLIENTID not set.\");\n    }\n    if (client_obj == NULL) {\n        local_rc = -ECONNRESET;\n    } else {\n        int rid = 0;\n        if(sync_reply) {\n            CRM_LOG_ASSERT(client_obj->request_id);\n            rid = client_obj->request_id;\n            client_obj->request_id = 0;\n            crm_trace(\"Sending response %d to %s %s\",\n                      rid, client_obj->name, from_peer?\"(originator of delegated request)\":\"\");\n        } else {\n            crm_trace(\"Sending an event to %s %s\",\n                      client_obj->name, from_peer?\"(originator of delegated request)\":\"\");\n        }\n        if (client_obj->ipc && crm_ipcs_send(client_obj->ipc, rid, notify_src, !sync_reply) < 0) {\n            local_rc = -ENOMSG;\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        } else if (client_obj->session) {\n            crm_send_remote_msg(client_obj->session, notify_src, client_obj->encrypted);\n#endif\n        } else if(client_obj->ipc == NULL) {\n            crm_err(\"Unknown transport for %s\", client_obj->name);\n        }\n    }\n    if (local_rc != pcmk_ok && client_obj != NULL) {\n        crm_warn(\"%sSync reply to %s failed: %s\",\n                 sync_reply ? \"\" : \"A-\",\n                 client_obj ? client_obj->name : \"<unknown>\", pcmk_strerror(local_rc));\n    }\n}", "target": 1}
{"code": "static int ieee80211_fragment(struct ieee80211_tx_data *tx,\n\t\t\t      struct sk_buff *skb, int hdrlen,\n\t\t\t      int frag_threshold)\n{\n\tstruct ieee80211_local *local = tx->local;\n\tstruct ieee80211_tx_info *info;\n\tstruct sk_buff *tmp;\n\tint per_fragm = frag_threshold - hdrlen - FCS_LEN;\n\tint pos = hdrlen + per_fragm;\n\tint rem = skb->len - hdrlen - per_fragm;\n\tif (WARN_ON(rem < 0))\n\t\treturn -EINVAL;\n\twhile (rem) {\n\t\tint fraglen = per_fragm;\n\t\tif (fraglen > rem)\n\t\t\tfraglen = rem;\n\t\trem -= fraglen;\n\t\ttmp = dev_alloc_skb(local->tx_headroom +\n\t\t\t\t    frag_threshold +\n\t\t\t\t    tx->sdata->encrypt_headroom +\n\t\t\t\t    IEEE80211_ENCRYPT_TAILROOM);\n\t\tif (!tmp)\n\t\t\treturn -ENOMEM;\n\t\t__skb_queue_tail(&tx->skbs, tmp);\n\t\tskb_reserve(tmp,\n\t\t\t    local->tx_headroom + tx->sdata->encrypt_headroom);\n\t\tmemcpy(tmp->cb, skb->cb, sizeof(tmp->cb));\n\t\tinfo = IEEE80211_SKB_CB(tmp);\n\t\tinfo->flags &= ~(IEEE80211_TX_CTL_CLEAR_PS_FILT |\n\t\t\t\t IEEE80211_TX_CTL_FIRST_FRAGMENT);\n\t\tif (rem)\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_MORE_FRAMES;\n\t\tskb_copy_queue_mapping(tmp, skb);\n\t\ttmp->priority = skb->priority;\n\t\ttmp->dev = skb->dev;\n\t\tmemcpy(skb_put(tmp, hdrlen), skb->data, hdrlen);\n\t\tmemcpy(skb_put(tmp, fraglen), skb->data + pos, fraglen);\n\t\tpos += fraglen;\n\t}\n\tskb->len = hdrlen + per_fragm;\n\treturn 0;\n}", "target": 1}
{"code": "MATCHER_P(HeaderMapEqualIgnoreOrder, expected, \"\") {\n  const bool equal = TestUtility::headerMapEqualIgnoreOrder(*arg, *expected);\n  if (!equal) {\n    *result_listener << \"\\n\"\n                     << TestUtility::addLeftAndRightPadding(\"Expected header map:\") << \"\\n\"\n                     << *expected\n                     << TestUtility::addLeftAndRightPadding(\"is not equal to actual header map:\")\n                     << \"\\n\"\n                     << *arg << TestUtility::addLeftAndRightPadding(\"\") \n                     << \"\\n\";\n  }\n  return equal;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) final {\n    const Tensor& superdiag = context->input(0);\n    const Tensor& maindiag = context->input(1);\n    const Tensor& subdiag = context->input(2);\n    const Tensor& rhs = context->input(3);\n    const int ndims = rhs.dims();\n    OP_REQUIRES(\n        context, ndims >= 2,\n        errors::InvalidArgument(\"Input must have rank >= 2, but got \", ndims));\n    OP_REQUIRES_OK(context, ValidateInputTensor(superdiag, \"superdiag\", rhs));\n    OP_REQUIRES_OK(context, ValidateInputTensor(maindiag, \"maindiag\", rhs));\n    OP_REQUIRES_OK(context, ValidateInputTensor(subdiag, \"subdiag\", rhs));\n    int64 batch_size = 1;\n    for (int i = 0; i < ndims - 2; i++) {\n      batch_size *= rhs.dim_size(i);\n    }\n    const int m = rhs.dim_size(ndims - 2);\n    const int n = rhs.dim_size(ndims - 1);\n    Tensor* output;\n    OP_REQUIRES_OK(context, context->allocate_output(0, rhs.shape(), &output));\n    const Eigen::GpuDevice& device = context->eigen_device<Eigen::GpuDevice>();\n    GpuLaunchConfig cfg = GetGpuLaunchConfig(1, device);\n    TF_CHECK_OK(GpuLaunchKernel(\n        TridiagonalMatMulKernel<Scalar>, cfg.block_count, cfg.thread_per_block,\n        0, device.stream(), batch_size, m, n, superdiag.flat<Scalar>().data(),\n        maindiag.flat<Scalar>().data(), subdiag.flat<Scalar>().data(),\n        rhs.flat<Scalar>().data(), output->flat<Scalar>().data()));\n  }", "target": 0}
{"code": "get_image_extensions(void)\n{\n\tGHashTable *extensions;\n\tGSList *formats = gdk_pixbuf_get_formats ();\n\tGSList *l;\n\tguint i;\n\tconst char *known_image_formats[] = {\n\t\t\"png\",\n\t\t\"jpg\",\n\t\t\"jpeg\",\n\t\t\"webp\"\n\t};\n\textensions = g_hash_table_new_full (g_str_hash, g_str_equal,\n\t\t\t\t\t    g_free, NULL);\n\tfor (l = formats; l != NULL; l = l->next) {\n\t\tint i;\n\t\tgchar **ext = gdk_pixbuf_format_get_extensions (l->data);\n\t\tfor (i = 0; ext[i] != NULL; i++) {\n\t\t\tg_hash_table_insert (extensions,\n\t\t\t\t\t     g_strdup (ext[i]),\n\t\t\t\t\t     GINT_TO_POINTER (FORMAT_SUPPORTED));\n\t\t}\n\t\tg_strfreev (ext);\n\t}\n\tg_slist_free (formats);\n\tfor (i = 0; i < G_N_ELEMENTS (known_image_formats); i++) {\n\t\tif (!g_hash_table_lookup (extensions, known_image_formats[i])) {\n\t\t\tg_hash_table_insert (extensions,\n\t\t\t\t\t     g_strdup (known_image_formats[i]),\n\t\t\t\t\t     GINT_TO_POINTER (FORMAT_UNSUPPORTED));\n\t\t}\n\t}\n\treturn extensions;\n}", "target": 0}
{"code": "static inline void init_keys(at91_aes_key_size_t *key_size,\n\t\t\t     unsigned int *cipher_key,\n\t\t\t     unsigned int *cmac_key,\n\t\t\t     unsigned int *iv)\n{\n#if defined(CONFIG_AES_KEY_SIZE_128)\n\t*key_size = AT91_AES_KEY_SIZE_128;\n#elif defined(CONFIG_AES_KEY_SIZE_192)\n\t*key_size = AT91_AES_KEY_SIZE_192;\n#elif defined(CONFIG_AES_KEY_SIZE_256)\n\t*key_size = AT91_AES_KEY_SIZE_256;\n#else\n#error \"bad AES key size\"\n#endif\n\tiv[0]\t\t= CONFIG_AES_IV_WORD0;\n\tiv[1]\t\t= CONFIG_AES_IV_WORD1;\n\tiv[2]\t\t= CONFIG_AES_IV_WORD2;\n\tiv[3]\t\t= CONFIG_AES_IV_WORD3;\n\tcipher_key[0]\t= CONFIG_AES_CIPHER_KEY_WORD0;\n\tcmac_key[0]\t= CONFIG_AES_CMAC_KEY_WORD0;\n\tcipher_key[1]\t= CONFIG_AES_CIPHER_KEY_WORD1;\n\tcmac_key[1]\t= CONFIG_AES_CMAC_KEY_WORD1;\n\tcipher_key[2]\t= CONFIG_AES_CIPHER_KEY_WORD2;\n\tcmac_key[2]\t= CONFIG_AES_CMAC_KEY_WORD2;\n\tcipher_key[3]\t= CONFIG_AES_CIPHER_KEY_WORD3;\n\tcmac_key[3]\t= CONFIG_AES_CMAC_KEY_WORD3;\n#if defined(CONFIG_AES_KEY_SIZE_192) || defined(CONFIG_AES_KEY_SIZE_256)\n\tcipher_key[4]\t= CONFIG_AES_CIPHER_KEY_WORD4;\n\tcmac_key[4]\t= CONFIG_AES_CMAC_KEY_WORD4;\n\tcipher_key[5]\t= CONFIG_AES_CIPHER_KEY_WORD5;\n\tcmac_key[5]\t= CONFIG_AES_CMAC_KEY_WORD5;\n#endif\n#if defined(CONFIG_AES_KEY_SIZE_256)\n\tcipher_key[6]\t= CONFIG_AES_CIPHER_KEY_WORD6;\n\tcmac_key[6]\t= CONFIG_AES_CMAC_KEY_WORD6;\n\tcipher_key[7]\t= CONFIG_AES_CIPHER_KEY_WORD7;\n\tcmac_key[7]\t= CONFIG_AES_CMAC_KEY_WORD7;\n#endif\n}", "target": 1}
{"code": "static int nfs4_open_recover_helper(struct nfs4_opendata *opendata, mode_t openflags, struct nfs4_state **res)\n{\n\tstruct nfs4_state *newstate;\n\tint ret;\n\topendata->o_arg.open_flags = openflags;\n\tmemset(&opendata->o_res, 0, sizeof(opendata->o_res));\n\tmemset(&opendata->c_res, 0, sizeof(opendata->c_res));\n\tnfs4_init_opendata_res(opendata);\n\tret = _nfs4_proc_open(opendata);\n\tif (ret != 0)\n\t\treturn ret; \n\tnewstate = nfs4_opendata_to_nfs4_state(opendata);\n\tif (IS_ERR(newstate))\n\t\treturn PTR_ERR(newstate);\n\tnfs4_close_state(&opendata->path, newstate, openflags);\n\t*res = newstate;\n\treturn 0;\n}", "target": 1}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_source_debug_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 6;\n\tif (sz < 8) {\n\t\treturn NULL;\n\t}\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_SOURCE_DEBUG_EXTENTSION_ATTR;\n\tif (attr->length == 0) {\n\t\teprintf (\"r_bin_java_source_debug_attr_new: Attempting to allocate 0 bytes for debug_extension.\\n\");\n\t\tattr->info.debug_extensions.debug_extension = NULL;\n\t\treturn attr;\n\t} else if ((attr->length + offset) > sz) {\n\t\teprintf (\"r_bin_java_source_debug_attr_new: Expected %d byte(s) got %\"\n\t\t\tPFMT64d \" bytes for debug_extension.\\n\", attr->length, (offset + sz));\n\t}\n\tattr->info.debug_extensions.debug_extension = (ut8 *) malloc (attr->length);\n\tif (attr->info.debug_extensions.debug_extension && (attr->length > (sz - offset))) {\n\t\tmemcpy (attr->info.debug_extensions.debug_extension, buffer + offset, sz - offset);\n\t} else if (attr->info.debug_extensions.debug_extension) {\n\t\tmemcpy (attr->info.debug_extensions.debug_extension, buffer + offset, attr->length);\n\t} else {\n\t\teprintf (\"r_bin_java_source_debug_attr_new: Unable to allocate the data for the debug_extension.\\n\");\n\t}\n\toffset += attr->length;\n\tattr->size = offset;\n\treturn attr;\n}", "target": 0}
{"code": "static const char *set_add_default_charset(cmd_parms *cmd,\n                                           void *d_, const char *arg)\n{\n    core_dir_config *d = d_;\n    if (!ap_cstr_casecmp(arg, \"Off\")) {\n       d->add_default_charset = ADD_DEFAULT_CHARSET_OFF;\n    }\n    else if (!ap_cstr_casecmp(arg, \"On\")) {\n       d->add_default_charset = ADD_DEFAULT_CHARSET_ON;\n       d->add_default_charset_name = DEFAULT_ADD_DEFAULT_CHARSET_NAME;\n    }\n    else {\n       d->add_default_charset = ADD_DEFAULT_CHARSET_ON;\n       d->add_default_charset_name = arg;\n    }\n    return NULL;\n}", "target": 0}
{"code": "pid_t LightProcess::waitpid(pid_t pid, int *stat_loc, int options,\n                            int timeout) {\n  if (!Available()) {\n    return ::waitpid(pid, stat_loc, options);\n  }\n  int id = GetId();\n  Lock lock(g_procs[id].m_procMutex);\n  fprintf(g_procs[id].m_fout, \"waitpid\\n%\" PRId64 \" %d %d\\n\", (int64_t)pid, options,\n          timeout);\n  fflush(g_procs[id].m_fout);\n  char buf[BUFFER_SIZE];\n  read_buf(g_procs[id].m_fin, buf);\n  if (!buf[0]) return -1;\n  int64_t ret;\n  int stat;\n  sscanf(buf, \"%\" PRId64 \" %d\", &ret, &stat);\n  *stat_loc = stat;\n  if (ret < 0) {\n    read_buf(g_procs[id].m_fin, buf);\n    sscanf(buf, \"%d\", &errno);\n  }\n  return (pid_t)ret;\n}", "target": 1}
{"code": "smb_fdata(netdissect_options *ndo,\n          const u_char *buf, const char *fmt, const u_char *maxbuf,\n          int unicodestr)\n{\n    static int depth = 0;\n    char s[128];\n    char *p;\n    while (*fmt) {\n\tswitch (*fmt) {\n\tcase '*':\n\t    fmt++;\n\t    while (buf < maxbuf) {\n\t\tconst u_char *buf2;\n\t\tdepth++;\n\t\tbuf2 = smb_fdata(ndo, buf, fmt, maxbuf, unicodestr);\n\t\tdepth--;\n\t\tif (buf2 == NULL)\n\t\t    return(NULL);\n\t\tif (buf2 == buf)\n\t\t    return(buf);\n\t\tbuf = buf2;\n\t    }\n\t    return(buf);\n\tcase '|':\n\t    fmt++;\n\t    if (buf >= maxbuf)\n\t\treturn(buf);\n\t    break;\n\tcase '%':\n\t    fmt++;\n\t    buf = maxbuf;\n\t    break;\n\tcase '#':\n\t    fmt++;\n\t    return(buf);\n\t    break;\n\tcase '[':\n\t    fmt++;\n\t    if (buf >= maxbuf)\n\t\treturn(buf);\n\t    memset(s, 0, sizeof(s));\n\t    p = strchr(fmt, ']');\n\t    if ((size_t)(p - fmt + 1) > sizeof(s)) {\n\t\treturn(buf);\n\t    }\n\t    strncpy(s, fmt, p - fmt);\n\t    s[p - fmt] = '\\0';\n\t    fmt = p + 1;\n\t    buf = smb_fdata1(ndo, buf, s, maxbuf, unicodestr);\n\t    if (buf == NULL)\n\t\treturn(NULL);\n\t    break;\n\tdefault:\n\t    ND_PRINT((ndo, \"%c\", *fmt));\n\t    fmt++;\n\t    break;\n\t}\n    }\n    if (!depth && buf < maxbuf) {\n\tsize_t len = PTR_DIFF(maxbuf, buf);\n\tND_PRINT((ndo, \"Data: (%lu bytes)\\n\", (unsigned long)len));\n\tsmb_print_data(ndo, buf, len);\n\treturn(buf + len);\n    }\n    return(buf);\n}", "target": 1}
{"code": "static int snd_ctl_elem_user_tlv(struct snd_kcontrol *kcontrol,\n\t\t\t\t int op_flag,\n\t\t\t\t unsigned int size,\n\t\t\t\t unsigned int __user *tlv)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\tint change = 0;\n\tvoid *new_data;\n\tif (op_flag > 0) {\n\t\tif (size > 1024 * 128)\t\n\t\t\treturn -EINVAL;\n\t\tnew_data = memdup_user(tlv, size);\n\t\tif (IS_ERR(new_data))\n\t\t\treturn PTR_ERR(new_data);\n\t\tchange = ue->tlv_data_size != size;\n\t\tif (!change)\n\t\t\tchange = memcmp(ue->tlv_data, new_data, size);\n\t\tkfree(ue->tlv_data);\n\t\tue->tlv_data = new_data;\n\t\tue->tlv_data_size = size;\n\t} else {\n\t\tif (! ue->tlv_data_size || ! ue->tlv_data)\n\t\t\treturn -ENXIO;\n\t\tif (size < ue->tlv_data_size)\n\t\t\treturn -ENOSPC;\n\t\tif (copy_to_user(tlv, ue->tlv_data, ue->tlv_data_size))\n\t\t\treturn -EFAULT;\n\t}\n\treturn change;\n}", "target": 1}
{"code": "static int asymmetric_key_match(const struct key *key,\n\t\t\t\tconst struct key_match_data *match_data)\n{\n\tconst struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\n\tconst char *description = match_data->raw_data;\n\tconst char *spec = description;\n\tconst char *id;\n\tptrdiff_t speclen;\n\tif (!subtype || !spec || !*spec)\n\t\treturn 0;\n\tif (key->description && strcmp(key->description, description) == 0)\n\t\treturn 1;\n\tid = strchr(spec, ':');\n\tif (!id)\n\t\treturn 0;\n\tspeclen = id - spec;\n\tid++;\n\tif (speclen == 2 && memcmp(spec, \"id\", 2) == 0)\n\t\treturn asymmetric_keyid_match(asymmetric_key_id(key), id);\n\tif (speclen == subtype->name_len &&\n\t    memcmp(spec, subtype->name, speclen) == 0)\n\t\treturn 1;\n\treturn 0;\n}", "target": 1}
{"code": "AudioContext* AudioContext::create(Document& document, ExceptionState& exceptionState)\n{\n    ASSERT(isMainThread());\n    if (s_hardwareContextCount >= MaxHardwareContexts) {\n        exceptionState.throwDOMException(\n            SyntaxError,\n            \"number of hardware contexts reached maximum (\" + String::number(MaxHardwareContexts) + \").\");\n        return 0;\n    }\n    AudioContext* audioContext = new AudioContext(&document);\n    audioContext->suspendIfNeeded();\n    return audioContext;\n}", "target": 0}
{"code": "static int crypto_report_one(struct crypto_alg *alg,\n\t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n{\n\tstrlcpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));\n\tstrlcpy(ualg->cru_driver_name, alg->cra_driver_name,\n\t\tsizeof(ualg->cru_driver_name));\n\tstrlcpy(ualg->cru_module_name, module_name(alg->cra_module),\n\t\tsizeof(ualg->cru_module_name));\n\tualg->cru_type = 0;\n\tualg->cru_mask = 0;\n\tualg->cru_flags = alg->cra_flags;\n\tualg->cru_refcnt = refcount_read(&alg->cra_refcnt);\n\tif (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))\n\t\tgoto nla_put_failure;\n\tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n\t\tstruct crypto_report_larval rl;\n\t\tstrlcpy(rl.type, \"larval\", sizeof(rl.type));\n\t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n\t\t\t    sizeof(struct crypto_report_larval), &rl))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\tif (alg->cra_type && alg->cra_type->report) {\n\t\tif (alg->cra_type->report(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\tswitch (alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL)) {\n\tcase CRYPTO_ALG_TYPE_CIPHER:\n\t\tif (crypto_report_cipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_COMPRESS:\n\t\tif (crypto_report_comp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_ACOMPRESS:\n\t\tif (crypto_report_acomp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_AKCIPHER:\n\t\tif (crypto_report_akcipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_KPP:\n\t\tif (crypto_report_kpp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\t}\nout:\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "perf_output_sample_regs(struct perf_output_handle *handle,\n\t\t\tstruct pt_regs *regs, u64 mask)\n{\n\tint bit;\n\tfor_each_set_bit(bit, (const unsigned long *) &mask,\n\t\t\t sizeof(mask) * BITS_PER_BYTE) {\n\t\tu64 val;\n\t\tval = perf_reg_value(regs, bit);\n\t\tperf_output_put(handle, val);\n\t}\n}", "target": 0}
{"code": "void RenderView::OnShouldClose() {\n  bool should_close = webview()->dispatchBeforeUnloadEvent();\n  Send(new ViewHostMsg_ShouldClose_ACK(routing_id_, should_close));\n}", "target": 0}
{"code": "WebSharedWorker* RenderView::createSharedWorker(\n    WebFrame* frame, const WebURL& url, const WebString& name,\n    unsigned long long document_id) {\n  int route_id = MSG_ROUTING_NONE;\n  bool exists = false;\n  bool url_mismatch = false;\n  ViewHostMsg_CreateWorker_Params params;\n  params.url = url;\n  params.is_shared = true;\n  params.name = name;\n  params.document_id = document_id;\n  params.render_view_route_id = routing_id_;\n  params.route_id = MSG_ROUTING_NONE;\n  params.parent_appcache_host_id = 0;\n  params.script_resource_appcache_id = 0;\n  Send(new ViewHostMsg_LookupSharedWorker(\n      params, &exists, &route_id, &url_mismatch));\n  if (url_mismatch) {\n    return NULL;\n  } else {\n    return new WebSharedWorkerProxy(RenderThread::current(),\n                                    document_id,\n                                    exists,\n                                    route_id,\n                                    routing_id_);\n  }\n}", "target": 0}
{"code": "gss_delete_sec_context (minor_status,\n                        context_handle,\n                        output_token)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t *\t\tcontext_handle;\ngss_buffer_t\t\toutput_token;\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    status = val_del_sec_ctx_args(minor_status, context_handle, output_token);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n    ctx = (gss_union_ctx_id_t) *context_handle;\n    if (GSSINT_CHK_LOOP(ctx))\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n    status = gssint_delete_internal_sec_context(minor_status,\n\t\t\t\t\t\tctx->mech_type,\n\t\t\t\t\t\t&ctx->internal_ctx_id,\n\t\t\t\t\t\toutput_token);\n    if (status)\n\treturn status;\n    free(ctx->mech_type->elements);\n    free(ctx->mech_type);\n    free(*context_handle);\n    *context_handle = GSS_C_NO_CONTEXT;\n    return (GSS_S_COMPLETE);\n}", "target": 1}
{"code": "static int ebt_size_mwt(struct compat_ebt_entry_mwt *match32,\n\t\t\tunsigned int size_left, enum compat_mwt type,\n\t\t\tstruct ebt_entries_buf_state *state, const void *base)\n{\n\tint growth = 0;\n\tchar *buf;\n\tif (size_left == 0)\n\t\treturn 0;\n\tbuf = (char *) match32;\n\twhile (size_left >= sizeof(*match32)) {\n\t\tstruct ebt_entry_match *match_kern;\n\t\tint ret;\n\t\tmatch_kern = (struct ebt_entry_match *) state->buf_kern_start;\n\t\tif (match_kern) {\n\t\t\tchar *tmp;\n\t\t\ttmp = state->buf_kern_start + state->buf_kern_offset;\n\t\t\tmatch_kern = (struct ebt_entry_match *) tmp;\n\t\t}\n\t\tret = ebt_buf_add(state, buf, sizeof(*match32));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsize_left -= sizeof(*match32);\n\t\tret = ebt_buf_add_pad(state, ebt_compat_entry_padsize());\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (match32->match_size > size_left)\n\t\t\treturn -EINVAL;\n\t\tsize_left -= match32->match_size;\n\t\tret = compat_mtw_from_user(match32, type, state, base);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (WARN_ON(ret < match32->match_size))\n\t\t\treturn -EINVAL;\n\t\tgrowth += ret - match32->match_size;\n\t\tgrowth += ebt_compat_entry_padsize();\n\t\tbuf += sizeof(*match32);\n\t\tbuf += match32->match_size;\n\t\tif (match_kern)\n\t\t\tmatch_kern->match_size = ret;\n\t\tWARN_ON(type == EBT_COMPAT_TARGET && size_left);\n\t\tmatch32 = (struct compat_ebt_entry_mwt *) buf;\n\t}\n\treturn growth;\n}", "target": 1}
{"code": "R_API ut8 *r_bin_java_get_attr_buf(RBinJavaObj *bin, ut64 sz, const ut64 offset, const ut8 *buf, const ut64 len) {\n\tut8 *attr_buf = NULL;\n\tint pending = len - offset;\n\tconst ut8 *a_buf = offset + buf;\n\tattr_buf = (ut8 *) calloc (pending + 1, 1);\n\tif (!attr_buf) {\n\t\teprintf (\"Unable to allocate enough bytes (0x%04\"PFMT64x\n\t\t\t\") to read in the attribute.\\n\", sz);\n\t\treturn attr_buf;\n\t}\n\tmemcpy (attr_buf, a_buf, pending); \n\treturn attr_buf;\n}", "target": 1}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  TFLITE_DCHECK(node->builtin_data != nullptr);\n  OpData* data = static_cast<OpData*>(node->user_data);\n  const auto params =\n      static_cast<const TfLiteFullyConnectedParams*>(node->builtin_data);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  const TfLiteTensor* filter = GetInput(context, node, kWeightsTensor);\n  TF_LITE_ENSURE(context, filter != nullptr);\n  const TfLiteTensor* bias = GetOptionalInputTensor(context, node, kBiasTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  TF_LITE_ENSURE_MSG(context, input->type == filter->type,\n                     \"Hybrid models are not supported on TFLite Micro.\");\n  return CalculateOpData(context, params->activation, input->type, input,\n                         filter, bias, output, data);\n}", "target": 0}
{"code": "u64 local_clock(void)\n{\n\tif (!sched_clock_stable())\n\t\treturn sched_clock_cpu(raw_smp_processor_id());\n\treturn sched_clock();\n}", "target": 0}
{"code": "remote_addr(VALUE self) {\n    return req_remote_addr((agooReq)DATA_PTR(self));\n}", "target": 0}
{"code": "R_API size_t r_str_ansi_strip(char *str) {\n\tsize_t i = 0;\n\twhile (str[i]) {\n\t\tsize_t chlen = __str_ansi_length (str + i);\n\t\tif (chlen > 1) {\n\t\t\tr_str_cpy (str + i + 1, str + i + chlen);\n\t\t}\n\t\ti++;\n\t}\n\treturn i;\n}", "target": 1}
{"code": "void ciEnv::cache_jvmti_state() {\n  VM_ENTRY_MARK;\n  MutexLocker mu(JvmtiThreadState_lock);\n  _jvmti_can_hotswap_or_post_breakpoint = JvmtiExport::can_hotswap_or_post_breakpoint();\n  _jvmti_can_access_local_variables     = JvmtiExport::can_access_local_variables();\n  _jvmti_can_post_on_exceptions         = JvmtiExport::can_post_on_exceptions();\n  _jvmti_can_pop_frame                  = JvmtiExport::can_pop_frame();\n}", "target": 0}
{"code": "static int process_options(int argc, char *argv[], char *operation)\n{\n  int error= 0;\n  int i= 0;\n  if ((error= handle_options(&argc, &argv, my_long_options, get_one_option)))\n    goto exit;\n  if (opt_print_defaults)\n  {\n    error= -1;\n    goto exit;\n  }\n  if (opt_basedir)\n  {\n    i= (int)strlength(opt_basedir);\n    if (opt_basedir[i-1] != FN_LIBCHAR || opt_basedir[i-1] != FN_LIBCHAR2)\n    {\n      char buff[FN_REFLEN];\n      memset(buff, 0, sizeof(buff));\n      strncpy(buff, opt_basedir, sizeof(buff) - 1);\n#ifdef __WIN__\n      strncat(buff, \"/\", sizeof(buff) - strlen(buff) - 1);\n#else\n      strncat(buff, FN_DIRSEP, sizeof(buff) - strlen(buff) - 1);\n#endif\n      buff[sizeof(buff) - 1]= 0;\n      my_free(opt_basedir);\n      opt_basedir= my_strdup(buff, MYF(MY_FAE));\n    }\n  }\n  if (!opt_no_defaults && ((error= get_default_values())))\n  {\n    error= -1;\n    goto exit;\n  }\n  strcpy(operation, \"\");\n  if ((error = check_options(argc, argv, operation)))\n  {\n    goto exit;\n  }\n  if (opt_verbose)\n  {\n    printf(\"#    basedir = %s\\n\", opt_basedir);\n    printf(\"# plugin_dir = %s\\n\", opt_plugin_dir);\n    printf(\"#    datadir = %s\\n\", opt_datadir);\n    printf(\"# plugin_ini = %s\\n\", opt_plugin_ini);\n  }\nexit:\n  return error;\n}", "target": 0}
{"code": "void lxc_execute_bind_init(struct lxc_conf *conf)\n{\n\tint ret;\n\tchar path[PATH_MAX], destpath[PATH_MAX], *p;\n\tp = choose_init(conf->rootfs.mount);\n\tif (p) {\n\t\tfree(p);\n\t\treturn;\n\t}\n\tret = snprintf(path, PATH_MAX, SBINDIR \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Path name too long searching for lxc.init.static\");\n\t\treturn;\n\t}\n\tif (!file_exists(path)) {\n\t\tINFO(\"%s does not exist on host\", path);\n\t\treturn;\n\t}\n\tret = snprintf(destpath, PATH_MAX, \"%s%s\", conf->rootfs.mount, \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Path name too long for container's lxc.init.static\");\n\t\treturn;\n\t}\n\tif (!file_exists(destpath)) {\n\t\tFILE * pathfile = fopen(destpath, \"wb\");\n\t\tif (!pathfile) {\n\t\t\tSYSERROR(\"Failed to create mount target '%s'\", destpath);\n\t\t\treturn;\n\t\t}\n\t\tfclose(pathfile);\n\t}\n\tret = mount(path, destpath, \"none\", MS_BIND, NULL);\n\tif (ret < 0)\n\t\tSYSERROR(\"Failed to bind lxc.init.static into container\");\n\tINFO(\"lxc.init.static bound into container at %s\", path);\n}", "target": 1}
{"code": "TfLiteStatus GetTemporarySafe(const TfLiteContext* context,\n                              const TfLiteNode* node, int index,\n                              TfLiteTensor** tensor) {\n  int tensor_index;\n  TF_LITE_ENSURE_OK(context, ValidateTensorIndexingSafe(\n                                 context, index, node->temporaries->size,\n                                 node->temporaries->data, &tensor_index));\n  *tensor = GetTensorAtIndex(context, tensor_index);\n  return kTfLiteOk;\n}", "target": 0}
{"code": "drm_atomic_state_init(struct drm_device *dev, struct drm_atomic_state *state)\n{\n\tkref_init(&state->ref);\n\tstate->allow_modeset = true;\n\tstate->crtcs = kcalloc(dev->mode_config.num_crtc,\n\t\t\t       sizeof(*state->crtcs), GFP_KERNEL);\n\tif (!state->crtcs)\n\t\tgoto fail;\n\tstate->planes = kcalloc(dev->mode_config.num_total_plane,\n\t\t\t\tsizeof(*state->planes), GFP_KERNEL);\n\tif (!state->planes)\n\t\tgoto fail;\n\tdrm_dev_get(dev);\n\tstate->dev = dev;\n\tdrm_dbg_atomic(dev, \"Allocated atomic state %p\\n\", state);\n\treturn 0;\nfail:\n\tdrm_atomic_state_default_release(state);\n\treturn -ENOMEM;\n}", "target": 0}
{"code": "hphp_libxml_input_buffer(const char *URI, xmlCharEncoding enc) {\n  if (s_libxml_errors->m_entity_loader_disabled) {\n    return nullptr;\n  }\n  return __xmlParserInputBufferCreateFilename(URI, enc);\n}", "target": 0}
{"code": "GF_Err gf_media_change_pl(GF_ISOFile *file, u32 track, u32 profile, u32 compat, u32 level)\n{\n\tu32 i, count, stype;\n\tGF_Err e;\n\tGF_AVCConfig *avcc;\n\tstype = gf_isom_get_media_subtype(file, track, 1);\n\tswitch (stype) {\n\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_OK;\n\t}\n\tavcc = gf_isom_avc_config_get(file, track, 1);\n\tif (!avcc)\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\tif (level) avcc->AVCLevelIndication = level;\n\tif (compat) avcc->profile_compatibility = compat;\n\tif (profile) avcc->AVCProfileIndication = profile;\n\tcount = gf_list_count(avcc->sequenceParameterSets);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *slc = gf_list_get(avcc->sequenceParameterSets, i);\n\t\tif (profile) slc->data[1] = profile;\n\t\tif (level) slc->data[3] = level;\n\t}\n\te = gf_isom_avc_config_update(file, track, 1, avcc);\n\tgf_odf_avc_cfg_del(avcc);\n\treturn e;\n}", "target": 0}
{"code": "void CoreUserInputHandler::putPrivmsg(const QByteArray &target, const QByteArray &message, Cipher *cipher)\n{\n    static const char *cmd = \"PRIVMSG\";\n    static const char *splitter = \" .,-!?\";\n    int maxSplitPos = message.count();\n    int splitPos = maxSplitPos;\n    forever {\n        QByteArray crypted = message.left(splitPos);\n        bool isEncrypted = false;\n#ifdef HAVE_QCA2\n        if (cipher && !cipher->key().isEmpty() && !message.isEmpty()) {\n            isEncrypted = cipher->encrypt(crypted);\n        }\n#endif\n        int overrun = lastParamOverrun(cmd, QList<QByteArray>() << target << crypted);\n        if (overrun) {\n            if (!isEncrypted)\n                maxSplitPos = message.count() - overrun;\n            splitPos = -1;\n            for (const char *splitChar = splitter; *splitChar != 0; splitChar++) {\n                splitPos = qMax(splitPos, message.lastIndexOf(*splitChar, maxSplitPos) + 1); \n            }\n            if (splitPos <= 0 || splitPos > maxSplitPos)\n                splitPos = maxSplitPos;\n            maxSplitPos = splitPos - 1;\n            if (maxSplitPos <= 0) { \n                qWarning() << tr(\"[Error] Could not encrypt your message: %1\").arg(message.data());\n                return;\n            }\n            continue; \n        }\n        putCmd(cmd, QList<QByteArray>() << target << crypted);\n        if (splitPos < message.count())\n            putPrivmsg(target, message.mid(splitPos), cipher);\n        return;\n    }\n}", "target": 1}
{"code": "void gf_isom_sample_entry_init(GF_SampleEntryBox *ent)\n{\n\tent->internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S;\n}", "target": 0}
{"code": "bool PackLinuxElf32::calls_crt1(Elf32_Rel const *rel, int sz)\n{\n    if (!dynsym || !dynstr) {\n        return false;\n    }\n    for (unsigned relnum= 0; 0 < sz; (sz -= sizeof(Elf32_Rel)), ++rel, ++relnum) {\n        unsigned const symnum = get_te32(&rel->r_info) >> 8;\n        char const *const symnam = get_dynsym_name(symnum, relnum);\n        if (0==strcmp(symnam, \"__libc_start_main\")  \n        ||  0==strcmp(symnam, \"__libc_init\")  \n        ||  0==strcmp(symnam, \"__uClibc_main\")\n        ||  0==strcmp(symnam, \"__uClibc_start_main\"))\n            return true;\n    }\n    return false;\n}", "target": 1}
{"code": "xfs_bmap_alloc(\n\tstruct xfs_bmalloca\t*ap)\t\n{\n\tif (XFS_IS_REALTIME_INODE(ap->ip) &&\n\t    xfs_alloc_is_userdata(ap->datatype))\n\t\treturn xfs_bmap_rtalloc(ap);\n\treturn xfs_bmap_btalloc(ap);\n}", "target": 0}
{"code": "bool chopOff(string &domain) \n{\n  if(domain.empty())\n    return false;\n  string::size_type fdot=domain.find('.');\n  if(fdot==string::npos) \n    domain=\"\";\n  else {\n    string::size_type remain = domain.length() - (fdot + 1);\n    char tmp[remain];\n    memcpy(tmp, domain.c_str()+fdot+1, remain);\n    domain.assign(tmp, remain); \n  }\n  return true;\n}", "target": 1}
{"code": "int setTypeAdd(robj *subject, sds value) {\n    long long llval;\n    if (subject->encoding == OBJ_ENCODING_HT) {\n        dict *ht = subject->ptr;\n        dictEntry *de = dictAddRaw(ht,value,NULL);\n        if (de) {\n            dictSetKey(ht,de,sdsdup(value));\n            dictSetVal(ht,de,NULL);\n            return 1;\n        }\n    } else if (subject->encoding == OBJ_ENCODING_INTSET) {\n        if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {\n            uint8_t success = 0;\n            subject->ptr = intsetAdd(subject->ptr,llval,&success);\n            if (success) {\n                if (intsetLen(subject->ptr) > server.set_max_intset_entries)\n                    setTypeConvert(subject,OBJ_ENCODING_HT);\n                return 1;\n            }\n        } else {\n            setTypeConvert(subject,OBJ_ENCODING_HT);\n            serverAssert(dictAdd(subject->ptr,sdsdup(value),NULL) == DICT_OK);\n            return 1;\n        }\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n    return 0;\n}", "target": 1}
{"code": "nfsd4_encode_layoutget(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\tstruct nfsd4_layoutget *lgp)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tconst struct nfsd4_layout_ops *ops =\n\t\tnfsd4_layout_ops[lgp->lg_layout_type];\n\t__be32 *p;\n\tdprintk(\"%s: err %d\\n\", __func__, nfserr);\n\tif (nfserr)\n\t\tgoto out;\n\tnfserr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 36 + sizeof(stateid_opaque_t));\n\tif (!p)\n\t\tgoto out;\n\t*p++ = cpu_to_be32(1);\t\n\t*p++ = cpu_to_be32(lgp->lg_sid.si_generation);\n\tp = xdr_encode_opaque_fixed(p, &lgp->lg_sid.si_opaque,\n\t\t\t\t    sizeof(stateid_opaque_t));\n\t*p++ = cpu_to_be32(1);\t\n\tp = xdr_encode_hyper(p, lgp->lg_seg.offset);\n\tp = xdr_encode_hyper(p, lgp->lg_seg.length);\n\t*p++ = cpu_to_be32(lgp->lg_seg.iomode);\n\t*p++ = cpu_to_be32(lgp->lg_layout_type);\n\tnfserr = ops->encode_layoutget(xdr, lgp);\nout:\n\tkfree(lgp->lg_content);\n\treturn nfserr;\n}", "target": 1}
{"code": "static int umocktypes_are_equal_bool_ptr(bool** left, bool** right)\n{\n    int result;\n    if (*left == *right)\n    {\n        result = 1;\n    }\n    else\n    {\n        if (*(*left) == *(*right))\n        {\n            result = 1;\n        }\n        else\n        {\n            result = 0;\n        }\n    }\n    return result;\n}", "target": 0}
{"code": "    StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,\n                                                     size_t xTriggerLevelBytes,\n                                                     BaseType_t xIsMessageBuffer )\n    {\n        uint8_t * pucAllocatedMemory;\n        uint8_t ucFlags;\n        if( xIsMessageBuffer == pdTRUE )\n        {\n            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;\n            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );\n        }\n        else\n        {\n            ucFlags = 0;\n            configASSERT( xBufferSizeBytes > 0 );\n        }\n        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );\n        if( xTriggerLevelBytes == ( size_t ) 0 )\n        {\n            xTriggerLevelBytes = ( size_t ) 1;\n        }\n        xBufferSizeBytes++;\n        pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); \n        if( pucAllocatedMemory != NULL )\n        {\n            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory,         \n                                          pucAllocatedMemory + sizeof( StreamBuffer_t ),  \n                                          xBufferSizeBytes,\n                                          xTriggerLevelBytes,\n                                          ucFlags );\n            traceSTREAM_BUFFER_CREATE( ( ( StreamBuffer_t * ) pucAllocatedMemory ), xIsMessageBuffer );\n        }\n        else\n        {\n            traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );\n        }\n        return ( StreamBufferHandle_t ) pucAllocatedMemory; \n    }", "target": 1}
{"code": "static Jsi_RC NumberToFixedCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[100];\n    int prec = 0, skip = 0;\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    Jsi_Value *pa = Jsi_ValueArrayIndex(interp, args, skip);\n    if (pa && Jsi_GetIntFromValue(interp, pa, &prec) != JSI_OK)\n        return JSI_ERROR;\n    if (prec<0) prec = 0;\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    snprintf(buf, sizeof(buf), \"%.*\" JSI_NUMFFMT, prec, num);\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}", "target": 1}
{"code": "void jslGetTokenString(char *str, size_t len) {\n  if (lex->tk == LEX_ID) {\n    strncpy(str, \"ID:\", len);\n    strncat(str, jslGetTokenValueAsString(), len);\n  } else if (lex->tk == LEX_STR) {\n    strncpy(str, \"String:'\", len);\n    strncat(str, jslGetTokenValueAsString(), len);\n    strncat(str, \"'\", len);\n  } else\n    jslTokenAsString(lex->tk, str, len);\n}", "target": 1}
{"code": "static void fio_signal_handler_setup(void) {\n  struct sigaction act;\n  if (fio_old_sig_int.sa_handler)\n    return;\n  memset(&act, 0, sizeof(act));\n  act.sa_handler = sig_int_handler;\n  sigemptyset(&act.sa_mask);\n  act.sa_flags = SA_RESTART | SA_NOCLDSTOP;\n  if (sigaction(SIGINT, &act, &fio_old_sig_int)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n  if (sigaction(SIGTERM, &act, &fio_old_sig_term)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n#if !FIO_DISABLE_HOT_RESTART\n  if (sigaction(SIGUSR1, &act, &fio_old_sig_usr1)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n#endif\n  act.sa_handler = SIG_IGN;\n  if (sigaction(SIGPIPE, &act, &fio_old_sig_pipe)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n}", "target": 1}
{"code": "static int r_jws_verify_sig_hmac(jws_t * jws, jwk_t * jwk) {\n  unsigned char * sig = r_jws_sign_hmac(jws, jwk);\n  int ret;\n  if (sig != NULL && 0 == o_strcmp((const char *)jws->signature_b64url, (const char *)sig)) {\n    ret = RHN_OK;\n  } else {\n    ret = RHN_ERROR_INVALID;\n  }\n  o_free(sig);\n  return ret;\n}", "target": 1}
{"code": "static int copy_counters_to_user(struct ebt_table *t,\n\t\t\t\t  const struct ebt_counter *oldcounters,\n\t\t\t\t  void __user *user, unsigned int num_counters,\n\t\t\t\t  unsigned int nentries)\n{\n\tstruct ebt_counter *counterstmp;\n\tint ret = 0;\n\tif (num_counters == 0)\n\t\treturn 0;\n\tif (num_counters != nentries) {\n\t\tBUGPRINT(\"Num_counters wrong\\n\");\n\t\treturn -EINVAL;\n\t}\n\tcounterstmp = vmalloc(nentries * sizeof(*counterstmp));\n\tif (!counterstmp)\n\t\treturn -ENOMEM;\n\twrite_lock_bh(&t->lock);\n\tget_counters(oldcounters, counterstmp, nentries);\n\twrite_unlock_bh(&t->lock);\n\tif (copy_to_user(user, counterstmp,\n\t   nentries * sizeof(struct ebt_counter)))\n\t\tret = -EFAULT;\n\tvfree(counterstmp);\n\treturn ret;\n}", "target": 0}
{"code": "decode_definite_string(CBORDecoderObject *self, Py_ssize_t length)\n{\n    PyObject *ret = NULL;\n    char *buf;\n    buf = PyMem_Malloc(length);\n    if (!buf)\n        return PyErr_NoMemory();\n    if (fp_read(self, buf, length) == 0)\n        ret = PyUnicode_DecodeUTF8(\n                buf, length, PyBytes_AS_STRING(self->str_errors));\n    PyMem_Free(buf);\n    if (!ret)\n        return NULL;\n    if (string_namespace_add(self, ret, length) == -1) {\n        Py_DECREF(ret);\n        return NULL;\n    }\n    return ret;\n}", "target": 1}
{"code": "static const char *set_max_reversals(cmd_parms *cmd, void *conf_, const char *arg)\n{\n    core_dir_config *conf = conf_;\n    int val = 0;\n    if (!ap_cstr_casecmp(arg, \"none\")) {\n        val = AP_MAXRANGES_NORANGES;\n    }\n    else if (!ap_cstr_casecmp(arg, \"default\")) {\n        val = AP_MAXRANGES_DEFAULT;\n    }\n    else if (!ap_cstr_casecmp(arg, \"unlimited\")) {\n        val = AP_MAXRANGES_UNLIMITED;\n    }\n    else {\n        val = atoi(arg);\n        if (val <= 0)\n            return \"MaxRangeReversals requires 'none', 'default', 'unlimited' or \"\n            \"a positive integer\";\n    }\n    conf->max_reversals = val;\n    return NULL;\n}", "target": 0}
{"code": "static int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps)\n{\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tmemcpy(&kvm->arch.vpit->pit_state, ps, sizeof(struct kvm_pit_state));\n\tkvm_pit_load_count(kvm, 0, ps->channels[0].count, 0);\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn 0;\n}", "target": 1}
{"code": "static int vivid_fb_ioctl(struct fb_info *info, unsigned cmd, unsigned long arg)\n{\n\tstruct vivid_dev *dev = (struct vivid_dev *)info->par;\n\tswitch (cmd) {\n\tcase FBIOGET_VBLANK: {\n\t\tstruct fb_vblank vblank;\n\t\tmemset(&vblank, 0, sizeof(vblank));\n\t\tvblank.flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT |\n\t\t\tFB_VBLANK_HAVE_VSYNC;\n\t\tvblank.count = 0;\n\t\tvblank.vcount = 0;\n\t\tvblank.hcount = 0;\n\t\tif (copy_to_user((void __user *)arg, &vblank, sizeof(vblank)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tdefault:\n\t\tdprintk(dev, 1, \"Unknown ioctl %08x\\n\", cmd);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "bit_write_MC (Bit_Chain *dat, BITCODE_MC val)\n{\n  int i, j;\n  int negative = 0;\n  unsigned char byte[5];\n  BITCODE_UMC mask = 0x0000007f;\n  BITCODE_UMC value = (BITCODE_UMC)val;\n  if (val < 0)\n    {\n      negative = 1;\n      value = (BITCODE_UMC)-val;\n    }\n  for (i = 4, j = 0; i >= 0; i--, j += 7)\n    {\n      byte[i] = (unsigned char)((value & mask) >> j);\n      byte[i] |= 0x80;\n      mask = mask << 7;\n    }\n  for (i = 0; i < 4; i++)\n    if (byte[i] & 0x7f)\n      break;\n  if (byte[i] & 0x40)\n    i--;\n  byte[i] &= 0x7f;\n  if (negative)\n    byte[i] |= 0x40;\n  for (j = 4; j >= i; j--)\n    bit_write_RC (dat, byte[j]);\n}", "target": 1}
{"code": "static int set_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)\n{\n\treturn usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),\n\t\t\t       RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,\n\t\t\t       indx, 0, data, size, 500);\n}", "target": 1}
{"code": "smix(uint8_t * B, size_t r, uint64_t N, void * V, void * XY)\n{\n  __m128i * X = (__m128i *) XY;\n  __m128i * Y = (__m128i *) ((uintptr_t)(XY) + 128 * r);\n  __m128i * Z = (__m128i *) ((uintptr_t)(XY) + 256 * r);\n  uint32_t * X32 = (uint32_t *)X;\n  uint64_t i, j;\n  size_t k;\n  for (k = 0; k < 2 * r; k++) {\n    for (i = 0; i < 16; i++) {\n      X32[k * 16 + i] = folly::Endian::little32(\n                          *((uint32_t *) &B[(k * 16 + (i * 5 % 16)) * 4]));\n    }\n  }\n  for (i = 0; i < N; i += 2) {\n    blkcpy((void *)((uintptr_t)(V) + i * 128 * r), X, 128 * r);\n    blockmix_salsa8(X, Y, Z, r);\n    blkcpy((void *)((uintptr_t)(V) + (i + 1) * 128 * r),\n        Y, 128 * r);\n    blockmix_salsa8(Y, X, Z, r);\n  }\n  for (i = 0; i < N; i += 2) {\n    j = integerify(X, r) & (N - 1);\n    blkxor(X, (void *)((uintptr_t)(V) + j * 128 * r), 128 * r);\n    blockmix_salsa8(X, Y, Z, r);\n    j = integerify(Y, r) & (N - 1);\n    blkxor(Y, (void *)((uintptr_t)(V) + j * 128 * r), 128 * r);\n    blockmix_salsa8(Y, X, Z, r);\n  }\n  for (k = 0; k < 2 * r; k++) {\n    for (i = 0; i < 16; i++) {\n      *((uint32_t *) &B[(k * 16 + (i * 5 % 16)) * 4]) =\n          folly::Endian::little32(X32[k * 16 + i]);\n    }\n  }\n}", "target": 1}
{"code": "int btrfs_get_dev_stats(struct btrfs_fs_info *fs_info,\n\t\t\tstruct btrfs_ioctl_get_dev_stats *stats)\n{\n\tstruct btrfs_device *dev;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tint i;\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(fs_info->fs_devices, stats->devid, NULL, NULL);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\tif (!dev) {\n\t\tbtrfs_warn(fs_info, \"get dev_stats failed, device not found\");\n\t\treturn -ENODEV;\n\t} else if (!dev->dev_stats_valid) {\n\t\tbtrfs_warn(fs_info, \"get dev_stats failed, not yet valid\");\n\t\treturn -ENODEV;\n\t} else if (stats->flags & BTRFS_DEV_STATS_RESET) {\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++) {\n\t\t\tif (stats->nr_items > i)\n\t\t\t\tstats->values[i] =\n\t\t\t\t\tbtrfs_dev_stat_read_and_reset(dev, i);\n\t\t\telse\n\t\t\t\tbtrfs_dev_stat_reset(dev, i);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++)\n\t\t\tif (stats->nr_items > i)\n\t\t\t\tstats->values[i] = btrfs_dev_stat_read(dev, i);\n\t}\n\tif (stats->nr_items > BTRFS_DEV_STAT_VALUES_MAX)\n\t\tstats->nr_items = BTRFS_DEV_STAT_VALUES_MAX;\n\treturn 0;\n}", "target": 1}
{"code": "static struct nfs4_state *nfs4_do_open(struct inode *dir, struct path *path, int flags, struct iattr *sattr, struct rpc_cred *cred)\n{\n\tstruct nfs4_exception exception = { };\n\tstruct nfs4_state *res;\n\tint status;\n\tdo {\n\t\tstatus = _nfs4_do_open(dir, path, flags, sattr, cred, &res);\n\t\tif (status == 0)\n\t\t\tbreak;\n\t\tif (status == -NFS4ERR_BAD_SEQID) {\n\t\t\tprintk(KERN_WARNING \"NFS: v4 server %s \"\n\t\t\t\t\t\" returned a bad sequence-id error!\\n\",\n\t\t\t\t\tNFS_SERVER(dir)->nfs_client->cl_hostname);\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -NFS4ERR_BAD_STATEID) {\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -EAGAIN) {\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tres = ERR_PTR(nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t\tstatus, &exception));\n\t} while (exception.retry);\n\treturn res;\n}", "target": 1}
{"code": "static int f2fs_swap_activate(struct swap_info_struct *sis, struct file *file,\n\t\t\t\tsector_t *span)\n{\n\tstruct inode *inode = file_inode(file);\n\tint ret;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\tif (f2fs_readonly(F2FS_I_SB(inode)->sb))\n\t\treturn -EROFS;\n\tret = f2fs_convert_inline_inode(inode);\n\tif (ret)\n\t\treturn ret;\n\tret = check_swap_activate(file, sis->max);\n\tif (ret)\n\t\treturn ret;\n\tset_inode_flag(inode, FI_PIN_FILE);\n\tf2fs_precache_extents(inode);\n\tf2fs_update_time(F2FS_I_SB(inode), REQ_TIME);\n\treturn 0;\n}", "target": 0}
{"code": "BigInt EC_Group::square_mod_order(const BigInt& x) const\n   {\n   return data().square_mod_order(x);\n   }", "target": 0}
{"code": "archive_read_format_zip_cleanup(struct archive_read *a)\n{\n\tstruct zip *zip;\n\tstruct zip_entry *zip_entry, *next_zip_entry;\n\tzip = (struct zip *)(a->format->data);\n#ifdef HAVE_ZLIB_H\n\tif (zip->stream_valid)\n\t\tinflateEnd(&zip->stream);\n#endif\n#if HAVA_LZMA_H && HAVE_LIBLZMA\n    if (zip->zipx_lzma_valid) {\n\t\tlzma_end(&zip->zipx_lzma_stream);\n\t}\n#endif\n#ifdef HAVE_BZLIB_H\n\tif (zip->bzstream_valid) {\n\t\tBZ2_bzDecompressEnd(&zip->bzstream);\n\t}\n#endif\n\tfree(zip->uncompressed_buffer);\n\tif (zip->ppmd8_valid)\n\t\t__archive_ppmd8_functions.Ppmd8_Free(&zip->ppmd8);\n\tif (zip->zip_entries) {\n\t\tzip_entry = zip->zip_entries;\n\t\twhile (zip_entry != NULL) {\n\t\t\tnext_zip_entry = zip_entry->next;\n\t\t\tarchive_string_free(&zip_entry->rsrcname);\n\t\t\tfree(zip_entry);\n\t\t\tzip_entry = next_zip_entry;\n\t\t}\n\t}\n\tfree(zip->decrypted_buffer);\n\tif (zip->cctx_valid)\n\t\tarchive_decrypto_aes_ctr_release(&zip->cctx);\n\tif (zip->hctx_valid)\n\t\tarchive_hmac_sha1_cleanup(&zip->hctx);\n\tfree(zip->iv);\n\tfree(zip->erd);\n\tfree(zip->v_data);\n\tarchive_string_free(&zip->format_name);\n\tfree(zip);\n\t(a->format->data) = NULL;\n\treturn (ARCHIVE_OK);\n}", "target": 1}
{"code": "static ssize_t oz_cdev_write(struct file *filp, const char __user *buf,\n\t\tsize_t count, loff_t *fpos)\n{\n\tstruct oz_pd *pd;\n\tstruct oz_elt_buf *eb;\n\tstruct oz_elt_info *ei;\n\tstruct oz_elt *elt;\n\tstruct oz_app_hdr *app_hdr;\n\tstruct oz_serial_ctx *ctx;\n\tif (count > sizeof(ei->data) - sizeof(*elt) - sizeof(*app_hdr))\n\t\treturn -EINVAL;\n\tspin_lock_bh(&g_cdev.lock);\n\tpd = g_cdev.active_pd;\n\tif (pd)\n\t\toz_pd_get(pd);\n\tspin_unlock_bh(&g_cdev.lock);\n\tif (pd == NULL)\n\t\treturn -ENXIO;\n\tif (!(pd->state & OZ_PD_S_CONNECTED))\n\t\treturn -EAGAIN;\n\teb = &pd->elt_buff;\n\tei = oz_elt_info_alloc(eb);\n\tif (ei == NULL) {\n\t\tcount = 0;\n\t\tgoto out;\n\t}\n\telt = (struct oz_elt *)ei->data;\n\tapp_hdr = (struct oz_app_hdr *)(elt+1);\n\telt->length = sizeof(struct oz_app_hdr) + count;\n\telt->type = OZ_ELT_APP_DATA;\n\tei->app_id = OZ_APPID_SERIAL;\n\tei->length = elt->length + sizeof(struct oz_elt);\n\tapp_hdr->app_id = OZ_APPID_SERIAL;\n\tif (copy_from_user(app_hdr+1, buf, count))\n\t\tgoto out;\n\tspin_lock_bh(&pd->app_lock[OZ_APPID_USB-1]);\n\tctx = (struct oz_serial_ctx *)pd->app_ctx[OZ_APPID_SERIAL-1];\n\tif (ctx) {\n\t\tapp_hdr->elt_seq_num = ctx->tx_seq_num++;\n\t\tif (ctx->tx_seq_num == 0)\n\t\t\tctx->tx_seq_num = 1;\n\t\tspin_lock(&eb->lock);\n\t\tif (oz_queue_elt_info(eb, 0, 0, ei) == 0)\n\t\t\tei = NULL;\n\t\tspin_unlock(&eb->lock);\n\t}\n\tspin_unlock_bh(&pd->app_lock[OZ_APPID_USB-1]);\nout:\n\tif (ei) {\n\t\tcount = 0;\n\t\tspin_lock_bh(&eb->lock);\n\t\toz_elt_info_free(eb, ei);\n\t\tspin_unlock_bh(&eb->lock);\n\t}\n\toz_pd_put(pd);\n\treturn count;\n}", "target": 0}
{"code": "crm_send_plaintext(int sock, const char *buf, size_t len)\n{\n    int rc = 0;\n    const char *unsent = buf;\n    int total_send;\n    if (buf == NULL) {\n        return -1;\n    }\n    total_send = len;\n    crm_trace(\"Message on socket %d: size=%d\", sock, len);\n  retry:\n    rc = write(sock, unsent, len);\n    if (rc < 0) {\n        switch (errno) {\n        case EINTR:\n        case EAGAIN:\n            crm_trace(\"Retry\");\n            goto retry;\n        default:\n            crm_perror(LOG_ERR, \"Could only write %d of the remaining %d bytes\", rc, (int) len);\n            break;\n        }\n    } else if (rc < len) {\n        crm_trace(\"Only sent %d of %d remaining bytes\", rc, len);\n        len -= rc;\n        unsent += rc;\n        goto retry;\n     } else {\n        crm_trace(\"Sent %d bytes: %.100s\", rc, buf);\n    }\n    return rc < 0 ? rc : total_send;\n}", "target": 0}
{"code": "PJ_DEF(void) pj_scan_get_until( pj_scanner *scanner,\n\t\t\t\tconst pj_cis_t *spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n    if (s >= scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    while (PJ_SCAN_CHECK_EOF(s) && !pj_cis_match(spec, *s)) {\n\t++s;\n    }\n    pj_strset3(out, scanner->curptr, s);\n    scanner->curptr = s;\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}", "target": 1}
{"code": "int smb2_tree_disconnect(struct ksmbd_work *work)\n{\n\tstruct smb2_tree_disconnect_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct ksmbd_session *sess = work->sess;\n\tstruct ksmbd_tree_connect *tcon = work->tcon;\n\trsp->StructureSize = cpu_to_le16(4);\n\tinc_rfc1001_len(work->response_buf, 4);\n\tksmbd_debug(SMB, \"request\\n\");\n\tif (!tcon) {\n\t\tstruct smb2_tree_disconnect_req *req =\n\t\t\tsmb2_get_msg(work->request_buf);\n\t\tksmbd_debug(SMB, \"Invalid tid %d\\n\", req->hdr.Id.SyncId.TreeId);\n\t\trsp->hdr.Status = STATUS_NETWORK_NAME_DELETED;\n\t\tsmb2_set_err_rsp(work);\n\t\treturn 0;\n\t}\n\tksmbd_close_tree_conn_fds(work);\n\tksmbd_tree_conn_disconnect(sess, tcon);\n\twork->tcon = NULL;\n\treturn 0;\n}", "target": 0}
{"code": "int sss_certmap_get_search_filter(struct sss_certmap_ctx *ctx,\n                                  const uint8_t *der_cert, size_t der_size,\n                                  char **_filter, char ***_domains)\n{\n    int ret;\n    struct match_map_rule *r;\n    struct priority_list *p;\n    struct sss_cert_content *cert_content = NULL;\n    char *filter = NULL;\n    char **domains = NULL;\n    size_t c;\n    if (_filter == NULL || _domains == NULL) {\n        return EINVAL;\n    }\n    ret = sss_cert_get_content(ctx, der_cert, der_size, &cert_content);\n    if (ret != 0) {\n        CM_DEBUG(ctx, \"Failed to get certificate content [%d].\", ret);\n        return ret;\n    }\n    if (ctx->prio_list == NULL) {\n        if (ctx->default_mapping_rule == NULL) {\n            CM_DEBUG(ctx, \"No matching or mapping rules available.\");\n            return EINVAL;\n        }\n        ret = get_filter(ctx, ctx->default_mapping_rule, cert_content, &filter);\n        goto done;\n    }\n    for (p = ctx->prio_list; p != NULL; p = p->next) {\n        for (r = p->rule_list; r != NULL; r = r->next) {\n            ret = do_match(ctx, r->parsed_match_rule, cert_content);\n            if (ret == 0) {\n                ret = get_filter(ctx, r->parsed_mapping_rule, cert_content,\n                                 &filter);\n                if (ret != 0) {\n                    CM_DEBUG(ctx, \"Failed to get filter\");\n                    goto done;\n                }\n                if (r->domains != NULL) {\n                    for (c = 0; r->domains[c] != NULL; c++);\n                    domains = talloc_zero_array(ctx, char *, c + 1);\n                    if (domains == NULL) {\n                        ret = ENOMEM;\n                        goto done;\n                    }\n                    for (c = 0; r->domains[c] != NULL; c++) {\n                        domains[c] = talloc_strdup(domains, r->domains[c]);\n                        if (domains[c] == NULL) {\n                            ret = ENOMEM;\n                            goto done;\n                        }\n                    }\n                }\n                ret = 0;\n                goto done;\n            }\n        }\n    }\n    ret = ENOENT;\ndone:\n    talloc_free(cert_content);\n    if (ret == 0) {\n        *_filter = filter;\n        *_domains = domains;\n    } else {\n        talloc_free(filter);\n        talloc_free(domains);\n    }\n    return ret;\n}", "target": 1}
{"code": "void HeaderMapImpl::addSize(uint64_t size) {\n  if (cached_byte_size_.has_value()) {\n    cached_byte_size_.value() += size;\n  }\n}", "target": 0}
{"code": "std::string Utf16To8(const std::wstring& utf16_string) {\n  return WC2MB(utf16_string, CP_UTF8);\n}", "target": 0}
{"code": "Item *Item_field::update_value_transformer(uchar *select_arg)\n{\n  SELECT_LEX *select= (SELECT_LEX*)select_arg;\n  DBUG_ASSERT(fixed);\n  if (field->table != select->context.table_list->table &&\n      type() != Item::TRIGGER_FIELD_ITEM)\n  {\n    List<Item> *all_fields= &select->join->all_fields;\n    Item **ref_pointer_array= select->ref_pointer_array;\n    DBUG_ASSERT(all_fields->elements <= select->ref_pointer_array_size);\n    int el= all_fields->elements;\n    Item_ref *ref;\n    ref_pointer_array[el]= (Item*)this;\n    all_fields->push_front((Item*)this);\n    ref= new Item_ref(&select->context, ref_pointer_array + el,\n                      table_name, field_name);\n    return ref;\n  }\n  return this;\n}", "target": 0}
{"code": "static void get_sem_elements(struct sem_data *p)\n{\n\tsize_t i;\n\tif (!p || !p->sem_nsems || p->sem_perm.id < 0)\n\t\treturn;\n\tp->elements = xcalloc(p->sem_nsems, sizeof(struct sem_elem));\n\tfor (i = 0; i < p->sem_nsems; i++) {\n\t\tstruct sem_elem *e = &p->elements[i];\n\t\tunion semun arg = { .val = 0 };\n\t\te->semval = semctl(p->sem_perm.id, i, GETVAL, arg);\n\t\tif (e->semval < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETVAL)\");\n\t\te->ncount = semctl(p->sem_perm.id, i, GETNCNT, arg);\n\t\tif (e->ncount < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETNCNT)\");\n\t\te->zcount = semctl(p->sem_perm.id, i, GETZCNT, arg);\n\t\tif (e->zcount < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETZCNT)\");\n\t\te->pid = semctl(p->sem_perm.id, i, GETPID, arg);\n\t\tif (e->pid < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETPID)\");\n\t}\n}", "target": 1}
{"code": "find_by_thp(struct tang_keys_info* tki, const char* target)\n{\n    if (!tki) {\n        return NULL;\n    }\n    json_auto_t* keys = json_deep_copy(tki->m_keys);\n    json_array_extend(keys, tki->m_rotated_keys);\n    size_t idx;\n    json_t* jwk;\n    const char** hashes = supported_hashes();\n    json_array_foreach(keys, idx, jwk) {\n        for (int i = 0; hashes[i]; i++) {\n            __attribute__ ((__cleanup__(cleanup_str))) char* thumbprint = jwk_thumbprint(jwk, hashes[i]);\n            if (!thumbprint || strcmp(thumbprint, target) != 0) {\n                continue;\n            }\n            if (jwk_valid_for_deriving_keys(jwk)) {\n                return json_incref(jwk);\n            } else if (jwk_valid_for_signing(jwk)) {\n                json_auto_t* sign = json_deep_copy(tki->m_sign);\n                if (json_array_append(sign, jwk) == -1) {\n                    return NULL;\n                }\n                json_auto_t* jws = jwk_sign(tki->m_payload, sign);\n                if (!jws) {\n                    return NULL;\n                }\n                return json_incref(jws);\n            }\n        }\n    }\n    return NULL;\n}", "target": 1}
{"code": "int shadow_server_start(rdpShadowServer* server)\n{\n\tBOOL ipc;\n\tBOOL status;\n\tWSADATA wsaData;\n\tif (!server)\n\t\treturn -1;\n\tif (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)\n\t\treturn -1;\n#ifndef _WIN32\n\tsignal(SIGPIPE, SIG_IGN);\n#endif\n\tserver->screen = shadow_screen_new(server);\n\tif (!server->screen)\n\t{\n\t\tWLog_ERR(TAG, \"screen_new failed\");\n\t\treturn -1;\n\t}\n\tserver->capture = shadow_capture_new(server);\n\tif (!server->capture)\n\t{\n\t\tWLog_ERR(TAG, \"capture_new failed\");\n\t\treturn -1;\n\t}\n\tipc = server->ipcSocket && (strncmp(bind_address, server->ipcSocket,\n\t                                    strnlen(bind_address, sizeof(bind_address))) != 0);\n\tif (!ipc)\n\t{\n\t\tsize_t x, count;\n\t\tchar** list = CommandLineParseCommaSeparatedValuesEx(NULL, server->ipcSocket, &count);\n\t\tif (!list || (count <= 1))\n\t\t{\n\t\t\tfree(list);\n\t\t\tif (server->ipcSocket == NULL)\n\t\t\t{\n\t\t\t\tif (!open_port(server, NULL))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t\tfor (x = 1; x < count; x++)\n\t\t{\n\t\t\tBOOL success = open_port(server, list[x]);\n\t\t\tif (!success)\n\t\t\t{\n\t\t\t\tfree(list);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(list);\n\t}\n\telse\n\t{\n\t\tstatus = server->listener->OpenLocal(server->listener, server->ipcSocket);\n\t\tif (!status)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Problem creating local socket listener. (Port already used or \"\n\t\t\t              \"insufficient permissions?)\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (!(server->thread = CreateThread(NULL, 0, shadow_server_thread, (void*)server, 0, NULL)))\n\t{\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static enum hrtimer_restart posix_timer_fn(struct hrtimer *timer)\n{\n\tstruct k_itimer *timr;\n\tunsigned long flags;\n\tint si_private = 0;\n\tenum hrtimer_restart ret = HRTIMER_NORESTART;\n\ttimr = container_of(timer, struct k_itimer, it.real.timer);\n\tspin_lock_irqsave(&timr->it_lock, flags);\n\ttimr->it_active = 0;\n\tif (timr->it_interval != 0)\n\t\tsi_private = ++timr->it_requeue_pending;\n\tif (posix_timer_event(timr, si_private)) {\n\t\tif (timr->it_interval != 0) {\n\t\t\tktime_t now = hrtimer_cb_get_time(timer);\n#ifdef CONFIG_HIGH_RES_TIMERS\n\t\t\t{\n\t\t\t\tktime_t kj = NSEC_PER_SEC / HZ;\n\t\t\t\tif (timr->it_interval < kj)\n\t\t\t\t\tnow = ktime_add(now, kj);\n\t\t\t}\n#endif\n\t\t\ttimr->it_overrun += (unsigned int)\n\t\t\t\thrtimer_forward(timer, now,\n\t\t\t\t\t\ttimr->it_interval);\n\t\t\tret = HRTIMER_RESTART;\n\t\t\t++timr->it_requeue_pending;\n\t\t\ttimr->it_active = 1;\n\t\t}\n\t}\n\tunlock_timer(timr, flags);\n\treturn ret;\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, MaxMinBadHintSelectsReverseIndex) {\n    addIndex(BSON(\"a\" << 1));\n    addIndex(BSON(\"a\" << -1));\n    runInvalidQueryFull(BSONObj(),\n                        BSONObj(),\n                        BSONObj(),\n                        0,\n                        0,\n                        fromjson(\"{a: 1}\"),\n                        fromjson(\"{a: 8}\"),\n                        fromjson(\"{a: 2}\"),\n                        false);\n}", "target": 0}
{"code": "void virtio_config_writew(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint16_t val = data;\n    if (addr > (vdev->config_len - sizeof(val)))\n        return;\n    stw_p(vdev->config + addr, val);\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}", "target": 1}
{"code": "void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n\t{\n\tBN_ULONG t1,t2;\n\tBN_ULONG c1,c2,c3;\n\tc1=0;\n\tc2=0;\n\tc3=0;\n\tmul_add_c(a[0],b[0],c1,c2,c3);\n\tr[0]=c1;\n\tc1=0;\n\tmul_add_c(a[0],b[1],c2,c3,c1);\n\tmul_add_c(a[1],b[0],c2,c3,c1);\n\tr[1]=c2;\n\tc2=0;\n\tmul_add_c(a[2],b[0],c3,c1,c2);\n\tmul_add_c(a[1],b[1],c3,c1,c2);\n\tmul_add_c(a[0],b[2],c3,c1,c2);\n\tr[2]=c3;\n\tc3=0;\n\tmul_add_c(a[0],b[3],c1,c2,c3);\n\tmul_add_c(a[1],b[2],c1,c2,c3);\n\tmul_add_c(a[2],b[1],c1,c2,c3);\n\tmul_add_c(a[3],b[0],c1,c2,c3);\n\tr[3]=c1;\n\tc1=0;\n\tmul_add_c(a[3],b[1],c2,c3,c1);\n\tmul_add_c(a[2],b[2],c2,c3,c1);\n\tmul_add_c(a[1],b[3],c2,c3,c1);\n\tr[4]=c2;\n\tc2=0;\n\tmul_add_c(a[2],b[3],c3,c1,c2);\n\tmul_add_c(a[3],b[2],c3,c1,c2);\n\tr[5]=c3;\n\tc3=0;\n\tmul_add_c(a[3],b[3],c1,c2,c3);\n\tr[6]=c1;\n\tr[7]=c2;\n\t}", "target": 1}
{"code": "vips_utf8_strcasestr( const char *haystack_start, const char *needle_start, \n\tint len_bytes )\n{\n        int needle_len = g_utf8_strlen( needle_start, -1 );\n        int needle_len_bytes = strlen( needle_start );\n\tconst char *haystack;\n\tfor( haystack = haystack_start; \n\t\thaystack - haystack_start <= len_bytes - needle_len_bytes; \n\t\thaystack = g_utf8_find_next_char( haystack, NULL ) ) {\n                const char *needle_char;\n                const char *haystack_char;\n\t\tint i;\n                haystack_char = haystack;\n                needle_char = needle_start;\n                for( i = 0; i < needle_len; i++ ) {\n                        gunichar a = \n\t\t\t\tg_utf8_get_char_validated( haystack_char, \n\t\t\t\t\thaystack_start + len_bytes - haystack );\n                        gunichar b = \n\t\t\t\tg_utf8_get_char_validated( needle_char, -1 );\n                        if( a == (gunichar) -1 ||\n\t\t\t\ta == (gunichar) -2 ||\n\t\t\t\tb == (gunichar) -1 ||\n\t\t\t\tb == (gunichar) -2 )\n                                return( NULL );\n                        if( a == (gunichar) 0 )\n                                return( NULL );\n                        if( g_unichar_tolower( a ) != g_unichar_tolower( b ) )\n                                break;\n                        haystack_char = \n\t\t\t\tg_utf8_find_next_char( haystack_char, \n\t\t\t\t\thaystack_start + len_bytes );\n                        needle_char = \n\t\t\t\tg_utf8_find_next_char( needle_char, NULL );\n                }\n                if( i == needle_len )\n                        return( haystack );\n        }\n        return( NULL );\n}", "target": 1}
{"code": "static int virtio_gpu_object_shmem_init(struct virtio_gpu_device *vgdev,\n\t\t\t\t\tstruct virtio_gpu_object *bo,\n\t\t\t\t\tstruct virtio_gpu_mem_entry **ents,\n\t\t\t\t\tunsigned int *nents)\n{\n\tbool use_dma_api = !virtio_has_dma_quirk(vgdev->vdev);\n\tstruct virtio_gpu_object_shmem *shmem = to_virtio_gpu_shmem(bo);\n\tstruct scatterlist *sg;\n\tint si, ret;\n\tret = drm_gem_shmem_pin(&bo->base);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\tshmem->pages = drm_gem_shmem_get_sg_table(&bo->base);\n\tif (!shmem->pages) {\n\t\tdrm_gem_shmem_unpin(&bo->base);\n\t\treturn -EINVAL;\n\t}\n\tif (use_dma_api) {\n\t\tret = dma_map_sgtable(vgdev->vdev->dev.parent,\n\t\t\t\t      shmem->pages, DMA_TO_DEVICE, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*nents = shmem->mapped = shmem->pages->nents;\n\t} else {\n\t\t*nents = shmem->pages->orig_nents;\n\t}\n\t*ents = kvmalloc_array(*nents,\n\t\t\t       sizeof(struct virtio_gpu_mem_entry),\n\t\t\t       GFP_KERNEL);\n\tif (!(*ents)) {\n\t\tDRM_ERROR(\"failed to allocate ent list\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tif (use_dma_api) {\n\t\tfor_each_sgtable_dma_sg(shmem->pages, sg, si) {\n\t\t\t(*ents)[si].addr = cpu_to_le64(sg_dma_address(sg));\n\t\t\t(*ents)[si].length = cpu_to_le32(sg_dma_len(sg));\n\t\t\t(*ents)[si].padding = 0;\n\t\t}\n\t} else {\n\t\tfor_each_sgtable_sg(shmem->pages, sg, si) {\n\t\t\t(*ents)[si].addr = cpu_to_le64(sg_phys(sg));\n\t\t\t(*ents)[si].length = cpu_to_le32(sg->length);\n\t\t\t(*ents)[si].padding = 0;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "  inline void init (hb_face_t *face,\n\t\t    hb_tag_t _hea_tag, hb_tag_t _mtx_tag,\n\t\t    unsigned int default_advance_)\n  {\n    this->default_advance = default_advance_;\n    this->num_metrics = face->get_num_glyphs ();\n    hb_blob_t *_hea_blob = OT::Sanitizer<OT::_hea>::sanitize (face->reference_table (_hea_tag));\n    const OT::_hea *_hea = OT::Sanitizer<OT::_hea>::lock_instance (_hea_blob);\n    this->num_advances = _hea->numberOfLongMetrics;\n    hb_blob_destroy (_hea_blob);\n    this->blob = OT::Sanitizer<OT::_mtx>::sanitize (face->reference_table (_mtx_tag));\n    if (unlikely (!this->num_advances ||\n\t\t  2 * (this->num_advances + this->num_metrics) < hb_blob_get_length (this->blob)))\n    {\n      this->num_metrics = this->num_advances = 0;\n      hb_blob_destroy (this->blob);\n      this->blob = hb_blob_get_empty ();\n    }\n    this->table = OT::Sanitizer<OT::_mtx>::lock_instance (this->blob);\n  }", "target": 1}
{"code": "static inline ut64 dwarf_read_address(size_t size, const ut8 **buf, const ut8 *buf_end) {\n\tut64 result;\n\tswitch (size) {\n\t\tcase 2:\n\t\tresult = READ16 (*buf); break;\n\t\tcase 4:\n\t\tresult = READ32 (*buf); break;\n\t\tcase 8:\n\t\tresult = READ64 (*buf); break;\n\t\tdefault:\n\t\tresult = 0;\n\t\t*buf += size;\n\t\teprintf (\"Weird dwarf address size: %zu.\", size);\n\t}\n\treturn result;\n}", "target": 1}
{"code": "static int htc_setup_complete(struct htc_target *target)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_comp_msg *comp_msg;\n\tint ret = 0;\n\tunsigned long time_left;\n\tskb = alloc_skb(50 + sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"failed to allocate send buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\tcomp_msg = skb_put(skb, sizeof(struct htc_comp_msg));\n\tcomp_msg->msg_id = cpu_to_be16(HTC_MSG_SETUP_COMPLETE_ID);\n\ttarget->htc_flags |= HTC_OP_START_WAIT;\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"HTC start timeout\\n\");\n\t\tkfree_skb(skb);\n\t\treturn -ETIMEDOUT;\n\t}\n\treturn 0;\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}", "target": 0}
{"code": "static inline struct htx_blk *htx_add_trailer(struct htx *htx, const struct ist name,\n\t\t\t\t\t      const struct ist value)\n{\n\tstruct htx_blk *blk;\n\tblk = htx_add_blk(htx, HTX_BLK_TLR, name.len + value.len);\n\tif (!blk)\n\t\treturn NULL;\n\tblk->info += (value.len << 8) + name.len;\n\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\n\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\n\treturn blk;\n}", "target": 1}
{"code": "static int stream_thunk(void *buf, size_t size, void *data)\n{\n\tint error = 0;\n\tstruct push_packbuilder_payload *payload = data;\n\tif ((error = payload->stream->write(payload->stream, (const char *)buf, size)) < 0)\n\t\treturn error;\n\tif (payload->cb) {\n\t\tdouble current_time = git__timer();\n\t\tpayload->last_bytes += size;\n\t\tif ((current_time - payload->last_progress_report_time) >= MIN_PROGRESS_UPDATE_INTERVAL) {\n\t\t\tpayload->last_progress_report_time = current_time;\n\t\t\terror = payload->cb(payload->pb->nr_written, payload->pb->nr_objects, payload->last_bytes, payload->cb_payload);\n\t\t}\n\t}\n\treturn error;\n}", "target": 0}
{"code": "update_info_in_idle_device_unreffed (gpointer user_data,\n                                     GObject *where_the_object_was)\n{\n  UpdateInfoInIdleData *data = user_data;\n  g_source_remove (data->idle_id);\n}", "target": 0}
{"code": "stack_param_list_read(stack_param_list * plist, ref_stack_t * pstack,\n                      uint skip, const ref * ppolicies, bool require_all,\n                      gs_ref_memory_t *imem)\n{\n    iparam_list *const iplist = (iparam_list *) plist;\n    uint count = ref_stack_counttomark(pstack);\n    if (count == 0)\n        return_error(gs_error_unmatchedmark);\n    count -= skip + 1;\n    if (count & 1)\n        return_error(gs_error_rangecheck);\n    plist->u.r.read = stack_param_read;\n    plist->enumerate = stack_param_enumerate;\n    plist->pstack = pstack;\n    plist->skip = skip;\n    return ref_param_read_init(iplist, count >> 1, ppolicies, require_all, imem);\n}", "target": 0}
{"code": "static inline int cipso_v4_validate(const struct sk_buff *skb,\n\t\t\t\t    unsigned char **option)\n{\n\tunsigned char *opt = *option;\n\tunsigned char err_offset = 0;\n\tu8 opt_len = opt[1];\n\tu8 opt_iter;\n\tif (opt_len < 8) {\n\t\terr_offset = 1;\n\t\tgoto out;\n\t}\n\tif (get_unaligned_be32(&opt[2]) == 0) {\n\t\terr_offset = 2;\n\t\tgoto out;\n\t}\n\tfor (opt_iter = 6; opt_iter < opt_len;) {\n\t\tif (opt[opt_iter + 1] > (opt_len - opt_iter)) {\n\t\t\terr_offset = opt_iter + 1;\n\t\t\tgoto out;\n\t\t}\n\t\topt_iter += opt[opt_iter + 1];\n\t}\nout:\n\t*option = opt + err_offset;\n\treturn err_offset;\n}", "target": 1}
{"code": "static RList *symbols(RBinFile *bf) {\n\tr_return_val_if_fail (bf && bf->o && bf->o->bin_obj, NULL);\n\tRCoreSymCacheElement *element = bf->o->bin_obj;\n\tsize_t i;\n\tHtUU *hash = ht_uu_new0 ();\n\tif (!hash) {\n\t\treturn NULL;\n\t}\n\tRList *res = r_list_newf ((RListFree)r_bin_symbol_free);\n\tbool found = false;\n\tif (element->lined_symbols) {\n\t\tfor (i = 0; i < element->hdr->n_lined_symbols; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = (RCoreSymCacheElementSymbol *)&element->lined_symbols[i];\n\t\t\tif (!sym) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tht_uu_find (hash, sym->paddr, &found);\n\t\t\tif (found) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRBinSymbol *s = bin_symbol_from_symbol (element, sym);\n\t\t\tif (s) {\n\t\t\t\tr_list_append (res, s);\n\t\t\t\tht_uu_insert (hash, sym->paddr, 1);\n\t\t\t}\n\t\t}\n\t}\n\tif (element->symbols) {\n\t\tfor (i = 0; i < element->hdr->n_symbols; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = &element->symbols[i];\n\t\t\tht_uu_find (hash, sym->paddr, &found);\n\t\t\tif (found) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRBinSymbol *s = bin_symbol_from_symbol (element, sym);\n\t\t\tif (s) {\n\t\t\t\tr_list_append (res, s);\n\t\t\t}\n\t\t}\n\t}\n\tht_uu_free (hash);\n\treturn res;\n}", "target": 0}
{"code": "struct r_bin_pe_addr_t *PE_(check_mingw)(RBinPEObj *pe) {\n\tstruct r_bin_pe_addr_t* entry;\n\tbool sw = false;\n\tut8 b[1024];\n\tsize_t n = 0;\n\tif (!pe || !pe->b) {\n\t\treturn 0LL;\n\t}\n\tentry = PE_(r_bin_pe_get_entrypoint) (pe);\n\tZERO_FILL (b);\n\tif (r_buf_read_at (pe->b, entry->paddr, b, sizeof (b)) < 0) {\n\t\tpe_printf (\"Warning: Cannot read entry at 0x%08\"PFMT64x \"\\n\", entry->paddr);\n\t\tfree (entry);\n\t\treturn NULL;\n\t}\n\tif (b[0] == 0x55 && b[1] == 0x89 && b[3] == 0x83 && b[6] == 0xc7 && b[13] == 0xff && b[19] == 0xe8) {\n\t\tsw = follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 19);\n\t}\n\tif (b[0] == 0x83 && b[3] == 0xc7 && b[10] == 0xff && b[16] == 0xe8) {\n\t\tsw = follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 16);\n\t}\n\tif (b[0] == 0x83 && b[3] == 0xc7 && b[13] == 0xe8 && b[18] == 0x83 && b[21] == 0xe9) {\n\t\tsw = follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 21);\n\t}\n\tif (sw) {\n\t\tfor (n = 0; n < sizeof (b) - 12; n++) {\n\t\t\tif (b[n] == 0xa1 && b[n + 5] == 0x89 && b[n + 8] == 0xe8) {\n\t\t\t\tsw = follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, n + 8);\n\t\t\t\treturn entry;\n\t\t\t}\n\t\t}\n\t}\n\tfree (entry);\n\treturn NULL;\n}", "target": 1}
{"code": "void PrintWebViewHelper::PrintPreviewContext::set_error(\n    enum PrintPreviewErrorBuckets error) {\n  error_ = error;\n}", "target": 0}
{"code": "gimp_channel_new_from_buffer (GimpImage     *image,\n                              GeglBuffer    *buffer,\n                              const gchar   *name,\n                              const GimpRGB *color)\n{\n  GimpChannel *channel;\n  GeglBuffer  *dest;\n  g_return_val_if_fail (GIMP_IS_IMAGE (image), NULL);\n  g_return_val_if_fail (GEGL_IS_BUFFER (buffer), NULL);\n  channel = gimp_channel_new (image,\n                              gegl_buffer_get_width  (buffer),\n                              gegl_buffer_get_height (buffer),\n                              name, color);\n  dest = gimp_drawable_get_buffer (GIMP_DRAWABLE (channel));\n  gimp_gegl_buffer_copy (buffer, NULL, GEGL_ABYSS_NONE, dest, NULL);\n  return channel;\n}", "target": 0}
{"code": "  void writeErr(size_t, const AsyncSocketException& ex) noexcept override {\n    LOG(ERROR) << \"write error: \" << ex.what();\n    EXPECT_NE(\n        ex.getType(),\n        AsyncSocketException::AsyncSocketExceptionType::SSL_ERROR);\n  }", "target": 0}
{"code": "decode_string(CBORDecoderObject *self, uint8_t subtype)\n{\n    uint64_t length = 0;\n    bool indefinite = true;\n    PyObject *ret;\n    char length_hex[17];\n    if (decode_length(self, subtype, &length, &indefinite) == -1)\n        return NULL;\n    if (length > (uint64_t)PY_SSIZE_T_MAX - (uint64_t)PyBytesObject_SIZE) {\n        sprintf(length_hex, \"%llX\", length);\n        PyErr_Format(\n                _CBOR2_CBORDecodeValueError,\n                \"excessive string size 0x%s\", length_hex);\n        return NULL;\n    }\n    if (indefinite)\n        ret = decode_indefinite_strings(self);\n    else\n        ret = decode_definite_string(self, (Py_ssize_t)length);\n    set_shareable(self, ret);\n    return ret;\n}", "target": 1}
{"code": "void mpz_as_bytes(const mpz_t *z, bool big_endian, size_t len, byte *buf) {\n    byte *b = buf;\n    if (big_endian) {\n        b += len;\n    }\n    mpz_dig_t *zdig = z->dig;\n    int bits = 0;\n    mpz_dbl_dig_t d = 0;\n    mpz_dbl_dig_t carry = 1;\n    for (size_t zlen = z->len; zlen > 0; --zlen) {\n        bits += DIG_SIZE;\n        d = (d << DIG_SIZE) | *zdig++;\n        for (; bits >= 8; bits -= 8, d >>= 8) {\n            mpz_dig_t val = d;\n            if (z->neg) {\n                val = (~val & 0xff) + carry;\n                carry = val >> 8;\n            }\n            if (big_endian) {\n                *--b = val;\n                if (b == buf) {\n                    return;\n                }\n            } else {\n                *b++ = val;\n                if (b == buf + len) {\n                    return;\n                }\n            }\n        }\n    }\n    if (big_endian) {\n        len = b - buf;\n    } else {\n        len = buf + len - b;\n        buf = b;\n    }\n    memset(buf, z->neg ? 0xff : 0x00, len);\n}", "target": 1}
{"code": "static NTSTATUS smb_set_file_dosmode(connection_struct *conn,\n\t\t\t\t     struct files_struct *fsp,\n\t\t\t\t     uint32_t dosmode)\n{\n\tstruct files_struct *dos_fsp = NULL;\n\tuint32_t current_dosmode;\n\tint ret;\n\tif (!VALID_STAT(fsp->fsp_name->st)) {\n\t\treturn NT_STATUS_OBJECT_NAME_NOT_FOUND;\n\t}\n\tdos_fsp = fsp->base_fsp != NULL ? fsp->base_fsp : fsp;\n\tif (dosmode != 0) {\n\t\tif (S_ISDIR(fsp->fsp_name->st.st_ex_mode)) {\n\t\t\tdosmode |= FILE_ATTRIBUTE_DIRECTORY;\n\t\t} else {\n\t\t\tdosmode &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\t}\n\t}\n\tDBG_DEBUG(\"dosmode: 0x%\" PRIx32 \"\\n\", dosmode);\n\tif (dosmode == 0) {\n\t\treturn NT_STATUS_OK;\n\t}\n\tcurrent_dosmode = fdos_mode(dos_fsp);\n\tif (dosmode == current_dosmode) {\n\t\treturn NT_STATUS_OK;\n\t}\n\tDBG_DEBUG(\"file %s : setting dos mode 0x%\" PRIx32 \"\\n\",\n\t\t  fsp_str_dbg(dos_fsp), dosmode);\n\tret = file_set_dosmode(conn, dos_fsp->fsp_name, dosmode, NULL, false);\n\tif (ret != 0) {\n\t\tDBG_WARNING(\"file_set_dosmode of %s failed: %s\\n\",\n\t\t\t    fsp_str_dbg(dos_fsp), strerror(errno));\n\t\treturn map_nt_error_from_unix(errno);\n\t}\n\treturn NT_STATUS_OK;\n}", "target": 0}
{"code": "_forceinline void Unpack::CopyString(uint Length,uint Distance)\n{\n  size_t SrcPtr=UnpPtr-Distance;\n  if (SrcPtr<MaxWinSize-MAX_LZ_MATCH && UnpPtr<MaxWinSize-MAX_LZ_MATCH)\n  {\n    byte *Src=Window+SrcPtr;\n    byte *Dest=Window+UnpPtr;\n    UnpPtr+=Length;\n#ifdef FAST_MEMCPY\n    if (Distance<Length) \n#endif\n      while (Length>=8)\n      {\n        Dest[0]=Src[0];\n        Dest[1]=Src[1];\n        Dest[2]=Src[2];\n        Dest[3]=Src[3];\n        Dest[4]=Src[4];\n        Dest[5]=Src[5];\n        Dest[6]=Src[6];\n        Dest[7]=Src[7];\n        Src+=8;\n        Dest+=8;\n        Length-=8;\n      }\n#ifdef FAST_MEMCPY\n    else\n      while (Length>=8)\n      {\n        memcpy(Dest,Src,8); \n        Src+=8;\n        Dest+=8;\n        Length-=8;\n      }\n#endif\n    if (Length>0) { Dest[0]=Src[0];\n    if (Length>1) { Dest[1]=Src[1];\n    if (Length>2) { Dest[2]=Src[2];\n    if (Length>3) { Dest[3]=Src[3];\n    if (Length>4) { Dest[4]=Src[4];\n    if (Length>5) { Dest[5]=Src[5];\n    if (Length>6) { Dest[6]=Src[6]; } } } } } } } \n  }\n  else\n    while (Length-- > 0) \n    {\n      Window[UnpPtr]=Window[SrcPtr++ & MaxWinMask];\n      UnpPtr=(UnpPtr+1) & MaxWinMask;\n    }\n}", "target": 1}
{"code": "int usbredirparser_have_peer_caps(struct usbredirparser *parser_pub)\n{\n    struct usbredirparser_priv *parser =\n        (struct usbredirparser_priv *)parser_pub;\n    return parser->have_peer_caps;\n}", "target": 0}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  OpData* data = static_cast<OpData*>(node->user_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE(context, input->type == kTfLiteUInt8 ||\n                              input->type == kTfLiteInt8 ||\n                              input->type == kTfLiteInt16);\n  TF_LITE_ENSURE(\n      context, output->type == kTfLiteFloat32 || output->type == kTfLiteInt32);\n  if (output->type == kTfLiteInt32) {\n    const double effective_output_scale =\n        static_cast<double>(input->params.scale) /\n        static_cast<double>(output->params.scale);\n    QuantizeMultiplier(effective_output_scale, &data->output_multiplier,\n                       &data->output_shift);\n  }\n  data->quantization_params.zero_point = input->params.zero_point;\n  data->quantization_params.scale = static_cast<double>(input->params.scale);\n  data->output_zero_point = output->params.zero_point;\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static void inet_get_ping_group_range_net(struct net *net, kgid_t *low,\n\t\t\t\t\t  kgid_t *high)\n{\n\tkgid_t *data = net->ipv4.ping_group_range.range;\n\tunsigned int seq;\n\tdo {\n\t\tseq = read_seqbegin(&net->ipv4.ping_group_range.lock);\n\t\t*low = data[0];\n\t\t*high = data[1];\n\t} while (read_seqretry(&net->ipv4.ping_group_range.lock, seq));\n}", "target": 0}
{"code": "static int nft_flush_table(struct nft_ctx *ctx)\n{\n\tint err;\n\tstruct nft_chain *chain, *nc;\n\tstruct nft_set *set, *ns;\n\tlist_for_each_entry_safe(chain, nc, &ctx->table->chains, list) {\n\t\tctx->chain = chain;\n\t\terr = nft_delrule_by_chain(ctx);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\terr = nft_delchain(ctx);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\tlist_for_each_entry_safe(set, ns, &ctx->table->sets, list) {\n\t\tif (set->flags & NFT_SET_ANONYMOUS &&\n\t\t    !list_empty(&set->bindings))\n\t\t\tcontinue;\n\t\terr = nft_delset(ctx, set);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\terr = nft_deltable(ctx);\nout:\n\treturn err;\n}", "target": 1}
{"code": "static BYTE get_bmf_bpp(UINT32 bmf, BOOL* pValid)\n{\n\tif (pValid)\n\t\t*pValid = TRUE;\n\tswitch (bmf)\n\t{\n\t\tcase 1:\n\t\t\treturn 1;\n\t\tcase 3:\n\t\t\treturn 8;\n\t\tcase 4:\n\t\t\treturn 16;\n\t\tcase 5:\n\t\t\treturn 24;\n\t\tcase 6:\n\t\t\treturn 32;\n\t\tdefault:\n\t\t\tWLog_WARN(TAG, \"Invalid bmf %\" PRIu32, bmf);\n\t\t\tif (pValid)\n\t\t\t\t*pValid = FALSE;\n\t\t\treturn 0;\n\t}\n}", "target": 0}
{"code": "int db_update(char* name, char* value)\n{\n\tchar* sql;\n\tint r = 0;\n\tif (crypt_key) {\n\t\tvalue = note_encrypt(value,crypt_key);\n\t\tr = asprintf(&sql, \"UPDATE nodau set text='%s' , encrypted='true' WHERE name='%s'\", value, name);\n\t\tfree(value);\n\t\tif (r < 0)\n\t\t\treturn 1;\n\t}else{\n\t\tif (asprintf(&sql, \"UPDATE nodau set text='%s' , encrypted='false' WHERE name='%s'\", value, name) < 0)\n\t\t\treturn 1;\n\t}\n\tr = sqlite3_exec(db_data.db, sql, NULL, 0, &db_data.error_msg);\n\tfree(sql);\n\treturn r;\n}", "target": 1}
{"code": "path_poly(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *path = PG_GETARG_PATH_P(0);\n\tPOLYGON    *poly;\n\tint\t\t\tsize;\n\tint\t\t\ti;\n\tif (!path->closed)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"open path cannot be converted to polygon\")));\n\tsize = offsetof(POLYGON, p[0]) +sizeof(poly->p[0]) * path->npts;\n\tpoly = (POLYGON *) palloc(size);\n\tSET_VARSIZE(poly, size);\n\tpoly->npts = path->npts;\n\tfor (i = 0; i < path->npts; i++)\n\t{\n\t\tpoly->p[i].x = path->p[i].x;\n\t\tpoly->p[i].y = path->p[i].y;\n\t}\n\tmake_bound_box(poly);\n\tPG_RETURN_POLYGON_P(poly);\n}", "target": 0}
{"code": "TEST(AsyncSSLSocketTest, EarlyCloseNotify) {\n  WriteOnEofReadCallback readCallback(nullptr);\n  HandshakeCallback handshakeCallback(&readCallback);\n  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback);\n  EventBase eventBase;\n  CloseNotifyConnector cnc(&eventBase, server.getAddress());\n  eventBase.loop();\n}", "target": 0}
{"code": "MONGO_EXPORT int bson_append_element( bson *b, const char *name_or_null, const bson_iterator *elem ) {\n    bson_iterator next = *elem;\n    int size;\n    bson_iterator_next( &next );\n    size = next.cur - elem->cur;\n    if ( name_or_null == NULL ) {\n        if( bson_ensure_space( b, size ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append( b, elem->cur, size );\n    }\n    else {\n        int data_size = size - 2 - strlen( bson_iterator_key( elem ) );\n        bson_append_estart( b, elem->cur[0], name_or_null, data_size );\n        bson_append( b, bson_iterator_value( elem ), data_size );\n    }\n    return BSON_OK;\n}", "target": 1}
{"code": "static void nalm_dump(FILE * trace, char *data, u32 data_size)\n{\n\tGF_BitStream *bs;\n\tBool rle, large_size;\n\tu32 entry_count;\n\tif (!data) {\n\t\tfprintf(trace, \"<NALUMap rle=\\\"\\\" large_size=\\\"\\\">\\n\");\n\t\tfprintf(trace, \"<NALUMapEntry NALU_startNumber=\\\"\\\" groupID=\\\"\\\"/>\\n\");\n\t\tfprintf(trace, \"</NALUMap>\\n\");\n\t\treturn;\n\t}\n\tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\tgf_bs_read_int(bs, 6);\n\tlarge_size = gf_bs_read_int(bs, 1);\n\trle = gf_bs_read_int(bs, 1);\n\tentry_count = gf_bs_read_int(bs, large_size ? 16 : 8);\n\tfprintf(trace, \"<NALUMap rle=\\\"%d\\\" large_size=\\\"%d\\\">\\n\", rle, large_size);\n\twhile (entry_count) {\n\t\tu32 ID;\n\t\tfprintf(trace, \"<NALUMapEntry \");\n\t\tif (rle) {\n\t\t\tu32 start_num = gf_bs_read_int(bs, large_size ? 16 : 8);\n\t\t\tfprintf(trace, \"NALU_startNumber=\\\"%d\\\" \", start_num);\n\t\t}\n\t\tID = gf_bs_read_u16(bs);\n\t\tfprintf(trace, \"groupID=\\\"%d\\\"/>\\n\", ID);\n\t\tentry_count--;\n\t}\n\tgf_bs_del(bs);\n\tfprintf(trace, \"</NALUMap>\\n\");\n\treturn;\n}", "target": 1}
{"code": "    bool CFontFileType1::RemovePfbMarkers()\n    {\n        bool bSuccess = true;\n        int nBlockType = 0;\n        int nBlockLen  = 0;\n        int nChar = 0;\n        unsigned char *sBuffer = NULL;\n        int nBufLen = 0;\n        while ( nBlockType != PFB_DONE )\n        {\n            while ( 0 == nBlockLen )\n            {\n                nChar = ReadU8( &bSuccess );\n                if ( !bSuccess )\n                    return false;\n                nBlockType = ReadU8( &bSuccess );\n                if ( !bSuccess || PFB_MARKER != nChar || ( PFB_ASCII != nBlockType && PFB_BINARY != nBlockType && PFB_DONE != nBlockType ) )\n                    return false;\n                if ( PFB_DONE == nBlockType )\n                    break;\n                nBlockLen = ReadU32LE( &bSuccess );\n                if ( !bSuccess )\n                    return false;\n            }\n            if ( nBlockLen > 0 )\n            {\n                if ( !sBuffer )\n                {\n                    sBuffer = (unsigned char*)MemUtilsMalloc( nBlockLen );\n                    if ( !sBuffer )\n                        return false;\n                }\n                else\n                    sBuffer = (unsigned char*)MemUtilsRealloc( sBuffer, nBufLen + nBlockLen );\n                Read( sBuffer + nBufLen, nBlockLen );\n                nBufLen += nBlockLen;\n            }\n            nBlockLen = 0;\n        }\n        if ( m_bFreeFileData )\n            MemUtilsFree( m_sFile );\n        m_bFreeFileData = true;\n        m_sFile         = (unsigned char*)sBuffer;\n        m_sFileData     = m_sFile;\n        m_nLen          = nBufLen;\n        m_nPos          = 0;\n        return true;\n    }", "target": 1}
{"code": "int snmp_helper(void *context, size_t hdrlen, unsigned char tag,\n\t\tconst void *data, size_t datalen)\n{\n\tstruct snmp_ctx *ctx = (struct snmp_ctx *)context;\n\t__be32 *pdata = (__be32 *)data;\n\tif (*pdata == ctx->from) {\n\t\tpr_debug(\"%s: %pI4 to %pI4\\n\", __func__,\n\t\t\t (void *)&ctx->from, (void *)&ctx->to);\n\t\tif (*ctx->check)\n\t\t\tfast_csum(ctx, (unsigned char *)data - ctx->begin);\n\t\t*pdata = ctx->to;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "int app_initialize(const char *const argv[])\n{\n    const char *argv_out[OGS_ARG_MAX];\n    bool user_config = false;\n    int i = 0;\n    for (i = 0; argv[i]; i++) {\n        if (strcmp(\"-c\", argv[i]) == 0) {\n            user_config = true; \n        }\n        argv_out[i] = argv[i];\n    }\n    argv_out[i] = NULL;\n    if (!user_config) {\n        argv_out[i++] = \"-c\";\n        argv_out[i++] = DEFAULT_CONFIG_FILENAME;\n        argv_out[i] = NULL;\n    }\n    if (ogs_app()->parameter.no_hss == 0)\n        hss_thread = test_child_create(\"hss\", argv_out);\n    if (ogs_app()->parameter.no_pcrf == 0)\n        pcrf_thread = test_child_create(\"pcrf\", argv_out);\n    if (ogs_app()->parameter.no_upf == 0)\n        upf_thread = test_child_create(\"upf\", argv_out);\n    if (ogs_app()->parameter.no_sgwu == 0)\n        sgwu_thread = test_child_create(\"sgwu\", argv_out);\n    if (ogs_app()->parameter.no_smf == 0)\n        smf_thread = test_child_create(\"smf\", argv_out);\n    if (ogs_app()->parameter.no_sgwc == 0)\n        sgwc_thread = test_child_create(\"sgwc\", argv_out);\n    if (ogs_app()->parameter.no_mme == 0)\n        mme_thread = test_child_create(\"mme\", argv_out);\n    ogs_msleep(5000);\n    return OGS_OK;;\n}", "target": 1}
{"code": "BOOL nego_read_request(rdpNego* nego, wStream* s)\n{\n\tBYTE li;\n\tBYTE type;\n\tUINT16 length;\n\tif (!tpkt_read_header(s, &length))\n\t\treturn FALSE;\n\tif (!tpdu_read_connection_request(s, &li, length))\n\t\treturn FALSE;\n\tif (li != Stream_GetRemainingLength(s) + 6)\n\t{\n\t\tWLog_ERR(TAG, \"Incorrect TPDU length indicator.\");\n\t\treturn FALSE;\n\t}\n\tif (!nego_read_request_token_or_cookie(nego, s))\n\t{\n\t\tWLog_ERR(TAG, \"Failed to parse routing token or cookie.\");\n\t\treturn FALSE;\n\t}\n\tif (Stream_GetRemainingLength(s) >= 8)\n\t{\n\t\tStream_Read_UINT8(s, type); \n\t\tif (type != TYPE_RDP_NEG_REQ)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Incorrect negotiation request type %\" PRIu8 \"\", type);\n\t\t\treturn FALSE;\n\t\t}\n\t\tnego_process_negotiation_request(nego, s);\n\t}\n\treturn tpkt_ensure_stream_consumed(s, length);\n}", "target": 1}
{"code": "static void on_underlying_io_bytes_received(void *context, const unsigned char *buffer, size_t size)\n{\n    if (context != NULL)\n    {\n        TLS_IO_INSTANCE *tls_io_instance = (TLS_IO_INSTANCE *)context;\n        unsigned char *new_socket_io_read_bytes = (unsigned char *)realloc(tls_io_instance->socket_io_read_bytes, tls_io_instance->socket_io_read_byte_count + size);\n        if (new_socket_io_read_bytes == NULL)\n        {\n            tls_io_instance->tlsio_state = TLSIO_STATE_ERROR;\n            indicate_error(tls_io_instance);\n        }\n        else\n        {\n            tls_io_instance->socket_io_read_bytes = new_socket_io_read_bytes;\n            (void)memcpy(tls_io_instance->socket_io_read_bytes + tls_io_instance->socket_io_read_byte_count, buffer, size);\n            tls_io_instance->socket_io_read_byte_count += size;\n        }\n    }\n    else\n    {\n        LogError(\"NULL value passed in context\");\n    }\n}", "target": 1}
{"code": "Array& ObjectData::reserveProperties(int numDynamic ) {\n  if (getAttribute(HasDynPropArr)) {\n    return dynPropArray();\n  }\n  auto const allocsz = MixedArray::computeAllocBytesFromMaxElms(numDynamic);\n  if (UNLIKELY(allocsz > kMaxSmallSize && tl_heap->preAllocOOM(allocsz))) {\n    check_non_safepoint_surprise();\n  }\n  return setDynPropArray(\n      Array::attach(MixedArray::MakeReserveMixed(numDynamic))\n  );\n}", "target": 0}
{"code": "static inline void check_buffer(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t struct rb_event_info *info,\n\t\t\t unsigned long tail)\n{\n}", "target": 0}
{"code": "static void __xen_evtchn_do_upcall(void)\n{\n\tstruct vcpu_info *vcpu_info = __this_cpu_read(xen_vcpu);\n\tint cpu = smp_processor_id();\n\tstruct evtchn_loop_ctrl ctrl = { 0 };\n\tread_lock(&evtchn_rwlock);\n\tdo {\n\t\tvcpu_info->evtchn_upcall_pending = 0;\n\t\txen_evtchn_handle_events(cpu, &ctrl);\n\t\tBUG_ON(!irqs_disabled());\n\t\tvirt_rmb(); \n\t} while (vcpu_info->evtchn_upcall_pending);\n\tread_unlock(&evtchn_rwlock);\n\t__this_cpu_inc(irq_epoch);\n}", "target": 0}
{"code": "void ciEnv::report_failure(const char* reason) {\n  EventCompilationFailure event;\n  if (event.should_commit()) {\n    CompilerEvent::CompilationFailureEvent::post(event, compile_id(), reason);\n  }\n}", "target": 0}
{"code": "int read_header_tga(gdIOCtx *ctx, oTga *tga)\n{\n\tunsigned char header[18];\n\tif (gdGetBuf(header, sizeof(header), ctx) < 18) {\n\t\tgd_error(\"fail to read header\");\n\t\treturn -1;\n\t}\n\ttga->identsize = header[0];\n\ttga->colormaptype = header[1];\n\ttga->imagetype = header[2];\n\ttga->colormapstart = header[3] + (header[4] << 8);\n\ttga->colormaplength = header[5] + (header[6] << 8);\n\ttga->colormapbits = header[7];\n\ttga->xstart = header[8] + (header[9] << 8);\n\ttga->ystart = header[10] + (header[11] << 8);\n\ttga->width = header[12] + (header[13] << 8);\n\ttga->height = header[14] + (header[15] << 8);\n\ttga->bits = header[16];\n\ttga->alphabits = header[17] & 0x0f;\n\ttga->fliph = (header[17] & 0x10) ? 1 : 0;\n\ttga->flipv = (header[17] & 0x20) ? 0 : 1;\n#if DEBUG\n\tprintf(\"format bps: %i\\n\", tga->bits);\n\tprintf(\"flip h/v: %i / %i\\n\", tga->fliph, tga->flipv);\n\tprintf(\"alpha: %i\\n\", tga->alphabits);\n\tprintf(\"wxh: %i %i\\n\", tga->width, tga->height);\n#endif\n\tswitch(tga->bits) {\n\tcase 8:\n\tcase 16:\n\tcase 24:\n\tcase 32:\n\t\tbreak;\n\tdefault:\n\t\tgd_error(\"bps %i not supported\", tga->bits);\n\t\treturn -1;\n\t\tbreak;\n\t}\n\ttga->ident = NULL;\n\tif (tga->identsize > 0) {\n\t\ttga->ident = (char *) gdMalloc(tga->identsize * sizeof(char));\n\t\tif(tga->ident == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\tgdGetBuf(tga->ident, tga->identsize, ctx);\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "  static Address js_entry_sp(ThreadLocalTop* thread) {\n    return thread->js_entry_sp_;\n  }", "target": 0}
{"code": "void common_timer_get(struct k_itimer *timr, struct itimerspec64 *cur_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tktime_t now, remaining, iv;\n\tstruct timespec64 ts64;\n\tbool sig_none;\n\tsig_none = (timr->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE;\n\tiv = timr->it_interval;\n\tif (iv) {\n\t\tcur_setting->it_interval = ktime_to_timespec64(iv);\n\t} else if (!timr->it_active) {\n\t\tif (!sig_none)\n\t\t\treturn;\n\t}\n\tkc->clock_get(timr->it_clock, &ts64);\n\tnow = timespec64_to_ktime(ts64);\n\tif (iv && (timr->it_requeue_pending & REQUEUE_PENDING || sig_none))\n\t\ttimr->it_overrun += kc->timer_forward(timr, now);\n\tremaining = kc->timer_remaining(timr, now);\n\tif (remaining <= 0) {\n\t\tif (!sig_none)\n\t\t\tcur_setting->it_value.tv_nsec = 1;\n\t} else {\n\t\tcur_setting->it_value = ktime_to_timespec64(remaining);\n\t}\n}", "target": 1}
{"code": "void skip(Protocol_& prot, TType arg_type) {\n  switch (arg_type) {\n    case TType::T_BOOL: {\n      bool boolv;\n      prot.readBool(boolv);\n      return;\n    }\n    case TType::T_BYTE: {\n      int8_t bytev;\n      prot.readByte(bytev);\n      return;\n    }\n    case TType::T_I16: {\n      int16_t i16;\n      prot.readI16(i16);\n      return;\n    }\n    case TType::T_I32: {\n      int32_t i32;\n      prot.readI32(i32);\n      return;\n    }\n    case TType::T_I64: {\n      int64_t i64;\n      prot.readI64(i64);\n      return;\n    }\n    case TType::T_DOUBLE: {\n      double dub;\n      prot.readDouble(dub);\n      return;\n    }\n    case TType::T_FLOAT: {\n      float flt;\n      prot.readFloat(flt);\n      return;\n    }\n    case TType::T_STRING: {\n      std::string str;\n      prot.readBinary(str);\n      return;\n    }\n    case TType::T_STRUCT: {\n      std::string name;\n      int16_t fid;\n      TType ftype;\n      prot.readStructBegin(name);\n      while (true) {\n        prot.readFieldBegin(name, ftype, fid);\n        if (ftype == TType::T_STOP) {\n          break;\n        }\n        apache::thrift::skip(prot, ftype);\n        prot.readFieldEnd();\n      }\n      prot.readStructEnd();\n      return;\n    }\n    case TType::T_MAP: {\n      TType keyType;\n      TType valType;\n      uint32_t i, size;\n      prot.readMapBegin(keyType, valType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, keyType);\n        apache::thrift::skip(prot, valType);\n      }\n      prot.readMapEnd();\n      return;\n    }\n    case TType::T_SET: {\n      TType elemType;\n      uint32_t i, size;\n      prot.readSetBegin(elemType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, elemType);\n      }\n      prot.readSetEnd();\n      return;\n    }\n    case TType::T_LIST: {\n      TType elemType;\n      uint32_t i, size;\n      prot.readListBegin(elemType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, elemType);\n      }\n      prot.readListEnd();\n      return;\n    }\n    default:\n      return;\n  }\n}", "target": 1}
{"code": "processInternalEntity(XML_Parser parser, ENTITY *entity, XML_Bool betweenDecl) {\n  const char *textStart, *textEnd;\n  const char *next;\n  enum XML_Error result;\n  OPEN_INTERNAL_ENTITY *openEntity;\n  if (parser->m_freeInternalEntities) {\n    openEntity = parser->m_freeInternalEntities;\n    parser->m_freeInternalEntities = openEntity->next;\n  } else {\n    openEntity\n        = (OPEN_INTERNAL_ENTITY *)MALLOC(parser, sizeof(OPEN_INTERNAL_ENTITY));\n    if (! openEntity)\n      return XML_ERROR_NO_MEMORY;\n  }\n  entity->open = XML_TRUE;\n  entity->processed = 0;\n  openEntity->next = parser->m_openInternalEntities;\n  parser->m_openInternalEntities = openEntity;\n  openEntity->entity = entity;\n  openEntity->startTagLevel = parser->m_tagLevel;\n  openEntity->betweenDecl = betweenDecl;\n  openEntity->internalEventPtr = NULL;\n  openEntity->internalEventEndPtr = NULL;\n  textStart = (char *)entity->textPtr;\n  textEnd = (char *)(entity->textPtr + entity->textLen);\n  next = textStart;\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok\n        = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n                      tok, next, &next, XML_FALSE);\n  } else\n#endif \n    result = doContent(parser, parser->m_tagLevel, parser->m_internalEncoding,\n                       textStart, textEnd, &next, XML_FALSE);\n  if (result == XML_ERROR_NONE) {\n    if (textEnd != next && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n      entity->processed = (int)(next - textStart);\n      parser->m_processor = internalEntityProcessor;\n    } else {\n      entity->open = XML_FALSE;\n      parser->m_openInternalEntities = openEntity->next;\n      openEntity->next = parser->m_freeInternalEntities;\n      parser->m_freeInternalEntities = openEntity;\n    }\n  }\n  return result;\n}", "target": 1}
{"code": "int LuaSettings::l_write(lua_State* L)\n{\n\tNO_MAP_LOCK_REQUIRED;\n\tLuaSettings* o = checkobject(L, 1);\n\tif (!o->m_write_allowed) {\n\t\tthrow LuaError(\"Settings: writing \" + o->m_filename +\n\t\t\t\t\" not allowed with mod security on.\");\n\t}\n\tbool success = o->m_settings->updateConfigFile(o->m_filename.c_str());\n\tlua_pushboolean(L, success);\n\treturn 1;\n}", "target": 0}
{"code": "static request_rec *my_ap_create_request(conn_rec *c)\n{\n    apr_pool_t *p;\n    request_rec *r;\n    apr_pool_create(&p, c->pool);\n    apr_pool_tag(p, \"request\");\n    r = apr_pcalloc(p, sizeof(request_rec));\n    AP_READ_REQUEST_ENTRY((intptr_t)r, (uintptr_t)c);\n    r->pool            = p;\n    r->connection      = c;\n    r->server          = c->base_server;\n    r->user            = NULL;\n    r->ap_auth_type    = NULL;\n    r->allowed_methods = ap_make_method_list(p, 2);\n    r->headers_in      = apr_table_make(r->pool, 5);\n    r->trailers_in     = apr_table_make(r->pool, 5);\n    r->subprocess_env  = apr_table_make(r->pool, 25);\n    r->headers_out     = apr_table_make(r->pool, 12);\n    r->err_headers_out = apr_table_make(r->pool, 5);\n    r->trailers_out    = apr_table_make(r->pool, 5);\n    r->notes           = apr_table_make(r->pool, 5);\n    r->request_config  = ap_create_request_config(r->pool);\n    r->proto_output_filters = c->output_filters;\n    r->output_filters  = r->proto_output_filters;\n    r->proto_input_filters = c->input_filters;\n    r->input_filters   = r->proto_input_filters;\n    ap_run_create_request(r);\n    r->per_dir_config  = r->server->lookup_defaults;\n    r->sent_bodyct     = 0;                      \n    r->read_length     = 0;\n    r->read_body       = REQUEST_NO_BODY;\n    r->status          = HTTP_OK;  \n    r->header_only     = 0;\n    r->the_request     = NULL;\n    r->used_path_info = AP_REQ_DEFAULT_PATH_INFO;\n    r->useragent_addr = c->client_addr;\n    r->useragent_ip = c->client_ip;\n    return r;\n}", "target": 1}
{"code": "local block_state deflate_huff(s, flush)\n    deflate_state *s;\n    int flush;\n{\n    int bflush;             \n    for (;;) {\n        if (s->lookahead == 0) {\n            fill_window(s);\n            if (s->lookahead == 0) {\n                if (flush == Z_NO_FLUSH)\n                    return need_more;\n                break;      \n            }\n        }\n        s->match_length = 0;\n        Tracevv((stderr,\"%c\", s->window[s->strstart]));\n        _tr_tally_lit (s, s->window[s->strstart], bflush);\n        s->lookahead--;\n        s->strstart++;\n        if (bflush) FLUSH_BLOCK(s, 0);\n    }\n    s->insert = 0;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->last_lit)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}", "target": 1}
{"code": "KeyInfo *sqlite3KeyInfoAlloc(sqlite3 *db, int N, int X){\n  int nExtra = (N+X)*(sizeof(CollSeq*)+1) - sizeof(CollSeq*);\n  KeyInfo *p = sqlite3DbMallocRawNN(db, sizeof(KeyInfo) + nExtra);\n  if( p ){\n    p->aSortOrder = (u8*)&p->aColl[N+X];\n    p->nKeyField = (u16)N;\n    p->nAllField = (u16)(N+X);\n    p->enc = ENC(db);\n    p->db = db;\n    p->nRef = 1;\n    memset(&p[1], 0, nExtra);\n  }else{\n    sqlite3OomFault(db);\n  }\n  return p;\n}", "target": 0}
{"code": "static bool translation_pre_enabled(struct intel_iommu *iommu)\n{\n\treturn (iommu->flags & VTD_FLAG_TRANS_PRE_ENABLED);\n}", "target": 0}
{"code": "ikev1_attrmap_print(netdissect_options *ndo,\n\t\t    const u_char *p, const u_char *ep,\n\t\t    const struct attrmap *map, size_t nmap)\n{\n\tint totlen;\n\tuint32_t t, v;\n\tif (p[0] & 0x80)\n\t\ttotlen = 4;\n\telse\n\t\ttotlen = 4 + EXTRACT_16BITS(&p[2]);\n\tif (ep < p + totlen) {\n\t\tND_PRINT((ndo,\"[|attr]\"));\n\t\treturn ep + 1;\n\t}\n\tND_PRINT((ndo,\"(\"));\n\tt = EXTRACT_16BITS(&p[0]) & 0x7fff;\n\tif (map && t < nmap && map[t].type)\n\t\tND_PRINT((ndo,\"type=%s \", map[t].type));\n\telse\n\t\tND_PRINT((ndo,\"type=#%d \", t));\n\tif (p[0] & 0x80) {\n\t\tND_PRINT((ndo,\"value=\"));\n\t\tv = EXTRACT_16BITS(&p[2]);\n\t\tif (map && t < nmap && v < map[t].nvalue && map[t].value[v])\n\t\t\tND_PRINT((ndo,\"%s\", map[t].value[v]));\n\t\telse\n\t\t\trawprint(ndo, (const uint8_t *)&p[2], 2);\n\t} else {\n\t\tND_PRINT((ndo,\"len=%d value=\", EXTRACT_16BITS(&p[2])));\n\t\trawprint(ndo, (const uint8_t *)&p[4], EXTRACT_16BITS(&p[2]));\n\t}\n\tND_PRINT((ndo,\")\"));\n\treturn p + totlen;\n}", "target": 1}
{"code": "static int ecryptfs_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct file *lower_file = ecryptfs_file_to_lower(file);\n\tif (!lower_file->f_op->mmap)\n\t\treturn -ENODEV;\n\treturn generic_file_mmap(file, vma);\n}", "target": 0}
{"code": "wait_limit_netblock_findcreate(struct infra_cache* infra, char* str,\n\tint cookie)\n{\n\trbtree_type* tree;\n\tstruct sockaddr_storage addr;\n\tint net;\n\tsocklen_t addrlen;\n\tstruct wait_limit_netblock_info* d;\n\tif(!netblockstrtoaddr(str, 0, &addr, &addrlen, &net)) {\n\t\tlog_err(\"cannot parse wait limit netblock '%s'\", str);\n\t\treturn 0;\n\t}\n\tif(cookie)\n\t\ttree = &infra->wait_limits_cookie_netblock;\n\telse\n\t\ttree = &infra->wait_limits_netblock;\n\td = (struct wait_limit_netblock_info*)addr_tree_find(tree, &addr,\n\t\taddrlen, net);\n\tif(d)\n\t\treturn d;\n\td = (struct wait_limit_netblock_info*)calloc(1, sizeof(*d));\n\tif(!d)\n\t\treturn NULL;\n\td->limit = -1;\n\tif(!addr_tree_insert(tree, &d->node, &addr, addrlen, net)) {\n\t\tlog_err(\"duplicate element in domainlimit tree\");\n\t\tfree(d);\n\t\treturn NULL;\n\t}\n\treturn d;\n}", "target": 0}
{"code": "  void ComputeAsyncImpl(OpKernelContext* c, CollectiveExecutor* col_exec,\n                        DoneCallback done) override {\n    auto output_shape = c->input(0).shape();\n    OP_REQUIRES_ASYNC(c, output_shape.dims() > 0,\n                      errors::InvalidArgument(\"input should have rank > 0, \",\n                                              \"recieved \", output_shape.dims()),\n                      done);\n    output_shape.set_dim(\n        0, output_shape.dim_size(0) * col_params_->group.group_size);\n    col_params_->instance.shape = output_shape;\n    if (c->mutable_output(0) == nullptr) {\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK_ASYNC(\n          c, c->allocate_output(0, col_params_->instance.shape, &output), done);\n    }\n    if (!CanProceedWithCompute(c, col_exec, done)) return;\n    auto actual_done = [c, col_params = col_params_, done](const Status& s) {\n      VLOG(1) << \"CollectiveGatherOpKernel ExecuteAsync done for collective \"\n              << c->op_kernel().name() << \" device \" << c->device()->name()\n              << \" group \" << col_params->group.group_key << \" instance \"\n              << col_params->instance.instance_key << \" status \" << s;\n      col_params->Unref();\n      OP_REQUIRES_OK_ASYNC(c, s, done);\n      done();\n    };\n    VLOG(1) << \"CollectiveGatherOpKernel ExecuteAsync start for collective \"\n            << col_params_->name << \" device \" << c->device()->name()\n            << \" group \" << col_params_->group.group_key << \" instance \"\n            << col_params_->instance.instance_key;\n    col_params_->Ref();\n    col_exec->ExecuteAsync(c, col_params_, GetCollectiveKey(c), actual_done);\n  }", "target": 0}
{"code": "snmp_ber_decode_unsigned_integer(unsigned char *buf, uint32_t *buff_len, uint8_t expected_type, uint32_t *num)\n{\n  uint8_t i, len, type;\n  buf = snmp_ber_decode_type(buf, buff_len, &type);\n  if(buf == NULL || type != expected_type) {\n    return NULL;\n  }\n  buf = snmp_ber_decode_length(buf, buff_len, &len);\n  if(buf == NULL || len > 4) {\n    return NULL;\n  }\n  if(*buff_len < len) {\n    return NULL;\n  }\n  *num = (uint32_t)(*buf++ & 0xFF);\n  (*buff_len)--;\n  for(i = 1; i < len; ++i) {\n    *num <<= 8;\n    *num |= (uint8_t)(*buf++ & 0xFF);\n    (*buff_len)--;\n  }\n  return buf;\n}", "target": 1}
{"code": "struct key *key_get_instantiation_authkey(key_serial_t target_id)\n{\n\tchar description[16];\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= &key_type_request_key_auth,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= user_match,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t};\n\tstruct key *authkey;\n\tkey_ref_t authkey_ref;\n\tsprintf(description, \"%x\", target_id);\n\tauthkey_ref = search_process_keyrings(&ctx);\n\tif (IS_ERR(authkey_ref)) {\n\t\tauthkey = ERR_CAST(authkey_ref);\n\t\tif (authkey == ERR_PTR(-EAGAIN))\n\t\t\tauthkey = ERR_PTR(-ENOKEY);\n\t\tgoto error;\n\t}\n\tauthkey = key_ref_to_ptr(authkey_ref);\n\tif (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {\n\t\tkey_put(authkey);\n\t\tauthkey = ERR_PTR(-EKEYREVOKED);\n\t}\nerror:\n\treturn authkey;\n}", "target": 1}
{"code": "TEST(TensorSliceReaderTest, InvalidTensorSlice) {\n  const string fname =\n      io::JoinPath(testing::TmpDir(), \"invalid_slice_checkpoint\");\n  TensorSliceWriter writer(fname, CreateTableTensorSliceBuilder);\n  const int32 data[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n  TF_CHECK_OK(writer.Add(\"test\", TensorShape({4, 5}),\n                         TensorSlice::ParseOrDie(\"0,2:-\"), data));\n  TF_CHECK_OK(writer.Finish());\n  MutateSavedTensorSlices(fname, [](SavedTensorSlices sts) {\n    if (sts.has_meta()) {\n      for (auto& tensor : *sts.mutable_meta()->mutable_tensor()) {\n        tensor.mutable_slice(0)->mutable_extent(0)->set_length(-10);\n      }\n    }\n    return sts.SerializeAsString();\n  });\n  TensorSliceReader reader(fname, OpenTableTensorSliceReader);\n  EXPECT_FALSE(reader.status().ok());\n}", "target": 0}
{"code": "struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,\n\t\t\t\t\t\tint port)\n{\n\tunsigned long flags;\n\tstruct snd_seq_client_port *new_port, *p;\n\tint num = -1;\n\tif (snd_BUG_ON(!client))\n\t\treturn NULL;\n\tif (client->num_ports >= SNDRV_SEQ_MAX_PORTS) {\n\t\tpr_warn(\"ALSA: seq: too many ports for client %d\\n\", client->number);\n\t\treturn NULL;\n\t}\n\tnew_port = kzalloc(sizeof(*new_port), GFP_KERNEL);\n\tif (!new_port)\n\t\treturn NULL;\t\n\tnew_port->addr.client = client->number;\n\tnew_port->addr.port = -1;\n\tnew_port->owner = THIS_MODULE;\n\tsprintf(new_port->name, \"port-%d\", num);\n\tsnd_use_lock_init(&new_port->use_lock);\n\tport_subs_info_init(&new_port->c_src);\n\tport_subs_info_init(&new_port->c_dest);\n\tnum = port >= 0 ? port : 0;\n\tmutex_lock(&client->ports_mutex);\n\twrite_lock_irqsave(&client->ports_lock, flags);\n\tlist_for_each_entry(p, &client->ports_list_head, list) {\n\t\tif (p->addr.port > num)\n\t\t\tbreak;\n\t\tif (port < 0) \n\t\t\tnum = p->addr.port + 1;\n\t}\n\tlist_add_tail(&new_port->list, &p->list);\n\tclient->num_ports++;\n\tnew_port->addr.port = num;\t\n\twrite_unlock_irqrestore(&client->ports_lock, flags);\n\tmutex_unlock(&client->ports_mutex);\n\tsprintf(new_port->name, \"port-%d\", num);\n\treturn new_port;\n}", "target": 1}
{"code": "int app_initialize(const char *const argv[])\n{\n    const char *argv_out[OGS_ARG_MAX];\n    bool user_config = false;\n    int i = 0;\n    for (i = 0; argv[i]; i++) {\n        if (strcmp(\"-c\", argv[i]) == 0) {\n            user_config = true; \n        }\n        argv_out[i] = argv[i];\n    }\n    argv_out[i] = NULL;\n    if (!user_config) {\n        argv_out[i++] = \"-c\";\n        argv_out[i++] = DEFAULT_CONFIG_FILENAME;\n        argv_out[i] = NULL;\n    }\n    if (ogs_app()->parameter.no_nrf == 0)\n        nrf_thread = test_child_create(\"nrf\", argv_out);\n    if (ogs_app()->parameter.no_scp == 0)\n        scp_thread = test_child_create(\"scp\", argv_out);\n    if (ogs_app()->parameter.no_upf == 0)\n        upf_thread = test_child_create(\"upf\", argv_out);\n    if (ogs_app()->parameter.no_smf == 0)\n        smf_thread = test_child_create(\"smf\", argv_out);\n    if (ogs_app()->parameter.no_amf == 0)\n        amf_thread = test_child_create(\"amf\", argv_out);\n    if (ogs_app()->parameter.no_ausf == 0)\n        ausf_thread = test_child_create(\"ausf\", argv_out);\n    if (ogs_app()->parameter.no_udm == 0)\n        udm_thread = test_child_create(\"udm\", argv_out);\n    if (ogs_app()->parameter.no_pcf == 0)\n        pcf_thread = test_child_create(\"pcf\", argv_out);\n    if (ogs_app()->parameter.no_nssf == 0)\n        nssf_thread = test_child_create(\"nssf\", argv_out);\n    if (ogs_app()->parameter.no_bsf == 0)\n        bsf_thread = test_child_create(\"bsf\", argv_out);\n    if (ogs_app()->parameter.no_udr == 0)\n        udr_thread = test_child_create(\"udr\", argv_out);\n    ogs_msleep(300);\n    return OGS_OK;;\n}", "target": 1}
{"code": "static int dbConnect(char *host, char *user, char *passwd)\n{\n  DBUG_ENTER(\"dbConnect\");\n  if (verbose)\n  {\n    fprintf(stderr, \"# Connecting to %s...\\n\", host ? host : \"localhost\");\n  }\n  mysql_init(&mysql_connection);\n  if (opt_compress)\n    mysql_options(&mysql_connection, MYSQL_OPT_COMPRESS, NullS);\n#ifdef HAVE_OPENSSL\n  if (opt_use_ssl)\n  {\n    mysql_ssl_set(&mysql_connection, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n\t\t  opt_ssl_capath, opt_ssl_cipher);\n    mysql_options(&mysql_connection, MYSQL_OPT_SSL_CRL, opt_ssl_crl);\n    mysql_options(&mysql_connection, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);\n  }\n#endif\n  if (opt_protocol)\n    mysql_options(&mysql_connection,MYSQL_OPT_PROTOCOL,(char*)&opt_protocol);\n  if (opt_bind_addr)\n    mysql_options(&mysql_connection, MYSQL_OPT_BIND, opt_bind_addr);\n#if defined (_WIN32) && !defined (EMBEDDED_LIBRARY)\n  if (shared_memory_base_name)\n    mysql_options(&mysql_connection,MYSQL_SHARED_MEMORY_BASE_NAME,shared_memory_base_name);\n#endif\n  if (opt_plugin_dir && *opt_plugin_dir)\n    mysql_options(&mysql_connection, MYSQL_PLUGIN_DIR, opt_plugin_dir);\n  if (opt_default_auth && *opt_default_auth)\n    mysql_options(&mysql_connection, MYSQL_DEFAULT_AUTH, opt_default_auth);\n  mysql_options(&mysql_connection, MYSQL_SET_CHARSET_NAME, default_charset);\n  mysql_options(&mysql_connection, MYSQL_OPT_CONNECT_ATTR_RESET, 0);\n  mysql_options4(&mysql_connection, MYSQL_OPT_CONNECT_ATTR_ADD,\n                 \"program_name\", \"mysqlcheck\");\n  if (!(sock = mysql_real_connect(&mysql_connection, host, user, passwd,\n         NULL, opt_mysql_port, opt_mysql_unix_port, 0)))\n  {\n    DBerror(&mysql_connection, \"when trying to connect\");\n    DBUG_RETURN(1);\n  }\n  mysql_connection.reconnect= 1;\n  DBUG_RETURN(0);\n} ", "target": 1}
{"code": "ZEND_API int zend_register_class_alias_ex(const char *name, int name_len, zend_class_entry *ce TSRMLS_DC) \n{\n\tchar *lcname = zend_str_tolower_dup(name, name_len);\n\tint ret;\n\tif (lcname[0] == '\\\\') {\n\t\tret = zend_hash_add(CG(class_table), lcname+1, name_len, &ce, sizeof(zend_class_entry *), NULL);\n\t} else {\n\t\tret = zend_hash_add(CG(class_table), lcname, name_len+1, &ce, sizeof(zend_class_entry *), NULL);\n\t}\n\tefree(lcname);\n\tif (ret == SUCCESS) {\n\t\tce->refcount++;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "Status CreateTempFile(Env* env, float value, uint64 size, string* filename) {\n  const string dir = testing::TmpDir();\n  *filename = io::JoinPath(dir, strings::StrCat(\"file_\", value));\n  std::unique_ptr<WritableFile> file;\n  TF_RETURN_IF_ERROR(env->NewWritableFile(*filename, &file));\n  for (uint64 i = 0; i < size; ++i) {\n    StringPiece sp(static_cast<char*>(static_cast<void*>(&value)),\n                   sizeof(value));\n    TF_RETURN_IF_ERROR(file->Append(sp));\n  }\n  TF_RETURN_IF_ERROR(file->Close());\n  return Status::OK();\n}", "target": 1}
{"code": "static int r_cmd_java_call(void *user, const char *input) {\n\tRCore *core = (RCore *) user;\n\tint res = false;\n\tut32 i = 0;\n\tif (strncmp (input, \"java\", 4)) {\n\t\treturn false;\n\t}\n\tif (input[4] != ' ') {\n\t\treturn r_cmd_java_handle_help (core, input);\n\t}\n\tfor (; i < END_CMDS; i++) {\n\t\tIFDBG r_cons_printf (\"Checking cmd: %s %d\\n\", JAVA_CMDS[i].name,\n\t\t\tstrncmp (input+5, JAVA_CMDS[i].name, JAVA_CMDS[i].name_len));\n\t\tif (!strncmp (input + 5, JAVA_CMDS[i].name, JAVA_CMDS[i].name_len)) {\n\t\t\tconst char *cmd = input + 5 + JAVA_CMDS[i].name_len;\n\t\t\tif (*cmd && *cmd == ' ') {\n\t\t\t\tcmd++;\n\t\t\t}\n\t\t\tres =  JAVA_CMDS[i].handler (core, cmd);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!res) {\n\t\treturn r_cmd_java_handle_help (core, input);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "TfLiteStatus ResizeOutputTensor(TfLiteContext* context,\n                                BatchToSpaceNDContext* op_context) {\n  TfLiteIntArray* input_size = op_context->input->dims;\n  const int* block_shape = GetTensorData<int32>(op_context->block_shape);\n  const int* crops = GetTensorData<int32>(op_context->crops);\n  int spatial_dims_num = input_size->size - 2;\n  TF_LITE_ENSURE_EQ(context, NumDimensions(op_context->block_shape), 1);\n  TF_LITE_ENSURE_EQ(context, op_context->block_shape->dims->data[0],\n                    spatial_dims_num);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(op_context->crops), 2);\n  TF_LITE_ENSURE_EQ(context, op_context->crops->dims->data[0],\n                    spatial_dims_num);\n  TF_LITE_ENSURE_EQ(context, op_context->crops->dims->data[1], 2);\n  for (int i = 0; i < spatial_dims_num * 2; ++i) {\n    TF_LITE_ENSURE(context, crops[i] >= 0);\n  }\n  TfLiteIntArray* output_size = TfLiteIntArrayCopy(input_size);\n  int output_batch_size = input_size->data[0];\n  for (int dim = 0; dim < spatial_dims_num; ++dim) {\n    TF_LITE_ENSURE(context, block_shape[dim] != 0);\n    TF_LITE_ENSURE_EQ(context, output_batch_size % block_shape[dim], 0);\n    output_batch_size = output_batch_size / block_shape[dim];\n    output_size->data[dim + 1] = input_size->data[dim + 1] * block_shape[dim] -\n                                 crops[dim * 2] - crops[dim * 2 + 1];\n  }\n  output_size->data[0] = output_batch_size;\n  output_size->data[input_size->size - 1] =\n      input_size->data[input_size->size - 1];\n  return context->ResizeTensor(context, op_context->output, output_size);\n}", "target": 0}
{"code": "header_put_be_short (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 2)\n\t{\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} ", "target": 1}
{"code": "test_validate_path_args (void)\n{\n  gsize idx;\n  for (idx = 0; idx < G_N_ELEMENTS (invalid_path_args); idx++)\n    {\n      g_autoptr(FlatpakContext) context = flatpak_context_new ();\n      g_autoptr(GError) local_error = NULL;\n      const char *path = invalid_path_args[idx];\n      context_parse_args (context, &local_error, path, NULL);\n      g_assert_error (local_error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA);\n      g_assert (strstr (local_error->message, \"Non-graphical character\"));\n    }\n}", "target": 0}
{"code": "static int nfc_genl_llc_get_params(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\tint rc = 0;\n\tstruct sk_buff *msg = NULL;\n\tu32 idx;\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_FIRMWARE_NAME])\n\t\treturn -EINVAL;\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\tdevice_lock(&dev->dev);\n\tlocal = nfc_llcp_find_local(dev);\n\tif (!local) {\n\t\trc = -ENODEV;\n\t\tgoto exit;\n\t}\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\trc = -ENOMEM;\n\t\tgoto exit;\n\t}\n\trc = nfc_genl_send_params(msg, local, info->snd_portid, info->snd_seq);\nexit:\n\tdevice_unlock(&dev->dev);\n\tnfc_put_device(dev);\n\tif (rc < 0) {\n\t\tif (msg)\n\t\t\tnlmsg_free(msg);\n\t\treturn rc;\n\t}\n\treturn genlmsg_reply(msg, info);\n}", "target": 1}
{"code": "static void spl_array_it_get_current_key(zend_object_iterator *iter, zval *key TSRMLS_DC) \n{\n\tspl_array_it       *iterator = (spl_array_it *)iter;\n\tspl_array_object   *object   = iterator->object;\n\tHashTable          *aht      = spl_array_get_hash_table(object, 0 TSRMLS_CC);\n\tif (object->ar_flags & SPL_ARRAY_OVERLOADED_KEY) {\n\t\tzend_user_it_get_current_key(iter, key TSRMLS_CC);\n\t} else {\n\t\tif (spl_array_object_verify_pos_ex(object, aht, \"ArrayIterator::current(): \" TSRMLS_CC) == FAILURE) {\n\t\t\tZVAL_NULL(key);\n\t\t} else {\n\t\t\tzend_hash_get_current_key_zval_ex(aht, key, &object->pos);\n\t\t}\n\t}\n}", "target": 0}
{"code": "static int __jfs_set_acl(tid_t tid, struct inode *inode, int type,\n\t\t       struct posix_acl *acl)\n{\n\tchar *ea_name;\n\tint rc;\n\tint size = 0;\n\tchar *value = NULL;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tea_name = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\trc = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\tinode->i_ctime = CURRENT_TIME;\n\t\t\tmark_inode_dirty(inode);\n\t\t\tif (rc == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tea_name = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn -ENOMEM;\n\t\trc = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\t}\n\trc = __jfs_setxattr(tid, inode, ea_name, value, size, 0);\nout:\n\tkfree(value);\n\tif (!rc)\n\t\tset_cached_acl(inode, type, acl);\n\treturn rc;\n}", "target": 1}
{"code": "static void irda_flow_indication(void *instance, void *sap, LOCAL_FLOW flow)\n{\n\tstruct irda_sock *self;\n\tstruct sock *sk;\n\tIRDA_DEBUG(2, \"%s()\\n\", __func__);\n\tself = instance;\n\tsk = instance;\n\tBUG_ON(sk == NULL);\n\tswitch (flow) {\n\tcase FLOW_STOP:\n\t\tIRDA_DEBUG(1, \"%s(), IrTTP wants us to slow down\\n\",\n\t\t\t   __func__);\n\t\tself->tx_flow = flow;\n\t\tbreak;\n\tcase FLOW_START:\n\t\tself->tx_flow = flow;\n\t\tIRDA_DEBUG(1, \"%s(), IrTTP wants us to start again\\n\",\n\t\t\t   __func__);\n\t\twake_up_interruptible(sk->sk_sleep);\n\t\tbreak;\n\tdefault:\n\t\tIRDA_DEBUG(0, \"%s(), Unknown flow command!\\n\", __func__);\n\t\tself->tx_flow = flow;\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "static GroupList collectGroups(const std::string &fulltext)\n{\n\tGroupList groupList; \n\tint lineNo = 1; \n\tbool inString = false; \n\tfor (unsigned int i=0; i<fulltext.length(); ++i) {\n\t\tif (fulltext[i] == '\\n') {\n\t\t\tlineNo++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (inString && fulltext.compare(i, 2, \"\\\\\\\"\") == 0) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (fulltext[i] == '\"') {\n\t\t\tinString = !inString;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!inString && fulltext.compare(i, 2, \"\n\t\t\ti++;\n\t\t\twhile (fulltext[i] != '\\n' && i<fulltext.length() ) i++;\n\t\t\tlineNo++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!inString && fulltext.compare(i, 2, \" every character is comment\n\t\t\twhile (fulltext.compare(i, 2, \"*/\") != 0 && i<fulltext.length()) {\n\t\t\t\tif(fulltext[i]=='\\n'){\n\t\t\t\t\tlineNo++;\n\t\t\t\t\tisGroup=false;\n\t\t\t\t}\n\t\t\t\tcomment += fulltext[i];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif(isGroup)\n\t\t\t\tgroupList.push_back(createGroup(comment,lineNo));\n\t\t}\n\t}\n\treturn groupList;\n}", "target": 0}
{"code": "\t\tstatic auto HasProxy(Local<Object> object) -> bool {\n\t\t\tif (object->IsProxy()) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tauto proto = object->GetPrototype();\n\t\t\t\tif (proto->IsNullOrUndefined()) {\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\treturn HasProxy(proto.As<Object>());\n\t\t\t\t}\n\t\t\t}\n\t\t}", "target": 0}
{"code": "static int linear_ioctl(struct dm_target *ti, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct linear_c *lc = (struct linear_c *) ti->private;\n\treturn __blkdev_driver_ioctl(lc->dev->bdev, lc->dev->mode, cmd, arg);\n}", "target": 1}
{"code": "stf_status ikev2parent_inI2outR2(struct msg_digest *md)\n{\n\tstruct state *st = md->st;\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\n\t\t    \"ikev2 parent inI2outR2: calculating g^{xy} in order to decrypt I2\"));\n\tif (!md->chain[ISAKMP_NEXT_v2E]) {\n\t\tlibreswan_log(\"R2 state should receive an encrypted payload\");\n\t\treset_globals();\n\t\treturn STF_FATAL;\n\t}\n\t{\n\t\tstruct dh_continuation *dh = alloc_thing(\n\t\t\tstruct dh_continuation,\n\t\t\t\"ikev2_inI2outR2 KE\");\n\t\tstf_status e;\n\t\tdh->md = md;\n\t\tset_suspended(st, dh->md);\n\t\tpcrc_init(&dh->dh_pcrc);\n\t\tdh->dh_pcrc.pcrc_func = ikev2_parent_inI2outR2_continue;\n\t\te = start_dh_v2(&dh->dh_pcrc, st, st->st_import, RESPONDER,\n\t\t\t\tst->st_oakley.groupnum);\n\t\tif (e != STF_SUSPEND && e != STF_INLINE) {\n\t\t\tloglog(RC_CRYPTOFAILED, \"system too busy\");\n\t\t\tdelete_state(st);\n\t\t}\n\t\treset_globals();\n\t\treturn e;\n\t}\n}", "target": 1}
{"code": "asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct oabi_flock64 user;\n\tstruct flock64 kernel;\n\tmm_segment_t fs = USER_DS; \n\tunsigned long local_arg = arg;\n\tint ret;\n\tswitch (cmd) {\n\tcase F_OFD_GETLK:\n\tcase F_OFD_SETLK:\n\tcase F_OFD_SETLKW:\n\tcase F_GETLK64:\n\tcase F_SETLK64:\n\tcase F_SETLKW64:\n\t\tif (copy_from_user(&user, (struct oabi_flock64 __user *)arg,\n\t\t\t\t   sizeof(user)))\n\t\t\treturn -EFAULT;\n\t\tkernel.l_type\t= user.l_type;\n\t\tkernel.l_whence\t= user.l_whence;\n\t\tkernel.l_start\t= user.l_start;\n\t\tkernel.l_len\t= user.l_len;\n\t\tkernel.l_pid\t= user.l_pid;\n\t\tlocal_arg = (unsigned long)&kernel;\n\t\tfs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t}\n\tret = sys_fcntl64(fd, cmd, local_arg);\n\tswitch (cmd) {\n\tcase F_GETLK64:\n\t\tif (!ret) {\n\t\t\tuser.l_type\t= kernel.l_type;\n\t\t\tuser.l_whence\t= kernel.l_whence;\n\t\t\tuser.l_start\t= kernel.l_start;\n\t\t\tuser.l_len\t= kernel.l_len;\n\t\t\tuser.l_pid\t= kernel.l_pid;\n\t\t\tif (copy_to_user((struct oabi_flock64 __user *)arg,\n\t\t\t\t\t &user, sizeof(user)))\n\t\t\t\tret = -EFAULT;\n\t\t}\n\tcase F_SETLK64:\n\tcase F_SETLKW64:\n\t\tset_fs(fs);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)\n{\n\tint ret;\n\tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,\n\t\t\t      indx, &data, 1, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}", "target": 1}
{"code": "int sock_initaddress(const char *host, const char *port,\n    struct addrinfo *hints, struct addrinfo **addrinfo, char *errbuf, int errbuflen)\n{\n\tint retval;\n\tretval = getaddrinfo(host, port == NULL ? \"0\" : port, hints, addrinfo);\n\tif (retval != 0)\n\t{\n\t\tif (errbuf)\n\t\t{\n\t\t\tif (host != NULL && port != NULL) {\n\t\t\t\tint try_retval;\n\t\t\t\ttry_retval = getaddrinfo(host, NULL, hints,\n\t\t\t\t    addrinfo);\n\t\t\t\tif (try_retval == 0) {\n\t\t\t\t\tfreeaddrinfo(*addrinfo);\n\t\t\t\t\tget_gai_errstring(errbuf, errbuflen,\n\t\t\t\t\t    \"\", retval, NULL, port);\n\t\t\t\t} else {\n\t\t\t\t\tget_gai_errstring(errbuf, errbuflen,\n\t\t\t\t\t    \"\", retval, host, NULL);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tget_gai_errstring(errbuf, errbuflen, \"\",\n\t\t\t\t    retval, host, port);\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tif (((*addrinfo)->ai_family != PF_INET) &&\n\t    ((*addrinfo)->ai_family != PF_INET6))\n\t{\n\t\tif (errbuf)\n\t\t\tsnprintf(errbuf, errbuflen, \"getaddrinfo(): socket type not supported\");\n\t\tfreeaddrinfo(*addrinfo);\n\t\t*addrinfo = NULL;\n\t\treturn -1;\n\t}\n\tif (((*addrinfo)->ai_socktype == SOCK_STREAM) &&\n\t    (sock_ismcastaddr((*addrinfo)->ai_addr) == 0))\n\t{\n\t\tif (errbuf)\n\t\t\tsnprintf(errbuf, errbuflen, \"getaddrinfo(): multicast addresses are not valid when using TCP streams\");\n\t\tfreeaddrinfo(*addrinfo);\n\t\t*addrinfo = NULL;\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void mongo_pass_digest( const char *user, const char *pass, char hex_digest[33] ) {\n    mongo_md5_state_t st;\n    mongo_md5_byte_t digest[16];\n    mongo_md5_init( &st );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )user, strlen( user ) );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )\":mongo:\", 7 );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )pass, strlen( pass ) );\n    mongo_md5_finish( &st, digest );\n    digest2hex( digest, hex_digest );\n}", "target": 1}
{"code": "static int ovl_remove_upper(struct dentry *dentry, bool is_dir)\n{\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *dir = upperdir->d_inode;\n\tstruct dentry *upper = ovl_dentry_upper(dentry);\n\tint err;\n\tinode_lock_nested(dir, I_MUTEX_PARENT);\n\terr = -ESTALE;\n\tif (upper->d_parent == upperdir) {\n\t\tdget(upper);\n\t\tif (is_dir)\n\t\t\terr = vfs_rmdir(dir, upper);\n\t\telse\n\t\t\terr = vfs_unlink(dir, upper, NULL);\n\t\tdput(upper);\n\t\tovl_dentry_version_inc(dentry->d_parent);\n\t}\n\tif (!err)\n\t\td_drop(dentry);\n\tinode_unlock(dir);\n\treturn err;\n}", "target": 1}
{"code": "static void esp_do_nodma(ESPState *s)\n{\n    int to_device = ((s->rregs[ESP_RSTAT] & 7) == STAT_DO);\n    uint32_t cmdlen;\n    int len;\n    if (s->do_cmd) {\n        cmdlen = fifo8_num_used(&s->cmdfifo);\n        trace_esp_handle_ti_cmd(cmdlen);\n        s->ti_size = 0;\n        if ((s->rregs[ESP_RSTAT] & 7) == STAT_CD) {\n            if (s->cmdfifo_cdb_offset == fifo8_num_used(&s->cmdfifo)) {\n                return;\n            }\n            s->do_cmd = 0;\n            do_cmd(s);\n        } else {\n            s->cmdfifo_cdb_offset = fifo8_num_used(&s->cmdfifo);\n            s->rregs[ESP_RSTAT] = STAT_TC | STAT_CD;\n            s->rregs[ESP_RSEQ] = SEQ_CD;\n            s->rregs[ESP_RINTR] |= INTR_BS;\n            esp_raise_irq(s);\n        }\n        return;\n    }\n    if (!s->current_req) {\n        return;\n    }\n    if (s->async_len == 0) {\n        return;\n    }\n    if (to_device) {\n        len = MIN(fifo8_num_used(&s->fifo), ESP_FIFO_SZ);\n        esp_fifo_pop_buf(&s->fifo, s->async_buf, len);\n        s->async_buf += len;\n        s->async_len -= len;\n        s->ti_size += len;\n    } else {\n        if (fifo8_is_empty(&s->fifo)) {\n            fifo8_push(&s->fifo, s->async_buf[0]);\n            s->async_buf++;\n            s->async_len--;\n            s->ti_size--;\n        }\n    }\n    if (s->async_len == 0) {\n        scsi_req_continue(s->current_req);\n        return;\n    }\n    s->rregs[ESP_RINTR] |= INTR_BS;\n    esp_raise_irq(s);\n}", "target": 1}
{"code": "static CURLcode pop3_parse_url_path(struct connectdata *conn)\n{\n  struct pop3_conn *pop3c = &conn->proto.pop3c;\n  struct SessionHandle *data = conn->data;\n  const char *path = data->state.path;\n  pop3c->mailbox = curl_easy_unescape(data, path, 0, NULL);\n  if(!pop3c->mailbox)\n    return CURLE_OUT_OF_MEMORY;\n  return CURLE_OK;\n}", "target": 1}
{"code": "ev_archive_get_entry_size (EvArchive *archive)\n{\n\tg_return_val_if_fail (EV_IS_ARCHIVE (archive), -1);\n\tg_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, -1);\n\tswitch (archive->type) {\n\tcase EV_ARCHIVE_TYPE_NONE:\n\t\tg_assert_not_reached ();\n\tcase EV_ARCHIVE_TYPE_RAR:\n\tcase EV_ARCHIVE_TYPE_ZIP:\n\tcase EV_ARCHIVE_TYPE_7Z:\n\tcase EV_ARCHIVE_TYPE_TAR:\n\t\tg_return_val_if_fail (archive->libar_entry != NULL, -1);\n\t\treturn archive_entry_size (archive->libar_entry);\n\t}\n\treturn -1;\n}", "target": 0}
{"code": "RCMS *r_pkcs7_parse_cms (const ut8 *buffer, ut32 length) {\n\tRASN1Object *object;\n\tRCMS *container;\n\tif (!buffer || !length) {\n\t\treturn NULL;\n\t}\n\tcontainer = R_NEW0 (RCMS);\n\tif (!container) {\n\t\treturn NULL;\n\t}\n\tobject = r_asn1_create_object (buffer, length);\n\tif (!object || object->list.length != 2 || !object->list.objects[0] || object->list.objects[1]->list.length != 1) {\n\t\tr_asn1_free_object (object);\n\t\tfree (container);\n\t\treturn NULL;\n\t}\n\tcontainer->contentType = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length);\n\tr_pkcs7_parse_signeddata (&container->signedData, object->list.objects[1]->list.objects[0]);\n\tr_asn1_free_object (object);\n\treturn container;\n}", "target": 1}
{"code": "void oz_hcd_get_desc_cnf(void *hport, u8 req_id, int status, const u8 *desc,\n\t\t\tint length, int offset, int total_size)\n{\n\tstruct oz_port *port = hport;\n\tstruct urb *urb;\n\tint err = 0;\n\toz_dbg(ON, \"oz_hcd_get_desc_cnf length = %d offs = %d tot_size = %d\\n\",\n\t       length, offset, total_size);\n\turb = oz_find_urb_by_id(port, 0, req_id);\n\tif (!urb)\n\t\treturn;\n\tif (status == 0) {\n\t\tint copy_len;\n\t\tint required_size = urb->transfer_buffer_length;\n\t\tif (required_size > total_size)\n\t\t\trequired_size = total_size;\n\t\tcopy_len = required_size-offset;\n\t\tif (length <= copy_len)\n\t\t\tcopy_len = length;\n\t\tmemcpy(urb->transfer_buffer+offset, desc, copy_len);\n\t\toffset += copy_len;\n\t\tif (offset < required_size) {\n\t\t\tstruct usb_ctrlrequest *setup =\n\t\t\t\t(struct usb_ctrlrequest *)urb->setup_packet;\n\t\t\tunsigned wvalue = le16_to_cpu(setup->wValue);\n\t\t\tif (oz_enqueue_ep_urb(port, 0, 0, urb, req_id))\n\t\t\t\terr = -ENOMEM;\n\t\t\telse if (oz_usb_get_desc_req(port->hpd, req_id,\n\t\t\t\t\tsetup->bRequestType, (u8)(wvalue>>8),\n\t\t\t\t\t(u8)wvalue, setup->wIndex, offset,\n\t\t\t\t\trequired_size-offset)) {\n\t\t\t\toz_dequeue_ep_urb(port, 0, 0, urb);\n\t\t\t\terr = -ENOMEM;\n\t\t\t}\n\t\t\tif (err == 0)\n\t\t\t\treturn;\n\t\t}\n\t}\n\turb->actual_length = total_size;\n\toz_complete_urb(port->ozhcd->hcd, urb, 0);\n}", "target": 1}
{"code": "void take_dentry_name_snapshot(struct name_snapshot *name, struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\tif (unlikely(dname_external(dentry))) {\n\t\tstruct external_name *p = external_name(dentry);\n\t\tatomic_inc(&p->u.count);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tname->name = p->name;\n\t} else {\n\t\tmemcpy(name->inline_name, dentry->d_iname, DNAME_INLINE_LEN);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tname->name = name->inline_name;\n\t}\n}", "target": 0}
{"code": "static bool parseUrlAddrFromRtspUrlString(const char* rtspUrlString, char* destination, size_t destinationLength) {\n    char* rtspUrlScratchBuffer;\n    char* portSeparator;\n    char* v6EscapeEndChar;\n    char* urlPathSeparator;\n    int prefixLen;\n    rtspUrlScratchBuffer = strdup(rtspUrlString);\n    if (rtspUrlScratchBuffer == NULL) {\n        return false;\n    }\n    portSeparator = strrchr(rtspUrlScratchBuffer, ':');\n    v6EscapeEndChar = strchr(rtspUrlScratchBuffer, ']');\n    for (prefixLen = 2; rtspUrlScratchBuffer[prefixLen - 2] != 0 && (rtspUrlScratchBuffer[prefixLen - 2] != '/' || rtspUrlScratchBuffer[prefixLen - 1] != '/'); prefixLen++);\n    if (rtspUrlScratchBuffer[prefixLen - 2] == 0) {\n        free(rtspUrlScratchBuffer);\n        return false;\n    }\n    urlPathSeparator = strchr(rtspUrlScratchBuffer + prefixLen, '/');\n    if (v6EscapeEndChar) {\n        *(v6EscapeEndChar + 1) = 0;\n    }\n    else if (portSeparator) {\n        *portSeparator = 0;\n    }\n    else if (urlPathSeparator) {\n        *urlPathSeparator = 0;\n    }\n    PltSafeStrcpy(destination, destinationLength, rtspUrlScratchBuffer + prefixLen);\n    destination[destinationLength - 1] = '\\0';\n    free(rtspUrlScratchBuffer);\n    return true;\n}", "target": 0}
{"code": "sg_fill_request_table(Sg_fd *sfp, sg_req_info_t *rinfo)\n{\n\tSg_request *srp;\n\tint val;\n\tunsigned int ms;\n\tval = 0;\n\tlist_for_each_entry(srp, &sfp->rq_list, entry) {\n\t\tif (val > SG_MAX_QUEUE)\n\t\t\tbreak;\n\t\tmemset(&rinfo[val], 0, SZ_SG_REQ_INFO);\n\t\trinfo[val].req_state = srp->done + 1;\n\t\trinfo[val].problem =\n\t\t\tsrp->header.masked_status &\n\t\t\tsrp->header.host_status &\n\t\t\tsrp->header.driver_status;\n\t\tif (srp->done)\n\t\t\trinfo[val].duration =\n\t\t\t\tsrp->header.duration;\n\t\telse {\n\t\t\tms = jiffies_to_msecs(jiffies);\n\t\t\trinfo[val].duration =\n\t\t\t\t(ms > srp->header.duration) ?\n\t\t\t\t(ms - srp->header.duration) : 0;\n\t\t}\n\t\trinfo[val].orphan = srp->orphan;\n\t\trinfo[val].sg_io_owned = srp->sg_io_owned;\n\t\trinfo[val].pack_id = srp->header.pack_id;\n\t\trinfo[val].usr_ptr = srp->header.usr_ptr;\n\t\tval++;\n\t}\n}", "target": 1}
{"code": "static int sco_send_frame(struct sock *sk, struct msghdr *msg, int len)\n{\n\tstruct sco_conn *conn = sco_pi(sk)->conn;\n\tstruct sk_buff *skb;\n\tint err;\n\tif (len > conn->mtu)\n\t\treturn -EINVAL;\n\tBT_DBG(\"sk %p len %d\", sk, len);\n\tskb = bt_skb_send_alloc(sk, len, msg->msg_flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\treturn err;\n\tif (memcpy_from_msg(skb_put(skb, len), msg, len)) {\n\t\tkfree_skb(skb);\n\t\treturn -EFAULT;\n\t}\n\thci_send_sco(conn->hcon, skb);\n\treturn len;\n}", "target": 1}
{"code": "static void set_cpu_rq_start_time(void)\n{\n\tint cpu = smp_processor_id();\n\tstruct rq *rq = cpu_rq(cpu);\n\trq->age_stamp = sched_clock_cpu(cpu);\n}", "target": 0}
{"code": "static int mov_read_covr(MOVContext *c, AVIOContext *pb, int type, int len)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    enum AVCodecID id;\n    int ret;\n    switch (type) {\n    case 0xd:  id = AV_CODEC_ID_MJPEG; break;\n    case 0xe:  id = AV_CODEC_ID_PNG;   break;\n    case 0x1b: id = AV_CODEC_ID_BMP;   break;\n    default:\n        av_log(c->fc, AV_LOG_WARNING, \"Unknown cover type: 0x%x.\\n\", type);\n        avio_skip(pb, len);\n        return 0;\n    }\n    sc = av_mallocz(sizeof(*sc));\n    if (!sc)\n        return AVERROR(ENOMEM);\n    ret = ff_add_attached_pic(c->fc, NULL, pb, NULL, len);\n    if (ret < 0) {\n        av_free(sc);\n        return ret;\n    }\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    st->priv_data = sc;\n    if (st->attached_pic.size >= 8 && id != AV_CODEC_ID_BMP) {\n        if (AV_RB64(st->attached_pic.data) == 0x89504e470d0a1a0a) {\n            id = AV_CODEC_ID_PNG;\n        } else {\n            id = AV_CODEC_ID_MJPEG;\n        }\n    }\n    st->codecpar->codec_id   = id;\n    return 0;\n}", "target": 0}
{"code": "static inline int ext4_should_dioread_nolock(struct inode *inode)\n{\n\tif (!test_opt(inode->i_sb, DIOREAD_NOLOCK))\n\t\treturn 0;\n\tif (test_opt(inode->i_sb, NOBH))\n\t\treturn 0;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (!(EXT4_I(inode)->i_flags & EXT4_EXTENTS_FL))\n\t\treturn 0;\n\tif (ext4_should_journal_data(inode))\n\t\treturn 0;\n\treturn 1;\n}", "target": 0}
{"code": "main(void)\n{\n    test(1, \"\", \"\");\n    test(1, \"a\", \"a\");\n    test(1, \"abc\", \"abc\");\n    test(0, \"a\", \"\");\n    test(0, \"ab\", \"\");\n    test(0, \"\", \"a\");\n    test(0, \"\", \"ab\");\n    test(0, \"abcd\", \"abc\");\n    test(0, \"abc\", \"abcd\");\n    return 0;\n}", "target": 0}
{"code": "\tvoid testQueryCompositionMathWrite_GoogleAutofuzz113244572() {\n\t\tUriQueryListA second = { .key = \"\\x11\", .value = NULL, .next = NULL };\n\t\tUriQueryListA first = { .key = \"\\x01\", .value = \"\\x02\", .next = &second };\n\t\tconst UriBool spaceToPlus = URI_TRUE;\n\t\tconst UriBool normalizeBreaks = URI_FALSE;  \n\t\tconst int charsRequired = (3 + 1 + 3) + 1 + (3);\n\t\t{\n\t\t\tconst char * const expected = \"%01=%02\" \"&\" \"%11\";\n\t\t\tchar dest[charsRequired + 1];\n\t\t\tint charsWritten;\n\t\t\tTEST_ASSERT(uriComposeQueryExA(dest, &first, sizeof(dest),\n\t\t\t\t\t&charsWritten, spaceToPlus, normalizeBreaks)\n\t\t\t\t== URI_SUCCESS);\n\t\t\tTEST_ASSERT(! strcmp(dest, expected));\n\t\t\tTEST_ASSERT(charsWritten == strlen(expected) + 1);\n\t\t}\n\t\t{\n\t\t\tchar dest[charsRequired + 1 - 1];\n\t\t\tint charsWritten;\n\t\t\tTEST_ASSERT(uriComposeQueryExA(dest, &first, sizeof(dest),\n\t\t\t\t\t&charsWritten, spaceToPlus, normalizeBreaks)\n\t\t\t\t== URI_ERROR_OUTPUT_TOO_LARGE);\n\t\t}\n\t}", "target": 0}
{"code": "TEST(FormatTest, Regression) {\n  fmt::format(\"...........{:<77777.7p}\", \"foo\");\n}", "target": 0}
{"code": "LIBOPENMPT_MODPLUG_API unsigned int ModPlug_InstrumentName(ModPlugFile* file, unsigned int qual, char* buff)\n{\n\tconst char* str;\n\tunsigned int retval;\n\tsize_t tmpretval;\n\tif(!file) return 0;\n\tstr = openmpt_module_get_instrument_name(file->mod,qual-1);\n\tif(!str){\n\t\tif(buff){\n\t\t\t*buff = '\\0';\n\t\t}\n\t\treturn 0;\n\t}\n\ttmpretval = strlen(str);\n\tif(tmpretval>=INT_MAX){\n\t\ttmpretval = INT_MAX-1;\n\t}\n\tretval = (int)tmpretval;\n\tif(buff){\n\t\tmemcpy(buff,str,retval+1);\n\t\tbuff[retval] = '\\0';\n\t}\n\topenmpt_free_string(str);\n\treturn retval;\n}", "target": 1}
{"code": "name_parse(u8 *packet, int length, int *idx, char *name_out, int name_out_len) {\n\tint name_end = -1;\n\tint j = *idx;\n\tint ptr_count = 0;\n#define GET32(x) do { if (j + 4 > length) goto err; memcpy(&t32_, packet + j, 4); j += 4; x = ntohl(t32_); } while (0)\n#define GET16(x) do { if (j + 2 > length) goto err; memcpy(&t_, packet + j, 2); j += 2; x = ntohs(t_); } while (0)\n#define GET8(x) do { if (j >= length) goto err; x = packet[j++]; } while (0)\n\tchar *cp = name_out;\n\tconst char *const end = name_out + name_out_len;\n\tfor (;;) {\n\t\tu8 label_len;\n\t\tif (j >= length) return -1;\n\t\tGET8(label_len);\n\t\tif (!label_len) break;\n\t\tif (label_len & 0xc0) {\n\t\t\tu8 ptr_low;\n\t\t\tGET8(ptr_low);\n\t\t\tif (name_end < 0) name_end = j;\n\t\t\tj = (((int)label_len & 0x3f) << 8) + ptr_low;\n\t\t\tif (j < 0 || j >= length) return -1;\n\t\t\tif (++ptr_count > length) return -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (label_len > 63) return -1;\n\t\tif (cp != name_out) {\n\t\t\tif (cp + 1 >= end) return -1;\n\t\t\t*cp++ = '.';\n\t\t}\n\t\tif (cp + label_len >= end) return -1;\n\t\tmemcpy(cp, packet + j, label_len);\n\t\tcp += label_len;\n\t\tj += label_len;\n\t}\n\tif (cp >= end) return -1;\n\t*cp = '\\0';\n\tif (name_end < 0)\n\t\t*idx = j;\n\telse\n\t\t*idx = name_end;\n\treturn 0;\n err:\n\treturn -1;\n}", "target": 1}
{"code": "TfLiteStatus EvalHashtable(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE(context, node->user_data != nullptr);\n  const auto* params =\n      reinterpret_cast<const TfLiteHashtableParams*>(node->user_data);\n  const int resource_id = std::hash<std::string>{}(params->table_name);\n  TfLiteTensor* resource_handle_tensor =\n      GetOutput(context, node, kResourceHandleTensor);\n  auto* resource_handle_data =\n      GetTensorData<std::int32_t>(resource_handle_tensor);\n  resource_handle_data[0] = resource_id;\n  Subgraph* subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n  auto& resources = subgraph->resources();\n  resource::CreateHashtableResourceIfNotAvailable(\n      &resources, resource_id, params->key_dtype, params->value_dtype);\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static void stellaris_enet_class_init(ObjectClass *klass, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(klass);\n    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);\n    k->init = stellaris_enet_init;\n    dc->unrealize = stellaris_enet_unrealize;\n    dc->props = stellaris_enet_properties;\n    dc->vmsd = &vmstate_stellaris_enet;\n}", "target": 0}
{"code": "valid_ruser(const char *s)\n{\n\tsize_t i;\n\tif (*s == '-')\n\t\treturn 0;\n\tfor (i = 0; s[i] != 0; i++) {\n\t\tif (strchr(\"'`\\\";&<>|(){}\", s[i]) != NULL)\n\t\t\treturn 0;\n\t\tif (isspace((u_char)s[i]) && s[i + 1] == '-')\n\t\t\treturn 0;\n\t\tif (s[i] == '\\\\' && s[i + 1] == '\\0')\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "static void sas_discover_domain(struct work_struct *work)\n{\n\tstruct domain_device *dev;\n\tint error = 0;\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev->port;\n\tclear_bit(DISCE_DISCOVER_DOMAIN, &port->disc.pending);\n\tif (port->port_dev)\n\t\treturn;\n\terror = sas_get_port_device(port);\n\tif (error)\n\t\treturn;\n\tdev = port->port_dev;\n\tSAS_DPRINTK(\"DOING DISCOVERY on port %d, pid:%d\\n\", port->id,\n\t\t    task_pid_nr(current));\n\tswitch (dev->dev_type) {\n\tcase SAS_END_DEVICE:\n\t\terror = sas_discover_end_dev(dev);\n\t\tbreak;\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\terror = sas_discover_root_expander(dev);\n\t\tbreak;\n\tcase SAS_SATA_DEV:\n\tcase SAS_SATA_PM:\n#ifdef CONFIG_SCSI_SAS_ATA\n\t\terror = sas_discover_sata(dev);\n\t\tbreak;\n#else\n\t\tSAS_DPRINTK(\"ATA device seen but CONFIG_SCSI_SAS_ATA=N so cannot attach\\n\");\n#endif\n\tdefault:\n\t\terror = -ENXIO;\n\t\tSAS_DPRINTK(\"unhandled device %d\\n\", dev->dev_type);\n\t\tbreak;\n\t}\n\tif (error) {\n\t\tsas_rphy_free(dev->rphy);\n\t\tlist_del_init(&dev->disco_list_node);\n\t\tspin_lock_irq(&port->dev_list_lock);\n\t\tlist_del_init(&dev->dev_list_node);\n\t\tspin_unlock_irq(&port->dev_list_lock);\n\t\tsas_put_device(dev);\n\t\tport->port_dev = NULL;\n\t}\n\tsas_probe_devices(port);\n\tSAS_DPRINTK(\"DONE DISCOVERY on port %d, pid:%d, result:%d\\n\", port->id,\n\t\t    task_pid_nr(current), error);\n}", "target": 0}
{"code": "  bool IsInUse() { return entry_stack_ != NULL; }", "target": 0}
{"code": "get_chainname_rulenum(const struct ip6t_entry *s, const struct ip6t_entry *e,\n\t\t      const char *hookname, const char **chainname,\n\t\t      const char **comment, unsigned int *rulenum)\n{\n\tconst struct xt_standard_target *t = (void *)ip6t_get_target_c(s);\n\tif (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {\n\t\t*chainname = t->target.data;\n\t\t(*rulenum) = 0;\n\t} else if (s == e) {\n\t\t(*rulenum)++;\n\t\tif (s->target_offset == sizeof(struct ip6t_entry) &&\n\t\t    strcmp(t->target.u.kernel.target->name,\n\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t    t->verdict < 0 &&\n\t\t    unconditional(&s->ipv6)) {\n\t\t\t*comment = *chainname == hookname\n\t\t\t\t? comments[NF_IP6_TRACE_COMMENT_POLICY]\n\t\t\t\t: comments[NF_IP6_TRACE_COMMENT_RETURN];\n\t\t}\n\t\treturn 1;\n\t} else\n\t\t(*rulenum)++;\n\treturn 0;\n}", "target": 1}
{"code": "    void SetArcInMem(byte *Data,size_t Size)\n    {\n      ArcMemData=Data;\n      ArcMemSize=Size;\n      ArcInMem=Data!=NULL && Size>0;\n    }", "target": 0}
{"code": "static bool blk_kick_flush(struct request_queue *q, struct blk_flush_queue *fq)\n{\n\tstruct list_head *pending = &fq->flush_queue[fq->flush_pending_idx];\n\tstruct request *first_rq =\n\t\tlist_first_entry(pending, struct request, flush.list);\n\tstruct request *flush_rq = fq->flush_rq;\n\tif (fq->flush_pending_idx != fq->flush_running_idx || list_empty(pending))\n\t\treturn false;\n\tif (!list_empty(&fq->flush_data_in_flight) &&\n\t    time_before(jiffies,\n\t\t\tfq->flush_pending_since + FLUSH_PENDING_TIMEOUT))\n\t\treturn false;\n\tfq->flush_pending_idx ^= 1;\n\tblk_rq_init(q, flush_rq);\n\tif (q->mq_ops) {\n\t\tflush_rq->mq_ctx = first_rq->mq_ctx;\n\t\tflush_rq->tag = first_rq->tag;\n\t}\n\tflush_rq->cmd_type = REQ_TYPE_FS;\n\tflush_rq->cmd_flags = WRITE_FLUSH | REQ_FLUSH_SEQ;\n\tflush_rq->rq_disk = first_rq->rq_disk;\n\tflush_rq->end_io = flush_end_io;\n\treturn blk_flush_queue_rq(flush_rq, false);\n}", "target": 1}
{"code": "static int32_t check_load_area(uintptr_t dst, uintptr_t len)\n{\n\tuint32_t legacy = dst + len <= UINT32_MAX - 1 ? 1 : 0;\n\tuintptr_t dram_start, dram_end;\n\tuintptr_t prot_start, prot_end;\n\tint32_t result = IO_SUCCESS;\n\tdram_start = legacy ? DRAM1_NS_BASE : DRAM_40BIT_BASE;\n\tdram_end = legacy ? DRAM1_NS_BASE + DRAM1_NS_SIZE :\n\t    DRAM_40BIT_BASE + DRAM_40BIT_SIZE;\n\tprot_start = legacy ? DRAM_PROTECTED_BASE : DRAM_40BIT_PROTECTED_BASE;\n\tprot_end = prot_start + DRAM_PROTECTED_SIZE;\n\tif (dst < dram_start || dst > dram_end - len || dram_end < len) {\n\t\tERROR(\"BL2: dst address is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t\tgoto done;\n\t}\n\tif (dst >= prot_start && dst < prot_end) {\n\t\tERROR(\"BL2: dst address is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t\tgoto done;\n\t}\n\tif ((dst < prot_start && dst > prot_start - len) || prot_start < len) {\n\t\tERROR(\"BL2: loaded data is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t\tgoto done;\n\t}\n\tif (addr_loaded_cnt >= CHECK_IMAGE_AREA_CNT) {\n\t\tERROR(\"BL2: max loadable non secure images reached\\n\");\n\t\tresult = IO_FAIL;\n\t\tgoto done;\n\t}\n\taddr_loaded[addr_loaded_cnt].dest = dst;\n\taddr_loaded[addr_loaded_cnt].length = len;\n\tfor(int n=0; n<addr_loaded_cnt; n++) {\n\t\tif (((dst >= addr_loaded[n].dest) &&\n\t\t     (dst <=  addr_loaded[n].dest + addr_loaded[n].length)) ||\n\t\t    ((dst + len >= addr_loaded[n].dest) &&\n\t\t     (dst + len <= addr_loaded[n].dest + addr_loaded[n].length)) ||\n\t\t    ((dst <= addr_loaded[n].dest) &&\n\t\t     (dst + len >= addr_loaded[n].dest + addr_loaded[n].length))) {\n\t\t\tERROR(\"BL2: next image overlap a previous image area.\\n\");\n\t\t\tresult = IO_FAIL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\taddr_loaded_cnt++;\ndone:\n\tif (result == IO_FAIL) {\n\t\tERROR(\"BL2: Out of range : dst=0x%lx len=0x%lx\\n\", dst, len);\n\t}\n\treturn result;\n}", "target": 0}
{"code": "static void *arm_coherent_dma_alloc(struct device *dev, size_t size,\n\tdma_addr_t *handle, gfp_t gfp, struct dma_attrs *attrs)\n{\n\tpgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);\n\tvoid *memory;\n\tif (dma_alloc_from_coherent(dev, size, handle, &memory))\n\t\treturn memory;\n\treturn __dma_alloc(dev, size, handle, gfp, prot, true,\n\t\t\t   __builtin_return_address(0));\n}", "target": 1}
{"code": "jas_matrix_t *jas_matrix_create(int numrows, int numcols)\n{\n\tjas_matrix_t *matrix;\n\tint i;\n\tsize_t size;\n\tmatrix = 0;\n\tif (numrows < 0 || numcols < 0) {\n\t\tgoto error;\n\t}\n\tif (!(matrix = jas_malloc(sizeof(jas_matrix_t)))) {\n\t\tgoto error;\n\t}\n\tmatrix->flags_ = 0;\n\tmatrix->numrows_ = numrows;\n\tmatrix->numcols_ = numcols;\n\tmatrix->rows_ = 0;\n\tmatrix->maxrows_ = numrows;\n\tmatrix->data_ = 0;\n\tmatrix->datasize_ = 0;\n\tif (!jas_safe_size_mul(numrows, numcols, &size)) {\n\t\tgoto error;\n\t}\n\tmatrix->datasize_ = size;\n\tif (matrix->maxrows_ > 0) {\n\t\tif (!(matrix->rows_ = jas_alloc2(matrix->maxrows_,\n\t\t  sizeof(jas_seqent_t *)))) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\tif (matrix->datasize_ > 0) {\n\t\tif (!(matrix->data_ = jas_alloc2(matrix->datasize_,\n\t\t  sizeof(jas_seqent_t)))) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\tfor (i = 0; i < numrows; ++i) {\n\t\tmatrix->rows_[i] = &matrix->data_[i * matrix->numcols_];\n\t}\n\tfor (i = 0; i < matrix->datasize_; ++i) {\n\t\tmatrix->data_[i] = 0;\n\t}\n\tmatrix->xstart_ = 0;\n\tmatrix->ystart_ = 0;\n\tmatrix->xend_ = matrix->numcols_;\n\tmatrix->yend_ = matrix->numrows_;\n\treturn matrix;\nerror:\n\tif (matrix) {\n\t\tjas_matrix_destroy(matrix);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "mp_join_print(netdissect_options *ndo,\n              const u_char *opt, u_int opt_len, u_char flags)\n{\n        const struct mp_join *mpj = (const struct mp_join *) opt;\n        if (!(opt_len == 12 && flags & TH_SYN) &&\n            !(opt_len == 16 && (flags & (TH_SYN | TH_ACK)) == (TH_SYN | TH_ACK)) &&\n            !(opt_len == 24 && flags & TH_ACK))\n                return 0;\n        if (opt_len != 24) {\n                if (mpj->sub_b & MP_JOIN_B)\n                        ND_PRINT((ndo, \" backup\"));\n                ND_PRINT((ndo, \" id %u\", mpj->addr_id));\n        }\n        switch (opt_len) {\n        case 12: \n                ND_PRINT((ndo, \" token 0x%x\" \" nonce 0x%x\",\n                        EXTRACT_32BITS(mpj->u.syn.token),\n                        EXTRACT_32BITS(mpj->u.syn.nonce)));\n                break;\n        case 16: \n                ND_PRINT((ndo, \" hmac 0x%\" PRIx64 \" nonce 0x%x\",\n                        EXTRACT_64BITS(mpj->u.synack.mac),\n                        EXTRACT_32BITS(mpj->u.synack.nonce)));\n                break;\n        case 24: {\n                size_t i;\n                ND_PRINT((ndo, \" hmac 0x\"));\n                for (i = 0; i < sizeof(mpj->u.ack.mac); ++i)\n                        ND_PRINT((ndo, \"%02x\", mpj->u.ack.mac[i]));\n        }\n        default:\n                break;\n        }\n        return 1;\n}", "target": 1}
{"code": "SPL_METHOD(MultipleIterator, getFlags)\n{\n\tspl_SplObjectStorage *intern = (spl_SplObjectStorage*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_LONG(intern->flags);\n}", "target": 0}
{"code": "        unsigned int GetUVarBE(int nPos, int nSize, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos + nSize > m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            unsigned int nRes = 0;\n            for ( int nIndex = 0; nIndex < nSize; ++nIndex )\n                nRes = (nRes << 8) + m_sFile[nPos + nIndex];\n            return nRes;\n        }", "target": 1}
{"code": "flatpak_filesystem_key_in_home (const char *filesystem)\n{\n  if (strcmp (filesystem, \"home\") == 0)\n    return TRUE;\n  if (g_strv_contains (flatpak_context_special_filesystems, filesystem) ||\n      g_str_has_prefix (filesystem, \"/\"))\n    return FALSE;\n  if (g_str_has_prefix (filesystem, \"xdg-run\"))\n    return FALSE;\n  return TRUE;\n}", "target": 0}
{"code": "std::string controller::bookmark(\n\t\tconst std::string& url,\n\t\tconst std::string& title,\n\t\tconst std::string& description,\n\t\tconst std::string& feed_title)\n{\n\tstd::string bookmark_cmd = cfg.get_configvalue(\"bookmark-cmd\");\n\tbool is_interactive = cfg.get_configvalue_as_bool(\"bookmark-interactive\");\n\tif (bookmark_cmd.length() > 0) {\n\t\tstd::string cmdline = strprintf::fmt(\"%s '%s' %s %s %s\",\n\t\t                                       bookmark_cmd,\n\t\t                                       utils::replace_all(url,\"'\", \"%27\"),\n\t\t                                       quote_empty(stfl::quote(title)),\n\t\t                                       quote_empty(stfl::quote(description)),\n\t\t                                       quote_empty(stfl::quote(feed_title)));\n\t\tLOG(level::DEBUG, \"controller::bookmark: cmd = %s\", cmdline);\n\t\tif (is_interactive) {\n\t\t\tv->push_empty_formaction();\n\t\t\tstfl::reset();\n\t\t\tutils::run_interactively(cmdline, \"controller::bookmark\");\n\t\t\tv->pop_current_formaction();\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\tchar * my_argv[4];\n\t\t\tmy_argv[0] = const_cast<char *>(\"/bin/sh\");\n\t\t\tmy_argv[1] = const_cast<char *>(\"-c\");\n\t\t\tmy_argv[2] = const_cast<char *>(cmdline.c_str());\n\t\t\tmy_argv[3] = nullptr;\n\t\t\treturn utils::run_program(my_argv, \"\");\n\t\t}\n\t} else {\n\t\treturn _(\"bookmarking support is not configured. Please set the configuration variable `bookmark-cmd' accordingly.\");\n\t}\n}", "target": 1}
{"code": "GF_Err tenc_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TrackEncryptionBox *ptr = (GF_TrackEncryptionBox*) a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"TrackEncryptionBox\", trace);\n\tfprintf(trace, \"isEncrypted=\\\"%d\\\"\", ptr->isProtected);\n\tif (ptr->Per_Sample_IV_Size)\n\t\tfprintf(trace, \" IV_size=\\\"%d\\\" KID=\\\"\", ptr->Per_Sample_IV_Size);\n\telse {\n\t\tfprintf(trace, \" constant_IV_size=\\\"%d\\\" constant_IV=\\\"\", ptr->constant_IV_size);\n\t\tdump_data_hex(trace, (char *) ptr->constant_IV, ptr->constant_IV_size);\n\t\tfprintf(trace, \"\\\"  KID=\\\"\");\n\t}\n\tdump_data_hex(trace, (char *) ptr->KID, 16);\n\tif (ptr->version) \n\t\tfprintf(trace, \"\\\" crypt_byte_block=\\\"%d\\\" skip_byte_block=\\\"%d\", ptr->crypt_byte_block, ptr->skip_byte_block);\n\tfprintf(trace, \"\\\">\\n\");\n\tgf_isom_box_dump_done(\"TrackEncryptionBox\", a, trace);\n\treturn GF_OK;\n}", "target": 1}
{"code": "static bool couldRecur(const Variant& v, const ArrayData* arr) {\n  return v.isReferenced() ||\n    arr->kind() == ArrayData::kGlobalsKind ||\n    arr->kind() == ArrayData::kProxyKind;\n}", "target": 0}
{"code": "static int mem_resize(jas_stream_memobj_t *m, int bufsize)\n{\n\tunsigned char *buf;\n\tassert(bufsize >= 0);\n\tJAS_DBGLOG(100, (\"mem_resize(%p, %d)\\n\", m, bufsize));\n\tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&\n\t  bufsize) {\n\t\tJAS_DBGLOG(100, (\"mem_resize realloc failed\\n\"));\n\t\treturn -1;\n\t}\n\tJAS_DBGLOG(100, (\"mem_resize realloc succeeded\\n\"));\n\tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}", "target": 1}
{"code": "void warn_on_nonidempotent_op(struct nfsd4_op *op)\n{\n\tif (OPDESC(op)->op_flags & OP_MODIFIES_SOMETHING) {\n\t\tpr_err(\"unable to encode reply to nonidempotent op %d (%s)\\n\",\n\t\t\top->opnum, nfsd4_op_name(op->opnum));\n\t\tWARN_ON_ONCE(1);\n\t}\n}", "target": 0}
{"code": "spnego_gss_import_sec_context(\n\tOM_uint32\t\t*minor_status,\n\tconst gss_buffer_t\tinterprocess_token,\n\tgss_ctx_id_t\t\t*context_handle)\n{\n\tOM_uint32 ret;\n\tret = gss_import_sec_context(minor_status,\n\t\t\t\t    interprocess_token,\n\t\t\t\t    context_handle);\n\treturn (ret);\n}", "target": 1}
{"code": "static Jsi_RC jsi_ArrayJoinCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    const char *jstr = \"\";\n    int argc, curlen;\n    Jsi_DString dStr = {};\n    curlen = Jsi_ObjGetLength(interp, _this->d.obj);\n    if (curlen == 0) {\n        goto bail;\n    }\n    if (Jsi_ValueGetLength(interp, args) >= 1) {\n        Jsi_Value *sc = Jsi_ValueArrayIndex(interp, args, 0);\n        if (sc != NULL)\n            jstr = Jsi_ValueToString(interp, sc, NULL);\n    }\n    if (0 == (argc=Jsi_ObjGetLength(interp, _this->d.obj))) {\n        goto bail;\n    }\n    int i;\n    for (i = 0; i < argc; ++i) {\n        const char *cp;\n        Jsi_Value *ov = Jsi_ValueArrayIndex(interp, _this, i);\n        if (!ov) {\n            continue;\n            cp = \"\";\n        } else\n            cp = Jsi_ValueToString(interp, ov, NULL);\n        if (i && jstr[0])\n            Jsi_DSAppend(&dStr, jstr, NULL);\n        Jsi_DSAppend(&dStr, cp, NULL);\n    }\n    Jsi_ValueMakeStringDup(interp, ret, Jsi_DSValue(&dStr));\n    Jsi_DSFree(&dStr);\n    return JSI_OK;\nbail:\n    Jsi_ValueMakeStringDup(interp, ret, \"\");\n    return JSI_OK;        \n}", "target": 1}
{"code": "static int64_t http_seek_internal(URLContext *h, int64_t off, int whence, int force_reconnect)\n{\n    HTTPContext *s = h->priv_data;\n    URLContext *old_hd = s->hd;\n    int64_t old_off = s->off;\n    uint8_t old_buf[BUFFER_SIZE];\n    int old_buf_size, ret;\n    AVDictionary *options = NULL;\n    if (whence == AVSEEK_SIZE)\n        return s->filesize;\n    else if (!force_reconnect &&\n             ((whence == SEEK_CUR && off == 0) ||\n              (whence == SEEK_SET && off == s->off)))\n        return s->off;\n    else if ((s->filesize == -1 && whence == SEEK_END))\n        return AVERROR(ENOSYS);\n    if (whence == SEEK_CUR)\n        off += s->off;\n    else if (whence == SEEK_END)\n        off += s->filesize;\n    else if (whence != SEEK_SET)\n        return AVERROR(EINVAL);\n    if (off < 0)\n        return AVERROR(EINVAL);\n    s->off = off;\n    if (s->off && h->is_streamed)\n        return AVERROR(ENOSYS);\n    old_buf_size = s->buf_end - s->buf_ptr;\n    memcpy(old_buf, s->buf_ptr, old_buf_size);\n    s->hd = NULL;\n    if ((ret = http_open_cnx(h, &options)) < 0) {\n        av_dict_free(&options);\n        memcpy(s->buffer, old_buf, old_buf_size);\n        s->buf_ptr = s->buffer;\n        s->buf_end = s->buffer + old_buf_size;\n        s->hd      = old_hd;\n        s->off     = old_off;\n        return ret;\n    }\n    av_dict_free(&options);\n    ffurl_close(old_hd);\n    return off;\n}", "target": 1}
{"code": "static bool dccp_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t     unsigned int dataoff, unsigned int *timeouts)\n{\n\tstruct net *net = nf_ct_net(ct);\n\tstruct dccp_net *dn;\n\tstruct dccp_hdr _dh, *dh;\n\tconst char *msg;\n\tu_int8_t state;\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n\tBUG_ON(dh == NULL);\n\tstate = dccp_state_table[CT_DCCP_ROLE_CLIENT][dh->dccph_type][CT_DCCP_NONE];\n\tswitch (state) {\n\tdefault:\n\t\tdn = dccp_pernet(net);\n\t\tif (dn->dccp_loose == 0) {\n\t\t\tmsg = \"nf_ct_dccp: not picking up existing connection \";\n\t\t\tgoto out_invalid;\n\t\t}\n\tcase CT_DCCP_REQUEST:\n\t\tbreak;\n\tcase CT_DCCP_INVALID:\n\t\tmsg = \"nf_ct_dccp: invalid state transition \";\n\t\tgoto out_invalid;\n\t}\n\tct->proto.dccp.role[IP_CT_DIR_ORIGINAL] = CT_DCCP_ROLE_CLIENT;\n\tct->proto.dccp.role[IP_CT_DIR_REPLY] = CT_DCCP_ROLE_SERVER;\n\tct->proto.dccp.state = CT_DCCP_NONE;\n\tct->proto.dccp.last_pkt = DCCP_PKT_REQUEST;\n\tct->proto.dccp.last_dir = IP_CT_DIR_ORIGINAL;\n\tct->proto.dccp.handshake_seq = 0;\n\treturn true;\nout_invalid:\n\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\tnf_log_packet(net, nf_ct_l3num(ct), 0, skb, NULL, NULL,\n\t\t\t      NULL, \"%s\", msg);\n\treturn false;\n}", "target": 1}
{"code": "void HTMLMediaElement::OnVisibilityChangedForLazyLoad(bool is_visible) {\n  if (!is_visible || !web_media_player_)\n    return;\n  web_media_player_->OnBecameVisible();\n  lazy_load_visibility_observer_->Stop();\n  lazy_load_visibility_observer_ = nullptr;\n}", "target": 0}
{"code": "static Eina_Bool _ewk_view_smart_key_up(Ewk_View_Smart_Data* smartData, const Evas_Event_Key_Up* upEvent)\n{\n    Evas_Object* frame = ewk_view_frame_focused_get(smartData->self);\n    if (!frame)\n        frame = smartData->main_frame;\n    return ewk_frame_feed_key_up(frame, upEvent);\n}", "target": 0}
{"code": "static void sctp_generate_timeout_event(struct sctp_association *asoc,\n\t\t\t\t\tsctp_event_timeout_t timeout_type)\n{\n\tstruct net *net = sock_net(asoc->base.sk);\n\tint error = 0;\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy: timer %d\\n\", __func__,\n\t\t\t timeout_type);\n\t\tif (!mod_timer(&asoc->timers[timeout_type], jiffies + (HZ/20)))\n\t\t\tsctp_association_hold(asoc);\n\t\tgoto out_unlock;\n\t}\n\tif (asoc->base.dead)\n\t\tgoto out_unlock;\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(timeout_type),\n\t\t\t   asoc->state, asoc->ep, asoc,\n\t\t\t   (void *)timeout_type, GFP_ATOMIC);\n\tif (error)\n\t\tasoc->base.sk->sk_err = -error;\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_association_put(asoc);\n}", "target": 1}
{"code": "AutoFillManager::AutoFillManager(TabContents* tab_contents,\n                                 PersonalDataManager* personal_data)\n    : tab_contents_(tab_contents),\n      personal_data_(personal_data),\n      download_manager_(NULL) {\n  DCHECK(tab_contents);\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, CantExplodeMetaSort) {\n    addIndex(BSON(\"a\" << 1 << \"b\" << 1 << \"c\"\n                      << \"text\"));\n    runQuerySortProj(fromjson(\"{a: {$in: [1, 2]}, b: {$in: [3, 4]}}\"),\n                     fromjson(\"{c: {$meta: 'textScore'}}\"),\n                     fromjson(\"{c: {$meta: 'textScore'}}\"));\n    assertNumSolutions(1U);\n    assertSolutionExists(\n        \"{proj: {spec: {c:{$meta:'textScore'}}, node: \"\n        \"{sort: {pattern: {c:{$meta:'textScore'}}, limit: 0, node: {sortKeyGen: {node: \"\n        \"{cscan: {filter: {a:{$in:[1,2]},b:{$in:[3,4]}}, dir: 1}}}}}}}}\");\n}", "target": 0}
{"code": "void WasmBinaryWriter::writeDebugLocation(Expression* curr, Function* func) {\n  if (sourceMap) {\n    auto& debugLocations = func->debugLocations;\n    auto iter = debugLocations.find(curr);\n    if (iter != debugLocations.end()) {\n      writeDebugLocation(iter->second);\n    }\n  }\n  if (func && !func->expressionLocations.empty()) {\n    binaryLocations.expressions[curr] =\n      BinaryLocations::Span{BinaryLocation(o.size()), 0};\n    binaryLocationTrackedExpressionsForFunc.push_back(curr);\n  }\n}", "target": 0}
{"code": "static int bad_format_imginfo(\n    char *fmt)\n{\n    char     *ptr;\n    int       n = 0;\n    ptr = fmt;\n    while (*ptr != '\\0')\n        if (*ptr++ == '%') {\n            if (*ptr == '\\0')\n                return 1;\n            if (*ptr == '%')\n                ptr++;\n            else if (*ptr == 's' || *ptr == 'S') {\n                n = 1;\n                ptr++;\n            }\n            else {\n                if (*ptr == ' ')\n                    ptr++;\n                while (*ptr >= '0' && *ptr <= '9')\n                    ptr++;\n                if (*ptr++ != 'l')\n                    return 1;\n                if (*ptr == 'u')\n                    ptr++;\n                else\n                    return 1;\n                n++;\n            }\n        }\n    return (n != 3);\n}", "target": 1}
{"code": "static void parse_content_range(URLContext *h, const char *p)\n{\n    HTTPContext *s = h->priv_data;\n    const char *slash;\n    if (!strncmp(p, \"bytes \", 6)) {\n        p     += 6;\n        s->off = strtoll(p, NULL, 10);\n        if ((slash = strchr(p, '/')) && strlen(slash) > 0)\n            s->filesize = strtoll(slash + 1, NULL, 10);\n    }\n    if (s->seekable == -1 && (!s->is_akamai || s->filesize != 2147483647))\n        h->is_streamed = 0; \n}", "target": 1}
{"code": "int fit_config_verify_required_sigs(const void *fit, int conf_noffset,\n\t\t\t\t    const void *sig_blob)\n{\n\tint noffset;\n\tint sig_node;\n\tint verified = 0;\n\tint reqd_sigs = 0;\n\tbool reqd_policy_all = true;\n\tconst char *reqd_mode;\n\tsig_node = fdt_subnode_offset(sig_blob, 0, FIT_SIG_NODENAME);\n\tif (sig_node < 0) {\n\t\tdebug(\"%s: No signature node found: %s\\n\", __func__,\n\t\t      fdt_strerror(sig_node));\n\t\treturn 0;\n\t}\n\treqd_mode = fdt_getprop(sig_blob, sig_node, \"required-mode\", NULL);\n\tif (reqd_mode && !strcmp(reqd_mode, \"any\"))\n\t\treqd_policy_all = false;\n\tdebug(\"%s: required-mode policy set to '%s'\\n\", __func__,\n\t      reqd_policy_all ? \"all\" : \"any\");\n\tfdt_for_each_subnode(noffset, sig_blob, sig_node) {\n\t\tconst char *required;\n\t\tint ret;\n\t\trequired = fdt_getprop(sig_blob, noffset, FIT_KEY_REQUIRED,\n\t\t\t\t       NULL);\n\t\tif (!required || strcmp(required, \"conf\"))\n\t\t\tcontinue;\n\t\treqd_sigs++;\n\t\tret = fit_config_verify_sig(fit, conf_noffset, sig_blob,\n\t\t\t\t\t    noffset);\n\t\tif (ret) {\n\t\t\tif (reqd_policy_all) {\n\t\t\t\tprintf(\"Failed to verify required signature '%s'\\n\",\n\t\t\t\t       fit_get_name(sig_blob, noffset, NULL));\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\tverified++;\n\t\t\tif (!reqd_policy_all)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (reqd_sigs && !verified) {\n\t\tprintf(\"Failed to verify 'any' of the required signature(s)\\n\");\n\t\treturn -EPERM;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int br_multicast_add_group(struct net_bridge *br,\n\t\t\t\t  struct net_bridge_port *port,\n\t\t\t\t  struct br_ip *group)\n{\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tunsigned long now = jiffies;\n\tint err;\n\tspin_lock(&br->multicast_lock);\n\tif (!netif_running(br->dev) ||\n\t    (port && port->state == BR_STATE_DISABLED))\n\t\tgoto out;\n\tmp = br_multicast_new_group(br, port, group);\n\terr = PTR_ERR(mp);\n\tif (IS_ERR(mp))\n\t\tgoto err;\n\tif (!port) {\n\t\thlist_add_head(&mp->mglist, &br->mglist);\n\t\tmod_timer(&mp->timer, now + br->multicast_membership_interval);\n\t\tgoto out;\n\t}\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p->port == port)\n\t\t\tgoto found;\n\t\tif ((unsigned long)p->port < (unsigned long)port)\n\t\t\tbreak;\n\t}\n\tp = kzalloc(sizeof(*p), GFP_ATOMIC);\n\terr = -ENOMEM;\n\tif (unlikely(!p))\n\t\tgoto err;\n\tp->addr = *group;\n\tp->port = port;\n\tp->next = *pp;\n\thlist_add_head(&p->mglist, &port->mglist);\n\tsetup_timer(&p->timer, br_multicast_port_group_expired,\n\t\t    (unsigned long)p);\n\tsetup_timer(&p->query_timer, br_multicast_port_group_query_expired,\n\t\t    (unsigned long)p);\n\trcu_assign_pointer(*pp, p);\nfound:\n\tmod_timer(&p->timer, now + br->multicast_membership_interval);\nout:\n\terr = 0;\nerr:\n\tspin_unlock(&br->multicast_lock);\n\treturn err;\n}", "target": 1}
{"code": "static void vgacon_restore_screen(struct vc_data *c)\n{\n\tc->vc_origin = c->vc_visible_origin;\n\tvgacon_scrollback_cur->save = 0;\n\tif (!vga_is_gfx && !vgacon_scrollback_cur->restore) {\n\t\tscr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf,\n\t\t\t    c->vc_screenbuf_size > vga_vram_size ?\n\t\t\t    vga_vram_size : c->vc_screenbuf_size);\n\t\tvgacon_scrollback_cur->restore = 1;\n\t\tvgacon_scrollback_cur->cur = vgacon_scrollback_cur->cnt;\n\t}\n}", "target": 1}
{"code": "dirserv_set_cached_directory(const char *directory, time_t published,\n                             int is_running_routers)\n{\n  time_t now = time(NULL);\n  if (is_running_routers) {\n    if (published >= now - MAX_V1_RR_AGE)\n      set_cached_dir(&cached_runningrouters, tor_strdup(directory), published);\n  } else {\n    if (published >= now - MAX_V1_DIRECTORY_AGE) {\n      cached_dir_decref(cached_directory);\n      cached_directory = new_cached_dir(tor_strdup(directory), published);\n    }\n  }\n}", "target": 0}
{"code": "void HttpIntegrationTest::testManyRequestHeaders(std::chrono::milliseconds time) {\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void { hcm.mutable_max_request_headers_kb()->set_value(96); });\n  max_request_headers_kb_ = 96;\n  Http::TestHeaderMapImpl big_headers{\n      {\":method\", \"GET\"}, {\":path\", \"/test/long/url\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}};\n  for (int i = 0; i < 20000; i++) {\n    big_headers.addCopy(std::to_string(i), std::string(0, 'a'));\n  }\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response =\n      sendRequestAndWaitForResponse(big_headers, 0, default_response_headers_, 0, 0, time);\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n}", "target": 0}
{"code": "otError Commissioner::AddJoiner(const Mac::ExtAddress *aEui64, const char *aPskd, uint32_t aTimeout)\n{\n    otError error = OT_ERROR_NO_BUFS;\n    VerifyOrExit(mState == OT_COMMISSIONER_STATE_ACTIVE, error = OT_ERROR_INVALID_STATE);\n    VerifyOrExit(strlen(aPskd) <= Dtls::kPskMaxLength, error = OT_ERROR_INVALID_ARGS);\n    RemoveJoiner(aEui64, 0); \n    for (Joiner *joiner = &mJoiners[0]; joiner < OT_ARRAY_END(mJoiners); joiner++)\n    {\n        if (joiner->mValid)\n        {\n            continue;\n        }\n        if (aEui64 != NULL)\n        {\n            joiner->mEui64 = *aEui64;\n            joiner->mAny   = false;\n        }\n        else\n        {\n            joiner->mAny = true;\n        }\n        (void)strlcpy(joiner->mPsk, aPskd, sizeof(joiner->mPsk));\n        joiner->mValid          = true;\n        joiner->mExpirationTime = TimerMilli::GetNow() + Time::SecToMsec(aTimeout);\n        UpdateJoinerExpirationTimer();\n        SendCommissionerSet();\n        otLogInfoMeshCoP(\"Added Joiner (%s, %s)\", (aEui64 != NULL) ? aEui64->ToString().AsCString() : \"*\", aPskd);\n        ExitNow(error = OT_ERROR_NONE);\n    }\nexit:\n    return error;\n}", "target": 1}
{"code": "void TileManager::crop( RawTile *ttt ){\n  int tw = image->getTileWidth();\n  int th = image->getTileHeight();\n  if( loglevel >= 5 ){\n    *logfile << \"TileManager :: Edge tile: Base size: \" << tw << \"x\" << th\n\t     << \": This tile: \" << ttt->width << \"x\" << ttt->height\n\t     << endl;\n  }\n  int len = tw * th * ttt->channels * (ttt->bpc/8);\n  unsigned char* buffer = (unsigned char*) malloc( len );\n  unsigned char* src_ptr = (unsigned char*) memcpy( buffer, ttt->data, len );\n  unsigned char* dst_ptr = (unsigned char*) ttt->data;\n  len =  ttt->width * ttt->channels * (ttt->bpc/8);\n  for( unsigned int i=0; i<ttt->height; i++ ){\n    memcpy( dst_ptr, src_ptr, len );\n    dst_ptr += len;\n    src_ptr += tw * ttt->channels * (ttt->bpc/8);\n  }\n  free( buffer );\n  len = ttt->width * ttt->height * ttt->channels * (ttt->bpc/8);\n  ttt->dataLength = len;\n  ttt->padded = false;\n}", "target": 1}
{"code": "static void mark_curve(fixed sx, fixed sy, fixed c1x, fixed c1y, fixed c2x, fixed c2y, fixed ex, fixed ey, fixed base_y, fixed height, int *table, int *index, int depth)\n{\n    fixed ax = (sx + c1x)>>1;\n    fixed ay = (sy + c1y)>>1;\n    fixed bx = (c1x + c2x)>>1;\n    fixed by = (c1y + c2y)>>1;\n    fixed cx = (c2x + ex)>>1;\n    fixed cy = (c2y + ey)>>1;\n    fixed dx = (ax + bx)>>1;\n    fixed dy = (ay + by)>>1;\n    fixed fx = (bx + cx)>>1;\n    fixed fy = (by + cy)>>1;\n    fixed gx = (dx + fx)>>1;\n    fixed gy = (dy + fy)>>1;\n    assert(depth >= 0);\n    if (depth == 0)\n        mark_line(sx, sy, ex, ey, base_y, height, table, index);\n    else {\n        depth--;\n        mark_curve(sx, sy, ax, ay, dx, dy, gx, gy, base_y, height, table, index, depth);\n        mark_curve(gx, gy, fx, fy, cx, cy, ex, ey, base_y, height, table, index, depth);\n    }\n}", "target": 0}
{"code": "Jsi_Value *Jsi_ValueArrayIndex(Jsi_Interp *interp, Jsi_Value *args, int index)\n{\n    Jsi_Obj *obj = args->d.obj;\n    Jsi_Value *v;\n    assert(args->vt == JSI_VT_OBJECT);\n    if (obj->isarrlist && obj->arr)\n        return ((index < 0 || (uint)index >= obj->arrCnt) ? NULL : obj->arr[index]);\n    char unibuf[100];\n    Jsi_NumberItoA10(index, unibuf, sizeof(unibuf));\n    v = Jsi_TreeObjGetValue(args->d.obj, unibuf, 0);\n    return v;\n}", "target": 1}
{"code": "int ipfilter(struct pico_frame *f)\n{\n    struct filter_node temp;\n    struct pico_ipv4_hdr *ipv4_hdr = (struct pico_ipv4_hdr *) f->net_hdr;\n    struct pico_trans *trans;\n    struct pico_icmp4_hdr *icmp_hdr;\n    memset(&temp, 0u, sizeof(struct filter_node));\n    temp.fdev = f->dev;\n    temp.out_addr = ipv4_hdr->dst.addr;\n    temp.in_addr = ipv4_hdr->src.addr;\n    if ((ipv4_hdr->proto == PICO_PROTO_TCP) || (ipv4_hdr->proto == PICO_PROTO_UDP)) {\n        trans = (struct pico_trans *) f->transport_hdr;\n        temp.out_port = short_be(trans->dport);\n        temp.in_port = short_be(trans->sport);\n    }\n    else if(ipv4_hdr->proto == PICO_PROTO_ICMP4) {\n        icmp_hdr = (struct pico_icmp4_hdr *) f->transport_hdr;\n        if(icmp_hdr->type == PICO_ICMP_UNREACH && icmp_hdr->code == PICO_ICMP_UNREACH_FILTER_PROHIB)\n            return 0;\n    }\n    temp.proto = ipv4_hdr->proto;\n    temp.priority = f->priority;\n    temp.tos = ipv4_hdr->tos;\n    return ipfilter_apply_filter(f, &temp);\n}", "target": 1}
{"code": "static Jsi_RC jsi_ArrayUnshiftCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    Jsi_Obj *obj = _this->d.obj;\n    int argc = Jsi_ValueGetLength(interp, args);\n    int curlen = Jsi_ObjGetLength(interp, obj);\n    if (curlen < 0) {\n        Jsi_ObjSetLength(interp, obj, 0);\n    }\n    if (argc <= 0) {\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    Jsi_ObjListifyArray(interp, obj);\n    if (Jsi_ObjArraySizer(interp, obj, curlen+argc)<=0) \n        return Jsi_LogError(\"too long\");\n    memmove(obj->arr+argc, obj->arr, (curlen)*sizeof(Jsi_Value*));\n    obj->arrCnt += argc;\n    int i;\n    for (i = 0; i < argc; ++i) {\n        Jsi_Value *ov = Jsi_ValueArrayIndex(interp, args, i);\n        obj->arr[i] = NULL;\n        if (!ov) { Jsi_LogBug(\"Arguments Error\"); continue; }\n        obj->arr[i] = ov;\n        Jsi_IncrRefCount(interp, ov);\n    }\n    Jsi_ObjSetLength(interp, obj, curlen+argc);\n    Jsi_ValueMakeNumber(interp, ret, Jsi_ObjGetLength(interp, obj));\n    return JSI_OK;\n}", "target": 1}
{"code": "static int mincore_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\n\t\t\tstruct mm_walk *walk)\n{\n\tspinlock_t *ptl;\n\tstruct vm_area_struct *vma = walk->vma;\n\tpte_t *ptep;\n\tunsigned char *vec = walk->private;\n\tint nr = (end - addr) >> PAGE_SHIFT;\n\tptl = pmd_trans_huge_lock(pmd, vma);\n\tif (ptl) {\n\t\tmemset(vec, 1, nr);\n\t\tspin_unlock(ptl);\n\t\tgoto out;\n\t}\n\tif (pmd_trans_unstable(pmd)) {\n\t\t__mincore_unmapped_range(addr, end, vma, vec);\n\t\tgoto out;\n\t}\n\tptep = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);\n\tfor (; addr != end; ptep++, addr += PAGE_SIZE) {\n\t\tpte_t pte = *ptep;\n\t\tif (pte_none(pte))\n\t\t\t__mincore_unmapped_range(addr, addr + PAGE_SIZE,\n\t\t\t\t\t\t vma, vec);\n\t\telse if (pte_present(pte))\n\t\t\t*vec = 1;\n\t\telse { \n\t\t\tswp_entry_t entry = pte_to_swp_entry(pte);\n\t\t\tif (non_swap_entry(entry)) {\n\t\t\t\t*vec = 1;\n\t\t\t} else {\n#ifdef CONFIG_SWAP\n\t\t\t\t*vec = mincore_page(swap_address_space(entry),\n\t\t\t\t\t\t    swp_offset(entry));\n#else\n\t\t\t\tWARN_ON(1);\n\t\t\t\t*vec = 1;\n#endif\n\t\t\t}\n\t\t}\n\t\tvec++;\n\t}\n\tpte_unmap_unlock(ptep - 1, ptl);\nout:\n\twalk->private += nr;\n\tcond_resched();\n\treturn 0;\n}", "target": 1}
{"code": "static int jpegxl_anim_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    JXLAnimDemuxContext *ctx = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int ret;\n    int64_t size;\n    size_t offset = 0;\n    size = avio_size(pb);\n    if (size < 0)\n        return size;\n    if (size > INT_MAX)\n        return AVERROR(EDOM);\n    if (size == 0)\n        size = 4096;\n    if (ctx->initial && size < ctx->initial->size)\n        size = ctx->initial->size;\n    ret = av_new_packet(pkt, size);\n    if (ret < 0)\n        return ret;\n    if (ctx->initial) {\n        offset = ctx->initial->size;\n        memcpy(pkt->data, ctx->initial->data, offset);\n        av_buffer_unref(&ctx->initial);\n    }\n    ret = avio_read(pb, pkt->data + offset, size - offset);\n    if (ret < 0)\n        return ret;\n    if (ret < size - offset)\n        pkt->size = ret + offset;\n    return 0;\n}", "target": 0}
{"code": "static int encrypt(struct blkcipher_desc *desc,\n\t\t   struct scatterlist *dst, struct scatterlist *src,\n\t\t   unsigned int nbytes)\n{\n\tstruct blkcipher_walk walk;\n\tstruct crypto_blkcipher *tfm = desc->tfm;\n\tstruct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);\n\tint err;\n\tblkcipher_walk_init(&walk, dst, src, nbytes);\n\terr = blkcipher_walk_virt_block(desc, &walk, 64);\n\tsalsa20_ivsetup(ctx, walk.iv);\n\tif (likely(walk.nbytes == nbytes))\n\t{\n\t\tsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\n\t\t\t\t      walk.src.virt.addr, nbytes);\n\t\treturn blkcipher_walk_done(desc, &walk, 0);\n\t}\n\twhile (walk.nbytes >= 64) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\n\t\t\t\t      walk.src.virt.addr,\n\t\t\t\t      walk.nbytes - (walk.nbytes % 64));\n\t\terr = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);\n\t}\n\tif (walk.nbytes) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\n\t\t\t\t      walk.src.virt.addr, walk.nbytes);\n\t\terr = blkcipher_walk_done(desc, &walk, 0);\n\t}\n\treturn err;\n}", "target": 1}
{"code": "int anon_vma_clone(struct vm_area_struct *dst, struct vm_area_struct *src)\n{\n\tstruct anon_vma_chain *avc, *pavc;\n\tstruct anon_vma *root = NULL;\n\tlist_for_each_entry_reverse(pavc, &src->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma;\n\t\tavc = anon_vma_chain_alloc(GFP_NOWAIT | __GFP_NOWARN);\n\t\tif (unlikely(!avc)) {\n\t\t\tunlock_anon_vma_root(root);\n\t\t\troot = NULL;\n\t\t\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\t\t\tif (!avc)\n\t\t\t\tgoto enomem_failure;\n\t\t}\n\t\tanon_vma = pavc->anon_vma;\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_chain_link(dst, avc, anon_vma);\n\t\tif (!dst->anon_vma && src->anon_vma &&\n\t\t    anon_vma != src->anon_vma && anon_vma->degree < 2)\n\t\t\tdst->anon_vma = anon_vma;\n\t}\n\tif (dst->anon_vma)\n\t\tdst->anon_vma->degree++;\n\tunlock_anon_vma_root(root);\n\treturn 0;\n enomem_failure:\n\tdst->anon_vma = NULL;\n\tunlink_anon_vmas(dst);\n\treturn -ENOMEM;\n}", "target": 1}
{"code": "Status Tensor::BuildTensor(DataType type, const TensorShape& shape,\n                           Tensor* out_tensor) {\n  CASES_WITH_DEFAULT(\n      type, {}, return errors::InvalidArgument(\"Type not set\"),\n      return errors::InvalidArgument(\"Unexpected type: \", DataType_Name(type)));\n  *out_tensor = Tensor(type, shape);\n  return Status::OK();\n}", "target": 0}
{"code": "static MagickBooleanType DecodeLabImage(Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n  MagickBooleanType\n    status;\n  ssize_t\n    y;\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    PixelPacket\n      *magick_restrict q;\n    ssize_t\n      x;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      {\n        status=MagickFalse;\n        break;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        a,\n        b;\n      a=QuantumScale*GetPixela(q)+0.5;\n      if (a > 1.0)\n        a-=1.0;\n      b=QuantumScale*GetPixelb(q)+0.5;\n      if (b > 1.0)\n        b-=1.0;\n      SetPixela(q,QuantumRange*a);\n      SetPixelb(q,QuantumRange*b);\n      q++;\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      {\n        status=MagickFalse;\n        break;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}", "target": 0}
{"code": "REDIS_STATIC int _quicklistNodeAllowMerge(const quicklistNode *a,\n                                          const quicklistNode *b,\n                                          const int fill) {\n    if (!a || !b)\n        return 0;\n    unsigned int merge_sz = a->sz + b->sz - 11;\n    if (likely(_quicklistNodeSizeMeetsOptimizationRequirement(merge_sz, fill)))\n        return 1;\n    else if (!sizeMeetsSafetyLimit(merge_sz))\n        return 0;\n    else if ((int)(a->count + b->count) <= fill)\n        return 1;\n    else\n        return 0;\n}", "target": 0}
{"code": "int fz_colorspace_is_gray(fz_context *ctx, const fz_colorspace *cs)\n{\n\treturn cs && cs->type == FZ_COLORSPACE_GRAY;\n}", "target": 0}
{"code": "static bool ctx_single_port_submission(const struct intel_context *ce)\n{\n\treturn (IS_ENABLED(CONFIG_DRM_I915_GVT) &&\n\t\ti915_gem_context_force_single_submission(ce->gem_context));\n}", "target": 0}
{"code": "inline void ScatterNd(const RuntimeShape& indices_shape,\n                      const IndicesT* indices_data,\n                      const RuntimeShape& updates_shape,\n                      const UpdatesT* updates_data,\n                      const RuntimeShape& output_shape, UpdatesT* output_data) {\n  ruy::profiler::ScopeLabel label(\"ScatterNd\");\n  int n_slices = 1;\n  int slice_size = 1;\n  const int outer_dims = indices_shape.DimensionsCount() - 1;\n  const int indices_nd = indices_shape.Dims(outer_dims);\n  const int updates_dims = updates_shape.DimensionsCount();\n  for (int i = 0; i < outer_dims; ++i) {\n    n_slices *= indices_shape.Dims(i);\n  }\n  for (int i = outer_dims; i < updates_dims; ++i) {\n    slice_size *= updates_shape.Dims(i);\n  }\n  int output_flat_size = output_shape.FlatSize();\n  int remain_flat_size = output_flat_size;\n  std::vector<int> dims_to_count(indices_nd, 0);\n  for (int i = 0; i < indices_nd; ++i) {\n    dims_to_count[i] = remain_flat_size / output_shape.Dims(i);\n    remain_flat_size = dims_to_count[i];\n  }\n  memset(output_data, 0, sizeof(UpdatesT) * output_flat_size);\n  for (int i = 0; i < n_slices; ++i) {\n    int to_pos = 0;\n    for (int j = 0; j < indices_nd; ++j) {\n      IndicesT idx = indices_data[i * indices_nd + j];\n      TFLITE_DCHECK(0 <= idx && idx < output_shape.Dims(j));\n      to_pos += idx * dims_to_count[j];\n    }\n    for (int j = 0; j < slice_size; j++) {\n      output_data[to_pos + j] += updates_data[i * slice_size + j];\n    }\n  }\n}", "target": 1}
{"code": "aiff_read_chanmap (SF_PRIVATE * psf, unsigned dword)\n{\tconst AIFF_CAF_CHANNEL_MAP * map_info ;\n\tunsigned channel_bitmap, channel_decriptions, bytesread ;\n\tint layout_tag ;\n\tbytesread = psf_binheader_readf (psf, \"444\", &layout_tag, &channel_bitmap, &channel_decriptions) ;\n\tif ((map_info = aiff_caf_of_channel_layout_tag (layout_tag)) == NULL)\n\t\treturn 0 ;\n\tpsf_log_printf (psf, \"  Tag    : %x\\n\", layout_tag) ;\n\tif (map_info)\n\t\tpsf_log_printf (psf, \"  Layout : %s\\n\", map_info->name) ;\n\tif (bytesread < dword)\n\t\tpsf_binheader_readf (psf, \"j\", dword - bytesread) ;\n\tif (map_info->channel_map != NULL)\n\t{\tsize_t chanmap_size = psf->sf.channels * sizeof (psf->channel_map [0]) ;\n\t\tfree (psf->channel_map) ;\n\t\tif ((psf->channel_map = malloc (chanmap_size)) == NULL)\n\t\t\treturn SFE_MALLOC_FAILED ;\n\t\tmemcpy (psf->channel_map, map_info->channel_map, chanmap_size) ;\n\t\t} ;\n\treturn 0 ;\n} ", "target": 1}
{"code": "   Clears flags on messages */\nPHP_FUNCTION(imap_clearflag_full)\n{\n\tzval *streamind;\n\tzend_string *sequence, *flag;\n\tzend_long flags = 0;\n\tpils *imap_le_struct;\n\tint argc = ZEND_NUM_ARGS();\n\tif (zend_parse_parameters(argc, \"rSS|l\", &streamind, &sequence, &flag, &flags) ==FAILURE) {\n\t\treturn;\n\t}\n\tif ((imap_le_struct = (pils *)zend_fetch_resource(Z_RES_P(streamind), \"imap\", le_imap)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tmail_clearflag_full(imap_le_struct->imap_stream, ZSTR_VAL(sequence), ZSTR_VAL(flag), (argc == 4 ? flags : NIL));\n\tRETURN_TRUE;", "target": 0}
{"code": "Status ResourceHandle::BuildResourceHandle(const ResourceHandleProto& proto,\n                                           ResourceHandle* out) {\n  if (out == nullptr)\n    return errors::Internal(\n        \"BuildResourceHandle() was called with nullptr for the output\");\n  return out->FromProto(proto);\n}", "target": 0}
{"code": "static void update_ia32_tsc_adjust_msr(struct kvm_vcpu *vcpu, s64 offset)\n{\n\tu64 curr_offset = kvm_x86_ops->read_tsc_offset(vcpu);\n\tvcpu->arch.ia32_tsc_adjust_msr += offset - curr_offset;\n}", "target": 0}
{"code": "size_t TensorSliceWriter::MaxBytesPerElementOrZero(DataType dt) {\n  switch (dt) {\n    case DT_FLOAT:\n      return 4;\n    case DT_DOUBLE:\n      return 8;\n    case DT_INT32:\n      return 10;\n    case DT_UINT8:\n      return 2;\n    case DT_INT16:\n      return 10;\n    case DT_INT8:\n      return 10;\n    case DT_COMPLEX64:\n      return 8;\n    case DT_INT64:\n      return 10;\n    case DT_BOOL:\n      return 1;\n    case DT_QINT8:\n      return 10;\n    case DT_QUINT8:\n      return 2;\n    case DT_QINT32:\n      return 10;\n    case DT_QINT16:\n      return 10;\n    case DT_QUINT16:\n      return 3;\n    case DT_UINT16:\n      return 3;\n    case DT_COMPLEX128:\n      return 16;\n    case DT_HALF:\n      return 3;\n    case DT_INVALID:\n    case DT_STRING:\n    case DT_BFLOAT16:\n    default:\n      return 0;\n  }\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& in0 = ctx->input(0);\n    const Tensor& in1 = ctx->input(1);\n    ValidateInputTensors(ctx, in0, in1);\n    if (!ctx->status().ok()) {\n      return;\n    }\n    MatMulBCast bcast(in0.shape().dim_sizes(), in1.shape().dim_sizes());\n    OP_REQUIRES(\n        ctx, bcast.IsValid(),\n        errors::InvalidArgument(\n            \"In[0] and In[1] must have compatible batch dimensions: \",\n            in0.shape().DebugString(), \" vs. \", in1.shape().DebugString()));\n    TensorShape out_shape = bcast.output_batch_shape();\n    auto batch_size = bcast.output_batch_size();\n    auto d0 = in0.dim_size(in0.dims() - 2);\n    auto d1 = in0.dim_size(in0.dims() - 1);\n    Tensor in0_reshaped;\n    OP_REQUIRES(\n        ctx,\n        in0_reshaped.CopyFrom(in0, TensorShape({bcast.x_batch_size(), d0, d1})),\n        errors::Internal(\"Failed to reshape In[0] from \",\n                         in0.shape().DebugString()));\n    auto d2 = in1.dim_size(in1.dims() - 2);\n    auto d3 = in1.dim_size(in1.dims() - 1);\n    Tensor in1_reshaped;\n    OP_REQUIRES(\n        ctx,\n        in1_reshaped.CopyFrom(in1, TensorShape({bcast.y_batch_size(), d2, d3})),\n        errors::Internal(\"Failed to reshape In[1] from \",\n                         in1.shape().DebugString()));\n    if (adjoint_) std::swap(d0, d1);\n    OP_REQUIRES(ctx, d1 == d2,\n                errors::InvalidArgument(\n                    \"In[0] mismatch In[1] shape: \", d1, \" vs. \", d2, \": \",\n                    in0.shape().DebugString(), \" \", in1.shape().DebugString(),\n                    \" \", lower_, \" \", adjoint_));\n    out_shape.AddDim(d0);\n    out_shape.AddDim(d3);\n    Tensor* out = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, out_shape, &out));\n    if (out->NumElements() == 0) {\n      return;\n    }\n    Tensor out_reshaped;\n    OP_REQUIRES(ctx,\n                out_reshaped.CopyFrom(*out, TensorShape({batch_size, d0, d3})),\n                errors::Internal(\"Failed to reshape output from \",\n                                 out->shape().DebugString()));\n    LaunchBatchMatrixTriangularSolve<Device, Scalar>::Launch(\n        ctx, in0_reshaped, in1_reshaped, adjoint_, lower_, bcast,\n        &out_reshaped);\n  }", "target": 0}
{"code": "WifiNetwork::WifiNetwork()\n    : WirelessNetwork(),\n      encryption_(SECURITY_NONE) {\n  type_ = TYPE_WIFI;\n}", "target": 0}
{"code": "static inline void vm_entry_controls_init(struct vcpu_vmx *vmx, u32 val)\n{\n\tvmcs_write32(VM_ENTRY_CONTROLS, val);\n\tvmx->vm_entry_controls_shadow = val;\n}", "target": 0}
{"code": "    }\n    template<typename t>\n    const T& max_min(t& min_val) const {\n      if (is_empty())\n        throw CImgInstanceException(_cimglist_instance\n                                    \"max_min(): Empty instance.\",\n                                    cimglist_instance);\n      const T *ptr_max = _data->_data;\n      T min_value = *ptr_max, max_value = min_value;\n      cimglist_for(*this,l) {\n        const CImg<T>& img = _data[l];\n        cimg_for(img,ptrs,T) {\n          const T val = *ptrs;\n          if (val>max_value) { max_value = val; ptr_max = ptrs; }\n          if (val<min_value) min_value = val;\n        }", "target": 0}
{"code": "static int hci_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint copied, err;\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\tif (sk->sk_state == BT_CLOSED)\n\t\treturn 0;\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\treturn err;\n\tmsg->msg_namelen = 0;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tswitch (hci_pi(sk)->channel) {\n\tcase HCI_CHANNEL_RAW:\n\t\thci_sock_cmsg(sk, msg, skb);\n\t\tbreak;\n\tcase HCI_CHANNEL_USER:\n\tcase HCI_CHANNEL_CONTROL:\n\tcase HCI_CHANNEL_MONITOR:\n\t\tsock_recv_timestamp(msg, sk, skb);\n\t\tbreak;\n\t}\n\tskb_free_datagram(sk, skb);\n\treturn err ? : copied;\n}", "target": 1}
{"code": "int __gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error;\n\tint len;\n\tchar *data;\n\tconst char *name = gfs2_acl_name(type);\n\tif (acl && acl->a_count > GFS2_ACL_MAX_ENTRIES(GFS2_SB(inode)))\n\t\treturn -E2BIG;\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tumode_t mode = inode->i_mode;\n\t\terror = posix_acl_equiv_mode(acl, &mode);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tif (error == 0)\n\t\t\tacl = NULL;\n\t\tif (mode != inode->i_mode) {\n\t\t\tinode->i_mode = mode;\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t}\n\tif (acl) {\n\t\tlen = posix_acl_to_xattr(&init_user_ns, acl, NULL, 0);\n\t\tif (len == 0)\n\t\t\treturn 0;\n\t\tdata = kmalloc(len, GFP_NOFS);\n\t\tif (data == NULL)\n\t\t\treturn -ENOMEM;\n\t\terror = posix_acl_to_xattr(&init_user_ns, acl, data, len);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tdata = NULL;\n\t\tlen = 0;\n\t}\n\terror = __gfs2_xattr_set(inode, name, data, len, 0, GFS2_EATYPE_SYS);\n\tif (error)\n\t\tgoto out;\n\tset_cached_acl(inode, type, acl);\nout:\n\tkfree(data);\n\treturn error;\n}", "target": 1}
{"code": "static inline void free_ep_req(struct usb_ep *ep, struct usb_request *req)\n{\n\tWARN_ON(req->buf == NULL);\n\tkfree(req->buf);\n\treq->buf = NULL;\n\tusb_ep_free_request(ep, req);\n}", "target": 0}
{"code": "static u32 seq_scale(u32 seq)\n{\n\treturn seq + (ktime_to_ns(ktime_get_real()) >> 6);\n}", "target": 0}
{"code": "void * pvPortMalloc( size_t xWantedSize )\n{\n    BlockLink_t * pxBlock, * pxPreviousBlock, * pxNewBlockLink;\n    static BaseType_t xHeapHasBeenInitialised = pdFALSE;\n    void * pvReturn = NULL;\n    vTaskSuspendAll();\n    {\n        if( xHeapHasBeenInitialised == pdFALSE )\n        {\n            prvHeapInit();\n            xHeapHasBeenInitialised = pdTRUE;\n        }\n        if( xWantedSize > 0 )\n        {\n            xWantedSize += heapSTRUCT_SIZE;\n            if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )\n            {\n                xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\n            }\n        }\n        if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )\n        {\n            pxPreviousBlock = &xStart;\n            pxBlock = xStart.pxNextFreeBlock;\n            while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )\n            {\n                pxPreviousBlock = pxBlock;\n                pxBlock = pxBlock->pxNextFreeBlock;\n            }\n            if( pxBlock != &xEnd )\n            {\n                pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );\n                pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;\n                if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )\n                {\n                    pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );\n                    pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;\n                    pxBlock->xBlockSize = xWantedSize;\n                    prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );\n                }\n                xFreeBytesRemaining -= pxBlock->xBlockSize;\n            }\n        }\n        traceMALLOC( pvReturn, xWantedSize );\n    }\n    ( void ) xTaskResumeAll();\n    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )\n        {\n            if( pvReturn == NULL )\n            {\n                extern void vApplicationMallocFailedHook( void );\n                vApplicationMallocFailedHook();\n            }\n        }\n    #endif\n    return pvReturn;\n}", "target": 1}
{"code": "selReadStream(FILE  *fp)\n{\nchar    *selname;\nchar     linebuf[L_BUF_SIZE];\nl_int32  sy, sx, cy, cx, i, j, version, ignore;\nSEL     *sel;\n    PROCNAME(\"selReadStream\");\n    if (!fp)\n        return (SEL *)ERROR_PTR(\"stream not defined\", procName, NULL);\n    if (fscanf(fp, \"  Sel Version %d\\n\", &version) != 1)\n        return (SEL *)ERROR_PTR(\"not a sel file\", procName, NULL);\n    if (version != SEL_VERSION_NUMBER)\n        return (SEL *)ERROR_PTR(\"invalid sel version\", procName, NULL);\n    if (fgets(linebuf, L_BUF_SIZE, fp) == NULL)\n        return (SEL *)ERROR_PTR(\"error reading into linebuf\", procName, NULL);\n    selname = stringNew(linebuf);\n    sscanf(linebuf, \"  ------  %s  ------\", selname);\n    if (fscanf(fp, \"  sy = %d, sx = %d, cy = %d, cx = %d\\n\",\n            &sy, &sx, &cy, &cx) != 4) {\n        LEPT_FREE(selname);\n        return (SEL *)ERROR_PTR(\"dimensions not read\", procName, NULL);\n    }\n    if ((sel = selCreate(sy, sx, selname)) == NULL) {\n        LEPT_FREE(selname);\n        return (SEL *)ERROR_PTR(\"sel not made\", procName, NULL);\n    }\n    selSetOrigin(sel, cy, cx);\n    for (i = 0; i < sy; i++) {\n        ignore = fscanf(fp, \"    \");\n        for (j = 0; j < sx; j++)\n            ignore = fscanf(fp, \"%1d\", &sel->data[i][j]);\n        ignore = fscanf(fp, \"\\n\");\n    }\n    ignore = fscanf(fp, \"\\n\");\n    LEPT_FREE(selname);\n    return sel;\n}", "target": 1}
{"code": "DLLIMPORT int cfg_setint(cfg_t *cfg, const char *name, long int value)\n{\n\treturn cfg_setnint(cfg, name, value, 0);\n}", "target": 0}
{"code": "static int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\n{\n\tint ret;\n\tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_SET_REGS, PEGASUS_REQT_WRITE, 0,\n\t\t\t      indx, data, size, 100);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}", "target": 1}
{"code": "QSqlRecord QODBCDriver::record(const QString& tablename) const\n{\n    Q_D(const QODBCDriver);\n    QSqlRecord fil;\n    if (!isOpen())\n        return fil;\n    SQLHANDLE hStmt;\n    QString catalog, schema, table;\n    const_cast<QODBCDriverPrivate*>(d)->splitTableQualifier(tablename, catalog, schema, table);\n    if (isIdentifierEscaped(catalog, QSqlDriver::TableName))\n        catalog = stripDelimiters(catalog, QSqlDriver::TableName);\n    else\n        catalog = d->adjustCase(catalog);\n    if (isIdentifierEscaped(schema, QSqlDriver::TableName))\n        schema = stripDelimiters(schema, QSqlDriver::TableName);\n    else\n        schema = d->adjustCase(schema);\n    if (isIdentifierEscaped(table, QSqlDriver::TableName))\n        table = stripDelimiters(table, QSqlDriver::TableName);\n    else\n        table = d->adjustCase(table);\n    SQLRETURN r = SQLAllocHandle(SQL_HANDLE_STMT,\n                                  d->hDbc,\n                                  &hStmt);\n    if (r != SQL_SUCCESS) {\n        qSqlWarning(\"QODBCDriver::record: Unable to allocate handle\"_L1, d);\n        return fil;\n    }\n    r = SQLSetStmtAttr(hStmt,\n                        SQL_ATTR_CURSOR_TYPE,\n                        (SQLPOINTER)SQL_CURSOR_FORWARD_ONLY,\n                        SQL_IS_UINTEGER);\n    r =  SQLColumns(hStmt,\n                     catalog.length() == 0 ? NULL : toSQLTCHAR(catalog).data(),\n                     catalog.length(),\n                     schema.length() == 0 ? NULL : toSQLTCHAR(schema).data(),\n                     schema.length(),\n                     toSQLTCHAR(table).data(),\n                     table.length(),\n                     NULL,\n                     0);\n    if (r != SQL_SUCCESS)\n        qSqlWarning(\"QODBCDriver::record: Unable to execute column list\"_L1, d);\n    if (d->hasSQLFetchScroll)\n        r = SQLFetchScroll(hStmt,\n                           SQL_FETCH_NEXT,\n                           0);\n    else\n        r = SQLFetch(hStmt);\n    while (r == SQL_SUCCESS) {\n        fil.append(qMakeFieldInfo(hStmt, d));\n        if (d->hasSQLFetchScroll)\n            r = SQLFetchScroll(hStmt,\n                               SQL_FETCH_NEXT,\n                               0);\n        else\n            r = SQLFetch(hStmt);\n    }\n    r = SQLFreeHandle(SQL_HANDLE_STMT, hStmt);\n    if (r!= SQL_SUCCESS)\n        qSqlWarning(\"QODBCDriver: Unable to free statement handle \"_L1 + QString::number(r), d);\n    return fil;\n}", "target": 1}
{"code": "void crypto_bignum_free(struct bignum *s)\n{\n\tmbedtls_mpi_free((mbedtls_mpi *)s);\n\tfree(s);\n}", "target": 1}
{"code": "TEST(ModMatchExpression, MatchesScalar) {\n    ModMatchExpression mod(\"a\", 5, 2);\n    ASSERT(mod.matchesBSON(BSON(\"a\" << 7.0), NULL));\n    ASSERT(!mod.matchesBSON(BSON(\"a\" << 4), NULL));\n}", "target": 0}
{"code": "ciEnv::~ciEnv() {\n  CompilerThread* current_thread = CompilerThread::current();\n  _factory->remove_symbols();\n  GUARDED_VM_ENTRY(current_thread->set_env(NULL);)\n}", "target": 0}
{"code": "Suite *cjose_jwe_suite()\n{\n    Suite *suite = suite_create(\"jwe\");\n    TCase *tc_jwe = tcase_create(\"core\");\n    tcase_set_timeout(tc_jwe, 120.0);\n    tcase_add_test(tc_jwe, test_cjose_jwe_node_jose_encrypt_self_decrypt);\n    tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt);\n    tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt_iv);\n    tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt_short);\n    tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt_empty);\n    tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt_large);\n    tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt_many);\n    tcase_add_test(tc_jwe, test_cjose_jwe_decrypt_aes);\n    tcase_add_test(tc_jwe, test_cjose_jwe_decrypt_aes_gcm);\n    tcase_add_test(tc_jwe, test_cjose_jwe_decrypt_rsa);\n    tcase_add_test(tc_jwe, test_cjose_jwe_encrypt_with_bad_header);\n    tcase_add_test(tc_jwe, test_cjose_jwe_encrypt_with_bad_key);\n    tcase_add_test(tc_jwe, test_cjose_jwe_encrypt_with_bad_content);\n    tcase_add_test(tc_jwe, test_cjose_jwe_import_export_compare);\n    tcase_add_test(tc_jwe, test_cjose_jwe_import_invalid_serialization);\n    tcase_add_test(tc_jwe, test_cjose_jwe_decrypt_bad_params);\n    tcase_add_test(tc_jwe, test_cjose_jwe_multiple_recipients);\n    suite_add_tcase(suite, tc_jwe);\n    return suite;\n}", "target": 0}
{"code": "BGD_DECLARE(void) gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n{\n\tgdImagePtr pim = 0, tim = im;\n\tint interlace, BitsPerPixel;\n\tinterlace = im->interlace;\n\tif(im->trueColor) {\n\t\tpim = gdImageCreatePaletteFromTrueColor(im, 1, 256);\n\t\tif(!pim) {\n\t\t\treturn;\n\t\t}\n\t\ttim = pim;\n\t}\n\tBitsPerPixel = colorstobpp(tim->colorsTotal);\n\tGIFEncode(\n\t    out, tim->sx, tim->sy, interlace, 0, tim->transparent, BitsPerPixel,\n\t    tim->red, tim->green, tim->blue, tim);\n\tif(pim) {\n\t\tgdImageDestroy(\tpim);\n\t}\n}", "target": 1}
{"code": "static int match_func(struct libmnt_fs *fs,\n\t\t      void *data __attribute__ ((__unused__)))\n{\n\tint rc = flags & FL_INVERT ? 1 : 0;\n\tconst char *m;\n\tvoid *md;\n\tm = get_match(COL_FSTYPE);\n\tif (m && !mnt_fs_match_fstype(fs, m))\n\t\treturn rc;\n\tm = get_match(COL_OPTIONS);\n\tif (m && !mnt_fs_match_options(fs, m))\n\t\treturn rc;\n\tmd = get_match_data(COL_MAJMIN);\n\tif (md && mnt_fs_get_devno(fs) != *((dev_t *) md))\n\t\treturn rc;\n\tm = get_match(COL_TARGET);\n\tif (m && !mnt_fs_match_target(fs, m, cache))\n\t\treturn rc;\n\tm = get_match(COL_SOURCE);\n\tif (m && !mnt_fs_match_source(fs, m, cache))\n\t\treturn rc;\n\tif ((flags & FL_DF) && !(flags & FL_ALL)) {\n\t\tconst char *type = mnt_fs_get_fstype(fs);\n\t\tif (type && strstr(type, \"tmpfs\"))\t\n\t\t\treturn !rc;\n\t\tif (mnt_fs_is_pseudofs(fs))\n\t\t\treturn rc;\n\t}\n\tif ((flags & FL_REAL) && mnt_fs_is_pseudofs(fs))\n\t    return rc;\n\tif ((flags & FL_PSEUDO) && !mnt_fs_is_pseudofs(fs))\n\t    return rc;\n\tif ((flags & FL_SHADOWED)) {\n\t\tstruct libmnt_table *tb = NULL;\n\t\tmnt_fs_get_table(fs, &tb);\n\t\tif (tb && mnt_table_over_fs(tb, fs, NULL) != 0)\n\t\t\treturn rc;\n\t}\n\tif ((flags & FL_DELETED) && !mnt_fs_is_deleted(fs))\n\t\treturn rc;\n\treturn !rc;\n}", "target": 1}
{"code": "static INLINE BOOL update_write_brush(wStream* s, rdpBrush* brush, BYTE fieldFlags)\n{\n\tif (fieldFlags & ORDER_FIELD_01)\n\t{\n\t\tStream_Write_UINT8(s, brush->x);\n\t}\n\tif (fieldFlags & ORDER_FIELD_02)\n\t{\n\t\tStream_Write_UINT8(s, brush->y);\n\t}\n\tif (fieldFlags & ORDER_FIELD_03)\n\t{\n\t\tStream_Write_UINT8(s, brush->style);\n\t}\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tbrush->hatch = brush->index;\n\t\tbrush->bpp = BMF_BPP[brush->style & 0x07];\n\t\tif (brush->bpp == 0)\n\t\t\tbrush->bpp = 1;\n\t}\n\tif (fieldFlags & ORDER_FIELD_04)\n\t{\n\t\tStream_Write_UINT8(s, brush->hatch);\n\t}\n\tif (fieldFlags & ORDER_FIELD_05)\n\t{\n\t\tbrush->data = (BYTE*)brush->p8x8;\n\t\tStream_Write_UINT8(s, brush->data[7]);\n\t\tStream_Write_UINT8(s, brush->data[6]);\n\t\tStream_Write_UINT8(s, brush->data[5]);\n\t\tStream_Write_UINT8(s, brush->data[4]);\n\t\tStream_Write_UINT8(s, brush->data[3]);\n\t\tStream_Write_UINT8(s, brush->data[2]);\n\t\tStream_Write_UINT8(s, brush->data[1]);\n\t\tbrush->data[0] = brush->hatch;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "static int logi_dj_recv_switch_to_dj_mode(struct dj_receiver_dev *djrcv_dev,\n\t\t\t\t\t  unsigned timeout)\n{\n\tstruct dj_report *dj_report;\n\tint retval;\n\tdj_report = kzalloc(sizeof(struct dj_report), GFP_KERNEL);\n\tif (!dj_report)\n\t\treturn -ENOMEM;\n\tdj_report->report_id = REPORT_ID_DJ_SHORT;\n\tdj_report->device_index = 0xFF;\n\tdj_report->report_type = REPORT_TYPE_CMD_SWITCH;\n\tdj_report->report_params[CMD_SWITCH_PARAM_DEVBITFIELD] = 0x3F;\n\tdj_report->report_params[CMD_SWITCH_PARAM_TIMEOUT_SECONDS] = (u8)timeout;\n\tretval = logi_dj_recv_send_report(djrcv_dev, dj_report);\n\tkfree(dj_report);\n\tmsleep(50);\n\treturn retval;\n}", "target": 0}
{"code": "static int __init memory_tier_init(void)\n{\n\tint ret, node;\n\tstruct memory_tier *memtier;\n\tret = subsys_virtual_register(&memory_tier_subsys, NULL);\n\tif (ret)\n\t\tpanic(\"%s() failed to register memory tier subsystem\\n\", __func__);\n#ifdef CONFIG_MIGRATION\n\tnode_demotion = kcalloc(nr_node_ids, sizeof(struct demotion_nodes),\n\t\t\t\tGFP_KERNEL);\n\tWARN_ON(!node_demotion);\n#endif\n\tmutex_lock(&memory_tier_lock);\n\tdefault_dram_type = alloc_memory_type(MEMTIER_ADISTANCE_DRAM);\n\tif (!default_dram_type)\n\t\tpanic(\"%s() failed to allocate default DRAM tier\\n\", __func__);\n\tfor_each_node_state(node, N_MEMORY) {\n\t\tmemtier = set_node_memory_tier(node);\n\t\tif (IS_ERR(memtier))\n\t\t\tbreak;\n\t}\n\testablish_demotion_targets();\n\tmutex_unlock(&memory_tier_lock);\n\thotplug_memory_notifier(memtier_hotplug_callback, MEMTIER_HOTPLUG_PRI);\n\treturn 0;\n}", "target": 1}
{"code": "static int nfs4_map_errors(int err)\n{\n\tif (err >= -1000)\n\t\treturn err;\n\tswitch (err) {\n\tcase -NFS4ERR_RESOURCE:\n\t\treturn -EREMOTEIO;\n\tcase -NFS4ERR_WRONGSEC:\n\t\treturn -EPERM;\n\tcase -NFS4ERR_BADOWNER:\n\tcase -NFS4ERR_BADNAME:\n\t\treturn -EINVAL;\n\tcase -NFS4ERR_SHARE_DENIED:\n\t\treturn -EACCES;\n\tcase -NFS4ERR_MINOR_VERS_MISMATCH:\n\t\treturn -EPROTONOSUPPORT;\n\tdefault:\n\t\tdprintk(\"%s could not handle NFSv4 error %d\\n\",\n\t\t\t\t__func__, -err);\n\t\tbreak;\n\t}\n\treturn -EIO;\n}", "target": 0}
{"code": "void PasswordAutofillAgent::AJAXSucceeded() {\n  OnSamePageNavigationCompleted();\n}", "target": 0}
{"code": "bool CSecurityTLS::processMsg(CConnection* cc)\n{\n  rdr::InStream* is = cc->getInStream();\n  rdr::OutStream* os = cc->getOutStream();\n  client = cc;\n  initGlobal();\n  if (!session) {\n    if (!is->checkNoWait(1))\n      return false;\n    if (is->readU8() == 0) {\n      rdr::U32 result = is->readU32();\n      CharArray reason;\n      if (result == secResultFailed || result == secResultTooMany)\n        reason.buf = is->readString();\n      else\n        reason.buf = strDup(\"Authentication failure (protocol error)\");\n      throw AuthFailureException(reason.buf);\n    }\n    if (gnutls_init(&session, GNUTLS_CLIENT) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_init failed\");\n    if (gnutls_set_default_priority(session) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_set_default_priority failed\");\n    setParam();\n  }\n  rdr::TLSInStream *tlsis = new rdr::TLSInStream(is, session);\n  rdr::TLSOutStream *tlsos = new rdr::TLSOutStream(os, session);\n  int err;\n  err = gnutls_handshake(session);\n  if (err != GNUTLS_E_SUCCESS) {\n    delete tlsis;\n    delete tlsos;\n    if (!gnutls_error_is_fatal(err))\n      return false;\n    vlog.error(\"TLS Handshake failed: %s\\n\", gnutls_strerror (err));\n    shutdown(false);\n    throw AuthFailureException(\"TLS Handshake failed\");\n  }\n  checkSession();\n  cc->setStreams(fis = tlsis, fos = tlsos);\n  return true;\n}", "target": 1}
{"code": "char *gf_bt_get_next(GF_BTParser *parser, Bool point_break)\n{\n\tu32 has_quote;\n\tBool go = 1;\n\ts32 i;\n\tgf_bt_check_line(parser);\n\ti=0;\n\thas_quote = 0;\n\twhile (go) {\n\t\tif (parser->line_buffer[parser->line_pos + i] == '\\\"') {\n\t\t\tif (!has_quote) has_quote = 1;\n\t\t\telse has_quote = 0;\n\t\t\tparser->line_pos += 1;\n\t\t\tif (parser->line_pos+i==parser->line_size) break;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!has_quote) {\n\t\t\tswitch (parser->line_buffer[parser->line_pos + i]) {\n\t\t\tcase 0:\n\t\t\tcase ' ':\n\t\t\tcase '\\t':\n\t\t\tcase '\\r':\n\t\t\tcase '\\n':\n\t\t\tcase '{':\n\t\t\tcase '}':\n\t\t\tcase ']':\n\t\t\tcase '[':\n\t\t\tcase ',':\n\t\t\t\tgo = 0;\n\t\t\t\tbreak;\n\t\t\tcase '.':\n\t\t\t\tif (point_break) go = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!go) break;\n\t\t}\n\t\tparser->cur_buffer[i] = parser->line_buffer[parser->line_pos + i];\n\t\ti++;\n\t\tif (parser->line_pos+i==parser->line_size) break;\n\t}\n\tparser->cur_buffer[i] = 0;\n\tparser->line_pos += i;\n\treturn parser->cur_buffer;\n}", "target": 1}
{"code": "void NotificationService::AddObserver(NotificationObserver* observer,\n                                      NotificationType type,\n                                      const NotificationSource& source) {\n  DCHECK(type.value < NotificationType::NOTIFICATION_TYPE_COUNT);\n  CHECK(observer);\n  NotificationObserverList* observer_list;\n  if (HasKey(observers_[type.value], source)) {\n    observer_list = observers_[type.value][source.map_key()];\n  } else {\n    observer_list = new NotificationObserverList;\n    observers_[type.value][source.map_key()] = observer_list;\n  }\n  observer_list->AddObserver(observer);\n#ifndef NDEBUG\n  ++observer_counts_[type.value];\n#endif\n}", "target": 0}
{"code": "static void ep_nested_calls_init(struct nested_calls *ncalls)\n{\n\tINIT_LIST_HEAD(&ncalls->tasks_call_list);\n\tspin_lock_init(&ncalls->lock);\n}", "target": 0}
{"code": "static void bt_tags_for_each(struct blk_mq_tags *tags,\n\t\tstruct blk_mq_bitmap_tags *bt, unsigned int off,\n\t\tbusy_tag_iter_fn *fn, void *data, bool reserved)\n{\n\tstruct request *rq;\n\tint bit, i;\n\tif (!tags->rqs)\n\t\treturn;\n\tfor (i = 0; i < bt->map_nr; i++) {\n\t\tstruct blk_align_bitmap *bm = &bt->map[i];\n\t\tfor (bit = find_first_bit(&bm->word, bm->depth);\n\t\t     bit < bm->depth;\n\t\t     bit = find_next_bit(&bm->word, bm->depth, bit + 1)) {\n\t\t\trq = blk_mq_tag_to_rq(tags, off + bit);\n\t\t\tfn(rq, data, reserved);\n\t\t}\n\t\toff += (1 << bt->bits_per_word);\n\t}\n}", "target": 1}
{"code": "static int stellaris_enet_init(SysBusDevice *sbd)\n{\n    DeviceState *dev = DEVICE(sbd);\n    stellaris_enet_state *s = STELLARIS_ENET(dev);\n    memory_region_init_io(&s->mmio, OBJECT(s), &stellaris_enet_ops, s,\n                          \"stellaris_enet\", 0x1000);\n    sysbus_init_mmio(sbd, &s->mmio);\n    sysbus_init_irq(sbd, &s->irq);\n    qemu_macaddr_default_if_unset(&s->conf.macaddr);\n    s->nic = qemu_new_nic(&net_stellaris_enet_info, &s->conf,\n                          object_get_typename(OBJECT(dev)), dev->id, s);\n    qemu_format_nic_info_str(qemu_get_queue(s->nic), s->conf.macaddr.a);\n    stellaris_enet_reset(s);\n    register_savevm(dev, \"stellaris_enet\", -1, 1,\n                    stellaris_enet_save, stellaris_enet_load, s);\n    return 0;\n}", "target": 1}
{"code": "new_fixup(struct archive_write_disk *a, const char *pathname)\n{\n\tstruct fixup_entry *fe;\n\tfe = (struct fixup_entry *)calloc(1, sizeof(struct fixup_entry));\n\tif (fe == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Can't allocate memory for a fixup\");\n\t\treturn (NULL);\n\t}\n\tfe->next = a->fixup_list;\n\ta->fixup_list = fe;\n\tfe->fixup = 0;\n\tfe->mode = 0;\n\tfe->name = strdup(pathname);\n\treturn (fe);\n}", "target": 0}
{"code": "int main(int argc, char *argv[])\n{\n\tint ret;\n\tstruct lxc_lock *lock;\n\tlock = lxc_newlock(NULL, NULL);\n\tif (!lock) {\n\t\tfprintf(stderr, \"%d: failed to get unnamed lock\\n\", __LINE__);\n\t\texit(1);\n\t}\n\tret = lxclock(lock, 0);\n\tif (ret) {\n\t\tfprintf(stderr, \"%d: failed to take unnamed lock (%d)\\n\", __LINE__, ret);\n\t\texit(1);\n\t}\n\tret = lxcunlock(lock);\n\tif (ret) {\n\t\tfprintf(stderr, \"%d: failed to put unnamed lock (%d)\\n\", __LINE__, ret);\n\t\texit(1);\n\t}\n\tlxc_putlock(lock);\n\tlock = lxc_newlock(\"/var/lib/lxc\", mycontainername);\n\tif (!lock) {\n\t\tfprintf(stderr, \"%d: failed to get lock\\n\", __LINE__);\n\t\texit(1);\n\t}\n\tstruct stat sb;\n\tchar *pathname = RUNTIME_PATH \"/lock/lxc/var/lib/lxc/\";\n\tret = stat(pathname, &sb);\n\tif (ret != 0) {\n\t\tfprintf(stderr, \"%d: filename %s not created\\n\", __LINE__,\n\t\t\tpathname);\n\t\texit(1);\n\t}\n\tlxc_putlock(lock);\n\ttest_two_locks();\n\tfprintf(stderr, \"all tests passed\\n\");\n\texit(ret);\n}", "target": 1}
{"code": "char *QuotedString::extractFrom(char *input, char **endPtr) {\n  char firstChar = *input;\n  if (!isQuote(firstChar)) {\n    return NULL;\n  }\n  char stopChar = firstChar;  \n  char *startPtr = input + 1;  \n  char *readPtr = startPtr;\n  char *writePtr = startPtr;\n  char c;\n  for (;;) {\n    c = *readPtr++;\n    if (c == '\\0') {\n      return NULL;\n    }\n    if (c == stopChar) {\n      break;\n    }\n    if (c == '\\\\') {\n      c = unescapeChar(*readPtr++);\n    }\n    *writePtr++ = c;\n  }\n  *writePtr = '\\0';\n  *endPtr = readPtr;\n  return startPtr;\n}", "target": 1}
{"code": "Eina_Bool ewk_view_editable_set(Evas_Object* ewkView, Eina_Bool editable)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    return ewk_frame_editable_set(smartData->main_frame, editable);\n}", "target": 0}
{"code": "static void vnc_refresh(DisplayChangeListener *dcl)\n{\n    VncDisplay *vd = container_of(dcl, VncDisplay, dcl);\n    VncState *vs, *vn;\n    int has_dirty, rects = 0;\n    if (QTAILQ_EMPTY(&vd->clients)) {\n        update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_MAX);\n        return;\n    }\n    graphic_hw_update(vd->dcl.con);\n    if (vnc_trylock_display(vd)) {\n        update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);\n        return;\n    }\n    has_dirty = vnc_refresh_server_surface(vd);\n    vnc_unlock_display(vd);\n    QTAILQ_FOREACH_SAFE(vs, &vd->clients, next, vn) {\n        rects += vnc_update_client(vs, has_dirty, false);\n    }\n    if (has_dirty && rects) {\n        vd->dcl.update_interval /= 2;\n        if (vd->dcl.update_interval < VNC_REFRESH_INTERVAL_BASE) {\n            vd->dcl.update_interval = VNC_REFRESH_INTERVAL_BASE;\n        }\n    } else {\n        vd->dcl.update_interval += VNC_REFRESH_INTERVAL_INC;\n        if (vd->dcl.update_interval > VNC_REFRESH_INTERVAL_MAX) {\n            vd->dcl.update_interval = VNC_REFRESH_INTERVAL_MAX;\n        }\n    }\n}", "target": 0}
{"code": "explain_slow_path(enum slow_path_reason slow, struct ds *output)\n{\n    ds_put_cstr(output, \"\\nThis flow is handled by the userspace \"\n                \"slow path because it:\");\n    for (; slow; slow = zero_rightmost_1bit(slow)) {\n        enum slow_path_reason bit = rightmost_1bit(slow);\n        ds_put_format(output, \"\\n  - %s.\",\n                      slow_path_reason_to_explanation(bit));\n    }\n}", "target": 0}
{"code": "vq_is_ready(struct vhost_virtqueue *vq)\n{\n\treturn vq && vq->desc && vq->avail && vq->used &&\n\t       vq->kickfd != VIRTIO_UNINITIALIZED_EVENTFD &&\n\t       vq->callfd != VIRTIO_UNINITIALIZED_EVENTFD;\n}", "target": 0}
{"code": "gen_values(codegen_scope *s, node *t, int val, int limit)\n{\n  int n = 0;\n  int first = 1;\n  int slimit = GEN_VAL_STACK_MAX;\n  if (limit == 0) limit = GEN_LIT_ARY_MAX;\n  if (cursp() >= slimit) slimit = INT16_MAX;\n  if (!val) {\n    while (t) {\n      codegen(s, t->car, NOVAL);\n      n++;\n      t = t->cdr;\n    }\n    return n;\n  }\n  while (t) {\n    int is_splat = nint(t->car->car) == NODE_SPLAT;\n    if (is_splat || n > limit || cursp() >= slimit) { \n      pop_n(n);\n      if (first) {\n        if (n == 0) {\n          genop_1(s, OP_LOADNIL, cursp());\n        }\n        else {\n          genop_2(s, OP_ARRAY, cursp(), n);\n        }\n        push();\n        first = 0;\n        limit = GEN_LIT_ARY_MAX;\n      }\n      else if (n > 0) {\n        pop();\n        genop_2(s, OP_ARYPUSH, cursp(), n);\n        push();\n      }\n      n = 0;\n    }\n    codegen(s, t->car, val);\n    if (is_splat) {\n      pop(); pop();\n      genop_1(s, OP_ARYCAT, cursp());\n      push();\n    }\n    else {\n      n++;\n    }\n    t = t->cdr;\n  }\n  if (!first) {\n    pop();\n    if (n > 0) {\n      pop_n(n);\n      genop_2(s, OP_ARYPUSH, cursp(), n);\n    }\n    return -1;                  \n  }\n  return n;\n}", "target": 1}
{"code": "ssize_t uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n  const char* si;\n  const char* st;\n  unsigned c;\n  char* ds;\n  int rc;\n  ds = d;\n  si = s;\n  while (si < se) {\n    st = si;\n    c = uv__utf8_decode1(&si, se);\n    if (c == UINT_MAX)\n      return UV_EINVAL;\n    if (c != '.')\n      if (c != 0x3002)  \n        if (c != 0xFF0E)  \n          if (c != 0xFF61)  \n            continue;\n    rc = uv__idna_toascii_label(s, st, &d, de);\n    if (rc < 0)\n      return rc;\n    if (d < de)\n      *d++ = '.';\n    s = si;\n  }\n  if (s < se) {\n    rc = uv__idna_toascii_label(s, se, &d, de);\n    if (rc < 0)\n      return rc;\n  }\n  if (d < de)\n    *d++ = '\\0';\n  return d - ds;  \n}", "target": 1}
{"code": "int ip_options_get_from_user(struct net *net, struct ip_options **optp,\n\t\t\t     unsigned char __user *data, int optlen)\n{\n\tstruct ip_options *opt = ip_options_get_alloc(optlen);\n\tif (!opt)\n\t\treturn -ENOMEM;\n\tif (optlen && copy_from_user(opt->__data, data, optlen)) {\n\t\tkfree(opt);\n\t\treturn -EFAULT;\n\t}\n\treturn ip_options_get_finish(net, optp, opt, optlen);\n}", "target": 1}
{"code": "xfs_acl_from_disk(struct xfs_acl *aclp)\n{\n\tstruct posix_acl_entry *acl_e;\n\tstruct posix_acl *acl;\n\tstruct xfs_acl_entry *ace;\n\tunsigned int count, i;\n\tcount = be32_to_cpu(aclp->acl_cnt);\n\tif (count > XFS_ACL_MAX_ENTRIES)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\tacl = posix_acl_alloc(count, GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (i = 0; i < count; i++) {\n\t\tacl_e = &acl->a_entries[i];\n\t\tace = &aclp->acl_entry[i];\n\t\tacl_e->e_tag = be32_to_cpu(ace->ae_tag);\n\t\tacl_e->e_perm = be16_to_cpu(ace->ae_perm);\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\tcase ACL_GROUP:\n\t\t\tacl_e->e_id = be32_to_cpu(ace->ae_id);\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tacl_e->e_id = ACL_UNDEFINED_ID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}", "target": 0}
{"code": "smb2_parse_lease_state(struct TCP_Server_Info *server,\n\t\t       struct smb2_create_rsp *rsp,\n\t\t       unsigned int *epoch, char *lease_key)\n{\n\tchar *data_offset;\n\tstruct create_context *cc;\n\tunsigned int next;\n\tunsigned int remaining;\n\tchar *name;\n\tdata_offset = (char *)rsp + le32_to_cpu(rsp->CreateContextsOffset);\n\tremaining = le32_to_cpu(rsp->CreateContextsLength);\n\tcc = (struct create_context *)data_offset;\n\twhile (remaining >= sizeof(struct create_context)) {\n\t\tname = le16_to_cpu(cc->NameOffset) + (char *)cc;\n\t\tif (le16_to_cpu(cc->NameLength) == 4 &&\n\t\t    strncmp(name, \"RqLs\", 4) == 0)\n\t\t\treturn server->ops->parse_lease_buf(cc, epoch,\n\t\t\t\t\t\t\t    lease_key);\n\t\tnext = le32_to_cpu(cc->Next);\n\t\tif (!next)\n\t\t\tbreak;\n\t\tremaining -= next;\n\t\tcc = (struct create_context *)((char *)cc + next);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "int nfc_genl_fw_download_done(struct nfc_dev *dev, const char *firmware_name,\n\t\t\t      u32 result)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_CMD_FW_DOWNLOAD);\n\tif (!hdr)\n\t\tgoto free_msg;\n\tif (nla_put_string(msg, NFC_ATTR_FIRMWARE_NAME, firmware_name) ||\n\t    nla_put_u32(msg, NFC_ATTR_FIRMWARE_DOWNLOAD_STATUS, result) ||\n\t    nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\tgenlmsg_end(msg, hdr);\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\treturn 0;\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "static int crypto_rng_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_rng *rng = __crypto_rng_cast(tfm);\n\tstruct rng_alg *alg = crypto_rng_alg(rng);\n\tstruct old_rng_alg *oalg = crypto_old_rng_alg(rng);\n\tif (oalg->rng_make_random) {\n\t\trng->generate = generate;\n\t\trng->seed = rngapi_reset;\n\t\trng->seedsize = oalg->seedsize;\n\t\treturn 0;\n\t}\n\trng->generate = alg->generate;\n\trng->seed = alg->seed;\n\trng->seedsize = alg->seedsize;\n\treturn 0;\n}", "target": 1}
{"code": "fiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mrb_bool resume, mrb_bool vmexec)\n{\n  struct mrb_context *c = fiber_check(mrb, self);\n  struct mrb_context *old_c = mrb->c;\n  enum mrb_fiber_state status;\n  mrb_value value;\n  fiber_check_cfunc(mrb, c);\n  status = c->status;\n  switch (status) {\n  case MRB_FIBER_TRANSFERRED:\n    if (resume) {\n      mrb_raise(mrb, E_FIBER_ERROR, \"resuming transferred fiber\");\n    }\n    break;\n  case MRB_FIBER_RUNNING:\n  case MRB_FIBER_RESUMED:\n    mrb_raise(mrb, E_FIBER_ERROR, \"double resume\");\n    break;\n  case MRB_FIBER_TERMINATED:\n    mrb_raise(mrb, E_FIBER_ERROR, \"resuming dead fiber\");\n    break;\n  default:\n    break;\n  }\n  old_c->status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED;\n  c->prev = resume ? mrb->c : (c->prev ? c->prev : mrb->root_c);\n  fiber_switch_context(mrb, c);\n  if (status == MRB_FIBER_CREATED) {\n    mrb_value *b, *e;\n    if (!c->ci->proc) {\n      mrb_raise(mrb, E_FIBER_ERROR, \"double resume (current)\");\n    }\n    mrb_stack_extend(mrb, len+2); \n    b = c->stbase+1;\n    e = b + len;\n    while (b<e) {\n      *b++ = *a++;\n    }\n    if (vmexec) {\n      c->ci--;                    \n    }\n    c->cibase->n = len;\n    value = c->stbase[0] = MRB_PROC_ENV(c->cibase->proc)->stack[0];\n  }\n  else {\n    value = fiber_result(mrb, a, len);\n    if (vmexec) {\n      c->ci[1].stack[0] = value;\n    }\n  }\n  if (vmexec) {\n    c->vmexec = TRUE;\n    value = mrb_vm_exec(mrb, c->ci->proc, c->ci->pc);\n    mrb->c = old_c;\n  }\n  else {\n    MARK_CONTEXT_MODIFY(c);\n  }\n  return value;\n}", "target": 1}
{"code": "int imap_subscribe(char *path, bool subscribe)\n{\n  struct ImapData *idata = NULL;\n  char buf[LONG_STRING];\n  char mbox[LONG_STRING];\n  char errstr[STRING];\n  struct Buffer err, token;\n  struct ImapMbox mx;\n  if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)\n  {\n    mutt_error(_(\"Bad mailbox name\"));\n    return -1;\n  }\n  idata = imap_conn_find(&(mx.account), 0);\n  if (!idata)\n    goto fail;\n  imap_fix_path(idata, mx.mbox, buf, sizeof(buf));\n  if (!*buf)\n    mutt_str_strfcpy(buf, \"INBOX\", sizeof(buf));\n  if (ImapCheckSubscribed)\n  {\n    mutt_buffer_init(&token);\n    mutt_buffer_init(&err);\n    err.data = errstr;\n    err.dsize = sizeof(errstr);\n    snprintf(mbox, sizeof(mbox), \"%smailboxes \\\"%s\\\"\", subscribe ? \"\" : \"un\", path);\n    if (mutt_parse_rc_line(mbox, &token, &err))\n      mutt_debug(1, \"Error adding subscribed mailbox: %s\\n\", errstr);\n    FREE(&token.data);\n  }\n  if (subscribe)\n    mutt_message(_(\"Subscribing to %s...\"), buf);\n  else\n    mutt_message(_(\"Unsubscribing from %s...\"), buf);\n  imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);\n  snprintf(buf, sizeof(buf), \"%sSUBSCRIBE %s\", subscribe ? \"\" : \"UN\", mbox);\n  if (imap_exec(idata, buf, 0) < 0)\n    goto fail;\n  imap_unmunge_mbox_name(idata, mx.mbox);\n  if (subscribe)\n    mutt_message(_(\"Subscribed to %s\"), mx.mbox);\n  else\n    mutt_message(_(\"Unsubscribed from %s\"), mx.mbox);\n  FREE(&mx.mbox);\n  return 0;\nfail:\n  FREE(&mx.mbox);\n  return -1;\n}", "target": 1}
{"code": "static int dns_stream_complete(DnsStream *s, int error) {\n        _cleanup_(dns_stream_unrefp) _unused_ DnsStream *ref = dns_stream_ref(s); \n        assert(s);\n#if ENABLE_DNS_OVER_TLS\n        if (s->encrypted) {\n                int r;\n                r = dnstls_stream_shutdown(s, error);\n                if (r != -EAGAIN)\n                        dns_stream_stop(s);\n        } else\n#endif\n                dns_stream_stop(s);\n        if (s->complete)\n                s->complete(s, error);\n        else \n                dns_stream_unref(s);\n        return 0;\n}", "target": 0}
{"code": "static int slim_rx_mux_get(struct snd_kcontrol *kc,\n\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kc);\n\tstruct wcd9335_codec *wcd = dev_get_drvdata(dapm->dev);\n\tucontrol->value.enumerated.item[0] = wcd->rx_port_value;\n\treturn 0;\n}", "target": 0}
{"code": "void ntlm_print_message_fields(NTLM_MESSAGE_FIELDS* fields, const char* name)\n{\n\tWLog_DBG(TAG, \"%s (Len: %\"PRIu16\" MaxLen: %\"PRIu16\" BufferOffset: %\"PRIu32\")\",\n\t         name, fields->Len, fields->MaxLen, fields->BufferOffset);\n\tif (fields->Len > 0)\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, fields->Buffer, fields->Len);\n}", "target": 1}
{"code": "BGD_DECLARE(gdImagePtr) gdImageCreateFromTgaCtx(gdIOCtx* ctx)\n{\n\tint bitmap_caret = 0;\n\toTga *tga = NULL;\n\tvolatile gdImagePtr image = NULL;\n\tint x = 0;\n\tint y = 0;\n\ttga = (oTga *) gdMalloc(sizeof(oTga));\n\tif (!tga) {\n\t\treturn NULL;\n\t}\n\ttga->bitmap = NULL;\n\ttga->ident = NULL;\n\tif (read_header_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\tif (read_image_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\timage = gdImageCreateTrueColor((int)tga->width, (int)tga->height );\n\tif (image == 0) {\n\t\tfree_tga( tga );\n\t\treturn NULL;\n\t}\n\tif (tga->alphabits) {\n\t\tgdImageAlphaBlending(image, 0);\n\t\tgdImageSaveAlpha(image, 1);\n\t}\n\tfor (y = 0; y < tga->height; y++) {\n\t\tregister int *tpix = image->tpixels[y];\n\t\tfor ( x = 0; x < tga->width; x++, tpix++) {\n\t\t\tif (tga->bits == TGA_BPP_24) {\n\t\t\t\t*tpix = gdTrueColor(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret]);\n\t\t\t\tbitmap_caret += 3;\n\t\t\t} else if (tga->bits == TGA_BPP_32 || tga->alphabits) {\n\t\t\t\tregister int a = tga->bitmap[bitmap_caret + 3];\n\t\t\t\t*tpix = gdTrueColorAlpha(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret], gdAlphaMax - (a >> 1));\n\t\t\t\tbitmap_caret += 4;\n\t\t\t}\n\t\t}\n\t}\n\tif (tga->flipv && tga->fliph) {\n\t\tgdImageFlipBoth(image);\n\t} else if (tga->flipv) {\n\t\tgdImageFlipVertical(image);\n\t} else if (tga->fliph) {\n\t\tgdImageFlipHorizontal(image);\n\t}\n\tfree_tga(tga);\n\treturn image;\n}", "target": 1}
{"code": "  AvgPoolGradOp(OpKernelConstruction* ctx, int num_spatial_dims)\n      : XlaOpKernel(ctx), num_spatial_dims_(num_spatial_dims) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"ksize\", &ksize_));\n    OP_REQUIRES(ctx, ksize_.size() == num_dims(),\n                errors::InvalidArgument(\"Sliding window ksize field must \"\n                                        \"specify \",\n                                        num_dims(), \" dimensions\"));\n    OP_REQUIRES_OK(ctx, ValidateKernelSizes(ksize_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"strides\", &stride_));\n    OP_REQUIRES(ctx, stride_.size() == num_dims(),\n                errors::InvalidArgument(\"Sliding window strides field must \"\n                                        \"specify \",\n                                        num_dims(), \" dimensions\"));\n    OP_REQUIRES_OK(ctx, ValidateStrides(stride_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"padding\", &padding_));\n    OP_REQUIRES(ctx, padding_ != EXPLICIT,\n                errors::Unimplemented(\n                    \"XLA does not support avgpoolgrad with explicit padding.\"));\n    OP_REQUIRES(ctx, ksize_[0] == 1 && stride_[0] == 1,\n                errors::Unimplemented(\n                    \"Pooling is not yet supported on the batch dimension.\"));\n    string data_format;\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"data_format\", &data_format));\n    OP_REQUIRES(ctx, FormatFromString(data_format, &data_format_),\n                errors::InvalidArgument(\"Invalid data format\"));\n  }", "target": 0}
{"code": "test_all_FFs_set_handler(void **state)\n{\n    (void) state;\n    Tss2_RC_SetHandler(0xFF, \"garbage\", custom_err_handler);\n    Tss2_RC_SetHandler(0xFF, NULL, NULL);\n}", "target": 0}
{"code": "int mesg_make_query (u_char *qname, uint16_t qtype, uint16_t qclass,\n\t\t     uint32_t id, int rd, u_char *buf, int buflen) {\n\tchar *fn = \"mesg_make_query()\";\n\tu_char *ucp;\n\tint i, written_len;\n\tMesg_Hdr *hdr;\n\tif (T.debug > 4)\n\t\tsyslog (LOG_DEBUG, \"%s: (qtype: %s, id: %d): start\", fn,\n\t\t\tstring_rtype (qtype), id);\n\thdr = (Mesg_Hdr *) buf;\n\thdr->id = id;\n\thdr->opcode = OP_QUERY;\n\thdr->rcode = RC_OK;\n\thdr->rd = rd;\n\thdr->qr = hdr->aa = hdr->tc = hdr->ra = hdr->zero = 0;\n\thdr->qdcnt = ntohs (1);\n\thdr->ancnt = hdr->nscnt = hdr->arcnt = ntohs (0);\n\twritten_len = sizeof (Mesg_Hdr);\n\tucp = (u_char *) (hdr + 1);\n\tif (T.debug > 4)\n\t\tsyslog (LOG_DEBUG, \"%s: qname offset = %zd\", fn, ucp - buf);\n\ti = dname_copy (qname, ucp, buflen - written_len);\n\tif (i < 0)\n\t\treturn -1;\n\twritten_len += i;\n\tucp += i;\n\tif (T.debug > 4)\n\t\tsyslog (LOG_DEBUG, \"%s: qtype/qclass offset = %zd\",\n\t\t\tfn, ucp - buf);\n\twritten_len += sizeof (uint16_t) * 2;\n\tif (written_len > buflen)\n\t\treturn -1;\n\tPUTSHORT (qtype, ucp);\n\tPUTSHORT (qclass, ucp);\n\treturn written_len;\n}", "target": 1}
{"code": "u64 secure_dccp_sequence_number(__be32 saddr, __be32 daddr,\n\t\t\t\t__be16 sport, __be16 dport)\n{\n\tu32 hash[MD5_DIGEST_WORDS];\n\tu64 seq;\n\thash[0] = (__force u32)saddr;\n\thash[1] = (__force u32)daddr;\n\thash[2] = ((__force u16)sport << 16) + (__force u16)dport;\n\thash[3] = net_secret[15];\n\tmd5_transform(hash, net_secret);\n\tseq = hash[0] | (((u64)hash[1]) << 32);\n\tseq += ktime_to_ns(ktime_get_real());\n\tseq &= (1ull << 48) - 1;\n\treturn seq;\n}", "target": 0}
{"code": "folly::Optional<ErrorCode> HTTP2Codec::parseHeadersDecodeFrames(\n    const folly::Optional<http2::PriorityUpdate>& priority,\n    const folly::Optional<uint32_t>& promisedStream,\n    const folly::Optional<ExAttributes>& exAttributes,\n    std::unique_ptr<HTTPMessage>& msg) {\n  Cursor headerCursor(curHeaderBlock_.front());\n  bool isReq = false;\n  if (promisedStream) {\n    isReq = true;\n  } else if (exAttributes) {\n    isReq = isRequest(curHeader_.stream);\n  } else {\n    isReq = transportDirection_ == TransportDirection::DOWNSTREAM;\n  }\n  decodeInfo_.init(isReq, parsingDownstreamTrailers_);\n  if (priority) {\n    if (curHeader_.stream == priority->streamDependency) {\n      streamError(folly::to<string>(\"Circular dependency for txn=\",\n                                    curHeader_.stream),\n                  ErrorCode::PROTOCOL_ERROR,\n                  curHeader_.type == http2::FrameType::HEADERS);\n      return ErrorCode::NO_ERROR;\n    }\n    decodeInfo_.msg->setHTTP2Priority(\n        std::make_tuple(priority->streamDependency,\n                        priority->exclusive,\n                        priority->weight));\n  }\n  headerCodec_.decodeStreaming(\n      headerCursor, curHeaderBlock_.chainLength(), this);\n  msg = std::move(decodeInfo_.msg);\n  auto g = folly::makeGuard([this] { curHeaderBlock_.move(); });\n  if (decodeInfo_.decodeError != HPACK::DecodeError::NONE) {\n    static const std::string decodeErrorMessage =\n        \"Failed decoding header block for stream=\";\n    if (decodeInfo_.decodeError != HPACK::DecodeError::HEADERS_TOO_LARGE) {\n      LOG(ERROR) << decodeErrorMessage << curHeader_.stream\n                 << \" header block=\";\n      VLOG(3) << IOBufPrinter::printHexFolly(curHeaderBlock_.front(), true);\n    } else {\n      LOG(ERROR) << decodeErrorMessage << curHeader_.stream;\n    }\n    if (msg) {\n      msg->dumpMessage(3);\n    }\n    return ErrorCode::COMPRESSION_ERROR;\n  }\n  if (decodeInfo_.parsingError != \"\") {\n    LOG(ERROR) << \"Failed parsing header list for stream=\" << curHeader_.stream\n               << \", error=\" << decodeInfo_.parsingError << \", header block=\";\n    VLOG(3) << IOBufPrinter::printHexFolly(curHeaderBlock_.front(), true);\n    HTTPException err(HTTPException::Direction::INGRESS,\n                      folly::to<std::string>(\"HTTP2Codec stream error: \",\n                                             \"stream=\",\n                                             curHeader_.stream,\n                                             \" status=\",\n                                             400,\n                                             \" error: \",\n                                             decodeInfo_.parsingError));\n    err.setHttpStatusCode(400);\n    callback_->onError(curHeader_.stream, err, true);\n    return ErrorCode::NO_ERROR;\n  }\n  return folly::Optional<ErrorCode>();\n}", "target": 1}
{"code": "static Jsi_RC SysGetEnvCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    extern char **environ;\n    char *cp;\n    int i;\n    if (interp->isSafe)\n        return Jsi_LogError(\"no getenv in safe mode\");\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    if (v != NULL) {\n        const char *fnam = Jsi_ValueString(interp, v, NULL);\n        if (!fnam) \n            return Jsi_LogError(\"arg1: expected string 'name'\");\n        cp = getenv(fnam);\n        if (cp != NULL) {\n            Jsi_ValueMakeStringDup(interp, ret, cp);\n        }\n        return JSI_OK;\n    }\n    Jsi_Value *vres;\n    Jsi_Obj  *ores = Jsi_ObjNew(interp);\n    Jsi_Value *nnv;\n    char *val, nam[200];\n    vres = Jsi_ValueMakeObject(interp, NULL, ores);\n    for (i=0; ; i++) {\n        int n;\n        cp = environ[i];\n        if (cp == 0 || ((val = Jsi_Strchr(cp, '='))==NULL))\n            break;\n        n = val-cp+1;\n        if (n>=(int)sizeof(nam))\n            n = sizeof(nam)-1;\n        Jsi_Strncpy(nam, cp, n);\n        val = val+1;\n        nnv = Jsi_ValueMakeStringDup(interp, NULL, val);\n        Jsi_ObjInsert(interp, ores, nam, nnv, 0);\n    }\n    Jsi_ValueReplace(interp, ret, vres);\n    return JSI_OK;\n}", "target": 1}
{"code": "static void cjson_get_object_item_case_sensitive_should_not_crash_with_array(void) {\n    cJSON *array = NULL;\n    cJSON *found = NULL;\n    array = cJSON_Parse(\"[1]\");\n    found = cJSON_GetObjectItemCaseSensitive(array, \"name\");\n    TEST_ASSERT_NULL(found);\n    cJSON_Delete(array);\n}", "target": 0}
{"code": "ConnectClientToUnixSock(const char *sockFile)\n{\n#ifdef WIN32\n  rfbClientErr(\"Windows doesn't support UNIX sockets\\n\");\n  return -1;\n#else\n  int sock;\n  struct sockaddr_un addr;\n  addr.sun_family = AF_UNIX;\n  if(strlen(sockFile) + 1 > sizeof(addr.sun_path)) {\n      rfbClientErr(\"ConnectToUnixSock: socket file name too long\\n\");\n      return -1;\n  }\n  strcpy(addr.sun_path, sockFile);\n  sock = socket(AF_UNIX, SOCK_STREAM, 0);\n  if (sock < 0) {\n    rfbClientErr(\"ConnectToUnixSock: socket (%s)\\n\",strerror(errno));\n    return -1;\n  }\n  if (connect(sock, (struct sockaddr *)&addr, sizeof(addr.sun_family) + strlen(addr.sun_path)) < 0) {\n    rfbClientErr(\"ConnectToUnixSock: connect\\n\");\n    close(sock);\n    return -1;\n  }\n  return sock;\n#endif\n}", "target": 0}
{"code": "cmsNAMEDCOLORLIST* CMSEXPORT cmsAllocNamedColorList(cmsContext ContextID, cmsUInt32Number n, cmsUInt32Number ColorantCount, const char* Prefix, const char* Suffix)\n{\n    cmsNAMEDCOLORLIST* v = (cmsNAMEDCOLORLIST*) _cmsMallocZero(ContextID, sizeof(cmsNAMEDCOLORLIST));\n    if (v == NULL) return NULL;\n    v ->List      = NULL;\n    v ->nColors   = 0;\n    v ->ContextID  = ContextID;\n    while (v -> Allocated < n)\n        GrowNamedColorList(v);\n    strncpy(v ->Prefix, Prefix, sizeof(v ->Prefix));\n    strncpy(v ->Suffix, Suffix, sizeof(v ->Suffix));\n    v->Prefix[32] = v->Suffix[32] = 0;\n    v -> ColorantCount = ColorantCount;\n    return v;\n}", "target": 1}
{"code": "static int tga_readheader(FILE *fp, unsigned int *bits_per_pixel,\n                          unsigned int *width, unsigned int *height, int *flip_image)\n{\n    int palette_size;\n    unsigned char tga[TGA_HEADER_SIZE];\n    unsigned char id_len,  image_type;\n    unsigned char pixel_depth, image_desc;\n    unsigned short  cmap_len, cmap_entry_size;\n    unsigned short  image_w, image_h;\n    if (!bits_per_pixel || !width || !height || !flip_image) {\n        return 0;\n    }\n    if (fread(tga, TGA_HEADER_SIZE, 1, fp) != 1) {\n        fprintf(stderr,\n                \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0 ;\n    }\n    id_len = tga[0];\n    image_type = tga[2];\n    cmap_len = get_ushort(&tga[5]);\n    cmap_entry_size = tga[7];\n#if 0\n    x_origin = get_ushort(&tga[8]);\n    y_origin = get_ushort(&tga[10]);\n#endif\n    image_w = get_ushort(&tga[12]);\n    image_h = get_ushort(&tga[14]);\n    pixel_depth = tga[16];\n    image_desc  = tga[17];\n    *bits_per_pixel = (unsigned int)pixel_depth;\n    *width  = (unsigned int)image_w;\n    *height = (unsigned int)image_h;\n    if (id_len) {\n        unsigned char *id = (unsigned char *) malloc(id_len);\n        if (id == 0) {\n            fprintf(stderr, \"tga_readheader: memory out\\n\");\n            return 0;\n        }\n        if (!fread(id, id_len, 1, fp)) {\n            fprintf(stderr,\n                    \"\\nError: fread return a number of element different from the expected.\\n\");\n            free(id);\n            return 0 ;\n        }\n        free(id);\n    }\n    if (image_type > 8) {\n        fprintf(stderr, \"Sorry, compressed tga files are not currently supported.\\n\");\n        return 0 ;\n    }\n    *flip_image = !(image_desc & 32);\n    palette_size = cmap_len * (cmap_entry_size / 8);\n    if (palette_size > 0) {\n        fprintf(stderr, \"File contains a palette - not yet supported.\");\n        fseek(fp, palette_size, SEEK_CUR);\n    }\n    return 1;\n}", "target": 1}
{"code": "void LightProcess::runShadow(int fdin, int fdout) {\n  FILE *fin = fdopen(fdin, \"r\");\n  FILE *fout = fdopen(fdout, \"w\");\n  char buf[BUFFER_SIZE];\n  pollfd pfd[1];\n  pfd[0].fd = fdin;\n  pfd[0].events = POLLIN;\n  while (true) {\n    int ret = poll(pfd, 1, -1);\n    if (ret < 0 && errno == EINTR) {\n      continue;\n    }\n    if (pfd[0].revents & POLLIN) {\n      if (!fgets(buf, BUFFER_SIZE, fin)) buf[0] = '\\0';\n      if (strncmp(buf, \"exit\", 4) == 0) {\n        Logger::Info(\"LightProcess exiting upon request\");\n        break;\n      } else if (strncmp(buf, \"popen\", 5) == 0) {\n        do_popen(fin, fout, m_afdt_fd);\n      } else if (strncmp(buf, \"pclose\", 6) == 0) {\n        do_pclose(fin, fout);\n      } else if (strncmp(buf, \"proc_open\", 9) == 0) {\n        do_proc_open(fin, fout, m_afdt_fd);\n      } else if (strncmp(buf, \"waitpid\", 7) == 0) {\n        do_waitpid(fin, fout);\n      } else if (strncmp(buf, \"change_user\", 11) == 0) {\n        do_change_user(fin, fout);\n      } else if (buf[0]) {\n        Logger::Info(\"LightProcess got invalid command: %.20s\", buf);\n      }\n    } else if (pfd[0].revents & POLLHUP) {\n      Logger::Error(\"Lost parent, LightProcess exiting\");\n      break;\n    }\n  }\n  fclose(fin);\n  fclose(fout);\n  ::close(m_afdt_fd);\n  remove(m_afdtFilename.c_str());\n  _Exit(0);\n}", "target": 1}
{"code": "scrypt_SHA256_Update(struct SHA256_CTX * ctx, const void *in, size_t len)\n{\n  uint32_t bitlen[2];\n  uint32_t r;\n  const unsigned char *src = (unsigned char *) in;\n  r = (ctx->count[1] >> 3) & 0x3f;\n  bitlen[1] = ((uint32_t)len) << 3;\n  bitlen[0] = (uint32_t)(len >> 29);\n  if ((ctx->count[1] += bitlen[1]) < bitlen[1])\n    ctx->count[0]++;\n  ctx->count[0] += bitlen[0];\n  if (len < 64 - r) {\n    memcpy(&ctx->buf[r], src, len);\n    return;\n  }\n  memcpy(&ctx->buf[r], src, 64 - r);\n  SHA256_Transform(ctx->state, ctx->buf);\n  src += 64 - r;\n  len -= 64 - r;\n  while (len >= 64) {\n    SHA256_Transform(ctx->state, src);\n    src += 64;\n    len -= 64;\n  }\n  memcpy(ctx->buf, src, len);\n}", "target": 1}
{"code": "static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb, u32 features)\n{\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tunsigned int mss;\n\tunsigned int unfrag_ip6hlen, unfrag_len;\n\tstruct frag_hdr *fptr;\n\tu8 *mac_start, *prevhdr;\n\tu8 nexthdr;\n\tu8 frag_hdr_sz = sizeof(struct frag_hdr);\n\tint offset;\n\t__wsum csum;\n\tmss = skb_shinfo(skb)->gso_size;\n\tif (unlikely(skb->len <= mss))\n\t\tgoto out;\n\tif (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {\n\t\tint type = skb_shinfo(skb)->gso_type;\n\t\tif (unlikely(type & ~(SKB_GSO_UDP | SKB_GSO_DODGY) ||\n\t\t\t     !(type & (SKB_GSO_UDP))))\n\t\t\tgoto out;\n\t\tskb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss);\n\t\tsegs = NULL;\n\t\tgoto out;\n\t}\n\toffset = skb->csum_start - skb_headroom(skb);\n\tcsum = skb_checksum(skb, offset, skb->len- offset, 0);\n\toffset += skb->csum_offset;\n\t*(__sum16 *)(skb->data + offset) = csum_fold(csum);\n\tskb->ip_summed = CHECKSUM_NONE;\n\tif ((skb_headroom(skb) < frag_hdr_sz) &&\n\t    pskb_expand_head(skb, frag_hdr_sz, 0, GFP_ATOMIC))\n\t\tgoto out;\n\tunfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);\n\tnexthdr = *prevhdr;\n\t*prevhdr = NEXTHDR_FRAGMENT;\n\tunfrag_len = skb_network_header(skb) - skb_mac_header(skb) +\n\t\t     unfrag_ip6hlen;\n\tmac_start = skb_mac_header(skb);\n\tmemmove(mac_start-frag_hdr_sz, mac_start, unfrag_len);\n\tskb->mac_header -= frag_hdr_sz;\n\tskb->network_header -= frag_hdr_sz;\n\tfptr = (struct frag_hdr *)(skb_network_header(skb) + unfrag_ip6hlen);\n\tfptr->nexthdr = nexthdr;\n\tfptr->reserved = 0;\n\tipv6_select_ident(fptr);\n\tsegs = skb_segment(skb, features);\nout:\n\treturn segs;\n}", "target": 1}
{"code": "dissect_spoolss_uint16uni(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\n\t\t\t  proto_tree *tree, guint8 *drep _U_, char **data,\n\t\t\t  int hf_name)\n{\n\tgint len, remaining;\n\tchar *text;\n\tif (offset % 2)\n\t\toffset += 2 - (offset % 2);\n\tremaining = tvb_captured_length_remaining(tvb, offset);\n\tif (remaining <= 0) {\n\t\tif (data)\n\t\t\t*data = g_strdup(\"\");\n\t\treturn offset;\n\t}\n\ttext = tvb_get_string_enc(NULL, tvb, offset, remaining, ENC_UTF_16|ENC_LITTLE_ENDIAN);\n\tlen = (int)strlen(text);\n\tproto_tree_add_string(tree, hf_name, tvb, offset, len * 2, text);\n\tif (data)\n\t\t*data = text;\n\telse\n\t\tg_free(text);\n\treturn offset + (len + 1) * 2;\n}", "target": 1}
{"code": "struct addr_t* MACH0_(get_entrypoint)(struct MACH0_(obj_t)* bin) {\n\tstruct addr_t *entry;\n\tint i;\n\tif (!bin->entry && !bin->sects) {\n\t\treturn NULL;\n\t}\n\tif (!(entry = calloc (1, sizeof (struct addr_t)))) {\n\t\treturn NULL;\n\t}\n\tif (bin->entry) {\n\t\tentry->addr = entry_to_vaddr (bin);\n\t\tentry->offset = addr_to_offset (bin, entry->addr);\n\t\tentry->haddr = sdb_num_get (bin->kv, \"mach0.entry.offset\", 0);\n\t}\n\tif (!bin->entry || entry->offset == 0) {\n\t\tfor (i = 0; i < bin->nsects; i++) {\n\t\t\tif (!strncmp (bin->sects[i].sectname, \"__text\", 6)) {\n\t\t\t\tentry->offset = (ut64)bin->sects[i].offset;\n\t\t\t\tsdb_num_set (bin->kv, \"mach0.entry\", entry->offset, 0);\n\t\t\t\tentry->addr = (ut64)bin->sects[i].addr;\n\t\t\t\tif (!entry->addr) { \n\t\t\t\t\tentry->addr = entry->offset;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbin->entry = entry->addr;\n\t}\n\treturn entry;\n}", "target": 1}
{"code": "void CIRCSock::ReadLine(const CString& sData) {\n    CString sLine = sData;\n    sLine.TrimRight(\"\\n\\r\");\n    DEBUG(\"(\" << m_pNetwork->GetUser()->GetUserName() << \"/\"\n              << m_pNetwork->GetName() << \") IRC -> ZNC [\" << sLine << \"]\");\n    bool bReturn = false;\n    IRCSOCKMODULECALL(OnRaw(sLine), &bReturn);\n    if (bReturn) return;\n    CMessage Message(sLine);\n    Message.SetNetwork(m_pNetwork);\n    IRCSOCKMODULECALL(OnRawMessage(Message), &bReturn);\n    if (bReturn) return;\n    switch (Message.GetType()) {\n        case CMessage::Type::Account:\n            bReturn = OnAccountMessage(Message);\n            break;\n        case CMessage::Type::Action:\n            bReturn = OnActionMessage(Message);\n            break;\n        case CMessage::Type::Away:\n            bReturn = OnAwayMessage(Message);\n            break;\n        case CMessage::Type::Capability:\n            bReturn = OnCapabilityMessage(Message);\n            break;\n        case CMessage::Type::CTCP:\n            bReturn = OnCTCPMessage(Message);\n            break;\n        case CMessage::Type::Error:\n            bReturn = OnErrorMessage(Message);\n            break;\n        case CMessage::Type::Invite:\n            bReturn = OnInviteMessage(Message);\n            break;\n        case CMessage::Type::Join:\n            bReturn = OnJoinMessage(Message);\n            break;\n        case CMessage::Type::Kick:\n            bReturn = OnKickMessage(Message);\n            break;\n        case CMessage::Type::Mode:\n            bReturn = OnModeMessage(Message);\n            break;\n        case CMessage::Type::Nick:\n            bReturn = OnNickMessage(Message);\n            break;\n        case CMessage::Type::Notice:\n            bReturn = OnNoticeMessage(Message);\n            break;\n        case CMessage::Type::Numeric:\n            bReturn = OnNumericMessage(Message);\n            break;\n        case CMessage::Type::Part:\n            bReturn = OnPartMessage(Message);\n            break;\n        case CMessage::Type::Ping:\n            bReturn = OnPingMessage(Message);\n            break;\n        case CMessage::Type::Pong:\n            bReturn = OnPongMessage(Message);\n            break;\n        case CMessage::Type::Quit:\n            bReturn = OnQuitMessage(Message);\n            break;\n        case CMessage::Type::Text:\n            bReturn = OnTextMessage(Message);\n            break;\n        case CMessage::Type::Topic:\n            bReturn = OnTopicMessage(Message);\n            break;\n        case CMessage::Type::Wallops:\n            bReturn = OnWallopsMessage(Message);\n            break;\n        default:\n            break;\n    }\n    if (bReturn) return;\n    m_pNetwork->PutUser(Message);\n}", "target": 1}
{"code": "bool DependencyOptimizer::SafeToRemoveIdentity(const NodeDef& node) const {\n  if (!IsIdentity(node) && !IsIdentityN(node)) {\n    return true;\n  }\n  if (nodes_to_preserve_.find(node.name()) != nodes_to_preserve_.end()) {\n    return false;\n  }\n  if (!fetch_nodes_known_) {\n    return false;\n  }\n  if (node.input_size() < 1) {\n    return false;\n  }\n  const NodeDef* input = node_map_->GetNode(NodeName(node.input(0)));\n  if (input == nullptr) {\n    VLOG(1) << \"node = \" << node.name() << \" input = \" << node.input(0);\n    return false;\n  }\n  if (IsVariable(*input) || IsRecv(*input)) {\n    return false;\n  }\n  for (const auto& consumer : node_map_->GetOutputs(node.name())) {\n    if (node.input_size() > 1 && (IsRetval(*consumer) || IsMerge(*consumer))) {\n      return false;\n    }\n    if (IsSwitch(*input)) {\n      for (const string& consumer_input : consumer->input()) {\n        if (consumer_input == AsControlDependency(node.name())) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}", "target": 0}
{"code": "static int rawsock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t   struct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint copied;\n\tint rc;\n\tpr_debug(\"sock=%p sk=%p len=%zu flags=%d\\n\", sock, sk, len, flags);\n\tskb = skb_recv_datagram(sk, flags, noblock, &rc);\n\tif (!skb)\n\t\treturn rc;\n\tmsg->msg_namelen = 0;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\trc = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tskb_free_datagram(sk, skb);\n\treturn rc ? : copied;\n}", "target": 1}
{"code": "static void ida_check_bad_free(struct ida *ida)\n{\n\tunsigned long i;\n\tprintk(\"vvv Ignore \\\"not allocated\\\" warnings\\n\");\n\tida_free(ida, 0);\n\tfor (i = 0; i < 31; i++)\n\t\tida_free(ida, 1 << i);\n\tIDA_BUG_ON(ida, ida_alloc_min(ida, 3, GFP_KERNEL) != 3);\n\tida_free(ida, 0);\n\tfor (i = 0; i < 31; i++)\n\t\tida_free(ida, 1 << i);\n\tIDA_BUG_ON(ida, ida_alloc_min(ida, 1023, GFP_KERNEL) != 1023);\n\tida_free(ida, 0);\n\tfor (i = 0; i < 31; i++)\n\t\tida_free(ida, 1 << i);\n\tIDA_BUG_ON(ida, ida_alloc_min(ida, (1 << 20) - 1, GFP_KERNEL) != (1 << 20) - 1);\n\tida_free(ida, 0);\n\tfor (i = 0; i < 31; i++)\n\t\tida_free(ida, 1 << i);\n\tprintk(\"^^^ \\\"not allocated\\\" warnings over\\n\");\n\tida_free(ida, 3);\n\tida_free(ida, 1023);\n\tida_free(ida, (1 << 20) - 1);\n\tIDA_BUG_ON(ida, !ida_is_empty(ida));\n}", "target": 0}
{"code": "mm_skey_query(void *ctx, char **name, char **infotxt,\n   u_int *numprompts, char ***prompts, u_int **echo_on)\n{\n\tBuffer m;\n\tint len;\n\tu_int success;\n\tchar *p, *challenge;\n\tdebug3(\"%s: entering\", __func__);\n\tbuffer_init(&m);\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_SKEYQUERY, &m);\n\tmm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_SKEYQUERY,\n\t    &m);\n\tsuccess = buffer_get_int(&m);\n\tif (success == 0) {\n\t\tdebug3(\"%s: no challenge\", __func__);\n\t\tbuffer_free(&m);\n\t\treturn (-1);\n\t}\n\tchallenge  = buffer_get_string(&m, NULL);\n\tbuffer_free(&m);\n\tdebug3(\"%s: received challenge: %s\", __func__, challenge);\n\tmm_chall_setup(name, infotxt, numprompts, prompts, echo_on);\n\tlen = strlen(challenge) + strlen(SKEY_PROMPT) + 1;\n\tp = xmalloc(len);\n\tstrlcpy(p, challenge, len);\n\tstrlcat(p, SKEY_PROMPT, len);\n\t(*prompts)[0] = p;\n\txfree(challenge);\n\treturn (0);\n}", "target": 0}
{"code": "xmlValidCtxtNormalizeAttributeValue(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n\t     xmlNodePtr elem, const xmlChar *name, const xmlChar *value) {\n    xmlChar *ret, *dst;\n    const xmlChar *src;\n    xmlAttributePtr attrDecl = NULL;\n    int extsubset = 0;\n    if (doc == NULL) return(NULL);\n    if (elem == NULL) return(NULL);\n    if (name == NULL) return(NULL);\n    if (value == NULL) return(NULL);\n    if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {\n\txmlChar fn[50];\n\txmlChar *fullname;\n\tfullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);\n\tif (fullname == NULL)\n\t    return(NULL);\n\tattrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullname, name);\n\tif ((attrDecl == NULL) && (doc->extSubset != NULL)) {\n\t    attrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullname, name);\n\t    if (attrDecl != NULL)\n\t\textsubset = 1;\n\t}\n\tif ((fullname != fn) && (fullname != elem->name))\n\t    xmlFree(fullname);\n    }\n    if ((attrDecl == NULL) && (doc->intSubset != NULL))\n\tattrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, name);\n    if ((attrDecl == NULL) && (doc->extSubset != NULL)) {\n\tattrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);\n\tif (attrDecl != NULL)\n\t    extsubset = 1;\n    }\n    if (attrDecl == NULL)\n\treturn(NULL);\n    if (attrDecl->atype == XML_ATTRIBUTE_CDATA)\n\treturn(NULL);\n    ret = xmlStrdup(value);\n    if (ret == NULL)\n\treturn(NULL);\n    src = value;\n    dst = ret;\n    while (*src == 0x20) src++;\n    while (*src != 0) {\n\tif (*src == 0x20) {\n\t    while (*src == 0x20) src++;\n\t    if (*src != 0)\n\t\t*dst++ = 0x20;\n\t} else {\n\t    *dst++ = *src++;\n\t}\n    }\n    *dst = 0;\n    if ((doc->standalone) && (extsubset == 1) && (!xmlStrEqual(value, ret))) {\n\txmlErrValidNode(ctxt, elem, XML_DTD_NOT_STANDALONE,\n\"standalone: %s on %s value had to be normalized based on external subset declaration\\n\",\n\t       name, elem->name, NULL);\n\tctxt->valid = 0;\n    }\n    return(ret);\n}", "target": 1}
{"code": "    size_t SonyMnHeader::size() const\n    {\n        return sizeOfSignature();\n    }", "target": 0}
{"code": "archive_string_append_from_wcs(struct archive_string *as,\n    const wchar_t *w, size_t len)\n{\n\tint n, ret_val = 0;\n\tchar *p;\n\tchar *end;\n#if HAVE_WCRTOMB\n\tmbstate_t shift_state;\n\tmemset(&shift_state, 0, sizeof(shift_state));\n#else\n\twctomb(NULL, L'\\0');\n#endif\n\tif (archive_string_ensure(as, as->length + len + 1) == NULL)\n\t\treturn (-1);\n\tp = as->s + as->length;\n\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n\twhile (*w != L'\\0' && len > 0) {\n\t\tif (p >= end) {\n\t\t\tas->length = p - as->s;\n\t\t\tas->s[as->length] = '\\0';\n\t\t\tif (archive_string_ensure(as,\n\t\t\t    as->length + len * 2 + 1) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tp = as->s + as->length;\n\t\t\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n\t\t}\n#if HAVE_WCRTOMB\n\t\tn = wcrtomb(p, *w++, &shift_state);\n#else\n\t\tn = wctomb(p, *w++);\n#endif\n\t\tif (n == -1) {\n\t\t\tif (errno == EILSEQ) {\n\t\t\t\t*p++ = '?';\n\t\t\t\tret_val = -1;\n\t\t\t} else {\n\t\t\t\tret_val = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tp += n;\n\t\tlen--;\n\t}\n\tas->length = p - as->s;\n\tas->s[as->length] = '\\0';\n\treturn (ret_val);\n}", "target": 1}
{"code": "TfLiteRegistration GetPassthroughOpRegistration() {\n  TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n  reg.init = [](TfLiteContext* context, const char*, size_t) -> void* {\n    auto* first_new_tensor = new int;\n    context->AddTensors(context, 2, first_new_tensor);\n    return first_new_tensor;\n  };\n  reg.free = [](TfLiteContext* context, void* buffer) {\n    delete static_cast<int*>(buffer);\n  };\n  reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n    auto* first_new_tensor = static_cast<int*>(node->user_data);\n    const TfLiteTensor* tensor0 = GetInput(context, node, 0);\n    TfLiteTensor* tensor1 = GetOutput(context, node, 0);\n    TfLiteIntArray* newSize = TfLiteIntArrayCopy(tensor0->dims);\n    TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, tensor1, newSize));\n    TfLiteIntArrayFree(node->temporaries);\n    node->temporaries = TfLiteIntArrayCreate(2);\n    for (int i = 0; i < 2; ++i) {\n      node->temporaries->data[i] = *(first_new_tensor) + i;\n    }\n    auto setup_temporary = [&](int id) {\n      TfLiteTensor* tmp = &context->tensors[id];\n      tmp->type = kTfLiteFloat32;\n      tmp->allocation_type = kTfLiteArenaRw;\n      return context->ResizeTensor(context, tmp,\n                                   TfLiteIntArrayCopy(tensor0->dims));\n    };\n    TF_LITE_ENSURE_STATUS(setup_temporary(node->temporaries->data[0]));\n    TF_LITE_ENSURE_STATUS(setup_temporary(node->temporaries->data[1]));\n    return kTfLiteOk;\n  };\n  reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n    const TfLiteTensor* a0 = GetInput(context, node, 0);\n    auto populate = [&](int id) {\n      TfLiteTensor* t = &context->tensors[id];\n      int num = a0->dims->data[0];\n      for (int i = 0; i < num; i++) {\n        t->data.f[i] = a0->data.f[i];\n      }\n    };\n    populate(node->outputs->data[0]);\n    populate(node->temporaries->data[0]);\n    populate(node->temporaries->data[1]);\n    return kTfLiteOk;\n  };\n  return reg;\n}", "target": 1}
{"code": "pci_get_vdev_info(int slot)\n{\n\tstruct businfo *bi;\n\tstruct slotinfo *si;\n\tstruct pci_vdev *dev = NULL;\n\tbi = pci_businfo[0];\n\tassert(bi != NULL);\n\tsi = &bi->slotinfo[slot];\n\tif (si != NULL)\n\t\tdev = si->si_funcs[0].fi_devi;\n\telse\n\t\tfprintf(stderr, \"slot=%d is empty!\\n\", slot);\n\treturn dev;\n}", "target": 1}
{"code": "static struct key *construct_key_and_link(struct keyring_search_context *ctx,\n\t\t\t\t\t  const char *callout_info,\n\t\t\t\t\t  size_t callout_len,\n\t\t\t\t\t  void *aux,\n\t\t\t\t\t  struct key *dest_keyring,\n\t\t\t\t\t  unsigned long flags)\n{\n\tstruct key_user *user;\n\tstruct key *key;\n\tint ret;\n\tkenter(\"\");\n\tif (ctx->index_key.type == &key_type_keyring)\n\t\treturn ERR_PTR(-EPERM);\n\tuser = key_user_lookup(current_fsuid());\n\tif (!user)\n\t\treturn ERR_PTR(-ENOMEM);\n\tconstruct_get_dest_keyring(&dest_keyring);\n\tret = construct_alloc_key(ctx, dest_keyring, flags, user, &key);\n\tkey_user_put(user);\n\tif (ret == 0) {\n\t\tret = construct_key(key, callout_info, callout_len, aux,\n\t\t\t\t    dest_keyring);\n\t\tif (ret < 0) {\n\t\t\tkdebug(\"cons failed\");\n\t\t\tgoto construction_failed;\n\t\t}\n\t} else if (ret == -EINPROGRESS) {\n\t\tret = 0;\n\t} else {\n\t\tgoto couldnt_alloc_key;\n\t}\n\tkey_put(dest_keyring);\n\tkleave(\" = key %d\", key_serial(key));\n\treturn key;\nconstruction_failed:\n\tkey_negate_and_link(key, key_negative_timeout, NULL, NULL);\n\tkey_put(key);\ncouldnt_alloc_key:\n\tkey_put(dest_keyring);\n\tkleave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}", "target": 1}
{"code": "ArgParser::parseServerArgs(ServerArgs& args, int argc, const char* const* argv)\n{\n    setArgsBase(args);\n    updateCommonArgs(argv);\n    for (int i = 1; i < argc; ++i) {\n        if (parsePlatformArg(args, argc, argv, i)) {\n            continue;\n        }\n        else if (parseGenericArgs(argc, argv, i)) {\n            continue;\n        }\n        else if (parseDeprecatedArgs(argc, argv, i)) {\n            continue;\n        }\n        else if (isArg(i, argc, argv, \"-a\", \"--address\", 1)) {\n            args.m_barrierAddress = argv[++i];\n        }\n        else if (isArg(i, argc, argv, \"-c\", \"--config\", 1)) {\n            args.m_configFile = argv[++i];\n        }\n        else if (isArg(i, argc, argv, NULL, \"--screen-change-script\", 1)) {\n            args.m_screenChangeScript = argv[++i];\n        }\n        else {\n            LOG((CLOG_PRINT \"%s: unrecognized option `%s'\" BYE, args.m_exename.c_str(), argv[i], args.m_exename.c_str()));\n            return false;\n        }\n    }\n    if (checkUnexpectedArgs()) {\n        return false;\n    }\n    return true;\n}", "target": 1}
{"code": "static __inline__ int scm_send(struct socket *sock, struct msghdr *msg,\n\t\t\t       struct scm_cookie *scm)\n{\n\tmemset(scm, 0, sizeof(*scm));\n\tunix_get_peersec_dgram(sock, scm);\n\tif (msg->msg_controllen <= 0)\n\t\treturn 0;\n\treturn __scm_send(sock, msg, scm);\n}", "target": 1}
{"code": "GF_Err dac3_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DEC3;\n\te = gf_isom_box_write_header(s, bs);\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DAC3;\n\tif (e) return e;\n\te = gf_odf_ac3_cfg_write_bs(&ptr->cfg, bs);\n\tif (e) return e;\n\tif (ptr->cfg.atmos_ec3_ext || ptr->cfg.complexity_index_type) {\n\t\tgf_bs_write_int(bs, 0, 7);\n\t\tgf_bs_write_int(bs, ptr->cfg.atmos_ec3_ext, 1);\n\t\tgf_bs_write_u8(bs, ptr->cfg.complexity_index_type);\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "static struct btrfs_device *btrfs_find_device_by_path(\n\t\tstruct btrfs_fs_info *fs_info, const char *device_path)\n{\n\tint ret = 0;\n\tstruct btrfs_super_block *disk_super;\n\tu64 devid;\n\tu8 *dev_uuid;\n\tstruct block_device *bdev;\n\tstruct buffer_head *bh;\n\tstruct btrfs_device *device;\n\tret = btrfs_get_bdev_and_sb(device_path, FMODE_READ,\n\t\t\t\t    fs_info->bdev_holder, 0, &bdev, &bh);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tdisk_super = (struct btrfs_super_block *)bh->b_data;\n\tdevid = btrfs_stack_device_id(&disk_super->dev_item);\n\tdev_uuid = disk_super->dev_item.uuid;\n\tif (btrfs_fs_incompat(fs_info, METADATA_UUID))\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, dev_uuid,\n\t\t\t\t\t   disk_super->metadata_uuid);\n\telse\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, dev_uuid,\n\t\t\t\t\t   disk_super->fsid);\n\tbrelse(bh);\n\tif (!device)\n\t\tdevice = ERR_PTR(-ENOENT);\n\tblkdev_put(bdev, FMODE_READ);\n\treturn device;\n}", "target": 1}
{"code": "static int su3000_frontend_attach(struct dvb_usb_adapter *d)\n{\n\tu8 obuf[3] = { 0xe, 0x80, 0 };\n\tu8 ibuf[] = { 0 };\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x02;\n\tobuf[2] = 1;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tmsleep(300);\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x83;\n\tobuf[2] = 0;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x83;\n\tobuf[2] = 1;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tobuf[0] = 0x51;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x51 transfer failed.\");\n\td->fe_adap[0].fe = dvb_attach(ds3000_attach, &su3000_ds3000_config,\n\t\t\t\t\t&d->dev->i2c_adap);\n\tif (d->fe_adap[0].fe == NULL)\n\t\treturn -EIO;\n\tif (dvb_attach(ts2020_attach, d->fe_adap[0].fe,\n\t\t\t\t&dw2104_ts2020_config,\n\t\t\t\t&d->dev->i2c_adap)) {\n\t\tinfo(\"Attached DS3000/TS2020!\");\n\t\treturn 0;\n\t}\n\tinfo(\"Failed to attach DS3000/TS2020!\");\n\treturn -EIO;\n}", "target": 1}
{"code": "static bool is_simm32(s64 value)\n{\n\treturn value == (s64) (s32) value;\n}", "target": 0}
{"code": "static int fsmVerify(const char *path, rpmfi fi)\n{\n    int rc;\n    int saveerrno = errno;\n    struct stat dsb;\n    mode_t mode = rpmfiFMode(fi);\n    rc = fsmStat(path, 1, &dsb);\n    if (rc)\n\treturn rc;\n    if (S_ISREG(mode)) {\n\tchar *rmpath = rstrscat(NULL, path, \"-RPMDELETE\", NULL);\n\trc = fsmRename(path, rmpath);\n\tif (!rc)\n\t    (void) fsmUnlink(rmpath);\n\telse\n\t    rc = RPMERR_UNLINK_FAILED;\n\tfree(rmpath);\n        return (rc ? rc : RPMERR_ENOENT);\t\n    } else if (S_ISDIR(mode)) {\n        if (S_ISDIR(dsb.st_mode)) return 0;\n        if (S_ISLNK(dsb.st_mode)) {\n            rc = fsmStat(path, 0, &dsb);\n            if (rc == RPMERR_ENOENT) rc = 0;\n            if (rc) return rc;\n            errno = saveerrno;\n            if (S_ISDIR(dsb.st_mode)) return 0;\n        }\n    } else if (S_ISLNK(mode)) {\n        if (S_ISLNK(dsb.st_mode)) {\n            char buf[8 * BUFSIZ];\n            size_t len;\n            rc = fsmReadLink(path, buf, 8 * BUFSIZ, &len);\n            errno = saveerrno;\n            if (rc) return rc;\n            if (rstreq(rpmfiFLink(fi), buf)) return 0;\n        }\n    } else if (S_ISFIFO(mode)) {\n        if (S_ISFIFO(dsb.st_mode)) return 0;\n    } else if (S_ISCHR(mode) || S_ISBLK(mode)) {\n        if ((S_ISCHR(dsb.st_mode) || S_ISBLK(dsb.st_mode)) &&\n            (dsb.st_rdev == rpmfiFRdev(fi))) return 0;\n    } else if (S_ISSOCK(mode)) {\n        if (S_ISSOCK(dsb.st_mode)) return 0;\n    }\n    rc = fsmUnlink(path);\n    if (rc == 0)\trc = RPMERR_ENOENT;\n    return (rc ? rc : RPMERR_ENOENT);\t\n}", "target": 1}
{"code": "static int multipath_ioctl(struct dm_target *ti, unsigned int cmd,\n\t\t\t   unsigned long arg)\n{\n\tstruct multipath *m = (struct multipath *) ti->private;\n\tstruct block_device *bdev = NULL;\n\tfmode_t mode = 0;\n\tunsigned long flags;\n\tint r = 0;\n\tspin_lock_irqsave(&m->lock, flags);\n\tif (!m->current_pgpath)\n\t\t__choose_pgpath(m, 0);\n\tif (m->current_pgpath) {\n\t\tbdev = m->current_pgpath->path.dev->bdev;\n\t\tmode = m->current_pgpath->path.dev->mode;\n\t}\n\tif (m->queue_io)\n\t\tr = -EAGAIN;\n\telse if (!bdev)\n\t\tr = -EIO;\n\tspin_unlock_irqrestore(&m->lock, flags);\n\tif (!r && ti->len != i_size_read(bdev->bd_inode) >> SECTOR_SHIFT)\n\t\tr = scsi_verify_blk_ioctl(NULL, cmd);\n\treturn r ? : __blkdev_driver_ioctl(bdev, mode, cmd, arg);\n}", "target": 0}
{"code": "static u64 gen_hi_max(struct tnum var)\n{\n\treturn (var.value | var.mask) & ~0xffffffffULL;\n}", "target": 0}
{"code": "void SetDashSize(double dashsize,double phase) {\n    if ( dashsize ) outpos += sprintf(outpos,\" [%12.3f] %12.3f d\",dashsize,phase);\n    else outpos += sprintf(outpos,\" [] 0 d\");\n}", "target": 1}
{"code": "int HttpStreamParser::DoLoop(int result) {\n  bool can_do_more = true;\n  do {\n    switch (io_state_) {\n      case STATE_SENDING_HEADERS:\n        if (result < 0)\n          can_do_more = false;\n        else\n          result = DoSendHeaders(result);\n        break;\n      case STATE_SENDING_BODY:\n        if (result < 0)\n          can_do_more = false;\n        else\n          result = DoSendBody(result);\n        break;\n      case STATE_SEND_REQUEST_READING_BODY:\n        result = DoSendRequestReadingBody(result);\n        break;\n      case STATE_REQUEST_SENT:\n        DCHECK(result != ERR_IO_PENDING);\n        can_do_more = false;\n        break;\n      case STATE_READ_HEADERS:\n        net_log_.BeginEvent(NetLog::TYPE_HTTP_STREAM_PARSER_READ_HEADERS);\n        result = DoReadHeaders();\n        break;\n      case STATE_READ_HEADERS_COMPLETE:\n        result = DoReadHeadersComplete(result);\n        net_log_.EndEventWithNetErrorCode(\n            NetLog::TYPE_HTTP_STREAM_PARSER_READ_HEADERS, result);\n        break;\n      case STATE_BODY_PENDING:\n        DCHECK(result != ERR_IO_PENDING);\n        can_do_more = false;\n        break;\n      case STATE_READ_BODY:\n        result = DoReadBody();\n        break;\n      case STATE_READ_BODY_COMPLETE:\n        result = DoReadBodyComplete(result);\n        break;\n      case STATE_DONE:\n        DCHECK(result != ERR_IO_PENDING);\n        can_do_more = false;\n        break;\n      default:\n        NOTREACHED();\n        can_do_more = false;\n        break;\n    }\n  } while (result != ERR_IO_PENDING && can_do_more);\n  return result;\n}", "target": 0}
{"code": "atm_if_print(netdissect_options *ndo,\n             const struct pcap_pkthdr *h, const u_char *p)\n{\n\tu_int caplen = h->caplen;\n\tu_int length = h->len;\n\tuint32_t llchdr;\n\tu_int hdrlen = 0;\n\tif (caplen < 1 || length < 1) {\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\treturn (caplen);\n\t}\n        if (*p == LLC_UI) {\n            if (ndo->ndo_eflag)\n                ND_PRINT((ndo, \"CNLPID \"));\n            isoclns_print(ndo, p + 1, length - 1, caplen - 1);\n            return hdrlen;\n        }\n\tif (caplen < 3 || length < 3) {\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\treturn (caplen);\n\t}\n\tllchdr = EXTRACT_24BITS(p);\n\tif (llchdr != LLC_UI_HDR(LLCSAP_SNAP) &&\n\t    llchdr != LLC_UI_HDR(LLCSAP_ISONS) &&\n\t    llchdr != LLC_UI_HDR(LLCSAP_IP)) {\n\t\tif (caplen < 20 || length < 20) {\n\t\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\t\treturn (caplen);\n\t\t}\n\t\tif (ndo->ndo_eflag)\n\t\t\tND_PRINT((ndo, \"%08x%08x %08x%08x \",\n\t\t\t       EXTRACT_32BITS(p),\n\t\t\t       EXTRACT_32BITS(p+4),\n\t\t\t       EXTRACT_32BITS(p+8),\n\t\t\t       EXTRACT_32BITS(p+12)));\n\t\tp += 20;\n\t\tlength -= 20;\n\t\tcaplen -= 20;\n\t\thdrlen += 20;\n\t}\n\thdrlen += atm_llc_print(ndo, p, length, caplen);\n\treturn (hdrlen);\n}", "target": 1}
{"code": "static FormatCode getFormatCode(const _AudioFormat &format)\n{\n\tif (format.sampleFormat == AF_SAMPFMT_FLOAT)\n\t\treturn kFloat;\n\tif (format.sampleFormat == AF_SAMPFMT_DOUBLE)\n\t\treturn kDouble;\n\tif (format.isInteger())\n\t{\n\t\tswitch (format.bytesPerSample(false))\n\t\t{\n\t\t\tcase 1: return kInt8;\n\t\t\tcase 2: return kInt16;\n\t\t\tcase 3: return kInt24;\n\t\t\tcase 4: return kInt32;\n\t\t}\n\t}\n\tassert(false);\n\treturn kUndefined;\n}", "target": 0}
{"code": "ClientContextImpl::newSsl(const Network::TransportSocketOptionsConstSharedPtr& options) {\n  bssl::UniquePtr<SSL> ssl_con(ContextImpl::newSsl(options));\n  const std::string server_name_indication = options && options->serverNameOverride().has_value()\n                                                 ? options->serverNameOverride().value()\n                                                 : server_name_indication_;\n  if (!server_name_indication.empty()) {\n    const int rc = SSL_set_tlsext_host_name(ssl_con.get(), server_name_indication.c_str());\n    RELEASE_ASSERT(rc, Utility::getLastCryptoError().value_or(\"\"));\n  }\n  if (options && !options->verifySubjectAltNameListOverride().empty()) {\n    SSL_set_verify(ssl_con.get(), SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, nullptr);\n  }\n  bool has_alpn_defined = !parsed_alpn_protocols_.empty();\n  if (options) {\n    has_alpn_defined |= parseAndSetAlpn(options->applicationProtocolListOverride(), *ssl_con);\n  }\n  if (options && !has_alpn_defined && !options->applicationProtocolFallback().empty()) {\n    parseAndSetAlpn(options->applicationProtocolFallback(), *ssl_con);\n  }\n  if (allow_renegotiation_) {\n    SSL_set_renegotiate_mode(ssl_con.get(), ssl_renegotiate_freely);\n  }\n  SSL_set_enforce_rsa_key_usage(ssl_con.get(), enforce_rsa_key_usage_);\n  if (max_session_keys_ > 0) {\n    if (session_keys_single_use_) {\n      absl::WriterMutexLock l(&session_keys_mu_);\n      if (!session_keys_.empty()) {\n        SSL_SESSION* session = session_keys_.front().get();\n        SSL_set_session(ssl_con.get(), session);\n        if (SSL_SESSION_should_be_single_use(session)) {\n          session_keys_.pop_front();\n        }\n      }\n    } else {\n      absl::ReaderMutexLock l(&session_keys_mu_);\n      if (!session_keys_.empty()) {\n        SSL_SESSION* session = session_keys_.front().get();\n        SSL_set_session(ssl_con.get(), session);\n      }\n    }\n  }\n  return ssl_con;\n}", "target": 1}
{"code": "FILE *LightProcess::LightPopenImpl(const char *cmd, const char *type,\n                                   const char *cwd) {\n  int id = GetId();\n  Lock lock(g_procs[id].m_procMutex);\n  fprintf(g_procs[id].m_fout, \"popen\\n%s\\n%s\\n%s\\n\", type, cmd, cwd);\n  fflush(g_procs[id].m_fout);\n  char buf[BUFFER_SIZE];\n  read_buf(g_procs[id].m_fin, buf);\n  if (strncmp(buf, \"error\", 5) == 0) {\n    return nullptr;\n  }\n  int64_t fptr = 0;\n  read_buf(g_procs[id].m_fin, buf);\n  sscanf(buf, \"%\" PRId64, &fptr);\n  if (!fptr) {\n    Logger::Error(\"Light process failed to return the file pointer.\");\n    return nullptr;\n  }\n  int fd = recv_fd(g_procs[id].m_afdt_fd);\n  if (fd < 0) {\n    Logger::Error(\"Light process failed to send the file descriptor.\");\n    return nullptr;\n  }\n  FILE *f = fdopen(fd, type);\n  g_procs[id].m_popenMap[(int64_t)f] = fptr;\n  return f;\n}", "target": 1}
{"code": "crm_create_anon_tls_session(int csock, int type , void *credentials)\n{\n    gnutls_session *session = gnutls_malloc(sizeof(gnutls_session));\n    gnutls_init(session, type);\n#  ifdef HAVE_GNUTLS_PRIORITY_SET_DIRECT\n    gnutls_priority_set_direct(*session, \"NORMAL:+ANON-DH\", NULL);\n#  else\n    gnutls_set_default_priority(*session);\n    gnutls_kx_set_priority(*session, anon_tls_kx_order);\n#  endif\n    gnutls_transport_set_ptr(*session, (gnutls_transport_ptr) GINT_TO_POINTER(csock));\n    switch (type) {\n    case GNUTLS_SERVER:\n        gnutls_credentials_set(*session, GNUTLS_CRD_ANON, (gnutls_anon_server_credentials_t) credentials);\n        break;\n    case GNUTLS_CLIENT:\n        gnutls_credentials_set(*session, GNUTLS_CRD_ANON, (gnutls_anon_client_credentials_t) credentials);\n        break;\n    }\n    return session;\n}", "target": 0}
{"code": "void conn_close_all(void) {\n    int i;\n    for (i = 0; i < max_fds; i++) {\n        if (conns[i] && conns[i]->state != conn_closed) {\n            conn_close(conns[i]);\n        }\n    }\n}", "target": 0}
{"code": "ikev1_attr_print(netdissect_options *ndo, const u_char *p, const u_char *ep)\n{\n\tint totlen;\n\tuint32_t t;\n\tif (p[0] & 0x80)\n\t\ttotlen = 4;\n\telse\n\t\ttotlen = 4 + EXTRACT_16BITS(&p[2]);\n\tif (ep < p + totlen) {\n\t\tND_PRINT((ndo,\"[|attr]\"));\n\t\treturn ep + 1;\n\t}\n\tND_PRINT((ndo,\"(\"));\n\tt = EXTRACT_16BITS(&p[0]) & 0x7fff;\n\tND_PRINT((ndo,\"type=#%d \", t));\n\tif (p[0] & 0x80) {\n\t\tND_PRINT((ndo,\"value=\"));\n\t\tt = p[2];\n\t\trawprint(ndo, (const uint8_t *)&p[2], 2);\n\t} else {\n\t\tND_PRINT((ndo,\"len=%d value=\", EXTRACT_16BITS(&p[2])));\n\t\trawprint(ndo, (const uint8_t *)&p[4], EXTRACT_16BITS(&p[2]));\n\t}\n\tND_PRINT((ndo,\")\"));\n\treturn p + totlen;\n}", "target": 1}
{"code": "void encode(ArgumentEncoder* encoder, CFArrayRef array)\n{\n    CFIndex size = CFArrayGetCount(array);\n    Vector<CFTypeRef, 32> values(size);\n    CFArrayGetValues(array, CFRangeMake(0, size), values.data());\n    encoder->encodeUInt64(size);\n    for (CFIndex i = 0; i < size; ++i) {\n        ASSERT(values[i]);\n        encode(encoder, values[i]);\n    }\n}", "target": 0}
{"code": "PHP_FUNCTION(pg_version)\n{\n\tphp_pgsql_get_link_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_VERSION);\n}", "target": 0}
{"code": "void ext4_es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t   ext4_lblk_t len)\n{\n\text4_lblk_t end;\n\tint err = 0;\n\tint reserved = 0;\n\tstruct extent_status *es = NULL;\n\tif (EXT4_SB(inode->i_sb)->s_mount_state & EXT4_FC_REPLAY)\n\t\treturn;\n\ttrace_ext4_es_remove_extent(inode, lblk, len);\n\tes_debug(\"remove [%u/%u) from extent status tree of inode %lu\\n\",\n\t\t lblk, len, inode->i_ino);\n\tif (!len)\n\t\treturn;\n\tend = lblk + len - 1;\n\tBUG_ON(end < lblk);\nretry:\n\tif (err && !es)\n\t\tes = __es_alloc_extent(true);\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\terr = __es_remove_extent(inode, lblk, end, &reserved, es);\n\tif (es && !es->es_len)\n\t\t__es_free_extent(es);\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\tif (err)\n\t\tgoto retry;\n\text4_es_print_tree(inode);\n\text4_da_release_space(inode, reserved);\n\treturn;\n}", "target": 1}
{"code": "unsigned char *ziplistMerge(unsigned char **first, unsigned char **second) {\n    if (first == NULL || *first == NULL || second == NULL || *second == NULL)\n        return NULL;\n    if (*first == *second)\n        return NULL;\n    size_t first_bytes = intrev32ifbe(ZIPLIST_BYTES(*first));\n    size_t first_len = intrev16ifbe(ZIPLIST_LENGTH(*first));\n    size_t second_bytes = intrev32ifbe(ZIPLIST_BYTES(*second));\n    size_t second_len = intrev16ifbe(ZIPLIST_LENGTH(*second));\n    int append;\n    unsigned char *source, *target;\n    size_t target_bytes, source_bytes;\n    if (first_len >= second_len) {\n        target = *first;\n        target_bytes = first_bytes;\n        source = *second;\n        source_bytes = second_bytes;\n        append = 1;\n    } else {\n        target = *second;\n        target_bytes = second_bytes;\n        source = *first;\n        source_bytes = first_bytes;\n        append = 0;\n    }\n    size_t zlbytes = first_bytes + second_bytes -\n                     ZIPLIST_HEADER_SIZE - ZIPLIST_END_SIZE;\n    size_t zllength = first_len + second_len;\n    zllength = zllength < UINT16_MAX ? zllength : UINT16_MAX;\n    assert(zlbytes < UINT32_MAX);\n    size_t first_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*first));\n    size_t second_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*second));\n    target = zrealloc(target, zlbytes);\n    if (append) {\n        memcpy(target + target_bytes - ZIPLIST_END_SIZE,\n               source + ZIPLIST_HEADER_SIZE,\n               source_bytes - ZIPLIST_HEADER_SIZE);\n    } else {\n        memmove(target + source_bytes - ZIPLIST_END_SIZE,\n                target + ZIPLIST_HEADER_SIZE,\n                target_bytes - ZIPLIST_HEADER_SIZE);\n        memcpy(target, source, source_bytes - ZIPLIST_END_SIZE);\n    }\n    ZIPLIST_BYTES(target) = intrev32ifbe(zlbytes);\n    ZIPLIST_LENGTH(target) = intrev16ifbe(zllength);\n    ZIPLIST_TAIL_OFFSET(target) = intrev32ifbe(\n                                   (first_bytes - ZIPLIST_END_SIZE) +\n                                   (second_offset - ZIPLIST_HEADER_SIZE));\n    target = __ziplistCascadeUpdate(target, target+first_offset);\n    if (append) {\n        zfree(*second);\n        *second = NULL;\n        *first = target;\n    } else {\n        zfree(*first);\n        *first = NULL;\n        *second = target;\n    }\n    return target;\n}", "target": 0}
{"code": "void virtio_config_writeb(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint8_t val = data;\n    if (addr > (vdev->config_len - sizeof(val)))\n        return;\n    stb_p(vdev->config + addr, val);\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}", "target": 1}
{"code": "void lcdSetPixels_ArrayBuffer_flat(JsGraphics *gfx, short x, short y, short pixelCount, unsigned int col) {\n  unsigned char *ptr = (unsigned char*)gfx->backendData;\n  unsigned int idx = lcdGetPixelIndex_ArrayBuffer(gfx,x,y,pixelCount);\n  ptr += idx>>3;\n  unsigned int whiteMask = (1U<<gfx->data.bpp)-1;\n  bool shortCut = (col==0 || (col&whiteMask)==whiteMask) && (!(gfx->data.flags&JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE)); \n  while (pixelCount--) { \n    if (gfx->data.bpp&7) {\n      idx = idx & 7;\n      if (shortCut && idx==0) {\n        int wholeBytes = (gfx->data.bpp*(pixelCount+1)) >> 3;\n        if (wholeBytes) {\n          char c = (char)(col?0xFF:0);\n          pixelCount = (short)(pixelCount+1 - (wholeBytes*8/gfx->data.bpp));\n          while (wholeBytes--) {\n            *ptr = c;\n            ptr++;\n          }\n          continue;\n        }\n      }\n      unsigned int mask = (unsigned int)(1<<gfx->data.bpp)-1;\n      unsigned int existing = (unsigned int)*ptr;\n      unsigned int bitIdx = (gfx->data.flags & JSGRAPHICSFLAGS_ARRAYBUFFER_MSB) ? 8-(idx+gfx->data.bpp) : idx;\n      assert(ptr>=gfx->backendData && ptr<((char*)gfx->backendData + graphicsGetMemoryRequired(gfx)));\n      *ptr = (char)((existing&~(mask<<bitIdx)) | ((col&mask)<<bitIdx));\n      if (gfx->data.flags & JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE) {\n        ptr++;\n      } else {\n        idx += gfx->data.bpp;\n        if (idx>=8) ptr++;\n      }\n    } else { \n      int i;\n      for (i=0;i<gfx->data.bpp;i+=8) {\n        *ptr = (char)(col >> i);\n        ptr++;\n      }\n    }\n  }\n}", "target": 0}
{"code": "finish_stop(int stop_count)\n{\n\tif (tracehook_notify_jctl(stop_count == 0, CLD_STOPPED)) {\n\t\tread_lock(&tasklist_lock);\n\t\tdo_notify_parent_cldstop(current, CLD_STOPPED);\n\t\tread_unlock(&tasklist_lock);\n\t}\n\tdo {\n\t\tschedule();\n\t} while (try_to_freeze());\n\tcurrent->exit_code = 0;\n}", "target": 0}
{"code": "wsemul_vt100_output_dcs(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tu_int newstate = VT100_EMUL_STATE_DCS;\n\tswitch (instate->inchar) {\n\tcase '0': case '1': case '2': case '3': case '4':\n\tcase '5': case '6': case '7': case '8': case '9':\n\t\tif (edp->nargs > VT100_EMUL_NARGS - 1)\n\t\t\tbreak;\n\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\tcase ';': \n\t\tedp->nargs++;\n\t\tbreak;\n\tdefault:\n\t\tedp->nargs++;\n\t\tif (edp->nargs > VT100_EMUL_NARGS) {\n#ifdef VT100_DEBUG\n\t\t\tprintf(\"vt100: too many arguments\\n\");\n#endif\n\t\t\tedp->nargs = VT100_EMUL_NARGS;\n\t\t}\n\t\tnewstate = VT100_EMUL_STATE_STRING;\n\t\tswitch (instate->inchar) {\n\t\tcase '$':\n\t\t\tnewstate = VT100_EMUL_STATE_DCS_DOLLAR;\n\t\t\tbreak;\n\t\tcase '{': \t\n\t\tcase '!': \n\t\tcase '|': \n#ifdef VT100_PRINTNOTIMPL\n\t\t\tprintf(\"DCS%c ignored\\n\", (char)instate->inchar);\n#endif\n\t\t\tbreak;\n\t\tdefault:\n#ifdef VT100_PRINTUNKNOWN\n\t\t\tprintf(\"DCS %x (%d, %d) unknown\\n\", instate->inchar,\n\t\t\t    ARG(0), ARG(1));\n#endif\n\t\t\tbreak;\n\t\t}\n\t}\n\tedp->state = newstate;\n\treturn 0;\n}", "target": 1}
{"code": "static void umocktypes_free_bool_ptr(bool** value)\n{\n    if (*value != NULL)\n    {\n        my_gballoc_free(*value);\n    }\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    INDEX_TYPE first_dimension;\n    const Tensor first_partition_tensor =\n        context->input(kFirstPartitionInputIndex);\n    OP_REQUIRES(context, first_partition_tensor.NumElements() > 0,\n                errors::InvalidArgument(\"Invalid first partition input. Tensor \"\n                                        \"requires at least one element.\"));\n    OP_REQUIRES_OK(context, GetFirstDimensionSize(context, &first_dimension));\n    vector<INDEX_TYPE> output_size;\n    OP_REQUIRES_OK(context,\n                   CalculateOutputSize(first_dimension, context, &output_size));\n    vector<INDEX_TYPE> multiplier;\n    multiplier.resize(ragged_rank_ + 1);\n    multiplier[multiplier.size() - 1] = 1;\n    for (int i = multiplier.size() - 2; i >= 0; --i) {\n      multiplier[i] = multiplier[i + 1] * output_size[i + 1];\n    }\n    TensorShape output_shape;\n    OP_REQUIRES_OK(context,\n                   TensorShapeUtils::MakeShape(output_size, &output_shape));\n    Tensor* output_tensor = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, output_shape, &output_tensor));\n    const INDEX_TYPE full_size = multiplier[0] * output_size[0];\n    if (full_size > 0) {\n      vector<INDEX_TYPE> output_index, new_output_index;\n      int nvals = context->input(kValueInputIndex).shape().dim_size(0);\n      output_index.reserve(nvals);\n      new_output_index.reserve(nvals);\n      CalculateFirstParentOutputIndex(first_dimension, multiplier[0],\n                                      output_size[0], &output_index);\n      for (int i = 1; i <= ragged_rank_; ++i) {\n        OP_REQUIRES_OK(context, CalculateOutputIndex(\n                                    context, i - 1, output_index, multiplier[i],\n                                    output_size[i], &new_output_index));\n        output_index.swap(new_output_index);\n        new_output_index.clear();\n      }\n      SetOutput(context, ragged_rank_, output_index, output_tensor);\n    }\n  }", "target": 0}
{"code": "spnego_gss_pseudo_random(OM_uint32 *minor_status,\n\t\t\t gss_ctx_id_t context,\n\t\t\t int prf_key,\n\t\t\t const gss_buffer_t prf_in,\n\t\t\t ssize_t desired_output_len,\n\t\t\t gss_buffer_t prf_out)\n{\n\tOM_uint32 ret;\n\tret = gss_pseudo_random(minor_status,\n\t\t\t\tcontext,\n\t\t\t\tprf_key,\n\t\t\t\tprf_in,\n\t\t\t\tdesired_output_len,\n\t\t\t\tprf_out);\n        return (ret);\n}", "target": 1}
{"code": "        int          GetU16BE (int nPos, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos + 1 >= m_nLen)\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            int nRes = m_sFile[ nPos ];\n            nRes = (nRes << 8) + m_sFile[ nPos + 1 ];\n            return nRes;\n        }", "target": 1}
{"code": "    bool read(ReadonlyBytes buffer)\n    {\n        auto fields_size = sizeof(LocalFileHeader) - (sizeof(u8*) * 3);\n        if (buffer.size() < fields_size)\n            return false;\n        if (memcmp(buffer.data(), local_file_header_signature, sizeof(local_file_header_signature)) != 0)\n            return false;\n        memcpy(reinterpret_cast<void*>(&minimum_version), buffer.data() + sizeof(local_file_header_signature), fields_size);\n        name = buffer.data() + sizeof(local_file_header_signature) + fields_size;\n        extra_data = name + name_length;\n        compressed_data = extra_data + extra_data_length;\n        return true;\n    }", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    OpInputList indices_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"indices\", &indices_list_in));\n    OpInputList values_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"values\", &values_list_in));\n    OpInputList shapes_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"shapes\", &shapes_list_in));\n    OpInputList dense_list_in;\n    OP_REQUIRES_OK(context,\n                   context->input_list(\"dense_inputs\", &dense_list_in));\n    OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,\n                                          shapes_list_in, dense_list_in));\n    const Tensor* sep_t;\n    OP_REQUIRES_OK(context, context->input(\"sep\", &sep_t));\n    const tstring separator = sep_t->scalar<tstring>()();\n    std::vector<std::unique_ptr<ColumnInterface<tstring>>> columns =\n        GenerateColumnsFromInput<tstring>(indices_list_in, values_list_in,\n                                          shapes_list_in, dense_list_in);\n    Tensor* indices_out;\n    Tensor* values_out;\n    Tensor* shape_out;\n    const int64 batch_size = CalculateBatchSize(shapes_list_in, dense_list_in);\n    std::vector<int64> output_start_indices(batch_size);\n    OP_REQUIRES_OK(\n        context,\n        CreateOutputTensors(columns, batch_size, context, &indices_out,\n                            &values_out, &shape_out, &output_start_indices));\n    StringCrosser<tstring> crosser(columns, 0, 0, separator);\n    OutputUpdater<tstring> updater(output_start_indices, indices_out,\n                                   values_out);\n    auto do_work = [&columns, crosser, updater](int64 begin, int64 end) {\n      for (int b = begin; b < end; b++) {\n        ProductIterator<tstring> product_iterator(columns, b);\n        int64 cross_count = 0;\n        while (product_iterator.HasNext()) {\n          const auto permutation = product_iterator.Next();\n          updater.Update(b, cross_count,\n                         crosser.Generate(b, permutation, false));\n          cross_count++;\n        }\n      }\n    };\n    auto* worker_threads = context->device()->tensorflow_cpu_worker_threads();\n    const int kCostPerUnit = 5000 * indices_list_in.size();\n    Shard(worker_threads->num_threads, worker_threads->workers, batch_size,\n          kCostPerUnit, do_work);\n  }", "target": 1}
{"code": "int vp9_alloc_context_buffers(VP9_COMMON *cm, int width, int height) {\n  int new_mi_size;\n  vp9_set_mb_mi(cm, width, height);\n  new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n  if (cm->mi_alloc_size < new_mi_size) {\n    cm->free_mi(cm);\n    if (cm->alloc_mi(cm, new_mi_size)) goto fail;\n  }\n  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {\n    free_seg_map(cm);\n    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;\n  }\n  if (cm->above_context_alloc_cols < cm->mi_cols) {\n    vpx_free(cm->above_context);\n    cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(\n        2 * mi_cols_aligned_to_sb(cm->mi_cols) * MAX_MB_PLANE,\n        sizeof(*cm->above_context));\n    if (!cm->above_context) goto fail;\n    vpx_free(cm->above_seg_context);\n    cm->above_seg_context = (PARTITION_CONTEXT *)vpx_calloc(\n        mi_cols_aligned_to_sb(cm->mi_cols), sizeof(*cm->above_seg_context));\n    if (!cm->above_seg_context) goto fail;\n    cm->above_context_alloc_cols = cm->mi_cols;\n  }\n  if (vp9_alloc_loop_filter(cm)) goto fail;\n  return 0;\nfail:\n  vp9_set_mb_mi(cm, 0, 0);\n  vp9_free_context_buffers(cm);\n  return 1;\n}", "target": 1}
{"code": "flac_read_loop (SF_PRIVATE *psf, unsigned len)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\tpflac->pos = 0 ;\n\tpflac->len = len ;\n\tpflac->remain = len ;\n\tif (pflac->frame != NULL && pflac->bufferpos < pflac->frame->header.blocksize)\n\t\tflac_buffer_copy (psf) ;\n\twhile (pflac->pos < pflac->len)\n\t{\tif (FLAC__stream_decoder_process_single (pflac->fsd) == 0)\n\t\t\tbreak ;\n\t\tif (FLAC__stream_decoder_get_state (pflac->fsd) >= FLAC__STREAM_DECODER_END_OF_STREAM)\n\t\t\tbreak ;\n\t\t} ;\n\tpflac->ptr = NULL ;\n\treturn pflac->pos ;\n} ", "target": 1}
{"code": "void EditorClientBlackBerry::learnWord(const WTF::String&)\n{\n    notImplemented();\n}", "target": 0}
{"code": "struct ipv6_txoptions *ipv6_update_options(struct sock *sk,\n\t\t\t\t\t   struct ipv6_txoptions *opt)\n{\n\tif (inet_sk(sk)->is_icsk) {\n\t\tif (opt &&\n\t\t    !((1 << sk->sk_state) & (TCPF_LISTEN | TCPF_CLOSE)) &&\n\t\t    inet_sk(sk)->inet_daddr != LOOPBACK4_IPV6) {\n\t\t\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\t\t\ticsk->icsk_ext_hdr_len = opt->opt_flen + opt->opt_nflen;\n\t\t\ticsk->icsk_sync_mss(sk, icsk->icsk_pmtu_cookie);\n\t\t}\n\t}\n\topt = xchg(&inet6_sk(sk)->opt, opt);\n\tsk_dst_reset(sk);\n\treturn opt;\n}", "target": 1}
{"code": "static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int h)\n{\n    PadContext *s = inlink->dst->priv;\n    AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],\n                                         w + (s->w - s->in_w),\n                                         h + (s->h - s->in_h));\n    int plane;\n    if (!frame)\n        return NULL;\n    frame->width  = w;\n    frame->height = h;\n    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {\n        int hsub = s->draw.hsub[plane];\n        int vsub = s->draw.vsub[plane];\n        frame->data[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +\n                              (s->y >> vsub) * frame->linesize[plane];\n    }\n    return frame;\n}", "target": 1}
{"code": "  explicit SparseFillEmptyRowsGPUOp(OpKernelConstruction* context)\n      : AsyncOpKernel(context) {}", "target": 0}
{"code": "bool PackLinuxElf64::calls_crt1(Elf64_Rela const *rela, int sz)\n{\n    if (!dynsym || !dynstr) {\n        return false;\n    }\n    for (unsigned relnum= 0; 0 < sz; (sz -= sizeof(Elf64_Rela)), ++rela, ++relnum) {\n        unsigned const symnum = get_te64(&rela->r_info) >> 32;\n        char const *const symnam = get_dynsym_name(symnum, relnum);\n        if (0==strcmp(symnam, \"__libc_start_main\")  \n        ||  0==strcmp(symnam, \"__libc_init\")  \n        ||  0==strcmp(symnam, \"__uClibc_main\")\n        ||  0==strcmp(symnam, \"__uClibc_start_main\"))\n            return true;\n    }\n    return false;\n}", "target": 1}
{"code": "static void xen_free_irq(unsigned irq)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\tunsigned long flags;\n\tif (WARN_ON(!info))\n\t\treturn;\n\twrite_lock_irqsave(&evtchn_rwlock, flags);\n\tif (!list_empty(&info->eoi_list))\n\t\tlateeoi_list_del(info);\n\tlist_del(&info->list);\n\tset_info_for_irq(irq, NULL);\n\tWARN_ON(info->refcnt > 0);\n\twrite_unlock_irqrestore(&evtchn_rwlock, flags);\n\tkfree(info);\n\tif (irq < nr_legacy_irqs())\n\t\treturn;\n\tirq_free_desc(irq);\n}", "target": 0}
{"code": "void WriteFromUrlOperation::GetDownloadTarget(\n    const base::Closure& continuation) {\n  DCHECK_CURRENTLY_ON(BrowserThread::FILE);\n  if (IsCancelled()) {\n    return;\n  }\n  if (url_.ExtractFileName().empty()) {\n    if (!base::CreateTemporaryFileInDir(temp_dir_.GetPath(), &image_path_)) {\n      Error(error::kTempFileError);\n      return;\n    }\n  } else {\n    base::FilePath file_name =\n        base::FilePath::FromUTF8Unsafe(url_.ExtractFileName());\n    image_path_ = temp_dir_.GetPath().Append(file_name);\n  }\n  BrowserThread::PostTask(BrowserThread::FILE, FROM_HERE, continuation);\n}", "target": 0}
{"code": "njs_function_closure_value(njs_vm_t *vm, njs_value_t **scope, njs_index_t index,\n    void *start, void *end)\n{\n    njs_value_t  *value, *newval;\n    value = scope[njs_scope_index_value(index)];\n    if (start <= (void *) value && end > (void *) value) {\n        newval = njs_mp_alloc(vm->mem_pool, sizeof(njs_value_t));\n        if (njs_slow_path(newval == NULL)) {\n            njs_memory_error(vm);\n            return NULL;\n        }\n        *newval = *value;\n        value = newval;\n    }\n    scope[njs_scope_index_value(index)] = value;\n    return value;\n}", "target": 0}
{"code": "static int mongo_cursor_get_more( mongo_cursor *cursor ) {\n    int res;\n    if( cursor->limit > 0 && cursor->seen >= cursor->limit ) {\n        cursor->err = MONGO_CURSOR_EXHAUSTED;\n        return MONGO_ERROR;\n    }\n    else if( ! cursor->reply ) {\n        cursor->err = MONGO_CURSOR_INVALID;\n        return MONGO_ERROR;\n    }\n    else if( ! cursor->reply->fields.cursorID ) {\n        cursor->err = MONGO_CURSOR_EXHAUSTED;\n        return MONGO_ERROR;\n    }\n    else {\n        char *data;\n        int sl = strlen( cursor->ns )+1;\n        int limit = 0;\n        mongo_message *mm;\n        if( cursor->limit > 0 )\n            limit = cursor->limit - cursor->seen;\n        mm = mongo_message_create( 16 \n                                   +4 \n                                   +sl\n                                   +4 \n                                   +8 \n                                   , 0, 0, MONGO_OP_GET_MORE );\n        data = &mm->data;\n        data = mongo_data_append32( data, &ZERO );\n        data = mongo_data_append( data, cursor->ns, sl );\n        data = mongo_data_append32( data, &limit );\n        mongo_data_append64( data, &cursor->reply->fields.cursorID );\n        bson_free( cursor->reply );\n        res = mongo_message_send( cursor->conn, mm );\n        if( res != MONGO_OK ) {\n            mongo_cursor_destroy( cursor );\n            return MONGO_ERROR;\n        }\n        res = mongo_read_response( cursor->conn, &( cursor->reply ) );\n        if( res != MONGO_OK ) {\n            mongo_cursor_destroy( cursor );\n            return MONGO_ERROR;\n        }\n        cursor->current.data = NULL;\n        cursor->seen += cursor->reply->fields.num;\n        return MONGO_OK;\n    }\n}", "target": 1}
{"code": "MemoryRegion *memory_map_ptr(struct uc_struct *uc, hwaddr begin, size_t size, uint32_t perms, void *ptr)\n{\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n    memory_region_init_ram_ptr(uc, ram, size, ptr);\n    ram->perms = perms;\n    if (ram->addr == -1) {\n        return NULL;\n    }\n    memory_region_add_subregion(uc->system_memory, begin, ram);\n    if (uc->cpu) {\n        tlb_flush(uc->cpu);\n    }\n    return ram;\n}", "target": 1}
{"code": "bool allow_svhandler_flash_sector_num(int sector) {\n  for (const FlashSector *s = flash_sector_map; s->use != FLASH_INVALID; s++) {\n    if (s->sector == sector) return allow_svhandler_flash_sector(s);\n  }\n  return false;\n}", "target": 0}
{"code": "static inline void set_pte_at(struct mm_struct *mm, unsigned long addr,\n\t\t\t      pte_t *ptep, pte_t pte)\n{\n\tif (pte_valid_ng(pte)) {\n\t\tif (!pte_special(pte) && pte_exec(pte))\n\t\t\t__sync_icache_dcache(pte, addr);\n\t\tif (pte_dirty(pte) && pte_write(pte))\n\t\t\tpte_val(pte) &= ~PTE_RDONLY;\n\t\telse\n\t\t\tpte_val(pte) |= PTE_RDONLY;\n\t}\n\tset_pte(ptep, pte);\n}", "target": 1}
{"code": "spnego_gss_unwrap(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t context_handle,\n\t\tgss_buffer_t input_message_buffer,\n\t\tgss_buffer_t output_message_buffer,\n\t\tint *conf_state,\n\t\tgss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tret = gss_unwrap(minor_status,\n\t\t\tcontext_handle,\n\t\t\tinput_message_buffer,\n\t\t\toutput_message_buffer,\n\t\t\tconf_state,\n\t\t\tqop_state);\n\treturn (ret);\n}", "target": 1}
{"code": "static void diff_bytes_c(uint8_t *dst, const uint8_t *src1, const uint8_t *src2, int w){\n    long i;\n#if !HAVE_FAST_UNALIGNED\n    if((long)src2 & (sizeof(long)-1)){\n        for(i=0; i+7<w; i+=8){\n            dst[i+0] = src1[i+0]-src2[i+0];\n            dst[i+1] = src1[i+1]-src2[i+1];\n            dst[i+2] = src1[i+2]-src2[i+2];\n            dst[i+3] = src1[i+3]-src2[i+3];\n            dst[i+4] = src1[i+4]-src2[i+4];\n            dst[i+5] = src1[i+5]-src2[i+5];\n            dst[i+6] = src1[i+6]-src2[i+6];\n            dst[i+7] = src1[i+7]-src2[i+7];\n        }\n    }else\n#endif\n    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){\n        long a = *(long*)(src1+i);\n        long b = *(long*)(src2+i);\n        *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);\n    }\n    for(; i<w; i++)\n        dst[i+0] = src1[i+0]-src2[i+0];\n}", "target": 1}
{"code": "__xfs_inode_free(\n\tstruct xfs_inode\t*ip)\n{\n\tASSERT(atomic_read(&ip->i_pincount) == 0);\n\tXFS_STATS_DEC(ip->i_mount, vn_active);\n\tcall_rcu(&VFS_I(ip)->i_rcu, xfs_inode_free_callback);\n}", "target": 0}
{"code": "decodeJsonStructure(void *dst, const UA_DataType *type, CtxJson *ctx, \n                    ParseCtx *parseCtx, UA_Boolean moveToken) {\n    (void) moveToken;\n    if(ctx->depth > UA_JSON_ENCODING_MAX_RECURSION)\n        return UA_STATUSCODE_BADENCODINGERROR;\n    ctx->depth++;\n    uintptr_t ptr = (uintptr_t)dst;\n    status ret = UA_STATUSCODE_GOOD;\n    u8 membersSize = type->membersSize;\n    const UA_DataType *typelists[2] = { UA_TYPES, &type[-type->typeIndex] };\n    UA_STACKARRAY(DecodeEntry, entries, membersSize);\n    for(size_t i = 0; i < membersSize && ret == UA_STATUSCODE_GOOD; ++i) {\n        const UA_DataTypeMember *m = &type->members[i];\n        const UA_DataType *mt = &typelists[!m->namespaceZero][m->memberTypeIndex];\n        entries[i].type = mt;\n        if(!m->isArray) {\n            ptr += m->padding;\n            entries[i].fieldName = m->memberName;\n            entries[i].fieldPointer = (void*)ptr;\n            entries[i].function = decodeJsonJumpTable[mt->typeKind];\n            entries[i].found = false;\n            ptr += mt->memSize;\n        } else {\n            ptr += m->padding;\n            ptr += sizeof(size_t);\n            entries[i].fieldName = m->memberName;\n            entries[i].fieldPointer = (void*)ptr;\n            entries[i].function = (decodeJsonSignature)Array_decodeJson;\n            entries[i].found = false;\n            ptr += sizeof(void*);\n        }\n    }\n    ret = decodeFields(ctx, parseCtx, entries, membersSize, type);\n    ctx->depth--;\n    return ret;\n}", "target": 1}
{"code": "spnego_gss_process_context_token(\n\t\t\t\tOM_uint32\t*minor_status,\n\t\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\t\tconst gss_buffer_t token_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_process_context_token(minor_status,\n\t\t\t\t\tcontext_handle,\n\t\t\t\t\ttoken_buffer);\n\treturn (ret);\n}", "target": 1}
{"code": "TEST_F(RaggedRangeOpTest, RangeSizeOverflow) {\n  BuildRaggedRangeGraph<float>();\n  AddInputFromArray<float>(TensorShape({2}), {1.1, 0.1});    \n  AddInputFromArray<float>(TensorShape({2}), {10.0, 1e10});  \n  AddInputFromArray<float>(TensorShape({2}), {1, 1e-10});    \n  EXPECT_EQ(absl::StrCat(\"Requires ((limit - start) / delta) <= \",\n                         std::numeric_limits<int64_t>::max()),\n            RunOpKernel().error_message());\n}", "target": 0}
{"code": "    bool isPrivate() const { return is_private; }", "target": 0}
{"code": "static void __exit pcd_exit(void)\n{\n\tstruct pcd_unit *cd;\n\tint unit;\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tif (!cd->disk)\n\t\t\tcontinue;\n\t\tif (cd->present) {\n\t\t\tdel_gendisk(cd->disk);\n\t\t\tpi_release(cd->pi);\n\t\t\tunregister_cdrom(&cd->info);\n\t\t}\n\t\tblk_cleanup_queue(cd->disk->queue);\n\t\tblk_mq_free_tag_set(&cd->tag_set);\n\t\tput_disk(cd->disk);\n\t}\n\tunregister_blkdev(major, name);\n\tpi_unregister_driver(par_drv);\n}", "target": 0}
{"code": "bool IsIdentityConsumingSwitch(const MutableGraphView& graph,\n                               const NodeDef& node) {\n  if ((IsIdentity(node) || IsIdentityNSingleInput(node)) &&\n      node.input_size() > 0) {\n    TensorId tensor_id = ParseTensorName(node.input(0));\n    if (IsTensorIdControlling(tensor_id)) {\n      return false;\n    }\n    NodeDef* input_node = graph.GetNode(tensor_id.node());\n    if (input_node == nullptr) {\n      return false;\n    }\n    return IsSwitch(*input_node);\n  }\n  return false;\n}", "target": 0}
{"code": "static void JP2WarningHandler(const char *message,void *client_data)\n{\n  ExceptionInfo\n    *exception;\n  exception=(ExceptionInfo *) client_data;\n  (void) ThrowMagickException(exception,GetMagickModule(),CoderWarning,\n    message,\"`%s'\",\"OpenJP2\");\n}", "target": 0}
{"code": "    uint32_t TiffEntryBase::doWriteImage(IoWrapper&,\n                                         ByteOrder ) const\n    {\n        return 0;\n    } ", "target": 0}
{"code": "isis_print_id(const uint8_t *cp, int id_len)\n{\n    int i;\n    static char id[sizeof(\"xxxx.xxxx.xxxx.yy-zz\")];\n    char *pos = id;\n    for (i = 1; i <= SYSTEM_ID_LEN; i++) {\n        snprintf(pos, sizeof(id) - (pos - id), \"%02x\", *cp++);\n\tpos += strlen(pos);\n\tif (i == 2 || i == 4)\n\t    *pos++ = '.';\n\t}\n    if (id_len >= NODE_ID_LEN) {\n        snprintf(pos, sizeof(id) - (pos - id), \".%02x\", *cp++);\n\tpos += strlen(pos);\n    }\n    if (id_len == LSP_ID_LEN)\n        snprintf(pos, sizeof(id) - (pos - id), \"-%02x\", *cp);\n    return (id);\n}", "target": 1}
{"code": "  void ComputeAsync(OpKernelContext* c, DoneCallback done) override {\n    auto col_params = new CollectiveParams();\n    auto done_with_cleanup = [col_params, done = std::move(done)]() {\n      done();\n      col_params->Unref();\n    };\n    core::RefCountPtr<CollectiveGroupResource> resource;\n    OP_REQUIRES_OK_ASYNC(c, LookupResource(c, HandleFromInput(c, 1), &resource),\n                         done);\n    Tensor group_assignment = c->input(2);\n    OP_REQUIRES_OK_ASYNC(\n        c,\n        FillCollectiveParams(col_params, group_assignment, REDUCTION_COLLECTIVE,\n                             resource.get()),\n        done);\n    col_params->instance.shape = c->input(0).shape();\n    col_params->merge_op = merge_op_.get();\n    col_params->final_op = final_op_.get();\n    VLOG(1) << \"CollectiveReduceV3 group_size \" << col_params->group.group_size\n            << \" group_key \" << col_params->group.group_key << \" instance_key \"\n            << col_params->instance.instance_key;\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK_ASYNC(c,\n                         c->forward_input_or_allocate_output(\n                             {0}, 0, col_params->instance.shape, &output),\n                         done_with_cleanup);\n    Run(c, col_params, std::move(done_with_cleanup));\n  }", "target": 1}
{"code": "str_to_archive_type (const char *str)\n{\n\tg_return_val_if_fail (str != NULL, EV_ARCHIVE_TYPE_NONE);\n\tif (g_strcmp0 (str, \"rar\") == 0)\n\t\treturn EV_ARCHIVE_TYPE_RAR;\n\tif (g_strcmp0 (str, \"zip\") == 0)\n\t\treturn EV_ARCHIVE_TYPE_ZIP;\n\tif (g_strcmp0 (str, \"7z\") == 0)\n\t\treturn EV_ARCHIVE_TYPE_7Z;\n\tif (g_strcmp0 (str, \"tar\") == 0)\n\t\treturn EV_ARCHIVE_TYPE_TAR;\n\tg_warning (\"Archive type '%s' not supported\", str);\n\treturn EV_ARCHIVE_TYPE_NONE;\n}", "target": 0}
{"code": "static inline int tcp_in_quickack_mode(const struct sock *sk)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\treturn icsk->icsk_ack.quick && !icsk->icsk_ack.pingpong;\n}", "target": 0}
{"code": "static int lua_ap_usleep(lua_State *L)\n{\n    apr_interval_time_t msec;\n    luaL_checktype(L, 1, LUA_TNUMBER);\n    msec = (apr_interval_time_t)lua_tonumber(L, 1);\n    apr_sleep(msec);\n    return 0;\n}", "target": 0}
{"code": "static void vmx_disable_intercept_msr_read_x2apic(u32 msr)\n{\n\t__vmx_disable_intercept_for_msr(vmx_msr_bitmap_legacy_x2apic,\n\t\t\tmsr, MSR_TYPE_R);\n\t__vmx_disable_intercept_for_msr(vmx_msr_bitmap_longmode_x2apic,\n\t\t\tmsr, MSR_TYPE_R);\n}", "target": 0}
{"code": "int LightProcess::pclose(FILE *f) {\n  if (!Available()) {\n    return ::pclose(f);\n  }\n  int id = GetId();\n  Lock lock(g_procs[id].m_procMutex);\n  std::map<int64_t, int64_t>::iterator it = g_procs[id].m_popenMap.find((int64_t)f);\n  if (it == g_procs[id].m_popenMap.end()) {\n    return ::pclose(f);\n  }\n  int64_t f2 = it->second;\n  g_procs[id].m_popenMap.erase((int64_t)f);\n  fclose(f);\n  fprintf(g_procs[id].m_fout, \"pclose\\n%\" PRId64 \"\\n\", f2);\n  fflush(g_procs[id].m_fout);\n  char buf[BUFFER_SIZE];\n  read_buf(g_procs[id].m_fin, buf);\n  int ret = -1;\n  sscanf(buf, \"%d\", &ret);\n  if (ret < 0) {\n    read_buf(g_procs[id].m_fin, buf);\n    sscanf(buf, \"%d\", &errno);\n  }\n  return ret;\n}", "target": 1}
{"code": "    void CFontFileType1::DecryptEexec(unsigned char** ppEexecBuffer, int nLen)\n    {\n        unsigned char *sCur = (unsigned char*)(*ppEexecBuffer);\n        while( sCur < (unsigned char*)(*ppEexecBuffer) + nLen && ( ' ' == *sCur || '\\t' == *sCur || '\\r' == *sCur || '\\n' == *sCur ) )\n            ++sCur;\n        bool bASCII = false;\n        if ( isxdigit( sCur[0] ) && isxdigit( sCur[1] ) && isxdigit( sCur[2] ) && isxdigit( sCur[3] ) )\n            bASCII = true;\n        if ( bASCII )\n            ASCIIHexDecode( &sCur, sCur + nLen, sCur, nLen );\n        unsigned short ushKey = 55665U;\n        EexecDecode( &sCur, *ppEexecBuffer + nLen, sCur, nLen, &ushKey );\n    }", "target": 1}
{"code": "void out_string(conn *c, const char *str) {\n    size_t len;\n    mc_resp *resp = c->resp;\n    assert(c != NULL);\n    resp_reset(resp);\n    if (c->noreply) {\n        resp->skip = true;\n        if (settings.verbose > 1)\n            fprintf(stderr, \">%d NOREPLY %s\\n\", c->sfd, str);\n        conn_set_state(c, conn_new_cmd);\n        return;\n    }\n    if (settings.verbose > 1)\n        fprintf(stderr, \">%d %s\\n\", c->sfd, str);\n    len = strlen(str);\n    if ((len + 2) > WRITE_BUFFER_SIZE) {\n        str = \"SERVER_ERROR output line too long\";\n        len = strlen(str);\n    }\n    memcpy(resp->wbuf, str, len);\n    memcpy(resp->wbuf + len, \"\\r\\n\", 2);\n    resp_add_iov(resp, resp->wbuf, len + 2);\n    conn_set_state(c, conn_new_cmd);\n    return;\n}", "target": 1}
{"code": "static char ** split(const char *arg, const char *delim) {\n  char *copy = dupstr(arg);\n  char **result = NULL;\n  int i = 0;\n  for (char *cptr = strtok(copy, delim); cptr; cptr = strtok(NULL, delim)) {\n    char **tmp = realloc (result, sizeof *result * (i + 1));\n    if (!tmp && result) {\n      while (i > 0) {\n\tfree(result[--i]);\n      }\n      free(result);\n      free(copy);\n      return NULL;\n    }\n    result = tmp;\n    result[i++] = dupstr(cptr);\n  }\n  free(copy);\n  if (i) {\n    char **tmp = realloc(result, sizeof *result * (i + 1));\n    if (!tmp) {\n      while (i > 0) {\n\tfree(result[--i]);\n      }\n      free(result);\n      free(copy);\n      return NULL;\n    }\n    result = tmp;\n    result[i++] = NULL;\n  }\n  return result;\n}", "target": 1}
{"code": "manuf_name_lookup(const guint8 *addr)\n{\n    guint32       manuf_key;\n    guint8       oct;\n    hashmanuf_t  *manuf_value;\n    manuf_key = addr[0];\n    manuf_key = manuf_key<<8;\n    oct = addr[1];\n    manuf_key = manuf_key | oct;\n    manuf_key = manuf_key<<8;\n    oct = addr[2];\n    manuf_key = manuf_key | oct;\n    manuf_value = (hashmanuf_t*)wmem_map_lookup(manuf_hashtable, GUINT_TO_POINTER(manuf_key));\n    if (manuf_value != NULL) {\n        return manuf_value;\n    }\n    if ((manuf_key & 0x00010000) != 0) {\n        manuf_key &= 0x00FEFFFF;\n        manuf_value = (hashmanuf_t*)wmem_map_lookup(manuf_hashtable, GUINT_TO_POINTER(manuf_key));\n        if (manuf_value != NULL) {\n            return manuf_value;\n        }\n    }\n    const char *short_name, *long_name;\n    short_name = ws_manuf_lookup_str(addr, &long_name);\n    if (short_name != NULL) {\n        return manuf_hash_new_entry(addr, short_name, long_name);\n    }\n    return manuf_hash_new_entry(addr, NULL, NULL);\n} ", "target": 1}
{"code": "static void free_copy_partition_data(VP9_COMP *cpi) {\n  vpx_free(cpi->prev_partition);\n  cpi->prev_partition = NULL;\n  vpx_free(cpi->prev_segment_id);\n  cpi->prev_segment_id = NULL;\n  vpx_free(cpi->prev_variance_low);\n  cpi->prev_variance_low = NULL;\n  vpx_free(cpi->copied_frame_cnt);\n  cpi->copied_frame_cnt = NULL;\n}", "target": 0}
{"code": "FNAME(prefetch_gpte)(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t     u64 *spte, pt_element_t gpte, bool no_dirty_log)\n{\n\tstruct kvm_memory_slot *slot;\n\tunsigned pte_access;\n\tgfn_t gfn;\n\tkvm_pfn_t pfn;\n\tif (FNAME(prefetch_invalid_gpte)(vcpu, sp, spte, gpte))\n\t\treturn false;\n\tpgprintk(\"%s: gpte %llx spte %p\\n\", __func__, (u64)gpte, spte);\n\tgfn = gpte_to_gfn(gpte);\n\tpte_access = sp->role.access & FNAME(gpte_access)(gpte);\n\tFNAME(protect_clean_gpte)(vcpu->arch.mmu, &pte_access, gpte);\n\tslot = gfn_to_memslot_dirty_bitmap(vcpu, gfn,\n\t\t\tno_dirty_log && (pte_access & ACC_WRITE_MASK));\n\tif (!slot)\n\t\treturn false;\n\tpfn = gfn_to_pfn_memslot_atomic(slot, gfn);\n\tif (is_error_pfn(pfn))\n\t\treturn false;\n\tmmu_set_spte(vcpu, slot, spte, pte_access, gfn, pfn, NULL);\n\tkvm_release_pfn_clean(pfn);\n\treturn true;\n}", "target": 0}
{"code": "htc_request_check_hdrs(struct sess *sp, struct http *hp)\n{\n\tint u;\n\tint seen_host = 0;\n\tint seen_cl = 0;\n\tfor (u = HTTP_HDR_FIRST; u < hp->nhd; u++) {\n\t\tif (hp->hd[u].b == NULL)\n\t\t\tcontinue;\n\t\tAN(hp->hd[u].b);\n\t\tAN(hp->hd[u].e);\n\t\tif (http_IsHdr(&hp->hd[u], H_Host)) {\n\t\t\tif (seen_host) {\n\t\t\t\tWSP(sp, SLT_Error, \"Duplicated Host header\");\n\t\t\t\treturn (400);\n\t\t\t}\n\t\t\tseen_host = 1;\n\t\t}\n\t\tif (http_IsHdr(&hp->hd[u], H_Content_Length)) {\n\t\t\tif (seen_cl) {\n\t\t\t\tWSP(sp, SLT_Error,\n\t\t\t\t    \"Duplicated Content-Length header\");\n\t\t\t\treturn (400);\n\t\t\t}\n\t\t\tseen_cl = 1;\n\t\t}\n\t}\n\treturn (0);\n}", "target": 0}
{"code": "void SmallVectorBase::grow_pod(void *FirstEl, size_t MinCapacity,\n                               size_t TSize) {\n  if (MinCapacity > UINT32_MAX)\n    report_bad_alloc_error(\"SmallVector capacity overflow during allocation\");\n  size_t NewCapacity = 2 * capacity() + 1; \n  NewCapacity =\n      std::min(std::max(NewCapacity, MinCapacity), size_t(UINT32_MAX));\n  void *NewElts;\n  if (BeginX == FirstEl) {\n    NewElts = safe_malloc(NewCapacity * TSize);\n    memcpy(NewElts, this->BeginX, size() * TSize);\n  } else {\n    NewElts = safe_realloc(this->BeginX, NewCapacity * TSize);\n  }\n  this->BeginX = NewElts;\n  this->Capacity = NewCapacity;\n}", "target": 1}
{"code": "static s32 adpt_i2o_hrt_get(adpt_hba* pHba)\n{\n\tu32 msg[6];\n\tint ret, size = sizeof(i2o_hrt);\n\tdo {\n\t\tif (pHba->hrt == NULL) {\n\t\t\tpHba->hrt = dma_alloc_coherent(&pHba->pDev->dev,\n\t\t\t\t\tsize, &pHba->hrt_pa, GFP_KERNEL);\n\t\t\tif (pHba->hrt == NULL) {\n\t\t\t\tprintk(KERN_CRIT \"%s: Hrt Get failed; Out of memory.\\n\", pHba->name);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\t\tmsg[0]= SIX_WORD_MSG_SIZE| SGL_OFFSET_4;\n\t\tmsg[1]= I2O_CMD_HRT_GET<<24 | HOST_TID<<12 | ADAPTER_TID;\n\t\tmsg[2]= 0;\n\t\tmsg[3]= 0;\n\t\tmsg[4]= (0xD0000000 | size);    \n\t\tmsg[5]= (u32)pHba->hrt_pa;\t\n\t\tif ((ret = adpt_i2o_post_wait(pHba, msg, sizeof(msg),20))) {\n\t\t\tprintk(KERN_ERR \"%s: Unable to get HRT (status=%#10x)\\n\", pHba->name, ret);\n\t\t\treturn ret;\n\t\t}\n\t\tif (pHba->hrt->num_entries * pHba->hrt->entry_len << 2 > size) {\n\t\t\tint newsize = pHba->hrt->num_entries * pHba->hrt->entry_len << 2;\n\t\t\tdma_free_coherent(&pHba->pDev->dev, size,\n\t\t\t\tpHba->hrt, pHba->hrt_pa);\n\t\t\tsize = newsize;\n\t\t\tpHba->hrt = NULL;\n\t\t}\n\t} while(pHba->hrt == NULL);\n\treturn 0;\n}                                                                                                                                       ", "target": 1}
{"code": "PJ_DEF(void) pj_scan_get_until_ch( pj_scanner *scanner, \n\t\t\t\t   int until_char, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n    if (s >= scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    while (PJ_SCAN_CHECK_EOF(s) && *s != until_char) {\n\t++s;\n    }\n    pj_strset3(out, scanner->curptr, s);\n    scanner->curptr = s;\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}", "target": 1}
{"code": "mptctl_readtest (unsigned long arg)\n{\n\tstruct mpt_ioctl_test __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_test\t karg;\n\tMPT_ADAPTER *ioc;\n\tint iocnum;\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_test))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_readtest - \"\n\t\t\t\"Unable to read in mpt_ioctl_test struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_readtest() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_readtest called.\\n\",\n\t    ioc->name));\n#ifdef MFCNT\n\tkarg.chip_type = ioc->mfcnt;\n#else\n\tkarg.chip_type = ioc->pcidev->device;\n#endif\n\tstrncpy (karg.name, ioc->name, MPT_MAX_NAME);\n\tkarg.name[MPT_MAX_NAME-1]='\\0';\n\tstrncpy (karg.product, ioc->prod_name, MPT_PRODUCT_LENGTH);\n\tkarg.product[MPT_PRODUCT_LENGTH-1]='\\0';\n\tif (copy_to_user((char __user *)arg, &karg, sizeof(struct mpt_ioctl_test))) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_readtest - \"\n\t\t\t\"Unable to write out mpt_ioctl_test struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void settings_init(void) {\n    settings.use_cas = true;\n    settings.access = 0700;\n    settings.port = 11211;\n    settings.udpport = 11211;\n    settings.inter = NULL;\n    settings.maxbytes = 64 * 1024 * 1024; \n    settings.maxconns = 1024;         \n    settings.verbose = 0;\n    settings.oldest_live = 0;\n    settings.oldest_cas = 0;          \n    settings.evict_to_free = 1;       \n    settings.socketpath = NULL;       \n    settings.factor = 1.25;\n    settings.chunk_size = 48;         \n    settings.num_threads = 4;         \n    settings.num_threads_per_udp = 0;\n    settings.prefix_delimiter = ':';\n    settings.detail_enabled = 0;\n    settings.reqs_per_event = 20;\n    settings.backlog = 1024;\n    settings.binding_protocol = negotiating_prot;\n    settings.item_size_max = 1024 * 1024; \n    settings.slab_page_size = 1024 * 1024; \n    settings.slab_chunk_size_max = settings.slab_page_size / 2;\n    settings.sasl = false;\n    settings.maxconns_fast = true;\n    settings.lru_crawler = false;\n    settings.lru_crawler_sleep = 100;\n    settings.lru_crawler_tocrawl = 0;\n    settings.lru_maintainer_thread = false;\n    settings.lru_segmented = true;\n    settings.hot_lru_pct = 20;\n    settings.warm_lru_pct = 40;\n    settings.hot_max_factor = 0.2;\n    settings.warm_max_factor = 2.0;\n    settings.inline_ascii_response = false;\n    settings.temp_lru = false;\n    settings.temporary_ttl = 61;\n    settings.idle_timeout = 0; \n    settings.hashpower_init = 0;\n    settings.slab_reassign = true;\n    settings.slab_automove = 1;\n    settings.slab_automove_ratio = 0.8;\n    settings.slab_automove_window = 30;\n    settings.shutdown_command = false;\n    settings.tail_repair_time = TAIL_REPAIR_TIME_DEFAULT;\n    settings.flush_enabled = true;\n    settings.dump_enabled = true;\n    settings.crawls_persleep = 1000;\n    settings.logger_watcher_buf_size = LOGGER_WATCHER_BUF_SIZE;\n    settings.logger_buf_size = LOGGER_BUF_SIZE;\n    settings.drop_privileges = true;\n#ifdef MEMCACHED_DEBUG\n    settings.relaxed_privileges = false;\n#endif\n}", "target": 1}
{"code": "  RectangleRequest &operator=(const struct RectangleRequest &req)\n  { \n    memcpy(this,&req,sizeof(struct RectangleRequest));\n    rr_pNext = NULL;\n    return *this;\n  }", "target": 1}
{"code": "void ModuleSQL::init()\n{\n\tif (mysql_library_init(0, NULL, NULL))\n\t\tthrow ModuleException(\"Unable to initialise the MySQL library!\");\n\tDispatcher = new DispatcherThread(this);\n\tServerInstance->Threads.Start(Dispatcher);\n}", "target": 0}
{"code": "njs_typed_array_get_string_tag(njs_vm_t *vm, njs_value_t *args,\n    njs_uint_t nargs, njs_index_t unused)\n{\n    njs_value_t  *this;\n    static const njs_value_t  *tags[NJS_OBJ_TYPE_TYPED_ARRAY_SIZE] = {\n        &njs_typed_array_uint8_tag,\n        &njs_typed_array_uint8_clamped_tag,\n        &njs_typed_array_int8_tag,\n        &njs_typed_array_uint16_tag,\n        &njs_typed_array_int16_tag,\n        &njs_typed_array_uint32_tag,\n        &njs_typed_array_int32_tag,\n        &njs_typed_array_float32_tag,\n        &njs_typed_array_float64_tag,\n    };\n    this = njs_argument(args, 0);\n    if (!njs_is_typed_array(this)) {\n        njs_set_undefined(&vm->retval);\n        return NJS_OK;\n    }\n    vm->retval = *tags[njs_typed_array_index(njs_typed_array(this)->type)];\n    return NJS_OK;\n}", "target": 0}
{"code": "GF_EXPORT\nGF_Err gf_isom_get_sidx_duration(GF_ISOFile *movie, u64 *sidx_dur, u32 *sidx_timescale)\n{\n\tu64 dur=0;\n\tu32 i;\n\tif (!movie || !movie->moov || !sidx_timescale || !sidx_dur)\n\t\treturn GF_BAD_PARAM;\n\tif (!movie->main_sidx) return GF_NOT_SUPPORTED;\n\t*sidx_timescale = movie->main_sidx->timescale;\n\tfor (i=0; i<movie->main_sidx->nb_refs; i++) {\n\t\tdur += movie->main_sidx->refs[i].subsegment_duration;\n\t}\n\t*sidx_dur = dur;\n\treturn GF_OK;", "target": 0}
{"code": "TEST(FloatPoolingOpTest, MaxPoolWithZeroStride) {\n  EXPECT_DEATH(\n      FloatPoolingOpModel m(BuiltinOperator_MAX_POOL_2D,\n                            {TensorType_FLOAT32, {1, 2, 4, 1}},\n                            2, 2,\n                            {TensorType_FLOAT32, {}},\n                            Padding_VALID,\n                            0, 0),\n      \"Cannot allocate tensors\");\n}", "target": 0}
{"code": "int ib_update_cm_av(struct ib_cm_id *id, const u8 *smac, const u8 *alt_smac)\n{\n\tstruct cm_id_private *cm_id_priv;\n\tcm_id_priv = container_of(id, struct cm_id_private, id);\n\tif (smac != NULL)\n\t\tmemcpy(cm_id_priv->av.smac, smac, sizeof(cm_id_priv->av.smac));\n\tif (alt_smac != NULL)\n\t\tmemcpy(cm_id_priv->alt_av.smac, alt_smac,\n\t\t       sizeof(cm_id_priv->alt_av.smac));\n\treturn 0;\n}", "target": 1}
{"code": "  bool IsSupported(const NodeDef* node) const override {\n    if (!node || node->input_size() < 2) {\n      return false;\n    }\n    return IsAnyMul(*node) && node->input(0) == node->input(1);\n  }", "target": 0}
{"code": "  static Status ParseEquation(const string& equation,\n                              OperandLabels* input_labels,\n                              Labels* output_labels,\n                              std::vector<DimensionType>* label_types,\n                              OperandLabelCounts* input_label_counts,\n                              LabelCounts* output_label_counts,\n                              gtl::InlinedVector<bool, 2>* input_has_ellipsis,\n                              bool* output_has_ellipsis) {\n    gtl::InlinedVector<string, 2> input_str;\n    string output_str;\n    TF_RETURN_IF_ERROR(ParseEinsumEquation(equation, &input_str, &output_str));\n    absl::flat_hash_map<char, int> label_mapping;\n    int num_inputs = input_str.size();\n    input_labels->resize(num_inputs);\n    for (int i = 0; i < num_inputs; ++i) {\n      MapToLabels(input_str[i], &input_labels->at(i), &label_mapping);\n    }\n    MapToLabels(output_str, output_labels, &label_mapping);\n    int num_labels = label_mapping.size();\n    input_label_counts->resize(num_inputs);\n    input_has_ellipsis->resize(num_inputs);\n    for (int i = 0; i < num_inputs; ++i) {\n      input_label_counts->at(i).resize(num_labels);\n      input_has_ellipsis->at(i) = false;\n      for (const int label : input_labels->at(i)) {\n        if (label != kEllipsisLabel)\n          input_label_counts->at(i)[label] += 1;\n        else\n          input_has_ellipsis->at(i) = true;\n      }\n    }\n    output_label_counts->resize(num_labels);\n    *output_has_ellipsis = false;\n    for (const int label : *output_labels) {\n      if (label != kEllipsisLabel)\n        output_label_counts->at(label) += 1;\n      else\n        *output_has_ellipsis = true;\n    }\n    label_types->resize(num_labels);\n    for (int label = 0; label < num_labels; ++label) {\n      if (label == kEllipsisLabel) continue;\n      bool removed = (*output_label_counts)[label] == 0;\n      bool unique = num_inputs == 1 || (*input_label_counts)[0][label] == 0 ||\n                    (*input_label_counts)[1][label] == 0;\n      (*label_types)[label] = GetDimensionType(removed, unique);\n    }\n    return Status::OK();\n  }", "target": 0}
{"code": "i915_gem_execbuffer2(struct drm_device *dev, void *data,\n\t\t     struct drm_file *file)\n{\n\tstruct drm_i915_gem_execbuffer2 *args = data;\n\tstruct drm_i915_gem_exec_object2 *exec2_list = NULL;\n\tint ret;\n\tif (args->buffer_count < 1) {\n\t\tDRM_DEBUG(\"execbuf2 with %d buffers\\n\", args->buffer_count);\n\t\treturn -EINVAL;\n\t}\n\texec2_list = kmalloc(sizeof(*exec2_list)*args->buffer_count,\n\t\t\t     GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (exec2_list == NULL)\n\t\texec2_list = drm_malloc_ab(sizeof(*exec2_list),\n\t\t\t\t\t   args->buffer_count);\n\tif (exec2_list == NULL) {\n\t\tDRM_DEBUG(\"Failed to allocate exec list for %d buffers\\n\",\n\t\t\t  args->buffer_count);\n\t\treturn -ENOMEM;\n\t}\n\tret = copy_from_user(exec2_list,\n\t\t\t     (struct drm_i915_relocation_entry __user *)\n\t\t\t     (uintptr_t) args->buffers_ptr,\n\t\t\t     sizeof(*exec2_list) * args->buffer_count);\n\tif (ret != 0) {\n\t\tDRM_DEBUG(\"copy %d exec entries failed %d\\n\",\n\t\t\t  args->buffer_count, ret);\n\t\tdrm_free_large(exec2_list);\n\t\treturn -EFAULT;\n\t}\n\tret = i915_gem_do_execbuffer(dev, data, file, args, exec2_list);\n\tif (!ret) {\n\t\tret = copy_to_user((struct drm_i915_relocation_entry __user *)\n\t\t\t\t   (uintptr_t) args->buffers_ptr,\n\t\t\t\t   exec2_list,\n\t\t\t\t   sizeof(*exec2_list) * args->buffer_count);\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tDRM_DEBUG(\"failed to copy %d exec entries \"\n\t\t\t\t  \"back to user (%d)\\n\",\n\t\t\t\t  args->buffer_count, ret);\n\t\t}\n\t}\n\tdrm_free_large(exec2_list);\n\treturn ret;\n}", "target": 1}
{"code": "bool Archive::IsOpened()\n{\n#ifdef USE_ARCMEM\n  if (ArcMem.IsLoaded())\n    return true;\n#endif\n  return File::IsOpened();\n};", "target": 0}
{"code": "xfs_iget_check_free_state(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags)\n{\n\tif (flags & XFS_IGET_CREATE) {\n\t\tif (VFS_I(ip)->i_mode != 0) {\n\t\t\txfs_warn(ip->i_mount,\n\"Corruption detected! Free inode 0x%llx not marked free! (mode 0x%x)\",\n\t\t\t\tip->i_ino, VFS_I(ip)->i_mode);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tif (ip->i_d.di_nblocks != 0) {\n\t\t\txfs_warn(ip->i_mount,\n\"Corruption detected! Free inode 0x%llx has blocks allocated!\",\n\t\t\t\tip->i_ino);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (VFS_I(ip)->i_mode == 0)\n\t\treturn -ENOENT;\n\treturn 0;\n}", "target": 0}
{"code": "void scramble(FILE* keyFile){\n\tfor (int j = 0; j < 16; ++j)\n\t{\n\t\tchar temp = 0;\n\t\tfor (int i = 0; i < 256; ++i)\n\t\t{\n\t\t\tscrambleAsciiTables[j][i] = i;\n\t\t}\n\t\tif (keyFile != NULL){\n\t\t\tint size;\n\t\t\tchar extractedString[BUFFER_SIZE] = \"\";\n\t\t\twhile((size = fread(extractedString, 1, BUFFER_SIZE, keyFile)) > 0){\n\t\t\t\tfor (int i = 0; i < size; ++i)\n\t\t\t\t{\n\t\t\t\t\ttemp = scrambleAsciiTables[j][i%256];\n\t\t\t\t\tscrambleAsciiTables[j][i%256] = scrambleAsciiTables[j][(unsigned char)(extractedString[i])];\n\t\t\t\t\tscrambleAsciiTables[j][(unsigned char)(extractedString[i])] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t\trewind(keyFile);\n\t\t} else {\n\t\t\tunsigned char random256;\n\t\t\tfor (int i = 0; i < 10 * 256; ++i)\n\t\t\t{\n\t\t\t\trandom256 = generateNumber() ^ passPhrase[passIndex];\n\t\t\t\tpassIndex++;\n\t\t\t\tpassIndex %= 16384;\n\t\t\t\ttemp = scrambleAsciiTables[j][i%256];\n\t\t\t\tscrambleAsciiTables[j][i%256] = scrambleAsciiTables[j][random256];\n\t\t\t\tscrambleAsciiTables[j][random256] = temp;\n\t\t\t}\n\t\t}\n\t}\n}", "target": 1}
{"code": "folly::Optional<Param> ReadRecordLayer::readEvent(\n    folly::IOBufQueue& socketBuf) {\n  if (!unparsedHandshakeData_.empty()) {\n    auto param = decodeHandshakeMessage(unparsedHandshakeData_);\n    if (param) {\n      VLOG(8) << \"Received handshake message \"\n              << toString(boost::apply_visitor(EventVisitor(), *param));\n      return param;\n    }\n  }\n  while (true) {\n    auto message = read(socketBuf);\n    if (!message) {\n      return folly::none;\n    }\n    if (!unparsedHandshakeData_.empty() &&\n        message->type != ContentType::handshake) {\n      throw std::runtime_error(\"spliced handshake data\");\n    }\n    switch (message->type) {\n      case ContentType::alert: {\n        auto alert = decode<Alert>(std::move(message->fragment));\n        if (alert.description == AlertDescription::close_notify) {\n          return Param(CloseNotify(socketBuf.move()));\n        } else {\n          return Param(std::move(alert));\n        }\n      }\n      case ContentType::handshake: {\n        unparsedHandshakeData_.append(std::move(message->fragment));\n        auto param = decodeHandshakeMessage(unparsedHandshakeData_);\n        if (param) {\n          VLOG(8) << \"Received handshake message \"\n                  << toString(boost::apply_visitor(EventVisitor(), *param));\n          return param;\n        } else {\n          continue;\n        }\n      }\n      case ContentType::application_data:\n        return Param(AppData(std::move(message->fragment)));\n      default:\n        throw std::runtime_error(\"unknown content type\");\n    }\n  }\n}", "target": 1}
{"code": "  void* GetData() { return embedder_data_; }", "target": 0}
{"code": "static int adpt_i2o_enable_hba(adpt_hba* pHba)\n{\n\tu32 msg[4];\n\tint ret;\n\tadpt_i2o_status_get(pHba);\n\tif(!pHba->status_block){\n\t\treturn -ENOMEM;\n\t}\n\tif(pHba->status_block->iop_state == ADAPTER_STATE_OPERATIONAL)\n\t\treturn 0;\n\tif(pHba->status_block->iop_state != ADAPTER_STATE_READY)\n\t\treturn -EINVAL;\n\tmsg[0]=FOUR_WORD_MSG_SIZE|SGL_OFFSET_0;\n\tmsg[1]=I2O_CMD_SYS_ENABLE<<24|HOST_TID<<12|ADAPTER_TID;\n\tmsg[2]= 0;\n\tmsg[3]= 0;\n\tif ((ret = adpt_i2o_post_wait(pHba, msg, sizeof(msg), 240))) {\n\t\tprintk(KERN_WARNING\"%s: Could not enable (status=%#10x).\\n\", \n\t\t\tpHba->name, ret);\n\t} else {\n\t\tPDEBUG(\"%s: Enabled.\\n\", pHba->name);\n\t}\n\tadpt_i2o_status_get(pHba);\n\treturn ret;\n}", "target": 1}
{"code": "xml_read_notification(xmlTextReaderPtr reader, void *arg)\n{\n\tstruct rdr_notification_ctx *ctx = arg;\n\txmlReaderTypes type;\n\txmlChar const *name;\n\tint error;\n\terror = 0;\n\tname = xmlTextReaderConstLocalName(reader);\n\ttype = xmlTextReaderNodeType(reader);\n\tswitch (type) {\n\tcase XML_READER_TYPE_ELEMENT:\n\t\tif (xmlStrEqual(name, BAD_CAST RRDP_ELEM_DELTA)) {\n\t\t\terror = parse_notification_delta(reader, ctx);\n\t\t} else if (xmlStrEqual(name, BAD_CAST RRDP_ELEM_SNAPSHOT)) {\n\t\t\terror = parse_doc_data(reader, true, true,\n\t\t\t    &ctx->notification->snapshot);\n\t\t} else if (xmlStrEqual(name, BAD_CAST RRDP_ELEM_NOTIFICATION)) {\n\t\t\terror = parse_global_data(reader,\n\t\t\t    &ctx->notification->global_data, NULL, 0);\n\t\t\trdr_notification_ctx_init(ctx);\n\t\t} else {\n\t\t\treturn pr_val_err(\"Unexpected '%s' element\", name);\n\t\t}\n\t\tbreak;\n\tcase XML_READER_TYPE_END_ELEMENT:\n\t\tif (xmlStrEqual(name, BAD_CAST RRDP_ELEM_NOTIFICATION)) {\n\t\t\terror = order_notification_deltas(ctx);\n\t\t\trdr_notification_ctx_cleanup(ctx);\n\t\t\treturn error; \n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (error) {\n\t\trdr_notification_ctx_cleanup(ctx);\n\t\treturn error;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "PJ_DEF(void) pj_scan_get_unescape( pj_scanner *scanner,\n\t\t\t\t   const pj_cis_t *spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n    char *dst = s;\n    pj_assert(pj_cis_match(spec,0)==0);\n    pj_assert(pj_cis_match(spec,'%')==0);\n    if (!pj_cis_match(spec, *s) && *s != '%') {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    out->ptr = s;\n    do {\n\tif (*s == '%') {\n\t    if (s+3 <= scanner->end && pj_isxdigit(*(s+1)) && \n\t\tpj_isxdigit(*(s+2))) \n\t    {\n\t\t*dst = (pj_uint8_t) ((pj_hex_digit_to_val(*(s+1)) << 4) +\n\t\t\t\t      pj_hex_digit_to_val(*(s+2)));\n\t\t++dst;\n\t\ts += 3;\n\t    } else {\n\t\t*dst++ = *s++;\n\t\t*dst++ = *s++;\n\t\tbreak;\n\t    }\n\t}\n\tif (pj_cis_match(spec, *s)) {\n\t    char *start = s;\n\t    do {\n\t\t++s;\n\t    } while (pj_cis_match(spec, *s));\n\t    if (dst != start) pj_memmove(dst, start, s-start);\n\t    dst += (s-start);\n\t} \n    } while (*s == '%');\n    scanner->curptr = s;\n    out->slen = (dst - out->ptr);\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);    \n    }\n}", "target": 1}
{"code": "static void sco_sock_timeout(struct work_struct *work)\n{\n\tstruct sco_conn *conn = container_of(work, struct sco_conn,\n\t\t\t\t\t     timeout_work.work);\n\tstruct sock *sk;\n\tsco_conn_lock(conn);\n\tsk = conn->sk;\n\tif (sk)\n\t\tsock_hold(sk);\n\tsco_conn_unlock(conn);\n\tif (!sk)\n\t\treturn;\n\tBT_DBG(\"sock %p state %d\", sk, sk->sk_state);\n\tlock_sock(sk);\n\tsk->sk_err = ETIMEDOUT;\n\tsk->sk_state_change(sk);\n\trelease_sock(sk);\n\tsock_put(sk);\n}", "target": 0}
{"code": "Status ExtractVariantFromInput(OpKernelContext* ctx, int index,\n                               const T** value) {\n  const Tensor& input_t = ctx->input(index);\n  if (!TensorShapeUtils::IsScalar(input_t.shape())) {\n    return errors::InvalidArgument(\n        \"Invalid input matrix: Shape must be rank 0 but is rank \",\n        input_t.dims());\n  }\n  const Variant& input_variant = input_t.scalar<Variant>()();\n  *value = input_variant.get<T>();\n  if (*value == nullptr) {\n    return errors::InvalidArgument(\"Could not retrieve Variant input \", index);\n  }\n  if (!(*value)->valid()) {\n    return errors::InvalidArgument(\"Variant input \", index, \" is not valid.\");\n  }\n  return OkStatus();\n}", "target": 0}
{"code": "is_code_ctype(OnigCodePoint code, unsigned int ctype, OnigEncoding enc ARG_UNUSED)\n{\n  if (code < 256)\n    return ENC_IS_ISO_8859_6_CTYPE(code, ctype);\n  else\n    return FALSE;\n}", "target": 0}
{"code": "CONCRETE_IO_HANDLE socketio_create(void* io_create_parameters)\n{\n    SOCKETIO_CONFIG* socket_io_config = (SOCKETIO_CONFIG*)io_create_parameters;\n    SOCKET_IO_INSTANCE* result;\n    struct tcp_keepalive tcp_keepalive = { 0, 0, 0 };\n    if (socket_io_config == NULL)\n    {\n        LogError(\"Invalid argument: socket_io_config is NULL\");\n        result = NULL;\n    }\n    else\n    {\n        result = (SOCKET_IO_INSTANCE*)malloc(sizeof(SOCKET_IO_INSTANCE));\n        if (result != NULL)\n        {\n            (void)memset(result, 0, sizeof(SOCKET_IO_INSTANCE));\n            result->address_type = ADDRESS_TYPE_IP;\n            result->pending_io_list = singlylinkedlist_create();\n            if (result->pending_io_list == NULL)\n            {\n                LogError(\"Failure: singlylinkedlist_create unable to create pending list.\");\n                destroy_socket_io_instance(result);\n                result = NULL;\n            }\n            else\n            {\n                if (socket_io_config->hostname != NULL)\n                {\n                    result->hostname = (char*)malloc(strlen(socket_io_config->hostname) + 1);\n                    if (result->hostname != NULL)\n                    {\n                        (void)strcpy(result->hostname, socket_io_config->hostname);\n                    }\n                    result->socket = INVALID_SOCKET;\n                }\n                else\n                {\n                    result->hostname = NULL;\n                    result->socket = *((SOCKET*)socket_io_config->accepted_socket);\n                }\n                if ((result->hostname == NULL) && (result->socket == INVALID_SOCKET))\n                {\n                    LogError(\"Failure: hostname == NULL and socket is invalid.\");\n                    destroy_socket_io_instance(result);\n                    result = NULL;\n                }\n                else if ((result->addrInfo = calloc(1, sizeof(struct addrinfo))) == NULL)\n                {\n                    LogError(\"Failure: addrInfo == NULL.\");\n                    destroy_socket_io_instance(result);\n                    result = NULL;\n                }\n                else\n                {\n                    result->port = socket_io_config->port;\n                    result->on_io_open_complete = NULL;\n                    result->dns_resolver = dns_resolver_create(result->hostname, socket_io_config->port, NULL);\n                    result->on_bytes_received = NULL;\n                    result->on_io_error = NULL;\n                    result->on_bytes_received_context = NULL;\n                    result->on_io_error_context = NULL;\n                    result->io_state = IO_STATE_CLOSED;\n                    result->keep_alive = tcp_keepalive;\n                }\n            }\n        }\n        else\n        {\n            LogError(\"Allocation Failure: SOCKET_IO_INSTANCE\");\n        }\n    }\n    return (XIO_HANDLE)result;\n}", "target": 1}
{"code": "date_s_new_bang(int argc, VALUE *argv, VALUE klass)\n{\n    VALUE ajd, of, sg, nth, sf;\n    int jd, df, rof;\n    double rsg;\n    rb_scan_args(argc, argv, \"03\", &ajd, &of, &sg);\n    switch (argc) {\n      case 0:\n\tajd = INT2FIX(0);\n      case 1:\n\tof = INT2FIX(0);\n      case 2:\n\tsg = INT2FIX(DEFAULT_SG);\n    }\n    old_to_new(ajd, of, sg,\n\t       &nth, &jd, &df, &sf, &rof, &rsg);\n    if (!df && f_zero_p(sf) && !rof)\n\treturn d_simple_new_internal(klass,\n\t\t\t\t     nth, jd,\n\t\t\t\t     rsg,\n\t\t\t\t     0, 0, 0,\n\t\t\t\t     HAVE_JD);\n    else\n\treturn d_complex_new_internal(klass,\n\t\t\t\t      nth, jd,\n\t\t\t\t      df, sf,\n\t\t\t\t      rof, rsg,\n\t\t\t\t      0, 0, 0,\n\t\t\t\t      0, 0, 0,\n\t\t\t\t      HAVE_JD | HAVE_DF);\n}", "target": 0}
{"code": "aspath_loop_check (struct aspath *aspath, as_t asno)\n{\n  struct assegment *seg;\n  int count = 0;\n  if ( (aspath == NULL) || (aspath->segments == NULL) )\n    return 0;\n  seg = aspath->segments;\n  while (seg)\n    {\n      int i;\n      for (i = 0; i < seg->length; i++)\n\tif (seg->as[i] == asno)\n\t  count++;\n      seg = seg->next;\n    }\n  return count;\n}", "target": 0}
{"code": "void test_bindmount(const char *path)\n{\n\tif (mount(path, path, \"none\", MS_BIND, NULL) == 0) {\n\t\tfprintf(stderr, \"leak at bind mount of %s\\n\", path);\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "snmp_ber_encode_string_len(unsigned char *out, uint32_t *out_len, const char *str, uint32_t length)\n{\n  uint32_t i;\n  str += length - 1;\n  for(i = 0; i < length; ++i) {\n    (*out_len)++;\n    *out-- = (uint8_t)*str--;\n  }\n  out = snmp_ber_encode_length(out, out_len, length);\n  out = snmp_ber_encode_type(out, out_len, BER_DATA_TYPE_OCTET_STRING);\n  return out;\n}", "target": 1}
{"code": "void test_creat(const char *path)\n{\n\tif (creat(path, 0755) >= 0) {\n\t\tfprintf(stderr, \"leak at creat of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at creat of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "static int vp8_lossy_decode_frame(AVCodecContext *avctx, AVFrame *p,\n                                  int *got_frame, uint8_t *data_start,\n                                  unsigned int data_size)\n{\n    WebPContext *s = avctx->priv_data;\n    AVPacket pkt;\n    int ret;\n    if (!s->initialized) {\n        ff_vp8_decode_init(avctx);\n        s->initialized = 1;\n        if (s->has_alpha)\n            avctx->pix_fmt = AV_PIX_FMT_YUVA420P;\n    }\n    s->lossless = 0;\n    if (data_size > INT_MAX) {\n        av_log(avctx, AV_LOG_ERROR, \"unsupported chunk size\\n\");\n        return AVERROR_PATCHWELCOME;\n    }\n    av_init_packet(&pkt);\n    pkt.data = data_start;\n    pkt.size = data_size;\n    ret = ff_vp8_decode_frame(avctx, p, got_frame, &pkt);\n    if (ret < 0)\n        return ret;\n    update_canvas_size(avctx, avctx->width, avctx->height);\n    if (s->has_alpha) {\n        ret = vp8_lossy_decode_alpha(avctx, p, s->alpha_data,\n                                     s->alpha_data_size);\n        if (ret < 0)\n            return ret;\n    }\n    return ret;\n}", "target": 1}
{"code": "static void preinit_thread (lua_State *L, global_State *g) {\n  G(L) = g;\n  L->stack = NULL;\n  L->ci = NULL;\n  L->nci = 0;\n  L->stacksize = 0;\n  L->twups = L;  \n  L->errorJmp = NULL;\n  L->hook = NULL;\n  L->hookmask = 0;\n  L->basehookcount = 0;\n  L->allowhook = 1;\n  resethookcount(L);\n  L->openupval = NULL;\n  L->status = LUA_OK;\n  L->errfunc = 0;\n  L->oldpc = 0;\n}", "target": 0}
{"code": "void auth_client_request_abort(struct auth_client_request **_request)\n{\n\tstruct auth_client_request *request = *_request;\n\t*_request = NULL;\n\tauth_client_send_cancel(request->conn->client, request->id);\n\tcall_callback(request, AUTH_REQUEST_STATUS_ABORT, NULL, NULL);\n\tpool_unref(&request->pool);\n}", "target": 0}
{"code": "case_map(OnigCaseFoldType* flagP, const OnigUChar** pp,\n\t const OnigUChar* end, OnigUChar* to, OnigUChar* to_end,\n\t const struct OnigEncodingTypeST* enc)\n{\n  OnigCodePoint code;\n  OnigUChar *to_start = to;\n  OnigCaseFoldType flags = *flagP;\n  while (*pp < end && to < to_end) {\n    code = *(*pp)++;\n    if (code == SHARP_s) {\n      if (flags & ONIGENC_CASE_UPCASE) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\t*to++ = 'S';\n\tcode = (flags & ONIGENC_CASE_TITLECASE) ? 's' : 'S';\n      }\n      else if (flags & ONIGENC_CASE_FOLD) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\t*to++ = 's';\n\tcode = 's';\n      }\n    }\n    else if ((EncISO_8859_2_CtypeTable[code] & BIT_CTYPE_UPPER)\n\t     && (flags & (ONIGENC_CASE_DOWNCASE | ONIGENC_CASE_FOLD))) {\n      flags |= ONIGENC_CASE_MODIFIED;\n      code = ENC_ISO_8859_2_TO_LOWER_CASE(code);\n    }\n    else if ((EncISO_8859_2_CtypeTable[code] & BIT_CTYPE_LOWER)\n       && (flags & ONIGENC_CASE_UPCASE)) {\n      if (code >= 0xB1 && code <= 0xBF) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\tcode -= 0x10;\n      }\n      else {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\tcode -= 0x20;\n      }\n    }\n    *to++ = code;\n    if (flags & ONIGENC_CASE_TITLECASE)  \n      flags ^= (ONIGENC_CASE_UPCASE | ONIGENC_CASE_DOWNCASE | ONIGENC_CASE_TITLECASE);\n  }\n  *flagP = flags;\n  return (int )(to - to_start);\n}", "target": 0}
{"code": "uint8_t ethereum_extractThorchainData(const EthereumSignTx *msg,\n                                          char *buffer) {\n  uint16_t offset = 4 + (5 * 32);\n  int16_t len = msg->data_length - offset;\n  if (msg->has_data_length && len > 0) {\n    memcpy(buffer, msg->data_initial_chunk.bytes + offset, len);\n    return len < 256 ? (uint8_t)len : 0;\n  }\n  return 0;\n}", "target": 1}
{"code": "static int sof_set_get_large_ctrl_data(struct snd_sof_dev *sdev,\n\t\t\t\t       struct sof_ipc_ctrl_data *cdata,\n\t\t\t\t       struct sof_ipc_ctrl_data_params *sparams,\n\t\t\t\t       bool send)\n{\n\tstruct sof_ipc_ctrl_data *partdata;\n\tsize_t send_bytes;\n\tsize_t offset = 0;\n\tsize_t msg_bytes;\n\tsize_t pl_size;\n\tint err;\n\tint i;\n\tpartdata = kzalloc(SOF_IPC_MSG_MAX_SIZE, GFP_KERNEL);\n\tif (!partdata)\n\t\treturn -ENOMEM;\n\tif (send)\n\t\terr = sof_get_ctrl_copy_params(cdata->type, cdata, partdata,\n\t\t\t\t\t       sparams);\n\telse\n\t\terr = sof_get_ctrl_copy_params(cdata->type, partdata, cdata,\n\t\t\t\t\t       sparams);\n\tif (err < 0)\n\t\treturn err;\n\tmsg_bytes = sparams->msg_bytes;\n\tpl_size = sparams->pl_size;\n\tmemcpy(partdata, cdata, sparams->hdr_bytes);\n\tmutex_lock(&sdev->ipc->tx_mutex);\n\tfor (i = 0; i < sparams->num_msg; i++) {\n\t\tsend_bytes = min(msg_bytes, pl_size);\n\t\tpartdata->num_elems = send_bytes;\n\t\tpartdata->rhdr.hdr.size = sparams->hdr_bytes + send_bytes;\n\t\tpartdata->msg_index = i;\n\t\tmsg_bytes -= send_bytes;\n\t\tpartdata->elems_remaining = msg_bytes;\n\t\tif (send)\n\t\t\tmemcpy(sparams->dst, sparams->src + offset, send_bytes);\n\t\terr = sof_ipc_tx_message_unlocked(sdev->ipc,\n\t\t\t\t\t\t  partdata->rhdr.hdr.cmd,\n\t\t\t\t\t\t  partdata,\n\t\t\t\t\t\t  partdata->rhdr.hdr.size,\n\t\t\t\t\t\t  partdata,\n\t\t\t\t\t\t  partdata->rhdr.hdr.size);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\tif (!send)\n\t\t\tmemcpy(sparams->dst + offset, sparams->src, send_bytes);\n\t\toffset += pl_size;\n\t}\n\tmutex_unlock(&sdev->ipc->tx_mutex);\n\tkfree(partdata);\n\treturn err;\n}", "target": 1}
{"code": "render_pixbuf_size_prepared_cb (GdkPixbufLoader *loader,\n\t\t\t\tgint             width,\n\t\t\t\tgint             height,\n\t\t\t\tEvRenderContext *rc)\n{\n\tdouble scale = rc->scale;\n\tint w = (width  * scale + 0.5);\n\tint h = (height * scale + 0.5);\n\tgdk_pixbuf_loader_set_size (loader, w, h);\n}", "target": 0}
{"code": "    TiffComponent* TiffIfdMakernote::doAddChild(TiffComponent::UniquePtr tiffComponent)\n    {\n        return ifd_.addChild(std::move(tiffComponent));\n    }", "target": 0}
{"code": "static s32 adpt_scsi_host_alloc(adpt_hba* pHba, struct scsi_host_template *sht)\n{\n\tstruct Scsi_Host *host;\n\thost = scsi_host_alloc(sht, sizeof(adpt_hba*));\n\tif (host == NULL) {\n\t\tprintk(\"%s: scsi_host_alloc returned NULL\\n\", pHba->name);\n\t\treturn -1;\n\t}\n\thost->hostdata[0] = (unsigned long)pHba;\n\tpHba->host = host;\n\thost->irq = pHba->pDev->irq;\n\thost->io_port = 0;\n\thost->n_io_port = 0;\n\thost->max_id = 16;\n\thost->max_lun = 256;\n\thost->max_channel = pHba->top_scsi_channel + 1;\n\thost->cmd_per_lun = 1;\n\thost->unique_id = (u32)sys_tbl_pa + pHba->unit;\n\thost->sg_tablesize = pHba->sg_tablesize;\n\thost->can_queue = pHba->post_fifo_size;\n\treturn 0;\n}", "target": 1}
{"code": "mm_answer_pam_free_ctx(int sock, Buffer *m)\n{\n\tdebug3(\"%s\", __func__);\n\t(sshpam_device.free_ctx)(sshpam_ctxt);\n\tbuffer_clear(m);\n\tmm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);\n\tauth_method = \"keyboard-interactive\";\n\tauth_submethod = \"pam\";\n\treturn (sshpam_authok == sshpam_ctxt);\n}", "target": 1}
{"code": "unique_ptr<IOBuf> IOBuf::create(std::size_t capacity) {\n  if (capacity > kMaxIOBufSize) {\n    throw_exception<std::bad_alloc>();\n  }\n  if (capacity <= kDefaultCombinedBufSize) {\n    return createCombined(capacity);\n  }\n  if (canNallocx()) {\n    auto mallocSize = goodMallocSize(capacity);\n    size_t minSize = ((capacity + 7) & ~7) + sizeof(SharedInfo);\n    if (mallocSize < minSize) {\n      auto* buf = checkedMalloc(mallocSize);\n      return takeOwnership(SIZED_FREE, buf, mallocSize, 0, 0);\n    }\n  }\n  return createSeparate(capacity);\n}", "target": 0}
{"code": "void M_LoadDefaults (void)\n{\n    int\t\ti;\n    int\t\tlen;\n    FILE*\tf;\n    char\tdef[80];\n    char\tstrparm[100];\n    char*\tnewstring;\n    int\t\tparm;\n    boolean\tisstring;\n    numdefaults = sizeof(defaults)/sizeof(defaults[0]);\n    for (i=0 ; i<numdefaults ; i++)\n\t*defaults[i].location = defaults[i].defaultvalue;\n    i = M_CheckParm (\"-config\");\n    if (i && i<myargc-1)\n    {\n\tdefaultfile = myargv[i+1];\n\tprintf (\"\tdefault file: %s\\n\",defaultfile);\n    }\n    else\n\tdefaultfile = basedefault;\n    f = fopen (defaultfile, \"r\");\n    if (f)\n    {\n\twhile (!feof(f))\n\t{\n\t    isstring = false;\n\t    if (fscanf (f, \"%79s %[^\\n]\\n\", def, strparm) == 2)\n\t    {\n\t\tif (strparm[0] == '\"')\n\t\t{\n\t\t    isstring = true;\n\t\t    len = strlen(strparm);\n\t\t    newstring = (char *) malloc(len);\n\t\t    strparm[len-1] = 0;\n\t\t    strcpy(newstring, strparm+1);\n\t\t}\n\t\telse if (strparm[0] == '0' && strparm[1] == 'x')\n\t\t    sscanf(strparm+2, \"%x\", &parm);\n\t\telse\n\t\t    sscanf(strparm, \"%i\", &parm);\n\t\tfor (i=0 ; i<numdefaults ; i++)\n\t\t    if (!strcmp(def, defaults[i].name))\n\t\t    {\n\t\t\tif (!isstring)\n\t\t\t    *defaults[i].location = parm;\n\t\t\telse\n\t\t\t    *defaults[i].location =\n\t\t\t\t(int) newstring;\n\t\t\tbreak;\n\t\t    }\n\t    }\n\t}\n\tfclose (f);\n    }\n    for (i = 0; i < numdefaults; i++)\n    {\n        if (defaults[i].scantranslate)\n        {\n            parm = *defaults[i].location;\n            defaults[i].untranslated = parm;\n            *defaults[i].location = scantokey[parm];\n        }\n    }\n}", "target": 1}
{"code": "void RuleMatchCandidateTxArrayFree(DetectEngineThreadCtx *det_ctx)\n{\n    SCFree(det_ctx->tx_candidates);\n    det_ctx->tx_candidates_size = 0;\n}", "target": 0}
{"code": "static void sixpack_close(struct tty_struct *tty)\n{\n\tstruct sixpack *sp;\n\twrite_lock_irq(&disc_data_lock);\n\tsp = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\tif (!sp)\n\t\treturn;\n\tif (!refcount_dec_and_test(&sp->refcnt))\n\t\twait_for_completion(&sp->dead);\n\tnetif_stop_queue(sp->dev);\n\tdel_timer_sync(&sp->tx_t);\n\tdel_timer_sync(&sp->resync_t);\n\tunregister_netdev(sp->dev);\n\tkfree(sp->rbuff);\n\tkfree(sp->xbuff);\n\tfree_netdev(sp->dev);\n}", "target": 1}
{"code": "u32 secure_ipv6_port_ephemeral(const __be32 *saddr, const __be32 *daddr,\n\t\t\t       __be16 dport)\n{\n\tu32 secret[MD5_MESSAGE_BYTES / 4];\n\tu32 hash[MD5_DIGEST_WORDS];\n\tu32 i;\n\tmemcpy(hash, saddr, 16);\n\tfor (i = 0; i < 4; i++)\n\t\tsecret[i] = net_secret[i] + (__force u32) daddr[i];\n\tsecret[4] = net_secret[4] + (__force u32)dport;\n\tfor (i = 5; i < MD5_MESSAGE_BYTES / 4; i++)\n\t\tsecret[i] = net_secret[i];\n\tmd5_transform(hash, secret);\n\treturn hash[0];\n}", "target": 0}
{"code": "static void ext2_put_super (struct super_block * sb)\n{\n\tint db_count;\n\tint i;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tdquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\text2_xattr_put_super(sb);\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tstruct ext2_super_block *es = sbi->s_es;\n\t\tspin_lock(&sbi->s_lock);\n\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\tdb_count = sbi->s_gdb_count;\n\tfor (i = 0; i < db_count; i++)\n\t\tif (sbi->s_group_desc[i])\n\t\t\tbrelse (sbi->s_group_desc[i]);\n\tkfree(sbi->s_group_desc);\n\tkfree(sbi->s_debts);\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tbrelse (sbi->s_sbh);\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\n}", "target": 1}
{"code": "fb_mmap(struct file *file, struct vm_area_struct * vma)\n{\n\tstruct fb_info *info = file_fb_info(file);\n\tstruct fb_ops *fb;\n\tunsigned long off;\n\tunsigned long start;\n\tu32 len;\n\tif (!info)\n\t\treturn -ENODEV;\n\tif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))\n\t\treturn -EINVAL;\n\toff = vma->vm_pgoff << PAGE_SHIFT;\n\tfb = info->fbops;\n\tif (!fb)\n\t\treturn -ENODEV;\n\tmutex_lock(&info->mm_lock);\n\tif (fb->fb_mmap) {\n\t\tint res;\n\t\tres = fb->fb_mmap(info, vma);\n\t\tmutex_unlock(&info->mm_lock);\n\t\treturn res;\n\t}\n\tstart = info->fix.smem_start;\n\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.smem_len);\n\tif (off >= len) {\n\t\toff -= len;\n\t\tif (info->var.accel_flags) {\n\t\t\tmutex_unlock(&info->mm_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tstart = info->fix.mmio_start;\n\t\tlen = PAGE_ALIGN((start & ~PAGE_MASK) + info->fix.mmio_len);\n\t}\n\tmutex_unlock(&info->mm_lock);\n\tstart &= PAGE_MASK;\n\tif ((vma->vm_end - vma->vm_start + off) > len)\n\t\treturn -EINVAL;\n\toff += start;\n\tvma->vm_pgoff = off >> PAGE_SHIFT;\n\tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\tfb_pgprotect(file, vma, off);\n\tif (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\n\t\t\t     vma->vm_end - vma->vm_start, vma->vm_page_prot))\n\t\treturn -EAGAIN;\n\treturn 0;\n}", "target": 1}
{"code": "void PacketReader::getLabelFromContent(const vector<uint8_t>& content, uint16_t& frompos, string& ret, int recurs) \n{\n  if(recurs > 100) \n    throw MOADNSException(\"Loop\");\n  int pos = frompos;\n  for(;;) {\n    unsigned char labellen=content.at(frompos++);\n    if(!labellen) {\n      if(ret.empty())\n              ret.append(1,'.');\n      break;\n    }\n    else if((labellen & 0xc0) == 0xc0) {\n      uint16_t offset=256*(labellen & ~0xc0) + (unsigned int)content.at(frompos++) - sizeof(dnsheader);\n      if(offset >= pos)\n        throw MOADNSException(\"forward reference during label decompression\");\n      return getLabelFromContent(content, offset, ret, ++recurs);\n    }\n    else if(labellen > 63) \n      throw MOADNSException(\"Overly long label during label decompression (\"+lexical_cast<string>((unsigned int)labellen)+\")\");\n    else {\n      for(string::size_type n = 0 ; n < labellen; ++n, frompos++) {\n        if(content.at(frompos)=='.' || content.at(frompos)=='\\\\') {\n          ret.append(1, '\\\\');\n          ret.append(1, content[frompos]);\n        }\n        else if(content.at(frompos)==' ') {\n          ret+=\"\\\\032\";\n        }\n        else \n          ret.append(1, content[frompos]);\n      }\n      ret.append(1,'.');\n    }\n    if (ret.length() > 1024)\n      throw MOADNSException(\"Total name too long\");\n  }\n}", "target": 1}
{"code": "const RootWindow* RootWindow::GetRootWindow() const {\n  return this;\n}", "target": 0}
{"code": "bool DecodeResourceHandleList(std::unique_ptr<port::StringListDecoder> d,\n                              ResourceHandle* ps, int64_t n) {\n  std::vector<uint32> sizes(n);\n  if (!d->ReadSizes(&sizes)) return false;\n  ResourceHandleProto proto;\n  for (int i = 0; i < n; ++i) {\n    if (!proto.ParseFromArray(d->Data(sizes[i]), sizes[i])) {\n      return false;\n    }\n    ps[i].FromProto(proto);\n  }\n  return true;\n}", "target": 1}
{"code": "static inline void TCP_ECN_queue_cwr(struct tcp_sock *tp)\n{\n\tif (tp->ecn_flags & TCP_ECN_OK)\n\t\ttp->ecn_flags |= TCP_ECN_QUEUE_CWR;\n}", "target": 0}
{"code": "HMAC_SHA256_Update(struct HMAC_SHA256_CTX * ctx, const void *in, size_t len)\n{\n  scrypt_SHA256_Update(&ctx->ictx, in, len);\n}", "target": 1}
{"code": "mes_lookup (struct message *meslist, int max, int index)\n{\n  if ((index >= 0) && (index < max) && (meslist[index].key == index))\n    return meslist[index].str;\n  {\n    int i;\n    for (i = 0; i < max; i++, meslist++)\n      {\n\tif (meslist->key == index)\n\t  {\n\t    zlog_warn(\"message index %d [%s] found in position %d (max is %d)\",\n\t\t      index, meslist->str, i, max);\n\t    return meslist->str;\n\t  }\n      }\n  }\n  zlog_err(\"message index %d not found (max is %d)\", index, max);\n  return NULL;\n}", "target": 1}
{"code": "void color_cmyk_to_rgb(opj_image_t *image)\n{\n\tfloat C, M, Y, K;\n\tfloat sC, sM, sY, sK;\n\tunsigned int w, h, max, i;\n\tw = image->comps[0].w;\n\th = image->comps[0].h;\n\tif(image->numcomps < 4) return;\n\tmax = w * h;\n\tsC = 1.0F / (float)((1 << image->comps[0].prec) - 1);\n\tsM = 1.0F / (float)((1 << image->comps[1].prec) - 1);\n\tsY = 1.0F / (float)((1 << image->comps[2].prec) - 1);\n\tsK = 1.0F / (float)((1 << image->comps[3].prec) - 1);\n\tfor(i = 0; i < max; ++i)\n\t{\n\t\tC = (float)(image->comps[0].data[i]) * sC;\n\t\tM = (float)(image->comps[1].data[i]) * sM;\n\t\tY = (float)(image->comps[2].data[i]) * sY;\n\t\tK = (float)(image->comps[3].data[i]) * sK;\n\t\tC = 1.0F - C;\n\t\tM = 1.0F - M;\n\t\tY = 1.0F - Y;\n\t\tK = 1.0F - K;\n\t\timage->comps[0].data[i] = (int)(255.0F * C * K); \n\t\timage->comps[1].data[i] = (int)(255.0F * M * K); \n\t\timage->comps[2].data[i] = (int)(255.0F * Y * K); \n\t}\n\tfree(image->comps[3].data); image->comps[3].data = NULL;\n\timage->comps[0].prec = 8;\n\timage->comps[1].prec = 8;\n\timage->comps[2].prec = 8;\n\timage->numcomps -= 1;\n\timage->color_space = OPJ_CLRSPC_SRGB;\n\tfor (i = 3; i < image->numcomps; ++i) {\n\t\tmemcpy(&(image->comps[i]), &(image->comps[i+1]), sizeof(image->comps[i]));\n\t}\n}", "target": 1}
{"code": "int DISOpticalFlowImpl::autoSelectCoarsestScale(int img_width)\n{\n    const int fratio = 5;\n    return std::max(0, (int)std::floor(log2((2.0f*(float)img_width) / ((float)fratio * (float)patch_size))));\n}", "target": 0}
{"code": "pacparser_find_proxy(const char *url, const char *host)\n{\n  char *error_prefix = \"pacparser.c: pacparser_find_proxy:\";\n  if (_debug()) print_error(\"DEBUG: Finding proxy for URL: %s and Host:\"\n                        \" %s\\n\", url, host);\n  jsval rval;\n  char *script;\n  if (url == NULL || (strcmp(url, \"\") == 0)) {\n    print_error(\"%s %s\\n\", error_prefix, \"URL not defined\");\n    return NULL;\n  }\n  if (host == NULL || (strcmp(host,\"\") == 0)) {\n    print_error(\"%s %s\\n\", error_prefix, \"Host not defined\");\n    return NULL;\n  }\n  if (cx == NULL || global == NULL) {\n    print_error(\"%s %s\\n\", error_prefix, \"Pac parser is not initialized.\");\n    return NULL;\n  }\n  script = \"typeof(findProxyForURL);\";\n  if (_debug()) print_error(\"DEBUG: Executing JavaScript: %s\\n\", script);\n  JS_EvaluateScript(cx, global, script, strlen(script), NULL, 1, &rval);\n  if (strcmp(\"function\", JS_GetStringBytes(JS_ValueToString(cx, rval))) != 0) {\n    print_error(\"%s %s\\n\", error_prefix,\n\t\t  \"Javascript function findProxyForURL not defined.\");\n    return NULL;\n  }\n  char *sanitized_url = str_replace(url, \"'\", \"%27\");\n  if (strchr(host, '\\'')) {\n    print_error(\"%s %s\\n\", error_prefix,\n\t\t\"Invalid hostname: hostname can't have single quotes.\");\n    return NULL;\n  }\n  script = (char*) malloc(32 + strlen(url) + strlen(host));\n  script[0] = '\\0';\n  strcat(script, \"findProxyForURL('\");\n  strcat(script, sanitized_url);\n  strcat(script, \"', '\");\n  strcat(script, host);\n  strcat(script, \"')\");\n  if (_debug()) print_error(\"DEBUG: Executing JavaScript: %s\\n\", script);\n  if (!JS_EvaluateScript(cx, global, script, strlen(script), NULL, 1, &rval)) {\n    print_error(\"%s %s\\n\", error_prefix, \"Problem in executing findProxyForURL.\");\n    free(sanitized_url);\n    free(script);\n    return NULL;\n  }\n  free(sanitized_url);\n  free(script);\n  return JS_GetStringBytes(JS_ValueToString(cx, rval));\n}", "target": 1}
{"code": "static int vidioc_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tint labellen = (sizeof(cap->card) < sizeof(dev->card_label)) ?\n\t\t\t       sizeof(cap->card) :\n\t\t\t\t     sizeof(dev->card_label);\n\tint device_nr =\n\t\t((struct v4l2loopback_private *)video_get_drvdata(dev->vdev))\n\t\t\t->device_nr;\n\t__u32 capabilities = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\n\tstrlcpy(cap->driver, \"v4l2 loopback\", sizeof(cap->driver));\n\tsnprintf(cap->card, labellen, dev->card_label);\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n\t\t \"platform:v4l2loopback-%03d\", device_nr);\n#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 1, 0)\n\tcap->version = V4L2LOOPBACK_VERSION_CODE;\n#endif\n#ifdef V4L2_CAP_VIDEO_M2M\n\tcapabilities |= V4L2_CAP_VIDEO_M2M;\n#endif \n\tif (dev->announce_all_caps) {\n\t\tcapabilities |= V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT;\n\t} else {\n\t\tif (dev->ready_for_capture) {\n\t\t\tcapabilities |= V4L2_CAP_VIDEO_CAPTURE;\n\t\t}\n\t\tif (dev->ready_for_output) {\n\t\t\tcapabilities |= V4L2_CAP_VIDEO_OUTPUT;\n\t\t}\n\t}\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)\n\tdev->vdev->device_caps =\n#endif \n\t\tcap->device_caps = cap->capabilities = capabilities;\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)\n\tcap->capabilities |= V4L2_CAP_DEVICE_CAPS;\n#endif\n\tmemset(cap->reserved, 0, sizeof(cap->reserved));\n\treturn 0;\n}", "target": 1}
{"code": "Map1toN(SDL_PixelFormat * src, Uint8 Rmod, Uint8 Gmod, Uint8 Bmod, Uint8 Amod,\n        SDL_PixelFormat * dst)\n{\n    Uint8 *map;\n    int i;\n    int bpp;\n    SDL_Palette *pal = src->palette;\n    bpp = ((dst->BytesPerPixel == 3) ? 4 : dst->BytesPerPixel);\n    map = (Uint8 *) SDL_malloc(pal->ncolors * bpp);\n    if (map == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n    for (i = 0; i < pal->ncolors; ++i) {\n        Uint8 R = (Uint8) ((pal->colors[i].r * Rmod) / 255);\n        Uint8 G = (Uint8) ((pal->colors[i].g * Gmod) / 255);\n        Uint8 B = (Uint8) ((pal->colors[i].b * Bmod) / 255);\n        Uint8 A = (Uint8) ((pal->colors[i].a * Amod) / 255);\n        ASSEMBLE_RGBA(&map[i * bpp], dst->BytesPerPixel, dst, (Uint32)R, (Uint32)G, (Uint32)B, (Uint32)A);\n    }\n    return (map);\n}", "target": 1}
{"code": "TEST(format_timespan) {\n        test_format_timespan_accuracy(1);\n        test_format_timespan_accuracy(USEC_PER_MSEC);\n        test_format_timespan_accuracy(USEC_PER_SEC);\n        _cleanup_free_ char *buf;\n        assert_se(buf = new(char, 5));\n        assert_se(buf == format_timespan(buf, 5, 100005, 1000));\n}", "target": 0}
{"code": "static int onChdir(rpmfi fi, void *data)\n{\n    struct diriter_s *di = data;\n    if (di->dirfd >= 0) {\n\tclose(di->dirfd);\n\tdi->dirfd = -1;\n    }\n    return 0;\n}", "target": 0}
{"code": "static void server_real_connect(SERVER_REC *server, IPADDR *ip,\n\t\t\t\tconst char *unix_socket)\n{\n\tGIOChannel *handle;\n\tIPADDR *own_ip = NULL;\n\tconst char *errmsg;\n\tchar *errmsg2;\n\tchar ipaddr[MAX_IP_LEN];\n        int port;\n\tg_return_if_fail(ip != NULL || unix_socket != NULL);\n\tsignal_emit(\"server connecting\", 2, server, ip);\n\tif (server->connrec->no_connect)\n\t\treturn;\n\tif (ip != NULL) {\n\t\town_ip = ip == NULL ? NULL :\n\t\t\t(IPADDR_IS_V6(ip) ? server->connrec->own_ip6 :\n\t\t\t server->connrec->own_ip4);\n\t\tport = server->connrec->proxy != NULL ?\n\t\t\tserver->connrec->proxy_port : server->connrec->port;\n\t\thandle = server->connrec->use_ssl ?\n\t\t\tnet_connect_ip_ssl(ip, port, own_ip, server->connrec->ssl_cert, server->connrec->ssl_pkey,\nserver->connrec->ssl_cafile, server->connrec->ssl_capath, server->connrec->ssl_verify) :\n\t\t\tnet_connect_ip(ip, port, own_ip);\n\t} else {\n\t\thandle = net_connect_unix(unix_socket);\n\t}\n\tif (handle == NULL) {\n\t\terrmsg = g_strerror(errno);\n\t\terrmsg2 = NULL;\n\t\tif (errno == EADDRNOTAVAIL) {\n\t\t\tif (own_ip != NULL) {\n\t\t\t\tnet_ip2host(own_ip, ipaddr);\n\t\t\t\terrmsg2 = g_strconcat(errmsg, \": \", ipaddr, NULL);\n\t\t\t}\n\t\t\tserver->no_reconnect = TRUE;\n\t\t}\n\t\tif (server->connrec->use_ssl && errno == ENOSYS)\n\t\t\tserver->no_reconnect = TRUE;\n\t\tserver->connection_lost = TRUE;\n\t\tserver_connect_failed(server, errmsg2 ? errmsg2 : errmsg);\n\t\tg_free(errmsg2);\n\t} else {\n\t\tserver->handle = net_sendbuffer_create(handle, 0);\n#ifdef HAVE_OPENSSL\n\t\tif (server->connrec->use_ssl)\n\t\t\tserver_connect_callback_init_ssl(server, handle);\n\t\telse\n#endif\n\t\tserver->connect_tag =\n\t\t\tg_input_add(handle, G_INPUT_WRITE | G_INPUT_READ,\n\t\t\t\t    (GInputFunction)\n\t\t\t\t    server_connect_callback_init,\n\t\t\t\t    server);\n\t}\n}", "target": 1}
{"code": "static void consume_one_event(unsigned cpu,\n\t\t\t      struct evtchn_fifo_control_block *control_block,\n\t\t\t      unsigned priority, unsigned long *ready,\n\t\t\t      bool drop)\n{\n\tstruct evtchn_fifo_queue *q = &per_cpu(cpu_queue, cpu);\n\tuint32_t head;\n\tevtchn_port_t port;\n\tevent_word_t *word;\n\thead = q->head[priority];\n\tif (head == 0) {\n\t\tvirt_rmb(); \n\t\thead = control_block->head[priority];\n\t}\n\tport = head;\n\tword = event_word_from_port(port);\n\thead = clear_linked(word);\n\tif (head == 0)\n\t\tclear_bit(priority, ready);\n\tif (evtchn_fifo_is_pending(port) && !evtchn_fifo_is_masked(port)) {\n\t\tif (unlikely(drop))\n\t\t\tpr_warn(\"Dropping pending event for port %u\\n\", port);\n\t\telse\n\t\t\thandle_irq_for_port(port);\n\t}\n\tq->head[priority] = head;\n}", "target": 1}
{"code": "static long ec_device_ioctl_xcmd(struct cros_ec_dev *ec, void __user *arg)\n{\n\tlong ret;\n\tstruct cros_ec_command u_cmd;\n\tstruct cros_ec_command *s_cmd;\n\tif (copy_from_user(&u_cmd, arg, sizeof(u_cmd)))\n\t\treturn -EFAULT;\n\tif ((u_cmd.outsize > EC_MAX_MSG_BYTES) ||\n\t    (u_cmd.insize > EC_MAX_MSG_BYTES))\n\t\treturn -EINVAL;\n\ts_cmd = kmalloc(sizeof(*s_cmd) + max(u_cmd.outsize, u_cmd.insize),\n\t\t\tGFP_KERNEL);\n\tif (!s_cmd)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(s_cmd, arg, sizeof(*s_cmd) + u_cmd.outsize)) {\n\t\tret = -EFAULT;\n\t\tgoto exit;\n\t}\n\ts_cmd->command += ec->cmd_offset;\n\tret = cros_ec_cmd_xfer(ec->ec_dev, s_cmd);\n\tif (ret < 0)\n\t\tgoto exit;\n\tif (copy_to_user(arg, s_cmd, sizeof(*s_cmd) + u_cmd.insize))\n\t\tret = -EFAULT;\nexit:\n\tkfree(s_cmd);\n\treturn ret;\n}", "target": 1}
{"code": "void test_lchown(const char *path)\n{\n\tif (lchown(path, 0, 0) == 0) {\n\t\tfprintf(stderr, \"leak at lchown of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at lchown of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "_archive_write_disk_close(struct archive *_a)\n{\n\tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n\tstruct fixup_entry *next, *p;\n\tint fd, ret;\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n\t    ARCHIVE_STATE_HEADER | ARCHIVE_STATE_DATA,\n\t    \"archive_write_disk_close\");\n\tret = _archive_write_disk_finish_entry(&a->archive);\n\tp = sort_dir_list(a->fixup_list);\n\twhile (p != NULL) {\n\t\tfd = -1;\n\t\ta->pst = NULL; \n\t\tif (p->fixup &\n\t\t    (TODO_TIMES | TODO_MODE_BASE | TODO_ACLS | TODO_FFLAGS)) {\n\t\t\tfd = open(p->name,\n\t\t\t    O_WRONLY | O_BINARY | O_NOFOLLOW | O_CLOEXEC);\n\t\t}\n\t\tif (p->fixup & TODO_TIMES) {\n\t\t\tset_times(a, fd, p->mode, p->name,\n\t\t\t    p->atime, p->atime_nanos,\n\t\t\t    p->birthtime, p->birthtime_nanos,\n\t\t\t    p->mtime, p->mtime_nanos,\n\t\t\t    p->ctime, p->ctime_nanos);\n\t\t}\n\t\tif (p->fixup & TODO_MODE_BASE) {\n#ifdef HAVE_FCHMOD\n\t\t\tif (fd >= 0)\n\t\t\t\tfchmod(fd, p->mode);\n\t\t\telse\n#endif\n\t\t\tchmod(p->name, p->mode);\n\t\t}\n\t\tif (p->fixup & TODO_ACLS)\n\t\t\tarchive_write_disk_set_acls(&a->archive, fd,\n\t\t\t    p->name, &p->acl, p->mode);\n\t\tif (p->fixup & TODO_FFLAGS)\n\t\t\tset_fflags_platform(a, fd, p->name,\n\t\t\t    p->mode, p->fflags_set, 0);\n\t\tif (p->fixup & TODO_MAC_METADATA)\n\t\t\tset_mac_metadata(a, p->name, p->mac_metadata,\n\t\t\t\t\t p->mac_metadata_size);\n\t\tnext = p->next;\n\t\tarchive_acl_clear(&p->acl);\n\t\tfree(p->mac_metadata);\n\t\tfree(p->name);\n\t\tif (fd >= 0)\n\t\t\tclose(fd);\n\t\tfree(p);\n\t\tp = next;\n\t}\n\ta->fixup_list = NULL;\n\treturn (ret);\n}", "target": 1}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE_EQ(context, 1, output->dims->data[0]);\n  TF_LITE_ENSURE_EQ(context, 1, input->dims->data[0]);\n  TF_LITE_ENSURE_EQ(context, 1, input->dims->data[1]);\n  TF_LITE_ENSURE_EQ(context, 1, output->dims->data[2]);\n  TF_LITE_ENSURE_EQ(context, 1, input->dims->data[2]);\n  TF_LITE_ENSURE_EQ(context, output->dims->data[3], input->dims->data[3]);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteInt8);\n  TFLITE_DCHECK_LE(op_data_counter, kMaxOpDataSize);\n  OpData* op_data = &op_data_array[op_data_counter++];\n  if (output->dims->data[1] == 5) {\n    op_data->cycles_max = 1;\n  } else {\n    op_data->cycles_max = 2;\n  }\n  op_data->cycles_until_run = op_data->cycles_max;\n  node->user_data = op_data;\n  return kTfLiteOk;\n}", "target": 0}
{"code": "find_entry_internal(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n    int\t\t\tlock,\n\tback_txn *txn,\n\tint flags\n)\n{\n\tif (addr->uniqueid!=NULL)\n\t{\n\t\tLDAPDebug( LDAP_DEBUG_TRACE, \"=> find_entry_internal (uniqueid=%s) lock %d\\n\",\n\t\t    addr->uniqueid, lock, 0 );\n\t\treturn (find_entry_internal_uniqueid (pb, be, addr->uniqueid, lock, txn));\n\t}\n\telse\n\t{\n\t\tstruct backentry *entry = NULL;\n\t\tLDAPDebug( LDAP_DEBUG_TRACE, \"=> find_entry_internal (dn=%s) lock %d\\n\",\n\t\t           slapi_sdn_get_dn(addr->sdn), lock, 0 );\n\t\tif (addr->sdn) {\n\t\t\tentry = find_entry_internal_dn (pb, be, addr->sdn, \n\t\t\t                                lock, txn, flags);\n\t\t} else {\n\t\t\tLDAPDebug0Args( LDAP_DEBUG_ANY,\n\t\t\t                \"find_entry_internal: Null target dn\\n\" );\n\t\t}\n\t\tLDAPDebug0Args( LDAP_DEBUG_TRACE, \"<= find_entry_internal\\n\" );\n\t\treturn entry;\n\t}\n}", "target": 1}
{"code": "entityValueInitProcessor(XML_Parser parser, const char *s, const char *end,\n                         const char **nextPtr) {\n  int tok;\n  const char *start = s;\n  const char *next = start;\n  parser->m_eventPtr = start;\n  for (;;) {\n    tok = XmlPrologTok(parser->m_encoding, start, end, &next);\n    parser->m_eventEndPtr = next;\n    if (tok <= 0) {\n      if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      switch (tok) {\n      case XML_TOK_INVALID:\n        return XML_ERROR_INVALID_TOKEN;\n      case XML_TOK_PARTIAL:\n        return XML_ERROR_UNCLOSED_TOKEN;\n      case XML_TOK_PARTIAL_CHAR:\n        return XML_ERROR_PARTIAL_CHAR;\n      case XML_TOK_NONE: \n      default:\n        break;\n      }\n      return storeEntityValue(parser, parser->m_encoding, s, end,\n                              XML_ACCOUNT_DIRECT);\n    } else if (tok == XML_TOK_XML_DECL) {\n      enum XML_Error result;\n      result = processXmlDecl(parser, 0, start, next);\n      if (result != XML_ERROR_NONE)\n        return result;\n      if (parser->m_parsingStatus.parsing == XML_FINISHED)\n        return XML_ERROR_ABORTED;\n      *nextPtr = next;\n      parser->m_processor = entityValueProcessor;\n      return entityValueProcessor(parser, next, end, nextPtr);\n    }\n    else if (tok == XML_TOK_BOM) {\n#  ifdef XML_DTD\n      if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                    XML_ACCOUNT_DIRECT)) {\n        accountingOnAbort(parser);\n        return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n      }\n#  endif\n      *nextPtr = next;\n      s = next;\n    }\n    else if (tok == XML_TOK_INSTANCE_START) {\n      *nextPtr = next;\n      return XML_ERROR_SYNTAX;\n    }\n    start = next;\n    parser->m_eventPtr = start;\n  }\n}", "target": 1}
{"code": "static int count_args(const char **argv)\n{\n\tint i = 0;\n\tif (argv) {\n\t\twhile (argv[i] != NULL)\n\t\t\ti++;\n\t}\n\treturn i;\n}", "target": 0}
{"code": "static int svm_vm_has_apicv(struct kvm *kvm)\n{\n\treturn 0;\n}", "target": 0}
{"code": "TEE_Result syscall_authenc_init(unsigned long state, const void *nonce,\n\t\t\tsize_t nonce_len, size_t tag_len,\n\t\t\tsize_t aad_len, size_t payload_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key;\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)nonce, nonce_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx), cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\tkey = o->attr;\n\tres = crypto_authenc_init(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t  (uint8_t *)(key + 1), key->key_size,\n\t\t\t\t  nonce, nonce_len, tag_len, aad_len,\n\t\t\t\t  payload_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tcs->ctx_finalize = (tee_cryp_ctx_finalize_func_t)crypto_authenc_final;\n\tcs->state = CRYP_STATE_INITIALIZED;\n\treturn TEE_SUCCESS;\n}", "target": 0}
{"code": "cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n    size_t len, const cdf_header_t *h, cdf_secid_t id)\n{\n\tassert((size_t)CDF_SHORT_SEC_SIZE(h) == len);\n\t(void)memcpy(((char *)buf) + offs,\n\t    ((const char *)sst->sst_tab) + CDF_SHORT_SEC_POS(h, id), len);\n\treturn len;\n}", "target": 1}
{"code": "int dns_HTTPS_add_ipv6hint(struct dns_rr_nested *svcparam, unsigned char addr[][DNS_RR_AAAA_LEN], int addr_num)\n{\n\tif (_dns_left_len(&svcparam->context) < 4 + addr_num * DNS_RR_AAAA_LEN) {\n\t\treturn -1;\n\t}\n\tunsigned short value = DNS_HTTPS_T_IPV6HINT;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tvalue = addr_num * DNS_RR_AAAA_LEN;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tfor (int i = 0; i < addr_num; i++) {\n\t\tdns_add_rr_nested_memcpy(svcparam, addr[i], DNS_RR_AAAA_LEN);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void WebContentsImpl::OnJSOutOfMemory() {\n  if (delegate_)\n    delegate_->JSOutOfMemory(this);\n}", "target": 0}
{"code": "check_entry_size_and_hooks(struct ipt_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ipt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\tif (!ip_checkentry(&e->ip))\n\t\treturn -EINVAL;\n\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1}
{"code": "int ntlm_read_message_fields_buffer(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields->Len > 0)\n\t{\n\t\tif ((fields->BufferOffset + fields->Len) > Stream_Length(s))\n\t\t\treturn -1;\n\t\tfields->Buffer = (PBYTE) malloc(fields->Len);\n\t\tif (!fields->Buffer)\n\t\t\treturn -1;\n\t\tStream_SetPosition(s, fields->BufferOffset);\n\t\tStream_Read(s, fields->Buffer, fields->Len);\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "static void sycc444_to_rgb(opj_image_t *img)\n{\n\tint *d0, *d1, *d2, *r, *g, *b;\n\tconst int *y, *cb, *cr;\n\tunsigned int maxw, maxh, max, i;\n\tint offset, upb;\n\tupb = (int)img->comps[0].prec;\n\toffset = 1<<(upb - 1); upb = (1<<upb)-1;\n\tmaxw = (unsigned int)img->comps[0].w; maxh = (unsigned int)img->comps[0].h;\n\tmax = maxw * maxh;\n\ty = img->comps[0].data;\n\tcb = img->comps[1].data;\n\tcr = img->comps[2].data;\n\td0 = r = (int*)malloc(sizeof(int) * (size_t)max);\n\td1 = g = (int*)malloc(sizeof(int) * (size_t)max);\n\td2 = b = (int*)malloc(sizeof(int) * (size_t)max);\n\tif(r == NULL || g == NULL || b == NULL) goto fails;\n\tfor(i = 0U; i < max; ++i)\n\t{\n\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t++y; ++cb; ++cr; ++r; ++g; ++b;\n\t}\n\tfree(img->comps[0].data); img->comps[0].data = d0;\n\tfree(img->comps[1].data); img->comps[1].data = d1;\n\tfree(img->comps[2].data); img->comps[2].data = d2;\n\treturn;\nfails:\n\tif(r) free(r);\n\tif(g) free(g);\n\tif(b) free(b);\n}", "target": 1}
{"code": "TEST_F(StuffingTest, SignedData_missing_codesigning_EKU) {\n  auto certs = uthenticode::read_certs(pe);\n  auto signed_data = certs[0].as_signed_data();\n  ASSERT_TRUE(signed_data->verify_signature());\n}", "target": 0}
{"code": "juniper_monitor_print(netdissect_options *ndo,\n                      const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        struct juniper_monitor_header {\n            uint8_t pkt_type;\n            uint8_t padding;\n            uint8_t iif[2];\n            uint8_t service_id[4];\n        };\n        const struct juniper_monitor_header *mh;\n        l2info.pictype = DLT_JUNIPER_MONITOR;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        mh = (const struct juniper_monitor_header *)p;\n        ND_TCHECK(*mh);\n        if (ndo->ndo_eflag)\n            ND_PRINT((ndo, \"service-id %u, iif %u, pkt-type %u: \",\n                   EXTRACT_32BITS(&mh->service_id),\n                   EXTRACT_16BITS(&mh->iif),\n                   mh->pkt_type));\n        ip_heuristic_guess (ndo, p, l2info.length);\n        return l2info.header_len;\ntrunc:\n\tND_PRINT((ndo, \"[|juniper_services]\"));\n\treturn l2info.header_len;\n}", "target": 0}
{"code": "ev_archive_at_entry (EvArchive *archive)\n{\n\tg_return_val_if_fail (EV_IS_ARCHIVE (archive), FALSE);\n\tg_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, FALSE);\n\treturn (archive->libar_entry != NULL);\n}", "target": 0}
{"code": "static int sgi_clock_set(clockid_t clockid, struct timespec *tp)\n{\n\tu64 nsec;\n\tu64 rem;\n\tnsec = rtc_time() * sgi_clock_period;\n\tsgi_clock_offset.tv_sec = tp->tv_sec - div_long_long_rem(nsec, NSEC_PER_SEC, &rem);\n\tif (rem <= tp->tv_nsec)\n\t\tsgi_clock_offset.tv_nsec = tp->tv_sec - rem;\n\telse {\n\t\tsgi_clock_offset.tv_nsec = tp->tv_sec + NSEC_PER_SEC - rem;\n\t\tsgi_clock_offset.tv_sec--;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "    void publish(Topic *iterator, size_t start, size_t stop, std::string_view topic, std::pair<std::string_view, std::string_view> message) {\n        if (numTriggeredTopics == 64) {\n            drain();\n        }\n        for (; stop != std::string::npos; start = stop + 1) {\n            stop = topic.find('/', start);\n            std::string_view segment = topic.substr(start, stop - start);\n            if (segment.length() == 1) {\n                if (segment[0] == '+' || segment[0] == '#') {\n                    return;\n                }\n            }\n            if (iterator->terminatingWildcardChild) {\n                iterator->terminatingWildcardChild->messages[messageId] = message;\n                if (!iterator->terminatingWildcardChild->triggered) {\n                    triggeredTopics[numTriggeredTopics++] = iterator->terminatingWildcardChild;\n                    iterator->terminatingWildcardChild->triggered = true;\n                }\n            }\n            if (iterator->wildcardChild) {\n                publish(iterator->wildcardChild, stop + 1, stop, topic, message);\n            }\n            std::map<std::string_view, Topic *>::iterator it = iterator->children.find(segment);\n            if (it == iterator->children.end()) {\n                return;\n            }\n            iterator = it->second;\n        }\n        iterator->messages[messageId] = message;\n        if (!iterator->triggered) {\n            triggeredTopics[numTriggeredTopics++] = iterator;\n            iterator->triggered = true;\n        }\n    }", "target": 1}
{"code": "unique_ptr<IOBuf> IOBuf::createCombined(std::size_t capacity) {\n  if (capacity > kMaxIOBufSize) {\n    throw_exception<std::bad_alloc>();\n  }\n  size_t requiredStorage = offsetof(HeapFullStorage, align) + capacity;\n  size_t mallocSize = goodMallocSize(requiredStorage);\n  auto storage = static_cast<HeapFullStorage*>(checkedMalloc(mallocSize));\n  new (&storage->hs.prefix) HeapPrefix(kIOBufInUse | kDataInUse, mallocSize);\n  new (&storage->shared) SharedInfo(freeInternalBuf, storage);\n  if (io_buf_alloc_cb) {\n    io_buf_alloc_cb(storage, mallocSize);\n  }\n  auto bufAddr = reinterpret_cast<uint8_t*>(&storage->align);\n  uint8_t* storageEnd = reinterpret_cast<uint8_t*>(storage) + mallocSize;\n  auto actualCapacity = size_t(storageEnd - bufAddr);\n  unique_ptr<IOBuf> ret(new (&storage->hs.buf) IOBuf(\n      InternalConstructor(),\n      packFlagsAndSharedInfo(0, &storage->shared),\n      bufAddr,\n      actualCapacity,\n      bufAddr,\n      0));\n  return ret;\n}", "target": 0}
{"code": "void fio_signal_handler_reset(void) {\n  struct sigaction old;\n  if (!fio_old_sig_int.sa_handler)\n    return;\n  memset(&old, 0, sizeof(old));\n  sigaction(SIGINT, &fio_old_sig_int, &old);\n  sigaction(SIGTERM, &fio_old_sig_term, &old);\n  sigaction(SIGPIPE, &fio_old_sig_pipe, &old);\n  if (fio_old_sig_chld.sa_handler)\n    sigaction(SIGCHLD, &fio_old_sig_chld, &old);\n#if !FIO_DISABLE_HOT_RESTART\n  sigaction(SIGUSR1, &fio_old_sig_usr1, &old);\n  memset(&fio_old_sig_usr1, 0, sizeof(fio_old_sig_usr1));\n#endif\n  memset(&fio_old_sig_int, 0, sizeof(fio_old_sig_int));\n  memset(&fio_old_sig_term, 0, sizeof(fio_old_sig_term));\n  memset(&fio_old_sig_pipe, 0, sizeof(fio_old_sig_pipe));\n  memset(&fio_old_sig_chld, 0, sizeof(fio_old_sig_chld));\n}", "target": 1}
{"code": "static bool ptrace_freeze_traced(struct task_struct *task)\n{\n\tbool ret = false;\n\tif (task->jobctl & JOBCTL_LISTENING)\n\t\treturn ret;\n\tspin_lock_irq(&task->sighand->siglock);\n\tif (task_is_traced(task) && !__fatal_signal_pending(task)) {\n\t\ttask->state = __TASK_TRACED;\n\t\tret = true;\n\t}\n\tspin_unlock_irq(&task->sighand->siglock);\n\treturn ret;\n}", "target": 0}
{"code": "static int crypto_report_akcipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_akcipher rakcipher;\n\tstrlcpy(rakcipher.type, \"akcipher\", sizeof(rakcipher.type));\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_AKCIPHER,\n\t\t    sizeof(struct crypto_report_akcipher), &rakcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "void *malloc(size_t size)\n{\n\tstruct free_arena_header *fp;\n\tstruct free_arena_header *pah;\n\tsize_t fsize;\n\tif (size == 0)\n\t\treturn NULL;\n\tif (size > PTRDIFF_MAX) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\tsize = (size + 2 * sizeof(struct arena_header) - 1) & ARENA_SIZE_MASK;\n\tfor (fp = __malloc_head.next_free; fp->a.type != ARENA_TYPE_HEAD;\n\t     fp = fp->next_free) {\n\t\tif (fp->a.size >= size) {\n\t\t\treturn __malloc_from_block(fp, size);\n\t\t}\n\t}\n\tfsize = (size + MALLOC_CHUNK_MASK) & ~MALLOC_CHUNK_MASK;\n#if _KLIBC_MALLOC_USES_SBRK\n\tfp = (struct free_arena_header *)sbrk(fsize);\n#else\n\tfp = (struct free_arena_header *)\n\t    mmap(NULL, fsize, PROT_READ | PROT_WRITE,\n\t\t MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);\n#endif\n\tif (fp == (struct free_arena_header *)MAP_FAILED) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\t\n\t}\n\tfp->a.type = ARENA_TYPE_FREE;\n\tfp->a.size = fsize;\n\tfor (pah = __malloc_head.a.prev; pah->a.type != ARENA_TYPE_HEAD;\n\t     pah = pah->a.prev) {\n\t\tif (pah < fp)\n\t\t\tbreak;\n\t}\n\tfp->a.next = pah->a.next;\n\tfp->a.prev = pah;\n\tpah->a.next = fp;\n\tfp->a.next->a.prev = fp;\n\tfp = __free_block(fp);\n\treturn __malloc_from_block(fp, size);\n}", "target": 0}
{"code": "int main()\n{\n\tgdImagePtr im, exp;\n\tint error = 0;\n\tim = gdImageCreate(50, 50);\n\tif (!im) {\n\t\tgdTestErrorMsg(\"gdImageCreate failed.\\n\");\n\t\treturn 1;\n\t}\n\tgdImageCropThreshold(im, 1337, 0);\n\tgdImageDestroy(im);\n\treturn 0;\n}", "target": 0}
{"code": "static char *mongo_data_append( char *start , const void *data , int len ) {\n    memcpy( start , data , len );\n    return start + len;\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, SortSkipLimit) {\n    runQuerySortProjSkipNToReturn(BSONObj(), fromjson(\"{a: 1}\"), BSONObj(), 2, -3);\n    assertNumSolutions(1U);\n    assertSolutionExists(\n        \"{skip: {n: 2, node: \"\n        \"{sort: {pattern: {a: 1}, limit: 5, node: {sortKeyGen: \"\n        \"{node: {cscan: {dir: 1}}}}}}}}\");\n}", "target": 0}
{"code": "void LineTo(double x1,double y1) {\n    outpos +=\n    sprintf(outpos,\"\\n %12.3f %12.3f l\",x1,y1);\n}", "target": 1}
{"code": "Bool gf_sg_proto_field_is_sftime_offset(GF_Node *node, GF_FieldInfo *field)\n{\n\tu32 i;\n\tGF_Route *r;\n\tGF_ProtoInstance *inst;\n\tGF_FieldInfo inf;\n\tif (node->sgprivate->tag != TAG_ProtoNode) return 0;\n\tif (field->fieldType != GF_SG_VRML_SFTIME) return 0;\n\tinst = (GF_ProtoInstance *) node;\n\ti=0;\n\twhile ((r = (GF_Route*)gf_list_enum(inst->proto_interface->sub_graph->Routes, &i))) {\n\t\tif (!r->IS_route) continue;\n\t\tif (r->FromNode || (r->FromField.fieldIndex != field->fieldIndex)) continue;\n\t\tgf_node_get_field(r->ToNode, r->ToField.fieldIndex, &inf);\n\t\tif (r->ToNode->sgprivate->tag == TAG_ProtoNode) return gf_sg_proto_field_is_sftime_offset(r->ToNode, &inf);\n\t\tif (!stricmp(inf.name, \"startTime\") || !stricmp(inf.name, \"stopTime\")) return 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "TfLiteStatus Subgraph::AllocateTensors() {\n  TFLITE_SCOPED_TAGGED_DEFAULT_PROFILE(profiler_.get(), \"AllocateTensors\");\n  if (!consistent_) {\n    ReportError(\"AllocateTensors() called on inconsistent model.\");\n    return kTfLiteError;\n  }\n  TF_LITE_ENSURE_STATUS(RedoAllDelegates());\n  if (state_ != kStateUninvokable &&\n      !HasDynamicTensorImpl(context_, inputs())) {\n    if (memory_planner_ && !memory_planner_->HasNonPersistentMemory()) {\n      memory_planner_->AcquireNonPersistentMemory();\n    }\n    return kTfLiteOk;\n  }\n  SubgraphGuard guard(&context_, &is_subgraph_in_use_);\n  TF_LITE_ENSURE_OK(&context_, guard.status());\n  next_execution_plan_index_to_prepare_ = 0;\n  next_execution_plan_index_to_plan_allocation_ = 0;\n  next_original_execution_plan_index_to_prepare_ = 0;\n  if (memory_planner_) {\n    TF_LITE_ENSURE_STATUS(memory_planner_->ResetAllocations());\n  }\n  TF_LITE_ENSURE_STATUS(PrepareOpsAndTensors());\n  state_ = kStateInvokable;\n  ResetVariableTensors();\n  return kTfLiteOk;\n}", "target": 0}
{"code": "V8WindowShell* ScriptController::windowShell(DOMWrapperWorld* world)\n{\n    ASSERT(world);\n    V8WindowShell* shell = 0;\n    if (world->isMainWorld())\n        shell = m_windowShell.get();\n    else {\n        IsolatedWorldMap::iterator iter = m_isolatedWorlds.find(world->worldId());\n        if (iter != m_isolatedWorlds.end())\n            shell = iter->value.get();\n        else {\n            OwnPtr<V8WindowShell> isolatedWorldShell = V8WindowShell::create(m_frame, world, m_isolate);\n            shell = isolatedWorldShell.get();\n            m_isolatedWorlds.set(world->worldId(), isolatedWorldShell.release());\n        }\n    }\n    if (!shell->isContextInitialized() && shell->initializeIfNeeded()) {\n        if (world->isMainWorld()) {\n            m_frame->loader()->dispatchDidClearWindowObjectInWorld(existingWindowShellWorkaroundWorld());\n        } else\n            m_frame->loader()->dispatchDidClearWindowObjectInWorld(world);\n    }\n    return shell;\n}", "target": 0}
{"code": "snmp_ber_decode_length(unsigned char *buff, uint32_t *buff_len, uint8_t *length)\n{\n  if(*buff_len == 0) {\n    return NULL;\n  }\n  *length = *buff++;\n  (*buff_len)--;\n  return buff;\n}", "target": 1}
{"code": "check_entry_size_and_hooks(struct ipt_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ipt_entry) >= limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1}
{"code": "void nghttp2_option_set_max_continuations(nghttp2_option *option, size_t val) {\n  option->opt_set_mask |= NGHTTP2_OPT_MAX_CONTINUATIONS;\n  option->max_continuations = val;\n}", "target": 0}
{"code": "int verify_compat_iovec(struct msghdr *kern_msg, struct iovec *kern_iov,\n\t\t   struct sockaddr_storage *kern_address, int mode)\n{\n\tint tot_len;\n\tif (kern_msg->msg_namelen) {\n\t\tif (mode == VERIFY_READ) {\n\t\t\tint err = move_addr_to_kernel(kern_msg->msg_name,\n\t\t\t\t\t\t      kern_msg->msg_namelen,\n\t\t\t\t\t\t      kern_address);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tkern_msg->msg_name = kern_address;\n\t} else\n\t\tkern_msg->msg_name = NULL;\n\ttot_len = iov_from_user_compat_to_kern(kern_iov,\n\t\t\t\t\t  (struct compat_iovec __user *)kern_msg->msg_iov,\n\t\t\t\t\t  kern_msg->msg_iovlen);\n\tif (tot_len >= 0)\n\t\tkern_msg->msg_iov = kern_iov;\n\treturn tot_len;\n}", "target": 1}
{"code": "static ssize_t k90_show_current_profile(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint current_profile;\n\tchar data[8];\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_STATUS,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n\t\t\t ret);\n\t\treturn -EIO;\n\t}\n\tcurrent_profile = data[7];\n\tif (current_profile < 1 || current_profile > 3) {\n\t\tdev_warn(dev, \"Read invalid current profile: %02hhx.\\n\",\n\t\t\t data[7]);\n\t\treturn -EIO;\n\t}\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", current_profile);\n}", "target": 1}
{"code": "BOOL freerdp_bitmap_planar_context_reset(BITMAP_PLANAR_CONTEXT* context, UINT32 width,\n                                         UINT32 height)\n{\n\tif (!context)\n\t\treturn FALSE;\n\tcontext->bgr = FALSE;\n\tcontext->maxWidth = PLANAR_ALIGN(width, 4);\n\tcontext->maxHeight = PLANAR_ALIGN(height, 4);\n\tconst UINT64 tmp = (UINT64)context->maxWidth * context->maxHeight;\n\tif (tmp > UINT32_MAX)\n\t\treturn FALSE;\n\tcontext->maxPlaneSize = tmp;\n\tif (context->maxWidth > UINT32_MAX / 4)\n\t\treturn FALSE;\n\tcontext->nTempStep = context->maxWidth * 4;\n\tmemset(context->planes, 0, sizeof(context->planes));\n\tmemset(context->rlePlanes, 0, sizeof(context->rlePlanes));\n\tmemset(context->deltaPlanes, 0, sizeof(context->deltaPlanes));\n\tif (context->maxPlaneSize > 0)\n\t{\n\t\tvoid* tmp = winpr_aligned_recalloc(context->planesBuffer, context->maxPlaneSize, 4, 32);\n\t\tif (!tmp)\n\t\t\treturn FALSE;\n\t\tcontext->planesBuffer = tmp;\n\t\ttmp = winpr_aligned_recalloc(context->pTempData, context->maxPlaneSize, 6, 32);\n\t\tif (!tmp)\n\t\t\treturn FALSE;\n\t\tcontext->pTempData = tmp;\n\t\ttmp = winpr_aligned_recalloc(context->deltaPlanesBuffer, context->maxPlaneSize, 4, 32);\n\t\tif (!tmp)\n\t\t\treturn FALSE;\n\t\tcontext->deltaPlanesBuffer = tmp;\n\t\ttmp = winpr_aligned_recalloc(context->rlePlanesBuffer, context->maxPlaneSize, 4, 32);\n\t\tif (!tmp)\n\t\t\treturn FALSE;\n\t\tcontext->rlePlanesBuffer = tmp;\n\t\tcontext->planes[0] = &context->planesBuffer[context->maxPlaneSize * 0];\n\t\tcontext->planes[1] = &context->planesBuffer[context->maxPlaneSize * 1];\n\t\tcontext->planes[2] = &context->planesBuffer[context->maxPlaneSize * 2];\n\t\tcontext->planes[3] = &context->planesBuffer[context->maxPlaneSize * 3];\n\t\tcontext->deltaPlanes[0] = &context->deltaPlanesBuffer[context->maxPlaneSize * 0];\n\t\tcontext->deltaPlanes[1] = &context->deltaPlanesBuffer[context->maxPlaneSize * 1];\n\t\tcontext->deltaPlanes[2] = &context->deltaPlanesBuffer[context->maxPlaneSize * 2];\n\t\tcontext->deltaPlanes[3] = &context->deltaPlanesBuffer[context->maxPlaneSize * 3];\n\t}\n\treturn TRUE;\n}", "target": 0}
{"code": "    Status CmdAuthenticate::_authenticateX509(const UserName& user, const BSONObj& cmdObj) {\n        if (!getSSLManager()) {\n            return Status(ErrorCodes::ProtocolError,\n                          \"SSL support is required for the MONGODB-X509 mechanism.\");\n        }\n        if(user.getDB() != \"$external\") {\n            return Status(ErrorCodes::ProtocolError,\n                          \"X.509 authentication must always use the $external database.\");\n        }\n        ClientBasic *client = ClientBasic::getCurrent();\n        AuthorizationSession* authorizationSession = client->getAuthorizationSession();\n        std::string subjectName = client->port()->getX509SubjectName();\n        if (user.getUser() != subjectName) {\n            return Status(ErrorCodes::AuthenticationFailed,\n                          \"There is no x.509 client certificate matching the user.\");\n        }\n        else {\n            std::string srvSubjectName = getSSLManager()->getServerSubjectName();\n            std::string srvClusterId = srvSubjectName.substr(srvSubjectName.find(\",OU=\"));\n            std::string peerClusterId = subjectName.substr(subjectName.find(\",OU=\"));\n            fassert(17002, !srvClusterId.empty() && srvClusterId != srvSubjectName);\n            int clusterAuthMode = serverGlobalParams.clusterAuthMode.load(); \n            if (srvClusterId == peerClusterId) {\n                if (clusterAuthMode == ServerGlobalParams::ClusterAuthMode_undefined ||\n                    clusterAuthMode == ServerGlobalParams::ClusterAuthMode_keyFile) {\n                    return Status(ErrorCodes::AuthenticationFailed, \"The provided certificate \" \n                                  \"can only be used for cluster authentication, not client \" \n                                  \"authentication. The current configuration does not allow \" \n                                  \"x.509 cluster authentication, check the --clusterAuthMode flag\");\n                }\n                authorizationSession->grantInternalAuthorization();\n            }\n            else {\n                if (_isX509AuthDisabled) {\n                    return Status(ErrorCodes::BadValue,\n                                  _x509AuthenticationDisabledMessage);\n                }\n                Status status = authorizationSession->addAndAuthorizeUser(user);\n                if (!status.isOK()) {\n                    return status;\n                }\n            }\n            return Status::OK();\n        }\n    }", "target": 1}
{"code": "static void bson_append32_as_int( bson *b, int data ) {\n    bson_little_endian32( b->cur, &data );\n    b->cur += 4;\n}", "target": 0}
{"code": "TfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,\n                        int index) {\n  const int tensor_index = ValidateTensorIndexing(\n      context, index, node->outputs->size, node->outputs->data);\n  if (tensor_index < 0) {\n    return nullptr;\n  }\n  return GetTensorAtIndex(context, tensor_index);\n}", "target": 0}
{"code": "main (void)\n{\n  char *login;\n  int errors = 0;\n  login = getlogin ();\n  if (login == NULL)\n    puts (\"getlogin returned NULL, no further tests\");\n  else\n    {\n      char name[1024];\n      int ret;\n      printf (\"getlogin returned: `%s'\\n\", login);\n      ret = getlogin_r (name, sizeof (name));\n      if (ret == 0)\n\t{\n\t  printf (\"getlogin_r returned: `%s'\\n\", name);\n\t  if (strcmp (name, login) != 0)\n\t    {\n\t      puts (\"Error: getlogin and getlogin_r returned different names\");\n\t      ++errors;\n\t    }\n\t}\n      else\n\t{\n\t  printf (\"Error: getlogin_r returned: %d (%s)\\n\",\n\t\t  ret, strerror (ret));\n\t  ++errors;\n\t}\n    }\n  return errors != 0;\n}", "target": 0}
{"code": "MemoryRegion *memory_map(struct uc_struct *uc, hwaddr begin, size_t size, uint32_t perms)\n{\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n    memory_region_init_ram(uc, ram, size, perms);\n    if (ram->addr == -1) {\n        return NULL;\n    }\n    memory_region_add_subregion(uc->system_memory, begin, ram);\n    if (uc->cpu) {\n        tlb_flush(uc->cpu);\n    }\n    return ram;\n}", "target": 1}
{"code": "static void ikev2_parent_inI1outR1_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct ke_continuation *ke = (struct ke_continuation *)pcrc;\n\tstruct msg_digest *md = ke->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent inI1outR1: calculated ke+nonce, sending R1\"));\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t\treturn;\n\t}\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\tpassert(st->st_suspended_md == ke->md);\n\tset_suspended(st, NULL); \n\tset_cur_state(st);\n\tst->st_calculating = FALSE;\n\te = ikev2_parent_inI1outR1_tail(pcrc, r);\n\tif (ke->md != NULL) {\n\t\tcomplete_v2_state_transition(&ke->md, e);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t}\n\treset_globals();\n\tpassert(GLOBALS_ARE_RESET());\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, NoKeepWithGeoNear) {\n    params.options = QueryPlannerParams::KEEP_MUTATIONS;\n    addIndex(BSON(\"a\"\n                  << \"2d\"));\n    runQuery(fromjson(\"{a: {$near: [0,0], $maxDistance:0.3 }}\"));\n    ASSERT_EQUALS(getNumSolutions(), 1U);\n    assertSolutionExists(\"{geoNear2d: {a: '2d'}}\");\n}", "target": 0}
{"code": "void ide_atapi_cmd(IDEState *s)\n{\n    uint8_t *buf;\n    buf = s->io_buffer;\n#ifdef DEBUG_IDE_ATAPI\n    {\n        int i;\n        printf(\"ATAPI limit=0x%x packet:\", s->lcyl | (s->hcyl << 8));\n        for(i = 0; i < ATAPI_PACKET_SIZE; i++) {\n            printf(\" %02x\", buf[i]);\n        }\n        printf(\"\\n\");\n    }\n#endif\n    if (s->sense_key == UNIT_ATTENTION &&\n        !(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA)) {\n        ide_atapi_cmd_check_status(s);\n        return;\n    }\n    if (!s->tray_open && bdrv_is_inserted(s->bs) && s->cdrom_changed) {\n        ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);\n        s->cdrom_changed = 0;\n        s->sense_key = UNIT_ATTENTION;\n        s->asc = ASC_MEDIUM_MAY_HAVE_CHANGED;\n        return;\n    }\n    if ((atapi_cmd_table[s->io_buffer[0]].flags & CHECK_READY) &&\n        (!media_present(s) || !bdrv_is_inserted(s->bs)))\n    {\n        ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);\n        return;\n    }\n    if (atapi_cmd_table[s->io_buffer[0]].handler) {\n        atapi_cmd_table[s->io_buffer[0]].handler(s, buf);\n        return;\n    }\n    ide_atapi_cmd_error(s, ILLEGAL_REQUEST, ASC_ILLEGAL_OPCODE);\n}", "target": 0}
{"code": "int mp_invmod_mont_ct (mp_int * a, mp_int * b, mp_int * c, mp_digit mp)\n{\n  return fp_invmod_mont_ct(a, b, c, mp);\n}", "target": 0}
