{"code": "static void bnx2x_pf_tx_q_prep(struct bnx2x *bp,\n\tstruct bnx2x_fastpath *fp, struct bnx2x_txq_setup_params *txq_init,\n\tu8 cos)\n{\n\ttxq_init->dscr_map = fp->txdata_ptr[cos]->tx_desc_mapping;\n\ttxq_init->sb_cq_index = HC_INDEX_ETH_FIRST_TX_CQ_CONS + cos;\n\ttxq_init->traffic_type = LLFC_TRAFFIC_TYPE_NW;\n\ttxq_init->fw_sb_id = fp->fw_sb_id;\n\ttxq_init->tss_leading_cl_id = bnx2x_fp(bp, 0, cl_id);\n\tif (IS_FCOE_FP(fp)) {\n\t\ttxq_init->sb_cq_index = HC_SP_INDEX_ETH_FCOE_TX_CQ_CONS;\n\t\ttxq_init->traffic_type = LLFC_TRAFFIC_TYPE_FCOE;\n\t}\n}", "target": 0}
{"code": "ProcAllocColorCells(ClientPtr client)\n{\n    ColormapPtr pcmp;\n    int rc;\n    REQUEST(xAllocColorCellsReq);\n    REQUEST_SIZE_MATCH(xAllocColorCellsReq);\n    rc = dixLookupResourceByType((void **) &pcmp, stuff->cmap, RT_COLORMAP,\n                                 client, DixAddAccess);\n    if (rc == Success) {\n        int npixels, nmasks;\n        long length;\n        Pixel *ppixels, *pmasks;\n        npixels = stuff->colors;\n        if (!npixels) {\n            client->errorValue = npixels;\n            return BadValue;\n        }\n        if (stuff->contiguous != xTrue && stuff->contiguous != xFalse) {\n            client->errorValue = stuff->contiguous;\n            return BadValue;\n        }\n        nmasks = stuff->planes;\n        length = ((long) npixels + (long) nmasks) * sizeof(Pixel);\n        ppixels = malloc(length);\n        if (!ppixels)\n            return BadAlloc;\n        pmasks = ppixels + npixels;\n        if ((rc = AllocColorCells(client->index, pcmp, npixels, nmasks,\n                                  (Bool) stuff->contiguous, ppixels, pmasks))) {\n            free(ppixels);\n            return rc;\n        }\n#ifdef PANORAMIX\n        if (noPanoramiXExtension || !pcmp->pScreen->myNum)\n#endif\n        {\n            xAllocColorCellsReply accr = {\n                .type = X_Reply,\n                .sequenceNumber = client->sequence,\n                .length = bytes_to_int32(length),\n                .nPixels = npixels,\n                .nMasks = nmasks\n            };\n            WriteReplyToClient(client, sizeof(xAllocColorCellsReply), &accr);\n            client->pSwapReplyFunc = (ReplySwapPtr) Swap32Write;\n            WriteSwappedDataToClient(client, length, ppixels);\n        }\n        free(ppixels);\n        return Success;\n    }\n    else {\n        client->errorValue = stuff->cmap;\n        return rc;\n    }\n}", "target": 0}
{"code": "void nfcmrvl_nci_unregister_dev(struct nfcmrvl_private *priv)\n{\n\tstruct nci_dev *ndev = priv->ndev;\n\tif (priv->ndev->nfc_dev->fw_download_in_progress)\n\t\tnfcmrvl_fw_dnld_abort(priv);\n\tnfcmrvl_fw_dnld_deinit(priv);\n\tif (gpio_is_valid(priv->config.reset_n_io))\n\t\tgpio_free(priv->config.reset_n_io);\n\tnci_unregister_device(ndev);\n\tnci_free_device(ndev);\n\tkfree(priv);\n}", "target": 1}
{"code": "int CLASS ljpeg_diff_new (LibRaw_bit_buffer& bits, LibRaw_byte_buffer* buf,ushort *huff)\n{\n  int len, diff;\n  if(!huff || !buf)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  len = bits._gethuff_lj(buf,*huff,huff+1);\n  if (len == 16 && (!dng_version || dng_version >= 0x1010000))\n    return -32768;\n  diff = bits._getbits_lj(buf,len);\n  if ((diff & (1 << (len-1))) == 0)\n    diff -= (1 << len) - 1;\n  return diff;\n}", "target": 0}
{"code": "static int skip_boxes(JXLParseContext *ctx, const uint8_t *buf, int buf_size)\n{\n    GetByteContext gb;\n    if (ctx->skip > buf_size)\n        return AVERROR_BUFFER_TOO_SMALL;\n    buf += ctx->skip;\n    buf_size -= ctx->skip;\n    bytestream2_init(&gb, buf, buf_size);\n    while (1) {\n        uint64_t size;\n        int head_size = 4;\n        if (bytestream2_peek_le16(&gb) == FF_JPEGXL_CODESTREAM_SIGNATURE_LE)\n            break;\n        if (bytestream2_peek_le64(&gb) == FF_JPEGXL_CONTAINER_SIGNATURE_LE)\n            break;\n        if (bytestream2_get_bytes_left(&gb) < 8)\n            return AVERROR_BUFFER_TOO_SMALL;\n        size = bytestream2_get_be32(&gb);\n        if (size == 1) {\n            if (bytestream2_get_bytes_left(&gb) < 12)\n                return AVERROR_BUFFER_TOO_SMALL;\n            size = bytestream2_get_be64(&gb);\n            head_size = 12;\n        }\n        if (!size)\n            return AVERROR_INVALIDDATA;\n        if (size <= head_size + 4)\n            return AVERROR_INVALIDDATA;\n        ctx->skip += size;\n        bytestream2_skip(&gb, size - head_size);\n        if (bytestream2_get_bytes_left(&gb) <= 0)\n            return AVERROR_BUFFER_TOO_SMALL;\n    }\n    return 0;\n}", "target": 1}
{"code": "static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n{\n\tint i;\n\tunsigned char max_level = 0;\n\tint unix_sock_count = 0;\n\tif (too_many_unix_fds(current))\n\t\treturn -ETOOMANYREFS;\n\tfor (i = scm->fp->count - 1; i >= 0; i--) {\n\t\tstruct sock *sk = unix_get_socket(scm->fp->fp[i]);\n\t\tif (sk) {\n\t\t\tunix_sock_count++;\n\t\t\tmax_level = max(max_level,\n\t\t\t\t\tunix_sk(sk)->recursion_level);\n\t\t}\n\t}\n\tif (unlikely(max_level > MAX_RECURSION_LEVEL))\n\t\treturn -ETOOMANYREFS;\n\tUNIXCB(skb).fp = scm_fp_dup(scm->fp);\n\tif (!UNIXCB(skb).fp)\n\t\treturn -ENOMEM;\n\tfor (i = scm->fp->count - 1; i >= 0; i--)\n\t\tunix_inflight(scm->fp->user, scm->fp->fp[i]);\n\treturn max_level;\n}", "target": 0}
{"code": "const u32 *gf_isom_get_track_switch_parameter(GF_ISOFile *movie, u32 trackNumber, u32 group_index, u32 *switchGroupID, u32 *criteriaListSize)\n{\n\tGF_TrackBox *trak;\n\tGF_UserDataMap *map;\n\tGF_TrackSelectionBox *tsel;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!group_index || !trak || !trak->udta) return NULL;\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\tif (!map) return NULL;\n\ttsel = (GF_TrackSelectionBox*)gf_list_get(map->boxes, group_index-1);\n\tif (!tsel) return NULL;\n\t*switchGroupID = tsel->switchGroup;\n\t*criteriaListSize = tsel->attributeListCount;\n\treturn (const u32 *) tsel->attributeList;\n}", "target": 1}
{"code": "TEST_F(TestSPIFFEValidator, TestGetTrustBundleStore) {\n  initialize();\n  auto cert = readCertFromFile(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/extensions_cert.pem\"));\n  EXPECT_FALSE(validator().getTrustBundleStore(cert.get()));\n  cert = readCertFromFile(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/non_spiffe_san_cert.pem\"));\n  EXPECT_FALSE(validator().getTrustBundleStore(cert.get()));\n  cert = readCertFromFile(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/spiffe_san_cert.pem\"));\n  EXPECT_FALSE(validator().getTrustBundleStore(cert.get()));\n  validator().trustBundleStores().emplace(\"example.com\", X509StorePtr(X509_STORE_new()));\n  EXPECT_TRUE(validator().getTrustBundleStore(cert.get()));\n}", "target": 1}
{"code": "void test_rmdir(const char *path)\n{\n\tsize_t len = strlen(path) + 30;\n\tchar *tmpname = alloca(len);\n\tsnprintf(tmpname, len, \"%s/%d\", path, (int)getpid());\n\tif (rmdir(path) == 0 || errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at rmdir of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (rmdir(tmpname) == 0 || errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at rmdir of %s\\n\", tmpname);\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "static const char *sip_endpoint_identifier_type2str(enum ast_sip_endpoint_identifier_type method)\n{\n\tconst char *str = \"<unknown>\";\n\tswitch (method) {\n\tcase AST_SIP_ENDPOINT_IDENTIFY_BY_USERNAME:\n\t\tstr = \"username\";\n\t\tbreak;\n\tcase AST_SIP_ENDPOINT_IDENTIFY_BY_AUTH_USERNAME:\n\t\tstr = \"auth_username\";\n\t\tbreak;\n\tcase AST_SIP_ENDPOINT_IDENTIFY_BY_IP:\n\t\tstr = \"ip\";\n\t\tbreak;\n\tcase AST_SIP_ENDPOINT_IDENTIFY_BY_HEADER:\n\t\tstr = \"header\";\n\t\tbreak;\n\tcase AST_SIP_ENDPOINT_IDENTIFY_BY_REQUEST_URI:\n\t\tstr = \"request_uri\";\n\t\tbreak;\n\tcase AST_SIP_ENDPOINT_IDENTIFY_BY_TRANSPORT:\n\t\tstr = \"transport\";\n\t\tbreak;\n\t}\n\treturn str;\n}", "target": 1}
{"code": "static void do_free_keypair(struct rsa_keypair *key)\n{\n\tcrypto_bignum_free(key->e);\n\tcrypto_bignum_free(key->d);\n\tcrypto_bignum_free(key->n);\n\tcrypto_bignum_free(key->p);\n\tcrypto_bignum_free(key->q);\n\tcrypto_bignum_free(key->qp);\n\tcrypto_bignum_free(key->dp);\n\tcrypto_bignum_free(key->dq);\n}", "target": 1}
{"code": "njs_promise_resolve(njs_vm_t *vm, njs_value_t *constructor, njs_value_t *x)\n{\n    njs_int_t                 ret;\n    njs_value_t               value;\n    njs_object_t              *object;\n    njs_promise_capability_t  *capability;\n    static const njs_value_t  string_constructor = njs_string(\"constructor\");\n    if (njs_is_object(x)) {\n        object = njs_object_proto_lookup(njs_object(x), NJS_PROMISE,\n                                         njs_object_t);\n        if (object != NULL) {\n            ret = njs_value_property(vm, x, njs_value_arg(&string_constructor),\n                                     &value);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                return NULL;\n            }\n            if (njs_values_same(&value, constructor)) {\n                return njs_promise(x);\n            }\n        }\n    }\n    capability = njs_promise_new_capability(vm, constructor);\n    if (njs_slow_path(capability == NULL)) {\n        return NULL;\n    }\n    ret = njs_function_call(vm, njs_function(&capability->resolve),\n                            &njs_value_undefined, x, 1, &value);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return NULL;\n    }\n    return njs_promise(&capability->promise);\n}", "target": 1}
{"code": "static void cswitch(JF, js_Ast *ref, js_Ast *head)\n{\n\tjs_Ast *node, *clause, *def = NULL;\n\tint end;\n\tcexp(J, F, ref);\n\tfor (node = head; node; node = node->b) {\n\t\tclause = node->a;\n\t\tif (clause->type == STM_DEFAULT) {\n\t\t\tif (def)\n\t\t\t\tjsC_error(J, clause, \"more than one default label in switch\");\n\t\t\tdef = clause;\n\t\t} else {\n\t\t\tcexp(J, F, clause->a);\n\t\t\tclause->casejump = emitjump(J, F, OP_JCASE);\n\t\t}\n\t}\n\temit(J, F, OP_POP);\n\tif (def) {\n\t\tdef->casejump = emitjump(J, F, OP_JUMP);\n\t\tend = 0;\n\t} else {\n\t\tend = emitjump(J, F, OP_JUMP);\n\t}\n\tfor (node = head; node; node = node->b) {\n\t\tclause = node->a;\n\t\tlabel(J, F, clause->casejump);\n\t\tif (clause->type == STM_DEFAULT)\n\t\t\tcstmlist(J, F, clause->a);\n\t\telse\n\t\t\tcstmlist(J, F, clause->b);\n\t}\n\tif (end)\n\t\tlabel(J, F, end);\n}", "target": 0}
{"code": "vrrp_print_data(void)\n{\n\tFILE *file = fopen (dump_file, \"w\");\n\tif (!file) {\n\t\tlog_message(LOG_INFO, \"Can't open %s (%d: %s)\",\n\t\t\tdump_file, errno, strerror(errno));\n\t\treturn;\n\t}\n\tdump_data_vrrp(file);\n\tfclose(file);\n}", "target": 1}
{"code": "MagickExport void RegisterStaticModules(void)\n{\n  PolicyRights\n    rights;\n  size_t\n    extent;\n  ssize_t\n    i;\n  rights=ReadPolicyRights|WritePolicyRights;\n  extent=sizeof(MagickModules)/sizeof(MagickModules[0]);\n  for (i=0; i < (ssize_t) extent; i++)\n  {\n    if (MagickModules[i].registered == MagickFalse)\n      {\n        if (IsRightsAuthorized(ModulePolicyDomain,rights,\n              MagickModules[i].module) == MagickFalse)\n          continue;\n        (void) (MagickModules[i].register_module)();\n        MagickModules[i].registered=MagickTrue;\n      }\n  }\n}", "target": 0}
{"code": "ssh_packet_get_compress_state(struct sshbuf *m, struct ssh *ssh)\n{\n\tstruct session_state *state = ssh->state;\n\tstruct sshbuf *b;\n\tint r;\n\tif ((b = sshbuf_new()) == NULL)\n\t\treturn SSH_ERR_ALLOC_FAIL;\n\tif (state->compression_in_started) {\n\t\tif ((r = sshbuf_put_string(b, &state->compression_in_stream,\n\t\t    sizeof(state->compression_in_stream))) != 0)\n\t\t\tgoto out;\n\t} else if ((r = sshbuf_put_string(b, NULL, 0)) != 0)\n\t\tgoto out;\n\tif (state->compression_out_started) {\n\t\tif ((r = sshbuf_put_string(b, &state->compression_out_stream,\n\t\t    sizeof(state->compression_out_stream))) != 0)\n\t\t\tgoto out;\n\t} else if ((r = sshbuf_put_string(b, NULL, 0)) != 0)\n\t\tgoto out;\n\tr = sshbuf_put_stringb(m, b);\n out:\n\tsshbuf_free(b);\n\treturn r;\n}", "target": 1}
{"code": "fpAcc(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\tuint32 bps = tif->tif_dir.td_bitspersample / 8;\n\ttmsize_t wc = cc / bps;\n\ttmsize_t count = cc;\n\tuint8 *cp = (uint8 *) cp0;\n\tuint8 *tmp;\n    if(cc%(bps*stride)!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"fpAcc\",\n                     \"%s\", \"cc%(bps*stride))!=0\");\n        return 0;\n    }\n    tmp = (uint8 *)_TIFFmalloc(cc);\n\tif (!tmp)\n\t\treturn 0;\n\twhile (count > stride) {\n\t\tREPEAT4(stride, cp[stride] =\n                        (unsigned char) ((cp[stride] + cp[0]) & 0xff); cp++)\n\t\tcount -= stride;\n\t}\n\t_TIFFmemcpy(tmp, cp0, cc);\n\tcp = (uint8 *) cp0;\n\tfor (count = 0; count < wc; count++) {\n\t\tuint32 byte;\n\t\tfor (byte = 0; byte < bps; byte++) {\n\t\t\t#if WORDS_BIGENDIAN\n\t\t\tcp[bps * count + byte] = tmp[byte * wc + count];\n\t\t\t#else\n\t\t\tcp[bps * count + byte] =\n\t\t\t\ttmp[(bps - byte - 1) * wc + count];\n\t\t\t#endif\n\t\t}\n\t}\n\t_TIFFfree(tmp);\n    return 1;\n}", "target": 0}
{"code": "void ZlibInStream::removeUnderlying()\n{\n  ptr = end = start;\n  if (!underlying) return;\n  while (bytesIn > 0) {\n    decompress(true);\n    end = start; \n  }\n  underlying = 0;\n}", "target": 1}
{"code": "int ipmi_destroy_user(struct ipmi_user *user)\n{\n\t_ipmi_destroy_user(user);\n\tcleanup_srcu_struct(&user->release_barrier);\n\tkref_put(&user->refcount, free_user);\n\treturn 0;\n}", "target": 1}
{"code": "rrdp_process_deltas(struct update_notification *parent,\n    unsigned long cur_serial, struct visited_uris *visited_uris,\n    bool log_operation)\n{\n\tstruct proc_upd_args args;\n\targs.parent = parent;\n\targs.visited_uris = visited_uris;\n\targs.log_operation = log_operation;\n\treturn deltas_head_for_each(parent->deltas_list,\n\t    parent->global_data.serial, cur_serial, process_delta, &args);\n}", "target": 1}
{"code": "int main(int argc, char *argv[])\n{\n#ifdef _UNIX\n  setlocale(LC_ALL,\"\");\n#endif\n  InitConsole();\n  ErrHandler.SetSignalHandlers(true);\n#ifdef SFX_MODULE\n  wchar ModuleName[NM];\n#ifdef _WIN_ALL\n  GetModuleFileName(NULL,ModuleName,ASIZE(ModuleName));\n#else\n  CharToWide(argv[0],ModuleName,ASIZE(ModuleName));\n#endif\n#endif\n#ifdef _WIN_ALL\n  SetErrorMode(SEM_NOALIGNMENTFAULTEXCEPT|SEM_FAILCRITICALERRORS|SEM_NOOPENFILEERRORBOX);\n#endif\n#if defined(_WIN_ALL) && !defined(SFX_MODULE)\n  POWER_MODE ShutdownOnClose=POWERMODE_KEEP;\n#endif\n  try \n  {\n    CommandData *Cmd=new CommandData;\n#ifdef SFX_MODULE\n    wcscpy(Cmd->Command,L\"X\");\n    char *Switch=argc>1 ? argv[1]:NULL;\n    if (Switch!=NULL && Cmd->IsSwitch(Switch[0]))\n    {\n      int UpperCmd=etoupper(Switch[1]);\n      switch(UpperCmd)\n      {\n        case 'T':\n        case 'V':\n          Cmd->Command[0]=UpperCmd;\n          break;\n        case '?':\n          Cmd->OutHelp(RARX_SUCCESS);\n          break;\n      }\n    }\n    Cmd->AddArcName(ModuleName);\n    Cmd->ParseDone();\n    Cmd->AbsoluteLinks=true; \n#else \n    Cmd->ParseCommandLine(true,argc,argv);\n    if (!Cmd->ConfigDisabled)\n    {\n      Cmd->ReadConfig();\n      Cmd->ParseEnvVar();\n    }\n    Cmd->ParseCommandLine(false,argc,argv);\n#endif\n#if defined(_WIN_ALL) && !defined(SFX_MODULE)\n    ShutdownOnClose=Cmd->Shutdown;\n#endif\n    uiInit(Cmd->Sound);\n    InitLogOptions(Cmd->LogName,Cmd->ErrlogCharset);\n    ErrHandler.SetSilent(Cmd->AllYes || Cmd->MsgStream==MSG_NULL);\n    Cmd->OutTitle();\n    Cmd->ProcessCommand();\n    delete Cmd;\n  }\n  catch (RAR_EXIT ErrCode)\n  {\n    ErrHandler.SetErrorCode(ErrCode);\n  }\n  catch (std::bad_alloc&)\n  {\n    ErrHandler.MemoryErrorMsg();\n    ErrHandler.SetErrorCode(RARX_MEMORY);\n  }\n  catch (...)\n  {\n    ErrHandler.SetErrorCode(RARX_FATAL);\n  }\n#if defined(_WIN_ALL) && !defined(SFX_MODULE)\n  if (ShutdownOnClose!=POWERMODE_KEEP && ErrHandler.IsShutdownEnabled())\n    Shutdown(ShutdownOnClose);\n#endif\n  ErrHandler.MainExit=true;\n  return ErrHandler.GetErrorCode();\n}", "target": 0}
{"code": "int __nla_parse(struct nlattr **tb, int maxtype,\n\t\tconst struct nlattr *head, int len,\n\t\tconst struct nla_policy *policy, unsigned int validate,\n\t\tstruct netlink_ext_ack *extack)\n{\n\treturn __nla_validate_parse(head, len, maxtype, policy, validate,\n\t\t\t\t    extack, tb);\n}", "target": 1}
{"code": "void Server::CheckDocRoot() {\n  try {\n    if (!fs::exists(doc_root_) || !fs::is_directory(doc_root_)) {\n      LOG_ERRO(\"Doc root is not an existing directory!\");\n      return;\n    }\n    if (doc_root_.is_relative()) {\n      doc_root_ = fs::absolute(doc_root_);\n    }\n    doc_root_ = fs::canonical(doc_root_);\n  } catch (fs::filesystem_error& e) {\n    LOG_ERRO(\"Doc root error: %s\", e.what());\n    doc_root_.clear();\n  }\n  LOG_INFO(\"Doc root: %s\", doc_root_.u8string().c_str());\n}", "target": 0}
{"code": "GF_Err gf_isom_reset_tables(GF_ISOFile *movie, Bool reset_sample_count)\n{\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i;\n\tif (!movie || !movie->moov || !movie->moov->mvex) return GF_BAD_PARAM;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox *)gf_list_get(movie->moov->trackList, i);\n\t\tu32 dur;\n\t\tu64 dts;\n\t\tGF_SampleTableBox *stbl = trak->Media->information->sampleTable;\n\t\ttrak->sample_count_at_seg_start += stbl->SampleSize->sampleCount;\n\t\tif (trak->sample_count_at_seg_start) {\n\t\t\tGF_Err e;\n\t\t\te = stbl_GetSampleDTS_and_Duration(stbl->TimeToSample, stbl->SampleSize->sampleCount, &dts, &dur);\n\t\t\tif (e == GF_OK) {\n\t\t\t\ttrak->dts_at_seg_start += dts + dur;\n\t\t\t}\n\t\t}\n\t\tgf_isom_recreate_tables(trak);\n#if 0\n\t\tj = stbl->nb_stbl_boxes;\n\t\twhile ((a = (GF_Box *)gf_list_enum(stbl->child_boxes, &j))) {\n\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, a);\n\t\t\tj--;\n\t\t}\n#endif\n\t\tif (reset_sample_count) {\n\t\t\ttrak->Media->information->sampleTable->SampleSize->sampleCount = 0;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\ttrak->sample_count_at_seg_start = 0;\n\t\t\ttrak->dts_at_seg_start = 0;\n\t\t\ttrak->first_traf_merged = GF_FALSE;\n#endif\n\t\t}\n\t}\n\tif (reset_sample_count) {\n\t\tmovie->NextMoofNumber = 0;\n\t}\n#endif\n\treturn GF_OK;\n}", "target": 0}
{"code": "int get_evtchn_to_irq(evtchn_port_t evtchn)\n{\n\tif (evtchn >= xen_evtchn_max_channels())\n\t\treturn -1;\n\tif (evtchn_to_irq[EVTCHN_ROW(evtchn)] == NULL)\n\t\treturn -1;\n\treturn evtchn_to_irq[EVTCHN_ROW(evtchn)][EVTCHN_COL(evtchn)];\n}", "target": 1}
{"code": "ikev1_cr_print(netdissect_options *ndo, u_char tpay _U_,\n\t       const struct isakmp_gen *ext, u_int item_len,\n\t       const u_char *ep _U_, uint32_t phase _U_, uint32_t doi0 _U_,\n\t       uint32_t proto0 _U_, int depth _U_)\n{\n\tconst struct ikev1_pl_cert *p;\n\tstruct ikev1_pl_cert cert;\n\tstatic const char *certstr[] = {\n\t\t\"none\",\t\"pkcs7\", \"pgp\", \"dns\",\n\t\t\"x509sign\", \"x509ke\", \"kerberos\", \"crl\",\n\t\t\"arl\", \"spki\", \"x509attr\",\n\t};\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_CR)));\n\tp = (const struct ikev1_pl_cert *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&cert, ext, sizeof(cert));\n\tND_PRINT((ndo,\" len=%d\", item_len - 4));\n\tND_PRINT((ndo,\" type=%s\", STR_OR_ID((cert.encode), certstr)));\n\tif (2 < ndo->ndo_vflag && 4 < item_len) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), item_len - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_CR)));\n\treturn NULL;\n}", "target": 0}
{"code": "lyd_new_output_anydata(struct lyd_node *parent, const struct lys_module *module, const char *name,\n                       void *value, LYD_ANYDATA_VALUETYPE value_type)\n{\n    const struct lys_node *siblings, *snode;\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n    siblings = lyd_new_find_schema(parent, module, 1);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_ANYDATA, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n    return lyd_create_anydata(parent, snode, value, value_type);\n}", "target": 1}
{"code": "    template<typename t>\n    CImg<T>& operator+=(const t value) {\n      if (is_empty()) return *this;\n      cimg_pragma_openmp(parallel for cimg_openmp_if(size()>=524288))\n      cimg_rof(*this,ptrd,T) *ptrd = (T)(*ptrd + value);\n      return *this;", "target": 0}
{"code": "pci_emul_dinit(struct vmctx *ctx, struct pci_vdev *dev, char *opts)\n{\n\tint error;\n\tstruct pci_emul_dummy *dummy;\n\tdummy = calloc(1, sizeof(struct pci_emul_dummy));\n\tdev->arg = dummy;\n\tpci_set_cfgdata16(dev, PCIR_DEVICE, 0x0001);\n\tpci_set_cfgdata16(dev, PCIR_VENDOR, 0x10DD);\n\tpci_set_cfgdata8(dev, PCIR_CLASS, 0x02);\n\terror = pci_emul_add_msicap(dev, PCI_EMUL_MSI_MSGS);\n\tassert(error == 0);\n\terror = pci_emul_alloc_bar(dev, 0, PCIBAR_IO, DIOSZ);\n\tassert(error == 0);\n\terror = pci_emul_alloc_bar(dev, 1, PCIBAR_MEM32, DMEMSZ);\n\tassert(error == 0);\n\terror = pci_emul_alloc_bar(dev, 2, PCIBAR_MEM32, DMEMSZ);\n\tassert(error == 0);\n\treturn 0;\n}", "target": 1}
{"code": "integerify(void * B, size_t r)\n{\n  uint32_t * X = (uint32_t *)((uintptr_t)(B) + (2 * r - 1) * 64);\n  return (((uint64_t)(X[13]) << 32) + X[0]);\n}", "target": 1}
{"code": "void luaD_callnoyield (lua_State *L, StkId func, int nResults) {\n  incXCcalls(L);\n  if (getCcalls(L) <= CSTACKERR)  \n    luaE_freeCI(L);\n  luaD_call(L, func, nResults);\n  decXCcalls(L);\n}", "target": 1}
{"code": "static int handle_wrmsr(struct kvm_vcpu *vcpu)\n{\n\tstruct msr_data msr;\n\tu32 ecx = vcpu->arch.regs[VCPU_REGS_RCX];\n\tu64 data = (vcpu->arch.regs[VCPU_REGS_RAX] & -1u)\n\t\t| ((u64)(vcpu->arch.regs[VCPU_REGS_RDX] & -1u) << 32);\n\tmsr.data = data;\n\tmsr.index = ecx;\n\tmsr.host_initiated = false;\n\tif (vmx_set_msr(vcpu, &msr) != 0) {\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\ttrace_kvm_msr_write(ecx, data);\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}", "target": 1}
{"code": "void test_symlink(const char *path)\n{\n\tchar *d = strdupa(path), *tmpname;\n\td = dirname(d);\n\tsize_t len = strlen(path) + 30;\n\ttmpname = alloca(len);\n\tsnprintf(tmpname, len, \"%s/%d\", d, (int)getpid());\n\tif (symlink(tmpname, path) == 0) {\n\t\tfprintf(stderr, \"leak at symlink of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at symlink of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n\tif (symlink(path, tmpname) == 0) {\n\t\tfprintf(stderr, \"leak at symlink (2) of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at symlink (2) of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "gss_unwrap_iov (minor_status,\n                context_handle,\n                conf_state,\n                qop_state,\n                iov,\n                iov_count)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nint *\t\t\tconf_state;\ngss_qop_t\t\t*qop_state;\ngss_iov_buffer_desc  *\tiov;\nint\t\t\tiov_count;\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    status = val_unwrap_iov_args(minor_status, context_handle,\n\t\t\t\t conf_state, qop_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech) {\n\tif (mech->gss_unwrap_iov) {\n\t    status = mech->gss_unwrap_iov(\n\t\t\t\t \t  minor_status,\n\t\t\t\t\t  ctx->internal_ctx_id,\n\t\t\t\t\t  conf_state,\n\t\t\t\t\t  qop_state,\n\t\t\t\t\t  iov,\n\t\t\t\t\t  iov_count);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\treturn(status);\n    }\n    return (GSS_S_BAD_MECH);\n}", "target": 0}
{"code": "static char *r_buf_read_string (RBuffer *buf, ut64 addr, int len) {\n\tut8 *data = malloc (len);\n\tif (data) {\n\t\tr_buf_read_at (buf, addr, data, len);\n\t\tdata[len-1] = 0;\n\t\treturn data;\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "static char *get_nextpath(char *path, int *offsetp, int fulllen)\n{\n\tint offset = *offsetp;\n\tif (offset >= fulllen)\n\t\treturn NULL;\n\twhile (path[offset] != '\\0' && offset < fulllen)\n\t\toffset++;\n\twhile (path[offset] == '\\0' && offset < fulllen)\n\t\toffset++;\n\t*offsetp = offset;\n\treturn (offset < fulllen) ? &path[offset] : NULL;\n}", "target": 0}
{"code": "nd_format_time(char *buf, size_t bufsize, const char *format,\n         const struct tm *timeptr)\n{\n\tif (timeptr != NULL) {\n\t\tif (strftime(buf, bufsize, format, timeptr) != 0)\n\t\t\treturn (buf);\n\t\telse\n\t\t\treturn (\"[nd_format_time() buffer is too small]\");\n\t} else\n\t\treturn (\"[localtime() or gmtime() couldn't convert the date and time]\");\n}", "target": 0}
{"code": "int X509_get_pubkey_parameters(EVP_PKEY *pkey, STACK_OF(X509) *chain)\n{\n    EVP_PKEY *ktmp = NULL, *ktmp2;\n    int i, j;\n    if ((pkey != NULL) && !EVP_PKEY_missing_parameters(pkey))\n        return 1;\n    for (i = 0; i < sk_X509_num(chain); i++) {\n        ktmp = X509_get_pubkey(sk_X509_value(chain, i));\n        if (ktmp == NULL) {\n            X509err(X509_F_X509_GET_PUBKEY_PARAMETERS,\n                    X509_R_UNABLE_TO_GET_CERTS_PUBLIC_KEY);\n            return 0;\n        }\n        if (!EVP_PKEY_missing_parameters(ktmp))\n            break;\n        EVP_PKEY_free(ktmp);\n        ktmp = NULL;\n    }\n    if (ktmp == NULL) {\n        X509err(X509_F_X509_GET_PUBKEY_PARAMETERS,\n                X509_R_UNABLE_TO_FIND_PARAMETERS_IN_CHAIN);\n        return 0;\n    }\n    for (j = i - 1; j >= 0; j--) {\n        ktmp2 = X509_get_pubkey(sk_X509_value(chain, j));\n        EVP_PKEY_copy_parameters(ktmp2, ktmp);\n        EVP_PKEY_free(ktmp2);\n    }\n    if (pkey != NULL)\n        EVP_PKEY_copy_parameters(pkey, ktmp);\n    EVP_PKEY_free(ktmp);\n    return 1;\n}", "target": 0}
{"code": "flatpak_context_set_persistent (FlatpakContext *context,\n                                const char     *path)\n{\n  g_hash_table_insert (context->persistent, g_strdup (path), GINT_TO_POINTER (1));\n}", "target": 1}
{"code": "register_commands (assuan_context_t ctx)\n{\n  static struct {\n    const char *name;\n    assuan_handler_t handler;\n    const char * const help;\n  } table[] = {\n    { \"SERIALNO\",     cmd_serialno, hlp_serialno },\n    { \"LEARN\",        cmd_learn,    hlp_learn },\n    { \"READCERT\",     cmd_readcert, hlp_readcert },\n    { \"READKEY\",      cmd_readkey,  hlp_readkey },\n    { \"SETDATA\",      cmd_setdata,  hlp_setdata },\n    { \"PKSIGN\",       cmd_pksign,   hlp_pksign },\n    { \"PKAUTH\",       cmd_pkauth,   hlp_pkauth },\n    { \"PKDECRYPT\",    cmd_pkdecrypt,hlp_pkdecrypt },\n    { \"INPUT\",        NULL },\n    { \"OUTPUT\",       NULL },\n    { \"GETATTR\",      cmd_getattr,  hlp_getattr },\n    { \"SETATTR\",      cmd_setattr,  hlp_setattr },\n    { \"WRITECERT\",    cmd_writecert,hlp_writecert },\n    { \"WRITEKEY\",     cmd_writekey, hlp_writekey },\n    { \"GENKEY\",       cmd_genkey,   hlp_genkey },\n    { \"RANDOM\",       cmd_random,   hlp_random },\n    { \"PASSWD\",       cmd_passwd,   hlp_passwd },\n    { \"CHECKPIN\",     cmd_checkpin, hlp_checkpin },\n    { \"LOCK\",         cmd_lock,     hlp_lock },\n    { \"UNLOCK\",       cmd_unlock,   hlp_unlock },\n    { \"GETINFO\",      cmd_getinfo,  hlp_getinfo },\n    { \"RESTART\",      cmd_restart,  hlp_restart },\n    { \"DISCONNECT\",   cmd_disconnect,hlp_disconnect },\n    { \"APDU\",         cmd_apdu,     hlp_apdu },\n    { \"KILLSCD\",      cmd_killscd,  hlp_killscd },\n    { NULL }\n  };\n  int i, rc;\n  for (i=0; table[i].name; i++)\n    {\n      rc = assuan_register_command (ctx, table[i].name, table[i].handler,\n                                    table[i].help);\n      if (rc)\n        return rc;\n    }\n  assuan_set_hello_line (ctx, \"GNU Privacy Guard's Smartcard server ready\");\n  assuan_register_reset_notify (ctx, reset_notify);\n  assuan_register_option_handler (ctx, option_handler);\n  return 0;\n}", "target": 0}
{"code": "static void svm_write_tsc_offset(struct kvm_vcpu *vcpu, u64 offset)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 g_tsc_offset = 0;\n\tif (is_guest_mode(vcpu)) {\n\t\tg_tsc_offset = svm->vmcb->control.tsc_offset -\n\t\t\t       svm->nested.hsave->control.tsc_offset;\n\t\tsvm->nested.hsave->control.tsc_offset = offset;\n\t} else\n\t\ttrace_kvm_write_tsc_offset(vcpu->vcpu_id,\n\t\t\t\t\t   svm->vmcb->control.tsc_offset,\n\t\t\t\t\t   offset);\n\tsvm->vmcb->control.tsc_offset = offset + g_tsc_offset;\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n}", "target": 0}
{"code": "error::Error GLES2DecoderImpl::HandleGetUniformfv(\n    uint32 immediate_data_size, const gles2::GetUniformfv& c) {\n  GLuint program = c.program;\n  GLint fake_location = program_manager()->UnswizzleLocation(c.location);\n  GLuint service_id;\n  GLint real_location = -1;\n  Error error;\n  typedef gles2::GetUniformfv::Result Result;\n  Result* result;\n  GLenum result_type;\n  if (GetUniformSetup(\n      program, fake_location, c.params_shm_id, c.params_shm_offset,\n      &error, &real_location, &service_id,\n      reinterpret_cast<void**>(&result), &result_type)) {\n    if (result_type == GL_BOOL || result_type == GL_BOOL_VEC2 ||\n        result_type == GL_BOOL_VEC3 || result_type == GL_BOOL_VEC4) {\n      GLsizei num_values = result->GetNumResults();\n      scoped_array<GLint> temp(new GLint[num_values]);\n      glGetUniformiv(service_id, real_location, temp.get());\n      GLfloat* dst = result->GetData();\n      for (GLsizei ii = 0; ii < num_values; ++ii) {\n        dst[ii] = (temp[ii] != 0);\n      }\n    } else {\n      glGetUniformfv(service_id, real_location, result->GetData());\n    }\n  }\n  return error;\n}", "target": 0}
{"code": "static struct sock *sctp_v6_create_accept_sk(struct sock *sk,\n\t\t\t\t\t     struct sctp_association *asoc,\n\t\t\t\t\t     bool kern)\n{\n\tstruct sock *newsk;\n\tstruct ipv6_pinfo *newnp, *np = inet6_sk(sk);\n\tstruct sctp6_sock *newsctp6sk;\n\tstruct ipv6_txoptions *opt;\n\tnewsk = sk_alloc(sock_net(sk), PF_INET6, GFP_KERNEL, sk->sk_prot, kern);\n\tif (!newsk)\n\t\tgoto out;\n\tsock_init_data(NULL, newsk);\n\tsctp_copy_sock(newsk, sk, asoc);\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\tnewsctp6sk = (struct sctp6_sock *)newsk;\n\tinet_sk(newsk)->pinet6 = &newsctp6sk->inet6;\n\tsctp_sk(newsk)->v4mapped = sctp_sk(sk)->v4mapped;\n\tnewnp = inet6_sk(newsk);\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\tnewnp->ipv6_mc_list = NULL;\n\tnewnp->ipv6_ac_list = NULL;\n\tnewnp->ipv6_fl_list = NULL;\n\trcu_read_lock();\n\topt = rcu_dereference(np->opt);\n\tif (opt)\n\t\topt = ipv6_dup_options(newsk, opt);\n\tRCU_INIT_POINTER(newnp->opt, opt);\n\trcu_read_unlock();\n\tsctp_v6_to_sk_daddr(&asoc->peer.primary_addr, newsk);\n\tnewsk->sk_v6_rcv_saddr = sk->sk_v6_rcv_saddr;\n\tsk_refcnt_debug_inc(newsk);\n\tif (newsk->sk_prot->init(newsk)) {\n\t\tsk_common_release(newsk);\n\t\tnewsk = NULL;\n\t}\nout:\n\treturn newsk;\n}", "target": 0}
{"code": "void CClient::EchoMessage(const CMessage& Message) {\n    CMessage EchoedMessage = Message;\n    for (CClient* pClient : GetClients()) {\n        if (pClient->HasEchoMessage() ||\n            (pClient != this && (m_pNetwork->IsChan(Message.GetParam(0)) ||\n                                 pClient->HasSelfMessage()))) {\n            EchoedMessage.SetNick(GetNickMask());\n            pClient->PutClient(EchoedMessage);\n        }\n    }\n}", "target": 1}
{"code": "static void smp_task_timedout(struct timer_list *t)\n{\n\tstruct sas_task_slow *slow = from_timer(slow, t, timer);\n\tstruct sas_task *task = slow->task;\n\tunsigned long flags;\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE))\n\t\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\tcomplete(&task->slow_task->completion);\n}", "target": 1}
{"code": "int crxParamInit(CrxBandParam **param, uint64_t subbandMdatOffset,\n                 uint64_t subbandDataSize, uint32_t subbandWidth,\n                 uint32_t subbandHeight, int32_t supportsPartial,\n                 uint32_t roundedBitsMask, LibRaw_abstract_datastream *input)\n{\n  int32_t progrDataSize = supportsPartial ? 0 : sizeof(int32_t) * subbandWidth;\n  int32_t paramLength = 2 * subbandWidth + 4;\n  uint8_t *paramBuf = (uint8_t *)calloc(\n      1, sizeof(CrxBandParam) + sizeof(int32_t) * paramLength + progrDataSize);\n  if (!paramBuf)\n    return -1;\n  *param = (CrxBandParam *)paramBuf;\n  paramBuf += sizeof(CrxBandParam);\n  (*param)->paramData = (int32_t *)paramBuf;\n  (*param)->nonProgrData =\n      progrDataSize ? (*param)->paramData + paramLength : 0;\n  (*param)->subbandWidth = subbandWidth;\n  (*param)->subbandHeight = subbandHeight;\n  (*param)->roundedBits = 0;\n  (*param)->curLine = 0;\n  (*param)->roundedBitsMask = roundedBitsMask;\n  (*param)->supportsPartial = supportsPartial;\n  (*param)->bitStream.bitData = 0;\n  (*param)->bitStream.bitsLeft = 0;\n  (*param)->bitStream.mdatSize = subbandDataSize;\n  (*param)->bitStream.curPos = 0;\n  (*param)->bitStream.curBufSize = 0;\n  (*param)->bitStream.curBufOffset = subbandMdatOffset;\n  (*param)->bitStream.input = input;\n  crxFillBuffer(&(*param)->bitStream);\n  return 0;\n}", "target": 1}
{"code": "PrimitiveStatus TrustedPrimitives::UntrustedCall(uint64_t untrusted_selector,\n                                                 MessageWriter *input,\n                                                 MessageReader *output) {\n  int ret;\n  UntrustedCacheMalloc *untrusted_cache = UntrustedCacheMalloc::Instance();\n  SgxParams *const sgx_params =\n      reinterpret_cast<SgxParams *>(untrusted_cache->Malloc(sizeof(SgxParams)));\n  if (!TrustedPrimitives::IsOutsideEnclave(sgx_params, sizeof(SgxParams))) {\n    TrustedPrimitives::BestEffortAbort(\n        \"UntrustedCall: sgx_param should be in untrusted memory\");\n  }\n  Cleanup clean_up(\n      [sgx_params, untrusted_cache] { untrusted_cache->Free(sgx_params); });\n  sgx_params->input_size = 0;\n  sgx_params->input = nullptr;\n  if (input) {\n    sgx_params->input_size = input->MessageSize();\n    if (sgx_params->input_size > 0) {\n      sgx_params->input = untrusted_cache->Malloc(sgx_params->input_size);\n      const void *input_pointer = sgx_params->input;\n      uint64_t input_size = sgx_params->input_size;\n      if (!TrustedPrimitives::IsOutsideEnclave(input_pointer, input_size)) {\n        TrustedPrimitives::BestEffortAbort(\n            \"UntrustedCall: sgx_param input should be in untrusted memory\");\n      }\n      input->Serialize(const_cast<void *>(input_pointer));\n    }\n  }\n  sgx_params->output_size = 0;\n  sgx_params->output = nullptr;\n  CHECK_OCALL(\n      ocall_dispatch_untrusted_call(&ret, untrusted_selector, sgx_params));\n  if (sgx_params->input) {\n    untrusted_cache->Free(const_cast<void *>(sgx_params->input));\n  }\n  const void *output_pointer = sgx_params->output;\n  uint64_t output_size = sgx_params->output_size;\n  if (!TrustedPrimitives::IsOutsideEnclave(output_pointer, output_size)) {\n    TrustedPrimitives::BestEffortAbort(\n        \"UntrustedCall: sgx_param output should be in untrusted memory\");\n  }\n  if (sgx_params->output) {\n    output->Deserialize(output_pointer, output_size);\n    TrustedPrimitives::UntrustedLocalFree(sgx_params->output);\n  }\n  return PrimitiveStatus::OkStatus();\n}", "target": 0}
{"code": "static inline int fpregs_state_valid(struct fpu *fpu, unsigned int cpu)\n{\n\treturn fpu == this_cpu_read_stable(fpu_fpregs_owner_ctx) && cpu == fpu->last_cpu;\n}", "target": 1}
{"code": "gss_context_time (minor_status,\n                  context_handle,\n                  time_rec)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nOM_uint32 *\t\ttime_rec;\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n    *minor_status = 0;\n    if (time_rec == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech) {\n\tif (mech->gss_context_time) {\n\t    status = mech->gss_context_time(\n\t\t\t\t\t    minor_status,\n\t\t\t\t\t    ctx->internal_ctx_id,\n\t\t\t\t\t    time_rec);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\treturn(status);\n    }\n    return (GSS_S_BAD_MECH);\n}", "target": 0}
{"code": "const FunctionDef* FunctionLibraryDefinition::GetAttrImpl(\n    const NodeDef& ndef) const {\n  if (ndef.op() != kGradientOp) {\n    return Find(ndef.op());\n  }\n  const NameAttrList* forward_func_attrs;\n  if (!TryGetNodeAttr(ndef, kFuncAttr, &forward_func_attrs)) {\n    return nullptr;\n  }\n  const string& func_name = forward_func_attrs->name();\n  {\n    tf_shared_lock l(mu_);\n    const string& grad_name = FindGradientHelper(func_name);\n    if (!grad_name.empty()) {\n      if (const auto helper = FindHelper(grad_name)) {\n        return &(helper->fdef);\n      } else {\n        return nullptr;\n      }\n    }\n    if (const auto helper = FindHelper(func_name)) {\n      return &(helper->fdef);\n    } else {\n      return nullptr;\n    }\n  }\n}", "target": 0}
{"code": "  SPLITS_TYPE RangeSize(T start, T limit, T delta) {\n    if (((delta > 0) && (limit < start)) || ((delta < 0) && (limit > start))) {\n      return 0;\n    }\n    return (std::is_integral<T>::value\n                ? ((std::abs(limit - start) + std::abs(delta) - 1) /\n                   std::abs(delta))\n                : std::ceil(std::abs((limit - start) / delta)));\n  }", "target": 1}
{"code": "MONGO_EXPORT int bson_append_code_n( bson *b, const char *name, const char *value, int len ) {\n    return bson_append_string_base( b, name, value, len, BSON_CODE );\n}", "target": 1}
{"code": "chdlc_print(netdissect_options *ndo, register const u_char *p, u_int length)\n{\n\tu_int proto;\n\tconst u_char *bp = p;\n\tif (length < CHDLC_HDRLEN)\n\t\tgoto trunc;\n\tND_TCHECK2(*p, CHDLC_HDRLEN);\n\tproto = EXTRACT_16BITS(&p[2]);\n\tif (ndo->ndo_eflag) {\n                ND_PRINT((ndo, \"%s, ethertype %s (0x%04x), length %u: \",\n                       tok2str(chdlc_cast_values, \"0x%02x\", p[0]),\n                       tok2str(ethertype_values, \"Unknown\", proto),\n                       proto,\n                       length));\n\t}\n\tlength -= CHDLC_HDRLEN;\n\tp += CHDLC_HDRLEN;\n\tswitch (proto) {\n\tcase ETHERTYPE_IP:\n\t\tip_print(ndo, p, length);\n\t\tbreak;\n\tcase ETHERTYPE_IPV6:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\tcase CHDLC_TYPE_SLARP:\n\t\tchdlc_slarp_print(ndo, p, length);\n\t\tbreak;\n#if 0\n\tcase CHDLC_TYPE_CDP:\n\t\tchdlc_cdp_print(p, length);\n\t\tbreak;\n#endif\n        case ETHERTYPE_MPLS:\n        case ETHERTYPE_MPLS_MULTI:\n                mpls_print(ndo, p, length);\n\t\tbreak;\n        case ETHERTYPE_ISO:\n                if (length < 2)\n                    goto trunc;\n                ND_TCHECK_16BITS(p);\n                if (*(p+1) == 0x81 ||\n                    *(p+1) == 0x82 ||\n                    *(p+1) == 0x83)\n                    isoclns_print(ndo, p + 1, length - 1, ndo->ndo_snapend - p - 1);\n                else\n                    isoclns_print(ndo, p, length, ndo->ndo_snapend - p);\n                break;\n\tdefault:\n                if (!ndo->ndo_eflag)\n                        ND_PRINT((ndo, \"unknown CHDLC protocol (0x%04x)\", proto));\n                break;\n\t}\n\treturn (CHDLC_HDRLEN);\ntrunc:\n\tND_PRINT((ndo, \"[|chdlc]\"));\n\treturn ndo->ndo_snapend - bp;\n}", "target": 0}
{"code": "int tipc_nl_publ_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint err;\n\tu32 tsk_portid = cb->args[0];\n\tu32 last_publ = cb->args[1];\n\tu32 done = cb->args[2];\n\tstruct net *net = sock_net(skb->sk);\n\tstruct tipc_sock *tsk;\n\tif (!tsk_portid) {\n\t\tstruct nlattr **attrs;\n\t\tstruct nlattr *sock[TIPC_NLA_SOCK_MAX + 1];\n\t\terr = tipc_nlmsg_parse(cb->nlh, &attrs);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (!attrs[TIPC_NLA_SOCK])\n\t\t\treturn -EINVAL;\n\t\terr = nla_parse_nested(sock, TIPC_NLA_SOCK_MAX,\n\t\t\t\t       attrs[TIPC_NLA_SOCK],\n\t\t\t\t       tipc_nl_sock_policy);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (!sock[TIPC_NLA_SOCK_REF])\n\t\t\treturn -EINVAL;\n\t\ttsk_portid = nla_get_u32(sock[TIPC_NLA_SOCK_REF]);\n\t}\n\tif (done)\n\t\treturn 0;\n\ttsk = tipc_sk_lookup(net, tsk_portid);\n\tif (!tsk)\n\t\treturn -EINVAL;\n\tlock_sock(&tsk->sk);\n\terr = __tipc_nl_list_sk_publ(skb, cb, tsk, &last_publ);\n\tif (!err)\n\t\tdone = 1;\n\trelease_sock(&tsk->sk);\n\tsock_put(&tsk->sk);\n\tcb->args[0] = tsk_portid;\n\tcb->args[1] = last_publ;\n\tcb->args[2] = done;\n\treturn skb->len;\n}", "target": 0}
{"code": "static MagickBooleanType WritePTIFImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  Image\n    *images,\n    *next,\n    *pyramid_image;\n  ImageInfo\n    *write_info;\n  MagickBooleanType\n    status;\n  PointInfo\n    resolution;\n  size_t\n    columns,\n    rows;\n  images=NewImageList();\n  for (next=image; next != (Image *) NULL; next=GetNextImageInList(next))\n  {\n    Image\n      *clone_image;\n    clone_image=CloneImage(next,0,0,MagickFalse,exception);\n    if (clone_image == (Image *) NULL)\n      break;\n    clone_image->previous=NewImageList();\n    clone_image->next=NewImageList();\n    (void) SetImageProperty(clone_image,\"tiff:subfiletype\",\"none\",exception);\n    AppendImageToList(&images,clone_image);\n    columns=next->columns;\n    rows=next->rows;\n    resolution=next->resolution;\n    while ((columns > 64) && (rows > 64))\n    {\n      columns/=2;\n      rows/=2;\n      resolution.x/=2;\n      resolution.y/=2;\n      pyramid_image=ResizeImage(next,columns,rows,image->filter,exception);\n      if (pyramid_image == (Image *) NULL)\n        break;\n      pyramid_image->resolution=resolution;\n      (void) SetImageProperty(pyramid_image,\"tiff:subfiletype\",\"REDUCEDIMAGE\",\n        exception);\n      AppendImageToList(&images,pyramid_image);\n    }\n  }\n  if (images != (Image *) NULL)\n    {\n      images=GetFirstImageInList(images);\n      write_info=CloneImageInfo(image_info);\n      write_info->adjoin=MagickTrue;\n      (void) CopyMagickString(write_info->magick,\"TIFF\",MagickPathExtent);\n      (void) CopyMagickString(images->magick,\"TIFF\",MagickPathExtent);\n      status=WriteTIFFImage(write_info,images,exception);\n      images=DestroyImageList(images);\n      write_info=DestroyImageInfo(write_info);\n    }\n  return(status);\n}", "target": 0}
{"code": "static int selinux_inode_getsecurity(struct inode *inode, const char *name, void **buffer, bool alloc)\n{\n\tu32 size;\n\tint error;\n\tchar *context = NULL;\n\tstruct inode_security_struct *isec;\n\tif (strcmp(name, XATTR_SELINUX_SUFFIX))\n\t\treturn -EOPNOTSUPP;\n\tisec = inode_security(inode);\n\tif (has_cap_mac_admin(false))\n\t\terror = security_sid_to_context_force(&selinux_state,\n\t\t\t\t\t\t      isec->sid, &context,\n\t\t\t\t\t\t      &size);\n\telse\n\t\terror = security_sid_to_context(&selinux_state, isec->sid,\n\t\t\t\t\t\t&context, &size);\n\tif (error)\n\t\treturn error;\n\terror = size;\n\tif (alloc) {\n\t\t*buffer = context;\n\t\tgoto out_nofree;\n\t}\n\tkfree(context);\nout_nofree:\n\treturn error;\n}", "target": 0}
{"code": "void *MACH0_(mach0_free)(struct MACH0_(obj_t) *mo) {\n\tif (!mo) {\n\t\treturn NULL;\n\t}\n\tsize_t i;\n\tif (mo->symbols) {\n\t\tfor (i = 0; !mo->symbols[i].last; i++) {\n\t\t\tfree (mo->symbols[i].name);\n\t\t}\n\t\tfree (mo->symbols);\n\t}\n\tfree (mo->segs);\n\tfree (mo->sects);\n\tfree (mo->symtab);\n\tfree (mo->symstr);\n\tfree (mo->indirectsyms);\n\tfree (mo->imports_by_ord);\n\tht_pp_free (mo->imports_by_name);\n\tfree (mo->dyld_info);\n\tfree (mo->toc);\n\tfree (mo->modtab);\n\tfree (mo->libs);\n\tfree (mo->func_start);\n\tfree (mo->signature);\n\tfree (mo->intrp);\n\tfree (mo->compiler);\n\tif (mo->chained_starts) {\n\t\tfor (i = 0; i < mo->nsegs; i++) {\n\t\t\tif (mo->chained_starts[i]) {\n\t\t\t\tfree (mo->chained_starts[i]->page_start);\n\t\t\t\tfree (mo->chained_starts[i]);\n\t\t\t}\n\t\t}\n\t\tfree (mo->chained_starts);\n\t}\n\tr_buf_free (mo->b);\n\tfree (mo);\n\treturn NULL;\n}", "target": 1}
{"code": "prepenv(const struct rule *rule)\n{\n\tstatic const char *safeset[] = {\n\t\t\"DISPLAY\", \"HOME\", \"LOGNAME\", \"MAIL\",\n\t\t\"PATH\", \"TERM\", \"USER\", \"USERNAME\",\n\t\tNULL\n\t};\n\tstruct env *env;\n\tenv = createenv(rule);\n\tif (!(rule->options & KEEPENV))\n\t\tfillenv(env, safeset);\n\tif (rule->envlist)\n\t\tfillenv(env, rule->envlist);\n\treturn flattenenv(env);\n}", "target": 1}
{"code": "void gf_filter_pid_inst_del(GF_FilterPidInst *pidinst)\n{\n\tassert(pidinst);\n\tgf_filter_pid_inst_reset(pidinst);\n \tgf_fq_del(pidinst->packets, (gf_destruct_fun) pcki_del);\n\tgf_mx_del(pidinst->pck_mx);\n\tgf_list_del(pidinst->pck_reassembly);\n\tif (pidinst->props) {\n\t\tassert(pidinst->props->reference_count);\n\t\tif (safe_int_dec(&pidinst->props->reference_count) == 0) {\n\t\t\tgf_mx_p(pidinst->pid->filter->tasks_mx);\n\t\t\tgf_list_del_item(pidinst->pid->properties, pidinst->props);\n\t\t\tgf_mx_v(pidinst->pid->filter->tasks_mx);\n\t\t\tgf_props_del(pidinst->props);\n\t\t}\n\t}\n\tgf_free(pidinst);\n}", "target": 1}
{"code": "pci_get_cfgdata32(struct pci_vdev *dev, int offset)\n{\n\tassert(offset <= (PCI_REGMAX - 3) && (offset & 3) == 0);\n\treturn (*(uint32_t *)(dev->cfgdata + offset));\n}", "target": 1}
{"code": "static void vc_uniscr_insert(struct vc_data *vc, unsigned int nr)\n{\n\tstruct uni_screen *uniscr = get_vc_uniscr(vc);\n\tif (uniscr) {\n\t\tchar32_t *ln = uniscr->lines[vc->vc_y];\n\t\tunsigned int x = vc->vc_x, cols = vc->vc_cols;\n\t\tmemmove(&ln[x + nr], &ln[x], (cols - x - nr) * sizeof(*ln));\n\t\tmemset32(&ln[x], ' ', nr);\n\t}\n}", "target": 0}
{"code": "\tvoid Execute(CommandSource &source, const std::vector<Anope::string> &params) anope_override\n\t{\n\t\tconst NickAlias *na;\n\t\tif (!(na = NickAlias::Find(params[0])))\n\t\t\tsource.Reply(NICK_X_NOT_REGISTERED, params[0].c_str());\n\t\telse if (na->nc->HasExt(\"NS_SUSPENDED\"))\n\t\t\tsource.Reply(NICK_X_SUSPENDED, na->nc->display.c_str());\n\t\telse if (!na->nc->email.equals_ci(params[1]))\n\t\t\tsource.Reply(_(\"Incorrect email address.\"));\n\t\telse\n\t\t{\n\t\t\tif (SendResetEmail(source.GetUser(), na, source.service))\n\t\t\t{\n\t\t\t\tLog(LOG_COMMAND, source, this) << \"for \" << na->nick << \" (group: \" << na->nc->display << \")\";\n\t\t\t\tsource.Reply(_(\"Password reset email for \\002%s\\002 has been sent.\"), na->nick.c_str());\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}", "target": 0}
{"code": "static char* umocktypes_stringify_bool_ptr(const bool** value)\n{\n    char* result;\n    result = (char*)my_gballoc_malloc(8);\n    if (result != NULL)\n    {\n        if (*value == NULL)\n        {\n            (void)strcpy(result, \"{NULL}\");\n        }\n        else if (*(*value) == true)\n        {\n            (void)strcpy(result, \"{true}\");\n        }\n        else\n        {\n            (void)strcpy(result, \"{false}\");\n        }\n    }\n    return result;\n}", "target": 0}
{"code": "static void mmtimer_setup_int_0(int cpu, u64 expires)\n{\n\tu64 val;\n\tHUB_S((u64 *)LOCAL_MMR_ADDR(SH_RTC1_INT_ENABLE), 0UL);\n\tHUB_S((u64 *)LOCAL_MMR_ADDR(SH_INT_CMPB), -1L);\n\tmmtimer_clr_int_pending(0);\n\tval = ((u64)SGI_MMTIMER_VECTOR << SH_RTC1_INT_CONFIG_IDX_SHFT) |\n\t\t((u64)cpu_physical_id(cpu) <<\n\t\t\tSH_RTC1_INT_CONFIG_PID_SHFT);\n\tHUB_S((u64 *)LOCAL_MMR_ADDR(SH_RTC1_INT_CONFIG), val);\n\tHUB_S((u64 *)LOCAL_MMR_ADDR(SH_RTC1_INT_ENABLE), 1UL);\n\tHUB_S((u64 *)LOCAL_MMR_ADDR(SH_INT_CMPB), expires);\n}", "target": 0}
{"code": "RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {\n\tint i;\n\tif (!bin || !bin->segment_entries) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_list_newf (free);\n\tfor (i = 0; i < bin->ne_header->SegCount; i++) {\n\t\tRBinSection *bs = R_NEW0 (RBinSection);\n\t\tif (!bs) {\n\t\t\treturn segments;\n\t\t}\n\t\tNE_image_segment_entry *se = &bin->segment_entries[i];\n\t\tbs->size = se->length;\n\t\tbs->vsize = se->minAllocSz ? se->minAllocSz : 64000;\n\t\tbs->bits = R_SYS_BITS_16;\n\t\tbs->is_data = se->flags & IS_DATA;\n\t\tbs->perm = __translate_perms (se->flags);\n\t\tbs->paddr = (ut64)se->offset * bin->alignment;\n\t\tbs->name = r_str_newf (\"%s.%\" PFMT64d, se->flags & IS_MOVEABLE ? \"MOVEABLE\" : \"FIXED\", bs->paddr);\n\t\tbs->is_segment = true;\n\t\tr_list_append (segments, bs);\n\t}\n\tbin->segments = segments;\n\treturn segments;\n}", "target": 0}
{"code": "SYSCALL_DEFINE4(ptrace, long, request, long, pid, unsigned long, addr,\n\t\tunsigned long, data)\n{\n\tstruct task_struct *child;\n\tlong ret;\n\tif (request == PTRACE_TRACEME) {\n\t\tret = ptrace_traceme();\n\t\tif (!ret)\n\t\t\tarch_ptrace_attach(current);\n\t\tgoto out;\n\t}\n\tchild = ptrace_get_task_struct(pid);\n\tif (IS_ERR(child)) {\n\t\tret = PTR_ERR(child);\n\t\tgoto out;\n\t}\n\tif (request == PTRACE_ATTACH || request == PTRACE_SEIZE) {\n\t\tret = ptrace_attach(child, request, addr, data);\n\t\tif (!ret)\n\t\t\tarch_ptrace_attach(child);\n\t\tgoto out_put_task_struct;\n\t}\n\tret = ptrace_check_attach(child, request == PTRACE_KILL ||\n\t\t\t\t  request == PTRACE_INTERRUPT);\n\tif (ret < 0)\n\t\tgoto out_put_task_struct;\n\tret = arch_ptrace(child, request, addr, data);\n\tif (ret || request != PTRACE_DETACH)\n\t\tptrace_unfreeze_traced(child);\n out_put_task_struct:\n\tput_task_struct(child);\n out:\n\treturn ret;\n}", "target": 0}
{"code": "xmlValidNormalizeString(xmlChar *str) {\n    xmlChar *dst;\n    const xmlChar *src;\n    if (str == NULL)\n        return;\n    src = str;\n    dst = str;\n    while (*src == 0x20) src++;\n    while (*src != 0) {\n\tif (*src == 0x20) {\n\t    while (*src == 0x20) src++;\n\t    if (*src != 0)\n\t\t*dst++ = 0x20;\n\t} else {\n\t    *dst++ = *src++;\n\t}\n    }\n    *dst = 0;\n}", "target": 0}
{"code": "static int req_ssl_var_lookup(lua_State *L)\n{\n    request_rec *r = ap_lua_check_request_rec(L, 1);\n    const char *s = luaL_checkstring(L, 2);\n    const char *res = ap_lua_ssl_val(r->pool, r->server, r->connection, r, \n                                     (char *)s);\n    lua_pushstring(L, res);\n    return 1;\n}", "target": 0}
{"code": "static int xar_hash_check(int hash, const void * result, const void * expected)\n{\n    int len;\n    if (!result || !expected)\n        return 1;\n    switch (hash) {\n    case XAR_CKSUM_SHA1:\n        len = SHA1_HASH_SIZE;\n        break;\n    case XAR_CKSUM_MD5:\n        len = CLI_HASH_MD5;\n        break;\n    case XAR_CKSUM_OTHER:\n    case XAR_CKSUM_NONE:\n    default:\n        return 1;\n    }\n    return memcmp(result, expected, len);\n}", "target": 1}
{"code": "static freelist_idx_t next_random_slot(union freelist_init_state *state)\n{\n\treturn (state->list[state->pos++] + state->rand) % state->count;\n}", "target": 1}
{"code": "static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)\n{\n    FILE *fp = fopen(dest_filename, \"wx\");\n    if (!fp)\n        return false;\n    unsigned fd = 0;\n    while (fd <= 99999) \n    {\n        sprintf(source_filename + source_base_ofs, \"fd/%u\", fd);\n        char *name = malloc_readlink(source_filename);\n        if (!name)\n            break;\n        fprintf(fp, \"%u:%s\\n\", fd, name);\n        free(name);\n        sprintf(source_filename + source_base_ofs, \"fdinfo/%u\", fd);\n        fd++;\n        FILE *in = fopen(source_filename, \"r\");\n        if (!in)\n            continue;\n        char buf[128];\n        while (fgets(buf, sizeof(buf)-1, in))\n        {\n            char *eol = strchrnul(buf, '\\n');\n            eol[0] = '\\n';\n            eol[1] = '\\0';\n            fputs(buf, fp);\n        }\n        fclose(in);\n    }\n    const int dest_fd = fileno(fp);\n    if (fchown(dest_fd, uid, gid) < 0)\n    {\n        perror_msg(\"Can't change '%s' ownership to %lu:%lu\", dest_filename, (long)uid, (long)gid);\n        fclose(fp);\n        unlink(dest_filename);\n        return false;\n    }\n    fclose(fp);\n    return true;\n}", "target": 0}
{"code": "ldns_str2rdf_tag(ldns_rdf **rd, const char *str)\n{\n\tuint8_t *data;\n\tconst char* ptr;\n\tif (strlen(str) > 255) {\n\t\treturn LDNS_STATUS_INVALID_TAG;\n\t}\n\tfor (ptr = str; *ptr; ptr++) {\n\t\tif (! isalnum((unsigned char)*ptr)) {\n\t\t\treturn LDNS_STATUS_INVALID_TAG;\n\t\t}\n\t}\n\tdata = LDNS_XMALLOC(uint8_t, strlen(str) + 1);\n        if (!data) {\n\t\treturn LDNS_STATUS_MEM_ERR;\n\t}\n\tdata[0] = strlen(str);\n\tmemcpy(data + 1, str, strlen(str));\n\t*rd = ldns_rdf_new(LDNS_RDF_TYPE_TAG, strlen(str) + 1, data);\n\tif (!*rd) {\n\t\tLDNS_FREE(data);\n\t\treturn LDNS_STATUS_MEM_ERR;\n\t}\n\treturn LDNS_STATUS_OK;\n}", "target": 0}
{"code": "static int sd_compat_ioctl(struct block_device *bdev, fmode_t mode,\n\t\t\t   unsigned int cmd, unsigned long arg)\n{\n\tstruct scsi_device *sdev = scsi_disk(bdev->bd_disk)->device;\n\tif (!scsi_block_when_processing_errors(sdev))\n\t\treturn -ENODEV;\n\tif (sdev->host->hostt->compat_ioctl) {\n\t\tint ret;\n\t\tret = sdev->host->hostt->compat_ioctl(sdev, cmd, (void __user *)arg);\n\t\treturn ret;\n\t}\n\treturn -ENOIOCTLCMD; \n}", "target": 1}
{"code": "void InstanceKlass::remove_unshareable_info() {\n  if (can_be_verified_at_dumptime()) {\n    set_verified_at_dump_time();\n  }\n  Klass::remove_unshareable_info();\n  if (SystemDictionaryShared::has_class_failed_verification(this)) {\n    return;\n  }\n  _init_state = allocated;\n  { \n    assert(SafepointSynchronize::is_at_safepoint(), \"only called at safepoint\");\n    init_implementor();\n  }\n  constants()->remove_unshareable_info();\n  for (int i = 0; i < methods()->length(); i++) {\n    Method* m = methods()->at(i);\n    m->remove_unshareable_info();\n  }\n  if (array_klasses() != NULL) {\n    array_klasses()->remove_unshareable_info();\n  }\n  _source_debug_extension = NULL;\n  _dep_context = NULL;\n  _osr_nmethods_head = NULL;\n#if INCLUDE_JVMTI\n  _breakpoints = NULL;\n  _previous_versions = NULL;\n  _cached_class_file = NULL;\n  _jvmti_cached_class_field_map = NULL;\n#endif\n  _init_thread = NULL;\n  _methods_jmethod_ids = NULL;\n  _jni_ids = NULL;\n  _oop_map_cache = NULL;\n  _nest_host = NULL;\n  init_shared_package_entry();\n  _dep_context_last_cleaned = 0;\n}", "target": 0}
{"code": "static inline unsigned long get_tpuser(void)\n{\n\tunsigned long reg = 0;\n\tif (has_tls_reg && !tls_emu)\n\t\t__asm__(\"mrc p15, 0, %0, c13, c0, 2\" : \"=r\" (reg));\n\treturn reg;\n}", "target": 0}
{"code": "TEE_Result syscall_hash_init(unsigned long state,\n\t\t\t     const void *iv __maybe_unused,\n\t\t\t     size_t iv_len __maybe_unused)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = crypto_hash_init(cs->ctx, cs->algo);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\t{\n\t\t\tstruct tee_obj *o;\n\t\t\tstruct tee_cryp_obj_secret *key;\n\t\t\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  cs->key1, &o);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tif ((o->info.handleFlags &\n\t\t\t     TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\t\tres = crypto_mac_init(cs->ctx, cs->algo,\n\t\t\t\t\t      (void *)(key + 1), key->key_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\tcs->state = CRYP_STATE_INITIALIZED;\n\treturn TEE_SUCCESS;\n}", "target": 0}
{"code": "void snd_timer_notify(struct snd_timer *timer, int event, struct timespec *tstamp)\n{\n\tunsigned long flags;\n\tunsigned long resolution = 0;\n\tstruct snd_timer_instance *ti, *ts;\n\tif (timer->card && timer->card->shutdown)\n\t\treturn;\n\tif (! (timer->hw.flags & SNDRV_TIMER_HW_SLAVE))\n\t\treturn;\n\tif (snd_BUG_ON(event < SNDRV_TIMER_EVENT_MSTART ||\n\t\t       event > SNDRV_TIMER_EVENT_MRESUME))\n\t\treturn;\n\tspin_lock_irqsave(&timer->lock, flags);\n\tif (event == SNDRV_TIMER_EVENT_MSTART ||\n\t    event == SNDRV_TIMER_EVENT_MCONTINUE ||\n\t    event == SNDRV_TIMER_EVENT_MRESUME) {\n\t\tif (timer->hw.c_resolution)\n\t\t\tresolution = timer->hw.c_resolution(timer);\n\t\telse\n\t\t\tresolution = timer->hw.resolution;\n\t}\n\tlist_for_each_entry(ti, &timer->active_list_head, active_list) {\n\t\tif (ti->ccallback)\n\t\t\tti->ccallback(ti, event, tstamp, resolution);\n\t\tlist_for_each_entry(ts, &ti->slave_active_head, active_list)\n\t\t\tif (ts->ccallback)\n\t\t\t\tts->ccallback(ts, event, tstamp, resolution);\n\t}\n\tspin_unlock_irqrestore(&timer->lock, flags);\n}", "target": 0}
{"code": "int mem_check_range(struct rxe_mem *mem, u64 iova, size_t length)\n{\n\tswitch (mem->type) {\n\tcase RXE_MEM_TYPE_DMA:\n\t\treturn 0;\n\tcase RXE_MEM_TYPE_MR:\n\tcase RXE_MEM_TYPE_FMR:\n\t\treturn ((iova < mem->iova) ||\n\t\t\t((iova + length) > (mem->iova + mem->length))) ?\n\t\t\t-EFAULT : 0;\n\tdefault:\n\t\treturn -EFAULT;\n\t}\n}", "target": 1}
{"code": "bool ParseAttrValue(StringPiece type, StringPiece text, AttrValue* out) {\n  string field_name;\n  bool is_list = absl::ConsumePrefix(&type, \"list(\");\n  if (absl::ConsumePrefix(&type, \"string\")) {\n    field_name = \"s\";\n  } else if (absl::ConsumePrefix(&type, \"int\")) {\n    field_name = \"i\";\n  } else if (absl::ConsumePrefix(&type, \"float\")) {\n    field_name = \"f\";\n  } else if (absl::ConsumePrefix(&type, \"bool\")) {\n    field_name = \"b\";\n  } else if (absl::ConsumePrefix(&type, \"type\")) {\n    field_name = \"type\";\n  } else if (absl::ConsumePrefix(&type, \"shape\")) {\n    field_name = \"shape\";\n  } else if (absl::ConsumePrefix(&type, \"tensor\")) {\n    field_name = \"tensor\";\n  } else if (absl::ConsumePrefix(&type, \"func\")) {\n    field_name = \"func\";\n  } else if (absl::ConsumePrefix(&type, \"placeholder\")) {\n    field_name = \"placeholder\";\n  } else {\n    return false;\n  }\n  if (is_list && !absl::ConsumePrefix(&type, \")\")) {\n    return false;\n  }\n  string to_parse;\n  if (is_list) {\n    StringPiece cleaned = text;\n    str_util::RemoveLeadingWhitespace(&cleaned);\n    str_util::RemoveTrailingWhitespace(&cleaned);\n    if (cleaned.size() < 2 || cleaned[0] != '[' ||\n        cleaned[cleaned.size() - 1] != ']') {\n      return false;\n    }\n    cleaned.remove_prefix(1);\n    str_util::RemoveLeadingWhitespace(&cleaned);\n    if (cleaned.size() == 1) {\n      out->Clear();\n      out->mutable_list();\n      return true;\n    }\n    to_parse = strings::StrCat(\"list { \", field_name, \": \", text, \" }\");\n  } else {\n    to_parse = strings::StrCat(field_name, \": \", text);\n  }\n  return ProtoParseFromString(to_parse, out);\n}", "target": 1}
{"code": "static int php_curl_option_str(php_curl *ch, zend_long option, const char *str, const int len, zend_bool make_copy)\n{\n\tCURLcode error = CURLE_OK;\n\tif (strlen(str) != len) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Curl option contains invalid characters (\\\\0)\");\n\t\treturn FAILURE;\n\t}\n#if LIBCURL_VERSION_NUM >= 0x071100\n\tif (make_copy) {\n#endif\n\t\tchar *copystr;\n\t\tcopystr = estrndup(str, len);\n\t\terror = curl_easy_setopt(ch->cp, option, copystr);\n\t\tzend_llist_add_element(&ch->to_free->str, &copystr);\n#if LIBCURL_VERSION_NUM >= 0x071100\n\t} else {\n\t\terror = curl_easy_setopt(ch->cp, option, str);\n\t}\n#endif\n\tSAVE_CURL_ERROR(ch, error)\n\treturn error == CURLE_OK ? SUCCESS : FAILURE;\n}", "target": 0}
{"code": "static inline union cpu_time_count cpu_time_sub(const clockid_t which_clock,\n\t\t\t\t\t\tunion cpu_time_count a,\n\t\t\t\t\t\tunion cpu_time_count b)\n{\n\tif (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED) {\n\t\ta.sched -= b.sched;\n\t}  else {\n\t\ta.cpu = cputime_sub(a.cpu, b.cpu);\n\t}\n\treturn a;\n}", "target": 0}
{"code": "static void TEST_sub_add_single(void)\n{\n\tstruct mosquitto__config config;\n\tstruct mosquitto__listener listener;\n\tstruct mosquitto context;\n\tstruct mosquitto__subhier *sub;\n\tint rc;\n\tmemset(&db, 0, sizeof(struct mosquitto_db));\n\tmemset(&config, 0, sizeof(struct mosquitto__config));\n\tmemset(&listener, 0, sizeof(struct mosquitto__listener));\n\tmemset(&context, 0, sizeof(struct mosquitto));\n\tcontext.id = \"client\";\n\tdb.config = &config;\n\tlistener.port = 1883;\n\tconfig.listeners = &listener;\n\tconfig.listener_count = 1;\n\tdb__open(&config);\n\trc = sub__add(&context, \"a/b/c/d/e\", 0, 0, 0);\n\tCU_ASSERT_EQUAL(rc, MOSQ_ERR_SUCCESS);\n\tCU_ASSERT_PTR_NOT_NULL(db.subs);\n\tif(db.subs){\n\t\tsub = db.subs;\n\t\thier_quick_check(&sub, NULL, \"\");\n\t\thier_quick_check(&sub, NULL, \"\");\n\t\thier_quick_check(&sub, NULL, \"a\");\n\t\thier_quick_check(&sub, NULL, \"b\");\n\t\thier_quick_check(&sub, NULL, \"c\");\n\t\thier_quick_check(&sub, NULL, \"d\");\n\t\thier_quick_check(&sub, &context, \"e\");\n\t\tCU_ASSERT_PTR_NULL(sub);\n\t}\n\tmosquitto__free(context.subs);\n\tdb__close();\n}", "target": 1}
{"code": "int ar6000_create_ap_interface(struct ar6_softc *ar, char *ap_ifname)\n{\n    struct net_device *dev;\n    struct ar_virtual_interface *arApDev;\n    dev = alloc_etherdev(sizeof(struct ar_virtual_interface));\n    if (dev == NULL) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_create_ap_interface: can't alloc etherdev\\n\"));\n        return A_ERROR;\n    } \n    ether_setup(dev);\n    init_netdev(dev, ap_ifname);\n    dev->priv_flags &= ~IFF_TX_SKB_SHARING;\n    if (register_netdev(dev)) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_create_ap_interface: register_netdev failed\\n\"));\n        return A_ERROR;\n    }\n    arApDev = netdev_priv(dev);\n    arApDev->arDev = ar;\n    arApDev->arNetDev = dev;\n    arApDev->arStaNetDev = ar->arNetDev;\n    ar->arApDev = arApDev;\n    arApNetDev = dev;\n    memcpy(dev->dev_addr, ar->arNetDev->dev_addr, AR6000_ETH_ADDR_LEN);\n    return 0;\n}", "target": 0}
{"code": "snmp_ber_encode_length(unsigned char *out, uint32_t *out_len, uint8_t length)\n{\n  *out-- = length;\n  (*out_len)++;\n  return out;\n}", "target": 1}
{"code": "void watchdogSignalHandler(int sig, siginfo_t *info, void *secret) {\n#ifdef HAVE_BACKTRACE\n    ucontext_t *uc = (ucontext_t*) secret;\n#else\n    (void)secret;\n#endif\n    UNUSED(info);\n    UNUSED(sig);\n    serverLogFromHandler(LL_WARNING,\"\\n--- WATCHDOG TIMER EXPIRED ---\");\n#ifdef HAVE_BACKTRACE\n    logStackTrace(getMcontextEip(uc), 1);\n#else\n    serverLogFromHandler(LL_WARNING,\"Sorry: no support for backtrace().\");\n#endif\n    serverLogFromHandler(LL_WARNING,\"--------\\n\");\n}", "target": 1}
{"code": "static RBinWasmCustomNameEntry *parse_custom_name_entry(RBinWasmObj *bin, ut64 bound) {\n\tRBuffer *b = bin->buf;\n\tRBinWasmCustomNameEntry *cust = R_NEW0 (RBinWasmCustomNameEntry);\n\tif (!cust) {\n\t\treturn NULL;\n\t}\n\tcust->type = R_BIN_WASM_NAMETYPE_None;\n\tsize_t start = r_buf_tell (b);\n\tif (!consume_u7_r (b, bound, &cust->type)) {\n\t\tgoto beach;\n\t};\n\tif (!consume_u32_r (b, bound, &cust->size)) {\n\t\tgoto beach;\n\t};\n\tswitch (cust->type) {\n\tcase R_BIN_WASM_NAMETYPE_Module:\n\t\tif (!consume_encoded_name_new (b, bound, NULL, &cust->mod_name)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tbreak;\n\tcase R_BIN_WASM_NAMETYPE_Function:\n\t\tcust->func = R_NEW0 (RBinWasmCustomNameFunctionNames);\n\t\tif (!cust->func) {\n\t\t\tgoto beach;\n\t\t}\n\t\tcust->func->names = r_id_storage_new (0, UT32_MAX);\n\t\tif (!cust->func->names) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (!parse_namemap (b, bound, cust->func->names, &cust->func->count)) {\n\t\t\tgoto beach;\n\t\t}\n\t\tbreak;\n\tcase R_BIN_WASM_NAMETYPE_Local:\n\t\tcust->local = parse_custom_names_local (b, bound);\n\t\tif (!cust->local) {\n\t\t\tgoto beach;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tR_LOG_WARN (\"[wasm] Halting custom name section parsing at unknown type 0x%x offset 0x%\" PFMTSZx \"\\n\", cust->type, start);\n\t\tcust->type = R_BIN_WASM_NAMETYPE_None;\n\t\tgoto beach;\n\t}\n\treturn cust;\nbeach:\n\twasm_custom_name_free (cust);\n\treturn NULL;\n}", "target": 0}
{"code": "utf32le_mbc_case_fold(OnigCaseFoldType flag,\n\t\t      const UChar** pp, const UChar* end, UChar* fold)\n{\n  const UChar* p = *pp;\n  if (ONIGENC_IS_ASCII_CODE(*p) && *(p+1) == 0 && *(p+2) == 0 && *(p+3) == 0) {\n#ifdef USE_UNICODE_CASE_FOLD_TURKISH_AZERI\n    if ((flag & ONIGENC_CASE_FOLD_TURKISH_AZERI) != 0) {\n      if (*p == 0x49) {\n        *fold++ = 0x31;\n        *fold++ = 0x01;\n      }\n    }\n    else {\n#endif\n      *fold++ = ONIGENC_ASCII_CODE_TO_LOWER_CASE(*p);\n      *fold++ = 0;\n#ifdef USE_UNICODE_CASE_FOLD_TURKISH_AZERI\n    }\n#endif\n    *fold++ = 0;\n    *fold   = 0;\n    *pp += 4;\n    return 4;\n  }\n  else\n    return onigenc_unicode_mbc_case_fold(ONIG_ENCODING_UTF32_LE, flag, pp, end,\n                                         fold);\n}", "target": 0}
{"code": "int ecall_answer(struct ecall *ecall, enum icall_call_type call_type,\n\t\t bool audio_cbr)\n{\n\tint err = 0;\n\tif (!ecall)\n\t\treturn EINVAL;\n#ifdef ECALL_CBR_ALWAYS_ON\n\taudio_cbr = true;\n#endif\n\tinfo(\"ecall(%p): answer on pending econn %p call_type=%d\\n\", ecall, ecall->econn, call_type);\n\tif (!ecall->econn) {\n\t\twarning(\"ecall: answer: econn does not exist!\\n\");\n\t\treturn ENOENT;\n\t}\n\tif (ECONN_PENDING_INCOMING != econn_current_state(ecall->econn)) {\n\t\tinfo(\"ecall(%p): answer: invalid state (%s)\\n\", ecall,\n\t\t     econn_state_name(econn_current_state(ecall->econn)));\n\t\treturn EPROTO;\n\t}\n\tif (!ecall->flow) {\n\t\twarning(\"ecall: answer: no mediaflow\\n\");\n\t\treturn EPROTO;\n\t}\n\tecall->call_type = call_type;\n\tIFLOW_CALL(ecall->flow, set_call_type, call_type);\n\tecall->audio_cbr = audio_cbr;\n\tIFLOW_CALL(ecall->flow, set_audio_cbr, audio_cbr);\n#if 0\n\tif (ecall->props_local) {\n\t\tconst char *vstate_string =\n\t\t\tcall_type == ICALL_CALL_TYPE_VIDEO ? \"true\" : \"false\";\n\t\tint err2 = econn_props_update(ecall->props_local, \"videosend\", vstate_string);\n\t\tif (err2) {\n\t\t\twarning(\"ecall(%p): econn_props_update(videosend)\",\n\t\t\t\t\" failed (%m)\\n\", ecall, err2);\n\t\t}\n\t}\n#endif\n\terr = generate_or_gather_answer(ecall, ecall->econn);\n\tif (err) {\n\t\twarning(\"ecall: answer: failed to gather_or_answer\\n\");\n\t\tgoto out;\n\t}\n\tecall->answered = true;\n\tecall->audio_setup_time = -1;\n\tecall->call_estab_time = -1;\n\tecall->ts_answered = tmr_jiffies();\n out:\n\treturn err;\n}", "target": 1}
{"code": "static MagickBooleanType WriteINLINEImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  char\n    *base64,\n    message[MagickPathExtent];\n  const MagickInfo\n    *magick_info;\n  Image\n    *write_image;\n  ImageInfo\n    *write_info;\n  MagickBooleanType\n    status;\n  size_t\n    blob_length,\n    encode_length;\n  unsigned char\n    *blob;\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  write_info=CloneImageInfo(image_info);\n  (void) SetImageInfo(write_info,1,exception);\n  if (LocaleCompare(write_info->magick,\"INLINE\") == 0)\n    (void) CopyMagickString(write_info->magick,image->magick,MagickPathExtent);\n  magick_info=GetMagickInfo(write_info->magick,exception);\n  if ((magick_info == (const MagickInfo *) NULL) ||\n      (GetMagickMimeType(magick_info) == (const char *) NULL))\n    ThrowWriterException(CorruptImageError,\"ImageTypeNotSupported\");\n  (void) CopyMagickString(image->filename,write_info->filename,\n    MagickPathExtent);\n  blob_length=2048;\n  write_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (write_image == (Image *) NULL)\n    {\n      write_info=DestroyImageInfo(write_info);\n      return(MagickTrue);\n    }\n  blob=(unsigned char *) ImageToBlob(write_info,write_image,&blob_length,\n    exception);\n  write_image=DestroyImage(write_image);\n  write_info=DestroyImageInfo(write_info);\n  if (blob == (unsigned char *) NULL)\n    return(MagickFalse);\n  encode_length=0;\n  base64=Base64Encode(blob,blob_length,&encode_length);\n  blob=(unsigned char *) RelinquishMagickMemory(blob);\n  if (base64 == (char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      base64=DestroyString(base64);\n      return(status);\n    }\n  (void) FormatLocaleString(message,MagickPathExtent,\"data:%s;base64,\",\n    GetMagickMimeType(magick_info));\n  (void) WriteBlobString(image,message);\n  (void) WriteBlobString(image,base64);\n  base64=DestroyString(base64);\n  return(MagickTrue);\n}", "target": 1}
{"code": "static inline int xsave_state_booting(struct xsave_struct *fx, u64 mask)\n{\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\tint err = 0;\n\tWARN_ON(system_state != SYSTEM_BOOTING);\n\tif (boot_cpu_has(X86_FEATURE_XSAVES))\n\t\tasm volatile(\"1:\"XSAVES\"\\n\\t\"\n\t\t\t\"2:\\n\\t\"\n\t\t\t: : \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t\t:   \"memory\");\n\telse\n\t\tasm volatile(\"1:\"XSAVE\"\\n\\t\"\n\t\t\t\"2:\\n\\t\"\n\t\t\t: : \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t\t:   \"memory\");\n\tasm volatile(xstate_fault\n\t\t     : \"0\" (0)\n\t\t     : \"memory\");\n\treturn err;\n}", "target": 1}
{"code": "static int open_if_safe(int dirfd, const char *nextpath)\n{\n\tint newfd = openat(dirfd, nextpath, O_RDONLY | O_NOFOLLOW);\n\tif (newfd >= 0) \n\t\treturn newfd;\n\tif (errno == ELOOP)\n\t\treturn newfd;\n\tif (errno == EPERM || errno == EACCES) {\n\t\tnewfd = openat(dirfd, nextpath, O_PATH | O_NOFOLLOW);\n\t\tif (newfd >= 0) {\n\t\t\tint ret = check_symlink(newfd);\n\t\t\tif (ret < 0) {\n\t\t\t\tclose(newfd);\n\t\t\t\tnewfd = ret;\n\t\t\t}\n\t\t}\n\t}\n\treturn newfd;\n}", "target": 0}
{"code": "static int hns_xgmac_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn ARRAY_SIZE(g_xgmac_stats_string);\n\treturn 0;\n}", "target": 1}
{"code": "    void WebPImage::writeMetadata()\n    {\n        if (io_->open() != 0) {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        BasicIo::UniquePtr tempIo(new MemIo);\n        assert (tempIo.get() != 0);\n        doWriteMetadata(*tempIo); \n        io_->close();\n        io_->transfer(*tempIo); \n    } ", "target": 0}
{"code": "static int get_task_ioprio(struct task_struct *p)\n{\n\tint ret;\n\tret = security_task_getioprio(p);\n\tif (ret)\n\t\tgoto out;\n\tret = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_NONE, IOPRIO_NORM);\n\ttask_lock(p);\n\tif (p->io_context)\n\t\tret = p->io_context->ioprio;\n\ttask_unlock(p);\nout:\n\treturn ret;\n}", "target": 0}
{"code": "    bool ms_verify_authorizer(Connection *con, int peer_type,\n\t\t\t      int protocol, bufferlist& authorizer_data, bufferlist& authorizer_reply,\n\t\t\t      bool& isvalid, CryptoKey& session_key) override {\n      isvalid = true;\n      return true;\n    }", "target": 1}
{"code": "static int stellaris_enet_post_load(void *opaque, int version_id)\n{\n    stellaris_enet_state *s = opaque;\n    int i;\n    if (s->next_packet >= ARRAY_SIZE(s->rx)) {\n        return -1;\n    }\n    if (s->np > ARRAY_SIZE(s->rx)) {\n        return -1;\n    }\n    for (i = 0; i < ARRAY_SIZE(s->rx); i++) {\n        if (s->rx[i].len > ARRAY_SIZE(s->rx[i].data)) {\n            return -1;\n        }\n    }\n    if (s->rx_fifo_offset > ARRAY_SIZE(s->rx[0].data) - 4) {\n        return -1;\n    }\n    if (s->tx_fifo_len > ARRAY_SIZE(s->tx_fifo)) {\n        return -1;\n    }\n    return 0;\n}", "target": 0}
{"code": "sixel_allocator_realloc(\n    sixel_allocator_t    *allocator,  \n    void                 *p,          \n    size_t               n)           \n{\n    assert(allocator);\n    assert(allocator->fn_realloc);\n    if (n == 0) {\n        sixel_helper_set_additional_message(\n            \"sixel_allocator_malloc: called with n == 0\");\n        return NULL;\n    }\n    if (n > SIXEL_ALLOCATE_BYTES_MAX) {\n        return NULL;\n    }\n    return allocator->fn_realloc(p, n);\n}", "target": 0}
{"code": "int btrfs_run_qgroups(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tint ret = 0;\n\tif (trans->transaction->state != TRANS_STATE_COMMIT_DOING)\n\t\tlockdep_assert_held(&fs_info->qgroup_ioctl_lock);\n\tif (!fs_info->quota_root)\n\t\treturn ret;\n\tspin_lock(&fs_info->qgroup_lock);\n\twhile (!list_empty(&fs_info->dirty_qgroups)) {\n\t\tstruct btrfs_qgroup *qgroup;\n\t\tqgroup = list_first_entry(&fs_info->dirty_qgroups,\n\t\t\t\t\t  struct btrfs_qgroup, dirty);\n\t\tlist_del_init(&qgroup->dirty);\n\t\tspin_unlock(&fs_info->qgroup_lock);\n\t\tret = update_qgroup_info_item(trans, qgroup);\n\t\tif (ret)\n\t\t\tqgroup_mark_inconsistent(fs_info);\n\t\tret = update_qgroup_limit_item(trans, qgroup);\n\t\tif (ret)\n\t\t\tqgroup_mark_inconsistent(fs_info);\n\t\tspin_lock(&fs_info->qgroup_lock);\n\t}\n\tif (test_bit(BTRFS_FS_QUOTA_ENABLED, &fs_info->flags))\n\t\tfs_info->qgroup_flags |= BTRFS_QGROUP_STATUS_FLAG_ON;\n\telse\n\t\tfs_info->qgroup_flags &= ~BTRFS_QGROUP_STATUS_FLAG_ON;\n\tspin_unlock(&fs_info->qgroup_lock);\n\tret = update_qgroup_status_item(trans);\n\tif (ret)\n\t\tqgroup_mark_inconsistent(fs_info);\n\treturn ret;\n}", "target": 0}
{"code": "struct qmp *qmp_get(struct device *dev)\n{\n\tstruct platform_device *pdev;\n\tstruct device_node *np;\n\tstruct qmp *qmp;\n\tif (!dev || !dev->of_node)\n\t\treturn ERR_PTR(-EINVAL);\n\tnp = of_parse_phandle(dev->of_node, \"qcom,qmp\", 0);\n\tif (!np)\n\t\treturn ERR_PTR(-ENODEV);\n\tpdev = of_find_device_by_node(np);\n\tof_node_put(np);\n\tif (!pdev)\n\t\treturn ERR_PTR(-EINVAL);\n\tqmp = platform_get_drvdata(pdev);\n\treturn qmp ? qmp : ERR_PTR(-EPROBE_DEFER);\n}", "target": 1}
{"code": "static ssize_t ucma_process_join(struct ucma_file *file,\n\t\t\t\t struct rdma_ucm_join_mcast *cmd,  int out_len)\n{\n\tstruct rdma_ucm_create_id_resp resp;\n\tstruct ucma_context *ctx;\n\tstruct ucma_multicast *mc;\n\tstruct sockaddr *addr;\n\tint ret;\n\tu8 join_state;\n\tif (out_len < sizeof(resp))\n\t\treturn -ENOSPC;\n\taddr = (struct sockaddr *) &cmd->addr;\n\tif (cmd->addr_size != rdma_addr_size(addr))\n\t\treturn -EINVAL;\n\tif (cmd->join_flags == RDMA_MC_JOIN_FLAG_FULLMEMBER)\n\t\tjoin_state = BIT(FULLMEMBER_JOIN);\n\telse if (cmd->join_flags == RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER)\n\t\tjoin_state = BIT(SENDONLY_FULLMEMBER_JOIN);\n\telse\n\t\treturn -EINVAL;\n\tctx = ucma_get_ctx_dev(file, cmd->id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\tmutex_lock(&file->mut);\n\tmc = ucma_alloc_multicast(ctx);\n\tif (!mc) {\n\t\tret = -ENOMEM;\n\t\tgoto err1;\n\t}\n\tmc->join_state = join_state;\n\tmc->uid = cmd->uid;\n\tmemcpy(&mc->addr, addr, cmd->addr_size);\n\tret = rdma_join_multicast(ctx->cm_id, (struct sockaddr *)&mc->addr,\n\t\t\t\t  join_state, mc);\n\tif (ret)\n\t\tgoto err2;\n\tresp.id = mc->id;\n\tif (copy_to_user(u64_to_user_ptr(cmd->response),\n\t\t\t &resp, sizeof(resp))) {\n\t\tret = -EFAULT;\n\t\tgoto err3;\n\t}\n\tmutex_lock(&mut);\n\tidr_replace(&multicast_idr, mc, mc->id);\n\tmutex_unlock(&mut);\n\tmutex_unlock(&file->mut);\n\tucma_put_ctx(ctx);\n\treturn 0;\nerr3:\n\trdma_leave_multicast(ctx->cm_id, (struct sockaddr *) &mc->addr);\n\tucma_cleanup_mc_events(mc);\nerr2:\n\tmutex_lock(&mut);\n\tidr_remove(&multicast_idr, mc->id);\n\tmutex_unlock(&mut);\n\tlist_del(&mc->list);\n\tkfree(mc);\nerr1:\n\tmutex_unlock(&file->mut);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}", "target": 0}
{"code": "static noinline int free_debug_processing(\n\tstruct kmem_cache *s, struct page *page,\n\tvoid *head, void *tail, int bulk_cnt,\n\tunsigned long addr)\n{\n\tstruct kmem_cache_node *n = get_node(s, page_to_nid(page));\n\tvoid *object = head;\n\tint cnt = 0;\n\tunsigned long uninitialized_var(flags);\n\tint ret = 0;\n\tspin_lock_irqsave(&n->list_lock, flags);\n\tslab_lock(page);\n\tif (s->flags & SLAB_CONSISTENCY_CHECKS) {\n\t\tif (!check_slab(s, page))\n\t\t\tgoto out;\n\t}\nnext_object:\n\tcnt++;\n\tif (s->flags & SLAB_CONSISTENCY_CHECKS) {\n\t\tif (!free_consistency_checks(s, page, object, addr))\n\t\t\tgoto out;\n\t}\n\tif (s->flags & SLAB_STORE_USER)\n\t\tset_track(s, object, TRACK_FREE, addr);\n\ttrace(s, page, object, 0);\n\tinit_object(s, object, SLUB_RED_INACTIVE);\n\tif (object != tail) {\n\t\tobject = get_freepointer(s, object);\n\t\tgoto next_object;\n\t}\n\tret = 1;\nout:\n\tif (cnt != bulk_cnt)\n\t\tslab_err(s, page, \"Bulk freelist count(%d) invalid(%d)\\n\",\n\t\t\t bulk_cnt, cnt);\n\tslab_unlock(page);\n\tspin_unlock_irqrestore(&n->list_lock, flags);\n\tif (!ret)\n\t\tslab_fix(s, \"Object at 0x%p not freed\", object);\n\treturn ret;\n}", "target": 0}
{"code": "struct kobject *get_disk(struct gendisk *disk)\n{\n\tstruct module *owner;\n\tstruct kobject *kobj;\n\tif (!disk->fops)\n\t\treturn NULL;\n\towner = disk->fops->owner;\n\tif (owner && !try_module_get(owner))\n\t\treturn NULL;\n\tkobj = kobject_get(&disk_to_dev(disk)->kobj);\n\tif (kobj == NULL) {\n\t\tmodule_put(owner);\n\t\treturn NULL;\n\t}\n\treturn kobj;\n}", "target": 0}
{"code": "njs_json_push_parse_state(njs_vm_t *vm, njs_json_parse_t *parse,\n    njs_value_t *value)\n{\n    njs_json_state_t  *state;\n    if (njs_slow_path(parse->depth >= NJS_JSON_MAX_DEPTH)) {\n        njs_type_error(vm, \"Nested too deep or a cyclic structure\");\n        return NULL;\n    }\n    state = &parse->states[parse->depth++];\n    state->value = *value;\n    state->index = 0;\n    state->prop = NULL;\n    state->keys = njs_value_own_enumerate(vm, value, NJS_ENUM_KEYS,\n                                          NJS_ENUM_STRING, 0);\n    if (state->keys == NULL) {\n        return NULL;\n    }\n    return state;\n}", "target": 1}
{"code": "int kvm_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr)\n{\n\tswitch (msr->index) {\n\tcase MSR_FS_BASE:\n\tcase MSR_GS_BASE:\n\tcase MSR_KERNEL_GS_BASE:\n\tcase MSR_CSTAR:\n\tcase MSR_LSTAR:\n\t\tif (is_noncanonical_address(msr->data))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tmsr->data = get_canonical(msr->data);\n\t}\n\treturn kvm_x86_ops->set_msr(vcpu, msr);\n}", "target": 0}
{"code": "static void mirror_free_init(MirrorBlockJob *s)\n{\n    int granularity = s->granularity;\n    size_t buf_size = s->buf_size;\n    uint8_t *buf = s->buf;\n    assert(s->buf_free_count == 0);\n    QSIMPLEQ_INIT(&s->buf_free);\n    while (buf_size != 0) {\n        MirrorBuffer *cur = (MirrorBuffer *)buf;\n        QSIMPLEQ_INSERT_TAIL(&s->buf_free, cur, next);\n        s->buf_free_count++;\n        buf_size -= granularity;\n        buf += granularity;\n    }\n}", "target": 0}
{"code": "void thread_func(unsigned int start, unsigned int end, int fd)\n{\n\tstruct qcedev_cipher_op_req req = { 0 };\n\tunsigned int i;\n\tchar *data;\n\tdata = mmap(NULL, 0xFFFFFF * 3, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE|MAP_POPULATE, -1, 0);\n\tif (data == MAP_FAILED) {\n\t\tprintf(\"mmap failed, get a better phone\\n\");\n\t\texit(0);\n\t}\n\tfor (i = 0; i < 0xFFFFFF * 3; i += sizeof(void*))\n\t\t*((unsigned long *)(data + i)) = 0xABADACC355001337;\n\treq.in_place_op = 1;\n\treq.entries = 2;\n\treq.byteoffset = 15;\n\treq.mode = QCEDEV_AES_MODE_CTR;\n\treq.op = QCEDEV_OPER_ENC;\n\treq.ivlen = 1;\n\treq.data_len = 0xFFFFFFFE;\n\treq.vbuf.src[0].len = 4;\n\treq.vbuf.src[1].len = 0xFFFFFFFE - 4;\n\treq.vbuf.src[0].vaddr = (uint8_t*)data;\n\treq.vbuf.src[1].vaddr = (uint8_t*)data;\n\treq.vbuf.dst[0].len = 4;\n\treq.vbuf.dst[1].len = 0xFFFFFFFE - 4;\n\treq.vbuf.dst[0].vaddr = (uint8_t*)data;\n\treq.vbuf.dst[1].vaddr = (uint8_t*)data;\n\tioctl(fd, QCEDEV_IOCTL_ENC_REQ, &req);\n\tprintf(\"exiting\\n\");\n\texit(0);\n}", "target": 0}
{"code": "    virtual void visit(const messages::result_message::prepared::cql& m) override {\n        _response.write_int(0x0004);\n        _response.write_short_bytes(m.get_id());\n        _response.write(m.metadata(), _version);\n        if (_version > 1) {\n            _response.write(*m.result_metadata());\n        }\n    }", "target": 0}
{"code": "static int pcd_detect(void)\n{\n\tchar id[18];\n\tint k, unit;\n\tstruct pcd_unit *cd;\n\tprintk(\"%s: %s version %s, major %d, nice %d\\n\",\n\t       name, name, PCD_VERSION, major, nice);\n\tpar_drv = pi_register_driver(name);\n\tif (!par_drv) {\n\t\tpr_err(\"failed to register %s driver\\n\", name);\n\t\treturn -1;\n\t}\n\tk = 0;\n\tif (pcd_drive_count == 0) { \n\t\tcd = pcd;\n\t\tif (pi_init(cd->pi, 1, -1, -1, -1, -1, -1, pcd_buffer,\n\t\t\t    PI_PCD, verbose, cd->name)) {\n\t\t\tif (!pcd_probe(cd, -1, id) && cd->disk) {\n\t\t\t\tcd->present = 1;\n\t\t\t\tk++;\n\t\t\t} else\n\t\t\t\tpi_release(cd->pi);\n\t\t}\n\t} else {\n\t\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\t\tint *conf = *drives[unit];\n\t\t\tif (!conf[D_PRT])\n\t\t\t\tcontinue;\n\t\t\tif (!pi_init(cd->pi, 0, conf[D_PRT], conf[D_MOD],\n\t\t\t\t     conf[D_UNI], conf[D_PRO], conf[D_DLY],\n\t\t\t\t     pcd_buffer, PI_PCD, verbose, cd->name)) \n\t\t\t\tcontinue;\n\t\t\tif (!pcd_probe(cd, conf[D_SLV], id) && cd->disk) {\n\t\t\t\tcd->present = 1;\n\t\t\t\tk++;\n\t\t\t} else\n\t\t\t\tpi_release(cd->pi);\n\t\t}\n\t}\n\tif (k)\n\t\treturn 0;\n\tprintk(\"%s: No CD-ROM drive found\\n\", name);\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tif (!cd->disk)\n\t\t\tcontinue;\n\t\tblk_cleanup_queue(cd->disk->queue);\n\t\tcd->disk->queue = NULL;\n\t\tblk_mq_free_tag_set(&cd->tag_set);\n\t\tput_disk(cd->disk);\n\t}\n\tpi_unregister_driver(par_drv);\n\treturn -1;\n}", "target": 0}
{"code": "static void set_own_dir(const char *argv0) {\n\tsize_t l = strlen(argv0);\n\twhile(l && argv0[l - 1] != '/')\n\t\tl--;\n\tif(l == 0)\n#ifdef SUPER_SECURE\n\t\tmemcpy(own_dir, \"/dev/null/\", 2);\n#else\n\t\tmemcpy(own_dir, \".\", 2);\n#endif\n\telse {\n\t\tmemcpy(own_dir, argv0, l - 1);\n\t\town_dir[l] = 0;\n\t}\n}", "target": 0}
{"code": "static inline u32 dma_high(dma_addr_t addr)\n{\n\treturn upper_32_bits(addr);\n}", "target": 1}
{"code": "void dwc3_gadget_del_and_unmap_request(struct dwc3_ep *dep,\n\t\tstruct dwc3_request *req, int status)\n{\n\tstruct dwc3\t\t\t*dwc = dep->dwc;\n\treq->started = false;\n\tlist_del(&req->list);\n\treq->remaining = 0;\n\tif (req->request.status == -EINPROGRESS)\n\t\treq->request.status = status;\n\tif (req->trb)\n\t\tusb_gadget_unmap_request_by_dev(dwc->sysdev,\n\t\t\t\t&req->request, req->direction);\n\treq->trb = NULL;\n\ttrace_dwc3_gadget_giveback(req);\n\tif (dep->number > 1)\n\t\tpm_runtime_put(dwc->dev);\n}", "target": 0}
{"code": "static inline void skb_reserve(struct sk_buff *skb, int len)\n{\n\tskb->data += len;\n\tskb->tail += len;\n}", "target": 0}
{"code": "static inline int check_sticky(struct inode *dir, struct inode *inode)\n{\n\tkuid_t fsuid = current_fsuid();\n\tif (!(dir->i_mode & S_ISVTX))\n\t\treturn 0;\n\tif (uid_eq(inode->i_uid, fsuid))\n\t\treturn 0;\n\tif (uid_eq(dir->i_uid, fsuid))\n\t\treturn 0;\n\treturn !inode_capable(inode, CAP_FOWNER);\n}", "target": 1}
{"code": "static int vhost_vdpa_open(struct inode *inode, struct file *filep)\n{\n\tstruct vhost_vdpa *v;\n\tstruct vhost_dev *dev;\n\tstruct vhost_virtqueue **vqs;\n\tint nvqs, i, r, opened;\n\tv = container_of(inode->i_cdev, struct vhost_vdpa, cdev);\n\topened = atomic_cmpxchg(&v->opened, 0, 1);\n\tif (opened)\n\t\treturn -EBUSY;\n\tnvqs = v->nvqs;\n\tr = vhost_vdpa_reset(v);\n\tif (r)\n\t\tgoto err;\n\tvqs = kmalloc_array(nvqs, sizeof(*vqs), GFP_KERNEL);\n\tif (!vqs) {\n\t\tr = -ENOMEM;\n\t\tgoto err;\n\t}\n\tdev = &v->vdev;\n\tfor (i = 0; i < nvqs; i++) {\n\t\tvqs[i] = &v->vqs[i];\n\t\tvqs[i]->handle_kick = handle_vq_kick;\n\t}\n\tvhost_dev_init(dev, vqs, nvqs, 0, 0, 0, false,\n\t\t       vhost_vdpa_process_iotlb_msg);\n\tdev->iotlb = vhost_iotlb_alloc(0, 0);\n\tif (!dev->iotlb) {\n\t\tr = -ENOMEM;\n\t\tgoto err_init_iotlb;\n\t}\n\tr = vhost_vdpa_alloc_domain(v);\n\tif (r)\n\t\tgoto err_init_iotlb;\n\tvhost_vdpa_set_iova_range(v);\n\tfilep->private_data = v;\n\treturn 0;\nerr_init_iotlb:\n\tvhost_dev_cleanup(&v->vdev);\n\tkfree(vqs);\nerr:\n\tatomic_dec(&v->opened);\n\treturn r;\n}", "target": 0}
{"code": "static int tcp_parse_options(struct pico_frame *f)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)f->sock;\n    uint8_t *opt = f->transport_hdr + PICO_SIZE_TCPHDR;\n    uint32_t i = 0;\n    f->timestamp = 0;\n    if (f->buffer + f->buffer_len > f->transport_hdr + f->transport_len)\n        return -1;\n    while (i < (f->transport_len - PICO_SIZE_TCPHDR)) {\n        uint8_t type =  opt[i++];\n        uint8_t len;\n        if(i < (f->transport_len - PICO_SIZE_TCPHDR) && (type > 1))\n            len =  opt[i++];\n        else\n            len = 1;\n        if (f->payload && ((opt + i) > f->payload))\n            break;\n        if (len == 0) {\n            return -1;\n        }\n        tcp_dbg_options(\"Received option '%d', len = %d \\n\", type, len);\n        switch (type) {\n        case PICO_TCP_OPTION_NOOP:\n        case PICO_TCP_OPTION_END:\n            break;\n        case PICO_TCP_OPTION_WS:\n            tcp_parse_option_ws(t, len, opt, &i);\n            break;\n        case PICO_TCP_OPTION_SACK_OK:\n            tcp_parse_option_sack_ok(t, f, len, &i);\n            break;\n        case PICO_TCP_OPTION_MSS:\n            tcp_parse_option_mss(t, len, opt, &i);\n            break;\n        case PICO_TCP_OPTION_TIMESTAMP:\n            tcp_parse_option_timestamp(t, f, len, opt, &i);\n            break;\n        case PICO_TCP_OPTION_SACK:\n            tcp_rcv_sack(t, opt + i, len - 2);\n            i = i + len - 2;\n            break;\n        default:\n            tcp_dbg_options(\"TCP: received unsupported option %u\\n\", type);\n            i = i + len - 2;\n        }\n    }\n    return 0;\n}", "target": 0}
{"code": "filesystem_create_completed_cb (DBusGMethodInvocation *context,\n                                Device *device,\n                                gboolean job_was_cancelled,\n                                int status,\n                                const char *stderr,\n                                const char *stdout,\n                                gpointer user_data)\n{\n  MkfsData *data = user_data;\n  device_generate_kernel_change_event (device);\n  if (WEXITSTATUS (status) == 0 && !job_was_cancelled)\n    {\n      if (data->hook_func != NULL)\n        data->hook_func (context, device, TRUE, data->hook_user_data);\n      else\n        dbus_g_method_return (context);\n    }\n  else\n    {\n      if (job_was_cancelled)\n        {\n          throw_error (context, ERROR_CANCELLED, \"Job was cancelled\");\n        }\n      else if (WEXITSTATUS (status) == 3)\n        {\n          throw_error (context,\n                       ERROR_FILESYSTEM_TOOLS_MISSING,\n                       \"Error creating file system: Cannot run mkfs: %s\",\n                       stderr);\n        }\n      else\n        {\n          throw_error (context,\n                       ERROR_FAILED,\n                       \"Error creating file system: helper exited with exit code %d: %s\\n%s\",\n                       WEXITSTATUS (status),\n                       stderr,\n                       stdout);\n        }\n      if (data->hook_func != NULL)\n        data->hook_func (context, device, FALSE, data->hook_user_data);\n    }\n}", "target": 0}
{"code": "void rose_stop_heartbeat(struct sock *sk)\n{\n\tdel_timer(&sk->sk_timer);\n}", "target": 1}
{"code": "struct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl)\n{\n\tstruct scm_fp_list *new_fpl;\n\tint i;\n\tif (!fpl)\n\t\treturn NULL;\n\tnew_fpl = kmemdup(fpl, offsetof(struct scm_fp_list, fp[fpl->count]),\n\t\t\t  GFP_KERNEL);\n\tif (new_fpl) {\n\t\tfor (i = 0; i < fpl->count; i++)\n\t\t\tget_file(fpl->fp[i]);\n\t\tnew_fpl->max = new_fpl->count;\n\t\tnew_fpl->user = get_uid(fpl->user);\n\t}\n\treturn new_fpl;\n}", "target": 0}
{"code": "int infra_wait_limit_allowed(struct infra_cache* infra, struct comm_reply* rep,\n\tint cookie_valid, struct config_file* cfg)\n{\n\tstruct lruhash_entry* entry;\n\tif(cfg->wait_limit == 0)\n\t\treturn 1;\n\tentry = infra_find_ip_ratedata(infra, &rep->client_addr,\n\t\trep->client_addrlen, 0);\n\tif(entry) {\n\t\trbtree_type* tree;\n\t\tstruct wait_limit_netblock_info* w;\n\t\tstruct rate_data* d = (struct rate_data*)entry->data;\n\t\tint mesh_wait = d->mesh_wait;\n\t\tlock_rw_unlock(&entry->lock);\n\t\tif(cookie_valid)\n\t\t\ttree = &infra->wait_limits_cookie_netblock;\n\t\telse\ttree = &infra->wait_limits_netblock;\n\t\tw = (struct wait_limit_netblock_info*)addr_tree_lookup(tree,\n\t\t\t&rep->client_addr, rep->client_addrlen);\n\t\tif(w) {\n\t\t\tif(w->limit != -1 && mesh_wait > w->limit)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif(mesh_wait > (cookie_valid?cfg->wait_limit_cookie:\n\t\t\t\tcfg->wait_limit))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "static void vgacon_flush_scrollback(struct vc_data *c)\n{\n\tsize_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;\n\tvgacon_scrollback_reset(c->vc_num, size);\n}", "target": 1}
{"code": "void swallow_arg(int *argcp, char *argv[], char *which)\n{\n\tint i;\n\tfor (i = 1; argv[i]; i++) {\n\t\tif (strcmp(argv[i], which) != 0)\n\t\t\tcontinue;\n\t\tfor (; argv[i]; i++) {\n\t\t\targv[i] = argv[i+1];\n\t\t}\n\t\t(*argcp)--;\n\t\treturn;\n\t}\n}", "target": 0}
{"code": "static void __attribute__((destructor)) fio_lib_destroy(void) {\n  uint8_t add_eol = fio_is_master();\n  fio_data->active = 0;\n  fio_on_fork();\n  fio_defer_perform();\n  fio_state_callback_force(FIO_CALL_AT_EXIT);\n  fio_state_callback_clear_all();\n  fio_defer_perform();\n  fio_poll_close();\n  fio_timer_clear_all();\n  fio_free(fio_data);\n  fio_mem_destroy();\n  FIO_LOG_DEBUG(\"(%d) facil.io resources released, exit complete.\",\n                (int)getpid());\n  if (add_eol)\n    fprintf(stderr, \"\\n\"); \n}", "target": 1}
{"code": "static int nfc_genl_deactivate_target(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tu32 device_idx, target_idx;\n\tint rc;\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn -EINVAL;\n\tdevice_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tdev = nfc_get_device(device_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\ttarget_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);\n\trc = nfc_deactivate_target(dev, target_idx, NFC_TARGET_MODE_SLEEP);\n\tnfc_put_device(dev);\n\treturn rc;\n}", "target": 1}
{"code": "static int ccid3_hc_tx_getsockopt(struct sock *sk, const int optname, int len,\n\t\t\t\t  u32 __user *optval, int __user *optlen)\n{\n\tconst struct ccid3_hc_tx_sock *hc = ccid3_hc_tx_sk(sk);\n\tstruct tfrc_tx_info tfrc;\n\tconst void *val;\n\tswitch (optname) {\n\tcase DCCP_SOCKOPT_CCID_TX_INFO:\n\t\tif (len < sizeof(tfrc))\n\t\t\treturn -EINVAL;\n\t\tmemset(&tfrc, 0, sizeof(tfrc));\n\t\ttfrc.tfrctx_x\t   = hc->tx_x;\n\t\ttfrc.tfrctx_x_recv = hc->tx_x_recv;\n\t\ttfrc.tfrctx_x_calc = hc->tx_x_calc;\n\t\ttfrc.tfrctx_rtt\t   = hc->tx_rtt;\n\t\ttfrc.tfrctx_p\t   = hc->tx_p;\n\t\ttfrc.tfrctx_rto\t   = hc->tx_t_rto;\n\t\ttfrc.tfrctx_ipi\t   = hc->tx_t_ipi;\n\t\tlen = sizeof(tfrc);\n\t\tval = &tfrc;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\tif (put_user(len, optlen) || copy_to_user(optval, val, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 0}
{"code": "static inline int pmd_large(pmd_t pte)\n{\n\treturn (pmd_flags(pte) & (_PAGE_PSE | _PAGE_PRESENT)) ==\n\t\t(_PAGE_PSE | _PAGE_PRESENT);\n}", "target": 1}
{"code": "int ext4_resize_begin(struct super_block *sb)\n{\n\tint ret = 0;\n\tif (!capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\tif (EXT4_SB(sb)->s_mount_state & EXT4_ERROR_FS) {\n\t\text4_warning(sb, \"There are errors in the filesystem, \"\n\t\t\t     \"so online resizing is not allowed\\n\");\n\t\treturn -EPERM;\n\t}\n\tif (test_and_set_bit_lock(EXT4_RESIZING, &EXT4_SB(sb)->s_resize_flags))\n\t\tret = -EBUSY;\n\treturn ret;\n}", "target": 0}
{"code": "deltas_head_cleanup(struct deltas_head *list)\n{\n\tsize_t i;\n\tfor (i = 0; i < list->capacity; i++)\n\t\tdelta_head_destroy(list->array[i]);\n\tif (list->array)\n\t\tfree(list->array);\n}", "target": 1}
{"code": "flatpak_proxy_client_init (FlatpakProxyClient *client)\n{\n  init_side (client, &client->client_side);\n  init_side (client, &client->bus_side);\n  client->auth_end_offset = AUTH_END_INIT_OFFSET;\n  client->rewrite_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_object_unref);\n  client->get_owner_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_free);\n  client->unique_id_policy = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n}", "target": 1}
{"code": "static int do_new_mount(struct path *path, const char *fstype, int flags,\n\t\t\tint mnt_flags, const char *name, void *data)\n{\n\tstruct file_system_type *type;\n\tstruct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;\n\tstruct vfsmount *mnt;\n\tint err;\n\tif (!fstype)\n\t\treturn -EINVAL;\n\ttype = get_fs_type(fstype);\n\tif (!type)\n\t\treturn -ENODEV;\n\tif (user_ns != &init_user_ns) {\n\t\tif (!(type->fs_flags & FS_USERNS_MOUNT)) {\n\t\t\tput_filesystem(type);\n\t\t\treturn -EPERM;\n\t\t}\n\t\tif (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) {\n\t\t\tflags |= MS_NODEV;\n\t\t\tmnt_flags |= MNT_NODEV;\n\t\t}\n\t}\n\tmnt = vfs_kern_mount(type, flags, name, data);\n\tif (!IS_ERR(mnt) && (type->fs_flags & FS_HAS_SUBTYPE) &&\n\t    !mnt->mnt_sb->s_subtype)\n\t\tmnt = fs_set_subtype(mnt, fstype);\n\tput_filesystem(type);\n\tif (IS_ERR(mnt))\n\t\treturn PTR_ERR(mnt);\n\terr = do_add_mount(real_mount(mnt), path, mnt_flags);\n\tif (err)\n\t\tmntput(mnt);\n\treturn err;\n}", "target": 1}
{"code": "void tcp_rcv_space_adjust(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint time;\n\tint copied;\n\ttime = tcp_time_stamp - tp->rcvq_space.time;\n\tif (time < (tp->rcv_rtt_est.rtt >> 3) || tp->rcv_rtt_est.rtt == 0)\n\t\treturn;\n\tcopied = tp->copied_seq - tp->rcvq_space.seq;\n\tif (copied <= tp->rcvq_space.space)\n\t\tgoto new_measure;\n\tif (sysctl_tcp_moderate_rcvbuf &&\n\t    !(sk->sk_userlocks & SOCK_RCVBUF_LOCK)) {\n\t\tint rcvwin, rcvmem, rcvbuf;\n\t\trcvwin = (copied << 1) + 16 * tp->advmss;\n\t\tif (copied >=\n\t\t    tp->rcvq_space.space + (tp->rcvq_space.space >> 2)) {\n\t\t\tif (copied >=\n\t\t\t    tp->rcvq_space.space + (tp->rcvq_space.space >> 1))\n\t\t\t\trcvwin <<= 1;\n\t\t\telse\n\t\t\t\trcvwin += (rcvwin >> 1);\n\t\t}\n\t\trcvmem = SKB_TRUESIZE(tp->advmss + MAX_TCP_HEADER);\n\t\twhile (tcp_win_from_space(rcvmem) < tp->advmss)\n\t\t\trcvmem += 128;\n\t\trcvbuf = min(rcvwin / tp->advmss * rcvmem, sysctl_tcp_rmem[2]);\n\t\tif (rcvbuf > sk->sk_rcvbuf) {\n\t\t\tsk->sk_rcvbuf = rcvbuf;\n\t\t\ttp->window_clamp = rcvwin;\n\t\t}\n\t}\n\ttp->rcvq_space.space = copied;\nnew_measure:\n\ttp->rcvq_space.seq = tp->copied_seq;\n\ttp->rcvq_space.time = tcp_time_stamp;\n}", "target": 0}
{"code": "DLLEXPORT int DLLCALL tjDecodeYUV(tjhandle handle, const unsigned char *srcBuf,\n\tint pad, int subsamp, unsigned char *dstBuf, int width, int pitch,\n\tint height, int pixelFormat, int flags)\n{\n\tconst unsigned char *srcPlanes[3];\n\tint pw0, ph0, strides[3], retval=-1;\n\ttjinstance *this=(tjinstance *)handle;\n\tif(!this) _throwg(\"tjDecodeYUV(): Invalid handle\");\n\tthis->isInstanceError=FALSE;\n\tif(srcBuf==NULL || pad<0 || !isPow2(pad) || subsamp<0 || subsamp>=NUMSUBOPT\n\t\t|| width<=0 || height<=0)\n\t\t_throw(\"tjDecodeYUV(): Invalid argument\");\n\tpw0=tjPlaneWidth(0, width, subsamp);\n\tph0=tjPlaneHeight(0, height, subsamp);\n\tsrcPlanes[0]=srcBuf;\n\tstrides[0]=PAD(pw0, pad);\n\tif(subsamp==TJSAMP_GRAY)\n\t{\n\t\tstrides[1]=strides[2]=0;\n\t\tsrcPlanes[1]=srcPlanes[2]=NULL;\n\t}\n\telse\n\t{\n\t\tint pw1=tjPlaneWidth(1, width, subsamp);\n\t\tint ph1=tjPlaneHeight(1, height, subsamp);\n\t\tstrides[1]=strides[2]=PAD(pw1, pad);\n\t\tsrcPlanes[1]=srcPlanes[0]+strides[0]*ph0;\n\t\tsrcPlanes[2]=srcPlanes[1]+strides[1]*ph1;\n\t}\n\treturn tjDecodeYUVPlanes(handle, srcPlanes, strides, subsamp, dstBuf, width,\n\t\tpitch, height, pixelFormat, flags);\n\tbailout:\n\treturn retval;\n}", "target": 0}
{"code": "jas_stream_t *jas_stream_memopen(char *buf, int bufsize)\n{\n\tchar *new_buf;\n\tsize_t new_bufsize;\n\tJAS_DBGLOG(100, (\"jas_stream_memopen(%p, %d)\\n\", buf, bufsize));\n\tif (bufsize < 0) {\n\t\tjas_deprecated(\"negative buffer size for jas_stream_memopen\");\n\t}\n\tif (buf && bufsize <= 0) {\n\t\tjas_eprintf(\"Invalid use of jas_stream_memopen detected.\\n\");\n\t\tjas_deprecated(\"A user-provided buffer for \"\n\t\t  \"jas_stream_memopen cannot be growable.\\n\");\n\t}\n\tif (bufsize <= 0) {\n\t\tnew_bufsize = 0;\n\t\tnew_buf = 0;\n\t} else {\n\t\tnew_bufsize = bufsize;\n\t\tnew_buf = buf;\n\t}\n\treturn jas_stream_memopen2(new_buf, new_bufsize);\n}", "target": 0}
{"code": "static void bump_cpu_timer(struct k_itimer *timer, u64 now)\n{\n\tint i;\n\tu64 delta, incr;\n\tif (timer->it.cpu.incr == 0)\n\t\treturn;\n\tif (now < timer->it.cpu.expires)\n\t\treturn;\n\tincr = timer->it.cpu.incr;\n\tdelta = now + incr - timer->it.cpu.expires;\n\tfor (i = 0; incr < delta - incr; i++)\n\t\tincr = incr << 1;\n\tfor (; i >= 0; incr >>= 1, i--) {\n\t\tif (delta < incr)\n\t\t\tcontinue;\n\t\ttimer->it.cpu.expires += incr;\n\t\ttimer->it_overrun += 1 << i;\n\t\tdelta -= incr;\n\t}\n}", "target": 1}
{"code": "alloc_compspace(isc_httpd_t *httpd, unsigned int size) {\n\tchar *newspace = NULL;\n\tisc_region_t r;\n\tisc_buffer_region(&httpd->compbuffer, &r);\n\tif (size < r.length) {\n\t\treturn;\n\t}\n\tnewspace = isc_mem_get(httpd->mgr->mctx, size);\n\tisc_buffer_reinit(&httpd->compbuffer, newspace, size);\n\tif (r.base != NULL) {\n\t\tisc_mem_put(httpd->mgr->mctx, r.base, r.length);\n\t}\n}", "target": 0}
{"code": "void isdn_ppp_receive(isdn_net_dev *net_dev, isdn_net_local *lp, struct sk_buff *skb)\n{\n\tstruct ippp_struct *is;\n\tint slot;\n\tint proto;\n\tBUG_ON(net_dev->local->master); \n\tslot = lp->ppp_slot;\n\tif (slot < 0 || slot >= ISDN_MAX_CHANNELS) {\n\t\tprintk(KERN_ERR \"isdn_ppp_receive: lp->ppp_slot(%d)\\n\",\n\t\t       lp->ppp_slot);\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\tis = ippp_table[slot];\n\tif (is->debug & 0x4) {\n\t\tprintk(KERN_DEBUG \"ippp_receive: is:%08lx lp:%08lx slot:%d unit:%d len:%d\\n\",\n\t\t       (long)is, (long)lp, lp->ppp_slot, is->unit, (int)skb->len);\n\t\tisdn_ppp_frame_log(\"receive\", skb->data, skb->len, 32, is->unit, lp->ppp_slot);\n\t}\n\tif (isdn_ppp_skip_ac(is, skb) < 0) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\tproto = isdn_ppp_strip_proto(skb);\n\tif (proto < 0) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n#ifdef CONFIG_ISDN_MPP\n\tif (is->compflags & SC_LINK_DECOMP_ON) {\n\t\tskb = isdn_ppp_decompress(skb, is, NULL, &proto);\n\t\tif (!skb) \n\t\t\treturn;\n\t}\n\tif (!(is->mpppcfg & SC_REJ_MP_PROT)) { \n\t\tif (proto == PPP_MP) {\n\t\t\tisdn_ppp_mp_receive(net_dev, lp, skb);\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n\tisdn_ppp_push_higher(net_dev, lp, skb, proto);\n}", "target": 0}
{"code": "psf_allocate (void)\n{\tSF_PRIVATE * psf ;\n\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n\t\treturn\tNULL ;\n\tif ((psf->header.ptr = calloc (1, INITAL_HEADER_SIZE)) == NULL)\n\t{\tfree (psf) ;\n\t\treturn\tNULL ;\n\t\t} ;\n\tpsf->header.len = INITAL_HEADER_SIZE ;\n\treturn psf ;\n} ", "target": 0}
{"code": "SecureSocket::initContext(bool server)\n{\n    SSL_library_init();\n    const SSL_METHOD* method;\n    OpenSSL_add_all_algorithms();\n    SSL_load_error_strings();\n    if (CLOG->getFilter() >= kINFO) {\n        showSecureLibInfo();\n    }\n    if (server) {\n        method = SSLv23_server_method();\n    }\n    else {\n        method = SSLv23_client_method();\n    }\n    SSL_METHOD* m = const_cast<SSL_METHOD*>(method);\n    m_ssl->m_context = SSL_CTX_new(m);\n    SSL_CTX_set_options(m_ssl->m_context, SSL_OP_NO_SSLv3);\n    if (m_ssl->m_context == NULL) {\n        showError(\"\");\n    }\n    if (security_level_ == ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED) {\n        SSL_CTX_set_verify(m_ssl->m_context, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,\n                           nullptr);\n        SSL_CTX_set_cert_verify_callback(m_ssl->m_context, cert_verify_ignore_callback, nullptr);\n    }\n}", "target": 0}
{"code": "find_jws(struct tang_keys_info* tki, const char* thp)\n{\n    if (!tki) {\n        return NULL;\n    }\n    if (thp == NULL) {\n        json_auto_t* jws = jwk_sign(tki->m_payload, tki->m_sign);\n        if (!jws) {\n            return NULL;\n        }\n        return json_incref(jws);\n    }\n    return find_by_thp(tki, thp);\n}", "target": 1}
{"code": "create_new_keys(const char* jwkdir)\n{\n    const char* alg[] = {\"ES512\", \"ECMR\", NULL};\n    char path[PATH_MAX];\n    umask(0337);\n    for (int i = 0; alg[i] != NULL; i++) {\n        json_auto_t* jwk = jwk_generate(alg[i]);\n        if (!jwk) {\n            return 0;\n        }\n        __attribute__ ((__cleanup__(cleanup_str))) char* thp = jwk_thumbprint(jwk, DEFAULT_THP_HASH);\n        if (!thp) {\n            return 0;\n        }\n        if (snprintf(path, PATH_MAX, \"%s/%s.jwk\", jwkdir, thp) < 0) {\n            fprintf(stderr, \"Unable to prepare variable with file full path (%s)\\n\", thp);\n            return 0;\n        }\n        path[sizeof(path) - 1] = '\\0';\n        if (json_dump_file(jwk, path, 0) == -1) {\n            fprintf(stderr, \"Error saving JWK to file (%s)\\n\", path);\n            return 0;\n        }\n        if (chmod(path, S_IRUSR | S_IRGRP) == -1) {\n            fprintf(stderr, \"Unable to set permissions for JWK file (%s)\\n\", path);\n            return 0;\n        }\n    }\n    return 1;\n}", "target": 0}
{"code": "vq_endchains(struct virtio_vq_info *vq, int used_all_avail)\n{\n\tstruct virtio_base *base;\n\tuint16_t event_idx, new_idx, old_idx;\n\tint intr;\n\tif (!vq || !vq->used)\n\t\treturn;\n\tatomic_thread_fence();\n\tbase = vq->base;\n\told_idx = vq->save_used;\n\tvq->save_used = new_idx = vq->used->idx;\n\tif (used_all_avail &&\n\t    (base->negotiated_caps & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)))\n\t\tintr = 1;\n\telse if (base->negotiated_caps & (1 << VIRTIO_RING_F_EVENT_IDX)) {\n\t\tevent_idx = VQ_USED_EVENT_IDX(vq);\n\t\tintr = (uint16_t)(new_idx - event_idx - 1) <\n\t\t\t(uint16_t)(new_idx - old_idx);\n\t} else {\n\t\tintr = new_idx != old_idx &&\n\t\t    !(vq->avail->flags & VRING_AVAIL_F_NO_INTERRUPT);\n\t}\n\tif (intr)\n\t\tvq_interrupt(base, vq);\n}", "target": 0}
{"code": "archive_read_format_rar_read_data(struct archive_read *a, const void **buff,\n                                  size_t *size, int64_t *offset)\n{\n  struct rar *rar = (struct rar *)(a->format->data);\n  int ret;\n  if (rar->has_encrypted_entries == ARCHIVE_READ_FORMAT_ENCRYPTION_DONT_KNOW) {\n\t  rar->has_encrypted_entries = 0;\n  }\n  if (rar->bytes_unconsumed > 0) {\n      __archive_read_consume(a, rar->bytes_unconsumed);\n      rar->bytes_unconsumed = 0;\n  }\n  *buff = NULL;\n  if (rar->entry_eof || rar->offset_seek >= rar->unp_size) {\n    *size = 0;\n    *offset = rar->offset;\n    if (*offset < rar->unp_size)\n      *offset = rar->unp_size;\n    return (ARCHIVE_EOF);\n  }\n  switch (rar->compression_method)\n  {\n  case COMPRESS_METHOD_STORE:\n    ret = read_data_stored(a, buff, size, offset);\n    break;\n  case COMPRESS_METHOD_FASTEST:\n  case COMPRESS_METHOD_FAST:\n  case COMPRESS_METHOD_NORMAL:\n  case COMPRESS_METHOD_GOOD:\n  case COMPRESS_METHOD_BEST:\n    ret = read_data_compressed(a, buff, size, offset);\n    if (ret != ARCHIVE_OK && ret != ARCHIVE_WARN)\n      __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);\n    break;\n  default:\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Unsupported compression method for RAR file.\");\n    ret = ARCHIVE_FATAL;\n    break;\n  }\n  return (ret);\n}", "target": 1}
{"code": "struct blk_mq_tags *blk_mq_init_tags(unsigned int total_tags,\n\t\t\t\t     unsigned int reserved_tags,\n\t\t\t\t     int node, int alloc_policy)\n{\n\tstruct blk_mq_tags *tags;\n\tif (total_tags > BLK_MQ_TAG_MAX) {\n\t\tpr_err(\"blk-mq: tag depth too large\\n\");\n\t\treturn NULL;\n\t}\n\ttags = kzalloc_node(sizeof(*tags), GFP_KERNEL, node);\n\tif (!tags)\n\t\treturn NULL;\n\tif (!zalloc_cpumask_var(&tags->cpumask, GFP_KERNEL)) {\n\t\tkfree(tags);\n\t\treturn NULL;\n\t}\n\ttags->nr_tags = total_tags;\n\ttags->nr_reserved_tags = reserved_tags;\n\treturn blk_mq_init_bitmap_tags(tags, node, alloc_policy);\n}", "target": 0}
{"code": "int git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\t\treturn (int)len;\n\t}\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\tif (len != 0 && len < PKT_LEN_SIZE)\n\t\treturn GIT_ERROR;\n\tline += PKT_LEN_SIZE;\n\tif (len == PKT_LEN_SIZE) {\n\t\tgiterr_set_str(GITERR_NET, \"Invalid empty packet\");\n\t\treturn GIT_ERROR;\n\t}\n\tif (len == 0) { \n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\tlen -= PKT_LEN_SIZE; \n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\t*out = line + len;\n\treturn ret;\n}", "target": 0}
{"code": "static bool allowed_problem_dir(const char *dir_name)\n{\n#if 0\n    unsigned len = strlen(g_settings_dump_location);\n    if (strncmp(dir_name, g_settings_dump_location, len) != 0\n     || (dir_name[len] != '/' && dir_name[len] != '\\0')\n     || strstr(dir_name + len, \"/.\")\n    ) {\n        return false;\n    }\n#endif\n    return true;\n}", "target": 1}
{"code": "void jbd2_journal_wait_updates(journal_t *journal)\n{\n\ttransaction_t *commit_transaction = journal->j_running_transaction;\n\tif (!commit_transaction)\n\t\treturn;\n\tspin_lock(&commit_transaction->t_handle_lock);\n\twhile (atomic_read(&commit_transaction->t_updates)) {\n\t\tDEFINE_WAIT(wait);\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(&commit_transaction->t_updates)) {\n\t\t\tspin_unlock(&commit_transaction->t_handle_lock);\n\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\tschedule();\n\t\t\twrite_lock(&journal->j_state_lock);\n\t\t\tspin_lock(&commit_transaction->t_handle_lock);\n\t\t}\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t}\n\tspin_unlock(&commit_transaction->t_handle_lock);\n}", "target": 1}
{"code": "void *Sys_LoadDll( const char *name, qboolean useSystemLib )\n{\n\tvoid *dllhandle = NULL;\n\tif ( COM_CompareExtension( name, \".pk3\" ) )\n\t{\n\t\tCom_Printf( S_COLOR_YELLOW \"WARNING: Rejecting DLL named \\\"%s\\\"\", name );\n\t\treturn NULL;\n\t}\n\tif ( useSystemLib )\n\t{\n\t\tCom_Printf( \"Trying to load \\\"%s\\\"...\\n\", name );\n\t\tdllhandle = Sys_LoadLibrary( name );\n\t\tif ( dllhandle )\n\t\t\treturn dllhandle;\n\t\tCom_Printf( \"%s(%s) failed: \\\"%s\\\"\\n\", __FUNCTION__, name, Sys_LibraryError() );\n\t}\n\tconst char *binarypath = Sys_BinaryPath();\n\tconst char *basepath = Cvar_VariableString( \"fs_basepath\" );\n\tif ( !*binarypath )\n\t\tbinarypath = \".\";\n\tconst char *searchPaths[] = {\n\t\tbinarypath,\n\t\tbasepath,\n\t};\n\tconst size_t numPaths = ARRAY_LEN( searchPaths );\n\tfor ( size_t i = 0; i < numPaths; i++ )\n\t{\n\t\tconst char *libDir = searchPaths[i];\n\t\tif ( !libDir[0] )\n\t\t\tcontinue;\n\t\tCom_Printf( \"Trying to load \\\"%s\\\" from \\\"%s\\\"...\\n\", name, libDir );\n\t\tchar *fn = va( \"%s%c%s\", libDir, PATH_SEP, name );\n\t\tdllhandle = Sys_LoadLibrary( fn );\n\t\tif ( dllhandle )\n\t\t\treturn dllhandle;\n\t\tCom_Printf( \"%s(%s) failed: \\\"%s\\\"\\n\", __FUNCTION__, fn, Sys_LibraryError() );\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "  explicit QuantizeAndDequantizeV2Op(OpKernelConstruction* ctx)\n      : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"signed_input\", &signed_input_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"axis\", &axis_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"num_bits\", &num_bits_));\n    OP_REQUIRES(ctx, num_bits_ > 0 && num_bits_ < (signed_input_ ? 62 : 63),\n                errors::InvalidArgument(\"num_bits is out of range: \", num_bits_,\n                                        \" with signed_input_ \", signed_input_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"range_given\", &range_given_));\n    string round_mode_string;\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"round_mode\", &round_mode_string));\n    OP_REQUIRES(\n        ctx,\n        (round_mode_string == \"HALF_UP\" || round_mode_string == \"HALF_TO_EVEN\"),\n        errors::InvalidArgument(\"Round mode string must be \"\n                                \"'HALF_UP' or \"\n                                \"'HALF_TO_EVEN', is '\" +\n                                round_mode_string + \"'\"));\n    if (round_mode_string == \"HALF_UP\") {\n      round_mode_ = ROUND_HALF_UP;\n    } else if (round_mode_string == \"HALF_TO_EVEN\") {\n      round_mode_ = ROUND_HALF_TO_EVEN;\n    }\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"narrow_range\", &narrow_range_));\n  }", "target": 1}
{"code": "cpStripToTile(uint8* out, uint8* in,\n    uint32 rows, uint32 cols, int outskew, int inskew)\n{\n\twhile (rows-- > 0) {\n\t\tuint32 j = cols;\n\t\twhile (j-- > 0)\n\t\t\t*out++ = *in++;\n\t\tout += outskew;\n\t\tin += inskew;\n\t}\n}", "target": 1}
{"code": "int am_check_url(request_rec *r, const char *url)\n{\n    const char *i;\n    if (url == NULL) {\n        return HTTP_BAD_REQUEST;\n    }\n    for (i = url; *i; i++) {\n        if (*i >= 0 && *i < ' ') {\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,\n                          \"Control character detected in URL.\");\n            return HTTP_BAD_REQUEST;\n        }\n        if (*i == '\\\\') {\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,\n                          \"Backslash character detected in URL.\");\n            return HTTP_BAD_REQUEST;\n        }\n    }\n    if (strstr(url, \"\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,\n                          \"URL starts with '\n        return HTTP_BAD_REQUEST;\n    }\n    return OK;\n}", "target": 0}
{"code": "xfs_iunlink_free_item(\n\tvoid\t\t\t*ptr,\n\tvoid\t\t\t*arg)\n{\n\tstruct xfs_iunlink\t*iu = ptr;\n\tbool\t\t\t*freed_anything = arg;\n\t*freed_anything = true;\n\tkmem_free(iu);\n}", "target": 0}
{"code": "nf_nat_redirect_ipv4(struct sk_buff *skb,\n\t\t     const struct nf_nat_ipv4_multi_range_compat *mr,\n\t\t     unsigned int hooknum)\n{\n\tstruct nf_conn *ct;\n\tenum ip_conntrack_info ctinfo;\n\t__be32 newdst;\n\tstruct nf_nat_range newrange;\n\tNF_CT_ASSERT(hooknum == NF_INET_PRE_ROUTING ||\n\t\t     hooknum == NF_INET_LOCAL_OUT);\n\tct = nf_ct_get(skb, &ctinfo);\n\tNF_CT_ASSERT(ct && (ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED));\n\tif (hooknum == NF_INET_LOCAL_OUT) {\n\t\tnewdst = htonl(0x7F000001);\n\t} else {\n\t\tstruct in_device *indev;\n\t\tstruct in_ifaddr *ifa;\n\t\tnewdst = 0;\n\t\trcu_read_lock();\n\t\tindev = __in_dev_get_rcu(skb->dev);\n\t\tif (indev != NULL) {\n\t\t\tifa = indev->ifa_list;\n\t\t\tnewdst = ifa->ifa_local;\n\t\t}\n\t\trcu_read_unlock();\n\t\tif (!newdst)\n\t\t\treturn NF_DROP;\n\t}\n\tmemset(&newrange.min_addr, 0, sizeof(newrange.min_addr));\n\tmemset(&newrange.max_addr, 0, sizeof(newrange.max_addr));\n\tnewrange.flags\t     = mr->range[0].flags | NF_NAT_RANGE_MAP_IPS;\n\tnewrange.min_addr.ip = newdst;\n\tnewrange.max_addr.ip = newdst;\n\tnewrange.min_proto   = mr->range[0].min;\n\tnewrange.max_proto   = mr->range[0].max;\n\treturn nf_nat_setup_info(ct, &newrange, NF_NAT_MANIP_DST);\n}", "target": 1}
{"code": "  add_authorized_client(const std::string &name, std::string &&cert) {\n    client_t &client = client_root;\n    named_cert_t named_cert;\n    named_cert.name = name;\n    named_cert.cert = std::move(cert);\n    named_cert.uuid = uuid_util::uuid_t::generate().string();\n    client.named_devices.emplace_back(named_cert);\n    if (!config::sunshine.flags[config::flag::FRESH_STATE]) {\n      save_state();\n    }\n  }", "target": 0}
{"code": "smb2_queryfs(const unsigned int xid, struct cifs_tcon *tcon,\n\t     struct cifs_sb_info *cifs_sb, struct kstatfs *buf)\n{\n\tstruct smb2_query_info_rsp *rsp;\n\tstruct smb2_fs_full_size_info *info = NULL;\n\tstruct kvec rsp_iov = {NULL, 0};\n\tint buftype = CIFS_NO_BUFFER;\n\tint rc;\n\trc = smb2_query_info_compound(xid, tcon, \"\",\n\t\t\t\t      FILE_READ_ATTRIBUTES,\n\t\t\t\t      FS_FULL_SIZE_INFORMATION,\n\t\t\t\t      SMB2_O_INFO_FILESYSTEM,\n\t\t\t\t      sizeof(struct smb2_fs_full_size_info),\n\t\t\t\t      &rsp_iov, &buftype, cifs_sb);\n\tif (rc)\n\t\tgoto qfs_exit;\n\trsp = (struct smb2_query_info_rsp *)rsp_iov.iov_base;\n\tbuf->f_type = SMB2_SUPER_MAGIC;\n\tinfo = (struct smb2_fs_full_size_info *)(\n\t\tle16_to_cpu(rsp->OutputBufferOffset) + (char *)rsp);\n\trc = smb2_validate_iov(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t       le32_to_cpu(rsp->OutputBufferLength),\n\t\t\t       &rsp_iov,\n\t\t\t       sizeof(struct smb2_fs_full_size_info));\n\tif (!rc)\n\t\tsmb2_copy_fs_info_to_kstatfs(info, buf);\nqfs_exit:\n\tfree_rsp_buf(buftype, rsp_iov.iov_base);\n\treturn rc;\n}", "target": 0}
{"code": "static int do_fault(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, pte_t *page_table, pmd_t *pmd,\n\t\tunsigned int flags, pte_t orig_pte)\n{\n\tpgoff_t pgoff = (((address & PAGE_MASK)\n\t\t\t- vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\tpte_unmap(page_table);\n\tif (!vma->vm_ops->fault)\n\t\treturn VM_FAULT_SIGBUS;\n\tif (!(flags & FAULT_FLAG_WRITE))\n\t\treturn do_read_fault(mm, vma, address, pmd, pgoff, flags,\n\t\t\t\torig_pte);\n\tif (!(vma->vm_flags & VM_SHARED))\n\t\treturn do_cow_fault(mm, vma, address, pmd, pgoff, flags,\n\t\t\t\torig_pte);\n\treturn do_shared_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);\n}", "target": 0}
{"code": "GF_Err gf_isom_use_compact_size(GF_ISOFile *movie, u32 trackNumber, Bool CompactionOn)\n{\n\tGF_TrackBox *trak;\n\tu32 i, size;\n\tGF_SampleSizeBox *stsz;\n\tGF_Err e;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media || !trak->Media->information\n\t        || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize)\n\t\treturn GF_ISOM_INVALID_FILE;\n\tstsz = trak->Media->information->sampleTable->SampleSize;\n\tif (!CompactionOn) {\n\t\tif (stsz->type == GF_ISOM_BOX_TYPE_STSZ) return GF_OK;\n\t\tstsz->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\tstsz->sampleSize = 0;\n\t\tif (!stsz->sampleCount) return GF_OK;\n\t\tif (!stsz->sizes) return GF_OK;\n\t\tsize = stsz->sizes[0];\n\t\tfor (i=1; i<stsz->sampleCount; i++) {\n\t\t\tif (size != stsz->sizes[i]) {\n\t\t\t\tsize = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (size) {\n\t\t\tgf_free(stsz->sizes);\n\t\t\tstsz->sizes = NULL;\n\t\t\tstsz->sampleSize = size;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (stsz->type == GF_ISOM_BOX_TYPE_STZ2) return GF_OK;\n\tif (stsz->sampleSize) {\n\t\tif (stsz->sizes) gf_free(stsz->sizes);\n\t\tstsz->sizes = (u32*) gf_malloc(sizeof(u32)*stsz->sampleCount);\n\t\tif (!stsz->sizes) return GF_OUT_OF_MEM;\n\t\tmemset(stsz->sizes, stsz->sampleSize, sizeof(u32));\n\t}\n\tstsz->sampleSize = 0;\n\tstsz->type = GF_ISOM_BOX_TYPE_STZ2;\n\treturn GF_OK;\n}", "target": 1}
{"code": "_pdfioFileConsume(pdfio_file_t *pdf,\t\n                  size_t       bytes)\t\n{\n  PDFIO_DEBUG(\"_pdfioFileConsume(pdf=%p, bytes=%u)\\n\", pdf, (unsigned)bytes);\n  if ((size_t)(pdf->bufend - pdf->bufptr) > bytes)\n    pdf->bufptr += bytes;\n  else if (_pdfioFileSeek(pdf, (off_t)bytes, SEEK_CUR) < 0)\n    return (false);\n  PDFIO_DEBUG(\"_pdfioFileConsume: pos=%ld\\n\", (long)(pdf->bufpos + pdf->bufptr - pdf->buffer));\n  return (true);\n}", "target": 0}
{"code": "mm_zalloc(struct mm_master *mm, u_int ncount, u_int size)\n{\n\tif (size == 0 || ncount == 0 || ncount > SIZE_MAX / size)\n\t\tfatal(\"%s: mm_zalloc(%u, %u)\", __func__, ncount, size);\n\treturn mm_malloc(mm, size * ncount);\n}", "target": 1}
{"code": "static void mctp_unregister(struct net_device *dev)\n{\n\tstruct mctp_dev *mdev;\n\tmdev = mctp_dev_get_rtnl(dev);\n\tif (mdev && !mctp_known(dev)) {\n\t\tnetdev_warn(dev, \"%s: BUG mctp_ptr set for unknown type %d\",\n\t\t\t    __func__, dev->type);\n\t\treturn;\n\t}\n\tif (!mdev)\n\t\treturn;\n\tRCU_INIT_POINTER(mdev->dev->mctp_ptr, NULL);\n\tmctp_route_remove_dev(mdev);\n\tmctp_neigh_remove_dev(mdev);\n\tkfree(mdev->addrs);\n\tmctp_dev_put(mdev);\n}", "target": 1}
{"code": "static const char* ConvertOneFloat(PyObject* v, T* out) {\n  if (PyErr_Occurred()) {\n    return nullptr;\n  }\n  if (TF_PREDICT_TRUE(PyFloat_Check(v))) {\n    const double as_double = PyFloat_AS_DOUBLE(v);\n    *out = static_cast<T>(as_double);\n    if (TF_PREDICT_FALSE(sizeof(T) < sizeof(double) && std::isinf(*out) &&\n                         std::isfinite(as_double))) {\n      return ErrorOutOfRangeDouble;\n    }\n    return nullptr;\n  }\n#if PY_MAJOR_VERSION < 3\n  if (PyInt_Check(v)) {\n    *out = PyInt_AS_LONG(v);\n    return nullptr;\n  }\n#endif\n  if (PyLong_Check(v)) {\n    *out = PyLong_AsDouble(v);\n    if (PyErr_Occurred()) return ErrorOutOfRangeDouble;\n    return nullptr;\n  }\n  if (PyIsInstance(v, &PyFloatingArrType_Type)) {  \n    Safe_PyObjectPtr as_float = make_safe(PyNumber_Float(v));\n    if (PyErr_Occurred()) {\n      return nullptr;\n    }\n    return ConvertOneFloat<T>(as_float.get(), out);\n  }\n  if (PyIsInstance(v, &PyIntegerArrType_Type)) {  \n#if PY_MAJOR_VERSION < 3\n    Safe_PyObjectPtr as_int = make_safe(PyNumber_Int(v));\n#else\n    Safe_PyObjectPtr as_int = make_safe(PyNumber_Long(v));\n#endif\n    if (PyErr_Occurred()) {\n      return nullptr;\n    }\n    return ConvertOneFloat<T>(as_int.get(), out);\n  }\n  return ErrorMixedTypes;\n}", "target": 1}
{"code": "snmp_mib_find_next(uint32_t *oid)\n{\n  snmp_mib_resource_t *resource;\n  resource = NULL;\n  for(resource = list_head(snmp_mib);\n      resource; resource = resource->next) {\n    if(snmp_oid_cmp_oid(resource->oid, oid) > 0) {\n      return resource;\n    }\n  }\n  return NULL;\n}", "target": 1}
{"code": "static int unpack_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_unpack *pkt;\n\tGIT_UNUSED(len);\n\tpkt = git__malloc(sizeof(*pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\tpkt->type = GIT_PKT_UNPACK;\n\tif (!git__prefixcmp(line, \"unpack ok\"))\n\t\tpkt->unpack_ok = 1;\n\telse\n\t\tpkt->unpack_ok = 0;\n\t*out = (git_pkt *)pkt;\n\treturn 0;\n}", "target": 0}
{"code": "void track_set_index(Track *track, int i, long ind)\n{\n\tif (i > MAXINDEX) {\n\t\tfprintf(stderr, \"too many indexes\\n\");\n                return;\n        }\n\ttrack->index[i] = ind;\n}", "target": 1}
{"code": "static void iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)\n{\n\tif (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE))\n\t\tIWL_ERR(priv, \"ACTIVATE a non DRIVER active station id %u \"\n\t\t\t\"addr %pM\\n\",\n\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\tif (priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE) {\n\t\tIWL_DEBUG_ASSOC(priv,\n\t\t\t\t\"STA id %u addr %pM already present in uCode \"\n\t\t\t\t\"(according to driver)\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t} else {\n\t\tpriv->stations[sta_id].used |= IWL_STA_UCODE_ACTIVE;\n\t\tIWL_DEBUG_ASSOC(priv, \"Added STA id %u addr %pM to uCode\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t}\n}", "target": 1}
{"code": "static void sas_destruct_ports(struct asd_sas_port *port)\n{\n\tstruct sas_port *sas_port, *p;\n\tlist_for_each_entry_safe(sas_port, p, &port->sas_port_del_list, del_list) {\n\t\tlist_del_init(&sas_port->del_list);\n\t\tsas_port_delete(sas_port);\n\t}\n}", "target": 0}
{"code": "static void sunkbd_set_leds_beeps(struct sunkbd *sunkbd)\n{\n\tserio_write(sunkbd->serio, SUNKBD_CMD_SETLED);\n\tserio_write(sunkbd->serio,\n\t\t(!!test_bit(LED_CAPSL,   sunkbd->dev->led) << 3) |\n\t\t(!!test_bit(LED_SCROLLL, sunkbd->dev->led) << 2) |\n\t\t(!!test_bit(LED_COMPOSE, sunkbd->dev->led) << 1) |\n\t\t !!test_bit(LED_NUML,    sunkbd->dev->led));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_NOCLICK - !!test_bit(SND_CLICK, sunkbd->dev->snd));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_BELLOFF - !!test_bit(SND_BELL, sunkbd->dev->snd));\n}", "target": 0}
{"code": "static int http1_on_request(http1_parser_s *parser) {\n  http1pr_s *p = parser2http(parser);\n  http_on_request_handler______internal(&http1_pr2handle(p), p->p.settings);\n  if (p->request.method && !p->stop)\n    http_finish(&p->request);\n  h1_reset(p);\n  return !p->close && fio_is_closed(p->p.uuid);\n}", "target": 1}
{"code": "void inet_sock_destruct(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\t__skb_queue_purge(&sk->sk_receive_queue);\n\t__skb_queue_purge(&sk->sk_error_queue);\n\tsk_mem_reclaim(sk);\n\tif (sk->sk_type == SOCK_STREAM && sk->sk_state != TCP_CLOSE) {\n\t\tpr_err(\"Attempt to release TCP socket in state %d %p\\n\",\n\t\t       sk->sk_state, sk);\n\t\treturn;\n\t}\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Attempt to release alive inet socket %p\\n\", sk);\n\t\treturn;\n\t}\n\tWARN_ON(atomic_read(&sk->sk_rmem_alloc));\n\tWARN_ON(atomic_read(&sk->sk_wmem_alloc));\n\tWARN_ON(sk->sk_wmem_queued);\n\tWARN_ON(sk->sk_forward_alloc);\n\tkfree(inet->opt);\n\tdst_release(rcu_dereference_check(sk->sk_dst_cache, 1));\n\tsk_refcnt_debug_dec(sk);\n}", "target": 1}
{"code": "int main(void)\n{\n\tint fd;\n\tunsigned int i;\n\tunsigned int start = 0;\n\tunsigned int _gap = ~0;\n\tunsigned int gap = _gap / 8;\n\tstruct qcedev_cipher_op_req req = { 0 };\n\tchar *data;\n\tfd = open(dev, O_RDWR);\n\tif (fd < 0) {\n\t\tprintf(\"Failed to open %s with errno %s\\n\", dev,\n\t\t       strerror(errno));\n\t\treturn EXIT_FAILURE;\n\t}\n\tthread_func(start, start + gap, fd);\n\tsleep(1000000);\n\treturn EXIT_FAILURE;\n}", "target": 0}
{"code": "static bool open_match_attributes(connection_struct *conn,\n\t\t\t\t  uint32 old_dos_attr,\n\t\t\t\t  uint32 new_dos_attr,\n\t\t\t\t  mode_t existing_unx_mode,\n\t\t\t\t  mode_t new_unx_mode,\n\t\t\t\t  mode_t *returned_unx_mode)\n{\n\tuint32 noarch_old_dos_attr, noarch_new_dos_attr;\n\tnoarch_old_dos_attr = (old_dos_attr & ~FILE_ATTRIBUTE_ARCHIVE);\n\tnoarch_new_dos_attr = (new_dos_attr & ~FILE_ATTRIBUTE_ARCHIVE);\n\tif((noarch_old_dos_attr == 0 && noarch_new_dos_attr != 0) || \n\t   (noarch_old_dos_attr != 0 && ((noarch_old_dos_attr & noarch_new_dos_attr) == noarch_old_dos_attr))) {\n\t\t*returned_unx_mode = new_unx_mode;\n\t} else {\n\t\t*returned_unx_mode = (mode_t)0;\n\t}\n\tDEBUG(10,(\"open_match_attributes: old_dos_attr = 0x%x, \"\n\t\t  \"existing_unx_mode = 0%o, new_dos_attr = 0x%x \"\n\t\t  \"returned_unx_mode = 0%o\\n\",\n\t\t  (unsigned int)old_dos_attr,\n\t\t  (unsigned int)existing_unx_mode,\n\t\t  (unsigned int)new_dos_attr,\n\t\t  (unsigned int)*returned_unx_mode ));\n\tif (lp_map_system(SNUM(conn)) || lp_store_dos_attributes(SNUM(conn))) {\n\t\tif ((old_dos_attr & FILE_ATTRIBUTE_SYSTEM) &&\n\t\t    !(new_dos_attr & FILE_ATTRIBUTE_SYSTEM)) {\n\t\t\treturn False;\n\t\t}\n\t}\n\tif (lp_map_hidden(SNUM(conn)) || lp_store_dos_attributes(SNUM(conn))) {\n\t\tif ((old_dos_attr & FILE_ATTRIBUTE_HIDDEN) &&\n\t\t    !(new_dos_attr & FILE_ATTRIBUTE_HIDDEN)) {\n\t\t\treturn False;\n\t\t}\n\t}\n\treturn True;\n}", "target": 0}
{"code": "Server::clientWriteDone(const CommIoCbParams &io)\n{\n    debugs(33,5, io.conn);\n    Must(writer != nullptr);\n    writer = nullptr;\n    if (io.flag == Comm::ERR_CLOSING || !Comm::IsConnOpen(clientConnection)) {\n        debugs(33,5, io.conn << \" closing Bailout.\");\n        return;\n    }\n    Must(io.conn->fd == clientConnection->fd);\n    if (io.flag && pipeline.front())\n        pipeline.front()->initiateClose(\"write failure\");\n    afterClientWrite(io.size); \n    writeSomeData(); \n}", "target": 1}
{"code": "CString CWebSock::GetSkinPath(const CString& sSkinName) {\n    CString sRet = CZNC::Get().GetZNCPath() + \"/webskins/\" + sSkinName;\n    if (!CFile::IsDir(sRet)) {\n        sRet = CZNC::Get().GetCurPath() + \"/webskins/\" + sSkinName;\n        if (!CFile::IsDir(sRet)) {\n            sRet = CString(_SKINDIR_) + \"/\" + sSkinName;\n        }\n    }\n    return sRet + \"/\";\n}", "target": 1}
{"code": "  explicit ThreadPoolHandleOp(OpKernelConstruction* ctx) : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"display_name\", &display_name_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"num_threads\", &num_threads_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"max_intra_op_parallelism\",\n                                     &max_intra_op_parallelism_));\n    OP_REQUIRES(\n        ctx, num_threads_ > 0,\n        errors::InvalidArgument(\"`num_threads` must be greater than zero.\"));\n  }", "target": 1}
{"code": "  StatusOr<std::vector<int64_t>> GetKernelSize(XlaOpKernelContext* ctx) {\n    if (ctx->num_inputs() == 1) {\n      return ksize_;\n    }\n    const TensorShape ksize_shape = ctx->InputShape(1);\n    if (!TensorShapeUtils::IsVector(ksize_shape)) {\n      return errors::InvalidArgument(\"ksize must be a vector, not shape \",\n                                     ksize_shape.DebugString());\n    }\n    if (ksize_shape.num_elements() != num_dims()) {\n      return errors::InvalidArgument(\n          \"Sliding window ksize field must \"\n          \"specify \",\n          num_dims(), \" dimensions\");\n    }\n    std::vector<int64_t> ksize;\n    auto status = ctx->ConstantInputAsIntVector(1, &ksize);\n    if (!status.ok()) {\n      return status;\n    }\n    return ksize;\n  }", "target": 1}
{"code": "  virtual void requestInit() {\n    m_use_error = false;\n    m_errors.reset();\n    xmlParserInputBufferCreateFilenameDefault(nullptr);\n  }", "target": 1}
{"code": "static inline void context_set_translation_type(struct context_entry *context,\n\t\t\t\t\t\tunsigned long value)\n{\n\tcontext->lo &= (((u64)-1) << 4) | 3;\n\tcontext->lo |= (value & 3) << 2;\n}", "target": 0}
{"code": "static int ep_poll_callback(wait_queue_t *wait, unsigned mode, int sync, void *key)\n{\n\tint pwake = 0;\n\tunsigned long flags;\n\tstruct epitem *epi = ep_item_from_wait(wait);\n\tstruct eventpoll *ep = epi->ep;\n\tif ((unsigned long)key & POLLFREE) {\n\t\tep_pwq_from_wait(wait)->whead = NULL;\n\t\tlist_del_init(&wait->task_list);\n\t}\n\tspin_lock_irqsave(&ep->lock, flags);\n\tif (!(epi->event.events & ~EP_PRIVATE_BITS))\n\t\tgoto out_unlock;\n\tif (key && !((unsigned long) key & epi->event.events))\n\t\tgoto out_unlock;\n\tif (unlikely(ep->ovflist != EP_UNACTIVE_PTR)) {\n\t\tif (epi->next == EP_UNACTIVE_PTR) {\n\t\t\tepi->next = ep->ovflist;\n\t\t\tep->ovflist = epi;\n\t\t}\n\t\tgoto out_unlock;\n\t}\n\tif (!ep_is_linked(&epi->rdllink))\n\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\tif (waitqueue_active(&ep->wq))\n\t\twake_up_locked(&ep->wq);\n\tif (waitqueue_active(&ep->poll_wait))\n\t\tpwake++;\nout_unlock:\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\treturn 1;\n}", "target": 0}
{"code": "static BOOL rdp_read_font_capability_set(wStream* s, UINT16 length, rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (length > 4)\n\t\tStream_Seek_UINT16(s); \n\tif (length > 6)\n\t\tStream_Seek_UINT16(s); \n\treturn TRUE;\n}", "target": 1}
{"code": "int db__open(struct mosquitto__config *config)\n{\n\tstruct mosquitto__subhier *subhier;\n\tif(!config) return MOSQ_ERR_INVAL;\n\tdb.last_db_id = 0;\n\tdb.contexts_by_id = NULL;\n\tdb.contexts_by_sock = NULL;\n\tdb.contexts_for_free = NULL;\n#ifdef WITH_BRIDGE\n\tdb.bridges = NULL;\n\tdb.bridge_count = 0;\n#endif\n\tdb.clientid_index_hash = NULL;\n\tdb.subs = NULL;\n\tsubhier = sub__add_hier_entry(NULL, &db.subs, \"\", 0);\n\tif(!subhier) return MOSQ_ERR_NOMEM;\n\tsubhier = sub__add_hier_entry(NULL, &db.subs, \"$SYS\", (uint16_t)strlen(\"$SYS\"));\n\tif(!subhier) return MOSQ_ERR_NOMEM;\n\tretain__init();\n\tdb.config->security_options.unpwd = NULL;\n#ifdef WITH_PERSISTENCE\n\tif(persist__restore()) return 1;\n#endif\n\treturn MOSQ_ERR_SUCCESS;\n}", "target": 1}
{"code": "int BN_GF2m_poly2arr(const BIGNUM *a, int p[], int max)\n{\n    int i, j, k = 0;\n    BN_ULONG mask;\n    if (BN_is_zero(a))\n        return 0;\n    for (i = a->top - 1; i >= 0; i--) {\n        if (!a->d[i])\n            continue;\n        mask = BN_TBIT;\n        for (j = BN_BITS2 - 1; j >= 0; j--) {\n            if (a->d[i] & mask) {\n                if (k < max)\n                    p[k] = BN_BITS2 * i + j;\n                k++;\n            }\n            mask >>= 1;\n        }\n    }\n    if (k < max) {\n        p[k] = -1;\n        k++;\n    }\n    return k;\n}", "target": 1}
{"code": "static ssize_t aio_setup_vectored_rw(struct kiocb *kiocb,\n\t\t\t\t     int rw, char __user *buf,\n\t\t\t\t     unsigned long *nr_segs,\n\t\t\t\t     size_t *len,\n\t\t\t\t     struct iovec **iovec,\n\t\t\t\t     bool compat)\n{\n\tssize_t ret;\n\t*nr_segs = *len;\n#ifdef CONFIG_COMPAT\n\tif (compat)\n\t\tret = compat_rw_copy_check_uvector(rw,\n\t\t\t\t(struct compat_iovec __user *)buf,\n\t\t\t\t*nr_segs, UIO_FASTIOV, *iovec, iovec);\n\telse\n#endif\n\t\tret = rw_copy_check_uvector(rw,\n\t\t\t\t(struct iovec __user *)buf,\n\t\t\t\t*nr_segs, UIO_FASTIOV, *iovec, iovec);\n\tif (ret < 0)\n\t\treturn ret;\n\t*len = ret;\n\treturn 0;\n}", "target": 1}
{"code": "static int libusb_udev_isoch_transfer(IUDEVICE* idev, URBDRC_CHANNEL_CALLBACK* callback,\n                                      UINT32 MessageId, UINT32 RequestId, UINT32 EndpointAddress,\n                                      UINT32 TransferFlags, UINT32 StartFrame, UINT32 ErrorCount,\n                                      BOOL NoAck, const BYTE* packetDescriptorData,\n                                      UINT32 NumberOfPackets, UINT32 BufferSize, const BYTE* Buffer,\n                                      t_isoch_transfer_cb cb, UINT32 Timeout)\n{\n\tUINT32 iso_packet_size;\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\tASYNC_TRANSFER_USER_DATA* user_data;\n\tstruct libusb_transfer* iso_transfer = NULL;\n\tURBDRC_PLUGIN* urbdrc;\n\tsize_t outSize = (NumberOfPackets * 12);\n\tuint32_t streamID = 0x40000000 | RequestId;\n\tif (!pdev || !pdev->urbdrc)\n\t\treturn -1;\n\turbdrc = pdev->urbdrc;\n\tuser_data = async_transfer_user_data_new(idev, MessageId, 48, BufferSize, Buffer,\n\t                                         outSize + 1024, NoAck, cb, callback);\n\tif (!user_data)\n\t\treturn -1;\n\tuser_data->ErrorCount = ErrorCount;\n\tuser_data->StartFrame = StartFrame;\n\tif (!Buffer)\n\t\tStream_Seek(user_data->data, (NumberOfPackets * 12));\n\tiso_packet_size = BufferSize / NumberOfPackets;\n\tiso_transfer = libusb_alloc_transfer(NumberOfPackets);\n\tif (iso_transfer == NULL)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_ERROR, \"Error: libusb_alloc_transfer.\");\n\t\tasync_transfer_user_data_free(user_data);\n\t\treturn -1;\n\t}\n\tlibusb_fill_iso_transfer(iso_transfer, pdev->libusb_handle, EndpointAddress,\n\t                         Stream_Pointer(user_data->data), BufferSize, NumberOfPackets,\n\t                         func_iso_callback, user_data, Timeout);\n\tset_stream_id_for_buffer(iso_transfer, streamID);\n\tlibusb_set_iso_packet_lengths(iso_transfer, iso_packet_size);\n\tif (ArrayList_Add(pdev->request_queue, iso_transfer) < 0)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_WARN,\n\t\t           \"Failed to queue iso transfer, streamID %08\" PRIx32 \" already in use!\",\n\t\t           streamID);\n\t\trequest_free(iso_transfer);\n\t\treturn -1;\n\t}\n\treturn libusb_submit_transfer(iso_transfer);\n}", "target": 1}
{"code": "PredictorEncodeTile(TIFF* tif, uint8* bp0, tmsize_t cc0, uint16 s)\n{\n\tstatic const char module[] = \"PredictorEncodeTile\";\n\tTIFFPredictorState *sp = PredictorState(tif);\n        uint8 *working_copy;\n\ttmsize_t cc = cc0, rowsize;\n\tunsigned char* bp;\n        int result_code;\n\tassert(sp != NULL);\n\tassert(sp->encodepfunc != NULL);\n\tassert(sp->encodetile != NULL);\n        working_copy = (uint8*) _TIFFmalloc(cc0);\n        if( working_copy == NULL )\n        {\n            TIFFErrorExt(tif->tif_clientdata, module, \n                         \"Out of memory allocating \" TIFF_SSIZE_FORMAT \" byte temp buffer.\",\n                         cc0 );\n            return 0;\n        }\n        memcpy( working_copy, bp0, cc0 );\n        bp = working_copy;\n\trowsize = sp->rowsize;\n\tassert(rowsize > 0);\n\tif((cc0%rowsize)!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"PredictorEncodeTile\",\n                     \"%s\", \"(cc0%rowsize)!=0\");\n        _TIFFfree( working_copy );\n        return 0;\n    }\n\twhile (cc > 0) {\n\t\t(*sp->encodepfunc)(tif, bp, rowsize);\n\t\tcc -= rowsize;\n\t\tbp += rowsize;\n\t}\n\tresult_code = (*sp->encodetile)(tif, working_copy, cc0, s);\n        _TIFFfree( working_copy );\n        return result_code;\n}", "target": 0}
{"code": "\tCmdResult HandleLocal(LocalUser* user, const Params& parameters) CXX11_OVERRIDE\n\t{\n\t\tsize_t origin = parameters.size() > 1 ? 1 : 0;\n\t\tif (parameters[origin].empty())\n\t\t{\n\t\t\tuser->WriteNumeric(ERR_NOORIGIN, \"No origin specified\");\n\t\t\treturn CMD_FAILURE;\n\t\t}\n\t\tClientProtocol::Messages::Pong pong(parameters[0], origin ? parameters[1] : \"\");\n\t\tuser->Send(ServerInstance->GetRFCEvents().pong, pong);\n\t\treturn CMD_SUCCESS;\n\t}", "target": 1}
{"code": "static bool kvm_vcpu_check_breakpoint(struct kvm_vcpu *vcpu, int *r)\n{\n\tif (unlikely(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) &&\n\t    (vcpu->arch.guest_debug_dr7 & DR7_BP_EN_MASK)) {\n\t\tstruct kvm_run *kvm_run = vcpu->run;\n\t\tunsigned long eip = kvm_get_linear_rip(vcpu);\n\t\tu32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.guest_debug_dr7,\n\t\t\t\t\t   vcpu->arch.eff_db);\n\t\tif (dr6 != 0) {\n\t\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_ACTIVE_LOW;\n\t\t\tkvm_run->debug.arch.pc = eip;\n\t\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\t*r = 0;\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (unlikely(vcpu->arch.dr7 & DR7_BP_EN_MASK) &&\n\t    !(kvm_get_rflags(vcpu) & X86_EFLAGS_RF)) {\n\t\tunsigned long eip = kvm_get_linear_rip(vcpu);\n\t\tu32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.dr7,\n\t\t\t\t\t   vcpu->arch.db);\n\t\tif (dr6 != 0) {\n\t\t\tkvm_queue_exception_p(vcpu, DB_VECTOR, dr6);\n\t\t\t*r = 1;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 1}
{"code": "ResourceHandle::ResourceHandle(const ResourceHandleProto& proto) {\n  FromProto(proto);\n}", "target": 1}
{"code": "call_bind_status(struct rpc_task *task)\n{\n\tint status = -EIO;\n\tif (task->tk_status >= 0) {\n\t\tdprint_status(task);\n\t\ttask->tk_status = 0;\n\t\ttask->tk_action = call_connect;\n\t\treturn;\n\t}\n\tswitch (task->tk_status) {\n\tcase -ENOMEM:\n\t\tdprintk(\"RPC: %5u rpcbind out of memory\\n\", task->tk_pid);\n\t\trpc_delay(task, HZ >> 2);\n\t\tgoto retry_timeout;\n\tcase -EACCES:\n\t\tdprintk(\"RPC: %5u remote rpcbind: RPC program/version \"\n\t\t\t\t\"unavailable\\n\", task->tk_pid);\n\t\tif (task->tk_msg.rpc_proc->p_proc == 0) {\n\t\t\tstatus = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\t\tif (task->tk_rebind_retry == 0)\n\t\t\tbreak;\n\t\ttask->tk_rebind_retry--;\n\t\trpc_delay(task, 3*HZ);\n\t\tgoto retry_timeout;\n\tcase -ETIMEDOUT:\n\t\tdprintk(\"RPC: %5u rpcbind request timed out\\n\",\n\t\t\t\ttask->tk_pid);\n\t\tgoto retry_timeout;\n\tcase -EPFNOSUPPORT:\n\t\tdprintk(\"RPC: %5u unrecognized remote rpcbind service\\n\",\n\t\t\t\ttask->tk_pid);\n\t\tbreak;\n\tcase -EPROTONOSUPPORT:\n\t\tdprintk(\"RPC: %5u remote rpcbind version unavailable, retrying\\n\",\n\t\t\t\ttask->tk_pid);\n\t\ttask->tk_status = 0;\n\t\ttask->tk_action = call_bind;\n\t\treturn;\n\tcase -ECONNREFUSED:\t\t\n\tcase -ECONNRESET:\n\tcase -ENOTCONN:\n\tcase -EHOSTDOWN:\n\tcase -EHOSTUNREACH:\n\tcase -ENETUNREACH:\n\tcase -EPIPE:\n\t\tdprintk(\"RPC: %5u remote rpcbind unreachable: %d\\n\",\n\t\t\t\ttask->tk_pid, task->tk_status);\n\t\tif (!RPC_IS_SOFTCONN(task)) {\n\t\t\trpc_delay(task, 5*HZ);\n\t\t\tgoto retry_timeout;\n\t\t}\n\t\tstatus = task->tk_status;\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"RPC: %5u unrecognized rpcbind error (%d)\\n\",\n\t\t\t\ttask->tk_pid, -task->tk_status);\n\t}\n\trpc_exit(task, status);\n\treturn;\nretry_timeout:\n\ttask->tk_action = call_timeout;\n}", "target": 0}
{"code": "char *LibRaw_buffer_datastream::gets(char *s, int sz)\n{\n  if(sz<1) return NULL;\n  unsigned char *psrc, *pdest, *str;\n  str = (unsigned char *)s;\n  psrc = buf + streampos;\n  pdest = str;\n  if(streampos >= streamsize) return NULL;\n  while ((size_t(psrc - buf) < streamsize) && ((pdest - str) < (sz-1)))\n  {\n    *pdest = *psrc;\n    if (*psrc == '\\n')\n      break;\n    psrc++;\n    pdest++;\n  }\n  if (size_t(psrc - buf) < streamsize)\n    psrc++;\n  if ((pdest - str) < sz-1)\n    *(++pdest) = 0;\n  else\n    s[sz - 1] = 0; \n  streampos = psrc - buf;\n  return s;\n}", "target": 0}
{"code": "cdf_check_stream_offset(const cdf_stream_t *sst, const cdf_header_t *h,\n    const void *p, size_t tail, int line)\n{\n\tconst char *b = (const char *)sst->sst_tab;\n\tconst char *e = ((const char *)p) + tail;\n\tsize_t ss = sst->sst_dirlen < h->h_min_size_standard_stream ?\n\t    CDF_SHORT_SEC_SIZE(h) : CDF_SEC_SIZE(h);\n\t(void)&line;\n\tif (e >= b && (size_t)(e - b) <= ss * sst->sst_len)\n\t\treturn 0;\n\tDPRINTF((\"%d: offset begin %p < end %p || %\" SIZE_T_FORMAT \"u\"\n\t    \" > %\" SIZE_T_FORMAT \"u [%\" SIZE_T_FORMAT \"u %\"\n\t    SIZE_T_FORMAT \"u]\\n\", line, b, e, (size_t)(e - b),\n\t    ss * sst->sst_len, ss, sst->sst_len));\n\terrno = EFTYPE;\n\treturn -1;\n}", "target": 0}
{"code": "static void __nfs4_close(struct path *path, struct nfs4_state *state, mode_t mode, int wait)\n{\n\tstruct nfs4_state_owner *owner = state->owner;\n\tint call_close = 0;\n\tint newstate;\n\tatomic_inc(&owner->so_count);\n\tspin_lock(&owner->so_lock);\n\tswitch (mode & (FMODE_READ | FMODE_WRITE)) {\n\t\tcase FMODE_READ:\n\t\t\tstate->n_rdonly--;\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tstate->n_wronly--;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tstate->n_rdwr--;\n\t}\n\tnewstate = FMODE_READ|FMODE_WRITE;\n\tif (state->n_rdwr == 0) {\n\t\tif (state->n_rdonly == 0) {\n\t\t\tnewstate &= ~FMODE_READ;\n\t\t\tcall_close |= test_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tcall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t\tif (state->n_wronly == 0) {\n\t\t\tnewstate &= ~FMODE_WRITE;\n\t\t\tcall_close |= test_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tcall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t\tif (newstate == 0)\n\t\t\tclear_bit(NFS_DELEGATED_STATE, &state->flags);\n\t}\n\tnfs4_state_set_mode_locked(state, newstate);\n\tspin_unlock(&owner->so_lock);\n\tif (!call_close) {\n\t\tnfs4_put_open_state(state);\n\t\tnfs4_put_state_owner(owner);\n\t} else\n\t\tnfs4_do_close(path, state, wait);\n}", "target": 1}
{"code": "inline bool operator ==(const MaskedIP& l, const MaskedIP& r) {\n  auto shift = std::max((l.v6 ? 128 : 32) - l.prefix,\n\t\t\t(r.v6 ? 128 : 32) - r.prefix);\n  ceph_assert(shift > 0);\n  return (l.addr >> shift) == (r.addr >> shift);\n}", "target": 1}
{"code": "static void free_states(struct bpf_verifier_env *env)\n{\n\tstruct bpf_verifier_state_list *sl, *sln;\n\tint i;\n\tsl = env->free_list;\n\twhile (sl) {\n\t\tsln = sl->next;\n\t\tfree_verifier_state(&sl->state, false);\n\t\tkfree(sl);\n\t\tsl = sln;\n\t}\n\tenv->free_list = NULL;\n\tif (!env->explored_states)\n\t\treturn;\n\tfor (i = 0; i < state_htab_size(env); i++) {\n\t\tsl = env->explored_states[i];\n\t\twhile (sl) {\n\t\t\tsln = sl->next;\n\t\t\tfree_verifier_state(&sl->state, false);\n\t\t\tkfree(sl);\n\t\t\tsl = sln;\n\t\t}\n\t\tenv->explored_states[i] = NULL;\n\t}\n}", "target": 0}
{"code": "static void f2fs_swap_deactivate(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tclear_inode_flag(inode, FI_PIN_FILE);\n}", "target": 0}
{"code": "static inline ut64 dwarf_read_offset(bool is_64bit, const ut8 **buf, const ut8 *buf_end) {\n\tut64 result;\n\tif (is_64bit) {\n\t\tresult = READ64 (*buf);\n\t} else {\n\t\tresult = READ32 (*buf);\n\t}\n\treturn result;\n}", "target": 1}
{"code": "bool RootWindow::DispatchTouchEvent(TouchEvent* event) {\n  DispatchHeldMouseMove();\n  if (ui::IsDIPEnabled()) {\n    float scale = ui::GetDeviceScaleFactor(layer());\n    ui::Transform transform = layer()->transform();\n    transform.ConcatScale(scale, scale);\n    event->UpdateForRootTransform(transform);\n  } else {\n    event->UpdateForRootTransform(layer()->transform());\n  }\n  bool handled = false;\n  ui::TouchStatus status = ui::TOUCH_STATUS_UNKNOWN;\n  Window* target = capture_window_;\n  if (!target) {\n    target = ConsumerToWindow(\n        gesture_recognizer_->GetTouchLockedTarget(event));\n    if (!target) {\n      target = ConsumerToWindow(\n          gesture_recognizer_->GetTargetForLocation(event->GetLocation()));\n    }\n  }\n  if (!target && !bounds().Contains(event->location())) {\n    target = this;\n  } else {\n    if (!target) {\n      target = GetEventHandlerForPoint(event->location());\n      if (!target)\n        return false;\n    }\n    TouchEvent translated_event(*event, this, target);\n    status = ProcessTouchEvent(target, &translated_event);\n    handled = status != ui::TOUCH_STATUS_UNKNOWN;\n    if (status == ui::TOUCH_STATUS_QUEUED ||\n        status == ui::TOUCH_STATUS_QUEUED_END)\n      gesture_recognizer_->QueueTouchEventForGesture(target, *event);\n  }\n  scoped_ptr<ui::GestureRecognizer::Gestures> gestures;\n  gestures.reset(gesture_recognizer_->ProcessTouchEventForGesture(\n      *event, status, target));\n  return ProcessGestures(gestures.get()) ? true : handled;\n}", "target": 0}
{"code": "static unsigned short get_ushort(const unsigned char *data)\n{\n    unsigned short val = *(const unsigned short *)data;\n#ifdef OPJ_BIG_ENDIAN\n    val = ((val & 0xffU) << 8) | (val >> 8);\n#endif\n    return val;\n}", "target": 1}
{"code": "static unsigned int unix_dgram_poll(struct file *file, struct socket *sock,\n\t\t\t\t    poll_table *wait)\n{\n\tstruct sock *sk = sock->sk, *other;\n\tunsigned int mask, writable;\n\tsock_poll_wait(file, sk_sleep(sk), wait);\n\tmask = 0;\n\tif (sk->sk_err || !skb_queue_empty(&sk->sk_error_queue))\n\t\tmask |= POLLERR |\n\t\t\t(sock_flag(sk, SOCK_SELECT_ERR_QUEUE) ? POLLPRI : 0);\n\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\tmask |= POLLRDHUP | POLLIN | POLLRDNORM;\n\tif (sk->sk_shutdown == SHUTDOWN_MASK)\n\t\tmask |= POLLHUP;\n\tif (!skb_queue_empty(&sk->sk_receive_queue))\n\t\tmask |= POLLIN | POLLRDNORM;\n\tif (sk->sk_type == SOCK_SEQPACKET) {\n\t\tif (sk->sk_state == TCP_CLOSE)\n\t\t\tmask |= POLLHUP;\n\t\tif (sk->sk_state == TCP_SYN_SENT)\n\t\t\treturn mask;\n\t}\n\tif (!(poll_requested_events(wait) & (POLLWRBAND|POLLWRNORM|POLLOUT)))\n\t\treturn mask;\n\twritable = unix_writable(sk);\n\tother = unix_peer_get(sk);\n\tif (other) {\n\t\tif (unix_peer(other) != sk) {\n\t\t\tsock_poll_wait(file, &unix_sk(other)->peer_wait, wait);\n\t\t\tif (unix_recvq_full(other))\n\t\t\t\twritable = 0;\n\t\t}\n\t\tsock_put(other);\n\t}\n\tif (writable)\n\t\tmask |= POLLOUT | POLLWRNORM | POLLWRBAND;\n\telse\n\t\tset_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags);\n\treturn mask;\n}", "target": 1}
{"code": "static int tg_cfs_schedulable_down(struct task_group *tg, void *data)\n{\n\tstruct cfs_schedulable_data *d = data;\n\tstruct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth;\n\ts64 quota = 0, parent_quota = -1;\n\tif (!tg->parent) {\n\t\tquota = RUNTIME_INF;\n\t} else {\n\t\tstruct cfs_bandwidth *parent_b = &tg->parent->cfs_bandwidth;\n\t\tquota = normalize_cfs_quota(tg, d);\n\t\tparent_quota = parent_b->hierarchical_quota;\n\t\tif (quota == RUNTIME_INF)\n\t\t\tquota = parent_quota;\n\t\telse if (parent_quota != RUNTIME_INF && quota > parent_quota)\n\t\t\treturn -EINVAL;\n\t}\n\tcfs_b->hierarchical_quota = quota;\n\treturn 0;\n}", "target": 0}
{"code": "static void update_read_synchronize(rdpUpdate* update, wStream* s)\n{\n\tWINPR_UNUSED(update);\n\tStream_Seek_UINT16(s); \n}", "target": 1}
{"code": "int common_timer_set(struct k_itimer *timr, int flags,\n\t\t     struct itimerspec64 *new_setting,\n\t\t     struct itimerspec64 *old_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tbool sigev_none;\n\tktime_t expires;\n\tif (old_setting)\n\t\tcommon_timer_get(timr, old_setting);\n\ttimr->it_interval = 0;\n\tif (kc->timer_try_to_cancel(timr) < 0)\n\t\treturn TIMER_RETRY;\n\ttimr->it_active = 0;\n\ttimr->it_requeue_pending = (timr->it_requeue_pending + 2) &\n\t\t~REQUEUE_PENDING;\n\ttimr->it_overrun_last = 0;\n\tif (!new_setting->it_value.tv_sec && !new_setting->it_value.tv_nsec)\n\t\treturn 0;\n\ttimr->it_interval = timespec64_to_ktime(new_setting->it_interval);\n\texpires = timespec64_to_ktime(new_setting->it_value);\n\tsigev_none = (timr->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE;\n\tkc->timer_arm(timr, expires, flags & TIMER_ABSTIME, sigev_none);\n\ttimr->it_active = !sigev_none;\n\treturn 0;\n}", "target": 1}
{"code": "hufDecode\n    (const Int64 * \thcode,\t\n     const HufDec * \thdecod,\t\n     const char* \tin,\t\n     int\t\tni,\t\n     int\t\trlc,\t\n     int\t\tno,\t\n     unsigned short*\tout)\t\n{\n    Int64 c = 0;\n    int lc = 0;\n    unsigned short * outb = out;\n    unsigned short * oe = out + no;\n    const char * ie = in + (ni + 7) / 8; \n    while (in < ie)\n    {\n\tgetChar (c, lc, in);\n\twhile (lc >= HUF_DECBITS)\n\t{\n\t    const HufDec pl = hdecod[(c >> (lc-HUF_DECBITS)) & HUF_DECMASK];\n\t    if (pl.len)\n\t    {\n\t\tlc -= pl.len;\n\t\tif ( lc < 0 )\n\t\t{\n\t\t\tinvalidCode(); \n\t\t}\n\t\tgetCode (pl.lit, rlc, c, lc, in, out, outb, oe);\n\t    }\n\t    else\n\t    {\n\t\tif (!pl.p)\n\t\t    invalidCode(); \n\t\tint j;\n\t\tfor (j = 0; j < pl.lit; j++)\n\t\t{\n\t\t    int\tl = hufLength (hcode[pl.p[j]]);\n\t\t    while (lc < l && in < ie)\t\n\t\t\tgetChar (c, lc, in);\n\t\t    if (lc >= l)\n\t\t    {\n\t\t\tif (hufCode (hcode[pl.p[j]]) ==\n\t\t\t\t((c >> (lc - l)) & ((Int64(1) << l) - 1)))\n\t\t\t{\n\t\t\t    lc -= l;\n\t\t\t    getCode (pl.p[j], rlc, c, lc, in, out, outb, oe);\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (j == pl.lit)\n\t\t    invalidCode(); \n\t    }\n\t}\n    }\n    int i = (8 - ni) & 7;\n    c >>= i;\n    lc -= i;\n    while (lc > 0)\n    {\n\tconst HufDec pl = hdecod[(c << (HUF_DECBITS - lc)) & HUF_DECMASK];\n\tif (pl.len)\n\t{\n\t    lc -= pl.len;\n            if ( lc < 0 )\n            {\n   \t        invalidCode(); \n            }\n\t    getCode (pl.lit, rlc, c, lc, in, out, outb, oe);\n\t}\n\telse\n\t{\n\t    invalidCode(); \n\t}\n    }\n    if (out - outb != no)\n\tnotEnoughData ();\n}", "target": 0}
{"code": "addMultiArrayContentJSON(CtxJson *ctx, void* array, const UA_DataType *type, \n                         size_t *index, UA_UInt32 *arrayDimensions, size_t dimensionIndex, \n                         size_t dimensionSize) {\n    if(ctx->depth > UA_JSON_ENCODING_MAX_RECURSION)\n        return UA_STATUSCODE_BADENCODINGERROR;\n    status ret;\n    if(dimensionIndex == (dimensionSize - 1)) {\n        ret = encodeJsonArray(ctx, ((u8*)array) + (type->memSize * *index),\n                              arrayDimensions[dimensionIndex], type);\n        (*index) += arrayDimensions[dimensionIndex];\n        return ret;\n    }\n    ret = writeJsonArrStart(ctx);\n    for(size_t i = 0; i < arrayDimensions[dimensionIndex]; i++) {\n        ret |= writeJsonCommaIfNeeded(ctx);\n        ret |= addMultiArrayContentJSON(ctx, array, type, index, arrayDimensions,\n                                        dimensionIndex + 1, dimensionSize);\n        ctx->commaNeeded[ctx->depth] = true;\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n    ret |= writeJsonArrEnd(ctx);\n    return ret;\n}", "target": 1}
{"code": "static int proc_connectinfo(struct usb_dev_state *ps, void __user *arg)\n{\n\tstruct usbdevfs_connectinfo ci = {\n\t\t.devnum = ps->dev->devnum,\n\t\t.slow = ps->dev->speed == USB_SPEED_LOW\n\t};\n\tif (copy_to_user(arg, &ci, sizeof(ci)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "smb3_create_lease_buf(u8 *lease_key, u8 oplock)\n{\n\tstruct create_lease_v2 *buf;\n\tbuf = kzalloc(sizeof(struct create_lease_v2), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\tmemcpy(&buf->lcontext.LeaseKey, lease_key, SMB2_LEASE_KEY_SIZE);\n\tbuf->lcontext.LeaseState = map_oplock_to_lease(oplock);\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct create_lease_v2, lcontext));\n\tbuf->ccontext.DataLength = cpu_to_le32(sizeof(struct lease_context_v2));\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_lease_v2, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\tbuf->Name[0] = 'R';\n\tbuf->Name[1] = 'q';\n\tbuf->Name[2] = 'L';\n\tbuf->Name[3] = 's';\n\treturn (char *)buf;\n}", "target": 0}
{"code": "static int netlink_realloc_groups(struct sock *sk)\n{\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tunsigned int groups;\n\tunsigned long *new_groups;\n\tint err = 0;\n\tnetlink_table_grab();\n\tgroups = nl_table[sk->sk_protocol].groups;\n\tif (!nl_table[sk->sk_protocol].registered) {\n\t\terr = -ENOENT;\n\t\tgoto out_unlock;\n\t}\n\tif (nlk->ngroups >= groups)\n\t\tgoto out_unlock;\n\tnew_groups = krealloc(nlk->groups, NLGRPSZ(groups), GFP_ATOMIC);\n\tif (new_groups == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\tmemset((char *)new_groups + NLGRPSZ(nlk->ngroups), 0,\n\t       NLGRPSZ(groups) - NLGRPSZ(nlk->ngroups));\n\tnlk->groups = new_groups;\n\tnlk->ngroups = groups;\n out_unlock:\n\tnetlink_table_ungrab();\n\treturn err;\n}", "target": 0}
{"code": "static void\nyydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, HEX_LEX_ENVIRONMENT *lex_env)\n{\n  YYUSE (yyvaluep);\n  YYUSE (yyscanner);\n  YYUSE (lex_env);\n  if (!yymsg)\n    yymsg = \"Deleting\";\n  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  switch (yytype)\n    {\n          case 16: \n#line 94 \"hex_grammar.y\" \n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1023 \"hex_grammar.c\" \n        break;\n    case 17: \n#line 95 \"hex_grammar.y\" \n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1029 \"hex_grammar.c\" \n        break;\n    case 18: \n#line 96 \"hex_grammar.y\" \n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1035 \"hex_grammar.c\" \n        break;\n    case 19: \n#line 97 \"hex_grammar.y\" \n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1041 \"hex_grammar.c\" \n        break;\n    case 21: \n#line 100 \"hex_grammar.y\" \n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1047 \"hex_grammar.c\" \n        break;\n    case 22: \n#line 99 \"hex_grammar.y\" \n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1053 \"hex_grammar.c\" \n        break;\n    case 23: \n#line 98 \"hex_grammar.y\" \n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1059 \"hex_grammar.c\" \n        break;\n      default:\n        break;\n    }", "target": 1}
{"code": "static inline int l2cap_connect_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)\n{\n\tstruct l2cap_conn_rsp *rsp = (struct l2cap_conn_rsp *) data;\n\tu16 scid, dcid, result, status;\n\tstruct sock *sk;\n\tu8 req[128];\n\tscid   = __le16_to_cpu(rsp->scid);\n\tdcid   = __le16_to_cpu(rsp->dcid);\n\tresult = __le16_to_cpu(rsp->result);\n\tstatus = __le16_to_cpu(rsp->status);\n\tBT_DBG(\"dcid 0x%4.4x scid 0x%4.4x result 0x%2.2x status 0x%2.2x\", dcid, scid, result, status);\n\tif (scid) {\n\t\tsk = l2cap_get_chan_by_scid(&conn->chan_list, scid);\n\t\tif (!sk)\n\t\t\treturn 0;\n\t} else {\n\t\tsk = l2cap_get_chan_by_ident(&conn->chan_list, cmd->ident);\n\t\tif (!sk)\n\t\t\treturn 0;\n\t}\n\tswitch (result) {\n\tcase L2CAP_CR_SUCCESS:\n\t\tsk->sk_state = BT_CONFIG;\n\t\tl2cap_pi(sk)->ident = 0;\n\t\tl2cap_pi(sk)->dcid = dcid;\n\t\tl2cap_pi(sk)->conf_state |= L2CAP_CONF_REQ_SENT;\n\t\tl2cap_pi(sk)->conf_state &= ~L2CAP_CONF_CONNECT_PEND;\n\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t\t\t\tl2cap_build_conf_req(sk, req), req);\n\t\tl2cap_pi(sk)->num_conf_req++;\n\t\tbreak;\n\tcase L2CAP_CR_PEND:\n\t\tl2cap_pi(sk)->conf_state |= L2CAP_CONF_CONNECT_PEND;\n\t\tbreak;\n\tdefault:\n\t\tl2cap_chan_del(sk, ECONNREFUSED);\n\t\tbreak;\n\t}\n\tbh_unlock_sock(sk);\n\treturn 0;\n}", "target": 0}
{"code": "static void snd_usb_mixer_free(struct usb_mixer_interface *mixer)\n{\n\tsnd_usb_mixer_disconnect(mixer);\n\tkfree(mixer->id_elems);\n\tif (mixer->urb) {\n\t\tkfree(mixer->urb->transfer_buffer);\n\t\tusb_free_urb(mixer->urb);\n\t}\n\tusb_free_urb(mixer->rc_urb);\n\tkfree(mixer->rc_setup_packet);\n\tkfree(mixer);\n}", "target": 0}
{"code": "static int iov_fault_in_pages_write(struct iovec *iov, unsigned long len)\n{\n\twhile (!iov->iov_len)\n\t\tiov++;\n\twhile (len > 0) {\n\t\tunsigned long this_len;\n\t\tthis_len = min_t(unsigned long, len, iov->iov_len);\n\t\tif (fault_in_pages_writeable(iov->iov_base, this_len))\n\t\t\tbreak;\n\t\tlen -= this_len;\n\t\tiov++;\n\t}\n\treturn len;\n}", "target": 1}
{"code": "AirPDcapGetSa(\n    PAIRPDCAP_CONTEXT ctx,\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\n{\n    INT sa_index;\n    if (ctx->sa_index!=-1) {\n        for (sa_index=ctx->sa_index; sa_index>=0; sa_index--) {\n            if (ctx->sa[sa_index].used) {\n                if (memcmp(id, &(ctx->sa[sa_index].saId), sizeof(AIRPDCAP_SEC_ASSOCIATION_ID))==0) {\n                    ctx->index=sa_index;\n                    return sa_index;\n                }\n            }\n        }\n    }\n    return -1;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& val = ctx->input(0);\n    int64 id = ctx->session_state()->GetNewId();\n    TensorStore::TensorAndKey tk{val, id, requested_device()};\n    OP_REQUIRES_OK(ctx, ctx->tensor_store()->AddTensor(name(), tk));\n    Tensor* handle = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({}), &handle));\n    if (ctx->expected_output_dtype(0) == DT_RESOURCE) {\n      ResourceHandle resource_handle = MakeResourceHandle<Tensor>(\n          ctx, SessionState::kTensorHandleResourceTypeName,\n          tk.GetHandle(name()));\n      resource_handle.set_maybe_type_name(\n          SessionState::kTensorHandleResourceTypeName);\n      handle->scalar<ResourceHandle>()() = resource_handle;\n    } else {\n      handle->flat<tstring>().setConstant(tk.GetHandle(name()));\n    }\n  }", "target": 1}
{"code": "static __inline__ int scm_check_creds(struct ucred *creds)\n{\n\tconst struct cred *cred = current_cred();\n\tkuid_t uid = make_kuid(cred->user_ns, creds->uid);\n\tkgid_t gid = make_kgid(cred->user_ns, creds->gid);\n\tif (!uid_valid(uid) || !gid_valid(gid))\n\t\treturn -EINVAL;\n\tif ((creds->pid == task_tgid_vnr(current) ||\n\t     ns_capable(task_active_pid_ns(current)->user_ns, CAP_SYS_ADMIN)) &&\n\t    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||\n\t      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&\n\t    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||\n\t      gid_eq(gid, cred->sgid)) || nsown_capable(CAP_SETGID))) {\n\t       return 0;\n\t}\n\treturn -EPERM;\n}", "target": 0}
{"code": "static int udf_symlink_filler(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct buffer_head *bh = NULL;\n\tunsigned char *symlink;\n\tint err;\n\tunsigned char *p = kmap(page);\n\tstruct udf_inode_info *iinfo;\n\tuint32_t pos;\n\tif (inode->i_size > inode->i_sb->s_blocksize) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out_unmap;\n\t}\n\tiinfo = UDF_I(inode);\n\tpos = udf_block_map(inode, 0);\n\tdown_read(&iinfo->i_data_sem);\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tsymlink = iinfo->i_ext.i_data + iinfo->i_lenEAttr;\n\t} else {\n\t\tbh = sb_bread(inode->i_sb, pos);\n\t\tif (!bh) {\n\t\t\terr = -EIO;\n\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tsymlink = bh->b_data;\n\t}\n\terr = udf_pc_to_char(inode->i_sb, symlink, inode->i_size, p, PAGE_SIZE);\n\tbrelse(bh);\n\tif (err)\n\t\tgoto out_unlock_inode;\n\tup_read(&iinfo->i_data_sem);\n\tSetPageUptodate(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn 0;\nout_unlock_inode:\n\tup_read(&iinfo->i_data_sem);\n\tSetPageError(page);\nout_unmap:\n\tkunmap(page);\n\tunlock_page(page);\n\treturn err;\n}", "target": 0}
{"code": "int test_gtpu_send_indirect_data_forwarding(\n        ogs_socknode_t *node, test_bearer_t *bearer, ogs_pkbuf_t *pkbuf)\n{\n    test_sess_t *sess = NULL;\n    ogs_gtp2_header_t gtp_hdesc;\n    ogs_gtp2_extension_header_t ext_hdesc;\n    ogs_assert(bearer);\n    sess = bearer->sess;\n    ogs_assert(sess);\n    ogs_assert(pkbuf);\n    memset(&gtp_hdesc, 0, sizeof(gtp_hdesc));\n    memset(&ext_hdesc, 0, sizeof(ext_hdesc));\n    gtp_hdesc.type = OGS_GTPU_MSGTYPE_GPDU;\n    if (bearer->qfi) {\n        gtp_hdesc.teid = sess->handover.upf_dl_teid;\n        ext_hdesc.qos_flow_identifier = bearer->qfi;\n    } else if (bearer->ebi) {\n        ogs_fatal(\"Not implmented EPC Indirect Tunnel\");\n        ogs_assert_if_reached();\n    } else {\n        ogs_fatal(\"No QFI[%d] and EBI[%d]\", bearer->qfi, bearer->ebi);\n        ogs_assert_if_reached();\n    }\n    return test_gtpu_send(node, bearer, &gtp_hdesc, &ext_hdesc, pkbuf);\n}", "target": 1}
{"code": "Jsi_RC Jsi_ValueInsertArray(Jsi_Interp *interp, Jsi_Value *target, int key, Jsi_Value *val, int flags)\n{\n    if (target->vt != JSI_VT_OBJECT) {\n        if (interp->strict)\n            Jsi_LogWarn(\"Target is not object\");\n        return JSI_ERROR;\n    }\n    Jsi_Obj *obj = target->d.obj;\n    if (obj->isarrlist) {\n        if (key >= 0 && (uint)key < interp->maxArrayList) {\n            Jsi_ObjArraySet(interp, obj, val, key);\n            return JSI_OK;\n        }\n        return JSI_ERROR;\n    }\n    char unibuf[JSI_MAX_NUMBER_STRING];\n    Jsi_NumberItoA10(key, unibuf, sizeof(unibuf));\n    Jsi_ObjInsert(interp, obj, unibuf, val, flags);\n    return JSI_OK;\n}", "target": 0}
{"code": "static u32 swf_get_32(SWFReader *read)\n{\n\tu32 val, res;\n\tval = swf_read_int(read, 32);\n\tres = (val&0xFF);\n\tres <<=8;\n\tres |= ((val>>8)&0xFF);\n\tres<<=8;\n\tres |= ((val>>16)&0xFF);\n\tres<<=8;\n\tres|= ((val>>24)&0xFF);\n\treturn res;\n}", "target": 1}
{"code": "PJ_DEF(void) pj_scan_get_newline( pj_scanner *scanner )\n{\n    if (!PJ_SCAN_IS_NEWLINE(*scanner->curptr)) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    if (*scanner->curptr == '\\r') {\n\t++scanner->curptr;\n    }\n    if (*scanner->curptr == '\\n') {\n\t++scanner->curptr;\n    }\n    ++scanner->line;\n    scanner->start_line = scanner->curptr;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& grad_in = context->input(1);\n    const Tensor& argmax = context->input(2);\n    PoolParameters params{context,\n                          ksize_,\n                          stride_,\n                          padding_,\n                          {},\n                          FORMAT_NHWC,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n    TensorShape out_shape({params.tensor_in_batch, params.tensor_in_rows,\n                           params.tensor_in_cols, params.depth});\n    Tensor* grad_out = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {0}, 0, out_shape, &grad_out));\n    if (out_shape.num_elements() == 0) return;  \n    LaunchMaxPoolingGradWithArgmax<Device, T>::launch(\n        context, params, grad_in, argmax, grad_out, include_batch_in_index_);\n  }", "target": 0}
{"code": "static void drive_file_fix_path(WCHAR* path)\n{\n\tsize_t i;\n\tsize_t length = _wcslen(path);\n\tfor (i = 0; i < length; i++)\n\t{\n\t\tif (path[i] == L'\\\\')\n\t\t\tpath[i] = L'/';\n\t}\n#ifdef WIN32\n\tif ((length == 3) && (path[1] == L':') && (path[2] == L'/'))\n\t\treturn;\n#else\n\tif ((length == 1) && (path[0] == L'/'))\n\t\treturn;\n#endif\n\tif ((length > 0) && (path[length - 1] == L'/'))\n\t\tpath[length - 1] = L'\\0';\n}", "target": 1}
{"code": "de265_error decoder_context::read_pps_NAL(bitreader& reader)\n{\n  logdebug(LogHeaders,\"----> read PPS\\n\");\n  std::shared_ptr<pic_parameter_set> new_pps = std::make_shared<pic_parameter_set>();\n  bool success = new_pps->read(&reader,this);\n  if (param_pps_headers_fd>=0) {\n    new_pps->dump(param_pps_headers_fd);\n  }\n  if (success) {\n    pps[ (int)new_pps->pic_parameter_set_id ] = new_pps;\n  }\n  return success ? DE265_OK : DE265_WARNING_PPS_HEADER_INVALID;\n}", "target": 1}
{"code": "ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,\n               const char **elem_rtrn, const char **field_rtrn,\n               ExprDef **index_rtrn)\n{\n    switch (expr->expr.op) {\n    case EXPR_IDENT:\n        *elem_rtrn = NULL;\n        *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);\n        *index_rtrn = NULL;\n        return (*field_rtrn != NULL);\n    case EXPR_FIELD_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);\n        *index_rtrn = NULL;\n        return (*elem_rtrn != NULL && *field_rtrn != NULL);\n    case EXPR_ARRAY_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);\n        *index_rtrn = expr->array_ref.entry;\n\tif (expr->array_ref.element != XKB_ATOM_NONE && *elem_rtrn == NULL)\n\t\treturn false;\n\tif (*field_rtrn == NULL)\n\t\treturn false;\n        return true;\n    default:\n        break;\n    }\n    log_wsgo(ctx, \"Unexpected operator %d in ResolveLhs\\n\", expr->expr.op);\n    return false;\n}", "target": 0}
{"code": "void sw_crypto_acipher_free_rsa_keypair(struct rsa_keypair *s)\n{\n\tif (!s)\n\t\treturn;\n\tcrypto_bignum_free(s->e);\n\tcrypto_bignum_free(s->d);\n\tcrypto_bignum_free(s->n);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\tcrypto_bignum_free(s->qp);\n\tcrypto_bignum_free(s->dp);\n\tcrypto_bignum_free(s->dq);\n}", "target": 1}
{"code": "cdf_dump(void *v, size_t len)\n{\n\tsize_t i, j;\n\tunsigned char *p = v;\n\tchar abuf[16];\n\t(void)fprintf(stderr, \"%.4x: \", 0);\n\tfor (i = 0, j = 0; i < len; i++, p++) {\n\t\t(void)fprintf(stderr, \"%.2x \", *p);\n\t\tabuf[j++] = isprint(*p) ? *p : '.';\n\t\tif (j == 16) {\n\t\t\tj = 0;\n\t\t\tabuf[15] = '\\0';\n\t\t\t(void)fprintf(stderr, \"%s\\n%.4\" SIZE_T_FORMAT \"x: \",\n\t\t\t    abuf, i + 1);\n\t\t}\n\t}\n\t(void)fprintf(stderr, \"\\n\");\n}", "target": 0}
{"code": "archive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n\t(void)mode;\t\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_POSIX1E, \"posix1e\");\n\t\treturn (ret);\n\t}\n#if ARCHIVE_ACL_SUNOS_NFS4\n\telse if ((archive_acl_types(abstract_acl) &\n\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n\t}\n#endif\n\treturn (ret);\n}", "target": 1}
{"code": "static BOOL gdi_Bitmap_Decompress(rdpContext* context, rdpBitmap* bitmap,\n                                  const BYTE* pSrcData, UINT32 DstWidth, UINT32 DstHeight,\n                                  UINT32 bpp, UINT32 length, BOOL compressed,\n                                  UINT32 codecId)\n{\n\tUINT32 SrcSize = length;\n\trdpGdi* gdi = context->gdi;\n\tbitmap->compressed = FALSE;\n\tbitmap->format = gdi->dstFormat;\n\tbitmap->length = DstWidth * DstHeight * GetBytesPerPixel(bitmap->format);\n\tbitmap->data = (BYTE*) _aligned_malloc(bitmap->length, 16);\n\tif (!bitmap->data)\n\t\treturn FALSE;\n\tif (compressed)\n\t{\n\t\tif (bpp < 32)\n\t\t{\n\t\t\tif (!interleaved_decompress(context->codecs->interleaved,\n\t\t\t                            pSrcData, SrcSize,\n\t\t\t                            DstWidth, DstHeight,\n\t\t\t                            bpp,\n\t\t\t                            bitmap->data, bitmap->format,\n\t\t\t                            0, 0, 0, DstWidth, DstHeight,\n\t\t\t                            &gdi->palette))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!planar_decompress(context->codecs->planar, pSrcData, SrcSize,\n\t\t\t                       DstWidth, DstHeight,\n\t\t\t                       bitmap->data, bitmap->format, 0, 0, 0,\n\t\t\t                       DstWidth, DstHeight, TRUE))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tconst UINT32 SrcFormat = gdi_get_pixel_format(bpp);\n\t\tconst size_t sbpp = GetBytesPerPixel(SrcFormat);\n\t\tconst size_t dbpp = GetBytesPerPixel(bitmap->format);\n\t\tif ((sbpp == 0) || (dbpp == 0))\n\t\t\treturn FALSE;\n\t\telse\n\t\t{\n\t\t\tconst size_t dstSize = SrcSize * dbpp / sbpp;\n\t\t\tif (dstSize  < bitmap->length)\n\t\t\t\treturn FALSE;\n\t\t}\n\t\tif (!freerdp_image_copy(bitmap->data, bitmap->format, 0, 0, 0,\n\t\t                        DstWidth, DstHeight, pSrcData, SrcFormat,\n\t\t                        0, 0, 0, &gdi->palette, FREERDP_FLIP_VERTICAL))\n\t\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "static int scm_fp_copy(struct cmsghdr *cmsg, struct scm_fp_list **fplp)\n{\n\tint *fdp = (int*)CMSG_DATA(cmsg);\n\tstruct scm_fp_list *fpl = *fplp;\n\tstruct file **fpp;\n\tint i, num;\n\tnum = (cmsg->cmsg_len - CMSG_ALIGN(sizeof(struct cmsghdr)))/sizeof(int);\n\tif (num <= 0)\n\t\treturn 0;\n\tif (num > SCM_MAX_FD)\n\t\treturn -EINVAL;\n\tif (!fpl)\n\t{\n\t\tfpl = kmalloc(sizeof(struct scm_fp_list), GFP_KERNEL);\n\t\tif (!fpl)\n\t\t\treturn -ENOMEM;\n\t\t*fplp = fpl;\n\t\tfpl->count = 0;\n\t\tfpl->max = SCM_MAX_FD;\n\t\tfpl->user = NULL;\n\t}\n\tfpp = &fpl->fp[fpl->count];\n\tif (fpl->count + num > fpl->max)\n\t\treturn -EINVAL;\n\tfor (i=0; i< num; i++)\n\t{\n\t\tint fd = fdp[i];\n\t\tstruct file *file;\n\t\tif (fd < 0 || !(file = fget_raw(fd)))\n\t\t\treturn -EBADF;\n\t\t*fpp++ = file;\n\t\tfpl->count++;\n\t}\n\tif (!fpl->user)\n\t\tfpl->user = get_uid(current_user());\n\treturn num;\n}", "target": 0}
{"code": "static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)\n{\n\tint r;\n\tstruct kvm_vcpu *vcpu, *v;\n\tif (id >= KVM_MAX_VCPUS)\n\t\treturn -EINVAL;\n\tvcpu = kvm_arch_vcpu_create(kvm, id);\n\tif (IS_ERR(vcpu))\n\t\treturn PTR_ERR(vcpu);\n\tpreempt_notifier_init(&vcpu->preempt_notifier, &kvm_preempt_ops);\n\tr = kvm_arch_vcpu_setup(vcpu);\n\tif (r)\n\t\tgoto vcpu_destroy;\n\tmutex_lock(&kvm->lock);\n\tif (!kvm_vcpu_compatible(vcpu)) {\n\t\tr = -EINVAL;\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\tif (atomic_read(&kvm->online_vcpus) == KVM_MAX_VCPUS) {\n\t\tr = -EINVAL;\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\tkvm_for_each_vcpu(r, v, kvm)\n\t\tif (v->vcpu_id == id) {\n\t\t\tr = -EEXIST;\n\t\t\tgoto unlock_vcpu_destroy;\n\t\t}\n\tBUG_ON(kvm->vcpus[atomic_read(&kvm->online_vcpus)]);\n\tkvm_get_kvm(kvm);\n\tr = create_vcpu_fd(vcpu);\n\tif (r < 0) {\n\t\tkvm_put_kvm(kvm);\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\tkvm->vcpus[atomic_read(&kvm->online_vcpus)] = vcpu;\n\tsmp_wmb();\n\tatomic_inc(&kvm->online_vcpus);\n\tmutex_unlock(&kvm->lock);\n\tkvm_arch_vcpu_postcreate(vcpu);\n\treturn r;\nunlock_vcpu_destroy:\n\tmutex_unlock(&kvm->lock);\nvcpu_destroy:\n\tkvm_arch_vcpu_destroy(vcpu);\n\treturn r;\n}", "target": 0}
{"code": "static void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\tif (atomic_dec_and_test(&ucounts->count)) {\n\t\tspin_lock_irqsave(&ucounts_lock, flags);\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\t\tkfree(ucounts);\n\t}\n}", "target": 1}
{"code": "ssize_t enc_untrusted_read(int fd, void *buf, size_t count) {\n  return static_cast<ssize_t>(EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_read, fd, buf, count));\n}", "target": 1}
{"code": "void sas_init_disc(struct sas_discovery *disc, struct asd_sas_port *port)\n{\n\tint i;\n\tstatic const work_func_t sas_event_fns[DISC_NUM_EVENTS] = {\n\t\t[DISCE_DISCOVER_DOMAIN] = sas_discover_domain,\n\t\t[DISCE_REVALIDATE_DOMAIN] = sas_revalidate_domain,\n\t\t[DISCE_PROBE] = sas_probe_devices,\n\t\t[DISCE_SUSPEND] = sas_suspend_devices,\n\t\t[DISCE_RESUME] = sas_resume_devices,\n\t\t[DISCE_DESTRUCT] = sas_destruct_devices,\n\t};\n\tdisc->pending = 0;\n\tfor (i = 0; i < DISC_NUM_EVENTS; i++) {\n\t\tINIT_SAS_WORK(&disc->disc_work[i].work, sas_event_fns[i]);\n\t\tdisc->disc_work[i].port = port;\n\t}\n}", "target": 1}
{"code": "smb2_query_eas(const unsigned int xid, struct cifs_tcon *tcon,\n\t       const unsigned char *path, const unsigned char *ea_name,\n\t       char *ea_data, size_t buf_size,\n\t       struct cifs_sb_info *cifs_sb)\n{\n\tint rc;\n\tstruct kvec rsp_iov = {NULL, 0};\n\tint buftype = CIFS_NO_BUFFER;\n\tstruct smb2_query_info_rsp *rsp;\n\tstruct smb2_file_full_ea_info *info = NULL;\n\trc = smb2_query_info_compound(xid, tcon, path,\n\t\t\t\t      FILE_READ_EA,\n\t\t\t\t      FILE_FULL_EA_INFORMATION,\n\t\t\t\t      SMB2_O_INFO_FILE,\n\t\t\t\t      CIFSMaxBufSize -\n\t\t\t\t      MAX_SMB2_CREATE_RESPONSE_SIZE -\n\t\t\t\t      MAX_SMB2_CLOSE_RESPONSE_SIZE,\n\t\t\t\t      &rsp_iov, &buftype, cifs_sb);\n\tif (rc) {\n\t\tif (!ea_name && rc == -ENODATA)\n\t\t\trc = 0;\n\t\tgoto qeas_exit;\n\t}\n\trsp = (struct smb2_query_info_rsp *)rsp_iov.iov_base;\n\trc = smb2_validate_iov(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t       le32_to_cpu(rsp->OutputBufferLength),\n\t\t\t       &rsp_iov,\n\t\t\t       sizeof(struct smb2_file_full_ea_info));\n\tif (rc)\n\t\tgoto qeas_exit;\n\tinfo = (struct smb2_file_full_ea_info *)(\n\t\t\tle16_to_cpu(rsp->OutputBufferOffset) + (char *)rsp);\n\trc = move_smb2_ea_to_cifs(ea_data, buf_size, info,\n\t\t\tle32_to_cpu(rsp->OutputBufferLength), ea_name);\n qeas_exit:\n\tfree_rsp_buf(buftype, rsp_iov.iov_base);\n\treturn rc;\n}", "target": 0}
{"code": "path_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tPATH\t   *path;\n\tint\t\t\tisopen;\n\tchar\t   *s;\n\tint\t\t\tnpts;\n\tint\t\t\tsize;\n\tint\t\t\tdepth = 0;\n\tif ((npts = pair_count(str, ',')) <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type path: \\\"%s\\\"\", str)));\n\ts = str;\n\twhile (isspace((unsigned char) *s))\n\t\ts++;\n\tif ((*s == LDELIM) && (strrchr(s, LDELIM) == s))\n\t{\n\t\ts++;\n\t\tdepth++;\n\t}\n\tsize = offsetof(PATH, p[0]) +sizeof(path->p[0]) * npts;\n\tpath = (PATH *) palloc(size);\n\tSET_VARSIZE(path, size);\n\tpath->npts = npts;\n\tif ((!path_decode(TRUE, npts, s, &isopen, &s, &(path->p[0])))\n\t&& (!((depth == 0) && (*s == '\\0'))) && !((depth >= 1) && (*s == RDELIM)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type path: \\\"%s\\\"\", str)));\n\tpath->closed = (!isopen);\n\tpath->dummy = 0;\n\tPG_RETURN_PATH_P(path);\n}", "target": 1}
{"code": "    OVS_REQUIRES(ofproto_mutex)\n{\n    const struct rule_actions *actions = rule_get_actions(rule);\n    ovs_assert(rule->state == RULE_INITIALIZED);\n    if (rule->hard_timeout || rule->idle_timeout) {\n        ovs_list_insert(&ofproto->expirable, &rule->expirable);\n    }\n    cookies_insert(ofproto, rule);\n    eviction_group_add_rule(rule);\n    if (actions->has_meter) {\n        meter_insert_rule(rule);\n    }\n    if (actions->has_groups) {\n        const struct ofpact_group *a;\n        OFPACT_FOR_EACH_TYPE_FLATTENED (a, GROUP, actions->ofpacts,\n                                        actions->ofpacts_len) {\n            struct ofgroup *group;\n            group = ofproto_group_lookup(ofproto, a->group_id, OVS_VERSION_MAX,\n                                         false);\n            ovs_assert(group != NULL);\n            group_add_rule(group, rule);\n        }\n    }\n    rule->state = RULE_INSERTED;\n}", "target": 1}
{"code": "externalParEntProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  const char *next = s;\n  int tok;\n  tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  if (tok <= 0) {\n    if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    switch (tok) {\n    case XML_TOK_INVALID:\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      return XML_ERROR_PARTIAL_CHAR;\n    case XML_TOK_NONE: \n    default:\n      break;\n    }\n  }\n  else if (tok == XML_TOK_BOM) {\n    s = next;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  }\n  parser->m_processor = prologProcessor;\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n}", "target": 1}
{"code": "static void cil_reset_classpermission(struct cil_classpermission *cp)\n{\n\tif (cp == NULL) {\n\t\treturn;\n\t}\n\tcil_reset_classperms_list(cp->classperms);\n}", "target": 1}
{"code": "int quicklistPushTail(quicklist *quicklist, void *value, size_t sz) {\n    quicklistNode *orig_tail = quicklist->tail;\n    assert(sz < UINT32_MAX); \n    if (likely(\n            _quicklistNodeAllowInsert(quicklist->tail, quicklist->fill, sz))) {\n        quicklist->tail->zl =\n            ziplistPush(quicklist->tail->zl, value, sz, ZIPLIST_TAIL);\n        quicklistNodeUpdateSz(quicklist->tail);\n    } else {\n        quicklistNode *node = quicklistCreateNode();\n        node->zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_TAIL);\n        quicklistNodeUpdateSz(node);\n        _quicklistInsertNodeAfter(quicklist, quicklist->tail, node);\n    }\n    quicklist->count++;\n    quicklist->tail->count++;\n    return (orig_tail != quicklist->tail);\n}", "target": 0}
{"code": "static void clear_evtchn_to_irq_row(unsigned row)\n{\n\tunsigned col;\n\tfor (col = 0; col < EVTCHN_PER_ROW; col++)\n\t\tevtchn_to_irq[row][col] = -1;\n}", "target": 1}
{"code": "static void tight_send_compact_size(VncState *vs, size_t len)\n{\n    int lpc = 0;\n    int bytes = 0;\n    char buf[3] = {0, 0, 0};\n    buf[bytes++] = len & 0x7F;\n    if (len > 0x7F) {\n        buf[bytes-1] |= 0x80;\n        buf[bytes++] = (len >> 7) & 0x7F;\n        if (len > 0x3FFF) {\n            buf[bytes-1] |= 0x80;\n            buf[bytes++] = (len >> 14) & 0xFF;\n        }\n    }\n    for (lpc = 0; lpc < bytes; lpc++) {\n        vnc_write_u8(vs, buf[lpc]);\n    }\n}", "target": 0}
{"code": "int lstat_cache_aware_rmdir(const char *path)\n{\n\tint ret = rmdir(path);\n\tif (!ret)\n\t\tinvalidate_lstat_cache();\n\treturn ret;\n}", "target": 0}
{"code": "static void php_array_merge_recursive(PointerSet &seen, bool check,\n                                      Array &arr1, const Array& arr2) {\n  if (check && !seen.insert((void*)arr1.get()).second) {\n    raise_warning(\"array_merge_recursive(): recursion detected\");\n    return;\n  }\n  for (ArrayIter iter(arr2); iter; ++iter) {\n    Variant key(iter.first());\n    const Variant& value(iter.secondRef());\n    if (key.isNumeric()) {\n      arr1.appendWithRef(value);\n    } else if (arr1.exists(key, true)) {\n      Variant &v = arr1.lvalAt(key, AccessFlags::Key);\n      auto subarr1 = v.toArray().copy();\n      php_array_merge_recursive(seen,\n                                couldRecur(v, subarr1.get()),\n                                subarr1,\n                                value.toArray());\n      v.unset(); \n      v = subarr1;\n    } else {\n      arr1.setWithRef(key, value, true);\n    }\n  }\n  if (check) {\n    seen.erase((void*)arr1.get());\n  }\n}", "target": 0}
{"code": "void FormatConverter<T>::InitSparseToDenseConverter(\n    std::vector<int> shape, std::vector<int> traversal_order,\n    std::vector<TfLiteDimensionType> format, std::vector<int> dense_size,\n    std::vector<std::vector<int>> segments,\n    std::vector<std::vector<int>> indices, std::vector<int> block_map) {\n  dense_shape_ = std::move(shape);\n  traversal_order_ = std::move(traversal_order);\n  block_map_ = std::move(block_map);\n  format_ = std::move(format);\n  dense_size_ = 1;\n  for (int i = 0; i < dense_shape_.size(); i++) {\n    dense_size_ *= dense_shape_[i];\n  }\n  dim_metadata_.resize(2 * format_.size());\n  for (int i = 0; i < format_.size(); i++) {\n    if (format_[i] == kTfLiteDimDense) {\n      dim_metadata_[2 * i] = {dense_size[i]};\n    } else {\n      dim_metadata_[2 * i] = std::move(segments[i]);\n      dim_metadata_[2 * i + 1] = std::move(indices[i]);\n    }\n  }\n  int original_rank = dense_shape_.size();\n  int block_dim = 0;\n  blocked_shape_.resize(original_rank);\n  block_size_.resize(block_map_.size());\n  for (int i = 0; i < original_rank; i++) {\n    if (block_dim < block_map_.size() && block_map_[block_dim] == i) {\n      int orig_dim = traversal_order_[original_rank + block_dim];\n      block_size_[block_dim] = dense_size[orig_dim];\n      blocked_shape_[i] = dense_shape_[i] / dense_size[orig_dim];\n      block_dim++;\n    } else {\n      blocked_shape_[i] = dense_shape_[i];\n    }\n  }\n}", "target": 1}
{"code": "error::Error GLES2DecoderImpl::GetAttribLocationHelper(\n    GLuint client_id, uint32 location_shm_id, uint32 location_shm_offset,\n    const std::string& name_str) {\n  if (!StringIsValidForGLES(name_str.c_str())) {\n    SetGLError(GL_INVALID_VALUE, \"glGetAttribLocation: Invalid character\");\n    return error::kNoError;\n  }\n  ProgramManager::ProgramInfo* info = GetProgramInfoNotShader(\n      client_id, \"glGetAttribLocation\");\n  if (!info) {\n    return error::kNoError;\n  }\n  if (!info->IsValid()) {\n    SetGLError(GL_INVALID_OPERATION, \"glGetAttribLocation: program not linked\");\n    return error::kNoError;\n  }\n  GLint* location = GetSharedMemoryAs<GLint*>(\n      location_shm_id, location_shm_offset, sizeof(GLint));\n  if (!location) {\n    return error::kOutOfBounds;\n  }\n  if (*location != -1) {\n    return error::kGenericError;\n  }\n  *location = info->GetAttribLocation(name_str);\n  return error::kNoError;\n}", "target": 0}
{"code": "void ion_free(struct ion_client *client, struct ion_handle *handle)\n{\n\tbool valid_handle;\n\tBUG_ON(client != handle->client);\n\tmutex_lock(&client->lock);\n\tvalid_handle = ion_handle_validate(client, handle);\n\tif (!valid_handle) {\n\t\tWARN(1, \"%s: invalid handle passed to free.\\n\", __func__);\n\t\tmutex_unlock(&client->lock);\n\t\treturn;\n\t}\n\tmutex_unlock(&client->lock);\n\tion_handle_put(handle);\n}", "target": 1}
{"code": "hb_set_union (hb_set_t       *set,\n\t      const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->union_ (*other);\n}", "target": 1}
{"code": "static int skcipher_setkey_unaligned(struct crypto_skcipher *tfm,\n\t\t\t\t     const u8 *key, unsigned int keylen)\n{\n\tunsigned long alignmask = crypto_skcipher_alignmask(tfm);\n\tstruct skcipher_alg *cipher = crypto_skcipher_alg(tfm);\n\tu8 *buffer, *alignbuffer;\n\tunsigned long absize;\n\tint ret;\n\tabsize = keylen + alignmask;\n\tbuffer = kmalloc(absize, GFP_ATOMIC);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\talignbuffer = (u8 *)ALIGN((unsigned long)buffer, alignmask + 1);\n\tmemcpy(alignbuffer, key, keylen);\n\tret = cipher->setkey(tfm, alignbuffer, keylen);\n\tkzfree(buffer);\n\treturn ret;\n}", "target": 0}
{"code": "String UnbufferedAsioTlsStream::GetVerifyError() const\n{\n\treturn m_VerifyError;\n}", "target": 1}
{"code": "static int snd_ctl_elem_read(struct snd_card *card,\n\t\t\t     struct snd_ctl_elem_value *control)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tstruct snd_ctl_elem_info info;\n\tconst u32 pattern = 0xdeadbeef;\n\tint ret;\n\tkctl = snd_ctl_find_id(card, &control->id);\n\tif (kctl == NULL)\n\t\treturn -ENOENT;\n\tindex_offset = snd_ctl_get_ioff(kctl, &control->id);\n\tvd = &kctl->vd[index_offset];\n\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_READ) || kctl->get == NULL)\n\t\treturn -EPERM;\n\tsnd_ctl_build_ioff(&control->id, kctl, index_offset);\n#ifdef CONFIG_SND_CTL_DEBUG\n\tmemset(&info, 0, sizeof(info));\n\tinfo.id = control->id;\n\tret = __snd_ctl_elem_info(card, kctl, &info, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n#endif\n\tif (!snd_ctl_skip_validation(&info))\n\t\tfill_remaining_elem_value(control, &info, pattern);\n\tret = snd_power_ref_and_wait(card);\n\tif (!ret)\n\t\tret = kctl->get(kctl, control);\n\tsnd_power_unref(card);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!snd_ctl_skip_validation(&info) &&\n\t    sanity_check_elem_value(card, control, &info, pattern) < 0) {\n\t\tdev_err(card->dev,\n\t\t\t\"control %i:%i:%i:%s:%i: access overflow\\n\",\n\t\t\tcontrol->id.iface, control->id.device,\n\t\t\tcontrol->id.subdevice, control->id.name,\n\t\t\tcontrol->id.index);\n\t\treturn -EINVAL;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "void btrfs_trans_release_chunk_metadata(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tif (!trans->chunk_bytes_reserved)\n\t\treturn;\n\tWARN_ON_ONCE(!list_empty(&trans->new_bgs));\n\tbtrfs_block_rsv_release(fs_info, &fs_info->chunk_block_rsv,\n\t\t\t\ttrans->chunk_bytes_reserved, NULL);\n\tatomic64_sub(trans->chunk_bytes_reserved, &cur_trans->chunk_bytes_reserved);\n\tcond_wake_up(&cur_trans->chunk_reserve_wait);\n\ttrans->chunk_bytes_reserved = 0;\n}", "target": 1}
{"code": "  Status FillCollectiveParams(CollectiveParams* col_params,\n                              CollectiveType collective_type,\n                              const Tensor& group_size, const Tensor& group_key,\n                              const Tensor& instance_key) {\n    if (group_size.dims() > 0) {\n      return errors::Internal(\"Unexpected dimensions on input group_size, got \",\n                              group_size.shape().DebugString());\n    }\n    if (group_key.dims() > 0) {\n      return errors::Internal(\"Unexpected dimensions on input group_key, got \",\n                              group_key.shape().DebugString());\n    }\n    if (instance_key.dims() > 0) {\n      return errors::Internal(\n          \"Unexpected dimensions on input instance_key, got \",\n          instance_key.shape().DebugString());\n    }\n    col_params->name = name_;\n    col_params->group.device_type = device_type_;\n    col_params->group.group_size = group_size.unaligned_flat<int32>()(0);\n    if (col_params->group.group_size <= 0) {\n      return errors::InvalidArgument(\n          \"group_size must be positive integer but got \",\n          col_params->group.group_size);\n    }\n    col_params->group.group_key = group_key.unaligned_flat<int32>()(0);\n    col_params->instance.type = collective_type;\n    col_params->instance.instance_key = instance_key.unaligned_flat<int32>()(0);\n    col_params->instance.data_type = data_type_;\n    col_params->instance.impl_details.communication_hint = communication_hint_;\n    col_params->instance.impl_details.timeout_seconds = timeout_seconds_;\n    return Status::OK();\n  }", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    CHECK_EQ(4, context->num_inputs());\n    const Tensor& gradient = context->input(0);\n    const Tensor& input = context->input(1);\n    OP_REQUIRES(context, input.IsSameSize(gradient),\n                InvalidArgument(\"gradient and input must be the same size\"));\n    const int depth = input.dim_size(input.dims() - 1);  \n    const Tensor& min = context->input(2);\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsVector(min.shape()),\n        InvalidArgument(\"`min` must be rank 1 but is rank \", min.dims()));\n    OP_REQUIRES(context, min.dim_size(0) == depth,\n                InvalidArgument(\"min has incorrect size, expected \", depth,\n                                \" was \", min.dim_size(0)));\n    const Tensor& max = context->input(3);\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsVector(max.shape()),\n        InvalidArgument(\"`max` must be rank 1 but is rank \", max.dims()));\n    OP_REQUIRES(context, max.dim_size(0) == depth,\n                InvalidArgument(\"max has incorrect size, expected \", depth,\n                                \" was \", max.dim_size(0)));\n    Tensor* grad_wrt_input;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input.shape(), &grad_wrt_input));\n    TensorShape min_max_shape({input.dim_size(input.dims() - 1)});\n    Tensor* grad_wrt_min;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(1, min_max_shape, &grad_wrt_min));\n    Tensor* grad_wrt_max;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(2, min_max_shape, &grad_wrt_max));\n    FakeQuantWithMinMaxVarsPerChannelGradientFunctor<Device> functor;\n    functor(\n        context->eigen_device<Device>(), gradient.flat_inner_dims<float, 2>(),\n        input.flat_inner_dims<float, 2>(), min.vec<float>(), max.vec<float>(),\n        quant_min_, quant_max_, grad_wrt_input->flat_inner_dims<float, 2>(),\n        grad_wrt_min->vec<float>(), grad_wrt_max->vec<float>());\n  }", "target": 0}
{"code": "static gboolean key_value_ok(gchar *key, gchar *value)\n{\n    char *i;\n    for (i = key; *i != 0; i++)\n    {\n        if (!isalpha(*i) && (*i != '-') && (*i != '_') && (*i != ' '))\n            return FALSE;\n    }\n    if (strcmp(key, \"basename\") == 0\n     || strcmp(key, FILENAME_TYPE) == 0\n    )\n    {\n        if (!str_is_correct_filename(value))\n        {\n            error_msg(\"Value of '%s' ('%s') is not a valid directory name\",\n                      key, value);\n            return FALSE;\n        }\n    }\n    return allowed_new_user_problem_entry(client_uid, key, value);\n}", "target": 0}
{"code": "void user_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \": %u\", key->datalen);\n}", "target": 1}
{"code": "static struct sk_buff **sit_gro_receive(struct sk_buff **head,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tif (NAPI_GRO_CB(skb)->encap_mark) {\n\t\tNAPI_GRO_CB(skb)->flush = 1;\n\t\treturn NULL;\n\t}\n\tNAPI_GRO_CB(skb)->encap_mark = 1;\n\treturn ipv6_gro_receive(head, skb);\n}", "target": 0}
{"code": "static void __exit adpt_exit(void)\n{\n\tadpt_hba\t*pHba, *next;\n\tfor (pHba = hba_chain; pHba; pHba = next) {\n\t\tnext = pHba->next;\n\t\tadpt_release(pHba);\n\t}\n}", "target": 1}
{"code": "static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag,\n                                     uint32_t lun, void *hba_private)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n    SCSIRequest *req;\n    SCSIDiskReq *r;\n    req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun, hba_private);\n    r = DO_UPCAST(SCSIDiskReq, req, req);\n    r->iov.iov_base = qemu_blockalign(s->bs, SCSI_DMA_BUF_SIZE);\n    return req;\n}", "target": 1}
{"code": "static void smb_set_posix_lock_done(struct tevent_req *subreq)\n{\n\tstruct smb_request *req = NULL;\n\tNTSTATUS status;\n\tbool ok;\n\tok = smbd_smb1_do_locks_extract_smbreq(subreq, talloc_tos(), &req);\n\tSMB_ASSERT(ok);\n\tstatus = smbd_smb1_do_locks_recv(subreq);\n\tTALLOC_FREE(subreq);\n\tif (NT_STATUS_IS_OK(status)) {\n\t\tchar params[2] = {0};\n\t\tsend_trans2_replies(\n\t\t\treq->conn,\n\t\t\treq,\n\t\t\tNT_STATUS_OK,\n\t\t\tparams,\n\t\t\t2,\n\t\t\tNULL,\n\t\t\t0,\n\t\t\t0xffff);\n\t} else {\n\t\treply_nterror(req, status);\n\t\tok = srv_send_smb(\n\t\t\treq->xconn,\n\t\t\t(char *)req->outbuf,\n\t\t\ttrue,\n\t\t\treq->seqnum+1,\n\t\t\tIS_CONN_ENCRYPTED(req->conn),\n\t\t\tNULL);\n\t\tif (!ok) {\n\t\t\texit_server_cleanly(\"smb_set_posix_lock_done: \"\n\t\t\t\t\t    \"srv_send_smb failed.\");\n\t\t}\n\t}\n\tTALLOC_FREE(req);\n\treturn;\n}", "target": 0}
{"code": "static int proc_cwd_link(struct dentry *dentry, struct path *path)\n{\n\tstruct task_struct *task = get_proc_task(dentry->d_inode);\n\tint result = -ENOENT;\n\tif (task) {\n\t\ttask_lock(task);\n\t\tif (task->fs) {\n\t\t\tget_fs_pwd(task->fs, path);\n\t\t\tresult = 0;\n\t\t}\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t}\n\treturn result;\n}", "target": 0}
{"code": "StatusOr<FullTypeDef> SpecializeType(const AttrSlice& attrs,\n                                     const OpDef& op_def) {\n  FullTypeDef ft;\n  ft.set_type_id(TFT_PRODUCT);\n  for (int i = 0; i < op_def.output_arg_size(); i++) {\n    auto* t = ft.add_args();\n    *t = op_def.output_arg(i).experimental_full_type();\n    for (int j = 0; j < t->args_size(); j++) {\n      auto* arg = t->mutable_args(j);\n      if (arg->type_id() == TFT_VAR) {\n        const auto* attr = attrs.Find(arg->s());\n        if (attr == nullptr) {\n          return Status(\n              error::INVALID_ARGUMENT,\n              absl::StrCat(\"Could not find an attribute for key \", arg->s()));\n        }\n        if (attr->value_case() == AttrValue::kList) {\n          const auto& attr_list = attr->list();\n          arg->set_type_id(TFT_PRODUCT);\n          for (int i = 0; i < attr_list.type_size(); i++) {\n            map_dtype_to_tensor(attr_list.type(i), arg->add_args());\n          }\n        } else if (attr->value_case() == AttrValue::kType) {\n          map_dtype_to_tensor(attr->type(), arg);\n        } else {\n          return Status(error::UNIMPLEMENTED,\n                        absl::StrCat(\"unknown attribute type\",\n                                     attrs.DebugString(), \" key=\", arg->s()));\n        }\n        arg->clear_s();\n      }\n    }\n  }\n  return ft;\n}", "target": 0}
{"code": "bool Url::Decode(string_view encoded, std::string* raw) {\n  for (auto iter = encoded.begin(); iter != encoded.end(); ++iter) {\n    if (*iter == '%') {\n      if (++iter == encoded.end()) {\n        return false;\n      }\n      int h_decimal = 0;\n      if (!HexToDecimal(*iter, &h_decimal)) {\n        return false;\n      }\n      if (++iter == encoded.end()) {\n        return false;\n      }\n      int l_decimal = 0;\n      if (!HexToDecimal(*iter, &l_decimal)) {\n        return false;\n      }\n      raw->push_back(static_cast<char>((h_decimal << 4) + l_decimal));\n    } else if (*iter > 127 || *iter < 0) {\n      return false;\n    } else {\n      raw->push_back(*iter);\n    }\n  }\n  return true;\n}", "target": 0}
{"code": "static void sanitize_string(char *s, char *new) {\n\tsize_t i,j, l = strlen(s), ls=l;\n\tfor(i=0,j=0;i<ls;i++) {\n\t\tif(s[i] < ' ' || s[i] > 127) {\n\t\t\tsprintf(new + j, \"\\\\x%02x\", s[i] & 0xff);\n\t\t\tj  += 3;\n\t\t} else new[j] = s[i];\n\t\tj++;\n\t}\n\tnew[j] = 0;\n}", "target": 0}
{"code": "static void *adpt_ioctl_from_context(adpt_hba *pHba, u32 context)\n{\n#if BITS_PER_LONG == 32\n\treturn (void *)(unsigned long)context;\n#else\n\tvoid *p = pHba->ioctl_reply_context[context];\n\tpHba->ioctl_reply_context[context] = NULL;\n\treturn p;\n#endif\n}", "target": 1}
{"code": "static int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tstruct sk_buff *supp_skb;\n\tif (hdr->sadb_msg_satype > SADB_SATYPE_MAX)\n\t\treturn -EINVAL;\n\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) {\n\t\tif (pfk->registered&(1<<hdr->sadb_msg_satype))\n\t\t\treturn -EEXIST;\n\t\tpfk->registered |= (1<<hdr->sadb_msg_satype);\n\t}\n\txfrm_probe_algs();\n\tsupp_skb = compose_sadb_supported(hdr, GFP_KERNEL);\n\tif (!supp_skb) {\n\t\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC)\n\t\t\tpfk->registered &= ~(1<<hdr->sadb_msg_satype);\n\t\treturn -ENOBUFS;\n\t}\n\tpfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk,\n\t\t\tsock_net(sk));\n\treturn 0;\n}", "target": 1}
{"code": "__global__ void UnsortedSegmentCustomKernel(const Index input_outer_dim_size,\n                                            const Index inner_dim_size,\n                                            const Index output_outer_dim_size,\n                                            const Index* segment_ids,\n                                            const T* input, T* output) {\n  const Index input_total_size = input_outer_dim_size * inner_dim_size;\n  const Index output_total_size = output_outer_dim_size * inner_dim_size;\n  for (int input_index : GpuGridRangeX(input_total_size)) {\n    const Index input_segment_index = input_index / inner_dim_size;\n    const Index segment_offset = input_index % inner_dim_size;\n    const Index output_segment_index = segment_ids[input_segment_index];\n    if (output_segment_index < 0 || output_segment_index >= output_total_size) {\n      continue;\n    }\n    const Index output_index =\n        output_segment_index * inner_dim_size + segment_offset;\n    KernelReductionFunctor()(output + output_index, ldg(input + input_index));\n  }\n}", "target": 1}
{"code": "static int check_submodule_url(const char *url)\n{\n\tconst char *curl_url;\n\tif (looks_like_command_line_option(url))\n\t\treturn -1;\n\tif (submodule_url_is_relative(url)) {\n\t\tchar *decoded = url_decode(url);\n\t\tint has_nl = !!strchr(decoded, '\\n');\n\t\tfree(decoded);\n\t\tif (has_nl)\n\t\t\treturn -1;\n\t}\n\telse if (url_to_curl_url(url, &curl_url)) {\n\t\tstruct credential c = CREDENTIAL_INIT;\n\t\tint ret = credential_from_url_gently(&c, curl_url, 1);\n\t\tcredential_clear(&c);\n\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "lyd_new_anydata(struct lyd_node *parent, const struct lys_module *module, const char *name,\n                void *value, LYD_ANYDATA_VALUETYPE value_type)\n{\n    const struct lys_node *siblings, *snode;\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n    siblings = lyd_new_find_schema(parent, module, 0);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_ANYDATA, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n    return lyd_create_anydata(parent, snode, value, value_type);\n}", "target": 1}
{"code": "get_word_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n    *ptr++ = rescale[temp];\n  }\n  return 1;\n}", "target": 1}
{"code": "static int do_anonymous_page(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, pte_t *page_table, pmd_t *pmd,\n\t\tunsigned int flags)\n{\n\tstruct mem_cgroup *memcg;\n\tstruct page *page;\n\tspinlock_t *ptl;\n\tpte_t entry;\n\tpte_unmap(page_table);\n\tif (vma->vm_flags & VM_SHARED)\n\t\treturn VM_FAULT_SIGBUS;\n\tif (check_stack_guard_page(vma, address) < 0)\n\t\treturn VM_FAULT_SIGSEGV;\n\tif (!(flags & FAULT_FLAG_WRITE) && !mm_forbids_zeropage(mm)) {\n\t\tentry = pte_mkspecial(pfn_pte(my_zero_pfn(address),\n\t\t\t\t\t\tvma->vm_page_prot));\n\t\tpage_table = pte_offset_map_lock(mm, pmd, address, &ptl);\n\t\tif (!pte_none(*page_table))\n\t\t\tgoto unlock;\n\t\tgoto setpte;\n\t}\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\tgoto oom;\n\tpage = alloc_zeroed_user_highpage_movable(vma, address);\n\tif (!page)\n\t\tgoto oom;\n\tif (mem_cgroup_try_charge(page, mm, GFP_KERNEL, &memcg))\n\t\tgoto oom_free_page;\n\t__SetPageUptodate(page);\n\tentry = mk_pte(page, vma->vm_page_prot);\n\tif (vma->vm_flags & VM_WRITE)\n\t\tentry = pte_mkwrite(pte_mkdirty(entry));\n\tpage_table = pte_offset_map_lock(mm, pmd, address, &ptl);\n\tif (!pte_none(*page_table))\n\t\tgoto release;\n\tinc_mm_counter_fast(mm, MM_ANONPAGES);\n\tpage_add_new_anon_rmap(page, vma, address);\n\tmem_cgroup_commit_charge(page, memcg, false);\n\tlru_cache_add_active_or_unevictable(page, vma);\nsetpte:\n\tset_pte_at(mm, address, page_table, entry);\n\tupdate_mmu_cache(vma, address, page_table);\nunlock:\n\tpte_unmap_unlock(page_table, ptl);\n\treturn 0;\nrelease:\n\tmem_cgroup_cancel_charge(page, memcg);\n\tpage_cache_release(page);\n\tgoto unlock;\noom_free_page:\n\tpage_cache_release(page);\noom:\n\treturn VM_FAULT_OOM;\n}", "target": 0}
{"code": "ut64 MACH0_(get_baddr)(struct MACH0_(obj_t)* bin) {\n\tint i;\n\tif (bin->hdr.filetype != MH_EXECUTE && bin->hdr.filetype != MH_DYLINKER)\n\t\treturn 0;\n\tfor (i = 0; i < bin->nsegs; ++i)\n\t\tif (bin->segs[i].fileoff == 0 && bin->segs[i].filesize != 0)\n\t\t\treturn bin->segs[i].vmaddr;\n\treturn 0;\n}", "target": 1}
{"code": "static inline void get_page(struct page *page)\n{\n\tpage = compound_head(page);\n\tVM_BUG_ON_PAGE(page_ref_count(page) <= 0, page);\n\tpage_ref_inc(page);\n}", "target": 1}
{"code": "struct crypto_template *crypto_lookup_template(const char *name)\n{\n\treturn try_then_request_module(__crypto_lookup_template(name), \"%s\",\n\t\t\t\t       name);\n}", "target": 1}
{"code": "ebt_check_watcher(struct ebt_entry_watcher *w, struct xt_tgchk_param *par,\n\t\t  unsigned int *cnt)\n{\n\tconst struct ebt_entry *e = par->entryinfo;\n\tstruct xt_target *watcher;\n\tsize_t left = ((char *)e + e->target_offset) - (char *)w;\n\tint ret;\n\tif (left < sizeof(struct ebt_entry_watcher) ||\n\t   left - sizeof(struct ebt_entry_watcher) < w->watcher_size)\n\t\treturn -EINVAL;\n\twatcher = xt_request_find_target(NFPROTO_BRIDGE, w->u.name, 0);\n\tif (IS_ERR(watcher))\n\t\treturn PTR_ERR(watcher);\n\tw->u.watcher = watcher;\n\tpar->target   = watcher;\n\tpar->targinfo = w->data;\n\tret = xt_check_target(par, w->watcher_size,\n\t      e->ethproto, e->invflags & EBT_IPROTO);\n\tif (ret < 0) {\n\t\tmodule_put(watcher->me);\n\t\treturn ret;\n\t}\n\t(*cnt)++;\n\treturn 0;\n}", "target": 0}
{"code": "static void dnsserver_reload_zones(struct dnsserver_state *dsstate)\n{\n\tstruct dnsserver_partition *p;\n\tstruct dnsserver_zone *zones, *z, *znext, *zmatch;\n\tstruct dnsserver_zone *old_list, *new_list;\n\told_list = dsstate->zones;\n\tnew_list = NULL;\n\tfor (p = dsstate->partitions; p; p = p->next) {\n\t\tzones = dnsserver_db_enumerate_zones(dsstate, dsstate->samdb, p);\n\t\tif (zones == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (z = zones; z; ) {\n\t\t\tznext = z->next;\n\t\t\tzmatch = dnsserver_find_zone(old_list, z->name);\n\t\t\tif (zmatch == NULL) {\n\t\t\t\tz->zoneinfo = dnsserver_init_zoneinfo(z, dsstate->serverinfo);\n\t\t\t\tif (z->zoneinfo == NULL) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tDLIST_ADD_END(new_list, z);\n\t\t\t\tp->zones_count++;\n\t\t\t\tdsstate->zones_count++;\n\t\t\t} else {\n\t\t\t\ttalloc_free(z);\n\t\t\t\tDLIST_REMOVE(old_list, zmatch);\n\t\t\t\tDLIST_ADD_END(new_list, zmatch);\n\t\t\t}\n\t\t\tz = znext;\n\t\t}\n\t}\n\tif (new_list == NULL) {\n\t\treturn;\n\t}\n\tfor (z = old_list; z; ) {\n\t\tznext = z->next;\n\t\tz->partition->zones_count--;\n\t\tdsstate->zones_count--;\n\t\ttalloc_free(z);\n\t\tz = znext;\n\t}\n\tdsstate->zones = new_list;\n}", "target": 0}
{"code": "SYSCALL_DEFINE1(timer_getoverrun, timer_t, timer_id)\n{\n\tstruct k_itimer *timr;\n\tint overrun;\n\tunsigned long flags;\n\ttimr = lock_timer(timer_id, &flags);\n\tif (!timr)\n\t\treturn -EINVAL;\n\toverrun = timr->it_overrun_last;\n\tunlock_timer(timr, flags);\n\treturn overrun;\n}", "target": 1}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_synthetic_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 0;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\toffset += 6;\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_SYNTHETIC_ATTR;\n\tattr->size = offset;\n\treturn attr;\n}", "target": 1}
{"code": "static int bnep_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tstruct bnep_connlist_req cl;\n\tstruct bnep_connadd_req  ca;\n\tstruct bnep_conndel_req  cd;\n\tstruct bnep_conninfo ci;\n\tstruct socket *nsock;\n\tvoid __user *argp = (void __user *)arg;\n\tint err;\n\tBT_DBG(\"cmd %x arg %lx\", cmd, arg);\n\tswitch (cmd) {\n\tcase BNEPCONNADD:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EACCES;\n\t\tif (copy_from_user(&ca, argp, sizeof(ca)))\n\t\t\treturn -EFAULT;\n\t\tnsock = sockfd_lookup(ca.sock, &err);\n\t\tif (!nsock)\n\t\t\treturn err;\n\t\tif (nsock->sk->sk_state != BT_CONNECTED) {\n\t\t\tsockfd_put(nsock);\n\t\t\treturn -EBADFD;\n\t\t}\n\t\tca.device[sizeof(ca.device)-1] = 0;\n\t\terr = bnep_add_connection(&ca, nsock);\n\t\tif (!err) {\n\t\t\tif (copy_to_user(argp, &ca, sizeof(ca)))\n\t\t\t\terr = -EFAULT;\n\t\t} else\n\t\t\tsockfd_put(nsock);\n\t\treturn err;\n\tcase BNEPCONNDEL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EACCES;\n\t\tif (copy_from_user(&cd, argp, sizeof(cd)))\n\t\t\treturn -EFAULT;\n\t\treturn bnep_del_connection(&cd);\n\tcase BNEPGETCONNLIST:\n\t\tif (copy_from_user(&cl, argp, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\t\tif (cl.cnum <= 0)\n\t\t\treturn -EINVAL;\n\t\terr = bnep_get_connlist(&cl);\n\t\tif (!err && copy_to_user(argp, &cl, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\t\treturn err;\n\tcase BNEPGETCONNINFO:\n\t\tif (copy_from_user(&ci, argp, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\t\terr = bnep_get_conninfo(&ci);\n\t\tif (!err && copy_to_user(argp, &ci, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\t\treturn err;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static long btrfs_ioctl_qgroup_assign(struct file *file, void __user *arg)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tstruct btrfs_ioctl_qgroup_assign_args *sa;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\tint err;\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tret = mnt_want_write_file(file);\n\tif (ret)\n\t\treturn ret;\n\tsa = memdup_user(arg, sizeof(*sa));\n\tif (IS_ERR(sa)) {\n\t\tret = PTR_ERR(sa);\n\t\tgoto drop_write;\n\t}\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans)) {\n\t\tret = PTR_ERR(trans);\n\t\tgoto out;\n\t}\n\tif (sa->assign) {\n\t\tret = btrfs_add_qgroup_relation(trans, sa->src, sa->dst);\n\t} else {\n\t\tret = btrfs_del_qgroup_relation(trans, sa->src, sa->dst);\n\t}\n\tmutex_lock(&fs_info->qgroup_ioctl_lock);\n\terr = btrfs_run_qgroups(trans);\n\tmutex_unlock(&fs_info->qgroup_ioctl_lock);\n\tif (err < 0)\n\t\tbtrfs_handle_fs_error(fs_info, err,\n\t\t\t\t      \"failed to update qgroup status and info\");\n\terr = btrfs_end_transaction(trans);\n\tif (err && !ret)\n\t\tret = err;\nout:\n\tkfree(sa);\ndrop_write:\n\tmnt_drop_write_file(file);\n\treturn ret;\n}", "target": 0}
{"code": "GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>\"\n\t\t\"</u:%sResponse>\";\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * int_ip, * int_port, * rem_host, * rem_port, * protocol;\n\tint opt=0;\n\tunsigned short iport, rport;\n\tif (GETFLAG(IPV6FCFWDISABLEDMASK))\n\t{\n\t\tSoapError(h, 702, \"FirewallDisabled\");\n\t\treturn;\n\t}\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tint_ip = GetValueFromNameValueList(&data, \"InternalClient\");\n\tint_port = GetValueFromNameValueList(&data, \"InternalPort\");\n\trem_host = GetValueFromNameValueList(&data, \"RemoteHost\");\n\trem_port = GetValueFromNameValueList(&data, \"RemotePort\");\n\tprotocol = GetValueFromNameValueList(&data, \"Protocol\");\n\tif (!int_port || !rem_port || !protocol)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\trport = (unsigned short)atoi(rem_port);\n\tiport = (unsigned short)atoi(int_port);\n\tsyslog(LOG_INFO, \"%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s\", action, int_ip, iport,rem_host, rport, protocol);\n\tr = -1;\n\tswitch(r)\n\t{\n\t\tcase 1:\t\n\t\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t                   action, ns,\n\t\t\t                   opt, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t\tbreak;\n\t\tcase -5:\t\n\t\t\tSoapError(h, 705, \"ProtocolNotSupported\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSoapError(h, 501, \"ActionFailed\");\n\t}\n\tClearNameValueList(&data);\n}", "target": 0}
{"code": "dump_dest_constraint_hop(const struct dest_constraint_hop *dch)\n{\n\tu_int i;\n\tchar *fp;\n\tdebug_f(\"user %s hostname %s is_ca %d nkeys %u\",\n\t    dch->user == NULL ? \"(null)\" : dch->user,\n\t    dch->hostname == NULL ? \"(null)\" : dch->hostname,\n\t    dch->is_ca, dch->nkeys);\n\tfor (i = 0; i < dch->nkeys; i++) {\n\t\tfp = NULL;\n\t\tif (dch->keys[i] != NULL &&\n\t\t    (fp = sshkey_fingerprint(dch->keys[i],\n\t\t    SSH_FP_HASH_DEFAULT, SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal_f(\"fingerprint failed\");\n\t\tdebug_f(\"key %u/%u: %s%s%s key_is_ca %d\", i, dch->nkeys,\n\t\t    dch->keys[i] == NULL ? \"\" : sshkey_ssh_name(dch->keys[i]),\n\t\t    dch->keys[i] == NULL ? \"\" : \" \",\n\t\t    dch->keys[i] == NULL ? \"none\" : fp,\n\t\t    dch->key_is_ca[i]);\n\t\tfree(fp);\n\t}\n}", "target": 0}
{"code": "std::pair<Function *, Function *> ESTreeIRGen::doLazyFunction(\n    hbc::LazyCompilationData *lazyData) {\n  Function *topLevel = Builder.createTopLevelFunction(lazyData->strictMode, {});\n  FunctionContext topLevelFunctionContext{this, topLevel, nullptr};\n  llvh::SaveAndRestore<FunctionContext *> saveTopLevelContext(\n      topLevelContext, &topLevelFunctionContext);\n  auto *node = cast<ESTree::FunctionLikeNode>(Root);\n  lexicalScopeChain = lazyData->parentScope;\n  materializeScopesInChain(\n      topLevel, lexicalScopeChain, getDepth(lexicalScopeChain) - 1);\n  Variable *parentVar = nullptr;\n  if (lazyData->closureAlias.isValid()) {\n    assert(lazyData->originalName.isValid() && \"Original name invalid\");\n    assert(\n        lazyData->originalName != lazyData->closureAlias &&\n        \"Original name must be different from the alias\");\n    parentVar = cast<Variable>(nameTable_.lookup(lazyData->closureAlias));\n    nameTable_.insert(lazyData->originalName, parentVar);\n  }\n  assert(\n      !llvh::isa<ESTree::ArrowFunctionExpressionNode>(node) &&\n      \"lazy compilation not supported for arrow functions\");\n  auto *func = genES5Function(lazyData->originalName, parentVar, node);\n  addLexicalDebugInfo(func, topLevel, lexicalScopeChain);\n  return {func, topLevel};\n}", "target": 1}
{"code": "static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\twhile (!list_empty(&tmp_list)) {\n\t\tbool disconnect;\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\t\tdisconnect = !(((how & UMOUNT_CONNECTED) &&\n\t\t\t\tmnt_has_parent(p) &&\n\t\t\t\t(p->mnt_parent->mnt.mnt_flags & MNT_UMOUNT)) ||\n\t\t\t       IS_MNT_LOCKED_AND_LAZY(p));\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,\n\t\t\t\t disconnect ? &unmounted : NULL);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tif (!disconnect) {\n\t\t\t\tlist_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);\n\t\t\t} else {\n\t\t\t\tumount_mnt(p);\n\t\t\t}\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}", "target": 0}
{"code": "GF_Err moof_on_child_box(GF_Box *s, GF_Box *a)\n{\n\tGF_MovieFragmentBox *ptr = (GF_MovieFragmentBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_MFHD:\n\t\tif (ptr->mfhd) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->mfhd = (GF_MovieFragmentHeaderBox *) a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TRAF:\n\t\treturn gf_list_add(ptr->TrackList, a);\n\tcase GF_ISOM_BOX_TYPE_PSSH:\n\t\tif (!ptr->PSSHs) ptr->PSSHs = gf_list_new();\n\t\treturn gf_list_add(ptr->PSSHs, a);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "static int _kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)\n{\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\t*val = vcpu->arch.db[dr];\n\t\tbreak;\n\tcase 4:\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\t\treturn 1;\n\tcase 6:\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\t\t*val = vcpu->arch.dr6;\n\t\telse\n\t\t\t*val = kvm_x86_ops->get_dr6(vcpu);\n\t\tbreak;\n\tcase 5:\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\t\treturn 1;\n\tdefault: \n\t\t*val = vcpu->arch.dr7;\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void pushGenericCommand(client *c, int where) {\n    int j, pushed = 0;\n    for (j = 2; j < c->argc; j++) {\n        if (sdslen(c->argv[j]->ptr) > LIST_MAX_ITEM_SIZE) {\n            addReplyError(c, \"Element too large\");\n            return;\n        }\n    }\n    robj *lobj = lookupKeyWrite(c->db,c->argv[1]);\n    if (lobj && lobj->type != OBJ_LIST) {\n        addReply(c,shared.wrongtypeerr);\n        return;\n    }\n    for (j = 2; j < c->argc; j++) {\n        if (!lobj) {\n            lobj = createQuicklistObject();\n            quicklistSetOptions(lobj->ptr, server.list_max_ziplist_size,\n                                server.list_compress_depth);\n            dbAdd(c->db,c->argv[1],lobj);\n        }\n        listTypePush(lobj,c->argv[j],where);\n        pushed++;\n    }\n    addReplyLongLong(c, (lobj ? listTypeLength(lobj) : 0));\n    if (pushed) {\n        char *event = (where == LIST_HEAD) ? \"lpush\" : \"rpush\";\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_LIST,event,c->argv[1],c->db->id);\n    }\n    server.dirty += pushed;\n}", "target": 0}
{"code": "SSecurityTLS::SSecurityTLS(bool _anon) : session(0), dh_params(0),\n\t\t\t\t\t\t anon_cred(0), cert_cred(0),\n\t\t\t\t\t\t anon(_anon), fis(0), fos(0)\n{\n  certfile = X509_CertFile.getData();\n  keyfile = X509_KeyFile.getData();\n  if (gnutls_global_init() != GNUTLS_E_SUCCESS)\n    throw AuthFailureException(\"gnutls_global_init failed\");\n}", "target": 0}
{"code": "void GfxState::ReusablePathIterator::reset()\n{\n    coordOff = 0;\n    subPathOff = 0;\n    curSubPath = path->getSubpath(0);\n    numCoords = curSubPath->getNumPoints();\n}", "target": 0}
{"code": "hostlist_matches_int(const struct sudoers_parse_tree *parse_tree,\n    const struct passwd *pw, const char *lhost, const char *shost,\n    const struct member_list *list)\n{\n    struct member *m;\n    int matched = UNSPEC;\n    debug_decl(hostlist_matches, SUDOERS_DEBUG_MATCH);\n    TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {\n\tmatched = host_matches(parse_tree, pw, lhost, shost, m);\n\tif (matched != UNSPEC)\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 1}
{"code": "int for_each_problem_in_dir(const char *path,\n                        uid_t caller_uid,\n                        int (*callback)(struct dump_dir *dd, void *arg),\n                        void *arg)\n{\n    DIR *dp = opendir(path);\n    if (!dp)\n    {\n        return 0;\n    }\n    int brk = 0;\n    struct dirent *dent;\n    while ((dent = readdir(dp)) != NULL)\n    {\n        if (dot_or_dotdot(dent->d_name))\n            continue; \n        char *full_name = concat_path_file(path, dent->d_name);\n        if (caller_uid == -1 || dump_dir_accessible_by_uid(full_name, caller_uid))\n        {\n            int sv_logmode = logmode;\n            logmode = 0;\n            struct dump_dir *dd = dd_opendir(full_name, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES | DD_DONT_WAIT_FOR_LOCK);\n            logmode = sv_logmode;\n            if (dd)\n            {\n                brk = callback ? callback(dd, arg) : 0;\n                dd_close(dd);\n            }\n        }\n        free(full_name);\n        if (brk)\n            break;\n    }\n    closedir(dp);\n    return brk;\n}", "target": 1}
{"code": "static inline bool is_exception(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VALID_MASK))\n\t\t== (INTR_TYPE_HARD_EXCEPTION | INTR_INFO_VALID_MASK);\n}", "target": 1}
{"code": "static void timerfd_setup_cancel(struct timerfd_ctx *ctx, int flags)\n{\n\tif ((ctx->clockid == CLOCK_REALTIME ||\n\t     ctx->clockid == CLOCK_REALTIME_ALARM) &&\n\t    (flags & TFD_TIMER_ABSTIME) && (flags & TFD_TIMER_CANCEL_ON_SET)) {\n\t\tif (!ctx->might_cancel) {\n\t\t\tctx->might_cancel = true;\n\t\t\tspin_lock(&cancel_lock);\n\t\t\tlist_add_rcu(&ctx->clist, &cancel_list);\n\t\t\tspin_unlock(&cancel_lock);\n\t\t}\n\t} else if (ctx->might_cancel) {\n\t\ttimerfd_remove_cancel(ctx);\n\t}\n}", "target": 1}
{"code": "TfLiteStatus EvalHashtableFind(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputResourceIdTensor);\n  int resource_id = input_resource_id_tensor->data.i32[0];\n  const TfLiteTensor* key_tensor = GetInput(context, node, kKeyTensor);\n  const TfLiteTensor* default_value_tensor =\n      GetInput(context, node, kDefaultValueTensor);\n  TfLiteTensor* output_tensor = GetOutput(context, node, 0);\n  Subgraph* subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n  auto& resources = subgraph->resources();\n  auto* lookup = resource::GetHashtableResource(&resources, resource_id);\n  TF_LITE_ENSURE(context, lookup != nullptr);\n  TF_LITE_ENSURE_STATUS(\n      lookup->CheckKeyAndValueTypes(context, key_tensor, output_tensor));\n  auto result =\n      lookup->Lookup(context, key_tensor, output_tensor, default_value_tensor);\n  return result;\n}", "target": 1}
{"code": "videobuf_vm_open(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\tdprintk(2,\"vm_open %p [count=%d,vma=%08lx-%08lx]\\n\",map,\n\t\tmap->count,vma->vm_start,vma->vm_end);\n\tmap->count++;\n}", "target": 1}
{"code": "void CZNC::ForceEncoding() {\n    m_uiForceEncoding++;\n#ifdef HAVE_ICU\n    for (Csock* pSock : GetManager()) {\n        if (pSock->GetEncoding().empty()) {\n            pSock->SetEncoding(\"UTF-8\");\n        }\n    }\n#endif\n}", "target": 1}
{"code": "static int xfrm_dump_sa(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\tBUILD_BUG_ON(sizeof(struct xfrm_state_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\tif (!cb->args[0]) {\n\t\tstruct nlattr *attrs[XFRMA_MAX+1];\n\t\tstruct xfrm_address_filter *filter = NULL;\n\t\tu8 proto = 0;\n\t\tint err;\n\t\tcb->args[0] = 1;\n\t\terr = nlmsg_parse(cb->nlh, 0, attrs, XFRMA_MAX,\n\t\t\t\t  xfrma_policy);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (attrs[XFRMA_ADDRESS_FILTER]) {\n\t\t\tfilter = kmemdup(nla_data(attrs[XFRMA_ADDRESS_FILTER]),\n\t\t\t\t\t sizeof(*filter), GFP_KERNEL);\n\t\t\tif (filter == NULL)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (attrs[XFRMA_PROTO])\n\t\t\tproto = nla_get_u8(attrs[XFRMA_PROTO]);\n\t\txfrm_state_walk_init(walk, proto, filter);\n\t}\n\t(void) xfrm_state_walk(net, walk, dump_one_state, &info);\n\treturn skb->len;\n}", "target": 1}
{"code": "void Curl_ssl_associate_conn(struct Curl_easy *data,\n                             struct connectdata *conn)\n{\n  if(Curl_ssl->associate_connection) {\n    Curl_ssl->associate_connection(data, conn, FIRSTSOCKET);\n    if(conn->sock[SECONDARYSOCKET] && conn->bits.sock_accepted)\n      Curl_ssl->associate_connection(data, conn, SECONDARYSOCKET);\n  }\n}", "target": 0}
{"code": "void LightProcess::ChangeUser(const std::string &username) {\n  if (username.empty()) return;\n  for (int i = 0; i < g_procsCount; i++) {\n    Lock lock(g_procs[i].m_procMutex);\n    fprintf(g_procs[i].m_fout, \"change_user\\n%s\\n\", username.c_str());\n    fflush(g_procs[i].m_fout);\n  }\n}", "target": 1}
{"code": "Network::TransportSocketPtr ServerSslSocketFactory::createDownstreamTransportSocket() const {\n  Envoy::Ssl::ServerContextSharedPtr ssl_ctx;\n  {\n    absl::ReaderMutexLock l(&ssl_ctx_mu_);\n    ssl_ctx = ssl_ctx_;\n  }\n  if (ssl_ctx) {\n    return std::make_unique<SslSocket>(std::move(ssl_ctx), InitialState::Server, nullptr,\n                                       config_->createHandshaker());\n  } else {\n    ENVOY_LOG(debug, \"Create NotReadySslSocket\");\n    stats_.downstream_context_secrets_not_ready_.inc();\n    return std::make_unique<NotReadySslSocket>();\n  }\n}", "target": 1}
{"code": "static int StreamTcpPacketStateClosed(ThreadVars *tv, Packet *p,\n        StreamTcpThread *stt, TcpSession *ssn, PacketQueueNoLock *pq)\n{\n    if (ssn == NULL)\n        return -1;\n    if (p->tcph->th_flags & TH_RST) {\n        SCLogDebug(\"RST on closed state\");\n        return 0;\n    }\n    TcpStream *stream = NULL, *ostream = NULL;\n    if (PKT_IS_TOSERVER(p)) {\n        stream = &ssn->client;\n        ostream = &ssn->server;\n    } else {\n        stream = &ssn->server;\n        ostream = &ssn->client;\n    }\n    SCLogDebug(\"stream %s ostream %s\",\n            stream->flags & STREAMTCP_STREAM_FLAG_RST_RECV?\"true\":\"false\",\n            ostream->flags & STREAMTCP_STREAM_FLAG_RST_RECV ? \"true\":\"false\");\n    if ((stream->flags & STREAMTCP_STREAM_FLAG_RST_RECV) == 0) {\n        if (ostream->flags & STREAMTCP_STREAM_FLAG_RST_RECV) {\n            if (StreamTcpStateDispatch(tv, p, stt, ssn, &stt->pseudo_queue, ssn->pstate) < 0)\n                return -1;\n            if (ssn->state == TCP_CLOSED)\n                ssn->state = ssn->pstate;\n        }\n    }\n    return 0;\n}", "target": 0}
{"code": "static int __init unittest_data_add(void)\n{\n\tvoid *unittest_data;\n\tstruct device_node *unittest_data_node, *np;\n\textern uint8_t __dtb_testcases_begin[];\n\textern uint8_t __dtb_testcases_end[];\n\tconst int size = __dtb_testcases_end - __dtb_testcases_begin;\n\tint rc;\n\tif (!size) {\n\t\tpr_warn(\"%s: No testcase data to attach; not running tests\\n\",\n\t\t\t__func__);\n\t\treturn -ENODATA;\n\t}\n\tunittest_data = kmemdup(__dtb_testcases_begin, size, GFP_KERNEL);\n\tif (!unittest_data)\n\t\treturn -ENOMEM;\n\tof_fdt_unflatten_tree(unittest_data, NULL, &unittest_data_node);\n\tif (!unittest_data_node) {\n\t\tpr_warn(\"%s: No tree to attach; not running tests\\n\", __func__);\n\t\tkfree(unittest_data);\n\t\treturn -ENODATA;\n\t}\n\tof_overlay_mutex_lock();\n\trc = of_resolve_phandles(unittest_data_node);\n\tif (rc) {\n\t\tpr_err(\"%s: Failed to resolve phandles (rc=%i)\\n\", __func__, rc);\n\t\tof_overlay_mutex_unlock();\n\t\treturn -EINVAL;\n\t}\n\tif (!of_root) {\n\t\tof_root = unittest_data_node;\n\t\tfor_each_of_allnodes(np)\n\t\t\t__of_attach_node_sysfs(np);\n\t\tof_aliases = of_find_node_by_path(\"/aliases\");\n\t\tof_chosen = of_find_node_by_path(\"/chosen\");\n\t\tof_overlay_mutex_unlock();\n\t\treturn 0;\n\t}\n\tnp = unittest_data_node->child;\n\twhile (np) {\n\t\tstruct device_node *next = np->sibling;\n\t\tnp->parent = of_root;\n\t\tattach_node_and_children(np);\n\t\tnp = next;\n\t}\n\tof_overlay_mutex_unlock();\n\treturn 0;\n}", "target": 0}
{"code": "void rds_rdma_drop_keys(struct rds_sock *rs)\n{\n\tstruct rds_mr *mr;\n\tstruct rb_node *node;\n\tunsigned long flags;\n\tspin_lock_irqsave(&rs->rs_rdma_lock, flags);\n\twhile ((node = rb_first(&rs->rs_rdma_keys))) {\n\t\tmr = rb_entry(node, struct rds_mr, r_rb_node);\n\t\tif (mr->r_trans == rs->rs_transport)\n\t\t\tmr->r_invalidate = 0;\n\t\trb_erase(&mr->r_rb_node, &rs->rs_rdma_keys);\n\t\tRB_CLEAR_NODE(&mr->r_rb_node);\n\t\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\t\trds_destroy_mr(mr);\n\t\trds_mr_put(mr);\n\t\tspin_lock_irqsave(&rs->rs_rdma_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&rs->rs_rdma_lock, flags);\n\tif (rs->rs_transport && rs->rs_transport->flush_mrs)\n\t\trs->rs_transport->flush_mrs();\n}", "target": 0}
{"code": "void LibRaw::blend_highlights()\n{\n  int clip = INT_MAX, row, col, c, i, j;\n  static const float trans[2][4][4] = {\n      {{1, 1, 1}, {1.7320508, -1.7320508, 0}, {-1, -1, 2}},\n      {{1, 1, 1, 1}, {1, -1, 1, -1}, {1, 1, -1, -1}, {1, -1, -1, 1}}};\n  static const float itrans[2][4][4] = {\n      {{1, 0.8660254, -0.5}, {1, -0.8660254, -0.5}, {1, 0, 1}},\n      {{1, 1, 1, 1}, {1, -1, 1, -1}, {1, 1, -1, -1}, {1, -1, -1, 1}}};\n  float cam[2][4], lab[2][4], sum[2], chratio;\n  if ((unsigned)(colors - 3) > 1)\n    return;\n  RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS, 0, 2);\n  FORCC if (clip > (i = 65535 * pre_mul[c])) clip = i;\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n    {\n      FORCC if (image[row * width + col][c] > clip) break;\n      if (c == colors)\n        continue;\n      FORCC\n      {\n        cam[0][c] = image[row * width + col][c];\n        cam[1][c] = MIN(cam[0][c], clip);\n      }\n      for (i = 0; i < 2; i++)\n      {\n        FORCC for (lab[i][c] = j = 0; j < colors; j++) lab[i][c] +=\n            trans[colors - 3][c][j] * cam[i][j];\n        for (sum[i] = 0, c = 1; c < colors; c++)\n          sum[i] += SQR(lab[i][c]);\n      }\n      chratio = sqrt(sum[1] / sum[0]);\n      for (c = 1; c < colors; c++)\n        lab[0][c] *= chratio;\n      FORCC for (cam[0][c] = j = 0; j < colors; j++) cam[0][c] +=\n          itrans[colors - 3][c][j] * lab[0][j];\n      FORCC image[row * width + col][c] = cam[0][c] / colors;\n    }\n  RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS, 1, 2);\n}", "target": 0}
{"code": "size_t vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t datalen)\n{\n    Error *err = NULL;\n    ssize_t ret;\n    ret = qio_channel_write(\n        vs->ioc, (const char *)data, datalen, &err);\n    VNC_DEBUG(\"Wrote wire %p %zd -> %ld\\n\", data, datalen, ret);\n    return vnc_client_io_error(vs, ret, &err);\n}", "target": 0}
{"code": "void ff_jpeg2000_cleanup(Jpeg2000Component *comp, Jpeg2000CodingStyle *codsty)\n{\n    int reslevelno, bandno, precno;\n    for (reslevelno = 0;\n         comp->reslevel && reslevelno < codsty->nreslevels;\n         reslevelno++) {\n        Jpeg2000ResLevel *reslevel = comp->reslevel + reslevelno;\n        for (bandno = 0; bandno < reslevel->nbands; bandno++) {\n            Jpeg2000Band *band = reslevel->band + bandno;\n            for (precno = 0; precno < reslevel->num_precincts_x * reslevel->num_precincts_y; precno++) {\n                Jpeg2000Prec *prec = band->prec + precno;\n                av_freep(&prec->zerobits);\n                av_freep(&prec->cblkincl);\n                av_freep(&prec->cblk);\n            }\n            av_freep(&band->prec);\n        }\n        av_freep(&reslevel->band);\n    }\n    ff_dwt_destroy(&comp->dwt);\n    av_freep(&comp->reslevel);\n    av_freep(&comp->i_data);\n    av_freep(&comp->f_data);\n}", "target": 1}
{"code": " bool makeAllDirectories(const String& path)\n {\n    String fullPath = path;\n    if (SHCreateDirectoryEx(0, fullPath.charactersWithNullTermination(), 0) != ERROR_SUCCESS) {\n        DWORD error = GetLastError();\n        if (error != ERROR_FILE_EXISTS && error != ERROR_ALREADY_EXISTS) {\n            LOG_ERROR(\"Failed to create path %s\", path.ascii().data());\n            return false;\n        }\n    }\n    return true;\n}", "target": 0}
{"code": "  const std::string& get_tenant() const {\n    ceph_assert(t != Wildcard);\n    return u.tenant;\n  }", "target": 1}
{"code": "void file_sb_list_add(struct file *file, struct super_block *sb)\n{\n\tif (likely(!(file->f_mode & FMODE_WRITE)))\n\t\treturn;\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\treturn;\n\tlg_local_lock(&files_lglock);\n\t__file_sb_list_add(file, sb);\n\tlg_local_unlock(&files_lglock);\n}", "target": 1}
{"code": "gboolean menu_cache_item_unref(MenuCacheItem* item)\n{\n    MENU_CACHE_LOCK; \n    if( g_atomic_int_dec_and_test( &item->n_ref ) )\n    {\n        g_free( item->id );\n        g_free( item->name );\n        g_free( item->comment );\n        g_free( item->icon );\n        menu_cache_file_dir_unref(item->file_dir);\n        if( item->file_name && item->file_name != item->id )\n            g_free( item->file_name );\n        if( item->parent )\n        {\n            item->parent->children = g_slist_remove(item->parent->children, item);\n        }\n        if( item->type == MENU_CACHE_TYPE_DIR )\n        {\n            MenuCacheDir* dir = MENU_CACHE_DIR(item);\n            GSList* l;\n            for(l = dir->children; l; )\n            {\n                MenuCacheItem* child = MENU_CACHE_ITEM(l->data);\n                child->parent = NULL;\n                l = l->next;\n                menu_cache_item_unref(child);\n            }\n            g_slist_free( dir->children );\n            g_slice_free( MenuCacheDir, dir );\n        }\n        else\n        {\n            MenuCacheApp* app = MENU_CACHE_APP(item);\n            g_free( app->exec );\n            g_free(app->try_exec);\n            g_free(app->working_dir);\n            g_free(app->categories);\n            g_free(app->keywords);\n            g_slice_free( MenuCacheApp, app );\n        }\n    }\n    MENU_CACHE_UNLOCK;\n    return FALSE;\n}", "target": 0}
{"code": "xmlPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr input) {\n    int ret;\n    if (input == NULL) return(-1);\n    if (xmlParserDebugEntities) {\n\tif ((ctxt->input != NULL) && (ctxt->input->filename))\n\t    xmlGenericError(xmlGenericErrorContext,\n\t\t    \"%s(%d): \", ctxt->input->filename,\n\t\t    ctxt->input->line);\n\txmlGenericError(xmlGenericErrorContext,\n\t\t\"Pushing input %d : %.30s\\n\", ctxt->inputNr+1, input->cur);\n    }\n    if (((ctxt->inputNr > 40) && ((ctxt->options & XML_PARSE_HUGE) == 0)) ||\n        (ctxt->inputNr > 1024)) {\n        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n        while (ctxt->inputNr > 1)\n            xmlFreeInputStream(inputPop(ctxt));\n\treturn(-1);\n    }\n    ret = inputPush(ctxt, input);\n    if (ctxt->instate == XML_PARSER_EOF)\n        return(-1);\n    GROW;\n    return(ret);\n}", "target": 0}
{"code": "static bool tipc_node_cleanup(struct tipc_node *peer)\n{\n\tstruct tipc_node *temp_node;\n\tstruct tipc_net *tn = tipc_net(peer->net);\n\tbool deleted = false;\n\tif (!spin_trylock_bh(&tn->node_list_lock))\n\t\treturn false;\n\ttipc_node_write_lock(peer);\n\tif (!node_is_up(peer) && time_after(jiffies, peer->delete_at)) {\n\t\ttipc_node_clear_links(peer);\n\t\ttipc_node_delete_from_list(peer);\n\t\tdeleted = true;\n\t}\n\ttipc_node_write_unlock(peer);\n\tif (!deleted) {\n\t\tspin_unlock_bh(&tn->node_list_lock);\n\t\treturn deleted;\n\t}\n\ttn->capabilities = TIPC_NODE_CAPABILITIES;\n\tlist_for_each_entry_rcu(temp_node, &tn->node_list, list) {\n\t\ttn->capabilities &= temp_node->capabilities;\n\t}\n\ttipc_bcast_toggle_rcast(peer->net,\n\t\t\t\t(tn->capabilities & TIPC_BCAST_RCAST));\n\tspin_unlock_bh(&tn->node_list_lock);\n\treturn deleted;\n}", "target": 0}
{"code": "int64_t LineBasedFrameDecoder::findEndOfLine(IOBufQueue& buf) {\n  Cursor c(buf.front());\n  for (uint32_t i = 0; i < maxLength_ && i < buf.chainLength(); i++) {\n    auto b = c.read<char>();\n    if (b == '\\n' && terminatorType_ != TerminatorType::CARRIAGENEWLINE) {\n      return i;\n    } else if (terminatorType_ != TerminatorType::NEWLINE &&\n               b == '\\r' && !c.isAtEnd() && c.read<char>() == '\\n') {\n      return i;\n    }\n  }\n  return -1;\n}", "target": 1}
{"code": "static void accumulate_steal_time(struct kvm_vcpu *vcpu)\n{\n\tu64 delta;\n\tif (!(vcpu->arch.st.msr_val & KVM_MSR_ENABLED))\n\t\treturn;\n\tdelta = current->sched_info.run_delay - vcpu->arch.st.last_steal;\n\tvcpu->arch.st.last_steal = current->sched_info.run_delay;\n\tvcpu->arch.st.accum_steal = delta;\n}", "target": 0}
{"code": "  void operator()(const CPUDevice& d, typename TTypes<T>::ConstFlat gradient,\n                  typename TTypes<T>::ConstFlat input,\n                  typename TTypes<T>::ConstScalar input_min_tensor,\n                  typename TTypes<T>::ConstScalar input_max_tensor,\n                  typename TTypes<T>::Flat input_backprop,\n                  typename TTypes<T>::Scalar input_min_backprop,\n                  typename TTypes<T>::Scalar input_max_backprop) {\n    QuantizeAndDequantizeOneScaleGradientImpl<CPUDevice, T>::Compute(\n        d, gradient, input, input_min_tensor, input_max_tensor, input_backprop,\n        input_min_backprop, input_max_backprop);\n  }", "target": 1}
{"code": "static ssize_t driver_override_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tchar *driver_override, *old = pdev->driver_override, *cp;\n\tif (count > PATH_MAX)\n\t\treturn -EINVAL;\n\tdriver_override = kstrndup(buf, count, GFP_KERNEL);\n\tif (!driver_override)\n\t\treturn -ENOMEM;\n\tcp = strchr(driver_override, '\\n');\n\tif (cp)\n\t\t*cp = '\\0';\n\tif (strlen(driver_override)) {\n\t\tpdev->driver_override = driver_override;\n\t} else {\n\t\tkfree(driver_override);\n\t\tpdev->driver_override = NULL;\n\t}\n\tkfree(old);\n\treturn count;\n}", "target": 1}
{"code": "static int hi3660_stub_clk_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tunsigned int i;\n\tint ret;\n\tstub_clk_chan.cl.dev = dev;\n\tstub_clk_chan.cl.tx_done = NULL;\n\tstub_clk_chan.cl.tx_block = false;\n\tstub_clk_chan.cl.knows_txdone = false;\n\tstub_clk_chan.mbox = mbox_request_channel(&stub_clk_chan.cl, 0);\n\tif (IS_ERR(stub_clk_chan.mbox))\n\t\treturn PTR_ERR(stub_clk_chan.mbox);\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -EINVAL;\n\tfreq_reg = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!freq_reg)\n\t\treturn -ENOMEM;\n\tfreq_reg += HI3660_STUB_CLOCK_DATA;\n\tfor (i = 0; i < HI3660_CLK_STUB_NUM; i++) {\n\t\tret = devm_clk_hw_register(&pdev->dev, &hi3660_stub_clks[i].hw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn devm_of_clk_add_hw_provider(&pdev->dev, hi3660_stub_clk_hw_get,\n\t\t\t\t\t   hi3660_stub_clks);\n}", "target": 0}
{"code": "START_TEST(test_log_long_msg)\n{\n\tint lpc;\n\tint rc;\n\tint i, max = 1000;\n\tchar *buffer = calloc(1, max);\n\tqb_log_init(\"test\", LOG_USER, LOG_DEBUG);\n\trc = qb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_ENABLED, QB_FALSE);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_ctl(QB_LOG_BLACKBOX, QB_LOG_CONF_SIZE, 1024);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_ctl(QB_LOG_BLACKBOX, QB_LOG_CONF_ENABLED, QB_TRUE);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_filter_ctl(QB_LOG_BLACKBOX, QB_LOG_FILTER_ADD,\n\t\t\t  QB_LOG_FILTER_FILE, \"*\", LOG_TRACE);\n\tck_assert_int_eq(rc, 0);\n\tfor (lpc = 500; lpc < max; lpc++) {\n\t\tlpc++;\n\t\tfor(i = 0; i < max; i++) {\n\t\t\tbuffer[i] = 'a' + (i % 10);\n\t\t}\n\t\tbuffer[lpc%600] = 0;\n\t\tqb_log(LOG_INFO, \"Message %d %d - %s\", lpc, lpc%600, buffer);\n\t}\n        qb_log_blackbox_write_to_file(\"blackbox.dump\");\n        qb_log_blackbox_print_from_file(\"blackbox.dump\");\n\tunlink(\"blackbox.dump\");\n\tqb_log_fini();\n}", "target": 1}
{"code": "krb5_pac_parse(krb5_context context,\n               const void *ptr,\n               size_t len,\n               krb5_pac *ppac)\n{\n    krb5_error_code ret;\n    size_t i;\n    const unsigned char *p = (const unsigned char *)ptr;\n    krb5_pac pac;\n    size_t header_len;\n    krb5_ui_4 cbuffers, version;\n    *ppac = NULL;\n    if (len < PACTYPE_LENGTH)\n        return ERANGE;\n    cbuffers = load_32_le(p);\n    p += 4;\n    version = load_32_le(p);\n    p += 4;\n    if (version != 0)\n        return EINVAL;\n    header_len = PACTYPE_LENGTH + (cbuffers * PAC_INFO_BUFFER_LENGTH);\n    if (len < header_len)\n        return ERANGE;\n    ret = krb5_pac_init(context, &pac);\n    if (ret != 0)\n        return ret;\n    pac->pac = (PACTYPE *)realloc(pac->pac,\n                                  sizeof(PACTYPE) + ((cbuffers - 1) * sizeof(PAC_INFO_BUFFER)));\n    if (pac->pac == NULL) {\n        krb5_pac_free(context, pac);\n        return ENOMEM;\n    }\n    pac->pac->cBuffers = cbuffers;\n    pac->pac->Version = version;\n    for (i = 0; i < pac->pac->cBuffers; i++) {\n        PAC_INFO_BUFFER *buffer = &pac->pac->Buffers[i];\n        buffer->ulType = load_32_le(p);\n        p += 4;\n        buffer->cbBufferSize = load_32_le(p);\n        p += 4;\n        buffer->Offset = load_64_le(p);\n        p += 8;\n        if (buffer->Offset % PAC_ALIGNMENT) {\n            krb5_pac_free(context, pac);\n            return EINVAL;\n        }\n        if (buffer->Offset < header_len ||\n            buffer->Offset + buffer->cbBufferSize > len) {\n            krb5_pac_free(context, pac);\n            return ERANGE;\n        }\n    }\n    pac->data.data = realloc(pac->data.data, len);\n    if (pac->data.data == NULL) {\n        krb5_pac_free(context, pac);\n        return ENOMEM;\n    }\n    memcpy(pac->data.data, ptr, len);\n    pac->data.length = len;\n    *ppac = pac;\n    return 0;\n}", "target": 1}
{"code": "static void ecc_free_public_key(struct ecc_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\tcrypto_bignum_free(s->x);\n\tcrypto_bignum_free(s->y);\n}", "target": 1}
{"code": "smtp_get_interface(uschar *istring, int host_af, address_item *addr,\n  uschar **interface, uschar *msg)\n{\nconst uschar * expint;\nuschar *iface;\nint sep = 0;\nif (!istring) return TRUE;\nif (!(expint = expand_string(istring)))\n  {\n  if (f.expand_string_forcedfail) return TRUE;\n  addr->transport_return = PANIC;\n  addr->message = string_sprintf(\"failed to expand \\\"interface\\\" \"\n      \"option for %s: %s\", msg, expand_string_message);\n  return FALSE;\n  }\nwhile (isspace(*expint)) expint++;\nif (*expint == 0) return TRUE;\nwhile ((iface = string_nextinlist(&expint, &sep, big_buffer,\n          big_buffer_size)))\n  {\n  if (string_is_ip_address(iface, NULL) == 0)\n    {\n    addr->transport_return = PANIC;\n    addr->message = string_sprintf(\"\\\"%s\\\" is not a valid IP \"\n      \"address for the \\\"interface\\\" option for %s\",\n      iface, msg);\n    return FALSE;\n    }\n  if (((Ustrchr(iface, ':') == NULL)? AF_INET:AF_INET6) == host_af)\n    break;\n  }\nif (iface) *interface = string_copy(iface);\nreturn TRUE;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor* stamp_token_t;\n    OP_REQUIRES_OK(context, context->input(\"stamp_token\", &stamp_token_t));\n    int64_t stamp_token = stamp_token_t->scalar<int64>()();\n    const Tensor* tree_ensemble_serialized_t;\n    OP_REQUIRES_OK(context, context->input(\"tree_ensemble_serialized\",\n                                           &tree_ensemble_serialized_t));\n    std::unique_ptr<BoostedTreesEnsembleResource> result(\n        new BoostedTreesEnsembleResource());\n    if (!result->InitFromSerialized(\n            tree_ensemble_serialized_t->scalar<tstring>()(), stamp_token)) {\n      result->Unref();\n      result.release();  \n      OP_REQUIRES(\n          context, false,\n          errors::InvalidArgument(\"Unable to parse tree ensemble proto.\"));\n    }\n    auto status =\n        CreateResource(context, HandleFromInput(context, 0), result.release());\n    if (status.code() != tensorflow::error::ALREADY_EXISTS) {\n      OP_REQUIRES_OK(context, status);\n    }\n  }", "target": 0}
{"code": "ofpacts_parse(char *str, const struct ofpact_parse_params *pp,\n              bool allow_instructions, enum ofpact_type outer_action)\n{\n    if (pp->depth >= MAX_OFPACT_PARSE_DEPTH) {\n        return xstrdup(\"Action nested too deeply\");\n    }\n    CONST_CAST(struct ofpact_parse_params *, pp)->depth++;\n    uint32_t orig_size = pp->ofpacts->size;\n    char *error = ofpacts_parse__(str, pp, allow_instructions, outer_action);\n    if (error) {\n        pp->ofpacts->size = orig_size;\n    }\n    CONST_CAST(struct ofpact_parse_params *, pp)->depth--;\n    return error;\n}", "target": 0}
{"code": "create_durable_v2_buf(struct cifs_open_parms *oparms)\n{\n\tstruct cifs_fid *pfid = oparms->fid;\n\tstruct create_durable_v2 *buf;\n\tbuf = kzalloc(sizeof(struct create_durable_v2), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct create_durable_v2, dcontext));\n\tbuf->ccontext.DataLength = cpu_to_le32(sizeof(struct durable_context_v2));\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_durable_v2, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\tbuf->dcontext.Timeout = cpu_to_le32(oparms->tcon->handle_timeout);\n\tbuf->dcontext.Flags = cpu_to_le32(SMB2_DHANDLE_FLAG_PERSISTENT);\n\tgenerate_random_uuid(buf->dcontext.CreateGuid);\n\tmemcpy(pfid->create_guid, buf->dcontext.CreateGuid, 16);\n\tbuf->Name[0] = 'D';\n\tbuf->Name[1] = 'H';\n\tbuf->Name[2] = '2';\n\tbuf->Name[3] = 'Q';\n\treturn buf;\n}", "target": 0}
{"code": "static void sysfs_slab_remove(struct kmem_cache *s)\n{\n\tkobject_uevent(&s->kobj, KOBJ_REMOVE);\n\tkobject_del(&s->kobj);\n\tkobject_put(&s->kobj);\n}", "target": 0}
{"code": "make_month(const char *s)\n{\n    int i;\n    char month[3];\n    month[0] = xtoupper(*s);\n    if (!month[0])\n        return -1; \n    month[1] = xtolower(*(s + 1));\n    if (!month[1])\n        return -1; \n    month[2] = xtolower(*(s + 2));\n    for (i = 0; i < 12; i++)\n        if (!strncmp(month_names[i], month, 3))\n            return i;\n    return -1;\n}", "target": 0}
{"code": "gss_krb5int_export_lucid_sec_context(\n    OM_uint32           *minor_status,\n    const gss_ctx_id_t  context_handle,\n    const gss_OID       desired_object,\n    gss_buffer_set_t    *data_set)\n{\n    krb5_error_code     kret = 0;\n    OM_uint32           retval;\n    krb5_gss_ctx_id_t   ctx = (krb5_gss_ctx_id_t)context_handle;\n    void                *lctx = NULL;\n    int                 version = 0;\n    gss_buffer_desc     rep;\n    retval = GSS_S_FAILURE;\n    *minor_status = 0;\n    *data_set = GSS_C_NO_BUFFER_SET;\n    if (ctx->terminated || !ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return GSS_S_NO_CONTEXT;\n    }\n    retval = generic_gss_oid_decompose(minor_status,\n                                       GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID,\n                                       GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID_LENGTH,\n                                       desired_object,\n                                       &version);\n    if (GSS_ERROR(retval))\n        return retval;\n    switch (version) {\n    case 1:\n        kret = make_external_lucid_ctx_v1((krb5_pointer)ctx,\n                                          version, &lctx);\n        break;\n    default:\n        kret = (OM_uint32) KG_LUCID_VERSION;\n        break;\n    }\n    if (kret)\n        goto error_out;\n    rep.value = &lctx;\n    rep.length = sizeof(lctx);\n    retval = generic_gss_add_buffer_set_member(minor_status, &rep, data_set);\n    if (GSS_ERROR(retval))\n        goto error_out;\nerror_out:\n    if (*minor_status == 0)\n        *minor_status = (OM_uint32) kret;\n    return(retval);\n}", "target": 0}
{"code": "static bool new_idmap_permitted(struct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *new_map)\n{\n\tif ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {\n\t\tu32 id = new_map->extent[0].lower_first;\n\t\tif (cap_setid == CAP_SETUID) {\n\t\t\tkuid_t uid = make_kuid(ns->parent, id);\n\t\t\tif (uid_eq(uid, current_fsuid()))\n\t\t\t\treturn true;\n\t\t}\n\t\telse if (cap_setid == CAP_SETGID) {\n\t\t\tkgid_t gid = make_kgid(ns->parent, id);\n\t\t\tif (gid_eq(gid, current_fsgid()))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\tif (!cap_valid(cap_setid))\n\t\treturn true;\n\tif (ns_capable(ns->parent, cap_setid))\n\t\treturn true;\n\treturn false;\n}", "target": 1}
{"code": "static int activate(AVFilterContext *ctx)\n{\n    AVFilterLink *inlink = ctx->inputs[0];\n    AVFilterLink *outlink = ctx->outputs[0];\n    AudioFWTDNContext *s = ctx->priv;\n    AVFrame *in = NULL;\n    int ret, status;\n    int64_t pts;\n    FF_FILTER_FORWARD_STATUS_BACK(outlink, inlink);\n    ret = ff_inlink_consume_samples(inlink, s->nb_samples, s->nb_samples, &in);\n    if (ret < 0)\n        return ret;\n    if (ret > 0)\n        return filter_frame(inlink, in);\n    if (ff_inlink_acknowledge_status(inlink, &status, &pts)) {\n        if (status == AVERROR_EOF) {\n            while (s->padd_samples != 0) {\n                ret = filter_frame(inlink, NULL);\n                if (ret < 0)\n                    return ret;\n            }\n            ff_outlink_set_status(outlink, status, pts);\n            return ret;\n        }\n    }\n    FF_FILTER_FORWARD_WANTED(outlink, inlink);\n    return FFERROR_NOT_READY;\n}", "target": 1}
{"code": "asmlinkage void __sched schedule(void)\n{\n\tstruct task_struct *prev, *next;\n\tunsigned long *switch_count;\n\tstruct rq *rq;\n\tint cpu;\nneed_resched:\n\tpreempt_disable();\n\tcpu = smp_processor_id();\n\trq = cpu_rq(cpu);\n\trcu_note_context_switch(cpu);\n\tprev = rq->curr;\n\trelease_kernel_lock(prev);\nneed_resched_nonpreemptible:\n\tschedule_debug(prev);\n\tif (sched_feat(HRTICK))\n\t\thrtick_clear(rq);\n\traw_spin_lock_irq(&rq->lock);\n\tclear_tsk_need_resched(prev);\n\tswitch_count = &prev->nivcsw;\n\tif (prev->state && !(preempt_count() & PREEMPT_ACTIVE)) {\n\t\tif (unlikely(signal_pending_state(prev->state, prev))) {\n\t\t\tprev->state = TASK_RUNNING;\n\t\t} else {\n\t\t\tif (prev->flags & PF_WQ_WORKER) {\n\t\t\t\tstruct task_struct *to_wakeup;\n\t\t\t\tto_wakeup = wq_worker_sleeping(prev, cpu);\n\t\t\t\tif (to_wakeup)\n\t\t\t\t\ttry_to_wake_up_local(to_wakeup);\n\t\t\t}\n\t\t\tdeactivate_task(rq, prev, DEQUEUE_SLEEP);\n\t\t}\n\t\tswitch_count = &prev->nvcsw;\n\t}\n\tpre_schedule(rq, prev);\n\tif (unlikely(!rq->nr_running))\n\t\tidle_balance(cpu, rq);\n\tput_prev_task(rq, prev);\n\tnext = pick_next_task(rq);\n\tif (likely(prev != next)) {\n\t\tsched_info_switch(prev, next);\n\t\tperf_event_task_sched_out(prev, next);\n\t\trq->nr_switches++;\n\t\trq->curr = next;\n\t\t++*switch_count;\n\t\tcontext_switch(rq, prev, next); \n\t\tcpu = smp_processor_id();\n\t\trq = cpu_rq(cpu);\n\t} else\n\t\traw_spin_unlock_irq(&rq->lock);\n\tpost_schedule(rq);\n\tif (unlikely(reacquire_kernel_lock(prev)))\n\t\tgoto need_resched_nonpreemptible;\n\tpreempt_enable_no_resched();\n\tif (need_resched())\n\t\tgoto need_resched;\n}", "target": 1}
{"code": "Status GetDeviceForInput(const EagerOperation& op, const EagerContext& ctx,\n                         TensorHandle* tensor_handle, Device** result) {\n  Device* cpu_device = ctx.HostCPU();\n  string device_name;\n  if (tensor_handle->Type() != TensorHandle::LOCAL) {\n    Device* device = tensor_handle->device();\n    device_name = device != nullptr ? device->name() : cpu_device->name();\n    *result = (device == nullptr ? cpu_device : device);\n  } else if (tensor_handle->dtype == DT_RESOURCE) {\n    const Tensor* tensor;\n    TF_RETURN_IF_ERROR(tensor_handle->Tensor(&tensor));\n    if (tensor->NumElements() == 0) {\n      return errors::InvalidArgument(\"Empty resource handle\");\n    }\n    const ResourceHandle& handle = tensor->flat<ResourceHandle>()(0);\n    device_name = handle.device();\n    Device* input_device;\n    TF_RETURN_IF_ERROR(\n        ctx.FindDeviceFromName(device_name.c_str(), &input_device));\n    *result = input_device;\n  } else {\n    Device* device = tensor_handle->device();\n    const bool is_tpu = device != nullptr && device->device_type() == \"TPU\";\n    const bool use_host_memory =\n        is_tpu ? MTypeFromDTypeIntsOnDevice(tensor_handle->dtype)\n               : MTypeFromDType(tensor_handle->dtype);\n    if (use_host_memory) {\n      *result = cpu_device;\n    } else {\n      if (!op.is_function() && device != nullptr && device != cpu_device) {\n        device = absl::get<Device*>(op.Device());\n      }\n      *result = (device == nullptr ? cpu_device : device);\n    }\n  }\n  return Status::OK();\n}", "target": 0}
{"code": "static int linkSane(FD_t wfd, const char *dest)\n{\n    struct stat sb, lsb;\n    return (fstat(Fileno(wfd), &sb) == 0 && sb.st_size == 0 &&\n\t    (sb.st_mode & ~S_IFMT) == S_IWUSR &&\n\t    lstat(dest, &lsb) == 0 && S_ISREG(lsb.st_mode) &&\n\t    sb.st_dev == lsb.st_dev && sb.st_ino == lsb.st_ino);\n}", "target": 0}
{"code": "    TimeValue::TimeValue(int hour, int minute,\n                         int second, int tzHour,\n                         int tzMinute)\n        : Value(date)\n    {\n        time_.hour = hour;\n        time_.minute = minute;\n        time_.second = second;\n        time_.tzHour = tzHour;\n        time_.tzMinute = tzMinute;\n    }", "target": 0}
{"code": "static void update_open_stateflags(struct nfs4_state *state, mode_t open_flags)\n{\n\tswitch (open_flags) {\n\t\tcase FMODE_WRITE:\n\t\t\tstate->n_wronly++;\n\t\t\tbreak;\n\t\tcase FMODE_READ:\n\t\t\tstate->n_rdonly++;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tstate->n_rdwr++;\n\t}\n\tnfs4_state_set_mode_locked(state, state->state | open_flags);\n}", "target": 1}
{"code": "static int sanitize_ptr_alu(struct bpf_verifier_env *env,\n\t\t\t    struct bpf_insn *insn,\n\t\t\t    const struct bpf_reg_state *ptr_reg,\n\t\t\t    const struct bpf_reg_state *off_reg,\n\t\t\t    struct bpf_reg_state *dst_reg,\n\t\t\t    struct bpf_insn_aux_data *tmp_aux,\n\t\t\t    const bool commit_window)\n{\n\tstruct bpf_insn_aux_data *aux = commit_window ? cur_aux(env) : tmp_aux;\n\tstruct bpf_verifier_state *vstate = env->cur_state;\n\tbool off_is_imm = tnum_is_const(off_reg->var_off);\n\tbool off_is_neg = off_reg->smin_value < 0;\n\tbool ptr_is_dst_reg = ptr_reg == dst_reg;\n\tu8 opcode = BPF_OP(insn->code);\n\tu32 alu_state, alu_limit;\n\tstruct bpf_reg_state tmp;\n\tbool ret;\n\tint err;\n\tif (can_skip_alu_sanitation(env, insn))\n\t\treturn 0;\n\tif (vstate->speculative)\n\t\tgoto do_sim;\n\terr = retrieve_ptr_limit(ptr_reg, off_reg, &alu_limit, opcode);\n\tif (err < 0)\n\t\treturn err;\n\tif (commit_window) {\n\t\talu_state = tmp_aux->alu_state;\n\t\talu_limit = abs(tmp_aux->alu_limit - alu_limit);\n\t} else {\n\t\talu_state  = off_is_neg ? BPF_ALU_NEG_VALUE : 0;\n\t\talu_state |= off_is_imm ? BPF_ALU_IMMEDIATE : 0;\n\t\talu_state |= ptr_is_dst_reg ?\n\t\t\t     BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST;\n\t}\n\terr = update_alu_sanitation_state(aux, alu_state, alu_limit);\n\tif (err < 0)\n\t\treturn err;\ndo_sim:\n\tif (commit_window)\n\t\treturn 0;\n\tif (!ptr_is_dst_reg) {\n\t\ttmp = *dst_reg;\n\t\t*dst_reg = *ptr_reg;\n\t}\n\tret = push_stack(env, env->insn_idx + 1, env->insn_idx, true);\n\tif (!ptr_is_dst_reg && ret)\n\t\t*dst_reg = tmp;\n\treturn !ret ? REASON_STACK : 0;\n}", "target": 0}
{"code": "static int is_integer(char *string)\n{\n  if (isdigit(string[0]) || string[0] == '-' || string[0] == '+') {\n    while (*++string && isdigit(*string))\n      ;                                           \n    if (!*string)\n      return 1;\n  }\n  return 0;\n}", "target": 1}
{"code": "static void exif_error_docref(const char *docref EXIFERR_DC, const image_info_type *ImageInfo, int type, const char *format, ...)\n{\n\tva_list args;\n\tva_start(args, format);\n#ifdef EXIF_DEBUG\n\t{\n\t\tchar *buf;\n\t\tspprintf(&buf, 0, \"%s(%d): %s\", _file, _line, format);\n\t\tphp_verror(docref, ImageInfo && ImageInfo->FileName ? ImageInfo->FileName:\"\", type, buf, args);\n\t\tefree(buf);\n\t}\n#else\n\tphp_verror(docref, ImageInfo && ImageInfo->FileName ? ImageInfo->FileName:\"\", type, format, args);\n#endif\n\tva_end(args);\n}", "target": 0}
{"code": "void PDPServer::notifyAboveRemoteEndpoints(\n        const ParticipantProxyData& pdata)\n{\n    static_cast<void>(pdata);\n#if HAVE_SECURITY\n    match_reliable_pdp_endpoints(pdata);\n#endif \n}", "target": 1}
{"code": "static int __init xfrm6_tunnel_spi_init(void)\n{\n\txfrm6_tunnel_spi_kmem = kmem_cache_create(\"xfrm6_tunnel_spi\",\n\t\t\t\t\t\t  sizeof(struct xfrm6_tunnel_spi),\n\t\t\t\t\t\t  0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t\t  NULL);\n\tif (!xfrm6_tunnel_spi_kmem)\n\t\treturn -ENOMEM;\n\treturn 0;\n}", "target": 1}
{"code": "static int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tint ret;\n\tmutex_lock(&dev->lock);\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\tbuf[1] &= ~(1 << offset);\n\tbuf[2] = gpio_push_pull;\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error setting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\tret = 0;\nexit:\n\tmutex_unlock(&dev->lock);\n\treturn ret < 0 ? ret : -EIO;\n}", "target": 0}
{"code": "static void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)\n{\n\tconst struct sched_class *class;\n\tif (p->sched_class == rq->curr->sched_class) {\n\t\trq->curr->sched_class->check_preempt_curr(rq, p, flags);\n\t} else {\n\t\tfor_each_class(class) {\n\t\t\tif (class == rq->curr->sched_class)\n\t\t\t\tbreak;\n\t\t\tif (class == p->sched_class) {\n\t\t\t\tresched_task(rq->curr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (test_tsk_need_resched(rq->curr))\n\t\trq->skip_clock_update = 1;\n}", "target": 1}
{"code": "void CLASS kodak_65000_load_raw()\n{\n  short buf[256];\n  int row, col, len, pred[2], ret, i;\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col+=256) {\n      pred[0] = pred[1] = 0;\n      len = MIN (256, width-col);\n      ret = kodak_65000_decode (buf, len);\n      for (i=0; i < len; i++)\n\tif ((RAW(row,col+i) =\tcurve[ret ? buf[i] :\n\t\t(pred[i & 1] += buf[i])]) >> 12) derror();\n    }\n  }\n}", "target": 1}
{"code": "_SSL_check_common_name (X509 *cert, const char *host)\n{\n\tX509_NAME *name;\n\tchar *common_name = NULL;\n\tint common_name_len;\n\tint rv = -1;\n\tGInetAddress *addr;\n\tname = X509_get_subject_name (cert);\n\tif (name == NULL)\n\t\treturn -1;\n\tcommon_name_len = X509_NAME_get_text_by_NID (name, NID_commonName, NULL, 0);\n\tif (common_name_len < 0)\n\t\treturn -1;\n\tcommon_name = calloc (common_name_len + 1, 1);\n\tif (common_name == NULL)\n\t\treturn -1;\n\tX509_NAME_get_text_by_NID (name, NID_commonName, common_name, common_name_len + 1);\n\tif (common_name_len != (int)strlen(common_name))\n\t{\n\t\tg_warning (\"NUL byte in Common Name field, probably a malicious certificate.\\n\");\n\t\trv = -2;\n\t\tgoto out;\n\t}\n\tif ((addr = g_inet_address_new_from_string (host)) != NULL)\n\t{\n\t\tif (g_strcmp0 (common_name, host) == 0)\n\t\t\trv = 0;\n\t\telse\n\t\t\trv = -1;\n\t\tg_object_unref (addr);\n\t}\n\telse if (_SSL_match_hostname (common_name, host) == 0)\n\t\trv = 0;\nout:\n\tfree(common_name);\n\treturn rv;\n}", "target": 0}
{"code": "nfs3svc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_writeargs *args)\n{\n\tunsigned int len, v, hdr, dlen;\n\tu32 max_blocksize = svc_max_payload(rqstp);\n\tstruct kvec *head = rqstp->rq_arg.head;\n\tstruct kvec *tail = rqstp->rq_arg.tail;\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = xdr_decode_hyper(p, &args->offset);\n\targs->count = ntohl(*p++);\n\targs->stable = ntohl(*p++);\n\tlen = args->len = ntohl(*p++);\n\tif ((void *)p > head->iov_base + head->iov_len)\n\t\treturn 0;\n\tif (args->count != args->len)\n\t\treturn 0;\n\thdr = (void*)p - head->iov_base;\n\tdlen = head->iov_len + rqstp->rq_arg.page_len + tail->iov_len - hdr;\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\tif (args->count > max_blocksize) {\n\t\targs->count = max_blocksize;\n\t\tlen = args->len = max_blocksize;\n\t}\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = head->iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}", "target": 0}
{"code": "static struct adpt_device* adpt_find_device(adpt_hba* pHba, u32 chan, u32 id, u64 lun)\n{\n\tstruct adpt_device* d;\n\tif (chan >= MAX_CHANNEL)\n\t\treturn NULL;\n\td = pHba->channel[chan].device[id];\n\tif(!d || d->tid == 0) {\n\t\treturn NULL;\n\t}\n\tif(d->scsi_lun == lun){\n\t\treturn d;\n\t}\n\tfor(d=d->next_lun ; d ; d = d->next_lun){\n\t\tif(d->scsi_lun == lun){\n\t\t\treturn d;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "crm_recv_remote_raw(void *session, gboolean encrypted, size_t max_recv, size_t *recv_len, int *disconnected)\n{\n    char *reply = NULL;\n    if (recv_len) {\n        *recv_len = 0;\n    }\n    if (disconnected) {\n        *disconnected = 0;\n    }\n    if (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        reply = crm_recv_tls(session, max_recv, recv_len, disconnected);\n#else\n        CRM_ASSERT(encrypted == FALSE);\n#endif\n    } else {\n        reply = crm_recv_plaintext(GPOINTER_TO_INT(session), max_recv, recv_len, disconnected);\n    }\n    if (reply == NULL || strlen(reply) == 0) {\n        crm_trace(\"Empty reply\");\n    }\n    return reply;\n}", "target": 0}
{"code": "static void handle_put_publish(struct http_conn *conn,\n\t\t\t       const struct http_msg *msg,\n\t\t\t       struct mbuf *mb, size_t clen)\n{\n\tstruct ident_entry *ie = NULL;\n\tstruct pl pl;\n\tchar *key = NULL;\n\tint err;\n\terr = re_regex(msg->prm.p, msg->prm.l, \"?pairid=[0-9]+\", &pl);\n\tif (err) {\n\t\twarning(\"invalid input\\n\");\n\t\tgoto out;\n\t}\n\tpl_strdup(&key, &pl);\n\tie = dict_lookup(verifyd.idents, key);\n\tif (!ie) {\n\t\tinfo(\"publish: pairing-id %s not found\\n\", key);\n\t\thttp_ereply(conn, 404, \"Not found\");\n\t\tgoto out;\n\t}\n\tdebug(\"publish: saving content(%zu): %b\\n\",\n\t\t  clen, mbuf_buf(mb), mbuf_get_left(mb));\n\tmbuf_strdup(mb, &ie->content.publish, clen);\n\thttp_reply(conn, 200, \"OK\", NULL);\n\thttp_conn_close(conn);\n out:\n\tmem_deref(key);\n}", "target": 0}
{"code": "int IniSection::Write (const YCPPath&p, const YCPValue&v, bool rewrite)\n{\n    if (ip->isFlat ())\n\treturn setValueFlat (p, v);\n    if (p->length() >= 1 && p->component_str (0) == \"all\")\n    {\n\treturn setAll (p, v, 1);\n    }\n    if (p->length() < 2)\n    {\n\ty2error (\"I do not know what to write to %s.\", p->toString().c_str());\n\treturn -1;\n    }\n    string s = p->component_str (0);\n    if (s == \"v\" || s == \"value\")\n\treturn setValue (p, v, 0, 1);\n    if (s == \"vc\" || s == \"value_comment\" || s == \"valuecomment\")\n      return setValue (p, v, 1, 1);\n    if (s == \"vt\" || s == \"value_type\" || s == \"valuetype\")\n      return setValue (p, v, 2, 1);\n    if (s == \"s\" || s == \"section\" || s == \"sc\" || s == \"section_comment\" || s == \"sectioncomment\")\n      return setSectionProp (p, v, 0, 1);\n    if (s == \"st\" || s == \"section_type\" || s == \"sectiontype\")\n      return setSectionProp (p, v, rewrite? 1:2, 1);\n    if (s == \"section_private\")\n      return setSectionProp (p, v, 3, 1);\n    return -1;\n}", "target": 0}
{"code": "struct nfc_llcp_local *nfc_llcp_find_local(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local;\n\tlist_for_each_entry(local, &llcp_devices, list)\n\t\tif (local->dev == dev)\n\t\t\treturn local;\n\tpr_debug(\"No device found\\n\");\n\treturn NULL;\n}", "target": 1}
{"code": "static void sanitize_string(std::string &str)\n{\n\tstr.erase(std::remove(str.begin(), str.end(), DESERIALIZE_START), str.end());\n\tstr.erase(std::remove(str.begin(), str.end(), DESERIALIZE_KV_DELIM), str.end());\n\tstr.erase(std::remove(str.begin(), str.end(), DESERIALIZE_PAIR_DELIM), str.end());\n}", "target": 0}
{"code": "        CFontFileBase(char *sFile, int nLen, bool bFreeFileData)\n        {\n            m_sFileData = m_sFile = (unsigned char *)sFile;\n            m_nLen = nLen;\n            m_bFreeFileData = bFreeFileData;\n            m_nPos = 0;\n        }", "target": 1}
{"code": "static inline Quantum ClampPixel(const MagickRealType value)\n{\n#if !defined(MAGICKCORE_HDRI_SUPPORT)\n  return((Quantum) value);\n#else\n  if (value < 0.0f)\n    return(0.0);\n  if (value >= (MagickRealType) QuantumRange)\n    return((Quantum) QuantumRange);\n  return(value);\n#endif\n}", "target": 1}
{"code": "static int tipc_nl_compat_media_dump(struct tipc_nl_compat_msg *msg,\n\t\t\t\t     struct nlattr **attrs)\n{\n\tstruct nlattr *media[TIPC_NLA_MEDIA_MAX + 1];\n\tint err;\n\tif (!attrs[TIPC_NLA_MEDIA])\n\t\treturn -EINVAL;\n\terr = nla_parse_nested(media, TIPC_NLA_MEDIA_MAX, attrs[TIPC_NLA_MEDIA],\n\t\t\t       NULL);\n\tif (err)\n\t\treturn err;\n\treturn tipc_add_tlv(msg->rep, TIPC_TLV_MEDIA_NAME,\n\t\t\t    nla_data(media[TIPC_NLA_MEDIA_NAME]),\n\t\t\t    nla_len(media[TIPC_NLA_MEDIA_NAME]));\n}", "target": 0}
{"code": "void *hashtable_get(hashtable_t *hashtable, const char *key)\n{\n    pair_t *pair;\n    size_t hash;\n    bucket_t *bucket;\n    hash = hash_str(key);\n    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n    if(!pair)\n        return NULL;\n    return pair->value;\n}", "target": 1}
{"code": "static int checkout_verify_paths(\n\tgit_repository *repo,\n\tint action,\n\tgit_diff_delta *delta)\n{\n\tunsigned int flags = GIT_PATH_REJECT_WORKDIR_DEFAULTS;\n\tif (action & CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->old_file.path, delta->old_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot remove invalid path '%s'\", delta->old_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (action & ~CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->new_file.path, delta->new_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot checkout to invalid path '%s'\", delta->new_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int command_write(struct pci_dev *dev, int offset, u16 value, void *data)\n{\n\tstruct xen_pcibk_dev_data *dev_data;\n\tint err;\n\tu16 val;\n\tstruct pci_cmd_info *cmd = data;\n\tdev_data = pci_get_drvdata(dev);\n\tif (!pci_is_enabled(dev) && is_enable_cmd(value)) {\n\t\tif (unlikely(verbose_request))\n\t\t\tprintk(KERN_DEBUG DRV_NAME \": %s: enable\\n\",\n\t\t\t       pci_name(dev));\n\t\terr = pci_enable_device(dev);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (dev_data)\n\t\t\tdev_data->enable_intx = 1;\n\t} else if (pci_is_enabled(dev) && !is_enable_cmd(value)) {\n\t\tif (unlikely(verbose_request))\n\t\t\tprintk(KERN_DEBUG DRV_NAME \": %s: disable\\n\",\n\t\t\t       pci_name(dev));\n\t\tpci_disable_device(dev);\n\t\tif (dev_data)\n\t\t\tdev_data->enable_intx = 0;\n\t}\n\tif (!dev->is_busmaster && is_master_cmd(value)) {\n\t\tif (unlikely(verbose_request))\n\t\t\tprintk(KERN_DEBUG DRV_NAME \": %s: set bus master\\n\",\n\t\t\t       pci_name(dev));\n\t\tpci_set_master(dev);\n\t}\n\tif (value & PCI_COMMAND_INVALIDATE) {\n\t\tif (unlikely(verbose_request))\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       DRV_NAME \": %s: enable memory-write-invalidate\\n\",\n\t\t\t       pci_name(dev));\n\t\terr = pci_set_mwi(dev);\n\t\tif (err) {\n\t\t\tpr_warn(\"%s: cannot enable memory-write-invalidate (%d)\\n\",\n\t\t\t\tpci_name(dev), err);\n\t\t\tvalue &= ~PCI_COMMAND_INVALIDATE;\n\t\t}\n\t}\n\tcmd->val = value;\n\tif (!permissive && (!dev_data || !dev_data->permissive))\n\t\treturn 0;\n\terr = pci_read_config_word(dev, offset, &val);\n\tif (err || val == value)\n\t\treturn err;\n\tvalue &= PCI_COMMAND_GUEST;\n\tvalue |= val & ~PCI_COMMAND_GUEST;\n\treturn pci_write_config_word(dev, offset, value);\n}", "target": 0}
{"code": "static bool ndp_msg_check_valid(struct ndp_msg *msg)\n{\n\tsize_t len = ndp_msg_payload_len(msg);\n\tenum ndp_msg_type msg_type = ndp_msg_type(msg);\n\tif (len < ndp_msg_type_info(msg_type)->raw_struct_size)\n\t\treturn false;\n\treturn true;\n}", "target": 1}
{"code": "static int unimac_mdio_probe(struct platform_device *pdev)\n{\n\tstruct unimac_mdio_pdata *pdata = pdev->dev.platform_data;\n\tstruct unimac_mdio_priv *priv;\n\tstruct device_node *np;\n\tstruct mii_bus *bus;\n\tstruct resource *r;\n\tint ret;\n\tnp = pdev->dev.of_node;\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!r)\n\t\treturn -EINVAL;\n\tpriv->base = devm_ioremap(&pdev->dev, r->start, resource_size(r));\n\tif (!priv->base) {\n\t\tdev_err(&pdev->dev, \"failed to remap register\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tpriv->mii_bus = mdiobus_alloc();\n\tif (!priv->mii_bus)\n\t\treturn -ENOMEM;\n\tbus = priv->mii_bus;\n\tbus->priv = priv;\n\tif (pdata) {\n\t\tbus->name = pdata->bus_name;\n\t\tpriv->wait_func = pdata->wait_func;\n\t\tpriv->wait_func_data = pdata->wait_func_data;\n\t\tbus->phy_mask = ~pdata->phy_mask;\n\t} else {\n\t\tbus->name = \"unimac MII bus\";\n\t\tpriv->wait_func_data = priv;\n\t\tpriv->wait_func = unimac_mdio_poll;\n\t}\n\tbus->parent = &pdev->dev;\n\tbus->read = unimac_mdio_read;\n\tbus->write = unimac_mdio_write;\n\tbus->reset = unimac_mdio_reset;\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%s-%d\", pdev->name, pdev->id);\n\tret = of_mdiobus_register(bus, np);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"MDIO bus registration failed\\n\");\n\t\tgoto out_mdio_free;\n\t}\n\tplatform_set_drvdata(pdev, priv);\n\tdev_info(&pdev->dev, \"Broadcom UniMAC MDIO bus at 0x%p\\n\", priv->base);\n\treturn 0;\nout_mdio_free:\n\tmdiobus_free(bus);\n\treturn ret;\n}", "target": 0}
{"code": "void setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !inode_capable(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}", "target": 1}
{"code": "ssl3_free(SSL *s)\n{\n\tif (s == NULL)\n\t\treturn;\n\ttls1_cleanup_key_block(s);\n\tssl3_release_read_buffer(s);\n\tssl3_release_write_buffer(s);\n\ttls_content_free(s->s3->rcontent);\n\ttls_buffer_free(s->s3->alert_fragment);\n\ttls_buffer_free(s->s3->handshake_fragment);\n\tfreezero(s->s3->hs.sigalgs, s->s3->hs.sigalgs_len);\n\tsk_X509_pop_free(s->s3->hs.peer_certs, X509_free);\n\tsk_X509_pop_free(s->s3->hs.peer_certs_no_leaf, X509_free);\n\ttls_key_share_free(s->s3->hs.key_share);\n\ttls13_secrets_destroy(s->s3->hs.tls13.secrets);\n\tfreezero(s->s3->hs.tls13.cookie, s->s3->hs.tls13.cookie_len);\n\ttls13_clienthello_hash_clear(&s->s3->hs.tls13);\n\ttls_buffer_free(s->s3->hs.tls13.quic_read_buffer);\n\tsk_X509_NAME_pop_free(s->s3->hs.tls12.ca_names, X509_NAME_free);\n\tsk_X509_pop_free(s->verified_chain, X509_free);\n\ts->verified_chain = NULL;\n\ttls1_transcript_free(s);\n\ttls1_transcript_hash_free(s);\n\tfree(s->s3->alpn_selected);\n\tfreezero(s->s3->peer_quic_transport_params,\n\t    s->s3->peer_quic_transport_params_len);\n\tfreezero(s->s3, sizeof(*s->s3));\n\ts->s3 = NULL;\n}", "target": 0}
{"code": "int sss_certmap_expand_mapping_rule(struct sss_certmap_ctx *ctx,\n                                    const uint8_t *der_cert, size_t der_size,\n                                    char **_expanded, char ***_domains)\n{\n    return expand_mapping_rule_ex(ctx, der_cert, der_size, false,\n                                  _expanded, _domains);\n}", "target": 0}
{"code": "_pyfribidi_log2vis (PyObject * self, PyObject * args, PyObject * kw)\n{\n\tPyObject *logical = NULL;\t\n\tFriBidiParType base = FRIBIDI_TYPE_RTL;\t\n\tconst char *encoding = \"utf-8\";\t\n\tint clean = 0; \n\tint reordernsm = 1; \n\tstatic char *kwargs[] =\n\t        { \"logical\", \"base_direction\", \"encoding\", \"clean\", \"reordernsm\", NULL };\n        if (!PyArg_ParseTupleAndKeywords (args, kw, \"O|isii\", kwargs,\n\t\t\t\t\t  &logical, &base, &encoding, &clean, &reordernsm))\n\t\treturn NULL;\n\tif (!(base == FRIBIDI_TYPE_RTL ||\n\t      base == FRIBIDI_TYPE_LTR || base == FRIBIDI_TYPE_ON))\n\t\treturn PyErr_Format (PyExc_ValueError,\n\t\t\t\t     \"invalid value %d: use either RTL, LTR or ON\",\n\t\t\t\t     base);\n\tif (PyUnicode_Check (logical))\n\t        return log2vis_unicode (logical, base, clean, reordernsm);\n\telse if (PyString_Check (logical))\n\t        return log2vis_encoded_string (logical, encoding, base, clean, reordernsm);\n\telse\n\t\treturn PyErr_Format (PyExc_TypeError,\n\t\t\t\t     \"expected unicode or str, not %s\",\n\t\t\t\t     logical->ob_type->tp_name);\n}", "target": 1}
{"code": "static int install_process_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tret = install_process_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret != -EEXIST ? ret : 0;\n\t}\n\treturn commit_creds(new);\n}", "target": 1}
{"code": "Item_bool_func2::add_key_fields_optimize_op(JOIN *join, KEY_FIELD **key_fields,\n                                            uint *and_level,\n                                            table_map usable_tables,\n                                            SARGABLE_PARAM **sargables,\n                                            bool equal_func)\n{\n  if (is_local_field(args[0]))\n  {\n    add_key_equal_fields(join, key_fields, *and_level, this,\n                         (Item_field*) args[0]->real_item(), equal_func,\n                         args + 1, 1, usable_tables, sargables);\n  }\n  if (is_local_field(args[1]))\n  {\n    add_key_equal_fields(join, key_fields, *and_level, this, \n                         (Item_field*) args[1]->real_item(), equal_func,\n                         args, 1, usable_tables, sargables);\n  }\n}", "target": 0}
{"code": "struct vfsmount *clone_private_mount(const struct path *path)\n{\n\tstruct mount *old_mnt = real_mount(path->mnt);\n\tstruct mount *new_mnt;\n\tif (IS_MNT_UNBINDABLE(old_mnt))\n\t\treturn ERR_PTR(-EINVAL);\n\tnew_mnt = clone_mnt(old_mnt, path->dentry, CL_PRIVATE);\n\tif (IS_ERR(new_mnt))\n\t\treturn ERR_CAST(new_mnt);\n\tnew_mnt->mnt_ns = MNT_NS_INTERNAL;\n\treturn &new_mnt->mnt;\n}", "target": 1}
{"code": "R_API RBinJavaVerificationObj *r_bin_java_verification_info_from_type(RBinJavaObj *bin, R_BIN_JAVA_STACKMAP_TYPE type, ut32 value) {\n\tRBinJavaVerificationObj *se = R_NEW0 (RBinJavaVerificationObj);\n\tif (!se) {\n\t\treturn NULL;\n\t}\n\tse->tag = type;\n\tif (se->tag == R_BIN_JAVA_STACKMAP_OBJECT) {\n\t\tse->info.obj_val_cp_idx = (ut16) value;\n\t} else if (se->tag == R_BIN_JAVA_STACKMAP_UNINIT) {\n\t\tse->info.uninit_offset = (ut16) value;\n\t}\n\treturn se;\n}", "target": 1}
{"code": "static void timerfd_remove_cancel(struct timerfd_ctx *ctx)\n{\n\tif (ctx->might_cancel) {\n\t\tctx->might_cancel = false;\n\t\tspin_lock(&cancel_lock);\n\t\tlist_del_rcu(&ctx->clist);\n\t\tspin_unlock(&cancel_lock);\n\t}\n}", "target": 1}
{"code": "pango_glyph_string_set_size (PangoGlyphString *string, gint new_len)\n{\n  g_return_if_fail (new_len >= 0);\n  while (new_len > string->space)\n    {\n      if (string->space == 0)\n\tstring->space = 1;\n      else\n\tstring->space *= 2;\n      if (string->space < 0)\n\t{\n\t  g_warning (\"glyph string length overflows maximum integer size, truncated\");\n\t  new_len = string->space = G_MAXINT - 8;\n\t}\n    }\n  string->glyphs = g_realloc (string->glyphs, string->space * sizeof (PangoGlyphInfo));\n  string->log_clusters = g_realloc (string->log_clusters, string->space * sizeof (gint));\n  string->num_glyphs = new_len;\n}", "target": 1}
{"code": "void crypto_bignum_free(struct bignum *a)\n{\n\tif (a)\n\t\tpanic();\n}", "target": 1}
{"code": "static int _dns_encode_domain(struct dns_context *context, const char *domain)\n{\n\tint num = 0;\n\tint total_len = 0;\n\tunsigned char *ptr_num = context->ptr++;\n\tint dict_offset = 0;\n\tdict_offset = _dns_get_domain_offset(context, domain);\n\ttotal_len++;\n\twhile (_dns_left_len(context) > 1 && *domain != 0) {\n\t\ttotal_len++;\n\t\tif (dict_offset >= 0) {\n\t\t\tint offset = 0xc000 | dict_offset;\n\t\t\tif (_dns_left_len(context) < 2) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t_dns_write_short(&ptr_num, offset);\n\t\t\tcontext->ptr++;\n\t\t\tptr_num = NULL;\n\t\t\treturn total_len;\n\t\t}\n\t\tif (*domain == '.') {\n\t\t\t*ptr_num = num;\n\t\t\tnum = 0;\n\t\t\tptr_num = context->ptr;\n\t\t\tdomain++;\n\t\t\tcontext->ptr++;\n\t\t\tdict_offset = _dns_get_domain_offset(context, domain);\n\t\t\tcontinue;\n\t\t}\n\t\t*context->ptr = *domain;\n\t\tnum++;\n\t\tcontext->ptr++;\n\t\tdomain++;\n\t}\n\tif (_dns_left_len(context) < 1) {\n\t\treturn -1;\n\t}\n\t*ptr_num = num;\n\tif (total_len > 1) {\n\t\t*(context->ptr) = 0;\n\t\ttotal_len++;\n\t\tcontext->ptr++;\n\t}\n\tif (_dns_left_len(context) <= 0) {\n\t\treturn -1;\n\t}\n\treturn total_len;\n}", "target": 0}
{"code": "TfLiteStatus ComputeDepthMultiplier(TfLiteContext* context,\n                                    const TfLiteTensor* input,\n                                    const TfLiteTensor* filter,\n                                    int16* depth_multiplier) {\n  int num_filter_channels = SizeOfDimension(filter, 3);\n  int num_input_channels = SizeOfDimension(input, 3);\n  TF_LITE_ENSURE_EQ(context, num_filter_channels % num_input_channels, 0);\n  *depth_multiplier = num_filter_channels / num_input_channels;\n  return kTfLiteOk;\n}", "target": 1}
{"code": " static void zgfx_history_buffer_ring_write(ZGFX_CONTEXT* zgfx, const BYTE* src, size_t count)\n {\n\tUINT32 front;\n\tif (count <= 0)\n\t\treturn;\n\tif (count > zgfx->HistoryBufferSize)\n\t{\n\t\tconst size_t residue = count - zgfx->HistoryBufferSize;\n\t\tcount = zgfx->HistoryBufferSize;\n\t\tsrc += residue;\n\t\tzgfx->HistoryIndex = (zgfx->HistoryIndex + residue) % zgfx->HistoryBufferSize;\n\t}\n\tif (zgfx->HistoryIndex + count <= zgfx->HistoryBufferSize)\n\t{\n\t\tCopyMemory(&(zgfx->HistoryBuffer[zgfx->HistoryIndex]), src, count);\n\t\tif ((zgfx->HistoryIndex += count) == zgfx->HistoryBufferSize)\n\t\t\tzgfx->HistoryIndex = 0;\n\t}\n\telse\n\t{\n\t\tfront = zgfx->HistoryBufferSize - zgfx->HistoryIndex;\n\t\tCopyMemory(&(zgfx->HistoryBuffer[zgfx->HistoryIndex]), src, front);\n\t\tCopyMemory(zgfx->HistoryBuffer, &src[front], count - front);\n\t\tzgfx->HistoryIndex = count - front;\n\t}\n}", "target": 0}
{"code": "l2tp_bearer_cap_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint32_t *ptr = (const uint32_t *)dat;\n\tif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_CAP_ANALOG_MASK) {\n\t\tND_PRINT((ndo, \"A\"));\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_CAP_DIGITAL_MASK) {\n\t\tND_PRINT((ndo, \"D\"));\n\t}\n}", "target": 1}
{"code": "static int set_msr_mce(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\tswitch (msr) {\n\tcase MSR_IA32_MCG_STATUS:\n\t\tvcpu->arch.mcg_status = data;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CTL:\n\t\tif (!(mcg_cap & MCG_CTL_P))\n\t\t\treturn 1;\n\t\tif (data != 0 && data != ~(u64)0)\n\t\t\treturn -1;\n\t\tvcpu->arch.mcg_ctl = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr >= MSR_IA32_MC0_CTL &&\n\t\t    msr < MSR_IA32_MC0_CTL + 4 * bank_num) {\n\t\t\tu32 offset = msr - MSR_IA32_MC0_CTL;\n\t\t\tif ((offset & 0x3) == 0 &&\n\t\t\t    data != 0 && (data | (1 << 10)) != ~(u64)0)\n\t\t\t\treturn -1;\n\t\t\tvcpu->arch.mce_banks[offset] = data;\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void test_openat(const char *path)\n{\n\tchar *d = strdupa(path), *f, *tmpname;\n\tint fd, fd2;\n\tf = basename(d);\n\td = dirname(d);\n\tfd = open(d, O_RDONLY);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error in openat test: could not open parent dir\\n\");\n\t\tfprintf(stderr, \"(this is expected on the second run)\\n\");\n\t\treturn;\n\t}\n\tfd2 = openat(fd, f, O_RDONLY);\n\tif (fd2 >= 0 || errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at openat of %s\\n\", f);\n\t\texit(1);\n\t}\n\tsize_t len = strlen(path) + strlen(\"/cgroup.procs\") + 1;\n\ttmpname = alloca(len);\n\tsnprintf(tmpname, len, \"%s/cgroup.procs\", f);\n\tfd2 = openat(fd, tmpname, O_RDONLY);\n\tif (fd2 >= 0 || errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at openat of %s\\n\", tmpname);\n\t\texit(1);\n\t}\n\tclose(fd);\n}", "target": 0}
{"code": "std::wstring Utf8ToUtf16(const std::string& utf8_string) {\n  return MB2WC(utf8_string, CP_UTF8);\n}", "target": 1}
{"code": "static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n#if 0\n\tjp2_pclr_t *pclr = &box->data.pclr;\n#endif\nbox = 0;\nout = 0;\n\treturn -1;\n}", "target": 1}
{"code": "static void parse_version(pj_scanner *scanner, \n                          volatile parse_context *ctx)\n{\n    ctx->last_error = PJMEDIA_SDP_EINVER;\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n    if (*(scanner->curptr+2) != '0') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n    pj_scan_skip_line(scanner);\n}", "target": 1}
{"code": "static UINT drive_process_irp_query_directory(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tconst WCHAR* path;\n\tDRIVE_FILE* file;\n\tBYTE InitialQuery;\n\tUINT32 PathLength;\n\tUINT32 FsInformationClass;\n\tif (!drive || !irp || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tStream_Read_UINT8(irp->input, InitialQuery);\n\tStream_Read_UINT32(irp->input, PathLength);\n\tStream_Seek(irp->input, 23); \n\tpath = (WCHAR*)Stream_Pointer(irp->input);\n\tif (!Stream_CheckAndLogRequiredLength(TAG, irp->input, PathLength))\n\t\treturn ERROR_INVALID_DATA;\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\tif (file == NULL)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tStream_Write_UINT32(irp->output, 0); \n\t}\n\telse if (!drive_file_query_directory(file, FsInformationClass, InitialQuery, path, PathLength,\n\t                                     irp->output))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t}\n\treturn irp->Complete(irp);\n}", "target": 0}
{"code": "mwifiex_set_wmm_params(struct mwifiex_private *priv,\n\t\t       struct mwifiex_uap_bss_param *bss_cfg,\n\t\t       struct cfg80211_ap_settings *params)\n{\n\tconst u8 *vendor_ie;\n\tconst u8 *wmm_ie;\n\tu8 wmm_oui[] = {0x00, 0x50, 0xf2, 0x02};\n\tvendor_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t    WLAN_OUI_TYPE_MICROSOFT_WMM,\n\t\t\t\t\t    params->beacon.tail,\n\t\t\t\t\t    params->beacon.tail_len);\n\tif (vendor_ie) {\n\t\twmm_ie = vendor_ie;\n\t\tif (*(wmm_ie + 1) > sizeof(struct mwifiex_types_wmm_info))\n\t\t\treturn;\n\t\tmemcpy(&bss_cfg->wmm_info, wmm_ie +\n\t\t       sizeof(struct ieee_types_header), *(wmm_ie + 1));\n\t\tpriv->wmm_enabled = 1;\n\t} else {\n\t\tmemset(&bss_cfg->wmm_info, 0, sizeof(bss_cfg->wmm_info));\n\t\tmemcpy(&bss_cfg->wmm_info.oui, wmm_oui, sizeof(wmm_oui));\n\t\tbss_cfg->wmm_info.subtype = MWIFIEX_WMM_SUBTYPE;\n\t\tbss_cfg->wmm_info.version = MWIFIEX_WMM_VERSION;\n\t\tpriv->wmm_enabled = 0;\n\t}\n\tbss_cfg->qos_info = 0x00;\n\treturn;\n}", "target": 0}
{"code": "long keyctl_update_key(key_serial_t id,\n\t\t       const void __user *_payload,\n\t\t       size_t plen)\n{\n\tkey_ref_t key_ref;\n\tvoid *payload;\n\tlong ret;\n\tret = -EINVAL;\n\tif (plen > PAGE_SIZE)\n\t\tgoto error;\n\tpayload = NULL;\n\tif (_payload) {\n\t\tret = -ENOMEM;\n\t\tpayload = kmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error;\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error2;\n\t}\n\tkey_ref = lookup_user_key(id, 0, KEY_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\tret = key_update(key_ref, payload, plen);\n\tkey_ref_put(key_ref);\nerror2:\n\tkfree(payload);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "ipv6_dup_options(struct sock *sk, struct ipv6_txoptions *opt)\n{\n\tstruct ipv6_txoptions *opt2;\n\topt2 = sock_kmalloc(sk, opt->tot_len, GFP_ATOMIC);\n\tif (opt2) {\n\t\tlong dif = (char *)opt2 - (char *)opt;\n\t\tmemcpy(opt2, opt, opt->tot_len);\n\t\tif (opt2->hopopt)\n\t\t\t*((char **)&opt2->hopopt) += dif;\n\t\tif (opt2->dst0opt)\n\t\t\t*((char **)&opt2->dst0opt) += dif;\n\t\tif (opt2->dst1opt)\n\t\t\t*((char **)&opt2->dst1opt) += dif;\n\t\tif (opt2->srcrt)\n\t\t\t*((char **)&opt2->srcrt) += dif;\n\t\tatomic_set(&opt2->refcnt, 1);\n\t}\n\treturn opt2;\n}", "target": 0}
{"code": "yy_symbol_value_print (FILE *yyo,\n                       yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp, void *parm)\n{\n  FILE *yyoutput = yyo;\n  YY_USE (yyoutput);\n  YY_USE (yylocationp);\n  YY_USE (parm);\n  if (!yyvaluep)\n    return;\n# ifdef YYPRINT\n  if (yykind < YYNTOKENS)\n    YYPRINT (yyo, yytoknum[yykind], *yyvaluep);\n# endif\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  YY_USE (yykind);\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n}", "target": 1}
{"code": "int quicklistPushHead(quicklist *quicklist, void *value, size_t sz) {\n    quicklistNode *orig_head = quicklist->head;\n    assert(sz < UINT32_MAX); \n    if (likely(\n            _quicklistNodeAllowInsert(quicklist->head, quicklist->fill, sz))) {\n        quicklist->head->zl =\n            ziplistPush(quicklist->head->zl, value, sz, ZIPLIST_HEAD);\n        quicklistNodeUpdateSz(quicklist->head);\n    } else {\n        quicklistNode *node = quicklistCreateNode();\n        node->zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);\n        quicklistNodeUpdateSz(node);\n        _quicklistInsertNodeBefore(quicklist, quicklist->head, node);\n    }\n    quicklist->count++;\n    quicklist->head->count++;\n    return (orig_head != quicklist->head);\n}", "target": 0}
{"code": "tvb_get_manuf_name_if_known(tvbuff_t *tvb, gint offset)\n{\n    return get_manuf_name_if_known(tvb_get_ptr(tvb, offset, 3));\n}", "target": 1}
{"code": "int addattr32(struct nlmsghdr *n, int maxlen, int type, __u32 data)\n{\n\treturn addattr_l(n, maxlen, type, &data, sizeof(__u32));\n}", "target": 0}
{"code": "MagickExport void *ResizeQuantumMemory(void *memory,const size_t count,\n  const size_t quantum)\n{\n  size_t\n    extent;\n  if (CheckMemoryOverflow(count,quantum) != MagickFalse)\n    {\n      memory=RelinquishMagickMemory(memory);\n      return((void *) NULL);\n    }\n  extent=count*quantum;\n  return(ResizeMagickMemory(memory,extent));\n}", "target": 1}
{"code": "void gnrc_sixlowpan_iphc_send(gnrc_pktsnip_t *pkt, void *ctx, unsigned page)\n{\n    gnrc_netif_hdr_t *netif_hdr = pkt->data;\n    gnrc_netif_t *netif = gnrc_netif_hdr_get_netif(netif_hdr);\n    gnrc_pktsnip_t *tmp;\n    size_t orig_datagram_size = gnrc_pkt_len(pkt->next);\n    ipv6_hdr_t *ipv6_hdr = pkt->next->data;\n    ipv6_addr_t dst;\n    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD)) {\n        dst = ipv6_hdr->dst;    \n    }\n    if ((tmp = _iphc_encode(pkt, pkt->data, netif))) {\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) && (ctx != NULL) &&\n            (gnrc_sixlowpan_frag_minfwd_frag_iphc(tmp, orig_datagram_size, &dst,\n                                                  ctx) == 0)) {\n            DEBUG(\"6lo iphc minfwd: putting slack in first fragment\\n\");\n            return;\n        }\n        gnrc_sixlowpan_multiplex_by_size(tmp, orig_datagram_size, netif, page);\n    }\n    else {\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD)) {\n            gnrc_sixlowpan_frag_fb_t *fb = ctx;\n            if (fb->pkt == pkt) {\n                fb->pkt = NULL;\n            }\n        }\n        gnrc_pktbuf_release(pkt);\n    }\n}", "target": 0}
{"code": "GF_HEVCConfig *gf_isom_hevc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tif (gf_isom_get_reference_count(the_file, trackNumber, GF_ISOM_REF_TBAS)) {\n\t\tu32 ref_track;\n\t\tGF_Err e = gf_isom_get_reference(the_file, trackNumber, GF_ISOM_REF_TBAS, 1, &ref_track);\n\t\tif (e == GF_OK) {\n\t\t\ttrackNumber = ref_track;\n\t\t}\n\t}\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tif (gf_isom_get_hevc_lhvc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_HEVCTYPE_NONE)\n\t\treturn NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return NULL;\n\tif (!entry->hevc_config) return NULL;\n\treturn HEVC_DuplicateConfig(entry->hevc_config->config);\n}", "target": 0}
{"code": "aodv_extension(netdissect_options *ndo,\n               const struct aodv_ext *ep, u_int length)\n{\n\tconst struct aodv_hello *ah;\n\tND_TCHECK(*ep);\n\tswitch (ep->type) {\n\tcase AODV_EXT_HELLO:\n\t\tah = (const struct aodv_hello *)(const void *)ep;\n\t\tND_TCHECK(*ah);\n\t\tif (length < sizeof(struct aodv_hello))\n\t\t\tgoto trunc;\n\t\tif (ep->length < 4) {\n\t\t\tND_PRINT((ndo, \"\\n\\text HELLO - bad length %u\", ep->length));\n\t\t\tbreak;\n\t\t}\n\t\tND_PRINT((ndo, \"\\n\\text HELLO %ld ms\",\n\t\t    (unsigned long)EXTRACT_32BITS(&ah->interval)));\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"\\n\\text %u %u\", ep->type, ep->length));\n\t\tbreak;\n\t}\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \" [|hello]\"));\n}", "target": 0}
{"code": "static gboolean is_correct_filename(const char *value)\n{\n    return printable_str(value) && !strchr(value, '/') && !strchr(value, '.');\n}", "target": 1}
{"code": "int ntlm_read_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn -1;\n\tStream_Read_UINT16(s, fields->Len); \n\tStream_Read_UINT16(s, fields->MaxLen); \n\tStream_Read_UINT32(s, fields->BufferOffset); \n\treturn 1;\n}", "target": 1}
{"code": "srs_timestamp_check(srs_t *srs, const char *stamp)\n{\n\tconst char\t*sp;\n\tchar\t\t*bp;\n\tint\t\t\t off;\n\ttime_t\t\t now;\n\ttime_t\t\t then;\n\tif (strlen(stamp) != 2) return SRS_ETIMESTAMPOUTOFDATE;\n\tthen = 0;\n\tfor (sp = stamp; *sp; sp++) {\n\t\tbp = strchr(SRS_TIME_BASECHARS, toupper(*sp));\n\t\tif (bp == NULL)\n\t\t\treturn SRS_EBADTIMESTAMPCHAR;\n\t\toff = bp - SRS_TIME_BASECHARS;\n\t\tthen = (then << SRS_TIME_BASEBITS) | off;\n\t}\n\ttime(&now);\n\tnow = (now / SRS_TIME_PRECISION) % SRS_TIME_SLOTS;\n\twhile (now < then)\n\t\tnow = now + SRS_TIME_SLOTS;\n\tif (now <= then + srs->maxage)\n\t\treturn SRS_SUCCESS;\n\treturn SRS_ETIMESTAMPOUTOFDATE;\n}", "target": 0}
{"code": "\tvoid initialize(const string &path, bool owner) {\n\t\tTRACE_POINT();\n\t\tthis->path  = path;\n\t\tthis->owner = owner;\n\t\tif (owner) {\n\t\t\tswitch (getFileTypeNoFollowSymlinks(path)) {\n\t\t\tcase FT_NONEXISTANT:\n\t\t\t\tcreateDirectory(path);\n\t\t\t\tbreak;\n\t\t\tcase FT_DIRECTORY:\n\t\t\t\tverifyDirectoryPermissions(path);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow RuntimeException(\"'\" + path + \"' already exists, and is not a directory\");\n\t\t\t}\n\t\t} else if (getFileType(path) != FT_DIRECTORY) {\n\t\t\tthrow RuntimeException(\"Server instance directory '\" + path +\n\t\t\t\t\"' does not exist\");\n\t\t}\n\t}", "target": 1}
{"code": "static void dump_completed_IO(struct inode * inode)\n{\n#ifdef\tEXT4_DEBUG\n\tstruct list_head *cur, *before, *after;\n\text4_io_end_t *io, *io0, *io1;\n\tunsigned long flags;\n\tif (list_empty(&EXT4_I(inode)->i_completed_io_list)){\n\t\text4_debug(\"inode %lu completed_io list is empty\\n\", inode->i_ino);\n\t\treturn;\n\t}\n\text4_debug(\"Dump inode %lu completed_io list \\n\", inode->i_ino);\n\tspin_lock_irqsave(&EXT4_I(inode)->i_completed_io_lock, flags);\n\tlist_for_each_entry(io, &EXT4_I(inode)->i_completed_io_list, list){\n\t\tcur = &io->list;\n\t\tbefore = cur->prev;\n\t\tio0 = container_of(before, ext4_io_end_t, list);\n\t\tafter = cur->next;\n\t\tio1 = container_of(after, ext4_io_end_t, list);\n\t\text4_debug(\"io 0x%p from inode %lu,prev 0x%p,next 0x%p\\n\",\n\t\t\t    io, inode->i_ino, io0, io1);\n\t}\n\tspin_unlock_irqrestore(&EXT4_I(inode)->i_completed_io_lock, flags);\n#endif\n}", "target": 0}
{"code": "LUA_API void lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {\n  if (func == NULL || mask == 0) {  \n    mask = 0;\n    func = NULL;\n  }\n  if (isLua(L->ci))\n    L->oldpc = L->ci->u.l.savedpc;\n  L->hook = func;\n  L->basehookcount = count;\n  resethookcount(L);\n  L->hookmask = cast_byte(mask);\n  if (mask)\n    settraps(L->ci);  \n}", "target": 1}
{"code": "Status FractionalPoolShapeFn(InferenceContext* c) {\n  ShapeHandle input;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 4, &input));\n  std::vector<float> pooling_ratio;\n  TF_RETURN_IF_ERROR(c->GetAttr(\"pooling_ratio\", &pooling_ratio));\n  if (pooling_ratio.size() != 4) {\n    return errors::InvalidArgument(\n        \"pooling_ratio field must specify 4 dimensions\");\n  }\n  std::vector<DimensionHandle> output_dims;\n  for (int i = 0; i < 4; ++i) {\n    DimensionHandle d = c->Dim(input, i);\n    if (c->ValueKnown(d)) {\n      auto val =\n          static_cast<int64_t>(std::floor(c->Value(d) / pooling_ratio[i]));\n      if (val < 0) {\n        return errors::InvalidArgument(\"Size computed for dim \", i,\n                                       \" is negative: \", val);\n      }\n      output_dims.push_back(c->MakeDim(val));\n    } else {\n      output_dims.push_back(c->UnknownDim());\n    }\n  }\n  for (std::size_t i = 0; i < pooling_ratio.size(); ++i) {\n    if (pooling_ratio[i] < 1) {\n      return errors::InvalidArgument(\n          \"pooling_ratio cannot be smaller than 1, got: \", pooling_ratio[i]);\n    }\n  }\n  c->set_output(0, c->MakeShape(output_dims));\n  c->set_output(1, c->Vector(output_dims[1]));\n  c->set_output(2, c->Vector(output_dims[2]));\n  return OkStatus();\n}", "target": 0}
{"code": "static int sip_endpoint_identifier_str2type(const char *str)\n{\n\tint method;\n\tif (!strcasecmp(str, \"username\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_USERNAME;\n\t} else if (!strcasecmp(str, \"auth_username\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_AUTH_USERNAME;\n\t} else if (!strcasecmp(str, \"ip\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_IP;\n\t} else if (!strcasecmp(str, \"header\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_HEADER;\n\t} else if (!strcasecmp(str, \"request_uri\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_REQUEST_URI;\n\t} else if (!strcasecmp(str, \"transport\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_TRANSPORT;\n\t} else {\n\t\tmethod = -1;\n\t}\n\treturn method;\n}", "target": 1}
{"code": "static int mwifiex_update_vs_ie(const u8 *ies, int ies_len,\n\t\t\t\tstruct mwifiex_ie **ie_ptr, u16 mask,\n\t\t\t\tunsigned int oui, u8 oui_type)\n{\n\tstruct ieee_types_header *vs_ie;\n\tstruct mwifiex_ie *ie = *ie_ptr;\n\tconst u8 *vendor_ie;\n\tvendor_ie = cfg80211_find_vendor_ie(oui, oui_type, ies, ies_len);\n\tif (vendor_ie) {\n\t\tif (!*ie_ptr) {\n\t\t\t*ie_ptr = kzalloc(sizeof(struct mwifiex_ie),\n\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!*ie_ptr)\n\t\t\t\treturn -ENOMEM;\n\t\t\tie = *ie_ptr;\n\t\t}\n\t\tvs_ie = (struct ieee_types_header *)vendor_ie;\n\t\tif (le16_to_cpu(ie->ie_length) + vs_ie->len + 2 >\n\t\t\tIEEE_MAX_IE_SIZE)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(ie->ie_buffer + le16_to_cpu(ie->ie_length),\n\t\t       vs_ie, vs_ie->len + 2);\n\t\tle16_unaligned_add_cpu(&ie->ie_length, vs_ie->len + 2);\n\t\tie->mgmt_subtype_mask = cpu_to_le16(mask);\n\t\tie->ie_index = cpu_to_le16(MWIFIEX_AUTO_IDX_MASK);\n\t}\n\t*ie_ptr = ie;\n\treturn 0;\n}", "target": 0}
{"code": "static int rtnl_fill_link_ifmap(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct rtnl_link_ifmap map = {\n\t\t.mem_start   = dev->mem_start,\n\t\t.mem_end     = dev->mem_end,\n\t\t.base_addr   = dev->base_addr,\n\t\t.irq         = dev->irq,\n\t\t.dma         = dev->dma,\n\t\t.port        = dev->if_port,\n\t};\n\tif (nla_put(skb, IFLA_MAP, sizeof(map), &map))\n\t\treturn -EMSGSIZE;\n\treturn 0;\n}", "target": 1}
{"code": "long jpc_bitstream_getbits(jpc_bitstream_t *bitstream, int n)\n{\n\tlong v;\n\tint u;\n\tassert(n >= 0 && n < 32);\n\tv = 0;\n\twhile (--n >= 0) {\n\t\tif ((u = jpc_bitstream_getbit(bitstream)) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tv = (v << 1) | u;\n\t}\n\treturn v;\n}", "target": 1}
{"code": "static unsigned long get_ctl_id_hash(const struct snd_ctl_elem_id *id)\n{\n\tint i;\n\tunsigned long h;\n\th = id->iface;\n\th = MULTIPLIER * h + id->device;\n\th = MULTIPLIER * h + id->subdevice;\n\tfor (i = 0; i < SNDRV_CTL_ELEM_ID_NAME_MAXLEN && id->name[i]; i++)\n\t\th = MULTIPLIER * h + id->name[i];\n\th = MULTIPLIER * h + id->index;\n\th &= LONG_MAX;\n\treturn h;\n}", "target": 0}
{"code": "static inline int unicode_cp_is_allowed(unsigned uni_cp, int document_type)\n{\n\tswitch (document_type) {\n\tcase ENT_HTML_DOC_HTML401:\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0x7E) ||\n\t\t\t(uni_cp == 0x0A || uni_cp == 0x09 || uni_cp == 0x0D) ||\n\t\t\t(uni_cp >= 0xA0 && uni_cp <= 0xD7FF) ||\n\t\t\t(uni_cp >= 0xE000 && uni_cp <= 0x10FFFF);\n\tcase ENT_HTML_DOC_HTML5:\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0x7E) ||\n\t\t\t(uni_cp >= 0x09 && uni_cp <= 0x0D && uni_cp != 0x0B) || \n\t\t\t(uni_cp >= 0xA0 && uni_cp <= 0xD7FF) ||\n\t\t\t(uni_cp >= 0xE000 && uni_cp <= 0x10FFFF &&\n\t\t\t\t((uni_cp & 0xFFFF) < 0xFFFE) && \n\t\t\t\t(uni_cp < 0xFDD0 || uni_cp > 0xFDEF)); \n\tcase ENT_HTML_DOC_XHTML:\n\tcase ENT_HTML_DOC_XML1:\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0xD7FF) ||\n\t\t\t(uni_cp == 0x0A || uni_cp == 0x09 || uni_cp == 0x0D) ||\n\t\t\t(uni_cp >= 0xE000 && uni_cp <= 0x10FFFF && uni_cp != 0xFFFE && uni_cp != 0xFFFF);\n\tdefault:\n\t\treturn 1;\n\t}\n}", "target": 1}
{"code": "raptor_libxml_getEntity(void* user_data, const xmlChar *name) {\n  raptor_sax2* sax2 = (raptor_sax2*)user_data;\n  return libxml2_getEntity(sax2->xc, name);\n}", "target": 1}
{"code": "ext4_xattr_cache_insert(struct mb_cache *ext4_mb_cache, struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(BHDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\tce = mb_cache_entry_alloc(ext4_mb_cache, GFP_NOFS);\n\tif (!ce) {\n\t\tea_bdebug(bh, \"out of memory\");\n\t\treturn;\n\t}\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache\");\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x]\", (int)hash);\n\t\tmb_cache_entry_release(ce);\n\t}\n}", "target": 1}
{"code": "void Filter::onSoftPerTryTimeout(UpstreamRequest& upstream_request) {\n  ASSERT(!upstream_request.retried());\n  updateOutlierDetection(Upstream::Outlier::Result::LocalOriginTimeout, upstream_request,\n                         absl::optional<uint64_t>(enumToInt(timeout_response_code_)));\n  upstream_request.outlierDetectionTimeoutRecorded(true);\n  if (!downstream_response_started_ && retry_state_) {\n    RetryStatus retry_status = retry_state_->shouldHedgeRetryPerTryTimeout(\n        [this, can_use_http3 = upstream_request.upstreamStreamOptions().can_use_http3_]() -> void {\n          doRetry( false, can_use_http3, TimeoutRetry::Yes);\n        });\n    if (retry_status == RetryStatus::Yes) {\n      runRetryOptionsPredicates(upstream_request);\n      pending_retries_++;\n      upstream_request.retried(true);\n    } else if (retry_status == RetryStatus::NoOverflow) {\n      callbacks_->streamInfo().setResponseFlag(StreamInfo::CoreResponseFlag::UpstreamOverflow);\n    } else if (retry_status == RetryStatus::NoRetryLimitExceeded) {\n      callbacks_->streamInfo().setResponseFlag(\n          StreamInfo::CoreResponseFlag::UpstreamRetryLimitExceeded);\n    }\n  }\n}", "target": 0}
{"code": "fr_command_cpio_get_capabilities (FrCommand  *comm,\n\t\t\t          const char *mime_type,\n\t\t\t\t  gboolean    check_command)\n{\n\tFrCommandCaps capabilities;\n\tcapabilities = FR_COMMAND_CAN_ARCHIVE_MANY_FILES;\n\tif (is_program_available (CPIO_PATH, check_command))\n\t\tcapabilities |= FR_COMMAND_CAN_READ;\n\treturn capabilities;\n}", "target": 1}
{"code": "  Status BuildInputArgIndex(const OpDef::ArgDef& arg_def, AttrSlice attr_values,\n                            const FunctionDef::ArgAttrs* arg_attrs,\n                            bool ints_on_device,\n                            int64_t resource_arg_unique_id) {\n    bool is_type_list;\n    DataTypeVector dtypes;\n    TF_RETURN_IF_ERROR(\n        ArgNumType(attr_values, arg_def, &is_type_list, &dtypes));\n    CHECK_GE(dtypes.size(), size_t{1});\n    int arg_index = result_.nodes.size();\n    TF_RETURN_IF_ERROR(\n        AddItem(arg_def.name(), {true, arg_index, 0, is_type_list, dtypes}));\n    for (size_t i = 0; i < dtypes.size(); ++i) {\n      TF_RETURN_IF_ERROR(AddItem(strings::StrCat(arg_def.name(), \":\", i),\n                                 {true, arg_index, 0, false, {dtypes[i]}}));\n      DCHECK_EQ(arg_index, result_.nodes.size());\n      string name = arg_def.name();\n      if (dtypes.size() > 1) {\n        strings::StrAppend(&name, \"_\", i);\n      }\n      NodeDef* gnode = AddNode(name);\n      if (ints_on_device && dtypes[i] == DataType::DT_INT32) {\n        gnode->set_op(FunctionLibraryDefinition::kDeviceArgOp);\n      } else {\n        gnode->set_op(FunctionLibraryDefinition::kArgOp);\n      }\n      DataType dtype = arg_def.is_ref() ? MakeRefType(dtypes[i]) : dtypes[i];\n      AddAttr(\"T\", dtype, gnode);\n      AddAttr(\"index\", arg_index, gnode);\n      if (resource_arg_unique_id >= 0) {\n        AddAttr(\"_resource_arg_unique_id\", resource_arg_unique_id, gnode);\n      }\n      if (arg_attrs) {\n        for (const auto& arg_attr : arg_attrs->attr()) {\n          AddAttr(arg_attr.first, arg_attr.second, gnode->mutable_attr());\n        }\n      }\n      result_.arg_types.push_back(dtypes[i]);\n      ++arg_index;\n    }\n    return Status::OK();\n  }", "target": 1}
{"code": "static void __init deferred_free_range(unsigned long pfn,\n\t\t\t\t       unsigned long nr_pages)\n{\n\tstruct page *page;\n\tunsigned long i;\n\tif (!nr_pages)\n\t\treturn;\n\tpage = pfn_to_page(pfn);\n\tif (nr_pages == pageblock_nr_pages &&\n\t    (pfn & (pageblock_nr_pages - 1)) == 0) {\n\t\tset_pageblock_migratetype(page, MIGRATE_MOVABLE);\n\t\t__free_pages_boot_core(page, pageblock_order);\n\t\treturn;\n\t}\n\tfor (i = 0; i < nr_pages; i++, page++, pfn++) {\n\t\tif ((pfn & (pageblock_nr_pages - 1)) == 0)\n\t\t\tset_pageblock_migratetype(page, MIGRATE_MOVABLE);\n\t\t__free_pages_boot_core(page, 0);\n\t}\n}", "target": 0}
{"code": "static inline int sector_in_part(struct hd_struct *part, sector_t sector)\n{\n\treturn part->start_sect <= sector &&\n\t\tsector < part->start_sect + part_nr_sects_read(part);\n}", "target": 0}
{"code": "static int em_ret_far(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned long eip, cs;\n\tu16 old_cs;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\tstruct desc_struct old_desc, new_desc;\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tops->get_segment(ctxt, &old_cs, &old_desc, NULL,\n\t\t\t\t VCPU_SREG_CS);\n\trc = emulate_pop(ctxt, &eip, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = emulate_pop(ctxt, &cs, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tif (ctxt->mode >= X86EMUL_MODE_PROT16 && (cs & 3) > cpl)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\trc = __load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS, cpl,\n\t\t\t\t       X86_TRANSFER_RET,\n\t\t\t\t       &new_desc);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = assign_eip_far(ctxt, eip, &new_desc);\n\tif (rc != X86EMUL_CONTINUE) {\n\t\tWARN_ON(ctxt->mode != X86EMUL_MODE_PROT64);\n\t\tops->set_segment(ctxt, old_cs, &old_desc, 0, VCPU_SREG_CS);\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "vrrp_tfile_end_handler(void)\n{\n\tvrrp_tracked_file_t *tfile = LIST_TAIL_DATA(vrrp_data->vrrp_track_files);\n\tstruct stat statb;\n\tFILE *tf;\n\tint ret;\n\tif (!tfile->file_path) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"No file set for track_file %s - removing\", tfile->fname);\n\t\tfree_list_element(vrrp_data->vrrp_track_files, vrrp_data->vrrp_track_files->tail);\n\t\treturn;\n\t}\n\tif (track_file_init == TRACK_FILE_NO_INIT)\n\t\treturn;\n\tret = stat(tfile->file_path, &statb);\n\tif (!ret) {\n\t\tif (track_file_init == TRACK_FILE_CREATE) {\n\t\t\treturn;\n\t\t}\n\t\tif ((statb.st_mode & S_IFMT) != S_IFREG) {\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Cannot initialise track file %s - it is not a regular file\", tfile->fname);\n\t\t\treturn;\n\t\t}\n\t\tif (reload)\n\t\t\treturn;\n\t}\n\tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n\t\tif ((tf = fopen(tfile->file_path, \"w\"))) {\n\t\t\tfprintf(tf, \"%d\\n\", track_file_init_value);\n\t\t\tfclose(tf);\n\t\t}\n\t\telse\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Unable to initialise track file %s\", tfile->fname);\n\t}\n}", "target": 1}
{"code": "void hostap_setup_dev(struct net_device *dev, local_info_t *local,\n\t\t      int type)\n{\n\tstruct hostap_interface *iface;\n\tiface = netdev_priv(dev);\n\tether_setup(dev);\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tif (iface) {\n\t\tiface->wireless_data.spy_data = &iface->spy_data;\n\t\tdev->wireless_data = &iface->wireless_data;\n\t}\n\tdev->wireless_handlers = &hostap_iw_handler_def;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\tswitch(type) {\n\tcase HOSTAP_INTERFACE_AP:\n\t\tdev->tx_queue_len = 0;\t\n\t\tdev->netdev_ops = &hostap_mgmt_netdev_ops;\n\t\tdev->type = ARPHRD_IEEE80211;\n\t\tdev->header_ops = &hostap_80211_ops;\n\t\tbreak;\n\tcase HOSTAP_INTERFACE_MASTER:\n\t\tdev->netdev_ops = &hostap_master_ops;\n\t\tbreak;\n\tdefault:\n\t\tdev->tx_queue_len = 0;\t\n\t\tdev->netdev_ops = &hostap_netdev_ops;\n\t}\n\tdev->mtu = local->mtu;\n\tSET_ETHTOOL_OPS(dev, &prism2_ethtool_ops);\n}", "target": 0}
{"code": "\tCxFile(void) { };", "target": 1}
{"code": "static std::string make_relative_path(const std::string& path) {\n  if (path.empty()) {\n    return path;\n  }\n  std::string canonical(FileUtil::canonicalize(path));\n  if (FileUtil::isDirSeparator(canonical[0])) {\n    return canonical.substr(1);\n  }\n  std::string relative(canonical);\n  int idx = canonical.length() - 1;\n  while (1) {\n    while (idx > 0 && !(FileUtil::isDirSeparator(canonical[idx]))) {\n      idx--;\n    }\n    if (idx == 0) {\n      return canonical;\n    }\n    if (idx >= 1 && (canonical[idx - 1] == '.' || canonical[idx - 1] == ':')) {\n      relative = canonical.substr(idx + 1);\n      break;\n    }\n    idx--;\n  }\n  return relative;\n}", "target": 0}
{"code": "lha_read_file_header_1(struct archive_read *a, struct lha *lha)\n{\n\tconst unsigned char *p;\n\tsize_t extdsize;\n\tint i, err, err2;\n\tint namelen, padding;\n\tunsigned char headersum, sum_calculated;\n\terr = ARCHIVE_OK;\n\tif ((p = __archive_read_ahead(a, H1_FIXED_SIZE, NULL)) == NULL)\n\t\treturn (truncated_error(a));\n\tlha->header_size = p[H1_HEADER_SIZE_OFFSET] + 2;\n\theadersum = p[H1_HEADER_SUM_OFFSET];\n\tlha->compsize = archive_le32dec(p + H1_COMP_SIZE_OFFSET);\n\tlha->origsize = archive_le32dec(p + H1_ORIG_SIZE_OFFSET);\n\tlha->mtime = lha_dos_time(p + H1_DOS_TIME_OFFSET);\n\tnamelen = p[H1_NAME_LEN_OFFSET];\n\tpadding = ((int)lha->header_size) - H1_FIXED_SIZE - namelen;\n\tif (namelen > 230 || padding < 0)\n\t\tgoto invalid;\n\tif ((p = __archive_read_ahead(a, lha->header_size, NULL)) == NULL)\n\t\treturn (truncated_error(a));\n\tfor (i = 0; i < namelen; i++) {\n\t\tif (p[i + H1_FILE_NAME_OFFSET] == 0xff)\n\t\t\tgoto invalid;\n\t}\n\tarchive_strncpy(&lha->filename, p + H1_FILE_NAME_OFFSET, namelen);\n\tlha->crc = archive_le16dec(p + H1_FILE_NAME_OFFSET + namelen);\n\tlha->setflag |= CRC_IS_SET;\n\tsum_calculated = lha_calcsum(0, p, 2, lha->header_size - 2);\n\t__archive_read_consume(a, lha->header_size - 2);\n\terr2 = lha_read_file_extended_header(a, lha, NULL, 2,\n\t    (size_t)(lha->compsize + 2), &extdsize);\n\tif (err2 < ARCHIVE_WARN)\n\t\treturn (err2);\n\tif (err2 < err)\n\t\terr = err2;\n\tlha->compsize -= extdsize - 2;\n\tif (lha->compsize < 0)\n\t\tgoto invalid;\t\n\tif (sum_calculated != headersum) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"LHa header sum error\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\treturn (err);\ninvalid:\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t    \"Invalid LHa header\");\n\treturn (ARCHIVE_FATAL);\n}", "target": 0}
{"code": "static int snd_hrtimer_start(struct snd_timer *t)\n{\n\tstruct snd_hrtimer *stime = t->private_data;\n\tatomic_set(&stime->running, 0);\n\thrtimer_cancel(&stime->hrt);\n\thrtimer_start(&stime->hrt, ns_to_ktime(t->sticks * resolution),\n\t\t      HRTIMER_MODE_REL);\n\tatomic_set(&stime->running, 1);\n\treturn 0;\n}", "target": 1}
{"code": "int ath9k_wmi_cmd(struct wmi *wmi, enum wmi_cmd_id cmd_id,\n\t\t  u8 *cmd_buf, u32 cmd_len,\n\t\t  u8 *rsp_buf, u32 rsp_len,\n\t\t  u32 timeout)\n{\n\tstruct ath_hw *ah = wmi->drv_priv->ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tu16 headroom = sizeof(struct htc_frame_hdr) +\n\t\t       sizeof(struct wmi_cmd_hdr);\n\tstruct sk_buff *skb;\n\tunsigned long time_left;\n\tint ret = 0;\n\tif (ah->ah_flags & AH_UNPLUGGED)\n\t\treturn 0;\n\tskb = alloc_skb(headroom + cmd_len, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tskb_reserve(skb, headroom);\n\tif (cmd_len != 0 && cmd_buf != NULL) {\n\t\tskb_put_data(skb, cmd_buf, cmd_len);\n\t}\n\tmutex_lock(&wmi->op_mutex);\n\tif (unlikely(wmi->stopped)) {\n\t\tret = -EPROTO;\n\t\tgoto out;\n\t}\n\twmi->cmd_rsp_buf = rsp_buf;\n\twmi->cmd_rsp_len = rsp_len;\n\tret = ath9k_wmi_cmd_issue(wmi, skb, cmd_id, cmd_len);\n\tif (ret)\n\t\tgoto out;\n\ttime_left = wait_for_completion_timeout(&wmi->cmd_wait, timeout);\n\tif (!time_left) {\n\t\tath_dbg(common, WMI, \"Timeout waiting for WMI command: %s\\n\",\n\t\t\twmi_cmd_to_name(cmd_id));\n\t\tmutex_unlock(&wmi->op_mutex);\n\t\tkfree_skb(skb);\n\t\treturn -ETIMEDOUT;\n\t}\n\tmutex_unlock(&wmi->op_mutex);\n\treturn 0;\nout:\n\tath_dbg(common, WMI, \"WMI failure for: %s\\n\", wmi_cmd_to_name(cmd_id));\n\tmutex_unlock(&wmi->op_mutex);\n\tkfree_skb(skb);\n\treturn ret;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& data = context->input(0);\n    const Tensor& segment_ids = context->input(1);\n    const Tensor& num_segments = context->input(2);\n    if (!UnsortedSegmentReductionDoValidation(this, context, data, segment_ids,\n                                              num_segments)) {\n      return;\n    }\n    const auto segment_flat = segment_ids.flat<Index>();\n    const Index output_rows = internal::SubtleMustCopy(static_cast<Index>(\n        num_segments.dtype() == DT_INT32 ? num_segments.scalar<int32>()()\n                                         : num_segments.scalar<int64>()()));\n    OP_REQUIRES(context, output_rows >= 0,\n                errors::InvalidArgument(\"Input num_segments == \", output_rows,\n                                        \" must not be negative.\"));\n    TensorShape output_shape;\n    output_shape.AddDim(output_rows);\n    for (int i = segment_ids.dims(); i < data.dims(); i++) {\n      output_shape.AddDim(data.dim_size(i));\n    }\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n    auto output_flat = output->flat_outer_dims<T>();\n    auto data_ptr = data.template flat<T>().data();\n    reduction_functor_(context, output_rows, segment_ids.shape(), segment_flat,\n                       data.NumElements(), data_ptr, output_flat);\n  }", "target": 1}
{"code": "void LanLinkProvider::udpBroadcastReceived()\n{\n    while (m_udpSocket.hasPendingDatagrams()) {\n        QByteArray datagram;\n        datagram.resize(m_udpSocket.pendingDatagramSize());\n        QHostAddress sender;\n        m_udpSocket.readDatagram(datagram.data(), datagram.size(), &sender);\n        if (sender.isLoopback() && !m_testMode)\n            continue;\n        NetworkPacket* receivedPacket = new NetworkPacket(QLatin1String(\"\"));\n        bool success = NetworkPacket::unserialize(datagram, receivedPacket);\n        if (!success) {\n            qCDebug(KDECONNECT_CORE) << \"Could not unserialize UDP packet\";\n            delete receivedPacket;\n            continue;\n        }\n        if (receivedPacket->type() != PACKET_TYPE_IDENTITY) {\n            qCDebug(KDECONNECT_CORE) << \"Received a UDP packet of wrong type\" << receivedPacket->type();\n            delete receivedPacket;\n            continue;\n        }\n        if (receivedPacket->get<QString>(QStringLiteral(\"deviceId\")) == KdeConnectConfig::instance().deviceId()) {\n            delete receivedPacket;\n            continue;\n        }\n        int tcpPort = receivedPacket->get<int>(QStringLiteral(\"tcpPort\"));\n        if (tcpPort < MIN_TCP_PORT || tcpPort > MAX_TCP_PORT) {\n            qCDebug(KDECONNECT_CORE) << \"TCP port outside of kdeconnect's range\";\n            delete receivedPacket;\n            continue;\n        }\n        if (m_receivedIdentityPackets.size() > MAX_REMEMBERED_IDENTITY_PACKETS) {\n            qCWarning(KDECONNECT_CORE) << \"Too many remembered identities, ignoring\" << receivedPacket->get<QString>(QStringLiteral(\"deviceId\")) << \"received via UDP\";\n            delete receivedPacket;\n            continue;\n        }\n        QSslSocket* socket = new QSslSocket(this);\n        socket->setProxy(QNetworkProxy::NoProxy);\n        m_receivedIdentityPackets[socket].np = receivedPacket;\n        m_receivedIdentityPackets[socket].sender = sender;\n        connect(socket, &QAbstractSocket::connected, this, &LanLinkProvider::tcpSocketConnected);\n#if QT_VERSION < QT_VERSION_CHECK(5,15,0)\n        connect(socket, QOverload<QAbstractSocket::SocketError>::of(&QAbstractSocket::error), this, &LanLinkProvider::connectError);\n#else\n        connect(socket, &QAbstractSocket::errorOccurred, this, &LanLinkProvider::connectError);\n#endif\n        socket->connectToHost(sender, tcpPort);\n    }\n}", "target": 0}
{"code": "uipbuf_add_ext_hdr(int16_t len)\n{\n  if(len + uip_len <= UIP_LINK_MTU && len + uip_len >= 0 && len + uip_ext_len >= 0) {\n    uip_ext_len += len;\n    uip_len += len;\n    return true;\n  } else {\n    return false;\n  }\n}", "target": 0}
{"code": "GIT_INLINE(bool) verify_dotgit_ntfs(git_repository *repo, const char *path, size_t len)\n{\n\tgit_buf *reserved = git_repository__reserved_names_win32;\n\tsize_t reserved_len = git_repository__reserved_names_win32_len;\n\tsize_t start = 0, i;\n\tif (repo)\n\t\tgit_repository__reserved_names(&reserved, &reserved_len, repo, true);\n\tfor (i = 0; i < reserved_len; i++) {\n\t\tgit_buf *r = &reserved[i];\n\t\tif (len >= r->size &&\n\t\t\tstrncasecmp(path, r->ptr, r->size) == 0) {\n\t\t\tstart = r->size;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!start)\n\t\treturn true;\n\tif (path[start] == '\\\\')\n\t\treturn false;\n\tfor (i = start; i < len; i++) {\n\t\tif (path[i] != ' ' && path[i] != '.')\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "void Magick::Image::read(MagickCore::Image *image,\n  MagickCore::ExceptionInfo *exceptionInfo)\n{\n  if (image != (MagickCore::Image *) NULL &&\n      image->next != (MagickCore::Image *) NULL)\n    {\n      MagickCore::Image\n        *next;\n      next=image->next;\n      image->next=(MagickCore::Image *) NULL;\n      next->previous=(MagickCore::Image *) NULL;\n      DestroyImageList(next);\n    }\n  replaceImage(image);\n  if (exceptionInfo->severity == MagickCore::UndefinedException &&\n      image == (MagickCore::Image *) NULL)\n    {\n      (void) MagickCore::DestroyExceptionInfo(exceptionInfo);\n      if (!quiet())\n        throwExceptionExplicit(MagickCore::ImageWarning,\n          \"No image was loaded.\");\n      return;\n    }\n  ThrowImageException;\n}", "target": 0}
{"code": "static void parse_generic_line(pj_scanner *scanner, pj_str_t *str,\n\t\t\t       volatile parse_context *ctx)\n{\n    ctx->last_error = PJMEDIA_SDP_EINSDP;\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n    pj_scan_get_until_chr(scanner, \"\\r\\n\", str);\n    pj_scan_get_newline(scanner);\n}", "target": 1}
{"code": "client_data cql_server::connection::make_client_data() const {\n    client_data cd;\n    std::tie(cd.ip, cd.port, cd.ct) = make_client_key(_client_state);\n    cd.shard_id = this_shard_id();\n    cd.protocol_version = _version;\n    cd.driver_name = _client_state.get_driver_name();\n    cd.driver_version = _client_state.get_driver_version();\n    if (const auto user_ptr = _client_state.user(); user_ptr) {\n        cd.username = user_ptr->name;\n    }\n    if (_ready) {\n        cd.connection_stage = client_connection_stage::ready;\n    } else if (_authenticating) {\n        cd.connection_stage = client_connection_stage::authenticating;\n    }\n    return cd;\n}", "target": 0}
{"code": "void RtmpProtocol::sendInvoke(const string &cmd, const AMFValue &val) {\n    AMFEncoder enc;\n    enc << cmd << ++_send_req_id << val;\n    sendRequest(MSG_CMD, enc.data());\n}", "target": 0}
{"code": "static int nfs4_proc_fsinfo(struct nfs_server *server, struct nfs_fh *fhandle, struct nfs_fsinfo *fsinfo)\n{\n\tint error;\n\tnfs_fattr_init(fsinfo->fattr);\n\terror = nfs4_do_fsinfo(server, fhandle, fsinfo);\n\tif (error == 0) {\n\t\tserver->pnfs_blksize = fsinfo->blksize;\n\t\tset_pnfs_layoutdriver(server, fhandle, fsinfo->layouttype);\n\t}\n\treturn error;\n}", "target": 0}
{"code": "      explicit JpegOutput( String const& filename ) {\n         if( FileHasExtension( filename )) {\n            outfile_ = std::fopen(filename.c_str(), \"wb\");\n         } else {\n            outfile_ = std::fopen( FileAddExtension( filename, \"jpg\" ).c_str(), \"wb\" );\n         }\n         if( outfile_ == nullptr ) {\n            DIP_THROW_RUNTIME( \"Could not open file for writing\" );\n         }\n         cinfo_.err = jpeg_std_error( &jerr_.pub );\n         jerr_.pub.error_exit = my_error_exit;\n         jerr_.pub.output_message = my_output_message;\n         if( setjmp( jerr_.setjmp_buffer )) {\n            DIP_THROW_RUNTIME( \"Error writing JPEG file.\" );\n         }\n         jpeg_create_compress( &cinfo_ );\n         initialized_ = true;\n         jpeg_stdio_dest( &cinfo_, outfile_ );\n      }", "target": 1}
{"code": "  void connectSuccess() noexcept override {\n    ssl_->writeChain(nullptr, IOBuf::copyBuffer(\"hi\"));\n    auto ssl = const_cast<SSL*>(ssl_->getSSL());\n    SSL_shutdown(ssl);\n    auto fd = ssl_->detachNetworkSocket();\n    tcp_.reset(new AsyncSocket(evb_, fd), AsyncSocket::Destructor());\n    evb_->runAfterDelay(\n        [this]() {\n          perLoopReads_.setSocket(tcp_.get());\n          tcp_->setReadCB(&perLoopReads_);\n          evb_->runAfterDelay([this]() { tcp_->closeNow(); }, 10);\n        },\n        100);\n  }", "target": 0}
{"code": "static Fixed lsr_translate_scale(GF_LASeRCodec *lsr, u32 val)\n{\n\tif (val >> (lsr->coord_bits-1) ) {\n\t\ts32 v = val - (1<<lsr->coord_bits);\n\t\treturn INT2FIX(v) / 256 ;\n\t} else {\n\t\treturn INT2FIX(val) / 256;\n\t}\n}", "target": 1}
{"code": "const TfLiteTensor* GetIntermediates(TfLiteContext* context,\n                                     const TfLiteNode* node, int index) {\n  const int tensor_index = ValidateTensorIndexing(\n      context, index, node->intermediates->size, node->intermediates->data);\n  if (tensor_index < 0) {\n    return nullptr;\n  }\n  return GetTensorAtIndex(context, tensor_index);\n}", "target": 0}
{"code": "int mutt_seqset_iterator_next(struct SeqsetIterator *iter, unsigned int *next)\n{\n  if (!iter || !next)\n    return -1;\n  if (iter->in_range)\n  {\n    if ((iter->down && (iter->range_cur == (iter->range_end - 1))) ||\n        (!iter->down && (iter->range_cur == (iter->range_end + 1))))\n    {\n      iter->in_range = 0;\n    }\n  }\n  if (!iter->in_range)\n  {\n    iter->substr_cur = iter->substr_end;\n    if (iter->substr_cur == iter->eostr)\n      return 1;\n    while (!*(iter->substr_cur))\n      iter->substr_cur++;\n    iter->substr_end = strchr(iter->substr_cur, ',');\n    if (!iter->substr_end)\n      iter->substr_end = iter->eostr;\n    else\n      *(iter->substr_end) = '\\0';\n    char *range_sep = strchr(iter->substr_cur, ':');\n    if (range_sep)\n      *range_sep++ = '\\0';\n    if (mutt_str_atoui(iter->substr_cur, &iter->range_cur) != 0)\n      return -1;\n    if (range_sep)\n    {\n      if (mutt_str_atoui(range_sep, &iter->range_end) != 0)\n        return -1;\n    }\n    else\n      iter->range_end = iter->range_cur;\n    iter->down = (iter->range_end < iter->range_cur);\n    iter->in_range = 1;\n  }\n  *next = iter->range_cur;\n  if (iter->down)\n    iter->range_cur--;\n  else\n    iter->range_cur++;\n  return 0;\n}", "target": 1}
{"code": "comics_check_decompress_support\t(gchar          *mime_type,\n\t\t\t\t ComicsDocument *comics_document,\n\t\t\t\t GError         **error)\n{\n\tif (g_content_type_is_a (mime_type, \"application/x-cbr\") ||\n\t    g_content_type_is_a (mime_type, \"application/x-rar\")) {\n\t\tif (ev_archive_set_archive_type (comics_document->archive, EV_ARCHIVE_TYPE_RAR))\n\t\t\treturn TRUE;\n\t} else if (g_content_type_is_a (mime_type, \"application/x-cbz\") ||\n\t\t   g_content_type_is_a (mime_type, \"application/zip\")) {\n\t\tif (ev_archive_set_archive_type (comics_document->archive, EV_ARCHIVE_TYPE_ZIP))\n\t\t\treturn TRUE;\n\t} else if (g_content_type_is_a (mime_type, \"application/x-cb7\") ||\n\t\t   g_content_type_is_a (mime_type, \"application/x-7z-compressed\")) {\n\t\tif (ev_archive_set_archive_type (comics_document->archive, EV_ARCHIVE_TYPE_7Z))\n\t\t\treturn TRUE;\n\t} else if (g_content_type_is_a (mime_type, \"application/x-cbt\") ||\n\t\t   g_content_type_is_a (mime_type, \"application/x-tar\")) {\n\t\tif (ev_archive_set_archive_type (comics_document->archive, EV_ARCHIVE_TYPE_TAR))\n\t\t\treturn TRUE;\n\t} else {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"Not a comic book MIME type: %s\"),\n\t\t\t     mime_type);\n\t\t\t     return FALSE;\n\t}\n\tg_set_error_literal (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"libarchive lacks support for this comic books \"\n\t\t\t     \"compression, please contact your distributor\"));\n\treturn FALSE;\n}", "target": 0}
{"code": "static int handle_invept(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 vmx_instruction_info, types;\n\tunsigned long type;\n\tgva_t gva;\n\tstruct x86_exception e;\n\tstruct {\n\t\tu64 eptp, gpa;\n\t} operand;\n\tif (!(vmx->nested.nested_vmx_secondary_ctls_high &\n\t      SECONDARY_EXEC_ENABLE_EPT) ||\n\t    !(vmx->nested.nested_vmx_ept_caps & VMX_EPT_INVEPT_BIT)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\tif (!kvm_read_cr0_bits(vcpu, X86_CR0_PE)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\tvmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\ttype = kvm_register_readl(vcpu, (vmx_instruction_info >> 28) & 0xf);\n\ttypes = (vmx->nested.nested_vmx_ept_caps >> VMX_EPT_EXTENT_SHIFT) & 6;\n\tif (!(types & (1UL << type))) {\n\t\tnested_vmx_failValid(vcpu,\n\t\t\t\tVMXERR_INVALID_OPERAND_TO_INVEPT_INVVPID);\n\t\treturn 1;\n\t}\n\tif (get_vmx_mem_address(vcpu, vmcs_readl(EXIT_QUALIFICATION),\n\t\t\tvmx_instruction_info, false, &gva))\n\t\treturn 1;\n\tif (kvm_read_guest_virt(&vcpu->arch.emulate_ctxt, gva, &operand,\n\t\t\t\tsizeof(operand), &e)) {\n\t\tkvm_inject_page_fault(vcpu, &e);\n\t\treturn 1;\n\t}\n\tswitch (type) {\n\tcase VMX_EPT_EXTENT_GLOBAL:\n\t\tkvm_mmu_sync_roots(vcpu);\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\tnested_vmx_succeed(vcpu);\n\t\tbreak;\n\tdefault:\n\t\tBUG_ON(1);\n\t\tbreak;\n\t}\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}", "target": 0}
{"code": "static void zend_throw_or_error(int fetch_type, zend_class_entry *exception_ce, const char *format, ...) \n{\n\tva_list va;\n\tchar *message = NULL;\n\tva_start(va, format);\n\tzend_vspprintf(&message, 0, format, va);\n\tif (fetch_type & ZEND_FETCH_CLASS_EXCEPTION) {\n\t\tzend_throw_error(exception_ce, message);\n\t} else {\n\t\tzend_error(E_ERROR, \"%s\", message);\n\t}\n\tefree(message);\n\tva_end(va);\n}", "target": 1}
{"code": "    void TiffEncoder::add(\n        TiffComponent* pRootDir,\n        TiffComponent* pSourceDir,\n        uint32_t       root\n    )\n    {\n        assert(pRootDir != 0);\n        writeMethod_ = wmIntrusive;\n        pSourceTree_ = pSourceDir;\n        del_ = false;\n        ExifData::const_iterator posBo = exifData_.end();\n        for (ExifData::const_iterator i = exifData_.begin();\n             i != exifData_.end(); ++i) {\n            IfdId group = groupId(i->groupName());\n            if (group == mnId) {\n                if (i->tag() == 0x0002) {\n                    posBo = i;\n                }\n                continue;\n            }\n            if (isImageTag(i->tag(), group)) continue;\n            TiffPath tiffPath;\n            TiffCreator::getPath(tiffPath, i->tag(), group, root);\n            TiffComponent* tc = pRootDir->addPath(i->tag(), tiffPath, pRootDir);\n            TiffEntryBase* object = dynamic_cast<TiffEntryBase*>(tc);\n#ifdef DEBUG\n            if (object == 0) {\n                std::cerr << \"Warning: addPath() didn't add an entry for \"\n                          << i->groupName()\n                          << \" tag 0x\" << std::setw(4) << std::setfill('0')\n                          << std::hex << i->tag() << \"\\n\";\n            }\n#endif\n            if (object != 0) {\n                encodeTiffComponent(object, &(*i));\n            }\n        }\n        if (posBo == exifData_.end()) return;\n        TiffFinder finder(0x927c, exifId);\n        pRootDir->accept(finder);\n        TiffMnEntry* te = dynamic_cast<TiffMnEntry*>(finder.result());\n        if (te) {\n            TiffIfdMakernote* tim = dynamic_cast<TiffIfdMakernote*>(te->mn_);\n            if (tim) {\n                ByteOrder bo = stringToByteOrder(posBo->toString());\n                if (bo != invalidByteOrder) tim->setByteOrder(bo);\n            }\n        }\n    } ", "target": 0}
{"code": "  explicit UnravelIndexOp(OpKernelConstruction* ctx) : OpKernel(ctx) {}", "target": 1}
{"code": "static unsigned int __blk_mq_get_reserved_tag(struct blk_mq_alloc_data *data)\n{\n\tint tag, zero = 0;\n\tif (unlikely(!data->hctx->tags->nr_reserved_tags)) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn BLK_MQ_TAG_FAIL;\n\t}\n\ttag = bt_get(data, &data->hctx->tags->breserved_tags, NULL, &zero,\n\t\tdata->hctx->tags);\n\tif (tag < 0)\n\t\treturn BLK_MQ_TAG_FAIL;\n\treturn tag;\n}", "target": 0}
{"code": "llvm::Optional<Value> simplifyBroadcast(ShapeComponentAnalysis& analysis,\n                                        ValueRange shapes, Location loc,\n                                        OpBuilder* builder) {\n  SmallVector<ArrayRef<ShapeComponentAnalysis::SymbolicExpr>> shapes_found;\n  size_t maxRank = 0;\n  for (const auto &shape : llvm::enumerate(shapes)) {\n    auto found_shape = analysis.GetValueInfo(shape.value());\n    if (!found_shape) return {};\n    shapes_found.push_back(*found_shape);\n    maxRank = std::max(maxRank, found_shape->size());\n  }\n  if (maxRank == 0) {\n    return Value(builder->create<tensor::FromElementsOp>(\n        loc, shapes[0].getType(), SmallVector<Value>()));\n  }\n  SmallVector<const ShapeComponentAnalysis::SymbolicExpr*> joined_dimensions(\n      maxRank);\n  SmallVector<std::pair<Value, int64_t>> shape_and_rank_for_dim(maxRank);\n  for (const auto &shape : llvm::enumerate(shapes_found)) {\n    for (const auto &dim : llvm::enumerate(llvm::reverse(shape.value()))) {\n      if (dim.value().isConstant(1)) continue;\n      auto index = maxRank - dim.index() - 1;\n      if (!joined_dimensions[index]) {\n        joined_dimensions[index] = &dim.value();\n        shape_and_rank_for_dim[index] =\n            std::make_pair(shapes[shape.index()], shape.value().size());\n        continue;\n      }\n      if (*joined_dimensions[index] != dim.value()) return {};\n    }\n  }\n  if (llvm::is_splat(shape_and_rank_for_dim) &&\n      shape_and_rank_for_dim[0].first) {\n    return shape_and_rank_for_dim[0].first;\n  }\n  SmallVector<Value> elements;\n  for (int i = 0; i != maxRank; ++i) {\n    if (!shape_and_rank_for_dim[i].first) {\n      auto one = builder->getIntegerAttr(\n          shapes[0].getType().cast<RankedTensorType>().getElementType(), 1);\n      elements.push_back(builder->create<ConstantOp>(loc, one));\n      continue;\n    }\n    Value index = builder->create<ConstantIndexOp>(\n        loc, i - maxRank + shape_and_rank_for_dim[i].second);\n    elements.push_back(builder->create<tensor::ExtractOp>(\n        loc, shape_and_rank_for_dim[i].first, index));\n  }\n  return Value(builder->create<tensor::FromElementsOp>(loc, elements));\n}", "target": 0}
{"code": "static inline FILE *xfmkstemp(char **tmpname, char *dir)\n{\n\tint fd;\n\tFILE *ret;\n\tfd = xmkstemp(tmpname, dir);\n\tif (fd == -1)\n\t\treturn NULL;\n\tif (!(ret = fdopen(fd, \"w+\" UL_CLOEXECSTR))) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "nvkm_vmm_node_split(struct nvkm_vmm *vmm,\n\t\t    struct nvkm_vma *vma, u64 addr, u64 size)\n{\n\tstruct nvkm_vma *prev = NULL;\n\tif (vma->addr != addr) {\n\t\tprev = vma;\n\t\tif (!(vma = nvkm_vma_tail(vma, vma->size + vma->addr - addr)))\n\t\t\treturn NULL;\n\t\tvma->part = true;\n\t\tnvkm_vmm_node_insert(vmm, vma);\n\t}\n\tif (vma->size != size) {\n\t\tstruct nvkm_vma *tmp;\n\t\tif (!(tmp = nvkm_vma_tail(vma, vma->size - size))) {\n\t\t\tnvkm_vmm_node_merge(vmm, prev, vma, NULL, vma->size);\n\t\t\treturn NULL;\n\t\t}\n\t\ttmp->part = true;\n\t\tnvkm_vmm_node_insert(vmm, tmp);\n\t}\n\treturn vma;\n}", "target": 0}
{"code": "int anon_vma_fork(struct vm_area_struct *vma, struct vm_area_struct *pvma)\n{\n\tstruct anon_vma_chain *avc;\n\tstruct anon_vma *anon_vma;\n\tint error;\n\tif (!pvma->anon_vma)\n\t\treturn 0;\n\tvma->anon_vma = NULL;\n\terror = anon_vma_clone(vma, pvma);\n\tif (error)\n\t\treturn error;\n\tif (vma->anon_vma)\n\t\treturn 0;\n\tanon_vma = anon_vma_alloc();\n\tif (!anon_vma)\n\t\tgoto out_error;\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_error_free_anon_vma;\n\tanon_vma->root = pvma->anon_vma->root;\n\tanon_vma->parent = pvma->anon_vma;\n\tget_anon_vma(anon_vma->root);\n\tvma->anon_vma = anon_vma;\n\tanon_vma_lock_write(anon_vma);\n\tanon_vma_chain_link(vma, avc, anon_vma);\n\tanon_vma->parent->degree++;\n\tanon_vma_unlock_write(anon_vma);\n\treturn 0;\n out_error_free_anon_vma:\n\tput_anon_vma(anon_vma);\n out_error:\n\tunlink_anon_vmas(vma);\n\treturn -ENOMEM;\n}", "target": 1}
{"code": "cgiGetVariable(const char *name)\t\n{\n  const _cgi_var_t\t*var;\t\t\n  var = cgi_find_variable(name);\n  return ((var == NULL) ? NULL : _cupsStrRetain(var->values[var->nvalues - 1]));\n}", "target": 0}
{"code": "static bool is_subdir(const char *subdir, const char *dir, size_t len)\n{\n\tsize_t subdirlen = strlen(subdir);\n\tif (subdirlen < len)\n\t\treturn false;\n\tif (strncmp(subdir, dir, len) != 0)\n\t\treturn false;\n\tif (dir[len-1] == '/')\n\t\treturn true;\n\tif (subdir[len] == '/' || subdirlen == len)\n\t\treturn true;\n\treturn false;\n}", "target": 0}
{"code": "processBatchMultiRuleset(batch_t *pBatch)\n{\n\truleset_t *currRuleset;\n\tbatch_t snglRuleBatch;\n\tint i;\n\tint iStart;\t\n\tint iNew;\t\n\tDEFiRet;\n\tCHKiRet(batchInit(&snglRuleBatch, pBatch->nElem));\n\tsnglRuleBatch.pbShutdownImmediate = pBatch->pbShutdownImmediate;\n\twhile(1) { \n\t\tfor(iStart = 0 ; iStart < pBatch->nElem && pBatch->pElem[iStart].state == BATCH_STATE_DISC ; ++iStart)\n\t\t\t;\n\t\tif(iStart == pBatch->nElem)\n\t\t\tFINALIZE; \n\t\tcurrRuleset = batchElemGetRuleset(pBatch, iStart);\n\t\tiNew = 0;\n\t\tfor(i = iStart ; i < pBatch->nElem ; ++i) {\n\t\t\tif(batchElemGetRuleset(pBatch, i) == currRuleset) {\n\t\t\t\tbatchCopyElem(&(snglRuleBatch.pElem[iNew++]), &(pBatch->pElem[i]));\n\t\t\t\tpBatch->pElem[i].state = BATCH_STATE_DISC;\n\t\t\t}\n\t\t}\n\t\tsnglRuleBatch.nElem = iNew; \n\t\tbatchSetSingleRuleset(&snglRuleBatch, 1);\n\t\tprocessBatch(&snglRuleBatch);\n\t}\n\tbatchFree(&snglRuleBatch);\nfinalize_it:\n\tRETiRet;\n}", "target": 1}
{"code": "static void snd_timer_proc_read(struct snd_info_entry *entry,\n\t\t\t\tstruct snd_info_buffer *buffer)\n{\n\tstruct snd_timer *timer;\n\tstruct snd_timer_instance *ti;\n\tmutex_lock(&register_mutex);\n\tlist_for_each_entry(timer, &snd_timer_list, device_list) {\n\t\tif (timer->card && timer->card->shutdown)\n\t\t\tcontinue;\n\t\tswitch (timer->tmr_class) {\n\t\tcase SNDRV_TIMER_CLASS_GLOBAL:\n\t\t\tsnd_iprintf(buffer, \"G%i: \", timer->tmr_device);\n\t\t\tbreak;\n\t\tcase SNDRV_TIMER_CLASS_CARD:\n\t\t\tsnd_iprintf(buffer, \"C%i-%i: \",\n\t\t\t\t    timer->card->number, timer->tmr_device);\n\t\t\tbreak;\n\t\tcase SNDRV_TIMER_CLASS_PCM:\n\t\t\tsnd_iprintf(buffer, \"P%i-%i-%i: \", timer->card->number,\n\t\t\t\t    timer->tmr_device, timer->tmr_subdevice);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnd_iprintf(buffer, \"?%i-%i-%i-%i: \", timer->tmr_class,\n\t\t\t\t    timer->card ? timer->card->number : -1,\n\t\t\t\t    timer->tmr_device, timer->tmr_subdevice);\n\t\t}\n\t\tsnd_iprintf(buffer, \"%s :\", timer->name);\n\t\tif (timer->hw.resolution)\n\t\t\tsnd_iprintf(buffer, \" %lu.%03luus (%lu ticks)\",\n\t\t\t\t    timer->hw.resolution / 1000,\n\t\t\t\t    timer->hw.resolution % 1000,\n\t\t\t\t    timer->hw.ticks);\n\t\tif (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)\n\t\t\tsnd_iprintf(buffer, \" SLAVE\");\n\t\tsnd_iprintf(buffer, \"\\n\");\n\t\tlist_for_each_entry(ti, &timer->open_list_head, open_list)\n\t\t\tsnd_iprintf(buffer, \"  Client %s : %s\\n\",\n\t\t\t\t    ti->owner ? ti->owner : \"unknown\",\n\t\t\t\t    ti->flags & (SNDRV_TIMER_IFLG_START |\n\t\t\t\t\t\t SNDRV_TIMER_IFLG_RUNNING)\n\t\t\t\t    ? \"running\" : \"stopped\");\n\t}\n\tmutex_unlock(&register_mutex);\n}", "target": 0}
{"code": "static QSvgNode *createPathNode(QSvgNode *parent,\n                                const QXmlStreamAttributes &attributes,\n                                QSvgHandler *)\n{\n    QStringRef data      = attributes.value(QLatin1String(\"d\"));\n    QPainterPath qpath;\n    qpath.setFillRule(Qt::WindingFill);\n    parsePathDataFast(data, qpath);\n    QSvgNode *path = new QSvgPath(parent, qpath);\n    return path;\n}", "target": 1}
{"code": "GIT_INLINE(bool) only_spaces_and_dots(const char *path)\n{\n\tconst char *c = path;\n\tfor (;; c++) {\n\t\tif (*c == '\\0')\n\t\t\treturn true;\n\t\tif (*c != ' ' && *c != '.')\n\t\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "GF_Err pcrb_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox*) s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->subsegment_count);\n\tfor (i=0; i<ptr->subsegment_count; i++ ) {\n\t\tu32 data1 = (u32) (ptr->pcr_values[i] >> 10);\n\t\tu16 data2 = (u16) (ptr->pcr_values[i] << 6);\n\t\tgf_bs_write_u32(bs, data1);\n\t\tgf_bs_write_u16(bs, data2);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "bool IsFullyConnectedOpSupported(const TfLiteRegistration* registration,\n                                 const TfLiteNode* node,\n                                 TfLiteContext* context) {\n  if (node->builtin_data == nullptr) return false;\n  const auto* fc_params =\n      reinterpret_cast<const TfLiteFullyConnectedParams*>(node->builtin_data);\n  const int kInput = 0;\n  const int kWeights = 1;\n  const int kBias = 2;\n  if (fc_params->weights_format != kTfLiteFullyConnectedWeightsFormatDefault) {\n    return false;\n  }\n  const TfLiteTensor* input = GetInput(context, node, kInput);\n  const TfLiteTensor* weights = GetInput(context, node, kWeights);\n  if (!IsFloatType(input->type)) {\n    return false;\n  }\n  if (!IsFloatType(weights->type) || !IsConstantTensor(weights)) {\n    return false;\n  }\n  if (input->dims->data[input->dims->size - 1] != NumElements(input)) {\n    return false;\n  }\n  if (node->inputs->size > 2) {\n    const TfLiteTensor* bias = GetInput(context, node, kBias);\n    if (!IsFloatType(bias->type) || !IsConstantTensor(bias)) {\n      return false;\n    }\n  }\n  TfLiteFusedActivation activation = fc_params->activation;\n  if (activation == kTfLiteActSignBit) {\n    return false;\n  }\n  return true;\n}", "target": 1}
{"code": "bool VerifySparsity(const RuntimeShape& weights_shape,\n                    const RuntimeShape& input_shape,\n                    const RuntimeShape& output_shape,\n                    const TfLiteSparsity* sparsity) {\n  const int weights_dims_count = weights_shape.DimensionsCount();\n  const int output_dims_count = output_shape.DimensionsCount();\n  const int w0_size = sparsity->dim_metadata[0].dense_size;\n  const int accum_depth = weights_shape.Dims(weights_dims_count - 1);\n  const int output_elements = output_shape.FlatSize();\n  const int input_elements = input_shape.FlatSize();\n  const int batches = FlatSizeSkipDim(output_shape, output_dims_count - 1);\n  const int output_depth = MatchingDim(weights_shape, weights_dims_count - 2,\n                                       output_shape, output_dims_count - 1);\n  const int max_batch_index = batches - 1;\n  const int max_output = max_batch_index * output_depth + w0_size;\n  const int max_batch_depth = accum_depth * max_batch_index;\n  if (output_elements < max_output) return false;\n  for (int i = 0; i < sparsity->dim_metadata[1].array_indices->size; ++i) {\n    if (input_elements <=\n        max_batch_depth + sparsity->dim_metadata[1].array_indices->data[i])\n      return false;\n  }\n  return true;\n}", "target": 0}
{"code": "bool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMissingInputs)\n{\n    return mempool.accept(txdb, *this, fCheckInputs, pfMissingInputs);\n}", "target": 1}
{"code": "void linsertCommand(client *c) {\n    int where;\n    robj *subject;\n    listTypeIterator *iter;\n    listTypeEntry entry;\n    int inserted = 0;\n    if (strcasecmp(c->argv[2]->ptr,\"after\") == 0) {\n        where = LIST_TAIL;\n    } else if (strcasecmp(c->argv[2]->ptr,\"before\") == 0) {\n        where = LIST_HEAD;\n    } else {\n        addReply(c,shared.syntaxerr);\n        return;\n    }\n    if (sdslen(c->argv[4]->ptr) > LIST_MAX_ITEM_SIZE) {\n        addReplyError(c, \"Element too large\");\n        return;\n    }\n    if ((subject = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||\n        checkType(c,subject,OBJ_LIST)) return;\n    iter = listTypeInitIterator(subject,0,LIST_TAIL);\n    while (listTypeNext(iter,&entry)) {\n        if (listTypeEqual(&entry,c->argv[3])) {\n            listTypeInsert(&entry,c->argv[4],where);\n            inserted = 1;\n            break;\n        }\n    }\n    listTypeReleaseIterator(iter);\n    if (inserted) {\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_LIST,\"linsert\",\n                            c->argv[1],c->db->id);\n        server.dirty++;\n    } else {\n        addReplyLongLong(c,-1);\n        return;\n    }\n    addReplyLongLong(c,listTypeLength(subject));\n}", "target": 0}
{"code": "int hci_req_sync(struct hci_dev *hdev, int (*req)(struct hci_request *req,\n\t\t\t\t\t\t  unsigned long opt),\n\t\t unsigned long opt, u32 timeout, u8 *hci_status)\n{\n\tint ret;\n\tif (!test_bit(HCI_UP, &hdev->flags))\n\t\treturn -ENETDOWN;\n\thci_req_sync_lock(hdev);\n\tret = __hci_req_sync(hdev, req, opt, timeout, hci_status);\n\thci_req_sync_unlock(hdev);\n\treturn ret;\n}", "target": 1}
{"code": "DltReturnValue dlt_file_message(DltFile *file, int index, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n    if (file == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n    if (index >= file->counter) {\n        dlt_vlog(LOG_WARNING, \"Message %d out of range!\\r\\n\", index);\n        return DLT_RETURN_WRONG_PARAMETER;\n    }\n    if (fseek(file->handle, file->index[index], SEEK_SET) != 0) {\n        dlt_vlog(LOG_WARNING, \"Seek to message %d to position %ld failed!\\r\\n\",\n                 index, file->index[index]);\n        return DLT_RETURN_ERROR;\n    }\n    if (dlt_file_read_header(file, verbose) < DLT_RETURN_OK)\n        return DLT_RETURN_ERROR;\n    if (dlt_file_read_header_extended(file, verbose) < DLT_RETURN_OK)\n        return DLT_RETURN_ERROR;\n    if (dlt_file_read_data(file, verbose) < DLT_RETURN_OK)\n        return DLT_RETURN_ERROR;\n    file->position = index;\n    return DLT_RETURN_OK;\n}", "target": 1}
{"code": "void PrivateThreadPoolDatasetOp::MakeDataset(OpKernelContext* ctx,\n                                             DatasetBase* input,\n                                             DatasetBase** output) {\n  int64_t num_threads = 0;\n  OP_REQUIRES_OK(\n      ctx, ParseScalarArgument<int64_t>(ctx, \"num_threads\", &num_threads));\n  OP_REQUIRES(ctx, num_threads >= 0,\n              errors::InvalidArgument(\"`num_threads` must be >= 0\"));\n  *output = new Dataset(ctx, input, num_threads);\n}", "target": 1}
{"code": "unsigned int X509v3_addr_get_afi(const IPAddressFamily *f)\n{\n    return ((f != NULL &&\n             f->addressFamily != NULL && f->addressFamily->data != NULL)\n            ? ((f->addressFamily->data[0] << 8) | (f->addressFamily->data[1]))\n            : 0);\n}", "target": 1}
{"code": "static void read_conf(FILE *conffile)\n{\n    char *buffer, *line, *val;\n    buffer = loadfile(conffile);\n    for (line = strtok(buffer, \"\\r\\n\"); line; line = strtok(NULL, \"\\r\\n\")) {\n        if (!strncmp(line, \"export \", 7))\n            continue;\n        val = strchr(line, '=');\n        if (!val) {\n            printf(\"invalid configuration line\\n\");\n            break;\n        }\n        *val++ = '\\0';\n        if (!strcmp(line, \"JSON_INDENT\"))\n            conf.indent = atoi(val);\n        if (!strcmp(line, \"JSON_COMPACT\"))\n            conf.compact = atoi(val);\n        if (!strcmp(line, \"JSON_ENSURE_ASCII\"))\n            conf.ensure_ascii = atoi(val);\n        if (!strcmp(line, \"JSON_PRESERVE_ORDER\"))\n            conf.preserve_order = atoi(val);\n        if (!strcmp(line, \"JSON_SORT_KEYS\"))\n            conf.sort_keys = atoi(val);\n        if (!strcmp(line, \"STRIP\"))\n            conf.strip = atoi(val);\n        if (!strcmp(line, \"HASHSEED\")) {\n            conf.have_hashseed = 1;\n            conf.hashseed = atoi(val);\n        } else {\n            conf.have_hashseed = 0;\n        }\n    }\n    free(buffer);\n}", "target": 0}
{"code": "ZEND_API void zend_object_store_ctor_failed(zval *zobject TSRMLS_DC)\n{\n\tzend_object_handle handle = Z_OBJ_HANDLE_P(zobject);\n\tzend_object_store_bucket *obj_bucket = &EG(objects_store).object_buckets[handle];\n\tobj_bucket->bucket.obj.handlers = Z_OBJ_HT_P(zobject);;\n\tobj_bucket->destructor_called = 1;\n}", "target": 1}
{"code": "static int prealloc_elems_and_freelist(struct bpf_stack_map *smap)\n{\n\tu32 elem_size = sizeof(struct stack_map_bucket) + smap->map.value_size;\n\tint err;\n\tsmap->elems = bpf_map_area_alloc(elem_size * smap->map.max_entries,\n\t\t\t\t\t smap->map.numa_node);\n\tif (!smap->elems)\n\t\treturn -ENOMEM;\n\terr = pcpu_freelist_init(&smap->freelist);\n\tif (err)\n\t\tgoto free_elems;\n\tpcpu_freelist_populate(&smap->freelist, smap->elems, elem_size,\n\t\t\t       smap->map.max_entries);\n\treturn 0;\nfree_elems:\n\tbpf_map_area_free(smap->elems);\n\treturn err;\n}", "target": 1}
{"code": "fu_plugin_set_secure_config_value(FuPlugin *self,\n\t\t\t\t  const gchar *key,\n\t\t\t\t  const gchar *value,\n\t\t\t\t  GError **error)\n{\n\tg_autofree gchar *conf_path = fu_plugin_get_config_filename(self);\n\tgint ret;\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n\tif (!g_file_test(conf_path, G_FILE_TEST_EXISTS)) {\n\t\tg_set_error(error, FWUPD_ERROR, FWUPD_ERROR_NOT_FOUND, \"%s is missing\", conf_path);\n\t\treturn FALSE;\n\t}\n\tret = g_chmod(conf_path, 0660);\n\tif (ret == -1) {\n\t\tg_set_error(error,\n\t\t\t    FWUPD_ERROR,\n\t\t\t    FWUPD_ERROR_INTERNAL,\n\t\t\t    \"failed to set permissions on %s\",\n\t\t\t    conf_path);\n\t\treturn FALSE;\n\t}\n\treturn fu_plugin_set_config_value(self, key, value, error);\n}", "target": 1}
{"code": "int htc_connect_service(struct htc_target *target,\n\t\t     struct htc_service_connreq *service_connreq,\n\t\t     enum htc_endpoint_id *conn_rsp_epid)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_endpoint *endpoint;\n\tstruct htc_conn_svc_msg *conn_msg;\n\tint ret;\n\tunsigned long time_left;\n\tendpoint = get_next_avail_ep(target->endpoint);\n\tif (!endpoint) {\n\t\tdev_err(target->dev, \"Endpoint is not available for service %d\\n\",\n\t\t\tservice_connreq->service_id);\n\t\treturn -EINVAL;\n\t}\n\tendpoint->service_id = service_connreq->service_id;\n\tendpoint->max_txqdepth = service_connreq->max_send_qdepth;\n\tendpoint->ul_pipeid = service_to_ulpipe(service_connreq->service_id);\n\tendpoint->dl_pipeid = service_to_dlpipe(service_connreq->service_id);\n\tendpoint->ep_callbacks = service_connreq->ep_callbacks;\n\tskb = alloc_skb(sizeof(struct htc_conn_svc_msg) +\n\t\t\t    sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"Failed to allocate buf to send\"\n\t\t\t\"service connect req\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\tconn_msg = skb_put(skb, sizeof(struct htc_conn_svc_msg));\n\tconn_msg->service_id = cpu_to_be16(service_connreq->service_id);\n\tconn_msg->msg_id = cpu_to_be16(HTC_MSG_CONNECT_SERVICE_ID);\n\tconn_msg->con_flags = cpu_to_be16(service_connreq->con_flags);\n\tconn_msg->dl_pipeid = endpoint->dl_pipeid;\n\tconn_msg->ul_pipeid = endpoint->ul_pipeid;\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"Service connection timeout for: %d\\n\",\n\t\t\tservice_connreq->service_id);\n\t\tkfree_skb(skb);\n\t\treturn -ETIMEDOUT;\n\t}\n\t*conn_rsp_epid = target->conn_rsp_epid;\n\treturn 0;\nerr:\n\tkfree_skb(skb);\n\treturn ret;\n}", "target": 0}
{"code": "static __be16 cma_port(const struct sockaddr *addr)\n{\n\tstruct sockaddr_ib *sib;\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\treturn ((struct sockaddr_in *) addr)->sin_port;\n\tcase AF_INET6:\n\t\treturn ((struct sockaddr_in6 *) addr)->sin6_port;\n\tcase AF_IB:\n\t\tsib = (struct sockaddr_ib *) addr;\n\t\treturn htons((u16) (be64_to_cpu(sib->sib_sid) &\n\t\t\t\t    be64_to_cpu(sib->sib_sid_mask)));\n\tdefault:\n\t\treturn 0;\n\t}\n}", "target": 0}
{"code": "xmlCopyEnumeration(xmlEnumerationPtr cur) {\n    xmlEnumerationPtr ret;\n    if (cur == NULL) return(NULL);\n    ret = xmlCreateEnumeration((xmlChar *) cur->name);\n    if (ret == NULL) return(NULL);\n    if (cur->next != NULL) ret->next = xmlCopyEnumeration(cur->next);\n    else ret->next = NULL;\n    return(ret);\n}", "target": 0}
{"code": "decrypt(gcry_mpi_t output, gcry_mpi_t a, gcry_mpi_t b, ELG_secret_key *skey )\n{\n  gcry_mpi_t t1, t2, r;\n  unsigned int nbits = mpi_get_nbits (skey->p);\n  mpi_normalize (a);\n  mpi_normalize (b);\n  t1 = mpi_snew (nbits);\n#ifdef USE_BLINDING\n  t2 = mpi_snew (nbits);\n  r  = mpi_new (nbits);\n  _gcry_mpi_randomize (r, nbits, GCRY_WEAK_RANDOM);\n  mpi_powm (t1, r, skey->x, skey->p);\n  mpi_mulm (t2, a, r, skey->p);\n  mpi_powm (t2, t2, skey->x, skey->p);\n  mpi_invm (t2, t2, skey->p);\n  mpi_mulm (t1, t1, t2, skey->p);\n  mpi_free (r);\n  mpi_free (t2);\n#else \n  mpi_powm (t1, a, skey->x, skey->p);\n  mpi_invm (t1, t1, skey->p);\n#endif \n  mpi_mulm (output, b, t1, skey->p);\n#if 0\n  if( DBG_CIPHER )\n    {\n      log_mpidump(\"elg decrypted x= \", skey->x);\n      log_mpidump(\"elg decrypted p= \", skey->p);\n      log_mpidump(\"elg decrypted a= \", a);\n      log_mpidump(\"elg decrypted b= \", b);\n      log_mpidump(\"elg decrypted M= \", output);\n    }\n#endif\n  mpi_free (t1);\n}", "target": 0}
{"code": "int audit_bprm(struct linux_binprm *bprm)\n{\n\tstruct audit_aux_data_execve *ax;\n\tstruct audit_context *context = current->audit_context;\n\tif (likely(!audit_enabled || !context || context->dummy))\n\t\treturn 0;\n\tif (bprm->argv_len > (audit_argv_kb << 10))\n\t\treturn -E2BIG;\n\tax = kmalloc(sizeof(*ax), GFP_KERNEL);\n\tif (!ax)\n\t\treturn -ENOMEM;\n\tax->argc = bprm->argc;\n\tax->envc = bprm->envc;\n\tax->mm = bprm->mm;\n\tax->d.type = AUDIT_EXECVE;\n\tax->d.next = context->aux;\n\tcontext->aux = (void *)ax;\n\treturn 0;\n}", "target": 0}
{"code": "makepol(QPRS_STATE *state)\n{\n\tint32\t\tval = 0,\n\t\t\t\ttype;\n\tint32\t\tlenval = 0;\n\tchar\t   *strval = NULL;\n\tint32\t\tstack[STACKDEPTH];\n\tint32\t\tlenstack = 0;\n\tuint16\t\tflag = 0;\n\tcheck_stack_depth();\n\twhile ((type = gettoken_query(state, &val, &lenval, &strval, &flag)) != END)\n\t{\n\t\tswitch (type)\n\t\t{\n\t\t\tcase VAL:\n\t\t\t\tpushval_asis(state, VAL, strval, lenval, flag);\n\t\t\t\twhile (lenstack && (stack[lenstack - 1] == (int32) '&' ||\n\t\t\t\t\t\t\t\t\tstack[lenstack - 1] == (int32) '!'))\n\t\t\t\t{\n\t\t\t\t\tlenstack--;\n\t\t\t\t\tpushquery(state, OPR, stack[lenstack], 0, 0, 0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase OPR:\n\t\t\t\tif (lenstack && val == (int32) '|')\n\t\t\t\t\tpushquery(state, OPR, val, 0, 0, 0);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (lenstack == STACKDEPTH)\n\t\t\t\t\t\telog(ERROR, \"stack too short\");\n\t\t\t\t\tstack[lenstack] = val;\n\t\t\t\t\tlenstack++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase OPEN:\n\t\t\t\tif (makepol(state) == ERR)\n\t\t\t\t\treturn ERR;\n\t\t\t\twhile (lenstack && (stack[lenstack - 1] == (int32) '&' ||\n\t\t\t\t\t\t\t\t\tstack[lenstack - 1] == (int32) '!'))\n\t\t\t\t{\n\t\t\t\t\tlenstack--;\n\t\t\t\t\tpushquery(state, OPR, stack[lenstack], 0, 0, 0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CLOSE:\n\t\t\t\twhile (lenstack)\n\t\t\t\t{\n\t\t\t\t\tlenstack--;\n\t\t\t\t\tpushquery(state, OPR, stack[lenstack], 0, 0, 0);\n\t\t\t\t};\n\t\t\t\treturn END;\n\t\t\t\tbreak;\n\t\t\tcase ERR:\n\t\t\tdefault:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"syntax error\")));\n\t\t\t\treturn ERR;\n\t\t}\n\t}\n\twhile (lenstack)\n\t{\n\t\tlenstack--;\n\t\tpushquery(state, OPR, stack[lenstack], 0, 0, 0);\n\t};\n\treturn END;\n}", "target": 0}
{"code": "smb_send_rqst(struct TCP_Server_Info *server, struct smb_rqst *rqst)\n{\n\tint rc;\n\tstruct kvec *iov = rqst->rq_iov;\n\tint n_vec = rqst->rq_nvec;\n\tunsigned int smb_buf_length = get_rfc1002_length(iov[0].iov_base);\n\tunsigned int i;\n\tsize_t total_len = 0, sent;\n\tstruct socket *ssocket = server->ssocket;\n\tint val = 1;\n\tif (ssocket == NULL)\n\t\treturn -ENOTSOCK;\n\tcFYI(1, \"Sending smb: smb_len=%u\", smb_buf_length);\n\tdump_smb(iov[0].iov_base, iov[0].iov_len);\n\tkernel_setsockopt(ssocket, SOL_TCP, TCP_CORK,\n\t\t\t\t(char *)&val, sizeof(val));\n\trc = smb_send_kvec(server, iov, n_vec, &sent);\n\tif (rc < 0)\n\t\tgoto uncork;\n\ttotal_len += sent;\n\tfor (i = 0; i < rqst->rq_npages; i++) {\n\t\tstruct kvec p_iov;\n\t\tcifs_rqst_page_to_kvec(rqst, i, &p_iov);\n\t\trc = smb_send_kvec(server, &p_iov, 1, &sent);\n\t\tkunmap(rqst->rq_pages[i]);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\t\ttotal_len += sent;\n\t}\nuncork:\n\tval = 0;\n\tkernel_setsockopt(ssocket, SOL_TCP, TCP_CORK,\n\t\t\t\t(char *)&val, sizeof(val));\n\tif ((total_len > 0) && (total_len != smb_buf_length + 4)) {\n\t\tcFYI(1, \"partial send (wanted=%u sent=%zu): terminating \"\n\t\t\t\"session\", smb_buf_length + 4, total_len);\n\t\tserver->tcpStatus = CifsNeedReconnect;\n\t}\n\tif (rc < 0 && rc != -EINTR)\n\t\tcERROR(1, \"Error %d sending data on socket to server\", rc);\n\telse\n\t\trc = 0;\n\treturn rc;\n}", "target": 0}
{"code": "static int can_open_delegated(struct nfs_delegation *delegation, mode_t open_flags)\n{\n\tif ((delegation->type & open_flags) != open_flags)\n\t\treturn 0;\n\tif (test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags))\n\t\treturn 0;\n\tnfs_mark_delegation_referenced(delegation);\n\treturn 1;\n}", "target": 1}
{"code": "static PixelChannels **AcquirePixelThreadSet(const Image *images)\n{\n  const Image\n    *next;\n  PixelChannels\n    **pixels;\n  register ssize_t\n    i;\n  size_t\n    columns,\n    rows;\n  rows=MagickMax(GetImageListLength(images),\n    (size_t) GetMagickResourceLimit(ThreadResource));\n  pixels=(PixelChannels **) AcquireQuantumMemory(rows,sizeof(*pixels));\n  if (pixels == (PixelChannels **) NULL)\n    return((PixelChannels **) NULL);\n  columns=MaxPixelChannels;\n  for (next=images; next != (Image *) NULL; next=next->next)\n    columns=MagickMax(next->columns,columns);\n  for (i=0; i < (ssize_t) rows; i++)\n  {\n    register ssize_t\n      j;\n    pixels[i]=(PixelChannels *) AcquireQuantumMemory(columns,sizeof(**pixels));\n    if (pixels[i] == (PixelChannels *) NULL)\n      return(DestroyPixelThreadSet(pixels));\n    for (j=0; j < (ssize_t) columns; j++)\n    {\n      register ssize_t\n        k;\n      for (k=0; k < MaxPixelChannels; k++)\n        pixels[i][j].channel[k]=0.0;\n    }\n  }\n  return(pixels);\n}", "target": 0}
{"code": "int pam_modutil_regain_priv(pam_handle_t *pamh, struct _ykpam_privs *privs) {\n    if ((privs->saved_euid == geteuid()) && (privs->saved_egid == getegid())) {\n        D (privs->debug_file, \"Privilges already as requested, pretend it is all right\");\n        return 0;\n    }\n    if (seteuid(privs->saved_euid) < 0) {\n        D (privs->debug_file, \"seteuid: %s\", strerror(errno));\n        return -1;\n    }\n    if (setegid(privs->saved_egid) < 0) {\n        D (privs->debug_file, \"setegid: %s\", strerror(errno));\n        return -1;\n    }\n    if (setgroups(privs->saved_groups_length, privs->saved_groups) < 0) {\n        D (privs->debug_file, \"setgroups: %s\", strerror(errno));\n        return -1;\n    }\n    return 0;\n}", "target": 0}
{"code": "void RequestContext::StartBackendSpanAndSetTraceContext() {\n  backend_span_.reset(CreateSpan(cloud_trace_.get(), \"Backend\"));\n  std::string trace_context_header = cloud_trace()->ToTraceContextHeader(\n      backend_span_->trace_span()->span_id());\n  Status status = request()->AddHeaderToBackend(\n      cloud_trace()->header_type() == HeaderType::CLOUD_TRACE_CONTEXT\n          ? kCloudTraceContextHeader\n          : kGRpcTraceContextHeader,\n      trace_context_header);\n  if (!status.ok()) {\n    service_context()->env()->LogError(\n        \"Failed to set trace context header to backend.\");\n  }\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    OP_REQUIRES(context, input.dims() == 1 || input.dims() == 2,\n                errors::InvalidArgument(\n                    \"input must be a vector or 2D tensor, but got shape \",\n                    input.shape().DebugString()));\n    if (input.dims() == 1) {\n      OP_REQUIRES(context,\n                  input.NumElements() == 2 || input.NumElements() == 4 ||\n                      input.NumElements() == 5,\n                  errors::InvalidArgument(\n                      \"1D input must be of size 2, 4 or 5, but got shape \",\n                      input.shape().DebugString()));\n    } else if (input.dims() == 2) {\n      OP_REQUIRES(context, input.dim_size(0) == 2 || input.dim_size(0) == 4,\n                  errors::InvalidArgument(\"First dimension of 2D input must be \"\n                                          \"of size 2 or 4, but got shape \",\n                                          input.shape().DebugString()));\n      OP_REQUIRES(\n          context, input.dim_size(1) == 2,\n          errors::InvalidArgument(\n              \"Second dimension of 2D input must be of size 2, but got shape \",\n              input.shape().DebugString()));\n    }\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input.shape(), &output));\n    Eigen::DSizes<Eigen::DenseIndex, 8> dst_idx;\n    string src_format_str = src_format_;\n    string dst_format_str = dst_format_;\n    if (input.dim_size(0) == 2) {\n      auto keep_only_spatial_dimensions = [](string* format_str) -> void {\n        auto new_end = std::remove_if(\n            format_str->begin(), format_str->end(),\n            [](const char dim) { return dim != 'H' && dim != 'W'; });\n        format_str->erase(new_end, format_str->end());\n      };\n      keep_only_spatial_dimensions(&src_format_str);\n      keep_only_spatial_dimensions(&dst_format_str);\n      OP_REQUIRES(context,\n                  src_format_str.size() == 2 && dst_format_str.size() == 2,\n                  errors::InvalidArgument(\n                      \"Format specifier must contain H and W for 2D case\"));\n    }\n    ComputeDstIndex(src_format_str, dst_format_str, input.dims(), &dst_idx);\n    functor::DataFormatVecPermute<Device, T>()(context->eigen_device<Device>(),\n                                               input.flat<T>(),\n                                               output->flat<T>(), dst_idx);\n  }", "target": 0}
{"code": "static int timer_start(Unit *u) {\n        Timer *t = TIMER(u);\n        TimerValue *v;\n        assert(t);\n        assert(t->state == TIMER_DEAD || t->state == TIMER_FAILED);\n        if (UNIT_TRIGGER(u)->load_state != UNIT_LOADED)\n                return -ENOENT;\n        t->last_trigger = DUAL_TIMESTAMP_NULL;\n        LIST_FOREACH(value, v, t->values)\n                if (v->base == TIMER_ACTIVE)\n                        v->disabled = false;\n        if (t->stamp_path) {\n                struct stat st;\n                if (stat(t->stamp_path, &st) >= 0)\n                        t->last_trigger.realtime = timespec_load(&st.st_atim);\n                else if (errno == ENOENT)\n                        touch_file(t->stamp_path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, 0);\n        }\n        t->result = TIMER_SUCCESS;\n        timer_enter_waiting(t, true);\n        return 1;\n}", "target": 1}
{"code": "TfLiteStatus GatherNd(const TfLiteTensor* params, const TfLiteTensor* indices,\n                      TfLiteTensor* output) {\n  reference_ops::GatherNd(\n      GetTensorShape(params), GetTensorData<ParamsT>(params),\n      GetTensorShape(indices), GetTensorData<IndicesT>(indices),\n      GetTensorShape(output), GetTensorData<ParamsT>(output));\n  return kTfLiteOk;\n}", "target": 1}
{"code": "HIDDEN void log_cachehdr(const char *name, const char *contents,\n                         const char *raw, void *rock)\n{\n    struct buf *buf = (struct buf *) rock;\n    if (name[0] == ':') return;\n    if (!strcasecmp(name, \"authorization\")) {\n        const char *creds = strchr(contents, ' ') + 1;\n        buf_printf(buf, \"%c%s: %.*s%-*s\\r\\n\", toupper(name[0]), name+1,\n                   (int) (creds - contents), contents,\n                   (int) strlen(creds), \"...\");\n    }\n    else if (raw)\n        buf_appendcstr(buf, raw);\n    else\n        buf_printf(buf, \"%c%s: %s\\r\\n\", toupper(name[0]), name+1, contents);\n}", "target": 0}
{"code": "static void *gp_worker_main(void *pvt)\n{\n    struct gp_thread *t = (struct gp_thread *)pvt;\n    struct gp_query *q = NULL;\n    char dummy = 0;\n    int ret;\n    while (!t->pool->shutdown) {\n        gp_debug_set_conn_id(0);\n        pthread_mutex_lock(&t->cond_mutex);\n        while (t->query == NULL) {\n            pthread_cond_wait(&t->cond_wakeup, &t->cond_mutex);\n            if (t->pool->shutdown) {\n                pthread_mutex_unlock(&t->cond_mutex);\n                pthread_exit(NULL);\n            }\n        }\n        q = t->query;\n        t->query = NULL;\n        pthread_mutex_unlock(&t->cond_mutex);\n        gp_debug_set_conn_id(gp_conn_get_cid(q->conn));\n        GPDEBUGN(3, \"[status] Handling query input: %p (%zu)\\n\", q->buffer,\n                 q->buflen);\n        gp_handle_query(t->pool, q);\n        GPDEBUGN(3 ,\"[status] Handling query output: %p (%zu)\\n\", q->buffer,\n                 q->buflen);\n        pthread_mutex_lock(&t->pool->lock);\n        q->next = t->pool->reply_list;\n        t->pool->reply_list = q;\n        if (!t->pool->shutdown) {\n            LIST_DEL(t->pool->busy_list, t);\n            LIST_ADD(t->pool->free_list, t);\n        }\n        pthread_mutex_unlock(&t->pool->lock);\n        ret = write(t->pool->sig_pipe[1], &dummy, 1);\n        if (ret == -1) {\n            GPERROR(\"Failed to signal dispatcher!\");\n        }\n    }\n    pthread_exit(NULL);\n}", "target": 0}
{"code": "static inline u32 dma_low(dma_addr_t addr)\n{\n\treturn (u32)addr;\n}", "target": 1}
{"code": "gss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n\t\t       int iov_count)\n{\n    OM_uint32 status;\n    gss_union_ctx_id_t ctx;\n    gss_mechanism mech;\n    status = val_wrap_iov_args(minor_status, context_handle, 0, qop_req, NULL,\n\t\t\t       iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn status;\n    ctx = (gss_union_ctx_id_t)context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism(ctx->mech_type);\n    if (mech == NULL)\n\treturn GSS_S_BAD_MECH;\n    if (mech->gss_get_mic_iov_length == NULL)\n\treturn GSS_S_UNAVAILABLE;\n    status = mech->gss_get_mic_iov_length(minor_status, ctx->internal_ctx_id,\n\t\t\t\t\t  qop_req, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\tmap_error(minor_status, mech);\n    return status;\n}", "target": 0}
{"code": "static void iriap_getvaluebyclass_indication(struct iriap_cb *self,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct ias_object *obj;\n\tstruct ias_attrib *attrib;\n\tint name_len;\n\tint attr_len;\n\tchar name[IAS_MAX_CLASSNAME + 1];\t\n\tchar attr[IAS_MAX_ATTRIBNAME + 1];\t\n\t__u8 *fp;\n\tint n;\n\tIRDA_DEBUG(4, \"%s()\\n\", __func__);\n\tIRDA_ASSERT(self != NULL, return;);\n\tIRDA_ASSERT(self->magic == IAS_MAGIC, return;);\n\tIRDA_ASSERT(skb != NULL, return;);\n\tfp = skb->data;\n\tn = 1;\n\tname_len = fp[n++];\n\tIRDA_ASSERT(name_len < IAS_MAX_CLASSNAME + 1, return;);\n\tmemcpy(name, fp+n, name_len); n+=name_len;\n\tname[name_len] = '\\0';\n\tattr_len = fp[n++];\n\tIRDA_ASSERT(attr_len < IAS_MAX_ATTRIBNAME + 1, return;);\n\tmemcpy(attr, fp+n, attr_len); n+=attr_len;\n\tattr[attr_len] = '\\0';\n\tIRDA_DEBUG(4, \"LM-IAS: Looking up %s: %s\\n\", name, attr);\n\tobj = irias_find_object(name);\n\tif (obj == NULL) {\n\t\tIRDA_DEBUG(2, \"LM-IAS: Object %s not found\\n\", name);\n\t\tiriap_getvaluebyclass_response(self, 0x1235, IAS_CLASS_UNKNOWN,\n\t\t\t\t\t       &irias_missing);\n\t\treturn;\n\t}\n\tIRDA_DEBUG(4, \"LM-IAS: found %s, id=%d\\n\", obj->name, obj->id);\n\tattrib = irias_find_attrib(obj, attr);\n\tif (attrib == NULL) {\n\t\tIRDA_DEBUG(2, \"LM-IAS: Attribute %s not found\\n\", attr);\n\t\tiriap_getvaluebyclass_response(self, obj->id,\n\t\t\t\t\t       IAS_ATTRIB_UNKNOWN,\n\t\t\t\t\t       &irias_missing);\n\t\treturn;\n\t}\n\tiriap_getvaluebyclass_response(self, obj->id, IAS_SUCCESS,\n\t\t\t\t       attrib->value);\n}", "target": 0}
{"code": "static void adpt_i2o_sys_shutdown(void)\n{\n\tadpt_hba *pHba, *pNext;\n\tstruct adpt_i2o_post_wait_data *p1, *old;\n\tprintk(KERN_INFO \"Shutting down Adaptec I2O controllers.\\n\");\n\tprintk(KERN_INFO \"   This could take a few minutes if there are many devices attached\\n\");\n\tfor (pHba = hba_chain; pHba; pHba = pNext) {\n\t\tpNext = pHba->next;\n\t\tadpt_i2o_delete_hba(pHba);\n\t}\n\tfor(p1 = adpt_post_wait_queue; p1;) {\n\t\told = p1;\n\t\tp1 = p1->next;\n\t\tkfree(old);\n\t}\n\tadpt_post_wait_queue = NULL;\n\tprintk(KERN_INFO \"Adaptec I2O controllers down.\\n\");\n}", "target": 1}
{"code": "static CuckooFilter *cfCreate(RedisModuleKey *key, size_t capacity, size_t bucketSize,\n                              size_t maxIterations, size_t expansion) {\n    if (capacity < bucketSize * 2)\n        return NULL;\n    CuckooFilter *cf = RedisModule_Calloc(1, sizeof(*cf));\n    if (CuckooFilter_Init(cf, capacity, bucketSize, maxIterations, expansion) != 0) {\n        RedisModule_Free(cf); \n        cf = NULL;            \n    }\n    RedisModule_ModuleTypeSetValue(key, CFType, cf);\n    return cf;\n}", "target": 1}
{"code": "static inline struct keydata *get_keyptr(void)\n{\n\tstruct keydata *keyptr = &ip_keydata[ip_cnt & 1];\n\tsmp_rmb();\n\treturn keyptr;\n}", "target": 1}
{"code": "l2tp_framing_cap_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint32_t *ptr = (const uint32_t *)dat;\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_ASYNC_MASK) {\n\t\tND_PRINT((ndo, \"A\"));\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_SYNC_MASK) {\n\t\tND_PRINT((ndo, \"S\"));\n\t}\n}", "target": 1}
{"code": "static void skcipher_sock_destruct(struct sock *sk)\n{\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tstruct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(&ctx->req);\n\tskcipher_free_sgl(sk);\n\tsock_kfree_s(sk, ctx->iv, crypto_ablkcipher_ivsize(tfm));\n\tsock_kfree_s(sk, ctx, ctx->len);\n\taf_alg_release_parent(sk);\n}", "target": 0}
{"code": "bool IsPadOpSupported(const TfLiteRegistration* registration,\n                      const TfLiteNode* node, TfLiteContext* context) {\n  const TfLiteTensor* padding = GetInput(context, node, 1);\n  if (!IsConstantTensor(padding)) {\n    TF_LITE_KERNEL_LOG(context,\n                       \"%s: Only constant padding is supported for PAD.\",\n                       padding->name);\n    return false;\n  }\n  if (padding->dims->data[0] != 4 || padding->dims->data[1] != 2) {\n    TF_LITE_KERNEL_LOG(context, \"%s: Only 4D inputs are supported for PAD.\",\n                       padding->name);\n    return false;\n  }\n  const int32_t* padding_data = GetTensorData<int32_t>(padding);\n  if (!(padding_data[0] == 0 && padding_data[1] == 0)) {\n    TF_LITE_KERNEL_LOG(\n        context, \"%s: Padding for batch dimension is not supported in PAD.\",\n        padding->name);\n    return false;\n  }\n  if (!(padding_data[6] == 0 && padding_data[7] == 0)) {\n    TF_LITE_KERNEL_LOG(\n        context, \"%s: Padding for channel dimension is not supported in PAD.\",\n        padding->name);\n    return false;\n  }\n  return true;\n}", "target": 1}
{"code": "void sock_release(struct socket *sock)\n{\n\tif (sock->ops) {\n\t\tstruct module *owner = sock->ops->owner;\n\t\tsock->ops->release(sock);\n\t\tsock->ops = NULL;\n\t\tmodule_put(owner);\n\t}\n\tif (rcu_dereference_protected(sock->wq, 1)->fasync_list)\n\t\tpr_err(\"%s: fasync list not empty!\\n\", __func__);\n\tif (!sock->file) {\n\t\tiput(SOCK_INODE(sock));\n\t\treturn;\n\t}\n\tsock->file = NULL;\n}", "target": 1}
{"code": "mailimap_mailbox_data_status_free(struct mailimap_mailbox_data_status * info)\n{\n  mailimap_mailbox_free(info->st_mailbox);\n  clist_foreach(info->st_info_list, (clist_func) mailimap_status_info_free,\n\t\t NULL);\n  clist_free(info->st_info_list);\n  free(info);\n}", "target": 1}
{"code": "static int rtl8xxxu_submit_int_urb(struct ieee80211_hw *hw)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct urb *urb;\n\tu32 val32;\n\tint ret;\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\tusb_fill_int_urb(urb, priv->udev, priv->pipe_interrupt,\n\t\t\t priv->int_buf, USB_INTR_CONTENT_LENGTH,\n\t\t\t rtl8xxxu_int_complete, priv, 1);\n\tusb_anchor_urb(urb, &priv->int_anchor);\n\tret = usb_submit_urb(urb, GFP_KERNEL);\n\tif (ret) {\n\t\tusb_unanchor_urb(urb);\n\t\tusb_free_urb(urb);\n\t\tgoto error;\n\t}\n\tval32 = rtl8xxxu_read32(priv, REG_USB_HIMR);\n\tval32 |= USB_HIMR_CPWM;\n\trtl8xxxu_write32(priv, REG_USB_HIMR, val32);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "void GLES2DecoderImpl::DoUniform1i(GLint fake_location, GLint v0) {\n  GLenum type = 0;\n  GLsizei count = 1;\n  GLint real_location = -1;\n  if (!PrepForSetUniformByLocation(\n      fake_location, \"glUniform1iv\", &real_location, &type, &count)) {\n    return;\n  }\n  current_program_->SetSamplers(fake_location, 1, &v0);\n  glUniform1i(real_location, v0);\n}", "target": 0}
{"code": "sysLocation_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_string(varbind, oid, \"\");\n}", "target": 1}
{"code": "TfLiteStatus MockCustom::Invoke(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = tflite::GetInput(context, node, 0);\n  const int32_t* input_data = input->data.i32;\n  const TfLiteTensor* weight = tflite::GetInput(context, node, 1);\n  const uint8_t* weight_data = weight->data.uint8;\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  int32_t* output_data = output->data.i32;\n  output_data[0] =\n      0;  \n  output_data[0] = input_data[0] + weight_data[0];\n  return kTfLiteOk;\n}", "target": 1}
{"code": "int submit_bio_wait(struct bio *bio)\n{\n\tstruct submit_bio_ret ret;\n\tinit_completion(&ret.event);\n\tbio->bi_private = &ret;\n\tbio->bi_end_io = submit_bio_wait_endio;\n\tbio->bi_opf |= REQ_SYNC;\n\tsubmit_bio(bio);\n\twait_for_completion_io(&ret.event);\n\treturn ret.error;\n}", "target": 0}
{"code": "void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tunsigned long flags;\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn;\n\truntime = substream->runtime;\n\tsnd_pcm_stream_lock_irqsave(substream, flags);\n\tif (!snd_pcm_running(substream) ||\n\t    snd_pcm_update_hw_ptr0(substream, 1) < 0)\n\t\tgoto _end;\n#ifdef CONFIG_SND_PCM_TIMER\n\tif (substream->timer_running)\n\t\tsnd_timer_interrupt(substream->timer, 1);\n#endif\n _end:\n\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n\tkill_fasync(&runtime->fasync, SIGIO, POLL_IN);\n}", "target": 1}
{"code": "static int extractRDNSequence(struct ndpi_packet_struct *packet,\n\t\t\t      u_int offset, char *buffer, u_int buffer_len,\n\t\t\t      char *rdnSeqBuf, u_int *rdnSeqBuf_offset,\n\t\t\t      u_int rdnSeqBuf_len,\n\t\t\t      const char *label) {\n  u_int8_t str_len = packet->payload[offset+4], is_printable = 1;\n  char *str;\n  u_int len, j;\n  if (*rdnSeqBuf_offset >= rdnSeqBuf_len) {\n#ifdef DEBUG_TLS\n    printf(\"[TLS] %s() [buffer capacity reached][%u]\\n\",\n           __FUNCTION__, rdnSeqBuf_len);\n#endif\n    return -1;\n  }\n  if((offset+4+str_len) >= packet->payload_packet_len)\n    return(-1);\n  str = (char*)&packet->payload[offset+5];\n  len = (u_int)ndpi_min(str_len, buffer_len-1);\n  strncpy(buffer, str, len);\n  buffer[len] = '\\0';\n  for(j = 0; j < len; j++) {\n    if(!ndpi_isprint(buffer[j])) {\n      is_printable = 0;\n      break;\n    }\n  }\n  if(is_printable) {\n    int rc = snprintf(&rdnSeqBuf[*rdnSeqBuf_offset],\n\t\t      rdnSeqBuf_len-(*rdnSeqBuf_offset),\n\t\t      \"%s%s=%s\", (*rdnSeqBuf_offset > 0) ? \", \" : \"\",\n\t\t      label, buffer);\n    if(rc > 0)\n      (*rdnSeqBuf_offset) += rc;\n  }\n  return(is_printable);\n}", "target": 0}
{"code": "static void handle_get_publish(struct http_conn *conn,\n\t\t\t       const struct http_msg *msg,\n\t\t\t       struct mbuf *mb, size_t clen)\n{\n\tstruct ident_entry *ie = NULL;\n\tstruct pl pl;\n\tchar *key = NULL;\n\tint err;\n\tinfo(\"handle get publish\\n\");\n\terr = re_regex(msg->prm.p, msg->prm.l, \"?pairid=[0-9]+\", &pl);\n\tif (err) {\n\t\twarning(\"invalid input\\n\");\n\t\tgoto out;\n\t}\n\tpl_strdup(&key, &pl);\n\tie = dict_lookup(verifyd.idents, key);\n\tif (!ie) {\n\t\tinfo(\"publish: pairing-id %s not found\\n\", key);\n\t\thttp_ereply(conn, 404, \"Not found\");\n\t\tgoto out;\n\t}\n\tdebug(\"handle get publish (content=%s)\\n\", ie->content.publish);\n\tif (ie->content.publish) {\n\t\thttp_creply(conn, 200, \"OK\",\n\t\t\t    \"application/json\", \"%s\", ie->content.publish);\n\t}\n\telse {\n\t\thttp_ereply(conn, 404, \"Not Yet\");\n\t}\n\thttp_conn_close(conn);\n out:\n\tmem_deref(key);\n}", "target": 0}
{"code": "got_headers (SoupMessage *req, SoupClientContext *client)\n{\n\tSoupServer *server = client->server;\n\tSoupServerPrivate *priv = SOUP_SERVER_GET_PRIVATE (server);\n\tSoupURI *uri;\n\tSoupDate *date;\n\tchar *date_string;\n\tSoupAuthDomain *domain;\n\tGSList *iter;\n\tgboolean rejected = FALSE;\n\tchar *auth_user;\n\tif (!priv->raw_paths) {\n\t\tchar *decoded_path;\n\t\turi = soup_message_get_uri (req);\n\t\tdecoded_path = soup_uri_decode (uri->path);\n\t\tif (strstr (decoded_path, \"/../\") ||\n\t\t    g_str_has_suffix (decoded_path, \"/..\")) {\n\t\t\tg_free (decoded_path);\n\t\t\tsoup_message_set_status (req, SOUP_STATUS_BAD_REQUEST);\n\t\t\treturn;\n\t\t}\n\t\tsoup_uri_set_path (uri, decoded_path);\n\t\tg_free (decoded_path);\n\t}\n\tdate = soup_date_new_from_now (0);\n\tdate_string = soup_date_to_string (date, SOUP_DATE_HTTP);\n\tsoup_message_headers_replace (req->response_headers, \"Date\",\n\t\t\t\t      date_string);\n\tg_free (date_string);\n\tsoup_date_free (date);\n\tfor (iter = priv->auth_domains; iter; iter = iter->next) {\n\t\tdomain = iter->data;\n\t\tif (soup_auth_domain_covers (domain, req)) {\n\t\t\tauth_user = soup_auth_domain_accepts (domain, req);\n\t\t\tif (auth_user) {\n\t\t\t\tclient->auth_domain = g_object_ref (domain);\n\t\t\t\tclient->auth_user = auth_user;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trejected = TRUE;\n\t\t}\n\t}\n\tif (!rejected)\n\t\treturn;\n\tfor (iter = priv->auth_domains; iter; iter = iter->next) {\n\t\tdomain = iter->data;\n\t\tif (soup_auth_domain_covers (domain, req))\n\t\t\tsoup_auth_domain_challenge (domain, req);\n\t}\n}", "target": 0}
{"code": "long kernel_wait4(pid_t upid, int __user *stat_addr, int options,\n\t\t  struct rusage *ru)\n{\n\tstruct wait_opts wo;\n\tstruct pid *pid = NULL;\n\tenum pid_type type;\n\tlong ret;\n\tif (options & ~(WNOHANG|WUNTRACED|WCONTINUED|\n\t\t\t__WNOTHREAD|__WCLONE|__WALL))\n\t\treturn -EINVAL;\n\tif (upid == INT_MIN)\n\t\treturn -ESRCH;\n\tif (upid == -1)\n\t\ttype = PIDTYPE_MAX;\n\telse if (upid < 0) {\n\t\ttype = PIDTYPE_PGID;\n\t\tpid = find_get_pid(-upid);\n\t} else if (upid == 0) {\n\t\ttype = PIDTYPE_PGID;\n\t\tpid = get_task_pid(current, PIDTYPE_PGID);\n\t} else  {\n\t\ttype = PIDTYPE_PID;\n\t\tpid = find_get_pid(upid);\n\t}\n\two.wo_type\t= type;\n\two.wo_pid\t= pid;\n\two.wo_flags\t= options | WEXITED;\n\two.wo_info\t= NULL;\n\two.wo_stat\t= 0;\n\two.wo_rusage\t= ru;\n\tret = do_wait(&wo);\n\tput_pid(pid);\n\tif (ret > 0 && stat_addr && put_user(wo.wo_stat, stat_addr))\n\t\tret = -EFAULT;\n\treturn ret;\n}", "target": 0}
{"code": "int dev_forward_skb(struct net_device *dev, struct sk_buff *skb)\n{\n\tskb_orphan(skb);\n\tif (!(dev->flags & IFF_UP))\n\t\treturn NET_RX_DROP;\n\tif (skb->len > (dev->mtu + dev->hard_header_len))\n\t\treturn NET_RX_DROP;\n\tskb_set_dev(skb, dev);\n\tskb->tstamp.tv64 = 0;\n\tskb->pkt_type = PACKET_HOST;\n\tskb->protocol = eth_type_trans(skb, dev);\n\treturn netif_rx(skb);\n}", "target": 1}
{"code": "int ConnectionImpl::saveHeader(const nghttp2_frame* frame, HeaderString&& name,\n                               HeaderString&& value) {\n  StreamImpl* stream = getStream(frame->hd.stream_id);\n  if (!stream) {\n    stats_.headers_cb_no_stream_.inc();\n    return 0;\n  }\n  stream->saveHeader(std::move(name), std::move(value));\n  if (stream->headers_->byteSize() > max_request_headers_kb_ * 1024) {\n    stats_.header_overflow_.inc();\n    return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n  } else {\n    return 0;\n  }\n}", "target": 1}
{"code": "dirserv_add_multiple_descriptors(const char *desc, uint8_t purpose,\n                                 const char *source,\n                                 const char **msg)\n{\n  was_router_added_t r, r_tmp;\n  const char *msg_out;\n  smartlist_t *list;\n  const char *s;\n  int n_parsed = 0;\n  time_t now = time(NULL);\n  char annotation_buf[ROUTER_ANNOTATION_BUF_LEN];\n  char time_buf[ISO_TIME_LEN+1];\n  int general = purpose == ROUTER_PURPOSE_GENERAL;\n  tor_assert(msg);\n  r=ROUTER_ADDED_SUCCESSFULLY; \n  format_iso_time(time_buf, now);\n  if (tor_snprintf(annotation_buf, sizeof(annotation_buf),\n                   \"@uploaded-at %s\\n\"\n                   \"@source %s\\n\"\n                   \"%s%s%s\", time_buf, escaped(source),\n                   !general ? \"@purpose \" : \"\",\n                   !general ? router_purpose_to_string(purpose) : \"\",\n                   !general ? \"\\n\" : \"\")<0) {\n    *msg = \"Couldn't format annotations\";\n    return -1;\n  }\n  s = desc;\n  list = smartlist_create();\n  if (!router_parse_list_from_string(&s, NULL, list, SAVED_NOWHERE, 0, 0,\n                                     annotation_buf)) {\n    SMARTLIST_FOREACH(list, routerinfo_t *, ri, {\n        msg_out = NULL;\n        tor_assert(ri->purpose == purpose);\n        r_tmp = dirserv_add_descriptor(ri, &msg_out, source);\n        if (WRA_MORE_SEVERE(r_tmp, r)) {\n          r = r_tmp;\n          *msg = msg_out;\n        }\n      });\n  }\n  n_parsed += smartlist_len(list);\n  smartlist_clear(list);\n  s = desc;\n  if (!router_parse_list_from_string(&s, NULL, list, SAVED_NOWHERE, 1, 0,\n                                     NULL)) {\n    SMARTLIST_FOREACH(list, extrainfo_t *, ei, {\n        msg_out = NULL;\n        r_tmp = dirserv_add_extrainfo(ei, &msg_out);\n        if (WRA_MORE_SEVERE(r_tmp, r)) {\n          r = r_tmp;\n          *msg = msg_out;\n        }\n      });\n  }\n  n_parsed += smartlist_len(list);\n  smartlist_free(list);\n  if (! *msg) {\n    if (!n_parsed) {\n      *msg = \"No descriptors found in your POST.\";\n      if (WRA_WAS_ADDED(r))\n        r = ROUTER_WAS_NOT_NEW;\n    } else {\n      *msg = \"(no message)\";\n    }\n  }\n  return r;\n}", "target": 0}
{"code": "void SocketLineReader::dataReceived()\n{\n    while (m_socket->canReadLine()) {\n        const QByteArray line = m_socket->readLine();\n        if (line.length() > 1) { \n            m_packets.enqueue(line);\n        }\n    }\n    if (m_socket->bytesAvailable() > 0) {\n        QMetaObject::invokeMethod(this, \"dataReceived\", Qt::QueuedConnection);\n        return;\n    }\n    if (!m_packets.isEmpty()) {\n        Q_EMIT readyRead();\n    }\n}", "target": 1}
{"code": "static jas_image_cmpt_t *jas_image_cmpt_create(int_fast32_t tlx,\n  int_fast32_t tly, int_fast32_t hstep, int_fast32_t vstep,\n  int_fast32_t width, int_fast32_t height, uint_fast16_t depth, bool sgnd,\n  uint_fast32_t inmem)\n{\n\tjas_image_cmpt_t *cmpt;\n\tsize_t size;\n\tcmpt = 0;\n\tif (width < 0 || height < 0 || hstep <= 0 || vstep <= 0) {\n\t\tgoto error;\n\t}\n\tif (!jas_safe_intfast32_add(tlx, width, 0) ||\n\t  !jas_safe_intfast32_add(tly, height, 0)) {\n\t\tgoto error;\n\t}\n\tif (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {\n\t\tgoto error;\n\t}\n\tcmpt->type_ = JAS_IMAGE_CT_UNKNOWN;\n\tcmpt->tlx_ = tlx;\n\tcmpt->tly_ = tly;\n\tcmpt->hstep_ = hstep;\n\tcmpt->vstep_ = vstep;\n\tcmpt->width_ = width;\n\tcmpt->height_ = height;\n\tcmpt->prec_ = depth;\n\tcmpt->sgnd_ = sgnd;\n\tcmpt->stream_ = 0;\n\tcmpt->cps_ = (depth + 7) / 8;\n\tif (!jas_safe_size_mul(cmpt->width_, cmpt->height_, &size) ||\n\t  !jas_safe_size_mul(size, cmpt->cps_, &size)) {\n\t\tgoto error;\n\t}\n\tcmpt->stream_ = (inmem) ? jas_stream_memopen(0, size) :\n\t  jas_stream_tmpfile();\n\tif (!cmpt->stream_) {\n\t\tgoto error;\n\t}\n\tif (jas_stream_seek(cmpt->stream_, size - 1, SEEK_SET) < 0 ||\n\t  jas_stream_putc(cmpt->stream_, 0) == EOF ||\n\t  jas_stream_seek(cmpt->stream_, 0, SEEK_SET) < 0) {\n\t\tgoto error;\n\t}\n\treturn cmpt;\nerror:\n\tif (cmpt) {\n\t\tjas_image_cmpt_destroy(cmpt);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "int check_name(char *name, int size)\n{\n\tchar *start = name;\n\tif(name[0] == '.') {\n\t\tif(name[1] == '.')\n\t\t\tname++;\n\t\tif(name[1] == '/' || name[1] == '\\0')\n\t\t\treturn FALSE;\n\t}\n\twhile(name[0] != '/' && name[0] != '\\0')\n\t\tname ++;\n\tif(name[0] == '/')\n\t\treturn FALSE;\n\tif((name - start) != size)\n\t\treturn FALSE;\n\treturn TRUE;\n}", "target": 0}
{"code": "DLLIMPORT int cfg_parse(cfg_t *cfg, const char *filename)\n{\n\tint ret;\n\tchar *fn;\n\tFILE *fp;\n\tif (!cfg || !filename) {\n\t\terrno = EINVAL;\n\t\treturn CFG_FILE_ERROR;\n\t}\n\tif (cfg->path)\n\t\tfn = cfg_searchpath(cfg->path, filename);\n\telse\n\t\tfn = cfg_tilde_expand(filename);\n\tif (!fn)\n\t\treturn CFG_FILE_ERROR;\n\tfree(cfg->filename);\n\tcfg->filename = fn;\n\tfp = fopen(cfg->filename, \"r\");\n\tif (!fp)\n\t\treturn CFG_FILE_ERROR;\n\tret = cfg_parse_fp(cfg, fp);\n\tfclose(fp);\n\treturn ret;\n}", "target": 0}
{"code": "static unsigned long get_seg_limit(struct pt_regs *regs, int seg_reg_idx)\n{\n\tstruct desc_struct *desc;\n\tunsigned long limit;\n\tshort sel;\n\tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn 0;\n\tif (user_64bit_mode(regs) || v8086_mode(regs))\n\t\treturn -1L;\n\tif (!sel)\n\t\treturn 0;\n\tdesc = get_desc(sel);\n\tif (!desc)\n\t\treturn 0;\n\tlimit = get_desc_limit(desc);\n\tif (desc->g)\n\t\tlimit = (limit << 12) + 0xfff;\n\treturn limit;\n}", "target": 1}
{"code": "static MagickBooleanType SkipRGBMipmaps(Image *image,DDSInfo *dds_info,\n  int pixel_size,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    offset;\n  register ssize_t\n    i;\n  size_t\n    h,\n    w;\n  if (EOFBlob(image) != MagickFalse)\n    {\n      ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n        image->filename);\n      return(MagickFalse);\n    }\n  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP\n      && (dds_info->ddscaps1 & DDSCAPS_TEXTURE\n          || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))\n    {\n      w = DIV2(dds_info->width);\n      h = DIV2(dds_info->height);\n      for (i=1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n      {\n        offset = (MagickOffsetType) w * h * pixel_size;\n        (void) SeekBlob(image, offset, SEEK_CUR);\n        w = DIV2(w);\n        h = DIV2(h);\n      }\n    }\n  return(MagickTrue);\n}", "target": 1}
{"code": "int ossl_dsa_check_pairwise(const DSA *dsa)\n{\n    int ret = 0;\n    BN_CTX *ctx = NULL;\n    BIGNUM *pub_key = NULL;\n    if (dsa->params.p == NULL\n        || dsa->params.g == NULL\n        || dsa->priv_key == NULL\n        || dsa->pub_key == NULL)\n        return 0;\n    ctx = BN_CTX_new_ex(dsa->libctx);\n    if (ctx == NULL)\n        goto err;\n    pub_key = BN_new();\n    if (pub_key == NULL)\n        goto err;\n    if (!ossl_dsa_generate_public_key(ctx, dsa, dsa->priv_key, pub_key))\n        goto err;\n    ret = BN_cmp(pub_key, dsa->pub_key) == 0;\nerr:\n    BN_free(pub_key);\n    BN_CTX_free(ctx);\n    return ret;\n}", "target": 1}
{"code": "void LinearAlgebraOp<InputScalar, OutputScalar>::PrepareOutputs(\n    OpKernelContext* context, const TensorShapes& input_matrix_shapes,\n    const TensorShape& batch_shape, TensorOutputs* outputs,\n    TensorShapes* output_matrix_shapes) {\n  *output_matrix_shapes = GetOutputMatrixShapes(input_matrix_shapes);\n  const int num_outputs = output_matrix_shapes->size();\n  OP_REQUIRES(\n      context, num_outputs <= context->num_outputs(),\n      errors::Internal(\n          \"Derived class expected more outputs (%d) that the op has (%d).\",\n          num_outputs, context->num_outputs()));\n  std::set<int> unused_inputs;\n  for (int input_idx = 0; input_idx < context->num_inputs(); ++input_idx) {\n    unused_inputs.insert(input_idx);\n  }\n  for (int output_idx = 0; output_idx < context->num_outputs(); ++output_idx) {\n    TensorShape output_tensor_shape({});\n    if (output_idx < num_outputs) {\n      const TensorShape& output_matrix_shape =\n          output_matrix_shapes->at(output_idx);\n      OP_REQUIRES(context, output_matrix_shape.dims() <= 2,\n                  errors::InvalidArgument(\n                      \"Rank of matrix output no. %d must be 0, 1 or 2, got %d.\",\n                      output_idx, output_matrix_shape.dims()));\n      output_tensor_shape = batch_shape;\n      output_tensor_shape.AppendShape(output_matrix_shape);\n    }\n    Tensor* out = nullptr;\n    bool reused_input = false;\n    if (EnableInputForwarding()) {\n      for (int input_idx : unused_inputs) {\n        if (context->forward_input_to_output_with_shape(\n                input_idx, output_idx, output_tensor_shape, &out)) {\n          reused_input = true;\n          unused_inputs.erase(input_idx);\n          break;\n        }\n      }\n    }\n    if (!reused_input) {\n      OP_REQUIRES_OK(context, context->allocate_output(\n                                  output_idx, output_tensor_shape, &out));\n    }\n    OP_REQUIRES(\n        context, out->dtype() == DataTypeToEnum<OutputScalar>::v(),\n        errors::InvalidArgument(\"Invalid output dtype \", out->dtype(), \" vs \",\n                                DataTypeToEnum<OutputScalar>::v()));\n    outputs->emplace_back(out);\n  }\n}", "target": 0}
{"code": "void free_bprm(struct linux_binprm *bprm)\n{\n\tfree_arg_pages(bprm);\n\tif (bprm->cred) {\n\t\tmutex_unlock(&current->signal->cred_guard_mutex);\n\t\tabort_creds(bprm->cred);\n\t}\n\tif (bprm->interp != bprm->filename)\n\t\tkfree(bprm->interp);\n\tkfree(bprm);\n}", "target": 0}
{"code": "void jbd2_journal_lock_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\tjbd2_might_wait_for_commit(journal);\n\twrite_lock(&journal->j_state_lock);\n\t++journal->j_barrier_count;\n\tif (atomic_read(&journal->j_reserved_credits)) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twait_event(journal->j_wait_reserved,\n\t\t\t   atomic_read(&journal->j_reserved_credits) == 0);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\tjbd2_journal_wait_updates(journal);\n\twrite_unlock(&journal->j_state_lock);\n\tmutex_lock(&journal->j_barrier);\n}", "target": 1}
{"code": "    size_t MemIo::write(const byte* data, size_t wcount)\n    {\n        p_->reserve(wcount);\n        assert(p_->isMalloced_);\n        if (data != nullptr) {\n            std::memcpy(&p_->data_[p_->idx_], data, wcount);\n        }\n        p_->idx_ += wcount;\n        return wcount;\n    }", "target": 0}
{"code": "uint64_t HeaderMapImpl::byteSize() const {\n  uint64_t byte_size = 0;\n  for (const HeaderEntryImpl& header : headers_) {\n    byte_size += header.key().size();\n    byte_size += header.value().size();\n  }\n  return byte_size;\n}", "target": 1}
{"code": "snmp_ber_decode_null(unsigned char *buf, uint32_t *buff_len)\n{\n  buf++;\n  (*buff_len)--;\n  buf++;\n  (*buff_len)--;\n  return buf;\n}", "target": 1}
{"code": "static int midi_setup_sysex_roland_reset(struct _mdi *mdi) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,0,0);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_sysex_roland_reset;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.value = 0;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}", "target": 0}
{"code": "void FileBody::Dump(std::ostream& os, const std::string& prefix) const {\n  os << prefix << \"<file: \" << path_.string() << \">\" << std::endl;\n}", "target": 1}
{"code": "int intel_execlists_submission_setup(struct intel_engine_cs *engine)\n{\n\ttasklet_init(&engine->execlists.tasklet,\n\t\t     execlists_submission_tasklet, (unsigned long)engine);\n\ttimer_setup(&engine->execlists.timer, execlists_timeslice, 0);\n\ttimer_setup(&engine->execlists.preempt, execlists_preempt, 0);\n\tlogical_ring_default_vfuncs(engine);\n\tlogical_ring_default_irqs(engine);\n\tif (engine->class == RENDER_CLASS)\n\t\trcs_submission_override(engine);\n\treturn 0;\n}", "target": 0}
{"code": "static int xfrm_dump_policy_done(struct netlink_callback *cb)\n{\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n\tstruct net *net = sock_net(cb->skb->sk);\n\txfrm_policy_walk_done(walk, net);\n\treturn 0;\n}", "target": 1}
{"code": "void Node::RunForwardTypeInference() {\n  VLOG(4) << \"Forward type inference: \" << props_->node_def.DebugString();\n  if (props_->fwd_type_fn == nullptr) {\n    return;\n  }\n  std::vector<Node*> input_nodes(props_->input_types.size(), nullptr);\n  std::vector<int> input_idx(props_->input_types.size(), 0);\n  for (const auto& edge : in_edges_) {\n    if (edge->IsControlEdge()) {\n      continue;\n    }\n    DCHECK(edge->dst_input() < input_nodes.size()) << DebugString();\n    int i = edge->dst_input();\n    input_nodes.at(i) = edge->src();\n    input_idx.at(i) = edge->src_output();\n  }\n  for (const auto* node : input_nodes) {\n    if (node == nullptr) {\n      ClearTypeInfo();\n      return;\n    }\n  }\n  static FullTypeDef* no_type = new FullTypeDef();\n  std::vector<std::reference_wrapper<const FullTypeDef>> input_types;\n  for (int i = 0; i < input_nodes.size(); i++) {\n    const auto* node = input_nodes[i];\n    if (node->def().has_experimental_type()) {\n      const auto& node_t = node->def().experimental_type();\n      if (node_t.type_id() != TFT_UNSET) {\n        int ix = input_idx[i];\n        DCHECK(ix < node_t.args_size())\n            << \"input \" << i << \" should have an output \" << ix\n            << \" but instead only has \" << node_t.args_size()\n            << \" outputs: \" << node_t.DebugString();\n        input_types.emplace_back(node_t.args(ix));\n      } else {\n        input_types.emplace_back(*no_type);\n      }\n    } else {\n      ClearTypeInfo();\n      return;\n    }\n  }\n  const auto infer_type = props_->fwd_type_fn(input_types);\n  const FullTypeDef infer_typedef = infer_type.ValueOrDie();\n  if (infer_typedef.type_id() != TFT_UNSET) {\n    MaybeCopyOnWrite();\n    *(props_->node_def.mutable_experimental_type()) = infer_typedef;\n  }\n}", "target": 1}
{"code": "static void ikev2_parent_inI2outR2_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct dh_continuation *dh = (struct dh_continuation *)pcrc;\n\tstruct msg_digest *md = dh->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent inI2outR2: calculating g^{xy}, sending R2\"));\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t\treturn;\n\t}\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\tpassert(st->st_suspended_md == dh->md);\n\tset_suspended(st, NULL); \n\tset_cur_state(st);\n\tst->st_calculating = FALSE;\n\te = ikev2_parent_inI2outR2_tail(pcrc, r);\n\tif ( e > STF_FAIL) {\n\t\tint v2_notify_num = e - STF_FAIL;\n\t\tDBG_log(\n\t\t\t\"ikev2_parent_inI2outR2_tail returned STF_FAIL with %s\",\n\t\t\tenum_name(&ikev2_notify_names, v2_notify_num));\n\t} else if ( e != STF_OK) {\n\t\tDBG_log(\"ikev2_parent_inI2outR2_tail returned %s\",\n\t\t\tenum_name(&stfstatus_name, e));\n\t}\n\tif (dh->md != NULL) {\n\t\tcomplete_v2_state_transition(&dh->md, e);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t}\n\treset_globals();\n\tpassert(GLOBALS_ARE_RESET());\n}", "target": 1}
{"code": "static int read_exceptions(struct pstore *ps,\n\t\t\t   int (*callback)(void *callback_context, chunk_t old,\n\t\t\t\t\t   chunk_t new),\n\t\t\t   void *callback_context)\n{\n\tint r, full = 1;\n\tfor (ps->current_area = 0; full; ps->current_area++) {\n\t\tr = area_io(ps, READ);\n\t\tif (r)\n\t\t\treturn r;\n\t\tr = insert_exceptions(ps, callback, callback_context, &full);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\tps->current_area--;\n\tskip_metadata(ps);\n\treturn 0;\n}", "target": 0}
{"code": "static long do_locks(unsigned int fd, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct flock64 kernel;\n\tstruct oabi_flock64 user;\n\tmm_segment_t fs;\n\tlong ret;\n\tif (copy_from_user(&user, (struct oabi_flock64 __user *)arg,\n\t\t\t   sizeof(user)))\n\t\treturn -EFAULT;\n\tkernel.l_type\t= user.l_type;\n\tkernel.l_whence\t= user.l_whence;\n\tkernel.l_start\t= user.l_start;\n\tkernel.l_len\t= user.l_len;\n\tkernel.l_pid\t= user.l_pid;\n\tfs = get_fs();\n\tset_fs(KERNEL_DS);\n\tret = sys_fcntl64(fd, cmd, (unsigned long)&kernel);\n\tset_fs(fs);\n\tif (!ret && (cmd == F_GETLK64 || cmd == F_OFD_GETLK)) {\n\t\tuser.l_type\t= kernel.l_type;\n\t\tuser.l_whence\t= kernel.l_whence;\n\t\tuser.l_start\t= kernel.l_start;\n\t\tuser.l_len\t= kernel.l_len;\n\t\tuser.l_pid\t= kernel.l_pid;\n\t\tif (copy_to_user((struct oabi_flock64 __user *)arg,\n\t\t\t\t &user, sizeof(user)))\n\t\t\tret = -EFAULT;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "void InitCodec(const vpx_codec_iface_t &iface, int width, int height,\n               vpx_codec_ctx_t *enc, vpx_codec_enc_cfg_t *cfg) {\n  ASSERT_EQ(vpx_codec_enc_config_default(&iface, cfg, 0), VPX_CODEC_OK);\n  cfg->g_w = width;\n  cfg->g_h = height;\n  cfg->g_lag_in_frames = 0;\n  cfg->g_pass = VPX_RC_ONE_PASS;\n  ASSERT_EQ(vpx_codec_enc_init(enc, &iface, cfg, 0), VPX_CODEC_OK);\n  ASSERT_EQ(vpx_codec_control_(enc, VP8E_SET_CPUUSED, 2), VPX_CODEC_OK);\n}", "target": 1}
{"code": "void test_readlink(const char *path)\n{\n\tchar *dest = alloca(2 * strlen(path));\n\tif (readlink(path, dest, 2 * strlen(path)) >= 0) {\n\t\tfprintf(stderr, \"leak at readlink of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at readlink of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "static int synic_set_msr(struct kvm_vcpu_hv_synic *synic,\n\t\t\t u32 msr, u64 data, bool host)\n{\n\tstruct kvm_vcpu *vcpu = hv_synic_to_vcpu(synic);\n\tint ret;\n\tif (!synic->active && !host)\n\t\treturn 1;\n\ttrace_kvm_hv_synic_set_msr(vcpu->vcpu_id, msr, data, host);\n\tret = 0;\n\tswitch (msr) {\n\tcase HV_X64_MSR_SCONTROL:\n\t\tsynic->control = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_SVERSION:\n\t\tif (!host) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tsynic->version = data;\n\t\tbreak;\n\tcase HV_X64_MSR_SIEFP:\n\t\tif ((data & HV_SYNIC_SIEFP_ENABLE) && !host &&\n\t\t    !synic->dont_zero_synic_pages)\n\t\t\tif (kvm_clear_guest(vcpu->kvm,\n\t\t\t\t\t    data & PAGE_MASK, PAGE_SIZE)) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tsynic->evt_page = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_SIMP:\n\t\tif ((data & HV_SYNIC_SIMP_ENABLE) && !host &&\n\t\t    !synic->dont_zero_synic_pages)\n\t\t\tif (kvm_clear_guest(vcpu->kvm,\n\t\t\t\t\t    data & PAGE_MASK, PAGE_SIZE)) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tsynic->msg_page = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_EOM: {\n\t\tint i;\n\t\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++)\n\t\t\tkvm_hv_notify_acked_sint(vcpu, i);\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\t\tret = synic_set_sint(synic, msr - HV_X64_MSR_SINT0, data, host);\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "ossl_cipher_update(int argc, VALUE *argv, VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n    unsigned char *in;\n    long in_len, out_len;\n    VALUE data, str;\n    rb_scan_args(argc, argv, \"11\", &data, &str);\n    if (!RTEST(rb_attr_get(self, id_key_set)))\n\tossl_raise(eCipherError, \"key not set\");\n    StringValue(data);\n    in = (unsigned char *)RSTRING_PTR(data);\n    if ((in_len = RSTRING_LEN(data)) == 0)\n        ossl_raise(rb_eArgError, \"data must not be empty\");\n    GetCipher(self, ctx);\n    out_len = in_len+EVP_CIPHER_CTX_block_size(ctx);\n    if (out_len <= 0) {\n\tossl_raise(rb_eRangeError,\n\t\t   \"data too big to make output buffer: %ld bytes\", in_len);\n    }\n    if (NIL_P(str)) {\n        str = rb_str_new(0, out_len);\n    } else {\n        StringValue(str);\n        rb_str_resize(str, out_len);\n    }\n    if (!ossl_cipher_update_long(ctx, (unsigned char *)RSTRING_PTR(str), &out_len, in, in_len))\n\tossl_raise(eCipherError, NULL);\n    assert(out_len < RSTRING_LEN(str));\n    rb_str_set_len(str, out_len);\n    return str;\n}", "target": 0}
{"code": "CertificateValidationContextConfigImpl::CertificateValidationContextConfigImpl(\n    const envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext& config,\n    Api::Api& api)\n    : ca_cert_(Config::DataSource::read(config.trusted_ca(), true, api)),\n      ca_cert_path_(Config::DataSource::getPath(config.trusted_ca())\n                        .value_or(ca_cert_.empty() ? EMPTY_STRING : INLINE_STRING)),\n      certificate_revocation_list_(Config::DataSource::read(config.crl(), true, api)),\n      certificate_revocation_list_path_(\n          Config::DataSource::getPath(config.crl())\n              .value_or(certificate_revocation_list_.empty() ? EMPTY_STRING : INLINE_STRING)),\n      subject_alt_name_matchers_(config.match_subject_alt_names().begin(),\n                                 config.match_subject_alt_names().end()),\n      verify_certificate_hash_list_(config.verify_certificate_hash().begin(),\n                                    config.verify_certificate_hash().end()),\n      verify_certificate_spki_list_(config.verify_certificate_spki().begin(),\n                                    config.verify_certificate_spki().end()),\n      allow_expired_certificate_(config.allow_expired_certificate()),\n      trust_chain_verification_(config.trust_chain_verification()),\n      custom_validator_config_(\n          config.has_custom_validator_config()\n              ? absl::make_optional<envoy::config::core::v3::TypedExtensionConfig>(\n                    config.custom_validator_config())\n              : absl::nullopt),\n      api_(api), only_verify_leaf_cert_crl_(config.only_verify_leaf_cert_crl()) {\n  if (ca_cert_.empty() && custom_validator_config_ == absl::nullopt) {\n    if (!certificate_revocation_list_.empty()) {\n      throw EnvoyException(fmt::format(\"Failed to load CRL from {} without trusted CA\",\n                                       certificateRevocationListPath()));\n    }\n    if (!subject_alt_name_matchers_.empty()) {\n      throw EnvoyException(\"SAN-based verification of peer certificates without \"\n                           \"trusted CA is insecure and not allowed\");\n    }\n    if (allow_expired_certificate_) {\n      throw EnvoyException(\"Certificate validity period is always ignored without trusted CA\");\n    }\n  }\n}", "target": 1}
{"code": "SYSCALL_DEFINE2(timerfd_create, int, clockid, int, flags)\n{\n\tint ufd;\n\tstruct timerfd_ctx *ctx;\n\tBUILD_BUG_ON(TFD_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON(TFD_NONBLOCK != O_NONBLOCK);\n\tif ((flags & ~TFD_CREATE_FLAGS) ||\n\t    (clockid != CLOCK_MONOTONIC &&\n\t     clockid != CLOCK_REALTIME &&\n\t     clockid != CLOCK_REALTIME_ALARM &&\n\t     clockid != CLOCK_BOOTTIME &&\n\t     clockid != CLOCK_BOOTTIME_ALARM))\n\t\treturn -EINVAL;\n\tif (!capable(CAP_WAKE_ALARM) &&\n\t    (clockid == CLOCK_REALTIME_ALARM ||\n\t     clockid == CLOCK_BOOTTIME_ALARM))\n\t\treturn -EPERM;\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\tinit_waitqueue_head(&ctx->wqh);\n\tspin_lock_init(&ctx->cancel_lock);\n\tctx->clockid = clockid;\n\tif (isalarm(ctx))\n\t\talarm_init(&ctx->t.alarm,\n\t\t\t   ctx->clockid == CLOCK_REALTIME_ALARM ?\n\t\t\t   ALARM_REALTIME : ALARM_BOOTTIME,\n\t\t\t   timerfd_alarmproc);\n\telse\n\t\thrtimer_init(&ctx->t.tmr, clockid, HRTIMER_MODE_ABS);\n\tctx->moffs = ktime_mono_to_real(0);\n\tufd = anon_inode_getfd(\"[timerfd]\", &timerfd_fops, ctx,\n\t\t\t       O_RDWR | (flags & TFD_SHARED_FCNTL_FLAGS));\n\tif (ufd < 0)\n\t\tkfree(ctx);\n\treturn ufd;\n}", "target": 0}
{"code": "int64_t OpLevelCostEstimator::CalculateTensorSize(\n    const OpInfo::TensorProperties& tensor, bool* found_unknown_shapes) {\n  int64_t count = CalculateTensorElementCount(tensor, found_unknown_shapes);\n  int size = DataTypeSize(BaseType(tensor.dtype()));\n  VLOG(2) << \"Count: \" << count << \" DataTypeSize: \" << size;\n  return count * size;\n}", "target": 1}
{"code": "BOOL license_read_scope_list(wStream* s, SCOPE_LIST* scopeList)\n{\n\tUINT32 i;\n\tUINT32 scopeCount;\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\tStream_Read_UINT32(s, scopeCount); \n        if (Stream_GetRemainingLength(s) / sizeof(LICENSE_BLOB) < scopeCount)\n                return FALSE;  \n\tscopeList->count = scopeCount;\n\tscopeList->array = (LICENSE_BLOB*) malloc(sizeof(LICENSE_BLOB) * scopeCount);\n\tfor (i = 0; i < scopeCount; i++)\n\t{\n\t\tscopeList->array[i].type = BB_SCOPE_BLOB;\n\t\tif (!license_read_binary_blob(s, &scopeList->array[i]))\n\t\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 0}
{"code": "static int kvm_set_guest_paused(struct kvm_vcpu *vcpu)\n{\n\tif (!vcpu->arch.time_page)\n\t\treturn -EINVAL;\n\tvcpu->arch.pvclock_set_guest_stopped_request = true;\n\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\treturn 0;\n}", "target": 1}
{"code": "void mp_decode_to_lua_array(lua_State *L, mp_cur *c, size_t len) {\n    assert(len <= UINT_MAX);\n    int index = 1;\n    lua_newtable(L);\n    luaL_checkstack(L, 1, \"in function mp_decode_to_lua_array\");\n    while(len--) {\n        lua_pushnumber(L,index++);\n        mp_decode_to_lua_type(L,c);\n        if (c->err) return;\n        lua_settable(L,-3);\n    }\n}", "target": 0}
{"code": "teardown_digests(cms_context *ctx)\n{\n\tstruct digest *digests = ctx->digests;\n\tif (!digests)\n\t\treturn;\n\tfor (int i = 0; i < n_digest_params; i++) {\n\t\tif (digests[i].pk11ctx) {\n\t\t\tPK11_Finalize(digests[i].pk11ctx);\n\t\t\tPK11_DestroyContext(digests[i].pk11ctx, PR_TRUE);\n\t\t}\n\t\tif (digests[i].pe_digest) {\n\t\t\tdigests[i].pe_digest = NULL;\n\t\t}\n\t}\n\tPORT_Free(digests);\n\tctx->digests = NULL;\n}", "target": 0}
{"code": "static void _isdn_setup(struct net_device *dev)\n{\n\tisdn_net_local *lp = netdev_priv(dev);\n\tether_setup(dev);\n\tdev->flags = IFF_NOARP|IFF_POINTOPOINT;\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tdev->header_ops = NULL;\n\tdev->netdev_ops = &isdn_netdev_ops;\n\tdev->tx_queue_len = 30;\n\tlp->p_encap = ISDN_NET_ENCAP_RAWIP;\n\tlp->magic = ISDN_NET_MAGIC;\n\tlp->last = lp;\n\tlp->next = lp;\n\tlp->isdn_device = -1;\n\tlp->isdn_channel = -1;\n\tlp->pre_device = -1;\n\tlp->pre_channel = -1;\n\tlp->exclusive = -1;\n\tlp->ppp_slot = -1;\n\tlp->pppbind = -1;\n\tskb_queue_head_init(&lp->super_tx_queue);\n\tlp->l2_proto = ISDN_PROTO_L2_X75I;\n\tlp->l3_proto = ISDN_PROTO_L3_TRANS;\n\tlp->triggercps = 6000;\n\tlp->slavedelay = 10 * HZ;\n\tlp->hupflags = ISDN_INHUP;\t\n\tlp->onhtime = 10;\t\n\tlp->dialmax = 1;\n\tlp->flags = ISDN_NET_CBHUP | ISDN_NET_DM_MANUAL;\n\tlp->cbdelay = 25;\t\n\tlp->dialtimeout = -1;  \n\tlp->dialwait = 5 * HZ; \n\tlp->dialstarted = 0;   \n\tlp->dialwait_timer = 0;  \n}", "target": 0}
{"code": "static int validate_core_offset(const struct kvm_one_reg *reg)\n{\n\tu64 off = core_reg_offset_from_id(reg->id);\n\tint size;\n\tswitch (off) {\n\tcase KVM_REG_ARM_CORE_REG(regs.regs[0]) ...\n\t     KVM_REG_ARM_CORE_REG(regs.regs[30]):\n\tcase KVM_REG_ARM_CORE_REG(regs.sp):\n\tcase KVM_REG_ARM_CORE_REG(regs.pc):\n\tcase KVM_REG_ARM_CORE_REG(regs.pstate):\n\tcase KVM_REG_ARM_CORE_REG(sp_el1):\n\tcase KVM_REG_ARM_CORE_REG(elr_el1):\n\tcase KVM_REG_ARM_CORE_REG(spsr[0]) ...\n\t     KVM_REG_ARM_CORE_REG(spsr[KVM_NR_SPSR - 1]):\n\t\tsize = sizeof(__u64);\n\t\tbreak;\n\tcase KVM_REG_ARM_CORE_REG(fp_regs.vregs[0]) ...\n\t     KVM_REG_ARM_CORE_REG(fp_regs.vregs[31]):\n\t\tsize = sizeof(__uint128_t);\n\t\tbreak;\n\tcase KVM_REG_ARM_CORE_REG(fp_regs.fpsr):\n\tcase KVM_REG_ARM_CORE_REG(fp_regs.fpcr):\n\t\tsize = sizeof(__u32);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (KVM_REG_SIZE(reg->id) == size &&\n\t    IS_ALIGNED(off, size / sizeof(__u32)))\n\t\treturn 0;\n\treturn -EINVAL;\n}", "target": 0}
{"code": "int fscrypt_setup_filename(struct inode *dir, const struct qstr *iname,\n\t\t\t      int lookup, struct fscrypt_name *fname)\n{\n\tint ret = 0, bigname = 0;\n\tmemset(fname, 0, sizeof(struct fscrypt_name));\n\tfname->usr_fname = iname;\n\tif (!dir->i_sb->s_cop->is_encrypted(dir) ||\n\t\t\t\tfscrypt_is_dot_dotdot(iname)) {\n\t\tfname->disk_name.name = (unsigned char *)iname->name;\n\t\tfname->disk_name.len = iname->len;\n\t\treturn 0;\n\t}\n\tret = fscrypt_get_crypt_info(dir);\n\tif (ret && ret != -EOPNOTSUPP)\n\t\treturn ret;\n\tif (dir->i_crypt_info) {\n\t\tret = fscrypt_fname_alloc_buffer(dir, iname->len,\n\t\t\t\t\t\t\t&fname->crypto_buf);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = fname_encrypt(dir, iname, &fname->crypto_buf);\n\t\tif (ret)\n\t\t\tgoto errout;\n\t\tfname->disk_name.name = fname->crypto_buf.name;\n\t\tfname->disk_name.len = fname->crypto_buf.len;\n\t\treturn 0;\n\t}\n\tif (!lookup)\n\t\treturn -ENOKEY;\n\tif (iname->name[0] == '_')\n\t\tbigname = 1;\n\tif ((bigname && (iname->len != 33)) || (!bigname && (iname->len > 43)))\n\t\treturn -ENOENT;\n\tfname->crypto_buf.name = kmalloc(32, GFP_KERNEL);\n\tif (fname->crypto_buf.name == NULL)\n\t\treturn -ENOMEM;\n\tret = digest_decode(iname->name + bigname, iname->len - bigname,\n\t\t\t\tfname->crypto_buf.name);\n\tif (ret < 0) {\n\t\tret = -ENOENT;\n\t\tgoto errout;\n\t}\n\tfname->crypto_buf.len = ret;\n\tif (bigname) {\n\t\tmemcpy(&fname->hash, fname->crypto_buf.name, 4);\n\t\tmemcpy(&fname->minor_hash, fname->crypto_buf.name + 4, 4);\n\t} else {\n\t\tfname->disk_name.name = fname->crypto_buf.name;\n\t\tfname->disk_name.len = fname->crypto_buf.len;\n\t}\n\treturn 0;\nerrout:\n\tfscrypt_fname_free_buffer(&fname->crypto_buf);\n\treturn ret;\n}", "target": 1}
{"code": "static bool checkreturn pb_dec_string(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    uint32_t size;\n    size_t alloc_size;\n    bool status;\n    if (!pb_decode_varint32(stream, &size))\n        return false;\n    alloc_size = size + 1;\n    if (alloc_size < size)\n        PB_RETURN_ERROR(stream, \"size too large\");\n    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)\n    {\n#ifndef PB_ENABLE_MALLOC\n        PB_RETURN_ERROR(stream, \"no malloc support\");\n#else\n        if (!allocate_field(stream, dest, alloc_size, 1))\n            return false;\n        dest = *(void**)dest;\n#endif\n    }\n    else\n    {\n        if (alloc_size > field->data_size)\n            PB_RETURN_ERROR(stream, \"string overflow\");\n    }\n    status = pb_read(stream, (uint8_t*)dest, size);\n    *((uint8_t*)dest + size) = 0;\n    return status;\n}", "target": 0}
{"code": "static struct sk_buff **ipip_gro_receive(struct sk_buff **head,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tif (NAPI_GRO_CB(skb)->encap_mark) {\n\t\tNAPI_GRO_CB(skb)->flush = 1;\n\t\treturn NULL;\n\t}\n\tNAPI_GRO_CB(skb)->encap_mark = 1;\n\treturn inet_gro_receive(head, skb);\n}", "target": 0}
{"code": "static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tstruct mmu_gather tlb;\n\tstruct vm_area_struct *vma;\n\tbool ret = true;\n\tmutex_lock(&oom_lock);\n\tif (!down_read_trylock(&mm->mmap_sem)) {\n\t\tret = false;\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\tif (mm_has_notifiers(mm)) {\n\t\tup_read(&mm->mmap_sem);\n\t\tschedule_timeout_idle(HZ);\n\t\tgoto unlock_oom;\n\t}\n\tif (test_bit(MMF_OOM_SKIP, &mm->flags)) {\n\t\tup_read(&mm->mmap_sem);\n\t\ttrace_skip_task_reaping(tsk->pid);\n\t\tgoto unlock_oom;\n\t}\n\ttrace_start_task_reaping(tsk->pid);\n\tset_bit(MMF_UNSTABLE, &mm->flags);\n\ttlb_gather_mmu(&tlb, mm, 0, -1);\n\tfor (vma = mm->mmap ; vma; vma = vma->vm_next) {\n\t\tif (!can_madv_dontneed_vma(vma))\n\t\t\tcontinue;\n\t\tif (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED))\n\t\t\tunmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end,\n\t\t\t\t\t NULL);\n\t}\n\ttlb_finish_mmu(&tlb, 0, -1);\n\tpr_info(\"oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\\n\",\n\t\t\ttask_pid_nr(tsk), tsk->comm,\n\t\t\tK(get_mm_counter(mm, MM_ANONPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_FILEPAGES)),\n\t\t\tK(get_mm_counter(mm, MM_SHMEMPAGES)));\n\tup_read(&mm->mmap_sem);\n\ttrace_finish_task_reaping(tsk->pid);\nunlock_oom:\n\tmutex_unlock(&oom_lock);\n\treturn ret;\n}", "target": 1}
{"code": "static inline int ccid_hc_tx_getsockopt(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\tconst int optname, int len,\n\t\t\t\t\tu32 __user *optval, int __user *optlen)\n{\n\tint rc = -ENOPROTOOPT;\n\tif (ccid->ccid_ops->ccid_hc_tx_getsockopt != NULL)\n\t\trc = ccid->ccid_ops->ccid_hc_tx_getsockopt(sk, optname, len,\n\t\t\t\t\t\t optval, optlen);\n\treturn rc;\n}", "target": 1}
{"code": "void MutateSavedTensorSlices(\n    const std::string& fname,\n    const std::function<std::string(SavedTensorSlices)>& mutator) {\n  table::Options options;\n  options.compression = table::kNoCompression;\n  std::vector<std::pair<std::string, std::string>> entries;\n  {\n    std::unique_ptr<RandomAccessFile> file;\n    TF_CHECK_OK(Env::Default()->NewRandomAccessFile(fname, &file));\n    uint64 file_size;\n    TF_CHECK_OK(Env::Default()->GetFileSize(fname, &file_size));\n    table::Table* t;\n    TF_CHECK_OK(table::Table::Open(options, file.get(), file_size, &t));\n    std::unique_ptr<table::Table> table(t);\n    std::unique_ptr<table::Iterator> it(table->NewIterator());\n    for (it->Seek(\"\"); it->Valid(); it->Next()) {\n      entries.emplace_back(it->key(), it->value());\n    }\n    TF_CHECK_OK(it->status());\n  }\n  {\n    std::unique_ptr<WritableFile> file;\n    TF_CHECK_OK(Env::Default()->NewWritableFile(fname, &file));\n    table::TableBuilder builder(options, file.get());\n    for (const auto& entry : entries) {\n      SavedTensorSlices sts;\n      CHECK(sts.ParseFromString(entry.second));\n      builder.Add(entry.first, mutator(std::move(sts)));\n    }\n    TF_CHECK_OK(builder.Finish());\n    TF_CHECK_OK(file->Close());\n  }\n}", "target": 0}
{"code": "int insn_get_code_seg_params(struct pt_regs *regs)\n{\n\tstruct desc_struct *desc;\n\tshort sel;\n\tif (v8086_mode(regs))\n\t\treturn INSN_CODE_SEG_PARAMS(2, 2);\n\tsel = get_segment_selector(regs, INAT_SEG_REG_CS);\n\tif (sel < 0)\n\t\treturn sel;\n\tdesc = get_desc(sel);\n\tif (!desc)\n\t\treturn -EINVAL;\n\tif (!(desc->type & BIT(3)))\n\t\treturn -EINVAL;\n\tswitch ((desc->l << 1) | desc->d) {\n\tcase 0: \n\t\treturn INSN_CODE_SEG_PARAMS(2, 2);\n\tcase 1: \n\t\treturn INSN_CODE_SEG_PARAMS(4, 4);\n\tcase 2: \n\t\treturn INSN_CODE_SEG_PARAMS(4, 8);\n\tcase 3: \n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}", "target": 1}
{"code": "void ImmutableConstantOp::Compute(OpKernelContext* ctx) {\n  std::unique_ptr<MemmappedTensorAllocator> allocator(\n      new MemmappedTensorAllocator());\n  OP_REQUIRES_OK(ctx,\n                 allocator->InitializeFromRegion(region_name_, ctx->env()));\n  OP_REQUIRES(ctx, dtype_ != DT_STRING,\n              errors::Unimplemented(\"Sorry, DT_STRING is not currently \"\n                                    \"supported for ImmutableConstOp.\"));\n  ctx->set_output(0, Tensor(allocator.get(), dtype_, shape_));\n  OP_REQUIRES_OK(ctx, allocator->allocation_status());\n  allocator.release()->set_delete_on_deallocate();\n}", "target": 0}
{"code": "static void fuse_lib_setxattr(fuse_req_t req, fuse_ino_t ino, const char *name,\n                              const char *value, size_t size, int flags)\n{\n    struct fuse *f = req_fuse_prepare(req);\n    char *path;\n    int err;\n    err = -ENOENT;\n    pthread_rwlock_rdlock(&f->tree_lock);\n    path = get_path(f, ino);\n    if (path != NULL) {\n        struct fuse_intr_data d;\n        fuse_prepare_interrupt(f, req, &d);\n        err = fuse_fs_setxattr(f->fs, path, name, value, size, flags);\n        fuse_finish_interrupt(f, req, &d);\n        free(path);\n    }\n    pthread_rwlock_unlock(&f->tree_lock);\n    reply_err(req, err);\n}", "target": 0}
{"code": "static inline bool unconditional(const struct ipt_ip *ip)\n{\n\tstatic const struct ipt_ip uncond;\n\treturn memcmp(ip, &uncond, sizeof(uncond)) == 0;\n#undef FWINV\n}", "target": 1}
{"code": "static int ptrace_check_attach(struct task_struct *child, bool ignore_state)\n{\n\tint ret = -ESRCH;\n\tread_lock(&tasklist_lock);\n\tif ((child->ptrace & PT_PTRACED) && child->parent == current) {\n\t\tspin_lock_irq(&child->sighand->siglock);\n\t\tWARN_ON_ONCE(task_is_stopped(child));\n\t\tif (ignore_state || (task_is_traced(child) &&\n\t\t\t\t     !(child->jobctl & JOBCTL_LISTENING)))\n\t\t\tret = 0;\n\t\tspin_unlock_irq(&child->sighand->siglock);\n\t}\n\tread_unlock(&tasklist_lock);\n\tif (!ret && !ignore_state)\n\t\tret = wait_task_inactive(child, TASK_TRACED) ? 0 : -ESRCH;\n\treturn ret;\n}", "target": 1}
{"code": "void LosslessScan::ParseMCU(struct Line **prev,struct Line **top)\n{ \n#if ACCUSOFT_CODE\n  UBYTE i;\n  for(i = 0;i < m_ucCount;i++) {\n    class HuffmanDecoder *dc = m_pDCDecoder[i];\n    struct Line *line = top[i];\n    struct Line *pline= prev[i];\n    UBYTE ym = m_ucMCUHeight[i];\n    class PredictorBase *mcupred = m_pPredict[i];\n    LONG *lp = line->m_pData + m_ulX[i];\n    LONG *pp = (pline)?(pline->m_pData + m_ulX[i]):(NULL);\n    do {\n      class PredictorBase *pred = mcupred;\n      UBYTE xm = m_ucMCUWidth[i];\n      do {\n        LONG v;\n        UBYTE symbol = dc->Get(&m_Stream);\n        if (symbol == 0) {\n          v = 0;\n        } else if (symbol == 16) {\n          v = -32768;\n        } else if (symbol > 16) {\n          JPG_THROW(MALFORMED_STREAM,\"LosslessScan::ParseMCU\",\n                    \"received an out-of-bounds symbol in a lossless JPEG scan\");\n        } else {\n          LONG thre = 1L << (symbol - 1);\n          LONG diff = m_Stream.Get(symbol); \n          if (diff < thre) {\n            diff += (-1L << symbol) + 1;\n          }\n          v = diff;\n        }\n        lp[0] = pred->DecodeSample(v,lp,pp);\n      } while(--xm && (lp++,pp++,pred = pred->MoveRight(),true));\n    } while(--ym && (pp = line->m_pData + m_ulX[i],line = (line->m_pNext)?(line->m_pNext):(line),\n                     lp = line->m_pData + m_ulX[i],mcupred = mcupred->MoveDown(),true));\n  }\n#else\n  NOREF(prev);\n  NOREF(top);\n#endif\n}", "target": 0}
{"code": "ia64_patch_rse (unsigned long start, unsigned long end)\n{\n\ts32 *offp = (s32 *) start;\n\tu64 ip, *b;\n\twhile (offp < (s32 *) end) {\n\t\tip = (u64) offp + *offp;\n\t\tb = (u64 *)(ip & -16);\n\t\tb[1] &= ~0xf800000L;\n\t\tia64_fc((void *) ip);\n\t\t++offp;\n\t}\n\tia64_sync_i();\n\tia64_srlz_i();\n}", "target": 0}
{"code": "fbFetch_r8g8b8 (const FbBits *bits, int x, int width, CARD32 *buffer, miIndexedPtr indexed)\n{\n    const CARD8 *pixel = (const CARD8 *)bits + 3*x;\n    const CARD8 *end = pixel + 3*width;\n    while (pixel < end) {\n        CARD32 b = Fetch24(pixel) | 0xff000000;\n        pixel += 3;\n        WRITE(buffer++, b);\n    }\n}", "target": 0}
{"code": "SMB2_open_free(struct smb_rqst *rqst)\n{\n\tint i;\n\tif (rqst && rqst->rq_iov) {\n\t\tcifs_small_buf_release(rqst->rq_iov[0].iov_base);\n\t\tfor (i = 1; i < rqst->rq_nvec; i++)\n\t\t\tif (rqst->rq_iov[i].iov_base != smb2_padding)\n\t\t\t\tkfree(rqst->rq_iov[i].iov_base);\n\t}\n}", "target": 0}
{"code": "monitor_sync(struct monitor *pmonitor)\n{\n\tif (options.compression) {\n\t\tmm_share_sync(&pmonitor->m_zlib, &pmonitor->m_zback);\n\t}\n}", "target": 1}
{"code": "static inline int pmd_present(pmd_t pmd)\n{\n\treturn pmd_flags(pmd) & _PAGE_PRESENT;\n}", "target": 1}
{"code": "int mlx4_register_vlan(struct mlx4_dev *dev, u8 port, u16 vlan, int *index)\n{\n\tstruct mlx4_vlan_table *table = &mlx4_priv(dev)->port[port].vlan_table;\n\tint i, err = 0;\n\tint free = -1;\n\tmutex_lock(&table->mutex);\n\tfor (i = MLX4_VLAN_REGULAR; i < MLX4_MAX_VLAN_NUM; i++) {\n\t\tif (free < 0 && (table->refs[i] == 0)) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (table->refs[i] &&\n\t\t    (vlan == (MLX4_VLAN_MASK &\n\t\t\t      be32_to_cpu(table->entries[i])))) {\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (free < 0) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (table->total == table->max) {\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be32(vlan | MLX4_VLAN_VALID);\n\terr = mlx4_set_port_vlan_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_warn(dev, \"Failed adding vlan: %u\\n\", vlan);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}", "target": 0}
{"code": "LogLuvClose(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\ttd->td_samplesperpixel =\n\t    (td->td_photometric == PHOTOMETRIC_LOGL) ? 1 : 3;\n\ttd->td_bitspersample = 16;\n\ttd->td_sampleformat = SAMPLEFORMAT_INT;\n}", "target": 1}
{"code": "int scsi_verify_blk_ioctl(struct block_device *bd, unsigned int cmd)\n{\n\tif (bd && bd == bd->bd_contains)\n\t\treturn 0;\n\tswitch (cmd) {\n\tcase SCSI_IOCTL_GET_IDLUN:\n\tcase SCSI_IOCTL_GET_BUS_NUMBER:\n\tcase SCSI_IOCTL_GET_PCI:\n\tcase SCSI_IOCTL_PROBE_HOST:\n\tcase SG_GET_VERSION_NUM:\n\tcase SG_SET_TIMEOUT:\n\tcase SG_GET_TIMEOUT:\n\tcase SG_GET_RESERVED_SIZE:\n\tcase SG_SET_RESERVED_SIZE:\n\tcase SG_EMULATED_HOST:\n\t\treturn 0;\n\tcase CDROM_GET_CAPABILITY:\n\t\treturn -ENOIOCTLCMD;\n\tdefault:\n\t\tbreak;\n\t}\n\tprintk_ratelimited(KERN_WARNING\n\t\t\t   \"%s: sending ioctl %x to a partition!\\n\", current->comm, cmd);\n\treturn capable(CAP_SYS_RAWIO) ? 0 : -ENOIOCTLCMD;\n}", "target": 0}
{"code": "    const std::unordered_map<std::string, Cookie> &getCookies() const\n    {\n        return cookies();\n    }", "target": 1}
{"code": "static inline void write_s3row_data(\n\tconst entity_stage3_row *r,\n\tunsigned orig_cp,\n\tenum entity_charset charset,\n\tzval *arr)\n{\n\tchar key[9] = \"\"; \n\tchar entity[LONGEST_ENTITY_LENGTH + 2] = {'&'};\n\tsize_t written_k1;\n\twritten_k1 = write_octet_sequence(key, charset, orig_cp);\n\tif (!r->ambiguous) {\n\t\tsize_t l = r->data.ent.entity_len;\n\t\tmemcpy(&entity[1], r->data.ent.entity, l);\n\t\tentity[l + 1] = ';';\n\t\tadd_assoc_stringl_ex(arr, key, written_k1 + 1, entity, l + 2, 1);\n\t} else {\n\t\tunsigned i,\n\t\t\t     num_entries;\n\t\tconst entity_multicodepoint_row *mcpr = r->data.multicodepoint_table;\n\t\tif (mcpr[0].leading_entry.default_entity != NULL) {\n\t\t\tsize_t l = mcpr[0].leading_entry.default_entity_len;\n\t\t\tmemcpy(&entity[1], mcpr[0].leading_entry.default_entity, l);\n\t\t\tentity[l + 1] = ';';\n\t\t\tadd_assoc_stringl_ex(arr, key, written_k1 + 1, entity, l + 2, 1);\n\t\t}\n\t\tnum_entries = mcpr[0].leading_entry.size;\n\t\tfor (i = 1; i <= num_entries; i++) {\n\t\t\tsize_t   l,\n\t\t\t\t     written_k2;\n\t\t\tunsigned uni_cp,\n\t\t\t\t\t spe_cp;\n\t\t\tuni_cp = mcpr[i].normal_entry.second_cp;\n\t\t\tl = mcpr[i].normal_entry.entity_len;\n\t\t\tif (!CHARSET_UNICODE_COMPAT(charset)) {\n\t\t\t\tif (map_from_unicode(uni_cp, charset, &spe_cp) == FAILURE)\n\t\t\t\t\tcontinue; \n\t\t\t} else {\n\t\t\t\tspe_cp = uni_cp;\n\t\t\t}\n\t\t\twritten_k2 = write_octet_sequence(&key[written_k1], charset, spe_cp);\n\t\t\tmemcpy(&entity[1], mcpr[i].normal_entry.entity, l);\n\t\t\tentity[l + 1] = ';';\n\t\t\tentity[l + 1] = '\\0';\n\t\t\tadd_assoc_stringl_ex(arr, key, written_k1 + written_k2 + 1, entity, l + 1, 1);\n\t\t}\n\t}\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in_shape = context->input(0);\n    const Tensor& out_backprop = context->input(1);\n    OP_REQUIRES(\n        context,\n        tensor_in_shape.dims() == 1 && tensor_in_shape.NumElements() == 5,\n        errors::InvalidArgument(\"tensor_in must be 1-dimensional and 5 \"\n                                \"elements\"));\n    OP_REQUIRES(context, out_backprop.dims() == 5,\n                errors::InvalidArgument(\"out_backprop must be 5-dimensional\"));\n    TensorShape output_shape;\n    auto shape_vec = tensor_in_shape.vec<int32>();\n    for (int64_t i = 0; i < tensor_in_shape.NumElements(); ++i) {\n      output_shape.AddDim(shape_vec(i));\n    }\n    Tensor* output;\n    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n    std::array<int64_t, 3> input_size{\n        {GetTensorDim(output_shape, data_format_, '2'),\n         GetTensorDim(output_shape, data_format_, '1'),\n         GetTensorDim(output_shape, data_format_, '0')}};\n    std::array<int64_t, 3> window{{GetTensorDim(ksize_, data_format_, '2'),\n                                   GetTensorDim(ksize_, data_format_, '1'),\n                                   GetTensorDim(ksize_, data_format_, '0')}};\n    std::array<int64_t, 3> stride{{GetTensorDim(stride_, data_format_, '2'),\n                                   GetTensorDim(stride_, data_format_, '1'),\n                                   GetTensorDim(stride_, data_format_, '0')}};\n    std::array<int64_t, 3> padding, out;\n    OP_REQUIRES_OK(context, Get3dOutputSize(input_size, window, stride,\n                                            padding_, &out, &padding));\n    LaunchAvgPooling3dGradOp<Device, T>::launch(\n        context, output_shape, out_backprop, window, stride, out, padding,\n        data_format_, output);\n  }", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& prefix = context->input(0);\n    const Tensor& tensor_names = context->input(1);\n    const Tensor& shape_and_slices = context->input(2);\n    OP_REQUIRES(context, tensor_names.NumElements() == dtypes_.size(),\n                errors::InvalidArgument(\"Got \", tensor_names.NumElements(),\n                                        \" tensor names, but \", dtypes_.size(),\n                                        \" expected dtypes.\"));\n    ValidateInputs(false , context, prefix, tensor_names,\n                   shape_and_slices);\n    if (!context->status().ok()) return;\n    const string& prefix_string = prefix.scalar<tstring>()();\n    Env* env = Env::Default();\n    std::vector<string> paths;\n    if (!env->GetMatchingPaths(MetaFilename(prefix_string), &paths).ok() ||\n        paths.empty()) {\n      for (size_t i = 0; i < tensor_names.NumElements(); ++i) {\n        RestoreTensor(context, &checkpoint::OpenTableTensorSliceReader,\n                       -1,  true,\n                       i);\n        if (!context->status().ok()) {\n          return;\n        }\n      }\n      return;\n    }\n    OP_REQUIRES_OK(context, RestoreTensorsV2(context, prefix, tensor_names,\n                                             shape_and_slices, dtypes_));\n  }", "target": 0}
{"code": "static int nr_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t      struct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;\n\tsize_t copied;\n\tstruct sk_buff *skb;\n\tint er;\n\tlock_sock(sk);\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\trelease_sock(sk);\n\t\treturn -ENOTCONN;\n\t}\n\tif ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL) {\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\tskb_reset_transport_header(skb);\n\tcopied     = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\ter = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (er < 0) {\n\t\tskb_free_datagram(sk, skb);\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\tif (sax != NULL) {\n\t\tmemset(sax, 0, sizeof(*sax));\n\t\tsax->sax25_family = AF_NETROM;\n\t\tskb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,\n\t\t\t      AX25_ADDR_LEN);\n\t\tmsg->msg_namelen = sizeof(*sax);\n\t}\n\tskb_free_datagram(sk, skb);\n\trelease_sock(sk);\n\treturn copied;\n}", "target": 0}
{"code": "int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)\n{\n\tunsigned int offset = sizeof(struct ipv6hdr);\n\tunsigned int packet_len = skb_tail_pointer(skb) -\n\t\tskb_network_header(skb);\n\tint found_rhdr = 0;\n\t*nexthdr = &ipv6_hdr(skb)->nexthdr;\n\twhile (offset <= packet_len) {\n\t\tstruct ipv6_opt_hdr *exthdr;\n\t\tunsigned int len;\n\t\tswitch (**nexthdr) {\n\t\tcase NEXTHDR_HOP:\n\t\t\tbreak;\n\t\tcase NEXTHDR_ROUTING:\n\t\t\tfound_rhdr = 1;\n\t\t\tbreak;\n\t\tcase NEXTHDR_DEST:\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\t\tif (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)\n\t\t\t\tbreak;\n#endif\n\t\t\tif (found_rhdr)\n\t\t\t\treturn offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn offset;\n\t\t}\n\t\tif (offset + sizeof(struct ipv6_opt_hdr) > packet_len)\n\t\t\treturn -EINVAL;\n\t\texthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +\n\t\t\t\t\t\t offset);\n\t\tlen = ipv6_optlen(exthdr);\n\t\tif (len + offset >= IPV6_MAXPLEN)\n\t\t\treturn -EINVAL;\n\t\toffset += len;\n\t\t*nexthdr = &exthdr->nexthdr;\n\t}\n\treturn -EINVAL;\n}", "target": 0}
{"code": "DECLAREreadFunc(readContigTilesIntoBuffer)\n{\n\tint status = 1;\n\ttsize_t tilesize = TIFFTileSize(in);\n\ttdata_t tilebuf;\n\tuint32 imagew = TIFFScanlineSize(in);\n\tuint32 tilew  = TIFFTileRowSize(in);\n\tint64 iskew = (int64)imagew - (int64)tilew;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tw, tl;\n\tuint32 row;\n\t(void) spp;\n\ttilebuf = _TIFFmalloc(tilesize);\n\tif (tilebuf == 0)\n\t\treturn 0;\n\t_TIFFmemset(tilebuf, 0, tilesize);\n\t(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n\t(void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n\tfor (row = 0; row < imagelength; row += tl) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\t\tfor (col = 0; col < imagewidth && colb < imagew; col += tw) {\n\t\t\tif (TIFFReadTile(in, tilebuf, col, row, 0, 0) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read tile at %lu %lu\",\n\t\t\t\t    (unsigned long) col,\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (colb > iskew) {\n\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\tuint32 oskew = tilew - width;\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, width,\n\t\t\t\t    oskew + iskew, oskew );\n\t\t\t} else\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, tilew,\n\t\t\t\t    iskew, 0);\n\t\t\tcolb += tilew;\n\t\t}\n\t\tbufp += imagew * nrow;\n\t}\ndone:\n\t_TIFFfree(tilebuf);\n\treturn status;\n}", "target": 0}
{"code": "void infra_wait_limit_dec(struct infra_cache* infra, struct comm_reply* rep,\n\tstruct config_file* cfg)\n{\n\tstruct lruhash_entry* entry;\n\tif(cfg->wait_limit == 0)\n\t\treturn;\n\tentry = infra_find_ip_ratedata(infra, &rep->client_addr,\n\t\trep->client_addrlen, 1);\n\tif(entry) {\n\t\tstruct rate_data* d = (struct rate_data*)entry->data;\n\t\tif(d->mesh_wait > 0)\n\t\t\td->mesh_wait--;\n\t\tlock_rw_unlock(&entry->lock);\n\t}\n}", "target": 0}
{"code": "MagickExport void CatchException(ExceptionInfo *exception)\n{\n  register const ExceptionInfo\n    *p;\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (exception->exceptions  == (void *) NULL)\n    return;\n  LockSemaphoreInfo(exception->semaphore);\n  ResetLinkedListIterator((LinkedListInfo *) exception->exceptions);\n  p=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)\n    exception->exceptions);\n  while (p != (const ExceptionInfo *) NULL)\n  {\n    if ((p->severity >= WarningException) && (p->severity < ErrorException))\n      MagickWarning(p->severity,p->reason,p->description);\n    if ((p->severity >= ErrorException) && (p->severity < FatalErrorException))\n      MagickError(p->severity,p->reason,p->description);\n    if (p->severity >= FatalErrorException)\n      MagickFatalError(p->severity,p->reason,p->description);\n    p=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)\n      exception->exceptions);\n  }\n  UnlockSemaphoreInfo(exception->semaphore);\n  ClearMagickException(exception);\n}", "target": 1}
{"code": "TEST_F(EncryptedRecordTest, TestAllPaddingHandshake) {\n  addToQueue(\"17030100050123456789\");\n  EXPECT_CALL(*readAead_, _decrypt(_, _, 0))\n      .WillOnce(Invoke([](std::unique_ptr<IOBuf>& buf, const IOBuf*, uint64_t) {\n        expectSame(buf, \"0123456789\");\n        return getBuf(\"16000000\");\n      }));\n  EXPECT_NO_THROW(read_.read(queue_));\n}", "target": 1}
{"code": "static unsigned mounts_poll(struct file *file, poll_table *wait)\n{\n\tstruct proc_mounts *p = file->private_data;\n\tstruct mnt_namespace *ns = p->m.private;\n\tunsigned res = 0;\n\tpoll_wait(file, &ns->poll, wait);\n\tspin_lock(&vfsmount_lock);\n\tif (p->event != ns->event) {\n\t\tp->event = ns->event;\n\t\tres = POLLERR;\n\t}\n\tspin_unlock(&vfsmount_lock);\n\treturn res;\n}", "target": 0}
{"code": "void flush_tlb_page(struct vm_area_struct *vma, unsigned long start)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpreempt_disable();\n\tif (current->active_mm == mm) {\n\t\tif (current->mm)\n\t\t\t__flush_tlb_one(start);\n\t\telse\n\t\t\tleave_mm(smp_processor_id());\n\t}\n\tif (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids)\n\t\tflush_tlb_others(mm_cpumask(mm), mm, start, 0UL);\n\tpreempt_enable();\n}", "target": 1}
{"code": "nfsd4_layout_verify(struct svc_export *exp, unsigned int layout_type)\n{\n\tif (!exp->ex_layout_types) {\n\t\tdprintk(\"%s: export does not support pNFS\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tif (!(exp->ex_layout_types & (1 << layout_type))) {\n\t\tdprintk(\"%s: layout type %d not supported\\n\",\n\t\t\t__func__, layout_type);\n\t\treturn NULL;\n\t}\n\treturn nfsd4_layout_ops[layout_type];\n}", "target": 1}
{"code": "static void tun_net_init(struct net_device *dev)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\tswitch (tun->flags & TUN_TYPE_MASK) {\n\tcase TUN_TUN_DEV:\n\t\tdev->netdev_ops = &tun_netdev_ops;\n\t\tdev->hard_header_len = 0;\n\t\tdev->addr_len = 0;\n\t\tdev->mtu = 1500;\n\t\tdev->type = ARPHRD_NONE;\n\t\tdev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;\n\t\tdev->tx_queue_len = TUN_READQ_SIZE;  \n\t\tbreak;\n\tcase TUN_TAP_DEV:\n\t\tdev->netdev_ops = &tap_netdev_ops;\n\t\tether_setup(dev);\n\t\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\t\trandom_ether_addr(dev->dev_addr);\n\t\tdev->tx_queue_len = TUN_READQ_SIZE;  \n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "dhcpv6_print(netdissect_options *ndo,\n             const u_char *cp, u_int length, int indent)\n{\n    u_int i, t;\n    const u_char *tlv, *value;\n    uint16_t type, optlen;\n    i = 0;\n    while (i < length) {\n        if (i + 4 > length)\n            return -1;\n        tlv = cp + i;\n        type = EXTRACT_16BITS(tlv);\n        optlen = EXTRACT_16BITS(tlv + 2);\n        value = tlv + 4;\n        ND_PRINT((ndo, \"\\n\"));\n        for (t = indent; t > 0; t--)\n            ND_PRINT((ndo, \"\\t\"));\n        ND_PRINT((ndo, \"%s\", tok2str(dh6opt_str, \"Unknown\", type)));\n        ND_PRINT((ndo,\" (%u)\", optlen + 4 ));\n        if (i + 4 + optlen > length)\n            return -1;\n        switch (type) {\n            case DH6OPT_DNS_SERVERS:\n            case DH6OPT_SNTP_SERVERS: {\n                if (optlen % 16 != 0) {\n                    ND_PRINT((ndo, \" %s\", istr));\n                    return -1;\n                }\n                for (t = 0; t < optlen; t += 16)\n                    ND_PRINT((ndo, \" %s\", ip6addr_string(ndo, value + t)));\n            }\n                break;\n            case DH6OPT_DOMAIN_LIST: {\n                const u_char *tp = value;\n                while (tp < value + optlen) {\n                    ND_PRINT((ndo, \" \"));\n                    if ((tp = ns_nprint(ndo, tp, value + optlen)) == NULL)\n                        return -1;\n                }\n            }\n                break;\n        }\n        i += 4 + optlen;\n    }\n    return 0;\n}", "target": 0}
{"code": "\t inline uLONG osdSwap4(uLONG *inLong) {\n\t return *inLong = DPT_Bswapl(*inLong);\n\t }", "target": 1}
{"code": "static int wc_ecc_gen_k(WC_RNG* rng, int size, mp_int* k, mp_int* order)\n{\n    int err;\n#ifdef WOLFSSL_SMALL_STACK\n    byte* buf;\n#else\n    byte  buf[ECC_MAXSIZE_GEN];\n#endif\n#ifdef WOLFSSL_SMALL_STACK\n    buf = (byte*)XMALLOC(ECC_MAXSIZE_GEN, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n    if (buf == NULL)\n        return MEMORY_E;\n#endif\n    size += 8;\n    err = wc_RNG_GenerateBlock(rng, buf, size);\n    if (err == 0)\n        err = mp_read_unsigned_bin(k, (byte*)buf, size);\n    if (err == MP_OKAY) {\n        if (mp_iszero(k) == MP_YES)\n          err = MP_ZERO_E;\n    }\n    if (err == MP_OKAY) {\n        if (mp_cmp(k, order) != MP_LT) {\n            err = mp_mod(k, order, k);\n        }\n    }\n    ForceZero(buf, ECC_MAXSIZE);\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(buf, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n#endif\n    return err;\n}", "target": 1}
{"code": "static void ctrycatchfinally(JF, js_Ast *trystm, js_Ast *catchvar, js_Ast *catchstm, js_Ast *finallystm)\n{\n\tint L1, L2, L3;\n\tL1 = emitjump(J, F, OP_TRY);\n\t{\n\t\tL2 = emitjump(J, F, OP_TRY);\n\t\t{\n\t\t\tcstm(J, F, finallystm); \n\t\t\temit(J, F, OP_THROW); \n\t\t}\n\t\tlabel(J, F, L2);\n\t\tif (F->strict) {\n\t\t\tcheckfutureword(J, F, catchvar);\n\t\t\tif (!strcmp(catchvar->string, \"arguments\"))\n\t\t\t\tjsC_error(J, catchvar, \"redefining 'arguments' is not allowed in strict mode\");\n\t\t\tif (!strcmp(catchvar->string, \"eval\"))\n\t\t\t\tjsC_error(J, catchvar, \"redefining 'eval' is not allowed in strict mode\");\n\t\t}\n\t\temitline(J, F, catchvar);\n\t\temitstring(J, F, OP_CATCH, catchvar->string);\n\t\tcstm(J, F, catchstm);\n\t\temit(J, F, OP_ENDCATCH);\n\t\temit(J, F, OP_ENDTRY);\n\t\tL3 = emitjump(J, F, OP_JUMP); \n\t}\n\tlabel(J, F, L1);\n\tcstm(J, F, trystm);\n\temit(J, F, OP_ENDTRY);\n\tlabel(J, F, L3);\n\tcstm(J, F, finallystm);\n}", "target": 0}
{"code": "fst_get_iface(struct fst_card_info *card, struct fst_port_info *port,\n\t      struct ifreq *ifr)\n{\n\tsync_serial_settings sync;\n\tint i;\n\tswitch (port->hwif) {\n\tcase E1:\n\t\tifr->ifr_settings.type = IF_IFACE_E1;\n\t\tbreak;\n\tcase T1:\n\t\tifr->ifr_settings.type = IF_IFACE_T1;\n\t\tbreak;\n\tcase V35:\n\t\tifr->ifr_settings.type = IF_IFACE_V35;\n\t\tbreak;\n\tcase V24:\n\t\tifr->ifr_settings.type = IF_IFACE_V24;\n\t\tbreak;\n\tcase X21D:\n\t\tifr->ifr_settings.type = IF_IFACE_X21D;\n\t\tbreak;\n\tcase X21:\n\tdefault:\n\t\tifr->ifr_settings.type = IF_IFACE_X21;\n\t\tbreak;\n\t}\n\tif (ifr->ifr_settings.size == 0) {\n\t\treturn 0;\t\n\t}\n\tif (ifr->ifr_settings.size < sizeof (sync)) {\n\t\treturn -ENOMEM;\n\t}\n\ti = port->index;\n\tmemset(&sync, 0, sizeof(sync));\n\tsync.clock_rate = FST_RDL(card, portConfig[i].lineSpeed);\n\tsync.clock_type = FST_RDB(card, portConfig[i].internalClock) ==\n\t    INTCLK ? CLOCK_INT : CLOCK_EXT;\n\tsync.loopback = 0;\n\tif (copy_to_user(ifr->ifr_settings.ifs_ifsu.sync, &sync, sizeof (sync))) {\n\t\treturn -EFAULT;\n\t}\n\tifr->ifr_settings.size = sizeof (sync);\n\treturn 0;\n}", "target": 0}
{"code": "static int ssl_parse_server_psk_hint( mbedtls_ssl_context *ssl,\n                                      unsigned char **p,\n                                      unsigned char *end )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n    size_t  len;\n    ((void) ssl);\n    if( (*p) > end - 2 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                    \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n    len = (*p)[0] << 8 | (*p)[1];\n    *p += 2;\n    if( (*p) > end - len )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                    \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n    *p += len;\n    ret = 0;\n    return( ret );\n}", "target": 0}
{"code": "static int sctp_setsockopt_auto_asconf(struct sock *sk, char __user *optval,\n\t\t\t\t\tunsigned int optlen)\n{\n\tint val;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\tif (!sctp_is_ep_boundall(sk) && val)\n\t\treturn -EINVAL;\n\tif ((val && sp->do_auto_asconf) || (!val && !sp->do_auto_asconf))\n\t\treturn 0;\n\tspin_lock_bh(&sock_net(sk)->sctp.addr_wq_lock);\n\tif (val == 0 && sp->do_auto_asconf) {\n\t\tlist_del(&sp->auto_asconf_list);\n\t\tsp->do_auto_asconf = 0;\n\t} else if (val && !sp->do_auto_asconf) {\n\t\tlist_add_tail(&sp->auto_asconf_list,\n\t\t    &sock_net(sk)->sctp.auto_asconf_splist);\n\t\tsp->do_auto_asconf = 1;\n\t}\n\tspin_unlock_bh(&sock_net(sk)->sctp.addr_wq_lock);\n\treturn 0;\n}", "target": 0}
{"code": "do_decrypt (const RIJNDAEL_context *ctx, unsigned char *bx,\n            const unsigned char *ax)\n{\n#ifdef USE_AMD64_ASM\n  return _gcry_aes_amd64_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,\n\t\t\t\t       &dec_tables);\n#elif defined(USE_ARM_ASM)\n  return _gcry_aes_arm_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,\n\t\t\t\t     &dec_tables);\n#else\n  return do_decrypt_fn (ctx, bx, ax);\n#endif \n}", "target": 1}
{"code": "R_API bool r_anal_vtable_begin(RAnal *anal, RVTableContext *context) {\n\tcontext->anal = anal;\n\tcontext->abi = anal->cxxabi;\n\tcontext->word_size = (ut8) (anal->config->bits / 8);\n\tconst bool is_arm = anal->cur->arch && r_str_startswith (anal->cur->arch, \"arm\");\n\tif (is_arm && context->word_size < 4) {\n\t\tcontext->word_size = 4;\n\t}\n\tconst bool be = anal->config->big_endian;\n\tswitch (context->word_size) {\n\tcase 1:\n\t\tcontext->read_addr = be? vtable_read_addr_be8 : vtable_read_addr_le8;\n\t\tbreak;\n\tcase 2:\n\t\tcontext->read_addr = be? vtable_read_addr_be16 : vtable_read_addr_le16;\n\t\tbreak;\n\tcase 4:\n\t\tcontext->read_addr = be? vtable_read_addr_be32 : vtable_read_addr_le32;\n\t\tbreak;\n\tcase 8:\n\t\tcontext->read_addr = be? vtable_read_addr_be64 : vtable_read_addr_le64;\n\t\tbreak;\n\tdefault:\n\t\tcontext->read_addr = be? vtable_read_addr_be32 : vtable_read_addr_le32;\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 0}
{"code": "static void coroutine_fn virtfs_reset(V9fsPDU *pdu)\n{\n    V9fsState *s = pdu->s;\n    V9fsFidState *fidp = NULL;\n    while (s->fid_list) {\n        fidp = s->fid_list;\n        s->fid_list = fidp->next;\n        if (fidp->ref) {\n            fidp->clunked = 1;\n        } else {\n            free_fid(pdu, fidp);\n        }\n    }\n    if (fidp) {\n        error_report(\"9pfs:%s: One or more uncluncked fids \"\n                     \"found during reset\", __func__);\n    }\n}", "target": 0}
{"code": "CURLcode Curl_urldecode(struct SessionHandle *data,\n                        const char *string, size_t length,\n                        char **ostring, size_t *olen,\n                        bool reject_ctrl)\n{\n  size_t alloc = (length?length:strlen(string))+1;\n  char *ns = malloc(alloc);\n  unsigned char in;\n  size_t strindex=0;\n  unsigned long hex;\n  CURLcode res;\n  if(!ns)\n    return CURLE_OUT_OF_MEMORY;\n  while(--alloc > 0) {\n    in = *string;\n    if(('%' == in) && ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {\n      char hexstr[3];\n      char *ptr;\n      hexstr[0] = string[1];\n      hexstr[1] = string[2];\n      hexstr[2] = 0;\n      hex = strtoul(hexstr, &ptr, 16);\n      in = curlx_ultouc(hex); \n      res = Curl_convert_from_network(data, &in, 1);\n      if(res) {\n        free(ns);\n        return res;\n      }\n      string+=2;\n      alloc-=2;\n    }\n    if(reject_ctrl && (in < 0x20)) {\n      free(ns);\n      return CURLE_URL_MALFORMAT;\n    }\n    ns[strindex++] = in;\n    string++;\n  }\n  ns[strindex]=0; \n  if(olen)\n    *olen = strindex;\n  if(ostring)\n    *ostring = ns;\n  return CURLE_OK;\n}", "target": 0}
{"code": "R_API int r_core_bin_set_env(RCore *r, RBinFile *binfile) {\n\tRBinObject *binobj = binfile ? binfile->o: NULL;\n\tRBinInfo *info = binobj ? binobj->info: NULL;\n\tif (info) {\n\t\tint va = info->has_va;\n\t\tconst char * arch = info->arch;\n\t\tut16 bits = info->bits;\n\t\tut64 baseaddr = r_bin_get_baddr (r->bin);\n\t\tr_config_set_i (r->config, \"io.va\",\n\t\t\t(binobj->info)? binobj->info->has_va: 0);\n\t\tr_config_set_i (r->config, \"bin.baddr\", baseaddr);\n\t\tr_config_set (r->config, \"asm.arch\", arch);\n\t\tr_config_set_i (r->config, \"asm.bits\", bits);\n\t\tr_config_set (r->config, \"anal.arch\", arch);\n\t\tif (info->cpu && *info->cpu) {\n\t\t\tr_config_set (r->config, \"anal.cpu\", info->cpu);\n\t\t} else {\n\t\t\tr_config_set (r->config, \"anal.cpu\", arch);\n\t\t}\n\t\tr_asm_use (r->assembler, arch);\n\t\tr_core_bin_info (r, R_CORE_BIN_ACC_ALL, R_CORE_BIN_SET, va, NULL, NULL);\n\t\tr_core_bin_set_cur (r, binfile);\n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)\n{\n        uint8* bufp = buf;\n        int32  bytes_read = 0;\n        uint32 strip, nstrips   = TIFFNumberOfStrips(in);\n        uint32 stripsize = TIFFStripSize(in);\n        uint32 rows = 0;\n        uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n        tsize_t scanline_size = TIFFScanlineSize(in);\n        if (scanline_size == 0) {\n                TIFFError(\"\", \"TIFF scanline size is zero!\");    \n                return 0;\n        }\n        for (strip = 0; strip < nstrips; strip++) {\n                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);\n                rows = bytes_read / scanline_size;\n                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))\n                        TIFFError(\"\", \"Strip %d: read %lu bytes, strip size %lu\",\n                                  (int)strip + 1, (unsigned long) bytes_read,\n                                  (unsigned long)stripsize);\n                if (bytes_read < 0 && !ignore) {\n                        TIFFError(\"\", \"Error reading strip %lu after %lu rows\",\n                                  (unsigned long) strip, (unsigned long)rows);\n                        return 0;\n                }\n                bufp += stripsize;\n        }\n        return 1;\n} ", "target": 0}
{"code": "static char *__filterShell(const char *arg) {\n\tr_return_val_if_fail (arg, NULL);\n\tchar *a = malloc (strlen (arg) + 1);\n\tif (!a) {\n\t\treturn NULL;\n\t}\n\tchar *b = a;\n\twhile (*arg) {\n\t\tswitch (*arg) {\n\t\tcase '@':\n\t\tcase '`':\n\t\tcase '|':\n\t\tcase ';':\n\t\tcase '\\n':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*b++ = *arg;\n\t\t\tbreak;\n\t\t}\n\t\targ++;\n\t}\n\t*b = 0;\n\treturn a;\n}", "target": 1}
{"code": "void mp_obj_int_to_bytes_impl(mp_obj_t self_in, bool big_endian, size_t len, byte *buf) {\n    assert(mp_obj_is_exact_type(self_in, &mp_type_int));\n    mp_obj_int_t *self = MP_OBJ_TO_PTR(self_in);\n    mpz_as_bytes(&self->mpz, big_endian, len, buf);\n}", "target": 1}
{"code": "TEE_Result crypto_acipher_alloc_dsa_public_key(struct dsa_public_key *s,\n\t\t\t\t\t       size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->g))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->p))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->q))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->g);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "static bool fib6_rule_suppress(struct fib_rule *rule, struct fib_lookup_arg *arg)\n{\n\tstruct fib6_result *res = arg->result;\n\tstruct rt6_info *rt = res->rt6;\n\tstruct net_device *dev = NULL;\n\tif (!rt)\n\t\treturn false;\n\tif (rt->rt6i_idev)\n\t\tdev = rt->rt6i_idev->dev;\n\tif (rt->rt6i_dst.plen <= rule->suppress_prefixlen)\n\t\tgoto suppress_route;\n\tif (rule->suppress_ifgroup != -1 && dev && dev->group == rule->suppress_ifgroup)\n\t\tgoto suppress_route;\n\treturn false;\nsuppress_route:\n\tip6_rt_put(rt);\n\treturn true;\n}", "target": 1}
{"code": "jiffies_to_timespec(const unsigned long jiffies, struct timespec *value)\n{\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &value->tv_nsec);\n}", "target": 1}
{"code": "QPDF::resolve(int objid, int generation)\n{\n    QPDFObjGen og(objid, generation);\n    if (this->resolving.count(og))\n    {\n\tQTC::TC(\"qpdf\", \"QPDF recursion loop in resolve\");\n\twarn(QPDFExc(qpdf_e_damaged_pdf, this->file->getName(),\n\t\t     \"\", this->file->getLastOffset(),\n\t\t     \"loop detected resolving object \" +\n\t\t     QUtil::int_to_string(objid) + \" \" +\n\t\t     QUtil::int_to_string(generation)));\n        return new QPDF_Null;\n    }\n    ResolveRecorder rr(this, og);\n    if (! this->obj_cache.count(og))\n    {\n\tif (! this->xref_table.count(og))\n\t{\n\t    return new QPDF_Null;\n\t}\n\tQPDFXRefEntry const& entry = this->xref_table[og];\n\tswitch (entry.getType())\n\t{\n\t  case 1:\n\t    {\n\t\tqpdf_offset_t offset = entry.getOffset();\n\t\tint aobjid;\n\t\tint ageneration;\n\t\tQPDFObjectHandle oh =\n\t\t    readObjectAtOffset(true, offset, \"\", objid, generation,\n\t\t\t\t       aobjid, ageneration);\n\t    }\n\t    break;\n\t  case 2:\n\t    resolveObjectsInStream(entry.getObjStreamNumber());\n\t    break;\n\t  default:\n\t    throw QPDFExc(qpdf_e_damaged_pdf, this->file->getName(), \"\", 0,\n\t\t\t  \"object \" +\n\t\t\t  QUtil::int_to_string(objid) + \"/\" +\n\t\t\t  QUtil::int_to_string(generation) +\n\t\t\t  \" has unexpected xref entry type\");\n\t}\n    }\n    return this->obj_cache[og].object;\n}", "target": 0}
{"code": "ServerApp::openClientListener(const NetworkAddress& address)\n{\n    auto security_level = ConnectionSecurityLevel::PLAINTEXT;\n    if (args().m_enableCrypto) {\n        security_level = ConnectionSecurityLevel::ENCRYPTED;\n        if (args().check_client_certificates) {\n            security_level = ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED;\n        }\n    }\n    ClientListener* listen = new ClientListener(\n        address,\n        new TCPSocketFactory(m_events, getSocketMultiplexer()),\n        m_events, security_level);\n    m_events->adoptHandler(\n        m_events->forClientListener().connected(), listen,\n        new TMethodEventJob<ServerApp>(\n            this, &ServerApp::handleClientConnected, listen));\n    return listen;\n}", "target": 0}
{"code": "auth_password(Authctxt *authctxt, const char *password)\n{\n\tstruct passwd * pw = authctxt->pw;\n\tint result, ok = authctxt->valid;\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tstatic int expire_checked = 0;\n#endif\n\tif (strlen(password) > MAX_PASSWORD_LEN)\n\t\treturn 0;\n#ifndef HAVE_CYGWIN\n\tif (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)\n\t\tok = 0;\n#endif\n\tif (*password == '\\0' && options.permit_empty_passwd == 0)\n\t\treturn 0;\n#ifdef KRB5\n\tif (options.kerberos_authentication == 1) {\n\t\tint ret = auth_krb5_password(authctxt, password);\n\t\tif (ret == 1 || ret == 0)\n\t\t\treturn ret && ok;\n\t}\n#endif\n#ifdef HAVE_CYGWIN\n\t{\n\t\tHANDLE hToken = cygwin_logon_user(pw, password);\n\t\tif (hToken == INVALID_HANDLE_VALUE)\n\t\t\treturn 0;\n\t\tcygwin_set_impersonation_token(hToken);\n\t\treturn ok;\n\t}\n#endif\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\treturn (sshpam_auth_passwd(authctxt, password) && ok);\n#endif\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tif (!expire_checked) {\n\t\texpire_checked = 1;\n\t\tif (auth_shadow_pwexpired(authctxt))\n\t\t\tauthctxt->force_pwchange = 1;\n\t}\n#endif\n\tresult = sys_auth_passwd(authctxt, password);\n\tif (authctxt->force_pwchange)\n\t\tdisable_forwarding();\n\treturn (result && ok);\n}", "target": 0}
{"code": "test_compressed_stream_overflow (xd3_stream *stream, int ignore)\n{\n  int ret;\n  int i;\n  uint8_t *buf;\n  if ((buf = (uint8_t*) malloc (TWO_MEGS_AND_DELTA)) == NULL) { return ENOMEM; }\n  memset (buf, 0, TWO_MEGS_AND_DELTA);\n  for (i = 0; i < (2 << 20); i += 256) \n    {\n      int j;\n      int off = mt_random(& static_mtrand) % 10;\n      for (j = 0; j < 256; j++) \n\t{\n\t  buf[i + j] = j + off;\n\t}\n    }\n  if (SIZEOF_XOFF_T == 4)\n    {\n      ret = test_streaming (stream, buf, buf + (1 << 20), buf + (2 << 20), (1 << 12) + 1);\n      if (ret == XD3_INVALID_INPUT && MSG_IS (\"decoder file offset overflow\"))\n\t{\n\t  ret = 0;\n\t}\n      else\n\t{\n          XPR(NT XD3_LIB_ERRMSG (stream, ret));\n\t  stream->msg = \"expected overflow condition\";\n\t  ret = XD3_INTERNAL;\n\t  goto fail;\n\t}\n    }\n  if ((ret = test_streaming (stream, \n\t\t\t     buf, \n\t\t\t     buf + (1 << 20), \n\t\t\t     buf + (2 << 20), \n\t\t\t     1 << 12))) \n    {\n      goto fail;\n    }\n fail:\n  free (buf);\n  return ret;\n}", "target": 1}
{"code": "void\nyyerror(YYLTYPE *yylloc, void *scanner, struct yang_parameter *param, ...)\n{\n  free(*param->value);\n  *param->value = NULL;\n  if (yylloc->first_line != -1) {\n    if (*param->data_node && (*param->data_node) == (*param->actual_node)) {\n      LOGVAL(param->module->ctx, LYE_INSTMT, LY_VLOG_LYS, *param->data_node, yyget_text(scanner));\n    } else {\n      LOGVAL(param->module->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, yyget_text(scanner));\n    }\n  }", "target": 0}
{"code": "void dvb_usbv2_disconnect(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\tconst char *name = d->name;\n\tstruct device dev = d->udev->dev;\n\tdev_dbg(&d->udev->dev, \"%s: bInterfaceNumber=%d\\n\", __func__,\n\t\t\tintf->cur_altsetting->desc.bInterfaceNumber);\n\tif (d->props->exit)\n\t\td->props->exit(d);\n\tdvb_usbv2_exit(d);\n\tdev_info(&dev, \"%s: '%s' successfully deinitialized and disconnected\\n\",\n\t\t\tKBUILD_MODNAME, name);\n}", "target": 1}
{"code": "static int l2cap_sock_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\tBT_DBG(\"sk %p backlog %d\", sk, backlog);\n\tlock_sock(sk);\n\tif (sk->sk_state != BT_BOUND || sock->type != SOCK_SEQPACKET) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\tswitch (l2cap_pi(sk)->mode) {\n\tcase L2CAP_MODE_BASIC:\n\t\tbreak;\n\tcase L2CAP_MODE_ERTM:\n\tcase L2CAP_MODE_STREAMING:\n\t\tif (enable_ertm)\n\t\t\tbreak;\n\tdefault:\n\t\terr = -ENOTSUPP;\n\t\tgoto done;\n\t}\n\tif (!l2cap_pi(sk)->psm) {\n\t\tbdaddr_t *src = &bt_sk(sk)->src;\n\t\tu16 psm;\n\t\terr = -EINVAL;\n\t\twrite_lock_bh(&l2cap_sk_list.lock);\n\t\tfor (psm = 0x1001; psm < 0x1100; psm += 2)\n\t\t\tif (!__l2cap_get_sock_by_addr(cpu_to_le16(psm), src)) {\n\t\t\t\tl2cap_pi(sk)->psm   = cpu_to_le16(psm);\n\t\t\t\tl2cap_pi(sk)->sport = cpu_to_le16(psm);\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\twrite_unlock_bh(&l2cap_sk_list.lock);\n\t\tif (err < 0)\n\t\t\tgoto done;\n\t}\n\tsk->sk_max_ack_backlog = backlog;\n\tsk->sk_ack_backlog = 0;\n\tsk->sk_state = BT_LISTEN;\ndone:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "yy_symbol_print (FILE *yyo,\n                 yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp, void *parm)\n{\n  YYFPRINTF (yyo, \"%s %s (\",\n             yykind < YYNTOKENS ? \"token\" : \"nterm\", yysymbol_name (yykind));\n  YY_LOCATION_PRINT (yyo, *yylocationp);\n  YYFPRINTF (yyo, \": \");\n  yy_symbol_value_print (yyo, yykind, yyvaluep, yylocationp, parm);\n  YYFPRINTF (yyo, \")\");\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    ReshapeOp::Compute(ctx);\n    const float input_min_float = ctx->input(2).flat<float>()(0);\n    const float input_max_float = ctx->input(3).flat<float>()(0);\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(1, TensorShape({}), &output_min));\n    output_min->flat<float>()(0) = input_min_float;\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(2, TensorShape({}), &output_max));\n    output_max->flat<float>()(0) = input_max_float;\n  }", "target": 1}
{"code": "static long snd_seq_ioctl(struct file *file, unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tstruct snd_seq_client *client = file->private_data;\n\tunion {\n\t\tint pversion;\n\t\tint client_id;\n\t\tstruct snd_seq_system_info\tsystem_info;\n\t\tstruct snd_seq_running_info\trunning_info;\n\t\tstruct snd_seq_client_info\tclient_info;\n\t\tstruct snd_seq_port_info\tport_info;\n\t\tstruct snd_seq_port_subscribe\tport_subscribe;\n\t\tstruct snd_seq_queue_info\tqueue_info;\n\t\tstruct snd_seq_queue_status\tqueue_status;\n\t\tstruct snd_seq_queue_tempo\ttempo;\n\t\tstruct snd_seq_queue_timer\tqueue_timer;\n\t\tstruct snd_seq_queue_client\tqueue_client;\n\t\tstruct snd_seq_client_pool\tclient_pool;\n\t\tstruct snd_seq_remove_events\tremove_events;\n\t\tstruct snd_seq_query_subs\tquery_subs;\n\t} buf;\n\tconst struct ioctl_handler *handler;\n\tunsigned long size;\n\tint err;\n\tif (snd_BUG_ON(!client))\n\t\treturn -ENXIO;\n\tfor (handler = ioctl_handlers; handler->cmd > 0; ++handler) {\n\t\tif (handler->cmd == cmd)\n\t\t\tbreak;\n\t}\n\tif (handler->cmd == 0)\n\t\treturn -ENOTTY;\n\tmemset(&buf, 0, sizeof(buf));\n\tsize = _IOC_SIZE(handler->cmd);\n\tif (handler->cmd & IOC_IN) {\n\t\tif (copy_from_user(&buf, (const void __user *)arg, size))\n\t\t\treturn -EFAULT;\n\t}\n\tmutex_lock(&client->ioctl_mutex);\n\terr = handler->func(client, &buf);\n\tmutex_unlock(&client->ioctl_mutex);\n\tif (err >= 0) {\n\t\tif (handler->cmd == SNDRV_SEQ_IOCTL_SET_QUEUE_CLIENT ||\n\t\t    handler->cmd == SNDRV_SEQ_IOCTL_SET_CLIENT_POOL ||\n\t\t    (handler->cmd & IOC_OUT))\n\t\t\tif (copy_to_user((void __user *)arg, &buf, size))\n\t\t\t\treturn -EFAULT;\n\t}\n\treturn err;\n}", "target": 0}
{"code": "static void fio_cluster_signal_children(void) {\n  if (fio_parent_pid() != getpid()) {\n    fio_stop();\n    return;\n  }\n  fio_cluster_server_sender(fio_msg_internal_create(0, FIO_CLUSTER_MSG_SHUTDOWN,\n                                                    (fio_str_info_s){.len = 0},\n                                                    (fio_str_info_s){.len = 0},\n                                                    0, 1),\n                            -1);\n}", "target": 1}
{"code": "void jiffies_to_timeval(const unsigned long jiffies, struct timeval *value)\n{\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tlong tv_usec;\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &tv_usec);\n\ttv_usec /= NSEC_PER_USEC;\n\tvalue->tv_usec = tv_usec;\n}", "target": 1}
{"code": "ZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)\n{\n\tGC_REFCOUNT(ht) = 1;\n\tGC_TYPE_INFO(ht) = IS_ARRAY;\n\tht->u.flags = (persistent ? HASH_FLAG_PERSISTENT : 0) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;\n\tht->nTableSize = zend_hash_check_size(nSize);\n\tht->nTableMask = HT_MIN_MASK;\n\tHT_SET_DATA_ADDR(ht, &uninitialized_bucket);\n\tht->nNumUsed = 0;\n\tht->nNumOfElements = 0;\n\tht->nInternalPointer = HT_INVALID_IDX;\n\tht->nNextFreeElement = 0;\n\tht->pDestructor = pDestructor;\n}", "target": 1}
{"code": "static inline void openOptimized(sqlite3*& db) {\n  sqlite3_open(\":memory:\", &db);\n  std::string settings;\n  for (const auto& setting : kMemoryDBSettings) {\n    settings += \"PRAGMA \" + setting.first + \"=\" + setting.second + \"; \";\n  }\n  sqlite3_exec(db, settings.c_str(), nullptr, nullptr, nullptr);\n  registerMathExtensions(db);\n#if !defined(FREEBSD)\n  registerStringExtensions(db);\n#endif\n#if !defined(SKIP_CARVER)\n  registerOperationExtensions(db);\n#endif\n  registerFilesystemExtensions(db);\n  registerHashingExtensions(db);\n  registerEncodingExtensions(db);\n  auto rc = sqlite3_set_authorizer(db, &sqliteAuthorizer, nullptr);\n  if (rc != SQLITE_OK) {\n    LOG(ERROR) << \"Failed to set sqlite authorizer: \" << sqlite3_errmsg(db);\n    requestShutdown(rc);\n  }\n}", "target": 0}
{"code": "static void my_free(void *ptr)\n{\n    free_called += 1;\n    free(ptr);\n}", "target": 1}
{"code": "TEST_F(QuantizeDownAndShrinkRangeTest, HandCrafted) {\n  TF_ASSERT_OK(NodeDefBuilder(\"quantize_down_and_shrink_range_op\",\n                              \"QuantizeDownAndShrinkRange\")\n                   .Input(FakeInput(DT_QINT32))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Attr(\"Tinput\", DataTypeToEnum<qint32>::v())\n                   .Attr(\"out_type\", DataTypeToEnum<quint8>::v())\n                   .Finalize(node_def()));\n  TF_ASSERT_OK(InitOp());\n  const int value_count = 3;\n  AddInputFromArray<qint32>(TensorShape({value_count}),\n                            {-(1 << 23), 0, (1 << 23)});\n  AddInputFromArray<float>(TensorShape({1}), {-256.0f});\n  AddInputFromArray<float>(TensorShape({1}), {256.0f});\n  TF_ASSERT_OK(RunOpKernel());\n  Tensor expected(allocator(), DT_QUINT8, TensorShape({value_count}));\n  test::FillValues<quint8>(&expected, {0, 128, 255});\n  test::ExpectTensorEqual<quint8>(expected, *GetOutput(0));\n  Tensor expected_min(allocator(), DT_FLOAT, TensorShape({}));\n  test::FillValues<float>(&expected_min, {-1.0f});\n  test::ExpectTensorEqual<float>(expected_min, *GetOutput(1));\n  Tensor expected_max(allocator(), DT_FLOAT, TensorShape({}));\n  test::FillValues<float>(&expected_max, {1.0f});\n  test::ExpectTensorEqual<float>(expected_max, *GetOutput(2));\n}", "target": 1}
{"code": "void options_free() {\n    parse_global_option(CMD_FREE, NULL, NULL);\n}", "target": 1}
{"code": "\tSpawnPreparationInfo prepareSpawn(const Options &options) {\n\t\tTRACE_POINT();\n\t\tSpawnPreparationInfo info;\n\t\tprepareChroot(info, options);\n\t\tinfo.userSwitching = prepareUserSwitching(options);\n\t\tprepareSwitchingWorkingDirectory(info, options);\n\t\tinferApplicationInfo(info);\n\t\treturn info;\n\t}", "target": 1}
{"code": "struct cifs_ntsd *get_cifs_acl(struct cifs_sb_info *cifs_sb,\n\t\t\t\t      struct inode *inode, const char *path,\n\t\t\t\t      u32 *pacllen)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tstruct cifsFileInfo *open_file = NULL;\n\tif (inode)\n\t\topen_file = find_readable_file(CIFS_I(inode), true);\n\tif (!open_file)\n\t\treturn get_cifs_acl_by_path(cifs_sb, path, pacllen);\n\tpntsd = get_cifs_acl_by_fid(cifs_sb, &open_file->fid, pacllen);\n\tcifsFileInfo_put(open_file);\n\treturn pntsd;\n}", "target": 0}
{"code": "GC_INNER void * GC_generic_malloc_ignore_off_page(size_t lb, int k)\n{\n    void *result;\n    size_t lg;\n    size_t lb_rounded;\n    word n_blocks;\n    GC_bool init;\n    DCL_LOCK_STATE;\n    if (SMALL_OBJ(lb))\n        return(GC_generic_malloc((word)lb, k));\n    lg = ROUNDED_UP_GRANULES(lb);\n    lb_rounded = GRANULES_TO_BYTES(lg);\n    if (lb_rounded < lb)\n        return((*GC_get_oom_fn())(lb));\n    n_blocks = OBJ_SZ_TO_BLOCKS(lb_rounded);\n    init = GC_obj_kinds[k].ok_init;\n    if (EXPECT(GC_have_errors, FALSE))\n      GC_print_all_errors();\n    GC_INVOKE_FINALIZERS();\n    LOCK();\n    result = (ptr_t)GC_alloc_large(ADD_SLOP(lb), k, IGNORE_OFF_PAGE);\n    if (0 != result) {\n        if (GC_debugging_started) {\n            BZERO(result, n_blocks * HBLKSIZE);\n        } else {\n#           ifdef THREADS\n                ((word *)result)[0] = 0;\n                ((word *)result)[1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-2] = 0;\n#           endif\n        }\n    }\n    GC_bytes_allocd += lb_rounded;\n    if (0 == result) {\n        GC_oom_func oom_fn = GC_oom_fn;\n        UNLOCK();\n        return((*oom_fn)(lb));\n    } else {\n        UNLOCK();\n        if (init && !GC_debugging_started) {\n            BZERO(result, n_blocks * HBLKSIZE);\n        }\n        return(result);\n    }\n}", "target": 0}
{"code": "static StkId rethook (lua_State *L, CallInfo *ci, StkId firstres, int nres) {\n  ptrdiff_t oldtop = savestack(L, L->top);  \n  int delta = 0;\n  if (isLuacode(ci)) {\n    Proto *p = clLvalue(s2v(ci->func))->p;\n    if (p->is_vararg)\n      delta = ci->u.l.nextraargs + p->numparams + 1;\n    if (L->top < ci->top)\n      L->top = ci->top;  \n  }\n  if (L->hookmask & LUA_MASKRET) {  \n    int ftransfer;\n    ci->func += delta;  \n    ftransfer = cast(unsigned short, firstres - ci->func);\n    luaD_hook(L, LUA_HOOKRET, -1, ftransfer, nres);  \n    ci->func -= delta;\n  }\n  if (isLua(ci->previous))\n    L->oldpc = ci->previous->u.l.savedpc;  \n  return restorestack(L, oldtop);\n}", "target": 1}
{"code": "static void dtls1_clear_queues(SSL *s)\n\t{\n    pitem *item = NULL;\n    hm_fragment *frag = NULL;\n\tDTLS1_RECORD_DATA *rdata;\n    while( (item = pqueue_pop(s->d1->unprocessed_rcds.q)) != NULL)\n        {\n\t\trdata = (DTLS1_RECORD_DATA *) item->data;\n\t\tif (rdata->rbuf.buf)\n\t\t\t{\n\t\t\tOPENSSL_free(rdata->rbuf.buf);\n\t\t\t}\n        OPENSSL_free(item->data);\n        pitem_free(item);\n        }\n    while( (item = pqueue_pop(s->d1->processed_rcds.q)) != NULL)\n        {\n\t\trdata = (DTLS1_RECORD_DATA *) item->data;\n\t\tif (rdata->rbuf.buf)\n\t\t\t{\n\t\t\tOPENSSL_free(rdata->rbuf.buf);\n\t\t\t}\n        OPENSSL_free(item->data);\n        pitem_free(item);\n        }\n    while( (item = pqueue_pop(s->d1->buffered_messages)) != NULL)\n        {\n        frag = (hm_fragment *)item->data;\n        OPENSSL_free(frag->fragment);\n        OPENSSL_free(frag);\n        pitem_free(item);\n        }\n    while ( (item = pqueue_pop(s->d1->sent_messages)) != NULL)\n        {\n        frag = (hm_fragment *)item->data;\n        OPENSSL_free(frag->fragment);\n        OPENSSL_free(frag);\n        pitem_free(item);\n        }\n\twhile ( (item = pqueue_pop(s->d1->buffered_app_data.q)) != NULL)\n\t\t{\n\t\tfrag = (hm_fragment *)item->data;\n\t\tOPENSSL_free(frag->fragment);\n\t\tOPENSSL_free(frag);\n\t\tpitem_free(item);\n\t\t}\n\t}", "target": 1}
{"code": "comics_document_thumbnails_get_thumbnail (EvDocumentThumbnails *document,\n\t\t\t\t\t  EvRenderContext      *rc,\n\t\t\t\t\t  gboolean              border)\n{\n\tGdkPixbuf *thumbnail;\n\tthumbnail = comics_document_render_pixbuf (EV_DOCUMENT (document), rc);\n\tif (border) {\n\t      GdkPixbuf *tmp_pixbuf = thumbnail;\n\t      thumbnail = ev_document_misc_get_thumbnail_frame (-1, -1, tmp_pixbuf);\n\t      g_object_unref (tmp_pixbuf);\n\t}\n\treturn thumbnail;\n}", "target": 1}
{"code": "void ogs_pfcp_context_init(void)\n{\n    int i;\n    ogs_assert(context_initialized == 0);\n    memset(&self, 0, sizeof(ogs_pfcp_context_t));\n    self.local_recovery = ogs_time_ntp32_now();\n    ogs_log_install_domain(&__ogs_pfcp_domain, \"pfcp\", ogs_core()->log.level);\n    ogs_pool_init(&ogs_pfcp_node_pool, ogs_app()->pool.nf);\n    ogs_pool_init(&ogs_pfcp_sess_pool, ogs_app()->pool.sess);\n    ogs_pool_init(&ogs_pfcp_far_pool,\n            ogs_app()->pool.sess * OGS_MAX_NUM_OF_FAR);\n    ogs_pool_init(&ogs_pfcp_urr_pool,\n            ogs_app()->pool.sess * OGS_MAX_NUM_OF_URR);\n    ogs_pool_init(&ogs_pfcp_qer_pool,\n            ogs_app()->pool.sess * OGS_MAX_NUM_OF_QER);\n    ogs_pool_init(&ogs_pfcp_bar_pool,\n            ogs_app()->pool.sess * OGS_MAX_NUM_OF_BAR);\n    ogs_pool_init(&ogs_pfcp_pdr_pool,\n            ogs_app()->pool.sess * OGS_MAX_NUM_OF_PDR);\n    ogs_pool_init(&ogs_pfcp_pdr_teid_pool, ogs_pfcp_pdr_pool.size);\n    ogs_pool_random_id_generate(&ogs_pfcp_pdr_teid_pool);\n    pdr_random_to_index = ogs_calloc(\n            sizeof(ogs_pool_id_t), ogs_pfcp_pdr_pool.size);\n    ogs_assert(pdr_random_to_index);\n    for (i = 0; i < ogs_pfcp_pdr_pool.size; i++)\n        pdr_random_to_index[ogs_pfcp_pdr_teid_pool.array[i]] = i;\n    ogs_pool_init(&ogs_pfcp_rule_pool,\n            ogs_app()->pool.sess *\n            OGS_MAX_NUM_OF_PDR * OGS_MAX_NUM_OF_FLOW_IN_PDR);\n    ogs_pool_init(&ogs_pfcp_dev_pool, OGS_MAX_NUM_OF_DEV);\n    ogs_pool_init(&ogs_pfcp_subnet_pool, OGS_MAX_NUM_OF_SUBNET);\n    self.object_teid_hash = ogs_hash_make();\n    ogs_assert(self.object_teid_hash);\n    self.far_f_teid_hash = ogs_hash_make();\n    ogs_assert(self.far_f_teid_hash);\n    self.far_teid_hash = ogs_hash_make();\n    ogs_assert(self.far_teid_hash);\n    context_initialized = 1;\n}", "target": 1}
{"code": "static inline void tlb_end_vma(struct mmu_gather *tlb, struct vm_area_struct *vma)\n{\n\tif (tlb->fullmm || IS_ENABLED(CONFIG_MMU_GATHER_MERGE_VMAS))\n\t\treturn;\n\ttlb_flush_mmu_tlbonly(tlb);\n}", "target": 1}
{"code": "Status TransposeShapeFn(InferenceContext* c) {\n  ShapeHandle input = c->input(0);\n  ShapeHandle perm_shape = c->input(1);\n  const Tensor* perm = c->input_tensor(1);\n  DimensionHandle perm_elems = c->NumElements(perm_shape);\n  if (!c->RankKnown(input) && !c->ValueKnown(perm_elems) && perm == nullptr) {\n    c->set_output(0, c->UnknownShape());\n    return Status::OK();\n  }\n  int64_t rank;\n  if (c->RankKnown(input)) {\n    rank = c->Rank(input);\n  } else if (c->ValueKnown(perm_elems)) {\n    rank = c->Value(perm_elems);\n  } else {\n    rank = perm->NumElements();\n  }\n  if (!c->RankKnown(input) && rank < 2) {\n    c->set_output(0, input);\n    return Status::OK();\n  }\n  std::vector<DimensionHandle> dims;\n  dims.resize(rank);\n  TF_RETURN_IF_ERROR(c->WithRank(input, rank, &input));\n  TF_RETURN_IF_ERROR(c->WithRank(perm_shape, 1, &perm_shape));\n  TF_RETURN_IF_ERROR(c->WithValue(perm_elems, rank, &perm_elems));\n  if (perm != nullptr) {\n    std::vector<int64_t> data;\n    if (perm->dtype() == DT_INT32) {\n      data = AsInt64<int32>(perm, rank);\n    } else {\n      data = AsInt64<int64_t>(perm, rank);\n    }\n    for (int32_t i = 0; i < rank; ++i) {\n      int64_t in_idx = data[i];\n      if (in_idx >= rank) {\n        return errors::InvalidArgument(\"perm dim \", in_idx,\n                                       \" is out of range of input rank \", rank);\n      }\n      dims[i] = c->Dim(input, in_idx);\n    }\n  } else {\n    for (int i = 0; i < rank; ++i) {\n      dims[i] = c->UnknownDim();\n    }\n  }\n  c->set_output(0, c->MakeShape(dims));\n  return Status::OK();\n}", "target": 1}
{"code": "static inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)\n{\n\tpmd_t pmdval = *pmd;\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tbarrier();\n#endif\n\tif (pmd_none(pmdval))\n\t\treturn 1;\n\tif (unlikely(pmd_bad(pmdval))) {\n\t\tif (!pmd_trans_huge(pmdval))\n\t\t\tpmd_clear_bad(pmd);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "bool ConstantFolding::SimplifyReshape(const GraphProperties& properties,\n                                      bool use_shape_info, NodeDef* node) {\n  if (!use_shape_info || node->attr().count(\"T\") == 0 ||\n      !IsSimplifiableReshape(*node, properties)) {\n    return false;\n  }\n  DataType output_type = node->attr().at(\"T\").type();\n  node->set_op(\"Identity\");\n  EraseRegularNodeAttributes(node);\n  (*node->mutable_attr())[\"T\"].set_type(output_type);\n  *node->mutable_input(1) = AsControlDependency(node->input(1));\n  return true;\n}", "target": 1}
{"code": "static int perf_swevent_add(struct perf_event *event, int flags)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tstruct hlist_head *head;\n\tif (is_sampling_event(event)) {\n\t\thwc->last_period = hwc->sample_period;\n\t\tperf_swevent_set_period(event);\n\t}\n\thwc->state = !(flags & PERF_EF_START);\n\thead = find_swevent_head(swhash, event);\n\tif (!head) {\n\t\tWARN_ON_ONCE(swhash->online);\n\t\treturn -EINVAL;\n\t}\n\thlist_add_head_rcu(&event->hlist_entry, head);\n\tperf_event_update_userpage(event);\n\treturn 0;\n}", "target": 1}
{"code": "static void iwjpeg_scan_exif_ifd(struct iwjpegrcontext *rctx,\n\tstruct iw_exif_state *e, iw_uint32 ifd)\n{\n\tunsigned int tag_count;\n\tunsigned int i;\n\tunsigned int tag_pos;\n\tunsigned int tag_id;\n\tunsigned int v;\n\tdouble v_dbl;\n\tif(ifd<8 || ifd>e->d_len-18) return;\n\ttag_count = iw_get_ui16_e(&e->d[ifd],e->endian);\n\tif(tag_count>1000) return; \n\tfor(i=0;i<tag_count;i++) {\n\t\ttag_pos = ifd+2+i*12;\n\t\tif(tag_pos+12 > e->d_len) return; \n\t\ttag_id = iw_get_ui16_e(&e->d[tag_pos],e->endian);\n\t\tswitch(tag_id) {\n\t\tcase 274: \n\t\t\tif(get_exif_tag_int_value(e,tag_pos,&v)) {\n\t\t\t\trctx->exif_orientation = v;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 296: \n\t\t\tif(get_exif_tag_int_value(e,tag_pos,&v)) {\n\t\t\t\trctx->exif_density_unit = v;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 282: \n\t\t\tif(get_exif_tag_dbl_value(e,tag_pos,&v_dbl)) {\n\t\t\t\trctx->exif_density_x = v_dbl;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 283: \n\t\t\tif(get_exif_tag_dbl_value(e,tag_pos,&v_dbl)) {\n\t\t\t\trctx->exif_density_y = v_dbl;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}", "target": 1}
{"code": "sudo_auth_begin_session(const struct sudoers_context *ctx, struct passwd *pw,\n    char **user_env[])\n{\n    sudo_auth *auth;\n    debug_decl(sudo_auth_begin_session, SUDOERS_DEBUG_AUTH);\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (auth->begin_session && !IS_DISABLED(auth)) {\n\t    int status = (auth->begin_session)(ctx, pw, user_env, auth);\n\t    if (status != AUTH_SUCCESS) {\n\t\tdebug_return_int(-1);\n\t    }\n\t}\n    }\n    debug_return_int(1);\n}", "target": 1}
{"code": "static static void adpt_delay(int millisec)\n{\n\tint i;\n\tfor (i = 0; i < millisec; i++) {\n\t\tudelay(1000);\t\n\t}\n}", "target": 1}
{"code": "fbFetchPixel_g1 (const FbBits *bits, int offset, miIndexedPtr indexed)\n{\n    CARD32 pixel = ((CARD32 *)bits)[offset >> 5];\n    CARD32 a;\n#if BITMAP_BIT_ORDER == MSBFirst\n    a = pixel >> (0x1f - (offset & 0x1f));\n#else\n    a = pixel >> (offset & 0x1f);\n#endif\n    a = a & 1;\n    return indexed->rgba[a];\n}", "target": 0}
{"code": "static void __net_exit sctp_defaults_exit(struct net *net)\n{\n\tsctp_free_addr_wq(net);\n\tsctp_free_local_addr_list(net);\n\tsctp_dbg_objcnt_exit(net);\n\tsctp_proc_exit(net);\n\tcleanup_sctp_mibs(net);\n\tsctp_sysctl_net_unregister(net);\n}", "target": 0}
{"code": "void *enc_untrusted_realloc(void *ptr, size_t size) {\n  MessageWriter input;\n  input.Push(reinterpret_cast<uint64_t>(ptr));\n  input.Push(static_cast<uint64_t>(size));\n  MessageReader output;\n  asylo::primitives::PrimitiveStatus status =\n      asylo::host_call::NonSystemCallDispatcher(\n          asylo::host_call::kReallocHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_realloc\", 2);\n  void *result = output.next<void *>();\n  int klinux_errno = output.next<int>();\n  if (!result && size != 0) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n  }\n  if (!::asylo::primitives::TrustedPrimitives::IsOutsideEnclave(result, size)) {\n    ::asylo::primitives::TrustedPrimitives::BestEffortAbort(\n        \"enc_untrusted_realloc: realloc result should be in untrusted \"\n        \"memory\");\n  }\n  return result;\n}", "target": 0}
{"code": "request_env(agooReq req, VALUE self) {\n    if (Qnil == (VALUE)req->env) {\n\tvolatile VALUE\tenv = rb_hash_new();\n\trb_hash_aset(env, request_method_val, req_method(req));\n\trb_hash_aset(env, script_name_val, req_script_name(req));\n\trb_hash_aset(env, path_info_val, req_path_info(req));\n\trb_hash_aset(env, query_string_val, req_query_string(req));\n\trb_hash_aset(env, server_name_val, req_server_name(req));\n\trb_hash_aset(env, server_port_val, req_server_port(req));\n\tfill_headers(req, env);\n\trb_hash_aset(env, rack_version_val, rack_version_val_val);\n\trb_hash_aset(env, rack_url_scheme_val, req_rack_url_scheme(req));\n\trb_hash_aset(env, rack_input_val, req_rack_input(req));\n\trb_hash_aset(env, rack_errors_val, req_rack_errors(req));\n\trb_hash_aset(env, rack_multithread_val, req_rack_multithread(req));\n\trb_hash_aset(env, rack_multiprocess_val, Qfalse);\n\trb_hash_aset(env, rack_run_once_val, Qfalse);\n\trb_hash_aset(env, rack_logger_val, req_rack_logger(req));\n\trb_hash_aset(env, rack_upgrade_val, req_rack_upgrade(req));\n\trb_hash_aset(env, rack_hijackq_val, Qtrue);\n\trb_hash_aset(env, rack_hijack_val, self);\n\trb_hash_aset(env, rack_hijack_io_val, Qnil);\n\tif (agoo_server.rack_early_hints) {\n\t    volatile VALUE\teh = agoo_early_hints_new(req);\n\t    rb_hash_aset(env, early_hints_val, eh);\n\t}\n\treq->env = (void*)env;\n    }\n    return (VALUE)req->env;\n}", "target": 1}
{"code": "matching_line_len(char_u *lbuf)\n{\n    char_u\t*p = lbuf + 1;\n    p += STRLEN(p) + 1;\n#ifdef FEAT_EMACS_TAGS\n    p += STRLEN(p) + 1;\n#endif\n    return (p - lbuf) + STRLEN(p);\n}", "target": 0}
{"code": "cib_notify_client(gpointer key, gpointer value, gpointer user_data)\n{\n    const char *type = NULL;\n    gboolean do_send = FALSE;\n    cib_client_t *client = value;\n    xmlNode *update_msg = user_data;\n    CRM_CHECK(client != NULL, return TRUE);\n    CRM_CHECK(update_msg != NULL, return TRUE);\n    if (client->ipc == NULL) {\n        crm_warn(\"Skipping client with NULL channel\");\n        return FALSE;\n    }\n    type = crm_element_value(update_msg, F_SUBTYPE);\n    CRM_LOG_ASSERT(type != NULL);\n    if (client->diffs && safe_str_eq(type, T_CIB_DIFF_NOTIFY)) {\n        do_send = TRUE;\n    } else if (client->replace && safe_str_eq(type, T_CIB_REPLACE_NOTIFY)) {\n        do_send = TRUE;\n    } else if (client->confirmations && safe_str_eq(type, T_CIB_UPDATE_CONFIRM)) {\n        do_send = TRUE;\n    } else if (client->pre_notify && safe_str_eq(type, T_CIB_PRE_NOTIFY)) {\n        do_send = TRUE;\n    } else if (client->post_notify && safe_str_eq(type, T_CIB_POST_NOTIFY)) {\n        do_send = TRUE;\n    }\n    if (do_send) {\n        if (client->ipc) {\n            if(crm_ipcs_send(client->ipc, 0, update_msg, TRUE) == FALSE) {\n                crm_warn(\"Notification of client %s/%s failed\", client->name, client->id);\n            }\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        } else if (client->session) {\n            crm_debug(\"Sent %s notification to client %s/%s\", type, client->name, client->id);\n            crm_send_remote_msg(client->session, update_msg, client->encrypted);\n#endif\n        } else {\n            crm_err(\"Unknown transport for %s\", client->name);\n        }\n    }\n    return FALSE;\n}", "target": 1}
{"code": "static void perf_event_exit_cpu(int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\tperf_event_exit_cpu_context(cpu);\n\tmutex_lock(&swhash->hlist_mutex);\n\tswhash->online = false;\n\tswevent_hlist_release(swhash);\n\tmutex_unlock(&swhash->hlist_mutex);\n}", "target": 1}
{"code": "rfbClientIteratorNext(rfbClientIteratorPtr i)\n{\n  if (!i)\n    return NULL;\n  if(i->next == 0) {\n    LOCK(rfbClientListMutex);\n    i->next = i->screen->clientHead;\n    UNLOCK(rfbClientListMutex);\n  } else {\n    rfbClientPtr cl = i->next;\n    i->next = i->next->next;\n    rfbDecrClientRef(cl);\n  }\n#if defined(LIBVNCSERVER_HAVE_LIBPTHREAD) || defined(LIBVNCSERVER_HAVE_WIN32THREADS)\n    if(!i->closedToo)\n      while(i->next && i->next->sock<0)\n        i->next = i->next->next;\n    if(i->next)\n      rfbIncrClientRef(i->next);\n#endif\n    return i->next;\n}", "target": 0}
{"code": " static int asymmetric_key_match_preparse(struct key_match_data *match_data)\n {\n \tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n\tmatch_data->cmp = asymmetric_key_cmp;\n \treturn 0;\n }", "target": 0}
{"code": "static ut64 r_buf_read64le (RBuffer *buf, ut64 off) {\n\tut8 data[8] = {0};\n\tr_buf_read_at (buf, off, data, 8);\n\treturn r_read_le64 (data);\n}", "target": 0}
{"code": "static __u8 *pl_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 60 && rdesc[39] == 0x2a && rdesc[40] == 0xf5 &&\n\t\t\trdesc[41] == 0x00 && rdesc[59] == 0x26 &&\n\t\t\trdesc[60] == 0xf9 && rdesc[61] == 0x00) {\n\t\thid_info(hdev, \"fixing up Petalynx Maxter Remote report descriptor\\n\");\n\t\trdesc[60] = 0xfa;\n\t\trdesc[40] = 0xfa;\n\t}\n\treturn rdesc;\n}", "target": 1}
{"code": "    size_t FileIo::write(BasicIo& src)\n    {\n        assert(p_->fp_ != 0);\n        if (static_cast<BasicIo*>(this) == &src) return 0;\n        if (!src.isopen()) return 0;\n        if (p_->switchMode(Impl::opWrite) != 0) return 0;\n        byte buf[4096];\n        size_t readCount = 0;\n        size_t writeTotal = 0;\n        while ((readCount = src.read(buf, sizeof(buf)))) {\n            const size_t writeCount = static_cast<long>(std::fwrite(buf, 1, static_cast<size_t>(readCount), p_->fp_));\n            writeTotal += writeCount;\n            if (writeCount != readCount) {\n                src.seek(writeCount-readCount, BasicIo::cur);\n                break;\n            }\n        }\n        return writeTotal;\n    }", "target": 0}
{"code": "gss_wrap_aead (minor_status,\n               context_handle,\n               conf_req_flag,\n               qop_req,\n\t       input_assoc_buffer,\n\t       input_payload_buffer,\n               conf_state,\n               output_message_buffer)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nint\t\t\tconf_req_flag;\ngss_qop_t\t\tqop_req;\ngss_buffer_t\t\tinput_assoc_buffer;\ngss_buffer_t\t\tinput_payload_buffer;\nint *\t\t\tconf_state;\ngss_buffer_t\t\toutput_message_buffer;\n{\n    OM_uint32\t\tstatus;\n    gss_mechanism\tmech;\n    gss_union_ctx_id_t\tctx;\n    status = val_wrap_aead_args(minor_status, context_handle,\n\t\t\t\tconf_req_flag, qop_req,\n\t\t\t\tinput_assoc_buffer, input_payload_buffer,\n\t\t\t\tconf_state, output_message_buffer);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n    ctx = (gss_union_ctx_id_t)context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (!mech)\n\treturn (GSS_S_BAD_MECH);\n    return gssint_wrap_aead(mech, minor_status, ctx,\n\t\t\t    conf_req_flag, qop_req,\n\t\t\t    input_assoc_buffer, input_payload_buffer,\n\t\t\t    conf_state, output_message_buffer);\n}", "target": 0}
{"code": "psf_bump_header_allocation (SF_PRIVATE * psf, sf_count_t needed)\n{\n\tsf_count_t newlen, smallest = INITAL_HEADER_SIZE ;\n\tvoid * ptr ;\n\tnewlen = (needed > psf->header.len) ? 2 * SF_MAX (needed, smallest) : 2 * psf->header.len ;\n\tif (newlen > 100 * 1024)\n\t{\tpsf_log_printf (psf, \"Request for header allocation of %D denined.\\n\", newlen) ;\n\t\treturn 1 ;\n\t\t}\n\tif ((ptr = realloc (psf->header.ptr, newlen)) == NULL)\n\t{\tpsf_log_printf (psf, \"realloc (%p, %D) failed\\n\", psf->header.ptr, newlen) ;\n\t\tpsf->error = SFE_MALLOC_FAILED ;\n\t\treturn 1 ;\n\t\t} ;\n\tpsf->header.ptr = ptr ;\n\tpsf->header.len = newlen ;\n\treturn 0 ;\n} ", "target": 0}
{"code": "Pl_Count::write(unsigned char* buf, size_t len)\n{\n    if (len)\n    {\n\tthis->m->count += QIntC::to_offset(len);\n\tgetNext()->write(buf, len);\n\tthis->m->last_char = buf[len - 1];\n    }\n}", "target": 1}
{"code": "void EventPluginsManager::loadPlugin(const QString &pluginId)\n{\n    QPluginLoader loader(\"plasmacalendarplugins/\" + pluginId);\n    if (!loader.load()) {\n        qWarning() << \"Could not create Plasma Calendar Plugin: \" << pluginId;\n        qWarning() << loader.errorString();\n        return;\n    }\n    QObject *obj = loader.instance();\n    if (obj) {\n        CalendarEvents::CalendarEventsPlugin *eventsPlugin = qobject_cast<CalendarEvents::CalendarEventsPlugin *>(obj);\n        if (eventsPlugin) {\n            qDebug() << \"Loading Calendar plugin\" << eventsPlugin;\n            eventsPlugin->setProperty(\"pluginId\", pluginId);\n            d->plugins << eventsPlugin;\n            connect(eventsPlugin, &CalendarEvents::CalendarEventsPlugin::dataReady, this, &EventPluginsManager::dataReady);\n            connect(eventsPlugin, &CalendarEvents::CalendarEventsPlugin::eventModified, this, &EventPluginsManager::eventModified);\n            connect(eventsPlugin, &CalendarEvents::CalendarEventsPlugin::eventRemoved, this, &EventPluginsManager::eventRemoved);\n            connect(eventsPlugin, &CalendarEvents::CalendarEventsPlugin::alternateCalendarDateReady, this, &EventPluginsManager::alternateCalendarDateReady);\n            connect(eventsPlugin, &CalendarEvents::CalendarEventsPlugin::subLabelReady, this, &EventPluginsManager::subLabelReady);\n        } else {\n            loader.unload();\n        }\n    } else {\n        loader.unload();\n    }\n}", "target": 1}
{"code": "static bool add_free_nid(struct f2fs_sb_info *sbi, nid_t nid, bool build)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\tstruct nat_entry *ne;\n\tint err;\n\tif (unlikely(nid == 0))\n\t\treturn false;\n\tif (build) {\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (ne && (!get_nat_flag(ne, IS_CHECKPOINTED) ||\n\t\t\t\tnat_get_blkaddr(ne) != NULL_ADDR))\n\t\t\treturn false;\n\t}\n\ti = f2fs_kmem_cache_alloc(free_nid_slab, GFP_NOFS);\n\ti->nid = nid;\n\ti->state = NID_NEW;\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn true;\n\t}\n\tspin_lock(&nm_i->nid_list_lock);\n\terr = __insert_nid_to_list(sbi, i, FREE_NID_LIST, true);\n\tspin_unlock(&nm_i->nid_list_lock);\n\tradix_tree_preload_end();\n\tif (err) {\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn true;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "CallResult<PseudoHandle<>> GeneratorInnerFunction::callInnerFunction(\n    Handle<GeneratorInnerFunction> selfHandle,\n    Runtime &runtime,\n    Handle<> arg,\n    Action action) {\n  auto self = Handle<GeneratorInnerFunction>::vmcast(selfHandle);\n  SmallHermesValue shv =\n      SmallHermesValue::encodeHermesValue(arg.getHermesValue(), runtime);\n  self->result_.set(shv, runtime.getHeap());\n  self->action_ = action;\n  auto ctx = runtime.makeMutableHandle(selfHandle->savedContext_);\n  const uint32_t argCount = self->argCount_;\n  HermesValue newTarget = HermesValue::encodeUndefinedValue();\n  ScopedNativeCallFrame frame{\n      runtime,\n      argCount, \n      selfHandle.getHermesValue(),\n      newTarget,\n      ctx->at(0)};\n  if (LLVM_UNLIKELY(frame.overflowed()))\n    return runtime.raiseStackOverflow(Runtime::StackOverflowKind::NativeStack);\n  for (ArrayStorage::size_type i = 0, e = argCount; i < e; ++i) {\n    frame->getArgRef(i) = ctx->at(i + 1);\n  }\n  if (LLVM_UNLIKELY(selfHandle->getCodeBlock(runtime)->isLazy())) {\n    selfHandle->getCodeBlock(runtime)->lazyCompile(runtime);\n    if (LLVM_UNLIKELY(\n            ArrayStorage::resize(\n                ctx,\n                runtime,\n                getContextSize(\n                    selfHandle->getCodeBlock(runtime),\n                    selfHandle->argCount_)) == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    selfHandle->savedContext_.set(runtime, ctx.get(), runtime.getHeap());\n  }\n  return JSFunction::_callImpl(selfHandle, runtime);\n}", "target": 1}
{"code": "int av_hwframe_ctx_init(AVBufferRef *ref)\n{\n    AVHWFramesContext *ctx = (AVHWFramesContext*)ref->data;\n    const enum AVPixelFormat *pix_fmt;\n    int ret;\n    if (ctx->internal->source_frames) {\n        return 0;\n    }\n    for (pix_fmt = ctx->internal->hw_type->pix_fmts; *pix_fmt != AV_PIX_FMT_NONE; pix_fmt++) {\n        if (*pix_fmt == ctx->format)\n            break;\n    }\n    if (*pix_fmt == AV_PIX_FMT_NONE) {\n        av_log(ctx, AV_LOG_ERROR,\n               \"The hardware pixel format '%s' is not supported by the device type '%s'\\n\",\n               av_get_pix_fmt_name(ctx->format), ctx->internal->hw_type->name);\n        return AVERROR(ENOSYS);\n    }\n    ret = av_image_check_size(ctx->width, ctx->height, 0, ctx);\n    if (ret < 0)\n        return ret;\n    if (ctx->internal->hw_type->frames_init) {\n        ret = ctx->internal->hw_type->frames_init(ctx);\n        if (ret < 0)\n            goto fail;\n    }\n    if (ctx->internal->pool_internal && !ctx->pool)\n        ctx->pool = ctx->internal->pool_internal;\n    if (ctx->initial_pool_size > 0) {\n        ret = hwframe_pool_prealloc(ref);\n        if (ret < 0)\n            goto fail;\n    }\n    return 0;\nfail:\n    if (ctx->internal->hw_type->frames_uninit)\n        ctx->internal->hw_type->frames_uninit(ctx);\n    return ret;\n}", "target": 1}
{"code": "tpaddr_print_ip(netdissect_options *ndo,\n\t        const struct arp_pkthdr *ap, u_short pro)\n{\n\tif (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)\n\t\tND_PRINT((ndo, \"<wrong proto type>\"));\n\telse if (PROTO_LEN(ap) != 4)\n\t\tND_PRINT((ndo, \"<wrong len>\"));\n\telse\n\t\tND_PRINT((ndo, \"%s\", ipaddr_string(ndo, TPA(ap))));\n}", "target": 0}
{"code": "struct tcp_sock_t *tcp6_open(uint16_t port)\n{\n\tstruct tcp_sock_t *this = calloc(1, sizeof *this);\n\tif (this == NULL) {\n\t\tERR(\"IPv6: callocing this failed\");\n\t\tgoto error;\n\t}\n\tthis->sd = -1;\n\tthis->sd = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (this->sd < 0) {\n\t\tERR(\"Ipv6 socket open failed\");\n\t\tgoto error;\n\t}\n\tstruct sockaddr_in6 addr;\n\tmemset(&addr, 0, sizeof addr);\n\taddr.sin6_family = AF_INET6;\n\taddr.sin6_port = htons(port);\n\taddr.sin6_addr = in6addr_loopback;\n\tif (bind(this->sd,\n\t        (struct sockaddr *)&addr,\n\t        sizeof addr) < 0) {\n\t\tif (g_options.only_desired_port == 1)\n\t\t\tERR(\"IPv6 bind on port failed. \"\n\t\t\t    \"Requested port may be taken or require root permissions.\");\n\t\tgoto error;\n\t}\n\tif (listen(this->sd, HTTP_MAX_PENDING_CONNS) < 0) {\n\t\tERR(\"IPv6 listen failed on socket\");\n\t\tgoto error;\n\t}\n\treturn this;\nerror:\n\tif (this != NULL) {\n\t\tif (this->sd != -1) {\n\t\t\tclose(this->sd);\n\t\t}\n\t\tfree(this);\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "void MainWindow::on_actionUpgrade_triggered()\n{\n    if (Settings.askUpgradeAutmatic()) {\n        QMessageBox dialog(QMessageBox::Question,\n           qApp->applicationName(),\n           tr(\"Do you want to automatically check for updates in the future?\"),\n           QMessageBox::No |\n           QMessageBox::Yes,\n           this);\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        dialog.setDefaultButton(QMessageBox::Yes);\n        dialog.setEscapeButton(QMessageBox::No);\n        dialog.setCheckBox(new QCheckBox(tr(\"Do not show this anymore.\", \"Automatic upgrade check dialog\")));\n        Settings.setCheckUpgradeAutomatic(dialog.exec() == QMessageBox::Yes);\n        if (dialog.checkBox()->isChecked())\n            Settings.setAskUpgradeAutomatic(false);\n    }\n    showStatusMessage(\"Checking for upgrade...\");\n    m_network.get(QNetworkRequest(QUrl(\"http:\n}", "target": 1}
{"code": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1}
{"code": "file_pipe2file(struct magic_set *ms, int fd, const void *startbuf,\n    size_t nbytes)\n{\n\tchar buf[4096];\n\tssize_t r;\n\tint tfd;\n\t(void)strlcpy(buf, \"/tmp/file.XXXXXX\", sizeof buf);\n#ifndef HAVE_MKSTEMP\n\t{\n\t\tchar *ptr = mktemp(buf);\n\t\ttfd = open(ptr, O_RDWR|O_TRUNC|O_EXCL|O_CREAT, 0600);\n\t\tr = errno;\n\t\t(void)unlink(ptr);\n\t\terrno = r;\n\t}\n#else\n\t{\n\t\tint te;\n\t\ttfd = mkstemp(buf);\n\t\tte = errno;\n\t\t(void)unlink(buf);\n\t\terrno = te;\n\t}\n#endif\n\tif (tfd == -1) {\n\t\tfile_error(ms, errno,\n\t\t    \"cannot create temporary file for pipe copy\");\n\t\treturn -1;\n\t}\n\tif (swrite(tfd, startbuf, nbytes) != (ssize_t)nbytes)\n\t\tr = 1;\n\telse {\n\t\twhile ((r = sread(fd, buf, sizeof(buf), 1)) > 0)\n\t\t\tif (swrite(tfd, buf, (size_t)r) != r)\n\t\t\t\tbreak;\n\t}\n\tswitch (r) {\n\tcase -1:\n\t\tfile_error(ms, errno, \"error copying from pipe to temp file\");\n\t\treturn -1;\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\tfile_error(ms, errno, \"error while writing to temp file\");\n\t\treturn -1;\n\t}\n\tif ((fd = dup2(tfd, fd)) == -1) {\n\t\tfile_error(ms, errno, \"could not dup descriptor for temp file\");\n\t\treturn -1;\n\t}\n\t(void)close(tfd);\n\tif (FINFO_LSEEK_FUNC(fd, (off_t)0, SEEK_SET) == (off_t)-1) {\n\t\tfile_badseek(ms);\n\t\treturn -1;\n\t}\n\treturn fd;\n}", "target": 0}
{"code": "rpl_dao_print(netdissect_options *ndo,\n              const u_char *bp, u_int length)\n{\n        const struct nd_rpl_dao *dao = (const struct nd_rpl_dao *)bp;\n        const char *dagid_str = \"<elided>\";\n        ND_TCHECK(*dao);\n        if (length < ND_RPL_DAO_MIN_LEN)\n        \tgoto tooshort;\n        bp += ND_RPL_DAO_MIN_LEN;\n        length -= ND_RPL_DAO_MIN_LEN;\n        if(RPL_DAO_D(dao->rpl_flags)) {\n                ND_TCHECK2(dao->rpl_dagid, DAGID_LEN);\n                if (length < DAGID_LEN)\n                \tgoto tooshort;\n                dagid_str = ip6addr_string (ndo, dao->rpl_dagid);\n                bp += DAGID_LEN;\n                length -= DAGID_LEN;\n        }\n        ND_PRINT((ndo, \" [dagid:%s,seq:%u,instance:%u%s%s,%02x]\",\n                  dagid_str,\n                  dao->rpl_daoseq,\n                  dao->rpl_instanceid,\n                  RPL_DAO_K(dao->rpl_flags) ? \",acK\":\"\",\n                  RPL_DAO_D(dao->rpl_flags) ? \",Dagid\":\"\",\n                  dao->rpl_flags));\n        if(ndo->ndo_vflag > 1) {\n                const struct rpl_dio_genoption *opt = (const struct rpl_dio_genoption *)bp;\n                rpl_dio_printopt(ndo, opt, length);\n        }\n\treturn;\ntrunc:\n\tND_PRINT((ndo,\" [|truncated]\"));\n\treturn;\ntooshort:\n\tND_PRINT((ndo,\" [|length too short]\"));\n\treturn;\n}", "target": 1}
{"code": "init_copy(mrb_state *mrb, mrb_value dest, mrb_value obj)\n{\n  switch (mrb_type(obj)) {\n    case MRB_TT_ICLASS:\n      copy_class(mrb, dest, obj);\n      return;\n    case MRB_TT_CLASS:\n    case MRB_TT_MODULE:\n      copy_class(mrb, dest, obj);\n      mrb_iv_copy(mrb, dest, obj);\n      mrb_iv_remove(mrb, dest, mrb_intern_lit(mrb, \"__classname__\"));\n      break;\n    case MRB_TT_OBJECT:\n    case MRB_TT_SCLASS:\n    case MRB_TT_HASH:\n    case MRB_TT_DATA:\n    case MRB_TT_EXCEPTION:\n      mrb_iv_copy(mrb, dest, obj);\n      break;\n    case MRB_TT_ISTRUCT:\n      mrb_istruct_copy(dest, obj);\n      break;\n    default:\n      break;\n  }\n  mrb_funcall(mrb, dest, \"initialize_copy\", 1, obj);\n}", "target": 0}
{"code": "static void iommu_disable_protect_mem_regions(struct intel_iommu *iommu)\n{\n\tu32 pmen;\n\tunsigned long flags;\n\traw_spin_lock_irqsave(&iommu->register_lock, flags);\n\tpmen = readl(iommu->reg + DMAR_PMEN_REG);\n\tpmen &= ~DMA_PMEN_EPM;\n\twritel(pmen, iommu->reg + DMAR_PMEN_REG);\n\tIOMMU_WAIT_OP(iommu, DMAR_PMEN_REG,\n\t\treadl, !(pmen & DMA_PMEN_PRS), pmen);\n\traw_spin_unlock_irqrestore(&iommu->register_lock, flags);\n}", "target": 0}
{"code": "void usb_serial_console_disconnect(struct usb_serial *serial)\n{\n\tif (serial->port[0] == usbcons_info.port) {\n\t\tusb_serial_console_exit();\n\t\tusb_serial_put(serial);\n\t}\n}", "target": 1}
{"code": "int crypto_scrypt(const uint8_t* password, size_t pwlen, const uint8_t* salt,\n                  size_t saltlen, uint64_t N, uint32_t r, uint32_t p,\n                  uint8_t* buf, size_t buflen) {\n  return crypto_pwhash_scryptsalsa208sha256_ll(password, pwlen, salt, saltlen,\n                                               N, r, p, buf, buflen);\n}", "target": 0}
{"code": "hermesBuiltinApply(void *, Runtime *runtime, NativeArgs args) {\n  GCScopeMarkerRAII marker{runtime};\n  Handle<Callable> fn = args.dyncastArg<Callable>(0);\n  if (LLVM_UNLIKELY(!fn)) {\n    return runtime->raiseTypeErrorForValue(\n        args.getArgHandle(0), \" is not a function\");\n  }\n  Handle<JSArray> argArray = args.dyncastArg<JSArray>(1);\n  if (LLVM_UNLIKELY(!argArray)) {\n    return runtime->raiseTypeError(\"args must be an array\");\n  }\n  uint32_t len = JSArray::getLength(*argArray);\n  bool isConstructor = args.getArgCount() == 2;\n  MutableHandle<> thisVal{runtime};\n  if (isConstructor) {\n    auto thisValRes = Callable::createThisForConstruct(fn, runtime);\n    if (LLVM_UNLIKELY(thisValRes == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    thisVal = *thisValRes;\n  } else {\n    thisVal = args.getArg(2);\n  }\n  ScopedNativeCallFrame newFrame{\n      runtime, len, *fn, isConstructor, thisVal.getHermesValue()};\n  if (LLVM_UNLIKELY(newFrame.overflowed()))\n    return runtime->raiseStackOverflow(Runtime::StackOverflowKind::NativeStack);\n  for (uint32_t i = 0; i < len; ++i) {\n    newFrame->getArgRef(i) = argArray->at(runtime, i);\n  }\n  return isConstructor ? Callable::construct(fn, runtime, thisVal)\n                       : Callable::call(fn, runtime);\n}", "target": 0}
{"code": "static int head_onwire_len(int ctrl_len, bool secure)\n{\n\tint head_len;\n\tint rem_len;\n\tBUG_ON(ctrl_len < 0 || ctrl_len > CEPH_MSG_MAX_CONTROL_LEN);\n\tif (secure) {\n\t\thead_len = CEPH_PREAMBLE_SECURE_LEN;\n\t\tif (ctrl_len > CEPH_PREAMBLE_INLINE_LEN) {\n\t\t\trem_len = ctrl_len - CEPH_PREAMBLE_INLINE_LEN;\n\t\t\thead_len += padded_len(rem_len) + CEPH_GCM_TAG_LEN;\n\t\t}\n\t} else {\n\t\thead_len = CEPH_PREAMBLE_PLAIN_LEN;\n\t\tif (ctrl_len)\n\t\t\thead_len += ctrl_len + CEPH_CRC_LEN;\n\t}\n\treturn head_len;\n}", "target": 0}
{"code": "void ResourceHandle::FromProto(const ResourceHandleProto& proto) {\n  set_device(proto.device());\n  set_container(proto.container());\n  set_name(proto.name());\n  set_hash_code(proto.hash_code());\n  set_maybe_type_name(proto.maybe_type_name());\n  std::vector<DtypeAndPartialTensorShape> dtypes_and_shapes;\n  for (const auto& dtype_and_shape : proto.dtypes_and_shapes()) {\n    DataType dtype = dtype_and_shape.dtype();\n    PartialTensorShape shape(dtype_and_shape.shape());\n    dtypes_and_shapes.push_back(DtypeAndPartialTensorShape{dtype, shape});\n  }\n  dtypes_and_shapes_ = std::move(dtypes_and_shapes);\n}", "target": 1}
{"code": "static noinline int btrfs_mksubvol(struct path *parent,\n\t\t\t\t   char *name, int namelen,\n\t\t\t\t   struct btrfs_root *snap_src,\n\t\t\t\t   u64 *async_transid, bool readonly,\n\t\t\t\t   struct btrfs_qgroup_inherit **inherit)\n{\n\tstruct inode *dir  = parent->dentry->d_inode;\n\tstruct dentry *dentry;\n\tint error;\n\tmutex_lock_nested(&dir->i_mutex, I_MUTEX_PARENT);\n\tdentry = lookup_one_len(name, parent->dentry, namelen);\n\terror = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto out_unlock;\n\terror = -EEXIST;\n\tif (dentry->d_inode)\n\t\tgoto out_dput;\n\terror = btrfs_may_create(dir, dentry);\n\tif (error)\n\t\tgoto out_dput;\n\terror = btrfs_check_dir_item_collision(BTRFS_I(dir)->root,\n\t\t\t\t\t       dir->i_ino, name,\n\t\t\t\t\t       namelen);\n\tif (error)\n\t\tgoto out_dput;\n\tdown_read(&BTRFS_I(dir)->root->fs_info->subvol_sem);\n\tif (btrfs_root_refs(&BTRFS_I(dir)->root->root_item) == 0)\n\t\tgoto out_up_read;\n\tif (snap_src) {\n\t\terror = create_snapshot(snap_src, dentry, name, namelen,\n\t\t\t\t\tasync_transid, readonly, inherit);\n\t} else {\n\t\terror = create_subvol(BTRFS_I(dir)->root, dentry,\n\t\t\t\t      name, namelen, async_transid, inherit);\n\t}\n\tif (!error)\n\t\tfsnotify_mkdir(dir, dentry);\nout_up_read:\n\tup_read(&BTRFS_I(dir)->root->fs_info->subvol_sem);\nout_dput:\n\tdput(dentry);\nout_unlock:\n\tmutex_unlock(&dir->i_mutex);\n\treturn error;\n}", "target": 0}
{"code": "R_API RCmdAliasVal *r_cmd_alias_get(RCmd *cmd, const char *k) {\n\tr_return_val_if_fail (cmd && cmd->aliases && k, NULL);\n\treturn ht_pp_find(cmd->aliases, k, NULL);\n}", "target": 1}
{"code": "agoo_ws_create_req(agooCon c, long mlen) {\n    uint8_t\top = 0x0F & *c->buf;\n    if (NULL == (c->req = agoo_req_create(mlen))) {\n\tagoo_log_cat(&agoo_error_cat, \"Out of memory attempting to allocate request.\");\n\treturn true;\n    }\n    if (NULL == c->up || agoo_server.ctx_nil_value == c->up->ctx) {\n\treturn true;\n    }\n    memset(c->req, 0, sizeof(struct _agooReq));\n    if ((long)c->bcnt <= mlen) {\n\tmemcpy(c->req->msg, c->buf, c->bcnt);\n\tif ((long)c->bcnt < mlen) {\n\t    memset(c->req->msg + c->bcnt, 0, mlen - c->bcnt);\n\t}\n    } else {\n\tmemcpy(c->req->msg, c->buf, mlen);\n    }\n    c->req->msg[mlen] = '\\0';\n    c->req->mlen = mlen;\n    c->req->method = (AGOO_WS_OP_BIN == op) ? AGOO_ON_BIN : AGOO_ON_MSG;\n    c->req->upgrade = AGOO_UP_NONE;\n    c->req->up = c->up;\n    memcpy(c->req->remote, c->remote, sizeof(c->remote));\n    c->req->res = NULL;\n    if (c->up->on_msg) {\n\tc->req->hook = agoo_hook_create(AGOO_NONE, NULL, c->up->ctx, PUSH_HOOK, &agoo_server.eval_queue);\n    }\n    return false;\n}", "target": 0}
{"code": "static void llc_sap_rcv(struct llc_sap *sap, struct sk_buff *skb,\n\t\t\tstruct sock *sk)\n{\n\tstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\n\tev->type   = LLC_SAP_EV_TYPE_PDU;\n\tev->reason = 0;\n\tskb_orphan(skb);\n\tsock_hold(sk);\n\tskb->sk = sk;\n\tskb->destructor = sock_efree;\n\tllc_sap_state_process(sap, skb);\n}", "target": 0}
{"code": "void gitn_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tif (ptr == NULL) return;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tif (ptr->entries[i].name) gf_free(ptr->entries[i].name);\n\t}\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);", "target": 1}
{"code": "ssize_t enc_untrusted_recvfrom(int sockfd, void *buf, size_t len, int flags,\n                               struct sockaddr *src_addr, socklen_t *addrlen) {\n  int klinux_flags = TokLinuxRecvSendFlag(flags);\n  if (klinux_flags == 0 && flags != 0) {\n    errno = EINVAL;\n    return -1;\n  }\n  MessageWriter input;\n  input.Push<int>(sockfd);\n  input.Push<uint64_t>(len);\n  input.Push<int>(klinux_flags);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kRecvFromHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_recvfrom\", 4);\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n  if (result > len) {\n    ::asylo::primitives::TrustedPrimitives::BestEffortAbort(\n        \"enc_untrusted_recvfrom: result exceeds requested\");\n  }\n  auto buffer_received = output.next();\n  memcpy(buf, buffer_received.data(), std::min(len, buffer_received.size()));\n  if (src_addr != nullptr && addrlen != nullptr) {\n    auto klinux_sockaddr_buf = output.next();\n    const struct klinux_sockaddr *klinux_addr =\n        klinux_sockaddr_buf.As<struct klinux_sockaddr>();\n    FromkLinuxSockAddr(klinux_addr, klinux_sockaddr_buf.size(), src_addr,\n                       addrlen, TrustedPrimitives::BestEffortAbort);\n  }\n  return result;\n}", "target": 0}
{"code": "lib_contains_symbol(const char *path, const char *s)\n{\n\tstruct nlist nl[2];\n\tint ret = -1, r;\n\tmemset(nl, 0, sizeof(nl));\n\tnl[0].n_name = xstrdup(s);\n\tnl[1].n_name = NULL;\n\tif ((r = nlist(path, nl)) == -1) {\n\t\terror_f(\"nlist failed for %s\", path);\n\t\tgoto out;\n\t}\n\tif (r != 0 || nl[0].n_value == 0 || nl[0].n_type == 0) {\n\t\terror_f(\"library %s does not contain symbol %s\", path, s);\n\t\tgoto out;\n\t}\n\tret = 0;\n out:\n\tfree(nl[0].n_name);\n\treturn ret;\n}", "target": 0}
{"code": "static int proc_dmesg_restrict(struct ctl_table *table, int write,\n\t\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tif (write && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\treturn proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n}", "target": 0}
{"code": "bool Mfcc::Initialize(int input_length, double input_sample_rate) {\n  bool initialized = mel_filterbank_.Initialize(\n      input_length, input_sample_rate, filterbank_channel_count_,\n      lower_frequency_limit_, upper_frequency_limit_);\n  initialized &=\n      dct_.Initialize(filterbank_channel_count_, dct_coefficient_count_);\n  initialized_ = initialized;\n  return initialized;\n}", "target": 1}
{"code": "static int rt6_bind_neighbour(struct rt6_info *rt, struct net_device *dev)\n{\n\tstruct neighbour *n = __ipv6_neigh_lookup(&nd_tbl, dev, &rt->rt6i_gateway);\n\tif (!n) {\n\t\tn = neigh_create(&nd_tbl, &rt->rt6i_gateway, dev);\n\t\tif (IS_ERR(n))\n\t\t\treturn PTR_ERR(n);\n\t}\n\trt->n = n;\n\treturn 0;\n}", "target": 0}
{"code": "static int hci_uart_set_proto(struct hci_uart *hu, int id)\n{\n\tconst struct hci_uart_proto *p;\n\tint err;\n\tp = hci_uart_get_proto(id);\n\tif (!p)\n\t\treturn -EPROTONOSUPPORT;\n\thu->proto = p;\n\tset_bit(HCI_UART_PROTO_READY, &hu->flags);\n\terr = hci_uart_register_dev(hu);\n\tif (err) {\n\t\tclear_bit(HCI_UART_PROTO_READY, &hu->flags);\n\t\treturn err;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int getSingletonPos(const char* str)\n{\n\tint result =-1;\n\tint i=0;\n\tint len = 0;\n\tif( str && ((len=strlen(str))>0) ){\n\t\tfor( i=0; i<len ; i++){\n\t\t\tif( isIDSeparator(*(str+i)) ){\n\t\t\t\tif( i==1){\n\t\t\t\t\tresult =0;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tif( isIDSeparator(*(str+i+2)) ){\n\t\t\t\t\t\tresult = i+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "target": 1}
{"code": "std::set<std::string> getMounts(Computer * computer, const std::string& comp_path) {\n    std::vector<std::string> elems = split(comp_path, \"/\\\\\");\n    std::list<std::string> pathc;\n    std::set<std::string> retval;\n    for (std::string s : elems) {\n        if (s == \"..\") { if (pathc.empty()) return retval; else pathc.pop_back(); }\n        else if (!s.empty() && !std::all_of(s.begin(), s.end(), [](const char c)->bool{return c == '.';})) {\n            s.erase(std::remove_if(s.begin(), s.end(), [](char c)->bool{return c=='\"'||c==':'||c=='<'||c=='>'||c=='?'||c=='|';}), s.end());\n            pathc.push_back(s);\n        }\n    }\n    for (const auto& m : computer->mounts)\n        if (pathc.size() + 1 == std::get<0>(m).size() && std::equal(pathc.begin(), pathc.end(), std::get<0>(m).begin()))\n            retval.insert(std::get<0>(m).back());\n    return retval;\n}", "target": 1}
{"code": "static int ax25_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n\tstruct sock *sk;\n\tax25_cb *ax25;\n\tif (protocol < 0 || protocol > SK_PROTOCOL_MAX)\n\t\treturn -EINVAL;\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\tswitch (sock->type) {\n\tcase SOCK_DGRAM:\n\t\tif (protocol == 0 || protocol == PF_AX25)\n\t\t\tprotocol = AX25_P_TEXT;\n\t\tbreak;\n\tcase SOCK_SEQPACKET:\n\t\tswitch (protocol) {\n\t\tcase 0:\n\t\tcase PF_AX25:\t\n\t\t\tprotocol = AX25_P_TEXT;\n\t\t\tbreak;\n\t\tcase AX25_P_SEGMENT:\n#ifdef CONFIG_INET\n\t\tcase AX25_P_ARP:\n\t\tcase AX25_P_IP:\n#endif\n#ifdef CONFIG_NETROM\n\t\tcase AX25_P_NETROM:\n#endif\n#ifdef CONFIG_ROSE\n\t\tcase AX25_P_ROSE:\n#endif\n\t\t\treturn -ESOCKTNOSUPPORT;\n#ifdef CONFIG_NETROM_MODULE\n\t\tcase AX25_P_NETROM:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_NETROM))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_ROSE_MODULE\n\t\tcase AX25_P_ROSE:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_ROSE))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SOCK_RAW:\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\tsk = sk_alloc(net, PF_AX25, GFP_ATOMIC, &ax25_proto, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\tax25 = ax25_sk(sk)->cb = ax25_create_cb();\n\tif (!ax25) {\n\t\tsk_free(sk);\n\t\treturn -ENOMEM;\n\t}\n\tsock_init_data(sock, sk);\n\tsk->sk_destruct = ax25_free_sock;\n\tsock->ops    = &ax25_proto_ops;\n\tsk->sk_protocol = protocol;\n\tax25->sk    = sk;\n\treturn 0;\n}", "target": 0}
{"code": "void pin_remove(struct fs_pin *pin)\n{\n\tspin_lock(&pin_lock);\n\thlist_del(&pin->m_list);\n\thlist_del(&pin->s_list);\n\tspin_unlock(&pin_lock);\n\tspin_lock_irq(&pin->wait.lock);\n\tpin->done = 1;\n\twake_up_locked(&pin->wait);\n\tspin_unlock_irq(&pin->wait.lock);\n}", "target": 1}
{"code": "static bool path_connected(const struct path *path)\n{\n\tstruct vfsmount *mnt = path->mnt;\n\tif (mnt->mnt_root == mnt->mnt_sb->s_root)\n\t\treturn true;\n\treturn is_subdir(path->dentry, mnt->mnt_root);\n}", "target": 0}
{"code": "set_option_info(struct archive_string *info, int *opt, const char *key,\n    enum keytype type,  ...)\n{\n\tva_list ap;\n\tchar prefix;\n\tconst char *s;\n\tint d;\n\tprefix = (*opt==0)? ' ':',';\n\tva_start(ap, type);\n\tswitch (type) {\n\tcase KEY_FLG:\n\t\td = va_arg(ap, int);\n\t\tarchive_string_sprintf(info, \"%c%s%s\",\n\t\t    prefix, (d == 0)?\"!\":\"\", key);\n\t\tbreak;\n\tcase KEY_STR:\n\t\ts = va_arg(ap, const char *);\n\t\tarchive_string_sprintf(info, \"%c%s=%s\",\n\t\t    prefix, key, s);\n\t\tbreak;\n\tcase KEY_INT:\n\t\td = va_arg(ap, int);\n\t\tarchive_string_sprintf(info, \"%c%s=%d\",\n\t\t    prefix, key, d);\n\t\tbreak;\n\tcase KEY_HEX:\n\t\td = va_arg(ap, int);\n\t\tarchive_string_sprintf(info, \"%c%s=%x\",\n\t\t    prefix, key, d);\n\t\tbreak;\n\t}\n\tva_end(ap);\n\t*opt = 1;\n}", "target": 0}
{"code": "static size_t socket_slurp(RSocket *s, RBuffer *buf) {\n\tsize_t i;\n\tif (r_socket_ready (s, 1, 0) != 1) {\n\t\treturn 0;\n\t}\n\tr_socket_block_time (s, 1, 0, 1000);\n\tfor (i = 0; i < SOCKET_HTTP_MAX_HEADER_LENGTH; i += 1) {\n\t\tut8 c;\n\t\tint olen = r_socket_read_block (s, &c, 1);\n\t\tif (olen != 1) {\n\t\t\tr_buf_append_bytes (buf, (ut8 *)\"\", 1);\n\t\t\tbreak;\n\t\t}\n\t\tr_buf_append_bytes (buf, &c, 1);\n\t}\n\treturn i;\n}", "target": 0}
{"code": "SWFShape_setLeftFillStyle(SWFShape shape, SWFFillStyle fill)\n{\n\tShapeRecord record;\n\tint idx;\n\tif ( shape->isEnded || shape->isMorph )\n\t\treturn;\n\tif(fill == NOFILL)\n\t{\n\t\trecord = addStyleRecord(shape);\n\t\trecord.record.stateChange->leftFill = 0;\n\t\trecord.record.stateChange->flags |= SWF_SHAPE_FILLSTYLE0FLAG;\n\t\treturn;\n\t}\n\tidx = getFillIdx(shape, fill);\n\tif(idx == 0) \n\t{\n\t\tSWFFillStyle_addDependency(fill, (SWFCharacter)shape);\n\t\tif(addFillStyle(shape, fill) < 0)\n\t\t\treturn;\t\t\n\t\tidx = getFillIdx(shape, fill);\n\t}\n\telse if (idx >= 255 && shape->useVersion == SWF_SHAPE1)\n\t{\n\t\tSWF_error(\"Too many fills for SWFShape V1.\\n\" \n\t\t\t  \"Use a higher SWFShape version\\n\");\n\t}\n\trecord = addStyleRecord(shape);\n\trecord.record.stateChange->leftFill = idx;\n\trecord.record.stateChange->flags |= SWF_SHAPE_FILLSTYLE0FLAG;\n}", "target": 0}
{"code": "void uwbd_start(struct uwb_rc *rc)\n{\n\trc->uwbd.task = kthread_run(uwbd, rc, \"uwbd\");\n\tif (rc->uwbd.task == NULL)\n\t\tprintk(KERN_ERR \"UWB: Cannot start management daemon; \"\n\t\t       \"UWB won't work\\n\");\n\telse\n\t\trc->uwbd.pid = rc->uwbd.task->pid;\n}", "target": 1}
{"code": "utf32be_mbc_to_code(const UChar* p, const UChar* end ARG_UNUSED)\n{\n  if (end - p < 4) return 0;\n  return (OnigCodePoint )(((p[0] * 256 + p[1]) * 256 + p[2]) * 256 + p[3]);\n}", "target": 0}
{"code": "*/\nMYSQL_PLUGIN_EXPORT\nchar *mysql_authentication_dialog_ask(MYSQL *mysql, int type,\n                                      const char *prompt,\n                                      char *buf, int buf_len)\n{\n  char *s=buf;\n  fputs(prompt, stdout);\n  fputs(\" \", stdout);\n  if (!fgets(buf, buf_len-1, stdin))\n    buf[0]= 0;\n  else if (buf[0] && (s= strend(buf))[-1] == '\\n')\n    s[-1]= 0;\n  for (s= buf; *s; s++)\n    fputc(type == 2 ? '*' : *s, stdout);\n  fputc('\\n', stdout);", "target": 0}
{"code": "_gnutls_x509_get_signature_algorithm(ASN1_TYPE src, const char *src_name)\n{\n\tint result;\n\tgnutls_datum_t sa;\n\tresult = _gnutls_x509_read_value(src, src_name, &sa);\n\tif (result < 0) {\n\t\tgnutls_assert();\n\t\treturn result;\n\t}\n\tresult = _gnutls_x509_oid2sign_algorithm((char *) sa.data);\n\t_gnutls_free_datum(&sa);\n\treturn result;\n}", "target": 0}
{"code": "  void ComputeAsync(OpKernelContext* c, DoneCallback done) override {\n    auto col_params = new CollectiveParams();\n    auto done_with_cleanup = [col_params, done = std::move(done)]() {\n      done();\n      col_params->Unref();\n    };\n    OP_REQUIRES_OK_ASYNC(c,\n                         FillCollectiveParams(col_params, REDUCTION_COLLECTIVE,\n                                               c->input(1),\n                                               c->input(2),\n                                               c->input(3)),\n                         done);\n    col_params->instance.shape = c->input(0).shape();\n    col_params->merge_op = merge_op_.get();\n    col_params->final_op = final_op_.get();\n    VLOG(1) << \"CollectiveReduceV2 group_size \" << col_params->group.group_size\n            << \" group_key \" << col_params->group.group_key << \" instance_key \"\n            << col_params->instance.instance_key;\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK_ASYNC(c,\n                         c->forward_input_or_allocate_output(\n                             {0}, 0, col_params->instance.shape, &output),\n                         done_with_cleanup);\n    Run(c, col_params, std::move(done_with_cleanup));\n  }", "target": 1}
{"code": "static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,\n\t\t\t     struct task_struct *tsk)\n{\n\tunsigned cpu = smp_processor_id();\n\tif (likely(prev != next)) {\n#ifdef CONFIG_SMP\n\t\tthis_cpu_write(cpu_tlbstate.state, TLBSTATE_OK);\n\t\tthis_cpu_write(cpu_tlbstate.active_mm, next);\n#endif\n\t\tcpumask_set_cpu(cpu, mm_cpumask(next));\n\t\tload_cr3(next->pgd);\n\t\ttrace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL);\n\t\tcpumask_clear_cpu(cpu, mm_cpumask(prev));\n\t\tload_mm_cr4(next);\n#ifdef CONFIG_MODIFY_LDT_SYSCALL\n\t\tif (unlikely(prev->context.ldt != next->context.ldt))\n\t\t\tload_mm_ldt(next);\n#endif\n\t}\n#ifdef CONFIG_SMP\n\t  else {\n\t\tthis_cpu_write(cpu_tlbstate.state, TLBSTATE_OK);\n\t\tBUG_ON(this_cpu_read(cpu_tlbstate.active_mm) != next);\n\t\tif (!cpumask_test_cpu(cpu, mm_cpumask(next))) {\n\t\t\tcpumask_set_cpu(cpu, mm_cpumask(next));\n\t\t\tload_cr3(next->pgd);\n\t\t\ttrace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL);\n\t\t\tload_mm_cr4(next);\n\t\t\tload_mm_ldt(next);\n\t\t}\n\t}\n#endif\n}", "target": 1}
{"code": "void j2k_dump (opj_j2k_t* p_j2k, OPJ_INT32 flag, FILE* out_stream)\n{\n        if ( (flag & OPJ_JP2_INFO) || (flag & OPJ_JP2_IND)){\n                fprintf(out_stream, \"Wrong flag\\n\");\n                return;\n        }\n        if (flag & OPJ_IMG_INFO){\n                if (p_j2k->m_private_image)\n                        j2k_dump_image_header(p_j2k->m_private_image, 0, out_stream);\n        }\n        if (flag & OPJ_J2K_MH_INFO){\n                opj_j2k_dump_MH_info(p_j2k, out_stream);\n        }\n        if (flag & OPJ_J2K_TCH_INFO){\n          OPJ_UINT32 l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;\n          OPJ_UINT32 i;\n          opj_tcp_t * l_tcp = p_j2k->m_cp.tcps;\n          for (i=0;i<l_nb_tiles;++i) {\n            opj_j2k_dump_tile_info( l_tcp,(OPJ_INT32)p_j2k->m_private_image->numcomps, out_stream);\n            ++l_tcp;\n          }\n        }\n        if (flag & OPJ_J2K_TH_INFO){\n        }\n        if (flag & OPJ_J2K_MH_IND){\n                opj_j2k_dump_MH_index(p_j2k, out_stream);\n        }\n        if (flag & OPJ_J2K_TH_IND){\n        }\n}", "target": 0}
{"code": "sctp_disposition_t sctp_sf_discard_chunk(struct net *net,\n\t\t\t\t\t const struct sctp_endpoint *ep,\n\t\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t\t const sctp_subtype_t type,\n\t\t\t\t\t void *arg,\n\t\t\t\t\t sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\tSCTP_DEBUG_PRINTK(\"Chunk %d is discarded\\n\", type.chunk);\n\treturn SCTP_DISPOSITION_DISCARD;\n}", "target": 0}
{"code": "static int nla_validate_array(const struct nlattr *head, int len, int maxtype,\n\t\t\t      const struct nla_policy *policy,\n\t\t\t      struct netlink_ext_ack *extack,\n\t\t\t      unsigned int validate)\n{\n\tconst struct nlattr *entry;\n\tint rem;\n\tnla_for_each_attr(entry, head, len, rem) {\n\t\tint ret;\n\t\tif (nla_len(entry) == 0)\n\t\t\tcontinue;\n\t\tif (nla_len(entry) < NLA_HDRLEN) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, entry,\n\t\t\t\t\t    \"Array element too short\");\n\t\t\treturn -ERANGE;\n\t\t}\n\t\tret = __nla_validate(nla_data(entry), nla_len(entry),\n\t\t\t\t     maxtype, policy, validate, extack);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\tkey = key_ref_to_ptr(key_ref);\n\tret = key_read_state(key);\n\tif (ret < 0)\n\t\tgoto error2; \n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error2;\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\ncan_read_key:\n\tret = -EOPNOTSUPP;\n\tif (key->type->read) {\n\t\tdown_read(&key->sem);\n\t\tret = key_validate(key);\n\t\tif (ret == 0)\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\tup_read(&key->sem);\n\t}\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "static void kvm_vcpu_destroy(struct kvm_vcpu *vcpu)\n{\n\tkvm_dirty_ring_free(&vcpu->dirty_ring);\n\tkvm_arch_vcpu_destroy(vcpu);\n\tput_pid(rcu_dereference_protected(vcpu->pid, 1));\n\tfree_page((unsigned long)vcpu->run);\n\tkmem_cache_free(kvm_vcpu_cache, vcpu);\n}", "target": 1}
{"code": "void iov_iter_pipe(struct iov_iter *i, int direction,\n\t\t\tstruct pipe_inode_info *pipe,\n\t\t\tsize_t count)\n{\n\tBUG_ON(direction != ITER_PIPE);\n\tWARN_ON(pipe->nrbufs == pipe->buffers);\n\ti->type = direction;\n\ti->pipe = pipe;\n\ti->idx = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);\n\ti->iov_offset = 0;\n\ti->count = count;\n}", "target": 0}
{"code": "njs_typed_array_set_value(njs_vm_t *vm, njs_typed_array_t *array,\n    uint32_t index, njs_value_t *setval)\n{\n    double              num;\n    njs_int_t           ret;\n    njs_array_buffer_t  *buffer;\n    ret = njs_value_to_number(vm, setval, &num);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    buffer = njs_typed_array_writable(vm, array);\n    if (njs_slow_path(buffer == NULL)) {\n        return NJS_ERROR;\n    }\n    njs_typed_array_prop_set(vm, array, index, num);\n    njs_set_number(setval, num);\n    return NJS_OK;\n}", "target": 1}
{"code": "static int acurite_leak_detector_decode(r_device* decoder, uint8_t* bb)\n{\n    int parity = parity_bytes(&bb[2], 4);\n    if (parity) {\n        decoder_log_bitrow(decoder, 1, __func__, bb, 7 * 8, \"bad parity\");\n        return DECODE_FAIL_MIC;\n    }\n    char const* channel_str = acurite_getChannel(bb[0]);\n    if (*channel_str == 'E') {\n        decoder_logf(decoder, 1, __func__, \"Acurite TXR sensor : bad channel Ch %s\", channel_str);\n        return DECODE_FAIL_SANITY;\n    }\n    int sensor_id = ((bb[0] & 0x3f) << 8) | bb[1];\n    int battery_low = (bb[2] & 0x40) == 0;\n    int is_wet = (bb[3] & 0x10) >> 4;\n    data_t* data;\n    data = data_make(\n            \"model\",                \"\",             DATA_STRING, \"Acurite-Leak\",\n            \"id\",                   \"\",             DATA_INT,    sensor_id,\n            \"channel\",              NULL,           DATA_STRING, channel_str,\n            \"battery_ok\",           \"Battery\",      DATA_INT,    !battery_low,\n            \"leak_detected\",        \"Leak\",         DATA_INT,    is_wet,\n            \"mic\",                  \"Integrity\",    DATA_STRING, \"CHECKSUM\",\n            NULL);\n    decoder_output_data(decoder, data);\n    return 1;\n}", "target": 0}
{"code": "static int hns_gmac_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn ARRAY_SIZE(g_gmac_stats_string);\n\treturn 0;\n}", "target": 1}
{"code": "    inline EndpointSecurityAttributesMask mask() const\n    {\n        EndpointSecurityAttributesMask rv = ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_VALID;\n        if (is_read_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_READ_PROTECTED;\n        if (is_write_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_WRITE_PROTECTED;\n        if (is_discovery_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_DISCOVERY_PROTECTED;\n        if (is_liveliness_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_LIVELINESS_PROTECTED;\n        if (is_submessage_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_SUBMESSAGE_PROTECTED;\n        if (is_payload_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_PAYLOAD_PROTECTED;\n        if (is_key_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_KEY_PROTECTED;\n        return rv;\n    }", "target": 1}
{"code": "\tPong(const std::string& cookie, const std::string& server = \"\")\n\t\t: ClientProtocol::Message(\"PONG\", ServerInstance->Config->GetServerName())\n\t{\n\t\tPushParamRef(ServerInstance->Config->GetServerName());\n\t\tif (!server.empty())\n\t\t\tPushParamRef(server);\n\t\tPushParamRef(cookie);\n\t}", "target": 1}
{"code": "AP4_StszAtom::AP4_StszAtom(AP4_UI32        size, \n                           AP4_UI08        version,\n                           AP4_UI32        flags,\n                           AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_STSZ, size, version, flags)\n{\n    stream.ReadUI32(m_SampleSize);\n    stream.ReadUI32(m_SampleCount);\n    if (m_SampleSize == 0) { \n        if (m_SampleCount > (size-8)/4) {\n            m_SampleCount = 0;\n            return;\n        }\n        AP4_Cardinal sample_count = m_SampleCount;\n        m_Entries.SetItemCount(sample_count);\n        unsigned char* buffer = new unsigned char[sample_count*4];\n        AP4_Result result = stream.Read(buffer, sample_count*4);\n        if (AP4_FAILED(result)) {\n            delete[] buffer;\n            return;\n        }\n        for (unsigned int i=0; i<sample_count; i++) {\n            m_Entries[i] = AP4_BytesToUInt32BE(&buffer[i*4]);\n        }\n        delete[] buffer;\n    }\n}", "target": 0}
{"code": "static mp_obj_t array_extend(mp_obj_t self_in, mp_obj_t arg_in) {\n    assert((MICROPY_PY_BUILTINS_BYTEARRAY && mp_obj_is_type(self_in, &mp_type_bytearray))\n        || (MICROPY_PY_ARRAY && mp_obj_is_type(self_in, &mp_type_array)));\n    mp_obj_array_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_buffer_info_t arg_bufinfo;\n    mp_get_buffer_raise(arg_in, &arg_bufinfo, MP_BUFFER_READ);\n    size_t sz = mp_binary_get_size('@', self->typecode, NULL);\n    size_t len = arg_bufinfo.len / sz;\n    if (self->free < len) {\n        self->items = m_renew(byte, self->items, (self->len + self->free) * sz, (self->len + len) * sz);\n        self->free = 0;\n        if (self_in == arg_in) {\n            mp_get_buffer_raise(arg_in, &arg_bufinfo, MP_BUFFER_READ);\n        }\n    } else {\n        self->free -= len;\n    }\n    mp_seq_copy((byte *)self->items + self->len * sz, arg_bufinfo.buf, len * sz, byte);\n    self->len += len;\n    return mp_const_none;\n}", "target": 0}
{"code": "static void skcipher_release(void *private)\n{\n\tcrypto_free_skcipher(private);\n}", "target": 1}
{"code": "process(register int code, unsigned char** fill)\n{\n    int incode;\n    static unsigned char firstchar;\n    if (code == clear) {\n\tcodesize = datasize + 1;\n\tcodemask = (1 << codesize) - 1;\n\tavail = clear + 2;\n\toldcode = -1;\n\treturn 1;\n    }\n    if (oldcode == -1) {\n        if (code >= clear) {\n            fprintf(stderr, \"bad input: code=%d is larger than clear=%d\\n\",code, clear);\n            return 0;\n        }\n\t*(*fill)++ = suffix[code];\n\tfirstchar = oldcode = code;\n\treturn 1;\n    }\n    if (code > avail) {\n\tfprintf(stderr, \"code %d too large for %d\\n\", code, avail);\n\treturn 0; \n    }\n    incode = code;\n    if (code == avail) {      \n\t*stackp++ = firstchar;\n\tcode = oldcode;\n    }\n    while (code > clear) {\n\t*stackp++ = suffix[code];\n\tcode = prefix[code];\n    }\n    *stackp++ = firstchar = suffix[code];\n    prefix[avail] = oldcode;\n    suffix[avail] = firstchar;\n    avail++;\n    if (((avail & codemask) == 0) && (avail < 4096)) {\n\tcodesize++;\n\tcodemask += avail;\n    }\n    oldcode = incode;\n    do {\n\t*(*fill)++ = *--stackp;\n    } while (stackp > stack);\n    return 1;\n}", "target": 0}
{"code": "sd_markdown_new(\n\tunsigned int extensions,\n\tsize_t max_nesting,\n\tconst struct sd_callbacks *callbacks,\n\tvoid *opaque)\n{\n\tstruct sd_markdown *md = NULL;\n\tassert(max_nesting > 0 && callbacks);\n\tmd = malloc(sizeof(struct sd_markdown));\n\tif (!md)\n\t\treturn NULL;\n\tmemcpy(&md->cb, callbacks, sizeof(struct sd_callbacks));\n\tredcarpet_stack_init(&md->work_bufs[BUFFER_BLOCK], 4);\n\tredcarpet_stack_init(&md->work_bufs[BUFFER_SPAN], 8);\n\tmemset(md->active_char, 0x0, 256);\n\tif (md->cb.emphasis || md->cb.double_emphasis || md->cb.triple_emphasis) {\n\t\tmd->active_char['*'] = MD_CHAR_EMPHASIS;\n\t\tmd->active_char['_'] = MD_CHAR_EMPHASIS;\n\t\tif (extensions & MKDEXT_STRIKETHROUGH)\n\t\t\tmd->active_char['~'] = MD_CHAR_EMPHASIS;\n\t\tif (extensions & MKDEXT_HIGHLIGHT)\n\t\t\tmd->active_char['='] = MD_CHAR_EMPHASIS;\n\t}\n\tif (md->cb.codespan)\n\t\tmd->active_char['`'] = MD_CHAR_CODESPAN;\n\tif (md->cb.linebreak)\n\t\tmd->active_char['\\n'] = MD_CHAR_LINEBREAK;\n\tif (md->cb.image || md->cb.link)\n\t\tmd->active_char['['] = MD_CHAR_LINK;\n\tmd->active_char['<'] = MD_CHAR_LANGLE;\n\tmd->active_char['\\\\'] = MD_CHAR_ESCAPE;\n\tmd->active_char['&'] = MD_CHAR_ENTITITY;\n\tif (extensions & MKDEXT_AUTOLINK) {\n\t\tmd->active_char[':'] = MD_CHAR_AUTOLINK_URL;\n\t\tmd->active_char['@'] = MD_CHAR_AUTOLINK_EMAIL;\n\t\tmd->active_char['w'] = MD_CHAR_AUTOLINK_WWW;\n\t}\n\tif (extensions & MKDEXT_SUPERSCRIPT)\n\t\tmd->active_char['^'] = MD_CHAR_SUPERSCRIPT;\n\tif (extensions & MKDEXT_QUOTE)\n\t\tmd->active_char['\"'] = MD_CHAR_QUOTE;\n\tmd->ext_flags = extensions;\n\tmd->opaque = opaque;\n\tmd->max_nesting = max_nesting;\n\tmd->in_link_body = 0;\n\treturn md;\n}", "target": 0}
{"code": "ossl_cipher_init(int argc, VALUE *argv, VALUE self, int mode)\n{\n    EVP_CIPHER_CTX *ctx;\n    unsigned char key[EVP_MAX_KEY_LENGTH], *p_key = NULL;\n    unsigned char iv[EVP_MAX_IV_LENGTH], *p_iv = NULL;\n    VALUE pass, init_v;\n    if(rb_scan_args(argc, argv, \"02\", &pass, &init_v) > 0){\n\tVALUE cname  = rb_class_path(rb_obj_class(self));\n\trb_warn(\"arguments for %\"PRIsVALUE\"#encrypt and %\"PRIsVALUE\"#decrypt were deprecated; \"\n                \"use %\"PRIsVALUE\"#pkcs5_keyivgen to derive key and IV\",\n                cname, cname, cname);\n\tStringValue(pass);\n\tGetCipher(self, ctx);\n\tif (NIL_P(init_v)) memcpy(iv, \"OpenSSL for Ruby rulez!\", sizeof(iv));\n\telse{\n\t    StringValue(init_v);\n\t    if (EVP_MAX_IV_LENGTH > RSTRING_LEN(init_v)) {\n\t\tmemset(iv, 0, EVP_MAX_IV_LENGTH);\n\t\tmemcpy(iv, RSTRING_PTR(init_v), RSTRING_LEN(init_v));\n\t    }\n\t    else memcpy(iv, RSTRING_PTR(init_v), sizeof(iv));\n\t}\n\tEVP_BytesToKey(EVP_CIPHER_CTX_cipher(ctx), EVP_md5(), iv,\n\t\t       (unsigned char *)RSTRING_PTR(pass), RSTRING_LENINT(pass), 1, key, NULL);\n\tp_key = key;\n\tp_iv = iv;\n    }\n    else {\n\tGetCipher(self, ctx);\n    }\n    if (EVP_CipherInit_ex(ctx, NULL, NULL, p_key, p_iv, mode) != 1) {\n\tossl_raise(eCipherError, NULL);\n    }\n    if (p_key)\n\trb_ivar_set(self, id_key_set, Qtrue);\n    return self;\n}", "target": 0}
{"code": "void rose_del_loopback_node(const rose_address *address)\n{\n\tstruct rose_node *rose_node;\n\tspin_lock_bh(&rose_node_list_lock);\n\trose_node = rose_node_list;\n\twhile (rose_node != NULL) {\n\t\tif ((rose_node->mask == 10) &&\n\t\t    (rosecmpm(address, &rose_node->address, 10) == 0) &&\n\t\t    rose_node->loopback)\n\t\t\tbreak;\n\t\trose_node = rose_node->next;\n\t}\n\tif (rose_node == NULL)\n\t\tgoto out;\n\trose_remove_node(rose_node);\n\trose_loopback_neigh->count--;\nout:\n\tspin_unlock_bh(&rose_node_list_lock);\n}", "target": 0}
{"code": "comics_document_document_thumbnails_iface_init (EvDocumentThumbnailsInterface *iface)\n{\n\tiface->get_thumbnail = comics_document_thumbnails_get_thumbnail;\n\tiface->get_dimensions = comics_document_thumbnails_get_dimensions;\n}", "target": 1}
{"code": "MmkvHostObject::MmkvHostObject(const std::string& instanceId, std::string path,\n                               std::string cryptKey) {\n  __android_log_print(ANDROID_LOG_INFO, \"RNMMKV\",\n                      \"Creating MMKV instance \\\"%s\\\"... (Path: %s, Encryption-Key: %s)\",\n                      instanceId.c_str(), path.c_str(), cryptKey.c_str());\n  std::string* pathPtr = path.size() > 0 ? &path : nullptr;\n  std::string* cryptKeyPtr = cryptKey.size() > 0 ? &cryptKey : nullptr;\n  instance = MMKV::mmkvWithID(instanceId, mmkv::DEFAULT_MMAP_SIZE, MMKV_SINGLE_PROCESS, cryptKeyPtr,\n                              pathPtr);\n  if (instance == nullptr) {\n    if (instanceId.empty()) {\n      throw std::runtime_error(\"Failed to create MMKV instance! `id` cannot be empty!\");\n    }\n    if (cryptKey.size() > 16) {\n      throw std::runtime_error(\n          \"Failed to create MMKV instance! `encryptionKey` cannot be longer than 16 bytes!\");\n    }\n    throw std::runtime_error(\"Failed to create MMKV instance!\");\n  }\n}", "target": 1}
{"code": "void CheckServiceControl(std::shared_ptr<context::RequestContext> context,\n                         std::function<void(Status status)> continuation) {\n  std::shared_ptr<cloud_trace::CloudTraceSpan> trace_span(\n      CreateSpan(context->cloud_trace(), \"CheckServiceControl\"));\n  if (!context->method()) {\n    if (context->GetRequestHTTPMethodWithOverride() == \"OPTIONS\") {\n      TRACE(trace_span) << \"OPTIONS request is rejected\";\n      continuation(Status(Code::PERMISSION_DENIED,\n                          \"The service does not allow CORS traffic.\",\n                          Status::SERVICE_CONTROL));\n    } else {\n      TRACE(trace_span) << \"Method is not configured in the service config\";\n      continuation(Status(Code::NOT_FOUND, \"Method does not exist.\",\n                          Status::SERVICE_CONTROL));\n    }\n    return;\n  } else if (!context->service_context()->service_control() ||\n             context->method()->skip_service_control()) {\n    TRACE(trace_span) << \"Service control check is not needed\";\n    continuation(Status::OK);\n    return;\n  }\n  if (context->api_key().empty()) {\n    if (context->method()->allow_unregistered_calls()) {\n      TRACE(trace_span) << \"Service control check is not needed\";\n      continuation(Status::OK);\n      return;\n    }\n    TRACE(trace_span) << \"Failed at checking caller identity.\";\n    continuation(\n        Status(Code::UNAUTHENTICATED,\n               \"Method doesn't allow unregistered callers (callers without \"\n               \"established identity). Please use API Key or other form of \"\n               \"API consumer identity to call this API.\",\n               Status::SERVICE_CONTROL));\n    return;\n  }\n  service_control::CheckRequestInfo info;\n  context->FillCheckRequestInfo(&info);\n  context->service_context()->service_control()->Check(\n      info, trace_span.get(),\n      [context, continuation, trace_span](\n          Status status, const service_control::CheckResponseInfo &info) {\n        TRACE(trace_span) << \"Check service control request returned with \"\n                          << \"status \" << status.ToString();\n        context->set_check_response_info(info);\n        if (!info.consumer_project_id.empty()) {\n          context->request()->AddHeaderToBackend(kConsumerProjecId,\n                                                 info.consumer_project_id);\n        }\n        continuation(status);\n      });\n}", "target": 1}
{"code": "static inline int mount_entry_on_systemfs(struct mntent *mntent)\n{\n  return mount_entry_on_generic(mntent, mntent->mnt_dir);\n}", "target": 1}
{"code": "static size_t consume_init_expr (ut8 *buf, ut8 *max, ut8 eoc, void *out, ut32 *offset) {\n\tut32 i = 0;\n\twhile (buf + i < max && buf[i] != eoc) {\n\t\ti += 1;\n\t}\n\tif (buf[i] != eoc) {\n\t\treturn 0;\n\t}\n\tif (offset) {\n\t\t*offset += i + 1;\n\t}\n\treturn i + 1;\n}", "target": 1}
{"code": "static unsigned int ipv6_defrag(void *priv,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tconst struct nf_hook_state *state)\n{\n\tint err;\n#if IS_ENABLED(CONFIG_NF_CONNTRACK)\n\tif (skb->nfct && !nf_ct_is_template((struct nf_conn *)skb->nfct))\n\t\treturn NF_ACCEPT;\n#endif\n\terr = nf_ct_frag6_gather(state->net, skb,\n\t\t\t\t nf_ct6_defrag_user(state->hook, skb));\n\tif (err == -EINPROGRESS)\n\t\treturn NF_STOLEN;\n\treturn NF_ACCEPT;\n}", "target": 1}
{"code": "  Status CalculateOutputIndex(OpKernelContext* context, int dimension,\n                              const vector<INDEX_TYPE>& parent_output_index,\n                              INDEX_TYPE output_index_multiplier,\n                              INDEX_TYPE output_size,\n                              vector<INDEX_TYPE>* result) {\n    const RowPartitionTensor row_partition_tensor =\n        GetRowPartitionTensor(context, dimension);\n    auto partition_type = GetRowPartitionTypeByDimension(dimension);\n    switch (partition_type) {\n      case RowPartitionType::VALUE_ROWIDS:\n        return CalculateOutputIndexValueRowID(\n            row_partition_tensor, parent_output_index, output_index_multiplier,\n            output_size, result);\n      case RowPartitionType::ROW_SPLITS:\n        if (row_partition_tensor.size() - 1 > parent_output_index.size()) {\n          return errors::InvalidArgument(\n              \"Row partition size is greater than output size: \",\n              row_partition_tensor.size() - 1, \" > \",\n              parent_output_index.size());\n        }\n        return CalculateOutputIndexRowSplit(\n            row_partition_tensor, parent_output_index, output_index_multiplier,\n            output_size, result);\n      default:\n        return errors::InvalidArgument(\n            \"Unsupported partition type:\",\n            RowPartitionTypeToString(partition_type));\n    }\n  }", "target": 0}
{"code": "int rm_rf_child(int fd, const char *name, RemoveFlags flags) {\n        if (fd < 0)\n                return -EBADF;\n        if (!filename_is_valid(name))\n                return -EINVAL;\n        if ((flags & (REMOVE_ROOT|REMOVE_MISSING_OK)) != 0) \n                return -EINVAL;\n        if (FLAGS_SET(flags, REMOVE_ONLY_DIRECTORIES|REMOVE_SUBVOLUME))\n                return -EINVAL;\n        return rm_rf_children_inner(fd, name, -1, flags, NULL);\n}", "target": 1}
{"code": "static BOOL ntlm_av_pair_check_data(const NTLM_AV_PAIR* pAvPair, size_t cbAvPair, size_t size)\n{\n\tsize_t offset;\n\tif (!pAvPair || cbAvPair < sizeof(NTLM_AV_PAIR) + size)\n\t\treturn FALSE;\n\tif (!ntlm_av_pair_get_next_offset(pAvPair, cbAvPair, &offset))\n\t\treturn FALSE;\n\treturn cbAvPair >= offset;\n}", "target": 0}
{"code": "int sldns_str2wire_nsap_buf(const char* str, uint8_t* rd, size_t* len)\n{\n\tconst char* s = str;\n\tsize_t slen;\n\tsize_t dlen = 0; \n\tif (s[0] != '0' || s[1] != 'x')\n\t\treturn LDNS_WIREPARSE_ERR_INVALID_STR;\n\ts += 2;\n\tslen = strlen(s);\n\tif(slen > LDNS_MAX_RDFLEN*2)\n\t\treturn LDNS_WIREPARSE_ERR_LABEL_OVERFLOW;\n\twhile(*s) {\n\t\tif(isspace((unsigned char)*s) || *s == '.') {\n\t\t\ts++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(!isxdigit((unsigned char)*s))\n\t\t\treturn RET_ERR(LDNS_WIREPARSE_ERR_SYNTAX_HEX, s-str);\n\t\tif(*len < dlen/2 + 1)\n\t\t\treturn RET_ERR(LDNS_WIREPARSE_ERR_BUFFER_TOO_SMALL,\n\t\t\t\ts-str);\n\t\tif((dlen&1)==0)\n\t\t\trd[dlen/2] = (uint8_t)sldns_hexdigit_to_int(*s++) * 16;\n\t\telse\trd[dlen/2] += sldns_hexdigit_to_int(*s++);\n\t\tdlen++;\n\t}\n\tif((dlen&1)!=0)\n\t\treturn RET_ERR(LDNS_WIREPARSE_ERR_SYNTAX_HEX, s-str);\n\t*len = dlen/2;\n\treturn LDNS_WIREPARSE_ERR_OK;\n}", "target": 0}
{"code": "find_node_in_range(struct inode *inode, loff_t min, loff_t max)\n{\n\tstruct rb_node *n = uprobes_tree.rb_node;\n\twhile (n) {\n\t\tstruct uprobe *u = rb_entry(n, struct uprobe, rb_node);\n\t\tif (inode < u->inode) {\n\t\t\tn = n->rb_left;\n\t\t} else if (inode > u->inode) {\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\tif (max < u->offset)\n\t\t\t\tn = n->rb_left;\n\t\t\telse if (min > u->offset)\n\t\t\t\tn = n->rb_right;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn n;\n}", "target": 0}
{"code": "xmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {\n    xmlIDTablePtr table;\n    xmlIDPtr id;\n    xmlChar *ID;\n    if (doc == NULL) return(-1);\n    if (attr == NULL) return(-1);\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)\n        return(-1);\n    ID = xmlNodeListGetString(doc, attr->children, 1);\n    if (ID == NULL)\n        return(-1);\n    xmlValidNormalizeString(ID);\n    id = xmlHashLookup(table, ID);\n    if (id == NULL || id->attr != attr) {\n        xmlFree(ID);\n        return(-1);\n    }\n    xmlHashRemoveEntry(table, ID, xmlFreeIDTableEntry);\n    xmlFree(ID);\n    attr->atype = 0;\n    return(0);\n}", "target": 0}
{"code": "struct mb2_cache_entry *mb2_cache_entry_find_first(struct mb2_cache *cache,\n\t\t\t\t\t\t   u32 key)\n{\n\treturn __entry_find(cache, NULL, key);\n}", "target": 0}
{"code": "static int install_thread_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tBUG_ON(new->thread_keyring);\n\tret = install_thread_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\treturn commit_creds(new);\n}", "target": 1}
{"code": "static struct rpmsg_device *rpmsg_virtio_add_ctrl_dev(struct virtio_device *vdev)\n{\n\tstruct virtproc_info *vrp = vdev->priv;\n\tstruct virtio_rpmsg_channel *vch;\n\tstruct rpmsg_device *rpdev_ctrl;\n\tint err = 0;\n\tvch = kzalloc(sizeof(*vch), GFP_KERNEL);\n\tif (!vch)\n\t\treturn ERR_PTR(-ENOMEM);\n\tvch->vrp = vrp;\n\trpdev_ctrl = &vch->rpdev;\n\trpdev_ctrl->ops = &virtio_rpmsg_ops;\n\trpdev_ctrl->dev.parent = &vrp->vdev->dev;\n\trpdev_ctrl->dev.release = virtio_rpmsg_release_device;\n\trpdev_ctrl->little_endian = virtio_is_little_endian(vrp->vdev);\n\terr = rpmsg_ctrldev_register_device(rpdev_ctrl);\n\tif (err) {\n\t\tkfree(vch);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn rpdev_ctrl;\n}", "target": 1}
{"code": "static int rm_read_extradata(AVFormatContext *s, AVIOContext *pb, AVCodecParameters *par, unsigned size)\n{\n    if (size >= 1<<24) {\n        av_log(s, AV_LOG_ERROR, \"extradata size %u too large\\n\", size);\n        return -1;\n    }\n    if (ff_get_extradata(s, par, pb, size) < 0)\n        return AVERROR(ENOMEM);\n    return 0;\n}", "target": 0}
{"code": "int db__close(void)\n{\n\tsubhier_clean(&db.subs);\n\tretain__clean(&db.retains);\n\tdb__msg_store_clean();\n\treturn MOSQ_ERR_SUCCESS;\n}", "target": 1}
{"code": "  bool matches(const Http::RequestHeaderMap& headers) const override {\n    if (BaseMatcherImpl::matchRoute(headers)) {\n      if (headers.Path() == nullptr) {\n        return false;\n      }\n      const Http::HeaderString& path = headers.Path()->value();\n      const absl::string_view query_string = Http::Utility::findQueryStringStart(path);\n      absl::string_view path_view = path.getStringView();\n      path_view.remove_suffix(query_string.length());\n      if (path_matcher_->match(path_view)) {\n        ENVOY_LOG(debug, \"Regex requirement '{}' matched.\", regex_str_);\n        return true;\n      }\n    }\n    return false;\n  }", "target": 0}
{"code": "static int selinux_sb_remount(struct super_block *sb, void *mnt_opts)\n{\n\tstruct selinux_mnt_opts *opts = mnt_opts;\n\tstruct superblock_security_struct *sbsec = sb->s_security;\n\tu32 sid;\n\tint rc;\n\tif (!(sbsec->flags & SE_SBINITIALIZED))\n\t\treturn 0;\n\tif (!opts)\n\t\treturn 0;\n\tif (opts->fscontext) {\n\t\trc = parse_sid(sb, opts->fscontext, &sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (bad_option(sbsec, FSCONTEXT_MNT, sbsec->sid, sid))\n\t\t\tgoto out_bad_option;\n\t}\n\tif (opts->context) {\n\t\trc = parse_sid(sb, opts->context, &sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (bad_option(sbsec, CONTEXT_MNT, sbsec->mntpoint_sid, sid))\n\t\t\tgoto out_bad_option;\n\t}\n\tif (opts->rootcontext) {\n\t\tstruct inode_security_struct *root_isec;\n\t\troot_isec = backing_inode_security(sb->s_root);\n\t\trc = parse_sid(sb, opts->rootcontext, &sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (bad_option(sbsec, ROOTCONTEXT_MNT, root_isec->sid, sid))\n\t\t\tgoto out_bad_option;\n\t}\n\tif (opts->defcontext) {\n\t\trc = parse_sid(sb, opts->defcontext, &sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (bad_option(sbsec, DEFCONTEXT_MNT, sbsec->def_sid, sid))\n\t\t\tgoto out_bad_option;\n\t}\n\treturn 0;\nout_bad_option:\n\tpr_warn(\"SELinux: unable to change security options \"\n\t       \"during remount (dev %s, type=%s)\\n\", sb->s_id,\n\t       sb->s_type->name);\n\treturn -EINVAL;\n}", "target": 0}
{"code": "static int valid_entry_name(const char *filename)\n{\n\treturn *filename != '\\0' &&\n\t\tstrchr(filename, '/') == NULL &&\n\t\t(*filename != '.' ||\n\t\t (strcmp(filename, \".\") != 0 &&\n\t\t  strcmp(filename, \"..\") != 0 &&\n\t\t  strcmp(filename, DOT_GIT) != 0));\n}", "target": 1}
{"code": "  inline Eigen::IndexList<Eigen::type2index<1>, int> OneByM(int m) {\n    Eigen::IndexList<Eigen::type2index<1>, int> ret;\n    ret.set(1, m);\n    return ret;\n  }", "target": 1}
{"code": "int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)\n{\n\tstruct sctp_association *asoc = sctp_id2assoc(sk, id);\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct socket *sock;\n\tint err = 0;\n\tif (!net_eq(current->nsproxy->net_ns, sock_net(sk)))\n\t\treturn -EINVAL;\n\tif (!asoc)\n\t\treturn -EINVAL;\n\tif (waitqueue_active(&asoc->wait))\n\t\treturn -EBUSY;\n\tif (!sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\terr = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);\n\tif (err < 0)\n\t\treturn err;\n\tsctp_copy_sock(sock->sk, sk, asoc);\n\tsp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);\n\tsctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);\n\t*sockp = sock;\n\treturn err;\n}", "target": 0}
{"code": "TfLiteStatus SimpleOpEval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input1 = tflite::GetInput(context, node, 0);\n  const TfLiteTensor* input2 = tflite::GetInput(context, node, 1);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  int32_t* output_data = output->data.i32;\n  *output_data = *(input1->data.i32) + *(input2->data.i32);\n  return kTfLiteOk;\n}", "target": 1}
{"code": "std::string get_wml_location(const std::string &filename, const std::string &current_dir)\n{\n\tDBG_FS << \"Looking for '\" << filename << \"'.\" << std::endl;\n\tassert(game_config::path.empty() == false);\n\tstd::string result;\n\tif (filename.empty()) {\n\t\tLOG_FS << \"  invalid filename\" << std::endl;\n\t\treturn result;\n\t}\n\tif (filename.find(\"..\") != std::string::npos) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (\\\"..\\\" not allowed).\" << std::endl;\n\t\treturn result;\n\t}\n\tif (looks_like_pbl(filename)) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (.pbl files are not allowed).\" << std::endl;\n\t\treturn result;\n\t}\n\tbool already_found = false;\n\tif (filename[0] == '~')\n\t{\n\t\tresult = get_user_data_dir() + \"/data/\" + filename.substr(1);\n\t\tDBG_FS << \"  trying '\" << result << \"'\" << std::endl;\n\t\talready_found = file_exists(result) || is_directory(result);\n\t}\n\telse if (filename.size() >= 2 && filename[0] == '.' && filename[1] == '/')\n\t{\n\t\tif (!current_dir.empty())\n\t\t{\n\t\t\tresult = current_dir;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = game_config::path;\n\t\t}\n\t\tresult += filename.substr(2);\n\t}\n\telse if (!game_config::path.empty())\n\t\tresult = game_config::path + \"/data/\" + filename;\n\tDBG_FS << \"  trying '\" << result << \"'\" << std::endl;\n\tif (result.empty() ||\n\t    (!already_found && !file_exists(result) && !is_directory(result)))\n\t{\n\t\tDBG_FS << \"  not found\" << std::endl;\n\t\tresult.clear();\n\t}\n\telse\n\t\tDBG_FS << \"  found: '\" << result << \"'\" << std::endl;\n\treturn result;\n}", "target": 0}
{"code": "static int rm_rf_children_inner(\n                int fd,\n                const char *fname,\n                int is_dir,\n                RemoveFlags flags,\n                const struct stat *root_dev) {\n        struct stat st;\n        int r, q = 0;\n        assert(fd >= 0);\n        assert(fname);\n        if (is_dir < 0 ||\n            root_dev ||\n            (is_dir > 0 && (root_dev || (flags & REMOVE_SUBVOLUME)))) {\n                r = fstatat_harder(fd, fname, &st, AT_SYMLINK_NOFOLLOW, flags);\n                if (r < 0)\n                        return r;\n                is_dir = S_ISDIR(st.st_mode);\n        }\n        if (is_dir) {\n                _cleanup_close_ int subdir_fd = -1;\n                if (root_dev && st.st_dev != root_dev->st_dev)\n                        return 0;\n                r = fd_is_mount_point(fd, fname, 0);\n                if (r < 0)\n                        return r;\n                if (r > 0)\n                        return 0;\n                if ((flags & REMOVE_SUBVOLUME) && btrfs_might_be_subvol(&st)) {\n                        r = btrfs_subvol_remove_fd(fd, fname, BTRFS_REMOVE_RECURSIVE|BTRFS_REMOVE_QUOTA);\n                        if (r < 0) {\n                                if (!IN_SET(r, -ENOTTY, -EINVAL))\n                                        return r;\n                        } else\n                                return 1;\n                }\n                subdir_fd = openat(fd, fname, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);\n                if (subdir_fd < 0)\n                        return -errno;\n                q = rm_rf_children(TAKE_FD(subdir_fd), flags | REMOVE_PHYSICAL, root_dev);\n        } else if (flags & REMOVE_ONLY_DIRECTORIES)\n                return 0;\n        r = unlinkat_harder(fd, fname, is_dir ? AT_REMOVEDIR : 0, flags);\n        if (r < 0)\n                return r;\n        if (q < 0)\n                return q;\n        return 1;\n}", "target": 1}
{"code": "static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}", "target": 1}
{"code": "static int l2tp_ip6_recvmsg(struct kiocb *iocb, struct sock *sk,\n\t\t\t    struct msghdr *msg, size_t len, int noblock,\n\t\t\t    int flags, int *addr_len)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *)msg->msg_name;\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tstruct sk_buff *skb;\n\tif (flags & MSG_OOB)\n\t\tgoto out;\n\tif (addr_len)\n\t\t*addr_len = sizeof(*lsa);\n\tif (flags & MSG_ERRQUEUE)\n\t\treturn ipv6_recv_error(sk, msg, len);\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto done;\n\tsock_recv_timestamp(msg, sk, skb);\n\tif (lsa) {\n\t\tlsa->l2tp_family = AF_INET6;\n\t\tlsa->l2tp_unused = 0;\n\t\tlsa->l2tp_addr = ipv6_hdr(skb)->saddr;\n\t\tlsa->l2tp_flowinfo = 0;\n\t\tlsa->l2tp_scope_id = 0;\n\t\tlsa->l2tp_conn_id = 0;\n\t\tif (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)\n\t\t\tlsa->l2tp_scope_id = IP6CB(skb)->iif;\n\t}\n\tif (np->rxopt.all)\n\t\tip6_datagram_recv_ctl(sk, msg, skb);\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err ? err : copied;\n}", "target": 0}
{"code": "static inline void sem_getref_and_unlock(struct sem_array *sma)\n{\n\tipc_rcu_getref(sma);\n\tipc_unlock(&(sma)->sem_perm);\n}", "target": 1}
{"code": "static void coroutine_fn v9fs_attach(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n    int32_t fid, afid, n_uname;\n    V9fsString uname, aname;\n    V9fsFidState *fidp;\n    size_t offset = 7;\n    V9fsQID qid;\n    ssize_t err;\n    v9fs_string_init(&uname);\n    v9fs_string_init(&aname);\n    err = pdu_unmarshal(pdu, offset, \"ddssd\", &fid,\n                        &afid, &uname, &aname, &n_uname);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_attach(pdu->tag, pdu->id, fid, afid, uname.data, aname.data);\n    fidp = alloc_fid(s, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    fidp->uid = n_uname;\n    err = v9fs_co_name_to_path(pdu, NULL, \"/\", &fidp->path);\n    if (err < 0) {\n        err = -EINVAL;\n        clunk_fid(s, fid);\n        goto out;\n    }\n    err = fid_to_qid(pdu, fidp, &qid);\n    if (err < 0) {\n        err = -EINVAL;\n        clunk_fid(s, fid);\n        goto out;\n    }\n    if (!s->migration_blocker) {\n        error_setg(&s->migration_blocker,\n                   \"Migration is disabled when VirtFS export path '%s' is mounted in the guest using mount_tag '%s'\",\n                   s->ctx.fs_root ? s->ctx.fs_root : \"NULL\", s->tag);\n        err = migrate_add_blocker(s->migration_blocker, NULL);\n        if (err < 0) {\n            error_free(s->migration_blocker);\n            s->migration_blocker = NULL;\n            clunk_fid(s, fid);\n            goto out;\n        }\n        s->root_fid = fid;\n    }\n    err = pdu_marshal(pdu, offset, \"Q\", &qid);\n    if (err < 0) {\n        clunk_fid(s, fid);\n        goto out;\n    }\n    err += offset;\n    memcpy(&s->root_qid, &qid, sizeof(qid));\n    trace_v9fs_attach_return(pdu->tag, pdu->id,\n                             qid.type, qid.version, qid.path);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&uname);\n    v9fs_string_free(&aname);\n}", "target": 0}
{"code": "int lxc_safe_uint(const char *numstr, unsigned int *converted)\n{\n\tchar *err = NULL;\n\tunsigned long int uli;\n\twhile (isspace(*numstr))\n\t\tnumstr++;\n\tif (*numstr == '-')\n\t\treturn -EINVAL;\n\terrno = 0;\n\tuli = strtoul(numstr, &err, 0);\n\tif (errno == ERANGE && uli == ULONG_MAX)\n\t\treturn -ERANGE;\n\tif (err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\tif (uli > UINT_MAX)\n\t\treturn -ERANGE;\n\t*converted = (unsigned int)uli;\n\treturn 0;\n}", "target": 0}
{"code": "be32enc_vect(unsigned char *dst, const uint32_t *src, size_t len)\n{\n  size_t i;\n  uint32_t *d;\n  for (i = 0; i < len / 4; i++) {\n    d = (uint32_t *) (dst + i * 4);\n    *d = folly::Endian::big32(src[i]);\n  }\n}", "target": 1}
{"code": "int __audit_mq_timedreceive(mqd_t mqdes, size_t msg_len,\n\t\t\t\tunsigned int __user *u_msg_prio,\n\t\t\t\tconst struct timespec __user *u_abs_timeout)\n{\n\tstruct audit_aux_data_mq_sendrecv *ax;\n\tstruct audit_context *context = current->audit_context;\n\tif (!audit_enabled)\n\t\treturn 0;\n\tif (likely(!context))\n\t\treturn 0;\n\tax = kmalloc(sizeof(*ax), GFP_ATOMIC);\n\tif (!ax)\n\t\treturn -ENOMEM;\n\tif (u_msg_prio != NULL) {\n\t\tif (get_user(ax->msg_prio, u_msg_prio)) {\n\t\t\tkfree(ax);\n\t\t\treturn -EFAULT;\n\t\t}\n\t} else\n\t\tax->msg_prio = 0;\n\tif (u_abs_timeout != NULL) {\n\t\tif (copy_from_user(&ax->abs_timeout, u_abs_timeout, sizeof(ax->abs_timeout))) {\n\t\t\tkfree(ax);\n\t\t\treturn -EFAULT;\n\t\t}\n\t} else\n\t\tmemset(&ax->abs_timeout, 0, sizeof(ax->abs_timeout));\n\tax->mqdes = mqdes;\n\tax->msg_len = msg_len;\n\tax->d.type = AUDIT_MQ_SENDRECV;\n\tax->d.next = context->aux;\n\tcontext->aux = (void *)ax;\n\treturn 0;\n}", "target": 0}
{"code": "static int nfs4_xdr_dec_readdir(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t\tstruct nfs4_readdir_res *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_readdir(xdr, rqstp, res);\nout:\n\treturn status;\n}", "target": 0}
{"code": "gss_get_mic (minor_status,\n\t     context_handle,\n\t     qop_req,\n\t     message_buffer,\n\t     msg_token)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_qop_t\t\tqop_req;\ngss_buffer_t\t\tmessage_buffer;\ngss_buffer_t\t\tmsg_token;\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    status = val_get_mic_args(minor_status, context_handle,\n\t\t\t      qop_req, message_buffer, msg_token);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech) {\n\tif (mech->gss_get_mic) {\n\t    status = mech->gss_get_mic(\n\t\t\t\t    minor_status,\n\t\t\t\t    ctx->internal_ctx_id,\n\t\t\t\t    qop_req,\n\t\t\t\t    message_buffer,\n\t\t\t\t    msg_token);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\treturn(status);\n    }\n    return (GSS_S_BAD_MECH);\n}", "target": 0}
{"code": "static void mark_commit(struct commit *c, void *data)\n{\n\tmark_object(&c->object, NULL, NULL, data);\n}", "target": 1}
{"code": "cleanup_pathname_fsobj(char *path, int *error_number, struct archive_string *error_string, int flags)\n{\n\tchar *dest, *src;\n\tchar separator = '\\0';\n\tdest = src = path;\n\tif (*src == '\\0') {\n\t\tif (error_number) *error_number = ARCHIVE_ERRNO_MISC;\n\t\tif (error_string)\n\t\t    archive_string_sprintf(error_string,\n\t\t\t    \"Invalid empty pathname\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n#if defined(__CYGWIN__)\n\tcleanup_pathname_win(a);\n#endif\n\tif (*src == '/') {\n\t\tif (flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {\n\t\t\tif (error_number) *error_number = ARCHIVE_ERRNO_MISC;\n\t\t\tif (error_string)\n\t\t\t    archive_string_sprintf(error_string,\n\t\t\t\t    \"Path is absolute\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t\tseparator = *src++;\n\t}\n\tfor (;;) {\n\t\tif (src[0] == '\\0') {\n\t\t\tbreak;\n\t\t} else if (src[0] == '/') {\n\t\t\tsrc++;\n\t\t\tcontinue;\n\t\t} else if (src[0] == '.') {\n\t\t\tif (src[1] == '\\0') {\n\t\t\t\tbreak;\n\t\t\t} else if (src[1] == '/') {\n\t\t\t\tsrc += 2;\n\t\t\t\tcontinue;\n\t\t\t} else if (src[1] == '.') {\n\t\t\t\tif (src[2] == '/' || src[2] == '\\0') {\n\t\t\t\t\tif (flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {\n\t\t\t\t\t\tif (error_number) *error_number = ARCHIVE_ERRNO_MISC;\n\t\t\t\t\t\tif (error_string)\n\t\t\t\t\t\t    archive_string_sprintf(error_string,\n\t\t\t\t\t\t\t    \"Path contains '..'\");\n\t\t\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (separator)\n\t\t\t*dest++ = '/';\n\t\twhile (*src != '\\0' && *src != '/') {\n\t\t\t*dest++ = *src++;\n\t\t}\n\t\tif (*src == '\\0')\n\t\t\tbreak;\n\t\tseparator = *src++;\n\t}\n\tif (dest == path) {\n\t\tif (separator)\n\t\t\t*dest++ = '/';\n\t\telse\n\t\t\t*dest++ = '.';\n\t}\n\t*dest = '\\0';\n\treturn (ARCHIVE_OK);\n}", "target": 0}
{"code": "static void tty_set_termios_ldisc(struct tty_struct *tty, int num)\n{\n\tdown_write(&tty->termios_rwsem);\n\ttty->termios.c_line = num;\n\tup_write(&tty->termios_rwsem);\n\ttty->disc_data = NULL;\n\ttty->receive_room = 0;\n}", "target": 0}
{"code": "static void nfs4_return_incompatible_delegation(struct inode *inode, mode_t open_flags)\n{\n\tstruct nfs_delegation *delegation;\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(inode)->delegation);\n\tif (delegation == NULL || (delegation->type & open_flags) == open_flags) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\trcu_read_unlock();\n\tnfs_inode_return_delegation(inode);\n}", "target": 1}
{"code": "static inline int checkSettingSecurity(lua_State* L, const std::string &name)\n{\n\tif (ScriptApiSecurity::isSecure(L) && name.compare(0, 7, \"secure.\") == 0)\n\t\tthrow LuaError(\"Attempt to set secure setting.\");\n\tbool is_mainmenu = false;\n#ifndef SERVER\n\tis_mainmenu = ModApiBase::getGuiEngine(L) != nullptr;\n#endif\n\tif (!is_mainmenu && (name == \"mg_name\" || name == \"mg_flags\")) {\n\t\terrorstream << \"Tried to set global setting \" << name << \", ignoring. \"\n\t\t\t\"minetest.set_mapgen_setting() should be used instead.\" << std::endl;\n\t\tinfostream << script_get_backtrace(L) << std::endl;\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "int js_isuserdata(js_State *J, int idx, const char *tag)\n{\n\tjs_Value *v = stackidx(J, idx);\n\tif (v->type == JS_TOBJECT && v->u.object->type == JS_CUSERDATA)\n\t\treturn !strcmp(tag, v->u.object->u.user.tag);\n\treturn 0;\n}", "target": 0}
{"code": "mm_memvalid(struct mm_master *mm, void *address, size_t size)\n{\n\tvoid *end = (char *)address + size;\n\tif (address < mm->address)\n\t\tfatal(\"mm_memvalid: address too small: %p\", address);\n\tif (end < address)\n\t\tfatal(\"mm_memvalid: end < address: %p < %p\", end, address);\n\tif (end > MM_ADDRESS_END(mm))\n\t\tfatal(\"mm_memvalid: address too large: %p\", address);\n}", "target": 1}
{"code": "static int get_rx_bufs(struct vhost_virtqueue *vq,\n\t\t       struct vring_used_elem *heads,\n\t\t       int datalen,\n\t\t       unsigned *iovcount,\n\t\t       struct vhost_log *log,\n\t\t       unsigned *log_num,\n\t\t       unsigned int quota)\n{\n\tunsigned int out, in;\n\tint seg = 0;\n\tint headcount = 0;\n\tunsigned d;\n\tint r, nlogs = 0;\n\twhile (datalen > 0 && headcount < quota) {\n\t\tif (unlikely(seg >= UIO_MAXIOV)) {\n\t\t\tr = -ENOBUFS;\n\t\t\tgoto err;\n\t\t}\n\t\td = vhost_get_vq_desc(vq->dev, vq, vq->iov + seg,\n\t\t\t\t      ARRAY_SIZE(vq->iov) - seg, &out,\n\t\t\t\t      &in, log, log_num);\n\t\tif (d == vq->num) {\n\t\t\tr = 0;\n\t\t\tgoto err;\n\t\t}\n\t\tif (unlikely(out || in <= 0)) {\n\t\t\tvq_err(vq, \"unexpected descriptor format for RX: \"\n\t\t\t\t\"out %d, in %d\\n\", out, in);\n\t\t\tr = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\tif (unlikely(log)) {\n\t\t\tnlogs += *log_num;\n\t\t\tlog += *log_num;\n\t\t}\n\t\theads[headcount].id = d;\n\t\theads[headcount].len = iov_length(vq->iov + seg, in);\n\t\tdatalen -= heads[headcount].len;\n\t\t++headcount;\n\t\tseg += in;\n\t}\n\theads[headcount - 1].len += datalen;\n\t*iovcount = seg;\n\tif (unlikely(log))\n\t\t*log_num = nlogs;\n\tif (unlikely(datalen > 0)) {\n\t\tr = UIO_MAXIOV + 1;\n\t\tgoto err;\n\t}\n\treturn headcount;\nerr:\n\tvhost_discard_vq_desc(vq, headcount);\n\treturn r;\n}", "target": 0}
{"code": "MYSOFA_EXPORT struct MYSOFA_HRTF* mysofa_load(const char *filename, int *err) {\n\tstruct READER reader;\n\tstruct MYSOFA_HRTF *hrtf = NULL;\n\tif (filename == NULL)\n\t\tfilename = CMAKE_INSTALL_PREFIX \"/share/libmysofa/default.sofa\";\n\tif (strcmp(filename, \"-\"))\n\t\treader.fhd = fopen(filename, \"rb\");\n\telse\n\t\treader.fhd = stdin;\n\tif (!reader.fhd) {\n\t\tlog(\"cannot open file %s\\n\", filename);\n\t\t*err = errno;\n\t\treturn NULL;\n\t}\n\treader.gcol = NULL;\n\treader.all = NULL;\n\treader.recursive_counter = 0;\n\t*err = superblockRead(&reader, &reader.superblock);\n\tif (!*err) {\n\t\thrtf = getHrtf(&reader, err);\n\t}\n\tsuperblockFree(&reader, &reader.superblock);\n\tgcolFree(reader.gcol);\n\tif (strcmp(filename, \"-\"))\n\t\tfclose(reader.fhd);\n\treturn hrtf;\n}", "target": 0}
{"code": "checked_xmalloc (size_t size)\n{\n    alloc_limit_assert (\"checked_xmalloc\", size);\n    return xmalloc (size);\n}", "target": 1}
{"code": "int virtio_gpu_object_create(struct virtio_gpu_device *vgdev,\n\t\t\t     unsigned long size, bool kernel, bool pinned,\n\t\t\t     struct virtio_gpu_object **bo_ptr)\n{\n\tstruct virtio_gpu_object *bo;\n\tenum ttm_bo_type type;\n\tsize_t acc_size;\n\tint ret;\n\tif (kernel)\n\t\ttype = ttm_bo_type_kernel;\n\telse\n\t\ttype = ttm_bo_type_device;\n\t*bo_ptr = NULL;\n\tacc_size = ttm_bo_dma_acc_size(&vgdev->mman.bdev, size,\n\t\t\t\t       sizeof(struct virtio_gpu_object));\n\tbo = kzalloc(sizeof(struct virtio_gpu_object), GFP_KERNEL);\n\tif (bo == NULL)\n\t\treturn -ENOMEM;\n\tsize = roundup(size, PAGE_SIZE);\n\tret = drm_gem_object_init(vgdev->ddev, &bo->gem_base, size);\n\tif (ret != 0)\n\t\treturn ret;\n\tbo->dumb = false;\n\tvirtio_gpu_init_ttm_placement(bo, pinned);\n\tret = ttm_bo_init(&vgdev->mman.bdev, &bo->tbo, size, type,\n\t\t\t  &bo->placement, 0, !kernel, NULL, acc_size,\n\t\t\t  NULL, NULL, &virtio_gpu_ttm_bo_destroy);\n\tif (ret != 0)\n\t\treturn ret;\n\t*bo_ptr = bo;\n\treturn 0;\n}", "target": 1}
{"code": "TfLiteStatus CalculateOpData(TfLiteContext* context, TfLiteNode* node,\n                             const TfLiteConvParams* params, int width,\n                             int height, int filter_width, int filter_height,\n                             int out_width, int out_height,\n                             const TfLiteType data_type, OpData* data) {\n  bool has_bias = node->inputs->size == 3;\n  TF_LITE_ENSURE(context, has_bias || node->inputs->size == 2);\n  TF_LITE_ENSURE_EQ(context, node->outputs->size, 1);\n  auto padding = params->padding;\n  data->padding = ComputePaddingHeightWidth(\n      params->stride_height, params->stride_width,\n      params->dilation_height_factor, params->dilation_width_factor, height,\n      width, filter_height, filter_width, padding, &out_height, &out_width);\n  if (data_type != kTfLiteFloat32) {\n    const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n    TF_LITE_ENSURE(context, input != nullptr);\n    const TfLiteTensor* filter = GetInput(context, node, kFilterTensor);\n    TF_LITE_ENSURE(context, filter != nullptr);\n    const TfLiteTensor* bias =\n        GetOptionalInputTensor(context, node, kBiasTensor);\n    TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n    TF_LITE_ENSURE(context, output != nullptr);\n    int output_channels = filter->dims->data[kConvQuantizedDimension];\n    TF_LITE_ENSURE_STATUS(tflite::PopulateConvolutionQuantizationParams(\n        context, input, filter, bias, output, params->activation,\n        &data->output_multiplier, &data->output_shift,\n        &data->output_activation_min, &data->output_activation_max,\n        data->per_channel_output_multiplier,\n        reinterpret_cast<int*>(data->per_channel_output_shift),\n        output_channels));\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "crm_recv_tls(gnutls_session * session, size_t max_size, size_t *recv_len, int *disconnected)\n{\n    char *buf = NULL;\n    int rc = 0;\n    size_t len = 0;\n    size_t chunk_size = max_size ? max_size : 1024;\n    size_t buf_size = 0;\n    size_t read_size = 0;\n    if (session == NULL) {\n        if (disconnected) {\n            *disconnected = 1;\n        }\n        goto done;\n    }\n    buf = calloc(1, chunk_size + 1);\n    buf_size = chunk_size;\n    while (TRUE) {\n        read_size = buf_size - len;\n        if (!max_size && (read_size < (chunk_size / 2))) {\n            buf_size += chunk_size;\n            crm_trace(\"Grow buffer by %d more bytes. buf is now %d bytes\", (int)chunk_size, buf_size);\n            buf = realloc(buf, buf_size + 1);\n            CRM_ASSERT(buf != NULL);\n            read_size = buf_size - len;\n        }\n        rc = gnutls_record_recv(*session, buf + len, read_size);\n        if (rc > 0) {\n            crm_trace(\"Got %d more bytes.\", rc);\n            len += rc;\n            buf[len] = '\\0';\n        }\n        if (max_size && (max_size == read_size)) {\n            crm_trace(\"Buffer max read size %d met\" , max_size);\n            goto done;\n        }\n        if (rc == GNUTLS_E_INTERRUPTED) {\n            crm_trace(\"EINTR encoutered, retry tls read\");\n        } else if (rc == GNUTLS_E_AGAIN) {\n            crm_trace(\"non-blocking, exiting read on rc = %d\", rc);\n            goto done;\n        } else if (rc <= 0) {\n            if (rc == 0) {\n                crm_debug(\"EOF encoutered during TLS read\");\n            } else {\n                crm_debug(\"Error receiving message: %s (%d)\", gnutls_strerror(rc), rc);\n            }\n            if (disconnected) {\n                *disconnected = 1;\n            }\n            goto done;\n        }\n    }\ndone:\n    if (recv_len) {\n        *recv_len = len;\n    }\n    if (!len) {\n        free(buf);\n        buf = NULL;\n    }\n    return buf;\n}", "target": 0}
{"code": "static void init_security_types(struct nvnc* server)\n{\n#define ADD_SECURITY_TYPE(type) \\\n\tassert(server->n_security_types < MAX_SECURITY_TYPES); \\\n\tserver->security_types[server->n_security_types++] = (type);\n\tif (server->n_security_types > 0)\n\t\treturn;\n\tif (server->auth_flags & NVNC_AUTH_REQUIRE_AUTH) {\n\t\tassert(server->auth_fn);\n#ifdef ENABLE_TLS\n\t\tif (server->tls_creds) {\n\t\t\tADD_SECURITY_TYPE(RFB_SECURITY_TYPE_VENCRYPT);\n\t\t}\n#endif\n#ifdef HAVE_CRYPTO\n\t\tADD_SECURITY_TYPE(RFB_SECURITY_TYPE_RSA_AES256);\n\t\tADD_SECURITY_TYPE(RFB_SECURITY_TYPE_RSA_AES);\n\t\tif (!(server->auth_flags & NVNC_AUTH_REQUIRE_ENCRYPTION)) {\n\t\t\tADD_SECURITY_TYPE(RFB_SECURITY_TYPE_APPLE_DH);\n\t\t}\n#endif\n\t} else {\n\t\tADD_SECURITY_TYPE(RFB_SECURITY_TYPE_NONE);\n\t}\n\tif (server->n_security_types == 0) {\n\t\tnvnc_log(NVNC_LOG_PANIC, \"Failed to satisfy requested security constraints\");\n\t}\n#undef ADD_SECURITY_TYPE\n}", "target": 0}
{"code": "static int xc2028_sleep(struct dvb_frontend *fe)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tint rc;\n\trc = check_device_status(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\tif (!rc)\n\t\treturn 0;\n\tif (no_poweroff || priv->ctrl.disable_power_mgmt)\n\t\treturn 0;\n\ttuner_dbg(\"Putting xc2028/3028 into poweroff mode.\\n\");\n\tif (debug > 1) {\n\t\ttuner_dbg(\"Printing sleep stack trace:\\n\");\n\t\tdump_stack();\n\t}\n\tmutex_lock(&priv->lock);\n\tif (priv->firm_version < 0x0202)\n\t\trc = send_seq(priv, {0x00, XREG_POWER_DOWN, 0x00, 0x00});\n\telse\n\t\trc = send_seq(priv, {0x80, XREG_POWER_DOWN, 0x00, 0x00});\n\tif (rc >= 0)\n\t\tpriv->state = XC2028_SLEEP;\n\tmutex_unlock(&priv->lock);\n\treturn rc;\n}", "target": 0}
{"code": "    const std::unordered_map<std::string, std::string> &getCookies() const\n    {\n        return cookies();\n    }", "target": 1}
{"code": "static int append_key_value(smart_str* loc_name, HashTable* hash_arr, char* key_name)\n{\n\tzval**\tele_value\t= NULL;\n\tif(zend_hash_find(hash_arr , key_name , strlen(key_name) + 1 ,(void **)&ele_value ) == SUCCESS ) {\n\t\tif(Z_TYPE_PP(ele_value)!= IS_STRING ){\n\t\t\treturn FAILURE;\n\t\t}\n\t\tif(strcmp(key_name, LOC_LANG_TAG) != 0 && \n\t\t   strcmp(key_name, LOC_GRANDFATHERED_LANG_TAG)!=0 ) {\n\t\t\tsmart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);\n\t\t}\n\t\tsmart_str_appendl(loc_name, Z_STRVAL_PP(ele_value) , Z_STRLEN_PP(ele_value));\n\t\treturn SUCCESS;\n\t}\n\treturn LOC_NOT_FOUND;\n}", "target": 1}
{"code": "static gboolean irssi_ssl_verify_hostname(X509 *cert, const char *hostname)\n{\n\tint gen_index, gen_count;\n\tgboolean matched = FALSE, has_dns_name = FALSE;\n\tconst char *cert_dns_name;\n\tchar *cert_subject_cn;\n\tconst GENERAL_NAME *gn;\n\tSTACK_OF(GENERAL_NAME) * gens;\n\tgens = X509_get_ext_d2i(cert, NID_subject_alt_name, 0, 0);\n\tif (gens) {\n\t\tgen_count = sk_GENERAL_NAME_num(gens);\n\t\tfor (gen_index = 0; gen_index < gen_count && !matched; ++gen_index) {\n\t\t\tgn = sk_GENERAL_NAME_value(gens, gen_index);\n\t\t\tif (gn->type != GEN_DNS)\n\t\t\t\tcontinue;\n\t\t\thas_dns_name = TRUE;\n\t\t\tcert_dns_name = tls_dns_name(gn);\n\t\t\tif (cert_dns_name && *cert_dns_name) {\n\t\t\t\tmatched = match_hostname(cert_dns_name, hostname);\n\t\t\t}\n    \t}\n\t    sk_GENERAL_NAME_pop_free(gens, GENERAL_NAME_free);\n\t}\n\tif (has_dns_name) {\n\t\tif (! matched) {\n\t\t\tg_warning(\"None of the Subject Alt Names in the certificate match hostname '%s'\", hostname);\n\t\t}\n\t\treturn matched;\n\t} else { \n\t\tcert_subject_cn = tls_text_name(X509_get_subject_name(cert), NID_commonName);\n\t    if (cert_subject_cn && *cert_subject_cn) {\n\t    \tmatched = match_hostname(cert_subject_cn, hostname);\n\t    \tif (! matched) {\n\t\t\t\tg_warning(\"SSL certificate common name '%s' doesn't match host name '%s'\", cert_subject_cn, hostname);\n\t    \t}\n\t    } else {\n\t    \tg_warning(\"No subjectAltNames and no valid common name in certificate\");\n\t    }\n\t    free(cert_subject_cn);\n\t}\n\treturn matched;\n}", "target": 0}
{"code": "static int l2cap_sock_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tint err;\n\tstruct l2cap_chan *chan;\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\tif (!sk)\n\t\treturn 0;\n\tl2cap_sock_cleanup_listen(sk);\n\tbt_sock_unlink(&l2cap_sk_list, sk);\n\terr = l2cap_sock_shutdown(sock, SHUT_RDWR);\n\tchan = l2cap_pi(sk)->chan;\n\tl2cap_chan_hold(chan);\n\tl2cap_chan_lock(chan);\n\tsock_orphan(sk);\n\tl2cap_sock_kill(sk);\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n\treturn err;\n}", "target": 0}
{"code": "int rdma_create_qp(struct rdma_cm_id *id, struct ib_pd *pd,\n\t\t   struct ib_qp_init_attr *qp_init_attr)\n{\n\tstruct rdma_id_private *id_priv;\n\tstruct ib_qp *qp;\n\tint ret;\n\tid_priv = container_of(id, struct rdma_id_private, id);\n\tif (id->device != pd->device) {\n\t\tret = -EINVAL;\n\t\tgoto out_err;\n\t}\n\tqp_init_attr->port_num = id->port_num;\n\tqp = ib_create_qp(pd, qp_init_attr);\n\tif (IS_ERR(qp)) {\n\t\tret = PTR_ERR(qp);\n\t\tgoto out_err;\n\t}\n\tif (id->qp_type == IB_QPT_UD)\n\t\tret = cma_init_ud_qp(id_priv, qp);\n\telse\n\t\tret = cma_init_conn_qp(id_priv, qp);\n\tif (ret)\n\t\tgoto out_destroy;\n\tid->qp = qp;\n\tid_priv->qp_num = qp->qp_num;\n\tid_priv->srq = (qp->srq != NULL);\n\ttrace_cm_qp_create(id_priv, pd, qp_init_attr, 0);\n\treturn 0;\nout_destroy:\n\tib_destroy_qp(qp);\nout_err:\n\ttrace_cm_qp_create(id_priv, pd, qp_init_attr, ret);\n\treturn ret;\n}", "target": 0}
{"code": "errno_t sss_filter_sanitize(TALLOC_CTX *mem_ctx,\n                            const char *input,\n                            char **sanitized)\n{\n    return sss_filter_sanitize_ex(mem_ctx, input, sanitized, NULL);\n}", "target": 1}
{"code": "flush_signal_handlers(struct task_struct *t, int force_default)\n{\n\tint i;\n\tstruct k_sigaction *ka = &t->sighand->action[0];\n\tfor (i = _NSIG ; i != 0 ; i--) {\n\t\tif (force_default || ka->sa.sa_handler != SIG_IGN)\n\t\t\tka->sa.sa_handler = SIG_DFL;\n\t\tka->sa.sa_flags = 0;\n#ifdef SA_RESTORER\n\t\tka->sa.sa_restorer = NULL;\n#endif\n\t\tsigemptyset(&ka->sa.sa_mask);\n\t\tka++;\n\t}\n}", "target": 0}
{"code": "PJ_DEF(void) pj_scan_advance_n( pj_scanner *scanner,\n\t\t\t\t unsigned N, pj_bool_t skip_ws)\n{\n    if (scanner->curptr + N > scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    scanner->curptr += N;\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*scanner->curptr) && skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}", "target": 1}
{"code": "BOOL transport_accept_nla(rdpTransport* transport)\n{\n\tfreerdp* instance;\n\trdpSettings* settings;\n\tif (transport->TlsIn == NULL)\n\t\ttransport->TlsIn = tls_new(transport->settings);\n\tif (transport->TlsOut == NULL)\n\t\ttransport->TlsOut = transport->TlsIn;\n\ttransport->layer = TRANSPORT_LAYER_TLS;\n\ttransport->TlsIn->sockfd = transport->TcpIn->sockfd;\n\tif (tls_accept(transport->TlsIn, transport->settings->CertificateFile, transport->settings->PrivateKeyFile) != TRUE)\n\t\treturn FALSE;\n\tif (transport->settings->Authentication != TRUE)\n\t\treturn TRUE;\n\tsettings = transport->settings;\n\tinstance = (freerdp*) settings->instance;\n\tif (transport->credssp == NULL)\n\t\ttransport->credssp = credssp_new(instance, transport, settings);\n\tif (credssp_authenticate(transport->credssp) < 0)\n\t{\n\t\tfprintf(stderr, \"client authentication failure\\n\");\n\t\tcredssp_free(transport->credssp);\n\t\ttransport->credssp = NULL;\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 0}
{"code": "p_string(FILE* f, ptrdiff_t len, UChar* s)\n{\n  fputs(\":\", f);\n  while (len-- > 0) { fputc(*s++, f); }\n}", "target": 0}
{"code": "static int http1_on_error(http1_parser_s *parser) {\n  FIO_LOG_DEBUG(\"HTTP parser error at HTTP/1.1 buffer position %zu/%zu\",\n                parser->state.next - parser2http(parser)->buf,\n                parser2http(parser)->buf_len);\n  fio_close(parser2http(parser)->p.uuid);\n  return -1;\n}", "target": 1}
{"code": "static struct nfc_llcp_local *nfc_llcp_remove_local(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local, *tmp;\n\tspin_lock(&llcp_devices_lock);\n\tlist_for_each_entry_safe(local, tmp, &llcp_devices, list)\n\t\tif (local->dev == dev) {\n\t\t\tlist_del(&local->list);\n\t\t\tspin_unlock(&llcp_devices_lock);\n\t\t\treturn local;\n\t\t}\n\tspin_unlock(&llcp_devices_lock);\n\tpr_warn(\"Shutting down device not found\\n\");\n\treturn NULL;\n}", "target": 0}
{"code": "int bson_check_field_name( bson *b, const char *string,\n                           const int length ) {\n    return bson_validate_string( b, ( const unsigned char * )string, length, 1, 1, 1 );\n}", "target": 1}
{"code": "static pj_status_t get_name_len(int rec_counter, const pj_uint8_t *pkt, \n                                const pj_uint8_t *start, const pj_uint8_t *max, \n                                int *parsed_len, int *name_len)\n{\n    const pj_uint8_t *p;\n    pj_status_t status;\n    if (rec_counter > 10) {\n        return PJLIB_UTIL_EDNSINNAMEPTR;\n    }\n    if (start >= max)\n        return PJLIB_UTIL_EDNSINNAMEPTR;\n    *name_len = *parsed_len = 0;\n    p = start;\n    while (*p) {\n        if ((*p & 0xc0) == 0xc0) {\n            int ptr_len = 0;\n            int dummy;\n            pj_uint16_t offset;\n            pj_memcpy(&offset, p, 2);\n            offset ^= pj_htons((pj_uint16_t)(0xc0 << 8));\n            offset = pj_ntohs(offset);\n            if (offset >= max - pkt)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n            status = get_name_len(rec_counter+1, pkt, pkt + offset, max, \n                                  &dummy, &ptr_len);\n            if (status != PJ_SUCCESS)\n                return status;\n            *parsed_len += 2;\n            *name_len += ptr_len;\n            return PJ_SUCCESS;\n        } else {\n            unsigned label_len = *p;\n            if (p+1+label_len+1 > max)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n            p += (label_len + 1);\n            *parsed_len += (label_len + 1);\n            if (*p != 0)\n                ++label_len;\n            *name_len += label_len;\n        }\n    }\n    ++p;\n    (*parsed_len)++;\n    return PJ_SUCCESS;\n}", "target": 0}
{"code": "static int persist__subs_save_all(FILE *db_fptr)\n{\n\tstruct mosquitto__subhier *subhier, *subhier_tmp;\n\tHASH_ITER(hh, db.subs, subhier, subhier_tmp){\n\t\tif(subhier->children){\n\t\t\tpersist__subs_save(db_fptr, subhier->children, \"\", 0);\n\t\t}\n\t}\n\treturn MOSQ_ERR_SUCCESS;\n}", "target": 1}
{"code": "  void decode(bufferlist::iterator& bl) {\n    __u8 struct_v;\n    ::decode(struct_v, bl);\n    ::decode(nonce, bl);\n    if (struct_v >= 2) {\n      ::decode(have_challenge, bl);\n      ::decode(server_challenge_plus_one, bl);\n    }\n  }", "target": 0}
{"code": "static MagickBooleanType DrawStrokePolygon(Image *image,\n  const DrawInfo *draw_info,const PrimitiveInfo *primitive_info,\n  ExceptionInfo *exception)\n{\n  DrawInfo\n    *clone_info;\n  MagickBooleanType\n    closed_path;\n  MagickStatusType\n    status;\n  PrimitiveInfo\n    *stroke_polygon;\n  register const PrimitiveInfo\n    *p,\n    *q;\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n      \"    begin draw-stroke-polygon\");\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  clone_info->fill=draw_info->stroke;\n  if (clone_info->fill_pattern != (Image *) NULL)\n    clone_info->fill_pattern=DestroyImage(clone_info->fill_pattern);\n  if (clone_info->stroke_pattern != (Image *) NULL)\n    clone_info->fill_pattern=CloneImage(clone_info->stroke_pattern,0,0,\n      MagickTrue,exception);\n  clone_info->stroke.alpha=(Quantum) TransparentAlpha;\n  clone_info->stroke_width=0.0;\n  clone_info->fill_rule=NonZeroRule;\n  status=MagickTrue;\n  for (p=primitive_info; p->primitive != UndefinedPrimitive; p+=p->coordinates)\n  {\n    stroke_polygon=TraceStrokePolygon(draw_info,p);\n    status&=DrawPolygonPrimitive(image,clone_info,stroke_polygon,exception);\n    if (status == 0)\n      break;\n    stroke_polygon=(PrimitiveInfo *) RelinquishMagickMemory(stroke_polygon);\n    q=p+p->coordinates-1;\n    closed_path=(q->point.x == p->point.x) && (q->point.y == p->point.y) ?\n      MagickTrue : MagickFalse;\n    if ((draw_info->linecap == RoundCap) && (closed_path == MagickFalse))\n      {\n        DrawRoundLinecap(image,draw_info,p,exception);\n        DrawRoundLinecap(image,draw_info,q,exception);\n      }\n  }\n  clone_info=DestroyDrawInfo(clone_info);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n      \"    end draw-stroke-polygon\");\n  return(status != 0 ? MagickTrue : MagickFalse);\n}", "target": 1}
{"code": "bool IsRelativeSymlinkSafe(CommandData *Cmd,const wchar *SrcName,const wchar *PrepSrcName,const wchar *TargetName)\n{\n  if (IsFullRootPath(SrcName) || IsFullRootPath(TargetName))\n    return false;\n  int UpLevels=0;\n  for (int Pos=0;*TargetName!=0;Pos++)\n  {\n    bool Dot2=TargetName[0]=='.' && TargetName[1]=='.' && \n              (IsPathDiv(TargetName[2]) || TargetName[2]==0) &&\n              (Pos==0 || IsPathDiv(*(TargetName-1)));\n    if (Dot2)\n      UpLevels++;\n    TargetName++;\n  }\n  if (UpLevels>0 && LinkInPath(PrepSrcName))\n    return false;\n  int AllowedDepth=CalcAllowedDepth(SrcName); \n  size_t ExtrPathLength=wcslen(Cmd->ExtrPath);\n  if (ExtrPathLength>0 && wcsncmp(PrepSrcName,Cmd->ExtrPath,ExtrPathLength)==0)\n  {\n    PrepSrcName+=ExtrPathLength;\n    while (IsPathDiv(*PrepSrcName))\n      PrepSrcName++;\n  }\n  int PrepAllowedDepth=CalcAllowedDepth(PrepSrcName);\n  return AllowedDepth>=UpLevels && PrepAllowedDepth>=UpLevels;\n}", "target": 1}
{"code": "static std::string WC2MB(const std::wstring& input, unsigned int code_page) {\n  if (input.empty()) {\n    return \"\";\n  }\n  DWORD flags = 0;\n  if (code_page != 65001 && code_page != 54936) {\n    flags = WC_NO_BEST_FIT_CHARS | WC_COMPOSITECHECK | WC_DEFAULTCHAR;\n  }\n  int length = ::WideCharToMultiByte(code_page, flags, &input[0],\n                                     static_cast<int>(input.size()), NULL, 0,\n                                     NULL, NULL);\n  std::string output(length, '\\0');\n  ::WideCharToMultiByte(code_page, flags, &input[0],\n                        static_cast<int>(input.size()), &output[0],\n                        static_cast<int>(output.size()), NULL, NULL);\n  return output;\n}", "target": 0}
{"code": "static inline void sem_putref(struct sem_array *sma)\n{\n\tipc_lock_by_ptr(&sma->sem_perm);\n\tipc_rcu_putref(sma);\n\tipc_unlock(&(sma)->sem_perm);\n}", "target": 1}
{"code": "void Context::onStart(absl::string_view root_id, absl::string_view vm_configuration) {\n  if (wasm_->onStart_) {\n    auto root_id_addr = wasm_->copyString(root_id);\n    auto config_addr = wasm_->copyString(vm_configuration);\n    wasm_->onStart_(this, id_, root_id_addr, root_id.size(), config_addr, vm_configuration.size());\n  }\n  in_vm_context_created_ = true;\n}", "target": 0}
{"code": "cib_remote_msg(gpointer data)\n{\n    const char *value = NULL;\n    xmlNode *command = NULL;\n    cib_client_t *client = data;\n    crm_trace(\"%s callback\", client->encrypted ? \"secure\" : \"clear-text\");\n    command = crm_recv_remote_msg(client->session, client->encrypted);\n    if (command == NULL) {\n        return -1;\n    }\n    value = crm_element_name(command);\n    if (safe_str_neq(value, \"cib_command\")) {\n        crm_log_xml_trace(command, \"Bad command: \");\n        goto bail;\n    }\n    if (client->name == NULL) {\n        value = crm_element_value(command, F_CLIENTNAME);\n        if (value == NULL) {\n            client->name = strdup(client->id);\n        } else {\n            client->name = strdup(value);\n        }\n    }\n    if (client->callback_id == NULL) {\n        value = crm_element_value(command, F_CIB_CALLBACK_TOKEN);\n        if (value != NULL) {\n            client->callback_id = strdup(value);\n            crm_trace(\"Callback channel for %s is %s\", client->id, client->callback_id);\n        } else {\n            client->callback_id = strdup(client->id);\n        }\n    }\n    xml_remove_prop(command, F_ORIG);\n    xml_remove_prop(command, F_CIB_HOST);\n    xml_remove_prop(command, F_CIB_GLOBAL_UPDATE);\n    crm_xml_add(command, F_TYPE, T_CIB);\n    crm_xml_add(command, F_CIB_CLIENTID, client->id);\n    crm_xml_add(command, F_CIB_CLIENTNAME, client->name);\n#if ENABLE_ACL\n    crm_xml_add(command, F_CIB_USER, client->user);\n#endif\n    if (crm_element_value(command, F_CIB_CALLID) == NULL) {\n        char *call_uuid = crm_generate_uuid();\n        crm_xml_add(command, F_CIB_CALLID, call_uuid);\n        free(call_uuid);\n    }\n    if (crm_element_value(command, F_CIB_CALLOPTS) == NULL) {\n        crm_xml_add_int(command, F_CIB_CALLOPTS, 0);\n    }\n    crm_log_xml_trace(command, \"Remote command: \");\n    cib_common_callback_worker(0, 0, command, client, TRUE);\n  bail:\n    free_xml(command);\n    command = NULL;\n    return 0;\n}", "target": 1}
{"code": "int dsOpen(void) {\n    struct stat sb;\n    int retval;\n    char *path = server.diskstore_path;\n    if ((retval = stat(path,&sb) == -1) && errno != ENOENT) {\n        redisLog(REDIS_WARNING, \"Error opening disk store at %s: %s\",\n                path, strerror(errno));\n        return REDIS_ERR;\n    }\n    if (retval == 0 && S_ISDIR(sb.st_mode)) return REDIS_OK;\n    if (retval == 0 && !S_ISDIR(sb.st_mode)) {\n        redisLog(REDIS_WARNING,\"Disk store at %s is not a directory\", path);\n        return REDIS_ERR;\n    }\n    if (mkdir(path) == -1) {\n        redisLog(REDIS_WARNING,\"Disk store init failed creating dir %s: %s\",\n            path, strerror(errno));\n        return REDIS_ERR;\n    }\n    return REDIS_OK;\n}", "target": 1}
{"code": "int sctp_verify_asconf(const struct sctp_association *asoc,\n\t\t       struct sctp_paramhdr *param_hdr, void *chunk_end,\n\t\t       struct sctp_paramhdr **errp) {\n\tsctp_addip_param_t *asconf_param;\n\tunion sctp_params param;\n\tint length, plen;\n\tparam.v = (sctp_paramhdr_t *) param_hdr;\n\twhile (param.v <= chunk_end - sizeof(sctp_paramhdr_t)) {\n\t\tlength = ntohs(param.p->length);\n\t\t*errp = param.p;\n\t\tif (param.v > chunk_end - length ||\n\t\t    length < sizeof(sctp_paramhdr_t))\n\t\t\treturn 0;\n\t\tswitch (param.p->type) {\n\t\tcase SCTP_PARAM_ADD_IP:\n\t\tcase SCTP_PARAM_DEL_IP:\n\t\tcase SCTP_PARAM_SET_PRIMARY:\n\t\t\tasconf_param = (sctp_addip_param_t *)param.v;\n\t\t\tplen = ntohs(asconf_param->param_hdr.length);\n\t\t\tif (plen < sizeof(sctp_addip_param_t) +\n\t\t\t    sizeof(sctp_paramhdr_t))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase SCTP_PARAM_SUCCESS_REPORT:\n\t\tcase SCTP_PARAM_ADAPTATION_LAYER_IND:\n\t\t\tif (length != sizeof(sctp_addip_param_t))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tparam.v += WORD_ROUND(length);\n\t}\n\tif (param.v != chunk_end)\n\t\treturn 0;\n\treturn 1;\n}", "target": 1}
{"code": "static int masq_inet_event(struct notifier_block *this,\n\t\t\t   unsigned long event,\n\t\t\t   void *ptr)\n{\n\tstruct net_device *dev = ((struct in_ifaddr *)ptr)->ifa_dev->dev;\n\tstruct netdev_notifier_info info;\n\tnetdev_notifier_info_init(&info, dev);\n\treturn masq_device_event(this, event, &info);\n}", "target": 1}
{"code": "static void ufs_mtk_init_va09_pwr_ctrl(struct ufs_hba *hba)\n{\n\tstruct ufs_mtk_host *host = ufshcd_get_variant(hba);\n\thost->reg_va09 = regulator_get(hba->dev, \"va09\");\n\tif (!host->reg_va09)\n\t\tdev_info(hba->dev, \"failed to get va09\");\n\telse\n\t\thost->caps |= UFS_MTK_CAP_VA09_PWR_CTRL;\n}", "target": 1}
{"code": "*/\nPHP_FUNCTION(date_parse)\n{\n\tchar                           *date;\n\tint                             date_len;\n\tstruct timelib_error_container *error;\n\ttimelib_time                   *parsed_time;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &date, &date_len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tparsed_time = timelib_strtotime(date, date_len, &error, DATE_TIMEZONEDB, php_date_parse_tzfile_wrapper);\n\tphp_date_do_return_parsed_time(INTERNAL_FUNCTION_PARAM_PASSTHRU, parsed_time, error);", "target": 0}
{"code": "snmp_ber_decode_timeticks(snmp_packet_t *snmp_packet, uint32_t *timeticks)\n{\n  return snmp_ber_decode_unsigned_integer(snmp_packet, BER_DATA_TYPE_TIMETICKS, timeticks);\n}", "target": 0}
{"code": "static u16 swf_get_16(SWFReader *read)\n{\n\tu16 val, res;\n\tval = swf_read_int(read, 16);\n\tres = (val&0xFF);\n\tres <<=8;\n\tres |= ((val>>8)&0xFF);\n\treturn res;\n}", "target": 1}
{"code": "int qeth_snmp_command(struct qeth_card *card, char __user *udata)\n{\n\tstruct qeth_cmd_buffer *iob;\n\tstruct qeth_ipa_cmd *cmd;\n\tstruct qeth_snmp_ureq *ureq;\n\tint req_len;\n\tstruct qeth_arp_query_info qinfo = {0, };\n\tint rc = 0;\n\tQETH_CARD_TEXT(card, 3, \"snmpcmd\");\n\tif (card->info.guestlan)\n\t\treturn -EOPNOTSUPP;\n\tif ((!qeth_adp_supported(card, IPA_SETADP_SET_SNMP_CONTROL)) &&\n\t    (!card->options.layer2)) {\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (copy_from_user(&req_len, udata + sizeof(int), sizeof(int)))\n\t\treturn -EFAULT;\n\tureq = memdup_user(udata, req_len + sizeof(struct qeth_snmp_ureq_hdr));\n\tif (IS_ERR(ureq)) {\n\t\tQETH_CARD_TEXT(card, 2, \"snmpnome\");\n\t\treturn PTR_ERR(ureq);\n\t}\n\tqinfo.udata_len = ureq->hdr.data_len;\n\tqinfo.udata = kzalloc(qinfo.udata_len, GFP_KERNEL);\n\tif (!qinfo.udata) {\n\t\tkfree(ureq);\n\t\treturn -ENOMEM;\n\t}\n\tqinfo.udata_offset = sizeof(struct qeth_snmp_ureq_hdr);\n\tiob = qeth_get_adapter_cmd(card, IPA_SETADP_SET_SNMP_CONTROL,\n\t\t\t\t   QETH_SNMP_SETADP_CMDLENGTH + req_len);\n\tcmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\n\tmemcpy(&cmd->data.setadapterparms.data.snmp, &ureq->cmd, req_len);\n\trc = qeth_send_ipa_snmp_cmd(card, iob, QETH_SETADP_BASE_LEN + req_len,\n\t\t\t\t    qeth_snmp_command_cb, (void *)&qinfo);\n\tif (rc)\n\t\tQETH_DBF_MESSAGE(2, \"SNMP command failed on %s: (0x%x)\\n\",\n\t\t\t   QETH_CARD_IFNAME(card), rc);\n\telse {\n\t\tif (copy_to_user(udata, qinfo.udata, qinfo.udata_len))\n\t\t\trc = -EFAULT;\n\t}\n\tkfree(ureq);\n\tkfree(qinfo.udata);\n\treturn rc;\n}", "target": 1}
{"code": "static void vapic_exit(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tint idx;\n\tif (!apic || !apic->vapic_addr)\n\t\treturn;\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tkvm_release_page_dirty(apic->vapic_page);\n\tmark_page_dirty(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n}", "target": 1}
{"code": "INST_HANDLER (lds) {\t\n\tif (len < 4) {\n\t\treturn;\n\t}\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tint k = (buf[3] << 8) | buf[2];\n\top->ptr = k;\n\t__generic_ld_st (op, \"ram\", 0, 1, 0, k, 0);\n\tESIL_A (\"r%d,=,\", d);\n}", "target": 0}
{"code": "int uev_init1(uev_ctx_t *ctx, int maxevents)\n{\n\tif (!ctx || maxevents < 1) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tif (maxevents > UEV_MAX_EVENTS)\n\t\tmaxevents = UEV_MAX_EVENTS;\n\tmemset(ctx, 0, sizeof(*ctx));\n\tctx->maxevents = maxevents;\n\treturn _init(ctx, 0);\n}", "target": 0}
{"code": "static void stellaris_enet_unrealize(DeviceState *dev, Error **errp)\n{\n    stellaris_enet_state *s = STELLARIS_ENET(dev);\n    unregister_savevm(DEVICE(s), \"stellaris_enet\", s);\n    memory_region_destroy(&s->mmio);\n}", "target": 1}
{"code": "snmp_mib_cmp_oid(snmp_oid_t *oid1, snmp_oid_t *oid2)\n{\n  uint8_t i;\n  i = 0;\n  while(i < oid1->length && i < oid2->length) {\n    if(oid1->data[i] != oid2->data[i]) {\n      if(oid1->data[i] < oid2->data[i]) {\n        return -1;\n      }\n      return 1;\n    }\n    i++;\n  }\n  if(i == oid1->length &&\n     i < oid2->length) {\n    return -1;\n  }\n  if(i < oid1->length &&\n     i == oid2->length) {\n    return 1;\n  }\n  return 0;\n}", "target": 0}
{"code": "static int tcos_list_files(sc_card_t *card, u8 *buf, size_t buflen)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tu8 rbuf[SC_MAX_APDU_BUFFER_SIZE], p1;\n\tint r, count = 0;\n\tassert(card != NULL);\n\tctx = card->ctx;\n\tfor (p1=1; p1<=2; p1++) {\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xAA, p1, 0);\n\t\tapdu.cla = 0x80;\n\t\tapdu.resp = rbuf;\n\t\tapdu.resplen = sizeof(rbuf);\n\t\tapdu.le = 256;\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tSC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\t\tif (apdu.sw1==0x6A && (apdu.sw2==0x82 || apdu.sw2==0x88)) continue;\n\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tSC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, \"List Dir failed\");\n\t\tif (apdu.resplen > buflen) return SC_ERROR_BUFFER_TOO_SMALL;\n\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\t \"got %\"SC_FORMAT_LEN_SIZE_T\"u %s-FileIDs\\n\",\n\t\t\t apdu.resplen / 2, p1 == 1 ? \"DF\" : \"EF\");\n\t\tmemcpy(buf, apdu.resp, apdu.resplen);\n\t\tbuf += apdu.resplen;\n\t\tbuflen -= apdu.resplen;\n\t\tcount += apdu.resplen;\n\t}\n\treturn count;\n}", "target": 0}
{"code": "static ssize_t ib_ucm_write(struct file *filp, const char __user *buf,\n\t\t\t    size_t len, loff_t *pos)\n{\n\tstruct ib_ucm_file *file = filp->private_data;\n\tstruct ib_ucm_cmd_hdr hdr;\n\tssize_t result;\n\tif (WARN_ON_ONCE(!ib_safe_file_access(filp)))\n\t\treturn -EACCES;\n\tif (len < sizeof(hdr))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&hdr, buf, sizeof(hdr)))\n\t\treturn -EFAULT;\n\tif (hdr.cmd >= ARRAY_SIZE(ucm_cmd_table))\n\t\treturn -EINVAL;\n\tif (hdr.in + sizeof(hdr) > len)\n\t\treturn -EINVAL;\n\tresult = ucm_cmd_table[hdr.cmd](file, buf + sizeof(hdr),\n\t\t\t\t\thdr.in, hdr.out);\n\tif (!result)\n\t\tresult = len;\n\treturn result;\n}", "target": 0}
{"code": "gss_verify_mic (minor_status,\n\t\tcontext_handle,\n\t\tmessage_buffer,\n\t\ttoken_buffer,\n\t\tqop_state)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_buffer_t\t\tmessage_buffer;\ngss_buffer_t\t\ttoken_buffer;\ngss_qop_t *\t\tqop_state;\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n    *minor_status = 0;\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n    if ((message_buffer == GSS_C_NO_BUFFER) ||\n\tGSS_EMPTY_BUFFER(token_buffer))\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech) {\n\tif (mech->gss_verify_mic) {\n\t    status = mech->gss_verify_mic(\n\t\t\t\t\t  minor_status,\n\t\t\t\t\t  ctx->internal_ctx_id,\n\t\t\t\t\t  message_buffer,\n\t\t\t\t\t  token_buffer,\n\t\t\t\t\t  qop_state);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\treturn(status);\n    }\n    return (GSS_S_BAD_MECH);\n}", "target": 0}
{"code": "void nfc_llcp_mac_is_down(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local;\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL)\n\t\treturn;\n\tlocal->remote_miu = LLCP_DEFAULT_MIU;\n\tlocal->remote_lto = LLCP_DEFAULT_LTO;\n\tnfc_llcp_socket_release(local, true, 0);\n\tnfc_llcp_local_put(local);\n}", "target": 0}
{"code": "static void vgacon_scrollback_switch(int vc_num)\n{\n\tif (!scrollback_persistent)\n\t\tvc_num = 0;\n\tif (!vgacon_scrollbacks[vc_num].data) {\n\t\tvgacon_scrollback_init(vc_num);\n\t} else {\n\t\tif (scrollback_persistent) {\n\t\t\tvgacon_scrollback_cur = &vgacon_scrollbacks[vc_num];\n\t\t} else {\n\t\t\tsize_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;\n\t\t\tvgacon_scrollback_reset(vc_num, size);\n\t\t}\n\t}\n}", "target": 1}
{"code": "int jpc_bitstream_putbits(jpc_bitstream_t *bitstream, int n, long v)\n{\n\tint m;\n\tassert(n >= 0 && n < 32);\n\tassert(!(v & (~JAS_ONES(n))));\n\tm = n - 1;\n\twhile (--n >= 0) {\n\t\tif (jpc_bitstream_putbit(bitstream, (v >> m) & 1) == EOF) {\n\t\t\treturn EOF;\n\t\t}\n\t\tv <<= 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int srpt_rx_mgmt_fn_tag(struct srpt_send_ioctx *ioctx, u64 tag)\n{\n\tstruct srpt_device *sdev;\n\tstruct srpt_rdma_ch *ch;\n\tstruct srpt_send_ioctx *target;\n\tint ret, i;\n\tret = -EINVAL;\n\tch = ioctx->ch;\n\tBUG_ON(!ch);\n\tBUG_ON(!ch->sport);\n\tsdev = ch->sport->sdev;\n\tBUG_ON(!sdev);\n\tspin_lock_irq(&sdev->spinlock);\n\tfor (i = 0; i < ch->rq_size; ++i) {\n\t\ttarget = ch->ioctx_ring[i];\n\t\tif (target->cmd.se_lun == ioctx->cmd.se_lun &&\n\t\t    target->cmd.tag == tag &&\n\t\t    srpt_get_cmd_state(target) != SRPT_STATE_DONE) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irq(&sdev->spinlock);\n\treturn ret;\n}", "target": 1}
{"code": "int sqlite3ExpandSubquery(Parse *pParse, struct SrcList_item *pFrom){\n  Select *pSel = pFrom->pSelect;\n  Table *pTab;\n  assert( pSel );\n  pFrom->pTab = pTab = sqlite3DbMallocZero(pParse->db, sizeof(Table));\n  if( pTab==0 ) return SQLITE_NOMEM;\n  pTab->nTabRef = 1;\n  if( pFrom->zAlias ){\n    pTab->zName = sqlite3DbStrDup(pParse->db, pFrom->zAlias);\n  }else{\n    pTab->zName = sqlite3MPrintf(pParse->db, \"subquery_%u\", pSel->selId);\n  }\n  while( pSel->pPrior ){ pSel = pSel->pPrior; }\n  sqlite3ColumnsFromExprList(pParse, pSel->pEList,&pTab->nCol,&pTab->aCol);\n  pTab->iPKey = -1;\n  pTab->nRowLogEst = 200; assert( 200==sqlite3LogEst(1048576) );\n  pTab->tabFlags |= TF_Ephemeral;\n  return pParse->nErr ? SQLITE_ERROR : SQLITE_OK;\n}", "target": 0}
{"code": "void test_base64_decode(void)\n{\n  char buffer[16];\n  int len = mutt_b64_decode(buffer, encoded);\n  if (!TEST_CHECK(len == sizeof(clear) - 1))\n  {\n    TEST_MSG(\"Expected: %zu\", sizeof(clear) - 1);\n    TEST_MSG(\"Actual  : %zu\", len);\n  }\n  buffer[len] = '\\0';\n  if (!TEST_CHECK(strcmp(buffer, clear) == 0))\n  {\n    TEST_MSG(\"Expected: %s\", clear);\n    TEST_MSG(\"Actual  : %s\", buffer);\n  }\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    OP_REQUIRES(context, tensor_in.dims() == 4,\n                errors::InvalidArgument(\"tensor_in must be 4-dimensional (2)\"));\n    OP_REQUIRES(context, tensor_in.NumElements() > 0,\n                errors::InvalidArgument(\"tensor_in must not be empty (2)\"));\n    PoolParameters params{context,\n                          ksize_,\n                          stride_,\n                          padding_,\n                          {},\n                          FORMAT_NHWC,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n    TensorShape out_shape({params.tensor_in_batch, params.out_height,\n                           params.out_width, params.depth});\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, out_shape, &output));\n    Tensor* argmax = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, out_shape, &argmax));\n    LaunchMaxPoolingWithArgmax<Device, T, Targmax>::launch(\n        context, params, tensor_in, output, argmax, propagate_nans_,\n        include_batch_in_index_);\n  }", "target": 0}
{"code": "int seccomp_restrict_realtime(void) {\n        static const int permitted_policies[] = {\n                SCHED_OTHER,\n                SCHED_BATCH,\n                SCHED_IDLE,\n        };\n        int r, max_policy = 0;\n        uint32_t arch;\n        unsigned i;\n        for (i = 0; i < ELEMENTSOF(permitted_policies); i++)\n                if (permitted_policies[i] > max_policy)\n                        max_policy = permitted_policies[i];\n        SECCOMP_FOREACH_LOCAL_ARCH(arch) {\n                _cleanup_(seccomp_releasep) scmp_filter_ctx seccomp = NULL;\n                int p;\n                log_debug(\"Operating on architecture: %s\", seccomp_arch_to_string(arch));\n                r = seccomp_init_for_arch(&seccomp, arch, SCMP_ACT_ALLOW);\n                if (r < 0)\n                        return r;\n                for (p = 0; p < max_policy; p++) {\n                        bool good = false;\n                        for (i = 0; i < ELEMENTSOF(permitted_policies); i++)\n                                if (permitted_policies[i] == p) {\n                                        good = true;\n                                        break;\n                                }\n                        if (good)\n                                continue;\n                        r = seccomp_rule_add_exact(\n                                        seccomp,\n                                        SCMP_ACT_ERRNO(EPERM),\n                                        SCMP_SYS(sched_setscheduler),\n                                        1,\n                                        SCMP_A1(SCMP_CMP_EQ, p));\n                        if (r < 0) {\n                                log_debug_errno(r, \"Failed to add scheduler rule for architecture %s, skipping: %m\", seccomp_arch_to_string(arch));\n                                continue;\n                        }\n                }\n                r = seccomp_rule_add_exact(\n                                seccomp,\n                                SCMP_ACT_ERRNO(EPERM),\n                                SCMP_SYS(sched_setscheduler),\n                                1,\n                                SCMP_A1(SCMP_CMP_GT, max_policy));\n                if (r < 0) {\n                        log_debug_errno(r, \"Failed to add scheduler rule for architecture %s, skipping: %m\", seccomp_arch_to_string(arch));\n                        continue;\n                }\n                r = seccomp_load(seccomp);\n                if (IN_SET(r, -EPERM, -EACCES))\n                        return r;\n                if (r < 0)\n                        log_debug_errno(r, \"Failed to install realtime protection rules for architecture %s, skipping: %m\", seccomp_arch_to_string(arch));\n        }\n        return 0;\n}", "target": 0}
{"code": "struct resource_pool *dce110_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc,\n\tstruct hw_asic_id asic_id)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\tif (!pool)\n\t\treturn NULL;\n\tif (construct(num_virtual_links, dc, pool, asic_id))\n\t\treturn &pool->base;\n\tkfree(pool);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 0}
{"code": "static void cil_reset_perm(struct cil_perm *perm)\n{\n\tcil_reset_classperms_list(perm->classperms);\n}", "target": 1}
{"code": "static int needs_empty_write(sector_t block, struct inode *inode)\n{\n\tint error;\n\tstruct buffer_head bh_map = { .b_state = 0, .b_blocknr = 0 };\n\tbh_map.b_size = 1 << inode->i_blkbits;\n\terror = gfs2_block_map(inode, block, &bh_map, 0);\n\tif (unlikely(error))\n\t\treturn error;\n\treturn !buffer_mapped(&bh_map);\n}", "target": 1}
{"code": "Status OpLevelCostEstimator::PredictFusedBatchNormGrad(\n    const OpContext& op_context, NodeCosts* node_costs) const {\n  bool found_unknown_shapes = false;\n  const auto& op_info = op_context.op_info;\n  ConvolutionDimensions dims = OpDimensionsFromInputs(\n      op_info.inputs(1).shape(), op_info, &found_unknown_shapes);\n  int64_t ops = 0;\n  const auto rsqrt_cost = Eigen::internal::functor_traits<\n      Eigen::internal::scalar_rsqrt_op<float>>::Cost;\n  ops = dims.iz * (dims.batch * dims.ix * dims.iy * 11 + 5 + rsqrt_cost);\n  node_costs->num_compute_ops = ops;\n  const int64_t size_nhwc =\n      CalculateTensorSize(op_info.inputs(1), &found_unknown_shapes);\n  const int64_t size_c =\n      CalculateTensorSize(op_info.inputs(2), &found_unknown_shapes);\n  node_costs->num_input_bytes_accessed = {size_nhwc, size_nhwc, size_c, size_c};\n  node_costs->num_output_bytes_accessed = {size_nhwc, size_c, size_c};\n  node_costs->internal_read_bytes = size_nhwc;\n  node_costs->max_memory = node_costs->num_total_output_bytes();\n  if (found_unknown_shapes) {\n    node_costs->inaccurate = true;\n    node_costs->num_nodes_with_unknown_shapes = 1;\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "av_cold void ff_vc2enc_free_transforms(VC2TransformContext *s)\n{\n    av_freep(&s->buffer);\n}", "target": 1}
{"code": "static unsigned long kvm_get_tsc_khz(void)\n{\n\tstruct pvclock_vcpu_time_info *src;\n\tsrc = &per_cpu(hv_clock, 0);\n\treturn pvclock_tsc_khz(src);\n}", "target": 0}
{"code": "  static void Launch(OpKernelContext* context, const Tensor& in_x,\n                     const Tensor& in_y, bool adjoint, bool lower,\n                     const MatMulBCast& bcast, Tensor* out) {\n    const int64 batch_size = bcast.output_batch_size();\n    const int64 cost_per_unit =\n        in_x.dim_size(1) * in_x.dim_size(2) * in_y.dim_size(2);\n    auto worker_threads = *(context->device()->tensorflow_cpu_worker_threads());\n    using Matrix =\n        Eigen::Matrix<Scalar, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>;\n    using ConstMatrixMap = Eigen::Map<const Matrix>;\n    using RealScalar = typename Eigen::NumTraits<Scalar>::Real;\n    auto matrix = ConstMatrixMap(in_x.flat<Scalar>().data(), in_x.dim_size(1),\n                                 in_x.dim_size(2));\n    RealScalar min_abs_pivot;\n    if (lower) {\n      min_abs_pivot = matrix.row(0).cwiseAbs().minCoeff();\n    } else {\n      min_abs_pivot = matrix.row(in_x.dim_size(1) - 1).cwiseAbs().minCoeff();\n    }\n    OP_REQUIRES(context, min_abs_pivot > RealScalar(0),\n                errors::InvalidArgument(\"Input matrix is not invertible.\"));\n    Shard(worker_threads.num_threads, worker_threads.workers, batch_size,\n          cost_per_unit,\n          [&in_x, &in_y, adjoint, lower, &bcast, out](int start, int limit) {\n            SequentialBandedTriangularSolveKernel<Scalar>::Run(\n                in_x, in_y, lower, adjoint, bcast, out, start, limit);\n          });\n  }", "target": 1}
{"code": "void flush_tlb_current_task(void)\n{\n\tstruct mm_struct *mm = current->mm;\n\tpreempt_disable();\n\tcount_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);\n\tlocal_flush_tlb();\n\ttrace_tlb_flush(TLB_LOCAL_SHOOTDOWN, TLB_FLUSH_ALL);\n\tif (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids)\n\t\tflush_tlb_others(mm_cpumask(mm), mm, 0UL, TLB_FLUSH_ALL);\n\tpreempt_enable();\n}", "target": 0}
{"code": "static void put_prev_task(struct rq *rq, struct task_struct *prev)\n{\n\tif (prev->se.on_rq)\n\t\tupdate_rq_clock(rq);\n\trq->skip_clock_update = 0;\n\tprev->sched_class->put_prev_task(rq, prev);\n}", "target": 1}
{"code": "bool Archive::ReadSubData(Array<byte> *UnpData,File *DestFile,bool TestMode)\n{\n  if (BrokenHeader)\n  {\n    uiMsg(UIERROR_SUBHEADERBROKEN,FileName);\n    ErrHandler.SetErrorCode(RARX_CRC);\n    return false;\n  }\n  if (SubHead.Method>5 || SubHead.UnpVer>(Format==RARFMT50 ? VER_UNPACK5:VER_UNPACK))\n  {\n    uiMsg(UIERROR_SUBHEADERUNKNOWN,FileName);\n    return false;\n  }\n  if (SubHead.PackSize==0 && !SubHead.SplitAfter)\n    return true;\n  SubDataIO.Init();\n  Unpack Unpack(&SubDataIO);\n  Unpack.Init(SubHead.WinSize,false);\n  if (DestFile==NULL)\n  {\n    if (SubHead.UnpSize>0x1000000)\n    {\n      uiMsg(UIERROR_SUBHEADERUNKNOWN,FileName);\n      return false;\n    }\n    if (UnpData==NULL)\n      SubDataIO.SetTestMode(true);\n    else\n    {\n      UnpData->Alloc((size_t)SubHead.UnpSize);\n      SubDataIO.SetUnpackToMemory(&(*UnpData)[0],(uint)SubHead.UnpSize);\n    }\n  }\n  if (SubHead.Encrypted)\n    if (Cmd->Password.IsSet())\n      SubDataIO.SetEncryption(false,SubHead.CryptMethod,&Cmd->Password,\n                SubHead.SaltSet ? SubHead.Salt:NULL,SubHead.InitV,\n                SubHead.Lg2Count,SubHead.HashKey,SubHead.PswCheck);\n    else\n      return false;\n  SubDataIO.UnpHash.Init(SubHead.FileHash.Type,1);\n  SubDataIO.SetPackedSizeToRead(SubHead.PackSize);\n  SubDataIO.EnableShowProgress(false);\n  SubDataIO.SetFiles(this,DestFile);\n  SubDataIO.SetTestMode(TestMode);\n  SubDataIO.UnpVolume=SubHead.SplitAfter;\n  SubDataIO.SetSubHeader(&SubHead,NULL);\n  Unpack.SetDestSize(SubHead.UnpSize);\n  if (SubHead.Method==0)\n    CmdExtract::UnstoreFile(SubDataIO,SubHead.UnpSize);\n  else\n    Unpack.DoUnpack(SubHead.UnpVer,false);\n  if (!SubDataIO.UnpHash.Cmp(&SubHead.FileHash,SubHead.UseHashKey ? SubHead.HashKey:NULL))\n  {\n    uiMsg(UIERROR_SUBHEADERDATABROKEN,FileName,SubHead.FileName);\n    ErrHandler.SetErrorCode(RARX_CRC);\n    if (UnpData!=NULL)\n      UnpData->Reset();\n    return false;\n  }\n  return true;\n}", "target": 1}
{"code": "struct nfc_llcp_local *nfc_llcp_local_get(struct nfc_llcp_local *local)\n{\n\tkref_get(&local->ref);\n\treturn local;\n}", "target": 1}
{"code": " struct timespec ns_to_timespec(const s64 nsec)\n {\n \tstruct timespec ts;\n\ts32 rem;\n \tif (!nsec)\n \t\treturn (struct timespec) {0, 0};\n\tts.tv_sec = div_s64_rem(nsec, NSEC_PER_SEC, &rem);\n\tif (unlikely(rem < 0)) {\n\t\tts.tv_sec--;\n\t\trem += NSEC_PER_SEC;\n\t}\n\tts.tv_nsec = rem;\n \treturn ts;\n }", "target": 0}
{"code": "static int get_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)\n{\n\t__u32 __user *uaddr = (__u32 __user *)(unsigned long)reg->addr;\n\tstruct kvm_regs *regs = vcpu_gp_regs(vcpu);\n\tint nr_regs = sizeof(*regs) / sizeof(__u32);\n\tu32 off;\n\toff = core_reg_offset_from_id(reg->id);\n\tif (off >= nr_regs ||\n\t    (off + (KVM_REG_SIZE(reg->id) / sizeof(__u32))) >= nr_regs)\n\t\treturn -ENOENT;\n\tif (validate_core_offset(reg))\n\t\treturn -EINVAL;\n\tif (copy_to_user(uaddr, ((u32 *)regs) + off, KVM_REG_SIZE(reg->id)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 0}
{"code": "int check_directory(struct dir *dir)\n{\n\tint i;\n\tstruct dir_ent *ent;\n\tif(dir->dir_count < 2)\n\t\treturn TRUE;\n\tfor(ent = dir->dirs, i = 0; i < dir->dir_count - 1; ent = ent->next, i++)\n\t\tif(strcmp(ent->name, ent->next->name) >= 0)\n\t\t\treturn FALSE;\n\treturn TRUE;\n}", "target": 0}
{"code": "  bool handleBackslash(signed char& out) {\n    char ch = *p++;\n    switch (ch) {\n      case 0: return false;\n      case '\"': out = ch; return true;\n      case '\\\\': out = ch; return true;\n      case '/': out = ch; return true;\n      case 'b': out = '\\b'; return true;\n      case 'f': out = '\\f'; return true;\n      case 'n': out = '\\n'; return true;\n      case 'r': out = '\\r'; return true;\n      case 't': out = '\\t'; return true;\n      case 'u': {\n        if (UNLIKELY(is_tsimplejson)) {\n          auto const ch1 = *p++;\n          auto const ch2 = *p++;\n          auto const dch3 = dehexchar(*p++);\n          auto const dch4 = dehexchar(*p++);\n          if (UNLIKELY(ch1 != '0' || ch2 != '0' || dch3 < 0 || dch4 < 0)) {\n            return false;\n          }\n          out = (dch3 << 4) | dch4;\n          return true;\n        } else {\n          uint16_t u16cp = 0;\n          for (int i = 0; i < 4; i++) {\n            auto const hexv = dehexchar(*p++);\n            if (hexv < 0) return false; \n            u16cp <<= 4;\n            u16cp |= hexv;\n          }\n          if (u16cp > 0x7f) {\n            return false;\n          } else {\n            out = u16cp;\n            return true;\n          }\n        }\n      }\n      default: return false;\n    }\n  }", "target": 1}
{"code": "static unsigned int seedsize(struct crypto_alg *alg)\n{\n\tstruct rng_alg *ralg = container_of(alg, struct rng_alg, base);\n\treturn alg->cra_rng.rng_make_random ?\n\t       alg->cra_rng.seedsize : ralg->seedsize;\n}", "target": 1}
{"code": "  CdsIntegrationTest()\n      : HttpIntegrationTest(Http::CodecType::HTTP2, ipVersion(),\n                            ConfigHelper::discoveredClustersBootstrap(\n                                sotwOrDelta() == Grpc::SotwOrDelta::Sotw ||\n                                        sotwOrDelta() == Grpc::SotwOrDelta::UnifiedSotw\n                                    ? \"GRPC\"\n                                    : \"DELTA_GRPC\")) {\n    if (sotwOrDelta() == Grpc::SotwOrDelta::UnifiedSotw ||\n        sotwOrDelta() == Grpc::SotwOrDelta::UnifiedDelta) {\n      config_helper_.addRuntimeOverride(\"envoy.reloadable_features.unified_mux\", \"true\");\n    }\n    use_lds_ = false;\n    sotw_or_delta_ = sotwOrDelta();\n  }", "target": 1}
{"code": "int ntlm_read_ntlm_v2_response(wStream* s, NTLMv2_RESPONSE* response)\n{\n\tif (Stream_GetRemainingLength(s) < 16)\n\t\treturn -1;\n\tStream_Read(s, response->Response, 16);\n\treturn ntlm_read_ntlm_v2_client_challenge(s, &(response->Challenge));\n}", "target": 0}
{"code": "int jpc_tsfb_synthesize(jpc_tsfb_t *tsfb, jas_seq2d_t *a)\n{\n\treturn (tsfb->numlvls > 0) ? jpc_tsfb_synthesize2(tsfb,\n\t  jas_seq2d_getref(a, jas_seq2d_xstart(a), jas_seq2d_ystart(a)),\n\t  jas_seq2d_xstart(a), jas_seq2d_ystart(a), jas_seq2d_width(a),\n\t  jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;\n}", "target": 1}
{"code": "void fput(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tfile_sb_list_del(file);\n\t\tif (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {\n\t\t\tinit_task_work(&file->f_u.fu_rcuhead, ____fput);\n\t\t\tif (!task_work_add(task, &file->f_u.fu_rcuhead, true))\n\t\t\t\treturn;\n\t\t}\n\t\tif (llist_add(&file->f_u.fu_llist, &delayed_fput_list))\n\t\t\tschedule_work(&delayed_fput_work);\n\t}\n}", "target": 1}
{"code": "rdr_notification_ctx_init(struct rdr_notification_ctx *ctx)\n{\n\tdeltas_parsed_init(&ctx->deltas);\n\treturn 0;\n}", "target": 1}
{"code": "static pyc_object *get_list_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\tn = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (list size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic (buffer, n);\n\tif (ret) {\n\t\tret->type = TYPE_LIST;\n\t\treturn ret;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "mark_trusted_task_done (GObject      *source_object,\n                        GAsyncResult *res,\n                        gpointer      user_data)\n{\n    MarkTrustedJob *job = user_data;\n    g_object_unref (job->file);\n    if (job->done_callback)\n    {\n        job->done_callback (!job_aborted ((CommonJob *) job),\n                            job->done_callback_data);\n    }\n    finalize_common ((CommonJob *) job);\n}", "target": 1}
{"code": "static int ntlm_decode_field(struct wire_field_hdr *hdr,\n                             struct ntlm_buffer *buffer,\n                             size_t payload_offs,\n                             struct ntlm_buffer *field)\n{\n    struct ntlm_buffer b = { NULL, 0 };\n    uint32_t offs;\n    uint16_t len;\n    len = le16toh(hdr->len);\n    if (len == 0) goto done;\n    offs = le32toh(hdr->offset);\n    if ((offs < payload_offs) ||\n        (offs > buffer->length) ||\n        (UINT32_MAX - offs < len) ||\n        (offs + len > buffer->length)) {\n        return ERR_DECODE;\n    }\n    b.data = malloc(len);\n    if (!b.data) return ENOMEM;\n    b.length = len;\n    memcpy(b.data, &buffer->data[offs], b.length);\ndone:\n    *field = b;\n    return 0;\n}", "target": 0}
{"code": "int copy_creds(struct task_struct *p, unsigned long clone_flags)\n{\n#ifdef CONFIG_KEYS\n\tstruct thread_group_cred *tgcred;\n#endif\n\tstruct cred *new;\n\tint ret;\n\tp->replacement_session_keyring = NULL;\n\tif (\n#ifdef CONFIG_KEYS\n\t\t!p->cred->thread_keyring &&\n#endif\n\t\tclone_flags & CLONE_THREAD\n\t    ) {\n\t\tp->real_cred = get_cred(p->cred);\n\t\tget_cred(p->cred);\n\t\talter_cred_subscribers(p->cred, 2);\n\t\tkdebug(\"share_creds(%p{%d,%d})\",\n\t\t       p->cred, atomic_read(&p->cred->usage),\n\t\t       read_cred_subscribers(p->cred));\n\t\tatomic_inc(&p->cred->user->processes);\n\t\treturn 0;\n\t}\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tif (clone_flags & CLONE_NEWUSER) {\n\t\tret = create_user_ns(new);\n\t\tif (ret < 0)\n\t\t\tgoto error_put;\n\t}\n\tnew->user_ns = new->user->user_ns;\n#ifdef CONFIG_KEYS\n\tif (new->thread_keyring) {\n\t\tkey_put(new->thread_keyring);\n\t\tnew->thread_keyring = NULL;\n\t\tif (clone_flags & CLONE_THREAD)\n\t\t\tinstall_thread_keyring_to_cred(new);\n\t}\n\tif (!(clone_flags & CLONE_THREAD)) {\n\t\ttgcred = kmalloc(sizeof(*tgcred), GFP_KERNEL);\n\t\tif (!tgcred) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error_put;\n\t\t}\n\t\tatomic_set(&tgcred->usage, 1);\n\t\tspin_lock_init(&tgcred->lock);\n\t\ttgcred->process_keyring = NULL;\n\t\ttgcred->session_keyring = key_get(new->tgcred->session_keyring);\n\t\trelease_tgcred(new);\n\t\tnew->tgcred = tgcred;\n\t}\n#endif\n\tatomic_inc(&new->user->processes);\n\tp->cred = p->real_cred = get_cred(new);\n\talter_cred_subscribers(new, 2);\n\tvalidate_creds(new);\n\treturn 0;\nerror_put:\n\tput_cred(new);\n\treturn ret;\n}", "target": 0}
{"code": "static int adpt_i2o_online_hba(adpt_hba* pHba)\n{\n\tif (adpt_i2o_systab_send(pHba) < 0)\n\t\treturn -1;\n\tif (adpt_i2o_enable_hba(pHba) < 0)\n\t\treturn -1;\n\treturn 0;\n}", "target": 1}
{"code": "juniper_services_print(netdissect_options *ndo,\n                       const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        struct juniper_services_header {\n            uint8_t svc_id;\n            uint8_t flags_len;\n            uint8_t svc_set_id[2];\n            uint8_t dir_iif[4];\n        };\n        const struct juniper_services_header *sh;\n        l2info.pictype = DLT_JUNIPER_SERVICES;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        sh = (const struct juniper_services_header *)p;\n        ND_TCHECK(*sh);\n        if (ndo->ndo_eflag)\n            ND_PRINT((ndo, \"service-id %u flags 0x%02x service-set-id 0x%04x iif %u: \",\n                   sh->svc_id,\n                   sh->flags_len,\n                   EXTRACT_16BITS(&sh->svc_set_id),\n                   EXTRACT_24BITS(&sh->dir_iif[1])));\n        ip_heuristic_guess (ndo, p, l2info.length);\n        return l2info.header_len;\ntrunc:\n\tND_PRINT((ndo, \"[|juniper_services]\"));\n\treturn l2info.header_len;\n}", "target": 0}
{"code": "Status SparseTensorFromContext(OpKernelContext* ctx, const int32_t base_index,\n                               const bool validate_indices,\n                               sparse::SparseTensor* tensor) {\n  TensorShape shape;\n  TF_RETURN_IF_ERROR(TensorShape::BuildTensorShape(\n      ctx->input(base_index + 2).vec<int64_t>(), &shape));\n  CheckRankAtLeast2(ctx, shape);\n  std::vector<int64_t> order(shape.dims());\n  std::iota(order.begin(), order.end(), 0);\n  Status status = sparse::SparseTensor::Create(\n      ctx->input(base_index), ctx->input(base_index + 1), shape, order, tensor);\n  if (!validate_indices || !status.ok()) return status;\n  return tensor->IndicesValid();\n}", "target": 1}
{"code": "try_resolve_op_from_metadata (FlatpakTransaction *self,\n                              FlatpakTransactionOperation *op,\n                              const char *checksum,\n                              GFile *sideload_path,\n                              FlatpakRemoteState *state,\n                              GError **error)\n{\n  g_autoptr(GBytes) metadata_bytes = NULL;\n  guint64 download_size = 0;\n  guint64 installed_size = 0;\n  const char *metadata = NULL;\n  VarMetadataRef sparse_cache;\n  VarRefInfoRef info;\n  g_autofree char *summary_checksum = NULL;\n  if ((state->summary == NULL && state->index == NULL) ||\n      !flatpak_remote_state_lookup_ref (state, flatpak_decomposed_get_ref (op->ref),\n                                        &summary_checksum, NULL, NULL, NULL, NULL) ||\n      strcmp (summary_checksum, checksum) != 0)\n    return FALSE;\n  if (!flatpak_remote_state_lookup_cache (state, flatpak_decomposed_get_ref (op->ref),\n                                          &download_size, &installed_size, &metadata, NULL))\n      return FALSE;\n  metadata_bytes = g_bytes_new (metadata, strlen (metadata));\n  if (flatpak_remote_state_lookup_ref (state, flatpak_decomposed_get_ref (op->ref),\n                                       NULL, NULL, &info, NULL, NULL))\n    op->summary_metadata = var_metadata_dup_to_gvariant (var_ref_info_get_metadata (info));\n  op->installed_size = installed_size;\n  op->download_size = download_size;\n  op->token_type = state->default_token_type;\n  if (flatpak_remote_state_lookup_sparse_cache (state, flatpak_decomposed_get_ref (op->ref), &sparse_cache, NULL))\n    {\n      op->eol = g_strdup (var_metadata_lookup_string (sparse_cache, FLATPAK_SPARSE_CACHE_KEY_ENDOFLINE, NULL));\n      op->eol_rebase = g_strdup (var_metadata_lookup_string (sparse_cache, FLATPAK_SPARSE_CACHE_KEY_ENDOFLINE_REBASE, NULL));\n      op->token_type = GINT32_FROM_LE (var_metadata_lookup_int32 (sparse_cache, FLATPAK_SPARSE_CACHE_KEY_TOKEN_TYPE, op->token_type));\n    }\n  return resolve_op_end (self, op, checksum, sideload_path, metadata_bytes, error);\n}", "target": 0}
{"code": "static void disk_seqf_stop(struct seq_file *seqf, void *v)\n{\n\tstruct class_dev_iter *iter = seqf->private;\n\tif (iter) {\n\t\tclass_dev_iter_exit(iter);\n\t\tkfree(iter);\n\t\tseqf->private = NULL;\n\t}\n}", "target": 0}
{"code": "skipString(const xmlChar *cur, int end) {\n    xmlChar limit;\n    if ((cur == NULL) || (end < 0)) return(-1);\n    if ((cur[end] == '\\'') || (cur[end] == '\"')) limit = cur[end];\n    else return(end);\n    end++;\n    while (cur[end] != 0) {\n        if (cur[end] == limit)\n\t    return(end + 1);\n\tend++;\n    }\n    return(-1);\n}", "target": 0}
{"code": "static KeyInfo *multiSelectOrderByKeyInfo(Parse *pParse, Select *p, int nExtra){\n  ExprList *pOrderBy = p->pOrderBy;\n  int nOrderBy = p->pOrderBy->nExpr;\n  sqlite3 *db = pParse->db;\n  KeyInfo *pRet = sqlite3KeyInfoAlloc(db, nOrderBy+nExtra, 1);\n  if( pRet ){\n    int i;\n    for(i=0; i<nOrderBy; i++){\n      struct ExprList_item *pItem = &pOrderBy->a[i];\n      Expr *pTerm = pItem->pExpr;\n      CollSeq *pColl;\n      if( pTerm->flags & EP_Collate ){\n        pColl = sqlite3ExprCollSeq(pParse, pTerm);\n      }else{\n        pColl = multiSelectCollSeq(pParse, p, pItem->u.x.iOrderByCol-1);\n        if( pColl==0 ) pColl = db->pDfltColl;\n        pOrderBy->a[i].pExpr =\n          sqlite3ExprAddCollateString(pParse, pTerm, pColl->zName);\n      }\n      assert( sqlite3KeyInfoIsWriteable(pRet) );\n      pRet->aColl[i] = pColl;\n      pRet->aSortFlags[i] = pOrderBy->a[i].sortFlags;\n    }\n  }\n  return pRet;\n}", "target": 0}
{"code": "static TEE_Result do_alloc_publickey(struct ecc_public_key *s, uint32_t type,\n\t\t\t\t     size_t size_bits __unused)\n{\n\tif (type != TEE_TYPE_ECDSA_PUBLIC_KEY &&\n\t    type != TEE_TYPE_ECDH_PUBLIC_KEY)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->x))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->x);\n\tcrypto_bignum_free(s->y);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "int mp_pack(lua_State *L) {\n    int nargs = lua_gettop(L);\n    int i;\n    mp_buf *buf;\n    if (nargs == 0)\n        return luaL_argerror(L, 0, \"MessagePack pack needs input.\");\n    if (!lua_checkstack(L, nargs))\n        return luaL_argerror(L, 0, \"Too many arguments for MessagePack pack.\");\n    buf = mp_buf_new(L);\n    for(i = 1; i <= nargs; i++) {\n        lua_pushvalue(L, i);\n        mp_encode_lua_type(L,buf,0);\n        lua_pushlstring(L,(char*)buf->b,buf->len);\n        buf->free += buf->len;\n        buf->len = 0;\n    }\n    mp_buf_free(L, buf);\n    lua_concat(L, nargs);\n    return 1;\n}", "target": 0}
{"code": "TfLiteStatus CalculateOpData(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteDepthToSpaceParams*>(node->builtin_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n  auto data_type = output->type;\n  TF_LITE_ENSURE(context,\n                 data_type == kTfLiteFloat32 || data_type == kTfLiteInt8);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  const int block_size = params->block_size;\n  TF_LITE_ENSURE(context, block_size > 0);\n  const int input_height = input->dims->data[kHeightRank];\n  const int input_width = input->dims->data[kWidthRank];\n  const int input_channels = input->dims->data[kDepthRank];\n  int output_height = input_height * block_size;\n  int output_width = input_width * block_size;\n  int output_channels = input_channels / block_size / block_size;\n  TF_LITE_ENSURE_EQ(context, input_height, output_height / block_size);\n  TF_LITE_ENSURE_EQ(context, input_width, output_width / block_size);\n  TF_LITE_ENSURE_EQ(context, input_channels,\n                    output_channels * block_size * block_size);\n  TfLiteEvalTensor* output_eval =\n      tflite::micro::GetEvalOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE_OK(context, tflite::micro::CreateWritableTensorDimsWithCopy(\n                                 context, output, output_eval));\n  output->dims->data[kBatchRank] = input->dims->data[kBatchRank];\n  output->dims->data[kHeightRank] = output_height;\n  output->dims->data[kWidthRank] = output_width;\n  output->dims->data[kDepthRank] = output_channels;\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static int string_check(char *buf, const char *buf2)\n{\n  if(strcmp(buf, buf2)) {\n    printf(\"sprintf failed:\\nwe '%s'\\nsystem: '%s'\\n\",\n           buf, buf2);\n    return 1;\n  }\n  return 0;\n}", "target": 1}
{"code": "void __kvm_migrate_pit_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pit *pit = vcpu->kvm->arch.vpit;\n\tstruct hrtimer *timer;\n\tif (!kvm_vcpu_is_bsp(vcpu) || !pit)\n\t\treturn;\n\ttimer = &pit->pit_state.timer;\n\tmutex_lock(&pit->pit_state.lock);\n\tif (hrtimer_cancel(timer))\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS);\n\tmutex_unlock(&pit->pit_state.lock);\n}", "target": 0}
{"code": "void WasmBinaryBuilder::read() {\n  if (DWARF) {\n    if (!hasDWARFSections()) {\n      DWARF = false;\n    }\n  }\n  readHeader();\n  readSourceMapHeader();\n  while (more()) {\n    uint8_t sectionCode = getInt8();\n    uint32_t payloadLen = getU32LEB();\n    if (uint64_t(pos) + uint64_t(payloadLen) > input.size()) {\n      throwError(\"Section extends beyond end of input\");\n    }\n    auto oldPos = pos;\n    if (sectionCode != BinaryConsts::Section::User &&\n        sectionCode != BinaryConsts::Section::Code) {\n      if (!seenSections.insert(BinaryConsts::Section(sectionCode)).second) {\n        throwError(\"section seen more than once: \" +\n                   std::to_string(sectionCode));\n      }\n    }\n    switch (sectionCode) {\n      case BinaryConsts::Section::Start:\n        readStart();\n        break;\n      case BinaryConsts::Section::Memory:\n        readMemory();\n        break;\n      case BinaryConsts::Section::Type:\n        readTypes();\n        break;\n      case BinaryConsts::Section::Import:\n        readImports();\n        break;\n      case BinaryConsts::Section::Function:\n        readFunctionSignatures();\n        break;\n      case BinaryConsts::Section::Code:\n        if (DWARF) {\n          codeSectionLocation = pos;\n        }\n        readFunctions();\n        break;\n      case BinaryConsts::Section::Export:\n        readExports();\n        break;\n      case BinaryConsts::Section::Element:\n        readElementSegments();\n        break;\n      case BinaryConsts::Section::Global:\n        readGlobals();\n        break;\n      case BinaryConsts::Section::Data:\n        readDataSegments();\n        break;\n      case BinaryConsts::Section::DataCount:\n        readDataCount();\n        break;\n      case BinaryConsts::Section::Table:\n        readTableDeclarations();\n        break;\n      case BinaryConsts::Section::Tag:\n        readTags();\n        break;\n      default: {\n        readUserSection(payloadLen);\n        if (pos > oldPos + payloadLen) {\n          throwError(\"bad user section size, started at \" +\n                     std::to_string(oldPos) + \" plus payload \" +\n                     std::to_string(payloadLen) +\n                     \" not being equal to new position \" + std::to_string(pos));\n        }\n        pos = oldPos + payloadLen;\n      }\n    }\n    if (pos != oldPos + payloadLen) {\n      throwError(\"bad section size, started at \" + std::to_string(oldPos) +\n                 \" plus payload \" + std::to_string(payloadLen) +\n                 \" not being equal to new position \" + std::to_string(pos));\n    }\n  }\n  validateBinary();\n  processNames();\n}", "target": 0}
{"code": "void LibRaw::read_shorts(ushort *pixel, unsigned count)\n{\n  if (fread(pixel, 2, count, ifp) < count)\n    derror();\n  if ((order == 0x4949) == (ntohs(0x1234) == 0x1234))\n    swab((char *)pixel, (char *)pixel, count * 2);\n}", "target": 0}
{"code": "static inline void sctp_copy_descendant(struct sock *sk_to,\n\t\t\t\t\tconst struct sock *sk_from)\n{\n\tint ancestor_size = sizeof(struct inet_sock) +\n\t\t\t    sizeof(struct sctp_sock) -\n\t\t\t    offsetof(struct sctp_sock, auto_asconf_list);\n\tif (sk_from->sk_family == PF_INET6)\n\t\tancestor_size += sizeof(struct ipv6_pinfo);\n\t__inet_sk_copy_descendant(sk_to, sk_from, ancestor_size);\n}", "target": 0}
{"code": "coolkey_add_object(coolkey_private_data_t *priv, unsigned long object_id, const u8 *object_data, size_t object_length, int add_v1_record)\n{\n\tsc_cardctl_coolkey_object_t new_object;\n\tint r;\n\tmemset(&new_object, 0, sizeof(new_object));\n\tnew_object.path = coolkey_template_path;\n\tnew_object.path.len = 4;\n\tulong2bebytes(new_object.path.value, object_id);\n\tnew_object.id = object_id;\n\tnew_object.length = object_length;\n\tif (coolkey_find_object_by_id(&priv->objects_list, object_id) != NULL) {\n\t\treturn SC_ERROR_INTERNAL;\n\t}\n\tif (object_data) {\n\t\tnew_object.data = malloc(object_length + add_v1_record);\n\t\tif (new_object.data == NULL) {\n\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\t}\n\t\tif (add_v1_record) {\n\t\t\tnew_object.data[0] = COOLKEY_V1_OBJECT;\n\t\t\tnew_object.length++;\n\t\t}\n\t\tmemcpy(&new_object.data[add_v1_record], object_data, object_length);\n\t}\n\tr = coolkey_add_object_to_list(&priv->objects_list, &new_object);\n\tif (r != SC_SUCCESS) {\n\t\tfree(new_object.data);\n\t\tnew_object.data = NULL;\n\t}\n\treturn r;\n}", "target": 0}
{"code": "void ConnectionImpl::onHeaderValue(const char* data, size_t length) {\n  if (header_parsing_state_ == HeaderParsingState::Done) {\n    return;\n  }\n  const absl::string_view header_value = absl::string_view(data, length);\n  if (strict_header_validation_) {\n    if (!Http::HeaderUtility::headerIsValid(header_value)) {\n      ENVOY_CONN_LOG(debug, \"invalid header value: {}\", connection_, header_value);\n      error_code_ = Http::Code::BadRequest;\n      sendProtocolError();\n      throw CodecProtocolException(\"http/1.1 protocol error: header value contains invalid chars\");\n    }\n  } else if (header_value.find('\\0') != absl::string_view::npos) {\n    throw CodecProtocolException(\"http/1.1 protocol error: header value contains NUL\");\n  }\n  header_parsing_state_ = HeaderParsingState::Value;\n  current_header_value_.append(data, length);\n  const uint32_t total =\n      current_header_field_.size() + current_header_value_.size() + current_header_map_->byteSize();\n  if (total > (max_request_headers_kb_ * 1024)) {\n    error_code_ = Http::Code::RequestHeaderFieldsTooLarge;\n    sendProtocolError();\n    throw CodecProtocolException(\"headers size exceeds limit\");\n  }\n}", "target": 1}
{"code": "void dns_server_init(struct netif * pnetif)\n{\n\tuint8_t *ip;\n\tif (dns_server_pcb != NULL) {\n\t\tudp_remove(dns_server_pcb);\n\t\tdns_server_pcb = NULL;\n\t}\n\tdns_server_pcb = udp_new();\n\tif (dns_server_pcb == NULL) {\n\t\tprintf(\"\\n\\r Error!!!upd_new error \\n\\r\");\n\t\treturn;\n\t}\n\tudp_bind(dns_server_pcb, IP_ADDR_ANY, DNS_SERVER_PORT);\n\tudp_recv(dns_server_pcb, dnss_receive_udp_packet_handler, NULL);\n}", "target": 0}
{"code": "static const char *describe_object(struct fsck_options *o, struct object *obj)\n{\n\tstatic struct strbuf buf = STRBUF_INIT;\n\tchar *name;\n\tstrbuf_reset(&buf);\n\tstrbuf_addstr(&buf, oid_to_hex(&obj->oid));\n\tif (o->object_names && (name = lookup_decoration(o->object_names, obj)))\n\t\tstrbuf_addf(&buf, \" (%s)\", name);\n\treturn buf.buf;\n}", "target": 0}
{"code": "PixarLogSetupDecode(TIFF* tif)\n{\n\tstatic const char module[] = \"PixarLogSetupDecode\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tPixarLogState* sp = DecoderState(tif);\n\ttmsize_t tbuf_size;\n\tassert(sp != NULL);\n\ttif->tif_postdecode = _TIFFNoPostDecode;  \n\tsp->stride = (td->td_planarconfig == PLANARCONFIG_CONTIG ?\n\t    td->td_samplesperpixel : 1);\n\ttbuf_size = multiply_ms(multiply_ms(multiply_ms(sp->stride, td->td_imagewidth),\n\t\t\t\t      td->td_rowsperstrip), sizeof(uint16));\n\ttbuf_size = add_ms(tbuf_size, sizeof(uint16) * sp->stride);\n\tif (tbuf_size == 0)\n\t\treturn (0);   \n\tsp->tbuf = (uint16 *) _TIFFmalloc(tbuf_size);\n\tif (sp->tbuf == NULL)\n\t\treturn (0);\n\tsp->tbuf_size = tbuf_size;\n\tif (sp->user_datafmt == PIXARLOGDATAFMT_UNKNOWN)\n\t\tsp->user_datafmt = PixarLogGuessDataFmt(td);\n\tif (sp->user_datafmt == PIXARLOGDATAFMT_UNKNOWN) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\"PixarLog compression can't handle bits depth/data format combination (depth: %d)\", \n\t\t\ttd->td_bitspersample);\n\t\treturn (0);\n\t}\n\tif (inflateInit(&sp->stream) != Z_OK) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"%s\", sp->stream.msg ? sp->stream.msg : \"(null)\");\n\t\treturn (0);\n\t} else {\n\t\tsp->state |= PLSTATE_INIT;\n\t\treturn (1);\n\t}\n}", "target": 0}
{"code": "static int __init personal_server_map_irq(const struct pci_dev *dev, u8 slot,\n\tu8 pin)\n{\n\tunsigned char line;\n\tpci_read_config_byte(dev, PCI_INTERRUPT_LINE, &line);\n\tif (line > 0x40 && line <= 0x5f) {\n\t\treturn irqmap_personal_server[(line & 0x1f) - 8];\n\t} else if (line == 0) {\n\t\treturn 0;\n\t} else\n\t\treturn irqmap_personal_server[(line - 1) & 3];\n}", "target": 1}
{"code": "gss_pseudo_random (OM_uint32 *minor_status,\n\t           gss_ctx_id_t context_handle,\n\t           int prf_key,\n\t           const gss_buffer_t prf_in,\n\t           ssize_t desired_output_len,\n\t           gss_buffer_t prf_out)\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    if (minor_status == NULL)\n\treturn GSS_S_CALL_INACCESSIBLE_WRITE;\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT;\n    if (prf_in == GSS_C_NO_BUFFER)\n\treturn GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT;\n    if (prf_out == GSS_C_NO_BUFFER)\n\treturn GSS_S_CALL_INACCESSIBLE_WRITE | GSS_S_NO_CONTEXT;\n    prf_out->length = 0;\n    prf_out->value = NULL;\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech != NULL) {\n\tif (mech->gss_pseudo_random != NULL) {\n\t    status = mech->gss_pseudo_random(minor_status,\n\t\t\t\t\t     ctx->internal_ctx_id,\n\t\t\t\t\t     prf_key,\n\t\t\t\t\t     prf_in,\n\t\t\t\t\t     desired_output_len,\n\t\t\t\t\t     prf_out);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\treturn status;\n    }\n    return GSS_S_BAD_MECH;\n}", "target": 0}
{"code": "gopherMimeCreate(GopherStateData * gopherState)\n{\n    StoreEntry *entry = gopherState->entry;\n    const char *mime_type = nullptr;\n    const char *mime_enc = nullptr;\n    switch (gopherState->type_id) {\n    case GOPHER_DIRECTORY:\n    case GOPHER_INDEX:\n    case GOPHER_HTML:\n    case GOPHER_WWW:\n    case GOPHER_CSO:\n        mime_type = \"text/html\";\n        break;\n    case GOPHER_GIF:\n    case GOPHER_IMAGE:\n    case GOPHER_PLUS_IMAGE:\n        mime_type = \"image/gif\";\n        break;\n    case GOPHER_SOUND:\n    case GOPHER_PLUS_SOUND:\n        mime_type = \"audio/basic\";\n        break;\n    case GOPHER_PLUS_MOVIE:\n        mime_type = \"video/mpeg\";\n        break;\n    case GOPHER_MACBINHEX:\n    case GOPHER_DOSBIN:\n    case GOPHER_UUENCODED:\n    case GOPHER_BIN:\n        mime_enc = mimeGetContentEncoding(gopherState->request);\n        mime_type = mimeGetContentType(gopherState->request);\n        if (!mime_type)\n            mime_type = def_gopher_bin;\n        break;\n    case GOPHER_FILE:\n    default:\n        mime_enc = mimeGetContentEncoding(gopherState->request);\n        mime_type = mimeGetContentType(gopherState->request);\n        if (!mime_type)\n            mime_type = def_gopher_text;\n        break;\n    }\n    assert(entry->isEmpty());\n    HttpReply *reply = new HttpReply;\n    entry->buffer();\n    reply->setHeaders(Http::scOkay, \"Gatewaying\", mime_type, -1, -1, -2);\n    if (mime_enc)\n        reply->header.putStr(Http::HdrType::CONTENT_ENCODING, mime_enc);\n    entry->replaceHttpReply(reply);\n    gopherState->reply_ = reply;\n}", "target": 1}
{"code": "static void php_ifd_set32u(char *data, size_t value, int motorola_intel)\n{\n\tif (motorola_intel) {\n\t\tdata[0] = (value & 0xFF000000) >> 24;\n\t\tdata[1] = (value & 0x00FF0000) >> 16;\n\t\tdata[2] = (value & 0x0000FF00) >>  8;\n\t\tdata[3] = (value & 0x000000FF);\n\t} else {\n\t\tdata[3] = (value & 0xFF000000) >> 24;\n\t\tdata[2] = (value & 0x00FF0000) >> 16;\n\t\tdata[1] = (value & 0x0000FF00) >>  8;\n\t\tdata[0] = (value & 0x000000FF);\n\t}\n}", "target": 0}
{"code": "void Triangle(double x1,double y1,double x2,double y2,double x3,double y3) {\n    outpos +=\n    sprintf(outpos,\"\\n %12.3f %12.3f m %12.3f %12.3f l %12.3f %12.3f l h\",x1,y1,x2,y2,x3,y3);\n}", "target": 1}
{"code": "gopherCachable(const HttpRequest * req)\n{\n    int cachable = 1;\n    char type_id;\n    gopher_request_parse(req,\n                         &type_id,\n                         nullptr);\n    switch (type_id) {\n    case GOPHER_INDEX:\n    case GOPHER_CSO:\n    case GOPHER_TELNET:\n    case GOPHER_3270:\n        cachable = 0;\n        break;\n    default:\n        cachable = 1;\n    }\n    return cachable;\n}", "target": 1}
{"code": "merged_1v_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                   JDIMENSION *in_row_group_ctr,\n                   JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf,\n                   JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr,\n                         output_buf + *out_row_ctr);\n  (*out_row_ctr)++;\n  (*in_row_group_ctr)++;\n}", "target": 1}
{"code": "static int sd_ioctl(struct block_device *bdev, fmode_t mode,\n\t\t    unsigned int cmd, unsigned long arg)\n{\n\tstruct gendisk *disk = bdev->bd_disk;\n\tstruct scsi_disk *sdkp = scsi_disk(disk);\n\tstruct scsi_device *sdp = sdkp->device;\n\tvoid __user *p = (void __user *)arg;\n\tint error;\n\tSCSI_LOG_IOCTL(1, sd_printk(KERN_INFO, sdkp, \"sd_ioctl: disk=%s, \"\n\t\t\t\t    \"cmd=0x%x\\n\", disk->disk_name, cmd));\n\terror = scsi_verify_blk_ioctl(bdev, cmd);\n\tif (error < 0)\n\t\treturn error;\n\terror = scsi_nonblockable_ioctl(sdp, cmd, p,\n\t\t\t\t\t(mode & FMODE_NDELAY) != 0);\n\tif (!scsi_block_when_processing_errors(sdp) || !error)\n\t\tgoto out;\n\tswitch (cmd) {\n\t\tcase SCSI_IOCTL_GET_IDLUN:\n\t\tcase SCSI_IOCTL_GET_BUS_NUMBER:\n\t\t\terror = scsi_ioctl(sdp, cmd, p);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = scsi_cmd_blk_ioctl(bdev, mode, cmd, p);\n\t\t\tif (error != -ENOTTY)\n\t\t\t\tbreak;\n\t\t\terror = scsi_ioctl(sdp, cmd, p);\n\t\t\tbreak;\n\t}\nout:\n\treturn error;\n}", "target": 0}
{"code": "sf_open_fd\t(int fd, int mode, SF_INFO *sfinfo, int close_desc)\n{\tSF_PRIVATE \t*psf ;\n\tif ((SF_CONTAINER (sfinfo->format)) == SF_FORMAT_SD2)\n\t{\tsf_errno = SFE_SD2_FD_DISALLOWED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\tpsf_init_files (psf) ;\n\tcopy_filename (psf, \"\") ;\n\tpsf->file.mode = mode ;\n\tpsf_set_file (psf, fd) ;\n\tpsf->is_pipe = psf_is_pipe (psf) ;\n\tpsf->fileoffset = psf_ftell (psf) ;\n\tif (! close_desc)\n\t\tpsf->file.do_not_close_descriptor = SF_TRUE ;\n\treturn psf_open_file (psf, sfinfo) ;\n} ", "target": 1}
{"code": "static int kvaser_usb_leaf_set_opt_mode(const struct kvaser_usb_net_priv *priv)\n{\n\tstruct kvaser_cmd *cmd;\n\tint rc;\n\tcmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\tcmd->id = CMD_SET_CTRL_MODE;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_ctrl_mode);\n\tcmd->u.ctrl_mode.tid = 0xff;\n\tcmd->u.ctrl_mode.channel = priv->channel;\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\tcmd->u.ctrl_mode.ctrl_mode = KVASER_CTRL_MODE_SILENT;\n\telse\n\t\tcmd->u.ctrl_mode.ctrl_mode = KVASER_CTRL_MODE_NORMAL;\n\trc = kvaser_usb_send_cmd(priv->dev, cmd, cmd->len);\n\tkfree(cmd);\n\treturn rc;\n}", "target": 1}
{"code": "Status BuildXlaCompilationCache(DeviceBase* device, FunctionLibraryRuntime* flr,\n                                const XlaPlatformInfo& platform_info,\n                                XlaCompilationCache** cache) {\n  if (platform_info.xla_device_metadata()) {\n    *cache = new XlaCompilationCache(\n        platform_info.xla_device_metadata()->client(),\n        platform_info.xla_device_metadata()->jit_device_type());\n    return Status::OK();\n  }\n  auto platform =\n      se::MultiPlatformManager::PlatformWithId(platform_info.platform_id());\n  if (!platform.ok()) {\n    return platform.status();\n  }\n  StatusOr<xla::Compiler*> compiler_for_platform =\n      xla::Compiler::GetForPlatform(platform.ValueOrDie());\n  if (!compiler_for_platform.ok()) {\n    const Status& status = compiler_for_platform.status();\n    if (status.code() == error::NOT_FOUND) {\n      return errors::Unimplemented(\"Could not find compiler for platform \",\n                                   platform.ValueOrDie()->Name(), \": \",\n                                   status.ToString());\n    }\n  }\n  xla::LocalClientOptions client_options;\n  client_options.set_platform(platform.ValueOrDie());\n  client_options.set_intra_op_parallelism_threads(\n      device->tensorflow_cpu_worker_threads()->num_threads);\n  string allowed_gpus =\n      flr->config_proto()->gpu_options().visible_device_list();\n  TF_ASSIGN_OR_RETURN(absl::optional<std::set<int>> gpu_ids,\n                      ParseVisibleDeviceList(allowed_gpus));\n  client_options.set_allowed_devices(gpu_ids);\n  auto client = xla::ClientLibrary::GetOrCreateLocalClient(client_options);\n  if (!client.ok()) {\n    return client.status();\n  }\n  const XlaOpRegistry::DeviceRegistration* registration;\n  if (!XlaOpRegistry::GetCompilationDevice(platform_info.device_type().type(),\n                                           &registration)) {\n    return errors::InvalidArgument(\"No JIT device registered for \",\n                                   platform_info.device_type().type());\n  }\n  *cache = new XlaCompilationCache(\n      client.ValueOrDie(), DeviceType(registration->compilation_device_name));\n  return Status::OK();\n}", "target": 1}
{"code": "static int __init fm10k_init_module(void)\n{\n\tpr_info(\"%s - version %s\\n\", fm10k_driver_string, fm10k_driver_version);\n\tpr_info(\"%s\\n\", fm10k_copyright);\n\tfm10k_workqueue = alloc_workqueue(\"%s\", WQ_MEM_RECLAIM, 0,\n\t\t\t\t\t  fm10k_driver_name);\n\tif (!fm10k_workqueue)\n\t\treturn -ENOMEM;\n\tfm10k_dbg_init();\n\treturn fm10k_register_pci_driver();\n}", "target": 0}
{"code": "dup_list_from_ptrarray (GPtrArray *p)\n{\n  GList *ret;\n  guint n;\n  ret = NULL;\n  for (n = 0; n < p->len; n++)\n    ret = g_list_prepend (ret, g_strdup (((gchar **) p->pdata)[n]));\n  return ret;\n}", "target": 0}
{"code": "hash_new_from_regs(mrb_state *mrb, mrb_int argc, mrb_int idx)\n{\n  mrb_value hash = mrb_hash_new_capa(mrb, argc);\n  while (argc--) {\n    mrb_hash_set(mrb, hash, regs[idx+0], regs[idx+1]);\n    idx += 2;\n  }\n  return hash;\n}", "target": 0}
{"code": "static uint16_t nvme_get_mgmt_zone_slba_idx(NvmeNamespace *ns, NvmeCmd *c,\n                                            uint64_t *slba, uint32_t *zone_idx)\n{\n    uint32_t dw10 = le32_to_cpu(c->cdw10);\n    uint32_t dw11 = le32_to_cpu(c->cdw11);\n    if (!ns->params.zoned) {\n        trace_pci_nvme_err_invalid_opc(c->opcode);\n        return NVME_INVALID_OPCODE | NVME_DNR;\n    }\n    *slba = ((uint64_t)dw11) << 32 | dw10;\n    if (unlikely(*slba >= ns->id_ns.nsze)) {\n        trace_pci_nvme_err_invalid_lba_range(*slba, 0, ns->id_ns.nsze);\n        *slba = 0;\n        return NVME_LBA_RANGE | NVME_DNR;\n    }\n    *zone_idx = nvme_zone_idx(ns, *slba);\n    assert(*zone_idx < ns->num_zones);\n    return NVME_SUCCESS;\n}", "target": 0}
{"code": "pci_lintr_request(struct pci_vdev *dev)\n{\n\tstruct businfo *bi;\n\tstruct slotinfo *si;\n\tint bestpin, bestcount, pin;\n\tbi = pci_businfo[dev->bus];\n\tassert(bi != NULL);\n\tsi = &bi->slotinfo[dev->slot];\n\tbestpin = 0;\n\tbestcount = si->si_intpins[0].ii_count;\n\tfor (pin = 1; pin < 4; pin++) {\n\t\tif (si->si_intpins[pin].ii_count < bestcount) {\n\t\t\tbestpin = pin;\n\t\t\tbestcount = si->si_intpins[pin].ii_count;\n\t\t}\n\t}\n\tsi->si_intpins[bestpin].ii_count++;\n\tdev->lintr.pin = bestpin + 1;\n\tpci_set_cfgdata8(dev, PCIR_INTPIN, bestpin + 1);\n}", "target": 1}
{"code": "check_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1}
{"code": "void mb2_cache_destroy(struct mb2_cache *cache)\n{\n\tstruct mb2_cache_entry *entry, *next;\n\tunregister_shrinker(&cache->c_shrink);\n\tlist_for_each_entry_safe(entry, next, &cache->c_lru_list, e_lru_list) {\n\t\tif (!hlist_bl_unhashed(&entry->e_hash_list)) {\n\t\t\thlist_bl_del_init(&entry->e_hash_list);\n\t\t\tatomic_dec(&entry->e_refcnt);\n\t\t} else\n\t\t\tWARN_ON(1);\n\t\tlist_del(&entry->e_lru_list);\n\t\tWARN_ON(atomic_read(&entry->e_refcnt) != 1);\n\t\tmb2_cache_entry_put(cache, entry);\n\t}\n\tkfree(cache->c_hash);\n\tkfree(cache);\n\tmodule_put(THIS_MODULE);\n}", "target": 0}
{"code": "static void http_req_handler(struct http_conn *conn,\n\t\t\t     const struct http_msg *msg, void *arg)\n{\n\tstruct mbuf *mb = mbuf_alloc(1024);\n\tint err = 0;\n\t(void)arg;\n\tinfo(\"restsrv: request %r %r%r from %J\\n\",\n\t     &msg->met, &msg->path, &msg->prm,\n\t     http_conn_peer(conn));\n\tif (0 == pl_strcasecmp(&msg->met, \"POST\") &&\n\t    0 == pl_strcasecmp(&msg->path, \"/create\")) {\n\t\thandle_post_create(conn, msg->mb, (size_t)msg->clen);\n\t}\n\telse if (0 == pl_strcasecmp(&msg->met, \"PUT\") &&\n\t\t 0 == pl_strcasecmp(&msg->path, \"/publish\")) {\n\t\thandle_put_publish(conn, msg, msg->mb, (size_t)msg->clen);\n\t}\n\telse if (0 == pl_strcasecmp(&msg->met, \"PUT\") &&\n\t\t 0 == pl_strcasecmp(&msg->path, \"/accept\")) {\n\t\thandle_put_accept(conn, msg, msg->mb, (size_t)msg->clen);\n\t}\n\telse if (0 == pl_strcasecmp(&msg->met, \"GET\") &&\n\t\t 0 == pl_strcasecmp(&msg->path, \"/publish\")) {\n\t\thandle_get_publish(conn, msg, msg->mb, (size_t)msg->clen);\n\t}\n\telse if (0 == pl_strcasecmp(&msg->met, \"GET\") &&\n\t\t 0 == pl_strcasecmp(&msg->path, \"/accept\")) {\n\t\thandle_get_accept(conn, msg, msg->mb, (size_t)msg->clen);\n\t}\n\telse {\n\t\twarning(\"no such resource\\n\");\n\t\terr = ENOENT;\n\t\tgoto out;\n\t}\n out:\n\tif (err) {\n\t\thttp_ereply(conn, 400, \"Bad Request\");\n\t\twarning(\"restsrv: response 400 Bad Request (%m)\\n\", err);\n\t\thttp_conn_close(conn);\n\t}\n\tmem_deref(mb);\n}", "target": 0}
{"code": "static void my_gballoc_free(void* ptr)\n{\n    free(ptr);\n}", "target": 0}
{"code": "xfs_file_splice_write(\n\tstruct pipe_inode_info\t*pipe,\n\tstruct file\t\t*outfilp,\n\tloff_t\t\t\t*ppos,\n\tsize_t\t\t\tcount,\n\tunsigned int\t\tflags)\n{\n\tstruct inode\t\t*inode = outfilp->f_mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tint\t\t\tioflags = 0;\n\tssize_t\t\t\tret;\n\tXFS_STATS_INC(xs_write_calls);\n\tif (outfilp->f_mode & FMODE_NOCMTIME)\n\t\tioflags |= IO_INVIS;\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n\t\treturn -EIO;\n\txfs_ilock(ip, XFS_IOLOCK_EXCL);\n\ttrace_xfs_file_splice_write(ip, count, *ppos, ioflags);\n\tret = generic_file_splice_write(pipe, outfilp, ppos, count, flags);\n\tif (ret > 0)\n\t\tXFS_STATS_ADD(xs_write_bytes, ret);\n\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\treturn ret;\n}", "target": 1}
{"code": "int xt_check_entry_offsets(const void *base,\n\t\t\t   const char *elems,\n\t\t\t   unsigned int target_offset,\n\t\t\t   unsigned int next_offset)\n{\n\tlong size_of_base_struct = elems - (const char *)base;\n\tconst struct xt_entry_target *t;\n\tconst char *e = base;\n\tif (target_offset < size_of_base_struct)\n\t\treturn -EINVAL;\n\tif (target_offset + sizeof(*t) > next_offset)\n\t\treturn -EINVAL;\n\tt = (void *)(e + target_offset);\n\tif (t->u.target_size < sizeof(*t))\n\t\treturn -EINVAL;\n\tif (target_offset + t->u.target_size > next_offset)\n\t\treturn -EINVAL;\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) == 0 &&\n\t    target_offset + sizeof(struct xt_standard_target) != next_offset)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 0}
{"code": "Http::Response AbstractWebApplication::processRequest(const Http::Request &request, const Http::Environment &env)\n{\n    session_ = 0;\n    request_ = request;\n    env_ = env;\n    clear(); \n    sessionInitialize();\n    if (!sessionActive() && !isAuthNeeded())\n        sessionStart();\n    if (isBanned()) {\n        status(403, \"Forbidden\");\n        print(QObject::tr(\"Your IP address has been banned after too many failed authentication attempts.\"), Http::CONTENT_TYPE_TXT);\n    }\n    else {\n        processRequest();\n    }\n    return response();\n}", "target": 1}
{"code": "static void tcp_illinois_info(struct sock *sk, u32 ext,\n\t\t\t      struct sk_buff *skb)\n{\n\tconst struct illinois *ca = inet_csk_ca(sk);\n\tif (ext & (1 << (INET_DIAG_VEGASINFO - 1))) {\n\t\tstruct tcpvegas_info info = {\n\t\t\t.tcpv_enabled = 1,\n\t\t\t.tcpv_rttcnt = ca->cnt_rtt,\n\t\t\t.tcpv_minrtt = ca->base_rtt,\n\t\t};\n\t\tu64 t = ca->sum_rtt;\n\t\tdo_div(t, ca->cnt_rtt);\n\t\tinfo.tcpv_rtt = t;\n\t\tnla_put(skb, INET_DIAG_VEGASINFO, sizeof(info), &info);\n\t}\n}", "target": 1}
{"code": "static inline void tcp_parse_option_mss(struct pico_socket_tcp *t, uint8_t len, uint8_t *opt, uint32_t *idx)\n{\n    uint16_t mss;\n    if (tcpopt_len_check(idx, len, PICO_TCPOPTLEN_MSS) < 0)\n        return;\n    if ((*idx + PICO_TCPOPTLEN_MSS) > len)\n        return;\n    t->mss_ok = 1;\n    mss = short_from(opt + *idx);\n    *idx += (uint32_t)sizeof(uint16_t);\n    if (t->mss > short_be(mss))\n        t->mss = short_be(mss);\n}", "target": 0}
{"code": "static inline void sem_getref(struct sem_array *sma)\n{\n\tspin_lock(&(sma)->sem_perm.lock);\n\tipc_rcu_getref(sma);\n\tipc_unlock(&(sma)->sem_perm);\n}", "target": 1}
{"code": "inline int NumInputs(const TfLiteNode* node) { return node->inputs->size; }", "target": 1}
{"code": "std::string sanitizeNameForWindowList(const std::string& name) {\n    std::string result = name;\n    if (result[0] == '\\\"')\n        result[0] = ' ';\n    for (size_t i = 1; i < result.size(); ++i) {\n        if (result[i - 1] == '>' && result[i] == ']')\n            result[i] = ' ';\n        if (result[i] == '\\\"')\n            result[i] = ' ';\n    }\n    return result;\n}", "target": 1}
{"code": "static inline void txopt_put(struct ipv6_txoptions *opt)\n{\n\tif (opt && atomic_dec_and_test(&opt->refcnt))\n\t\tkfree_rcu(opt, rcu);\n}", "target": 0}
{"code": "  static void  Ins_MDRP( INS_ARG )\n  {\n    Int         point;\n    TT_F26Dot6  distance,\n                org_dist;\n    point = (Int)args[0];\n    if ( BOUNDS( args[0], CUR.zp1.n_points ) )\n    {\n      return;\n    }\n    org_dist = CUR_Func_dualproj( CUR.zp1.org_x[point] -\n                                    CUR.zp0.org_x[CUR.GS.rp0],\n                                  CUR.zp1.org_y[point] -\n                                    CUR.zp0.org_y[CUR.GS.rp0] );\n    if ( ABS(org_dist) < CUR.GS.single_width_cutin )\n    {\n      if ( org_dist >= 0 )\n        org_dist = CUR.GS.single_width_value;\n      else\n        org_dist = -CUR.GS.single_width_value;\n    }\n    if ( (CUR.opcode & 4) != 0 )\n      distance = CUR_Func_round( org_dist,\n                                 CUR.metrics.compensations[CUR.opcode & 3] );\n    else\n      distance = Round_None( EXEC_ARGS\n                             org_dist,\n                             CUR.metrics.compensations[CUR.opcode & 3]  );\n    if ( (CUR.opcode & 8) != 0 )\n    {\n      if ( org_dist >= 0 )\n      {\n        if ( distance < CUR.GS.minimum_distance )\n          distance = CUR.GS.minimum_distance;\n      }\n      else\n      {\n        if ( distance > -CUR.GS.minimum_distance )\n          distance = -CUR.GS.minimum_distance;\n      }\n    }\n    org_dist = CUR_Func_project( CUR.zp1.cur_x[point] -\n                                   CUR.zp0.cur_x[CUR.GS.rp0],\n                                 CUR.zp1.cur_y[point] -\n                                   CUR.zp0.cur_y[CUR.GS.rp0] );\n    CUR_Func_move( &CUR.zp1, point, distance - org_dist );\n    CUR.GS.rp1 = CUR.GS.rp0;\n    CUR.GS.rp2 = point;\n    if ( (CUR.opcode & 16) != 0 )\n      CUR.GS.rp0 = point;\n  }", "target": 0}
{"code": "void rose_start_idletimer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tdel_timer(&rose->idletimer);\n\tif (rose->idle > 0) {\n\t\trose->idletimer.function = rose_idletimer_expiry;\n\t\trose->idletimer.expires  = jiffies + rose->idle;\n\t\tadd_timer(&rose->idletimer);\n\t}\n}", "target": 1}
{"code": "static int http_connect(http_subtransport *t)\n{\n\tint error;\n\tchar *proxy_url;\n\tif (t->connected &&\n\t\thttp_should_keep_alive(&t->parser) &&\n\t\tt->parse_finished)\n\t\treturn 0;\n\tif (t->io) {\n\t\tgit_stream_close(t->io);\n\t\tgit_stream_free(t->io);\n\t\tt->io = NULL;\n\t\tt->connected = 0;\n\t}\n\tif (t->connection_data.use_ssl) {\n\t\terror = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n\t} else {\n#ifdef GIT_CURL\n\t\terror = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n#else\n\t\terror = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);\n#endif\n\t}\n\tif (error < 0)\n\t\treturn error;\n\tGITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, \"git_stream\");\n\tif (git_stream_supports_proxy(t->io) &&\n\t    !git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url)) {\n\t\terror = git_stream_set_proxy(t->io, proxy_url);\n\t\tgit__free(proxy_url);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\terror = git_stream_connect(t->io);\n#if defined(GIT_OPENSSL) || defined(GIT_SECURE_TRANSPORT) || defined(GIT_CURL)\n\tif ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&\n\t    git_stream_is_encrypted(t->io)) {\n\t\tgit_cert *cert;\n\t\tint is_valid;\n\t\tif ((error = git_stream_certificate(&cert, t->io)) < 0)\n\t\t\treturn error;\n\t\tgiterr_clear();\n\t\tis_valid = error != GIT_ECERTIFICATE;\n\t\terror = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);\n\t\tif (error < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, \"user cancelled certificate check\");\n\t\t\treturn error;\n\t\t}\n\t}\n#endif\n\tif (error < 0)\n\t\treturn error;\n\tt->connected = 1;\n\treturn 0;\n}", "target": 1}
{"code": "static inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_esn,\n\t\t\t\t\t struct nlattr *rp)\n{\n\tstruct xfrm_replay_state_esn *up;\n\tint ulen;\n\tif (!replay_esn || !rp)\n\t\treturn 0;\n\tup = nla_data(rp);\n\tulen = xfrm_replay_state_esn_len(up);\n\tif (nla_len(rp) < ulen || xfrm_replay_state_esn_len(replay_esn) != ulen)\n\t\treturn -EINVAL;\n\tif (up->replay_window > up->bmp_len * sizeof(__u32) * 8)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    OpInputList ragged_nested_splits_in;\n    OP_REQUIRES_OK(context, context->input_list(\"rt_nested_splits\",\n                                                &ragged_nested_splits_in));\n    const int ragged_nested_splits_len = ragged_nested_splits_in.size();\n    RaggedTensorVariant batched_ragged_input;\n    batched_ragged_input.set_values(context->input(ragged_nested_splits_len));\n    batched_ragged_input.mutable_nested_splits()->reserve(\n        ragged_nested_splits_len);\n    for (int i = 0; i < ragged_nested_splits_len; i++) {\n      OP_REQUIRES(context, ragged_nested_splits_in[i].dims() == 1,\n                  errors::InvalidArgument(\"Requires nested_row_splits[\", i, \"]\",\n                                          \" to be rank 1 but is rank \",\n                                          ragged_nested_splits_in[i].dims()));\n      batched_ragged_input.append_splits(ragged_nested_splits_in[i]);\n    }\n    if (!batched_input_) {\n      Tensor* encoded_scalar;\n      OP_REQUIRES_OK(context, context->allocate_output(0, TensorShape({}),\n                                                       &encoded_scalar));\n      encoded_scalar->scalar<Variant>()() = std::move(batched_ragged_input);\n      return;\n    }\n    std::vector<RaggedTensorVariant> unbatched_ragged_input;\n    OP_REQUIRES_OK(context, UnbatchRaggedZerothDim<VALUE_TYPE, SPLIT_TYPE>(\n                                batched_ragged_input, &unbatched_ragged_input));\n    Tensor* encoded_vector;\n    int64_t output_size = unbatched_ragged_input.size();\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, TensorShape({output_size}),\n                                            &encoded_vector));\n    auto encoded_vector_t = encoded_vector->vec<Variant>();\n    for (auto i = decltype(output_size){}; i < output_size; i++) {\n      encoded_vector_t(i) = unbatched_ragged_input[i];\n    }\n  }", "target": 0}
{"code": "static int ax25_recvmsg(struct kiocb *iocb, struct socket *sock,\n\tstruct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint copied;\n\tint err = 0;\n\tlock_sock(sk);\n\tif (sk->sk_type == SOCK_SEQPACKET && sk->sk_state != TCP_ESTABLISHED) {\n\t\terr =  -ENOTCONN;\n\t\tgoto out;\n\t}\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tif (skb == NULL)\n\t\tgoto out;\n\tif (!ax25_sk(sk)->pidincl)\n\t\tskb_pull(skb, 1);\t\t\n\tskb_reset_transport_header(skb);\n\tcopied = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (msg->msg_name) {\n\t\tax25_digi digi;\n\t\tax25_address src;\n\t\tconst unsigned char *mac = skb_mac_header(skb);\n\t\tstruct sockaddr_ax25 *sax = msg->msg_name;\n\t\tmemset(sax, 0, sizeof(struct full_sockaddr_ax25));\n\t\tax25_addr_parse(mac + 1, skb->data - mac - 1, &src, NULL,\n\t\t\t\t&digi, NULL, NULL);\n\t\tsax->sax25_family = AF_AX25;\n\t\tsax->sax25_ndigis = digi.ndigi;\n\t\tsax->sax25_call   = src;\n\t\tif (sax->sax25_ndigis != 0) {\n\t\t\tint ct;\n\t\t\tstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)sax;\n\t\t\tfor (ct = 0; ct < digi.ndigi; ct++)\n\t\t\t\tfsa->fsa_digipeater[ct] = digi.calls[ct];\n\t\t}\n\t\tmsg->msg_namelen = sizeof(struct full_sockaddr_ax25);\n\t}\n\tskb_free_datagram(sk, skb);\n\terr = copied;\nout:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "void processInputBuffer(client *c) {\n    server.current_client = c;\n    while(sdslen(c->querybuf)) {\n        if (!(c->flags & CLIENT_SLAVE) && clientsArePaused()) break;\n        if (c->flags & CLIENT_BLOCKED) break;\n        if (c->flags & CLIENT_CLOSE_AFTER_REPLY) break;\n        if (!c->reqtype) {\n            if (c->querybuf[0] == '*') {\n                c->reqtype = PROTO_REQ_MULTIBULK;\n            } else {\n                c->reqtype = PROTO_REQ_INLINE;\n            }\n        }\n        if (c->reqtype == PROTO_REQ_INLINE) {\n            if (processInlineBuffer(c) != C_OK) break;\n        } else if (c->reqtype == PROTO_REQ_MULTIBULK) {\n            if (processMultibulkBuffer(c) != C_OK) break;\n        } else {\n            serverPanic(\"Unknown request type\");\n        }\n        if (c->argc == 0) {\n            resetClient(c);\n        } else {\n            if (processCommand(c) == C_OK)\n                resetClient(c);\n            if (server.current_client == NULL) break;\n        }\n    }\n    server.current_client = NULL;\n}", "target": 1}
{"code": "static void timer_enter_running(Timer *t) {\n        _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;\n        int r;\n        assert(t);\n        if (unit_stop_pending(UNIT(t)))\n                return;\n        r = manager_add_job(UNIT(t)->manager, JOB_START, UNIT_TRIGGER(UNIT(t)),\n                            JOB_REPLACE, true, &error, NULL);\n        if (r < 0)\n                goto fail;\n        dual_timestamp_get(&t->last_trigger);\n        if (t->stamp_path)\n                touch_file(t->stamp_path, true, t->last_trigger.realtime, UID_INVALID, GID_INVALID, 0);\n        timer_set_state(t, TIMER_RUNNING);\n        return;\nfail:\n        log_unit_warning(UNIT(t), \"Failed to queue unit startup job: %s\", bus_error_message(&error, r));\n        timer_enter_dead(t, TIMER_FAILURE_RESOURCES);\n}", "target": 1}
{"code": "int handle(int s, unsigned char* data, int len, struct sockaddr_in *s_in)\n{\n\tchar buf[2048];\n\tunsigned short *cmd = (unsigned short *)buf;\n\tint plen;\n\tstruct in_addr *addr = &s_in->sin_addr;\n\tunsigned short *pid = (unsigned short*) data;\n\tif (len == S_HELLO_LEN && memcmp(data, \"sorbo\", 5) == 0) {\n\t\tunsigned short *id = (unsigned short*) (data+5);\n\t\tint x = 2+4+2;\n\t\t*cmd = htons(S_CMD_INET_CHECK);\n\t\tmemcpy(cmd+1, addr, 4);\n\t\tmemcpy(cmd+1+2, id, 2);\n\t\tprintf(\"Inet check by %s %d\\n\",\n\t\t       inet_ntoa(*addr), ntohs(*id));\n\t\tif (send(s, buf, x, 0) != x)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\t*cmd++ = htons(S_CMD_PACKET);\n\t*cmd++ = *pid;\n\tplen = len - 2;\n    if (plen < 0)\n        return 0;\n\tlast_id = ntohs(*pid);\n\tif (last_id > 20000)\n\t\twrap = 1;\n\tif (wrap && last_id < 100) {\n\t\twrap = 0;\n\t\tmemset(ids, 0, sizeof(ids));\n\t}\n\tprintf(\"Got packet %d %d\", last_id, plen);\n\tif (is_dup(last_id)) {\n\t\tprintf(\" (DUP)\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"\\n\");\n\t*cmd++ = htons(plen);\n\tmemcpy(cmd, data+2, plen);\n\tplen += 2 + 2 + 2;\n\tassert(plen <= (int) sizeof(buf));\n\tif (send(s, buf, plen, 0) != plen)\n\t\treturn 1;\n\treturn 0;\n}", "target": 0}
{"code": "static int unix_dgram_peer_wake_me(struct sock *sk, struct sock *other)\n{\n\tint connected;\n\tconnected = unix_dgram_peer_wake_connect(sk, other);\n\tif (unix_recvq_full(other))\n\t\treturn 1;\n\tif (connected)\n\t\tunix_dgram_peer_wake_disconnect(sk, other);\n\treturn 0;\n}", "target": 0}
{"code": "static const jpc_mstabent_t *jpc_mstab_lookup(int id)\n{\n\tconst jpc_mstabent_t *mstabent;\n\tfor (mstabent = jpc_mstab;; ++mstabent) {\n\t\tif (mstabent->id == id || mstabent->id < 0) {\n\t\t\treturn mstabent;\n\t\t}\n\t}\n\tassert(0);\n\treturn 0;\n}", "target": 0}
{"code": "void __init files_init(unsigned long mempages)\n{ \n\tunsigned long n;\n\tfilp_cachep = kmem_cache_create(\"filp\", sizeof(struct file), 0,\n\t\t\tSLAB_HWCACHE_ALIGN | SLAB_PANIC, NULL);\n\tn = (mempages * (PAGE_SIZE / 1024)) / 10;\n\tfiles_stat.max_files = max_t(unsigned long, n, NR_FILE);\n\tfiles_defer_init();\n\tlg_lock_init(&files_lglock, \"files_lglock\");\n\tpercpu_counter_init(&nr_files, 0);\n} ", "target": 1}
{"code": "static void adpt_i386_info(sysInfo_S* si)\n{\n\tswitch (boot_cpu_data.x86) {\n\tcase CPU_386:\n\t\tsi->processorType = PROC_386;\n\t\tbreak;\n\tcase CPU_486:\n\t\tsi->processorType = PROC_486;\n\t\tbreak;\n\tcase CPU_586:\n\t\tsi->processorType = PROC_PENTIUM;\n\t\tbreak;\n\tdefault:  \n\t\tsi->processorType = PROC_PENTIUM;\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "static struct nft_trans *nft_trans_alloc_gfp(const struct nft_ctx *ctx,\n\t\t\t\t\t     int msg_type, u32 size, gfp_t gfp)\n{\n\tstruct nft_trans *trans;\n\ttrans = kzalloc(sizeof(struct nft_trans) + size, gfp);\n\tif (trans == NULL)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&trans->list);\n\ttrans->msg_type = msg_type;\n\ttrans->ctx\t= *ctx;\n\treturn trans;\n}", "target": 0}
{"code": "u64 gf_isom_get_sample_dts(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber)\n{\n\tu64 dts;\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\tif (!sampleNumber) return 0;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return 0;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\tif (stbl_GetSampleDTS(trak->Media->information->sampleTable->TimeToSample, sampleNumber, &dts) != GF_OK) return 0;\n\treturn dts;\n}", "target": 0}
{"code": "static void __sock_release(struct socket *sock, struct inode *inode)\n{\n\tif (sock->ops) {\n\t\tstruct module *owner = sock->ops->owner;\n\t\tif (inode)\n\t\t\tinode_lock(inode);\n\t\tsock->ops->release(sock);\n\t\tif (inode)\n\t\t\tinode_unlock(inode);\n\t\tsock->ops = NULL;\n\t\tmodule_put(owner);\n\t}\n\tif (rcu_dereference_protected(sock->wq, 1)->fasync_list)\n\t\tpr_err(\"%s: fasync list not empty!\\n\", __func__);\n\tif (!sock->file) {\n\t\tiput(SOCK_INODE(sock));\n\t\treturn;\n\t}\n\tsock->file = NULL;\n}", "target": 0}
{"code": "\tUnbufferedAsioTlsStream(UnbufferedAsioTlsStreamParams& init)\n\t\t: AsioTcpTlsStream(init.IoContext, init.SslContext), m_VerifyOK(true), m_Hostname(init.Hostname)\n\t{\n\t}", "target": 1}
{"code": "be32dec_vect(uint32_t *dst, const unsigned char *src, size_t len)\n{\n  size_t i;\n  uint32_t *s;\n  for (i = 0; i < len / 4; i++) {\n    s = (uint32_t *) (src + i * 4);\n    dst[i] = folly::Endian::big32(*s);\n  }\n}", "target": 1}
{"code": "static void addDimensions(EctEnhancedCT *ct)\n{\n    if (!ct)\n        return;\n    IODMultiframeDimensionModule &dims = ct->getDimensions();\n    OFCHECK(dims.addDimensionIndex(\n                    DCM_StackID, \"2.25.30855560781715986879861690673941231222\", DCM_FrameContentSequence, \"STACK_DIM\")\n                .good());\n    OFCHECK(dims.addDimensionIndex(DCM_InStackPositionNumber,\n                                   \"2.25.30855560781715986879861690673941231222\",\n                                   DCM_FrameContentSequence,\n                                   \"STACK_DIM\")\n                .good());\n    OFunique_ptr<IODMultiframeDimensionModule::DimensionOrganizationItem> org(\n        new IODMultiframeDimensionModule::DimensionOrganizationItem);\n    if (org)\n    {\n        org->setDimensionOrganizationUID(\"2.25.30855560781715986879861690673941231222\");\n        dims.getDimensionOrganizationSequence().push_back(org.release());\n    }\n}", "target": 0}
{"code": "void prefetch_table(const void *tab, size_t len)\n{\n  const volatile byte *vtab = tab;\n  size_t i;\n  for (i = 0; i < len; i += 8 * 32)\n    {\n      (void)vtab[i + 0 * 32];\n      (void)vtab[i + 1 * 32];\n      (void)vtab[i + 2 * 32];\n      (void)vtab[i + 3 * 32];\n      (void)vtab[i + 4 * 32];\n      (void)vtab[i + 5 * 32];\n      (void)vtab[i + 6 * 32];\n      (void)vtab[i + 7 * 32];\n    }\n  (void)vtab[len - 1];\n}", "target": 1}
{"code": "  void ValidateInputTensors(OpKernelContext* ctx, const Tensor& in0,\n                            const Tensor& in1) override {\n    OP_REQUIRES(\n        ctx, in0.dims() >= 2,\n        errors::InvalidArgument(\"In[0] ndims must be >= 2: \", in0.dims()));\n    OP_REQUIRES(\n        ctx, in1.dims() >= 2,\n        errors::InvalidArgument(\"In[0] ndims must be >= 2: \", in1.dims()));\n  }", "target": 1}
{"code": "cmd_readcert (assuan_context_t ctx, char *line)\n{\n  ctrl_t ctrl = assuan_get_pointer (ctx);\n  int rc;\n  unsigned char *cert;\n  size_t ncert;\n  if ((rc = open_card (ctrl, NULL)))\n    return rc;\n  line = xstrdup (line); \n  rc = app_readcert (ctrl->app_ctx, line, &cert, &ncert);\n  if (rc)\n    log_error (\"app_readcert failed: %s\\n\", gpg_strerror (rc));\n  xfree (line);\n  line = NULL;\n  if (!rc)\n    {\n      rc = assuan_send_data (ctx, cert, ncert);\n      xfree (cert);\n      if (rc)\n        return rc;\n    }\n  TEST_CARD_REMOVAL (ctrl, rc);\n  return rc;\n}", "target": 0}
{"code": "static void ndpi_reset_packet_line_info(struct ndpi_packet_struct *packet) {\n  packet->parsed_lines = 0, packet->empty_line_position_set = 0, packet->host_line.ptr = NULL,\n    packet->host_line.len = 0, packet->referer_line.ptr = NULL, packet->referer_line.len = 0,\n    packet->content_line.ptr = NULL, packet->content_line.len = 0, packet->accept_line.ptr = NULL,\n    packet->accept_line.len = 0, packet->user_agent_line.ptr = NULL, packet->user_agent_line.len = 0,\n    packet->http_url_name.ptr = NULL, packet->http_url_name.len = 0, packet->http_encoding.ptr = NULL,\n    packet->http_encoding.len = 0, packet->http_transfer_encoding.ptr = NULL, packet->http_transfer_encoding.len = 0,\n    packet->http_contentlen.ptr = NULL, packet->http_contentlen.len = 0, packet->http_cookie.ptr = NULL,\n    packet->http_cookie.len = 0, packet->http_origin.len = 0, packet->http_origin.ptr = NULL,\n    packet->http_x_session_type.ptr = NULL, packet->http_x_session_type.len = 0, packet->server_line.ptr = NULL,\n    packet->server_line.len = 0, packet->http_method.ptr = NULL, packet->http_method.len = 0,\n    packet->http_response.ptr = NULL, packet->http_response.len = 0, packet->http_num_headers = 0;\n}", "target": 1}
{"code": "static long hugetlbfs_punch_hole(struct inode *inode, loff_t offset, loff_t len)\n{\n\tstruct hstate *h = hstate_inode(inode);\n\tloff_t hpage_size = huge_page_size(h);\n\tloff_t hole_start, hole_end;\n\thole_start = round_up(offset, hpage_size);\n\thole_end = round_down(offset + len, hpage_size);\n\tif (hole_end > hole_start) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tmutex_lock(&inode->i_mutex);\n\t\ti_mmap_lock_write(mapping);\n\t\tif (!RB_EMPTY_ROOT(&mapping->i_mmap))\n\t\t\thugetlb_vmdelete_list(&mapping->i_mmap,\n\t\t\t\t\t\thole_start >> PAGE_SHIFT,\n\t\t\t\t\t\thole_end  >> PAGE_SHIFT);\n\t\ti_mmap_unlock_write(mapping);\n\t\tremove_inode_hugepages(inode, hole_start, hole_end);\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "AsyncSocket::WriteResult AsyncSSLSocket::interpretSSLError(int rc, int error) {\n  if (error == SSL_ERROR_WANT_READ) {\n    LOG(ERROR) << \"AsyncSSLSocket(fd=\" << fd_ << \", state=\" << int(state_)\n               << \", sslState=\" << sslState_ << \", events=\" << eventFlags_\n               << \"): \"\n               << \"unsupported SSL renegotiation during write\";\n    return WriteResult(\n        WRITE_ERROR,\n        std::make_unique<SSLException>(SSLError::INVALID_RENEGOTIATION));\n  } else {\n    if (zero_return(error, rc, errno)) {\n      return WriteResult(0);\n    }\n    auto errError = ERR_get_error();\n    VLOG(3) << \"ERROR: AsyncSSLSocket(fd=\" << fd_ << \", state=\" << int(state_)\n            << \", sslState=\" << sslState_ << \", events=\" << eventFlags_ << \"): \"\n            << \"SSL error: \" << error << \", errno: \" << errno\n            << \", func: \" << ERR_func_error_string(errError)\n            << \", reason: \" << ERR_reason_error_string(errError);\n    return WriteResult(\n        WRITE_ERROR,\n        std::make_unique<SSLException>(error, errError, rc, errno));\n  }\n}", "target": 1}
{"code": "do_pam_chauthtok(void)\n{\n\tstruct pam_conv pam_conv = { pam_chauthtok_conv, NULL };\n\tif (use_privsep)\n\t\tfatal(\"PAM: chauthtok not supprted with privsep\");\n\tsshpam_err = pam_set_item(sshpam_handle, PAM_CONV,\n\t    (const void *)&pam_conv);\n\tif (sshpam_err != PAM_SUCCESS)\n\t\tfatal(\"PAM: failed to set PAM_CONV: %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n\tdebug(\"PAM: changing password\");\n\tsshpam_err = pam_chauthtok(sshpam_handle, PAM_CHANGE_EXPIRED_AUTHTOK);\n\tif (sshpam_err != PAM_SUCCESS)\n\t\tfatal(\"PAM: pam_chauthtok(): %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n}", "target": 0}
{"code": "l2tp_proxy_auth_type_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tND_PRINT((ndo, \"%s\", tok2str(l2tp_authentype2str,\n\t\t\t     \"AuthType-#%u\", EXTRACT_16BITS(ptr))));\n}", "target": 1}
{"code": "  void operator()(const CPUDevice& d, typename TTypes<T, 3>::ConstTensor input,\n                  bool signed_input, int num_bits, bool range_given,\n                  Tensor* input_min_tensor, Tensor* input_max_tensor,\n                  QuantizerRoundMode round_mode, bool narrow_range,\n                  typename TTypes<T, 3>::Tensor out) {\n    QuantizeAndDequantizePerChannelImpl<CPUDevice, T>::Compute(\n        d, input, signed_input, num_bits, range_given, input_min_tensor,\n        input_max_tensor, round_mode, narrow_range, out);\n  }", "target": 1}
{"code": "parse_io(VALUE klass, VALUE io, VALUE encoding)\n{\n  xmlParserCtxtPtr ctxt;\n  xmlCharEncoding enc = (xmlCharEncoding)NUM2INT(encoding);\n  if (!rb_respond_to(io, id_read)) {\n    rb_raise(rb_eTypeError, \"argument expected to respond to :read\");\n  }\n  ctxt = xmlCreateIOParserCtxt(NULL, NULL,\n                               (xmlInputReadCallback)noko_io_read,\n                               (xmlInputCloseCallback)noko_io_close,\n                               (void *)io, enc);\n  if (ctxt->sax) {\n    xmlFree(ctxt->sax);\n    ctxt->sax = NULL;\n  }\n  return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);\n}", "target": 0}
{"code": "static int xen_evtchn_cpu_prepare(unsigned int cpu)\n{\n\tint ret = 0;\n\txen_cpu_init_eoi(cpu);\n\tif (evtchn_ops->percpu_init)\n\t\tret = evtchn_ops->percpu_init(cpu);\n\treturn ret;\n}", "target": 0}
{"code": "Status SubstituteForEach(AttrMap& attrs, FullTypeDef& t) {\n  DCHECK_EQ(t.args_size(), 3);\n  const auto& cont = t.args(0);\n  const auto& tmpl = t.args(1);\n  const auto& t_var = t.args(2);\n  StringPiece var_name = t_var.s();\n  if (!attrs.contains(var_name)) {\n    return Status(\n        error::INVALID_ARGUMENT,\n        absl::StrCat(\"could not find an attribute for key '\", var_name, \"'\"));\n  }\n  const AttrValue* attr = attrs.at(var_name);\n  FullTypeDef result;\n  result.set_type_id(cont.type_id());\n  const auto attr_type = attr->value_case();\n  if (attr_type == AttrValue::kType) {\n    FullTypeDef* target = result.add_args();\n    *target = tmpl;\n    TF_RETURN_WITH_CONTEXT_IF_ERROR(\n        SubstituteFromAttrs(attrs, *target), \"while substituting '\", var_name,\n        \"' from\\n\", attr->DebugString(), \"\\ninto \", target->DebugString());\n  } else if (attr_type == AttrValue::kList) {\n    const auto& attr_list = attr->list();\n    int tsize = attr_list.type_size();\n    if (tsize == 0) {\n      return Status(error::UNIMPLEMENTED,\n                    absl::StrCat(\"unsupported list attribute type\\n\",\n                                 attr_list.DebugString(), \"\\nkey=\", var_name));\n    }\n    AttrValue replacement;\n    attrs[var_name] = &replacement;\n    for (int i = 0; i < tsize; i++) {\n      replacement.set_type(attr_list.type(i));\n      FullTypeDef* target = result.add_args();\n      *target = tmpl;\n      TF_RETURN_WITH_CONTEXT_IF_ERROR(SubstituteFromAttrs(attrs, *target),\n                                      \"while substituting '\", var_name,\n                                      \"' from\\n\", attr->DebugString(), \"\\n[\", i,\n                                      \"] into\\n\", target->DebugString());\n    }\n    attrs[var_name] = attr;\n  } else {\n    return Status(error::UNIMPLEMENTED,\n                  absl::StrCat(\"unsupported attribute type\\n\",\n                               attr->DebugString(), \"\\nfor name \", var_name));\n  }\n  t = result;\n  return OkStatus();\n}", "target": 1}
{"code": "tTcpIpPacketParsingResult ParaNdis_CheckSumVerify(\n                                                tCompletePhysicalAddress *pDataPages,\n                                                ULONG ulDataLength,\n                                                ULONG ulStartOffset,\n                                                ULONG flags,\n                                                BOOLEAN verifyLength,\n                                                LPCSTR caller)\n{\n    IPHeader *pIpHeader = (IPHeader *) RtlOffsetToPointer(pDataPages[0].Virtual, ulStartOffset);\n    tTcpIpPacketParsingResult res = QualifyIpPacket(pIpHeader, ulDataLength, verifyLength);\n    if (res.ipStatus == ppresNotIP || res.ipCheckSum == ppresIPTooShort)\n        return res;\n    if (res.ipStatus == ppresIPV4)\n    {\n        if (flags & pcrIpChecksum)\n            res = VerifyIpChecksum(&pIpHeader->v4, res, (flags & pcrFixIPChecksum) != 0);\n        if(res.xxpStatus == ppresXxpKnown)\n        {\n            if (res.TcpUdp == ppresIsTCP) \n            {\n                if(flags & pcrTcpV4Checksum)\n                {\n                    res = VerifyTcpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixTcpV4Checksum));\n                }\n            }\n            else \n            {\n                if (flags & pcrUdpV4Checksum)\n                {\n                    res = VerifyUdpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixUdpV4Checksum));\n                }\n            }\n        }\n    }\n    else if (res.ipStatus == ppresIPV6)\n    {\n        if(res.xxpStatus == ppresXxpKnown)\n        {\n            if (res.TcpUdp == ppresIsTCP) \n            {\n                if(flags & pcrTcpV6Checksum)\n                {\n                    res = VerifyTcpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixTcpV6Checksum));\n                }\n            }\n            else \n            {\n                if (flags & pcrUdpV6Checksum)\n                {\n                    res = VerifyUdpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixUdpV6Checksum));\n                }\n            }\n        }\n    }\n    PrintOutParsingResult(res, 1, caller);\n    return res;\n}", "target": 0}
{"code": "static void op_attr_bignum_free(void *attr)\n{\n\tstruct bignum **bn = attr;\n\tcrypto_bignum_free(*bn);\n\t*bn = NULL;\n}", "target": 1}
{"code": "static bool check_underflow(const struct arpt_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\tif (!unconditional(&e->arp))\n\t\treturn false;\n\tt = arpt_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}", "target": 1}
{"code": "resp_get_length(netdissect_options *ndo, register const u_char *bp, int len, const u_char **endp)\n{\n    int result;\n    u_char c;\n    int saw_digit;\n    int neg;\n    int too_large;\n    if (len == 0)\n        goto trunc;\n    ND_TCHECK(*bp);\n    too_large = 0;\n    neg = 0;\n    if (*bp == '-') {\n        neg = 1;\n        bp++;\n        len--;\n    }\n    result = 0;\n    saw_digit = 0;\n    for (;;) {\n        if (len == 0)\n            goto trunc;\n        ND_TCHECK(*bp);\n        c = *bp;\n        if (!(c >= '0' && c <= '9')) {\n            if (!saw_digit)\n                goto invalid;\n            break;\n        }\n        c -= '0';\n        if (result > (INT_MAX / 10)) {\n            too_large = 1;\n        } else {\n            result *= 10;\n            if (result == INT_MAX && c > (INT_MAX % 10)) {\n                too_large = 1;\n            } else\n                result += c;\n        }\n        bp++;\n        len--;\n        saw_digit = 1;\n    }\n    if (!saw_digit)\n        goto invalid;\n    if (len == 0)\n        goto trunc;\n    ND_TCHECK(*bp);\n    if (*bp != '\\r')\n        goto invalid;\n    bp++;\n    len--;\n    if (len == 0)\n        goto trunc;\n    ND_TCHECK(*bp);\n    if (*bp != '\\n')\n        goto invalid;\n    bp++;\n    len--;\n    *endp = bp;\n    if (neg) {\n        if (too_large || result != 1)\n            return (-4);\n        result = -1;\n    }\n    return (too_large ? -3 : result);\ntrunc:\n    return (-2);\ninvalid:\n    return (-5);\n}", "target": 1}
{"code": "xmlValidCtxtPtr xmlNewValidCtxt(void) {\n    xmlValidCtxtPtr ret;\n    if ((ret = xmlMalloc(sizeof (xmlValidCtxt))) == NULL) {\n\txmlVErrMemory(NULL, \"malloc failed\");\n\treturn (NULL);\n    }\n    (void) memset(ret, 0, sizeof (xmlValidCtxt));\n    return (ret);\n}", "target": 0}
{"code": "static int init_die(RzBinDwarfDie *die, ut64 abbr_code, ut64 attr_count) {\n\tif (!die) {\n\t\treturn -1;\n\t}\n\tdie->attr_values = calloc(sizeof(RzBinDwarfAttrValue), attr_count);\n\tif (!die->attr_values) {\n\t\treturn -1;\n\t}\n\tdie->abbrev_code = abbr_code;\n\tdie->capacity = attr_count;\n\tdie->count = 0;\n\treturn 0;\n}", "target": 1}
{"code": "  void setSanMatchers(std::vector<envoy::type::matcher::v3::StringMatcher> san_matchers) {\n    san_matchers_ = san_matchers;\n  };", "target": 1}
{"code": "static int pptp_bind(struct socket *sock, struct sockaddr *uservaddr,\n\tint sockaddr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_pppox *sp = (struct sockaddr_pppox *) uservaddr;\n\tstruct pppox_sock *po = pppox_sk(sk);\n\tstruct pptp_opt *opt = &po->proto.pptp;\n\tint error = 0;\n\tif (sockaddr_len < sizeof(struct sockaddr_pppox))\n\t\treturn -EINVAL;\n\tlock_sock(sk);\n\topt->src_addr = sp->sa_addr.pptp;\n\tif (add_chan(po))\n\t\terror = -EBUSY;\n\trelease_sock(sk);\n\treturn error;\n}", "target": 0}
{"code": "int prepareForShutdown() {\n    redisLog(REDIS_WARNING,\"User requested shutdown, saving DB...\");\n    if (server.bgsavechildpid != -1) {\n        redisLog(REDIS_WARNING,\"There is a live saving child. Killing it!\");\n        kill(server.bgsavechildpid,SIGKILL);\n        rdbRemoveTempFile(server.bgsavechildpid);\n    }\n    if (server.appendonly) {\n        aof_fsync(server.appendfd);\n        if (server.vm_enabled) unlink(server.vm_swap_file);\n    } else if (server.saveparamslen > 0) {\n        if (rdbSave(server.dbfilename) != REDIS_OK) {\n            redisLog(REDIS_WARNING,\"Error trying to save the DB, can't exit\");\n            return REDIS_ERR;\n        }\n    } else {\n        redisLog(REDIS_WARNING,\"Not saving DB.\");\n    }\n    if (server.daemonize) unlink(server.pidfile);\n    redisLog(REDIS_WARNING,\"Server exit now, bye bye...\");\n    return REDIS_OK;\n}", "target": 1}
{"code": "static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC) \n{\n\tif (prev_options != NULL) {\n\t\t*prev_options = MBREX(regex_default_options);\n\t}\n\tif (prev_syntax != NULL) {\n\t\t*prev_syntax = MBREX(regex_default_syntax);\n\t}\n\tMBREX(regex_default_options) = options;\n\tMBREX(regex_default_syntax) = syntax;\n}", "target": 1}
{"code": "int sanity_check_ckpt(struct f2fs_sb_info *sbi)\n{\n\tunsigned int total, fsmeta;\n\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tunsigned int ovp_segments, reserved_segments;\n\tunsigned int main_segs, blocks_per_seg;\n\tint i;\n\ttotal = le32_to_cpu(raw_super->segment_count);\n\tfsmeta = le32_to_cpu(raw_super->segment_count_ckpt);\n\tfsmeta += le32_to_cpu(raw_super->segment_count_sit);\n\tfsmeta += le32_to_cpu(raw_super->segment_count_nat);\n\tfsmeta += le32_to_cpu(ckpt->rsvd_segment_count);\n\tfsmeta += le32_to_cpu(raw_super->segment_count_ssa);\n\tif (unlikely(fsmeta >= total))\n\t\treturn 1;\n\tovp_segments = le32_to_cpu(ckpt->overprov_segment_count);\n\treserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);\n\tif (unlikely(fsmeta < F2FS_MIN_SEGMENTS ||\n\t\t\tovp_segments == 0 || reserved_segments == 0)) {\n\t\tf2fs_msg(sbi->sb, KERN_ERR,\n\t\t\t\"Wrong layout: check mkfs.f2fs version\");\n\t\treturn 1;\n\t}\n\tmain_segs = le32_to_cpu(raw_super->segment_count_main);\n\tblocks_per_seg = sbi->blocks_per_seg;\n\tfor (i = 0; i < NR_CURSEG_NODE_TYPE; i++) {\n\t\tif (le32_to_cpu(ckpt->cur_node_segno[i]) >= main_segs ||\n\t\t\tle16_to_cpu(ckpt->cur_node_blkoff[i]) >= blocks_per_seg)\n\t\t\treturn 1;\n\t}\n\tfor (i = 0; i < NR_CURSEG_DATA_TYPE; i++) {\n\t\tif (le32_to_cpu(ckpt->cur_data_segno[i]) >= main_segs ||\n\t\t\tle16_to_cpu(ckpt->cur_data_blkoff[i]) >= blocks_per_seg)\n\t\t\treturn 1;\n\t}\n\tif (unlikely(f2fs_cp_error(sbi))) {\n\t\tf2fs_msg(sbi->sb, KERN_ERR, \"A bug case: need to run fsck\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "PHP_FUNCTION(radius_get_vendor_attr)\n{\n\tint res;\n\tconst void *data;\n\tint len;\n\tu_int32_t vendor;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &data, &len) == FAILURE) {\n\t\treturn;\n\t}\n\tres = rad_get_vendor_attr(&vendor, &data, (size_t *) &len);\n\tif (res == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tarray_init(return_value);\n\t\tadd_assoc_long(return_value, \"attr\", res);\n\t\tadd_assoc_long(return_value, \"vendor\", vendor);\n\t\tadd_assoc_stringl(return_value, \"data\", (char *) data, len, 1);\n\t\treturn;\n\t}\n}", "target": 1}
{"code": "static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)\n{\n\tstruct fsck_gitmodules_data *data = vdata;\n\tconst char *subsection, *key;\n\tint subsection_len;\n\tchar *name;\n\tif (parse_config_key(var, \"submodule\", &subsection, &subsection_len, &key) < 0 ||\n\t    !subsection)\n\t\treturn 0;\n\tname = xmemdupz(subsection, subsection_len);\n\tif (check_submodule_name(name) < 0)\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_NAME,\n\t\t\t\t    \"disallowed submodule name: %s\",\n\t\t\t\t    name);\n\tif (!strcmp(key, \"url\") && value &&\n\t    looks_like_command_line_option(value))\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_URL,\n\t\t\t\t    \"disallowed submodule url: %s\",\n\t\t\t\t    value);\n\tfree(name);\n\treturn 0;\n}", "target": 0}
{"code": "int ntlm_read_message_header(wStream* s, NTLM_MESSAGE_HEADER* header)\n{\n\tif (Stream_GetRemainingLength(s) < 12)\n\t\treturn -1;\n\tStream_Read(s, header->Signature, 8);\n\tStream_Read_UINT32(s, header->MessageType);\n\tif (strncmp((char*) header->Signature, NTLM_SIGNATURE, 8) != 0)\n\t\treturn -1;\n\treturn 1;\n}", "target": 1}
{"code": "auth_ice_connection (IceConn ice_conn)\n{\n        GIOChannel            *channel;\n        GsmIceConnectionWatch *data;\n        int                    fd;\n        g_debug (\"GsmXsmpServer: auth_ice_connection()\");\n        fd = IceConnectionNumber (ice_conn);\n        fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);\n        channel = g_io_channel_unix_new (fd);\n        data = g_new0 (GsmIceConnectionWatch, 1);\n        ice_conn->context = data;\n        data->protocol_timeout = g_timeout_add_seconds (5,\n                                                        (GSourceFunc)ice_protocol_timeout,\n                                                        ice_conn);\n        data->watch_id = g_io_add_watch (channel,\n                                         G_IO_IN | G_IO_ERR,\n                                         (GIOFunc)auth_iochannel_watch,\n                                         ice_conn);\n        g_io_channel_unref (channel);\n}", "target": 0}
{"code": "eb_get_object(struct eb_objects *eb, unsigned long handle)\n{\n\tif (eb->and < 0) {\n\t\tif (handle >= -eb->and)\n\t\t\treturn NULL;\n\t\treturn eb->lut[handle];\n\t} else {\n\t\tstruct hlist_head *head;\n\t\tstruct hlist_node *node;\n\t\thead = &eb->buckets[handle & eb->and];\n\t\thlist_for_each(node, head) {\n\t\t\tstruct drm_i915_gem_object *obj;\n\t\t\tobj = hlist_entry(node, struct drm_i915_gem_object, exec_node);\n\t\t\tif (obj->exec_handle == handle)\n\t\t\t\treturn obj;\n\t\t}\n\t\treturn NULL;\n\t}\n}", "target": 0}
{"code": "static void do_sched_cfs_slack_timer(struct cfs_bandwidth *cfs_b)\n{\n\tu64 runtime = 0, slice = sched_cfs_bandwidth_slice();\n\tunsigned long flags;\n\tu64 expires;\n\traw_spin_lock_irqsave(&cfs_b->lock, flags);\n\tcfs_b->slack_started = false;\n\tif (cfs_b->distribute_running) {\n\t\traw_spin_unlock_irqrestore(&cfs_b->lock, flags);\n\t\treturn;\n\t}\n\tif (runtime_refresh_within(cfs_b, min_bandwidth_expiration)) {\n\t\traw_spin_unlock_irqrestore(&cfs_b->lock, flags);\n\t\treturn;\n\t}\n\tif (cfs_b->quota != RUNTIME_INF && cfs_b->runtime > slice)\n\t\truntime = cfs_b->runtime;\n\texpires = cfs_b->runtime_expires;\n\tif (runtime)\n\t\tcfs_b->distribute_running = 1;\n\traw_spin_unlock_irqrestore(&cfs_b->lock, flags);\n\tif (!runtime)\n\t\treturn;\n\truntime = distribute_cfs_runtime(cfs_b, runtime, expires);\n\traw_spin_lock_irqsave(&cfs_b->lock, flags);\n\tif (expires == cfs_b->runtime_expires)\n\t\tlsub_positive(&cfs_b->runtime, runtime);\n\tcfs_b->distribute_running = 0;\n\traw_spin_unlock_irqrestore(&cfs_b->lock, flags);\n}", "target": 1}
{"code": "\t\tauto GetKey(Local<Context> context) -> Local<Name> {\n\t\t\tauto key_inner = key->CopyInto();\n\t\t\treturn (key_inner->IsString() || key_inner->IsSymbol()) ?\n\t\t\t\tkey_inner.As<Name>() : Unmaybe(key_inner->ToString(context)).As<Name>();\n\t\t}", "target": 0}
{"code": "GC_API void * GC_CALL GC_generic_malloc(size_t lb, int k)\n{\n    void * result;\n    DCL_LOCK_STATE;\n    if (EXPECT(GC_have_errors, FALSE))\n      GC_print_all_errors();\n    GC_INVOKE_FINALIZERS();\n    if (SMALL_OBJ(lb)) {\n        LOCK();\n        result = GC_generic_malloc_inner((word)lb, k);\n        UNLOCK();\n    } else {\n        size_t lg;\n        size_t lb_rounded;\n        word n_blocks;\n        GC_bool init;\n        lg = ROUNDED_UP_GRANULES(lb);\n        lb_rounded = GRANULES_TO_BYTES(lg);\n        if (lb_rounded < lb)\n            return((*GC_get_oom_fn())(lb));\n        n_blocks = OBJ_SZ_TO_BLOCKS(lb_rounded);\n        init = GC_obj_kinds[k].ok_init;\n        LOCK();\n        result = (ptr_t)GC_alloc_large(lb_rounded, k, 0);\n        if (0 != result) {\n          if (GC_debugging_started) {\n            BZERO(result, n_blocks * HBLKSIZE);\n          } else {\n#           ifdef THREADS\n                ((word *)result)[0] = 0;\n                ((word *)result)[1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-2] = 0;\n#           endif\n          }\n        }\n        GC_bytes_allocd += lb_rounded;\n        UNLOCK();\n        if (init && !GC_debugging_started && 0 != result) {\n            BZERO(result, n_blocks * HBLKSIZE);\n        }\n    }\n    if (0 == result) {\n        return((*GC_get_oom_fn())(lb));\n    } else {\n        return(result);\n    }\n}", "target": 0}
{"code": "handle_mlppp(netdissect_options *ndo,\n             const u_char *p, int length)\n{\n    if (!ndo->ndo_eflag)\n        ND_PRINT((ndo, \"MLPPP, \"));\n    if (length < 2) {\n        ND_PRINT((ndo, \"[|mlppp]\"));\n        return;\n    }\n    if (!ND_TTEST_16BITS(p)) {\n        ND_PRINT((ndo, \"[|mlppp]\"));\n        return;\n    }\n    ND_PRINT((ndo, \"seq 0x%03x, Flags [%s], length %u\",\n           (EXTRACT_16BITS(p))&0x0fff, \n           bittok2str(ppp_ml_flag_values, \"none\", *p & 0xc0),\n           length));\n}", "target": 0}
{"code": "void lsetCommand(client *c) {\n    robj *o = lookupKeyWriteOrReply(c,c->argv[1],shared.nokeyerr);\n    if (o == NULL || checkType(c,o,OBJ_LIST)) return;\n    long index;\n    robj *value = c->argv[3];\n    if (sdslen(value->ptr) > LIST_MAX_ITEM_SIZE) {\n        addReplyError(c, \"Element too large\");\n        return;\n    }\n    if ((getLongFromObjectOrReply(c, c->argv[2], &index, NULL) != C_OK))\n        return;\n    if (o->encoding == OBJ_ENCODING_QUICKLIST) {\n        quicklist *ql = o->ptr;\n        int replaced = quicklistReplaceAtIndex(ql, index,\n                                               value->ptr, sdslen(value->ptr));\n        if (!replaced) {\n            addReply(c,shared.outofrangeerr);\n        } else {\n            addReply(c,shared.ok);\n            signalModifiedKey(c,c->db,c->argv[1]);\n            notifyKeyspaceEvent(NOTIFY_LIST,\"lset\",c->argv[1],c->db->id);\n            server.dirty++;\n        }\n    } else {\n        serverPanic(\"Unknown list encoding\");\n    }\n}", "target": 0}
{"code": "bool QHstsHeaderParser::parse(const QList<QPair<QByteArray, QByteArray>> &headers)\n{\n    for (const auto &h : headers) {\n        if (h.first == \"Strict-Transport-Security\") {\n            header = h.second;\n            if (parseSTSHeader() && maxAgeFound) {\n                expiry = QDateTime::currentDateTimeUtc().addSecs(maxAge);\n                return true;\n            }\n        }\n    }\n    subDomainsFound = false;\n    return false;\n}", "target": 1}
{"code": "      void Init(void)\n      {\n        for(int i = 0;i < 15;i++) {\n          X[i].Init();\n          M[i].Init();\n        }\n      }", "target": 1}
{"code": "static SQInteger thread_call(HSQUIRRELVM v)\n{\n    SQObjectPtr o = stack_get(v,1);\n    if(sq_type(o) == OT_THREAD) {\n        SQInteger nparams = sq_gettop(v);\n        sq_reservestack(_thread(o), nparams + 3);\n        _thread(o)->Push(_thread(o)->_roottable);\n        for(SQInteger i = 2; i<(nparams+1); i++)\n            sq_move(_thread(o),v,i);\n        if(SQ_SUCCEEDED(sq_call(_thread(o),nparams,SQTrue,SQTrue))) {\n            sq_move(v,_thread(o),-1);\n            sq_pop(_thread(o),1);\n            return 1;\n        }\n        v->_lasterror = _thread(o)->_lasterror;\n        return SQ_ERROR;\n    }\n    return sq_throwerror(v,_SC(\"wrong parameter\"));\n}", "target": 0}
{"code": "decode_definite_long_bytestring(CBORDecoderObject *self, Py_ssize_t length)\n{\n    PyObject *buffer = NULL;\n    Py_ssize_t left = length;\n    while (left) {\n        Py_ssize_t chunk_length = length <= 65536 ? length : 65536;\n        PyObject *chunk = fp_read_object(self, chunk_length);\n        if (!chunk) {\n            break;\n        }\n        if (!PyBytes_CheckExact(chunk)) {\n            Py_DECREF(chunk);\n            break;\n        }\n        if (buffer) {\n            PyObject *new_buffer = PyByteArray_Concat(buffer, chunk);\n            Py_DECREF(chunk);\n            if (!new_buffer)\n                break;\n            if (new_buffer != buffer) {\n                Py_DECREF(buffer);\n                buffer = new_buffer;\n            }\n        } else {\n            buffer = PyByteArray_FromObject(chunk);\n            Py_DECREF(chunk);\n            if (!buffer)\n                break;\n        }\n        left -= chunk_length;\n    }\n    PyObject *ret = NULL;\n    if (buffer) {\n        ret = PyBytes_FromObject(buffer);\n        Py_DECREF(buffer);\n        if (ret && string_namespace_add(self, ret, length) == -1) {\n            Py_DECREF(ret);\n            ret = NULL;\n        }\n    }\n    return ret;\n}", "target": 0}
{"code": "Status RangeSize(const Tensor* start_t, const Tensor* limit_t,\n                 const Tensor* delta_t, InferenceContext* const c) {\n  T start = start_t->scalar<T>()();\n  T limit = limit_t->scalar<T>()();\n  T delta = delta_t->scalar<T>()();\n  if (start > limit && delta > T(0)) {\n    return errors::InvalidArgument(\n        \"Requires start <= limit when delta > 0: \", start, \"/\", limit);\n  }\n  if (start < limit && delta < T(0)) {\n    return errors::InvalidArgument(\n        \"Requires start >= limit when delta < 0: \", start, \"/\", limit);\n  }\n  if (delta == T(0)) {\n    return errors::InvalidArgument(\"Requires delta != 0\");\n  }\n  auto size = (std::is_integral<T>::value\n                   ? ((Eigen::numext::abs(limit - start) +\n                       Eigen::numext::abs(delta) - T(1)) /\n                      Eigen::numext::abs(delta))\n                   : (Eigen::numext::ceil(\n                         Eigen::numext::abs((limit - start) / delta))));\n  if (size > std::numeric_limits<int64_t>::max()) {\n    return errors::InvalidArgument(\"Requires ((limit - start) / delta) <= \",\n                                   std::numeric_limits<int64_t>::max());\n  }\n  c->set_output(0, c->Vector(static_cast<int64_t>(size)));\n  return Status::OK();\n}", "target": 1}
{"code": "bool f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_tree *et;\n\tstruct extent_node *en;\n\tstruct extent_info ei;\n\tif (!f2fs_may_extent_tree(inode)) {\n\t\tif (i_ext && i_ext->len) {\n\t\t\ti_ext->len = 0;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tet = __grab_extent_tree(inode);\n\tif (!i_ext || !i_ext->len)\n\t\treturn false;\n\tget_extent_info(&ei, i_ext);\n\twrite_lock(&et->lock);\n\tif (atomic_read(&et->node_cnt))\n\t\tgoto out;\n\ten = __init_extent_tree(sbi, et, &ei);\n\tif (en) {\n\t\tspin_lock(&sbi->extent_lock);\n\t\tlist_add_tail(&en->list, &sbi->extent_list);\n\t\tspin_unlock(&sbi->extent_lock);\n\t}\nout:\n\twrite_unlock(&et->lock);\n\treturn false;\n}", "target": 1}
{"code": "    const std::unordered_map<std::string, std::string> &getHeaders() const\n    {\n        return headers();\n    }", "target": 1}
{"code": "pdf_write_names(FILE *out)\t\t\n{\n  int\t\ti;\t\t\t\n  uchar\t\t*s;\t\t\t\n  link_t\t*link;\t\t\t\n  for (i = num_links, link = links; i > 0; i --, link ++)\n    for (s = link->name; *s != '\\0'; s ++)\n      *s = (uchar)tolower(*s);\n  names_object = pdf_start_object(out);\n  fprintf(out, \"/Dests %d 0 R\", (int)num_objects + 1);\n  pdf_end_object(out);\n  pdf_start_object(out);\n  fprintf(out, \"/Kids[%d 0 R]\", (int)num_objects + 1);\n  pdf_end_object(out);\n  pdf_start_object(out);\n  fputs(\"/Limits[\", out);\n  write_string(out, links[0].name, 0);\n  write_string(out, links[num_links - 1].name, 0);\n  fputs(\"]\", out);\n  fputs(\"/Names[\", out);\n  for (i = 1, link = links; i <= (int)num_links; i ++, link ++)\n  {\n    write_string(out, link->name, 0);\n    fprintf(out, \"%d 0 R\", (int)num_objects + i);\n  }\n  fputs(\"]\", out);\n  pdf_end_object(out);\n  for (i = num_links, link = links; i > 0; i --, link ++)\n  {\n    pdf_start_object(out);\n    float x, y;\n    check_pages(link->page);\n    x = 0.0f;\n    y = link->top + pages[link->page].bottom;\n    pspdf_transform_coords(pages + link->page, x, y);\n    fprintf(out, \"/D[%d 0 R/XYZ %.0f %.0f 0]\",\n            pages_object + 2 * pages[link->page].outpage + 1, x, y);\n    pdf_end_object(out);\n  }\n}", "target": 0}
{"code": "int st21nfca_connectivity_event_received(struct nfc_hci_dev *hdev, u8 host,\n\t\t\t\tu8 event, struct sk_buff *skb)\n{\n\tint r = 0;\n\tstruct device *dev = &hdev->ndev->dev;\n\tstruct nfc_evt_transaction *transaction;\n\tpr_debug(\"connectivity gate event: %x\\n\", event);\n\tswitch (event) {\n\tcase ST21NFCA_EVT_CONNECTIVITY:\n\t\tr = nfc_se_connectivity(hdev->ndev, host);\n\tbreak;\n\tcase ST21NFCA_EVT_TRANSACTION:\n\t\tif (skb->len < NFC_MIN_AID_LENGTH + 2 &&\n\t\t    skb->data[0] != NFC_EVT_TRANSACTION_AID_TAG)\n\t\t\treturn -EPROTO;\n\t\ttransaction = devm_kzalloc(dev, skb->len - 2, GFP_KERNEL);\n\t\tif (!transaction)\n\t\t\treturn -ENOMEM;\n\t\ttransaction->aid_len = skb->data[1];\n\t\tif (transaction->aid_len > sizeof(transaction->aid))\n\t\t\treturn -EINVAL;\n\t\tmemcpy(transaction->aid, &skb->data[2],\n\t\t       transaction->aid_len);\n\t\tif (skb->data[transaction->aid_len + 2] !=\n\t\t    NFC_EVT_TRANSACTION_PARAMS_TAG)\n\t\t\treturn -EPROTO;\n\t\ttransaction->params_len = skb->data[transaction->aid_len + 3];\n\t\tif (transaction->params_len > ((skb->len - 2) - sizeof(struct nfc_evt_transaction)))\n\t\t\treturn -EINVAL;\n\t\tmemcpy(transaction->params, skb->data +\n\t\t       transaction->aid_len + 4, transaction->params_len);\n\t\tr = nfc_se_transaction(hdev->ndev, host, transaction);\n\tbreak;\n\tdefault:\n\t\tnfc_err(&hdev->ndev->dev, \"Unexpected event on connectivity gate\\n\");\n\t\treturn 1;\n\t}\n\tkfree_skb(skb);\n\treturn r;\n}", "target": 0}
{"code": "av_cold void ff_mpv_idct_init(MpegEncContext *s)\n{\n    if (s->codec_id == AV_CODEC_ID_MPEG4)\n        s->idsp.mpeg4_studio_profile = s->studio_profile;\n    ff_idctdsp_init(&s->idsp, s->avctx);\n    if (s->alternate_scan) {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_alternate_vertical_scan);\n    } else {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_zigzag_direct);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_zigzag_direct);\n    }\n    ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);\n    ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);\n}", "target": 0}
{"code": "static Jsi_RC jsi_ArraySizeOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    int i = Jsi_ObjGetLength(interp, _this->d.obj);\n    Jsi_ValueMakeNumber(interp, ret, i);\n    return JSI_OK;\n}", "target": 1}
{"code": "static bool io_wq_for_each_worker(struct io_wqe *wqe,\n\t\t\t\t  bool (*func)(struct io_worker *, void *),\n\t\t\t\t  void *data)\n{\n\tstruct io_worker *worker;\n\tbool ret = false;\n\tlist_for_each_entry_rcu(worker, &wqe->all_list, all_list) {\n\t\tif (io_worker_get(worker)) {\n\t\t\tif (worker->task)\n\t\t\t\tret = func(worker, data);\n\t\t\tio_worker_release(worker);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static void lateeoi_list_del(struct irq_info *info)\n{\n\tstruct lateeoi_work *eoi = &per_cpu(lateeoi, info->eoi_cpu);\n\tunsigned long flags;\n\tspin_lock_irqsave(&eoi->eoi_list_lock, flags);\n\tlist_del_init(&info->eoi_list);\n\tspin_unlock_irqrestore(&eoi->eoi_list_lock, flags);\n}", "target": 0}
{"code": "pci_msix_table_init(struct pci_vdev *dev, int table_entries)\n{\n\tint i, table_size;\n\tassert(table_entries > 0);\n\tassert(table_entries <= MAX_MSIX_TABLE_ENTRIES);\n\ttable_size = table_entries * MSIX_TABLE_ENTRY_SIZE;\n\tdev->msix.table = calloc(1, table_size);\n\tassert(dev->msix.table != NULL);\n\tfor (i = 0; i < table_entries; i++)\n\t\tdev->msix.table[i].vector_control |= PCIM_MSIX_VCTRL_MASK;\n}", "target": 1}
{"code": "ctcompare(const char *a,\t\t\n          const char *b)\t\t\n{\n  int\tresult = 0;\t\t\t\n  while (*a && *b)\n  {\n    result |= *a ^ *b;\n    a ++;\n    b ++;\n  }\n  return (result);\n}", "target": 1}
{"code": "InstallSignalHandlers(void)\n{\n    xf86Info.caughtSignal = FALSE;\n    if (!xf86Info.notrapSignals) {\n        OsRegisterSigWrapper(xf86SigWrapper);\n    }\n    else {\n        signal(SIGSEGV, SIG_DFL);\n        signal(SIGILL, SIG_DFL);\n#ifdef SIGEMT\n        signal(SIGEMT, SIG_DFL);\n#endif\n        signal(SIGFPE, SIG_DFL);\n        signal(SIGBUS, SIG_DFL);\n        signal(SIGSYS, SIG_DFL);\n        signal(SIGXCPU, SIG_DFL);\n        signal(SIGXFSZ, SIG_DFL);\n    }\n}", "target": 0}
{"code": "hstore_slice_to_hstore(PG_FUNCTION_ARGS)\n{\n\tHStore\t   *hs = PG_GETARG_HS(0);\n\tHEntry\t   *entries = ARRPTR(hs);\n\tchar\t   *ptr = STRPTR(hs);\n\tArrayType  *key_array = PG_GETARG_ARRAYTYPE_P(1);\n\tHStore\t   *out;\n\tint\t\t\tnkeys;\n\tPairs\t   *key_pairs = hstoreArrayToPairs(key_array, &nkeys);\n\tPairs\t   *out_pairs;\n\tint\t\t\tbufsiz;\n\tint\t\t\tlastidx = 0;\n\tint\t\t\ti;\n\tint\t\t\tout_count = 0;\n\tif (nkeys == 0)\n\t{\n\t\tout = hstorePairs(NULL, 0, 0);\n\t\tPG_RETURN_POINTER(out);\n\t}\n\tout_pairs = palloc(sizeof(Pairs) * nkeys);\n\tbufsiz = 0;\n\tfor (i = 0; i < nkeys; ++i)\n\t{\n\t\tint\t\t\tidx = hstoreFindKey(hs, &lastidx,\n\t\t\t\t\t\t\t\t\t  key_pairs[i].key, key_pairs[i].keylen);\n\t\tif (idx >= 0)\n\t\t{\n\t\t\tout_pairs[out_count].key = key_pairs[i].key;\n\t\t\tbufsiz += (out_pairs[out_count].keylen = key_pairs[i].keylen);\n\t\t\tout_pairs[out_count].val = HS_VAL(entries, ptr, idx);\n\t\t\tbufsiz += (out_pairs[out_count].vallen = HS_VALLEN(entries, idx));\n\t\t\tout_pairs[out_count].isnull = HS_VALISNULL(entries, idx);\n\t\t\tout_pairs[out_count].needfree = false;\n\t\t\t++out_count;\n\t\t}\n\t}\n\tout = hstorePairs(out_pairs, out_count, bufsiz);\n\tPG_RETURN_POINTER(out);\n}", "target": 0}
{"code": "static void netprobe_handler(int err, const struct netprobe_result *result,\n\t\t\t     void *arg)\n{\n\tstruct probe_entry *np;\n\tsize_t ix = (size_t)arg;\n\tif (err) {\n\t\twarning(\"netprobe failed (%m)\\n\", err);\n\t\tgoto out;\n\t}\n\tnp = &netprobev[ix];\n\tre_printf(\"Network Probe results for %s TURN%s-server at %J\\n\",\n\t\t  net_proto2name(np->proto),\n\t\t  np->secure ? \"S\" : \"\", &np->turn_srv);\n\tre_printf(\"    Average RTT:   %.1f milliseconds\\n\",\n\t\t  result->rtt_avg / 1000.0);\n\tre_printf(\"    transmitted:   %u packets\\n\", result->n_pkt_sent);\n\tre_printf(\"    received:      %u packets\\n\", result->n_pkt_recv);\n\tre_printf(\"\\n\");\n out:\n\tnetprobec_ok++;\n\tif (netprobec_ok >= netprobec) {\n\t\tinfo(\"netprobing done. shutting down..\\n\");\n\t\tengine_shutdown(engine);\n\t}\n}", "target": 0}
{"code": "  void operator()(OpKernelContext* ctx, const Index num_segments,\n                  const TensorShape& segment_ids_shape,\n                  typename TTypes<Index>::ConstFlat segment_ids,\n                  const Index data_size, const T* data,\n                  typename TTypes<T, 2>::Tensor output) {\n    output.setConstant(InitialValueF()());\n    if (data_size == 0) {\n      return;\n    }\n    const int64 N = segment_ids.dimension(0);\n    ReductionF reduction;\n    auto data_flat = typename TTypes<T, 2>::ConstTensor(data, N, data_size / N);\n    for (int64 i = 0; i < N; ++i) {\n      Index j = internal::SubtleMustCopy(segment_ids(i));\n      if (j < 0) {\n        continue;\n      }\n      OP_REQUIRES(ctx, FastBoundsCheck(j, num_segments),\n                  errors::InvalidArgument(\n                      \"segment_ids\", SliceDebugString(segment_ids_shape, i),\n                      \" = \", j, \" is out of range [0, \", num_segments, \")\"));\n      reduction(data_flat.template chip<0>(i), output.template chip<0>(j));\n    }\n  }", "target": 1}
{"code": "deltas_head_create(struct deltas_head **deltas)\n{\n\tstruct deltas_head *tmp;\n\ttmp = malloc(sizeof(struct deltas_head));\n\tif (tmp == NULL)\n\t\treturn pr_enomem();\n\tdeltas_head_init(tmp);\n\t*deltas = tmp;\n\treturn 0;\n}", "target": 1}
{"code": "BOOL security_fips_decrypt(BYTE* data, size_t length, rdpRdp* rdp)\n{\n\tsize_t olen;\n\tif (!rdp || !rdp->fips_decrypt)\n\t\treturn FALSE;\n\tif (!winpr_Cipher_Update(rdp->fips_decrypt, data, length, data, &olen))\n\t\treturn FALSE;\n\treturn TRUE;\n}", "target": 0}
{"code": "bgp_attr_unintern (struct attr **attr)\n{\n  struct attr *ret;\n  struct attr tmp;\n  (*attr)->refcnt--;\n  tmp = *(*attr);\n  if ((*attr)->extra)\n    {\n      tmp.extra = bgp_attr_extra_new ();\n      memcpy (tmp.extra, (*attr)->extra, sizeof (struct attr_extra));\n    }\n  if ((*attr)->refcnt == 0)\n    {    \n      ret = hash_release (attrhash, *attr);\n      assert (ret != NULL);\n      bgp_attr_extra_free (*attr);\n      XFREE (MTYPE_ATTR, *attr);\n      *attr = NULL;\n    }\n  bgp_attr_unintern_sub (&tmp);\n  bgp_attr_extra_free (&tmp);\n}", "target": 0}
{"code": "static uint8_t *extend_raw_data(LHAFileHeader **header,\n                                LHAInputStream *stream,\n                                size_t nbytes)\n{\n\tLHAFileHeader *new_header;\n\tsize_t new_raw_len;\n\tuint8_t *result;\n\tif (nbytes > LEVEL_3_MAX_HEADER_LEN) {\n\t\treturn NULL;\n\t}\n\tnew_raw_len = RAW_DATA_LEN(header) + nbytes;\n\tnew_header = realloc(*header, sizeof(LHAFileHeader) + new_raw_len);\n\tif (new_header == NULL) {\n\t\treturn NULL;\n\t}\n\t*header = new_header;\n\tnew_header->raw_data = (uint8_t *) (new_header + 1);\n\tresult = new_header->raw_data + new_header->raw_data_len;\n\tif (!lha_input_stream_read(stream, result, nbytes)) {\n\t\treturn NULL;\n\t}\n\tnew_header->raw_data_len = new_raw_len;\n\treturn result;\n}", "target": 0}
{"code": "static inline void blk_mq_tag_set_rq(struct blk_mq_hw_ctx *hctx,\n\t\tunsigned int tag, struct request *rq)\n{\n\thctx->tags->rqs[tag] = rq;\n}", "target": 0}
{"code": "int nft_expr_inner_parse(const struct nft_ctx *ctx, const struct nlattr *nla,\n\t\t\t struct nft_expr_info *info)\n{\n\tstruct nlattr *tb[NFTA_EXPR_MAX + 1];\n\tconst struct nft_expr_type *type;\n\tint err;\n\terr = nla_parse_nested_deprecated(tb, NFTA_EXPR_MAX, nla,\n\t\t\t\t\t  nft_expr_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\tif (!tb[NFTA_EXPR_DATA])\n\t\treturn -EINVAL;\n\ttype = __nft_expr_type_get(ctx->family, tb[NFTA_EXPR_NAME]);\n\tif (!type)\n\t\treturn -ENOENT;\n\tif (!type->inner_ops)\n\t\treturn -EOPNOTSUPP;\n\terr = nla_parse_nested_deprecated(info->tb, type->maxattr,\n\t\t\t\t\t  tb[NFTA_EXPR_DATA],\n\t\t\t\t\t  type->policy, NULL);\n\tif (err < 0)\n\t\tgoto err_nla_parse;\n\tinfo->attr = nla;\n\tinfo->ops = type->inner_ops;\n\treturn 0;\nerr_nla_parse:\n\treturn err;\n}", "target": 1}
{"code": "static inline void pipe_buf_get(struct pipe_inode_info *pipe,\n\t\t\t\tstruct pipe_buffer *buf)\n{\n\tbuf->ops->get(pipe, buf);\n}", "target": 1}
{"code": "static inline void ModulateHSL(const double percent_hue,\n  const double percent_saturation,const double percent_lightness,double *red,\n  double *green,double *blue)\n{\n  double\n    hue,\n    lightness,\n    saturation;\n  ConvertRGBToHSL(*red,*green,*blue,&hue,&saturation,&lightness);\n  hue+=0.5*(0.01*percent_hue-1.0);\n  saturation*=0.01*percent_saturation;\n  lightness*=0.01*percent_lightness;\n  ConvertHSLToRGB(hue,saturation,lightness,red,green,blue);\n}", "target": 0}
{"code": "void ___might_sleep(const char *file, int line, int preempt_offset)\n{\n\tstatic unsigned long prev_jiffy;\t\n\trcu_sleep_check(); \n\tif ((preempt_count_equals(preempt_offset) && !irqs_disabled() &&\n\t     !is_idle_task(current)) ||\n\t    system_state != SYSTEM_RUNNING || oops_in_progress)\n\t\treturn;\n\tif (time_before(jiffies, prev_jiffy + HZ) && prev_jiffy)\n\t\treturn;\n\tprev_jiffy = jiffies;\n\tprintk(KERN_ERR\n\t\t\"BUG: sleeping function called from invalid context at %s:%d\\n\",\n\t\t\tfile, line);\n\tprintk(KERN_ERR\n\t\t\"in_atomic(): %d, irqs_disabled(): %d, pid: %d, name: %s\\n\",\n\t\t\tin_atomic(), irqs_disabled(),\n\t\t\tcurrent->pid, current->comm);\n\tif (task_stack_end_corrupted(current))\n\t\tprintk(KERN_EMERG \"Thread overran stack, or stack corrupted\\n\");\n\tdebug_show_held_locks(current);\n\tif (irqs_disabled())\n\t\tprint_irqtrace_events(current);\n#ifdef CONFIG_DEBUG_PREEMPT\n\tif (!preempt_count_equals(preempt_offset)) {\n\t\tpr_err(\"Preemption disabled at:\");\n\t\tprint_ip_sym(current->preempt_disable_ip);\n\t\tpr_cont(\"\\n\");\n\t}\n#endif\n\tdump_stack();\n}", "target": 0}
{"code": "find_entry_only(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n\tback_txn *txn\n)\n{\n\treturn( find_entry_internal( pb, be, addr, 0, txn, FE_REALLY_INTERNAL ) );\n}", "target": 1}
{"code": "GF_Err text_box_size(GF_Box *s)\n{\n\tGF_TextSampleEntryBox *ptr = (GF_TextSampleEntryBox*)s;\n\ts->size += 51 + 1;\n\tif (ptr->textName)\n\t\ts->size += strlen(ptr->textName);\n\treturn GF_OK;\n}", "target": 1}
{"code": "GF_Err video_sample_entry_box_size(GF_Box *s)\n{\n\tGF_Box *b;\n\tu32 pos=0;\n\tGF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;\n\tgf_isom_video_sample_entry_size((GF_VisualSampleEntryBox *)s);\n\tgf_isom_check_position(s, (GF_Box *)ptr->esd, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_3gpp, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->avc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->svc_config, &pos);\n\tif (ptr->mvc_config) {\n\t\tgf_isom_check_position(s, gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_VWID), &pos);\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->mvc_config, &pos);\n\t}\n\tgf_isom_check_position(s, (GF_Box *)ptr->hevc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->lhvc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->vvc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->av1_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->vp_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->jp2h, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->dovi_config, &pos);\n\tb = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_ST3D);\n\tif (b) gf_isom_check_position(s, b, &pos);\n\tb = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_SV3D);\n\tif (b) gf_isom_check_position(s, b, &pos);\n\treturn GF_OK;\n}", "target": 1}
{"code": "local void init_block(s)\n    deflate_state *s;\n{\n    int n; \n    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;\n    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;\n    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;\n    s->dyn_ltree[END_BLOCK].Freq = 1;\n    s->opt_len = s->static_len = 0L;\n    s->last_lit = s->matches = 0;\n}", "target": 1}
{"code": "GF_Err Media_CheckDataEntry(GF_MediaBox *mdia, u32 dataEntryIndex)\n{\n\tGF_DataEntryURLBox *entry;\n\tGF_DataMap *map;\n\tGF_Err e;\n\tif (!mdia || !dataEntryIndex || dataEntryIndex > gf_list_count(mdia->information->dataInformation->dref->child_boxes)) return GF_BAD_PARAM;\n\tentry = (GF_DataEntryURLBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataEntryIndex - 1);\n\tif (!entry) return GF_ISOM_INVALID_FILE;\n\tif (entry->flags == 1) return GF_OK;\n\tif (entry->type == GF_ISOM_BOX_TYPE_URN) return GF_NOT_SUPPORTED;\n\tif (mdia->mediaTrack->moov->mov->openMode == GF_ISOM_OPEN_WRITE) {\n\t\te = gf_isom_datamap_new(entry->location, NULL, GF_ISOM_DATA_MAP_READ, &map);\n\t} else {\n\t\te = gf_isom_datamap_new(entry->location, mdia->mediaTrack->moov->mov->fileName, GF_ISOM_DATA_MAP_READ, &map);\n\t}\n\tif (e) return e;\n\tgf_isom_datamap_del(map);\n\treturn GF_OK;\n}", "target": 1}
{"code": "bgp_capability_restart (struct peer *peer, struct capability_header *caphdr)\n{\n  struct stream *s = BGP_INPUT (peer);\n  u_int16_t restart_flag_time;\n  int restart_bit = 0;\n  size_t end = stream_get_getp (s) + caphdr->length;\n  SET_FLAG (peer->cap, PEER_CAP_RESTART_RCV);\n  restart_flag_time = stream_getw(s);\n  if (CHECK_FLAG (restart_flag_time, RESTART_R_BIT))\n    restart_bit = 1;\n  UNSET_FLAG (restart_flag_time, 0xF000);\n  peer->v_gr_restart = restart_flag_time;\n  if (BGP_DEBUG (normal, NORMAL))\n    {\n      zlog_debug (\"%s OPEN has Graceful Restart capability\", peer->host);\n      zlog_debug (\"%s Peer has%srestarted. Restart Time : %d\",\n                  peer->host, restart_bit ? \" \" : \" not \",\n                  peer->v_gr_restart);\n    }\n  while (stream_get_getp (s) + 4 < end)\n    {\n      afi_t afi = stream_getw (s);\n      safi_t safi = stream_getc (s);\n      u_char flag = stream_getc (s);\n      if (!bgp_afi_safi_valid_indices (afi, &safi))\n        {\n          if (BGP_DEBUG (normal, NORMAL))\n            zlog_debug (\"%s Addr-family %d/%d(afi/safi) not supported.\"\n                        \" Ignore the Graceful Restart capability\",\n                        peer->host, afi, safi);\n        }\n      else if (!peer->afc[afi][safi])\n        {\n          if (BGP_DEBUG (normal, NORMAL))\n            zlog_debug (\"%s Addr-family %d/%d(afi/safi) not enabled.\"\n                        \" Ignore the Graceful Restart capability\",\n                        peer->host, afi, safi);\n        }\n      else\n        {\n          if (BGP_DEBUG (normal, NORMAL))\n            zlog_debug (\"%s Address family %s is%spreserved\", peer->host,\n                        afi_safi_print (afi, safi),\n                        CHECK_FLAG (peer->af_cap[afi][safi],\n                                    PEER_CAP_RESTART_AF_PRESERVE_RCV)\n                        ? \" \" : \" not \");\n          SET_FLAG (peer->af_cap[afi][safi], PEER_CAP_RESTART_AF_RCV);\n          if (CHECK_FLAG (flag, RESTART_F_BIT))\n            SET_FLAG (peer->af_cap[afi][safi], PEER_CAP_RESTART_AF_PRESERVE_RCV);\n        }\n    }\n  return 0;\n}", "target": 0}
{"code": "ikev1_sig_print(netdissect_options *ndo, u_char tpay _U_,\n\t\tconst struct isakmp_gen *ext, u_int item_len _U_,\n\t\tconst u_char *ep _U_, uint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_SIG)));\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_SIG)));\n\treturn NULL;\n}", "target": 0}
{"code": "static void pageset_init(struct per_cpu_pageset *p)\n{\n\tstruct per_cpu_pages *pcp;\n\tint migratetype;\n\tmemset(p, 0, sizeof(*p));\n\tpcp = &p->pcp;\n\tpcp->count = 0;\n\tfor (migratetype = 0; migratetype < MIGRATE_PCPTYPES; migratetype++)\n\t\tINIT_LIST_HEAD(&pcp->lists[migratetype]);\n}", "target": 0}
{"code": "FramebufferModel::~FramebufferModel()\n{\n    delete[] m_pixelBuffer;\n}", "target": 1}
{"code": "static int xfrm_dump_policy(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\tBUILD_BUG_ON(sizeof(struct xfrm_policy_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\tif (!cb->args[0]) {\n\t\tcb->args[0] = 1;\n\t\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\n\t}\n\t(void) xfrm_policy_walk(net, walk, dump_one_policy, &info);\n\treturn skb->len;\n}", "target": 1}
{"code": "ossl_cipher_initialize(VALUE self, VALUE str)\n{\n    EVP_CIPHER_CTX *ctx;\n    const EVP_CIPHER *cipher;\n    char *name;\n    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };\n    name = StringValueCStr(str);\n    GetCipherInit(self, ctx);\n    if (ctx) {\n\tossl_raise(rb_eRuntimeError, \"Cipher already inititalized!\");\n    }\n    AllocCipher(self, ctx);\n    if (!(cipher = EVP_get_cipherbyname(name))) {\n\tossl_raise(rb_eRuntimeError, \"unsupported cipher algorithm (%\"PRIsVALUE\")\", str);\n    }\n    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)\n\tossl_raise(eCipherError, NULL);\n    return self;\n}", "target": 1}
{"code": "static void cleanup_timers(struct list_head *head,\n\t\t\t   cputime_t utime, cputime_t stime,\n\t\t\t   unsigned long long sum_exec_runtime)\n{\n\tstruct cpu_timer_list *timer, *next;\n\tcputime_t ptime = cputime_add(utime, stime);\n\tlist_for_each_entry_safe(timer, next, head, entry) {\n\t\tlist_del_init(&timer->entry);\n\t\tif (cputime_lt(timer->expires.cpu, ptime)) {\n\t\t\ttimer->expires.cpu = cputime_zero;\n\t\t} else {\n\t\t\ttimer->expires.cpu = cputime_sub(timer->expires.cpu,\n\t\t\t\t\t\t\t ptime);\n\t\t}\n\t}\n\t++head;\n\tlist_for_each_entry_safe(timer, next, head, entry) {\n\t\tlist_del_init(&timer->entry);\n\t\tif (cputime_lt(timer->expires.cpu, utime)) {\n\t\t\ttimer->expires.cpu = cputime_zero;\n\t\t} else {\n\t\t\ttimer->expires.cpu = cputime_sub(timer->expires.cpu,\n\t\t\t\t\t\t\t utime);\n\t\t}\n\t}\n\t++head;\n\tlist_for_each_entry_safe(timer, next, head, entry) {\n\t\tlist_del_init(&timer->entry);\n\t\tif (timer->expires.sched < sum_exec_runtime) {\n\t\t\ttimer->expires.sched = 0;\n\t\t} else {\n\t\t\ttimer->expires.sched -= sum_exec_runtime;\n\t\t}\n\t}\n}", "target": 0}
{"code": "int gru_handle_user_call_os(unsigned long cb)\n{\n\tstruct gru_tlb_fault_handle *tfh;\n\tstruct gru_thread_state *gts;\n\tvoid *cbk;\n\tint ucbnum, cbrnum, ret = -EINVAL;\n\tSTAT(call_os);\n\tucbnum = get_cb_number((void *)cb);\n\tif ((cb & (GRU_HANDLE_STRIDE - 1)) || ucbnum >= GRU_NUM_CB)\n\t\treturn -EINVAL;\n\tgts = gru_find_lock_gts(cb);\n\tif (!gts)\n\t\treturn -EINVAL;\n\tgru_dbg(grudev, \"address 0x%lx, gid %d, gts 0x%p\\n\", cb, gts->ts_gru ? gts->ts_gru->gs_gid : -1, gts);\n\tif (ucbnum >= gts->ts_cbr_au_count * GRU_CBR_AU_SIZE)\n\t\tgoto exit;\n\tgru_check_context_placement(gts);\n\tif (gts->ts_gru && gts->ts_force_cch_reload) {\n\t\tgts->ts_force_cch_reload = 0;\n\t\tgru_update_cch(gts);\n\t}\n\tret = -EAGAIN;\n\tcbrnum = thread_cbr_number(gts, ucbnum);\n\tif (gts->ts_gru) {\n\t\ttfh = get_tfh_by_index(gts->ts_gru, cbrnum);\n\t\tcbk = get_gseg_base_address_cb(gts->ts_gru->gs_gru_base_vaddr,\n\t\t\t\tgts->ts_ctxnum, ucbnum);\n\t\tret = gru_user_dropin(gts, tfh, cbk);\n\t}\nexit:\n\tgru_unlock_gts(gts);\n\treturn ret;\n}", "target": 1}
{"code": "int jas_stream_gobble(jas_stream_t *stream, int n)\n{\n\tint m;\n\tif (n < 0) {\n\t\tjas_deprecated(\"negative count for jas_stream_gobble\");\n\t}\n\tm = n;\n\tfor (m = n; m > 0; --m) {\n\t\tif (jas_stream_getc(stream) == EOF) {\n\t\t\treturn n - m;\n\t\t}\n\t}\n\treturn n;\n}", "target": 0}
{"code": "size_t copy_page_from_iter(struct page *page, size_t offset, size_t bytes,\n\t\t\t struct iov_iter *i)\n{\n\tsize_t skip, copy, left, wanted;\n\tconst struct iovec *iov;\n\tchar __user *buf;\n\tvoid *kaddr, *to;\n\tif (unlikely(bytes > i->count))\n\t\tbytes = i->count;\n\tif (unlikely(!bytes))\n\t\treturn 0;\n\twanted = bytes;\n\tiov = i->iov;\n\tskip = i->iov_offset;\n\tbuf = iov->iov_base + skip;\n\tcopy = min(bytes, iov->iov_len - skip);\n\tif (!fault_in_pages_readable(buf, copy)) {\n\t\tkaddr = kmap_atomic(page);\n\t\tto = kaddr + offset;\n\t\tleft = __copy_from_user_inatomic(to, buf, copy);\n\t\tcopy -= left;\n\t\tskip += copy;\n\t\tto += copy;\n\t\tbytes -= copy;\n\t\twhile (unlikely(!left && bytes)) {\n\t\t\tiov++;\n\t\t\tbuf = iov->iov_base;\n\t\t\tcopy = min(bytes, iov->iov_len);\n\t\t\tleft = __copy_from_user_inatomic(to, buf, copy);\n\t\t\tcopy -= left;\n\t\t\tskip = copy;\n\t\t\tto += copy;\n\t\t\tbytes -= copy;\n\t\t}\n\t\tif (likely(!bytes)) {\n\t\t\tkunmap_atomic(kaddr);\n\t\t\tgoto done;\n\t\t}\n\t\toffset = to - kaddr;\n\t\tbuf += copy;\n\t\tkunmap_atomic(kaddr);\n\t\tcopy = min(bytes, iov->iov_len - skip);\n\t}\n\tkaddr = kmap(page);\n\tto = kaddr + offset;\n\tleft = __copy_from_user(to, buf, copy);\n\tcopy -= left;\n\tskip += copy;\n\tto += copy;\n\tbytes -= copy;\n\twhile (unlikely(!left && bytes)) {\n\t\tiov++;\n\t\tbuf = iov->iov_base;\n\t\tcopy = min(bytes, iov->iov_len);\n\t\tleft = __copy_from_user(to, buf, copy);\n\t\tcopy -= left;\n\t\tskip = copy;\n\t\tto += copy;\n\t\tbytes -= copy;\n\t}\n\tkunmap(page);\ndone:\n\ti->count -= wanted - bytes;\n\ti->nr_segs -= iov - i->iov;\n\ti->iov = iov;\n\ti->iov_offset = skip;\n\treturn wanted - bytes;\n}", "target": 0}
{"code": "static void pcd_init_units(void)\n{\n\tstruct pcd_unit *cd;\n\tint unit;\n\tpcd_drive_count = 0;\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tstruct gendisk *disk = alloc_disk(1);\n\t\tif (!disk)\n\t\t\tcontinue;\n\t\tdisk->queue = blk_mq_init_sq_queue(&cd->tag_set, &pcd_mq_ops,\n\t\t\t\t\t\t   1, BLK_MQ_F_SHOULD_MERGE);\n\t\tif (IS_ERR(disk->queue)) {\n\t\t\tput_disk(disk);\n\t\t\tdisk->queue = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tINIT_LIST_HEAD(&cd->rq_list);\n\t\tdisk->queue->queuedata = cd;\n\t\tblk_queue_bounce_limit(disk->queue, BLK_BOUNCE_HIGH);\n\t\tcd->disk = disk;\n\t\tcd->pi = &cd->pia;\n\t\tcd->present = 0;\n\t\tcd->last_sense = 0;\n\t\tcd->changed = 1;\n\t\tcd->drive = (*drives[unit])[D_SLV];\n\t\tif ((*drives[unit])[D_PRT])\n\t\t\tpcd_drive_count++;\n\t\tcd->name = &cd->info.name[0];\n\t\tsnprintf(cd->name, sizeof(cd->info.name), \"%s%d\", name, unit);\n\t\tcd->info.ops = &pcd_dops;\n\t\tcd->info.handle = cd;\n\t\tcd->info.speed = 0;\n\t\tcd->info.capacity = 1;\n\t\tcd->info.mask = 0;\n\t\tdisk->major = major;\n\t\tdisk->first_minor = unit;\n\t\tstrcpy(disk->disk_name, cd->name);\t\n\t\tdisk->fops = &pcd_bdops;\n\t\tdisk->flags = GENHD_FL_BLOCK_EVENTS_ON_EXCL_WRITE;\n\t}\n}", "target": 0}
{"code": "static void prefetch_table(const volatile byte *tab, size_t len)\n{\n  size_t i;\n  for (i = 0; i < len; i += 8 * 32)\n    {\n      (void)tab[i + 0 * 32];\n      (void)tab[i + 1 * 32];\n      (void)tab[i + 2 * 32];\n      (void)tab[i + 3 * 32];\n      (void)tab[i + 4 * 32];\n      (void)tab[i + 5 * 32];\n      (void)tab[i + 6 * 32];\n      (void)tab[i + 7 * 32];\n    }\n  (void)tab[len - 1];\n}", "target": 1}
{"code": "void smp_enc_cmpl(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n uint8_t enc_enable = p_data->status;\n  SMP_TRACE_DEBUG(\"%s\", __func__);\n  tSMP_INT_DATA smp_int_data;\n  smp_int_data.status = enc_enable ? SMP_SUCCESS : SMP_ENC_FAIL;\n  smp_sm_event(p_cb, SMP_AUTH_CMPL_EVT, &smp_int_data);\n}", "target": 0}
{"code": "  QInt16() {}", "target": 1}
{"code": "hb_set_symmetric_difference (hb_set_t       *set,\n\t\t\t     const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->symmetric_difference (*other);\n}", "target": 1}
{"code": "static struct pid *good_sigevent(sigevent_t * event)\n{\n\tstruct task_struct *rtn = current->group_leader;\n\tif ((event->sigev_notify & SIGEV_THREAD_ID ) &&\n\t\t(!(rtn = find_task_by_vpid(event->sigev_notify_thread_id)) ||\n\t\t !same_thread_group(rtn, current) ||\n\t\t (event->sigev_notify & ~SIGEV_THREAD_ID) != SIGEV_SIGNAL))\n\t\treturn NULL;\n\tif (((event->sigev_notify & ~SIGEV_THREAD_ID) != SIGEV_NONE) &&\n\t    ((event->sigev_signo <= 0) || (event->sigev_signo > SIGRTMAX)))\n\t\treturn NULL;\n\treturn task_pid(rtn);\n}", "target": 1}
{"code": "  CookieHashMethod(const std::string& key, const std::string& path,\n                   const absl::optional<std::chrono::seconds>& ttl, bool terminal,\n                   const CookieAttributeRefVector attributes)\n      : HashMethodImplBase(terminal), key_(key), path_(path), ttl_(ttl), attributes_(attributes) {}", "target": 1}
{"code": "static int stv06xx_isoc_init(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_host_interface *alt;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\talt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];\n\talt->endpoint[0].desc.wMaxPacketSize =\n\t\tcpu_to_le16(sd->sensor->max_packet_size[gspca_dev->curr_mode]);\n\treturn 0;\n}", "target": 1}
{"code": "static int check_line_charstring(void)\n{\n  char *p = line;\n  while (isspace(*p))\n    p++;\n  return (*p == '/' || (p[0] == 'd' && p[1] == 'u' && p[2] == 'p'));\n}", "target": 1}
{"code": "void vlan_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\tdev->priv_flags\t\t|= IFF_802_1Q_VLAN;\n\tdev->priv_flags\t\t&= ~IFF_XMIT_DST_RELEASE;\n\tdev->tx_queue_len\t= 0;\n\tdev->netdev_ops\t\t= &vlan_netdev_ops;\n\tdev->destructor\t\t= free_netdev;\n\tdev->ethtool_ops\t= &vlan_ethtool_ops;\n\tmemset(dev->broadcast, 0, ETH_ALEN);\n}", "target": 1}
{"code": "static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *segment)\n{\n    int i, length;\n    segment->nb_index_entries = avio_rb32(pb);\n    length = avio_rb32(pb);\n    if(segment->nb_index_entries && length < 11)\n        return AVERROR_INVALIDDATA;\n    if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||\n        !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||\n        !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries))))\n        return AVERROR(ENOMEM);\n    for (i = 0; i < segment->nb_index_entries; i++) {\n        if(avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n        segment->temporal_offset_entries[i] = avio_r8(pb);\n        avio_r8(pb);                                        \n        segment->flag_entries[i] = avio_r8(pb);\n        segment->stream_offset_entries[i] = avio_rb64(pb);\n        avio_skip(pb, length - 11);\n    }\n    return 0;\n}", "target": 0}
{"code": "static OPJ_BOOL opj_j2k_write_sot(opj_j2k_t *p_j2k,\n                                  OPJ_BYTE * p_data,\n                                  OPJ_UINT32 p_total_data_size,\n                                  OPJ_UINT32 * p_data_written,\n                                  const opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager\n                                 )\n{\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n    OPJ_UNUSED(p_stream);\n    OPJ_UNUSED(p_manager);\n    if (p_total_data_size < 12) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Not enough bytes in output buffer to write SOT marker\\n\");\n        return OPJ_FALSE;\n    }\n    opj_write_bytes(p_data, J2K_MS_SOT,\n                    2);                                 \n    p_data += 2;\n    opj_write_bytes(p_data, 10,\n                    2);                                                   \n    p_data += 2;\n    opj_write_bytes(p_data, p_j2k->m_current_tile_number,\n                    2);                        \n    p_data += 2;\n    p_data += 4;\n    opj_write_bytes(p_data,\n                    p_j2k->m_specific_param.m_encoder.m_current_tile_part_number,\n                    1);                        \n    ++p_data;\n    opj_write_bytes(p_data,\n                    p_j2k->m_cp.tcps[p_j2k->m_current_tile_number].m_nb_tile_parts,\n                    1);                      \n    ++p_data;\n#ifdef USE_JPWL\n    assert(0 && \"TODO\");\n#endif \n    * p_data_written = 12;\n    return OPJ_TRUE;\n}", "target": 0}
{"code": "static int rmqueue_bulk(struct zone *zone, unsigned int order,\n\t\t\tunsigned long count, struct list_head *list,\n\t\t\tint migratetype)\n{\n\tint i, alloced = 0;\n\tspin_lock(&zone->lock);\n\tfor (i = 0; i < count; ++i) {\n\t\tstruct page *page = __rmqueue(zone, order, migratetype);\n\t\tif (unlikely(page == NULL))\n\t\t\tbreak;\n\t\tif (unlikely(check_pcp_refill(page)))\n\t\t\tcontinue;\n\t\tlist_add_tail(&page->lru, list);\n\t\talloced++;\n\t\tif (is_migrate_cma(get_pcppage_migratetype(page)))\n\t\t\t__mod_zone_page_state(zone, NR_FREE_CMA_PAGES,\n\t\t\t\t\t      -(1 << order));\n\t}\n\t__mod_zone_page_state(zone, NR_FREE_PAGES, -(i << order));\n\tspin_unlock(&zone->lock);\n\treturn alloced;\n}", "target": 0}
{"code": "int nfc_fw_download(struct nfc_dev *dev, const char *firmware_name)\n{\n\tint rc = 0;\n\tpr_debug(\"%s do firmware %s\\n\", dev_name(&dev->dev), firmware_name);\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->dev_up) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (!dev->ops->fw_download) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto error;\n\t}\n\tdev->fw_download_in_progress = true;\n\trc = dev->ops->fw_download(dev, firmware_name);\n\tif (rc)\n\t\tdev->fw_download_in_progress = false;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "void perf_bp_event(struct perf_event *bp, void *data)\n{\n\tstruct perf_sample_data sample;\n\tstruct pt_regs *regs = data;\n\tperf_sample_data_init(&sample, bp->attr.bp_addr, 0);\n\tif (!bp->hw.state && !perf_exclude_event(bp, regs))\n\t\tperf_swevent_event(bp, 1, &sample, regs);\n}", "target": 0}
{"code": "static char *create_output_name(unsigned char *fname, unsigned char *dir,\n\t\t\t int lower, int isunix, int utf8)\n{\n  unsigned char *p, *name, c, *fe, sep, slash;\n  unsigned int x;\n  sep   = (isunix) ? '/'  : '\\\\'; \n  slash = (isunix) ? '\\\\' : '/';  \n  x = strlen((char *) fname);\n  if (utf8) x *= 3;\n  if (dir) x += strlen((char *) dir);\n  if (!(name = (unsigned char *) malloc(x + 2))) {\n    fprintf(stderr, \"out of memory!\\n\");\n    return NULL;\n  }\n  *name = '\\0';\n  if (dir) {\n    strcpy((char *) name, (char *) dir);\n    strcat((char *) name, \"/\");\n  }\n  while (*fname == sep) fname++;\n  p = &name[strlen((char *)name)];\n  fe = &fname[strlen((char *)fname)];\n  if (utf8) {\n    do {\n      if (fname >= fe) {\n\tfree(name);\n\treturn NULL;\n      }\n      if ((c = *fname++) < 0x80) x = c;\n      else {\n\tif ((c >= 0xC0) && (c < 0xE0)) {\n\t  x = (c & 0x1F) << 6;\n\t  x |= *fname++ & 0x3F;\n\t}\n\telse if ((c >= 0xE0) && (c < 0xF0)) {\n\t  x = (c & 0xF) << 12;\n\t  x |= (*fname++ & 0x3F) << 6;\n\t  x |= *fname++ & 0x3F;\n\t}\n\telse x = '?';\n      }\n      if      (x == sep)   x = '/';\n      else if (x == slash) x = '\\\\';\n      else if (lower)      x = (unsigned int) tolower((int) x);\n      if (x < 0x80) {\n\t*p++ = (unsigned char) x;\n      }\n      else if (x < 0x800) {\n\t*p++ = 0xC0 | (x >> 6);   \n\t*p++ = 0x80 | (x & 0x3F);\n      }\n      else {\n\t*p++ = 0xE0 | (x >> 12);\n\t*p++ = 0x80 | ((x >> 6) & 0x3F);\n\t*p++ = 0x80 | (x & 0x3F);\n      }\n    } while (x);\n  }\n  else {\n    do {\n      c = *fname++;\n      if      (c == sep)   c = '/';\n      else if (c == slash) c = '\\\\';\n      else if (lower)      c = (unsigned char) tolower((int) c);\n    } while ((*p++ = c));\n  }\n  return (char *) name;\n}", "target": 1}
{"code": "static void addrconf_ip6_tnl_config(struct net_device *dev)\n{\n\tstruct inet6_dev *idev;\n\tASSERT_RTNL();\n\tidev = addrconf_add_dev(dev);\n\tif (IS_ERR(idev)) {\n\t\tpr_debug(\"init ip6-ip6: add_dev failed\\n\");\n\t\treturn;\n\t}\n\tip6_tnl_add_linklocal(idev);\n}", "target": 0}
{"code": "bool IsReshapeOpSupported(const TfLiteRegistration* registration,\n                          const TfLiteNode* node, TfLiteContext* context,\n                          int coreml_version) {\n  if (coreml_version >= 3) {\n    return false;\n  }\n  if (node->inputs->size == 1) {\n    const auto* params =\n        reinterpret_cast<TfLiteReshapeParams*>(node->builtin_data);\n    return params->num_dimensions == 3 || params->num_dimensions == 4;\n  }\n  const int kShapeTensor = 1;\n  const auto* shape = GetInput(context, node, kShapeTensor);\n  if (shape->allocation_type != kTfLiteMmapRo) {\n    TF_LITE_KERNEL_LOG(context, \"Reshape has non-const shape.\");\n    return false;\n  }\n  const bool is_shape_tensor =\n      shape->dims->size == 1 && shape->type == kTfLiteInt32;\n  return is_shape_tensor &&\n         (shape->dims->data[0] == 3 || shape->dims->data[0] == 4);\n}", "target": 1}
{"code": "Status OpLevelCostEstimator::PredictFusedBatchNorm(\n    const OpContext& op_context, NodeCosts* node_costs) const {\n  bool found_unknown_shapes = false;\n  const auto& op_info = op_context.op_info;\n  ConvolutionDimensions dims = OpDimensionsFromInputs(\n      op_info.inputs(0).shape(), op_info, &found_unknown_shapes);\n  const bool is_training = IsTraining(op_info);\n  int64_t ops = 0;\n  const auto rsqrt_cost = Eigen::internal::functor_traits<\n      Eigen::internal::scalar_rsqrt_op<float>>::Cost;\n  if (is_training) {\n    ops = dims.iz * (dims.batch * dims.ix * dims.iy * 4 + 6 + rsqrt_cost);\n  } else {\n    ops = dims.batch * dims.ix * dims.iy * dims.iz * 2;\n  }\n  node_costs->num_compute_ops = ops;\n  const int64_t size_nhwc =\n      CalculateTensorSize(op_info.inputs(0), &found_unknown_shapes);\n  const int64_t size_c =\n      CalculateTensorSize(op_info.inputs(1), &found_unknown_shapes);\n  if (is_training) {\n    node_costs->num_input_bytes_accessed = {size_nhwc, size_c, size_c};\n    node_costs->num_output_bytes_accessed = {size_nhwc, size_c, size_c, size_c,\n                                             size_c};\n    node_costs->internal_read_bytes = size_nhwc;\n  } else {\n    node_costs->num_input_bytes_accessed = {size_nhwc, size_c, size_c, size_c,\n                                            size_c};\n    node_costs->num_output_bytes_accessed = {size_nhwc};\n  }\n  node_costs->max_memory = node_costs->num_total_output_bytes();\n  if (found_unknown_shapes) {\n    node_costs->inaccurate = true;\n    node_costs->num_nodes_with_unknown_shapes = 1;\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "int cap_bprm_set_creds(struct linux_binprm *bprm)\n{\n\tconst struct cred *old = current_cred();\n\tstruct cred *new = bprm->cred;\n\tbool effective, has_cap = false;\n\tint ret;\n\teffective = false;\n\tret = get_file_caps(bprm, &effective, &has_cap);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!issecure(SECURE_NOROOT)) {\n\t\tif (has_cap && new->uid != 0 && new->euid == 0) {\n\t\t\twarn_setuid_and_fcaps_mixed(bprm->filename);\n\t\t\tgoto skip;\n\t\t}\n\t\tif (new->euid == 0 || new->uid == 0) {\n\t\t\tnew->cap_permitted = cap_combine(old->cap_bset,\n\t\t\t\t\t\t\t old->cap_inheritable);\n\t\t}\n\t\tif (new->euid == 0)\n\t\t\teffective = true;\n\t}\nskip:\n\tif (!cap_issubset(new->cap_permitted, old->cap_permitted))\n\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\tif ((new->euid != old->uid ||\n\t     new->egid != old->gid ||\n\t     !cap_issubset(new->cap_permitted, old->cap_permitted)) &&\n\t    bprm->unsafe & ~LSM_UNSAFE_PTRACE_CAP) {\n\t\tif (!capable(CAP_SETUID)) {\n\t\t\tnew->euid = new->uid;\n\t\t\tnew->egid = new->gid;\n\t\t}\n\t\tnew->cap_permitted = cap_intersect(new->cap_permitted,\n\t\t\t\t\t\t   old->cap_permitted);\n\t}\n\tnew->suid = new->fsuid = new->euid;\n\tnew->sgid = new->fsgid = new->egid;\n\tif (effective)\n\t\tnew->cap_effective = new->cap_permitted;\n\telse\n\t\tcap_clear(new->cap_effective);\n\tbprm->cap_effective = effective;\n\tif (!cap_isclear(new->cap_effective)) {\n\t\tif (!cap_issubset(CAP_FULL_SET, new->cap_effective) ||\n\t\t    new->euid != 0 || new->uid != 0 ||\n\t\t    issecure(SECURE_NOROOT)) {\n\t\t\tret = audit_log_bprm_fcaps(bprm, new, old);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\tnew->securebits &= ~issecure_mask(SECURE_KEEP_CAPS);\n\treturn 0;\n}", "target": 0}
{"code": "nautilus_file_mark_desktop_file_executable (GFile              *file,\n                                            GtkWindow          *parent_window,\n                                            gboolean            interactive,\n                                            NautilusOpCallback  done_callback,\n                                            gpointer            done_callback_data)\n{\n    GTask *task;\n    MarkTrustedJob *job;\n    job = op_job_new (MarkTrustedJob, parent_window);\n    job->file = g_object_ref (file);\n    job->interactive = interactive;\n    job->done_callback = done_callback;\n    job->done_callback_data = done_callback_data;\n    task = g_task_new (NULL, NULL, mark_desktop_file_executable_task_done, job);\n    g_task_set_task_data (task, job, NULL);\n    g_task_run_in_thread (task, mark_desktop_file_executable_task_thread_func);\n    g_object_unref (task);\n}", "target": 0}
{"code": "static void bprm_fill_uid(struct linux_binprm *bprm)\n{\n\tstruct inode *inode;\n\tunsigned int mode;\n\tkuid_t uid;\n\tkgid_t gid;\n\tbprm->cred->euid = current_euid();\n\tbprm->cred->egid = current_egid();\n\tif (bprm->file->f_path.mnt->mnt_flags & MNT_NOSUID)\n\t\treturn;\n\tif (task_no_new_privs(current))\n\t\treturn;\n\tinode = file_inode(bprm->file);\n\tmode = READ_ONCE(inode->i_mode);\n\tif (!(mode & (S_ISUID|S_ISGID)))\n\t\treturn;\n\tmutex_lock(&inode->i_mutex);\n\tmode = inode->i_mode;\n\tuid = inode->i_uid;\n\tgid = inode->i_gid;\n\tmutex_unlock(&inode->i_mutex);\n\tif (!kuid_has_mapping(bprm->cred->user_ns, uid) ||\n\t\t !kgid_has_mapping(bprm->cred->user_ns, gid))\n\t\treturn;\n\tif (mode & S_ISUID) {\n\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\tbprm->cred->euid = uid;\n\t}\n\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\tbprm->cred->egid = gid;\n\t}\n}", "target": 0}
{"code": "gx_fill_edgebuffer_app(gx_device       * pdev,\n                 const gx_device_color * pdevc,\n                       gx_edgebuffer   * edgebuffer,\n                       int               log_op)\n{\n    int i, code;\n    for (i=0; i < edgebuffer->height; i++) {\n        int *row    = &edgebuffer->table[edgebuffer->index[i]];\n        int  rowlen = *row++;\n        int  left, right;\n        while (rowlen > 0) {\n            left  = *row++;\n            right = *row++;\n            left  = fixed2int(left);\n            right = fixed2int(right + fixed_1 - 1);\n            rowlen -= 2;\n            right -= left;\n            if (right > 0) {\n                if (log_op < 0)\n                    code = dev_proc(pdev, fill_rectangle)(pdev, left, edgebuffer->base+i, right, 1, pdevc->colors.pure);\n                else\n                    code = gx_fill_rectangle_device_rop(left, edgebuffer->base+i, right, 1, pdevc, pdev, (gs_logical_operation_t)log_op);\n                if (code < 0)\n                    return code;\n            }\n        }\n    }\n    return 0;\n}", "target": 0}
{"code": "static int pgpVerifySelf(pgpDigParams key, pgpDigParams selfsig,\n\t\t\tconst struct pgpPkt *all, int i)\n{\n    int rc = -1;\n    DIGEST_CTX hash = NULL;\n    switch (selfsig->sigtype) {\n    case PGPSIGTYPE_SUBKEY_BINDING:\n\thash = rpmDigestInit(selfsig->hash_algo, 0);\n\tif (hash) {\n\t    rc = hashKey(hash, &all[0], PGPTAG_PUBLIC_KEY);\n\t    if (!rc)\n\t\trc = hashKey(hash, &all[i-1], PGPTAG_PUBLIC_SUBKEY);\n\t}\n\tbreak;\n    default:\n\trc = 0;\n\tbreak;\n    }\n    if (hash && rc == 0)\n\trc = pgpVerifySignature(key, selfsig, hash);\n    rpmDigestFinal(hash, NULL, NULL, 0);\n    return rc;\n}", "target": 0}
{"code": "    **/\n    CImg<T>& log2() {\n      if (is_empty()) return *this;\n      cimg_pragma_openmp(parallel for cimg_openmp_if(size()>=4096))\n      cimg_rof(*this,ptrd,T) *ptrd = (T)cimg::log2((double)*ptrd);\n      return *this;", "target": 0}
{"code": "static int llc_ui_autobind(struct socket *sock, struct sockaddr_llc *addr)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tstruct llc_sap *sap;\n\tint rc = -EINVAL;\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\tif (!addr->sllc_arphrd)\n\t\taddr->sllc_arphrd = ARPHRD_ETHER;\n\tif (addr->sllc_arphrd != ARPHRD_ETHER)\n\t\tgoto out;\n\trc = -ENODEV;\n\tif (sk->sk_bound_dev_if) {\n\t\tllc->dev = dev_get_by_index(&init_net, sk->sk_bound_dev_if);\n\t\tif (llc->dev && addr->sllc_arphrd != llc->dev->type) {\n\t\t\tdev_put(llc->dev);\n\t\t\tllc->dev = NULL;\n\t\t}\n\t} else\n\t\tllc->dev = dev_getfirstbyhwtype(&init_net, addr->sllc_arphrd);\n\tif (!llc->dev)\n\t\tgoto out;\n\tnetdev_tracker_alloc(llc->dev, &llc->dev_tracker, GFP_KERNEL);\n\trc = -EUSERS;\n\tllc->laddr.lsap = llc_ui_autoport();\n\tif (!llc->laddr.lsap)\n\t\tgoto out;\n\trc = -EBUSY; \n\tsap = llc_sap_open(llc->laddr.lsap, NULL);\n\tif (!sap)\n\t\tgoto out;\n\tmemcpy(llc->laddr.mac, llc->dev->dev_addr, IFHWADDRLEN);\n\tmemcpy(&llc->addr, addr, sizeof(llc->addr));\n\tllc_sap_add_socket(sap, sk);\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\trc = 0;\nout:\n\tif (rc) {\n\t\tdev_put_track(llc->dev, &llc->dev_tracker);\n\t\tllc->dev = NULL;\n\t}\n\treturn rc;\n}", "target": 0}
{"code": "dup_dest_constraint_hop(const struct dest_constraint_hop *dch,\n    struct dest_constraint_hop *out)\n{\n\tu_int i;\n\tint r;\n\tout->user = dch->user == NULL ? NULL : xstrdup(dch->user);\n\tout->hostname = dch->hostname == NULL ? NULL : xstrdup(dch->hostname);\n\tout->is_ca = dch->is_ca;\n\tout->nkeys = dch->nkeys;\n\tout->keys = out->nkeys == 0 ? NULL :\n\t    xcalloc(out->nkeys, sizeof(*out->keys));\n\tout->key_is_ca = out->nkeys == 0 ? NULL :\n\t    xcalloc(out->nkeys, sizeof(*out->key_is_ca));\n\tfor (i = 0; i < dch->nkeys; i++) {\n\t\tif (dch->keys[i] != NULL &&\n\t\t    (r = sshkey_from_private(dch->keys[i],\n\t\t    &(out->keys[i]))) != 0)\n\t\t\tfatal_fr(r, \"copy key\");\n\t\tout->key_is_ca[i] = dch->key_is_ca[i];\n\t}\n}", "target": 0}
{"code": "void CSecurityTLS::initGlobal()\n{\n  static bool globalInitDone = false;\n  if (!globalInitDone) {\n    gnutls_global_init();\n    globalInitDone = true;\n  }\n}", "target": 1}
{"code": "static int dcbnl_getperm_hwaddr(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t\tu32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tu8 perm_addr[MAX_ADDR_LEN];\n\tif (!netdev->dcbnl_ops->getpermhwaddr)\n\t\treturn -EOPNOTSUPP;\n\tmemset(perm_addr, 0, sizeof(perm_addr));\n\tnetdev->dcbnl_ops->getpermhwaddr(netdev, perm_addr);\n\treturn nla_put(skb, DCB_ATTR_PERM_HWADDR, sizeof(perm_addr), perm_addr);\n}", "target": 0}
{"code": "static int sqfs_disk_read(__u32 block, __u32 nr_blocks, void *buf)\n{\n\tulong ret;\n\tif (!ctxt.cur_dev)\n\t\treturn -1;\n\tret = blk_dread(ctxt.cur_dev, ctxt.cur_part_info.start + block,\n\t\t\tnr_blocks, buf);\n\tif (ret != nr_blocks)\n\t\treturn -1;\n\treturn ret;\n}", "target": 0}
{"code": "IW_IMPL(int) iw_get_i32le(const iw_byte *b)\n{\n\treturn (iw_int32)(iw_uint32)(b[0] | (b[1]<<8) | (b[2]<<16) | (b[3]<<24));\n}", "target": 1}
{"code": "Status KernelAndDeviceOp::Run(\n    ScopedStepContainer* step_container, const EagerKernelArgs& inputs,\n    std::vector<EagerKernelRet>* outputs,\n    CancellationManager* cancellation_manager,\n    const absl::optional<EagerRemoteFunctionParams>& remote_func_params) {\n  OpKernelContext::Params params;\n  params.device = device_;\n  params.frame_iter = FrameAndIter(0, 0);\n  params.inputs = inputs.GetTensorValues();\n  params.op_kernel = kernel_.get();\n  params.resource_manager = device_->resource_manager();\n  params.input_alloc_attrs = &input_alloc_attrs_;\n  params.output_attr_array = output_alloc_attrs_.data();\n  params.function_library = flr_;\n  params.slice_reader_cache = &slice_reader_cache_;\n  params.rendezvous = rendezvous_;\n  OpExecutionState* op_execution_state = nullptr;\n  CancellationManager default_cancellation_manager;\n  if (cancellation_manager) {\n    params.cancellation_manager = cancellation_manager;\n  } else if (kernel_->is_deferred()) {\n    op_execution_state = new OpExecutionState;\n    params.cancellation_manager = &op_execution_state->cancellation_manager;\n    params.inc_num_deferred_ops_function = [op_execution_state]() {\n      op_execution_state->Ref();\n    };\n    params.dec_num_deferred_ops_function = [op_execution_state]() {\n      op_execution_state->Unref();\n    };\n  } else {\n    params.cancellation_manager = &default_cancellation_manager;\n  }\n  params.log_memory = log_memory_;\n  params.runner = get_runner();\n  params.step_container =\n      step_container == nullptr ? &step_container_ : step_container;\n  auto step_container_cleanup = gtl::MakeCleanup([step_container, this] {\n    if (step_container == nullptr) {\n      this->step_container_.CleanUp();\n    }\n  });\n  params.collective_executor =\n      collective_executor_ ? collective_executor_->get() : nullptr;\n  OpKernelContext context(&params);\n  {\n    port::ScopedFlushDenormal flush;\n    port::ScopedSetRound round(FE_TONEAREST);\n    profiler::AnnotatedTraceMe activity(\n        [&] { return kernel_->TraceString(context, false); },\n        profiler::TraceMeLevel::kInfo);\n    device_->Compute(kernel_.get(), &context);\n  }\n  if (op_execution_state != nullptr) {\n    op_execution_state->Unref();\n  }\n  if (!context.status().ok()) return context.status();\n  if (outputs != nullptr) {\n    outputs->clear();\n    for (int i = 0; i < context.num_outputs(); ++i) {\n      outputs->push_back(Tensor(*context.mutable_output(i)));\n    }\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "  explicit QuantizeAndDequantizeOp(OpKernelConstruction* ctx) : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"signed_input\", &signed_input_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"num_bits\", &num_bits_));\n    OP_REQUIRES(ctx, num_bits_ > 0 && num_bits_ < (signed_input_ ? 62 : 63),\n                errors::InvalidArgument(\"num_bits is out of range: \", num_bits_,\n                                        \" with signed_input_ \", signed_input_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"range_given\", &range_given_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"input_min\", &input_min_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"input_max\", &input_max_));\n    if (range_given_) {\n      OP_REQUIRES(\n          ctx, input_min_ <= input_max_,\n          errors::InvalidArgument(\"Invalid range: input_min \", input_min_,\n                                  \" > input_max \", input_max_));\n    }\n  }", "target": 1}
{"code": "static bool msr_mtrr_valid(unsigned msr)\n{\n\tswitch (msr) {\n\tcase 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1:\n\tcase MSR_MTRRfix64K_00000:\n\tcase MSR_MTRRfix16K_80000:\n\tcase MSR_MTRRfix16K_A0000:\n\tcase MSR_MTRRfix4K_C0000:\n\tcase MSR_MTRRfix4K_C8000:\n\tcase MSR_MTRRfix4K_D0000:\n\tcase MSR_MTRRfix4K_D8000:\n\tcase MSR_MTRRfix4K_E0000:\n\tcase MSR_MTRRfix4K_E8000:\n\tcase MSR_MTRRfix4K_F0000:\n\tcase MSR_MTRRfix4K_F8000:\n\tcase MSR_MTRRdefType:\n\tcase MSR_IA32_CR_PAT:\n\t\treturn true;\n\tcase 0x2f8:\n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "static const char *ifsection(cmd_parms *cmd, void *mconfig, const char *arg)\n{\n    const char *errmsg;\n    const char *endp = ap_strrchr_c(arg, '>');\n    int old_overrides = cmd->override;\n    char *old_path = cmd->path;\n    core_dir_config *conf;\n    const command_rec *thiscmd = cmd->cmd;\n    ap_conf_vector_t *new_if_conf = ap_create_per_dir_config(cmd->pool);\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);\n    const char *condition;\n    const char *expr_err;\n    if (err != NULL) {\n        return err;\n    }\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n    arg = apr_pstrndup(cmd->temp_pool, arg, endp - arg);\n    cmd->path = \"*If\";\n    if (!old_path) {\n        cmd->override = OR_ALL|ACCESS_CONF;\n    }\n    conf = ap_set_config_vectors(cmd->server, new_if_conf, cmd->path,\n                                 &core_module, cmd->pool);\n    if (cmd->cmd->cmd_data == COND_IF)\n        conf->condition_ifelse = AP_CONDITION_IF;\n    else if (cmd->cmd->cmd_data == COND_ELSEIF)\n        conf->condition_ifelse = AP_CONDITION_ELSEIF;\n    else if (cmd->cmd->cmd_data == COND_ELSE)\n        conf->condition_ifelse = AP_CONDITION_ELSE;\n    else\n        ap_assert(0);\n    if (conf->condition_ifelse == AP_CONDITION_ELSE) {\n        if (arg[0])\n            return \"<Else> does not take an argument\";\n    }\n    else {\n        if (!arg[0])\n            return missing_container_arg(cmd);\n        condition = ap_getword_conf(cmd->pool, &arg);\n        conf->condition = ap_expr_parse_cmd(cmd, condition, 0, &expr_err, NULL);\n        if (expr_err)\n            return apr_psprintf(cmd->pool, \"Cannot parse condition clause: %s\",\n                                expr_err);\n    }\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, new_if_conf);\n    if (errmsg != NULL)\n        return errmsg;\n    conf->d = cmd->path;\n    conf->d_is_fnmatch = 0;\n    conf->r = NULL;\n    errmsg = ap_add_if_conf(cmd->pool, (core_dir_config *)mconfig, new_if_conf);\n    if (errmsg != NULL)\n        return errmsg;\n    if (*arg != '\\0') {\n        return apr_pstrcat(cmd->pool, \"Multiple \", thiscmd->name,\n                           \"> arguments not supported.\", NULL);\n    }\n    cmd->path = old_path;\n    cmd->override = old_overrides;\n    return NULL;\n}", "target": 0}
{"code": "same_url_p(ParsedURL *pu1, ParsedURL *pu2)\n{\n    return (pu1->scheme == pu2->scheme && pu1->port == pu2->port &&\n\t    (pu1->host ? pu2->host ? !strcasecmp(pu1->host, pu2->host) : 0 : 1)\n\t    && (pu1->file ? pu2->\n\t\tfile ? !strcmp(pu1->file, pu2->file) : 0 : 1));\n}", "target": 0}
{"code": "static void tcp_dsack_set(struct sock *sk, u32 seq, u32 end_seq)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tif (tcp_is_sack(tp) && sysctl_tcp_dsack) {\n\t\tint mib_idx;\n\t\tif (before(seq, tp->rcv_nxt))\n\t\t\tmib_idx = LINUX_MIB_TCPDSACKOLDSENT;\n\t\telse\n\t\t\tmib_idx = LINUX_MIB_TCPDSACKOFOSENT;\n\t\tNET_INC_STATS_BH(sock_net(sk), mib_idx);\n\t\ttp->rx_opt.dsack = 1;\n\t\ttp->duplicate_sack[0].start_seq = seq;\n\t\ttp->duplicate_sack[0].end_seq = end_seq;\n\t}\n}", "target": 0}
{"code": "static void adpt_ia64_info(sysInfo_S* si)\n{\n\tsi->processorType = PROC_IA64;\n}", "target": 1}
{"code": "void rfbClientCleanup(rfbClient* client) {\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n  int i;\n  for ( i = 0; i < 4; i++ ) {\n    if (client->zlibStreamActive[i] == TRUE ) {\n      if (inflateEnd (&client->zlibStream[i]) != Z_OK &&\n\t  client->zlibStream[i].msg != NULL)\n\trfbClientLog(\"inflateEnd: %s\\n\", client->zlibStream[i].msg);\n    }\n  }\n  if ( client->decompStreamInited == TRUE ) {\n    if (inflateEnd (&client->decompStream) != Z_OK &&\n\tclient->decompStream.msg != NULL)\n      rfbClientLog(\"inflateEnd: %s\\n\", client->decompStream.msg );\n  }\n#endif\n  if (client->ultra_buffer)\n    free(client->ultra_buffer);\n  if (client->raw_buffer)\n    free(client->raw_buffer);\n  FreeTLS(client);\n  while (client->clientData) {\n    rfbClientData* next = client->clientData->next;\n    free(client->clientData);\n    client->clientData = next;\n  }\n  free(client->vncRec);\n  if (client->sock != RFB_INVALID_SOCKET)\n    rfbCloseSocket(client->sock);\n  if (client->listenSock != RFB_INVALID_SOCKET)\n    rfbCloseSocket(client->listenSock);\n  free(client->desktopName);\n  free(client->serverHost);\n  if (client->destHost)\n    free(client->destHost);\n  if (client->clientAuthSchemes)\n    free(client->clientAuthSchemes);\n#ifdef LIBVNCSERVER_HAVE_SASL\n  if (client->saslSecret)\n    free(client->saslSecret);\n#endif \n#ifdef WIN32\n  if(WSACleanup() != 0) {\n      errno=WSAGetLastError();\n      rfbClientErr(\"Could not terminate Windows Sockets: %s\\n\", strerror(errno));\n  }\n#endif\n  free(client);\n}", "target": 0}
{"code": "SSL_SESSION *SSL_SESSION_dup(const SSL_SESSION *src)\n{\n    return ssl_session_dup(src, 1);\n}", "target": 1}
{"code": "__delta_head_destroy(struct delta_head **delta_head)\n{\n\tdelta_head_destroy(*delta_head);\n}", "target": 1}
{"code": "int64_t BZ2File::readImpl(char * buf, int64_t length) {\n  if (length == 0) {\n    return 0;\n  }\n  assertx(m_bzFile);\n  int len = BZ2_bzread(m_bzFile, buf, length);\n  if (len <= 0) {\n    setEof(true);\n    if (len < 0) {\n      return -1;\n    }\n  }\n  return len;\n}", "target": 1}
{"code": "void __init set_dma_reserve(unsigned long new_dma_reserve)\n{\n\tdma_reserve = new_dma_reserve;\n}", "target": 0}
{"code": "void ssl_update_cache(SSL *s, int mode)\n{\n    int i;\n    if (s->session->session_id_length == 0)\n        return;\n    if (s->server && s->session->sid_ctx_length == 0\n            && (s->verify_mode & SSL_VERIFY_PEER) != 0)\n        return;\n    i = s->session_ctx->session_cache_mode;\n    if ((i & mode) != 0\n        && (!s->hit || SSL_IS_TLS13(s))) {\n        if ((i & SSL_SESS_CACHE_NO_INTERNAL_STORE) == 0\n                && (!SSL_IS_TLS13(s)\n                    || !s->server\n                    || (s->max_early_data > 0\n                        && (s->options & SSL_OP_NO_ANTI_REPLAY) == 0)\n                    || s->session_ctx->remove_session_cb != NULL\n                    || (s->options & SSL_OP_NO_TICKET) != 0))\n            SSL_CTX_add_session(s->session_ctx, s->session);\n        if (s->session_ctx->new_session_cb != NULL) {\n            SSL_SESSION_up_ref(s->session);\n            if (!s->session_ctx->new_session_cb(s, s->session))\n                SSL_SESSION_free(s->session);\n        }\n    }\n    if ((!(i & SSL_SESS_CACHE_NO_AUTO_CLEAR)) && ((i & mode) == mode)) {\n        TSAN_QUALIFIER int *stat;\n        if (mode & SSL_SESS_CACHE_CLIENT)\n            stat = &s->session_ctx->stats.sess_connect_good;\n        else\n            stat = &s->session_ctx->stats.sess_accept_good;\n        if ((ssl_tsan_load(s->session_ctx, stat) & 0xff) == 0xff)\n            SSL_CTX_flush_sessions(s->session_ctx, (unsigned long)time(NULL));\n    }\n}", "target": 1}
{"code": "static bool cma_match_net_dev(const struct rdma_cm_id *id,\n\t\t\t      const struct net_device *net_dev,\n\t\t\t      const struct cma_req_info *req)\n{\n\tconst struct rdma_addr *addr = &id->route.addr;\n\tif (!net_dev)\n\t\treturn (!id->port_num || id->port_num == req->port) &&\n\t\t       (addr->src_addr.ss_family == AF_IB);\n\tif (!cma_is_req_ipv6_ll(req))\n\t\treturn true;\n\tif (net_eq(dev_net(net_dev), addr->dev_addr.net) &&\n\t    (!!addr->dev_addr.bound_dev_if ==\n\t     (addr->dev_addr.bound_dev_if == net_dev->ifindex)))\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "target": 0}
{"code": "static void adjust_branches(struct bpf_prog *prog, int pos, int delta)\n{\n\tstruct bpf_insn *insn = prog->insnsi;\n\tint insn_cnt = prog->len;\n\tint i;\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (BPF_CLASS(insn->code) != BPF_JMP ||\n\t\t    BPF_OP(insn->code) == BPF_CALL ||\n\t\t    BPF_OP(insn->code) == BPF_EXIT)\n\t\t\tcontinue;\n\t\tif (i < pos && i + insn->off + 1 > pos)\n\t\t\tinsn->off += delta;\n\t\telse if (i > pos && i + insn->off + 1 < pos)\n\t\t\tinsn->off -= delta;\n\t}\n}", "target": 1}
{"code": "const char * RtmpProtocol::handle_C0C1(const char *data, size_t len) {\n    if (len < 1 + C1_HANDSHARK_SIZE) {\n        return nullptr;\n    }\n    if (data[0] != HANDSHAKE_PLAINTEXT) {\n        throw std::runtime_error(\"only plaintext[0x03] handshake supported\");\n    }\n    if (memcmp(data + 5, \"\\x00\\x00\\x00\\x00\", 4) == 0) {\n        handle_C1_simple(data);\n    } else {\n#ifdef ENABLE_OPENSSL\n        handle_C1_complex(data);\n#else\n        WarnL << \"ENABLE_OPENSSLflash\";\n        handle_C1_simple(data);\n#endif\n    }\n    return data + 1 + C1_HANDSHARK_SIZE;\n}", "target": 0}
{"code": "static uint16_t nvme_cmd_effects(NvmeCtrl *n, uint8_t csi, uint32_t buf_len,\n                                 uint64_t off, NvmeRequest *req)\n{\n    NvmeEffectsLog log = {};\n    const uint32_t *src_iocs = NULL;\n    uint32_t trans_len;\n    if (off >= sizeof(log)) {\n        trace_pci_nvme_err_invalid_log_page_offset(off, sizeof(log));\n        return NVME_INVALID_FIELD | NVME_DNR;\n    }\n    switch (NVME_CC_CSS(ldl_le_p(&n->bar.cc))) {\n    case NVME_CC_CSS_NVM:\n        src_iocs = nvme_cse_iocs_nvm;\n    case NVME_CC_CSS_ADMIN_ONLY:\n        break;\n    case NVME_CC_CSS_CSI:\n        switch (csi) {\n        case NVME_CSI_NVM:\n            src_iocs = nvme_cse_iocs_nvm;\n            break;\n        case NVME_CSI_ZONED:\n            src_iocs = nvme_cse_iocs_zoned;\n            break;\n        }\n    }\n    memcpy(log.acs, nvme_cse_acs, sizeof(nvme_cse_acs));\n    if (src_iocs) {\n        memcpy(log.iocs, src_iocs, sizeof(log.iocs));\n    }\n    trans_len = MIN(sizeof(log) - off, buf_len);\n    return nvme_c2h(n, ((uint8_t *)&log) + off, trans_len, req);\n}", "target": 0}
{"code": "int msPostGISLayerSetTimeFilter(layerObj *lp, const char *timestring, const char *timefield)\n{\n  char **atimes, **aranges = NULL;\n  int numtimes=0,i=0,numranges=0;\n  size_t buffer_size = 512;\n  char buffer[512], bufferTmp[512];\n  buffer[0] = '\\0';\n  bufferTmp[0] = '\\0';\n  if (!lp || !timestring || !timefield)\n    return MS_FALSE;\n  if( strchr(timestring,'\\'') || strchr(timestring, '\\\\') ) {\n     msSetError(MS_MISCERR, \"Invalid time filter.\", \"msPostGISLayerSetTimeFilter()\");\n     return MS_FALSE;\n  }\n  if (strstr(timestring, \",\") == NULL &&\n      strstr(timestring, \"/\") == NULL) { \n    createPostgresTimeCompareSimple(timefield, timestring, buffer, buffer_size);\n  } else {\n    atimes = msStringSplit (timestring, ',', &numtimes);\n    if (atimes == NULL || numtimes < 1)\n      return MS_FALSE;\n    strlcat(buffer, \"(\", buffer_size);\n    for(i=0; i<numtimes; i++) {\n      if(i!=0) {\n        strlcat(buffer, \" OR \", buffer_size);\n      }\n      strlcat(buffer, \"(\", buffer_size);\n      aranges = msStringSplit(atimes[i],  '/', &numranges);\n      if(!aranges) return MS_FALSE;\n      if(numranges == 1) {\n        createPostgresTimeCompareSimple(timefield, atimes[i], bufferTmp, buffer_size);\n        strlcat(buffer, bufferTmp, buffer_size);\n      } else if(numranges == 2) {\n        createPostgresTimeCompareRange(timefield, aranges[0], aranges[1], bufferTmp, buffer_size);\n        strlcat(buffer, bufferTmp, buffer_size);\n      } else {\n        return MS_FALSE;\n      }\n      msFreeCharArray(aranges, numranges);\n      strlcat(buffer, \")\", buffer_size);\n    }\n    strlcat(buffer, \")\", buffer_size);\n    msFreeCharArray(atimes, numtimes);\n  }\n  if(!*buffer) {\n    return MS_FALSE;\n  }\n  if(lp->filteritem) free(lp->filteritem);\n  lp->filteritem = msStrdup(timefield);\n  if (&lp->filter) {\n    if (lp->filter.type == MS_EXPRESSION) {\n      snprintf(bufferTmp, buffer_size, \"(%s) and %s\", lp->filter.string, buffer);\n      loadExpressionString(&lp->filter, bufferTmp);\n    } else {\n      freeExpression(&lp->filter);\n      loadExpressionString(&lp->filter, buffer);\n    }\n  }\n  return MS_TRUE;\n}", "target": 0}
{"code": "int blk_init_allocated_queue(struct request_queue *q)\n{\n\tWARN_ON_ONCE(q->mq_ops);\n\tq->fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, q->cmd_size);\n\tif (!q->fq)\n\t\treturn -ENOMEM;\n\tif (q->init_rq_fn && q->init_rq_fn(q, q->fq->flush_rq, GFP_KERNEL))\n\t\tgoto out_free_flush_queue;\n\tif (blk_init_rl(&q->root_rl, q, GFP_KERNEL))\n\t\tgoto out_exit_flush_rq;\n\tINIT_WORK(&q->timeout_work, blk_timeout_work);\n\tq->queue_flags\t\t|= QUEUE_FLAG_DEFAULT;\n\tblk_queue_make_request(q, blk_queue_bio);\n\tq->sg_reserved_size = INT_MAX;\n\tif (elevator_init(q))\n\t\tgoto out_exit_flush_rq;\n\treturn 0;\nout_exit_flush_rq:\n\tif (q->exit_rq_fn)\n\t\tq->exit_rq_fn(q, q->fq->flush_rq);\nout_free_flush_queue:\n\tblk_free_flush_queue(q->fq);\n\tq->fq = NULL;\n\treturn -ENOMEM;\n}", "target": 0}
{"code": "get_char(_pdfio_token_t *tb)\t\t\n{\n  ssize_t\tbytes;\t\t\t\n  if (tb->bufptr >= tb->bufend)\n  {\n    if (tb->bufend > tb->buffer)\n    {\n      PDFIO_DEBUG(\"get_char: Consuming %d bytes.\\n\", (int)(tb->bufend - tb->buffer));\n      (tb->consume_cb)(tb->cb_data, (size_t)(tb->bufend - tb->buffer));\n    }\n    if ((bytes = (tb->peek_cb)(tb->cb_data, tb->buffer, sizeof(tb->buffer))) <= 0)\n    {\n      tb->bufptr = tb->bufend = tb->buffer;\n      return (EOF);\n    }\n    tb->bufptr = tb->buffer;\n    tb->bufend = tb->buffer + bytes;\n#if 0\n#ifdef DEBUG\n    unsigned char *ptr;\t\t\t\n    PDFIO_DEBUG(\"get_char: Read '\");\n    for (ptr = tb->buffer; ptr < tb->bufend; ptr ++)\n    {\n      if (*ptr < ' ' || *ptr == 0x7f)\n        PDFIO_DEBUG(\"\\\\%03o\", *ptr);\n      else\n        PDFIO_DEBUG(\"%c\", *ptr);\n    }\n    PDFIO_DEBUG(\"'\\n\");\n#endif \n#endif \n  }\n  return (*(tb->bufptr)++);\n}", "target": 0}
{"code": "inline bool canReadNElements(\n    Protocol_& prot,\n    uint32_t n,\n    std::initializer_list<\n        typename detail::ProtocolReaderWireTypeInfo<Protocol_>::WireType>\n        types) {\n  return prot.getCursor().canAdvance(n * types.size());\n}", "target": 0}
{"code": "static BIO *cms_get_text_bio(BIO *out, unsigned int flags)\n\t{\n\tBIO *rbio;\n\tif (out == NULL)\n\t\trbio = BIO_new(BIO_s_null());\n\telse if (flags & CMS_TEXT)\n\t\t{\n\t\trbio = BIO_new(BIO_s_mem());\n\t\tBIO_set_mem_eof_return(rbio, 0);\n\t\t}\n\telse\n\t\trbio = out;\n\treturn rbio;\n\t}", "target": 0}
{"code": "int mingw_rmdir(const char *pathname)\n{\n\tint ret, tries = 0;\n\twchar_t wpathname[MAX_PATH];\n\tif (xutftowcs_path(wpathname, pathname) < 0)\n\t\treturn -1;\n\twhile ((ret = _wrmdir(wpathname)) == -1 && tries < ARRAY_SIZE(delay)) {\n\t\tif (!is_file_in_use_error(GetLastError()))\n\t\t\terrno = err_win_to_posix(GetLastError());\n\t\tif (errno != EACCES)\n\t\t\tbreak;\n\t\tif (!is_dir_empty(wpathname)) {\n\t\t\terrno = ENOTEMPTY;\n\t\t\tbreak;\n\t\t}\n\t\tSleep(delay[tries]);\n\t\ttries++;\n\t}\n\twhile (ret == -1 && errno == EACCES && is_file_in_use_error(GetLastError()) &&\n\t       ask_yes_no_if_possible(\"Deletion of directory '%s' failed. \"\n\t\t\t\"Should I try again?\", pathname))\n\t       ret = _wrmdir(wpathname);\n\tif (!ret)\n\t\tinvalidate_lstat_cache();\n\treturn ret;\n}", "target": 0}
{"code": "void rdp_read_flow_control_pdu(wStream* s, UINT16* type)\n{\n\tUINT8 pduType;\n\tStream_Read_UINT8(s, pduType); \n\t*type = pduType;\n\tStream_Seek_UINT8(s);  \n\tStream_Seek_UINT8(s);  \n\tStream_Seek_UINT8(s);  \n\tStream_Seek_UINT16(s); \n}", "target": 1}
{"code": "comics_regex_quote (const gchar *unquoted_string)\n{\n\tconst gchar *p;\n\tGString *dest;\n\tdest = g_string_new (\"'\");\n\tp = unquoted_string;\n\twhile (*p) {\n\t\tswitch (*p) {\n\t\t\tcase ('*'):\n\t\t\tcase ('?'):\n\t\t\tcase ('['):\n\t\t\t\tg_string_append (dest, \"[\");\n\t\t\t\tg_string_append_c (dest, *p);\n\t\t\t\tg_string_append (dest, \"]\");\n\t\t\t\tbreak;\n\t\t\tcase ('\\\\'):\n\t\t\t\tg_string_append (dest, \"[\\\\\\\\]\");\n\t\t\t\tbreak;\n\t\t\tcase ('\\''):\n\t\t\t\tg_string_append (dest, \"'\\\\''\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tg_string_append_c (dest, *p);\n\t\t\t\tbreak;\n\t\t}\n\t\t++p;\n\t}\n\tg_string_append_c (dest, '\\'');\n\treturn g_string_free (dest, FALSE);\n}", "target": 1}
{"code": "int nsim_bpf(struct net_device *dev, struct netdev_bpf *bpf)\n{\n\tstruct netdevsim *ns = netdev_priv(dev);\n\tint err;\n\tASSERT_RTNL();\n\tswitch (bpf->command) {\n\tcase XDP_SETUP_PROG:\n\t\terr = nsim_setup_prog_checks(ns, bpf);\n\t\tif (err)\n\t\t\treturn err;\n\t\treturn nsim_xdp_set_prog(ns, bpf, &ns->xdp);\n\tcase XDP_SETUP_PROG_HW:\n\t\terr = nsim_setup_prog_hw_checks(ns, bpf);\n\t\tif (err)\n\t\t\treturn err;\n\t\treturn nsim_xdp_set_prog(ns, bpf, &ns->xdp_hw);\n\tcase BPF_OFFLOAD_MAP_ALLOC:\n\t\tif (!ns->bpf_map_accept)\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn nsim_bpf_map_alloc(ns, bpf->offmap);\n\tcase BPF_OFFLOAD_MAP_FREE:\n\t\tnsim_bpf_map_free(bpf->offmap);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}", "target": 0}
{"code": "OPJ_BOOL opj_j2k_encoding_validation (  opj_j2k_t * p_j2k,\n                                                                            opj_stream_private_t *p_stream,\n                                                                            opj_event_mgr_t * p_manager )\n{\n        OPJ_BOOL l_is_valid = OPJ_TRUE;\n        assert(p_j2k != 00);\n        assert(p_stream != 00);\n        assert(p_manager != 00);\n        l_is_valid &= (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_NONE);\n        l_is_valid &= (p_j2k->m_procedure_list != 00);\n        l_is_valid &= (p_j2k->m_validation_list != 00);\n        if ((p_j2k->m_cp.tcps->tccps->numresolutions <= 0) || (p_j2k->m_cp.tcps->tccps->numresolutions > 32)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Number of resolutions is too high in comparison to the size of tiles\\n\");\n                return OPJ_FALSE;\n        }\n        if ((p_j2k->m_cp.tdx) < (OPJ_UINT32) (1 << (p_j2k->m_cp.tcps->tccps->numresolutions - 1U))) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Number of resolutions is too high in comparison to the size of tiles\\n\");\n                return OPJ_FALSE;\n        }\n        if ((p_j2k->m_cp.tdy) < (OPJ_UINT32) (1 << (p_j2k->m_cp.tcps->tccps->numresolutions - 1U))) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Number of resolutions is too high in comparison to the size of tiles\\n\");\n                return OPJ_FALSE;\n        }\n        return l_is_valid;\n}", "target": 0}
{"code": "child_setup_func (gpointer user_data)\n{\n  ChildSetupData *data = (ChildSetupData *) user_data;\n  FdMapEntry *fd_map = data->fd_map;\n  sigset_t set;\n  int i;\n  flatpak_close_fds_workaround (3);\n  if (data->instance_id_fd != -1)\n    drop_cloexec (data->instance_id_fd);\n  if (data->env_fd != -1)\n    drop_cloexec (data->env_fd);\n  sigemptyset (&set);\n  if (pthread_sigmask (SIG_SETMASK, &set, NULL) == -1)\n    {\n      g_warning (\"Failed to unblock signals when starting child\");\n      return;\n    }\n  for (i = 1; i < NSIG; i++)\n    {\n      if (i != SIGSTOP && i != SIGKILL)\n        signal (i, SIG_DFL);\n    }\n  for (i = 0; i < data->fd_map_len; i++)\n    {\n      if (fd_map[i].from != fd_map[i].to)\n        {\n          dup2 (fd_map[i].from, fd_map[i].to);\n          close (fd_map[i].from);\n        }\n    }\n  for (i = 0; i < data->fd_map_len; i++)\n    {\n      if (fd_map[i].to != fd_map[i].final)\n        {\n          dup2 (fd_map[i].to, fd_map[i].final);\n          close (fd_map[i].to);\n        }\n      drop_cloexec (fd_map[i].final);\n    }\n  setsid ();\n  setpgid (0, 0);\n  if (data->set_tty)\n    {\n      for (i = 0; i < data->fd_map_len; i++)\n        {\n          if (fd_map[i].from == data->tty)\n            {\n              if (ioctl (fd_map[i].final, TIOCSCTTY, 0) == -1)\n                g_debug (\"ioctl(%d, TIOCSCTTY, 0) failed: %s\",\n                         fd_map[i].final, strerror (errno));\n              break;\n            }\n        }\n    }\n}", "target": 0}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteDepthToSpaceParams*>(node->builtin_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n  auto data_type = output->type;\n  TF_LITE_ENSURE(context,\n                 data_type == kTfLiteFloat32 || data_type == kTfLiteUInt8 ||\n                     data_type == kTfLiteInt8 || data_type == kTfLiteInt32 ||\n                     data_type == kTfLiteInt64);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  const int block_size = params->block_size;\n  TF_LITE_ENSURE(context, block_size > 0);\n  const int input_height = input->dims->data[1];\n  const int input_width = input->dims->data[2];\n  const int input_channels = input->dims->data[3];\n  int output_height = input_height * block_size;\n  int output_width = input_width * block_size;\n  int output_channels = input_channels / block_size / block_size;\n  TF_LITE_ENSURE_EQ(context, input_height, output_height / block_size);\n  TF_LITE_ENSURE_EQ(context, input_width, output_width / block_size);\n  TF_LITE_ENSURE_EQ(context, input_channels,\n                    output_channels * block_size * block_size);\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(4);\n  output_size->data[0] = input->dims->data[0];\n  output_size->data[1] = output_height;\n  output_size->data[2] = output_width;\n  output_size->data[3] = output_channels;\n  return context->ResizeTensor(context, output, output_size);\n}", "target": 0}
{"code": "static int expand_template(struct sss_certmap_ctx *ctx,\n                           struct parsed_template *parsed_template,\n                           struct sss_cert_content *cert_content,\n                           bool sanitize,\n                           char **expanded)\n{\n    int ret;\n    char *exp = NULL;\n    char *exp_sanitized = NULL;\n    if (strcmp(\"issuer_dn\", parsed_template->name) == 0) {\n        ret = rdn_list_2_dn_str(ctx, parsed_template->conversion,\n                                cert_content->issuer_rdn_list, &exp);\n    } else if (strcmp(\"subject_dn\", parsed_template->name) == 0) {\n        ret = rdn_list_2_dn_str(ctx, parsed_template->conversion,\n                                cert_content->subject_rdn_list, &exp);\n    } else if (strncmp(\"subject_\", parsed_template->name, 8) == 0) {\n        ret = expand_san(ctx, parsed_template, cert_content->san_list, &exp);\n    } else if (strcmp(\"cert\", parsed_template->name) == 0) {\n        sanitize = false;\n        ret = expand_cert(ctx, parsed_template, cert_content, &exp);\n    } else {\n        CM_DEBUG(ctx, \"Unsupported template name.\");\n        ret = EINVAL;\n        goto done;\n    }\n    if (ret != 0) {\n        CM_DEBUG(ctx, \"Failed to expand [%s] template.\", parsed_template->name);\n        goto done;\n    }\n    if (exp == NULL) {\n        ret = ENOMEM;\n        goto done;\n    }\n    if (sanitize) {\n        ret = sss_filter_sanitize(ctx, exp, &exp_sanitized);\n        if (ret != EOK) {\n            CM_DEBUG(ctx, \"Failed to sanitize expanded template.\");\n            goto done;\n        }\n        talloc_free(exp);\n        exp = exp_sanitized;\n    }\n    ret = 0;\ndone:\n    if (ret == 0) {\n        *expanded = exp;\n    } else {\n        talloc_free(exp);\n    }\n    return ret;\n}", "target": 0}
{"code": "vg_ctrl_response(VuGpu *g,\n                 struct virtio_gpu_ctrl_command *cmd,\n                 struct virtio_gpu_ctrl_hdr *resp,\n                 size_t resp_len)\n{\n    size_t s;\n    if (cmd->cmd_hdr.flags & VIRTIO_GPU_FLAG_FENCE) {\n        resp->flags |= VIRTIO_GPU_FLAG_FENCE;\n        resp->fence_id = cmd->cmd_hdr.fence_id;\n        resp->ctx_id = cmd->cmd_hdr.ctx_id;\n    }\n    virtio_gpu_ctrl_hdr_bswap(resp);\n    s = iov_from_buf(cmd->elem.in_sg, cmd->elem.in_num, 0, resp, resp_len);\n    if (s != resp_len) {\n        g_critical(\"%s: response size incorrect %zu vs %zu\",\n                   __func__, s, resp_len);\n    }\n    vu_queue_push(&g->dev.parent, cmd->vq, &cmd->elem, s);\n    vu_queue_notify(&g->dev.parent, cmd->vq);\n    cmd->state = VG_CMD_STATE_FINISHED;\n}", "target": 0}
{"code": "static int ath10k_usb_hif_tx_sg(struct ath10k *ar, u8 pipe_id,\n\t\t\t\tstruct ath10k_hif_sg_item *items, int n_items)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tstruct ath10k_usb_pipe *pipe = &ar_usb->pipes[pipe_id];\n\tstruct ath10k_urb_context *urb_context;\n\tstruct sk_buff *skb;\n\tstruct urb *urb;\n\tint ret, i;\n\tfor (i = 0; i < n_items; i++) {\n\t\turb_context = ath10k_usb_alloc_urb_from_pipe(pipe);\n\t\tif (!urb_context) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tskb = items[i].transfer_context;\n\t\turb_context->skb = skb;\n\t\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\t\tif (!urb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free_urb_to_pipe;\n\t\t}\n\t\tusb_fill_bulk_urb(urb,\n\t\t\t\t  ar_usb->udev,\n\t\t\t\t  pipe->usb_pipe_handle,\n\t\t\t\t  skb->data,\n\t\t\t\t  skb->len,\n\t\t\t\t  ath10k_usb_transmit_complete, urb_context);\n\t\tif (!(skb->len % pipe->max_packet_size)) {\n\t\t\turb->transfer_flags |= URB_ZERO_PACKET;\n\t\t}\n\t\tusb_anchor_urb(urb, &pipe->urb_submitted);\n\t\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (ret) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_USB_BULK,\n\t\t\t\t   \"usb bulk transmit failed: %d\\n\", ret);\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tusb_free_urb(urb);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_free_urb_to_pipe;\n\t\t}\n\t\tusb_free_urb(urb);\n\t}\n\treturn 0;\nerr_free_urb_to_pipe:\n\tath10k_usb_free_urb_to_pipe(urb_context->pipe, urb_context);\nerr:\n\treturn ret;\n}", "target": 0}
{"code": "sudo_auth_cleanup(const struct sudoers_context *ctx, struct passwd *pw,\n    bool force)\n{\n    sudo_auth *auth;\n    debug_decl(sudo_auth_cleanup, SUDOERS_DEBUG_AUTH);\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (auth->cleanup && !IS_DISABLED(auth)) {\n\t    int status = (auth->cleanup)(ctx, pw, auth, force);\n\t    if (status == AUTH_ERROR) {\n\t\tdebug_return_int(-1);\n\t    }\n\t}\n    }\n    debug_return_int(0);\n}", "target": 1}
{"code": "void msetGenericCommand(client *c, int nx) {\n    int j;\n    int setkey_flags = 0;\n    if ((c->argc % 2) == 0) {\n        addReplyErrorArity(c);\n        return;\n    }\n    if (nx) {\n        for (j = 1; j < c->argc; j += 2) {\n            if (lookupKeyWrite(c->db,c->argv[j]) != NULL) {\n                addReply(c, shared.czero);\n                return;\n            }\n        }\n        setkey_flags |= SETKEY_DOESNT_EXIST;\n    }\n    for (j = 1; j < c->argc; j += 2) {\n        c->argv[j+1] = tryObjectEncoding(c->argv[j+1]);\n        setKey(c, c->db, c->argv[j], c->argv[j + 1], setkey_flags);\n        notifyKeyspaceEvent(NOTIFY_STRING,\"set\",c->argv[j],c->db->id);\n    }\n    server.dirty += (c->argc-1)/2;\n    addReply(c, nx ? shared.cone : shared.ok);\n}", "target": 1}
{"code": "static void bnx2x_init_cyclecounter(struct bnx2x *bp)\n{\n\tmemset(&bp->cyclecounter, 0, sizeof(bp->cyclecounter));\n\tbp->cyclecounter.read = bnx2x_cyclecounter_read;\n\tbp->cyclecounter.mask = CYCLECOUNTER_MASK(64);\n\tbp->cyclecounter.shift = 0;\n\tbp->cyclecounter.mult = 1;\n}", "target": 0}
{"code": "gstd_accept(int fd, char **display_creds, char **export_name, char **mech)\n{\n\tgss_name_t\t client;\n\tgss_OID\t\t mech_oid;\n\tstruct gstd_tok *tok;\n\tgss_ctx_id_t\t ctx = GSS_C_NO_CONTEXT;\n\tgss_buffer_desc\t in, out;\n\tOM_uint32\t maj, min;\n\tint\t\t ret;\n\t*display_creds = NULL;\n\t*export_name = NULL;\n\tout.length = 0;\n\tin.length = 0;\n\tread_packet(fd, &in, 60000, 1);\nagain:\n\twhile ((ret = read_packet(fd, &in, 60000, 0)) == -2)\n\t\t;\n\tif (ret < 1)\n\t\treturn NULL;\n\tmaj = gss_accept_sec_context(&min, &ctx, GSS_C_NO_CREDENTIAL,\n\t    &in, GSS_C_NO_CHANNEL_BINDINGS, &client, &mech_oid, &out, NULL,\n\t    NULL, NULL);\n\tgss_release_buffer(&min, &in);\n\tif (out.length && write_packet(fd, &out)) {\n\t\tgss_release_buffer(&min, &out);\n\t\treturn NULL;\n\t}\n\tgss_release_buffer(&min, &out);\n\tGSTD_GSS_ERROR(maj, min, NULL, \"gss_accept_sec_context\");\n\tif (maj & GSS_S_CONTINUE_NEEDED)\n\t\tgoto again;\n\t*display_creds = gstd_get_display_name(client);\n\t*export_name = gstd_get_export_name(client);\n\t*mech = gstd_get_mech(mech_oid);\n\tgss_release_name(&min, &client);\n\tSETUP_GSTD_TOK(tok, ctx, fd, \"gstd_accept\");\n\treturn tok;\n}", "target": 0}
{"code": "static void flush(AVCodecContext *avctx)\n{\n    AACContext *ac= avctx->priv_data;\n    int type, i, j;\n    for (type = 3; type >= 0; type--) {\n        for (i = 0; i < MAX_ELEM_ID; i++) {\n            ChannelElement *che = ac->che[type][i];\n            if (che) {\n                for (j = 0; j <= 1; j++) {\n                    memset(che->ch[j].saved, 0, sizeof(che->ch[j].saved));\n                }\n            }\n        }\n    }\n}", "target": 0}
{"code": "void SetBackgroundColor(int par)\n{\n    if ( par == STROKING ) { outpos += sprintf(outpos,\" 0 0 0 0 K\"); }\n    else                   { outpos += sprintf(outpos,\" 0 0 0 0 k\"); }\n}", "target": 1}
{"code": "void InlineTextBox::paintCompositionUnderline(GraphicsContext* ctx, int tx, int ty, const CompositionUnderline& underline)\n{\n    tx += m_x;\n    ty += m_y;\n    if (m_truncation == cFullTruncation)\n        return;\n    int start = 0;                 \n    int width = m_logicalWidth;           \n    bool useWholeWidth = true;\n    unsigned paintStart = m_start;\n    unsigned paintEnd = end() + 1; \n    if (paintStart <= underline.startOffset) {\n        paintStart = underline.startOffset;\n        useWholeWidth = false;\n        start = toRenderText(renderer())->width(m_start, paintStart - m_start, textPos(), m_firstLine);\n    }\n    if (paintEnd != underline.endOffset) {      \n        paintEnd = min(paintEnd, (unsigned)underline.endOffset);\n        useWholeWidth = false;\n    }\n    if (m_truncation != cNoTruncation) {\n        paintEnd = min(paintEnd, (unsigned)m_start + m_truncation);\n        useWholeWidth = false;\n    }\n    if (!useWholeWidth) {\n        width = toRenderText(renderer())->width(paintStart, paintEnd - paintStart, textPos() + start, m_firstLine);\n    }\n    int lineThickness = 1;\n    int baseline = renderer()->style(m_firstLine)->font().ascent();\n    if (underline.thick && logicalHeight() - baseline >= 2)\n        lineThickness = 2;\n    start += 1;\n    width -= 2;\n    ctx->setStrokeColor(underline.color, renderer()->style()->colorSpace());\n    ctx->setStrokeThickness(lineThickness);\n    ctx->drawLineForText(IntPoint(tx + start, ty + logicalHeight() - lineThickness), width, textRenderer()->document()->printing());\n}", "target": 0}
{"code": "int afGetFileFormat (AFfilehandle file, int *version)\n{\n\tif (!_af_filehandle_ok(file))\n\t\treturn -1;\n\tif (version != NULL)\n\t{\n\t\tif (_af_units[file->fileFormat].getversion)\n\t\t\t*version = _af_units[file->fileFormat].getversion(file);\n\t\telse\n\t\t\t*version = 0;\n\t}\n\treturn file->fileFormat;\n}", "target": 0}
{"code": "void acpi_os_set_prepare_sleep(int (*func)(u8 sleep_state,\n\t\t\t       u32 pm1a_ctrl, u32 pm1b_ctrl))\n{\n\t__acpi_os_prepare_sleep = func;\n}", "target": 0}
{"code": "iakerb_gss_export_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_buffer_t interprocess_token)\n{\n    OM_uint32 maj;\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)*context_handle;\n    if (!ctx->established)\n        return GSS_S_UNAVAILABLE;\n    maj = krb5_gss_export_sec_context(minor_status, &ctx->gssc,\n                                      interprocess_token);\n    if (ctx->gssc == GSS_C_NO_CONTEXT) {\n        iakerb_release_context(ctx);\n        *context_handle = GSS_C_NO_CONTEXT;\n    }\n    return maj;\n}", "target": 0}
{"code": "void SSecurityTLS::initGlobal()\n{\n  static bool globalInitDone = false;\n  if (!globalInitDone) {\n    if (gnutls_global_init() != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_global_init failed\");\n    globalInitDone = true;\n  }\n}", "target": 1}
{"code": "x_order(const active_line *lp1, const active_line *lp2)\n{\n    bool s1;\n    INCR(order);\n    if (!lp1 || !lp2 || lp1->x_current < lp2->x_current)\n        return -1;\n    else if (lp1->x_current > lp2->x_current)\n        return 1;\n    if ((s1 = lp1->start.x < lp1->end.x) != (lp2->start.x < lp2->end.x))\n        return (s1 ? 1 : -1);\n    INCR(slow_order);\n    {\n        fixed dx1 = lp1->end.x - lp1->start.x,\n            dy1 = lp1->end.y - lp1->start.y;\n        fixed dx2 = lp2->end.x - lp2->start.x,\n            dy2 = lp2->end.y - lp2->start.y;\n        double diff = (double)dx1 * dy2 - (double)dx2 * dy1;\n        return (diff < 0 ? -1 : diff > 0 ? 1 : 0);\n    }\n}", "target": 0}
{"code": "int posix_acl_update_mode(struct inode *inode, umode_t *mode_p,\n\t\t\t  struct posix_acl **acl)\n{\n\tumode_t mode = inode->i_mode;\n\tint error;\n\terror = posix_acl_equiv_mode(*acl, &mode);\n\tif (error < 0)\n\t\treturn error;\n\tif (error == 0)\n\t\t*acl = NULL;\n\tif (!in_group_p(inode->i_gid) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\tmode &= ~S_ISGID;\n\t*mode_p = mode;\n\treturn 0;\n}", "target": 0}
{"code": "static void *my_malloc(size_t size)\n{\n    malloc_called += 1;\n    return malloc(size);\n}", "target": 1}
{"code": "static int uas_switch_interface(struct usb_device *udev,\n\t\t\t\tstruct usb_interface *intf)\n{\n\tint alt;\n\talt = uas_find_uas_alt_setting(intf);\n\tif (alt < 0)\n\t\treturn alt;\n\treturn usb_set_interface(udev,\n\t\t\tintf->altsetting[0].desc.bInterfaceNumber, alt);\n}", "target": 1}
{"code": "gopherStateFree(const CommCloseCbParams &params)\n{\n    GopherStateData *gopherState = (GopherStateData *)params.data;\n    delete gopherState;\n}", "target": 1}
{"code": "static int do_siocgstamp(struct net *net, struct socket *sock,\n\t\t\t unsigned int cmd, void __user *up)\n{\n\tmm_segment_t old_fs = get_fs();\n\tstruct timeval ktv;\n\tint err;\n\tset_fs(KERNEL_DS);\n\terr = sock_do_ioctl(net, sock, cmd, (unsigned long)&ktv);\n\tset_fs(old_fs);\n\tif (!err)\n\t\terr = compat_put_timeval(up, &ktv);\n\treturn err;\n}", "target": 1}
{"code": "void* sspi_SecureHandleGetLowerPointer(SecHandle* handle)\n{\n\tvoid* pointer;\n\tif (!handle)\n\t\treturn NULL;\n\tpointer = (void*) ~((size_t) handle->dwLower);\n\treturn pointer;\n}", "target": 1}
{"code": "static int nfs_can_extend_write(struct file *file, struct page *page, struct inode *inode)\n{\n\tif (file->f_flags & O_DSYNC)\n\t\treturn 0;\n\tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))\n\t\treturn 1;\n\tif (nfs_write_pageuptodate(page, inode) && (inode->i_flock == NULL ||\n\t\t\t(inode->i_flock->fl_start == 0 &&\n\t\t\tinode->i_flock->fl_end == OFFSET_MAX &&\n\t\t\tinode->i_flock->fl_type != F_RDLCK)))\n\t\treturn 1;\n\treturn 0;\n}", "target": 1}
{"code": "int nfc_start_poll(struct nfc_dev *dev, u32 im_protocols, u32 tm_protocols)\n{\n\tint rc;\n\tpr_debug(\"dev_name %s initiator protocols 0x%x target protocols 0x%x\\n\",\n\t\t dev_name(&dev->dev), im_protocols, tm_protocols);\n\tif (!im_protocols && !tm_protocols)\n\t\treturn -EINVAL;\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->dev_up) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->polling) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\trc = dev->ops->start_poll(dev, im_protocols, tm_protocols);\n\tif (!rc) {\n\t\tdev->polling = true;\n\t\tdev->rf_mode = NFC_RF_NONE;\n\t}\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "static void unqueue_me_pi(struct futex_q *q)\n{\n\tWARN_ON(plist_node_empty(&q->list));\n\tplist_del(&q->list, &q->list.plist);\n\tBUG_ON(!q->pi_state);\n\tfree_pi_state(q->pi_state);\n\tq->pi_state = NULL;\n\tspin_unlock(q->lock_ptr);\n\tdrop_futex_key_refs(&q->key);\n}", "target": 1}
{"code": "int main(int argc, char *argv[])\n{\n\tchar *procspath;\n\tsize_t len;\n\tif (geteuid() != 0) {\n\t\tfprintf(stderr, \"Run me as root\\n\");\n\t\texit(1);\n\t}\n\tif (argc != 2)  {\n\t\tfprintf(stderr, \"Usage: %s [lxcfs_test_cgroup_path]\\n\", argv[0]);\n\t\texit(1);\n\t}\n\tlen = strlen(argv[1]) + strlen(\"/cgroup.procs\") + 1;\n\tprocspath = alloca(len);\n\tsnprintf(procspath, len, \"%s/cgroup.procs\", argv[1]);\n\ttest_open(argv[1]);\n\ttest_open(procspath);\n\ttest_stat(argv[1]);\n\ttest_stat(procspath);\n\ttest_access(argv[1]);\n\ttest_access(procspath);\n\ttest_bind(argv[1]);\n\ttest_bind(procspath);\n\ttest_bindmount(argv[1]);\n\ttest_bindmount(procspath);\n\ttest_truncate(argv[1]);\n\ttest_truncate(procspath);\n\ttest_chdir(argv[1]);\n\ttest_chdir(procspath);\n\ttest_rename(argv[1]);\n\ttest_rename(procspath);\n\ttest_mkdir(argv[1]);\n\ttest_mkdir(procspath);\n\ttest_rmdir(argv[1]);\n\ttest_rmdir(procspath);\n\ttest_creat(argv[1]);\n\ttest_creat(procspath);\n\ttest_link(argv[1]);\n\ttest_link(procspath);\n\ttest_unlink(argv[1]);\n\ttest_unlink(procspath);\n\ttest_symlink(argv[1]);\n\ttest_symlink(procspath);\n\ttest_readlink(argv[1]);\n\ttest_readlink(procspath);\n\ttest_chmod(argv[1]);\n\ttest_chmod(procspath);\n\ttest_chown(argv[1]);\n\ttest_chown(procspath);\n\ttest_lchown(argv[1]);\n\ttest_lchown(procspath);\n\ttest_mknod(argv[1]);\n\ttest_mknod(procspath);\n\ttest_chroot(argv[1]);\n\ttest_chroot(procspath);\n\ttest_xattrs(argv[1]);\n\ttest_xattrs(procspath);\n\ttest_utimes(argv[1]);\n\ttest_utimes(procspath);\n\ttest_openat(argv[1]);\n\tprintf(\"All tests passed\\n\");\n\treturn 0;\n}", "target": 0}
{"code": "int jas_stream_write(jas_stream_t *stream, const void *buf, int cnt)\n{\n\tint n;\n\tconst char *bufptr;\n\tif (cnt < 0) {\n\t\tjas_deprecated(\"negative count for jas_stream_write\");\n\t}\n\tbufptr = buf;\n\tn = 0;\n\twhile (n < cnt) {\n\t\tif (jas_stream_putc(stream, *bufptr) == EOF) {\n\t\t\treturn n;\n\t\t}\n\t\t++bufptr;\n\t\t++n;\n\t}\n\treturn n;\n}", "target": 0}
{"code": "flatpak_run_get_cups_server_name_config (const char *path)\n{\n  g_autoptr(GFile) file = g_file_new_for_path (path);\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(GFileInputStream) input_stream = NULL;\n  g_autoptr(GDataInputStream) data_stream = NULL;\n  size_t len;\n  input_stream = g_file_read (file, NULL, &my_error);\n  if (my_error)\n    {\n      g_debug (\"CUPS configuration file '%s': %s\", path, my_error->message);\n      return NULL;\n    }\n  data_stream = g_data_input_stream_new (G_INPUT_STREAM (input_stream));\n  while (TRUE)\n    {\n      g_autofree char *line = g_data_input_stream_read_line (data_stream, &len, NULL, NULL);\n      if (line == NULL)\n        break;\n      g_strchug (line);\n      if ((*line  == '\\0') || (*line == '#'))\n        continue;\n      g_auto(GStrv) tokens = g_strsplit (line, \" \", 2);\n      if ((tokens[0] != NULL) && (tokens[1] != NULL))\n        {\n          if (strcmp (\"ServerName\", tokens[0]) == 0)\n            {\n              g_strchug (tokens[1]);\n              if (flatpak_run_cups_check_server_is_socket (tokens[1]))\n                return g_strdup (tokens[1]);\n            }\n        }\n    }\n    return NULL;\n}", "target": 0}
{"code": "static int expand_mapping_rule_ex(struct sss_certmap_ctx *ctx,\n                                  const uint8_t *der_cert, size_t der_size,\n                                  bool sanitize,\n                                  char **_filter, char ***_domains)\n{\n    int ret;\n    struct match_map_rule *r;\n    struct priority_list *p;\n    struct sss_cert_content *cert_content = NULL;\n    char *filter = NULL;\n    char **domains = NULL;\n    size_t c;\n    if (_filter == NULL || _domains == NULL) {\n        return EINVAL;\n    }\n    ret = sss_cert_get_content(ctx, der_cert, der_size, &cert_content);\n    if (ret != 0) {\n        CM_DEBUG(ctx, \"Failed to get certificate content [%d].\", ret);\n        return ret;\n    }\n    if (ctx->prio_list == NULL) {\n        if (ctx->default_mapping_rule == NULL) {\n            CM_DEBUG(ctx, \"No matching or mapping rules available.\");\n            return EINVAL;\n        }\n        ret = get_filter(ctx, ctx->default_mapping_rule, cert_content, sanitize,\n                         &filter);\n        goto done;\n    }\n    for (p = ctx->prio_list; p != NULL; p = p->next) {\n        for (r = p->rule_list; r != NULL; r = r->next) {\n            ret = do_match(ctx, r->parsed_match_rule, cert_content);\n            if (ret == 0) {\n                ret = get_filter(ctx, r->parsed_mapping_rule, cert_content,\n                                 sanitize, &filter);\n                if (ret != 0) {\n                    CM_DEBUG(ctx, \"Failed to get filter\");\n                    goto done;\n                }\n                if (r->domains != NULL) {\n                    for (c = 0; r->domains[c] != NULL; c++);\n                    domains = talloc_zero_array(ctx, char *, c + 1);\n                    if (domains == NULL) {\n                        ret = ENOMEM;\n                        goto done;\n                    }\n                    for (c = 0; r->domains[c] != NULL; c++) {\n                        domains[c] = talloc_strdup(domains, r->domains[c]);\n                        if (domains[c] == NULL) {\n                            ret = ENOMEM;\n                            goto done;\n                        }\n                    }\n                }\n                ret = 0;\n                goto done;\n            }\n        }\n    }\n    ret = ENOENT;\ndone:\n    talloc_free(cert_content);\n    if (ret == 0) {\n        *_filter = filter;\n        *_domains = domains;\n    } else {\n        talloc_free(filter);\n        talloc_free(domains);\n    }\n    return ret;\n}", "target": 0}
{"code": "static void log_handler(uint32_t level, const char *msg, void *arg)\n{\n\tfprintf(stdout, msg, arg);\n}", "target": 0}
{"code": "int tcp_filter(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcphdr *th = (struct tcphdr *)skb->data;\n\tunsigned int eaten = skb->len;\n\tint err;\n\terr = sk_filter_trim_cap(sk, skb, th->doff * 4);\n\tif (!err) {\n\t\teaten -= skb->len;\n\t\tTCP_SKB_CB(skb)->end_seq -= eaten;\n\t}\n\treturn err;\n}", "target": 0}
{"code": "bool generateV2Header(const Network::ProxyProtocolData& proxy_proto_data, Buffer::Instance& out,\n                      bool pass_all_tlvs, const absl::flat_hash_set<uint8_t>& pass_through_tlvs) {\n  uint64_t extension_length = 0;\n  for (auto&& tlv : proxy_proto_data.tlv_vector_) {\n    if (!pass_all_tlvs && !pass_through_tlvs.contains(tlv.type)) {\n      continue;\n    }\n    extension_length += PROXY_PROTO_V2_TLV_TYPE_LENGTH_LEN + tlv.value.size();\n    if (extension_length > std::numeric_limits<uint16_t>::max()) {\n      ENVOY_LOG_MISC(\n          warn, \"Generating Proxy Protocol V2 header: TLVs exceed length limit {}, already got {}\",\n          std::numeric_limits<uint16_t>::max(), extension_length);\n      return false;\n    }\n  }\n  ASSERT(extension_length <= std::numeric_limits<uint16_t>::max());\n  if (proxy_proto_data.src_addr_ == nullptr || proxy_proto_data.src_addr_->ip() == nullptr) {\n    IS_ENVOY_BUG(\"Missing or incorrect source IP in proxy_proto_data_\");\n    return false;\n  }\n  if (proxy_proto_data.dst_addr_ == nullptr || proxy_proto_data.dst_addr_->ip() == nullptr) {\n    IS_ENVOY_BUG(\"Missing or incorrect dest IP in proxy_proto_data_\");\n    return false;\n  }\n  const auto& src = *proxy_proto_data.src_addr_->ip();\n  const auto& dst = *proxy_proto_data.dst_addr_->ip();\n  generateV2Header(src.addressAsString(), dst.addressAsString(), src.port(), dst.port(),\n                   src.version(), static_cast<uint16_t>(extension_length), out);\n  for (auto&& tlv : proxy_proto_data.tlv_vector_) {\n    if (!pass_all_tlvs && !pass_through_tlvs.contains(tlv.type)) {\n      continue;\n    }\n    out.add(&tlv.type, 1);\n    uint16_t size = htons(static_cast<uint16_t>(tlv.value.size()));\n    out.add(&size, sizeof(uint16_t));\n    out.add(&tlv.value.front(), tlv.value.size());\n  }\n  return true;\n}", "target": 0}
{"code": "check_compat_entry_size_and_hooks(struct compat_arpt_entry *e,\n\t\t\t\t  struct xt_table_info *newinfo,\n\t\t\t\t  unsigned int *size,\n\t\t\t\t  const unsigned char *base,\n\t\t\t\t  const unsigned char *limit,\n\t\t\t\t  const unsigned int *hook_entries,\n\t\t\t\t  const unsigned int *underflows,\n\t\t\t\t  const char *name)\n{\n\tstruct xt_entry_target *t;\n\tstruct xt_target *target;\n\tunsigned int entry_offset;\n\tint ret, off, h;\n\tduprintf(\"check_compat_entry_size_and_hooks %p\\n\", e);\n\tif ((unsigned long)e % __alignof__(struct compat_arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct compat_arpt_entry) >= limit) {\n\t\tduprintf(\"Bad offset %p, limit = %p\\n\", e, limit);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset < sizeof(struct compat_arpt_entry) +\n\t\t\t     sizeof(struct compat_xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\tret = check_entry((struct arpt_entry *)e);\n\tif (ret)\n\t\treturn ret;\n\toff = sizeof(struct arpt_entry) - sizeof(struct compat_arpt_entry);\n\tentry_offset = (void *)e - (void *)base;\n\tt = compat_arpt_get_target(e);\n\ttarget = xt_request_find_target(NFPROTO_ARP, t->u.user.name,\n\t\t\t\t\tt->u.user.revision);\n\tif (IS_ERR(target)) {\n\t\tduprintf(\"check_compat_entry_size_and_hooks: `%s' not found\\n\",\n\t\t\t t->u.user.name);\n\t\tret = PTR_ERR(target);\n\t\tgoto out;\n\t}\n\tt->u.kernel.target = target;\n\toff += xt_compat_target_offset(target);\n\t*size += off;\n\tret = xt_compat_add_offset(NFPROTO_ARP, entry_offset, off);\n\tif (ret)\n\t\tgoto release_target;\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h])\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t}\n\tmemset(&e->counters, 0, sizeof(e->counters));\n\te->comefrom = 0;\n\treturn 0;\nrelease_target:\n\tmodule_put(t->u.kernel.target->me);\nout:\n\treturn ret;\n}", "target": 1}
{"code": "R_API void r_core_fini(RCore *c) {\n\tif (!c) {\n\t\treturn;\n\t}\n\tr_core_task_break_all (&c->tasks);\n\tr_core_task_join (&c->tasks, NULL, -1);\n\tr_core_wait (c);\n\tr_list_free (c->ropchain);\n\tr_event_free (c->ev);\n\tfree (c->cmdlog);\n\tfree (c->lastsearch);\n\tR_FREE (c->cons->pager);\n\tfree (c->cmdqueue);\n\tfree (c->lastcmd);\n\tfree (c->stkcmd);\n\tr_list_free (c->visual.tabs);\n\tfree (c->block);\n\tr_core_autocomplete_free (c->autocomplete);\n\tr_list_free (c->gadgets);\n\tr_list_free (c->undos);\n\tr_num_free (c->num);\n\tfree (c->table_query);\n\tr_list_free (c->files);\n\tr_list_free (c->watchers);\n\tr_list_free (c->scriptstack);\n\tr_core_task_scheduler_fini (&c->tasks);\n\tc->rcmd = r_cmd_free (c->rcmd);\n\tr_list_free (c->cmd_descriptors);\n\tc->anal = r_anal_free (c->anal);\n\tr_asm_free (c->assembler);\n\tc->assembler = NULL;\n\tc->print = r_print_free (c->print);\n\tc->bin = (r_bin_free (c->bin), NULL);\n\tc->lang = (r_lang_free (c->lang), NULL);\n\tc->dbg = (r_debug_free (c->dbg), NULL);\n\tr_io_free (c->io);\n\tr_config_free (c->config);\n\tr_cons_free ();\n\tr_cons_singleton ()->teefile = NULL; \n\tr_search_free (c->search);\n\tr_flag_free (c->flags);\n\tr_fs_free (c->fs);\n\tr_egg_free (c->egg);\n\tr_lib_free (c->lib);\n\tr_buf_free (c->yank_buf);\n\tr_agraph_free (c->graph);\n\tfree (c->asmqjmps);\n\tsdb_free (c->sdb);\n\tr_core_log_free (c->log);\n\tr_parse_free (c->parser);\n\tfree (c->times);\n}", "target": 1}
{"code": "int rtnl_dump_request_n(struct rtnl_handle *rth, struct nlmsghdr *n)\n{\n\tstruct sockaddr_nl nladdr = { .nl_family = AF_NETLINK };\n\tstruct iovec iov = {\n\t\t.iov_base = n,\n\t\t.iov_len = n->nlmsg_len\n\t};\n\tstruct msghdr msg = {\n\t\t.msg_name = &nladdr,\n\t\t.msg_namelen = sizeof(nladdr),\n\t\t.msg_iov = &iov,\n\t\t.msg_iovlen = 1,\n\t};\n\tn->nlmsg_flags = NLM_F_DUMP|NLM_F_REQUEST;\n\tn->nlmsg_pid = 0;\n\tn->nlmsg_seq = rth->dump = ++rth->seq;\n\treturn sendmsg(rth->fd, &msg, 0);\n}", "target": 0}
{"code": "Http::FilterMetadataStatus Context::onRequestMetadata() {\n  if (!wasm_->onRequestMetadata_) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  if (wasm_->onRequestMetadata_(this, id_).u64_ == 0) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  return Http::FilterMetadataStatus::Continue; \n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& data = context->input(0);\n    const Tensor& weights = context->input(1);\n    bool use_weights = weights.NumElements() > 0;\n    OP_REQUIRES(context,\n                TensorShapeUtils::IsVector(data.shape()) ||\n                    TensorShapeUtils::IsMatrix(data.shape()),\n                errors::InvalidArgument(\n                    \"Input must be a 1 or 2-dimensional tensor. Got: \",\n                    data.shape().DebugString()));\n    if (use_weights) {\n      OP_REQUIRES(\n          context, weights.shape() == data.shape(),\n          errors::InvalidArgument(\n              \"Weights and data must have the same shape. Weight shape: \",\n              weights.shape().DebugString(),\n              \"; data shape: \", data.shape().DebugString()));\n    }\n    bool is_1d = TensorShapeUtils::IsVector(data.shape());\n    int negative_valued_axis = -1;\n    int num_batch_dimensions = (data.shape().dims() + negative_valued_axis);\n    int num_batch_elements = 1;\n    for (int i = 0; i < num_batch_dimensions; ++i) {\n      OP_REQUIRES(context, data.shape().dim_size(i) != 0,\n                  errors::InvalidArgument(\n                      \"Invalid input: Shapes dimension cannot be 0.\"));\n      num_batch_elements *= data.shape().dim_size(i);\n    }\n    int num_value_elements = data.shape().num_elements() / num_batch_elements;\n    auto per_batch_counts = BatchedMap<W>(num_batch_elements);\n    T max_value = 0;\n    const auto data_values = data.flat<T>();\n    const auto weight_values = weights.flat<W>();\n    int i = 0;\n    for (int b = 0; b < num_batch_elements; ++b) {\n      for (int v = 0; v < num_value_elements; ++v) {\n        const auto& value = data_values(i);\n        if (value >= 0 && (maxlength_ <= 0 || value < maxlength_)) {\n          if (binary_output_) {\n            per_batch_counts[b][value] = 1;\n          } else if (use_weights) {\n            per_batch_counts[b][value] += weight_values(i);\n          } else {\n            per_batch_counts[b][value]++;\n          }\n          if (value > max_value) {\n            max_value = value;\n          }\n        }\n        ++i;\n      }\n    }\n    int num_output_values = GetOutputSize(max_value, maxlength_, minlength_);\n    OP_REQUIRES_OK(context, OutputSparse<W>(per_batch_counts, num_output_values,\n                                            is_1d, context));\n  }", "target": 0}
{"code": "static void xen_cpu_init_eoi(unsigned int cpu)\n{\n\tstruct lateeoi_work *eoi = &per_cpu(lateeoi, cpu);\n\tINIT_DELAYED_WORK(&eoi->delayed, xen_irq_lateeoi_worker);\n\tspin_lock_init(&eoi->eoi_list_lock);\n\tINIT_LIST_HEAD(&eoi->eoi_list);\n}", "target": 0}
{"code": "mrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b)\n{\n  if (a->body.irep) {\n    return;\n  }\n  if (!MRB_PROC_CFUNC_P(b) && b->body.irep) {\n    mrb_irep_incref(mrb, (mrb_irep*)b->body.irep);\n  }\n  a->flags = b->flags;\n  a->body = b->body;\n  a->upper = b->upper;\n  a->e.env = b->e.env;\n}", "target": 0}
{"code": "TensorBuffer* FromProtoField<ResourceHandle>(Allocator* a,\n                                             const TensorProto& in, int64_t n) {\n  CHECK_GT(n, 0);\n  Buffer<ResourceHandle>* buf = new Buffer<ResourceHandle>(a, n);\n  ResourceHandle* data = buf->template base<ResourceHandle>();\n  if (data == nullptr) {\n    buf->Unref();\n    return nullptr;\n  }\n  const int64_t in_n = ProtoHelper<ResourceHandle>::NumElements(in);\n  if (in_n <= 0) {\n    std::fill_n(data, n, ResourceHandle());\n  } else {\n    const int64_t real_n = n < in_n ? n : in_n;\n    for (int64_t i = 0; i < real_n; ++i) {\n      Status s = ResourceHandle::BuildResourceHandle(in.resource_handle_val(i),\n                                                     &data[i]);\n      if (!s.ok()) {\n        LOG(ERROR) << \"Could not decode resource handle from proto \\\"\"\n                   << in.resource_handle_val(i).ShortDebugString()\n                   << \"\\\", returned status: \" << s.ToString();\n        buf->Unref();\n        return nullptr;\n      }\n    }\n    for (int64_t i = in_n; i < n; ++i) {\n      data[i] = ResourceHandle();\n    }\n  }\n  return buf;\n}", "target": 0}
{"code": "  void DoRealForwardFFT(OpKernelContext* ctx, uint64* fft_shape,\n                        const Tensor& in, Tensor* out) {\n    const auto axes = Eigen::ArrayXi::LinSpaced(FFTRank, 1, FFTRank);\n    auto device = ctx->eigen_device<CPUDevice>();\n    auto input = Tensor(in).flat_inner_dims<RealT, FFTRank + 1>();\n    const auto input_dims = input.dimensions();\n    Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> input_slice_sizes;\n    input_slice_sizes[0] = input_dims[0];\n    TensorShape temp_shape{input_dims[0]};\n    for (int i = 1; i <= FFTRank; ++i) {\n      input_slice_sizes[i] = fft_shape[i - 1];\n      temp_shape.AddDim(fft_shape[i - 1]);\n    }\n    OP_REQUIRES(ctx, temp_shape.num_elements() > 0,\n                errors::InvalidArgument(\"Obtained a FFT shape of 0 elements: \",\n                                        temp_shape.DebugString()));\n    auto output = out->flat_inner_dims<ComplexT, FFTRank + 1>();\n    const Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> zero_start_indices;\n    Tensor temp;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<ComplexT>::v(),\n                                           temp_shape, &temp));\n    auto full_fft = temp.flat_inner_dims<ComplexT, FFTRank + 1>();\n    full_fft.device(device) =\n        input.slice(zero_start_indices, input_slice_sizes)\n            .template fft<Eigen::BothParts, Eigen::FFT_FORWARD>(axes);\n    output.device(device) =\n        full_fft.slice(zero_start_indices, output.dimensions());\n  }", "target": 0}
{"code": "nfs4_xdr_dec_setacl(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t    struct nfs_setaclres *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_setattr(xdr);\nout:\n\treturn status;\n}", "target": 0}
{"code": "static int xfrm_dump_sa_done(struct netlink_callback *cb)\n{\n\tstruct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];\n\tstruct sock *sk = cb->skb->sk;\n\tstruct net *net = sock_net(sk);\n\txfrm_state_walk_done(walk, net);\n\treturn 0;\n}", "target": 1}
{"code": "fixExec2Error(int action,\n             u_char * var_val,\n             u_char var_val_type,\n             size_t var_val_len,\n             u_char * statP, oid * name, size_t name_len)\n{\n    netsnmp_old_extend *exten = NULL;\n    unsigned int idx;\n    idx = name[name_len-1] -1;\n    exten = &compatability_entries[ idx ];\n#ifndef NETSNMP_NO_WRITE_SUPPORT\n    switch (action) {\n    case MODE_SET_RESERVE1:\n        if (var_val_type != ASN_INTEGER) {\n            snmp_log(LOG_ERR, \"Wrong type != int\\n\");\n            return SNMP_ERR_WRONGTYPE;\n        }\n        idx = *((long *) var_val);\n        if (idx != 1) {\n            snmp_log(LOG_ERR, \"Wrong value != 1\\n\");\n            return SNMP_ERR_WRONGVALUE;\n        }\n        if (!exten || !exten->efix_entry) {\n            snmp_log(LOG_ERR, \"No command to run\\n\");\n            return SNMP_ERR_GENERR;\n        }\n        return SNMP_ERR_NOERROR;\n    case MODE_SET_COMMIT:\n        netsnmp_cache_check_and_reload( exten->efix_entry->cache );\n    }\n#endif \n    return SNMP_ERR_NOERROR;\n}", "target": 1}
{"code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  OpContext op_context(context, node);\n    switch (op_context.output->type) {\n      case kTfLiteFloat32:\n        TFLiteOperation<kernel_type, float, OpType>(context, node, op_context);\n        break;\n      case kTfLiteUInt8:\n        TFLiteOperation<kernel_type, uint8_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt8:\n        TFLiteOperation<kernel_type, int8_t, OpType>(context, node, op_context);\n        break;\n      case kTfLiteInt32:\n        TFLiteOperation<kernel_type, int32_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt64:\n        TFLiteOperation<kernel_type, int64_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt16:\n        TFLiteOperation<kernel_type, int16_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      default:\n        context->ReportError(context,\n                             \"Type %d is currently not supported by Maximum.\",\n                             op_context.output->type);\n        return kTfLiteError;\n    }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "GopherStateData::iconUrl(const char gtype)\n{\n    switch (gtype) {\n    case GOPHER_DIRECTORY:\n        return mimeGetIconURL(\"internal-menu\");\n    case GOPHER_HTML:\n    case GOPHER_FILE:\n        return mimeGetIconURL(\"internal-text\");\n    case GOPHER_INDEX:\n    case GOPHER_CSO:\n        return mimeGetIconURL(\"internal-index\");\n    case GOPHER_IMAGE:\n    case GOPHER_GIF:\n    case GOPHER_PLUS_IMAGE:\n        return mimeGetIconURL(\"internal-image\");\n    case GOPHER_SOUND:\n    case GOPHER_PLUS_SOUND:\n        return mimeGetIconURL(\"internal-sound\");\n    case GOPHER_PLUS_MOVIE:\n        return mimeGetIconURL(\"internal-movie\");\n    case GOPHER_TELNET:\n    case GOPHER_3270:\n        return mimeGetIconURL(\"internal-telnet\");\n    case GOPHER_BIN:\n    case GOPHER_MACBINHEX:\n    case GOPHER_DOSBIN:\n    case GOPHER_UUENCODED:\n        return mimeGetIconURL(\"internal-binary\");\n    case GOPHER_INFO:\n        return nullptr;\n    case GOPHER_WWW:\n        return mimeGetIconURL(\"internal-link\");\n    default:\n        return mimeGetIconURL(\"internal-unknown\");\n    }\n}", "target": 1}
{"code": "int ext4_group_add(struct super_block *sb, struct ext4_new_group_data *input)\n{\n\tstruct ext4_new_flex_group_data flex_gd;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint reserved_gdb = ext4_bg_has_super(sb, input->group) ?\n\t\tle16_to_cpu(es->s_reserved_gdt_blocks) : 0;\n\tstruct inode *inode = NULL;\n\tint gdb_off, gdb_num;\n\tint err;\n\t__u16 bg_flags = 0;\n\tgdb_num = input->group / EXT4_DESC_PER_BLOCK(sb);\n\tgdb_off = input->group % EXT4_DESC_PER_BLOCK(sb);\n\tif (gdb_off == 0 && !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER)) {\n\t\text4_warning(sb, \"Can't resize non-sparse filesystem further\");\n\t\treturn -EPERM;\n\t}\n\tif (ext4_blocks_count(es) + input->blocks_count <\n\t    ext4_blocks_count(es)) {\n\t\text4_warning(sb, \"blocks_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\tif (le32_to_cpu(es->s_inodes_count) + EXT4_INODES_PER_GROUP(sb) <\n\t    le32_to_cpu(es->s_inodes_count)) {\n\t\text4_warning(sb, \"inodes_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\tif (reserved_gdb || gdb_off == 0) {\n\t\tif (!EXT4_HAS_COMPAT_FEATURE(sb,\n\t\t\t\t\t     EXT4_FEATURE_COMPAT_RESIZE_INODE)\n\t\t    || !le16_to_cpu(es->s_reserved_gdt_blocks)) {\n\t\t\text4_warning(sb,\n\t\t\t\t     \"No reserved GDT blocks, can't resize\");\n\t\t\treturn -EPERM;\n\t\t}\n\t\tinode = ext4_iget(sb, EXT4_RESIZE_INO);\n\t\tif (IS_ERR(inode)) {\n\t\t\text4_warning(sb, \"Error opening resize inode\");\n\t\t\treturn PTR_ERR(inode);\n\t\t}\n\t}\n\terr = verify_group_input(sb, input);\n\tif (err)\n\t\tgoto out;\n\tflex_gd.count = 1;\n\tflex_gd.groups = input;\n\tflex_gd.bg_flags = &bg_flags;\n\terr = ext4_flex_group_add(sb, inode, &flex_gd);\nout:\n\tiput(inode);\n\treturn err;\n} ", "target": 0}
{"code": "absl::Status Ipv6Instance::validateProtocolSupported() {\n  static const bool supported = SocketInterfaceSingleton::get().ipFamilySupported(AF_INET6);\n  if (supported) {\n    return absl::OkStatus();\n  }\n  return absl::FailedPreconditionError(\"IPv6 addresses are not supported on this machine\");\n}", "target": 1}
{"code": "static void *seq_buf_alloc(unsigned long size)\n{\n\tif (unlikely(size > MAX_RW_COUNT))\n\t\treturn NULL;\n\treturn kvmalloc(size, GFP_KERNEL_ACCOUNT);\n}", "target": 0}
{"code": "static uint64_t generatePageID()\n{\n    static uint64_t uniquePageID = 1;\n    return uniquePageID++;\n}", "target": 0}
{"code": "static int xfrm_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *attrs[XFRMA_MAX+1];\n\tconst struct xfrm_link *link;\n\tint type, err;\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall())\n\t\treturn -EOPNOTSUPP;\n#endif\n\ttype = nlh->nlmsg_type;\n\tif (type > XFRM_MSG_MAX)\n\t\treturn -EINVAL;\n\ttype -= XFRM_MSG_BASE;\n\tlink = &xfrm_dispatch[type];\n\tif (!netlink_net_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\tif ((type == (XFRM_MSG_GETSA - XFRM_MSG_BASE) ||\n\t     type == (XFRM_MSG_GETPOLICY - XFRM_MSG_BASE)) &&\n\t    (nlh->nlmsg_flags & NLM_F_DUMP)) {\n\t\tif (link->dump == NULL)\n\t\t\treturn -EINVAL;\n\t\t{\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.start = link->start,\n\t\t\t\t.dump = link->dump,\n\t\t\t\t.done = link->done,\n\t\t\t};\n\t\t\treturn netlink_dump_start(net->xfrm.nlsk, skb, nlh, &c);\n\t\t}\n\t}\n\terr = nlmsg_parse(nlh, xfrm_msg_min[type], attrs,\n\t\t\t  link->nla_max ? : XFRMA_MAX,\n\t\t\t  link->nla_pol ? : xfrma_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\tif (link->doit == NULL)\n\t\treturn -EINVAL;\n\treturn link->doit(skb, nlh, attrs);\n}", "target": 0}
{"code": "static void update_db_bp_intercept(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tclr_exception_intercept(svm, DB_VECTOR);\n\tclr_exception_intercept(svm, BP_VECTOR);\n\tif (svm->nmi_singlestep)\n\t\tset_exception_intercept(svm, DB_VECTOR);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_ENABLE) {\n\t\tif (vcpu->guest_debug &\n\t\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))\n\t\t\tset_exception_intercept(svm, DB_VECTOR);\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\tset_exception_intercept(svm, BP_VECTOR);\n\t} else\n\t\tvcpu->guest_debug = 0;\n}", "target": 1}
{"code": "lldp_mgmt_addr_tlv_print(netdissect_options *ndo,\n                         const u_char *pptr, u_int len)\n{\n    uint8_t mgmt_addr_len, intf_num_subtype, oid_len;\n    const u_char *tptr;\n    u_int tlen;\n    char *mgmt_addr;\n    tlen = len;\n    tptr = pptr;\n    if (tlen < 1) {\n        return 0;\n    }\n    mgmt_addr_len = *tptr++;\n    tlen--;\n    if (tlen < mgmt_addr_len) {\n        return 0;\n    }\n    mgmt_addr = lldp_network_addr_print(ndo, tptr, mgmt_addr_len);\n    if (mgmt_addr == NULL) {\n        return 0;\n    }\n    ND_PRINT((ndo, \"\\n\\t  Management Address length %u, %s\",\n           mgmt_addr_len, mgmt_addr));\n    tptr += mgmt_addr_len;\n    tlen -= mgmt_addr_len;\n    if (tlen < LLDP_INTF_NUM_LEN) {\n        return 0;\n    }\n    intf_num_subtype = *tptr;\n    ND_PRINT((ndo, \"\\n\\t  %s Interface Numbering (%u): %u\",\n           tok2str(lldp_intf_numb_subtype_values, \"Unknown\", intf_num_subtype),\n           intf_num_subtype,\n           EXTRACT_32BITS(tptr + 1)));\n    tptr += LLDP_INTF_NUM_LEN;\n    tlen -= LLDP_INTF_NUM_LEN;\n    if (tlen) {\n        oid_len = *tptr;\n        if (tlen < oid_len) {\n            return 0;\n        }\n        if (oid_len) {\n            ND_PRINT((ndo, \"\\n\\t  OID length %u\", oid_len));\n            safeputs(ndo, tptr + 1, oid_len);\n        }\n    }\n    return 1;\n}", "target": 1}
{"code": "njs_promise_prototype_then(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_int_t                 ret;\n    njs_value_t               *promise, *fulfilled, *rejected, constructor;\n    njs_object_t              *object;\n    njs_function_t            *function;\n    njs_promise_capability_t  *capability;\n    promise = njs_argument(args, 0);\n    if (njs_slow_path(!njs_is_object(promise))) {\n        goto failed;\n    }\n    object = njs_object_proto_lookup(njs_object(promise), NJS_PROMISE,\n                                     njs_object_t);\n    if (njs_slow_path(object == NULL)) {\n        goto failed;\n    }\n    function = njs_promise_create_function(vm, sizeof(njs_promise_context_t));\n    function->u.native = njs_promise_constructor;\n    njs_set_function(&constructor, function);\n    ret = njs_value_species_constructor(vm, promise, &constructor,\n                                        &constructor);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    capability = njs_promise_new_capability(vm, &constructor);\n    if (njs_slow_path(capability == NULL)) {\n        return NJS_ERROR;\n    }\n    fulfilled = njs_arg(args, nargs, 1);\n    rejected = njs_arg(args, nargs, 2);\n    return njs_promise_perform_then(vm, promise, fulfilled, rejected,\n                                    capability);\nfailed:\n    njs_type_error(vm, \"required a promise object\");\n    return NJS_ERROR;\n}", "target": 1}
{"code": "static char *get_netscape_format(const struct Cookie *co)\n{\n  return aprintf(\n    \"%s\"     \n    \"%s%s\\t\" \n    \"%s\\t\"   \n    \"%s\\t\"   \n    \"%s\\t\"   \n    \"%\" FORMAT_OFF_T \"\\t\"   \n    \"%s\\t\"   \n    \"%s\",    \n    co->httponly?\"#HttpOnly_\":\"\",\n    (co->tailmatch && co->domain && co->domain[0] != '.')? \".\":\"\",\n    co->domain?co->domain:\"unknown\",\n    co->tailmatch?\"TRUE\":\"FALSE\",\n    co->path?co->path:\"/\",\n    co->secure?\"TRUE\":\"FALSE\",\n    co->expires,\n    co->name,\n    co->value?co->value:\"\");\n}", "target": 0}
{"code": "static int _string_check(int linenumber, char *buf, const char *buf2)\n{\n  if(strcmp(buf, buf2)) {\n    printf(\"sprintf line %d failed:\\nwe      '%s'\\nsystem: '%s'\\n\",\n           linenumber, buf, buf2);\n    return 1;\n  }\n  return 0;\n}", "target": 0}
{"code": "TEE_Result crypto_acipher_alloc_dsa_keypair(struct dsa_keypair *s,\n\t\t\t\t\t    size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->g))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->p))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->q))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->x))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->g);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\tcrypto_bignum_free(s->y);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "static void llc_cmsg_rcv(struct msghdr *msg, struct sk_buff *skb)\n{\n\tstruct llc_sock *llc = llc_sk(skb->sk);\n\tif (llc->cmsg_flags & LLC_CMSG_PKTINFO) {\n\t\tstruct llc_pktinfo info;\n\t\tmemset(&info, 0, sizeof(info));\n\t\tinfo.lpi_ifindex = llc_sk(skb->sk)->dev->ifindex;\n\t\tllc_pdu_decode_dsap(skb, &info.lpi_sap);\n\t\tllc_pdu_decode_da(skb, info.lpi_mac);\n\t\tput_cmsg(msg, SOL_LLC, LLC_OPT_PKTINFO, sizeof(info), &info);\n\t}\n}", "target": 0}
{"code": "int siphash_test(void) {\n    uint8_t in[64], k[16];\n    int i;\n    int fails = 0;\n    for (i = 0; i < 16; ++i)\n        k[i] = i;\n    for (i = 0; i < 64; ++i) {\n        in[i] = i;\n        uint64_t hash = siphash(in, i, k);\n        const uint8_t *v = NULL;\n        v = (uint8_t *)vectors_sip64;\n        if (memcmp(&hash, v + (i * 8), 8)) {\n            fails++;\n        }\n    }\n    uint64_t h1, h2;\n    h1 = siphash((uint8_t*)\"hello world\",11,(uint8_t*)\"1234567812345678\");\n    h2 = siphash_nocase((uint8_t*)\"hello world\",11,(uint8_t*)\"1234567812345678\");\n    if (h1 != h2) fails++;\n    h1 = siphash((uint8_t*)\"hello world\",11,(uint8_t*)\"1234567812345678\");\n    h2 = siphash_nocase((uint8_t*)\"HELLO world\",11,(uint8_t*)\"1234567812345678\");\n    if (h1 != h2) fails++;\n    h1 = siphash((uint8_t*)\"HELLO world\",11,(uint8_t*)\"1234567812345678\");\n    h2 = siphash_nocase((uint8_t*)\"HELLO world\",11,(uint8_t*)\"1234567812345678\");\n    if (h1 == h2) fails++;\n    if (!fails) return 0;\n    return 1;\n}", "target": 0}
{"code": "static void bt_for_each(struct blk_mq_hw_ctx *hctx,\n\t\tstruct blk_mq_bitmap_tags *bt, unsigned int off,\n\t\tbusy_iter_fn *fn, void *data, bool reserved)\n{\n\tstruct request *rq;\n\tint bit, i;\n\tfor (i = 0; i < bt->map_nr; i++) {\n\t\tstruct blk_align_bitmap *bm = &bt->map[i];\n\t\tfor (bit = find_first_bit(&bm->word, bm->depth);\n\t\t     bit < bm->depth;\n\t\t     bit = find_next_bit(&bm->word, bm->depth, bit + 1)) {\n\t\t     \trq = blk_mq_tag_to_rq(hctx->tags, off + bit);\n\t\t\tif (rq->q == hctx->queue)\n\t\t\t\tfn(hctx, rq, data, reserved);\n\t\t}\n\t\toff += (1 << bt->bits_per_word);\n\t}\n}", "target": 1}
{"code": "FIO_FUNC inline void fio_throttle_thread(size_t nano_sec) {\n  const struct timespec tm = {.tv_nsec = (nano_sec % 1000000000),\n                              .tv_sec = (nano_sec / 1000000000)};\n  nanosleep(&tm, NULL);\n}", "target": 1}
{"code": "callbacks_new_project_activate (GtkMenuItem *menuitem, gpointer user_data)\n{\n\tif (mainProject->last_loaded >= 0) {\n\t\tif (!interface_get_alert_dialog_response (\n\t\t\t_(\"Do you want to close any open layers \"\n\t\t\t\"and start a new project?\"),\n\t\t\t_(\"Starting a new project will cause all currently \"\n\t\t\t\"open layers to be closed. Any unsaved changes \"\n\t\t\t\"will be lost.\"),\n\t\t\tFALSE, NULL, GTK_STOCK_CLOSE, GTK_STOCK_CANCEL))\n\t\t\treturn;\n\t}\n\tgerbv_unload_all_layers (mainProject);\n\tcallbacks_update_layer_tree ();\n\tselection_clear (&screen.selectionInfo);\n\tupdate_selected_object_message (FALSE);\n\tif (mainProject->project) {\n\t    g_free(mainProject->project);\n\t    mainProject->project = NULL;\n\t}\n\trender_refresh_rendered_image_on_screen();\n}", "target": 0}
{"code": "acpi_os_create_semaphore(u32 max_units, u32 initial_units, acpi_handle * handle)\n{\n\tstruct semaphore *sem = NULL;\n\tsem = acpi_os_allocate_zeroed(sizeof(struct semaphore));\n\tif (!sem)\n\t\treturn AE_NO_MEMORY;\n\tsema_init(sem, initial_units);\n\t*handle = (acpi_handle *) sem;\n\tACPI_DEBUG_PRINT((ACPI_DB_MUTEX, \"Creating semaphore[%p|%d].\\n\",\n\t\t\t  *handle, initial_units));\n\treturn AE_OK;\n}", "target": 0}
{"code": "struct resource_pool *dce100_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc  *dc)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\tif (!pool)\n\t\treturn NULL;\n\tif (construct(num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\tkfree(pool);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 0}
{"code": "static int n_tty_ioctl(struct tty_struct *tty, struct file *file,\n\t\t       unsigned int cmd, unsigned long arg)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint retval;\n\tswitch (cmd) {\n\tcase TIOCOUTQ:\n\t\treturn put_user(tty_chars_in_buffer(tty), (int __user *) arg);\n\tcase TIOCINQ:\n\t\tdown_write(&tty->termios_rwsem);\n\t\tif (L_ICANON(tty))\n\t\t\tretval = inq_canon(ldata);\n\t\telse\n\t\t\tretval = read_cnt(ldata);\n\t\tup_write(&tty->termios_rwsem);\n\t\treturn put_user(retval, (unsigned int __user *) arg);\n\tdefault:\n\t\treturn n_tty_ioctl_helper(tty, file, cmd, arg);\n\t}\n}", "target": 1}
{"code": "static int rock_continue(struct rock_state *rs)\n{\n\tint ret = 1;\n\tint blocksize = 1 << rs->inode->i_blkbits;\n\tconst int min_de_size = offsetof(struct rock_ridge, u);\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\tif ((unsigned)rs->cont_offset > blocksize - min_de_size ||\n\t    (unsigned)rs->cont_size > blocksize ||\n\t    (unsigned)(rs->cont_offset + rs->cont_size) > blocksize) {\n\t\tprintk(KERN_NOTICE \"rock: corrupted directory entry. \"\n\t\t\t\"extent=%d, offset=%d, size=%d\\n\",\n\t\t\trs->cont_extent, rs->cont_offset, rs->cont_size);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tif (rs->cont_extent) {\n\t\tstruct buffer_head *bh;\n\t\trs->buffer = kmalloc(rs->cont_size, GFP_KERNEL);\n\t\tif (!rs->buffer) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = -EIO;\n\t\tif (++rs->cont_loops >= RR_MAX_CE_ENTRIES)\n\t\t\tgoto out;\n\t\tbh = sb_bread(rs->inode->i_sb, rs->cont_extent);\n\t\tif (bh) {\n\t\t\tmemcpy(rs->buffer, bh->b_data + rs->cont_offset,\n\t\t\t\t\trs->cont_size);\n\t\t\tput_bh(bh);\n\t\t\trs->chr = rs->buffer;\n\t\t\trs->len = rs->cont_size;\n\t\t\trs->cont_extent = 0;\n\t\t\trs->cont_size = 0;\n\t\t\trs->cont_offset = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tprintk(\"Unable to read rock-ridge attributes\\n\");\n\t}\nout:\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\treturn ret;\n}", "target": 0}
{"code": "void ntlm_write_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields->MaxLen < 1)\n\t\tfields->MaxLen = fields->Len;\n\tStream_Write_UINT16(s, fields->Len); \n\tStream_Write_UINT16(s, fields->MaxLen); \n\tStream_Write_UINT32(s, fields->BufferOffset); \n}", "target": 1}
{"code": "struct pipe_inode_info *alloc_pipe_info(void)\n{\n\tstruct pipe_inode_info *pipe;\n\tpipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL);\n\tif (pipe) {\n\t\tpipe->bufs = kzalloc(sizeof(struct pipe_buffer) * PIPE_DEF_BUFFERS, GFP_KERNEL);\n\t\tif (pipe->bufs) {\n\t\t\tinit_waitqueue_head(&pipe->wait);\n\t\t\tpipe->r_counter = pipe->w_counter = 1;\n\t\t\tpipe->buffers = PIPE_DEF_BUFFERS;\n\t\t\tmutex_init(&pipe->mutex);\n\t\t\treturn pipe;\n\t\t}\n\t\tkfree(pipe);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static inline int ip6_ufo_append_data(struct sock *sk,\n\t\t\tint getfrag(void *from, char *to, int offset, int len,\n\t\t\tint odd, struct sk_buff *skb),\n\t\t\tvoid *from, int length, int hh_len, int fragheaderlen,\n\t\t\tint transhdrlen, int mtu,unsigned int flags,\n\t\t\tstruct rt6_info *rt)\n{\n\tstruct sk_buff *skb;\n\tstruct frag_hdr fhdr;\n\tint err;\n\tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {\n\t\tskb = sock_alloc_send_skb(sk,\n\t\t\thh_len + fragheaderlen + transhdrlen + 20,\n\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\tif (skb == NULL)\n\t\t\treturn err;\n\t\tskb_reserve(skb, hh_len);\n\t\tskb_put(skb,fragheaderlen + transhdrlen);\n\t\tskb_reset_network_header(skb);\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb->csum = 0;\n\t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\t} else if (skb_is_gso(skb)) {\n\t\tgoto append;\n\t}\n\tskb->ip_summed = CHECKSUM_PARTIAL;\n\tskb_shinfo(skb)->gso_size = (mtu - fragheaderlen -\n\t\t\t\t     sizeof(struct frag_hdr)) & ~7;\n\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\tipv6_select_ident(&fhdr, rt);\n\tskb_shinfo(skb)->ip6_frag_id = fhdr.identification;\nappend:\n\treturn skb_append_datato_frags(sk, skb, getfrag, from,\n\t\t\t\t       (length - transhdrlen));\n}", "target": 0}
{"code": "atol8(const char *p, size_t char_cnt)\n{\n\tint64_t l;\n\tint digit;\n\tl = 0;\n\twhile (char_cnt-- > 0) {\n\t\tif (*p >= '0' && *p <= '7')\n\t\t\tdigit = *p - '0';\n\t\telse\n\t\t\tbreak;\n\t\tp++;\n\t\tl <<= 3;\n\t\tl |= digit;\n\t}\n\treturn (l);\n}", "target": 1}
{"code": "__u32 secure_ip_id(__be32 daddr)\n{\n\tu32 hash[MD5_DIGEST_WORDS];\n\thash[0] = (__force __u32) daddr;\n\thash[1] = net_secret[13];\n\thash[2] = net_secret[14];\n\thash[3] = net_secret[15];\n\tmd5_transform(hash, net_secret);\n\treturn hash[0];\n}", "target": 0}
{"code": "R_API st64 r_buf_read_at(RBuffer *b, ut64 addr, ut8 *buf, ut64 len) {\n\tr_return_val_if_fail (b && buf, -1);\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tst64 r = r_buf_seek (b, addr, R_BUF_SET);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\tr = r_buf_read (b, buf, len);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn r;\n}", "target": 1}
{"code": "static int rd_allocate_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,\n\t\t\t\t u32 total_sg_needed, unsigned char init_payload)\n{\n\tu32 i = 0, j, page_offset = 0, sg_per_table;\n\tu32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /\n\t\t\t\tsizeof(struct scatterlist));\n\tstruct page *pg;\n\tstruct scatterlist *sg;\n\tunsigned char *p;\n\twhile (total_sg_needed) {\n\t\tsg_per_table = (total_sg_needed > max_sg_per_table) ?\n\t\t\tmax_sg_per_table : total_sg_needed;\n\t\tsg = kzalloc(sg_per_table * sizeof(struct scatterlist),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!sg) {\n\t\t\tpr_err(\"Unable to allocate scatterlist array\"\n\t\t\t\t\" for struct rd_dev\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tsg_init_table(sg, sg_per_table);\n\t\tsg_table[i].sg_table = sg;\n\t\tsg_table[i].rd_sg_count = sg_per_table;\n\t\tsg_table[i].page_start_offset = page_offset;\n\t\tsg_table[i++].page_end_offset = (page_offset + sg_per_table)\n\t\t\t\t\t\t- 1;\n\t\tfor (j = 0; j < sg_per_table; j++) {\n\t\t\tpg = alloc_pages(GFP_KERNEL, 0);\n\t\t\tif (!pg) {\n\t\t\t\tpr_err(\"Unable to allocate scatterlist\"\n\t\t\t\t\t\" pages for struct rd_dev_sg_table\\n\");\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tsg_assign_page(&sg[j], pg);\n\t\t\tsg[j].length = PAGE_SIZE;\n\t\t\tp = kmap(pg);\n\t\t\tmemset(p, init_payload, PAGE_SIZE);\n\t\t\tkunmap(pg);\n\t\t}\n\t\tpage_offset += sg_per_table;\n\t\ttotal_sg_needed -= sg_per_table;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "int cmd_upload_pack(int argc, const char **argv, const char *prefix)\n{\n\tconst char *dir;\n\tint strict = 0;\n\tint advertise_refs = 0;\n\tint stateless_rpc = 0;\n\tint timeout = 0;\n\tstruct option options[] = {\n\t\tOPT_BOOL(0, \"stateless-rpc\", &stateless_rpc,\n\t\t\t N_(\"quit after a single request/response exchange\")),\n\t\tOPT_HIDDEN_BOOL(0, \"http-backend-info-refs\", &advertise_refs,\n\t\t\t\tN_(\"serve up the info/refs for git-http-backend\")),\n\t\tOPT_ALIAS(0, \"advertise-refs\", \"http-backend-info-refs\"),\n\t\tOPT_BOOL(0, \"strict\", &strict,\n\t\t\t N_(\"do not try <directory>/.git/ if <directory> is no Git directory\")),\n\t\tOPT_INTEGER(0, \"timeout\", &timeout,\n\t\t\t    N_(\"interrupt transfer after <n> seconds of inactivity\")),\n\t\tOPT_END()\n\t};\n\tpacket_trace_identity(\"upload-pack\");\n\tread_replace_refs = 0;\n\txsetenv(\"GIT_NO_LAZY_FETCH\", \"1\", 0);\n\targc = parse_options(argc, argv, prefix, options, upload_pack_usage, 0);\n\tif (argc != 1)\n\t\tusage_with_options(upload_pack_usage, options);\n\tsetup_path();\n\tdir = argv[0];\n\tif (!enter_repo(dir, strict))\n\t\tdie(\"'%s' does not appear to be a git repository\", dir);\n\tswitch (determine_protocol_version_server()) {\n\tcase protocol_v2:\n\t\tif (advertise_refs)\n\t\t\tprotocol_v2_advertise_capabilities();\n\t\telse\n\t\t\tprotocol_v2_serve_loop(stateless_rpc);\n\t\tbreak;\n\tcase protocol_v1:\n\t\tif (advertise_refs || !stateless_rpc)\n\t\t\tpacket_write_fmt(1, \"version 1\\n\");\n\tcase protocol_v0:\n\t\tupload_pack(advertise_refs, stateless_rpc, timeout);\n\t\tbreak;\n\tcase protocol_unknown_version:\n\t\tBUG(\"unknown protocol version\");\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "int secure_check(void *data)\n{\n\tconst at91_secure_header_t *header;\n\tvoid *file;\n\tif (secure_decrypt(data, sizeof(*header), 0))\n\t\treturn -1;\n\theader = (const at91_secure_header_t *)data;\n\tif (header->magic != AT91_SECURE_MAGIC)\n\t\treturn -1;\n\tfile = (unsigned char *)data + sizeof(*header);\n\treturn secure_decrypt(file, header->file_size, 1);\n}", "target": 1}
{"code": "absl::Status SslSocket::initialize(InitialState state,\n                                   Ssl::HandshakerFactoryCb handshaker_factory_cb) {\n  auto status_or_ssl = ctx_->newSsl(transport_socket_options_);\n  if (!status_or_ssl.ok()) {\n    return status_or_ssl.status();\n  }\n  info_ = std::dynamic_pointer_cast<SslHandshakerImpl>(handshaker_factory_cb(\n      std::move(status_or_ssl.value()), ctx_->sslExtendedSocketInfoIndex(), this));\n  if (state == InitialState::Client) {\n    SSL_set_connect_state(rawSsl());\n  } else {\n    ASSERT(state == InitialState::Server);\n    SSL_set_accept_state(rawSsl());\n  }\n  return absl::OkStatus();\n}", "target": 0}
{"code": "static int install_relocation_handler(int num_cpus, size_t save_state_size)\n{\n\tstruct smm_loader_params smm_params = {\n\t\t.per_cpu_stack_size = CONFIG_SMM_STUB_STACK_SIZE,\n\t\t.num_concurrent_stacks = num_cpus,\n\t\t.per_cpu_save_state_size = save_state_size,\n\t\t.num_concurrent_save_states = 1,\n\t\t.handler = smm_do_relocation,\n\t};\n\tif (mp_state.ops.adjust_smm_params != NULL)\n\t\tmp_state.ops.adjust_smm_params(&smm_params, 0);\n\tif (smm_setup_relocation_handler(&smm_params))\n\t\treturn -1;\n\tadjust_smm_apic_id_map(&smm_params);\n\treturn 0;\n}", "target": 1}
{"code": "sds sdsMakeRoomFor(sds s, size_t addlen) {\n    void *sh, *newsh;\n    size_t avail = sdsavail(s);\n    size_t len, newlen, reqlen;\n    char type, oldtype = s[-1] & SDS_TYPE_MASK;\n    int hdrlen;\n    if (avail >= addlen) return s;\n    len = sdslen(s);\n    sh = (char*)s-sdsHdrSize(oldtype);\n    reqlen = newlen = (len+addlen);\n    assert(newlen > len);   \n    if (newlen < SDS_MAX_PREALLOC)\n        newlen *= 2;\n    else\n        newlen += SDS_MAX_PREALLOC;\n    type = sdsReqType(newlen);\n    if (type == SDS_TYPE_5) type = SDS_TYPE_8;\n    hdrlen = sdsHdrSize(type);\n    assert(hdrlen + newlen + 1 > reqlen);  \n    if (oldtype==type) {\n        newsh = s_realloc(sh, hdrlen+newlen+1);\n        if (newsh == NULL) return NULL;\n        s = (char*)newsh+hdrlen;\n    } else {\n        newsh = s_malloc(hdrlen+newlen+1);\n        if (newsh == NULL) return NULL;\n        memcpy((char*)newsh+hdrlen, s, len+1);\n        s_free(sh);\n        s = (char*)newsh+hdrlen;\n        s[-1] = type;\n        sdssetlen(s, len);\n    }\n    sdssetalloc(s, newlen);\n    return s;\n}", "target": 0}
{"code": "void ArcMemory::Load(const byte *Data,size_t Size)\n{\n  ArcData.Alloc(Size);\n  memcpy(&ArcData[0],Data,Size);\n  Loaded=true;\n  SeekPos=0;\n}", "target": 0}
{"code": "BGD_DECLARE(void) gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)\n{\n\tint x, y, pos;\n\tWbmp *wbmp;\n\tif((wbmp = createwbmp(gdImageSX(image), gdImageSY(image), WBMP_WHITE)) == NULL) {\n\t\tgd_error(\"Could not create WBMP\\n\");\n\t\treturn;\n\t}\n\tpos = 0;\n\tfor(y = 0; y < gdImageSY(image); y++) {\n\t\tfor(x = 0; x < gdImageSX(image); x++) {\n\t\t\tif(gdImageGetPixel(image, x, y) == fg) {\n\t\t\t\twbmp->bitmap[pos] = WBMP_BLACK;\n\t\t\t}\n\t\t\tpos++;\n\t\t}\n\t}\n\tif(writewbmp(wbmp, &gd_putout, out)) {\n\t\tgd_error(\"Could not save WBMP\\n\");\n\t}\n\tfreewbmp(wbmp);\n}", "target": 1}
{"code": "rfbReleaseClientIterator(rfbClientIteratorPtr iterator)\n{\n  if(iterator->next) rfbDecrClientRef(iterator->next);\n  free(iterator);\n}", "target": 1}
{"code": "void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi)\n{\n\t__issue_discard_cmd(sbi, false);\n\t__drop_discard_cmd(sbi);\n\t__wait_discard_cmd(sbi, false);\n}", "target": 1}
{"code": "static int hci_sock_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct hci_ufilter uf;\n\tstruct sock *sk = sock->sk;\n\tint len, opt, err = 0;\n\tBT_DBG(\"sk %p, opt %d\", sk, optname);\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tlock_sock(sk);\n\tif (hci_pi(sk)->channel != HCI_CHANNEL_RAW) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\tswitch (optname) {\n\tcase HCI_DATA_DIR:\n\t\tif (hci_pi(sk)->cmsg_mask & HCI_CMSG_DIR)\n\t\t\topt = 1;\n\t\telse\n\t\t\topt = 0;\n\t\tif (put_user(opt, optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase HCI_TIME_STAMP:\n\t\tif (hci_pi(sk)->cmsg_mask & HCI_CMSG_TSTAMP)\n\t\t\topt = 1;\n\t\telse\n\t\t\topt = 0;\n\t\tif (put_user(opt, optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase HCI_FILTER:\n\t\t{\n\t\t\tstruct hci_filter *f = &hci_pi(sk)->filter;\n\t\t\tmemset(&uf, 0, sizeof(uf));\n\t\t\tuf.type_mask = f->type_mask;\n\t\t\tuf.opcode    = f->opcode;\n\t\t\tuf.event_mask[0] = *((u32 *) f->event_mask + 0);\n\t\t\tuf.event_mask[1] = *((u32 *) f->event_mask + 1);\n\t\t}\n\t\tlen = min_t(unsigned int, len, sizeof(uf));\n\t\tif (copy_to_user(optval, &uf, len))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\ndone:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "\t\tDeleteRunner(ReferenceHandle& that, Local<Value> key_handle) :\n\t\t\t\tkey{ExternalCopy::CopyIfPrimitive(key_handle)},\n\t\t\t\tcontext{that.context},\n\t\t\t\treference{that.reference} {\n\t\t\tthat.CheckDisposed();\n\t\t\tif (!key) {\n\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n\t\t\t}\n\t\t}", "target": 1}
{"code": "getTable (const char *tableList)\n{\n  int tableListLen;\n  ChainEntry *currentEntry = NULL;\n  ChainEntry *lastEntry = NULL;\n  void *newTable;\n  if (tableList == NULL || *tableList == 0)\n    return NULL;\n  errorCount = fileCount = 0;\n  tableListLen = strlen (tableList);\n  if (lastTrans != NULL)\n    if (tableListLen == lastTrans->tableListLength && (memcmp\n\t\t\t\t\t\t       (&lastTrans->\n\t\t\t\t\t\t\ttableList\n\t\t\t\t\t\t\t[0],\n\t\t\t\t\t\t\ttableList,\n\t\t\t\t\t\t\ttableListLen)) == 0)\n      return (table = lastTrans->table);\n  currentEntry = tableChain;\n  while (currentEntry != NULL)\n    {\n      if (tableListLen == currentEntry->tableListLength && (memcmp\n\t\t\t\t\t\t\t    (&currentEntry->\n\t\t\t\t\t\t\t     tableList\n\t\t\t\t\t\t\t     [0],\n\t\t\t\t\t\t\t     tableList,\n\t\t\t\t\t\t\t     tableListLen))\n\t  == 0)\n\t{\n\t  lastTrans = currentEntry;\n\t  return (table = currentEntry->table);\n\t}\n      lastEntry = currentEntry;\n      currentEntry = currentEntry->next;\n    }\n  if ((newTable = compileTranslationTable (tableList)))\n    {\n      int entrySize = sizeof (ChainEntry) + tableListLen;\n      ChainEntry *newEntry = malloc (entrySize);\n      if (!newEntry)\n\toutOfMemory ();\n      if (tableChain == NULL)\n\ttableChain = newEntry;\n      else\n\tlastEntry->next = newEntry;\n      newEntry->next = NULL;\n      newEntry->table = newTable;\n      newEntry->tableListLength = tableListLen;\n      memcpy (&newEntry->tableList[0], tableList, tableListLen);\n      lastTrans = newEntry;\n      return newEntry->table;\n    }\n  return NULL;\n}", "target": 0}
{"code": "static int ec2m_field_sanity(void)\n{\n    int ret = 0;\n    BN_CTX *ctx = BN_CTX_new();\n    BIGNUM *p, *a, *b;\n    EC_GROUP *group1 = NULL, *group2 = NULL, *group3 = NULL;\n    TEST_info(\"Testing GF2m hardening\\n\");\n    BN_CTX_start(ctx);\n    p = BN_CTX_get(ctx);\n    a = BN_CTX_get(ctx);\n    if (!TEST_ptr(b = BN_CTX_get(ctx))\n        || !TEST_true(BN_one(a))\n        || !TEST_true(BN_one(b)))\n        goto out;\n    if (!TEST_true(BN_set_word(p, 0xf2)))\n        goto out;\n    if (!TEST_ptr_null(group1 = EC_GROUP_new_curve_GF2m(p, a, b, ctx)))\n        TEST_error(\"Zero constant term accepted in GF2m polynomial\");\n    if (!TEST_true(BN_set_word(p, 0xf3)))\n        goto out;\n    if (!TEST_ptr_null(group2 = EC_GROUP_new_curve_GF2m(p, a, b, ctx)))\n        TEST_error(\"Hexanomial accepted as GF2m polynomial\");\n    if (!TEST_true(BN_set_word(p, 0x71))\n        || !TEST_true(BN_set_bit(p, OPENSSL_ECC_MAX_FIELD_BITS + 1)))\n        goto out;\n    if (!TEST_ptr_null(group3 = EC_GROUP_new_curve_GF2m(p, a, b, ctx)))\n        TEST_error(\"GF2m polynomial degree > %d accepted\",\n                   OPENSSL_ECC_MAX_FIELD_BITS);\n    ret = group1 == NULL && group2 == NULL && group3 == NULL;\n out:\n    EC_GROUP_free(group1);\n    EC_GROUP_free(group2);\n    EC_GROUP_free(group3);\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n    return ret;\n}", "target": 0}
{"code": "void imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const char *src)\n{\n  char *buf = mutt_str_strdup(src);\n  imap_utf_encode(idata, &buf);\n  imap_quote_string(dest, dlen, buf);\n  FREE(&buf);\n}", "target": 1}
{"code": "static uint8_t check_length(uint16_t length, uint16_t offset)\n{\n\tif (length > BT_ATT_MAX_VALUE_LEN)\n\t\treturn BT_ATT_ERROR_INVALID_ATTRIBUTE_VALUE_LEN;\n\tif (offset > BT_ATT_MAX_VALUE_LEN)\n\t\treturn BT_ATT_ERROR_INVALID_OFFSET;\n\tif (length + offset > BT_ATT_MAX_VALUE_LEN)\n\t\treturn BT_ATT_ERROR_INVALID_ATTRIBUTE_VALUE_LEN;\n\treturn 0;\n}", "target": 0}
{"code": "static void __account_cfs_rq_runtime(struct cfs_rq *cfs_rq, u64 delta_exec)\n{\n\tcfs_rq->runtime_remaining -= delta_exec;\n\texpire_cfs_rq_runtime(cfs_rq);\n\tif (likely(cfs_rq->runtime_remaining > 0))\n\t\treturn;\n\tif (!assign_cfs_rq_runtime(cfs_rq) && likely(cfs_rq->curr))\n\t\tresched_curr(rq_of(cfs_rq));\n}", "target": 1}
{"code": "void CoreUserInputHandler::handleSay(const BufferInfo &bufferInfo, const QString &msg)\n{\n    if (bufferInfo.bufferName().isEmpty() || !bufferInfo.acceptsRegularMessages())\n        return;  \n    QByteArray encMsg = channelEncode(bufferInfo.bufferName(), msg);\n#ifdef HAVE_QCA2\n    putPrivmsg(serverEncode(bufferInfo.bufferName()), encMsg, network()->cipher(bufferInfo.bufferName()));\n#else\n    putPrivmsg(serverEncode(bufferInfo.bufferName()), encMsg);\n#endif\n    emit displayMsg(Message::Plain, bufferInfo.type(), bufferInfo.bufferName(), msg, network()->myNick(), Message::Self);\n}", "target": 1}
{"code": "  void ComputeAsync(OpKernelContext* c, DoneCallback done) override {\n    auto col_params = new CollectiveParams();\n    auto done_with_cleanup = [col_params, done = std::move(done)]() {\n      done();\n      col_params->Unref();\n    };\n    core::RefCountPtr<CollectiveGroupResource> resource;\n    OP_REQUIRES_OK_ASYNC(c, LookupResource(c, HandleFromInput(c, 1), &resource),\n                         done);\n    Tensor group_assignment = c->input(2);\n    OP_REQUIRES_OK_ASYNC(\n        c,\n        FillCollectiveParams(col_params, group_assignment,\n                             ALL_TO_ALL_COLLECTIVE, resource.get()),\n        done);\n    col_params->instance.shape = c->input(0).shape();\n    VLOG(1) << \"CollectiveAllToAll group_size \" << col_params->group.group_size\n            << \" group_key \" << col_params->group.group_key << \" instance_key \"\n            << col_params->instance.instance_key;\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK_ASYNC(c,\n                         c->forward_input_or_allocate_output(\n                             {0}, 0, col_params->instance.shape, &output),\n                         done_with_cleanup);\n    Run(c, col_params, std::move(done_with_cleanup));\n  }", "target": 1}
{"code": "checked_xcalloc (size_t num, size_t size)\n{\n    alloc_limit_assert (\"checked_xcalloc\", (num *size));\n    return xcalloc (num, size);\n}", "target": 1}
{"code": "comics_document_init (ComicsDocument *comics_document)\n{\n\tcomics_document->archive = NULL;\n\tcomics_document->page_names = NULL;\n\tcomics_document->extract_command = NULL;\n}", "target": 1}
{"code": "nvkm_vmm_node_merge(struct nvkm_vmm *vmm, struct nvkm_vma *prev,\n\t\t    struct nvkm_vma *vma, struct nvkm_vma *next, u64 size)\n{\n\tif (next) {\n\t\tif (vma->size == size) {\n\t\t\tvma->size += next->size;\n\t\t\tnvkm_vmm_node_delete(vmm, next);\n\t\t\tif (prev) {\n\t\t\t\tprev->size += vma->size;\n\t\t\t\tnvkm_vmm_node_delete(vmm, vma);\n\t\t\t\treturn prev;\n\t\t\t}\n\t\t\treturn vma;\n\t\t}\n\t\tBUG_ON(prev);\n\t\tnvkm_vmm_node_remove(vmm, next);\n\t\tvma->size -= size;\n\t\tnext->addr -= size;\n\t\tnext->size += size;\n\t\tnvkm_vmm_node_insert(vmm, next);\n\t\treturn next;\n\t}\n\tif (prev) {\n\t\tif (vma->size != size) {\n\t\t\tnvkm_vmm_node_remove(vmm, vma);\n\t\t\tprev->size += size;\n\t\t\tvma->addr += size;\n\t\t\tvma->size -= size;\n\t\t\tnvkm_vmm_node_insert(vmm, vma);\n\t\t} else {\n\t\t\tprev->size += vma->size;\n\t\t\tnvkm_vmm_node_delete(vmm, vma);\n\t\t}\n\t\treturn prev;\n\t}\n\treturn vma;\n}", "target": 0}
{"code": "PJ_DEF(pj_status_t) pj_file_setpos( pj_oshandle_t fd,\n                                    pj_off_t offset,\n                                    enum pj_file_seek_type whence)\n{\n    int mode;\n    if ((sizeof(pj_off_t) > sizeof(long)) &&\n        (offset > PJ_MAXLONG || offset < PJ_MINLONG)) \n    {\n        return PJ_ENOTSUP;\n    }\n    switch (whence) {\n    case PJ_SEEK_SET:\n        mode = SEEK_SET; break;\n    case PJ_SEEK_CUR:\n        mode = SEEK_CUR; break;\n    case PJ_SEEK_END:\n        mode = SEEK_END; break;\n    default:\n        pj_assert(!\"Invalid whence in file_setpos\");\n        return PJ_EINVAL;\n    }\n    if (fseek((FILE*)fd, (long)offset, mode) != 0)\n        return PJ_RETURN_OS_ERROR(errno);\n    return PJ_SUCCESS;\n}", "target": 0}
{"code": "mmsMsg_isFilenameSave(const char* filename)\n{\n    if (filename)\n    {\n        if (strstr(filename, \"..\"))\n            return false;\n        if (strstr(filename, \"./\"))\n            return false;\n        return true;\n    }\n    else {\n        return false;\n    }\n}", "target": 0}
{"code": "void grubfs_free (GrubFS *gf) {\n\tif (gf) {\n\t\tif (gf->file && gf->file->device)\n\t\t\tfree (gf->file->device->disk);\n\t\tfree (gf->file);\n\t\tfree (gf);\n\t}\n}", "target": 1}
{"code": "njs_string_alloc(njs_vm_t *vm, njs_value_t *value, uint64_t size,\n    uint64_t length)\n{\n    uint32_t      total, map_offset, *map;\n    njs_string_t  *string;\n    if (njs_slow_path(size > NJS_STRING_MAX_LENGTH)) {\n        njs_range_error(vm, \"invalid string length\");\n        return NULL;\n    }\n    value->type = NJS_STRING;\n    njs_string_truth(value, size);\n    if (size <= NJS_STRING_SHORT) {\n        value->short_string.size = size;\n        value->short_string.length = length;\n        return value->short_string.start;\n    }\n    value->short_string.size = NJS_STRING_LONG;\n    value->short_string.length = 0;\n    value->long_string.external = 0;\n    value->long_string.size = size;\n    if (size != length && length > NJS_STRING_MAP_STRIDE) {\n        map_offset = njs_string_map_offset(size);\n        total = map_offset + njs_string_map_size(length);\n    } else {\n        map_offset = 0;\n        total = size;\n    }\n    string = njs_mp_alloc(vm->mem_pool, sizeof(njs_string_t) + total);\n    if (njs_fast_path(string != NULL)) {\n        value->long_string.data = string;\n        string->start = (u_char *) string + sizeof(njs_string_t);\n        string->length = length;\n        string->retain = 1;\n        if (map_offset != 0) {\n            map = (uint32_t *) (string->start + map_offset);\n            map[0] = 0;\n        }\n        return string->start;\n    }\n    njs_memory_error(vm);\n    return NULL;\n}", "target": 0}
{"code": "static inline void vmacache_invalidate(struct mm_struct *mm)\n{\n\tmm->vmacache_seqnum++;\n\tif (unlikely(mm->vmacache_seqnum == 0))\n\t\tvmacache_flush_all(mm);\n}", "target": 1}
{"code": "int CLASS ljpeg_start (struct jhead *jh, int info_only)\n{\n  int c, tag, len;\n  uchar data[0x10000];\n  const uchar *dp;\n  memset (jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  fread (data, 2, 1, ifp);\n  if (data[1] != 0xd8) return 0;\n  do {\n    fread (data, 2, 2, ifp);\n    tag =  data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00) return 0;\n    fread (data, 1, len, ifp);\n    switch (tag) {\n      case 0xffc3:\n\tjh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n      case 0xffc0:\n\tjh->bits = data[0];\n\tjh->high = data[1] << 8 | data[2];\n\tjh->wide = data[3] << 8 | data[4];\n\tjh->clrs = data[5] + jh->sraw;\n\tif (len == 9 && !dng_version) getc(ifp);\n\tbreak;\n      case 0xffc4:\n\tif (info_only) break;\n\tfor (dp = data; dp < data+len && (c = *dp++) < 4; )\n\t  jh->free[c] = jh->huff[c] = make_decoder_ref (&dp);\n\tbreak;\n      case 0xffda:\n\tjh->psv = data[1+data[0]*2];\n\tjh->bits -= data[3+data[0]*2] & 15;\n\tbreak;\n      case 0xffdd:\n\tjh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (info_only) return 1;\n  if (jh->clrs > 6 || !jh->huff[0]) return 0;\n  FORC(5) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c];\n  if (jh->sraw) {\n    FORC(4)        jh->huff[2+c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1+c] = jh->huff[0];\n  }\n  jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);\n  merror (jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}", "target": 1}
{"code": "Filter::UpstreamRequest::~UpstreamRequest() {\n  if (span_ != nullptr) {\n    Tracing::HttpTracerUtility::finalizeUpstreamSpan(*span_, upstream_headers_.get(),\n                                                     upstream_trailers_.get(), stream_info_,\n                                                     Tracing::EgressConfig::get());\n  }\n  if (per_try_timeout_ != nullptr) {\n    per_try_timeout_->disableTimer();\n  }\n  clearRequestEncoder();\n  stream_info_.setUpstreamTiming(upstream_timing_);\n  stream_info_.onRequestComplete();\n  if (upstream_headers_ != nullptr) {\n    upstream_headers_->refreshByteSize();\n  }\n  if (upstream_trailers_ != nullptr) {\n    upstream_trailers_->refreshByteSize();\n  }\n  for (const auto& upstream_log : parent_.config_.upstream_logs_) {\n    upstream_log->log(parent_.downstream_headers_, upstream_headers_.get(),\n                      upstream_trailers_.get(), stream_info_);\n  }\n}", "target": 0}
{"code": "static inline bool cfs_rq_is_decayed(struct cfs_rq *cfs_rq)\n{\n\tif (cfs_rq->load.weight)\n\t\treturn false;\n\tif (cfs_rq->avg.load_sum)\n\t\treturn false;\n\tif (cfs_rq->avg.util_sum)\n\t\treturn false;\n\tif (cfs_rq->avg.runnable_load_sum)\n\t\treturn false;\n\treturn true;\n}", "target": 1}
{"code": "static ssize_t process_output_block(struct tty_struct *tty,\n\t\t\t\t    const unsigned char *buf, unsigned int nr)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint\tspace;\n\tint\ti;\n\tconst unsigned char *cp;\n\tmutex_lock(&ldata->output_lock);\n\tspace = tty_write_room(tty);\n\tif (!space) {\n\t\tmutex_unlock(&ldata->output_lock);\n\t\treturn 0;\n\t}\n\tif (nr > space)\n\t\tnr = space;\n\tfor (i = 0, cp = buf; i < nr; i++, cp++) {\n\t\tunsigned char c = *cp;\n\t\tswitch (c) {\n\t\tcase '\\n':\n\t\t\tif (O_ONLRET(tty))\n\t\t\t\tldata->column = 0;\n\t\t\tif (O_ONLCR(tty))\n\t\t\t\tgoto break_out;\n\t\t\tldata->canon_column = ldata->column;\n\t\t\tbreak;\n\t\tcase '\\r':\n\t\t\tif (O_ONOCR(tty) && ldata->column == 0)\n\t\t\t\tgoto break_out;\n\t\t\tif (O_OCRNL(tty))\n\t\t\t\tgoto break_out;\n\t\t\tldata->canon_column = ldata->column = 0;\n\t\t\tbreak;\n\t\tcase '\\t':\n\t\t\tgoto break_out;\n\t\tcase '\\b':\n\t\t\tif (ldata->column > 0)\n\t\t\t\tldata->column--;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!iscntrl(c)) {\n\t\t\t\tif (O_OLCUC(tty))\n\t\t\t\t\tgoto break_out;\n\t\t\t\tif (!is_continuation(c, tty))\n\t\t\t\t\tldata->column++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\nbreak_out:\n\ti = tty->ops->write(tty, buf, i);\n\tmutex_unlock(&ldata->output_lock);\n\treturn i;\n}", "target": 0}
{"code": "static int proc_readdir(const char *path, void *buf, fuse_fill_dir_t filler, off_t offset,\n\t\tstruct fuse_file_info *fi)\n{\n\tif (filler(buf, \"cpuinfo\", NULL, 0) != 0 ||\n\t\t\t\tfiller(buf, \"meminfo\", NULL, 0) != 0 ||\n\t\t\t\tfiller(buf, \"stat\", NULL, 0) != 0 ||\n\t\t\t\tfiller(buf, \"uptime\", NULL, 0) != 0 ||\n\t\t\t\tfiller(buf, \"diskstats\", NULL, 0) != 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 0}
{"code": "void next_character(void)\n{\n    if (!recovery_started) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");\n        layoutHome();\n        return;\n    }\n    strlcpy(cipher, english_alphabet, ENGLISH_ALPHABET_BUF);\n    random_permute_char(cipher, strlen(cipher));\n    static char CONFIDENTIAL current_word[CURRENT_WORD_BUF];\n    get_current_word(current_word);\n    if (strlen(current_word) > 4) {\n        memzero(current_word, sizeof(current_word));\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_SyntaxError,\n                        \"Words were not entered correctly. Make sure you are using the substition cipher.\");\n        layoutHome();\n        return;\n    }\n    CharacterRequest resp;\n    memset(&resp, 0, sizeof(CharacterRequest));\n    resp.word_pos = get_current_word_pos();\n    resp.character_pos = strlen(current_word);\n    msg_write(MessageType_MessageType_CharacterRequest, &resp);\n    bool auto_completed = false;\n    if (strlen(current_word) >= 3) {\n        auto_completed = attempt_auto_complete(current_word);\n    }\n#if DEBUG_LINK\n    if (auto_completed) {\n        strlcpy(auto_completed_word, current_word, CURRENT_WORD_BUF);\n    } else {\n        auto_completed_word[0] = '\\0';\n    }\n#endif\n    format_current_word(current_word, auto_completed);\n    layout_cipher(current_word, cipher);\n    memzero(current_word, sizeof(current_word));\n}", "target": 0}
{"code": "static void show_object(struct object *obj,\n\t\t\tstruct strbuf *path, const char *component,\n\t\t\tvoid *cb_data)\n{\n\tstruct rev_list_info *info = cb_data;\n\tfinish_object(obj, path, component, cb_data);\n\tif (info->flags & REV_LIST_QUIET)\n\t\treturn;\n\tshow_object_with_name(stdout, obj, path, component);\n}", "target": 1}
{"code": "int ZlibInStream::overrun(int itemSize, int nItems, bool wait)\n{\n  if (itemSize > bufSize)\n    throw Exception(\"ZlibInStream overrun: max itemSize exceeded\");\n  if (!underlying)\n    throw Exception(\"ZlibInStream overrun: no underlying stream\");\n  if (end - ptr != 0)\n    memmove(start, ptr, end - ptr);\n  offset += ptr - start;\n  end -= ptr - start;\n  ptr = start;\n  while (end - ptr < itemSize) {\n    if (!decompress(wait))\n      return 0;\n  }\n  if (itemSize * nItems > end - ptr)\n    nItems = (end - ptr) / itemSize;\n  return nItems;\n}", "target": 1}
{"code": "static int get_exif_tag_dbl_value(struct iw_exif_state *e, unsigned int tag_pos,\n\tdouble *pv)\n{\n\tunsigned int field_type;\n\tunsigned int value_count;\n\tunsigned int value_pos;\n\tunsigned int numer, denom;\n\tfield_type = iw_get_ui16_e(&e->d[tag_pos+2],e->endian);\n\tvalue_count = iw_get_ui32_e(&e->d[tag_pos+4],e->endian);\n\tif(value_count!=1) return 0;\n\tif(field_type!=5) return 0; \n\tvalue_pos = iw_get_ui32_e(&e->d[tag_pos+8],e->endian);\n\tif(value_pos > e->d_len-8) return 0;\n\tnumer = iw_get_ui32_e(&e->d[value_pos  ],e->endian);\n\tdenom = iw_get_ui32_e(&e->d[value_pos+4],e->endian);\n\tif(denom==0) return 0;\n\t*pv = ((double)numer)/denom;\n\treturn 1;\n}", "target": 1}
{"code": "int64_t OutputFile::readImpl(char* , int64_t ) {\n  raise_warning(\"cannot read from a php:\n  return -1;\n}", "target": 1}
{"code": "static void wipe_keys()\n{\n\tmemset(cmac_key, 0, sizeof(cmac_key));\n\tmemset(cipher_key, 0, sizeof(cipher_key));\n\tmemset(iv, 0, sizeof(iv));\n}", "target": 0}
{"code": "parse_memory(VALUE klass, VALUE data)\n{\n  xmlParserCtxtPtr ctxt;\n  if (NIL_P(data)) {\n    rb_raise(rb_eArgError, \"data cannot be nil\");\n  }\n  if (!(int)RSTRING_LEN(data)) {\n    rb_raise(rb_eRuntimeError, \"data cannot be empty\");\n  }\n  ctxt = xmlCreateMemoryParserCtxt(StringValuePtr(data),\n                                   (int)RSTRING_LEN(data));\n  if (ctxt->sax) {\n    xmlFree(ctxt->sax);\n    ctxt->sax = NULL;\n  }\n  return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);\n}", "target": 1}
{"code": "static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int nodigest, int nocontent)\n{\n    FD_t wfd = NULL;\n    int rc = 0;\n    {\n\tmode_t old_umask = umask(0577);\n\twfd = Fopen(dest, \"w.ufdio\");\n\tumask(old_umask);\n    }\n    if (Ferror(wfd)) {\n\trc = RPMERR_OPEN_FAILED;\n\tgoto exit;\n    }\n    if (!nocontent)\n\trc = rpmfiArchiveReadToFilePsm(fi, wfd, nodigest, psm);\nexit:\n    if (wfd) {\n\tint myerrno = errno;\n\tFclose(wfd);\n\terrno = myerrno;\n    }\n    return rc;\n}", "target": 1}
{"code": "bool RepeatedAttrDefEqual(\n    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a1,\n    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a2) {\n  std::unordered_map<string, const OpDef::AttrDef*> a1_set;\n  for (const OpDef::AttrDef& def : a1) {\n    DCHECK(a1_set.find(def.name()) == a1_set.end())\n        << \"AttrDef names must be unique, but '\" << def.name()\n        << \"' appears more than once\";\n    a1_set[def.name()] = &def;\n  }\n  for (const OpDef::AttrDef& def : a2) {\n    auto iter = a1_set.find(def.name());\n    if (iter == a1_set.end()) return false;\n    if (!AttrDefEqual(*iter->second, def)) return false;\n    a1_set.erase(iter);\n  }\n  if (!a1_set.empty()) return false;\n  return true;\n}", "target": 1}
{"code": "pci_emul_alloc_resource(uint64_t *baseptr, uint64_t limit, uint64_t size,\n\t\t\tuint64_t *addr)\n{\n\tuint64_t base;\n\tassert((size & (size - 1)) == 0);\t\n\tbase = roundup2(*baseptr, size);\n\tif (base + size <= limit) {\n\t\t*addr = base;\n\t\t*baseptr = base + size;\n\t\treturn 0;\n\t} else\n\t\treturn -1;\n}", "target": 1}
{"code": "  Status Init(DataType input_type, const string& fill = \"\", int width = -1,\n              int precision = -1, bool scientific = false,\n              bool shortest = false) {\n    TF_CHECK_OK(NodeDefBuilder(\"op\", \"AsString\")\n                    .Input(FakeInput(input_type))\n                    .Attr(\"fill\", fill)\n                    .Attr(\"precision\", precision)\n                    .Attr(\"scientific\", scientific)\n                    .Attr(\"shortest\", shortest)\n                    .Attr(\"width\", width)\n                    .Finalize(node_def()));\n    return InitOp();\n  }", "target": 0}
{"code": "void PDPServer::perform_builtin_endpoints_matching(\n        const ParticipantProxyData& pdata)\n{\n    if (mp_EDP != nullptr)\n    {\n        mp_EDP->assignRemoteEndpoints(pdata);\n    }\n    if (mp_builtin->mp_WLP != nullptr)\n    {\n        mp_builtin->mp_WLP->assignRemoteEndpoints(pdata);\n    }\n}", "target": 1}
{"code": "static void ossl_associate_connection(struct Curl_easy *data,\n                                      struct connectdata *conn,\n                                      int sockindex)\n{\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  if(!backend->handle)\n    return;\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    int data_idx = ossl_get_ssl_data_index();\n    int connectdata_idx = ossl_get_ssl_conn_index();\n    int sockindex_idx = ossl_get_ssl_sockindex_index();\n    int proxy_idx = ossl_get_proxy_index();\n    if(data_idx >= 0 && connectdata_idx >= 0 && sockindex_idx >= 0 &&\n       proxy_idx >= 0) {\n      SSL_set_ex_data(backend->handle, data_idx, data);\n      SSL_set_ex_data(backend->handle, connectdata_idx, conn);\n      SSL_set_ex_data(backend->handle, sockindex_idx, conn->sock + sockindex);\n#ifndef CURL_DISABLE_PROXY\n      SSL_set_ex_data(backend->handle, proxy_idx, SSL_IS_PROXY() ? (void *) 1:\n                      NULL);\n#else\n      SSL_set_ex_data(backend->handle, proxy_idx, NULL);\n#endif\n    }\n  }\n}", "target": 0}
{"code": "xmlAddID(xmlValidCtxtPtr ctxt, xmlDocPtr doc, const xmlChar *value,\n         xmlAttrPtr attr) {\n    xmlIDPtr ret;\n    xmlIDTablePtr table;\n    if (doc == NULL) {\n\treturn(NULL);\n    }\n    if (value == NULL) {\n\treturn(NULL);\n    }\n    if (attr == NULL) {\n\treturn(NULL);\n    }\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)  {\n        doc->ids = table = xmlHashCreateDict(0, doc->dict);\n    }\n    if (table == NULL) {\n\txmlVErrMemory(ctxt,\n\t\t\"xmlAddID: Table creation failed!\\n\");\n        return(NULL);\n    }\n    ret = (xmlIDPtr) xmlMalloc(sizeof(xmlID));\n    if (ret == NULL) {\n\txmlVErrMemory(ctxt, \"malloc failed\");\n\treturn(NULL);\n    }\n    ret->value = xmlStrdup(value);\n    ret->doc = doc;\n    if ((ctxt != NULL) && (ctxt->vstateNr != 0)) {\n\tif (doc->dict != NULL)\n\t    ret->name = xmlDictLookup(doc->dict, attr->name, -1);\n\telse\n\t    ret->name = xmlStrdup(attr->name);\n\tret->attr = NULL;\n    } else {\n\tret->attr = attr;\n\tret->name = NULL;\n    }\n    ret->lineno = xmlGetLineNo(attr->parent);\n    if (xmlHashAddEntry(table, value, ret) < 0) {\n#ifdef LIBXML_VALID_ENABLED\n\tif (ctxt != NULL) {\n\t    xmlErrValidNode(ctxt, attr->parent, XML_DTD_ID_REDEFINED,\n\t\t\t    \"ID %s already defined\\n\", value, NULL, NULL);\n\t}\n#endif \n\txmlFreeID(ret);\n\treturn(NULL);\n    }\n    if (attr != NULL)\n\tattr->atype = XML_ATTRIBUTE_ID;\n    return(ret);\n}", "target": 1}
{"code": "static long adpt_unlocked_ioctl(struct file *file, uint cmd, ulong arg)\n{\n\tstruct inode *inode;\n\tlong ret;\n\tinode = file_inode(file);\n\tmutex_lock(&adpt_mutex);\n\tret = adpt_ioctl(inode, file, cmd, arg);\n\tmutex_unlock(&adpt_mutex);\n\treturn ret;\n}", "target": 1}
{"code": "static void lsr_read_extend_class(GF_LASeRCodec *lsr, char **out_data, u32 *out_len, const char *name)\n{\n\tu32 len;\n\tGF_LSR_READ_INT(lsr, len, lsr->info->cfg.extensionIDBits, \"reserved\");\n\tlen = lsr_read_vluimsbf5(lsr, \"len\");\n\tgf_bs_read_long_int(lsr->bs, len);\n\tif (out_data) *out_data = NULL;\n\tif (out_len) *out_len = 0;\n}", "target": 1}
{"code": "static int ldb_msg_append_value_impl(struct ldb_message *msg,\n\t\t\t\t     const char *attr_name,\n\t\t\t\t     const struct ldb_val *val,\n\t\t\t\t     int flags,\n\t\t\t\t     struct ldb_message_element **return_el)\n{\n\tstruct ldb_message_element *el = NULL;\n\tint ret;\n\tret = ldb_msg_add_empty(msg, attr_name, flags, &el);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tret = ldb_msg_element_add_value(msg->elements, el, val);\n\tif (ret != LDB_SUCCESS) {\n\t\treturn ret;\n\t}\n\tif (return_el != NULL) {\n\t\t*return_el = el;\n\t}\n\treturn LDB_SUCCESS;\n}", "target": 0}
{"code": "static int l2cap_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)\n{\n\tstruct sockaddr_l2 *la = (struct sockaddr_l2 *) addr;\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\tmemset(la, 0, sizeof(struct sockaddr_l2));\n\taddr->sa_family = AF_BLUETOOTH;\n\t*len = sizeof(struct sockaddr_l2);\n\tif (peer) {\n\t\tla->l2_psm = chan->psm;\n\t\tbacpy(&la->l2_bdaddr, &bt_sk(sk)->dst);\n\t\tla->l2_cid = cpu_to_le16(chan->dcid);\n\t} else {\n\t\tla->l2_psm = chan->sport;\n\t\tbacpy(&la->l2_bdaddr, &bt_sk(sk)->src);\n\t\tla->l2_cid = cpu_to_le16(chan->scid);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int do_prlimit(struct task_struct *tsk, unsigned int resource,\n\t\t      struct rlimit *new_rlim, struct rlimit *old_rlim)\n{\n\tstruct rlimit *rlim;\n\tint retval = 0;\n\tif (resource >= RLIM_NLIMITS)\n\t\treturn -EINVAL;\n\tresource = array_index_nospec(resource, RLIM_NLIMITS);\n\tif (new_rlim) {\n\t\tif (new_rlim->rlim_cur > new_rlim->rlim_max)\n\t\t\treturn -EINVAL;\n\t\tif (resource == RLIMIT_NOFILE &&\n\t\t\t\tnew_rlim->rlim_max > sysctl_nr_open)\n\t\t\treturn -EPERM;\n\t}\n\trlim = tsk->signal->rlim + resource;\n\ttask_lock(tsk->group_leader);\n\tif (new_rlim) {\n\t\tif (new_rlim->rlim_max > rlim->rlim_max &&\n\t\t\t\t!capable(CAP_SYS_RESOURCE))\n\t\t\tretval = -EPERM;\n\t\tif (!retval)\n\t\t\tretval = security_task_setrlimit(tsk, resource, new_rlim);\n\t}\n\tif (!retval) {\n\t\tif (old_rlim)\n\t\t\t*old_rlim = *rlim;\n\t\tif (new_rlim)\n\t\t\t*rlim = *new_rlim;\n\t}\n\ttask_unlock(tsk->group_leader);\n\tif (!retval && new_rlim && resource == RLIMIT_CPU &&\n\t    new_rlim->rlim_cur != RLIM_INFINITY &&\n\t    IS_ENABLED(CONFIG_POSIX_TIMERS)) {\n\t\tupdate_rlimit_cpu(tsk->group_leader, new_rlim->rlim_cur);\n\t}\n\treturn retval;\n}", "target": 0}
{"code": "dig_t bn_get_prime(int pos) {\n\tif (pos >= BASIC_TESTS) {\n\t\treturn 0;\n\t}\n\treturn primes[pos];\n}", "target": 1}
{"code": "static void process_event_record(MYSQL_THD thd, LEX_CSTRING event_name,\n                                 const char *data, size_t data_length)\n{\n  const char *record_str = (const char *)THDVAR(thd, event_record_def);\n  LEX_CSTRING record_begin = get_token(&record_str);\n  LEX_CSTRING record_end = get_token(&record_str);\n  if (record_str == NULL)\n  {\n    return;\n  }\n  if (record_end.length == 0)\n  {\n    const char *buffer= THDVAR(thd, event_record);\n    add_event(thd, buffer, event_name, data, data_length);\n    my_free((void *)(buffer));\n    if (!my_charset_latin1.coll->strnncoll(&my_charset_latin1,\n                                           (const uchar *)record_begin.str,\n                                           record_begin.length,\n                                           (const uchar *)event_name.str,\n                                           event_name.length, FALSE))\n    {\n      THDVAR(thd, event_record_def)= 0;\n    }\n  }\n  else\n  {\n    const char *buffer;\n    if (my_charset_latin1.coll->strnncoll(&my_charset_latin1,\n                                          (const uchar *)record_begin.str,\n                                          record_begin.length,\n                                          (const uchar *)event_name.str,\n                                          event_name.length, FALSE))\n    {\n      return;\n    }\n    buffer= THDVAR(thd, event_record);\n    my_free((void *)(buffer));\n    THDVAR(thd, event_record)= 0;\n    add_event(thd, \"\", event_name, data, data_length);\n    record_str = (const char *)THDVAR(thd, event_record_def);\n    memmove((char *)record_str, (void *)record_end.str, record_end.length + 1);\n  }\n}", "target": 0}
{"code": "pci_set_cfgdata32(struct pci_vdev *dev, int offset, uint32_t val)\n{\n\tassert(offset <= (PCI_REGMAX - 3) && (offset & 3) == 0);\n\t*(uint32_t *)(dev->cfgdata + offset) = val;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    OpInputList params_nested_splits_in;\n    OP_REQUIRES_OK(context, context->input_list(\"params_nested_splits\",\n                                                &params_nested_splits_in));\n    const Tensor& params_dense_values_in =\n        context->input(params_nested_splits_in.size());\n    const Tensor& indices_in =\n        context->input(params_nested_splits_in.size() + 1);\n    DCHECK_GT(params_nested_splits_in.size(), 0);  \n    SPLITS_TYPE num_params = params_nested_splits_in[0].dim_size(0) - 1;\n    OP_REQUIRES_OK(context, ValidateIndices(indices_in, num_params));\n    OP_REQUIRES(context, params_dense_values_in.dims() > 0,\n                errors::InvalidArgument(\"params.rank must be nonzero\"));\n    SPLITS_TYPE num_params_dense_values = params_dense_values_in.dim_size(0);\n    std::vector<std::pair<SPLITS_TYPE, SPLITS_TYPE>> value_slices;\n    SPLITS_TYPE num_values = 0;\n    std::vector<std::vector<SPLITS_TYPE>> out_splits;\n    OP_REQUIRES_OK(context, MakeSplits(indices_in, params_nested_splits_in,\n                                       num_params_dense_values, &out_splits,\n                                       &value_slices, &num_values));\n    OP_REQUIRES_OK(context, WriteSplits(out_splits, context));\n    OP_REQUIRES_OK(context,\n                   WriteValues(params_dense_values_in, value_slices,\n                               out_splits.size(), num_values, context));\n  }", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& sorted_inputs_t = ctx->input(0);\n    const Tensor& values_t = ctx->input(1);\n    OP_REQUIRES(\n        ctx, sorted_inputs_t.shape().dims() >= 2,\n        errors::InvalidArgument(\"sorted input argument must be a matrix\"));\n    OP_REQUIRES(ctx, sorted_inputs_t.dim_size(0) == values_t.dim_size(0),\n                Status(error::INVALID_ARGUMENT,\n                       \"Leading dim_size of both tensors must match.\"));\n    OP_REQUIRES(ctx, values_t.NumElements() < std::numeric_limits<int>::max(),\n                Status(error::INVALID_ARGUMENT,\n                       \"values tensor size must less than INT_MAX\"));\n    Tensor* output_t;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, values_t.shape(), &output_t));\n    if (output_t->dtype() == DT_INT32) {\n      OP_REQUIRES(ctx,\n                  FastBoundsCheck(sorted_inputs_t.dim_size(1),\n                                  std::numeric_limits<int>::max()),\n                  errors::InvalidArgument(\"trailing dim_size must less than \"\n                                          \"INT_MAX for int32 output type, was \",\n                                          sorted_inputs_t.dim_size(1)));\n    }\n    auto output = output_t->template flat<OutType>();\n    const auto sorted_inputs = sorted_inputs_t.template flat<T>();\n    const auto values = values_t.template flat<T>();\n    if (sorted_inputs.size() == 0) {\n      functor::SetZeroFunctor<Device, OutType> set_zero;\n      set_zero(ctx->eigen_device<Device>(), output);\n      return;\n    }\n    OP_REQUIRES_OK(\n        ctx, functor::UpperBoundFunctor<Device, T, OutType>::Compute(\n                 ctx, sorted_inputs, values, sorted_inputs_t.dim_size(0),\n                 sorted_inputs_t.dim_size(1), values_t.dim_size(1), &output));\n  }", "target": 0}
{"code": "static int hashKey(DIGEST_CTX hash, const struct pgpPkt *pkt, int exptag)\n{\n    int rc = -1;\n    if (pkt->tag == exptag) {\n\tuint8_t head[] = {\n\t    0x99,\n\t    (pkt->blen >> 8),\n\t    (pkt->blen     ),\n\t};\n\trpmDigestUpdate(hash, head, 3);\n\trpmDigestUpdate(hash, pkt->body, pkt->blen);\n\trc = 0;\n    }\n    return rc;\n}", "target": 0}
{"code": "static void adpt_i2o_post_wait_complete(u32 context, int status)\n{\n\tstruct adpt_i2o_post_wait_data *p1 = NULL;\n\tcontext &= 0x7fff;\n\tspin_lock(&adpt_post_wait_lock);\n\tfor(p1 = adpt_post_wait_queue; p1; p1 = p1->next) {\n\t\tif(p1->id == context) {\n\t\t\tp1->status = status;\n\t\t\tspin_unlock(&adpt_post_wait_lock);\n\t\t\twake_up_interruptible(p1->wq);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock(&adpt_post_wait_lock);\n\tprintk(KERN_DEBUG\"dpti: Could Not find task %d in wait queue\\n\",context);\n\tprintk(KERN_DEBUG\"      Tasks in wait queue:\\n\");\n\tfor(p1 = adpt_post_wait_queue; p1; p1 = p1->next) {\n\t\tprintk(KERN_DEBUG\"           %d\\n\",p1->id);\n\t}\n\treturn;\n}", "target": 1}
{"code": "DEFINE_TEST(test_write_disk_fixup)\n{\n\tstruct archive *ad;\n\tstruct archive_entry *ae;\n\tint r;\n\tif (!canSymlink()) {\n\t\tskipping(\"Symlinks not supported\");\n\t\treturn;\n\t}\n\tassert((ad = archive_write_disk_new()) != NULL);\n\tassertMakeFile(\"victim\", 0600, \"a\");\n        assert((ae = archive_entry_new()) != NULL);\n        archive_entry_copy_pathname(ae, \"dir\");\n        archive_entry_set_mode(ae, AE_IFDIR | 0606);\n\tassertEqualIntA(ad, 0, archive_write_header(ad, ae));\n\tassertEqualIntA(ad, 0, archive_write_finish_entry(ad));\n        archive_entry_free(ae);\n\tassert((ae = archive_entry_new()) != NULL);\n\tarchive_entry_copy_pathname(ae, \"dir\");\n\tarchive_entry_set_mode(ae, AE_IFLNK | 0777);\n\tarchive_entry_set_size(ae, 0);\n\tarchive_entry_copy_symlink(ae, \"victim\");\n\tassertEqualIntA(ad, 0, r = archive_write_header(ad, ae));\n\tif (r >= ARCHIVE_WARN)\n\t\tassertEqualIntA(ad, 0, archive_write_finish_entry(ad));\n\tarchive_entry_free(ae);\n\tassertEqualInt(ARCHIVE_OK, archive_write_free(ad));\n\tassertIsSymlink(\"dir\", \"victim\", 0);\n\tassertFileMode(\"victim\", 0600);\n}", "target": 0}
{"code": "MONGO_EXPORT int bson_finish( bson *b ) {\n    int i;\n    if( b->err & BSON_NOT_UTF8 )\n        return BSON_ERROR;\n    if ( ! b->finished ) {\n        if ( bson_ensure_space( b, 1 ) == BSON_ERROR ) return BSON_ERROR;\n        bson_append_byte( b, 0 );\n        i = b->cur - b->data;\n        bson_little_endian32( b->data, &i );\n        b->finished = 1;\n    }\n    return BSON_OK;\n}", "target": 1}
{"code": "fu_plugin_config_func(void)\n{\n\tGStatBuf statbuf = {0};\n\tgboolean ret;\n\tgint rc;\n\tg_autofree gchar *conf_dir = NULL;\n\tg_autofree gchar *conf_file = NULL;\n\tg_autofree gchar *fn = NULL;\n\tg_autofree gchar *testdatadir = NULL;\n\tg_autofree gchar *value = NULL;\n\tg_autoptr(FuPlugin) plugin = fu_plugin_new(NULL);\n\tg_autoptr(GError) error = NULL;\n\ttestdatadir = g_test_build_filename(G_TEST_BUILT, \"tests\", NULL);\n\t(void)g_setenv(\"FWUPD_SYSCONFDIR\", testdatadir, TRUE);\n\tconf_dir = fu_path_from_kind(FU_PATH_KIND_SYSCONFDIR_PKG);\n\tfu_plugin_set_name(plugin, \"test\");\n\tconf_file = g_strdup_printf(\"%s.conf\", fu_plugin_get_name(plugin));\n\tfn = g_build_filename(conf_dir, conf_file, NULL);\n\tret = fu_path_mkdir_parent(fn, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_remove(fn);\n\tret = g_file_set_contents(fn, \"\", -1, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tret = fu_plugin_set_config_value(plugin, \"Key\", \"True\", &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_true(g_file_test(fn, G_FILE_TEST_EXISTS));\n\trc = g_stat(fn, &statbuf);\n\tg_assert_cmpint(rc, ==, 0);\n\tg_assert_cmpint(statbuf.st_mode & 0777, ==, 0644);\n\tvalue = fu_plugin_get_config_value(plugin, \"Key\");\n\tg_assert_cmpstr(value, ==, \"True\");\n\tg_assert_true(fu_plugin_get_config_value_boolean(plugin, \"Key\"));\n\tret = fu_plugin_set_secure_config_value(plugin, \"Key\", \"False\", &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\trc = g_stat(fn, &statbuf);\n\tg_assert_cmpint(rc, ==, 0);\n\tg_assert_cmpint(statbuf.st_mode & 0777, ==, 0640);\n}", "target": 0}
{"code": "static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)\n{\n\treturn crypto_skcipher_setkey(private, key, keylen);\n}", "target": 1}
{"code": "mm_zfree(struct mm_master *mm, void *address)\n{\n\tmm_free(mm, address);\n}", "target": 1}
{"code": "static uint32_t color_string_to_rgba(const char *p, int len)\n{\n    uint32_t ret = 0xFF000000;\n    const ColorEntry *entry;\n    char color_name[100];\n    len = FFMIN(FFMAX(len, 0), sizeof(color_name) - 1);\n    if (*p == '#') {\n        p++;\n        len--;\n        if (len == 3) {\n            ret |= (hex_char_to_number(p[2]) <<  4) |\n                   (hex_char_to_number(p[1]) << 12) |\n                   (hex_char_to_number(p[0]) << 20);\n        } else if (len == 4) {\n            ret  = (hex_char_to_number(p[3]) <<  4) |\n                   (hex_char_to_number(p[2]) << 12) |\n                   (hex_char_to_number(p[1]) << 20) |\n                   (hex_char_to_number(p[0]) << 28);\n        } else if (len == 6) {\n            ret |=  hex_char_to_number(p[5])        |\n                   (hex_char_to_number(p[4]) <<  4) |\n                   (hex_char_to_number(p[3]) <<  8) |\n                   (hex_char_to_number(p[2]) << 12) |\n                   (hex_char_to_number(p[1]) << 16) |\n                   (hex_char_to_number(p[0]) << 20);\n        } else if (len == 8) {\n            ret  =  hex_char_to_number(p[7])        |\n                   (hex_char_to_number(p[6]) <<  4) |\n                   (hex_char_to_number(p[5]) <<  8) |\n                   (hex_char_to_number(p[4]) << 12) |\n                   (hex_char_to_number(p[3]) << 16) |\n                   (hex_char_to_number(p[2]) << 20) |\n                   (hex_char_to_number(p[1]) << 24) |\n                   (hex_char_to_number(p[0]) << 28);\n        }\n    } else {\n        strncpy(color_name, p, len);\n        color_name[len] = '\\0';\n        entry = bsearch(color_name,\n                        color_table,\n                        FF_ARRAY_ELEMS(color_table),\n                        sizeof(ColorEntry),\n                        color_table_compare);\n        if (!entry)\n            return ret;\n        ret = entry->rgb_color;\n    }\n    return ret;\n}", "target": 0}
{"code": "comics_decompress_temp_dir (const gchar *command_decompress_tmp,\n\t\t\t    const gchar *command,\n\t\t\t    GError      **error)\n{\n\tgboolean success;\n\tgchar *std_out, *basename;\n\tGError *err = NULL;\n\tgint retval;\n\tsuccess = g_spawn_command_line_sync (command_decompress_tmp, &std_out,\n\t\t\t\t\t     NULL, &retval, &err);\n\tbasename = g_path_get_basename (command);\n\tif (!success) {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"Error launching the command %s in order to \"\n\t\t\t     \"decompress the comic book: %s\"),\n\t\t\t     basename,\n\t\t\t     err->message);\n\t\tg_error_free (err);\n\t} else if (WIFEXITED (retval)) {\n\t\tif (WEXITSTATUS (retval) == EXIT_SUCCESS) {\n\t\t\tg_free (std_out);\n\t\t\tg_free (basename);\n\t\t\treturn TRUE;\n\t\t} else {\n\t\t\tg_set_error (error,\n\t\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t\t     _(\"The command %s failed at \"\n\t\t\t\t     \"decompressing the comic book.\"),\n\t\t\t\t     basename);\n\t\t\tg_free (std_out);\n\t\t}\n\t} else {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"The command %s did not end normally.\"),\n\t\t\t     basename);\n\t\tg_free (std_out);\n\t}\n\tg_free (basename);\n\treturn FALSE;\n}", "target": 1}
{"code": "bool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, int *r, struct dest_map *dest_map)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap;\n\tstruct kvm_lapic **dst = NULL;\n\tint i;\n\tbool ret;\n\t*r = -1;\n\tif (irq->shorthand == APIC_DEST_SELF) {\n\t\tif (KVM_BUG_ON(!src, kvm)) {\n\t\t\t*r = 0;\n\t\t\treturn true;\n\t\t}\n\t\t*r = kvm_apic_set_irq(src->vcpu, irq, dest_map);\n\t\treturn true;\n\t}\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\tret = kvm_apic_map_get_dest_lapic(kvm, &src, irq, map, &dst, &bitmap);\n\tif (ret) {\n\t\t*r = 0;\n\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\tif (!dst[i])\n\t\t\t\tcontinue;\n\t\t\t*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}", "target": 0}
{"code": "TfLiteStatus CalculateOpData(TfLiteContext* context, TfLiteNode* node,\n                             TfLiteDepthwiseConvParams* params, int width,\n                             int height, int filter_width, int filter_height,\n                             const TfLiteType data_type, OpData* data) {\n  bool has_bias = node->inputs->size == 3;\n  TF_LITE_ENSURE(context, has_bias || node->inputs->size == 2);\n  TF_LITE_ENSURE_EQ(context, node->outputs->size, 1);\n  int unused_output_height, unused_output_width;\n  data->padding = ComputePaddingHeightWidth(\n      params->stride_height, params->stride_width, 1, 1, height, width,\n      filter_height, filter_width, params->padding, &unused_output_height,\n      &unused_output_width);\n  if (data_type != kTfLiteFloat32) {\n    const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n    TF_LITE_ENSURE(context, input != nullptr);\n    const TfLiteTensor* filter = GetInput(context, node, kFilterTensor);\n    TF_LITE_ENSURE(context, filter != nullptr);\n    const TfLiteTensor* bias =\n        GetOptionalInputTensor(context, node, kBiasTensor);\n    TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n    TF_LITE_ENSURE(context, output != nullptr);\n    int num_channels = filter->dims->data[kDepthwiseConvQuantizedDimension];\n    return tflite::PopulateConvolutionQuantizationParams(\n        context, input, filter, bias, output, params->activation,\n        &data->output_multiplier, &data->output_shift,\n        &data->output_activation_min, &data->output_activation_max,\n        data->per_channel_output_multiplier,\n        reinterpret_cast<int*>(data->per_channel_output_shift), num_channels);\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static int generate(struct crypto_rng *tfm, const u8 *src, unsigned int slen,\n\t\t    u8 *dst, unsigned int dlen)\n{\n\treturn crypto_old_rng_alg(tfm)->rng_make_random(tfm, dst, dlen);\n}", "target": 1}
{"code": "sg_poll(struct file *filp, poll_table * wait)\n{\n\tunsigned int res = 0;\n\tSg_device *sdp;\n\tSg_fd *sfp;\n\tSg_request *srp;\n\tint count = 0;\n\tunsigned long iflags;\n\tsfp = filp->private_data;\n\tif (!sfp)\n\t\treturn POLLERR;\n\tsdp = sfp->parentdp;\n\tif (!sdp)\n\t\treturn POLLERR;\n\tpoll_wait(filp, &sfp->read_wait, wait);\n\tread_lock_irqsave(&sfp->rq_list_lock, iflags);\n\tlist_for_each_entry(srp, &sfp->rq_list, entry) {\n\t\tif ((0 == res) && (1 == srp->done) && (!srp->sg_io_owned))\n\t\t\tres = POLLIN | POLLRDNORM;\n\t\t++count;\n\t}\n\tread_unlock_irqrestore(&sfp->rq_list_lock, iflags);\n\tif (atomic_read(&sdp->detaching))\n\t\tres |= POLLHUP;\n\telse if (!sfp->cmd_q) {\n\t\tif (0 == count)\n\t\t\tres |= POLLOUT | POLLWRNORM;\n\t} else if (count < SG_MAX_QUEUE)\n\t\tres |= POLLOUT | POLLWRNORM;\n\tSCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp,\n\t\t\t\t      \"sg_poll: res=0x%x\\n\", (int) res));\n\treturn res;\n}", "target": 0}
{"code": "static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)\n{\n\tioapic->rtc_status.pending_eoi = 0;\n\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPUS);\n}", "target": 1}
{"code": "static int unload_module(void)\n{\n\tast_cli_unregister_multiple(cli_identify, ARRAY_LEN(cli_identify));\n\tast_sip_unregister_cli_formatter(cli_formatter);\n\tast_sip_unregister_endpoint_formatter(&endpoint_identify_formatter);\n\tast_sip_unregister_endpoint_identifier(&header_identifier);\n\tast_sip_unregister_endpoint_identifier(&request_identifier);\n\tast_sip_unregister_endpoint_identifier(&ip_identifier);\n\tast_sip_unregister_endpoint_identifier(&transport_identifier);\n\treturn 0;\n}", "target": 1}
{"code": "init_connection_options(MYSQL *mysql)\n{\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n  if (opt_use_ssl)\n  {\n    mysql_ssl_set(mysql, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n                  opt_ssl_capath, opt_ssl_cipher);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRL, opt_ssl_crl);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);\n  }\n  mysql_options(mysql, MYSQL_OPT_SSL_VERIFY_SERVER_CERT,\n                (char*) &opt_ssl_verify_server_cert);\n#endif\n  if (opt_protocol)\n    mysql_options(mysql, MYSQL_OPT_PROTOCOL, (char*) &opt_protocol);\n#ifdef HAVE_SMEM\n  if (shared_memory_base_name)\n    mysql_options(mysql, MYSQL_SHARED_MEMORY_BASE_NAME, shared_memory_base_name);\n#endif\n}", "target": 1}
{"code": "sysServices_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_time_ticks(varbind, oid, clock_seconds() * 100);\n}", "target": 1}
{"code": "static void __route4_delete_filter(struct route4_filter *f)\n{\n\ttcf_exts_destroy(&f->exts);\n\ttcf_exts_put_net(&f->exts);\n\tkfree(f);\n}", "target": 0}
{"code": "dotraplinkage void notrace do_int3(struct pt_regs *regs, long error_code)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (unlikely(atomic_read(&modifying_ftrace_code)) &&\n\t    ftrace_int3_handler(regs))\n\t\treturn;\n#endif\n\tif (poke_int3_handler(regs))\n\t\treturn;\n\tist_enter(regs);\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(), \"entry code didn't wake RCU\");\n#ifdef CONFIG_KGDB_LOW_LEVEL_TRAP\n\tif (kgdb_ll_trap(DIE_INT3, \"int3\", regs, error_code, X86_TRAP_BP,\n\t\t\t\tSIGTRAP) == NOTIFY_STOP)\n\t\tgoto exit;\n#endif \n#ifdef CONFIG_KPROBES\n\tif (kprobe_int3_handler(regs))\n\t\tgoto exit;\n#endif\n\tif (notify_die(DIE_INT3, \"int3\", regs, error_code, X86_TRAP_BP,\n\t\t\tSIGTRAP) == NOTIFY_STOP)\n\t\tgoto exit;\n\tdebug_stack_usage_inc();\n\tcond_local_irq_enable(regs);\n\tdo_trap(X86_TRAP_BP, SIGTRAP, \"int3\", regs, error_code, NULL);\n\tcond_local_irq_disable(regs);\n\tdebug_stack_usage_dec();\nexit:\n\tist_exit(regs);\n}", "target": 1}
{"code": "test_custom_handler(void **state)\n{\n    (void) state;\n    TSS2_RC_HANDLER old = Tss2_RC_SetHandler(1, \"cstm\", custom_err_handler);\n    assert_null(old);\n    unsigned i;\n    for (i = 1; i < 4; i++) {\n        TSS2_RC rc = TSS2_RC_LAYER(1) | i;\n        char buf[256];\n        snprintf(buf, sizeof(buf), \"cstm:error %u\", i);\n        const char *e = Tss2_RC_Decode(rc);\n        assert_string_equal(e, buf);\n    }\n    TSS2_RC rc = TSS2_RC_LAYER(1) | 42;\n    const char *e = Tss2_RC_Decode(rc);\n    assert_string_equal(e, \"cstm:0x2A\");\n    old = Tss2_RC_SetHandler(1, \"cstm\", NULL);\n    assert_ptr_equal(old, custom_err_handler);\n    e = Tss2_RC_Decode(rc);\n    assert_string_equal(e, \"1:0x2A\");\n}", "target": 1}
{"code": "GF_Err pssh_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ProtectionSystemHeaderBox *ptr = (GF_ProtectionSystemHeaderBox *)s;\n\tgf_bs_read_data(bs, (char *) ptr->SystemID, 16);\n\tISOM_DECREASE_SIZE(ptr, 16);\n\tif (ptr->version > 0) {\n\t\tptr->KID_count = gf_bs_read_u32(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tif (ptr->KID_count) {\n\t\t\tu32 i;\n\t\t\tif (ptr->size / sizeof(bin128) < ptr->KID_count)\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\tptr->KIDs = gf_malloc(ptr->KID_count*sizeof(bin128));\n\t\t\tif (!ptr->KIDs)\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\tfor (i=0; i<ptr->KID_count; i++) {\n\t\t\t\tgf_bs_read_data(bs, (char *) ptr->KIDs[i], 16);\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\t\t}\n\t\t}\n\t}\n\tptr->private_data_size = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tif (ptr->private_data_size) {\n\t\tif (ptr->size < ptr->private_data_size)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tptr->private_data = gf_malloc(sizeof(char)*ptr->private_data_size);\n\t\tif (!ptr->private_data)\n\t\t\treturn GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, (char *) ptr->private_data, ptr->private_data_size);\n\t\tISOM_DECREASE_SIZE(ptr, ptr->private_data_size);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "void recovery_delete_character(void)\n{\n    if (!recovery_started) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");\n        layoutHome();\n        return;\n    }\n    if(strlen(mnemonic) > 0)\n    {\n        mnemonic[strlen(mnemonic) - 1] = '\\0';\n    }\n    next_character();\n}", "target": 0}
{"code": "void read_pcm_samples_internal(thread_context* tctx, int x0, int y0, int log2CbSize,\n                               int cIdx, bitreader& br)\n{\n  const seq_parameter_set& sps = tctx->img->get_sps();\n  int nPcmBits;\n  int bitDepth;\n  int w = 1<<log2CbSize;\n  int h = 1<<log2CbSize;\n  if (cIdx>0) {\n    w /= sps.SubWidthC;\n    h /= sps.SubHeightC;\n    x0 /= sps.SubWidthC;\n    y0 /= sps.SubHeightC;\n    nPcmBits = sps.pcm_sample_bit_depth_chroma;\n    bitDepth = sps.BitDepth_C;\n  }\n  else {\n    nPcmBits = sps.pcm_sample_bit_depth_luma;\n    bitDepth = sps.BitDepth_Y;\n  }\n  pixel_t* ptr;\n  int stride;\n  ptr    = tctx->img->get_image_plane_at_pos_NEW<pixel_t>(cIdx,x0,y0);\n  stride = tctx->img->get_image_stride(cIdx);\n  int shift = bitDepth - nPcmBits;\n  if (shift < 0) {\n    shift=0;\n  }\n  for (int y=0;y<h;y++)\n    for (int x=0;x<w;x++)\n      {\n        int value = get_bits(&br, nPcmBits);\n        ptr[y*stride+x] = value << shift;\n      }\n}", "target": 0}
{"code": "void *jas_malloc(size_t size)\n{\n\tvoid *result;\n\tJAS_DBGLOG(101, (\"jas_malloc called with %zu\\n\", size));\n\tresult = malloc(size);\n\tJAS_DBGLOG(100, (\"jas_malloc(%zu) -> %p\\n\", size, result));\n\treturn result;\n}", "target": 1}
{"code": "static __u8 *ch_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 17 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {\n\t\thid_info(hdev, \"fixing up Cherry Cymotion report descriptor\\n\");\n\t\trdesc[11] = rdesc[16] = 0xff;\n\t\trdesc[12] = rdesc[17] = 0x03;\n\t}\n\treturn rdesc;\n}", "target": 1}
{"code": "IW_IMPL(unsigned int) iw_get_ui16le(const iw_byte *b)\n{\n\treturn b[0] | (b[1]<<8);\n}", "target": 1}
{"code": "ptaReadStream(FILE  *fp)\n{\nchar       typestr[128];\nl_int32    i, n, ix, iy, type, version;\nl_float32  x, y;\nPTA       *pta;\n    PROCNAME(\"ptaReadStream\");\n    if (!fp)\n        return (PTA *)ERROR_PTR(\"stream not defined\", procName, NULL);\n    if (fscanf(fp, \"\\n Pta Version %d\\n\", &version) != 1)\n        return (PTA *)ERROR_PTR(\"not a pta file\", procName, NULL);\n    if (version != PTA_VERSION_NUMBER)\n        return (PTA *)ERROR_PTR(\"invalid pta version\", procName, NULL);\n    if (fscanf(fp, \" Number of pts = %d; format = %s\\n\", &n, typestr) != 2)\n        return (PTA *)ERROR_PTR(\"not a pta file\", procName, NULL);\n    if (!strcmp(typestr, \"float\"))\n        type = 0;\n    else  \n        type = 1;\n    if ((pta = ptaCreate(n)) == NULL)\n        return (PTA *)ERROR_PTR(\"pta not made\", procName, NULL);\n    for (i = 0; i < n; i++) {\n        if (type == 0) {  \n            if (fscanf(fp, \"   (%f, %f)\\n\", &x, &y) != 2) {\n                ptaDestroy(&pta);\n                return (PTA *)ERROR_PTR(\"error reading floats\", procName, NULL);\n            }\n            ptaAddPt(pta, x, y);\n        } else {   \n            if (fscanf(fp, \"   (%d, %d)\\n\", &ix, &iy) != 2) {\n                ptaDestroy(&pta);\n                return (PTA *)ERROR_PTR(\"error reading ints\", procName, NULL);\n            }\n            ptaAddPt(pta, ix, iy);\n        }\n    }\n    return pta;\n}", "target": 1}
{"code": "static void request_end(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct fuse_iqueue *fiq = &fc->iq;\n\tif (test_and_set_bit(FR_FINISHED, &req->flags))\n\t\tgoto put_request;\n\tspin_lock(&fiq->waitq.lock);\n\tlist_del_init(&req->intr_entry);\n\tspin_unlock(&fiq->waitq.lock);\n\tWARN_ON(test_bit(FR_PENDING, &req->flags));\n\tWARN_ON(test_bit(FR_SENT, &req->flags));\n\tif (test_bit(FR_BACKGROUND, &req->flags)) {\n\t\tspin_lock(&fc->bg_lock);\n\t\tclear_bit(FR_BACKGROUND, &req->flags);\n\t\tif (fc->num_background == fc->max_background) {\n\t\t\tfc->blocked = 0;\n\t\t\twake_up(&fc->blocked_waitq);\n\t\t} else if (!fc->blocked) {\n\t\t\tif (waitqueue_active(&fc->blocked_waitq))\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t}\n\t\tif (fc->num_background == fc->congestion_threshold && fc->sb) {\n\t\t\tclear_bdi_congested(fc->sb->s_bdi, BLK_RW_SYNC);\n\t\t\tclear_bdi_congested(fc->sb->s_bdi, BLK_RW_ASYNC);\n\t\t}\n\t\tfc->num_background--;\n\t\tfc->active_background--;\n\t\tflush_bg_queue(fc);\n\t\tspin_unlock(&fc->bg_lock);\n\t}\n\twake_up(&req->waitq);\n\tif (req->end)\n\t\treq->end(fc, req);\nput_request:\n\tfuse_put_request(fc, req);\n}", "target": 0}
{"code": "struct request *blk_mq_tag_to_rq(struct blk_mq_tags *tags, unsigned int tag)\n{\n\tstruct request *rq = tags->rqs[tag];\n\tstruct blk_flush_queue *fq = blk_get_flush_queue(rq->q, rq->mq_ctx);\n\tif (!is_flush_request(rq, fq, tag))\n\t\treturn rq;\n\treturn fq->flush_rq;\n}", "target": 1}
{"code": "GF_Err url_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\tif (ptr->size) {\n\t\tptr->location = (char*)gf_malloc((u32) ptr->size);\n\t\tif (! ptr->location) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->location, (u32)ptr->size);\n\t\tif (ptr->location[ptr->size-1]) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] url box location is not 0-terminated\\n\" ));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "void handle_get_plugin_schema_resp(nng_aio *aio, neu_resp_check_schema_t *resp)\n{\n    if (resp->exist) {\n        char * schema_path = NULL;\n        size_t len         = 0;\n        char * buf         = NULL;\n        if (0 > neu_asprintf(&schema_path, \"%s/schema/%s.json\", g_plugin_dir,\n                             resp->schema)) {\n            NEU_JSON_RESPONSE_ERROR(NEU_ERR_EINTERNAL, {\n                neu_http_response(aio, error_code.error, result_error);\n            });\n            return;\n        }\n        buf = file_string_read(&len, schema_path);\n        if (NULL == buf) {\n            free(schema_path);\n            if (0 > neu_asprintf(&schema_path, \"%s/custom/schema/%s.json\",\n                                 g_plugin_dir, resp->schema)) {\n                NEU_JSON_RESPONSE_ERROR(NEU_ERR_EINTERNAL, {\n                    neu_http_response(aio, error_code.error, result_error);\n                });\n                return;\n            }\n            buf = file_string_read(&len, schema_path);\n        }\n        if (NULL == buf) {\n            free(schema_path);\n            if (0 > neu_asprintf(&schema_path, \"%s/system/schema/%s.json\",\n                                 g_plugin_dir, resp->schema)) {\n                NEU_JSON_RESPONSE_ERROR(NEU_ERR_EINTERNAL, {\n                    neu_http_response(aio, error_code.error, result_error);\n                });\n                return;\n            }\n            buf = file_string_read(&len, schema_path);\n        }\n        if (NULL == buf) {\n            nlog_info(\"open %s error: %d\", schema_path, errno);\n            neu_http_not_found(aio, \"{\\\"status\\\": \\\"error\\\"}\");\n            free(schema_path);\n            return;\n        }\n        neu_http_ok(aio, buf);\n        free(buf);\n        free(schema_path);\n    } else {\n        NEU_JSON_RESPONSE_ERROR(NEU_ERR_PLUGIN_NOT_FOUND, {\n            neu_http_response(aio, error_code.error, result_error);\n        });\n    }\n}", "target": 0}
{"code": "static int count_leading_dotdots(const char *url, const char **out)\n{\n\tint result = 0;\n\twhile (1) {\n\t\tif (starts_with_dot_dot_slash(url)) {\n\t\t\tresult++;\n\t\t\turl += strlen(\"../\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (starts_with_dot_slash(url)) {\n\t\t\turl += strlen(\"./\");\n\t\t\tcontinue;\n\t\t}\n\t\t*out = url;\n\t\treturn result;\n\t}\n}", "target": 0}
{"code": "gsm_xsmp_client_disconnect (GsmXSMPClient *client)\n{\n        if (client->priv->watch_id > 0) {\n                g_source_remove (client->priv->watch_id);\n        }\n        if (client->priv->conn != NULL) {\n                SmsCleanUp (client->priv->conn);\n        }\n        if (client->priv->ice_connection != NULL) {\n                IceSetShutdownNegotiation (client->priv->ice_connection, FALSE);\n                IceCloseConnection (client->priv->ice_connection);\n        }\n        if (client->priv->protocol_timeout > 0) {\n                g_source_remove (client->priv->protocol_timeout);\n        }\n}", "target": 1}
{"code": "static int cg_open(const char *path, struct fuse_file_info *fi)\n{\n\tconst char *cgroup;\n\tchar *fpath = NULL, *path1, *path2, * cgdir = NULL, *controller;\n\tstruct cgfs_files *k = NULL;\n\tstruct file_info *file_info;\n\tstruct fuse_context *fc = fuse_get_context();\n\tint ret;\n\tif (!fc)\n\t\treturn -EIO;\n\tcontroller = pick_controller_from_path(fc, path);\n\tif (!controller)\n\t\treturn -EIO;\n\tcgroup = find_cgroup_in_path(path);\n\tif (!cgroup)\n\t\treturn -EINVAL;\n\tget_cgdir_and_path(cgroup, &cgdir, &fpath);\n\tif (!fpath) {\n\t\tpath1 = \"/\";\n\t\tpath2 = cgdir;\n\t} else {\n\t\tpath1 = cgdir;\n\t\tpath2 = fpath;\n\t}\n\tk = cgfs_get_key(controller, path1, path2);\n\tif (!k) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tfree_key(k);\n\tif (!caller_may_see_dir(fc->pid, controller, path1)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tif (!fc_may_access(fc, controller, path1, path2, fi->flags)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tfile_info = malloc(sizeof(*file_info));\n\tif (!file_info) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tfile_info->controller = must_copy_string(controller);\n\tfile_info->cgroup = must_copy_string(path1);\n\tfile_info->file = must_copy_string(path2);\n\tfile_info->type = LXC_TYPE_CGFILE;\n\tfile_info->buf = NULL;\n\tfile_info->buflen = 0;\n\tfi->fh = (unsigned long)file_info;\n\tret = 0;\nout:\n\tfree(cgdir);\n\treturn ret;\n}", "target": 0}
{"code": "mark_desktop_file_executable (CommonJob    *common,\n                              GCancellable *cancellable,\n                              GFile        *file,\n                              gboolean      interactive)\n{\n    GError *error;\n    guint32 current_perms, new_perms;\n    int response;\n    GFileInfo *info;\nretry:\n    error = NULL;\n    info = g_file_query_info (file,\n                              G_FILE_ATTRIBUTE_STANDARD_TYPE \",\"\n                              G_FILE_ATTRIBUTE_UNIX_MODE,\n                              G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                              common->cancellable,\n                              &error);\n    if (info == NULL)\n    {\n        if (interactive)\n        {\n            response = run_error (common,\n                                  g_strdup (_(\"Unable to mark launcher trusted (executable)\")),\n                                  error->message,\n                                  NULL,\n                                  FALSE,\n                                  CANCEL, RETRY,\n                                  NULL);\n        }\n        else\n        {\n            response = 0;\n        }\n        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n        {\n            abort_job (common);\n        }\n        else if (response == 1)\n        {\n            goto retry;\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n        goto out;\n    }\n    if (g_file_info_has_attribute (info, G_FILE_ATTRIBUTE_UNIX_MODE))\n    {\n        current_perms = g_file_info_get_attribute_uint32 (info, G_FILE_ATTRIBUTE_UNIX_MODE);\n        new_perms = current_perms | S_IXGRP | S_IXUSR | S_IXOTH;\n        if ((current_perms != new_perms) &&\n            !g_file_set_attribute_uint32 (file, G_FILE_ATTRIBUTE_UNIX_MODE,\n                                          new_perms, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                          common->cancellable, &error))\n        {\n            g_object_unref (info);\n            if (interactive)\n            {\n                response = run_error (common,\n                                      g_strdup (_(\"Unable to mark launcher trusted (executable)\")),\n                                      error->message,\n                                      NULL,\n                                      FALSE,\n                                      CANCEL, RETRY,\n                                      NULL);\n            }\n            else\n            {\n                response = 0;\n            }\n            if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n            {\n                abort_job (common);\n            }\n            else if (response == 1)\n            {\n                goto retry;\n            }\n            else\n            {\n                g_assert_not_reached ();\n            }\n            goto out;\n        }\n    }\n    g_object_unref (info);\nout:\n    ;\n}", "target": 0}
{"code": "static int is_symlink_path(pool *p, const char *path, size_t pathlen) {\n  int res, xerrno = 0;\n  struct stat st;\n  char *ptr;\n  if (pathlen == 0) {\n    return 0;\n  }\n  pr_fs_clear_cache();\n  res = pr_fsio_lstat(path, &st);\n  if (res < 0) {\n    xerrno = errno;\n    pr_log_pri(PR_LOG_WARNING, \"error: unable to check %s: %s\", path,\n      strerror(xerrno));\n    errno = xerrno;\n    return -1;\n  }\n  if (S_ISLNK(st.st_mode)) {\n    errno = EPERM;\n    return -1;\n  }\n  ptr = strrchr(path, '/');\n  if (ptr != NULL) {\n    char *new_path;\n    size_t new_pathlen;\n    pr_signals_handle();\n    new_pathlen = ptr - path;\n    if (new_pathlen == pathlen) {\n      return 0;\n    }\n    new_path = pstrndup(p, path, new_pathlen);\n    pr_log_debug(DEBUG10,\n      \"AllowChrootSymlink: path '%s' not a symlink, checking '%s'\", path,\n      new_path);\n    res = is_symlink_path(p, new_path, new_pathlen);\n    if (res < 0) {\n      return -1;\n    }\n  }\n  return 0;\n}", "target": 0}
{"code": "static int get_tp_trap(struct pt_regs *regs, unsigned int instr)\n{\n\tint reg = (instr >> 12) & 15;\n\tif (reg == 15)\n\t\treturn 1;\n\tregs->uregs[reg] = current_thread_info()->tp_value;\n\tregs->ARM_pc += 4;\n\treturn 0;\n}", "target": 1}
{"code": "  void initialize() override {\n    setMaxRequestHeadersKb(60);\n    setMaxRequestHeadersCount(100);\n    envoy::config::route::v3::RetryPolicy retry_policy;\n    auto pass_through = config_helper_.createVirtualHost(\"pass.through.internal.redirect\");\n    config_helper_.addVirtualHost(pass_through);\n    auto handle = config_helper_.createVirtualHost(\"handle.internal.redirect\");\n    handle.mutable_routes(0)->set_name(\"redirect\");\n    handle.mutable_routes(0)->mutable_route()->mutable_internal_redirect_policy();\n    config_helper_.addVirtualHost(handle);\n    auto handle_max_3_hop =\n        config_helper_.createVirtualHost(\"handle.internal.redirect.max.three.hop\");\n    handle_max_3_hop.mutable_routes(0)->set_name(\"max_three_hop\");\n    handle_max_3_hop.mutable_routes(0)->mutable_route()->mutable_internal_redirect_policy();\n    handle_max_3_hop.mutable_routes(0)\n        ->mutable_route()\n        ->mutable_internal_redirect_policy()\n        ->mutable_max_internal_redirects()\n        ->set_value(3);\n    config_helper_.addVirtualHost(handle_max_3_hop);\n    auto handle_by_direct_response = config_helper_.createVirtualHost(\"handle.direct.response\");\n    handle_by_direct_response.mutable_routes(0)->set_name(\"direct_response\");\n    handle_by_direct_response.mutable_routes(0)->mutable_direct_response()->set_status(204);\n    handle_by_direct_response.mutable_routes(0)\n        ->mutable_direct_response()\n        ->mutable_body()\n        ->set_inline_string(EMPTY_STRING);\n    config_helper_.addVirtualHost(handle_by_direct_response);\n    HttpProtocolIntegrationTest::initialize();\n  }", "target": 0}
{"code": "static int count_ah_combs(const struct xfrm_tmpl *t)\n{\n\tint i, sz = 0;\n\tfor (i = 0; ; i++) {\n\t\tconst struct xfrm_algo_desc *aalg = xfrm_aalg_get_byidx(i);\n\t\tif (!aalg)\n\t\t\tbreak;\n\t\tif (!aalg->pfkey_supported)\n\t\t\tcontinue;\n\t\tif (aalg_tmpl_set(t, aalg) && aalg->available)\n\t\t\tsz += sizeof(struct sadb_comb);\n\t}\n\treturn sz + sizeof(struct sadb_prop);\n}", "target": 0}
{"code": "authDigestNonceLinks(digest_nonce_h * nonce)\n{\n    if (!nonce)\n        return -1;\n    return nonce->references;\n}", "target": 1}
{"code": "    uint64_t Image::byteSwap(uint64_t value,bool bSwap) const\n    {\n        uint64_t result = 0;\n        byte* source_value = reinterpret_cast<byte *>(&value);\n        byte* destination_value = reinterpret_cast<byte *>(&result);\n        for (int i = 0; i < 8; i++)\n            destination_value[i] = source_value[8 - i - 1];\n        return bSwap ? result : value;\n    }", "target": 0}
{"code": "xfs_attr_calc_size(\n\tstruct xfs_inode \t*ip,\n\tint\t\t\tnamelen,\n\tint\t\t\tvaluelen,\n\tint\t\t\t*local)\n{\n\tstruct xfs_mount \t*mp = ip->i_mount;\n\tint\t\t\tsize;\n\tint\t\t\tnblks;\n\tsize = xfs_attr_leaf_newentsize(namelen, valuelen,\n\t\t\t\t\tmp->m_sb.sb_blocksize, local);\n\tnblks = XFS_DAENTER_SPACE_RES(mp, XFS_ATTR_FORK);\n\tif (*local) {\n\t\tif (size > (mp->m_sb.sb_blocksize >> 1)) {\n\t\t\tnblks *= 2;\n\t\t}\n\t} else {\n\t\tuint\tdblocks = XFS_B_TO_FSB(mp, valuelen);\n\t\tnblks += dblocks;\n\t\tnblks += XFS_NEXTENTADD_SPACE_RES(mp, dblocks, XFS_ATTR_FORK);\n\t}\n\treturn nblks;\n}", "target": 1}
{"code": "void PrepareTFPass::runOnOperation() {\n  MLIRContext *ctx = &getContext();\n  RewritePatternSet patterns(ctx);\n  RewritePatternSet phase_2_patterns(ctx);\n  auto func = getOperation();\n  if (failed(ValidateOp(func))) {\n    func.emitError() << \"tfl-prepare-tf pass failed.\";\n    signalPassFailure();\n    return;\n  }\n  if (failed(ConvertTf2XlaOps(func, ctx))) {\n    signalPassFailure();\n    return;\n  }\n  patterns.add<ConvertTFDilatedConvOp<TF::Conv2DOp>, FusedBatchNormV3Pat,\n               ConvertTFDilatedConvOp<TF::DepthwiseConv2dNativeOp>>(ctx);\n  patterns.add<RemoveIdentity>(ctx);\n  TFL::populateWithGenerated(patterns);\n  TF::ReshapeOp::getCanonicalizationPatterns(patterns, ctx);\n  (void)applyPatternsAndFoldGreedily(func, std::move(patterns));\n  if (failed(ConvertFakeQuantOps(func, ctx, use_fake_quant_num_bits_))) {\n    signalPassFailure();\n    return;\n  }\n  TFL::populateWithGenerated(phase_2_patterns);\n  if (unfold_batch_matmul_) {\n    TF::PopulateUnrollTfBatchMatMul(ctx, phase_2_patterns);\n  }\n  phase_2_patterns\n      .add<TF::ConvertTFEinsumOp, ConvertTFBroadcastTo, ConvertTFStridedSlice,\n           ConvertRfftToRfft2d, RemoveIdentity>(ctx);\n  phase_2_patterns.add<ConvertTFConv2D, ConvertTFDepthwiseConv2dNative>(\n      ctx, allow_bf16_and_f16_type_legalization_);\n  TF::ReshapeOp::getCanonicalizationPatterns(phase_2_patterns, ctx);\n  (void)applyPatternsAndFoldGreedily(func, std::move(phase_2_patterns));\n}", "target": 0}
{"code": "isofs_export_encode_fh(struct inode *inode,\n\t\t       __u32 *fh32,\n\t\t       int *max_len,\n\t\t       struct inode *parent)\n{\n\tstruct iso_inode_info * ei = ISOFS_I(inode);\n\tint len = *max_len;\n\tint type = 1;\n\t__u16 *fh16 = (__u16*)fh32;\n\tif (parent && (len < 5)) {\n\t\t*max_len = 5;\n\t\treturn 255;\n\t} else if (len < 3) {\n\t\t*max_len = 3;\n\t\treturn 255;\n\t}\n\tlen = 3;\n\tfh32[0] = ei->i_iget5_block;\n \tfh16[2] = (__u16)ei->i_iget5_offset;  \n\tfh16[3] = 0;  \n\tfh32[2] = inode->i_generation;\n\tif (parent) {\n\t\tstruct iso_inode_info *eparent;\n\t\teparent = ISOFS_I(parent);\n\t\tfh32[3] = eparent->i_iget5_block;\n\t\tfh16[3] = (__u16)eparent->i_iget5_offset;  \n\t\tfh32[4] = parent->i_generation;\n\t\tlen = 5;\n\t\ttype = 2;\n\t}\n\t*max_len = len;\n\treturn type;\n}", "target": 0}
{"code": "    bool ms_verify_authorizer(Connection *con, int peer_type, int protocol,\n                              bufferlist& authorizer, bufferlist& authorizer_reply,\n                              bool& isvalid, CryptoKey& session_key) override {\n      isvalid = true;\n      return true;\n    }", "target": 1}
{"code": "acpi_os_write_pci_configuration(struct acpi_pci_id * pci_id, u32 reg,\n\t\t\t\tu64 value, u32 width)\n{\n\tint result, size;\n\tswitch (width) {\n\tcase 8:\n\t\tsize = 1;\n\t\tbreak;\n\tcase 16:\n\t\tsize = 2;\n\t\tbreak;\n\tcase 32:\n\t\tsize = 4;\n\t\tbreak;\n\tdefault:\n\t\treturn AE_ERROR;\n\t}\n\tresult = raw_pci_write(pci_id->segment, pci_id->bus,\n\t\t\t\tPCI_DEVFN(pci_id->device, pci_id->function),\n\t\t\t\treg, size, value);\n\treturn (result ? AE_ERROR : AE_OK);\n}", "target": 0}
{"code": "set_default_colour_sequences(void)\n{\n    fg_bg_sequences[COL_SEQ_FG].start = ztrdup(TC_COL_FG_START);\n    fg_bg_sequences[COL_SEQ_FG].end = ztrdup(TC_COL_FG_END);\n    fg_bg_sequences[COL_SEQ_FG].def = ztrdup(TC_COL_FG_DEFAULT);\n    fg_bg_sequences[COL_SEQ_BG].start = ztrdup(TC_COL_BG_START);\n    fg_bg_sequences[COL_SEQ_BG].end = ztrdup(TC_COL_BG_END);\n    fg_bg_sequences[COL_SEQ_BG].def = ztrdup(TC_COL_BG_DEFAULT);\n}", "target": 0}
{"code": "static void chase_port(struct edgeport_port *port, unsigned long timeout,\n\t\t\t\t\t\t\t\tint flush)\n{\n\tint baud_rate;\n\tstruct tty_struct *tty = tty_port_tty_get(&port->port->port);\n\tstruct usb_serial *serial = port->port->serial;\n\twait_queue_t wait;\n\tunsigned long flags;\n\tif (!tty)\n\t\treturn;\n\tif (!timeout)\n\t\ttimeout = (HZ * EDGE_CLOSING_WAIT)/100;\n\tspin_lock_irqsave(&port->ep_lock, flags);\n\tinit_waitqueue_entry(&wait, current);\n\tadd_wait_queue(&tty->write_wait, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (kfifo_len(&port->write_fifo) == 0\n\t\t|| timeout == 0 || signal_pending(current)\n\t\t|| serial->disconnected)\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&port->ep_lock, flags);\n\t\ttimeout = schedule_timeout(timeout);\n\t\tspin_lock_irqsave(&port->ep_lock, flags);\n\t}\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&tty->write_wait, &wait);\n\tif (flush)\n\t\tkfifo_reset_out(&port->write_fifo);\n\tspin_unlock_irqrestore(&port->ep_lock, flags);\n\ttty_kref_put(tty);\n\ttimeout += jiffies;\n\twhile ((long)(jiffies - timeout) < 0 && !signal_pending(current)\n\t\t\t\t\t\t&& !serial->disconnected) {\n\t\tif (!tx_active(port))\n\t\t\tbreak;\n\t\tmsleep(10);\n\t}\n\tif (serial->disconnected)\n\t\treturn;\n\tbaud_rate = port->baud_rate;\n\tif (baud_rate == 0)\n\t\tbaud_rate = 50;\n\tmsleep(max(1, DIV_ROUND_UP(10000, baud_rate)));\n}", "target": 0}
{"code": "int nfc_llcp_data_received(struct nfc_dev *dev, struct sk_buff *skb)\n{\n\tstruct nfc_llcp_local *local;\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tkfree_skb(skb);\n\t\treturn -ENODEV;\n\t}\n\t__nfc_llcp_recv(local, skb);\n\tnfc_llcp_local_put(local);\n\treturn 0;\n}", "target": 0}
{"code": "void TestSocketLineReader::initTestCase()\n{\n    m_server = new Server(this);\n    QVERIFY2(m_server->listen(QHostAddress::LocalHost, 8694), \"Failed to create local tcp server\");\n    m_timer.setInterval(4000);\n    m_timer.setSingleShot(true);\n    connect(&m_timer, &QTimer::timeout, &m_loop, &QEventLoop::quit);\n    m_conn = new QSslSocket(this);\n    m_conn->connectToHost(QHostAddress::LocalHost, 8694);\n    connect(m_conn, &QAbstractSocket::connected, &m_loop, &QEventLoop::quit);\n    m_timer.start();\n    m_loop.exec();\n    QVERIFY2(m_conn->isOpen(), \"Could not connect to local tcp server\");\n}", "target": 1}
{"code": "static BOOL ntlm_av_pair_check(NTLM_AV_PAIR* pAvPair, size_t cbAvPair)\n{\n\tif (!pAvPair || cbAvPair < sizeof(NTLM_AV_PAIR))\n\t\treturn FALSE;\n\treturn cbAvPair >= ntlm_av_pair_get_next_offset(pAvPair);\n}", "target": 1}
{"code": "ext2_xattr_put_super(struct super_block *sb)\n{\n}", "target": 1}
{"code": "    void operator = (const IniSection &s)\n\t{\n\t    if (&s == this)\n\t    {\n\t\treturn;\n\t    } \n\t    IniBase::operator = (s);\n\t    ip = s.ip;\n\t    end_comment = s.end_comment; rewrite_by = s.rewrite_by;\n\t    container = s.container;\n\t    reindex ();\n\t}", "target": 1}
{"code": "sctp_chunk_length_valid(struct sctp_chunk *chunk,\n\t\t\t   __u16 required_length)\n{\n\t__u16 chunk_length = ntohs(chunk->chunk_hdr->length);\n\tif (unlikely(chunk->pdiscard))\n\t\treturn 0;\n\tif (unlikely(chunk_length < required_length))\n\t\treturn 0;\n\treturn 1;\n}", "target": 0}
{"code": "void UpdateDownloader::CleanLeftovers()\n{\n    std::wstring tmpdir;\n    if ( !Settings::ReadConfigValue(\"UpdateTempDir\", tmpdir) )\n        return;\n    try\n    {\n        if (tmpdir.find(GetUniqueTempDirectoryPrefix()) != 0)\n        {\n            Settings::DeleteConfigValue(\"UpdateTempDir\");\n            return;\n        }\n    }\n    catch (Win32Exception&) \n    {\n        return;\n    }\n    tmpdir.append(1, '\\0'); \n    SHFILEOPSTRUCT fos = {0};\n    fos.wFunc = FO_DELETE;\n    fos.pFrom = tmpdir.c_str();\n    fos.fFlags = FOF_NO_UI | \n                 FOF_SILENT |\n                 FOF_NOCONFIRMATION |\n                 FOF_NOERRORUI;\n    if ( SHFileOperation(&fos) == 0 )\n    {\n        Settings::DeleteConfigValue(\"UpdateTempDir\");\n    }\n}", "target": 0}
{"code": "static const tls12_hash_info *tls12_get_hash_info(unsigned char hash_alg)\n\t{\n\tif (hash_alg == 0)\n\t\treturn NULL;\n\tif (hash_alg > sizeof(tls12_md_info)/sizeof(tls12_md_info[0]))\n\t\treturn NULL;\n\treturn tls12_md_info + hash_alg - 1;\n\t}", "target": 0}
{"code": "static BOOL update_read_bitmap_data(rdpUpdate* update, wStream* s, BITMAP_DATA* bitmapData)\n{\n\tWINPR_UNUSED(update);\n\tif (Stream_GetRemainingLength(s) < 18)\n\t\treturn FALSE;\n\tStream_Read_UINT16(s, bitmapData->destLeft);\n\tStream_Read_UINT16(s, bitmapData->destTop);\n\tStream_Read_UINT16(s, bitmapData->destRight);\n\tStream_Read_UINT16(s, bitmapData->destBottom);\n\tStream_Read_UINT16(s, bitmapData->width);\n\tStream_Read_UINT16(s, bitmapData->height);\n\tStream_Read_UINT16(s, bitmapData->bitsPerPixel);\n\tStream_Read_UINT16(s, bitmapData->flags);\n\tStream_Read_UINT16(s, bitmapData->bitmapLength);\n\tif (bitmapData->flags & BITMAP_COMPRESSION)\n\t{\n\t\tif (!(bitmapData->flags & NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\treturn FALSE;\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompFirstRowSize); \n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompMainBodySize); \n\t\t\tStream_Read_UINT16(s, bitmapData->cbScanWidth);     \n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbUncompressedSize); \n\t\t\tbitmapData->bitmapLength = bitmapData->cbCompMainBodySize;\n\t\t}\n\t\tbitmapData->compressed = TRUE;\n\t}\n\telse\n\t\tbitmapData->compressed = FALSE;\n\tif (Stream_GetRemainingLength(s) < bitmapData->bitmapLength)\n\t\treturn FALSE;\n\tif (bitmapData->bitmapLength > 0)\n\t{\n\t\tbitmapData->bitmapDataStream = malloc(bitmapData->bitmapLength);\n\t\tif (!bitmapData->bitmapDataStream)\n\t\t\treturn FALSE;\n\t\tmemcpy(bitmapData->bitmapDataStream, Stream_Pointer(s), bitmapData->bitmapLength);\n\t\tStream_Seek(s, bitmapData->bitmapLength);\n\t}\n\treturn TRUE;\n}", "target": 0}
{"code": "static int nr_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t      struct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;\n\tsize_t copied;\n\tstruct sk_buff *skb;\n\tint er;\n\tlock_sock(sk);\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\trelease_sock(sk);\n\t\treturn -ENOTCONN;\n\t}\n\tif ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL) {\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\tskb_reset_transport_header(skb);\n\tcopied     = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\ter = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (er < 0) {\n\t\tskb_free_datagram(sk, skb);\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\tif (sax != NULL) {\n\t\tmemset(sax, 0, sizeof(*sax));\n\t\tsax->sax25_family = AF_NETROM;\n\t\tskb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,\n\t\t\t      AX25_ADDR_LEN);\n\t}\n\tmsg->msg_namelen = sizeof(*sax);\n\tskb_free_datagram(sk, skb);\n\trelease_sock(sk);\n\treturn copied;\n}", "target": 0}
{"code": "jiffies_to_compat_timeval(unsigned long jiffies, struct compat_timeval *value)\n{\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tlong rem;\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &rem);\n\tvalue->tv_usec = rem / NSEC_PER_USEC;\n}", "target": 1}
{"code": "static pyc_object *get_set_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (set size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic (buffer, n);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_SET;\n\treturn ret;\n}", "target": 1}
{"code": "static inline size_t GetPSDRowSize(Image *image)\n{\n  if (image->depth == 1)\n    return((image->columns+7)/8);\n  else\n    return(image->columns*GetPSDPacketSize(image));\n}", "target": 1}
{"code": "void uwbd_stop(struct uwb_rc *rc)\n{\n\tkthread_stop(rc->uwbd.task);\n\tuwbd_flush(rc);\n}", "target": 1}
{"code": "static u32 crc32sum(u32 crc, u8 * RESTRICT buf, size_t size) {\n    while (size--) crc = crc32Table[(crc ^ *(buf++)) & 0xff] ^ (crc >> 8);\n    return crc;\n}", "target": 1}
{"code": "static std::string GetBaseFilename(const std::string &filepath) {\n  auto idx = filepath.find_last_of(\"/\\\\\");\n  if (idx != std::string::npos)\n    return filepath.substr(idx + 1);\n  return filepath;\n}", "target": 1}
{"code": "Status ArrayFromMemory(int dim_size, npy_intp* dims, void* data, DataType dtype,\n                       std::function<void()> destructor, PyObject** result) {\n  if (dtype == DT_STRING || dtype == DT_RESOURCE) {\n    return errors::FailedPrecondition(\n        \"Cannot convert string or resource Tensors.\");\n  }\n  int type_num = -1;\n  Status s =\n      TF_DataType_to_PyArray_TYPE(static_cast<TF_DataType>(dtype), &type_num);\n  if (!s.ok()) {\n    return s;\n  }\n  if (dim_size > NPY_MAXDIMS) {\n    return errors::InvalidArgument(\n        \"Cannot convert tensor with \", dim_size,\n        \" dimensions to NumPy array. NumPy arrays can have at most \",\n        NPY_MAXDIMS, \" dimensions\");\n  }\n  auto* np_array = reinterpret_cast<PyArrayObject*>(\n      PyArray_SimpleNewFromData(dim_size, dims, type_num, data));\n  if (np_array == nullptr) {\n    string shape_str = absl::StrJoin(\n        absl::Span<npy_intp>{dims, static_cast<size_t>(dim_size)}, \", \");\n    if (PyErr_Occurred()) {\n      string exception_str = PyExceptionFetch();\n      PyErr_Clear();\n      return errors::InvalidArgument(\n          \"Failed to create numpy array from tensor of shape [\", shape_str,\n          \"]. Numpy error: \", exception_str);\n    }\n    return errors::Internal(\n        \"Failed to create numpy array from tensor of shape [\", shape_str, \"]\");\n  }\n  PyArray_CLEARFLAGS(np_array, NPY_ARRAY_OWNDATA);\n  if (PyType_Ready(&TensorReleaserType) == -1) {\n    return errors::Unknown(\"Python type initialization failed.\");\n  }\n  auto* releaser = reinterpret_cast<TensorReleaser*>(\n      TensorReleaserType.tp_alloc(&TensorReleaserType, 0));\n  releaser->destructor = new std::function<void()>(std::move(destructor));\n  if (PyArray_SetBaseObject(np_array, reinterpret_cast<PyObject*>(releaser)) ==\n      -1) {\n    Py_DECREF(releaser);\n    return errors::Unknown(\"Python array refused to use memory.\");\n  }\n  *result = reinterpret_cast<PyObject*>(np_array);\n  return OkStatus();\n}", "target": 0}
{"code": "R_API int r_socket_ready(RSocket *s, int secs, int usecs) {\n#if __UNIX__\n\tint msecs = (usecs / 1000);\n\tstruct pollfd fds[1];\n\tfds[0].fd = s->fd;\n\tfds[0].events = POLLIN | POLLPRI;\n\tfds[0].revents = POLLNVAL | POLLHUP | POLLERR;\n\treturn poll ((struct pollfd *)&fds, 1, msecs);\n#elif __WINDOWS__\n\tfd_set rfds;\n\tstruct timeval tv;\n\tif (s->fd == R_INVALID_SOCKET) {\n\t\treturn -1;\n\t}\n\tFD_ZERO (&rfds);\n\tFD_SET (s->fd, &rfds);\n\ttv.tv_sec = secs;\n\ttv.tv_usec = usecs;\n\treturn select (s->fd + 1, &rfds, NULL, NULL, &tv);\n#else\n\treturn true; \n#endif\n}", "target": 1}
{"code": "PJ_DEF(void) pj_scan_get( pj_scanner *scanner,\n\t\t\t  const pj_cis_t *spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n    pj_assert(pj_cis_match(spec,0)==0);\n    if (!pj_cis_match(spec, *s)) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    do {\n\t++s;\n    } while (pj_cis_match(spec, *s));\n    pj_strset3(out, scanner->curptr, s);\n    scanner->curptr = s;\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);    \n    }\n}", "target": 1}
{"code": "int safe_mount(const char *src, const char *dest, const char *fstype,\n\t\tunsigned long flags, const void *data, const char *rootfs)\n{\n\tint srcfd = -1, destfd, ret, saved_errno;\n\tchar srcbuf[50], destbuf[50]; \n\tconst char *mntsrc = src;\n\tif (!rootfs)\n\t\trootfs = \"\";\n\tif (flags & MS_BIND && src && src[0] != '/') {\n\t\tINFO(\"this is a relative bind mount\");\n\t\tsrcfd = open_without_symlink(src, NULL);\n\t\tif (srcfd < 0)\n\t\t\treturn srcfd;\n\t\tret = snprintf(srcbuf, 50, \"/proc/self/fd/%d\", srcfd);\n\t\tif (ret < 0 || ret > 50) {\n\t\t\tclose(srcfd);\n\t\t\tERROR(\"Out of memory\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmntsrc = srcbuf;\n\t}\n\tdestfd = open_without_symlink(dest, rootfs);\n\tif (destfd < 0) {\n\t\tif (srcfd != -1)\n\t\t\tclose(srcfd);\n\t\treturn destfd;\n\t}\n\tret = snprintf(destbuf, 50, \"/proc/self/fd/%d\", destfd);\n\tif (ret < 0 || ret > 50) {\n\t\tif (srcfd != -1)\n\t\t\tclose(srcfd);\n\t\tclose(destfd);\n\t\tERROR(\"Out of memory\");\n\t\treturn -EINVAL;\n\t}\n\tret = mount(mntsrc, destbuf, fstype, flags, data);\n\tsaved_errno = errno;\n\tif (srcfd != -1)\n\t\tclose(srcfd);\n\tclose(destfd);\n\tif (ret < 0) {\n\t\terrno = saved_errno;\n\t\tSYSERROR(\"Failed to mount %s onto %s\", src, dest);\n\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void HierarchicalBitmapRequester::PrepareForDecoding(void)\n{\n#if ACCUSOFT_CODE\n  UBYTE i;\n  BuildCommon();\n  if (m_ppDecodingMCU == NULL) {\n    m_ppDecodingMCU = (struct Line **)m_pEnviron->AllocMem(sizeof(struct Line *) * m_ucCount*8);\n    memset(m_ppDecodingMCU,0,sizeof(struct Line *) * m_ucCount * 8);\n  }\n  if (m_ppUpsampler == NULL) {\n    m_ppUpsampler = (class UpsamplerBase **)m_pEnviron->AllocMem(sizeof(class UpsamplerBase *) * m_ucCount);\n    memset(m_ppUpsampler,0,sizeof(class Upsampler *) * m_ucCount);\n    for(i = 0;i < m_ucCount;i++) {\n      class Component *comp = m_pFrame->ComponentOf(i);\n      UBYTE sx = comp->SubXOf();\n      UBYTE sy = comp->SubYOf();\n      if (m_pLargestScale) {\n        class Frame *frame = m_pLargestScale->FrameOf();\n        while(frame) {\n          if (frame->ComponentOf(i)->SubXOf() != sx || frame->ComponentOf(i)->SubYOf() != sy)\n            JPG_THROW(MALFORMED_STREAM,\"HierarchicalBitmapRequester::PrepareForDecoding\",\n                      \"component subsampling is inconsistent across hierarchical levels\");\n          frame = frame->NextOf();\n        }\n      }\n      if (sx > 1 || sy > 1) {\n        m_ppUpsampler[i] = UpsamplerBase::CreateUpsampler(m_pEnviron,sx,sy,\n                                                          m_ulPixelWidth,m_ulPixelHeight,\n                                                          m_pFrame->TablesOf()->isChromaCentered());\n        m_bSubsampling   = true;\n      }\n    }\n  }\n  if (m_pLargestScale)\n    m_pLargestScale->PrepareForDecoding();\n#endif\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& in0 = ctx->input(0);\n    const Tensor& in1 = ctx->input(1);\n    OP_REQUIRES(\n        ctx, in0.NumElements() == in1.NumElements(),\n        errors::InvalidArgument(\"The two arguments to a cwise op must have \"\n                                \"same number of elements, got \",\n                                in0.NumElements(), \" and \", in1.NumElements()));\n    auto in0_flat = in0.flat<Tin>();\n    auto in1_flat = in1.flat<Tin>();\n    const Device& eigen_device = ctx->eigen_device<Device>();\n    Tensor* out = nullptr;\n    if (std::is_same<Tin, Tout>::value) {\n      OP_REQUIRES_OK(ctx, ctx->forward_input_or_allocate_output(\n                              {0, 1}, 0, in0.shape(), &out));\n    } else {\n      OP_REQUIRES_OK(ctx, ctx->allocate_output(0, in0.shape(), &out));\n    }\n    auto out_flat = out->flat<Tout>();\n    functor::SimpleBinaryFunctor<Device, Functor>()(eigen_device, out_flat,\n                                                    in0_flat, in1_flat);\n  }", "target": 0}
{"code": "int wc_SignatureGenerateHash(\n    enum wc_HashType hash_type, enum wc_SignatureType sig_type,\n    const byte* hash_data, word32 hash_len,\n    byte* sig, word32 *sig_len,\n    const void* key, word32 key_len, WC_RNG* rng)\n{\n    return wc_SignatureGenerateHash_ex(hash_type, sig_type, hash_data, hash_len,\n        sig, sig_len, key, key_len, rng, 1);\n}", "target": 0}
{"code": "AuthenticationFeature::AuthenticationFeature(application_features::ApplicationServer& server)\n    : ApplicationFeature(server, \"Authentication\"),\n      _userManager(nullptr),\n      _authCache(nullptr),\n      _authenticationUnixSockets(true),\n      _authenticationSystemOnly(true),\n      _localAuthentication(true),\n      _active(true),\n      _authenticationTimeout(0.0) {\n  setOptional(false);\n  startsAfter<application_features::BasicFeaturePhaseServer>();\n#ifdef USE_ENTERPRISE\n  startsAfter<LdapFeature>();\n#endif\n}", "target": 1}
{"code": "void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) {\n  global_State *g = G(L);\n  lua_assert(isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o));\n  if (keepinvariant(g)) {  \n    reallymarkobject(g, v);  \n    if (isold(o)) {\n      lua_assert(!isold(v));  \n      setage(v, G_OLD0);  \n    }\n  }\n  else {  \n    lua_assert(issweepphase(g));\n    makewhite(g, o);  \n  }\n}", "target": 1}
{"code": "static int manager_setup_time_change(Manager *m) {\n        int r;\n        struct itimerspec its = {\n                .it_value.tv_sec = TIME_T_MAX,\n        };\n        assert(m);\n        assert_cc(sizeof(time_t) == sizeof(TIME_T_MAX));\n        if (m->test_run)\n                return 0;\n        m->time_change_fd = timerfd_create(CLOCK_REALTIME, TFD_NONBLOCK|TFD_CLOEXEC);\n        if (m->time_change_fd < 0)\n                return log_error_errno(errno, \"Failed to create timerfd: %m\");\n        if (timerfd_settime(m->time_change_fd, TFD_TIMER_ABSTIME|TFD_TIMER_CANCEL_ON_SET, &its, NULL) < 0) {\n                log_debug_errno(errno, \"Failed to set up TFD_TIMER_CANCEL_ON_SET, ignoring: %m\");\n                m->time_change_fd = safe_close(m->time_change_fd);\n                return 0;\n        }\n        r = sd_event_add_io(m->event, &m->time_change_event_source, m->time_change_fd, EPOLLIN, manager_dispatch_time_change_fd, m);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to create time change event source: %m\");\n        log_debug(\"Set up TFD_TIMER_CANCEL_ON_SET timerfd.\");\n        return 0;\n}", "target": 0}
{"code": "gopherHTMLFooter(StoreEntry * e)\n{\n    storeAppendPrintf(e, \"<HR noshade size=\\\"1px\\\">\\n\");\n    storeAppendPrintf(e, \"<ADDRESS>\\n\");\n    storeAppendPrintf(e, \"Generated %s by %s (%s)\\n\",\n                      Time::FormatRfc1123(squid_curtime),\n                      getMyHostname(),\n                      visible_appname_string);\n    storeAppendPrintf(e, \"</ADDRESS></BODY></HTML>\\n\");\n}", "target": 1}
{"code": "static void php_array_replace_recursive(PointerSet &seen, bool check,\n                                        Array &arr1, const Array& arr2) {\n  if (arr1.get() == arr2.get()) {\n    return;\n  }\n  if (check && !seen.insert((void*)arr1.get()).second) {\n    raise_warning(\"array_replace_recursive(): recursion detected\");\n    return;\n  }\n  for (ArrayIter iter(arr2); iter; ++iter) {\n    Variant key = iter.first();\n    const Variant& value = iter.secondRef();\n    if (arr1.exists(key, true) && value.isArray()) {\n      Variant &v = arr1.lvalAt(key, AccessFlags::Key);\n      if (v.isArray()) {\n        Array subarr1 = v.toArray();\n        const ArrNR& arr_value = value.toArrNR();\n        php_array_replace_recursive(seen, couldRecur(v, subarr1.get()),\n                                    subarr1, arr_value);\n        v = subarr1;\n      } else {\n        arr1.set(key, value, true);\n      }\n    } else {\n      arr1.setWithRef(key, value, true);\n    }\n  }\n  if (check) {\n    seen.erase((void*)arr1.get());\n  }\n}", "target": 0}
{"code": "matchDomainName(const char *h, const char *d, MatchDomainNameFlags flags)\n{\n    int dl;\n    int hl;\n    const bool hostIncludesSubdomains = (*h == '.');\n    while ('.' == *h)\n        ++h;\n    hl = strlen(h);\n    if (hl == 0)\n        return -1;\n    dl = strlen(d);\n    if (dl == 0)\n        return 1;\n    while (xtolower(h[--hl]) == xtolower(d[--dl])) {\n        if (hl == 0 && dl == 0) {\n            return 0;\n        }\n        if (0 == hl) {\n            if (1 == dl && '.' == d[0])\n                return 0;\n            else\n                return -1;\n        }\n        if (0 == dl) {\n            if ('.' == d[0]) {\n                if (flags & mdnRejectSubsubDomains) {\n                    while(--hl >= 0 && h[hl] != '.');\n                    if (hl < 0) {\n                        return hostIncludesSubdomains ? 1 : 0;\n                    } else\n                        return 1; \n                } else\n                    return 0;\n            } else\n                return 1;\n        }\n    }\n    if ((flags & mdnHonorWildcards) && h[hl] == '*' && h[hl + 1] == '.')\n        return 0;\n    if ('.' == d[dl])\n        return 1;\n    if ('.' == h[hl])\n        return -1;\n    return (xtolower(h[hl]) - xtolower(d[dl]));\n}", "target": 0}
{"code": "static ram_addr_t find_ram_offset(struct uc_struct *uc, ram_addr_t size)\n{\n    RAMBlock *block, *next_block;\n    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;\n    assert(size != 0); \n    if (QLIST_EMPTY(&uc->ram_list.blocks)) {\n        return 0;\n    }\n    RAMBLOCK_FOREACH(block) {\n        ram_addr_t candidate, next = RAM_ADDR_MAX;\n        candidate = block->offset + block->max_length;\n        candidate = ROUND_UP(candidate, BITS_PER_LONG << TARGET_PAGE_BITS);\n        RAMBLOCK_FOREACH(next_block) {\n            if (next_block->offset >= candidate) {\n                next = MIN(next, next_block->offset);\n            }\n        }\n        if (next - candidate >= size && next - candidate < mingap) {\n            offset = candidate;\n            mingap = next - candidate;\n        }\n    }\n    if (offset == RAM_ADDR_MAX) {\n        fprintf(stderr, \"Failed to find gap of requested size: %\" PRIu64 \"\\n\",\n                (uint64_t)size);\n        abort();\n    }\n    return offset;\n}", "target": 1}
{"code": "static int EscChar(const char *src, char *dst, int dstlen, const char *specchars, char escchar)\n{\n   const char *p;\n   char *q, *end = dst+dstlen-1;\n   for (p = src, q = dst; *p && q < end; ) {\n      if (strchr(specchars, *p)) {\n         *q++ = escchar;\n         if (q < end)\n            *q++ = *p++;\n      } else\n         *q++ = *p++;\n   }\n   *q = '\\0';\n   if (*p != 0)\n      return -1;\n   return q-dst;\n}", "target": 1}
{"code": "static int ion_handle_put(struct ion_handle *handle)\n{\n\tstruct ion_client *client = handle->client;\n\tint ret;\n\tmutex_lock(&client->lock);\n\tret = kref_put(&handle->ref, ion_handle_destroy);\n\tmutex_unlock(&client->lock);\n\treturn ret;\n}", "target": 1}
{"code": "void zrandmemberCommand(client *c) {\n    long l;\n    int withscores = 0;\n    robj *zset;\n    listpackEntry ele;\n    if (c->argc >= 3) {\n        if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL) != C_OK) return;\n        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withscores\"))) {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        } else if (c->argc == 4) {\n            withscores = 1;\n            if (l < -LONG_MAX/2 || l > LONG_MAX/2) {\n                addReplyError(c,\"value is out of range\");\n                return;\n            }\n        }\n        zrandmemberWithCountCommand(c, l, withscores);\n        return;\n    }\n    if ((zset = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL ||\n        checkType(c,zset,OBJ_ZSET)) {\n        return;\n    }\n    zsetTypeRandomElement(zset, zsetLength(zset), &ele,NULL);\n    zsetReplyFromListpackEntry(c,&ele);\n}", "target": 0}
{"code": "int LibRaw::parseLeicaLensName(unsigned len)\n{\n#define plln ilm.Lens\n  if (!len)\n  {\n    strcpy(plln, \"N/A\");\n    return 0;\n  }\n  stmread(plln, len, ifp);\n  if ((plln[0] == ' ') || !strncasecmp(plln, \"not \", 4) ||\n      !strncmp(plln, \"---\", 3) || !strncmp(plln, \"***\", 3))\n  {\n    strcpy(plln, \"N/A\");\n    return 0;\n  }\n  else\n    return 1;\n#undef plln\n}", "target": 0}
{"code": "void dev_load(struct net *net, const char *name)\n{\n\tstruct net_device *dev;\n\trcu_read_lock();\n\tdev = dev_get_by_name_rcu(net, name);\n\trcu_read_unlock();\n\tif (!dev && capable(CAP_NET_ADMIN))\n\t\trequest_module(\"%s\", name);\n}", "target": 1}
{"code": "isoclns_print(netdissect_options *ndo,\n              const uint8_t *p, u_int length, u_int caplen)\n{\n\tif (caplen <= 1) { \n\t\tND_PRINT((ndo, \"|OSI\"));\n\t\treturn;\n\t}\n\tif (ndo->ndo_eflag)\n\t\tND_PRINT((ndo, \"OSI NLPID %s (0x%02x): \", tok2str(nlpid_values, \"Unknown\", *p), *p));\n\tswitch (*p) {\n\tcase NLPID_CLNP:\n\t\tif (!clnp_print(ndo, p, length))\n\t\t\tprint_unknown_data(ndo, p, \"\\n\\t\", caplen);\n\t\tbreak;\n\tcase NLPID_ESIS:\n\t\tesis_print(ndo, p, length);\n\t\treturn;\n\tcase NLPID_ISIS:\n\t\tif (!isis_print(ndo, p, length))\n\t\t\tprint_unknown_data(ndo, p, \"\\n\\t\", caplen);\n\t\tbreak;\n\tcase NLPID_NULLNS:\n\t\tND_PRINT((ndo, \"%slength: %u\", ndo->ndo_eflag ? \"\" : \", \", length));\n\t\tbreak;\n\tcase NLPID_Q933:\n\t\tq933_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\tcase NLPID_IP:\n\t\tip_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\tcase NLPID_IP6:\n\t\tip6_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\tcase NLPID_PPP:\n\t\tppp_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\tdefault:\n\t\tif (!ndo->ndo_eflag)\n\t\t\tND_PRINT((ndo, \"OSI NLPID 0x%02x unknown\", *p));\n\t\tND_PRINT((ndo, \"%slength: %u\", ndo->ndo_eflag ? \"\" : \", \", length));\n\t\tif (caplen > 1)\n\t\t\tprint_unknown_data(ndo, p, \"\\n\\t\", caplen);\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "int ecall_restore(const char *input, uint64_t input_len, char **output,\n                  uint64_t *output_len) {\n  if (!asylo::primitives::TrustedPrimitives::IsOutsideEnclave(input,\n                                                              input_len) ||\n      !asylo::primitives::TrustedPrimitives::IsOutsideEnclave(\n          output_len, sizeof(uint64_t)) ||\n      !asylo::primitives::TrustedPrimitives::IsOutsideEnclave(output,\n                                                              *output_len)) {\n    asylo::primitives::TrustedPrimitives::BestEffortAbort(\n        \"ecall_restore: input/output found to not be in untrusted memory.\");\n  }\n  int result = 0;\n  size_t tmp_output_len;\n  try {\n    result = asylo::Restore(input, static_cast<size_t>(input_len), output,\n                            &tmp_output_len);\n  } catch (...) {\n    LOG(FATAL) << \"Uncaught exception in enclave\";\n  }\n  if (output_len) {\n    *output_len = static_cast<uint64_t>(tmp_output_len);\n  }\n  return result;\n}", "target": 0}
{"code": "void __sock_recv_timestamp(struct msghdr *msg, struct sock *sk,\n\tstruct sk_buff *skb)\n{\n\tint need_software_tstamp = sock_flag(sk, SOCK_RCVTSTAMP);\n\tstruct scm_timestamping tss;\n\tint empty = 1;\n\tstruct skb_shared_hwtstamps *shhwtstamps =\n\t\tskb_hwtstamps(skb);\n\tif (need_software_tstamp && skb->tstamp == 0)\n\t\t__net_timestamp(skb);\n\tif (need_software_tstamp) {\n\t\tif (!sock_flag(sk, SOCK_RCVTSTAMPNS)) {\n\t\t\tstruct timeval tv;\n\t\t\tskb_get_timestamp(skb, &tv);\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMP,\n\t\t\t\t sizeof(tv), &tv);\n\t\t} else {\n\t\t\tstruct timespec ts;\n\t\t\tskb_get_timestampns(skb, &ts);\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPNS,\n\t\t\t\t sizeof(ts), &ts);\n\t\t}\n\t}\n\tmemset(&tss, 0, sizeof(tss));\n\tif ((sk->sk_tsflags & SOF_TIMESTAMPING_SOFTWARE) &&\n\t    ktime_to_timespec_cond(skb->tstamp, tss.ts + 0))\n\t\tempty = 0;\n\tif (shhwtstamps &&\n\t    (sk->sk_tsflags & SOF_TIMESTAMPING_RAW_HARDWARE) &&\n\t    ktime_to_timespec_cond(shhwtstamps->hwtstamp, tss.ts + 2))\n\t\tempty = 0;\n\tif (!empty) {\n\t\tput_cmsg(msg, SOL_SOCKET,\n\t\t\t SCM_TIMESTAMPING, sizeof(tss), &tss);\n\t\tif (skb_is_err_queue(skb) && skb->len &&\n\t\t    SKB_EXT_ERR(skb)->opt_stats)\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPING_OPT_STATS,\n\t\t\t\t skb->len, skb->data);\n\t}\n}", "target": 0}
{"code": "static int count_paired_channels(uint8_t (*layout_map)[3], int tags, int pos,\n                                 int *current)\n{\n    int num_pos_channels = 0;\n    int first_cpe        = 0;\n    int sce_parity       = 0;\n    int i;\n    for (i = *current; i < tags; i++) {\n        if (layout_map[i][2] != pos)\n            break;\n        if (layout_map[i][0] == TYPE_CPE) {\n            if (sce_parity) {\n                if (pos == AAC_CHANNEL_FRONT && !first_cpe) {\n                    sce_parity = 0;\n                } else {\n                    return -1;\n                }\n            }\n            num_pos_channels += 2;\n            first_cpe         = 1;\n        } else {\n            num_pos_channels++;\n            sce_parity ^= 1;\n        }\n    }\n    if (sce_parity &&\n        ((pos == AAC_CHANNEL_FRONT && first_cpe) || pos == AAC_CHANNEL_SIDE))\n        return -1;\n    *current = i;\n    return num_pos_channels;\n}", "target": 0}
{"code": "sysUpTime_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_time_ticks(varbind, oid, clock_seconds() * 100);\n}", "target": 1}
{"code": "bool inode_capable(const struct inode *inode, int cap)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\treturn ns_capable(ns, cap) && kuid_has_mapping(ns, inode->i_uid);\n}", "target": 1}
{"code": "void CNB::SetupLSO(virtio_net_hdr_basic *VirtioHeader, PVOID IpHeader, ULONG EthPayloadLength) const\n{\n    PopulateIPLength(reinterpret_cast<IPv4Header*>(IpHeader), static_cast<USHORT>(EthPayloadLength));\n    tTcpIpPacketParsingResult packetReview;\n    packetReview = ParaNdis_CheckSumVerifyFlat(reinterpret_cast<IPv4Header*>(IpHeader), EthPayloadLength,\n                                               pcrIpChecksum | pcrFixIPChecksum | pcrTcpChecksum | pcrFixPHChecksum,\n                                               FALSE,\n                                               __FUNCTION__);\n    if (packetReview.xxpCheckSum == ppresPCSOK || packetReview.fixedXxpCS)\n    {\n        auto IpHeaderOffset = m_Context->Offload.ipHeaderOffset;\n        auto VHeader = static_cast<virtio_net_hdr_basic*>(VirtioHeader);\n        auto PriorityHdrLen = (m_ParentNBL->TCI() != 0) ? ETH_PRIORITY_HEADER_SIZE : 0;\n        VHeader->flags = VIRTIO_NET_HDR_F_NEEDS_CSUM;\n        VHeader->gso_type = packetReview.ipStatus == ppresIPV4 ? VIRTIO_NET_HDR_GSO_TCPV4 : VIRTIO_NET_HDR_GSO_TCPV6;\n        VHeader->hdr_len = (USHORT)(packetReview.XxpIpHeaderSize + IpHeaderOffset + PriorityHdrLen);\n        VHeader->gso_size = (USHORT)m_ParentNBL->MSS();\n        VHeader->csum_start = (USHORT)(m_ParentNBL->TCPHeaderOffset() + PriorityHdrLen);\n        VHeader->csum_offset = TCP_CHECKSUM_OFFSET;\n    }\n}", "target": 0}
{"code": "static bool check_underflow(const struct ipt_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\tif (!unconditional(&e->ip))\n\t\treturn false;\n\tt = ipt_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}", "target": 1}
{"code": "bool IsBlacklistedArg(const base::CommandLine::CharType* arg) {\n#if defined(OS_WIN)\n  const auto converted = base::WideToUTF8(arg);\n  const char* a = converted.c_str();\n#else\n  const char* a = arg;\n#endif\n  static const char* prefixes[] = {\"--\", \"-\", \"/\"};\n  int prefix_length = 0;\n  for (auto& prefix : prefixes) {\n    if (base::StartsWith(a, prefix, base::CompareCase::SENSITIVE)) {\n      prefix_length = strlen(prefix);\n      break;\n    }\n  }\n  if (prefix_length > 0) {\n    a += prefix_length;\n    std::string switch_name(a, strcspn(a, \"=\"));\n    auto* iter = std::lower_bound(std::begin(kBlacklist), std::end(kBlacklist),\n                                  switch_name);\n    if (iter != std::end(kBlacklist) && switch_name == *iter) {\n      return true;\n    }\n  }\n  return false;\n}", "target": 1}
{"code": "static inline void write_desc(struct intel_engine_execlists *execlists, u64 desc, u32 port)\n{\n\tif (execlists->ctrl_reg) {\n\t\twritel(lower_32_bits(desc), execlists->submit_reg + port * 2);\n\t\twritel(upper_32_bits(desc), execlists->submit_reg + port * 2 + 1);\n\t} else {\n\t\twritel(upper_32_bits(desc), execlists->submit_reg);\n\t\twritel(lower_32_bits(desc), execlists->submit_reg);\n\t}\n}", "target": 0}
{"code": "  static void launch(OpKernelContext* context, bool cudnn_use_autotune,\n                     const Tensor& input, const Tensor& filter,\n                     const std::array<int64, 3>& dilations,\n                     const std::array<int64, 3>& strides, const Padding padding,\n                     TensorFormat data_format, Tensor* output) {\n    OP_REQUIRES(context, data_format == FORMAT_NHWC,\n                errors::InvalidArgument(\"CPU implementation of Conv3D \"\n                                        \"currently only supports the NHWC \"\n                                        \"tensor format.\"));\n    OP_REQUIRES(context,\n                dilations[0] == 1 && dilations[1] == 1 && dilations[2] == 1,\n                errors::InvalidArgument(\"CPU implementation of Conv3D \"\n                                        \"currently only supports dilated rates \"\n                                        \"of 1.\"));\n    OP_REQUIRES(context, filter.dim_size(3) == input.dim_size(input.dims() - 1),\n                errors::InvalidArgument(\n                    \"Number of channels in filter (\", filter.dim_size(3),\n                    \") must match last dimension of input (\",\n                    input.dim_size(input.dims() - 1), \")\"));\n    functor::CuboidConvolution<CPUDevice, T>()(\n        context->eigen_device<CPUDevice>(), output->tensor<T, 5>(),\n        input.tensor<T, 5>(), filter.tensor<T, 5>(), strides[2], strides[1],\n        strides[0], BrainPadding2EigenPadding(padding));\n  }", "target": 0}
{"code": "static int irda_sendmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\tstruct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct irda_sock *self;\n\tstruct sk_buff *skb;\n\tint err = -EPIPE;\n\tIRDA_DEBUG(4, \"%s(), len=%zd\\n\", __func__, len);\n\tif (msg->msg_flags & ~(MSG_DONTWAIT | MSG_EOR | MSG_CMSG_COMPAT |\n\t\t\t       MSG_NOSIGNAL))\n\t\treturn -EINVAL;\n\tif (sk->sk_shutdown & SEND_SHUTDOWN)\n\t\tgoto out_err;\n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\treturn -ENOTCONN;\n\tself = irda_sk(sk);\n\tif (wait_event_interruptible(*(sk->sk_sleep),\n\t    (self->tx_flow != FLOW_STOP  ||  sk->sk_state != TCP_ESTABLISHED)))\n\t\treturn -ERESTARTSYS;\n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\treturn -ENOTCONN;\n\tif (len > self->max_data_size) {\n\t\tIRDA_DEBUG(2, \"%s(), Chopping frame from %zd to %d bytes!\\n\",\n\t\t\t   __func__, len, self->max_data_size);\n\t\tlen = self->max_data_size;\n\t}\n\tskb = sock_alloc_send_skb(sk, len + self->max_header_size + 16,\n\t\t\t\t  msg->msg_flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\tgoto out_err;\n\tskb_reserve(skb, self->max_header_size + 16);\n\tskb_reset_transport_header(skb);\n\tskb_put(skb, len);\n\terr = memcpy_fromiovec(skb_transport_header(skb), msg->msg_iov, len);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\tgoto out_err;\n\t}\n\terr = irttp_data_request(self->tsap, skb);\n\tif (err) {\n\t\tIRDA_DEBUG(0, \"%s(), err=%d\\n\", __func__, err);\n\t\tgoto out_err;\n\t}\n\treturn len;\n out_err:\n\treturn sk_stream_error(sk, msg->msg_flags, err);\n}", "target": 0}
{"code": "static int ima_lsm_rule_init(struct ima_measure_rule_entry *entry,\n\t\t\t     char *args, int lsm_rule, int audit_type)\n{\n\tint result;\n\tif (entry->lsm[lsm_rule].rule)\n\t\treturn -EINVAL;\n\tentry->lsm[lsm_rule].type = audit_type;\n\tresult = security_filter_rule_init(entry->lsm[lsm_rule].type,\n\t\t\t\t\t   Audit_equal, args,\n\t\t\t\t\t   &entry->lsm[lsm_rule].rule);\n\tif (!entry->lsm[lsm_rule].rule)\n\t\treturn -EINVAL;\n\treturn result;\n}", "target": 0}
{"code": "static void xmt_remove_link_for_descriptor(GF_XMTParser* parser, GF_Descriptor* desc) {\n\tu32 i=0;\n\tXMT_ODLink *l, *to_del=NULL;\n\twhile ((l = (XMT_ODLink*)gf_list_enum(parser->od_links, &i)) ) {\n\t\tif (l->od && l->od == (GF_ObjectDescriptor*)desc) {\n\t\t\tl->od = NULL;\n\t\t\tto_del = l;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (to_del) {\n\t\ti=0;\n\t\tGF_Descriptor* subdesc;\n\t\twhile ((subdesc = gf_list_enum(((GF_ObjectDescriptor*)desc)->ESDescriptors, &i))) {\n\t\t\tif (subdesc) xmt_remove_link_for_descriptor(parser, subdesc);\n\t\t}\n\t\tgf_list_del_item(parser->od_links, to_del);\n\t\tif (to_del->desc_name) gf_free(to_del->desc_name);\n\t\tgf_list_del(to_del->mf_urls);\n\t\tgf_free(to_del);\n\t}\n\tXMT_ESDLink *esdl, *esdl_del=NULL;\n\ti=0;\n\twhile ((esdl = (XMT_ESDLink *)gf_list_enum(parser->esd_links, &i))) {\n\t\tif (esdl->esd && esdl->esd == (GF_ESD*)desc) {\n\t\t\tesdl->esd = NULL;\n\t\t\tesdl_del = esdl;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (esdl_del) {\n\t\tgf_list_del_item(parser->esd_links, esdl_del);\n\t\tif (esdl_del->desc_name) gf_free(esdl_del->desc_name);\n\t\tgf_free(esdl_del);\n\t}\n}", "target": 0}
{"code": "static const char *tls_dns_name(const GENERAL_NAME * gn)\n{\n\tconst char *dnsname;\n\tif (ASN1_STRING_type(gn->d.ia5) != V_ASN1_IA5STRING) {\n\t\tg_warning(\"Invalid ASN1 value type in subjectAltName\");\n\t\treturn NULL;\n\t}\n\tdnsname = (char *) ASN1_STRING_data(gn->d.ia5);\n\tif (has_internal_nul(dnsname, ASN1_STRING_length(gn->d.ia5))) {\n\t\tg_warning(\"Internal NUL in subjectAltName\");\n\t\treturn NULL;\n\t}\n\treturn dnsname;\n}", "target": 0}
{"code": "static UINT urb_isoch_transfer(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback, wStream* s,\n                               UINT32 RequestField, UINT32 MessageId, IUDEVMAN* udevman,\n                               int transferDir)\n{\n\tUINT32 EndpointAddress;\n\tUINT32 PipeHandle, TransferFlags, StartFrame, NumberOfPackets;\n\tUINT32 ErrorCount, OutputBufferSize;\n\tBYTE* packetDescriptorData;\n\tconst BOOL noAck = (RequestField & 0x80000000U) != 0;\n\tconst UINT32 RequestId = RequestField & 0x7FFFFFFF;\n\tif (!pdev || !callback || !udevman)\n\t\treturn ERROR_INVALID_PARAMETER;\n\tif (Stream_GetRemainingLength(s) < 20)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT32(s, PipeHandle);\n\tEndpointAddress = (PipeHandle & 0x000000ff);\n\tStream_Read_UINT32(s, TransferFlags);   \n\tStream_Read_UINT32(s, StartFrame);      \n\tStream_Read_UINT32(s, NumberOfPackets); \n\tStream_Read_UINT32(s, ErrorCount);      \n\tif (Stream_GetRemainingLength(s) < NumberOfPackets * 12 + 4)\n\t\treturn ERROR_INVALID_DATA;\n\tpacketDescriptorData = Stream_Pointer(s);\n\tStream_Seek(s, NumberOfPackets * 12);\n\tStream_Read_UINT32(s, OutputBufferSize);\n\tif (transferDir == USBD_TRANSFER_DIRECTION_OUT)\n\t{\n\t\tif (!Stream_CheckAndLogRequiredLength(TAG, s, OutputBufferSize))\n\t\t\treturn ERROR_INVALID_DATA;\n\t}\n\treturn pdev->isoch_transfer(\n\t    pdev, callback, MessageId, RequestId, EndpointAddress, TransferFlags, StartFrame,\n\t    ErrorCount, noAck, packetDescriptorData, NumberOfPackets, OutputBufferSize,\n\t    (transferDir == USBD_TRANSFER_DIRECTION_OUT) ? Stream_Pointer(s) : NULL,\n\t    urb_isoch_transfer_cb, 2000);\n}", "target": 0}
{"code": "int SMIME_write_PKCS7(BIO *bio, PKCS7 *p7, BIO *data, int flags)\n{\n    STACK_OF(X509_ALGOR) *mdalgs;\n    int ctype_nid = OBJ_obj2nid(p7->type);\n    const PKCS7_CTX *ctx = ossl_pkcs7_get0_ctx(p7);\n    if (ctype_nid == NID_pkcs7_signed)\n        mdalgs = p7->d.sign->md_algs;\n    else\n        mdalgs = NULL;\n    flags ^= SMIME_OLDMIME;\n    return SMIME_write_ASN1_ex(bio, (ASN1_VALUE *)p7, data, flags, ctype_nid,\n                               NID_undef, mdalgs, ASN1_ITEM_rptr(PKCS7),\n                               ossl_pkcs7_ctx_get0_libctx(ctx),\n                               ossl_pkcs7_ctx_get0_propq(ctx));\n}", "target": 1}
{"code": "SecureSocket::secureAccept(int socket)\n{\n    createSSL();\n    SSL_set_fd(m_ssl->m_ssl, socket);\n    LOG((CLOG_DEBUG2 \"accepting secure socket\"));\n    int r = SSL_accept(m_ssl->m_ssl);\n    static int retry;\n    checkResult(r, retry);\n    if (isFatal()) {\n        LOG((CLOG_ERR \"failed to accept secure socket\"));\n        LOG((CLOG_INFO \"client connection may not be secure\"));\n        m_secureReady = false;\n        ARCH->sleep(1);\n        retry = 0;\n        return -1; \n    }\n    if (retry == 0) {\n        if (security_level_ == ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED) {\n            if (verify_cert_fingerprint(\n                        barrier::DataDirectories::trusted_clients_ssl_fingerprints_path())) {\n                LOG((CLOG_INFO \"accepted secure socket\"));\n                if (!ensure_peer_certificate()) {\n                    retry = 0;\n                    disconnect();\n                    return -1;\n                }\n            }\n            else {\n                LOG((CLOG_ERR \"failed to verify server certificate fingerprint\"));\n                retry = 0;\n                disconnect();\n                return -1; \n            }\n        }\n        m_secureReady = true;\n        LOG((CLOG_INFO \"accepted secure socket\"));\n        if (CLOG->getFilter() >= kDEBUG1) {\n            showSecureCipherInfo();\n        }\n        showSecureConnectInfo();\n        return 1;\n    }\n    if (retry > 0) {\n        LOG((CLOG_DEBUG2 \"retry accepting secure socket\"));\n        m_secureReady = false;\n        ARCH->sleep(s_retryDelay);\n        return 0;\n    }\n    LOG((CLOG_ERR \"unexpected state attempting to accept connection\"));\n    return -1;\n}", "target": 0}
{"code": "void AcceptRoutingHandler<Pipeline, R>::onRoutingData(\n    uint64_t connId,\n    typename RoutingDataHandler<R>::RoutingData& routingData) {\n  auto routingPipelineIter = routingPipelines_.find(connId);\n  if (routingPipelineIter == routingPipelines_.end()) {\n    VLOG(2) << \"Connection has already been closed, \"\n               \"or routed to a worker thread.\";\n    return;\n  }\n  auto routingPipeline = std::move(routingPipelineIter->second);\n  routingPipelines_.erase(routingPipelineIter);\n  auto socket = std::dynamic_pointer_cast<folly::AsyncSocket>(\n      routingPipeline->getTransport());\n  routingPipeline->transportInactive();\n  socket->detachEventBase();\n  uint64_t hash = std::hash<R>()(routingData.routingData);\n  auto acceptor = acceptors_[hash % acceptors_.size()];\n  acceptor->getEventBase()->runInEventBaseThread(\n      [ =, routingData = std::move(routingData) ]() mutable {\n        socket->attachEventBase(acceptor->getEventBase());\n        auto routingHandler =\n            routingPipeline->template getHandler<RoutingDataHandler<R>>();\n        DCHECK(routingHandler);\n        auto transportInfo = routingPipeline->getTransportInfo();\n        auto pipeline = childPipelineFactory_->newPipeline(\n            socket, routingData.routingData, routingHandler, transportInfo);\n        auto connection =\n            new typename ServerAcceptor<Pipeline>::ServerConnection(pipeline);\n        acceptor->addConnection(connection);\n        pipeline->transportActive();\n        pipeline->read(routingData.bufQueue);\n      });\n}", "target": 1}
{"code": "static const char *findvararg (CallInfo *ci, int n, StkId *pos) {\n  if (clLvalue(s2v(ci->func))->p->is_vararg) {\n    int nextra = ci->u.l.nextraargs;\n    if (n <= nextra) {\n      *pos = ci->func - nextra + (n - 1);\n      return \"(vararg)\";  \n    }\n  }\n  return NULL;  \n}", "target": 1}
{"code": "struct mb2_cache *mb2_cache_create(int bucket_bits)\n{\n\tstruct mb2_cache *cache;\n\tint bucket_count = 1 << bucket_bits;\n\tint i;\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn NULL;\n\tcache = kzalloc(sizeof(struct mb2_cache), GFP_KERNEL);\n\tif (!cache)\n\t\tgoto err_out;\n\tcache->c_bucket_bits = bucket_bits;\n\tINIT_LIST_HEAD(&cache->c_lru_list);\n\tspin_lock_init(&cache->c_lru_list_lock);\n\tcache->c_hash = kmalloc(bucket_count * sizeof(struct hlist_bl_head),\n\t\t\t\tGFP_KERNEL);\n\tif (!cache->c_hash) {\n\t\tkfree(cache);\n\t\tgoto err_out;\n\t}\n\tfor (i = 0; i < bucket_count; i++)\n\t\tINIT_HLIST_BL_HEAD(&cache->c_hash[i]);\n\tcache->c_shrink.count_objects = mb2_cache_count;\n\tcache->c_shrink.scan_objects = mb2_cache_scan;\n\tcache->c_shrink.seeks = DEFAULT_SEEKS;\n\tregister_shrinker(&cache->c_shrink);\n\treturn cache;\nerr_out:\n\tmodule_put(THIS_MODULE);\n\treturn NULL;\n}", "target": 0}
{"code": "static int adpt_close(struct inode *inode, struct file *file)\n{\n\tint minor;\n\tadpt_hba* pHba;\n\tminor = iminor(inode);\n\tif (minor >= hba_count) {\n\t\treturn -ENXIO;\n\t}\n\tmutex_lock(&adpt_configuration_lock);\n\tfor (pHba = hba_chain; pHba; pHba = pHba->next) {\n\t\tif (pHba->unit == minor) {\n\t\t\tbreak;\t\n\t\t}\n\t}\n\tmutex_unlock(&adpt_configuration_lock);\n\tif (pHba == NULL) {\n\t\treturn -ENXIO;\n\t}\n\tpHba->in_use = 0;\n\treturn 0;\n}", "target": 1}
{"code": "static int hns_roce_netdev_event(struct notifier_block *self,\n\t\t\t\t unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct hns_roce_ib_iboe *iboe = NULL;\n\tstruct hns_roce_dev *hr_dev = NULL;\n\tu8 port = 0;\n\tint ret = 0;\n\thr_dev = container_of(self, struct hns_roce_dev, iboe.nb);\n\tiboe = &hr_dev->iboe;\n\tfor (port = 0; port < hr_dev->caps.num_ports; port++) {\n\t\tif (dev == iboe->netdevs[port]) {\n\t\t\tret = handle_en_event(hr_dev, port, event);\n\t\t\tif (ret)\n\t\t\t\treturn NOTIFY_DONE;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn NOTIFY_DONE;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input_sizes = context->input(0);\n    const Tensor& filter = context->input(1);\n    const Tensor& out_backprop = context->input(2);\n    OP_REQUIRES(\n        context, out_backprop.dims() == 4,\n        errors::InvalidArgument(\"input_sizes must be 4-dimensional, got: \",\n                                out_backprop.dims()));\n    TensorShape input_shape;\n    OP_REQUIRES_OK(context,\n                   Conv2DBackpropComputeInputShape(input_sizes, filter.shape(),\n                                                   out_backprop.shape(),\n                                                   data_format_, &input_shape));\n    Tensor* in_backprop = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input_shape, &in_backprop));\n    if (input_shape.num_elements() == 0) {\n      return;\n    }\n    if (out_backprop.NumElements() == 0) {\n      functor::SetZeroFunctor<Device, T> set_zero;\n      set_zero(context->eigen_device<Device>(),\n               in_backprop->template flat<T>());\n      return;\n    }\n    const int stride_rows = GetTensorDim(strides_, data_format_, 'H');\n    const int stride_cols = GetTensorDim(strides_, data_format_, 'W');\n    const int dilation_rows = GetTensorDim(dilations_, data_format_, 'H');\n    const int dilation_cols = GetTensorDim(dilations_, data_format_, 'W');\n    VLOG(2) << \"Conv2DBackpropInput:\"\n            << \" input: \" << input_shape.DebugString()\n            << \" filter:\" << filter.shape().DebugString()\n            << \" out_backprop: \" << out_backprop.shape().DebugString()\n            << \" strides: [\" << stride_rows << \", \" << stride_cols << \"]\"\n            << \" dilations: [\" << dilation_rows << \", \" << dilation_cols << \"]\";\n    LaunchConv2DBackpropInputOp<Device, T> launch;\n    launch(context, use_cudnn_, cudnn_use_autotune_, out_backprop, filter,\n           dilation_rows, dilation_cols, stride_rows, stride_cols, padding_,\n           explicit_paddings_, in_backprop, data_format_);\n  }", "target": 0}
{"code": "static void __net_exit sctp_net_exit(struct net *net)\n{\n\tsctp_free_addr_wq(net);\n\tsctp_free_local_addr_list(net);\n\tinet_ctl_sock_destroy(net->sctp.ctl_sock);\n\tsctp_dbg_objcnt_exit(net);\n\tsctp_proc_exit(net);\n\tcleanup_sctp_mibs(net);\n\tsctp_sysctl_net_unregister(net);\n}", "target": 1}
{"code": "static int ghash_update(struct shash_desc *desc,\n\t\t\t const u8 *src, unsigned int srclen)\n{\n\tstruct ghash_desc_ctx *dctx = shash_desc_ctx(desc);\n\tstruct ghash_ctx *ctx = crypto_shash_ctx(desc->tfm);\n\tu8 *dst = dctx->buffer;\n\tif (!ctx->gf128)\n\t\treturn -ENOKEY;\n\tif (dctx->bytes) {\n\t\tint n = min(srclen, dctx->bytes);\n\t\tu8 *pos = dst + (GHASH_BLOCK_SIZE - dctx->bytes);\n\t\tdctx->bytes -= n;\n\t\tsrclen -= n;\n\t\twhile (n--)\n\t\t\t*pos++ ^= *src++;\n\t\tif (!dctx->bytes)\n\t\t\tgf128mul_4k_lle((be128 *)dst, ctx->gf128);\n\t}\n\twhile (srclen >= GHASH_BLOCK_SIZE) {\n\t\tcrypto_xor(dst, src, GHASH_BLOCK_SIZE);\n\t\tgf128mul_4k_lle((be128 *)dst, ctx->gf128);\n\t\tsrc += GHASH_BLOCK_SIZE;\n\t\tsrclen -= GHASH_BLOCK_SIZE;\n\t}\n\tif (srclen) {\n\t\tdctx->bytes = GHASH_BLOCK_SIZE - srclen;\n\t\twhile (srclen--)\n\t\t\t*dst++ ^= *src++;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int find_low_bit(unsigned int x)\n{\n\tint i;\n\tfor(i=0;i<=31;i++) {\n\t\tif(x&(1<<i)) return i;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "tvb_get_manuf_name(tvbuff_t *tvb, gint offset)\n{\n    return get_manuf_name(tvb_get_ptr(tvb, offset, 3));\n}", "target": 1}
{"code": "void LibRaw::lch_to_rgb(double (*image2)[3])\n{\n  int indx;\n  for (indx = 0; indx < height * width; indx++)\n  {\n    image[indx][0] = CLIP(image2[indx][0] / 3.0 - image2[indx][2] / 6.0 +\n                          image2[indx][1] / 3.464101615);\n    image[indx][1] = CLIP(image2[indx][0] / 3.0 - image2[indx][2] / 6.0 -\n                          image2[indx][1] / 3.464101615);\n    image[indx][2] = CLIP(image2[indx][0] / 3.0 + image2[indx][2] / 3.0);\n  }\n}", "target": 0}
{"code": "void TestJlCompress::extractDir_data()\n{\n    QTest::addColumn<QString>(\"zipName\");\n    QTest::addColumn<QStringList>(\"fileNames\");\n    QTest::newRow(\"simple\") << \"jlextdir.zip\" << (\n            QStringList() << \"test0.txt\" << \"testdir1/test1.txt\"\n            << \"testdir2/test2.txt\" << \"testdir2/subdir/test2sub.txt\");\n    QTest::newRow(\"separate dir\") << \"sepdir.zip\" << (\n            QStringList() << \"laj/\" << \"laj/lajfile.txt\");\n}", "target": 1}
{"code": "static int flakey_ioctl(struct dm_target *ti, unsigned int cmd, unsigned long arg)\n{\n\tstruct flakey_c *fc = ti->private;\n\treturn __blkdev_driver_ioctl(fc->dev->bdev, fc->dev->mode, cmd, arg);\n}", "target": 1}
{"code": "void Curl_detach_connnection(struct Curl_easy *data)\n{\n  struct connectdata *conn = data->conn;\n  if(conn)\n    Curl_llist_remove(&conn->easyq, &data->conn_queue, NULL);\n  data->conn = NULL;\n}", "target": 1}
{"code": "static void sas_resume_port(struct asd_sas_phy *phy)\n{\n\tstruct domain_device *dev;\n\tstruct asd_sas_port *port = phy->port;\n\tstruct sas_ha_struct *sas_ha = phy->ha;\n\tstruct sas_internal *si = to_sas_internal(sas_ha->core.shost->transportt);\n\tif (si->dft->lldd_port_formed)\n\t\tsi->dft->lldd_port_formed(phy);\n\tif (port->suspended)\n\t\tport->suspended = 0;\n\telse {\n\t\treturn;\n\t}\n\tlist_for_each_entry(dev, &port->dev_list, dev_list_node) {\n\t\tint i, rc;\n\t\trc = sas_notify_lldd_dev_found(dev);\n\t\tif (rc) {\n\t\t\tsas_unregister_dev(port, dev);\n\t\t\tsas_destruct_devices(port);\n\t\t\tcontinue;\n\t\t}\n\t\tif (dev->dev_type == SAS_EDGE_EXPANDER_DEVICE || dev->dev_type == SAS_FANOUT_EXPANDER_DEVICE) {\n\t\t\tdev->ex_dev.ex_change_count = -1;\n\t\t\tfor (i = 0; i < dev->ex_dev.num_phys; i++) {\n\t\t\t\tstruct ex_phy *phy = &dev->ex_dev.ex_phy[i];\n\t\t\t\tphy->phy_change_count = -1;\n\t\t\t}\n\t\t}\n\t}\n\tsas_discover_event(port, DISCE_RESUME);\n}", "target": 0}
{"code": "accept_ice_connection (GIOChannel           *source,\n                       GIOCondition          condition,\n                       GsmIceConnectionData *data)\n{\n        IceListenObj    listener;\n        IceConn         ice_conn;\n        IceAcceptStatus status;\n        GsmClient      *client;\n        GsmXsmpServer  *server;\n        listener = data->listener;\n        server = data->server;\n        g_debug (\"GsmXsmpServer: accept_ice_connection()\");\n        ice_conn = IceAcceptConnection (listener, &status);\n        if (status != IceAcceptSuccess) {\n                g_debug (\"GsmXsmpServer: IceAcceptConnection returned %d\", status);\n                return TRUE;\n        }\n        client = gsm_xsmp_client_new (ice_conn);\n        ice_conn->context = client;\n        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));\n        g_object_unref (client);\n        return TRUE;\n}", "target": 1}
{"code": "GF_Err gf_isom_set_extraction_slc(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex, const GF_SLConfig *slConfig)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_Err e;\n\tGF_SLConfig **slc;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex, &entry, NULL);\n\tif (e) return e;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tif (((GF_MPEGSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = & ((GF_MPEGSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tif (((GF_MPEGAudioSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = & ((GF_MPEGAudioSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tif (((GF_MPEGVisualSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = & ((GF_MPEGVisualSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\tif (*slc) {\n\t\tgf_odf_desc_del((GF_Descriptor *)*slc);\n\t\t*slc = NULL;\n\t}\n\tif (!slConfig) return GF_OK;\n\treturn gf_odf_desc_copy((GF_Descriptor *) slConfig, (GF_Descriptor **) slc);\n}", "target": 1}
{"code": "R_API char *r_cons_hud_line_string(const char *s) {\n\tif (!r_cons_is_interactive ()) {\n\t\tR_LOG_ERROR (\"Hud mode requires scr.interactive=true\");\n\t\treturn NULL;\n\t}\n\tchar *os, *track, *ret, *o = strdup (s);\n\tif (!o) {\n\t\treturn NULL;\n\t}\n\tr_str_replace_ch (o, '\\r', 0, true);\n\tr_str_replace_ch (o, '\\t', 0, true);\n\tr_str_ansi_strip (o);\n\tRList *fl = r_list_new ();\n\tint i;\n\tif (!fl) {\n\t\tfree (o);\n\t\treturn NULL;\n\t}\n\tfl->free = free;\n\tfor (os = o, i = 0; o[i]; i++) {\n\t\tif (o[i] == '\\n') {\n\t\t\to[i] = 0;\n\t\t\tif (*os && *os != '#') {\n\t\t\t\ttrack = strdup (os);\n\t\t\t\tif (!r_list_append (fl, track)) {\n\t\t\t\t\tfree (track);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tos = o + i + 1;\n\t\t}\n\t}\n\tret = r_cons_hud_line (fl, NULL);\n\tfree (o);\n\tr_list_free (fl);\n\treturn ret;\n}", "target": 0}
{"code": "void InferenceContext::PreInputInit(\n    const OpDef& op_def, const std::vector<const Tensor*>& input_tensors,\n    const std::vector<ShapeHandle>& input_tensors_as_shapes) {\n  const auto ret = full_type::SpecializeType(attrs_, op_def);\n  DCHECK(ret.status().ok()) << \"while instantiating types: \" << ret.status();\n  ret_types_ = ret.ValueOrDie();\n  input_tensors_ = input_tensors;\n  input_tensors_as_shapes_ = input_tensors_as_shapes;\n  construction_status_ =\n      NameRangesForNode(attrs_, op_def, &input_name_map_, &output_name_map_);\n  if (!construction_status_.ok()) return;\n  int num_outputs = 0;\n  for (const auto& e : output_name_map_) {\n    num_outputs = std::max(num_outputs, e.second.second);\n  }\n  outputs_.assign(num_outputs, nullptr);\n  output_handle_shapes_and_types_.resize(num_outputs);\n}", "target": 1}
{"code": "const char *enter_repo(const char *path, int strict)\n{\n\tstatic struct strbuf validated_path = STRBUF_INIT;\n\tstatic struct strbuf used_path = STRBUF_INIT;\n\tif (!path)\n\t\treturn NULL;\n\tif (!strict) {\n\t\tstatic const char *suffix[] = {\n\t\t\t\"/.git\", \"\", \".git/.git\", \".git\", NULL,\n\t\t};\n\t\tconst char *gitfile;\n\t\tint len = strlen(path);\n\t\tint i;\n\t\twhile ((1 < len) && (path[len-1] == '/'))\n\t\t\tlen--;\n\t\tif (PATH_MAX <= len)\n\t\t\treturn NULL;\n\t\tstrbuf_reset(&used_path);\n\t\tstrbuf_reset(&validated_path);\n\t\tstrbuf_add(&used_path, path, len);\n\t\tstrbuf_add(&validated_path, path, len);\n\t\tif (used_path.buf[0] == '~') {\n\t\t\tchar *newpath = interpolate_path(used_path.buf, 0);\n\t\t\tif (!newpath)\n\t\t\t\treturn NULL;\n\t\t\tstrbuf_attach(&used_path, newpath, strlen(newpath),\n\t\t\t\t      strlen(newpath));\n\t\t}\n\t\tfor (i = 0; suffix[i]; i++) {\n\t\t\tstruct stat st;\n\t\t\tsize_t baselen = used_path.len;\n\t\t\tstrbuf_addstr(&used_path, suffix[i]);\n\t\t\tif (!stat(used_path.buf, &st) &&\n\t\t\t    (S_ISREG(st.st_mode) ||\n\t\t\t    (S_ISDIR(st.st_mode) && is_git_directory(used_path.buf)))) {\n\t\t\t\tstrbuf_addstr(&validated_path, suffix[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrbuf_setlen(&used_path, baselen);\n\t\t}\n\t\tif (!suffix[i])\n\t\t\treturn NULL;\n\t\tgitfile = read_gitfile(used_path.buf);\n\t\tdie_upon_dubious_ownership(gitfile, NULL, used_path.buf);\n\t\tif (gitfile) {\n\t\t\tstrbuf_reset(&used_path);\n\t\t\tstrbuf_addstr(&used_path, gitfile);\n\t\t}\n\t\tif (chdir(used_path.buf))\n\t\t\treturn NULL;\n\t\tpath = validated_path.buf;\n\t}\n\telse {\n\t\tconst char *gitfile = read_gitfile(path);\n\t\tdie_upon_dubious_ownership(gitfile, NULL, path);\n\t\tif (gitfile)\n\t\t\tpath = gitfile;\n\t\tif (chdir(path))\n\t\t\treturn NULL;\n\t}\n\tif (is_git_directory(\".\")) {\n\t\tset_git_dir(\".\", 0);\n\t\tcheck_repository_format(NULL);\n\t\treturn path;\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "PJ_DEF(void) pj_scan_skip_line( pj_scanner *scanner )\n{\n    char *s = pj_memchr(scanner->curptr, '\\n', scanner->end - scanner->curptr);\n    if (!s) {\n\tscanner->curptr = scanner->end;\n    } else {\n\tscanner->curptr = scanner->start_line = s+1;\n\tscanner->line++;\n   }\n}", "target": 1}
{"code": "void securityWarningCommand(client *c) {\n    static time_t logged_time;\n    time_t now = time(NULL);\n    if (labs(now-logged_time) > 60) {\n        serverLog(LL_WARNING,\"Possible SECURITY ATTACK detected. It looks like somebody is sending POST or Host: commands to Redis. This is likely due to an attacker attempting to use Cross Protocol Scripting to compromise your Redis instance. Connection aborted.\");\n        logged_time = now;\n    }\n    freeClientAsync(c);\n}", "target": 0}
{"code": " */\nint re_yyget_column  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n        if (! YY_CURRENT_BUFFER)\n            return 0;\n    return yycolumn;", "target": 1}
{"code": "int LibRaw::dcraw_thumb_writer(const char *fname)\n{\n  if(!fname) \n    return ENOENT;\n  FILE *tfp = fopen(fname,\"wb\");\n  if(!tfp) \n    return errno;\n  if(!T.thumb)\n    {\n      fclose(tfp);\n      return LIBRAW_OUT_OF_ORDER_CALL;\n    }\n  try {\n    switch (T.tformat)\n      {\n      case LIBRAW_THUMBNAIL_JPEG:\n        jpeg_thumb_writer (tfp,T.thumb,T.tlength);\n        break;\n      case LIBRAW_THUMBNAIL_BITMAP:\n        fprintf (tfp, \"P6\\n%d %d\\n255\\n\", T.twidth, T.theight);\n        fwrite (T.thumb, 1, T.tlength, tfp);\n        break;\n      default:\n        fclose(tfp);\n        return LIBRAW_UNSUPPORTED_THUMBNAIL;\n      }\n    fclose(tfp);\n    return 0;\n  }\n  catch ( LibRaw_exceptions err) {\n    fclose(tfp);\n    EXCEPTION_HANDLER(err);\n  }\n}", "target": 0}
{"code": "static void timestamp(void)\n{\n    struct compile_time * const oct = &official_compile_time;\n    const struct tm *tp, *best_gm;\n    time(&oct->t);\n    best_gm = NULL;\n    tp = localtime(&oct->t);\n    if (tp) {\n        oct->local = *tp;\n        best_gm = &oct->local;\n        oct->have_local = true;\n    }\n    tp = gmtime(&oct->t);\n    if (tp) {\n        oct->gm = *tp;\n        best_gm = &oct->gm;\n        oct->have_gm = true;\n        if (!oct->have_local)\n            oct->local = oct->gm;\n    } else {\n        oct->gm = oct->local;\n    }\n    if (best_gm) {\n        oct->posix = make_posix_time(best_gm);\n        oct->have_posix = true;\n    }\n}", "target": 0}
{"code": "tTcpIpPacketParsingResult ParaNdis_CheckSumVerifyFlat(\n                                                PVOID pBuffer,\n                                                ULONG ulDataLength,\n                                                ULONG flags,\n                                                LPCSTR caller)\n{\n    tCompletePhysicalAddress SGBuffer;\n    SGBuffer.Virtual = pBuffer;\n    SGBuffer.size = ulDataLength;\n    return ParaNdis_CheckSumVerify(&SGBuffer, ulDataLength, 0, flags, caller);\n}", "target": 1}
{"code": "sraSpanInsertAfter(sraSpan *newspan, sraSpan *after) {\n  newspan->_next = after->_next;\n  newspan->_prev = after;\n  after->_next->_prev = newspan;\n  after->_next = newspan;\n}", "target": 1}
{"code": "static void rose_timer_expiry(struct timer_list *t)\n{\n\tstruct rose_sock *rose = from_timer(rose, t, timer);\n\tstruct sock *sk = &rose->sock;\n\tbh_lock_sock(sk);\n\tswitch (rose->state) {\n\tcase ROSE_STATE_1:\t\n\tcase ROSE_STATE_4:\t\n\t\trose_write_internal(sk, ROSE_CLEAR_REQUEST);\n\t\trose->state = ROSE_STATE_2;\n\t\trose_start_t3timer(sk);\n\t\tbreak;\n\tcase ROSE_STATE_2:\t\n\t\trose->neighbour->use--;\n\t\trose_disconnect(sk, ETIMEDOUT, -1, -1);\n\t\tbreak;\n\tcase ROSE_STATE_3:\t\n\t\tif (rose->condition & ROSE_COND_ACK_PENDING) {\n\t\t\trose->condition &= ~ROSE_COND_ACK_PENDING;\n\t\t\trose_enquiry_response(sk);\n\t\t}\n\t\tbreak;\n\t}\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}", "target": 0}
{"code": "void mbedtls_ssl_flight_free( mbedtls_ssl_flight_item *flight )\n{\n    mbedtls_ssl_flight_item *cur = flight;\n    mbedtls_ssl_flight_item *next;\n    while( cur != NULL )\n    {\n        next = cur->next;\n        mbedtls_free( cur->p );\n        mbedtls_free( cur );\n        cur = next;\n    }\n}", "target": 0}
{"code": "static u32 adpt_ioctl_to_context(adpt_hba * pHba, void *reply)\n{\n#if BITS_PER_LONG == 32\n\treturn (u32)(unsigned long)reply;\n#else\n\tulong flags = 0;\n\tu32 nr, i;\n\tspin_lock_irqsave(pHba->host->host_lock, flags);\n\tnr = ARRAY_SIZE(pHba->ioctl_reply_context);\n\tfor (i = 0; i < nr; i++) {\n\t\tif (pHba->ioctl_reply_context[i] == NULL) {\n\t\t\tpHba->ioctl_reply_context[i] = reply;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(pHba->host->host_lock, flags);\n\tif (i >= nr) {\n\t\tprintk(KERN_WARNING\"%s: Too many outstanding \"\n\t\t\t\t\"ioctl commands\\n\", pHba->name);\n\t\treturn (u32)-1;\n\t}\n\treturn i;\n#endif\n}", "target": 1}
{"code": "  explicit HashContext(const HashContext* ctx) {\n    assert(ctx->ops);\n    assert(ctx->ops->context_size >= 0);\n    ops = ctx->ops;\n    context = malloc(ops->context_size);\n    ops->hash_copy(context, ctx->context);\n    options = ctx->options;\n    key = ctx->key ? strdup(ctx->key) : nullptr;\n  }", "target": 1}
{"code": "void AV1_RewriteESDescriptorEx(GF_MPEGVisualSampleEntryBox *av1, GF_MediaBox *mdia)\n{\n\tGF_BitRateBox *btrt = gf_isom_sample_entry_get_bitrate((GF_SampleEntryBox *)av1, GF_FALSE);\n\tif (av1->emul_esd) gf_odf_desc_del((GF_Descriptor *)av1->emul_esd);\n\tav1->emul_esd = gf_odf_desc_esd_new(2);\n\tav1->emul_esd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\tav1->emul_esd->decoderConfig->objectTypeIndication = GF_CODECID_AV1;\n\tif (btrt) {\n\t\tav1->emul_esd->decoderConfig->bufferSizeDB = btrt->bufferSizeDB;\n\t\tav1->emul_esd->decoderConfig->avgBitrate = btrt->avgBitrate;\n\t\tav1->emul_esd->decoderConfig->maxBitrate = btrt->maxBitrate;\n\t}\n\tif (av1->av1_config) {\n\t\tGF_AV1Config *av1_cfg = AV1_DuplicateConfig(av1->av1_config->config);\n\t\tif (av1_cfg) {\n\t\t\tgf_odf_av1_cfg_write(av1_cfg, &av1->emul_esd->decoderConfig->decoderSpecificInfo->data, &av1->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\tgf_odf_av1_cfg_del(av1_cfg);\n\t\t}\n\t}\n}", "target": 1}
{"code": "void set_task_blockstep(struct task_struct *task, bool on)\n{\n\tunsigned long debugctl;\n\tlocal_irq_disable();\n\tdebugctl = get_debugctlmsr();\n\tif (on) {\n\t\tdebugctl |= DEBUGCTLMSR_BTF;\n\t\tset_tsk_thread_flag(task, TIF_BLOCKSTEP);\n\t} else {\n\t\tdebugctl &= ~DEBUGCTLMSR_BTF;\n\t\tclear_tsk_thread_flag(task, TIF_BLOCKSTEP);\n\t}\n\tif (task == current)\n\t\tupdate_debugctlmsr(debugctl);\n\tlocal_irq_enable();\n}", "target": 1}
{"code": "static int get_query(struct MHD_Connection *connection, char **query, const char *separator)\n{\n\tint element_counter;\n\tchar **elements;\n\tchar *query_str;\n\tstruct collect_query collect_query;\n\tint i;\n\tint j;\n\tint length = 0;\n\tdebug(LOG_DEBUG, \" Getting query, separator is [%s].\", separator);\n\telement_counter = MHD_get_connection_values(connection, MHD_GET_ARGUMENT_KIND, counter_iterator, NULL);\n\tif (element_counter < 0) {\n\t\t*query = safe_strdup(\"\");\n\t\treturn MHD_NO;\n\t}\n\telements = calloc(element_counter, sizeof(char *));\n\tif (elements == NULL) {\n\t\treturn MHD_NO;\n\t}\n\tcollect_query.i = 0;\n\tcollect_query.elements = elements;\n\tMHD_get_connection_values(connection, MHD_GET_ARGUMENT_KIND, collect_query_string, &collect_query);\n\tfor (i = 0; i < element_counter; i++) {\n\t\tif (!elements[i])\n\t\t\tcontinue;\n\t\tlength += strlen(elements[i]);\n\t\tif (i > 0) \n\t\t\tlength++;\n\t}\n\tif (*query == NULL) {\n\t\tfor (i = 0; i < element_counter; i++) {\n\t\t\tfree(elements[i]);\n\t\t}\n\t\tfree(elements);\n\t\treturn 0;\n\t}\n\tquery_str = safe_calloc(QUERYMAXLEN);\n\tfor (i = 0, j = 0; i < element_counter; i++) {\n\t\tif (!elements[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tdebug(LOG_DEBUG, \" element [%d] is [%s]\", i, elements[i]);\n\t\tstrncpy(*query + j, elements[i], length - j);\n\t\tif (i == 0) {\n\t\t\tstrcpy(query_str, \"?\");\n\t\t} else {\n\t\t\tif (QUERYMAXLEN - strlen(query_str) > length - j + 1) {\n\t\t\t\tstrncat(query_str, separator, QUERYMAXLEN - strlen(query_str));\n\t\t\t}\n\t\t}\n\t\tif (QUERYMAXLEN - strlen(query_str) > length - j) {\n\t\t\tstrncat(query_str, *query, QUERYMAXLEN - strlen(query_str));\n\t\t} else {\n\t\t\tdebug(LOG_WARNING, \" Query string exceeds the maximum of %d bytes so has been truncated.\", QUERYMAXLEN/2);\n\t\t}\n\t\tfree(elements[i]);\n\t}\n\tdebug(LOG_DEBUG, \" query is [%s]\", query_str);\n\tstrncpy(*query, query_str, QUERYMAXLEN);\n\tfree(query_str);\n\tfree(elements);\n\treturn 0;\n}", "target": 1}
{"code": "kg_unseal_iov(OM_uint32 *minor_status,\n              gss_ctx_id_t context_handle,\n              int *conf_state,\n              gss_qop_t *qop_state,\n              gss_iov_buffer_desc *iov,\n              int iov_count,\n              int toktype)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    OM_uint32 code;\n    ctx = (krb5_gss_ctx_id_rec *)context_handle;\n    if (!ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return GSS_S_NO_CONTEXT;\n    }\n    if (kg_locate_iov(iov, iov_count, GSS_IOV_BUFFER_TYPE_STREAM) != NULL) {\n        code = kg_unseal_stream_iov(minor_status, ctx, conf_state, qop_state,\n                                    iov, iov_count, toktype);\n    } else {\n        code = kg_unseal_iov_token(minor_status, ctx, conf_state, qop_state,\n                                   iov, iov_count, toktype);\n    }\n    return code;\n}", "target": 1}
{"code": "l2tp_bearer_type_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint32_t *ptr = (const uint32_t *)dat;\n\tif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_TYPE_ANALOG_MASK) {\n\t\tND_PRINT((ndo, \"A\"));\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_TYPE_DIGITAL_MASK) {\n\t\tND_PRINT((ndo, \"D\"));\n\t}\n}", "target": 1}
{"code": "nfs3svc_decode_symlinkargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_symlinkargs *args)\n{\n\tunsigned int len, avail;\n\tchar *old, *new;\n\tstruct kvec *vec;\n\tif (!(p = decode_fh(p, &args->ffh)) ||\n\t    !(p = decode_filename(p, &args->fname, &args->flen))\n\t\t)\n\t\treturn 0;\n\tp = decode_sattr3(p, &args->attrs);\n\tlen = ntohl(*p++);\n\tif (len == 0 || len > NFS3_MAXPATHLEN || len >= PAGE_SIZE)\n\t\treturn 0;\n\targs->tname = new = page_address(*(rqstp->rq_next_page++));\n\targs->tlen = len;\n\told = (char*)p;\n\tvec = &rqstp->rq_arg.head[0];\n\tif ((void *)old > vec->iov_base + vec->iov_len)\n\t\treturn 0;\n\tavail = vec->iov_len - (old - (char*)vec->iov_base);\n\twhile (len && avail && *old) {\n\t\t*new++ = *old++;\n\t\tlen--;\n\t\tavail--;\n\t}\n\tif (len && !avail && rqstp->rq_arg.page_len) {\n\t\tavail = min_t(unsigned int, rqstp->rq_arg.page_len, PAGE_SIZE);\n\t\told = page_address(rqstp->rq_arg.pages[0]);\n\t}\n\twhile (len && avail && *old) {\n\t\t*new++ = *old++;\n\t\tlen--;\n\t\tavail--;\n\t}\n\t*new = '\\0';\n\tif (len)\n\t\treturn 0;\n\treturn 1;\n}", "target": 0}
{"code": "int main(int argc, char * argv[])\n{\n    gr_face * face = 0;\n    try\n\t{\n\t\tif (argc != 2)\tthrow std::length_error(\"not enough arguments: need a backing font\");\n\t\tdummyFace = face_handle(argv[1]);\n\t\ttestFeatTable<FeatTableTestA>(testDataA, \"A\\n\");\n\t\ttestFeatTable<FeatTableTestB>(testDataB, \"B\\n\");\n\t\ttestFeatTable<FeatTableTestB>(testDataBunsorted, \"Bu\\n\");\n\t\ttestFeatTable<FeatTableTestC>(testDataCunsorted, \"C\\n\");\n\t\ttestFeatTable<FeatTableTestD>(testDataDunsorted, \"D\\n\");\n\t\ttestFeatTable<FeatTableTestE>(testDataE, \"E\\n\");\n\t\tFeatureMap testFeatureMap;\n\t\tdummyFace.replace_table(TtfUtil::Tag::Feat, &testBadOffset, sizeof testBadOffset);\n\t\tface = gr_make_face_with_ops(&dummyFace, &face_handle::ops, gr_face_dumbRendering);\n\t\tbool readStatus = testFeatureMap.readFeats(*face);\n\t\ttestAssert(\"fail gracefully on bad table\", !readStatus);\n\t}\n\tcatch (std::exception & e)\n\t{\n\t\tfprintf(stderr, \"%s: %s\\n\", argv[0], e.what());\n\t\tgr_face_destroy(face);\n\t\treturn 1;\n\t}\n    gr_face_destroy(face);\n    return 0;\n}", "target": 1}
{"code": "void HeaderMapImpl::remove(const LowerCaseString& key) {\n  EntryCb cb = ConstSingleton<StaticLookupTable>::get().find(key.get());\n  if (cb) {\n    StaticLookupResponse ref_lookup_response = cb(*this);\n    removeInline(ref_lookup_response.entry_);\n  } else {\n    for (auto i = headers_.begin(); i != headers_.end();) {\n      if (i->key() == key.get().c_str()) {\n        subtractSize(i->key().size() + i->value().size());\n        i = headers_.erase(i);\n      } else {\n        ++i;\n      }\n    }\n  }\n}", "target": 0}
{"code": "njs_vmcode_array(njs_vm_t *vm, u_char *pc)\n{\n    uint32_t            length;\n    njs_array_t         *array;\n    njs_value_t         *value;\n    njs_vmcode_array_t  *code;\n    code = (njs_vmcode_array_t *) pc;\n    array = njs_array_alloc(vm, 0, code->length, NJS_ARRAY_SPARE);\n    if (njs_fast_path(array != NULL)) {\n        if (code->ctor) {\n            value = array->start;\n            length = array->length;\n            do {\n                njs_set_invalid(value);\n                value++;\n                length--;\n            } while (length != 0);\n        } else {\n            array->length = 0;\n        }\n        njs_set_array(&vm->retval, array);\n        return sizeof(njs_vmcode_array_t);\n    }\n    return NJS_ERROR;\n}", "target": 1}
{"code": "static int amf_get_field_value2(GetByteContext *gb,\n                           const uint8_t *name, uint8_t *dst, int dst_size)\n{\n    int namelen = strlen(name);\n    int len;\n    while (bytestream2_peek_byte(gb) != AMF_DATA_TYPE_OBJECT && bytestream2_get_bytes_left(gb) > 0) {\n        int ret = amf_tag_skip(gb);\n        if (ret < 0)\n            return -1;\n    }\n    if (bytestream2_get_bytes_left(gb) < 3)\n        return -1;\n    bytestream2_get_byte(gb);\n    for (;;) {\n        int size = bytestream2_get_be16(gb);\n        if (!size)\n            break;\n        if (size < 0 || size >= bytestream2_get_bytes_left(gb))\n            return -1;\n        bytestream2_skip(gb, size);\n        if (size == namelen && !memcmp(gb->buffer-size, name, namelen)) {\n            switch (bytestream2_get_byte(gb)) {\n            case AMF_DATA_TYPE_NUMBER:\n                snprintf(dst, dst_size, \"%g\", av_int2double(bytestream2_get_be64(gb)));\n                break;\n            case AMF_DATA_TYPE_BOOL:\n                snprintf(dst, dst_size, \"%s\", bytestream2_get_byte(gb) ? \"true\" : \"false\");\n                break;\n            case AMF_DATA_TYPE_STRING:\n                len = bytestream2_get_be16(gb);\n                if (dst_size < 1)\n                    return -1;\n                if (dst_size < len + 1)\n                    len = dst_size - 1;\n                bytestream2_get_buffer(gb, dst, len);\n                dst[len] = 0;\n                break;\n            default:\n                return -1;\n            }\n            return 0;\n        }\n        len = amf_tag_skip(gb);\n        if (len < 0 || bytestream2_get_bytes_left(gb) <= 0)\n            return -1;\n    }\n    return -1;\n}", "target": 0}
{"code": "static void xennet_make_txreqs(\n\tstruct xennet_gnttab_make_txreq *info,\n\tstruct page *page,\n\tunsigned int offset, unsigned int len)\n{\n\tpage += offset >> PAGE_SHIFT;\n\toffset &= ~PAGE_MASK;\n\twhile (len) {\n\t\tinfo->page = page;\n\t\tinfo->size = 0;\n\t\tgnttab_foreach_grant_in_range(page, offset, len,\n\t\t\t\t\t      xennet_make_one_txreq,\n\t\t\t\t\t      info);\n\t\tpage++;\n\t\toffset = 0;\n\t\tlen -= info->size;\n\t}\n}", "target": 0}
{"code": "void set_module_sig_enforced(void)\n{\n\tsig_enforce = true;\n}", "target": 1}
{"code": "TEE_Result syscall_authenc_update_payload(unsigned long state,\n\t\t\tconst void *src_data, size_t src_len, void *dst_data,\n\t\t\tuint64_t *dst_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tsize_t dlen = 0;\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t) src_data, src_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = get_user_u64_as_size_t(&dlen, dst_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_WRITE |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)dst_data, dlen);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (dlen < src_len) {\n\t\tres = TEE_ERROR_SHORT_BUFFER;\n\t\tgoto out;\n\t}\n\tres = crypto_authenc_update_payload(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t    src_data, src_len, dst_data,\n\t\t\t\t\t    &dlen);\nout:\n\tif (res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) {\n\t\tTEE_Result res2 = put_user_u64(dst_len, dlen);\n\t\tif (res2 != TEE_SUCCESS)\n\t\t\tres = res2;\n\t}\n\treturn res;\n}", "target": 0}
{"code": "dtls1_process_buffered_records(SSL *s)\n    {\n    pitem *item;\n    item = pqueue_peek(s->d1->unprocessed_rcds.q);\n    if (item)\n        {\n        if (s->d1->unprocessed_rcds.epoch != s->d1->r_epoch)\n            return(1);  \n        while (pqueue_peek(s->d1->unprocessed_rcds.q))\n            {\n            dtls1_get_unprocessed_record(s);\n            if ( ! dtls1_process_record(s))\n                return(0);\n            dtls1_buffer_record(s, &(s->d1->processed_rcds), \n                s->s3->rrec.seq_num);\n            }\n        }\n    s->d1->processed_rcds.epoch = s->d1->r_epoch;\n    s->d1->unprocessed_rcds.epoch = s->d1->r_epoch + 1;\n    return(1);\n    }", "target": 1}
{"code": "nfsd4_getdeviceinfo(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate,\n\t\tstruct nfsd4_getdeviceinfo *gdp)\n{\n\tconst struct nfsd4_layout_ops *ops;\n\tstruct nfsd4_deviceid_map *map;\n\tstruct svc_export *exp;\n\t__be32 nfserr;\n\tdprintk(\"%s: layout_type %u dev_id [0x%llx:0x%x] maxcnt %u\\n\",\n\t       __func__,\n\t       gdp->gd_layout_type,\n\t       gdp->gd_devid.fsid_idx, gdp->gd_devid.generation,\n\t       gdp->gd_maxcount);\n\tmap = nfsd4_find_devid_map(gdp->gd_devid.fsid_idx);\n\tif (!map) {\n\t\tdprintk(\"%s: couldn't find device ID to export mapping!\\n\",\n\t\t\t__func__);\n\t\treturn nfserr_noent;\n\t}\n\texp = rqst_exp_find(rqstp, map->fsid_type, map->fsid);\n\tif (IS_ERR(exp)) {\n\t\tdprintk(\"%s: could not find device id\\n\", __func__);\n\t\treturn nfserr_noent;\n\t}\n\tnfserr = nfserr_layoutunavailable;\n\tops = nfsd4_layout_verify(exp, gdp->gd_layout_type);\n\tif (!ops)\n\t\tgoto out;\n\tnfserr = nfs_ok;\n\tif (gdp->gd_maxcount != 0) {\n\t\tnfserr = ops->proc_getdeviceinfo(exp->ex_path.mnt->mnt_sb,\n\t\t\t\trqstp, cstate->session->se_client, gdp);\n\t}\n\tgdp->gd_notify_types &= ops->notify_types;\nout:\n\texp_put(exp);\n\treturn nfserr;\n}", "target": 0}
{"code": "BZIP3_API struct bz3_state * bz3_new(s32 block_size) {\n    if (block_size < KiB(65) || block_size > MiB(511)) {\n        return NULL;\n    }\n    struct bz3_state * bz3_state = malloc(sizeof(struct bz3_state));\n    if (!bz3_state) {\n        return NULL;\n    }\n    bz3_state->cm_state = malloc(sizeof(state));\n    bz3_state->swap_buffer = malloc(bz3_bound(block_size));\n    bz3_state->sais_array = malloc((block_size + 128) * sizeof(s32));\n    memset(bz3_state->sais_array, 0, sizeof(s32) * (block_size + 128));\n    bz3_state->lzp_lut = calloc(1 << LZP_DICTIONARY, sizeof(s32));\n    if (!bz3_state->cm_state || !bz3_state->swap_buffer || !bz3_state->sais_array || !bz3_state->lzp_lut) {\n        if (bz3_state->cm_state) free(bz3_state->cm_state);\n        if (bz3_state->swap_buffer) free(bz3_state->swap_buffer);\n        if (bz3_state->sais_array) free(bz3_state->sais_array);\n        if (bz3_state->lzp_lut) free(bz3_state->lzp_lut);\n        free(bz3_state);\n        return NULL;\n    }\n    bz3_state->block_size = block_size;\n    bz3_state->last_error = BZ3_OK;\n    return bz3_state;\n}", "target": 1}
{"code": "gopherEndHTML(GopherStateData * gopherState)\n{\n    StoreEntry *e = gopherState->entry;\n    if (!gopherState->HTML_header_added) {\n        gopherHTMLHeader(e, \"Server Return Nothing\", nullptr);\n        storeAppendPrintf(e, \"<P>The Gopher query resulted in a blank response</P>\");\n    } else if (gopherState->HTML_pre) {\n        storeAppendPrintf(e, \"</PRE>\\n\");\n    }\n    gopherHTMLFooter(e);\n}", "target": 1}
{"code": "  bool ms_deliver_verify_authorizer(Connection *con, int peer_type,\n\t\t\t\t    int protocol, bufferlist& authorizer, bufferlist& authorizer_reply,\n\t\t\t\t    bool& isvalid, CryptoKey& session_key) {\n    for (list<Dispatcher*>::iterator p = dispatchers.begin();\n\t p != dispatchers.end();\n\t ++p) {\n      if ((*p)->ms_verify_authorizer(con, peer_type, protocol, authorizer, authorizer_reply, isvalid, session_key))\n\treturn true;\n    }\n    return false;\n  }", "target": 1}
{"code": "static void set_inverse_transl(struct vc_data *conp, struct uni_pagedir *p, int i)\n{\n\tint j, glyph;\n\tunsigned short *t = translations[i];\n\tunsigned char *q;\n\tif (!p) return;\n\tq = p->inverse_translations[i];\n\tif (!q) {\n\t\tq = p->inverse_translations[i] = kmalloc(MAX_GLYPH, GFP_KERNEL);\n\t\tif (!q) return;\n\t}\n\tmemset(q, 0, MAX_GLYPH);\n\tfor (j = 0; j < E_TABSZ; j++) {\n\t\tglyph = conv_uni_to_pc(conp, t[j]);\n\t\tif (glyph >= 0 && glyph < MAX_GLYPH && q[glyph] < 32) {\n\t\t  \tq[glyph] = j;\n\t\t}\n\t}\n}", "target": 0}
{"code": "start_output_ppm (j_decompress_ptr cinfo, djpeg_dest_ptr dinfo)\n{\n  ppm_dest_ptr dest = (ppm_dest_ptr) dinfo;\n  switch (cinfo->out_color_space) {\n  case JCS_GRAYSCALE:\n    fprintf(dest->pub.output_file, \"P5\\n%ld %ld\\n%d\\n\",\n            (long) cinfo->output_width, (long) cinfo->output_height,\n            PPM_MAXVAL);\n    break;\n  case JCS_RGB:\n  case JCS_EXT_RGB:\n  case JCS_EXT_RGBX:\n  case JCS_EXT_BGR:\n  case JCS_EXT_BGRX:\n  case JCS_EXT_XBGR:\n  case JCS_EXT_XRGB:\n  case JCS_EXT_RGBA:\n  case JCS_EXT_BGRA:\n  case JCS_EXT_ABGR:\n  case JCS_EXT_ARGB:\n  case JCS_CMYK:\n    fprintf(dest->pub.output_file, \"P6\\n%ld %ld\\n%d\\n\",\n            (long) cinfo->output_width, (long) cinfo->output_height,\n            PPM_MAXVAL);\n    break;\n  default:\n    ERREXIT(cinfo, JERR_PPM_COLORSPACE);\n  }\n}", "target": 0}
{"code": "MONGO_EXPORT int bson_iterator_int( const bson_iterator *i ) {\n    switch ( bson_iterator_type( i ) ) {\n    case BSON_INT:\n        return bson_iterator_int_raw( i );\n    case BSON_LONG:\n        return bson_iterator_long_raw( i );\n    case BSON_DOUBLE:\n        return bson_iterator_double_raw( i );\n    default:\n        return 0;\n    }\n}", "target": 1}
{"code": "REDIS_STATIC int _quicklistNodeAllowInsert(const quicklistNode *node,\n                                           const int fill, const size_t sz) {\n    if (unlikely(!node))\n        return 0;\n    int ziplist_overhead;\n    if (sz < 254)\n        ziplist_overhead = 1;\n    else\n        ziplist_overhead = 5;\n    if (sz < 64)\n        ziplist_overhead += 1;\n    else if (likely(sz < 16384))\n        ziplist_overhead += 2;\n    else\n        ziplist_overhead += 5;\n    unsigned int new_sz = node->sz + sz + ziplist_overhead;\n    if (likely(_quicklistNodeSizeMeetsOptimizationRequirement(new_sz, fill)))\n        return 1;\n    else if (!sizeMeetsSafetyLimit(new_sz))\n        return 0;\n    else if ((int)node->count < fill)\n        return 1;\n    else\n        return 0;\n}", "target": 0}
{"code": "static MagickBooleanType IsTXT(const unsigned char *magick,const size_t length)\n{\n#define MagickID  \"# ImageMagick pixel enumeration:\"\n  char\n    colorspace[MagickPathExtent];\n  ssize_t\n    count;\n  unsigned long\n    columns,\n    depth,\n    rows;\n  if (length < 40)\n    return(MagickFalse);\n  if (LocaleNCompare((const char *) magick,MagickID,strlen(MagickID)) != 0)\n    return(MagickFalse);\n  count=(ssize_t) sscanf((const char *) magick+32,\"%lu,%lu,%lu,%s\",&columns,\n    &rows,&depth,colorspace);\n  if (count != 4)\n    return(MagickFalse);\n  return(MagickTrue);\n}", "target": 0}
{"code": "static int _FVMenuClose(FontView *fv) {\n    int i;\n    SplineFont *sf = fv->b.cidmaster?fv->b.cidmaster:fv->b.sf;\n    if ( !SFCloseAllInstrs(fv->b.sf) )\nreturn( false );\n    if ( fv->b.nextsame!=NULL || fv->b.sf->fv!=&fv->b ) {\n    } else if ( warn_script_unsaved && fv->script_unsaved && \n                AskScriptChanged()==2 ) {\n        return false;\n    } else if ( SFAnyChanged(sf) ) {\n\ti = AskChanged(fv->b.sf);\n\tif ( i==2 )\t\nreturn( false );\n\tif ( i==0 && !_FVMenuSave(fv))\t\t\nreturn(false);\n\telse\n\t    SFClearAutoSave(sf);\t\t\n    }\n    _FVCloseWindows(fv);\n    if ( sf->filename!=NULL )\n\tRecentFilesRemember(sf->filename);\n    else if ( sf->origname!=NULL )\n\tRecentFilesRemember(sf->origname);\n    GDrawDestroyWindow(fv->gw);\nreturn( true );\n}", "target": 0}
{"code": "    void Encode(Key, const Value& value) {\n      AddToSummary(Key::key(), Key::Encode(value).size());\n    }", "target": 1}
{"code": "void Curl_ssl_detach_conn(struct Curl_easy *data,\n                          struct connectdata *conn)\n{\n  if(Curl_ssl->disassociate_connection) {\n    Curl_ssl->disassociate_connection(data, FIRSTSOCKET);\n    if(conn->sock[SECONDARYSOCKET] && conn->bits.sock_accepted)\n      Curl_ssl->disassociate_connection(data, SECONDARYSOCKET);\n  }\n}", "target": 0}
{"code": "static struct ion_handle *ion_handle_get_by_id_nolock(struct ion_client *client,\n\t\t\t\t\t\tint id)\n{\n\tstruct ion_handle *handle;\n\thandle = idr_find(&client->idr, id);\n\tif (handle)\n\t\tion_handle_get(handle);\n\treturn handle ? handle : ERR_PTR(-EINVAL);\n}", "target": 0}
{"code": "static void php_mb_regex_free_cache(php_mb_regex_t **pre) \n{\n\tonig_free(*pre);\n}", "target": 1}
{"code": "static void free_clt(struct rtrs_clt_sess *clt)\n{\n\tfree_permits(clt);\n\tfree_percpu(clt->pcpu_path);\n\tmutex_destroy(&clt->paths_ev_mutex);\n\tmutex_destroy(&clt->paths_mutex);\n\tdevice_unregister(&clt->dev);\n}", "target": 1}
{"code": "static GF_Err BM_ParseGlobalQuantizer(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tGF_Node *node;\n\tGF_Command *com;\n\tGF_CommandField *inf;\n\tnode = gf_bifs_dec_node(codec, bs, NDT_SFWorldNode);\n\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\tif (codec->scenegraph->global_qp) {\n\t\tgf_node_unregister(codec->scenegraph->global_qp, NULL);\n\t}\n\tcodec->ActiveQP = NULL;\n\tcodec->scenegraph->global_qp = NULL;\n\tif (gf_node_get_tag(node) != TAG_MPEG4_QuantizationParameter) {\n\t\tgf_node_unregister(node, NULL);\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tcodec->ActiveQP = (M_QuantizationParameter *) node;\n\tcodec->ActiveQP->isLocal = 0;\n\tcodec->scenegraph->global_qp = node;\n\tnode->sgprivate->num_instances = 2;\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER);\n\tinf = gf_sg_command_field_new(com);\n\tinf->new_node = node;\n\tinf->field_ptr = &inf->new_node;\n\tinf->fieldType = GF_SG_VRML_SFNODE;\n\tgf_list_add(com_list, com);\n\treturn GF_OK;\n}", "target": 1}
{"code": "static void free_func_state(struct bpf_func_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tkfree(state->stack);\n\tkfree(state);\n}", "target": 0}
{"code": "TIFFFlushData1(TIFF* tif)\n{\n\tif (tif->tif_rawcc > 0 && tif->tif_flags & TIFF_BUF4WRITE ) {\n\t\tif (!isFillOrder(tif, tif->tif_dir.td_fillorder) &&\n\t\t    (tif->tif_flags & TIFF_NOBITREV) == 0)\n\t\t\tTIFFReverseBits((uint8*)tif->tif_rawdata,\n\t\t\t    tif->tif_rawcc);\n\t\tif (!TIFFAppendToStrip(tif,\n\t\t    isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip,\n\t\t    tif->tif_rawdata, tif->tif_rawcc))\n        {\n            tif->tif_rawcc = 0;\n            tif->tif_rawcp = tif->tif_rawdata;\n\t\t\treturn (0);\n        }\n\t\ttif->tif_rawcc = 0;\n\t\ttif->tif_rawcp = tif->tif_rawdata;\n\t}\n\treturn (1);\n}", "target": 0}
{"code": "void snd_usb_mixer_disconnect(struct usb_mixer_interface *mixer)\n{\n\tusb_kill_urb(mixer->urb);\n\tusb_kill_urb(mixer->rc_urb);\n}", "target": 1}
{"code": "static long kvm_dev_ioctl(struct file *filp,\n\t\t\t  unsigned int ioctl, unsigned long arg)\n{\n\tlong r = -EINVAL;\n\tswitch (ioctl) {\n\tcase KVM_GET_API_VERSION:\n\t\tr = -EINVAL;\n\t\tif (arg)\n\t\t\tgoto out;\n\t\tr = KVM_API_VERSION;\n\t\tbreak;\n\tcase KVM_CREATE_VM:\n\t\tr = -EINVAL;\n\t\tif (arg)\n\t\t\tgoto out;\n\t\tr = kvm_dev_ioctl_create_vm();\n\t\tbreak;\n\tcase KVM_CHECK_EXTENSION:\n\t\tr = kvm_dev_ioctl_check_extension_generic(arg);\n\t\tbreak;\n\tcase KVM_GET_VCPU_MMAP_SIZE:\n\t\tr = -EINVAL;\n\t\tif (arg)\n\t\t\tgoto out;\n\t\tr = PAGE_SIZE;     \n#ifdef CONFIG_X86\n\t\tr += PAGE_SIZE;    \n#endif\n#ifdef KVM_COALESCED_MMIO_PAGE_OFFSET\n\t\tr += PAGE_SIZE;    \n#endif\n\t\tbreak;\n\tcase KVM_TRACE_ENABLE:\n\tcase KVM_TRACE_PAUSE:\n\tcase KVM_TRACE_DISABLE:\n\t\tr = -EOPNOTSUPP;\n\t\tbreak;\n\tdefault:\n\t\treturn kvm_arch_dev_ioctl(filp, ioctl, arg);\n\t}\nout:\n\treturn r;\n}", "target": 0}
{"code": "otError Commissioner::GeneratePskc(const char *              aPassPhrase,\n                                   const char *              aNetworkName,\n                                   const Mac::ExtendedPanId &aExtPanId,\n                                   Pskc &                    aPskc)\n{\n    otError    error        = OT_ERROR_NONE;\n    const char saltPrefix[] = \"Thread\";\n    uint8_t    salt[OT_PBKDF2_SALT_MAX_LEN];\n    uint16_t   saltLen = 0;\n    uint16_t   passphraseLen;\n    uint8_t    networkNameLen;\n    passphraseLen  = static_cast<uint16_t>(strnlen(aPassPhrase, OT_COMMISSIONING_PASSPHRASE_MAX_SIZE + 1));\n    networkNameLen = static_cast<uint8_t>(strnlen(aNetworkName, OT_NETWORK_NAME_MAX_SIZE + 1));\n    VerifyOrExit((passphraseLen >= OT_COMMISSIONING_PASSPHRASE_MIN_SIZE) &&\n                     (passphraseLen <= OT_COMMISSIONING_PASSPHRASE_MAX_SIZE) &&\n                     (networkNameLen <= OT_NETWORK_NAME_MAX_SIZE),\n                 error = OT_ERROR_INVALID_ARGS);\n    memset(salt, 0, sizeof(salt));\n    memcpy(salt, saltPrefix, sizeof(saltPrefix) - 1);\n    saltLen += static_cast<uint16_t>(sizeof(saltPrefix) - 1);\n    memcpy(salt + saltLen, aExtPanId.m8, sizeof(aExtPanId));\n    saltLen += OT_EXT_PAN_ID_SIZE;\n    memcpy(salt + saltLen, aNetworkName, networkNameLen);\n    saltLen += networkNameLen;\n    otPbkdf2Cmac(reinterpret_cast<const uint8_t *>(aPassPhrase), passphraseLen, reinterpret_cast<const uint8_t *>(salt),\n                 saltLen, 16384, OT_PSKC_MAX_SIZE, aPskc.m8);\nexit:\n    return error;\n}", "target": 0}
{"code": "int wait_for_key_construction(struct key *key, bool intr)\n{\n\tint ret;\n\tret = wait_on_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT,\n\t\t\t  intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);\n\tif (ret)\n\t\treturn -ERESTARTSYS;\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) {\n\t\tsmp_rmb();\n\t\treturn key->reject_error;\n\t}\n\treturn key_validate(key);\n}", "target": 1}
{"code": "lyd_new_yangdata(const struct lys_module *module, const char *name_template, const char *name)\n{\n    const struct lys_node *schema = NULL, *snode;\n    if (!module || !name_template || !name) {\n        LOGARG;\n        return NULL;\n    }\n    schema = lyp_get_yang_data_template(module, name_template, strlen(name_template));\n    if (!schema) {\n        LOGERR(module->ctx, LY_EINVAL, \"Failed to find yang-data template \\\"%s\\\".\", name_template);\n        return NULL;\n    }\n    if (lys_getnext_data(module, schema, name, strlen(name), LYS_CONTAINER, &snode) || !snode) {\n        LOGERR(module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a container child of \\\"%s:%s\\\".\",\n               name, module->name, schema->name);\n        return NULL;\n    }\n    return _lyd_new(NULL, snode, 0);\n}", "target": 1}
{"code": "static inline int memcmp_P(const void *a1, const void *b1, size_t len) {\n    const uint8_t* a = (const uint8_t*)(a1);\n    uint8_t* b = (uint8_t*)(b1);\n    for (size_t i=0; i<len; i++) {\n        uint8_t d = pgm_read_byte(a) - pgm_read_byte(b);\n        if (d) return d;\n        a++;\n        b++;\n    }\n    return 0;\n}", "target": 0}
{"code": "void PDPClient::perform_builtin_endpoints_matching(\n        const ParticipantProxyData& pdata)\n{\n    if (mp_builtin->mp_WLP != nullptr)\n    {\n        mp_builtin->mp_WLP->assignRemoteEndpoints(pdata);\n    }\n}", "target": 1}
{"code": "void Logger::addPeer(const QString &ip, bool blocked, const QString &reason)\n{\n    QWriteLocker locker(&lock);\n    Log::Peer temp = { peerCounter++, QDateTime::currentMSecsSinceEpoch(), ip, blocked, reason };\n    m_peers.push_back(temp);\n    if (m_peers.size() >= MAX_LOG_MESSAGES)\n        m_peers.pop_front();\n    emit newLogPeer(temp);\n}", "target": 1}
{"code": "string SummarizeArray<bool>(int64_t limit, int64_t num_elts,\n                            const TensorShape& tensor_shape, const char* data,\n                            const bool print_v2) {\n  if (data == nullptr) {\n    return strings::StrCat(\"\");  \n  }\n  auto mutable_data = std::unique_ptr<char[]>(new char[num_elts]);\n  for (int64_t i = 0; i < num_elts; ++i)\n    mutable_data.get()[i] = data[i] ? 1 : 0;\n  bool* array = reinterpret_cast<bool*>(mutable_data.get());\n  return SummarizeArrayInternal<bool>(limit, num_elts, tensor_shape, array,\n                                      print_v2);\n}", "target": 0}
{"code": "virSecuritySELinuxMCSFind(virSecurityManager *mgr,\n                          const char *sens,\n                          int catMin,\n                          int catMax)\n{\n    virSecuritySELinuxData *data = virSecurityManagerGetPrivateData(mgr);\n    int catRange;\n    char *mcs = NULL;\n    catRange = (catMax - catMin) + 1;\n    if (catRange < 8) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Category range c%d-c%d too small\"),\n                       catMin, catMax);\n        return NULL;\n    }\n    VIR_DEBUG(\"Using sensitivity level '%s' cat min %d max %d range %d\",\n              sens, catMin, catMax, catRange);\n    for (;;) {\n        int c1 = virRandomInt(catRange);\n        int c2 = virRandomInt(catRange);\n        VIR_DEBUG(\"Try cat %s:c%d,c%d\", sens, c1 + catMin, c2 + catMin);\n        if (c1 == c2) {\n            continue;\n        } else {\n            if (c1 > c2) {\n                int t = c1;\n                c1 = c2;\n                c2 = t;\n            }\n            mcs = g_strdup_printf(\"%s:c%d,c%d\", sens, catMin + c1, catMin + c2);\n        }\n        if (virHashLookup(data->mcs, mcs) == NULL)\n            break;\n        VIR_FREE(mcs);\n    }\n    return mcs;\n}", "target": 0}
{"code": "ECDSA_PrivateKey::create_signature_op(RandomNumberGenerator& ,\n                                      const std::string& params,\n                                      const std::string& provider) const\n   {\n#if defined(BOTAN_HAS_BEARSSL)\n   if(provider == \"bearssl\" || provider.empty())\n      {\n      try\n         {\n         return make_bearssl_ecdsa_sig_op(*this, params);\n         }\n      catch(Lookup_Error& e)\n         {\n         if(provider == \"bearssl\")\n            throw;\n         }\n      }\n#endif\n#if defined(BOTAN_HAS_OPENSSL)\n   if(provider == \"openssl\" || provider.empty())\n      {\n      try\n         {\n         return make_openssl_ecdsa_sig_op(*this, params);\n         }\n      catch(Lookup_Error& e)\n         {\n         if(provider == \"openssl\")\n            throw;\n         }\n      }\n#endif\n   if(provider == \"base\" || provider.empty())\n      return std::unique_ptr<PK_Ops::Signature>(new ECDSA_Signature_Operation(*this, params));\n   throw Provider_Not_Found(algo_name(), provider);\n   }", "target": 1}
{"code": "    const std::unordered_map<std::string, std::string> &cookies() const override\n    {\n        return cookies_;\n    }", "target": 1}
{"code": "void CodeBlock::lazyCompileImpl(Runtime &runtime) {\n  assert(isLazy() && \"Laziness has not been checked\");\n  PerfSection perf(\"Lazy function compilation\");\n  auto *provider = (hbc::BCProviderLazy *)runtimeModule_->getBytecode();\n  auto *func = provider->getBytecodeFunction();\n  auto *lazyData = func->getLazyCompilationData();\n  auto bcModule = compileLazyFunction(lazyData);\n  runtimeModule_->initializeLazyMayAllocate(\n      hbc::BCProviderFromSrc::createBCProviderFromSrc(std::move(bcModule)));\n  functionID_ = runtimeModule_->getBytecode()->getGlobalFunctionIndex();\n  functionHeader_ =\n      runtimeModule_->getBytecode()->getFunctionHeader(functionID_);\n  bytecode_ = runtimeModule_->getBytecode()->getBytecode(functionID_);\n}", "target": 1}
{"code": "ttwu_do_wakeup(struct rq *rq, struct task_struct *p, int wake_flags)\n{\n\tcheck_preempt_curr(rq, p, wake_flags);\n\tp->state = TASK_RUNNING;\n\ttrace_sched_wakeup(p);\n#ifdef CONFIG_SMP\n\tif (p->sched_class->task_woken) {\n\t\tlockdep_unpin_lock(&rq->lock);\n\t\tp->sched_class->task_woken(rq, p);\n\t\tlockdep_pin_lock(&rq->lock);\n\t}\n\tif (rq->idle_stamp) {\n\t\tu64 delta = rq_clock(rq) - rq->idle_stamp;\n\t\tu64 max = 2*rq->max_idle_balance_cost;\n\t\tupdate_avg(&rq->avg_idle, delta);\n\t\tif (rq->avg_idle > max)\n\t\t\trq->avg_idle = max;\n\t\trq->idle_stamp = 0;\n\t}\n#endif\n}", "target": 0}
{"code": "Status PyArrayDescr_to_TF_DataType(PyArray_Descr* descr,\n                                   TF_DataType* out_tf_datatype) {\n  PyObject* key;\n  PyObject* value;\n  Py_ssize_t pos = 0;\n  if (descr->fields == nullptr) {\n    return errors::Internal(\"Unexpected numpy data type\");\n  }\n  if (PyDict_Next(descr->fields, &pos, &key, &value)) {\n    const char* key_string =\n        PyBytes_Check(key) ? PyBytes_AsString(key)\n                           : PyBytes_AsString(PyUnicode_AsASCIIString(key));\n    if (!key_string) {\n      return errors::Internal(\"Corrupt numpy type descriptor\");\n    }\n    tensorflow::string key = key_string;\n    if (key == \"quint8\") {\n      *out_tf_datatype = TF_QUINT8;\n    } else if (key == \"qint8\") {\n      *out_tf_datatype = TF_QINT8;\n    } else if (key == \"qint16\") {\n      *out_tf_datatype = TF_QINT16;\n    } else if (key == \"quint16\") {\n      *out_tf_datatype = TF_QUINT16;\n    } else if (key == \"qint32\") {\n      *out_tf_datatype = TF_QINT32;\n    } else if (key == \"resource\") {\n      *out_tf_datatype = TF_RESOURCE;\n    } else {\n      return errors::Internal(\"Unsupported numpy data type\");\n    }\n    return Status::OK();\n  }\n  return errors::Internal(\"Unsupported numpy data type\");\n}", "target": 0}
{"code": "static void cmd_anal_ucall_ref(RCore *core, ut64 addr) {\n\tRAnalFunction * fcn = r_anal_get_function_at (core->anal, addr);\n\tif (fcn) {\n\t\tr_cons_printf (\" ; %s\", fcn->name);\n\t} else {\n\t\tr_cons_printf (\" ; 0x%\" PFMT64x, addr);\n\t}\n}", "target": 1}
{"code": "int perf_cpu_time_max_percent_handler(struct ctl_table *table, int write,\n\t\t\t\tvoid __user *buffer, size_t *lenp,\n\t\t\t\tloff_t *ppos)\n{\n\tint ret = proc_dointvec(table, write, buffer, lenp, ppos);\n\tif (ret || !write)\n\t\treturn ret;\n\tif (sysctl_perf_cpu_time_max_percent == 100 ||\n\t    sysctl_perf_cpu_time_max_percent == 0) {\n\t\tprintk(KERN_WARNING\n\t\t       \"perf: Dynamic interrupt throttling disabled, can hang your system!\\n\");\n\t\tWRITE_ONCE(perf_sample_allowed_ns, 0);\n\t} else {\n\t\tupdate_perf_cpu_limits();\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const float in_min = context->input(2).flat<float>()(0);\n    const float in_max = context->input(3).flat<float>()(0);\n    ImageResizerState st(align_corners_, false);\n    st.ValidateAndCreateOutput(context);\n    if (!context->status().ok()) return;\n    if (st.output->NumElements() == 0) return;\n    typename TTypes<T, 4>::ConstTensor image_data(\n        context->input(0).tensor<T, 4>());\n    typename TTypes<T, 4>::Tensor output_data(st.output->tensor<T, 4>());\n    ResizeBilinear<T>(image_data, st.height_scale, st.width_scale, in_min,\n                      in_max, half_pixel_centers_, &output_data);\n    Tensor* out_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &out_min));\n    out_min->flat<float>()(0) = in_min;\n    Tensor* out_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &out_max));\n    out_max->flat<float>()(0) = in_max;\n  }", "target": 1}
{"code": "void rds6_inc_info_copy(struct rds_incoming *inc,\n\t\t\tstruct rds_info_iterator *iter,\n\t\t\tstruct in6_addr *saddr, struct in6_addr *daddr,\n\t\t\tint flip)\n{\n\tstruct rds6_info_message minfo6;\n\tminfo6.seq = be64_to_cpu(inc->i_hdr.h_sequence);\n\tminfo6.len = be32_to_cpu(inc->i_hdr.h_len);\n\tminfo6.tos = inc->i_conn->c_tos;\n\tif (flip) {\n\t\tminfo6.laddr = *daddr;\n\t\tminfo6.faddr = *saddr;\n\t\tminfo6.lport = inc->i_hdr.h_dport;\n\t\tminfo6.fport = inc->i_hdr.h_sport;\n\t} else {\n\t\tminfo6.laddr = *saddr;\n\t\tminfo6.faddr = *daddr;\n\t\tminfo6.lport = inc->i_hdr.h_sport;\n\t\tminfo6.fport = inc->i_hdr.h_dport;\n\t}\n\tminfo6.flags = 0;\n\trds_info_copy(iter, &minfo6, sizeof(minfo6));\n}", "target": 0}
{"code": "crm_recv_plaintext(int sock, size_t max_size, size_t *recv_len, int *disconnected)\n{\n    char *buf = NULL;\n    ssize_t rc = 0;\n    ssize_t len = 0;\n    ssize_t chunk_size = max_size ? max_size : 1024;\n    size_t buf_size = 0;\n    size_t read_size = 0;\n    if (sock <= 0) {\n        if (disconnected) {\n            *disconnected = 1;\n        }\n        goto done;\n    }\n    buf = calloc(1, chunk_size + 1);\n    buf_size = chunk_size;\n    while (TRUE) {\n        errno = 0;\n        read_size = buf_size - len;\n        if (!max_size && (read_size < (chunk_size / 2))) {\n            buf_size += chunk_size;\n            crm_trace(\"Grow buffer by %d more bytes. buf is now %d bytes\", (int)chunk_size, buf_size);\n            buf = realloc(buf, buf_size + 1);\n            CRM_ASSERT(buf != NULL);\n            read_size = buf_size - len;\n        }\n        rc = read(sock, buf + len, chunk_size);\n        if (rc > 0) {\n            crm_trace(\"Got %d more bytes. errno=%d\", (int)rc, errno);\n            len += rc;\n            buf[len] = '\\0';\n        }\n        if (max_size && (max_size == read_size)) {\n            crm_trace(\"Buffer max read size %d met\" , max_size);\n            goto done;\n        }\n        if (rc > 0) {\n            continue;\n        } else if (rc == 0) {\n            if (disconnected) {\n                *disconnected = 1;\n            }\n            crm_trace(\"EOF encoutered during read\");\n            goto done;\n        }\n        if (errno == EINTR) {\n            crm_trace(\"EINTER encoutered, retry socket read.\");\n        } else if (errno == EAGAIN) {\n            crm_trace(\"non-blocking, exiting read on rc = %d\", rc);\n            goto done;\n        } else if (errno <= 0) {\n            if (disconnected) {\n                *disconnected = 1;\n            }\n            crm_debug(\"Error receiving message: %d\", (int)rc);\n            goto done;\n        }\n    }\ndone:\n    if (recv_len) {\n        *recv_len = len;\n    }\n    if (!len) {\n        free(buf);\n        buf = NULL;\n    }\n    return buf;\n}", "target": 0}
{"code": "build_ycc_rgb_table(j_decompress_ptr cinfo)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  int i;\n  JLONG x;\n  SHIFT_TEMPS\n  upsample->Cr_r_tab = (int *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(int));\n  upsample->Cb_b_tab = (int *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(int));\n  upsample->Cr_g_tab = (JLONG *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(JLONG));\n  upsample->Cb_g_tab = (JLONG *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(JLONG));\n  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {\n    upsample->Cr_r_tab[i] = (int)\n                    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);\n    upsample->Cb_b_tab[i] = (int)\n                    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);\n    upsample->Cr_g_tab[i] = (-FIX(0.71414)) * x;\n    upsample->Cb_g_tab[i] = (-FIX(0.34414)) * x + ONE_HALF;\n  }\n}", "target": 1}
{"code": "void ntlm_print_negotiate_flags(UINT32 flags)\n{\n\tint i;\n\tconst char* str;\n\tWLog_INFO(TAG, \"negotiateFlags \\\"0x%08\"PRIX32\"\\\"\", flags);\n\tfor (i = 31; i >= 0; i--)\n\t{\n\t\tif ((flags >> i) & 1)\n\t\t{\n\t\t\tstr = NTLM_NEGOTIATE_STRINGS[(31 - i)];\n\t\t\tWLog_INFO(TAG, \"\\t%s (%d),\", str, (31 - i));\n\t\t}\n\t}\n}", "target": 1}
{"code": "htc_request_check_host_hdr(struct http *hp)\n{\n\tint u;\n\tint seen_host = 0;\n\tfor (u = HTTP_HDR_FIRST; u < hp->nhd; u++) {\n\t\tif (hp->hd[u].b == NULL)\n\t\t\tcontinue;\n\t\tAN(hp->hd[u].b);\n\t\tAN(hp->hd[u].e);\n\t\tif (http_IsHdr(&hp->hd[u], H_Host)) {\n\t\t\tif (seen_host) {\n\t\t\t\treturn (400);\n\t\t\t}\n\t\t\tseen_host = 1;\n\t\t}\n\t}\n\treturn (0);\n}", "target": 1}
{"code": "static int rose_parse_ccitt(unsigned char *p, struct rose_facilities_struct *facilities, int len)\n{\n\tunsigned char l, n = 0;\n\tchar callsign[11];\n\tdo {\n\t\tswitch (*p & 0xC0) {\n\t\tcase 0x00:\n\t\t\tif (len < 2)\n\t\t\t\treturn -1;\n\t\t\tp   += 2;\n\t\t\tn   += 2;\n\t\t\tlen -= 2;\n\t\t\tbreak;\n\t\tcase 0x40:\n\t\t\tif (len < 3)\n\t\t\t\treturn -1;\n\t\t\tp   += 3;\n\t\t\tn   += 3;\n\t\t\tlen -= 3;\n\t\t\tbreak;\n\t\tcase 0x80:\n\t\t\tif (len < 4)\n\t\t\t\treturn -1;\n\t\t\tp   += 4;\n\t\t\tn   += 4;\n\t\t\tlen -= 4;\n\t\t\tbreak;\n\t\tcase 0xC0:\n\t\t\tif (len < 2)\n\t\t\t\treturn -1;\n\t\t\tl = p[1];\n\t\t\tif (l < 10 || l > 20)\n\t\t\t\treturn -1;\n\t\t\tif (*p == FAC_CCITT_DEST_NSAP) {\n\t\t\t\tmemcpy(&facilities->source_addr, p + 7, ROSE_ADDR_LEN);\n\t\t\t\tmemcpy(callsign, p + 12,   l - 10);\n\t\t\t\tcallsign[l - 10] = '\\0';\n\t\t\t\tasc2ax(&facilities->source_call, callsign);\n\t\t\t}\n\t\t\tif (*p == FAC_CCITT_SRC_NSAP) {\n\t\t\t\tmemcpy(&facilities->dest_addr, p + 7, ROSE_ADDR_LEN);\n\t\t\t\tmemcpy(callsign, p + 12, l - 10);\n\t\t\t\tcallsign[l - 10] = '\\0';\n\t\t\t\tasc2ax(&facilities->dest_call, callsign);\n\t\t\t}\n\t\t\tp   += l + 2;\n\t\t\tn   += l + 2;\n\t\t\tlen -= l + 2;\n\t\t\tbreak;\n\t\t}\n\t} while (*p != 0x00 && len > 0);\n\treturn n;\n}", "target": 0}
{"code": "xsltFreeKeyDef(xsltKeyDefPtr keyd) {\n    if (keyd == NULL)\n\treturn;\n    if (keyd->comp != NULL)\n\txmlXPathFreeCompExpr(keyd->comp);\n    if (keyd->usecomp != NULL)\n\txmlXPathFreeCompExpr(keyd->usecomp);\n    if (keyd->name != NULL)\n\txmlFree(keyd->name);\n    if (keyd->nameURI != NULL)\n\txmlFree(keyd->nameURI);\n    if (keyd->match != NULL)\n\txmlFree(keyd->match);\n    if (keyd->use != NULL)\n\txmlFree(keyd->use);\n    if (keyd->nsList != NULL)\n        xmlFree(keyd->nsList);\n    memset(keyd, -1, sizeof(xsltKeyDef));\n    xmlFree(keyd);\n}", "target": 0}
{"code": "static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC) \n{\n\tzend_hash_destroy(&pglobals->ht_rc);\n}", "target": 1}
{"code": "static int bad_format_check(const char *pattern, char *fmt) {\n    GError *gerr = NULL;\n    GRegex *re = g_regex_new(pattern, G_REGEX_EXTENDED, 0, &gerr);\n    GMatchInfo *mi;\n    if (gerr != NULL) {\n        rrd_set_error(\"cannot compile regular expression: %s (%s)\", gerr->message,pattern);\n        return 1;\n    }\n    int m = g_regex_match(re, fmt, 0, &mi);\n    g_match_info_free (mi);\n    g_regex_unref(re);\n    if (!m) {\n        rrd_set_error(\"invalid format string '%s' (should match '%s')\",fmt,pattern);\n        return 1;\n    }\n    return 0;\n}", "target": 0}
{"code": "void Context::onUpstreamConnectionClose(PeerType peer_type) {\n  if (wasm_->onUpstreamConnectionClose_) {\n    wasm_->onUpstreamConnectionClose_(this, id_, static_cast<uint32_t>(peer_type));\n  }\n}", "target": 1}
{"code": "static void check_registration_keywords(hook_user_register_check_t *hdata)\n{\n\tif (hdata->approved || !anope_flags_compat)\n\t{\n\t\treturn;\n\t}\n\tif (!strcasecmp(hdata->account, \"LIST\") || !strcasecmp(hdata->account, \"CLEAR\") || !strcasecmp(hdata->account, \"MODIFY\"))\n\t{\n\t\tcommand_fail(hdata->si, fault_badparams, \"The nick \\2%s\\2 is reserved and cannot be registered.\", hdata->account);\n\t\thdata->approved = 1;\n\t}\n}", "target": 0}
{"code": "static int may_create_in_sticky(struct dentry * const dir,\n\t\t\t\tstruct inode * const inode)\n{\n\tif ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) ||\n\t    (!sysctl_protected_regular && S_ISREG(inode->i_mode)) ||\n\t    likely(!(dir->d_inode->i_mode & S_ISVTX)) ||\n\t    uid_eq(inode->i_uid, dir->d_inode->i_uid) ||\n\t    uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn 0;\n\tif (likely(dir->d_inode->i_mode & 0002) ||\n\t    (dir->d_inode->i_mode & 0020 &&\n\t     ((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) ||\n\t      (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) {\n\t\tconst char *operation = S_ISFIFO(inode->i_mode) ?\n\t\t\t\t\t\"sticky_create_fifo\" :\n\t\t\t\t\t\"sticky_create_regular\";\n\t\taudit_log_path_denied(AUDIT_ANOM_CREAT, operation);\n\t\treturn -EACCES;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "option_env_fd_cb (const gchar *option_name,\n                  const gchar *value,\n                  gpointer     data,\n                  GError     **error)\n{\n  FlatpakContext *context = data;\n  g_autoptr(GBytes) env_block = NULL;\n  gsize remaining;\n  const char *p;\n  guint64 fd;\n  gchar *endptr;\n  fd = g_ascii_strtoull (value, &endptr, 10);\n  if (endptr == NULL || *endptr != '\\0' || fd > G_MAXINT)\n    return glnx_throw (error, \"Not a valid file descriptor: %s\", value);\n  env_block = glnx_fd_readall_bytes ((int) fd, NULL, error);\n  if (env_block == NULL)\n    return FALSE;\n  p = g_bytes_get_data (env_block, &remaining);\n  while (remaining > 0)\n    {\n      size_t len = strnlen (p, remaining);\n      const char *equals;\n      g_assert (len <= remaining);\n      equals = memchr (p, '=', len);\n      if (equals == NULL || equals == p)\n        return glnx_throw (error,\n                           \"Environment variable must be given in the form VARIABLE=VALUE, not %.*s\", (int) len, p);\n      flatpak_context_set_env_var (context,\n                                   g_strndup (p, equals - p),\n                                   g_strndup (equals + 1, len - (equals - p) - 1));\n      p += len;\n      remaining -= len;\n      if (remaining > 0)\n        {\n          g_assert (*p == '\\0');\n          p += 1;\n          remaining -= 1;\n        }\n    }\n  if (fd >= 3)\n    close (fd);\n  return TRUE;\n}", "target": 0}
{"code": "int blkcg_init_queue(struct request_queue *q)\n{\n\tstruct blkcg_gq *new_blkg, *blkg;\n\tbool preloaded;\n\tint ret;\n\tnew_blkg = blkg_alloc(&blkcg_root, q, GFP_KERNEL);\n\tif (!new_blkg)\n\t\treturn -ENOMEM;\n\tpreloaded = !radix_tree_preload(GFP_KERNEL);\n\trcu_read_lock();\n\tspin_lock_irq(q->queue_lock);\n\tblkg = blkg_create(&blkcg_root, q, new_blkg);\n\tspin_unlock_irq(q->queue_lock);\n\trcu_read_unlock();\n\tif (preloaded)\n\t\tradix_tree_preload_end();\n\tif (IS_ERR(blkg)) {\n\t\tblkg_free(new_blkg);\n\t\treturn PTR_ERR(blkg);\n\t}\n\tq->root_blkg = blkg;\n\tq->root_rl.blkg = blkg;\n\tret = blk_throtl_init(q);\n\tif (ret) {\n\t\tspin_lock_irq(q->queue_lock);\n\t\tblkg_destroy_all(q);\n\t\tspin_unlock_irq(q->queue_lock);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "const char * util_acl_to_str(const sc_acl_entry_t *e)\n{\n\tstatic char line[80], buf[20];\n\tunsigned int acl;\n\tif (e == NULL)\n\t\treturn \"N/A\";\n\tline[0] = 0;\n\twhile (e != NULL) {\n\t\tacl = e->method;\n\t\tswitch (acl) {\n\t\tcase SC_AC_UNKNOWN:\n\t\t\treturn \"N/A\";\n\t\tcase SC_AC_NEVER:\n\t\t\treturn \"NEVR\";\n\t\tcase SC_AC_NONE:\n\t\t\treturn \"NONE\";\n\t\tcase SC_AC_CHV:\n\t\t\tstrcpy(buf, \"CHV\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_TERM:\n\t\t\tstrcpy(buf, \"TERM\");\n\t\t\tbreak;\n\t\tcase SC_AC_PRO:\n\t\t\tstrcpy(buf, \"PROT\");\n\t\t\tbreak;\n\t\tcase SC_AC_AUT:\n\t\t\tstrcpy(buf, \"AUTH\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 4, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SEN:\n\t\t\tstrcpy(buf, \"Sec.Env. \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SCB:\n\t\t\tstrcpy(buf, \"Sec.ControlByte \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"Ox%X\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_IDA:\n\t\t\tstrcpy(buf, \"PKCS#15 AuthID \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstrcpy(buf, \"????\");\n\t\t\tbreak;\n\t\t}\n\t\tstrncat(line, buf, sizeof line);\n\t\tstrncat(line, \" \", sizeof line);\n\t\te = e->next;\n\t}\n\tline[(sizeof line)-1] = '\\0'; \n\tline[strlen(line)-1] = 0; \n\treturn line;\n}", "target": 0}
{"code": "static void free_sched_groups(struct sched_group *sg, int free_sgc)\n{\n\tstruct sched_group *tmp, *first;\n\tif (!sg)\n\t\treturn;\n\tfirst = sg;\n\tdo {\n\t\ttmp = sg->next;\n\t\tif (free_sgc && atomic_dec_and_test(&sg->sgc->ref))\n\t\t\tkfree(sg->sgc);\n\t\tkfree(sg);\n\t\tsg = tmp;\n\t} while (sg != first);\n}", "target": 0}
{"code": "static inline u32 net_hash_mix(const struct net *net)\n{\n#ifdef CONFIG_NET_NS\n\treturn (u32)(((unsigned long)net) >> ilog2(sizeof(*net)));\n#else\n\treturn 0;\n#endif\n}", "target": 1}
{"code": "void kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr)\n{\n\tvcpu->arch.apic->vapic_addr = vapic_addr;\n\tif (vapic_addr)\n\t\t__set_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\telse\n\t\t__clear_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n}", "target": 1}
{"code": "njs_vmcode_typeof(njs_vm_t *vm, njs_value_t *value, njs_value_t *invld)\n{\n    static const njs_value_t  *types[NJS_VALUE_TYPE_MAX] = {\n        &njs_string_object,\n        &njs_string_undefined,\n        &njs_string_boolean,\n        &njs_string_number,\n        &njs_string_symbol,\n        &njs_string_string,\n        &njs_string_data,\n        &njs_string_external,\n        &njs_string_invalid,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_function,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n    };\n    vm->retval = *types[value->type];\n    return sizeof(njs_vmcode_2addr_t);\n}", "target": 0}
{"code": "void SecurityManager::resend_handshake_message_token(\n        const GUID_t& remote_participant_key) const\n{\n    auto sentry = is_security_manager_initialized();\n    if (!sentry)\n    {\n        return;\n    }\n    shared_lock<shared_mutex> _(mutex_);\n    auto dp_it = discovered_participants_.find(remote_participant_key);\n    if (dp_it != discovered_participants_.end())\n    {\n        SecurityManager::DiscoveredParticipantInfo::AuthUniquePtr remote_participant_info = dp_it->second->get_auth();\n        if (remote_participant_info)\n        {\n            if (remote_participant_info->change_sequence_number_ != SequenceNumber_t::unknown())\n            {\n                CacheChange_t* p_change = participant_stateless_message_writer_history_->remove_change_and_reuse(\n                    remote_participant_info->change_sequence_number_);\n                remote_participant_info->change_sequence_number_ = SequenceNumber_t::unknown();\n                if (p_change != nullptr)\n                {\n                    EPROSIMA_LOG_INFO(SECURITY, \"Authentication handshake resent to participant \" <<\n                            remote_participant_key);\n                    if (participant_stateless_message_writer_history_->add_change(p_change))\n                    {\n                        remote_participant_info->change_sequence_number_ = p_change->sequenceNumber;\n                    }\n                }\n            }\n            dp_it->second->set_auth(remote_participant_info);\n        }\n    }\n}", "target": 1}
{"code": "void CarbonProtocolReader::skip(const FieldType ft) {\n  switch (ft) {\n    case FieldType::True:\n    case FieldType::False: {\n      break;\n    }\n    case FieldType::Int8: {\n      readRaw<int8_t>();\n      break;\n    }\n    case FieldType::Int16: {\n      readRaw<int16_t>();\n      break;\n    }\n    case FieldType::Int32: {\n      readRaw<int32_t>();\n      break;\n    }\n    case FieldType::Int64: {\n      readRaw<int64_t>();\n      break;\n    }\n    case FieldType::Double: {\n      readRaw<double>();\n      break;\n    }\n    case FieldType::Float: {\n      readRaw<float>();\n      break;\n    }\n    case FieldType::Binary: {\n      readRaw<std::string>();\n      break;\n    }\n    case FieldType::List: {\n      skipLinearContainer();\n      break;\n    }\n    case FieldType::Struct: {\n      readStructBegin();\n      while (true) {\n        const auto fieldType = readFieldHeader().first;\n        if (fieldType == FieldType::Stop) {\n          break;\n        }\n        skip(fieldType);\n      }\n      readStructEnd();\n      break;\n    }\n    case FieldType::Set: {\n      skipLinearContainer();\n      break;\n    }\n    case FieldType::Map: {\n      skipKVContainer();\n      break;\n    }\n    default: { break; }\n  }\n}", "target": 1}
{"code": "int nfc_deactivate_target(struct nfc_dev *dev, u32 target_idx, u8 mode)\n{\n\tint rc = 0;\n\tpr_debug(\"dev_name=%s target_idx=%u\\n\",\n\t\t dev_name(&dev->dev), target_idx);\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->active_target == NULL) {\n\t\trc = -ENOTCONN;\n\t\tgoto error;\n\t}\n\tif (dev->active_target->idx != target_idx) {\n\t\trc = -ENOTCONN;\n\t\tgoto error;\n\t}\n\tif (dev->ops->check_presence)\n\t\tdel_timer_sync(&dev->check_pres_timer);\n\tdev->ops->deactivate_target(dev, dev->active_target, mode);\n\tdev->active_target = NULL;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "static int do_sched_cfs_period_timer(struct cfs_bandwidth *cfs_b, int overrun, unsigned long flags)\n{\n\tu64 runtime, runtime_expires;\n\tint throttled;\n\tif (cfs_b->quota == RUNTIME_INF)\n\t\tgoto out_deactivate;\n\tthrottled = !list_empty(&cfs_b->throttled_cfs_rq);\n\tcfs_b->nr_periods += overrun;\n\tif (cfs_b->idle && !throttled)\n\t\tgoto out_deactivate;\n\t__refill_cfs_bandwidth_runtime(cfs_b);\n\tif (!throttled) {\n\t\tcfs_b->idle = 1;\n\t\treturn 0;\n\t}\n\tcfs_b->nr_throttled += overrun;\n\truntime_expires = cfs_b->runtime_expires;\n\twhile (throttled && cfs_b->runtime > 0 && !cfs_b->distribute_running) {\n\t\truntime = cfs_b->runtime;\n\t\tcfs_b->distribute_running = 1;\n\t\traw_spin_unlock_irqrestore(&cfs_b->lock, flags);\n\t\truntime = distribute_cfs_runtime(cfs_b, runtime,\n\t\t\t\t\t\t runtime_expires);\n\t\traw_spin_lock_irqsave(&cfs_b->lock, flags);\n\t\tcfs_b->distribute_running = 0;\n\t\tthrottled = !list_empty(&cfs_b->throttled_cfs_rq);\n\t\tlsub_positive(&cfs_b->runtime, runtime);\n\t}\n\tcfs_b->idle = 0;\n\treturn 0;\nout_deactivate:\n\treturn 1;\n}", "target": 1}
{"code": "NOEXPORT void print_tmp_key(SSL *s) {\n    EVP_PKEY *key;\n    if (!SSL_get_peer_tmp_key(s, &key)) {\n        sslerror(\"SSL_get_peer_tmp_key\");\n        return;\n    }\n    switch (EVP_PKEY_id(key)) {\n    case EVP_PKEY_RSA:\n        s_log(LOG_INFO, \"Peer temporary key: RSA, %d bits\", EVP_PKEY_bits(key));\n        break;\n    case EVP_PKEY_DH:\n        s_log(LOG_INFO, \"Peer temporary key: DH, %d bits\", EVP_PKEY_bits(key));\n        break;\n#ifndef OPENSSL_NO_EC\n    case EVP_PKEY_EC:\n        {\n            EC_KEY *ec=EVP_PKEY_get1_EC_KEY(key);\n            int nid=EC_GROUP_get_curve_name(EC_KEY_get0_group(ec));\n            const char *cname=EC_curve_nid2nist(nid);\n            EC_KEY_free(ec);\n            if (cname == NULL)\n                cname=OBJ_nid2sn(nid);\n            s_log(LOG_INFO, \"Peer temporary key: ECDH, %s, %d bits\", cname, EVP_PKEY_bits(key));\n        }\n        break;\n#endif\n    default:\n        s_log(LOG_INFO, \"Peer temporary key: %s, %d bits\", OBJ_nid2sn(EVP_PKEY_id(key)),\n                   EVP_PKEY_bits(key));\n    }\n    EVP_PKEY_free(key);\n}", "target": 0}
{"code": "static unsigned int stack_maxrandom_size(void)\n{\n\tunsigned int max = 0;\n\tif ((current->flags & PF_RANDOMIZE) &&\n\t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n\t\tmax = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;\n\t}\n\treturn max;\n}", "target": 1}
{"code": "static int smm_place_entry_code(uintptr_t smbase, unsigned int num_cpus,\n\t\t\t\tunsigned int stack_top, const struct smm_loader_params *params)\n{\n\tunsigned int i;\n\tunsigned int size;\n\tif (smm_create_map(smbase, num_cpus, params)) {\n\t\tif (cpus[num_cpus].active) {\n\t\t\tif (cpus[num_cpus - 1].smbase +\n\t\t\t\tparams->smm_main_entry_offset < stack_top) {\n\t\t\t\tprintk(BIOS_ERR, \"%s: stack encroachment\\n\", __func__);\n\t\t\t\tprintk(BIOS_ERR, \"%s: smbase %zx, stack_top %x\\n\",\n\t\t\t\t\t__func__, cpus[num_cpus].smbase, stack_top);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tprintk(BIOS_ERR, \"%s: unable to place smm entry code\\n\", __func__);\n\t\treturn 0;\n\t}\n\tprintk(BIOS_INFO, \"%s: smbase %zx, stack_top %x\\n\",\n\t\t__func__, cpus[num_cpus-1].smbase, stack_top);\n\tsize = cpus[0].code_end - cpus[0].code_start;\n\tfor (i = 1; i < num_cpus; i++) {\n\t\tmemcpy((int *)cpus[i].code_start, (int *)cpus[0].code_start, size);\n\t\tprintk(BIOS_DEBUG,\n\t\t\t\"SMM Module: placing smm entry code at %zx,  cpu # 0x%x\\n\",\n\t\t\tcpus[i].code_start, i);\n\t\tprintk(BIOS_DEBUG, \"%s: copying from %zx to %zx 0x%x bytes\\n\",\n\t\t\t__func__, cpus[0].code_start, cpus[i].code_start, size);\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "static inline int init_new_context(struct task_struct *tsk,\n\t\t\t\t   struct mm_struct *mm)\n{\n\tcpumask_clear(&mm->context.cpu_attach_mask);\n\tatomic_set(&mm->context.attach_count, 0);\n\tmm->context.flush_mm = 0;\n\tmm->context.asce_bits = _ASCE_TABLE_LENGTH | _ASCE_USER_BITS;\n\tmm->context.asce_bits |= _ASCE_TYPE_REGION3;\n#ifdef CONFIG_PGSTE\n\tmm->context.alloc_pgste = page_table_allocate_pgste;\n\tmm->context.has_pgste = 0;\n\tmm->context.use_skey = 0;\n#endif\n\tmm->context.asce_limit = STACK_TOP_MAX;\n\tcrst_table_init((unsigned long *) mm->pgd, pgd_entry_type(mm));\n\treturn 0;\n}", "target": 1}
{"code": "infra_create(struct config_file* cfg)\n{\n\tstruct infra_cache* infra = (struct infra_cache*)calloc(1, \n\t\tsizeof(struct infra_cache));\n\tsize_t maxmem = cfg->infra_cache_numhosts * (sizeof(struct infra_key)+\n\t\tsizeof(struct infra_data)+INFRA_BYTES_NAME);\n\tif(!infra) {\n\t\treturn NULL;\n\t}\n\tinfra->hosts = slabhash_create(cfg->infra_cache_slabs,\n\t\tINFRA_HOST_STARTSIZE, maxmem, &infra_sizefunc, &infra_compfunc,\n\t\t&infra_delkeyfunc, &infra_deldatafunc, NULL);\n\tif(!infra->hosts) {\n\t\tfree(infra);\n\t\treturn NULL;\n\t}\n\tinfra->host_ttl = cfg->host_ttl;\n\tinfra->infra_keep_probing = cfg->infra_keep_probing;\n\tinfra_dp_ratelimit = cfg->ratelimit;\n\tinfra->domain_rates = slabhash_create(cfg->ratelimit_slabs,\n\t\tINFRA_HOST_STARTSIZE, cfg->ratelimit_size,\n\t\t&rate_sizefunc, &rate_compfunc, &rate_delkeyfunc,\n\t\t&rate_deldatafunc, NULL);\n\tif(!infra->domain_rates) {\n\t\tinfra_delete(infra);\n\t\treturn NULL;\n\t}\n\tif(!setup_domain_limits(infra, cfg)) {\n\t\tinfra_delete(infra);\n\t\treturn NULL;\n\t}\n\tif(!setup_wait_limits(infra, cfg)) {\n\t\tinfra_delete(infra);\n\t\treturn NULL;\n\t}\n\tinfra_ip_ratelimit = cfg->ip_ratelimit;\n\tinfra->client_ip_rates = slabhash_create(cfg->ip_ratelimit_slabs,\n\t    INFRA_HOST_STARTSIZE, cfg->ip_ratelimit_size, &ip_rate_sizefunc,\n\t    &ip_rate_compfunc, &ip_rate_delkeyfunc, &ip_rate_deldatafunc, NULL);\n\tif(!infra->client_ip_rates) {\n\t\tinfra_delete(infra);\n\t\treturn NULL;\n\t}\n\treturn infra;\n}", "target": 0}
{"code": "static bool malidp_check_pages_threshold(struct malidp_plane_state *ms,\n\t\t\t\t\t u32 pgsize)\n{\n\tint i;\n\tfor (i = 0; i < ms->n_planes; i++) {\n\t\tstruct drm_gem_object *obj;\n\t\tstruct drm_gem_cma_object *cma_obj;\n\t\tstruct sg_table *sgt;\n\t\tstruct scatterlist *sgl;\n\t\tobj = drm_gem_fb_get_obj(ms->base.fb, i);\n\t\tcma_obj = to_drm_gem_cma_obj(obj);\n\t\tif (cma_obj->sgt)\n\t\t\tsgt = cma_obj->sgt;\n\t\telse\n\t\t\tsgt = obj->funcs->get_sg_table(obj);\n\t\tif (!sgt)\n\t\t\treturn false;\n\t\tsgl = sgt->sgl;\n\t\twhile (sgl) {\n\t\t\tif (sgl->length < pgsize) {\n\t\t\t\tif (!cma_obj->sgt)\n\t\t\t\t\tkfree(sgt);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tsgl = sg_next(sgl);\n\t\t}\n\t\tif (!cma_obj->sgt)\n\t\t\tkfree(sgt);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static void labeljumps(JF, js_JumpList *jump, int baddr, int caddr)\n{\n\twhile (jump) {\n\t\tif (jump->type == STM_BREAK)\n\t\t\tlabelto(J, F, jump->inst, baddr);\n\t\tif (jump->type == STM_CONTINUE)\n\t\t\tlabelto(J, F, jump->inst, caddr);\n\t\tjump = jump->next;\n\t}\n}", "target": 1}
{"code": "void ping_unhash(struct sock *sk)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tpr_debug(\"ping_unhash(isk=%p,isk->num=%u)\\n\", isk, isk->inet_num);\n\tif (sk_hashed(sk)) {\n\t\twrite_lock_bh(&ping_table.lock);\n\t\thlist_nulls_del(&sk->sk_nulls_node);\n\t\tsk_nulls_node_init(&sk->sk_nulls_node);\n\t\tsock_put(sk);\n\t\tisk->inet_num = 0;\n\t\tisk->inet_sport = 0;\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\t\twrite_unlock_bh(&ping_table.lock);\n\t}\n}", "target": 0}
{"code": "int jas_stream_read(jas_stream_t *stream, void *buf, int cnt)\n{\n\tint n;\n\tint c;\n\tchar *bufptr;\n\tif (cnt < 0) {\n\t\tjas_deprecated(\"negative count for jas_stream_read\");\n\t}\n\tbufptr = buf;\n\tn = 0;\n\twhile (n < cnt) {\n\t\tif ((c = jas_stream_getc(stream)) == EOF) {\n\t\t\treturn n;\n\t\t}\n\t\t*bufptr++ = c;\n\t\t++n;\n\t}\n\treturn n;\n}", "target": 0}
{"code": "SkBitmap Clipboard::ReadImage(Buffer buffer) const {\n  ScopedGObject<GdkPixbuf>::Type pixbuf(\n      gtk_clipboard_wait_for_image(clipboard_));\n  if (!pixbuf.get())\n    return SkBitmap();\n  gfx::CanvasSkia canvas(gdk_pixbuf_get_width(pixbuf.get()),\n                         gdk_pixbuf_get_height(pixbuf.get()),\n                         false);\n  {\n    skia::ScopedPlatformPaint scoped_platform_paint(canvas.sk_canvas());\n    cairo_t* context = scoped_platform_paint.GetPlatformSurface();\n    gdk_cairo_set_source_pixbuf(context, pixbuf.get(), 0.0, 0.0);\n    cairo_paint(context);\n  }\n  return canvas.ExtractBitmap();\n}", "target": 0}
{"code": "static int mwifiex_update_vs_ie(const u8 *ies, int ies_len,\n\t\t\t\tstruct mwifiex_ie **ie_ptr, u16 mask,\n\t\t\t\tunsigned int oui, u8 oui_type)\n{\n\tstruct ieee_types_header *vs_ie;\n\tstruct mwifiex_ie *ie = *ie_ptr;\n\tconst u8 *vendor_ie;\n\tvendor_ie = cfg80211_find_vendor_ie(oui, oui_type, ies, ies_len);\n\tif (vendor_ie) {\n\t\tif (!*ie_ptr) {\n\t\t\t*ie_ptr = kzalloc(sizeof(struct mwifiex_ie),\n\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!*ie_ptr)\n\t\t\t\treturn -ENOMEM;\n\t\t\tie = *ie_ptr;\n\t\t}\n\t\tvs_ie = (struct ieee_types_header *)vendor_ie;\n\t\tif (le16_to_cpu(ie->ie_length) + vs_ie->len + 2 >\n\t\t\tIEEE_MAX_IE_SIZE)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(ie->ie_buffer + le16_to_cpu(ie->ie_length),\n\t\t       vs_ie, vs_ie->len + 2);\n\t\tle16_unaligned_add_cpu(&ie->ie_length, vs_ie->len + 2);\n\t\tie->mgmt_subtype_mask = cpu_to_le16(mask);\n\t\tie->ie_index = cpu_to_le16(MWIFIEX_AUTO_IDX_MASK);\n\t}\n\t*ie_ptr = ie;\n\treturn 0;\n}", "target": 0}
{"code": "int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,\n                            size_t size)\n{\n    GetBitContext gb;\n    AC3HeaderInfo *hdr;\n    int err;\n    if (!*phdr)\n        *phdr = av_mallocz(sizeof(AC3HeaderInfo));\n    if (!*phdr)\n        return AVERROR(ENOMEM);\n    hdr = *phdr;\n    init_get_bits8(&gb, buf, size);\n    err = ff_ac3_parse_header(&gb, hdr);\n    if (err < 0)\n        return AVERROR_INVALIDDATA;\n    return get_bits_count(&gb);\n}", "target": 1}
{"code": "int scsi_cmd_blk_ioctl(struct block_device *bd, fmode_t mode,\n\t\t       unsigned int cmd, void __user *arg)\n{\n\tint ret;\n\tret = scsi_verify_blk_ioctl(bd, cmd);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn scsi_cmd_ioctl(bd->bd_disk->queue, bd->bd_disk, mode, cmd, arg);\n}", "target": 0}
{"code": "static VncBasicInfoList *qmp_query_server_entry(int socket,\n                                                bool websocket,\n                                                VncBasicInfoList *prev)\n{\n    VncBasicInfoList *list;\n    VncBasicInfo *info;\n    struct sockaddr_storage sa;\n    socklen_t salen = sizeof(sa);\n    char host[NI_MAXHOST];\n    char serv[NI_MAXSERV];\n    if (getsockname(socket, (struct sockaddr *)&sa, &salen) < 0 ||\n        getnameinfo((struct sockaddr *)&sa, salen,\n                    host, sizeof(host), serv, sizeof(serv),\n                    NI_NUMERICHOST | NI_NUMERICSERV) < 0) {\n        return prev;\n    }\n    info = g_new0(VncBasicInfo, 1);\n    info->host = g_strdup(host);\n    info->service = g_strdup(serv);\n    info->family = inet_netfamily(sa.ss_family);\n    info->websocket = websocket;\n    list = g_new0(VncBasicInfoList, 1);\n    list->value = info;\n    list->next = prev;\n    return list;\n}", "target": 0}
{"code": "sysName_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_string(varbind, oid, \"Contiki-NG - \"CONTIKI_TARGET_STRING);\n}", "target": 1}
{"code": "static ssize_t intel_iommu_show_ndoms(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tstruct intel_iommu *iommu = dev_to_intel_iommu(dev);\n\treturn sprintf(buf, \"%ld\\n\", cap_ndoms(iommu->cap));\n}", "target": 0}
{"code": "static void cleanup_shm_refs(const uint64_t *saved_attr,\n\t\t\t     struct tee_ta_param *param, uint32_t num_params)\n{\n\tsize_t n;\n\tfor (n = 0; n < num_params; n++) {\n\t\tswitch (saved_attr[n]) {\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_TMEM_INOUT:\n#ifdef CFG_CORE_DYN_SHM\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_INPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_OUTPUT:\n\t\tcase OPTEE_MSG_ATTR_TYPE_RMEM_INOUT:\n#endif\n\t\t\tmobj_put(param->u[n].mem.mobj);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}", "target": 1}
{"code": "void PackLinuxElf32::updateLoader(OutputFile * )\n{\n    unsigned start = linker->getSymbolOffset(\"_start\");\n    unsigned vbase = get_te32(&elfout.phdr[0].p_vaddr);\n    set_te32(&elfout.ehdr.e_entry, start + sz_pack2 + vbase);\n}", "target": 0}
{"code": "static int bit_tohex(lua_State *L)\n{\n  UBits b = barg(L, 1);\n  SBits n = lua_isnone(L, 2) ? 8 : (SBits)barg(L, 2);\n  const char *hexdigits = \"0123456789abcdef\";\n  char buf[8];\n  int i;\n  if (n == INT32_MIN) n = INT32_MIN+1;\n  if (n < 0) { n = -n; hexdigits = \"0123456789ABCDEF\"; }\n  if (n > 8) n = 8;\n  for (i = (int)n; --i >= 0; ) { buf[i] = hexdigits[b & 15]; b >>= 4; }\n  lua_pushlstring(L, buf, (size_t)n);\n  return 1;\n}", "target": 0}
{"code": "static int create_mr(PVRDMADev *dev, union pvrdma_cmd_req *req,\n                     union pvrdma_cmd_resp *rsp)\n{\n    struct pvrdma_cmd_create_mr *cmd = &req->create_mr;\n    struct pvrdma_cmd_create_mr_resp *resp = &rsp->create_mr_resp;\n    PCIDevice *pci_dev = PCI_DEVICE(dev);\n    void *host_virt = NULL;\n    int rc = 0;\n    memset(resp, 0, sizeof(*resp));\n    if (!(cmd->flags & PVRDMA_MR_FLAG_DMA)) {\n        host_virt = pvrdma_map_to_pdir(pci_dev, cmd->pdir_dma, cmd->nchunks,\n                                       cmd->length);\n        if (!host_virt) {\n            rdma_error_report(\"Failed to map to pdir\");\n            return -EINVAL;\n        }\n    }\n    rc = rdma_rm_alloc_mr(&dev->rdma_dev_res, cmd->pd_handle, cmd->start,\n                          cmd->length, host_virt, cmd->access_flags,\n                          &resp->mr_handle, &resp->lkey, &resp->rkey);\n    if (rc && host_virt) {\n        munmap(host_virt, cmd->length);\n    }\n    return rc;\n}", "target": 0}
{"code": "void my_error_exit( j_common_ptr cinfo ) {\n   my_error_ptr myerr = reinterpret_cast<my_error_ptr>(cinfo->err);\n   longjmp( myerr->setjmp_buffer, 1 );\n}", "target": 1}
{"code": "static int dr_domain_init_resources(struct mlx5dr_domain *dmn)\n{\n\tint ret;\n\tdmn->ste_ctx = mlx5dr_ste_get_ctx(dmn->info.caps.sw_format_ver);\n\tif (!dmn->ste_ctx) {\n\t\tmlx5dr_err(dmn, \"SW Steering on this device is unsupported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tret = mlx5_core_alloc_pd(dmn->mdev, &dmn->pdn);\n\tif (ret) {\n\t\tmlx5dr_err(dmn, \"Couldn't allocate PD, ret: %d\", ret);\n\t\treturn ret;\n\t}\n\tdmn->uar = mlx5_get_uars_page(dmn->mdev);\n\tif (!dmn->uar) {\n\t\tmlx5dr_err(dmn, \"Couldn't allocate UAR\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto clean_pd;\n\t}\n\tdmn->ste_icm_pool = mlx5dr_icm_pool_create(dmn, DR_ICM_TYPE_STE);\n\tif (!dmn->ste_icm_pool) {\n\t\tmlx5dr_err(dmn, \"Couldn't get icm memory\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto clean_uar;\n\t}\n\tdmn->action_icm_pool = mlx5dr_icm_pool_create(dmn, DR_ICM_TYPE_MODIFY_ACTION);\n\tif (!dmn->action_icm_pool) {\n\t\tmlx5dr_err(dmn, \"Couldn't get action icm memory\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto free_ste_icm_pool;\n\t}\n\tret = mlx5dr_send_ring_alloc(dmn);\n\tif (ret) {\n\t\tmlx5dr_err(dmn, \"Couldn't create send-ring\\n\");\n\t\tgoto free_action_icm_pool;\n\t}\n\treturn 0;\nfree_action_icm_pool:\n\tmlx5dr_icm_pool_destroy(dmn->action_icm_pool);\nfree_ste_icm_pool:\n\tmlx5dr_icm_pool_destroy(dmn->ste_icm_pool);\nclean_uar:\n\tmlx5_put_uars_page(dmn->mdev, dmn->uar);\nclean_pd:\n\tmlx5_core_dealloc_pd(dmn->mdev, dmn->pdn);\n\treturn ret;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& handle = ctx->input(0);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(handle.shape()),\n                errors::InvalidArgument(\"handle must be scalar\"));\n    const string& name = handle.scalar<tstring>()();\n    Tensor val;\n    auto session_state = ctx->session_state();\n    OP_REQUIRES(ctx, session_state != nullptr,\n                errors::FailedPrecondition(\n                    \"GetSessionTensor called on null session state\"));\n    OP_REQUIRES_OK(ctx, session_state->GetTensor(name, &val));\n    ctx->set_output(0, val);\n  }", "target": 0}
{"code": "debug_print_range(const char *msg,\n    int lineno,\n    void *start, signed long len,\n    void *end)\n{\n    char *st = (char *)start;\n    char *en = (char *)end;\n    signed long le = len;\n    if (len) {\n        if (en) {\n            le = (long)(en-st);\n        } else {\n            en= start+len;\n        }\n    } else if (en) {\n        le = (long)(en-st);\n    }\n    printf(\"RANGEdebug %s  st=0x%lx le=%ld en=0x%lx line %d\\n\",\n        msg,(unsigned long)st,le,(unsigned long)en,lineno);\n}", "target": 0}
{"code": "static inline int init_new_context(struct task_struct *tsk,\n\t\t\t\t   struct mm_struct *mm)\n{\n\t#ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS\n\tif (cpu_feature_enabled(X86_FEATURE_OSPKE)) {\n\t\tmm->context.pkey_allocation_map = 0x1;\n\t\tmm->context.execute_only_pkey = -1;\n\t}\n\t#endif\n\tinit_new_context_ldt(tsk, mm);\n\treturn 0;\n}", "target": 1}
{"code": "static void scsi_free_request(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    qemu_vfree(r->iov.iov_base);\n}", "target": 1}
{"code": "static struct fsnotify_group *inotify_new_group(struct user_struct *user, unsigned int max_events)\n{\n\tstruct fsnotify_group *group;\n\tgroup = fsnotify_alloc_group(&inotify_fsnotify_ops);\n\tif (IS_ERR(group))\n\t\treturn group;\n\tgroup->max_events = max_events;\n\tspin_lock_init(&group->inotify_data.idr_lock);\n\tidr_init(&group->inotify_data.idr);\n\tgroup->inotify_data.last_wd = 0;\n\tgroup->inotify_data.user = user;\n\tgroup->inotify_data.fa = NULL;\n\treturn group;\n}", "target": 1}
{"code": "int options_parse(CONF_TYPE type) {\n    SERVICE_OPTIONS *section;\n    options_defaults();\n    section=&new_service_options;\n    if(options_file(configuration_file, type, &section))\n        return 1;\n    if(init_section(1, &section))\n        return 1;\n    s_log(LOG_NOTICE, \"Configuration successful\");\n    return 0;\n}", "target": 1}
{"code": "ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)\n{\n    unsigned nSyms = darray_size(expr->keysym_list.syms);\n    unsigned numEntries = darray_size(append->keysym_list.syms);\n    darray_append(expr->keysym_list.symsMapIndex, nSyms);\n    darray_append(expr->keysym_list.symsNumEntries, numEntries);\n    darray_concat(expr->keysym_list.syms, append->keysym_list.syms);\n    FreeStmt((ParseCommon *) &append);\n    return expr;\n}", "target": 1}
{"code": "  bool verify_authorizer(Connection *con, int peer_type, int protocol, bufferlist& auth, bufferlist& auth_reply,\n                         bool& isvalid, CryptoKey& session_key) {\n    return ms_deliver_verify_authorizer(con, peer_type, protocol, auth,\n                                        auth_reply, isvalid, session_key);\n  }", "target": 1}
{"code": "GF_Err stbl_AppendTime(GF_SampleTableBox *stbl, u32 duration, u32 nb_pack)\n{\n\tGF_TimeToSampleBox *stts = stbl->TimeToSample;\n\tif (!nb_pack) nb_pack = 1;\n\tif (stts->nb_entries) {\n\t\tif (stts->entries[stts->nb_entries-1].sampleDelta == duration) {\n\t\t\tstts->entries[stts->nb_entries-1].sampleCount += nb_pack;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\tif (stts->nb_entries==stts->alloc_size) {\n\t\tALLOC_INC(stts->alloc_size);\n\t\tstts->entries = gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size);\n\t\tif (!stts->entries) return GF_OUT_OF_MEM;\n\t\tmemset(&stts->entries[stts->nb_entries], 0, sizeof(GF_SttsEntry)*(stts->alloc_size-stts->nb_entries) );\n\t}\n\tstts->entries[stts->nb_entries].sampleCount = nb_pack;\n\tstts->entries[stts->nb_entries].sampleDelta = duration;\n\tstts->nb_entries++;\n\tif (stts->max_ts_delta < duration ) stts->max_ts_delta = duration;\n\treturn GF_OK;\n}", "target": 1}
{"code": "TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,\n\t\t\t\t       uint32_t flags, uaddr_t uaddr,\n\t\t\t\t       size_t len)\n{\n\tuaddr_t a;\n\tsize_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,\n\t\t\t       CORE_MMU_USER_PARAM_SIZE);\n\tif (ADD_OVERFLOW(uaddr, len, &a))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t    (flags & TEE_MEMORY_ACCESS_SECURE))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\tif (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) &&\n\t   !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\tfor (a = uaddr; a < (uaddr + len); a += addr_incr) {\n\t\tuint32_t attr;\n\t\tTEE_Result res;\n\t\tres = tee_mmu_user_va2pa_attr(utc, (void *)a, NULL, &attr);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t\t    (attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_SECURE) &&\n\t\t    !(attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_WRITE) && !(attr & TEE_MATTR_UW))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t\tif ((flags & TEE_MEMORY_ACCESS_READ) && !(attr & TEE_MATTR_UR))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t}\n\treturn TEE_SUCCESS;\n}", "target": 1}
{"code": "struct xt_table_info *xt_alloc_table_info(unsigned int size)\n{\n\tstruct xt_table_info *info = NULL;\n\tsize_t sz = sizeof(*info) + size;\n\tif (sz < sizeof(*info))\n\t\treturn NULL;\n\tif ((SMP_ALIGN(size) >> PAGE_SHIFT) + 2 > totalram_pages)\n\t\treturn NULL;\n\tif (sz <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER))\n\t\tinfo = kmalloc(sz, GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (!info) {\n\t\tinfo = vmalloc(sz);\n\t\tif (!info)\n\t\t\treturn NULL;\n\t}\n\tmemset(info, 0, sizeof(*info));\n\tinfo->size = size;\n\treturn info;\n}", "target": 0}
{"code": "static int usb_enumerate_device_otg(struct usb_device *udev)\n{\n\tint err = 0;\n#ifdef\tCONFIG_USB_OTG\n\tif (!udev->bus->is_b_host\n\t\t\t&& udev->config\n\t\t\t&& udev->parent == udev->bus->root_hub) {\n\t\tstruct usb_otg_descriptor\t*desc = NULL;\n\t\tstruct usb_bus\t\t\t*bus = udev->bus;\n\t\tunsigned\t\t\tport1 = udev->portnum;\n\t\terr = __usb_get_extra_descriptor(udev->rawdescriptors[0],\n\t\t\t\tle16_to_cpu(udev->config[0].desc.wTotalLength),\n\t\t\t\tUSB_DT_OTG, (void **) &desc);\n\t\tif (err || !(desc->bmAttributes & USB_OTG_HNP))\n\t\t\treturn 0;\n\t\tdev_info(&udev->dev, \"Dual-Role OTG device on %sHNP port\\n\",\n\t\t\t\t\t(port1 == bus->otg_port) ? \"\" : \"non-\");\n\t\tif (port1 == bus->otg_port) {\n\t\t\tbus->b_hnp_enable = 1;\n\t\t\terr = usb_control_msg(udev,\n\t\t\t\tusb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, 0,\n\t\t\t\tUSB_DEVICE_B_HNP_ENABLE,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t\tif (err < 0) {\n\t\t\t\tdev_err(&udev->dev, \"can't set HNP mode: %d\\n\",\n\t\t\t\t\t\t\t\t\terr);\n\t\t\t\tbus->b_hnp_enable = 0;\n\t\t\t}\n\t\t} else if (desc->bLength == sizeof\n\t\t\t\t(struct usb_otg_descriptor)) {\n\t\t\terr = usb_control_msg(udev,\n\t\t\t\tusb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, 0,\n\t\t\t\tUSB_DEVICE_A_ALT_HNP_SUPPORT,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t\tif (err < 0)\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"set a_alt_hnp_support failed: %d\\n\",\n\t\t\t\t\terr);\n\t\t}\n\t}\n#endif\n\treturn err;\n}", "target": 1}
{"code": "snmp_oid_cmp_oid(uint32_t *oid1, uint32_t *oid2)\n{\n  uint8_t i;\n  i = 0;\n  while(oid1[i] != ((uint32_t)-1) &&\n        oid2[i] != ((uint32_t)-1)) {\n    if(oid1[i] != oid2[i]) {\n      if(oid1[i] < oid2[i]) {\n        return -1;\n      }\n      return 1;\n    }\n    i++;\n  }\n  if(oid1[i] == ((uint32_t)-1) &&\n     oid2[i] != ((uint32_t)-1)) {\n    return -1;\n  }\n  if(oid1[i] != ((uint32_t)-1) &&\n     oid2[i] == ((uint32_t)-1)) {\n    return 1;\n  }\n  return 0;\n}", "target": 1}
{"code": "backref_match_at_nested_level(regex_t* reg,\n                              StackType* top, StackType* stk_base,\n                              int ignore_case, int case_fold_flag,\n                              int nest, int mem_num, MemNumType* memp,\n                              UChar** s, const UChar* send)\n{\n  UChar *ss, *p, *pstart, *pend = NULL_UCHARP;\n  int level;\n  StackType* k;\n  level = 0;\n  k = top;\n  k--;\n  while (k >= stk_base) {\n    if (k->type == STK_CALL_FRAME) {\n      level--;\n    }\n    else if (k->type == STK_RETURN) {\n      level++;\n    }\n    else if (level == nest) {\n      if (k->type == STK_MEM_START) {\n        if (mem_is_in_memp(k->zid, mem_num, memp)) {\n          pstart = k->u.mem.pstr;\n          if (IS_NOT_NULL(pend)) {\n            if (pend - pstart > send - *s) return 0; \n            p  = pstart;\n            ss = *s;\n            if (ignore_case != 0) {\n              if (string_cmp_ic(reg->enc, case_fold_flag,\n                                pstart, &ss, (int )(pend - pstart)) == 0)\n                return 0; \n            }\n            else {\n              while (p < pend) {\n                if (*p++ != *ss++) return 0; \n              }\n            }\n            *s = ss;\n            return 1;\n          }\n        }\n      }\n      else if (k->type == STK_MEM_END) {\n        if (mem_is_in_memp(k->zid, mem_num, memp)) {\n          pend = k->u.mem.pstr;\n        }\n      }\n    }\n    k--;\n  }\n  return 0;\n}", "target": 0}
{"code": "void _single_copy_to_wide( SQLWCHAR *out, LPCSTR in, int len )\n{\n    while ( len >= 0 )\n    {\n        *out = *in;\n        out++;\n        in++;\n        len --;\n    }\n}", "target": 0}
{"code": "TEE_Result syscall_hash_update(unsigned long state, const void *chunk,\n\t\t\tsize_t chunk_size)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tif (!chunk && chunk_size)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\tif (!chunk_size)\n\t\treturn TEE_SUCCESS;\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)chunk, chunk_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = crypto_hash_update(cs->ctx, cs->algo, chunk, chunk_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tres = crypto_mac_update(cs->ctx, cs->algo, chunk, chunk_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\treturn TEE_SUCCESS;\n}", "target": 0}
{"code": "kvm_irqfd(struct kvm *kvm, struct kvm_irqfd *args)\n{\n\tif (args->flags & ~(KVM_IRQFD_FLAG_DEASSIGN | KVM_IRQFD_FLAG_RESAMPLE))\n\t\treturn -EINVAL;\n\tif (args->gsi >= KVM_MAX_IRQ_ROUTES)\n\t\treturn -EINVAL;\n\tif (args->flags & KVM_IRQFD_FLAG_DEASSIGN)\n\t\treturn kvm_irqfd_deassign(kvm, args);\n\treturn kvm_irqfd_assign(kvm, args);\n}", "target": 0}
{"code": "void nf_tables_deactivate_set(const struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t      struct nft_set_binding *binding,\n\t\t\t      enum nft_trans_phase phase)\n{\n\tswitch (phase) {\n\tcase NFT_TRANS_PREPARE:\n\t\tif (nft_set_is_anonymous(set))\n\t\t\tnft_deactivate_next(ctx->net, set);\n\t\tset->use--;\n\t\treturn;\n\tcase NFT_TRANS_ABORT:\n\tcase NFT_TRANS_RELEASE:\n\t\tset->use--;\n\t\tfallthrough;\n\tdefault:\n\t\tnf_tables_unbind_set(ctx, set, binding,\n\t\t\t\t     phase == NFT_TRANS_COMMIT);\n\t}\n}", "target": 0}
{"code": "resolve_superior_type_check(struct lys_type *type)\n{\n    uint32_t i;\n    if (type->base == LY_TYPE_DER) {\n        return EXIT_FAILURE;\n    } else if (type->base == LY_TYPE_UNION) {\n        for (i = 0; i < type->info.uni.count; ++i) {\n            if (resolve_superior_type_check(&type->info.uni.types[i])) {\n                return EXIT_FAILURE;\n            }\n        }\n    } else if (type->base == LY_TYPE_LEAFREF) {\n        while (!type->info.lref.path) {\n            assert(type->der);\n            type = &type->der->type;\n        }\n    }\n    return EXIT_SUCCESS;\n}", "target": 0}
{"code": "ecma_op_internal_buffer_append (ecma_collection_t *container_p, \n                                ecma_value_t key_arg, \n                                ecma_value_t value_arg, \n                                lit_magic_string_id_t lit_id) \n{\n  JERRY_ASSERT (container_p != NULL);\n  ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (key_arg));\n  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)\n  {\n    ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (value_arg));\n  }\n  ECMA_CONTAINER_SET_SIZE (container_p, ECMA_CONTAINER_GET_SIZE (container_p) + 1);\n} ", "target": 1}
{"code": "static void nfs4_close_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_closedata *calldata = data;\n\tstruct nfs4_state *state = calldata->state;\n\tstruct nfs_server *server = NFS_SERVER(calldata->inode);\n\tif (RPC_ASSASSINATED(task))\n\t\treturn;\n\tswitch (task->tk_status) {\n\t\tcase 0:\n\t\t\tnfs_set_open_stateid(state, &calldata->res.stateid, 0);\n\t\t\trenew_lease(server, calldata->timestamp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_OLD_STATEID:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tif (calldata->arg.open_flags == 0)\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (nfs4_async_handle_error(task, server, state) == -EAGAIN) {\n\t\t\t\trpc_restart_call(task);\n\t\t\t\treturn;\n\t\t\t}\n\t}\n\tnfs_refresh_inode(calldata->inode, calldata->res.fattr);\n}", "target": 1}
{"code": "void ping_unhash(struct sock *sk)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tpr_debug(\"ping_unhash(isk=%p,isk->num=%u)\\n\", isk, isk->inet_num);\n\twrite_lock_bh(&ping_table.lock);\n\tif (sk_hashed(sk)) {\n\t\thlist_nulls_del(&sk->sk_nulls_node);\n\t\tsk_nulls_node_init(&sk->sk_nulls_node);\n\t\tsock_put(sk);\n\t\tisk->inet_num = 0;\n\t\tisk->inet_sport = 0;\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\t}\n\twrite_unlock_bh(&ping_table.lock);\n}", "target": 0}
{"code": "deltas_head_set_size(struct deltas_head *deltas, size_t capacity)\n{\n\tsize_t i;\n\tif (deltas->array != NULL)\n\t\tpr_crit(\"Size of this list can't be modified\");\n\tdeltas->capacity = capacity;\n\tif (capacity == 0)\n\t\treturn 0; \n\tdeltas->array = malloc(deltas->capacity\n\t    * sizeof(struct delta_head *));\n\tif (deltas->array == NULL)\n\t\treturn pr_enomem();\n\tfor (i = 0; i < deltas->capacity; i++)\n\t\tdeltas->array[i] = NULL;\n\treturn 0;\n}", "target": 1}
{"code": "static void calcstepsizes(uint_fast16_t refstepsize, int numrlvls,\n  uint_fast16_t *stepsizes)\n{\n\tint bandno;\n\tint numbands;\n\tuint_fast16_t expn;\n\tuint_fast16_t mant;\n\texpn = JPC_QCX_GETEXPN(refstepsize);\n\tmant = JPC_QCX_GETMANT(refstepsize);\n\tnumbands = 3 * numrlvls - 2;\n\tfor (bandno = 0; bandno < numbands; ++bandno) {\n\t\tstepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn +\n\t\t  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));\n\t}\n}", "target": 0}
{"code": "static UINT rdpei_recv_pdu(RDPEI_CHANNEL_CALLBACK* callback, wStream* s)\n{\n\tUINT16 eventId;\n\tUINT32 pduLength;\n\tUINT error;\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT16(s, eventId);   \n\tStream_Read_UINT32(s, pduLength); \n#ifdef WITH_DEBUG_RDPEI\n\tWLog_DBG(TAG, \"rdpei_recv_pdu: eventId: %\" PRIu16 \" (%s) length: %\" PRIu32 \"\", eventId,\n\t         rdpei_eventid_string(eventId), pduLength);\n#endif\n\tswitch (eventId)\n\t{\n\t\tcase EVENTID_SC_READY:\n\t\t\tif ((error = rdpei_recv_sc_ready_pdu(callback, s)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_recv_sc_ready_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tif ((error = rdpei_send_cs_ready_pdu(callback)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_send_cs_ready_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EVENTID_SUSPEND_TOUCH:\n\t\t\tif ((error = rdpei_recv_suspend_touch_pdu(callback, s)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_recv_suspend_touch_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EVENTID_RESUME_TOUCH:\n\t\t\tif ((error = rdpei_recv_resume_touch_pdu(callback, s)))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"rdpei_recv_resume_touch_pdu failed with error %\" PRIu32 \"!\", error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn CHANNEL_RC_OK;\n}", "target": 0}
{"code": "static entity_table_opt determine_entity_table(int all, int doctype)\n{\n\tentity_table_opt retval = {NULL};\n\tassert(!(doctype == ENT_HTML_DOC_XML1 && all));\n\tif (all) {\n\t\tretval.ms_table = (doctype == ENT_HTML_DOC_HTML5) ?\n\t\t\tentity_ms_table_html5 : entity_ms_table_html4;\n\t} else {\n\t\tretval.table = (doctype == ENT_HTML_DOC_HTML401) ?\n\t\t\tstage3_table_be_noapos_00000 : stage3_table_be_apos_00000;\n\t}\n\treturn retval;\n}", "target": 1}
{"code": "CURLcode Curl_close(struct Curl_easy *data)\n{\n  struct Curl_multi *m;\n  if(!data)\n    return CURLE_OK;\n  Curl_expire_clear(data); \n  m = data->multi;\n  if(m)\n    curl_multi_remove_handle(data->multi, data);\n  if(data->multi_easy)\n    curl_multi_cleanup(data->multi_easy);\n  Curl_llist_destroy(&data->state.timeoutlist, NULL);\n  data->magic = 0; \n  if(data->state.rangestringalloc)\n    free(data->state.range);\n  Curl_free_request_state(data);\n  Curl_ssl_close_all(data);\n  Curl_safefree(data->state.first_host);\n  Curl_safefree(data->state.scratch);\n  Curl_ssl_free_certinfo(data);\n  free(data->req.newurl);\n  data->req.newurl = NULL;\n  if(data->change.referer_alloc) {\n    Curl_safefree(data->change.referer);\n    data->change.referer_alloc = FALSE;\n  }\n  data->change.referer = NULL;\n  Curl_up_free(data);\n  Curl_safefree(data->state.buffer);\n  Curl_safefree(data->state.headerbuff);\n  Curl_safefree(data->state.ulbuf);\n  Curl_flush_cookies(data, 1);\n  Curl_digest_cleanup(data);\n  Curl_safefree(data->info.contenttype);\n  Curl_safefree(data->info.wouldredirect);\n  Curl_resolver_cleanup(data->state.resolver);\n  Curl_http2_cleanup_dependencies(data);\n  Curl_convert_close(data);\n  if(data->share) {\n    Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);\n    data->share->dirty--;\n    Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);\n  }\n  Curl_wildcard_dtor(&data->wildcard);\n  Curl_freeset(data);\n  free(data);\n  return CURLE_OK;\n}", "target": 1}
{"code": "ikev1_vid_print(netdissect_options *ndo, u_char tpay _U_,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep _U_,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_VID)));\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_VID)));\n\treturn NULL;\n}", "target": 0}
{"code": "void TestSocketLineReader::init()\n{\n    m_packets.clear();\n    m_server = new Server(this);\n    QVERIFY2(m_server->listen(QHostAddress::LocalHost, 8694), \"Failed to create local tcp server\");\n    m_timer.setInterval(4000);\n    m_timer.setSingleShot(true);\n    connect(&m_timer, &QTimer::timeout, &m_loop, &QEventLoop::quit);\n    m_conn = new QSslSocket(this);\n    m_conn->connectToHost(QHostAddress::LocalHost, 8694);\n    connect(m_conn, &QAbstractSocket::connected, &m_loop, &QEventLoop::quit);\n    m_timer.start();\n    m_loop.exec();\n    QVERIFY2(m_conn->isOpen(), \"Could not connect to local tcp server\");\n}", "target": 0}
{"code": "int dns_add_rr_nested_end(struct dns_rr_nested *rr_nested, dns_type_t rtype)\n{\n\tif (rr_nested == NULL || rr_nested->rr_start == NULL) {\n\t\treturn -1;\n\t}\n\tint len = rr_nested->context.ptr - rr_nested->rr_start;\n\tunsigned char *ptr = rr_nested->rr_len_ptr;\n\tif (ptr == NULL || _dns_left_len(&rr_nested->context) < 2) {\n\t\treturn -1;\n\t}\n\tif (len <= 14) {\n\t\trr_nested->context.ptr = rr_nested->rr_start;\n\t\treturn 0;\n\t}\n\t_dns_write_short(&ptr, len - rr_nested->rr_head_len);\n\treturn _dns_rr_add_end(rr_nested->context.packet, rr_nested->type, rtype, len);\n}", "target": 0}
{"code": "peek_from_buf(char *string, size_t string_len, const buf_t *buf)\n{\n  chunk_t *chunk;\n  tor_assert(string);\n  tor_assert(string_len <= buf->datalen);\n  chunk = buf->head;\n  while (string_len) {\n    size_t copy = string_len;\n    tor_assert(chunk);\n    if (chunk->datalen < copy)\n      copy = chunk->datalen;\n    memcpy(string, chunk->data, copy);\n    string_len -= copy;\n    string += copy;\n    chunk = chunk->next;\n  }\n}", "target": 0}
{"code": "R_API st64 r_buf_fread_at(RBuffer *b, ut64 addr, ut8 *buf, const char *fmt, int n) {\n\tr_return_val_if_fail (b && buf && fmt, -1);\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tst64 r = r_buf_seek (b, addr, R_BUF_SET);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\tr = r_buf_fread (b, buf, fmt, n);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn r;\n}", "target": 1}
{"code": "_pdfioDictRead(pdfio_file_t   *pdf,\t\n               pdfio_obj_t    *obj,\t\n               _pdfio_token_t *tb,\t\n               size_t         depth)\t\n{\n  pdfio_dict_t\t\t*dict;\t\t\n  char\t\t\tkey[256];\t\n  _pdfio_value_t\tvalue;\t\t\n  PDFIO_DEBUG(\"_pdfioDictRead(pdf=%p)\\n\", pdf);\n  if ((dict = pdfioDictCreate(pdf)) == NULL)\n    return (NULL);\n  while (_pdfioTokenGet(tb, key, sizeof(key)))\n  {\n    if (!strcmp(key, \">>\"))\n    {\n      return (dict);\n    }\n    else if (key[0] != '/')\n    {\n      _pdfioFileError(pdf, \"Invalid dictionary contents.\");\n      break;\n    }\n    else if (_pdfioDictGetValue(dict, key + 1))\n    {\n      _pdfioFileError(pdf, \"Duplicate dictionary key '%s'.\", key + 1);\n      return (NULL);\n    }\n    PDFIO_DEBUG(\"_pdfioDictRead: Reading value for '%s'.\\n\", key + 1);\n    if (!_pdfioValueRead(pdf, obj, tb, &value, depth))\n    {\n      _pdfioFileError(pdf, \"Missing value for dictionary key.\");\n      break;\n    }\n    if (!_pdfioDictSetValue(dict, pdfioStringCreate(pdf, key + 1), &value))\n      break;\n  }\n  return (NULL);\n}", "target": 0}
{"code": "void TensorSliceReader::LoadShard(int shard) const {\n  CHECK_LT(shard, sss_.size());\n  if (sss_[shard] || !status_.ok()) {\n    return;  \n  }\n  string value;\n  SavedTensorSlices sts;\n  const string fname = fnames_[shard];\n  VLOG(1) << \"Reading meta data from file \" << fname << \"...\";\n  Table* table;\n  Status s = open_function_(fname, &table);\n  if (!s.ok()) {\n    status_ = errors::DataLoss(\"Unable to open table file \", fname, \": \",\n                               s.ToString());\n    return;\n  }\n  sss_[shard].reset(table);\n  if (!(table->Get(kSavedTensorSlicesKey, &value) &&\n        ParseProtoUnlimited(&sts, value))) {\n    status_ = errors::Internal(\n        \"Failed to find the saved tensor slices at the beginning of the \"\n        \"checkpoint file: \",\n        fname);\n    return;\n  }\n  status_ = CheckVersions(sts.meta().versions(), TF_CHECKPOINT_VERSION,\n                          TF_CHECKPOINT_VERSION_MIN_PRODUCER, \"Checkpoint\",\n                          \"checkpoint\");\n  if (!status_.ok()) return;\n  for (const SavedSliceMeta& ssm : sts.meta().tensor()) {\n    TensorShape ssm_shape(ssm.shape());\n    for (const TensorSliceProto& tsp : ssm.slice()) {\n      TensorSlice ss_slice(tsp);\n      status_ = RegisterTensorSlice(ssm.name(), ssm_shape, ssm.type(), fname,\n                                    ss_slice, &tensors_);\n      if (!status_.ok()) return;\n    }\n  }\n}", "target": 1}
{"code": "hb_set_intersect (hb_set_t       *set,\n\t\t  const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->intersect (*other);\n}", "target": 1}
{"code": "reverseSamplesBytes (uint16 spp, uint16 bps, uint32 width, \n                     uint8 *src, uint8 *dst)\n  {\n  int i;\n  uint32  col, bytes_per_pixel, col_offset;\n  uint8   bytebuff1;\n  unsigned char swapbuff[32];\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"reverseSamplesBytes\",\"Invalid input or output buffer\");\n    return (1);\n    }\n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n  if( bytes_per_pixel > sizeof(swapbuff) )\n  {\n    TIFFError(\"reverseSamplesBytes\",\"bytes_per_pixel too large\");\n    return (1);\n  }\n  switch (bps / 8)\n     {\n     case 8:  \n     case 4:\n     case 3:\n     case 2: for (col = 0; col < (width / 2); col++)\n               {\n\t       col_offset = col * bytes_per_pixel;                     \n\t       _TIFFmemcpy (swapbuff, src + col_offset, bytes_per_pixel);\n\t       _TIFFmemcpy (src + col_offset, dst - col_offset - bytes_per_pixel, bytes_per_pixel);\n\t       _TIFFmemcpy (dst - col_offset - bytes_per_pixel, swapbuff, bytes_per_pixel);\n               }\n\t     break;\n     case 1: \n             for (col = 0; col < (width / 2); col++)\n               { \n\t       for (i = 0; i < spp; i++)\n                  {\n\t\t  bytebuff1 = *src;\n\t\t  *src++ = *(dst - spp + i);\n                  *(dst - spp + i) = bytebuff1;\n\t\t  }\n\t\tdst -= spp;\n                }\n\t     break;\n     default: TIFFError(\"reverseSamplesBytes\",\"Unsupported bit depth %d\", bps);\n       return (1);\n     }\n  return (0);\n  } ", "target": 0}
{"code": "static int handle_vmptrst(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\tgva_t vmcs_gva;\n\tstruct x86_exception e;\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\tif (get_vmx_mem_address(vcpu, exit_qualification,\n\t\t\tvmx_instruction_info, true, &vmcs_gva))\n\t\treturn 1;\n\tif (kvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, vmcs_gva,\n\t\t\t\t (void *)&to_vmx(vcpu)->nested.current_vmptr,\n\t\t\t\t sizeof(u64), &e)) {\n\t\tkvm_inject_page_fault(vcpu, &e);\n\t\treturn 1;\n\t}\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}", "target": 1}
{"code": "static __be32 nfsd4_open_omfg(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_op *op)\n{\n\tstruct nfsd4_open *open = &op->u.open;\n\tif (!seqid_mutating_err(ntohl(op->status)))\n\t\treturn op->status;\n\tif (nfsd4_has_session(cstate))\n\t\treturn op->status;\n\topen->op_xdr_error = op->status;\n\treturn nfsd4_open(rqstp, cstate, &op->u);\n}", "target": 0}
{"code": "static int hci_sock_getname(struct socket *sock, struct sockaddr *addr,\n\t\t\t    int *addr_len, int peer)\n{\n\tstruct sockaddr_hci *haddr = (struct sockaddr_hci *) addr;\n\tstruct sock *sk = sock->sk;\n\tstruct hci_dev *hdev = hci_pi(sk)->hdev;\n\tBT_DBG(\"sock %p sk %p\", sock, sk);\n\tif (!hdev)\n\t\treturn -EBADFD;\n\tlock_sock(sk);\n\t*addr_len = sizeof(*haddr);\n\thaddr->hci_family = AF_BLUETOOTH;\n\thaddr->hci_dev    = hdev->id;\n\thaddr->hci_channel= 0;\n\trelease_sock(sk);\n\treturn 0;\n}", "target": 0}
{"code": "htp_param_t *htp_tx_req_get_param_ex(htp_tx_t *tx, enum htp_data_source_t source, const char *name, size_t name_len) {\n    if ((tx == NULL) || (name == NULL)) return NULL;\n    htp_param_t *p = NULL;\n    for (size_t i = 0, n = htp_table_size(tx->request_params); i < n; i++) {\n        p = htp_table_get_index(tx->request_params, i, NULL);\n        if (p->source != source) continue;\n        if (bstr_cmp_mem_nocase(p->name, name, name_len) == 0) return p;\n    }\n    return NULL;\n}", "target": 0}
{"code": "CallResult<HermesValue> Runtime::interpretFunctionImpl(\n    CodeBlock *newCodeBlock) {\n  newCodeBlock->lazyCompile(*this);\n#if defined(HERMES_MEMORY_INSTRUMENTATION) || !defined(NDEBUG)\n  const inst::Inst *ip = getCurrentIP();\n  (void)ip;\n#endif\n#ifdef HERMES_MEMORY_INSTRUMENTATION\n  if (ip) {\n    const CodeBlock *codeBlock;\n    std::tie(codeBlock, ip) = getCurrentInterpreterLocation(ip);\n    if (codeBlock) {\n      pushCallStack(codeBlock, ip);\n    } else {\n      pushCallStack(newCodeBlock, (const Inst *)newCodeBlock->begin());\n    }\n  } else {\n    pushCallStack(newCodeBlock, (const Inst *)newCodeBlock->begin());\n  }\n#endif\n  InterpreterState state{newCodeBlock, 0};\n  if (HERMESVM_CRASH_TRACE &&\n      (getVMExperimentFlags() & experiments::CrashTrace)) {\n    return Interpreter::interpretFunction<false, true>(*this, state);\n  } else {\n    return Interpreter::interpretFunction<false, false>(*this, state);\n  }\n}", "target": 1}
{"code": "static int restrictedFile(const char *filename)\n{\n\tif (!live_dangerously && !strncasecmp(filename, \"/\", 1) &&\n\t\t strncasecmp(filename, ast_config_AST_CONFIG_DIR, strlen(ast_config_AST_CONFIG_DIR))) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "struct net *get_net_ns_by_id(struct net *net, int id)\n{\n\tstruct net *peer;\n\tif (id < 0)\n\t\treturn NULL;\n\trcu_read_lock();\n\tspin_lock_bh(&net->nsid_lock);\n\tpeer = idr_find(&net->netns_ids, id);\n\tif (peer)\n\t\tget_net(peer);\n\tspin_unlock_bh(&net->nsid_lock);\n\trcu_read_unlock();\n\treturn peer;\n}", "target": 1}
{"code": "static int logi_dj_raw_event(struct hid_device *hdev,\n\t\t\t     struct hid_report *report, u8 *data,\n\t\t\t     int size)\n{\n\tstruct dj_receiver_dev *djrcv_dev = hid_get_drvdata(hdev);\n\tstruct dj_report *dj_report = (struct dj_report *) data;\n\tunsigned long flags;\n\tbool report_processed = false;\n\tdbg_hid(\"%s, size:%d\\n\", __func__, size);\n\tif ((dj_report->device_index < DJ_DEVICE_INDEX_MIN) ||\n\t    (dj_report->device_index > DJ_DEVICE_INDEX_MAX)) {\n\t\tdev_err(&hdev->dev, \"%s: invalid device index:%d\\n\",\n\t\t\t\t__func__, dj_report->device_index);\n\t\treturn false;\n\t}\n\tspin_lock_irqsave(&djrcv_dev->lock, flags);\n\tif (dj_report->report_id == REPORT_ID_DJ_SHORT) {\n\t\tswitch (dj_report->report_type) {\n\t\tcase REPORT_TYPE_NOTIF_DEVICE_PAIRED:\n\t\tcase REPORT_TYPE_NOTIF_DEVICE_UNPAIRED:\n\t\t\tlogi_dj_recv_queue_notification(djrcv_dev, dj_report);\n\t\t\tbreak;\n\t\tcase REPORT_TYPE_NOTIF_CONNECTION_STATUS:\n\t\t\tif (dj_report->report_params[CONNECTION_STATUS_PARAM_STATUS] ==\n\t\t\t    STATUS_LINKLOSS) {\n\t\t\t\tlogi_dj_recv_forward_null_report(djrcv_dev, dj_report);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlogi_dj_recv_forward_report(djrcv_dev, dj_report);\n\t\t}\n\t\treport_processed = true;\n\t}\n\tspin_unlock_irqrestore(&djrcv_dev->lock, flags);\n\treturn report_processed;\n}", "target": 0}
{"code": "static int unix_dgram_peer_wake_relay(wait_queue_t *q, unsigned mode, int flags,\n\t\t\t\t      void *key)\n{\n\tstruct unix_sock *u;\n\twait_queue_head_t *u_sleep;\n\tu = container_of(q, struct unix_sock, peer_wake);\n\t__remove_wait_queue(&unix_sk(u->peer_wake.private)->peer_wait,\n\t\t\t    q);\n\tu->peer_wake.private = NULL;\n\tu_sleep = sk_sleep(&u->sk);\n\tif (u_sleep)\n\t\twake_up_interruptible_poll(u_sleep, key);\n\treturn 0;\n}", "target": 0}
{"code": "static char *utf2char(utf16_t *str, char *buffer)\n{\n  char *b = buffer;\n  while (*str != 0x00) {\n    char *chr = (char *)str;\n    *b++ = *chr;\n    str++;\n  }\n  *b = 0;\n  return buffer;\n}", "target": 1}
{"code": "render_pixbuf_size_prepared_cb (GdkPixbufLoader *loader,\n\t\t\t\tgint             width,\n\t\t\t\tgint             height,\n\t\t\t\tgpointer         data)\n{\n\tdouble *scale = data;\n\tint w = (width  * (*scale) + 0.5);\n\tint h = (height * (*scale) + 0.5);\n\tgdk_pixbuf_loader_set_size (loader, w, h);\n}", "target": 1}
{"code": "Status OpLevelCostEstimator::PredictMaxPoolGrad(const OpContext& op_context,\n                                                NodeCosts* node_costs) const {\n  bool found_unknown_shapes = false;\n  const auto& op_info = op_context.op_info;\n  if (op_info.inputs_size() < 3) {\n    return errors::InvalidArgument(\"MaxPoolGrad op has invalid inputs: \",\n                                   op_info.ShortDebugString());\n  }\n  ConvolutionDimensions dims = OpDimensionsFromInputs(\n      op_info.inputs(0).shape(), op_info, &found_unknown_shapes);\n  int64_t ops = 0;\n  if (dims.kx == 1 && dims.ky == 1) {\n    ops = dims.batch * dims.ix * dims.iy * dims.iz;\n  } else if (dims.kx <= dims.sx && dims.ky <= dims.sy) {\n    ops = dims.batch * dims.iz *\n          (dims.ox * dims.oy * (dims.kx * dims.ky - 1) + dims.ix * dims.iy);\n  } else {\n    ops = dims.batch * dims.iz *\n          (dims.ox * dims.oy * (dims.kx * dims.ky - 1) + dims.ix * dims.iy * 2);\n  }\n  node_costs->num_compute_ops = ops;\n  const int64_t input0_size =\n      CalculateTensorSize(op_info.inputs(0), &found_unknown_shapes);\n  const int64_t input2_size =\n      CalculateTensorSize(op_info.inputs(2), &found_unknown_shapes);\n  node_costs->num_input_bytes_accessed = {input0_size, 0, input2_size};\n  const int64_t output_size =\n      CalculateTensorSize(op_info.inputs(0), &found_unknown_shapes);\n  node_costs->num_output_bytes_accessed = {output_size};\n  node_costs->max_memory = output_size;\n  if (found_unknown_shapes) {\n    node_costs->inaccurate = true;\n    node_costs->num_nodes_with_unknown_shapes = 1;\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "CopyKeyAliasesToKeymap(struct xkb_keymap *keymap, KeyNamesInfo *info)\n{\n    AliasInfo *alias;\n    unsigned i, num_key_aliases;\n    struct xkb_key_alias *key_aliases;\n    num_key_aliases = 0;\n    darray_foreach(alias, info->aliases) {\n        if (!XkbKeyByName(keymap, alias->real, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to alias %s to non-existent key %s; Ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n        if (XkbKeyByName(keymap, alias->alias, false)) {\n            log_vrb(info->ctx, 5,\n                    \"Attempt to create alias with the name of a real key; \"\n                    \"Alias \\\"%s = %s\\\" ignored\\n\",\n                    KeyNameText(info->ctx, alias->alias),\n                    KeyNameText(info->ctx, alias->real));\n            alias->real = XKB_ATOM_NONE;\n            continue;\n        }\n        num_key_aliases++;\n    }\n    key_aliases = NULL;\n    if (num_key_aliases > 0) {\n        key_aliases = calloc(num_key_aliases, sizeof(*key_aliases));\n        if (!key_aliases)\n            return false;\n    }\n    i = 0;\n    darray_foreach(alias, info->aliases) {\n        if (alias->real != XKB_ATOM_NONE) {\n            key_aliases[i].alias = alias->alias;\n            key_aliases[i].real = alias->real;\n            i++;\n        }\n    }\n    keymap->num_key_aliases = num_key_aliases;\n    keymap->key_aliases = key_aliases;\n    return true;\n}", "target": 1}
{"code": "infra_wait_limit_netblock_insert(struct infra_cache* infra,\n\tstruct config_file* cfg)\n{\n\tstruct config_str2list* p;\n\tstruct wait_limit_netblock_info* d;\n\tfor(p = cfg->wait_limit_netblock; p; p = p->next) {\n\t\td = wait_limit_netblock_findcreate(infra, p->str, 0);\n\t\tif(!d)\n\t\t\treturn 0;\n\t\td->limit = atoi(p->str2);\n\t}\n\tfor(p = cfg->wait_limit_cookie_netblock; p; p = p->next) {\n\t\td = wait_limit_netblock_findcreate(infra, p->str, 1);\n\t\tif(!d)\n\t\t\treturn 0;\n\t\td->limit = atoi(p->str2);\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "iakerb_gss_import_sec_context(OM_uint32 *minor_status,\n                              gss_buffer_t interprocess_token,\n                              gss_ctx_id_t *context_handle)\n{\n    OM_uint32 maj, tmpmin;\n    krb5_error_code code;\n    gss_ctx_id_t gssc;\n    krb5_gss_ctx_id_t kctx;\n    iakerb_ctx_id_t ctx;\n    maj = krb5_gss_import_sec_context(minor_status, interprocess_token, &gssc);\n    if (maj != GSS_S_COMPLETE)\n        return maj;\n    kctx = (krb5_gss_ctx_id_t)gssc;\n    if (!kctx->established) {\n        krb5_gss_delete_sec_context(&tmpmin, &gssc, GSS_C_NO_BUFFER);\n        return GSS_S_FAILURE;\n    }\n    code = iakerb_alloc_context(&ctx, kctx->initiate);\n    if (code != 0) {\n        krb5_gss_delete_sec_context(&tmpmin, &gssc, GSS_C_NO_BUFFER);\n        *minor_status = code;\n        return GSS_S_FAILURE;\n    }\n    ctx->gssc = gssc;\n    ctx->established = 1;\n    *context_handle = (gss_ctx_id_t)ctx;\n    return GSS_S_COMPLETE;\n}", "target": 0}
{"code": "static int cma_bind_loopback(struct rdma_id_private *id_priv)\n{\n\tstruct cma_device *cma_dev, *cur_dev;\n\tunion ib_gid gid;\n\tenum ib_port_state port_state;\n\tunsigned int p;\n\tu16 pkey;\n\tint ret;\n\tcma_dev = NULL;\n\tmutex_lock(&lock);\n\tlist_for_each_entry(cur_dev, &dev_list, list) {\n\t\tif (cma_family(id_priv) == AF_IB &&\n\t\t    !rdma_cap_ib_cm(cur_dev->device, 1))\n\t\t\tcontinue;\n\t\tif (!cma_dev)\n\t\t\tcma_dev = cur_dev;\n\t\trdma_for_each_port (cur_dev->device, p) {\n\t\t\tif (!ib_get_cached_port_state(cur_dev->device, p, &port_state) &&\n\t\t\t    port_state == IB_PORT_ACTIVE) {\n\t\t\t\tcma_dev = cur_dev;\n\t\t\t\tgoto port_found;\n\t\t\t}\n\t\t}\n\t}\n\tif (!cma_dev) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\tp = 1;\nport_found:\n\tret = rdma_query_gid(cma_dev->device, p, 0, &gid);\n\tif (ret)\n\t\tgoto out;\n\tret = ib_get_cached_pkey(cma_dev->device, p, 0, &pkey);\n\tif (ret)\n\t\tgoto out;\n\tid_priv->id.route.addr.dev_addr.dev_type =\n\t\t(rdma_protocol_ib(cma_dev->device, p)) ?\n\t\tARPHRD_INFINIBAND : ARPHRD_ETHER;\n\trdma_addr_set_sgid(&id_priv->id.route.addr.dev_addr, &gid);\n\tib_addr_set_pkey(&id_priv->id.route.addr.dev_addr, pkey);\n\tid_priv->id.port_num = p;\n\tcma_attach_to_dev(id_priv, cma_dev);\n\trdma_restrack_add(&id_priv->res);\n\tcma_set_loopback(cma_src_addr(id_priv));\nout:\n\tmutex_unlock(&lock);\n\treturn ret;\n}", "target": 0}
{"code": "void TEMPLATE(process_block_dec)(decoder_info_t *decoder_info,int size,int yposY,int xposY,int sub)\n{\n  int width = decoder_info->width;\n  int height = decoder_info->height;\n  stream_t *stream = decoder_info->stream;\n  frame_type_t frame_type = decoder_info->frame_info.frame_type;\n  int split_flag = 0;\n  if (yposY >= height || xposY >= width)\n    return;\n  int decode_this_size = (yposY + size <= height) && (xposY + size <= width);\n  int decode_rectangular_size = !decode_this_size && frame_type != I_FRAME;\n  int bit_start = stream->bitcnt;\n  int mode = MODE_SKIP;\n  block_context_t block_context;\n  TEMPLATE(find_block_contexts)(yposY, xposY, height, width, size, decoder_info->deblock_data, &block_context, decoder_info->use_block_contexts);\n  decoder_info->block_context = &block_context;\n  split_flag = decode_super_mode(decoder_info,size,decode_this_size);\n  mode = decoder_info->mode;\n  if (size == (1<<decoder_info->log2_sb_size) && (split_flag || mode != MODE_SKIP) && decoder_info->max_delta_qp > 0) {\n    int delta_qp = read_delta_qp(stream);\n    int prev_qp;\n    if (yposY == 0 && xposY == 0)\n      prev_qp = decoder_info->frame_info.qp;\n    else\n      prev_qp = decoder_info->frame_info.qpb;\n    decoder_info->frame_info.qpb = prev_qp + delta_qp;\n  }\n  decoder_info->bit_count.super_mode[decoder_info->bit_count.stat_frame_type] += (stream->bitcnt - bit_start);\n  if (split_flag){\n    int new_size = size/2;\n    TEMPLATE(process_block_dec)(decoder_info,new_size,yposY+0*new_size,xposY+0*new_size,sub);\n    TEMPLATE(process_block_dec)(decoder_info,new_size,yposY+1*new_size,xposY+0*new_size,sub);\n    TEMPLATE(process_block_dec)(decoder_info,new_size,yposY+0*new_size,xposY+1*new_size,sub);\n    TEMPLATE(process_block_dec)(decoder_info,new_size,yposY+1*new_size,xposY+1*new_size,sub);\n  }\n  else if (decode_this_size || decode_rectangular_size){\n    decode_block(decoder_info,size,yposY,xposY,sub);\n  }\n}", "target": 1}
{"code": "static struct mb2_cache_entry *__entry_find(struct mb2_cache *cache,\n\t\t\t\t\t    struct mb2_cache_entry *entry,\n\t\t\t\t\t    u32 key)\n{\n\tstruct mb2_cache_entry *old_entry = entry;\n\tstruct hlist_bl_node *node;\n\tstruct hlist_bl_head *head;\n\tif (entry)\n\t\thead = entry->e_hash_list_head;\n\telse\n\t\thead = &cache->c_hash[hash_32(key, cache->c_bucket_bits)];\n\thlist_bl_lock(head);\n\tif (entry && !hlist_bl_unhashed(&entry->e_hash_list))\n\t\tnode = entry->e_hash_list.next;\n\telse\n\t\tnode = hlist_bl_first(head);\n\twhile (node) {\n\t\tentry = hlist_bl_entry(node, struct mb2_cache_entry,\n\t\t\t\t       e_hash_list);\n\t\tif (entry->e_key == key) {\n\t\t\tatomic_inc(&entry->e_refcnt);\n\t\t\tgoto out;\n\t\t}\n\t\tnode = node->next;\n\t}\n\tentry = NULL;\nout:\n\thlist_bl_unlock(head);\n\tif (old_entry)\n\t\tmb2_cache_entry_put(cache, old_entry);\n\treturn entry;\n}", "target": 0}
{"code": "static void rose_heartbeat_expiry(struct timer_list *t)\n{\n\tstruct sock *sk = from_timer(sk, t, sk_timer);\n\tstruct rose_sock *rose = rose_sk(sk);\n\tbh_lock_sock(sk);\n\tswitch (rose->state) {\n\tcase ROSE_STATE_0:\n\t\tif (sock_flag(sk, SOCK_DESTROY) ||\n\t\t    (sk->sk_state == TCP_LISTEN && sock_flag(sk, SOCK_DEAD))) {\n\t\t\tbh_unlock_sock(sk);\n\t\t\trose_destroy_socket(sk);\n\t\t\tsock_put(sk);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase ROSE_STATE_3:\n\t\tif (atomic_read(&sk->sk_rmem_alloc) < (sk->sk_rcvbuf / 2) &&\n\t\t    (rose->condition & ROSE_COND_OWN_RX_BUSY)) {\n\t\t\trose->condition &= ~ROSE_COND_OWN_RX_BUSY;\n\t\t\trose->condition &= ~ROSE_COND_ACK_PENDING;\n\t\t\trose->vl         = rose->vr;\n\t\t\trose_write_internal(sk, ROSE_RR);\n\t\t\trose_stop_timer(sk);\t\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\trose_start_heartbeat(sk);\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}", "target": 0}
{"code": "struct nfs_client *nfs4_alloc_client(const struct nfs_client_initdata *cl_init)\n{\n\tint err;\n\tstruct nfs_client *clp = nfs_alloc_client(cl_init);\n\tif (IS_ERR(clp))\n\t\treturn clp;\n\terr = nfs_get_cb_ident_idr(clp, cl_init->minorversion);\n\tif (err)\n\t\tgoto error;\n\tif (cl_init->minorversion > NFS4_MAX_MINOR_VERSION) {\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\tspin_lock_init(&clp->cl_lock);\n\tINIT_DELAYED_WORK(&clp->cl_renewd, nfs4_renew_state);\n\tINIT_LIST_HEAD(&clp->cl_ds_clients);\n\trpc_init_wait_queue(&clp->cl_rpcwaitq, \"NFS client\");\n\tclp->cl_state = 1 << NFS4CLNT_LEASE_EXPIRED;\n\tclp->cl_mvops = nfs_v4_minor_ops[cl_init->minorversion];\n\tclp->cl_mig_gen = 1;\n#if IS_ENABLED(CONFIG_NFS_V4_1)\n\tinit_waitqueue_head(&clp->cl_lock_waitq);\n#endif\n\tINIT_LIST_HEAD(&clp->pending_cb_stateids);\n\treturn clp;\nerror:\n\tnfs_free_client(clp);\n\treturn ERR_PTR(err);\n}", "target": 1}
{"code": "void mark_files_ro(struct super_block *sb)\n{\n\tstruct file *f;\n\tlg_global_lock(&files_lglock);\n\tdo_file_list_for_each_entry(sb, f) {\n\t\tif (!file_count(f))\n\t\t\tcontinue;\n\t\tif (!(f->f_mode & FMODE_WRITE))\n\t\t\tcontinue;\n\t\tspin_lock(&f->f_lock);\n\t\tf->f_mode &= ~FMODE_WRITE;\n\t\tspin_unlock(&f->f_lock);\n\t\tif (file_check_writeable(f) != 0)\n\t\t\tcontinue;\n\t\t__mnt_drop_write(f->f_path.mnt);\n\t\tfile_release_write(f);\n\t} while_file_list_for_each_entry;\n\tlg_global_unlock(&files_lglock);\n}", "target": 1}
{"code": "static int umocktypes_copy_bool_ptr(bool** destination, const bool** source)\n{\n    int result;\n    *destination = (bool*)my_gballoc_malloc(sizeof(bool));\n    if (*destination == NULL)\n    {\n        result = MU_FAILURE;\n    }\n    else\n    {\n        *(*destination) = *(*source);\n        result = 0;\n    }\n    return result;\n}", "target": 0}
{"code": "static void GTextFieldSave(GTextField *gt,int utf8) {\n    unichar_t *ret;\n    char *cret;\n    FILE *file;\n    unichar_t *pt;\n    if ( _ggadget_use_gettext ) {\n\tchar *temp = GWidgetOpenFile8(_(\"Save\"),NULL,\"*.{txt,py}\",NULL,NULL);\n\tret = utf82u_copy(temp);\n\tfree(temp);\n    } else\n\tret = GWidgetSaveAsFile(GStringGetResource(_STR_Save,NULL),NULL,\n\t\ttxt,NULL,NULL);\n    if ( ret==NULL )\nreturn;\n    cret = u2def_copy(ret);\n    free(ret);\n    file = fopen(cret,\"w\");\n    if ( file==NULL ) {\n\tif ( _ggadget_use_gettext )\n\t    GWidgetError8(_(\"Could not open file\"), _(\"Could not open %.100s\"),cret);\n\telse\n\t    GWidgetError(errort,error,cret);\n\tfree(cret);\nreturn;\n    }\n    free(cret);\n    if ( utf8 ) {\n\tputc(0xef,file);\t\t\n\tputc(0xbb,file);\n\tputc(0xbf,file);\n\tfor ( pt = gt->text ; *pt; ++pt ) {\n\t    if ( *pt<0x80 )\n\t\tputc(*pt,file);\n\t    else if ( *pt<0x800 ) {\n\t\tputc(0xc0 | (*pt>>6), file);\n\t\tputc(0x80 | (*pt&0x3f), file);\n\t    } else if ( *pt>=0xd800 && *pt<0xdc00 && pt[1]>=0xdc00 && pt[1]<0xe000 ) {\n\t\tint u = ((*pt>>6)&0xf)+1, y = ((*pt&3)<<4) | ((pt[1]>>6)&0xf);\n\t\tputc( 0xf0 | (u>>2),file );\n\t\tputc( 0x80 | ((u&3)<<4) | ((*pt>>2)&0xf),file );\n\t\tputc( 0x80 | y,file );\n\t\tputc( 0x80 | (pt[1]&0x3f),file );\n\t    } else {\n\t\tputc( 0xe0 | (*pt>>12),file );\n\t\tputc( 0x80 | ((*pt>>6)&0x3f),file );\n\t\tputc( 0x80 | (*pt&0x3f),file );\n\t    }\n\t}\n    } else {\n\tputc(0xfeff>>8,file);\t\t\n\tputc(0xfeff&0xff,file);\n\tfor ( pt = gt->text ; *pt; ++pt ) {\n\t    putc(*pt>>8,file);\n\t    putc(*pt&0xff,file);\n\t}\n    }\n    fclose(file);\n    GTextFieldSaved(gt);\n}", "target": 0}
{"code": "static void clamp_buffer(void*& buffer, size_t& size, void* limit_start, void* limit_end)\n{\n\tif (NULL == limit_start || NULL == limit_end)\n\t\treturn;\n\tuint8_t* _buffer = (uint8_t*)buffer;\n\tuint8_t* _limit_start = (uint8_t*)limit_start;\n\tuint8_t* _limit_end = (uint8_t*)limit_end;\n\tif (_buffer > _limit_end)\n\t{\n\t\tbuffer = limit_end;\n\t\tsize = 0;\n\t\treturn;\n\t}\n\tif (_buffer < _limit_start)\n\t\t_buffer = _limit_start;\n\tif ((_buffer + size) > _limit_end)\n\t\tsize = (_limit_end - _buffer);\n}", "target": 0}
{"code": "validate_event(struct pmu_hw_events *hw_events,\n\t       struct perf_event *event)\n{\n\tstruct arm_pmu *armpmu = to_arm_pmu(event->pmu);\n\tstruct pmu *leader_pmu = event->group_leader->pmu;\n\tif (is_software_event(event))\n\t\treturn 1;\n\tif (event->pmu != leader_pmu || event->state < PERF_EVENT_STATE_OFF)\n\t\treturn 1;\n\tif (event->state == PERF_EVENT_STATE_OFF && !event->attr.enable_on_exec)\n\t\treturn 1;\n\treturn armpmu->get_event_idx(hw_events, event) >= 0;\n}", "target": 0}
{"code": "static gboolean printable_str(const char *str)\n{\n    do {\n        if ((unsigned char)(*str) < ' ' || *str == 0x7f)\n            return FALSE;\n        str++;\n    } while (*str);\n    return TRUE;\n}", "target": 1}
{"code": "get_page_size_area_prepared_cb (GdkPixbufLoader *loader,\n\t\t\t\tgpointer         data)\n{\n\tgboolean *got_size = data;\n\t*got_size = TRUE;\n}", "target": 1}
{"code": "check_SET_VLAN_PCP(struct ofpact_vlan_pcp *a, struct ofpact_check_params *cp)\n{\n    ovs_be16 *tci = &cp->match->flow.vlans[0].tci;\n    a->flow_has_vlan = (*tci & htons(VLAN_CFI)) != 0;\n    if (!a->flow_has_vlan && !a->push_vlan_if_needed) {\n        inconsistent_match(&cp->usable_protocols);\n    }\n    *tci |= htons(VLAN_CFI);\n    return 0;\n}", "target": 0}
{"code": "\t\tvoid Phase2() final {\n\t\t\tLocal<Context> context_handle = Deref(context);\n\t\t\tContext::Scope context_scope{context_handle};\n\t\t\tLocal<Value> key_inner = key->CopyInto();\n\t\t\tLocal<Object> object = Local<Object>::Cast(Deref(reference));\n\t\t\tbool allow = [&]() {\n\t\t\t\tif (!inherit) {\n\t\t\t\t\tif (key_inner->IsName()) {\n\t\t\t\t\t\treturn Unmaybe(object->HasRealNamedProperty(context_handle, key_inner.As<Name>()));\n\t\t\t\t\t} else if (key_inner->IsNumber()) {\n\t\t\t\t\t\treturn Unmaybe(object->HasRealIndexedProperty(context_handle, HandleCast<uint32_t>(key_inner)));\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}();\n\t\t\tLocal<Value> value = allow ?\n\t\t\t\tUnmaybe(object->Get(context_handle, key_inner)) :\n\t\t\t\tUndefined(Isolate::GetCurrent()).As<Value>();\n\t\t\tret = TransferOut(value, options);\n\t\t}", "target": 1}
{"code": "static void bpf_adj_branches(struct bpf_prog *prog, u32 pos, u32 delta)\n{\n\tstruct bpf_insn *insn = prog->insnsi;\n\tu32 i, insn_cnt = prog->len;\n\tbool pseudo_call;\n\tu8 code;\n\tint off;\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tcode = insn->code;\n\t\tif (BPF_CLASS(code) != BPF_JMP)\n\t\t\tcontinue;\n\t\tif (BPF_OP(code) == BPF_EXIT)\n\t\t\tcontinue;\n\t\tif (BPF_OP(code) == BPF_CALL) {\n\t\t\tif (insn->src_reg == BPF_PSEUDO_CALL)\n\t\t\t\tpseudo_call = true;\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tpseudo_call = false;\n\t\t}\n\t\toff = pseudo_call ? insn->imm : insn->off;\n\t\tif (i < pos && i + off + 1 > pos)\n\t\t\toff += delta;\n\t\telse if (i > pos + delta && i + off + 1 <= pos + delta)\n\t\t\toff -= delta;\n\t\tif (pseudo_call)\n\t\t\tinsn->imm = off;\n\t\telse\n\t\t\tinsn->off = off;\n\t}\n}", "target": 1}
{"code": "static int io_rw_init_file(struct io_kiocb *req, fmode_t mode)\n{\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct file *file = req->file;\n\tint ret;\n\tif (unlikely(!file || !(file->f_mode & mode)))\n\t\treturn -EBADF;\n\tif (!io_req_ffs_set(req))\n\t\treq->flags |= io_file_get_flags(file) << REQ_F_SUPPORT_NOWAIT_BIT;\n\tkiocb->ki_flags = iocb_flags(file);\n\tret = kiocb_set_rw_flags(kiocb, req->rw.flags);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tif ((kiocb->ki_flags & IOCB_NOWAIT) ||\n\t    ((file->f_flags & O_NONBLOCK) && !io_file_supports_nowait(req)))\n\t\treq->flags |= REQ_F_NOWAIT;\n\tif (ctx->flags & IORING_SETUP_IOPOLL) {\n\t\tif (!(kiocb->ki_flags & IOCB_DIRECT) || !file->f_op->iopoll)\n\t\t\treturn -EOPNOTSUPP;\n\t\tkiocb->private = NULL;\n\t\tkiocb->ki_flags |= IOCB_HIPRI | IOCB_ALLOC_CACHE;\n\t\tkiocb->ki_complete = io_complete_rw_iopoll;\n\t\treq->iopoll_completed = 0;\n\t} else {\n\t\tif (kiocb->ki_flags & IOCB_HIPRI)\n\t\t\treturn -EINVAL;\n\t\tkiocb->ki_complete = io_complete_rw;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "int nfs4_lock_delegation_recall(struct nfs4_state *state, struct file_lock *fl)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_exception exception = { };\n\tint err;\n\terr = nfs4_set_lock_state(state, fl);\n\tif (err != 0)\n\t\tgoto out;\n\tdo {\n\t\terr = _nfs4_do_setlk(state, F_SETLK, fl, NFS_LOCK_NEW);\n\t\tswitch (err) {\n\t\t\tdefault:\n\t\t\t\tprintk(KERN_ERR \"NFS: %s: unhandled error \"\n\t\t\t\t\t\"%d.\\n\", __func__, err);\n\t\t\tcase 0:\n\t\t\tcase -ESTALE:\n\t\t\t\tgoto out;\n\t\t\tcase -NFS4ERR_EXPIRED:\n\t\t\t\tnfs4_schedule_stateid_recovery(server, state);\n\t\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tcase -NFS4ERR_STALE_STATEID:\n\t\t\t\tnfs4_schedule_lease_recovery(server->nfs_client);\n\t\t\t\tgoto out;\n\t\t\tcase -NFS4ERR_BADSESSION:\n\t\t\tcase -NFS4ERR_BADSLOT:\n\t\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\t\tcase -NFS4ERR_DEADSESSION:\n\t\t\t\tnfs4_schedule_session_recovery(server->nfs_client->cl_session, err);\n\t\t\t\tgoto out;\n\t\t\tcase -ERESTARTSYS:\n\t\t\tcase -NFS4ERR_DELEG_REVOKED:\n\t\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\t\tcase -NFS4ERR_BAD_STATEID:\n\t\t\tcase -NFS4ERR_OPENMODE:\n\t\t\t\tnfs4_schedule_stateid_recovery(server, state);\n\t\t\t\terr = 0;\n\t\t\t\tgoto out;\n\t\t\tcase -EKEYEXPIRED:\n\t\t\t\terr = 0;\n\t\t\t\tgoto out;\n\t\t\tcase -ENOMEM:\n\t\t\tcase -NFS4ERR_DENIED:\n\t\t\t\terr = 0;\n\t\t\t\tgoto out;\n\t\t\tcase -NFS4ERR_DELAY:\n\t\t\t\tbreak;\n\t\t}\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\nout:\n\treturn err;\n}", "target": 0}
{"code": "static int http_read_stream(URLContext *h, uint8_t *buf, int size)\n{\n    HTTPContext *s = h->priv_data;\n    int err, new_location, read_ret;\n    int64_t seek_ret;\n    if (!s->hd)\n        return AVERROR_EOF;\n    if (s->end_chunked_post && !s->end_header) {\n        err = http_read_header(h, &new_location);\n        if (err < 0)\n            return err;\n    }\n    if (s->chunksize >= 0) {\n        if (!s->chunksize) {\n            char line[32];\n                do {\n                    if ((err = http_get_line(s, line, sizeof(line))) < 0)\n                        return err;\n                } while (!*line);    \n                s->chunksize = strtoll(line, NULL, 16);\n                av_log(NULL, AV_LOG_TRACE, \"Chunked encoding data size: %\"PRId64\"'\\n\",\n                        s->chunksize);\n                if (!s->chunksize)\n                    return 0;\n        }\n        size = FFMIN(size, s->chunksize);\n    }\n#if CONFIG_ZLIB\n    if (s->compressed)\n        return http_buf_read_compressed(h, buf, size);\n#endif \n    read_ret = http_buf_read(h, buf, size);\n    if (   (read_ret  < 0 && s->reconnect        && (!h->is_streamed || s->reconnect_streamed) && s->filesize > 0 && s->off < s->filesize)\n        || (read_ret == 0 && s->reconnect_at_eof && (!h->is_streamed || s->reconnect_streamed))) {\n        int64_t target = h->is_streamed ? 0 : s->off;\n        if (s->reconnect_delay > s->reconnect_delay_max)\n            return AVERROR(EIO);\n        av_log(h, AV_LOG_INFO, \"Will reconnect at %\"PRId64\" error=%s.\\n\", s->off, av_err2str(read_ret));\n        av_usleep(1000U*1000*s->reconnect_delay);\n        s->reconnect_delay = 1 + 2*s->reconnect_delay;\n        seek_ret = http_seek_internal(h, target, SEEK_SET, 1);\n        if (seek_ret != target) {\n            av_log(h, AV_LOG_ERROR, \"Failed to reconnect at %\"PRId64\".\\n\", target);\n            return read_ret;\n        }\n        read_ret = http_buf_read(h, buf, size);\n    } else\n        s->reconnect_delay = 0;\n    return read_ret;\n}", "target": 1}
{"code": "void CLASS parse_qt (int end)\n{\n  unsigned save, size;\n  char tag[4];\n  order = 0x4d4d;\n  while (ftell(ifp)+7 < end) {\n    save = ftell(ifp);\n    if ((size = get4()) < 8) return;\n    if ((int)size < 0) return; \n    if (save + size < save) return; \n    fread (tag, 4, 1, ifp);\n    if (!memcmp(tag,\"moov\",4) ||\n\t!memcmp(tag,\"udta\",4) ||\n\t!memcmp(tag,\"CNTH\",4))\n      parse_qt (save+size);\n    if (!memcmp(tag,\"CNDA\",4))\n      parse_jpeg (ftell(ifp));\n    fseek (ifp, save+size, SEEK_SET);\n  }\n}", "target": 0}
{"code": "ModuleExport size_t RegisterPSImage(void)\n{\n  MagickInfo\n    *entry;\n  entry=AcquireMagickInfo(\"PS\",\"EPI\",\n    \"Encapsulated PostScript Interchange format\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"EPS\",\"Encapsulated PostScript\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"EPSF\",\"Encapsulated PostScript\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"EPSI\",\n    \"Encapsulated PostScript Interchange format\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"PS\",\"PostScript\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}", "target": 0}
{"code": "folly::Optional<TLSMessage> EncryptedReadRecordLayer::read(\n    folly::IOBufQueue& buf) {\n  auto decryptedBuf = getDecryptedBuf(buf);\n  if (!decryptedBuf) {\n    return folly::none;\n  }\n  TLSMessage msg{};\n  auto currentBuf = decryptedBuf->get();\n  bool nonZeroFound = false;\n  do {\n    currentBuf = currentBuf->prev();\n    size_t i = currentBuf->length();\n    while (i > 0 && !nonZeroFound) {\n      nonZeroFound = (currentBuf->data()[i - 1] != 0);\n      i--;\n    }\n    if (nonZeroFound) {\n      msg.type = static_cast<ContentType>(currentBuf->data()[i]);\n    }\n    currentBuf->trimEnd(currentBuf->length() - i);\n  } while (!nonZeroFound && currentBuf != decryptedBuf->get());\n  if (!nonZeroFound) {\n    throw std::runtime_error(\"No content type found\");\n  }\n  msg.fragment = std::move(*decryptedBuf);\n  switch (msg.type) {\n    case ContentType::handshake:\n    case ContentType::alert:\n    case ContentType::application_data:\n      break;\n    default:\n      throw std::runtime_error(folly::to<std::string>(\n          \"received encrypted content type \",\n          static_cast<ContentTypeType>(msg.type)));\n  }\n  if (!msg.fragment || msg.fragment->empty()) {\n    if (msg.type == ContentType::application_data) {\n      msg.fragment = folly::IOBuf::create(0);\n    } else {\n      throw std::runtime_error(\"received empty fragment\");\n    }\n  }\n  return msg;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    PoolParameters params{context,\n                          ksize_,\n                          stride_,\n                          padding_,\n                          {},\n                          FORMAT_NHWC,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n    const float min_input = context->input(1).flat<float>()(0);\n    const float max_input = context->input(2).flat<float>()(0);\n    OP_REQUIRES(context, params.depth_window == 1,\n                errors::Unimplemented(\"Non-spatial pooling is not \"\n                                      \"yet supported. Volunteers? :)\"));\n    OP_REQUIRES(context, tensor_in.dims() == 4,\n                errors::InvalidArgument(\"tensor_in must be 4-dimensional\"));\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                0, params.forward_output_shape(), &output));\n    const int32_t highest = static_cast<int32>(Eigen::NumTraits<T>::highest());\n    const int32_t lowest = static_cast<int32>(Eigen::NumTraits<T>::lowest());\n    Tensor int32_output(DT_INT32, params.forward_output_shape());\n    Tensor int32_input(DT_INT32, tensor_in.shape());\n    int32_input.flat<int32>() = tensor_in.flat<T>().template cast<int32>();\n    SpatialAvgPool<Device, int32>(context, &int32_output, int32_input, params,\n                                  padding_);\n    output->flat<T>() = int32_output.flat<int32>()\n                            .cwiseMax(lowest)\n                            .cwiseMin(highest)\n                            .template cast<T>();\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));\n    output_min->flat<float>()(0) = min_input;\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max));\n    output_max->flat<float>()(0) = max_input;\n  }", "target": 1}
{"code": "\t__acquires(&current->sighand->siglock)\n{\n\tbool gstop_done = false;\n\tif (arch_ptrace_stop_needed(exit_code, info)) {\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tarch_ptrace_stop(exit_code, info);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\tif (sigkill_pending(current))\n\t\t\treturn;\n\t}\n\tset_current_state(TASK_TRACED);\n\tcurrent->last_siginfo = info;\n\tcurrent->exit_code = exit_code;\n\tif (why == CLD_STOPPED && (current->jobctl & JOBCTL_STOP_PENDING))\n\t\tgstop_done = task_participate_group_stop(current);\n\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_STOP);\n\tif (info && info->si_code >> 8 == PTRACE_EVENT_STOP)\n\t\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_NOTIFY);\n\ttask_clear_jobctl_trapping(current);\n\tspin_unlock_irq(&current->sighand->siglock);\n\tread_lock(&tasklist_lock);\n\tif (may_ptrace_stop()) {\n\t\tdo_notify_parent_cldstop(current, true, why);\n\t\tif (gstop_done && ptrace_reparented(current))\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\t\tpreempt_disable();\n\t\tread_unlock(&tasklist_lock);\n\t\tpreempt_enable_no_resched();\n\t\tfreezable_schedule();\n\t} else {\n\t\tif (gstop_done)\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\t\t__set_current_state(TASK_RUNNING);\n\t\tif (clear_code)\n\t\t\tcurrent->exit_code = 0;\n\t\tread_unlock(&tasklist_lock);\n\t}\n\tspin_lock_irq(&current->sighand->siglock);\n\tcurrent->last_siginfo = NULL;\n\tcurrent->jobctl &= ~JOBCTL_LISTENING;\n\trecalc_sigpending_tsk(current);\n}", "target": 0}
{"code": "void DetectSignatureApplyActions(Packet *p,\n        const Signature *s, const uint8_t alert_flags)\n{\n    PACKET_UPDATE_ACTION(p, s->action);\n    if (s->action & ACTION_DROP) {\n        if (p->alerts.drop.action == 0) {\n            p->alerts.drop.num = s->num;\n            p->alerts.drop.action = s->action;\n            p->alerts.drop.s = (Signature *)s;\n        }\n    } else if (s->action & ACTION_PASS) {\n        if ((p->flow != NULL) &&\n                (alert_flags & (PACKET_ALERT_FLAG_STATE_MATCH|PACKET_ALERT_FLAG_STREAM_MATCH)))\n        {\n            FlowSetNoPacketInspectionFlag(p->flow);\n        }\n    }\n}", "target": 0}
{"code": "static void ext4_end_io_work(struct work_struct *work)\n{\n\text4_io_end_t *io  = container_of(work, ext4_io_end_t, work);\n\tstruct inode *inode = io->inode;\n\tint ret = 0;\n\tmutex_lock(&inode->i_mutex);\n\tret = ext4_end_io_nolock(io);\n\tif (ret >= 0) {\n\t\tif (!list_empty(&io->list))\n\t\t\tlist_del_init(&io->list);\n\t\text4_free_io_end(io);\n\t}\n\tmutex_unlock(&inode->i_mutex);\n}", "target": 1}
{"code": "static int stimer_set_config(struct kvm_vcpu_hv_stimer *stimer, u64 config,\n\t\t\t     bool host)\n{\n\tunion hv_stimer_config new_config = {.as_uint64 = config},\n\t\told_config = {.as_uint64 = stimer->config.as_uint64};\n\tstruct kvm_vcpu *vcpu = hv_stimer_to_vcpu(stimer);\n\tstruct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);\n\tstruct kvm_vcpu_hv_synic *synic = to_hv_synic(vcpu);\n\tif (!synic->active && !host)\n\t\treturn 1;\n\tif (unlikely(!host && hv_vcpu->enforce_cpuid && new_config.direct_mode &&\n\t\t     !(hv_vcpu->cpuid_cache.features_edx &\n\t\t       HV_STIMER_DIRECT_MODE_AVAILABLE)))\n\t\treturn 1;\n\ttrace_kvm_hv_stimer_set_config(hv_stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t       stimer->index, config, host);\n\tstimer_cleanup(stimer);\n\tif (old_config.enable &&\n\t    !new_config.direct_mode && new_config.sintx == 0)\n\t\tnew_config.enable = 0;\n\tstimer->config.as_uint64 = new_config.as_uint64;\n\tif (stimer->config.enable)\n\t\tstimer_mark_pending(stimer, false);\n\treturn 0;\n}", "target": 1}
{"code": "static void cancel_att_send_op(struct att_send_op *op)\n{\n\tif (op->destroy)\n\t\top->destroy(op->user_data);\n\top->user_data = NULL;\n\top->callback = NULL;\n\top->destroy = NULL;\n}", "target": 1}
{"code": "void json_object_seed(size_t seed) {\n    uint32_t new_seed = (uint32_t)seed;\n    if (hashtable_seed == 0) {\n        if (__atomic_test_and_set(&seed_initialized, __ATOMIC_RELAXED) == 0) {\n            if (new_seed == 0)\n                new_seed = generate_seed();\n            __atomic_store_n(&hashtable_seed, new_seed, __ATOMIC_ACQ_REL);\n        } else {\n            do {\n#ifdef HAVE_SCHED_YIELD\n                sched_yield();\n#endif\n            } while(__atomic_load_n(&hashtable_seed, __ATOMIC_ACQUIRE) == 0);\n        }\n    }\n}", "target": 0}
{"code": "bit_catenate(VarBit *arg1, VarBit *arg2)\n{\n\tVarBit\t   *result;\n\tint\t\t\tbitlen1,\n\t\t\t\tbitlen2,\n\t\t\t\tbytelen,\n\t\t\t\tbit1pad,\n\t\t\t\tbit2shift;\n\tbits8\t   *pr,\n\t\t\t   *pa;\n\tbitlen1 = VARBITLEN(arg1);\n\tbitlen2 = VARBITLEN(arg2);\n\tif (bitlen1 > VARBITMAXLEN - bitlen2)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"bit string length exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tVARBITMAXLEN)));\n\tbytelen = VARBITTOTALLEN(bitlen1 + bitlen2);\n\tresult = (VarBit *) palloc(bytelen);\n\tSET_VARSIZE(result, bytelen);\n\tVARBITLEN(result) = bitlen1 + bitlen2;\n\tmemcpy(VARBITS(result), VARBITS(arg1), VARBITBYTES(arg1));\n\tbit1pad = VARBITPAD(arg1);\n\tif (bit1pad == 0)\n\t{\n\t\tmemcpy(VARBITS(result) + VARBITBYTES(arg1), VARBITS(arg2),\n\t\t\t   VARBITBYTES(arg2));\n\t}\n\telse if (bitlen2 > 0)\n\t{\n\t\tbit2shift = BITS_PER_BYTE - bit1pad;\n\t\tpr = VARBITS(result) + VARBITBYTES(arg1) - 1;\n\t\tfor (pa = VARBITS(arg2); pa < VARBITEND(arg2); pa++)\n\t\t{\n\t\t\t*pr |= ((*pa >> bit2shift) & BITMASK);\n\t\t\tpr++;\n\t\t\tif (pr < VARBITEND(result))\n\t\t\t\t*pr = (*pa << bit1pad) & BITMASK;\n\t\t}\n\t}\n\treturn result;\n}", "target": 0}
{"code": "init_ext2_xattr(void)\n{\n\treturn 0;\n}", "target": 1}
{"code": "static int ext4_dax_pfn_mkwrite(struct vm_area_struct *vma,\n\t\t\t\tstruct vm_fault *vmf)\n{\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct super_block *sb = inode->i_sb;\n\tint ret = VM_FAULT_NOPAGE;\n\tloff_t size;\n\tsb_start_pagefault(sb);\n\tfile_update_time(vma->vm_file);\n\tdown_read(&EXT4_I(inode)->i_mmap_sem);\n\tsize = (i_size_read(inode) + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (vmf->pgoff >= size)\n\t\tret = VM_FAULT_SIGBUS;\n\tup_read(&EXT4_I(inode)->i_mmap_sem);\n\tsb_end_pagefault(sb);\n\treturn ret;\n}", "target": 0}
{"code": "static void fdc_specify(void)\n{\n\tunsigned char spec1;\n\tunsigned char spec2;\n\tunsigned long srt;\n\tunsigned long hlt;\n\tunsigned long hut;\n\tunsigned long dtr = NOMINAL_DTR;\n\tunsigned long scale_dtr = NOMINAL_DTR;\n\tint hlt_max_code = 0x7f;\n\tint hut_max_code = 0xf;\n\tif (FDCS->need_configure && FDCS->version >= FDC_82072A) {\n\t\tfdc_configure();\n\t\tFDCS->need_configure = 0;\n\t}\n\tswitch (raw_cmd->rate & 0x03) {\n\tcase 3:\n\t\tdtr = 1000;\n\t\tbreak;\n\tcase 1:\n\t\tdtr = 300;\n\t\tif (FDCS->version >= FDC_82078) {\n\t\t\toutput_byte(FD_DRIVESPEC);\n\t\t\tif (need_more_output() == MORE_OUTPUT) {\n\t\t\t\toutput_byte(UNIT(current_drive));\n\t\t\t\toutput_byte(0xc0);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tdtr = 250;\n\t\tbreak;\n\t}\n\tif (FDCS->version >= FDC_82072) {\n\t\tscale_dtr = dtr;\n\t\thlt_max_code = 0x00;\t\n\t\thut_max_code = 0x0;\t\n\t}\n\tsrt = 16 - DIV_ROUND_UP(DP->srt * scale_dtr / 1000, NOMINAL_DTR);\n\tif (slow_floppy)\n\t\tsrt = srt / 4;\n\tSUPBOUND(srt, 0xf);\n\tINFBOUND(srt, 0);\n\thlt = DIV_ROUND_UP(DP->hlt * scale_dtr / 2, NOMINAL_DTR);\n\tif (hlt < 0x01)\n\t\thlt = 0x01;\n\telse if (hlt > 0x7f)\n\t\thlt = hlt_max_code;\n\thut = DIV_ROUND_UP(DP->hut * scale_dtr / 16, NOMINAL_DTR);\n\tif (hut < 0x1)\n\t\thut = 0x1;\n\telse if (hut > 0xf)\n\t\thut = hut_max_code;\n\tspec1 = (srt << 4) | hut;\n\tspec2 = (hlt << 1) | (use_virtual_dma & 1);\n\tif (FDCS->spec1 != spec1 || FDCS->spec2 != spec2) {\n\t\toutput_byte(FD_SPECIFY);\n\t\toutput_byte(FDCS->spec1 = spec1);\n\t\toutput_byte(FDCS->spec2 = spec2);\n\t}\n}\t\t\t\t", "target": 0}
{"code": "static const char* jvp_literal_number_literal(jv n) {\n  assert(JVP_HAS_FLAGS(n, JVP_FLAGS_NUMBER_LITERAL));\n  decNumber *pdec = jvp_dec_number_ptr(n);\n  jvp_literal_number* plit = jvp_literal_number_ptr(n);\n  if (decNumberIsNaN(pdec)) {\n    return \"null\";\n  }\n  if (decNumberIsInfinite(pdec)) {\n    return NULL;\n  }\n  if (plit->literal_data == NULL) {\n    int len = jvp_dec_number_ptr(n)->digits + 14;\n    plit->literal_data = jv_mem_alloc(len);\n    decNumberToString(pdec, plit->literal_data);\n  }\n  return plit->literal_data;\n}", "target": 1}
{"code": "lyd_new_output_leaf(struct lyd_node *parent, const struct lys_module *module, const char *name, const char *val_str)\n{\n    const struct lys_node *snode = NULL, *siblings;\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n    siblings = lyd_new_find_schema(parent, module, 1);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_LEAFLIST | LYS_LEAF, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n    return _lyd_new_leaf(parent, snode, val_str, 0, 0);\n}", "target": 1}
{"code": "static void __munlock_pagevec(struct pagevec *pvec, struct zone *zone)\n{\n\tint i;\n\tint nr = pagevec_count(pvec);\n\tint delta_munlocked;\n\tstruct pagevec pvec_putback;\n\tint pgrescued = 0;\n\tpagevec_init(&pvec_putback, 0);\n\tspin_lock_irq(zone_lru_lock(zone));\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tif (TestClearPageMlocked(page)) {\n\t\t\tif (__munlock_isolate_lru_page(page, false))\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\t__munlock_isolation_failed(page);\n\t\t}\n\t\tpagevec_add(&pvec_putback, pvec->pages[i]);\n\t\tpvec->pages[i] = NULL;\n\t}\n\tdelta_munlocked = -nr + pagevec_count(&pvec_putback);\n\t__mod_zone_page_state(zone, NR_MLOCK, delta_munlocked);\n\tspin_unlock_irq(zone_lru_lock(zone));\n\tpagevec_release(&pvec_putback);\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct page *page = pvec->pages[i];\n\t\tif (page) {\n\t\t\tlock_page(page);\n\t\t\tif (!__putback_lru_fast_prepare(page, &pvec_putback,\n\t\t\t\t\t&pgrescued)) {\n\t\t\t\tget_page(page); \n\t\t\t\t__munlock_isolated_page(page);\n\t\t\t\tunlock_page(page);\n\t\t\t\tput_page(page); \n\t\t\t}\n\t\t}\n\t}\n\tif (pagevec_count(&pvec_putback))\n\t\t__putback_lru_fast(&pvec_putback, pgrescued);\n}", "target": 1}
{"code": "void pdo_stmt_init(TSRMLS_D)\n{\n\tzend_class_entry ce;\n\tINIT_CLASS_ENTRY(ce, \"PDOStatement\", pdo_dbstmt_functions);\n\tpdo_dbstmt_ce = zend_register_internal_class(&ce TSRMLS_CC);\n\tpdo_dbstmt_ce->get_iterator = pdo_stmt_iter_get;\n\tpdo_dbstmt_ce->create_object = pdo_dbstmt_new;\n\tzend_class_implements(pdo_dbstmt_ce TSRMLS_CC, 1, zend_ce_traversable);\n\tzend_declare_property_null(pdo_dbstmt_ce, \"queryString\", sizeof(\"queryString\")-1, ZEND_ACC_PUBLIC TSRMLS_CC);\n\tmemcpy(&pdo_dbstmt_object_handlers, &std_object_handlers, sizeof(zend_object_handlers));\n\tpdo_dbstmt_object_handlers.write_property = dbstmt_prop_write;\n\tpdo_dbstmt_object_handlers.unset_property = dbstmt_prop_delete;\n\tpdo_dbstmt_object_handlers.get_method = dbstmt_method_get;\n\tpdo_dbstmt_object_handlers.compare_objects = dbstmt_compare;\n\tpdo_dbstmt_object_handlers.clone_obj = dbstmt_clone_obj;\n\tINIT_CLASS_ENTRY(ce, \"PDORow\", pdo_row_functions);\n\tpdo_row_ce = zend_register_internal_class(&ce TSRMLS_CC);\n\tpdo_row_ce->ce_flags |= ZEND_ACC_FINAL_CLASS; \n\tpdo_row_ce->create_object = pdo_row_new;\n\tpdo_row_ce->serialize = pdo_row_serialize;\n\tpdo_row_ce->unserialize = zend_class_unserialize_deny;", "target": 0}
{"code": "cdf_read_sector(const cdf_info_t *info, void *buf, size_t offs, size_t len,\n    const cdf_header_t *h, cdf_secid_t id)\n{\n\tassert((size_t)CDF_SEC_SIZE(h) == len);\n\treturn cdf_read(info, (off_t)CDF_SEC_POS(h, id),\n\t    ((char *)buf) + offs, len);\n}", "target": 1}
{"code": "void sqlite3SelectReset(Parse *pParse, Select *p){\n  if( ALWAYS(p) ){\n    clearSelect(pParse->db, p, 0);\n    memset(&p->iLimit, 0, sizeof(Select) - offsetof(Select,iLimit));\n    p->pEList = sqlite3ExprListAppend(pParse, 0,\n                     sqlite3ExprAlloc(pParse->db,TK_NULL,0,0));\n    p->pSrc = sqlite3DbMallocZero(pParse->db, sizeof(SrcList));\n  }\n}", "target": 0}
{"code": "static void enable_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tif ((svm->vcpu.arch.hflags & (HF_NMI_MASK | HF_IRET_MASK))\n\t    == HF_NMI_MASK)\n\t\treturn; \n\tsvm->nmi_singlestep = true;\n\tsvm->vmcb->save.rflags |= (X86_EFLAGS_TF | X86_EFLAGS_RF);\n\tupdate_db_bp_intercept(vcpu);\n}", "target": 1}
{"code": "u64 secure_dccpv6_sequence_number(__be32 *saddr, __be32 *daddr,\n\t\t\t\t  __be16 sport, __be16 dport)\n{\n\tu32 secret[MD5_MESSAGE_BYTES / 4];\n\tu32 hash[MD5_DIGEST_WORDS];\n\tu64 seq;\n\tu32 i;\n\tmemcpy(hash, saddr, 16);\n\tfor (i = 0; i < 4; i++)\n\t\tsecret[i] = net_secret[i] + daddr[i];\n\tsecret[4] = net_secret[4] +\n\t\t(((__force u16)sport << 16) + (__force u16)dport);\n\tfor (i = 5; i < MD5_MESSAGE_BYTES / 4; i++)\n\t\tsecret[i] = net_secret[i];\n\tmd5_transform(hash, secret);\n\tseq = hash[0] | (((u64)hash[1]) << 32);\n\tseq += ktime_to_ns(ktime_get_real());\n\tseq &= (1ull << 48) - 1;\n\treturn seq;\n}", "target": 0}
{"code": "static inline int process_nested_data(UNSERIALIZE_PARAMETER, HashTable *ht, long elements, int objprops)\n{\n\twhile (elements-- > 0) {\n\t\tzval *key, *data, **old_data;\n\t\tALLOC_INIT_ZVAL(key);\n\t\tif (!php_var_unserialize(&key, p, max, NULL TSRMLS_CC)) {\n\t\t\tzval_dtor(key);\n\t\t\tFREE_ZVAL(key);\n\t\t\treturn 0;\n\t\t}\n\t\tif (Z_TYPE_P(key) != IS_LONG && Z_TYPE_P(key) != IS_STRING) {\n\t\t\tzval_dtor(key);\n\t\t\tFREE_ZVAL(key);\n\t\t\treturn 0;\n\t\t}\n\t\tALLOC_INIT_ZVAL(data);\n\t\tif (!php_var_unserialize(&data, p, max, var_hash TSRMLS_CC)) {\n\t\t\tzval_dtor(key);\n\t\t\tFREE_ZVAL(key);\n\t\t\tzval_dtor(data);\n\t\t\tFREE_ZVAL(data);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!objprops) {\n\t\t\tswitch (Z_TYPE_P(key)) {\n\t\t\tcase IS_LONG:\n\t\t\t\tif (zend_hash_index_find(ht, Z_LVAL_P(key), (void **)&old_data)==SUCCESS) {\n\t\t\t\t\tvar_push_dtor(var_hash, old_data);\n\t\t\t\t}\n\t\t\t\tzend_hash_index_update(ht, Z_LVAL_P(key), &data, sizeof(data), NULL);\n\t\t\t\tbreak;\n\t\t\tcase IS_STRING:\n\t\t\t\tif (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {\n\t\t\t\t\tvar_push_dtor(var_hash, old_data);\n\t\t\t\t}\n\t\t\t\tzend_symtable_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data, sizeof(data), NULL);\n\t\t\t\tbreak;\n\t\t\t}\n                } else {\n                        convert_to_string(key);\n                       if (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {\n                               var_push_dtor(var_hash, old_data);\n                       }\n                        zend_hash_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data,\n                                        sizeof data, NULL);\n                }\n\t\tif (elements && *(*p-1) != ';' && *(*p-1) != '}') {\n\t\t\t(*p)--;\n\t\t\treturn 0;\n\t\t}\n\t}", "target": 0}
{"code": "find_entry2modify_only(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n    back_txn *txn\n)\n{\n\treturn( find_entry_internal( pb, be, addr, 1, txn, FE_REALLY_INTERNAL ) );\n}", "target": 1}
{"code": "static inline int http_test_encoded_path(const char *mem, size_t len) {\n  const char *pos = NULL;\n  const char *end = mem + len;\n  while (mem < end && (pos = memchr(mem, '/', (size_t)len))) {\n    len = end - pos;\n    mem = pos + 1;\n    if (pos[1] == '/')\n      return -1;\n    if (len > 3 && pos[1] == '.' && pos[2] == '.' && pos[3] == '/')\n      return -1;\n  }\n  return 0;\n}", "target": 0}
{"code": "CertificateValidationContextConfigImpl::getSubjectAltNameMatchers(\n    const envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext& config) {\n  if (!config.match_typed_subject_alt_names().empty() &&\n      !config.match_subject_alt_names().empty()) {\n    throw EnvoyException(\"SAN-based verification using both match_typed_subject_alt_names and \"\n                         \"the deprecated match_subject_alt_names is not allowed\");\n  }\n  std::vector<envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher>\n      subject_alt_name_matchers(config.match_typed_subject_alt_names().begin(),\n                                config.match_typed_subject_alt_names().end());\n  for (const envoy::type::matcher::v3::StringMatcher& matcher : config.match_subject_alt_names()) {\n    static constexpr std::array<\n        envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::SanType, 4>\n        san_types{envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::DNS,\n                  envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::URI,\n                  envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::EMAIL,\n                  envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::IP_ADDRESS};\n    for (const auto san_type : san_types) {\n      subject_alt_name_matchers.emplace_back();\n      subject_alt_name_matchers.back().set_san_type(san_type);\n      *subject_alt_name_matchers.back().mutable_matcher() = matcher;\n    }\n  }\n  return subject_alt_name_matchers;\n}", "target": 0}
{"code": "static void *load_bytes(RBinFile *arch, const ut8 *buf, ut64 sz, ut64 loaddr, Sdb *sdb) {\n\tif (!buf || !sz || sz == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\tRBuffer *tbuf = r_buf_new ();\n\tif (!tbuf) {\n\t\treturn NULL;\n\t}\n\tr_buf_set_bytes (tbuf, buf, sz);\n\tstruct r_bin_bflt_obj *res = r_bin_bflt_new_buf (tbuf);\n\tr_buf_free (tbuf);\n\treturn res ? res : NULL;\n}", "target": 0}
{"code": "void posixtimer_rearm(struct siginfo *info)\n{\n\tstruct k_itimer *timr;\n\tunsigned long flags;\n\ttimr = lock_timer(info->si_tid, &flags);\n\tif (!timr)\n\t\treturn;\n\tif (timr->it_requeue_pending == info->si_sys_private) {\n\t\ttimr->kclock->timer_rearm(timr);\n\t\ttimr->it_active = 1;\n\t\ttimr->it_overrun_last = timr->it_overrun;\n\t\ttimr->it_overrun = -1;\n\t\t++timr->it_requeue_pending;\n\t\tinfo->si_overrun += timr->it_overrun_last;\n\t}\n\tunlock_timer(timr, flags);\n}", "target": 1}
{"code": "int key_reject_and_link(struct key *key,\n\t\t\tunsigned timeout,\n\t\t\tunsigned error,\n\t\t\tstruct key *keyring,\n\t\t\tstruct key *authkey)\n{\n\tstruct assoc_array_edit *edit;\n\tstruct timespec now;\n\tint ret, awaken, link_ret = 0;\n\tkey_check(key);\n\tkey_check(keyring);\n\tawaken = 0;\n\tret = -EBUSY;\n\tif (keyring) {\n\t\tif (keyring->restrict_link)\n\t\t\treturn -EPERM;\n\t\tlink_ret = __key_link_begin(keyring, &key->index_key, &edit);\n\t}\n\tmutex_lock(&key_construction_mutex);\n\tif (key->state == KEY_IS_UNINSTANTIATED) {\n\t\tatomic_inc(&key->user->nikeys);\n\t\tmark_key_instantiated(key, -error);\n\t\tnow = current_kernel_time();\n\t\tkey->expiry = now.tv_sec + timeout;\n\t\tkey_schedule_gc(key->expiry + key_gc_delay);\n\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\tawaken = 1;\n\t\tret = 0;\n\t\tif (keyring && link_ret == 0)\n\t\t\t__key_link(key, &edit);\n\t\tif (authkey)\n\t\t\tkey_revoke(authkey);\n\t}\n\tmutex_unlock(&key_construction_mutex);\n\tif (keyring && link_ret == 0)\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\tif (awaken)\n\t\twake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT);\n\treturn ret == 0 ? link_ret : ret;\n}", "target": 0}
{"code": "cib_remote_command_dispatch(gpointer user_data)\n{\n    int disconnected = 0;\n    cib_t *cib = user_data;\n    cib_remote_opaque_t *private = cib->variant_opaque;\n    crm_recv_remote_msg(private->command.session, &private->command.recv_buf, private->command.encrypted, -1, &disconnected);\n    free(private->command.recv_buf);\n    private->command.recv_buf = NULL;\n    crm_err(\"received late reply for remote cib connection, discarding\");\n    if (disconnected) {\n        return -1;\n    }\n    return 0;\n}", "target": 0}
{"code": "comics_document_finalize (GObject *object)\n{\n\tComicsDocument *comics_document = COMICS_DOCUMENT (object);\n\tif (comics_document->decompress_tmp) {\n\t\tif (comics_remove_dir (comics_document->dir) == -1)\n\t\t\tg_warning (_(\"There was an error deleting %s.\"),\n\t\t\t\t   comics_document->dir);\n\t\tg_free (comics_document->dir);\n\t}\n\tif (comics_document->page_names) {\n                g_ptr_array_foreach (comics_document->page_names, (GFunc) g_free, NULL);\n                g_ptr_array_free (comics_document->page_names, TRUE);\n\t}\n\tg_free (comics_document->archive);\n\tg_free (comics_document->selected_command);\n\tg_free (comics_document->alternative_command);\n\tg_free (comics_document->extract_command);\n\tg_free (comics_document->list_command);\n\tG_OBJECT_CLASS (comics_document_parent_class)->finalize (object);\n}", "target": 1}
{"code": "void recovery_cipher_init(bool passphrase_protection, bool pin_protection,\n                          const char *language, const char *label, bool _enforce_wordlist,\n                          uint32_t _auto_lock_delay_ms, uint32_t _u2f_counter, bool _dry_run)\n{\n    enforce_wordlist = _enforce_wordlist;\n    dry_run = _dry_run;\n    if (!dry_run) {\n        if (pin_protection) {\n            if (!change_pin()) {\n                recovery_abort();\n                fsm_sendFailure(FailureType_Failure_ActionCancelled, \"PINs do not match\");\n                layoutHome();\n                return;\n            }\n        } else {\n            storage_setPin(\"\");\n        }\n        storage_setPassphraseProtected(passphrase_protection);\n        storage_setLanguage(language);\n        storage_setLabel(label);\n        storage_setAutoLockDelayMs(_auto_lock_delay_ms);\n        storage_setU2FCounter(_u2f_counter);\n    } else if (!pin_protect(\"Enter Your PIN\")) {\n        layoutHome();\n        return;\n    }\n    if (!confirm(ButtonRequestType_ButtonRequest_Other,\n                 dry_run ? \"Recovery Dry Run\" : \"Recovery\",\n                 \"When entering your recovery seed, use the substitution cipher \"\n                 \"and check that each word shows up correctly on the screen.\")) {\n        fsm_sendFailure(FailureType_Failure_ActionCancelled, \"Recovery cancelled\");\n        if (!dry_run)\n            storage_reset();\n        layoutHome();\n        return;\n    }\n    memset(mnemonic, 0, sizeof(mnemonic) / sizeof(char));\n    awaiting_character = true;\n    recovery_started = true;\n    next_character();\n}", "target": 0}
{"code": "static int xfrm_dump_policy(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\tBUILD_BUG_ON(sizeof(struct xfrm_policy_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\tif (!cb->args[0]) {\n\t\tcb->args[0] = 1;\n\t\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\n\t}\n\t(void) xfrm_policy_walk(net, walk, dump_one_policy, &info);\n\treturn skb->len;\n}", "target": 1}
{"code": "MagickExport MagickBooleanType LinearStretchImage(Image *image,\n  const double black_point,const double white_point,ExceptionInfo *exception)\n{\n#define LinearStretchImageTag  \"LinearStretch/Image\"\n  CacheView\n    *image_view;\n  double\n    *histogram,\n    intensity;\n  MagickBooleanType\n    status;\n  ssize_t\n    black,\n    white,\n    y;\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  histogram=(double *) AcquireQuantumMemory(MaxMap+1UL,sizeof(*histogram));\n  if (histogram == (double *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  (void) ResetMagickMemory(histogram,0,(MaxMap+1)*sizeof(*histogram));\n  image_view=AcquireVirtualCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n    register ssize_t\n      x;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      intensity=GetPixelIntensity(image,p);\n      histogram[ScaleQuantumToMap(ClampToQuantum(intensity))]++;\n      p+=GetPixelChannels(image);\n    }\n  }\n  image_view=DestroyCacheView(image_view);\n  intensity=0.0;\n  for (black=0; black < (ssize_t) MaxMap; black++)\n  {\n    intensity+=histogram[black];\n    if (intensity >= black_point)\n      break;\n  }\n  intensity=0.0;\n  for (white=(ssize_t) MaxMap; white != 0; white--)\n  {\n    intensity+=histogram[white];\n    if (intensity >= white_point)\n      break;\n  }\n  histogram=(double *) RelinquishMagickMemory(histogram);\n  status=LevelImage(image,(double) ScaleMapToQuantum((MagickRealType) black),\n    (double) ScaleMapToQuantum((MagickRealType) white),1.0,exception);\n  return(status);\n}", "target": 0}
{"code": "smb_com_flush(smb_request_t *sr)\n{\n\tsmb_ofile_t\t*file;\n\tsmb_llist_t\t*flist;\n\tint\t\trc;\n\tif (smb_flush_required == 0) {\n\t\trc = smbsr_encode_empty_result(sr);\n\t\treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n\t}\n\tif (sr->smb_fid != 0xffff) {\n\t\tsmbsr_lookup_file(sr);\n\t\tif (sr->fid_ofile == NULL) {\n\t\t\tsmbsr_error(sr, NT_STATUS_INVALID_HANDLE,\n\t\t\t    ERRDOS, ERRbadfid);\n\t\t\treturn (SDRC_ERROR);\n\t\t}\n\t\tsmb_flush_file(sr, sr->fid_ofile);\n\t} else {\n\t\tflist = &sr->tid_tree->t_ofile_list;\n\t\tsmb_llist_enter(flist, RW_READER);\n\t\tfile = smb_llist_head(flist);\n\t\twhile (file) {\n\t\t\tmutex_enter(&file->f_mutex);\n\t\t\tsmb_flush_file(sr, file);\n\t\t\tmutex_exit(&file->f_mutex);\n\t\t\tfile = smb_llist_next(flist, file);\n\t\t}\n\t\tsmb_llist_exit(flist);\n\t}\n\trc = smbsr_encode_empty_result(sr);\n\treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n}", "target": 1}
{"code": "CharString *Formattable::internalGetCharString(UErrorCode &status) {\n    if(fDecimalStr == NULL) {\n      if (fDecimalQuantity == NULL) {\n        LocalPointer<DecimalQuantity> dq(new DecimalQuantity(), status);\n        if (U_FAILURE(status)) { return nullptr; }\n        populateDecimalQuantity(*dq, status);\n        if (U_FAILURE(status)) { return nullptr; }\n        fDecimalQuantity = dq.orphan();\n      }\n      fDecimalStr = new CharString();\n      if (fDecimalStr == NULL) {\n        status = U_MEMORY_ALLOCATION_ERROR;\n        return NULL;\n      }\n      if (fDecimalQuantity->isZero()) {\n        fDecimalStr->append(\"0\", -1, status);\n      } else if (std::abs(fDecimalQuantity->getMagnitude()) < 5) {\n        fDecimalStr->appendInvariantChars(fDecimalQuantity->toPlainString(), status);\n      } else {\n        fDecimalStr->appendInvariantChars(fDecimalQuantity->toScientificString(), status);\n      }\n    }\n    return fDecimalStr;\n}", "target": 1}
{"code": "static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)\n{\n\tint rlen, remain;\n\tdpIOCtxPtr dctx;\n\tdynamicPtr *dp;\n\tdctx = (dpIOCtxPtr) ctx;\n\tdp = dctx->dp;\n\tif (dp->pos < 0 || dp->pos >= dp->realSize) {\n\t\treturn 0;\n\t}\n\tremain = dp->logicalSize - dp->pos;\n\tif(remain >= len) {\n\t\trlen = len;\n\t} else {\n\t\tif(remain <= 0) {\n\t\t\treturn 0;\n\t\t}\n\t\trlen = remain;\n\t}\n\tif (dp->pos + rlen > dp->realSize) {\n\t\trlen = dp->realSize - dp->pos;\n\t}\n\tmemcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);\n\tdp->pos += rlen;\n\treturn rlen;\n}", "target": 0}
{"code": "struct sock *dccp_v4_request_recv_sock(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t       struct request_sock *req,\n\t\t\t\t       struct dst_entry *dst)\n{\n\tstruct inet_request_sock *ireq;\n\tstruct inet_sock *newinet;\n\tstruct sock *newsk;\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto exit_overflow;\n\tif (dst == NULL && (dst = inet_csk_route_req(sk, req)) == NULL)\n\t\tgoto exit;\n\tnewsk = dccp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto exit_nonewsk;\n\tsk_setup_caps(newsk, dst);\n\tnewinet\t\t   = inet_sk(newsk);\n\tireq\t\t   = inet_rsk(req);\n\tnewinet->inet_daddr\t= ireq->rmt_addr;\n\tnewinet->inet_rcv_saddr = ireq->loc_addr;\n\tnewinet->inet_saddr\t= ireq->loc_addr;\n\tnewinet->opt\t   = ireq->opt;\n\tireq->opt\t   = NULL;\n\tnewinet->mc_index  = inet_iif(skb);\n\tnewinet->mc_ttl\t   = ip_hdr(skb)->ttl;\n\tnewinet->inet_id   = jiffies;\n\tdccp_sync_mss(newsk, dst_mtu(dst));\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tsock_put(newsk);\n\t\tgoto exit;\n\t}\n\t__inet_hash_nolisten(newsk, NULL);\n\treturn newsk;\nexit_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nexit_nonewsk:\n\tdst_release(dst);\nexit:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}", "target": 1}
{"code": "int luaG_traceexec (lua_State *L, const Instruction *pc) {\n  CallInfo *ci = L->ci;\n  lu_byte mask = L->hookmask;\n  int counthook;\n  if (!(mask & (LUA_MASKLINE | LUA_MASKCOUNT))) {  \n    ci->u.l.trap = 0;  \n    return 0;  \n  }\n  pc++;  \n  ci->u.l.savedpc = pc;  \n  counthook = (--L->hookcount == 0 && (mask & LUA_MASKCOUNT));\n  if (counthook)\n    resethookcount(L);  \n  else if (!(mask & LUA_MASKLINE))\n    return 1;  \n  if (ci->callstatus & CIST_HOOKYIELD) {  \n    ci->callstatus &= ~CIST_HOOKYIELD;  \n    return 1;  \n  }\n  if (!isIT(*(ci->u.l.savedpc - 1)))\n    L->top = ci->top;  \n  if (counthook)\n    luaD_hook(L, LUA_HOOKCOUNT, -1, 0, 0);  \n  if (mask & LUA_MASKLINE) {\n    const Proto *p = ci_func(ci)->p;\n    int npci = pcRel(pc, p);\n    if (npci == 0 ||  \n        pc <= L->oldpc ||  \n        changedline(p, pcRel(L->oldpc, p), npci)) {  \n      int newline = luaG_getfuncline(p, npci);\n      luaD_hook(L, LUA_HOOKLINE, newline, 0, 0);  \n    }\n    L->oldpc = pc;  \n  }\n  if (L->status == LUA_YIELD) {  \n    if (counthook)\n      L->hookcount = 1;  \n    ci->u.l.savedpc--;  \n    ci->callstatus |= CIST_HOOKYIELD;  \n    luaD_throw(L, LUA_YIELD);\n  }\n  return 1;  \n}", "target": 1}
{"code": "static bool __init is_skylake_era(void)\n{\n\tif (boot_cpu_data.x86_vendor == X86_VENDOR_INTEL &&\n\t    boot_cpu_data.x86 == 6) {\n\t\tswitch (boot_cpu_data.x86_model) {\n\t\tcase INTEL_FAM6_SKYLAKE_MOBILE:\n\t\tcase INTEL_FAM6_SKYLAKE_DESKTOP:\n\t\tcase INTEL_FAM6_SKYLAKE_X:\n\t\tcase INTEL_FAM6_KABYLAKE_MOBILE:\n\t\tcase INTEL_FAM6_KABYLAKE_DESKTOP:\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 1}
{"code": "snmp_mib_find(uint32_t *oid)\n{\n  snmp_mib_resource_t *resource;\n  resource = NULL;\n  for(resource = list_head(snmp_mib);\n      resource; resource = resource->next) {\n    if(!snmp_oid_cmp_oid(oid, resource->oid)) {\n      return resource;\n    }\n  }\n  return NULL;\n}", "target": 1}
{"code": "sraSpanInsertBefore(sraSpan *newspan, sraSpan *before) {\n  newspan->_next = before;\n  newspan->_prev = before->_prev;\n  before->_prev->_next = newspan;\n  before->_prev = newspan;\n}", "target": 1}
{"code": "static void ossl_disassociate_connection(struct Curl_easy *data,\n                                         int sockindex)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  if(!backend->handle)\n    return;\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    bool isproxy = FALSE;\n    bool incache;\n    void *old_ssl_sessionid = NULL;\n    int data_idx = ossl_get_ssl_data_index();\n    int connectdata_idx = ossl_get_ssl_conn_index();\n    int sockindex_idx = ossl_get_ssl_sockindex_index();\n    int proxy_idx = ossl_get_proxy_index();\n    if(data_idx >= 0 && connectdata_idx >= 0 && sockindex_idx >= 0 &&\n       proxy_idx >= 0) {\n      isproxy = SSL_get_ex_data(backend->handle, proxy_idx) ? TRUE : FALSE;\n      SSL_set_ex_data(backend->handle, data_idx, NULL);\n      SSL_set_ex_data(backend->handle, connectdata_idx, NULL);\n      SSL_set_ex_data(backend->handle, sockindex_idx, NULL);\n      SSL_set_ex_data(backend->handle, proxy_idx, NULL);\n    }\n    Curl_ssl_sessionid_lock(data);\n    incache = !(Curl_ssl_getsessionid(data, conn, isproxy,\n                                      &old_ssl_sessionid, NULL, sockindex));\n    if(incache)\n      Curl_ssl_delsessionid(data, old_ssl_sessionid);\n    Curl_ssl_sessionid_unlock(data);\n  }\n}", "target": 0}
{"code": "void is888Tests()\n{\n    printf(\"Simple format detection:\\n\\n\");\n    do888Test(true, 32, 24, false, true, 255, 255, 255, 0, 8, 16);\n    do888Test(true, 32, 24, false, true, 255, 255, 255, 24, 16, 8);\n    do888Test(true, 32, 24, false, true, 255, 255, 255, 24, 8, 0);\n    do888Test(false, 32, 16, false, true, 15, 31, 15, 0, 8, 16);\n    do888Test(false, 32, 8, false, true, 3, 7, 3, 0, 8, 16);\n    do888Test(false, 16, 16, false, true, 15, 31, 15, 0, 5, 11);\n    do888Test(false, 8, 8, false, true, 3, 7, 3, 0, 2, 5);\n    do888Test(false, 8, 8, false, false, 0, 0, 0, 0, 0, 0);\n    do888Test(false, 32, 24, false, true, 255, 255, 255, 0, 8, 18);\n    do888Test(false, 32, 24, false, true, 255, 255, 255, 0, 11, 24);\n    do888Test(false, 32, 24, false, true, 255, 255, 255, 4, 16, 24);\n    printf(\"\\n\");\n}", "target": 0}
{"code": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\tif (inode_capable(inode, CAP_FOWNER))\n\t\treturn true;\n\treturn false;\n}", "target": 1}
{"code": "gss_process_context_token (minor_status,\n                           context_handle,\n                           token_buffer)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_buffer_t\t\ttoken_buffer;\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n    *minor_status = 0;\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n    if (token_buffer == GSS_C_NO_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n    if (GSS_EMPTY_BUFFER(token_buffer))\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech) {\n\tif (mech->gss_process_context_token) {\n\t    status = mech->gss_process_context_token(\n\t\t\t\t\t\t    minor_status,\n\t\t\t\t\t\t    ctx->internal_ctx_id,\n\t\t\t\t\t\t    token_buffer);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\treturn(status);\n    }\n    return (GSS_S_BAD_MECH);\n}", "target": 0}
{"code": "static int rsi_send_beacon(struct rsi_common *common)\n{\n\tstruct sk_buff *skb = NULL;\n\tu8 dword_align_bytes = 0;\n\tskb = dev_alloc_skb(MAX_MGMT_PKT_SIZE);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tmemset(skb->data, 0, MAX_MGMT_PKT_SIZE);\n\tdword_align_bytes = ((unsigned long)skb->data & 0x3f);\n\tif (dword_align_bytes)\n\t\tskb_pull(skb, (64 - dword_align_bytes));\n\tif (rsi_prepare_beacon(common, skb)) {\n\t\trsi_dbg(ERR_ZONE, \"Failed to prepare beacon\\n\");\n\t\tdev_kfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\tskb_queue_tail(&common->tx_queue[MGMT_BEACON_Q], skb);\n\trsi_set_event(&common->tx_thread.event);\n\trsi_dbg(DATA_TX_ZONE, \"%s: Added to beacon queue\\n\", __func__);\n\treturn 0;\n}", "target": 0}
{"code": "static int __do_page_fault(struct mm_struct *mm, unsigned long addr,\n\t\t\t   unsigned int mm_flags, unsigned long vm_flags,\n\t\t\t   struct task_struct *tsk)\n{\n\tstruct vm_area_struct *vma;\n\tint fault;\n\tvma = find_vma(mm, addr);\n\tfault = VM_FAULT_BADMAP;\n\tif (unlikely(!vma))\n\t\tgoto out;\n\tif (unlikely(vma->vm_start > addr))\n\t\tgoto check_stack;\ngood_area:\n\tif (!(vma->vm_flags & vm_flags)) {\n\t\tfault = VM_FAULT_BADACCESS;\n\t\tgoto out;\n\t}\n\treturn handle_mm_fault(mm, vma, addr & PAGE_MASK, mm_flags);\ncheck_stack:\n\tif (vma->vm_flags & VM_GROWSDOWN && !expand_stack(vma, addr))\n\t\tgoto good_area;\nout:\n\treturn fault;\n}", "target": 1}
{"code": "ospf_ls_ack_send_delayed (struct ospf_interface *oi)\n{\n  struct in_addr dst;\n  if (oi->type == OSPF_IFTYPE_NBMA)\n    {\n      struct ospf_neighbor *nbr;\n      struct route_node *rn;\n      for (rn = route_top (oi->nbrs); rn; rn = route_next (rn))\n\tif ((nbr = rn->info) != NULL)\n\t  if (nbr != oi->nbr_self && nbr->state >= NSM_Exchange)\n\t    while (listcount (oi->ls_ack))\n\t      ospf_ls_ack_send_list (oi, oi->ls_ack, nbr->address.u.prefix4);\n      return;\n    }\n  if (oi->type == OSPF_IFTYPE_VIRTUALLINK)\n    dst.s_addr = oi->vl_data->peer_addr.s_addr;\n  else if (oi->state == ISM_DR || oi->state == ISM_Backup)\n    dst.s_addr = htonl (OSPF_ALLSPFROUTERS);\n  else if (oi->type == OSPF_IFTYPE_POINTOPOINT)\n    dst.s_addr = htonl (OSPF_ALLSPFROUTERS);\n  else if (oi->type == OSPF_IFTYPE_POINTOMULTIPOINT)\n    dst.s_addr = htonl (OSPF_ALLSPFROUTERS);\n  else\n    dst.s_addr = htonl (OSPF_ALLDROUTERS);\n  while (listcount (oi->ls_ack))\n    ospf_ls_ack_send_list (oi, oi->ls_ack, dst);\n}", "target": 0}
{"code": "static int wcd9335_codec_find_amic_input(struct snd_soc_component *comp,\n\t\t\t\t\t int adc_mux_n)\n{\n\tint mux_sel, reg, mreg;\n\tif (adc_mux_n < 0 || adc_mux_n > WCD9335_MAX_VALID_ADC_MUX ||\n\t    adc_mux_n == WCD9335_INVALID_ADC_MUX)\n\t\treturn 0;\n\tif (adc_mux_n < 4) {\n\t\treg = WCD9335_CDC_TX_INP_MUX_ADC_MUX0_CFG1 + 2 * adc_mux_n;\n\t\tmreg = WCD9335_CDC_TX_INP_MUX_ADC_MUX0_CFG0 + 2 * adc_mux_n;\n\t\tmux_sel = snd_soc_component_read32(comp, reg) & 0x3;\n\t} else {\n\t\treg = WCD9335_CDC_TX_INP_MUX_ADC_MUX4_CFG0 + adc_mux_n - 4;\n\t\tmreg = reg;\n\t\tmux_sel = snd_soc_component_read32(comp, reg) >> 6;\n\t}\n\tif (mux_sel != WCD9335_CDC_TX_INP_MUX_SEL_AMIC)\n\t\treturn 0;\n\treturn snd_soc_component_read32(comp, mreg) & 0x07;\n}", "target": 0}
{"code": "static inline bool sctp_peer_needs_update(struct sctp_association *asoc)\n{\n\tstruct net *net = sock_net(asoc->base.sk);\n\tswitch (asoc->state) {\n\tcase SCTP_STATE_ESTABLISHED:\n\tcase SCTP_STATE_SHUTDOWN_PENDING:\n\tcase SCTP_STATE_SHUTDOWN_RECEIVED:\n\tcase SCTP_STATE_SHUTDOWN_SENT:\n\t\tif ((asoc->rwnd > asoc->a_rwnd) &&\n\t\t    ((asoc->rwnd - asoc->a_rwnd) >= max_t(__u32,\n\t\t\t   (asoc->base.sk->sk_rcvbuf >> net->sctp.rwnd_upd_shift),\n\t\t\t   asoc->pathmtu)))\n\t\t\treturn true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn false;\n}", "target": 0}
{"code": "static int call_function(cfg_t *cfg, cfg_opt_t *opt, cfg_opt_t *funcopt)\n{\n\tint ret;\n\tconst char **argv;\n\tunsigned int i;\n\tif (!cfg || !opt ||!funcopt) {\n\t\terrno = EINVAL;\n\t\treturn CFG_FAIL;\n\t}\n\targv = calloc(funcopt->nvalues, sizeof(char *));\n\tif (!argv)\n\t\treturn CFG_FAIL;\n\tfor (i = 0; i < funcopt->nvalues; i++)\n\t\targv[i] = funcopt->values[i]->string;\n\tret = (*opt->func) (cfg, opt, funcopt->nvalues, argv);\n\tcfg_free_value(funcopt);\n\tfree(argv);\n\treturn ret;\n}", "target": 0}
{"code": "static uint8_t avrcp_handle_abort_continuing(struct avrcp *session,\n\t\t\t\t\t\tstruct avrcp_header *pdu,\n\t\t\t\t\t\tuint8_t transaction)\n{\n\tuint16_t len = ntohs(pdu->params_len);\n\tstruct pending_pdu *pending;\n\tif (len != 1 || session->pending_pdu == NULL)\n\t\tgoto err;\n\tpending = session->pending_pdu;\n\tif (pending->pdu_id != pdu->params[0])\n\t\tgoto err;\n\tsession_abort_pending_pdu(session);\n\tpdu->params_len = 0;\n\treturn AVC_CTYPE_ACCEPTED;\nerr:\n\tpdu->params_len = htons(1);\n\tpdu->params[0] = AVRCP_STATUS_INVALID_PARAM;\n\treturn AVC_CTYPE_REJECTED;\n}", "target": 0}
{"code": "png_check_chunk_length(png_const_structrp png_ptr, const png_uint_32 length)\n{\n   png_alloc_size_t limit = PNG_UINT_31_MAX;\n# ifdef PNG_SET_USER_LIMITS_SUPPORTED\n   if (png_ptr->user_chunk_malloc_max > 0 &&\n       png_ptr->user_chunk_malloc_max < limit)\n      limit = png_ptr->user_chunk_malloc_max;\n# elif PNG_USER_CHUNK_MALLOC_MAX > 0\n   if (PNG_USER_CHUNK_MALLOC_MAX < limit)\n      limit = PNG_USER_CHUNK_MALLOC_MAX;\n# endif\n   if (png_ptr->chunk_name == png_IDAT)\n   {\n      png_alloc_size_t idat_limit = PNG_UINT_31_MAX;\n      size_t row_factor =\n         (png_ptr->width * png_ptr->channels * (png_ptr->bit_depth > 8? 2: 1)\n          + 1 + (png_ptr->interlaced? 6: 0));\n      if (png_ptr->height > PNG_UINT_32_MAX/row_factor)\n         idat_limit=PNG_UINT_31_MAX;\n      else\n         idat_limit = png_ptr->height * row_factor;\n      row_factor = row_factor > 32566? 32566 : row_factor;\n      idat_limit += 6 + 5*(idat_limit/row_factor+1); \n      idat_limit=idat_limit < PNG_UINT_31_MAX? idat_limit : PNG_UINT_31_MAX;\n      limit = limit < idat_limit? idat_limit : limit;\n   }\n   if (length > limit)\n   {\n      png_debug2(0,\" length = %lu, limit = %lu\",\n         (unsigned long)length,(unsigned long)limit);\n      png_chunk_error(png_ptr, \"chunk data is too large\");\n   }\n}", "target": 1}
{"code": "int __init nfc_llcp_sock_init(void)\n{\n\treturn nfc_proto_register(&llcp_nfc_proto);\n}", "target": 0}
{"code": "static int can_open_cached(struct nfs4_state *state, int mode)\n{\n\tint ret = 0;\n\tswitch (mode & (FMODE_READ|FMODE_WRITE|O_EXCL)) {\n\t\tcase FMODE_READ:\n\t\t\tret |= test_bit(NFS_O_RDONLY_STATE, &state->flags) != 0;\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tret |= test_bit(NFS_O_WRONLY_STATE, &state->flags) != 0;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tret |= test_bit(NFS_O_RDWR_STATE, &state->flags) != 0;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "  virtual bool ms_verify_authorizer(Connection *con,\n\t\t\t\t    int peer_type,\n\t\t\t\t    int protocol,\n\t\t\t\t    ceph::bufferlist& authorizer,\n\t\t\t\t    ceph::bufferlist& authorizer_reply,\n\t\t\t\t    bool& isvalid,\n\t\t\t\t    CryptoKey& session_key) { return false; }", "target": 1}
{"code": "bool ecdsa_verify_legacy(const ecdsa_verify_context_t *ctx, const ecc_25519_work_t *pubkey) {\n  ecc_25519_work_t s2, work;\n  ecc_int256_t w, tmp;\n  if (ecc_25519_gf_is_zero(&ctx->r))\n    return false;\n  ecc_25519_scalarmult(&s2, &ctx->u2, pubkey);\n  ecc_25519_add(&work, &ctx->s1, &s2);\n  ecc_25519_store_xy_legacy(&w, NULL, &work);\n  ecc_25519_gf_sub(&tmp, &ctx->r, &w);\n  return ecc_25519_gf_is_zero(&tmp);\n}", "target": 0}
{"code": "static int bnx2x_vlan_rx_add_vid(struct net_device *dev, __be16 proto, u16 vid)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tstruct bnx2x_vlan_entry *vlan;\n\tDP(NETIF_MSG_IFUP, \"Adding VLAN %d\\n\", vid);\n\tvlan = kmalloc(sizeof(*vlan), GFP_KERNEL);\n\tif (!vlan)\n\t\treturn -ENOMEM;\n\tvlan->vid = vid;\n\tvlan->hw = false;\n\tlist_add_tail(&vlan->link, &bp->vlan_reg);\n\tif (netif_running(dev))\n\t\tbnx2x_vlan_configure(bp, true);\n\treturn 0;\n}", "target": 0}
{"code": "  Status CalculateOutputIndexRowSplit(\n      const RowPartitionTensor& row_split,\n      const vector<INDEX_TYPE>& parent_output_index,\n      INDEX_TYPE output_index_multiplier, INDEX_TYPE output_size,\n      vector<INDEX_TYPE>* result) {\n    INDEX_TYPE row_split_size = row_split.size();\n    if (row_split_size > 0) {\n      result->reserve(row_split(row_split_size - 1));\n    }\n    for (INDEX_TYPE i = 0; i < row_split_size - 1; ++i) {\n      INDEX_TYPE row_length = row_split(i + 1) - row_split(i);\n      INDEX_TYPE real_length = std::min(output_size, row_length);\n      INDEX_TYPE parent_output_index_current = parent_output_index[i];\n      if (parent_output_index_current == -1) {\n        real_length = 0;\n      }\n      for (INDEX_TYPE j = 0; j < real_length; ++j) {\n        result->push_back(parent_output_index_current);\n        parent_output_index_current += output_index_multiplier;\n      }\n      for (INDEX_TYPE j = 0; j < row_length - real_length; ++j) {\n        result->push_back(-1);\n      }\n    }\n    if (row_split_size > 0 && result->size() != row_split(row_split_size - 1)) {\n      return errors::InvalidArgument(\"Invalid row split size.\");\n    }\n    return Status::OK();\n  }", "target": 0}
{"code": "void FIO_TLS_WEAK fio_tls_destroy(fio_tls_s *tls) {\n  if (!tls)\n    return;\n  REQUIRE_LIBRARY();\n  if (fio_atomic_sub(&tls->ref, 1))\n    return;\n  fio_tls_destroy_context(tls);\n  alpn_list_free(&tls->alpn);\n  cert_ary_free(&tls->sni);\n  trust_ary_free(&tls->trust);\n  free(tls);\n}", "target": 0}
{"code": "static void do_free_publickey(struct rsa_public_key *key)\n{\n\tcrypto_bignum_free(key->e);\n\tcrypto_bignum_free(key->n);\n}", "target": 1}
{"code": "void HTTPSession::onCertificateRequest(uint16_t requestId,\n                                       std::unique_ptr<IOBuf> authRequest) {\n  DestructorGuard dg(this);\n  VLOG(4) << \"CERTIFICATE_REQUEST on\" << *this << \", requestId=\" << requestId;\n  if (!secondAuthManager_) {\n    return;\n  }\n  std::pair<uint16_t, std::unique_ptr<folly::IOBuf>> authenticator;\n  auto fizzBase = getTransport()->getUnderlyingTransport<AsyncFizzBase>();\n  if (fizzBase) {\n    if (isUpstream()) {\n      authenticator =\n          secondAuthManager_->getAuthenticator(*fizzBase,\n                                               TransportDirection::UPSTREAM,\n                                               requestId,\n                                               std::move(authRequest));\n    } else {\n      authenticator =\n          secondAuthManager_->getAuthenticator(*fizzBase,\n                                               TransportDirection::DOWNSTREAM,\n                                               requestId,\n                                               std::move(authRequest));\n    }\n  } else {\n    VLOG(4) << \"Underlying transport does not support secondary \"\n               \"authentication.\";\n    return;\n  }\n  if (codec_->generateCertificate(writeBuf_,\n                                  authenticator.first,\n                                  std::move(authenticator.second)) > 0) {\n    scheduleWrite();\n  }\n}", "target": 0}
{"code": "int create_history_entry(krb5_context context,\n                         krb5_keyblock *hist_key, int n_key_data,\n                         krb5_key_data *key_data, osa_pw_hist_ent *hist)\n{\n    krb5_error_code ret;\n    krb5_keyblock key;\n    krb5_keysalt salt;\n    int i;\n    hist->key_data = k5calloc(n_key_data, sizeof(krb5_key_data), &ret);\n    if (hist->key_data == NULL)\n        return ret;\n    for (i = 0; i < n_key_data; i++) {\n        ret = krb5_dbe_decrypt_key_data(context, NULL, &key_data[i], &key,\n                                        &salt);\n        if (ret)\n            return ret;\n        ret = krb5_dbe_encrypt_key_data(context, hist_key, &key, &salt,\n                                        key_data[i].key_data_kvno,\n                                        &hist->key_data[i]);\n        if (ret)\n            return ret;\n        krb5_free_keyblock_contents(context, &key);\n    }\n    hist->n_key_data = n_key_data;\n    return 0;\n}", "target": 0}
{"code": "inline PointerReader ListReader::getPointerElement(ElementCount index) const {\n  return PointerReader(segment, capTable, reinterpret_cast<const WirePointer*>(\n      ptr + upgradeBound<uint64_t>(index) * step / BITS_PER_BYTE), nestingLimit);\n}", "target": 1}
{"code": "static void nft_objref_map_activate(const struct nft_ctx *ctx,\n\t\t\t\t    const struct nft_expr *expr)\n{\n\tstruct nft_objref_map *priv = nft_expr_priv(expr);\n\tpriv->set->use++;\n}", "target": 1}
{"code": "ansi_step(pansi, ch)\n\tstruct ansi_state *pansi;\n\tLWCHAR ch;\n{\n\tif (pansi->hlink)\n\t{\n\t\tif (ch == '\\7')\n\t\t\treturn ANSI_END;\n\t\tif (pansi->prev_esc && ch == '\\\\')\n\t\t\treturn ANSI_END;\n\t\tpansi->prev_esc = (ch == ESC);\n\t\treturn ANSI_MID;\n\t}\n\tif (pansi->hindex >= 0)\n\t{\n\t\tstatic char hlink_prefix[] = ESCS \"]8;\";\n\t\tif (ch == hlink_prefix[pansi->hindex] ||\n\t\t    (pansi->hindex == 0 && IS_CSI_START(ch)))\n\t\t{\n\t\t\tpansi->hindex++;\n\t\t\tif (hlink_prefix[pansi->hindex] == '\\0')\n\t\t\t\tpansi->hlink = 1; \n\t\t\treturn ANSI_MID;\n\t\t}\n\t\tpansi->hindex = -1; \n\t}\n\tif (is_ansi_middle(ch))\n\t\treturn ANSI_MID;\n\tif (is_ansi_end(ch))\n\t\treturn ANSI_END;\n\treturn ANSI_ERR;\n}", "target": 1}
{"code": "int mongo_env_write_socket( mongo *conn, const void *buf, int len ) {\n    const char *cbuf = buf;\n    int flags = 0;\n    while ( len ) {\n        int sent = send( conn->sock, cbuf, len, flags );\n        if ( sent == -1 ) {\n            __mongo_set_error( conn, MONGO_IO_ERROR, NULL, WSAGetLastError() );\n            conn->connected = 0;\n            return MONGO_ERROR;\n        }\n        cbuf += sent;\n        len -= sent;\n    }\n    return MONGO_OK;\n}", "target": 1}
{"code": "void poly_frommsg(poly *r, const uint8_t msg[KYBER_INDCPA_MSGBYTES])\n{\n  unsigned int i,j;\n  int16_t mask;\n#if (KYBER_INDCPA_MSGBYTES != KYBER_N/8)\n#error \"KYBER_INDCPA_MSGBYTES must be equal to KYBER_N/8 bytes!\"\n#endif\n  for(i=0;i<KYBER_N/8;i++) {\n    for(j=0;j<8;j++) {\n      mask = -(int16_t)((msg[i] >> j)&1);\n      r->coeffs[8*i+j] = mask & ((KYBER_Q+1)/2);\n    }\n  }\n}", "target": 1}
{"code": "Http::FilterMetadataStatus Context::onResponseMetadata() {\n  if (!wasm_->onResponseMetadata_) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  if (wasm_->onResponseMetadata_(this, id_).u64_ == 0) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  return Http::FilterMetadataStatus::Continue; \n}", "target": 1}
{"code": "pf_remove_divert_state(struct pf_state_key *sk)\n{\n\tstruct pf_state_item\t*si;\n\tPF_ASSERT_UNLOCKED();\n\tPF_LOCK();\n\tPF_STATE_ENTER_WRITE();\n\tTAILQ_FOREACH(si, &sk->sk_states, si_entry) {\n\t\tstruct pf_state *sist = si->si_st;\n\t\tif (sk == sist->key[PF_SK_STACK] && sist->rule.ptr &&\n\t\t    (sist->rule.ptr->divert.type == PF_DIVERT_TO ||\n\t\t     sist->rule.ptr->divert.type == PF_DIVERT_REPLY)) {\n\t\t\tif (sist->key[PF_SK_STACK]->proto == IPPROTO_TCP &&\n\t\t\t    sist->key[PF_SK_WIRE] != sist->key[PF_SK_STACK]) {\n\t\t\t\tif (sist->src.state < TCPS_FIN_WAIT_2 ||\n\t\t\t\t    sist->dst.state < TCPS_FIN_WAIT_2) {\n\t\t\t\t\tpf_set_protostate(sist, PF_PEER_BOTH,\n\t\t\t\t\t    TCPS_TIME_WAIT);\n\t\t\t\t\tsist->timeout = PFTM_TCP_CLOSED;\n\t\t\t\t\tsist->expire = getuptime();\n\t\t\t\t}\n\t\t\t\tsist->state_flags |= PFSTATE_INP_UNLINKED;\n\t\t\t} else\n\t\t\t\tpf_remove_state(sist);\n\t\t\tbreak;\n\t\t}\n\t}\n\tPF_STATE_EXIT_WRITE();\n\tPF_UNLOCK();\n}", "target": 1}
{"code": "http_DissectRequest(struct sess *sp)\n{\n\tstruct http_conn *htc;\n\tstruct http *hp;\n\tuint16_t retval;\n\tCHECK_OBJ_NOTNULL(sp, SESS_MAGIC);\n\thtc = sp->htc;\n\tCHECK_OBJ_NOTNULL(htc, HTTP_CONN_MAGIC);\n\thp = sp->http;\n\tCHECK_OBJ_NOTNULL(hp, HTTP_MAGIC);\n\thp->logtag = HTTP_Rx;\n\tretval = http_splitline(sp->wrk, sp->fd, hp, htc,\n\t    HTTP_HDR_REQ, HTTP_HDR_URL, HTTP_HDR_PROTO);\n\tif (retval != 0) {\n\t\tWSPR(sp, SLT_HttpGarbage, htc->rxbuf);\n\t\treturn (retval);\n\t}\n\thttp_ProtoVer(hp);\n\tretval = htc_request_check_host_hdr(hp);\n\tif (retval != 0) {\n\t\tWSP(sp, SLT_Error, \"Duplicated Host header\");\n\t\treturn (retval);\n\t}\n\treturn (retval);\n}", "target": 1}
{"code": "static void __sco_chan_add(struct sco_conn *conn, struct sock *sk,\n\t\t\t   struct sock *parent)\n{\n\tBT_DBG(\"conn %p\", conn);\n\tsco_pi(sk)->conn = conn;\n\tconn->sk = sk;\n\tINIT_DELAYED_WORK(&conn->timeout_work, sco_sock_timeout);\n\tif (parent)\n\t\tbt_accept_enqueue(parent, sk, true);\n}", "target": 0}
{"code": "int64_t TensorByteSize(const TensorProto& t) {\n  int64_t num_elems = TensorShape(t.tensor_shape()).num_elements();\n  return num_elems < 0 ? -1 : num_elems * DataTypeSize(t.dtype());\n}", "target": 1}
{"code": "static void l2tp_eth_dev_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\tdev->netdev_ops\t\t= &l2tp_eth_netdev_ops;\n\tdev->destructor\t\t= free_netdev;\n}", "target": 1}
{"code": "int db__message_store_find(struct mosquitto *context, uint16_t mid, struct mosquitto_msg_store **stored)\n{\n\tstruct mosquitto_client_msg *tail;\n\tif(!context) return MOSQ_ERR_INVAL;\n\t*stored = NULL;\n\tDL_FOREACH(context->msgs_in.inflight, tail){\n\t\tif(tail->store->source_mid == mid){\n\t\t\t*stored = tail->store;\n\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t}\n\t}\n\tDL_FOREACH(context->msgs_in.queued, tail){\n\t\tif(tail->store->source_mid == mid){\n\t\t\t*stored = tail->store;\n\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t}\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "static inline unsigned long do_div_llr(const long long dividend,\n\t\t\t\t       const long divisor, long *remainder)\n{\n\tu64 result = dividend;\n\t*(remainder) = do_div(result, divisor);\n\treturn (unsigned long) result;\n}", "target": 1}
{"code": "cib_remote_connection_destroy(gpointer user_data)\n{\n    cib_client_t *client = user_data;\n    int csock = 0;\n    if (client == NULL) {\n        return;\n    }\n    crm_trace(\"Cleaning up after client disconnect: %s/%s\",\n              crm_str(client->name), client->id);\n    if (client->id != NULL) {\n        if (!g_hash_table_remove(client_list, client->id)) {\n            crm_err(\"Client %s not found in the hashtable\", client->name);\n        }\n    }\n    crm_trace(\"Destroying %s (%p)\", client->name, user_data);\n    num_clients--;\n    crm_trace(\"Num unfree'd clients: %d\", num_clients);\n    if (client->remote_auth_timeout) {\n        g_source_remove(client->remote_auth_timeout);\n    }\n    if (client->encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        if (client->session) {\n            void *sock_ptr = gnutls_transport_get_ptr(*client->session);\n            csock = GPOINTER_TO_INT(sock_ptr);\n            if (client->handshake_complete) {\n                gnutls_bye(*client->session, GNUTLS_SHUT_WR);\n            }\n            gnutls_deinit(*client->session);\n            gnutls_free(client->session);\n        }\n#endif\n    } else {\n        csock = GPOINTER_TO_INT(client->session);\n    }\n    client->session = NULL;\n    if (csock > 0) {\n        close(csock);\n    }\n    free(client->name);\n    free(client->callback_id);\n    free(client->id);\n    free(client->user);\n    free(client->recv_buf);\n    free(client);\n    crm_trace(\"Freed the cib client\");\n    if (cib_shutdown_flag) {\n        cib_shutdown(0);\n    }\n    return;\n}", "target": 0}
{"code": "static inline void xen_evtchn_handle_events(unsigned cpu)\n{\n\treturn evtchn_ops->handle_events(cpu);\n}", "target": 1}
{"code": "hb_set_set (hb_set_t       *set,\n\t    const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->set (*other);\n}", "target": 1}
{"code": "static int mov_write_vpcc_tag(AVFormatContext *s, AVIOContext *pb, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0);\n    ffio_wfourcc(pb, \"vpcC\");\n    avio_wb32(pb, 0); \n    ff_isom_write_vpcc(s, pb, track->par);\n    return update_size(pb, pos);\n}", "target": 0}
{"code": "check_entry_size_and_hooks(struct ipt_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ipt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 0}
{"code": "static size_t ntlm_av_pair_get_next_offset(NTLM_AV_PAIR* pAvPair)\n{\n\treturn ntlm_av_pair_get_len(pAvPair) + sizeof(NTLM_AV_PAIR);\n}", "target": 1}
{"code": "l2tp_msgtype_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tND_PRINT((ndo, \"%s\", tok2str(l2tp_msgtype2str, \"MSGTYPE-#%u\",\n\t    EXTRACT_16BITS(ptr))));\n}", "target": 1}
{"code": "int sas_discover_sata(struct domain_device *dev)\n{\n\tint res;\n\tif (dev->dev_type == SAS_SATA_PM)\n\t\treturn -ENODEV;\n\tdev->sata_dev.class = sas_get_ata_command_set(dev);\n\tsas_fill_in_rphy(dev, dev->rphy);\n\tres = sas_notify_lldd_dev_found(dev);\n\tif (res)\n\t\treturn res;\n\tsas_discover_event(dev->port, DISCE_PROBE);\n\treturn 0;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& boxes = context->input(0);\n    const Tensor& scores = context->input(1);\n    const Tensor& max_output_size = context->input(2);\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsScalar(max_output_size.shape()),\n        errors::InvalidArgument(\"max_output_size must be 0-D, got shape \",\n                                max_output_size.shape().DebugString()));\n    const Tensor& iou_threshold = context->input(3);\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(iou_threshold.shape()),\n                errors::InvalidArgument(\"iou_threshold must be 0-D, got shape \",\n                                        iou_threshold.shape().DebugString()));\n    const T iou_threshold_val = iou_threshold.scalar<T>()();\n    OP_REQUIRES(context,\n                iou_threshold_val >= static_cast<T>(0.0) &&\n                    iou_threshold_val <= static_cast<T>(1.0),\n                errors::InvalidArgument(\"iou_threshold must be in [0, 1]\"));\n    const Tensor& score_threshold = context->input(4);\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsScalar(score_threshold.shape()),\n        errors::InvalidArgument(\"score_threshold must be 0-D, got shape \",\n                                score_threshold.shape().DebugString()));\n    const T score_threshold_val = score_threshold.scalar<T>()();\n    int num_boxes = 0;\n    ParseAndCheckBoxSizes(context, boxes, &num_boxes);\n    CheckScoreSizes(context, num_boxes, scores);\n    if (!context->status().ok()) {\n      return;\n    }\n    auto similarity_fn = CreateIOUSimilarityFn<T>(boxes);\n    int num_valid_outputs;\n    bool return_scores_tensor_ = false;\n    const T dummy_soft_nms_sigma = static_cast<T>(0.0);\n    DoNonMaxSuppressionOp<T>(\n        context, scores, num_boxes, max_output_size, iou_threshold_val,\n        score_threshold_val, dummy_soft_nms_sigma, similarity_fn,\n        return_scores_tensor_, pad_to_max_output_size_, &num_valid_outputs);\n    if (!context->status().ok()) {\n      return;\n    }\n    Tensor* num_outputs_t = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                1, tensorflow::TensorShape{}, &num_outputs_t));\n    num_outputs_t->scalar<int32>().setConstant(num_valid_outputs);\n  }", "target": 0}
{"code": "void HeaderMapImpl::appendToHeader(HeaderString& header, absl::string_view data) {\n  if (data.empty()) {\n    return;\n  }\n  if (!header.empty()) {\n    header.append(\",\", 1);\n  }\n  header.append(data.data(), data.size());\n}", "target": 1}
{"code": "TfLiteStatus CalculateOpData(TfLiteContext* context, TfLiteNode* node,\n                             TfLiteMulParams* params, OpData* data) {\n  const TfLiteTensor* input1 = GetInput(context, node, kInput1Tensor);\n  TF_LITE_ENSURE(context, input1 != nullptr);\n  const TfLiteTensor* input2 = GetInput(context, node, kInput2Tensor);\n  TF_LITE_ENSURE(context, input2 != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input2->type);\n  if (output->type == kTfLiteUInt8 || output->type == kTfLiteInt8) {\n    TF_LITE_ENSURE_STATUS(CalculateActivationRangeQuantized(\n        context, params->activation, output, &data->output_activation_min,\n        &data->output_activation_max));\n    double real_multiplier = static_cast<double>(input1->params.scale) *\n                             static_cast<double>(input2->params.scale) /\n                             static_cast<double>(output->params.scale);\n    QuantizeMultiplier(real_multiplier, &data->output_multiplier,\n                       &data->output_shift);\n    data->input1_zero_point = input1->params.zero_point;\n    data->input2_zero_point = input2->params.zero_point;\n    data->output_zero_point = output->params.zero_point;\n  } else {\n    CalculateActivationRange(params->activation,\n                             &data->output_activation_min_f32,\n                             &data->output_activation_max_f32);\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "inline void ComputeInterpolationWeights(\n    const int64 out_size, const int64 in_size, const float scale,\n    const int resolution, InterpolationCache<T_SCALE>* interpolation) {\n  const Scaler scaler;\n  interpolation->lower.resize(out_size + 1);\n  interpolation->upper.resize(out_size + 1);\n  interpolation->lerp.resize(out_size + 1);\n  interpolation->ilerp.resize(out_size + 1);\n  interpolation->lower[out_size] = 0;\n  interpolation->upper[out_size] = 0;\n  for (int64 i = out_size - 1; i >= 0; --i) {\n    const float in = scaler(i, scale);\n    const float in_f = std::floor(in);\n    interpolation->lower[i] =\n        std::max(static_cast<int64>(in_f), static_cast<int64>(0));\n    interpolation->upper[i] =\n        std::min(static_cast<int64>(std::ceil(in)), in_size - 1);\n    interpolation->lower[i] =\n        std::min(interpolation->lower[i], interpolation->upper[i]);\n    interpolation->lerp[i] = in - in_f;\n    interpolation->ilerp[i] =\n        static_cast<T_SCALE>((in - in_f) * (1 << resolution));\n  }\n}", "target": 0}
{"code": "static void array_cleanup( char* arr[] , int arr_size)\n{\n\tint i=0;\n\tfor( i=0; i< arr_size; i++ ){ \n\t\tif( arr[i*2] ){\n\t\t\tefree( arr[i*2]);\n\t\t}\n\t}\n\tefree(arr);\n}", "target": 1}
{"code": "pci_lintr_release(struct pci_vdev *dev)\n{\n\tstruct businfo *bi;\n\tstruct slotinfo *si;\n\tint pin;\n\tbi = pci_businfo[dev->bus];\n\tassert(bi != NULL);\n\tsi = &bi->slotinfo[dev->slot];\n\tfor (pin = 1; pin < 4; pin++) {\n\t\tsi->si_intpins[pin].ii_count = 0;\n\t\tsi->si_intpins[pin].ii_pirq_pin = 0;\n\t\tsi->si_intpins[pin].ii_ioapic_irq = 0;\n\t}\n}", "target": 1}
{"code": "update_notification_create(struct update_notification **file)\n{\n\tstruct update_notification *tmp;\n\tstruct deltas_head *list;\n\tint error;\n\ttmp = malloc(sizeof(struct update_notification));\n\tif (tmp == NULL)\n\t\treturn pr_enomem();\n\tlist = NULL;\n\terror = deltas_head_create(&list);\n\tif (error) {\n\t\tfree(tmp);\n\t\treturn error;\n\t}\n\ttmp->deltas_list = list;\n\ttmp->uri = NULL;\n\tglobal_data_init(&tmp->global_data);\n\tdoc_data_init(&tmp->snapshot);\n\t*file = tmp;\n\treturn 0;\n}", "target": 1}
{"code": "void DoEmbedProfile(const char* ProfileFile)\n{\n    FILE* f;\n    size_t size, EmbedLen;\n    cmsUInt8Number* EmbedBuffer;\n        f = fopen(ProfileFile, \"rb\");\n        if (f == NULL) return;\n        size = cmsfilelength(f);\n        EmbedBuffer = (cmsUInt8Number*) malloc(size + 1);\n        EmbedLen = fread(EmbedBuffer, 1, size, f);\n        fclose(f);\n        EmbedBuffer[EmbedLen] = 0;\n        write_icc_profile (&Compressor, EmbedBuffer, EmbedLen);\n        free(EmbedBuffer);\n}", "target": 0}
{"code": "init_rc(void)\n{\n    int i;\n    struct stat st;\n    FILE *f;\n    if (rc_dir != NULL)\n\tgoto open_rc;\n    rc_dir = expandPath(RC_DIR);\n    i = strlen(rc_dir);\n    if (i > 1 && rc_dir[i - 1] == '/')\n\trc_dir[i - 1] = '\\0';\n#ifdef USE_M17N\n    display_charset_str = wc_get_ces_list();\n    document_charset_str = display_charset_str;\n    system_charset_str = display_charset_str;\n#endif\n    if (stat(rc_dir, &st) < 0) {\n\tif (errno == ENOENT) {\t\n\t    if (do_mkdir(rc_dir, 0700) < 0) {\n\t\tgoto rc_dir_err;\n\t    }\n\t    else {\n\t\tstat(rc_dir, &st);\n\t    }\n\t}\n\telse {\n\t    goto rc_dir_err;\n\t}\n    }\n    if (!S_ISDIR(st.st_mode)) {\n\tgoto rc_dir_err;\n    }\n    if (!(st.st_mode & S_IWUSR)) {\n\tgoto rc_dir_err;\n    }\n    no_rc_dir = FALSE;\n    tmp_dir = rc_dir;\n    if (config_file == NULL)\n\tconfig_file = rcFile(CONFIG_FILE);\n    create_option_search_table();\n  open_rc:\n    if ((f = fopen(etcFile(W3MCONFIG), \"rt\")) != NULL) {\n\tinterpret_rc(f);\n\tfclose(f);\n    }\n    if ((f = fopen(confFile(CONFIG_FILE), \"rt\")) != NULL) {\n\tinterpret_rc(f);\n\tfclose(f);\n    }\n    if (config_file && (f = fopen(config_file, \"rt\")) != NULL) {\n\tinterpret_rc(f);\n\tfclose(f);\n    }\n    return;\n  rc_dir_err:\n    no_rc_dir = TRUE;\n    if (((tmp_dir = getenv(\"TMPDIR\")) == NULL || *tmp_dir == '\\0') &&\n\t((tmp_dir = getenv(\"TMP\")) == NULL || *tmp_dir == '\\0') &&\n\t((tmp_dir = getenv(\"TEMP\")) == NULL || *tmp_dir == '\\0'))\n\ttmp_dir = \"/tmp\";\n#ifdef HAVE_MKDTEMP\n    tmp_dir = mkdtemp(Strnew_m_charp(tmp_dir, \"/w3m-XXXXXX\", NULL)->ptr);\n    if (tmp_dir == NULL)\n\ttmp_dir = rc_dir;\n#endif\n    create_option_search_table();\n    goto open_rc;\n}", "target": 0}
{"code": "static int clie_5_attach(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *port;\n\tunsigned int pipe;\n\tint j;\n\tif (serial->num_ports < 2)\n\t\treturn -1;\n\tport = serial->port[0];\n\tport->bulk_out_endpointAddress =\n\t\t\t\tserial->port[1]->bulk_out_endpointAddress;\n\tpipe = usb_sndbulkpipe(serial->dev, port->bulk_out_endpointAddress);\n\tfor (j = 0; j < ARRAY_SIZE(port->write_urbs); ++j)\n\t\tport->write_urbs[j]->pipe = pipe;\n\treturn 0;\n}", "target": 1}
{"code": "static inline void __file_sb_list_add(struct file *file, struct super_block *sb)\n{\n\tstruct list_head *list;\n#ifdef CONFIG_SMP\n\tint cpu;\n\tcpu = smp_processor_id();\n\tfile->f_sb_list_cpu = cpu;\n\tlist = per_cpu_ptr(sb->s_files, cpu);\n#else\n\tlist = &sb->s_files;\n#endif\n\tlist_add(&file->f_u.fu_list, list);\n}", "target": 1}
{"code": "static int samldb_spn_uniqueness_check(struct samldb_ctx *ac,\n\t\t\t\t       struct ldb_message_element *spn_el)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tint ret;\n\tconst char *spn = NULL;\n\tsize_t i;\n\tTALLOC_CTX *tmp_ctx = talloc_new(ac->msg);\n\tif (tmp_ctx == NULL) {\n\t\treturn ldb_oom(ldb);\n\t}\n\tfor (i = 0; i < spn_el->num_values; i++) {\n\t\tint n_components;\n\t\tspn = (char *)spn_el->values[i].data;\n\t\tn_components = count_spn_components(spn_el->values[i]);\n\t\tif (n_components > 3 || n_components < 2) {\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t       \"samldb: spn[%s] invalid with %u components\",\n\t\t\t\t\t       spn, n_components);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t}\n\t\tret = check_spn_direct_collision(ldb,\n\t\t\t\t\t\t tmp_ctx,\n\t\t\t\t\t\t spn,\n\t\t\t\t\t\t ac->msg->dn);\n\t\tif (ret == LDB_ERR_COMPARE_TRUE) {\n\t\t\tDBG_INFO(\"SPN %s re-added to the same object\\n\", spn);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn LDB_SUCCESS;\n\t\t}\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\tDBG_ERR(\"SPN %s failed direct uniqueness check\\n\", spn);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\t\tret = check_spn_alias_collision(ldb,\n\t\t\t\t\t\ttmp_ctx,\n\t\t\t\t\t\tspn,\n\t\t\t\t\t\tac->msg->dn);\n\t\tif (ret == LDB_ERR_NO_SUCH_OBJECT) {\n\t\t\tbreak;\n\t\t}\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\tDBG_ERR(\"SPN %s failed alias uniqueness check\\n\", spn);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\t\tDBG_INFO(\"SPN %s seems to be unique\\n\", spn);\n\t}\n\ttalloc_free(tmp_ctx);\n\treturn LDB_SUCCESS;\n}", "target": 1}
{"code": "static int ptrace_setoptions(struct task_struct *child, unsigned long data)\n{\n\tunsigned flags;\n\tif (data & ~(unsigned long)PTRACE_O_MASK)\n\t\treturn -EINVAL;\n\tif (unlikely(data & PTRACE_O_SUSPEND_SECCOMP)) {\n\t\tif (!IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) ||\n\t\t    !IS_ENABLED(CONFIG_SECCOMP))\n\t\t\treturn -EINVAL;\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (seccomp_mode(&current->seccomp) != SECCOMP_MODE_DISABLED ||\n\t\t    current->ptrace & PT_SUSPEND_SECCOMP)\n\t\t\treturn -EPERM;\n\t}\n\tflags = child->ptrace;\n\tflags &= ~(PTRACE_O_MASK << PT_OPT_FLAG_SHIFT);\n\tflags |= (data << PT_OPT_FLAG_SHIFT);\n\tchild->ptrace = flags;\n\treturn 0;\n}", "target": 1}
{"code": "static inline int assign_eip_far(struct x86_emulate_ctxt *ctxt, ulong dst,\n\t\t\t       int cs_l)\n{\n\tswitch (ctxt->op_bytes) {\n\tcase 2:\n\t\tctxt->_eip = (u16)dst;\n\t\tbreak;\n\tcase 4:\n\t\tctxt->_eip = (u32)dst;\n\t\tbreak;\n\tcase 8:\n\t\tif ((cs_l && is_noncanonical_address(dst)) ||\n\t\t    (!cs_l && (dst & ~(u32)-1)))\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tctxt->_eip = dst;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"unsupported eip assignment size\\n\");\n\t}\n\treturn X86EMUL_CONTINUE;\n}", "target": 0}
{"code": "static int ncrush_generate_tables(NCRUSH_CONTEXT* context)\n{\n\tUINT32 k, i;\n\tint j, l;\n\tk = 0;\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(28 < ARRAYSIZE(LOMBitsLUT));\n\tfor (i = 0; i < 28; i++)\n\t{\n\t\tfor (j = 0; j < 1 << LOMBitsLUT[i]; j++)\n\t\t{\n\t\t\tl = (k++) + 2;\n\t\t\tcontext->HuffTableLOM[l] = (int)i;\n\t\t}\n\t}\n\tfor (k = 2; k < 4096; k++)\n\t{\n\t\tif ((k - 2) >= 768)\n\t\t\ti = 28;\n\t\telse\n\t\t\ti = context->HuffTableLOM[k];\n\t\tif (i >= ARRAYSIZE(LOMBitsLUT))\n\t\t\treturn -1;\n\t\tif (i >= ARRAYSIZE(LOMBaseLUT))\n\t\t\treturn -1;\n\t\tif (((((1 << LOMBitsLUT[i]) - 1) & (k - 2)) + LOMBaseLUT[i]) != k)\n\t\t\treturn -1;\n\t}\n\tk = 0;\n\tfor (i = 0; i < 16; i++)\n\t{\n\t\tfor (j = 0; j < 1 << CopyOffsetBitsLUT[i]; j++)\n\t\t{\n\t\t\tl = k++ + 2;\n\t\t\tcontext->HuffTableCopyOffset[l] = i;\n\t\t}\n\t}\n\tk /= 128;\n\tfor (i = 16; i < 32; i++)\n\t{\n\t\tfor (j = 0; j < 1 << (CopyOffsetBitsLUT[i] - 7); j++)\n\t\t{\n\t\t\tl = k++ + 2 + 256;\n\t\t\tcontext->HuffTableCopyOffset[l] = i;\n\t\t}\n\t}\n\tif ((k + 256) > 1024)\n\t\treturn -1;\n\treturn 1;\n}", "target": 0}
{"code": "char *rfbProcessFileTransferReadBuffer(rfbClientPtr cl, uint32_t length)\n{\n    char *buffer=NULL;\n    int   n=0;\n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, NULL);\n    if(length == SIZE_MAX || length > INT_MAX) {\n\trfbErr(\"rfbProcessFileTransferReadBuffer: too big file transfer length requested: %u\", (unsigned int)length);\n\trfbCloseClient(cl);\n\treturn NULL;\n    }\n    if (length>0) {\n        buffer=malloc((size_t)length+1);\n        if (buffer!=NULL) {\n            if ((n = rfbReadExact(cl, (char *)buffer, length)) <= 0) {\n                if (n != 0)\n                    rfbLogPerror(\"rfbProcessFileTransferReadBuffer: read\");\n                rfbCloseClient(cl);\n                if (buffer!=NULL) free(buffer);\n                return NULL;\n            }\n            buffer[length]=0;\n        }\n    }\n    return buffer;\n}", "target": 0}
{"code": "TfLiteStatus EvalGatherNd(TfLiteContext* context, const TfLiteTensor* params,\n                          const TfLiteTensor* indices, TfLiteTensor* output) {\n  bool indices_has_only_positive_elements = true;\n  const auto* indices_values = GetTensorData<IndicesT>(indices);\n  const size_t num_indices = indices->bytes / sizeof(IndicesT);\n  for (size_t i = 0; i < num_indices; i++) {\n    if (indices_values[i] < 0) {\n      indices_has_only_positive_elements = false;\n      break;\n    }\n  }\n  TF_LITE_ENSURE(context, indices_has_only_positive_elements);\n  switch (params->type) {\n    case kTfLiteFloat32:\n      return GatherNd<float, IndicesT>(params, indices, output);\n    case kTfLiteUInt8:\n      return GatherNd<uint8_t, IndicesT>(params, indices, output);\n    case kTfLiteInt8:\n      return GatherNd<int8_t, IndicesT>(params, indices, output);\n    case kTfLiteInt16:\n      return GatherNd<int16_t, IndicesT>(params, indices, output);\n    case kTfLiteInt32:\n      return GatherNd<int32_t, IndicesT>(params, indices, output);\n    case kTfLiteInt64:\n      return GatherNd<int64_t, IndicesT>(params, indices, output);\n    case kTfLiteString:\n      return GatherNdString<IndicesT>(params, indices, output);\n    default:\n      TF_LITE_KERNEL_LOG(context,\n                         \"Params type '%s' are not supported by gather_nd.\",\n                         TfLiteTypeGetName(params->type));\n      return kTfLiteError;\n  }\n}", "target": 1}
{"code": "x509_vfy_callback_indicate_success(X509_STORE_CTX *ctx)\n{\n\treturn x509_vfy_internal_verify(ctx, 1);\n}", "target": 1}
{"code": "static void my_error_exit( j_common_ptr cinfo ) {\n   my_error_ptr myerr = reinterpret_cast<my_error_ptr>( cinfo->err );\n   longjmp( myerr->setjmp_buffer, 1 );\n}", "target": 0}
{"code": "R_API char *r_cons_hud_string(const char *s) {\n\tif (!r_cons_is_interactive ()) {\n\t\tR_LOG_ERROR (\"Hud mode requires scr.interactive=true\");\n\t\treturn NULL;\n\t}\n\tchar *os, *track, *ret, *o = strdup (s);\n\tif (!o) {\n\t\treturn NULL;\n\t}\n\tr_str_ansi_strip (o);\n\tr_str_replace_ch (o, '\\r', 0, true);\n\tr_str_replace_ch (o, '\\t', 0, true);\n\tRList *fl = r_list_new ();\n\tint i;\n\tif (!fl) {\n\t\tfree (o);\n\t\treturn NULL;\n\t}\n\tfl->free = free;\n\tfor (os = o, i = 0; o[i]; i++) {\n\t\tif (o[i] == '\\n') {\n\t\t\to[i] = 0;\n\t\t\tif (*os && *os != '#') {\n\t\t\t\ttrack = strdup (os);\n\t\t\t\tif (!r_list_append (fl, track)) {\n\t\t\t\t\tfree (track);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tos = o + i + 1;\n\t\t}\n\t}\n\tret = r_cons_hud (fl, NULL);\n\tfree (o);\n\tr_list_free (fl);\n\treturn ret;\n}", "target": 0}
{"code": "static void InsertNode(CPpmd8 *p, void *node, unsigned indx)\n{\n  ((CPpmd8_Node *)node)->Stamp = EMPTY_NODE;\n  ((CPpmd8_Node *)node)->Next = (CPpmd8_Node_Ref)p->FreeList[indx];\n  ((CPpmd8_Node *)node)->NU = I2U(indx);\n  p->FreeList[indx] = REF(node);\n  p->Stamps[indx]++;\n}", "target": 0}
{"code": "p2la(UINT8 *out, const UINT8 *in, int xsize, const UINT8 *palette) {\n    int x;\n    for (x = 0; x < xsize; x++, out += 4) {\n        const UINT8 *rgba = &palette[*in++ * 4];\n        out[0] = out[1] = out[2] = L(rgba) / 1000;\n        out[3] = rgba[3];\n    }\n}", "target": 0}
{"code": "static struct vm_area_struct *vma_to_resize(unsigned long addr,\n\tunsigned long old_len, unsigned long new_len, unsigned long *p)\n{\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = find_vma(mm, addr);\n\tif (!vma || vma->vm_start > addr)\n\t\tgoto Efault;\n\tif (is_vm_hugetlb_page(vma))\n\t\tgoto Einval;\n\tif (old_len > vma->vm_end - addr)\n\t\tgoto Efault;\n\tif (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP)) {\n\t\tif (new_len > old_len)\n\t\t\tgoto Efault;\n\t}\n\tif (vma->vm_flags & VM_LOCKED) {\n\t\tunsigned long locked, lock_limit;\n\t\tlocked = mm->locked_vm << PAGE_SHIFT;\n\t\tlock_limit = rlimit(RLIMIT_MEMLOCK);\n\t\tlocked += new_len - old_len;\n\t\tif (locked > lock_limit && !capable(CAP_IPC_LOCK))\n\t\t\tgoto Eagain;\n\t}\n\tif (!may_expand_vm(mm, (new_len - old_len) >> PAGE_SHIFT))\n\t\tgoto Enomem;\n\tif (vma->vm_flags & VM_ACCOUNT) {\n\t\tunsigned long charged = (new_len - old_len) >> PAGE_SHIFT;\n\t\tif (security_vm_enough_memory(charged))\n\t\t\tgoto Efault;\n\t\t*p = charged;\n\t}\n\treturn vma;\nEfault:\t\n\treturn ERR_PTR(-EFAULT);\nEinval:\n\treturn ERR_PTR(-EINVAL);\nEnomem:\n\treturn ERR_PTR(-ENOMEM);\nEagain:\n\treturn ERR_PTR(-EAGAIN);\n}", "target": 1}
{"code": "bool DSClientEvent::event()\n{\n    bool restart = false;\n    ParticipantProxyData* part_proxy_data;\n    eprosima::shared_lock<eprosima::shared_mutex> lock(mp_PDP->mp_builtin->getDiscoveryMutex());\n    for (auto server: mp_PDP->remote_server_attributes())\n    {\n        std::unique_lock<std::recursive_mutex> pdp_lock(*mp_PDP->getMutex());\n        part_proxy_data = mp_PDP->get_participant_proxy_data(server.guidPrefix);\n        if (nullptr != part_proxy_data)\n        {\n            if (!mp_EDP->areRemoteEndpointsMatched(part_proxy_data))\n            {\n                mp_EDP->assignRemoteEndpoints(*(part_proxy_data));\n            }\n        }\n        else\n        {\n            restart = true;\n        }\n    }\n    if (restart)\n    {\n        mp_PDP->_serverPing = true;\n        mp_PDP->announceParticipantState(false);\n        EPROSIMA_LOG_INFO(CLIENT_PDP_THREAD,\n                \"Client \" << mp_PDP->getRTPSParticipant()->getGuid() << \" PDP announcement\");\n    }\n    return restart;\n}", "target": 1}
{"code": "static inline void switch_to_bitmap(unsigned long tifp)\n{\n\tif (tifp & _TIF_IO_BITMAP)\n\t\ttss_invalidate_io_bitmap(this_cpu_ptr(&cpu_tss_rw));\n}", "target": 1}
{"code": "static int do_tkill(pid_t tgid, pid_t pid, int sig)\n{\n\tstruct siginfo info;\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_TKILL;\n\tinfo.si_pid = task_tgid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\treturn do_send_specific(tgid, pid, sig, &info);\n}", "target": 1}
{"code": "int anetUnixServer(char *err, char *path, mode_t perm, int backlog)\n{\n    int s;\n    struct sockaddr_un sa;\n    if (strlen(path) > sizeof(sa.sun_path)-1) {\n        anetSetError(err,\"unix socket path too long (%zu), must be under %zu\", strlen(path), sizeof(sa.sun_path));\n        return ANET_ERR;\n    }\n    if ((s = anetCreateSocket(err,AF_LOCAL)) == ANET_ERR)\n        return ANET_ERR;\n    memset(&sa,0,sizeof(sa));\n    sa.sun_family = AF_LOCAL;\n    redis_strlcpy(sa.sun_path,path,sizeof(sa.sun_path));\n    if (anetListen(err,s,(struct sockaddr*)&sa,sizeof(sa),backlog) == ANET_ERR)\n        return ANET_ERR;\n    if (perm)\n        chmod(sa.sun_path, perm);\n    return s;\n}", "target": 1}
{"code": "int VP8LHuffmanTablesAllocate(int size, HuffmanTables* huffman_tables) {\n  HuffmanTablesSegment* const root = &huffman_tables->root;\n  huffman_tables->curr_segment = root;\n  root->start = (HuffmanCode*)WebPSafeMalloc(size, sizeof(*root->start));\n  if (root->start == NULL) return 0;\n  root->curr_table = root->start;\n  root->next = NULL;\n  root->size = size;\n  return 1;\n}", "target": 0}
{"code": "static int del_balance_item(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tint ret, err;\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tbtrfs_free_path(path);\n\t\treturn PTR_ERR(trans);\n\t}\n\tkey.objectid = BTRFS_BALANCE_OBJECTID;\n\tkey.type = BTRFS_TEMPORARY_ITEM_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tret = btrfs_del_item(trans, root, path);\nout:\n\tbtrfs_free_path(path);\n\terr = btrfs_commit_transaction(trans);\n\tif (err && !ret)\n\t\tret = err;\n\treturn ret;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& filter = context->input(1);\n    int stride_rows = 0, stride_cols = 0;\n    int rate_rows = 0, rate_cols = 0;\n    int64 pad_top = 0, pad_left = 0;\n    int64 out_rows = 0, out_cols = 0;\n    ParseSizes(context, strides_, rates_, padding_, &stride_rows, &stride_cols,\n               &rate_rows, &rate_cols, &pad_top, &pad_left, &out_rows,\n               &out_cols);\n    if (!context->status().ok()) return;\n    const int batch = input.dim_size(0);\n    const int depth = input.dim_size(3);\n    const std::vector<int64> out_sizes = {batch, out_rows, out_cols, depth};\n    TensorShape out_shape(out_sizes);\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, out_shape, &output));\n    if (out_shape.num_elements() == 0) {\n      return;\n    }\n    functor::Dilation<Device, T>()(\n        context->eigen_device<Device>(), input.tensor<T, 4>(),\n        filter.tensor<T, 3>(), stride_rows, stride_cols, rate_rows, rate_cols,\n        pad_top, pad_left, output->tensor<T, 4>());\n  }", "target": 0}
{"code": "static void wait_for_child_to_die(void *ctx)\n{\n\tREQUEST *request = ctx;\n\trad_assert(request->magic == REQUEST_MAGIC);\n\tif ((request->child_state == REQUEST_QUEUED) ||\n\t    ((request->child_state == REQUEST_RUNNING) &&\n\t     (pthread_equal(request->child_pid, NO_SUCH_CHILD_PID) == 0))) {\n\t\tif (request->delay < (USEC * 60 * 5)) {\n\t\t\trequest->delay += (request->delay >> 1);\n\t\t\tradlog(L_INFO, \"WARNING: Child is hung for request %u in component %s module %s.\",\n\t\t\t       request->number, request->component, request->module);\n\t\t} else {\n\t\t\tRDEBUG2(\"Child is still stuck for request %u\",\n\t\t\t\trequest->number);\n\t\t}\n\t\ttv_add(&request->when, request->delay);\n\t\tINSERT_EVENT(wait_for_child_to_die, request);\n\t\treturn;\n\t}\n\tRDEBUG2(\"Child is finally responsive for request %u\", request->number);\n\tremove_from_request_hash(request);\n#ifdef WITH_PROXY\n\tif (request->proxy) {\n\t\twait_for_proxy_id_to_expire(request);\n\t\treturn;\n\t}\n#endif\n\tev_request_free(&request);\n}", "target": 1}
{"code": "static int semctl_setval(struct ipc_namespace *ns, int semid, int semnum,\n\t\tunsigned long arg)\n{\n\tstruct sem_undo *un;\n\tstruct sem_array *sma;\n\tstruct sem* curr;\n\tint err;\n\tint nsems;\n\tstruct list_head tasks;\n\tint val;\n#if defined(CONFIG_64BIT) && defined(__BIG_ENDIAN)\n\tval = arg >> 32;\n#else\n\tval = arg;\n#endif\n\tsma = sem_lock_check(ns, semid);\n\tif (IS_ERR(sma))\n\t\treturn PTR_ERR(sma);\n\tINIT_LIST_HEAD(&tasks);\n\tnsems = sma->sem_nsems;\n\terr = -EACCES;\n\tif (ipcperms(ns, &sma->sem_perm, S_IWUGO))\n\t\tgoto out_unlock;\n\terr = security_sem_semctl(sma, SETVAL);\n\tif (err)\n\t\tgoto out_unlock;\n\terr = -EINVAL;\n\tif(semnum < 0 || semnum >= nsems)\n\t\tgoto out_unlock;\n\tcurr = &sma->sem_base[semnum];\n\terr = -ERANGE;\n\tif (val > SEMVMX || val < 0)\n\t\tgoto out_unlock;\n\tassert_spin_locked(&sma->sem_perm.lock);\n\tlist_for_each_entry(un, &sma->list_id, list_id)\n\t\tun->semadj[semnum] = 0;\n\tcurr->semval = val;\n\tcurr->sempid = task_tgid_vnr(current);\n\tsma->sem_ctime = get_seconds();\n\tdo_smart_update(sma, NULL, 0, 0, &tasks);\n\terr = 0;\nout_unlock:\n\tsem_unlock(sma);\n\twake_up_sem_queue_do(&tasks);\n\treturn err;\n}", "target": 1}
{"code": "std::string RestAuthHandler::generateJwt(std::string const& username,\n                                         std::string const& password) {\n  AuthenticationFeature* af = AuthenticationFeature::instance();\n  TRI_ASSERT(af != nullptr);\n  return fuerte::jwt::generateUserToken(af->tokenCache().jwtSecret(), username, _validFor);\n}", "target": 1}
{"code": "void RequestContext::SetApiKeyHeader() {\n  request_->AddHeaderToBackend(kDefaultApiKeyHeaderName, api_key_);\n}", "target": 1}
{"code": "static int cdrom_ioctl_media_changed(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tstruct cdrom_changer_info *info;\n\tint ret;\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_MEDIA_CHANGED\\n\");\n\tif (!CDROM_CAN(CDC_MEDIA_CHANGED))\n\t\treturn -ENOSYS;\n\tif (!CDROM_CAN(CDC_SELECT_DISC) || arg == CDSL_CURRENT)\n\t\treturn media_changed(cdi, 1);\n\tif ((unsigned int)arg >= cdi->capacity)\n\t\treturn -EINVAL;\n\tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tret = cdrom_read_mech_status(cdi, info);\n\tif (!ret)\n\t\tret = info->slots[arg].change;\n\tkfree(info);\n\treturn ret;\n}", "target": 1}
{"code": "static inline bool key_is_instantiated(const struct key *key)\n{\n\treturn test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n\t\t!test_bit(KEY_FLAG_NEGATIVE, &key->flags);\n}", "target": 1}
{"code": "      void Init(void)\n      {\n        for(int i = 0;i < 19;i++) {\n#ifdef DEBUG_QMCODER\n          char string[5] = \"X0  \";\n          string[1] = (i / 10) + '0';\n          string[2] = (i % 10) + '0';\n          X[i].Init(string);\n          string[0] = 'M';\n          M[i].Init(string);\n#else\n          X[i].Init();\n          M[i].Init();\n#endif\n        }\n      }", "target": 1}
{"code": "cdf_unpack_dir(cdf_directory_t *d, char *buf)\n{\n\tsize_t len = 0;\n\tCDF_UNPACKA(d->d_name);\n\tCDF_UNPACK(d->d_namelen);\n\tCDF_UNPACK(d->d_type);\n\tCDF_UNPACK(d->d_color);\n\tCDF_UNPACK(d->d_left_child);\n\tCDF_UNPACK(d->d_right_child);\n\tCDF_UNPACK(d->d_storage);\n\tCDF_UNPACKA(d->d_storage_uuid);\n\tCDF_UNPACK(d->d_flags);\n\tCDF_UNPACK(d->d_created);\n\tCDF_UNPACK(d->d_modified);\n\tCDF_UNPACK(d->d_stream_first_sector);\n\tCDF_UNPACK(d->d_size);\n\tCDF_UNPACK(d->d_unused0);\n}", "target": 0}
{"code": "static bool disconnect_cb(struct io *io, void *user_data)\n{\n\tstruct bt_att_chan *chan = user_data;\n\tstruct bt_att *att = chan->att;\n\tint err;\n\tsocklen_t len;\n\tlen = sizeof(err);\n\tif (getsockopt(chan->fd, SOL_SOCKET, SO_ERROR, &err, &len) < 0) {\n\t\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"(chan %p) Failed to obtain disconnect\"\n\t\t\t\t\t\" error: %s\", chan, strerror(errno));\n\t\terr = 0;\n\t}\n\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"Channel %p disconnected: %s\",\n\t\t\t\t\tchan, strerror(err));\n\tqueue_remove(att->chans, chan);\n\tqueue_remove_all(att->req_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->ind_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->write_queue, NULL, NULL, disc_att_send_op);\n\tif (chan->pending_req) {\n\t\tdisc_att_send_op(chan->pending_req);\n\t\tchan->pending_req = NULL;\n\t}\n\tif (chan->pending_ind) {\n\t\tdisc_att_send_op(chan->pending_ind);\n\t\tchan->pending_ind = NULL;\n\t}\n\tbt_att_chan_free(chan);\n\tif (!queue_isempty(att->chans))\n\t\treturn false;\n\tbt_att_ref(att);\n\tqueue_foreach(att->disconn_list, disconn_handler, INT_TO_PTR(err));\n\tbt_att_unregister_all(att);\n\tbt_att_unref(att);\n\treturn false;\n}", "target": 1}
{"code": "SYSCALL_DEFINE6(move_pages, pid_t, pid, unsigned long, nr_pages,\n\t\tconst void __user * __user *, pages,\n\t\tconst int __user *, nodes,\n\t\tint __user *, status, int, flags)\n{\n\tconst struct cred *cred = current_cred(), *tcred;\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tint err;\n\tnodemask_t task_nodes;\n\tif (flags & ~(MPOL_MF_MOVE|MPOL_MF_MOVE_ALL))\n\t\treturn -EINVAL;\n\tif ((flags & MPOL_MF_MOVE_ALL) && !capable(CAP_SYS_NICE))\n\t\treturn -EPERM;\n\trcu_read_lock();\n\ttask = pid ? find_task_by_vpid(pid) : current;\n\tif (!task) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\tget_task_struct(task);\n\ttcred = __task_cred(task);\n\tif (!uid_eq(cred->euid, tcred->suid) && !uid_eq(cred->euid, tcred->uid) &&\n\t    !uid_eq(cred->uid,  tcred->suid) && !uid_eq(cred->uid,  tcred->uid) &&\n\t    !capable(CAP_SYS_NICE)) {\n\t\trcu_read_unlock();\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\trcu_read_unlock();\n \terr = security_task_movememory(task);\n \tif (err)\n\t\tgoto out;\n\ttask_nodes = cpuset_mems_allowed(task);\n\tmm = get_task_mm(task);\n\tput_task_struct(task);\n\tif (!mm)\n\t\treturn -EINVAL;\n\tif (nodes)\n\t\terr = do_pages_move(mm, task_nodes, nr_pages, pages,\n\t\t\t\t    nodes, status, flags);\n\telse\n\t\terr = do_pages_stat(mm, nr_pages, pages, status);\n\tmmput(mm);\n\treturn err;\nout:\n\tput_task_struct(task);\n\treturn err;\n}", "target": 1}
{"code": "static struct sk_buff *xfrm_state_netlink(struct sk_buff *in_skb,\n\t\t\t\t\t  struct xfrm_state *x, u32 seq)\n{\n\tstruct xfrm_dump_info info;\n\tstruct sk_buff *skb;\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = seq;\n\tinfo.nlmsg_flags = 0;\n\tif (dump_one_state(x, 0, &info)) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\treturn skb;\n}", "target": 1}
{"code": "static void save_quoted(const char *data, FILE *file)\n{\n\tconst char *p;\n\tfputc('\"', file);\n\tfor (p = data; p && *p; p++) {\n\t\tif ((unsigned char) *p == 0x22 ||\t\t\n\t\t    (unsigned char) *p == 0x5c)\t\t\t\n\t\t\tfputc('\\\\', file);\n\t\tfputc(*p, file);\n\t}\n\tfputc('\"', file);\n}", "target": 0}
{"code": "static void fio_worker_cleanup(void) {\n  if (fio_data->is_worker)\n    FIO_LOG_INFO(\"(%d) detected exit signal.\", (int)getpid());\n  else\n    FIO_LOG_INFO(\"Server Detected exit signal.\");\n  fio_state_callback_force(FIO_CALL_ON_SHUTDOWN);\n  for (size_t i = 0; i <= fio_data->max_protocol_fd; ++i) {\n    if (fd_data(i).protocol) {\n      fio_defer_push_task(deferred_on_shutdown, (void *)fd2uuid(i), NULL);\n    }\n  }\n  fio_defer_push_task(fio_cycle_unwind, NULL, NULL);\n  fio_defer_perform();\n  for (size_t i = 0; i <= fio_data->max_protocol_fd; ++i) {\n    if (fd_data(i).protocol || fd_data(i).open) {\n      fio_force_close(fd2uuid(i));\n    }\n  }\n  fio_defer_perform();\n  fio_state_callback_force(FIO_CALL_ON_FINISH);\n  fio_defer_perform();\n  if (!fio_data->is_worker) {\n    fio_cluster_signal_children();\n    while (wait(NULL) != -1)\n      ;\n  }\n  fio_defer_perform();\n  fio_signal_handler_reset();\n  if (fio_data->parent == getpid()) {\n    FIO_LOG_INFO(\"   ---  Shutdown Complete  ---\\n\");\n  } else {\n    FIO_LOG_INFO(\"(%d) cleanup complete.\", (int)getpid());\n  }\n}", "target": 1}
{"code": "static char *socket_http_get_recursive(const char *url, int *code, int *rlen, ut32 redirections) {\n\tif (code) {\n\t\t*code = 0;\n\t}\n\tif (rlen) {\n\t\t*rlen = 0;\n\t}\n\tchar *curl_env = r_sys_getenv (\"R2_CURL\");\n\tif (!R_STR_ISEMPTY (curl_env) && atoi (curl_env)) {\n\t\tint len;\n\t\tchar *escaped_url = r_str_escape_sh (url);\n\t\tchar *command = r_str_newf (\"curl -sfL -o - \\\"%s\\\"\", escaped_url);\n\t\tchar *res = r_sys_cmd_str (command, NULL, &len);\n\t\tfree (escaped_url);\n\t\tfree (command);\n\t\tfree (curl_env);\n\t\tif (!res) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (res) {\n\t\t\tif (code) {\n\t\t\t\t*code = 200;\n\t\t\t}\n\t\t\tif (rlen) {\n\t\t\t\t*rlen = len;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tfree (curl_env);\n#if __WINDOWS__\n\treturn http_get_w32 (url, code, rlen);\n#else\n\tRSocket *s;\n\tint ssl = r_str_startswith (url, \"https:\n#if !HAVE_LIB_SSL\n\tif (ssl) {\n\t\teprintf (\"Tried to get '%s', but SSL support is disabled, set R2_CURL=1 to use curl\\n\", url);\n\t\treturn NULL;\n\t}\n#endif\n\tchar *response, *host, *path, *port = \"80\";\n\tchar *uri = strdup (url);\n\tif (!uri) {\n\t\treturn NULL;\n\t}\n\thost = strstr (uri, \":\n\tif (!host) {\n\t\tfree (uri);\n\t\teprintf (\"r_socket_http_get: Invalid URI\");\n\t\treturn NULL;\n\t}\n\thost += 3;\n\tport = strchr (host, ':');\n\tif (!port) {\n\t\tport = ssl? \"443\": \"80\";\n\t\tpath = host;\n\t} else {\n\t\t*port++ = 0;\n\t\tpath = port;\n\t}\n\tpath = strchr (path, '/');\n\tif (!path) {\n\t\tpath = \"\";\n\t} else {\n\t\t*path++ = 0;\n\t}\n\ts = r_socket_new (ssl);\n\tif (!s) {\n\t\teprintf (\"r_socket_http_get: Cannot create socket\\n\");\n\t\tfree (uri);\n\t\treturn NULL;\n\t}\n\tif (r_socket_connect_tcp (s, host, port, 0)) {\n\t\tr_socket_printf (s,\n\t\t\t\t\"GET /%s HTTP/1.1\\r\\n\"\n\t\t\t\t\"User-Agent: radare2 \"R2_VERSION\"\\r\\n\"\n\t\t\t\t\"Accept: *", "target": 0}
{"code": "  void onComplete(const Status& status, ContextImpl& context) const override {\n    auto& completion_state = context.getCompletionState(this);\n    if (completion_state.is_completed_) {\n      return;\n    }\n    if (Status::Ok == status) {\n      completion_state.is_completed_ = true;\n      completeWithStatus(status, context);\n      return;\n    }\n    if (++completion_state.number_completed_children_ == verifiers_.size()) {\n      Status final_status = Status::JwtMissed;\n      for (const auto& it : verifiers_) {\n        Status child_status = context.getCompletionState(it.get()).status_;\n        if (child_status != Status::JwtMissed && child_status != Status::JwtUnknownIssuer) {\n          final_status = child_status;\n        }\n      }\n      if (is_allow_missing_or_failed_) {\n        final_status = Status::Ok;\n      } else if (is_allow_missing_ && final_status == Status::JwtMissed) {\n        final_status = Status::Ok;\n      }\n      completion_state.is_completed_ = true;\n      completeWithStatus(final_status, context);\n    }\n  }", "target": 1}
{"code": "__be32 ipv6_select_ident(struct net *net,\n\t\t\t const struct in6_addr *daddr,\n\t\t\t const struct in6_addr *saddr)\n{\n\tstatic u32 ip6_idents_hashrnd __read_mostly;\n\tu32 id;\n\tnet_get_random_once(&ip6_idents_hashrnd, sizeof(ip6_idents_hashrnd));\n\tid = __ipv6_select_ident(net, ip6_idents_hashrnd, daddr, saddr);\n\treturn htonl(id);\n}", "target": 1}
{"code": "void _reset_fxsave_state()\n{\n    static OE_ALIGNED(OE_FXSAVE_ALIGNMENT) const uint64_t\n        _initial_fxstate[OE_FXSAVE_AREA_SIZE / sizeof(uint64_t)] = {\n            0x037F, 0, 0, 0xFFFF00001F80,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n        };\n    asm volatile(\"fxrstor %[fx_state] \\n\\t\"\n                 :\n                 : [fx_state] \"m\"(_initial_fxstate)\n                 :);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    CHECK_EQ(4, context->num_inputs());\n    const Tensor& gradient = context->input(0);\n    const Tensor& input = context->input(1);\n    OP_REQUIRES(context, input.IsSameSize(gradient),\n                InvalidArgument(\"gradient and input must be the same size\"));\n    const Tensor& min = context->input(2);\n    const Tensor& max = context->input(3);\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsScalar(min.shape()),\n        InvalidArgument(\"`min` must be rank 0 but is rank \", min.dims()));\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsScalar(max.shape()),\n        InvalidArgument(\"`max` must be rank 0 but is rank \", max.dims()));\n    Tensor* grad_wrt_input;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input.shape(), &grad_wrt_input));\n    TensorShape scalar_shape;\n    Tensor* grad_wrt_min;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(1, scalar_shape, &grad_wrt_min));\n    Tensor* grad_wrt_max;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(2, scalar_shape, &grad_wrt_max));\n    FakeQuantWithMinMaxVarsGradientFunctor<Device> functor;\n    functor(context->eigen_device<Device>(), gradient.flat<float>(),\n            input.flat<float>(), min.scalar<float>(), max.scalar<float>(),\n            quant_min_, quant_max_, grad_wrt_input->flat<float>(),\n            grad_wrt_min->scalar<float>(), grad_wrt_max->scalar<float>());\n  }", "target": 0}
{"code": "NEDMALLOCNOALIASATTR NEDMALLOCPTRATTR void * nedpcalloc(nedpool *p, size_t no, size_t size) THROWSPEC\n{\n\tunsigned flags=NEDMALLOC_FORCERESERVE(p, 0, no*size);\n\treturn nedpmalloc2(p, size*no, 0, M2_ZERO_MEMORY|flags);\n}", "target": 1}
{"code": "l2tp_q931_cc_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tprint_16bits_val(ndo, (const uint16_t *)dat);\n\tND_PRINT((ndo, \", %02x\", dat[2]));\n\tif (length > 3) {\n\t\tND_PRINT((ndo, \" \"));\n\t\tprint_string(ndo, dat+3, length-3);\n\t}\n}", "target": 1}
{"code": "char *LibRaw_bigfile_datastream::gets(char *str, int sz)\n{\n  if(sz<1) return NULL;\n  LR_BF_CHK();\n  return fgets(str, sz, f);\n}", "target": 0}
{"code": "juniper_ggsn_print(netdissect_options *ndo,\n                   const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        struct juniper_ggsn_header {\n            uint8_t svc_id;\n            uint8_t flags_len;\n            uint8_t proto;\n            uint8_t flags;\n            uint8_t vlan_id[2];\n            uint8_t res[2];\n        };\n        const struct juniper_ggsn_header *gh;\n        l2info.pictype = DLT_JUNIPER_GGSN;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        gh = (struct juniper_ggsn_header *)&l2info.cookie;\n        ND_TCHECK(*gh);\n        if (ndo->ndo_eflag) {\n            ND_PRINT((ndo, \"proto %s (%u), vlan %u: \",\n                   tok2str(juniper_protocol_values,\"Unknown\",gh->proto),\n                   gh->proto,\n                   EXTRACT_16BITS(&gh->vlan_id[0])));\n        }\n        switch (gh->proto) {\n        case JUNIPER_PROTO_IPV4:\n            ip_print(ndo, p, l2info.length);\n            break;\n        case JUNIPER_PROTO_IPV6:\n            ip6_print(ndo, p, l2info.length);\n            break;\n        default:\n            if (!ndo->ndo_eflag)\n                ND_PRINT((ndo, \"unknown GGSN proto (%u)\", gh->proto));\n        }\n        return l2info.header_len;\ntrunc:\n\tND_PRINT((ndo, \"[|juniper_services]\"));\n\treturn l2info.header_len;\n}", "target": 0}
{"code": "void RunOneAveragePoolTest(const PoolParams& params,\n                           const RuntimeShape& input_shape,\n                           const int8* input_data,\n                           const RuntimeShape& output_shape) {\n  const int buffer_size = output_shape.FlatSize();\n  std::vector<int8> optimized_averagePool_output(buffer_size);\n  std::vector<int8> reference_averagePool_output(buffer_size);\n  reference_integer_ops::AveragePool(params, input_shape, input_data,\n                                     output_shape,\n                                     reference_averagePool_output.data());\n  optimized_integer_ops::AveragePool(params, input_shape, input_data,\n                                     output_shape,\n                                     optimized_averagePool_output.data());\n  for (int i = 0; i < buffer_size; i++) {\n    EXPECT_TRUE(reference_averagePool_output[i] ==\n                optimized_averagePool_output[i]);\n  }\n}", "target": 1}
{"code": "static inline struct old_rng_alg *crypto_old_rng_alg(struct crypto_rng *tfm)\n{\n\treturn &crypto_rng_tfm(tfm)->__crt_alg->cra_rng;\n}", "target": 1}
{"code": "has_supported_extension (const char *name,\n\t\t\t GHashTable *supported_extensions)\n{\n\tgboolean ret = FALSE;\n\tgchar *suffix;\n\tsuffix = g_strrstr (name, \".\");\n\tif (!suffix)\n\t\treturn ret;\n\tsuffix = g_ascii_strdown (suffix + 1, -1);\n\tret = GPOINTER_TO_INT (g_hash_table_lookup (supported_extensions, suffix));\n\tg_free (suffix);\n\treturn ret;\n}", "target": 0}
{"code": "void release_dentry_name_snapshot(struct name_snapshot *name)\n{\n\tif (unlikely(name->name != name->inline_name)) {\n\t\tstruct external_name *p;\n\t\tp = container_of(name->name, struct external_name, name[0]);\n\t\tif (unlikely(atomic_dec_and_test(&p->u.count)))\n\t\t\tkfree_rcu(p, u.head);\n\t}\n}", "target": 0}
{"code": "int nfc_stop_poll(struct nfc_dev *dev)\n{\n\tint rc = 0;\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->polling) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\tdev->ops->stop_poll(dev);\n\tdev->polling = false;\n\tdev->rf_mode = NFC_RF_NONE;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "void test_checkout_nasty__git_tilde1(void)\n{\n#ifdef GIT_WIN32\n\ttest_checkout_fails(\"refs/heads/git_tilde1\", \".git/foobar\");\n#endif\n}", "target": 1}
{"code": "static int ppp_unattached_ioctl(struct net *net, struct ppp_file *pf,\n\t\t\tstruct file *file, unsigned int cmd, unsigned long arg)\n{\n\tint unit, err = -EFAULT;\n\tstruct ppp *ppp;\n\tstruct channel *chan;\n\tstruct ppp_net *pn;\n\tint __user *p = (int __user *)arg;\n\tmutex_lock(&ppp_mutex);\n\tswitch (cmd) {\n\tcase PPPIOCNEWUNIT:\n\t\tif (get_user(unit, p))\n\t\t\tbreak;\n\t\tppp = ppp_create_interface(net, unit, file, &err);\n\t\tif (!ppp)\n\t\t\tbreak;\n\t\tfile->private_data = &ppp->file;\n\t\terr = -EFAULT;\n\t\tif (put_user(ppp->file.index, p))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\tcase PPPIOCATTACH:\n\t\tif (get_user(unit, p))\n\t\t\tbreak;\n\t\terr = -ENXIO;\n\t\tpn = ppp_pernet(net);\n\t\tmutex_lock(&pn->all_ppp_mutex);\n\t\tppp = ppp_find_unit(pn, unit);\n\t\tif (ppp) {\n\t\t\tatomic_inc(&ppp->file.refcnt);\n\t\t\tfile->private_data = &ppp->file;\n\t\t\terr = 0;\n\t\t}\n\t\tmutex_unlock(&pn->all_ppp_mutex);\n\t\tbreak;\n\tcase PPPIOCATTCHAN:\n\t\tif (get_user(unit, p))\n\t\t\tbreak;\n\t\terr = -ENXIO;\n\t\tpn = ppp_pernet(net);\n\t\tspin_lock_bh(&pn->all_channels_lock);\n\t\tchan = ppp_find_channel(pn, unit);\n\t\tif (chan) {\n\t\t\tatomic_inc(&chan->file.refcnt);\n\t\t\tfile->private_data = &chan->file;\n\t\t\terr = 0;\n\t\t}\n\t\tspin_unlock_bh(&pn->all_channels_lock);\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOTTY;\n\t}\n\tmutex_unlock(&ppp_mutex);\n\treturn err;\n}", "target": 0}
{"code": "static void print_vtable(vtableEntry* start, int len, outputStream* st) {\n  return print_vtable(reinterpret_cast<intptr_t*>(start), len, st);\n}", "target": 0}
{"code": "unset_nonblock(int fd)\n{\n\tint val;\n\tval = fcntl(fd, F_GETFL);\n\tif (val == -1) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}", "target": 0}
{"code": "      TF_EXCLUSIVE_LOCKS_REQUIRED(mu_) {\n    if (tuple[index].has_value()) {\n      return Status(errors::InvalidArgument(\n          \"The tensor for index '\", index, \"' for key '\", key.scalar<int64>()(),\n          \"' was already initialized '\", dtypes_.size(), \"'.\"));\n    }\n    return Status::OK();\n  }", "target": 1}
{"code": "  inline Eigen::IndexList<int, Eigen::type2index<1>> NByOne(int n) {\n    Eigen::IndexList<int, Eigen::type2index<1>> ret;\n    ret.set(0, n);\n    return ret;\n  }", "target": 1}
{"code": "init_util(void)\n{\n\tfilegen_register(statsdir, \"peerstats\",\t  &peerstats);\n\tfilegen_register(statsdir, \"loopstats\",\t  &loopstats);\n\tfilegen_register(statsdir, \"clockstats\",  &clockstats);\n\tfilegen_register(statsdir, \"rawstats\",\t  &rawstats);\n\tfilegen_register(statsdir, \"sysstats\",\t  &sysstats);\n\tfilegen_register(statsdir, \"protostats\",  &protostats);\n#ifdef AUTOKEY\n\tfilegen_register(statsdir, \"cryptostats\", &cryptostats);\n#endif\t\n#ifdef DEBUG_TIMING\n\tfilegen_register(statsdir, \"timingstats\", &timingstats);\n#endif\t\n\tstep_callback = &ntpd_time_stepped;\n#ifdef DEBUG\n\tatexit(&uninit_util);\n#endif \n}", "target": 1}
{"code": "static void lwp_read(FILE *fin, std::string &buf) {\n  size_t len;\n  fread(&len, sizeof(len), 1, fin);\n  char *buffer = (char *)malloc(len + 1);\n  fread(buffer, sizeof(*buffer), len, fin);\n  buffer[len] = '\\0';\n  buf = std::string(buffer);\n  free(buffer);\n}", "target": 0}
{"code": "static void recalculate_apic_map(struct kvm *kvm)\n{\n\tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\tnew = kzalloc(sizeof(struct kvm_apic_map), GFP_KERNEL);\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\tif (!new)\n\t\tgoto out;\n\tnew->ldr_bits = 8;\n\tnew->cid_shift = 8;\n\tnew->cid_mask = 0;\n\tnew->lid_mask = 0xff;\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tu16 cid, lid;\n\t\tu32 ldr;\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tnew->ldr_bits = 32;\n\t\t\tnew->cid_shift = 16;\n\t\t\tnew->cid_mask = new->lid_mask = 0xffff;\n\t\t} else if (kvm_apic_sw_enabled(apic) &&\n\t\t\t\t!new->cid_mask  &&\n\t\t\t\tkvm_apic_get_reg(apic, APIC_DFR) == APIC_DFR_CLUSTER) {\n\t\t\tnew->cid_shift = 4;\n\t\t\tnew->cid_mask = 0xf;\n\t\t\tnew->lid_mask = 0xf;\n\t\t}\n\t\tnew->phys_map[kvm_apic_id(apic)] = apic;\n\t\tldr = kvm_apic_get_reg(apic, APIC_LDR);\n\t\tcid = apic_cluster_id(new, ldr);\n\t\tlid = apic_logical_id(new, ldr);\n\t\tif (lid)\n\t\t\tnew->logical_map[cid][ffs(lid) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\tkvm_vcpu_request_scan_ioapic(kvm);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& sizes = context->input(1);\n    OP_REQUIRES(\n        context,\n        (TensorShapeUtils::IsVector(sizes.shape()) ||\n         TensorShapeUtils::IsScalar(sizes.shape())),\n        errors::InvalidArgument(\"sizes input must be 1-D, not \",\n                                sizes.shape().DebugString()));\n    OP_REQUIRES(\n        context, sizes.NumElements() < TensorShape::MaxDimensions(),\n        errors::InvalidArgument(\"too many dimensions: must be < \",\n                                TensorShape::MaxDimensions(), \", but received \",\n                                sizes.NumElements()));\n    TensorShape shape;\n    int64_t product = 1;\n    int unknown_index = -1;\n    bool sizes_has_zero_dim;\n    switch (sizes.dtype()) {\n      case DT_INT32:\n        OP_REQUIRES_OK(context,\n                       ValidateSizes<int32>(sizes, &product, &unknown_index,\n                                            &shape, &sizes_has_zero_dim));\n        break;\n      case DT_INT64:\n        OP_REQUIRES_OK(context,\n                       ValidateSizes<int64_t>(sizes, &product, &unknown_index,\n                                              &shape, &sizes_has_zero_dim));\n        break;\n      default:\n        context->CtxFailure(errors::InvalidArgument(\n            \"desired shape must be a DT_INT32 or DT_INT64 vector, not a \",\n            DataTypeString(sizes.dtype())));\n        return;\n    }\n    if (unknown_index != -1) {\n      int64_t input_num_elements = 1;\n      bool input_has_zero_dim = false;\n      for (int dim = 0; dim < input.dims(); dim++) {\n        if (input.dim_size(dim) > 0 || !sizes_has_zero_dim) {\n          input_num_elements *= input.dim_size(dim);\n        } else {\n          input_has_zero_dim = true;\n        }\n      }\n      const int64_t missing = input_num_elements / product;\n      if (!input_has_zero_dim) {\n        OP_REQUIRES(\n            context, product * missing == input_num_elements,\n            errors::InvalidArgument(\n                \"Input to reshape is a tensor with \", input_num_elements,\n                \" values, but the requested shape requires a multiple of \",\n                product));\n      }\n      shape.set_dim(unknown_index, missing);\n    }\n    OP_REQUIRES(context, shape.num_elements() == input.NumElements(),\n                errors::InvalidArgument(\"Input to reshape is a tensor with \",\n                                        input.NumElements(),\n                                        \" values, but the requested shape has \",\n                                        shape.num_elements()));\n    Tensor output(input.dtype());\n    CHECK(output.CopyFrom(input, shape));\n    context->set_output(0, output);\n  }", "target": 0}
{"code": "static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)\n{\n\tstruct fsck_gitmodules_data *data = vdata;\n\tconst char *subsection, *key;\n\tint subsection_len;\n\tchar *name;\n\tif (parse_config_key(var, \"submodule\", &subsection, &subsection_len, &key) < 0 ||\n\t    !subsection)\n\t\treturn 0;\n\tname = xmemdupz(subsection, subsection_len);\n\tif (check_submodule_name(name) < 0)\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_NAME,\n\t\t\t\t    \"disallowed submodule name: %s\",\n\t\t\t\t    name);\n\tif (!strcmp(key, \"url\") && value &&\n\t    looks_like_command_line_option(value))\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_URL,\n\t\t\t\t    \"disallowed submodule url: %s\",\n\t\t\t\t    value);\n\tif (!strcmp(key, \"path\") && value &&\n\t    looks_like_command_line_option(value))\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_PATH,\n\t\t\t\t    \"disallowed submodule path: %s\",\n\t\t\t\t    value);\n\tfree(name);\n\treturn 0;\n}", "target": 0}
{"code": "static int _nfs4_do_open_reclaim(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs_delegation *delegation;\n\tstruct nfs4_opendata *opendata;\n\tint delegation_type = 0;\n\tint status;\n\topendata = nfs4_open_recoverdata_alloc(ctx, state);\n\tif (IS_ERR(opendata))\n\t\treturn PTR_ERR(opendata);\n\topendata->o_arg.claim = NFS4_OPEN_CLAIM_PREVIOUS;\n\topendata->o_arg.fh = NFS_FH(state->inode);\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(state->inode)->delegation);\n\tif (delegation != NULL && test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags) != 0)\n\t\tdelegation_type = delegation->type;\n\trcu_read_unlock();\n\topendata->o_arg.u.delegation_type = delegation_type;\n\tstatus = nfs4_open_recover(opendata, state);\n\tnfs4_opendata_put(opendata);\n\treturn status;\n}", "target": 1}
{"code": "  void operator()(OpKernelContext* ctx, bool use_cudnn, bool cudnn_use_autotune,\n                  const Tensor& input, const Tensor& filter, int row_dilation,\n                  int col_dilation, int row_stride, int col_stride,\n                  const Padding& padding,\n                  const std::vector<int64>& explicit_paddings, Tensor* output,\n                  TensorFormat data_format) {\n    if (data_format != FORMAT_NHWC) {\n      ctx->SetStatus(errors::Unimplemented(\n          \"The Conv2D op currently only supports the NHWC tensor format on the \"\n          \"CPU. The op was given the format: \",\n          ToString(data_format)));\n      return;\n    }\n    for (int64 explicit_padding : explicit_paddings) {\n      if (!FastBoundsCheck(explicit_padding, std::numeric_limits<int>::max())) {\n        ctx->SetStatus(errors::InvalidArgument(\"filter too large\"));\n        return;\n      }\n    }\n    const int64 in_depth = input.dim_size(3);\n    const int64 out_depth = output->dim_size(3);\n    const int64 patch_depth = filter.dim_size(2);\n    if (patch_depth <= 0) {\n      ctx->SetStatus(errors::InvalidArgument(\n          \"filter depth must be stricly positive, got \", patch_depth));\n      return;\n    }\n    if (in_depth % patch_depth != 0) {\n      ctx->SetStatus(errors::InvalidArgument(\n          \"input depth must be evenly divisible by filter depth: \", in_depth,\n          \" vs \", patch_depth));\n      return;\n    }\n    const int64 num_groups = in_depth / patch_depth;\n    if (num_groups <= 0) {\n      ctx->SetStatus(errors::InvalidArgument(\n          \"number of groups must be stricly positive, got \", num_groups));\n      return;\n    }\n    if (out_depth % num_groups != 0 || out_depth < num_groups) {\n      ctx->SetStatus(errors::InvalidArgument(\n          \"output depth must be evenly divisible by number of groups: \",\n          out_depth, \" vs \", num_groups));\n      return;\n    }\n    if (in_depth != patch_depth) {\n      LaunchGrouped<T>()(ctx, input, filter, row_stride, col_stride,\n                         row_dilation, col_dilation, padding, explicit_paddings,\n                         output, data_format);\n    } else {\n      LaunchGeneric<CPUDevice, T>()(ctx, input, filter, row_stride, col_stride,\n                                    row_dilation, col_dilation, padding,\n                                    explicit_paddings, output, data_format);\n    }\n  }", "target": 0}
{"code": "trim_subnode_array(apr_array_header_t **array,\n                   int latest_any_var,\n                   apr_pool_t *scratch_pool)\n{\n  if (*array)\n    {\n      int i, dest;\n      for (i = 0, dest = 0; i < (*array)->nelts; ++i)\n        {\n          node_t *node = APR_ARRAY_IDX(*array, i, sorted_pattern_t).node;\n          if (!trim_tree(node, latest_any_var, scratch_pool))\n            {\n              if (i != dest)\n                APR_ARRAY_IDX(*array, dest, sorted_pattern_t)\n                  = APR_ARRAY_IDX(*array, i, sorted_pattern_t);\n              ++dest;\n            }\n        }\n      if (dest)\n        {\n          (*array)->nelts = dest;\n          return FALSE;\n        }\n      *array = NULL;\n    }\n  return TRUE;\n}", "target": 0}
{"code": "xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error = 0;\n\tif (!acl)\n\t\tgoto set_acl;\n\terror = -E2BIG;\n\tif (acl->a_count > XFS_ACL_MAX_ENTRIES(XFS_M(inode->i_sb)))\n\t\treturn error;\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tumode_t mode = inode->i_mode;\n\t\terror = posix_acl_equiv_mode(acl, &mode);\n\t\tif (error <= 0) {\n\t\t\tacl = NULL;\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\t\terror = xfs_set_mode(inode, mode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n set_acl:\n\treturn __xfs_set_acl(inode, type, acl);\n}", "target": 1}
{"code": "static void finish_object(struct object *obj,\n\t\t\t  struct strbuf *path, const char *name,\n\t\t\t  void *cb_data)\n{\n\tstruct rev_list_info *info = cb_data;\n\tif (obj->type == OBJ_BLOB && !has_object_file(&obj->oid))\n\t\tdie(\"missing blob object '%s'\", oid_to_hex(&obj->oid));\n\tif (info->revs->verify_objects && !obj->parsed && obj->type != OBJ_COMMIT)\n\t\tparse_object(obj->oid.hash);\n}", "target": 1}
{"code": "void CIRCNetwork::SetEncoding(const CString& s) {\n    m_sEncoding = s;\n    if (GetIRCSock()) {\n        GetIRCSock()->SetEncoding(s);\n    }\n}", "target": 1}
{"code": "lrmd_remote_client_msg(gpointer data)\n{\n    int id = 0;\n    int rc = 0;\n    int disconnected = 0;\n    xmlNode *request = NULL;\n    crm_client_t *client = data;\n    if (client->remote->tls_handshake_complete == FALSE) {\n        int rc = 0;\n        do {\n            rc = gnutls_handshake(*client->remote->tls_session);\n            if (rc < 0 && rc != GNUTLS_E_AGAIN) {\n                crm_err(\"Remote lrmd tls handshake failed\");\n                return -1;\n            }\n        } while (rc == GNUTLS_E_INTERRUPTED);\n        if (rc == 0) {\n            crm_debug(\"Remote lrmd tls handshake completed\");\n            client->remote->tls_handshake_complete = TRUE;\n            if (client->remote->auth_timeout) {\n                g_source_remove(client->remote->auth_timeout);\n            }\n            client->remote->auth_timeout = 0;\n            notify_of_new_client(client);\n        }\n        return 0;\n    }\n    rc = crm_remote_ready(client->remote, 0);\n    if (rc == 0) {\n        return 0;\n    } else if (rc < 0) {\n        crm_info(\"Client disconnected during remote client read\");\n        return -1;\n    }\n    crm_remote_recv(client->remote, -1, &disconnected);\n    request = crm_remote_parse_buffer(client->remote);\n    while (request) {\n        crm_element_value_int(request, F_LRMD_REMOTE_MSG_ID, &id);\n        crm_trace(\"processing request from remote client with remote msg id %d\", id);\n        if (!client->name) {\n            const char *value = crm_element_value(request, F_LRMD_CLIENTNAME);\n            if (value) {\n                client->name = strdup(value);\n            }\n        }\n        lrmd_call_id++;\n        if (lrmd_call_id < 1) {\n            lrmd_call_id = 1;\n        }\n        crm_xml_add(request, F_LRMD_CLIENTID, client->id);\n        crm_xml_add(request, F_LRMD_CLIENTNAME, client->name);\n        crm_xml_add_int(request, F_LRMD_CALLID, lrmd_call_id);\n        process_lrmd_message(client, id, request);\n        free_xml(request);\n        request = crm_remote_parse_buffer(client->remote);\n    }\n    if (disconnected) {\n        crm_info(\"Client disconnect detected in tls msg dispatcher.\");\n        return -1;\n    }\n    return 0;\n}", "target": 0}
{"code": "usm_malloc_usmStateReference(void)\n{\n    struct usmStateReference *retval = (struct usmStateReference *)\n        calloc(1, sizeof(struct usmStateReference));\n    return retval;\n}                               ", "target": 1}
{"code": "static inline item* limited_get(char *key, size_t nkey, conn *c) {\n    item *it = item_get(key, nkey, c, DO_UPDATE);\n    if (it && it->refcount > IT_REFCOUNT_LIMIT) {\n        item_remove(it);\n        it = NULL;\n    }\n    return it;\n}", "target": 0}
{"code": "static void on_page_prepare(GtkNotebook *assistant, GtkWidget *page, gpointer user_data)\n{\n    if (!is_processing_finished())\n    {\n        show_next_step_button();\n        clear_warnings();\n    }\n    gtk_widget_hide(g_btn_detail);\n    gtk_widget_hide(g_btn_onfail);\n    if (!g_expert_mode)\n        gtk_widget_hide(g_btn_repeat);\n    save_items_from_notepad();\n    save_text_from_text_view(g_tv_comment, FILENAME_COMMENT);\n    if (pages[PAGENO_SUMMARY].page_widget == page)\n    {\n        if (!g_expert_mode)\n        {\n            int n = select_next_page_no(pages[PAGENO_SUMMARY].page_no, NULL);\n            log_info(\"switching to page_no:%d\", n);\n            gtk_notebook_set_current_page(assistant, n);\n            return;\n        }\n    }\n    if (pages[PAGENO_EDIT_ELEMENTS].page_widget == page)\n    {\n        if (highlight_forbidden())\n        {\n            add_sensitive_data_warning();\n            show_warnings();\n            gtk_expander_set_expanded(g_exp_search, TRUE);\n        }\n        else\n            gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g_rb_custom_search), TRUE);\n        show_warnings();\n    }\n    if (pages[PAGENO_REVIEW_DATA].page_widget == page)\n    {\n        update_ls_details_checkboxes(g_event_selected);\n        gtk_widget_set_sensitive(g_btn_next, gtk_toggle_button_get_active(g_tb_approve_bt));\n    }\n    if (pages[PAGENO_EDIT_COMMENT].page_widget == page)\n    {\n        gtk_widget_show(g_btn_detail);\n        gtk_widget_set_sensitive(g_btn_next, false);\n        on_comment_changed(gtk_text_view_get_buffer(g_tv_comment), NULL);\n    }\n    if (pages[PAGENO_EVENT_PROGRESS].page_widget == page)\n    {\n        log_info(\"g_event_selected:'%s'\", g_event_selected);\n        if (g_event_selected\n         && g_event_selected[0]\n        ) {\n            clear_warnings();\n            start_event_run(g_event_selected);\n        }\n    }\n    if(pages[PAGENO_EVENT_SELECTOR].page_widget == page)\n    {\n        if (!g_expert_mode && !g_auto_event_list)\n            hide_next_step_button();\n    }\n}", "target": 1}
{"code": "static gg_action_t gg_handle_send_proxy_gg(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state)\n{\n\tchar *req, *auth;\n\tsize_t req_len;\n\tint res;\n\tgg_debug_session(sess, GG_DEBUG_MISC, \"\n\tif (sess->connect_index > 1 || sess->connect_port[sess->connect_index] == 0) {\n\t\tgg_debug_session(sess, GG_DEBUG_MISC, \"\n\t\te->event.failure = GG_FAILURE_CONNECTING;\n\t\treturn GG_ACTION_FAIL;\n\t}\n\tauth = gg_proxy_auth();\n\treq = gg_saprintf(\"CONNECT %s:%d HTTP/1.0\\r\\n%s\\r\\n\", sess->connect_host, sess->connect_port[sess->connect_index], (auth) ? auth : \"\");\n\tfree(auth);\n\tsess->connect_index++;\n\tif (req == NULL) {\n\t\tgg_debug_session(sess, GG_DEBUG_MISC, \"\n\t\te->event.failure = GG_FAILURE_PROXY;\n\t\treturn GG_ACTION_FAIL;\n\t}\n\treq_len = strlen(req);\n\tgg_debug_session(sess, GG_DEBUG_MISC, \"\n\tres = send(sess->fd, req, req_len, 0);\n\tfree(req);\n\tif (res == -1 && errno != EINTR && errno != EAGAIN) {\n\t\tgg_debug_session(sess, GG_DEBUG_MISC, \"\n\t\te->event.failure = GG_FAILURE_PROXY;\n\t\treturn GG_ACTION_FAIL;\n\t}\n\tif ((size_t) res < req_len) {\n\t\tsess->state = alt_state;\n\t\tsess->check = GG_CHECK_WRITE;\n\t\tsess->timeout = GG_DEFAULT_TIMEOUT;\n\t} else {\n\t\tsess->state = next_state;\n\t\tsess->check = GG_CHECK_READ;\n\t\tsess->timeout = GG_DEFAULT_TIMEOUT;\n\t}\n\treturn GG_ACTION_WAIT;\n}", "target": 0}
{"code": "cdf_unpack_summary_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    cdf_summary_info_header_t *ssi, cdf_property_info_t **info, size_t *count)\n{\n\tsize_t i, maxcount;\n\tconst cdf_summary_info_header_t *si =\n\t    CAST(const cdf_summary_info_header_t *, sst->sst_tab);\n\tconst cdf_section_declaration_t *sd =\n\t    CAST(const cdf_section_declaration_t *, (const void *)\n\t    ((const char *)sst->sst_tab + CDF_SECTION_DECLARATION_OFFSET));\n\tif (cdf_check_stream_offset(sst, h, si, sizeof(*si), __LINE__) == -1 ||\n\t    cdf_check_stream_offset(sst, h, sd, sizeof(*sd), __LINE__) == -1)\n\t\treturn -1;\n\tssi->si_byte_order = CDF_TOLE2(si->si_byte_order);\n\tssi->si_os_version = CDF_TOLE2(si->si_os_version);\n\tssi->si_os = CDF_TOLE2(si->si_os);\n\tssi->si_class = si->si_class;\n\tcdf_swap_class(&ssi->si_class);\n\tssi->si_count = CDF_TOLE2(si->si_count);\n\t*count = 0;\n\tmaxcount = 0;\n\t*info = NULL;\n\tfor (i = 0; i < CDF_TOLE4(si->si_count); i++) {\n\t\tif (i >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Unpack summary info loop limit\"));\n\t\t\terrno = EFTYPE;\n\t\t\treturn -1;\n\t\t}\n\t\tif (cdf_read_property_info(sst, h, CDF_TOLE4(sd->sd_offset),\n\t\t    info, count, &maxcount) == -1) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static BOOL rdp_write_logon_info_v1(wStream* s, logon_info* info)\n{\n\tconst size_t charLen = 52 / sizeof(WCHAR);\n\tconst size_t userCharLen = 512 / sizeof(WCHAR);\n\tsize_t sz = 4 + 52 + 4 + 512 + 4;\n\tsize_t len = 0;\n\tif (!Stream_EnsureRemainingCapacity(s, sz))\n\t\treturn FALSE;\n\tWINPR_ASSERT(info);\n\tif (!info->domain || !info->username)\n\t\treturn FALSE;\n\tlen = strnlen(info->domain, charLen + 1);\n\tif (len > charLen)\n\t\treturn FALSE;\n\tStream_Write_UINT32(s, len * sizeof(WCHAR));\n\tif (Stream_Write_UTF16_String_From_UTF8(s, charLen, info->domain, len, TRUE) < 0)\n\t\treturn FALSE;\n\tlen = strnlen(info->username, userCharLen + 1);\n\tif (len > userCharLen)\n\t\treturn FALSE;\n\tStream_Write_UINT32(s, len * sizeof(WCHAR));\n\tif (Stream_Write_UTF16_String_From_UTF8(s, userCharLen, info->username, len, TRUE) < 0)\n\t\treturn FALSE;\n\tStream_Write_UINT32(s, info->sessionId);\n\treturn TRUE;\n}", "target": 0}
{"code": "file_fmtcheck(struct magic_set *ms, const char *desc, const char *def,\n\tconst char *file, size_t line)\n{\n\tconst char *ptr = fmtcheck(desc, def);\n\tif (ptr == def)\n\t\tfile_magerror(ms,\n\t\t    \"%s, %\" SIZE_T_FORMAT \"u: format `%s' does not match\"\n\t\t    \" with `%s'\", file, line, desc, def);\n\treturn ptr;\n}", "target": 0}
{"code": "dtls1_buffer_record(SSL *s, record_pqueue *queue, unsigned char *priority)\n\t{\n\tDTLS1_RECORD_DATA *rdata;\n\tpitem *item;\n\tif (pqueue_size(queue->q) >= 100)\n\t\treturn 0;\n\trdata = OPENSSL_malloc(sizeof(DTLS1_RECORD_DATA));\n\titem = pitem_new(priority, rdata);\n\tif (rdata == NULL || item == NULL)\n\t\t{\n\t\tif (rdata != NULL) OPENSSL_free(rdata);\n\t\tif (item != NULL) pitem_free(item);\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\treturn(0);\n\t\t}\n\trdata->packet = s->packet;\n\trdata->packet_length = s->packet_length;\n\tmemcpy(&(rdata->rbuf), &(s->s3->rbuf), sizeof(SSL3_BUFFER));\n\tmemcpy(&(rdata->rrec), &(s->s3->rrec), sizeof(SSL3_RECORD));\n\titem->data = rdata;\n#ifndef OPENSSL_NO_SCTP\n\tif (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&\n\t    (s->state == SSL3_ST_SR_FINISHED_A || s->state == SSL3_ST_CR_FINISHED_A)) {\n\t\tBIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SCTP_GET_RCVINFO, sizeof(rdata->recordinfo), &rdata->recordinfo);\n\t}\n#endif\n\ts->packet = NULL;\n\ts->packet_length = 0;\n\tmemset(&(s->s3->rbuf), 0, sizeof(SSL3_BUFFER));\n\tmemset(&(s->s3->rrec), 0, sizeof(SSL3_RECORD));\n\tif (!ssl3_setup_buffers(s))\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\tOPENSSL_free(rdata);\n\t\tpitem_free(item);\n\t\treturn(0);\n\t\t}\n\tif (pqueue_insert(queue->q, item) == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\tOPENSSL_free(rdata);\n\t\tpitem_free(item);\n\t\treturn(0);\n\t\t}\n\treturn(1);\n\t}", "target": 1}
{"code": "static int wrmsr_interception(struct vcpu_svm *svm)\n{\n\tstruct msr_data msr;\n\tu32 ecx = svm->vcpu.arch.regs[VCPU_REGS_RCX];\n\tu64 data = (svm->vcpu.arch.regs[VCPU_REGS_RAX] & -1u)\n\t\t| ((u64)(svm->vcpu.arch.regs[VCPU_REGS_RDX] & -1u) << 32);\n\tmsr.data = data;\n\tmsr.index = ecx;\n\tmsr.host_initiated = false;\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\n\tif (svm_set_msr(&svm->vcpu, &msr)) {\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t} else {\n\t\ttrace_kvm_msr_write(ecx, data);\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "void sctp_generate_proto_unreach_event(unsigned long data)\n{\n\tstruct sctp_transport *transport = (struct sctp_transport *) data;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct net *net = sock_net(asoc->base.sk);\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\t\tif (!mod_timer(&transport->proto_unreach_timer,\n\t\t\t\tjiffies + (HZ/20)))\n\t\t\tsctp_association_hold(asoc);\n\t\tgoto out_unlock;\n\t}\n\tif (asoc->base.dead)\n\t\tgoto out_unlock;\n\tsctp_do_sm(net, SCTP_EVENT_T_OTHER,\n\t\t   SCTP_ST_OTHER(SCTP_EVENT_ICMP_PROTO_UNREACH),\n\t\t   asoc->state, asoc->ep, asoc, transport, GFP_ATOMIC);\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_association_put(asoc);\n}", "target": 1}
{"code": "static enum AVPixelFormat h263_get_format(AVCodecContext *avctx)\n{\n    if (avctx->bits_per_raw_sample > 8) {\n        av_assert1(avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);\n        return avctx->pix_fmt;\n    }\n    if (avctx->codec->id == AV_CODEC_ID_MSS2)\n        return AV_PIX_FMT_YUV420P;\n    if (CONFIG_GRAY && (avctx->flags & AV_CODEC_FLAG_GRAY)) {\n        if (avctx->color_range == AVCOL_RANGE_UNSPECIFIED)\n            avctx->color_range = AVCOL_RANGE_MPEG;\n        return AV_PIX_FMT_GRAY8;\n    }\n    return avctx->pix_fmt = ff_get_format(avctx, avctx->codec->pix_fmts);\n}", "target": 1}
{"code": "ref_stack_pop_block(ref_stack_t *pstack)\n{\n    s_ptr bot = pstack->bot;\n    uint count = pstack->p + 1 - bot;\n    ref_stack_block *pcur =\n    (ref_stack_block *) pstack->current.value.refs;\n    ref_stack_block *pnext =\n    (ref_stack_block *) pcur->next.value.refs;\n    uint used;\n    ref *body;\n    ref next;\n    if (pnext == 0)\n        return_error(pstack->params->underflow_error);\n    used = r_size(&pnext->used);\n    body = (ref *) (pnext + 1) + pstack->params->bot_guard;\n    next = pcur->next;\n    if (used + count > pstack->body_size) {\n        uint moved = pstack->body_size - count;\n        uint left;\n        if (moved == 0)\n            return_error(gs_error_Fatal);\n        memmove(bot + moved, bot, count * sizeof(ref));\n        left = used - moved;\n        memcpy(bot, body + left, moved * sizeof(ref));\n        refset_null_new(body + left, moved, 0);\n        r_dec_size(&pnext->used, moved);\n        pstack->p = pstack->top;\n        pstack->extension_used -= moved;\n    } else {\n        memcpy(body + used, bot, count * sizeof(ref));\n        pstack->bot = bot = body;\n        pstack->top = bot + pstack->body_size - 1;\n        gs_free_ref_array(pstack->memory, &pstack->current,\n                          \"ref_stack_pop_block\");\n        pstack->current = next;\n        pstack->p = bot + (used + count - 1);\n        pstack->extension_size -= pstack->body_size;\n        pstack->extension_used -= used;\n    }\n    return 0;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    OpInputList ragged_nested_splits_in;\n    OP_REQUIRES_OK(context, context->input_list(\"rt_nested_splits\",\n                                                &ragged_nested_splits_in));\n    const int ragged_nested_splits_len = ragged_nested_splits_in.size();\n    RaggedTensorVariant batched_ragged_input;\n    batched_ragged_input.set_values(context->input(ragged_nested_splits_len));\n    batched_ragged_input.mutable_nested_splits()->reserve(\n        ragged_nested_splits_len);\n    for (int i = 0; i < ragged_nested_splits_len; i++) {\n      batched_ragged_input.append_splits(ragged_nested_splits_in[i]);\n    }\n    if (!batched_input_) {\n      Tensor* encoded_scalar;\n      OP_REQUIRES_OK(context, context->allocate_output(0, TensorShape({}),\n                                                       &encoded_scalar));\n      encoded_scalar->scalar<Variant>()() = std::move(batched_ragged_input);\n      return;\n    }\n    OP_REQUIRES(context, ragged_nested_splits_len > 0,\n                errors::InvalidArgument(\n                    \"rt_nested_splits must be a list of one or more, but \"\n                    \"received rt_nested_splits of length 0.\"));\n    std::vector<RaggedTensorVariant> unbatched_ragged_input;\n    auto batched_splits_top_vec =\n        batched_ragged_input.splits(0).vec<SPLIT_TYPE>();\n    int num_components = batched_splits_top_vec.size() - 1;\n    OP_REQUIRES(context, num_components >= 0,\n                errors::Internal(\"Invalid split argument.\"));\n    OP_REQUIRES_OK(context, UnbatchRaggedZerothDim<VALUE_TYPE, SPLIT_TYPE>(\n                                batched_ragged_input, &unbatched_ragged_input));\n    Tensor* encoded_vector;\n    int output_size = unbatched_ragged_input.size();\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, TensorShape({output_size}),\n                                            &encoded_vector));\n    auto encoded_vector_t = encoded_vector->vec<Variant>();\n    for (int i = 0; i < output_size; i++) {\n      encoded_vector_t(i) = unbatched_ragged_input[i];\n    }\n  }", "target": 0}
{"code": "static int vhost_attach_cgroups(struct vhost_dev *dev)\n{\n\tstruct vhost_attach_cgroups_struct attach;\n\tattach.owner = current;\n\tvhost_work_init(&attach.work, vhost_attach_cgroups_work);\n\tvhost_work_queue(dev, &attach.work);\n\tvhost_work_flush(dev, &attach.work);\n\treturn attach.ret;\n}", "target": 0}
{"code": "void altivec_unavailable_exception(struct pt_regs *regs)\n{\n#if !defined(CONFIG_ALTIVEC)\n\tif (user_mode(regs)) {\n\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\t\treturn;\n\t}\n#endif\n\tprintk(KERN_EMERG \"Unrecoverable VMX/Altivec Unavailable Exception \"\n\t\t\t\"%lx at %lx\\n\", regs->trap, regs->nip);\n\tdie(\"Unrecoverable VMX/Altivec Unavailable Exception\", regs, SIGABRT);\n}", "target": 1}
{"code": "static void youngcollection (lua_State *L, global_State *g) {\n  GCObject **psurvival;  \n  lua_assert(g->gcstate == GCSpropagate);\n  markold(g, g->survival, g->reallyold);\n  markold(g, g->finobj, g->finobjrold);\n  atomic(L);\n  psurvival = sweepgen(L, g, &g->allgc, g->survival);\n  sweepgen(L, g, psurvival, g->reallyold);\n  g->reallyold = g->old;\n  g->old = *psurvival;  \n  g->survival = g->allgc;  \n  psurvival = sweepgen(L, g, &g->finobj, g->finobjsur);\n  sweepgen(L, g, psurvival, g->finobjrold);\n  g->finobjrold = g->finobjold;\n  g->finobjold = *psurvival;  \n  g->finobjsur = g->finobj;  \n  sweepgen(L, g, &g->tobefnz, NULL);\n  finishgencycle(L, g);\n}", "target": 1}
{"code": "static void resv_map_put(struct vm_area_struct *vma)\n{\n\tstruct resv_map *reservations = vma_resv_map(vma);\n\tif (!reservations)\n\t\treturn;\n\tkref_put(&reservations->refs, resv_map_release);\n}", "target": 0}
{"code": "static void commit_tree(struct mount *mnt, struct mount *shadows)\n{\n\tstruct mount *parent = mnt->mnt_parent;\n\tstruct mount *m;\n\tLIST_HEAD(head);\n\tstruct mnt_namespace *n = parent->mnt_ns;\n\tBUG_ON(parent == mnt);\n\tlist_add_tail(&head, &mnt->mnt_list);\n\tlist_for_each_entry(m, &head, mnt_list)\n\t\tm->mnt_ns = n;\n\tlist_splice(&head, n->list.prev);\n\tn->mounts += n->pending_mounts;\n\tn->pending_mounts = 0;\n\tattach_shadowed(mnt, parent, shadows);\n\ttouch_mnt_namespace(n);\n}", "target": 0}
{"code": "read_pbm_integer(j_compress_ptr cinfo, FILE *infile, unsigned int maxval)\n{\n  register int ch;\n  register unsigned int val;\n  do {\n    ch = pbm_getc(infile);\n    if (ch == EOF)\n      ERREXIT(cinfo, JERR_INPUT_EOF);\n  } while (ch == ' ' || ch == '\\t' || ch == '\\n' || ch == '\\r');\n  if (ch < '0' || ch > '9')\n    ERREXIT(cinfo, JERR_PPM_NONNUMERIC);\n  val = ch - '0';\n  while ((ch = pbm_getc(infile)) >= '0' && ch <= '9') {\n    val *= 10;\n    val += ch - '0';\n  }\n  if (val > maxval)\n    ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n  return val;\n}", "target": 1}
{"code": "static int ensureDir(rpmPlugins plugins, const char *p, int owned, int create)\n{\n    char *path = xstrdup(p);\n    char *dp = path;\n    char *sp = NULL, *bn;\n    int oflags = O_RDONLY;\n    int dirfd = fsmOpenat(-1, \"/\", oflags);\n    int fd = dirfd; \n    while ((bn = strtok_r(dp, \"/\", &sp)) != NULL) {\n\tstruct stat sb;\n\tfd = fsmOpenat(dirfd, bn, oflags);\n\tif (fd < 0 && errno == ENOENT && create) {\n\t    mode_t mode = S_IFDIR | (_dirPerms & 07777);\n\t    if (fsmDoMkDir(plugins, dirfd, bn, owned, mode) == 0) {\n\t\tfd = fsmOpenat(dirfd, bn, oflags|O_NOFOLLOW);\n\t    }\n\t}\n\tif (fd >= 0 && fstat(fd, &sb) == 0 && !S_ISDIR(sb.st_mode)) {\n\t    close(fd);\n\t    errno = ENOTDIR;\n\t    fd = -1;\n\t}\n\tclose(dirfd);\n\tif (fd >= 0) {\n\t    dirfd = fd;\n\t} else {\n\t    dirfd = -1;\n\t    rpmlog(RPMLOG_ERR, _(\"failed to open dir %s of %s: %s\\n\"),\n\t\t\t\tbn, p, strerror(errno));\n\t    break;\n\t}\n\tdp = NULL;\n    }\n    free(path);\n    return dirfd;\n}", "target": 0}
{"code": "asmlinkage long compat_sys_recvmmsg(int fd, struct compat_mmsghdr __user *mmsg,\n\t\t\t\t    unsigned int vlen, unsigned int flags,\n\t\t\t\t    struct compat_timespec __user *timeout)\n{\n\tint datagrams;\n\tstruct timespec ktspec;\n\tif (flags & MSG_CMSG_COMPAT)\n\t\treturn -EINVAL;\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT,\n\t\t\t\t      (struct timespec *) timeout);\n\tif (timeout == NULL)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT, NULL);\n\tif (get_compat_timespec(&ktspec, timeout))\n\t\treturn -EFAULT;\n\tdatagrams = __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t   flags | MSG_CMSG_COMPAT, &ktspec);\n\tif (datagrams > 0 && put_compat_timespec(&ktspec, timeout))\n\t\tdatagrams = -EFAULT;\n\treturn datagrams;\n}", "target": 1}
{"code": "static int ha_quic_add_handshake_data(SSL *ssl, enum ssl_encryption_level_t level,\n                                      const uint8_t *data, size_t len)\n{\n\tint ret = 0;\n\tstruct quic_conn *qc = SSL_get_ex_data(ssl, ssl_qc_app_data_index);\n\tstruct quic_enc_level **qel = ssl_to_qel_addr(qc, level);\n\tstruct quic_pktns **pktns = ssl_to_quic_pktns(qc, level);\n\tTRACE_ENTER(QUIC_EV_CONN_ADDDATA, qc);\n\tTRACE_PROTO(\"ha_quic_add_handshake_data() called\", QUIC_EV_CONN_IO_CB, qc, NULL, ssl);\n#ifdef HAVE_SSL_0RTT_QUIC\n\tif ((qc->flags & QUIC_FL_CONN_NO_TOKEN_RCVD) && qc_ssl_eary_data_accepted(ssl)) {\n\t\tTRACE_PROTO(\"connection to be killed\", QUIC_EV_CONN_ADDDATA, qc);\n\t\tqc->flags |= QUIC_FL_CONN_TO_KILL|QUIC_FL_CONN_SEND_RETRY;\n\t\tgoto leave;\n\t}\n#endif\n\tif (qc->flags & QUIC_FL_CONN_TO_KILL) {\n\t\tTRACE_PROTO(\"connection to be killed\", QUIC_EV_CONN_ADDDATA, qc);\n\t\tgoto out;\n\t}\n\tif (qc->flags & QUIC_FL_CONN_IMMEDIATE_CLOSE) {\n\t\tTRACE_PROTO(\"CC required\", QUIC_EV_CONN_ADDDATA, qc);\n\t\tgoto out;\n\t}\n\tif (!*qel && !qc_enc_level_alloc(qc, pktns, qel, level))\n\t\tgoto leave;\n\tif (!qc_ssl_crypto_data_cpy(qc, *qel, data, len)) {\n\t\tTRACE_ERROR(\"Could not bufferize\", QUIC_EV_CONN_ADDDATA, qc);\n\t\tgoto leave;\n\t}\n\tTRACE_DEVEL(\"CRYPTO data buffered\", QUIC_EV_CONN_ADDDATA,\n\t            qc, &level, &len);\n out:\n\tret = 1;\n leave:\n\tTRACE_LEAVE(QUIC_EV_CONN_ADDDATA, qc);\n\treturn ret;\n}", "target": 0}
{"code": "void HeaderTable::setCapacity(uint32_t capacity) {\n  auto oldCapacity = capacity_;\n  capacity_ = capacity;\n  if (capacity_ <= oldCapacity) {\n    evict(0);\n  } else {\n    auto oldTail = tail();\n    auto oldLength = table_.size();\n    uint32_t newLength = (capacity_ >> 5) + 1;\n    table_.resize(newLength);\n    if (size_ > 0 && oldTail > head_) {\n      std::copy(table_.begin() + oldTail, table_.begin() + oldLength,\n                table_.begin() + newLength - (oldLength - oldTail));\n      for (auto& names_it: names_) {\n        for (auto& idx: names_it.second) {\n          if (idx >= oldTail) {\n            DCHECK_LT(idx + (table_.size() - oldLength), table_.size());\n            idx += (table_.size() - oldLength);\n          } else {\n            break;\n          }\n        }\n      }\n    }\n  }\n}", "target": 1}
{"code": "jp2_box_t *jp2_box_create0()\n{\n\tjp2_box_t *box;\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\treturn 0;\n\t}\n\tmemset(box, 0, sizeof(jp2_box_t));\n\tbox->type = 0;\n\tbox->len = 0;\n\tbox->ops = &jp2_boxinfo_unk.ops;\n\treturn box;\n}", "target": 0}
{"code": "void bpf_map_inc(struct bpf_map *map, bool uref)\n{\n\tatomic_inc(&map->refcnt);\n\tif (uref)\n\t\tatomic_inc(&map->usercnt);\n}", "target": 1}
{"code": "setup_connection (GsmXSMPClient *client)\n{\n        GIOChannel    *channel;\n        int            fd;\n        g_debug (\"GsmXSMPClient: Setting up new connection\");\n        fd = IceConnectionNumber (client->priv->ice_connection);\n        fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);\n        channel = g_io_channel_unix_new (fd);\n        client->priv->watch_id = g_io_add_watch (channel,\n                                                 G_IO_IN | G_IO_ERR,\n                                                 (GIOFunc)client_iochannel_watch,\n                                                 client);\n        g_io_channel_unref (channel);\n        client->priv->protocol_timeout = g_timeout_add_seconds (5,\n                                                                (GSourceFunc)_client_protocol_timeout,\n                                                                client);\n        set_description (client);\n        g_debug (\"GsmXSMPClient: New client '%s'\", client->priv->description);\n}", "target": 1}
{"code": "xsltVariableComp(xsltStylesheetPtr style, xmlNodePtr inst) {\n#ifdef XSLT_REFACTORED\n    xsltStyleItemVariablePtr comp;\n#else\n    xsltStylePreCompPtr comp;\n#endif\n    if ((style == NULL) || (inst == NULL) || (inst->type != XML_ELEMENT_NODE))\n\treturn;\n#ifdef XSLT_REFACTORED\n    comp = (xsltStyleItemVariablePtr)\n\txsltNewStylePreComp(style, XSLT_FUNC_VARIABLE);\n#else\n    comp = xsltNewStylePreComp(style, XSLT_FUNC_VARIABLE);\n#endif\n    if (comp == NULL)\n\treturn;\n    inst->psvi = comp;\n    comp->inst = inst;\n    xsltGetQNameProperty(style, inst, BAD_CAST \"name\",\n\t1, &(comp->has_name), &(comp->ns), &(comp->name));\n    if (comp->ns)\n\tcomp->has_ns = 1;\n    comp->select = xsltGetCNsProp(style, inst, (const xmlChar *)\"select\",\n\t                        XSLT_NAMESPACE);\n    if (comp->select != NULL) {\n#ifndef XSLT_REFACTORED\n        xmlNodePtr cur;\n#endif\n\tcomp->comp = xsltXPathCompile(style, comp->select);\n\tif (comp->comp == NULL) {\n\t    xsltTransformError(NULL, style, inst,\n\t\t\"XSLT-variable: Failed to compile the XPath expression '%s'.\\n\",\n\t\tcomp->select);\n\t    style->errors++;\n\t}\n#ifdef XSLT_REFACTORED\n\tif (inst->children != NULL) {\n\t    xsltTransformError(NULL, style, inst,\n\t\t\"XSLT-variable: There must be no child nodes, since the \"\n\t\t\"attribute 'select' was specified.\\n\");\n\t    style->errors++;\n\t}\n#else\n        for (cur = inst->children; cur != NULL; cur = cur->next) {\n            if (cur->type != XML_COMMENT_NODE &&\n                (cur->type != XML_TEXT_NODE || !xsltIsBlank(cur->content)))\n            {\n                xsltTransformError(NULL, style, inst,\n                    \"XSLT-variable: There must be no child nodes, since the \"\n                    \"attribute 'select' was specified.\\n\");\n                style->errors++;\n            }\n        }\n#endif\n    }\n}", "target": 0}
{"code": "std::string Utf16ToUtf8(const std::wstring& utf16_string) {\n  return WC2MB(utf16_string, CP_UTF8);\n}", "target": 1}
{"code": "l_strnstart(const char *tstr1, u_int tl1, const char *str2, u_int l2)\n{\n\tif (tl1 > l2)\n\t\treturn 0;\n\treturn (strncmp(tstr1, str2, tl1) == 0 ? 1 : 0);\n}", "target": 1}
{"code": "userlist_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct passwd *pw, const struct member_list *list)\n{\n    struct member *m;\n    int matched = UNSPEC;\n    debug_decl(userlist_matches, SUDOERS_DEBUG_MATCH);\n    TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {\n\tif ((matched = user_matches(parse_tree, pw, m)) != UNSPEC)\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 1}
{"code": "auto ReferenceHandle::New(Local<Value> value, MaybeLocal<Object> options) -> unique_ptr<ReferenceHandle> {\n\tauto inherit = ReadOption<bool>(options, StringTable::Get().inheritUnsafe, false);\n\treturn std::make_unique<ReferenceHandle>(value, inherit);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& tensor_out = context->input(1);\n    const Tensor& out_grad_backprop = context->input(2);\n    OP_REQUIRES(context, tensor_in.dims() == 5,\n                errors::InvalidArgument(\"tensor_in must be 5-dimensional\"));\n    OP_REQUIRES(context, tensor_out.dims() == 5,\n                errors::InvalidArgument(\"tensor_out must be 5-dimensional\"));\n    OP_REQUIRES(\n        context, out_grad_backprop.dims() == 5,\n        errors::InvalidArgument(\"out_grad_backprop must be 5-dimensional\"));\n    Pool3dParameters params{context,  ksize_,       stride_,\n                            padding_, data_format_, tensor_in.shape()};\n    if (!context->status().ok()) return;  \n    OP_REQUIRES(context, tensor_out.shape() == params.forward_output_shape(),\n                errors::InvalidArgument(\"Expected orig_output shape to be \",\n                                        params.forward_output_shape(),\n                                        \", but got \", tensor_out.shape()));\n    OP_REQUIRES(\n        context, out_grad_backprop.shape() == tensor_in.shape(),\n        errors::InvalidArgument(\"Expected grad shape to be \", tensor_in.shape(),\n                                \", but got \", out_grad_backprop.shape()));\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {2}, 0, tensor_out.shape(), &output));\n    OP_REQUIRES(context, tensor_in.NumElements() > 0,\n                errors::InvalidArgument(\"received empty tensor tensor_in: \",\n                                        tensor_in.DebugString()));\n    OP_REQUIRES(context, tensor_out.NumElements() > 0,\n                errors::InvalidArgument(\"received empty tensor tensor_out: \",\n                                        tensor_out.DebugString()));\n    OP_REQUIRES(\n        context, out_grad_backprop.NumElements() > 0,\n        errors::InvalidArgument(\"received empty tensor out_grad_backprop: \",\n                                out_grad_backprop.DebugString()));\n    OP_REQUIRES(context,\n                tensor_in.NumElements() == out_grad_backprop.NumElements(),\n                errors::InvalidArgument(\"tensor_in and out_grad_backprop must \"\n                                        \"have same number of elements, got <\",\n                                        tensor_in.DebugString(), \"> and <\",\n                                        out_grad_backprop.DebugString(), \">\"));\n    OP_REQUIRES(\n        context, tensor_out.NumElements() == output->NumElements(),\n        errors::InvalidArgument(\n            \"tensor_out and output must have same number of elements, got <\",\n            tensor_out.DebugString(), \"> and <\", output->DebugString(), \">\"));\n    LaunchMaxPooling3dGradGradOp<Device, T>::launch(\n        context, params, tensor_in, tensor_out, out_grad_backprop, output);\n  }", "target": 0}
{"code": "bool neu_plugin_manager_schema_exist(neu_plugin_manager_t *mgr,\n                                     const char *          schema)\n{\n    bool             exist = false;\n    plugin_entity_t *el = NULL, *tmp = NULL;\n    HASH_ITER(hh, mgr->plugins, el, tmp)\n    {\n        if (strcmp(el->schema, schema) == 0) {\n            exist = true;\n            break;\n        }\n    }\n    return exist;\n}", "target": 0}
{"code": "template <> HeaderMapImpl::StaticLookupTable<RequestHeaderMap>::StaticLookupTable() {\n#define REGISTER_DEFAULT_REQUEST_HEADER(name)                                                      \\\n  CustomInlineHeaderRegistry::registerInlineHeader<RequestHeaderMap::header_map_type>(             \\\n      Headers::get().name);\n  INLINE_REQ_HEADERS(REGISTER_DEFAULT_REQUEST_HEADER)\n  INLINE_REQ_RESP_HEADERS(REGISTER_DEFAULT_REQUEST_HEADER)\n  finalizeTable();\n  const auto handle =\n      CustomInlineHeaderRegistry::getInlineHeader<RequestHeaderMap::header_map_type>(\n          Headers::get().Host);\n  add(Headers::get().HostLegacy.get().c_str(), [handle](HeaderMapImpl& h) -> StaticLookupResponse {\n    return {&h.inlineHeaders()[handle.value().it_->second], &handle.value().it_->first};\n  });\n}", "target": 0}
{"code": "  TfLiteRegistration OkOpRegistration() {\n    TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n    reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n      const TfLiteTensor* in_tensor = GetInput(context, node, 0);\n      TfLiteTensor* out_tensor = GetOutput(context, node, 0);\n      TfLiteIntArray* new_size = TfLiteIntArrayCopy(in_tensor->dims);\n      return context->ResizeTensor(context, out_tensor, new_size);\n    };\n    reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n      return kTfLiteOk;\n    };\n    return reg;\n  }", "target": 1}
{"code": "int rds_get_mr_for_dest(struct rds_sock *rs, char __user *optval, int optlen)\n{\n\tstruct rds_get_mr_for_dest_args args;\n\tstruct rds_get_mr_args new_args;\n\tif (optlen != sizeof(struct rds_get_mr_for_dest_args))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&args, (struct rds_get_mr_for_dest_args __user *)optval,\n\t\t\t   sizeof(struct rds_get_mr_for_dest_args)))\n\t\treturn -EFAULT;\n\tnew_args.vec = args.vec;\n\tnew_args.cookie_addr = args.cookie_addr;\n\tnew_args.flags = args.flags;\n\treturn __rds_rdma_map(rs, &new_args, NULL, NULL);\n}", "target": 0}
{"code": "tTcpIpPacketParsingResult ParaNdis_ReviewIPPacket(PVOID buffer, ULONG size, LPCSTR caller)\n{\n    tTcpIpPacketParsingResult res = QualifyIpPacket((IPHeader *) buffer, size);\n    PrintOutParsingResult(res, 1, caller);\n    return res;\n}", "target": 1}
{"code": "njs_json_pop_parse_state(njs_vm_t *vm, njs_json_parse_t *parse)\n{\n    njs_json_state_t  *state;\n    state = &parse->states[parse->depth - 1];\n    njs_array_destroy(vm, state->keys);\n    state->keys = NULL;\n    if (parse->depth > 1) {\n        parse->depth--;\n        return &parse->states[parse->depth - 1];\n    }\n    return NULL;\n}", "target": 1}
{"code": "validate_event(struct pmu_hw_events *hw_events,\n\t       struct perf_event *event)\n{\n\tstruct arm_pmu *armpmu = to_arm_pmu(event->pmu);\n\tstruct hw_perf_event fake_event = event->hw;\n\tstruct pmu *leader_pmu = event->group_leader->pmu;\n\tif (is_software_event(event))\n\t\treturn 1;\n\tif (event->pmu != leader_pmu || event->state < PERF_EVENT_STATE_OFF)\n\t\treturn 1;\n\tif (event->state == PERF_EVENT_STATE_OFF && !event->attr.enable_on_exec)\n\t\treturn 1;\n\treturn armpmu->get_event_idx(hw_events, &fake_event) >= 0;\n}", "target": 1}
{"code": "static int em_syscall(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tu16 cs_sel, ss_sel;\n\tu64 efer = 0;\n\tif (ctxt->mode == X86EMUL_MODE_REAL ||\n\t    ctxt->mode == X86EMUL_MODE_VM86)\n\t\treturn emulate_ud(ctxt);\n\tif (!(em_syscall_is_enabled(ctxt)))\n\t\treturn emulate_ud(ctxt);\n\tops->get_msr(ctxt, MSR_EFER, &efer);\n\tsetup_syscalls_segments(ctxt, &cs, &ss);\n\tif (!(efer & EFER_SCE))\n\t\treturn emulate_ud(ctxt);\n\tops->get_msr(ctxt, MSR_STAR, &msr_data);\n\tmsr_data >>= 32;\n\tcs_sel = (u16)(msr_data & 0xfffc);\n\tss_sel = (u16)(msr_data + 8);\n\tif (efer & EFER_LMA) {\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t}\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n\tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n\tctxt->regs[VCPU_REGS_RCX] = ctxt->_eip;\n\tif (efer & EFER_LMA) {\n#ifdef CONFIG_X86_64\n\t\tctxt->regs[VCPU_REGS_R11] = ctxt->eflags & ~EFLG_RF;\n\t\tops->get_msr(ctxt,\n\t\t\t     ctxt->mode == X86EMUL_MODE_PROT64 ?\n\t\t\t     MSR_LSTAR : MSR_CSTAR, &msr_data);\n\t\tctxt->_eip = msr_data;\n\t\tops->get_msr(ctxt, MSR_SYSCALL_MASK, &msr_data);\n\t\tctxt->eflags &= ~(msr_data | EFLG_RF);\n#endif\n\t} else {\n\t\tops->get_msr(ctxt, MSR_STAR, &msr_data);\n\t\tctxt->_eip = (u32)msr_data;\n\t\tctxt->eflags &= ~(EFLG_VM | EFLG_IF | EFLG_RF);\n\t}\n\treturn X86EMUL_CONTINUE;\n}", "target": 0}
{"code": "bqarr_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *buf = (char *) PG_GETARG_POINTER(0);\n\tWORKSTATE\tstate;\n\tint32\t\ti;\n\tQUERYTYPE  *query;\n\tint32\t\tcommonlen;\n\tITEM\t   *ptr;\n\tNODE\t   *tmp;\n\tint32\t\tpos = 0;\n#ifdef BS_DEBUG\n\tStringInfoData pbuf;\n#endif\n\tstate.buf = buf;\n\tstate.state = WAITOPERAND;\n\tstate.count = 0;\n\tstate.num = 0;\n\tstate.str = NULL;\n\tmakepol(&state);\n\tif (!state.num)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"empty query\")));\n\tif (state.num > QUERYTYPEMAXITEMS)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\terrmsg(\"number of query items (%d) exceeds the maximum allowed (%d)\",\n\t\t\t   state.num, (int) QUERYTYPEMAXITEMS)));\n\tcommonlen = COMPUTESIZE(state.num);\n\tquery = (QUERYTYPE *) palloc(commonlen);\n\tSET_VARSIZE(query, commonlen);\n\tquery->size = state.num;\n\tptr = GETQUERY(query);\n\tfor (i = state.num - 1; i >= 0; i--)\n\t{\n\t\tptr[i].type = state.str->type;\n\t\tptr[i].val = state.str->val;\n\t\ttmp = state.str->next;\n\t\tpfree(state.str);\n\t\tstate.str = tmp;\n\t}\n\tpos = query->size - 1;\n\tfindoprnd(ptr, &pos);\n#ifdef BS_DEBUG\n\tinitStringInfo(&pbuf);\n\tfor (i = 0; i < query->size; i++)\n\t{\n\t\tif (ptr[i].type == OPR)\n\t\t\tappendStringInfo(&pbuf, \"%c(%d) \", ptr[i].val, ptr[i].left);\n\t\telse\n\t\t\tappendStringInfo(&pbuf, \"%d \", ptr[i].val);\n\t}\n\telog(DEBUG3, \"POR: %s\", pbuf.data);\n\tpfree(pbuf.data);\n#endif\n\tPG_RETURN_POINTER(query);\n}", "target": 0}
{"code": "static int em_loop(struct x86_emulate_ctxt *ctxt)\n{\n\tregister_address_increment(ctxt, reg_rmw(ctxt, VCPU_REGS_RCX), -1);\n\tif ((address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) != 0) &&\n\t    (ctxt->b == 0xe2 || test_cc(ctxt->b ^ 0x5, ctxt->eflags)))\n\t\tjmp_rel(ctxt, ctxt->src.val);\n\treturn X86EMUL_CONTINUE;\n}", "target": 1}
{"code": "static inline ut32 r_read_at_le32(const void *src, size_t offset) {\n\tif (!src) {\n\t\treturn UT32_MAX;\n\t}\n\tconst ut8 *s = (const ut8*)src + offset;\n\treturn r_read_le32 (s);\n}", "target": 0}
{"code": "GF_Err gf_swf_read_header(SWFReader *read)\n{\n\tSWFRec rc;\n\tu8 sig[3];\n\tsig[0] = gf_bs_read_u8(read->bs);\n\tsig[1] = gf_bs_read_u8(read->bs);\n\tsig[2] = gf_bs_read_u8(read->bs);\n\tif ( ((sig[0] != 'F') && (sig[0] != 'C')) || (sig[1] != 'W') || (sig[2] != 'S') ) {\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tgf_bs_read_u8(read->bs);\n\tread->length = swf_get_32(read);\n\tif (sig[0] == 'C') {\n\t\tswf_init_decompress(read);\n\t\tif (!read->bs) return GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tswf_get_rec(read, &rc);\n\tread->width = rc.w;\n\tread->height = rc.h;\n\tswf_align(read);\n\tread->frame_rate = swf_get_16(read)>>8;\n\tread->frame_count = swf_get_16(read);\n\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"SWF Import - Scene Size %gx%g - %d frames @ %d FPS\\n\", read->width, read->height, read->frame_count, read->frame_rate));\n\tif (!read->frame_rate) read->frame_rate = 1;\n\treturn GF_OK;\n}", "target": 0}
{"code": "local block_state deflate_fast(s, flush)\n    deflate_state *s;\n    int flush;\n{\n    IPos hash_head;       \n    int bflush;           \n    for (;;) {\n        if (s->lookahead < MIN_LOOKAHEAD) {\n            fill_window(s);\n            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {\n                return need_more;\n            }\n            if (s->lookahead == 0) break; \n        }\n        hash_head = NIL;\n        if (s->lookahead >= MIN_MATCH) {\n            INSERT_STRING(s, s->strstart, hash_head);\n        }\n        if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {\n            s->match_length = longest_match (s, hash_head);\n        }\n        if (s->match_length >= MIN_MATCH) {\n            check_match(s, s->strstart, s->match_start, s->match_length);\n            _tr_tally_dist(s, s->strstart - s->match_start,\n                           s->match_length - MIN_MATCH, bflush);\n            s->lookahead -= s->match_length;\n#ifndef FASTEST\n            if (s->match_length <= s->max_insert_length &&\n                s->lookahead >= MIN_MATCH) {\n                s->match_length--; \n                do {\n                    s->strstart++;\n                    INSERT_STRING(s, s->strstart, hash_head);\n                } while (--s->match_length != 0);\n                s->strstart++;\n            } else\n#endif\n            {\n                s->strstart += s->match_length;\n                s->match_length = 0;\n                s->ins_h = s->window[s->strstart];\n                UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);\n#if MIN_MATCH != 3\n                Call UPDATE_HASH() MIN_MATCH-3 more times\n#endif\n            }\n        } else {\n            Tracevv((stderr,\"%c\", s->window[s->strstart]));\n            _tr_tally_lit (s, s->window[s->strstart], bflush);\n            s->lookahead--;\n            s->strstart++;\n        }\n        if (bflush) FLUSH_BLOCK(s, 0);\n    }\n    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->last_lit)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}", "target": 1}
{"code": "x509_verify_ctx_add_chain(struct x509_verify_ctx *ctx,\n    struct x509_verify_chain *chain, char *name)\n{\n\tsize_t depth;\n\tX509 *last = x509_verify_chain_last(chain);\n\tX509 *leaf = x509_verify_chain_leaf(chain);\n\tdepth = sk_X509_num(chain->certs);\n\tif (depth > 0)\n\t\tdepth--;\n\tif (ctx->chains_count >= ctx->max_chains)\n\t\treturn x509_verify_cert_error(ctx, last, depth,\n\t\t    X509_V_ERR_CERT_CHAIN_TOO_LONG, 0);\n\tif (chain->cert_errors[depth] ==\n\t    X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)\n\t\tchain->cert_errors[depth] = X509_V_OK;\n\tif (!x509_verify_ctx_validate_legacy_chain(ctx, chain, depth))\n\t\treturn 0;\n\tif ((ctx->chains[ctx->chains_count] = x509_verify_chain_dup(chain)) ==\n\t    NULL) {\n\t\treturn x509_verify_cert_error(ctx, last, depth,\n\t\t    X509_V_ERR_OUT_OF_MEM, 0);\n\t}\n\tif (!x509_verify_cert_valid(ctx, leaf, NULL))\n\t\treturn 0;\n\tif (!x509_verify_cert_hostname(ctx, leaf, name))\n\t\treturn 0;\n\tctx->chains_count++;\n\tctx->error = X509_V_OK;\n\tctx->error_depth = depth;\n\treturn 1;\n}", "target": 1}
{"code": "NAN_METHOD(DetectCharacterEncoding) {\n\tNan::HandleScope scope;\n\tv8::Local<v8::Object> inputBuffer = info[0]->ToObject();\n\tUCharsetDetector *charsetDetector;\n\tconst UCharsetMatch *charsetMatch;\n\tUErrorCode errorCode = U_ZERO_ERROR;\n\tcharsetDetector = ucsdet_open(&errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to open ICU charset detector.\");\n\t\treturn;\n\t}\n\tucsdet_setText(\n\t\tcharsetDetector,\n\t\tnode::Buffer::Data(inputBuffer),\n\t\tnode::Buffer::Length(inputBuffer),\n\t\t&errorCode\n\t);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to set ICU charset detectors text.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tcharsetMatch = ucsdet_detect(charsetDetector, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to detect charset.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tconst char *charsetName = ucsdet_getName(charsetMatch, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get name from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tint32_t confidence = ucsdet_getConfidence(charsetMatch, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get confidence from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tv8::Local<v8::Object> obj = Nan::New<v8::Object>();\n\tobj->Set(Nan::New<v8::String>(\"encoding\").ToLocalChecked(), Nan::New<v8::String>(charsetName).ToLocalChecked());\n\tobj->Set(Nan::New<v8::String>(\"confidence\").ToLocalChecked(), Nan::New<v8::Number>(confidence));\n\tinfo.GetReturnValue().Set(obj);\n\tucsdet_close(charsetDetector);\n}", "target": 0}
{"code": "void CoreNetwork::putCmd(const QString &cmd, const QList<QList<QByteArray>> &params, const QByteArray &prefix)\n{\n    QListIterator<QList<QByteArray>> i(params);\n    while (i.hasNext()) {\n        QList<QByteArray> msg = i.next();\n        putCmd(cmd, msg, prefix);\n    }\n}", "target": 0}
{"code": "EntropyParser::EntropyParser(class Frame *frame,class Scan *scan)\n  : JKeeper(scan->EnvironOf()), m_pScan(scan), m_pFrame(frame)\n{\n  m_ucCount = scan->ComponentsInScan();\n  for(volatile UBYTE i = 0;i < m_ucCount && i < 4;i++) {\n    JPG_TRY {\n      m_pComponent[i] = scan->ComponentOf(i);\n    } JPG_CATCH {\n      m_pComponent[i] = NULL;\n    } JPG_ENDTRY;\n  }\n  m_ulRestartInterval   = m_pFrame->TablesOf()->RestartIntervalOf();\n  m_usNextRestartMarker = 0xffd0;\n  m_ulMCUsToGo          = m_ulRestartInterval;\n  m_bSegmentIsValid     = true;\n  m_bScanForDNL         = (m_pFrame->HeightOf() == 0)?true:false;\n  m_bDNLFound           = false;\n}", "target": 1}
{"code": "static void ikev2_parent_inR1outI2_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct dh_continuation *dh = (struct dh_continuation *)pcrc;\n\tstruct msg_digest *md = dh->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent inR1outI2: calculating g^{xy}, sending I2\"));\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t\treturn;\n\t}\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\tpassert(st->st_suspended_md == dh->md);\n\tset_suspended(st, NULL); \n\tset_cur_state(st);\n\tst->st_calculating = FALSE;\n\te = ikev2_parent_inR1outI2_tail(pcrc, r);\n\tif (dh->md != NULL) {\n\t\tcomplete_v2_state_transition(&dh->md, e);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t}\n\treset_globals();\n\tpassert(GLOBALS_ARE_RESET());\n}", "target": 1}
{"code": "unsigned int add_ch(unsigned char ch, unsigned char* buf, unsigned int idx) {\n    if (idx >= MAX_ALN) {\n        verbprintf(3, \"FLEX: idx %u >= MAX_ALN %u\\n\", idx, MAX_ALN);\n        return 0;\n    }\n    if (ch == 0x09 && idx < (MAX_ALN - 2)) {  \n        buf[idx] = '\\\\';\n        buf[idx + 1] = 't';\n        return 2;\n    }\n    if (ch == 0x0a && idx < (MAX_ALN - 2)) {  \n        buf[idx] = '\\\\';\n        buf[idx + 1] = 'n';\n        return 2;\n    }\n    if (ch == 0x0d && idx < (MAX_ALN - 2)) {  \n        buf[idx] = '\\\\';\n        buf[idx + 1] = 'r';\n        return 2;\n    }\n    if (ch == '%') {\n        if (idx < (MAX_ALN - 2)) {\n            buf[idx] = '%';\n            buf[idx + 1] = '%';\n            return 2;\n        }\n        return 0;\n    }\n    if (ch >= 32 && ch <= 126) {\n        buf[idx] = ch;\n        return 1;\n    }\n    return 0;\n}", "target": 0}
{"code": "static void process_blob(struct rev_info *revs,\n\t\t\t struct blob *blob,\n\t\t\t show_object_fn show,\n\t\t\t struct strbuf *path,\n\t\t\t const char *name,\n\t\t\t void *cb_data)\n{\n\tstruct object *obj = &blob->object;\n\tif (!revs->blob_objects)\n\t\treturn;\n\tif (!obj)\n\t\tdie(\"bad blob object\");\n\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\treturn;\n\tobj->flags |= SEEN;\n\tshow(obj, path, name, cb_data);\n}", "target": 1}
{"code": "void *jas_realloc(void *ptr, size_t size)\n{\n\tvoid *result;\n\tJAS_DBGLOG(101, (\"jas_realloc called with %x,%zu\\n\", ptr, size));\n\tresult = realloc(ptr, size);\n\tJAS_DBGLOG(100, (\"jas_realloc(%p, %zu) -> %p\\n\", ptr, size, result));\n\treturn result;\n}", "target": 1}
{"code": "nfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct nfs4_acl *acl)\n{\n\t__be32 error;\n\tint host_error;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tstruct posix_acl *pacl = NULL, *dpacl = NULL;\n\tunsigned int flags = 0;\n\terror = fh_verify(rqstp, fhp, 0, NFSD_MAY_SATTR);\n\tif (error)\n\t\treturn error;\n\tdentry = fhp->fh_dentry;\n\tinode = d_inode(dentry);\n\tif (!inode->i_op->set_acl || !IS_POSIXACL(inode))\n\t\treturn nfserr_attrnotsupp;\n\tif (S_ISDIR(inode->i_mode))\n\t\tflags = NFS4_ACL_DIR;\n\thost_error = nfs4_acl_nfsv4_to_posix(acl, &pacl, &dpacl, flags);\n\tif (host_error == -EINVAL)\n\t\treturn nfserr_attrnotsupp;\n\tif (host_error < 0)\n\t\tgoto out_nfserr;\n\thost_error = inode->i_op->set_acl(inode, pacl, ACL_TYPE_ACCESS);\n\tif (host_error < 0)\n\t\tgoto out_release;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\thost_error = inode->i_op->set_acl(inode, dpacl,\n\t\t\t\t\t\t  ACL_TYPE_DEFAULT);\n\t}\nout_release:\n\tposix_acl_release(pacl);\n\tposix_acl_release(dpacl);\nout_nfserr:\n\tif (host_error == -EOPNOTSUPP)\n\t\treturn nfserr_attrnotsupp;\n\telse\n\t\treturn nfserrno(host_error);\n}", "target": 1}
{"code": "x509stack_peek_level(struct cert_stack *stack)\n{\n\tstruct repo_level_node *repo = SLIST_FIRST(&stack->levels);\n\treturn (repo != NULL) ? repo->level : 0;\n}", "target": 1}
{"code": "MONGO_EXPORT int bson_buffer_size( const bson *b ) {\n    return (b->cur - b->data + 1);\n}", "target": 1}
{"code": "ftrace_regex_lseek(struct file *file, loff_t offset, int whence)\n{\n\tloff_t ret;\n\tif (file->f_mode & FMODE_READ)\n\t\tret = seq_lseek(file, offset, whence);\n\telse\n\t\tfile->f_pos = ret = 1;\n\treturn ret;\n}", "target": 1}
{"code": "PixarLogClose(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\ttd->td_bitspersample = 8;\n\ttd->td_sampleformat = SAMPLEFORMAT_UINT;\n}", "target": 1}
{"code": "uint16_t nvme_bounce_data(NvmeCtrl *n, uint8_t *ptr, uint32_t len,\n                          NvmeTxDirection dir, NvmeRequest *req)\n{\n    NvmeNamespace *ns = req->ns;\n    NvmeRwCmd *rw = (NvmeRwCmd *)&req->cmd;\n    bool pi = !!NVME_ID_NS_DPS_TYPE(ns->id_ns.dps);\n    bool pract = !!(le16_to_cpu(rw->control) & NVME_RW_PRINFO_PRACT);\n    if (nvme_ns_ext(ns) && !(pi && pract && ns->lbaf.ms == 8)) {\n        return nvme_tx_interleaved(n, &req->sg, ptr, len, ns->lbasz,\n                                   ns->lbaf.ms, 0, dir);\n    }\n    return nvme_tx(n, &req->sg, ptr, len, dir);\n}", "target": 0}
{"code": "poly_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tPOLYGON    *poly;\n\tint\t\t\tnpts;\n\tint\t\t\tsize;\n\tint\t\t\tisopen;\n\tchar\t   *s;\n\tif ((npts = pair_count(str, ',')) <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t  errmsg(\"invalid input syntax for type polygon: \\\"%s\\\"\", str)));\n\tsize = offsetof(POLYGON, p[0]) +sizeof(poly->p[0]) * npts;\n\tpoly = (POLYGON *) palloc0(size);\t\n\tSET_VARSIZE(poly, size);\n\tpoly->npts = npts;\n\tif ((!path_decode(FALSE, npts, str, &isopen, &s, &(poly->p[0])))\n\t\t|| (*s != '\\0'))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t  errmsg(\"invalid input syntax for type polygon: \\\"%s\\\"\", str)));\n\tmake_bound_box(poly);\n\tPG_RETURN_POLYGON_P(poly);\n}", "target": 1}
{"code": "void ast_dns_resolver_completed(struct ast_dns_query *query)\n{\n\tsort_result(ast_dns_query_get_rr_type(query), query->result);\n\tquery->callback(query);\n}", "target": 1}
{"code": "raptor_rss_parse_start(raptor_parser *rdf_parser) \n{\n  raptor_uri *uri = rdf_parser->base_uri;\n  raptor_rss_parser* rss_parser = (raptor_rss_parser*)rdf_parser->context;\n  int n;\n  if(!uri)\n    return 1;\n  for(n = 0; n < RAPTOR_RSS_NAMESPACES_SIZE; n++)\n    rss_parser->nspaces_seen[n] = 'N';\n  raptor_sax2_set_option(rss_parser->sax2, \n                         RAPTOR_OPTION_NO_NET, NULL,\n                         RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NO_NET));\n  raptor_sax2_set_option(rss_parser->sax2, \n                         RAPTOR_OPTION_NO_FILE, NULL,\n                         RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NO_FILE));\n  raptor_sax2_set_option(rss_parser->sax2, \n                         RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES, NULL,\n                         RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES));\n  if(rdf_parser->uri_filter)\n    raptor_sax2_set_uri_filter(rss_parser->sax2, rdf_parser->uri_filter,\n                               rdf_parser->uri_filter_user_data);\n  raptor_sax2_parse_start(rss_parser->sax2, uri);\n  return 0;\n}", "target": 0}
{"code": "static OPJ_BOOL opj_j2k_write_sod(opj_j2k_t *p_j2k,\n                                  opj_tcd_t * p_tile_coder,\n                                  OPJ_BYTE * p_data,\n                                  OPJ_UINT32 * p_data_written,\n                                  OPJ_UINT32 p_total_data_size,\n                                  const opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager\n                                 )\n{\n    opj_codestream_info_t *l_cstr_info = 00;\n    OPJ_UINT32 l_remaining_data;\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n    OPJ_UNUSED(p_stream);\n    if (p_total_data_size < 4) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Not enough bytes in output buffer to write SOD marker\\n\");\n        return OPJ_FALSE;\n    }\n    opj_write_bytes(p_data, J2K_MS_SOD,\n                    2);                                 \n    p_data += 2;\n    l_remaining_data =  p_total_data_size - 4;\n    p_tile_coder->tp_num =\n        p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number ;\n    p_tile_coder->cur_tp_num =\n        p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;\n#ifdef USE_JPWL\n    assert(0 && \"TODO\");\n#endif \n    if (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number == 0) {\n        p_tile_coder->tcd_image->tiles->packno = 0;\n        if (l_cstr_info) {\n            l_cstr_info->packno = 0;\n        }\n    }\n    *p_data_written = 0;\n    if (! opj_tcd_encode_tile(p_tile_coder, p_j2k->m_current_tile_number, p_data,\n                              p_data_written, l_remaining_data, l_cstr_info,\n                              p_manager)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Cannot encode tile\\n\");\n        return OPJ_FALSE;\n    }\n    *p_data_written += 2;\n    return OPJ_TRUE;\n}", "target": 0}
{"code": "set_range(bitstr_t *bits, int low, int high, int start, int stop, int step) {\n\tDebug(DPARS|DEXT, (\"set_range(?,%d,%d,%d,%d,%d)\\n\",\n\t\t\t   low, high, start, stop, step))\n\tif (start < low || stop > high)\n\t\treturn (EOF);\n\tstart -= low;\n\tstop -= low;\n\tif (step == 1) {\n\t\tbit_nset(bits, start, stop);\n\t} else {\n\t\tfor (int i = start; i <= stop; i += step)\n\t\t\tbit_set(bits, i);\n\t}\n\treturn (OK);\n}", "target": 1}
{"code": "static void* OGRExpatRealloc( void *ptr, size_t size )\n{\n    if( CanAlloc(size) )\n        return realloc(ptr, size);\n    free(ptr);\n    return nullptr;\n}", "target": 1}
{"code": "static void split_certinfo(char *string, zval *hash)\n{\n\tchar *org = estrdup(string);\n\tchar *s = org;\n\tchar *split;\n\tif(org) {\n\t\tdo {\n\t\t\tchar *key;\n\t\t\tchar *val;\n\t\t\tchar *tmp;\n\t\t\tsplit = strstr(s, \"; \");\n\t\t\tif(split)\n\t\t\t\t*split = '\\0';\n\t\t\tkey = s;\n\t\t\ttmp = memchr(key, '=', 64);\n\t\t\tif(tmp) {\n\t\t\t\t*tmp = '\\0';\n\t\t\t\tval = tmp+1;\n\t\t\t\tadd_assoc_string(hash, key, val, 1);\n\t\t\t}\n\t\t\ts = split+2;\n\t\t} while(split);\n\t\tefree(org);\n\t}\n}", "target": 0}
{"code": "int X509_cmp_time(const ASN1_TIME *ctm, time_t *cmp_time)\n{\n    char *str;\n    ASN1_TIME atm;\n    long offset;\n    char buff1[24], buff2[24], *p;\n    int i, j;\n    p = buff1;\n    i = ctm->length;\n    str = (char *)ctm->data;\n    if (ctm->type == V_ASN1_UTCTIME) {\n        if ((i < 11) || (i > 17))\n            return 0;\n        memcpy(p, str, 10);\n        p += 10;\n        str += 10;\n    } else {\n        if (i < 13)\n            return 0;\n        memcpy(p, str, 12);\n        p += 12;\n        str += 12;\n    }\n    if ((*str == 'Z') || (*str == '-') || (*str == '+')) {\n        *(p++) = '0';\n        *(p++) = '0';\n    } else {\n        *(p++) = *(str++);\n        *(p++) = *(str++);\n        if (*str == '.') {\n            str++;\n            while ((*str >= '0') && (*str <= '9'))\n                str++;\n        }\n    }\n    *(p++) = 'Z';\n    *(p++) = '\\0';\n    if (*str == 'Z')\n        offset = 0;\n    else {\n        if ((*str != '+') && (*str != '-'))\n            return 0;\n        offset = ((str[1] - '0') * 10 + (str[2] - '0')) * 60;\n        offset += (str[3] - '0') * 10 + (str[4] - '0');\n        if (*str == '-')\n            offset = -offset;\n    }\n    atm.type = ctm->type;\n    atm.flags = 0;\n    atm.length = sizeof(buff2);\n    atm.data = (unsigned char *)buff2;\n    if (X509_time_adj(&atm, offset * 60, cmp_time) == NULL)\n        return 0;\n    if (ctm->type == V_ASN1_UTCTIME) {\n        i = (buff1[0] - '0') * 10 + (buff1[1] - '0');\n        if (i < 50)\n            i += 100;           \n        j = (buff2[0] - '0') * 10 + (buff2[1] - '0');\n        if (j < 50)\n            j += 100;\n        if (i < j)\n            return -1;\n        if (i > j)\n            return 1;\n    }\n    i = strcmp(buff1, buff2);\n    if (i == 0)                 \n        return -1;\n    else\n        return i;\n}", "target": 1}
{"code": "static void send(node_t *node, node_t *child, byte *fout) {\n\tif (node->parent) {\n\t\tsend(node->parent, node, fout);\n\t}\n\tif (child) {\n\t\tif (node->right == child) {\n\t\t\tadd_bit(1, fout);\n\t\t} else {\n\t\t\tadd_bit(0, fout);\n\t\t}\n\t}\n}", "target": 1}
{"code": "static void *snd_malloc_sbus_pages(struct device *dev, size_t size,\n\t\t\t\t   dma_addr_t *dma_addr)\n{\n\tstruct sbus_dev *sdev = (struct sbus_dev *)dev;\n\tint pg;\n\tvoid *res;\n\tsnd_assert(size > 0, return NULL);\n\tsnd_assert(dma_addr != NULL, return NULL);\n\tpg = get_order(size);\n\tres = sbus_alloc_consistent(sdev, PAGE_SIZE * (1 << pg), dma_addr);\n\tif (res != NULL)\n\t\tinc_snd_pages(pg);\n\treturn res;\n}", "target": 0}
{"code": "static inline pmd_t pmd_read_atomic(pmd_t *pmdp)\n{\n\tpmdval_t ret;\n\tu32 *tmp = (u32 *)pmdp;\n\tret = (pmdval_t) (*tmp);\n\tif (ret) {\n\t\tsmp_rmb();\n\t\tret |= ((pmdval_t)*(tmp + 1)) << 32;\n\t}\n\treturn (pmd_t) { ret };\n}", "target": 0}
{"code": "CMS_ContentInfo *CMS_sign_receipt(CMS_SignerInfo *si,\n                                  X509 *signcert, EVP_PKEY *pkey,\n                                  STACK_OF(X509) *certs, unsigned int flags)\n{\n    CMS_SignerInfo *rct_si;\n    CMS_ContentInfo *cms = NULL;\n    ASN1_OCTET_STRING **pos, *os;\n    BIO *rct_cont = NULL;\n    int r = 0;\n    flags &= ~(CMS_STREAM | CMS_TEXT);\n    flags |= CMS_PARTIAL | CMS_BINARY | CMS_DETACHED;\n    if (!pkey || !signcert) {\n        CMSerr(CMS_F_CMS_SIGN_RECEIPT, CMS_R_NO_KEY_OR_CERT);\n        return NULL;\n    }\n    cms = CMS_sign(NULL, NULL, certs, NULL, flags);\n    if (!cms)\n        goto err;\n    if (!CMS_set1_eContentType(cms, OBJ_nid2obj(NID_id_smime_ct_receipt)))\n        goto err;\n    rct_si = CMS_add1_signer(cms, signcert, pkey, NULL, flags);\n    if (!rct_si) {\n        CMSerr(CMS_F_CMS_SIGN_RECEIPT, CMS_R_ADD_SIGNER_ERROR);\n        goto err;\n    }\n    os = cms_encode_Receipt(si);\n    if (!os)\n        goto err;\n    rct_cont = BIO_new_mem_buf(os->data, os->length);\n    if (!rct_cont)\n        goto err;\n    if (!cms_msgSigDigest_add1(rct_si, si))\n        goto err;\n    if (!CMS_final(cms, rct_cont, NULL, flags))\n        goto err;\n    pos = CMS_get0_content(cms);\n    *pos = os;\n    r = 1;\n err:\n    if (rct_cont)\n        BIO_free(rct_cont);\n    if (r)\n        return cms;\n    CMS_ContentInfo_free(cms);\n    return NULL;\n}", "target": 0}
{"code": "extract_auth_val(char **q)\n{\n    unsigned char *qq = *(unsigned char **)q;\n    int quoted = 0;\n    Str val = Strnew();\n    SKIP_BLANKS(qq);\n    if (*qq == '\"') {\n\tquoted = TRUE;\n\tStrcat_char(val, *qq++);\n    }\n    while (*qq != '\\0') {\n\tif (quoted && *qq == '\"') {\n\t    Strcat_char(val, *qq++);\n\t    break;\n\t}\n\tif (!quoted) {\n\t    switch (*qq) {\n\t    case '[':\n\t    case ']':\n\t    case '(':\n\t    case ')':\n\t    case '<':\n\t    case '>':\n\t    case '@':\n\t    case ';':\n\t    case ':':\n\t    case '\\\\':\n\t    case '\"':\n\t    case '/':\n\t    case '?':\n\t    case '=':\n\t    case ' ':\n\t    case '\\t':\n\t\tqq++;\n\t    case ',':\n\t\tgoto end_token;\n\t    default:\n\t\tif (*qq <= 037 || *qq == 0177) {\n\t\t    qq++;\n\t\t    goto end_token;\n\t\t}\n\t    }\n\t}\n\telse if (quoted && *qq == '\\\\')\n\t    Strcat_char(val, *qq++);\n\tStrcat_char(val, *qq++);\n    }\n  end_token:\n    *q = (char *)qq;\n    return val;\n}", "target": 0}
{"code": "void AOClient::pktRemoveEvidence(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (!checkEvidenceAccess(area))\n        return;\n    bool is_int = false;\n    int idx = argv[0].toInt(&is_int);\n    if (is_int && idx <= area->evidence().size() && idx >= 0) {\n        area->deleteEvidence(idx);\n    }\n    sendEvidenceList(area);\n}", "target": 1}
{"code": "irc_ctcp_dcc_filename_without_quotes (const char *filename)\n{\n    int length;\n    length = strlen (filename);\n    if (length > 0)\n    {\n        if ((filename[0] == '\\\"') && (filename[length - 1] == '\\\"'))\n            return weechat_strndup (filename + 1, length - 2);\n    }\n    return strdup (filename);\n}", "target": 1}
{"code": "int dccp_destroy_sock(struct sock *sk)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tstruct dccp_minisock *dmsk = dccp_msk(sk);\n\tif (sk->sk_send_head != NULL) {\n\t\tkfree_skb(sk->sk_send_head);\n\t\tsk->sk_send_head = NULL;\n\t}\n\tif (inet_csk(sk)->icsk_bind_hash != NULL)\n\t\tinet_put_port(&dccp_hashinfo, sk);\n\tkfree(dp->dccps_service_list);\n\tdp->dccps_service_list = NULL;\n\tif (dmsk->dccpms_send_ack_vector) {\n\t\tdccp_ackvec_free(dp->dccps_hc_rx_ackvec);\n\t\tdp->dccps_hc_rx_ackvec = NULL;\n\t}\n\tccid_hc_rx_delete(dp->dccps_hc_rx_ccid, sk);\n\tccid_hc_tx_delete(dp->dccps_hc_tx_ccid, sk);\n\tdp->dccps_hc_rx_ccid = dp->dccps_hc_tx_ccid = NULL;\n\tdccp_feat_clean(dmsk);\n\treturn 0;\n}", "target": 0}
{"code": "  void createDebugInfo() override {\n    llvm_unreachable(\"Accessing debug info from a lazy module\");\n  }", "target": 1}
{"code": "static int _dns_encode_HTTPS(struct dns_context *context, struct dns_rrs *rrs)\n{\n\tint ret = 0;\n\tint qtype = 0;\n\tint qclass = 0;\n\tchar domain[DNS_MAX_CNAME_LEN];\n\tchar target[DNS_MAX_CNAME_LEN] = {0};\n\tunsigned char *rr_len_ptr = NULL;\n\tunsigned char *start = NULL;\n\tunsigned char *rr_start = NULL;\n\tint ttl = 0;\n\tint priority = 0;\n\tstruct dns_https_param *param = NULL;\n\tparam = dns_get_HTTPS_svcparm_start(rrs, domain, DNS_MAX_CNAME_LEN, &ttl, &priority, target, DNS_MAX_CNAME_LEN);\n\tif (param == NULL) {\n\t\ttlog(TLOG_ERROR, \"get https param failed.\");\n\t\treturn -1;\n\t}\n\tret = _dns_encode_rr_head(context, domain, qtype, qclass, ttl, 0, &rr_len_ptr);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\trr_start = context->ptr;\n\tif (_dns_left_len(context) < 2) {\n\t\ttlog(TLOG_ERROR, \"left len is invalid.\");\n\t\treturn -1;\n\t}\n\t_dns_write_short(&context->ptr, priority);\n\tret = _dns_encode_domain(context, target);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\tstart = context->ptr;\n\tfor (; param != NULL; param = dns_get_HTTPS_svcparm_next(rrs, param)) {\n\t\tif (context->ptr - start > rrs->len || _dns_left_len(context) <= 0) {\n\t\t\treturn -1;\n\t\t}\n\t\t_dns_write_short(&context->ptr, param->key);\n\t\t_dns_write_short(&context->ptr, param->len);\n\t\tswitch (param->key) {\n\t\tcase DNS_HTTPS_T_MANDATORY:\n\t\tcase DNS_HTTPS_T_NO_DEFAULT_ALPN:\n\t\tcase DNS_HTTPS_T_ALPN:\n\t\tcase DNS_HTTPS_T_PORT:\n\t\tcase DNS_HTTPS_T_IPV4HINT:\n\t\tcase DNS_HTTPS_T_ECH:\n\t\tcase DNS_HTTPS_T_IPV6HINT: {\n\t\t\tmemcpy(context->ptr, param->value, param->len);\n\t\t\tcontext->ptr += param->len;\n\t\t} break;\n\t\tdefault:\n\t\t\tcontext->ptr -= 4;\n\t\t\tbreak;\n\t\t}\n\t}\n\t_dns_write_short(&rr_len_ptr, context->ptr - rr_start);\n\treturn 0;\n}", "target": 1}
{"code": "static int sysfs_slab_add(struct kmem_cache *s)\n{\n\tint err;\n\tconst char *name;\n\tstruct kset *kset = cache_kset(s);\n\tint unmergeable = slab_unmergeable(s);\n\tINIT_WORK(&s->kobj_remove_work, sysfs_slab_remove_workfn);\n\tif (!kset) {\n\t\tkobject_init(&s->kobj, &slab_ktype);\n\t\treturn 0;\n\t}\n\tif (!unmergeable && disable_higher_order_debug &&\n\t\t\t(slub_debug & DEBUG_METADATA_FLAGS))\n\t\tunmergeable = 1;\n\tif (unmergeable) {\n\t\tsysfs_remove_link(&slab_kset->kobj, s->name);\n\t\tname = s->name;\n\t} else {\n\t\tname = create_unique_id(s);\n\t}\n\ts->kobj.kset = kset;\n\terr = kobject_init_and_add(&s->kobj, &slab_ktype, NULL, \"%s\", name);\n\tif (err)\n\t\tgoto out;\n\terr = sysfs_create_group(&s->kobj, &slab_attr_group);\n\tif (err)\n\t\tgoto out_del_kobj;\n#ifdef CONFIG_MEMCG\n\tif (is_root_cache(s) && memcg_sysfs_enabled) {\n\t\ts->memcg_kset = kset_create_and_add(\"cgroup\", NULL, &s->kobj);\n\t\tif (!s->memcg_kset) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_del_kobj;\n\t\t}\n\t}\n#endif\n\tkobject_uevent(&s->kobj, KOBJ_ADD);\n\tif (!unmergeable) {\n\t\tsysfs_slab_alias(s, s->name);\n\t}\nout:\n\tif (!unmergeable)\n\t\tkfree(name);\n\treturn err;\nout_del_kobj:\n\tkobject_del(&s->kobj);\n\tgoto out;", "target": 0}
{"code": "int hns_ppe_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn ETH_PPE_STATIC_NUM;\n\treturn 0;\n}", "target": 1}
{"code": "void ecdsa_verify_prepare_legacy(ecdsa_verify_context_t *ctx, const ecc_int256_t *hash, const ecdsa_signature_t *signature) {\n  ecc_int256_t w, u1, tmp;\n  if (ecc_25519_gf_is_zero(&signature->s) || ecc_25519_gf_is_zero(&signature->r)) {\n    memset(&ctx->r, 0, sizeof(ctx->r));\n    return;\n  }\n  ctx->r = signature->r;\n  ecc_25519_gf_recip(&w, &signature->s);\n  ecc_25519_gf_reduce(&tmp, hash);\n  ecc_25519_gf_mult(&u1, &tmp, &w);\n  ecc_25519_gf_mult(&ctx->u2, &ctx->r, &w);\n  ecc_25519_scalarmult_base(&ctx->s1, &u1);\n}", "target": 0}
{"code": "void CheckAuthTest::TestValidToken(const std::string &auth_token,\n                                   const std::string &user_info) {\n  EXPECT_CALL(*raw_request_, FindHeader(\"x-goog-iap-jwt-assertion\", _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = \"\";\n        return false;\n      }));\n  EXPECT_CALL(*raw_request_, FindHeader(kAuthHeader, _))\n      .WillOnce(Invoke([auth_token](const std::string &, std::string *token) {\n        *token = std::string(kBearer) + auth_token;\n        return true;\n      }));\n  EXPECT_CALL(*raw_request_, SetAuthToken(auth_token)).Times(1);\n  EXPECT_CALL(*raw_env_, DoRunHTTPRequest(_))\n      .Times(2)\n      .WillOnce(Invoke([](HTTPRequest *req) {\n        EXPECT_EQ(req->url(), kIssuer1OpenIdUrl);\n        std::string body(kOpenIdContent);\n        std::map<std::string, std::string> empty;\n        req->OnComplete(Status::OK, std::move(empty), std::move(body));\n      }))\n      .WillOnce(Invoke([](HTTPRequest *req) {\n        EXPECT_EQ(req->url(), kIssuer1PubkeyUrl);\n        std::string body(kPubkey);\n        std::map<std::string, std::string> empty;\n        req->OnComplete(Status::OK, std::move(empty), std::move(body));\n      }));\n  std::cout << \"need be replaced: \" << user_info << std::endl;\n  EXPECT_CALL(*raw_request_,\n              AddHeaderToBackend(kEndpointApiUserInfo, user_info))\n      .WillOnce(Return(utils::Status::OK));\n  CheckAuth(context_, [](Status status) { ASSERT_TRUE(status.ok()); });\n}", "target": 1}
{"code": "MONGO_EXPORT void *bson_malloc( int size ) {\n    void *p;\n    p = bson_malloc_func( size );\n    bson_fatal_msg( !!p, \"malloc() failed\" );\n    return p;\n}", "target": 1}
{"code": "    float parseFloat(const std::string& s, bool& ok)\n    {\n        float ret = stringTo<float>(s, ok);\n        if (ok) return ret;\n        Rational r = stringTo<Rational>(s, ok);\n        if (ok) {\n            if (r.second == 0) {\n                ok = false;\n                return 0.0;\n            }\n            return static_cast<float>(r.first) / r.second;\n        }\n        bool b = stringTo<bool>(s, ok);\n        if (ok) return b ? 1.0f : 0.0f;\n        return ret;\n    }", "target": 0}
{"code": "static void __init clear_bss(void)\n{\n\tmemset(__bss_start, 0,\n\t       (unsigned long) __bss_stop - (unsigned long) __bss_start);\n}", "target": 1}
{"code": "CMD_FUNC(m_authenticate)\n{\n\taClient *agent_p = NULL;\n\tif (!SASL_SERVER || !MyConnect(sptr) || BadPtr(parv[1]) || !CHECKPROTO(sptr, PROTO_SASL))\n\t\treturn 0;\n\tif (sptr->local->sasl_complete)\n\t{\n\t\tsendto_one(sptr, err_str(ERR_SASLALREADY), me.name, BadPtr(sptr->name) ? \"*\" : sptr->name);\n\t\treturn 0;\n\t}\n\tif ((parv[1][0] == ':') || strchr(parv[1], ' '))\n\t{\n\t\tsendto_one(sptr, err_str(ERR_CANNOTDOCOMMAND), me.name, \"*\", \"AUTHENTICATE\", \"Invalid parameter\");\n\t\treturn 0;\n\t}\n\tif (strlen(parv[1]) > 400)\n\t{\n\t\tsendto_one(sptr, err_str(ERR_SASLTOOLONG), me.name, BadPtr(sptr->name) ? \"*\" : sptr->name);\n\t\treturn 0;\n\t}\n\tif (*sptr->local->sasl_agent)\n\t\tagent_p = find_client(sptr->local->sasl_agent, NULL);\n\tif (agent_p == NULL)\n\t{\n\t\tchar *addr = BadPtr(sptr->ip) ? \"0\" : sptr->ip;\n\t\tchar *certfp = moddata_client_get(sptr, \"certfp\");\n\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s H %s %s\",\n\t\t    me.name, SASL_SERVER, encode_puid(sptr), addr, addr);\n\t\tif (certfp)\n\t\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s S %s %s\",\n\t\t\t    me.name, SASL_SERVER, encode_puid(sptr), parv[1], certfp);\n\t\telse\n\t\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s S %s\",\n\t\t\t    me.name, SASL_SERVER, encode_puid(sptr), parv[1]);\n\t}\n\telse\n\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s C %s\",\n\t\t    me.name, AGENT_SID(agent_p), encode_puid(sptr), parv[1]);\n\tsptr->local->sasl_out++;\n\treturn 0;\n}", "target": 0}
{"code": "void hsr_del_node(struct list_head *self_node_db)\n{\n\tstruct hsr_node *node;\n\trcu_read_lock();\n\tnode = list_first_or_null_rcu(self_node_db, struct hsr_node, mac_list);\n\trcu_read_unlock();\n\tif (node) {\n\t\tlist_del_rcu(&node->mac_list);\n\t\tkfree(node);\n\t}\n}", "target": 0}
{"code": "IW_IMPL(unsigned int) iw_get_ui32le(const iw_byte *b)\n{\n\treturn b[0] | (b[1]<<8) | (b[2]<<16) | (b[3]<<24);\n}", "target": 1}
{"code": "void start_cfs_bandwidth(struct cfs_bandwidth *cfs_b)\n{\n\tu64 overrun;\n\tlockdep_assert_held(&cfs_b->lock);\n\tif (cfs_b->period_active)\n\t\treturn;\n\tcfs_b->period_active = 1;\n\toverrun = hrtimer_forward_now(&cfs_b->period_timer, cfs_b->period);\n\tcfs_b->runtime_expires += (overrun + 1) * ktime_to_ns(cfs_b->period);\n\tcfs_b->expires_seq++;\n\thrtimer_start_expires(&cfs_b->period_timer, HRTIMER_MODE_ABS_PINNED);\n}", "target": 1}
{"code": "static inline void assign_eip_near(struct x86_emulate_ctxt *ctxt, ulong dst)\n{\n\tswitch (ctxt->op_bytes) {\n\tcase 2:\n\t\tctxt->_eip = (u16)dst;\n\t\tbreak;\n\tcase 4:\n\t\tctxt->_eip = (u32)dst;\n\t\tbreak;\n\tcase 8:\n\t\tctxt->_eip = dst;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"unsupported eip assignment size\\n\");\n\t}\n}", "target": 1}
{"code": "static int nr_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tlock_sock(sk);\n\tif (sock->state != SS_UNCONNECTED) {\n\t\trelease_sock(sk);\n\t\treturn -EINVAL;\n\t}\n\tif (sk->sk_state != TCP_LISTEN) {\n\t\tmemset(&nr_sk(sk)->user_addr, 0, AX25_ADDR_LEN);\n\t\tsk->sk_max_ack_backlog = backlog;\n\t\tsk->sk_state           = TCP_LISTEN;\n\t\trelease_sock(sk);\n\t\treturn 0;\n\t}\n\trelease_sock(sk);\n\treturn -EOPNOTSUPP;\n}", "target": 0}
{"code": "void check_system_chunk(struct btrfs_trans_handle *trans, u64 type)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_space_info *info;\n\tu64 left;\n\tu64 thresh;\n\tint ret = 0;\n\tu64 num_devs;\n\tlockdep_assert_held(&fs_info->chunk_mutex);\n\tinfo = btrfs_find_space_info(fs_info, BTRFS_BLOCK_GROUP_SYSTEM);\nagain:\n\tspin_lock(&info->lock);\n\tleft = info->total_bytes - btrfs_space_info_used(info, true);\n\tspin_unlock(&info->lock);\n\tnum_devs = get_profile_num_devs(fs_info, type);\n\tthresh = btrfs_calc_metadata_size(fs_info, num_devs) +\n\t\tbtrfs_calc_insert_metadata_size(fs_info, 1);\n\tif (left < thresh && btrfs_test_opt(fs_info, ENOSPC_DEBUG)) {\n\t\tbtrfs_info(fs_info, \"left=%llu, need=%llu, flags=%llu\",\n\t\t\t   left, thresh, type);\n\t\tbtrfs_dump_space_info(fs_info, info, 0, 0);\n\t}\n\tif (left < thresh) {\n\t\tu64 flags = btrfs_system_alloc_profile(fs_info);\n\t\tu64 reserved = atomic64_read(&cur_trans->chunk_bytes_reserved);\n\t\tif (reserved > trans->chunk_bytes_reserved) {\n\t\t\tconst u64 min_needed = reserved - thresh;\n\t\t\tmutex_unlock(&fs_info->chunk_mutex);\n\t\t\twait_event(cur_trans->chunk_reserve_wait,\n\t\t\t   atomic64_read(&cur_trans->chunk_bytes_reserved) <=\n\t\t\t   min_needed);\n\t\t\tmutex_lock(&fs_info->chunk_mutex);\n\t\t\tgoto again;\n\t\t}\n\t\tret = btrfs_alloc_chunk(trans, flags);\n\t}\n\tif (!ret) {\n\t\tret = btrfs_block_rsv_add(fs_info->chunk_root,\n\t\t\t\t\t  &fs_info->chunk_block_rsv,\n\t\t\t\t\t  thresh, BTRFS_RESERVE_NO_FLUSH);\n\t\tif (!ret) {\n\t\t\tatomic64_add(thresh, &cur_trans->chunk_bytes_reserved);\n\t\t\ttrans->chunk_bytes_reserved += thresh;\n\t\t}\n\t}\n}", "target": 1}
{"code": "Network::FilterStatus Context::onUpstreamData(int data_length, bool end_of_stream) {\n  if (!wasm_->onUpstreamData_) {\n    return Network::FilterStatus::Continue;\n  }\n  auto result = wasm_->onUpstreamData_(this, id_, static_cast<uint32_t>(data_length),\n                                       static_cast<uint32_t>(end_of_stream));\n  return result.u64_ == 0 ? Network::FilterStatus::Continue : Network::FilterStatus::StopIteration;\n}", "target": 1}
{"code": "static int faultin_page(struct task_struct *tsk, struct vm_area_struct *vma,\n\t\tunsigned long address, unsigned int *flags, int *nonblocking)\n{\n\tunsigned int fault_flags = 0;\n\tint ret;\n\tif ((*flags & (FOLL_POPULATE | FOLL_MLOCK)) == FOLL_MLOCK)\n\t\treturn -ENOENT;\n\tif ((*flags & FOLL_POPULATE) &&\n\t\t\t(stack_guard_page_start(vma, address) ||\n\t\t\t stack_guard_page_end(vma, address + PAGE_SIZE)))\n\t\treturn -ENOENT;\n\tif (*flags & FOLL_WRITE)\n\t\tfault_flags |= FAULT_FLAG_WRITE;\n\tif (*flags & FOLL_REMOTE)\n\t\tfault_flags |= FAULT_FLAG_REMOTE;\n\tif (nonblocking)\n\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY;\n\tif (*flags & FOLL_NOWAIT)\n\t\tfault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT;\n\tif (*flags & FOLL_TRIED) {\n\t\tVM_WARN_ON_ONCE(fault_flags & FAULT_FLAG_ALLOW_RETRY);\n\t\tfault_flags |= FAULT_FLAG_TRIED;\n\t}\n\tret = handle_mm_fault(vma, address, fault_flags);\n\tif (ret & VM_FAULT_ERROR) {\n\t\tif (ret & VM_FAULT_OOM)\n\t\t\treturn -ENOMEM;\n\t\tif (ret & (VM_FAULT_HWPOISON | VM_FAULT_HWPOISON_LARGE))\n\t\t\treturn *flags & FOLL_HWPOISON ? -EHWPOISON : -EFAULT;\n\t\tif (ret & (VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV))\n\t\t\treturn -EFAULT;\n\t\tBUG();\n\t}\n\tif (tsk) {\n\t\tif (ret & VM_FAULT_MAJOR)\n\t\t\ttsk->maj_flt++;\n\t\telse\n\t\t\ttsk->min_flt++;\n\t}\n\tif (ret & VM_FAULT_RETRY) {\n\t\tif (nonblocking)\n\t\t\t*nonblocking = 0;\n\t\treturn -EBUSY;\n\t}\n\tif ((ret & VM_FAULT_WRITE) && !(vma->vm_flags & VM_WRITE))\n\t\t*flags &= ~FOLL_WRITE;\n\treturn 0;\n}", "target": 1}
{"code": "_client_protocol_timeout (GsmXSMPClient *client)\n{\n        g_debug (\"GsmXSMPClient: client_protocol_timeout for client '%s' in ICE status %d\",\n                 client->priv->description,\n                 IceConnectionStatus (client->priv->ice_connection));\n        gsm_client_set_status (GSM_CLIENT (client), GSM_CLIENT_FAILED);\n        gsm_client_disconnected (GSM_CLIENT (client));\n        return FALSE;\n}", "target": 1}
{"code": "const char* sldns_get_errorstr_parse(int e)\n{\n\tsldns_lookup_table *lt;\n\tlt = sldns_lookup_by_id(sldns_wireparse_errors, LDNS_WIREPARSE_ERROR(e));\n\treturn lt?lt->name:\"unknown error\";\n}", "target": 0}
{"code": "ext4_xattr_create_cache(char *name)\n{\n\treturn mb_cache_create(name, HASH_BUCKET_BITS);\n}", "target": 1}
{"code": "static bool read_phdr(ELFOBJ *bin, bool linux_kernel_hack) {\n\tbool phdr_found = false;\n\tint i;\n#if R_BIN_ELF64\n\tconst bool is_elf64 = true;\n#else\n\tconst bool is_elf64 = false;\n#endif\n\tut64 phnum = Elf_(r_bin_elf_get_phnum) (bin);\n\tfor (i = 0; i < phnum; i++) {\n\t\tut8 phdr[sizeof (Elf_(Phdr))] = {0};\n\t\tint j = 0;\n\t\tconst size_t rsize = bin->ehdr.e_phoff + i * sizeof (Elf_(Phdr));\n\t\tint len = r_buf_read_at (bin->b, rsize, phdr, sizeof (Elf_(Phdr)));\n\t\tif (len < 1) {\n\t\t\tR_LOG_ERROR (\"read (phdr)\");\n\t\t\tR_FREE (bin->phdr);\n\t\t\treturn false;\n\t\t}\n\t\tbin->phdr[i].p_type = READ32 (phdr, j);\n\t\tif (bin->phdr[i].p_type == PT_PHDR) {\n\t\t\tphdr_found = true;\n\t\t}\n\t\tif (is_elf64) {\n\t\t\tbin->phdr[i].p_flags = READ32 (phdr, j);\n\t\t}\n\t\tbin->phdr[i].p_offset = R_BIN_ELF_READWORD (phdr, j);\n\t\tbin->phdr[i].p_vaddr = R_BIN_ELF_READWORD (phdr, j);\n\t\tbin->phdr[i].p_paddr = R_BIN_ELF_READWORD (phdr, j);\n\t\tbin->phdr[i].p_filesz = R_BIN_ELF_READWORD (phdr, j);\n\t\tbin->phdr[i].p_memsz = R_BIN_ELF_READWORD (phdr, j);\n\t\tif (!is_elf64) {\n\t\t\tbin->phdr[i].p_flags = READ32 (phdr, j);\n\t\t}\n\t\tbin->phdr[i].p_align = R_BIN_ELF_READWORD (phdr, j);\n\t}\n\tif (linux_kernel_hack && phdr_found) {\n\t\tut64 load_addr = Elf_(r_bin_elf_get_baddr) (bin);\n\t\tbin->ehdr.e_phoff = Elf_(r_bin_elf_v2p) (bin, load_addr + bin->ehdr.e_phoff);\n\t\treturn read_phdr (bin, false);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "crm_send_tls(gnutls_session * session, const char *buf, size_t len)\n{\n    const char *unsent = buf;\n    int rc = 0;\n    int total_send;\n    if (buf == NULL) {\n        return -1;\n    }\n    total_send = len;\n    crm_trace(\"Message size: %d\", len);\n    while (TRUE) {\n        rc = gnutls_record_send(*session, unsent, len);\n        if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN) {\n            crm_debug(\"Retry\");\n        } else if (rc < 0) {\n            crm_err(\"Connection terminated rc = %d\", rc);\n            break;\n        } else if (rc < len) {\n            crm_debug(\"Only sent %d of %d bytes\", rc, len);\n            len -= rc;\n            unsent += rc;\n        } else {\n            crm_debug(\"Sent %d bytes\", rc);\n            break;\n        }\n    }\n    return rc < 0 ? rc : total_send;\n}", "target": 0}
{"code": "static int wdm_post_reset(struct usb_interface *intf)\n{\n\tstruct wdm_device *desc = wdm_find_device(intf);\n\tint rv;\n\tclear_bit(WDM_OVERFLOW, &desc->flags);\n\tclear_bit(WDM_RESETTING, &desc->flags);\n\trv = recover_from_urb_loss(desc);\n\tmutex_unlock(&desc->wlock);\n\tmutex_unlock(&desc->rlock);\n\treturn 0;\n}", "target": 0}
{"code": "hash_new_from_values(mrb_state *mrb, mrb_int argc, mrb_value *regs)\n{\n  mrb_value hash = mrb_hash_new_capa(mrb, argc);\n  while (argc--) {\n    mrb_hash_set(mrb, hash, regs[0], regs[1]);\n    regs += 2;\n  }\n  return hash;\n}", "target": 1}
{"code": "static void put_crypt_info(struct fscrypt_info *ci)\n{\n\tif (!ci)\n\t\treturn;\n\tkey_put(ci->ci_keyring_key);\n\tcrypto_free_skcipher(ci->ci_ctfm);\n\tkmem_cache_free(fscrypt_info_cachep, ci);\n}", "target": 1}
{"code": "  void MakeDataset(OpKernelContext* ctx, DatasetBase** output) override {\n    const Tensor* indices;\n    OP_REQUIRES_OK(ctx, ctx->input(\"indices\", &indices));\n    const Tensor* values;\n    OP_REQUIRES_OK(ctx, ctx->input(\"values\", &values));\n    const Tensor* dense_shape;\n    OP_REQUIRES_OK(ctx, ctx->input(\"dense_shape\", &dense_shape));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(indices->shape()),\n                errors::InvalidArgument(\n                    \"Input indices should be a matrix but received shape \",\n                    indices->shape().DebugString()));\n    const auto num_indices = indices->NumElements();\n    const auto num_values = values->NumElements();\n    if (num_indices == 0 || num_values == 0) {\n      OP_REQUIRES(ctx, num_indices == num_values,\n                  errors::InvalidArgument(\n                      \"If indices or values are empty, the other one must also \"\n                      \"be. Got indices of shape \",\n                      indices->shape().DebugString(), \" and values of shape \",\n                      values->shape().DebugString()));\n    }\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(values->shape()),\n                errors::InvalidArgument(\n                    \"Input values should be a vector but received shape \",\n                    indices->shape().DebugString()));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(dense_shape->shape()),\n                errors::InvalidArgument(\n                    \"Input shape should be a vector but received shape \",\n                    dense_shape->shape().DebugString()));\n    int64_t previous_batch_index = -1;\n    for (int64_t i = 0; i < indices->dim_size(0); ++i) {\n      int64_t next_batch_index = indices->matrix<int64_t>()(i, 0);\n      OP_REQUIRES(\n          ctx, next_batch_index >= previous_batch_index,\n          errors::Unimplemented(\"The SparseTensor must be ordered in the batch \"\n                                \"dimension; handling arbitrarily ordered input \"\n                                \"is not currently supported.\"));\n      previous_batch_index = next_batch_index;\n    }\n    gtl::InlinedVector<int64_t, 8> std_order(dense_shape->NumElements(), 0);\n    sparse::SparseTensor tensor;\n    OP_REQUIRES_OK(\n        ctx, sparse::SparseTensor::Create(\n                 *indices, *values, TensorShape(dense_shape->vec<int64_t>()),\n                 std_order, &tensor));\n    *output = new Dataset<T>(ctx, std::move(tensor));\n  }", "target": 1}
{"code": "static int fsmOpenat(int dirfd, const char *path, int flags)\n{\n    struct stat lsb, sb;\n    int sflags = flags | O_NOFOLLOW;\n    int fd = openat(dirfd, path, sflags);\n    if (fd < 0 && errno == ELOOP && flags != sflags) {\n\tint ffd = openat(dirfd, path, flags);\n\tif (ffd >= 0 && fstatat(dirfd, path, &lsb, AT_SYMLINK_NOFOLLOW) == 0) {\n\t    if (fstat(ffd, &sb) == 0) {\n\t\tif (lsb.st_uid == 0 || lsb.st_uid == sb.st_uid) {\n\t\t    fd = ffd;\n\t\t} else {\n\t\t    close(ffd);\n\t\t}\n\t    }\n\t}\n    }\n    return fd;\n}", "target": 0}
{"code": "static bool map_info2_flags_to_sbuf(const SMB_STRUCT_STAT *psbuf,\n\t\t\t\tconst uint32_t smb_fflags,\n\t\t\t\tconst uint32_t smb_fmask,\n\t\t\t\tint *stat_fflags)\n{\n\tuint32_t max_fmask = 0;\n\tint i;\n\t*stat_fflags = psbuf->st_ex_flags;\n\tfor (i = 0; i < ARRAY_SIZE(info2_flags_map); ++i) {\n\t    max_fmask |= info2_flags_map[i].smb_fflag;\n\t    if (smb_fmask & info2_flags_map[i].smb_fflag) {\n\t\t    if (smb_fflags & info2_flags_map[i].smb_fflag) {\n\t\t\t    *stat_fflags |= info2_flags_map[i].stat_fflag;\n\t\t    } else {\n\t\t\t    *stat_fflags &= ~info2_flags_map[i].stat_fflag;\n\t\t    }\n\t    }\n\t}\n\tif ((smb_fmask & max_fmask) != smb_fmask) {\n\t\treturn False;\n\t}\n\treturn True;\n}", "target": 0}
{"code": "int main(int argc, char *argv[] ) {\n\tint i, fails_count=0;\n\tCU_pSuite cryptoUtilsTestSuite, parserTestSuite;\n\tCU_pSuite *suites[] = {\n\t\t&cryptoUtilsTestSuite,\n\t\t&parserTestSuite,\n\t\tNULL\n\t};\n\tif (argc>1) {\n\t\tif (argv[1][0] == '-') {\n\t\t\tif (strcmp(argv[1], \"-verbose\") == 0) {\n\t\t\t\tverbose = 1;\n\t\t\t} else {\n\t\t\t\tprintf (\"Usage:\\n %s [-verbose] to enable extensive logging\\n\", argv[0]);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else {\n\t\t\tprintf (\"Usage:\\n %s [-verbose] to enable extensive logging\\n\", argv[0]);\n\t\t\treturn 1;\n\t\t}\n\t}\n#ifdef HAVE_LIBXML2\n\txmlInitParser();\n#endif\n\tif (CUE_SUCCESS != CU_initialize_registry()) {\n\t\treturn CU_get_error();\n\t}\n\tcryptoUtilsTestSuite = CU_add_suite(\"Bzrtp Crypto Utils\", NULL, NULL);\n\tCU_add_test(cryptoUtilsTestSuite, \"zrtpKDF\", test_zrtpKDF);\n\tCU_add_test(cryptoUtilsTestSuite, \"CRC32\", test_CRC32);\n\tCU_add_test(cryptoUtilsTestSuite, \"algo agreement\", test_algoAgreement);\n\tCU_add_test(cryptoUtilsTestSuite, \"context algo setter and getter\", test_algoSetterGetter);\n\tCU_add_test(cryptoUtilsTestSuite, \"adding mandatory crypto algorithms if needed\", test_addMandatoryCryptoTypesIfNeeded);\n\tparserTestSuite = CU_add_suite(\"Bzrtp ZRTP Packet Parser\", NULL, NULL);\n\tCU_add_test(parserTestSuite, \"Parse\", test_parser);\n\tCU_add_test(parserTestSuite, \"Parse hvi check fail\", test_parser_hvi);\n\tCU_add_test(parserTestSuite, \"Parse Exchange\", test_parserComplete);\n\tCU_add_test(parserTestSuite, \"State machine\", test_stateMachine);\n\tfor(i=0; suites[i]; i++){\n\t\tCU_basic_run_suite(*suites[i]);\n\t\tfails_count += CU_get_number_of_tests_failed();\n\t}\n\tCU_cleanup_registry();\n#ifdef HAVE_LIBXML2\n\txmlCleanupParser();\n#endif\n\treturn (fails_count == 0 ? 0 : 1);\n}", "target": 0}
{"code": "blkxor(void * dest, void * src, size_t len)\n{\n  __m128i * D = (__m128i *) dest;\n  __m128i * S = (__m128i *) src;\n  size_t L = len / 16;\n  size_t i;\n  for (i = 0; i < L; i++)\n    D[i] = _mm_xor_si128(D[i], S[i]);\n}", "target": 1}
{"code": "defbackend_bind( Slapi_PBlock *pb )\n{\n    int\t\t\trc;\n    ber_tag_t\t\tmethod;\n    struct berval\t*cred;\n    LDAPDebug( LDAP_DEBUG_TRACE, \"defbackend_bind\\n\", 0, 0, 0 );\n    slapi_pblock_get( pb, SLAPI_BIND_METHOD, &method );\n    slapi_pblock_get( pb, SLAPI_BIND_CREDENTIALS, &cred );\n    if ( method == LDAP_AUTH_SIMPLE && cred->bv_len == 0 ) {\n\tslapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsAnonymousBinds);\n\trc = SLAPI_BIND_ANONYMOUS;\n    } else {\n\tsend_nobackend_ldap_result( pb );\n\trc = SLAPI_BIND_FAIL;\n    }\n    return( rc );\n}", "target": 1}
{"code": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 0}
{"code": "json_t *json_object(void)\n{\n    json_object_t *object = jsonp_malloc(sizeof(json_object_t));\n    if(!object)\n        return NULL;\n    if (!hashtable_seed) {\n        json_object_seed(0);\n    }\n    json_init(&object->json, JSON_OBJECT);\n    if(hashtable_init(&object->hashtable))\n    {\n        jsonp_free(object);\n        return NULL;\n    }\n    object->serial = 0;\n    object->visited = 0;\n    return &object->json;\n}", "target": 0}
{"code": "static void handle_put_accept(struct http_conn *conn,\n\t\t\t      const struct http_msg *msg,\n\t\t\t      struct mbuf *mb, size_t clen)\n{\n\tstruct ident_entry *ie = NULL;\n\tstruct pl pl;\n\tchar *key = NULL;\n\tint err;\n\terr = re_regex(msg->prm.p, msg->prm.l, \"?pairid=[0-9]+\", &pl);\n\tif (err) {\n\t\twarning(\"invalid input\\n\");\n\t\tgoto out;\n\t}\n\tpl_strdup(&key, &pl);\n\tie = dict_lookup(verifyd.idents, key);\n\tif (!ie) {\n\t\tinfo(\"accept: pairing-id %s not found\\n\", key);\n\t\thttp_ereply(conn, 404, \"Not found\");\n\t\tgoto out;\n\t}\n\tdebug(\"accept: saving content(%zu): %b\\n\",\n\t\t  clen, mbuf_buf(mb), mbuf_get_left(mb));\n\tmbuf_strdup(mb, &ie->content.accept, clen);\n\thttp_reply(conn, 200, \"OK\", NULL);\n\thttp_conn_close(conn);\n out:\n\tmem_deref(key);\n}", "target": 0}
{"code": "TEST(GifTest, Gif) {\n  Env* env = Env::Default();\n  const string testdata_path = kTestData;\n  std::vector<DecodeGifTestCase> testcases(\n      {\n       {testdata_path + \"lena.gif\", 1, 51, 26, 3},\n       {testdata_path + \"optimized.gif\", 12, 20, 40, 3},\n       {testdata_path + \"red_black.gif\", 1, 16, 16, 3},\n       {testdata_path + \"scan.gif\", 12, 20, 40, 3},\n       {testdata_path + \"squares.gif\", 2, 16, 16, 3}});\n  for (const auto& tc : testcases) {\n    TestDecodeGif(env, tc);\n  }\n}", "target": 1}
{"code": "static void HTPStateTransactionFree(void *state, uint64_t id)\n{\n    SCEnter();\n    HtpState *s = (HtpState *)state;\n    SCLogDebug(\"state %p, id %\"PRIu64, s, id);\n    htp_tx_t *tx = HTPStateGetTx(s, id);\n    if (tx != NULL) {\n        HtpTxUserData *htud = (HtpTxUserData *) htp_tx_get_user_data(tx);\n        HtpTxUserDataFree(s, htud);\n        htp_tx_set_user_data(tx, NULL);\n        if (unlikely(!(\n            tx->request_progress == HTP_REQUEST_COMPLETE &&\n            tx->response_progress == HTP_RESPONSE_COMPLETE)))\n        {\n            tx->request_progress = HTP_REQUEST_COMPLETE;\n            tx->response_progress = HTP_RESPONSE_COMPLETE;\n        }\n        htp_tx_destroy(tx);\n    }\n    s->tx_freed += htp_connp_tx_freed(s->connp);\n}", "target": 0}
{"code": "static void sas_destruct_devices(struct work_struct *work)\n{\n\tstruct domain_device *dev, *n;\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev->port;\n\tclear_bit(DISCE_DESTRUCT, &port->disc.pending);\n\tlist_for_each_entry_safe(dev, n, &port->destroy_list, disco_list_node) {\n\t\tlist_del_init(&dev->disco_list_node);\n\t\tsas_remove_children(&dev->rphy->dev);\n\t\tsas_rphy_delete(dev->rphy);\n\t\tsas_unregister_common_dev(port, dev);\n\t}\n}", "target": 1}
{"code": "static int fscrypt_d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct dentry *dir;\n\tstruct fscrypt_info *ci;\n\tint dir_has_key, cached_with_key;\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\tdir = dget_parent(dentry);\n\tif (!d_inode(dir)->i_sb->s_cop->is_encrypted(d_inode(dir))) {\n\t\tdput(dir);\n\t\treturn 0;\n\t}\n\tci = d_inode(dir)->i_crypt_info;\n\tif (ci && ci->ci_keyring_key &&\n\t    (ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t\t\t  (1 << KEY_FLAG_REVOKED) |\n\t\t\t\t\t  (1 << KEY_FLAG_DEAD))))\n\t\tci = NULL;\n\tspin_lock(&dentry->d_lock);\n\tcached_with_key = dentry->d_flags & DCACHE_ENCRYPTED_WITH_KEY;\n\tspin_unlock(&dentry->d_lock);\n\tdir_has_key = (ci != NULL);\n\tdput(dir);\n\tif ((!cached_with_key && d_is_negative(dentry)) ||\n\t\t\t(!cached_with_key && dir_has_key) ||\n\t\t\t(cached_with_key && !dir_has_key))\n\t\treturn 0;\n\treturn 1;\n}", "target": 1}
{"code": "bool MemoryManager::validate_user_write(const Process& process, VirtualAddress vaddr) const\n{\n    auto* region = region_from_vaddr(process, vaddr);\n    return region && region->is_writable();\n}", "target": 1}
{"code": "  QUInt8() {}", "target": 1}
{"code": "script_autoload(\n    char_u\t*name,\n    int\t\treload)\t    \n{\n    char_u\t*p;\n    char_u\t*scriptname, *tofree;\n    int\t\tret = FALSE;\n    int\t\ti;\n    int\t\tret_sid;\n    p = vim_strchr(name, AUTOLOAD_CHAR);\n    if (p == NULL || p == name)\n\treturn FALSE;\n    tofree = scriptname = autoload_name(name);\n    if (scriptname == NULL)\n\treturn FALSE;\n    for (i = 0; i < ga_loaded.ga_len; ++i)\n\tif (STRCMP(((char_u **)ga_loaded.ga_data)[i] + 9, scriptname + 9) == 0)\n\t    break;\n    if (!reload && i < ga_loaded.ga_len)\n\tret = FALSE;\t    \n    else\n    {\n\tif (i == ga_loaded.ga_len && ga_grow(&ga_loaded, 1) == OK)\n\t{\n\t    ((char_u **)ga_loaded.ga_data)[ga_loaded.ga_len++] = scriptname;\n\t    tofree = NULL;\n\t}\n\tif (source_in_path(p_rtp, scriptname, DIP_START, &ret_sid) == OK)\n\t    ret = TRUE;\n    }\n    vim_free(tofree);\n    return ret;\n}", "target": 0}
{"code": "static int sock_close(struct inode *inode, struct file *filp)\n{\n\tsock_release(SOCKET_I(inode));\n\treturn 0;\n}", "target": 1}
{"code": "nfp_abm_u32_knode_replace(struct nfp_abm_link *alink,\n\t\t\t  struct tc_cls_u32_knode *knode,\n\t\t\t  __be16 proto, struct netlink_ext_ack *extack)\n{\n\tstruct nfp_abm_u32_match *match = NULL, *iter;\n\tunsigned int tos_off;\n\tu8 mask, val;\n\tint err;\n\tif (!nfp_abm_u32_check_knode(alink->abm, knode, proto, extack))\n\t\tgoto err_delete;\n\ttos_off = proto == htons(ETH_P_IP) ? 16 : 20;\n\tval = be32_to_cpu(knode->sel->keys[0].val) >> tos_off & 0xff;\n\tmask = be32_to_cpu(knode->sel->keys[0].mask) >> tos_off & 0xff;\n\tlist_for_each_entry(iter, &alink->dscp_map, list) {\n\t\tu32 cmask;\n\t\tif (iter->handle == knode->handle) {\n\t\t\tmatch = iter;\n\t\t\tcontinue;\n\t\t}\n\t\tcmask = iter->mask & mask;\n\t\tif ((iter->val & cmask) == (val & cmask) &&\n\t\t    iter->band != knode->res->classid) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"conflict with already offloaded filter\");\n\t\t\tgoto err_delete;\n\t\t}\n\t}\n\tif (!match) {\n\t\tmatch = kzalloc(sizeof(*match), GFP_KERNEL);\n\t\tif (!match)\n\t\t\treturn -ENOMEM;\n\t\tlist_add(&match->list, &alink->dscp_map);\n\t}\n\tmatch->handle = knode->handle;\n\tmatch->band = knode->res->classid;\n\tmatch->mask = mask;\n\tmatch->val = val;\n\terr = nfp_abm_update_band_map(alink);\n\tif (err)\n\t\tgoto err_delete;\n\treturn 0;\nerr_delete:\n\tnfp_abm_u32_knode_delete(alink, knode);\n\treturn -EOPNOTSUPP;\n}", "target": 1}
{"code": "static struct phy *serdes_simple_xlate(struct device *dev,\n\t\t\t\t       struct of_phandle_args *args)\n{\n\tstruct serdes_ctrl *ctrl = dev_get_drvdata(dev);\n\tunsigned int port, idx, i;\n\tif (args->args_count != 2)\n\t\treturn ERR_PTR(-EINVAL);\n\tport = args->args[0];\n\tidx = args->args[1];\n\tfor (i = 0; i <= SERDES_MAX; i++) {\n\t\tstruct serdes_macro *macro = phy_get_drvdata(ctrl->phys[i]);\n\t\tif (idx != macro->idx)\n\t\t\tcontinue;\n\t\tif (idx != SERDES6G(0) && macro->port >= 0)\n\t\t\treturn ERR_PTR(-EBUSY);\n\t\tmacro->port = port;\n\t\treturn ctrl->phys[i];\n\t}\n\treturn ERR_PTR(-ENODEV);\n}", "target": 1}
{"code": "static void sco_sock_cleanup_listen(struct sock *parent)\n{\n\tstruct sock *sk;\n\tBT_DBG(\"parent %p\", parent);\n\twhile ((sk = bt_accept_dequeue(parent, NULL))) {\n\t\tsco_sock_close(sk);\n\t\tsco_sock_kill(sk);\n\t}\n\tparent->sk_state  = BT_CLOSED;\n\tsock_set_flag(parent, SOCK_ZAPPED);\n}", "target": 0}
{"code": "static void _sched_arq_timeout(gnrc_sixlowpan_frag_fb_t *fbuf, uint32_t offset)\n{\n    if (IS_ACTIVE(CONFIG_GNRC_SIXLOWPAN_SFR_MOCK_ARQ_TIMER)) {\n        return;\n    }\n    if (fbuf->sfr.arq_timeout_event.msg.content.ptr != NULL) {\n        DEBUG(\"6lo sfr: ARQ timeout for datagram %u already scheduled\\n\",\n              (uint8_t)fbuf->tag);\n        return;\n    }\n    DEBUG(\"6lo sfr: arming ACK timeout in %lums for datagram %u\\n\",\n          (long unsigned)offset, fbuf->tag);\n    fbuf->sfr.arq_timeout_event.event.offset = offset;\n    fbuf->sfr.arq_timeout_event.msg.content.ptr = fbuf;\n    fbuf->sfr.arq_timeout_event.msg.type = GNRC_SIXLOWPAN_FRAG_SFR_ARQ_TIMEOUT_MSG;\n    evtimer_add_msg(&_arq_timer, &fbuf->sfr.arq_timeout_event,\n                    _getpid());\n}", "target": 1}
{"code": "rfbSendServerCutText(rfbScreenInfoPtr rfbScreen,char *str, int len)\n{\n    rfbClientPtr cl;\n    rfbServerCutTextMsg sct;\n    rfbClientIteratorPtr iterator;\n    memset((char *)&sct, 0, sizeof(sct));\n    iterator = rfbGetClientIterator(rfbScreen);\n    while ((cl = rfbClientIteratorNext(iterator)) != NULL) {\n        sct.type = rfbServerCutText;\n        sct.length = Swap32IfLE(len);\n        LOCK(cl->sendMutex);\n        if (rfbWriteExact(cl, (char *)&sct,\n                       sz_rfbServerCutTextMsg) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n            UNLOCK(cl->sendMutex);\n            continue;\n        }\n        if (rfbWriteExact(cl, str, len) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n        }\n        UNLOCK(cl->sendMutex);\n        rfbStatRecordMessageSent(cl, rfbServerCutText, sz_rfbServerCutTextMsg+len, sz_rfbServerCutTextMsg+len);\n    }\n    rfbReleaseClientIterator(iterator);\n}", "target": 0}
{"code": "bool AuthUnknownAuthorizeHandler::verify_authorizer(CephContext *cct, KeyStore *keys,\n\t\t\t\t\t\t bufferlist& authorizer_data, bufferlist& authorizer_reply,\n\t\t\t\t\t\t EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info, CryptoKey& session_key,\nuint64_t *auid)\n{\n  return true;\n}", "target": 1}
{"code": "void sas_deform_port(struct asd_sas_phy *phy, int gone)\n{\n\tstruct sas_ha_struct *sas_ha = phy->ha;\n\tstruct asd_sas_port *port = phy->port;\n\tstruct sas_internal *si =\n\t\tto_sas_internal(sas_ha->core.shost->transportt);\n\tstruct domain_device *dev;\n\tunsigned long flags;\n\tif (!port)\n\t\treturn;\t\t  \n\tdev = port->port_dev;\n\tif (dev)\n\t\tdev->pathways--;\n\tif (port->num_phys == 1) {\n\t\tsas_unregister_domain_devices(port, gone);\n\t\tsas_destruct_devices(port);\n\t\tsas_port_delete(port->port);\n\t\tport->port = NULL;\n\t} else {\n\t\tsas_port_delete_phy(port->port, phy->phy);\n\t\tsas_device_set_phy(dev, port->port);\n\t}\n\tif (si->dft->lldd_port_deformed)\n\t\tsi->dft->lldd_port_deformed(phy);\n\tspin_lock_irqsave(&sas_ha->phy_port_lock, flags);\n\tspin_lock(&port->phy_list_lock);\n\tlist_del_init(&phy->port_phy_el);\n\tsas_phy_set_target(phy, NULL);\n\tphy->port = NULL;\n\tport->num_phys--;\n\tport->phy_mask &= ~(1U << phy->id);\n\tif (port->num_phys == 0) {\n\t\tINIT_LIST_HEAD(&port->phy_list);\n\t\tmemset(port->sas_addr, 0, SAS_ADDR_SIZE);\n\t\tmemset(port->attached_sas_addr, 0, SAS_ADDR_SIZE);\n\t\tport->class = 0;\n\t\tport->iproto = 0;\n\t\tport->tproto = 0;\n\t\tport->oob_mode = 0;\n\t\tport->phy_mask = 0;\n\t}\n\tspin_unlock(&port->phy_list_lock);\n\tspin_unlock_irqrestore(&sas_ha->phy_port_lock, flags);\n\treturn;\n}", "target": 0}
{"code": "urlCheckRequest(const HttpRequest * r)\n{\n    if (r->method == Http::METHOD_CONNECT)\n        return true;\n    if (r->method == Http::METHOD_OPTIONS || r->method == Http::METHOD_TRACE)\n        return (r->header.getInt64(Http::HdrType::MAX_FORWARDS) == 0 || r->url.path() != AnyP::Uri::Asterisk());\n    if (r->method == Http::METHOD_PURGE)\n        return true;\n    switch (r->url.getScheme()) {\n    case AnyP::PROTO_URN:\n    case AnyP::PROTO_HTTP:\n    case AnyP::PROTO_CACHE_OBJECT:\n        return true;\n    case AnyP::PROTO_FTP:\n        if (r->method == Http::METHOD_PUT ||\n                r->method == Http::METHOD_GET ||\n                r->method == Http::METHOD_HEAD )\n            return true;\n        return false;\n    case AnyP::PROTO_GOPHER:\n    case AnyP::PROTO_WAIS:\n    case AnyP::PROTO_WHOIS:\n        if (r->method == Http::METHOD_GET ||\n                r->method == Http::METHOD_HEAD)\n            return true;\n        return false;\n    case AnyP::PROTO_HTTPS:\n#if USE_OPENSSL || USE_GNUTLS\n        return true;\n#else\n        return false;\n#endif\n    default:\n        return false;\n    }\n    return false;\n}", "target": 1}
{"code": "static void dns_callback(void *arg, const struct sockaddr *sa, int salen)\n{\n\tstruct PgSocket *server = arg;\n\tstruct PgDatabase *db = server->pool->db;\n\tstruct sockaddr_in sa_in;\n\tstruct sockaddr_in6 sa_in6;\n\tserver->dns_token = NULL;\n\tif (!sa) {\n\t\tdisconnect_server(server, true, \"server dns lookup failed\");\n\t\treturn;\n\t} else if (sa->sa_family == AF_INET) {\n\t\tchar buf[64];\n\t\tmemcpy(&sa_in, sa, sizeof(sa_in));\n\t\tsa_in.sin_port = htons(db->port);\n\t\tsa = (struct sockaddr *)&sa_in;\n\t\tsalen = sizeof(sa_in);\n\t\tslog_debug(server, \"dns_callback: inet4: %s\",\n\t\t\t   sa2str(sa, buf, sizeof(buf)));\n\t} else if (sa->sa_family == AF_INET6) {\n\t\tchar buf[64];\n\t\tmemcpy(&sa_in6, sa, sizeof(sa_in6));\n\t\tsa_in6.sin6_port = htons(db->port);\n\t\tsa = (struct sockaddr *)&sa_in6;\n\t\tsalen = sizeof(sa_in6);\n\t\tslog_debug(server, \"dns_callback: inet6: %s\",\n\t\t\t   sa2str(sa, buf, sizeof(buf)));\n\t} else {\n\t\tdisconnect_server(server, true, \"unknown address family: %d\", sa->sa_family);\n\t\treturn;\n\t}\n\tconnect_server(server, sa, salen);\n}", "target": 0}
{"code": "static int jpc_qcd_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_qcd_t *qcd = &ms->parms.qcd;\n\tint i;\n\tfprintf(out, \"qntsty = %d; numguard = %d; numstepsizes = %d\\n\",\n\t  (int) qcd->compparms.qntsty, qcd->compparms.numguard, qcd->compparms.numstepsizes);\n\tfor (i = 0; i < qcd->compparms.numstepsizes; ++i) {\n\t\tfprintf(out, \"expn[%d] = 0x%04x; mant[%d] = 0x%04x;\\n\",\n\t\t  i, (unsigned) JPC_QCX_GETEXPN(qcd->compparms.stepsizes[i]),\n\t\t  i, (unsigned) JPC_QCX_GETMANT(qcd->compparms.stepsizes[i]));\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "sc_pkcs15emu_add_cert(sc_pkcs15_card_t *p15card,\n\t\tint type, int authority,\n\t\tconst sc_path_t *path,\n\t\tconst sc_pkcs15_id_t *id,\n                const char *label, int obj_flags)\n{\n\tsc_pkcs15_cert_info_t *info;\n\tinfo = calloc(1, sizeof(*info));\n\tif (!info)\n\t{\n\t\tLOG_FUNC_RETURN(p15card->card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\tinfo->id\t\t= *id;\n\tinfo->authority\t\t= authority;\n\tif (path)\n\t\tinfo->path = *path;\n\treturn sc_pkcs15emu_add_object(p15card, type, label, info, NULL, obj_flags);\n}", "target": 0}
{"code": "iasecc_chv_verify(struct sc_card *card, struct sc_pin_cmd_data *pin_cmd, unsigned char *scbs,\n\t\t  int *tries_left)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tunsigned char scb = scbs[IASECC_ACLS_CHV_VERIFY];\n\tint rv;\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"Verify CHV PIN(ref:%i,len:%i,scb:%X)\", pin_cmd->pin_reference, pin_cmd->pin1.len,\n\t       scb);\n\tif (scb & IASECC_SCB_METHOD_SM) {\n\t\trv = iasecc_sm_pin_verify(card, scb & IASECC_SCB_METHOD_MASK_REF, pin_cmd, tries_left);\n\t\tLOG_FUNC_RETURN(ctx, rv);\n\t}\n\trv = iso_ops->pin_cmd(card, pin_cmd, tries_left);\n\tLOG_FUNC_RETURN(ctx, rv);\n}", "target": 0}
{"code": "static bool _valid_hex(char *s, const char *file, const char *func, const int line)\n{\n\tbool ret = false;\n\tint i, len;\n\tif (unlikely(!s)) {\n\t\tapplog(LOG_ERR, \"Null string passed to valid_hex from\"IN_FMT_FFL, file, func, line);\n\t\treturn ret;\n\t}\n\tlen = strlen(s);\n\tif (unlikely(!len)) {\n\t\tapplog(LOG_ERR, \"Zero length string passed to valid_hex from\"IN_FMT_FFL, file, func, line);\n\t\treturn ret;\n\t}\n\tfor (i = 0; i < len; i++) {\n\t\tunsigned char idx = s[i];\n\t\tif (unlikely(hex2bin_tbl[idx] < 0)) {\n\t\t\tapplog(LOG_ERR, \"Invalid char %x passed to valid_hex from\"IN_FMT_FFL, idx, file, func, line);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tret = true;\n\treturn ret;\n}", "target": 0}
{"code": "static struct btrfs_fs_devices *find_fsid_changed(\n\t\t\t\t\tstruct btrfs_super_block *disk_super)\n{\n\tstruct btrfs_fs_devices *fs_devices;\n\tlist_for_each_entry(fs_devices, &fs_uuids, fs_list) {\n\t\tif (memcmp(fs_devices->metadata_uuid, fs_devices->fsid,\n\t\t\t   BTRFS_FSID_SIZE) != 0 &&\n\t\t    memcmp(fs_devices->metadata_uuid, disk_super->metadata_uuid,\n\t\t\t   BTRFS_FSID_SIZE) == 0 &&\n\t\t    memcmp(fs_devices->fsid, disk_super->fsid,\n\t\t\t   BTRFS_FSID_SIZE) != 0) {\n\t\t\treturn fs_devices;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "static void* my_gballoc_realloc(void* ptr, size_t size)\n{\n    return realloc(ptr, size);\n}", "target": 0}
{"code": "void ipc_rcu_getref(void *ptr)\n{\n\tcontainer_of(ptr, struct ipc_rcu_hdr, data)->refcount++;\n}", "target": 1}
{"code": "void ArrowHead()\n{\n    int k;\n    double length;\n    SaveGraphicsState;\n    if ( flip ) length = -arrow.length;\n    else        length =  arrow.length;\n    SetDashSize(0,0);\n    if ( arrow.stroke ) {\n        SetLineWidth(arrow.stroke);\n        for (k = 1; k <= 2; k++ ) {\n            SaveGraphicsState;\n            MoveTo(length*0.5,0);\n            LineTo(-length*0.5,arrow.width);\n            LineTo(-length*0.5+length*arrow.inset,0);\n            LineTo(-length*0.5,-arrow.width);\n            if (k == 1) {\n                SetBackgroundColor(NONSTROKING);\n                outpos += sprintf(outpos,\" h f\");\n            }\n            else {\n                outpos += sprintf(outpos,\" s\");\n            }\n            RestoreGraphicsState;\n        }\n    }\n    else {\n        MoveTo(length*0.5,0);\n        LineTo(-length*0.5,arrow.width);\n        LineTo(-length*0.5+length*arrow.inset,0);\n        LineTo(-length*0.5,-arrow.width);\n        outpos += sprintf(outpos,\" h f\");\n    }\n    RestoreGraphicsState;\n}", "target": 1}
{"code": "initpyfribidi (void)\n{\n\tPyObject *module;\n\tmodule = Py_InitModule3 (\"pyfribidi\", PyfribidiMethods,\n\t\t\t\t _pyfribidi__doc__);\n\tPyModule_AddIntConstant (module, \"RTL\", (long) FRIBIDI_TYPE_RTL);\n\tPyModule_AddIntConstant (module, \"LTR\", (long) FRIBIDI_TYPE_LTR);\n\tPyModule_AddIntConstant (module, \"ON\", (long) FRIBIDI_TYPE_ON);\n\tPyModule_AddStringConstant (module, \"__author__\",\n\t\t\t\t    \"Yaacov Zamir and Nir Soffer\");\n}", "target": 1}
{"code": "static int snd_seq_device_dev_free(struct snd_device *device)\n{\n\tstruct snd_seq_device *dev = device->device_data;\n\tcancel_autoload_drivers();\n\tput_device(&dev->dev);\n\treturn 0;\n}", "target": 0}
{"code": "static BOOL nsc_stream_initialize(NSC_CONTEXT* context, wStream* s)\n{\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(context->priv);\n\tif (!Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, 20))\n\t\treturn FALSE;\n\tsize_t total = 0;\n\tfor (size_t i = 0; i < 4; i++)\n\t{\n\t\tStream_Read_UINT32(s, context->PlaneByteCount[i]);\n\t\ttotal += context->PlaneByteCount[i];\n\t}\n\tStream_Read_UINT8(s, context->ColorLossLevel);         \n\tStream_Read_UINT8(s, context->ChromaSubsamplingLevel); \n\tStream_Seek(s, 2);                                     \n\tcontext->Planes = Stream_Pointer(s);\n\tcontext->PlanesSize = total;\n\treturn Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, total);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& in_grads = context->input(0);\n    const Tensor& in_image = context->input(1);\n    const Tensor& out_image = context->input(2);\n    OP_REQUIRES(context, in_grads.dims() == 4 && in_image.dims() == 4,\n                errors::InvalidArgument(\"inputs must be 4-dimensional\"));\n    const int64_t batch = in_grads.dim_size(0);\n    const int64_t rows = in_grads.dim_size(1);\n    const int64_t cols = in_grads.dim_size(2);\n    const int64_t depth = in_grads.dim_size(3);\n    OP_REQUIRES(\n        context,\n        in_image.dim_size(0) == batch && in_image.dim_size(1) == rows &&\n            in_image.dim_size(2) == cols && in_image.dim_size(3) == depth &&\n            out_image.dim_size(0) == batch && out_image.dim_size(1) == rows &&\n            out_image.dim_size(2) == cols && out_image.dim_size(3) == depth,\n        errors::InvalidArgument(\n            \"input_grads, input_image, and out_image should have the same \"\n            \"shape\"));\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(\n                       0, TensorShape({batch, rows, cols, depth}), &output));\n    LaunchLRNGrad<Device, T> launcher(depth_radius_, bias_, alpha_, beta_);\n    launcher.launch(context, this, in_grads, in_image, out_image, output);\n  }", "target": 1}
{"code": "storageDriverAutostartCallback(virStoragePoolObj *obj,\n                               const void *opaque G_GNUC_UNUSED)\n{\n    virStoragePoolDef *def = virStoragePoolObjGetDef(obj);\n    virStorageBackend *backend;\n    bool started = false;\n    if (!(backend = virStorageBackendForType(def->type)))\n        return;\n    if (virStoragePoolObjIsAutostart(obj) &&\n        !virStoragePoolObjIsActive(obj)) {\n        virStoragePoolObjSetStarting(obj, true);\n        if (backend->startPool &&\n            backend->startPool(obj) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to autostart storage pool '%s': %s\"),\n                           def->name, virGetLastErrorMessage());\n            goto cleanup;\n        }\n        started = true;\n    }\n    if (started) {\n        g_autofree char *stateFile = NULL;\n        stateFile = virFileBuildPath(driver->stateDir, def->name, \".xml\");\n        if (!stateFile ||\n            virStoragePoolSaveState(stateFile, def) < 0 ||\n            storagePoolRefreshImpl(backend, obj, stateFile) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to autostart storage pool '%s': %s\"),\n                           def->name, virGetLastErrorMessage());\n        } else {\n            virStoragePoolObjSetActive(obj, true);\n        }\n    }\n cleanup:\n    if (virStoragePoolObjIsStarting(obj)) {\n        if (!virStoragePoolObjIsActive(obj))\n            virStoragePoolUpdateInactive(obj);\n        virStoragePoolObjSetStarting(obj, false);\n    }\n}", "target": 0}
{"code": "void svhandler_flash_pgm_word(void) {\n  uint32_t dst = _param_1;\n  uint32_t src = _param_2;\n  if ((dst >= BSTRP_FLASH_SECT_START) &&\n      (dst <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN))) {\n    return;\n  }\n  if ((dst >= BLDR_FLASH_SECT_START) &&\n      (dst <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN))) {\n    return;\n  }\n  flash_clear_status_flags();\n  flash_unlock();\n  flash_program_word(dst, src);\n  _param_1 = !!flash_chk_status();\n  _param_2 = 0;\n  _param_3 = 0;\n  flash_wait_for_last_operation();\n  FLASH_CR &= ~FLASH_CR_PG;\n  FLASH_CR |= FLASH_CR_LOCK;\n}", "target": 1}
{"code": "void migrate_page_copy(struct page *newpage, struct page *page)\n{\n\tint cpupid;\n\tif (PageHuge(page) || PageTransHuge(page))\n\t\tcopy_huge_page(newpage, page);\n\telse\n\t\tcopy_highpage(newpage, page);\n\tif (PageError(page))\n\t\tSetPageError(newpage);\n\tif (PageReferenced(page))\n\t\tSetPageReferenced(newpage);\n\tif (PageUptodate(page))\n\t\tSetPageUptodate(newpage);\n\tif (TestClearPageActive(page)) {\n\t\tVM_BUG_ON_PAGE(PageUnevictable(page), page);\n\t\tSetPageActive(newpage);\n\t} else if (TestClearPageUnevictable(page))\n\t\tSetPageUnevictable(newpage);\n\tif (PageChecked(page))\n\t\tSetPageChecked(newpage);\n\tif (PageMappedToDisk(page))\n\t\tSetPageMappedToDisk(newpage);\n\tif (PageDirty(page)) {\n\t\tclear_page_dirty_for_io(page);\n\t\tif (PageSwapBacked(page))\n\t\t\tSetPageDirty(newpage);\n\t\telse\n\t\t\t__set_page_dirty_nobuffers(newpage);\n \t}\n\tif (page_is_young(page))\n\t\tset_page_young(newpage);\n\tif (page_is_idle(page))\n\t\tset_page_idle(newpage);\n\tcpupid = page_cpupid_xchg_last(page, -1);\n\tpage_cpupid_xchg_last(newpage, cpupid);\n\tksm_migrate_page(newpage, page);\n\tif (PageSwapCache(page))\n\t\tClearPageSwapCache(page);\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tif (PageWriteback(newpage))\n\t\tend_page_writeback(newpage);\n}", "target": 1}
{"code": "int bson_check_string( bson *b, const char *string,\n                       const int length ) {\n    return bson_validate_string( b, ( const unsigned char * )string, length, 1, 0, 0 );\n}", "target": 1}
{"code": "int socketio_setoption(CONCRETE_IO_HANDLE socket_io, const char* optionName, const void* value)\n{\n    int result;\n    if (socket_io == NULL ||\n        optionName == NULL ||\n        value == NULL)\n    {\n        result = MU_FAILURE;\n    }\n    else\n    {\n        SOCKET_IO_INSTANCE* socket_io_instance = (SOCKET_IO_INSTANCE*)socket_io;\n        if (strcmp(optionName, \"tcp_keepalive\") == 0)\n        {\n            result = setsockopt(socket_io_instance->socket, SOL_SOCKET, SO_KEEPALIVE, value, sizeof(int));\n            if (result == -1) result = errno;\n        }\n        else if (strcmp(optionName, \"tcp_keepalive_time\") == 0)\n        {\n#ifdef __APPLE__\n            result = setsockopt(socket_io_instance->socket, IPPROTO_TCP, TCP_KEEPALIVE, value, sizeof(int));\n#else\n            result = setsockopt(socket_io_instance->socket, SOL_TCP, TCP_KEEPIDLE, value, sizeof(int));\n#endif\n            if (result == -1) result = errno;\n        }\n        else if (strcmp(optionName, \"tcp_keepalive_interval\") == 0)\n        {\n            result = setsockopt(socket_io_instance->socket, SOL_TCP, TCP_KEEPINTVL, value, sizeof(int));\n            if (result == -1) result = errno;\n        }\n        else if (strcmp(optionName, OPTION_NET_INT_MAC_ADDRESS) == 0)\n        {\n#ifdef __APPLE__\n            LogError(\"option not supported.\");\n            result = MU_FAILURE;\n#else\n            if (strlen(value) == 0)\n            {\n                LogError(\"option value must be a valid mac address\");\n                result = MU_FAILURE;\n            }\n            else if ((socket_io_instance->target_mac_address = (char*)malloc(sizeof(char) * (strlen(value) + 1))) == NULL)\n            {\n                LogError(\"failed setting net_interface_mac_address option (malloc failed)\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                strcpy(socket_io_instance->target_mac_address, value);\n                strtoup(socket_io_instance->target_mac_address);\n                result = 0;\n            }\n#endif\n        }\n        else if (strcmp(optionName, OPTION_ADDRESS_TYPE) == 0)\n        {\n            result = socketio_setaddresstype_option(socket_io_instance, (const char*)value);\n        }\n        else\n        {\n            result = MU_FAILURE;\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "static int assign_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tstruct task_group *tg = cfs_rq->tg;\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(tg);\n\tu64 amount = 0, min_amount, expires;\n\tint expires_seq;\n\tmin_amount = sched_cfs_bandwidth_slice() - cfs_rq->runtime_remaining;\n\traw_spin_lock(&cfs_b->lock);\n\tif (cfs_b->quota == RUNTIME_INF)\n\t\tamount = min_amount;\n\telse {\n\t\tstart_cfs_bandwidth(cfs_b);\n\t\tif (cfs_b->runtime > 0) {\n\t\t\tamount = min(cfs_b->runtime, min_amount);\n\t\t\tcfs_b->runtime -= amount;\n\t\t\tcfs_b->idle = 0;\n\t\t}\n\t}\n\texpires_seq = cfs_b->expires_seq;\n\texpires = cfs_b->runtime_expires;\n\traw_spin_unlock(&cfs_b->lock);\n\tcfs_rq->runtime_remaining += amount;\n\tif (cfs_rq->expires_seq != expires_seq) {\n\t\tcfs_rq->expires_seq = expires_seq;\n\t\tcfs_rq->runtime_expires = expires;\n\t}\n\treturn cfs_rq->runtime_remaining > 0;\n}", "target": 1}
{"code": "static int adpt_reset(struct scsi_cmnd* cmd)\n{\n\tint rc;\n\tspin_lock_irq(cmd->device->host->host_lock);\n\trc = __adpt_reset(cmd);\n\tspin_unlock_irq(cmd->device->host->host_lock);\n\treturn rc;\n}", "target": 1}
{"code": "void ext4_journal_abort_handle(const char *caller, unsigned int line,\n\t\t\t       const char *err_fn, struct buffer_head *bh,\n\t\t\t       handle_t *handle, int err)\n{\n\tchar nbuf[16];\n\tconst char *errstr = ext4_decode_error(NULL, err, nbuf);\n\tBUG_ON(!ext4_handle_valid(handle));\n\tif (bh)\n\t\tBUFFER_TRACE(bh, \"abort\");\n\tif (!handle->h_err)\n\t\thandle->h_err = err;\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\tprintk(KERN_ERR \"EXT4-fs: %s:%d: aborting transaction: %s in %s\\n\",\n\t       caller, line, errstr, err_fn);\n\tjbd2_journal_abort_handle(handle);\n}", "target": 0}
{"code": "int main(void)\n{\n\tFILE *f;\n\tchar *tmpname;\n\tf = xfmkstemp(&tmpname, NULL);\n\tunlink(tmpname);\n\tfree(tmpname);\n\tfclose(f);\n\treturn EXIT_FAILURE;\n}", "target": 1}
{"code": "static bool __f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_tree *et;\n\tstruct extent_node *en;\n\tstruct extent_info ei;\n\tif (!f2fs_may_extent_tree(inode)) {\n\t\tif (i_ext && i_ext->len) {\n\t\t\ti_ext->len = 0;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tet = __grab_extent_tree(inode);\n\tif (!i_ext || !i_ext->len)\n\t\treturn false;\n\tget_extent_info(&ei, i_ext);\n\twrite_lock(&et->lock);\n\tif (atomic_read(&et->node_cnt))\n\t\tgoto out;\n\ten = __init_extent_tree(sbi, et, &ei);\n\tif (en) {\n\t\tspin_lock(&sbi->extent_lock);\n\t\tlist_add_tail(&en->list, &sbi->extent_list);\n\t\tspin_unlock(&sbi->extent_lock);\n\t}\nout:\n\twrite_unlock(&et->lock);\n\treturn false;\n}", "target": 0}
{"code": "TEST_P(ResizeRealtimeTest, DISABLED_TestExternalResizeSmallerWidthBiggerSize) {\n  ResizingVideoSource video;\n  video.flag_codec_ = true;\n  video.smaller_width_larger_size_ = true;\n  DefaultConfig();\n  cfg_.rc_resize_allowed = 0;\n  change_bitrate_ = false;\n  mismatch_psnr_ = 0.0;\n  mismatch_nframes_ = 0;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  for (std::vector<FrameInfo>::const_iterator info = frame_info_list_.begin();\n       info != frame_info_list_.end(); ++info) {\n    const unsigned int frame = static_cast<unsigned>(info->pts);\n    unsigned int expected_w;\n    unsigned int expected_h;\n    ScaleForFrameNumber(frame, kInitialWidth, kInitialHeight, &expected_w,\n                        &expected_h, video.flag_codec_,\n                        video.smaller_width_larger_size_);\n    EXPECT_EQ(expected_w, info->w)\n        << \"Frame \" << frame << \" had unexpected width\";\n    EXPECT_EQ(expected_h, info->h)\n        << \"Frame \" << frame << \" had unexpected height\";\n    EXPECT_EQ(static_cast<unsigned int>(0), GetMismatchFrames());\n  }\n}", "target": 1}
{"code": "static int ntlm_decode_oem_str(struct wire_field_hdr *str_hdr,\n                               struct ntlm_buffer *buffer,\n                               size_t payload_offs, char **_str)\n{\n    uint16_t str_len;\n    uint32_t str_offs;\n    char *str = NULL;\n    str_len = le16toh(str_hdr->len);\n    if (str_len == 0) goto done;\n    str_offs = le32toh(str_hdr->offset);\n    if ((str_offs < payload_offs) ||\n        (str_offs > buffer->length) ||\n        (UINT32_MAX - str_offs < str_len) ||\n        (str_offs + str_len > buffer->length)) {\n        return ERR_DECODE;\n    }\n    str = strndup((const char *)&buffer->data[str_offs], str_len);\n    if (!str) return ENOMEM;\ndone:\n    *_str = str;\n    return 0;\n}", "target": 0}
{"code": "bool_t xdr_krb5_tl_data(XDR *xdrs, krb5_tl_data **tl_data_head)\n{\n     krb5_tl_data *tl, *tl2;\n     bool_t more;\n     unsigned int len;\n     switch (xdrs->x_op) {\n     case XDR_FREE:\n\t  tl = tl2 = *tl_data_head;\n\t  while (tl) {\n\t       tl2 = tl->tl_data_next;\n\t       free(tl->tl_data_contents);\n\t       free(tl);\n\t       tl = tl2;\n\t  }\n\t  *tl_data_head = NULL;\n\t  break;\n     case XDR_ENCODE:\n\t  tl = *tl_data_head;\n\t  while (1) {\n\t       more = (tl != NULL);\n\t       if (!xdr_bool(xdrs, &more))\n\t\t    return FALSE;\n\t       if (tl == NULL)\n\t\t    break;\n\t       if (!xdr_krb5_int16(xdrs, &tl->tl_data_type))\n\t\t    return FALSE;\n\t       len = tl->tl_data_length;\n\t       if (!xdr_bytes(xdrs, (char **) &tl->tl_data_contents, &len, ~0))\n\t\t    return FALSE;\n\t       tl = tl->tl_data_next;\n\t  }\n\t  break;\n     case XDR_DECODE:\n\t  tl = NULL;\n\t  while (1) {\n\t       if (!xdr_bool(xdrs, &more))\n\t\t    return FALSE;\n\t       if (more == FALSE)\n\t\t    break;\n\t       tl2 = (krb5_tl_data *) malloc(sizeof(krb5_tl_data));\n\t       if (tl2 == NULL)\n\t\t    return FALSE;\n\t       memset(tl2, 0, sizeof(krb5_tl_data));\n\t       if (!xdr_krb5_int16(xdrs, &tl2->tl_data_type))\n\t\t    return FALSE;\n\t       if (!xdr_bytes(xdrs, (char **)&tl2->tl_data_contents, &len, ~0))\n\t\t    return FALSE;\n\t       tl2->tl_data_length = len;\n\t       tl2->tl_data_next = tl;\n\t       tl = tl2;\n\t  }\n\t  *tl_data_head = tl;\n\t  break;\n     }\n     return TRUE;\n}", "target": 0}
{"code": "static int xfrm_dump_policy_done(struct netlink_callback *cb)\n{\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n\txfrm_policy_walk_done(walk);\n\treturn 0;\n}", "target": 1}
{"code": "static unsigned char *oidc_cache_hash_passphrase(request_rec *r,\n\t\tconst char *passphrase) {\n\tunsigned char *key = NULL;\n\tunsigned int key_len = 0;\n\toidc_jose_error_t err;\n\tif (oidc_jose_hash_bytes(r->pool, OIDC_JOSE_ALG_SHA256,\n\t\t\t(const unsigned char *) passphrase, strlen(passphrase), &key,\n\t\t\t&key_len, &err) == FALSE) {\n\t\toidc_error(r, \"oidc_jose_hash_bytes returned an error: %s\", err.text);\n\t\treturn NULL;\n\t}\n\treturn key;\n}", "target": 1}
{"code": "    bool IsOpened() {return hFile!=FILE_BAD_HANDLE;};", "target": 1}
{"code": "SPL_METHOD(SplDoublyLinkedList, offsetSet)\n{\n\tzval                  *zindex, *value;\n\tspl_dllist_object     *intern;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"zz\", &zindex, &value) == FAILURE) {\n\t\treturn;\n\t}\n\tintern = Z_SPLDLLIST_P(getThis());\n\tif (Z_TYPE_P(zindex) == IS_NULL) {\n\t\tspl_ptr_llist_push(intern->llist, value);\n\t} else {\n\t\tzend_long                   index;\n\t\tspl_ptr_llist_element *element;\n\t\tindex = spl_offset_convert_to_long(zindex);\n\t\tif (index < 0 || index >= intern->llist->count) {\n\t\t\tzval_ptr_dtor(value);\n\t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \"Offset invalid or out of range\", 0);\n\t\t\treturn;\n\t\t}\n\t\telement = spl_ptr_llist_offset(intern->llist, index, intern->flags & SPL_DLLIST_IT_LIFO);\n\t\tif (element != NULL) {\n\t\t\tif (intern->llist->dtor) {\n\t\t\t\tintern->llist->dtor(element);\n\t\t\t}\n\t\t\tzval_ptr_dtor(&element->data);\n\t\t\tZVAL_COPY_VALUE(&element->data, value);\n\t\t\tif (intern->llist->ctor) {\n\t\t\t\tintern->llist->ctor(element);\n\t\t\t}\n\t\t} else {\n\t\t\tzval_ptr_dtor(value);\n\t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \"Offset invalid\", 0);\n\t\t\treturn;\n\t\t}\n\t}\n} ", "target": 1}
{"code": "static void nft_lookup_activate(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nft_expr *expr)\n{\n\tstruct nft_lookup *priv = nft_expr_priv(expr);\n\tpriv->set->use++;\n}", "target": 1}
{"code": "__u32 secure_tcp_sequence_number(__be32 saddr, __be32 daddr,\n\t\t\t\t __be16 sport, __be16 dport)\n{\n\tu32 hash[MD5_DIGEST_WORDS];\n\thash[0] = (__force u32)saddr;\n\thash[1] = (__force u32)daddr;\n\thash[2] = ((__force u16)sport << 16) + (__force u16)dport;\n\thash[3] = net_secret[15];\n\tmd5_transform(hash, net_secret);\n\treturn seq_scale(hash[0]);\n}", "target": 0}
{"code": "pci_set_cfgdata16(struct pci_vdev *dev, int offset, uint16_t val)\n{\n\tassert(offset <= (PCI_REGMAX - 1) && (offset & 1) == 0);\n\t*(uint16_t *)(dev->cfgdata + offset) = val;\n}", "target": 1}
{"code": "const char *cgit_loginurl(void)\n{\n\tstatic const char *login_url;\n\tif (!login_url)\n\t\tlogin_url = fmtalloc(\"%s?p=login\", cgit_rooturl());\n\treturn login_url;\n}", "target": 0}
{"code": "static int skcipher_recvmsg_nokey(struct socket *sock, struct msghdr *msg,\n\t\t\t\t  size_t ignored, int flags)\n{\n\tint err;\n\terr = skcipher_check_key(sock);\n\tif (err)\n\t\treturn err;\n\treturn skcipher_recvmsg(sock, msg, ignored, flags);\n}", "target": 0}
{"code": "int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n{\n#ifndef WITH_BROKER\n\tchar sockpair_data = 0;\n#endif\n\tassert(mosq);\n\tassert(packet);\n\tpacket->pos = 0;\n\tpacket->to_process = packet->packet_length;\n\tpacket->next = NULL;\n\tpthread_mutex_lock(&mosq->out_packet_mutex);\n#ifdef WITH_BROKER\n\tif(mosq->out_packet_count >= db.config->max_queued_messages){\n\t\tmosquitto__free(packet);\n\t\tif(mosq->is_dropping == false){\n\t\t\tmosq->is_dropping = true;\n\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n\t\t\t\t\t\"Outgoing messages are being dropped for client %s.\",\n\t\t\t\t\tmosq->id);\n\t\t}\n\t\tG_MSGS_DROPPED_INC();\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}\n#endif\n\tif(mosq->out_packet){\n\t\tmosq->out_packet_last->next = packet;\n\t}else{\n\t\tmosq->out_packet = packet;\n\t}\n\tmosq->out_packet_last = packet;\n\tmosq->out_packet_count++;\n\tpthread_mutex_unlock(&mosq->out_packet_mutex);\n#ifdef WITH_BROKER\n#  ifdef WITH_WEBSOCKETS\n\tif(mosq->wsi){\n\t\tlws_callback_on_writable(mosq->wsi);\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}else{\n\t\treturn packet__write(mosq);\n\t}\n#  else\n\treturn packet__write(mosq);\n#  endif\n#else\n\tif(mosq->sockpairW != INVALID_SOCKET){\n#ifndef WIN32\n\t\tif(write(mosq->sockpairW, &sockpair_data, 1)){\n\t\t}\n#else\n\t\tsend(mosq->sockpairW, &sockpair_data, 1, 0);\n#endif\n\t}\n\tif(mosq->in_callback == false && mosq->threaded == mosq_ts_none){\n\t\treturn packet__write(mosq);\n\t}else{\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}\n#endif\n}", "target": 0}
{"code": "static void *createArrayObject(const redisReadTask *task, size_t elements) {\n    redisReply *r, *parent;\n    r = createReplyObject(task->type);\n    if (r == NULL)\n        return NULL;\n    if (elements > 0) {\n        if (SIZE_MAX / sizeof(redisReply*) < elements) return NULL;  \n        r->element = hi_calloc(elements,sizeof(redisReply*));\n        if (r->element == NULL) {\n            freeReplyObject(r);\n            return NULL;\n        }\n    }\n    r->elements = elements;\n    if (task->parent) {\n        parent = task->parent->obj;\n        assert(parent->type == REDIS_REPLY_ARRAY ||\n               parent->type == REDIS_REPLY_MAP ||\n               parent->type == REDIS_REPLY_SET ||\n               parent->type == REDIS_REPLY_PUSH);\n        parent->element[task->idx] = r;\n    }\n    return r;\n}", "target": 0}
{"code": "static void nft_dynset_activate(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nft_expr *expr)\n{\n\tstruct nft_dynset *priv = nft_expr_priv(expr);\n\tpriv->set->use++;\n}", "target": 1}
{"code": "void Lab2ITU(const cmsCIELab* Lab, cmsUInt16Number Out[3])\n{\n\tOut[0] = (cmsUInt16Number) floor((double) (Lab -> L / 100.)* 65535. );\n\tOut[1] = (cmsUInt16Number) floor((double) (Lab -> a / 170.)* 65535. + 32768. );\n\tOut[2] = (cmsUInt16Number) floor((double) (Lab -> b / 200.)* 65535. + 24576. );\n}", "target": 0}
{"code": "static int oidc_request_post_preserved_restore(request_rec *r,\n\t\tconst char *original_url) {\n\toidc_debug(r, \"enter: original_url=%s\", original_url);\n\tconst char *method = \"postOnLoad\";\n\tconst char *script =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function str_decode(string) {\\n\"\n\t\t\t\t\t\"        try {\\n\"\n\t\t\t\t\t\"          result = decodeURIComponent(string);\\n\"\n\t\t\t\t\t\"        } catch (e) {\\n\"\n\t\t\t\t\t\"          result =  unescape(string);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        return result;\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        var mod_auth_openidc_preserve_post_params = JSON.parse(sessionStorage.getItem('mod_auth_openidc_preserve_post_params'));\\n\"\n\t\t\t\t\t\"\t\t sessionStorage.removeItem('mod_auth_openidc_preserve_post_params');\\n\"\n\t\t\t\t\t\"        for (var key in mod_auth_openidc_preserve_post_params) {\\n\"\n\t\t\t\t\t\"          var input = document.createElement(\\\"input\\\");\\n\"\n\t\t\t\t\t\"          input.name = str_decode(key);\\n\"\n\t\t\t\t\t\"          input.value = str_decode(mod_auth_openidc_preserve_post_params[key]);\\n\"\n\t\t\t\t\t\"          input.type = \\\"hidden\\\";\\n\"\n\t\t\t\t\t\"          document.forms[0].appendChild(input);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        document.forms[0].action = \\\"%s\\\";\\n\"\n\t\t\t\t\t\"        document.forms[0].submit();\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", method, oidc_util_javascript_escape(r->pool, original_url));\n\tconst char *body = \"    <p>Restoring...</p>\\n\"\n\t\t\t\"    <form method=\\\"post\\\"></form>\\n\";\n\treturn oidc_util_html_send(r, \"Restoring...\", script, method, body,\n\t\t\tOK);\n}", "target": 0}
{"code": "static void get_info_from_frame (mpeg2ps_stream_t *sptr,\n                                 u8 *buffer,\n                                 u32 buflen)\n{\n\tif (sptr->is_video) {\n\t\tif (MPEG12_ParseSeqHdr(buffer, buflen,\n\t\t                       &sptr->have_mpeg2,\n\t\t                       &sptr->h,\n\t\t                       &sptr->w,\n\t\t                       &sptr->frame_rate,\n\t\t                       &sptr->bit_rate,\n\t\t                       &sptr->par) < 0) {\n\t\t\tsptr->m_stream_id = 0;\n\t\t\tsptr->m_fd = FDNULL;\n\t\t\treturn;\n\t\t}\n\t\tsptr->ticks_per_frame = (u64)(90000.0 / sptr->frame_rate);\n\t\treturn;\n\t}\n\tif (sptr->m_stream_id >= 0xc0) {\n\t\tu32 hdr = GF_4CC((u32)buffer[0],buffer[1],buffer[2],buffer[3]);\n\t\tsptr->channels = gf_mp3_num_channels(hdr);\n\t\tsptr->freq = gf_mp3_sampling_rate(hdr);\n\t\tsptr->samples_per_frame = gf_mp3_window_size(hdr);\n\t\tsptr->bitrate = gf_mp3_bit_rate(hdr) * 1000; \n\t\tsptr->layer = gf_mp3_layer(hdr);\n\t} else if (sptr->m_stream_id == 0xbd) {\n\t\tif (sptr->m_substream_id >= 0xa0) {\n\t\t} else if (sptr->m_substream_id >= 0x80) {\n\t\t\tu32 pos;\n\t\t\tGF_AC3Config hdr;\n\t\t\tmemset(&hdr, 0, sizeof(GF_AC3Config));\n\t\t\tgf_ac3_parser(buffer, buflen, &pos, &hdr, 0);\n\t\t\tsptr->bitrate = gf_ac3_get_bitrate(hdr.brcode);\n\t\t\tsptr->freq = hdr.sample_rate;\n\t\t\tsptr->channels = hdr.streams[0].channels;\n\t\t\tsptr->samples_per_frame = 256 * 6;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\treturn;\n\t}\n}", "target": 0}
{"code": "static int key_notify_policy_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb_out;\n\tstruct sadb_msg *hdr;\n\tskb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb_out)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb_out, sizeof(struct sadb_msg));\n\thdr->sadb_msg_type = SADB_X_SPDFLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\thdr->sadb_msg_reserved = 0;\n\tpfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\treturn 0;\n}", "target": 0}
{"code": "void OfflineAudioDestinationHandler::DoOfflineRendering() {\n  DCHECK(!IsMainThread());\n  unsigned number_of_channels;\n  Vector<float*> destinations;\n  {\n    bool has_lock = ProcessHeap::CrossThreadPersistentMutex().TryLock();\n    if (!has_lock) {\n      render_thread_task_runner_->PostTask(\n          FROM_HERE,\n          WTF::Bind(&OfflineAudioDestinationHandler::DoOfflineRendering,\n                    WrapRefCounted(this)));\n      return;\n    }\n    number_of_channels = render_target_->numberOfChannels();\n    destinations.ReserveInitialCapacity(number_of_channels);\n    for (unsigned i = 0; i < number_of_channels; ++i)\n      destinations.push_back(render_target_->getChannelData(i).View()->Data());\n    ProcessHeap::CrossThreadPersistentMutex().unlock();\n  }\n  while (frames_to_process_ > 0) {\n    if (RenderIfNotSuspended(nullptr, render_bus_.get(),\n                             audio_utilities::kRenderQuantumFrames))\n      return;\n    uint32_t frames_available_to_copy =\n        std::min(frames_to_process_, audio_utilities::kRenderQuantumFrames);\n    for (unsigned channel_index = 0; channel_index < number_of_channels;\n         ++channel_index) {\n      const float* source = render_bus_->Channel(channel_index)->Data();\n      memcpy(destinations[channel_index] + frames_processed_, source,\n             sizeof(float) * frames_available_to_copy);\n    }\n    frames_processed_ += frames_available_to_copy;\n    DCHECK_GE(frames_to_process_, frames_available_to_copy);\n    frames_to_process_ -= frames_available_to_copy;\n  }\n  DCHECK_EQ(frames_to_process_, 0u);\n  FinishOfflineRendering();\n}", "target": 0}
{"code": "static int bson_string_is_db_ref( const unsigned char *string, const int length ) {\n    int result = 0;\n    if( length >= 4 ) {\n        if( string[1] == 'r' && string[2] == 'e' && string[3] == 'f' )\n            result = 1;\n    }\n    else if( length >= 3 ) {\n        if( string[1] == 'i' && string[2] == 'd' )\n            result = 1;\n        else if( string[1] == 'd' && string[2] == 'b' )\n            result = 1;\n    }\n    return result;\n}", "target": 1}
{"code": "date_strftime_internal(int argc, VALUE *argv, VALUE self,\n\t\t       const char *default_fmt,\n\t\t       void (*func)(VALUE, struct tmx *))\n{\n    VALUE vfmt;\n    const char *fmt;\n    long len;\n    char buffer[SMALLBUF], *buf = buffer;\n    struct tmx tmx;\n    VALUE str;\n    rb_scan_args(argc, argv, \"01\", &vfmt);\n    if (argc < 1)\n\tvfmt = rb_usascii_str_new2(default_fmt);\n    else {\n\tStringValue(vfmt);\n\tif (!rb_enc_str_asciicompat_p(vfmt)) {\n\t    rb_raise(rb_eArgError,\n\t\t     \"format should have ASCII compatible encoding\");\n\t}\n    }\n    fmt = RSTRING_PTR(vfmt);\n    len = RSTRING_LEN(vfmt);\n    (*func)(self, &tmx);\n    if (memchr(fmt, '\\0', len)) {\n\tconst char *p = fmt, *pe = fmt + len;\n\tstr = rb_str_new(0, 0);\n\twhile (p < pe) {\n\t    len = date_strftime_alloc(&buf, p, &tmx);\n\t    rb_str_cat(str, buf, len);\n\t    p += strlen(p);\n\t    if (buf != buffer) {\n\t\txfree(buf);\n\t\tbuf = buffer;\n\t    }\n\t    for (fmt = p; p < pe && !*p; ++p);\n\t    if (p > fmt) rb_str_cat(str, fmt, p - fmt);\n\t}\n\trb_enc_copy(str, vfmt);\n\treturn str;\n    }\n    else\n\tlen = date_strftime_alloc(&buf, fmt, &tmx);\n    str = rb_str_new(buf, len);\n    if (buf != buffer) xfree(buf);\n    rb_enc_copy(str, vfmt);\n    return str;\n}", "target": 0}
{"code": "mesh_state_cleanup(struct mesh_state* mstate)\n{\n\tstruct mesh_area* mesh;\n\tint i;\n\tif(!mstate)\n\t\treturn;\n\tmesh = mstate->s.env->mesh;\n\tif(mstate->s.serve_expired_data && mstate->s.serve_expired_data->timer) {\n\t\tcomm_timer_delete(mstate->s.serve_expired_data->timer);\n\t\tmstate->s.serve_expired_data->timer = NULL;\n\t}\n\tif(!mstate->replies_sent) {\n\t\tstruct mesh_reply* rep = mstate->reply_list;\n\t\tstruct mesh_cb* cb;\n\t\tmstate->reply_list = NULL;\n\t\tfor(; rep; rep=rep->next) {\n\t\t\tinfra_wait_limit_dec(mesh->env->infra_cache,\n\t\t\t\t&rep->query_reply, mesh->env->cfg);\n\t\t\tcomm_point_drop_reply(&rep->query_reply);\n\t\t\tlog_assert(mesh->num_reply_addrs > 0);\n\t\t\tmesh->num_reply_addrs--;\n\t\t}\n\t\twhile((cb = mstate->cb_list)!=NULL) {\n\t\t\tmstate->cb_list = cb->next;\n\t\t\tfptr_ok(fptr_whitelist_mesh_cb(cb->cb));\n\t\t\t(*cb->cb)(cb->cb_arg, LDNS_RCODE_SERVFAIL, NULL,\n\t\t\t\tsec_status_unchecked, NULL, 0);\n\t\t\tlog_assert(mesh->num_reply_addrs > 0);\n\t\t\tmesh->num_reply_addrs--;\n\t\t}\n\t}\n\tfor(i=0; i<mesh->mods.num; i++) {\n\t\tfptr_ok(fptr_whitelist_mod_clear(mesh->mods.mod[i]->clear));\n\t\t(*mesh->mods.mod[i]->clear)(&mstate->s, i);\n\t\tmstate->s.minfo[i] = NULL;\n\t\tmstate->s.ext_state[i] = module_finished;\n\t}\n\talloc_reg_release(mstate->s.env->alloc, mstate->s.region);\n}", "target": 0}
{"code": "urlInitialize(void)\n{\n    debugs(23, 5, \"urlInitialize: Initializing...\");\n    assert(strcmp(AnyP::ProtocolType_str[AnyP::PROTO_MAX], \"MAX\") == 0);\n    assert(0 == matchDomainName(\"foo.com\", \"foo.com\"));\n    assert(0 == matchDomainName(\".foo.com\", \"foo.com\"));\n    assert(0 == matchDomainName(\"foo.com\", \".foo.com\"));\n    assert(0 == matchDomainName(\".foo.com\", \".foo.com\"));\n    assert(0 == matchDomainName(\"x.foo.com\", \".foo.com\"));\n    assert(0 == matchDomainName(\"y.x.foo.com\", \".foo.com\"));\n    assert(0 != matchDomainName(\"x.foo.com\", \"foo.com\"));\n    assert(0 != matchDomainName(\"foo.com\", \"x.foo.com\"));\n    assert(0 != matchDomainName(\"bar.com\", \"foo.com\"));\n    assert(0 != matchDomainName(\".bar.com\", \"foo.com\"));\n    assert(0 != matchDomainName(\".bar.com\", \".foo.com\"));\n    assert(0 != matchDomainName(\"bar.com\", \".foo.com\"));\n    assert(0 < matchDomainName(\"zzz.com\", \"foo.com\"));\n    assert(0 > matchDomainName(\"aaa.com\", \"foo.com\"));\n    assert(0 == matchDomainName(\"FOO.com\", \"foo.COM\"));\n    assert(0 < matchDomainName(\"bfoo.com\", \"afoo.com\"));\n    assert(0 > matchDomainName(\"afoo.com\", \"bfoo.com\"));\n    assert(0 < matchDomainName(\"x-foo.com\", \".foo.com\"));\n    assert(0 == matchDomainName(\".foo.com\", \".foo.com\", mdnRejectSubsubDomains));\n    assert(0 == matchDomainName(\"x.foo.com\", \".foo.com\", mdnRejectSubsubDomains));\n    assert(0 != matchDomainName(\"y.x.foo.com\", \".foo.com\", mdnRejectSubsubDomains));\n    assert(0 != matchDomainName(\".x.foo.com\", \".foo.com\", mdnRejectSubsubDomains));\n    assert(0 == matchDomainName(\"*.foo.com\", \"x.foo.com\", mdnHonorWildcards));\n    assert(0 == matchDomainName(\"*.foo.com\", \".x.foo.com\", mdnHonorWildcards));\n    assert(0 == matchDomainName(\"*.foo.com\", \".foo.com\", mdnHonorWildcards));\n    assert(0 != matchDomainName(\"*.foo.com\", \"foo.com\", mdnHonorWildcards));\n    assert(0 != matchDomainName(\"foo.com\", \"\"));\n    assert(0 != matchDomainName(\"foo.com\", \"\", mdnHonorWildcards));\n    assert(0 != matchDomainName(\"foo.com\", \"\", mdnRejectSubsubDomains));\n}", "target": 0}
{"code": "static int __sock_diag_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tint err;\n\tstruct sock_diag_req *req = nlmsg_data(nlh);\n\tconst struct sock_diag_handler *hndl;\n\tif (nlmsg_len(nlh) < sizeof(*req))\n\t\treturn -EINVAL;\n\tif (req->sdiag_family >= AF_MAX)\n\t\treturn -EINVAL;\n\thndl = sock_diag_lock_handler(req->sdiag_family);\n\tif (hndl == NULL)\n\t\terr = -ENOENT;\n\telse\n\t\terr = hndl->dump(skb, nlh);\n\tsock_diag_unlock_handler(hndl);\n\treturn err;\n}", "target": 0}
{"code": "init_syntax_once ()\n{\n   register int c;\n   static int done;\n   if (done)\n     return;\n   bzero (re_syntax_table, sizeof re_syntax_table);\n   for (c = 'a'; c <= 'z'; c++)\n     re_syntax_table[c] = Sword;\n   for (c = 'A'; c <= 'Z'; c++)\n     re_syntax_table[c] = Sword;\n   for (c = '0'; c <= '9'; c++)\n     re_syntax_table[c] = Sword;\n   re_syntax_table['_'] = Sword;\n   done = 1;\n}", "target": 1}
{"code": "Status SpectrogramShapeFn(InferenceContext* c) {\n  ShapeHandle input;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &input));\n  int32_t window_size;\n  TF_RETURN_IF_ERROR(c->GetAttr(\"window_size\", &window_size));\n  if (window_size <= 1) {\n    return errors::InvalidArgument(\"window size must be > 1, got \",\n                                   window_size);\n  }\n  int32_t stride;\n  TF_RETURN_IF_ERROR(c->GetAttr(\"stride\", &stride));\n  if (stride <= 0) {\n    return errors::InvalidArgument(\"stride must be strictly positive, got \",\n                                   stride);\n  }\n  DimensionHandle input_length = c->Dim(input, 0);\n  DimensionHandle input_channels = c->Dim(input, 1);\n  DimensionHandle output_length;\n  if (!c->ValueKnown(input_length)) {\n    output_length = c->UnknownDim();\n  } else {\n    const int64_t input_length_value = c->Value(input_length);\n    const int64_t length_minus_window = (input_length_value - window_size);\n    int64_t output_length_value;\n    if (length_minus_window < 0) {\n      output_length_value = 0;\n    } else {\n      output_length_value = 1 + (length_minus_window / stride);\n    }\n    output_length = c->MakeDim(output_length_value);\n  }\n  DimensionHandle output_channels =\n      c->MakeDim(1 + NextPowerOfTwo(window_size) / 2);\n  c->set_output(0,\n                c->MakeShape({input_channels, output_length, output_channels}));\n  return OkStatus();\n}", "target": 0}
{"code": "static void nvme_select_iocs_ns(NvmeCtrl *n, NvmeNamespace *ns)\n{\n    uint32_t cc = ldl_le_p(&n->bar.cc);\n    ns->iocs = nvme_cse_iocs_none;\n    switch (ns->csi) {\n    case NVME_CSI_NVM:\n        if (NVME_CC_CSS(cc) != NVME_CC_CSS_ADMIN_ONLY) {\n            ns->iocs = nvme_cse_iocs_nvm;\n        }\n        break;\n    case NVME_CSI_ZONED:\n        if (NVME_CC_CSS(cc) == NVME_CC_CSS_CSI) {\n            ns->iocs = nvme_cse_iocs_zoned;\n        } else if (NVME_CC_CSS(cc) == NVME_CC_CSS_NVM) {\n            ns->iocs = nvme_cse_iocs_nvm;\n        }\n        break;\n    }\n}", "target": 0}
{"code": "IW_IMPL(unsigned int) iw_get_ui32be(const iw_byte *b)\n{\n\treturn (b[0]<<24) | (b[1]<<16) | (b[2]<<8) | b[3];\n}", "target": 1}
{"code": "int dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *key) {\n        int r;\n        assert(p);\n        assert(key);\n        if (DNS_PACKET_QR(p) != 1)\n                return 0;\n        r = dns_packet_extract(p);\n        if (r < 0)\n                return r;\n        if (!p->question)\n                return 0;\n        if (p->question->n_keys != 1)\n                return 0;\n        return dns_resource_key_equal(p->question->keys[0], key);\n}", "target": 0}
{"code": "  void decode(bufferlist::iterator& bl) {\n    __u8 struct_v;\n    ::decode(struct_v, bl);\n    ::decode(server_challenge, bl);\n  }", "target": 0}
{"code": "static void handleOutputMode(void* data, struct wl_output* wl_output, uint32_t flags, int32_t width, int32_t height, int32_t refresh) {\n    const auto POUTPUT = (SOutput*)data;\n    POUTPUT->refreshRate = std::round(refresh / 1000.0);\n}", "target": 1}
{"code": "int nfc_disable_se(struct nfc_dev *dev, u32 se_idx)\n{\n\tstruct nfc_se *se;\n\tint rc;\n\tpr_debug(\"%s se index %d\\n\", dev_name(&dev->dev), se_idx);\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->dev_up) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->ops->enable_se || !dev->ops->disable_se) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto error;\n\t}\n\tse = nfc_find_se(dev, se_idx);\n\tif (!se) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\tif (se->state == NFC_SE_DISABLED) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\trc = dev->ops->disable_se(dev, se_idx);\n\tif (rc >= 0)\n\t\tse->state = NFC_SE_DISABLED;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "static void sctp_sock_rfree_frag(struct sk_buff *skb)\n{\n\tstruct sk_buff *frag;\n\tif (!skb->data_len)\n\t\tgoto done;\n\tfor (frag = skb_shinfo(skb)->frag_list; frag; frag = frag->next)\n\t\tsctp_sock_rfree_frag(frag);\ndone:\n\tsctp_sock_rfree(skb);\n}", "target": 0}
{"code": "static void encode_test_stateid(struct xdr_stream *xdr,\n\t\t\t\tstruct nfs41_test_stateid_args *args,\n\t\t\t\tstruct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_TEST_STATEID, decode_test_stateid_maxsz, hdr);\n\tencode_uint32(xdr, 1);\n\tencode_nfs4_stateid(xdr, args->stateid);\n}", "target": 0}
{"code": "void rose_stop_timer(struct sock *sk)\n{\n\tdel_timer(&rose_sk(sk)->timer);\n}", "target": 1}
{"code": "int ConnectionImpl::onFrameSend(const nghttp2_frame* frame) {\n  ENVOY_CONN_LOG(trace, \"sent frame type={}\", connection_, static_cast<uint64_t>(frame->hd.type));\n  switch (frame->hd.type) {\n  case NGHTTP2_GOAWAY: {\n    ENVOY_CONN_LOG(debug, \"sent goaway code={}\", connection_, frame->goaway.error_code);\n    if (frame->goaway.error_code != NGHTTP2_NO_ERROR) {\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n    break;\n  }\n  case NGHTTP2_RST_STREAM: {\n    ENVOY_CONN_LOG(debug, \"sent reset code={}\", connection_, frame->rst_stream.error_code);\n    stats_.tx_reset_.inc();\n    break;\n  }\n  case NGHTTP2_HEADERS:\n  case NGHTTP2_DATA: {\n    StreamImpl* stream = getStream(frame->hd.stream_id);\n    if (stream->headers_) {\n      ASSERT(stream->headers_->byteSize().has_value() &&\n             stream->headers_->byteSize().value() == stream->headers_->byteSizeInternal());\n    }\n    stream->local_end_stream_sent_ = frame->hd.flags & NGHTTP2_FLAG_END_STREAM;\n    break;\n  }\n  }\n  return 0;\n}", "target": 0}
{"code": "int rose_parse_facilities(unsigned char *p, unsigned packet_len,\n\tstruct rose_facilities_struct *facilities)\n{\n\tint facilities_len, len;\n\tfacilities_len = *p++;\n\tif (facilities_len == 0 || (unsigned)facilities_len > packet_len)\n\t\treturn 0;\n\twhile (facilities_len >= 3 && *p == 0x00) {\n\t\tfacilities_len--;\n\t\tp++;\n\t\tswitch (*p) {\n\t\tcase FAC_NATIONAL:\t\t\n\t\t\tlen = rose_parse_national(p + 1, facilities, facilities_len - 1);\n\t\t\tbreak;\n\t\tcase FAC_CCITT:\t\t\n\t\t\tlen = rose_parse_ccitt(p + 1, facilities, facilities_len - 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_DEBUG \"ROSE: rose_parse_facilities - unknown facilities family %02X\\n\", *p);\n\t\t\tlen = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (len < 0)\n\t\t\treturn 0;\n\t\tif (WARN_ON(len >= facilities_len))\n\t\t\treturn 0;\n\t\tfacilities_len -= len + 1;\n\t\tp += len + 1;\n\t}\n\treturn facilities_len == 0;\n}", "target": 0}
{"code": "static inline __u32 dccp_v6_init_sequence(struct sk_buff *skb)\n{\n\treturn secure_dccpv6_sequence_number(ipv6_hdr(skb)->daddr.s6_addr32,\n\t\t\t\t\t     ipv6_hdr(skb)->saddr.s6_addr32,\n\t\t\t\t\t     dccp_hdr(skb)->dccph_dport,\n\t\t\t\t\t     dccp_hdr(skb)->dccph_sport     );\n}", "target": 1}
{"code": "static void __exit ipgre_fini(void)\n{\n\trtnl_link_unregister(&ipgre_tap_ops);\n\trtnl_link_unregister(&ipgre_link_ops);\n\tunregister_pernet_device(&ipgre_net_ops);\n\tif (inet_del_protocol(&ipgre_protocol, IPPROTO_GRE) < 0)\n\t\tprintk(KERN_INFO \"ipgre close: can't remove protocol\\n\");\n}", "target": 1}
{"code": "static inline unsigned char unimap_bsearch(const uni_to_enc *table, unsigned code_key_a, size_t num)\n{\n\tconst uni_to_enc *l = table,\n\t\t\t\t\t *h = &table[num-1],\n\t\t\t\t\t *m;\n\tunsigned short code_key;\n\tif (code_key_a > 0xFFFFU)\n\t\treturn 0;\n\tcode_key = (unsigned short) code_key_a;\n\twhile (l <= h) {\n\t\tm = l + (h - l) / 2;\n\t\tif (code_key < m->un_code_point)\n\t\t\th = m - 1;\n\t\telse if (code_key > m->un_code_point)\n\t\t\tl = m + 1;\n\t\telse\n\t\t\treturn m->cs_code;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "  QInt8() {}", "target": 1}
{"code": "static void i8042_stop(struct serio *serio)\n{\n\tstruct i8042_port *port = serio->port_data;\n\tport->exists = false;\n\tsynchronize_irq(I8042_AUX_IRQ);\n\tsynchronize_irq(I8042_KBD_IRQ);\n\tport->serio = NULL;\n}", "target": 1}
{"code": "TfLiteStatus PrepareHashtableSize(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputResourceIdTensor);\n  TF_LITE_ENSURE_EQ(context, input_resource_id_tensor->type, kTfLiteInt32);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input_resource_id_tensor), 1);\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(input_resource_id_tensor, 0), 1);\n  TfLiteTensor* output_tensor = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output_tensor != nullptr);\n  TF_LITE_ENSURE_EQ(context, output_tensor->type, kTfLiteInt64);\n  TfLiteIntArray* outputSize = TfLiteIntArrayCreate(1);\n  outputSize->data[0] = 1;\n  return context->ResizeTensor(context, output_tensor, outputSize);\n}", "target": 1}
{"code": "static void __return_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq->tg);\n\ts64 slack_runtime = cfs_rq->runtime_remaining - min_cfs_rq_runtime;\n\tif (slack_runtime <= 0)\n\t\treturn;\n\traw_spin_lock(&cfs_b->lock);\n\tif (cfs_b->quota != RUNTIME_INF &&\n\t    cfs_rq->runtime_expires == cfs_b->runtime_expires) {\n\t\tcfs_b->runtime += slack_runtime;\n\t\tif (cfs_b->runtime > sched_cfs_bandwidth_slice() &&\n\t\t    !list_empty(&cfs_b->throttled_cfs_rq))\n\t\t\tstart_cfs_slack_bandwidth(cfs_b);\n\t}\n\traw_spin_unlock(&cfs_b->lock);\n\tcfs_rq->runtime_remaining -= slack_runtime;\n}", "target": 1}
{"code": "psf_fwrite (const void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)\n{\tsf_count_t total = 0 ;\n\tssize_t\tcount ;\n\tif (bytes == 0 || items == 0)\n\t\treturn 0 ;\n\tif (psf->virtual_io)\n\t\treturn psf->vio.write (ptr, bytes*items, psf->vio_user_data) / bytes ;\n\titems *= bytes ;\n\tif (items <= 0)\n\t\treturn 0 ;\n\twhile (items > 0)\n\t{\t\n\t\tcount = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : items ;\n\t\tcount = write (psf->file.filedes, ((const char*) ptr) + total, count) ;\n\t\tif (count == -1)\n\t\t{\tif (errno == EINTR)\n\t\t\t\tcontinue ;\n\t\t\tpsf_log_syserr (psf, errno) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\t\tif (count == 0)\n\t\t\tbreak ;\n\t\ttotal += count ;\n\t\titems -= count ;\n\t\t} ;\n\tif (psf->is_pipe)\n\t\tpsf->pipeoffset += total ;\n\treturn total / bytes ;\n} ", "target": 0}
{"code": "int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)\n{\n\tflush_fp_to_thread(src);\n\tflush_altivec_to_thread(src);\n\tflush_vsx_to_thread(src);\n\tflush_spe_to_thread(src);\n\t__switch_to_tm(src);\n\ttm_recheckpoint_new_task(src);\n\t*dst = *src;\n\tclear_task_ebb(dst);\n\treturn 0;\n}", "target": 0}
{"code": "static void sas_revalidate_domain(struct work_struct *work)\n{\n\tint res = 0;\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev->port;\n\tstruct sas_ha_struct *ha = port->ha;\n\tstruct domain_device *ddev = port->port_dev;\n\tmutex_lock(&ha->disco_mutex);\n\tif (test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state)) {\n\t\tSAS_DPRINTK(\"REVALIDATION DEFERRED on port %d, pid:%d\\n\",\n\t\t\t    port->id, task_pid_nr(current));\n\t\tgoto out;\n\t}\n\tclear_bit(DISCE_REVALIDATE_DOMAIN, &port->disc.pending);\n\tSAS_DPRINTK(\"REVALIDATING DOMAIN on port %d, pid:%d\\n\", port->id,\n\t\t    task_pid_nr(current));\n\tif (ddev && (ddev->dev_type == SAS_FANOUT_EXPANDER_DEVICE ||\n\t\t     ddev->dev_type == SAS_EDGE_EXPANDER_DEVICE))\n\t\tres = sas_ex_revalidate_domain(ddev);\n\tSAS_DPRINTK(\"done REVALIDATING DOMAIN on port %d, pid:%d, res 0x%x\\n\",\n\t\t    port->id, task_pid_nr(current), res);\n out:\n\tmutex_unlock(&ha->disco_mutex);\n\tsas_destruct_devices(port);\n\tsas_destruct_ports(port);\n\tsas_probe_devices(port);\n}", "target": 0}
{"code": "static void ide_atapi_cmd_read(IDEState *s, int lba, int nb_sectors,\n                               int sector_size)\n{\n#ifdef DEBUG_IDE_ATAPI\n    printf(\"read %s: LBA=%d nb_sectors=%d\\n\", s->atapi_dma ? \"dma\" : \"pio\",\n        lba, nb_sectors);\n#endif\n    if (s->atapi_dma) {\n        ide_atapi_cmd_read_dma(s, lba, nb_sectors, sector_size);\n    } else {\n        ide_atapi_cmd_read_pio(s, lba, nb_sectors, sector_size);\n    }\n}", "target": 0}
{"code": "archive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n\t(void)mode;\t\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_ACCESS) != 0) {\n\t\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_ACCESS, \"access\");\n\t\t\tif (ret != ARCHIVE_OK)\n\t\t\t\treturn (ret);\n\t\t}\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_DEFAULT) != 0)\n\t\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT, \"default\");\n\t\treturn (ret);\n\t}\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\telse if ((archive_acl_types(abstract_acl) &\n\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n\t}\n#endif\n\treturn (ret);\n}", "target": 1}
{"code": "\tvirtual size_t\tRead(void *buffer, size_t size, size_t count)\n\t{\n\t\tif (!m_fp) return 0;\n\t\treturn fread(buffer, size, count, m_fp);\n\t}", "target": 1}
{"code": "static void xen_irq_init(unsigned irq)\n{\n\tstruct irq_info *info;\n#ifdef CONFIG_SMP\n\tcpumask_copy(irq_get_affinity_mask(irq), cpumask_of(0));\n#endif\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (info == NULL)\n\t\tpanic(\"Unable to allocate metadata for IRQ%d\\n\", irq);\n\tinfo->type = IRQT_UNBOUND;\n\tinfo->refcnt = -1;\n\tset_info_for_irq(irq, info);\n\tINIT_LIST_HEAD(&info->eoi_list);\n\tlist_add_tail(&info->list, &xen_irq_list_head);\n}", "target": 0}
{"code": "AtomicString SrcSchemeToURL(TestURLScheme scheme) {\n  switch (scheme) {\n    case TestURLScheme::kHttp:\n      return \"http:\n    case TestURLScheme::kHttps:\n      return \"https:\n    case TestURLScheme::kFtp:\n      return \"ftp:\n    case TestURLScheme::kFile:\n      return \"file:\n    case TestURLScheme::kData:\n      return \"data:video/mp4;base64,XXXXXXX\";\n    case TestURLScheme::kBlob:\n      return \"blob:http:\n    default:\n      NOTREACHED();\n  }\n  return g_empty_atom;\n}", "target": 0}
{"code": "bool LinksToDirs(const wchar *SrcName,const wchar *SkipPart,std::wstring &LastChecked)\n{\n  wchar Path[NM];\n  if (wcslen(SrcName)>=ASIZE(Path))\n    return false;  \n  wcsncpyz(Path,SrcName,ASIZE(Path));\n  size_t SkipLength=wcslen(SkipPart);\n  if (SkipLength>0 && wcsncmp(Path,SkipPart,SkipLength)!=0)\n    SkipLength=0; \n  for (uint I=0;Path[I]!=0 && I<LastChecked.size() && Path[I]==LastChecked[I];I++)\n    if (IsPathDiv(Path[I]) && I>SkipLength)\n      SkipLength=I;\n  wchar *Name=Path;\n  if (SkipLength>0)\n  {\n    Name+=SkipLength;\n    while (IsPathDiv(*Name))\n      Name++;\n  }\n  for (wchar *s=Path+wcslen(Path)-1;s>Name;s--)\n    if (IsPathDiv(*s))\n    {\n      *s=0;\n      FindData FD;\n      if (FindFile::FastFind(Path,&FD,true) && FD.IsLink)\n#ifdef _WIN_ALL\n        if (!DelDir(Path))\n#else\n        if (!DelFile(Path))\n#endif\n          return false; \n    }\n  LastChecked=SrcName;\n  return true;\n}", "target": 0}
{"code": "Http::FilterDataStatus Context::onRequestBody(int body_buffer_length, bool end_of_stream) {\n  if (!wasm_->onRequestBody_) {\n    return Http::FilterDataStatus::Continue;\n  }\n  switch (wasm_\n              ->onRequestBody_(this, id_, static_cast<uint32_t>(body_buffer_length),\n                               static_cast<uint32_t>(end_of_stream))\n              .u64_) {\n  case 0:\n    return Http::FilterDataStatus::Continue;\n  case 1:\n    return Http::FilterDataStatus::StopIterationAndBuffer;\n  case 2:\n    return Http::FilterDataStatus::StopIterationAndWatermark;\n  default:\n    return Http::FilterDataStatus::StopIterationNoBuffer;\n  }\n}", "target": 1}
{"code": "static uint32_t generate_seed() {\n    uint32_t seed;\n    int done = 0;\n#if !defined(_WIN32) && defined(USE_URANDOM)\n    if (!done && seed_from_urandom(&seed) == 0)\n        done = 1;\n#endif\n#if defined(_WIN32) && defined(USE_WINDOWS_CRYPTOAPI)\n    if (!done && seed_from_windows_cryptoapi(&seed) == 0)\n        done = 1;\n#endif\n    if (!done) {\n        seed_from_timestamp_and_pid(&seed);\n    }\n    if (seed == 0)\n        seed = 1;\n    return seed;\n}", "target": 0}
{"code": "static struct dump_dir *open_directory_for_modification_of_element(\n    GDBusMethodInvocation *invocation,\n    uid_t caller_uid,\n    const char *problem_id,\n    const char *element)\n{\n    static const char *const protected_elements[] = {\n        FILENAME_TIME,\n        FILENAME_UID,\n        NULL,\n    };\n    for (const char *const *protected = protected_elements; *protected; ++protected)\n    {\n        if (strcmp(*protected, element) == 0)\n        {\n            log_notice(\"'%s' element of '%s' can't be modified\", element, problem_id);\n            char *error = xasprintf(_(\"'%s' element can't be modified\"), element);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                        \"org.freedesktop.problems.ProtectedElement\",\n                                        error);\n            free(error);\n            return NULL;\n        }\n    }\n    if (!dump_dir_accessible_by_uid(problem_id, caller_uid))\n    {\n        if (errno == ENOTDIR)\n        {\n            log_notice(\"'%s' is not a valid problem directory\", problem_id);\n            return_InvalidProblemDir_error(invocation, problem_id);\n        }\n        else\n        {\n            log_notice(\"UID(%d) is not Authorized to access '%s'\", caller_uid, problem_id);\n            g_dbus_method_invocation_return_dbus_error(invocation,\n                                \"org.freedesktop.problems.AuthFailure\",\n                                _(\"Not Authorized\"));\n        }\n        return NULL;\n    }\n    struct dump_dir *dd = dd_opendir(problem_id,  0);\n    if (!dd)\n    {   \n        log_notice(\"Can't access the problem '%s' for modification\", problem_id);\n        g_dbus_method_invocation_return_dbus_error(invocation,\n                                \"org.freedesktop.problems.Failure\",\n                                _(\"Can't access the problem for modification\"));\n        return NULL;\n    }\n    return dd;\n}", "target": 1}
{"code": "smb_ofile_flush(struct smb_request *sr, struct smb_ofile *of)\n{\n\tswitch (of->f_ftype) {\n\tcase SMB_FTYPE_DISK:\n\t\tif ((of->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n\t\t\t(void) smb_fsop_commit(sr, of->f_cr, of->f_node);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "void Context::onDone() {\n  if (wasm_->onDone_) {\n    wasm_->onDone_(this, id_);\n  }\n}", "target": 1}
{"code": "static inline int dpt_dma64(adpt_hba *pHba)\n{\n\treturn (sizeof(dma_addr_t) > 4 && (pHba)->dma64);\n}", "target": 1}
{"code": "    CImg<T>& RGBtoYUV() {\n      if (_spectrum!=3)\n        throw CImgInstanceException(_cimg_instance\n                                    \"RGBtoYUV(): Instance is not a RGB image.\",\n                                    cimg_instance);\n      T *p1 = data(0,0,0,0), *p2 = data(0,0,0,1), *p3 = data(0,0,0,2);\n      const ulongT whd = (ulongT)_width*_height*_depth;\n      cimg_pragma_openmp(parallel for cimg_openmp_if(whd>=16384))\n      for (ulongT N = 0; N<whd; ++N) {\n        const Tfloat\n          R = (Tfloat)p1[N]/255,\n          G = (Tfloat)p2[N]/255,\n          B = (Tfloat)p3[N]/255,\n          Y = 0.299f*R + 0.587f*G + 0.114f*B;\n        p1[N] = (T)Y;\n        p2[N] = (T)(0.492f*(B - Y));\n        p3[N] = (T)(0.877*(R - Y));\n      }\n      return *this;", "target": 0}
{"code": "socks_request_free(socks_request_t *req)\n{\n  if (!req)\n    return;\n  if (req->username) {\n    memwipe(req->username, 0x10, req->usernamelen);\n    tor_free(req->username);\n  }\n  if (req->password) {\n    memwipe(req->password, 0x04, req->passwordlen);\n    tor_free(req->password);\n  }\n  memwipe(req, 0xCC, sizeof(socks_request_t));\n  tor_free(req);\n}", "target": 0}
{"code": "static void tiny_dispatch(const MessagesMap_t *entry, uint8_t *msg, uint32_t msg_size)\n{\n    if (!pb_parse(entry, msg, msg_size, msg_tiny)) {\n        call_msg_failure_handler(FailureType_Failure_UnexpectedMessage,\n                                 \"Could not parse tiny protocol buffer message\");\n        return;\n    }\n    msg_tiny_id = entry->msg_id;\n}", "target": 1}
{"code": "CodingReturnValue LeptonCodec::ThreadState::vp8_decode_thread(unsigned int thread_id,\n                                                              UncompressedComponents *const colldata) {\n    Sirikata::Array1d<uint32_t, (uint32_t)ColorChannel::NumBlockTypes> component_size_in_blocks;\n    BlockBasedImagePerChannel<false> image_data;\n    for (int i = 0; i < colldata->get_num_components(); ++i) {\n        component_size_in_blocks[i] = colldata->component_size_in_blocks(i);\n        image_data[i] = &colldata->full_component_write((BlockType)i);\n    }\n    Sirikata::Array1d<uint32_t,\n                      (size_t)ColorChannel::NumBlockTypes> max_coded_heights\n        = colldata->get_max_coded_heights();\n    dev_assert(luma_splits_.size() == 2); \n    always_assert(luma_splits_.size() >= 2);\n    int min_y = luma_splits_[0];\n    int max_y = luma_splits_[1];\n    while(true) {\n        RowSpec cur_row = row_spec_from_index(decode_index_++, image_data, colldata->get_mcu_count_vertical(), max_coded_heights);\n        if (cur_row.done) {\n            break;\n        }\n        if (cur_row.luma_y >= max_y && thread_id + 1 != NUM_THREADS) {\n            break;\n        }\n        if (cur_row.skip) {\n            continue;\n        }\n        if (cur_row.luma_y < min_y) {\n            continue;\n        }\n        decode_rowf(image_data,\n                   component_size_in_blocks,\n                   cur_row.component,\n                   cur_row.curr_y);\n        if (thread_id == 0) {\n            colldata->worker_update_cmp_progress((BlockType)cur_row.component,\n                                                 image_data[cur_row.component]->block_width() );\n        }\n        return CODING_PARTIAL;\n    }\n    return CODING_DONE;\n}", "target": 0}
{"code": "static void settings_changed(struct btd_adapter *adapter, uint32_t settings)\n{\n\tuint32_t changed_mask;\n\tchanged_mask = adapter->current_settings ^ settings;\n\tadapter->current_settings = settings;\n\tadapter->pending_settings &= ~changed_mask;\n\tDBG(\"Changed settings: 0x%08x\", changed_mask);\n\tDBG(\"Pending settings: 0x%08x\", adapter->pending_settings);\n\tif (changed_mask & MGMT_SETTING_POWERED) {\n\t        g_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Powered\");\n\t\tif (adapter->current_settings & MGMT_SETTING_POWERED) {\n\t\t\tadapter_start(adapter);\n\t\t} else {\n\t\t\tadapter_stop(adapter);\n\t\t\tif (powering_down) {\n\t\t\t\tadapter_remaining--;\n\t\t\t\tif (!adapter_remaining)\n\t\t\t\t\tbtd_exit();\n\t\t\t}\n\t\t}\n\t}\n\tif ((changed_mask & MGMT_SETTING_LE) &&\n\t\t\t\tbtd_adapter_get_powered(adapter) &&\n\t\t\t\t(adapter->current_settings & MGMT_SETTING_LE))\n\t\ttrigger_passive_scanning(adapter);\n\tif (changed_mask & MGMT_SETTING_DISCOVERABLE) {\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Discoverable\");\n\t\tstore_adapter_info(adapter);\n\t\tbtd_adv_manager_refresh(adapter->adv_manager);\n\t}\n\tif (changed_mask & MGMT_SETTING_BONDABLE) {\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Pairable\");\n\t\ttrigger_pairable_timeout(adapter);\n\t}\n}", "target": 1}
{"code": "Adaptation::Ecap::FirstLineRep::protocol() const\n{\n    switch (theMessage.http_ver.protocol) {\n    case AnyP::PROTO_HTTP:\n        return libecap::protocolHttp;\n    case AnyP::PROTO_HTTPS:\n        return libecap::protocolHttps;\n    case AnyP::PROTO_FTP:\n        return libecap::protocolFtp;\n    case AnyP::PROTO_GOPHER:\n        return libecap::protocolGopher;\n    case AnyP::PROTO_WAIS:\n        return libecap::protocolWais;\n    case AnyP::PROTO_WHOIS:\n        return libecap::protocolWhois;\n    case AnyP::PROTO_URN:\n        return libecap::protocolUrn;\n    case AnyP::PROTO_ICP:\n        return protocolIcp;\n#if USE_HTCP\n    case AnyP::PROTO_HTCP:\n        return protocolHtcp;\n#endif\n    case AnyP::PROTO_CACHE_OBJECT:\n        return protocolCacheObj;\n    case AnyP::PROTO_ICY:\n        return protocolIcy;\n    case AnyP::PROTO_COAP:\n    case AnyP::PROTO_COAPS: \n    case AnyP::PROTO_AUTHORITY_FORM:\n    case AnyP::PROTO_SSL:\n    case AnyP::PROTO_TLS:\n    case AnyP::PROTO_UNKNOWN:\n        return protocolUnknown; \n    case AnyP::PROTO_NONE:\n        return Name();\n    case AnyP::PROTO_MAX:\n        break; \n    }\n    Must(false); \n    return Name();\n}", "target": 1}
{"code": "static void __evtchn_fifo_handle_events(unsigned cpu, bool drop)\n{\n\tstruct evtchn_fifo_control_block *control_block;\n\tunsigned long ready;\n\tunsigned q;\n\tcontrol_block = per_cpu(cpu_control_block, cpu);\n\tready = xchg(&control_block->ready, 0);\n\twhile (ready) {\n\t\tq = find_first_bit(&ready, EVTCHN_FIFO_MAX_QUEUES);\n\t\tconsume_one_event(cpu, control_block, q, &ready, drop);\n\t\tready |= xchg(&control_block->ready, 0);\n\t}\n}", "target": 1}
{"code": "static void kvmclock_reset(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.time_page) {\n\t\tkvm_release_page_dirty(vcpu->arch.time_page);\n\t\tvcpu->arch.time_page = NULL;\n\t}\n}", "target": 1}
{"code": "irc_server_reconnect_schedule (struct t_irc_server *server)\n{\n    int minutes, seconds;\n    if (IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_AUTORECONNECT))\n    {\n        if (server->reconnect_delay == 0)\n            server->reconnect_delay = IRC_SERVER_OPTION_INTEGER(server, IRC_SERVER_OPTION_AUTORECONNECT_DELAY);\n        else\n            server->reconnect_delay = server->reconnect_delay * weechat_config_integer (irc_config_network_autoreconnect_delay_growing);\n        if ((weechat_config_integer (irc_config_network_autoreconnect_delay_max) > 0)\n            && (server->reconnect_delay > weechat_config_integer (irc_config_network_autoreconnect_delay_max)))\n            server->reconnect_delay = weechat_config_integer (irc_config_network_autoreconnect_delay_max);\n        server->reconnect_start = time (NULL);\n        minutes = server->reconnect_delay / 60;\n        seconds = server->reconnect_delay % 60;\n        if ((minutes > 0) && (seconds > 0))\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: reconnecting to server in %d %s, %d %s\"),\n                weechat_prefix (\"network\"),\n                IRC_PLUGIN_NAME,\n                minutes,\n                NG_(\"minute\", \"minutes\", minutes),\n                seconds,\n                NG_(\"second\", \"seconds\", seconds));\n        }\n        else if (minutes > 0)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: reconnecting to server in %d %s\"),\n                weechat_prefix (\"network\"),\n                IRC_PLUGIN_NAME,\n                minutes,\n                NG_(\"minute\", \"minutes\", minutes));\n        }\n        else\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: reconnecting to server in %d %s\"),\n                weechat_prefix (\"network\"),\n                IRC_PLUGIN_NAME,\n                seconds,\n                NG_(\"second\", \"seconds\", seconds));\n        }\n    }\n    else\n    {\n        server->reconnect_delay = 0;\n        server->reconnect_start = 0;\n    }\n}", "target": 0}
{"code": "int khugepaged_enter_vma_merge(struct vm_area_struct *vma)\n{\n\tunsigned long hstart, hend;\n\tif (!vma->anon_vma)\n\t\treturn 0;\n\tif (vma->vm_file || vma->vm_ops)\n\t\treturn 0;\n\tVM_BUG_ON(is_linear_pfn_mapping(vma) || is_pfn_mapping(vma));\n\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n\thend = vma->vm_end & HPAGE_PMD_MASK;\n\tif (hstart < hend)\n\t\treturn khugepaged_enter(vma);\n\treturn 0;\n}", "target": 1}
{"code": "init_resources(X509 *x509, enum rpki_policy policy, enum cert_type type,\n    struct resources **_result)\n{\n\tstruct resources *result;\n\tint error;\n\tresult = resources_create(false);\n\tif (result == NULL)\n\t\treturn pr_enomem();\n\tresources_set_policy(result, policy);\n\terror = certificate_get_resources(x509, result, type);\n\tif (error)\n\t\tgoto fail;\n\tif (type == TA && resources_empty(result)) {\n\t\terror = pr_val_err(\"Trust Anchor certificate does not define any number resources.\");\n\t\tgoto fail;\n\t}\n\t*_result = result;\n\treturn 0;\nfail:\n\tresources_destroy(result);\n\treturn error;\n}", "target": 0}
{"code": "static enum count_type __read_io_type(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tif (mapping) {\n\t\tstruct inode *inode = mapping->host;\n\t\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\t\tif (inode->i_ino == F2FS_META_INO(sbi))\n\t\t\treturn F2FS_RD_META;\n\t\tif (inode->i_ino == F2FS_NODE_INO(sbi))\n\t\t\treturn F2FS_RD_NODE;\n\t}\n\treturn F2FS_RD_DATA;\n}", "target": 1}
{"code": "static int llcp_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tstruct nfc_llcp_local *local;\n\tstruct nfc_dev *dev;\n\tstruct sockaddr_nfc_llcp llcp_addr;\n\tint len, ret = 0;\n\tif (!addr || addr->sa_family != AF_NFC)\n\t\treturn -EINVAL;\n\tpr_debug(\"sk %p addr %p family %d\\n\", sk, addr, addr->sa_family);\n\tmemset(&llcp_addr, 0, sizeof(llcp_addr));\n\tlen = min_t(unsigned int, sizeof(llcp_addr), alen);\n\tmemcpy(&llcp_addr, addr, len);\n\tif (llcp_addr.dsap != 0)\n\t\treturn -EINVAL;\n\tlock_sock(sk);\n\tif (sk->sk_state != LLCP_CLOSED) {\n\t\tret = -EBADFD;\n\t\tgoto error;\n\t}\n\tdev = nfc_get_device(llcp_addr.dev_idx);\n\tif (dev == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto put_dev;\n\t}\n\tllcp_sock->dev = dev;\n\tllcp_sock->local = nfc_llcp_local_get(local);\n\tllcp_sock->nfc_protocol = llcp_addr.nfc_protocol;\n\tllcp_sock->service_name_len = min_t(unsigned int,\n\t\t\t\t\t    llcp_addr.service_name_len,\n\t\t\t\t\t    NFC_LLCP_MAX_SERVICE_NAME);\n\tllcp_sock->service_name = kmemdup(llcp_addr.service_name,\n\t\t\t\t\t  llcp_sock->service_name_len,\n\t\t\t\t\t  GFP_KERNEL);\n\tllcp_sock->ssap = nfc_llcp_get_sdp_ssap(local, llcp_sock);\n\tif (llcp_sock->ssap == LLCP_SAP_MAX) {\n\t\tret = -EADDRINUSE;\n\t\tgoto put_dev;\n\t}\n\tllcp_sock->reserved_ssap = llcp_sock->ssap;\n\tnfc_llcp_sock_link(&local->sockets, sk);\n\tpr_debug(\"Socket bound to SAP %d\\n\", llcp_sock->ssap);\n\tsk->sk_state = LLCP_BOUND;\nput_dev:\n\tnfc_put_device(dev);\nerror:\n\trelease_sock(sk);\n\treturn ret;\n}", "target": 0}
{"code": "next_state_class(CClassNode* cc, OnigCodePoint* vs, enum CCVALTYPE* type,\n\t\t enum CCSTATE* state, ScanEnv* env)\n{\n  int r;\n  if (*state == CCS_RANGE)\n    return ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE;\n  if (*state == CCS_VALUE && *type != CCV_CLASS) {\n    if (*type == CCV_SB)\n      BITSET_SET_BIT(cc->bs, (int )(*vs));\n    else if (*type == CCV_CODE_POINT) {\n      r = add_code_range(&(cc->mbuf), env, *vs, *vs);\n      if (r < 0) return r;\n    }\n  }\n  *state = CCS_VALUE;\n  *type  = CCV_CLASS;\n  return 0;\n}", "target": 1}
{"code": "updateDevice(const struct header * headers, time_t t)\n{\n\tstruct device ** pp = &devlist;\n\tstruct device * p = *pp;\t\n\twhile(p)\n\t{\n\t\tif(  p->headers[HEADER_NT].l == headers[HEADER_NT].l\n\t\t  && (0==memcmp(p->headers[HEADER_NT].p, headers[HEADER_NT].p, headers[HEADER_NT].l))\n\t\t  && p->headers[HEADER_USN].l == headers[HEADER_USN].l\n\t\t  && (0==memcmp(p->headers[HEADER_USN].p, headers[HEADER_USN].p, headers[HEADER_USN].l)) )\n\t\t{\n\t\t\tsyslog(LOG_DEBUG, \"device updated : %.*s\", headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t\t\tp->t = t;\n\t\t\tif(headers[HEADER_LOCATION].l > p->headers[HEADER_LOCATION].l)\n\t\t\t{\n\t\t\t\tstruct device * tmp;\n\t\t\t\ttmp = realloc(p, sizeof(struct device)\n\t\t\t\t    + headers[0].l+headers[1].l+headers[2].l);\n\t\t\t\tif(!tmp)\t\n\t\t\t\t{\n\t\t\t\t\tsyslog(LOG_ERR, \"updateDevice() : memory allocation error\");\n\t\t\t\t\t*pp = p->next;\t\n\t\t\t\t\tfree(p);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tp = tmp;\n\t\t\t\t*pp = p;\n\t\t\t}\n\t\t\tmemcpy(p->data + p->headers[0].l + p->headers[1].l,\n\t\t\t       headers[2].p, headers[2].l);\n\t\t\treturn 0;\n\t\t}\n\t\tpp = &p->next;\n\t\tp = *pp;\t\n\t}\n\tsyslog(LOG_INFO, \"new device discovered : %.*s\",\n\t       headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t{\n\t\tchar * pc;\n\t\tint i;\n\t\tp = malloc(  sizeof(struct device)\n\t\t           + headers[0].l+headers[1].l+headers[2].l );\n\t\tif(!p) {\n\t\t\tsyslog(LOG_ERR, \"updateDevice(): cannot allocate memory\");\n\t\t\treturn -1;\n\t\t}\n\t\tp->next = devlist;\n\t\tp->t = t;\n\t\tpc = p->data;\n\t\tfor(i = 0; i < 3; i++)\n\t\t{\n\t\t\tp->headers[i].p = pc;\n\t\t\tp->headers[i].l = headers[i].l;\n\t\t\tmemcpy(pc, headers[i].p, headers[i].l);\n\t\t\tpc += headers[i].l;\n\t\t}\n\t\tdevlist = p;\n\t\tsendNotifications(NOTIF_NEW, p, NULL);\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "int read_super_2(squashfs_operations **s_ops, void *s)\n{\n\t squashfs_super_block_3 *sBlk_3 = s;\n\tif(sBlk_3->s_magic != SQUASHFS_MAGIC || sBlk_3->s_major != 2 ||\n\t\t\t\t\t\t\tsBlk_3->s_minor > 1)\n\t\treturn -1;\n\tsBlk.s.s_magic = sBlk_3->s_magic;\n\tsBlk.s.inodes = sBlk_3->inodes;\n\tsBlk.s.mkfs_time = sBlk_3->mkfs_time;\n\tsBlk.s.block_size = sBlk_3->block_size;\n\tsBlk.s.fragments = sBlk_3->fragments;\n\tsBlk.s.block_log = sBlk_3->block_log;\n\tsBlk.s.flags = sBlk_3->flags;\n\tsBlk.s.s_major = sBlk_3->s_major;\n\tsBlk.s.s_minor = sBlk_3->s_minor;\n\tsBlk.s.root_inode = sBlk_3->root_inode;\n\tsBlk.s.bytes_used = sBlk_3->bytes_used_2;\n\tsBlk.s.inode_table_start = sBlk_3->inode_table_start;\n\tsBlk.s.directory_table_start = sBlk_3->directory_table_start_2;\n\tsBlk.s.fragment_table_start = sBlk_3->fragment_table_start_2;\n\tsBlk.s.inode_table_start = sBlk_3->inode_table_start_2;\n\tsBlk.no_uids = sBlk_3->no_uids;\n\tsBlk.no_guids = sBlk_3->no_guids;\n\tsBlk.uid_start = sBlk_3->uid_start_2;\n\tsBlk.guid_start = sBlk_3->guid_start_2;\n\tsBlk.s.xattr_id_table_start = SQUASHFS_INVALID_BLK;\n\t*s_ops = &ops;\n\tcomp = lookup_compressor(\"gzip\");\n\tif(sBlk_3->s_minor == 0)\n\t\tneeds_sorting = TRUE;\n\treturn TRUE;\n}", "target": 0}
{"code": "GF_Box *mp4s_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_MP4S);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\ttmp->internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S;\n\treturn (GF_Box *)tmp;\n}", "target": 1}
{"code": "inline Result ClientImpl::Delete(const std::string &path,\n                                 const Headers &headers, const char *body,\n                                 size_t content_length,\n                                 const std::string &content_type) {\n  Request req;\n  req.method = \"DELETE\";\n  req.headers = headers;\n  req.path = path;\n  if (!content_type.empty()) {\n    req.headers.emplace(\"Content-Type\", content_type);\n  }\n  req.body.assign(body, content_length);\n  return send_(std::move(req));\n}", "target": 1}
{"code": "static void *create_core_server_config(apr_pool_t *a, server_rec *s)\n{\n    core_server_config *conf;\n    int is_virtual = s->is_virtual;\n    conf = (core_server_config *)apr_pcalloc(a, sizeof(core_server_config));\n    if (!is_virtual) {\n        conf->ap_document_root = DOCUMENT_LOCATION;\n        conf->access_name = DEFAULT_ACCESS_FNAME;\n        conf->accf_map = apr_table_make(a, 5);\n#if APR_HAS_SO_ACCEPTFILTER\n        apr_table_setn(conf->accf_map, \"http\", ACCEPT_FILTER_NAME);\n        apr_table_setn(conf->accf_map, \"https\", \"dataready\");\n#elif defined(WIN32)\n        apr_table_setn(conf->accf_map, \"http\", \"connect\");\n        apr_table_setn(conf->accf_map, \"https\", \"connect\");\n#else\n        apr_table_setn(conf->accf_map, \"http\", \"data\");\n        apr_table_setn(conf->accf_map, \"https\", \"data\");\n#endif\n        conf->flush_max_threshold = AP_FLUSH_MAX_THRESHOLD;\n        conf->flush_max_pipelined = AP_FLUSH_MAX_PIPELINED;\n    }\n    else {\n        conf->flush_max_pipelined = -1;\n    }\n    conf->sec_dir = apr_array_make(a, 40, sizeof(ap_conf_vector_t *));\n    conf->sec_url = apr_array_make(a, 40, sizeof(ap_conf_vector_t *));\n    conf->trace_enable = AP_TRACE_UNSET;\n    conf->protocols = apr_array_make(a, 5, sizeof(const char *));\n    conf->protocols_honor_order = -1;\n    conf->merge_slashes = AP_CORE_CONFIG_UNSET; \n    conf->strict_host_check= AP_CORE_CONFIG_UNSET; \n    return (void *)conf;\n}", "target": 0}
{"code": "static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,\n                             uint32_t length)\n{\n    int v, i;\n    if (s->color_type == PNG_COLOR_TYPE_PALETTE) {\n        if (length > 256 || !(s->state & PNG_PLTE))\n            return AVERROR_INVALIDDATA;\n        for (i = 0; i < length; i++) {\n            v = bytestream2_get_byte(&s->gb);\n            s->palette[i] = (s->palette[i] & 0x00ffffff) | (v << 24);\n        }\n    } else if (s->color_type == PNG_COLOR_TYPE_GRAY || s->color_type == PNG_COLOR_TYPE_RGB) {\n        if ((s->color_type == PNG_COLOR_TYPE_GRAY && length != 2) ||\n            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6))\n            return AVERROR_INVALIDDATA;\n        for (i = 0; i < length / 2; i++) {\n            v = av_mod_uintp2(bytestream2_get_be16(&s->gb), s->bit_depth);\n            if (s->bit_depth > 8)\n                AV_WB16(&s->transparent_color_be[2 * i], v);\n            else\n                s->transparent_color_be[i] = v;\n        }\n    } else {\n        return AVERROR_INVALIDDATA;\n    }\n    bytestream2_skip(&s->gb, 4); \n    s->has_trns = 1;\n    return 0;\n}", "target": 1}
{"code": "static void Sp_search(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tResub m;\n\ttext = checkstring(J, 0);\n\tif (js_isregexp(J, 1))\n\t\tjs_copy(J, 1);\n\telse if (js_isundefined(J, 1))\n\t\tjs_newregexp(J, \"\", 0);\n\telse\n\t\tjs_newregexp(J, js_tostring(J, 1), 0);\n\tre = js_toregexp(J, -1);\n\tif (!js_regexec(re->prog, text, &m, 0))\n\t\tjs_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));\n\telse\n\t\tjs_pushnumber(J, -1);\n}", "target": 1}
{"code": "static inline int udp4_csum_init(struct sk_buff *skb, struct udphdr *uh,\n\t\t\t\t int proto)\n{\n\tint err;\n\tUDP_SKB_CB(skb)->partial_cov = 0;\n\tUDP_SKB_CB(skb)->cscov = skb->len;\n\tif (proto == IPPROTO_UDPLITE) {\n\t\terr = udplite_checksum_init(skb, uh);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn skb_checksum_init_zero_check(skb, proto, uh->check,\n\t\t\t\t\t    inet_compute_pseudo);\n}", "target": 0}
{"code": "static void free_user(struct kref *ref)\n{\n\tstruct ipmi_user *user = container_of(ref, struct ipmi_user, refcount);\n\tcleanup_srcu_struct(&user->release_barrier);\n\tkfree(user);\n}", "target": 0}
{"code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInput);\n  const TfLiteTensor* input_state = GetInput(context, node, kInputState);\n  const TfLiteTensor* gate_weight = GetInput(context, node, kGateWeight);\n  const TfLiteTensor* gate_bias = GetInput(context, node, kGateBias);\n  const TfLiteTensor* candidate_weight =\n      GetInput(context, node, kCandidateWeight);\n  const TfLiteTensor* candidate_bias = GetInput(context, node, kCandidateBias);\n  TfLiteTensor* output = GetOutput(context, node, kOutput);\n  TfLiteTensor* output_state = GetOutput(context, node, kOutputState);\n  TfLiteTensor* activation = GetTemporary(context, node, kActivation);\n  TfLiteTensor* concat = GetTemporary(context, node, kConcat);\n  auto cpu_backend_context = CpuBackendContext::GetFromContext(context);\n  if (gate_weight->type == kTfLiteFloat32) {\n    GruImpl(input, input_state, gate_weight, gate_bias, candidate_weight,\n            candidate_bias, output, output_state, activation, concat,\n            cpu_backend_context);\n  } else {\n    context->ReportError(context,\n                         \"Unsupported combination of data types for GruCell\");\n    return kTfLiteError;\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static void copy_to_user_policy(struct xfrm_policy *xp, struct xfrm_userpolicy_info *p, int dir)\n{\n\tmemset(p, 0, sizeof(*p));\n\tmemcpy(&p->sel, &xp->selector, sizeof(p->sel));\n\tmemcpy(&p->lft, &xp->lft, sizeof(p->lft));\n\tmemcpy(&p->curlft, &xp->curlft, sizeof(p->curlft));\n\tp->priority = xp->priority;\n\tp->index = xp->index;\n\tp->sel.family = xp->family;\n\tp->dir = dir;\n\tp->action = xp->action;\n\tp->flags = xp->flags;\n\tp->share = XFRM_SHARE_ANY; \n}", "target": 0}
{"code": "  absl::Status IsSupported(const TfLiteContext* context,\n                           const TfLiteNode* tflite_node,\n                           const TfLiteRegistration* registration) final {\n    if (mirror_pad_) {\n      const TfLiteMirrorPaddingParams* tf_options;\n      RETURN_IF_ERROR(RetrieveBuiltinData(tflite_node, &tf_options));\n      if (tf_options->mode !=\n          TfLiteMirrorPaddingMode::kTfLiteMirrorPaddingReflect) {\n        return absl::InvalidArgumentError(\n            \"Only Reflective padding is supported for Mirror Pad operation.\");\n      }\n    }\n    RETURN_IF_ERROR(CheckMaxSupportedOpVersion(registration, 2));\n    RETURN_IF_ERROR(CheckInputsOutputs(context, tflite_node,\n                                       1, 1));\n    RETURN_IF_ERROR(CheckTensorIsAvailable(context, tflite_node, 1));\n    auto pad_tensor = tflite::GetInput(context, tflite_node, 1);\n    if (pad_tensor->dims->size != 2) {\n      return absl::InvalidArgumentError(absl::StrCat(\n          \"Invalid paddings tensor dimension: expected 2 dim, got \",\n          pad_tensor->dims->size, \" dim\"));\n    }\n    bool supported =\n        pad_tensor->dims->data[0] == 3 || pad_tensor->dims->data[0] == 4;\n    if (!supported || pad_tensor->dims->data[1] != 2) {\n      return absl::InvalidArgumentError(absl::StrCat(\n          \"Invalid paddings tensor shape: expected 4x2 or 3x2, got \",\n          pad_tensor->dims->data[0], \"x\", pad_tensor->dims->data[1]));\n    }\n    return absl::OkStatus();\n  }", "target": 1}
{"code": "static void create_layer_surface(struct swaylock_surface *surface) {\n\tstruct swaylock_state *state = surface->state;\n\tsurface->image = select_image(state, surface);\n\tsurface->surface = wl_compositor_create_surface(state->compositor);\n\tassert(surface->surface);\n\tsurface->child = wl_compositor_create_surface(state->compositor);\n\tassert(surface->child);\n\tsurface->subsurface = wl_subcompositor_get_subsurface(state->subcompositor, surface->child, surface->surface);\n\tassert(surface->subsurface);\n\twl_subsurface_set_sync(surface->subsurface);\n\tsurface->layer_surface = zwlr_layer_shell_v1_get_layer_surface(\n\t\t\tstate->layer_shell, surface->surface, surface->output,\n\t\t\tZWLR_LAYER_SHELL_V1_LAYER_OVERLAY, \"lockscreen\");\n\tassert(surface->layer_surface);\n\tzwlr_layer_surface_v1_set_size(surface->layer_surface, 0, 0);\n\tzwlr_layer_surface_v1_set_anchor(surface->layer_surface,\n\t\t\tZWLR_LAYER_SURFACE_V1_ANCHOR_TOP |\n\t\t\tZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT |\n\t\t\tZWLR_LAYER_SURFACE_V1_ANCHOR_BOTTOM |\n\t\t\tZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT);\n\tzwlr_layer_surface_v1_set_exclusive_zone(surface->layer_surface, -1);\n\tzwlr_layer_surface_v1_set_keyboard_interactivity(\n\t\t\tsurface->layer_surface, true);\n\tzwlr_layer_surface_v1_add_listener(surface->layer_surface,\n\t\t\t&layer_surface_listener, surface);\n\tif (surface_is_opaque(surface) &&\n\t\t\tsurface->state->args.mode != BACKGROUND_MODE_CENTER &&\n\t\t\tsurface->state->args.mode != BACKGROUND_MODE_FIT) {\n\t\tstruct wl_region *region =\n\t\t\twl_compositor_create_region(surface->state->compositor);\n\t\twl_region_add(region, 0, 0, INT32_MAX, INT32_MAX);\n\t\twl_surface_set_opaque_region(surface->surface, region);\n\t\twl_region_destroy(region);\n\t}\n\twl_surface_commit(surface->surface);\n}", "target": 1}
{"code": "struct btrfs_device *btrfs_find_device(struct btrfs_fs_devices *fs_devices,\n\t\t\t\t       u64 devid, u8 *uuid, u8 *fsid)\n{\n\tstruct btrfs_device *device;\n\twhile (fs_devices) {\n\t\tif (!fsid ||\n\t\t    !memcmp(fs_devices->metadata_uuid, fsid, BTRFS_FSID_SIZE)) {\n\t\t\tdevice = find_device(fs_devices, devid, uuid);\n\t\t\tif (device)\n\t\t\t\treturn device;\n\t\t}\n\t\tfs_devices = fs_devices->seed;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "externalEntityInitProcessor2(XML_Parser parser, const char *start,\n                             const char *end, const char **endPtr) {\n  const char *next = start; \n  int tok = XmlContentTok(parser->m_encoding, start, end, &next);\n  switch (tok) {\n  case XML_TOK_BOM:\n#ifdef XML_DTD\n    if (! accountingDiffTolerated(parser, tok, start, next, __LINE__,\n                                  XML_ACCOUNT_DIRECT)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif \n    if (next == end && ! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = next;\n      return XML_ERROR_NONE;\n    }\n    start = next;\n    break;\n  case XML_TOK_PARTIAL:\n    if (! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = start;\n      return XML_ERROR_NONE;\n    }\n    parser->m_eventPtr = start;\n    return XML_ERROR_UNCLOSED_TOKEN;\n  case XML_TOK_PARTIAL_CHAR:\n    if (! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = start;\n      return XML_ERROR_NONE;\n    }\n    parser->m_eventPtr = start;\n    return XML_ERROR_PARTIAL_CHAR;\n  }\n  parser->m_processor = externalEntityInitProcessor3;\n  return externalEntityInitProcessor3(parser, start, end, endPtr);\n}", "target": 1}
{"code": "static void seg_setup(int seg)\n{\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\tunsigned int ar;\n\tvmcs_write16(sf->selector, 0);\n\tvmcs_writel(sf->base, 0);\n\tvmcs_write32(sf->limit, 0xffff);\n\tar = 0x93;\n\tif (seg == VCPU_SREG_CS)\n\t\tar |= 0x08; \n\tvmcs_write32(sf->ar_bytes, ar);\n}", "target": 0}
{"code": "void IOBuf::allocExtBuffer(\n    std::size_t minCapacity,\n    uint8_t** bufReturn,\n    SharedInfo** infoReturn,\n    std::size_t* capacityReturn) {\n  if (minCapacity > kMaxIOBufSize) {\n    throw_exception<std::bad_alloc>();\n  }\n  size_t mallocSize = goodExtBufferSize(minCapacity);\n  auto buf = static_cast<uint8_t*>(checkedMalloc(mallocSize));\n  initExtBuffer(buf, mallocSize, infoReturn, capacityReturn);\n  (*infoReturn)->userData = reinterpret_cast<void*>(mallocSize);\n  if (io_buf_alloc_cb) {\n    io_buf_alloc_cb(buf, mallocSize);\n  }\n  *bufReturn = buf;\n}", "target": 0}
{"code": "BOOL update_write_cache_bitmap_v3_order(wStream* s, CACHE_BITMAP_V3_ORDER* cache_bitmap_v3,\n                                        UINT16* flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\tif (!Stream_EnsureRemainingCapacity(\n\t        s, update_approximate_cache_bitmap_v3_order(cache_bitmap_v3, flags)))\n\t\treturn FALSE;\n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tbitsPerPixelId = BPP_CBR23[cache_bitmap_v3->bpp];\n\t*flags = (cache_bitmap_v3->cacheId & 0x00000003) |\n\t         ((cache_bitmap_v3->flags << 7) & 0x0000FF80) | ((bitsPerPixelId << 3) & 0x00000078);\n\tStream_Write_UINT16(s, cache_bitmap_v3->cacheIndex); \n\tStream_Write_UINT32(s, cache_bitmap_v3->key1);       \n\tStream_Write_UINT32(s, cache_bitmap_v3->key2);       \n\tStream_Write_UINT8(s, bitmapData->bpp);\n\tStream_Write_UINT8(s, 0);                   \n\tStream_Write_UINT8(s, 0);                   \n\tStream_Write_UINT8(s, bitmapData->codecID); \n\tStream_Write_UINT16(s, bitmapData->width);  \n\tStream_Write_UINT16(s, bitmapData->height); \n\tStream_Write_UINT32(s, bitmapData->length); \n\tStream_Write(s, bitmapData->data, bitmapData->length);\n\treturn TRUE;\n}", "target": 1}
{"code": "  friend bool operator==(const TensorKey& t1, const TensorKey& t2) {\n    if (t1.dtype() != t2.dtype() || t1.shape() != t2.shape()) {\n      return false;\n    }\n    if (DataTypeCanUseMemcpy(t1.dtype())) {\n      return t1.tensor_data() == t2.tensor_data();\n    }\n    if (t1.dtype() == DT_STRING) {\n      const auto s1 = t1.unaligned_flat<tstring>();\n      const auto s2 = t2.unaligned_flat<tstring>();\n      for (int64_t i = 0, n = t1.NumElements(); i < n; ++i) {\n        if (TF_PREDICT_FALSE(s1(i) != s2(i))) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }", "target": 1}
{"code": "static void set_fdc(int drive)\n{\n\tif (drive >= 0 && drive < N_DRIVE) {\n\t\tfdc = FDC(drive);\n\t\tcurrent_drive = drive;\n\t}\n\tif (fdc != 1 && fdc != 0) {\n\t\tpr_info(\"bad fdc value\\n\");\n\t\treturn;\n\t}\n\tset_dor(fdc, ~0, 8);\n#if N_FDC > 1\n\tset_dor(1 - fdc, ~8, 0);\n#endif\n\tif (FDCS->rawcmd == 2)\n\t\treset_fdc_info(1);\n\tif (fd_inb(FD_STATUS) != STATUS_READY)\n\t\tFDCS->reset = 1;\n}", "target": 1}
{"code": "CSecurityTLS::CSecurityTLS(bool _anon) : session(0), anon_cred(0),\n\t\t\t\t\t\t anon(_anon), fis(0), fos(0)\n{\n  cafile = X509CA.getData();\n  crlfile = X509CRL.getData();\n  if (gnutls_global_init() != GNUTLS_E_SUCCESS)\n    throw AuthFailureException(\"gnutls_global_init failed\");\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& sorted_inputs_t = ctx->input(0);\n    const Tensor& values_t = ctx->input(1);\n    OP_REQUIRES(\n        ctx, sorted_inputs_t.shape().dims() == 2,\n        errors::InvalidArgument(absl::StrCat(\n            \"Shape must be rank 2 but is rank \", sorted_inputs_t.shape().dims(),\n            \" for \"\n            \"`sorted_inputs` argument\")));\n    OP_REQUIRES(ctx, values_t.shape().dims() == 2,\n                errors::InvalidArgument(absl::StrCat(\n                    \"Shape must be rank 2 but is rank \",\n                    values_t.shape().dims(), \" for `values` argument\")));\n    OP_REQUIRES(ctx, sorted_inputs_t.dim_size(0) == values_t.dim_size(0),\n                Status(error::INVALID_ARGUMENT,\n                       \"Leading dim_size of both tensors must match.\"));\n    OP_REQUIRES(ctx, values_t.NumElements() < std::numeric_limits<int>::max(),\n                Status(error::INVALID_ARGUMENT,\n                       \"values tensor size must less than INT_MAX\"));\n    Tensor* output_t;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, values_t.shape(), &output_t));\n    if (output_t->dtype() == DT_INT32) {\n      OP_REQUIRES(ctx,\n                  FastBoundsCheck(sorted_inputs_t.dim_size(1),\n                                  std::numeric_limits<int>::max()),\n                  errors::InvalidArgument(\"trailing dim_size must less than \"\n                                          \"INT_MAX for int32 output type, was \",\n                                          sorted_inputs_t.dim_size(1)));\n    }\n    auto output = output_t->template flat<OutType>();\n    const auto sorted_inputs = sorted_inputs_t.template flat<T>();\n    const auto values = values_t.template flat<T>();\n    if (sorted_inputs.size() == 0) {\n      functor::SetZeroFunctor<Device, OutType> set_zero;\n      set_zero(ctx->eigen_device<Device>(), output);\n      return;\n    }\n    OP_REQUIRES_OK(\n        ctx, functor::LowerBoundFunctor<Device, T, OutType>::Compute(\n                 ctx, sorted_inputs, values, sorted_inputs_t.dim_size(0),\n                 sorted_inputs_t.dim_size(1), values_t.dim_size(1), &output));\n  }", "target": 0}
{"code": "R_API char *r_cons_hud_file(const char *f) {\n\tchar *s = r_file_slurp (f, NULL);\n\tif (s) {\n\t\tr_str_ansi_strip (s);\n\t\tchar *ret = r_cons_hud_string (s);\n\t\tfree (s);\n\t\treturn ret;\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "bool ExtractSymlink(CommandData *Cmd,ComprDataIO &DataIO,Archive &Arc,const wchar *LinkName)\n{\n#if defined(SAVE_LINKS) && defined(_UNIX)\n  if (Arc.Format==RARFMT15)\n    return ExtractUnixLink30(Cmd,DataIO,Arc,LinkName);\n  if (Arc.Format==RARFMT50)\n    return ExtractUnixLink50(Cmd,LinkName,&Arc.FileHead);\n#elif defined _WIN_ALL\n  if (Arc.Format==RARFMT50)\n    return CreateReparsePoint(Cmd,LinkName,&Arc.FileHead);\n#endif\n  return false;\n}", "target": 1}
{"code": "static inline void arch_dup_mmap(struct mm_struct *oldmm,\n\t\t\t\t struct mm_struct *mm)\n{\n\tif (oldmm->context.asce_limit < mm->context.asce_limit)\n\t\tcrst_table_downgrade(mm, oldmm->context.asce_limit);\n}", "target": 1}
{"code": "infra_delete(struct infra_cache* infra)\n{\n\tif(!infra)\n\t\treturn;\n\tslabhash_delete(infra->hosts);\n\tslabhash_delete(infra->domain_rates);\n\ttraverse_postorder(&infra->domain_limits, domain_limit_free, NULL);\n\tslabhash_delete(infra->client_ip_rates);\n\ttraverse_postorder(&infra->wait_limits_netblock,\n\t\twait_limit_netblock_del, NULL);\n\ttraverse_postorder(&infra->wait_limits_cookie_netblock,\n\t\twait_limit_netblock_del, NULL);\n\tfree(infra);\n}", "target": 0}
{"code": "authentic_emu_update_tokeninfo(struct sc_profile *profile, struct sc_pkcs15_card *p15card,\n\t\tstruct sc_pkcs15_tokeninfo *tinfo)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_file *file = NULL;\n\tstruct sc_path path;\n\tunsigned char buffer[8];\n\tint rv,len;\n\tsc_format_path(AUTHENTIC_CACHE_TIMESTAMP_PATH, &path);\n\trv = sc_select_file(p15card->card, &path, &file);\n\tif (!rv) {\n\t\trv = sc_get_challenge(p15card->card, buffer, sizeof(buffer));\n\t\tif (!rv) {\n\t\t\tsc_file_free(file);\n\t\t\tLOG_TEST_RET(ctx, rv, \"Get challenge error\");\n\t\t}\n\t\tlen = file->size > sizeof(buffer) ? sizeof(buffer) : file->size;\n\t\trv = sc_update_binary(p15card->card, 0, buffer, len, 0);\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, rv, \"Update binary error\");\n\t}\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}", "target": 1}
{"code": "ErrorCode HTTP2Codec::checkNewStream(uint32_t streamId, bool trailersAllowed) {\n  if (streamId == 0) {\n    goawayErrorMessage_ = folly::to<string>(\n        \"GOAWAY error: received streamID=\", streamId,\n        \" as invalid new stream for lastStreamID_=\", lastStreamID_);\n    VLOG(4) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n  parsingDownstreamTrailers_ = trailersAllowed && (streamId <= lastStreamID_);\n  if (parsingDownstreamTrailers_) {\n    VLOG(4) << \"Parsing downstream trailers streamId=\" << streamId;\n  }\n  if (sessionClosing_ != ClosingState::CLOSED) {\n    lastStreamID_ = streamId;\n  }\n  if (isInitiatedStream(streamId)) {\n    goawayErrorMessage_ = folly::to<string>(\n        \"GOAWAY error: invalid new stream received with streamID=\", streamId);\n    VLOG(4) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  } else {\n    return ErrorCode::NO_ERROR;\n  }\n}", "target": 1}
{"code": "int cil_build_ast(struct cil_db *db, struct cil_tree_node *parse_tree, struct cil_tree_node *ast)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_build extra_args;\n\tif (db == NULL || parse_tree == NULL || ast == NULL) {\n\t\tgoto exit;\n\t}\n\textra_args.ast = ast;\n\textra_args.db = db;\n\textra_args.tunif = NULL;\n\textra_args.in = NULL;\n\textra_args.macro = NULL;\n\textra_args.optional = NULL;\n\textra_args.boolif = NULL;\n\trc = cil_tree_walk(parse_tree, __cil_build_ast_node_helper, __cil_build_ast_first_child_helper, __cil_build_ast_last_child_helper, &extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\treturn SEPOL_OK;\nexit:\n\treturn rc;\n}", "target": 0}
{"code": "static int shmem_remount_fs(struct super_block *sb, int *flags, char *data)\n{\n\tstruct shmem_sb_info *sbinfo = SHMEM_SB(sb);\n\tstruct shmem_sb_info config = *sbinfo;\n\tunsigned long inodes;\n\tint error = -EINVAL;\n\tif (shmem_parse_options(data, &config, true))\n\t\treturn error;\n\tspin_lock(&sbinfo->stat_lock);\n\tinodes = sbinfo->max_inodes - sbinfo->free_inodes;\n\tif (percpu_counter_compare(&sbinfo->used_blocks, config.max_blocks) > 0)\n\t\tgoto out;\n\tif (config.max_inodes < inodes)\n\t\tgoto out;\n\tif (config.max_blocks && !sbinfo->max_blocks)\n\t\tgoto out;\n\tif (config.max_inodes && !sbinfo->max_inodes)\n\t\tgoto out;\n\terror = 0;\n\tsbinfo->max_blocks  = config.max_blocks;\n\tsbinfo->max_inodes  = config.max_inodes;\n\tsbinfo->free_inodes = config.max_inodes - inodes;\n\tmpol_put(sbinfo->mpol);\n\tsbinfo->mpol        = config.mpol;\t\nout:\n\tspin_unlock(&sbinfo->stat_lock);\n\treturn error;\n}", "target": 1}
{"code": "void SparseFillEmptyRowsOpImpl(OpKernelContext* context,\n                               AsyncOpKernel::DoneCallback done = nullptr) {\n  if (!done) {\n    done = [] {};\n  }\n  const int kIndicesInput = 0;\n  const int kValuesInput = 1;\n  const int kDenseShapeInput = 2;\n  const int kDefaultValueInput = 3;\n  const Tensor& indices_t = context->input(kIndicesInput);\n  const Tensor& values_t = context->input(kValuesInput);\n  const Tensor& dense_shape_t = context->input(kDenseShapeInput);\n  const Tensor& default_value_t = context->input(kDefaultValueInput);\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsVector(dense_shape_t.shape()),\n      errors::InvalidArgument(\"dense_shape must be a vector, saw: \",\n                              dense_shape_t.shape().DebugString()),\n      done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsMatrix(indices_t.shape()),\n                    errors::InvalidArgument(\"indices must be a matrix, saw: \",\n                                            indices_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsVector(values_t.shape()),\n                    errors::InvalidArgument(\"values must be a vector, saw: \",\n                                            values_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsScalar(default_value_t.shape()),\n      errors::InvalidArgument(\"default_value must be a scalar, saw: \",\n                              default_value_t.shape().DebugString()),\n      done);\n  using FunctorType = functor::SparseFillEmptyRows<Device, T, Tindex>;\n  OP_REQUIRES_OK_ASYNC(context,\n                       FunctorType()(context, default_value_t, indices_t,\n                                     values_t, dense_shape_t, done),\n                       done);\n}", "target": 1}
{"code": "static void ext4_clamp_want_extra_isize(struct super_block *sb)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tif (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    sbi->s_want_extra_isize == 0) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t     EXT4_GOOD_OLD_INODE_SIZE;\n\t\tif (ext4_has_feature_extra_isize(sb)) {\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_want_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_want_extra_isize);\n\t\t\tif (sbi->s_want_extra_isize <\n\t\t\t    le16_to_cpu(es->s_min_extra_isize))\n\t\t\t\tsbi->s_want_extra_isize =\n\t\t\t\t\tle16_to_cpu(es->s_min_extra_isize);\n\t\t}\n\t}\n\tif (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >\n\t\t\t\t\t\t\tsbi->s_inode_size) {\n\t\tsbi->s_want_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t\t       EXT4_GOOD_OLD_INODE_SIZE;\n\t\text4_msg(sb, KERN_INFO,\n\t\t\t \"required extra inode space not available\");\n\t}\n}", "target": 1}
{"code": "static int tiocgetd(struct tty_struct *tty, int __user *p)\n{\n\tstruct tty_ldisc *ld;\n\tint ret;\n\tld = tty_ldisc_ref_wait(tty);\n\tret = put_user(ld->ops->num, p);\n\ttty_ldisc_deref(ld);\n\treturn ret;\n}", "target": 0}
{"code": "ProcXkbBell(ClientPtr client)\n{\n    REQUEST(xkbBellReq);\n    DeviceIntPtr dev;\n    WindowPtr\t pWin;\n    int rc;\n    REQUEST_SIZE_MATCH(xkbBellReq);\n    if (!(client->xkbClientFlags&_XkbClientInitialized))\n\treturn BadAccess;\n    CHK_BELL_DEVICE(dev, stuff->deviceSpec, client, DixBellAccess);\n    CHK_ATOM_OR_NONE(stuff->name);\n    if ((stuff->forceSound)&&(stuff->eventOnly)) {\n\tclient->errorValue=_XkbErrCode3(0x1,stuff->forceSound,stuff->eventOnly);\n\treturn BadMatch;\n    }\n    if (stuff->percent < -100 || stuff->percent > 100) {\n\tclient->errorValue = _XkbErrCode2(0x2,stuff->percent);\n\treturn BadValue;\n    }\n    if (stuff->duration<-1) {\n\tclient->errorValue = _XkbErrCode2(0x3,stuff->duration);\n\treturn BadValue;\n    }\n    if (stuff->pitch<-1) {\n\tclient->errorValue = _XkbErrCode2(0x4,stuff->pitch);\n\treturn BadValue;\n    }\n    if (stuff->bellClass == XkbDfltXIClass) {\n\tif (dev->kbdfeed!=NULL)\n\t     stuff->bellClass= KbdFeedbackClass;\n\telse stuff->bellClass= BellFeedbackClass;\n    }\n    if (stuff->window!=None) {\n\trc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);\n\tif (rc != Success) {\n\t    client->errorValue= stuff->window;\n\t    return rc;\n\t}\n    }\n    else pWin= NULL;\n    rc = _XkbBell(client, dev, pWin, stuff->bellClass, stuff->bellID,\n                  stuff->pitch, stuff->duration, stuff->percent,\n                  stuff->forceSound, stuff->eventOnly, stuff->name);\n    if ((rc == Success) && ((stuff->deviceSpec == XkbUseCoreKbd) ||\n                            (stuff->deviceSpec == XkbUseCorePtr)))\n    {\n        DeviceIntPtr other;\n        for (other = inputInfo.devices; other; other = other->next)\n        {\n            if ((other != dev) && other->key && !other->isMaster && (other->u.master == dev))\n            {\n                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixBellAccess);\n                if (rc == Success)\n                    _XkbBell(client, other, pWin, stuff->bellClass,\n                             stuff->bellID, stuff->pitch, stuff->duration,\n                             stuff->percent, stuff->forceSound,\n                             stuff->eventOnly, stuff->name);\n            }\n        }\n        rc = Success; \n    }\n    return rc;\n}", "target": 0}
{"code": "void ext4_xattr_destroy_cache(struct mb_cache *cache)\n{\n\tif (cache)\n\t\tmb_cache_destroy(cache);\n}", "target": 1}
{"code": "static void flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\tif (tsk != current)\n\t\treturn;\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&(tsk->thread));\n\t}\n}", "target": 1}
{"code": "xmlValidNormalizeAttributeValue(xmlDocPtr doc, xmlNodePtr elem,\n\t\t\t        const xmlChar *name, const xmlChar *value) {\n    xmlChar *ret, *dst;\n    const xmlChar *src;\n    xmlAttributePtr attrDecl = NULL;\n    if (doc == NULL) return(NULL);\n    if (elem == NULL) return(NULL);\n    if (name == NULL) return(NULL);\n    if (value == NULL) return(NULL);\n    if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {\n\txmlChar fn[50];\n\txmlChar *fullname;\n\tfullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);\n\tif (fullname == NULL)\n\t    return(NULL);\n\tif ((fullname != fn) && (fullname != elem->name))\n\t    xmlFree(fullname);\n    }\n    attrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, name);\n    if ((attrDecl == NULL) && (doc->extSubset != NULL))\n\tattrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);\n    if (attrDecl == NULL)\n\treturn(NULL);\n    if (attrDecl->atype == XML_ATTRIBUTE_CDATA)\n\treturn(NULL);\n    ret = xmlStrdup(value);\n    if (ret == NULL)\n\treturn(NULL);\n    src = value;\n    dst = ret;\n    while (*src == 0x20) src++;\n    while (*src != 0) {\n\tif (*src == 0x20) {\n\t    while (*src == 0x20) src++;\n\t    if (*src != 0)\n\t\t*dst++ = 0x20;\n\t} else {\n\t    *dst++ = *src++;\n\t}\n    }\n    *dst = 0;\n    return(ret);\n}", "target": 1}
{"code": "void CNB::DoIPHdrCSO(PVOID IpHeader, ULONG EthPayloadLength) const\n{\n    ParaNdis_CheckSumVerifyFlat(IpHeader,\n                                EthPayloadLength,\n                                pcrIpChecksum | pcrFixIPChecksum,\n                                __FUNCTION__);\n}", "target": 1}
{"code": "decode_definite_short_bytestring(CBORDecoderObject *self, Py_ssize_t length)\n{\n    PyObject *ret = fp_read_object(self, length);\n    if (!ret)\n        return NULL;\n    if (string_namespace_add(self, ret, length) == -1) {\n        Py_DECREF(ret);\n        return NULL;\n    }\n    return ret;\n}", "target": 0}
{"code": "static tjhandle _tjInitDecompress(tjinstance *this)\n{\n\tstatic unsigned char buffer[1];\n\tthis->dinfo.err=jpeg_std_error(&this->jerr.pub);\n\tthis->jerr.pub.error_exit=my_error_exit;\n\tthis->jerr.pub.output_message=my_output_message;\n\tthis->jerr.emit_message=this->jerr.pub.emit_message;\n\tthis->jerr.pub.emit_message=my_emit_message;\n\tif(setjmp(this->jerr.setjmp_buffer))\n\t{\n\t\tif(this) free(this);\n\t\treturn NULL;\n\t}\n\tjpeg_create_decompress(&this->dinfo);\n\tjpeg_mem_src_tj(&this->dinfo, buffer, 1);\n\tthis->init|=DECOMPRESS;\n\treturn (tjhandle)this;\n}", "target": 0}
{"code": "static void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tstruct sock *sk;\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tsk = s->sk;\n\t\t\tsock_hold(sk);\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(sk);\n\t\t\ts->ax25_dev = NULL;\n\t\t\tax25_dev_put(ax25_dev);\n\t\t\trelease_sock(sk);\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tsock_put(sk);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}", "target": 1}
{"code": "main (int argc, char **argv)\n{\n\tEvArchive *ar;\n\tEvArchiveType ar_type;\n\tGError *error = NULL;\n\tgboolean printed_header = FALSE;\n\tif (argc != 3) {\n\t\tusage (argv[0]);\n\t\treturn 1;\n\t}\n\tar_type = str_to_archive_type (argv[1]);\n\tif (ar_type == EV_ARCHIVE_TYPE_NONE)\n\t\treturn 1;\n\tar = ev_archive_new ();\n\tif (!ev_archive_set_archive_type (ar, ar_type)) {\n\t\tg_warning (\"Failed to set archive type\");\n\t\tgoto out;\n\t}\n\tif (!ev_archive_open_filename (ar, argv[2], &error)) {\n\t\tg_warning (\"Failed to open '%s': %s\",\n\t\t\t   argv[2], error->message);\n\t\tg_error_free (error);\n\t\tgoto out;\n\t}\n\twhile (1) {\n\t\tconst char *name;\n\t\tgboolean is_encrypted;\n\t\tgint64 size;\n\t\tif (!ev_archive_read_next_header (ar, &error)) {\n\t\t\tif (error != NULL) {\n\t\t\t\tg_warning (\"Fatal error handling archive: %s\", error->message);\n\t\t\t\tg_clear_error (&error);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tname = ev_archive_get_entry_pathname (ar);\n\t\tis_encrypted = ev_archive_get_entry_is_encrypted (ar);\n\t\tsize = ev_archive_get_entry_size (ar);\n\t\tif (!printed_header) {\n\t\t\tg_print (\"P\\tSIZE\\tNAME\\n\");\n\t\t\tprinted_header = TRUE;\n\t\t}\n\t\tg_print (\"%c\\t%\"G_GINT64_FORMAT\"\\t%s\\n\",\n\t\t\t is_encrypted ? 'P' : ' ',\n\t\t\t size, name);\n\t}\n\tev_archive_reset (ar);\n\tg_clear_object (&ar);\n\treturn 0;\nout:\n\tg_clear_object (&ar);\n\treturn 1;\n}", "target": 0}
{"code": "TfLiteStatus PrepareHashtable(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 0);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  TF_LITE_ENSURE(context, node->user_data != nullptr);\n  const auto* params =\n      reinterpret_cast<const TfLiteHashtableParams*>(node->user_data);\n  TF_LITE_ENSURE(context, !params->table_name.empty());\n  TF_LITE_ENSURE(context, (params->key_dtype == kTfLiteInt64 &&\n                           params->value_dtype == kTfLiteString) ||\n                              (params->key_dtype == kTfLiteString &&\n                               params->value_dtype == kTfLiteInt64));\n  TfLiteTensor* resource_handle_tensor =\n      GetOutput(context, node, kResourceHandleTensor);\n  TF_LITE_ENSURE(context, resource_handle_tensor != nullptr);\n  TF_LITE_ENSURE_EQ(context, resource_handle_tensor->type, kTfLiteInt32);\n  TfLiteIntArray* outputSize = TfLiteIntArrayCreate(1);\n  outputSize->data[0] = 1;\n  return context->ResizeTensor(context, resource_handle_tensor, outputSize);\n}", "target": 1}
{"code": "static void list_slab_objects(struct kmem_cache *s, struct page *page,\n\t\t\t\t\t\t\tconst char *text)\n{\n#ifdef CONFIG_SLUB_DEBUG\n\tvoid *addr = page_address(page);\n\tvoid *p;\n\tunsigned long *map;\n\tslab_err(s, page, text, s->name);\n\tslab_lock(page);\n\tmap = get_map(s, page);\n\tfor_each_object(p, s, addr, page->objects) {\n\t\tif (!test_bit(slab_index(p, s, addr), map)) {\n\t\t\tpr_err(\"INFO: Object 0x%p @offset=%tu\\n\", p, p - addr);\n\t\t\tprint_tracking(s, p);\n\t\t}\n\t}\n\tput_map(map);\n\tslab_unlock(page);\n#endif\n}", "target": 0}
{"code": "static int cuse_channel_release(struct inode *inode, struct file *file)\n{\n\tstruct fuse_dev *fud = file->private_data;\n\tstruct cuse_conn *cc = fc_to_cc(fud->fc);\n\tint rc;\n\tmutex_lock(&cuse_lock);\n\tlist_del_init(&cc->list);\n\tmutex_unlock(&cuse_lock);\n\tif (cc->dev)\n\t\tdevice_unregister(cc->dev);\n\tif (cc->cdev) {\n\t\tunregister_chrdev_region(cc->cdev->dev, 1);\n\t\tcdev_del(cc->cdev);\n\t}\n\tfuse_conn_put(&cc->fc);\n\trc = fuse_dev_release(inode, file);\t\n\treturn rc;\n}", "target": 0}
{"code": "__acquires(&fc->lock)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(req->inode);\n\tloff_t size = i_size_read(req->inode);\n\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\tif (!fc->connected)\n\t\tgoto out_free;\n\tif (inarg->offset + PAGE_CACHE_SIZE <= size) {\n\t\tinarg->size = PAGE_CACHE_SIZE;\n\t} else if (inarg->offset < size) {\n\t\tinarg->size = size & (PAGE_CACHE_SIZE - 1);\n\t} else {\n\t\tgoto out_free;\n\t}\n\treq->in.args[1].size = inarg->size;\n\tfi->writectr++;\n\tfuse_request_send_background_locked(fc, req);\n\treturn;\n out_free:\n\tfuse_writepage_finish(fc, req);\n\tspin_unlock(&fc->lock);\n\tfuse_writepage_free(fc, req);\n\tfuse_put_request(fc, req);\n\tspin_lock(&fc->lock);\n}", "target": 0}
{"code": "_archive_write_data(struct archive *_a, const void *buff, size_t s)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tconst size_t max_write = INT_MAX;\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_DATA, \"archive_write_data\");\n\tif (s > max_write)\n\t\ts = max_write;\n\tarchive_clear_error(&a->archive);\n\treturn ((a->format_write_data)(a, buff, s));\n}", "target": 0}
{"code": "pci_populate_msicap(struct msicap *msicap, int msgnum, int nextptr)\n{\n\tint mmc;\n\tassert((msgnum & (msgnum - 1)) == 0 && msgnum >= 1 && msgnum <= 32);\n\tmmc = ffs(msgnum) - 1;\n\tbzero(msicap, sizeof(struct msicap));\n\tmsicap->capid = PCIY_MSI;\n\tmsicap->nextptr = nextptr;\n\tmsicap->msgctrl = PCIM_MSICTRL_64BIT | (mmc << 1);\n}", "target": 1}
{"code": "void llc_conn_handler(struct llc_sap *sap, struct sk_buff *skb)\n{\n\tstruct llc_addr saddr, daddr;\n\tstruct sock *sk;\n\tllc_pdu_decode_sa(skb, saddr.mac);\n\tllc_pdu_decode_ssap(skb, &saddr.lsap);\n\tllc_pdu_decode_da(skb, daddr.mac);\n\tllc_pdu_decode_dsap(skb, &daddr.lsap);\n\tsk = __llc_lookup(sap, &saddr, &daddr);\n\tif (!sk)\n\t\tgoto drop;\n\tbh_lock_sock(sk);\n\tif (unlikely(sk->sk_state == TCP_LISTEN)) {\n\t\tstruct sock *newsk = llc_create_incoming_sock(sk, skb->dev,\n\t\t\t\t\t\t\t      &saddr, &daddr);\n\t\tif (!newsk)\n\t\t\tgoto drop_unlock;\n\t\tskb_set_owner_r(skb, newsk);\n\t} else {\n\t\tskb_orphan(skb);\n\t\tsock_hold(sk);\n\t\tskb->sk = sk;\n\t\tskb->destructor = sock_efree;\n\t}\n\tif (!sock_owned_by_user(sk))\n\t\tllc_conn_rcv(sk, skb);\n\telse {\n\t\tdprintk(\"%s: adding to backlog...\\n\", __func__);\n\t\tllc_set_backlog_type(skb, LLC_PACKET);\n\t\tif (sk_add_backlog(sk, skb, sk->sk_rcvbuf))\n\t\t\tgoto drop_unlock;\n\t}\nout:\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n\treturn;\ndrop:\n\tkfree_skb(skb);\n\treturn;\ndrop_unlock:\n\tkfree_skb(skb);\n\tgoto out;\n}", "target": 0}
{"code": "int addrconf_sysctl_mtu(struct ctl_table *ctl, int write,\n\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct inet6_dev *idev = ctl->extra1;\n\tint min_mtu = IPV6_MIN_MTU;\n\tstruct ctl_table lctl;\n\tlctl = *ctl;\n\tlctl.extra1 = &min_mtu;\n\tlctl.extra2 = idev ? &idev->dev->mtu : NULL;\n\treturn proc_dointvec_minmax(&lctl, write, buffer, lenp, ppos);\n}", "target": 0}
{"code": "static long compat_adpt_ioctl(struct file *file,\n\t\t\t\tunsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode;\n\tlong ret;\n\tinode = file_inode(file);\n\tmutex_lock(&adpt_mutex);\n\tswitch(cmd) {\n\t\tcase DPT_SIGNATURE:\n\t\tcase I2OUSRCMD:\n\t\tcase DPT_CTRLINFO:\n\t\tcase DPT_SYSINFO:\n\t\tcase DPT_BLINKLED:\n\t\tcase I2ORESETCMD:\n\t\tcase I2ORESCANCMD:\n\t\tcase (DPT_TARGET_BUSY & 0xFFFF):\n\t\tcase DPT_TARGET_BUSY:\n\t\t\tret = adpt_ioctl(inode, file, cmd, arg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret =  -ENOIOCTLCMD;\n\t}\n\tmutex_unlock(&adpt_mutex);\n\treturn ret;\n}", "target": 1}
{"code": "static inline int file_list_cpu(struct file *file)\n{\n#ifdef CONFIG_SMP\n\treturn file->f_sb_list_cpu;\n#else\n\treturn smp_processor_id();\n#endif\n}", "target": 1}
{"code": "file_pop_buffer(struct magic_set *ms, file_pushbuf_t *pb)\n{\n\tchar *rbuf;\n\tif (ms->event_flags & EVENT_HAD_ERR) {\n\t\tfree(pb->buf);\n\t\tfree(pb);\n\t\treturn NULL;\n\t}\n\trbuf = ms->o.buf;\n\tms->o.buf = pb->buf;\n\tms->offset = pb->offset;\n\tfree(pb);\n\treturn rbuf;\n}", "target": 0}
{"code": "static int asymmetric_key_cmp(const struct key *key,\n\t\t\t      const struct key_match_data *match_data)\n{\n\tconst struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\n\tconst char *description = match_data->raw_data;\n\tconst char *spec = description;\n\tconst char *id;\n\tptrdiff_t speclen;\n\tif (!subtype || !spec || !*spec)\n\t\treturn 0;\n\tif (key->description && strcmp(key->description, description) == 0)\n\t\treturn 1;\n\tid = strchr(spec, ':');\n\tif (!id)\n\t\treturn 0;\n\tspeclen = id - spec;\n\tid++;\n\tif (speclen == 2 && memcmp(spec, \"id\", 2) == 0)\n\t\treturn asymmetric_keyid_match(asymmetric_key_id(key), id);\n\tif (speclen == subtype->name_len &&\n\t    memcmp(spec, subtype->name, speclen) == 0)\n\t\treturn 1;\n\treturn 0;\n}", "target": 0}
{"code": "sysObjectID_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  OID(sysObjectID_oid, 1, 3, 6, 1, 4, 1, 54352);\n  snmp_api_set_oid(varbind, oid, sysObjectID_oid);\n}", "target": 1}
{"code": "certstack_destroy(struct cert_stack *stack)\n{\n\tunsigned int stack_size;\n\tstruct metadata_node *meta;\n\tstruct defer_node *post;\n\tstruct repo_level_node *level;\n\tstack_size = 0;\n\twhile (!SLIST_EMPTY(&stack->defers)) {\n\t\tpost = SLIST_FIRST(&stack->defers);\n\t\tSLIST_REMOVE_HEAD(&stack->defers, next);\n\t\tdefer_destroy(post);\n\t\tstack_size++;\n\t}\n\tpr_val_debug(\"Deleted %u deferred certificates.\", stack_size);\n\tpr_val_debug(\"Deleting %d stacked x509s.\", sk_X509_num(stack->x509s));\n\tsk_X509_pop_free(stack->x509s, X509_free);\n\tstack_size = 0;\n\twhile (!SLIST_EMPTY(&stack->metas)) {\n\t\tmeta = SLIST_FIRST(&stack->metas);\n\t\tSLIST_REMOVE_HEAD(&stack->metas, next);\n\t\tmeta_destroy(meta);\n\t\tstack_size++;\n\t}\n\tpr_val_debug(\"Deleted %u metadatas.\", stack_size);\n\tstack_size = 0;\n\twhile (!SLIST_EMPTY(&stack->levels)) {\n\t\tlevel = SLIST_FIRST(&stack->levels);\n\t\tSLIST_REMOVE_HEAD(&stack->levels, next);\n\t\tfree(level);\n\t\tstack_size++;\n\t}\n\tpr_val_debug(\"Deleted %u stacked levels.\", stack_size);\n\tfree(stack);\n}", "target": 1}
{"code": "static uint32_t scsi_init_iovec(SCSIDiskReq *r)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n    if (!r->iov.iov_base) {\n        r->buflen = SCSI_DMA_BUF_SIZE;\n        r->iov.iov_base = qemu_blockalign(s->bs, r->buflen);\n    }\n    r->iov.iov_len = MIN(r->sector_count * 512, r->buflen);\n    qemu_iovec_init_external(&r->qiov, &r->iov, 1);\n    return r->qiov.size / 512;\n}", "target": 0}
{"code": "static bool nfs_request_too_big(struct svc_rqst *rqstp,\n\t\t\t\tstruct svc_procedure *proc)\n{\n\tif (rqstp->rq_prog != NFS_PROGRAM)\n\t\treturn false;\n\tif (rqstp->rq_vers >= 4)\n\t\treturn false;\n\tif (proc->pc_xdrressize > 0 &&\n\t    proc->pc_xdrressize < XDR_QUADLEN(PAGE_SIZE))\n\t\treturn false;\n\treturn rqstp->rq_arg.len > PAGE_SIZE;\n}", "target": 0}
{"code": "double enclave_check_abi()\n{\n    double retval = NAN;\n    oe_result_t result = OE_UNEXPECTED;\n    abi_state_t before_ocall_state = {};\n    abi_state_t after_ocall_state = {};\n    typedef struct _host_check_abi_args_t\n    {\n        oe_result_t _result;\n        void* deepcopy_out_buffer;\n        size_t deepcopy_out_buffer_size;\n        double _retval;\n    } host_check_abi_args_t;\n    typedef struct _flat_ocall_args\n    {\n        oe_call_host_function_args_t host_function_args;\n        host_check_abi_args_t check_abi_args;\n    } flat_ocall_args_t;\n    static const size_t abi_fcn_id_host_check_abi = 0;\n    const flat_ocall_args_t args_template = {\n        {.function_id = abi_fcn_id_host_check_abi,\n         .input_buffer = NULL,\n         .input_buffer_size = sizeof(args_template.check_abi_args),\n         .output_buffer = NULL,\n         .output_buffer_size = sizeof(args_template.check_abi_args),\n         .output_bytes_written = 0,\n         .result = OE_UNEXPECTED},\n        {._result = OE_UNEXPECTED,\n         .deepcopy_out_buffer = NULL,\n         .deepcopy_out_buffer_size = 0,\n         ._retval = 0}};\n    flat_ocall_args_t* args =\n        (flat_ocall_args_t*)oe_allocate_ocall_buffer(sizeof(args_template));\n    if (!args)\n        goto done;\n    memcpy(args, &args_template, sizeof(args_template));\n    args->host_function_args.input_buffer = &args->check_abi_args;\n    args->host_function_args.output_buffer = &args->check_abi_args;\n    set_test_abi_state();\n    read_abi_state(&before_ocall_state);\n    result = oe_ocall(OE_OCALL_CALL_HOST_FUNCTION, (uint64_t)args, NULL);\n    read_abi_state(&after_ocall_state);\n    reset_test_abi_state();\n    if (result != OE_OK)\n        goto done;\n    if (args->host_function_args.result != OE_OK)\n        goto done;\n    if (args->host_function_args.output_bytes_written !=\n        sizeof(args_template.check_abi_args))\n        goto done;\n    if (args->check_abi_args._retval != EXPECTED_CHECK_ABI_RETURN_VALUE)\n        goto done;\n    if (!is_same_abi_state(&before_ocall_state, &after_ocall_state))\n        goto done;\n    retval = args->check_abi_args._retval;\ndone:\n    return retval;\n}", "target": 1}
{"code": "static int inotify_release(struct inode *ignored, struct file *file)\n{\n\tstruct fsnotify_group *group = file->private_data;\n\tstruct user_struct *user = group->inotify_data.user;\n\tpr_debug(\"%s: group=%p\\n\", __func__, group);\n\tfsnotify_clear_marks_by_group(group);\n\tfsnotify_put_group(group);\n\tatomic_dec(&user->inotify_devs);\n\treturn 0;\n}", "target": 1}
{"code": "static int vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tvcpu->arch.l1tf_flush_l1d = true;\n\tfor (;;) {\n\t\tvcpu->arch.at_instruction_boundary = false;\n\t\tif (kvm_vcpu_running(vcpu)) {\n\t\t\tr = vcpu_enter_guest(vcpu);\n\t\t} else {\n\t\t\tr = vcpu_block(vcpu);\n\t\t}\n\t\tif (r <= 0)\n\t\t\tbreak;\n\t\tkvm_clear_request(KVM_REQ_UNBLOCK, vcpu);\n\t\tif (kvm_xen_has_pending_events(vcpu))\n\t\t\tkvm_xen_inject_pending_events(vcpu);\n\t\tif (kvm_cpu_has_pending_timer(vcpu))\n\t\t\tkvm_inject_pending_timer_irqs(vcpu);\n\t\tif (dm_request_for_irq_injection(vcpu) &&\n\t\t\tkvm_vcpu_ready_for_interrupt_injection(vcpu)) {\n\t\t\tr = 0;\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_IRQ_WINDOW_OPEN;\n\t\t\t++vcpu->stat.request_irq_exits;\n\t\t\tbreak;\n\t\t}\n\t\tif (__xfer_to_guest_mode_work_pending()) {\n\t\t\tkvm_vcpu_srcu_read_unlock(vcpu);\n\t\t\tr = xfer_to_guest_mode_handle_work(vcpu);\n\t\t\tkvm_vcpu_srcu_read_lock(vcpu);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t}\n\t}\n\treturn r;\n}", "target": 0}
{"code": "yang_free_nodes(struct ly_ctx *ctx, struct lys_node *node)\n{\n    struct lys_node *tmp, *child, *sibling;\n    if (!node) {\n        return;\n    }\n    tmp = node;\n    while (tmp) {\n        child = tmp->child;\n        sibling = tmp->next;\n        lydict_remove(ctx, tmp->name);\n        if (!(tmp->nodetype & (LYS_INPUT | LYS_OUTPUT))) {\n            lys_iffeature_free(ctx, tmp->iffeature, tmp->iffeature_size, 0, NULL);\n            lydict_remove(ctx, tmp->dsc);\n            lydict_remove(ctx, tmp->ref);\n        }\n        switch (tmp->nodetype) {\n        case LYS_GROUPING:\n        case LYS_RPC:\n        case LYS_ACTION:\n            yang_free_grouping(ctx, (struct lys_node_grp *)tmp);\n            break;\n        case LYS_CONTAINER:\n            yang_free_container(ctx, (struct lys_node_container *)tmp);\n            break;\n        case LYS_LEAF:\n            yang_free_leaf(ctx, (struct lys_node_leaf *)tmp);\n            break;\n        case LYS_LEAFLIST:\n            yang_free_leaflist(ctx, (struct lys_node_leaflist *)tmp);\n            break;\n        case LYS_LIST:\n            yang_free_list(ctx, (struct lys_node_list *)tmp);\n            break;\n        case LYS_CHOICE:\n            yang_free_choice(ctx, (struct lys_node_choice *)tmp);\n            break;\n        case LYS_CASE:\n            lys_when_free(ctx, ((struct lys_node_case *)tmp)->when, NULL);\n            break;\n        case LYS_ANYXML:\n        case LYS_ANYDATA:\n            yang_free_anydata(ctx, (struct lys_node_anydata *)tmp);\n            break;\n        case LYS_INPUT:\n        case LYS_OUTPUT:\n            yang_free_inout(ctx, (struct lys_node_inout *)tmp);\n            break;\n        case LYS_NOTIF:\n            yang_free_notif(ctx, (struct lys_node_notif *)tmp);\n            break;\n        case LYS_USES:\n            yang_free_uses(ctx, (struct lys_node_uses *)tmp);\n            break;\n        default:\n            break;\n        }\n        lys_extension_instances_free(ctx, tmp->ext, tmp->ext_size, NULL);\n        yang_free_nodes(ctx, child);\n        free(tmp);\n        tmp = sibling;\n    }\n}", "target": 0}
{"code": "AP_DECLARE(request_rec *) ap_create_request(conn_rec *conn)\n{\n    request_rec *r;\n    apr_pool_t *p;\n    apr_pool_create(&p, conn->pool);\n    apr_pool_tag(p, \"request\");\n    r = apr_pcalloc(p, sizeof(request_rec));\n    AP_READ_REQUEST_ENTRY((intptr_t)r, (uintptr_t)conn);\n    r->pool            = p;\n    r->connection      = conn;\n    r->server          = conn->base_server;\n    r->user            = NULL;\n    r->ap_auth_type    = NULL;\n    r->allowed_methods = ap_make_method_list(p, 2);\n    r->headers_in      = apr_table_make(r->pool, 25);\n    r->trailers_in     = apr_table_make(r->pool, 5);\n    r->subprocess_env  = apr_table_make(r->pool, 25);\n    r->headers_out     = apr_table_make(r->pool, 12);\n    r->err_headers_out = apr_table_make(r->pool, 5);\n    r->trailers_out    = apr_table_make(r->pool, 5);\n    r->notes           = apr_table_make(r->pool, 5);\n    r->request_config  = ap_create_request_config(r->pool);\n    r->proto_output_filters = conn->output_filters;\n    r->output_filters  = r->proto_output_filters;\n    r->proto_input_filters = conn->input_filters;\n    r->input_filters   = r->proto_input_filters;\n    ap_run_create_request(r);\n    r->per_dir_config  = r->server->lookup_defaults;\n    r->sent_bodyct     = 0;                      \n    r->read_length     = 0;\n    r->read_body       = REQUEST_NO_BODY;\n    r->status          = HTTP_OK;  \n    r->header_only     = 0;\n    r->the_request     = NULL;\n    r->used_path_info = AP_REQ_DEFAULT_PATH_INFO;\n    r->useragent_addr = conn->client_addr;\n    r->useragent_ip = conn->client_ip;\n    return r;\n}", "target": 0}
{"code": "static void freeInstParams (AFPVu *values, int fileFormat)\n{\n\tint\ti;\n\tint\tparameterCount = _af_units[fileFormat].instrumentParameterCount;\n\tfor (i=0; i<parameterCount; i++)\n\t{\n\t\tif (_af_units[fileFormat].instrumentParameters[i].type == AU_PVTYPE_PTR)\n\t\t\tif (values[i].v != NULL)\n\t\t\t\tfree(values[i].v);\n\t}\n\tfree(values);\n}", "target": 0}
{"code": "static int proc_open(const char *path, struct fuse_file_info *fi)\n{\n\tint type = -1;\n\tstruct file_info *info;\n\tif (strcmp(path, \"/proc/meminfo\") == 0)\n\t\ttype = LXC_TYPE_PROC_MEMINFO;\n\telse if (strcmp(path, \"/proc/cpuinfo\") == 0)\n\t\ttype = LXC_TYPE_PROC_CPUINFO;\n\telse if (strcmp(path, \"/proc/uptime\") == 0)\n\t\ttype = LXC_TYPE_PROC_UPTIME;\n\telse if (strcmp(path, \"/proc/stat\") == 0)\n\t\ttype = LXC_TYPE_PROC_STAT;\n\telse if (strcmp(path, \"/proc/diskstats\") == 0)\n\t\ttype = LXC_TYPE_PROC_DISKSTATS;\n\tif (type == -1)\n\t\treturn -ENOENT;\n\tinfo = malloc(sizeof(*info));\n\tif (!info)\n\t\treturn -ENOMEM;\n\tmemset(info, 0, sizeof(*info));\n\tinfo->type = type;\n\tinfo->buflen = get_procfile_size(path) + BUF_RESERVE_SIZE;\n\tdo {\n\t\tinfo->buf = malloc(info->buflen);\n\t} while (!info->buf);\n\tmemset(info->buf, 0, info->buflen);\n\tinfo->size = info->buflen;\n\tfi->fh = (unsigned long)info;\n\treturn 0;\n}", "target": 0}
{"code": "static int x25_create(struct net *net, struct socket *sock, int protocol,\n\t\t      int kern)\n{\n\tstruct sock *sk;\n\tstruct x25_sock *x25;\n\tint rc = -EAFNOSUPPORT;\n\tif (!net_eq(net, &init_net))\n\t\tgoto out;\n\trc = -ESOCKTNOSUPPORT;\n\tif (sock->type != SOCK_SEQPACKET)\n\t\tgoto out;\n\trc = -EINVAL;\n\tif (protocol)\n\t\tgoto out;\n\trc = -ENOMEM;\n\tif ((sk = x25_alloc_socket(net, kern)) == NULL)\n\t\tgoto out;\n\tx25 = x25_sk(sk);\n\tsock_init_data(sock, sk);\n\tx25_init_timers(sk);\n\tsock->ops    = &x25_proto_ops;\n\tsk->sk_protocol = protocol;\n\tsk->sk_backlog_rcv = x25_backlog_rcv;\n\tx25->t21   = sysctl_x25_call_request_timeout;\n\tx25->t22   = sysctl_x25_reset_request_timeout;\n\tx25->t23   = sysctl_x25_clear_request_timeout;\n\tx25->t2    = sysctl_x25_ack_holdback_timeout;\n\tx25->state = X25_STATE_0;\n\tx25->cudmatchlength = 0;\n\tset_bit(X25_ACCPT_APPRV_FLAG, &x25->flags);\t\n\tx25->facilities.winsize_in  = X25_DEFAULT_WINDOW_SIZE;\n\tx25->facilities.winsize_out = X25_DEFAULT_WINDOW_SIZE;\n\tx25->facilities.pacsize_in  = X25_DEFAULT_PACKET_SIZE;\n\tx25->facilities.pacsize_out = X25_DEFAULT_PACKET_SIZE;\n\tx25->facilities.throughput  = 0;\t\n\tx25->facilities.reverse     = X25_DEFAULT_REVERSE;\n\tx25->dte_facilities.calling_len = 0;\n\tx25->dte_facilities.called_len = 0;\n\tmemset(x25->dte_facilities.called_ae, '\\0',\n\t\t\tsizeof(x25->dte_facilities.called_ae));\n\tmemset(x25->dte_facilities.calling_ae, '\\0',\n\t\t\tsizeof(x25->dte_facilities.calling_ae));\n\trc = 0;\nout:\n\treturn rc;\n}", "target": 0}
{"code": "static int vmx_check_nested_events(struct kvm_vcpu *vcpu, bool external_intr)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long exit_qual;\n\tif (kvm_event_needs_reinjection(vcpu))\n\t\treturn -EBUSY;\n\tif (vcpu->arch.exception.pending &&\n\t\tnested_vmx_check_exception(vcpu, &exit_qual)) {\n\t\tif (vmx->nested.nested_run_pending)\n\t\t\treturn -EBUSY;\n\t\tnested_vmx_inject_exception_vmexit(vcpu, exit_qual);\n\t\tvcpu->arch.exception.pending = false;\n\t\treturn 0;\n\t}\n\tif (nested_cpu_has_preemption_timer(get_vmcs12(vcpu)) &&\n\t    vmx->nested.preemption_timer_expired) {\n\t\tif (vmx->nested.nested_run_pending)\n\t\t\treturn -EBUSY;\n\t\tnested_vmx_vmexit(vcpu, EXIT_REASON_PREEMPTION_TIMER, 0, 0);\n\t\treturn 0;\n\t}\n\tif (vcpu->arch.nmi_pending && nested_exit_on_nmi(vcpu)) {\n\t\tif (vmx->nested.nested_run_pending)\n\t\t\treturn -EBUSY;\n\t\tnested_vmx_vmexit(vcpu, EXIT_REASON_EXCEPTION_NMI,\n\t\t\t\t  NMI_VECTOR | INTR_TYPE_NMI_INTR |\n\t\t\t\t  INTR_INFO_VALID_MASK, 0);\n\t\tvcpu->arch.nmi_pending = 0;\n\t\tvmx_set_nmi_mask(vcpu, true);\n\t\treturn 0;\n\t}\n\tif ((kvm_cpu_has_interrupt(vcpu) || external_intr) &&\n\t    nested_exit_on_intr(vcpu)) {\n\t\tif (vmx->nested.nested_run_pending)\n\t\t\treturn -EBUSY;\n\t\tnested_vmx_vmexit(vcpu, EXIT_REASON_EXTERNAL_INTERRUPT, 0, 0);\n\t\treturn 0;\n\t}\n\tvmx_complete_nested_posted_interrupt(vcpu);\n\treturn 0;\n}", "target": 0}
{"code": "MagickExport MemoryInfo *AcquireVirtualMemory(const size_t count,\n  const size_t quantum)\n{\n  MemoryInfo\n    *memory_info;\n  size_t\n    extent;\n  if (CheckMemoryOverflow(count,quantum) != MagickFalse)\n    return((MemoryInfo *) NULL);\n  memory_info=(MemoryInfo *) MagickAssumeAligned(AcquireAlignedMemory(1,\n    sizeof(*memory_info)));\n  if (memory_info == (MemoryInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(memory_info,0,sizeof(*memory_info));\n  extent=count*quantum;\n  memory_info->length=extent;\n  memory_info->signature=MagickCoreSignature;\n  if (AcquireMagickResource(MemoryResource,extent) != MagickFalse)\n    {\n      memory_info->blob=AcquireAlignedMemory(1,extent);\n      if (memory_info->blob != NULL)\n        {\n          memory_info->type=AlignedVirtualMemory;\n          return(memory_info);\n        }\n    }\n  RelinquishMagickResource(MemoryResource,extent);\n  if (AcquireMagickResource(MapResource,extent) != MagickFalse)\n    {\n      memory_info->blob=MapBlob(-1,IOMode,0,extent);\n      if (memory_info->blob != NULL)\n        {\n          memory_info->type=MapVirtualMemory;\n          return(memory_info);\n        }\n      if (AcquireMagickResource(DiskResource,extent) != MagickFalse)\n        {\n          int\n            file;\n          file=AcquireUniqueFileResource(memory_info->filename);\n          if (file != -1)\n            {\n              MagickOffsetType\n                offset;\n              offset=(MagickOffsetType) lseek(file,extent-1,SEEK_SET);\n              if ((offset == (MagickOffsetType) (extent-1)) &&\n                  (write(file,\"\",1) == 1))\n                {\n                  memory_info->blob=MapBlob(file,IOMode,0,extent);\n                  if (memory_info->blob != NULL)\n                    {\n                      (void) close(file);\n                      memory_info->type=MapVirtualMemory;\n                      return(memory_info);\n                    }\n                }\n              (void) close(file);\n              (void) RelinquishUniqueFileResource(memory_info->filename);\n              *memory_info->filename = '\\0';\n            }\n        }\n      RelinquishMagickResource(DiskResource,extent);\n    }\n  RelinquishMagickResource(MapResource,extent);\n  if (memory_info->blob == NULL)\n    {\n      memory_info->blob=AcquireMagickMemory(extent);\n      if (memory_info->blob != NULL)\n        memory_info->type=UnalignedVirtualMemory;\n    }\n  if (memory_info->blob == NULL)\n    memory_info=RelinquishVirtualMemory(memory_info);\n  return(memory_info);\n}", "target": 1}
{"code": "static int __init acpi_custom_method_init(void)\n{\n\tif (!acpi_debugfs_dir)\n\t\treturn -ENOENT;\n\tcm_dentry = debugfs_create_file(\"custom_method\", S_IWUSR,\n\t\t\t\t\tacpi_debugfs_dir, NULL, &cm_fops);\n\tif (!cm_dentry)\n\t\treturn -ENODEV;\n\treturn 0;\n}", "target": 1}
{"code": "static void SerializeGltfSampler(Sampler &sampler, json &o) {\n  if (sampler.magFilter != -1) {\n    SerializeNumberProperty(\"magFilter\", sampler.magFilter, o);\n  }\n  if (sampler.minFilter != -1) {\n    SerializeNumberProperty(\"minFilter\", sampler.minFilter, o);\n  }\n  SerializeNumberProperty(\"wrapS\", sampler.wrapS, o);\n  SerializeNumberProperty(\"wrapT\", sampler.wrapT, o);\n  if (sampler.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", sampler.extras, o);\n  }\n}", "target": 1}
{"code": "struct sock *inet_csk_clone_lock(const struct sock *sk,\n\t\t\t\t const struct request_sock *req,\n\t\t\t\t const gfp_t priority)\n{\n\tstruct sock *newsk = sk_clone_lock(sk, priority);\n\tif (newsk) {\n\t\tstruct inet_connection_sock *newicsk = inet_csk(newsk);\n\t\tnewsk->sk_state = TCP_SYN_RECV;\n\t\tnewicsk->icsk_bind_hash = NULL;\n\t\tinet_sk(newsk)->inet_dport = inet_rsk(req)->ir_rmt_port;\n\t\tinet_sk(newsk)->inet_num = inet_rsk(req)->ir_num;\n\t\tinet_sk(newsk)->inet_sport = htons(inet_rsk(req)->ir_num);\n\t\tnewsk->sk_write_space = sk_stream_write_space;\n\t\tsock_reset_flag(newsk, SOCK_RCU_FREE);\n\t\tinet_sk(newsk)->mc_list = NULL;\n\t\tnewsk->sk_mark = inet_rsk(req)->ir_mark;\n\t\tatomic64_set(&newsk->sk_cookie,\n\t\t\t     atomic64_read(&inet_rsk(req)->ir_cookie));\n\t\tnewicsk->icsk_retransmits = 0;\n\t\tnewicsk->icsk_backoff\t  = 0;\n\t\tnewicsk->icsk_probes_out  = 0;\n\t\tmemset(&newicsk->icsk_accept_queue, 0, sizeof(newicsk->icsk_accept_queue));\n\t\tsecurity_inet_csk_clone(newsk, req);\n\t}\n\treturn newsk;\n}", "target": 0}
{"code": "std::string DecodeUnsafe(string_view encoded) {\n  std::string raw;\n  if (Decode(encoded, &raw)) {\n    return raw;\n  }\n  return ToString(encoded);\n}", "target": 1}
{"code": "TfLiteStatus ReshapeOutput(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  int num_input_elements = NumElements(input);\n  TfLiteIntArray* output_shape = output->dims;\n  if (NumInputs(node) == 1 &&  \n      output_shape->size == 1 && output_shape->data[0] == 0) {\n    output_shape->size = 0;\n  }\n  int num_output_elements = 1;\n  int stretch_dim = -1;\n  for (int i = 0; i < output_shape->size; ++i) {\n    int value = output_shape->data[i];\n    if (value == -1) {\n      TF_LITE_ENSURE_EQ(context, stretch_dim, -1);\n      stretch_dim = i;\n    } else {\n      num_output_elements *= value;\n    }\n  }\n  if (stretch_dim != -1) {\n    output_shape->data[stretch_dim] = num_input_elements / num_output_elements;\n    num_output_elements *= output_shape->data[stretch_dim];\n  }\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  TF_LITE_ENSURE_EQ(context, num_input_elements, num_output_elements);\n  return kTfLiteOk;\n}", "target": 0}
{"code": "    void assignRemoteEndpoints(\n            const ParticipantProxyData& ) override\n    {\n    }", "target": 1}
{"code": "static void f2fs_put_super(struct super_block *sb)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tint i;\n\tf2fs_quota_off_umount(sb);\n\tmutex_lock(&sbi->umount_mutex);\n\tif (is_sbi_flag_set(sbi, SBI_IS_DIRTY) ||\n\t\t\t!is_set_ckpt_flags(sbi, CP_UMOUNT_FLAG)) {\n\t\tstruct cp_control cpc = {\n\t\t\t.reason = CP_UMOUNT,\n\t\t};\n\t\twrite_checkpoint(sbi, &cpc);\n\t}\n\tf2fs_wait_discard_bios(sbi);\n\tif (f2fs_discard_en(sbi) && !sbi->discard_blks) {\n\t\tstruct cp_control cpc = {\n\t\t\t.reason = CP_UMOUNT | CP_TRIMMED,\n\t\t};\n\t\twrite_checkpoint(sbi, &cpc);\n\t}\n\tf2fs_destroy_stats(sbi);\n\trelease_ino_entry(sbi, true);\n\tf2fs_leave_shrinker(sbi);\n\tmutex_unlock(&sbi->umount_mutex);\n\tf2fs_flush_merged_writes(sbi);\n\tiput(sbi->node_inode);\n\tiput(sbi->meta_inode);\n\tdestroy_node_manager(sbi);\n\tdestroy_segment_manager(sbi);\n\tkfree(sbi->ckpt);\n\tf2fs_unregister_sysfs(sbi);\n\tsb->s_fs_info = NULL;\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n\tkfree(sbi->raw_super);\n\tdestroy_device_list(sbi);\n\tmempool_destroy(sbi->write_io_dummy);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\tdestroy_percpu_info(sbi);\n\tfor (i = 0; i < NR_PAGE_TYPE; i++)\n\t\tkfree(sbi->write_io[i]);\n\tkfree(sbi);\n}", "target": 1}
{"code": "crm_send_remote_msg_raw(void *session, const char *buf, size_t len, gboolean encrypted)\n{\n    int rc = -1;\n    if (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        rc = crm_send_tls(session, buf, len);\n#else\n        CRM_ASSERT(encrypted == FALSE);\n#endif\n    } else {\n        rc = crm_send_plaintext(GPOINTER_TO_INT(session), buf, len);\n    }\n    return rc;\n}", "target": 0}
{"code": "webSocketsHasDataInBuffer(rfbClientPtr cl)\n{\n    ws_ctx_t *wsctx = (ws_ctx_t *)cl->wsctx;\n    if (wsctx && wsctx->readbuflen)\n      return TRUE;\n    return (cl->sslctx && rfbssl_pending(cl) > 0);\n}", "target": 1}
{"code": "bool UnbufferedAsioTlsStream::IsVerifyOK() const\n{\n\treturn m_VerifyOK;\n}", "target": 1}
{"code": "static int fetch_setup_walk(git_revwalk **out, git_repository *repo)\n{\n\tgit_revwalk *walk = NULL;\n\tgit_strarray refs;\n\tunsigned int i;\n\tgit_reference *ref;\n\tint error;\n\tif ((error = git_reference_list(&refs, repo)) < 0)\n\t\treturn error;\n\tif ((error = git_revwalk_new(&walk, repo)) < 0)\n\t\treturn error;\n\tgit_revwalk_sorting(walk, GIT_SORT_TIME);\n\tfor (i = 0; i < refs.count; ++i) {\n\t\tif (!git__prefixcmp(refs.strings[i], GIT_REFS_TAGS_DIR))\n\t\t\tcontinue;\n\t\tif ((error = git_reference_lookup(&ref, repo, refs.strings[i])) < 0)\n\t\t\tgoto on_error;\n\t\tif (git_reference_type(ref) == GIT_REF_SYMBOLIC)\n\t\t\tcontinue;\n\t\tif ((error = git_revwalk_push(walk, git_reference_target(ref))) < 0)\n\t\t\tgoto on_error;\n\t\tgit_reference_free(ref);\n\t}\n\tgit_strarray_free(&refs);\n\t*out = walk;\n\treturn 0;\non_error:\n\tgit_revwalk_free(walk);\n\tgit_reference_free(ref);\n\tgit_strarray_free(&refs);\n\treturn error;\n}", "target": 0}
{"code": "static int sanitize_ptr_alu(struct bpf_verifier_env *env,\n\t\t\t    struct bpf_insn *insn,\n\t\t\t    const struct bpf_reg_state *ptr_reg,\n\t\t\t    struct bpf_reg_state *dst_reg,\n\t\t\t    bool off_is_neg)\n{\n\tstruct bpf_verifier_state *vstate = env->cur_state;\n\tstruct bpf_insn_aux_data *aux = cur_aux(env);\n\tbool ptr_is_dst_reg = ptr_reg == dst_reg;\n\tu8 opcode = BPF_OP(insn->code);\n\tu32 alu_state, alu_limit;\n\tstruct bpf_reg_state tmp;\n\tbool ret;\n\tif (can_skip_alu_sanitation(env, insn))\n\t\treturn 0;\n\tif (vstate->speculative)\n\t\tgoto do_sim;\n\talu_state  = off_is_neg ? BPF_ALU_NEG_VALUE : 0;\n\talu_state |= ptr_is_dst_reg ?\n\t\t     BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST;\n\tif (retrieve_ptr_limit(ptr_reg, &alu_limit, opcode, off_is_neg))\n\t\treturn 0;\n\tif (update_alu_sanitation_state(aux, alu_state, alu_limit))\n\t\treturn -EACCES;\ndo_sim:\n\tif (!ptr_is_dst_reg) {\n\t\ttmp = *dst_reg;\n\t\t*dst_reg = *ptr_reg;\n\t}\n\tret = push_stack(env, env->insn_idx + 1, env->insn_idx, true);\n\tif (!ptr_is_dst_reg)\n\t\t*dst_reg = tmp;\n\treturn !ret ? -EFAULT : 0;\n}", "target": 0}
{"code": "static int get_filter(void __user *arg, struct sock_filter **p)\n{\n\tstruct sock_fprog uprog;\n\tstruct sock_filter *code = NULL;\n\tint len;\n\tif (copy_from_user(&uprog, arg, sizeof(uprog)))\n\t\treturn -EFAULT;\n\tif (!uprog.len) {\n\t\t*p = NULL;\n\t\treturn 0;\n\t}\n\tlen = uprog.len * sizeof(struct sock_filter);\n\tcode = memdup_user(uprog.filter, len);\n\tif (IS_ERR(code))\n\t\treturn PTR_ERR(code);\n\t*p = code;\n\treturn uprog.len;\n}", "target": 0}
{"code": "static int sr_write_reg(struct usbnet *dev, u8 reg, u8 value)\n{\n\treturn usbnet_write_cmd(dev, SR_WR_REGS, SR_REQ_WR_REG,\n\t\t\t\tvalue, reg, NULL, 0);\n}", "target": 0}
{"code": "auto ReferenceHandle::Get(Local<Value> key_handle, MaybeLocal<Object> maybe_options) -> Local<Value> {\n\treturn ThreePhaseTask::Run<async, GetRunner>(*isolate, *this, key_handle, maybe_options, inherit);\n}", "target": 1}
{"code": "R_API ut64 r_bin_java_element_pair_calc_size(RBinJavaElementValuePair *evp) {\n\tut64 sz = 0;\n\tif (evp == NULL) {\n\t\treturn sz;\n\t}\n\tsz += 2;\n\tif (evp->value) {\n\t\tsz += r_bin_java_element_value_calc_size (evp->value);\n\t}\n\treturn sz;\n}", "target": 1}
{"code": "static int evtchn_fifo_percpu_deinit(unsigned int cpu)\n{\n\t__evtchn_fifo_handle_events(cpu, true);\n\treturn 0;\n}", "target": 1}
{"code": "        int          GetU8    (int nPos, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            return m_sFile[ nPos ];\n        }", "target": 1}
{"code": "MagickExport void RemoveDuplicateLayers(Image **images,\n     ExceptionInfo *exception)\n{\n  register Image\n    *curr,\n    *next;\n  RectangleInfo\n    bounds;\n  assert((*images) != (const Image *) NULL);\n  assert((*images)->signature == MagickCoreSignature);\n  if ((*images)->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",(*images)->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  curr=GetFirstImageInList(*images);\n  for (; (next=GetNextImageInList(curr)) != (Image *) NULL; curr=next)\n  {\n    if ( curr->columns != next->columns || curr->rows != next->rows\n         || curr->page.x != next->page.x || curr->page.y != next->page.y )\n      continue;\n    bounds=CompareImagesBounds(curr,next,CompareAnyLayer,exception);\n    if ( bounds.x < 0 ) {\n      size_t time;\n      time = curr->delay*1000/curr->ticks_per_second;\n      time += next->delay*1000/next->ticks_per_second;\n      next->ticks_per_second = 100L;\n      next->delay = time*curr->ticks_per_second/1000;\n      next->iterations = curr->iterations;\n      *images = curr;\n      (void) DeleteImageFromList(images);\n    }\n  }\n  *images = GetFirstImageInList(*images);\n}", "target": 1}
{"code": "compute_U_value_R2(std::string const& user_password,\n\t\t   QPDF::EncryptionData const& data)\n{\n    std::string k1 = QPDF::compute_encryption_key(user_password, data);\n    char udata[key_bytes];\n    pad_or_truncate_password_V4(\"\", udata);\n    pad_short_parameter(k1, data.getLengthBytes());\n    iterate_rc4(QUtil::unsigned_char_pointer(udata), key_bytes,\n\t\tQUtil::unsigned_char_pointer(k1),\n                data.getLengthBytes(), 1, false);\n    return std::string(udata, key_bytes);\n}", "target": 0}
{"code": "int bridge__remap_topic_in(struct mosquitto *context, char **topic)\n{\n\tstruct mosquitto__bridge_topic *cur_topic;\n\tchar *topic_temp;\n\tint i;\n\tsize_t len;\n\tint rc;\n\tbool match;\n\tif(context->bridge && context->bridge->topics && context->bridge->topic_remapping){\n\t\tfor(i=0; i<context->bridge->topic_count; i++){\n\t\t\tcur_topic = &context->bridge->topics[i];\n\t\t\tif((cur_topic->direction == bd_both || cur_topic->direction == bd_in)\n\t\t\t\t\t&& (cur_topic->remote_prefix || cur_topic->local_prefix)){\n\t\t\t\trc = mosquitto_topic_matches_sub(cur_topic->remote_topic, *topic, &match);\n\t\t\t\tif(rc){\n\t\t\t\t\tmosquitto__free(*topic);\n\t\t\t\t\t*topic = NULL;\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\t\t\t\tif(match){\n\t\t\t\t\tif(cur_topic->remote_prefix){\n\t\t\t\t\t\tif(!strncmp(cur_topic->remote_prefix, *topic, strlen(cur_topic->remote_prefix))){\n\t\t\t\t\t\t\ttopic_temp = mosquitto__strdup((*topic)+strlen(cur_topic->remote_prefix));\n\t\t\t\t\t\t\tif(!topic_temp){\n\t\t\t\t\t\t\t\tmosquitto__free(*topic);\n\t\t\t\t\t\t\t\t*topic = NULL;\n\t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmosquitto__free(*topic);\n\t\t\t\t\t\t\t*topic = topic_temp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(cur_topic->local_prefix){\n\t\t\t\t\t\tlen = strlen(*topic) + strlen(cur_topic->local_prefix)+1;\n\t\t\t\t\t\ttopic_temp = mosquitto__malloc(len+1);\n\t\t\t\t\t\tif(!topic_temp){\n\t\t\t\t\t\t\tmosquitto__free(*topic);\n\t\t\t\t\t\t\t*topic = NULL;\n\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsnprintf(topic_temp, len, \"%s%s\", cur_topic->local_prefix, *topic);\n\t\t\t\t\t\ttopic_temp[len] = '\\0';\n\t\t\t\t\t\tmosquitto__free(*topic);\n\t\t\t\t\t\t*topic = topic_temp;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn MOSQ_ERR_SUCCESS;\n}", "target": 0}
{"code": "_dbus_lookup_session_address_launchd (DBusString *address, DBusError  *error)\n{\n  dbus_bool_t valid_socket;\n  DBusString socket_path;\n  if (_dbus_check_setuid ())\n    {\n      dbus_set_error_const (error, DBUS_ERROR_NOT_SUPPORTED,\n                            \"Unable to find launchd socket when setuid\");\n      return FALSE;\n    }\n  if (!_dbus_string_init (&socket_path))\n    {\n      _DBUS_SET_OOM (error);\n      return FALSE;\n    }\n  valid_socket = _dbus_lookup_launchd_socket (&socket_path, \"DBUS_LAUNCHD_SESSION_BUS_SOCKET\", error);\n  if (dbus_error_is_set(error))\n    {\n      _dbus_string_free(&socket_path);\n      return FALSE;\n    }\n  if (!valid_socket)\n    {\n      dbus_set_error(error, \"no socket path\",\n                \"launchd did not provide a socket path, \"\n                \"verify that org.freedesktop.dbus-session.plist is loaded!\");\n      _dbus_string_free(&socket_path);\n      return FALSE;\n    }\n  if (!_dbus_string_append (address, \"unix:path=\"))\n    {\n      _DBUS_SET_OOM (error);\n      _dbus_string_free(&socket_path);\n      return FALSE;\n    }\n  if (!_dbus_string_copy (&socket_path, 0, address,\n                          _dbus_string_get_length (address)))\n    {\n      _DBUS_SET_OOM (error);\n      _dbus_string_free(&socket_path);\n      return FALSE;\n    }\n  _dbus_string_free(&socket_path);\n  return TRUE;\n}", "target": 0}
{"code": "static int adpt_slave_configure(struct scsi_device * device)\n{\n\tstruct Scsi_Host *host = device->host;\n\tif (host->can_queue && device->tagged_supported) {\n\t\tscsi_change_queue_depth(device,\n\t\t\t\thost->can_queue - 1);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {\n\tRBuffer *fbuf = r_buf_ref (buf);\n\tstruct MACH0_(opts_t) opts;\n\tMACH0_(opts_set_default) (&opts, bf);\n\tstruct MACH0_(obj_t) *main_mach0 = MACH0_(new_buf) (fbuf, &opts);\n\tif (!main_mach0) {\n\t\treturn false;\n\t}\n\tRRebaseInfo *rebase_info = r_rebase_info_new_from_mach0 (fbuf, main_mach0);\n\tRKernelCacheObj *obj = NULL;\n\tRPrelinkRange *prelink_range = get_prelink_info_range_from_mach0 (main_mach0);\n\tif (!prelink_range) {\n\t\tgoto beach;\n\t}\n\tobj = R_NEW0 (RKernelCacheObj);\n\tif (!obj) {\n\t\tR_FREE (prelink_range);\n\t\tgoto beach;\n\t}\n\tRCFValueDict *prelink_info = NULL;\n\tif (main_mach0->hdr.filetype != MH_FILESET && prelink_range->range.size) {\n\t\tprelink_info = r_cf_value_dict_parse (fbuf, prelink_range->range.offset,\n\t\t\t\tprelink_range->range.size, R_CF_OPTION_SKIP_NSDATA);\n\t\tif (!prelink_info) {\n\t\t\tR_FREE (prelink_range);\n\t\t\tR_FREE (obj);\n\t\t\tgoto beach;\n\t\t}\n\t}\n\tif (!pending_bin_files) {\n\t\tpending_bin_files = r_list_new ();\n\t\tif (!pending_bin_files) {\n\t\t\tR_FREE (prelink_range);\n\t\t\tR_FREE (obj);\n\t\t\tR_FREE (prelink_info);\n\t\t\tgoto beach;\n\t\t}\n\t}\n\tobj->mach0 = main_mach0;\n\tobj->rebase_info = rebase_info;\n\tobj->prelink_info = prelink_info;\n\tobj->cache_buf = fbuf;\n\tobj->pa2va_exec = prelink_range->pa2va_exec;\n\tobj->pa2va_data = prelink_range->pa2va_data;\n\tR_FREE (prelink_range);\n\t*bin_obj = obj;\n\tr_list_push (pending_bin_files, bf);\n\tif (rebase_info || main_mach0->chained_starts) {\n\t\tRIO *io = bf->rbin->iob.io;\n\t\tswizzle_io_read (obj, io);\n\t}\n\treturn true;\nbeach:\n\tr_buf_free (fbuf);\n\tobj->cache_buf = NULL;\n\tMACH0_(mach0_free) (main_mach0);\n\treturn false;\n}", "target": 1}
{"code": "static int cdc_ncm_bind(struct usbnet *dev, struct usb_interface *intf)\n{\n\tint ret;\n\tif (cdc_ncm_select_altsetting(intf) != CDC_NCM_COMM_ALTSETTING_NCM)\n\t\treturn -ENODEV;\n\tret = cdc_ncm_bind_common(dev, intf, CDC_NCM_DATA_ALTSETTING_NCM, 0);\n\tusbnet_link_change(dev, 0, 0);\n\treturn ret;\n}", "target": 1}
{"code": "void arch_pick_mmap_layout(struct mm_struct *mm)\n{\n\tunsigned long random_factor = 0UL;\n\tif (current->flags & PF_RANDOMIZE)\n\t\trandom_factor = arch_mmap_rnd();\n\tmm->mmap_legacy_base = mmap_legacy_base(random_factor);\n\tif (mmap_is_legacy()) {\n\t\tmm->mmap_base = mm->mmap_legacy_base;\n\t\tmm->get_unmapped_area = arch_get_unmapped_area;\n\t} else {\n\t\tmm->mmap_base = mmap_base(random_factor);\n\t\tmm->get_unmapped_area = arch_get_unmapped_area_topdown;\n\t}\n}", "target": 1}
{"code": "int rds_rdma_extra_size(struct rds_rdma_args *args)\n{\n\tstruct rds_iovec vec;\n\tstruct rds_iovec __user *local_vec;\n\tint tot_pages = 0;\n\tunsigned int nr_pages;\n\tunsigned int i;\n\tlocal_vec = (struct rds_iovec __user *)(unsigned long) args->local_vec_addr;\n\tif (args->nr_local == 0)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < args->nr_local; i++) {\n\t\tif (copy_from_user(&vec, &local_vec[i],\n\t\t\t\t   sizeof(struct rds_iovec)))\n\t\t\treturn -EFAULT;\n\t\tnr_pages = rds_pages_in_vec(&vec);\n\t\tif (nr_pages == 0)\n\t\t\treturn -EINVAL;\n\t\ttot_pages += nr_pages;\n\t\tif (tot_pages < 0)\n\t\t\treturn -EINVAL;\n\t}\n\treturn tot_pages * sizeof(struct scatterlist);\n}", "target": 0}
{"code": "merge_agg_lats_step (class ipcp_param_lattices *dest_plats,\n\t\t     HOST_WIDE_INT offset, HOST_WIDE_INT val_size,\n\t\t     struct ipcp_agg_lattice ***aglat,\n\t\t     bool pre_existing, bool *change)\n{\n  gcc_checking_assert (offset >= 0);\n  while (**aglat && (**aglat)->offset < offset)\n    {\n      if ((**aglat)->offset + (**aglat)->size > offset)\n\t{\n\t  set_agg_lats_to_bottom (dest_plats);\n\t  return false;\n\t}\n      *change |= (**aglat)->set_contains_variable ();\n      *aglat = &(**aglat)->next;\n    }\n  if (**aglat && (**aglat)->offset == offset)\n    {\n      if ((**aglat)->size != val_size)\n\t{\n\t  set_agg_lats_to_bottom (dest_plats);\n\t  return false;\n\t}\n      gcc_assert (!(**aglat)->next\n\t\t  || (**aglat)->next->offset >= offset + val_size);\n      return true;\n    }\n  else\n    {\n      struct ipcp_agg_lattice *new_al;\n      if (**aglat && (**aglat)->offset < offset + val_size)\n\t{\n\t  set_agg_lats_to_bottom (dest_plats);\n\t  return false;\n\t}\n      if (dest_plats->aggs_count == param_ipa_max_agg_items)\n\treturn false;\n      dest_plats->aggs_count++;\n      new_al = ipcp_agg_lattice_pool.allocate ();\n      memset (new_al, 0, sizeof (*new_al));\n      new_al->offset = offset;\n      new_al->size = val_size;\n      new_al->contains_variable = pre_existing;\n      new_al->next = **aglat;\n      **aglat = new_al;\n      return true;\n    }\n}", "target": 0}
{"code": "mark_trusted_task_thread_func (GTask        *task,\n                               gpointer      source_object,\n                               gpointer      task_data,\n                               GCancellable *cancellable)\n{\n    MarkTrustedJob *job = task_data;\n    CommonJob *common;\n    common = (CommonJob *) job;\n    nautilus_progress_info_start (job->common.progress);\n    mark_desktop_file_trusted (common,\n                               cancellable,\n                               job->file,\n                               job->interactive);\n}", "target": 1}
{"code": "void gru_check_context_placement(struct gru_thread_state *gts)\n{\n\tstruct gru_state *gru;\n\tgru = gts->ts_gru;\n\tif (!gru || gts->ts_tgid_owner != current->tgid)\n\t\treturn;\n\tif (!gru_check_chiplet_assignment(gru, gts)) {\n\t\tSTAT(check_context_unload);\n\t\tgru_unload_context(gts, 1);\n\t} else if (gru_retarget_intr(gts)) {\n\t\tSTAT(check_context_retarget_intr);\n\t}\n}", "target": 1}
{"code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  TfLiteType output_type = GetOutput(context, node, kOutputTensor)->type;\n  switch (output_type) {  \n    case kTfLiteFloat32:\n      EvalUnquantized<float>(context, node);\n      break;\n    case kTfLiteInt32:\n      EvalUnquantized<int32_t>(context, node);\n      break;\n    case kTfLiteUInt8:\n      EvalQuantizedUInt8(context, node);\n      break;\n    case kTfLiteInt8:\n      EvalUnquantized<int8_t>(context, node);\n      break;\n    case kTfLiteInt64:\n      EvalUnquantized<int64_t>(context, node);\n      break;\n    default:\n      TF_LITE_KERNEL_LOG(\n          context, \"Op Concatenation does not currently support Type '%s'.\",\n          TfLiteTypeGetName(output_type));\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "pci_lintr_deassert(struct pci_vdev *dev)\n{\n\tassert(dev->lintr.pin > 0);\n\tpthread_mutex_lock(&dev->lintr.lock);\n\tif (dev->lintr.state == ASSERTED) {\n\t\tdev->lintr.state = IDLE;\n\t\tpci_irq_deassert(dev);\n\t} else if (dev->lintr.state == PENDING)\n\t\tdev->lintr.state = IDLE;\n\tpthread_mutex_unlock(&dev->lintr.lock);\n}", "target": 1}
{"code": "subscription_update (subscriptionPtr subscription, guint flags)\n{\n\tUpdateRequest\t*request;\n\tguint64\t\tnow;\n\tguint\t\tcount, maxcount;\n\tif (!subscription)\n\t\treturn;\n\tif (subscription->updateJob)\n\t\treturn;\n\tdebug1 (DEBUG_UPDATE, \"Scheduling %s to be updated\", node_get_title (subscription->node));\n\tif (subscription_can_be_updated (subscription)) {\n\t\tnow = g_get_real_time();\n\t\tsubscription_reset_update_counter (subscription, &now);\n\t\trequest = update_request_new (\n\t\t\tsubscription_get_source (subscription),\n\t\t\tsubscription->updateState,\n\t\t\tsubscription->updateOptions\n\t\t);\n\t\tupdate_request_allow_commands (request, TRUE);\n\t\tif (subscription_get_filter (subscription))\n\t\t\trequest->filtercmd = g_strdup (subscription_get_filter (subscription));\n\t\tif (SUBSCRIPTION_TYPE (subscription)->prepare_update_request (subscription, request))\n\t\t\tsubscription->updateJob = update_execute_request (subscription, request, subscription_process_update_result, subscription, flags);\n\t\telse\n\t\t\tg_object_unref (request);\n\t\tupdate_jobs_get_count (&count, &maxcount);\n\t\tif (count > 1)\n\t\t\tliferea_shell_set_status_bar (_(\"Updating (%d / %d) ...\"), maxcount - count, maxcount);\n\t\telse\n\t\t\tliferea_shell_set_status_bar (_(\"Updating '%s'...\"), node_get_title (subscription->node));\n\t}\n}", "target": 0}
{"code": "void* sspi_SecureHandleGetUpperPointer(SecHandle* handle)\n{\n\tvoid* pointer;\n\tif (!handle)\n\t\treturn NULL;\n\tpointer = (void*) ~((size_t) handle->dwUpper);\n\treturn pointer;\n}", "target": 1}
{"code": "inline typename V::VectorType FBUnserializer<V>::unserializeList() {\n  p_ += CODE_SIZE;\n  unserializeInt64();\n  typename V::VectorType ret = V::createVector();\n  size_t code = nextCode();\n  while (code != FB_SERIALIZE_STOP) {\n    V::vectorAppend(ret, unserializeThing());\n    code = nextCode();\n  }\n  p_ += CODE_SIZE;\n  return ret;\n}", "target": 1}
{"code": "static u_int mp_dss_len(const  struct mp_dss *m, int csum)\n{\n        u_int len;\n        len = 4;\n        if (m->flags & MP_DSS_A) {\n                len += (m->flags & MP_DSS_a) ? 8 : 4;\n        }\n        if (m->flags & MP_DSS_M) {\n                len += (m->flags & MP_DSS_m) ? 14 : 10;\n                if (csum)\n                        len += 2;\n\t}\n\treturn len;\n}", "target": 1}
{"code": "RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {\n\tint i;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_list_newf (free);\n\tfor (i = 0; i < bin->ne_header->SegCount; i++) {\n\t\tRBinSection *bs = R_NEW0 (RBinSection);\n\t\tNE_image_segment_entry *se = &bin->segment_entries[i];\n\t\tif (!bs) {\n\t\t\treturn segments;\n\t\t}\n\t\tbs->size = se->length;\n\t\tbs->vsize = se->minAllocSz ? se->minAllocSz : 64000;\n\t\tbs->bits = R_SYS_BITS_16;\n\t\tbs->is_data = se->flags & IS_DATA;\n\t\tbs->perm = __translate_perms (se->flags);\n\t\tbs->paddr = (ut64)se->offset * bin->alignment;\n\t\tbs->name = r_str_newf (\"%s.%\" PFMT64d, se->flags & IS_MOVEABLE ? \"MOVEABLE\" : \"FIXED\", bs->paddr);\n\t\tbs->is_segment = true;\n\t\tr_list_append (segments, bs);\n\t}\n\tbin->segments = segments;\n\treturn segments;\n}", "target": 1}
{"code": "static inline ut16 r_read_at_le16(const void *src, size_t offset) {\n\tif (!src) {\n\t\treturn UT16_MAX;\n\t}\n\tconst ut8 *s = (const ut8*)src + offset;\n\treturn r_read_le16 (s);\n}", "target": 0}
{"code": "passGetEmphasis ()\n{\n  int more = 1;\n  passLinepos++;\n  passEmphasis = 0;\n  while (more)\n    {\n      switch (passLine.chars[passLinepos])\n\t{\n\tcase 'i':\n\t  passEmphasis |= italic;\n\t  break;\n\tcase 'b':\n\t  passEmphasis |= bold;\n\t  break;\n\tcase 'u':\n\t  passEmphasis |= underline;\n\t  break;\n\tcase 'c':\n\t  passEmphasis |= computer_braille;\n\t  break;\n\tdefault:\n\t  more = 0;\n\t  break;\n\t}\n      if (more)\n\tpassLinepos++;\n    }\n  if (!passEmphasis)\n    {\n      compileError (passNested, \"emphasis indicators expected\");\n      passLinepos--;\n      return 0;\n    }\n  return 1;\n}", "target": 0}
{"code": "static inline int quic_token_validate(struct quic_rx_packet *pkt,\n                                      struct quic_dgram *dgram,\n                                      struct listener *l, struct quic_conn *qc,\n                                      struct quic_cid *odcid)\n{\n\tint ret = 0;\n\tTRACE_ENTER(QUIC_EV_CONN_LPKT, qc);\n\tswitch (*pkt->token) {\n\tcase QUIC_TOKEN_FMT_RETRY:\n\t\tret = quic_retry_token_check(pkt, dgram, l, qc, odcid);\n\t\tbreak;\n\tcase QUIC_TOKEN_FMT_NEW:\n\t\tret = quic_token_check(pkt, dgram, qc);\n\t\tif (!ret) {\n\t\t\tdgram->flags |= QUIC_DGRAM_FL_SEND_RETRY;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tTRACE_PROTO(\"Packet dropped\", QUIC_EV_CONN_LPKT, qc, NULL, NULL, pkt->version);\n\t\tbreak;\n\t}\n\tif (!ret)\n\t\tgoto err;\n\tret = 1;\n leave:\n\tTRACE_LEAVE(QUIC_EV_CONN_LPKT, qc);\n\treturn ret;\n err:\n\tTRACE_DEVEL(\"leaving in error\", QUIC_EV_CONN_LPKT, qc);\n\tgoto leave;\n}", "target": 0}
{"code": "static int decode_unit(SCPRContext *s, PixelModel *pixel, unsigned step, unsigned *rval)\n{\n    GetByteContext *gb = &s->gb;\n    RangeCoder *rc = &s->rc;\n    unsigned totfr = pixel->total_freq;\n    unsigned value, x = 0, cumfr = 0, cnt_x = 0;\n    int i, j, ret, c, cnt_c;\n    if ((ret = s->get_freq(rc, totfr, &value)) < 0)\n        return ret;\n    while (x < 16) {\n        cnt_x = pixel->lookup[x];\n        if (value >= cumfr + cnt_x)\n            cumfr += cnt_x;\n        else\n            break;\n        x++;\n    }\n    c = x * 16;\n    cnt_c = 0;\n    while (c < 256) {\n        cnt_c = pixel->freq[c];\n        if (value >= cumfr + cnt_c)\n            cumfr += cnt_c;\n        else\n            break;\n        c++;\n    }\n    if (x >= 16 || c >= 256) {\n        return AVERROR_INVALIDDATA;\n    }\n    if ((ret = s->decode(gb, rc, cumfr, cnt_c, totfr)) < 0)\n        return ret;\n    pixel->freq[c] = cnt_c + step;\n    pixel->lookup[x] = cnt_x + step;\n    totfr += step;\n    if (totfr > BOT) {\n        totfr = 0;\n        for (i = 0; i < 256; i++) {\n            unsigned nc = (pixel->freq[i] >> 1) + 1;\n            pixel->freq[i] = nc;\n            totfr += nc;\n        }\n        for (i = 0; i < 16; i++) {\n            unsigned sum = 0;\n            unsigned i16_17 = i << 4;\n            for (j = 0; j < 16; j++)\n                sum += pixel->freq[i16_17 + j];\n            pixel->lookup[i] = sum;\n        }\n    }\n    pixel->total_freq = totfr;\n    *rval = c & s->cbits;\n    return 0;\n}", "target": 0}
{"code": "static int su3000_power_ctrl(struct dvb_usb_device *d, int i)\n{\n\tstruct dw2102_state *state = (struct dw2102_state *)d->priv;\n\tu8 obuf[] = {0xde, 0};\n\tinfo(\"%s: %d, initialized %d\", __func__, i, state->initialized);\n\tif (i && !state->initialized) {\n\t\tstate->initialized = 1;\n\t\treturn dvb_usb_generic_rw(d, obuf, 2, NULL, 0, 0);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "GF_EXPORT\nGF_Err gf_isom_box_write(GF_Box *a, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu64 pos = gf_bs_get_position(bs);\n\tif (!a) return GF_BAD_PARAM;\n\tif (!a->size) return GF_OK;\n\tif (a->registry->disabled) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s disabled registry, skip write\\n\", gf_4cc_to_str(a->type)));\n\t\treturn GF_OK;\n\t}\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s size %d write\\n\", gf_4cc_to_str(a->type), a->size));\n\te = gf_isom_box_write_listing(a, bs);\n\tif (e) return e;\n\tif (a->child_boxes) {\n\t\te = gf_isom_box_array_write(a, a->child_boxes, bs);\n\t}\n\tpos = gf_bs_get_position(bs) - pos;\n\tif (pos != a->size) {\n\t\tif (a->type != GF_ISOM_BOX_TYPE_MDAT) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box %s wrote \"LLU\" bytes but size is \"LLU\"\\n\", gf_4cc_to_str(a->type), pos, a->size ));\n\t\t}\n\t}\n\treturn e;", "target": 1}
{"code": "static TEE_Result do_alloc_keypair(struct ecc_keypair *s, uint32_t type,\n\t\t\t\t   size_t size_bits __unused)\n{\n\tif (type != TEE_TYPE_ECDSA_KEYPAIR &&\n\t    type != TEE_TYPE_ECDH_KEYPAIR)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->d))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->x))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->d);\n\tcrypto_bignum_free(s->x);\n\tcrypto_bignum_free(s->y);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "coolkey_get_attribute_bytes(sc_card_t *card, sc_cardctl_coolkey_object_t *obj, CK_ATTRIBUTE_TYPE type, u8 *data, size_t *data_len, size_t max_data_len)\n{\n\tconst u8 *val;\n\tsize_t val_len;\n\tint r;\n\tr = coolkey_get_attribute(card, obj, type, &val, &val_len, NULL);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\tif (val_len > max_data_len) {\n\t\tval_len = max_data_len;\n\t}\n\tmemcpy(data, val, val_len);\n\t*data_len = val_len;\n\treturn SC_SUCCESS;\n}", "target": 0}
{"code": "mm_sshpam_init_ctx(Authctxt *authctxt)\n{\n\tBuffer m;\n\tint success;\n\tdebug3(\"%s\", __func__);\n\tbuffer_init(&m);\n\tbuffer_put_cstring(&m, authctxt->user);\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_PAM_INIT_CTX, &m);\n\tdebug3(\"%s: waiting for MONITOR_ANS_PAM_INIT_CTX\", __func__);\n\tmm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_PAM_INIT_CTX, &m);\n\tsuccess = buffer_get_int(&m);\n\tif (success == 0) {\n\t\tdebug3(\"%s: pam_init_ctx failed\", __func__);\n\t\tbuffer_free(&m);\n\t\treturn (NULL);\n\t}\n\tbuffer_free(&m);\n\treturn (authctxt);\n}", "target": 1}
{"code": "int con_set_default_unimap(struct vc_data *vc)\n{\n\tint i, j, err = 0, err1;\n\tu16 *q;\n\tstruct uni_pagedir *p;\n\tif (dflt) {\n\t\tp = *vc->vc_uni_pagedir_loc;\n\t\tif (p == dflt)\n\t\t\treturn 0;\n\t\tdflt->refcount++;\n\t\t*vc->vc_uni_pagedir_loc = dflt;\n\t\tif (p && !--p->refcount) {\n\t\t\tcon_release_unimap(p);\n\t\t\tkfree(p);\n\t\t}\n\t\treturn 0;\n\t}\n\terr = con_do_clear_unimap(vc);\n\tif (err)\n\t\treturn err;\n\tp = *vc->vc_uni_pagedir_loc;\n\tq = dfont_unitable;\n\tfor (i = 0; i < 256; i++)\n\t\tfor (j = dfont_unicount[i]; j; j--) {\n\t\t\terr1 = con_insert_unipair(p, *(q++), i);\n\t\t\tif (err1)\n\t\t\t\terr = err1;\n\t\t}\n\tif (con_unify_unimap(vc, p)) {\n\t\tdflt = *vc->vc_uni_pagedir_loc;\n\t\treturn err;\n\t}\n\tfor (i = 0; i <= 3; i++)\n\t\tset_inverse_transl(vc, p, i);\t\n\tset_inverse_trans_unicode(vc, p);\n\tdflt = p;\n\treturn err;\n}", "target": 0}
{"code": "Status ValidateInputs(const Tensor *a_indices, const Tensor *a_values,\n                      const Tensor *a_shape, const Tensor *b) {\n  if (!TensorShapeUtils::IsMatrix(a_indices->shape())) {\n    return errors::InvalidArgument(\n        \"Input a_indices should be a matrix but received shape: \",\n        a_indices->shape().DebugString());\n  }\n  if (!TensorShapeUtils::IsVector(a_values->shape()) ||\n      !TensorShapeUtils::IsVector(a_shape->shape())) {\n    return errors::InvalidArgument(\n        \"Inputs a_values and a_shape should be vectors \"\n        \"but received shapes: \",\n        a_values->shape().DebugString(), \" and \",\n        a_shape->shape().DebugString());\n  }\n  int64_t nnz = a_indices->dim_size(0);\n  int64_t ndims = a_indices->dim_size(1);\n  if (a_values->dim_size(0) != nnz) {\n    return errors::InvalidArgument(\"Dimensions \", nnz, \" and \",\n                                   a_values->dim_size(0),\n                                   \" are not compatible\");\n  }\n  if (a_shape->dim_size(0) != ndims) {\n    return errors::InvalidArgument(\"Dimensions \", ndims, \" and \",\n                                   a_shape->dim_size(0), \" are not compatible\");\n  }\n  if (a_shape->NumElements() != b->dims()) {\n    return errors::InvalidArgument(\n        \"Two operands have different ranks; received: \", a_shape->NumElements(),\n        \" and \", b->dims());\n  }\n  const auto a_shape_flat = a_shape->flat<Index>();\n  for (int i = 0; i < b->dims(); ++i) {\n    if (a_shape_flat(i) != b->dim_size(i)) {\n      return errors::InvalidArgument(\n          \"Dimension \", i,\n          \" does not equal (no broadcasting is supported): sparse side \",\n          a_shape_flat(i), \" vs dense side \", b->dim_size(i));\n    }\n  }\n  const auto a_indices_mat = a_indices->flat_inner_dims<Index>();\n  for (int64_t zidx = 0; zidx < nnz; ++zidx) {\n    for (int64_t didx = 0; didx < ndims; ++didx) {\n      const Index idx = a_indices_mat(zidx, didx);\n      if (idx < 0 || idx >= a_shape_flat(didx)) {\n        return errors::InvalidArgument(\n            \"Sparse tensor has an invalid index on dimension \", didx,\n            \": \"\n            \"a_indices(\",\n            zidx, \",\", didx, \") = \", idx,\n            \", dense tensor shape: \", a_shape_flat);\n      }\n    }\n  }\n  return Status::OK();\n}", "target": 0}
{"code": "njs_promise_perform_all_handler(njs_vm_t *vm, njs_iterator_args_t *args,\n    njs_value_t *value, int64_t index)\n{\n    njs_int_t                    ret;\n    njs_array_t                  *array;\n    njs_value_t                  arguments[2], next;\n    njs_function_t               *on_fulfilled;\n    njs_promise_capability_t     *capability;\n    njs_promise_all_context_t    *context;\n    njs_promise_iterator_args_t  *pargs;\n    if (!njs_is_valid(value)) {\n        value = njs_value_arg(&njs_value_undefined);\n    }\n    pargs = (njs_promise_iterator_args_t *) args;\n    capability = pargs->capability;\n    array = args->data;\n    njs_set_undefined(&array->start[index]);\n    ret = njs_function_call(vm, pargs->function, pargs->constructor, value,\n                            1, &next);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n    on_fulfilled = njs_promise_create_function(vm,\n                                            sizeof(njs_promise_all_context_t));\n    if (njs_slow_path(on_fulfilled == NULL)) {\n        return NJS_ERROR;\n    }\n    on_fulfilled->u.native = njs_promise_all_resolve_element_functions;\n    on_fulfilled->args_count = 1;\n    context = on_fulfilled->context;\n    context->already_called = 0;\n    context->index = (uint32_t) index;\n    context->values = pargs->args.data;\n    context->capability = capability;\n    context->remaining_elements = pargs->remaining;\n    (*pargs->remaining)++;\n    njs_set_function(&arguments[0], on_fulfilled);\n    arguments[1] = capability->reject;\n    ret = njs_promise_invoke_then(vm, &next, arguments, 2);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n    return NJS_OK;\n}", "target": 0}
{"code": "int bprm_change_interp(char *interp, struct linux_binprm *bprm)\n{\n\tif (bprm->interp != bprm->filename)\n\t\tkfree(bprm->interp);\n\tbprm->interp = kstrdup(interp, GFP_KERNEL);\n\tif (!bprm->interp)\n\t\treturn -ENOMEM;\n\treturn 0;\n}", "target": 0}
{"code": "static void expire_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq->tg);\n\tif (likely((s64)(rq_clock(rq_of(cfs_rq)) - cfs_rq->runtime_expires) < 0))\n\t\treturn;\n\tif (cfs_rq->runtime_remaining < 0)\n\t\treturn;\n\tif (cfs_rq->expires_seq == cfs_b->expires_seq) {\n\t\tcfs_rq->runtime_expires += TICK_NSEC;\n\t} else {\n\t\tcfs_rq->runtime_remaining = 0;\n\t}\n}", "target": 1}
{"code": "comics_document_render (EvDocument      *document,\n\t\t\tEvRenderContext *rc)\n{\n\tGdkPixbuf       *pixbuf;\n\tcairo_surface_t *surface;\n\tpixbuf = comics_document_render_pixbuf (document, rc);\n\tsurface = ev_document_misc_surface_from_pixbuf (pixbuf);\n\tg_object_unref (pixbuf);\n\treturn surface;\n}", "target": 1}
{"code": "void ZydisFormatterBufferInit(ZydisFormatterBuffer* buffer, char* user_buffer,\n    ZyanUSize length)\n{\n    ZYAN_ASSERT(buffer);\n    ZYAN_ASSERT(user_buffer);\n    ZYAN_ASSERT(length);\n    buffer->is_token_list              = ZYAN_FALSE;\n    buffer->string.flags               = ZYAN_STRING_HAS_FIXED_CAPACITY;\n    buffer->string.vector.allocator    = ZYAN_NULL;\n    buffer->string.vector.element_size = sizeof(char);\n    buffer->string.vector.size         = 1;\n    buffer->string.vector.capacity     = length;\n    buffer->string.vector.data         = user_buffer;\n    *user_buffer = '\\0';\n}", "target": 1}
{"code": "static u8 adpt_read_blink_led(adpt_hba* host)\n{\n\tif (host->FwDebugBLEDflag_P) {\n\t\tif( readb(host->FwDebugBLEDflag_P) == 0xbc ){\n\t\t\treturn readb(host->FwDebugBLEDvalue_P);\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "    const std::unordered_map<std::string, std::string> &getParameters() const\n    {\n        return parameters();\n    }", "target": 1}
{"code": "void sctp_association_free(struct sctp_association *asoc)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tstruct sctp_transport *transport;\n\tstruct list_head *pos, *temp;\n\tint i;\n\tif (!asoc->temp) {\n\t\tlist_del(&asoc->asocs);\n\t\tif (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING))\n\t\t\tsk->sk_ack_backlog--;\n\t}\n\tasoc->base.dead = true;\n\tsctp_outq_free(&asoc->outqueue);\n\tsctp_ulpq_free(&asoc->ulpq);\n\tsctp_inq_free(&asoc->base.inqueue);\n\tsctp_tsnmap_free(&asoc->peer.tsn_map);\n\tsctp_ssnmap_free(asoc->ssnmap);\n\tsctp_bind_addr_free(&asoc->base.bind_addr);\n\tfor (i = SCTP_EVENT_TIMEOUT_NONE; i < SCTP_NUM_TIMEOUT_TYPES; ++i) {\n\t\tif (del_timer(&asoc->timers[i]))\n\t\t\tsctp_association_put(asoc);\n\t}\n\tkfree(asoc->peer.cookie);\n\tkfree(asoc->peer.peer_random);\n\tkfree(asoc->peer.peer_chunks);\n\tkfree(asoc->peer.peer_hmacs);\n\tlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\n\t\ttransport = list_entry(pos, struct sctp_transport, transports);\n\t\tlist_del_rcu(pos);\n\t\tsctp_transport_free(transport);\n\t}\n\tasoc->peer.transport_count = 0;\n\tsctp_asconf_queue_teardown(asoc);\n\tif (asoc->asconf_addr_del_pending != NULL)\n\t\tkfree(asoc->asconf_addr_del_pending);\n\tsctp_auth_destroy_keys(&asoc->endpoint_shared_keys);\n\tsctp_auth_key_put(asoc->asoc_shared_key);\n\tsctp_association_put(asoc);\n}", "target": 1}
{"code": "\t__must_hold(&ctx->completion_lock)\n{\n\tu32 seq = ctx->cached_cq_tail - atomic_read(&ctx->cq_timeouts);\n\tspin_lock_irq(&ctx->timeout_lock);\n\twhile (!list_empty(&ctx->timeout_list)) {\n\t\tu32 events_needed, events_got;\n\t\tstruct io_kiocb *req = list_first_entry(&ctx->timeout_list,\n\t\t\t\t\t\tstruct io_kiocb, timeout.list);\n\t\tif (io_is_timeout_noseq(req))\n\t\t\tbreak;\n\t\tevents_needed = req->timeout.target_seq - ctx->cq_last_tm_flush;\n\t\tevents_got = seq - ctx->cq_last_tm_flush;\n\t\tif (events_got < events_needed)\n\t\t\tbreak;\n\t\tlist_del_init(&req->timeout.list);\n\t\tio_kill_timeout(req, 0);\n\t}\n\tctx->cq_last_tm_flush = seq;\n\tspin_unlock_irq(&ctx->timeout_lock);\n}", "target": 1}
{"code": "static int init_strtab(ELFOBJ *bin) {\n\tr_return_val_if_fail (!bin->strtab, false);\n\tif (!bin->shdr) {\n\t\treturn false;\n\t}\n\tElf_(Half) shstrndx = bin->ehdr.e_shstrndx;\n\tif (shstrndx != SHN_UNDEF && !is_shidx_valid (bin, shstrndx)) {\n\t\treturn false;\n\t}\n\tif (bin->shdr[shstrndx].sh_size > UT32_MAX) {\n\t\treturn false;\n\t}\n\tif (!bin->shdr[shstrndx].sh_size) {\n\t\treturn false;\n\t}\n\tbin->shstrtab_section = bin->strtab_section = &bin->shdr[shstrndx];\n\tbin->shstrtab_size = bin->shstrtab_section->sh_size;\n\tif (bin->shstrtab_size > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->shstrtab_section->sh_offset > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->shstrtab_section->sh_offset + bin->shstrtab_section->sh_size > bin->size) {\n\t\treturn false;\n\t}\n\tif (!(bin->shstrtab = calloc (1, bin->shstrtab_size + 1))) {\n\t\tr_sys_perror (\"malloc\");\n\t\tbin->shstrtab = NULL;\n\t\treturn false;\n\t}\n\tint res = r_buf_read_at (bin->b, bin->shstrtab_section->sh_offset, (ut8*)bin->shstrtab,\n\t\tbin->shstrtab_section->sh_size);\n\tif (res < 1) {\n\t\tR_LOG_ERROR (\"read (shstrtab) at 0x%\" PFMT64x, (ut64) bin->shstrtab_section->sh_offset);\n\t\tR_FREE (bin->shstrtab);\n\t\treturn false;\n\t}\n\tbin->shstrtab[bin->shstrtab_section->sh_size] = '\\0';\n\tsdb_num_set (bin->kv, \"elf_shstrtab.offset\", bin->shstrtab_section->sh_offset, 0);\n\tsdb_num_set (bin->kv, \"elf_shstrtab.size\", bin->shstrtab_section->sh_size, 0);\n\treturn true;\n}", "target": 1}
{"code": "int ip6_mroute_getsockopt(struct sock *sk, int optname, char __user *optval,\n\t\t\t  int __user *optlen)\n{\n\tint olr;\n\tint val;\n\tstruct net *net = sock_net(sk);\n\tstruct mr6_table *mrt;\n\tif (sk->sk_type != SOCK_RAW ||\n\t    inet_sk(sk)->inet_num != IPPROTO_ICMPV6)\n\t\treturn -EOPNOTSUPP;\n\tmrt = ip6mr_get_table(net, raw6_sk(sk)->ip6mr_table ? : RT6_TABLE_DFLT);\n\tif (!mrt)\n\t\treturn -ENOENT;\n\tswitch (optname) {\n\tcase MRT6_VERSION:\n\t\tval = 0x0305;\n\t\tbreak;\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tcase MRT6_PIM:\n\t\tval = mrt->mroute_do_pim;\n\t\tbreak;\n#endif\n\tcase MRT6_ASSERT:\n\t\tval = mrt->mroute_do_assert;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\tif (get_user(olr, optlen))\n\t\treturn -EFAULT;\n\tolr = min_t(int, olr, sizeof(int));\n\tif (olr < 0)\n\t\treturn -EINVAL;\n\tif (put_user(olr, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, olr))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 0}
{"code": "static void encode_share_access(struct xdr_stream *xdr, int open_flags)\n{\n\t__be32 *p;\n\tRESERVE_SPACE(8);\n\tswitch (open_flags & (FMODE_READ|FMODE_WRITE)) {\n\t\tcase FMODE_READ:\n\t\t\tWRITE32(NFS4_SHARE_ACCESS_READ);\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tWRITE32(NFS4_SHARE_ACCESS_WRITE);\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tWRITE32(NFS4_SHARE_ACCESS_BOTH);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\tWRITE32(0);\t\t\n}", "target": 1}
{"code": "static int off_nominal_sync_run(struct ast_test *test, const char *domain, int rr_type,\n\t\tint rr_class, int expected_rcode)\n{\n\tstruct ast_dns_result *result;\n\tint res = 0;\n\tif (ast_dns_resolve(domain, rr_type, rr_class, &result)) {\n\t\tast_test_status_update(test, \"Failed to perform resolution :(\\n\");\n\t\treturn -1;\n\t}\n\tif (!result) {\n\t\tast_test_status_update(test, \"Resolution returned no result\\n\");\n\t\treturn -1;\n\t}\n\tif (ast_dns_result_get_rcode(result) != expected_rcode) {\n\t\tast_test_status_update(test, \"Unexpected rcode from DNS resolution\\n\");\n\t\tres = -1;\n\t}\n\tif (ast_dns_result_get_records(result)) {\n\t\tast_test_status_update(test, \"DNS resolution returned records unexpectedly\\n\");\n\t\tres = -1;\n\t}\n\tast_dns_result_free(result);\n\treturn res;\n}", "target": 1}
{"code": "ext2_xattr_put_super(struct super_block *sb)\n{\n\tmb_cache_shrink(sb->s_bdev);\n}", "target": 1}
{"code": "ssize_t enc_untrusted_recvmsg(int sockfd, struct msghdr *msg, int flags) {\n  size_t total_buffer_size = CalculateTotalMessageSize(msg);\n  MessageWriter input;\n  input.Push(sockfd);\n  input.Push<uint64_t>(msg->msg_namelen);\n  input.Push<uint64_t>(total_buffer_size);\n  input.Push<uint64_t>(msg->msg_controllen);\n  input.Push(msg->msg_flags);\n  input.Push(flags);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kRecvMsgHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_recvmsg\", 2,\n                           false);\n  ssize_t result = output.next<ssize_t>();\n  int klinux_errno = output.next<int>();\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n  if (result > total_buffer_size) {\n    ::asylo::primitives::TrustedPrimitives::BestEffortAbort(\n        \"enc_untrusted_recvmsg: result exceeds requested\");\n  }\n  auto msg_name_extent = output.next();\n  if (msg_name_extent.size() <= msg->msg_namelen) {\n    msg->msg_namelen = msg_name_extent.size();\n  }\n  memcpy(msg->msg_name, msg_name_extent.As<char>(), msg->msg_namelen);\n  auto msg_iov_extent = output.next();\n  size_t total_bytes = msg_iov_extent.size();\n  size_t bytes_copied = 0;\n  for (int i = 0; i < msg->msg_iovlen && bytes_copied < total_bytes; ++i) {\n    size_t bytes_to_copy =\n        std::min(msg->msg_iov[i].iov_len, total_bytes - bytes_copied);\n    memcpy(msg->msg_iov[i].iov_base, msg_iov_extent.As<char>() + bytes_copied,\n           bytes_to_copy);\n    bytes_copied += bytes_to_copy;\n  }\n  auto msg_control_extent = output.next();\n  if (msg_control_extent.size() <= msg->msg_controllen) {\n    msg->msg_controllen = msg_control_extent.size();\n  }\n  memcpy(msg->msg_control, msg_control_extent.As<char>(), msg->msg_controllen);\n  return result;\n}", "target": 0}
{"code": "kdc_process_s4u2proxy_req(kdc_realm_t *kdc_active_realm,\n                          krb5_kdc_req *request,\n                          const krb5_enc_tkt_part *t2enc,\n                          const krb5_db_entry *server,\n                          krb5_const_principal server_princ,\n                          krb5_const_principal proxy_princ,\n                          const char **status)\n{\n    krb5_error_code errcode;\n    if (request->kdc_options & (NON_TGT_OPTION | KDC_OPT_ENC_TKT_IN_SKEY)) {\n        *status = \"INVALID_S4U2PROXY_OPTIONS\";\n        return KRB5KDC_ERR_BADOPTION;\n    }\n    if (!krb5_principal_compare(kdc_context,\n                                server->princ, \n                                server_princ)) {\n        *status = \"EVIDENCE_TICKET_MISMATCH\";\n        return KRB5KDC_ERR_SERVER_NOMATCH;\n    }\n    if (!isflagset(t2enc->flags, TKT_FLG_FORWARDABLE)) {\n        *status = \"EVIDENCE_TKT_NOT_FORWARDABLE\";\n        return KRB5_TKT_NOT_FORWARDABLE;\n    }\n    errcode = check_allowed_to_delegate_to(kdc_context,\n                                           t2enc->client,\n                                           server,\n                                           proxy_princ);\n    if (errcode) {\n        *status = \"NOT_ALLOWED_TO_DELEGATE\";\n        return errcode;\n    }\n    return 0;\n}", "target": 0}
{"code": "get_manuf_name(const guint8 *addr)\n{\n    hashmanuf_t *manuf_value;\n    manuf_value = manuf_name_lookup(addr);\n    if (gbl_resolv_flags.mac_name && manuf_value->status != HASHETHER_STATUS_UNRESOLVED)\n        return manuf_value->resolved_name;\n    return manuf_value->hexaddr;\n} ", "target": 1}
{"code": "void LightProcess::closeShadow() {\n  Lock lock(m_procMutex);\n  if (m_shadowProcess) {\n    fprintf(m_fout, \"exit\\n\");\n    fflush(m_fout);\n    fclose(m_fin);\n    fclose(m_fout);\n    ::waitpid(m_shadowProcess, nullptr, 0);\n  }\n  if (!m_afdtFilename.empty()) {\n    remove(m_afdtFilename.c_str());\n  }\n  if (m_afdt_fd >= 0) {\n    ::close(m_afdt_fd);\n    m_afdt_fd = -1;\n  }\n  m_shadowProcess = 0;\n}", "target": 1}
{"code": "prologProcessor(XML_Parser parser, const char *s, const char *end,\n                const char **nextPtr) {\n  const char *next = s;\n  int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n}", "target": 1}
{"code": "static int em_ret_near_imm(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tctxt->dst.type = OP_REG;\n\tctxt->dst.addr.reg = &ctxt->_eip;\n\tctxt->dst.bytes = ctxt->op_bytes;\n\trc = emulate_pop(ctxt, &ctxt->dst.val, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trsp_increment(ctxt, ctxt->src.val);\n\treturn X86EMUL_CONTINUE;\n}", "target": 1}
{"code": "matchCurrentInput(\n\t\tconst InString *input, int pos, const widechar *passInstructions, int passIC) {\n\tint k;\n\tint kk = pos;\n\tfor (k = passIC + 2; k < passIC + 2 + passInstructions[passIC + 1]; k++)\n\t\tif (input->chars[kk] == ENDSEGMENT || passInstructions[k] != input->chars[kk++])\n\t\t\treturn 0;\n\treturn 1;\n}", "target": 1}
{"code": "int git_treebuilder_write(git_oid *oid, git_repository *repo, git_treebuilder *bld)\n{\n\tint error = 0;\n\tsize_t i;\n\tgit_buf tree = GIT_BUF_INIT;\n\tgit_odb *odb;\n\tassert(bld);\n\tgit_vector_sort(&bld->entries);\n\terror = git_buf_grow(&tree, bld->entries.length * 72);\n\tfor (i = 0; i < bld->entries.length && !error; ++i) {\n\t\tgit_tree_entry *entry = git_vector_get(&bld->entries, i);\n\t\tif (entry->removed)\n\t\t\tcontinue;\n\t\tgit_buf_printf(&tree, \"%o \", entry->attr);\n\t\tgit_buf_put(&tree, entry->filename, entry->filename_len + 1);\n\t\tgit_buf_put(&tree, (char *)entry->oid.id, GIT_OID_RAWSZ);\n\t\tif (git_buf_oom(&tree))\n\t\t\terror = -1;\n\t}\n\tif (!error &&\n\t\t!(error = git_repository_odb__weakptr(&odb, repo)))\n\t\terror = git_odb_write(oid, odb, tree.ptr, tree.size, GIT_OBJ_TREE);\n\tgit_buf_free(&tree);\n\treturn error;\n}", "target": 0}
{"code": "static int __init random_int_secret_init(void)\n{\n\tget_random_bytes(random_int_secret, sizeof(random_int_secret));\n\treturn 0;\n}", "target": 0}
{"code": "static inline int crypto_rng_seedsize(struct crypto_rng *tfm)\n{\n\treturn tfm->seedsize;\n}", "target": 1}
{"code": "static int em_call(struct x86_emulate_ctxt *ctxt)\n{\n\tlong rel = ctxt->src.val;\n\tctxt->src.val = (unsigned long)ctxt->_eip;\n\tjmp_rel(ctxt, rel);\n\treturn em_push(ctxt);\n}", "target": 1}
{"code": "inline int SizeOfDimension(const TfLiteTensor* t, int dim) {\n  return t->dims->data[dim];\n}", "target": 1}
{"code": "void audit_free(struct task_struct *tsk)\n{\n\tstruct audit_context *context;\n\tcontext = audit_get_context(tsk, 0, 0);\n\tif (likely(!context))\n\t\treturn;\n\tif (context->in_syscall && context->auditable)\n\t\taudit_log_exit(context, tsk);\n\taudit_free_context(context);\n}", "target": 0}
{"code": "void CScreencopyPortal::queueNextShareFrame(CScreencopyPortal::SSession* pSession) {\n    const auto PSTREAM = m_pPipewire->streamFromSession(pSession);\n    if (PSTREAM && !PSTREAM->streamState)\n        return;\n    const auto FRAMETOOKMS           = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::system_clock::now() - pSession->sharingData.begunFrame).count() / 1000.0;\n    const auto MSTILNEXTREFRESH      = 1000.0 / (pSession->sharingData.framerate) - FRAMETOOKMS;\n    pSession->sharingData.begunFrame = std::chrono::system_clock::now();\n    Debug::log(TRACE, \"[screencopy] set fps {}, frame took {:.2f}ms, ms till next refresh {:.2f}, estimated actual fps: {:.2f}\", pSession->sharingData.framerate, FRAMETOOKMS,\n               MSTILNEXTREFRESH, std::clamp(1000.0 / FRAMETOOKMS, 1.0, (double)pSession->sharingData.framerate));\n    g_pPortalManager->addTimer({std::clamp(MSTILNEXTREFRESH - 1.0 , 6.0, 1000.0), [pSession]() { g_pPortalManager->m_sPortals.screencopy->startFrameCopy(pSession); }});\n}", "target": 1}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_line_number_table_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tut64 curpos, offset = 0;\n\tRBinJavaLineNumberAttribute *lnattr;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\toffset += 6;\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_LINE_NUMBER_TABLE_ATTR;\n\tattr->info.line_number_table_attr.line_number_table_length = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.line_number_table_attr.line_number_table = r_list_newf (free);\n\tut32 linenum_len = attr->info.line_number_table_attr.line_number_table_length;\n\tRList *linenum_list = attr->info.line_number_table_attr.line_number_table;\n\tif (linenum_len > sz) {\n\t\tfree (attr);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < linenum_len; i++) {\n\t\tcurpos = buf_offset + offset;\n\t\tlnattr = R_NEW0 (RBinJavaLineNumberAttribute);\n\t\tif (!lnattr) {\n\t\t\tbreak;\n\t\t}\n\t\tlnattr->start_pc = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlnattr->line_number = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlnattr->file_offset = curpos;\n\t\tlnattr->size = 4;\n\t\tr_list_append (linenum_list, lnattr);\n\t}\n\tattr->size = offset;\n\treturn attr;\n}", "target": 1}
{"code": "void skb_complete_tx_timestamp(struct sk_buff *skb,\n\t\t\t       struct skb_shared_hwtstamps *hwtstamps)\n{\n\tstruct sock *sk = skb->sk;\n\tif (!skb_may_tx_timestamp(sk, false))\n\t\treturn;\n\tif (likely(atomic_inc_not_zero(&sk->sk_refcnt))) {\n\t\t*skb_hwtstamps(skb) = *hwtstamps;\n\t\t__skb_complete_tx_timestamp(skb, sk, SCM_TSTAMP_SND);\n\t\tsock_put(sk);\n\t}", "target": 1}
{"code": "static void http1_on_ready(intptr_t uuid, fio_protocol_s *protocol) {\n  http1pr_s *p = (http1pr_s *)protocol;\n  if ((p->stop & 4)) {\n    p->stop ^= 4;\n    fio_force_event(uuid, FIO_EVENT_ON_DATA);\n  }\n  (void)protocol;\n}", "target": 1}
{"code": "static bool has_locked_children(struct mount *mnt, struct dentry *dentry)\n{\n\tstruct mount *child;\n\tlist_for_each_entry(child, &mnt->mnt_mounts, mnt_child) {\n\t\tif (!is_subdir(child->mnt_mountpoint, dentry))\n\t\t\tcontinue;\n\t\tif (child->mnt.mnt_flags & MNT_LOCKED)\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "struct btrfs_device *btrfs_find_device_by_devspec(\n\t\tstruct btrfs_fs_info *fs_info, u64 devid,\n\t\tconst char *device_path)\n{\n\tstruct btrfs_device *device;\n\tif (devid) {\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, NULL,\n\t\t\t\t\t   NULL);\n\t\tif (!device)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\treturn device;\n\t}\n\tif (!device_path || !device_path[0])\n\t\treturn ERR_PTR(-EINVAL);\n\tif (strcmp(device_path, \"missing\") == 0) {\n\t\tlist_for_each_entry(device, &fs_info->fs_devices->devices,\n\t\t\t\t    dev_list) {\n\t\t\tif (test_bit(BTRFS_DEV_STATE_IN_FS_METADATA,\n\t\t\t\t     &device->dev_state) && !device->bdev)\n\t\t\t\treturn device;\n\t\t}\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\treturn btrfs_find_device_by_path(fs_info, device_path);\n}", "target": 1}
{"code": "int LibRaw::subtract_black()\n{\n\tCHECK_ORDER_LOW(LIBRAW_PROGRESS_RAW2_IMAGE);\n\ttry {\n    if(!is_phaseone_compressed() && (C.cblack[0] || C.cblack[1] || C.cblack[2] || C.cblack[3]))\n        {\n#define BAYERC(row,col,c) imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][c] \n            int cblk[4],i;\n            for(i=0;i<4;i++)\n                cblk[i] = C.cblack[i];\n            int size = S.iheight * S.iwidth;\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#define LIM(x,min,max) MAX(min,MIN(x,max))\n#define CLIP(x) LIM(x,0,65535)\n            for(i=0; i< size*4; i++)\n              {\n                int val = imgdata.image[0][i];\n                val -= cblk[i & 3];\n                imgdata.image[0][i] = CLIP(val);\n                if(C.data_maximum < val) C.data_maximum = val;\n              }\n#undef MIN\n#undef MAX\n#undef LIM\n#undef CLIP\n            C.maximum -= C.black;\n            ZERO(C.cblack);\n            C.black = 0;\n#undef BAYERC\n        }\n    else\n        {\n          int idx;\n          ushort *p = (ushort*)imgdata.image;\n          C.data_maximum = 0;\n          for(idx=0;idx<S.iheight*S.iwidth*4;idx++)\n            if(C.data_maximum < p[idx]) C.data_maximum = p[idx];\n        }\n\t\treturn 0;\n\t}\n\tcatch ( LibRaw_exceptions err) {\n\t\tEXCEPTION_HANDLER(err);\n\t}\n}", "target": 1}
{"code": "static void *HttpMultiBufHeaderThreadDataInit(void *data)\n{\n    HttpMultiBufHeaderThreadData *td = SCCalloc(1, sizeof(*td));\n    return td;\n}", "target": 0}
{"code": "static uint16_t nvme_changed_nslist(NvmeCtrl *n, uint8_t rae, uint32_t buf_len,\n                                    uint64_t off, NvmeRequest *req)\n{\n    uint32_t nslist[1024];\n    uint32_t trans_len;\n    int i = 0;\n    uint32_t nsid;\n    if (off >= sizeof(nslist)) {\n        trace_pci_nvme_err_invalid_log_page_offset(off, sizeof(nslist));\n        return NVME_INVALID_FIELD | NVME_DNR;\n    }\n    memset(nslist, 0x0, sizeof(nslist));\n    trans_len = MIN(sizeof(nslist) - off, buf_len);\n    while ((nsid = find_first_bit(n->changed_nsids, NVME_CHANGED_NSID_SIZE)) !=\n            NVME_CHANGED_NSID_SIZE) {\n        if (i == ARRAY_SIZE(nslist)) {\n            memset(nslist, 0x0, sizeof(nslist));\n            nslist[0] = 0xffffffff;\n            break;\n        }\n        nslist[i++] = nsid;\n        clear_bit(nsid, n->changed_nsids);\n    }\n    if (nslist[0] == 0xffffffff) {\n        bitmap_zero(n->changed_nsids, NVME_CHANGED_NSID_SIZE);\n    }\n    if (!rae) {\n        nvme_clear_events(n, NVME_AER_TYPE_NOTICE);\n    }\n    return nvme_c2h(n, ((uint8_t *)nslist) + off, trans_len, req);\n}", "target": 0}
{"code": "static void nlmclnt_unlock_callback(struct rpc_task *task, void *data)\n{\n\tstruct nlm_rqst\t*req = data;\n\tu32 status = ntohl(req->a_res.status);\n\tif (RPC_ASSASSINATED(task))\n\t\tgoto die;\n\tif (task->tk_status < 0) {\n\t\tdprintk(\"lockd: unlock failed (err = %d)\\n\", -task->tk_status);\n\t\tgoto retry_rebind;\n\t}\n\tif (status == NLM_LCK_DENIED_GRACE_PERIOD) {\n\t\trpc_delay(task, NLMCLNT_GRACE_WAIT);\n\t\tgoto retry_unlock;\n\t}\n\tif (status != NLM_LCK_GRANTED)\n\t\tprintk(KERN_WARNING \"lockd: unexpected unlock status: %d\\n\", status);\ndie:\n\treturn;\n retry_rebind:\n\tnlm_rebind_host(req->a_host);\n retry_unlock:\n\trpc_restart_call(task);\n}", "target": 1}
{"code": "int jpc_ppxstab_insert(jpc_ppxstab_t *tab, jpc_ppxstabent_t *ent)\n{\n\tint inspt;\n\tint i;\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tif (tab->ents[i]->ind > ent->ind) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tinspt = i;\n\tif (tab->numents >= tab->maxents) {\n\t\tif (jpc_ppxstab_grow(tab, tab->maxents + 128)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tfor (i = tab->numents; i > inspt; --i) {\n\t\ttab->ents[i] = tab->ents[i - 1];\n\t}\n\ttab->ents[i] = ent;\n\t++tab->numents;\n\treturn 0;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const auto splits = ctx->input(0).flat<int64_t>();\n    const auto values = ctx->input(1).flat<Tidx>();\n    const Tensor& size_t = ctx->input(2);\n    const auto weights = ctx->input(3).flat<T>();\n    const int64_t weights_size = weights.size();\n    OP_REQUIRES(ctx, size_t.dims() == 0,\n                errors::InvalidArgument(\"Shape must be rank 0 but is rank \",\n                                        size_t.dims()));\n    Tidx size = size_t.scalar<Tidx>()();\n    OP_REQUIRES(\n        ctx, size >= 0,\n        errors::InvalidArgument(\"size (\", size, \") must be non-negative\"));\n    int num_rows = splits.size() - 1;\n    int num_values = values.size();\n    int batch_idx = 0;\n    OP_REQUIRES(ctx, splits.size() > 0,\n                errors::InvalidArgument(\"Splits must be non-empty\"));\n    OP_REQUIRES(ctx, splits(0) == 0,\n                errors::InvalidArgument(\"Splits must start with 0, not with \",\n                                        splits(0)));\n    OP_REQUIRES(ctx, splits(num_rows) == num_values,\n                errors::InvalidArgument(\n                    \"Splits must end with the number of values, got \",\n                    splits(num_rows), \" instead of \", num_values));\n    Tensor* out_t;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(0, TensorShape({num_rows, size}), &out_t));\n    functor::SetZeroFunctor<Device, T> fill;\n    fill(ctx->eigen_device<Device>(), out_t->flat<T>());\n    const auto out = out_t->matrix<T>();\n    for (int idx = 0; idx < num_values; ++idx) {\n      while (idx >= splits(batch_idx)) {\n        batch_idx++;\n      }\n      Tidx bin = values(idx);\n      OP_REQUIRES(ctx, bin >= 0,\n                  errors::InvalidArgument(\"Input must be non-negative\"));\n      if (bin < size) {\n        if (binary_output_) {\n          out(batch_idx - 1, bin) = T(1);\n        } else {\n          T value = (weights_size > 0) ? weights(idx) : T(1);\n          out(batch_idx - 1, bin) += value;\n        }\n      }\n    }\n  }", "target": 0}
{"code": "int jas_stream_pad(jas_stream_t *stream, int n, int c)\n{\n\tint m;\n\tif (n < 0) {\n\t\tjas_deprecated(\"negative count for jas_stream_pad\");\n\t}\n\tm = n;\n\tfor (m = n; m > 0; --m) {\n\t\tif (jas_stream_putc(stream, c) == EOF)\n\t\t\treturn n - m;\n\t}\n\treturn n;\n}", "target": 0}
{"code": "static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)\n{\n    int i, j, v;\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->intra_matrix[j]        = v;\n            s->chroma_intra_matrix[j] = v;\n        }\n    }\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            get_bits(gb, 8);\n        }\n    }\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->chroma_intra_matrix[j] = v;\n        }\n    }\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            get_bits(gb, 8);\n        }\n    }\n    next_start_code_studio(gb);\n}", "target": 1}
{"code": "TEST_P(Http2CodecImplTest, TestLargeRequestHeadersAtLimitAccepted) {\n  uint32_t codec_limit_kb = 64;\n  max_request_headers_kb_ = codec_limit_kb;\n  initialize();\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  std::string key = \"big\";\n  uint32_t head_room = 77;\n  uint32_t long_string_length =\n      codec_limit_kb * 1024 - request_headers.byteSize() - key.length() - head_room;\n  std::string long_string = std::string(long_string_length, 'q');\n  request_headers.addCopy(key, long_string);\n  ASSERT_EQ(request_headers.byteSize() + head_room, codec_limit_kb * 1024);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, _));\n  request_encoder_->encodeHeaders(request_headers, true);\n}", "target": 1}
{"code": "static int fsmMkdir(const char *path, mode_t mode)\n{\n    int rc = mkdir(path, (mode & 07777));\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, 0%04o) %s\\n\", __func__,\n\t       path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_MKDIR_FAILED;\n    return rc;\n}", "target": 1}
{"code": "void *js_touserdata(js_State *J, int idx, const char *tag)\n{\n\tjs_Value *v = stackidx(J, idx);\n\tif (v->type == JS_TOBJECT && v->u.object->type == JS_CUSERDATA)\n\t\tif (!strcmp(tag, v->u.object->u.user.tag))\n\t\t\treturn v->u.object->u.user.data;\n\tjs_typeerror(J, \"not a %s\", tag);\n}", "target": 0}
{"code": "vips_malloc( VipsObject *object, size_t size )\n{\n\tvoid *buf;\n\tbuf = g_malloc( size );\n        if( object ) {\n\t\tg_signal_connect( object, \"postclose\", \n\t\t\tG_CALLBACK( vips_malloc_cb ), buf );\n\t\tobject->local_memory += size;\n\t}\n\treturn( buf );\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& filter = context->input(1);\n    const TensorShape& filter_shape = filter.shape();\n    const Tensor& out_backprop = context->input(2);\n    const TensorShape& out_backprop_shape = out_backprop.shape();\n    TensorShape input_shape;\n    if (takes_shape_) {\n      const Tensor& input_sizes = context->input(0);\n      OP_REQUIRES_OK(context, tensor::MakeShape(input_sizes, &input_shape));\n    } else {\n      input_shape = context->input(0).shape();\n    }\n    OP_REQUIRES(\n        context, input_shape.dim_size(4) == filter_shape.dim_size(3),\n        errors::InvalidArgument(\"input and filter_sizes must have the same \"\n                                \"number of channels. Got \",\n                                input_shape.dim_size(4), \" for input and \",\n                                filter_shape.dim_size(3), \" for filter_sizes\"));\n    OP_REQUIRES(\n        context, out_backprop_shape.dim_size(4) == filter_shape.dim_size(4),\n        errors::InvalidArgument(\"out_backprop and filter_sizes must have the \"\n                                \"same number of channels. Got \",\n                                out_backprop_shape.dim_size(4),\n                                \" for out_backprop and \",\n                                filter_shape.dim_size(4), \" for filter_sizes\"));\n    ConvBackpropDimensions dims;\n    OP_REQUIRES_OK(context, ConvBackpropComputeDimensions(\n                                \"Conv3DBackpropInputOp\", 3,\n                                input_shape, filter_shape, out_backprop_shape,\n                                stride_, padding_, data_format_, &dims));\n    Tensor* in_backprop;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input_shape, &in_backprop));\n    functor::CuboidConvolutionBackwardInput<Device, T>()(\n        context->eigen_device<Device>(),\n        in_backprop->tensor<T, 5>(),                     \n        filter.tensor<T, 5>(),                           \n        out_backprop.tensor<T, 5>(),                     \n        static_cast<int>(dims.spatial_dims[0].stride),   \n        static_cast<int>(dims.spatial_dims[1].stride),   \n        static_cast<int>(dims.spatial_dims[2].stride));  \n  }", "target": 0}
{"code": "static OPJ_BOOL opj_tcd_code_block_dec_allocate(opj_tcd_cblk_dec_t *\n        p_code_block)\n{\n    if (! p_code_block->data) {\n        p_code_block->data = (OPJ_BYTE*) opj_malloc(OPJ_COMMON_DEFAULT_CBLK_DATA_SIZE);\n        if (! p_code_block->data) {\n            return OPJ_FALSE;\n        }\n        p_code_block->data_max_size = OPJ_COMMON_DEFAULT_CBLK_DATA_SIZE;\n        p_code_block->segs = (opj_tcd_seg_t *) opj_calloc(OPJ_J2K_DEFAULT_NB_SEGS,\n                             sizeof(opj_tcd_seg_t));\n        if (! p_code_block->segs) {\n            return OPJ_FALSE;\n        }\n        p_code_block->m_current_max_segs = OPJ_J2K_DEFAULT_NB_SEGS;\n    } else {\n        OPJ_BYTE* l_data = p_code_block->data;\n        OPJ_UINT32 l_data_max_size = p_code_block->data_max_size;\n        opj_tcd_seg_t * l_segs = p_code_block->segs;\n        OPJ_UINT32 l_current_max_segs = p_code_block->m_current_max_segs;\n        memset(p_code_block, 0, sizeof(opj_tcd_cblk_dec_t));\n        p_code_block->data = l_data;\n        p_code_block->data_max_size = l_data_max_size;\n        p_code_block->segs = l_segs;\n        p_code_block->m_current_max_segs = l_current_max_segs;\n    }\n    return OPJ_TRUE;\n}", "target": 0}
{"code": "static inline void pgd_free(struct mm_struct *mm, pgd_t *pgd)\n{\n\tif (mm->context.asce_limit == (1UL << 31))\n\t\tpgtable_pmd_page_dtor(virt_to_page(pgd));\n\tcrst_table_free(mm, (unsigned long *) pgd);\n}", "target": 0}
{"code": "static unsigned char *AcquireCompactPixels(const Image *image,\n  ExceptionInfo *exception)\n{\n  size_t\n    packet_size;\n  unsigned char\n    *compact_pixels;\n  packet_size=image->depth > 8UL ? 2UL : 1UL;\n  compact_pixels=(unsigned char *) AcquireQuantumMemory((9*\n    image->columns)+1,packet_size*sizeof(*compact_pixels));\n  if (compact_pixels == (unsigned char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n        image->filename);\n    }\n  return(compact_pixels);\n}", "target": 1}
{"code": "int compat_get_timex(struct timex *txc, const struct compat_timex __user *utp)\n{\n\tstruct compat_timex tx32;\n\tmemset(txc, 0, sizeof(struct timex));\n\tif (copy_from_user(&tx32, utp, sizeof(struct compat_timex)))\n\t\treturn -EFAULT;\n\ttxc->modes = tx32.modes;\n\ttxc->offset = tx32.offset;\n\ttxc->freq = tx32.freq;\n\ttxc->maxerror = tx32.maxerror;\n\ttxc->esterror = tx32.esterror;\n\ttxc->status = tx32.status;\n\ttxc->constant = tx32.constant;\n\ttxc->precision = tx32.precision;\n\ttxc->tolerance = tx32.tolerance;\n\ttxc->time.tv_sec = tx32.time.tv_sec;\n\ttxc->time.tv_usec = tx32.time.tv_usec;\n\ttxc->tick = tx32.tick;\n\ttxc->ppsfreq = tx32.ppsfreq;\n\ttxc->jitter = tx32.jitter;\n\ttxc->shift = tx32.shift;\n\ttxc->stabil = tx32.stabil;\n\ttxc->jitcnt = tx32.jitcnt;\n\ttxc->calcnt = tx32.calcnt;\n\ttxc->errcnt = tx32.errcnt;\n\ttxc->stbcnt = tx32.stbcnt;\n\treturn 0;\n}", "target": 0}
{"code": "ppp_hdlc(netdissect_options *ndo,\n         const u_char *p, int length)\n{\n\tu_int caplen = ndo->ndo_snapend - p;\n\tu_char *b, *t, c;\n\tconst u_char *s;\n\tu_int i;\n\tint proto;\n\tconst void *se;\n\tif (caplen == 0)\n\t\treturn;\n        if (length <= 0)\n                return;\n\tb = (u_char *)malloc(caplen);\n\tif (b == NULL)\n\t\treturn;\n\tfor (s = p, t = b, i = caplen; i != 0; i--) {\n\t\tc = *s++;\n\t\tif (c == 0x7d) {\n\t\t\tif (i <= 1)\n\t\t\t\tbreak;\n\t\t\ti--;\n\t\t\tc = *s++ ^ 0x20;\n\t\t}\n\t\t*t++ = c;\n\t}\n\tse = ndo->ndo_snapend;\n\tndo->ndo_snapend = t;\n\tlength = t - b;\n        if (length < 1)\n                goto trunc;\n        proto = *b; \n        switch (proto) {\n        case PPP_IP:\n\t\tip_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        case PPP_IPV6:\n\t\tip6_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        default: \n\t\tbreak;\n        }\n        if (length < 2)\n                goto trunc;\n        proto = EXTRACT_16BITS(b); \n        switch (proto) {\n        case (PPP_ADDRESS << 8 | PPP_CONTROL): \n            if (length < 4)\n                goto trunc;\n            proto = EXTRACT_16BITS(b+2); \n            handle_ppp(ndo, proto, b + 4, length - 4);\n            break;\n        default: \n            handle_ppp(ndo, proto, b + 2, length - 2);\n            break;\n        }\ncleanup:\n\tndo->ndo_snapend = se;\n\tfree(b);\n        return;\ntrunc:\n\tndo->ndo_snapend = se;\n\tfree(b);\n\tND_PRINT((ndo, \"[|ppp]\"));\n}", "target": 0}
{"code": "GF_Err gf_bin128_parse(const char *string, bin128 value)\n{\n\tu32 len;\n\tu32\ti=0;\n\tif (!strnicmp(string, \"0x\", 2)) string += 2;\n\tlen = (u32) strlen(string);\n\tif (len >= 32) {\n\t\tu32 j;\n\t\tfor (j=0; j<len; j+=2) {\n\t\t\tu32 v;\n\t\t\tchar szV[5];\n\t\t\twhile (string[j] && !isalnum(string[j]))\n\t\t\t\tj++;\n\t\t\tif (!string[j])\n\t\t\t\tbreak;\n\t\t\tsprintf(szV, \"%c%c\", string[j], string[j+1]);\n\t\t\tsscanf(szV, \"%x\", &v);\n\t\t\tif (i > 15) {\n\t\t\t\ti++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvalue[i] = v;\n\t\t\ti++;\n\t\t}\n\t}\n\tif (i != 16) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[CORE] 128bit blob is not 16-bytes long: %s\\n\", string));\n\t\treturn GF_BAD_PARAM;\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "pci_bus_configured(int bus)\n{\n\tassert(bus >= 0 && bus < MAXBUSES);\n\treturn (pci_businfo[bus] != NULL);\n}", "target": 1}
{"code": "static void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,\n\t\t\t\t      unsigned long resolution,\n\t\t\t\t      unsigned long ticks)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\tstruct snd_timer_tread *r, r1;\n\tstruct timespec tstamp;\n\tint prev, append = 0;\n\tmemset(&tstamp, 0, sizeof(tstamp));\n\tspin_lock(&tu->qlock);\n\tif ((tu->filter & ((1 << SNDRV_TIMER_EVENT_RESOLUTION) |\n\t\t\t   (1 << SNDRV_TIMER_EVENT_TICK))) == 0) {\n\t\tspin_unlock(&tu->qlock);\n\t\treturn;\n\t}\n\tif (tu->last_resolution != resolution || ticks > 0) {\n\t\tif (timer_tstamp_monotonic)\n\t\t\tktime_get_ts(&tstamp);\n\t\telse\n\t\t\tgetnstimeofday(&tstamp);\n\t}\n\tif ((tu->filter & (1 << SNDRV_TIMER_EVENT_RESOLUTION)) &&\n\t    tu->last_resolution != resolution) {\n\t\tmemset(&r1, 0, sizeof(r1));\n\t\tr1.event = SNDRV_TIMER_EVENT_RESOLUTION;\n\t\tr1.tstamp = tstamp;\n\t\tr1.val = resolution;\n\t\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\t\ttu->last_resolution = resolution;\n\t\tappend++;\n\t}\n\tif ((tu->filter & (1 << SNDRV_TIMER_EVENT_TICK)) == 0)\n\t\tgoto __wake;\n\tif (ticks == 0)\n\t\tgoto __wake;\n\tif (tu->qused > 0) {\n\t\tprev = tu->qtail == 0 ? tu->queue_size - 1 : tu->qtail - 1;\n\t\tr = &tu->tqueue[prev];\n\t\tif (r->event == SNDRV_TIMER_EVENT_TICK) {\n\t\t\tr->tstamp = tstamp;\n\t\t\tr->val += ticks;\n\t\t\tappend++;\n\t\t\tgoto __wake;\n\t\t}\n\t}\n\tr1.event = SNDRV_TIMER_EVENT_TICK;\n\tr1.tstamp = tstamp;\n\tr1.val = ticks;\n\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\tappend++;\n      __wake:\n\tspin_unlock(&tu->qlock);\n\tif (append == 0)\n\t\treturn;\n\tkill_fasync(&tu->fasync, SIGIO, POLL_IN);\n\twake_up(&tu->qchange_sleep);\n}", "target": 0}
{"code": "PHPAPI int php_execute_simple_script(zend_file_handle *primary_file, zval *ret)\n{\n\tchar *old_cwd;\n\tALLOCA_FLAG(use_heap)\n\tEG(exit_status) = 0;\n#define OLD_CWD_SIZE 4096\n\told_cwd = do_alloca(OLD_CWD_SIZE, use_heap);\n\told_cwd[0] = '\\0';\n\tzend_try {\n#ifdef PHP_WIN32\n\t\tif(primary_file->filename) {\n\t\t\tUpdateIniFromRegistry((char*)primary_file->filename);\n\t\t}\n#endif\n\t\tPG(during_request_startup) = 0;\n\t\tif (primary_file->filename && !(SG(options) & SAPI_OPTION_NO_CHDIR)) {\n\t\t\tphp_ignore_value(VCWD_GETCWD(old_cwd, OLD_CWD_SIZE-1));\n\t\t\tVCWD_CHDIR_FILE(primary_file->filename);\n\t\t}\n\t\tzend_execute_scripts(ZEND_REQUIRE, ret, 1, primary_file);\n\t} zend_end_try();\n\tif (old_cwd[0] != '\\0') {\n\t\tphp_ignore_value(VCWD_CHDIR(old_cwd));\n\t}\n\tfree_alloca(old_cwd, use_heap);\n\treturn EG(exit_status);\n}", "target": 0}
{"code": "static int do_session_handshake (lua_State *L, int status, lua_KContext ctx) {\n    int rc;\n    struct ssh_userdata *sshu = NULL;\n    assert(lua_gettop(L) == 4);\n    sshu = (struct ssh_userdata *) nseU_checkudata(L, 3, SSH2_UDATA, \"ssh2\");\n    while ((rc = libssh2_session_handshake(sshu->session, sshu->sp[0])) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 3, \"filter\");\n        lua_pushvalue(L, 3);\n        assert(lua_status(L) == LUA_OK);\n        lua_callk(L, 1, 0, 0, do_session_handshake);\n    }\n    if (rc) {\n        libssh2_session_free(sshu->session);\n        sshu->session = NULL;\n        return luaL_error(L, \"Unable to complete libssh2 handshake.\");\n    }\n    lua_settop(L, 3);\n    return 1;\n}", "target": 0}
{"code": "GF_Box *encs_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_ENCS);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\ttmp->internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S;\n\treturn (GF_Box *)tmp;\n}", "target": 1}
{"code": "static inline struct sk_buff *skb_share_check(struct sk_buff *skb, gfp_t pri)\n{\n\tmight_sleep_if(pri & __GFP_WAIT);\n\tif (skb_shared(skb)) {\n\t\tstruct sk_buff *nskb = skb_clone(skb, pri);\n\t\tif (likely(nskb))\n\t\t\tconsume_skb(skb);\n\t\telse\n\t\t\tkfree_skb(skb);\n\t\tskb = nskb;\n\t}\n\treturn skb;\n}", "target": 0}
{"code": "raptor_libxml_resolveEntity(void* user_data, \n                            const xmlChar *publicId, const xmlChar *systemId) {\n  raptor_sax2* sax2 = (raptor_sax2*)user_data;\n  return libxml2_resolveEntity(sax2->xc, publicId, systemId);\n}", "target": 1}
{"code": "void ZlibInStream::deinit()\n{\n  assert(zs != NULL);\n  removeUnderlying();\n  inflateEnd(zs);\n  delete zs;\n  zs = NULL;\n}", "target": 1}
{"code": "int xml_init(modsec_rec *msr, char **error_msg) {\n    xmlParserInputBufferCreateFilenameFunc entity;\n    if (error_msg == NULL) return -1;\n    *error_msg = NULL;\n    msr->xml = apr_pcalloc(msr->mp, sizeof(xml_data));\n    if (msr->xml == NULL) return -1;\n    if(msr->txcfg->xml_external_entity == 0)    {\n        entity = xmlParserInputBufferCreateFilenameDefault(xml_unload_external_entity);\n    }\n    return 1;\n}", "target": 0}
{"code": "int sub__remove(struct mosquitto *context, const char *sub, uint8_t *reason)\n{\n\tint rc = 0;\n\tstruct mosquitto__subhier *subhier;\n\tconst char *sharename = NULL;\n\tchar *local_sub = NULL;\n\tchar **topics = NULL;\n\tassert(sub);\n\trc = sub__topic_tokenise(sub, &local_sub, &topics, &sharename);\n\tif(rc) return rc;\n\tHASH_FIND(hh, db.subs, topics[0], strlen(topics[0]), subhier);\n\tif(subhier){\n\t\t*reason = MQTT_RC_NO_SUBSCRIPTION_EXISTED;\n\t\trc = sub__remove_recurse(context, subhier, topics, reason, sharename);\n\t}\n\tmosquitto__free(local_sub);\n\tmosquitto__free(topics);\n\treturn rc;\n}", "target": 1}
{"code": "absl::StatusOr<tensorflow::Tensor> DecompressTensorFromProto(\n    const tensorflow::TensorProto& proto) {\n  if (!IsSupported(proto.dtype())) {\n    return absl::InvalidArgumentError(absl::StrCat(\n        \"Tensor of dtype \", tensorflow::DataTypeString(proto.dtype()),\n        \" is not supported for decompression.\"));\n  }\n  if (proto.dtype() == tensorflow::DT_STRING) {\n    tensorflow::Tensor tensor;\n    REVERB_CHECK(tensor.FromProto(proto));\n    return tensor;\n  } else {\n    tensorflow::Tensor tensor(proto.dtype(),\n                              tensorflow::TensorShape(proto.tensor_shape()));\n    const auto& tensor_content = proto.tensor_content();\n    SnappyUncompressToString(tensor_content, tensor.tensor_data().size(),\n                             const_cast<char*>(tensor.tensor_data().data()));\n    return tensor;\n  }\n}", "target": 0}
{"code": "static void bnx2x_clear_func_ilt(struct bnx2x *bp, u32 func)\n{\n\tu32 i, base = FUNC_ILT_BASE(func);\n\tfor (i = base; i < base + ILT_PER_FUNC; i++)\n\t\tbnx2x_ilt_wr(bp, i, 0);\n}", "target": 0}
{"code": "CompileKeymap(XkbFile *file, struct xkb_keymap *keymap, enum merge_mode merge)\n{\n    bool ok;\n    XkbFile *files[LAST_KEYMAP_FILE_TYPE + 1] = { NULL };\n    enum xkb_file_type type;\n    struct xkb_context *ctx = keymap->ctx;\n    for (file = (XkbFile *) file->defs; file;\n         file = (XkbFile *) file->common.next) {\n        if (file->file_type < FIRST_KEYMAP_FILE_TYPE ||\n            file->file_type > LAST_KEYMAP_FILE_TYPE) {\n            log_err(ctx, \"Cannot define %s in a keymap file\\n\",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n        if (files[file->file_type]) {\n            log_err(ctx,\n                    \"More than one %s section in keymap file; \"\n                    \"All sections after the first ignored\\n\",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n        files[file->file_type] = file;\n    }\n    ok = true;\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        if (files[type] == NULL) {\n            log_err(ctx, \"Required section %s missing from keymap\\n\",\n                    xkb_file_type_to_string(type));\n            ok = false;\n        }\n    }\n    if (!ok)\n        return false;\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        log_dbg(ctx, \"Compiling %s \\\"%s\\\"\\n\",\n                xkb_file_type_to_string(type), files[type]->name);\n        ok = compile_file_fns[type](files[type], keymap, merge);\n        if (!ok) {\n            log_err(ctx, \"Failed to compile %s\\n\",\n                    xkb_file_type_to_string(type));\n            return false;\n        }\n    }\n    return UpdateDerivedKeymapFields(keymap);\n}", "target": 1}
{"code": "cib_timeout_handler(gpointer data)\n{\n    struct timer_rec_s *timer = data;\n    timer_expired = TRUE;\n    crm_err(\"Call %d timed out after %ds\", timer->call_id, timer->timeout);\n    return TRUE;\n}", "target": 1}
{"code": "  void operator()(const CPUDevice& d,\n                  typename TTypes<T, 3>::ConstTensor gradient,\n                  typename TTypes<T, 3>::ConstTensor input,\n                  const Tensor* input_min_tensor,\n                  const Tensor* input_max_tensor,\n                  typename TTypes<T, 3>::Tensor input_backprop,\n                  typename TTypes<T>::Flat input_min_backprop,\n                  typename TTypes<T>::Flat input_max_backprop) {\n    QuantizeAndDequantizePerChannelGradientImpl<CPUDevice, T>::Compute(\n        d, gradient, input, input_min_tensor, input_max_tensor, input_backprop,\n        input_min_backprop, input_max_backprop);\n  }", "target": 1}
{"code": "int unit_name_path_escape(const char *f, char **ret) {\n        char *p, *s;\n        assert(f);\n        assert(ret);\n        p = strdupa(f);\n        if (!p)\n                return -ENOMEM;\n        path_simplify(p, false);\n        if (empty_or_root(p))\n                s = strdup(\"-\");\n        else {\n                if (!path_is_normalized(p))\n                        return -EINVAL;\n                delete_trailing_chars(p, \"/\");\n                p = skip_leading_chars(p, \"/\");\n                s = unit_name_escape(p);\n        }\n        if (!s)\n                return -ENOMEM;\n        *ret = s;\n        return 0;\n}", "target": 1}
{"code": "static int ntlm_decode_u16l_str_hdr(struct ntlm_ctx *ctx,\n                                    struct wire_field_hdr *str_hdr,\n                                    struct ntlm_buffer *buffer,\n                                    size_t payload_offs, char **str)\n{\n    char *in, *out = NULL;\n    uint16_t str_len;\n    uint32_t str_offs;\n    size_t outlen;\n    int ret = 0;\n    str_len = le16toh(str_hdr->len);\n    if (str_len == 0) goto done;\n    str_offs = le32toh(str_hdr->offset);\n    if ((str_offs < payload_offs) ||\n        (str_offs > buffer->length) ||\n        (UINT32_MAX - str_offs < str_len) ||\n        (str_offs + str_len > buffer->length)) {\n        return ERR_DECODE;\n    }\n    in = (char *)&buffer->data[str_offs];\n    out = malloc(str_len * 2 + 1);\n    if (!out) return ENOMEM;\n    ret = ntlm_str_convert(ctx->to_oem, in, out, str_len, &outlen);\n    out[outlen] = '\\0';\ndone:\n    if (ret) {\n        safefree(out);\n    }\n    *str = out;\n    return ret;\n}", "target": 0}
{"code": "static inline __u32 skb_get_rxhash(struct sk_buff *skb)\n{\n\tif (!skb->l4_rxhash)\n\t\t__skb_get_rxhash(skb);\n\treturn skb->rxhash;\n}", "target": 0}
{"code": "static int whiteheat_probe(struct usb_serial *serial,\n\t\t\t\tconst struct usb_device_id *id)\n{\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tsize_t num_bulk_in = 0;\n\tsize_t num_bulk_out = 0;\n\tsize_t min_num_bulk;\n\tunsigned int i;\n\tiface_desc = serial->interface->cur_altsetting;\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; i++) {\n\t\tendpoint = &iface_desc->endpoint[i].desc;\n\t\tif (usb_endpoint_is_bulk_in(endpoint))\n\t\t\t++num_bulk_in;\n\t\tif (usb_endpoint_is_bulk_out(endpoint))\n\t\t\t++num_bulk_out;\n\t}\n\tmin_num_bulk = COMMAND_PORT + 1;\n\tif (num_bulk_in < min_num_bulk || num_bulk_out < min_num_bulk)\n\t\treturn -ENODEV;\n\treturn 0;\n}", "target": 0}
{"code": "void zrandmemberCommand(client *c) {\n    long l;\n    int withscores = 0;\n    robj *zset;\n    listpackEntry ele;\n    if (c->argc >= 3) {\n        if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;\n        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withscores\"))) {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        } else if (c->argc == 4)\n            withscores = 1;\n        zrandmemberWithCountCommand(c, l, withscores);\n        return;\n    }\n    if ((zset = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL ||\n        checkType(c,zset,OBJ_ZSET)) {\n        return;\n    }\n    zsetTypeRandomElement(zset, zsetLength(zset), &ele,NULL);\n    zsetReplyFromListpackEntry(c,&ele);\n}", "target": 1}
{"code": "static void prefetch_enc(void)\n{\n  prefetch_table((const void *)encT, sizeof(encT));\n}", "target": 1}
{"code": "static long media_device_enum_entities(struct media_device *mdev,\n\t\t\t\t       struct media_entity_desc __user *uent)\n{\n\tstruct media_entity *ent;\n\tstruct media_entity_desc u_ent;\n\tmemset(&u_ent, 0, sizeof(u_ent));\n\tif (copy_from_user(&u_ent.id, &uent->id, sizeof(u_ent.id)))\n\t\treturn -EFAULT;\n\tent = find_entity(mdev, u_ent.id);\n\tif (ent == NULL)\n\t\treturn -EINVAL;\n\tu_ent.id = ent->id;\n\tif (ent->name) {\n\t\tstrncpy(u_ent.name, ent->name, sizeof(u_ent.name));\n\t\tu_ent.name[sizeof(u_ent.name) - 1] = '\\0';\n\t} else {\n\t\tmemset(u_ent.name, 0, sizeof(u_ent.name));\n\t}\n\tu_ent.type = ent->type;\n\tu_ent.revision = ent->revision;\n\tu_ent.flags = ent->flags;\n\tu_ent.group_id = ent->group_id;\n\tu_ent.pads = ent->num_pads;\n\tu_ent.links = ent->num_links - ent->num_backlinks;\n\tmemcpy(&u_ent.raw, &ent->info, sizeof(ent->info));\n\tif (copy_to_user(uent, &u_ent, sizeof(u_ent)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 0}
{"code": "LUA_API void *lua_upvalueid (lua_State *L, int fidx, int n) {\n  StkId fi = index2addr(L, fidx);\n  switch (ttype(fi)) {\n    case LUA_TLCL: {  \n      return *getupvalref(L, fidx, n, NULL);\n    }\n    case LUA_TCCL: {  \n      CClosure *f = clCvalue(fi);\n      api_check(L, 1 <= n && n <= f->nupvalues, \"invalid upvalue index\");\n      return &f->upvalue[n - 1];\n    }\n    default: {\n      api_check(L, 0, \"closure expected\");\n      return NULL;\n    }\n  }\n}", "target": 1}
{"code": "Fraction::Fraction(int32_t num,int32_t den)\n{\n  int32_t g = gcd(num, den);\n  if (num == std::numeric_limits<int32_t>::min() && g == -1) {\n    num++;\n  }\n  if (den == std::numeric_limits<int32_t>::min() && g == -1) {\n    den++;\n  }\n  numerator = num / g;\n  denominator = den / g;\n  while (denominator > MAX_FRACTION_DENOMINATOR) {\n    numerator >>= 1;\n    denominator >>= 1;\n  }\n}", "target": 1}
{"code": "Network::FilterStatus Context::onDownstreamData(int data_length, bool end_of_stream) {\n  if (!wasm_->onDownstreamData_) {\n    return Network::FilterStatus::Continue;\n  }\n  auto result = wasm_->onDownstreamData_(this, id_, static_cast<uint32_t>(data_length),\n                                         static_cast<uint32_t>(end_of_stream));\n  return result.u64_ == 0 ? Network::FilterStatus::Continue : Network::FilterStatus::StopIteration;\n}", "target": 1}
{"code": "void ChromotingInstance::PostChromotingMessage(\n    const std::string& method,\n    scoped_ptr<base::DictionaryValue> data) {\n  scoped_ptr<base::DictionaryValue> message(new base::DictionaryValue());\n  message->SetString(\"method\", method);\n  message->Set(\"data\", data.release());\n  std::string message_json;\n  base::JSONWriter::Write(message.get(), &message_json);\n  PostMessage(pp::Var(message_json));\n}", "target": 0}
{"code": "static int stimer_set_count(struct kvm_vcpu_hv_stimer *stimer, u64 count,\n\t\t\t    bool host)\n{\n\tstruct kvm_vcpu *vcpu = hv_stimer_to_vcpu(stimer);\n\tstruct kvm_vcpu_hv_synic *synic = to_hv_synic(vcpu);\n\tif (!synic->active && !host)\n\t\treturn 1;\n\ttrace_kvm_hv_stimer_set_count(hv_stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t      stimer->index, count, host);\n\tstimer_cleanup(stimer);\n\tstimer->count = count;\n\tif (stimer->count == 0)\n\t\tstimer->config.enable = 0;\n\telse if (stimer->config.auto_enable)\n\t\tstimer->config.enable = 1;\n\tif (stimer->config.enable)\n\t\tstimer_mark_pending(stimer, false);\n\treturn 0;\n}", "target": 1}
{"code": "static int target_xcopy_locate_se_dev_e4_iter(struct se_device *se_dev,\n\t\t\t\t\t      void *data)\n{\n\tstruct xcopy_dev_search_info *info = data;\n\tunsigned char tmp_dev_wwn[XCOPY_NAA_IEEE_REGEX_LEN];\n\tint rc;\n\tif (!se_dev->dev_attrib.emulate_3pc)\n\t\treturn 0;\n\tmemset(&tmp_dev_wwn[0], 0, XCOPY_NAA_IEEE_REGEX_LEN);\n\ttarget_xcopy_gen_naa_ieee(se_dev, &tmp_dev_wwn[0]);\n\trc = memcmp(&tmp_dev_wwn[0], info->dev_wwn, XCOPY_NAA_IEEE_REGEX_LEN);\n\tif (rc != 0)\n\t\treturn 0;\n\tinfo->found_dev = se_dev;\n\tpr_debug(\"XCOPY 0xe4: located se_dev: %p\\n\", se_dev);\n\trc = target_depend_item(&se_dev->dev_group.cg_item);\n\tif (rc != 0) {\n\t\tpr_err(\"configfs_depend_item attempt failed: %d for se_dev: %p\\n\",\n\t\t       rc, se_dev);\n\t\treturn rc;\n\t}\n\tpr_debug(\"Called configfs_depend_item for se_dev: %p se_dev->se_dev_group: %p\\n\",\n\t\t se_dev, &se_dev->dev_group);\n\treturn 1;\n}", "target": 1}
{"code": "    unsigned int readBits(int n)\n    {\n        unsigned int bit, bits;\n        if (n < 0) {\n            return -1;\n        }\n        if (n == 0) {\n            return 0;\n        }\n        if (n == 1) {\n            return readBit();\n        }\n        bit = readBit();\n        if (bit == (unsigned int)-1) {\n            return -1;\n        }\n        bit = bit << (n - 1);\n        bits = readBits(n - 1);\n        if (bits == (unsigned int)-1) {\n            return -1;\n        }\n        return bit | bits;\n    }", "target": 0}
{"code": "static int update_write_order_info(rdpContext* context, wStream* s, ORDER_INFO* orderInfo,\n                                   size_t offset)\n{\n\tsize_t position;\n\tWINPR_UNUSED(context);\n\tposition = Stream_GetPosition(s);\n\tStream_SetPosition(s, offset);\n\tStream_Write_UINT8(s, orderInfo->controlFlags); \n\tif (orderInfo->controlFlags & ORDER_TYPE_CHANGE)\n\t\tStream_Write_UINT8(s, orderInfo->orderType); \n\tupdate_write_field_flags(s, orderInfo->fieldFlags, orderInfo->controlFlags,\n\t                         PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType]);\n\tupdate_write_bounds(s, orderInfo);\n\tStream_SetPosition(s, position);\n\treturn 0;\n}", "target": 1}
{"code": "static int send_acknowledge(struct nci_spi *nspi, u8 acknowledge)\n{\n\tstruct sk_buff *skb;\n\tunsigned char *hdr;\n\tu16 crc;\n\tint ret;\n\tskb = nci_skb_alloc(nspi->ndev, 0, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\thdr = skb_push(skb, NCI_SPI_HDR_LEN);\n\thdr[0] = NCI_SPI_DIRECT_WRITE;\n\thdr[1] = NCI_SPI_CRC_ENABLED;\n\thdr[2] = acknowledge << NCI_SPI_ACK_SHIFT;\n\thdr[3] = 0;\n\tcrc = crc_ccitt(CRC_INIT, skb->data, skb->len);\n\tskb_put_u8(skb, crc >> 8);\n\tskb_put_u8(skb, crc & 0xFF);\n\tret = __nci_spi_send(nspi, skb, 0);\n\tkfree_skb(skb);\n\treturn ret;\n}", "target": 0}
{"code": "SWFInput_readSBits(SWFInput input, int number)\n{\n\tint num = SWFInput_readBits(input, number);\n\tif ( num & (1<<(number-1)) )\n\t\treturn num - (1<<number);\n\telse\n\t\treturn num;\n}", "target": 1}
{"code": "mm_xmalloc(struct mm_master *mm, size_t size)\n{\n\tvoid *address;\n\taddress = mm_malloc(mm, size);\n\tif (address == NULL)\n\t\tfatal(\"%s: mm_malloc(%zu)\", __func__, size);\n\tmemset(address, 0, size);\n\treturn (address);\n}", "target": 1}
{"code": "init_ctx_reselect(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,\n\t\t  OM_uint32 acc_negState, gss_OID supportedMech,\n\t\t  gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,\n\t\t  OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 tmpmin;\n\tsize_t i;\n\tgeneric_gss_release_oid(&tmpmin, &sc->internal_mech);\n\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n\t\t\t       GSS_C_NO_BUFFER);\n\tfor (i = 0; i < sc->mech_set->count; i++) {\n\t\tif (g_OID_equal(supportedMech, &sc->mech_set->elements[i]))\n\t\t\tbreak;\n\t}\n\tif (i == sc->mech_set->count)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc->internal_mech = &sc->mech_set->elements[i];\n\tif (acc_negState != REQUEST_MIC)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc->mech_complete = 0;\n\tsc->mic_reqd = 1;\n\t*negState = REQUEST_MIC;\n\t*tokflag = CONT_TOKEN_SEND;\n\treturn GSS_S_CONTINUE_NEEDED;\n}", "target": 1}
{"code": "static char *__filterQuotedShell(const char *arg) {\n\tr_return_val_if_fail (arg, NULL);\n\tchar *a = malloc (strlen (arg) + 1);\n\tif (!a) {\n\t\treturn NULL;\n\t}\n\tchar *b = a;\n\twhile (*arg) {\n\t\tswitch (*arg) {\n\t\tcase ' ':\n\t\tcase '=':\n\t\tcase '\"':\n\t\tcase '\\\\':\n\t\tcase '\\r':\n\t\tcase '\\n':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*b++ = *arg;\n\t\t\tbreak;\n\t\t}\n\t\targ++;\n\t}\n\t*b = 0;\n\treturn a;\n}", "target": 0}
{"code": "ext4_xattr_put_super(struct super_block *sb)\n{\n\tmb_cache_shrink(sb->s_bdev);\n}", "target": 1}
{"code": "nautilus_file_mark_desktop_file_trusted (GFile              *file,\n                                         GtkWindow          *parent_window,\n                                         gboolean            interactive,\n                                         NautilusOpCallback  done_callback,\n                                         gpointer            done_callback_data)\n{\n    GTask *task;\n    MarkTrustedJob *job;\n    job = op_job_new (MarkTrustedJob, parent_window);\n    job->file = g_object_ref (file);\n    job->interactive = interactive;\n    job->done_callback = done_callback;\n    job->done_callback_data = done_callback_data;\n    task = g_task_new (NULL, NULL, mark_trusted_task_done, job);\n    g_task_set_task_data (task, job, NULL);\n    g_task_run_in_thread (task, mark_trusted_task_thread_func);\n    g_object_unref (task);\n}", "target": 1}
{"code": "\tCmdResult Handle (const std::vector<std::string>& parameters, User *user)\n\t{\n\t\tif (user->registered != REG_ALL)\n\t\t{\n\t\t\tif (!cap.ext.get(user))\n\t\t\t\treturn CMD_FAILURE;\n\t\t\tif (parameters[0].find(' ') != std::string::npos || parameters[0][0] == ':')\n\t\t\t\treturn CMD_FAILURE;\n\t\t\tSaslAuthenticator *sasl = authExt.get(user);\n\t\t\tif (!sasl)\n\t\t\t\tauthExt.set(user, new SaslAuthenticator(user, parameters[0]));\n\t\t\telse if (sasl->SendClientMessage(parameters) == false)\t\n\t\t\t{\n\t\t\t\tsasl->AnnounceState();\n\t\t\t\tauthExt.unset(user);\n\t\t\t}\n\t\t}\n\t\treturn CMD_FAILURE;\n\t}", "target": 0}
{"code": "static int em_jcxz(struct x86_emulate_ctxt *ctxt)\n{\n\tif (address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) == 0)\n\t\tjmp_rel(ctxt, ctxt->src.val);\n\treturn X86EMUL_CONTINUE;\n}", "target": 1}
{"code": "FramebufferModel::FramebufferModel(QObject* parent)\n  : QObject(parent)\n  , m_pixelBuffer(nullptr)\n  , m_width(0)\n  , m_height(0)\n  , m_isImageLoaded(false)\n  , m_exposure(0)\n  , m_imageLoadingWatcher(new QFutureWatcher<void>(this))\n  , m_imageEditingWatcher(new QFutureWatcher<void>(this))\n  , m_pixelAspectRatio(1.f)\n{}", "target": 1}
{"code": "IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(\n    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,\n    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index) {\n  ASSERT(codec_client_ != nullptr);\n  IntegrationStreamDecoderPtr response;\n  if (request_body_size) {\n    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);\n  } else {\n    response = codec_client_->makeHeaderOnlyRequest(request_headers);\n  }\n  waitForNextUpstreamRequest(upstream_index);\n  upstream_request_->encodeHeaders(response_headers, response_size == 0);\n  if (response_size) {\n    upstream_request_->encodeData(response_size, true);\n  }\n  response->waitForEndStream();\n  return response;\n}", "target": 1}
{"code": "INST_HANDLER (sts) {\t\n\tif (len < 4) {\n\t\treturn;\n\t}\n\tint r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tint k = (buf[3] << 8) | buf[2];\n\top->ptr = k;\n\tESIL_A (\"r%d,\", r);\n\t__generic_ld_st (op, \"ram\", 0, 1, 0, k, 1);\n\top->cycles = 2;\n}", "target": 0}
{"code": "normalizeLines(XML_Char *s)\n{\n  XML_Char *p;\n  for (;; s++) {\n    if (*s == XML_T('\\0'))\n      return;\n    if (*s == 0xD)\n      break;\n  }\n  p = s;\n  do {\n    if (*s == 0xD) {\n      *p++ = 0xA;\n      if (*++s == 0xA)\n        s++;\n    }\n    else\n      *p++ = *s++;\n  } while (*s);\n  *p = XML_T('\\0');\n}", "target": 0}
{"code": "static int nft_inner_init(const struct nft_ctx *ctx,\n\t\t\t  const struct nft_expr *expr,\n\t\t\t  const struct nlattr * const tb[])\n{\n\tstruct nft_inner *priv = nft_expr_priv(expr);\n\tu32 flags, hdrsize, type, num;\n\tstruct nft_expr_info expr_info;\n\tint err;\n\tif (!tb[NFTA_INNER_FLAGS] ||\n\t    !tb[NFTA_INNER_NUM] ||\n\t    !tb[NFTA_INNER_HDRSIZE] ||\n\t    !tb[NFTA_INNER_TYPE] ||\n\t    !tb[NFTA_INNER_EXPR])\n\t\treturn -EINVAL;\n\tflags = ntohl(nla_get_be32(tb[NFTA_INNER_FLAGS]));\n\tif (flags & ~NFT_INNER_MASK)\n\t\treturn -EOPNOTSUPP;\n\tnum = ntohl(nla_get_be32(tb[NFTA_INNER_NUM]));\n\tif (num != 0)\n\t\treturn -EOPNOTSUPP;\n\thdrsize = ntohl(nla_get_be32(tb[NFTA_INNER_HDRSIZE]));\n\ttype = ntohl(nla_get_be32(tb[NFTA_INNER_TYPE]));\n\tif (type > U8_MAX)\n\t\treturn -EINVAL;\n\tif (flags & NFT_INNER_HDRSIZE) {\n\t\tif (hdrsize == 0 || hdrsize > 64)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\tpriv->flags = flags;\n\tpriv->hdrsize = hdrsize;\n\tpriv->type = type;\n\terr = nft_expr_inner_parse(ctx, tb[NFTA_INNER_EXPR], &expr_info);\n\tif (err < 0)\n\t\treturn err;\n\tpriv->expr.ops = expr_info.ops;\n\tif (!strcmp(expr_info.ops->type->name, \"payload\"))\n\t\tpriv->expr_type = NFT_INNER_EXPR_PAYLOAD;\n\telse if (!strcmp(expr_info.ops->type->name, \"meta\"))\n\t\tpriv->expr_type = NFT_INNER_EXPR_META;\n\telse\n\t\treturn -EINVAL;\n\terr = expr_info.ops->init(ctx, (struct nft_expr *)&priv->expr,\n\t\t\t\t  (const struct nlattr * const*)expr_info.tb);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}", "target": 0}
{"code": "static inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)\n{\n\tpmd_t pmdval = pmd_read_atomic(pmd);\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tbarrier();\n#endif\n\tif (pmd_none(pmdval))\n\t\treturn 1;\n\tif (unlikely(pmd_bad(pmdval))) {\n\t\tif (!pmd_trans_huge(pmdval))\n\t\t\tpmd_clear_bad(pmd);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void TestGatherNd(int* param_dims, const ParamType* param_data, int* index_dims,\n                  const IndexType* index_data, int* output_dims,\n                  ParamType* output_data,\n                  const ParamType* expected_output_data) {\n  TfLiteIntArray* pdims = IntArrayFromInts(param_dims);\n  TfLiteIntArray* idims = IntArrayFromInts(index_dims);\n  TfLiteIntArray* odims = IntArrayFromInts(output_dims);\n  constexpr int inputs_size = 2;\n  constexpr int outputs_size = 1;\n  constexpr int tensors_size = inputs_size + outputs_size;\n  TfLiteTensor tensors[tensors_size] = {\n      CreateTensor(param_data, pdims),\n      CreateTensor(index_data, idims),\n      CreateTensor(output_data, odims),\n  };\n  int inputs_array_data[] = {2, 0, 1};\n  TfLiteIntArray* inputs_array = IntArrayFromInts(inputs_array_data);\n  int outputs_array_data[] = {1, 2};\n  TfLiteIntArray* outputs_array = IntArrayFromInts(outputs_array_data);\n  const TfLiteRegistration registration = Register_GATHER_ND();\n  micro::KernelRunner runner(registration, tensors, tensors_size, inputs_array,\n                             outputs_array, nullptr);\n  TF_LITE_MICRO_EXPECT_EQ(kTfLiteOk, runner.InitAndPrepare());\n  TF_LITE_MICRO_EXPECT_EQ(kTfLiteOk, runner.Invoke());\n  TfLiteTensor* actual_output_tensor = &tensors[2];\n  TfLiteIntArray* actual_output_dims = actual_output_tensor->dims;\n  const int output_size = ElementCount(*actual_output_dims);\n  for (int i = 0; i < output_size; ++i) {\n    TF_LITE_MICRO_EXPECT_EQ(expected_output_data[i], output_data[i]);\n  }\n}", "target": 1}
{"code": "bool SQClass::NewSlot(SQSharedState *ss,const SQObjectPtr &key,const SQObjectPtr &val,bool bstatic)\n{\n    SQObjectPtr temp;\n    bool belongs_to_static_table = sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE || bstatic;\n    if(_locked && !belongs_to_static_table)\n        return false; \n    if(_members->Get(key,temp) && _isfield(temp)) \n    {\n        _defaultvalues[_member_idx(temp)].val = val;\n        return true;\n    }\n\tif (_members->CountUsed() >= MEMBER_MAX_COUNT) {\n\t\treturn false;\n\t}\n    if(belongs_to_static_table) {\n        SQInteger mmidx;\n        if((sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE) &&\n            (mmidx = ss->GetMetaMethodIdxByName(key)) != -1) {\n            _metamethods[mmidx] = val;\n        }\n        else {\n            SQObjectPtr theval = val;\n            if(_base && sq_type(val) == OT_CLOSURE) {\n                theval = _closure(val)->Clone();\n                _closure(theval)->_base = _base;\n                __ObjAddRef(_base); \n            }\n            if(sq_type(temp) == OT_NULL) {\n                bool isconstructor;\n                SQVM::IsEqual(ss->_constructoridx, key, isconstructor);\n                if(isconstructor) {\n                    _constructoridx = (SQInteger)_methods.size();\n                }\n                SQClassMember m;\n                m.val = theval;\n                _members->NewSlot(key,SQObjectPtr(_make_method_idx(_methods.size())));\n                _methods.push_back(m);\n            }\n            else {\n                _methods[_member_idx(temp)].val = theval;\n            }\n        }\n        return true;\n    }\n    SQClassMember m;\n    m.val = val;\n    _members->NewSlot(key,SQObjectPtr(_make_field_idx(_defaultvalues.size())));\n    _defaultvalues.push_back(m);\n    return true;\n}", "target": 0}
{"code": "void color_sycc_to_rgb(opj_image_t *img)\n{\n\tif(img->numcomps < 3)\n\t{\n\t\timg->color_space = OPJ_CLRSPC_GRAY;\n\t\treturn;\n\t}\n\tif((img->comps[0].dx == 1)\n\t&& (img->comps[1].dx == 2)\n\t&& (img->comps[2].dx == 2)\n\t&& (img->comps[0].dy == 1)\n\t&& (img->comps[1].dy == 2)\n\t&& (img->comps[2].dy == 2))\n  {\n\t\tsycc420_to_rgb(img);\n  }\n\telse\n\tif((img->comps[0].dx == 1)\n\t&& (img->comps[1].dx == 2)\n\t&& (img->comps[2].dx == 2)\n\t&& (img->comps[0].dy == 1)\n\t&& (img->comps[1].dy == 1)\n\t&& (img->comps[2].dy == 1))\n  {\n\t\tsycc422_to_rgb(img);\n  }\n\telse\n\tif((img->comps[0].dx == 1)\n\t&& (img->comps[1].dx == 1)\n\t&& (img->comps[2].dx == 1)\n\t&& (img->comps[0].dy == 1)\n\t&& (img->comps[1].dy == 1)\n\t&& (img->comps[2].dy == 1))\n  {\n\t\tsycc444_to_rgb(img);\n  }\n\telse\n  {\n\t\tfprintf(stderr,\"%s:%d:color_sycc_to_rgb\\n\\tCAN NOT CONVERT\\n\", __FILE__,__LINE__);\n\t\treturn;\n  }\n\timg->color_space = OPJ_CLRSPC_SRGB;\n}", "target": 1}
{"code": "TfLiteStatus ResizeOutputTensors(TfLiteContext* context, TfLiteNode* node,\n                                 const TfLiteTensor* axis,\n                                 const TfLiteTensor* input, int num_splits) {\n  int axis_value = GetTensorData<int>(axis)[0];\n  if (axis_value < 0) {\n    axis_value += NumDimensions(input);\n  }\n  TF_LITE_ENSURE(context, axis_value >= 0);\n  TF_LITE_ENSURE(context, axis_value < NumDimensions(input));\n  const int input_size = SizeOfDimension(input, axis_value);\n  TF_LITE_ENSURE(context, num_splits != 0);\n  TF_LITE_ENSURE_MSG(context, input_size % num_splits == 0,\n                     \"Not an even split\");\n  const int slice_size = input_size / num_splits;\n  for (int i = 0; i < NumOutputs(node); ++i) {\n    TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input->dims);\n    output_dims->data[axis_value] = slice_size;\n    TfLiteTensor* output;\n    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output));\n    TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_dims));\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static void WriteBinaryGltfStream(std::ostream &stream,\n                                  const std::string &content,\n                                  const std::vector<unsigned char> &binBuffer) {\n  const std::string header = \"glTF\";\n  const int version = 2;\n  const uint32_t content_size = uint32_t(content.size());\n  const uint32_t binBuffer_size = uint32_t(binBuffer.size());\n  const uint32_t content_padding_size = content_size % 4 == 0 ? 0 : 4 - content_size % 4;\n  const uint32_t bin_padding_size = binBuffer_size % 4 == 0 ? 0 : 4 - binBuffer_size % 4;\n  const uint32_t length =\n      12 + 8 + content_size + content_padding_size +\n      (binBuffer_size ? (8 + binBuffer_size + bin_padding_size) : 0);\n  stream.write(header.c_str(), std::streamsize(header.size()));\n  stream.write(reinterpret_cast<const char *>(&version), sizeof(version));\n  stream.write(reinterpret_cast<const char *>(&length), sizeof(length));\n  const uint32_t model_length = uint32_t(content.size()) + content_padding_size;\n  const uint32_t model_format = 0x4E4F534A;\n  stream.write(reinterpret_cast<const char *>(&model_length),\n               sizeof(model_length));\n  stream.write(reinterpret_cast<const char *>(&model_format),\n               sizeof(model_format));\n  stream.write(content.c_str(), std::streamsize(content.size()));\n  if (content_padding_size > 0) {\n    const std::string padding = std::string(size_t(content_padding_size), ' ');\n    stream.write(padding.c_str(), std::streamsize(padding.size()));\n  }\n  if (binBuffer.size() > 0) {\n    const uint32_t bin_length = uint32_t(binBuffer.size()) + bin_padding_size;\n    const uint32_t bin_format = 0x004e4942;\n    stream.write(reinterpret_cast<const char *>(&bin_length),\n                 sizeof(bin_length));\n    stream.write(reinterpret_cast<const char *>(&bin_format),\n                 sizeof(bin_format));\n    stream.write(reinterpret_cast<const char *>(binBuffer.data()),\n                 std::streamsize(binBuffer.size()));\n    if (bin_padding_size > 0) {\n      const std::vector<unsigned char> padding =\n          std::vector<unsigned char>(size_t(bin_padding_size), 0);\n      stream.write(reinterpret_cast<const char *>(padding.data()),\n                   std::streamsize(padding.size()));\n    }\n  }\n}", "target": 1}
{"code": "static void br_multicast_del_pg(struct net_bridge *br,\n\t\t\t\tstruct net_bridge_port_group *pg)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tmdb = mlock_dereference(br->mdb, br);\n\tmp = br_mdb_ip_get(mdb, &pg->addr);\n\tif (WARN_ON(!mp))\n\t\treturn;\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p != pg)\n\t\t\tcontinue;\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n\t\tdel_timer(&p->timer);\n\t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n\t\tif (!mp->ports && !mp->mglist &&\n\t\t    netif_running(br->dev))\n\t\t\tmod_timer(&mp->timer, jiffies);\n\t\treturn;\n\t}\n\tWARN_ON(1);\n}", "target": 1}
{"code": "struct file *get_empty_filp(void)\n{\n\tconst struct cred *cred = current_cred();\n\tstatic long old_max;\n\tstruct file *f;\n\tint error;\n\tif (get_nr_files() >= files_stat.max_files && !capable(CAP_SYS_ADMIN)) {\n\t\tif (percpu_counter_sum_positive(&nr_files) >= files_stat.max_files)\n\t\t\tgoto over;\n\t}\n\tf = kmem_cache_zalloc(filp_cachep, GFP_KERNEL);\n\tif (unlikely(!f))\n\t\treturn ERR_PTR(-ENOMEM);\n\tpercpu_counter_inc(&nr_files);\n\tf->f_cred = get_cred(cred);\n\terror = security_file_alloc(f);\n\tif (unlikely(error)) {\n\t\tfile_free(f);\n\t\treturn ERR_PTR(error);\n\t}\n\tINIT_LIST_HEAD(&f->f_u.fu_list);\n\tatomic_long_set(&f->f_count, 1);\n\trwlock_init(&f->f_owner.lock);\n\tspin_lock_init(&f->f_lock);\n\teventpoll_init_file(f);\n\treturn f;\nover:\n\tif (get_nr_files() > old_max) {\n\t\tpr_info(\"VFS: file-max limit %lu reached\\n\", get_max_files());\n\t\told_max = get_nr_files();\n\t}\n\treturn ERR_PTR(-ENFILE);\n}", "target": 1}
{"code": "SslSocket::SslSocket(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,\n                     const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,\n                     Ssl::HandshakerFactoryCb handshaker_factory_cb)\n    : transport_socket_options_(transport_socket_options),\n      ctx_(std::dynamic_pointer_cast<ContextImpl>(ctx)),\n      info_(std::dynamic_pointer_cast<SslHandshakerImpl>(handshaker_factory_cb(\n          ctx_->newSsl(transport_socket_options_), ctx_->sslExtendedSocketInfoIndex(), this))) {\n  if (state == InitialState::Client) {\n    SSL_set_connect_state(rawSsl());\n  } else {\n    ASSERT(state == InitialState::Server);\n    SSL_set_accept_state(rawSsl());\n  }\n}", "target": 1}
{"code": "static int propagate_one(struct mount *m)\n{\n\tstruct mount *child;\n\tint type;\n\tif (IS_MNT_NEW(m))\n\t\treturn 0;\n\tif (!is_subdir(mp->m_dentry, m->mnt.mnt_root))\n\t\treturn 0;\n\tif (peers(m, last_dest)) {\n\t\ttype = CL_MAKE_SHARED;\n\t} else {\n\t\tstruct mount *n, *p;\n\t\tbool done;\n\t\tfor (n = m; ; n = p) {\n\t\t\tp = n->mnt_master;\n\t\t\tif (p == dest_master || IS_MNT_MARKED(p))\n\t\t\t\tbreak;\n\t\t}\n\t\tdo {\n\t\t\tstruct mount *parent = last_source->mnt_parent;\n\t\t\tif (last_source == first_source)\n\t\t\t\tbreak;\n\t\t\tdone = parent->mnt_master == p;\n\t\t\tif (done && peers(n, parent))\n\t\t\t\tbreak;\n\t\t\tlast_source = last_source->mnt_master;\n\t\t} while (!done);\n\t\ttype = CL_SLAVE;\n\t\tif (IS_MNT_SHARED(m))\n\t\t\ttype |= CL_MAKE_SHARED;\n\t}\n\tif (m->mnt_ns->user_ns != user_ns)\n\t\ttype |= CL_UNPRIVILEGED;\n\tchild = copy_tree(last_source, last_source->mnt.mnt_root, type);\n\tif (IS_ERR(child))\n\t\treturn PTR_ERR(child);\n\tchild->mnt.mnt_flags &= ~MNT_LOCKED;\n\tmnt_set_mountpoint(m, mp, child);\n\tlast_dest = m;\n\tlast_source = child;\n\tif (m->mnt_master != dest_master) {\n\t\tread_seqlock_excl(&mount_lock);\n\t\tSET_MNT_MARK(m->mnt_master);\n\t\tread_sequnlock_excl(&mount_lock);\n\t}\n\thlist_add_head(&child->mnt_hash, list);\n\treturn count_mounts(m->mnt_ns, child);\n}", "target": 0}
{"code": "generate_ava(cms_context *cms, SECItem *der, CERTAVA *certava)\n{\n\tava ava;\n\tSECOidData *oid;\n\tvoid *arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);\n\tif (arena == NULL)\n\t\tcnreterr(-1, cms, \"could not create arena\");\n\tvoid *real_arena = cms->arena;\n\tcms->arena = arena;\n\toid = SECOID_FindOID(&certava->type);\n\tif (!oid) {\n\t\tsave_port_err() {\n\t\t\tPORT_FreeArena(arena, PR_TRUE);\n\t\t}\n\t\tcms->arena = real_arena;\n\t\tcnreterr(-1, cms, \"could not find OID\");\n\t}\n\tint rc = generate_object_id(cms, &ava.type, oid->offset);\n\tif (rc < 0) {\n\t\tPORT_FreeArena(arena, PR_TRUE);\n\t\tcms->arena = real_arena;\n\t\treturn -1;\n\t}\n\tmemcpy(&ava.value, &certava->value, sizeof (ava.value));\n\tvoid *ret;\n\tSECItem tmp;\n\tret = SEC_ASN1EncodeItem(arena, &tmp, &ava, AVATemplate);\n\tif (ret == NULL) {\n\t\tsave_port_err() {\n\t\t\tPORT_FreeArena(arena, PR_TRUE);\n\t\t}\n\t\tcms->arena = real_arena;\n\t\tcnreterr(-1, cms, \"could not encode AVA\");\n\t}\n\tder->type = tmp.type;\n\tder->len = tmp.len;\n\tder->data = PORT_ArenaAlloc(real_arena, tmp.len);\n\tif (!der->data) {\n\t\tsave_port_err() {\n\t\t\tPORT_FreeArena(arena, PR_TRUE);\n\t\t}\n\t\tcms->arena = real_arena;\n\t\tcnreterr(-1, cms, \"could not allocate AVA\");\n\t}\n\tmemcpy(der->data, tmp.data, tmp.len);\n\tPORT_FreeArena(arena, PR_TRUE);\n\tcms->arena = real_arena;\n\treturn 0;\n}", "target": 0}
{"code": "void AverageEvalFloat(TfLiteContext* context, TfLiteNode* node,\n                      TfLitePoolParams* params, OpData* data,\n                      const TfLiteTensor* input, TfLiteTensor* output) {\n  float activation_min, activation_max;\n  CalculateActivationRange(params->activation, &activation_min,\n                           &activation_max);\n#define TF_LITE_AVERAGE_POOL(type)                                       \\\n  tflite::PoolParams op_params;                                          \\\n  op_params.stride_height = params->stride_height;                       \\\n  op_params.stride_width = params->stride_width;                         \\\n  op_params.filter_height = params->filter_height;                       \\\n  op_params.filter_width = params->filter_width;                         \\\n  op_params.padding_values.height = data->padding.height;                \\\n  op_params.padding_values.width = data->padding.width;                  \\\n  op_params.float_activation_min = activation_min;                       \\\n  op_params.float_activation_max = activation_max;                       \\\n  type::AveragePool(op_params, GetTensorShape(input),                    \\\n                    GetTensorData<float>(input), GetTensorShape(output), \\\n                    GetTensorData<float>(output))\n  if (kernel_type == kReference) {\n    TF_LITE_AVERAGE_POOL(reference_ops);\n  } else {\n    TF_LITE_AVERAGE_POOL(optimized_ops);\n  }\n#undef TF_LITE_AVERAGE_POOL\n}", "target": 1}
{"code": "tar_directory_for_file (GsfInfileTar *dir, const char *name, gboolean last)\n{\n\tconst char *s = name;\n\twhile (1) {\n\t\tconst char *s0 = s;\n\t\tchar *dirname;\n\t\twhile (1) {\n\t\t\tif (*s == 0) {\n\t\t\t\tif (last && s != s0)\n\t\t\t\t\tbreak;\n\t\t\t\telse\n\t\t\t\t\treturn dir;\n\t\t\t}\n\t\t\tif (*s == '/')\n\t\t\t\tbreak;\n\t\t\ts++;\n\t\t}\n\t\tdirname = g_strndup (s0, s - s0);\n\t\twhile (*s == '/')\n\t\t\ts++;\n\t\tif (strcmp (dirname, \".\") != 0) {\n\t\t\tGsfInput *subdir =\n\t\t\t\tgsf_infile_child_by_name (GSF_INFILE (dir),\n\t\t\t\t\t\t\t  dirname);\n\t\t\tif (subdir) {\n\t\t\t\tg_object_unref (subdir);\n\t\t\t\tdir = GSF_INFILE_TAR (subdir);\n\t\t\t} else\n\t\t\t\tdir = tar_create_dir (dir, dirname);\n\t\t}\n\t\tg_free (dirname);\n\t}\n}", "target": 1}
{"code": "header_cache_t *imap_hcache_open(struct ImapData *idata, const char *path)\n{\n  struct ImapMbox mx;\n  struct Url url;\n  char cachepath[PATH_MAX];\n  char mbox[PATH_MAX];\n  if (path)\n    imap_cachepath(idata, path, mbox, sizeof(mbox));\n  else\n  {\n    if (!idata->ctx || imap_parse_path(idata->ctx->path, &mx) < 0)\n      return NULL;\n    imap_cachepath(idata, mx.mbox, mbox, sizeof(mbox));\n    FREE(&mx.mbox);\n  }\n  if (strstr(mbox, \"/../\") || (strcmp(mbox, \"..\") == 0) || (strncmp(mbox, \"../\", 3) == 0))\n    return NULL;\n  size_t len = strlen(mbox);\n  if ((len > 3) && (strcmp(mbox + len - 3, \"/..\") == 0))\n    return NULL;\n  mutt_account_tourl(&idata->conn->account, &url);\n  url.path = mbox;\n  url_tostring(&url, cachepath, sizeof(cachepath), U_PATH);\n  return mutt_hcache_open(HeaderCache, cachepath, imap_hcache_namer);\n}", "target": 0}
{"code": "is_valid_filename (const char *p)\n{\n\tif (!*p)\n\t\treturn 0;\n\treturn strpbrk (p, \"\\\\\n}", "target": 0}
{"code": "gerb_fopen(char const * filename)\n{\n    gerb_file_t *fd;\n    struct stat statinfo;\n    dprintf(\"---> Entering gerb_fopen, filename = %s\\n\", filename);\n    fd = g_new(gerb_file_t, 1);\n    if (fd == NULL) {\n\treturn NULL;\n    }\n    dprintf(\"     Doing fopen\\n\");\n    fd->fd = g_fopen(filename, \"rb\");\n    if (fd->fd == NULL) {\n\tg_free(fd);\n\treturn NULL;\n    }\n    dprintf(\"     Doing fstat\\n\");\n    fd->ptr = 0;\n    fd->fileno = fileno(fd->fd);\n    if (fstat(fd->fileno, &statinfo) < 0) {\n\tfclose(fd->fd);\n\tg_free(fd);\n\treturn NULL;\n    }\n    dprintf(\"     Checking S_ISREG\\n\");\n    if (!S_ISREG(statinfo.st_mode)) {\n\tfclose(fd->fd);\n\tg_free(fd);\n\terrno = EISDIR;\n\treturn NULL;\n    }\n    dprintf(\"     Checking statinfo.st_size\\n\");\n    if ((int)statinfo.st_size == 0) {\n\tfclose(fd->fd);\n\tg_free(fd);\n\terrno = EIO; \n\treturn NULL;\n    }\n#ifdef HAVE_SYS_MMAN_H\n    dprintf(\"     Doing mmap\\n\");\n    fd->datalen = (int)statinfo.st_size;\n    fd->data = (char *)mmap(0, statinfo.st_size, PROT_READ, MAP_PRIVATE, \n\t\t\t    fd->fileno, 0);\n    if(fd->data == MAP_FAILED) {\n\tfclose(fd->fd);\n\tg_free(fd);\n\tfd = NULL;\n    }\n#else\n    dprintf(\"     Doing calloc\\n\");\n    fd->datalen = (int)statinfo.st_size;\n    fd->data = calloc(1, statinfo.st_size + 1);\n    if (fd->data == NULL) {\n        fclose(fd->fd);\n        g_free(fd);\n        return NULL;\n    }\n    if (fread((void*)fd->data, 1, statinfo.st_size, fd->fd) != statinfo.st_size) {\n        fclose(fd->fd);\n\tg_free(fd->data);\n        g_free(fd);\n\treturn NULL;\n    }\n    rewind (fd->fd);\n#endif\n    dprintf(\"     Setting filename\\n\");\n    fd->filename = g_strdup(filename);\n    dprintf(\"<--- Leaving gerb_fopen\\n\");\n    return fd;\n} ", "target": 0}
{"code": "void PdfXRefStreamParserObject::ReadXRefTable()\n{\n    int64_t size = this->GetDictionary().FindKeyAs<int64_t>(PdfName::KeySize, 0);\n    auto& arrObj = this->GetDictionary().MustFindKey(\"W\");\n    const PdfArray* arr;\n    if (!arrObj.TryGetArray(arr) || arr->size() != 3)\n        PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef stream /W array\");\n    int64_t wArray[W_ARRAY_SIZE] = { 0, 0, 0 };\n    int64_t num;\n    for (unsigned i = 0; i < W_ARRAY_SIZE; i++)\n    {\n        if (!(*arr)[i].TryGetNumber(num))\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef stream /W array\");\n        wArray[i] = num;\n    }\n    vector<int64_t> indices;\n    getIndices(indices, static_cast<int64_t>(size));\n    parseStream(wArray, indices);\n}", "target": 1}
{"code": "content::WebContents* WebContents::OpenURLFromTab(\n    content::WebContents* source,\n    const content::OpenURLParams& params) {\n  if (params.disposition != WindowOpenDisposition::CURRENT_TAB) {\n    Emit(\"-new-window\", params.url, \"\", params.disposition, \"\", params.referrer,\n         params.post_data);\n    return nullptr;\n  }\n  if (Emit(\"will-navigate\", params.url))\n    return nullptr;\n  if (IsDestroyed())\n    return nullptr;\n  return CommonWebContentsDelegate::OpenURLFromTab(source, params);\n}", "target": 1}
{"code": "resolve_iffeature(struct lys_iffeature *expr)\n{\n    int index_e = 0, index_f = 0;\n    if (expr->expr) {\n        return resolve_iffeature_recursive(expr, &index_e, &index_f);\n    }\n    return 0;\n}", "target": 1}
{"code": "void test_mkdir(const char *path)\n{\n\tsize_t len = strlen(path) + 30;\n\tchar *tmpname = alloca(len);\n\tsnprintf(tmpname, len, \"%s/%d\", path, (int)getpid());\n\tif (mkdir(path, 0755) == 0) {\n\t\tfprintf(stderr, \"leak at mkdir of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at mkdir of %s, errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n\tif (mkdir(tmpname, 0755) == 0) {\n\t\tfprintf(stderr, \"leak at mkdir of %s\\n\", tmpname);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at mkdir of %s, errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "mm_compare(struct mm_share *a, struct mm_share *b)\n{\n\tptrdiff_t diff = (char *)a->address - (char *)b->address;\n\tif (diff == 0)\n\t\treturn (0);\n\telse if (diff < 0)\n\t\treturn (-1);\n\telse\n\t\treturn (1);\n}", "target": 1}
{"code": "TfLiteRegistration AddOpRegistration() {\n  TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n  reg.custom_name = \"my_add\";\n  reg.builtin_code = tflite::BuiltinOperator_CUSTOM;\n  reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n    const TfLiteTensor* input1 = GetInput(context, node, 0);\n    const TfLiteTensor* input2 = GetInput(context, node, 1);\n    TfLiteTensor* output = GetOutput(context, node, 0);\n    TF_LITE_ENSURE_EQ(context, input1->dims->size, input2->dims->size);\n    for (int i = 0; i < input1->dims->size; ++i) {\n      TF_LITE_ENSURE_EQ(context, input1->dims->data[i], input2->dims->data[i]);\n    }\n    TF_LITE_ENSURE_STATUS(context->ResizeTensor(\n        context, output, TfLiteIntArrayCopy(input1->dims)));\n    return kTfLiteOk;\n  };\n  reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n    const TfLiteTensor* a0 = GetInput(context, node, 0);\n    TF_LITE_ENSURE(context, a0);\n    TF_LITE_ENSURE(context, a0->data.f);\n    const TfLiteTensor* a1 = GetInput(context, node, 1);\n    TF_LITE_ENSURE(context, a1);\n    TF_LITE_ENSURE(context, a1->data.f);\n    TfLiteTensor* out = GetOutput(context, node, 0);\n    TF_LITE_ENSURE(context, out);\n    TF_LITE_ENSURE(context, out->data.f);\n    int num = a0->dims->data[0];\n    for (int i = 0; i < num; i++) {\n      out->data.f[i] = a0->data.f[i] + a1->data.f[i];\n    }\n    return kTfLiteOk;\n  };\n  return reg;\n}", "target": 1}
{"code": "STATIC void\nS_put_code_point(pTHX_ SV *sv, UV c)\n{\n    PERL_ARGS_ASSERT_PUT_CODE_POINT;\n    if (c > 255) {\n        Perl_sv_catpvf(aTHX_ sv, \"\\\\x{%04\" UVXf \"}\", c);\n    }\n    else if (isPRINT(c)) {\n\tconst char string = (char) c;\n\tif (isBACKSLASHED_PUNCT(c) || c == '{' || c == '}')\n\t    sv_catpvs(sv, \"\\\\\");\n\tsv_catpvn(sv, &string, 1);\n    }\n    else if (isMNEMONIC_CNTRL(c)) {\n        Perl_sv_catpvf(aTHX_ sv, \"%s\", cntrl_to_mnemonic((U8) c));\n    }\n    else {\n        Perl_sv_catpvf(aTHX_ sv, \"\\\\x%02X\", (U8) c);\n    }", "target": 0}
{"code": "void HeaderMapImpl::addViaMove(HeaderString&& key, HeaderString&& value) {\n  auto* entry = getExistingInline(key.getStringView());\n  if (entry != nullptr) {\n    appendToHeader(entry->value(), value.getStringView());\n    key.clear();\n    value.clear();\n  } else {\n    insertByKey(std::move(key), std::move(value));\n  }\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& sorted_inputs_t = ctx->input(0);\n    const Tensor& values_t = ctx->input(1);\n    OP_REQUIRES(\n        ctx, sorted_inputs_t.shape().dims() == 2,\n        errors::InvalidArgument(absl::StrCat(\n            \"Shape must be rank 2 but is rank \", sorted_inputs_t.shape().dims(),\n            \" for \"\n            \"`sorted_inputs` argument\")));\n    OP_REQUIRES(ctx, values_t.shape().dims() == 2,\n                errors::InvalidArgument(absl::StrCat(\n                    \"Shape must be rank 2 but is rank \",\n                    values_t.shape().dims(), \" for `values` argument\")));\n    OP_REQUIRES(ctx, sorted_inputs_t.dim_size(0) == values_t.dim_size(0),\n                Status(error::INVALID_ARGUMENT,\n                       \"Leading dim_size of both tensors must match.\"));\n    OP_REQUIRES(ctx, values_t.NumElements() < std::numeric_limits<int>::max(),\n                Status(error::INVALID_ARGUMENT,\n                       \"values tensor size must less than INT_MAX\"));\n    Tensor* output_t;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, values_t.shape(), &output_t));\n    if (output_t->dtype() == DT_INT32) {\n      OP_REQUIRES(ctx,\n                  FastBoundsCheck(sorted_inputs_t.dim_size(1),\n                                  std::numeric_limits<int>::max()),\n                  errors::InvalidArgument(\"trailing dim_size must less than \"\n                                          \"INT_MAX for int32 output type, was \",\n                                          sorted_inputs_t.dim_size(1)));\n    }\n    auto output = output_t->template flat<OutType>();\n    const auto sorted_inputs = sorted_inputs_t.template flat<T>();\n    const auto values = values_t.template flat<T>();\n    if (sorted_inputs.size() == 0) {\n      functor::SetZeroFunctor<Device, OutType> set_zero;\n      set_zero(ctx->eigen_device<Device>(), output);\n      return;\n    }\n    OP_REQUIRES_OK(\n        ctx, functor::UpperBoundFunctor<Device, T, OutType>::Compute(\n                 ctx, sorted_inputs, values, sorted_inputs_t.dim_size(0),\n                 sorted_inputs_t.dim_size(1), values_t.dim_size(1), &output));\n  }", "target": 0}
{"code": "static int net_ctl_permissions(struct ctl_table_header *head,\n\t\t\t       struct ctl_table *table)\n{\n\tstruct net *net = container_of(head->set, struct net, sysctls);\n\tkuid_t root_uid = make_kuid(net->user_ns, 0);\n\tkgid_t root_gid = make_kgid(net->user_ns, 0);\n\tif (ns_capable(net->user_ns, CAP_NET_ADMIN) ||\n\t    uid_eq(root_uid, current_uid())) {\n\t\tint mode = (table->mode >> 6) & 7;\n\t\treturn (mode << 6) | (mode << 3) | mode;\n\t}\n\tif (gid_eq(root_gid, current_gid())) {\n\t\tint mode = (table->mode >> 3) & 7;\n\t\treturn (mode << 3) | mode;\n\t}\n\treturn table->mode;\n}", "target": 1}
{"code": "void kvm_release_pfn_clean(kvm_pfn_t pfn)\n{\n\tif (!is_error_noslot_pfn(pfn) && !kvm_is_reserved_pfn(pfn))\n\t\tput_page(pfn_to_page(pfn));\n}", "target": 0}
{"code": "PHP_FUNCTION(imagetruecolortopalette)\n{\n\tzval *IM;\n\tzend_bool dither;\n\tzend_long ncolors;\n\tgdImagePtr im;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rbl\", &IM, &dither, &ncolors) == FAILURE)  {\n\t\treturn;\n\t}\n\tif ((im = (gdImagePtr)zend_fetch_resource(Z_RES_P(IM), \"Image\", le_gd)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tif (ncolors <= 0) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Number of colors has to be greater than zero\");\n\t\tRETURN_FALSE;\n\t}\n\tgdImageTrueColorToPalette(im, dither, ncolors);\n\tRETURN_TRUE;\n}", "target": 1}
{"code": "static int xgene_hwmon_remove(struct platform_device *pdev)\n{\n\tstruct xgene_hwmon_dev *ctx = platform_get_drvdata(pdev);\n\tcancel_work_sync(&ctx->workq);\n\thwmon_device_unregister(ctx->hwmon_dev);\n\tkfifo_free(&ctx->async_msg_fifo);\n\tif (acpi_disabled)\n\t\tmbox_free_channel(ctx->mbox_chan);\n\telse\n\t\tpcc_mbox_free_channel(ctx->pcc_chan);\n\treturn 0;\n}", "target": 0}
{"code": "static inline int mk_vhost_fdt_close(struct session_request *sr)\n{\n    int id;\n    unsigned int hash;\n    struct vhost_fdt_hash_table *ht = NULL;\n    struct vhost_fdt_hash_chain *hc;\n    if (config->fdt == MK_FALSE) {\n        return close(sr->fd_file);\n    }\n    id   = sr->vhost_fdt_id;\n    hash = sr->vhost_fdt_hash;\n    ht = mk_vhost_fdt_table_lookup(id, sr->host_conf);\n    if (mk_unlikely(!ht)) {\n        return close(sr->fd_file);\n    }\n    hc = mk_vhost_fdt_chain_lookup(hash, ht);\n    if (hc) {\n        hc->readers--;\n        if (hc->readers == 0) {\n            hc->fd   = -1;\n            hc->hash = 0;\n            ht->av_slots++;\n            return close(sr->fd_file);\n        }\n        else {\n            return 0;\n        }\n    }\n    return close(sr->fd_file);\n}", "target": 1}
{"code": "void mctp_dev_put(struct mctp_dev *mdev)\n{\n\tif (mdev && refcount_dec_and_test(&mdev->refs)) {\n\t\tkfree(mdev->addrs);\n\t\tdev_put(mdev->dev);\n\t\tkfree_rcu(mdev, rcu);\n\t}\n}", "target": 0}
{"code": "static int search_old_relocation(struct reloc_struct_t *reloc_table, ut32 addr_to_patch, int n_reloc) {\n\tint i;\n\tfor (i = 0; i < n_reloc; i++) {\n\t\tif (addr_to_patch == reloc_table[i].data_offset) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}", "target": 1}
{"code": "static void check_serverpath(request_rec *r)\n{\n    server_rec *s;\n    server_rec *last_s;\n    name_chain *src;\n    apr_port_t port;\n    port = r->connection->local_addr->port;\n    last_s = NULL;\n    for (src = r->connection->vhost_lookup_data; src; src = src->next) {\n        if (src->sar->host_port != 0 && port != src->sar->host_port) {\n            continue;\n        }\n        s = src->server;\n        if (s == last_s) {\n            continue;\n        }\n        last_s = s;\n        if (s->path && !strncmp(r->uri, s->path, s->pathlen) &&\n            (s->path[s->pathlen - 1] == '/' ||\n             r->uri[s->pathlen] == '/' ||\n             r->uri[s->pathlen] == '\\0')) {\n            r->server = s;\n            return;\n        }\n    }\n}", "target": 1}
{"code": "static unsigned long mmap_legacy_base(unsigned long rnd)\n{\n\tif (mmap_is_ia32())\n\t\treturn TASK_UNMAPPED_BASE;\n\telse\n\t\treturn TASK_UNMAPPED_BASE + rnd;\n}", "target": 1}
{"code": "static int seed_from_timestamp_and_pid(uint32_t *seed) {\n#ifdef HAVE_GETTIMEOFDAY\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    *seed = (uint32_t)tv.tv_sec ^ (uint32_t)tv.tv_usec;\n#else\n    *seed = (uint32_t)time(NULL);\n#endif\n#if defined(_WIN32)\n    *seed ^= (uint32_t)_getpid();\n#elif defined(HAVE_GETPID)\n    *seed ^= (uint32_t)getpid();\n#endif\n    return 0;\n}", "target": 0}
{"code": "static int br_mdb_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net_device *dev;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlmsghdr *nlh = NULL;\n\tint idx = 0, s_idx;\n\ts_idx = cb->args[0];\n\trcu_read_lock();\n\tcb->seq = net->dev_base_seq + br_mdb_rehash_seq;\n\tfor_each_netdev_rcu(net, dev) {\n\t\tif (dev->priv_flags & IFF_EBRIDGE) {\n\t\t\tstruct br_port_msg *bpm;\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto skip;\n\t\t\tnlh = nlmsg_put(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\tcb->nlh->nlmsg_seq, RTM_GETMDB,\n\t\t\t\t\tsizeof(*bpm), NLM_F_MULTI);\n\t\t\tif (nlh == NULL)\n\t\t\t\tbreak;\n\t\t\tbpm = nlmsg_data(nlh);\n\t\t\tmemset(bpm, 0, sizeof(*bpm));\n\t\t\tbpm->ifindex = dev->ifindex;\n\t\t\tif (br_mdb_fill_info(skb, cb, dev) < 0)\n\t\t\t\tgoto out;\n\t\t\tif (br_rports_fill_info(skb, cb, dev) < 0)\n\t\t\t\tgoto out;\n\t\t\tcb->args[1] = 0;\n\t\t\tnlmsg_end(skb, nlh);\n\t\tskip:\n\t\t\tidx++;\n\t\t}\n\t}\nout:\n\tif (nlh)\n\t\tnlmsg_end(skb, nlh);\n\trcu_read_unlock();\n\tcb->args[0] = idx;\n\treturn skb->len;\n}", "target": 0}
{"code": "mrb_obj_clone(mrb_state *mrb, mrb_value self)\n{\n  struct RObject *p;\n  mrb_value clone;\n  if (mrb_immediate_p(self)) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"can't clone %S\", self);\n  }\n  if (mrb_type(self) == MRB_TT_SCLASS) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't clone singleton class\");\n  }\n  p = (struct RObject*)mrb_obj_alloc(mrb, mrb_type(self), mrb_obj_class(mrb, self));\n  p->c = mrb_singleton_class_clone(mrb, self);\n  mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)p->c);\n  clone = mrb_obj_value(p);\n  init_copy(mrb, clone, self);\n  p->flags = mrb_obj_ptr(self)->flags;\n  return clone;\n}", "target": 1}
{"code": "static inline __u32 secure_dccpv6_sequence_number(__be32 *saddr, __be32 *daddr,\n\t\t\t\t\t\t  __be16 sport, __be16 dport   )\n{\n\treturn secure_tcpv6_sequence_number(saddr, daddr, sport, dport);\n}", "target": 1}
{"code": "static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)\n{\n\trcu_read_lock();\n\t__ptrace_link(child, new_parent, __task_cred(new_parent));\n\trcu_read_unlock();\n}", "target": 1}
{"code": "static inline void skb_mac_header_rebuild(struct sk_buff *skb)\n{\n\tif (skb_mac_header_was_set(skb)) {\n\t\tconst unsigned char *old_mac = skb_mac_header(skb);\n\t\tskb_set_mac_header(skb, -skb->mac_len);\n\t\tmemmove(skb_mac_header(skb), old_mac, skb->mac_len);\n\t}\n}", "target": 0}
{"code": "static int netlbl_cipsov4_add_common(struct genl_info *info,\n\t\t\t\t     struct cipso_v4_doi *doi_def)\n{\n\tstruct nlattr *nla;\n\tint nla_rem;\n\tu32 iter = 0;\n\tdoi_def->doi = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_DOI]);\n\tif (nla_validate_nested(info->attrs[NLBL_CIPSOV4_A_TAGLST],\n\t\t\t\tNLBL_CIPSOV4_A_MAX,\n\t\t\t\tnetlbl_cipsov4_genl_policy) != 0)\n\t\treturn -EINVAL;\n\tnla_for_each_nested(nla, info->attrs[NLBL_CIPSOV4_A_TAGLST], nla_rem)\n\t\tif (nla->nla_type == NLBL_CIPSOV4_A_TAG) {\n\t\t\tif (iter > CIPSO_V4_TAG_MAXCNT)\n\t\t\t\treturn -EINVAL;\n\t\t\tdoi_def->tags[iter++] = nla_get_u8(nla);\n\t\t}\n\tif (iter < CIPSO_V4_TAG_MAXCNT)\n\t\tdoi_def->tags[iter] = CIPSO_V4_TAG_INVALID;\n\treturn 0;\n}", "target": 1}
{"code": "Mgr::IoActionData::operator += (const IoActionData& stats)\n{\n    http_reads += stats.http_reads;\n    for (int i = 0; i < IoStats::histSize; ++i)\n        http_read_hist[i] += stats.http_read_hist[i];\n    ftp_reads += stats.ftp_reads;\n    for (int i = 0; i < IoStats::histSize; ++i)\n        ftp_read_hist[i] += stats.ftp_read_hist[i];\n    gopher_reads += stats.gopher_reads;\n    for (int i = 0; i < IoStats::histSize; ++i)\n        gopher_read_hist[i] += stats.gopher_read_hist[i];\n    return *this;\n}", "target": 1}
{"code": "call_handler (SoupMessage *req, SoupClientContext *client)\n{\n\tSoupServer *server = client->server;\n\tSoupServerHandler *hand;\n\tSoupURI *uri;\n\tg_signal_emit (server, signals[REQUEST_READ], 0, req, client);\n\tif (req->status_code != 0)\n\t\treturn;\n\turi = soup_message_get_uri (req);\n\thand = soup_server_get_handler (server, uri->path);\n\tif (!hand) {\n\t\tsoup_message_set_status (req, SOUP_STATUS_NOT_FOUND);\n\t\treturn;\n\t}\n\tif (hand->callback) {\n\t\tGHashTable *form_data_set;\n\t\tif (uri->query)\n\t\t\tform_data_set = soup_form_decode (uri->query);\n\t\telse\n\t\t\tform_data_set = NULL;\n\t\t(*hand->callback) (server, req,\n\t\t\t\t   uri->path, form_data_set,\n\t\t\t\t   client, hand->user_data);\n\t\tif (form_data_set)\n\t\t\tg_hash_table_destroy (form_data_set);\n\t}\n}", "target": 0}
{"code": "do_encrypt (const RIJNDAEL_context *ctx,\n            unsigned char *bx, const unsigned char *ax)\n{\n#ifdef USE_AMD64_ASM\n  return _gcry_aes_amd64_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,\n\t\t\t\t       encT);\n#elif defined(USE_ARM_ASM)\n  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds, encT);\n#else\n  return do_encrypt_fn (ctx, bx, ax);\n#endif \n}", "target": 1}
{"code": "void nego_process_negotiation_response(rdpNego* nego, wStream* s)\n{\n\tUINT16 length;\n\tWLog_DBG(TAG, \"RDP_NEG_RSP\");\n\tif (Stream_GetRemainingLength(s) < 7)\n\t{\n\t\tWLog_ERR(TAG, \"Invalid RDP_NEG_RSP\");\n\t\tnego->state = NEGO_STATE_FAIL;\n\t\treturn;\n\t}\n\tStream_Read_UINT8(s, nego->flags);\n\tStream_Read_UINT16(s, length);\n\tStream_Read_UINT32(s, nego->SelectedProtocol);\n\tnego->state = NEGO_STATE_FINAL;\n}", "target": 1}
{"code": "static inline int copy_regset_to_user(struct task_struct *target,\n\t\t\t\t      const struct user_regset_view *view,\n\t\t\t\t      unsigned int setno,\n\t\t\t\t      unsigned int offset, unsigned int size,\n\t\t\t\t      void __user *data)\n{\n\tconst struct user_regset *regset = &view->regsets[setno];\n\tif (!regset->get)\n\t\treturn -EOPNOTSUPP;\n\tif (!access_ok(VERIFY_WRITE, data, size))\n\t\treturn -EIO;\n\treturn regset->get(target, regset, offset, size, NULL, data);\n}", "target": 0}
{"code": "static inline key_ref_t __key_update(key_ref_t key_ref,\n\t\t\t\t     struct key_preparsed_payload *prep)\n{\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\tgoto error;\n\tret = -EEXIST;\n\tif (!key->type->update)\n\t\tgoto error;\n\tdown_write(&key->sem);\n\tret = key->type->update(key, prep);\n\tif (ret == 0)\n\t\tclear_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\tup_write(&key->sem);\n\tif (ret < 0)\n\t\tgoto error;\nout:\n\treturn key_ref;\nerror:\n\tkey_put(key);\n\tkey_ref = ERR_PTR(ret);\n\tgoto out;\n}", "target": 1}
{"code": "void options_defaults() {\n    SERVICE_OPTIONS *service;\n    memset(&new_global_options, 0, sizeof(GLOBAL_OPTIONS));\n    memset(&new_service_options, 0, sizeof(SERVICE_OPTIONS));\n    new_service_options.next=NULL;\n    parse_global_option(CMD_SET_DEFAULTS, NULL, NULL);\n    service=&new_service_options;\n    parse_service_option(CMD_SET_DEFAULTS, &service, NULL, NULL);\n}", "target": 1}
{"code": "RequestHandler::RequestHandler(\n    std::shared_ptr<CheckWorkflow> check_workflow,\n    std::shared_ptr<context::ServiceContext> service_context,\n    std::unique_ptr<Request> request_data)\n    : context_(new context::RequestContext(service_context,\n                                           std::move(request_data))),\n      check_workflow_(check_workflow) {\n  std::string buffer;\n  if (context_->request()->FindHeader(\n          google::api_manager::auth::kEndpointApiUserInfo, &buffer)) {\n    context_->request()->AddHeaderToBackend(\n        google::api_manager::auth::kEndpointApiUserInfo, \"\");\n  }\n}", "target": 1}
{"code": "bool ParseAttrValueHelper_TensorNestsUnderLimit(int limit, string to_parse) {\n  int nests = 0;\n  int maxed_out = to_parse.length();\n  int open_curly = to_parse.find('{');\n  int open_bracket = to_parse.find('<');\n  int close_curly = to_parse.find('}');\n  int close_bracket = to_parse.find('>');\n  if (open_curly == -1) {\n    open_curly = maxed_out;\n  }\n  if (open_bracket == -1) {\n    open_bracket = maxed_out;\n  }\n  int min = std::min(open_curly, open_bracket);\n  do {\n    if (open_curly == maxed_out && open_bracket == maxed_out) {\n      return true;\n    }\n    if (min == open_curly) {\n      nests += 1;\n      open_curly = to_parse.find('{', open_curly + 1);\n      if (open_curly == -1) {\n        open_curly = maxed_out;\n      }\n    } else if (min == open_bracket) {\n      nests += 1;\n      open_bracket = to_parse.find('<', open_bracket + 1);\n      if (open_bracket == -1) {\n        open_bracket = maxed_out;\n      }\n    } else if (min == close_curly) {\n      nests -= 1;\n      close_curly = to_parse.find('}', close_curly + 1);\n      if (close_curly == -1) {\n        close_curly = maxed_out;\n      }\n    } else if (min == close_bracket) {\n      nests -= 1;\n      close_bracket = to_parse.find('>', close_bracket + 1);\n      if (close_bracket == -1) {\n        close_bracket = maxed_out;\n      }\n    }\n    min = std::min({open_curly, open_bracket, close_curly, close_bracket});\n  } while (nests < 100);\n  return false;\n}", "target": 0}
{"code": "fpDiff(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\tuint32 bps = tif->tif_dir.td_bitspersample / 8;\n\ttmsize_t wc = cc / bps;\n\ttmsize_t count;\n\tuint8 *cp = (uint8 *) cp0;\n\tuint8 *tmp;\n    if((cc%(bps*stride))!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"fpDiff\",\n                     \"%s\", \"(cc%(bps*stride))!=0\");\n        return 0;\n    }\n    tmp = (uint8 *)_TIFFmalloc(cc);\n\tif (!tmp)\n\t\treturn 0;\n\t_TIFFmemcpy(tmp, cp0, cc);\n\tfor (count = 0; count < wc; count++) {\n\t\tuint32 byte;\n\t\tfor (byte = 0; byte < bps; byte++) {\n\t\t\t#if WORDS_BIGENDIAN\n\t\t\tcp[byte * wc + count] = tmp[bps * count + byte];\n\t\t\t#else\n\t\t\tcp[(bps - byte - 1) * wc + count] =\n\t\t\t\ttmp[bps * count + byte];\n\t\t\t#endif\n\t\t}\n\t}\n\t_TIFFfree(tmp);\n\tcp = (uint8 *) cp0;\n\tcp += cc - stride - 1;\n\tfor (count = cc; count > stride; count -= stride)\n\t\tREPEAT4(stride, cp[stride] = (unsigned char)((cp[stride] - cp[0])&0xff); cp--)\n    return 1;\n}", "target": 0}
{"code": "bool SPIFFEValidator::matchSubjectAltName(X509& leaf_cert) {\n  bssl::UniquePtr<GENERAL_NAMES> san_names(static_cast<GENERAL_NAMES*>(\n      X509_get_ext_d2i(&leaf_cert, NID_subject_alt_name, nullptr, nullptr)));\n  ASSERT(san_names != nullptr,\n         \"san_names should have at least one name after SPIFFE cert validation\");\n  for (const GENERAL_NAME* general_name : san_names.get()) {\n    if (general_name->type == GEN_URI) {\n      const std::string san = Utility::generalNameAsString(general_name);\n      for (const auto& config_san_matcher : subject_alt_name_matchers_) {\n        if (config_san_matcher.match(san)) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}", "target": 1}
{"code": "int luaopen_x509(lua_State *L)\n{\n  auxiliar_newclass(L, \"openssl.x509\", x509_funcs);\n  lua_newtable(L);\n  luaL_setfuncs(L, R, 0);\n  openssl_register_xname(L);\n  lua_setfield(L, -2, \"name\");\n  openssl_register_xattribute(L);\n  lua_setfield(L, -2, \"attribute\");\n  openssl_register_xextension(L);\n  lua_setfield(L, -2, \"extension\");\n  openssl_register_xstore(L);\n  lua_setfield(L, -2, \"store\");\n  openssl_register_xalgor(L);\n  lua_setfield(L, -2, \"algor\");\n  luaopen_x509_req(L);\n  lua_setfield(L, -2, \"req\");\n  luaopen_x509_crl(L);\n  lua_setfield(L, -2, \"crl\");\n  lua_pushliteral(L, \"version\");    \n  lua_pushliteral(L, MYVERSION);\n  lua_settable(L, -3);\n#if OPENSSL_VERSION_NUMBER > 0x10002000L\n  lua_pushliteral(L, \"check_flag\");\n  lua_newtable(L);\n  auxiliar_enumerate(L, -1, check_flags_const);\n  lua_settable(L, -3);\n#endif\n  return 1;\n}", "target": 0}
{"code": "SWFInput_stream_read(SWFInput input, unsigned char* buffer, int count)\n{\n\tstruct SWFInputStreamData *data = (struct SWFInputStreamData *) input->data;\n\tint need = input->offset + count - input->length;\n\tif ( need > 0 )\n\t{\n\t\tint num;\n\t\tdata->buffer =\n\t\t\t(unsigned char*) realloc(data->buffer,\n\t\t\t\t\t\t\tsizeof(unsigned char) * INPUTSTREAM_INCREMENT *\n\t\t\t\t\t\t\t(((input->offset + count) / INPUTSTREAM_INCREMENT) + 1));\n\t\tnum = fread(data->buffer + input->length,\n\t\t\t\t\t\t\t\tsizeof(unsigned char), need, data->file);\n\t\tinput->length += num;\n\t}\n\tif ( count > input->length - input->offset )\n\t\tcount = input->length - input->offset;\n\tmemcpy(buffer, data->buffer + input->offset, count);\n\treturn count;\n}", "target": 0}
{"code": "int IniParser::write_file(const string & filename, IniSection & section)\n{\n    Pathname pn(filename);\n    PathInfo::assert_dir (pn.dirname ());\n    mode_t file_umask = section.isPrivate()? 0077: 0022;\n    mode_t orig_umask = umask(file_umask);\n    unlink(filename.c_str());\n    ofstream of(filename.c_str());\n    if (!of.good()) {\n        y2error (\"Can not open file %s for write\", filename.c_str());\n        return -1;\n    }\n    write_helper (section, of, 0);\n    of.close();\n    umask(orig_umask);\n    return 0;\n}", "target": 0}
{"code": "static void evtchn_fifo_handle_events(unsigned cpu)\n{\n\t__evtchn_fifo_handle_events(cpu, false);\n}", "target": 1}
{"code": "static void ssh2_send_newkeys(PTInstVar pvar)\n{\n\tbegin_send_packet(pvar, SSH2_MSG_NEWKEYS, 0);\n\tfinish_send_packet(pvar);\n\tlogprintf(LOG_LEVEL_VERBOSE, \"%s: SSH2_MSG_NEWKEYS was sent.\", __FUNCTION__);\n\tssh2_set_newkeys(pvar, MODE_OUT);\n\tif (!CRYPT_start_encryption(pvar, 1, 0)) {\n\t}\n\tpvar->ssh2_keys[MODE_OUT].mac.enabled = 1;\n\tpvar->ssh2_keys[MODE_OUT].comp.enabled = 1;\n\tenable_send_compression(pvar);\n\tpvar->kex_status |= KEX_FLAG_NEWKEYS_SENT;\n\tif (pvar->server_strict_kex) {\n\t\tpvar->ssh_state.sender_sequence_number = 0;\n\t}\n\tif (pvar->kex_status & KEX_FLAG_NEWKEYS_RECEIVED) {\n\t\tif ((pvar->kex_status & KEX_FLAG_REKEYING)) {\n\t\t\tdo_SSH2_dispatch_setup_for_transfer(pvar);\n\t\t}\n\t\telse {\n\t\t\tssh2_finish_encryption_setup(pvar);\n\t\t\tssh2_prep_userauth(pvar);\n\t\t}\n\t\tpvar->kex_status = KEX_FLAG_KEXDONE;\n\t}\n\treturn;\n}", "target": 0}
{"code": "static void xen_free_irq(unsigned irq)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\tunsigned long flags;\n\tif (WARN_ON(!info))\n\t\treturn;\n\twrite_lock_irqsave(&evtchn_rwlock, flags);\n\tlist_del(&info->list);\n\tset_info_for_irq(irq, NULL);\n\tWARN_ON(info->refcnt > 0);\n\twrite_unlock_irqrestore(&evtchn_rwlock, flags);\n\tkfree(info);\n\tif (irq < nr_legacy_irqs())\n\t\treturn;\n\tirq_free_desc(irq);\n}", "target": 0}
{"code": "gss_unwrap_aead (minor_status,\n                 context_handle,\n\t\t input_message_buffer,\n\t\t input_assoc_buffer,\n\t\t output_payload_buffer,\n                 conf_state,\n                 qop_state)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_buffer_t\t\tinput_message_buffer;\ngss_buffer_t\t\tinput_assoc_buffer;\ngss_buffer_t\t\toutput_payload_buffer;\nint \t\t\t*conf_state;\ngss_qop_t\t\t*qop_state;\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    status = val_unwrap_aead_args(minor_status, context_handle,\n\t\t\t\t  input_message_buffer, input_assoc_buffer,\n\t\t\t\t  output_payload_buffer,\n\t\t\t\t  conf_state, qop_state);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (!mech)\n\treturn (GSS_S_BAD_MECH);\n    return gssint_unwrap_aead(mech, minor_status, ctx,\n\t\t\t      input_message_buffer, input_assoc_buffer,\n\t\t\t      output_payload_buffer, conf_state, qop_state);\n}", "target": 0}
{"code": "static void vm_unlock_anon_vma(struct anon_vma *anon_vma)\n{\n\tif (test_bit(0, (unsigned long *) &anon_vma->root->rb_root.rb_node)) {\n\t\tif (!__test_and_clear_bit(0, (unsigned long *)\n\t\t\t\t\t  &anon_vma->root->rb_root.rb_node))\n\t\t\tBUG();\n\t\tanon_vma_unlock_write(anon_vma);\n\t}\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& shape_t = ctx->input(0);\n    const Tensor& rate_t = ctx->input(1);\n    TensorShape samples_shape;\n    OP_REQUIRES_OK(ctx, tensor::MakeShape(shape_t, &samples_shape));\n    const int64_t num_samples = samples_shape.num_elements();\n    samples_shape.AppendShape(rate_t.shape());\n    Tensor* samples_t = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, samples_shape, &samples_t));\n    if (num_samples == 0) return;\n    const auto rate_flat = rate_t.flat<T>().data();\n    const int64_t num_rate = rate_t.NumElements();\n    auto samples_flat = samples_t->flat<U>().data();\n    random::PhiloxRandom rng = generator_.ReserveRandomOutputs(\n        num_samples * num_rate, kReservedSamplesPerOutput);\n    functor::PoissonFunctor<CPUDevice, T, U>()(\n        ctx, ctx->eigen_device<CPUDevice>(), rate_flat, num_rate, num_samples,\n        rng, samples_flat);\n  }", "target": 1}
{"code": "struct mapped_device *dm_get_from_kobject(struct kobject *kobj)\n{\n\tstruct mapped_device *md;\n\tmd = container_of(kobj, struct mapped_device, kobj_holder.kobj);\n\tif (test_bit(DMF_FREEING, &md->flags) ||\n\t    dm_deleting_md(md))\n\t\treturn NULL;\n\tdm_get(md);\n\treturn md;\n}", "target": 1}
{"code": "_defbackend_gen_returntext(char *buffer, size_t buflen, char **dns)\n{\n    int dnidx;\n    int sidx;\n    struct suffix_repeat {\n        char *suffix;\n        int size;\n    } candidates[] = {\n        {\"dc=\", 3}, \n        {NULL, 0}\n    };\n    PR_snprintf(buffer, buflen, \"%s (\", DEFBE_NO_SUCH_SUFFIX);\n    for (dnidx = 0; dns[dnidx]; dnidx++) ; \n    dnidx--; \n    for (sidx = 0; candidates[sidx].suffix; sidx++) {\n        if (!PL_strncasecmp(dns[dnidx], candidates[sidx].suffix, candidates[sidx].size)) {\n            while (!PL_strncasecmp(dns[--dnidx], candidates[sidx].suffix, candidates[sidx].size)) ;\n            PL_strcat(buffer, dns[++dnidx]); \n            for (++dnidx; dns[dnidx]; dnidx++) {\n                PL_strcat(buffer, \",\");\n                PL_strcat(buffer, dns[dnidx]);\n            }\n            PL_strcat(buffer, \")\");\n            return; \n        }\n    }\n    PL_strcat(buffer, dns[dnidx]);\n    PL_strcat(buffer, \")\");\n    return;\n}", "target": 0}
{"code": "static inline struct sem_array *sem_obtain_lock(struct ipc_namespace *ns, int id)\n{\n\tstruct kern_ipc_perm *ipcp;\n\tstruct sem_array *sma;\n\trcu_read_lock();\n\tipcp = ipc_obtain_object(&sem_ids(ns), id);\n\tif (IS_ERR(ipcp)) {\n\t\tsma = ERR_CAST(ipcp);\n\t\tgoto err;\n\t}\n\tspin_lock(&ipcp->lock);\n\tif (!ipcp->deleted)\n\t\treturn container_of(ipcp, struct sem_array, sem_perm);\n\tspin_unlock(&ipcp->lock);\n\tsma = ERR_PTR(-EINVAL);\nerr:\n\trcu_read_unlock();\n\treturn sma;\n}", "target": 1}
{"code": "static int do_replace(struct net *net, const void __user *user,\n\t\t      unsigned int len)\n{\n\tint ret, countersize;\n\tstruct ebt_table_info *newinfo;\n\tstruct ebt_replace tmp;\n\tif (copy_from_user(&tmp, user, sizeof(tmp)) != 0)\n\t\treturn -EFAULT;\n\tif (len != sizeof(tmp) + tmp.entries_size) {\n\t\tBUGPRINT(\"Wrong len argument\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (tmp.entries_size == 0) {\n\t\tBUGPRINT(\"Entries_size never zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (tmp.nentries >= ((INT_MAX - sizeof(struct ebt_table_info)) /\n\t\t\tNR_CPUS - SMP_CACHE_BYTES) / sizeof(struct ebt_counter))\n\t\treturn -ENOMEM;\n\tif (tmp.num_counters >= INT_MAX / sizeof(struct ebt_counter))\n\t\treturn -ENOMEM;\n\ttmp.name[sizeof(tmp.name) - 1] = 0;\n\tcountersize = COUNTER_OFFSET(tmp.nentries) * nr_cpu_ids;\n\tnewinfo = vmalloc(sizeof(*newinfo) + countersize);\n\tif (!newinfo)\n\t\treturn -ENOMEM;\n\tif (countersize)\n\t\tmemset(newinfo->counters, 0, countersize);\n\tnewinfo->entries = vmalloc(tmp.entries_size);\n\tif (!newinfo->entries) {\n\t\tret = -ENOMEM;\n\t\tgoto free_newinfo;\n\t}\n\tif (copy_from_user(\n\t   newinfo->entries, tmp.entries, tmp.entries_size) != 0) {\n\t\tBUGPRINT(\"Couldn't copy entries from userspace\\n\");\n\t\tret = -EFAULT;\n\t\tgoto free_entries;\n\t}\n\tret = do_replace_finish(net, &tmp, newinfo);\n\tif (ret == 0)\n\t\treturn ret;\nfree_entries:\n\tvfree(newinfo->entries);\nfree_newinfo:\n\tvfree(newinfo);\n\treturn ret;\n}", "target": 0}
{"code": "  const std::string& get_id() const {\n    ceph_assert(t != Wildcard && t != Tenant);\n    return u.id;\n  }", "target": 1}
{"code": "static int snd_compress_check_input(struct snd_compr_params *params)\n{\n\tif (params->buffer.fragment_size == 0 ||\n\t\t\tparams->buffer.fragments > SIZE_MAX / params->buffer.fragment_size)\n\t\treturn -EINVAL;\n\tif (params->codec.id == 0 || params->codec.id > SND_AUDIOCODEC_MAX)\n\t\treturn -EINVAL;\n\tif (params->codec.ch_in == 0 || params->codec.ch_out == 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "static HashTable* spl_array_get_debug_info(zval *obj, int *is_temp TSRMLS_DC) \n{\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(obj TSRMLS_CC);\n\tzval *tmp, *storage;\n\tint name_len;\n\tchar *zname;\n\tzend_class_entry *base;\n\t*is_temp = 0;\n\tif (!intern->std.properties) {\n\t\trebuild_object_properties(&intern->std);\n\t}\n\tif (HASH_OF(intern->array) == intern->std.properties) {\n\t\treturn intern->std.properties;\n\t} else {\n\t\tif (intern->debug_info == NULL) {\n\t\t\tALLOC_HASHTABLE(intern->debug_info);\n\t\t\tZEND_INIT_SYMTABLE_EX(intern->debug_info, zend_hash_num_elements(intern->std.properties) + 1, 0);\n\t\t}\n\t\tif (intern->debug_info->nApplyCount == 0) {\n\t\t\tzend_hash_clean(intern->debug_info);\n\t\t\tzend_hash_copy(intern->debug_info, intern->std.properties, (copy_ctor_func_t) zval_add_ref, (void *) &tmp, sizeof(zval *));\n\t\t\tstorage = intern->array;\n\t\t\tzval_add_ref(&storage);\n\t\t\tbase = (Z_OBJ_HT_P(obj) == &spl_handler_ArrayIterator) ? spl_ce_ArrayIterator : spl_ce_ArrayObject;\n\t\t\tzname = spl_gen_private_prop_name(base, \"storage\", sizeof(\"storage\")-1, &name_len TSRMLS_CC);\n\t\t\tzend_symtable_update(intern->debug_info, zname, name_len+1, &storage, sizeof(zval *), NULL);\n\t\t\tefree(zname);\n\t\t}\n\t\treturn intern->debug_info;\n\t}\n}", "target": 0}
{"code": "static inline struct nlattr *nla_next(const struct nlattr *nla, int *remaining)\n{\n\tint totlen = NLA_ALIGN(nla->nla_len);\n\t*remaining -= totlen;\n\treturn (struct nlattr *) ((char *) nla + totlen);\n}", "target": 0}
{"code": "static void nfs_set_open_stateid(struct nfs4_state *state, nfs4_stateid *stateid, int open_flags)\n{\n\twrite_seqlock(&state->seqlock);\n\tnfs_set_open_stateid_locked(state, stateid, open_flags);\n\twrite_sequnlock(&state->seqlock);\n}", "target": 1}
{"code": "static void __exit pf_exit(void)\n{\n\tstruct pf_unit *pf;\n\tint unit;\n\tunregister_blkdev(major, name);\n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tif (!pf->disk)\n\t\t\tcontinue;\n\t\tif (pf->present)\n\t\t\tdel_gendisk(pf->disk);\n\t\tblk_cleanup_queue(pf->disk->queue);\n\t\tblk_mq_free_tag_set(&pf->tag_set);\n\t\tput_disk(pf->disk);\n\t\tif (pf->present)\n\t\t\tpi_release(pf->pi);\n\t}\n}", "target": 0}
{"code": "static int l2cap_sock_connect(struct socket *sock, struct sockaddr *addr, int alen, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_l2 la;\n\tint len, err = 0;\n\tBT_DBG(\"sk %p\", sk);\n\tif (!addr || addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\tmemset(&la, 0, sizeof(la));\n\tlen = min_t(unsigned int, sizeof(la), alen);\n\tmemcpy(&la, addr, len);\n\tif (la.l2_cid)\n\t\treturn -EINVAL;\n\tlock_sock(sk);\n\tif (sk->sk_type == SOCK_SEQPACKET && !la.l2_psm) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\tswitch (l2cap_pi(sk)->mode) {\n\tcase L2CAP_MODE_BASIC:\n\t\tbreak;\n\tcase L2CAP_MODE_ERTM:\n\tcase L2CAP_MODE_STREAMING:\n\t\tif (enable_ertm)\n\t\t\tbreak;\n\tdefault:\n\t\terr = -ENOTSUPP;\n\t\tgoto done;\n\t}\n\tswitch (sk->sk_state) {\n\tcase BT_CONNECT:\n\tcase BT_CONNECT2:\n\tcase BT_CONFIG:\n\t\tgoto wait;\n\tcase BT_CONNECTED:\n\t\tgoto done;\n\tcase BT_OPEN:\n\tcase BT_BOUND:\n\t\tbreak;\n\tdefault:\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\tbacpy(&bt_sk(sk)->dst, &la.l2_bdaddr);\n\tl2cap_pi(sk)->psm = la.l2_psm;\n\terr = l2cap_do_connect(sk);\n\tif (err)\n\t\tgoto done;\nwait:\n\terr = bt_sock_wait_state(sk, BT_CONNECTED,\n\t\t\tsock_sndtimeo(sk, flags & O_NONBLOCK));\ndone:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "void mm_release(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tstruct completion *vfork_done = tsk->vfork_done;\n#ifdef CONFIG_FUTEX\n\tif (unlikely(tsk->robust_list))\n\t\texit_robust_list(tsk);\n#ifdef CONFIG_COMPAT\n\tif (unlikely(tsk->compat_robust_list))\n\t\tcompat_exit_robust_list(tsk);\n#endif\n#endif\n\tdeactivate_mm(tsk, mm);\n\tif (vfork_done) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork_done);\n\t}\n\tif (tsk->clear_child_tid\n\t    && !(tsk->flags & PF_SIGNALED)\n\t    && atomic_read(&mm->mm_users) > 1) {\n\t\tu32 __user * tidptr = tsk->clear_child_tid;\n\t\ttsk->clear_child_tid = NULL;\n\t\tput_user(0, tidptr);\n\t\tsys_futex(tidptr, FUTEX_WAKE, 1, NULL, NULL, 0);\n\t}\n}", "target": 0}
{"code": "l2tp_proxy_auth_id_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tND_PRINT((ndo, \"%u\", EXTRACT_16BITS(ptr) & L2TP_PROXY_AUTH_ID_MASK));\n}", "target": 1}
{"code": "  TfLiteRegistration CancelOpRegistration() {\n    TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n    reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n      const TfLiteTensor* in_tensor = GetInput(context, node, 0);\n      TfLiteTensor* out_tensor = GetOutput(context, node, 0);\n      TfLiteIntArray* new_size = TfLiteIntArrayCopy(in_tensor->dims);\n      return context->ResizeTensor(context, out_tensor, new_size);\n    };\n    reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n      cancellation_data_.is_cancelled = true;\n      return kTfLiteOk;\n    };\n    return reg;\n  }", "target": 1}
{"code": "static void __exit inet6_exit(void)\n{\n\tsock_unregister(PF_INET6);\n\trtnl_unregister_all(PF_INET6);\n#ifdef CONFIG_SYSCTL\n\tipv6_sysctl_unregister();\n#endif\n\tudpv6_exit();\n\tudplitev6_exit();\n\ttcpv6_exit();\n\tipv6_packet_cleanup();\n\tipv6_frag_exit();\n\tipv6_exthdrs_exit();\n\taddrconf_cleanup();\n\tip6_flowlabel_cleanup();\n\tip6_route_cleanup();\n#ifdef CONFIG_PROC_FS\n\tif6_proc_exit();\n\tipv6_misc_proc_exit();\n\tudplite6_proc_exit();\n\traw6_proc_exit();\n#endif\n\tipv6_netfilter_fini();\n\tigmp6_cleanup();\n\tndisc_cleanup();\n\ticmpv6_cleanup();\n\trawv6_exit();\n\tunregister_pernet_subsys(&inet6_net_ops);\n\tcleanup_ipv6_mibs();\n\tproto_unregister(&rawv6_prot);\n\tproto_unregister(&udplitev6_prot);\n\tproto_unregister(&udpv6_prot);\n\tproto_unregister(&tcpv6_prot);\n}", "target": 0}
{"code": "void Context::onDownstreamConnectionClose(PeerType peer_type) {\n  if (wasm_->onDownstreamConnectionClose_) {\n    wasm_->onDownstreamConnectionClose_(this, id_, static_cast<uint32_t>(peer_type));\n  }\n}", "target": 1}
{"code": "struct ucounts *alloc_ucounts(struct user_namespace *ns, kuid_t uid)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ns, uid);\n\tstruct ucounts *ucounts, *new;\n\tbool wrapped;\n\tspin_lock_irq(&ucounts_lock);\n\tucounts = find_ucounts(ns, uid, hashent);\n\tif (!ucounts) {\n\t\tspin_unlock_irq(&ucounts_lock);\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn NULL;\n\t\tnew->ns = ns;\n\t\tnew->uid = uid;\n\t\tatomic_set(&new->count, 1);\n\t\tspin_lock_irq(&ucounts_lock);\n\t\tucounts = find_ucounts(ns, uid, hashent);\n\t\tif (ucounts) {\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\thlist_add_head(&new->node, hashent);\n\t\t\tget_user_ns(new->ns);\n\t\t\tspin_unlock_irq(&ucounts_lock);\n\t\t\treturn new;\n\t\t}\n\t}\n\twrapped = !get_ucounts_or_wrap(ucounts);\n\tspin_unlock_irq(&ucounts_lock);\n\tif (wrapped) {\n\t\tput_ucounts(ucounts);\n\t\treturn NULL;\n\t}\n\treturn ucounts;\n}", "target": 0}
{"code": "void set_pmd_migration_entry(struct page_vma_mapped_walk *pvmw,\n\t\tstruct page *page)\n{\n\tstruct vm_area_struct *vma = pvmw->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long address = pvmw->address;\n\tpmd_t pmdval;\n\tswp_entry_t entry;\n\tpmd_t pmdswp;\n\tif (!(pvmw->pmd && !pvmw->pte))\n\t\treturn;\n\tmmu_notifier_invalidate_range_start(mm, address,\n\t\t\taddress + HPAGE_PMD_SIZE);\n\tflush_cache_range(vma, address, address + HPAGE_PMD_SIZE);\n\tpmdval = *pvmw->pmd;\n\tpmdp_invalidate(vma, address, pvmw->pmd);\n\tif (pmd_dirty(pmdval))\n\t\tset_page_dirty(page);\n\tentry = make_migration_entry(page, pmd_write(pmdval));\n\tpmdswp = swp_entry_to_pmd(entry);\n\tif (pmd_soft_dirty(pmdval))\n\t\tpmdswp = pmd_swp_mksoft_dirty(pmdswp);\n\tset_pmd_at(mm, address, pvmw->pmd, pmdswp);\n\tpage_remove_rmap(page, true);\n\tput_page(page);\n\tmmu_notifier_invalidate_range_end(mm, address,\n\t\t\taddress + HPAGE_PMD_SIZE);\n}", "target": 0}
{"code": "setup_efi_state(struct boot_params *params, unsigned long params_load_addr,\n\t\tunsigned int efi_map_offset, unsigned int efi_map_sz,\n\t\tunsigned int efi_setup_data_offset)\n{\n\tstruct efi_info *current_ei = &boot_params.efi_info;\n\tstruct efi_info *ei = &params->efi_info;\n\tif (!current_ei->efi_memmap_size)\n\t\treturn 0;\n\tif (efi_enabled(EFI_OLD_MEMMAP))\n\t\treturn 0;\n\tparams->secure_boot = boot_params.secure_boot;\n\tei->efi_loader_signature = current_ei->efi_loader_signature;\n\tei->efi_systab = current_ei->efi_systab;\n\tei->efi_systab_hi = current_ei->efi_systab_hi;\n\tei->efi_memdesc_version = current_ei->efi_memdesc_version;\n\tei->efi_memdesc_size = efi_get_runtime_map_desc_size();\n\tsetup_efi_info_memmap(params, params_load_addr, efi_map_offset,\n\t\t\t      efi_map_sz);\n\tprepare_add_efi_setup_data(params, params_load_addr,\n\t\t\t\t   efi_setup_data_offset);\n\treturn 0;\n}", "target": 0}
{"code": "  pin(std::string pin, std::string name) {\n    pt::ptree tree;\n    if (map_id_sess.empty()) {\n      return false;\n    }\n    if (pin.size() != 4) {\n      tree.put(\"root.paired\", 0);\n      tree.put(\"root.<xmlattr>.status_code\", 400);\n      tree.put(\n        \"root.<xmlattr>.status_message\", \"Pin must be 4 digits, \" + std::to_string(pin.size()) + \" provided\");\n      return false;\n    }\n    if (!std::all_of(pin.begin(), pin.end(), ::isdigit)) {\n      tree.put(\"root.paired\", 0);\n      tree.put(\"root.<xmlattr>.status_code\", 400);\n      tree.put(\"root.<xmlattr>.status_message\", \"Pin must be numeric\");\n      return false;\n    }\n    auto &sess = std::begin(map_id_sess)->second;\n    getservercert(sess, tree, pin);\n    sess.client.name = name;\n    std::ostringstream data;\n    pt::write_xml(data, tree);\n    auto &async_response = sess.async_insert_pin.response;\n    if (async_response.has_left() && async_response.left()) {\n      async_response.left()->write(data.str());\n    }\n    else if (async_response.has_right() && async_response.right()) {\n      async_response.right()->write(data.str());\n    }\n    else {\n      return false;\n    }\n    async_response = std::decay_t<decltype(async_response.left())>();\n    return true;\n  }", "target": 0}
{"code": "tsetcap(int cap, int flags)\n{\n    if (tccan(cap) && !isset(SINGLELINEZLE) &&\n        !(termflags & (TERM_NOUP|TERM_BAD|TERM_UNKNOWN))) {\n\tswitch (flags & TSC_OUTPUT_MASK) {\n\tcase TSC_RAW:\n\t    tputs(tcstr[cap], 1, putraw);\n\t    break;\n\tcase 0:\n\tdefault:\n\t    tputs(tcstr[cap], 1, putshout);\n\t    break;\n\tcase TSC_PROMPT:\n\t    if (!bv->dontcount) {\n\t\taddbufspc(1);\n\t\t*bv->bp++ = Inpar;\n\t    }\n\t    tputs(tcstr[cap], 1, putstr);\n\t    if (!bv->dontcount) {\n\t\tint glitch = 0;\n\t\tif (cap == TCSTANDOUTBEG || cap == TCSTANDOUTEND)\n\t\t    glitch = tgetnum(\"sg\");\n\t\telse if (cap == TCUNDERLINEBEG || cap == TCUNDERLINEEND)\n\t\t    glitch = tgetnum(\"ug\");\n\t\tif(glitch < 0)\n\t\t    glitch = 0;\n\t\taddbufspc(glitch + 1);\n\t\twhile(glitch--)\n\t\t    *bv->bp++ = Nularg;\n\t\t*bv->bp++ = Outpar;\n\t    }\n\t    break;\n\t}\n\tif (flags & TSC_DIRTY) {\n\t    flags &= ~TSC_DIRTY;\n\t    if (txtisset(TXTBOLDFACE) && cap != TCBOLDFACEBEG)\n\t\ttsetcap(TCBOLDFACEBEG, flags);\n\t    if (txtisset(TXTSTANDOUT))\n\t\ttsetcap(TCSTANDOUTBEG, flags);\n\t    if (txtisset(TXTUNDERLINE))\n\t\ttsetcap(TCUNDERLINEBEG, flags);\n\t    if (txtisset(TXTFGCOLOUR))\n\t\tset_colour_attribute(txtattrmask, COL_SEQ_FG, TSC_PROMPT);\n\t    if (txtisset(TXTBGCOLOUR))\n\t\tset_colour_attribute(txtattrmask, COL_SEQ_BG, TSC_PROMPT);\n\t}\n    }\n}", "target": 0}
{"code": "static MagickBooleanType load_tile(Image *image,Image *tile_image,\n  XCFDocInfo *inDocInfo,XCFLayerInfo *inLayerInfo,size_t data_length,\n  ExceptionInfo *exception)\n{\n  ssize_t\n    y;\n  register ssize_t\n    x;\n  register Quantum\n    *q;\n  ssize_t\n    count;\n  unsigned char\n    *graydata;\n  XCFPixelInfo\n    *xcfdata,\n    *xcfodata;\n  xcfdata=(XCFPixelInfo *) AcquireQuantumMemory(data_length,sizeof(*xcfdata));\n  if (xcfdata == (XCFPixelInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  xcfodata=xcfdata;\n  graydata=(unsigned char *) xcfdata;  \n  count=ReadBlob(image,data_length,(unsigned char *) xcfdata);\n  if (count != (ssize_t) data_length)\n    ThrowBinaryException(CorruptImageError,\"NotEnoughPixelData\",\n      image->filename);\n  for (y=0; y < (ssize_t) tile_image->rows; y++)\n  {\n    q=GetAuthenticPixels(tile_image,0,y,tile_image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    if (inDocInfo->image_type == GIMP_GRAY)\n      {\n        for (x=0; x < (ssize_t) tile_image->columns; x++)\n        {\n          SetPixelGray(tile_image,ScaleCharToQuantum(*graydata),q);\n          SetPixelAlpha(tile_image,ScaleCharToQuantum((unsigned char)\n            inLayerInfo->alpha),q);\n          graydata++;\n          q+=GetPixelChannels(tile_image);\n        }\n      }\n    else\n      if (inDocInfo->image_type == GIMP_RGB)\n        {\n          for (x=0; x < (ssize_t) tile_image->columns; x++)\n          {\n            SetPixelRed(tile_image,ScaleCharToQuantum(xcfdata->red),q);\n            SetPixelGreen(tile_image,ScaleCharToQuantum(xcfdata->green),q);\n            SetPixelBlue(tile_image,ScaleCharToQuantum(xcfdata->blue),q);\n            SetPixelAlpha(tile_image,xcfdata->alpha == 255U ? TransparentAlpha :\n              ScaleCharToQuantum((unsigned char) inLayerInfo->alpha),q);\n            xcfdata++;\n            q+=GetPixelChannels(tile_image);\n          }\n        }\n     if (SyncAuthenticPixels(tile_image,exception) == MagickFalse)\n       break;\n  }\n  xcfodata=(XCFPixelInfo *) RelinquishMagickMemory(xcfodata);\n  return MagickTrue;\n}", "target": 1}
{"code": "static uint8_t excluded_channels(bitfile *ld, drc_info *drc)\n{\n    uint8_t i, n = 0;\n    uint8_t num_excl_chan = 7;\n    for (i = 0; i < 7; i++)\n    {\n        drc->exclude_mask[i] = faad_get1bit(ld\n            DEBUGVAR(1,103,\"excluded_channels(): exclude_mask\"));\n    }\n    n++;\n    while ((drc->additional_excluded_chns[n-1] = faad_get1bit(ld\n        DEBUGVAR(1,104,\"excluded_channels(): additional_excluded_chns\"))) == 1)\n    {\n        if (i >= MAX_CHANNELS - num_excl_chan - 7)\n            return n;\n        for (i = num_excl_chan; i < num_excl_chan+7; i++)\n        {\n            drc->exclude_mask[i] = faad_get1bit(ld\n                DEBUGVAR(1,105,\"excluded_channels(): exclude_mask\"));\n        }\n        n++;\n        num_excl_chan += 7;\n    }\n    return n;\n}", "target": 0}
{"code": "    const std::unordered_map<std::string, Cookie> &cookies() const override\n    {\n        return cookies_;\n    }", "target": 1}
{"code": "static int bn2cf(const BIGNUM *num, u8 *buf)\n{\n\tu8 tmp[512];\n\tint r;\n\tr = BN_bn2bin(num, tmp);\n\tif (r <= 0)\n\t\treturn r;\n\tinvert_buf(buf, tmp, r);\n\treturn r;\n}", "target": 0}
{"code": "static int perf_release(struct inode *inode, struct file *file)\n{\n\tput_event(file->private_data);\n\treturn 0;\n}", "target": 0}
{"code": "int sortROGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {\n    keyReference *keys;\n    UNUSED(cmd);\n    UNUSED(argv);\n    UNUSED(argc);\n    keys = getKeysPrepareResult(result, 1);\n    keys[0].pos = 1; \n    keys[0].flags = CMD_KEY_RO | CMD_KEY_ACCESS;\n    return 1;\n}", "target": 1}
{"code": "int fp_invmod_mont_ct(fp_int *a, fp_int *b, fp_int *c, fp_digit mp)\n{\n  int i, j;\n#ifndef WOLFSSL_SMALL_STACK\n  fp_int t[1], e[1];\n  fp_int pre[CT_INV_MOD_PRE_CNT];\n#else\n  fp_int* t;\n  fp_int* e;\n  fp_int* pre;\n#endif\n#ifdef WOLFSSL_SMALL_STACK\n  t = (fp_int*)XMALLOC(sizeof(fp_int) * (2 + CT_INV_MOD_PRE_CNT), NULL,\n                                                           DYNAMIC_TYPE_BIGINT);\n  if (t == NULL)\n    return FP_MEM;\n  e = t + 1;\n  pre = t + 2;\n#endif\n  fp_init(t);\n  fp_init(e);\n  fp_init(&pre[0]);\n  fp_copy(a, &pre[0]);\n  for (i = 1; i < CT_INV_MOD_PRE_CNT; i++) {\n    fp_init(&pre[i]);\n    fp_sqr(&pre[i-1], &pre[i]);\n    fp_montgomery_reduce(&pre[i], b, mp);\n    fp_mul(&pre[i], a, &pre[i]);\n    fp_montgomery_reduce(&pre[i], b, mp);\n  }\n  fp_sub_d(b, 2, e);\n  for (i = fp_count_bits(e)-2, j = 1; i >= 0; i--, j++) {\n      if (!fp_is_bit_set(e, i) || j == CT_INV_MOD_PRE_CNT)\n          break;\n  }\n  fp_copy(&pre[j-1], t);\n  for (j = 0; i >= 0; i--) {\n    int set = fp_is_bit_set(e, i);\n    if ((j == CT_INV_MOD_PRE_CNT) || (!set && j > 0)) {\n      fp_mul(t, &pre[j-1], t);\n      fp_montgomery_reduce(t, b, mp);\n      j = 0;\n    }\n    fp_sqr(t, t);\n    fp_montgomery_reduce(t, b, mp);\n    j += set;\n  }\n  if (j > 0) {\n    fp_mul(t, &pre[j-1], c);\n    fp_montgomery_reduce(c, b, mp);\n  }\n  else \n    fp_copy(t, c);\n#ifdef WOLFSSL_SMALL_STACK\n  XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);\n#endif\n  return FP_OKAY;\n}", "target": 0}
{"code": "static int pit_ioport_read(struct kvm_io_device *this,\n\t\t\t   gpa_t addr, int len, void *data)\n{\n\tstruct kvm_pit *pit = dev_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\tint ret, count;\n\tstruct kvm_kpit_channel_state *s;\n\tif (!pit_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\taddr &= KVM_PIT_CHANNEL_MASK;\n\tif (addr == 3)\n\t\treturn 0;\n\ts = &pit_state->channels[addr];\n\tmutex_lock(&pit_state->lock);\n\tif (s->status_latched) {\n\t\ts->status_latched = 0;\n\t\tret = s->status;\n\t} else if (s->count_latched) {\n\t\tswitch (s->count_latched) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tret = s->latched_count & 0xff;\n\t\t\ts->count_latched = 0;\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tret = s->latched_count >> 8;\n\t\t\ts->count_latched = 0;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\tret = s->latched_count & 0xff;\n\t\t\ts->count_latched = RW_STATE_MSB;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (s->read_state) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = count & 0xff;\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = (count >> 8) & 0xff;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = count & 0xff;\n\t\t\ts->read_state = RW_STATE_WORD1;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD1:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = (count >> 8) & 0xff;\n\t\t\ts->read_state = RW_STATE_WORD0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (len > sizeof(ret))\n\t\tlen = sizeof(ret);\n\tmemcpy(data, (char *)&ret, len);\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}", "target": 0}
{"code": "  explicit DataFormatDimMapOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    string src_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"src_format\", &src_format));\n    string dst_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"dst_format\", &dst_format));\n    OP_REQUIRES(context, src_format.size() == 4 || src_format.size() == 5,\n                errors::InvalidArgument(strings::StrCat(\n                    \"Source format must of length 4 or 5, received \"\n                    \"src_format = \",\n                    src_format)));\n    OP_REQUIRES(\n        context, dst_format.size() == 4 || dst_format.size() == 5,\n        errors::InvalidArgument(strings::StrCat(\n            \"Destination format must of length 4 or 5, received dst_format = \",\n            dst_format)));\n    dst_idx_ = Tensor(DT_INT32, {static_cast<int64>(src_format.size())});\n    for (int i = 0; i < src_format.size(); ++i) {\n      for (int j = 0; j < dst_format.size(); ++j) {\n        if (dst_format[j] == src_format[i]) {\n          dst_idx_.vec<int>()(i) = j;\n          break;\n        }\n      }\n    }\n  }", "target": 1}
{"code": "Node* Graph::AddNode(NodeDef node_def, Status* status) {\n  const OpRegistrationData* op_reg_data;\n  status->Update(ops_.LookUp(node_def.op(), &op_reg_data));\n  if (!status->ok()) return nullptr;\n  DataTypeVector inputs;\n  DataTypeVector outputs;\n  status->Update(\n      InOutTypesForNode(node_def, op_reg_data->op_def, &inputs, &outputs));\n  if (!status->ok()) {\n    *status = AttachDef(*status, node_def);\n    return nullptr;\n  }\n  Node::NodeClass node_class = op_reg_data->is_function_op\n                                   ? Node::NC_FUNCTION_OP\n                                   : Node::GetNodeClassForOp(node_def.op());\n  if (op_reg_data->type_ctor != nullptr) {\n    VLOG(3) << \"AddNode: found type constructor for \" << node_def.name();\n    const auto ctor_type =\n        full_type::SpecializeType(AttrSlice(node_def), op_reg_data->op_def);\n    if (!ctor_type.ok()) {\n      *status = errors::InvalidArgument(\"type error: \",\n                                        ctor_type.status().ToString());\n      return nullptr;\n    }\n    const FullTypeDef ctor_typedef = ctor_type.ValueOrDie();\n    if (ctor_typedef.type_id() != TFT_UNSET) {\n      *(node_def.mutable_experimental_type()) = ctor_typedef;\n    }\n  } else {\n    VLOG(3) << \"AddNode: no type constructor for \" << node_def.name();\n  }\n  Node* node = AllocateNode(std::make_shared<NodeProperties>(\n                                &op_reg_data->op_def, std::move(node_def),\n                                inputs, outputs, op_reg_data->fwd_type_fn),\n                            nullptr, node_class);\n  return node;\n}", "target": 0}
{"code": "Status TensorSlice::BuildTensorSlice(const TensorSliceProto& proto,\n                                     TensorSlice* output) {\n  output->Clear();\n  output->starts_.reserve(proto.extent_size());\n  output->lengths_.reserve(proto.extent_size());\n  for (const auto& e : proto.extent()) {\n    int64_t l = GetExtentLength(e);\n    if (e.start() != 0 || l != kFullExtent) {\n      if (e.start() < 0 || l <= 0) {\n        return errors::InvalidArgument(\n            \"Expected non-negative start and positive length but got start = \",\n            e.start(), \", length = \", l, \": extent = \", e.ShortDebugString());\n      }\n      if (static_cast<uint64_t>(e.start()) + static_cast<uint64_t>(e.length()) >\n          std::numeric_limits<int64_t>::max()) {\n        return errors::InvalidArgument(\n            \"Extent end exceeds the maximum possible size: extent = \",\n            e.ShortDebugString());\n      }\n    }\n    output->starts_.push_back(e.start());\n    output->lengths_.push_back(l);\n  }\n  return Status::OK();\n}", "target": 0}
{"code": "queue_unlock(struct futex_q *q, struct futex_hash_bucket *hb)\n{\n\tspin_unlock(&hb->lock);\n\tdrop_futex_key_refs(&q->key);\n}", "target": 1}
{"code": "const char *luaG_findlocal (lua_State *L, CallInfo *ci, int n, StkId *pos) {\n  StkId base = ci->func + 1;\n  const char *name = NULL;\n  if (isLua(ci)) {\n    if (n < 0)  \n      return findvararg(ci, -n, pos);\n    else\n      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));\n  }\n  if (name == NULL) {  \n    StkId limit = (ci == L->ci) ? L->top : ci->next->func;\n    if (limit - base >= n && n > 0) {  \n      name = isLua(ci) ? \"(temporary)\" : \"(C temporary)\";\n    }\n    else\n      return NULL;  \n  }\n  if (pos)\n    *pos = base + (n - 1);\n  return name;\n}", "target": 1}
{"code": "agoo_con_create(agooErr err, int sock, uint64_t id, agooBind b) {\n    agooCon\tc;\n    if (NULL == (c = (agooCon)AGOO_CALLOC(1, sizeof(struct _agooCon)))) {\n\tAGOO_ERR_MEM(err, \"Connection\");\n    } else {\n\tstruct sockaddr_storage\taddr;\n\tsocklen_t\t\tlen = sizeof(addr);\n\tgetpeername(sock, (struct sockaddr*)&addr, &len);\n\tif (addr.ss_family == AF_INET) {\n\t    struct sockaddr_in\t*s = (struct sockaddr_in*)&addr;\n\t    inet_ntop(AF_INET, &s->sin_addr, c->remote, sizeof(c->remote));\n\t} else {\n\t    struct sockaddr_in6\t*s = (struct sockaddr_in6*)&addr;\n\t    inet_ntop(AF_INET6, &s->sin6_addr, c->remote, sizeof(c->remote));\n\t}\n\tc->sock = sock;\n\tc->id = id;\n\tc->timeout = dtime() + CON_TIMEOUT;\n\tc->bind = b;\n\tc->loop = NULL;\n\tpthread_mutex_init(&c->res_lock, 0);\n    }\n    return c;\n}", "target": 0}
{"code": "static int unix_dgram_peer_wake_connect(struct sock *sk, struct sock *other)\n{\n\tstruct unix_sock *u, *u_other;\n\tint rc;\n\tu = unix_sk(sk);\n\tu_other = unix_sk(other);\n\trc = 0;\n\tspin_lock(&u_other->peer_wait.lock);\n\tif (!u->peer_wake.private) {\n\t\tu->peer_wake.private = other;\n\t\t__add_wait_queue(&u_other->peer_wait, &u->peer_wake);\n\t\trc = 1;\n\t}\n\tspin_unlock(&u_other->peer_wait.lock);\n\treturn rc;\n}", "target": 0}
{"code": "static void gfs2_evict_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct gfs2_sbd *sdp = sb->s_fs_info;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tint ret;\n\tif (inode->i_nlink || sb_rdonly(sb) || !ip->i_no_addr)\n\t\tgoto out;\n\tif (!sdp->sd_jdesc)\n\t\tgoto out;\n\tgfs2_holder_mark_uninitialized(&gh);\n\tret = evict_should_delete(inode, &gh);\n\tif (ret == SHOULD_DEFER_EVICTION)\n\t\tgoto out;\n\tif (ret == SHOULD_DELETE_DINODE)\n\t\tret = evict_unlinked_inode(inode);\n\telse\n\t\tret = evict_linked_inode(inode);\n\tif (gfs2_rs_active(&ip->i_res))\n\t\tgfs2_rs_deltree(&ip->i_res);\n\tif (gfs2_holder_initialized(&gh))\n\t\tgfs2_glock_dq_uninit(&gh);\n\tif (ret && ret != GLR_TRYFAILED && ret != -EROFS)\n\t\tfs_warn(sdp, \"gfs2_evict_inode: %d\\n\", ret);\nout:\n\ttruncate_inode_pages_final(&inode->i_data);\n\tif (ip->i_qadata)\n\t\tgfs2_assert_warn(sdp, ip->i_qadata->qa_ref == 0);\n\tgfs2_rs_deltree(&ip->i_res);\n\tgfs2_ordered_del_inode(ip);\n\tclear_inode(inode);\n\tgfs2_dir_hash_inval(ip);\n\tif (gfs2_holder_initialized(&ip->i_iopen_gh)) {\n\t\tstruct gfs2_glock *gl = ip->i_iopen_gh.gh_gl;\n\t\tglock_clear_object(gl, ip);\n\t\tgfs2_glock_hold(gl);\n\t\tip->i_iopen_gh.gh_flags |= GL_NOCACHE;\n\t\tgfs2_glock_dq_uninit(&ip->i_iopen_gh);\n\t\tgfs2_glock_put_eventually(gl);\n\t}\n\tif (ip->i_gl) {\n\t\tglock_clear_object(ip->i_gl, ip);\n\t\twait_on_bit_io(&ip->i_flags, GIF_GLOP_PENDING, TASK_UNINTERRUPTIBLE);\n\t\tgfs2_glock_add_to_lru(ip->i_gl);\n\t\tgfs2_glock_put_eventually(ip->i_gl);\n\t\tip->i_gl = NULL;\n\t}\n}", "target": 0}
{"code": "static struct full_stripe_lock *search_full_stripe_lock(\n\t\tstruct btrfs_full_stripe_locks_tree *locks_root,\n\t\tu64 fstripe_logical)\n{\n\tstruct rb_node *node;\n\tstruct full_stripe_lock *entry;\n\tlockdep_assert_held(&locks_root->lock);\n\tnode = locks_root->root.rb_node;\n\twhile (node) {\n\t\tentry = rb_entry(node, struct full_stripe_lock, node);\n\t\tif (fstripe_logical < entry->logical)\n\t\t\tnode = node->rb_left;\n\t\telse if (fstripe_logical > entry->logical)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "int nfc_register_device(struct nfc_dev *dev)\n{\n\tint rc;\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\tmutex_lock(&nfc_devlist_mutex);\n\tnfc_devlist_generation++;\n\trc = device_add(&dev->dev);\n\tmutex_unlock(&nfc_devlist_mutex);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = nfc_llcp_register_device(dev);\n\tif (rc)\n\t\tpr_err(\"Could not register llcp device\\n\");\n\tdevice_lock(&dev->dev);\n\tdev->rfkill = rfkill_alloc(dev_name(&dev->dev), &dev->dev,\n\t\t\t\t   RFKILL_TYPE_NFC, &nfc_rfkill_ops, dev);\n\tif (dev->rfkill) {\n\t\tif (rfkill_register(dev->rfkill) < 0) {\n\t\t\trfkill_destroy(dev->rfkill);\n\t\t\tdev->rfkill = NULL;\n\t\t}\n\t}\n\tdev->shutting_down = false;\n\tdevice_unlock(&dev->dev);\n\trc = nfc_genl_device_added(dev);\n\tif (rc)\n\t\tpr_debug(\"The userspace won't be notified that the device %s was added\\n\",\n\t\t\t dev_name(&dev->dev));\n\treturn 0;\n}", "target": 0}
{"code": "static int g2m_init_buffers(G2MContext *c)\n{\n    int aligned_height;\n    if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {\n        c->framebuf_stride = FFALIGN(c->width * 3, 16);\n        aligned_height     = FFALIGN(c->height,    16);\n        av_free(c->framebuf);\n        c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);\n        if (!c->framebuf)\n            return AVERROR(ENOMEM);\n    }\n    if (!c->synth_tile || !c->jpeg_tile ||\n        c->old_tile_w < c->tile_width ||\n        c->old_tile_h < c->tile_height) {\n        c->tile_stride = FFALIGN(c->tile_width * 3, 16);\n        aligned_height = FFALIGN(c->tile_height,    16);\n        av_free(c->synth_tile);\n        av_free(c->jpeg_tile);\n        av_free(c->kempf_buf);\n        av_free(c->kempf_flags);\n        c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);\n        c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);\n        c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height\n                                    + FF_INPUT_BUFFER_PADDING_SIZE);\n        c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);\n        if (!c->synth_tile || !c->jpeg_tile ||\n            !c->kempf_buf || !c->kempf_flags)\n            return AVERROR(ENOMEM);\n    }\n    return 0;\n}", "target": 1}
{"code": "void __init xen_init_IRQ(void)\n{\n\tint ret = -EINVAL;\n\tevtchn_port_t evtchn;\n\tif (fifo_events)\n\t\tret = xen_evtchn_fifo_init();\n\tif (ret < 0)\n\t\txen_evtchn_2l_init();\n\txen_cpu_init_eoi(smp_processor_id());\n\tcpuhp_setup_state_nocalls(CPUHP_XEN_EVTCHN_PREPARE,\n\t\t\t\t  \"xen/evtchn:prepare\",\n\t\t\t\t  xen_evtchn_cpu_prepare, xen_evtchn_cpu_dead);\n\tevtchn_to_irq = kcalloc(EVTCHN_ROW(xen_evtchn_max_channels()),\n\t\t\t\tsizeof(*evtchn_to_irq), GFP_KERNEL);\n\tBUG_ON(!evtchn_to_irq);\n\tfor (evtchn = 0; evtchn < xen_evtchn_nr_channels(); evtchn++)\n\t\tmask_evtchn(evtchn);\n\tpirq_needs_eoi = pirq_needs_eoi_flag;\n#ifdef CONFIG_X86\n\tif (xen_pv_domain()) {\n\t\tif (xen_initial_domain())\n\t\t\tpci_xen_initial_domain();\n\t}\n\tif (xen_feature(XENFEAT_hvm_callback_vector)) {\n\t\txen_setup_callback_vector();\n\t\txen_alloc_callback_vector();\n\t}\n\tif (xen_hvm_domain()) {\n\t\tnative_init_IRQ();\n\t\tpci_xen_hvm_init();\n\t} else {\n\t\tint rc;\n\t\tstruct physdev_pirq_eoi_gmfn eoi_gmfn;\n\t\tpirq_eoi_map = (void *)__get_free_page(GFP_KERNEL|__GFP_ZERO);\n\t\teoi_gmfn.gmfn = virt_to_gfn(pirq_eoi_map);\n\t\trc = HYPERVISOR_physdev_op(PHYSDEVOP_pirq_eoi_gmfn_v2, &eoi_gmfn);\n\t\tif (rc != 0) {\n\t\t\tfree_page((unsigned long) pirq_eoi_map);\n\t\t\tpirq_eoi_map = NULL;\n\t\t} else\n\t\t\tpirq_needs_eoi = pirq_check_eoi_map;\n\t}\n#endif\n}", "target": 0}
{"code": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tfile_sb_list_del(file);\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}", "target": 1}
{"code": "int LibRaw::minolta_z2()\n{\n  int i, nz;\n  char tail[424];\n  fseek(ifp, -sizeof tail, SEEK_END);\n  fread(tail, 1, sizeof tail, ifp);\n  for (nz = i = 0; i < sizeof tail; i++)\n    if (tail[i])\n      nz++;\n  return nz > 20;\n}", "target": 0}
{"code": "virSecuritySELinuxRestoreMemoryLabel(virSecurityManager *mgr,\n                                     virDomainDef *def,\n                                     virDomainMemoryDef *mem)\n{\n    int ret = -1;\n    virSecurityLabelDef *seclabel;\n    switch (mem->model) {\n    case VIR_DOMAIN_MEMORY_MODEL_NVDIMM:\n    case VIR_DOMAIN_MEMORY_MODEL_VIRTIO_PMEM:\n        seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n        if (!seclabel || !seclabel->relabel)\n            return 0;\n        ret = virSecuritySELinuxRestoreFileLabel(mgr, mem->nvdimmPath, true);\n        break;\n    case VIR_DOMAIN_MEMORY_MODEL_DIMM:\n    case VIR_DOMAIN_MEMORY_MODEL_NONE:\n    case VIR_DOMAIN_MEMORY_MODEL_LAST:\n        ret = 0;\n        break;\n    }\n    return ret;\n}", "target": 0}
{"code": "psf_close (SF_PRIVATE *psf)\n{\tuint32_t k ;\n\tint\terror = 0 ;\n\tif (psf->codec_close)\n\t{\terror = psf->codec_close (psf) ;\n\t\tpsf->codec_close = NULL ;\n\t\t} ;\n\tif (psf->container_close)\n\t\terror = psf->container_close (psf) ;\n\terror = psf_fclose (psf) ;\n\tpsf_close_rsrc (psf) ;\n\tfree (psf->header.ptr) ;\n\tfree (psf->container_data) ;\n\tfree (psf->codec_data) ;\n\tfree (psf->interleave) ;\n\tfree (psf->dither) ;\n\tfree (psf->peak_info) ;\n\tfree (psf->broadcast_16k) ;\n\tfree (psf->loop_info) ;\n\tfree (psf->instrument) ;\n\tfree (psf->cues) ;\n\tfree (psf->channel_map) ;\n\tfree (psf->format_desc) ;\n\tfree (psf->strings.storage) ;\n\tif (psf->wchunks.chunks)\n\t\tfor (k = 0 ; k < psf->wchunks.used ; k++)\n\t\t\tfree (psf->wchunks.chunks [k].data) ;\n\tfree (psf->rchunks.chunks) ;\n\tfree (psf->wchunks.chunks) ;\n\tfree (psf->iterator) ;\n\tfree (psf->cart_16k) ;\n\tmemset (psf, 0, sizeof (SF_PRIVATE)) ;\n\tfree (psf) ;\n\treturn error ;\n} ", "target": 0}
{"code": "Error ImageOverlay::parse(size_t num_images, const std::vector<uint8_t>& data)\n{\n  Error eofError(heif_error_Invalid_input,\n                 heif_suberror_Invalid_grid_data,\n                 \"Overlay image data incomplete\");\n  if (data.size() < 2 + 4 * 2) {\n    return eofError;\n  }\n  m_version = data[0];\n  m_flags = data[1];\n  if (m_version != 0) {\n    std::stringstream sstr;\n    sstr << \"Overlay image data version \" << ((int) m_version) << \" is not implemented yet\";\n    return Error(heif_error_Unsupported_feature,\n                 heif_suberror_Unsupported_data_version,\n                 sstr.str());\n  }\n  int field_len = ((m_flags & 1) ? 4 : 2);\n  int ptr = 2;\n  if (ptr + 4 * 2 + 2 * field_len + num_images * 2 * field_len > data.size()) {\n    return eofError;\n  }\n  for (int i = 0; i < 4; i++) {\n    uint16_t color = static_cast<uint16_t>(readvec(data, ptr, 2));\n    m_background_color[i] = color;\n  }\n  m_width = readvec(data, ptr, field_len);\n  m_height = readvec(data, ptr, field_len);\n  m_offsets.resize(num_images);\n  for (size_t i = 0; i < num_images; i++) {\n    m_offsets[i].x = readvec_signed(data, ptr, field_len);\n    m_offsets[i].y = readvec_signed(data, ptr, field_len);\n  }\n  return Error::Ok;\n}", "target": 1}
{"code": "lyd_new(struct lyd_node *parent, const struct lys_module *module, const char *name)\n{\n    const struct lys_node *snode = NULL, *siblings;\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n    siblings = lyd_new_find_schema(parent, module, 0);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_CONTAINER | LYS_LIST | LYS_NOTIF\n                         | LYS_RPC | LYS_ACTION, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n    return _lyd_new(parent, snode, 0);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    StagingMap<Ordered>* map = nullptr;\n    OP_REQUIRES_OK(ctx, GetStagingMap(ctx, def(), &map));\n    core::ScopedUnref scope(map);\n    typename StagingMap<Ordered>::OptionalTuple tuple;\n    const Tensor* key_tensor;\n    const Tensor* indices_tensor;\n    OpInputList values_tensor;\n    OP_REQUIRES_OK(ctx, ctx->input(\"key\", &key_tensor));\n    OP_REQUIRES_OK(ctx, ctx->input(\"indices\", &indices_tensor));\n    OP_REQUIRES_OK(ctx, ctx->input_list(\"values\", &values_tensor));\n    OP_REQUIRES(ctx, key_tensor->NumElements() > 0,\n                errors::InvalidArgument(\"key must not be empty\"));\n    OP_REQUIRES(ctx, key_tensor->NumElements() == 1,\n                errors::InvalidArgument(\n                    \"key must be an int64 scalar, got tensor with shape: \",\n                    key_tensor->shape()));\n    Tensor key(*key_tensor);\n    for (std::size_t i = 0; i < values_tensor.size(); ++i) {\n      tuple.push_back(values_tensor[i]);\n    }\n    OP_REQUIRES_OK(ctx, map->put(&key, indices_tensor, &tuple));\n  }", "target": 0}
{"code": "    size_t operator()(const std::string &str) const\n    {\n        const size_t A = 6665339;\n        const size_t B = 2534641;\n        size_t h = fixedRandomNumber;\n        for (char ch : str)\n            h = (h * A) ^ (ch * B);\n        return h;\n    }", "target": 0}
{"code": "static TEE_Result do_alloc_publickey(struct rsa_public_key *s,\n\t\t\t\t     size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->e))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->n)) {\n\t\tcrypto_bignum_free(s->e);\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\t}\n\treturn TEE_SUCCESS;\n}", "target": 1}
{"code": "static void update_exception_bitmap(struct kvm_vcpu *vcpu)\n{\n\tu32 eb;\n\teb = (1u << PF_VECTOR) | (1u << UD_VECTOR) | (1u << MC_VECTOR) |\n\t     (1u << NM_VECTOR) | (1u << DB_VECTOR);\n\tif ((vcpu->guest_debug &\n\t     (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP)) ==\n\t    (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP))\n\t\teb |= 1u << BP_VECTOR;\n\tif (to_vmx(vcpu)->rmode.vm86_active)\n\t\teb = ~0;\n\tif (enable_ept)\n\t\teb &= ~(1u << PF_VECTOR); \n\tif (vcpu->fpu_active)\n\t\teb &= ~(1u << NM_VECTOR);\n\tif (is_guest_mode(vcpu))\n\t\teb |= get_vmcs12(vcpu)->exception_bitmap;\n\tvmcs_write32(EXCEPTION_BITMAP, eb);\n}", "target": 1}
{"code": "int install_thread_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\tif (new->thread_keyring)\n\t\treturn 0;\n\tkeyring = keyring_alloc(\"_tid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\tnew->thread_keyring = keyring;\n\treturn 0;\n}", "target": 0}
{"code": "static int fuse_notify_inval_entry(struct fuse_conn *fc, unsigned int size,\n\t\t\t\t   struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_inval_entry_out outarg;\n\tint err = -ENOMEM;\n\tchar *buf;\n\tstruct qstr name;\n\tbuf = kzalloc(FUSE_NAME_MAX + 1, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err;\n\terr = -EINVAL;\n\tif (size < sizeof(outarg))\n\t\tgoto err;\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto err;\n\terr = -ENAMETOOLONG;\n\tif (outarg.namelen > FUSE_NAME_MAX)\n\t\tgoto err;\n\terr = -EINVAL;\n\tif (size != sizeof(outarg) + outarg.namelen + 1)\n\t\tgoto err;\n\tname.name = buf;\n\tname.len = outarg.namelen;\n\terr = fuse_copy_one(cs, buf, outarg.namelen + 1);\n\tif (err)\n\t\tgoto err;\n\tfuse_copy_finish(cs);\n\tbuf[outarg.namelen] = 0;\n\tname.hash = full_name_hash(name.name, name.len);\n\tdown_read(&fc->killsb);\n\terr = -ENOENT;\n\tif (fc->sb)\n\t\terr = fuse_reverse_inval_entry(fc->sb, outarg.parent, &name);\n\tup_read(&fc->killsb);\n\tkfree(buf);\n\treturn err;\nerr:\n\tkfree(buf);\n\tfuse_copy_finish(cs);\n\treturn err;\n}", "target": 0}
{"code": "static bool access_pmu_evcntr(struct kvm_vcpu *vcpu,\n\t\t\t      struct sys_reg_params *p,\n\t\t\t      const struct sys_reg_desc *r)\n{\n\tu64 idx;\n\tif (!kvm_arm_pmu_v3_ready(vcpu))\n\t\treturn trap_raz_wi(vcpu, p, r);\n\tif (r->CRn == 9 && r->CRm == 13) {\n\t\tif (r->Op2 == 2) {\n\t\t\tif (pmu_access_event_counter_el0_disabled(vcpu))\n\t\t\t\treturn false;\n\t\t\tidx = vcpu_sys_reg(vcpu, PMSELR_EL0)\n\t\t\t      & ARMV8_PMU_COUNTER_MASK;\n\t\t} else if (r->Op2 == 0) {\n\t\t\tif (pmu_access_cycle_counter_el0_disabled(vcpu))\n\t\t\t\treturn false;\n\t\t\tidx = ARMV8_PMU_CYCLE_IDX;\n\t\t} else {\n\t\t\tBUG();\n\t\t}\n\t} else if (r->CRn == 14 && (r->CRm & 12) == 8) {\n\t\tif (pmu_access_event_counter_el0_disabled(vcpu))\n\t\t\treturn false;\n\t\tidx = ((r->CRm & 3) << 3) | (r->Op2 & 7);\n\t} else {\n\t\tBUG();\n\t}\n\tif (!pmu_counter_idx_valid(vcpu, idx))\n\t\treturn false;\n\tif (p->is_write) {\n\t\tif (pmu_access_el0_disabled(vcpu))\n\t\t\treturn false;\n\t\tkvm_pmu_set_counter_value(vcpu, idx, p->regval);\n\t} else {\n\t\tp->regval = kvm_pmu_get_counter_value(vcpu, idx);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "accept_xsmp_connection (SmsConn        sms_conn,\n                        GsmXsmpServer *server,\n                        unsigned long *mask_ret,\n                        SmsCallbacks  *callbacks_ret,\n                        char         **failure_reason_ret)\n{\n        IceConn        ice_conn;\n        GsmXSMPClient *client;\n        if (server->priv->xsmp_sockets == NULL) {\n                g_debug (\"GsmXsmpServer: In shutdown, rejecting new client\");\n                *failure_reason_ret = strdup (_(\"Refusing new client connection because the session is currently being shut down\\n\"));\n                return FALSE;\n        }\n        ice_conn = SmsGetIceConnection (sms_conn);\n        client = ice_conn->context;\n        g_return_val_if_fail (client != NULL, TRUE);\n        gsm_xsmp_client_connect (client, sms_conn, mask_ret, callbacks_ret);\n        return TRUE;\n}", "target": 1}
{"code": "static int __init personal_pci_init(void)\n{\n\tif (machine_is_personal_server())\n\t\tpci_common_init(&personal_server_pci);\n\treturn 0;\n}", "target": 1}
{"code": "gs_malloc_init(void)\n{\n    gs_malloc_memory_t *malloc_memory_default = gs_malloc_memory_init();\n    gs_memory_t *memory_t_default;\n    if (malloc_memory_default == NULL)\n        return NULL;\n    if (gs_lib_ctx_init((gs_memory_t *)malloc_memory_default) != 0)\n        return NULL;\n#if defined(USE_RETRY_MEMORY_WRAPPER)\n    gs_malloc_wrap(&memory_t_default, malloc_memory_default);\n#else\n    memory_t_default = (gs_memory_t *)malloc_memory_default;\n#endif\n    memory_t_default->stable_memory = memory_t_default;\n    return memory_t_default;\n}", "target": 0}
{"code": "static inline struct sem_array *sem_lock_check(struct ipc_namespace *ns,\n\t\t\t\t\t\tint id)\n{\n\tstruct kern_ipc_perm *ipcp = ipc_lock_check(&sem_ids(ns), id);\n\tif (IS_ERR(ipcp))\n\t\treturn ERR_CAST(ipcp);\n\treturn container_of(ipcp, struct sem_array, sem_perm);\n}", "target": 1}
{"code": "g_file_set_contents_full(const gchar *filename,\n\t\t\t const gchar *contents,\n\t\t\t gssize length,\n\t\t\t GFileSetContentsFlags flags,\n\t\t\t int mode,\n\t\t\t GError **error)\n{\n\tgint fd;\n\tgssize wrote;\n\tif (length < 0)\n\t\tlength = strlen(contents);\n\tfd = g_open(filename, O_CREAT, mode);\n\tif (fd <= 0) {\n\t\tg_set_error(error,\n\t\t\t    G_IO_ERROR,\n\t\t\t    G_IO_ERROR_FAILED,\n\t\t\t    \"could not open %s file\",\n\t\t\t    filename);\n\t\treturn FALSE;\n\t}\n\twrote = write(fd, contents, length);\n\tif (wrote != length) {\n\t\tg_set_error(error,\n\t\t\t    G_IO_ERROR,\n\t\t\t    G_IO_ERROR_FAILED,\n\t\t\t    \"did not write %s file\",\n\t\t\t    filename);\n\t\tg_close(fd, NULL);\n\t\treturn FALSE;\n\t}\n\treturn g_close(fd, error);\n}", "target": 0}
{"code": "static void xudc_getstatus(struct xusb_udc *udc)\n{\n\tstruct xusb_ep *ep0\t= &udc->ep[0];\n\tstruct xusb_req *req\t= udc->req;\n\tstruct xusb_ep *target_ep;\n\tu16 status = 0;\n\tu32 epcfgreg;\n\tint epnum;\n\tu32 halt;\n\tint ret;\n\tswitch (udc->setup.bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\tstatus = 1 << USB_DEVICE_SELF_POWERED;\n\t\tif (udc->remote_wkp)\n\t\t\tstatus |= (1 << USB_DEVICE_REMOTE_WAKEUP);\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT:\n\t\tepnum = udc->setup.wIndex & USB_ENDPOINT_NUMBER_MASK;\n\t\tif (epnum >= XUSB_MAX_ENDPOINTS)\n\t\t\tgoto stall;\n\t\ttarget_ep = &udc->ep[epnum];\n\t\tepcfgreg = udc->read_fn(udc->addr + target_ep->offset);\n\t\thalt = epcfgreg & XUSB_EP_CFG_STALL_MASK;\n\t\tif (udc->setup.wIndex & USB_DIR_IN) {\n\t\t\tif (!target_ep->is_in)\n\t\t\t\tgoto stall;\n\t\t} else {\n\t\t\tif (target_ep->is_in)\n\t\t\t\tgoto stall;\n\t\t}\n\t\tif (halt)\n\t\t\tstatus = 1 << USB_ENDPOINT_HALT;\n\t\tbreak;\n\tdefault:\n\t\tgoto stall;\n\t}\n\treq->usb_req.length = 2;\n\t*(u16 *)req->usb_req.buf = cpu_to_le16(status);\n\tret = __xudc_ep0_queue(ep0, req);\n\tif (ret == 0)\n\t\treturn;\nstall:\n\tdev_err(udc->dev, \"Can't respond to getstatus request\\n\");\n\txudc_ep0_stall(udc);\n}", "target": 0}
{"code": "    DataBuf LoaderExifDataJpeg::getData() const\n    {\n        if (!valid()) return DataBuf();\n        ExifData::const_iterator pos = image_.exifData().findKey(dataKey_);\n        if (pos != image_.exifData().end()) {\n            DataBuf buf = pos->dataArea(); \n            if (buf.size_ == 0) { \n                buf = DataBuf(pos->size());\n                pos->copy(buf.pData_, invalidByteOrder);\n            }\n            buf.pData_[0] = 0xff; \n            return buf;\n        }\n        return DataBuf();\n    }", "target": 0}
{"code": "static int SetupSavePath(const DetectEngineCtx *de_ctx,\n        char *save, size_t save_size)\n{\n    SCLogDebug(\"save %s\", save);\n    int allow_save = 1;\n    if (ConfGetBool(\"datasets.rules.allow-write\", &allow_save)) {\n        if (!allow_save) {\n            SCLogError(SC_ERR_INVALID_SIGNATURE,\n                    \"Rules containing save/state datasets have been disabled\");\n            return -1;\n        }\n    }\n    int allow_absolute = 0;\n    (void)ConfGetBool(\"datasets.rules.allow-absolute-filenames\", &allow_absolute);\n    if (allow_absolute) {\n        SCLogNotice(\"Allowing absolute filename for dataset rule: %s\", save);\n    } else {\n        if (PathIsAbsolute(save)) {\n            SCLogError(SC_ERR_INVALID_ARGUMENT, \"Absolute paths not allowed: %s\", save);\n            return -1;\n        }\n        if (SCPathContainsTraversal(save)) {\n            SCLogError(SC_ERR_INVALID_ARGUMENT, \"Directory traversals not allowed: %s\", save);\n            return -1;\n        }\n    }\n    const char *dir = ConfigGetDataDirectory();\n    BUG_ON(dir == NULL); \n    char path[PATH_MAX];\n    if (snprintf(path, sizeof(path), \"%s/%s\", dir, save) >= (int)sizeof(path)) \n        return -1;\n    strlcpy(save, path, save_size);\n    return 0;\n}", "target": 0}
{"code": "int sas_discover_end_dev(struct domain_device *dev)\n{\n\tint res;\n\tres = sas_notify_lldd_dev_found(dev);\n\tif (res)\n\t\treturn res;\n\tsas_discover_event(dev->port, DISCE_PROBE);\n\treturn 0;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(context->input(0).shape()),\n                errors::InvalidArgument(\"dim must be a scalar\"));\n    int32_t dim = context->input(0).scalar<int32_t>()();\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(context->input(0).shape()),\n                errors::InvalidArgument(\"num_results must be a scalar\"));\n    int32_t num_results = context->input(1).scalar<int32_t>()();\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(context->input(0).shape()),\n                errors::InvalidArgument(\"skip must be a scalar\"));\n    int32_t skip = context->input(2).scalar<int32_t>()();\n    OP_REQUIRES(context, dim >= 1,\n                errors::InvalidArgument(\"dim must be at least one\"));\n    OP_REQUIRES(context, dim <= sobol_data::kMaxSobolDim,\n                errors::InvalidArgument(\"dim must be at most \",\n                                        sobol_data::kMaxSobolDim));\n    OP_REQUIRES(context, num_results >= 1,\n                errors::InvalidArgument(\"num_results must be at least one\"));\n    OP_REQUIRES(context, skip >= 0,\n                errors::InvalidArgument(\"skip must be non-negative\"));\n    OP_REQUIRES(context,\n                num_results < std::numeric_limits<int32_t>::max() - skip,\n                errors::InvalidArgument(\"num_results+skip must be less than \",\n                                        std::numeric_limits<int32_t>::max()));\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(\n                       0, TensorShape({num_results, dim}), &output));\n    auto output_flat = output->flat<T>();\n    const DeviceBase::CpuWorkerThreads& worker_threads =\n        *(context->device()->tensorflow_cpu_worker_threads());\n    int num_threads = worker_threads.num_threads;\n    int block_size = std::max(\n        kMinBlockSize, static_cast<int>(std::ceil(\n                           static_cast<float>(num_results) / num_threads)));\n    worker_threads.workers->TransformRangeConcurrently(\n        block_size, num_results ,\n        [&dim, &skip, &output_flat](const int start, const int end) {\n          CalculateSobolSample<T>(dim, end - start , skip,\n                                  start, output_flat);\n        });\n  }", "target": 0}
{"code": "d_lite_step(int argc, VALUE *argv, VALUE self)\n{\n    VALUE limit, step, date;\n    int c;\n    rb_scan_args(argc, argv, \"11\", &limit, &step);\n    if (argc < 2)\n\tstep = INT2FIX(1);\n#if 0\n    if (f_zero_p(step))\n\trb_raise(rb_eArgError, \"step can't be 0\");\n#endif\n    RETURN_ENUMERATOR(self, argc, argv);\n    date = self;\n    c = f_cmp(step, INT2FIX(0));\n    if (c < 0) {\n\twhile (FIX2INT(d_lite_cmp(date, limit)) >= 0) {\n\t    rb_yield(date);\n\t    date = d_lite_plus(date, step);\n\t}\n    }\n    else if (c == 0) {\n\twhile (1)\n\t    rb_yield(date);\n    }\n    else  {\n\twhile (FIX2INT(d_lite_cmp(date, limit)) <= 0) {\n\t    rb_yield(date);\n\t    date = d_lite_plus(date, step);\n\t}\n    }\n    return self;\n}", "target": 0}
{"code": "int sas_smp_get_phy_events(struct sas_phy *phy)\n{\n\tint res;\n\tu8 *req;\n\tu8 *resp;\n\tstruct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);\n\tstruct domain_device *dev = sas_find_dev_by_rphy(rphy);\n\treq = alloc_smp_req(RPEL_REQ_SIZE);\n\tif (!req)\n\t\treturn -ENOMEM;\n\tresp = alloc_smp_resp(RPEL_RESP_SIZE);\n\tif (!resp) {\n\t\tkfree(req);\n\t\treturn -ENOMEM;\n\t}\n\treq[1] = SMP_REPORT_PHY_ERR_LOG;\n\treq[9] = phy->number;\n\tres = smp_execute_task(dev, req, RPEL_REQ_SIZE,\n\t\t\t            resp, RPEL_RESP_SIZE);\n\tif (!res)\n\t\tgoto out;\n\tphy->invalid_dword_count = scsi_to_u32(&resp[12]);\n\tphy->running_disparity_error_count = scsi_to_u32(&resp[16]);\n\tphy->loss_of_dword_sync_count = scsi_to_u32(&resp[20]);\n\tphy->phy_reset_problem_count = scsi_to_u32(&resp[24]);\n out:\n\tkfree(req);\n\tkfree(resp);\n\treturn res;\n}", "target": 0}
{"code": "  Status CheckInputs(Tensor group_size_t, Tensor group_key_t) {\n    if (group_size_t.dims() > 0) {\n      return errors::Internal(\n          \"Unexpected dimensions on input group_size. \"\n          \"It shoulbe a scalar, got tensor with shape \",\n          group_size_t.shape().DebugString());\n    }\n    if (group_key_t.dims() > 0) {\n      return errors::Internal(\"Unexpected dimensions on input group_key, got \",\n                              group_key_t.shape().DebugString());\n    }\n    auto group_size = group_size_t.unaligned_flat<int32>()(0);\n    if (group_size <= 0) {\n      return errors::InvalidArgument(\n          \"group_size must be positive integer but got \", group_size);\n    }\n    return Status::OK();\n  }", "target": 1}
{"code": "  void encode(bufferlist& bl) const {\n    __u8 struct_v = 1;\n    ::encode(struct_v, bl);\n    ::encode(nonce, bl);\n  }", "target": 1}
{"code": "static int __init sit_init(void)\n{\n\tint err;\n\tprintk(KERN_INFO \"IPv6 over IPv4 tunneling driver\\n\");\n\tif (xfrm4_tunnel_register(&sit_handler, AF_INET6) < 0) {\n\t\tprintk(KERN_INFO \"sit init: Can't add protocol\\n\");\n\t\treturn -EAGAIN;\n\t}\n\terr = register_pernet_device(&sit_net_ops);\n\tif (err < 0)\n\t\txfrm4_tunnel_deregister(&sit_handler, AF_INET6);\n\treturn err;\n}", "target": 1}
{"code": " */\nstatic enum hrtimer_restart bfq_idle_slice_timer(struct hrtimer *timer)\n{\n\tstruct bfq_data *bfqd = container_of(timer, struct bfq_data,\n\t\t\t\t\t     idle_slice_timer);\n\tstruct bfq_queue *bfqq = bfqd->in_service_queue;\n\tif (bfqq)\n\t\tbfq_idle_slice_timer_body(bfqq);\n\treturn HRTIMER_NORESTART;", "target": 1}
{"code": "void schedule_deferred_open_smb_message(uint16 mid)\n{\n\tstruct pending_message_list *pml;\n\tint i = 0;\n\tfor (pml = deferred_open_queue; pml; pml = pml->next) {\n\t\tuint16 msg_mid = SVAL(pml->buf.data,smb_mid);\n\t\tDEBUG(10,(\"schedule_deferred_open_smb_message: [%d] msg_mid = %u\\n\", i++,\n\t\t\t(unsigned int)msg_mid ));\n\t\tif (mid == msg_mid) {\n\t\t\tstruct timed_event *te;\n\t\t\tDEBUG(10,(\"schedule_deferred_open_smb_message: scheduling mid %u\\n\",\n\t\t\t\tmid ));\n\t\t\tte = event_add_timed(smbd_event_context(),\n\t\t\t\t\t     pml,\n\t\t\t\t\t     timeval_zero(),\n\t\t\t\t\t     smbd_deferred_open_timer,\n\t\t\t\t\t     pml);\n\t\t\tif (!te) {\n\t\t\t\tDEBUG(10,(\"schedule_deferred_open_smb_message: \"\n\t\t\t\t\t  \"event_add_timed() failed, skipping mid %u\\n\",\n\t\t\t\t\t  mid ));\n\t\t\t}\n\t\t\tTALLOC_FREE(pml->te);\n\t\t\tpml->te = te;\n\t\t\tDLIST_PROMOTE(deferred_open_queue, pml);\n\t\t\treturn;\n\t\t}\n\t}\n\tDEBUG(10,(\"schedule_deferred_open_smb_message: failed to find message mid %u\\n\",\n\t\tmid ));\n}", "target": 0}
{"code": "static int cbs_av1_read_uvlc(CodedBitstreamContext *ctx, GetBitContext *gbc,\n                             const char *name, uint32_t *write_to,\n                             uint32_t range_min, uint32_t range_max)\n{\n    uint32_t value;\n    int position, zeroes, i, j;\n    char bits[65];\n    if (ctx->trace_enable)\n        position = get_bits_count(gbc);\n    zeroes = i = 0;\n    while (1) {\n        if (get_bits_left(gbc) < zeroes + 1) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"\n                   \"%s: bitstream ended.\\n\", name);\n            return AVERROR_INVALIDDATA;\n        }\n        if (get_bits1(gbc)) {\n            bits[i++] = '1';\n            break;\n        } else {\n            bits[i++] = '0';\n            ++zeroes;\n        }\n    }\n    if (zeroes >= 32) {\n        value = MAX_UINT_BITS(32);\n    } else {\n        value = get_bits_long(gbc, zeroes);\n        for (j = 0; j < zeroes; j++)\n            bits[i++] = (value >> (zeroes - j - 1) & 1) ? '1' : '0';\n        value += (1 << zeroes) - 1;\n    }\n    if (ctx->trace_enable) {\n        bits[i] = 0;\n        ff_cbs_trace_syntax_element(ctx, position, name, NULL,\n                                    bits, value);\n    }\n    if (value < range_min || value > range_max) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"%s out of range: \"\n               \"%\"PRIu32\", but must be in [%\"PRIu32\",%\"PRIu32\"].\\n\",\n               name, value, range_min, range_max);\n        return AVERROR_INVALIDDATA;\n    }\n    *write_to = value;\n    return 0;\n}", "target": 1}
{"code": "int __nla_validate(const struct nlattr *head, int len, int maxtype,\n\t\t   const struct nla_policy *policy, unsigned int validate,\n\t\t   struct netlink_ext_ack *extack)\n{\n\treturn __nla_validate_parse(head, len, maxtype, policy, validate,\n\t\t\t\t    extack, NULL);\n}", "target": 1}
{"code": "void cipso_v4_sock_delattr(struct sock *sk)\n{\n\tint hdr_delta;\n\tstruct ip_options *opt;\n\tstruct inet_sock *sk_inet;\n\tsk_inet = inet_sk(sk);\n\topt = sk_inet->opt;\n\tif (opt == NULL || opt->cipso == 0)\n\t\treturn;\n\thdr_delta = cipso_v4_delopt(&sk_inet->opt);\n\tif (sk_inet->is_icsk && hdr_delta > 0) {\n\t\tstruct inet_connection_sock *sk_conn = inet_csk(sk);\n\t\tsk_conn->icsk_ext_hdr_len -= hdr_delta;\n\t\tsk_conn->icsk_sync_mss(sk, sk_conn->icsk_pmtu_cookie);\n\t}\n}", "target": 1}
{"code": "Status GetTensorArray(OpKernelContext* ctx, TensorArray** tensor_array) {\n  string container;\n  string ta_handle;\n  if (ctx->input_dtype(0) != DT_RESOURCE) {\n    TF_RETURN_IF_ERROR(GetHandle(ctx, &container, &ta_handle));\n    ResourceMgr* rm = ctx->resource_manager();\n    if (rm == nullptr) return errors::Internal(\"No resource manager.\");\n    TF_RETURN_IF_ERROR(\n        ctx->step_container()->Lookup(rm, container + ta_handle, tensor_array));\n    return OkStatus();\n  } else {\n    return LookupResource(ctx, HandleFromInput(ctx, 0), tensor_array);\n  }\n}", "target": 1}
{"code": "print_prefix(netdissect_options *ndo, const u_char *prefix, u_int max_length)\n{\n    int plenbytes;\n    char buf[sizeof(\"xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx::/128\")];\n    if (prefix[0] >= 96 && max_length >= IPV4_MAPPED_HEADING_LEN + 1 &&\n        is_ipv4_mapped_address(&prefix[1])) {\n        struct in_addr addr;\n        u_int plen;\n        plen = prefix[0]-96;\n        if (32 < plen)\n            return -1;\n        max_length -= 1;\n        memset(&addr, 0, sizeof(addr));\n        plenbytes = (plen + 7) / 8;\n        if (max_length < (u_int)plenbytes + IPV4_MAPPED_HEADING_LEN)\n            return -3;\n        memcpy(&addr, &prefix[1 + IPV4_MAPPED_HEADING_LEN], plenbytes);\n        if (plen % 8) {\n\t\t((u_char *)&addr)[plenbytes - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, sizeof(buf), \"%s/%d\", ipaddr_string(ndo, &addr), plen);\n        plenbytes += 1 + IPV4_MAPPED_HEADING_LEN;\n    } else {\n        plenbytes = decode_prefix6(ndo, prefix, max_length, buf, sizeof(buf));\n        if (plenbytes < 0)\n            return plenbytes;\n    }\n    ND_PRINT((ndo, \"%s\", buf));\n    return plenbytes;\n}", "target": 0}
{"code": "void ZlibInStream::flushUnderlying()\n{\n  ptr = end = start;\n  while (bytesIn > 0) {\n    decompress(true);\n    end = start; \n  }\n  setUnderlying(NULL, 0);\n}", "target": 0}
{"code": "static void account_pipe_buffers(struct pipe_inode_info *pipe,\n                                 unsigned long old, unsigned long new)\n{\n\tatomic_long_add(new - old, &pipe->user->pipe_bufs);\n}", "target": 0}
{"code": "static GCObject **correctgraylist (GCObject **p) {\n  GCObject *curr;\n  while ((curr = *p) != NULL) {\n    switch (curr->tt) {\n      case LUA_VTABLE: case LUA_VUSERDATA: {\n        GCObject **next = getgclist(curr);\n        if (getage(curr) == G_TOUCHED1) {  \n          lua_assert(isgray(curr));\n          gray2black(curr);  \n          changeage(curr, G_TOUCHED1, G_TOUCHED2);\n          p = next;  \n        }\n        else {  \n          if (!iswhite(curr)) {  \n            lua_assert(isold(curr));\n            if (getage(curr) == G_TOUCHED2)  \n              changeage(curr, G_TOUCHED2, G_OLD);  \n            gray2black(curr);  \n          }\n          *p = *next;  \n        }\n        break;\n      }\n      case LUA_VTHREAD: {\n        lua_State *th = gco2th(curr);\n        lua_assert(!isblack(th));\n        if (iswhite(th))  \n          *p = th->gclist;  \n        else  \n          p = &th->gclist;  \n        break;\n      }\n      default: lua_assert(0);  \n    }\n  }\n  return p;\n}", "target": 1}
{"code": "static void ifb_setup(struct net_device *dev)\n{\n\tdev->destructor = free_netdev;\n\tdev->netdev_ops = &ifb_netdev_ops;\n\tether_setup(dev);\n\tdev->tx_queue_len = TX_Q_LIMIT;\n\tdev->features |= IFB_FEATURES;\n\tdev->vlan_features |= IFB_FEATURES;\n\tdev->flags |= IFF_NOARP;\n\tdev->flags &= ~IFF_MULTICAST;\n\tdev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n\trandom_ether_addr(dev->dev_addr);\n}", "target": 1}
{"code": "static int decode_cblk(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *codsty,\n                       Jpeg2000T1Context *t1, Jpeg2000Cblk *cblk,\n                       int width, int height, int bandpos)\n{\n    int passno = cblk->npasses, pass_t = 2, bpno = cblk->nonzerobits - 1, y;\n    int clnpass_cnt = 0;\n    int bpass_csty_symbol           = codsty->cblk_style & JPEG2000_CBLK_BYPASS;\n    int vert_causal_ctx_csty_symbol = codsty->cblk_style & JPEG2000_CBLK_VSC;\n    av_assert0(width  <= JPEG2000_MAX_CBLKW);\n    av_assert0(height <= JPEG2000_MAX_CBLKH);\n    for (y = 0; y < height; y++)\n        memset(t1->data[y], 0, width * sizeof(**t1->data));\n    if (!cblk->length)\n        return 0;\n    for (y = 0; y < height + 2; y++)\n        memset(t1->flags[y], 0, (width + 2) * sizeof(**t1->flags));\n    cblk->data[cblk->length] = 0xff;\n    cblk->data[cblk->length+1] = 0xff;\n    ff_mqc_initdec(&t1->mqc, cblk->data);\n    while (passno--) {\n        switch(pass_t) {\n        case 0:\n            decode_sigpass(t1, width, height, bpno + 1, bandpos,\n                           bpass_csty_symbol && (clnpass_cnt >= 4),\n                           vert_causal_ctx_csty_symbol);\n            break;\n        case 1:\n            decode_refpass(t1, width, height, bpno + 1);\n            if (bpass_csty_symbol && clnpass_cnt >= 4)\n                ff_mqc_initdec(&t1->mqc, cblk->data);\n            break;\n        case 2:\n            decode_clnpass(s, t1, width, height, bpno + 1, bandpos,\n                           codsty->cblk_style & JPEG2000_CBLK_SEGSYM,\n                           vert_causal_ctx_csty_symbol);\n            clnpass_cnt = clnpass_cnt + 1;\n            if (bpass_csty_symbol && clnpass_cnt >= 4)\n                ff_mqc_initdec(&t1->mqc, cblk->data);\n            break;\n        }\n        pass_t++;\n        if (pass_t == 3) {\n            bpno--;\n            pass_t = 0;\n        }\n    }\n    return 0;\n}", "target": 0}
{"code": "static int _strlen_check(int linenumber, char *buf, size_t len)\n{\n  size_t buflen = strlen(buf);\n  if(len != buflen) {\n    printf(\"sprintf strlen:%d failed:\\nwe '%d'\\nsystem: '%d'\\n\",\n           linenumber, buflen, len);\n    return 1;\n  }\n  return 0;\n}", "target": 0}
{"code": "hb_set_invert (hb_set_t *set)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->invert ();\n}", "target": 1}
{"code": "void ext2_xattr_destroy_cache(struct mb2_cache *cache)\n{\n\tif (cache)\n\t\tmb2_cache_destroy(cache);\n}", "target": 0}
{"code": "void nfc_llcp_unregister_device(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tpr_debug(\"No such device\\n\");\n\t\treturn;\n\t}\n\tlocal_cleanup(local);\n\tnfc_llcp_local_put(local);\n}", "target": 1}
{"code": "static bool vmci_transport_allow_dgram(struct vsock_sock *vsock, u32 peer_cid)\n{\n\tif (vsock->cached_peer != peer_cid) {\n\t\tvsock->cached_peer = peer_cid;\n\t\tif (!vmci_transport_is_trusted(vsock, peer_cid) &&\n\t\t    (vmci_context_get_priv_flags(peer_cid) &\n\t\t     VMCI_PRIVILEGE_FLAG_RESTRICTED)) {\n\t\t\tvsock->cached_peer_allow_dgram = false;\n\t\t} else {\n\t\t\tvsock->cached_peer_allow_dgram = true;\n\t\t}\n\t}\n\treturn vsock->cached_peer_allow_dgram;\n}", "target": 0}
{"code": "PHPAPI char *php_unescape_html_entities(unsigned char *old, size_t oldlen, size_t *newlen, int all, int flags, char *hint_charset TSRMLS_DC)\n{\n\tsize_t retlen;\n\tchar *ret;\n\tenum entity_charset charset;\n\tconst entity_ht *inverse_map = NULL;\n\tsize_t new_size = TRAVERSE_FOR_ENTITIES_EXPAND_SIZE(oldlen);\n\tif (all) {\n\t\tcharset = determine_charset(hint_charset TSRMLS_CC);\n\t} else {\n\t\tcharset = cs_8859_1; \n\t}\n\tif (oldlen > new_size) {\n\t\tret = estrndup((char*)old, oldlen);\n\t\tretlen = oldlen;\n\t\tgoto empty_source;\n\t}\n\tret = emalloc(new_size);\n\t*ret = '\\0';\n\tretlen = oldlen;\n\tif (retlen == 0) {\n\t\tgoto empty_source;\n\t}\n\tinverse_map = unescape_inverse_map(all, flags);\n\ttraverse_for_entities(old, oldlen, ret, &retlen, all, flags, inverse_map, charset);\nempty_source:\t\n\t*newlen = retlen;\n\treturn ret;\n}", "target": 1}
{"code": "sigterm_handler(int sig)\t\t\n{\n  (void)sig;\n  fprintf(stderr,\n\t  \"DEBUG: beh: Job canceled.\\n\");\n  if (job_canceled)\n    _exit(CUPS_BACKEND_OK);\n  else\n    job_canceled = 1;\n}", "target": 1}
{"code": "int main_configure(char *arg1, char *arg2) {\n    int cmdline_status;\n    cmdline_status=options_cmdline(arg1, arg2);\n    if(cmdline_status) \n        return cmdline_status;\n    options_apply();\n    str_canary_init(); \n    log_open(SINK_SYSLOG);\n    if(bind_ports())\n        return 1;\n#ifdef HAVE_CHROOT\n    if(change_root())\n        return 1;\n#endif \n    if(drop_privileges(1))\n        return 1;\n    if(log_open(SINK_OUTFILE))\n        return 1;\n#ifndef USE_FORK\n    num_clients=0; \n#endif\n    log_flush(LOG_MODE_CONFIGURED);\n    return 0;\n}", "target": 1}
{"code": "next_state_val(CClassNode* cc, OnigCodePoint *vs, OnigCodePoint v,\n\t       int* vs_israw, int v_israw,\n\t       enum CCVALTYPE intype, enum CCVALTYPE* type,\n\t       enum CCSTATE* state, ScanEnv* env)\n{\n  int r;\n  switch (*state) {\n  case CCS_VALUE:\n    if (*type == CCV_SB) {\n      if (*vs > 0xff)\n          return ONIGERR_INVALID_CODE_POINT_VALUE;\n      BITSET_SET_BIT(cc->bs, (int )(*vs));\n    }\n    else if (*type == CCV_CODE_POINT) {\n      r = add_code_range(&(cc->mbuf), env, *vs, *vs);\n      if (r < 0) return r;\n    }\n    break;\n  case CCS_RANGE:\n    if (intype == *type) {\n      if (intype == CCV_SB) {\n        if (*vs > 0xff || v > 0xff)\n          return ONIGERR_INVALID_CODE_POINT_VALUE;\n        if (*vs > v) {\n          if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n            goto ccs_range_end;\n          else\n            return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n        }\n        bitset_set_range(cc->bs, (int )*vs, (int )v);\n      }\n      else {\n        r = add_code_range(&(cc->mbuf), env, *vs, v);\n        if (r < 0) return r;\n      }\n    }\n    else {\n#if 0\n      if (intype == CCV_CODE_POINT && *type == CCV_SB) {\n#endif\n        if (*vs > v) {\n          if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n            goto ccs_range_end;\n          else\n            return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n        }\n        bitset_set_range(cc->bs, (int )*vs, (int )(v < 0xff ? v : 0xff));\n        r = add_code_range(&(cc->mbuf), env, (OnigCodePoint )*vs, v);\n        if (r < 0) return r;\n#if 0\n      }\n      else\n        return ONIGERR_MISMATCH_CODE_LENGTH_IN_CLASS_RANGE;\n#endif\n    }\n  ccs_range_end:\n    *state = CCS_COMPLETE;\n    break;\n  case CCS_COMPLETE:\n  case CCS_START:\n    *state = CCS_VALUE;\n    break;\n  default:\n    break;\n  }\n  *vs_israw = v_israw;\n  *vs       = v;\n  *type     = intype;\n  return 0;\n}", "target": 0}
{"code": "TRIO_PUBLIC_STRING size_t trio_length TRIO_ARGS1((string), TRIO_CONST char* string)\n{\n\treturn strlen(string);\n}", "target": 1}
{"code": "static inline struct inode *vfs_select_inode(struct dentry *dentry,\n\t\t\t\t\t     unsigned open_flags)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tif (inode && unlikely(dentry->d_flags & DCACHE_OP_SELECT_INODE))\n\t\tinode = dentry->d_op->d_select_inode(dentry, open_flags);\n\treturn inode;\n}", "target": 0}
{"code": "static int gup_huge_pud(pud_t orig, pud_t *pudp, unsigned long addr,\n\t\tunsigned long end, int write, struct page **pages, int *nr)\n{\n\tstruct page *head, *page;\n\tint refs;\n\tif (!pud_access_permitted(orig, write))\n\t\treturn 0;\n\tif (pud_devmap(orig))\n\t\treturn __gup_device_huge_pud(orig, pudp, addr, end, pages, nr);\n\trefs = 0;\n\tpage = pud_page(orig) + ((addr & ~PUD_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\thead = compound_head(pud_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\tif (unlikely(pud_val(orig) != pud_val(*pudp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\tSetPageReferenced(head);\n\treturn 1;\n}", "target": 1}
{"code": "static UpVal **getupvalref (lua_State *L, int fidx, int n, LClosure **pf) {\n  LClosure *f;\n  StkId fi = index2addr(L, fidx);\n  api_check(L, ttisLclosure(fi), \"Lua function expected\");\n  f = clLvalue(fi);\n  api_check(L, (1 <= n && n <= f->p->sizeupvalues), \"invalid upvalue index\");\n  if (pf) *pf = f;\n  return &f->upvals[n - 1];  \n}", "target": 1}
{"code": "add_prefix_matches(lookup_state_t *state,\n                   const svn_stringbuf_t *segment,\n                   apr_array_header_t *prefixes)\n{\n  int i = svn_sort__bsearch_lower_bound(prefixes, segment->data,\n                                        compare_node_path_segment);\n  if (i < prefixes->nelts)\n    add_if_prefix_matches(state,\n                          &APR_ARRAY_IDX(prefixes, i, sorted_pattern_t),\n                          segment);\n  if (i > 0)\n    {\n      sorted_pattern_t *pattern;\n      for (pattern = &APR_ARRAY_IDX(prefixes, i - 1, sorted_pattern_t);\n           pattern;\n           pattern = pattern->next)\n        {\n          add_if_prefix_matches(state, pattern, segment);\n        }\n    }\n}", "target": 0}
{"code": "static QSvgNode *createPathNode(QSvgNode *parent,\n                                const QXmlStreamAttributes &attributes,\n                                QSvgHandler *)\n{\n    QStringView data = attributes.value(QLatin1String(\"d\"));\n    QPainterPath qpath;\n    qpath.setFillRule(Qt::WindingFill);\n    parsePathDataFast(data, qpath);\n    QSvgNode *path = new QSvgPath(parent, qpath);\n    return path;\n}", "target": 1}
{"code": "Network::TransportSocketPtr ClientSslSocketFactory::createTransportSocket(\n    Network::TransportSocketOptionsConstSharedPtr transport_socket_options,\n    Upstream::HostDescriptionConstSharedPtr) const {\n  Envoy::Ssl::ClientContextSharedPtr ssl_ctx;\n  {\n    absl::ReaderMutexLock l(&ssl_ctx_mu_);\n    ssl_ctx = ssl_ctx_;\n  }\n  if (ssl_ctx) {\n    return std::make_unique<SslSocket>(std::move(ssl_ctx), InitialState::Client,\n                                       transport_socket_options, config_->createHandshaker());\n  } else {\n    ENVOY_LOG(debug, \"Create NotReadySslSocket\");\n    stats_.upstream_context_secrets_not_ready_.inc();\n    return std::make_unique<NotReadySslSocket>();\n  }\n}", "target": 1}
{"code": "static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,\n\tstruct user_namespace *user_ns)\n{\n\tmm->mmap = NULL;\n\tmm->mm_rb = RB_ROOT;\n\tmm->vmacache_seqnum = 0;\n\tatomic_set(&mm->mm_users, 1);\n\tatomic_set(&mm->mm_count, 1);\n\tinit_rwsem(&mm->mmap_sem);\n\tINIT_LIST_HEAD(&mm->mmlist);\n\tmm->core_state = NULL;\n\tatomic_long_set(&mm->nr_ptes, 0);\n\tmm_nr_pmds_init(mm);\n\tmm->map_count = 0;\n\tmm->locked_vm = 0;\n\tmm->pinned_vm = 0;\n\tmemset(&mm->rss_stat, 0, sizeof(mm->rss_stat));\n\tspin_lock_init(&mm->page_table_lock);\n\tmm_init_cpumask(mm);\n\tmm_init_aio(mm);\n\tmm_init_owner(mm, p);\n\tRCU_INIT_POINTER(mm->exe_file, NULL);\n\tmmu_notifier_mm_init(mm);\n\tinit_tlb_flush_pending(mm);\n#if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS\n\tmm->pmd_huge_pte = NULL;\n#endif\n\tif (current->mm) {\n\t\tmm->flags = current->mm->flags & MMF_INIT_MASK;\n\t\tmm->def_flags = current->mm->def_flags & VM_INIT_DEF_MASK;\n\t} else {\n\t\tmm->flags = default_dump_filter;\n\t\tmm->def_flags = 0;\n\t}\n\tif (mm_alloc_pgd(mm))\n\t\tgoto fail_nopgd;\n\tif (init_new_context(p, mm))\n\t\tgoto fail_nocontext;\n\tmm->user_ns = get_user_ns(user_ns);\n\treturn mm;\nfail_nocontext:\n\tmm_free_pgd(mm);\nfail_nopgd:\n\tfree_mm(mm);\n\treturn NULL;\n}", "target": 0}
{"code": "gx_dc_pattern2_clip_with_bbox_simple(const gx_device_color * pdevc, gx_device * pdev,\n                              gx_clip_path *cpath_local)\n{\n    int code = 0;\n    if (gx_dc_is_pattern2_color(pdevc) && gx_dc_pattern2_color_has_bbox(pdevc) &&\n            (*dev_proc(pdev, dev_spec_op))(pdev, gxdso_pattern_shading_area, NULL, 0) == 0) {\n        gs_pattern2_instance_t *pinst = (gs_pattern2_instance_t *)pdevc->ccolor.pattern;\n        gx_path box_path;\n        gs_memory_t *mem = cpath_local->path.memory;\n        gx_path_init_local(&box_path, mem);\n        code = gx_dc_shading_path_add_box(&box_path, pdevc);\n        if (code == gs_error_limitcheck) {\n            code = 0;\n        } else if (code >= 0) {\n            code = gx_cpath_intersect(cpath_local, &box_path, gx_rule_winding_number, (gs_gstate *)pinst->saved);\n        }\n        gx_path_free(&box_path, \"gx_default_fill_path(path_bbox)\");\n    }\n    return code;\n}", "target": 0}
{"code": "AnyP::UriScheme::defaultPort() const\n{\n    switch (theScheme_) {\n    case AnyP::PROTO_HTTP:\n        return 80;\n    case AnyP::PROTO_HTTPS:\n        return 443;\n    case AnyP::PROTO_FTP:\n        return 21;\n    case AnyP::PROTO_COAP:\n    case AnyP::PROTO_COAPS:\n        return 5683;\n    case AnyP::PROTO_GOPHER:\n        return 70;\n    case AnyP::PROTO_WAIS:\n        return 210;\n    case AnyP::PROTO_CACHE_OBJECT:\n        return CACHE_HTTP_PORT;\n    case AnyP::PROTO_WHOIS:\n        return 43;\n    default:\n        return 0;\n    }\n}", "target": 1}
{"code": "static int sco_sock_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t    size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tint err;\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\terr = sock_error(sk);\n\tif (err)\n\t\treturn err;\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\tlock_sock(sk);\n\tif (sk->sk_state == BT_CONNECTED)\n\t\terr = sco_send_frame(sk, msg, len);\n\telse\n\t\terr = -ENOTCONN;\n\trelease_sock(sk);\n\treturn err;\n}", "target": 1}
{"code": "mm_make_entry(struct mm_master *mm, struct mmtree *head,\n    void *address, size_t size)\n{\n\tstruct mm_share *tmp, *tmp2;\n\tif (mm->mmalloc == NULL)\n\t\ttmp = xcalloc(1, sizeof(struct mm_share));\n\telse\n\t\ttmp = mm_xmalloc(mm->mmalloc, sizeof(struct mm_share));\n\ttmp->address = address;\n\ttmp->size = size;\n\ttmp2 = RB_INSERT(mmtree, head, tmp);\n\tif (tmp2 != NULL)\n\t\tfatal(\"mm_make_entry(%p): double address %p->%p(%zu)\",\n\t\t    mm, tmp2, address, size);\n\treturn (tmp);\n}", "target": 1}
{"code": "int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu, struct kvm_run *run)\n{\n\tint ret;\n\tsigset_t sigsaved;\n\tif (unlikely(vcpu->arch.target < 0))\n\t\treturn -ENOEXEC;\n\tret = kvm_vcpu_first_run_init(vcpu);\n\tif (ret)\n\t\treturn ret;\n\tif (run->exit_reason == KVM_EXIT_MMIO) {\n\t\tret = kvm_handle_mmio_return(vcpu, vcpu->run);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (vcpu->sigset_active)\n\t\tsigprocmask(SIG_SETMASK, &vcpu->sigset, &sigsaved);\n\tret = 1;\n\trun->exit_reason = KVM_EXIT_UNKNOWN;\n\twhile (ret > 0) {\n\t\tcond_resched();\n\t\tupdate_vttbr(vcpu->kvm);\n\t\tif (vcpu->arch.pause)\n\t\t\tvcpu_pause(vcpu);\n\t\tkvm_vgic_flush_hwstate(vcpu);\n\t\tkvm_timer_flush_hwstate(vcpu);\n\t\tlocal_irq_disable();\n\t\tif (signal_pending(current)) {\n\t\t\tret = -EINTR;\n\t\t\trun->exit_reason = KVM_EXIT_INTR;\n\t\t}\n\t\tif (ret <= 0 || need_new_vmid_gen(vcpu->kvm)) {\n\t\t\tlocal_irq_enable();\n\t\t\tkvm_timer_sync_hwstate(vcpu);\n\t\t\tkvm_vgic_sync_hwstate(vcpu);\n\t\t\tcontinue;\n\t\t}\n\t\ttrace_kvm_entry(*vcpu_pc(vcpu));\n\t\tkvm_guest_enter();\n\t\tvcpu->mode = IN_GUEST_MODE;\n\t\tret = kvm_call_hyp(__kvm_vcpu_run, vcpu);\n\t\tvcpu->mode = OUTSIDE_GUEST_MODE;\n\t\tvcpu->arch.last_pcpu = smp_processor_id();\n\t\tkvm_guest_exit();\n\t\ttrace_kvm_exit(*vcpu_pc(vcpu));\n\t\tlocal_irq_enable();\n\t\tkvm_timer_sync_hwstate(vcpu);\n\t\tkvm_vgic_sync_hwstate(vcpu);\n\t\tret = handle_exit(vcpu, run, ret);\n\t}\n\tif (vcpu->sigset_active)\n\t\tsigprocmask(SIG_SETMASK, &sigsaved, NULL);\n\treturn ret;\n}", "target": 1}
{"code": "static bool torture_winbind_struct_getpwent(struct torture_context *torture)\n{\n\tstruct winbindd_request req;\n\tstruct winbindd_response rep;\n\tstruct winbindd_pw *pwent;\n\ttorture_comment(torture, \"Running WINBINDD_GETPWENT (struct based)\\n\");\n\ttorture_comment(torture, \" - Running WINBINDD_SETPWENT first\\n\");\n\tZERO_STRUCT(req);\n\tZERO_STRUCT(rep);\n\tDO_STRUCT_REQ_REP(WINBINDD_SETPWENT, &req, &rep);\n\ttorture_comment(torture, \" - Running WINBINDD_GETPWENT now\\n\");\n\tZERO_STRUCT(req);\n\tZERO_STRUCT(rep);\n\treq.data.num_entries = 1;\n\tif (torture_setting_bool(torture, \"samba3\", false)) {\n\t\tDO_STRUCT_REQ_REP_EXT(WINBINDD_GETPWENT, &req, &rep,\n\t\t\t\t      NSS_STATUS_SUCCESS, false, _STRUCT_NOOP,\n\t\t\t\t      NULL);\n\t} else {\n\t\tDO_STRUCT_REQ_REP(WINBINDD_GETPWENT, &req, &rep);\n\t}\n\tpwent = (struct winbindd_pw *)rep.extra_data.data;\n\tif (!torture_setting_bool(torture, \"samba3\", false)) {\n\t\ttorture_assert(torture, (pwent != NULL), \"NULL pwent\");\n\t}\n\tif (pwent) {\n\t\ttorture_comment(torture, \"name: %s, uid: %d, gid: %d, shell: %s\\n\",\n\t\t\t\tpwent->pw_name, pwent->pw_uid, pwent->pw_gid,\n\t\t\t\tpwent->pw_shell);\n\t}\n\treturn true;\n}", "target": 0}
{"code": "inline size_t codepoint_length(const char *s8, size_t l) {\n  if (l) {\n    auto b = static_cast<uint8_t>(s8[0]);\n    if ((b & 0x80) == 0) {\n      return 1;\n    } else if ((b & 0xE0) == 0xC0) {\n      return 2;\n    } else if ((b & 0xF0) == 0xE0) {\n      return 3;\n    } else if ((b & 0xF8) == 0xF0) {\n      return 4;\n    }\n  }\n  return 0;\n}", "target": 1}
{"code": "int crxFreeImageData(CrxImage *img)\n{\n  CrxTile *tile = img->tiles;\n  int nTiles = img->tileRows * img->tileCols;\n  if (img->tiles)\n  {\n    for (int32_t curTile = 0; curTile < nTiles; curTile++, tile++)\n      if (tile[curTile].comps)\n        for (int32_t curPlane = 0; curPlane < img->nPlanes; curPlane++)\n          crxFreeSubbandData(img, tile[curTile].comps + curPlane);\n    free(img->tiles);\n    img->tiles = 0;\n  }\n  if (img->planeBuf)\n  {\n    free(img->planeBuf);\n    img->planeBuf = 0;\n  }\n  return 0;\n}", "target": 1}
{"code": "static pyc_object *get_tuple_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\tn = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (tuple size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic (buffer, n);\n\tif (ret) {\n\t\tret->type = TYPE_TUPLE;\n\t\treturn ret;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static void xfrm6_tunnel_spi_fini(void)\n{\n\tkmem_cache_destroy(xfrm6_tunnel_spi_kmem);\n}", "target": 1}
{"code": "static int update_discovery_filter(struct btd_adapter *adapter)\n{\n\tstruct mgmt_cp_start_service_discovery *sd_cp;\n\tGSList *l;\n\tDBG(\"\");\n\tif (discovery_filter_to_mgmt_cp(adapter, &sd_cp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"discovery_filter_to_mgmt_cp returned error\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (l = adapter->discovery_list; l; l = g_slist_next(l)) {\n\t\tstruct discovery_client *client = l->data;\n\t\tif (!client->discovery_filter)\n\t\t\tcontinue;\n\t\tif (client->discovery_filter->discoverable)\n\t\t\tbreak;\n\t}\n\tset_discovery_discoverable(adapter, l ? true : false);\n\tif (filters_equal(adapter->current_discovery_filter, sd_cp) &&\n\t    adapter->discovering != 0) {\n\t\tDBG(\"filters were equal, deciding to not restart the scan.\");\n\t\tg_free(sd_cp);\n\t\treturn 0;\n\t}\n\tg_free(adapter->current_discovery_filter);\n\tadapter->current_discovery_filter = sd_cp;\n\ttrigger_start_discovery(adapter, 0);\n\treturn -EINPROGRESS;\n}", "target": 1}
{"code": "static int mount_notrunc(const char *source, const char *target,\n\t\t\t const char *filesystemtype, unsigned long mountflags,\n\t\t\t const char *data) {\n\tif (strlen(data) > sysconf(_SC_PAGESIZE) - 1) {\n\t\tfprintf(stderr, \"%s: mount options too long\\n\", progname);\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\treturn mount(source, target, filesystemtype, mountflags, data);\n}", "target": 0}
{"code": "ikev2_gen_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext)\n{\n\tstruct isakmp_gen e;\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tikev2_pay_print(ndo, NPSTR(tpay), e.critical);\n\tND_PRINT((ndo,\" len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 0}
{"code": "static int uas_find_uas_alt_setting(struct usb_interface *intf)\n{\n\tint i;\n\tfor (i = 0; i < intf->num_altsetting; i++) {\n\t\tstruct usb_host_interface *alt = &intf->altsetting[i];\n\t\tif (uas_is_interface(alt))\n\t\t\treturn alt->desc.bAlternateSetting;\n\t}\n\treturn -ENODEV;\n}", "target": 1}
{"code": "static Jsi_RC jsi_ArrayFlatSub(Jsi_Interp *interp, Jsi_Obj* nobj, Jsi_Value *arr, int depth) {\n    int i, n = 0, len = jsi_SizeOfArray(interp, arr->d.obj);\n    if (len <= 0) return JSI_OK;\n    Jsi_RC rc = JSI_OK;\n    int clen = jsi_SizeOfArray(interp, nobj);\n    for (i = 0; i < len && rc == JSI_OK; i++) {\n        Jsi_Value *t = Jsi_ValueArrayIndex(interp, arr, i);\n        if (t && depth>0 && Jsi_ValueIsArray(interp, t))\n            rc = jsi_ArrayFlatSub(interp, nobj, t , depth-1);\n        else if (!Jsi_ValueIsUndef(interp, t))\n            Jsi_ObjArrayAdd(interp, nobj, t);\n        if ((uint)(++n + clen)>interp->maxArrayList)\n            return Jsi_LogError(\"array size exceeded\");\n    }\n    return rc;\n}", "target": 0}
{"code": "TfLiteStatus Gather(const TfLiteGatherParams& params, const TfLiteTensor* input,\n                    const TfLiteTensor* positions, TfLiteTensor* output) {\n  tflite::GatherParams op_params;\n  op_params.axis = params.axis;\n  op_params.batch_dims = params.batch_dims;\n  optimized_ops::Gather(op_params, GetTensorShape(input),\n                        GetTensorData<InputT>(input), GetTensorShape(positions),\n                        GetTensorData<PositionsT>(positions),\n                        GetTensorShape(output), GetTensorData<InputT>(output));\n  return kTfLiteOk;\n}", "target": 1}
{"code": "l_noret luaG_runerror (lua_State *L, const char *fmt, ...) {\n  CallInfo *ci = L->ci;\n  const char *msg;\n  va_list argp;\n  luaC_checkGC(L);  \n  va_start(argp, fmt);\n  msg = luaO_pushvfstring(L, fmt, argp);  \n  va_end(argp);\n  if (isLua(ci))  \n    luaG_addinfo(L, msg, ci_func(ci)->p->source, getcurrentline(ci));\n  luaG_errormsg(L);\n}", "target": 1}
{"code": "static int metachar(char c)\n{\n\treturn (strchr(metachars(), c) != NULL);\n}", "target": 1}
{"code": "mrb_remove_method(mrb_state *mrb, struct RClass *c, mrb_sym mid)\n{\n  mt_tbl *h;\n  MRB_CLASS_ORIGIN(c);\n  h = c->mt;\n  if (h && mt_del(mrb, h, mid)) return;\n  mrb_name_error(mrb, mid, \"method '%n' not defined in %C\", mid, c);\n}", "target": 1}
{"code": "static bool check_reg_sane_offset(struct bpf_verifier_env *env,\n\t\t\t\t  const struct bpf_reg_state *reg,\n\t\t\t\t  enum bpf_reg_type type)\n{\n\tbool known = tnum_is_const(reg->var_off);\n\ts64 val = reg->var_off.value;\n\ts64 smin = reg->smin_value;\n\tif (known && (val >= BPF_MAX_VAR_OFF || val <= -BPF_MAX_VAR_OFF)) {\n\t\tverbose(env, \"math between %s pointer and %lld is not allowed\\n\",\n\t\t\treg_type_str[type], val);\n\t\treturn false;\n\t}\n\tif (reg->off >= BPF_MAX_VAR_OFF || reg->off <= -BPF_MAX_VAR_OFF) {\n\t\tverbose(env, \"%s pointer offset %d is not allowed\\n\",\n\t\t\treg_type_str[type], reg->off);\n\t\treturn false;\n\t}\n\tif (smin == S64_MIN) {\n\t\tverbose(env, \"math between %s pointer and register with unbounded min value is not allowed\\n\",\n\t\t\treg_type_str[type]);\n\t\treturn false;\n\t}\n\tif (smin >= BPF_MAX_VAR_OFF || smin <= -BPF_MAX_VAR_OFF) {\n\t\tverbose(env, \"value %lld makes %s pointer be out of bounds\\n\",\n\t\t\tsmin, reg_type_str[type]);\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 0}
{"code": "      DSA_Verification_Operation(const DSA_PublicKey& dsa,\n                                 const std::string& emsa) :\n         PK_Ops::Verification_with_EMSA(emsa),\n         m_group(dsa.get_group()),\n         m_y(dsa.get_y()),\n         m_mod_q(dsa.group_q())\n         {}", "target": 1}
{"code": "static void ClearMetadata(VP8LMetadata* const hdr) {\n  assert(hdr != NULL);\n  WebPSafeFree(hdr->huffman_image_);\n  WebPSafeFree(hdr->huffman_tables_);\n  VP8LHtreeGroupsFree(hdr->htree_groups_);\n  VP8LColorCacheClear(&hdr->color_cache_);\n  VP8LColorCacheClear(&hdr->saved_color_cache_);\n  InitMetadata(hdr);\n}", "target": 1}
{"code": "void hrandfieldCommand(client *c) {\n    long l;\n    int withvalues = 0;\n    robj *hash;\n    listpackEntry ele;\n    if (c->argc >= 3) {\n        if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL) != C_OK) return;\n        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withvalues\"))) {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        } else if (c->argc == 4) {\n            withvalues = 1;\n            if (l < -LONG_MAX/2 || l > LONG_MAX/2) {\n                addReplyError(c,\"value is out of range\");\n                return;\n            }\n        }\n        hrandfieldWithCountCommand(c, l, withvalues);\n        return;\n    }\n    if ((hash = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL ||\n        checkType(c,hash,OBJ_HASH)) {\n        return;\n    }\n    hashTypeRandomElement(hash,hashTypeLength(hash),&ele,NULL);\n    hashReplyFromListpackEntry(c, &ele);\n}", "target": 0}
{"code": "clientHierarchical(ClientHttpRequest * http)\n{\n    HttpRequest *request = http->request;\n    HttpRequestMethod method = request->method;\n    if (!request->flags.hostVerified && (request->flags.intercepted || request->flags.interceptTproxy))\n        return 0;\n    if (request->flags.ims && !neighbors_do_private_keys)\n        return 0;\n    if (request->flags.auth)\n        return 0;\n    if (method == Http::METHOD_TRACE)\n        return 1;\n    if (method != Http::METHOD_GET)\n        return 0;\n    if (request->flags.loopDetected)\n        return 0;\n    if (request->url.getScheme() == AnyP::PROTO_HTTP)\n        return method.respMaybeCacheable();\n    if (request->url.getScheme() == AnyP::PROTO_GOPHER)\n        return gopherCachable(request);\n    if (request->url.getScheme() == AnyP::PROTO_CACHE_OBJECT)\n        return 0;\n    return 1;\n}", "target": 1}
{"code": "static int async_polkit_callback(sd_bus_message *reply, void *userdata, sd_bus_error *error) {\n        _cleanup_(sd_bus_error_free) sd_bus_error error_buffer = SD_BUS_ERROR_NULL;\n        AsyncPolkitQuery *q = userdata;\n        int r;\n        assert(reply);\n        assert(q);\n        assert(q->slot);\n        q->slot = sd_bus_slot_unref(q->slot);\n        assert(!q->reply);\n        q->reply = sd_bus_message_ref(reply);\n        assert(!q->defer_event_source);\n        r = sd_event_add_defer(sd_bus_get_event(sd_bus_message_get_bus(reply)), &q->defer_event_source, async_polkit_defer, q);\n        if (r < 0)\n                goto fail;\n        r = sd_event_source_set_priority(q->defer_event_source, SD_EVENT_PRIORITY_IDLE);\n        if (r < 0)\n                goto fail;\n        r = sd_event_source_set_enabled(q->defer_event_source, SD_EVENT_ONESHOT);\n        if (r < 0)\n                goto fail;\n        r = sd_bus_message_rewind(q->request, true);\n        if (r < 0)\n                goto fail;\n        r = sd_bus_enqueue_for_read(sd_bus_message_get_bus(q->request), q->request);\n        if (r < 0)\n                goto fail;\n        return 1;\nfail:\n        log_debug_errno(r, \"Processing asynchronous PolicyKit reply failed, ignoring: %m\");\n        (void) sd_bus_reply_method_errno(q->request, r, NULL);\n        async_polkit_query_free(q);\n        return r;\n}", "target": 0}
{"code": "mrb_realloc(mrb_state *mrb, void *p, size_t len)\n{\n  void *p2;\n  p2 = mrb_realloc_simple(mrb, p, len);\n  if (len == 0) return p2;\n  if (p2 == NULL) {\n    mrb_free(mrb, p);\n    mrb->gc.out_of_memory = TRUE;\n    mrb_raise_nomemory(mrb);\n  }\n  else {\n    mrb->gc.out_of_memory = FALSE;\n  }\n  return p2;\n}", "target": 1}
{"code": "static int mpls_dev_sysctl_register(struct net_device *dev,\n\t\t\t\t    struct mpls_dev *mdev)\n{\n\tchar path[sizeof(\"net/mpls/conf/\") + IFNAMSIZ];\n\tstruct net *net = dev_net(dev);\n\tstruct ctl_table *table;\n\tint i;\n\ttable = kmemdup(&mpls_dev_table, sizeof(mpls_dev_table), GFP_KERNEL);\n\tif (!table)\n\t\tgoto out;\n\tfor (i = 0; i < ARRAY_SIZE(mpls_dev_table); i++) {\n\t\ttable[i].data = (char *)mdev + (uintptr_t)table[i].data;\n\t\ttable[i].extra1 = mdev;\n\t\ttable[i].extra2 = net;\n\t}\n\tsnprintf(path, sizeof(path), \"net/mpls/conf/%s\", dev->name);\n\tmdev->sysctl = register_net_sysctl(net, path, table);\n\tif (!mdev->sysctl)\n\t\tgoto free;\n\tmpls_netconf_notify_devconf(net, RTM_NEWNETCONF, NETCONFA_ALL, mdev);\n\treturn 0;\nfree:\n\tkfree(table);\nout:\n\tmdev->sysctl = NULL;\n\treturn -ENOBUFS;\n}", "target": 0}
{"code": "uint64_t siphash_nocase(const uint8_t *in, const size_t inlen, const uint8_t *k)\n{\n    uint64_t hash;\n    uint8_t *out = (uint8_t*) &hash;\n    uint64_t v0 = 0x736f6d6570736575ULL;\n    uint64_t v1 = 0x646f72616e646f6dULL;\n    uint64_t v2 = 0x6c7967656e657261ULL;\n    uint64_t v3 = 0x7465646279746573ULL;\n    uint64_t k0 = U8TO64_LE(k);\n    uint64_t k1 = U8TO64_LE(k + 8);\n    uint64_t m;\n    const uint8_t *end = in + inlen - (inlen % sizeof(uint64_t));\n    const int left = inlen & 7;\n    uint64_t b = ((uint64_t)inlen) << 56;\n    v3 ^= k1;\n    v2 ^= k0;\n    v1 ^= k1;\n    v0 ^= k0;\n    for (; in != end; in += 8) {\n        m = U8TO64_LE_NOCASE(in);\n        v3 ^= m;\n        SIPROUND;\n        SIPROUND;\n        v0 ^= m;\n    }\n    switch (left) {\n    case 7: b |= ((uint64_t)tolower(in[6])) << 48;\n    case 6: b |= ((uint64_t)tolower(in[5])) << 40;\n    case 5: b |= ((uint64_t)tolower(in[4])) << 32;\n    case 4: b |= ((uint64_t)tolower(in[3])) << 24;\n    case 3: b |= ((uint64_t)tolower(in[2])) << 16;\n    case 2: b |= ((uint64_t)tolower(in[1])) << 8;\n    case 1: b |= ((uint64_t)tolower(in[0])); break;\n    case 0: break;\n    }\n    v3 ^= b;\n    SIPROUND;\n    SIPROUND;\n    v0 ^= b;\n    v2 ^= 0xff;\n    SIPROUND;\n    SIPROUND;\n    SIPROUND;\n    SIPROUND;\n    b = v0 ^ v1 ^ v2 ^ v3;\n    U64TO8_LE(out, b);\n    return hash;\n}", "target": 0}
{"code": "static avifBool avifParseImageGridBox(avifImageGrid * grid, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n    uint8_t version, flags;\n    CHECK(avifROStreamRead(&s, &version, 1)); \n    if (version != 0) {\n        return AVIF_FALSE;\n    }\n    CHECK(avifROStreamRead(&s, &flags, 1));         \n    CHECK(avifROStreamRead(&s, &grid->rows, 1));    \n    CHECK(avifROStreamRead(&s, &grid->columns, 1)); \n    ++grid->rows;\n    ++grid->columns;\n    uint32_t fieldLength = ((flags & 1) + 1) * 16;\n    if (fieldLength == 16) {\n        uint16_t outputWidth16, outputHeight16;\n        CHECK(avifROStreamReadU16(&s, &outputWidth16));  \n        CHECK(avifROStreamReadU16(&s, &outputHeight16)); \n        grid->outputWidth = outputWidth16;\n        grid->outputHeight = outputHeight16;\n    } else {\n        if (fieldLength != 32) {\n            return AVIF_FALSE;\n        }\n        CHECK(avifROStreamReadU32(&s, &grid->outputWidth));  \n        CHECK(avifROStreamReadU32(&s, &grid->outputHeight)); \n    }\n    if (grid->outputWidth > AVIF_MAX_IMAGE_SIZE / grid->outputHeight) {\n        return AVIF_FALSE;\n    }\n    return AVIF_TRUE;\n}", "target": 0}
{"code": "int page_name_is_good(char* page_name)\n{\n    if (!page_name)\n        return FALSE;\n    if (!isalnum(page[0]))\n        return FALSE;\n    if (strstr(page, \"..\"))\n        return FALSE;\n    return TRUE;\n}", "target": 0}
{"code": "get_supported_image_extensions(void)\n{\n\tGSList *extensions = NULL;\n\tGSList *formats = gdk_pixbuf_get_formats ();\n\tGSList *l;\n\tfor (l = formats; l != NULL; l = l->next) {\n\t\tint i;\n\t\tgchar **ext = gdk_pixbuf_format_get_extensions (l->data);\n\t\tfor (i = 0; ext[i] != NULL; i++) {\n\t\t\textensions = g_slist_append (extensions,\n\t\t\t\t\t\t     g_strdup (ext[i]));\n\t\t}\n\t\tg_strfreev (ext);\n\t}\n\tg_slist_free (formats);\n\treturn extensions;\n}", "target": 1}
{"code": "static inline bool unconditional(const struct ip6t_ip6 *ipv6)\n{\n\tstatic const struct ip6t_ip6 uncond;\n\treturn memcmp(ipv6, &uncond, sizeof(uncond)) == 0;\n}", "target": 1}
{"code": "void CefLayeredWindowUpdaterOSR::OnAllocatedSharedMemory(\n    const gfx::Size& pixel_size,\n    base::UnsafeSharedMemoryRegion region) {\n  size_t expected_bytes;\n  bool size_result = viz::ResourceSizes::MaybeSizeInBytes(\n      pixel_size, viz::SinglePlaneFormat::kRGBA_8888, &expected_bytes);\n  if (!size_result) {\n    return;\n  }\n  pixel_size_ = pixel_size;\n  shared_memory_ = region.Map();\n  DCHECK(shared_memory_.IsValid());\n}", "target": 1}
{"code": "static int gup_huge_pgd(pgd_t orig, pgd_t *pgdp, unsigned long addr,\n\t\t\tunsigned long end, int write,\n\t\t\tstruct page **pages, int *nr)\n{\n\tint refs;\n\tstruct page *head, *page;\n\tif (!pgd_access_permitted(orig, write))\n\t\treturn 0;\n\tBUILD_BUG_ON(pgd_devmap(orig));\n\trefs = 0;\n\tpage = pgd_page(orig) + ((addr & ~PGDIR_MASK) >> PAGE_SHIFT);\n\tdo {\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t\tpage++;\n\t\trefs++;\n\t} while (addr += PAGE_SIZE, addr != end);\n\thead = compound_head(pgd_page(orig));\n\tif (!page_cache_add_speculative(head, refs)) {\n\t\t*nr -= refs;\n\t\treturn 0;\n\t}\n\tif (unlikely(pgd_val(orig) != pgd_val(*pgdp))) {\n\t\t*nr -= refs;\n\t\twhile (refs--)\n\t\t\tput_page(head);\n\t\treturn 0;\n\t}\n\tSetPageReferenced(head);\n\treturn 1;\n}", "target": 1}
{"code": "static void edge_bulk_in_callback(struct urb *urb)\n{\n\tstruct edgeport_port *edge_port = urb->context;\n\tstruct device *dev = &edge_port->port->dev;\n\tunsigned char *data = urb->transfer_buffer;\n\tint retval = 0;\n\tint port_number;\n\tint status = urb->status;\n\tswitch (status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\tdev_dbg(&urb->dev->dev, \"%s - urb shutting down with status: %d\\n\", __func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_err(&urb->dev->dev, \"%s - nonzero read bulk status received: %d\\n\", __func__, status);\n\t}\n\tif (status == -EPIPE)\n\t\tgoto exit;\n\tif (status) {\n\t\tdev_err(&urb->dev->dev, \"%s - stopping read!\\n\", __func__);\n\t\treturn;\n\t}\n\tport_number = edge_port->port->port_number;\n\tif (edge_port->lsr_event) {\n\t\tedge_port->lsr_event = 0;\n\t\tdev_dbg(dev, \"%s ===== Port %u LSR Status = %02x, Data = %02x ======\\n\",\n\t\t\t__func__, port_number, edge_port->lsr_mask, *data);\n\t\thandle_new_lsr(edge_port, 1, edge_port->lsr_mask, *data);\n\t\t--urb->actual_length;\n\t\t++data;\n\t}\n\tif (urb->actual_length) {\n\t\tusb_serial_debug_data(dev, __func__, urb->actual_length, data);\n\t\tif (edge_port->close_pending)\n\t\t\tdev_dbg(dev, \"%s - close pending, dropping data on the floor\\n\",\n\t\t\t\t\t\t\t\t__func__);\n\t\telse\n\t\t\tedge_tty_recv(edge_port->port, data,\n\t\t\t\t\turb->actual_length);\n\t\tedge_port->port->icount.rx += urb->actual_length;\n\t}\nexit:\n\tspin_lock(&edge_port->ep_lock);\n\tif (edge_port->ep_read_urb_state == EDGE_READ_URB_RUNNING)\n\t\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\telse if (edge_port->ep_read_urb_state == EDGE_READ_URB_STOPPING)\n\t\tedge_port->ep_read_urb_state = EDGE_READ_URB_STOPPED;\n\tspin_unlock(&edge_port->ep_lock);\n\tif (retval)\n\t\tdev_err(dev, \"%s - usb_submit_urb failed with result %d\\n\", __func__, retval);\n}", "target": 1}
{"code": "ff_layout_encode_layoutreturn(struct xdr_stream *xdr,\n\t\tconst void *voidargs,\n\t\tconst struct nfs4_xdr_opaque_data *ff_opaque)\n{\n\tconst struct nfs4_layoutreturn_args *args = voidargs;\n\tstruct nfs4_flexfile_layoutreturn_args *ff_args = ff_opaque->data;\n\tstruct xdr_buf tmp_buf = {\n\t\t.head = {\n\t\t\t[0] = {\n\t\t\t\t.iov_base = page_address(ff_args->pages[0]),\n\t\t\t},\n\t\t},\n\t\t.buflen = PAGE_SIZE,\n\t};\n\tstruct xdr_stream tmp_xdr;\n\t__be32 *start;\n\tdprintk(\"%s: Begin\\n\", __func__);\n\txdr_init_encode(&tmp_xdr, &tmp_buf, NULL, NULL);\n\tff_layout_encode_ioerr(&tmp_xdr, args, ff_args);\n\tff_layout_encode_iostats_array(&tmp_xdr, args, ff_args);\n\tstart = xdr_reserve_space(xdr, 4);\n\t*start = cpu_to_be32(tmp_buf.len);\n\txdr_write_pages(xdr, ff_args->pages, 0, tmp_buf.len);\n\tdprintk(\"%s: Return\\n\", __func__);\n}", "target": 0}
{"code": "static int lsm_openat(int procfd, pid_t pid, int on_exec)\n{\n\tint ret = -1;\n\tint labelfd = -1;\n\tconst char* name;\n#define __LSMATTRLEN  (5 +  21 +  7 +  1)\n\tchar path[__LSMATTRLEN];\n\tname = lsm_name();\n\tif (strcmp(name, \"nop\") == 0)\n\t\treturn 0;\n\tif (strcmp(name, \"none\") == 0)\n\t\treturn 0;\n\tif (strcmp(name, \"AppArmor\") == 0)\n\t\ton_exec = 0;\n\tif (on_exec) {\n\t\tret = snprintf(path, __LSMATTRLEN, \"%d/attr/exec\", pid);\n\t\tif (ret < 0 || ret >= __LSMATTRLEN)\n\t\t\treturn -1;\n\t\tlabelfd = openat(procfd, path, O_RDWR);\n\t} else {\n\t\tret = snprintf(path, __LSMATTRLEN, \"%d/attr/current\", pid);\n\t\tif (ret < 0 || ret >= __LSMATTRLEN)\n\t\t\treturn -1;\n\t\tlabelfd = openat(procfd, path, O_RDWR);\n\t}\n\tif (labelfd < 0) {\n\t\tSYSERROR(\"Unable to open LSM label\");\n\t\treturn -1;\n\t}\n\treturn labelfd;\n}", "target": 0}
{"code": "compute_O_value(std::string const& user_password,\n\t\tstd::string const& owner_password,\n\t\tQPDF::EncryptionData const& data)\n{\n    unsigned char O_key[OU_key_bytes_V4];\n    compute_O_rc4_key(user_password, owner_password, data, O_key);\n    char upass[key_bytes];\n    pad_or_truncate_password_V4(user_password, upass);\n    std::string k1(reinterpret_cast<char*>(O_key), OU_key_bytes_V4);\n    pad_short_parameter(k1, data.getLengthBytes());\n    iterate_rc4(QUtil::unsigned_char_pointer(upass), key_bytes,\n\t\tO_key, data.getLengthBytes(),\n                (data.getR() >= 3) ? 20 : 1, false);\n    return std::string(upass, key_bytes);\n}", "target": 0}
{"code": "void preproc_mount_mnt_dir(void) {\n\tif (!tmpfs_mounted) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on %s directory\\n\", RUN_MNT_DIR);\n\t\tif (mount(\"tmpfs\", RUN_MNT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /run/firejail/mnt\");\n\t\ttmpfs_mounted = 1;\n\t\tfs_logger2(\"tmpfs\", RUN_MNT_DIR);\n#ifdef HAVE_SECCOMP\n\t\tcreate_empty_dir_as_root(RUN_SECCOMP_DIR, 0755);\n\t\tif (arg_seccomp_block_secondary)\n\t\t\tcopy_file(PATH_SECCOMP_BLOCK_SECONDARY, RUN_SECCOMP_BLOCK_SECONDARY, getuid(), getgid(), 0644); \n\t\telse {\n\t\t\tcopy_file(PATH_SECCOMP_32, RUN_SECCOMP_32, getuid(), getgid(), 0644); \n\t\t}\n\t\tif (arg_allow_debuggers)\n\t\t\tcopy_file(PATH_SECCOMP_DEFAULT_DEBUG, RUN_SECCOMP_CFG, getuid(), getgid(), 0644); \n\t\telse\n\t\t\tcopy_file(PATH_SECCOMP_DEFAULT, RUN_SECCOMP_CFG, getuid(), getgid(), 0644); \n\t\tif (arg_memory_deny_write_execute)\n\t\t\tcopy_file(PATH_SECCOMP_MDWX, RUN_SECCOMP_MDWX, getuid(), getgid(), 0644); \n\t\tcreate_empty_file_as_root(RUN_SECCOMP_PROTOCOL, 0644);\n\t\tif (set_perms(RUN_SECCOMP_PROTOCOL, getuid(), getgid(), 0644))\n\t\t\terrExit(\"set_perms\");\n\t\tcreate_empty_file_as_root(RUN_SECCOMP_POSTEXEC, 0644);\n\t\tif (set_perms(RUN_SECCOMP_POSTEXEC, getuid(), getgid(), 0644))\n\t\t\terrExit(\"set_perms\");\n#endif\n\t}\n}", "target": 0}
{"code": "void nego_process_negotiation_request(rdpNego* nego, wStream* s)\n{\n\tBYTE flags;\n\tUINT16 length;\n\tStream_Read_UINT8(s, flags);\n\tStream_Read_UINT16(s, length);\n\tStream_Read_UINT32(s, nego->RequestedProtocols);\n\tWLog_DBG(TAG, \"RDP_NEG_REQ: RequestedProtocol: 0x%08\" PRIX32 \"\", nego->RequestedProtocols);\n\tnego->state = NEGO_STATE_FINAL;\n}", "target": 1}
{"code": "static void mbochs_remove(struct mdev_device *mdev)\n{\n\tstruct mdev_state *mdev_state = dev_get_drvdata(&mdev->dev);\n\tmbochs_used_mbytes -= mdev_state->type->mbytes;\n\tvfio_unregister_group_dev(&mdev_state->vdev);\n\tkfree(mdev_state->pages);\n\tkfree(mdev_state->vconfig);\n\tkfree(mdev_state);\n}", "target": 1}
{"code": "static inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_esn,\n\t\t\t\t\t struct nlattr *rp)\n{\n\tstruct xfrm_replay_state_esn *up;\n\tint ulen;\n\tif (!replay_esn || !rp)\n\t\treturn 0;\n\tup = nla_data(rp);\n\tulen = xfrm_replay_state_esn_len(up);\n\tif (nla_len(rp) < ulen ||\n\t    xfrm_replay_state_esn_len(replay_esn) != ulen ||\n\t    replay_esn->bmp_len != up->bmp_len)\n\t\treturn -EINVAL;\n\tif (up->replay_window > up->bmp_len * sizeof(__u32) * 8)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 0}
{"code": "RestAuthHandler::RestAuthHandler(application_features::ApplicationServer& server,\n                                 GeneralRequest* request, GeneralResponse* response)\n    : RestVocbaseBaseHandler(server, request, response),\n      _validFor(60 * 60 * 24 * 30) {}", "target": 1}
{"code": "static int __ext4_expand_extra_isize(struct inode *inode,\n\t\t\t\t     unsigned int new_extra_isize,\n\t\t\t\t     struct ext4_iloc *iloc,\n\t\t\t\t     handle_t *handle, int *no_expand)\n{\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_xattr_ibody_header *header;\n\tunsigned int inode_size = EXT4_INODE_SIZE(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tint error;\n\tif ((EXT4_GOOD_OLD_INODE_SIZE + ei->i_extra_isize > inode_size) ||\n\t    (ei->i_extra_isize & 3)) {\n\t\tEXT4_ERROR_INODE(inode, \"bad extra_isize %u (inode size %u)\",\n\t\t\t\t ei->i_extra_isize,\n\t\t\t\t EXT4_INODE_SIZE(inode->i_sb));\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif ((new_extra_isize < ei->i_extra_isize) ||\n\t    (new_extra_isize < 4) ||\n\t    (new_extra_isize > inode_size - EXT4_GOOD_OLD_INODE_SIZE))\n\t\treturn -EINVAL;\t\n\traw_inode = ext4_raw_inode(iloc);\n\theader = IHDR(inode, raw_inode);\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR) ||\n\t    header->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC)) {\n\t\tmemset((void *)raw_inode + EXT4_GOOD_OLD_INODE_SIZE +\n\t\t       EXT4_I(inode)->i_extra_isize, 0,\n\t\t       new_extra_isize - EXT4_I(inode)->i_extra_isize);\n\t\tEXT4_I(inode)->i_extra_isize = new_extra_isize;\n\t\treturn 0;\n\t}\n\terror = ext4_expand_extra_isize_ea(inode, new_extra_isize,\n\t\t\t\t\t   raw_inode, handle);\n\tif (error) {\n\t\t*no_expand = 1;\n\t}\n\treturn error;\n}", "target": 0}
{"code": "static inline long div_long_long_rem_signed(const long long dividend,\n\t\t\t\t\t    const long divisor, long *remainder)\n{\n\tlong res;\n\tif (unlikely(dividend < 0)) {\n\t\tres = -div_long_long_rem(-dividend, divisor, remainder);\n\t\t*remainder = -(*remainder);\n\t} else\n\t\tres = div_long_long_rem(dividend, divisor, remainder);\n\treturn res;\n}", "target": 1}
{"code": "void init_xml_relax_ng()\n{\n  VALUE nokogiri = rb_define_module(\"Nokogiri\");\n  VALUE xml = rb_define_module_under(nokogiri, \"XML\");\n  VALUE klass = rb_define_class_under(xml, \"RelaxNG\", cNokogiriXmlSchema);\n  cNokogiriXmlRelaxNG = klass;\n  rb_define_singleton_method(klass, \"read_memory\", read_memory, 1);\n  rb_define_singleton_method(klass, \"from_document\", from_document, 1);\n  rb_define_private_method(klass, \"validate_document\", validate_document, 1);\n}", "target": 1}
{"code": "BuildSendAndCloseSoapResp(struct upnphttp * h,\n                          const char * body, int bodylen)\n{\n\tstatic const char beforebody[] =\n\t\t\"<?xml version=\\\"1.0\\\"?>\\r\\n\"\n\t\t\"<s:Envelope xmlns:s=\\\"http:\n\t\t\"s:encodingStyle=\\\"http:\n\t\t\"<s:Body>\";\n\tstatic const char afterbody[] =\n\t\t\"</s:Body>\"\n\t\t\"</s:Envelope>\\r\\n\";\n\tint r = BuildHeader_upnphttp(h, 200, \"OK\",  sizeof(beforebody) - 1\n\t                             + sizeof(afterbody) - 1 + bodylen );\n\tif(r >= 0) {\n\t\tmemcpy(h->res_buf + h->res_buflen, beforebody, sizeof(beforebody) - 1);\n\t\th->res_buflen += sizeof(beforebody) - 1;\n\t\tmemcpy(h->res_buf + h->res_buflen, body, bodylen);\n\t\th->res_buflen += bodylen;\n\t\tmemcpy(h->res_buf + h->res_buflen, afterbody, sizeof(afterbody) - 1);\n\t\th->res_buflen += sizeof(afterbody) - 1;\n\t} else {\n\t\tBuildResp2_upnphttp(h, 500, \"Internal Server Error\", NULL, 0);\n\t}\n\tSendRespAndClose_upnphttp(h);\n}", "target": 0}
{"code": "static int sco_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sco_pinfo *pi = sco_pi(sk);\n\tlock_sock(sk);\n\tif (sk->sk_state == BT_CONNECT2 &&\n\t    test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {\n\t\tsco_conn_defer_accept(pi->conn->hcon, pi->setting);\n\t\tsk->sk_state = BT_CONFIG;\n\t\tmsg->msg_namelen = 0;\n\t\trelease_sock(sk);\n\t\treturn 0;\n\t}\n\trelease_sock(sk);\n\treturn bt_sock_recvmsg(iocb, sock, msg, len, flags);\n}", "target": 1}
{"code": "IOBasicTypes::LongFilePositionType ObjectByteWriterWithPosition::GetCurrentPosition()\n{\n\tCREATE_ISOLATE_CONTEXT;\n\tCREATE_ESCAPABLE_SCOPE;\n\tLocal<Value> value = OBJECT_FROM_PERSISTENT(mObject)->Get(GET_CURRENT_CONTEXT, NEW_STRING(\"getCurrentPosition\")).ToLocalChecked();\n    if(value->IsUndefined())\n        return true;\n    Local<Function> func = Local<Function>::Cast(value);\n\treturn TO_NUMBER(func->Call(GET_CURRENT_CONTEXT, OBJECT_FROM_PERSISTENT(mObject), 0, NULL).ToLocalChecked())->Value();\n}", "target": 1}
{"code": "TfLiteStatus ResizeOutputTensor(TfLiteContext* context,\n                                SpaceToBatchNDContext* op_context) {\n  TfLiteIntArray* input_size = op_context->input->dims;\n  const int32* block_shape = GetTensorData<int32>(op_context->block_shape);\n  const int32* paddings_data = GetTensorData<int32>(op_context->paddings);\n  int spatial_dims_num = input_size->size - 2;\n  TF_LITE_ENSURE_EQ(context, NumDimensions(op_context->block_shape), 1);\n  TF_LITE_ENSURE_EQ(context, op_context->block_shape->dims->data[0],\n                    spatial_dims_num);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(op_context->paddings), 2);\n  TF_LITE_ENSURE_EQ(context, op_context->paddings->dims->data[0],\n                    spatial_dims_num);\n  TF_LITE_ENSURE_EQ(context, op_context->paddings->dims->data[1], 2);\n  TfLiteIntArray* output_size = TfLiteIntArrayCopy(input_size);\n  int output_batch_size = input_size->data[0];\n  for (int dim = 0; dim < spatial_dims_num; ++dim) {\n    int final_dim_size = (input_size->data[dim + 1] + paddings_data[dim * 2] +\n                          paddings_data[dim * 2 + 1]);\n    TF_LITE_ENSURE(context, block_shape[dim] != 0);\n    TF_LITE_ENSURE_EQ(context, final_dim_size % block_shape[dim], 0);\n    output_size->data[dim + 1] = final_dim_size / block_shape[dim];\n    output_batch_size *= block_shape[dim];\n  }\n  output_size->data[0] = output_batch_size;\n  output_size->data[input_size->size - 1] =\n      input_size->data[input_size->size - 1];\n  return context->ResizeTensor(context, op_context->output, output_size);\n}", "target": 0}
{"code": "TfLiteStatus EvalHashtableSize(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputResourceIdTensor);\n  int resource_id = input_resource_id_tensor->data.i32[0];\n  TfLiteTensor* output_tensor = GetOutput(context, node, kOutputTensor);\n  auto* output_data = GetTensorData<std::int64_t>(output_tensor);\n  Subgraph* subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n  auto& resources = subgraph->resources();\n  auto* lookup = resource::GetHashtableResource(&resources, resource_id);\n  TF_LITE_ENSURE(context, lookup != nullptr);\n  output_data[0] = lookup->Size();\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static void O_getOwnPropertyDescriptor(js_State *J)\n{\n\tjs_Object *obj;\n\tjs_Property *ref;\n\tif (!js_isobject(J, 1))\n\t\tjs_typeerror(J, \"not an object\");\n\tobj = js_toobject(J, 1);\n\tref = jsV_getproperty(J, obj, js_tostring(J, 2));\n\tif (!ref) {\n\t\tjs_pushundefined(J);\n\t} else {\n\t\tjs_newobject(J);\n\t\tif (!ref->getter && !ref->setter) {\n\t\t\tjs_pushvalue(J, ref->value);\n\t\t\tjs_setproperty(J, -2, \"value\");\n\t\t\tjs_pushboolean(J, !(ref->atts & JS_READONLY));\n\t\t\tjs_setproperty(J, -2, \"writable\");\n\t\t} else {\n\t\t\tif (ref->getter)\n\t\t\t\tjs_pushobject(J, ref->getter);\n\t\t\telse\n\t\t\t\tjs_pushundefined(J);\n\t\t\tjs_setproperty(J, -2, \"get\");\n\t\t\tif (ref->setter)\n\t\t\t\tjs_pushobject(J, ref->setter);\n\t\t\telse\n\t\t\t\tjs_pushundefined(J);\n\t\t\tjs_setproperty(J, -2, \"set\");\n\t\t}\n\t\tjs_pushboolean(J, !(ref->atts & JS_DONTENUM));\n\t\tjs_setproperty(J, -2, \"enumerable\");\n\t\tjs_pushboolean(J, !(ref->atts & JS_DONTCONF));\n\t\tjs_setproperty(J, -2, \"configurable\");\n\t}\n}", "target": 1}
{"code": "int main(int argc, char **argv, char **envp)\n{\n#ifdef DYNLOAD\n    if (!uc_dyn_load(NULL, 0)) {\n        printf(\"Error dynamically loading shared library.\\n\");\n        printf(\"Please check that unicorn.dll/unicorn.so is available as well as\\n\");\n        printf(\"any other dependent dll/so files.\\n\");\n        printf(\"The easiest way is to place them in the same directory as this app.\\n\");\n        return 1;\n    }\n#endif\n    test_arm();\n    printf(\"==========================\\n\");\n    test_thumb();\n#ifdef DYNLOAD\n    uc_dyn_free();\n#endif\n    return 0;\n}", "target": 1}
{"code": "ikev2_auth_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct ikev2_auth a;\n\tconst char *v2_auth[]={ \"invalid\", \"rsasig\",\n\t\t\t\t\"shared-secret\", \"dsssig\" };\n\tconst u_char *authdata = (const u_char*)ext + sizeof(a);\n\tunsigned int len;\n\tND_TCHECK2(*ext, sizeof(a));\n\tUNALIGNED_MEMCPY(&a, ext, sizeof(a));\n\tikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);\n\tlen = ntohs(a.h.len);\n\tND_PRINT((ndo,\" len=%u method=%s\", len-4,\n\t\t  STR_OR_ID(a.auth_method, v2_auth)));\n\tif (len > 4) {\n\t\tif (ndo->ndo_vflag > 1) {\n\t\t\tND_PRINT((ndo, \" authdata=(\"));\n\t\t\tif (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))\n\t\t\t\tgoto trunc;\n\t\t\tND_PRINT((ndo, \") \"));\n\t\t} else if (ndo->ndo_vflag) {\n\t\t\tif (!ike_show_somedata(ndo, authdata, ep))\n\t\t\t\tgoto trunc;\n\t\t}\n\t}\n\treturn (const u_char *)ext + len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 0}
{"code": "find_script_callback(char_u *fname, void *cookie)\n{\n    int sid;\n    int error = OK;\n    int *ret_sid = cookie;\n    sid = find_script_by_name(fname);\n    if (sid < 0)\n    {\n\tsid = get_new_scriptitem(&error);\n\tif (error == OK)\n\t{\n\t    scriptitem_T *si = SCRIPT_ITEM(sid);\n\t    si->sn_name = vim_strsave(fname);\n\t    si->sn_state = SN_STATE_NOT_LOADED;\n\t}\n    }\n    *ret_sid = sid;\n}", "target": 0}
{"code": "int mnt_fs_is_deleted(struct libmnt_fs *fs)\n{\n\treturn mnt_fs_get_flags(fs) & MNT_FS_DELETED;\n}", "target": 1}
{"code": "gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\tgss_qop_t qop_req, gss_iov_buffer_desc *iov, int iov_count)\n{\n    OM_uint32 status;\n    gss_union_ctx_id_t ctx;\n    gss_mechanism mech;\n    status = val_wrap_iov_args(minor_status, context_handle, 0, qop_req, NULL,\n\t\t\t       iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn status;\n    ctx = (gss_union_ctx_id_t)context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism(ctx->mech_type);\n    if (mech == NULL)\n\treturn GSS_S_BAD_MECH;\n    if (mech->gss_get_mic_iov == NULL)\n\treturn GSS_S_UNAVAILABLE;\n    status = mech->gss_get_mic_iov(minor_status, ctx->internal_ctx_id, qop_req,\n\t\t\t\t   iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\tmap_error(minor_status, mech);\n    return status;\n}", "target": 0}
{"code": "static void __exit xfrm6_tunnel_fini(void)\n{\n\tunregister_pernet_subsys(&xfrm6_tunnel_net_ops);\n\txfrm6_tunnel_spi_fini();\n\txfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);\n\txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\n\txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\n}", "target": 1}
{"code": "  StringSanMatcher(int general_name_type, envoy::type::matcher::v3::StringMatcher matcher)\n      : general_name_type_(general_name_type), matcher_(matcher) {}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input_sizes = context->input(0);\n    const Tensor& filter = context->input(1);\n    const Tensor& out_backprop = context->input(2);\n    TensorShape input_shape;\n    OP_REQUIRES_OK(context,\n                   Conv2DBackpropComputeInputShape(input_sizes, filter.shape(),\n                                                   out_backprop.shape(),\n                                                   data_format_, &input_shape));\n    Tensor* in_backprop = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input_shape, &in_backprop));\n    if (input_shape.num_elements() == 0) {\n      return;\n    }\n    if (out_backprop.NumElements() == 0) {\n      functor::SetZeroFunctor<Device, T> set_zero;\n      set_zero(context->eigen_device<Device>(),\n               in_backprop->template flat<T>());\n      return;\n    }\n    const int stride_rows = GetTensorDim(strides_, data_format_, 'H');\n    const int stride_cols = GetTensorDim(strides_, data_format_, 'W');\n    const int dilation_rows = GetTensorDim(dilations_, data_format_, 'H');\n    const int dilation_cols = GetTensorDim(dilations_, data_format_, 'W');\n    VLOG(2) << \"Conv2DBackpropInput:\"\n            << \" input: \" << input_shape.DebugString()\n            << \" filter:\" << filter.shape().DebugString()\n            << \" out_backprop: \" << out_backprop.shape().DebugString()\n            << \" strides: [\" << stride_rows << \", \" << stride_cols << \"]\"\n            << \" dilations: [\" << dilation_rows << \", \" << dilation_cols << \"]\";\n    LaunchConv2DBackpropInputOp<Device, T> launch;\n    launch(context, use_cudnn_, cudnn_use_autotune_, out_backprop, filter,\n           dilation_rows, dilation_cols, stride_rows, stride_cols, padding_,\n           explicit_paddings_, in_backprop, data_format_);\n  }", "target": 0}
{"code": "static int smm_stub_place_staggered_entry_points(char *base,\n\tconst struct smm_loader_params *params, const struct rmodule *smm_stub)\n{\n\tsize_t stub_entry_offset;\n\tint rc = 1;\n\tstub_entry_offset = rmodule_entry_offset(smm_stub);\n\tif (params->num_concurrent_save_states > 1 || stub_entry_offset != 0) {\n\t\trc = smm_place_entry_code((unsigned int)base,\n\t\t\tparams->num_concurrent_save_states,\n\t\t\t(unsigned int)params->stack_top, params);\n\t}\n\treturn rc;\n}", "target": 0}
{"code": "static void fuse_lib_init(void *data, struct fuse_conn_info *conn)\n{\n    struct fuse *f = (struct fuse *) data;\n    struct fuse_context_i *c = fuse_get_context_internal();\n    memset(c, 0, sizeof(*c));\n    c->ctx.fuse = f;\n    fuse_fs_init(f->fs, conn);\n}", "target": 0}
{"code": "inline void update_rq_clock(struct rq *rq)\n{\n\tif (!rq->skip_clock_update) {\n\t\tint cpu = cpu_of(rq);\n\t\tu64 irq_time;\n\t\trq->clock = sched_clock_cpu(cpu);\n\t\tirq_time = irq_time_cpu(cpu);\n\t\tif (rq->clock - irq_time > rq->clock_task)\n\t\t\trq->clock_task = rq->clock - irq_time;\n\t\tsched_irq_time_avg_update(rq, irq_time);\n\t}\n}", "target": 1}
{"code": "rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tint phy_addr;\n\tstruct netdev_private *np = netdev_priv(dev);\n\tstruct mii_data *miidata = (struct mii_data *) &rq->ifr_ifru;\n\tstruct netdev_desc *desc;\n\tint i;\n\tphy_addr = np->phy_addr;\n\tswitch (cmd) {\n\tcase SIOCDEVPRIVATE:\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 1:\n\t\tmiidata->out_value = mii_read (dev, phy_addr, miidata->reg_num);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 2:\n\t\tmii_write (dev, phy_addr, miidata->reg_num, miidata->in_value);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 3:\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 4:\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 5:\n\t\tnetif_stop_queue (dev);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 6:\n\t\tnetif_wake_queue (dev);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 7:\n\t\tprintk\n\t\t    (\"tx_full=%x cur_tx=%lx old_tx=%lx cur_rx=%lx old_rx=%lx\\n\",\n\t\t     netif_queue_stopped(dev), np->cur_tx, np->old_tx, np->cur_rx,\n\t\t     np->old_rx);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 8:\n\t\tprintk(\"TX ring:\\n\");\n\t\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\t\tdesc = &np->tx_ring[i];\n\t\t\tprintk\n\t\t\t    (\"%02x:cur:%08x next:%08x status:%08x frag1:%08x frag0:%08x\",\n\t\t\t     i,\n\t\t\t     (u32) (np->tx_ring_dma + i * sizeof (*desc)),\n\t\t\t     (u32)le64_to_cpu(desc->next_desc),\n\t\t\t     (u32)le64_to_cpu(desc->status),\n\t\t\t     (u32)(le64_to_cpu(desc->fraginfo) >> 32),\n\t\t\t     (u32)le64_to_cpu(desc->fraginfo));\n\t\t\tprintk (\"\\n\");\n\t\t}\n\t\tprintk (\"\\n\");\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void SFS_Params(ScriptParser *parser)\n{\n\tu32 val;\n\tif (parser->codec->LastError) return;\n\tval = gf_bs_read_int(parser->bs, 1);\n\twhile (val) {\n\t\tSFS_Expression(parser);\n\t\tif (parser->codec->LastError) return;\n\t\tval = gf_bs_read_int(parser->bs, 1);\n\t\tif(val) SFS_AddString(parser, \",\");\n\t}\n}", "target": 0}
{"code": "static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uint32 mode)\n{\n\tM_fs_info_t  *info = NULL;\n\tchar         *pold = NULL;\n\tchar         *pnew = NULL;\n\tM_fs_type_t   type;\n\tM_bool        ret  = M_TRUE;\n\tif (mode & M_FS_FILE_MODE_OVERWRITE)\n\t\treturn M_TRUE;\n\tif (M_fs_info(&info, p1, M_FS_PATH_INFO_FLAGS_BASIC) != M_FS_ERROR_SUCCESS)\n\t\treturn M_FALSE;\n\ttype = M_fs_info_get_type(info);\n\tM_fs_info_destroy(info);\n\tif (type != M_FS_TYPE_DIR) {\n\t\tif (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS)\n\t\t{\n\t\t\tret = M_FALSE;\n\t\t\tgoto done;\n\t\t}\n\t}\n\tpold = M_fs_path_basename(p1, M_FS_SYSTEM_AUTO);\n\tpnew = M_fs_path_join(p2, pnew, M_FS_SYSTEM_AUTO);\n\tif (M_fs_perms_can_access(pnew, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {\n\t\tret = M_FALSE;\n\t\tgoto done;\n\t}\ndone:\n\tM_free(pnew);\n\tM_free(pold);\n\treturn ret;\n}", "target": 1}
{"code": "static DexString *dex_string_new(RzBuffer *buf, ut64 offset, st64 *pread) {\n\tut64 size = 0;\n\tchar *data = NULL;\n\tst64 read;\n\tDexString *string = NULL;\n\tread = rz_buf_uleb128(buf, &size);\n\tif (UT64_ADD_OVFCHK(size, 1)) {\n\t\treturn NULL;\n\t}\n\tdata = malloc(size + 1);\n\tif (!data || rz_buf_read(buf, (ut8 *)data, size) != size) {\n\t\tfree(data);\n\t\treturn NULL;\n\t}\n\tdata[size] = 0;\n\tstring = RZ_NEW0(DexString);\n\tif (!string) {\n\t\tfree(data);\n\t\treturn NULL;\n\t}\n\t*pread = read;\n\tstring->size = size;\n\tstring->offset = offset;\n\tstring->data = data;\n\treturn string;\n}", "target": 0}
{"code": "static ssize_t ppp_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ppp_file *pf = file->private_data;\n\tDECLARE_WAITQUEUE(wait, current);\n\tssize_t ret;\n\tstruct sk_buff *skb = NULL;\n\tstruct iovec iov;\n\tstruct iov_iter to;\n\tret = count;\n\tif (!pf)\n\t\treturn -ENXIO;\n\tadd_wait_queue(&pf->rwait, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tskb = skb_dequeue(&pf->rq);\n\t\tif (skb)\n\t\t\tbreak;\n\t\tret = 0;\n\t\tif (pf->dead)\n\t\t\tbreak;\n\t\tif (pf->kind == INTERFACE) {\n\t\t\tstruct ppp *ppp = PF_TO_PPP(pf);\n\t\t\tif (ppp->n_channels == 0 &&\n\t\t\t    (ppp->flags & SC_LOOP_TRAFFIC) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = -EAGAIN;\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\tbreak;\n\t\tret = -ERESTARTSYS;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&pf->rwait, &wait);\n\tif (!skb)\n\t\tgoto out;\n\tret = -EOVERFLOW;\n\tif (skb->len > count)\n\t\tgoto outf;\n\tret = -EFAULT;\n\tiov.iov_base = buf;\n\tiov.iov_len = count;\n\tiov_iter_init(&to, READ, &iov, 1, count);\n\tif (skb_copy_datagram_iter(skb, 0, &to, skb->len))\n\t\tgoto outf;\n\tret = skb->len;\n outf:\n\tkfree_skb(skb);\n out:\n\treturn ret;\n}", "target": 0}
{"code": "static int __init big_key_init(void)\n{\n\treturn register_key_type(&key_type_big_key);\n}", "target": 1}
{"code": "static inline void set_attr(map<string, bufferlist>& attrs, const char* key, const char* value)\n{\n  bufferlist bl;\n  encode(value,bl);\n  attrs.emplace(key, std::move(bl));\n}", "target": 0}
{"code": "static void packet_flush_mclist(struct sock *sk)\n{\n\tstruct packet_sock *po = pkt_sk(sk);\n\tstruct packet_mclist *ml;\n\tif (!po->mclist)\n\t\treturn;\n\trtnl_lock();\n\twhile ((ml = po->mclist) != NULL) {\n\t\tstruct net_device *dev;\n\t\tpo->mclist = ml->next;\n\t\tdev = __dev_get_by_index(sock_net(sk), ml->ifindex);\n\t\tif (dev != NULL)\n\t\t\tpacket_dev_mc(dev, ml, -1);\n\t\tkfree(ml);\n\t}\n\trtnl_unlock();\n}", "target": 0}
{"code": "string_copylc(uschar *s)\n{\nuschar *ss = store_get(Ustrlen(s) + 1);\nuschar *p = ss;\nwhile (*s != 0) *p++ = tolower(*s++);\n*p = 0;\nreturn ss;\n}", "target": 0}
{"code": "TfLiteStatus EvalHashtableImport(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputResourceIdTensor);\n  const int resource_id = input_resource_id_tensor->data.i32[0];\n  const TfLiteTensor* key_tensor = GetInput(context, node, kKeyTensor);\n  const TfLiteTensor* value_tensor = GetInput(context, node, kValueTensor);\n  Subgraph* subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n  auto& resources = subgraph->resources();\n  auto* lookup = resource::GetHashtableResource(&resources, resource_id);\n  TF_LITE_ENSURE(context, lookup != nullptr);\n  TF_LITE_ENSURE_STATUS(\n      lookup->CheckKeyAndValueTypes(context, key_tensor, value_tensor));\n  auto result = lookup->Import(context, key_tensor, value_tensor);\n  return result;\n}", "target": 1}
{"code": "static int ext4_split_unwritten_extents(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tstruct ext4_map_blocks *map,\n\t\t\t\t\tstruct ext4_ext_path *path,\n\t\t\t\t\tint flags)\n{\n\text4_lblk_t eof_block;\n\text4_lblk_t ee_block;\n\tstruct ext4_extent *ex;\n\tunsigned int ee_len;\n\tint split_flag = 0, depth;\n\text_debug(\"ext4_split_unwritten_extents: inode %lu, logical\"\n\t\t\"block %llu, max_blocks %u\\n\", inode->i_ino,\n\t\t(unsigned long long)map->m_lblk, map->m_len);\n\teof_block = (inode->i_size + inode->i_sb->s_blocksize - 1) >>\n\t\tinode->i_sb->s_blocksize_bits;\n\tif (eof_block < map->m_lblk + map->m_len)\n\t\teof_block = map->m_lblk + map->m_len;\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tee_block = le32_to_cpu(ex->ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n\tsplit_flag |= ee_block + ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0;\n\tsplit_flag |= EXT4_EXT_MARK_UNINIT2;\n\tif (flags & EXT4_GET_BLOCKS_CONVERT)\n\t\tsplit_flag |= EXT4_EXT_DATA_VALID2;\n\tflags |= EXT4_GET_BLOCKS_PRE_IO;\n\treturn ext4_split_extent(handle, inode, path, map, split_flag, flags);\n}", "target": 0}
{"code": "IW_IMPL(int) iw_get_input_density(struct iw_context *ctx,\n   double *px, double *py, int *pcode)\n{\n\t*px = 1.0;\n\t*py = 1.0;\n\t*pcode = ctx->img1.density_code;\n\tif(ctx->img1.density_code!=IW_DENSITY_UNKNOWN) {\n\t\t*px = ctx->img1.density_x;\n\t\t*py = ctx->img1.density_y;\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "do_prefetch_tables (const void *gcmM, size_t gcmM_size)\n{\n  prefetch_table(gcmM, gcmM_size);\n  prefetch_table(gcmR, sizeof(gcmR));\n}", "target": 1}
{"code": "static void nodeDestruct(struct SaveNode* node)\n{\n    if (node->v == &node->sorted)\n    {\n        tr_free(node->sorted.val.l.vals);\n    }\n}", "target": 1}
{"code": "juniper_pppoe_atm_print(netdissect_options *ndo,\n                        const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n\tuint16_t extracted_ethertype;\n        l2info.pictype = DLT_JUNIPER_PPPOE_ATM;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        ND_TCHECK2(p[0], 2);\n        extracted_ethertype = EXTRACT_16BITS(p);\n        if (ethertype_print(ndo, extracted_ethertype,\n                              p+ETHERTYPE_LEN,\n                              l2info.length-ETHERTYPE_LEN,\n                              l2info.caplen-ETHERTYPE_LEN,\n                              NULL, NULL) == 0)\n            ND_PRINT((ndo, \"unknown ethertype 0x%04x\", extracted_ethertype));\n        return l2info.header_len;\ntrunc:\n\tND_PRINT((ndo, \"[|juniper_pppoe_atm]\"));\n\treturn l2info.header_len;\n}", "target": 0}
{"code": "generatePreview (const char inFileName[],\n\t\t float exposure,\n\t\t int previewWidth,\n\t\t int &previewHeight,\n\t\t Array2D <PreviewRgba> &previewPixels)\n{\n    RgbaInputFile in (inFileName);\n    Box2i dw = in.dataWindow();\n    float a = in.pixelAspectRatio();\n    int w = dw.max.x - dw.min.x + 1;\n    int h = dw.max.y - dw.min.y + 1;\n    Array2D <Rgba> pixels (h, w);\n    in.setFrameBuffer (ComputeBasePointer (&pixels[0][0], dw), 1, w);\n    in.readPixels (dw.min.y, dw.max.y);\n    previewHeight = max (int (h / (w * a) * previewWidth + .5f), 1);\n    previewPixels.resizeErase (previewHeight, previewWidth);\n    float fx = (previewWidth  > 0)? (float (w - 1) / (previewWidth  - 1)): 1;\n    float fy = (previewHeight > 0)? (float (h - 1) / (previewHeight - 1)): 1;\n    float m  = Math<float>::pow (2.f, IMATH_NAMESPACE::clamp (exposure + 2.47393f, -20.f, 20.f));\n    for (int y = 0; y < previewHeight; ++y)\n    {\n\tfor (int x = 0; x < previewWidth; ++x)\n\t{\n\t    PreviewRgba &preview = previewPixels[y][x];\n\t    const Rgba &pixel = pixels[int (y * fy + .5f)][int (x * fx + .5f)];\n\t    preview.r = gamma (pixel.r, m);\n\t    preview.g = gamma (pixel.g, m);\n\t    preview.b = gamma (pixel.b, m);\n\t    preview.a = int (IMATH_NAMESPACE::clamp (pixel.a * 255.f, 0.f, 255.f) + .5f);\n\t}\n    }\n}", "target": 1}
{"code": "quant::UniformQuantizedPerAxisType ResetAxisAndBroadcast(\n    ArrayRef<int64_t> shape, quant::UniformQuantizedPerAxisType qtype,\n    Type target, int quant_dim) {\n  auto shaped = target.dyn_cast<RankedTensorType>();\n  if (!shaped) return {};\n  ArrayRef<int64_t> new_shape = shaped.getShape();\n  SmallVector<double, 4> scales(qtype.getScales().begin(),\n                                qtype.getScales().end());\n  SmallVector<int64_t, 4> zero_points(qtype.getZeroPoints().begin(),\n                                      qtype.getZeroPoints().end());\n  if (new_shape.size() == shape.size()) {  \n    if (BroadcastVector<double>(shaped.getDimSize(quant_dim), scales) ||\n        BroadcastVector<int64_t>(shaped.getDimSize(quant_dim), zero_points)) {\n      return {};\n    }\n  } else if ((new_shape.size() == shape.size() + 1) && new_shape.back() == 1) {\n    if (std::equal(shape.begin(), shape.end(), new_shape.begin()) &&\n        quant_dim == -1) {\n      quant_dim = shape.size() + quant_dim;\n    } else {\n      return {};\n    }\n  } else {\n    return {};\n  }\n  return quant::UniformQuantizedPerAxisType::get(\n      qtype.getFlags(), qtype.getStorageType(), qtype.getExpressedType(),\n      scales, zero_points, quant_dim, qtype.getStorageTypeMin(),\n      qtype.getStorageTypeMax());\n}", "target": 1}
{"code": "void TensorSliceReader::LoadShard(int shard) const {\n  CHECK_LT(shard, sss_.size());\n  if (sss_[shard] || !status_.ok()) {\n    return;  \n  }\n  string value;\n  SavedTensorSlices sts;\n  const string fname = fnames_[shard];\n  VLOG(1) << \"Reading meta data from file \" << fname << \"...\";\n  Table* table;\n  Status s = open_function_(fname, &table);\n  if (!s.ok()) {\n    status_ = errors::DataLoss(\"Unable to open table file \", fname, \": \",\n                               s.ToString());\n    return;\n  }\n  sss_[shard].reset(table);\n  if (!(table->Get(kSavedTensorSlicesKey, &value) &&\n        ParseProtoUnlimited(&sts, value))) {\n    status_ = errors::Internal(\n        \"Failed to find the saved tensor slices at the beginning of the \"\n        \"checkpoint file: \",\n        fname);\n    return;\n  }\n  status_ = CheckVersions(sts.meta().versions(), TF_CHECKPOINT_VERSION,\n                          TF_CHECKPOINT_VERSION_MIN_PRODUCER, \"Checkpoint\",\n                          \"checkpoint\");\n  if (!status_.ok()) return;\n  for (const SavedSliceMeta& ssm : sts.meta().tensor()) {\n    TensorShape ssm_shape;\n    status_ = TensorShape::BuildTensorShapeBase(ssm.shape(), &ssm_shape);\n    if (!status_.ok()) return;\n    for (const TensorSliceProto& tsp : ssm.slice()) {\n      TensorSlice ss_slice;\n      status_ = TensorSlice::BuildTensorSlice(tsp, &ss_slice);\n      if (!status_.ok()) return;\n      status_ = RegisterTensorSlice(ssm.name(), ssm_shape, ssm.type(), fname,\n                                    ss_slice, &tensors_);\n      if (!status_.ok()) return;\n    }\n  }\n}", "target": 0}
{"code": "static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t\tunsigned int dataoff, unsigned int *timeouts)\n{\n\treturn true;\n}", "target": 1}
{"code": "bool ResourceHandle::ParseFromString(const string& s) {\n  ResourceHandleProto proto;\n  const bool status = proto.ParseFromString(s);\n  if (status) FromProto(proto);\n  return status;\n}", "target": 1}
{"code": "bool __net_get_random_once(void *buf, int nbytes, bool *done,\n\t\t\t   struct static_key *done_key)\n{\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long flags;\n\tspin_lock_irqsave(&lock, flags);\n\tif (*done) {\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t\treturn false;\n\t}\n\tget_random_bytes(buf, nbytes);\n\t*done = true;\n\tspin_unlock_irqrestore(&lock, flags);\n\t__net_random_once_disable_jump(done_key);\n\treturn true;\n}", "target": 1}
{"code": "static bool download_and_write(SPDBDownloaderOpt *opt, const char *file) {\n\tchar *dir = r_str_newf (\"%s%s%s%s%s\",\n\t\topt->symbol_store_path, R_SYS_DIR,\n\t\topt->dbg_file, R_SYS_DIR,\n\t\topt->guid);\n\tif (!r_sys_mkdirp (dir)) {\n\t\tfree (dir);\n\t\treturn false;\n\t}\n\tchar *url = r_str_newf (\"%s/%s/%s/%s\", opt->symbol_server, opt->dbg_file, opt->guid, file);\n\tint len;\n\tchar *file_buf = r_socket_http_get (url, NULL, &len);\n\tfree (url);\n\tif (!len || R_STR_ISEMPTY (file_buf)) {\n\t\tfree (dir);\n\t\tfree (file_buf);\n\t\treturn false;\n\t}\n\tchar *path = r_str_newf (\"%s%s%s\", dir, R_SYS_DIR, opt->dbg_file);\n\tFILE *f = fopen (path, \"wb\");\n\tif (f) {\n\t\tfwrite (file_buf, sizeof (char), (size_t)len, f);\n\t\tfclose (f);\n\t}\n\tfree (dir);\n\tfree (path);\n\tfree (file_buf);\n\treturn true;\n}", "target": 0}
{"code": "static void setup_msrs(struct vcpu_vmx *vmx)\n{\n\tint save_nmsrs, index;\n\tsave_nmsrs = 0;\n#ifdef CONFIG_X86_64\n\tif (is_long_mode(&vmx->vcpu)) {\n\t\tindex = __find_msr_index(vmx, MSR_SYSCALL_MASK);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\tindex = __find_msr_index(vmx, MSR_LSTAR);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\tindex = __find_msr_index(vmx, MSR_CSTAR);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\tindex = __find_msr_index(vmx, MSR_TSC_AUX);\n\t\tif (index >= 0 && vmx->rdtscp_enabled)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\tindex = __find_msr_index(vmx, MSR_STAR);\n\t\tif ((index >= 0) && (vmx->vcpu.arch.efer & EFER_SCE))\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t}\n#endif\n\tindex = __find_msr_index(vmx, MSR_EFER);\n\tif (index >= 0 && update_transition_efer(vmx, index))\n\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\tvmx->save_nmsrs = save_nmsrs;\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmx_set_msr_bitmap(&vmx->vcpu);\n}", "target": 0}
{"code": "static pfn_t kvm_pin_pages(struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t   unsigned long size)\n{\n\tgfn_t end_gfn;\n\tpfn_t pfn;\n\tpfn     = gfn_to_pfn_memslot(slot, gfn);\n\tend_gfn = gfn + (size >> PAGE_SHIFT);\n\tgfn    += 1;\n\tif (is_error_noslot_pfn(pfn))\n\t\treturn pfn;\n\twhile (gfn < end_gfn)\n\t\tgfn_to_pfn_memslot(slot, gfn++);\n\treturn pfn;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& filter = context->input(1);\n    OP_REQUIRES(context, input.dims() == 5,\n                errors::InvalidArgument(\"input must be 5-dimensional\"));\n    OP_REQUIRES(context, filter.dims() == 5,\n                errors::InvalidArgument(\"filter must be 5-dimensional\"));\n    const int64 in_depth = GetTensorDim(input, data_format_, 'C');\n    const int64 in_batch = GetTensorDim(input, data_format_, 'N');\n    const int64 filter_depth = filter.dim_size(3);\n    const int64 out_depth = filter.dim_size(4);\n    OP_REQUIRES(context, filter_depth != 0,\n                errors::InvalidArgument(\"filter_depth must be non-zero\"));\n    OP_REQUIRES(context, in_depth % filter_depth == 0,\n                errors::InvalidArgument(\n                    \"Input depth must be evenly divisible by filter depth: \",\n                    in_depth, \" vs \", filter_depth));\n    std::array<int64, 3> input_size = {\n        {GetTensorDim(input, data_format_, '0'),\n         GetTensorDim(input, data_format_, '1'),\n         GetTensorDim(input, data_format_, '2')}};\n    std::array<int64, 3> filter_size = {\n        {filter.dim_size(0), filter.dim_size(1), filter.dim_size(2)}};\n    std::array<int64, 3> dilations = {\n        {GetTensorDim(dilation_, data_format_, '0'),\n         GetTensorDim(dilation_, data_format_, '1'),\n         GetTensorDim(dilation_, data_format_, '2')}};\n    std::array<int64, 3> strides = {{GetTensorDim(stride_, data_format_, '0'),\n                                     GetTensorDim(stride_, data_format_, '1'),\n                                     GetTensorDim(stride_, data_format_, '2')}};\n    std::array<int64, 3> out, padding;\n    OP_REQUIRES_OK(\n        context, Get3dOutputSizeV2(input_size, filter_size, dilations, strides,\n                                   padding_, &out, &padding));\n    TensorShape out_shape = ShapeFromFormat(\n        data_format_, in_batch, {{out[0], out[1], out[2]}}, out_depth);\n    Tensor* output;\n    OP_REQUIRES_OK(context, context->allocate_output(0, out_shape, &output));\n    if (out_shape.num_elements() == 0) return;\n    LaunchConvOp<Device, T>::launch(context, cudnn_use_autotune_, input, filter,\n                                    dilations, strides, padding_, data_format_,\n                                    output);\n  }", "target": 0}
{"code": "coolkey_find_matching_cert(sc_card_t *card, sc_cardctl_coolkey_object_t *in_obj, sc_cardctl_coolkey_object_t **cert_obj) {\n\tsc_cardctl_coolkey_find_object_t fobj;\n\tsc_cardctl_coolkey_attribute_t template[2];\n\tu8 obj_class[4];\n\tint r;\n\ttemplate[0].attribute_type = CKA_CLASS;\n\ttemplate[0].attribute_data_type = SC_CARDCTL_COOLKEY_ATTR_TYPE_ULONG;\n\ttemplate[0].attribute_length = sizeof(obj_class);\n\ttemplate[0].attribute_value = obj_class;\n\tulong2bebytes(obj_class, CKO_CERTIFICATE);\n\ttemplate[1].attribute_type = CKA_ID;\n\ttemplate[1].object = in_obj;\n\tr = sc_card_ctl(card, SC_CARDCTL_COOLKEY_GET_ATTRIBUTE, &template[1]);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\ttemplate[0].object = NULL; \n\ttemplate[1].object = NULL; \n\tfobj.type = SC_CARDCTL_COOLKEY_FIND_BY_TEMPLATE;\n\tfobj.obj = NULL;\n\tfobj.coolkey_template = &template[0];\n\tfobj.template_count=2;\n\tr = sc_card_ctl(card, SC_CARDCTL_COOLKEY_FIND_OBJECT, &fobj);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\t*cert_obj = fobj.obj;\n\treturn SC_SUCCESS;\n}", "target": 0}
{"code": "static int iwch_l2t_send(struct t3cdev *tdev, struct sk_buff *skb, struct l2t_entry *l2e)\n{\n\tint\terror = 0;\n\tstruct cxio_rdev *rdev;\n\trdev = (struct cxio_rdev *)tdev->ulp;\n\tif (cxio_fatal_error(rdev)) {\n\t\tkfree_skb(skb);\n\t\treturn -EIO;\n\t}\n\terror = l2t_send(tdev, skb, l2e);\n\tif (error < 0)\n\t\tkfree_skb(skb);\n\treturn error;\n}", "target": 1}
{"code": "static void ext4_free_io_end(ext4_io_end_t *io)\n{\n\tBUG_ON(!io);\n\tiput(io->inode);\n\tkfree(io);\n}", "target": 1}
{"code": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\tif ((cur->peercallno == callno) ||\n\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "    const std::unordered_map<std::string, std::string> &headers() const override\n    {\n        return headers_;\n    }", "target": 1}
{"code": "void ldbRedis(lua_State *lua, sds *argv, int argc) {\n    int j, saved_rc = server.lua_replicate_commands;\n    if (!lua_checkstack(lua, argc + 1)) {\n        ldbLogRedisReply(\"max lua stack reached\");\n        return;\n    }\n    lua_getglobal(lua,\"redis\");\n    lua_pushstring(lua,\"call\");\n    lua_gettable(lua,-2);       \n    for (j = 1; j < argc; j++)\n        lua_pushlstring(lua,argv[j],sdslen(argv[j]));\n    ldb.step = 1;               \n    server.lua_replicate_commands = 1;\n    lua_pcall(lua,argc-1,1,0);  \n    ldb.step = 0;               \n    server.lua_replicate_commands = saved_rc;\n    lua_pop(lua,2);             \n}", "target": 0}
{"code": "static gpointer openssl_global_init_once(gpointer arg)\n{\n    SSL_library_init();\n    SSL_load_error_strings();\n    openssl_thread_setup();\n    return NULL;\n}", "target": 0}
{"code": "static int find_high_bit(unsigned int x)\n{\n\tint i;\n\tfor(i=31;i>=0;i--) {\n\t\tif(x&(1<<i)) return i;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "get_word_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  register int rindex = rgb_red[cinfo->in_color_space];\n  register int gindex = rgb_green[cinfo->in_color_space];\n  register int bindex = rgb_blue[cinfo->in_color_space];\n  register int aindex = alpha_index[cinfo->in_color_space];\n  register int ps = rgb_pixelsize[cinfo->in_color_space];\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    ptr[rindex] = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    ptr[gindex] = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    ptr[bindex] = rescale[temp];\n    if (aindex >= 0)\n      ptr[aindex] = 0xFF;\n    ptr += ps;\n  }\n  return 1;\n}", "target": 0}
{"code": "    inline PluginEndpointSecurityAttributesMask mask() const\n    {\n        PluginEndpointSecurityAttributesMask rv = PLUGIN_ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_VALID;\n        if (is_submessage_encrypted) rv |= PLUGIN_ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_SUBMESSAGE_ENCRYPTED;\n        if (is_submessage_origin_authenticated) rv |= PLUGIN_ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_SUBMESSAGE_ORIGIN_AUTHENTICATED;\n        if (is_payload_encrypted) rv |= PLUGIN_ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_PAYLOAD_ENCRYPTED;\n        return rv;\n    }", "target": 1}
{"code": "static inline void fsnotify_oldname_free(const unsigned char *old_name)\n{\n\tkfree(old_name);\n}", "target": 1}
{"code": "static int kill_something_info(int sig, struct siginfo *info, pid_t pid)\n{\n\tint ret;\n\tif (pid > 0) {\n\t\trcu_read_lock();\n\t\tret = kill_pid_info(sig, info, find_vpid(pid));\n\t\trcu_read_unlock();\n\t\treturn ret;\n\t}\n\tif (pid == INT_MIN)\n\t\treturn -ESRCH;\n\tread_lock(&tasklist_lock);\n\tif (pid != -1) {\n\t\tret = __kill_pgrp_info(sig, info,\n\t\t\t\tpid ? find_vpid(-pid) : task_pgrp(current));\n\t} else {\n\t\tint retval = 0, count = 0;\n\t\tstruct task_struct * p;\n\t\tfor_each_process(p) {\n\t\t\tif (task_pid_vnr(p) > 1 &&\n\t\t\t\t\t!same_thread_group(p, current)) {\n\t\t\t\tint err = group_send_sig_info(sig, info, p);\n\t\t\t\t++count;\n\t\t\t\tif (err != -EPERM)\n\t\t\t\t\tretval = err;\n\t\t\t}\n\t\t}\n\t\tret = count ? retval : -ESRCH;\n\t}\n\tread_unlock(&tasklist_lock);\n\treturn ret;\n}", "target": 0}
{"code": "void unix_inflight(struct user_struct *user, struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\tspin_lock(&unix_gc_lock);\n\tif (s) {\n\t\tstruct unix_sock *u = unix_sk(s);\n\t\tif (atomic_long_inc_return(&u->inflight) == 1) {\n\t\t\tBUG_ON(!list_empty(&u->link));\n\t\t\tlist_add_tail(&u->link, &gc_inflight_list);\n\t\t} else {\n\t\t\tBUG_ON(list_empty(&u->link));\n\t\t}\n\t\tunix_tot_inflight++;\n\t}\n\tuser->unix_inflight++;\n\tspin_unlock(&unix_gc_lock);\n}", "target": 0}
{"code": " */\nstatic int wddx_stack_destroy(wddx_stack *stack)\n{\n\tregister int i;\n\tif (stack->elements) {\n\t\tfor (i = 0; i < stack->top; i++) {\n\t\t\tif (((st_entry *)stack->elements[i])->data)\t{\n\t\t\t\tzval_ptr_dtor(&((st_entry *)stack->elements[i])->data);\n\t\t\t}\n\t\t\tif (((st_entry *)stack->elements[i])->varname) {\n\t\t\t\tefree(((st_entry *)stack->elements[i])->varname);\n\t\t\t}\n\t\t\tefree(stack->elements[i]);\n\t\t}\n\t\tefree(stack->elements);\n\t}\n\treturn SUCCESS;", "target": 1}
{"code": "get_html_data (MAPI_Attr *a)\n{\n    VarLenData **body = XCALLOC(VarLenData*, a->num_values + 1);\n    int j;\n    for (j = 0; j < a->num_values; j++)\n    {\n\tbody[j] = XMALLOC(VarLenData, 1);\n\tbody[j]->len = a->values[j].len;\n\tbody[j]->data = CHECKED_XCALLOC(unsigned char, a->values[j].len);\n\tmemmove (body[j]->data, a->values[j].data.buf, body[j]->len);\n    }\n    return body;\n}", "target": 1}
{"code": "void get_pid_creds(pid_t pid, uid_t *uid, gid_t *gid)\n{\n\tchar line[400];\n\tuid_t u;\n\tgid_t g;\n\tFILE *f;\n\t*uid = -1;\n\t*gid = -1;\n\tsprintf(line, \"/proc/%d/status\", pid);\n\tif ((f = fopen(line, \"r\")) == NULL) {\n\t\tfprintf(stderr, \"Error opening %s: %s\\n\", line, strerror(errno));\n\t\treturn;\n\t}\n\twhile (fgets(line, 400, f)) {\n\t\tif (strncmp(line, \"Uid:\", 4) == 0) {\n\t\t\tif (sscanf(line+4, \"%u\", &u) != 1) {\n\t\t\t\tfprintf(stderr, \"bad uid line for pid %u\\n\", pid);\n\t\t\t\tfclose(f);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t*uid = u;\n\t\t} else if (strncmp(line, \"Gid:\", 4) == 0) {\n\t\t\tif (sscanf(line+4, \"%u\", &g) != 1) {\n\t\t\t\tfprintf(stderr, \"bad gid line for pid %u\\n\", pid);\n\t\t\t\tfclose(f);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t*gid = g;\n\t\t}\n\t}\n\tfclose(f);\n}", "target": 0}
{"code": "deltas_head_sort(struct deltas_head *deltas, unsigned long max_serial)\n{\n\tunsigned long min_serial;\n\tstruct delta_head *cursor;\n\tarray_index i;\n\tint error;\n\tif (max_serial + 1 < deltas->len)\n\t\treturn pr_val_err(\"Deltas: Too many deltas (%zu) for serial %lu. (Negative serials not implemented.)\",\n\t\t    deltas->len, max_serial);\n\tmin_serial = max_serial + 1 - deltas->len;\n\tARRAYLIST_FOREACH(deltas, cursor, i) {\n\t\terror = swap_until_sorted(deltas->array, i, min_serial,\n\t\t    max_serial);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "struct mb2_cache *ext2_xattr_create_cache(void)\n{\n\treturn mb2_cache_create(HASH_BUCKET_BITS);\n}", "target": 0}
{"code": "int x86_decode_emulated_instruction(struct kvm_vcpu *vcpu, int emulation_type,\n\t\t\t\t    void *insn, int insn_len)\n{\n\tint r = EMULATION_OK;\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tinit_emulate_ctxt(vcpu);\n\tif (!(emulation_type & EMULTYPE_SKIP) &&\n\t    kvm_vcpu_check_breakpoint(vcpu, &r))\n\t\treturn r;\n\tr = x86_decode_insn(ctxt, insn, insn_len, emulation_type);\n\ttrace_kvm_emulate_insn_start(vcpu);\n\t++vcpu->stat.insn_emulation;\n\treturn r;\n}", "target": 1}
{"code": "static __net_init int setup_net(struct net *net, struct user_namespace *user_ns)\n{\n\tconst struct pernet_operations *ops, *saved_ops;\n\tint error = 0;\n\tLIST_HEAD(net_exit_list);\n\trefcount_set(&net->count, 1);\n\trefcount_set(&net->passive, 1);\n\tget_random_bytes(&net->hash_mix, sizeof(u32));\n\tnet->dev_base_seq = 1;\n\tnet->user_ns = user_ns;\n\tidr_init(&net->netns_ids);\n\tspin_lock_init(&net->nsid_lock);\n\tmutex_init(&net->ipv4.ra_mutex);\n\tlist_for_each_entry(ops, &pernet_list, list) {\n\t\terror = ops_init(ops, net);\n\t\tif (error < 0)\n\t\t\tgoto out_undo;\n\t}\n\tdown_write(&net_rwsem);\n\tlist_add_tail_rcu(&net->list, &net_namespace_list);\n\tup_write(&net_rwsem);\nout:\n\treturn error;\nout_undo:\n\tlist_add(&net->exit_list, &net_exit_list);\n\tsaved_ops = ops;\n\tlist_for_each_entry_continue_reverse(ops, &pernet_list, list)\n\t\tops_exit_list(ops, &net_exit_list);\n\tops = saved_ops;\n\tlist_for_each_entry_continue_reverse(ops, &pernet_list, list)\n\t\tops_free_list(ops, &net_exit_list);\n\trcu_barrier();\n\tgoto out;\n}", "target": 0}
{"code": "void blk_mq_all_tag_busy_iter(struct blk_mq_tags *tags, busy_tag_iter_fn *fn,\n\t\tvoid *priv)\n{\n\tif (tags->nr_reserved_tags)\n\t\tbt_tags_for_each(tags, &tags->breserved_tags, 0, fn, priv, true);\n\tbt_tags_for_each(tags, &tags->bitmap_tags, tags->nr_reserved_tags, fn, priv,\n\t\t\tfalse);\n}", "target": 0}
{"code": "  void AddBatchOffsets(Tensor* indices, const Tensor& params) {\n    int64_t batch_size = 1;  \n    for (int idx = 0; idx < batch_dims_; ++idx) {\n      batch_size *= params.dim_size(idx);\n    }\n    auto indices_flat = indices->flat<Index>();\n    int64_t const index_inner_size = indices->NumElements() / batch_size;\n    int64_t const batch_offset = params.dim_size(batch_dims_);\n    for (int64_t batch_idx = 0, dest_idx = 0; batch_idx < batch_size;\n         ++batch_idx) {\n      for (int64_t idx = 0; idx < index_inner_size; ++idx) {\n        indices_flat(dest_idx++) += batch_offset * batch_idx;\n      }\n    }\n  }", "target": 1}
{"code": "assegment_dup_all (struct assegment *seg)\n{\n  struct assegment *new = NULL;\n  struct assegment *head = NULL;\n  while (seg)\n    {\n      if (head)\n        {\n          new->next = assegment_dup (seg);\n          new = new->next;\n        }\n      else\n        head = new = assegment_dup (seg);\n      seg = seg->next;\n    }\n  return head;\n}", "target": 0}
{"code": "static int seed_from_urandom(uint32_t *seed) {\n    char data[sizeof(uint32_t)];\n    int ok;\n#if defined(HAVE_OPEN) && defined(HAVE_CLOSE) && defined(HAVE_READ)\n    int urandom;\n    urandom = open(\"/dev/urandom\", O_RDONLY);\n    if (urandom == -1)\n        return 1;\n    ok = read(urandom, data, sizeof(uint32_t)) == sizeof(uint32_t);\n    close(urandom);\n#else\n    FILE *urandom;\n    urandom = fopen(\"/dev/urandom\", \"rb\");\n    if (!urandom)\n        return 1;\n    ok = fread(data, 1, sizeof(uint32_t), urandom) == sizeof(uint32_t);\n    fclose(urandom);\n#endif\n    if (!ok)\n        return 1;\n    *seed = buf_to_uint32(data);\n    return 0;\n}", "target": 0}
{"code": "static int netbk_set_skb_gso(struct xenvif *vif,\n\t\t\t     struct sk_buff *skb,\n\t\t\t     struct xen_netif_extra_info *gso)\n{\n\tif (!gso->u.gso.size) {\n\t\tnetdev_dbg(vif->dev, \"GSO size must not be zero.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (gso->u.gso.type != XEN_NETIF_GSO_TYPE_TCPV4) {\n\t\tnetdev_dbg(vif->dev, \"Bad GSO type %d.\\n\", gso->u.gso.type);\n\t\treturn -EINVAL;\n\t}\n\tskb_shinfo(skb)->gso_size = gso->u.gso.size;\n\tskb_shinfo(skb)->gso_type = SKB_GSO_TCPV4;\n\tskb_shinfo(skb)->gso_type |= SKB_GSO_DODGY;\n\tskb_shinfo(skb)->gso_segs = 0;\n\treturn 0;\n}", "target": 1}
{"code": "usage(void)\n{\n\tfprintf(stderr,\n\t    \"usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\\n\"\n\t    \"                 [-t life] [command [arg ...]]\\n\"\n\t    \"       ssh-agent [-c | -s] -k\\n\");\n\texit(1);\n}", "target": 1}
{"code": "static void spl_filesystem_dir_it_rewind(zend_object_iterator *iter TSRMLS_DC)\n{\n\tspl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);\n\tobject->u.dir.index = 0;\n\tif (object->u.dir.dirp) {\n\t\tphp_stream_rewinddir(object->u.dir.dirp);\n\t}\n\tspl_filesystem_dir_read(object TSRMLS_CC);\n}", "target": 0}
{"code": "StatusOr<FullTypeDef> SpecializeType(const AttrSlice& attrs,\n                                     const OpDef& op_def) {\n  FullTypeDef ft;\n  ft.set_type_id(TFT_PRODUCT);\n  for (int i = 0; i < op_def.output_arg_size(); i++) {\n    auto* t = ft.add_args();\n    *t = op_def.output_arg(i).experimental_full_type();\n    for (int j = 0; j < t->args_size(); j++) {\n      auto* arg = t->mutable_args(i);\n      if (arg->type_id() == TFT_VAR) {\n        const auto* attr = attrs.Find(arg->s());\n        DCHECK(attr != nullptr);\n        if (attr->value_case() == AttrValue::kList) {\n          const auto& attr_list = attr->list();\n          arg->set_type_id(TFT_PRODUCT);\n          for (int i = 0; i < attr_list.type_size(); i++) {\n            map_dtype_to_tensor(attr_list.type(i), arg->add_args());\n          }\n        } else if (attr->value_case() == AttrValue::kType) {\n          map_dtype_to_tensor(attr->type(), arg);\n        } else {\n          return Status(error::UNIMPLEMENTED,\n                        absl::StrCat(\"unknown attribute type\",\n                                     attrs.DebugString(), \" key=\", arg->s()));\n        }\n        arg->clear_s();\n      }\n    }\n  }\n  return ft;\n}", "target": 1}
{"code": "int fscrypt_get_encryption_info(struct inode *inode)\n{\n\tstruct fscrypt_info *ci = inode->i_crypt_info;\n\tif (!ci ||\n\t\t(ci->ci_keyring_key &&\n\t\t (ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t\t\t       (1 << KEY_FLAG_REVOKED) |\n\t\t\t\t\t       (1 << KEY_FLAG_DEAD)))))\n\t\treturn fscrypt_get_crypt_info(inode);\n\treturn 0;\n}", "target": 1}
{"code": "static void __lo_release(struct loop_device *lo)\n{\n\tint err;\n\tif (atomic_dec_return(&lo->lo_refcnt))\n\t\treturn;\n\tmutex_lock(&lo->lo_ctl_mutex);\n\tif (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {\n\t\terr = loop_clr_fd(lo);\n\t\tif (!err)\n\t\t\treturn;\n\t} else if (lo->lo_state == Lo_bound) {\n\t\tblk_mq_freeze_queue(lo->lo_queue);\n\t\tblk_mq_unfreeze_queue(lo->lo_queue);\n\t}\n\tmutex_unlock(&lo->lo_ctl_mutex);\n}", "target": 0}
{"code": "struct timespec ns_to_timespec(const s64 nsec)\n{\n\tstruct timespec ts;\n\tif (!nsec)\n\t\treturn (struct timespec) {0, 0};\n\tts.tv_sec = div_long_long_rem_signed(nsec, NSEC_PER_SEC, &ts.tv_nsec);\n\tif (unlikely(nsec < 0))\n\t\tset_normalized_timespec(&ts, ts.tv_sec, ts.tv_nsec);\n\treturn ts;\n}", "target": 1}
{"code": "rfbSetClientColourMapBGR233(rfbClientPtr cl)\n{\n    char buf[sz_rfbSetColourMapEntriesMsg + 256 * 3 * 2];\n    rfbSetColourMapEntriesMsg *scme = (rfbSetColourMapEntriesMsg *)buf;\n    uint16_t *rgb = (uint16_t *)(&buf[sz_rfbSetColourMapEntriesMsg]);\n    int i, len;\n    int r, g, b;\n    if (cl->format.bitsPerPixel != 8 ) {\n        rfbErr(\"%s: client not 8 bits per pixel\\n\",\n                \"rfbSetClientColourMapBGR233\");\n        rfbCloseClient(cl);\n        return FALSE;\n    }\n    scme->type = rfbSetColourMapEntries;\n    scme->firstColour = Swap16IfLE(0);\n    scme->nColours = Swap16IfLE(256);\n    len = sz_rfbSetColourMapEntriesMsg;\n    i = 0;\n    for (b = 0; b < 4; b++) {\n        for (g = 0; g < 8; g++) {\n            for (r = 0; r < 8; r++) {\n                rgb[i++] = Swap16IfLE(r * 65535 / 7);\n                rgb[i++] = Swap16IfLE(g * 65535 / 7);\n                rgb[i++] = Swap16IfLE(b * 65535 / 3);\n            }\n        }\n    }\n    len += 256 * 3 * 2;\n    if (rfbWriteExact(cl, buf, len) < 0) {\n        rfbLogPerror(\"rfbSetClientColourMapBGR233: write\");\n        rfbCloseClient(cl);\n        return FALSE;\n    }\n    return TRUE;\n}", "target": 1}
{"code": "static int ext4_end_io_dio(struct kiocb *iocb, loff_t offset,\n\t\t\t    ssize_t size, void *private)\n{\n        ext4_io_end_t *io_end = private;\n\tif (!io_end)\n\t\treturn 0;\n\text_debug(\"ext4_end_io_dio(): io_end 0x%p \"\n\t\t  \"for inode %lu, iocb 0x%p, offset %llu, size %zd\\n\",\n\t\t  io_end, io_end->inode->i_ino, iocb, offset, size);\n\tif (size <= 0) {\n\t\text4_clear_io_unwritten_flag(io_end);\n\t\tsize = 0;\n\t}\n\tio_end->offset = offset;\n\tio_end->size = size;\n\text4_put_io_end(io_end);\n\treturn 0;\n}", "target": 0}
{"code": "static int srv_init(uint16_t lport)\n{\n\tstruct sa laddr;\n\tstruct tcp_sock *tsock;\n\tint err;\n\tinfo(\"srv_init: lport=%d\\n\", (int)lport);\n\terr = sa_set_str(&laddr, \"0.0.0.0\", lport);\n\tif (err)\n\t\treturn err;\n\terr = http_listen(&verifyd.sock, &laddr, http_req_handler, NULL);\n\tif (err) {\n\t\tre_fprintf(stderr, \"http_listen: failed: %m\\n\", err);\n\t\treturn err;\n\t}\n\ttsock = http_sock_tcp(verifyd.sock);\n\tif (tsock) {\n\t\ttcp_sock_local_get(tsock, &laddr);\n\t}\n\tre_fprintf(stderr, \"verifyd: listening on %J\\n\", &laddr);\n\treturn 0;\n}", "target": 0}
{"code": "void inet6_destroy_sock(struct sock *sk)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sk_buff *skb;\n\tstruct ipv6_txoptions *opt;\n\tskb = xchg(&np->pktoptions, NULL);\n\tif (skb)\n\t\tkfree_skb(skb);\n\tskb = xchg(&np->rxpmtu, NULL);\n\tif (skb)\n\t\tkfree_skb(skb);\n\tfl6_free_socklist(sk);\n\topt = xchg(&np->opt, NULL);\n\tif (opt)\n\t\tsock_kfree_s(sk, opt, opt->tot_len);\n}", "target": 1}
{"code": "static void cil_reset_classperms_set(struct cil_classperms_set *cp_set)\n{\n\tcil_reset_classpermission(cp_set->set);\n}", "target": 1}
{"code": "void CxImage::Ghost(const CxImage *from)\n{\n\tif (from){\n\t\tmemcpy(&head,&from->head,sizeof(BITMAPINFOHEADER));\n\t\tmemcpy(&info,&from->info,sizeof(CXIMAGEINFO));\n\t\tpDib = from->pDib;\n        pDibLimit = from->pDibLimit;\n\t\tpSelection = from->pSelection;\n\t\tpAlpha = from->pAlpha;\n\t\tppLayers = from->ppLayers;\n\t\tppFrames = from->ppFrames;\n\t\tinfo.pGhost=(CxImage *)from;\n\t}\n}", "target": 0}
{"code": "void Archive::Seek(int64 Offset,int Method)\n{\n  if (!QOpen.Seek(Offset,Method))\n    File::Seek(Offset,Method);\n}", "target": 1}
{"code": "dirserv_remove_old_statuses(smartlist_t *fps, time_t cutoff)\n{\n  int found_any = 0;\n  SMARTLIST_FOREACH(fps, char *, digest,\n  {\n    cached_dir_t *d = lookup_cached_dir_by_fp(digest);\n    if (!d)\n      continue;\n    found_any = 1;\n    if (d->published <= cutoff) {\n      tor_free(digest);\n      SMARTLIST_DEL_CURRENT(fps, digest);\n    }\n  });\n  return found_any;\n}", "target": 0}
{"code": "  Status SetUnknownShape(const NodeDef* node, int output_port) {\n    shape_inference::ShapeHandle shape =\n        GetUnknownOutputShape(node, output_port);\n    InferenceContext* ctx = GetContext(node);\n    if (ctx == nullptr) {\n      return errors::InvalidArgument(\"Missing context\");\n    }\n    ctx->set_output(output_port, shape);\n    return Status::OK();\n  }", "target": 1}
{"code": "static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\tspin_lock(&ctx->event_wqh.lock);\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (ACCESS_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\t\t\t\tuserfaultfd_ctx_put(new);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\twake_up_poll(&ctx->fd_wqh, POLLIN);\n\t\tschedule();\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\nout:\n\tuserfaultfd_ctx_put(ctx);\n}", "target": 0}
{"code": "static int __init init_ext2_fs(void)\n{\n\tint err = init_ext2_xattr();\n\tif (err)\n\t\treturn err;\n\terr = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n        err = register_filesystem(&ext2_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\texit_ext2_xattr();\n\treturn err;\n}", "target": 1}
{"code": "Adaptation::Ecap::Host::Host()\n{\n    libecap::headerTransferEncoding.assignHostId(Http::HdrType::TRANSFER_ENCODING);\n    libecap::headerReferer.assignHostId(Http::HdrType::REFERER);\n    libecap::headerContentLength.assignHostId(Http::HdrType::CONTENT_LENGTH);\n    libecap::headerVia.assignHostId(Http::HdrType::VIA);\n    libecap::protocolHttp.assignHostId(AnyP::PROTO_HTTP);\n    libecap::protocolHttps.assignHostId(AnyP::PROTO_HTTPS);\n    libecap::protocolFtp.assignHostId(AnyP::PROTO_FTP);\n    libecap::protocolGopher.assignHostId(AnyP::PROTO_GOPHER);\n    libecap::protocolWais.assignHostId(AnyP::PROTO_WAIS);\n    libecap::protocolUrn.assignHostId(AnyP::PROTO_URN);\n    libecap::protocolWhois.assignHostId(AnyP::PROTO_WHOIS);\n    protocolCacheObj.assignHostId(AnyP::PROTO_CACHE_OBJECT);\n    protocolIcp.assignHostId(AnyP::PROTO_ICP);\n#if USE_HTCP\n    protocolHtcp.assignHostId(AnyP::PROTO_HTCP);\n#endif\n    protocolIcy.assignHostId(AnyP::PROTO_ICY);\n    protocolUnknown.assignHostId(AnyP::PROTO_UNKNOWN);\n    metaBypassable.assignHostId(1);\n}", "target": 1}
{"code": "static int handle_vmon(struct kvm_vcpu *vcpu)\n{\n\tint ret;\n\tgpa_t vmptr;\n\tstruct page *page;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tconst u64 VMXON_NEEDED_FEATURES = FEATURE_CONTROL_LOCKED\n\t\t| FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX;\n\tif (!kvm_read_cr4_bits(vcpu, X86_CR4_VMXE)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\tif (vmx_get_cpl(vcpu)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\tif (vmx->nested.vmxon) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_VMXON_IN_VMX_ROOT_OPERATION);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\tif ((vmx->msr_ia32_feature_control & VMXON_NEEDED_FEATURES)\n\t\t\t!= VMXON_NEEDED_FEATURES) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\tif (nested_vmx_get_vmptr(vcpu, &vmptr))\n\t\treturn 1;\n\tif (!PAGE_ALIGNED(vmptr) || (vmptr >> cpuid_maxphyaddr(vcpu))) {\n\t\tnested_vmx_failInvalid(vcpu);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\tpage = kvm_vcpu_gpa_to_page(vcpu, vmptr);\n\tif (is_error_page(page)) {\n\t\tnested_vmx_failInvalid(vcpu);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\tif (*(u32 *)kmap(page) != VMCS12_REVISION) {\n\t\tkunmap(page);\n\t\tkvm_release_page_clean(page);\n\t\tnested_vmx_failInvalid(vcpu);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\tkunmap(page);\n\tkvm_release_page_clean(page);\n\tvmx->nested.vmxon_ptr = vmptr;\n\tret = enter_vmx_operation(vcpu);\n\tif (ret)\n\t\treturn ret;\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}", "target": 0}
{"code": "void __drm_atomic_state_free(struct kref *ref)\n{\n\tstruct drm_atomic_state *state = container_of(ref, typeof(*state), ref);\n\tstruct drm_mode_config *config = &state->dev->mode_config;\n\tdrm_atomic_state_clear(state);\n\tdrm_dbg_atomic(state->dev, \"Freeing atomic state %p\\n\", state);\n\tif (config->funcs->atomic_state_free) {\n\t\tconfig->funcs->atomic_state_free(state);\n\t} else {\n\t\tdrm_atomic_state_default_release(state);\n\t\tkfree(state);\n\t}\n}", "target": 1}
{"code": "static void host_callback(void *arg, int status, int timeouts,\n                          unsigned char *abuf, int alen)\n{\n  struct host_query *hquery = (struct host_query*)arg;\n  int addinfostatus = ARES_SUCCESS;\n  hquery->timeouts += timeouts;\n  hquery->remaining--;\n  if (status == ARES_SUCCESS)\n    {\n      addinfostatus = ares__parse_into_addrinfo(abuf, alen, hquery->ai);\n    }\n  else if (status == ARES_EDESTRUCTION)\n    {\n      end_hquery(hquery, status);\n      return;\n    }\n  if (!hquery->remaining)\n    {\n      if (addinfostatus != ARES_SUCCESS)\n        {\n          end_hquery(hquery, addinfostatus);\n        }\n      else if (hquery->ai->nodes)\n        {\n          end_hquery(hquery, ARES_SUCCESS);\n        }\n      else if (status == ARES_ENOTFOUND)\n        {\n          next_lookup(hquery, status);\n        }\n      else\n        {\n          end_hquery(hquery, status);\n        }\n    }\n}", "target": 0}
{"code": "static int perf_swevent_init(struct perf_event *event)\n{\n\tint event_id = event->attr.config;\n\tif (event->attr.type != PERF_TYPE_SOFTWARE)\n\t\treturn -ENOENT;\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\tswitch (event_id) {\n\tcase PERF_COUNT_SW_CPU_CLOCK:\n\tcase PERF_COUNT_SW_TASK_CLOCK:\n\t\treturn -ENOENT;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (event_id >= PERF_COUNT_SW_MAX)\n\t\treturn -ENOENT;\n\tif (!event->parent) {\n\t\tint err;\n\t\terr = swevent_hlist_get(event);\n\t\tif (err)\n\t\t\treturn err;\n\t\tstatic_key_slow_inc(&perf_swevent_enabled[event_id]);\n\t\tevent->destroy = sw_perf_event_destroy;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static inline void *get_freepointer(struct kmem_cache *s, void *object)\n{\n\treturn *(void **)(object + s->offset);\n}", "target": 0}
{"code": "void StelScriptOutput::saveOutputAs(const QString &name)\n{\n\tQFile asFile;\n\tconst QFileInfo outputInfo(outputFile);\n\tconst QDir dir=outputInfo.dir(); \n\tconst QFileInfo newFileNameInfo(name);\n\tconst bool okToSaveToAbsolutePath=StelApp::getInstance().getSettings()->value(\"scripts/flag_script_allow_write_absolute_path\", false).toBool();\n\tif (name.contains(\"config.ini\"))\n\t{\n\t\tqWarning() << \"SCRIPTING ERROR: You are trying to overwrite config.ini. Ignoring.\";\n\t\treturn;\n\t}\n\tif (!okToSaveToAbsolutePath && ((newFileNameInfo.isAbsolute() || (name.contains(\"..\"))))) \n\t{\n\t\tqWarning() << \"SCRIPTING CONFIGURATION ISSUE: You are trying to save to an absolute pathname or move up in directories.\";\n\t\tqWarning() << \"  To enable this, edit config.ini and set [scripts]/flag_script_allow_write_absolute_path=true\";\n\t\tasFile.setFileName(dir.absolutePath() + \"/\" + newFileNameInfo.fileName());\n\t\tqWarning() << \"  Storing to \" << asFile.fileName() << \" instead\";\n\t}\n\telse if (okToSaveToAbsolutePath && (newFileNameInfo.isAbsolute()))\n\t{\n\t\tasFile.setFileName(name);\n\t}\n\telse\n\t{\n\t\tasFile.setFileName(dir.absolutePath() + \"/\" + name);\n\t}\n\tif (!asFile.open(QIODevice::WriteOnly | QIODevice::Truncate | QIODevice::Text | QIODevice::Unbuffered))\n\t{\n\t\tqDebug() << \"ERROR: Cannot open file\" << asFile.fileName();\n\t\treturn;\n\t}\n\tqDebug() << \"saving copy of output.txt to \" << asFile.fileName();\n\tasFile.write(qPrintable(outputText), outputText.size());\n\tasFile.close();\n}", "target": 0}
{"code": "xmalloc (size_t size)\n{\n    void *ptr = malloc (size);\n    if (!ptr \n        && (size != 0))         \n    {\n        perror (\"xmalloc: Memory allocation failure\");\n        abort();\n    }\n    return ptr;\n}", "target": 1}
{"code": "static int keyring_search_iterator(const void *object, void *iterator_data)\n{\n\tstruct keyring_search_context *ctx = iterator_data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\tunsigned long kflags = key->flags;\n\tkenter(\"{%d}\", key->serial);\n\tif (key->type != ctx->index_key.type) {\n\t\tkleave(\" = 0 [!type]\");\n\t\treturn 0;\n\t}\n\tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n\t\tif (kflags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED))) {\n\t\t\tctx->result = ERR_PTR(-EKEYREVOKED);\n\t\t\tkleave(\" = %d [invrev]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t\tif (key->expiry && ctx->now.tv_sec >= key->expiry) {\n\t\t\tif (!(ctx->flags & KEYRING_SEARCH_SKIP_EXPIRED))\n\t\t\t\tctx->result = ERR_PTR(-EKEYEXPIRED);\n\t\t\tkleave(\" = %d [expire]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t}\n\tif (!ctx->match_data.cmp(key, &ctx->match_data)) {\n\t\tkleave(\" = 0 [!match]\");\n\t\treturn 0;\n\t}\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&\n\t    key_task_permission(make_key_ref(key, ctx->possessed),\n\t\t\t\tctx->cred, KEY_NEED_SEARCH) < 0) {\n\t\tctx->result = ERR_PTR(-EACCES);\n\t\tkleave(\" = %d [!perm]\", ctx->skipped_ret);\n\t\tgoto skipped;\n\t}\n\tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n\t\tif (kflags & (1 << KEY_FLAG_NEGATIVE)) {\n\t\t\tsmp_rmb();\n\t\t\tctx->result = ERR_PTR(key->reject_error);\n\t\t\tkleave(\" = %d [neg]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t}\n\tctx->result = make_key_ref(key, ctx->possessed);\n\tkleave(\" = 1 [found]\");\n\treturn 1;\nskipped:\n\treturn ctx->skipped_ret;\n}", "target": 1}
{"code": "  QInt32() {}", "target": 1}
{"code": "int module_load(\n    YR_SCAN_CONTEXT* context,\n    YR_OBJECT* module_object,\n    void* module_data,\n    size_t module_data_size)\n{\n  set_integer(1, module_object, \"constants.one\");\n  set_integer(2, module_object, \"constants.two\");\n  set_string(\"foo\", module_object, \"constants.foo\");\n  set_string(\"\", module_object, \"constants.empty\");\n  set_integer(1, module_object, \"struct_array[1].i\");\n  set_integer(0, module_object, \"integer_array[%i]\", 0);\n  set_integer(1, module_object, \"integer_array[%i]\", 1);\n  set_integer(2, module_object, \"integer_array[%i]\", 2);\n  set_integer(256, module_object, \"integer_array[%i]\", 256);\n  set_string(\"foo\", module_object, \"string_array[%i]\", 0);\n  set_string(\"bar\", module_object, \"string_array[%i]\", 1);\n  set_string(\"baz\", module_object, \"string_array[%i]\", 2);\n  set_sized_string(\"foo\\0bar\", 7, module_object, \"string_array[%i]\", 3);\n  set_string(\"foo\", module_object, \"string_dict[%s]\", \"foo\");\n  set_string(\"bar\", module_object, \"string_dict[\\\"bar\\\"]\");\n  set_string(\"foo\", module_object, \"struct_dict[%s].s\", \"foo\");\n  set_integer(1, module_object, \"struct_dict[%s].i\", \"foo\");\n  return ERROR_SUCCESS;\n}", "target": 0}
{"code": "void nf_tables_activate_set(const struct nft_ctx *ctx, struct nft_set *set)\n{\n\tif (nft_set_is_anonymous(set))\n\t\tnft_clear(ctx->net, set);\n\tset->use++;\n}", "target": 0}
{"code": "static int floppy_raw_cmd_ioctl(int type, int drive, int cmd,\n\t\t\t\tvoid __user *param)\n{\n\tint ret;\n\tpr_warn_once(\"Note: FDRAWCMD is deprecated and will be removed from the kernel in the near future.\\n\");\n\tif (type)\n\t\treturn -EINVAL;\n\tif (lock_fdc(drive))\n\t\treturn -EINTR;\n\tset_floppy(drive);\n\tret = raw_cmd_ioctl(cmd, param);\n\tif (ret == -EINTR)\n\t\treturn -EINTR;\n\tprocess_fd_request();\n\treturn ret;\n}", "target": 0}
{"code": "cib_remote_callback_dispatch(gpointer user_data)\n{\n    cib_t *cib = user_data;\n    cib_remote_opaque_t *private = cib->variant_opaque;\n    xmlNode *msg = NULL;\n    int disconnected = 0;\n    crm_info(\"Message on callback channel\");\n    crm_recv_remote_msg(private->callback.session, &private->callback.recv_buf, private->callback.encrypted, -1, &disconnected);\n    msg = crm_parse_remote_buffer(&private->callback.recv_buf);\n    while (msg) {\n        const char *type = crm_element_value(msg, F_TYPE);\n        crm_trace(\"Activating %s callbacks...\", type);\n        if (safe_str_eq(type, T_CIB)) {\n            cib_native_callback(cib, msg, 0, 0);\n        } else if (safe_str_eq(type, T_CIB_NOTIFY)) {\n            g_list_foreach(cib->notify_list, cib_native_notify, msg);\n        } else {\n            crm_err(\"Unknown message type: %s\", type);\n        }\n        free_xml(msg);\n        msg = crm_parse_remote_buffer(&private->callback.recv_buf);\n    }\n    if (disconnected) {\n        return -1;\n    }\n    return 0;\n}", "target": 0}
{"code": "void pid_ns_release_proc(struct pid_namespace *ns)\n{\n\tmntput(ns->proc_mnt);\n}", "target": 1}
{"code": "sraSpanRemove(sraSpan *span) {\n  span->_prev->_next = span->_next;\n  span->_next->_prev = span->_prev;\n}", "target": 1}
{"code": "static Variant HHVM_FUNCTION(simplexml_import_dom,\n  const Object& node,\n  const String& class_name ) {\n  auto domnode = Native::data<DOMNode>(node);\n  xmlNodePtr nodep = domnode->nodep();\n  if (nodep) {\n    if (nodep->doc == nullptr) {\n      raise_warning(\"Imported Node must have associated Document\");\n      return init_null();\n    }\n    if (nodep->type == XML_DOCUMENT_NODE ||\n        nodep->type == XML_HTML_DOCUMENT_NODE) {\n      nodep = xmlDocGetRootElement((xmlDocPtr) nodep);\n    }\n  }\n  if (nodep && nodep->type == XML_ELEMENT_NODE) {\n    auto cls = class_from_name(class_name, \"simplexml_import_dom\");\n    if (!cls) {\n      return init_null();\n    }\n    Object obj = create_object(cls->nameStr(), Array(), false);\n    auto sxe = Native::data<SimpleXMLElement>(obj.get());\n    sxe->node = libxml_register_node(nodep);\n    return obj;\n  } else {\n    raise_warning(\"Invalid Nodetype to import\");\n    return init_null();\n  }\n  return false;\n}", "target": 1}
{"code": "bsg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct bsg_device *bd = file->private_data;\n\tssize_t bytes_written;\n\tint ret;\n\tdprintk(\"%s: write %Zd bytes\\n\", bd->name, count);\n\tif (unlikely(segment_eq(get_fs(), KERNEL_DS)))\n\t\treturn -EINVAL;\n\tbsg_set_block(bd, file);\n\tbytes_written = 0;\n\tret = __bsg_write(bd, buf, count, &bytes_written,\n\t\t\t  file->f_mode & FMODE_WRITE);\n\t*ppos = bytes_written;\n\tif (!bytes_written || err_block_err(ret))\n\t\tbytes_written = ret;\n\tdprintk(\"%s: returning %Zd\\n\", bd->name, bytes_written);\n\treturn bytes_written;\n}", "target": 0}
{"code": "int btrfs_check_dir_item_collision(struct btrfs_root *root, u64 dir,\n\t\t\t\t   const char *name, int name_len)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_dir_item *di;\n\tint data_size;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tstruct btrfs_path *path;\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tkey.objectid = dir;\n\tbtrfs_set_key_type(&key, BTRFS_DIR_ITEM_KEY);\n\tkey.offset = btrfs_name_hash(name, name_len);\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tdi = btrfs_match_dir_item_name(root, path, name, name_len);\n\tif (di) {\n\t\tret = -EEXIST;\n\t\tgoto out;\n\t}\n\tdata_size = sizeof(*di) + name_len + sizeof(struct btrfs_item);\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\tif (data_size + btrfs_item_size_nr(leaf, slot) +\n\t    sizeof(struct btrfs_item) > BTRFS_LEAF_DATA_SIZE(root)) {\n\t\tret = -EOVERFLOW;\n\t} else {\n\t\tret = 0;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}", "target": 0}
{"code": "fbStore_a1 (FbBits *bits, const CARD32 *values, int x, int width, miIndexedPtr indexed)\n{\n    int i;\n    for (i = 0; i < width; ++i) {\n        CARD32  *pixel = ((CARD32 *) bits) + ((i+x) >> 5);\n        CARD32  mask = FbStipMask((i+x) & 0x1f, 1);\n        CARD32 v = READ(values + i) & 0x80000000 ? mask : 0;\n        WRITE(pixel, (READ(pixel) & ~mask) | v);\n    }\n}", "target": 0}
{"code": "int io_msg_ring(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_msg *msg = io_kiocb_to_cmd(req, struct io_msg);\n\tint ret;\n\tret = -EBADFD;\n\tif (!io_is_uring_fops(req->file))\n\t\tgoto done;\n\tswitch (msg->cmd) {\n\tcase IORING_MSG_DATA:\n\t\tret = io_msg_ring_data(req);\n\t\tbreak;\n\tcase IORING_MSG_SEND_FD:\n\t\tret = io_msg_send_fd(req, issue_flags);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\ndone:\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_set_res(req, ret, 0);\n\tio_put_file(req->file);\n\treq->file = NULL;\n\treturn IOU_OK;\n}", "target": 1}
{"code": "char *redisProtocolToLuaType(lua_State *lua, char* reply) {\n    if (!lua_checkstack(lua, 5)) {\n        serverPanic(\"lua stack limit reach when parsing redis.call reply\");\n    }\n    char *p = reply;\n    switch(*p) {\n    case ':': p = redisProtocolToLuaType_Int(lua,reply); break;\n    case '$': p = redisProtocolToLuaType_Bulk(lua,reply); break;\n    case '+': p = redisProtocolToLuaType_Status(lua,reply); break;\n    case '-': p = redisProtocolToLuaType_Error(lua,reply); break;\n    case '*': p = redisProtocolToLuaType_Aggregate(lua,reply,*p); break;\n    case '%': p = redisProtocolToLuaType_Aggregate(lua,reply,*p); break;\n    case '~': p = redisProtocolToLuaType_Aggregate(lua,reply,*p); break;\n    case '_': p = redisProtocolToLuaType_Null(lua,reply); break;\n    case '#': p = redisProtocolToLuaType_Bool(lua,reply,p[1]); break;\n    case ',': p = redisProtocolToLuaType_Double(lua,reply); break;\n    }\n    return p;\n}", "target": 0}
{"code": "ieee80211_tx_h_multicast_ps_buf(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;\n\tstruct ps_data *ps;\n\tif (tx->sdata->vif.type == NL80211_IFTYPE_AP ||\n\t    tx->sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\n\t\tif (!tx->sdata->bss)\n\t\t\treturn TX_CONTINUE;\n\t\tps = &tx->sdata->bss->ps;\n\t} else if (ieee80211_vif_is_mesh(&tx->sdata->vif)) {\n\t\tps = &tx->sdata->u.mesh.ps;\n\t} else {\n\t\treturn TX_CONTINUE;\n\t}\n\tif (ieee80211_has_order(hdr->frame_control))\n\t\treturn TX_CONTINUE;\n\tif (tx->local->hw.flags & IEEE80211_HW_QUEUE_CONTROL)\n\t\tinfo->hw_queue = tx->sdata->vif.cab_queue;\n\tif (!atomic_read(&ps->num_sta_ps))\n\t\treturn TX_CONTINUE;\n\tinfo->flags |= IEEE80211_TX_CTL_SEND_AFTER_DTIM;\n\tif (!(tx->local->hw.flags & IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING))\n\t\treturn TX_CONTINUE;\n\tif (tx->local->total_ps_buffered >= TOTAL_MAX_TX_BUFFER)\n\t\tpurge_old_ps_buffers(tx->local);\n\tif (skb_queue_len(&ps->bc_buf) >= AP_MAX_BC_BUFFER) {\n\t\tps_dbg(tx->sdata,\n\t\t       \"BC TX buffer full - dropping the oldest frame\\n\");\n\t\tdev_kfree_skb(skb_dequeue(&ps->bc_buf));\n\t} else\n\t\ttx->local->total_ps_buffered++;\n\tskb_queue_tail(&ps->bc_buf, tx->skb);\n\treturn TX_QUEUED;\n}", "target": 0}
{"code": "static void fpm_child_init(struct fpm_worker_pool_s *wp) \n{\n\tfpm_globals.max_requests = wp->config->pm_max_requests;\n\tfpm_globals.listening_socket = dup(wp->listening_socket);\n\tif (0 > fpm_stdio_init_child(wp)  ||\n\t    0 > fpm_log_init_child(wp)    ||\n\t    0 > fpm_status_init_child(wp) ||\n\t    0 > fpm_unix_init_child(wp)   ||\n\t    0 > fpm_signals_init_child()  ||\n\t    0 > fpm_env_init_child(wp)    ||\n\t    0 > fpm_php_init_child(wp)) {\n\t\tzlog(ZLOG_ERROR, \"[pool %s] child failed to initialize\", wp->config->name);\n\t\texit(FPM_EXIT_SOFTWARE);\n\t}\n}", "target": 0}
{"code": "AUpvlist _af_pv_pointer (void *val)\n{\n\tAUpvlist\tret = AUpvnew(1);\n\tAUpvsetparam(ret, 0, 0);\n\tAUpvsetvaltype(ret, 0, AU_PVTYPE_PTR);\n\tAUpvsetval(ret, 0, &val);\n\treturn ret;\n}", "target": 0}
{"code": "static void bfq_idle_slice_timer_body(struct bfq_queue *bfqq)\n{\n\tstruct bfq_data *bfqd = bfqq->bfqd;\n\tenum bfqq_expiration reason;\n\tunsigned long flags;\n\tspin_lock_irqsave(&bfqd->lock, flags);\n\tbfq_clear_bfqq_wait_request(bfqq);\n\tif (bfqq != bfqd->in_service_queue) {\n\t\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\t\treturn;\n\t}\n\tif (bfq_bfqq_budget_timeout(bfqq))\n\t\treason = BFQQE_BUDGET_TIMEOUT;\n\telse if (bfqq->queued[0] == 0 && bfqq->queued[1] == 0)\n\t\treason = BFQQE_TOO_IDLE;\n\telse\n\t\tgoto schedule_dispatch;\n\tbfq_bfqq_expire(bfqd, bfqq, true, reason);\nschedule_dispatch:\n\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\tbfq_schedule_dispatch(bfqd);", "target": 1}
{"code": "int kvm_get_dirty_log(struct kvm *kvm,\n\t\t\tstruct kvm_dirty_log *log, int *is_dirty)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tint r, i, as_id, id;\n\tunsigned long n;\n\tunsigned long any = 0;\n\tr = -EINVAL;\n\tas_id = log->slot >> 16;\n\tid = (u16)log->slot;\n\tif (as_id >= KVM_ADDRESS_SPACE_NUM || id >= KVM_USER_MEM_SLOTS)\n\t\tgoto out;\n\tslots = __kvm_memslots(kvm, as_id);\n\tmemslot = id_to_memslot(slots, id);\n\tr = -ENOENT;\n\tif (!memslot->dirty_bitmap)\n\t\tgoto out;\n\tn = kvm_dirty_bitmap_bytes(memslot);\n\tfor (i = 0; !any && i < n/sizeof(long); ++i)\n\t\tany = memslot->dirty_bitmap[i];\n\tr = -EFAULT;\n\tif (copy_to_user(log->dirty_bitmap, memslot->dirty_bitmap, n))\n\t\tgoto out;\n\tif (any)\n\t\t*is_dirty = 1;\n\tr = 0;\nout:\n\treturn r;\n}", "target": 0}
{"code": "  void operator()(const CPUDevice& d, typename TTypes<T>::ConstVec input,\n                  const bool signed_input, const int num_bits,\n                  const bool range_given, Tensor* input_min_tensor,\n                  Tensor* input_max_tensor, QuantizerRoundMode round_mode,\n                  bool narrow_range, typename TTypes<T>::Vec out) {\n    QuantizeAndDequantizeOneScaleImpl<CPUDevice, T>::Compute(\n        d, input, signed_input, num_bits, range_given, input_min_tensor,\n        input_max_tensor, round_mode, narrow_range, out);\n  }", "target": 1}
{"code": "void CompactProtocolReader::readStringBody(StrType& str, int32_t size) {\n  if (static_cast<int32_t>(in_.length()) < size) {\n    if (!in_.canAdvance(size)) {\n      protocol::TProtocolException::throwTruncatedData();\n    }\n    str.reserve(size); \n  }\n  str.clear();\n  size_t size_left = size;\n  while (size_left > 0) {\n    auto data = in_.peekBytes();\n    auto data_avail = std::min(data.size(), size_left);\n    if (data.empty()) {\n      TProtocolException::throwExceededSizeLimit();\n    }\n    str.append((const char*)data.data(), data_avail);\n    size_left -= data_avail;\n    in_.skipNoAdvance(data_avail);\n  }\n}", "target": 0}
{"code": "bool ArcMemory::Seek(int64 Offset,int Method)\n{\n  if (!Loaded)\n    return false;\n  if (Method==SEEK_SET)\n    SeekPos=Min(Offset,ArcData.Size());\n  else\n    if (Method==SEEK_CUR || Method==SEEK_END)\n    {\n      if (Method==SEEK_END)\n        SeekPos=ArcData.Size();\n      SeekPos+=(uint64)Offset;\n      if (SeekPos>ArcData.Size())\n        SeekPos=Offset<0 ? 0 : ArcData.Size();\n    }\n  return true;\n}", "target": 0}
{"code": "gss_wrap_iov (minor_status,\n              context_handle,\n              conf_req_flag,\n              qop_req,\n              conf_state,\n              iov,\n              iov_count)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nint\t\t\tconf_req_flag;\ngss_qop_t\t\tqop_req;\nint *\t\t\tconf_state;\ngss_iov_buffer_desc  *\tiov;\nint\t\t\tiov_count;\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    status = val_wrap_iov_args(minor_status, context_handle,\n\t\t\t       conf_req_flag, qop_req,\n\t\t\t       conf_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech) {\n\tif (mech->gss_wrap_iov) {\n\t    status = mech->gss_wrap_iov(\n\t\t\t\t\tminor_status,\n\t\t\t\t\tctx->internal_ctx_id,\n\t\t\t\t\tconf_req_flag,\n\t\t\t\t\tqop_req,\n\t\t\t\t\tconf_state,\n\t\t\t\t\tiov,\n\t\t\t\t\tiov_count);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\treturn(status);\n    }\n    return (GSS_S_BAD_MECH);\n}", "target": 0}
{"code": "void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\tif (atomic_dec_and_lock_irqsave(&ucounts->count, &ucounts_lock, flags)) {\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\t\tput_user_ns(ucounts->ns);\n\t\tkfree(ucounts);\n\t}\n}", "target": 0}
{"code": "shutdown_mib(void)\n{\n    unload_all_mibs();\n    if (tree_top) {\n        if (tree_top->label)\n            SNMP_FREE(tree_top->label);\n        SNMP_FREE(tree_top);\n    }\n    tree_head = NULL;\n    Mib = NULL;\n    if (_mibindexes) {\n        int i;\n        for (i = 0; i < _mibindex; ++i)\n            SNMP_FREE(_mibindexes[i]);\n        free(_mibindexes);\n        _mibindex = 0;\n        _mibindex_max = 0;\n        _mibindexes = NULL;\n    }\n    if (Prefix != NULL && Prefix != &Standard_Prefix[0])\n        SNMP_FREE(Prefix);\n    if (Prefix)\n        Prefix = NULL;\n    SNMP_FREE(confmibs);\n    SNMP_FREE(confmibdir);\n}", "target": 1}
{"code": "ikev1_hash_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t const struct isakmp_gen *ext, u_int item_len _U_,\n\t\t const u_char *ep _U_, uint32_t phase _U_, uint32_t doi _U_,\n\t\t uint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_HASH)));\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_HASH)));\n\treturn NULL;\n}", "target": 0}
{"code": "int mnt_optstr_get_uid(const char *optstr, const char *name, uid_t *uid)\n{\n\tchar *value = NULL;\n\tsize_t valsz = 0;\n\tchar buf[sizeof(stringify_value(UINT64_MAX))];\n\tint rc;\n\tuint64_t num;\n\tassert(optstr);\n\tassert(name);\n\tassert(uid);\n\trc = mnt_optstr_get_option(optstr, name, &value, &valsz);\n\tif (rc != 0)\n\t\tgoto fail;\n\tif (valsz > sizeof(buf) - 1) {\n\t\trc = -ERANGE;\n\t\tgoto fail;\n\t}\n\tmem2strcpy(buf, value, valsz, sizeof(buf));\n\trc = ul_strtou64(buf, &num, 10);\n\tif (rc != 0)\n\t\tgoto fail;\n\tif (num > ULONG_MAX || (uid_t) num != num) {\n\t\trc = -ERANGE;\n\t\tgoto fail;\n\t}\n\t*uid = (uid_t) num;\n\treturn 0;\nfail:\n\tDBG(UTILS, ul_debug(\"failed to convert '%s'= to number [rc=%d]\", name, rc));\n\treturn rc;\n}", "target": 0}
{"code": "agoo_http_init() {\n    const char\t**kp = header_keys;\n    memset(&key_cache, 0, sizeof(struct _cache));\n    for (; NULL != *kp; kp++) {\n\tkey_set(*kp);\n    }\n}", "target": 1}
{"code": "static void cmd_sdbk(Sdb *db, const char *input) {\n\tchar *out = (input[0] == ' ')\n\t\t? sdb_querys (db, NULL, 0, input + 1)\n\t\t: sdb_querys (db, NULL, 0, \"*\");\n\tif (out) {\n\t\tr_cons_println (out);\n\t\tfree (out);\n\t} else {\n\t\tR_LOG_ERROR (\"Usage: ask [query]\");\n\t}\n}", "target": 1}
{"code": "guestfs___first_line_of_file (guestfs_h *g, const char *filename)\n{\n  CLEANUP_FREE char **lines = NULL; \n  int64_t size;\n  char *ret;\n  size = guestfs_filesize (g, filename);\n  if (size == -1)\n    return NULL;\n  if (size > MAX_SMALL_FILE_SIZE) {\n    error (g, _(\"size of %s is unreasonably large (%\" PRIi64 \" bytes)\"),\n           filename, size);\n    return NULL;\n  }\n  lines = guestfs_head_n (g, 1, filename);\n  if (lines == NULL)\n    return NULL;\n  if (lines[0] == NULL) {\n    guestfs___free_string_list (lines);\n    return safe_strdup (g, \"\");\n  }\n  ret = lines[0];               \n  return ret;\n}", "target": 1}
{"code": "storagePoolGetXMLDesc(virStoragePoolPtr pool,\n                      unsigned int flags)\n{\n    virStoragePoolObj *obj;\n    virStoragePoolDef *def;\n    virStoragePoolDef *newDef;\n    virStoragePoolDef *curDef;\n    char *ret = NULL;\n    virCheckFlags(VIR_STORAGE_XML_INACTIVE, NULL);\n    if (!(obj = virStoragePoolObjFromStoragePool(pool)))\n        return NULL;\n    def = virStoragePoolObjGetDef(obj);\n    newDef = virStoragePoolObjGetNewDef(obj);\n    if (virStoragePoolGetXMLDescEnsureACL(pool->conn, def) < 0)\n        goto cleanup;\n    if ((flags & VIR_STORAGE_XML_INACTIVE) && newDef)\n        curDef = newDef;\n    else\n        curDef = def;\n    ret = virStoragePoolDefFormat(curDef);\n cleanup:\n    virStoragePoolObjEndAPI(&obj);\n    return ret;\n}", "target": 0}
{"code": "HttpRequest::maybeCacheable()\n{\n    if (!flags.hostVerified && (flags.intercepted || flags.interceptTproxy))\n        return false;\n    switch (url.getScheme()) {\n    case AnyP::PROTO_HTTP:\n    case AnyP::PROTO_HTTPS:\n        if (!method.respMaybeCacheable())\n            return false;\n        if (!flags.ignoreCc && cache_control && cache_control->hasNoStore())\n            return false;\n        break;\n    case AnyP::PROTO_GOPHER:\n        if (!gopherCachable(this))\n            return false;\n        break;\n    case AnyP::PROTO_CACHE_OBJECT:\n        return false;\n    default:\n        break;\n    }\n    return true;\n}", "target": 1}
{"code": "void RtmpProtocol::handle_C1_complex(const char *data){\n    const char *c1_start = data + 1;\n    const char *schema_start = c1_start + 8;\n    char *digest_start;\n    try {\n        auto digest = get_C1_digest((uint8_t *) schema_start + C1_SCHEMA_SIZE, &digest_start);\n        string c1_joined(c1_start, C1_HANDSHARK_SIZE);\n        c1_joined.erase(digest_start - c1_start, C1_DIGEST_SIZE);\n        check_C1_Digest(digest, c1_joined);\n        send_complex_S0S1S2(0, digest);\n    } catch (std::exception &) {\n        try {\n            auto digest = get_C1_digest((uint8_t *) schema_start, &digest_start);\n            string c1_joined(c1_start, C1_HANDSHARK_SIZE);\n            c1_joined.erase(digest_start - c1_start, C1_DIGEST_SIZE);\n            check_C1_Digest(digest, c1_joined);\n            send_complex_S0S1S2(1, digest);\n        } catch (std::exception &) {\n            handle_C1_simple(data);\n        }\n    }\n}", "target": 0}
{"code": "long pipe_fcntl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct pipe_inode_info *pipe;\n\tlong ret;\n\tpipe = get_pipe_info(file);\n\tif (!pipe)\n\t\treturn -EBADF;\n\t__pipe_lock(pipe);\n\tswitch (cmd) {\n\tcase F_SETPIPE_SZ: {\n\t\tunsigned int size, nr_pages;\n\t\tsize = round_pipe_size(arg);\n\t\tnr_pages = size >> PAGE_SHIFT;\n\t\tret = -EINVAL;\n\t\tif (!nr_pages)\n\t\t\tgoto out;\n\t\tif (!capable(CAP_SYS_RESOURCE) && size > pipe_max_size) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t} else if ((too_many_pipe_buffers_hard(pipe->user) ||\n\t\t\t    too_many_pipe_buffers_soft(pipe->user)) &&\n\t\t           !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = pipe_set_size(pipe, nr_pages);\n\t\tbreak;\n\t\t}\n\tcase F_GETPIPE_SZ:\n\t\tret = pipe->buffers * PAGE_SIZE;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\nout:\n\t__pipe_unlock(pipe);\n\treturn ret;\n}", "target": 0}
{"code": "XML_GetFeatureList(void) {\n  static const XML_Feature features[] = {\n    {XML_FEATURE_SIZEOF_XML_CHAR, XML_L(\"sizeof(XML_Char)\"), sizeof(XML_Char)},\n    {XML_FEATURE_SIZEOF_XML_LCHAR, XML_L(\"sizeof(XML_LChar)\"),\n     sizeof(XML_LChar)},\n#ifdef XML_UNICODE\n    {XML_FEATURE_UNICODE, XML_L(\"XML_UNICODE\"), 0},\n#endif\n#ifdef XML_UNICODE_WCHAR_T\n    {XML_FEATURE_UNICODE_WCHAR_T, XML_L(\"XML_UNICODE_WCHAR_T\"), 0},\n#endif\n#ifdef XML_DTD\n    {XML_FEATURE_DTD, XML_L(\"XML_DTD\"), 0},\n#endif\n#if XML_CONTEXT_BYTES > 0\n    {XML_FEATURE_CONTEXT_BYTES, XML_L(\"XML_CONTEXT_BYTES\"), XML_CONTEXT_BYTES},\n#endif\n#ifdef XML_MIN_SIZE\n    {XML_FEATURE_MIN_SIZE, XML_L(\"XML_MIN_SIZE\"), 0},\n#endif\n#ifdef XML_NS\n    {XML_FEATURE_NS, XML_L(\"XML_NS\"), 0},\n#endif\n#ifdef XML_LARGE_SIZE\n    {XML_FEATURE_LARGE_SIZE, XML_L(\"XML_LARGE_SIZE\"), 0},\n#endif\n#ifdef XML_ATTR_INFO\n    {XML_FEATURE_ATTR_INFO, XML_L(\"XML_ATTR_INFO\"), 0},\n#endif\n#ifdef XML_DTD\n    {XML_FEATURE_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT,\n     XML_L(\"XML_BLAP_MAX_AMP\"),\n     (long int)\n         EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT},\n    {XML_FEATURE_BILLION_LAUGHS_ATTACK_PROTECTION_ACTIVATION_THRESHOLD_DEFAULT,\n     XML_L(\"XML_BLAP_ACT_THRES\"),\n     EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_ACTIVATION_THRESHOLD_DEFAULT},\n#endif\n    {XML_FEATURE_END, NULL, 0}\n  };\n  return features;\n}", "target": 1}
{"code": "static int vt_kdsetmode(struct vc_data *vc, unsigned long mode)\n{\n\tswitch (mode) {\n\tcase KD_GRAPHICS:\n\t\tbreak;\n\tcase KD_TEXT0:\n\tcase KD_TEXT1:\n\t\tmode = KD_TEXT;\n\t\tfallthrough;\n\tcase KD_TEXT:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (vc->vc_mode == mode)\n\t\treturn 0;\n\tvc->vc_mode = mode;\n\tif (vc->vc_num != fg_console)\n\t\treturn 0;\n\tconsole_lock();\n\tif (mode == KD_TEXT)\n\t\tdo_unblank_screen(1);\n\telse\n\t\tdo_blank_screen(1);\n\tconsole_unlock();\n\treturn 0;\n}", "target": 1}
{"code": "void FrameLoader::stopLoading(UnloadEventPolicy unloadEventPolicy, DatabasePolicy databasePolicy)\n{\n    if (m_frame->document() && m_frame->document()->tokenizer())\n        m_frame->document()->tokenizer()->stopParsing();\n    if (unloadEventPolicy != UnloadEventPolicyNone) {\n        if (m_frame->document()) {\n            if (m_didCallImplicitClose && !m_wasUnloadEventEmitted) {\n                Node* currentFocusedNode = m_frame->document()->focusedNode();\n                if (currentFocusedNode)\n                    currentFocusedNode->aboutToUnload();\n                m_unloadEventBeingDispatched = true;\n                if (m_frame->domWindow()) {\n                    if (unloadEventPolicy == UnloadEventPolicyUnloadAndPageHide)\n                        m_frame->domWindow()->dispatchEvent(PageTransitionEvent::create(EventNames().pagehideEvent, m_frame->document()->inPageCache()), m_frame->document());\n                    if (!m_frame->document()->inPageCache())\n                        m_frame->domWindow()->dispatchEvent(Event::create(eventNames().unloadEvent, false, false), m_frame->domWindow()->document());\n                }\n                m_unloadEventBeingDispatched = false;\n                if (m_frame->document())\n                    m_frame->document()->updateStyleIfNeeded();\n                m_wasUnloadEventEmitted = true;\n            }\n        }\n        if (m_frame->document() && !m_frame->document()->inPageCache()) {\n            bool keepEventListeners = m_isDisplayingInitialEmptyDocument && m_provisionalDocumentLoader\n                && m_frame->document()->securityOrigin()->isSecureTransitionTo(m_provisionalDocumentLoader->url());\n            if (!keepEventListeners)\n                m_frame->document()->removeAllEventListeners();\n        }\n    }\n    m_isComplete = true; \n    m_isLoadingMainResource = false;\n    m_didCallImplicitClose = true; \n    if (m_frame->document() && m_frame->document()->parsing()) {\n        finishedParsing();\n        m_frame->document()->setParsing(false);\n    }\n    m_workingURL = KURL();\n    if (Document* doc = m_frame->document()) {\n        if (DocLoader* docLoader = doc->docLoader())\n            cache()->loader()->cancelRequests(docLoader);\n#if ENABLE(DATABASE)\n        if (databasePolicy == DatabasePolicyStop)\n            doc->stopDatabases();\n#endif\n    }\n    for (Frame* child = m_frame->tree()->firstChild(); child; child = child->tree()->nextSibling())\n        child->loader()->stopLoading(unloadEventPolicy);\n    m_frame->redirectScheduler()->cancel();\n}", "target": 0}
{"code": "sf_open_virtual\t(SF_VIRTUAL_IO *sfvirtual, int mode, SF_INFO *sfinfo, void *user_data)\n{\tSF_PRIVATE \t*psf ;\n\tif (sfvirtual->get_filelen == NULL || sfvirtual->seek == NULL || sfvirtual->tell == NULL)\n\t{\tsf_errno = SFE_BAD_VIRTUAL_IO ;\n\t\tsnprintf (sf_parselog, sizeof (sf_parselog), \"Bad vio_get_filelen / vio_seek / vio_tell in SF_VIRTUAL_IO struct.\\n\") ;\n\t\treturn NULL ;\n\t\t} ;\n\tif ((mode == SFM_READ || mode == SFM_RDWR) && sfvirtual->read == NULL)\n\t{\tsf_errno = SFE_BAD_VIRTUAL_IO ;\n\t\tsnprintf (sf_parselog, sizeof (sf_parselog), \"Bad vio_read in SF_VIRTUAL_IO struct.\\n\") ;\n\t\treturn NULL ;\n\t\t} ;\n\tif ((mode == SFM_WRITE || mode == SFM_RDWR) && sfvirtual->write == NULL)\n\t{\tsf_errno = SFE_BAD_VIRTUAL_IO ;\n\t\tsnprintf (sf_parselog, sizeof (sf_parselog), \"Bad vio_write in SF_VIRTUAL_IO struct.\\n\") ;\n\t\treturn NULL ;\n\t\t} ;\n\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\tpsf_init_files (psf) ;\n\tpsf->virtual_io = SF_TRUE ;\n\tpsf->vio = *sfvirtual ;\n\tpsf->vio_user_data = user_data ;\n\tpsf->file.mode = mode ;\n\treturn psf_open_file (psf, sfinfo) ;\n} ", "target": 1}
{"code": "static int fit_image_verify_sig(const void *fit, int image_noffset,\n\t\t\t\tconst char *data, size_t size,\n\t\t\t\tconst void *sig_blob, int sig_offset)\n{\n\tint noffset;\n\tchar *err_msg = \"\";\n\tint verified = 0;\n\tint ret;\n\tfdt_for_each_subnode(noffset, fit, image_noffset) {\n\t\tconst char *name = fit_get_name(fit, noffset, NULL);\n\t\tif (strchr(name, '@')) {\n\t\t\terr_msg = \"Node name contains @\";\n\t\t\tgoto error;\n\t\t}\n\t\tif (!strncmp(name, FIT_SIG_NODENAME,\n\t\t\t     strlen(FIT_SIG_NODENAME))) {\n\t\t\tret = fit_image_check_sig(fit, noffset, data,\n\t\t\t\t\t\t  size, -1, &err_msg);\n\t\t\tif (ret) {\n\t\t\t\tputs(\"- \");\n\t\t\t} else {\n\t\t\t\tputs(\"+ \");\n\t\t\t\tverified = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (noffset == -FDT_ERR_TRUNCATED || noffset == -FDT_ERR_BADSTRUCTURE) {\n\t\terr_msg = \"Corrupted or truncated tree\";\n\t\tgoto error;\n\t}\n\treturn verified ? 0 : -EPERM;\nerror:\n\tprintf(\" error!\\n%s for '%s' hash node in '%s' image node\\n\",\n\t       err_msg, fit_get_name(fit, noffset, NULL),\n\t       fit_get_name(fit, image_noffset, NULL));\n\treturn -1;\n}", "target": 0}
{"code": "comics_document_finalize (GObject *object)\n{\n\tComicsDocument *comics_document = COMICS_DOCUMENT (object);\n\tif (comics_document->decompress_tmp) {\n\t\tif (comics_remove_dir (comics_document->dir) == -1)\n\t\t\tg_warning (_(\"There was an error deleting %s.\"),\n\t\t\t\t   comics_document->dir);\n\t\tg_free (comics_document->dir);\n\t}\n\tif (comics_document->page_names) {\n                g_ptr_array_foreach (comics_document->page_names, (GFunc) g_free, NULL);\n                g_ptr_array_free (comics_document->page_names, TRUE);\n\t}\n\tg_free (comics_document->archive);\n\tg_free (comics_document->selected_command);\n\tg_free (comics_document->alternative_command);\n\tg_free (comics_document->extract_command);\n\tg_free (comics_document->list_command);\n\tG_OBJECT_CLASS (comics_document_parent_class)->finalize (object);\n}", "target": 1}
{"code": "compat_pkalg_proposal(struct ssh *ssh, char *pkalg_prop)\n{\n\tif (!(ssh->compat & SSH_BUG_RSASIGMD5))\n\t\treturn pkalg_prop;\n\tdebug2_f(\"original public key proposal: %s\", pkalg_prop);\n\tif ((pkalg_prop = match_filter_denylist(pkalg_prop, \"ssh-rsa\")) == NULL)\n\t\tfatal(\"match_filter_denylist failed\");\n\tdebug2_f(\"compat public key proposal: %s\", pkalg_prop);\n\tif (*pkalg_prop == '\\0')\n\t\tfatal(\"No supported PK algorithms found\");\n\treturn pkalg_prop;\n}", "target": 1}
{"code": "absl::Status Ipv4Instance::validateProtocolSupported() {\n  static const bool supported = SocketInterfaceSingleton::get().ipFamilySupported(AF_INET);\n  if (supported) {\n    return absl::OkStatus();\n  }\n  return absl::FailedPreconditionError(\"IPv4 addresses are not supported on this machine\");\n}", "target": 1}
{"code": "  llvh::ArrayRef<hbc::HBCExceptionHandlerInfo> getExceptionTable(\n      uint32_t) const override {\n    llvm_unreachable(\"Accessing exception info from a lazy module\");\n  }", "target": 1}
{"code": "static void ok_jpg_idct_16x16(const int16_t *input, uint8_t *output) {\n    int temp[8 * 16];\n    ok_jpg_idct_1d_col_16(input, temp);\n    ok_jpg_idct_1d_row_16(16, temp, output);\n}", "target": 0}
{"code": "  Status ValidateInputTensor(const Tensor& tensor,\n                             const std::string& tensor_name,\n                             const Tensor& rhs) {\n    const int ndims = rhs.dims();\n    if (tensor.dims() != ndims) {\n      return errors::InvalidArgument(tensor_name,\n                                     \" must have same rank as rhs, but got \",\n                                     tensor.dims(), \" and \", ndims);\n    }\n    for (int i = 0; i < ndims - 2; i++) {\n      if (tensor.dim_size(i) != rhs.dim_size(i)) {\n        return errors::InvalidArgument(\n            tensor_name,\n            \" must have same outer dimensions as rhs, but for index \", i,\n            \", got \", tensor.dim_size(i), \" and \", rhs.dim_size(i));\n      }\n    }\n    if (tensor.dim_size(ndims - 2) != 1) {\n      return errors::InvalidArgument(\n          tensor_name, \"'s second-to-last dimension must be 1, but got \",\n          tensor.dim_size(ndims - 2));\n    }\n    if (tensor.dim_size(ndims - 1) != rhs.dim_size(ndims - 2)) {\n      return errors::InvalidArgument(tensor_name,\n                                     \"'s last dimension size must be rhs's \"\n                                     \"second-to-last dimension size, but got \",\n                                     tensor.dim_size(ndims - 1), \" and \",\n                                     rhs.dim_size(ndims - 2));\n    }\n    return Status::OK();\n  }", "target": 0}
{"code": "static inline int handle_dots(struct nameidata *nd, int type)\n{\n\tif (type == LAST_DOTDOT) {\n\t\tif (nd->flags & LOOKUP_RCU) {\n\t\t\treturn follow_dotdot_rcu(nd);\n\t\t} else\n\t\t\tfollow_dotdot(nd);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "int lxc_switch_uid_gid(uid_t uid, gid_t gid)\n{\n\tif (setgid(gid) < 0) {\n\t\tSYSERROR(\"Failed to switch to gid %d.\", gid);\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Switched to gid %d.\", gid);\n\tif (setuid(uid) < 0) {\n\t\tSYSERROR(\"Failed to switch to uid %d.\", uid);\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Switched to uid %d.\", uid);\n\treturn 0;\n}", "target": 0}
{"code": "static void init_timeout(void *arg)\n{\n\tint local_port = *(int *)arg;\n\tinfo(\"init_timeout: srv_init\\n\");\n\tsrv_init((uint16_t)local_port);\n}", "target": 0}
{"code": "TEST_F(GroupVerifierTest, TestRequiresAnyWithAllowMissingButOk) {\n  TestUtility::loadFromYaml(RequiresAnyConfig, proto_config_);\n  proto_config_.mutable_rules(0)\n      ->mutable_requires()\n      ->mutable_requires_any()\n      ->add_requirements()\n      ->mutable_allow_missing();\n  createAsyncMockAuthsAndVerifier(std::vector<std::string>{\"example_provider\", \"other_provider\"});\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  callbacks_[\"example_provider\"](Status::JwtMissed);\n  callbacks_[\"other_provider\"](Status::JwtUnknownIssuer);\n}", "target": 1}
{"code": "AP_CORE_DECLARE_NONSTD(const char *) ap_limit_section(cmd_parms *cmd,\n                                                      void *dummy,\n                                                      const char *arg)\n{\n    const char *endp = ap_strrchr_c(arg, '>');\n    const char *limited_methods;\n    void *tog = cmd->cmd->cmd_data;\n    apr_int64_t limited = 0;\n    apr_int64_t old_limited = cmd->limited;\n    const char *errmsg;\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n    limited_methods = apr_pstrmemdup(cmd->temp_pool, arg, endp - arg);\n    if (!limited_methods[0]) {\n        return missing_container_arg(cmd);\n    }\n    while (limited_methods[0]) {\n        char *method = ap_getword_conf(cmd->temp_pool, &limited_methods);\n        int methnum;\n        methnum = ap_method_number_of(method);\n        if (methnum == M_TRACE && !tog) {\n            return \"TRACE cannot be controlled by <Limit>, see TraceEnable\";\n        }\n        else if (methnum == M_INVALID) {\n            if (cmd->pool == cmd->temp_pool) {\n                return apr_psprintf(cmd->pool, \"Could not register method '%s' \"\n                                   \"for %s from .htaccess configuration\",\n                                    method, cmd->cmd->name);\n            }\n            methnum = ap_method_register(cmd->pool,\n                                         apr_pstrdup(cmd->pool, method));\n        }\n        limited |= (AP_METHOD_BIT << methnum);\n    }\n    limited = tog ? ~limited : limited;\n    if (!(old_limited & limited)) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive excludes all methods\", NULL);\n    }\n    else if ((old_limited & limited) == old_limited) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive specifies methods already excluded\",\n                           NULL);\n    }\n    cmd->limited &= limited;\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, cmd->context);\n    cmd->limited = old_limited;\n    return errmsg;\n}", "target": 0}
{"code": "void BezierCircle(double r,char *action)\n{\n    char *outpos = outputbuffer;\n    outpos +=\n    sprintf(outpos,\" %12.3f 0 m %12.3f %12.3f %12.3f %12.3f 0 %12.3f c\\n\",-r,-r,r*BzK,-r*BzK,r,r);\n    outpos +=\n    sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f %12.3f 0 c\\n\",r*BzK,r,r,r*BzK,r);\n    outpos +=\n    sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f 0 %12.3f c\\n\",r,-r*BzK,r*BzK,-r,-r);\n    outpos +=\n    sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f %12.3f 0 c %s\\n\",-r*BzK,-r,-r,-r*BzK,-r,action);\n    sendClean(outputbuffer);\n}", "target": 0}
{"code": "int xstateregs_set(struct task_struct *target, const struct user_regset *regset,\n\t\t  unsigned int pos, unsigned int count,\n\t\t  const void *kbuf, const void __user *ubuf)\n{\n\tstruct fpu *fpu = &target->thread.fpu;\n\tstruct xregs_state *xsave;\n\tint ret;\n\tif (!boot_cpu_has(X86_FEATURE_XSAVE))\n\t\treturn -ENODEV;\n\tif ((pos != 0) || (count < fpu_user_xstate_size))\n\t\treturn -EFAULT;\n\txsave = &fpu->state.xsave;\n\tfpu__activate_fpstate_write(fpu);\n\tif (boot_cpu_has(X86_FEATURE_XSAVES)) {\n\t\tif (kbuf)\n\t\t\tret = copy_kernel_to_xstate(xsave, kbuf);\n\t\telse\n\t\t\tret = copy_user_to_xstate(xsave, ubuf);\n\t} else {\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, xsave, 0, -1);\n\t\tif (!ret && xsave->header.xcomp_bv)\n\t\t\tret = -EINVAL;\n\t}\n\tif (ret)\n\t\tfpstate_init(&fpu->state);\n\txsave->i387.mxcsr &= mxcsr_feature_mask;\n\txsave->header.xfeatures &= xfeatures_mask;\n\tmemset(&xsave->header.reserved, 0, 48);\n\treturn ret;\n}", "target": 0}
{"code": "static int lsm_set_label_at(int lsm_labelfd, int on_exec, char *lsm_label)\n{\n\tint fret = -1;\n\tconst char* name;\n\tchar *command = NULL;\n\tname = lsm_name();\n\tif (strcmp(name, \"nop\") == 0)\n\t\treturn 0;\n\tif (strcmp(name, \"none\") == 0)\n\t\treturn 0;\n\tif (strcmp(name, \"AppArmor\") == 0)\n\t\ton_exec = 0;\n\tif (strcmp(name, \"AppArmor\") == 0) {\n\t\tint size;\n\t\tcommand = malloc(strlen(lsm_label) + strlen(\"changeprofile \") + 1);\n\t\tif (!command) {\n\t\t\tSYSERROR(\"Failed to write apparmor profile\");\n\t\t\tgoto out;\n\t\t}\n\t\tsize = sprintf(command, \"changeprofile %s\", lsm_label);\n\t\tif (size < 0) {\n\t\t\tSYSERROR(\"Failed to write apparmor profile\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (write(lsm_labelfd, command, size + 1) < 0) {\n\t\t\tSYSERROR(\"Unable to set LSM label: %s.\", command);\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Set LSM label to: %s.\", command);\n\t} else if (strcmp(name, \"SELinux\") == 0) {\n\t\tif (write(lsm_labelfd, lsm_label, strlen(lsm_label) + 1) < 0) {\n\t\t\tSYSERROR(\"Unable to set LSM label\");\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Set LSM label to: %s.\", lsm_label);\n\t} else {\n\t\tERROR(\"Unable to restore label for unknown LSM: %s\", name);\n\t\tgoto out;\n\t}\n\tfret = 0;\nout:\n\tfree(command);\n\tif (lsm_labelfd != -1)\n\t\tclose(lsm_labelfd);\n\treturn fret;\n}", "target": 0}
{"code": "UpdatePinhole(struct upnphttp * h, const char * action, const char * ns)\n{\n#if 0\n\tstatic const char resp[] =\n\t\t\"<u:UpdatePinholeResponse \"\n\t\t\"xmlns:u=\\\"urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\\\">\"\n\t\t\"</u:UpdatePinholeResponse>\";\n#endif\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"</u:%sResponse>\";\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tconst char * uid_str, * leaseTime;\n\tchar iaddr[INET6_ADDRSTRLEN];\n\tunsigned short iport;\n\tint ltime;\n\tint uid;\n\tint n;\n\tif(CheckStatus(h)==0)\n\t\treturn;\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tuid_str = GetValueFromNameValueList(&data, \"UniqueID\");\n\tleaseTime = GetValueFromNameValueList(&data, \"NewLeaseTime\");\n\tuid = uid_str ? atoi(uid_str) : -1;\n\tltime = leaseTime ? atoi(leaseTime) : -1;\n\tClearNameValueList(&data);\n\tif(uid < 0 || uid > 65535 || ltime <= 0 || ltime > 86400)\n\t{\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\tn = upnp_get_pinhole_info(uid, NULL, 0, NULL,\n\t                          iaddr, sizeof(iaddr), &iport,\n\t                          NULL, \n\t                          NULL, 0, \n\t                          NULL, NULL);\n\tif (n >= 0)\n\t{\n\t\tif(PinholeVerification(h, iaddr, iport) <= 0)\n\t\t\treturn;\n\t}\n\telse if(n == -2)\n\t{\n\t\tSoapError(h, 704, \"NoSuchEntry\");\n\t\treturn;\n\t}\n\telse\n\t{\n\t\tSoapError(h, 501, \"ActionFailed\");\n\t\treturn;\n\t}\n\tsyslog(LOG_INFO, \"%s: (inbound) updating lease duration to %d for pinhole with ID: %d\",\n\t       action, ltime, uid);\n\tn = upnp_update_inboundpinhole(uid, ltime);\n\tif(n == -1)\n\t\tSoapError(h, 704, \"NoSuchEntry\");\n\telse if(n < 0)\n\t\tSoapError(h, 501, \"ActionFailed\");\n\telse {\n\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t                   action, ns, action);\n\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t}\n}", "target": 0}
{"code": "bool setCtbAddrFromTS(thread_context* tctx)\n{\n  const seq_parameter_set& sps = tctx->img->get_sps();\n  if (tctx->CtbAddrInTS < sps.PicSizeInCtbsY) {\n    tctx->CtbAddrInRS = tctx->img->get_pps().CtbAddrTStoRS[tctx->CtbAddrInTS];\n    tctx->CtbX = tctx->CtbAddrInRS % sps.PicWidthInCtbsY;\n    tctx->CtbY = tctx->CtbAddrInRS / sps.PicWidthInCtbsY;\n    return false;\n  }\n  else {\n    tctx->CtbAddrInRS = sps.PicSizeInCtbsY;\n    tctx->CtbX = tctx->CtbAddrInRS % sps.PicWidthInCtbsY;\n    tctx->CtbY = tctx->CtbAddrInRS / sps.PicWidthInCtbsY;\n    return true;\n  }\n}", "target": 0}
{"code": "static GF_Err mp4_mux_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tGF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);\n\tif (is_remove) {\n\t\tTrackWriter *tkw = gf_filter_pid_get_udta(pid);\n\t\tif (tkw) {\n\t\t\tgf_list_del_item(ctx->tracks, tkw);\n\t\t\tif (ctx->ref_tkw == tkw) ctx->ref_tkw = gf_list_get(ctx->tracks, 0);\n\t\t\tgf_free(tkw);\n\t\t}\n\t\tif (ctx->opid && !gf_list_count(ctx->tracks)) {\n\t\t\tif (ctx->file) {\n\t\t\t\tif (!ctx->init_movie_done) {\n\t\t\t\t\tmp4_mux_done(ctx, GF_TRUE);\n\t\t\t\t}\n\t\t\t} else {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\twhile (ctx->flush_size) {\n\t\t\t\t\tGF_Err e = mp4_mux_flush_fragmented(ctx);\n\t\t\t\t\tif (e) break;\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t\tgf_filter_pid_remove(ctx->opid);\n\t\t\tctx->opid = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\treturn mp4_mux_setup_pid(filter, pid, GF_TRUE);\n}", "target": 0}
{"code": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !inode_capable(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !inode_capable(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !inode_capable(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "njs_function_frame_free(njs_vm_t *vm, njs_native_frame_t *native)\n{\n    njs_native_frame_t  *previous;\n    do {\n        previous = native->previous;\n        if (native->size != 0) {\n            vm->stack_size -= native->size;\n            njs_mp_free(vm->mem_pool, native);\n        }\n        native = previous;\n    } while (native->skip);\n}", "target": 0}
{"code": "AP_DECLARE(int) ap_update_vhost_from_headers_ex(request_rec *r, int require_match)\n{\n    core_server_config *conf = ap_get_core_module_config(r->server->module_config);\n    const char *host_header = apr_table_get(r->headers_in, \"Host\");\n    int is_v6literal = 0;\n    int have_hostname_from_url = 0;\n    int rc = HTTP_OK;\n    if (r->hostname) {\n        have_hostname_from_url = 1;\n        is_v6literal = fix_hostname(r, NULL, conf->http_conformance);\n    }\n    else if (host_header != NULL) {\n        is_v6literal = fix_hostname(r, host_header, conf->http_conformance);\n    }\n    if (!require_match && r->status != HTTP_OK)\n        return HTTP_OK;\n    if (conf->http_conformance != AP_HTTP_CONFORMANCE_UNSAFE) {\n        if (have_hostname_from_url && host_header != NULL) {\n            const char *repl = construct_host_header(r, is_v6literal);\n            apr_table_setn(r->headers_in, \"Host\", repl);\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02417)\n                          \"Replacing host header '%s' with host '%s' given \"\n                          \"in the request uri\", host_header, repl);\n        }\n    }\n    if (r->connection->vhost_lookup_data) {\n        if (r->hostname)\n            rc = update_server_from_aliases(r);\n        else\n            check_serverpath(r);\n    }\n    else if (require_match && r->hostname) { \n        rc = update_server_from_aliases(r);\n    }\n    return rc;\n}", "target": 0}
{"code": "static const char *virtualhost_section(cmd_parms *cmd, void *dummy,\n                                       const char *arg)\n{\n    server_rec *main_server = cmd->server, *s;\n    const char *errmsg;\n    const char *endp = ap_strrchr_c(arg, '>');\n    apr_pool_t *p = cmd->pool;\n    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);\n    if (err != NULL) {\n        return err;\n    }\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n    arg = apr_pstrndup(cmd->temp_pool, arg, endp - arg);\n    if (!arg[0]) {\n        return missing_container_arg(cmd);\n    }\n    if (main_server->is_virtual) {\n        return \"<VirtualHost> doesn't nest!\";\n    }\n    errmsg = ap_init_virtual_host(p, arg, main_server, &s);\n    if (errmsg) {\n        return errmsg;\n    }\n    s->next = main_server->next;\n    main_server->next = s;\n    s->defn_name = cmd->directive->filename;\n    s->defn_line_number = cmd->directive->line_num;\n    cmd->server = s;\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd,\n                            s->lookup_defaults);\n    cmd->server = main_server;\n    return errmsg;\n}", "target": 0}
{"code": "sread(int fd, void *buf, size_t n, int canbepipe)\n{\n\tssize_t rv;\n#ifdef FIONREAD\n\tint t = 0;\n#endif\n\tsize_t rn = n;\n\tif (fd == STDIN_FILENO)\n\t\tgoto nocheck;\n#ifdef FIONREAD\n\tif (canbepipe && (ioctl(fd, FIONREAD, &t) == -1 || t == 0)) {\n#ifdef FD_ZERO\n\t\tssize_t cnt;\n\t\tfor (cnt = 0;; cnt++) {\n\t\t\tfd_set check;\n\t\t\tstruct timeval tout = {0, 100 * 1000};\n\t\t\tint selrv;\n\t\t\tFD_ZERO(&check);\n\t\t\tFD_SET(fd, &check);\n\t\t\tselrv = select(fd + 1, &check, NULL, NULL, &tout);\n\t\t\tif (selrv == -1) {\n\t\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\t\tcontinue;\n\t\t\t} else if (selrv == 0 && cnt >= 5) {\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n#endif\n\t\t(void)ioctl(fd, FIONREAD, &t);\n\t}\n\tif (t > 0 && (size_t)t < n) {\n\t\tn = t;\n\t\trn = n;\n\t}\n#endif\nnocheck:\n\tdo\n\t\tswitch ((rv = FINFO_READ_FUNC(fd, buf, n))) {\n\t\tcase -1:\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\treturn -1;\n\t\tcase 0:\n\t\t\treturn rn - n;\n\t\tdefault:\n\t\t\tn -= rv;\n\t\t\tbuf = ((char *)buf) + rv;\n\t\t\tbreak;\n\t\t}\n\twhile (n > 0);\n\treturn rn;\n}", "target": 0}
{"code": "l2tp_proto_ver_print(netdissect_options *ndo, const uint16_t *dat)\n{\n\tND_PRINT((ndo, \"%u.%u\", (EXTRACT_16BITS(dat) >> 8),\n\t    (EXTRACT_16BITS(dat) & 0xff)));\n}", "target": 1}
{"code": "static inline void tss_invalidate_io_bitmap(struct tss_struct *tss)\n{\n\ttss->x86_tss.io_bitmap_base = IO_BITMAP_OFFSET_INVALID;\n}", "target": 1}
{"code": "static int __init acpi_os_name_setup(char *str)\n{\n\tchar *p = acpi_os_name;\n\tint count = ACPI_MAX_OVERRIDE_LEN - 1;\n\tif (!str || !*str)\n\t\treturn 0;\n\tfor (; count-- && *str; str++) {\n\t\tif (isalnum(*str) || *str == ' ' || *str == ':')\n\t\t\t*p++ = *str;\n\t\telse if (*str == '\\'' || *str == '\"')\n\t\t\tcontinue;\n\t\telse\n\t\t\tbreak;\n\t}\n\t*p = 0;\n\treturn 1;\n}", "target": 0}
{"code": "find_entry2modify_only_ext(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n    int flags,\n    back_txn *txn\n)\n{\n\treturn( find_entry_internal( pb, be, addr, 1, txn, \n\t\t                         FE_REALLY_INTERNAL | flags ));\n}", "target": 1}
{"code": "setup_wait_limits(struct infra_cache* infra, struct config_file* cfg)\n{\n\taddr_tree_init(&infra->wait_limits_netblock);\n\taddr_tree_init(&infra->wait_limits_cookie_netblock);\n\tif(!infra_wait_limit_netblock_insert(infra, cfg))\n\t\treturn 0;\n\taddr_tree_init_parents(&infra->wait_limits_netblock);\n\taddr_tree_init_parents(&infra->wait_limits_cookie_netblock);\n\treturn 1;\n}", "target": 0}
{"code": "static void unix_release_sock(struct sock *sk, int embrion)\n{\n\tstruct unix_sock *u = unix_sk(sk);\n\tstruct path path;\n\tstruct sock *skpair;\n\tstruct sk_buff *skb;\n\tint state;\n\tunix_remove_socket(sk);\n\tunix_state_lock(sk);\n\tsock_orphan(sk);\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\tpath\t     = u->path;\n\tu->path.dentry = NULL;\n\tu->path.mnt = NULL;\n\tstate = sk->sk_state;\n\tsk->sk_state = TCP_CLOSE;\n\tunix_state_unlock(sk);\n\twake_up_interruptible_all(&u->peer_wait);\n\tskpair = unix_peer(sk);\n\tif (skpair != NULL) {\n\t\tif (sk->sk_type == SOCK_STREAM || sk->sk_type == SOCK_SEQPACKET) {\n\t\t\tunix_state_lock(skpair);\n\t\t\tskpair->sk_shutdown = SHUTDOWN_MASK;\n\t\t\tif (!skb_queue_empty(&sk->sk_receive_queue) || embrion)\n\t\t\t\tskpair->sk_err = ECONNRESET;\n\t\t\tunix_state_unlock(skpair);\n\t\t\tskpair->sk_state_change(skpair);\n\t\t\tsk_wake_async(skpair, SOCK_WAKE_WAITD, POLL_HUP);\n\t\t}\n\t\tunix_dgram_peer_wake_disconnect(sk, skpair);\n\t\tsock_put(skpair); \n\t\tunix_peer(sk) = NULL;\n\t}\n\twhile ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {\n\t\tif (state == TCP_LISTEN)\n\t\t\tunix_release_sock(skb->sk, 1);\n\t\tUNIXCB(skb).consumed = skb->len;\n\t\tkfree_skb(skb);\n\t}\n\tif (path.dentry)\n\t\tpath_put(&path);\n\tsock_put(sk);\n\tif (unix_tot_inflight)\n\t\tunix_gc();\t\t\n}", "target": 0}
{"code": "njs_array_expand(njs_vm_t *vm, njs_array_t *array, uint32_t prepend,\n    uint32_t append)\n{\n    uint32_t     free_before, free_after;\n    uint64_t     size;\n    njs_value_t  *start, *old;\n    njs_assert(array->object.fast_array);\n    free_before = array->start - array->data;\n    free_after = array->size - array->length - free_before;\n    if (njs_fast_path(free_before >= prepend && free_after >= append)) {\n        return NJS_OK;\n    }\n    size = (uint64_t) prepend + array->length + append;\n    if (size < 16) {\n        size *= 2;\n    } else {\n        size += size / 2;\n    }\n    if (njs_slow_path(size > (UINT32_MAX / sizeof(njs_value_t)))) {\n        goto memory_error;\n    }\n    start = njs_mp_align(vm->mem_pool, sizeof(njs_value_t),\n                         size * sizeof(njs_value_t));\n    if (njs_slow_path(start == NULL)) {\n        goto memory_error;\n    }\n    array->size = size;\n    old = array->data;\n    array->data = start;\n    start += prepend;\n    if (array->length != 0) {\n        memcpy(start, array->start, array->length * sizeof(njs_value_t));\n    }\n    array->start = start;\n    njs_mp_free(vm->mem_pool, old);\n    return NJS_OK;\nmemory_error:\n    njs_memory_error(vm);\n    return NJS_ERROR;\n}", "target": 0}
{"code": "Literal *hermes::evalUnaryOperator(\n    UnaryOperatorInst::OpKind kind,\n    IRBuilder &builder,\n    Literal *operand) {\n  switch (kind) {\n    case UnaryOperatorInst::OpKind::MinusKind:\n      switch (operand->getKind()) {\n        case ValueKind::LiteralNumberKind:\n          if (auto *literalNum = llvh::dyn_cast<LiteralNumber>(operand)) {\n            auto V = -literalNum->getValue();\n            return builder.getLiteralNumber(V);\n          }\n          break;\n        case ValueKind::LiteralUndefinedKind:\n          return builder.getLiteralNaN();\n        case ValueKind::LiteralBoolKind:\n          if (evalIsTrue(builder, operand)) {\n            return builder.getLiteralNumber(-1);\n          } else { \n            return builder.getLiteralNegativeZero();\n          }\n        case ValueKind::LiteralNullKind:\n          return builder.getLiteralNegativeZero();\n        default:\n          break;\n      }\n      break;\n    case UnaryOperatorInst::OpKind::TypeofKind:\n      switch (operand->getKind()) {\n        case ValueKind::GlobalObjectKind:\n        case ValueKind::LiteralNullKind:\n          return builder.getLiteralString(\"object\");\n        case ValueKind::LiteralUndefinedKind:\n          return builder.getLiteralString(\"undefined\");\n        case ValueKind::LiteralBoolKind:\n          return builder.getLiteralString(\"boolean\");\n        case ValueKind::LiteralNumberKind:\n          return builder.getLiteralString(\"number\");\n        case ValueKind::LiteralStringKind:\n          return builder.getLiteralString(\"string\");\n        default:\n          llvm_unreachable(\"Invalid literal kind.\");\n      }\n      break;\n    case UnaryOperatorInst::OpKind::BangKind:\n      if (evalIsTrue(builder, operand)) {\n        return builder.getLiteralBool(false);\n      }\n      if (evalIsFalse(builder, operand)) {\n        return builder.getLiteralBool(true);\n      }\n      break;\n    case UnaryOperatorInst::OpKind::VoidKind:\n      return builder.getLiteralUndefined();\n    default:\n      break;\n  }\n  return nullptr;\n}", "target": 1}
{"code": "void read_sequence_header(decoder_info_t *decoder_info, stream_t *stream) {\n  decoder_info->width = get_flc(16, stream);\n  decoder_info->height = get_flc(16, stream);\n  decoder_info->log2_sb_size = get_flc(3, stream);\n  decoder_info->log2_sb_size = clip(decoder_info->log2_sb_size, log2i(MIN_BLOCK_SIZE), log2i(MAX_SB_SIZE));\n  decoder_info->pb_split = get_flc(1, stream);\n  decoder_info->tb_split_enable = get_flc(1, stream);\n  decoder_info->max_num_ref = get_flc(2, stream) + 1;\n  decoder_info->interp_ref = get_flc(2, stream);\n  decoder_info->max_delta_qp = get_flc(1, stream);\n  decoder_info->deblocking = get_flc(1, stream);\n  decoder_info->clpf = get_flc(1, stream);\n  decoder_info->use_block_contexts = get_flc(1, stream);\n  decoder_info->bipred = get_flc(2, stream);\n  decoder_info->qmtx = get_flc(1, stream);\n  if (decoder_info->qmtx) {\n    decoder_info->qmtx_offset = get_flc(6, stream) - 32;\n  }\n  decoder_info->subsample = get_flc(2, stream);\n    decoder_info->subsample = \n    (decoder_info->subsample & 1) * 20 + (decoder_info->subsample & 2) * 22 +\n    ((decoder_info->subsample & 3) == 3) * 2 + 400;\n  decoder_info->num_reorder_pics = get_flc(4, stream);\n  if (decoder_info->subsample != 400) {\n    decoder_info->cfl_intra = get_flc(1, stream);\n    decoder_info->cfl_inter = get_flc(1, stream);\n  }\n  decoder_info->bitdepth = get_flc(1, stream) ? 10 : 8;\n  if (decoder_info->bitdepth == 10)\n    decoder_info->bitdepth += 2 * get_flc(1, stream);\n  decoder_info->input_bitdepth = get_flc(1, stream) ? 10 : 8;\n  if (decoder_info->input_bitdepth == 10)\n    decoder_info->input_bitdepth += 2 * get_flc(1, stream);\n}", "target": 0}
{"code": "void ntlm_free_message_fields_buffer(NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields)\n\t{\n\t\tif (fields->Buffer)\n\t\t{\n\t\t\tfree(fields->Buffer);\n\t\t\tfields->Len = 0;\n\t\t\tfields->MaxLen = 0;\n\t\t\tfields->Buffer = NULL;\n\t\t\tfields->BufferOffset = 0;\n\t\t}\n\t}\n}", "target": 1}
{"code": "static int parse_bigBN(BIGNUM **out, const char *bn_strings[])\n{\n    char *bigstring = glue_strings(bn_strings, NULL);\n    int ret = BN_hex2bn(out, bigstring);\n    OPENSSL_free(bigstring);\n    return ret;\n}", "target": 0}
{"code": "static long madvise_willneed(struct vm_area_struct *vma,\n\t\t\t     struct vm_area_struct **prev,\n\t\t\t     unsigned long start, unsigned long end)\n{\n\tstruct file *file = vma->vm_file;\n#ifdef CONFIG_SWAP\n\tif (!file) {\n\t\t*prev = vma;\n\t\tforce_swapin_readahead(vma, start, end);\n\t\treturn 0;\n\t}\n\tif (shmem_mapping(file->f_mapping)) {\n\t\t*prev = vma;\n\t\tforce_shm_swapin_readahead(vma, start, end,\n\t\t\t\t\tfile->f_mapping);\n\t\treturn 0;\n\t}\n#else\n\tif (!file)\n\t\treturn -EBADF;\n#endif\n\tif (IS_DAX(file_inode(file))) {\n\t\treturn 0;\n\t}\n\t*prev = vma;\n\tstart = ((start - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\tif (end > vma->vm_end)\n\t\tend = vma->vm_end;\n\tend = ((end - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\tforce_page_cache_readahead(file->f_mapping, file, start, end - start);\n\treturn 0;\n}", "target": 1}
{"code": "void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,\n\t\t   struct br_ip *group, int type)\n{\n\tstruct br_mdb_entry entry;\n\tmemset(&entry, 0, sizeof(entry));\n\tentry.ifindex = port->dev->ifindex;\n\tentry.addr.proto = group->proto;\n\tentry.addr.u.ip4 = group->u.ip4;\n#if IS_ENABLED(CONFIG_IPV6)\n\tentry.addr.u.ip6 = group->u.ip6;\n#endif\n\t__br_mdb_notify(dev, &entry, type);\n}", "target": 0}
{"code": "static int key_notify_policy_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb_out;\n\tstruct sadb_msg *hdr;\n\tskb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb_out)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb_out, sizeof(struct sadb_msg));\n\thdr->sadb_msg_type = SADB_X_SPDFLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\tpfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\treturn 0;\n}", "target": 0}
{"code": "static void dnxhd_setup_threads_slices(DNXHDEncContext *ctx)\n{\n    int mb_y, mb_x;\n    int offset = 0;\n    for (mb_y = 0; mb_y < ctx->m.mb_height; mb_y++) {\n        int thread_size;\n        ctx->slice_offs[mb_y] = offset;\n        ctx->slice_size[mb_y] = 0;\n        for (mb_x = 0; mb_x < ctx->m.mb_width; mb_x++) {\n            unsigned mb = mb_y * ctx->m.mb_width + mb_x;\n            ctx->slice_size[mb_y] += ctx->mb_bits[mb];\n        }\n        ctx->slice_size[mb_y] = (ctx->slice_size[mb_y]+31)&~31;\n        ctx->slice_size[mb_y] >>= 3;\n        thread_size = ctx->slice_size[mb_y];\n        offset += thread_size;\n    }\n}", "target": 0}
{"code": "static int tipc_crypto_key_revoke(struct net *net, u8 tx_key)\n{\n\tstruct tipc_crypto *tx = tipc_net(net)->crypto_tx;\n\tstruct tipc_key key;\n\tspin_lock(&tx->lock);\n\tkey = tx->key;\n\tWARN_ON(!key.active || tx_key != key.active);\n\ttipc_crypto_key_set_state(tx, key.passive, 0, key.pending);\n\ttipc_crypto_key_detach(tx->aead[key.active], &tx->lock);\n\tspin_unlock(&tx->lock);\n\tpr_warn(\"%s: key is revoked\\n\", tx->name);\n\treturn -EKEYREVOKED;\n}", "target": 1}
{"code": "mrb_f_send(mrb_state *mrb, mrb_value self)\n{\n  mrb_sym name;\n  mrb_value block, *regs;\n  mrb_method_t m;\n  struct RClass *c;\n  mrb_callinfo *ci = mrb->c->ci;\n  int n = ci->n;\n  if (ci->cci > CINFO_NONE) {\n  funcall:;\n    const mrb_value *argv;\n    mrb_int argc;\n    mrb_get_args(mrb, \"n*&\", &name, &argv, &argc, &block);\n    return mrb_funcall_with_block(mrb, self, name, argc, argv, block);\n  }\n  regs = mrb->c->ci->stack+1;\n  if (n == 0) {\n  argnum_error:\n    mrb_argnum_error(mrb, 0, 1, -1);\n  }\n  else if (n == 15) {\n    if (RARRAY_LEN(regs[0]) == 0) goto argnum_error;\n    name = mrb_obj_to_sym(mrb, RARRAY_PTR(regs[0])[0]);\n  }\n  else {\n    name = mrb_obj_to_sym(mrb, regs[0]);\n  }\n  c = mrb_class(mrb, self);\n  m = mrb_method_search_vm(mrb, &c, name);\n  if (MRB_METHOD_UNDEF_P(m)) {            \n    goto funcall;\n  }\n  ci->mid = name;\n  ci->u.target_class = c;\n  if (n == 15) {     \n    regs[0] = mrb_ary_subseq(mrb, regs[0], 1, RARRAY_LEN(regs[0]) - 1);\n  }\n  else { \n    for (int i=0; i<n; i++) {\n      regs[i] = regs[i+1];\n    }\n    regs[n] = regs[n+1];        \n    if (ci->nk > 0) {\n      regs[n+1] = regs[n+2];    \n    }\n    ci->n--;\n  }\n  if (MRB_METHOD_CFUNC_P(m)) {\n    if (MRB_METHOD_NOARG_P(m)) {\n      check_method_noarg(mrb, ci);\n    }\n    if (MRB_METHOD_PROC_P(m)) {\n      mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));\n    }\n    return MRB_METHOD_CFUNC(m)(mrb, self);\n  }\n  return exec_irep(mrb, self, MRB_METHOD_PROC(m));\n}", "target": 0}
{"code": "CotpConnection_readToTpktBuffer(CotpConnection* self)\n{\n    uint8_t* buffer = self->readBuffer->buffer;\n    int bufferSize = self->readBuffer->maxSize;\n    int bufPos = self->readBuffer->size;\n    assert (bufferSize > 4);\n    int readBytes;\n    if (bufPos < 4) {\n        readBytes = readFromSocket(self, buffer + bufPos, 4 - bufPos);\n        if (readBytes < 0)\n            goto exit_closed;\n        if (DEBUG_COTP) {\n            if (readBytes > 0)\n                printf(\"TPKT: read %i bytes from socket\\n\", readBytes);\n        }\n        bufPos += readBytes;\n        if (bufPos == 4) {\n            if ((buffer[0] == 3) && (buffer[1] == 0)) {\n                self->packetSize = (buffer[2] * 0x100) + buffer[3];\n                if (DEBUG_COTP)\n                    printf(\"TPKT: header complete (msg size = %i)\\n\", self->packetSize);\n                if (self->packetSize > bufferSize) {\n                    if (DEBUG_COTP) printf(\"TPKT: packet too large\\n\");\n                    goto exit_error;\n                }\n            }\n            else {\n                if (DEBUG_COTP) printf(\"TPKT: failed to decode TPKT header.\\n\");\n                goto exit_error;\n            }\n        }\n        else\n            goto exit_waiting;\n    }\n    if (self->packetSize <= bufPos)\n        goto exit_error;\n    readBytes = readFromSocket(self, buffer + bufPos, self->packetSize - bufPos);\n    if (readBytes < 0)\n        goto exit_closed;\n    bufPos += readBytes;\n    if (bufPos < self->packetSize)\n       goto exit_waiting;\n    if (DEBUG_COTP) printf(\"TPKT: message complete (size = %i)\\n\", self->packetSize);\n    self->readBuffer->size = bufPos;\n    return TPKT_PACKET_COMPLETE;\nexit_closed:\n    if (DEBUG_COTP) printf(\"TPKT: socket closed or socket error\\n\");\n    return TPKT_ERROR;\nexit_error:\n    if (DEBUG_COTP) printf(\"TPKT: Error parsing message\\n\");\n    return TPKT_ERROR;\nexit_waiting:\n    if (DEBUG_COTP)\n        if (bufPos != 0)\n            printf(\"TPKT: waiting (read %i of %i)\\n\", bufPos, self->packetSize);\n    self->readBuffer->size = bufPos;\n    return TPKT_WAITING;\n}", "target": 0}
{"code": "void key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}", "target": 0}
{"code": "fbFetchPixel_b1g2r1 (const FbBits *bits, int offset, miIndexedPtr indexed)\n{\n    CARD32  pixel = Fetch4(bits, offset);\n    CARD32  r,g,b;\n    b = ((pixel & 0x8) * 0xff) >> 3;\n    g = ((pixel & 0x6) * 0x55) << 7;\n    r = ((pixel & 0x1) * 0xff) << 16;\n    return 0xff000000|r|g|b;\n}", "target": 0}
{"code": "static inline void jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)\n{\n\tassign_eip_near(ctxt, ctxt->_eip + rel);\n}", "target": 1}
{"code": "alloc_limit_failure (char *fn_name, size_t size)\n{\n    fprintf (stderr, \n             \"%s: Maximum allocation size exceeded \"\n             \"(maxsize = %lu; size = %lu).\\n\",\n             fn_name,\n             (unsigned long)alloc_limit, \n             (unsigned long)size);\n}", "target": 1}
{"code": "}\nstatic inline bool f2fs_force_buffered_io(struct inode *inode,\n\t\t\t\tstruct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tint rw = iov_iter_rw(iter);\n\tif (f2fs_post_read_required(inode))\n\t\treturn true;\n\tif (f2fs_is_multi_device(sbi))\n\t\treturn true;\n\tif (f2fs_sb_has_blkzoned(sbi))\n\t\treturn true;\n\tif (test_opt(sbi, LFS) && (rw == WRITE) &&\n\t\t\t\tblock_unaligned_IO(inode, iocb, iter))\n\t\treturn true;\n\tif (is_sbi_flag_set(F2FS_I_SB(inode), SBI_CP_DISABLED))\n\t\treturn true;", "target": 1}
{"code": "hb_set_clear (hb_set_t *set)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->clear ();\n}", "target": 1}
{"code": "static bool rb_is_reader_page(struct buffer_page *page)\n{\n\tstruct list_head *list = page->list.prev;\n\treturn rb_list_head(list->next) != &page->list;\n}", "target": 0}
{"code": "void nfs4_close_sync(struct path *path, struct nfs4_state *state, mode_t mode)\n{\n\t__nfs4_close(path, state, mode, 1);\n}", "target": 1}
{"code": "is_link_trusted (NautilusFile *file,\n                 gboolean      is_launcher)\n{\n    GFile *location;\n    gboolean res;\n    if (!is_launcher)\n    {\n        return TRUE;\n    }\n    if (nautilus_file_can_execute (file))\n    {\n        return TRUE;\n    }\n    res = FALSE;\n    if (nautilus_file_is_local (file))\n    {\n        location = nautilus_file_get_location (file);\n        res = nautilus_is_in_system_dir (location);\n        g_object_unref (location);\n    }\n    return res;\n}", "target": 1}
{"code": "  StatusOr<std::vector<int64_t>> GetStride(XlaOpKernelContext* ctx) {\n    if (ctx->num_inputs() == 1) {\n      return stride_;\n    }\n    const TensorShape stride_shape = ctx->InputShape(2);\n    if (!TensorShapeUtils::IsVector(stride_shape)) {\n      return errors::InvalidArgument(\"stride must be a vector, not shape \",\n                                     stride_shape.DebugString());\n    }\n    if (stride_shape.num_elements() != num_dims()) {\n      return errors::InvalidArgument(\n          \"Sliding window stride field must \"\n          \"specify \",\n          num_dims(), \" dimensions\");\n    }\n    std::vector<int64_t> stride;\n    auto status = ctx->ConstantInputAsIntVector(2, &stride);\n    if (!status.ok()) {\n      return status;\n    }\n    return stride;\n  }", "target": 1}
{"code": "static void write_cb(struct bt_att_chan *chan, uint8_t opcode, const void *pdu,\n\t\t\t\t\tuint16_t length, void *user_data)\n{\n\tstruct bt_gatt_server *server = user_data;\n\tstruct gatt_db_attribute *attr;\n\tuint16_t handle = 0;\n\tstruct async_write_op *op = NULL;\n\tuint8_t ecode;\n\tif (length < 2) {\n\t\tecode = BT_ATT_ERROR_INVALID_PDU;\n\t\tgoto error;\n\t}\n\tecode = authorize_req(server, opcode, handle);\n\tif (ecode)\n\t\tgoto error;\n\thandle = get_le16(pdu);\n\tattr = gatt_db_get_attribute(server->db, handle);\n\tif (!attr) {\n\t\tecode = BT_ATT_ERROR_INVALID_HANDLE;\n\t\tgoto error;\n\t}\n\tutil_debug(server->debug_callback, server->debug_data,\n\t\t\t\t\"Write %s - handle: 0x%04x\",\n\t\t\t\t(opcode == BT_ATT_OP_WRITE_REQ) ? \"Req\" : \"Cmd\",\n\t\t\t\thandle);\n\tecode = check_length(length, 0);\n\tif (ecode)\n\t\tgoto error;\n\tecode = check_permissions(server, attr, BT_ATT_PERM_WRITE_MASK);\n\tif (ecode)\n\t\tgoto error;\n\top = new0(struct async_write_op, 1);\n\top->chan = chan;\n\top->server = bt_gatt_server_ref(server);\n\top->opcode = opcode;\n\tif (gatt_db_attribute_write(attr, 0, pdu + 2, length - 2, opcode,\n\t\t\t\t\t\t\tserver->att,\n\t\t\t\t\t\t\twrite_complete_cb, op))\n\t\treturn;\n\tasync_write_op_destroy(op);\n\tecode = BT_ATT_ERROR_UNLIKELY;\nerror:\n\tif (opcode == BT_ATT_OP_WRITE_CMD)\n\t\treturn;\n\tbt_att_chan_send_error_rsp(chan, opcode, handle, ecode);\n}", "target": 0}
{"code": "static int vapic_enter(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct page *page;\n\tif (!apic || !apic->vapic_addr)\n\t\treturn 0;\n\tpage = gfn_to_page(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\treturn -EFAULT;\n\tvcpu->arch.apic->vapic_page = page;\n\treturn 0;\n}", "target": 1}
{"code": "delta_head_create(struct delta_head **result)\n{\n\tstruct delta_head *tmp;\n\ttmp = malloc(sizeof(struct delta_head));\n\tif (tmp == NULL)\n\t\treturn pr_enomem();\n\tdoc_data_init(&tmp->doc_data);\n\t*result = tmp;\n\treturn 0;\n}", "target": 1}
{"code": "static int32_t gcd(int a, int b)\n{\n  if (a == 0 && b == 0) {\n    return 1;\n  }\n  if (a == 0) return b;\n  if (b == 0) return a;\n  int32_t h;\n  do {\n    h = a % b;\n    a = b;\n    b = h;\n  } while (b != 0);\n  return a;\n}", "target": 1}
{"code": "void imap_quote_string(char *dest, size_t dlen, const char *src)\n{\n  static const char quote[] = \"\\\"\\\\\";\n  char *pt = dest;\n  const char *s = src;\n  *pt++ = '\"';\n  dlen -= 2;\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      dlen -= 2;\n      if (dlen == 0)\n        break;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = '\\0';\n}", "target": 1}
{"code": "static void prefetch_dec(void)\n{\n  dec_tables.counter_head++;\n  dec_tables.counter_tail++;\n  prefetch_table((const void *)&dec_tables, sizeof(dec_tables));\n}", "target": 0}
{"code": "static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_bpcc_t *bpcc = &box->data.bpcc;\n\tunsigned int i;\n\tbpcc->bpcs = 0;\n\tbpcc->numcmpts = box->datalen;\n\tif (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < bpcc->numcmpts; ++i) {\n\t\tif (jp2_getuint8(in, &bpcc->bpcs[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "ldns_str2rdf_str(ldns_rdf **rd, const char *str)\n{\n\tuint8_t *data, *dp, ch = 0;\n\tsize_t length;\n\tdp = data = LDNS_XMALLOC(uint8_t, strlen(str) > 255 ? 256 : (strlen(str) + 1));\n\tif (! data) {\n\t\treturn LDNS_STATUS_MEM_ERR;\n\t}\n\twhile (parse_char(&ch, &str)) {\n\t\tif (dp - data >= 255) {\n\t\t\tLDNS_FREE(data);\n\t\t\treturn LDNS_STATUS_INVALID_STR;\n\t\t}\n\t\t*++dp = ch;\n\t}\n\tif (! str) {\n\t\treturn LDNS_STATUS_SYNTAX_BAD_ESCAPE;\n\t}\n\tlength = (size_t)(dp - data);\n\tdata[0] = (uint8_t)length;\n\tdata = LDNS_XREALLOC(dp = data, uint8_t, length + 1);\n\tif (! data) {\n\t\tLDNS_FREE(dp);\n\t\treturn LDNS_STATUS_MEM_ERR;\n\t}\n\t*rd = ldns_rdf_new(LDNS_RDF_TYPE_STR, length + 1, data);\n\tif (! *rd) {\n\t\tLDNS_FREE(data);\n\t\treturn LDNS_STATUS_MEM_ERR;\n\t}\n\treturn LDNS_STATUS_OK;\n}", "target": 0}
{"code": "static TEE_Result do_allocate_publickey(struct ecc_public_key *key,\n\t\t\t\t\tuint32_t type __unused,\n\t\t\t\t\tsize_t size_bits)\n{\n\tECC_TRACE(\"Allocate Public Key of %zu bits\", size_bits);\n\tmemset(key, 0, sizeof(*key));\n\tkey->x = crypto_bignum_allocate(size_bits);\n\tif (!key->x)\n\t\tgoto err;\n\tkey->y = crypto_bignum_allocate(size_bits);\n\tif (!key->y)\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tECC_TRACE(\"Allocation error\");\n\tcrypto_bignum_free(key->x);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "static void fuse_lib_listxattr(fuse_req_t req, fuse_ino_t ino, size_t size)\n{\n    struct fuse *f = req_fuse_prepare(req);\n    int res;\n    if (size) {\n        char *list = (char *) malloc(size);\n        if (list == NULL) {\n            reply_err(req, -ENOMEM);\n            return;\n        }\n        res = common_listxattr(f, req, ino, list, size);\n        if (res > 0)\n            fuse_reply_buf(req, list, res);\n        else\n            reply_err(req, res);\n        free(list);\n    } else {\n        res = common_listxattr(f, req, ino, NULL, 0);\n        if (res >= 0)\n            fuse_reply_xattr(req, res);\n        else\n            reply_err(req, res);\n    }\n}", "target": 0}
{"code": "inline typename V::VariantType FBUnserializer<V>::unserializeThing() {\n  size_t code = nextCode();\n  switch (code) {\n    case FB_SERIALIZE_BYTE:\n    case FB_SERIALIZE_I16:\n    case FB_SERIALIZE_I32:\n    case FB_SERIALIZE_I64:\n      return V::fromInt64(unserializeInt64());\n    case FB_SERIALIZE_VARCHAR:\n    case FB_SERIALIZE_STRING:\n      return V::fromString(unserializeString());\n    case FB_SERIALIZE_STRUCT:\n      return V::fromMap(unserializeMap());\n    case FB_SERIALIZE_NULL:\n      ++p_;\n      return V::createNull();\n    case FB_SERIALIZE_DOUBLE:\n      return V::fromDouble(unserializeDouble());\n    case FB_SERIALIZE_BOOLEAN:\n      return V::fromBool(unserializeBoolean());\n    case FB_SERIALIZE_VECTOR:\n      return V::fromVector(unserializeVector());\n    case FB_SERIALIZE_LIST:\n      return V::fromVector(unserializeList());\n    case FB_SERIALIZE_SET:\n      return V::fromSet(unserializeSet());\n    default:\n      throw UnserializeError(\"Invalid code: \" + folly::to<std::string>(code)\n                             + \" at location \" + folly::to<std::string>(p_));\n  }\n}", "target": 1}
{"code": "static int udf_encode_fh(struct inode *inode, __u32 *fh, int *lenp,\n\t\t\t struct inode *parent)\n{\n\tint len = *lenp;\n\tstruct kernel_lb_addr location = UDF_I(inode)->i_location;\n\tstruct fid *fid = (struct fid *)fh;\n\tint type = FILEID_UDF_WITHOUT_PARENT;\n\tif (parent && (len < 5)) {\n\t\t*lenp = 5;\n\t\treturn 255;\n\t} else if (len < 3) {\n\t\t*lenp = 3;\n\t\treturn 255;\n\t}\n\t*lenp = 3;\n\tfid->udf.block = location.logicalBlockNum;\n\tfid->udf.partref = location.partitionReferenceNum;\n\tfid->udf.parent_partref = 0;\n\tfid->udf.generation = inode->i_generation;\n\tif (parent) {\n\t\tlocation = UDF_I(parent)->i_location;\n\t\tfid->udf.parent_block = location.logicalBlockNum;\n\t\tfid->udf.parent_partref = location.partitionReferenceNum;\n\t\tfid->udf.parent_generation = inode->i_generation;\n\t\t*lenp = 5;\n\t\ttype = FILEID_UDF_WITH_PARENT;\n\t}\n\treturn type;\n}", "target": 0}
{"code": "static bool kvm_vcpu_check_code_breakpoint(struct kvm_vcpu *vcpu, int *r)\n{\n\tif (unlikely(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) &&\n\t    (vcpu->arch.guest_debug_dr7 & DR7_BP_EN_MASK)) {\n\t\tstruct kvm_run *kvm_run = vcpu->run;\n\t\tunsigned long eip = kvm_get_linear_rip(vcpu);\n\t\tu32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.guest_debug_dr7,\n\t\t\t\t\t   vcpu->arch.eff_db);\n\t\tif (dr6 != 0) {\n\t\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_ACTIVE_LOW;\n\t\t\tkvm_run->debug.arch.pc = eip;\n\t\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\t*r = 0;\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (unlikely(vcpu->arch.dr7 & DR7_BP_EN_MASK) &&\n\t    !(kvm_get_rflags(vcpu) & X86_EFLAGS_RF)) {\n\t\tunsigned long eip = kvm_get_linear_rip(vcpu);\n\t\tu32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.dr7,\n\t\t\t\t\t   vcpu->arch.db);\n\t\tif (dr6 != 0) {\n\t\t\tkvm_queue_exception_p(vcpu, DB_VECTOR, dr6);\n\t\t\t*r = 1;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 0}
{"code": "void macvlan_common_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\tdev->priv_flags\t       &= ~IFF_XMIT_DST_RELEASE;\n\tdev->netdev_ops\t\t= &macvlan_netdev_ops;\n\tdev->destructor\t\t= free_netdev;\n\tdev->header_ops\t\t= &macvlan_hard_header_ops,\n\tdev->ethtool_ops\t= &macvlan_ethtool_ops;\n}", "target": 1}
{"code": "static int snd_hrtimer_stop(struct snd_timer *t)\n{\n\tstruct snd_hrtimer *stime = t->private_data;\n\tatomic_set(&stime->running, 0);\n\thrtimer_try_to_cancel(&stime->hrt);\n\treturn 0;\n}", "target": 0}
{"code": "inline typename V::SetType FBUnserializer<V>::unserializeSet() {\n  p_ += CODE_SIZE;\n  unserializeInt64();\n  typename V::SetType ret = V::createSet();\n  size_t code = nextCode();\n  while (code != FB_SERIALIZE_STOP) {\n    V::setAppend(ret, unserializeThing());\n    code = nextCode();\n  }\n  p_ += CODE_SIZE;\n  return ret;\n}", "target": 1}
{"code": "static inline bool is_flush_request(struct request *rq,\n\t\tstruct blk_flush_queue *fq, unsigned int tag)\n{\n\treturn ((rq->cmd_flags & REQ_FLUSH_SEQ) &&\n\t\t\tfq->flush_rq->tag == tag);\n}", "target": 1}
{"code": "bool AuthNoneAuthorizeHandler::verify_authorizer(CephContext *cct, KeyStore *keys,\n\t\t\t\t\t\t bufferlist& authorizer_data, bufferlist& authorizer_reply,\n\t\t\t\t\t\t EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info, CryptoKey& session_key,\nuint64_t *auid)\n{\n  bufferlist::iterator iter = authorizer_data.begin();\n  try {\n    __u8 struct_v = 1;\n    ::decode(struct_v, iter);\n    ::decode(entity_name, iter);\n    ::decode(global_id, iter);\n  } catch (const buffer::error &err) {\n    ldout(cct, 0) << \"AuthNoneAuthorizeHandle::verify_authorizer() failed to decode\" << dendl;\n    return false;\n  }\n  caps_info.allow_all = true;\n  return true;\n}", "target": 1}
{"code": "static int bpf_adj_delta_to_off(struct bpf_insn *insn, u32 pos, u32 delta,\n\t\t\t\tu32 curr, const bool probe_pass)\n{\n\tconst s32 off_min = S16_MIN, off_max = S16_MAX;\n\ts32 off = insn->off;\n\tif (curr < pos && curr + off + 1 > pos)\n\t\toff += delta;\n\telse if (curr > pos + delta && curr + off + 1 <= pos + delta)\n\t\toff -= delta;\n\tif (off < off_min || off > off_max)\n\t\treturn -ERANGE;\n\tif (!probe_pass)\n\t\tinsn->off = off;\n\treturn 0;\n}", "target": 0}
{"code": "snmp_api_set_oid(snmp_varbind_t *varbind, uint32_t *oid, uint32_t *ret_oid)\n{\n  snmp_api_replace_oid(varbind, oid);\n  varbind->value_type = BER_DATA_TYPE_OID;\n  varbind->value.oid = ret_oid;\n}", "target": 1}
{"code": "void cql_server::response::serialize(const event::schema_change& event, uint8_t version)\n{\n    if (version >= 3) {\n        write_string(to_string(event.change));\n        write_string(to_string(event.target));\n        write_string(event.keyspace);\n        switch (event.target) {\n        case event::schema_change::target_type::KEYSPACE:\n            break;\n        case event::schema_change::target_type::TYPE:\n        case event::schema_change::target_type::TABLE:\n            write_string(event.arguments[0]);\n            break;\n        case event::schema_change::target_type::FUNCTION:\n        case event::schema_change::target_type::AGGREGATE:\n            write_string(event.arguments[0]);\n            write_string_list(std::vector<sstring>(event.arguments.begin() + 1, event.arguments.end()));\n            break;\n        }\n    } else {\n        switch (event.target) {\n        case event::schema_change::target_type::TYPE:\n        case event::schema_change::target_type::FUNCTION:\n        case event::schema_change::target_type::AGGREGATE:\n            write_string(to_string(event::schema_change::change_type::UPDATED));\n            write_string(event.keyspace);\n            write_string(\"\");\n            break;\n        case event::schema_change::target_type::TABLE:\n        case event::schema_change::target_type::KEYSPACE:\n            write_string(to_string(event.change));\n            write_string(event.keyspace);\n            if (event.target == event::schema_change::target_type::TABLE) {\n                write_string(event.arguments[0]);\n            } else {\n                write_string(\"\");\n            }\n        }\n    }\n}", "target": 0}
{"code": "void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h, *g;\n\tunsigned int i;\n\tvmcb_mark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\tc = &svm->vmcb->control;\n\th = &svm->vmcb01.ptr->control;\n\tg = &svm->nested.ctl;\n\tfor (i = 0; i < MAX_INTERCEPT; i++)\n\t\tc->intercepts[i] = h->intercepts[i];\n\tif (g->int_ctl & V_INTR_MASKING_MASK) {\n\t\tvmcb_clr_intercept(c, INTERCEPT_CR8_READ);\n\t\tvmcb_clr_intercept(c, INTERCEPT_CR8_WRITE);\n\t\tvmcb_clr_intercept(c, INTERCEPT_VINTR);\n\t}\n\tvmcb_clr_intercept(c, INTERCEPT_VMMCALL);\n\tfor (i = 0; i < MAX_INTERCEPT; i++)\n\t\tc->intercepts[i] |= g->intercepts[i];\n\tif (!intercept_smi)\n\t\tvmcb_clr_intercept(c, INTERCEPT_SMI);\n\tvmcb_set_intercept(c, INTERCEPT_VMLOAD);\n\tvmcb_set_intercept(c, INTERCEPT_VMSAVE);\n}", "target": 0}
{"code": "create_spnego_ctx(void)\n{\n\tspnego_gss_ctx_id_t spnego_ctx = NULL;\n\tspnego_ctx = (spnego_gss_ctx_id_t)\n\t\tmalloc(sizeof (spnego_gss_ctx_id_rec));\n\tif (spnego_ctx == NULL) {\n\t\treturn (NULL);\n\t}\n\tspnego_ctx->magic_num = SPNEGO_MAGIC_ID;\n\tspnego_ctx->ctx_handle = GSS_C_NO_CONTEXT;\n\tspnego_ctx->mech_set = NULL;\n\tspnego_ctx->internal_mech = NULL;\n\tspnego_ctx->optionStr = NULL;\n\tspnego_ctx->DER_mechTypes.length = 0;\n\tspnego_ctx->DER_mechTypes.value = NULL;\n\tspnego_ctx->default_cred = GSS_C_NO_CREDENTIAL;\n\tspnego_ctx->mic_reqd = 0;\n\tspnego_ctx->mic_sent = 0;\n\tspnego_ctx->mic_rcvd = 0;\n\tspnego_ctx->mech_complete = 0;\n\tspnego_ctx->nego_done = 0;\n\tspnego_ctx->internal_name = GSS_C_NO_NAME;\n\tspnego_ctx->actual_mech = GSS_C_NO_OID;\n\tcheck_spnego_options(spnego_ctx);\n\treturn (spnego_ctx);\n}", "target": 1}
{"code": "static void common_hrtimer_rearm(struct k_itimer *timr)\n{\n\tstruct hrtimer *timer = &timr->it.real.timer;\n\tif (!timr->it_interval)\n\t\treturn;\n\ttimr->it_overrun += (unsigned int) hrtimer_forward(timer,\n\t\t\t\t\t\ttimer->base->get_time(),\n\t\t\t\t\t\ttimr->it_interval);\n\thrtimer_restart(timer);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& grad_in = context->input(1);\n    const Tensor& argmax = context->input(2);\n    PoolParameters params{context,\n                          ksize_,\n                          stride_,\n                          padding_,\n                          {},\n                          FORMAT_NHWC,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n    OP_REQUIRES(\n        context, grad_in.shape() == tensor_in.shape(),\n        errors::InvalidArgument(\"Expected grad shape to be \", tensor_in.shape(),\n                                \", but got \", grad_in.shape()));\n    OP_REQUIRES(context, argmax.shape() == params.forward_output_shape(),\n                errors::InvalidArgument(\"Expected argmax shape to be \",\n                                        params.forward_output_shape(),\n                                        \", but got \", argmax.shape()));\n    TensorShape out_shape({params.tensor_in_batch, params.out_height,\n                           params.out_width, params.depth});\n    Tensor* grad_out = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {0}, 0, out_shape, &grad_out));\n    LaunchMaxPoolingGradGradWithArgmax<Device, T>::launch(\n        context, params, grad_in, argmax, grad_out, include_batch_in_index_);\n  }", "target": 0}
{"code": "static int region_list_contains_offset(struct fdt_region_state *info,\n\t\t\t\t       const void *fdt, int target)\n{\n\tstruct fdt_region *reg;\n\tint num;\n\ttarget += fdt_off_dt_struct(fdt);\n\tfor (reg = info->region, num = 0; num < info->count; reg++, num++) {\n\t\tif (target >= reg->offset && target < reg->offset + reg->size)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int efi_capsule_flush(struct file *file, fl_owner_t id)\n{\n\tint ret = 0;\n\tstruct capsule_info *cap_info = file->private_data;\n\tif (cap_info->index > 0) {\n\t\tpr_err(\"capsule upload not complete\\n\");\n\t\tefi_free_all_buff_pages(cap_info);\n\t\tret = -ECANCELED;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "MagickExport void *AcquireQuantumMemory(const size_t count,const size_t quantum)\n{\n  size_t\n    extent;\n  if (CheckMemoryOverflow(count,quantum) != MagickFalse)\n    return((void *) NULL);\n  extent=count*quantum;\n  return(AcquireMagickMemory(extent));\n}", "target": 1}
{"code": "static inline __u8 l2cap_select_mode(__u8 mode, __u16 remote_feat_mask)\n{\n\tswitch (mode) {\n\tcase L2CAP_MODE_STREAMING:\n\tcase L2CAP_MODE_ERTM:\n\t\tif (l2cap_mode_supported(mode, remote_feat_mask))\n\t\t\treturn mode;\n\tdefault:\n\t\treturn L2CAP_MODE_BASIC;\n\t}\n}", "target": 0}
{"code": "pci_get_cfgdata16(struct pci_vdev *dev, int offset)\n{\n\tassert(offset <= (PCI_REGMAX - 1) && (offset & 1) == 0);\n\treturn (*(uint16_t *)(dev->cfgdata + offset));\n}", "target": 1}
{"code": "static int sctp_sf_send_restart_abort(struct net *net, union sctp_addr *ssa,\n\t\t\t\t      struct sctp_chunk *init,\n\t\t\t\t      sctp_cmd_seq_t *commands)\n{\n\tint len;\n\tstruct sctp_packet *pkt;\n\tunion sctp_addr_param *addrparm;\n\tstruct sctp_errhdr *errhdr;\n\tstruct sctp_endpoint *ep;\n\tchar buffer[sizeof(struct sctp_errhdr)+sizeof(union sctp_addr_param)];\n\tstruct sctp_af *af = sctp_get_af_specific(ssa->v4.sin_family);\n\terrhdr = (struct sctp_errhdr *)buffer;\n\taddrparm = (union sctp_addr_param *)errhdr->variable;\n\tlen = af->to_addr_param(ssa, addrparm);\n\tlen += sizeof(sctp_errhdr_t);\n\terrhdr->cause = SCTP_ERROR_RESTART;\n\terrhdr->length = htons(len);\n\tep = sctp_sk(net->sctp.ctl_sock)->ep;\n\tpkt = sctp_abort_pkt_new(net, ep, NULL, init, errhdr, len);\n\tif (!pkt)\n\t\tgoto out;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT, SCTP_PACKET(pkt));\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\nout:\n\treturn 0;\n}", "target": 0}
{"code": "bool dir_has_correct_permissions(const char *dir_name)\n{\n    if (g_settings_privatereports)\n    {\n        struct stat statbuf;\n        if (lstat(dir_name, &statbuf) != 0 || !S_ISDIR(statbuf.st_mode))\n        {\n            error_msg(\"Path '%s' isn't directory\", dir_name);\n            return false;\n        }\n        struct group *gr = getgrnam(\"abrt\");\n        if (!gr)\n        {\n            error_msg(\"Group 'abrt' does not exist\");\n            return false;\n        }\n        if (statbuf.st_uid != 0 || !(statbuf.st_gid == 0 || statbuf.st_gid == gr->gr_gid) || statbuf.st_mode & 07)\n            return false;\n    }\n    return true;\n}", "target": 0}
{"code": "static unsigned long page_table_shareable(struct vm_area_struct *svma,\n\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\tunsigned long addr, pgoff_t idx)\n{\n\tunsigned long saddr = ((idx - svma->vm_pgoff) << PAGE_SHIFT) +\n\t\t\t\tsvma->vm_start;\n\tunsigned long sbase = saddr & PUD_MASK;\n\tunsigned long s_end = sbase + PUD_SIZE;\n\tunsigned long vm_flags = vma->vm_flags & VM_LOCKED_CLEAR_MASK;\n\tunsigned long svm_flags = svma->vm_flags & VM_LOCKED_CLEAR_MASK;\n\tif (pmd_index(addr) != pmd_index(saddr) ||\n\t    vm_flags != svm_flags ||\n\t    !range_in_vma(svma, sbase, s_end))\n\t\treturn 0;\n\treturn saddr;\n}", "target": 0}
{"code": "\t\tauto Phase3() -> Local<Value> final {\n\t\t\treturn Boolean::New(Isolate::GetCurrent(), result);\n\t\t}", "target": 1}
{"code": "static void xen_irq_lateeoi_worker(struct work_struct *work)\n{\n\tstruct lateeoi_work *eoi;\n\tstruct irq_info *info;\n\tu64 now = get_jiffies_64();\n\tunsigned long flags;\n\teoi = container_of(to_delayed_work(work), struct lateeoi_work, delayed);\n\tread_lock_irqsave(&evtchn_rwlock, flags);\n\twhile (true) {\n\t\tspin_lock(&eoi->eoi_list_lock);\n\t\tinfo = list_first_entry_or_null(&eoi->eoi_list, struct irq_info,\n\t\t\t\t\t\teoi_list);\n\t\tif (info == NULL || now < info->eoi_time) {\n\t\t\tspin_unlock(&eoi->eoi_list_lock);\n\t\t\tbreak;\n\t\t}\n\t\tlist_del_init(&info->eoi_list);\n\t\tspin_unlock(&eoi->eoi_list_lock);\n\t\tinfo->eoi_time = 0;\n\t\txen_irq_lateeoi_locked(info);\n\t}\n\tif (info)\n\t\tmod_delayed_work_on(info->eoi_cpu, system_wq,\n\t\t\t\t    &eoi->delayed, info->eoi_time - now);\n\tread_unlock_irqrestore(&evtchn_rwlock, flags);\n}", "target": 0}
{"code": "void cmov_int16(int16_t *r, int16_t v, uint16_t b)\n{\n  b = -b;\n  *r ^= b & ((*r) ^ v);\n}", "target": 0}
{"code": "void input_set_capability(struct input_dev *dev, unsigned int type, unsigned int code)\n{\n\tif (type < EV_CNT && input_max_code[type] &&\n\t    code > input_max_code[type]) {\n\t\tpr_err(\"%s: invalid code %u for type %u\\n\", __func__, code,\n\t\t       type);\n\t\tdump_stack();\n\t\treturn;\n\t}\n\tswitch (type) {\n\tcase EV_KEY:\n\t\t__set_bit(code, dev->keybit);\n\t\tbreak;\n\tcase EV_REL:\n\t\t__set_bit(code, dev->relbit);\n\t\tbreak;\n\tcase EV_ABS:\n\t\tinput_alloc_absinfo(dev);\n\t\t__set_bit(code, dev->absbit);\n\t\tbreak;\n\tcase EV_MSC:\n\t\t__set_bit(code, dev->mscbit);\n\t\tbreak;\n\tcase EV_SW:\n\t\t__set_bit(code, dev->swbit);\n\t\tbreak;\n\tcase EV_LED:\n\t\t__set_bit(code, dev->ledbit);\n\t\tbreak;\n\tcase EV_SND:\n\t\t__set_bit(code, dev->sndbit);\n\t\tbreak;\n\tcase EV_FF:\n\t\t__set_bit(code, dev->ffbit);\n\t\tbreak;\n\tcase EV_PWR:\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: unknown type %u (code %u)\\n\", __func__, type, code);\n\t\tdump_stack();\n\t\treturn;\n\t}\n\t__set_bit(type, dev->evbit);\n}", "target": 0}
{"code": "hphp_libxml_input_buffer_noload(const char *URI, xmlCharEncoding enc) {\n  return nullptr;\n}", "target": 1}
{"code": "static void unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n{\n\tint i;\n\tscm->fp = UNIXCB(skb).fp;\n\tUNIXCB(skb).fp = NULL;\n\tfor (i = scm->fp->count-1; i >= 0; i--)\n\t\tunix_notinflight(scm->fp->fp[i]);\n}", "target": 1}
{"code": "void ssl_update_cache(SSL_CONNECTION *s, int mode)\n{\n    int i;\n    if (s->session->session_id_length == 0)\n        return;\n    if (s->server && s->session->sid_ctx_length == 0\n            && (s->verify_mode & SSL_VERIFY_PEER) != 0)\n        return;\n    i = s->session_ctx->session_cache_mode;\n    if ((i & mode) != 0\n        && (!s->hit || SSL_CONNECTION_IS_TLS13(s))) {\n        if ((i & SSL_SESS_CACHE_NO_INTERNAL_STORE) == 0\n                && (!SSL_CONNECTION_IS_TLS13(s)\n                    || !s->server\n                    || (s->max_early_data > 0\n                        && (s->options & SSL_OP_NO_ANTI_REPLAY) == 0)\n                    || s->session_ctx->remove_session_cb != NULL\n                    || (s->options & SSL_OP_NO_TICKET) != 0))\n            SSL_CTX_add_session(s->session_ctx, s->session);\n        if (s->session_ctx->new_session_cb != NULL) {\n            SSL_SESSION_up_ref(s->session);\n            if (!s->session_ctx->new_session_cb(SSL_CONNECTION_GET_SSL(s),\n                                                s->session))\n                SSL_SESSION_free(s->session);\n        }\n    }\n    if ((!(i & SSL_SESS_CACHE_NO_AUTO_CLEAR)) && ((i & mode) == mode)) {\n        TSAN_QUALIFIER int *stat;\n        if (mode & SSL_SESS_CACHE_CLIENT)\n            stat = &s->session_ctx->stats.sess_connect_good;\n        else\n            stat = &s->session_ctx->stats.sess_accept_good;\n        if ((ssl_tsan_load(s->session_ctx, stat) & 0xff) == 0xff)\n            SSL_CTX_flush_sessions(s->session_ctx, (unsigned long)time(NULL));\n    }\n}", "target": 1}
{"code": "static unsigned char mincore_page(struct address_space *mapping, pgoff_t pgoff)\n{\n\tunsigned char present = 0;\n\tstruct page *page;\n#ifdef CONFIG_SWAP\n\tif (shmem_mapping(mapping)) {\n\t\tpage = find_get_entry(mapping, pgoff);\n\t\tif (xa_is_value(page)) {\n\t\t\tswp_entry_t swp = radix_to_swp_entry(page);\n\t\t\tpage = find_get_page(swap_address_space(swp),\n\t\t\t\t\t     swp_offset(swp));\n\t\t}\n\t} else\n\t\tpage = find_get_page(mapping, pgoff);\n#else\n\tpage = find_get_page(mapping, pgoff);\n#endif\n\tif (page) {\n\t\tpresent = PageUptodate(page);\n\t\tput_page(page);\n\t}\n\treturn present;\n}", "target": 1}
{"code": "DSA_PrivateKey::create_signature_op(RandomNumberGenerator& ,\n                                    const std::string& params,\n                                    const std::string& provider) const\n   {\n   if(provider == \"base\" || provider.empty())\n      return std::unique_ptr<PK_Ops::Signature>(new DSA_Signature_Operation(*this, params));\n   throw Provider_Not_Found(algo_name(), provider);\n   }", "target": 1}
{"code": "void sort_directory(struct dir *dir)\n{\n\tstruct dir_ent *cur, *l1, *l2, *next;\n\tint len1, len2, stride = 1;\n\tif(dir->dir_count < 2)\n\t\treturn;\n\tdo {\n\t\tl2 = dir->dirs; \n\t\tcur = NULL; \n\t\twhile(l2) {\n\t\t\tl1 = l2;\n\t\t\tfor(len1 = 0; l2 && len1 < stride; len1 ++, l2 = l2->next);\n\t\t\tlen2 = stride;\n\t\t\twhile(len1 && l2 && len2) {\n\t\t\t\tif(strcmp(l1->name, l2->name) <= 0) {\n\t\t\t\t\tnext = l1;\n\t\t\t\t\tl1 = l1->next;\n\t\t\t\t\tlen1 --;\n\t\t\t\t} else {\n\t\t\t\t\tnext = l2;\n\t\t\t\t\tl2 = l2->next;\n\t\t\t\t\tlen2 --;\n\t\t\t\t}\n\t\t\t\tif(cur) {\n\t\t\t\t\tcur->next = next;\n\t\t\t\t\tcur = next;\n\t\t\t\t} else\n\t\t\t\t\tdir->dirs = cur = next;\n\t\t\t}\n\t\t\tfor(; len1; len1 --, l1 = l1->next) {\n\t\t\t\tif(cur) {\n\t\t\t\t\tcur->next = l1;\n\t\t\t\t\tcur = l1;\n\t\t\t\t} else\n\t\t\t\t\tdir->dirs = cur = l1;\n\t\t\t}\n\t\t\tfor(; l2 && len2; len2 --, l2 = l2->next) {\n\t\t\t\tif(cur) {\n\t\t\t\t\tcur->next = l2;\n\t\t\t\t\tcur = l2;\n\t\t\t\t} else\n\t\t\t\t\tdir->dirs = cur = l2;\n\t\t\t}\n\t\t}\n\t\tcur->next = NULL;\n\t\tstride = stride << 1;\n\t} while(stride < dir->dir_count);\n}", "target": 0}
{"code": "    GopherStateData(FwdState *aFwd) :\n        entry(aFwd->entry),\n        conversion(NORMAL),\n        HTML_header_added(0),\n        HTML_pre(0),\n        type_id(GOPHER_FILE ),\n        overflowed(false),\n        cso_recno(0),\n        len(0),\n        buf(nullptr),\n        fwd(aFwd)\n    {\n        *request = 0;\n        buf = (char *)memAllocate(MEM_4K_BUF);\n        entry->lock(\"gopherState\");\n        *replybuf = 0;\n    }", "target": 1}
{"code": "ecma_op_function_call_native (ecma_object_t *func_obj_p, \n                              ecma_value_t this_arg_value, \n                              const ecma_value_t *arguments_list_p, \n                              uint32_t arguments_list_len) \n{\n  JERRY_ASSERT (ecma_get_object_type (func_obj_p) == ECMA_OBJECT_TYPE_NATIVE_FUNCTION);\n  ECMA_CHECK_STACK_USAGE ();\n  ecma_native_function_t *native_function_p = (ecma_native_function_t *) func_obj_p;\n#if JERRY_BUILTIN_REALMS\n  ecma_global_object_t *saved_global_object_p = JERRY_CONTEXT (global_object_p);\n  JERRY_CONTEXT (global_object_p) =\n    ECMA_GET_INTERNAL_VALUE_POINTER (ecma_global_object_t, native_function_p->realm_value);\n#endif \n  jerry_call_info_t call_info;\n  call_info.function = ecma_make_object_value (func_obj_p);\n  call_info.this_value = this_arg_value;\n  ecma_object_t *new_target_p = JERRY_CONTEXT (current_new_target_p);\n  call_info.new_target = (new_target_p == NULL) ? ECMA_VALUE_UNDEFINED : ecma_make_object_value (new_target_p);\n  JERRY_ASSERT (native_function_p->native_handler_cb != NULL);\n  ecma_value_t ret_value = native_function_p->native_handler_cb (&call_info, arguments_list_p, arguments_list_len);\n#if JERRY_BUILTIN_REALMS\n  JERRY_CONTEXT (global_object_p) = saved_global_object_p;\n#endif \n  if (JERRY_UNLIKELY (ecma_is_value_exception (ret_value)))\n  {\n    ecma_throw_exception (ret_value);\n    return ECMA_VALUE_ERROR;\n  }\n#if JERRY_DEBUGGER\n  JERRY_DEBUGGER_CLEAR_FLAGS (JERRY_DEBUGGER_VM_EXCEPTION_THROWN);\n#endif \n  return ret_value;\n} ", "target": 0}
{"code": "int copy_strings_kernel(int argc,char ** argv, struct linux_binprm *bprm)\n{\n\tint r;\n\tmm_segment_t oldfs = get_fs();\n\tset_fs(KERNEL_DS);\n\tr = copy_strings(argc, (char __user * __user *)argv, bprm);\n\tset_fs(oldfs);\n\treturn r;\n}", "target": 0}
{"code": "static int set_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)\n{\n\t__u32 __user *uaddr = (__u32 __user *)(unsigned long)reg->addr;\n\tstruct kvm_regs *regs = vcpu_gp_regs(vcpu);\n\tint nr_regs = sizeof(*regs) / sizeof(__u32);\n\t__uint128_t tmp;\n\tvoid *valp = &tmp;\n\tu64 off;\n\tint err = 0;\n\toff = core_reg_offset_from_id(reg->id);\n\tif (off >= nr_regs ||\n\t    (off + (KVM_REG_SIZE(reg->id) / sizeof(__u32))) >= nr_regs)\n\t\treturn -ENOENT;\n\tif (validate_core_offset(reg))\n\t\treturn -EINVAL;\n\tif (KVM_REG_SIZE(reg->id) > sizeof(tmp))\n\t\treturn -EINVAL;\n\tif (copy_from_user(valp, uaddr, KVM_REG_SIZE(reg->id))) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\tif (off == KVM_REG_ARM_CORE_REG(regs.pstate)) {\n\t\tu64 mode = (*(u64 *)valp) & PSR_AA32_MODE_MASK;\n\t\tswitch (mode) {\n\t\tcase PSR_AA32_MODE_USR:\n\t\t\tif (!system_supports_32bit_el0())\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase PSR_AA32_MODE_FIQ:\n\t\tcase PSR_AA32_MODE_IRQ:\n\t\tcase PSR_AA32_MODE_SVC:\n\t\tcase PSR_AA32_MODE_ABT:\n\t\tcase PSR_AA32_MODE_UND:\n\t\t\tif (!vcpu_el1_is_32bit(vcpu))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase PSR_MODE_EL0t:\n\t\tcase PSR_MODE_EL1t:\n\t\tcase PSR_MODE_EL1h:\n\t\t\tif (vcpu_el1_is_32bit(vcpu))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmemcpy((u32 *)regs + off, valp, KVM_REG_SIZE(reg->id));\nout:\n\treturn err;\n}", "target": 0}
{"code": "int regexec(Reprog *prog, const char *sp, Resub *sub, int eflags)\n{\n\tResub scratch;\n\tint i;\n\tif (!sub)\n\t\tsub = &scratch;\n\tsub->nsub = prog->nsub;\n\tfor (i = 0; i < MAXSUB; ++i)\n\t\tsub->sub[i].sp = sub->sub[i].ep = NULL;\n\treturn !match(prog->start, sp, sp, prog->flags | eflags, sub);\n}", "target": 1}
{"code": "static void do_free_publickey(struct rsa_public_key *s)\n{\n\tif (s) {\n\t\tcrypto_bignum_free(s->n);\n\t\tcrypto_bignum_free(s->e);\n\t}\n}", "target": 1}
{"code": "int message_add_body_amqp_sequence(MESSAGE_HANDLE message, AMQP_VALUE sequence_list)\n{\n    int result;\n    if ((message == NULL) ||\n        (sequence_list == NULL))\n    {\n        LogError(\"Bad arguments: message = %p, sequence_list = %p\",\n            message, sequence_list);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        MESSAGE_BODY_TYPE body_type = internal_get_body_type(message);\n        if ((body_type == MESSAGE_BODY_TYPE_DATA) ||\n            (body_type == MESSAGE_BODY_TYPE_VALUE))\n        {\n            LogError(\"Body is already set to another body type\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            AMQP_VALUE* new_body_amqp_sequence_items = (AMQP_VALUE*)realloc(message->body_amqp_sequence_items, sizeof(AMQP_VALUE) * (message->body_amqp_sequence_count + 1));\n            if (new_body_amqp_sequence_items == NULL)\n            {\n                LogError(\"Cannot allocate enough memory for sequence items\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                message->body_amqp_sequence_items = new_body_amqp_sequence_items;\n                message->body_amqp_sequence_items[message->body_amqp_sequence_count] = amqpvalue_clone(sequence_list);\n                if (message->body_amqp_sequence_items[message->body_amqp_sequence_count] == NULL)\n                {\n                    LogError(\"Cloning sequence failed\");\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    message->body_amqp_sequence_count++;\n                    result = 0;\n                }\n            }\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "njs_function_capture_closure(njs_vm_t *vm, njs_function_t *function,\n    njs_function_lambda_t *lambda)\n{\n    void                *start, *end;\n    uint32_t            n;\n    njs_value_t         *value, **closure;\n    njs_native_frame_t  *frame;\n    if (lambda->nclosures == 0) {\n        return NJS_OK;\n    }\n    frame = &vm->active_frame->native;\n    while (frame->native) {\n        frame = frame->previous;\n    }\n    start = frame;\n    end = frame->free;\n    closure = njs_function_closures(function);\n    n = lambda->nclosures;\n    do {\n        n--;\n        value = njs_scope_value(vm, lambda->closures[n]);\n        if (start <= (void *) value && (void *) value < end) {\n            value = njs_scope_value_clone(vm, lambda->closures[n], value);\n            if (njs_slow_path(value == NULL)) {\n                return NJS_ERROR;\n            }\n        }\n        closure[n] = value;\n    } while (n != 0);\n    return NJS_OK;\n}", "target": 0}
{"code": "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);\n}", "target": 1}
{"code": "int socket_accept(int fd, uint16_t port)\n{\n#ifdef WIN32\n\tint addr_len;\n#else\n\tsocklen_t addr_len;\n#endif\n\tint result;\n\tstruct sockaddr_in addr;\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\taddr.sin_port = htons(port);\n\taddr_len = sizeof(addr);\n\tresult = accept(fd, (struct sockaddr*)&addr, &addr_len);\n\treturn result;\n}", "target": 1}
{"code": "BOOL transport_connect_nla(rdpTransport* transport)\n{\n\tfreerdp* instance;\n\trdpSettings* settings;\n\tif (transport->layer == TRANSPORT_LAYER_TSG)\n\t\treturn TRUE;\n\tif (!transport_connect_tls(transport))\n\t\treturn FALSE;\n\tif (transport->settings->Authentication != TRUE)\n\t\treturn TRUE;\n\tsettings = transport->settings;\n\tinstance = (freerdp*) settings->instance;\n\tif (transport->credssp == NULL)\n\t\ttransport->credssp = credssp_new(instance, transport, settings);\n\tif (credssp_authenticate(transport->credssp) < 0)\n\t{\n\t\tif (!connectErrorCode)\n\t\t\tconnectErrorCode = AUTHENTICATIONERROR;\n\t\tfprintf(stderr, \"Authentication failure, check credentials.\\n\"\n\t\t\t\"If credentials are valid, the NTLMSSP implementation may be to blame.\\n\");\n\t\tcredssp_free(transport->credssp);\n\t\ttransport->credssp = NULL;\n\t\treturn FALSE;\n\t}\n\tcredssp_free(transport->credssp);\n\treturn TRUE;\n}", "target": 0}
{"code": "crm_parse_remote_buffer(char **msg_buf)\n{\n    char *buf = NULL;\n    char *start = NULL;\n    char *end = NULL;\n    xmlNode *xml = NULL;\n    if (*msg_buf == NULL) {\n        return NULL;\n    }\n    buf = *msg_buf;\n    *msg_buf = NULL;\n    start = buf;\n    end = strstr(start, REMOTE_MSG_TERMINATOR);\n    while (!xml && end) {\n        end[0] = '\\0';\n        end += strlen(REMOTE_MSG_TERMINATOR);\n        xml = string2xml(start);\n        if (xml == NULL) {\n            crm_err(\"Couldn't parse: '%.120s'\", start);\n        }\n        start = end;\n        end = strstr(start, REMOTE_MSG_TERMINATOR);\n    }\n    if (xml && start) {\n        *msg_buf = strdup(start);\n        free(buf);\n    } else if (!xml) {\n        *msg_buf = buf;\n    }\n    return xml;\n}", "target": 0}
{"code": "int input_set_keycode(struct input_dev *dev,\n\t\t      const struct input_keymap_entry *ke)\n{\n\tunsigned long flags;\n\tunsigned int old_keycode;\n\tint retval;\n\tif (ke->keycode > KEY_MAX)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&dev->event_lock, flags);\n\tretval = dev->setkeycode(dev, ke, &old_keycode);\n\tif (retval)\n\t\tgoto out;\n\t__clear_bit(KEY_RESERVED, dev->keybit);\n\tif (test_bit(EV_KEY, dev->evbit) &&\n\t    !is_event_supported(old_keycode, dev->keybit, KEY_MAX) &&\n\t    __test_and_clear_bit(old_keycode, dev->key)) {\n\t\tstruct input_value vals[] =  {\n\t\t\t{ EV_KEY, old_keycode, 0 },\n\t\t\tinput_value_sync\n\t\t};\n\t\tinput_pass_values(dev, vals, ARRAY_SIZE(vals));\n\t}\n out:\n\tspin_unlock_irqrestore(&dev->event_lock, flags);\n\treturn retval;\n}", "target": 1}
{"code": "int nfs4_proc_fs_locations(struct rpc_clnt *client, struct inode *dir,\n\t\t\t   const struct qstr *name,\n\t\t\t   struct nfs4_fs_locations *fs_locations,\n\t\t\t   struct page *page)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t_nfs4_proc_fs_locations(client, dir, name, fs_locations, page),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}", "target": 0}
{"code": "void FoFiTrueType::cvtEncoding(char **encoding,\n\t\t\t       FoFiOutputFunc outputFunc,\n\t\t\t       void *outputStream) {\n  const char *name;\n  GooString *buf;\n  int i;\n  (*outputFunc)(outputStream, \"/Encoding 256 array\\n\", 20);\n  if (encoding) {\n    for (i = 0; i < 256; ++i) {\n      if (!(name = encoding[i])) {\n\tname = \".notdef\";\n      }\n      buf = GooString::format(\"dup {0:d} /\", i);\n      (*outputFunc)(outputStream, buf->getCString(), buf->getLength());\n      delete buf;\n      (*outputFunc)(outputStream, name, strlen(name));\n      (*outputFunc)(outputStream, \" put\\n\", 5);\n    }\n  } else {\n    for (i = 0; i < 256; ++i) {\n      buf = GooString::format(\"dup {0:d} /c{1:02x} put\\n\", i, i);\n      (*outputFunc)(outputStream, buf->getCString(), buf->getLength());\n      delete buf;\n    }\n  }\n  (*outputFunc)(outputStream, \"readonly def\\n\", 13);\n}", "target": 0}
{"code": "static void sas_scsi_clear_queue_lu(struct list_head *error_q, struct scsi_cmnd *my_cmd)\n{\n\tstruct scsi_cmnd *cmd, *n;\n\tlist_for_each_entry_safe(cmd, n, error_q, eh_entry) {\n\t\tif (cmd->device->sdev_target == my_cmd->device->sdev_target &&\n\t\t    cmd->device->lun == my_cmd->device->lun)\n\t\t\tsas_eh_defer_cmd(cmd);\n\t}\n}", "target": 1}
{"code": "void file_sb_list_del(struct file *file)\n{\n\tif (!list_empty(&file->f_u.fu_list)) {\n\t\tlg_local_lock_cpu(&files_lglock, file_list_cpu(file));\n\t\tlist_del_init(&file->f_u.fu_list);\n\t\tlg_local_unlock_cpu(&files_lglock, file_list_cpu(file));\n\t}\n}", "target": 1}
{"code": "nvkm_vmm_put_region(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n{\n\tstruct nvkm_vma *prev, *next;\n\tif ((prev = node(vma, prev)) && !prev->used) {\n\t\trb_erase(&prev->tree, &vmm->free);\n\t\tlist_del(&prev->head);\n\t\tvma->addr  = prev->addr;\n\t\tvma->size += prev->size;\n\t\tkfree(prev);\n\t}\n\tif ((next = node(vma, next)) && !next->used) {\n\t\trb_erase(&next->tree, &vmm->free);\n\t\tlist_del(&next->head);\n\t\tvma->size += next->size;\n\t\tkfree(next);\n\t}\n\tnvkm_vmm_free_insert(vmm, vma);\n}", "target": 1}
{"code": "inline int MatchingDim(const RuntimeShape& shape1, int index1,\n                       const RuntimeShape& shape2, int index2) {\n  TFLITE_DCHECK_EQ(shape1.Dims(index1), shape2.Dims(index2));\n  return shape1.Dims(index1);\n}", "target": 1}
{"code": "  friend H AbslHashValue(H h, const TensorKey& k) {\n    const uint8* d = static_cast<uint8*>(k.data());\n    size_t s = k.AllocatedBytes();\n    std::vector<uint8> vec;\n    vec.reserve(s);\n    for (int i = 0; i < s; i++) {\n      vec.push_back(d[i]);\n    }\n    return H::combine(std::move(h), s);\n  }", "target": 1}
{"code": "Http::FilterTrailersStatus Context::onRequestTrailers() {\n  if (!wasm_->onRequestTrailers_) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  if (wasm_->onRequestTrailers_(this, id_).u64_ == 0) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  return Http::FilterTrailersStatus::StopIteration;\n}", "target": 1}
{"code": "void gf_isom_check_position(GF_Box *s, GF_Box *child, u32 *pos)\n{\n\tif (!s || !s->child_boxes || !child || !pos) return;\n\tif (s->internal_flags & GF_ISOM_ORDER_FREEZE)\n\t\treturn;\n\ts32 cur_pos = gf_list_find(s->child_boxes, child);\n\tif (cur_pos < 0) return;\n\tif (cur_pos != (s32) *pos) {\n\t\tgf_list_del_item(s->child_boxes, child);\n\t\tgf_list_insert(s->child_boxes, child, *pos);\n\t}\n\t(*pos)++;", "target": 1}
{"code": "Item_cond_and::add_key_fields(JOIN *join, KEY_FIELD **key_fields,\n                              uint *and_level, table_map usable_tables,\n                              SARGABLE_PARAM **sargables)\n{\n  List_iterator_fast<Item> li(*argument_list());\n  KEY_FIELD *org_key_fields= *key_fields;\n  Item *item;\n  while ((item=li++))\n    item->add_key_fields(join, key_fields, and_level, usable_tables,\n                         sargables);\n  for (; org_key_fields != *key_fields ; org_key_fields++)\n    org_key_fields->level= *and_level;\n}", "target": 0}
{"code": "static void tm_reclaim_thread(struct thread_struct *thr,\n\t\t\t      struct thread_info *ti, uint8_t cause)\n{\n\tunsigned long msr_diff = 0;\n\tif (test_ti_thread_flag(ti, TIF_RESTORE_TM)) {\n\t\tmsr_diff = thr->ckpt_regs.msr & ~thr->regs->msr;\n\t\tif (msr_diff & MSR_FP)\n\t\t\tmemcpy(&thr->transact_fp, &thr->fp_state,\n\t\t\t       sizeof(struct thread_fp_state));\n\t\tif (msr_diff & MSR_VEC)\n\t\t\tmemcpy(&thr->transact_vr, &thr->vr_state,\n\t\t\t       sizeof(struct thread_vr_state));\n\t\tclear_ti_thread_flag(ti, TIF_RESTORE_TM);\n\t\tmsr_diff &= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;\n\t}\n\tif (!MSR_TM_SUSPENDED(mfmsr()))\n\t\treturn;\n\ttm_reclaim(thr, thr->regs->msr, cause);\n\tthr->regs->msr |= msr_diff;\n}", "target": 0}
{"code": "unquoted_glob_pattern_p (string)\n     register char *string;\n{\n  register int c;\n  char *send;\n  int open, bsquote;\n  DECLARE_MBSTATE;\n  open = bsquote = 0;\n  send = string + strlen (string);\n  while (c = *string++)\n    {\n      switch (c)\n\t{\n\tcase '?':\n\tcase '*':\n\t  return (1);\n\tcase '[':\n\t  open++;\n\t  continue;\n\tcase ']':\n\t  if (open)\n\t    return (1);\n\t  continue;\n\tcase '+':\n\tcase '@':\n\tcase '!':\n\t  if (*string == '(')\t\n\t    return (1);\n\t  continue;\n\tcase '\\\\':\n\t  if (*string != '\\0' && *string != '/')\n\t    {\n\t      bsquote = 1;\n\t      string++;\n\t      continue;\n\t    }\n\t  else if (*string == 0)\n\t    return (0);\n\tcase CTLESC:\n\t  if (*string++ == '\\0')\n\t    return (0);\n\t}\n#ifdef HANDLE_MULTIBYTE\n      string--;\n      ADVANCE_CHAR_P (string, send - string);\n      string++;\n#else\n      ADVANCE_CHAR_P (string, send - string);\n#endif\n    }\n  return ((bsquote && posix_glob_backslash) ? 2 : 0);\n}", "target": 1}
{"code": "void Context::onDelete() {\n  if (wasm_->onDelete_) {\n    wasm_->onDelete_(this, id_);\n  }\n}", "target": 1}
{"code": "static int getid(char ch) {\n\tconst char *keys = \"[]<>+-,.\";\n\tconst char *cidx = strchr (keys, ch);\n\treturn cidx? cidx - keys + 1: 0;\n}", "target": 1}
{"code": "CURLcode Curl_urldecode(struct SessionHandle *data,\n                        const char *string, size_t length,\n                        char **ostring, size_t *olen,\n                        bool reject_ctrl)\n{\n  size_t alloc = (length?length:strlen(string))+1;\n  char *ns = malloc(alloc);\n  unsigned char in;\n  size_t strindex=0;\n  unsigned long hex;\n  CURLcode res;\n  if(!ns)\n    return CURLE_OUT_OF_MEMORY;\n  while(--alloc > 0) {\n    in = *string;\n    if(('%' == in) && (alloc > 2) &&\n       ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {\n      char hexstr[3];\n      char *ptr;\n      hexstr[0] = string[1];\n      hexstr[1] = string[2];\n      hexstr[2] = 0;\n      hex = strtoul(hexstr, &ptr, 16);\n      in = curlx_ultouc(hex); \n      res = Curl_convert_from_network(data, &in, 1);\n      if(res) {\n        free(ns);\n        return res;\n      }\n      string+=2;\n      alloc-=2;\n    }\n    if(reject_ctrl && (in < 0x20)) {\n      free(ns);\n      return CURLE_URL_MALFORMAT;\n    }\n    ns[strindex++] = in;\n    string++;\n  }\n  ns[strindex]=0; \n  if(olen)\n    *olen = strindex;\n  if(ostring)\n    *ostring = ns;\n  return CURLE_OK;\n}", "target": 0}
{"code": "  Status operator()(OpKernelContext* context,\n                    typename TTypes<Tindex>::ConstVec reverse_index_map,\n                    typename TTypes<T>::ConstVec grad_values,\n                    typename TTypes<T>::Vec d_values,\n                    typename TTypes<T>::Scalar d_default_value) {\n    const GPUDevice& device = context->eigen_device<GPUDevice>();\n    const Tindex N = reverse_index_map.dimension(0);\n    const Tindex N_full = grad_values.dimension(0);\n    Tensor visited_t;\n    TF_RETURN_IF_ERROR(\n        context->allocate_temp(DT_BOOL, TensorShape({N_full}), &visited_t));\n    auto visited = visited_t.vec<bool>();\n    visited.device(device) = visited.constant(false);\n    TF_RETURN_IF_ERROR(wrap_kernel_call(\n        GatherOriginalGradValuesKernel<T, Tindex>, device,\n        N, reverse_index_map, grad_values, d_values, visited));\n    gpuprim::CountingInputIterator<Tindex, Tindex> counting_iterator(Tindex(0));\n    ZeroMaskedValues<T, Tindex> mask_values_fn(visited.data(),\n                                               grad_values.data());\n    gpuprim::TransformInputIterator<T, decltype(mask_values_fn),\n                                    decltype(counting_iterator), Tindex>\n        transform_iterator(counting_iterator, mask_values_fn);\n    std::size_t temp_storage_bytes = 0;\n    auto gpuprim_status = gpuprim::DeviceReduce::Sum(\n        nullptr, temp_storage_bytes,\n        transform_iterator,\n        d_default_value.data(),\n        N_full,\n        device.stream());\n    if (gpuprim_status != gpuSuccess) {\n      return errors::Internal(\n          \"SparseFillEmptyRowsGrad: Could not launch \"\n          \"gpuprim::DeviceReduce::Sum to calculate temp_storage_bytes, \"\n          \"status: \",\n          GpuGetErrorString(gpuprim_status));\n    }\n    Tensor temp_storage;\n    TF_RETURN_IF_ERROR(context->allocate_temp(\n        DT_INT8, TensorShape({static_cast<int64_t>(temp_storage_bytes)}),\n        &temp_storage));\n    gpuprim_status = gpuprim::DeviceReduce::Sum(\n        temp_storage.flat<int8>().data(), temp_storage_bytes,\n        transform_iterator,\n        d_default_value.data(),\n        N_full,\n        device.stream());\n    if (gpuprim_status != gpuSuccess) {\n      return errors::Internal(\n          \"SparseFillEmptyRowsGrad: Could not launch \"\n          \"gpuprim::DeviceReduce::Sum to sum values from originally-empty \"\n          \"rows. temp_storage_bytes: \",\n          temp_storage_bytes, \", status: \", GpuGetErrorString(gpuprim_status));\n    }\n    return OkStatus();\n  }", "target": 1}
{"code": "int tls_free_buffers(OSSL_RECORD_LAYER *rl)\n{\n    if (rl->direction == OSSL_RECORD_DIRECTION_WRITE) {\n        if (rl->nextwbuf < rl->numwpipes) {\n            if (rl->nextwbuf != 0\n                    || rl->numwpipes != 1\n                    || TLS_BUFFER_get_left(&rl->wbuf[0]) != 0)\n                return 0;\n        }\n        tls_release_write_buffer(rl);\n        return 1;\n    }\n    if (rl->curr_rec < rl->num_recs || TLS_BUFFER_get_left(&rl->rbuf) != 0)\n        return 0;\n    return tls_release_read_buffer(rl);\n}", "target": 1}
{"code": "TfLiteStatus ExpandTensorDim(TfLiteContext* context, const TfLiteTensor& input,\n                             int axis, TfLiteTensor* output) {\n  const TfLiteIntArray& input_dims = *input.dims;\n  if (axis < 0) {\n    axis = input_dims.size + 1 + axis;\n  }\n  TF_LITE_ENSURE(context, axis <= input_dims.size);\n  TF_LITE_ENSURE(context, axis >= 0);\n  TfLiteIntArray* output_dims = TfLiteIntArrayCreate(input_dims.size + 1);\n  for (int i = 0; i < output_dims->size; ++i) {\n    if (i < axis) {\n      output_dims->data[i] = input_dims.data[i];\n    } else if (i == axis) {\n      output_dims->data[i] = 1;\n    } else {\n      output_dims->data[i] = input_dims.data[i - 1];\n    }\n  }\n  return context->ResizeTensor(context, output, output_dims);\n}", "target": 0}
{"code": "static struct ion_handle *ion_handle_get_by_id(struct ion_client *client,\n\t\t\t\t\t\tint id)\n{\n\tstruct ion_handle *handle;\n\tmutex_lock(&client->lock);\n\thandle = idr_find(&client->idr, id);\n\tif (handle)\n\t\tion_handle_get(handle);\n\tmutex_unlock(&client->lock);\n\treturn handle ? handle : ERR_PTR(-EINVAL);\n}", "target": 1}
{"code": "bool TensorSliceReader::CopySliceData(const string& name,\n                                      const TensorSlice& slice, T* data) const {\n  std::vector<std::pair<TensorSlice, string>> details;\n  const TensorSliceSet* tss;\n  {\n    mutex_lock l(mu_);\n    tss = FindTensorSlice(name, slice, &details);\n    if (!tss && !all_shards_loaded_) {\n      VLOG(1) << \"Did not find slice in preferred shard, loading all shards.\"\n              << name << \": \" << slice.DebugString();\n      LoadAllShards();\n      tss = FindTensorSlice(name, slice, &details);\n    }\n    if (!tss) {\n      return false;\n    }\n  }\n  string value;\n  for (const auto& x : details) {\n    const TensorSlice& slice_s = x.first;\n    const string& fname = x.second;\n    int idx = gtl::FindWithDefault(fname_to_index_, fname, -1);\n    CHECK_GE(idx, 0) << \"Failed to find the index for filename \" << fname;\n    const string key = EncodeTensorNameSlice(name, slice_s);\n    if (!sss_[idx]->Get(key, &value)) {\n      VLOG(1) << \"Failed to seek to the record for tensor \" << name\n              << \", slice \" << slice_s.DebugString()\n              << \": computed key = \" << key;\n      return false;\n    }\n    SavedTensorSlices sts;\n    if (!ParseProtoUnlimited(&sts, value)) {\n      VLOG(1) << \"Failed to parse the record for tensor \" << name << \", slice \"\n              << slice_s.DebugString() << \": computed key = \" << key;\n      return false;\n    }\n    TensorShape shp_s;\n    Status s = slice_s.SliceTensorShape(tss->shape(), &shp_s);\n    if (!s.ok()) {\n      VLOG(1) << \"Failed to slice tensor \" << name << \", slice \"\n              << slice_s.DebugString() << \": \" << s;\n      return false;\n    }\n    if (checkpoint::TensorProtoDataSize<T>(sts.data().data()) !=\n        shp_s.num_elements()) {\n      VLOG(1) << \"Tensor \" << name << \", slice \" << slice_s.DebugString()\n              << \" had an unexpected amount of data: expected = \"\n              << shp_s.num_elements() << \", got = \"\n              << checkpoint::TensorProtoDataSize<T>(sts.data().data());\n      return false;\n    }\n    CopyDataFromTensorSliceToTensorSlice(\n        tss->shape(), slice_s, slice,\n        checkpoint::TensorProtoData<T>(sts.data().data()), data);\n  }\n  return true;\n}", "target": 0}
{"code": "static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n#ifdef CONFIG_NUMA\n\treturn s->node[node];\n#else\n\treturn &s->local_node;\n#endif\n}", "target": 0}
{"code": "size_t TensorSliceWriter::MaxBytesPerElement(DataType dt) {\n  switch (dt) {\n    case DT_FLOAT:\n      return 4;\n    case DT_DOUBLE:\n      return 8;\n    case DT_INT32:\n      return 10;\n    case DT_UINT8:\n      return 2;\n    case DT_INT16:\n      return 10;\n    case DT_INT8:\n      return 10;\n    case DT_COMPLEX64:\n      return 8;\n    case DT_INT64:\n      return 10;\n    case DT_BOOL:\n      return 1;\n    case DT_QINT8:\n      return 10;\n    case DT_QUINT8:\n      return 2;\n    case DT_QINT32:\n      return 10;\n    case DT_QINT16:\n      return 10;\n    case DT_QUINT16:\n      return 3;\n    case DT_UINT16:\n      return 3;\n    case DT_COMPLEX128:\n      return 16;\n    case DT_HALF:\n      return 3;\n    case DT_INVALID:\n    case DT_STRING:\n    case DT_BFLOAT16:\n    default:\n      LOG(FATAL) << \"MaxBytesPerElement not implemented for dtype: \" << dt;\n  }\n  return 0;\n}", "target": 1}
{"code": "static long mem_seek(jas_stream_obj_t *obj, long offset, int origin)\n{\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tlong newpos;\n\tJAS_DBGLOG(100, (\"mem_seek(%p, %ld, %d)\\n\", obj, offset, origin));\n\tswitch (origin) {\n\tcase SEEK_SET:\n\t\tnewpos = offset;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tnewpos = m->len_ - offset;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tnewpos = m->pos_ + offset;\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t\tbreak;\n\t}\n\tif (newpos < 0) {\n\t\treturn -1;\n\t}\n\tm->pos_ = newpos;\n\treturn m->pos_;\n}", "target": 1}
{"code": "void cql_server::response::write_bytes(bytes b)\n{\n    write_int(cast_if_fits<int32_t>(b.size()));\n    _body.write(b);\n}", "target": 0}
{"code": "void cipso_v4_req_delattr(struct request_sock *req)\n{\n\tstruct ip_options *opt;\n\tstruct inet_request_sock *req_inet;\n\treq_inet = inet_rsk(req);\n\topt = req_inet->opt;\n\tif (opt == NULL || opt->cipso == 0)\n\t\treturn;\n\tcipso_v4_delopt(&req_inet->opt);\n}", "target": 1}
{"code": "static int __init ipgre_init(void)\n{\n\tint err;\n\tprintk(KERN_INFO \"GRE over IPv4 tunneling driver\\n\");\n\tif (inet_add_protocol(&ipgre_protocol, IPPROTO_GRE) < 0) {\n\t\tprintk(KERN_INFO \"ipgre init: can't add protocol\\n\");\n\t\treturn -EAGAIN;\n\t}\n\terr = register_pernet_device(&ipgre_net_ops);\n\tif (err < 0)\n\t\tgoto gen_device_failed;\n\terr = rtnl_link_register(&ipgre_link_ops);\n\tif (err < 0)\n\t\tgoto rtnl_link_failed;\n\terr = rtnl_link_register(&ipgre_tap_ops);\n\tif (err < 0)\n\t\tgoto tap_ops_failed;\nout:\n\treturn err;\ntap_ops_failed:\n\trtnl_link_unregister(&ipgre_link_ops);\nrtnl_link_failed:\n\tunregister_pernet_device(&ipgre_net_ops);\ngen_device_failed:\n\tinet_del_protocol(&ipgre_protocol, IPPROTO_GRE);\n\tgoto out;\n}", "target": 1}
{"code": "int unshare_userns(unsigned long unshare_flags, struct cred **new_cred)\n{\n\tstruct cred *cred;\n\tif (!(unshare_flags & CLONE_NEWUSER))\n\t\treturn 0;\n\tcred = prepare_creds();\n\tif (!cred)\n\t\treturn -ENOMEM;\n\t*new_cred = cred;\n\treturn create_user_ns(cred);\n}", "target": 1}
{"code": "int generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tif (inode_capable(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (inode_capable(inode, CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (inode_capable(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (inode_capable(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\treturn -EACCES;\n}", "target": 1}
{"code": "LUA_API void lua_upvaluejoin (lua_State *L, int fidx1, int n1,\n                                            int fidx2, int n2) {\n  LClosure *f1;\n  UpVal **up1 = getupvalref(L, fidx1, n1, &f1);\n  UpVal **up2 = getupvalref(L, fidx2, n2, NULL);\n  luaC_upvdeccount(L, *up1);\n  *up1 = *up2;\n  (*up1)->refcount++;\n  if (upisopen(*up1)) (*up1)->u.open.touched = 1;\n  luaC_upvalbarrier(L, *up1);\n}", "target": 1}
{"code": "int create_user_ns(struct cred *new)\n{\n\tstruct user_namespace *ns, *parent_ns = new->user_ns;\n\tkuid_t owner = new->euid;\n\tkgid_t group = new->egid;\n\tint ret;\n\tif (current_chrooted())\n\t\treturn -EPERM;\n\tif (!kuid_has_mapping(parent_ns, owner) ||\n\t    !kgid_has_mapping(parent_ns, group))\n\t\treturn -EPERM;\n\tns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);\n\tif (!ns)\n\t\treturn -ENOMEM;\n\tret = proc_alloc_inum(&ns->proc_inum);\n\tif (ret) {\n\t\tkmem_cache_free(user_ns_cachep, ns);\n\t\treturn ret;\n\t}\n\tatomic_set(&ns->count, 1);\n\tns->parent = parent_ns;\n\tns->owner = owner;\n\tns->group = group;\n\tset_cred_user_ns(new, ns);\n\treturn 0;\n}", "target": 0}
{"code": "int Archive::Read(void *Data,size_t Size)\n{\n  size_t Result;\n  if (QOpen.Read(Data,Size,Result))\n    return (int)Result;\n  return File::Read(Data,Size);\n}", "target": 1}
{"code": "int fscrypt_process_policy(struct inode *inode,\n\t\t\t\tconst struct fscrypt_policy *policy)\n{\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EACCES;\n\tif (policy->version != 0)\n\t\treturn -EINVAL;\n\tif (!inode_has_encryption_context(inode)) {\n\t\tif (!inode->i_sb->s_cop->empty_dir)\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (!inode->i_sb->s_cop->empty_dir(inode))\n\t\t\treturn -ENOTEMPTY;\n\t\treturn create_encryption_context_from_policy(inode, policy);\n\t}\n\tif (is_encryption_context_consistent_with_policy(inode, policy))\n\t\treturn 0;\n\tprintk(KERN_WARNING \"%s: Policy inconsistent with encryption context\\n\",\n\t       __func__);\n\treturn -EINVAL;\n}", "target": 0}
{"code": "name_len(netdissect_options *ndo,\n         const unsigned char *s, const unsigned char *maxbuf)\n{\n    const unsigned char *s0 = s;\n    unsigned char c;\n    if (s >= maxbuf)\n\treturn(-1);\t\n    ND_TCHECK2(*s, 1);\n    c = *s;\n    if ((c & 0xC0) == 0xC0)\n\treturn(2);\n    while (*s) {\n\tif (s >= maxbuf)\n\t    return(-1);\t\n\tND_TCHECK2(*s, 1);\n\ts += (*s) + 1;\n\tND_TCHECK2(*s, 1);\n    }\n    return(PTR_DIFF(s, s0) + 1);\ntrunc:\n    return(-1);\t\n}", "target": 0}
{"code": "int create_flush_cmd_control(struct f2fs_sb_info *sbi)\n{\n\tdev_t dev = sbi->sb->s_bdev->bd_dev;\n\tstruct flush_cmd_control *fcc;\n\tint err = 0;\n\tif (SM_I(sbi)->fcc_info) {\n\t\tfcc = SM_I(sbi)->fcc_info;\n\t\tgoto init_thread;\n\t}\n\tfcc = kzalloc(sizeof(struct flush_cmd_control), GFP_KERNEL);\n\tif (!fcc)\n\t\treturn -ENOMEM;\n\tatomic_set(&fcc->issued_flush, 0);\n\tatomic_set(&fcc->issing_flush, 0);\n\tinit_waitqueue_head(&fcc->flush_wait_queue);\n\tinit_llist_head(&fcc->issue_list);\n\tSM_I(sbi)->fcc_info = fcc;\n\tif (!test_opt(sbi, FLUSH_MERGE))\n\t\treturn err;\ninit_thread:\n\tfcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,\n\t\t\t\t\"f2fs_flush-%u:%u\", MAJOR(dev), MINOR(dev));\n\tif (IS_ERR(fcc->f2fs_issue_flush)) {\n\t\terr = PTR_ERR(fcc->f2fs_issue_flush);\n\t\tkfree(fcc);\n\t\tSM_I(sbi)->fcc_info = NULL;\n\t\treturn err;\n\t}\n\treturn err;\n}", "target": 0}
{"code": "njs_promise_perform_any_handler(njs_vm_t *vm, njs_iterator_args_t *args,\n    njs_value_t *value, int64_t index)\n{\n    njs_int_t                    ret;\n    njs_array_t                  *array;\n    njs_value_t                  arguments[2], next;\n    njs_function_t               *on_rejected;\n    njs_promise_capability_t     *capability;\n    njs_promise_all_context_t    *context;\n    njs_promise_iterator_args_t  *pargs;\n    if (!njs_is_valid(value)) {\n        value = njs_value_arg(&njs_value_undefined);\n    }\n    pargs = (njs_promise_iterator_args_t *) args;\n    capability = pargs->capability;\n    array = pargs->args.data;\n    njs_set_undefined(&array->start[index]);\n    ret = njs_function_call(vm, pargs->function, pargs->constructor, value, 1,\n                            &next);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n    on_rejected = njs_promise_create_function(vm,\n                                            sizeof(njs_promise_all_context_t));\n    if (njs_slow_path(on_rejected == NULL)) {\n        return NJS_ERROR;\n    }\n    on_rejected->u.native = njs_promise_any_reject_element_functions;\n    on_rejected->args_count = 1;\n    context = on_rejected->context;\n    context->already_called = 0;\n    context->index = (uint32_t) index;\n    context->values = pargs->args.data;\n    context->capability = capability;\n    context->remaining_elements = pargs->remaining;\n    (*pargs->remaining)++;\n    arguments[0] = capability->resolve;\n    njs_set_function(&arguments[1], on_rejected);\n    ret = njs_promise_invoke_then(vm, &next, arguments, 2);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n    return NJS_OK;\n}", "target": 0}
{"code": "static int g2m_init_buffers(G2MContext *c)\n{\n    int aligned_height;\n    if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {\n        c->framebuf_stride = FFALIGN(c->width + 15, 16) * 3;\n        aligned_height     = c->height + 15;\n        av_free(c->framebuf);\n        c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);\n        if (!c->framebuf)\n            return AVERROR(ENOMEM);\n    }\n    if (!c->synth_tile || !c->jpeg_tile ||\n        c->old_tile_w < c->tile_width ||\n        c->old_tile_h < c->tile_height) {\n        c->tile_stride = FFALIGN(c->tile_width, 16) * 3;\n        aligned_height = FFALIGN(c->tile_height,    16);\n        av_free(c->synth_tile);\n        av_free(c->jpeg_tile);\n        av_free(c->kempf_buf);\n        av_free(c->kempf_flags);\n        c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);\n        c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);\n        c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height\n                                    + FF_INPUT_BUFFER_PADDING_SIZE);\n        c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);\n        if (!c->synth_tile || !c->jpeg_tile ||\n            !c->kempf_buf || !c->kempf_flags)\n            return AVERROR(ENOMEM);\n    }\n    return 0;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* c) override {\n    PartialTensorShape element_shape;\n    OP_REQUIRES_OK(c, TensorShapeFromTensor(c->input(0), &element_shape));\n    OP_REQUIRES(\n        c, TensorShapeUtils::IsScalar(c->input(1).shape()),\n        errors::InvalidArgument(\n            \"The num_elements to reserve must be a tensor size 1, but got \",\n            c->input(1).shape()));\n    int32_t num_elements = c->input(1).scalar<int32>()();\n    OP_REQUIRES(c, num_elements >= 0,\n                errors::InvalidArgument(\"The num_elements to reserve must be a \"\n                                        \"non negative number, but got \",\n                                        num_elements));\n    TensorList output;\n    output.element_shape = element_shape;\n    output.element_dtype = element_dtype_;\n    output.tensors().resize(num_elements, Tensor(DT_INVALID));\n    Tensor* result;\n    AllocatorAttributes attr;\n    attr.set_on_host(true);\n    OP_REQUIRES_OK(c, c->allocate_output(0, TensorShape{}, &result, attr));\n    result->scalar<Variant>()() = std::move(output);\n  }", "target": 0}
{"code": "static void handle_post_create(struct http_conn *conn,\n\t\t\t       struct mbuf *mb, size_t clen)\n{\n\tstruct ident_entry *ie = NULL;\n\tuint64_t ident;\n\tchar key[256];\n\tint err = 0;\n\tident = 1 + rand_u64() & 0xf;  \n\tre_snprintf(key, sizeof(key), \"%llu\", ident);\n\tinfo(\"POST: new pairing id %llu\\n\", ident);\n\tie = mem_zalloc(sizeof(*ie), ie_destructor);\n\tie->id = ident;\n\tstr_dup(&ie->ident, key);\n\terr = dict_add(verifyd.idents, key, ie);\n\tif (err)\n\t\tgoto out;\n\tmem_deref(ie); \n\thttp_creply(conn, 200, \"OK\",\n\t\t    \"application/json\",\n\t\t    \"{\\\"pairid\\\":\\\"%llu\\\"}\", ident);\n out:\n\tif (err) {\n\t\twarning(\"internal error (%m)\\n\" ,err);\n\t}\n}", "target": 0}
{"code": "DECLAREContigPutFunc(put4bitbwtile)\n{\n    uint32** BWmap = img->BWmap;\n    (void) x; (void) y;\n    fromskew /= 2;\n    while (h-- > 0) {\n\tuint32* bw;\n\tUNROLL2(w, bw = BWmap[*pp++], *cp++ = *bw++);\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}", "target": 0}
{"code": "static int xfrm_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *attrs[XFRMA_MAX+1];\n\tconst struct xfrm_link *link;\n\tint type, err;\n\ttype = nlh->nlmsg_type;\n\tif (type > XFRM_MSG_MAX)\n\t\treturn -EINVAL;\n\ttype -= XFRM_MSG_BASE;\n\tlink = &xfrm_dispatch[type];\n\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\tif ((type == (XFRM_MSG_GETSA - XFRM_MSG_BASE) ||\n\t     type == (XFRM_MSG_GETPOLICY - XFRM_MSG_BASE)) &&\n\t    (nlh->nlmsg_flags & NLM_F_DUMP)) {\n\t\tif (link->dump == NULL)\n\t\t\treturn -EINVAL;\n\t\t{\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.start = link->start,\n\t\t\t\t.dump = link->dump,\n\t\t\t\t.done = link->done,\n\t\t\t};\n\t\t\treturn netlink_dump_start(net->xfrm.nlsk, skb, nlh, &c);\n\t\t}\n\t}\n\terr = nlmsg_parse(nlh, xfrm_msg_min[type], attrs, XFRMA_MAX,\n\t\t\t  xfrma_policy);\n\tif (err < 0)\n\t\treturn err;\n\tif (link->doit == NULL)\n\t\treturn -EINVAL;\n\treturn link->doit(skb, nlh, attrs);\n}", "target": 0}
{"code": "njs_promise_perform_race_handler(njs_vm_t *vm, njs_iterator_args_t *args,\n    njs_value_t *value, int64_t index)\n{\n    njs_int_t                    ret;\n    njs_value_t                  arguments[2], next;\n    njs_promise_capability_t     *capability;\n    njs_promise_iterator_args_t  *pargs;\n    if (!njs_is_valid(value)) {\n        value = njs_value_arg(&njs_value_undefined);\n    }\n    pargs = (njs_promise_iterator_args_t *) args;\n    ret = njs_function_call(vm, pargs->function, pargs->constructor, value,\n                            1, &next);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n    capability = pargs->capability;\n    arguments[0] = capability->resolve;\n    arguments[1] = capability->reject;\n    (void) njs_promise_invoke_then(vm, &next, arguments, 2);\n    return NJS_OK;\n}", "target": 0}
{"code": "gopherSendComplete(const Comm::ConnectionPointer &conn, char *, size_t size, Comm::Flag errflag, int xerrno, void *data)\n{\n    GopherStateData *gopherState = (GopherStateData *) data;\n    StoreEntry *entry = gopherState->entry;\n    debugs(10, 5, conn << \" size: \" << size << \" errflag: \" << errflag);\n    if (size > 0) {\n        fd_bytes(conn->fd, size, FD_WRITE);\n        statCounter.server.all.kbytes_out += size;\n        statCounter.server.other.kbytes_out += size;\n    }\n    if (!entry->isAccepting()) {\n        debugs(10, 3, \"terminating due to bad \" << *entry);\n        gopherState->serverConn->close();\n        return;\n    }\n    if (errflag) {\n        const auto err = new ErrorState(ERR_WRITE_ERROR, Http::scServiceUnavailable, gopherState->fwd->request, gopherState->fwd->al);\n        err->xerrno = xerrno;\n        err->port = gopherState->fwd->request->url.port();\n        err->url = xstrdup(entry->url());\n        gopherState->fwd->fail(err);\n        gopherState->serverConn->close();\n        return;\n    }\n    entry->buffer();\n    gopherMimeCreate(gopherState);\n    switch (gopherState->type_id) {\n    case GOPHER_DIRECTORY:\n        gopherState->conversion = GopherStateData::HTML_DIR;\n        gopherState->HTML_header_added = 0;\n        break;\n    case GOPHER_INDEX:\n        gopherState->conversion = GopherStateData::HTML_INDEX_RESULT;\n        gopherState->HTML_header_added = 0;\n        break;\n    case GOPHER_CSO:\n        gopherState->conversion = GopherStateData::HTML_CSO_RESULT;\n        gopherState->cso_recno = 0;\n        gopherState->HTML_header_added = 0;\n        break;\n    default:\n        gopherState->conversion = GopherStateData::NORMAL;\n        entry->flush();\n    }\n    GopherStateData::DelayAwareRead(gopherState);\n}", "target": 1}
{"code": "find_entry(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n\tback_txn *txn\n)\n{\n\treturn( find_entry_internal( pb, be, addr, 0, txn, 0 ) );\n}", "target": 1}
{"code": "static u32 psi_group_change(struct psi_group *group, int cpu,\n\t\t\t    unsigned int clear, unsigned int set)\n{\n\tstruct psi_group_cpu *groupc;\n\tunsigned int t, m;\n\tenum psi_states s;\n\tu32 state_mask = 0;\n\tgroupc = per_cpu_ptr(group->pcpu, cpu);\n\twrite_seqcount_begin(&groupc->seq);\n\trecord_times(groupc, cpu, false);\n\tfor (t = 0, m = clear; m; m &= ~(1 << t), t++) {\n\t\tif (!(m & (1 << t)))\n\t\t\tcontinue;\n\t\tif (groupc->tasks[t] == 0 && !psi_bug) {\n\t\t\tprintk_deferred(KERN_ERR \"psi: task underflow! cpu=%d t=%d tasks=[%u %u %u] clear=%x set=%x\\n\",\n\t\t\t\t\tcpu, t, groupc->tasks[0],\n\t\t\t\t\tgroupc->tasks[1], groupc->tasks[2],\n\t\t\t\t\tclear, set);\n\t\t\tpsi_bug = 1;\n\t\t}\n\t\tgroupc->tasks[t]--;\n\t}\n\tfor (t = 0; set; set &= ~(1 << t), t++)\n\t\tif (set & (1 << t))\n\t\t\tgroupc->tasks[t]++;\n\tfor (s = 0; s < NR_PSI_STATES; s++) {\n\t\tif (test_state(groupc->tasks, s))\n\t\t\tstate_mask |= (1 << s);\n\t}\n\tgroupc->state_mask = state_mask;\n\twrite_seqcount_end(&groupc->seq);\n\treturn state_mask;\n}", "target": 0}
{"code": "vips_foreign_load_gif_scan_image( VipsForeignLoadGif *gif ) \n{\n\tVipsObjectClass *class = VIPS_OBJECT_GET_CLASS( gif );\n\tGifFileType *file = gif->file;\n\tColorMapObject *map = file->Image.ColorMap ?\n\t\tfile->Image.ColorMap : file->SColorMap;\n\tGifByteType *extension;\n\tif( DGifGetImageDesc( gif->file ) == GIF_ERROR ) {\n\t\tvips_foreign_load_gif_error( gif ); \n\t\treturn( -1 );\n\t}\n\tif( file->Image.Left < 0 ||\n\t\tfile->Image.Width < 1 ||\n\t\tfile->Image.Width > 10000 ||\n\t\tfile->Image.Left + file->Image.Width > file->SWidth ||\n\t\tfile->Image.Top < 0 ||\n\t\tfile->Image.Height < 1 ||\n\t\tfile->Image.Height > 10000 ||\n\t\tfile->Image.Top + file->Image.Height > file->SHeight ) {\n\t\tvips_error( class->nickname, \"%s\", _( \"bad frame size\" ) ); \n\t\treturn( -1 ); \n\t}\n\tif( !gif->has_colour &&\n\t\tmap ) {\n\t\tint i;\n\t\tfor( i = 0; i < map->ColorCount; i++ ) \n\t\t\tif( map->Colors[i].Red != map->Colors[i].Green ||\n\t\t\t\tmap->Colors[i].Green != map->Colors[i].Blue ) {\n\t\t\t\tgif->has_colour = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\tdo {\n\t\tif( vips_foreign_load_gif_code_next( gif, &extension ) ) \n\t\t\treturn( -1 );\n\t} while( extension != NULL );\n\treturn( 0 );\n}", "target": 1}
{"code": "bool IsConstantFoldable(\n    const Node* n,\n    const std::unordered_map<string, std::vector<PartialTensorShape>>*\n        shape_map,\n    const std::function<bool(const Node*)>& consider,\n    int64_t max_constant_size_in_bytes,\n    std::unordered_map<const Node*, std::vector<Tensor>>*\n        shape_replacement_map) {\n  if (n->IsConstant()) {\n    return true;\n  }\n  if (MaybeReplaceShapeOp(n, shape_map, shape_replacement_map)) {\n    return true;\n  }\n  if (n->op_def().is_stateful()) {\n    return false;\n  }\n  if (consider && !consider(n)) {\n    return false;\n  }\n  if (shape_map != nullptr) {\n    auto shape_it = shape_map->find(n->name());\n    if (shape_it != shape_map->end()) {\n      for (int64_t i = 0; i < shape_it->second.size(); ++i) {\n        const auto& out_shape = shape_it->second[i];\n        if (out_shape.IsFullyDefined() &&\n            out_shape.num_elements() * DataTypeSize(n->output_type(i)) >\n                max_constant_size_in_bytes) {\n          return false;\n        }\n      }\n    }\n  }\n  if (n->IsControlFlow() || n->IsSend() || n->IsRecv()) {\n    return false;\n  }\n  if (n->IsGetSessionHandle() || n->IsGetSessionTensor() ||\n      n->IsDeleteSessionTensor()) {\n    return false;\n  }\n  if (n->IsSource()) {\n    return false;\n  }\n  if (n->IsSink()) {\n    return false;\n  }\n  if (n->IsFakeParam()) {\n    return false;\n  }\n  if (!KernelDefAvailable(DeviceType(DEVICE_CPU), n->def())) {\n    return false;\n  }\n  if (n->attrs().Find(kScopedAllocatorAttrName) != nullptr) {\n    VLOG(2) << \"Skip node [\" << n->DebugString()\n            << \"] for constant folding due to scoped allocator\";\n    return false;\n  }\n  return true;\n}", "target": 1}
{"code": "ikev1_cert_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t const struct isakmp_gen *ext, u_int item_len,\n\t\t const u_char *ep _U_, uint32_t phase _U_,\n\t\t uint32_t doi0 _U_,\n\t\t uint32_t proto0 _U_, int depth _U_)\n{\n\tconst struct ikev1_pl_cert *p;\n\tstruct ikev1_pl_cert cert;\n\tstatic const char *certstr[] = {\n\t\t\"none\",\t\"pkcs7\", \"pgp\", \"dns\",\n\t\t\"x509sign\", \"x509ke\", \"kerberos\", \"crl\",\n\t\t\"arl\", \"spki\", \"x509attr\",\n\t};\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_CERT)));\n\tp = (const struct ikev1_pl_cert *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&cert, ext, sizeof(cert));\n\tND_PRINT((ndo,\" len=%d\", item_len - 4));\n\tND_PRINT((ndo,\" type=%s\", STR_OR_ID((cert.encode), certstr)));\n\tif (2 < ndo->ndo_vflag && 4 < item_len) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), item_len - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_CERT)));\n\treturn NULL;\n}", "target": 0}
{"code": "static int snd_timer_user_tselect(struct file *file,\n\t\t\t\t  struct snd_timer_select __user *_tselect)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_select tselect;\n\tchar str[32];\n\tint err = 0;\n\ttu = file->private_data;\n\tif (tu->timeri) {\n\t\tsnd_timer_close(tu->timeri);\n\t\ttu->timeri = NULL;\n\t}\n\tif (copy_from_user(&tselect, _tselect, sizeof(tselect))) {\n\t\terr = -EFAULT;\n\t\tgoto __err;\n\t}\n\tsprintf(str, \"application %i\", current->pid);\n\tif (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)\n\t\ttselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;\n\terr = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid);\n\tif (err < 0)\n\t\tgoto __err;\n\ttu->qhead = tu->qtail = tu->qused = 0;\n\tkfree(tu->queue);\n\ttu->queue = NULL;\n\tkfree(tu->tqueue);\n\ttu->tqueue = NULL;\n\tif (tu->tread) {\n\t\ttu->tqueue = kmalloc(tu->queue_size * sizeof(struct snd_timer_tread),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (tu->tqueue == NULL)\n\t\t\terr = -ENOMEM;\n\t} else {\n\t\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (tu->queue == NULL)\n\t\t\terr = -ENOMEM;\n\t}\n      \tif (err < 0) {\n\t\tsnd_timer_close(tu->timeri);\n      \t\ttu->timeri = NULL;\n      \t} else {\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;\n\t\ttu->timeri->callback = tu->tread\n\t\t\t? snd_timer_user_tinterrupt : snd_timer_user_interrupt;\n\t\ttu->timeri->ccallback = snd_timer_user_ccallback;\n\t\ttu->timeri->callback_data = (void *)tu;\n\t\ttu->timeri->disconnect = snd_timer_user_disconnect;\n\t}\n      __err:\n\treturn err;\n}", "target": 0}
{"code": "njs_json_parse(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_int_t             ret;\n    njs_value_t           *text, value, lvalue;\n    const u_char          *p, *end;\n    njs_json_parse_t      *parse, json_parse;\n    const njs_value_t     *reviver;\n    njs_string_prop_t     string;\n    njs_json_parse_ctx_t  ctx;\n    parse = &json_parse;\n    text = njs_lvalue_arg(&lvalue, args, nargs, 1);\n    if (njs_slow_path(!njs_is_string(text))) {\n        ret = njs_value_to_string(vm, text, text);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n    }\n    (void) njs_string_prop(&string, text);\n    p = string.start;\n    end = p + string.size;\n    ctx.vm = vm;\n    ctx.pool = vm->mem_pool;\n    ctx.depth = NJS_JSON_MAX_DEPTH;\n    ctx.start = string.start;\n    ctx.end = end;\n    p = njs_json_skip_space(p, end);\n    if (njs_slow_path(p == end)) {\n        njs_json_parse_exception(&ctx, \"Unexpected end of input\", p);\n        return NJS_ERROR;\n    }\n    p = njs_json_parse_value(&ctx, &value, p);\n    if (njs_slow_path(p == NULL)) {\n        return NJS_ERROR;\n    }\n    p = njs_json_skip_space(p, end);\n    if (njs_slow_path(p != end)) {\n        njs_json_parse_exception(&ctx, \"Unexpected token\", p);\n        return NJS_ERROR;\n    }\n    reviver = njs_arg(args, nargs, 2);\n    if (njs_slow_path(njs_is_function(reviver) && njs_is_object(&value))) {\n        parse->function = njs_function(reviver);\n        parse->depth = 0;\n        return njs_json_parse_iterator(vm, parse, &value);\n    }\n    vm->retval = value;\n    return NJS_OK;\n}", "target": 1}
{"code": "static void ssl_calc_finished_tls(\n                ssl_context *ssl, unsigned char *buf, int from )\n{\n    int len = 12;\n    char *sender;\n    md5_context  md5;\n    sha1_context sha1;\n    unsigned char padbuf[36];\n    ssl_session *session = ssl->session_negotiate;\n    if( !session )\n        session = ssl->session;\n    SSL_DEBUG_MSG( 2, ( \"=> calc  finished tls\" ) );\n    memcpy( &md5 , &ssl->handshake->fin_md5 , sizeof(md5_context)  );\n    memcpy( &sha1, &ssl->handshake->fin_sha1, sizeof(sha1_context) );\n    SSL_DEBUG_BUF( 4, \"finished  md5 state\", (unsigned char *)\n                    md5.state, sizeof(  md5.state ) );\n    SSL_DEBUG_BUF( 4, \"finished sha1 state\", (unsigned char *)\n                   sha1.state, sizeof( sha1.state ) );\n    sender = ( from == SSL_IS_CLIENT )\n             ? (char *) \"client finished\"\n             : (char *) \"server finished\";\n    md5_finish(  &md5, padbuf );\n    sha1_finish( &sha1, padbuf + 16 );\n    ssl->handshake->tls_prf( session->master, 48, sender,\n                             padbuf, 36, buf, len );\n    SSL_DEBUG_BUF( 3, \"calc finished result\", buf, len );\n    memset(  &md5, 0, sizeof(  md5_context ) );\n    memset( &sha1, 0, sizeof( sha1_context ) );\n    memset(  padbuf, 0, sizeof(  padbuf ) );\n    SSL_DEBUG_MSG( 2, ( \"<= calc  finished\" ) );\n}", "target": 0}
{"code": "compat_cipher_proposal(struct ssh *ssh, char *cipher_prop)\n{\n\tif (!(ssh->compat & SSH_BUG_BIGENDIANAES))\n\t\treturn cipher_prop;\n\tdebug2_f(\"original cipher proposal: %s\", cipher_prop);\n\tif ((cipher_prop = match_filter_denylist(cipher_prop, \"aes*\")) == NULL)\n\t\tfatal(\"match_filter_denylist failed\");\n\tdebug2_f(\"compat cipher proposal: %s\", cipher_prop);\n\tif (*cipher_prop == '\\0')\n\t\tfatal(\"No supported ciphers found\");\n\treturn cipher_prop;\n}", "target": 1}
{"code": "compare_orports_(const void **_a, const void **_b)\n{\n  const tor_addr_port_t *a = *_a, *b = *_b;\n  int r;\n  if ((r = tor_addr_compare(&a->addr, &b->addr, CMP_EXACT)))\n    return r;\n  if ((r = (((int) b->port) - ((int) a->port))))\n    return r;\n  return 0;\n}", "target": 0}
{"code": "sudo_auth_end_session(void)\n{\n    sudo_auth *auth;\n    int status;\n    debug_decl(sudo_auth_end_session, SUDOERS_DEBUG_AUTH);\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (auth->end_session && !IS_DISABLED(auth)) {\n\t    status = (auth->end_session)(auth);\n\t    if (status == AUTH_ERROR) {\n\t\tdebug_return_int(-1);\n\t    }\n\t}\n    }\n    debug_return_int(1);\n}", "target": 1}
{"code": "opfunc_construct (vm_frame_ctx_t *frame_ctx_p) \n{\n  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p + 1;\n  uint8_t opcode = byte_code_p[-1];\n  unsigned int arguments_list_len;\n  if (opcode >= CBC_NEW0)\n  {\n    arguments_list_len = (unsigned int) (opcode - CBC_NEW0);\n  }\n  else\n  {\n    arguments_list_len = *byte_code_p++;\n  }\n  ecma_value_t *stack_top_p = frame_ctx_p->stack_top_p - arguments_list_len;\n  ecma_value_t constructor_value = stack_top_p[-1];\n  ecma_value_t completion_value;\n  const char *constructor_message_p = ecma_check_constructor (constructor_value);\n  if (constructor_message_p != ECMA_IS_VALID_CONSTRUCTOR)\n  {\n    completion_value = ecma_raise_type_error (constructor_message_p);\n  }\n  else\n  {\n    ecma_object_t *constructor_obj_p = ecma_get_object_from_value (constructor_value);\n    completion_value = ecma_op_function_construct (constructor_obj_p,\n                                                   constructor_obj_p,\n                                                   stack_top_p,\n                                                   arguments_list_len);\n  }\n  for (uint32_t i = 0; i < arguments_list_len; i++)\n  {\n    ecma_fast_free_value (stack_top_p[i]);\n  }\n  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))\n  {\n#if JERRY_DEBUGGER\n    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;\n#endif \n    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;\n  }\n  else\n  {\n    ecma_free_value (stack_top_p[-1]);\n    frame_ctx_p->byte_code_p = byte_code_p;\n    stack_top_p[-1] = completion_value;\n  }\n  frame_ctx_p->stack_top_p = stack_top_p;\n} ", "target": 0}
{"code": "TiledInputFile::rawTileData (int &dx, int &dy,\n\t\t\t     int &lx, int &ly,\n                             const char *&pixelData,\n\t\t\t     int &pixelDataSize)\n{\n    try\n    {\n        Lock lock (*_data->_streamData);\n        if (!isValidTile (dx, dy, lx, ly))\n            throw IEX_NAMESPACE::ArgExc (\"Tried to read a tile outside \"\n\t\t\t       \"the image file's data window.\");\n        TileBuffer *tileBuffer = _data->getTileBuffer (0);\n        int old_dx=dx;\n        int old_dy=dy;\n        int old_lx=lx;\n        int old_ly=ly;\n        if(isMultiPart(version()))\n        {\n            _data->_streamData->is->seekg(_data->tileOffsets(dx,dy,lx,ly));\n        }\n        readNextTileData (_data->_streamData, _data, dx, dy, lx, ly,\n\t\t\t  tileBuffer->buffer,\n                          pixelDataSize);\n        if(isMultiPart(version()))\n        {\n            if (old_dx!=dx || old_dy !=dy || old_lx!=lx || old_ly!=ly)\n            {\n                throw IEX_NAMESPACE::ArgExc (\"rawTileData read the wrong tile\");\n            }\n        }\n        else\n        {\n             if(!isValidTile (dx, dy, lx, ly) )\n             {\n                 throw IEX_NAMESPACE::IoExc (\"rawTileData read an invalid tile\");\n             }\n        }\n        pixelData = tileBuffer->buffer;\n    }\n    catch (IEX_NAMESPACE::BaseExc &e)\n    {\n        REPLACE_EXC (e, \"Error reading pixel data from image \"\n                     \"file \\\"\" << fileName() << \"\\\". \" << e.what());\n        throw;\n    }\n}", "target": 0}
{"code": "void * calloc(size_t n, size_t lb)\n{\n    if ((lb | n) > GC_SQRT_SIZE_MAX \n        && lb && n > GC_SIZE_MAX / lb)\n      return NULL;\n#   if defined(GC_LINUX_THREADS) \n        {\n          static GC_bool lib_bounds_set = FALSE;\n          ptr_t caller = (ptr_t)__builtin_return_address(0);\n          if (!EXPECT(lib_bounds_set, TRUE)) {\n            GC_init_lib_bounds();\n            lib_bounds_set = TRUE;\n          }\n          if (((word)caller >= (word)GC_libpthread_start\n               && (word)caller < (word)GC_libpthread_end)\n              || ((word)caller >= (word)GC_libld_start\n                  && (word)caller < (word)GC_libld_end))\n            return GC_malloc_uncollectable(n*lb);\n        }\n#   endif\n    return((void *)REDIRECT_MALLOC(n*lb));\n}", "target": 0}
{"code": "xfs_ioctl_setattr_xflags(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tstruct fileattr\t\t*fa)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tuint64_t\t\ti_flags2;\n\tif ((ip->i_df.if_nextents || ip->i_delayed_blks) &&\n\t    XFS_IS_REALTIME_INODE(ip) != (fa->fsx_xflags & FS_XFLAG_REALTIME))\n\t\treturn -EINVAL;\n\tif (fa->fsx_xflags & FS_XFLAG_REALTIME) {\n\t\tif (mp->m_sb.sb_rblocks == 0 || mp->m_sb.sb_rextsize == 0 ||\n\t\t    (ip->i_extsize % mp->m_sb.sb_rextsize))\n\t\t\treturn -EINVAL;\n\t}\n\tif ((fa->fsx_xflags & FS_XFLAG_REALTIME) && xfs_is_reflink_inode(ip))\n\t\tip->i_diflags2 &= ~XFS_DIFLAG2_REFLINK;\n\tif ((fa->fsx_xflags & FS_XFLAG_DAX) && xfs_is_reflink_inode(ip))\n\t\treturn -EINVAL;\n\ti_flags2 = xfs_flags2diflags2(ip, fa->fsx_xflags);\n\tif (i_flags2 && !xfs_has_v3inodes(mp))\n\t\treturn -EINVAL;\n\tip->i_diflags = xfs_flags2diflags(ip, fa->fsx_xflags);\n\tip->i_diflags2 = i_flags2;\n\txfs_diflags_to_iflags(ip, false);\n\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\tXFS_STATS_INC(mp, xs_ig_attrchg);\n\treturn 0;\n}", "target": 0}
{"code": "void exit_io_context(void)\n{\n\tstruct io_context *ioc;\n\ttask_lock(current);\n\tioc = current->io_context;\n\tcurrent->io_context = NULL;\n\ttask_unlock(current);\n\tif (atomic_dec_and_test(&ioc->nr_tasks)) {\n\t\tif (ioc->aic && ioc->aic->exit)\n\t\t\tioc->aic->exit(ioc->aic);\n\t\tcfq_exit(ioc);\n\t\tput_io_context(ioc);\n\t}\n}", "target": 1}
{"code": "int btrfs_create_uuid_tree(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct btrfs_root *uuid_root;\n\tstruct task_struct *task;\n\tint ret;\n\ttrans = btrfs_start_transaction(tree_root, 2);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\tuuid_root = btrfs_create_tree(trans, fs_info,\n\t\t\t\t      BTRFS_UUID_TREE_OBJECTID);\n\tif (IS_ERR(uuid_root)) {\n\t\tret = PTR_ERR(uuid_root);\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tbtrfs_end_transaction(trans);\n\t\treturn ret;\n\t}\n\tfs_info->uuid_root = uuid_root;\n\tret = btrfs_commit_transaction(trans);\n\tif (ret)\n\t\treturn ret;\n\tdown(&fs_info->uuid_tree_rescan_sem);\n\ttask = kthread_run(btrfs_uuid_scan_kthread, fs_info, \"btrfs-uuid\");\n\tif (IS_ERR(task)) {\n\t\tbtrfs_warn(fs_info, \"failed to start uuid_scan task\");\n\t\tup(&fs_info->uuid_tree_rescan_sem);\n\t\treturn PTR_ERR(task);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int cypress_generic_port_probe(struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct cypress_private *priv;\n\tif (!port->interrupt_out_urb || !port->interrupt_in_urb) {\n\t\tdev_err(&port->dev, \"required endpoint is missing\\n\");\n\t\treturn -ENODEV;\n\t}\n\tpriv = kzalloc(sizeof(struct cypress_private), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tpriv->comm_is_ok = !0;\n\tspin_lock_init(&priv->lock);\n\tif (kfifo_alloc(&priv->write_fifo, CYPRESS_BUF_SIZE, GFP_KERNEL)) {\n\t\tkfree(priv);\n\t\treturn -ENOMEM;\n\t}\n\tif (!is_frwd(serial->dev))\n\t\tusb_reset_configuration(serial->dev);\n\tpriv->cmd_ctrl = 0;\n\tpriv->line_control = 0;\n\tpriv->termios_initialized = 0;\n\tpriv->rx_flags = 0;\n\tif (port->interrupt_out_size > 9)\n\t\tpriv->pkt_fmt = packet_format_1;\n\telse\n\t\tpriv->pkt_fmt = packet_format_2;\n\tif (interval > 0) {\n\t\tpriv->write_urb_interval = interval;\n\t\tpriv->read_urb_interval = interval;\n\t\tdev_dbg(&port->dev, \"%s - read & write intervals forced to %d\\n\",\n\t\t\t__func__, interval);\n\t} else {\n\t\tpriv->write_urb_interval = port->interrupt_out_urb->interval;\n\t\tpriv->read_urb_interval = port->interrupt_in_urb->interval;\n\t\tdev_dbg(&port->dev, \"%s - intervals: read=%d write=%d\\n\",\n\t\t\t__func__, priv->read_urb_interval,\n\t\t\tpriv->write_urb_interval);\n\t}\n\tusb_set_serial_port_data(port, priv);\n\tport->port.drain_delay = 256;\n\treturn 0;\n}", "target": 0}
{"code": "static int ax25_recvmsg(struct kiocb *iocb, struct socket *sock,\n\tstruct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint copied;\n\tint err = 0;\n\tlock_sock(sk);\n\tif (sk->sk_type == SOCK_SEQPACKET && sk->sk_state != TCP_ESTABLISHED) {\n\t\terr =  -ENOTCONN;\n\t\tgoto out;\n\t}\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tif (skb == NULL)\n\t\tgoto out;\n\tif (!ax25_sk(sk)->pidincl)\n\t\tskb_pull(skb, 1);\t\t\n\tskb_reset_transport_header(skb);\n\tcopied = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (msg->msg_namelen != 0) {\n\t\tstruct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;\n\t\tax25_digi digi;\n\t\tax25_address src;\n\t\tconst unsigned char *mac = skb_mac_header(skb);\n\t\tmemset(sax, 0, sizeof(struct full_sockaddr_ax25));\n\t\tax25_addr_parse(mac + 1, skb->data - mac - 1, &src, NULL,\n\t\t\t\t&digi, NULL, NULL);\n\t\tsax->sax25_family = AF_AX25;\n\t\tsax->sax25_ndigis = digi.ndigi;\n\t\tsax->sax25_call   = src;\n\t\tif (sax->sax25_ndigis != 0) {\n\t\t\tint ct;\n\t\t\tstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)sax;\n\t\t\tfor (ct = 0; ct < digi.ndigi; ct++)\n\t\t\t\tfsa->fsa_digipeater[ct] = digi.calls[ct];\n\t\t}\n\t\tmsg->msg_namelen = sizeof(struct full_sockaddr_ax25);\n\t}\n\tskb_free_datagram(sk, skb);\n\terr = copied;\nout:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "  Status GetFirstDimensionSize(OpKernelContext* context, INDEX_TYPE* result) {\n    const Tensor first_partition_tensor =\n        context->input(kFirstPartitionInputIndex);\n    if (row_partition_types_.empty()) {\n      return errors::InvalidArgument(\"No row_partition_types given.\");\n    }\n    const RowPartitionType first_partition_type = row_partition_types_[0];\n    switch (first_partition_type) {\n      case RowPartitionType::FIRST_DIM_SIZE:\n        *result = first_partition_tensor.scalar<INDEX_TYPE>()();\n        return Status::OK();\n      case RowPartitionType::VALUE_ROWIDS:\n        return errors::InvalidArgument(\n            \"Cannot handle VALUE_ROWIDS in first dimension.\");\n      case RowPartitionType::ROW_SPLITS:\n        *result = first_partition_tensor.shape().dim_size(0) - 1;\n        return Status::OK();\n      default:\n        return errors::InvalidArgument(\n            \"Cannot handle type \",\n            RowPartitionTypeToString(first_partition_type));\n    }\n  }", "target": 0}
{"code": "static long aio_read_events_ring(struct kioctx *ctx,\n\t\t\t\t struct io_event __user *event, long nr)\n{\n\tstruct aio_ring *ring;\n\tunsigned head, tail, pos;\n\tlong ret = 0;\n\tint copy_ret;\n\tmutex_lock(&ctx->ring_lock);\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\thead = ring->head;\n\ttail = ring->tail;\n\tkunmap_atomic(ring);\n\tpr_debug(\"h%u t%u m%u\\n\", head, tail, ctx->nr_events);\n\tif (head == tail)\n\t\tgoto out;\n\thead %= ctx->nr_events;\n\ttail %= ctx->nr_events;\n\twhile (ret < nr) {\n\t\tlong avail;\n\t\tstruct io_event *ev;\n\t\tstruct page *page;\n\t\tavail = (head <= tail ?  tail : ctx->nr_events) - head;\n\t\tif (head == tail)\n\t\t\tbreak;\n\t\tavail = min(avail, nr - ret);\n\t\tavail = min_t(long, avail, AIO_EVENTS_PER_PAGE -\n\t\t\t    ((head + AIO_EVENTS_OFFSET) % AIO_EVENTS_PER_PAGE));\n\t\tpos = head + AIO_EVENTS_OFFSET;\n\t\tpage = ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE];\n\t\tpos %= AIO_EVENTS_PER_PAGE;\n\t\tev = kmap(page);\n\t\tcopy_ret = copy_to_user(event + ret, ev + pos,\n\t\t\t\t\tsizeof(*ev) * avail);\n\t\tkunmap(page);\n\t\tif (unlikely(copy_ret)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tret += avail;\n\t\thead += avail;\n\t\thead %= ctx->nr_events;\n\t}\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\tring->head = head;\n\tkunmap_atomic(ring);\n\tflush_dcache_page(ctx->ring_pages[0]);\n\tpr_debug(\"%li  h%u t%u\\n\", ret, head, tail);\nout:\n\tmutex_unlock(&ctx->ring_lock);\n\treturn ret;\n}", "target": 0}
{"code": "static char *clean_path(char *path)\n{\n\tchar *ch;\n\tchar *ch2;\n\tchar *str;\n\tstr = xmalloc(strlen(path) + 1);\n\tch = path;\n\tch2 = str;\n\twhile (true) {\n\t\t*ch2 = *ch;\n\t\tch++;\n\t\tch2++;\n\t\tif (!*(ch-1))\n\t\t\tbreak;\n\t\twhile (*(ch - 1) == '/' && *ch == '/')\n\t\t\tch++;\n\t}\n\twhile ((ch = strrchr(str, '/'))) {\n\t\tif (ch == str)\n\t\t\tbreak;\n\t\tif (!*(ch+1))\n\t\t\t*ch = 0;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn str;\n}", "target": 0}
{"code": "static void __exit exit_ext2_fs(void)\n{\n\tunregister_filesystem(&ext2_fs_type);\n\tdestroy_inodecache();\n\texit_ext2_xattr();\n}", "target": 1}
{"code": "static int xar_get_numeric_from_xml_element(xmlTextReaderPtr reader, long * value)\n{\n    const xmlChar * numstr;\n    if (xmlTextReaderRead(reader) == 1 && xmlTextReaderNodeType(reader) == XML_READER_TYPE_TEXT) {\n        numstr = xmlTextReaderConstValue(reader);\n        if (numstr) {\n            *value = atol((const char *)numstr);\n            if (*value < 0) {\n                cli_dbgmsg(\"cli_scanxar: XML element value %li\\n\", *value);\n                return CL_EFORMAT;\n            }\n            return CL_SUCCESS;\n        }\n    }\n    cli_dbgmsg(\"cli_scanxar: No text for XML element\\n\");\n    return CL_EFORMAT;\n}", "target": 1}
{"code": "void SecurityManager::cancel_init()\n{\n    SecurityException exception;\n    if (local_participant_crypto_handle_)\n    {\n        crypto_plugin_->cryptokeyfactory()->unregister_participant(local_participant_crypto_handle_, exception);\n    }\n    if (crypto_plugin_ != nullptr)\n    {\n        delete crypto_plugin_;\n        crypto_plugin_ = nullptr;\n    }\n    if (access_plugin_ != nullptr)\n    {\n        delete access_plugin_;\n        access_plugin_ = nullptr;\n    }\n    delete authentication_plugin_;\n    authentication_plugin_ = nullptr;\n    disable_security_manager();\n}", "target": 1}
{"code": "void http_buffer_heavy_realign(struct buffer *buf, struct http_msg *msg)\n{\n\tchar *end = buf->data + buf->size;\n\tint off = buf->data + buf->size - buf->w;\n\tif (buf->l) {\n\t\tint block1 = buf->l;\n\t\tint block2 = 0;\n\t\tif (buf->r <= buf->w) {\n\t\t\tblock1 = buf->data + buf->size - buf->w;\n\t\t\tblock2 = buf->r - buf->data;\n\t\t}\n\t\tif (block2)\n\t\t\tmemcpy(swap_buffer, buf->data, block2);\n\t\tmemmove(buf->data, buf->w, block1);\n\t\tif (block2)\n\t\t\tmemcpy(buf->data + block1, swap_buffer, block2);\n\t}\n\tbuf->w    = buf->data;\n\tbuf->lr  += off; if (buf->lr  >= end) buf->lr  -= buf->size;\n\tbuf->r   += off; if (buf->r   >= end) buf->r   -= buf->size;\n\tmsg->sol += off; if (msg->sol >= end) msg->sol -= buf->size;\n\tmsg->eol += off; if (msg->eol >= end) msg->eol -= buf->size;\n\tmsg->som  = 0;\n\tmsg->eoh += off; if (msg->eoh >= buf->size) msg->eoh -= buf->size;\n\tmsg->sov += off; if (msg->sov >= buf->size) msg->sov -= buf->size;\n\tif (msg->err_pos >= 0) {\n\t\tmsg->err_pos += off;\n\t\tif (msg->err_pos >= buf->size)\n\t\t\tmsg->err_pos -= buf->size;\n\t}\n\tbuf->flags &= ~BF_FULL;\n\tif (buf->l >= buffer_max_len(buf))\n\t\tbuf->flags |= BF_FULL;\n}", "target": 0}
{"code": "static int em_ret(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.type = OP_REG;\n\tctxt->dst.addr.reg = &ctxt->_eip;\n\tctxt->dst.bytes = ctxt->op_bytes;\n\treturn em_pop(ctxt);\n}", "target": 1}
{"code": "static int snd_timer_user_release(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\tif (file->private_data) {\n\t\ttu = file->private_data;\n\t\tfile->private_data = NULL;\n\t\tmutex_lock(&tu->ioctl_lock);\n\t\tif (tu->timeri)\n\t\t\tsnd_timer_close(tu->timeri);\n\t\tmutex_unlock(&tu->ioctl_lock);\n\t\tkfree(tu->queue);\n\t\tkfree(tu->tqueue);\n\t\tkfree(tu);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "yang_read_string(struct ly_ctx *ctx, const char *input, char *output, int size, int offset, int indent)\n{\n    int i = 0, out_index = offset, space = 0;\n    while (i < size) {\n        switch (input[i]) {\n        case '\\n':\n            out_index -= space;\n            output[out_index] = '\\n';\n            space = 0;\n            i = read_indent(input, indent, size, i + 1, &out_index, output);\n            break;\n        case ' ':\n        case '\\t':\n            output[out_index] = input[i];\n            ++space;\n            break;\n        case '\\\\':\n            if (input[i + 1] == 'n') {\n                out_index -= space;\n                output[out_index] = '\\n';\n                space = 0;\n                i = read_indent(input, indent, size, i + 2, &out_index, output);\n            } else if (input[i + 1] == 't') {\n                output[out_index] = '\\t';\n                ++i;\n                ++space;\n            } else if (input[i + 1] == '\\\\') {\n                output[out_index] = '\\\\';\n                ++i;\n            } else if ((i + 1) != size && input[i + 1] == '\"') {\n                output[out_index] = '\"';\n                ++i;\n            } else {\n                LOGVAL(ctx, LYE_XML_INCHAR, LY_VLOG_NONE, NULL, input + i);\n                return NULL;\n            }\n            break;\n        default:\n            output[out_index] = input[i];\n            space = 0;\n            break;\n        }\n        ++i;\n        ++out_index;\n    }\n    output[out_index] = '\\0';\n    if (size != out_index) {\n        output = realloc(output, out_index + 1);\n        LY_CHECK_ERR_RETURN(!output, LOGMEM(ctx), NULL);\n    }\n    return output;\n}", "target": 0}
{"code": "void AOClient::pktEditEvidence(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (!checkEvidenceAccess(area))\n        return;\n    bool is_int = false;\n    int idx = argv[0].toInt(&is_int);\n    AreaData::Evidence evi = {argv[1], argv[2], argv[3]};\n    if (is_int && idx <= area->evidence().size() && idx >= 0) {\n        area->replaceEvidence(idx, evi);\n    }\n    sendEvidenceList(area);\n}", "target": 1}
{"code": "static void write_palette(int idx, uint32_t color, void *opaque)\n{\n    struct palette_cb_priv *priv = opaque;\n    VncState *vs = priv->vs;\n    uint32_t bytes = vs->client_pf.bytes_per_pixel;\n    if (bytes == 4) {\n        ((uint32_t*)priv->header)[idx] = color;\n    } else {\n        ((uint16_t*)priv->header)[idx] = color;\n    }\n}", "target": 0}
{"code": "QTN2QT(QTNode *in)\n{\n\tTSQuery\t\tout;\n\tint\t\t\tlen;\n\tint\t\t\tsumlen = 0,\n\t\t\t\tnnode = 0;\n\tQTN2QTState state;\n\tcntsize(in, &sumlen, &nnode);\n\tif (TSQUERY_TOO_BIG(nnode, sumlen))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"tsquery is too large\")));\n\tlen = COMPUTESIZE(nnode, sumlen);\n\tout = (TSQuery) palloc0(len);\n\tSET_VARSIZE(out, len);\n\tout->size = nnode;\n\tstate.curitem = GETQUERY(out);\n\tstate.operand = state.curoperand = GETOPERAND(out);\n\tfillQT(&state, in);\n\treturn out;\n}", "target": 0}
{"code": "MagickExport MagickBooleanType FileToImage(Image *image,const char *filename,\n  ExceptionInfo *exception)\n{\n  int\n    file;\n  MagickBooleanType\n    status;\n  size_t\n    length,\n    quantum;\n  ssize_t\n    count;\n  struct stat\n    file_stats;\n  unsigned char\n    *blob;\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(filename != (const char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",filename);\n  status=IsRightsAuthorized(PathPolicyDomain,WritePolicyRights,filename);\n  if (status == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",filename);\n      return(MagickFalse);\n    }\n  file=fileno(stdin);\n  if (LocaleCompare(filename,\"-\") != 0)\n    file=open_utf8(filename,O_RDONLY | O_BINARY,0);\n  if (file == -1)\n    {\n      ThrowFileException(exception,BlobError,\"UnableToOpenBlob\",filename);\n      return(MagickFalse);\n    }\n  quantum=(size_t) MagickMaxBufferExtent;\n  if ((fstat(file,&file_stats) == 0) && (file_stats.st_size > 0))\n    quantum=(size_t) MagickMin(file_stats.st_size,MagickMaxBufferExtent);\n  blob=(unsigned char *) AcquireQuantumMemory(quantum,sizeof(*blob));\n  if (blob == (unsigned char *) NULL)\n    {\n      file=close(file);\n      ThrowFileException(exception,ResourceLimitError,\"MemoryAllocationFailed\",\n        filename);\n      return(MagickFalse);\n    }\n  for ( ; ; )\n  {\n    count=read(file,blob,quantum);\n    if (count <= 0)\n      {\n        count=0;\n        if (errno != EINTR)\n          break;\n      }\n    length=(size_t) count;\n    count=WriteBlobStream(image,length,blob);\n    if (count != (ssize_t) length)\n      {\n        ThrowFileException(exception,BlobError,\"UnableToWriteBlob\",filename);\n        break;\n      }\n  }\n  file=close(file);\n  if (file == -1)\n    ThrowFileException(exception,BlobError,\"UnableToWriteBlob\",filename);\n  blob=(unsigned char *) RelinquishMagickMemory(blob);\n  return(MagickTrue);\n}", "target": 0}
{"code": "nfs4_proc_layoutget(struct nfs4_layoutget *lgp, gfp_t gfp_flags)\n{\n\tstruct nfs_server *server = NFS_SERVER(lgp->args.inode);\n\tsize_t max_pages = max_response_pages(server);\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LAYOUTGET],\n\t\t.rpc_argp = &lgp->args,\n\t\t.rpc_resp = &lgp->res,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_layoutget_call_ops,\n\t\t.callback_data = lgp,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tstruct pnfs_layout_segment *lseg = NULL;\n\tint status = 0;\n\tdprintk(\"--> %s\\n\", __func__);\n\tlgp->args.layout.pages = nfs4_alloc_pages(max_pages, gfp_flags);\n\tif (!lgp->args.layout.pages) {\n\t\tnfs4_layoutget_release(lgp);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tlgp->args.layout.pglen = max_pages * PAGE_SIZE;\n\tlgp->res.layoutp = &lgp->args.layout;\n\tlgp->res.seq_res.sr_slot = NULL;\n\tnfs41_init_sequence(&lgp->args.seq_args, &lgp->res.seq_res, 0);\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn ERR_CAST(task);\n\tstatus = nfs4_wait_for_completion_rpc_task(task);\n\tif (status == 0)\n\t\tstatus = task->tk_status;\n\tif (status == 0)\n\t\tlseg = pnfs_layout_process(lgp);\n\trpc_put_task(task);\n\tdprintk(\"<-- %s status=%d\\n\", __func__, status);\n\tif (status)\n\t\treturn ERR_PTR(status);\n\treturn lseg;\n}", "target": 0}
{"code": "void HeaderMapImpl::removeInline(HeaderEntryImpl** ptr_to_entry) {\n  if (!*ptr_to_entry) {\n    return;\n  }\n  HeaderEntryImpl* entry = *ptr_to_entry;\n  const uint64_t size_to_subtract = entry->entry_->key().size() + entry->entry_->value().size();\n  subtractSize(size_to_subtract);\n  *ptr_to_entry = nullptr;\n  headers_.erase(entry->entry_);\n}", "target": 0}
{"code": "static int kvm_ioctl_create_device(struct kvm *kvm,\n\t\t\t\t   struct kvm_create_device *cd)\n{\n\tstruct kvm_device_ops *ops = NULL;\n\tstruct kvm_device *dev;\n\tbool test = cd->flags & KVM_CREATE_DEVICE_TEST;\n\tint ret;\n\tif (cd->type >= ARRAY_SIZE(kvm_device_ops_table))\n\t\treturn -ENODEV;\n\tops = kvm_device_ops_table[cd->type];\n\tif (ops == NULL)\n\t\treturn -ENODEV;\n\tif (test)\n\t\treturn 0;\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tdev->ops = ops;\n\tdev->kvm = kvm;\n\tmutex_lock(&kvm->lock);\n\tret = ops->create(dev, cd->type);\n\tif (ret < 0) {\n\t\tmutex_unlock(&kvm->lock);\n\t\tkfree(dev);\n\t\treturn ret;\n\t}\n\tlist_add(&dev->vm_node, &kvm->devices);\n\tmutex_unlock(&kvm->lock);\n\tif (ops->init)\n\t\tops->init(dev);\n\tkvm_get_kvm(kvm);\n\tret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);\n\tif (ret < 0) {\n\t\tkvm_put_kvm(kvm);\n\t\tmutex_lock(&kvm->lock);\n\t\tlist_del(&dev->vm_node);\n\t\tmutex_unlock(&kvm->lock);\n\t\tops->destroy(dev);\n\t\treturn ret;\n\t}\n\tcd->fd = ret;\n\treturn 0;\n}", "target": 0}
{"code": "rdr_notification_ctx_cleanup(struct rdr_notification_ctx *ctx)\n{\n\tif (ctx->deltas.array != NULL)\n\t\tdeltas_parsed_cleanup(&ctx->deltas, __delta_head_destroy);\n}", "target": 1}
{"code": "int HttpFileImpl::save(const std::string &path) const\n{\n    assert(!path.empty());\n    if (fileName_.empty())\n        return -1;\n    filesystem::path fsPath(utils::toNativePath(path));\n    if (!fsPath.is_absolute() &&\n        (!fsPath.has_parent_path() ||\n         (fsPath.begin()->string() != \".\" && fsPath.begin()->string() != \"..\")))\n    {\n        filesystem::path fsUploadPath(utils::toNativePath(\n            HttpAppFrameworkImpl::instance().getUploadPath()));\n        fsPath = fsUploadPath / fsPath;\n    }\n    filesystem::path fsFileName(utils::toNativePath(fileName_));\n    if (!filesystem::exists(fsPath))\n    {\n        LOG_TRACE << \"create path:\" << fsPath;\n        drogon::error_code err;\n        filesystem::create_directories(fsPath, err);\n        if (err)\n        {\n            LOG_SYSERR;\n            return -1;\n        }\n    }\n    return saveTo(fsPath / fsFileName);\n}", "target": 1}
{"code": "PHYSICALPATH_FUNC(mod_alias_physical_handler) {\n\tplugin_data *p = p_d;\n\tint uri_len, basedir_len;\n\tchar *uri_ptr;\n\tsize_t k;\n\tif (buffer_is_empty(con->physical.path)) return HANDLER_GO_ON;\n\tmod_alias_patch_connection(srv, con, p);\n\tbasedir_len = buffer_string_length(con->physical.basedir);\n\tif ('/' == con->physical.basedir->ptr[basedir_len-1]) --basedir_len;\n\turi_len = buffer_string_length(con->physical.path) - basedir_len;\n\turi_ptr = con->physical.path->ptr + basedir_len;\n\tfor (k = 0; k < p->conf.alias->used; k++) {\n\t\tdata_string *ds = (data_string *)p->conf.alias->data[k];\n\t\tint alias_len = buffer_string_length(ds->key);\n\t\tif (alias_len > uri_len) continue;\n\t\tif (buffer_is_empty(ds->key)) continue;\n\t\tif (0 == (con->conf.force_lowercase_filenames ?\n\t\t\t\t\tstrncasecmp(uri_ptr, ds->key->ptr, alias_len) :\n\t\t\t\t\tstrncmp(uri_ptr, ds->key->ptr, alias_len))) {\n\t\t\tif (uri_ptr[alias_len] == '.') {\n\t\t\t\tchar *s = uri_ptr + alias_len + 1;\n\t\t\t\tif (*s == '.') ++s;\n\t\t\t\tif (*s == '/' || *s == '\\0') {\n\t\t\t\t\tsize_t vlen = buffer_string_length(ds->value);\n\t\t\t\t\tif (0 != alias_len && ds->key->ptr[alias_len-1] != '/'\n\t\t\t\t\t    && 0 != vlen && ds->value->ptr[vlen-1] == '/') {\n\t\t\t\t\t\tcon->http_status = 403;\n\t\t\t\t\t\treturn HANDLER_FINISHED;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuffer_copy_buffer(con->physical.basedir, ds->value);\n\t\t\tbuffer_copy_buffer(srv->tmp_buf, ds->value);\n\t\t\tbuffer_append_string(srv->tmp_buf, uri_ptr + alias_len);\n\t\t\tbuffer_copy_buffer(con->physical.path, srv->tmp_buf);\n\t\t\treturn HANDLER_GO_ON;\n\t\t}\n\t}\n\treturn HANDLER_GO_ON;\n}", "target": 0}
{"code": "STACK_OF(PKCS7) *PKCS12_unpack_authsafes(const PKCS12 *p12)\n{\n    STACK_OF(PKCS7) *p7s;\n    PKCS7_CTX *p7ctx;\n    PKCS7 *p7;\n    int i;\n    if (!PKCS7_type_is_data(p12->authsafes)) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_CONTENT_TYPE_NOT_DATA);\n        return NULL;\n    }\n    if (p12->authsafes->d.data == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_DECODE_ERROR);\n        return NULL;\n    }\n    p7ctx = &p12->authsafes->ctx;\n    p7s = ASN1_item_unpack_ex(p12->authsafes->d.data,\n                              ASN1_ITEM_rptr(PKCS12_AUTHSAFES),\n                              ossl_pkcs7_ctx_get0_libctx(p7ctx),\n                              ossl_pkcs7_ctx_get0_propq(p7ctx));\n    if (p7s != NULL) {\n        for (i = 0; i < sk_PKCS7_num(p7s); i++) {\n            p7 = sk_PKCS7_value(p7s, i);\n            if (!ossl_pkcs7_ctx_propagate(p12->authsafes, p7))\n                goto err;\n        }\n    }\n    return p7s;\nerr:\n    sk_PKCS7_free(p7s);\n    return NULL;\n}", "target": 0}
{"code": "Status UncompressElement(const CompressedElement& compressed,\n                         std::vector<Tensor>* out) {\n  int num_components = compressed.component_metadata_size();\n  out->clear();\n  out->reserve(num_components);\n  std::vector<struct iovec> iov(num_components);\n  std::vector<tstring> tensor_proto_strs;\n  tensor_proto_strs.reserve(num_components);\n  int64 total_size = 0;\n  for (int i = 0; i < num_components; ++i) {\n    const CompressedComponentMetadata& metadata =\n        compressed.component_metadata(i);\n    if (DataTypeCanUseMemcpy(metadata.dtype())) {\n      out->emplace_back(metadata.dtype(), metadata.tensor_shape());\n      TensorBuffer* buffer = DMAHelper::buffer(&out->back());\n      iov[i].iov_base = buffer->data();\n      iov[i].iov_len = buffer->size();\n    } else {\n      out->emplace_back();\n      tensor_proto_strs.emplace_back();\n      tstring& tensor_proto_str = tensor_proto_strs.back();\n      tensor_proto_str.resize_uninitialized(metadata.tensor_size_bytes());\n      iov[i].iov_base = tensor_proto_str.mdata();\n      iov[i].iov_len = tensor_proto_str.size();\n    }\n    total_size += iov[i].iov_len;\n  }\n  const std::string& compressed_data = compressed.data();\n  size_t uncompressed_size;\n  if (!port::Snappy_GetUncompressedLength(\n          compressed_data.data(), compressed_data.size(), &uncompressed_size)) {\n    return errors::Internal(\n        \"Could not get snappy uncompressed length. Compressed data size: \",\n        compressed_data.size());\n  }\n  if (uncompressed_size != static_cast<size_t>(total_size)) {\n    return errors::Internal(\n        \"Uncompressed size mismatch. Snappy expects \", uncompressed_size,\n        \" whereas the tensor metadata suggests \", total_size);\n  }\n  if (!port::Snappy_UncompressToIOVec(compressed_data.data(),\n                                      compressed_data.size(), iov.data(),\n                                      num_components)) {\n    return errors::Internal(\"Failed to perform snappy decompression.\");\n  }\n  int tensor_proto_strs_index = 0;\n  for (int i = 0; i < num_components; ++i) {\n    if (DataTypeCanUseMemcpy(compressed.component_metadata(i).dtype())) {\n      continue;\n    }\n    TensorProto tp;\n    if (!tp.ParseFromString(tensor_proto_strs[tensor_proto_strs_index++])) {\n      return errors::Internal(\"Could not parse TensorProto\");\n    }\n    if (!out->at(i).FromProto(tp)) {\n      return errors::Internal(\"Could not parse Tensor\");\n    }\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "file_check_mem(struct magic_set *ms, unsigned int level)\n{\n\tsize_t len;\n\tif (level >= ms->c.len) {\n\t\tlen = (ms->c.len += 20) * sizeof(*ms->c.li);\n\t\tms->c.li = CAST(struct level_info *, (ms->c.li == NULL) ?\n\t\t    malloc(len) :\n\t\t    realloc(ms->c.li, len));\n\t\tif (ms->c.li == NULL) {\n\t\t\tfile_oomem(ms, len);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tms->c.li[level].got_match = 0;\n#ifdef ENABLE_CONDITIONALS\n\tms->c.li[level].last_match = 0;\n\tms->c.li[level].last_cond = COND_NONE;\n#endif \n\treturn 0;\n}", "target": 1}
{"code": "TIFFNumberOfStrips(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 nstrips;\n    if( td->td_nstrips )\n        return td->td_nstrips;\n\tnstrips = (td->td_rowsperstrip == (uint32) -1 ? 1 :\n\t     TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip));\n\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n\t\tnstrips = _TIFFMultiply32(tif, nstrips, (uint32)td->td_samplesperpixel,\n\t\t    \"TIFFNumberOfStrips\");\n\treturn (nstrips);\n}", "target": 1}
{"code": "bool CModules::GetModInfo(CModInfo& ModInfo, const CString& sModule,\n                          CString& sRetMsg) {\n    if (!ValidateModuleName(sModule, sRetMsg)) {\n        return false;\n    }\n    CString sModPath, sTmp;\n    bool bSuccess;\n    bool bHandled = false;\n    GLOBALMODULECALL(OnGetModInfo(ModInfo, sModule, bSuccess, sRetMsg),\n                     &bHandled);\n    if (bHandled) return bSuccess;\n    if (!FindModPath(sModule, sModPath, sTmp)) {\n        sRetMsg = t_f(\"Unable to find module {1}.\")(sModule);\n        return false;\n    }\n    return GetModPathInfo(ModInfo, sModule, sModPath, sRetMsg);\n}", "target": 0}
{"code": "fetch_var_cell_from_buf(buf_t *buf, var_cell_t **out, int linkproto)\n{\n  char hdr[VAR_CELL_MAX_HEADER_SIZE];\n  var_cell_t *result;\n  uint8_t command;\n  uint16_t length;\n  const int wide_circ_ids = linkproto >= MIN_LINK_PROTO_FOR_WIDE_CIRC_IDS;\n  const int circ_id_len = get_circ_id_size(wide_circ_ids);\n  const unsigned header_len = get_var_cell_header_size(wide_circ_ids);\n  check();\n  *out = NULL;\n  if (buf->datalen < header_len)\n    return 0;\n  peek_from_buf(hdr, header_len, buf);\n  command = get_uint8(hdr + circ_id_len);\n  if (!(cell_command_is_var_length(command, linkproto)))\n    return 0;\n  length = ntohs(get_uint16(hdr + circ_id_len + 1));\n  if (buf->datalen < (size_t)(header_len+length))\n    return 1;\n  result = var_cell_new(length);\n  result->command = command;\n  if (wide_circ_ids)\n    result->circ_id = ntohl(get_uint32(hdr));\n  else\n    result->circ_id = ntohs(get_uint16(hdr));\n  buf_remove_from_front(buf, header_len);\n  peek_from_buf((char*) result->payload, length, buf);\n  buf_remove_from_front(buf, length);\n  check();\n  *out = result;\n  return 1;\n}", "target": 0}
{"code": "void fx_DataView(txMachine* the)\n{\n\ttxSlot* slot;\n\ttxBoolean flag = 0;\n\ttxInteger offset, size;\n\ttxSlot* info;\n\ttxSlot* instance;\n\ttxSlot* view;\n\ttxSlot* buffer;\n\tif (mxIsUndefined(mxTarget))\n\t\tmxTypeError(\"call: DataView\");\n\tif ((mxArgc > 0) && (mxArgv(0)->kind == XS_REFERENCE_KIND)) {\n\t\tslot = mxArgv(0)->value.reference->next;\n\t\tif (slot && ((slot->kind == XS_ARRAY_BUFFER_KIND) || (slot->kind == XS_HOST_KIND))) {\n\t\t\tflag = 1;\n\t\t}\n\t}\n\tif (!flag)\n\t\tmxTypeError(\"buffer is no ArrayBuffer instance\");\n\toffset = fxArgToByteLength(the, 1, 0);\n\tinfo = fxGetBufferInfo(the, mxArgv(0));\n\tif (info->value.bufferInfo.length < offset)\n\t\tmxRangeError(\"out of range byteOffset %ld\", offset);\n\tsize = fxArgToByteLength(the, 2, -1);\n\tif (size >= 0) {\n\t\tif (info->value.bufferInfo.length < (offset + size))\n\t\t\tmxRangeError(\"out of range byteLength %ld\", size);\n\t}\n\telse {\n\t\tif (info->value.bufferInfo.maxLength < 0)\n\t\t\tsize = info->value.bufferInfo.length - offset;\n\t}\n\tmxPushSlot(mxTarget);\n\tfxGetPrototypeFromConstructor(the, &mxDataViewPrototype);\n\tinstance = fxNewDataViewInstance(the);\n\tmxPullSlot(mxResult);\n\tview = instance->next;\n\tbuffer = view->next;\n\tbuffer->kind = XS_REFERENCE_KIND;\n\tbuffer->value.reference = mxArgv(0)->value.reference;\n\tinfo = fxGetBufferInfo(the, buffer);\n\tif (info->value.bufferInfo.maxLength >= 0) {\n\t\tif (info->value.bufferInfo.length < offset)\n\t\t\tmxRangeError(\"out of range byteOffset %ld\", offset);\n\t\telse if (size >= 0) {\n\t\t\tif (info->value.bufferInfo.length < (offset + size))\n\t\t\t\tmxRangeError(\"out of range byteLength %ld\", size);\n\t\t}\n\t}\n\tview->value.dataView.offset = offset;\n\tview->value.dataView.size = size;\n}", "target": 1}
{"code": "static struct mobj *alloc_ta_mem(size_t size)\n{\n#ifdef CFG_PAGED_USER_TA\n\treturn mobj_paged_alloc(size);\n#else\n\tstruct mobj *mobj = mobj_mm_alloc(mobj_sec_ddr, size, &tee_mm_sec_ddr);\n\tif (mobj)\n\t\tmemset(mobj_get_va(mobj, 0), 0, size);\n\treturn mobj;\n#endif\n}", "target": 1}
{"code": "int CLua::execstring(const char *s, const char *context, int nresults)\n{\n    int err = 0;\n    if ((err = loadstring(s, context)))\n        return err;\n    lua_State *ls = state();\n    lua_call_throttle strangler(this);\n    err = lua_pcall(ls, 0, nresults, 0);\n    set_error(err, ls);\n    return err;\n}", "target": 0}
{"code": "static void tcp_send_challenge_ack(struct sock *sk, const struct sk_buff *skb)\n{\n\tstatic u32 challenge_timestamp;\n\tstatic unsigned int challenge_count;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 now;\n\tif (tcp_oow_rate_limited(sock_net(sk), skb,\n\t\t\t\t LINUX_MIB_TCPACKSKIPPEDCHALLENGE,\n\t\t\t\t &tp->last_oow_ack_time))\n\t\treturn;\n\tnow = jiffies / HZ;\n\tif (now != challenge_timestamp) {\n\t\tchallenge_timestamp = now;\n\t\tchallenge_count = 0;\n\t}\n\tif (++challenge_count <= sysctl_tcp_challenge_ack_limit) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);\n\t\ttcp_send_ack(sk);\n\t}\n}", "target": 1}
{"code": "dirvote_get_vote(const char *fp, int flags)\n{\n  int by_id = flags & DGV_BY_ID;\n  const int include_pending = flags & DGV_INCLUDE_PENDING;\n  const int include_previous = flags & DGV_INCLUDE_PREVIOUS;\n  if (!pending_vote_list && !previous_vote_list)\n    return NULL;\n  if (fp == NULL) {\n    authority_cert_t *c = get_my_v3_authority_cert();\n    if (c) {\n      fp = c->cache_info.identity_digest;\n      by_id = 1;\n    } else\n      return NULL;\n  }\n  if (by_id) {\n    if (pending_vote_list && include_pending) {\n      SMARTLIST_FOREACH(pending_vote_list, pending_vote_t *, pv,\n        if (fast_memeq(get_voter(pv->vote)->identity_digest, fp, DIGEST_LEN))\n          return pv->vote_body);\n    }\n    if (previous_vote_list && include_previous) {\n      SMARTLIST_FOREACH(previous_vote_list, pending_vote_t *, pv,\n        if (fast_memeq(get_voter(pv->vote)->identity_digest, fp, DIGEST_LEN))\n          return pv->vote_body);\n    }\n  } else {\n    if (pending_vote_list && include_pending) {\n      SMARTLIST_FOREACH(pending_vote_list, pending_vote_t *, pv,\n        if (fast_memeq(pv->vote->digests.d[DIGEST_SHA1], fp, DIGEST_LEN))\n          return pv->vote_body);\n    }\n    if (previous_vote_list && include_previous) {\n      SMARTLIST_FOREACH(previous_vote_list, pending_vote_t *, pv,\n        if (fast_memeq(pv->vote->digests.d[DIGEST_SHA1], fp, DIGEST_LEN))\n          return pv->vote_body);\n    }\n  }\n  return NULL;\n}", "target": 0}
{"code": "void PdfXRefStreamParserObject::getIndices(vector<int64_t>& indices, int64_t size)\n{\n    auto indexObj = this->GetDictionary().GetKey(\"Index\");\n    if (indexObj == nullptr)\n    {\n        indices.push_back(static_cast<int64_t>(0));\n        indices.push_back(size);\n    }\n    else\n    {\n        const PdfArray* arr;\n        if (!indexObj->TryGetArray(arr))\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef Stream /Index\");\n        for (auto index : *arr)\n            indices.push_back(index.GetNumber());\n    }\n    if (indices.size() % 2 != 0)\n        PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef Stream /Index\");\n}", "target": 1}
{"code": "static int do_remount(struct path *path, int flags, int mnt_flags,\n\t\t      void *data)\n{\n\tint err;\n\tstruct super_block *sb = path->mnt->mnt_sb;\n\tstruct mount *mnt = real_mount(path->mnt);\n\tif (!check_mnt(mnt))\n\t\treturn -EINVAL;\n\tif (path->dentry != path->mnt->mnt_root)\n\t\treturn -EINVAL;\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_READONLY) &&\n\t    !(mnt_flags & MNT_READONLY)) {\n\t\treturn -EPERM;\n\t}\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_NODEV) &&\n\t    !(mnt_flags & MNT_NODEV)) {\n\t\treturn -EPERM;\n\t}\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_NOSUID) &&\n\t    !(mnt_flags & MNT_NOSUID)) {\n\t\treturn -EPERM;\n\t}\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_NOEXEC) &&\n\t    !(mnt_flags & MNT_NOEXEC)) {\n\t\treturn -EPERM;\n\t}\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_ATIME) &&\n\t    ((mnt->mnt.mnt_flags & MNT_ATIME_MASK) != (mnt_flags & MNT_ATIME_MASK))) {\n\t\treturn -EPERM;\n\t}\n\terr = security_sb_remount(sb, data);\n\tif (err)\n\t\treturn err;\n\tdown_write(&sb->s_umount);\n\tif (flags & MS_BIND)\n\t\terr = change_mount_flags(path->mnt, flags);\n\telse if (!capable(CAP_SYS_ADMIN))\n\t\terr = -EPERM;\n\telse\n\t\terr = do_remount_sb(sb, flags, data, 0);\n\tif (!err) {\n\t\tlock_mount_hash();\n\t\tmnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;\n\t\tmnt->mnt.mnt_flags = mnt_flags;\n\t\ttouch_mnt_namespace(mnt->mnt_ns);\n\t\tunlock_mount_hash();\n\t}\n\tup_write(&sb->s_umount);\n\treturn err;\n}", "target": 0}
{"code": "static int rfcomm_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)\n{\n\tstruct sockaddr_rc *sa = (struct sockaddr_rc *) addr;\n\tstruct sock *sk = sock->sk;\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\tmemset(sa, 0, sizeof(*sa));\n\tsa->rc_family  = AF_BLUETOOTH;\n\tsa->rc_channel = rfcomm_pi(sk)->channel;\n\tif (peer)\n\t\tbacpy(&sa->rc_bdaddr, &bt_sk(sk)->dst);\n\telse\n\t\tbacpy(&sa->rc_bdaddr, &bt_sk(sk)->src);\n\t*len = sizeof(struct sockaddr_rc);\n\treturn 0;\n}", "target": 0}
{"code": "static void __reg_combine_min_max(struct bpf_reg_state *src_reg,\n\t\t\t\t  struct bpf_reg_state *dst_reg)\n{\n\tsrc_reg->umin_value = dst_reg->umin_value = max(src_reg->umin_value,\n\t\t\t\t\t\t\tdst_reg->umin_value);\n\tsrc_reg->umax_value = dst_reg->umax_value = min(src_reg->umax_value,\n\t\t\t\t\t\t\tdst_reg->umax_value);\n\tsrc_reg->smin_value = dst_reg->smin_value = max(src_reg->smin_value,\n\t\t\t\t\t\t\tdst_reg->smin_value);\n\tsrc_reg->smax_value = dst_reg->smax_value = min(src_reg->smax_value,\n\t\t\t\t\t\t\tdst_reg->smax_value);\n\tsrc_reg->var_off = dst_reg->var_off = tnum_intersect(src_reg->var_off,\n\t\t\t\t\t\t\t     dst_reg->var_off);\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n\t__reg_deduce_bounds(src_reg);\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(src_reg);\n\t__reg_bound_offset(dst_reg);\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n}", "target": 0}
{"code": "unsigned int bounded_iostream::write_no_buffer(const void *from, size_t bytes_to_write) {\n    std::pair<unsigned int, Sirikata::JpegError> retval;\n    if (byte_bound != 0 && byte_position + bytes_to_write > byte_bound) {\n        size_t real_bytes_to_write = byte_bound - byte_position;\n        byte_position += real_bytes_to_write;\n        retval = parent->Write(reinterpret_cast<const unsigned char*>(from), real_bytes_to_write);\n        if (retval.first < real_bytes_to_write) {\n            err = retval.second;\n            return retval.first;\n        }\n        return bytes_to_write; \n    }\n    size_t total = bytes_to_write;\n    retval = parent->Write(reinterpret_cast<const unsigned char*>(from), total);\n    unsigned int written = retval.first;\n    byte_position += written;\n    if (written < total ) {\n        err = retval.second;\n        return written;\n    }\n    return bytes_to_write;\n}", "target": 1}
{"code": "static int open_without_symlink(const char *target, const char *prefix_skip)\n{\n\tint curlen = 0, dirfd, fulllen, i;\n\tchar *dup = NULL;\n\tfulllen = strlen(target);\n\tif (prefix_skip) {\n\t\tcurlen = strlen(prefix_skip);\n\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n\t\t\tERROR(\"WHOA there - target '%s' didn't start with prefix '%s'\",\n\t\t\t\ttarget, prefix_skip);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (curlen)\n\t\t\tcurlen--;\n\t} else {\n\t\tprefix_skip = \"/\";\n\t\tcurlen = 0;\n\t}\n\tif ((dup = strdup(target)) == NULL) {\n\t\tSYSERROR(\"Out of memory checking for symbolic link\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < fulllen; i++) {\n\t\tif (dup[i] == '/')\n\t\t\tdup[i] = '\\0';\n\t}\n\tdirfd = open(prefix_skip, O_RDONLY);\n\tif (dirfd < 0)\n\t\tgoto out;\n\twhile (1) {\n\t\tint newfd, saved_errno;\n\t\tchar *nextpath;\n\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n\t\t\tgoto out;\n\t\tnewfd = open_if_safe(dirfd, nextpath);\n\t\tsaved_errno = errno;\n\t\tclose(dirfd);\n\t\tdirfd = newfd;\n\t\tif (newfd < 0) {\n\t\t\terrno = saved_errno;\n\t\t\tif (errno == ELOOP)\n\t\t\t\tSYSERROR(\"%s in %s was a symbolic link!\", nextpath, target);\n\t\t\telse\n\t\t\t\tSYSERROR(\"Error examining %s in %s\", nextpath, target);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tfree(dup);\n\treturn dirfd;\n}", "target": 0}
{"code": "int r_bin_pdb_download(RCore *core, int isradjson, int *actions_done, SPDBOptions *options) {\n\tint ret;\n\tSPDBDownloaderOpt opt;\n\tSPDBDownloader pdb_downloader;\n\tRBinInfo *info = r_bin_get_info (core->bin);\n\tif (!info || !info->debug_file_name) {\n\t\teprintf (\"Can't find debug filename\\n\");\n\t\treturn 1;\n\t}\n\tif (!is_valid_guid (info->guid)) {\n\t\teprintf (\"Invalid GUID for file\\n\");\n\t\treturn 1;\n\t}\n\tif (!options || !options->symbol_server || !options->user_agent) {\n\t\teprintf (\"Can't retrieve pdb configurations\\n\");\n\t\treturn 1;\n\t}\n\topt.dbg_file = (char*) r_file_basename (info->debug_file_name);\n\topt.guid = info->guid;\n\topt.symbol_server = options->symbol_server;\n\topt.user_agent = options->user_agent;\n\topt.symbol_store_path = options->symbol_store_path;\n\topt.extract = options->extract;\n\tinit_pdb_downloader (&opt, &pdb_downloader);\n\tret = pdb_downloader.download ? pdb_downloader.download (&pdb_downloader) : 0;\n\tif (isradjson && actions_done) {\n\t\tprintf (\"%s\\\"pdb\\\":{\\\"file\\\":\\\"%s\\\",\\\"download\\\":%s}\",\n\t\t        *actions_done ? \",\" : \"\", opt.dbg_file, ret ? \"true\" : \"false\");\n\t} else {\n\t\tprintf (\"PDB \\\"%s\\\" download %s\\n\",\n\t\t        opt.dbg_file, ret ? \"success\" : \"failed\");\n\t}\n\tif (actions_done) {\n\t\t(*actions_done)++;\n\t}\n\tdeinit_pdb_downloader (&pdb_downloader);\n\treturn 0;\n}", "target": 0}
{"code": "static bool checkreturn decode_static_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)\n{\n    pb_type_t type;\n    pb_decoder_t func;\n    type = iter->pos->type;\n    func = PB_DECODERS[PB_LTYPE(type)];\n    switch (PB_HTYPE(type))\n    {\n        case PB_HTYPE_REQUIRED:\n            return func(stream, iter->pos, iter->pData);\n        case PB_HTYPE_OPTIONAL:\n            if (iter->pSize != iter->pData)\n                *(bool*)iter->pSize = true;\n            return func(stream, iter->pos, iter->pData);\n        case PB_HTYPE_REPEATED:\n            if (wire_type == PB_WT_STRING\n                && PB_LTYPE(type) <= PB_LTYPE_LAST_PACKABLE)\n            {\n                bool status = true;\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n                pb_istream_t substream;\n                if (!pb_make_string_substream(stream, &substream))\n                    return false;\n                while (substream.bytes_left > 0 && *size < iter->pos->array_size)\n                {\n                    void *pItem = (char*)iter->pData + iter->pos->data_size * (*size);\n                    if (!func(&substream, iter->pos, pItem))\n                    {\n                        status = false;\n                        break;\n                    }\n                    (*size)++;\n                }\n                if (substream.bytes_left != 0)\n                    PB_RETURN_ERROR(stream, \"array overflow\");\n                if (!pb_close_string_substream(stream, &substream))\n                    return false;\n                return status;\n            }\n            else\n            {\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n                char *pItem = (char*)iter->pData + iter->pos->data_size * (*size);\n                if ((*size)++ >= iter->pos->array_size)\n                    PB_RETURN_ERROR(stream, \"array overflow\");\n                return func(stream, iter->pos, pItem);\n            }\n        case PB_HTYPE_ONEOF:\n            *(pb_size_t*)iter->pSize = iter->pos->tag;\n            if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE)\n            {\n                memset(iter->pData, 0, iter->pos->data_size);\n                pb_message_set_to_defaults((const pb_field_t*)iter->pos->ptr, iter->pData);\n            }\n            return func(stream, iter->pos, iter->pData);\n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n}", "target": 1}
{"code": "Network::FilterStatus Context::onNetworkNewConnection() {\n  onCreate(root_context_id_);\n  in_vm_context_created_ = true;\n  if (!wasm_->onNewConnection_) {\n    return Network::FilterStatus::Continue;\n  }\n  if (wasm_->onNewConnection_(this, id_).u64_ == 0) {\n    return Network::FilterStatus::Continue;\n  }\n  return Network::FilterStatus::StopIteration;\n}", "target": 0}
{"code": "size_t IOBuf::goodExtBufferSize(std::size_t minCapacity) {\n  if (minCapacity > kMaxIOBufSize) {\n    throw_exception<std::bad_alloc>();\n  }\n  size_t minSize = static_cast<size_t>(minCapacity) + sizeof(SharedInfo);\n  minSize = (minSize + 7) & ~7;\n  return goodMallocSize(minSize);\n}", "target": 0}
{"code": "static long vhost_vdpa_set_config_call(struct vhost_vdpa *v, u32 __user *argp)\n{\n\tstruct vdpa_callback cb;\n\tint fd;\n\tstruct eventfd_ctx *ctx;\n\tcb.callback = vhost_vdpa_config_cb;\n\tcb.private = v->vdpa;\n\tif (copy_from_user(&fd, argp, sizeof(fd)))\n\t\treturn  -EFAULT;\n\tctx = fd == VHOST_FILE_UNBIND ? NULL : eventfd_ctx_fdget(fd);\n\tswap(ctx, v->config_ctx);\n\tif (!IS_ERR_OR_NULL(ctx))\n\t\teventfd_ctx_put(ctx);\n\tif (IS_ERR(v->config_ctx))\n\t\treturn PTR_ERR(v->config_ctx);\n\tv->vdpa->config->set_config_cb(v->vdpa, &cb);\n\treturn 0;\n}", "target": 0}
{"code": "find_entry2modify(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n\tback_txn *txn\n)\n{\n\treturn( find_entry_internal( pb, be, addr, 1, txn, 0 ) );\n}", "target": 1}
{"code": "  template<typename T> const T GetWirelessNetworkByPath(\n      const std::vector<T>& networks, const std::string& path) const {\n    typedef typename std::vector<T>::const_iterator iter_t;\n    iter_t iter = std::find_if(networks.begin(), networks.end(),\n                               WirelessNetwork::ServicePathEq(path));\n    return (iter != networks.end()) ? *iter : NULL;\n  }", "target": 0}
{"code": "int devmem_is_allowed(unsigned long pagenr)\n{\n\tif (pagenr < 256)\n\t\treturn 1;\n\tif (iomem_is_exclusive(pagenr << PAGE_SHIFT))\n\t\treturn 0;\n\tif (!page_is_ram(pagenr))\n\t\treturn 1;\n\treturn 0;\n}", "target": 1}
{"code": "Status TensorSliceWriter::SaveData(const T* data, int64_t num_elements,\n                                   SavedSlice* ss) {\n  size_t size_bound =\n      ss->ByteSize() + kTensorProtoHeaderBytes +\n      (MaxBytesPerElement(DataTypeToEnum<T>::value) * num_elements);\n  if (size_bound > kMaxMessageBytes) {\n    return errors::InvalidArgument(\n        \"Tensor slice is too large to serialize (conservative estimate: \",\n        size_bound, \" bytes)\");\n  }\n  Fill(data, num_elements, ss->mutable_data());\n  DCHECK_GE(ss->ByteSize(), 0);\n  DCHECK_LE(ss->ByteSize(), size_bound);\n  return OkStatus();\n}", "target": 1}
{"code": "static void mov_parse_stsd_subtitle(MOVContext *c, AVIOContext *pb,\n                                    AVStream *st, MOVStreamContext *sc,\n                                    int64_t size)\n{\n    MOVAtom fake_atom = { .size = size };\n    if (st->codecpar->codec_tag != AV_RL32(\"mp4s\"))\n        mov_read_glbl(c, pb, fake_atom);\n    st->codecpar->width  = sc->width;\n    st->codecpar->height = sc->height;\n}", "target": 0}
{"code": "fbFetchPixel_b8g8r8 (const FbBits *bits, int offset, miIndexedPtr indexed)\n{\n    CARD8   *pixel = ((CARD8 *) bits) + (offset*3);\n#if IMAGE_BYTE_ORDER == MSBFirst\n    return (0xff000000 |\n\t    (READ(pixel + 2) << 16) |\n\t    (READ(pixel + 1) << 8) |\n\t    (READ(pixel + 0)));\n#else\n    return (0xff000000 |\n\t    (READ(pixel + 0) << 16) |\n\t    (READ(pixel + 1) << 8) |\n\t    (READ(pixel + 2)));\n#endif\n}", "target": 0}
{"code": "NOEXPORT int parse_socket_error(CLI *c, const char *text) {\n    switch(get_last_socket_error()) {\n    case 0: \n#ifndef USE_WIN32\n    case EPIPE: \n#endif\n    case S_ECONNABORTED:\n        s_log(LOG_INFO, \"%s: Socket is closed\", text);\n        return 0;\n    case S_EINTR:\n        s_log(LOG_DEBUG, \"%s: Interrupted by a signal: retrying\", text);\n        return 1;\n    case S_EWOULDBLOCK:\n        s_log(LOG_NOTICE, \"%s: Would block: retrying\", text);\n        s_poll_sleep(1, 0); \n        return 1;\n#if S_EAGAIN!=S_EWOULDBLOCK\n    case S_EAGAIN:\n        s_log(LOG_DEBUG,\n            \"%s: Temporary lack of resources: retrying\", text);\n        return 1;\n#endif\n#ifdef USE_WIN32\n    case S_ECONNRESET:\n        if(c->opt->exec_name) {\n            s_log(LOG_INFO, \"%s: Socket is closed (exec)\", text);\n            return 0;\n        }\n#endif\n    default:\n        sockerror(text);\n        throw_exception(c, 1);\n        return -1; \n    }\n}", "target": 1}
{"code": "check_1_6_dummy(kadm5_principal_ent_t entry, long mask,\n                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)\n{\n    int i;\n    char *password = *passptr;\n    if (!(mask & KADM5_ATTRIBUTES) ||\n        !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))\n        return;\n    for (i = 0; (unsigned char) password[i] == i + 1; i++);\n    if (password[i] != '\\0' || i != 255)\n        return;\n    *passptr = NULL;\n}", "target": 1}
{"code": "static int on_security_message(struct nvnc_client* client)\n{\n\tif (client->buffer_len - client->buffer_index < 1)\n\t\treturn 0;\n\tuint8_t type = client->msg_buffer[client->buffer_index];\n\tnvnc_log(NVNC_LOG_DEBUG, \"Client chose security type: %d\", type);\n\tif (!is_allowed_security_type(client->server, type)) {\n\t\tsecurity_handshake_failed(client, NULL, \"Illegal security type\");\n\t\treturn sizeof(type);\n\t}\n\tswitch (type) {\n\tcase RFB_SECURITY_TYPE_NONE:\n\t\tsecurity_handshake_ok(client, NULL);\n\t\tclient->state = VNC_CLIENT_STATE_WAITING_FOR_INIT;\n\t\tbreak;\n#ifdef ENABLE_TLS\n\tcase RFB_SECURITY_TYPE_VENCRYPT:\n\t\tvencrypt_send_version(client);\n\t\tclient->state = VNC_CLIENT_STATE_WAITING_FOR_VENCRYPT_VERSION;\n\t\tbreak;\n#endif\n#ifdef HAVE_CRYPTO\n\tcase RFB_SECURITY_TYPE_APPLE_DH:\n\t\tapple_dh_send_public_key(client);\n\t\tclient->state = VNC_CLIENT_STATE_WAITING_FOR_APPLE_DH_RESPONSE;\n\t\tbreak;\n\tcase RFB_SECURITY_TYPE_RSA_AES:\n\t\tclient->rsa.hash_type = CRYPTO_HASH_SHA1;\n\t\tclient->rsa.cipher_type = CRYPTO_CIPHER_AES_EAX;\n\t\tclient->rsa.challenge_len = 16;\n\t\trsa_aes_send_public_key(client);\n\t\tclient->state = VNC_CLIENT_STATE_WAITING_FOR_RSA_AES_PUBLIC_KEY;\n\t\tbreak;\n\tcase RFB_SECURITY_TYPE_RSA_AES256:\n\t\tclient->rsa.hash_type = CRYPTO_HASH_SHA256;\n\t\tclient->rsa.cipher_type = CRYPTO_CIPHER_AES256_EAX;\n\t\tclient->rsa.challenge_len = 32;\n\t\trsa_aes_send_public_key(client);\n\t\tclient->state = VNC_CLIENT_STATE_WAITING_FOR_RSA_AES_PUBLIC_KEY;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tsecurity_handshake_failed(client, NULL,\n\t\t\t\t\"Unsupported security type\");\n\t\tbreak;\n\t}\n\treturn sizeof(type);\n}", "target": 0}
{"code": "int dns_HTTPS_add_alpn(struct dns_rr_nested *svcparam, const char *alpn, int alpn_len)\n{\n\tif (_dns_left_len(&svcparam->context) < 2 + 2 + alpn_len) {\n\t\treturn -1;\n\t}\n\tunsigned short value = DNS_HTTPS_T_ALPN;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tvalue = alpn_len;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tdns_add_rr_nested_memcpy(svcparam, alpn, alpn_len);\n\treturn 0;\n}", "target": 0}
{"code": "static int verify_ordered(unsigned mode1, const char *name1, unsigned mode2, const char *name2)\n{\n\tint len1 = strlen(name1);\n\tint len2 = strlen(name2);\n\tint len = len1 < len2 ? len1 : len2;\n\tunsigned char c1, c2;\n\tint cmp;\n\tcmp = memcmp(name1, name2, len);\n\tif (cmp < 0)\n\t\treturn 0;\n\tif (cmp > 0)\n\t\treturn TREE_UNORDERED;\n\tc1 = name1[len];\n\tc2 = name2[len];\n\tif (!c1 && !c2)\n\t\treturn TREE_HAS_DUPS;\n\tif (!c1 && S_ISDIR(mode1))\n\t\tc1 = '/';\n\tif (!c2 && S_ISDIR(mode2))\n\t\tc2 = '/';\n\treturn c1 < c2 ? 0 : TREE_UNORDERED;\n}", "target": 0}
{"code": "void OneHotComputeImpl(const OneHotContext& op_context) {\n  int prefix_dim_size = 1;\n  for (int i = 0; i < op_context.axis; ++i) {\n    prefix_dim_size *= op_context.indices->dims->data[i];\n  }\n  if (prefix_dim_size == 0) {\n    return;\n  }\n  const int suffix_dim_size = NumElements(op_context.indices) / prefix_dim_size;\n  const int depth = *op_context.depth->data.i32;\n  const T on_value = *GetTensorData<T>(op_context.on_value);\n  const T off_value = *GetTensorData<T>(op_context.off_value);\n  T* output = GetTensorData<T>(op_context.output);\n  const TI* indices = GetTensorData<TI>(op_context.indices);\n  for (int i = 0; i < prefix_dim_size; ++i) {\n    for (int j = 0; j < depth; ++j) {\n      for (int k = 0; k < suffix_dim_size; ++k, ++output) {\n        *output = static_cast<int>(indices[i * suffix_dim_size + k]) == j\n                      ? on_value\n                      : off_value;\n      }\n    }\n  }\n}", "target": 0}
{"code": "void make_random_permutation(int start) {\n        int i, j;\n        permutation[0] = start;\t\n        for (i = 1; i < ARRAY_SIZE; i++) {\n                j = random() * (double)(i + 1) / RAND_MAX; \n                if (j != i) { \n                  permutation[i] = permutation[j];\n                }\n                permutation[j] = start + i;\n        }\n}", "target": 0}
{"code": "snmp_ber_encode_type(unsigned char *out, uint32_t *out_len, uint8_t type)\n{\n  *out-- = type;\n  (*out_len)++;\n  return out;\n}", "target": 1}
{"code": "ldap_pvt_tls_check_hostname( LDAP *ld, void *s, const char *name_in )\n{\n\ttls_session *session = s;\n\tif (ld->ld_options.ldo_tls_require_cert != LDAP_OPT_X_TLS_NEVER &&\n\t    ld->ld_options.ldo_tls_require_cert != LDAP_OPT_X_TLS_ALLOW) {\n\t\tld->ld_errno = tls_imp->ti_session_chkhost( ld, session, name_in );\n\t\tif (ld->ld_errno != LDAP_SUCCESS) {\n\t\t\treturn ld->ld_errno;\n\t\t}\n\t}\n\treturn LDAP_SUCCESS;\n}", "target": 0}
{"code": "static void lo_release(struct gendisk *disk, fmode_t mode)\n{\n\tstruct loop_device *lo = disk->private_data;\n\tint err;\n\tif (atomic_dec_return(&lo->lo_refcnt))\n\t\treturn;\n\tmutex_lock(&lo->lo_ctl_mutex);\n\tif (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {\n\t\terr = loop_clr_fd(lo);\n\t\tif (!err)\n\t\t\treturn;\n\t} else if (lo->lo_state == Lo_bound) {\n\t\tblk_mq_freeze_queue(lo->lo_queue);\n\t\tblk_mq_unfreeze_queue(lo->lo_queue);\n\t}\n\tmutex_unlock(&lo->lo_ctl_mutex);\n}", "target": 1}
{"code": "Http::FilterDataStatus Context::onResponseBody(int body_buffer_length, bool end_of_stream) {\n  if (!wasm_->onResponseBody_) {\n    return Http::FilterDataStatus::Continue;\n  }\n  switch (wasm_\n              ->onResponseBody_(this, id_, static_cast<uint32_t>(body_buffer_length),\n                                static_cast<uint32_t>(end_of_stream))\n              .u64_) {\n  case 0:\n    return Http::FilterDataStatus::Continue;\n  case 1:\n    return Http::FilterDataStatus::StopIterationAndBuffer;\n  case 2:\n    return Http::FilterDataStatus::StopIterationAndWatermark;\n  default:\n    return Http::FilterDataStatus::StopIterationNoBuffer;\n  }\n}", "target": 1}
{"code": "void native_tss_update_io_bitmap(void)\n{\n\tstruct tss_struct *tss = this_cpu_ptr(&cpu_tss_rw);\n\tstruct thread_struct *t = &current->thread;\n\tu16 *base = &tss->x86_tss.io_bitmap_base;\n\tif (!test_thread_flag(TIF_IO_BITMAP)) {\n\t\ttss_invalidate_io_bitmap(tss);\n\t\treturn;\n\t}\n\tif (IS_ENABLED(CONFIG_X86_IOPL_IOPERM) && t->iopl_emul == 3) {\n\t\t*base = IO_BITMAP_OFFSET_VALID_ALL;\n\t} else {\n\t\tstruct io_bitmap *iobm = t->io_bitmap;\n\t\tif (tss->io_bitmap.prev_sequence != iobm->sequence)\n\t\t\ttss_copy_io_bitmap(tss, iobm);\n\t\t*base = IO_BITMAP_OFFSET_VALID_MAP;\n\t}\n\trefresh_tss_limit();\n}", "target": 1}
{"code": "GF_Err svhd_box_size(GF_Box *s)\n{\n\tGF_SphericalVideoInfoBox *ptr = (GF_SphericalVideoInfoBox *)s;\n\tif (ptr->string)\n\t\ts->size += (u32) strlen(ptr->string);\n\ts->size += 1;\n\treturn GF_OK;\n}", "target": 0}
{"code": "int snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\tunsigned int count;\n\tint err = -EINVAL;\n\tif (! kcontrol)\n\t\treturn err;\n\tif (snd_BUG_ON(!card || !kcontrol->info))\n\t\tgoto error;\n\tid = kcontrol->id;\n\tif (id.index > UINT_MAX - kcontrol->count)\n\t\tgoto error;\n\tdown_write(&card->controls_rwsem);\n\tif (snd_ctl_find_id(card, &id)) {\n\t\tup_write(&card->controls_rwsem);\n\t\tdev_err(card->dev, \"control %i:%i:%i:%s:%i is already present\\n\",\n\t\t\t\t\tid.iface,\n\t\t\t\t\tid.device,\n\t\t\t\t\tid.subdevice,\n\t\t\t\t\tid.name,\n\t\t\t\t\tid.index);\n\t\terr = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (snd_ctl_find_hole(card, kcontrol->count) < 0) {\n\t\tup_write(&card->controls_rwsem);\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tlist_add_tail(&kcontrol->list, &card->controls);\n\tcard->controls_count += kcontrol->count;\n\tkcontrol->id.numid = card->last_numid + 1;\n\tcard->last_numid += kcontrol->count;\n\tcount = kcontrol->count;\n\tup_write(&card->controls_rwsem);\n\tfor (idx = 0; idx < count; idx++, id.index++, id.numid++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);\n\treturn 0;\n error:\n\tsnd_ctl_free_one(kcontrol);\n\treturn err;\n}", "target": 0}
{"code": "static void mspack_fmap_free(void *mem)\n{\n\tfree(mem);\n}", "target": 1}
{"code": "static const char *valid_domain_label(const char *label)\n{\n\tunsigned char ch;\n\tunsigned pos = 0;\n\tfor (;;) {\n\t\tch = *label;\n\t\tif ((ch|0x20) < 'a' || (ch|0x20) > 'z') {\n\t\t\tif (ch < '0' || ch > '9') {\n\t\t\t\tif (ch == '\\0' || ch == '.')\n\t\t\t\t\treturn label;\n\t\t\t\tif (ch != '-' && ch != '_')\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tlabel++;\n\t\tpos++;\n\t}\n}", "target": 0}
{"code": "gss_wrap_iov_length (minor_status,\n                     context_handle,\n                     conf_req_flag,\n                     qop_req,\n                     conf_state,\n                     iov,\n                     iov_count)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nint\t\t\tconf_req_flag;\ngss_qop_t\t\tqop_req;\nint *\t\t\tconf_state;\ngss_iov_buffer_desc  *\tiov;\nint\t\t\tiov_count;\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    status = val_wrap_iov_args(minor_status, context_handle,\n\t\t\t       conf_req_flag, qop_req,\n\t\t\t       conf_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech) {\n\tif (mech->gss_wrap_iov_length) {\n\t    status = mech->gss_wrap_iov_length(\n\t\t\t\t\t      minor_status,\n\t\t\t\t\t      ctx->internal_ctx_id,\n\t\t\t\t\t      conf_req_flag,\n\t\t\t\t\t      qop_req,\n\t\t\t\t\t      conf_state,\n\t\t\t\t\t      iov,\n\t\t\t\t\t      iov_count);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\treturn(status);\n    }\n    return (GSS_S_BAD_MECH);\n}", "target": 0}
{"code": "static int proc_pid_readlink(struct dentry * dentry, char __user * buffer, int buflen)\n{\n\tint error = -EACCES;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct dentry *de;\n\tstruct vfsmount *mnt = NULL;\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\terror = PROC_I(inode)->op.proc_get_link(inode, &de, &mnt);\n\tif (error)\n\t\tgoto out;\n\terror = do_proc_readlink(de, mnt, buffer, buflen);\n\tdput(de);\n\tmntput(mnt);\nout:\n\treturn error;\n}", "target": 0}
{"code": "static void dns_handler(int dns_err, const struct sa *srv, void *arg)\n{\n\tstruct lookup_entry *lent = arg;\n\tstruct sa turn_srv;\n\tre_printf(\"DNS lookup for: %s err=%d\\n\", lent->host, dns_err);\n\tif (dns_err)\n\t\tgoto out;\n\tsa_cpy(&turn_srv, srv);\n\tsa_set_port(&turn_srv, lent->port);\n\tre_printf(\"DNS lookup success: %s -> %J(proto=%s secure=%d)\\n\",\n\t\t  lent->host, &turn_srv, net_proto2name(lent->proto),\n\t\t  lent->secure);\n\tstart_netprobe(&turn_srv, lent->proto, lent->secure,\n\t\t       lent->turn.username, lent->turn.credential);\n out:\n\tmem_deref(lent);\n}", "target": 0}
{"code": "void* IOBuf::operator new(size_t size) {\n  if (size > kMaxIOBufSize) {\n    throw_exception<std::bad_alloc>();\n  }\n  size_t fullSize = offsetof(HeapStorage, buf) + size;\n  auto storage = static_cast<HeapStorage*>(checkedMalloc(fullSize));\n  new (&storage->prefix) HeapPrefix(kIOBufInUse, fullSize);\n  if (io_buf_alloc_cb) {\n    io_buf_alloc_cb(storage, fullSize);\n  }\n  return &(storage->buf);\n}", "target": 0}
{"code": "static int clgi_interception(struct vcpu_svm *svm)\n{\n\tif (nested_svm_check_permissions(svm))\n\t\treturn 1;\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 3;\n\tskip_emulated_instruction(&svm->vcpu);\n\tdisable_gif(svm);\n\tsvm_clear_vintr(svm);\n\tsvm->vmcb->control.int_ctl &= ~V_IRQ_MASK;\n\tmark_dirty(svm->vmcb, VMCB_INTR);\n\treturn 1;\n}", "target": 0}
{"code": "static int xennet_xdp_xmit(struct net_device *dev, int n,\n\t\t\t   struct xdp_frame **frames, u32 flags)\n{\n\tunsigned int num_queues = dev->real_num_tx_queues;\n\tstruct netfront_info *np = netdev_priv(dev);\n\tstruct netfront_queue *queue = NULL;\n\tunsigned long irq_flags;\n\tint nxmit = 0;\n\tint i;\n\tif (unlikely(np->broken))\n\t\treturn -ENODEV;\n\tif (unlikely(flags & ~XDP_XMIT_FLAGS_MASK))\n\t\treturn -EINVAL;\n\tqueue = &np->queues[smp_processor_id() % num_queues];\n\tspin_lock_irqsave(&queue->tx_lock, irq_flags);\n\tfor (i = 0; i < n; i++) {\n\t\tstruct xdp_frame *xdpf = frames[i];\n\t\tif (!xdpf)\n\t\t\tcontinue;\n\t\tif (xennet_xdp_xmit_one(dev, queue, xdpf))\n\t\t\tbreak;\n\t\tnxmit++;\n\t}\n\tspin_unlock_irqrestore(&queue->tx_lock, irq_flags);\n\treturn nxmit;\n}", "target": 0}
{"code": "static EctEnhancedCT *create()\n{\n    IODEnhGeneralEquipmentModule::EquipmentInfo eq(\"Open Connections\", \"OC CT\", \"4711\", \"0.1\");\n    EctEnhancedCT *ct = NULL;\n    OFCondition result;\n    result = EctEnhancedCT::create(ct,\n                                   NUM_ROWS,\n                                   NUM_COLS,\n                                   OFFalse,\n                                   EctTypes::E_ImageType1_Original,\n                                   EctTypes::DT_ImageType3_Volume,\n                                   EctTypes::DT_ImageType4_Maximum,\n                                   \"1\" ,\n                                   EctTypes::E_ContQuali_Research,\n                                   EctTypes::E_PixelPres_Monochrome,\n                                   EctTypes::E_VolProps_Volume,\n                                   EctTypes::DT_VolBasedCalcTechnique_VolumeRender,\n                                   eq,\n                                   \"20190801120000\" ,\n                                   2.0 );\n    OFCHECK(result.good());\n    OFCHECK(ct != OFnullptr);\n    return ct;\n}", "target": 0}
{"code": "int VP8LBuildHuffmanTable(HuffmanCode* const root_table, int root_bits,\n                          const int code_lengths[], int code_lengths_size) {\n  int total_size;\n  assert(code_lengths_size <= MAX_CODE_LENGTHS_SIZE);\n  if (root_table == NULL) {\n    total_size = BuildHuffmanTable(NULL, root_bits,\n                                   code_lengths, code_lengths_size, NULL);\n  } else if (code_lengths_size <= SORTED_SIZE_CUTOFF) {\n    uint16_t sorted[SORTED_SIZE_CUTOFF];\n    total_size = BuildHuffmanTable(root_table, root_bits,\n                                   code_lengths, code_lengths_size, sorted);\n  } else {   \n    uint16_t* const sorted =\n        (uint16_t*)WebPSafeMalloc(code_lengths_size, sizeof(*sorted));\n    if (sorted == NULL) return 0;\n    total_size = BuildHuffmanTable(root_table, root_bits,\n                                   code_lengths, code_lengths_size, sorted);\n    WebPSafeFree(sorted);\n  }\n  return total_size;\n}", "target": 1}
{"code": "STACK_OF(PKCS12_SAFEBAG) *PKCS12_unpack_p7encdata(PKCS7 *p7, const char *pass,\n                                                  int passlen)\n{\n    if (!PKCS7_type_is_encrypted(p7))\n        return NULL;\n    if (p7->d.encrypted == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_DECODE_ERROR);\n        return NULL;\n    }\n    return PKCS12_item_decrypt_d2i_ex(p7->d.encrypted->enc_data->algorithm,\n                                   ASN1_ITEM_rptr(PKCS12_SAFEBAGS),\n                                   pass, passlen,\n                                   p7->d.encrypted->enc_data->enc_data, 1,\n                                   p7->ctx.libctx, p7->ctx.propq);\n}", "target": 0}
{"code": "int hugepage_madvise(struct vm_area_struct *vma,\n\t\t     unsigned long *vm_flags, int advice)\n{\n\tswitch (advice) {\n\tcase MADV_HUGEPAGE:\n\t\tif (*vm_flags & (VM_HUGEPAGE |\n\t\t\t\t VM_SHARED   | VM_MAYSHARE   |\n\t\t\t\t VM_PFNMAP   | VM_IO      | VM_DONTEXPAND |\n\t\t\t\t VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE |\n\t\t\t\t VM_MIXEDMAP | VM_SAO))\n\t\t\treturn -EINVAL;\n\t\t*vm_flags &= ~VM_NOHUGEPAGE;\n\t\t*vm_flags |= VM_HUGEPAGE;\n\t\tif (unlikely(khugepaged_enter_vma_merge(vma)))\n\t\t\treturn -ENOMEM;\n\t\tbreak;\n\tcase MADV_NOHUGEPAGE:\n\t\tif (*vm_flags & (VM_NOHUGEPAGE |\n\t\t\t\t VM_SHARED   | VM_MAYSHARE   |\n\t\t\t\t VM_PFNMAP   | VM_IO      | VM_DONTEXPAND |\n\t\t\t\t VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE |\n\t\t\t\t VM_MIXEDMAP | VM_SAO))\n\t\t\treturn -EINVAL;\n\t\t*vm_flags &= ~VM_HUGEPAGE;\n\t\t*vm_flags |= VM_NOHUGEPAGE;\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "NO_INLINE JsVar *jspeFactorDelete() {\n  JSP_ASSERT_MATCH(LEX_R_DELETE);\n  JsVar *parent = 0;\n  JsVar *a = jspeFactorMember(jspeFactor(), &parent);\n  JsVar *result = 0;\n  if (JSP_SHOULD_EXECUTE) {\n    bool ok = false;\n    if (jsvIsName(a) && !jsvIsNewChild(a)) {\n      if (!parent && jsvIsChild(execInfo.root, a))\n        parent = jsvLockAgain(execInfo.root);\n      if (jsvHasChildren(parent)) {\n        if (jsvIsArray(parent)) {\n          JsVarInt l = jsvGetArrayLength(parent);\n          jsvRemoveChild(parent, a);\n          jsvSetArrayLength(parent, l, false);\n        } else {\n          jsvRemoveChild(parent, a);\n        }\n        ok = true;\n      }\n    }\n    result = jsvNewFromBool(ok);\n  }\n  jsvUnLock2(a, parent);\n  return result;\n}", "target": 1}
{"code": "irc_server_get_prefix_char_for_mode (struct t_irc_server *server, char mode)\n{\n    const char *prefix_chars;\n    int index;\n    if (server)\n    {\n        prefix_chars = irc_server_get_prefix_chars (server);\n        index = irc_server_get_prefix_mode_index (server, mode);\n        if (index >= 0)\n            return prefix_chars[index];\n    }\n    return ' ';\n}", "target": 0}
{"code": "static void ptrace_unfreeze_traced(struct task_struct *task)\n{\n\tif (task->state != __TASK_TRACED)\n\t\treturn;\n\tWARN_ON(!task->ptrace || task->parent != current);\n\tspin_lock_irq(&task->sighand->siglock);\n\tif (__fatal_signal_pending(task))\n\t\twake_up_state(task, __TASK_TRACED);\n\telse\n\t\ttask->state = TASK_TRACED;\n\tspin_unlock_irq(&task->sighand->siglock);\n}", "target": 0}
{"code": "static int update_prepare_order_info(rdpContext* context, ORDER_INFO* orderInfo, UINT32 orderType)\n{\n\tint length = 1;\n\torderInfo->fieldFlags = 0;\n\torderInfo->orderType = orderType;\n\torderInfo->controlFlags = ORDER_STANDARD;\n\torderInfo->controlFlags |= ORDER_TYPE_CHANGE;\n\tlength += 1;\n\tlength += PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType];\n\tlength += update_prepare_bounds(context, orderInfo);\n\treturn length;\n}", "target": 1}
{"code": "void bio_chain(struct bio *bio, struct bio *parent)\n{\n\tBUG_ON(bio->bi_private || bio->bi_end_io);\n\tbio->bi_private = parent;\n\tbio->bi_end_io\t= bio_chain_endio;\n\tbio_inc_remaining(parent);\n}", "target": 0}
{"code": "static void simple_decode_row(x3f_info_t *I, x3f_directory_entry_t *DE,\n                              int bits, int row, int row_stride)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n  x3f_huffman_t *HUF = ID->huffman;\n  if (row*row_stride > ID->data_size - (ID->columns*sizeof(uint32_t)))\n\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  uint32_t *data = (uint32_t *)((unsigned char *)ID->data + row * row_stride);\n  uint16_t c[3] = {0, 0, 0};\n  int col;\n  uint32_t mask = 0;\n  switch (bits)\n  {\n  case 8:\n    mask = 0x0ff;\n    break;\n  case 9:\n    mask = 0x1ff;\n    break;\n  case 10:\n    mask = 0x3ff;\n    break;\n  case 11:\n    mask = 0x7ff;\n    break;\n  case 12:\n    mask = 0xfff;\n    break;\n  default:\n    mask = 0;\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n    break;\n  }\n  for (col = 0; col < ID->columns; col++)\n  {\n    int color;\n    uint32_t val = data[col];\n    for (color = 0; color < 3; color++)\n    {\n      uint16_t c_fix;\n      c[color] += get_simple_diff(HUF, (val >> (color * bits)) & mask);\n      switch (ID->type_format)\n      {\n      case X3F_IMAGE_RAW_HUFFMAN_X530:\n      case X3F_IMAGE_RAW_HUFFMAN_10BIT:\n        c_fix = (int16_t)c[color] > 0 ? c[color] : 0;\n        HUF->x3rgb16.data[3 * (row * ID->columns + col) + color] = c_fix;\n        break;\n      case X3F_IMAGE_THUMB_HUFFMAN:\n        c_fix = (int8_t)c[color] > 0 ? c[color] : 0;\n        HUF->rgb8.data[3 * (row * ID->columns + col) + color] = c_fix;\n        break;\n      default:\n        throw LIBRAW_EXCEPTION_IO_CORRUPT;\n      }\n    }\n  }\n}", "target": 0}
{"code": "void streamGetEdgeID(stream *s, int first, int skip_tombstones, streamID *edge_id)\n{\n    streamIterator si;\n    int64_t numfields;\n    streamIteratorStart(&si,s,NULL,NULL,!first);\n    si.skip_tombstones = skip_tombstones;\n    int found = streamIteratorGetID(&si,edge_id,&numfields);\n    if (!found) {\n        streamID min_id = {0, 0}, max_id = {UINT64_MAX, UINT64_MAX};\n        *edge_id = first ? max_id : min_id;\n    }\n}", "target": 1}
{"code": "void WasmBinaryBuilder::readDylink0(size_t payloadLen) {\n  BYN_TRACE(\"== readDylink0\\n\");\n  auto sectionPos = pos;\n  uint32_t lastType = 0;\n  wasm.dylinkSection = make_unique<DylinkSection>();\n  while (pos < sectionPos + payloadLen) {\n    auto oldPos = pos;\n    auto dylinkType = getU32LEB();\n    if (lastType && dylinkType <= lastType) {\n      std::cerr << \"warning: out-of-order dylink.0 subsection: \" << dylinkType\n                << std::endl;\n    }\n    lastType = dylinkType;\n    auto subsectionSize = getU32LEB();\n    auto subsectionPos = pos;\n    if (dylinkType == BinaryConsts::UserSections::Subsection::DylinkMemInfo) {\n      wasm.dylinkSection->memorySize = getU32LEB();\n      wasm.dylinkSection->memoryAlignment = getU32LEB();\n      wasm.dylinkSection->tableSize = getU32LEB();\n      wasm.dylinkSection->tableAlignment = getU32LEB();\n    } else if (dylinkType ==\n               BinaryConsts::UserSections::Subsection::DylinkNeeded) {\n      size_t numNeededDynlibs = getU32LEB();\n      for (size_t i = 0; i < numNeededDynlibs; ++i) {\n        wasm.dylinkSection->neededDynlibs.push_back(getInlineString());\n      }\n    } else {\n      pos = oldPos;\n      size_t remaining = (sectionPos + payloadLen) - pos;\n      auto tail = getByteView(remaining);\n      wasm.dylinkSection->tail = {tail.first, tail.second};\n      break;\n    }\n    if (pos != subsectionPos + subsectionSize) {\n      throwError(\"bad dylink.0 subsection position change\");\n    }\n  }\n}", "target": 0}
{"code": "crm_send_remote_msg(void *session, xmlNode * msg, gboolean encrypted)\n{\n    if (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        cib_send_tls(session, msg);\n#else\n        CRM_ASSERT(encrypted == FALSE);\n#endif\n    } else {\n        cib_send_plaintext(GPOINTER_TO_INT(session), msg);\n    }\n}", "target": 1}
{"code": "void Filter::onUpstreamEvent(Network::ConnectionEvent event) {\n  bool connecting = connecting_;\n  connecting_ = false;\n  if (event == Network::ConnectionEvent::RemoteClose ||\n      event == Network::ConnectionEvent::LocalClose) {\n    upstream_.reset();\n    disableIdleTimer();\n    if (connecting) {\n      if (event == Network::ConnectionEvent::RemoteClose) {\n        getStreamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamConnectionFailure);\n        read_callbacks_->upstreamHost()->outlierDetector().putResult(\n            Upstream::Outlier::Result::LocalOriginConnectFailed);\n      }\n      initializeUpstreamConnection();\n    } else {\n      if (read_callbacks_->connection().state() == Network::Connection::State::Open) {\n        read_callbacks_->connection().close(Network::ConnectionCloseType::FlushWrite);\n      }\n    }\n  }\n}", "target": 1}
{"code": "static inline u32 nla_get_u32(struct nlattr *nla)\n{\n\treturn *(u32 *) nla_data(nla);\n}", "target": 0}
{"code": "rb_iter_peek(struct ring_buffer_iter *iter, u64 *ts)\n{\n\tstruct trace_buffer *buffer;\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tstruct ring_buffer_event *event;\n\tint nr_loops = 0;\n\tif (ts)\n\t\t*ts = 0;\n\tcpu_buffer = iter->cpu_buffer;\n\tbuffer = cpu_buffer->buffer;\n\tif (unlikely(iter->cache_read != cpu_buffer->read ||\n\t\t     iter->cache_reader_page != cpu_buffer->reader_page))\n\t\trb_iter_reset(iter);\n again:\n\tif (ring_buffer_iter_empty(iter))\n\t\treturn NULL;\n\tif (++nr_loops > 3)\n\t\treturn NULL;\n\tif (rb_per_cpu_empty(cpu_buffer))\n\t\treturn NULL;\n\tif (iter->head >= rb_page_size(iter->head_page)) {\n\t\trb_inc_iter(iter);\n\t\tgoto again;\n\t}\n\tevent = rb_iter_head_event(iter);\n\tif (!event)\n\t\tgoto again;\n\tswitch (event->type_len) {\n\tcase RINGBUF_TYPE_PADDING:\n\t\tif (rb_null_event(event)) {\n\t\t\trb_inc_iter(iter);\n\t\t\tgoto again;\n\t\t}\n\t\trb_advance_iter(iter);\n\t\treturn event;\n\tcase RINGBUF_TYPE_TIME_EXTEND:\n\t\trb_advance_iter(iter);\n\t\tgoto again;\n\tcase RINGBUF_TYPE_TIME_STAMP:\n\t\tif (ts) {\n\t\t\t*ts = rb_event_time_stamp(event);\n\t\t\tring_buffer_normalize_time_stamp(cpu_buffer->buffer,\n\t\t\t\t\t\t\t cpu_buffer->cpu, ts);\n\t\t}\n\t\trb_advance_iter(iter);\n\t\tgoto again;\n\tcase RINGBUF_TYPE_DATA:\n\t\tif (ts && !(*ts)) {\n\t\t\t*ts = iter->read_stamp + event->time_delta;\n\t\t\tring_buffer_normalize_time_stamp(buffer,\n\t\t\t\t\t\t\t cpu_buffer->cpu, ts);\n\t\t}\n\t\treturn event;\n\tdefault:\n\t\tRB_WARN_ON(cpu_buffer, 1);\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "static int userfaultfd_release(struct inode *inode, struct file *file)\n{\n\tstruct userfaultfd_ctx *ctx = file->private_data;\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev;\n\tstruct userfaultfd_wake_range range = { .len = 0, };\n\tunsigned long new_flags;\n\tWRITE_ONCE(ctx->released, true);\n\tif (!mmget_not_zero(mm))\n\t\tgoto wakeup;\n\tdown_write(&mm->mmap_sem);\n\tif (!mmget_still_valid(mm))\n\t\tgoto skip_mm;\n\tprev = NULL;\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tcond_resched();\n\t\tBUG_ON(!!vma->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(vma->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\t\tif (vma->vm_userfaultfd_ctx.ctx != ctx) {\n\t\t\tprev = vma;\n\t\t\tcontinue;\n\t\t}\n\t\tnew_flags = vma->vm_flags & ~(VM_UFFD_MISSING | VM_UFFD_WP);\n\t\tprev = vma_merge(mm, prev, vma->vm_start, vma->vm_end,\n\t\t\t\t new_flags, vma->anon_vma,\n\t\t\t\t vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t NULL_VM_UFFD_CTX);\n\t\tif (prev)\n\t\t\tvma = prev;\n\t\telse\n\t\t\tprev = vma;\n\t\tvma->vm_flags = new_flags;\n\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\t}\nskip_mm:\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\nwakeup:\n\tspin_lock(&ctx->fault_pending_wqh.lock);\n\t__wake_up_locked_key(&ctx->fault_pending_wqh, TASK_NORMAL, &range);\n\t__wake_up(&ctx->fault_wqh, TASK_NORMAL, 1, &range);\n\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\twake_up_all(&ctx->event_wqh);\n\twake_up_poll(&ctx->fd_wqh, EPOLLHUP);\n\tuserfaultfd_ctx_put(ctx);\n\treturn 0;\n}", "target": 0}
{"code": "juniper_mfr_print(netdissect_options *ndo,\n                  const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        memset(&l2info, 0, sizeof(l2info));\n        l2info.pictype = DLT_JUNIPER_MFR;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        if (l2info.cookie_len == 0) {\n            mfr_print(ndo, p, l2info.length);\n            return l2info.header_len;\n        }\n        if (l2info.cookie_len == AS_PIC_COOKIE_LEN) {\n            switch(l2info.proto) {\n            case JUNIPER_LSQ_L3_PROTO_IPV4:\n                ip_print(ndo, p, l2info.length);\n                return l2info.header_len;\n            case JUNIPER_LSQ_L3_PROTO_IPV6:\n                ip6_print(ndo, p,l2info.length);\n                return l2info.header_len;\n            case JUNIPER_LSQ_L3_PROTO_MPLS:\n                mpls_print(ndo, p, l2info.length);\n                return l2info.header_len;\n            case JUNIPER_LSQ_L3_PROTO_ISO:\n                isoclns_print(ndo, p, l2info.length, l2info.caplen);\n                return l2info.header_len;\n            default:\n                break;\n            }\n            return l2info.header_len;\n        }\n        if (ndo->ndo_eflag && EXTRACT_32BITS(l2info.cookie) != 1)\n            ND_PRINT((ndo, \"Bundle-ID %u, \", l2info.bundle));\n        switch (l2info.proto) {\n        case (LLCSAP_ISONS<<8 | LLCSAP_ISONS):\n            isoclns_print(ndo, p + 1, l2info.length - 1, l2info.caplen - 1);\n            break;\n        case (LLC_UI<<8 | NLPID_Q933):\n        case (LLC_UI<<8 | NLPID_IP):\n        case (LLC_UI<<8 | NLPID_IP6):\n            isoclns_print(ndo, p - 1, l2info.length + 1, l2info.caplen + 1);\n            break;\n        default:\n            ND_PRINT((ndo, \"unknown protocol 0x%04x, length %u\", l2info.proto, l2info.length));\n        }\n        return l2info.header_len;\n}", "target": 1}
{"code": "smb_flush_file(struct smb_request *sr, struct smb_ofile *ofile)\n{\n\tsr->user_cr = smb_ofile_getcred(ofile);\n\tif ((ofile->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n\t\t(void) smb_fsop_commit(sr, sr->user_cr, ofile->f_node);\n}", "target": 1}
{"code": "static void buffer_pipe_buf_get(struct pipe_inode_info *pipe,\n\t\t\t\tstruct pipe_buffer *buf)\n{\n\tstruct buffer_ref *ref = (struct buffer_ref *)buf->private;\n\tref->ref++;\n}", "target": 1}
{"code": "\t\tauto Phase3() -> Local<Value> final {\n\t\t\treturn Boolean::New(Isolate::GetCurrent(), did_set);\n\t\t}", "target": 1}
{"code": "static int stv06xx_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\tint err, packet_size;\n\tintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\n\talt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\n\tif (!alt) {\n\t\tgspca_err(gspca_dev, \"Couldn't get altsetting\\n\");\n\t\treturn -EIO;\n\t}\n\tif (alt->desc.bNumEndpoints < 1)\n\t\treturn -ENODEV;\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\terr = stv06xx_write_bridge(sd, STV_ISO_SIZE_L, packet_size);\n\tif (err < 0)\n\t\treturn err;\n\terr = sd->sensor->start(sd);\n\tif (err < 0)\n\t\tgoto out;\n\terr = stv06xx_write_bridge(sd, STV_ISO_ENABLE, 1);\nout:\n\tif (err < 0)\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Starting stream failed\\n\");\n\telse\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Started streaming\\n\");\n\treturn (err < 0) ? err : 0;\n}", "target": 0}
{"code": "lsquic_qeh_settings (struct qpack_enc_hdl *qeh, unsigned max_table_size,\n             unsigned dyn_table_size, unsigned max_risked_streams, int server)\n{\n    enum lsqpack_enc_opts enc_opts;\n    assert(qeh->qeh_flags & QEH_INITIALIZED);\n    if (qeh->qeh_flags & QEH_HAVE_SETTINGS)\n    {\n        LSQ_WARN(\"settings already set\");\n        return -1;\n    }\n    enc_opts = LSQPACK_ENC_OPT_STAGE_2\n             | (server ? LSQPACK_ENC_OPT_SERVER : 0);\n    qeh->qeh_tsu_sz = sizeof(qeh->qeh_tsu_buf);\n    if (QENC_MIN_DYN_TABLE_SIZE > dyn_table_size)\n        dyn_table_size = 0;\n    if (0 != lsqpack_enc_init(&qeh->qeh_encoder, (void *) qeh->qeh_conn,\n                max_table_size, dyn_table_size, max_risked_streams, enc_opts,\n                qeh->qeh_tsu_buf, &qeh->qeh_tsu_sz))\n    {\n        LSQ_INFO(\"could not initialize QPACK encoder\");\n        return -1;\n    }\n    LSQ_DEBUG(\"%zu-byte post-init TSU\", qeh->qeh_tsu_sz);\n    qeh->qeh_flags |= QEH_HAVE_SETTINGS;\n    qeh->qeh_max_prefix_size =\n                        lsqpack_enc_header_block_prefix_size(&qeh->qeh_encoder);\n    LSQ_DEBUG(\"have settings: max table size=%u; dyn table size=%u; max risked \"\n        \"streams=%u\", max_table_size, dyn_table_size, max_risked_streams);\n    if (qeh->qeh_enc_sm_out)\n        qeh_begin_out(qeh);\n    return 0;\n}", "target": 0}
{"code": " */\nint re_yyget_lineno  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n        if (! YY_CURRENT_BUFFER)\n            return 0;\n    return yylineno;", "target": 1}
{"code": "static char *get_object(\n    FILE         *fp,\n    int           obj_id,\n    const xref_t *xref,\n    size_t       *size,\n    int          *is_stream)\n{\n    static const int    blk_sz = 256;\n    int                 i, total_sz, read_sz, n_blks, search, stream;\n    size_t              obj_sz;\n    char               *c, *data;\n    long                start;\n    const xref_entry_t *entry;\n    if (size)\n      *size = 0;\n    if (is_stream)\n      *is_stream = 0;\n    start = ftell(fp);\n    entry = NULL;\n    for (i=0; i<xref->n_entries; i++)\n      if (xref->entries[i].obj_id == obj_id)\n      {\n          entry = &xref->entries[i];\n          break;\n      }\n    if (!entry)\n      return NULL;\n    fseek(fp, entry->offset, SEEK_SET);\n    obj_sz = 0;    \n    total_sz = 0;  \n    n_blks = 1;\n    data = safe_calloc(blk_sz * n_blks);\n    stream = 0;\n    while ((read_sz = fread(data+total_sz, 1, blk_sz-1, fp)) && !ferror(fp))\n    {\n        total_sz += read_sz;\n        *(data + total_sz) = '\\0';\n        if (total_sz + blk_sz >= (blk_sz * n_blks))\n          data = realloc(data, blk_sz * (++n_blks));\n        if (!data) {\n          ERR(\"Failed to reallocate buffer.\\n\");\n          exit(EXIT_FAILURE);\n        }\n        search = total_sz - read_sz;\n        if (search < 0)\n          search = 0;\n        if ((c = strstr(data + search, \"endobj\")))\n        {\n            *(c + strlen(\"endobj\") + 1) = '\\0';\n            obj_sz = (char *)strstr(data + search, \"endobj\") - (char *)data;\n            obj_sz += strlen(\"endobj\") + 1;\n            break;\n        }\n        else if (strstr(data, \"stream\"))\n          stream = 1;\n    }\n    clearerr(fp);\n    fseek(fp, start, SEEK_SET);\n    if (size) {\n      *size = obj_sz;\n      if (!obj_sz && data) {\n        free(data);\n        data = NULL;\n      }\n    }\n    if (is_stream)\n      *is_stream = stream;\n    return data;\n}", "target": 0}
{"code": "static inline int add_post_vars(zval *arr, post_var_data_t *vars, zend_bool eof TSRMLS_DC)\n{\n\tuint64_t max_vars = PG(max_input_vars);\n\tvars->ptr = vars->str.c;\n\tvars->end = vars->str.c + vars->str.len;\n\twhile (add_post_var(arr, vars, eof TSRMLS_CC)) {\n\t\tif (++vars->cnt > max_vars) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING,\n\t\t\t\t\t\"Input variables exceeded %\" PRIu64 \". \"\n\t\t\t\t\t\"To increase the limit change max_input_vars in php.ini.\",\n\t\t\t\t\tmax_vars);\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\tif (!eof) {\n\t\tmemmove(vars->str.c, vars->ptr, vars->str.len = vars->end - vars->ptr);\n\t}\n\treturn SUCCESS;\n}", "target": 1}
{"code": "static inline void exit_io_context(void)\n{\n}", "target": 1}
{"code": "void *HtpGetTxForH2(void *alstate)\n{\n    HtpState *http_state = (HtpState *)alstate;\n    if (http_state != NULL && http_state->conn != NULL) {\n        size_t txid = htp_list_array_size(http_state->conn->transactions);\n        if (txid > 0) {\n            return htp_list_get(http_state->conn->transactions, txid - 1);\n        }\n    }\n    return NULL;\n}", "target": 1}
{"code": "void PdfXRefStreamParserObject::parseStream(const int64_t wArray[W_ARRAY_SIZE], const vector<int64_t>& indices)\n{\n    for (int64_t lengthSum = 0, i = 0; i < W_ARRAY_SIZE; i++)\n    {\n        if (wArray[i] < 0)\n        {\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef,\n                \"Negative field length in XRef stream\");\n        }\n        if (numeric_limits<int64_t>::max() - lengthSum < wArray[i])\n        {\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef,\n                \"Invalid entry length in XRef stream\");\n        }\n        else\n        {\n            lengthSum += wArray[i];\n        }\n    }\n    const size_t entryLen = static_cast<size_t>(wArray[0] + wArray[1] + wArray[2]);\n    charbuff buffer;\n    this->GetOrCreateStream().CopyTo(buffer);\n    vector<int64_t>::const_iterator it = indices.begin();\n    char* cursor = buffer.data();\n    while (it != indices.end())\n    {\n        int64_t firstObj = *it++;\n        int64_t count = *it++;\n        m_entries->Enlarge(firstObj + count);\n        for (unsigned index = 0; index < (unsigned)count; index++)\n        {\n            if ((size_t)(cursor - buffer.data()) >= buffer.size())\n                PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid count in XRef stream\");\n            unsigned objIndex = (unsigned)firstObj + index;\n            auto& entry = (*m_entries)[objIndex];\n            if (objIndex < m_entries->GetSize() && !entry.Parsed)\n                readXRefStreamEntry(entry, cursor, wArray);\n            cursor += entryLen;\n        }\n    }\n}", "target": 1}
{"code": "gss_wrap( OM_uint32 *minor_status,\n          gss_ctx_id_t context_handle,\n          int conf_req_flag,\n          gss_qop_t qop_req,\n          gss_buffer_t input_message_buffer,\n          int *conf_state,\n          gss_buffer_t output_message_buffer)\n{\n    OM_uint32           status;\n    gss_union_ctx_id_t  ctx;\n    gss_mechanism       mech;\n    status = val_wrap_args(minor_status, context_handle,\n                           conf_req_flag, qop_req,\n                           input_message_buffer, conf_state,\n                           output_message_buffer);\n    if (status != GSS_S_COMPLETE)\n        return (status);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n        return (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech) {\n        if (mech->gss_wrap) {\n            status = mech->gss_wrap(minor_status,\n                                    ctx->internal_ctx_id,\n                                    conf_req_flag,\n                                    qop_req,\n                                    input_message_buffer,\n                                    conf_state,\n                                    output_message_buffer);\n            if (status != GSS_S_COMPLETE)\n                map_error(minor_status, mech);\n        } else if (mech->gss_wrap_aead ||\n                   (mech->gss_wrap_iov && mech->gss_wrap_iov_length)) {\n            status = gssint_wrap_aead(mech,\n                                      minor_status,\n                                      ctx,\n                                      conf_req_flag,\n                                      (gss_qop_t)qop_req,\n                                      GSS_C_NO_BUFFER,\n                                      input_message_buffer,\n                                      conf_state,\n                                      output_message_buffer);\n        } else\n            status = GSS_S_UNAVAILABLE;\n        return(status);\n    }\n    return (GSS_S_BAD_MECH);\n}", "target": 0}
{"code": "dequeue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int sleep)\n{\n\tupdate_curr(cfs_rq);\n\tupdate_stats_dequeue(cfs_rq, se);\n\tif (sleep) {\n#ifdef CONFIG_SCHEDSTATS\n\t\tif (entity_is_task(se)) {\n\t\t\tstruct task_struct *tsk = task_of(se);\n\t\t\tif (tsk->state & TASK_INTERRUPTIBLE)\n\t\t\t\tse->sleep_start = rq_of(cfs_rq)->clock;\n\t\t\tif (tsk->state & TASK_UNINTERRUPTIBLE)\n\t\t\t\tse->block_start = rq_of(cfs_rq)->clock;\n\t\t}\n#endif\n\t}\n\tif (se != cfs_rq->curr)\n\t\t__dequeue_entity(cfs_rq, se);\n\taccount_entity_dequeue(cfs_rq, se);\n}", "target": 0}
{"code": "static void ext4_invalidatepage(struct page *page, unsigned long offset)\n{\n\tjournal_t *journal = EXT4_JOURNAL(page->mapping->host);\n\tif (ext4_should_dioread_nolock(page->mapping->host))\n\t\text4_invalidatepage_free_endio(page, offset);\n\tif (offset == 0)\n\t\tClearPageChecked(page);\n\tif (journal)\n\t\tjbd2_journal_invalidatepage(journal, page, offset);\n\telse\n\t\tblock_invalidatepage(page, offset);\n}", "target": 0}
{"code": "sshkey_load_file(int fd, struct sshbuf *blob)\n{\n\tu_char buf[1024];\n\tsize_t len;\n\tstruct stat st;\n\tint r;\n\tif (fstat(fd, &st) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size > MAX_KEY_FILE_SIZE)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tfor (;;) {\n\t\tif ((len = atomicio(read, fd, buf, sizeof(buf))) == 0) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tbreak;\n\t\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put(blob, buf, len)) != 0)\n\t\t\tgoto out;\n\t\tif (sshbuf_len(blob) > MAX_KEY_FILE_SIZE) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size != (off_t)sshbuf_len(blob)) {\n\t\tr = SSH_ERR_FILE_CHANGED;\n\t\tgoto out;\n\t}\n\tr = 0;\n out:\n\texplicit_bzero(buf, sizeof(buf));\n\tif (r != 0)\n\t\tsshbuf_reset(blob);\n\treturn r;\n}", "target": 1}
{"code": "  static void setAppend(SetType& set, const VariantType& v) {\n    auto value_type = type(v);\n    if (value_type != HPHP::serialize::Type::INT64 &&\n        value_type != HPHP::serialize::Type::STRING) {\n      throw HPHP::serialize::UnserializeError(\n          \"Unsupported keyset element of type \" +\n          folly::to<std::string>(value_type));\n    }\n    set.append(v);\n  }", "target": 1}
{"code": "void unbind_ports(void) {\n    SERVICE_OPTIONS *opt;\n    s_poll_init(fds, 1);\n    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_SECTIONS]);\n    opt=service_options.next;\n    service_options.next=NULL;\n    service_free(&service_options);\n    while(opt) {\n        unsigned i;\n        s_log(LOG_DEBUG, \"Unbinding service [%s]\", opt->servname);\n        for(i=0; i<opt->local_addr.num; ++i)\n            unbind_port(opt, i);\n        if(opt->exec_name && opt->connect_addr.names) {\n            opt->option.retry=0;\n        }\n        if(opt->ctx)\n            SSL_CTX_flush_sessions(opt->ctx,\n                (long)time(NULL)+opt->session_timeout+1);\n        s_log(LOG_DEBUG, \"Service [%s] closed\", opt->servname);\n        {\n            SERVICE_OPTIONS *garbage=opt;\n            opt=opt->next;\n            garbage->next=NULL;\n            service_free(garbage);\n        }\n    }\n    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_SECTIONS]);\n}", "target": 1}
{"code": "  void readStructEnd() {\n    lastFieldId_ = nestedStructFieldIds_.back();\n    nestedStructFieldIds_.pop_back();\n  }", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const TensorShape& input_shape = input.shape();\n    const Tensor& out_backprop = context->input(2);\n    const TensorShape& out_backprop_shape = out_backprop.shape();\n    TensorShape filter_shape;\n    if (takes_shape_) {\n      const Tensor& filter_sizes = context->input(1);\n      OP_REQUIRES_OK(context, TensorShapeUtils::MakeShape(\n                                  filter_sizes.vec<int32>(), &filter_shape));\n    } else {\n      filter_shape = context->input(1).shape();\n    }\n    OP_REQUIRES(\n        context, input_shape.dim_size(4) == filter_shape.dim_size(3),\n        errors::InvalidArgument(\"input and filter_sizes must have the same \"\n                                \"number of channels. Got \",\n                                input_shape.dim_size(4), \" for input and \",\n                                filter_shape.dim_size(3), \" for filter_sizes\"));\n    OP_REQUIRES(\n        context, out_backprop_shape.dim_size(4) == filter_shape.dim_size(4),\n        errors::InvalidArgument(\"out_backprop and filter_sizes must have the \"\n                                \"same number of channels. Got \",\n                                out_backprop_shape.dim_size(4),\n                                \" for out_backprop and \",\n                                filter_shape.dim_size(4), \" for filter_sizes\"));\n    ConvBackpropDimensions dims;\n    OP_REQUIRES_OK(context,\n                   ConvBackpropComputeDimensions(\n                       \"Conv3DBackpropFilterOp\", 3,\n                       input_shape, filter_shape, out_backprop_shape, stride_,\n                       padding_, data_format_, &dims));\n    Tensor* filter_backprop;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, filter_shape, &filter_backprop));\n    if (input_shape.num_elements() == 0) {\n      filter_backprop->template flat<T>().setZero();\n      return;\n    }\n    functor::CuboidConvolutionBackwardFilter<Device, T>()(\n        context->eigen_device<Device>(),\n        filter_backprop->tensor<T, 5>(),                 \n        input.tensor<T, 5>(),                            \n        out_backprop.tensor<T, 5>(),                     \n        static_cast<int>(dims.spatial_dims[0].stride),   \n        static_cast<int>(dims.spatial_dims[1].stride),   \n        static_cast<int>(dims.spatial_dims[2].stride));  \n  }", "target": 0}
{"code": "R_API int r_io_bank_write_to_submap_at(RIO *io, const ut32 bankid, ut64 addr, const ut8 *buf, int len) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, -1);\n\tif (!len) {\n\t\treturn 0;\n\t}\n\tRRBNode *node;\n\tif (bank->last_used && r_io_submap_contain (((RIOSubMap *)bank->last_used->data), addr)) {\n\t\tnode = bank->last_used;\n\t} else {\n\t\tnode = r_crbtree_find_node (bank->submaps, &addr, _find_sm_by_vaddr_cb, NULL);\n\t\tif (!node) {\n\t\t\treturn 0;\n\t\t}\n\t\tbank->last_used = node;\n\t}\n\tRIOSubMap *sm = (RIOSubMap *)node->data;\n\tif (!r_io_submap_contain (sm, addr)) {\n\t\treturn 0;\n\t}\n\tRIOMap *map = r_io_map_get_by_ref (io, &sm->mapref);\n\tif (!map || !(map->perm & R_PERM_W)) {\n\t\treturn -1;\n\t}\n\tconst int write_len = R_MIN (len, r_io_submap_to (sm) - addr + 1);\n\tconst ut64 paddr = addr - r_io_map_from (map) + map->delta;\n\treturn r_io_fd_write_at (io, map->fd, paddr, buf, write_len);\n}", "target": 0}
{"code": "void Polygon::Insert( sal_uInt16 nPos, const Point& rPt )\n{\n    ImplMakeUnique();\n    if( nPos >= mpImplPolygon->mnPoints )\n        nPos = mpImplPolygon->mnPoints;\n    mpImplPolygon->ImplSplit( nPos, 1 );\n    mpImplPolygon->mpPointAry[ nPos ] = rPt;\n}", "target": 1}
{"code": "static int muscle_restore_security_env(sc_card_t *card, int se_num)\n{\n\tmuscle_private_t* priv = MUSCLE_DATA(card);\n\tmemset(&priv->env, 0, sizeof(priv->env));\n\treturn 0;\n}", "target": 0}
{"code": "        EDP* getEDP() { return &edp_; }", "target": 1}
{"code": "ngx_gmtime(time_t t, ngx_tm_t *tp)\n{\n    ngx_int_t   yday;\n    ngx_uint_t  sec, min, hour, mday, mon, year, wday, days, leap;\n    if (t < 0) {\n        t = 0;\n    }\n    days = t / 86400;\n    sec = t % 86400;\n    if (days > 2932896) {\n        days = 2932896;\n        sec = 86399;\n    }\n    wday = (4 + days) % 7;\n    hour = sec / 3600;\n    sec %= 3600;\n    min = sec / 60;\n    sec %= 60;\n    days = days - (31 + 28) + 719527;\n    year = (days + 2) * 400 / (365 * 400 + 100 - 4 + 1);\n    yday = days - (365 * year + year / 4 - year / 100 + year / 400);\n    if (yday < 0) {\n        leap = (year % 4 == 0) && (year % 100 || (year % 400 == 0));\n        yday = 365 + leap + yday;\n        year--;\n    }\n    mon = (yday + 31) * 10 / 306;\n    mday = yday - (367 * mon / 12 - 30) + 1;\n    if (yday >= 306) {\n        year++;\n        mon -= 10;\n    } else {\n        mon += 2;\n    }\n    tp->ngx_tm_sec = (ngx_tm_sec_t) sec;\n    tp->ngx_tm_min = (ngx_tm_min_t) min;\n    tp->ngx_tm_hour = (ngx_tm_hour_t) hour;\n    tp->ngx_tm_mday = (ngx_tm_mday_t) mday;\n    tp->ngx_tm_mon = (ngx_tm_mon_t) mon;\n    tp->ngx_tm_year = (ngx_tm_year_t) year;\n    tp->ngx_tm_wday = (ngx_tm_wday_t) wday;\n}", "target": 0}
{"code": "sf_flac_write_callback (const FLAC__StreamDecoder * UNUSED (decoder), const FLAC__Frame *frame, const int32_t * const buffer [], void *client_data)\n{\tSF_PRIVATE *psf = (SF_PRIVATE*) client_data ;\n\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\tpflac->frame = frame ;\n\tpflac->bufferpos = 0 ;\n\tpflac->bufferbackup = SF_FALSE ;\n\tpflac->wbuffer = buffer ;\n\tflac_buffer_copy (psf) ;\n\treturn FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE ;\n} ", "target": 1}
{"code": "int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)\n{\n\tstruct super_block *sb;\n\tint err;\n\tint rc;\n\tif (!ext4_handle_valid(handle)) {\n\t\text4_put_nojournal(handle);\n\t\treturn 0;\n\t}\n\tif (!handle->h_transaction) {\n\t\terr = jbd2_journal_stop(handle);\n\t\treturn handle->h_err ? handle->h_err : err;\n\t}\n\tsb = handle->h_transaction->t_journal->j_private;\n\terr = handle->h_err;\n\trc = jbd2_journal_stop(handle);\n\tif (!err)\n\t\terr = rc;\n\tif (err)\n\t\t__ext4_std_error(sb, where, line, err);\n\treturn err;\n}", "target": 1}
{"code": "order_notification_deltas(struct rdr_notification_ctx *ctx)\n{\n\tstruct delta_head **ptr;\n\tarray_index i;\n\tint error;\n\terror = deltas_head_set_size(ctx->notification->deltas_list,\n\t    ctx->deltas.len);\n\tif (error)\n\t\treturn error;\n\tARRAYLIST_FOREACH(&ctx->deltas, ptr, i) {\n\t\terror = deltas_head_add(ctx->notification->deltas_list,\n\t\t    ctx->notification->global_data.serial,\n\t\t    (*ptr)->serial,\n\t\t    (*ptr)->doc_data.uri,\n\t\t    (*ptr)->doc_data.hash,\n\t\t    (*ptr)->doc_data.hash_len);\n\t\tif (!error)\n\t\t\tcontinue;\n\t\tif (error == -EINVAL)\n\t\t\treturn pr_val_err(\"Serial '%lu' at delta elements isn't part of a contiguous list of serials.\",\n\t\t\t    (*ptr)->serial);\n\t\tif (error == -EEXIST)\n\t\t\treturn pr_val_err(\"Duplicated serial '%lu' at delta elements.\",\n\t\t\t    (*ptr)->serial);\n\t\treturn error;\n\t}\n\tif (!deltas_head_values_set(ctx->notification->deltas_list))\n\t\treturn pr_val_err(\"Deltas listed don't have a contiguous sequence of serial numbers\");\n\treturn 0;\n}", "target": 1}
{"code": "__attribute__((__always_inline__)) static inline int send_icmp4_too_big(\n    struct xdp_md* xdp) {\n  int headroom = (int)sizeof(struct iphdr) + (int)sizeof(struct icmphdr);\n  if (bpf_xdp_adjust_head(xdp, 0 - headroom)) {\n    return XDP_DROP;\n  }\n  void* data = (void*)(long)xdp->data;\n  void* data_end = (void*)(long)xdp->data_end;\n  if (data + (ICMP_TOOBIG_SIZE + headroom) > data_end) {\n    return XDP_DROP;\n  }\n  struct iphdr *iph, *orig_iph;\n  struct ethhdr* orig_eth;\n  struct icmphdr* icmp_hdr;\n  __u64 csum = 0;\n  __u64 off = 0;\n  orig_eth = data + headroom;\n  swap_mac(data, orig_eth);\n  off += sizeof(struct ethhdr);\n  iph = data + off;\n  off += sizeof(struct iphdr);\n  icmp_hdr = data + off;\n  off += sizeof(struct icmphdr);\n  orig_iph = data + off;\n  icmp_hdr->type = ICMP_DEST_UNREACH;\n  icmp_hdr->code = ICMP_FRAG_NEEDED;\n  icmp_hdr->un.frag.mtu = bpf_htons(MAX_PCKT_SIZE - sizeof(struct ethhdr));\n  icmp_hdr->un.frag.__unused = 0;\n  icmp_hdr->checksum = 0;\n  ipv4_csum(icmp_hdr, ICMP_TOOBIG_PAYLOAD_SIZE, &csum);\n  icmp_hdr->checksum = csum;\n  iph->ttl = DEFAULT_TTL;\n  iph->daddr = orig_iph->saddr;\n  iph->saddr = orig_iph->daddr;\n  iph->frag_off = 0;\n  iph->version = 4;\n  iph->ihl = 5;\n  iph->protocol = IPPROTO_ICMP;\n  iph->tos = 0;\n  iph->tot_len = bpf_htons(ICMP_TOOBIG_SIZE + headroom - sizeof(struct ethhdr));\n  iph->id = 0;\n  iph->check = 0;\n  csum = 0;\n  ipv4_csum(iph, sizeof(struct iphdr), &csum);\n  iph->check = csum;\n  return XDP_TX;\n}", "target": 0}
{"code": "static void adpt_release(adpt_hba *pHba)\n{\n\tstruct Scsi_Host *shost = pHba->host;\n\tscsi_remove_host(shost);\n\tadpt_i2o_delete_hba(pHba);\n\tscsi_host_put(shost);\n}", "target": 1}
{"code": "static UINT ExtractRunLengthMegaMega(const BYTE* pbOrderHdr, const BYTE* pbEnd, UINT32* advance)\n{\n\tUINT runLength = 0;\n\tWINPR_ASSERT(pbOrderHdr);\n\tWINPR_ASSERT(pbEnd);\n\tWINPR_ASSERT(advance);\n\tif (!buffer_within_range(pbOrderHdr, 2, pbEnd))\n\t{\n\t\t*advance = 0;\n\t\treturn 0;\n\t}\n\trunLength = ((UINT16)pbOrderHdr[1]) | (((UINT16)pbOrderHdr[2]) << 8);\n\t(*advance) += 2;\n\treturn runLength;\n}", "target": 1}
{"code": "static inline void SMTPTransactionComplete(SMTPState *state)\n{\n    DEBUG_VALIDATE_BUG_ON(state->curr_tx == NULL);\n    if (state->curr_tx)\n        state->curr_tx->done = 1;\n}", "target": 1}
{"code": "pci_populate_msixcap(struct msixcap *msixcap, int msgnum, int barnum,\n\t\t     uint32_t msix_tab_size)\n{\n\tassert(msix_tab_size % 4096 == 0);\n\tbzero(msixcap, sizeof(struct msixcap));\n\tmsixcap->capid = PCIY_MSIX;\n\tmsixcap->msgctrl = msgnum - 1;\n\tmsixcap->table_info = barnum & PCIM_MSIX_BIR_MASK;\n\tmsixcap->pba_info = msix_tab_size | (barnum & PCIM_MSIX_BIR_MASK);\n}", "target": 1}
{"code": "void net_tx_pkt_update_ip_hdr_checksum(struct NetTxPkt *pkt)\n{\n    uint16_t csum;\n    assert(pkt);\n    struct ip_header *ip_hdr;\n    ip_hdr = pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base;\n    ip_hdr->ip_len = cpu_to_be16(pkt->payload_len +\n        pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len);\n    ip_hdr->ip_sum = 0;\n    csum = net_raw_checksum((uint8_t *)ip_hdr,\n        pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len);\n    ip_hdr->ip_sum = cpu_to_be16(csum);\n}", "target": 0}
{"code": "void update_process_times(int user_tick)\n{\n\tstruct task_struct *p = current;\n\taccount_process_tick(p, user_tick);\n\trun_local_timers();\n\trcu_sched_clock_irq(user_tick);\n#ifdef CONFIG_IRQ_WORK\n\tif (in_irq())\n\t\tirq_work_tick();\n#endif\n\tscheduler_tick();\n\tif (IS_ENABLED(CONFIG_POSIX_TIMERS))\n\t\trun_posix_cpu_timers();\n\tthis_cpu_add(net_rand_state.s1, rol32(jiffies, 24) + user_tick);\n}", "target": 0}
{"code": "static void validate_set_si_mode(struct bnx2x *bp)\n{\n\tu8 func = BP_ABS_FUNC(bp);\n\tu32 val;\n\tval = MF_CFG_RD(bp, func_mf_config[func].mac_upper);\n\tif (val != 0xffff) {\n\t\tbp->mf_mode = MULTI_FUNCTION_SI;\n\t\tbp->mf_config[BP_VN(bp)] =\n\t\t\tMF_CFG_RD(bp, func_mf_config[func].config);\n\t} else\n\t\tBNX2X_DEV_INFO(\"illegal MAC address for SI\\n\");\n}", "target": 0}
{"code": "vmxnet3_rq_cleanup(struct vmxnet3_rx_queue *rq,\n\t\t   struct vmxnet3_adapter *adapter)\n{\n\tu32 i, ring_idx;\n\tstruct Vmxnet3_RxDesc *rxd;\n\tif (!rq->rx_ring[0].base)\n\t\treturn;\n\tfor (ring_idx = 0; ring_idx < 2; ring_idx++) {\n\t\tfor (i = 0; i < rq->rx_ring[ring_idx].size; i++) {\n#ifdef __BIG_ENDIAN_BITFIELD\n\t\t\tstruct Vmxnet3_RxDesc rxDesc;\n#endif\n\t\t\tvmxnet3_getRxDesc(rxd,\n\t\t\t\t&rq->rx_ring[ring_idx].base[i].rxd, &rxDesc);\n\t\t\tif (rxd->btype == VMXNET3_RXD_BTYPE_HEAD &&\n\t\t\t\t\trq->buf_info[ring_idx][i].skb) {\n\t\t\t\tdma_unmap_single(&adapter->pdev->dev, rxd->addr,\n\t\t\t\t\t\t rxd->len, DMA_FROM_DEVICE);\n\t\t\t\tdev_kfree_skb(rq->buf_info[ring_idx][i].skb);\n\t\t\t\trq->buf_info[ring_idx][i].skb = NULL;\n\t\t\t} else if (rxd->btype == VMXNET3_RXD_BTYPE_BODY &&\n\t\t\t\t\trq->buf_info[ring_idx][i].page) {\n\t\t\t\tdma_unmap_page(&adapter->pdev->dev, rxd->addr,\n\t\t\t\t\t       rxd->len, DMA_FROM_DEVICE);\n\t\t\t\tput_page(rq->buf_info[ring_idx][i].page);\n\t\t\t\trq->buf_info[ring_idx][i].page = NULL;\n\t\t\t}\n\t\t}\n\t\trq->rx_ring[ring_idx].gen = VMXNET3_INIT_GEN;\n\t\trq->rx_ring[ring_idx].next2fill =\n\t\t\t\t\trq->rx_ring[ring_idx].next2comp = 0;\n\t}\n\trq->comp_ring.gen = VMXNET3_INIT_GEN;\n\trq->comp_ring.next2proc = 0;\n}", "target": 0}
{"code": "recv_fd (const int sock)\n{\n  struct msghdr msg = {0};\n  union\n    {\n      struct cmsghdr hdr;\n      char buf[CMSG_SPACE(sizeof(int))];\n    } cmsgbuf = {0};\n  struct cmsghdr *cmsg;\n  struct iovec vec;\n  ssize_t n;\n  char ch = '\\0';\n  int fd = -1;\n  vec.iov_base = &ch;\n  vec.iov_len = 1;\n  msg.msg_iov = &vec;\n  msg.msg_iovlen = 1;\n  msg.msg_control = &cmsgbuf.buf;\n  msg.msg_controllen = sizeof (cmsgbuf.buf);\n  while ((n = recvmsg (sock, &msg, 0)) == -1 && errno == EINTR);\n  if (n != 1 || ch != 'A')\n    return -1;\n  cmsg = CMSG_FIRSTHDR (&msg);\n  if (cmsg == NULL)\n    return -1;\n  if (cmsg->cmsg_type != SCM_RIGHTS)\n    return -1;\n  memcpy (&fd, CMSG_DATA (cmsg), sizeof (fd));\n  if (fd < 0)\n    return -1;\n  return fd;\n}", "target": 0}
{"code": "int32_t CxImage::GetSize()\n{\n\treturn head.biSize + head.biSizeImage + GetPaletteSize();\n}", "target": 1}
{"code": "_PUBLIC_ char **file_lines_load(const char *fname, int *numlines, size_t maxsize, TALLOC_CTX *mem_ctx)\n{\n\tchar *p;\n\tsize_t size;\n\tp = file_load(fname, &size, maxsize, mem_ctx);\n\tif (!p) return NULL;\n\treturn file_lines_parse(p, size, numlines, mem_ctx);\n}", "target": 0}
{"code": "static void do_free_publickey(struct ecc_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\tcrypto_bignum_free(s->x);\n\tcrypto_bignum_free(s->y);\n}", "target": 1}
{"code": "static int persistent_prepare_exception(struct dm_exception_store *store,\n\t\t\t\t\tstruct dm_exception *e)\n{\n\tstruct pstore *ps = get_info(store);\n\tuint32_t stride;\n\tchunk_t next_free;\n\tsector_t size = get_dev_size(dm_snap_cow(store->snap)->bdev);\n\tif (size < ((ps->next_free + 1) * store->chunk_size))\n\t\treturn -ENOSPC;\n\te->new_chunk = ps->next_free;\n\tstride = (ps->exceptions_per_area + 1);\n\tnext_free = ++ps->next_free;\n\tif (sector_div(next_free, stride) == 1)\n\t\tps->next_free++;\n\tatomic_inc(&ps->pending_count);\n\treturn 0;\n}", "target": 1}
{"code": "void *UntrustedCacheMalloc::GetBuffer() {\n  void **buffers = nullptr;\n  void *buffer;\n  bool is_pool_empty;\n  {\n    LockGuard spin_lock(&lock_);\n    is_pool_empty = buffer_pool_.empty();\n    if (is_pool_empty) {\n      buffers =\n          primitives::AllocateUntrustedBuffers(kPoolIncrement, kPoolEntrySize);\n      for (int i = 0; i < kPoolIncrement; i++) {\n        if (!buffers[i] ||\n            !TrustedPrimitives::IsOutsideEnclave(buffers[i], kPoolEntrySize)) {\n          abort();\n        }\n        buffer_pool_.push(buffers[i]);\n      }\n    }\n    buffer = buffer_pool_.top();\n    buffer_pool_.pop();\n    busy_buffers_.insert(buffer);\n  }\n  if (is_pool_empty) {\n    Free(buffers);\n  }\n  return buffer;\n}", "target": 1}
{"code": "static void copy_fields(const FieldMatchContext *fm, AVFrame *dst,\n                        const AVFrame *src, int field)\n{\n    int plane;\n    for (plane = 0; plane < 4 && src->data[plane]; plane++)\n        av_image_copy_plane(dst->data[plane] + field*dst->linesize[plane], dst->linesize[plane] << 1,\n                            src->data[plane] + field*src->linesize[plane], src->linesize[plane] << 1,\n                            get_width(fm, src, plane), get_height(fm, src, plane) / 2);\n}", "target": 1}
{"code": "nfssvc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_writeargs *args)\n{\n\tunsigned int len, hdr, dlen;\n\tstruct kvec *head = rqstp->rq_arg.head;\n\tint v;\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp++;\t\t\t\t\n\targs->offset = ntohl(*p++);\t\n\tp++;\t\t\t\t\n\tlen = args->len = ntohl(*p++);\n\tif (len > NFSSVC_MAXBLKSIZE_V2)\n\t\treturn 0;\n\thdr = (void*)p - head->iov_base;\n\tif (hdr > head->iov_len)\n\t\treturn 0;\n\tdlen = head->iov_len + rqstp->rq_arg.page_len - hdr;\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = head->iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}", "target": 0}
{"code": "static int intf_start_seq_timer(struct ipmi_smi *intf,\n\t\t\t\tlong       msgid)\n{\n\tint           rv = -ENODEV;\n\tunsigned long flags;\n\tunsigned char seq;\n\tunsigned long seqid;\n\tGET_SEQ_FROM_MSGID(msgid, seq, seqid);\n\tspin_lock_irqsave(&intf->seq_lock, flags);\n\tif ((intf->seq_table[seq].inuse)\n\t\t\t\t&& (intf->seq_table[seq].seqid == seqid)) {\n\t\tstruct seq_table *ent = &intf->seq_table[seq];\n\t\tent->timeout = ent->orig_timeout;\n\t\trv = 0;\n\t}\n\tspin_unlock_irqrestore(&intf->seq_lock, flags);\n\treturn rv;\n}", "target": 0}
{"code": "gopherTimeout(const CommTimeoutCbParams &io)\n{\n    GopherStateData *gopherState = static_cast<GopherStateData *>(io.data);\n    debugs(10, 4, io.conn << \": '\" << gopherState->entry->url() << \"'\" );\n    gopherState->fwd->fail(new ErrorState(ERR_READ_TIMEOUT, Http::scGatewayTimeout, gopherState->fwd->request, gopherState->fwd->al));\n    if (Comm::IsConnOpen(io.conn))\n        io.conn->close();\n}", "target": 1}
{"code": "asmlinkage void bad_mode(struct pt_regs *regs, int reason, unsigned int esr)\n{\n\tconsole_verbose();\n\tpr_crit(\"Bad mode in %s handler detected, code 0x%08x\\n\",\n\t\thandler[reason], esr);\n\tdie(\"Oops - bad mode\", regs, 0);\n\tlocal_irq_disable();\n\tpanic(\"bad mode\");\n}", "target": 1}
{"code": "deltas_head_destroy(struct deltas_head *deltas)\n{\n\tdeltas_head_cleanup(deltas);\n\tfree(deltas);\n}", "target": 1}
{"code": "transientObjectPutErrorMessage(Runtime *runtime, Handle<> base, SymbolID id) {\n  StringView propName =\n      runtime->getIdentifierTable().getStringView(runtime, id);\n  Handle<StringPrimitive> baseType =\n      runtime->makeHandle(vmcast<StringPrimitive>(typeOf(runtime, base)));\n  StringView baseTypeAsString =\n      StringPrimitive::createStringView(runtime, baseType);\n  MutableHandle<StringPrimitive> valueAsString{runtime};\n  if (base->isSymbol()) {\n    auto str = symbolDescriptiveString(runtime, Handle<SymbolID>::vmcast(base));\n    if (str != ExecutionStatus::EXCEPTION) {\n      valueAsString = *str;\n    } else {\n      runtime->clearThrownValue();\n      valueAsString = StringPrimitive::createNoThrow(\n          runtime, \"<<Exception occurred getting the value>>\");\n    }\n  } else {\n    auto str = toString_RJS(runtime, base);\n    assert(\n        str != ExecutionStatus::EXCEPTION &&\n        \"Primitives should be convertible to string without exceptions\");\n    valueAsString = std::move(*str);\n  }\n  StringView valueAsStringPrintable =\n      StringPrimitive::createStringView(runtime, valueAsString);\n  SmallU16String<32> tmp;\n  return runtime->raiseTypeError(\n      TwineChar16(\"Cannot create property '\") + propName + \"' on \" +\n      baseTypeAsString.getUTF16Ref(tmp) + \" '\" +\n      valueAsStringPrintable.getUTF16Ref(tmp) + \"'\");\n}", "target": 1}
{"code": "int write_output(void)\n{\n   int fd;\n   struct filter_op *fop;\n   struct filter_header fh;\n   size_t ninst, i;\n   u_char *data;\n   ninst = compile_tree(&fop);\n   if (fop == NULL)\n      return -E_NOTHANDLED;\n   if (ninst == 0)\n      return -E_INVALID;\n   fd = open(EF_GBL_OPTIONS->output_file, O_CREAT | O_RDWR | O_TRUNC | O_BINARY, 0644);\n   ON_ERROR(fd, -1, \"Can't create file %s\", EF_GBL_OPTIONS->output_file);\n   fprintf(stdout, \" Writing output to \\'%s\\' \", EF_GBL_OPTIONS->output_file);\n   fflush(stdout);\n   fh.magic = htons(EC_FILTER_MAGIC);\n   strncpy(fh.version, EC_VERSION, sizeof(fh.version));\n   fh.data = sizeof(fh);\n   data = create_data_segment(&fh, fop, ninst);\n   write(fd, &fh, sizeof(struct filter_header));\n   write(fd, data, fh.code - fh.data);\n   for (i = 0; i <= ninst; i++) {\n      print_progress_bar(&fop[i]);\n      write(fd, &fop[i], sizeof(struct filter_op));\n   }\n   close(fd);\n   fprintf(stdout, \" done.\\n\\n\");\n   fprintf(stdout, \" -> Script encoded into %d instructions.\\n\\n\", (int)(i - 1));\n   return E_SUCCESS;\n}", "target": 0}
{"code": "    void resize (std::size_t new_size_) { _buf_size = new_size_; }", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor* epsilon_t;\n    OP_REQUIRES_OK(context, context->input(kEpsilonName, &epsilon_t));\n    float epsilon = epsilon_t->scalar<float>()();\n    OP_REQUIRES(\n        context, epsilon > 0,\n        errors::InvalidArgument(\"An epsilon value of zero is not allowed.\"));\n    const Tensor* num_streams_t;\n    OP_REQUIRES_OK(context, context->input(kNumStreamsName, &num_streams_t));\n    int64_t num_streams = num_streams_t->scalar<int64>()();\n    OP_REQUIRES(context, num_streams >= 0,\n                errors::InvalidArgument(\n                    \"Num_streams input cannot be a negative integer\"));\n    auto result =\n        new QuantileStreamResource(epsilon, max_elements_, num_streams);\n    auto status = CreateResource(context, HandleFromInput(context, 0), result);\n    if (!status.ok() && status.code() != tensorflow::error::ALREADY_EXISTS) {\n      OP_REQUIRES(context, false, status);\n    }\n  }", "target": 0}
{"code": "void qemu_ram_free(struct uc_struct *uc, RAMBlock *block)\n{\n    if (!block) {\n        return;\n    }\n    QLIST_REMOVE(block, next);\n    uc->ram_list.mru_block = NULL;\n    reclaim_ramblock(uc, block);\n}", "target": 1}
{"code": "decode_NXAST_RAW_ENCAP(const struct nx_action_encap *nae,\n                       enum ofp_version ofp_version OVS_UNUSED,\n                       struct ofpbuf *out)\n{\n    struct ofpact_encap *encap;\n    const struct ofp_ed_prop_header *ofp_prop;\n    const size_t encap_ofs = out->size;\n    size_t props_len;\n    uint16_t n_props = 0;\n    int err;\n    encap = ofpact_put_ENCAP(out);\n    encap->ofpact.raw = NXAST_RAW_ENCAP;\n    switch (ntohl(nae->new_pkt_type)) {\n    case PT_ETH:\n    case PT_NSH:\n        break;\n    default:\n        return OFPERR_NXBAC_BAD_HEADER_TYPE;\n    }\n    encap->new_pkt_type = nae->new_pkt_type;\n    encap->hdr_size = ntohs(nae->hdr_size);\n    ofp_prop = nae->props;\n    props_len = ntohs(nae->len) - offsetof(struct nx_action_encap, props);\n    n_props = 0;\n    while (props_len > 0) {\n        err = decode_ed_prop(&ofp_prop, out, &props_len);\n        if (err) {\n            return err;\n        }\n        n_props++;\n    }\n    encap = ofpbuf_at_assert(out, encap_ofs, sizeof *encap);\n    encap->n_props = n_props;\n    out->header = &encap->ofpact;\n    ofpact_finish_ENCAP(out, &encap);\n    return 0;\n}", "target": 0}
{"code": "void CUser::SetClientEncoding(const CString& s) {\n    m_sClientEncoding = s;\n    for (CClient* pClient : GetAllClients()) {\n        pClient->SetEncoding(s);\n    }\n}", "target": 1}
{"code": "makeDirTree(const string &path, const StaticString &mode, uid_t owner, gid_t group) {\n\tstruct stat buf;\n\tvector<string> paths;\n\tvector<string>::reverse_iterator rit;\n\tstring current = path;\n\tmode_t modeBits;\n\tint ret;\n\tif (stat(path.c_str(), &buf) == 0) {\n\t\treturn;\n\t}\n\tmodeBits = parseModeString(mode);\n\twhile (current != \"/\" && current != \".\" && getFileType(current) == FT_NONEXISTANT) {\n\t\tpaths.push_back(current);\n\t\tcurrent = extractDirName(current);\n\t}\n\tfor (rit = paths.rbegin(); rit != paths.rend(); rit++) {\n\t\tcurrent = *rit;\n\t\tdo {\n\t\t\tret = mkdir(current.c_str(), modeBits);\n\t\t} while (ret == -1 && errno == EINTR);\n\t\tif (ret == -1) {\n\t\t\tif (errno == EEXIST) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tint e = errno;\n\t\t\t\tthrow FileSystemException(\"Cannot create directory '\" + current + \"'\",\n\t\t\t\t\te, current);\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tret = chmod(current.c_str(), modeBits);\n\t\t} while (ret == -1 && errno == EINTR);\n\t\tif (owner != USER_NOT_GIVEN && group != GROUP_NOT_GIVEN) {\n\t\t\tif (owner == USER_NOT_GIVEN) {\n\t\t\t\towner = (uid_t) -1; \n\t\t\t}\n\t\t\tif (group == GROUP_NOT_GIVEN) {\n\t\t\t\tgroup = (gid_t) -1; \n\t\t\t}\n\t\t\tdo {\n\t\t\t\tret = chown(current.c_str(), owner, group);\n\t\t\t} while (ret == -1 && errno == EINTR);\n\t\t\tif (ret == -1) {\n\t\t\t\tchar message[1024];\n\t\t\t\tint e = errno;\n\t\t\t\tsnprintf(message, sizeof(message) - 1,\n\t\t\t\t\t\"Cannot change the directory '%s' its UID to %lld and GID to %lld\",\n\t\t\t\t\tcurrent.c_str(), (long long) owner, (long long) group);\n\t\t\t\tmessage[sizeof(message) - 1] = '\\0';\n\t\t\t\tthrow FileSystemException(message, e, path);\n\t\t\t}\n\t\t}\n\t}\n}", "target": 0}
{"code": "pf_update_state_timeout(struct pf_state *st, int to)\n{\n\tmtx_enter(&st->mtx);\n\tif (st->timeout != PFTM_UNLINKED)\n\t\tst->timeout = to;\n\tmtx_leave(&st->mtx);\n}", "target": 0}
{"code": "static int decode_user_data(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    char buf[256];\n    int i;\n    int e;\n    int ver = 0, build = 0, ver2 = 0, ver3 = 0;\n    char last;\n    for (i = 0; i < 255 && get_bits_count(gb) < gb->size_in_bits; i++) {\n        if (show_bits(gb, 23) == 0)\n            break;\n        buf[i] = get_bits(gb, 8);\n    }\n    buf[i] = 0;\n    e = sscanf(buf, \"DivX%dBuild%d%c\", &ver, &build, &last);\n    if (e < 2)\n        e = sscanf(buf, \"DivX%db%d%c\", &ver, &build, &last);\n    if (e >= 2) {\n        ctx->divx_version = ver;\n        ctx->divx_build   = build;\n        s->divx_packed  = e == 3 && last == 'p';\n        if (s->divx_packed && !ctx->showed_packed_warning) {\n            av_log(s->avctx, AV_LOG_INFO, \"Video uses a non-standard and \"\n                   \"wasteful way to store B-frames ('packed B-frames'). \"\n                   \"Consider using a tool like VirtualDub or avidemux to fix it.\\n\");\n            ctx->showed_packed_warning = 1;\n        }\n    }\n    e = sscanf(buf, \"FFmpe%*[^b]b%d\", &build) + 3;\n    if (e != 4)\n        e = sscanf(buf, \"FFmpeg v%d.%d.%d / libavcodec build: %d\", &ver, &ver2, &ver3, &build);\n    if (e != 4) {\n        e = sscanf(buf, \"Lavc%d.%d.%d\", &ver, &ver2, &ver3) + 1;\n        if (e > 1)\n            build = (ver << 16) + (ver2 << 8) + ver3;\n    }\n    if (e != 4) {\n        if (strcmp(buf, \"ffmpeg\") == 0)\n            ctx->lavc_build = 4600;\n    }\n    if (e == 4)\n        ctx->lavc_build = build;\n    e = sscanf(buf, \"XviD%d\", &build);\n    if (e == 1)\n        ctx->xvid_build = build;\n    return 0;\n}", "target": 0}
{"code": "static long __snd_timer_user_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct snd_timer_user *tu;\n\tvoid __user *argp = (void __user *)arg;\n\tint __user *p = argp;\n\ttu = file->private_data;\n\tswitch (cmd) {\n\tcase SNDRV_TIMER_IOCTL_PVERSION:\n\t\treturn put_user(SNDRV_TIMER_VERSION, p) ? -EFAULT : 0;\n\tcase SNDRV_TIMER_IOCTL_NEXT_DEVICE:\n\t\treturn snd_timer_user_next_device(argp);\n\tcase SNDRV_TIMER_IOCTL_TREAD:\n\t{\n\t\tint xarg;\n\t\tif (tu->timeri)\t\n\t\t\treturn -EBUSY;\n\t\tif (get_user(xarg, p))\n\t\t\treturn -EFAULT;\n\t\ttu->tread = xarg ? 1 : 0;\n\t\treturn 0;\n\t}\n\tcase SNDRV_TIMER_IOCTL_GINFO:\n\t\treturn snd_timer_user_ginfo(file, argp);\n\tcase SNDRV_TIMER_IOCTL_GPARAMS:\n\t\treturn snd_timer_user_gparams(file, argp);\n\tcase SNDRV_TIMER_IOCTL_GSTATUS:\n\t\treturn snd_timer_user_gstatus(file, argp);\n\tcase SNDRV_TIMER_IOCTL_SELECT:\n\t\treturn snd_timer_user_tselect(file, argp);\n\tcase SNDRV_TIMER_IOCTL_INFO:\n\t\treturn snd_timer_user_info(file, argp);\n\tcase SNDRV_TIMER_IOCTL_PARAMS:\n\t\treturn snd_timer_user_params(file, argp);\n\tcase SNDRV_TIMER_IOCTL_STATUS:\n\t\treturn snd_timer_user_status(file, argp);\n\tcase SNDRV_TIMER_IOCTL_START:\n\tcase SNDRV_TIMER_IOCTL_START_OLD:\n\t\treturn snd_timer_user_start(file);\n\tcase SNDRV_TIMER_IOCTL_STOP:\n\tcase SNDRV_TIMER_IOCTL_STOP_OLD:\n\t\treturn snd_timer_user_stop(file);\n\tcase SNDRV_TIMER_IOCTL_CONTINUE:\n\tcase SNDRV_TIMER_IOCTL_CONTINUE_OLD:\n\t\treturn snd_timer_user_continue(file);\n\tcase SNDRV_TIMER_IOCTL_PAUSE:\n\tcase SNDRV_TIMER_IOCTL_PAUSE_OLD:\n\t\treturn snd_timer_user_pause(file);\n\t}\n\treturn -ENOTTY;\n}", "target": 0}
{"code": "struct tcp_conn_t *tcp_conn_select(struct tcp_sock_t *sock,\n\t\t\t\t   struct tcp_sock_t *sock6)\n{\n\tstruct tcp_conn_t *conn = calloc(1, sizeof *conn);\n\tif (conn == NULL) {\n\t\tERR(\"Calloc for connection struct failed\");\n\t\tgoto error;\n\t}\n\tfd_set rfds;\n\tstruct timeval tv;\n\tint retval = 0;\n\tint nfds = 0;\n\twhile (retval == 0) {\n\t\tFD_ZERO(&rfds);\n\t\tif (sock) {\n\t\t\tFD_SET(sock->sd, &rfds);\n\t\t\tnfds = sock->sd;\n\t\t}\n\t\tif (sock6) {\n\t\t\tFD_SET(sock6->sd, &rfds);\n\t\t\tif (sock6->sd > nfds)\n\t\t\t\tnfds = sock6->sd;\n\t\t}\n\t\tif (nfds == 0) {\n\t\t\tERR(\"No valid TCP socket supplied.\");\n\t\t\tgoto error;\n\t\t}\n\t\tnfds += 1;\n\t\ttv.tv_sec = 5;\n\t\ttv.tv_usec = 0;\n\t\tretval = select(nfds, &rfds, NULL, NULL, &tv);\n\t\tif (retval == -1) {\n\t\t\tERR(\"Failed to open tcp connection\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\tif (sock && FD_ISSET(sock->sd, &rfds)) {\n\t\tconn->sd = accept(sock->sd, NULL, NULL);\n\t\tNOTE (\"Using IPv4\");\n\t} else if (sock6 && FD_ISSET(sock6->sd, &rfds)) {\n\t\tconn->sd = accept(sock6->sd, NULL, NULL);\n\t\tNOTE (\"Using IPv6\");\n\t} else {\n\t\tERR(\"select failed\");\n\t\tgoto error;\n\t}\n\tif (conn->sd < 0) {\n\t\tERR(\"accept failed\");\n\t\tgoto error;\n\t}\n\treturn conn;\nerror:\n\tif (conn != NULL)\n\t\tfree(conn);\n\treturn NULL;\n}", "target": 0}
{"code": "exit_ext2_xattr(void)\n{\n\tmb_cache_destroy(ext2_xattr_cache);\n}", "target": 1}
{"code": "static inline void skb_queue_splice_tail(const struct sk_buff_head *list,\n\t\t\t\t\t struct sk_buff_head *head)\n{\n\tif (!skb_queue_empty(list)) {\n\t\t__skb_queue_splice(list, head->prev, (struct sk_buff *) head);\n\t\thead->qlen += list->qlen;\n\t}\n}", "target": 0}
{"code": "void PrivateThreadPoolDatasetOp::MakeDatasetFromOptions(OpKernelContext* ctx,\n                                                        DatasetBase* input,\n                                                        int32_t num_threads,\n                                                        DatasetBase** output) {\n  OP_REQUIRES(ctx, num_threads >= 0,\n              errors::InvalidArgument(\"`num_threads` must be >= 0\"));\n  *output = new Dataset(ctx,\n                        DatasetContext(DatasetContext::Params(\n                            {PrivateThreadPoolDatasetOp::kDatasetType,\n                             PrivateThreadPoolDatasetOp::kDatasetOp})),\n                        input, num_threads);\n}", "target": 1}
{"code": "acpi_parse_lapic_nmi(acpi_table_entry_header * header, const unsigned long end)\n{\n\tstruct acpi_table_lapic_nmi *lapic_nmi = NULL;\n\tlapic_nmi = (struct acpi_table_lapic_nmi *)header;\n\tif (BAD_MADT_ENTRY(lapic_nmi, end))\n\t\treturn -EINVAL;\n\tacpi_table_print_madt_entry(header);\n\tif (lapic_nmi->lint != 1)\n\t\tprintk(KERN_WARNING PREFIX \"NMI not connected to LINT 1!\\n\");\n\treturn 0;\n}", "target": 0}
{"code": "static void xen_netbk_idx_release(struct xen_netbk *netbk, u16 pending_idx)\n{\n\tstruct xenvif *vif;\n\tstruct pending_tx_info *pending_tx_info;\n\tpending_ring_idx_t index;\n\tif (netbk->mmap_pages[pending_idx] == NULL)\n\t\treturn;\n\tpending_tx_info = &netbk->pending_tx_info[pending_idx];\n\tvif = pending_tx_info->vif;\n\tmake_tx_response(vif, &pending_tx_info->req, XEN_NETIF_RSP_OKAY);\n\tindex = pending_index(netbk->pending_prod++);\n\tnetbk->pending_ring[index] = pending_idx;\n\txenvif_put(vif);\n\tnetbk->mmap_pages[pending_idx]->mapping = 0;\n\tput_page(netbk->mmap_pages[pending_idx]);\n\tnetbk->mmap_pages[pending_idx] = NULL;\n}", "target": 1}
{"code": "acpi_os_install_interrupt_handler(u32 gsi, acpi_osd_handler handler,\n\t\t\t\t  void *context)\n{\n\tunsigned int irq;\n\tacpi_irq_stats_init();\n\tif (gsi != acpi_gbl_FADT.sci_interrupt)\n\t\treturn AE_BAD_PARAMETER;\n\tif (acpi_irq_handler)\n\t\treturn AE_ALREADY_ACQUIRED;\n\tif (acpi_gsi_to_irq(gsi, &irq) < 0) {\n\t\tprintk(KERN_ERR PREFIX \"SCI (ACPI GSI %d) not registered\\n\",\n\t\t       gsi);\n\t\treturn AE_OK;\n\t}\n\tacpi_irq_handler = handler;\n\tacpi_irq_context = context;\n\tif (request_irq(irq, acpi_irq, IRQF_SHARED, \"acpi\", acpi_irq)) {\n\t\tprintk(KERN_ERR PREFIX \"SCI (IRQ%d) allocation failed\\n\", irq);\n\t\tacpi_irq_handler = NULL;\n\t\treturn AE_NOT_ACQUIRED;\n\t}\n\tacpi_sci_irq = irq;\n\treturn AE_OK;\n}", "target": 0}
{"code": "static int __init llc2_init(void)\n{\n\tint rc = proto_register(&llc_proto, 0);\n\tif (rc != 0)\n\t\tgoto out;\n\tllc_build_offset_table();\n\tllc_station_init();\n\tllc_ui_sap_last_autoport = LLC_SAP_DYN_START;\n\trc = llc_proc_init();\n\tif (rc != 0) {\n\t\tprintk(llc_proc_err_msg);\n\t\tgoto out_unregister_llc_proto;\n\t}\n\trc = llc_sysctl_init();\n\tif (rc) {\n\t\tprintk(llc_sysctl_err_msg);\n\t\tgoto out_proc;\n\t}\n\trc = sock_register(&llc_ui_family_ops);\n\tif (rc) {\n\t\tprintk(llc_sock_err_msg);\n\t\tgoto out_sysctl;\n\t}\n\tllc_add_pack(LLC_DEST_SAP, llc_sap_handler);\n\tllc_add_pack(LLC_DEST_CONN, llc_conn_handler);\nout:\n\treturn rc;\nout_sysctl:\n\tllc_sysctl_exit();\nout_proc:\n\tllc_proc_exit();\nout_unregister_llc_proto:\n\tproto_unregister(&llc_proto);\n\tgoto out;\n}", "target": 0}
{"code": "      BigInt multiply_mod_order(const BigInt& x, const BigInt& y, const BigInt& z) const\n         {\n         return m_mod_order.multiply(m_mod_order.multiply(x, y), z);\n         }", "target": 0}
{"code": "void luaT_getvarargs (lua_State *L, CallInfo *ci, StkId where, int wanted) {\n  int i;\n  int nextra = ci->u.l.nextraargs;\n  if (wanted < 0) {\n    wanted = nextra;  \n    checkstackp(L, nextra, where);  \n    L->top = where + nextra;  \n  }\n  for (i = 0; i < wanted && i < nextra; i++)\n    setobjs2s(L, where + i, ci->func - nextra + i);\n  for (; i < wanted; i++)   \n    setnilvalue(s2v(where + i));\n}", "target": 1}
{"code": "static void get_request(GDHCPClient *dhcp_client, struct dhcp_packet *packet,\n\t\tuint16_t packet_len)\n{\n\tGDHCPOptionType type;\n\tGList *list, *value_list;\n\tchar *option_value;\n\tuint8_t *option;\n\tuint8_t code;\n\tfor (list = dhcp_client->request_list; list; list = list->next) {\n\t\tcode = (uint8_t) GPOINTER_TO_INT(list->data);\n\t\toption = dhcp_get_option(packet, packet_len, code);\n\t\tif (!option) {\n\t\t\tg_hash_table_remove(dhcp_client->code_value_hash,\n\t\t\t\t\t\tGINT_TO_POINTER((int) code));\n\t\t\tcontinue;\n\t\t}\n\t\ttype =  dhcp_get_code_type(code);\n\t\toption_value = malloc_option_value_string(option, type);\n\t\tif (!option_value)\n\t\t\tg_hash_table_remove(dhcp_client->code_value_hash,\n\t\t\t\t\t\tGINT_TO_POINTER((int) code));\n\t\tvalue_list = get_option_value_list(option_value, type);\n\t\tg_free(option_value);\n\t\tif (!value_list)\n\t\t\tg_hash_table_remove(dhcp_client->code_value_hash,\n\t\t\t\t\t\tGINT_TO_POINTER((int) code));\n\t\telse\n\t\t\tg_hash_table_insert(dhcp_client->code_value_hash,\n\t\t\t\tGINT_TO_POINTER((int) code), value_list);\n\t}\n}", "target": 0}
{"code": "static int set_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)\n{\n\t__u32 __user *uaddr = (__u32 __user *)(unsigned long)reg->addr;\n\tstruct kvm_regs *regs = vcpu_gp_regs(vcpu);\n\tint nr_regs = sizeof(*regs) / sizeof(__u32);\n\t__uint128_t tmp;\n\tvoid *valp = &tmp;\n\tu64 off;\n\tint err = 0;\n\toff = core_reg_offset_from_id(reg->id);\n\tif (off >= nr_regs ||\n\t    (off + (KVM_REG_SIZE(reg->id) / sizeof(__u32))) >= nr_regs)\n\t\treturn -ENOENT;\n\tif (validate_core_offset(reg))\n\t\treturn -EINVAL;\n\tif (KVM_REG_SIZE(reg->id) > sizeof(tmp))\n\t\treturn -EINVAL;\n\tif (copy_from_user(valp, uaddr, KVM_REG_SIZE(reg->id))) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\tif (off == KVM_REG_ARM_CORE_REG(regs.pstate)) {\n\t\tu32 mode = (*(u32 *)valp) & PSR_AA32_MODE_MASK;\n\t\tswitch (mode) {\n\t\tcase PSR_AA32_MODE_USR:\n\t\tcase PSR_AA32_MODE_FIQ:\n\t\tcase PSR_AA32_MODE_IRQ:\n\t\tcase PSR_AA32_MODE_SVC:\n\t\tcase PSR_AA32_MODE_ABT:\n\t\tcase PSR_AA32_MODE_UND:\n\t\tcase PSR_MODE_EL0t:\n\t\tcase PSR_MODE_EL1t:\n\t\tcase PSR_MODE_EL1h:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmemcpy((u32 *)regs + off, valp, KVM_REG_SIZE(reg->id));\nout:\n\treturn err;\n}", "target": 0}
{"code": "\tvirtual ~CxFile() { };", "target": 1}
{"code": "DRIVE_FILE* drive_file_new(const WCHAR* base_path, const WCHAR* path, UINT32 PathLength, UINT32 id,\n                           UINT32 DesiredAccess, UINT32 CreateDisposition, UINT32 CreateOptions,\n                           UINT32 FileAttributes, UINT32 SharedAccess)\n{\n\tDRIVE_FILE* file;\n\tif (!base_path || (!path && (PathLength > 0)))\n\t\treturn NULL;\n\tfile = (DRIVE_FILE*)calloc(1, sizeof(DRIVE_FILE));\n\tif (!file)\n\t{\n\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\treturn NULL;\n\t}\n\tfile->file_handle = INVALID_HANDLE_VALUE;\n\tfile->find_handle = INVALID_HANDLE_VALUE;\n\tfile->id = id;\n\tfile->basepath = base_path;\n\tfile->FileAttributes = FileAttributes;\n\tfile->DesiredAccess = DesiredAccess;\n\tfile->CreateDisposition = CreateDisposition;\n\tfile->CreateOptions = CreateOptions;\n\tfile->SharedAccess = SharedAccess;\n\tdrive_file_set_fullpath(file, drive_file_combine_fullpath(base_path, path, PathLength));\n\tif (!drive_file_init(file))\n\t{\n\t\tDWORD lastError = GetLastError();\n\t\tdrive_file_free(file);\n\t\tSetLastError(lastError);\n\t\treturn NULL;\n\t}\n\treturn file;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& values_tensor = ctx->input(0);\n    const Tensor& value_range_tensor = ctx->input(1);\n    const Tensor& nbins_tensor = ctx->input(2);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(value_range_tensor.shape()),\n                errors::InvalidArgument(\"value_range should be a vector.\"));\n    OP_REQUIRES(ctx, (value_range_tensor.shape().num_elements() == 2),\n                errors::InvalidArgument(\n                    \"value_range should be a vector of 2 elements.\"));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(nbins_tensor.shape()),\n                errors::InvalidArgument(\"nbins should be a scalar.\"));\n    const auto values = values_tensor.flat<T>();\n    const auto value_range = value_range_tensor.flat<T>();\n    const auto nbins = nbins_tensor.scalar<int32>()();\n    OP_REQUIRES(\n        ctx, (value_range(0) < value_range(1)),\n        errors::InvalidArgument(\"value_range should satisfy value_range[0] < \"\n                                \"value_range[1], but got '[\",\n                                value_range(0), \", \", value_range(1), \"]'\"));\n    OP_REQUIRES(\n        ctx, (nbins > 0),\n        errors::InvalidArgument(\"nbins should be a positive number, but got '\",\n                                nbins, \"'\"));\n    Tensor* out_tensor;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(0, TensorShape({nbins}), &out_tensor));\n    auto out = out_tensor->flat<Tout>();\n    OP_REQUIRES_OK(\n        ctx, functor::HistogramFixedWidthFunctor<Device, T, Tout>::Compute(\n                 ctx, values, value_range, nbins, out));\n  }", "target": 1}
{"code": "static int ext4_dax_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\treturn dax_mkwrite(vma, vmf, ext4_get_block_dax,\n\t\t\t\text4_end_io_unwritten);\n}", "target": 1}
{"code": "Http::FilterTrailersStatus Context::onResponseTrailers() {\n  if (!wasm_->onResponseTrailers_) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  if (wasm_->onResponseTrailers_(this, id_).u64_ == 0) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  return Http::FilterTrailersStatus::StopIteration;\n}", "target": 1}
{"code": "int sas_ex_revalidate_domain(struct domain_device *port_dev)\n{\n\tint res;\n\tstruct domain_device *dev = NULL;\n\tres = sas_find_bcast_dev(port_dev, &dev);\n\twhile (res == 0 && dev) {\n\t\tstruct expander_device *ex = &dev->ex_dev;\n\t\tint i = 0, phy_id;\n\t\tdo {\n\t\t\tphy_id = -1;\n\t\t\tres = sas_find_bcast_phy(dev, &phy_id, i, true);\n\t\t\tif (phy_id == -1)\n\t\t\t\tbreak;\n\t\t\tres = sas_rediscover(dev, phy_id);\n\t\t\ti = phy_id + 1;\n\t\t} while (i < ex->num_phys);\n\t\tdev = NULL;\n\t\tres = sas_find_bcast_dev(port_dev, &dev);\n\t}\n\treturn res;\n}", "target": 1}
{"code": "gimp_write_and_read_file (Gimp     *gimp,\n                          gboolean  with_unusual_stuff,\n                          gboolean  compat_paths,\n                          gboolean  use_gimp_2_8_features)\n{\n  GimpImage           *image;\n  GimpImage           *loaded_image;\n  GimpPlugInProcedure *proc;\n  gchar               *filename;\n  GFile               *file;\n  image = gimp_create_mainimage (gimp,\n                                 with_unusual_stuff,\n                                 compat_paths,\n                                 use_gimp_2_8_features);\n  gimp_assert_mainimage (image,\n                         with_unusual_stuff,\n                         compat_paths,\n                         use_gimp_2_8_features);\n  filename = g_build_filename (g_get_tmp_dir (), \"gimp-test.xcf\", NULL);\n  file = g_file_new_for_path (filename);\n  g_free (filename);\n  proc = gimp_plug_in_manager_file_procedure_find (image->gimp->plug_in_manager,\n                                                   GIMP_FILE_PROCEDURE_GROUP_SAVE,\n                                                   file,\n                                                   NULL );\n  file_save (gimp,\n             image,\n             NULL ,\n             file,\n             proc,\n             GIMP_RUN_NONINTERACTIVE,\n             FALSE ,\n             FALSE ,\n             FALSE ,\n             NULL );\n  loaded_image = gimp_test_load_image (image->gimp, file);\n  gimp_assert_mainimage (loaded_image,\n                         with_unusual_stuff,\n                         compat_paths,\n                         use_gimp_2_8_features);\n  g_file_delete (file, NULL, NULL);\n  g_object_unref (file);\n}", "target": 1}
{"code": "bool Server::MatchViewOrStatic(const std::string& method,\n                               const std::string& url, bool* stream) {\n  if (Router::MatchView(method, url, stream)) {\n    return true;\n  }\n  if (method == methods::kGet && !doc_root_.empty()) {\n    fs::path path = doc_root_ / url;\n    fs::error_code ec;\n    if (!fs::is_directory(path, ec) && fs::exists(path, ec)) {\n      return true;\n    }\n  }\n  return false;\n}", "target": 1}
{"code": "static int vmx_sync_pir_to_irr(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint max_irr;\n\tWARN_ON(!vcpu->arch.apicv_active);\n\tif (pi_test_on(&vmx->pi_desc)) {\n\t\tpi_clear_on(&vmx->pi_desc);\n\t\tsmp_mb__after_atomic();\n\t\tmax_irr = kvm_apic_update_irr(vcpu, vmx->pi_desc.pir);\n\t} else {\n\t\tmax_irr = kvm_lapic_find_highest_irr(vcpu);\n\t}\n\tvmx_hwapic_irr_update(vcpu, max_irr);\n\treturn max_irr;\n}", "target": 0}
{"code": "comics_document_thumbnails_get_dimensions (EvDocumentThumbnails *document,\n\t\t\t\t\t   EvRenderContext      *rc,\n\t\t\t\t\t   gint                 *width,\n\t\t\t\t\t   gint                 *height)\n{\n\tgdouble page_width, page_height;\n\tcomics_document_get_page_size (EV_DOCUMENT (document), rc->page,\n\t\t\t\t       &page_width, &page_height);\n\tif (rc->rotation == 90 || rc->rotation == 270) {\n\t\t*width = (gint) (page_height * rc->scale);\n\t\t*height = (gint) (page_width * rc->scale);\n\t} else {\n\t\t*width = (gint) (page_width * rc->scale);\n\t\t*height = (gint) (page_height * rc->scale);\n\t}\n}", "target": 1}
{"code": "static void adpt_sparc_info(sysInfo_S* si)\n{\n\tsi->processorType = PROC_ULTRASPARC;\n}", "target": 1}
{"code": "bool ImageIsJPEG( String const& filename ) {\n   try {\n      JpegInput jpeg( filename );\n   } catch( ... ) {\n      return false;\n   }\n   return true;\n}", "target": 1}
{"code": "flatpak_escape_string (const char        *s,\n                       FlatpakEscapeFlags flags)\n{\n  g_autoptr(GString) res = g_string_new (\"\");\n  gboolean did_escape = FALSE;\n  while (*s)\n    {\n      gunichar c = g_utf8_get_char_validated (s, -1);\n      if (c == (gunichar)-2 || c == (gunichar)-1)\n        {\n          append_hex_escaped_character (res, (unsigned char)*s++);\n          did_escape = TRUE;\n          continue;\n        }\n      else if (should_hex_escape (c, flags))\n        {\n          append_hex_escaped_character (res, c);\n          did_escape = TRUE;\n        }\n      else if (c == '\\\\' || (!(flags & FLATPAK_ESCAPE_DO_NOT_QUOTE) && c == '\\''))\n        {\n          g_string_append_printf (res, \"\\\\%c\", (char) c);\n          did_escape = TRUE;\n        }\n      else\n        g_string_append_unichar (res, c);\n      s = g_utf8_find_next_char (s, NULL);\n    }\n  if (did_escape && !(flags & FLATPAK_ESCAPE_DO_NOT_QUOTE))\n    {\n      g_string_prepend_c (res, '\\'');\n      g_string_append_c (res, '\\'');\n    }\n  return g_string_free (g_steal_pointer (&res), FALSE);\n}", "target": 0}
{"code": "ip_optprint(netdissect_options *ndo,\n            register const u_char *cp, u_int length)\n{\n\tregister u_int option_len;\n\tconst char *sep = \"\";\n\tfor (; length > 0; cp += option_len, length -= option_len) {\n\t\tu_int option_code;\n\t\tND_PRINT((ndo, \"%s\", sep));\n\t\tsep = \",\";\n\t\tND_TCHECK(*cp);\n\t\toption_code = *cp;\n\t\tND_PRINT((ndo, \"%s\",\n\t\t          tok2str(ip_option_values,\"unknown %u\",option_code)));\n\t\tif (option_code == IPOPT_NOP ||\n                    option_code == IPOPT_EOL)\n\t\t\toption_len = 1;\n\t\telse {\n\t\t\tND_TCHECK(cp[1]);\n\t\t\toption_len = cp[1];\n\t\t\tif (option_len < 2) {\n\t\t\t\tND_PRINT((ndo, \" [bad length %u]\", option_len));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (option_len > length) {\n\t\t\tND_PRINT((ndo, \" [bad length %u]\", option_len));\n\t\t\treturn;\n\t\t}\n\t\tND_TCHECK2(*cp, option_len);\n\t\tswitch (option_code) {\n\t\tcase IPOPT_EOL:\n\t\t\treturn;\n\t\tcase IPOPT_TS:\n\t\t\tif (ip_printts(ndo, cp, option_len) == -1)\n\t\t\t\tgoto trunc;\n\t\t\tbreak;\n\t\tcase IPOPT_RR:       \n\t\tcase IPOPT_SSRR:\n\t\tcase IPOPT_LSRR:\n\t\t\tif (ip_printroute(ndo, cp, option_len) == -1)\n\t\t\t\tgoto trunc;\n\t\t\tbreak;\n\t\tcase IPOPT_RA:\n\t\t\tif (option_len < 4) {\n\t\t\t\tND_PRINT((ndo, \" [bad length %u]\", option_len));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tND_TCHECK(cp[3]);\n\t\t\tif (EXTRACT_16BITS(&cp[2]) != 0)\n\t\t\t\tND_PRINT((ndo, \" value %u\", EXTRACT_16BITS(&cp[2])));\n\t\t\tbreak;\n\t\tcase IPOPT_NOP:       \n\t\tcase IPOPT_SECURITY:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\n}", "target": 0}
{"code": "xmlParseMarkupDecl(xmlParserCtxtPtr ctxt) {\n    GROW;\n    if (CUR == '<') {\n        if (NXT(1) == '!') {\n\t    switch (NXT(2)) {\n\t        case 'E':\n\t\t    if (NXT(3) == 'L')\n\t\t\txmlParseElementDecl(ctxt);\n\t\t    else if (NXT(3) == 'N')\n\t\t\txmlParseEntityDecl(ctxt);\n\t\t    break;\n\t        case 'A':\n\t\t    xmlParseAttributeListDecl(ctxt);\n\t\t    break;\n\t        case 'N':\n\t\t    xmlParseNotationDecl(ctxt);\n\t\t    break;\n\t        case '-':\n\t\t    xmlParseComment(ctxt);\n\t\t    break;\n\t\tdefault:\n\t\t    break;\n\t    }\n\t} else if (NXT(1) == '?') {\n\t    xmlParsePI(ctxt);\n\t}\n    }\n    if ((ctxt->external == 0) && (ctxt->inputNr == 1))\n\txmlParsePEReference(ctxt);\n    if ((ctxt->external == 0) && (ctxt->inputNr > 1)) {\n        if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {\n\t    xmlParseConditionalSections(ctxt);\n\t}\n    }\n    ctxt->instate = XML_PARSER_DTD;\n}", "target": 0}
{"code": "int ContentLine_Analyzer::DoDeliverOnce(int len, const u_char* data)\n\t{\n\tconst u_char* data_start = data;\n\tif ( len <= 0 )\n\t\treturn 0;\n\tfor ( ; len > 0; --len, ++data )\n\t\t{\n\t\tif ( offset >= buf_len )\n\t\t\tInitBuffer(buf_len * 2);\n\t\tint c = data[0];\n#define EMIT_LINE \\\n\t{ \\\n\tbuf[offset] = '\\0'; \\\n\tint seq_len = data + 1 - data_start; \\\n\tseq_delivered_in_lines = seq + seq_len; \\\n\tlast_char = c; \\\n\tForwardStream(offset, buf, IsOrig()); \\\n\toffset = 0; \\\n\treturn seq_len; \\\n\t}\n\t\tswitch ( c ) {\n\t\tcase '\\r':\n\t\t\tif ( len > 1 && data[1] == '\\n' )\n\t\t\t\t{\n\t\t\t\t--len; ++data;\n\t\t\t\tlast_char = c;\n\t\t\t\tc = data[0];\n\t\t\t\tEMIT_LINE\n\t\t\t\t}\n\t\t\telse if ( CR_LF_as_EOL & CR_as_EOL )\n\t\t\t\tEMIT_LINE\n\t\t\telse\n\t\t\t\tbuf[offset++] = c;\n\t\t\tbreak;\n\t\tcase '\\n':\n\t\t\tif ( last_char == '\\r' )\n\t\t\t\t{\n\t\t\t\tif ( offset == 0 )\n\t\t\t\t\t{\n\t\t\t\t\tlast_char = c;\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t--offset; \n\t\t\t\tEMIT_LINE\n\t\t\t\t}\n\t\t\telse if ( CR_LF_as_EOL & LF_as_EOL )\n\t\t\t\tEMIT_LINE\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tif ( ! suppress_weirds && Conn()->FlagEvent(SINGULAR_LF) )\n\t\t\t\t\tConn()->Weird(\"line_terminated_with_single_LF\");\n\t\t\t\tbuf[offset++] = c;\n\t\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\0':\n\t\t\tif ( flag_NULs )\n\t\t\t\tCheckNUL();\n\t\t\telse\n\t\t\t\tbuf[offset++] = c;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbuf[offset++] = c;\n\t\t\tbreak;\n\t\t}\n\t\tif ( last_char == '\\r' )\n\t\t\tif ( ! suppress_weirds && Conn()->FlagEvent(SINGULAR_CR) )\n\t\t\t\tConn()->Weird(\"line_terminated_with_single_CR\");\n\t\tlast_char = c;\n\t\t}\n\treturn data - data_start;\n\t}", "target": 0}
{"code": "static int fts3ExprTermOffsetInit(Fts3Expr *pExpr, int iPhrase, void *ctx){\n  TermOffsetCtx *p = (TermOffsetCtx *)ctx;\n  int nTerm;                      \n  int iTerm;                      \n  char *pList;                    \n  int iPos = 0;                   \n  int rc;\n  UNUSED_PARAMETER(iPhrase);\n  rc = sqlite3Fts3EvalPhrasePoslist(p->pCsr, pExpr, p->iCol, &pList);\n  nTerm = pExpr->pPhrase->nToken;\n  if( pList ){\n    fts3GetDeltaPosition(&pList, &iPos);\n    assert( iPos>=0 );\n  }\n  for(iTerm=0; iTerm<nTerm; iTerm++){\n    TermOffset *pT = &p->aTerm[p->iTerm++];\n    pT->iOff = nTerm-iTerm-1;\n    pT->pList = pList;\n    pT->iPos = iPos;\n  }\n  return rc;\n}", "target": 0}
{"code": "test_keys ( ELG_secret_key *sk, unsigned int nbits, int nodie )\n{\n  ELG_public_key pk;\n  gcry_mpi_t test = gcry_mpi_new ( 0 );\n  gcry_mpi_t out1_a = gcry_mpi_new ( nbits );\n  gcry_mpi_t out1_b = gcry_mpi_new ( nbits );\n  gcry_mpi_t out2 = gcry_mpi_new ( nbits );\n  int failed = 0;\n  pk.p = sk->p;\n  pk.g = sk->g;\n  pk.y = sk->y;\n  gcry_mpi_randomize ( test, nbits, GCRY_WEAK_RANDOM );\n  do_encrypt ( out1_a, out1_b, test, &pk );\n  decrypt ( out2, out1_a, out1_b, sk );\n  if ( mpi_cmp( test, out2 ) )\n    failed |= 1;\n  sign ( out1_a, out1_b, test, sk );\n  if ( !verify( out1_a, out1_b, test, &pk ) )\n    failed |= 2;\n  gcry_mpi_release ( test );\n  gcry_mpi_release ( out1_a );\n  gcry_mpi_release ( out1_b );\n  gcry_mpi_release ( out2 );\n  if (failed && !nodie)\n    log_fatal (\"Elgamal test key for %s %s failed\\n\",\n               (failed & 1)? \"encrypt+decrypt\":\"\",\n               (failed & 2)? \"sign+verify\":\"\");\n  if (failed && DBG_CIPHER)\n    log_debug (\"Elgamal test key for %s %s failed\\n\",\n               (failed & 1)? \"encrypt+decrypt\":\"\",\n               (failed & 2)? \"sign+verify\":\"\");\n  return failed;\n}", "target": 0}
{"code": "void LibRaw::android_tight_load_raw()\n{\n  uchar *data, *dp;\n  int bwide, row, col, c;\n  bwide = -(-5 * raw_width >> 5) << 3;\n  data = (uchar *)malloc(bwide);\n  merror(data, \"android_tight_load_raw()\");\n  for (row = 0; row < raw_height; row++)\n  {\n    if (fread(data, 1, bwide, ifp) < bwide)\n      derror();\n    for (dp = data, col = 0; col < raw_width; dp += 5, col += 4)\n      FORC4 RAW(row, col + c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n  }\n  free(data);\n}", "target": 0}
{"code": "static TEE_Result do_allocate_keypair(struct ecc_keypair *key,\n\t\t\t\t      uint32_t type __unused,\n\t\t\t\t      size_t size_bits)\n{\n\tECC_TRACE(\"Allocate Keypair of %zu bits\", size_bits);\n\tmemset(key, 0, sizeof(*key));\n\tkey->d = crypto_bignum_allocate(size_bits);\n\tif (!key->d)\n\t\tgoto err;\n\tkey->x = crypto_bignum_allocate(size_bits);\n\tif (!key->x)\n\t\tgoto err;\n\tkey->y = crypto_bignum_allocate(size_bits);\n\tif (!key->y)\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tECC_TRACE(\"Allocation error\");\n\tcrypto_bignum_free(key->d);\n\tcrypto_bignum_free(key->x);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "int compat_ipv6_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t   char __user *optval, unsigned int optlen)\n{\n\tint err;\n\tif (level == SOL_IP && sk->sk_type != SOCK_RAW) {\n\t\tif (udp_prot.compat_setsockopt != NULL)\n\t\t\treturn udp_prot.compat_setsockopt(sk, level, optname,\n\t\t\t\t\t\t\t  optval, optlen);\n\t\treturn udp_prot.setsockopt(sk, level, optname, optval, optlen);\n\t}\n\tif (level != SOL_IPV6)\n\t\treturn -ENOPROTOOPT;\n\tif (optname >= MCAST_JOIN_GROUP && optname <= MCAST_MSFILTER)\n\t\treturn compat_mc_setsockopt(sk, level, optname, optval, optlen,\n\t\t\tipv6_setsockopt);\n\terr = do_ipv6_setsockopt(sk, level, optname, optval, optlen);\n#ifdef CONFIG_NETFILTER\n\tif (err == -ENOPROTOOPT && optname != IPV6_IPSEC_POLICY &&\n\t    optname != IPV6_XFRM_POLICY)\n\t\terr = compat_nf_setsockopt(sk, PF_INET6, optname, optval,\n\t\t\t\t\t   optlen);\n#endif\n\treturn err;\n}", "target": 0}
{"code": "cssp_encode_tspasswordcreds(char *username, char *password, char *domain)\n{\n\tSTREAM out, h1, h2;\n\tstruct stream tmp = { 0 };\n\tstruct stream message = { 0 };\n\tmemset(&tmp, 0, sizeof(tmp));\n\tmemset(&message, 0, sizeof(message));\n\ts_realloc(&tmp, 4 + strlen(domain) * sizeof(uint16));\n\ts_reset(&tmp);\n\trdp_out_unistr(&tmp, domain, strlen(domain) * sizeof(uint16));\n\ts_mark_end(&tmp);\n\th2 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, &tmp);\n\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0, h2);\n\ts_realloc(&message, s_length(&message) + s_length(h1));\n\tout_uint8p(&message, h1->data, s_length(h1));\n\ts_mark_end(&message);\n\ts_free(h2);\n\ts_free(h1);\n\ts_realloc(&tmp, 4 + strlen(username) * sizeof(uint16));\n\ts_reset(&tmp);\n\trdp_out_unistr(&tmp, username, strlen(username) * sizeof(uint16));\n\ts_mark_end(&tmp);\n\th2 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, &tmp);\n\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1, h2);\n\ts_realloc(&message, s_length(&message) + s_length(h1));\n\tout_uint8p(&message, h1->data, s_length(h1));\n\ts_mark_end(&message);\n\ts_free(h2);\n\ts_free(h1);\n\ts_realloc(&tmp, 4 + strlen(password) * sizeof(uint16));\n\ts_reset(&tmp);\n\trdp_out_unistr(&tmp, password, strlen(password) * sizeof(uint16));\n\ts_mark_end(&tmp);\n\th2 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, &tmp);\n\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 2, h2);\n\ts_realloc(&message, s_length(&message) + s_length(h1));\n\tout_uint8p(&message, h1->data, s_length(h1));\n\ts_mark_end(&message);\n\ts_free(h2);\n\ts_free(h1);\n\tout = ber_wrap_hdr_data(BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED, &message);\n\txfree(tmp.data);\n\txfree(message.data);\n\treturn out;\n}", "target": 0}
{"code": "static BOOL ntlm_av_pair_add_copy(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList,\n                                  NTLM_AV_PAIR* pAvPair, size_t cbAvPair)\n{\n\tif (!ntlm_av_pair_check(pAvPair, cbAvPair))\n\t\treturn FALSE;\n\treturn ntlm_av_pair_add(pAvPairList, cbAvPairList, ntlm_av_pair_get_id(pAvPair),\n\t                        ntlm_av_pair_get_value_pointer(pAvPair), ntlm_av_pair_get_len(pAvPair));\n}", "target": 1}
{"code": "ExprResolveBoolean(struct xkb_context *ctx, const ExprDef *expr,\n                   bool *set_rtrn)\n{\n    bool ok = false;\n    const char *ident;\n    switch (expr->expr.op) {\n    case EXPR_VALUE:\n        if (expr->expr.value_type != EXPR_TYPE_BOOLEAN) {\n            log_err(ctx,\n                    \"Found constant of type %s where boolean was expected\\n\",\n                    expr_value_type_to_string(expr->expr.value_type));\n            return false;\n        }\n        *set_rtrn = expr->boolean.set;\n        return true;\n    case EXPR_IDENT:\n        ident = xkb_atom_text(ctx, expr->ident.ident);\n        if (ident) {\n            if (istreq(ident, \"true\") ||\n                istreq(ident, \"yes\") ||\n                istreq(ident, \"on\")) {\n                *set_rtrn = true;\n                return true;\n            }\n            else if (istreq(ident, \"false\") ||\n                     istreq(ident, \"no\") ||\n                     istreq(ident, \"off\")) {\n                *set_rtrn = false;\n                return true;\n            }\n        }\n        log_err(ctx, \"Identifier \\\"%s\\\" of type boolean is unknown\\n\", ident);\n        return false;\n    case EXPR_FIELD_REF:\n        log_err(ctx, \"Default \\\"%s.%s\\\" of type boolean is unknown\\n\",\n                xkb_atom_text(ctx, expr->field_ref.element),\n                xkb_atom_text(ctx, expr->field_ref.field));\n        return false;\n    case EXPR_INVERT:\n    case EXPR_NOT:\n        ok = ExprResolveBoolean(ctx, expr, set_rtrn);\n        if (ok)\n            *set_rtrn = !*set_rtrn;\n        return ok;\n    case EXPR_ADD:\n    case EXPR_SUBTRACT:\n    case EXPR_MULTIPLY:\n    case EXPR_DIVIDE:\n    case EXPR_ASSIGN:\n    case EXPR_NEGATE:\n    case EXPR_UNARY_PLUS:\n        log_err(ctx, \"%s of boolean values not permitted\\n\",\n                expr_op_type_to_string(expr->expr.op));\n        break;\n    default:\n        log_wsgo(ctx, \"Unknown operator %d in ResolveBoolean\\n\",\n                 expr->expr.op);\n        break;\n    }\n    return false;\n}", "target": 1}
{"code": "_zip_cdir_new(int nentry, struct zip_error *error)\n{\n    struct zip_cdir *cd;\n    if ((cd=(struct zip_cdir *)malloc(sizeof(*cd))) == NULL) {\n\t_zip_error_set(error, ZIP_ER_MEMORY, 0);\n\treturn NULL;\n    }\n    if ( nentry > ((size_t)-1)/sizeof(*(cd->entry)) || (cd->entry=(struct zip_dirent *)malloc(sizeof(*(cd->entry))*(size_t)nentry))\n\t== NULL) {\n\t_zip_error_set(error, ZIP_ER_MEMORY, 0);\n\tfree(cd);\n\treturn NULL;\n    }\n    cd->nentry = nentry;\n    cd->size = cd->offset = 0;\n    cd->comment = NULL;\n    cd->comment_len = 0;\n    return cd;\n}", "target": 0}
{"code": "void Wifipcap::handle_packet(WifipcapCallbacks *cbs,int header_type,\n                             const struct pcap_pkthdr *header, const u_char * packet) \n{\n    if (startTime == TIME_NONE) {\n\tstartTime = header->ts;\n\tlastPrintTime = header->ts;\n    }\n    if (header->ts.tv_sec > lastPrintTime.tv_sec + Wifipcap::PRINT_TIME_INTERVAL) {\n\tif (verbose) {\n\t    int hours = (header->ts.tv_sec - startTime.tv_sec)/3600;\n\t    int days  = hours/24;\n\t    int left  = hours%24;\n\t    fprintf(stderr, \"wifipcap: %2d days %2d hours, %10\" PRId64 \" pkts\\n\", \n\t\t    days, left, packetsProcessed);\n\t}\n\tlastPrintTime = header->ts;\n    }\n    packetsProcessed++;\n    WifiPacket pkt(cbs,header_type,header,packet);\n    cbs->PacketBegin(pkt, packet, header->caplen, header->len);\n    switch(header_type) {\n    case DLT_PRISM_HEADER:\n        pkt.handle_prism(packet,header->caplen);\n        break;\n    case DLT_IEEE802_11_RADIO:\n        pkt.handle_radiotap(packet,header->caplen);\n        break;\n    case DLT_IEEE802_11:\n        pkt.handle_80211(packet,header->caplen);\n        break;\n    case DLT_EN10MB:\n        pkt.handle_ether(packet,header->caplen);\n        break;\n    default:\n#if 0\n        pkt.handle_ip(packet,header->caplen);\n#endif\n        break;\n    }\n    cbs->PacketEnd(pkt);\n}", "target": 0}
{"code": "SHA256_Init(struct SHA256_CTX * ctx)\n{\n  ctx->count[0] = ctx->count[1] = 0;\n  ctx->state[0] = 0x6A09E667;\n  ctx->state[1] = 0xBB67AE85;\n  ctx->state[2] = 0x3C6EF372;\n  ctx->state[3] = 0xA54FF53A;\n  ctx->state[4] = 0x510E527F;\n  ctx->state[5] = 0x9B05688C;\n  ctx->state[6] = 0x1F83D9AB;\n  ctx->state[7] = 0x5BE0CD19;\n}", "target": 1}
{"code": "inline void* aligned_malloc(size_t size, size_t alignment) {\n  return folly::detail::aligned_malloc(size, alignment);\n}", "target": 1}
{"code": "set_num_722(unsigned char *p, uint16_t value)\n{\n\tarchive_be16enc(p, value);\n}", "target": 0}
{"code": "escape_xml(const char *text)\n{\n\tstatic char *escaped;\n\tstatic size_t escaped_size;\n\tchar *out;\n\tsize_t len;\n\tif (!strlen(text)) return \"\";\n\tfor (out=escaped, len=0; *text; ++len, ++out, ++text) {\n\t\tif ((len + 8) > escaped_size) {\n\t\t\tchar *bigger_escaped;\n\t\t\tescaped_size += 128;\n\t\t\tbigger_escaped = realloc(escaped, escaped_size);\n\t\t\tif (!bigger_escaped) {\n\t\t\t\tfree(escaped);\t\n\t\t\t\tescaped = NULL;\n\t\t\t\tescaped_size = 0;\n\t\t\t\treturn \">>> out of memory <<<\";\n\t\t\t}\n\t\t\tout = bigger_escaped + len;\n\t\t\tescaped = bigger_escaped;\n\t\t}\n\t\tswitch (*text) {\n\t\t\tcase '&':\n\t\t\t\tstrcpy(out, \"&amp;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\tstrcpy(out, \"&lt;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\tstrcpy(out, \"&gt;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t*out = *text;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t*out = '\\x0';  \n\treturn escaped;\n}", "target": 0}
{"code": "void AAHD::refine_hv_dirs()\n{\n  for (int i = 0; i < libraw.imgdata.sizes.iheight; ++i)\n  {\n    refine_hv_dirs(i, i & 1);\n  }\n  for (int i = 0; i < libraw.imgdata.sizes.iheight; ++i)\n  {\n    refine_hv_dirs(i, (i & 1) ^ 1);\n  }\n  for (int i = 0; i < libraw.imgdata.sizes.iheight; ++i)\n  {\n    refine_ihv_dirs(i);\n  }\n}", "target": 0}
{"code": "int gnutls_x509_ext_export_aia(gnutls_x509_aia_t aia,\n\t\t\t\t\t      gnutls_datum_t * ext)\n{\n\tint ret, result;\n\tASN1_TYPE c2 = ASN1_TYPE_EMPTY;\n\tunsigned int i;\n\tret = asn1_create_element(_gnutls_get_pkix(),\n\t\t\t\t  \"PKIX1.AuthorityInfoAccessSyntax\", &c2);\n\tif (ret != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\treturn _gnutls_asn2err(ret);\n\t}\n\tfor (i=0;i<aia->size;i++) {\n\t\tresult = asn1_write_value(c2, \"\", \"NEW\", 1);\n\t\tif (result != ASN1_SUCCESS) {\n\t\t\tgnutls_assert();\n\t\t\tret = _gnutls_asn2err(result);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tresult = asn1_write_value(c2, \"?LAST.accessMethod\", aia->aia[i].oid.data, 1);\n\t\tif (result != ASN1_SUCCESS) {\n\t\t\tgnutls_assert();\n\t\t\tret = _gnutls_asn2err(result);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tret =\n\t\t    _gnutls_write_general_name(c2,\n\t\t\t\t\t\t   \"?LAST.accessLocation\",\n\t\t\t\t\t\t   aia->aia[i].san_type,\n\t\t\t\t\t\t   aia->aia[i].san.data,\n\t\t\t\t\t\t   aia->aia[i].san.size);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tret = _gnutls_x509_der_encode(c2, \"\", ext, 0);\n\tif (ret < 0) {\n\t\tgnutls_assert();\n\t\tgoto cleanup;\n\t}\n cleanup:\n\tasn1_delete_structure(&c2);\n\treturn ret;\n}", "target": 0}
{"code": "void test_base64_lengths(void)\n{\n  const char *in = \"FuseMuse\";\n  char out1[32];\n  char out2[32];\n  size_t enclen;\n  int declen;\n  enclen = mutt_b64_encode(out1, in, 0, 32);\n  if (!TEST_CHECK(enclen == 0))\n  {\n    TEST_MSG(\"Expected: %zu\", 0);\n    TEST_MSG(\"Actual  : %zu\", enclen);\n  }\n  out1[0] = '\\0';\n  declen = mutt_b64_decode(out2, out1);\n  if (!TEST_CHECK(declen == -1))\n  {\n    TEST_MSG(\"Expected: %zu\", -1);\n    TEST_MSG(\"Actual  : %zu\", declen);\n  }\n  for (size_t i = 1; i <= 8; ++i)\n  {\n    enclen = mutt_b64_encode(out1, in, i, 32);\n    size_t exp = ((i + 2) / 3) << 2;\n    if (!TEST_CHECK(enclen == exp))\n    {\n      TEST_MSG(\"Expected: %zu\", exp);\n      TEST_MSG(\"Actual  : %zu\", enclen);\n    }\n    declen = mutt_b64_decode(out2, out1);\n    if (!TEST_CHECK(declen == i))\n    {\n      TEST_MSG(\"Expected: %zu\", i);\n      TEST_MSG(\"Actual  : %zu\", declen);\n    }\n    out2[declen] = '\\0';\n    if (!TEST_CHECK(strncmp(out2, in, i) == 0))\n    {\n      TEST_MSG(\"Expected: %s\", in);\n      TEST_MSG(\"Actual  : %s\", out2);\n    }\n  }\n}", "target": 1}
{"code": "void ExtensionPrefs::InitPrefStore() {\n  ExtensionIdSet extension_ids;\n  GetExtensions(&extension_ids);\n  for (ExtensionIdSet::iterator ext_id = extension_ids.begin();\n       ext_id != extension_ids.end(); ++ext_id) {\n    ScopedExtensionPrefUpdate update(prefs_, *ext_id);\n    update.Get();\n  }\n  FixMissingPrefs(extension_ids);\n  for (ExtensionIdSet::iterator ext_id = extension_ids.begin();\n       ext_id != extension_ids.end(); ++ext_id) {\n    extension_pref_value_map_->RegisterExtension(\n        *ext_id,\n        GetInstallTime(*ext_id),\n        GetExtensionState(*ext_id) == Extension::ENABLED);\n    content_settings_store_->RegisterExtension(\n        *ext_id,\n        GetInstallTime(*ext_id),\n        GetExtensionState(*ext_id) == Extension::ENABLED);\n    const DictionaryValue* prefs = GetExtensionControlledPrefs(*ext_id, false);\n    for (DictionaryValue::key_iterator i = prefs->begin_keys();\n         i != prefs->end_keys(); ++i) {\n      Value* value;\n      if (!prefs->GetWithoutPathExpansion(*i, &value))\n        continue;\n      extension_pref_value_map_->SetExtensionPref(\n          *ext_id, *i, kExtensionPrefsScopeRegular, value->DeepCopy());\n    }\n    prefs = GetExtensionControlledPrefs(*ext_id, true);\n    for (DictionaryValue::key_iterator i = prefs->begin_keys();\n         i != prefs->end_keys(); ++i) {\n      Value* value;\n      if (!prefs->GetWithoutPathExpansion(*i, &value))\n        continue;\n      extension_pref_value_map_->SetExtensionPref(\n          *ext_id, *i, kExtensionPrefsScopeIncognitoPersistent,\n          value->DeepCopy());\n    }\n    const DictionaryValue* extension_prefs = GetExtensionPref(*ext_id);\n    DCHECK(extension_prefs);\n    ListValue* content_settings = NULL;\n    if (extension_prefs->GetList(kPrefContentSettings,\n                                 &content_settings)) {\n      content_settings_store_->SetExtensionContentSettingsFromList(\n          *ext_id, content_settings,\n          kExtensionPrefsScopeRegular);\n    }\n    if (extension_prefs->GetList(kPrefIncognitoContentSettings,\n                                 &content_settings)) {\n      content_settings_store_->SetExtensionContentSettingsFromList(\n          *ext_id, content_settings,\n          kExtensionPrefsScopeIncognitoPersistent);\n    }\n  }\n  extension_pref_value_map_->NotifyInitializationCompleted();\n}", "target": 0}
{"code": "TfLiteStatus HardSwishPrepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  if (input->type == kTfLiteUInt8 || input->type == kTfLiteInt8) {\n    HardSwishParams* params = static_cast<HardSwishParams*>(node->user_data);\n    params->input_zero_point = input->params.zero_point;\n    params->output_zero_point = output->params.zero_point;\n    const float input_scale = input->params.scale;\n    const float hires_input_scale = (1.0f / 128.0f) * input_scale;\n    const float reluish_scale = 3.0f / 32768.0f;\n    const float output_scale = output->params.scale;\n    const double output_multiplier =\n        static_cast<double>(hires_input_scale / output_scale);\n    int32_t output_multiplier_fixedpoint_int32;\n    QuantizeMultiplier(output_multiplier, &output_multiplier_fixedpoint_int32,\n                       &params->output_multiplier_exponent);\n    DownScaleInt32ToInt16Multiplier(\n        output_multiplier_fixedpoint_int32,\n        &params->output_multiplier_fixedpoint_int16);\n    TF_LITE_ENSURE(context, params->output_multiplier_exponent <= 0);\n    const double reluish_multiplier =\n        static_cast<double>(hires_input_scale / reluish_scale);\n    int32_t reluish_multiplier_fixedpoint_int32;\n    QuantizeMultiplier(reluish_multiplier, &reluish_multiplier_fixedpoint_int32,\n                       &params->reluish_multiplier_exponent);\n    DownScaleInt32ToInt16Multiplier(\n        reluish_multiplier_fixedpoint_int32,\n        &params->reluish_multiplier_fixedpoint_int16);\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static int smb2_calc_max_out_buf_len(struct ksmbd_work *work,\n\t\t\t\t     unsigned short hdr2_len,\n\t\t\t\t     unsigned int out_buf_len)\n{\n\tint free_len;\n\tif (out_buf_len > work->conn->vals->max_trans_size)\n\t\treturn -EINVAL;\n\tfree_len = (int)(work->response_sz -\n\t\t\t (get_rfc1002_len(work->response_buf) + 4)) -\n\t\thdr2_len;\n\tif (free_len < 0)\n\t\treturn -EINVAL;\n\treturn min_t(int, out_buf_len, free_len);\n}", "target": 1}
{"code": "__be32 ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb)\n{\n\tstatic u32 ip6_proxy_idents_hashrnd __read_mostly;\n\tstruct in6_addr buf[2];\n\tstruct in6_addr *addrs;\n\tu32 id;\n\taddrs = skb_header_pointer(skb,\n\t\t\t\t   skb_network_offset(skb) +\n\t\t\t\t   offsetof(struct ipv6hdr, saddr),\n\t\t\t\t   sizeof(buf), buf);\n\tif (!addrs)\n\t\treturn 0;\n\tnet_get_random_once(&ip6_proxy_idents_hashrnd,\n\t\t\t    sizeof(ip6_proxy_idents_hashrnd));\n\tid = __ipv6_select_ident(net, ip6_proxy_idents_hashrnd,\n\t\t\t\t &addrs[1], &addrs[0]);\n\treturn htonl(id);\n}", "target": 1}
{"code": "static u32 apic_get_tmcct(struct kvm_lapic *apic)\n{\n\tktime_t remaining;\n\ts64 ns;\n\tu32 tmcct;\n\tASSERT(apic != NULL);\n\tif (kvm_apic_get_reg(apic, APIC_TMICT) == 0)\n\t\treturn 0;\n\tremaining = hrtimer_get_remaining(&apic->lapic_timer.timer);\n\tif (ktime_to_ns(remaining) < 0)\n\t\tremaining = ktime_set(0, 0);\n\tns = mod_64(ktime_to_ns(remaining), apic->lapic_timer.period);\n\ttmcct = div64_u64(ns,\n\t\t\t (APIC_BUS_CYCLE_NS * apic->divide_count));\n\treturn tmcct;\n}", "target": 1}
{"code": "  virtual bool ms_verify_authorizer(Connection *con, int peer_type,\n\t\t\t\t    int protocol, bufferlist& authorizer,\n\t\t\t\t    bufferlist& authorizer_reply,\n\t\t\t\t    bool& isvalid, CryptoKey& session_key) {\n    isvalid = true;\n    return true;\n  };", "target": 1}
{"code": "get_word_gray_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n    *ptr++ = rescale[temp];\n  }\n  return 1;\n}", "target": 1}
{"code": "static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid, int bitdepth)\n{\n    if (cid != ctx->cid) {\n        const CIDEntry *cid_table = ff_dnxhd_get_cid_table(cid);\n        if (!cid_table) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"unsupported cid %\"PRIu32\"\\n\", cid);\n            return AVERROR(ENOSYS);\n        }\n        if (cid_table->bit_depth != bitdepth &&\n            cid_table->bit_depth != DNXHD_VARIABLE) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"bit depth mismatches %d %d\\n\",\n                   cid_table->bit_depth, bitdepth);\n            return AVERROR_INVALIDDATA;\n        }\n        ctx->cid_table = cid_table;\n        av_log(ctx->avctx, AV_LOG_VERBOSE, \"Profile cid %\"PRIu32\".\\n\", cid);\n        ff_free_vlc(&ctx->ac_vlc);\n        ff_free_vlc(&ctx->dc_vlc);\n        ff_free_vlc(&ctx->run_vlc);\n        init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,\n                 ctx->cid_table->ac_bits, 1, 1,\n                 ctx->cid_table->ac_codes, 2, 2, 0);\n        init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, bitdepth > 8 ? 14 : 12,\n                 ctx->cid_table->dc_bits, 1, 1,\n                 ctx->cid_table->dc_codes, 1, 1, 0);\n        init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,\n                 ctx->cid_table->run_bits, 1, 1,\n                 ctx->cid_table->run_codes, 2, 2, 0);\n        ctx->cid = cid;\n    }\n    return 0;\n}", "target": 1}
{"code": "void CleanWriters(GF_List *writers)\n{\n\twhile (gf_list_count(writers)) {\n\t\tTrackWriter *writer = (TrackWriter*)gf_list_get(writers, 0);\n\t\tgf_list_del_item(writer->stbl->child_boxes, writer->stco);\n\t\tgf_list_del_item(writer->stbl->child_boxes, writer->stsc);\n\t\tgf_isom_box_del(writer->stco);\n\t\tgf_isom_box_del((GF_Box *)writer->stsc);\n\t\tgf_free(writer);\n\t\tgf_list_rem(writers, 0);\n\t}\n}", "target": 0}
{"code": "int ossl_dsa_check_pairwise(const DSA *dsa)\n{\n    int ret = 0;\n    BN_CTX *ctx = NULL;\n    BIGNUM *pub_key = NULL;\n    if (dsa->params.p == NULL\n        || dsa->params.g == NULL\n        || dsa->priv_key == NULL\n        || dsa->pub_key == NULL)\n        return 0;\n    ctx = BN_CTX_new_ex(dsa->libctx);\n    if (ctx == NULL)\n        goto err;\n    pub_key = BN_new();\n    if (pub_key == NULL)\n        goto err;\n    if (!ossl_dsa_generate_public_key(ctx, dsa, dsa->priv_key, pub_key))\n        goto err;\n    ret = BN_cmp(pub_key, dsa->pub_key) == 0;\nerr:\n    BN_free(pub_key);\n    BN_CTX_free(ctx);\n    return ret;\n}", "target": 1}
{"code": "gdImagePtr gdImageCreate (int sx, int sy)\n{\n\tint i;\n\tgdImagePtr im;\n\tif (overflow2(sx, sy)) {\n\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof(unsigned char *), sy)) {\n\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof(unsigned char *), sx)) {\n\t\treturn NULL;\n\t}\n\tim = (gdImage *) gdCalloc(1, sizeof(gdImage));\n\tim->pixels = (unsigned char **) gdMalloc(sizeof(unsigned char *) * sy);\n\tim->AA_opacity = (unsigned char **) gdMalloc(sizeof(unsigned char *) * sy);\n\tim->polyInts = 0;\n\tim->polyAllocated = 0;\n\tim->brush = 0;\n\tim->tile = 0;\n\tim->style = 0;\n\tfor (i = 0; i < sy; i++) {\n\t\tim->pixels[i] = (unsigned char *) gdCalloc(sx, sizeof(unsigned char));\n\t\tim->AA_opacity[i] = (unsigned char *) gdCalloc(sx, sizeof(unsigned char));\n\t}\n\tim->sx = sx;\n\tim->sy = sy;\n\tim->colorsTotal = 0;\n\tim->transparent = (-1);\n\tim->interlace = 0;\n\tim->thick = 1;\n\tim->AA = 0;\n\tim->AA_polygon = 0;\n\tfor (i = 0; i < gdMaxColors; i++) {\n\t\tim->open[i] = 1;\n\t\tim->red[i] = 0;\n\t\tim->green[i] = 0;\n\t\tim->blue[i] = 0;\n\t}\n\tim->trueColor = 0;\n\tim->tpixels = 0;\n\tim->cx1 = 0;\n\tim->cy1 = 0;\n\tim->cx2 = im->sx - 1;\n\tim->cy2 = im->sy - 1;\n\tim->interpolation = NULL;\n\tim->interpolation_id = GD_BILINEAR_FIXED;\n\treturn im;\n}", "target": 0}
{"code": "archive_reopen_if_needed (ComicsDocument  *comics_document,\n\t\t\t  const char      *page_wanted,\n\t\t\t  GError         **error)\n{\n\tconst char *current_page;\n\tguint current_page_idx, page_wanted_idx;\n\tif (ev_archive_at_entry (comics_document->archive)) {\n\t\tcurrent_page = ev_archive_get_entry_pathname (comics_document->archive);\n\t\tif (current_page) {\n\t\t\tcurrent_page_idx = GPOINTER_TO_UINT (g_hash_table_lookup (comics_document->page_positions, current_page));\n\t\t\tpage_wanted_idx = GPOINTER_TO_UINT (g_hash_table_lookup (comics_document->page_positions, page_wanted));\n\t\t\tif (current_page_idx != 0 &&\n\t\t\t    page_wanted_idx != 0 &&\n\t\t\t    page_wanted_idx > current_page_idx)\n\t\t\t\treturn TRUE;\n\t\t}\n\t\tev_archive_reset (comics_document->archive);\n\t}\n\treturn ev_archive_open_filename (comics_document->archive, comics_document->archive_path, error);\n}", "target": 0}
{"code": "__u32 secure_tcpv6_sequence_number(__be32 *saddr, __be32 *daddr,\n\t\t\t\t   __be16 sport, __be16 dport)\n{\n\tu32 secret[MD5_MESSAGE_BYTES / 4];\n\tu32 hash[MD5_DIGEST_WORDS];\n\tu32 i;\n\tmemcpy(hash, saddr, 16);\n\tfor (i = 0; i < 4; i++)\n\t\tsecret[i] = net_secret[i] + daddr[i];\n\tsecret[4] = net_secret[4] +\n\t\t(((__force u16)sport << 16) + (__force u16)dport);\n\tfor (i = 5; i < MD5_MESSAGE_BYTES / 4; i++)\n\t\tsecret[i] = net_secret[i];\n\tmd5_transform(hash, secret);\n\treturn seq_scale(hash[0]);\n}", "target": 0}
{"code": "static void *HTPStateGetTx(void *alstate, uint64_t tx_id)\n{\n    HtpState *http_state = (HtpState *)alstate;\n    if (http_state != NULL && http_state->conn != NULL)\n        return htp_list_get(http_state->conn->transactions, tx_id);\n    else\n        return NULL;\n}", "target": 1}
{"code": "        bool         CheckRegion(int nPos, int nSize)\n        {\n            return (nPos >= 0 && nPos + nSize >= nPos && nPos + nSize <= m_nLen);\n        }", "target": 1}
{"code": "static __u8 *sp_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 107 && rdesc[104] == 0x26 && rdesc[105] == 0x80 &&\n\t\t\trdesc[106] == 0x03) {\n\t\thid_info(hdev, \"fixing up Sunplus Wireless Desktop report descriptor\\n\");\n\t\trdesc[105] = rdesc[110] = 0x03;\n\t\trdesc[106] = rdesc[111] = 0x21;\n\t}\n\treturn rdesc;\n}", "target": 1}
{"code": "  void ValidateOpDimensionsFromInputs(const int n, const int h, const int w,\n                                      const int c, const int kx, const int ky,\n                                      const int sx, const int sy,\n                                      const string& data_format,\n                                      const string& padding) {\n    OpContext op_context;\n    int ho;\n    int wo;\n    if (data_format == \"NHWC\") {\n      op_context = DescribePoolingOp(\"MaxPool\", {n, h, w, c}, {1, kx, ky, 1},\n                                     {1, sx, sy, 1}, \"NHWC\", padding);\n      ho = op_context.op_info.outputs(0).shape().dim(1).size();\n      wo = op_context.op_info.outputs(0).shape().dim(2).size();\n    } else {\n      op_context = DescribePoolingOp(\"MaxPool\", {n, c, h, w}, {1, 1, kx, ky},\n                                     {1, 1, sx, sy}, \"NCHW\", padding);\n      ho = op_context.op_info.outputs(0).shape().dim(2).size();\n      wo = op_context.op_info.outputs(0).shape().dim(3).size();\n    }\n    bool found_unknown_shapes;\n    auto dims = OpLevelCostEstimator::OpDimensionsFromInputs(\n        op_context.op_info.inputs(0).shape(), op_context.op_info,\n        &found_unknown_shapes);\n    Padding padding_enum;\n    if (padding == \"VALID\") {\n      padding_enum = Padding::VALID;\n    } else {\n      padding_enum = Padding::SAME;\n    }\n    EXPECT_EQ(n, dims.batch);\n    EXPECT_EQ(h, dims.ix);\n    EXPECT_EQ(w, dims.iy);\n    EXPECT_EQ(c, dims.iz);\n    EXPECT_EQ(kx, dims.kx);\n    EXPECT_EQ(ky, dims.ky);\n    EXPECT_EQ(sx, dims.sx);\n    EXPECT_EQ(sy, dims.sy);\n    EXPECT_EQ(ho, dims.ox);\n    EXPECT_EQ(wo, dims.oy);\n    EXPECT_EQ(c, dims.oz);\n    EXPECT_EQ(padding_enum, dims.padding);\n  }", "target": 1}
{"code": "fp_read_object(CBORDecoderObject *self, const Py_ssize_t size)\n{\n    PyObject *ret = NULL;\n    PyObject *obj, *size_obj;\n    size_obj = PyLong_FromSsize_t(size);\n    if (size_obj) {\n        obj = PyObject_CallFunctionObjArgs(self->read, size_obj, NULL);\n        Py_DECREF(size_obj);\n        if (obj) {\n            assert(PyBytes_CheckExact(obj));\n            if (PyBytes_GET_SIZE(obj) == (Py_ssize_t) size) {\n                ret = obj;\n            } else {\n                Py_DECREF(obj);\n                PyErr_Format(\n                    _CBOR2_CBORDecodeEOF,\n                    \"premature end of stream (expected to read %zd bytes, \"\n                    \"got %zd instead)\", size, PyBytes_GET_SIZE(obj));\n            }\n        }\n    }\n    return ret;\n}", "target": 0}
{"code": "static int __tail_onwire_len(int front_len, int middle_len, int data_len,\n\t\t\t     bool secure)\n{\n\tBUG_ON(front_len < 0 || front_len > CEPH_MSG_MAX_FRONT_LEN ||\n\t       middle_len < 0 || middle_len > CEPH_MSG_MAX_MIDDLE_LEN ||\n\t       data_len < 0 || data_len > CEPH_MSG_MAX_DATA_LEN);\n\tif (!front_len && !middle_len && !data_len)\n\t\treturn 0;\n\tif (!secure)\n\t\treturn front_len + middle_len + data_len +\n\t\t       CEPH_EPILOGUE_PLAIN_LEN;\n\treturn padded_len(front_len) + padded_len(middle_len) +\n\t       padded_len(data_len) + CEPH_EPILOGUE_SECURE_LEN;\n}", "target": 0}
{"code": "static inline void put_utf16(wchar_t *s, unsigned c, enum utf16_endian endian)\n{\n\tswitch (endian) {\n\tdefault:\n\t\t*s = (wchar_t) c;\n\t\tbreak;\n\tcase UTF16_LITTLE_ENDIAN:\n\t\t*s = __cpu_to_le16(c);\n\t\tbreak;\n\tcase UTF16_BIG_ENDIAN:\n\t\t*s = __cpu_to_be16(c);\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "GF_Err tenc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu8 iv_size;\n\tGF_TrackEncryptionBox *ptr = (GF_TrackEncryptionBox*)s;\n\tISOM_DECREASE_SIZE(ptr, 3);\n\tgf_bs_read_u8(bs); \n\tif (!ptr->version) {\n\t\tgf_bs_read_u8(bs); \n\t} else {\n\t\tptr->crypt_byte_block = gf_bs_read_int(bs, 4);\n\t\tptr->skip_byte_block = gf_bs_read_int(bs, 4);\n\t}\n\tptr->isProtected = gf_bs_read_u8(bs);\n\tISOM_DECREASE_SIZE(ptr, 17);\n\tptr->key_info[0] = 0;\n\tptr->key_info[1] = 0;\n\tptr->key_info[2] = 0;\n\tptr->key_info[3] = iv_size = gf_bs_read_u8(bs);\n\tgf_bs_read_data(bs, ptr->key_info+4, 16);\n\tif (!iv_size && ptr->isProtected) {\n\t\tISOM_DECREASE_SIZE(ptr, 1);\n\t\tiv_size = ptr->key_info[20] = gf_bs_read_u8(bs);\n\t\tISOM_DECREASE_SIZE(ptr, ptr->key_info[20]);\n\t\tif ((iv_size!=8) && (iv_size!=16)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid constant IV size %d, must be 8 or 16\\n\", (u32) iv_size));\n\t\t\tptr->key_info[20] = 16;\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tgf_bs_read_data(bs, ptr->key_info+21, iv_size);\n\t}\n\telse if ((iv_size!=0) && (iv_size!=8) && (iv_size!=16)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid IV size %d, must be 0, 8 or 16\\n\", (u32) iv_size));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "static inline int object_common2(UNSERIALIZE_PARAMETER, long elements)\n{\n\tzval *retval_ptr = NULL;\n\tzval fname;\n\tif (Z_TYPE_PP(rval) != IS_OBJECT) {\n\t\treturn 0;\n\t}\n\tif (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_OBJPROP_PP(rval), elements, 1)) {\n\t    if(Z_TYPE_PP(rval) == IS_OBJECT) {\n\t       zend_hash_clean(Z_OBJPROP_PP(rval));\n\t       zend_object_store_ctor_failed(*rval TSRMLS_CC);\n\t    }\n\t    ZVAL_NULL(*rval);\n\t\treturn 0;\n\t}\n    if (Z_TYPE_PP(rval) != IS_OBJECT) {\n        return 0;\n    }\n\tif (Z_OBJCE_PP(rval) != PHP_IC_ENTRY &&\n\t\tzend_hash_exists(&Z_OBJCE_PP(rval)->function_table, \"__wakeup\", sizeof(\"__wakeup\"))) {\n\t\tINIT_PZVAL(&fname);\n\t\tZVAL_STRINGL(&fname, \"__wakeup\", sizeof(\"__wakeup\") - 1, 0);\n\t\tBG(serialize_lock)++;\n\t\tcall_user_function_ex(CG(function_table), rval, &fname, &retval_ptr, 0, 0, 1, NULL TSRMLS_CC);\n\t\tBG(serialize_lock)--;\n\t}\n\tif (retval_ptr) {\n\t\tzval_ptr_dtor(&retval_ptr);\n\t}\n\tif (EG(exception)) {\n\t\treturn 0;\n\t}\n\treturn finish_nested_data(UNSERIALIZE_PASSTHRU);\n}", "target": 0}
{"code": "sanitize (GPtrArray *array)\n{\n        int i;\n        GPtrArray *new;\n        g_debug (\"before sanitizing\");\n        for (i = 0; i < array->len; ++i) {\n                if (array->pdata[i]) {\n                        print_configuration (array->pdata[i], \"before\");\n                }\n        }\n        for (i = 1; i < array->len; ++i) {\n                int j;\n                for (j = 0; j < i; ++j) {\n                        GnomeRRConfig *this = array->pdata[j];\n                        GnomeRRConfig *other = array->pdata[i];\n                        if (this && other && gnome_rr_config_equal (this, other)) {\n                                g_debug (\"removing duplicate configuration\");\n                                gnome_rr_config_free (this);\n                                array->pdata[j] = NULL;\n                                break;\n                        }\n                }\n        }\n        for (i = 0; i < array->len; ++i) {\n                GnomeRRConfig *config = array->pdata[i];\n                if (config) {\n                        gboolean all_off = TRUE;\n                        int j;\n                        for (j = 0; config->outputs[j] != NULL; ++j) {\n                                if (config->outputs[j]->on)\n                                        all_off = FALSE;\n                        }\n                        if (all_off) {\n                                gnome_rr_config_free (array->pdata[i]);\n                                array->pdata[i] = NULL;\n                        }\n                }\n        }\n        new = g_ptr_array_new ();\n        for (i = 0; i < array->len; ++i) {\n                if (array->pdata[i]) {\n                        g_ptr_array_add (new, array->pdata[i]);\n                        print_configuration (array->pdata[i], \"Final\");\n                }\n        }\n        if (new->len > 0) {\n                g_ptr_array_add (new, NULL);\n        } else {\n                g_ptr_array_free (new, TRUE);\n                new = NULL;\n        }\n        g_ptr_array_free (array, TRUE);\n        return new;\n}", "target": 0}
{"code": "MONGO_EXPORT int bson_append_symbol_n( bson *b, const char *name, const char *value, int len ) {\n    return bson_append_string_base( b, name, value, len, BSON_SYMBOL );\n}", "target": 1}
{"code": "beep_print(netdissect_options *ndo, const u_char *bp, u_int length)\n{\n\tif (l_strnstart(\"MSG\", 4, (const char *)bp, length)) \n\t\tND_PRINT((ndo, \" BEEP MSG\"));\n\telse if (l_strnstart(\"RPY \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP RPY\"));\n\telse if (l_strnstart(\"ERR \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP ERR\"));\n\telse if (l_strnstart(\"ANS \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP ANS\"));\n\telse if (l_strnstart(\"NUL \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP NUL\"));\n\telse if (l_strnstart(\"SEQ \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP SEQ\"));\n\telse if (l_strnstart(\"END\", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP END\"));\n\telse\n\t\tND_PRINT((ndo, \" BEEP (payload or undecoded)\"));\n}", "target": 1}
{"code": "string_copy(uschar *s)\n{\nint len = Ustrlen(s) + 1;\nuschar *ss = store_get(len);\nmemcpy(ss, s, len);\nreturn ss;\n}", "target": 0}
{"code": "enum nss_status _nss_mymachines_getgrnam_r(\n                const char *name,\n                struct group *gr,\n                char *buffer, size_t buflen,\n                int *errnop) {\n        _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;\n        _cleanup_bus_message_unref_ sd_bus_message* reply = NULL;\n        _cleanup_bus_flush_close_unref_ sd_bus *bus = NULL;\n        const char *p, *e, *machine;\n        uint32_t mapped;\n        uid_t gid;\n        size_t l;\n        int r;\n        assert(name);\n        assert(gr);\n        p = startswith(name, \"vg-\");\n        if (!p)\n                goto not_found;\n        e = strrchr(p, '-');\n        if (!e || e == p)\n                goto not_found;\n        if (e - p > HOST_NAME_MAX - 1)  \n                goto not_found;\n        r = parse_gid(e + 1, &gid);\n        if (r < 0)\n                goto not_found;\n        machine = strndupa(p, e - p);\n        if (!machine_name_is_valid(machine))\n                goto not_found;\n        r = sd_bus_open_system(&bus);\n        if (r < 0)\n                goto fail;\n        r = sd_bus_call_method(bus,\n                               \"org.freedesktop.machine1\",\n                               \"/org/freedesktop/machine1\",\n                               \"org.freedesktop.machine1.Manager\",\n                               \"MapFromMachineGroup\",\n                               &error,\n                               &reply,\n                               \"su\",\n                               machine, (uint32_t) gid);\n        if (r < 0) {\n                if (sd_bus_error_has_name(&error, BUS_ERROR_NO_SUCH_GROUP_MAPPING))\n                        goto not_found;\n                goto fail;\n        }\n        r = sd_bus_message_read(reply, \"u\", &mapped);\n        if (r < 0)\n                goto fail;\n        l = sizeof(char*) + strlen(name) + 1;\n        if (buflen < l) {\n                *errnop = ENOMEM;\n                return NSS_STATUS_TRYAGAIN;\n        }\n        memzero(buffer, sizeof(char*));\n        strcpy(buffer + sizeof(char*), name);\n        gr->gr_name = buffer + sizeof(char*);\n        gr->gr_gid = gid;\n        gr->gr_passwd = (char*) \"*\"; \n        gr->gr_mem = (char**) buffer;\n        *errnop = 0;\n        return NSS_STATUS_SUCCESS;\nnot_found:\n        *errnop = 0;\n        return NSS_STATUS_NOTFOUND;\nfail:\n        *errnop = -r;\n        return NSS_STATUS_UNAVAIL;\n}", "target": 0}
{"code": "bool ItemStackMetadata::setString(const std::string &name, const std::string &var)\n{\n\tbool result = Metadata::setString(name, var);\n\tif (name == TOOLCAP_KEY)\n\t\tupdateToolCapabilities();\n\treturn result;\n}", "target": 1}
{"code": "nfsd4_getattr(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      union nfsd4_op_u *u)\n{\n\tstruct nfsd4_getattr *getattr = &u->getattr;\n\t__be32 status;\n\tstatus = fh_verify(rqstp, &cstate->current_fh, 0, NFSD_MAY_NOP);\n\tif (status)\n\t\treturn status;\n\tif (getattr->ga_bmval[1] & NFSD_WRITEONLY_ATTRS_WORD1)\n\t\treturn nfserr_inval;\n\tgetattr->ga_bmval[0] &= nfsd_suppattrs[cstate->minorversion][0];\n\tgetattr->ga_bmval[1] &= nfsd_suppattrs[cstate->minorversion][1];\n\tgetattr->ga_bmval[2] &= nfsd_suppattrs[cstate->minorversion][2];\n\tgetattr->ga_fhp = &cstate->current_fh;\n\treturn nfs_ok;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& tensor_out = context->input(1);\n    const Tensor& out_backprop = context->input(2);\n    OP_REQUIRES(context, tensor_in.dims() == 5,\n                errors::InvalidArgument(\"tensor_in must be 5-dimensional\"));\n    OP_REQUIRES(context, tensor_out.dims() == 5,\n                errors::InvalidArgument(\"tensor_out must be 5-dimensional\"));\n    OP_REQUIRES(context, out_backprop.dims() == 5,\n                errors::InvalidArgument(\"out_backprop must be 5-dimensional\"));\n    const TensorShape& output_shape = tensor_in.shape();\n    Tensor* input_backprop;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, output_shape, &input_backprop));\n    std::array<int64_t, 3> input_size{\n        {GetTensorDim(output_shape, data_format_, '2'),\n         GetTensorDim(output_shape, data_format_, '1'),\n         GetTensorDim(output_shape, data_format_, '0')}};\n    std::array<int64_t, 3> window{{GetTensorDim(ksize_, data_format_, '2'),\n                                   GetTensorDim(ksize_, data_format_, '1'),\n                                   GetTensorDim(ksize_, data_format_, '0')}};\n    std::array<int64_t, 3> stride{{GetTensorDim(stride_, data_format_, '2'),\n                                   GetTensorDim(stride_, data_format_, '1'),\n                                   GetTensorDim(stride_, data_format_, '0')}};\n    std::array<int64_t, 3> out, padding;\n    OP_REQUIRES_OK(context, Get3dOutputSize(input_size, window, stride,\n                                            padding_, &out, &padding));\n    const int64_t depth = GetTensorDim(tensor_in, data_format_, 'C');\n    const int64_t in_batch = GetTensorDim(tensor_in, data_format_, 'N');\n    TensorShape out_shape = ShapeFromFormat(data_format_, in_batch,\n                                            {{out[2], out[1], out[0]}}, depth);\n    OP_REQUIRES(\n        context, tensor_out.shape() == out_shape,\n        errors::InvalidArgument(\"Expected orig_output shape to be \", out_shape,\n                                \", but got \", tensor_out.shape()));\n    OP_REQUIRES(context, out_backprop.shape() == out_shape,\n                errors::InvalidArgument(\"Expected grad shape to be \", out_shape,\n                                        \", but got \", out_backprop.shape()));\n    LaunchMaxPooling3dGradOp<Device, T>::launch(\n        context, tensor_in, tensor_out, out_backprop, window, stride, out,\n        padding, data_format_, input_backprop);\n  }", "target": 0}
{"code": "static int truncate_inline_extent(struct inode *inode,\n\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t  struct btrfs_key *found_key,\n\t\t\t\t  const u64 item_end,\n\t\t\t\t  const u64 new_size)\n{\n\tstruct extent_buffer *leaf = path->nodes[0];\n\tint slot = path->slots[0];\n\tstruct btrfs_file_extent_item *fi;\n\tu32 size = (u32)(new_size - found_key->offset);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tfi = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n\tif (btrfs_file_extent_compression(leaf, fi) != BTRFS_COMPRESS_NONE) {\n\t\tloff_t offset = new_size;\n\t\tloff_t page_end = ALIGN(offset, PAGE_CACHE_SIZE);\n\t\tbtrfs_release_path(path);\n\t\treturn btrfs_truncate_page(inode, offset, page_end - offset, 0);\n\t}\n\tbtrfs_set_file_extent_ram_bytes(leaf, fi, size);\n\tsize = btrfs_file_extent_calc_inline_size(size);\n\tbtrfs_truncate_item(root, path, size, 1);\n\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\tinode_sub_bytes(inode, item_end + 1 - new_size);\n\treturn 0;\n}", "target": 0}
{"code": "static inline ut16 r_read_le16(const void *src) {\n\tif (!src) {\n\t\treturn UT16_MAX;\n\t}\n\tconst ut8 *s = (const ut8*)src;\n\treturn (((ut16)s[1]) << 8) | (((ut16)s[0]) << 0);\n}", "target": 0}
{"code": "static int msr_open(struct inode *inode, struct file *file)\n{\n\tunsigned int cpu;\n\tstruct cpuinfo_x86 *c;\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\tcpu = iminor(file->f_path.dentry->d_inode);\n\tif (cpu >= nr_cpu_ids || !cpu_online(cpu))\n\t\treturn -ENXIO;\t\n\tc = &cpu_data(cpu);\n\tif (!cpu_has(c, X86_FEATURE_MSR))\n\t\treturn -EIO;\t\n\treturn 0;\n}", "target": 0}
{"code": "static void *bpf_any_get(void *raw, enum bpf_type type)\n{\n\tswitch (type) {\n\tcase BPF_TYPE_PROG:\n\t\tatomic_inc(&((struct bpf_prog *)raw)->aux->refcnt);\n\t\tbreak;\n\tcase BPF_TYPE_MAP:\n\t\tbpf_map_inc(raw, true);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\treturn raw;\n}", "target": 1}
{"code": "start_pass_merged_upsample(j_decompress_ptr cinfo)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  upsample->spare_full = FALSE;\n  upsample->rows_to_go = cinfo->output_height;\n}", "target": 1}
{"code": "static ssize_t driver_override_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\treturn sprintf(buf, \"%s\\n\", pdev->driver_override);\n}", "target": 1}
{"code": "txid_current_snapshot(PG_FUNCTION_ARGS)\n{\n\tTxidSnapshot *snap;\n\tuint32\t\tnxip,\n\t\t\t\ti,\n\t\t\t\tsize;\n\tTxidEpoch\tstate;\n\tSnapshot\tcur;\n\tcur = GetActiveSnapshot();\n\tif (cur == NULL)\n\t\telog(ERROR, \"no active snapshot set\");\n\tload_xid_epoch(&state);\n\tStaticAssertStmt(MAX_BACKENDS * 2 <= TXID_SNAPSHOT_MAX_NXIP,\n\t\t\t\t\t \"possible overflow in txid_current_snapshot()\");\n\tnxip = cur->xcnt;\n\tsize = TXID_SNAPSHOT_SIZE(nxip);\n\tsnap = palloc(size);\n\tSET_VARSIZE(snap, size);\n\tsnap->xmin = convert_xid(cur->xmin, &state);\n\tsnap->xmax = convert_xid(cur->xmax, &state);\n\tsnap->nxip = nxip;\n\tfor (i = 0; i < nxip; i++)\n\t\tsnap->xip[i] = convert_xid(cur->xip[i], &state);\n\tsort_snapshot(snap);\n\tPG_RETURN_POINTER(snap);\n}", "target": 0}
{"code": "ActivationPtr createActivation(Protobuf::Arena& arena, const StreamInfo::StreamInfo& info,\n                               const Http::RequestHeaderMap* request_headers,\n                               const Http::ResponseHeaderMap* response_headers,\n                               const Http::ResponseTrailerMap* response_trailers) {\n  auto activation = std::make_unique<Activation>();\n  activation->InsertValueProducer(Request,\n                                  std::make_unique<RequestWrapper>(arena, request_headers, info));\n  activation->InsertValueProducer(Response, std::make_unique<ResponseWrapper>(\n                                                arena, response_headers, response_trailers, info));\n  activation->InsertValueProducer(Connection, std::make_unique<ConnectionWrapper>(info));\n  activation->InsertValueProducer(Upstream, std::make_unique<UpstreamWrapper>(info));\n  activation->InsertValueProducer(Source, std::make_unique<PeerWrapper>(info, false));\n  activation->InsertValueProducer(Destination, std::make_unique<PeerWrapper>(info, true));\n  activation->InsertValueProducer(Metadata,\n                                  std::make_unique<MetadataProducer>(info.dynamicMetadata()));\n  activation->InsertValueProducer(FilterState,\n                                  std::make_unique<FilterStateWrapper>(info.filterState()));\n  return activation;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& min_input_tensor = context->input(1);\n    const Tensor& max_input_tensor = context->input(2);\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(min_input_tensor.shape()),\n                errors::InvalidArgument(\n                    \"min_input shape must be rank 0 but is rank \",\n                    min_input_tensor.dims(),\n                    \", received shape: \", min_input_tensor.shape()));\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(max_input_tensor.shape()),\n                errors::InvalidArgument(\n                    \"max_input shape must be rank 0 but is rank \",\n                    max_input_tensor.dims(),\n                    \", received shape: \", max_input_tensor.shape()));\n    const float min_input = context->input(1).scalar<float>()();\n    const float max_input = context->input(2).scalar<float>()();\n    MaxPoolingOp<Device, T>::Compute(context);\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));\n    output_min->flat<float>()(0) = min_input;\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max));\n    output_max->flat<float>()(0) = max_input;\n  }", "target": 0}
{"code": "unsigned paravirt_patch_call(void *insnbuf,\n\t\t\t     const void *target, u16 tgt_clobbers,\n\t\t\t     unsigned long addr, u16 site_clobbers,\n\t\t\t     unsigned len)\n{\n\tstruct branch *b = insnbuf;\n\tunsigned long delta = (unsigned long)target - (addr+5);\n\tif (tgt_clobbers & ~site_clobbers)\n\t\treturn len;\t\n\tif (len < 5)\n\t\treturn len;\t\n\tb->opcode = 0xe8; \n\tb->delta = delta;\n\tBUILD_BUG_ON(sizeof(*b) != 5);\n\treturn 5;\n}", "target": 1}
{"code": "static void ip_cmsg_recv_checksum(struct msghdr *msg, struct sk_buff *skb,\n\t\t\t\t  int tlen, int offset)\n{\n\t__wsum csum = skb->csum;\n\tif (skb->ip_summed != CHECKSUM_COMPLETE)\n\t\treturn;\n\tif (offset != 0)\n\t\tcsum = csum_sub(csum,\n\t\t\t\tcsum_partial(skb_transport_header(skb) + tlen,\n\t\t\t\t\t     offset, 0));\n\tput_cmsg(msg, SOL_IP, IP_CHECKSUM, sizeof(__wsum), &csum);\n}", "target": 1}
{"code": "void uverbs_user_mmap_disassociate(struct ib_uverbs_file *ufile)\n{\n\tstruct rdma_umap_priv *priv, *next_priv;\n\tlockdep_assert_held(&ufile->hw_destroy_rwsem);\n\twhile (1) {\n\t\tstruct mm_struct *mm = NULL;\n\t\tmutex_lock(&ufile->umap_lock);\n\t\twhile (!list_empty(&ufile->umaps)) {\n\t\t\tint ret;\n\t\t\tpriv = list_first_entry(&ufile->umaps,\n\t\t\t\t\t\tstruct rdma_umap_priv, list);\n\t\t\tmm = priv->vma->vm_mm;\n\t\t\tret = mmget_not_zero(mm);\n\t\t\tif (!ret) {\n\t\t\t\tlist_del_init(&priv->list);\n\t\t\t\tmm = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&ufile->umap_lock);\n\t\tif (!mm)\n\t\t\treturn;\n\t\tdown_write(&mm->mmap_sem);\n\t\tif (!mmget_still_valid(mm))\n\t\t\tgoto skip_mm;\n\t\tmutex_lock(&ufile->umap_lock);\n\t\tlist_for_each_entry_safe (priv, next_priv, &ufile->umaps,\n\t\t\t\t\t  list) {\n\t\t\tstruct vm_area_struct *vma = priv->vma;\n\t\t\tif (vma->vm_mm != mm)\n\t\t\t\tcontinue;\n\t\t\tlist_del_init(&priv->list);\n\t\t\tzap_vma_ptes(vma, vma->vm_start,\n\t\t\t\t     vma->vm_end - vma->vm_start);\n\t\t\tvma->vm_flags &= ~(VM_SHARED | VM_MAYSHARE);\n\t\t}\n\t\tmutex_unlock(&ufile->umap_lock);\n\tskip_mm:\n\t\tup_write(&mm->mmap_sem);\n\t\tmmput(mm);\n\t}\n}", "target": 0}
{"code": "    setSanMatchers(std::vector<envoy::type::matcher::v3::StringMatcher> san_matchers) {\n      san_matchers_ = san_matchers;\n      return *this;\n    }", "target": 1}
{"code": "OGRKMLLayer::OGRKMLLayer( const char * pszName,\n                          OGRSpatialReference *poSRSIn, bool bWriterIn,\n                          OGRwkbGeometryType eReqType,\n                          OGRKMLDataSource *poDSIn ) :\n    poDS_(poDSIn),\n    poSRS_(poSRSIn ? new OGRSpatialReference(nullptr) : nullptr),\n    poCT_(nullptr),\n    poFeatureDefn_(new OGRFeatureDefn( pszName )),\n    iNextKMLId_(0),\n    nTotalKMLCount_(-1),\n    bWriter_(bWriterIn),\n    nLayerNumber_(0),\n    nWroteFeatureCount_(0),\n    bSchemaWritten_(false),\n    pszName_(CPLStrdup(pszName)),\n    nLastAsked(-1),\n    nLastCount(-1)\n{\n    if( poSRSIn != nullptr )\n    {\n        poSRS_->SetWellKnownGeogCS( \"WGS84\" );\n        poSRS_->SetAxisMappingStrategy(OAMS_TRADITIONAL_GIS_ORDER);\n        if( !poSRS_->IsSame(poSRSIn) )\n        {\n            poCT_ = OGRCreateCoordinateTransformation( poSRSIn, poSRS_ );\n            if( poCT_ == nullptr && poDSIn->IsFirstCTError() )\n            {\n                char *pszWKT = nullptr;\n                poSRSIn->exportToPrettyWkt( &pszWKT, FALSE );\n                CPLError(\n                    CE_Warning, CPLE_AppDefined,\n                    \"Failed to create coordinate transformation between the \"\n                    \"input coordinate system and WGS84.  This may be because \"\n                    \"they are not transformable.  \"\n                    \"KML geometries may not render correctly.  \"\n                    \"This message will not be issued any more.\"\n                    \"\\nSource:\\n%s\\n\",\n                    pszWKT );\n                CPLFree( pszWKT );\n                poDSIn->IssuedFirstCTError();\n            }\n        }\n    }\n    SetDescription( poFeatureDefn_->GetName() );\n    poFeatureDefn_->Reference();\n    poFeatureDefn_->SetGeomType( eReqType );\n    if( poFeatureDefn_->GetGeomFieldCount() != 0 )\n        poFeatureDefn_->GetGeomFieldDefn(0)->SetSpatialRef(poSRS_);\n    OGRFieldDefn oFieldName( \"Name\", OFTString );\n    poFeatureDefn_->AddFieldDefn( &oFieldName );\n    OGRFieldDefn oFieldDesc( \"Description\", OFTString );\n    poFeatureDefn_->AddFieldDefn( &oFieldDesc );\n    bClosedForWriting = !bWriterIn;\n}", "target": 0}
{"code": "chdlc_print(netdissect_options *ndo, register const u_char *p, u_int length)\n{\n\tu_int proto;\n\tconst u_char *bp = p;\n\tif (length < CHDLC_HDRLEN)\n\t\tgoto trunc;\n\tND_TCHECK2(*p, CHDLC_HDRLEN);\n\tproto = EXTRACT_16BITS(&p[2]);\n\tif (ndo->ndo_eflag) {\n                ND_PRINT((ndo, \"%s, ethertype %s (0x%04x), length %u: \",\n                       tok2str(chdlc_cast_values, \"0x%02x\", p[0]),\n                       tok2str(ethertype_values, \"Unknown\", proto),\n                       proto,\n                       length));\n\t}\n\tlength -= CHDLC_HDRLEN;\n\tp += CHDLC_HDRLEN;\n\tswitch (proto) {\n\tcase ETHERTYPE_IP:\n\t\tip_print(ndo, p, length);\n\t\tbreak;\n\tcase ETHERTYPE_IPV6:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\tcase CHDLC_TYPE_SLARP:\n\t\tchdlc_slarp_print(ndo, p, length);\n\t\tbreak;\n#if 0\n\tcase CHDLC_TYPE_CDP:\n\t\tchdlc_cdp_print(p, length);\n\t\tbreak;\n#endif\n        case ETHERTYPE_MPLS:\n        case ETHERTYPE_MPLS_MULTI:\n                mpls_print(ndo, p, length);\n\t\tbreak;\n        case ETHERTYPE_ISO:\n                if (length < 2)\n                    goto trunc;\n                ND_TCHECK_16BITS(p);\n                if (*(p+1) == 0x81 ||\n                    *(p+1) == 0x82 ||\n                    *(p+1) == 0x83)\n                    isoclns_print(ndo, p + 1, length - 1);\n                else\n                    isoclns_print(ndo, p, length);\n                break;\n\tdefault:\n                if (!ndo->ndo_eflag)\n                        ND_PRINT((ndo, \"unknown CHDLC protocol (0x%04x)\", proto));\n                break;\n\t}\n\treturn (CHDLC_HDRLEN);\ntrunc:\n\tND_PRINT((ndo, \"[|chdlc]\"));\n\treturn ndo->ndo_snapend - bp;\n}", "target": 0}
{"code": "static int openssl_static_locks_install(void)\n{\n    int result;\n    if (openssl_locks != NULL)\n    {\n        LogInfo(\"Locks already initialized\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        openssl_locks = malloc(CRYPTO_num_locks() * sizeof(LOCK_HANDLE));\n        if (openssl_locks == NULL)\n        {\n            LogError(\"Failed to allocate locks\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            int i;\n            for (i = 0; i < CRYPTO_num_locks(); i++)\n            {\n                openssl_locks[i] = Lock_Init();\n                if (openssl_locks[i] == NULL)\n                {\n                    LogError(\"Failed to allocate lock %d\", i);\n                    break;\n                }\n            }\n            if (i != CRYPTO_num_locks())\n            {\n                int j;\n                for (j = 0; j < i; j++)\n                {\n                    Lock_Deinit(openssl_locks[j]);\n                }\n                result = MU_FAILURE;\n            }\n            else\n            {\n                CRYPTO_set_locking_callback(openssl_static_locks_lock_unlock_cb);\n                result = 0;\n            }\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "spaddr_print_ip(netdissect_options *ndo,\n\t        const struct arp_pkthdr *ap, u_short pro)\n{\n\tif (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)\n\t\tND_PRINT((ndo, \"<wrong proto type>\"));\n\telse if (PROTO_LEN(ap) != 4)\n\t\tND_PRINT((ndo, \"<wrong len>\"));\n\telse\n\t\tND_PRINT((ndo, \"%s\", ipaddr_string(ndo, SPA(ap))));\n}", "target": 0}
{"code": "static struct block_device *ext3_blkdev_get(dev_t dev, struct super_block *sb)\n{\n\tstruct block_device *bdev;\n\tchar b[BDEVNAME_SIZE];\n\tbdev = blkdev_get_by_dev(dev, FMODE_READ|FMODE_WRITE|FMODE_EXCL, sb);\n\tif (IS_ERR(bdev))\n\t\tgoto fail;\n\treturn bdev;\nfail:\n\text3_msg(sb, \"error: failed to open journal device %s: %ld\",\n\t\t__bdevname(dev, b), PTR_ERR(bdev));\n\treturn NULL;\n}", "target": 1}
{"code": "static gpa_t FNAME(gva_to_gpa_nested)(struct kvm_vcpu *vcpu, gva_t vaddr,\n\t\t\t\t      u32 access,\n\t\t\t\t      struct x86_exception *exception)\n{\n\tstruct guest_walker walker;\n\tgpa_t gpa = UNMAPPED_GVA;\n\tint r;\n\tr = FNAME(walk_addr_nested)(&walker, vcpu, vaddr, access);\n\tif (r) {\n\t\tgpa = gfn_to_gpa(walker.gfn);\n\t\tgpa |= vaddr & ~PAGE_MASK;\n\t} else if (exception)\n\t\t*exception = walker.fault;\n\treturn gpa;\n}", "target": 0}
{"code": "const FieldID& activeUnionMemberId(const void* object, ptrdiff_t offset) {\n  return *reinterpret_cast<const FieldID*>(\n      offset + static_cast<const char*>(object));\n}", "target": 1}
{"code": "TfLiteStatus EvalGatherNd(TfLiteContext* context,\n                          const TfLiteEvalTensor* params,\n                          const TfLiteEvalTensor* indices,\n                          TfLiteEvalTensor* output) {\n  switch (params->type) {\n    case kTfLiteFloat32:\n      return GatherNd<float, IndicesT>(params, indices, output);\n      break;\n    case kTfLiteInt8:\n      return GatherNd<int8_t, IndicesT>(params, indices, output);\n      break;\n    default:\n      TF_LITE_KERNEL_LOG(context,\n                         \"Params type '%s' are not supported by gather_nd.\",\n                         TfLiteTypeGetName(params->type));\n      return kTfLiteError;\n  }\n}", "target": 1}
{"code": "FastCGIServer::FastCGIServer(const std::string &address,\n                             int port,\n                             int workers,\n                             bool useFileSocket)\n  : Server(address, port),\n    m_worker(&m_eventBaseManager),\n    m_dispatcher(workers, workers,\n                 RuntimeOption::ServerThreadDropCacheTimeoutSeconds,\n                 RuntimeOption::ServerThreadDropStack,\n                 this,\n                 RuntimeOption::ServerThreadJobLIFOSwitchThreshold,\n                 RuntimeOption::ServerThreadJobMaxQueuingMilliSeconds,\n                 RequestPriority::k_numPriorities) {\n  folly::SocketAddress sock_addr;\n  if (useFileSocket) {\n    sock_addr.setFromPath(address);\n  } else if (address.empty()) {\n    sock_addr.setFromLocalPort(port);\n  } else {\n    sock_addr.setFromHostPort(address, port);\n  }\n  m_socketConfig.bindAddress = sock_addr;\n  m_socketConfig.acceptBacklog = RuntimeOption::ServerBacklog;\n  std::chrono::seconds timeout;\n  if (RuntimeOption::ConnectionTimeoutSeconds >= 0) {\n    timeout = std::chrono::seconds(RuntimeOption::ConnectionTimeoutSeconds);\n  } else {\n    timeout = std::chrono::seconds(120);\n  }\n  m_socketConfig.connectionIdleTimeout = timeout;\n}", "target": 1}
{"code": "boost::optional<SaplingOutgoingPlaintext> SaplingOutgoingPlaintext::decrypt(\n    const SaplingOutCiphertext &ciphertext,\n    const uint256& ovk,\n    const uint256& cv,\n    const uint256& cm,\n    const uint256& epk\n)\n{\n    auto pt = AttemptSaplingOutDecryption(ciphertext, ovk, cv, cm, epk);\n    if (!pt) {\n        return boost::none;\n    }\n    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n    ss << pt.get();\n    SaplingOutgoingPlaintext ret;\n    ss >> ret;\n    assert(ss.size() == 0);\n    return ret;\n}", "target": 1}
{"code": "int iwch_cxgb3_ofld_send(struct t3cdev *tdev, struct sk_buff *skb)\n{\n\tint\terror = 0;\n\tstruct cxio_rdev *rdev;\n\trdev = (struct cxio_rdev *)tdev->ulp;\n\tif (cxio_fatal_error(rdev)) {\n\t\tkfree_skb(skb);\n\t\treturn -EIO;\n\t}\n\terror = cxgb3_ofld_send(tdev, skb);\n\tif (error < 0)\n\t\tkfree_skb(skb);\n\treturn error;\n}", "target": 1}
{"code": "static void copy_to_user_state(struct xfrm_state *x, struct xfrm_usersa_info *p)\n{\n\tmemset(p, 0, sizeof(*p));\n\tmemcpy(&p->id, &x->id, sizeof(p->id));\n\tmemcpy(&p->sel, &x->sel, sizeof(p->sel));\n\tmemcpy(&p->lft, &x->lft, sizeof(p->lft));\n\tmemcpy(&p->curlft, &x->curlft, sizeof(p->curlft));\n\tmemcpy(&p->stats, &x->stats, sizeof(p->stats));\n\tmemcpy(&p->saddr, &x->props.saddr, sizeof(p->saddr));\n\tp->mode = x->props.mode;\n\tp->replay_window = x->props.replay_window;\n\tp->reqid = x->props.reqid;\n\tp->family = x->props.family;\n\tp->flags = x->props.flags;\n\tp->seq = x->km.seq;\n}", "target": 0}
{"code": "bool QODBCResult::prepare(const QString& query)\n{\n    Q_D(QODBCResult);\n    setActive(false);\n    setAt(QSql::BeforeFirstRow);\n    SQLRETURN r;\n    d->rInf.clear();\n    if (d->hStmt && d->isStmtHandleValid()) {\n        r = SQLFreeHandle(SQL_HANDLE_STMT, d->hStmt);\n        if (r != SQL_SUCCESS) {\n            qSqlWarning(\"QODBCResult::prepare: Unable to close statement\"_L1, d);\n            return false;\n        }\n    }\n    r  = SQLAllocHandle(SQL_HANDLE_STMT,\n                         d->dpDbc(),\n                         &d->hStmt);\n    if (r != SQL_SUCCESS) {\n        qSqlWarning(\"QODBCResult::prepare: Unable to allocate statement handle\"_L1, d);\n        return false;\n    }\n    d->updateStmtHandleState();\n    if (isForwardOnly()) {\n        r = SQLSetStmtAttr(d->hStmt,\n                            SQL_ATTR_CURSOR_TYPE,\n                            (SQLPOINTER)SQL_CURSOR_FORWARD_ONLY,\n                            SQL_IS_UINTEGER);\n    } else {\n        r = SQLSetStmtAttr(d->hStmt,\n                            SQL_ATTR_CURSOR_TYPE,\n                            (SQLPOINTER)SQL_CURSOR_STATIC,\n                            SQL_IS_UINTEGER);\n    }\n    if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) {\n        setLastError(qMakeError(QCoreApplication::translate(\"QODBCResult\",\n            \"QODBCResult::reset: Unable to set 'SQL_CURSOR_STATIC' as statement attribute. \"\n            \"Please check your ODBC driver configuration\"), QSqlError::StatementError, d));\n        return false;\n    }\n    r = SQLPrepare(d->hStmt,\n                    toSQLTCHAR(query).data(),\n                    (SQLINTEGER) query.length());\n    if (r != SQL_SUCCESS) {\n        setLastError(qMakeError(QCoreApplication::translate(\"QODBCResult\",\n                     \"Unable to prepare statement\"), QSqlError::StatementError, d));\n        return false;\n    }\n    return true;\n}", "target": 1}
{"code": "void ACLosslessScan::ParseMCU(struct Line **prev,struct Line **top)\n{ \n#if ACCUSOFT_CODE\n  UBYTE c;\n  for(c = 0;c < m_ucCount;c++) {\n    struct QMContextSet &contextset = m_Context[m_ucContext[c]];\n    struct Line *line = top[c];\n    struct Line *pline= prev[c];\n    UBYTE ym = m_ucMCUHeight[c];\n    ULONG  x = m_ulX[c];\n    class PredictorBase *mcupred = m_pPredict[c];\n    LONG *lp = line->m_pData + x;\n    LONG *pp = (pline)?(pline->m_pData + x):(NULL);\n    do {\n      class PredictorBase *pred = mcupred;\n      UBYTE xm = m_ucMCUWidth[c];\n      do {\n        LONG v;\n        struct QMContextSet::ContextZeroSet &zset = contextset.ClassifySignZero(m_plDa[c][ym-1],m_plDb[c][x],\n                                                                                m_ucSmall[c],m_ucLarge[c]);\n        if (m_Coder.Get(zset.S0)) {\n          LONG sz   = 0;\n          bool sign = m_Coder.Get(zset.SS); \n          if (m_Coder.Get((sign)?(zset.SN):(zset.SP))) {\n            struct QMContextSet::MagnitudeSet &mset = contextset.ClassifyMagnitude(m_plDb[c][x],m_ucLarge[c]);\n            int  i = 0;\n            LONG m = 2;\n            while(m_Coder.Get(mset.X[i])) {\n              m <<= 1;\n              i++;\n            }\n            m >>= 1;\n            sz  = m;\n            while((m >>= 1)) {\n              if (m_Coder.Get(mset.M[i])) {\n                sz |= m;\n              }\n            }\n          }\n          if (sign) {\n            v = -sz - 1;\n          } else {\n            v =  sz + 1;\n          }\n        } else {\n          v = 0;\n        }\n        lp[0] = pred->DecodeSample(v,lp,pp);\n        m_plDb[c][x]    = v;\n        m_plDa[c][ym-1] = v;\n      } while(--xm && (lp++,pp++,x++,pred = pred->MoveRight(),true));\n    } while(--ym && (pp = line->m_pData + (x = m_ulX[c]),line = (line->m_pNext)?(line->m_pNext):(line),\n                     lp = line->m_pData + x,mcupred = mcupred->MoveDown(),true));\n  }\n#else\n  NOREF(prev);\n  NOREF(top);\n#endif\n}", "target": 1}
{"code": "void rds_inc_info_copy(struct rds_incoming *inc,\n\t\t       struct rds_info_iterator *iter,\n\t\t       __be32 saddr, __be32 daddr, int flip)\n{\n\tstruct rds_info_message minfo;\n\tminfo.seq = be64_to_cpu(inc->i_hdr.h_sequence);\n\tminfo.len = be32_to_cpu(inc->i_hdr.h_len);\n\tif (flip) {\n\t\tminfo.laddr = daddr;\n\t\tminfo.faddr = saddr;\n\t\tminfo.lport = inc->i_hdr.h_dport;\n\t\tminfo.fport = inc->i_hdr.h_sport;\n\t} else {\n\t\tminfo.laddr = saddr;\n\t\tminfo.faddr = daddr;\n\t\tminfo.lport = inc->i_hdr.h_sport;\n\t\tminfo.fport = inc->i_hdr.h_dport;\n\t}\n\tminfo.flags = 0;\n\trds_info_copy(iter, &minfo, sizeof(minfo));\n}", "target": 0}
{"code": "extract_one_file(EpubDocument* epub_document,GError ** error)\n{\n    GFile * outfile ;\n    gsize writesize = 0;\n    GString * gfilepath ;\n    unz_file_info64 info ;\n    gchar* directory;\n    GString* dir_create;\n    GFileOutputStream * outstream ;\n    if ( unzOpenCurrentFile(epub_document->epubDocument) != UNZ_OK )\n    {\n            return FALSE ;\n    }\n    gboolean result = TRUE;\n    gpointer currentfilename = g_malloc0(512);\n    unzGetCurrentFileInfo64(epub_document->epubDocument,&info,currentfilename,512,NULL,0,NULL,0) ;\n    directory = g_strrstr(currentfilename,\"/\") ;\n    if ( directory != NULL )\n        directory++;\n    gfilepath = g_string_new(epub_document->tmp_archive_dir) ;\n    g_string_append_printf(gfilepath,\"/%s\",(gchar*)currentfilename);\n    if (directory != NULL && *directory == '\\0')\n    {\n        g_mkdir(gfilepath->str,0777);\n        goto out;\n    }\n    else if (directory != NULL && *directory != '\\0' ) {\n        gchar* createdir = currentfilename;\n        gchar *createdirname = g_malloc0(strlen(currentfilename));\n        gchar *createdirnametemp = createdirname;\n        while ( createdir != directory ) {\n            (*createdirnametemp) = (*createdir);\n            createdirnametemp++;\n            createdir++;\n        }\n        (*createdirnametemp) = '\\0';\n        dir_create = g_string_new(epub_document->tmp_archive_dir);\n        g_string_append_printf(dir_create,\"/%s\",createdirname);\n        g_free(createdirname);\n        g_mkdir_with_parents(dir_create->str,0777);\n        g_string_free(dir_create,TRUE);\n    }\n    outfile = g_file_new_for_path(gfilepath->str);\n    outstream = g_file_create(outfile,G_FILE_CREATE_PRIVATE,NULL,error);\n    gpointer buffer = g_malloc0(512);\n    while ( (writesize = unzReadCurrentFile(epub_document->epubDocument,buffer,512) ) != 0 )\n    {\n        if ( g_output_stream_write((GOutputStream*)outstream,buffer,writesize,NULL,error) == -1 )\n        {\n            result = FALSE;\n            break;\n        }\n    }\n    g_free(buffer);\n    g_output_stream_close((GOutputStream*)outstream,NULL,error);\n    g_object_unref(outfile) ;\n    g_object_unref(outstream) ;\nout:\n    unzCloseCurrentFile (epub_document->epubDocument) ;\n    g_string_free(gfilepath,TRUE);\n    g_free(currentfilename);\n    return result;\n}", "target": 1}
{"code": "string PacketReader::getLabel(unsigned int recurs)\n{\n  string ret;\n  ret.reserve(40);\n  getLabelFromContent(d_content, d_pos, ret, recurs++);\n  return ret;\n}", "target": 1}
{"code": "static void timelib_eat_until_separator(char **ptr)\n{\n\twhile (strchr(\" \\t.,:;/-0123456789\", **ptr) == NULL) {\n\t\t++*ptr;\n\t}\n}", "target": 0}
{"code": "bool cli_check_msdfs_proxy(TALLOC_CTX *ctx,\n\t\t\t\tstruct cli_state *cli,\n\t\t\t\tconst char *sharename,\n\t\t\t\tchar **pp_newserver,\n\t\t\t\tchar **pp_newshare,\n\t\t\t\tbool force_encrypt,\n\t\t\t\tconst char *username,\n\t\t\t\tconst char *password,\n\t\t\t\tconst char *domain)\n{\n\tstruct client_dfs_referral *refs = NULL;\n\tsize_t num_refs = 0;\n\tsize_t consumed = 0;\n\tchar *fullpath = NULL;\n\tbool res;\n\tuint16_t cnum;\n\tchar *newextrapath = NULL;\n\tNTSTATUS status;\n\tconst char *remote_name;\n\tif (!cli || !sharename) {\n\t\treturn false;\n\t}\n\tremote_name = smbXcli_conn_remote_name(cli->conn);\n\tcnum = cli_state_get_tid(cli);\n\tif (strequal(sharename, \"IPC$\")) {\n\t\treturn false;\n\t}\n\tfullpath = talloc_asprintf(ctx, \"\\\\%s\\\\%s\", remote_name, sharename);\n\tif (!fullpath) {\n\t\treturn false;\n\t}\n\tif (!NT_STATUS_IS_OK(cli_tree_connect(cli, \"IPC$\", \"IPC\", NULL, 0))) {\n\t\treturn false;\n\t}\n\tif (force_encrypt) {\n\t\tstatus = cli_cm_force_encryption(cli,\n\t\t\t\t\tusername,\n\t\t\t\t\tpassword,\n\t\t\t\t\tdomain,\n\t\t\t\t\t\"IPC$\");\n\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tstatus = cli_dfs_get_referral(ctx, cli, fullpath, &refs,\n\t\t\t\t      &num_refs, &consumed);\n\tres = NT_STATUS_IS_OK(status);\n\tstatus = cli_tdis(cli);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\treturn false;\n\t}\n\tcli_state_set_tid(cli, cnum);\n\tif (!res || !num_refs) {\n\t\treturn false;\n\t}\n\tif (!refs[0].dfspath) {\n\t\treturn false;\n\t}\n\tif (!split_dfs_path(ctx, refs[0].dfspath, pp_newserver,\n\t\t\t    pp_newshare, &newextrapath)) {\n\t\treturn false;\n\t}\n\tif (strequal(remote_name, *pp_newserver) &&\n\t\t\tstrequal(sharename, *pp_newshare)) {\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 0}
{"code": "int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gid, mode_t mode) {\n        _cleanup_close_ int fd;\n        int r;\n        assert(path);\n        if (parents)\n                mkdir_parents(path, 0755);\n        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY,\n                        (mode == 0 || mode == MODE_INVALID) ? 0644 : mode);\n        if (fd < 0)\n                return -errno;\n        if (mode != MODE_INVALID) {\n                r = fchmod(fd, mode);\n                if (r < 0)\n                        return -errno;\n        }\n        if (uid != UID_INVALID || gid != GID_INVALID) {\n                r = fchown(fd, uid, gid);\n                if (r < 0)\n                        return -errno;\n        }\n        if (stamp != USEC_INFINITY) {\n                struct timespec ts[2];\n                timespec_store(&ts[0], stamp);\n                ts[1] = ts[0];\n                r = futimens(fd, ts);\n        } else\n                r = futimens(fd, NULL);\n        if (r < 0)\n                return -errno;\n        return 0;\n}", "target": 0}
{"code": "mark_context_stack(mrb_state *mrb, struct mrb_context *c)\n{\n  size_t i;\n  size_t e;\n  if (c->stack == NULL) return;\n  e = c->stack - c->stbase;\n  if (c->ci) e += c->ci->nregs;\n  if (c->stbase + e > c->stend) e = c->stend - c->stbase;\n  for (i=0; i<e; i++) {\n    mrb_value v = c->stbase[i];\n    if (!mrb_immediate_p(v)) {\n      if (mrb_basic_ptr(v)->tt == MRB_TT_FREE) {\n        c->stbase[i] = mrb_nil_value();\n      }\n      else {\n        mrb_gc_mark(mrb, mrb_basic_ptr(v));\n      }\n    }\n  }\n}", "target": 1}
{"code": "void sev_es_init_vmcb(struct vcpu_svm *svm)\n{\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\tsvm->vmcb->control.nested_ctl |= SVM_NESTED_CTL_SEV_ES_ENABLE;\n\tsvm->vmcb->control.virt_ext |= LBR_CTL_ENABLE_MASK;\n\tsvm->vmcb->control.vmsa_pa = __pa(svm->vmsa);\n\tsvm_clr_intercept(svm, INTERCEPT_CR0_READ);\n\tsvm_clr_intercept(svm, INTERCEPT_CR4_READ);\n\tsvm_clr_intercept(svm, INTERCEPT_CR8_READ);\n\tsvm_clr_intercept(svm, INTERCEPT_CR0_WRITE);\n\tsvm_clr_intercept(svm, INTERCEPT_CR4_WRITE);\n\tsvm_clr_intercept(svm, INTERCEPT_CR8_WRITE);\n\tsvm_clr_intercept(svm, INTERCEPT_SELECTIVE_CR0);\n\tsvm_set_intercept(svm, TRAP_EFER_WRITE);\n\tsvm_set_intercept(svm, TRAP_CR0_WRITE);\n\tsvm_set_intercept(svm, TRAP_CR4_WRITE);\n\tsvm_set_intercept(svm, TRAP_CR8_WRITE);\n\tclr_exception_intercept(svm, GP_VECTOR);\n\tsvm_clr_intercept(svm, INTERCEPT_XSETBV);\n\tset_msr_interception(vcpu, svm->msrpm, MSR_EFER, 1, 1);\n\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_CR_PAT, 1, 1);\n\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_LASTBRANCHFROMIP, 1, 1);\n\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_LASTBRANCHTOIP, 1, 1);\n\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_LASTINTFROMIP, 1, 1);\n\tset_msr_interception(vcpu, svm->msrpm, MSR_IA32_LASTINTTOIP, 1, 1);\n}", "target": 0}
{"code": "snmp_ber_encode_timeticks(snmp_packet_t *snmp_packet, uint32_t timeticks)\n{\n  return snmp_ber_encode_unsigned_integer(snmp_packet, BER_DATA_TYPE_TIMETICKS, timeticks);\n}", "target": 0}
{"code": "static int rtnl_bridge_notify(struct net_device *dev)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct sk_buff *skb;\n\tint err = -EOPNOTSUPP;\n\tif (!dev->netdev_ops->ndo_bridge_getlink)\n\t\treturn 0;\n\tskb = nlmsg_new(bridge_nlmsg_size(), GFP_ATOMIC);\n\tif (!skb) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\terr = dev->netdev_ops->ndo_bridge_getlink(skb, 0, 0, dev, 0, 0);\n\tif (err < 0)\n\t\tgoto errout;\n\tif (!skb->len)\n\t\tgoto errout;\n\trtnl_notify(skb, net, 0, RTNLGRP_LINK, NULL, GFP_ATOMIC);\n\treturn 0;\nerrout:\n\tWARN_ON(err == -EMSGSIZE);\n\tkfree_skb(skb);\n\tif (err)\n\t\trtnl_set_sk_err(net, RTNLGRP_LINK, err);\n\treturn err;\n}", "target": 0}
{"code": "static __exit void sctp_exit(void)\n{\n\tsctp_v6_del_protocol();\n\tsctp_v4_del_protocol();\n\tunregister_pernet_subsys(&sctp_net_ops);\n\tsctp_v6_protosw_exit();\n\tsctp_v4_protosw_exit();\n\tsctp_v6_pf_exit();\n\tsctp_v4_pf_exit();\n\tsctp_sysctl_unregister();\n\tfree_pages((unsigned long)sctp_assoc_hashtable,\n\t\t   get_order(sctp_assoc_hashsize *\n\t\t\t     sizeof(struct sctp_hashbucket)));\n\tkfree(sctp_ep_hashtable);\n\tfree_pages((unsigned long)sctp_port_hashtable,\n\t\t   get_order(sctp_port_hashsize *\n\t\t\t     sizeof(struct sctp_bind_hashbucket)));\n\tpercpu_counter_destroy(&sctp_sockets_allocated);\n\trcu_barrier(); \n\tkmem_cache_destroy(sctp_chunk_cachep);\n\tkmem_cache_destroy(sctp_bucket_cachep);\n}", "target": 1}
{"code": "static int snmp6_alloc_dev(struct inet6_dev *idev)\n{\n\tif (snmp_mib_init((void __percpu **)idev->stats.ipv6,\n\t\t\t  sizeof(struct ipstats_mib),\n\t\t\t  __alignof__(struct ipstats_mib)) < 0)\n\t\tgoto err_ip;\n\tidev->stats.icmpv6dev = kzalloc(sizeof(struct icmpv6_mib_device),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!idev->stats.icmpv6dev)\n\t\tgoto err_icmp;\n\tidev->stats.icmpv6msgdev = kzalloc(sizeof(struct icmpv6msg_mib_device),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!idev->stats.icmpv6msgdev)\n\t\tgoto err_icmpmsg;\n\treturn 0;\nerr_icmpmsg:\n\tkfree(idev->stats.icmpv6dev);\nerr_icmp:\n\tsnmp_mib_free((void __percpu **)idev->stats.ipv6);\nerr_ip:\n\treturn -ENOMEM;\n}", "target": 0}
{"code": "void VP8LHuffmanTablesDeallocate(HuffmanTables* const huffman_tables) {\n  HuffmanTablesSegment *current, *next;\n  if (huffman_tables == NULL) return;\n  current = &huffman_tables->root;\n  next = current->next;\n  WebPSafeFree(current->start);\n  current->start = NULL;\n  current->next = NULL;\n  current = next;\n  while (current != NULL) {\n    next = current->next;\n    WebPSafeFree(current->start);\n    WebPSafeFree(current);\n    current = next;\n  }\n}", "target": 0}
{"code": "void exit_io_context(struct task_struct *task)\n{\n\tstruct io_context *ioc;\n\ttask_lock(task);\n\tioc = task->io_context;\n\ttask->io_context = NULL;\n\ttask_unlock(task);\n\tif (atomic_dec_and_test(&ioc->nr_tasks)) {\n\t\tif (ioc->aic && ioc->aic->exit)\n\t\t\tioc->aic->exit(ioc->aic);\n\t\tcfq_exit(ioc);\n\t}\n\tput_io_context(ioc);\n}", "target": 0}
{"code": "horizontalDifference8(unsigned char *ip, int n, int stride, \n\tunsigned short *wp, uint16 *From8)\n{\n    register int  r1, g1, b1, a1, r2, g2, b2, a2, mask;\n#undef\t CLAMP\n#define  CLAMP(v) (From8[(v)])\n    mask = CODE_MASK;\n    if (n >= stride) {\n\tif (stride == 3) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);\n\t    n -= 3;\n\t    while (n > 0) {\n\t\tn -= 3;\n\t\tr1 = CLAMP(ip[3]); wp[3] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[4]); wp[4] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[5]); wp[5] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\twp += 3;\n\t\tip += 3;\n\t    }\n\t} else if (stride == 4) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);  a2 = wp[3] = CLAMP(ip[3]);\n\t    n -= 4;\n\t    while (n > 0) {\n\t\tn -= 4;\n\t\tr1 = CLAMP(ip[4]); wp[4] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[5]); wp[5] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[6]); wp[6] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\ta1 = CLAMP(ip[7]); wp[7] = (uint16)((a1-a2) & mask); a2 = a1;\n\t\twp += 4;\n\t\tip += 4;\n\t    }\n\t} else {\n\t    wp += n + stride - 1;\t\n\t    ip += n + stride - 1;\t\n\t    n -= stride;\n\t    while (n > 0) {\n\t\tREPEAT(stride, wp[0] = CLAMP(ip[0]);\n\t\t\t\twp[stride] -= wp[0];\n\t\t\t\twp[stride] &= mask;\n\t\t\t\twp--; ip--)\n\t\tn -= stride;\n\t    }\n\t    REPEAT(stride, wp[0] = CLAMP(ip[0]); wp--; ip--)\n\t}\n    }\n}", "target": 1}
{"code": "static unsigned long randomize_stack_top(unsigned long stack_top)\n{\n\tunsigned int random_variable = 0;\n\tif ((current->flags & PF_RANDOMIZE) &&\n\t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n\t\trandom_variable = get_random_int() & STACK_RND_MASK;\n\t\trandom_variable <<= PAGE_SHIFT;\n\t}\n#ifdef CONFIG_STACK_GROWSUP\n\treturn PAGE_ALIGN(stack_top) + random_variable;\n#else\n\treturn PAGE_ALIGN(stack_top) - random_variable;\n#endif\n}", "target": 1}
{"code": "int kvm_inject_realmode_interrupt(struct kvm_vcpu *vcpu, int irq)\n{\n\tstruct decode_cache *c = &vcpu->arch.emulate_ctxt.decode;\n\tint ret;\n\tinit_emulate_ctxt(vcpu);\n\tvcpu->arch.emulate_ctxt.decode.op_bytes = 2;\n\tvcpu->arch.emulate_ctxt.decode.ad_bytes = 2;\n\tvcpu->arch.emulate_ctxt.decode.eip = vcpu->arch.emulate_ctxt.eip;\n\tret = emulate_int_real(&vcpu->arch.emulate_ctxt, &emulate_ops, irq);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn EMULATE_FAIL;\n\tvcpu->arch.emulate_ctxt.eip = c->eip;\n\tmemcpy(vcpu->arch.regs, c->regs, sizeof c->regs);\n\tkvm_rip_write(vcpu, vcpu->arch.emulate_ctxt.eip);\n\tkvm_x86_ops->set_rflags(vcpu, vcpu->arch.emulate_ctxt.eflags);\n\tif (irq == NMI_VECTOR)\n\t\tvcpu->arch.nmi_pending = false;\n\telse\n\t\tvcpu->arch.interrupt.pending = false;\n\treturn EMULATE_DONE;\n}", "target": 0}
{"code": "static struct mount *alloc_vfsmnt(const char *name)\n{\n\tstruct mount *mnt = kmem_cache_zalloc(mnt_cache, GFP_KERNEL);\n\tif (mnt) {\n\t\tint err;\n\t\terr = mnt_alloc_id(mnt);\n\t\tif (err)\n\t\t\tgoto out_free_cache;\n\t\tif (name) {\n\t\t\tmnt->mnt_devname = kstrdup(name, GFP_KERNEL);\n\t\t\tif (!mnt->mnt_devname)\n\t\t\t\tgoto out_free_id;\n\t\t}\n#ifdef CONFIG_SMP\n\t\tmnt->mnt_pcp = alloc_percpu(struct mnt_pcp);\n\t\tif (!mnt->mnt_pcp)\n\t\t\tgoto out_free_devname;\n\t\tthis_cpu_add(mnt->mnt_pcp->mnt_count, 1);\n#else\n\t\tmnt->mnt_count = 1;\n\t\tmnt->mnt_writers = 0;\n#endif\n\t\tINIT_HLIST_NODE(&mnt->mnt_hash);\n\t\tINIT_LIST_HEAD(&mnt->mnt_child);\n\t\tINIT_LIST_HEAD(&mnt->mnt_mounts);\n\t\tINIT_LIST_HEAD(&mnt->mnt_list);\n\t\tINIT_LIST_HEAD(&mnt->mnt_expire);\n\t\tINIT_LIST_HEAD(&mnt->mnt_share);\n\t\tINIT_LIST_HEAD(&mnt->mnt_slave_list);\n\t\tINIT_LIST_HEAD(&mnt->mnt_slave);\n#ifdef CONFIG_FSNOTIFY\n\t\tINIT_HLIST_HEAD(&mnt->mnt_fsnotify_marks);\n#endif\n\t}\n\treturn mnt;\n#ifdef CONFIG_SMP\nout_free_devname:\n\tkfree(mnt->mnt_devname);\n#endif\nout_free_id:\n\tmnt_free_id(mnt);\nout_free_cache:\n\tkmem_cache_free(mnt_cache, mnt);\n\treturn NULL;\n}", "target": 0}
{"code": "static __always_inline int __do_follow_link(struct path *path, struct nameidata *nd)\n{\n\tint error;\n\tvoid *cookie;\n\tstruct dentry *dentry = path->dentry;\n\ttouch_atime(path->mnt, dentry);\n\tnd_set_link(nd, NULL);\n\tif (path->mnt != nd->path.mnt) {\n\t\tpath_to_nameidata(path, nd);\n\t\tdget(dentry);\n\t}\n\tmntget(path->mnt);\n\tnd->last_type = LAST_BIND;\n\tcookie = dentry->d_inode->i_op->follow_link(dentry, nd);\n\terror = PTR_ERR(cookie);\n\tif (!IS_ERR(cookie)) {\n\t\tchar *s = nd_get_link(nd);\n\t\terror = 0;\n\t\tif (s)\n\t\t\terror = __vfs_follow_link(nd, s);\n\t\telse if (nd->last_type == LAST_BIND) {\n\t\t\terror = force_reval_path(&nd->path, nd);\n\t\t\tif (error)\n\t\t\t\tpath_put(&nd->path);\n\t\t}\n\t\tif (dentry->d_inode->i_op->put_link)\n\t\t\tdentry->d_inode->i_op->put_link(dentry, nd, cookie);\n\t}\n\treturn error;\n}", "target": 0}
{"code": "xcalloc (size_t num, size_t size)\n{\n    void *ptr = malloc(num * size);\n    if (ptr)\n    {\n        memset (ptr, '\\0', (num * size));\n    }\n    return ptr;\n}", "target": 1}
{"code": "int zmq::stream_engine_t::decode_and_push (msg_t *msg_)\n{\n    zmq_assert (mechanism != NULL);\n    if (mechanism->decode (msg_) == -1)\n        return -1;\n    if (metadata)\n        msg_->set_metadata (metadata);\n    if (session->push_msg (msg_) == -1) {\n        if (errno == EAGAIN)\n            process_msg = &stream_engine_t::push_one_then_decode_and_push;\n        return -1;\n    }\n    return 0;\n}", "target": 0}
{"code": "struct bpf_map *bpf_map_get_with_uref(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_map *map;\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn map;\n\tbpf_map_inc(map, true);\n\tfdput(f);\n\treturn map;\n}", "target": 1}
{"code": "static int tls_construct_cke_ecdhe(SSL *s, unsigned char **p, int *len, int *al)\n{\n#ifndef OPENSSL_NO_EC\n    unsigned char *encodedPoint = NULL;\n    int encoded_pt_len = 0;\n    EVP_PKEY *ckey = NULL, *skey = NULL;\n    skey = s->s3->peer_tmp;\n    if (skey == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n    ckey = ssl_generate_pkey(skey);\n    if (ckey == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n    if (ssl_derive(s, ckey, skey) == 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EVP_LIB);\n        goto err;\n    }\n    encoded_pt_len = EVP_PKEY_get1_tls_encodedpoint(ckey, &encodedPoint);\n    if (encoded_pt_len == 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EC_LIB);\n        goto err;\n    }\n    EVP_PKEY_free(ckey);\n    ckey = NULL;\n    *len = encoded_pt_len;\n    **p = *len;\n    *p += 1;\n    memcpy(*p, encodedPoint, *len);\n    *len += 1;\n    OPENSSL_free(encodedPoint);\n    return 1;\n err:\n    EVP_PKEY_free(ckey);\n    return 0;\n#else\n    SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);\n    *al = SSL_AD_INTERNAL_ERROR;\n    return 0;\n#endif\n}", "target": 0}
{"code": "bool TABLE_REF::tmp_table_index_lookup_init(THD *thd,\n                                            KEY *tmp_key,\n                                            Item_iterator &it,\n                                            bool value,\n                                            uint skip)\n{\n  uint tmp_key_parts= tmp_key->user_defined_key_parts;\n  uint i;\n  DBUG_ENTER(\"TABLE_REF::tmp_table_index_lookup_init\");\n  key= 0; \n  key_length= tmp_key->key_length;\n  if (!(key_buff=\n        (uchar*) thd->calloc(ALIGN_SIZE(tmp_key->key_length) * 2)) ||\n      !(key_copy=\n        (store_key**) thd->alloc((sizeof(store_key*) *\n                                  (tmp_key_parts + 1)))) ||\n      !(items=\n        (Item**) thd->alloc(sizeof(Item*) * tmp_key_parts)))\n    DBUG_RETURN(TRUE);\n  key_buff2= key_buff + ALIGN_SIZE(tmp_key->key_length);\n  KEY_PART_INFO *cur_key_part= tmp_key->key_part;\n  store_key **ref_key= key_copy;\n  uchar *cur_ref_buff= key_buff;\n  it.open();\n  for (i= 0; i < skip; i++) it.next();\n  for (i= 0; i < tmp_key_parts; i++, cur_key_part++, ref_key++)\n  {\n    Item *item= it.next();\n    DBUG_ASSERT(item);\n    items[i]= item;\n    int null_count= MY_TEST(cur_key_part->field->real_maybe_null());\n    *ref_key= new store_key_item(thd, cur_key_part->field,\n                                 cur_ref_buff + null_count,\n                                 null_count ? cur_ref_buff : 0,\n                                 cur_key_part->length, items[i], value);\n    cur_ref_buff+= cur_key_part->store_length;\n  }\n  *ref_key= NULL; \n  key_err= 1;\n  key_parts= tmp_key_parts;\n  DBUG_RETURN(FALSE);\n}", "target": 0}
{"code": "static inline bool spectre_v2_in_ibrs_mode(enum spectre_v2_mitigation mode)\n{\n\treturn mode == SPECTRE_V2_IBRS ||\n\t       mode == SPECTRE_V2_EIBRS ||\n\t       mode == SPECTRE_V2_EIBRS_RETPOLINE ||\n\t       mode == SPECTRE_V2_EIBRS_LFENCE;\n}", "target": 1}
{"code": "const char *GetClipboardText(void)\n{\n#if defined(PLATFORM_DESKTOP)\n    return glfwGetClipboardString(CORE.Window.handle);\n#endif\n#if defined(PLATFORM_WEB)\n    emscripten_run_script_string(\"navigator.clipboard.readText() \\\n        .then(text => { document.getElementById('clipboard').innerText = text; console.log('Pasted content: ', text); }) \\\n        .catch(err => { console.error('Failed to read clipboard contents: ', err); });\"\n    );\n    return NULL;\n#endif\n    return NULL;\n}", "target": 1}
{"code": "rpl_daoack_print(netdissect_options *ndo,\n                 const u_char *bp, u_int length)\n{\n        const struct nd_rpl_daoack *daoack = (const struct nd_rpl_daoack *)bp;\n        const char *dagid_str = \"<elided>\";\n        ND_TCHECK2(*daoack, ND_RPL_DAOACK_MIN_LEN);\n        if (length < ND_RPL_DAOACK_MIN_LEN)\n        \tgoto tooshort;\n        bp += ND_RPL_DAOACK_MIN_LEN;\n        length -= ND_RPL_DAOACK_MIN_LEN;\n        if(RPL_DAOACK_D(daoack->rpl_flags)) {\n                ND_TCHECK2(daoack->rpl_dagid, DAGID_LEN);\n                if (length < DAGID_LEN)\n                \tgoto tooshort;\n                dagid_str = ip6addr_string (ndo, daoack->rpl_dagid);\n                bp += DAGID_LEN;\n                length -= DAGID_LEN;\n        }\n        ND_PRINT((ndo, \" [dagid:%s,seq:%u,instance:%u,status:%u]\",\n                  dagid_str,\n                  daoack->rpl_daoseq,\n                  daoack->rpl_instanceid,\n                  daoack->rpl_status));\n        if(ndo->ndo_vflag > 1) {\n                const struct rpl_dio_genoption *opt = (const struct rpl_dio_genoption *)bp;\n                rpl_dio_printopt(ndo, opt, length);\n        }\n\treturn;\ntrunc:\n\tND_PRINT((ndo,\" [|dao-truncated]\"));\n\treturn;\ntooshort:\n\tND_PRINT((ndo,\" [|dao-length too short]\"));\n\treturn;\n}", "target": 1}
{"code": "static __u8 *mr_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 30 && rdesc[29] == 0x05 && rdesc[30] == 0x09) {\n\t\thid_info(hdev, \"fixing up button/consumer in HID report descriptor\\n\");\n\t\trdesc[30] = 0x0c;\n\t}\n\treturn rdesc;\n}", "target": 1}
{"code": "void print_cfs_stats(struct seq_file *m, int cpu)\n{\n\tstruct cfs_rq *cfs_rq, *pos;\n\trcu_read_lock();\n\tfor_each_leaf_cfs_rq_safe(cpu_rq(cpu), cfs_rq, pos)\n\t\tprint_cfs_rq(m, cpu, cfs_rq);\n\trcu_read_unlock();\n}", "target": 1}
{"code": "static CallResult<HermesValue> getCodeBlockFileName(\n    Runtime &runtime,\n    const CodeBlock *codeBlock,\n    OptValue<hbc::DebugSourceLocation> location) {\n  RuntimeModule *runtimeModule = codeBlock->getRuntimeModule();\n  if (location) {\n    auto debugInfo = runtimeModule->getBytecode()->getDebugInfo();\n    return StringPrimitive::createEfficient(\n        runtime, debugInfo->getFilenameByID(location->filenameId));\n  } else {\n    llvh::StringRef sourceURL = runtimeModule->getSourceURL();\n    if (!sourceURL.empty()) {\n      return StringPrimitive::createEfficient(runtime, sourceURL);\n    }\n  }\n  return HermesValue::encodeUndefinedValue();\n}", "target": 1}
{"code": "child_func (void * const arg)\n{\n  xclose (sockfd[0]);\n  const int sock = sockfd[1];\n  char ch;\n  TEST_VERIFY_EXIT (read (sock, &ch, 1) == 1);\n  TEST_VERIFY_EXIT (ch == '1');\n  if (mount (\"/\", MOUNT_NAME, NULL, MS_BIND | MS_REC, NULL))\n    FAIL_EXIT1 (\"mount failed: %m\\n\");\n  const int fd = xopen (\"mpoint\",\n\t\t\tO_RDONLY | O_PATH | O_DIRECTORY | O_NOFOLLOW, 0);\n  send_fd (sock, fd);\n  xclose (fd);\n  TEST_VERIFY_EXIT (read (sock, &ch, 1) == 1);\n  TEST_VERIFY_EXIT (ch == 'a');\n  xclose (sock);\n  return 0;\n}", "target": 0}
{"code": "static AMQP_VALUE test_on_transfer_received(void* context, TRANSFER_HANDLE transfer, uint32_t payload_size, const unsigned char* payload_bytes)\n{\n    (void)context;\n    test_on_transfer_received_transfer = transfer;\n    test_on_transfer_received_payload_size = payload_size;\n    memcpy(test_on_transfer_received_payload_bytes, payload_bytes, payload_size);\n    return (AMQP_VALUE)0x6000;\n}", "target": 0}
{"code": "  const uint8_t *getBytecode(uint32_t) const override {\n    llvm_unreachable(\"Accessing bytecode from a lazy module\");\n  }", "target": 1}
{"code": "static inline void vma_adjust_trans_huge(struct vm_area_struct *vma,\n\t\t\t\t\t unsigned long start,\n\t\t\t\t\t unsigned long end,\n\t\t\t\t\t long adjust_next)\n{\n\tif (!vma->anon_vma || vma->vm_ops || vma->vm_file)\n\t\treturn;\n\t__vma_adjust_trans_huge(vma, start, end, adjust_next);\n}", "target": 1}
{"code": "int wcall_i_answer(struct wcall *wcall,\n\t\t   int call_type, int audio_cbr)\n{\n\tint err = 0;\n\tbool cbr = audio_cbr != 0;\n\tif (!wcall) {\n\t\twarning(\"wcall; answer: no wcall\\n\");\n\t\treturn EINVAL;\n\t}\n\tcall_type = (call_type == WCALL_CALL_TYPE_FORCED_AUDIO) ?\n\t\t    WCALL_CALL_TYPE_NORMAL : call_type;\n\tinfo(APITAG \"wcall(%p): answer calltype=%s\\n\",\n\t     wcall, wcall_call_type_name(call_type));\n\tif (wcall->disable_audio)\n\t\twcall->disable_audio = false;\n\tif (!wcall->icall) {\n\t\twarning(\"wcall(%p): answer: no call object found\\n\", wcall);\n\t\treturn ENOTSUP;\n\t}\n\tset_state(wcall, WCALL_STATE_ANSWERED);\n\tif (call_type == WCALL_CALL_TYPE_VIDEO) {\n\t\tICALL_CALL(wcall->icall,\n\t\t\t   set_video_send_state,\n\t\t\t   ICALL_VIDEO_STATE_STARTED);\n\t}\n\telse {\n\t\tICALL_CALL(wcall->icall,\n\t\t\t   set_video_send_state,\n\t\t\t   ICALL_VIDEO_STATE_STOPPED);\n\t}\n\terr = ICALL_CALLE(wcall->icall, answer,\n\t\t\t  call_type, cbr);\n\treturn err;\n}", "target": 1}
{"code": "static struct btrfs_device *find_device(struct btrfs_fs_devices *fs_devices,\n\t\tu64 devid, const u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\tlist_for_each_entry(dev, &fs_devices->devices, dev_list) {\n\t\tif (dev->devid == devid &&\n\t\t    (!uuid || !memcmp(dev->uuid, uuid, BTRFS_UUID_SIZE))) {\n\t\t\treturn dev;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static int mincore_unmapped_range(unsigned long addr, unsigned long end,\n\t\t\t\t   struct mm_walk *walk)\n{\n\twalk->private += __mincore_unmapped_range(addr, end,\n\t\t\t\t\t\t  walk->vma, walk->private);\n\treturn 0;\n}", "target": 1}
{"code": "static int snd_ctl_elem_lock(struct snd_ctl_file *file,\n\t\t\t     struct snd_ctl_elem_id __user *_id)\n{\n\tstruct snd_card *card = file->card;\n\tstruct snd_ctl_elem_id id;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tint result;\n\tif (copy_from_user(&id, _id, sizeof(id)))\n\t\treturn -EFAULT;\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &id);\n\tif (kctl == NULL) {\n\t\tresult = -ENOENT;\n\t} else {\n\t\tvd = &kctl->vd[snd_ctl_get_ioff(kctl, &id)];\n\t\tif (vd->owner != NULL)\n\t\t\tresult = -EBUSY;\n\t\telse {\n\t\t\tvd->owner = file;\n\t\t\tresult = 0;\n\t\t}\n\t}\n\tup_write(&card->controls_rwsem);\n\treturn result;\n}", "target": 0}
{"code": "static void local_release(struct kref *ref)\n{\n\tstruct nfc_llcp_local *local;\n\tlocal = container_of(ref, struct nfc_llcp_local, ref);\n\tlist_del(&local->list);\n\tlocal_cleanup(local);\n\tkfree(local);\n}", "target": 1}
{"code": "static void xen_irq_lateeoi_locked(struct irq_info *info)\n{\n\tevtchn_port_t evtchn;\n\tevtchn = info->evtchn;\n\tif (!VALID_EVTCHN(evtchn))\n\t\treturn;\n\tunmask_evtchn(evtchn);\n}", "target": 1}
{"code": "static int dp8393x_receive_filter(dp8393xState *s, const uint8_t * buf,\n                                  int size)\n{\n    static const uint8_t bcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n    int i;\n    if ((s->regs[SONIC_RCR] & SONIC_RCR_PRO) && (buf[0] & 1) == 0) {\n        return 0;\n    }\n    if ((s->regs[SONIC_RCR] & SONIC_RCR_AMC) && (buf[0] & 1) == 1) {\n        return SONIC_RCR_MC;\n    }\n    if ((s->regs[SONIC_RCR] & SONIC_RCR_BRD) && !memcmp(buf, bcast, sizeof(bcast))) {\n        return SONIC_RCR_BC;\n    }\n    for (i = 0; i < 16; i++) {\n        if (s->regs[SONIC_CE] & (1 << i)) {\n             if (!memcmp(buf, s->cam[i], sizeof(s->cam[i]))) {\n                 return 0;\n             }\n        }\n    }\n    return -1;\n}", "target": 0}
{"code": "get_certificate_type(X509 *cert, bool is_ta, enum cert_type *result)\n{\n\tif (is_ta) {\n\t\t*result = TA;\n\t\treturn 0;\n\t}\n\tif (X509_check_ca(cert) == 1) {\n\t\t*result = CA;\n\t\treturn 0;\n\t}\n\tif (has_bgpsec_router_eku(cert)) {\n\t\t*result = BGPSEC;\n\t\treturn 0;\n\t}\n\t*result = EE; \n\treturn pr_val_err(\"Certificate is not TA, CA nor BGPsec. Ignoring...\");\n}", "target": 0}
{"code": "static size_t hash_str(const void *ptr)\n{\n    const char *str = (const char *)ptr;\n    size_t hash = 5381;\n    size_t c;\n    while((c = (size_t)*str))\n    {\n        hash = ((hash << 5) + hash) + c;\n        str++;\n    }\n    return hash;\n}", "target": 1}
{"code": "int rm_rf_children(\n                int fd,\n                RemoveFlags flags,\n                const struct stat *root_dev) {\n        _cleanup_closedir_ DIR *d = NULL;\n        int ret = 0, r;\n        assert(fd >= 0);\n        d = fdopendir(fd);\n        if (!d) {\n                safe_close(fd);\n                return -errno;\n        }\n        if (!(flags & REMOVE_PHYSICAL)) {\n                struct statfs sfs;\n                if (fstatfs(dirfd(d), &sfs) < 0)\n                        return -errno;\n                if (is_physical_fs(&sfs)) {\n                        _cleanup_free_ char *path = NULL;\n                        (void) fd_get_path(fd, &path);\n                        return log_error_errno(SYNTHETIC_ERRNO(EPERM),\n                                               \"Attempted to remove disk file system under \\\"%s\\\", and we can't allow that.\",\n                                               strna(path));\n                }\n        }\n        FOREACH_DIRENT_ALL(de, d, return -errno) {\n                int is_dir;\n                if (dot_or_dot_dot(de->d_name))\n                        continue;\n                is_dir =\n                        de->d_type == DT_UNKNOWN ? -1 :\n                        de->d_type == DT_DIR;\n                r = rm_rf_children_inner(dirfd(d), de->d_name, is_dir, flags, root_dev);\n                if (r < 0 && r != -ENOENT && ret == 0)\n                        ret = r;\n        }\n        if (FLAGS_SET(flags, REMOVE_SYNCFS) && syncfs(dirfd(d)) < 0 && ret >= 0)\n                ret = -errno;\n        return ret;\n}", "target": 1}
{"code": "PlayerGeneric::~PlayerGeneric()\n{\n\tif (mixer)\n\t\tdelete mixer;\n\tif (player)\n\t{\n\t\tif (mixer->isActive() && !mixer->isDeviceRemoved(player))\n\t\t\tmixer->removeDevice(player);\n\t\tdelete player;\n\t}\n\tdelete[] audioDriverName;\n\tdelete listener;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const float min_input = context->input(1).flat<float>()(0);\n    const float max_input = context->input(2).flat<float>()(0);\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input.shape(), &output));\n    const T min_as_quantized = FloatToQuantized<T>(0.0f, min_input, max_input);\n    const T max_as_quantized = FloatToQuantized<T>(6.0f, min_input, max_input);\n    if (meta::IsSupportedAndEnabled() && std::is_same<T, quint8>()) {\n      auto input_ui8_array = input.flat<quint8>();\n      meta::Clamp(context, input_ui8_array.data(), input_ui8_array.size(),\n                  min_as_quantized, max_as_quantized,\n                  output->flat<quint8>().data());\n    } else {\n      output->flat<T>().device(context->eigen_cpu_device()) =\n          input.flat<T>()\n              .cwiseMax(min_as_quantized)\n              .cwiseMin(max_as_quantized)\n              .template cast<T>();\n    }\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));\n    output_min->flat<float>()(0) = min_input;\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max));\n    output_max->flat<float>()(0) = max_input;\n  }", "target": 1}
{"code": "static int userns_install(struct nsproxy *nsproxy, void *ns)\n{\n\tstruct user_namespace *user_ns = ns;\n\tstruct cred *cred;\n\tif (user_ns == current_user_ns())\n\t\treturn -EINVAL;\n\tif (atomic_read(&current->mm->mm_users) > 1)\n\t\treturn -EINVAL;\n\tif (current->fs->users != 1)\n\t\treturn -EINVAL;\n\tif (!ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tcred = prepare_creds();\n\tif (!cred)\n\t\treturn -ENOMEM;\n\tput_user_ns(cred->user_ns);\n\tset_cred_user_ns(cred, get_user_ns(user_ns));\n\treturn commit_creds(cred);\n}", "target": 0}
{"code": "static u64 distribute_cfs_runtime(struct cfs_bandwidth *cfs_b,\n\t\tu64 remaining, u64 expires)\n{\n\tstruct cfs_rq *cfs_rq;\n\tu64 runtime;\n\tu64 starting_runtime = remaining;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(cfs_rq, &cfs_b->throttled_cfs_rq,\n\t\t\t\tthrottled_list) {\n\t\tstruct rq *rq = rq_of(cfs_rq);\n\t\tstruct rq_flags rf;\n\t\trq_lock_irqsave(rq, &rf);\n\t\tif (!cfs_rq_throttled(cfs_rq))\n\t\t\tgoto next;\n\t\truntime = -cfs_rq->runtime_remaining + 1;\n\t\tif (runtime > remaining)\n\t\t\truntime = remaining;\n\t\tremaining -= runtime;\n\t\tcfs_rq->runtime_remaining += runtime;\n\t\tcfs_rq->runtime_expires = expires;\n\t\tif (cfs_rq->runtime_remaining > 0)\n\t\t\tunthrottle_cfs_rq(cfs_rq);\nnext:\n\t\trq_unlock_irqrestore(rq, &rf);\n\t\tif (!remaining)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\treturn starting_runtime - remaining;\n}", "target": 1}
{"code": "static int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)\n{\n\tstruct sockaddr_rc *sa = (struct sockaddr_rc *) addr;\n\tstruct sock *sk = sock->sk;\n\tint chan = sa->rc_channel;\n\tint err = 0;\n\tBT_DBG(\"sk %p %pMR\", sk, &sa->rc_bdaddr);\n\tif (!addr || addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\tlock_sock(sk);\n\tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\tif (sk->sk_type != SOCK_STREAM) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\twrite_lock(&rfcomm_sk_list.lock);\n\tif (chan && __rfcomm_get_listen_sock_by_addr(chan, &sa->rc_bdaddr)) {\n\t\terr = -EADDRINUSE;\n\t} else {\n\t\tbacpy(&rfcomm_pi(sk)->src, &sa->rc_bdaddr);\n\t\trfcomm_pi(sk)->channel = chan;\n\t\tsk->sk_state = BT_BOUND;\n\t}\n\twrite_unlock(&rfcomm_sk_list.lock);\ndone:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 1}
{"code": "  void readDataAvailable(size_t len) noexcept override {\n    std::cerr << \"readDataAvailable, len \" << len << std::endl;\n    currentBuffer.length = len;\n    wcb_->setSocket(socket_);\n    socket_->write(wcb_, currentBuffer.buffer, len, writeFlags);\n    buffers.push_back(currentBuffer);\n    currentBuffer.reset();\n    state = STATE_SUCCEEDED;\n  }", "target": 1}
{"code": "void __refill_cfs_bandwidth_runtime(struct cfs_bandwidth *cfs_b)\n{\n\tu64 now;\n\tif (cfs_b->quota == RUNTIME_INF)\n\t\treturn;\n\tnow = sched_clock_cpu(smp_processor_id());\n\tcfs_b->runtime = cfs_b->quota;\n\tcfs_b->runtime_expires = now + ktime_to_ns(cfs_b->period);\n\tcfs_b->expires_seq++;\n}", "target": 1}
{"code": "void LanLinkProvider::udpBroadcastReceived()\n{\n    while (m_udpSocket.hasPendingDatagrams()) {\n        QByteArray datagram;\n        datagram.resize(m_udpSocket.pendingDatagramSize());\n        QHostAddress sender;\n        m_udpSocket.readDatagram(datagram.data(), datagram.size(), &sender);\n        if (sender.isLoopback() && !m_testMode)\n            continue;\n        NetworkPacket* receivedPacket = new NetworkPacket(QLatin1String(\"\"));\n        bool success = NetworkPacket::unserialize(datagram, receivedPacket);\n        if (!success) {\n            qCDebug(KDECONNECT_CORE) << \"Could not unserialize UDP packet\";\n            delete receivedPacket;\n            continue;\n        }\n        if (receivedPacket->type() != PACKET_TYPE_IDENTITY) {\n            qCDebug(KDECONNECT_CORE) << \"Received a UDP packet of wrong type\" << receivedPacket->type();\n            delete receivedPacket;\n            continue;\n        }\n        if (receivedPacket->get<QString>(QStringLiteral(\"deviceId\")) == KdeConnectConfig::instance().deviceId()) {\n            delete receivedPacket;\n            continue;\n        }\n        int tcpPort = receivedPacket->get<int>(QStringLiteral(\"tcpPort\"));\n        if (m_receivedIdentityPackets.size() > MAX_REMEMBERED_IDENTITY_PACKETS) {\n            qCWarning(KDECONNECT_CORE) << \"Too many remembered identities, ignoring\" << receivedPacket->get<QString>(QStringLiteral(\"deviceId\")) << \"received via UDP\";\n            delete receivedPacket;\n            continue;\n        }\n        QSslSocket* socket = new QSslSocket(this);\n        socket->setProxy(QNetworkProxy::NoProxy);\n        m_receivedIdentityPackets[socket].np = receivedPacket;\n        m_receivedIdentityPackets[socket].sender = sender;\n        connect(socket, &QAbstractSocket::connected, this, &LanLinkProvider::tcpSocketConnected);\n#if QT_VERSION < QT_VERSION_CHECK(5,15,0)\n        connect(socket, QOverload<QAbstractSocket::SocketError>::of(&QAbstractSocket::error), this, &LanLinkProvider::connectError);\n#else\n        connect(socket, &QAbstractSocket::errorOccurred, this, &LanLinkProvider::connectError);\n#endif\n        socket->connectToHost(sender, tcpPort);\n    }\n}", "target": 0}
{"code": "void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)\n{\n\tstruct in_pktinfo *pktinfo = PKTINFO_SKB_CB(skb);\n\tbool prepare = (inet_sk(sk)->cmsg_flags & IP_CMSG_PKTINFO) ||\n\t\t       ipv6_sk_rxinfo(sk);\n\tif (prepare && skb_rtable(skb)) {\n\t\tif (pktinfo->ipi_ifindex == LOOPBACK_IFINDEX)\n\t\t\tpktinfo->ipi_ifindex = inet_iif(skb);\n\t\tpktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);\n\t} else {\n\t\tpktinfo->ipi_ifindex = 0;\n\t\tpktinfo->ipi_spec_dst.s_addr = 0;\n\t}\n\tskb_dst_drop(skb);\n}", "target": 1}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_enclosing_methods_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 6;\n\tif (sz < 8) {\n\t\treturn NULL;\n\t}\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\tif (!attr || sz < 10) {\n\t\tfree (attr);\n\t\treturn NULL;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_ENCLOSING_METHOD_ATTR;\n\tattr->info.enclosing_method_attr.class_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.enclosing_method_attr.method_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.enclosing_method_attr.class_name = r_bin_java_get_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, attr->info.enclosing_method_attr.class_idx);\n\tif (attr->info.enclosing_method_attr.class_name == NULL) {\n\t\teprintf (\"Could not resolve enclosing class name for the enclosed method.\\n\");\n\t}\n\tattr->info.enclosing_method_attr.method_name = r_bin_java_get_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, attr->info.enclosing_method_attr.method_idx);\n\tif (attr->info.enclosing_method_attr.class_name == NULL) {\n\t\teprintf (\"Could not resolve method descriptor for the enclosed method.\\n\");\n\t}\n\tattr->info.enclosing_method_attr.method_descriptor = r_bin_java_get_desc_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, attr->info.enclosing_method_attr.method_idx);\n\tif (attr->info.enclosing_method_attr.method_name == NULL) {\n\t\teprintf (\"Could not resolve method name for the enclosed method.\\n\");\n\t}\n\tattr->size = offset;\n\treturn attr;\n}", "target": 0}
{"code": "static int er_supported(ERContext *s)\n{\n    if(s->avctx->hwaccel && s->avctx->hwaccel->decode_slice           ||\n       !s->cur_pic.f                                                  ||\n       s->cur_pic.field_picture                                       ||\n       s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO\n    )\n        return 0;\n    return 1;\n}", "target": 1}
{"code": "static void youngcollection (lua_State *L, global_State *g) {\n  GCObject **psurvival;  \n  lua_assert(g->gcstate == GCSpropagate);\n  markold(g, g->allgc, g->reallyold);\n  markold(g, g->finobj, g->finobjrold);\n  atomic(L);\n  g->gcstate = GCSswpallgc;\n  psurvival = sweepgen(L, g, &g->allgc, g->survival);\n  sweepgen(L, g, psurvival, g->reallyold);\n  g->reallyold = g->old;\n  g->old = *psurvival;  \n  g->survival = g->allgc;  \n  psurvival = sweepgen(L, g, &g->finobj, g->finobjsur);\n  sweepgen(L, g, psurvival, g->finobjrold);\n  g->finobjrold = g->finobjold;\n  g->finobjold = *psurvival;  \n  g->finobjsur = g->finobj;  \n  sweepgen(L, g, &g->tobefnz, NULL);\n  finishgencycle(L, g);\n}", "target": 0}
{"code": "static void sr_mdio_write(struct net_device *netdev, int phy_id, int loc,\n\t\t\t  int val)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\t__le16 res = cpu_to_le16(val);\n\tif (phy_id) {\n\t\tnetdev_dbg(netdev, \"Only internal phy supported\\n\");\n\t\treturn;\n\t}\n\tnetdev_dbg(netdev, \"sr_mdio_write() phy_id=0x%02x, loc=0x%02x, val=0x%04x\\n\",\n\t\t   phy_id, loc, val);\n\tsr_share_write_word(dev, 1, loc, res);\n}", "target": 0}
{"code": "static void show_object(struct object *object, struct strbuf *path,\n\t\t\tconst char *last, void *data)\n{\n\tstruct bitmap *base = data;\n\tbitmap_set(base, find_object_pos(object->oid.hash));\n\tmark_as_seen(object);\n}", "target": 1}
{"code": "void Context::onLog() {\n  if (wasm_->onLog_) {\n    wasm_->onLog_(this, id_);\n  }\n}", "target": 1}
{"code": "void pjsua_init_tpselector(pjsua_transport_id tp_id,\n\t\t\t   pjsip_tpselector *sel)\n{\n    pjsua_transport_data *tpdata;\n    unsigned flag;\n    pj_bzero(sel, sizeof(*sel));\n    if (tp_id == PJSUA_INVALID_ID)\n\treturn;\n    pj_assert(tp_id >= 0 && tp_id < (int)PJ_ARRAY_SIZE(pjsua_var.tpdata));\n    tpdata = &pjsua_var.tpdata[tp_id];\n    flag = pjsip_transport_get_flag_from_type(tpdata->type);\n    if (flag & PJSIP_TRANSPORT_DATAGRAM) {\n\tsel->type = PJSIP_TPSELECTOR_TRANSPORT;\n\tsel->u.transport = tpdata->data.tp;\n    } else {\n\tsel->type = PJSIP_TPSELECTOR_LISTENER;\n\tsel->u.listener = tpdata->data.factory;\n    }\n}", "target": 1}
{"code": "String UTF16BEDecoder::to_utf8(const StringView& input)\n{\n    StringBuilder builder(input.length() / 2);\n    for (size_t i = 0; i < input.length(); i += 2) {\n        u16 code_point = (input[i] << 8) | input[i + 1];\n        builder.append_code_point(code_point);\n    }\n    return builder.to_string();\n}", "target": 1}
{"code": "static int cma_accept_iw(struct rdma_id_private *id_priv,\n\t\t  struct rdma_conn_param *conn_param)\n{\n\tstruct iw_cm_conn_param iw_param;\n\tint ret;\n\tif (!conn_param)\n\t\treturn -EINVAL;\n\tret = cma_modify_qp_rtr(id_priv, conn_param);\n\tif (ret)\n\t\treturn ret;\n\tiw_param.ord = conn_param->initiator_depth;\n\tiw_param.ird = conn_param->responder_resources;\n\tiw_param.private_data = conn_param->private_data;\n\tiw_param.private_data_len = conn_param->private_data_len;\n\tif (id_priv->id.qp)\n\t\tiw_param.qpn = id_priv->qp_num;\n\telse\n\t\tiw_param.qpn = conn_param->qp_num;\n\treturn iw_cm_accept(id_priv->cm_id.iw, &iw_param);\n}", "target": 0}
{"code": "epass2003_hook_path(struct sc_path *path, int inc)\n{\n\tu8 fid_h = path->value[path->len - 2];\n\tu8 fid_l = path->value[path->len - 1];\n\tswitch (fid_h) {\n\tcase 0x29:\n\tcase 0x30:\n\tcase 0x31:\n\tcase 0x32:\n\tcase 0x33:\n\tcase 0x34:\n\t\tif (inc)\n\t\t\tfid_l = fid_l * FID_STEP;\n\t\telse\n\t\t\tfid_l = fid_l / FID_STEP;\n\t\tpath->value[path->len - 1] = fid_l;\n\t\treturn 1;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "struct torture_suite *torture_winbind_struct_init(TALLOC_CTX *ctx)\n{\n\tstruct torture_suite *suite = torture_suite_create(ctx, \"struct\");\n\ttorture_suite_add_simple_test(suite, \"interface_version\", torture_winbind_struct_interface_version);\n\ttorture_suite_add_simple_test(suite, \"ping\", torture_winbind_struct_ping);\n\ttorture_suite_add_simple_test(suite, \"info\", torture_winbind_struct_info);\n\ttorture_suite_add_simple_test(suite, \"priv_pipe_dir\", torture_winbind_struct_priv_pipe_dir);\n\ttorture_suite_add_simple_test(suite, \"netbios_name\", torture_winbind_struct_netbios_name);\n\ttorture_suite_add_simple_test(suite, \"domain_name\", torture_winbind_struct_domain_name);\n\ttorture_suite_add_simple_test(suite, \"check_machacc\", torture_winbind_struct_check_machacc);\n\ttorture_suite_add_simple_test(suite, \"list_trustdom\", torture_winbind_struct_list_trustdom);\n\ttorture_suite_add_simple_test(suite, \"domain_info\", torture_winbind_struct_domain_info);\n\ttorture_suite_add_simple_test(suite, \"getdcname\", torture_winbind_struct_getdcname);\n\ttorture_suite_add_simple_test(suite, \"dsgetdcname\", torture_winbind_struct_dsgetdcname);\n\ttorture_suite_add_simple_test(suite, \"list_users\", torture_winbind_struct_list_users);\n\ttorture_suite_add_simple_test(suite, \"list_groups\", torture_winbind_struct_list_groups);\n\ttorture_suite_add_simple_test(suite, \"show_sequence\", torture_winbind_struct_show_sequence);\n\ttorture_suite_add_simple_test(suite, \"setpwent\", torture_winbind_struct_setpwent);\n\ttorture_suite_add_simple_test(suite, \"getpwent\", torture_winbind_struct_getpwent);\n\ttorture_suite_add_simple_test(suite, \"endpwent\", torture_winbind_struct_endpwent);\n\ttorture_suite_add_simple_test(suite, \"lookup_name_sid\", torture_winbind_struct_lookup_name_sid);\n\ttorture_suite_add_simple_test(\n\t\tsuite,\n\t\t\"lookup_sids_invalid\",\n\t\ttorture_winbind_struct_lookup_sids_invalid);\n\tsuite->description = talloc_strdup(suite, \"WINBIND - struct based protocol tests\");\n\treturn suite;\n}", "target": 0}
{"code": "static gboolean prplcb_xfer_new_send_cb(gpointer data, gint fd, b_input_condition cond)\n{\n\tPurpleXfer *xfer = data;\n\tstruct im_connection *ic = purple_ic_by_pa(xfer->account);\n\tstruct prpl_xfer_data *px = xfer->ui_data;\n\tPurpleBuddy *buddy;\n\tconst char *who;\n\tbuddy = purple_find_buddy(xfer->account, xfer->who);\n\twho = buddy ? purple_buddy_get_name(buddy) : xfer->who;\n\tpx->ft = imcb_file_send_start(ic, (char *) who, xfer->filename, xfer->size);\n\tif (!px->ft) {\n\t\treturn FALSE;\n\t}\n\tpx->ft->data = px;\n\tpx->ft->accept = prpl_xfer_accept;\n\tpx->ft->canceled = prpl_xfer_canceled;\n\tpx->ft->free = prpl_xfer_free;\n\tpx->ft->write_request = prpl_xfer_write_request;\n\treturn FALSE;\n}", "target": 0}
{"code": "static void usage(void)\n{\n  PRINT_VERSION;\n  puts(\"Copyright (c) 2011, Oracle and/or its affiliates. \"\n       \"All rights reserved.\\n\");\n  puts(\"Enable or disable plugins.\");\n  printf(\"\\nUsage: %s [options] <plugin> ENABLE|DISABLE\\n\\nOptions:\\n\",\n     my_progname);\n  my_print_help(my_long_options);\n  puts(\"\\n\");\n}", "target": 1}
{"code": "static long cec_adap_g_log_addrs(struct cec_adapter *adap,\n\t\t\t\t struct cec_log_addrs __user *parg)\n{\n\tstruct cec_log_addrs log_addrs;\n\tmutex_lock(&adap->lock);\n\tlog_addrs = adap->log_addrs;\n\tif (!adap->is_configured)\n\t\tmemset(log_addrs.log_addr, CEC_LOG_ADDR_INVALID,\n\t\t       sizeof(log_addrs.log_addr));\n\tmutex_unlock(&adap->lock);\n\tif (copy_to_user(parg, &log_addrs, sizeof(log_addrs)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "bgp_capability_mp_data (struct stream *s, struct capability_mp_data *mpc)\n{\n  mpc->afi = stream_getw (s);\n  mpc->reserved = stream_getc (s);\n  mpc->safi = stream_getc (s);\n}", "target": 0}
{"code": "static void __init netlink_add_usersock_entry(void)\n{\n\tstruct listeners *listeners;\n\tint groups = 32;\n\tlisteners = kzalloc(sizeof(*listeners) + NLGRPSZ(groups), GFP_KERNEL);\n\tif (!listeners)\n\t\tpanic(\"netlink_add_usersock_entry: Cannot allocate listeners\\n\");\n\tnetlink_table_grab();\n\tnl_table[NETLINK_USERSOCK].groups = groups;\n\trcu_assign_pointer(nl_table[NETLINK_USERSOCK].listeners, listeners);\n\tnl_table[NETLINK_USERSOCK].module = THIS_MODULE;\n\tnl_table[NETLINK_USERSOCK].registered = 1;\n\tnl_table[NETLINK_USERSOCK].nl_nonroot = NL_NONROOT_SEND;\n\tnetlink_table_ungrab();\n}", "target": 0}
{"code": "void blk_mq_free_tag_set(struct blk_mq_tag_set *set)\n{\n\tint i;\n\tfor (i = 0; i < set->nr_hw_queues; i++) {\n\t\tif (set->tags[i]) {\n\t\t\tblk_mq_free_rq_map(set, set->tags[i], i);\n\t\t\tfree_cpumask_var(set->tags[i]->cpumask);\n\t\t}\n\t}\n\tkfree(set->tags);\n\tset->tags = NULL;\n}", "target": 0}
{"code": "static int show_stat(struct kmem_cache *s, char *buf, enum stat_item si)\n{\n\tunsigned long sum  = 0;\n\tint cpu;\n\tint len;\n\tint *data = kmalloc(nr_cpu_ids * sizeof(int), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tfor_each_online_cpu(cpu) {\n\t\tunsigned x = get_cpu_slab(s, cpu)->stat[si];\n\t\tdata[cpu] = x;\n\t\tsum += x;\n\t}\n\tlen = sprintf(buf, \"%lu\", sum);\n#ifdef CONFIG_SMP\n\tfor_each_online_cpu(cpu) {\n\t\tif (data[cpu] && len < PAGE_SIZE - 20)\n\t\t\tlen += sprintf(buf + len, \" C%d=%u\", cpu, data[cpu]);\n\t}\n#endif\n\tkfree(data);\n\treturn len + sprintf(buf + len, \"\\n\");\n}", "target": 0}
{"code": "static void opt_kfree_rcu(struct rcu_head *head)\n{\n\tkfree(container_of(head, struct ip_options_rcu, rcu));\n}", "target": 0}
{"code": "prepare_singleton_class(mrb_state *mrb, struct RBasic *o)\n{\n  struct RClass *sc, *c;\n  mrb_assert(o->c);\n  if (o->c->tt == MRB_TT_SCLASS) return;\n  sc = MRB_OBJ_ALLOC(mrb, MRB_TT_SCLASS, mrb->class_class);\n  sc->flags |= MRB_FL_CLASS_IS_INHERITED;\n  sc->mt = mt_new(mrb);\n  sc->iv = 0;\n  if (o->tt == MRB_TT_CLASS) {\n    c = (struct RClass*)o;\n    if (!c->super) {\n      sc->super = mrb->class_class;\n    }\n    else {\n      sc->super = c->super->c;\n    }\n  }\n  else if (o->tt == MRB_TT_SCLASS) {\n    c = (struct RClass*)o;\n    while (c->super->tt == MRB_TT_ICLASS)\n      c = c->super;\n    make_metaclass(mrb, c->super);\n    sc->super = c->super->c;\n  }\n  else {\n    sc->super = o->c;\n    prepare_singleton_class(mrb, (struct RBasic*)sc);\n  }\n  o->c = sc;\n  mrb_field_write_barrier(mrb, (struct RBasic*)o, (struct RBasic*)sc);\n  mrb_field_write_barrier(mrb, (struct RBasic*)sc, (struct RBasic*)o);\n  mrb_obj_iv_set(mrb, (struct RObject*)sc, MRB_SYM(__attached__), mrb_obj_value(o));\n  sc->flags |= o->flags & MRB_FL_OBJ_IS_FROZEN;\n}", "target": 0}
{"code": "static void *command_init(struct pci_dev *dev, int offset)\n{\n\tstruct pci_cmd_info *cmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\n\tint err;\n\tif (!cmd)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = pci_read_config_word(dev, PCI_COMMAND, &cmd->val);\n\tif (err) {\n\t\tkfree(cmd);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn cmd;\n}", "target": 0}
{"code": "bits_at(const OnigCodePoint *c, const int n)\n{\n  return bits_of(c[n / 3], n % 3);\n}", "target": 0}
{"code": "    PngImage::PngImage(BasicIo::UniquePtr io, bool create)\n            : Image(ImageType::png, mdExif | mdIptc | mdXmp | mdComment, std::move(io))\n    {\n        if (create)\n        {\n            if (io_->open() == 0)\n            {\n#ifdef DEBUG\n                std::cerr << \"Exiv2::PngImage:: Creating PNG image to memory\\n\";\n#endif\n                IoCloser closer(*io_);\n                if (io_->write(pngBlank, sizeof(pngBlank)) != sizeof(pngBlank))\n                {\n#ifdef DEBUG\n                    std::cerr << \"Exiv2::PngImage:: Failed to create PNG image on memory\\n\";\n#endif\n                }\n            }\n        }\n    } ", "target": 0}
{"code": "lyd_new_leaf(struct lyd_node *parent, const struct lys_module *module, const char *name, const char *val_str)\n{\n    const struct lys_node *snode = NULL, *siblings;\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n    siblings = lyd_new_find_schema(parent, module, 0);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_LEAFLIST | LYS_LEAF, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n    return _lyd_new_leaf(parent, snode, val_str, 0, 0);\n}", "target": 1}
{"code": "ipf_extract_frags_from_batch(struct ipf *ipf, struct dp_packet_batch *pb,\n                             ovs_be16 dl_type, uint16_t zone, long long now,\n                             uint32_t hash_basis)\n{\n    const size_t pb_cnt = dp_packet_batch_size(pb);\n    int pb_idx; \n    struct dp_packet *pkt;\n    DP_PACKET_BATCH_REFILL_FOR_EACH (pb_idx, pb_cnt, pkt, pb) {\n        if (OVS_UNLIKELY((dl_type == htons(ETH_TYPE_IP) &&\n                          ipf_is_valid_v4_frag(ipf, pkt))\n                          ||\n                          (dl_type == htons(ETH_TYPE_IPV6) &&\n                          ipf_is_valid_v6_frag(ipf, pkt)))) {\n            ovs_mutex_lock(&ipf->ipf_lock);\n            if (!ipf_handle_frag(ipf, pkt, dl_type, zone, now, hash_basis)) {\n                dp_packet_batch_refill(pb, pkt, pb_idx);\n            } else {\n                dp_packet_delete(pkt);\n            }\n            ovs_mutex_unlock(&ipf->ipf_lock);\n        } else {\n            dp_packet_batch_refill(pb, pkt, pb_idx);\n        }\n    }\n}", "target": 0}
{"code": "Status TensorSliceReader::GetTensor(\n    const string& name, std::unique_ptr<tensorflow::Tensor>* out_tensor) const {\n  DataType type;\n  TensorShape shape;\n  TensorSlice slice;\n  {\n    mutex_lock l(mu_);\n    const TensorSliceSet* tss = gtl::FindPtrOrNull(tensors_, name);\n    if (tss == nullptr) {\n      return errors::NotFound(name, \" not found in checkpoint file\");\n    }\n    if (tss->Slices().size() > 1) {\n      return errors::Unimplemented(\"Sliced checkpoints are not supported\");\n    }\n    type = tss->type();\n    shape = tss->shape();\n    slice = tss->Slices().begin()->second.slice;\n  }\n  std::unique_ptr<tensorflow::Tensor> t(new tensorflow::Tensor(type, shape));\n  bool success = false;\n#define READER_COPY(dt)                                                  \\\n  case dt:                                                               \\\n    success = CopySliceData(name, slice,                                 \\\n                            t->flat<EnumToDataType<dt>::Type>().data()); \\\n    break;\n  switch (type) {\n    READER_COPY(DT_FLOAT);\n    READER_COPY(DT_DOUBLE);\n    READER_COPY(DT_INT32);\n    READER_COPY(DT_UINT8);\n    READER_COPY(DT_INT16);\n    READER_COPY(DT_INT8);\n    READER_COPY(DT_INT64);\n    READER_COPY(DT_STRING);\n    default:\n      return errors::Unimplemented(\"Data type not supported\");\n  }\n#undef READER_COPY\n  if (!success) {\n    return errors::NotFound(name, \" not found in checkpoint file\");\n  }\n  std::swap(*out_tensor, t);\n  return Status::OK();\n}", "target": 1}
{"code": "TfLiteStatus PrepareHashtableImport(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 3);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 0);\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputResourceIdTensor);\n  TF_LITE_ENSURE_EQ(context, input_resource_id_tensor->type, kTfLiteInt32);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input_resource_id_tensor), 1);\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(input_resource_id_tensor, 0), 1);\n  const TfLiteTensor* key_tensor = GetInput(context, node, kKeyTensor);\n  const TfLiteTensor* value_tensor = GetInput(context, node, kValueTensor);\n  TF_LITE_ENSURE(context, (key_tensor->type == kTfLiteInt64 &&\n                           value_tensor->type == kTfLiteString) ||\n                              (key_tensor->type == kTfLiteString &&\n                               value_tensor->type == kTfLiteInt64));\n  TF_LITE_ENSURE(context, HaveSameShapes(key_tensor, value_tensor));\n  return kTfLiteOk;\n}", "target": 1}
{"code": "xfs_acl_from_disk(struct xfs_acl *aclp)\n{\n\tstruct posix_acl_entry *acl_e;\n\tstruct posix_acl *acl;\n\tstruct xfs_acl_entry *ace;\n\tint count, i;\n\tcount = be32_to_cpu(aclp->acl_cnt);\n\tif (count > XFS_ACL_MAX_ENTRIES)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\tacl = posix_acl_alloc(count, GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (i = 0; i < count; i++) {\n\t\tacl_e = &acl->a_entries[i];\n\t\tace = &aclp->acl_entry[i];\n\t\tacl_e->e_tag = be32_to_cpu(ace->ae_tag);\n\t\tacl_e->e_perm = be16_to_cpu(ace->ae_perm);\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\tcase ACL_GROUP:\n\t\t\tacl_e->e_id = be32_to_cpu(ace->ae_id);\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tacl_e->e_id = ACL_UNDEFINED_ID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}", "target": 0}
{"code": "void DoImageProjectiveTransformOp(OpKernelContext* ctx,\n                                  const Interpolation& interpolation,\n                                  const Mode& fill_mode) {\n  const Tensor& images_t = ctx->input(0);\n  const Tensor& transform_t = ctx->input(1);\n  OP_REQUIRES(ctx, images_t.shape().dims() == 4,\n              errors::InvalidArgument(\"Input images must have rank 4\"));\n  OP_REQUIRES(ctx,\n              (TensorShapeUtils::IsMatrix(transform_t.shape()) &&\n               (transform_t.dim_size(0) == images_t.dim_size(0) ||\n                transform_t.dim_size(0) == 1) &&\n               transform_t.dim_size(1) == 8),\n              errors::InvalidArgument(\n                  \"Input transform should be num_images x 8 or 1 x 8\"));\n  int32_t out_height, out_width;\n  if (ctx->num_inputs() >= 3) {\n    const Tensor& shape_t = ctx->input(2);\n    OP_REQUIRES(ctx, shape_t.dims() == 1,\n                errors::InvalidArgument(\"output shape must be 1-dimensional\",\n                                        shape_t.shape().DebugString()));\n    OP_REQUIRES(ctx, shape_t.NumElements() == 2,\n                errors::InvalidArgument(\"output shape must have two elements\",\n                                        shape_t.shape().DebugString()));\n    auto shape_vec = shape_t.vec<int32>();\n    out_height = shape_vec(0);\n    out_width = shape_vec(1);\n    OP_REQUIRES(ctx, out_height > 0 && out_width > 0,\n                errors::InvalidArgument(\"output dimensions must be positive\"));\n  } else {\n    out_height = images_t.shape().dim_size(1);\n    out_width = images_t.shape().dim_size(2);\n  }\n  T fill_value(0);\n  if (ctx->num_inputs() >= 4) {\n    const Tensor& fill_value_t = ctx->input(3);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(fill_value_t.shape()),\n                errors::InvalidArgument(\"fill_value must be a scalar\",\n                                        fill_value_t.shape().DebugString()));\n    fill_value = static_cast<T>(*(fill_value_t.scalar<float>().data()));\n  }\n  Tensor* output_t;\n  OP_REQUIRES_OK(\n      ctx, ctx->allocate_output(0,\n                                TensorShape({images_t.dim_size(0), out_height,\n                                             out_width, images_t.dim_size(3)}),\n                                &output_t));\n  auto output = output_t->tensor<T, 4>();\n  auto images = images_t.tensor<T, 4>();\n  auto transform = transform_t.matrix<float>();\n  (FillProjectiveTransform<Device, T>(interpolation))(\n      ctx->eigen_device<Device>(), &output, images, transform, fill_mode,\n      fill_value);\n}", "target": 1}
{"code": "BOOL glyph_cache_put(rdpGlyphCache* glyphCache, UINT32 id, UINT32 index, rdpGlyph* glyph)\n{\n\trdpGlyph* prevGlyph;\n\tif (id > 9)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache id: %\" PRIu32 \"\", id);\n\t\treturn FALSE;\n\t}\n\tif (index > glyphCache->glyphCache[id].number)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache index: %\" PRIu32 \" in cache id: %\" PRIu32 \"\", index, id);\n\t\treturn FALSE;\n\t}\n\tWLog_Print(glyphCache->log, WLOG_DEBUG, \"GlyphCachePut: id: %\" PRIu32 \" index: %\" PRIu32 \"\", id,\n\t           index);\n\tprevGlyph = glyphCache->glyphCache[id].entries[index];\n\tif (prevGlyph)\n\t\tprevGlyph->Free(glyphCache->context, prevGlyph);\n\tglyphCache->glyphCache[id].entries[index] = glyph;\n\treturn TRUE;\n}", "target": 1}
{"code": "static void record_recent_object(struct object *obj,\n\t\t\t\t struct strbuf *path,\n\t\t\t\t const char *last,\n\t\t\t\t void *data)\n{\n\tsha1_array_append(&recent_objects, obj->oid.hash);\n}", "target": 1}
{"code": "int numa_zonelist_order_handler(struct ctl_table *table, int write,\n\t\tvoid __user *buffer, size_t *length,\n\t\tloff_t *ppos)\n{\n\tchar *str;\n\tint ret;\n\tif (!write)\n\t\treturn proc_dostring(table, write, buffer, length, ppos);\n\tstr = memdup_user_nul(buffer, 16);\n\tif (IS_ERR(str))\n\t\treturn PTR_ERR(str);\n\tret = __parse_numa_zonelist_order(str);\n\tkfree(str);\n\treturn ret;\n}", "target": 0}
{"code": "static int dir_contains_only_dotgit(const char *path)\n{\n\tDIR *dir = opendir(path);\n\tstruct dirent *e;\n\tint ret = 1;\n\tif (!dir)\n\t\treturn 0;\n\te = readdir_skip_dot_and_dotdot(dir);\n\tif (!e)\n\t\tret = 0;\n\telse if (strcmp(DEFAULT_GIT_DIR_ENVIRONMENT, e->d_name) ||\n\t\t (e = readdir_skip_dot_and_dotdot(dir))) {\n\t\terror(\"unexpected item '%s' in '%s'\", e->d_name, path);\n\t\tret = 0;\n\t}\n\tclosedir(dir);\n\treturn ret;\n}", "target": 0}
{"code": "static void keyring_describe(const struct key *keyring, struct seq_file *m)\n{\n\tif (keyring->description)\n\t\tseq_puts(m, keyring->description);\n\telse\n\t\tseq_puts(m, \"[anon]\");\n\tif (key_is_instantiated(keyring)) {\n\t\tif (keyring->keys.nr_leaves_on_tree != 0)\n\t\t\tseq_printf(m, \": %lu\", keyring->keys.nr_leaves_on_tree);\n\t\telse\n\t\t\tseq_puts(m, \": empty\");\n\t}\n}", "target": 1}
{"code": "static int unix_dgram_connect(struct socket *sock, struct sockaddr *addr,\n\t\t\t      int alen, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\tstruct sockaddr_un *sunaddr = (struct sockaddr_un *)addr;\n\tstruct sock *other;\n\tunsigned int hash;\n\tint err;\n\tif (addr->sa_family != AF_UNSPEC) {\n\t\terr = unix_mkname(sunaddr, alen, &hash);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\talen = err;\n\t\tif (test_bit(SOCK_PASSCRED, &sock->flags) &&\n\t\t    !unix_sk(sk)->addr && (err = unix_autobind(sock)) != 0)\n\t\t\tgoto out;\nrestart:\n\t\tother = unix_find_other(net, sunaddr, alen, sock->type, hash, &err);\n\t\tif (!other)\n\t\t\tgoto out;\n\t\tunix_state_double_lock(sk, other);\n\t\tif (sock_flag(other, SOCK_DEAD)) {\n\t\t\tunix_state_double_unlock(sk, other);\n\t\t\tsock_put(other);\n\t\t\tgoto restart;\n\t\t}\n\t\terr = -EPERM;\n\t\tif (!unix_may_send(sk, other))\n\t\t\tgoto out_unlock;\n\t\terr = security_unix_may_send(sk->sk_socket, other->sk_socket);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t} else {\n\t\tother = NULL;\n\t\tunix_state_double_lock(sk, other);\n\t}\n\tif (unix_peer(sk)) {\n\t\tstruct sock *old_peer = unix_peer(sk);\n\t\tunix_peer(sk) = other;\n\t\tunix_dgram_peer_wake_disconnect_wakeup(sk, old_peer);\n\t\tunix_state_double_unlock(sk, other);\n\t\tif (other != old_peer)\n\t\t\tunix_dgram_disconnected(sk, old_peer);\n\t\tsock_put(old_peer);\n\t} else {\n\t\tunix_peer(sk) = other;\n\t\tunix_state_double_unlock(sk, other);\n\t}\n\treturn 0;\nout_unlock:\n\tunix_state_double_unlock(sk, other);\n\tsock_put(other);\nout:\n\treturn err;\n}", "target": 0}
{"code": "atol10(const char *p, size_t char_cnt)\n{\n\tuint64_t l;\n\tint digit;\n\tif (char_cnt == 0)\n\t\treturn (0);\n\tl = 0;\n\tdigit = *p - '0';\n\twhile (digit >= 0 && digit < 10  && char_cnt-- > 0) {\n\t\tl = (l * 10) + digit;\n\t\tdigit = *++p - '0';\n\t}\n\treturn (l);\n}", "target": 0}
{"code": "void ath_tx_aggr_sleep(struct ieee80211_sta *sta, struct ath_softc *sc,\n\t\t       struct ath_node *an)\n{\n\tstruct ath_atx_tid *tid;\n\tstruct ath_atx_ac *ac;\n\tstruct ath_txq *txq;\n\tbool buffered;\n\tint tidno;\n\tfor (tidno = 0, tid = &an->tid[tidno];\n\t     tidno < IEEE80211_NUM_TIDS; tidno++, tid++) {\n\t\tif (!tid->sched)\n\t\t\tcontinue;\n\t\tac = tid->ac;\n\t\ttxq = ac->txq;\n\t\tath_txq_lock(sc, txq);\n\t\tbuffered = ath_tid_has_buffered(tid);\n\t\ttid->sched = false;\n\t\tlist_del(&tid->list);\n\t\tif (ac->sched) {\n\t\t\tac->sched = false;\n\t\t\tlist_del(&ac->list);\n\t\t}\n\t\tath_txq_unlock(sc, txq);\n\t\tieee80211_sta_set_buffered(sta, tidno, buffered);\n\t}\n}", "target": 1}
{"code": "snmp_api_set_time_ticks(snmp_varbind_t *varbind, uint32_t *oid, uint32_t integer)\n{\n  snmp_api_replace_oid(varbind, oid);\n  varbind->value_type = SNMP_DATA_TYPE_TIME_TICKS;\n  varbind->value.integer = integer;\n}", "target": 1}
{"code": "static int _kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)\n{\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\t*val = vcpu->arch.db[dr];\n\t\tbreak;\n\tcase 4:\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\t\treturn 1;\n\tcase 6:\n\t\t*val = vcpu->arch.dr6;\n\t\tbreak;\n\tcase 5:\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\t\treturn 1;\n\tdefault: \n\t\t*val = vcpu->arch.dr7;\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "GopherStateData::DelayAwareRead(GopherStateData *gopherState)\n{\n    const auto &conn = gopherState->serverConn;\n    if (!Comm::IsConnOpen(conn) || fd_table[conn->fd].closing()) {\n        debugs(10, 3, \"will not read from \" << conn);\n        return;\n    }\n    const auto amountToRead = gopherState->entry->bytesWanted(Range<size_t>(0, BUFSIZ));\n    if (amountToRead <= 0) {\n        AsyncCall::Pointer delayCall = asyncCall(10, 3, \"GopherStateData::DelayAwareRead\",\n                                       cbdataDialer(&GopherStateData::DelayAwareRead, gopherState));\n        gopherState->entry->mem().delayRead(delayCall);\n        return;\n    }\n    AsyncCall::Pointer readCall = commCbCall(5, 5, \"gopherReadReply\", CommIoCbPtrFun(gopherReadReply, gopherState));\n    comm_read(conn, gopherState->replybuf, amountToRead, readCall);\n}", "target": 1}
{"code": "int xt_compat_check_entry_offsets(const void *base,\n\t\t\t\t  unsigned int target_offset,\n\t\t\t\t  unsigned int next_offset)\n{\n\tconst struct compat_xt_entry_target *t;\n\tconst char *e = base;\n\tif (target_offset + sizeof(*t) > next_offset)\n\t\treturn -EINVAL;\n\tt = (void *)(e + target_offset);\n\tif (t->u.target_size < sizeof(*t))\n\t\treturn -EINVAL;\n\tif (target_offset + t->u.target_size > next_offset)\n\t\treturn -EINVAL;\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) == 0 &&\n\t    target_offset + sizeof(struct compat_xt_standard_target) != next_offset)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "static String cachedStorageDirectory(DWORD pathIdentifier)\n{\n    static HashMap<DWORD, String> directories;\n    HashMap<DWORD, String>::iterator it = directories.find(pathIdentifier);\n    if (it != directories.end())\n        return it->value;\n    String directory = storageDirectory(pathIdentifier);\n    directories.add(pathIdentifier, directory);\n    return directory;\n}", "target": 0}
{"code": "static int mbochs_probe(struct mdev_device *mdev)\n{\n\tconst struct mbochs_type *type =\n\t\t&mbochs_types[mdev_get_type_group_id(mdev)];\n\tstruct device *dev = mdev_dev(mdev);\n\tstruct mdev_state *mdev_state;\n\tint ret = -ENOMEM;\n\tif (type->mbytes + mbochs_used_mbytes > max_mbytes)\n\t\treturn -ENOMEM;\n\tmdev_state = kzalloc(sizeof(struct mdev_state), GFP_KERNEL);\n\tif (mdev_state == NULL)\n\t\treturn -ENOMEM;\n\tvfio_init_group_dev(&mdev_state->vdev, &mdev->dev, &mbochs_dev_ops);\n\tmdev_state->vconfig = kzalloc(MBOCHS_CONFIG_SPACE_SIZE, GFP_KERNEL);\n\tif (mdev_state->vconfig == NULL)\n\t\tgoto err_mem;\n\tmdev_state->memsize = type->mbytes * 1024 * 1024;\n\tmdev_state->pagecount = mdev_state->memsize >> PAGE_SHIFT;\n\tmdev_state->pages = kcalloc(mdev_state->pagecount,\n\t\t\t\t    sizeof(struct page *),\n\t\t\t\t    GFP_KERNEL);\n\tif (!mdev_state->pages)\n\t\tgoto err_mem;\n\tdev_info(dev, \"%s: %s, %d MB, %ld pages\\n\", __func__,\n\t\t type->name, type->mbytes, mdev_state->pagecount);\n\tmutex_init(&mdev_state->ops_lock);\n\tmdev_state->mdev = mdev;\n\tINIT_LIST_HEAD(&mdev_state->dmabufs);\n\tmdev_state->next_id = 1;\n\tmdev_state->type = type;\n\tmdev_state->edid_regs.max_xres = type->max_x;\n\tmdev_state->edid_regs.max_yres = type->max_y;\n\tmdev_state->edid_regs.edid_offset = MBOCHS_EDID_BLOB_OFFSET;\n\tmdev_state->edid_regs.edid_max_size = sizeof(mdev_state->edid_blob);\n\tmbochs_create_config_space(mdev_state);\n\tmbochs_reset(mdev_state);\n\tmbochs_used_mbytes += type->mbytes;\n\tret = vfio_register_group_dev(&mdev_state->vdev);\n\tif (ret)\n\t\tgoto err_mem;\n\tdev_set_drvdata(&mdev->dev, mdev_state);\n\treturn 0;\nerr_mem:\n\tkfree(mdev_state->vconfig);\n\tkfree(mdev_state);\n\treturn ret;\n}", "target": 1}
{"code": "iso9660_finish_entry(struct archive_write *a)\n{\n\tstruct iso9660 *iso9660 = a->format_data;\n\tif (iso9660->cur_file == NULL)\n\t\treturn (ARCHIVE_OK);\n\tif (archive_entry_filetype(iso9660->cur_file->entry) != AE_IFREG)\n\t\treturn (ARCHIVE_OK);\n\tif (iso9660->cur_file->content.size == 0)\n\t\treturn (ARCHIVE_OK);\n\twhile (iso9660->bytes_remaining > 0) {\n\t\tsize_t s;\n\t\ts = (iso9660->bytes_remaining > a->null_length)?\n\t\t    a->null_length: (size_t)iso9660->bytes_remaining;\n\t\tif (write_iso9660_data(a, a->nulls, s) < 0)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tiso9660->bytes_remaining -= s;\n\t}\n\tif (iso9660->zisofs.making && zisofs_finish_entry(a) != ARCHIVE_OK)\n\t\treturn (ARCHIVE_FATAL);\n\tif (wb_write_padding_to_temp(a, iso9660->cur_file->cur_content->size)\n\t    != ARCHIVE_OK)\n\t\treturn (ARCHIVE_FATAL);\n\tiso9660->cur_file->cur_content->blocks = (int)\n\t    ((iso9660->cur_file->cur_content->size\n\t     + LOGICAL_BLOCK_SIZE -1) >> LOGICAL_BLOCK_BITS);\n\tisofile_add_data_file(iso9660, iso9660->cur_file);\n\treturn (ARCHIVE_OK);\n}", "target": 0}
{"code": "static bool check_underflow(const struct ip6t_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\tif (!unconditional(&e->ipv6))\n\t\treturn false;\n\tt = ip6t_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}", "target": 1}
{"code": "static int append_session_tasks_max(pam_handle_t *handle, sd_bus_message *m, const char *limit) {\n        uint64_t val;\n        int r;\n        if (isempty(limit) || streq(limit, \"infinity\"))\n                return 0;\n        r = safe_atou64(limit, &val);\n        if (r >= 0) {\n                r = sd_bus_message_append(m, \"(sv)\", \"TasksMax\", \"t\", val);\n                if (r < 0) {\n                        pam_syslog(handle, LOG_ERR, \"Failed to append to bus message: %s\", strerror(-r));\n                        return r;\n                }\n        } else\n                pam_syslog(handle, LOG_WARNING, \"Failed to parse systemd.limit: %s, ignoring.\", limit);\n        return 0;\n}", "target": 0}
{"code": "static inline u64 get_canonical(u64 la)\n{\n\treturn ((int64_t)la << 16) >> 16;\n}", "target": 0}
{"code": "static int kvaser_usb_leaf_flush_queue(struct kvaser_usb_net_priv *priv)\n{\n\tstruct kvaser_cmd *cmd;\n\tint rc;\n\tcmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\tcmd->id = CMD_FLUSH_QUEUE;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_flush_queue);\n\tcmd->u.flush_queue.channel = priv->channel;\n\tcmd->u.flush_queue.flags = 0x00;\n\trc = kvaser_usb_send_cmd(priv->dev, cmd, cmd->len);\n\tkfree(cmd);\n\treturn rc;\n}", "target": 1}
{"code": "static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tjp2_cdefchan_t *chan;\n\tunsigned int channo;\n\tcdef->ents = 0;\n\tif (jp2_getuint16(in, &cdef->numchans)) {\n\t\treturn -1;\n\t}\n\tif (!(cdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t)))) {\n\t\treturn -1;\n\t}\n\tfor (channo = 0; channo < cdef->numchans; ++channo) {\n\t\tchan = &cdef->ents[channo];\n\t\tif (jp2_getuint16(in, &chan->channo) || jp2_getuint16(in, &chan->type) ||\n\t\t  jp2_getuint16(in, &chan->assoc)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void unlink_anon_vmas(struct vm_area_struct *vma)\n{\n\tstruct anon_vma_chain *avc, *next;\n\tstruct anon_vma *root = NULL;\n\tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma = avc->anon_vma;\n\t\troot = lock_anon_vma_root(root, anon_vma);\n\t\tanon_vma_interval_tree_remove(avc, &anon_vma->rb_root);\n\t\tif (RB_EMPTY_ROOT(&anon_vma->rb_root.rb_root)) {\n\t\t\tanon_vma->parent->degree--;\n\t\t\tcontinue;\n\t\t}\n\t\tlist_del(&avc->same_vma);\n\t\tanon_vma_chain_free(avc);\n\t}\n\tif (vma->anon_vma) {\n\t\tvma->anon_vma->degree--;\n\t\tvma->anon_vma = NULL;\n\t}\n\tunlock_anon_vma_root(root);\n\tlist_for_each_entry_safe(avc, next, &vma->anon_vma_chain, same_vma) {\n\t\tstruct anon_vma *anon_vma = avc->anon_vma;\n\t\tVM_WARN_ON(anon_vma->degree);\n\t\tput_anon_vma(anon_vma);\n\t\tlist_del(&avc->same_vma);\n\t\tanon_vma_chain_free(avc);\n\t}\n}", "target": 1}
{"code": "static void adpt_alpha_info(sysInfo_S* si)\n{\n\tsi->processorType = PROC_ALPHA;\n}", "target": 1}
{"code": "static void iov_fault_in_pages_read(struct iovec *iov, unsigned long len)\n{\n\twhile (!iov->iov_len)\n\t\tiov++;\n\twhile (len > 0) {\n\t\tunsigned long this_len;\n\t\tthis_len = min_t(unsigned long, len, iov->iov_len);\n\t\tfault_in_pages_readable(iov->iov_base, this_len);\n\t\tlen -= this_len;\n\t\tiov++;\n\t}\n}", "target": 1}
{"code": "static void test_simple()\n{\n    json_set_alloc_funcs(my_malloc, my_free);\n    create_and_free_complex_object();\n    if(malloc_called != 20 || free_called != 20)\n        fail(\"Custom allocation failed\");\n}", "target": 1}
{"code": "static int udp_push_pending_frames(struct sock *sk)\n{\n\tstruct udp_sock  *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct flowi4 *fl4 = &inet->cork.fl.u.ip4;\n\tstruct sk_buff *skb;\n\tint err = 0;\n\tskb = ip_finish_skb(sk, fl4);\n\tif (!skb)\n\t\tgoto out;\n\terr = udp_send_skb(skb, fl4);\nout:\n\tup->len = 0;\n\tup->pending = 0;\n\treturn err;\n}", "target": 1}
{"code": "static int hci_sock_blacklist_add(struct hci_dev *hdev, void __user *arg)\n{\n\tbdaddr_t bdaddr;\n\tint err;\n\tif (copy_from_user(&bdaddr, arg, sizeof(bdaddr)))\n\t\treturn -EFAULT;\n\thci_dev_lock(hdev);\n\terr = hci_blacklist_add(hdev, &bdaddr, 0);\n\thci_dev_unlock(hdev);\n\treturn err;\n}", "target": 0}
{"code": "void URI_FUNC(ResetUri)(URI_TYPE(Uri) * uri) {\n\tif (uri == NULL) {\n\t\treturn;\n\t}\n\tmemset(uri, 0, sizeof(URI_TYPE(Uri)));\n}", "target": 0}
{"code": "jas_stream_t *jas_stream_memopen2(char *buf, size_t bufsize)\n{\n\tjas_stream_t *stream;\n\tjas_stream_memobj_t *obj;\n\tJAS_DBGLOG(100, (\"jas_stream_memopen2(%p, %zu)\\n\", buf, bufsize));\n\tassert((buf && bufsize > 0) || (!buf));\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\tstream->ops_ = &jas_stream_memops;\n\tif (!(obj = jas_malloc(sizeof(jas_stream_memobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tstream->obj_ = (void *) obj;\n\tobj->myalloc_ = 0;\n\tobj->buf_ = 0;\n\tif (!bufsize) {\n\t\tobj->bufsize_ = 1024;\n\t\tobj->growable_ = 1;\n\t} else {\n\t\tobj->bufsize_ = bufsize;\n\t\tobj->growable_ = 0;\n\t}\n\tif (buf) {\n\t\tobj->buf_ = JAS_CAST(unsigned char *, buf);\n\t} else {\n\t\tobj->buf_ = jas_malloc(obj->bufsize_);\n\t\tobj->myalloc_ = 1;\n\t}\n\tif (!obj->buf_) {\n\t\tjas_stream_close(stream);\n\t\treturn 0;\n\t}\n\tJAS_DBGLOG(100, (\"jas_stream_memopen2 buffer buf=%p myalloc=%d\\n\",\n\t  obj->buf_, obj->myalloc_));\n\tif (bufsize > 0 && buf) {\n\t\tobj->len_ = bufsize;\n\t} else {\n\t\tobj->len_ = 0;\n\t}\n\tobj->pos_ = 0;\n\treturn stream;\n}", "target": 0}
{"code": "static inline int ealg_tmpl_set(const struct xfrm_tmpl *t,\n\t\t\t\tconst struct xfrm_algo_desc *d)\n{\n\tunsigned int id = d->desc.sadb_alg_id;\n\tif (id >= sizeof(t->ealgos) * 8)\n\t\treturn 0;\n\treturn (t->ealgos >> id) & 1;\n}", "target": 0}
{"code": "WM_SYMBOL midi *WildMidi_OpenBuffer(uint8_t *midibuffer, uint32_t size) {\n    uint8_t mus_hdr[] = { 'M', 'U', 'S', 0x1A };\n    uint8_t xmi_hdr[] = { 'F', 'O', 'R', 'M' };\n    midi * ret = NULL;\n    if (!WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (NULL);\n    }\n    if (midibuffer == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL midi data buffer)\", 0);\n        return (NULL);\n    }\n    if (size > WM_MAXFILESIZE) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_LONGFIL, NULL, 0);\n        return (NULL);\n    }\n    if (size < 18) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n        return (NULL);\n    }\n    if (memcmp(midibuffer,\"HMIMIDIP\", 8) == 0) {\n        ret = (void *) _WM_ParseNewHmp(midibuffer, size);\n    } else if (memcmp(midibuffer, \"HMI-MIDISONG061595\", 18) == 0) {\n        ret = (void *) _WM_ParseNewHmi(midibuffer, size);\n    } else if (memcmp(midibuffer, mus_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewMus(midibuffer, size);\n    } else if (memcmp(midibuffer, xmi_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewXmi(midibuffer, size);\n    } else {\n        ret = (void *) _WM_ParseNewMidi(midibuffer, size);\n    }\n    if (ret) {\n        if (add_handle(ret) != 0) {\n            WildMidi_Close(ret);\n            ret = NULL;\n        }\n    }\n    return (ret);\n}", "target": 0}
{"code": "static int cdrom_ioctl_drive_status(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_DRIVE_STATUS\\n\");\n\tif (!(cdi->ops->capability & CDC_DRIVE_STATUS))\n\t\treturn -ENOSYS;\n\tif (!CDROM_CAN(CDC_SELECT_DISC) ||\n\t    (arg == CDSL_CURRENT || arg == CDSL_NONE))\n\t\treturn cdi->ops->drive_status(cdi, CDSL_CURRENT);\n\tif (((int)arg >= cdi->capacity))\n\t\treturn -EINVAL;\n\treturn cdrom_slot_status(cdi, arg);\n}", "target": 1}
{"code": "static bool snd_ctl_remove_numid_conflict(struct snd_card *card,\n\t\t\t\t\t  unsigned int count)\n{\n\tstruct snd_kcontrol *kctl;\n\tif (card->last_numid >= UINT_MAX - count)\n\t\tcard->last_numid = 0;\n\tlist_for_each_entry(kctl, &card->controls, list) {\n\t\tif (kctl->id.numid < card->last_numid + 1 + count &&\n\t\t    kctl->id.numid + kctl->count > card->last_numid + 1) {\n\t\t    \tcard->last_numid = kctl->id.numid + kctl->count - 1;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 0}
{"code": "ConnectionManagerImpl::ActiveStream::~ActiveStream() {\n  stream_info_.onRequestComplete();\n  if (!stream_info_.hasAnyResponseFlag() && !stream_info_.responseCode()) {\n    stream_info_.setResponseFlag(StreamInfo::ResponseFlag::DownstreamConnectionTermination);\n  }\n  connection_manager_.stats_.named_.downstream_rq_active_.dec();\n  if (request_headers_ != nullptr) {\n    request_headers_->refreshByteSize();\n  }\n  if (response_headers_ != nullptr) {\n    response_headers_->refreshByteSize();\n  }\n  if (response_trailers_ != nullptr) {\n    response_trailers_->refreshByteSize();\n  }\n  for (const AccessLog::InstanceSharedPtr& access_log : connection_manager_.config_.accessLogs()) {\n    access_log->log(request_headers_.get(), response_headers_.get(), response_trailers_.get(),\n                    stream_info_);\n  }\n  for (const auto& log_handler : access_log_handlers_) {\n    log_handler->log(request_headers_.get(), response_headers_.get(), response_trailers_.get(),\n                     stream_info_);\n  }\n  if (stream_info_.healthCheck()) {\n    connection_manager_.config_.tracingStats().health_check_.inc();\n  }\n  if (active_span_) {\n    Tracing::HttpTracerUtility::finalizeDownstreamSpan(\n        *active_span_, request_headers_.get(), response_headers_.get(), response_trailers_.get(),\n        stream_info_, *this);\n  }\n  if (state_.successful_upgrade_) {\n    connection_manager_.stats_.named_.downstream_cx_upgrades_active_.dec();\n  }\n  ASSERT(state_.filter_call_state_ == 0);\n}", "target": 0}
{"code": "static int i8042_start(struct serio *serio)\n{\n\tstruct i8042_port *port = serio->port_data;\n\tport->exists = true;\n\tmb();\n\treturn 0;\n}", "target": 1}
{"code": "static void ene_remove(struct pnp_dev *pnp_dev)\n{\n\tstruct ene_device *dev = pnp_get_drvdata(pnp_dev);\n\tunsigned long flags;\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\tene_rx_disable(dev);\n\tene_rx_restore_hw_buffer(dev);\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n\tfree_irq(dev->irq, dev);\n\trelease_region(dev->hw_io, ENE_IO_SIZE);\n\trc_unregister_device(dev->rdev);\n\tkfree(dev);\n}", "target": 1}
{"code": "int compat_get_fd_set(unsigned long nr, compat_ulong_t __user *ufdset,\n\t\t\tunsigned long *fdset)\n{\n\tnr = DIV_ROUND_UP(nr, __COMPAT_NFDBITS);\n\tif (ufdset) {\n\t\tunsigned long odd;\n\t\tif (!access_ok(VERIFY_WRITE, ufdset, nr*sizeof(compat_ulong_t)))\n\t\t\treturn -EFAULT;\n\t\todd = nr & 1UL;\n\t\tnr &= ~1UL;\n\t\twhile (nr) {\n\t\t\tunsigned long h, l;\n\t\t\tif (__get_user(l, ufdset) || __get_user(h, ufdset+1))\n\t\t\t\treturn -EFAULT;\n\t\t\tufdset += 2;\n\t\t\t*fdset++ = h << 32 | l;\n\t\t\tnr -= 2;\n\t\t}\n\t\tif (odd && __get_user(*fdset, ufdset))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tmemset(fdset, 0, ((nr + 1) & ~1)*sizeof(compat_ulong_t));\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "certstack_create(struct cert_stack **result)\n{\n\tstruct cert_stack *stack;\n\tstack = malloc(sizeof(struct cert_stack));\n\tif (stack == NULL)\n\t\treturn pr_enomem();\n\tstack->x509s = sk_X509_new_null();\n\tif (stack->x509s == NULL) {\n\t\tfree(stack);\n\t\treturn val_crypto_err(\"sk_X509_new_null() returned NULL\");\n\t}\n\tSLIST_INIT(&stack->defers);\n\tSLIST_INIT(&stack->metas);\n\tSLIST_INIT(&stack->levels);\n\t*result = stack;\n\treturn 0;\n}", "target": 1}
{"code": "long kvm_arch_vcpu_ioctl(struct file *filp,\n\t\t\t unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm_vcpu *vcpu = filp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tswitch (ioctl) {\n\tcase KVM_ARM_VCPU_INIT: {\n\t\tstruct kvm_vcpu_init init;\n\t\tif (copy_from_user(&init, argp, sizeof(init)))\n\t\t\treturn -EFAULT;\n\t\treturn kvm_vcpu_set_target(vcpu, &init);\n\t}\n\tcase KVM_SET_ONE_REG:\n\tcase KVM_GET_ONE_REG: {\n\t\tstruct kvm_one_reg reg;\n\t\tif (unlikely(!kvm_vcpu_initialized(vcpu)))\n\t\t\treturn -ENOEXEC;\n\t\tif (copy_from_user(&reg, argp, sizeof(reg)))\n\t\t\treturn -EFAULT;\n\t\tif (ioctl == KVM_SET_ONE_REG)\n\t\t\treturn kvm_arm_set_reg(vcpu, &reg);\n\t\telse\n\t\t\treturn kvm_arm_get_reg(vcpu, &reg);\n\t}\n\tcase KVM_GET_REG_LIST: {\n\t\tstruct kvm_reg_list __user *user_list = argp;\n\t\tstruct kvm_reg_list reg_list;\n\t\tunsigned n;\n\t\tif (unlikely(!kvm_vcpu_initialized(vcpu)))\n\t\t\treturn -ENOEXEC;\n\t\tif (copy_from_user(&reg_list, user_list, sizeof(reg_list)))\n\t\t\treturn -EFAULT;\n\t\tn = reg_list.n;\n\t\treg_list.n = kvm_arm_num_regs(vcpu);\n\t\tif (copy_to_user(user_list, &reg_list, sizeof(reg_list)))\n\t\t\treturn -EFAULT;\n\t\tif (n < reg_list.n)\n\t\t\treturn -E2BIG;\n\t\treturn kvm_arm_copy_reg_indices(vcpu, user_list->reg);\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}", "target": 0}
{"code": "static int __ptrace_may_access(struct task_struct *task, unsigned int mode)\n{\n\tconst struct cred *cred = current_cred(), *tcred;\n\tint dumpable = 0;\n\tif (same_thread_group(task, current))\n\t\treturn 0;\n\trcu_read_lock();\n\ttcred = __task_cred(task);\n\tif (uid_eq(cred->uid, tcred->euid) &&\n\t    uid_eq(cred->uid, tcred->suid) &&\n\t    uid_eq(cred->uid, tcred->uid)  &&\n\t    gid_eq(cred->gid, tcred->egid) &&\n\t    gid_eq(cred->gid, tcred->sgid) &&\n\t    gid_eq(cred->gid, tcred->gid))\n\t\tgoto ok;\n\tif (ptrace_has_cap(tcred->user_ns, mode))\n\t\tgoto ok;\n\trcu_read_unlock();\n\treturn -EPERM;\nok:\n\trcu_read_unlock();\n\tsmp_rmb();\n\tif (task->mm)\n\t\tdumpable = get_dumpable(task->mm);\n\trcu_read_lock();\n\tif (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {\n\t\trcu_read_unlock();\n\t\treturn -EPERM;\n\t}\n\trcu_read_unlock();\n\treturn security_ptrace_access_check(task, mode);\n}", "target": 1}
{"code": "static inline int event2keytype(int event)\n{\n\tswitch (event) {\n\tcase XFRM_MSG_DELSA:\n\t\treturn SADB_DELETE;\n\tcase XFRM_MSG_NEWSA:\n\t\treturn SADB_ADD;\n\tcase XFRM_MSG_UPDSA:\n\t\treturn SADB_UPDATE;\n\tcase XFRM_MSG_EXPIRE:\n\t\treturn SADB_EXPIRE;\n\tdefault:\n\t\tpr_err(\"pfkey: Unknown SA event %d\\n\", event);\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static BOOL autodetect_recv_bandwidth_measure_results(rdpRdp* rdp, wStream* s,\n                                                      AUTODETECT_RSP_PDU* autodetectRspPdu)\n{\n\tBOOL success = TRUE;\n\tif (autodetectRspPdu->headerLength != 0x0E)\n\t\treturn FALSE;\n\tWLog_VRB(AUTODETECT_TAG, \"received Bandwidth Measure Results PDU\");\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn -1;\n\tStream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureTimeDelta); \n\tStream_Read_UINT32(s, rdp->autodetect->bandwidthMeasureByteCount); \n\tif (rdp->autodetect->bandwidthMeasureTimeDelta > 0)\n\t\trdp->autodetect->netCharBandwidth = rdp->autodetect->bandwidthMeasureByteCount * 8 /\n\t\t                                    rdp->autodetect->bandwidthMeasureTimeDelta;\n\telse\n\t\trdp->autodetect->netCharBandwidth = 0;\n\tIFCALLRET(rdp->autodetect->BandwidthMeasureResults, success, rdp->context,\n\t          autodetectRspPdu->sequenceNumber);\n\treturn success;\n}", "target": 0}
{"code": "TfLiteStatus MultiplyAndCheckOverflow(size_t a, size_t b, size_t* product) {\n  constexpr size_t size_t_bits = 8 * sizeof(size_t);\n  constexpr size_t overflow_upper_half_bit_position = size_t_bits / 2;\n  *product = a * b;\n  if (TFLITE_EXPECT_FALSE((a | b) >> overflow_upper_half_bit_position != 0)) {\n    if (a != 0 && *product / a != b) return kTfLiteError;\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "nvkm_vmm_unmap_region(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n{\n\tstruct nvkm_vma *next;\n\tnvkm_memory_tags_put(vma->memory, vmm->mmu->subdev.device, &vma->tags);\n\tnvkm_memory_unref(&vma->memory);\n\tif (vma->part) {\n\t\tstruct nvkm_vma *prev = node(vma, prev);\n\t\tif (!prev->memory) {\n\t\t\tprev->size += vma->size;\n\t\t\trb_erase(&vma->tree, &vmm->root);\n\t\t\tlist_del(&vma->head);\n\t\t\tkfree(vma);\n\t\t\tvma = prev;\n\t\t}\n\t}\n\tnext = node(vma, next);\n\tif (next && next->part) {\n\t\tif (!next->memory) {\n\t\t\tvma->size += next->size;\n\t\t\trb_erase(&next->tree, &vmm->root);\n\t\t\tlist_del(&next->head);\n\t\t\tkfree(next);\n\t\t}\n\t}\n}", "target": 1}
{"code": "static void *smm_stub_place_stacks(char *base, size_t size,\n\t\t\t\t   struct smm_loader_params *params)\n{\n\tsize_t total_stack_size;\n\tchar *stacks_top;\n\ttotal_stack_size = params->per_cpu_stack_size *\n\t\t\t   params->num_concurrent_stacks;\n\tprintk(BIOS_DEBUG, \"%s: cpus: %zx : stack space: needed -> %zx\\n\",\n\t\t__func__, params->num_concurrent_stacks,\n\t\ttotal_stack_size);\n\tprintk(BIOS_DEBUG, \"  available -> %zx : per_cpu_stack_size : %zx\\n\",\n\t\tsize, params->per_cpu_stack_size);\n\tif (params->num_concurrent_stacks < 1)\n\t\treturn NULL;\n\tif (total_stack_size > size)\n\t\treturn NULL;\n\tstacks_top = &base[total_stack_size];\n\tprintk(BIOS_DEBUG, \"%s: exit, stack_top %p\\n\", __func__, stacks_top);\n\treturn stacks_top;\n}", "target": 0}
{"code": "decode_definite_bytestring(CBORDecoderObject *self, Py_ssize_t length)\n{\n    PyObject *ret = NULL;\n    ret = PyBytes_FromStringAndSize(NULL, length);\n    if (!ret)\n        return NULL;\n    if (fp_read(self, PyBytes_AS_STRING(ret), length) == -1) {\n        Py_DECREF(ret);\n        return NULL;\n    }\n    if (string_namespace_add(self, ret, length) == -1) {\n        Py_DECREF(ret);\n        return NULL;\n    }\n    return ret;\n}", "target": 1}
{"code": "inline void aligned_free(void* ptr) {\n  folly::detail::aligned_free(ptr);\n}", "target": 1}
{"code": "validate_serials(struct deltas_head *deltas, ...)\n{\n\tunsigned long serial;\n\tunsigned int i;\n\tva_list vl;\n\tva_start(vl, deltas);\n\ti = 0;\n\twhile ((serial = va_arg(vl, unsigned long)) != END) {\n\t\tck_assert_uint_eq(serial, deltas->array[i].serial);\n\t\ti++;\n\t}\n\tva_end(vl);\n}", "target": 0}
{"code": "static void php_mcrypt_module_dtor(zend_rsrc_list_entry *rsrc TSRMLS_DC) \n{\n\tphp_mcrypt *pm = (php_mcrypt *) rsrc->ptr;\n\tif (pm) {\t\n\t\tmcrypt_generic_deinit(pm->td);\n\t\tmcrypt_module_close(pm->td);\n\t\tefree(pm);\n\t\tpm = NULL;\n\t}", "target": 1}
{"code": "bool ContentSettingsObserver::AllowScript(bool enabled_per_settings) {\n  if (!enabled_per_settings)\n    return false;\n  if (IsScriptDisabledForPreview(render_frame()))\n    return false;\n  if (is_interstitial_page_)\n    return true;\n  blink::WebLocalFrame* frame = render_frame()->GetWebFrame();\n  const auto it = cached_script_permissions_.find(frame);\n  if (it != cached_script_permissions_.end())\n    return it->second;\n  bool allow = true;\n  if (content_setting_rules_) {\n    ContentSetting setting = GetContentSettingFromRules(\n        content_setting_rules_->script_rules, frame,\n        url::Origin(frame->GetDocument().GetSecurityOrigin()).GetURL());\n    allow = setting != CONTENT_SETTING_BLOCK;\n  }\n  allow = allow || IsWhitelistedForContentSettings();\n  cached_script_permissions_[frame] = allow;\n  return allow;\n}", "target": 1}
{"code": "test_appheader (xd3_stream *stream, int ignore)\n{\n  int i;\n  int ret;\n  char buf[TESTBUFSIZE];\n  char bogus[TESTBUFSIZE];\n  xoff_t ssize, tsize;\n  test_setup ();\n  if ((ret = test_make_inputs (stream, &ssize, &tsize))) { return ret; }\n  snprintf_func (buf, TESTBUFSIZE, \"%s -q -f -e -s %s %s %s\", program_name,\n\t\t TEST_SOURCE_FILE, TEST_TARGET_FILE, TEST_DELTA_FILE);\n  if ((ret = do_cmd (stream, buf))) { return ret; }\n  if ((ret = test_copy_to (program_name, TEST_RECON2_FILE))) { return ret; }\n  snprintf_func (buf, TESTBUFSIZE, \"chmod 0700 %s\", TEST_RECON2_FILE);\n  if ((ret = do_cmd (stream, buf))) { return ret; }\n  if ((ret = test_save_copy (TEST_TARGET_FILE))) { return ret; }\n  if ((ret = test_copy_to (TEST_SOURCE_FILE, TEST_TARGET_FILE))) { return ret; }\n  if ((ret = test_compare_files (TEST_TARGET_FILE, TEST_COPY_FILE)) == 0)\n    {\n      return XD3_INVALID;  \n    }\n  snprintf_func (buf, TESTBUFSIZE, \"(cd /tmp && %s -q -f -d %s)\",\n\t\t TEST_RECON2_FILE,\n\t\t TEST_DELTA_FILE);\n  if ((ret = do_cmd (stream, buf))) { return ret; }\n  if ((ret = test_compare_files (TEST_TARGET_FILE, TEST_COPY_FILE)) != 0)\n    {\n      return ret;\n    }\n  for (i = 0; i < TESTBUFSIZE / 4; ++i)\n    {\n      bogus[2*i] = 'G';\n      bogus[2*i+1] = '/';\n    }\n  bogus[TESTBUFSIZE/2-1] = 0;\n  snprintf_func (buf, TESTBUFSIZE, \n\t\t \"%s -q -f -A=%s -e -s %s %s %s\", program_name, bogus,\n\t\t TEST_SOURCE_FILE, TEST_TARGET_FILE, TEST_DELTA_FILE);\n  if ((ret = do_cmd (stream, buf))) { return ret; }\n  snprintf_func (buf, TESTBUFSIZE, \"(cd /tmp && %s -q -f -d %s)\",\n\t\t TEST_RECON2_FILE,\n\t\t TEST_DELTA_FILE);\n  if ((ret = do_cmd (stream, buf)) == 0) \n    { \n      return XD3_INVALID;  \n    }\n  if (!WIFEXITED(ret))\n    {\n      return XD3_INVALID;  \n    }\n  return 0;\n}", "target": 0}
{"code": "static int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int backlog) {\n    if (bind(s,sa,len) == -1) {\n        anetSetError(err, \"bind: %s\", strerror(errno));\n        close(s);\n        return ANET_ERR;\n    }\n    if (listen(s, backlog) == -1) {\n        anetSetError(err, \"listen: %s\", strerror(errno));\n        close(s);\n        return ANET_ERR;\n    }\n    return ANET_OK;\n}", "target": 1}
{"code": "bool SimpleMessenger::verify_authorizer(Connection *con, int peer_type,\n\t\t\t\t\tint protocol, bufferlist& authorizer, bufferlist& authorizer_reply,\n\t\t\t\t\tbool& isvalid,CryptoKey& session_key)\n{\n  return ms_deliver_verify_authorizer(con, peer_type, protocol, authorizer, authorizer_reply, isvalid,session_key);\n}", "target": 1}
{"code": "flatpak_bwrap_envp_to_args (FlatpakBwrap *bwrap)\n{\n  gsize i;\n  for (i = 0; bwrap->envp[i] != NULL; i++)\n    {\n      char *key_val = bwrap->envp[i];\n      char *eq = strchr (key_val, '=');\n      if (eq)\n        {\n          flatpak_bwrap_add_arg (bwrap, \"--setenv\");\n          flatpak_bwrap_take_arg (bwrap, g_strndup (key_val, eq - key_val));\n          flatpak_bwrap_add_arg (bwrap, eq + 1);\n        }\n      else\n        {\n          g_warn_if_reached ();\n        }\n    }\n  g_strfreev (g_steal_pointer (&bwrap->envp));\n  bwrap->envp = g_strdupv (flatpak_bwrap_empty_env);\n}", "target": 0}
{"code": "unicode_log2vis (PyUnicodeObject* string,\n                 FriBidiParType base_direction, int clean, int reordernsm)\n{\n    int i;\n    int length = string->length;\n    FriBidiChar *logical = NULL; \n    FriBidiChar *visual = NULL;      \n    FriBidiStrIndex new_len = 0; \n    PyUnicodeObject *result = NULL;\n    logical = PyMem_New (FriBidiChar, length + 1);\n    if (logical == NULL) {\n        PyErr_NoMemory();\n        goto cleanup;\n    }\n    visual = PyMem_New (FriBidiChar, length + 1);\n    if (visual == NULL) {\n        PyErr_NoMemory();\n        goto cleanup;\n    }\n    for (i=0; i<length; ++i) {\n        logical[i] = string->str[i];\n    }\n    fribidi_set_reorder_nsm(reordernsm);\n    if (!fribidi_log2vis (logical, length, &base_direction, visual,\n                          NULL, NULL, NULL)) {\n        PyErr_SetString (PyExc_RuntimeError,\n                         \"fribidi failed to order string\");\n        goto cleanup;\n    }\n    if (clean) {\n        length = fribidi_remove_bidi_marks (visual, length, NULL, NULL, NULL);\n    }\n    result = (PyUnicodeObject*) PyUnicode_FromUnicode(NULL, length);\n    if (result == NULL) {\n        goto cleanup;\n    }\n    for (i=0; i<length; ++i) {\n        result->str[i] = visual[i];\n    }\n  cleanup:\n    PyMem_Del (logical);\n    PyMem_Del (visual);\n    return (PyObject *)result;\n}", "target": 0}
{"code": "bool ConstantFolding::IsSimplifiableReshape(\n    const NodeDef& node, const GraphProperties& properties) const {\n  if (!IsReshape(node)) {\n    return false;\n  }\n  CHECK_LE(2, node.input_size());\n  const NodeDef* new_shape = node_map_->GetNode(node.input(1));\n  if (!IsReallyConstant(*new_shape)) {\n    return false;\n  }\n  TensorVector outputs;\n  auto outputs_cleanup = gtl::MakeCleanup([&outputs] {\n    for (const auto& output : outputs) {\n      delete output.tensor;\n    }\n  });\n  Status s = EvaluateNode(*new_shape, TensorVector(), &outputs);\n  if (!s.ok()) {\n    return false;\n  }\n  CHECK_EQ(1, outputs.size());\n  const std::vector<OpInfo::TensorProperties>& props =\n      properties.GetInputProperties(node.name());\n  if (props.empty()) {\n    return false;\n  }\n  const OpInfo::TensorProperties& prop = props[0];\n  if (prop.dtype() == DT_INVALID) {\n    return false;\n  }\n  const PartialTensorShape shape(prop.shape());\n  if (!shape.IsFullyDefined()) {\n    return false;\n  }\n  PartialTensorShape new_dims;\n  if (outputs[0]->dtype() == DT_INT32) {\n    std::vector<int32> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int32_t dim = outputs[0]->flat<int32>()(i);\n      shp.push_back(dim);\n    }\n    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims));\n  } else {\n    std::vector<int64_t> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int64_t dim = outputs[0]->flat<int64_t>()(i);\n      shp.push_back(dim);\n    }\n    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims));\n  }\n  return shape.IsCompatibleWith(new_dims);\n}", "target": 1}
{"code": "static void vgacon_scrollback_startup(void)\n{\n\tvgacon_scrollback_cur = &vgacon_scrollbacks[0];\n\tvgacon_scrollback_init(0);\n}", "target": 1}
{"code": "int CLASS ljpeg_diff (ushort *huff)\n{\n  int len, diff;\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!huff)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  len = gethuff(huff);\n  if (len == 16 && (!dng_version || dng_version >= 0x1010000))\n    return -32768;\n  diff = getbits(len);\n  if ((diff & (1 << (len-1))) == 0)\n    diff -= (1 << len) - 1;\n  return diff;\n}", "target": 0}
{"code": "static inline bool unconditional(const struct arpt_arp *arp)\n{\n\tstatic const struct arpt_arp uncond;\n\treturn memcmp(arp, &uncond, sizeof(uncond)) == 0;\n}", "target": 1}
{"code": "static ssize_t mem_write(struct file * file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tint copied;\n\tchar *page;\n\tstruct task_struct *task = get_proc_task(file->f_path.dentry->d_inode);\n\tunsigned long dst = *ppos;\n\tcopied = -ESRCH;\n\tif (!task)\n\t\tgoto out_no_task;\n\tif (!MAY_PTRACE(task) || !ptrace_may_attach(task))\n\t\tgoto out;\n\tcopied = -ENOMEM;\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\tgoto out;\n\tcopied = 0;\n\twhile (count > 0) {\n\t\tint this_len, retval;\n\t\tthis_len = (count > PAGE_SIZE) ? PAGE_SIZE : count;\n\t\tif (copy_from_user(page, buf, this_len)) {\n\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tretval = access_process_vm(task, dst, page, this_len, 1);\n\t\tif (!retval) {\n\t\t\tif (!copied)\n\t\t\t\tcopied = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tcopied += retval;\n\t\tbuf += retval;\n\t\tdst += retval;\n\t\tcount -= retval;\t\t\t\n\t}\n\t*ppos = dst;\n\tfree_page((unsigned long) page);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn copied;\n}", "target": 0}
{"code": "file_add_mapi_attrs (File* file, MAPI_Attr** attrs)\n{\n    int i;\n    for (i = 0; attrs[i]; i++)\n    {\n\tMAPI_Attr* a = attrs[i];\n\tif (a->num_values)\n\t{\n\t    switch (a->name)\n\t    {\n\t    case MAPI_ATTACH_LONG_FILENAME:\n\t\tassert(a->type == szMAPI_STRING);\n\t\tif (file->name) XFREE(file->name);\n\t\tfile->name = strdup( (char*)a->values[0].data.buf );\n\t\tbreak;\n\t    case MAPI_ATTACH_DATA_OBJ:\n\t\tassert((a->type == szMAPI_BINARY) || (a->type == szMAPI_OBJECT));\n\t\tfile->len = a->values[0].len;\n\t\tif (file->data) XFREE (file->data);\n\t\tfile->data = CHECKED_XMALLOC (unsigned char, file->len);\n\t\tmemmove (file->data, a->values[0].data.buf, file->len);\n\t\tbreak;\n             case MAPI_ATTACH_MIME_TAG:\n\t\tassert(a->type == szMAPI_STRING);\n\t\tif (file->mime_type) XFREE (file->mime_type);\n\t\tfile->mime_type = CHECKED_XMALLOC (char, a->values[0].len);\n\t\tmemmove (file->mime_type, a->values[0].data.buf, a->values[0].len);\n\t\tbreak;\n                case MAPI_ATTACH_CONTENT_ID:\n                    assert(a->type == szMAPI_STRING);\n                    if (file->content_id) XFREE(file->content_id);\n                    file->content_id = CHECKED_XMALLOC (char, a->values[0].len);\n                    memmove (file->content_id, a->values[0].data.buf, a->values[0].len);\n                    break;\n\t    default:\n\t\tbreak;\n\t    }\n\t}\n    }\n}", "target": 0}
{"code": "doIgnoreSection(XML_Parser parser, const ENCODING *enc, const char **startPtr,\n                const char *end, const char **nextPtr, XML_Bool haveMore) {\n  const char *next = *startPtr; \n  int tok;\n  const char *s = *startPtr;\n  const char **eventPP;\n  const char **eventEndPP;\n  if (enc == parser->m_encoding) {\n    eventPP = &parser->m_eventPtr;\n    *eventPP = s;\n    eventEndPP = &parser->m_eventEndPtr;\n  } else {\n    eventPP = &(parser->m_openInternalEntities->internalEventPtr);\n    eventEndPP = &(parser->m_openInternalEntities->internalEventEndPtr);\n  }\n  *eventPP = s;\n  *startPtr = NULL;\n  tok = XmlIgnoreSectionTok(enc, s, end, &next);\n#  ifdef XML_DTD\n  if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                XML_ACCOUNT_DIRECT)) {\n    accountingOnAbort(parser);\n    return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n  }\n#  endif\n  *eventEndPP = next;\n  switch (tok) {\n  case XML_TOK_IGNORE_SECT:\n    if (parser->m_defaultHandler)\n      reportDefault(parser, enc, s, next);\n    *startPtr = next;\n    *nextPtr = next;\n    if (parser->m_parsingStatus.parsing == XML_FINISHED)\n      return XML_ERROR_ABORTED;\n    else\n      return XML_ERROR_NONE;\n  case XML_TOK_INVALID:\n    *eventPP = next;\n    return XML_ERROR_INVALID_TOKEN;\n  case XML_TOK_PARTIAL_CHAR:\n    if (haveMore) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    return XML_ERROR_PARTIAL_CHAR;\n  case XML_TOK_PARTIAL:\n  case XML_TOK_NONE:\n    if (haveMore) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    return XML_ERROR_SYNTAX; \n  default:\n    *eventPP = next;\n    return XML_ERROR_UNEXPECTED_STATE;\n  }\n}", "target": 1}
{"code": "static int muscle_delete_file(sc_card_t *card, const sc_path_t *path_in)\n{\n\tmscfs_t *fs = MUSCLE_FS(card);\n\tmscfs_file_t *file_data = NULL;\n\tint r = 0;\n\tr = mscfs_loadFileInfo(fs, path_in->value, path_in->len, &file_data, NULL);\n\tif(r < 0) SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,r);\n\tr = muscle_delete_mscfs_file(card, file_data);\n\tmscfs_clear_cache(fs);\n\tif(r < 0) SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,r);\n\treturn 0;\n}", "target": 0}
{"code": "archive_reopen_if_needed (ComicsDocument  *comics_document,\n\t\t\t  const char      *page_wanted,\n\t\t\t  GError         **error)\n{\n\tconst char *current_page;\n\tguint current_page_idx, page_wanted_idx;\n\tif (ev_archive_at_entry (comics_document->archive)) {\n\t\tcurrent_page = ev_archive_get_entry_pathname (comics_document->archive);\n\t\tif (current_page) {\n\t\t\tcurrent_page_idx = GPOINTER_TO_UINT (g_hash_table_lookup (comics_document->page_positions, current_page));\n\t\t\tpage_wanted_idx = GPOINTER_TO_UINT (g_hash_table_lookup (comics_document->page_positions, page_wanted));\n\t\t\tif (current_page_idx != 0 &&\n\t\t\t    page_wanted_idx != 0 &&\n\t\t\t    page_wanted_idx > current_page_idx)\n\t\t\t\treturn TRUE;\n\t\t}\n\t\tev_archive_reset (comics_document->archive);\n\t}\nreturn ev_archive_open_filename (comics_document->archive, comics_document->archive_path, error);\n}", "target": 0}
{"code": "static void do_free_upto(BIO *f, BIO *upto)\n\t{\n\tif (upto)\n\t\t{\n\t\tBIO *tbio;\n\t\tdo \n\t\t\t{\n\t\t\ttbio = BIO_pop(f);\n\t\t\tBIO_free(f);\n\t\t\tf = tbio;\n\t\t\t}\n\t\twhile (f != upto);\n\t\t}\n\telse\n\t\tBIO_free_all(f);\n\t}", "target": 1}
{"code": "real_need_secrets (NMVpnServicePlugin *plugin,\n                   NMConnection *connection,\n                   const char **out_setting_name,\n                   GError **error)\n{\n\tNMSettingVpn *s_vpn;\n\tNMSettingSecretFlags pw_flags;\n\tconst char *pw = NULL;\n\tg_return_val_if_fail (NM_IS_VPN_SERVICE_PLUGIN (plugin), FALSE);\n\tg_return_val_if_fail (NM_IS_CONNECTION (connection), FALSE);\n\ts_vpn = nm_connection_get_setting_vpn (connection);\n\tif (!s_vpn) {\n\t\tg_set_error (error,\n\t\t             NM_VPN_PLUGIN_ERROR,\n\t\t             NM_VPN_PLUGIN_ERROR_INVALID_CONNECTION,\n\t\t             \"%s\",\n\t\t             _(\"Could not process the request because the VPN connection settings were invalid.\"));\n\t\treturn FALSE;\n\t}\n\tpw = nm_setting_vpn_get_secret (s_vpn, NM_VPNC_KEY_SECRET);\n\tpw_flags = get_pw_flags (s_vpn, NM_VPNC_KEY_SECRET, NM_VPNC_KEY_SECRET_TYPE);\n\tif (!pw && !(pw_flags & NM_SETTING_SECRET_FLAG_NOT_REQUIRED)) {\n\t\t*out_setting_name = NM_SETTING_VPN_SETTING_NAME;\n\t\treturn TRUE;\n\t}\n\tpw = nm_setting_vpn_get_secret (s_vpn, NM_VPNC_KEY_XAUTH_PASSWORD);\n\tpw_flags = get_pw_flags (s_vpn, NM_VPNC_KEY_XAUTH_PASSWORD, NM_VPNC_KEY_XAUTH_PASSWORD_TYPE);\n\tif (!pw && !(pw_flags & NM_SETTING_SECRET_FLAG_NOT_REQUIRED)) {\n\t\t*out_setting_name = NM_SETTING_VPN_SETTING_NAME;\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}", "target": 0}
{"code": "SIZED_STRING* sized_string_dup(\n    SIZED_STRING* s)\n{\n  SIZED_STRING* result = (SIZED_STRING*) yr_malloc(\n      sizeof(SIZED_STRING) + s->length);\n  if (result == NULL)\n    return NULL;\n  result->length = s->length;\n  result->flags = s->flags;\n  strncpy(result->c_string, s->c_string, s->length + 1);\n  return result;\n}", "target": 0}
{"code": "void RestAuthHandler::shutdownExecute(bool isFinalized) noexcept {\n  try {\n    if (_isValid) {\n      events::LoggedIn(*_request, _username);\n    } else {\n      events::CredentialsBad(*_request, _username);\n    }\n  } catch (...) {\n  }\n  RestVocbaseBaseHandler::shutdownExecute(isFinalized);\n}", "target": 1}
{"code": "int ceph_crypt(const struct ceph_crypto_key *key, bool encrypt,\n\t       void *buf, int buf_len, int in_len, int *pout_len)\n{\n\tswitch (key->type) {\n\tcase CEPH_CRYPTO_NONE:\n\t\t*pout_len = in_len;\n\t\treturn 0;\n\tcase CEPH_CRYPTO_AES:\n\t\treturn ceph_aes_crypt(key, encrypt, buf, buf_len, in_len,\n\t\t\t\t      pout_len);\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n}", "target": 0}
{"code": "TfLiteStatus EvalScatterNd(TfLiteContext* context, const TfLiteTensor* indices,\n                           const TfLiteTensor* updates,\n                           const TfLiteTensor* shape, TfLiteTensor* output) {\n  if (IsDynamicTensor(output)) {\n    TF_LITE_ENSURE_OK(\n        context, CheckShapes<IndicesT>(\n                     context, GetTensorShape(indices), GetTensorShape(updates),\n                     GetTensorShape(shape), GetTensorData<IndicesT>(shape)));\n    TF_LITE_ENSURE_OK(context,\n                      ResizeOutputTensor<IndicesT>(context, shape, output));\n  }\n  switch (updates->type) {\n    case kTfLiteFloat32:\n      return ScatterNd<IndicesT, float>(indices, updates, output);\n    case kTfLiteUInt8:\n      return ScatterNd<IndicesT, uint8_t>(indices, updates, output);\n    case kTfLiteBool:\n      return ScatterNd<IndicesT, bool>(indices, updates, output);\n    case kTfLiteInt8:\n      return ScatterNd<IndicesT, int8_t>(indices, updates, output);\n    case kTfLiteInt32:\n      return ScatterNd<IndicesT, int32_t>(indices, updates, output);\n    case kTfLiteInt64:\n      return ScatterNd<IndicesT, int64_t>(indices, updates, output);\n    default:\n      TF_LITE_KERNEL_LOG(\n          context, \"Updates of type '%s' are not supported by scatter_nd.\",\n          TfLiteTypeGetName(updates->type));\n      return kTfLiteError;\n  }\n}", "target": 1}
{"code": "learn_min_len(uint16_t header)\n{\n    int n_bits = header & NX_LEARN_N_BITS_MASK;\n    int src_type = header & NX_LEARN_SRC_MASK;\n    int dst_type = header & NX_LEARN_DST_MASK;\n    unsigned int min_len;\n    min_len = 0;\n    if (src_type == NX_LEARN_SRC_FIELD) {\n        min_len += sizeof(ovs_be32); \n        min_len += sizeof(ovs_be16); \n    } else {\n        min_len += 2 * DIV_ROUND_UP(n_bits, 16);\n    }\n    if (dst_type == NX_LEARN_DST_MATCH ||\n        dst_type == NX_LEARN_DST_LOAD) {\n        min_len += sizeof(ovs_be32); \n        min_len += sizeof(ovs_be16); \n    }\n    return min_len;\n}", "target": 0}
{"code": "static UINT urb_bulk_or_interrupt_transfer(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback,\n                                           wStream* s, UINT32 RequestField, UINT32 MessageId,\n                                           IUDEVMAN* udevman, int transferDir)\n{\n\tUINT32 EndpointAddress, PipeHandle;\n\tUINT32 TransferFlags, OutputBufferSize;\n\tconst BOOL noAck = (RequestField & 0x80000000U) != 0;\n\tconst UINT32 RequestId = RequestField & 0x7FFFFFFF;\n\tif (!pdev || !callback || !s || !udevman)\n\t\treturn ERROR_INVALID_PARAMETER;\n\tif (Stream_GetRemainingLength(s) < 12)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT32(s, PipeHandle);\n\tStream_Read_UINT32(s, TransferFlags); \n\tStream_Read_UINT32(s, OutputBufferSize);\n\tEndpointAddress = (PipeHandle & 0x000000ff);\n\tif (transferDir == USBD_TRANSFER_DIRECTION_OUT)\n\t{\n\t\tif (!Stream_CheckAndLogRequiredLength(TAG, s, OutputBufferSize))\n\t\t{\n\t\t\treturn ERROR_INVALID_DATA;\n\t\t}\n\t}\n\treturn pdev->bulk_or_interrupt_transfer(\n\t    pdev, callback, MessageId, RequestId, EndpointAddress, TransferFlags, noAck,\n\t    OutputBufferSize, (transferDir == USBD_TRANSFER_DIRECTION_OUT) ? Stream_Pointer(s) : NULL,\n\t    urb_bulk_transfer_cb, 10000);\n}", "target": 0}
{"code": "int is_valid_msg_type(const char *msg_id, const char *msg_type)\n{\n\tif (parse_msg_id(msg_id) < 0)\n\t\treturn 0;\n\tparse_msg_type(msg_type);\n\treturn 1;\n}", "target": 0}
{"code": "static inline void ext4_truncate_failed_write(struct inode *inode)\n{\n\tdown_write(&EXT4_I(inode)->i_mmap_sem);\n\ttruncate_inode_pages(inode->i_mapping, inode->i_size);\n\text4_truncate(inode);\n\tup_write(&EXT4_I(inode)->i_mmap_sem);\n}", "target": 0}
{"code": "bool f_libxml_disable_entity_loader(bool disable ) {\n  xmlParserInputBufferCreateFilenameFunc old;\n  if (disable) {\n    old = xmlParserInputBufferCreateFilenameDefault(hphp_libxml_input_buffer_noload);\n  } else {\n    old = xmlParserInputBufferCreateFilenameDefault(nullptr);\n  }\n  return (old == hphp_libxml_input_buffer_noload);\n}", "target": 1}
{"code": "void StelScriptOutput::saveOutputAs(const QString &name)\n{\n\tQFile asFile;\n\tQFileInfo outputInfo(outputFile);\n\tQDir dir=outputInfo.dir(); \n\tQFileInfo newFileNameInfo(name);\n\tbool okToSaveToAbsolutePath=StelApp::getInstance().getSettings()->value(\"scripts/flag_script_allow_write_absolute_path\", false).toBool();\n\tif (!okToSaveToAbsolutePath && (newFileNameInfo.isAbsolute()))\n\t{\n\t\tqWarning() << \"SCRIPTING CONFIGURATION ISSUE: You are trying to save to an absolute pathname.\";\n\t\tqWarning() << \"  To enable this, edit config.ini and set [scripts]/flag_script_allow_write_absolute_path=true\";\n\t\tasFile.setFileName(dir.absolutePath() + \"/\" + newFileNameInfo.fileName());\n\t\tqWarning() << \"  Storing to \" << asFile.fileName() << \" instead\";\n\t}\n\telse if (okToSaveToAbsolutePath && (newFileNameInfo.isAbsolute()))\n\t{\n\t\tasFile.setFileName(name);\n\t}\n\telse\n\t{\n\t\tasFile.setFileName(dir.absolutePath() + \"/\" + name);\n\t}\n\tif (!asFile.open(QIODevice::WriteOnly | QIODevice::Truncate | QIODevice::Text | QIODevice::Unbuffered))\n\t{\n\t\tqDebug() << \"ERROR: Cannot open file\" << asFile.fileName();\n\t\treturn;\n\t}\n\tqDebug() << \"saving copy of output.txt to \" << asFile.fileName();\n\tasFile.write(qPrintable(outputText), outputText.size());\n\tasFile.close();\n}", "target": 1}
{"code": "daemon_linux_lvm2_vg_add_pv (Daemon *daemon,\n                             const gchar *uuid,\n                             const gchar *object_path,\n                             gchar **options,\n                             DBusGMethodInvocation *context)\n{\n  daemon_local_check_auth (daemon,\n                           NULL,\n                           \"org.freedesktop.udisks.linux-lvm2\",\n                           \"LinuxLvm2VGAddPV\",\n                           TRUE,\n                           daemon_linux_lvm2_vg_add_pv_authorized_cb,\n                           context,\n                           3,\n                           g_strdup (uuid),\n                           g_free,\n                           g_strdup (object_path),\n                           g_free,\n                           g_strdupv (options),\n                           g_strfreev);\n  return TRUE;\n}", "target": 0}
{"code": "  Status check_index_ordering(const Tensor& indices) {\n    auto findices = indices.flat<int>();\n    for (std::size_t i = 0; i < findices.dimension(0) - 1; ++i) {\n      if (findices(i) < findices(i + 1)) {\n        continue;\n      }\n      return Status(\n          errors::InvalidArgument(\"Indices are not strictly ordered\"));\n    }\n    return Status::OK();\n  }", "target": 1}
{"code": "static void fio_cluster_listen_on_close(intptr_t uuid,\n                                        fio_protocol_s *protocol) {\n  free(protocol);\n  cluster_data.uuid = -1;\n  if (fio_parent_pid() == getpid()) {\n#if DEBUG\n    FIO_LOG_DEBUG(\"(%d) stopped listening for cluster connections\",\n                  (int)getpid());\n#endif\n    if (fio_data->active)\n      fio_stop();\n  }\n  (void)uuid;\n}", "target": 1}
{"code": "find_method_in_class (MonoClass *klass, const char *name, const char *qname, const char *fqname,\n\t\t      MonoMethodSignature *sig, MonoClass *from_class)\n{\n \tint i;\n\tif (klass->type_token && !klass->image->dynamic && !klass->methods && !klass->rank && klass == from_class && !from_class->generic_class) {\n\t\tfor (i = 0; i < klass->method.count; ++i) {\n\t\t\tguint32 cols [MONO_METHOD_SIZE];\n\t\t\tMonoMethod *method;\n\t\t\tconst char *m_name;\n\t\t\tMonoMethodSignature *other_sig;\n\t\t\tmono_metadata_decode_table_row (klass->image, MONO_TABLE_METHOD, klass->method.first + i, cols, MONO_METHOD_SIZE);\n\t\t\tm_name = mono_metadata_string_heap (klass->image, cols [MONO_METHOD_NAME]);\n\t\t\tif (!((fqname && !strcmp (m_name, fqname)) ||\n\t\t\t\t  (qname && !strcmp (m_name, qname)) ||\n\t\t\t\t  (name && !strcmp (m_name, name))))\n\t\t\t\tcontinue;\n\t\t\tmethod = mono_get_method (klass->image, MONO_TOKEN_METHOD_DEF | (klass->method.first + i + 1), klass);\n\t\t\tother_sig = mono_method_signature (method);\n\t\t\tif (method && other_sig && (sig->call_convention != MONO_CALL_VARARG) && mono_metadata_signature_equal (sig, other_sig))\n\t\t\t\treturn method;\n\t\t}\n\t}\n\tmono_class_setup_methods (klass);\n\tif (!klass->methods)\n\t\treturn NULL;\n\tfor (i = 0; i < klass->method.count; ++i) {\n\t\tMonoMethod *m = klass->methods [i];\n\t\tMonoMethodSignature *msig;\n\t\tif (!((fqname && !strcmp (m->name, fqname)) ||\n\t\t      (qname && !strcmp (m->name, qname)) ||\n\t\t      (name && !strcmp (m->name, name))))\n\t\t\tcontinue;\n\t\tmsig = mono_method_signature (m);\n\t\tif (!msig)\n\t\t\tcontinue;\n\t\tif (sig->call_convention == MONO_CALL_VARARG) {\n\t\t\tif (mono_metadata_signature_vararg_match (sig, msig))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (mono_metadata_signature_equal (sig, msig))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (i < klass->method.count)\n\t\treturn mono_class_get_method_by_index (from_class, i);\n\treturn NULL;\n}", "target": 0}
{"code": "pci_lintr_assert(struct pci_vdev *dev)\n{\n\tassert(dev->lintr.pin > 0);\n\tpthread_mutex_lock(&dev->lintr.lock);\n\tif (dev->lintr.state == IDLE) {\n\t\tif (pci_lintr_permitted(dev)) {\n\t\t\tdev->lintr.state = ASSERTED;\n\t\t\tpci_irq_assert(dev);\n\t\t} else\n\t\t\tdev->lintr.state = PENDING;\n\t}\n\tpthread_mutex_unlock(&dev->lintr.lock);\n}", "target": 1}
{"code": "static struct nfs4_opendata *nfs4_open_recoverdata_alloc(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs4_opendata *opendata;\n\topendata = nfs4_opendata_alloc(&ctx->path, state->owner, 0, NULL);\n\tif (opendata == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\topendata->state = state;\n\tatomic_inc(&state->count);\n\treturn opendata;\n}", "target": 1}
{"code": "static inline ut32 r_read_le32(const void *src) {\n\tif (!src) {\n\t\treturn UT32_MAX;\n\t}\n\tconst ut8 *s = (const ut8*)src;\n\treturn (((ut32)s[3]) << 24) | (((ut32)s[2]) << 16) |\n\t\t(((ut32)s[1]) << 8) | (((ut32)s[0]) << 0);\n}", "target": 0}
{"code": "int kvm_deassign_device(struct kvm *kvm,\n\t\t\tstruct kvm_assigned_dev_kernel *assigned_dev)\n{\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\tstruct pci_dev *pdev = NULL;\n\tif (!domain)\n\t\treturn 0;\n\tpdev = assigned_dev->dev;\n\tif (pdev == NULL)\n\t\treturn -ENODEV;\n\tiommu_detach_device(domain, &pdev->dev);\n\tpci_clear_dev_assigned(pdev);\n\tdev_info(&pdev->dev, \"kvm deassign device\\n\");\n\treturn 0;\n}", "target": 0}
{"code": "comics_document_save (EvDocument *document,\n\t\t      const char *uri,\n\t\t      GError    **error)\n{\n\tComicsDocument *comics_document = COMICS_DOCUMENT (document);\n\treturn ev_xfer_uri_simple (comics_document->archive, uri, error);\n}", "target": 1}
{"code": "static void copy_password_acl_validation_control(\n\tstruct ldb_request *req,\n\tstruct ldb_reply *ares)\n{\n\tstruct ldb_control *pav_ctrl = NULL;\n\tstruct dsdb_control_password_acl_validation *pav = NULL;\n\tpav_ctrl = ldb_request_get_control(\n\t\tdiscard_const(req),\n\t\tDSDB_CONTROL_PASSWORD_ACL_VALIDATION_OID);\n\tif (pav_ctrl == NULL) {\n\t\treturn;\n\t}\n\tpav = talloc_get_type_abort(\n\t\tpav_ctrl->data,\n\t\tstruct dsdb_control_password_acl_validation);\n\tif (pav == NULL) {\n\t\treturn;\n\t}\n\tldb_reply_add_control(\n\t\tares,\n\t\tDSDB_CONTROL_PASSWORD_ACL_VALIDATION_OID,\n\t\tfalse,\n\t\tpav);\n}", "target": 0}
{"code": "deltas_head_init(struct deltas_head *list)\n{\n\tlist->array = NULL;\n\tlist->len = 0;\n\tlist->capacity = 0;\n}", "target": 1}
{"code": "static int treo_attach(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *swap_port;\n\tif (!((le16_to_cpu(serial->dev->descriptor.idVendor)\n\t\t\t\t\t\t== HANDSPRING_VENDOR_ID) ||\n\t\t(le16_to_cpu(serial->dev->descriptor.idVendor)\n\t\t\t\t\t\t== KYOCERA_VENDOR_ID)) ||\n\t\t(serial->num_interrupt_in == 0))\n\t\treturn 0;\n\tif (serial->num_bulk_in < 2 || serial->num_interrupt_in < 2) {\n\t\tdev_err(&serial->interface->dev, \"missing endpoints\\n\");\n\t\treturn -ENODEV;\n\t}\n#define COPY_PORT(dest, src)\t\t\t\t\t\t\\\n\tdo { \\\n\t\tint i;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tfor (i = 0; i < ARRAY_SIZE(src->read_urbs); ++i) {\t\\\n\t\t\tdest->read_urbs[i] = src->read_urbs[i];\t\t\\\n\t\t\tdest->read_urbs[i]->context = dest;\t\t\\\n\t\t\tdest->bulk_in_buffers[i] = src->bulk_in_buffers[i]; \\\n\t\t}\t\t\t\t\t\t\t\\\n\t\tdest->read_urb = src->read_urb;\t\t\t\t\\\n\t\tdest->bulk_in_endpointAddress = src->bulk_in_endpointAddress;\\\n\t\tdest->bulk_in_buffer = src->bulk_in_buffer;\t\t\\\n\t\tdest->bulk_in_size = src->bulk_in_size;\t\t\t\\\n\t\tdest->interrupt_in_urb = src->interrupt_in_urb;\t\t\\\n\t\tdest->interrupt_in_urb->context = dest;\t\t\t\\\n\t\tdest->interrupt_in_endpointAddress = \\\n\t\t\t\t\tsrc->interrupt_in_endpointAddress;\\\n\t\tdest->interrupt_in_buffer = src->interrupt_in_buffer;\t\\\n\t} while (0);\n\tswap_port = kmalloc(sizeof(*swap_port), GFP_KERNEL);\n\tif (!swap_port)\n\t\treturn -ENOMEM;\n\tCOPY_PORT(swap_port, serial->port[0]);\n\tCOPY_PORT(serial->port[0], serial->port[1]);\n\tCOPY_PORT(serial->port[1], swap_port);\n\tkfree(swap_port);\n\treturn 0;\n}", "target": 0}
{"code": "int vcc_getsockopt(struct socket *sock, int level, int optname,\n\t\t   char __user *optval, int __user *optlen)\n{\n\tstruct atm_vcc *vcc;\n\tint len;\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (__SO_LEVEL_MATCH(optname, level) && len != __SO_SIZE(optname))\n\t\treturn -EINVAL;\n\tvcc = ATM_SD(sock);\n\tswitch (optname) {\n\tcase SO_ATMQOS:\n\t\tif (!test_bit(ATM_VF_HASQOS, &vcc->flags))\n\t\t\treturn -EINVAL;\n\t\treturn copy_to_user(optval, &vcc->qos, sizeof(vcc->qos))\n\t\t\t? -EFAULT : 0;\n\tcase SO_SETCLP:\n\t\treturn put_user(vcc->atm_options & ATM_ATMOPT_CLP ? 1 : 0,\n\t\t\t\t(unsigned long __user *)optval) ? -EFAULT : 0;\n\tcase SO_ATMPVC:\n\t{\n\t\tstruct sockaddr_atmpvc pvc;\n\t\tif (!vcc->dev || !test_bit(ATM_VF_ADDR, &vcc->flags))\n\t\t\treturn -ENOTCONN;\n\t\tmemset(&pvc, 0, sizeof(pvc));\n\t\tpvc.sap_family = AF_ATMPVC;\n\t\tpvc.sap_addr.itf = vcc->dev->number;\n\t\tpvc.sap_addr.vpi = vcc->vpi;\n\t\tpvc.sap_addr.vci = vcc->vci;\n\t\treturn copy_to_user(optval, &pvc, sizeof(pvc)) ? -EFAULT : 0;\n\t}\n\tdefault:\n\t\tif (level == SOL_SOCKET)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\tif (!vcc->dev || !vcc->dev->ops->getsockopt)\n\t\treturn -EINVAL;\n\treturn vcc->dev->ops->getsockopt(vcc, level, optname, optval, len);\n}", "target": 0}
{"code": "compute_U_value_R3(std::string const& user_password,\n\t\t   QPDF::EncryptionData const& data)\n{\n    std::string k1 = QPDF::compute_encryption_key(user_password, data);\n    MD5 md5;\n    md5.encodeDataIncrementally(\n\tpad_or_truncate_password_V4(\"\").c_str(), key_bytes);\n    md5.encodeDataIncrementally(data.getId1().c_str(),\n                                data.getId1().length());\n    MD5::Digest digest;\n    md5.digest(digest);\n    pad_short_parameter(k1, data.getLengthBytes());\n    iterate_rc4(digest, sizeof(MD5::Digest),\n\t\tQUtil::unsigned_char_pointer(k1),\n                data.getLengthBytes(), 20, false);\n    char result[key_bytes];\n    memcpy(result, digest, sizeof(MD5::Digest));\n    for (unsigned int i = sizeof(MD5::Digest); i < key_bytes; ++i)\n    {\n\tresult[i] = static_cast<char>((i * i) % 0xff);\n    }\n    return std::string(result, key_bytes);\n}", "target": 0}
{"code": "minimask_equal(const struct minimask *a, const struct minimask *b)\n{\n    return !memcmp(a, b, sizeof *a\n                   + MINIFLOW_VALUES_SIZE(miniflow_n_values(&a->masks)));\n}", "target": 1}
{"code": "static inline struct anon_vma *anon_vma_alloc(void)\n{\n\tstruct anon_vma *anon_vma;\n\tanon_vma = kmem_cache_alloc(anon_vma_cachep, GFP_KERNEL);\n\tif (anon_vma) {\n\t\tatomic_set(&anon_vma->refcount, 1);\n\t\tanon_vma->degree = 1;\t\n\t\tanon_vma->parent = anon_vma;\n\t\tanon_vma->root = anon_vma;\n\t}\n\treturn anon_vma;\n}", "target": 1}
{"code": "SYSCALL_DEFINE3(rt_sigqueueinfo, pid_t, pid, int, sig,\n\t\tsiginfo_t __user *, uinfo)\n{\n\tsiginfo_t info;\n\tif (copy_from_user(&info, uinfo, sizeof(siginfo_t)))\n\t\treturn -EFAULT;\n\tif (info.si_code >= 0)\n\t\treturn -EPERM;\n\tinfo.si_signo = sig;\n\treturn kill_proc_info(sig, &info, pid);\n}", "target": 1}
{"code": "int ossl_policy_cache_set_mapping(X509 *x, POLICY_MAPPINGS *maps)\n{\n    POLICY_MAPPING *map;\n    X509_POLICY_DATA *data;\n    X509_POLICY_CACHE *cache = x->policy_cache;\n    int i;\n    int ret = 0;\n    if (sk_POLICY_MAPPING_num(maps) == 0) {\n        ret = -1;\n        goto bad_mapping;\n    }\n    for (i = 0; i < sk_POLICY_MAPPING_num(maps); i++) {\n        map = sk_POLICY_MAPPING_value(maps, i);\n        if ((OBJ_obj2nid(map->subjectDomainPolicy) == NID_any_policy)\n            || (OBJ_obj2nid(map->issuerDomainPolicy) == NID_any_policy)) {\n            ret = -1;\n            goto bad_mapping;\n        }\n        data = ossl_policy_cache_find_data(cache, map->issuerDomainPolicy);\n        if (data == NULL && !cache->anyPolicy)\n            continue;\n        if (data == NULL) {\n            data = ossl_policy_data_new(NULL, map->issuerDomainPolicy,\n                                        cache->anyPolicy->flags\n                                        & POLICY_DATA_FLAG_CRITICAL);\n            if (data == NULL)\n                goto bad_mapping;\n            data->qualifier_set = cache->anyPolicy->qualifier_set;\n            data->flags |= POLICY_DATA_FLAG_MAPPED_ANY;\n            data->flags |= POLICY_DATA_FLAG_SHARED_QUALIFIERS;\n            if (!sk_X509_POLICY_DATA_push(cache->data, data)) {\n                ossl_policy_data_free(data);\n                goto bad_mapping;\n            }\n        } else\n            data->flags |= POLICY_DATA_FLAG_MAPPED;\n        if (!sk_ASN1_OBJECT_push(data->expected_policy_set,\n                                 map->subjectDomainPolicy))\n            goto bad_mapping;\n        map->subjectDomainPolicy = NULL;\n    }\n    ret = 1;\n bad_mapping:\n    if (ret == -1 && CRYPTO_THREAD_write_lock(x->lock)) {\n        x->ex_flags |= EXFLAG_INVALID_POLICY;\n        CRYPTO_THREAD_unlock(x->lock);\n    }\n    sk_POLICY_MAPPING_pop_free(maps, POLICY_MAPPING_free);\n    return ret;\n}", "target": 1}
{"code": "gss_wrap_size_limit(OM_uint32  *minor_status,\n                    gss_ctx_id_t context_handle,\n                    int conf_req_flag,\n                    gss_qop_t qop_req, OM_uint32 req_output_size, OM_uint32 *max_input_size)\n{\n    gss_union_ctx_id_t  ctx;\n    gss_mechanism       mech;\n    OM_uint32           major_status;\n    if (minor_status == NULL)\n        return (GSS_S_CALL_INACCESSIBLE_WRITE);\n    *minor_status = 0;\n    if (context_handle == GSS_C_NO_CONTEXT)\n        return (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n    if (max_input_size == NULL)\n        return (GSS_S_CALL_INACCESSIBLE_WRITE);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n        return (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (!mech)\n        return (GSS_S_BAD_MECH);\n    if (mech->gss_wrap_size_limit)\n        major_status = mech->gss_wrap_size_limit(minor_status,\n                                                 ctx->internal_ctx_id,\n                                                 conf_req_flag, qop_req,\n                                                 req_output_size, max_input_size);\n    else if (mech->gss_wrap_iov_length)\n        major_status = gssint_wrap_size_limit_iov_shim(mech, minor_status,\n                                                       ctx->internal_ctx_id,\n                                                       conf_req_flag, qop_req,\n                                                       req_output_size, max_input_size);\n    else\n        major_status = GSS_S_UNAVAILABLE;\n    if (major_status != GSS_S_COMPLETE)\n        map_error(minor_status, mech);\n    return major_status;\n}", "target": 0}
{"code": "void cql_server::response::write_long_string(const sstring& s)\n{\n    write_int(cast_if_fits<int32_t>(s.size()));\n    _body.write(bytes_view(reinterpret_cast<const int8_t*>(s.data()), s.size()));\n}", "target": 0}
{"code": "static void shm_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp)\n{\n\tns->shm_tot -= (shp->shm_segsz + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tshm_rmid(ns, shp);\n\tshm_unlock(shp);\n\tif (!is_file_hugepages(shp->shm_file))\n\t\tshmem_lock(shp->shm_file, 0, shp->mlock_user);\n\telse if (shp->mlock_user)\n\t\tuser_shm_unlock(file_inode(shp->shm_file)->i_size,\n\t\t\t\t\t\tshp->mlock_user);\n\tfput (shp->shm_file);\n\tipc_rcu_putref(shp, shm_rcu_free);\n}", "target": 1}
{"code": "\tvirtual void run(Chunk &inChunk, Chunk &outChunk)\n\t{\n\t\tint count = inChunk.f.channelCount * inChunk.frameCount;\n\t\tif (m_isSigned)\n\t\t\trun<int32_t>(reinterpret_cast<const uint8_t *>(inChunk.buffer),\n\t\t\t\treinterpret_cast<int32_t *>(outChunk.buffer),\n\t\t\t\tcount);\n\t\telse\n\t\t\trun<uint32_t>(reinterpret_cast<const uint8_t *>(inChunk.buffer),\n\t\t\t\treinterpret_cast<uint32_t *>(outChunk.buffer),\n\t\t\t\tcount);\n\t}", "target": 0}
{"code": "static bool get_user_list(struct torture_context *torture, char ***users)\n{\n\tstruct winbindd_request req;\n\tstruct winbindd_response rep;\n\tchar **u = NULL;\n\tuint32_t count;\n\tchar name[256];\n\tconst char *extra_data;\n\tZERO_STRUCT(req);\n\tZERO_STRUCT(rep);\n\tDO_STRUCT_REQ_REP(WINBINDD_LIST_USERS, &req, &rep);\n\textra_data = (char *)rep.extra_data.data;\n\ttorture_assert(torture, extra_data, \"NULL extra data\");\n\tfor(count = 0;\n\t    next_token(&extra_data, name, \",\", sizeof(name));\n\t    count++)\n\t{\n\t\tu = talloc_realloc(torture, u, char *, count + 2);\n\t\tu[count+1] = NULL;\n\t\tu[count] = talloc_strdup(u, name);\n\t}\n\tSAFE_FREE(rep.extra_data.data);\n\t*users = u;\n\treturn true;\n}", "target": 0}
{"code": "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);\n}", "target": 1}
{"code": "static int _gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n{\n\tuint8_t *argb;\n\tint x, y;\n\tuint8_t *p;\n\tuint8_t *out;\n\tsize_t out_size;\n    int ret = 0;\n\tif (im == NULL) {\n\t\treturn 1;\n\t}\n\tif (!gdImageTrueColor(im)) {\n\t\tgd_error(\"Palette image not supported by webp\");\n\t\treturn 1;\n\t}\n\tif (quality == -1) {\n\t\tquality = 80;\n\t}\n\tif (overflow2(gdImageSX(im), 4)) {\n\t\treturn 1;\n\t}\n\tif (overflow2(gdImageSX(im) * 4, gdImageSY(im))) {\n\t\treturn 1;\n\t}\n\targb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));\n\tif (!argb) {\n\t\treturn 1;\n\t}\n\tp = argb;\n\tfor (y = 0; y < gdImageSY(im); y++) {\n\t\tfor (x = 0; x < gdImageSX(im); x++) {\n\t\t\tregister int c;\n\t\t\tregister char a;\n\t\t\tc = im->tpixels[y][x];\n\t\t\ta = gdTrueColorGetAlpha(c);\n\t\t\tif (a == 127) {\n\t\t\t\ta = 0;\n\t\t\t} else {\n\t\t\t\ta = 255 - ((a << 1) + (a >> 6));\n\t\t\t}\n\t\t\t*(p++) = gdTrueColorGetRed(c);\n\t\t\t*(p++) = gdTrueColorGetGreen(c);\n\t\t\t*(p++) = gdTrueColorGetBlue(c); \n\t\t\t*(p++) = a;\n\t\t}\n\t}\n\tout_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);\n\tif (out_size == 0) {\n\t\tgd_error(\"gd-webp encoding failed\");\n        ret = 1;\n\t\tgoto freeargb;\n\t}\n\tgdPutBuf(out, out_size, outfile);\n\tfree(out);\nfreeargb:\n\tgdFree(argb);\n    return ret;\n}", "target": 0}
{"code": "disable_priv_mode ()\n{\n  int e;\n#if HAVE_DECL_SETRESUID\n  if (setresuid (current_user.uid, current_user.uid, current_user.uid) < 0)\n#else\n  if (setuid (current_user.uid) < 0)\n#endif\n    {\n      e = errno;\n      sys_error (_(\"cannot set uid to %d: effective uid %d\"), current_user.uid, current_user.euid);\n#if defined (EXIT_ON_SETUID_FAILURE)\n      if (e == EAGAIN)\n\texit (e);\n#endif\n    }\n#if HAVE_DECL_SETRESGID\n  if (setresgid (current_user.gid, current_user.gid, current_user.gid) < 0)\n#else\n  if (setgid (current_user.gid) < 0)\n#endif\n    sys_error (_(\"cannot set gid to %d: effective gid %d\"), current_user.gid, current_user.egid);\n  current_user.euid = current_user.uid;\n  current_user.egid = current_user.gid;\n}", "target": 0}
{"code": "static int pcrypt_create_aead(struct crypto_template *tmpl, struct rtattr **tb,\n\t\t\t      u32 type, u32 mask)\n{\n\tstruct pcrypt_instance_ctx *ctx;\n\tstruct crypto_attr_type *algt;\n\tstruct aead_instance *inst;\n\tstruct aead_alg *alg;\n\tconst char *name;\n\tint err;\n\talgt = crypto_get_attr_type(tb);\n\tif (IS_ERR(algt))\n\t\treturn PTR_ERR(algt);\n\tname = crypto_attr_alg_name(tb[1]);\n\tif (IS_ERR(name))\n\t\treturn PTR_ERR(name);\n\tinst = kzalloc(sizeof(*inst) + sizeof(*ctx), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\tctx = aead_instance_ctx(inst);\n\tcrypto_set_aead_spawn(&ctx->spawn, aead_crypto_instance(inst));\n\terr = crypto_grab_aead(&ctx->spawn, name, 0, 0);\n\tif (err)\n\t\tgoto out_free_inst;\n\talg = crypto_spawn_aead_alg(&ctx->spawn);\n\terr = pcrypt_init_instance(aead_crypto_instance(inst), &alg->base);\n\tif (err)\n\t\tgoto out_drop_aead;\n\tinst->alg.base.cra_flags = CRYPTO_ALG_ASYNC;\n\tinst->alg.ivsize = crypto_aead_alg_ivsize(alg);\n\tinst->alg.maxauthsize = crypto_aead_alg_maxauthsize(alg);\n\tinst->alg.base.cra_ctxsize = sizeof(struct pcrypt_aead_ctx);\n\tinst->alg.init = pcrypt_aead_init_tfm;\n\tinst->alg.exit = pcrypt_aead_exit_tfm;\n\tinst->alg.setkey = pcrypt_aead_setkey;\n\tinst->alg.setauthsize = pcrypt_aead_setauthsize;\n\tinst->alg.encrypt = pcrypt_aead_encrypt;\n\tinst->alg.decrypt = pcrypt_aead_decrypt;\n\tinst->free = pcrypt_free;\n\terr = aead_register_instance(tmpl, inst);\n\tif (err)\n\t\tgoto out_drop_aead;\nout:\n\treturn err;\nout_drop_aead:\n\tcrypto_drop_aead(&ctx->spawn);\nout_free_inst:\n\tkfree(inst);\n\tgoto out;\n}", "target": 0}
{"code": "static const char *findNextNonWSBack(const char *q, const char *start)\n{\n    while (q > start &&\n\t   (*q == 0 || *q == 9 || *q == 0xa || *q == 0xc || *q == 0xd || *q == 0x20))\n    {\n\tq--;\n    }\n    return q;\n}", "target": 0}
{"code": "static uint64_t HTPStateGetTxCnt(void *alstate)\n{\n    HtpState *http_state = (HtpState *)alstate;\n    if (http_state != NULL && http_state->conn != NULL) {\n        const int64_t size = (int64_t)htp_list_size(http_state->conn->transactions);\n        if (size < 0)\n            return 0ULL;\n        SCLogDebug(\"size %\"PRIu64, size);\n        return (uint64_t)size;\n    } else {\n        return 0ULL;\n    }\n}", "target": 1}
{"code": "static void update_blocked_averages(int cpu)\n{\n\tstruct rq *rq = cpu_rq(cpu);\n\tstruct cfs_rq *cfs_rq, *pos;\n\tconst struct sched_class *curr_class;\n\tstruct rq_flags rf;\n\tbool done = true;\n\trq_lock_irqsave(rq, &rf);\n\tupdate_rq_clock(rq);\n\tfor_each_leaf_cfs_rq_safe(rq, cfs_rq, pos) {\n\t\tstruct sched_entity *se;\n\t\tif (throttled_hierarchy(cfs_rq))\n\t\t\tcontinue;\n\t\tif (update_cfs_rq_load_avg(cfs_rq_clock_task(cfs_rq), cfs_rq))\n\t\t\tupdate_tg_load_avg(cfs_rq, 0);\n\t\tse = cfs_rq->tg->se[cpu];\n\t\tif (se && !skip_blocked_update(se))\n\t\t\tupdate_load_avg(cfs_rq_of(se), se, 0);\n\t\tif (cfs_rq_is_decayed(cfs_rq))\n\t\t\tlist_del_leaf_cfs_rq(cfs_rq);\n\t\tif (cfs_rq_has_blocked(cfs_rq))\n\t\t\tdone = false;\n\t}\n\tcurr_class = rq->curr->sched_class;\n\tupdate_rt_rq_load_avg(rq_clock_task(rq), rq, curr_class == &rt_sched_class);\n\tupdate_dl_rq_load_avg(rq_clock_task(rq), rq, curr_class == &dl_sched_class);\n\tupdate_irq_load_avg(rq, 0);\n\tif (others_have_blocked(rq))\n\t\tdone = false;\n#ifdef CONFIG_NO_HZ_COMMON\n\trq->last_blocked_load_update_tick = jiffies;\n\tif (done)\n\t\trq->has_blocked_load = 0;\n#endif\n\trq_unlock_irqrestore(rq, &rf);\n}", "target": 1}
{"code": "bool IsConvolutionOpSupported(const TfLiteRegistration* registration,\n                              const TfLiteNode* node, TfLiteContext* context) {\n  if (node->builtin_data == nullptr) return false;\n  TfLiteFusedActivation activation;\n  if (registration->builtin_code == kTfLiteBuiltinConv2d) {\n    const auto* conv_params =\n        reinterpret_cast<const TfLiteConvParams*>(node->builtin_data);\n    activation = conv_params->activation;\n  } else if (registration->builtin_code == kTfLiteBuiltinDepthwiseConv2d) {\n    const auto* depthwise_conv_params =\n        reinterpret_cast<const TfLiteDepthwiseConvParams*>(node->builtin_data);\n    activation = depthwise_conv_params->activation;\n  } else if (registration->builtin_code == kTfLiteBuiltinTransposeConv) {\n    activation = kTfLiteActNone;\n  } else {\n    TF_LITE_KERNEL_LOG(\n        context,\n        \"Invalid op: op must be Conv2D, DepthwiseConv2D or TransposeConv.\");\n    return false;\n  }\n  if (activation == kTfLiteActSignBit) {\n    return false;\n  }\n  const int kOutputShapeTensor = 0;  \n  const int kWeightTensor = 1;\n  const int kBiasTensor = 2;  \n  const TfLiteTensor* weights = GetInput(context, node, kWeightTensor);\n  const int max_kernel_size = 16384;\n  if (!IsConstantTensor(weights)) {\n    return false;\n  }\n  if (weights->dims->data[1] > max_kernel_size ||\n      weights->dims->data[2] > max_kernel_size) {\n    return false;\n  }\n  if (registration->builtin_code == kTfLiteBuiltinTransposeConv) {\n    if (!IsConstantTensor(GetInput(context, node, kOutputShapeTensor))) {\n      return false;\n    }\n  } else {\n    if (node->inputs->size >= kBiasTensor &&\n        !IsConstantTensor(GetInput(context, node, kBiasTensor))) {\n      return false;\n    }\n  }\n  return true;\n}", "target": 1}
{"code": "  SubgraphGuard(TfLiteContext* context, bool* is_subgraph_in_use)\n      : is_subgraph_in_use_(is_subgraph_in_use) {\n    if (*is_subgraph_in_use_) {\n      TF_LITE_KERNEL_LOG(\n          context,\n          \"Subgraph is already in use. Using an interpreter or a subgraph in \"\n          \"multiple threads is not supported. Recursion in the graph is not \"\n          \"supported.\");\n      status_ = kTfLiteError;\n    } else {\n      *is_subgraph_in_use_ = true;\n    }\n  }", "target": 0}
{"code": "    int FixCom::run(const std::string& path)\n    {\n        try {\n            if (!Exiv2::fileExists(path, true)) {\n                std::cerr << path << \": \" << _(\"Failed to open the file\\n\");\n                return -1;\n            }\n            Timestamp ts;\n            if (Params::instance().preserve_)\n                ts.read(path);\n            Exiv2::Image::UniquePtr image = Exiv2::ImageFactory::open(path);\n            image->readMetadata();\n            Exiv2::ExifData& exifData = image->exifData();\n            if (exifData.empty()) {\n                std::cerr << path << \": \" << _(\"No Exif data found in the file\\n\");\n                return -3;\n            }\n            auto pos = exifData.findKey(Exiv2::ExifKey(\"Exif.Photo.UserComment\"));\n            if (pos == exifData.end()) {\n                if (Params::instance().verbose_) {\n                    std::cout << _(\"No Exif user comment found\") << \"\\n\";\n                }\n                return 0;\n            }\n            Exiv2::Value::UniquePtr v = pos->getValue();\n            const Exiv2::CommentValue* pcv = dynamic_cast<const Exiv2::CommentValue*>(v.get());\n            if (!pcv) {\n                if (Params::instance().verbose_) {\n                    std::cout << _(\"Found Exif user comment with unexpected value type\") << \"\\n\";\n                }\n                return 0;\n            }\n            Exiv2::CommentValue::CharsetId csId = pcv->charsetId();\n            if (csId != Exiv2::CommentValue::unicode) {\n                if (Params::instance().verbose_) {\n                    std::cout << _(\"No Exif UNICODE user comment found\") << \"\\n\";\n                }\n                return 0;\n            }\n            std::string comment = pcv->comment(Params::instance().charset_.c_str());\n            if (Params::instance().verbose_) {\n                std::cout << _(\"Setting Exif UNICODE user comment to\") << \" \\\"\" << comment << \"\\\"\\n\";\n            }\n            comment = std::string(\"charset=\\\"\") + Exiv2::CommentValue::CharsetInfo::name(csId) + \"\\\" \" + comment;\n            pos->setValue(comment);\n            image->writeMetadata();\n            if (Params::instance().preserve_)\n                ts.touch(path);\n            return 0;\n        } catch (const Exiv2::AnyError& e) {\n            std::cerr << \"Exiv2 exception in fixcom action for file \" << path << \":\\n\" << e << \"\\n\";\n            return 1;\n        }\n    }", "target": 0}
{"code": "void rose_stop_idletimer(struct sock *sk)\n{\n\tdel_timer(&rose_sk(sk)->idletimer);\n}", "target": 1}
{"code": "LibRaw_byte_buffer *LibRaw_abstract_datastream::make_byte_buffer(unsigned int sz)\n{\n  if(INT64(sz)>size())\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n    LibRaw_byte_buffer *ret = new LibRaw_byte_buffer(sz);\n    if(!ret) \n      throw LIBRAW_EXCEPTION_ALLOC;\n    read(ret->get_buffer(),sz,1);\n    return ret;\n}", "target": 0}
{"code": "  StringTableEntry getStringTableEntry(uint32_t index) const override {\n    llvm_unreachable(\"Accessing string table from a lazy module\");\n  }", "target": 1}
{"code": "void handle_irq_for_port(evtchn_port_t port, struct evtchn_loop_ctrl *ctrl)\n{\n\tint irq;\n\tstruct irq_info *info;\n\tirq = get_evtchn_to_irq(port);\n\tif (irq == -1)\n\t\treturn;\n\tif (!ctrl->defer_eoi && !(++ctrl->count & 0xff)) {\n\t\tktime_t kt = ktime_get();\n\t\tif (!ctrl->timeout) {\n\t\t\tkt = ktime_add_ms(kt,\n\t\t\t\t\t  jiffies_to_msecs(event_loop_timeout));\n\t\t\tctrl->timeout = kt;\n\t\t} else if (kt > ctrl->timeout) {\n\t\t\tctrl->defer_eoi = true;\n\t\t}\n\t}\n\tinfo = info_for_irq(irq);\n\tif (ctrl->defer_eoi) {\n\t\tinfo->eoi_cpu = smp_processor_id();\n\t\tinfo->irq_epoch = __this_cpu_read(irq_epoch);\n\t\tinfo->eoi_time = get_jiffies_64() + event_eoi_delay;\n\t}\n\tgeneric_handle_irq(irq);\n}", "target": 0}
{"code": "static void sas_init_port(struct asd_sas_port *port,\n\t\t\t  struct sas_ha_struct *sas_ha, int i)\n{\n\tmemset(port, 0, sizeof(*port));\n\tport->id = i;\n\tINIT_LIST_HEAD(&port->dev_list);\n\tINIT_LIST_HEAD(&port->disco_list);\n\tINIT_LIST_HEAD(&port->destroy_list);\n\tINIT_LIST_HEAD(&port->sas_port_del_list);\n\tspin_lock_init(&port->phy_list_lock);\n\tINIT_LIST_HEAD(&port->phy_list);\n\tport->ha = sas_ha;\n\tspin_lock_init(&port->dev_list_lock);\n}", "target": 0}
{"code": "Status TensorShapeFromTensor(const Tensor& t, PartialTensorShape* out) {\n  if (t.shape() == TensorShape({})) {\n    if ((t.dtype() == DT_INT32 && t.scalar<int32>()() == -1) ||\n        (t.dtype() == DT_INT64 && t.scalar<int64_t>()() == -1)) {\n      *out = PartialTensorShape();\n      return OkStatus();\n    }\n    return errors::InvalidArgument(\n        \"The only valid scalar shape tensor is the fully unknown shape \"\n        \"specified as -1.\");\n  } else if (t.shape().dims() != 1) {\n    return errors::InvalidArgument(\"Shape must be at most rank 1 but is rank \",\n                                   t.shape().dims());\n  }\n  if (t.dtype() == DT_INT32) {\n    return PartialTensorShape::MakePartialShape(t.vec<int32>().data(),\n                                                t.NumElements(), out);\n  } else if (t.dtype() == DT_INT64) {\n    return PartialTensorShape::MakePartialShape(t.vec<int64_t>().data(),\n                                                t.NumElements(), out);\n  }\n  return errors::InvalidArgument(\n      \"Expected an int32 or int64 shape tensor; found \",\n      DataTypeString(t.dtype()));\n}", "target": 0}
{"code": "void hrandfieldCommand(client *c) {\n    long l;\n    int withvalues = 0;\n    robj *hash;\n    listpackEntry ele;\n    if (c->argc >= 3) {\n        if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;\n        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withvalues\"))) {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        } else if (c->argc == 4)\n            withvalues = 1;\n        hrandfieldWithCountCommand(c, l, withvalues);\n        return;\n    }\n    if ((hash = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL ||\n        checkType(c,hash,OBJ_HASH)) {\n        return;\n    }\n    hashTypeRandomElement(hash,hashTypeLength(hash),&ele,NULL);\n    hashReplyFromListpackEntry(c, &ele);\n}", "target": 1}
{"code": "static void ion_free_nolock(struct ion_client *client, struct ion_handle *handle)\n{\n\tbool valid_handle;\n\tBUG_ON(client != handle->client);\n\tvalid_handle = ion_handle_validate(client, handle);\n\tif (!valid_handle) {\n\t\tWARN(1, \"%s: invalid handle passed to free.\\n\", __func__);\n\t\treturn;\n\t}\n\tion_handle_put_nolock(handle);\n}", "target": 0}
{"code": "static void do_free_publickey(struct ecc_public_key *key)\n{\n\tcrypto_bignum_free(key->x);\n\tcrypto_bignum_free(key->y);\n}", "target": 1}
{"code": "void usbredirparser_send_control_packet(struct usbredirparser *parser,\n    uint64_t id,\n    struct usb_redir_control_packet_header *control_header,\n    uint8_t *data, int data_len)\n{\n    usbredirparser_queue(parser, usb_redir_control_packet, id, control_header,\n                         data, data_len);\n}", "target": 0}
{"code": "void LibRaw::sinar_4shot_load_raw()\n{\n  ushort *pixel;\n  unsigned shot, row, col, r, c;\n  if (raw_image)\n  {\n    shot = LIM(shot_select, 1, 4) - 1;\n    fseek(ifp, data_offset + shot * 4, SEEK_SET);\n    fseek(ifp, get4(), SEEK_SET);\n    unpacked_load_raw();\n    return;\n  }\n  if (!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  pixel = (ushort *)calloc(raw_width, sizeof *pixel);\n  merror(pixel, \"sinar_4shot_load_raw()\");\n  try\n  {\n    for (shot = 0; shot < 4; shot++)\n    {\n      checkCancel();\n      fseek(ifp, data_offset + shot * 4, SEEK_SET);\n      fseek(ifp, get4(), SEEK_SET);\n      for (row = 0; row < raw_height; row++)\n      {\n        read_shorts(pixel, raw_width);\n        if ((r = row - top_margin - (shot >> 1 & 1)) >= height)\n          continue;\n        for (col = 0; col < raw_width; col++)\n        {\n          if ((c = col - left_margin - (shot & 1)) >= width)\n            continue;\n          image[r * width + c][(row & 1) * 3 ^ (~col & 1)] = pixel[col];\n        }\n      }\n    }\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n  free(pixel);\n  mix_green = 1;\n}", "target": 0}
{"code": "ftrace_filter_lseek(struct file *file, loff_t offset, int whence)\n{\n\tloff_t ret;\n\tif (file->f_mode & FMODE_READ)\n\t\tret = seq_lseek(file, offset, whence);\n\telse\n\t\tfile->f_pos = ret = 1;\n\treturn ret;\n}", "target": 0}
{"code": "static inline int domain_pfn_mapping(struct dmar_domain *domain, unsigned long iov_pfn,\n\t\t\t\t     unsigned long phys_pfn, unsigned long nr_pages,\n\t\t\t\t     int prot)\n{\n\treturn domain_mapping(domain, iov_pfn, NULL, phys_pfn, nr_pages, prot);\n}", "target": 0}
{"code": "static inline void sem_unlock(struct sem_array *sma, int locknum)\n{\n\tif (locknum == -1) {\n\t\tspin_unlock(&sma->sem_perm.lock);\n\t} else {\n\t\tstruct sem *sem = sma->sem_base + locknum;\n\t\tspin_unlock(&sem->lock);\n\t}\n\trcu_read_unlock();\n}", "target": 0}
{"code": "static void __net_random_once_deferred(struct work_struct *w)\n{\n\tstruct __net_random_once_work *work =\n\t\tcontainer_of(w, struct __net_random_once_work, work);\n\tif (!static_key_enabled(work->key))\n\t\tstatic_key_slow_inc(work->key);\n\tkfree(work);\n}", "target": 1}
{"code": "static int picolcd_raw_event(struct hid_device *hdev,\n\t\tstruct hid_report *report, u8 *raw_data, int size)\n{\n\tstruct picolcd_data *data = hid_get_drvdata(hdev);\n\tunsigned long flags;\n\tint ret = 0;\n\tif (!data)\n\t\treturn 1;\n\tif (size > 64) {\n\t\thid_warn(hdev, \"invalid size value (%d) for picolcd raw event\\n\",\n\t\t\t\tsize);\n\t\treturn 0;\n\t}\n\tif (report->id == REPORT_KEY_STATE) {\n\t\tif (data->input_keys)\n\t\t\tret = picolcd_raw_keypad(data, report, raw_data+1, size-1);\n\t} else if (report->id == REPORT_IR_DATA) {\n\t\tret = picolcd_raw_cir(data, report, raw_data+1, size-1);\n\t} else {\n\t\tspin_lock_irqsave(&data->lock, flags);\n\t\tif (data->pending) {\n\t\t\tmemcpy(data->pending->raw_data, raw_data+1, size-1);\n\t\t\tdata->pending->raw_size  = size-1;\n\t\t\tdata->pending->in_report = report;\n\t\t\tcomplete(&data->pending->ready);\n\t\t}\n\t\tspin_unlock_irqrestore(&data->lock, flags);\n\t}\n\tpicolcd_debug_raw_event(data, hdev, report, raw_data, size);\n\treturn 1;\n}", "target": 0}
{"code": "int vm_iomap_memory(struct vm_area_struct *vma, phys_addr_t start, unsigned long len)\n{\n\tunsigned long vm_len, pfn, pages;\n\tif (start + len < start)\n\t\treturn -EINVAL;\n\tlen += start & ~PAGE_MASK;\n\tpfn = start >> PAGE_SHIFT;\n\tpages = (len + ~PAGE_MASK) >> PAGE_SHIFT;\n\tif (pfn + pages < pfn)\n\t\treturn -EINVAL;\n\tif (vma->vm_pgoff > pages)\n\t\treturn -EINVAL;\n\tpfn += vma->vm_pgoff;\n\tpages -= vma->vm_pgoff;\n\tvm_len = vma->vm_end - vma->vm_start;\n\tif (vm_len >> PAGE_SHIFT > pages)\n\t\treturn -EINVAL;\n\treturn io_remap_pfn_range(vma, vma->vm_start, pfn, vm_len, vma->vm_page_prot);\n}", "target": 0}
{"code": "createFile(const string &filename, const StaticString &contents, mode_t permissions, uid_t owner,\n\tgid_t group, bool overwrite)\n{\n\tFileDescriptor fd;\n\tint ret, e, options;\n\toptions = O_WRONLY | O_CREAT | O_TRUNC;\n\tif (!overwrite) {\n\t\toptions |= O_EXCL;\n\t}\n\tdo {\n\t\tfd = open(filename.c_str(), options, permissions);\n\t} while (fd == -1 && errno == EINTR);\n\tif (fd != -1) {\n\t\tFileGuard guard(filename);\n\t\tdo {\n\t\t\tret = fchmod(fd, permissions);\n\t\t} while (ret == -1 && errno == EINTR);\n\t\tif (ret == -1) {\n\t\t\te = errno;\n\t\t\tthrow FileSystemException(\"Cannot set permissions on \" + filename,\n\t\t\t\te, filename);\n\t\t}\n\t\tif (owner != USER_NOT_GIVEN && group != GROUP_NOT_GIVEN) {\n\t\t\tif (owner == USER_NOT_GIVEN) {\n\t\t\t\towner = (uid_t) -1; \n\t\t\t}\n\t\t\tif (group == GROUP_NOT_GIVEN) {\n\t\t\t\tgroup = (gid_t) -1; \n\t\t\t}\n\t\t\tdo {\n\t\t\t\tret = fchown(fd, owner, group);\n\t\t\t} while (ret == -1 && errno == EINTR);\n\t\t\tif (ret == -1) {\n\t\t\t\te = errno;\n\t\t\t\tthrow FileSystemException(\"Cannot set ownership for \" + filename,\n\t\t\t\t\te, filename);\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\twriteExact(fd, contents);\n\t\t\tfd.close();\n\t\t} catch (const SystemException &e) {\n\t\t\tthrow FileSystemException(\"Cannot write to file \" + filename,\n\t\t\t\te.code(), filename);\n\t\t}\n\t\tguard.commit();\n\t} else {\n\t\te = errno;\n\t\tif (overwrite || e != EEXIST) {\n\t\t\tthrow FileSystemException(\"Cannot create file \" + filename,\n\t\t\t\te, filename);\n\t\t}\n\t}\n}", "target": 0}
{"code": "void CLASS parse_kodak_ifd (int base)\n{\n  unsigned entries, tag, type, len, save;\n  int i, c, wbi=-2, wbtemp=6500;\n  float mul[3]={1,1,1}, num;\n  static const int wbtag[] = { 64037,64040,64039,64041,-1,-1,64042 };\n  entries = get2();\n  if (entries > 1024) return;\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    if (tag == 1020) wbi = getint(type);\n    if (tag == 1021 && len == 72) {\t\t\n      fseek (ifp, 40, SEEK_CUR);\n      FORC3 cam_mul[c] = 2048.0 / get2();\n      wbi = -2;\n    }\n    if (tag == 2118) wbtemp = getint(type);\n    if (tag == 2120 + wbi && wbi >= 0)\n      FORC3 cam_mul[c] = 2048.0 / getreal(type);\n    if (tag == 2130 + wbi)\n      FORC3 mul[c] = getreal(type);\n    if (tag == 2140 + wbi && wbi >= 0)\n      FORC3 {\n\tfor (num=i=0; i < 4; i++)\n\t  num += getreal(type) * pow (wbtemp/100.0, i);\n\tcam_mul[c] = 2048 / (num * mul[c]);\n      }\n    if (tag == 2317) linear_table (len);\n    if (tag == 6020) iso_speed = getint(type);\n    if (tag == 64013) wbi = fgetc(ifp);\n    if ((unsigned) wbi < 7 && tag == wbtag[wbi])\n      FORC3 cam_mul[c] = get4();\n    if (tag == 64019) width = getint(type);\n    if (tag == 64020) height = (getint(type)+1) & -2;\n    fseek (ifp, save, SEEK_SET);\n  }\n}", "target": 0}
{"code": "static const char *adpt_i2o_get_class_name(int class)\n{\n\tint idx = 16;\n\tstatic char *i2o_class_name[] = {\n\t\t\"Executive\",\n\t\t\"Device Driver Module\",\n\t\t\"Block Device\",\n\t\t\"Tape Device\",\n\t\t\"LAN Interface\",\n\t\t\"WAN Interface\",\n\t\t\"Fibre Channel Port\",\n\t\t\"Fibre Channel Device\",\n\t\t\"SCSI Device\",\n\t\t\"ATE Port\",\n\t\t\"ATE Device\",\n\t\t\"Floppy Controller\",\n\t\t\"Floppy Device\",\n\t\t\"Secondary Bus Port\",\n\t\t\"Peer Transport Agent\",\n\t\t\"Peer Transport\",\n\t\t\"Unknown\"\n\t};\n\tswitch(class&0xFFF) {\n\tcase I2O_CLASS_EXECUTIVE:\n\t\tidx = 0; break;\n\tcase I2O_CLASS_DDM:\n\t\tidx = 1; break;\n\tcase I2O_CLASS_RANDOM_BLOCK_STORAGE:\n\t\tidx = 2; break;\n\tcase I2O_CLASS_SEQUENTIAL_STORAGE:\n\t\tidx = 3; break;\n\tcase I2O_CLASS_LAN:\n\t\tidx = 4; break;\n\tcase I2O_CLASS_WAN:\n\t\tidx = 5; break;\n\tcase I2O_CLASS_FIBRE_CHANNEL_PORT:\n\t\tidx = 6; break;\n\tcase I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL:\n\t\tidx = 7; break;\n\tcase I2O_CLASS_SCSI_PERIPHERAL:\n\t\tidx = 8; break;\n\tcase I2O_CLASS_ATE_PORT:\n\t\tidx = 9; break;\n\tcase I2O_CLASS_ATE_PERIPHERAL:\n\t\tidx = 10; break;\n\tcase I2O_CLASS_FLOPPY_CONTROLLER:\n\t\tidx = 11; break;\n\tcase I2O_CLASS_FLOPPY_DEVICE:\n\t\tidx = 12; break;\n\tcase I2O_CLASS_BUS_ADAPTER_PORT:\n\t\tidx = 13; break;\n\tcase I2O_CLASS_PEER_TRANSPORT_AGENT:\n\t\tidx = 14; break;\n\tcase I2O_CLASS_PEER_TRANSPORT:\n\t\tidx = 15; break;\n\t}\n\treturn i2o_class_name[idx];\n}", "target": 1}
{"code": "void PDPSimple::notifyAboveRemoteEndpoints(\n        const ParticipantProxyData& pdata)\n{\n    if (mp_EDP != nullptr)\n    {\n        mp_EDP->assignRemoteEndpoints(pdata);\n    }\n    if (mp_builtin->mp_WLP != nullptr)\n    {\n        mp_builtin->mp_WLP->assignRemoteEndpoints(pdata);\n    }\n    if (mp_builtin->tlm_ != nullptr)\n    {\n        mp_builtin->tlm_->assign_remote_endpoints(pdata);\n    }\n}", "target": 1}
{"code": "switchGroup(uid_t uid, const struct passwd *userInfo, gid_t gid) {\n\tif (userInfo != NULL) {\n\t\tbool setgroupsCalled = false;\n\t\t#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__)\n\t\t\t#ifdef __APPLE__\n\t\t\t\tint groups[1024];\n\t\t\t\tint ngroups = sizeof(groups) / sizeof(int);\n\t\t\t#else\n\t\t\t\tgid_t groups[1024];\n\t\t\t\tint ngroups = sizeof(groups) / sizeof(gid_t);\n\t\t\t#endif\n\t\t\tboost::scoped_array<gid_t> gidset;\n\t\t\tint ret = getgrouplist(userInfo->pw_name, gid,\n\t\t\t\tgroups, &ngroups);\n\t\t\tif (ret == -1) {\n\t\t\t\tint e = errno;\n\t\t\t\tfprintf(stderr, \"ERROR: getgrouplist(%s, %d) failed: %s (errno=%d)\\n\",\n\t\t\t\t\tuserInfo->pw_name, (int) gid, strerror(e), e);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (ngroups <= NGROUPS_MAX) {\n\t\t\t\tsetgroupsCalled = true;\n\t\t\t\tgidset.reset(new gid_t[ngroups]);\n\t\t\t\tfor (int i = 0; i < ngroups; i++) {\n\t\t\t\t\tgidset[i] = groups[i];\n\t\t\t\t}\n\t\t\t\tif (setgroups(ngroups, gidset.get()) == -1) {\n\t\t\t\t\tint e = errno;\n\t\t\t\t\tfprintf(stderr, \"ERROR: setgroups(%d, ...) failed: %s (errno=%d)\\n\",\n\t\t\t\t\t\tngroups, strerror(e), e);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t#endif\n\t\tif (!setgroupsCalled && initgroups(userInfo->pw_name, gid) == -1) {\n\t\t\tint e = errno;\n\t\t\tfprintf(stderr, \"ERROR: initgroups(%s, %d) failed: %s (errno=%d)\\n\",\n\t\t\t\tuserInfo->pw_name, (int) gid, strerror(e), e);\n\t\t\texit(1);\n\t\t}\n\t}\n\tif (setgid(gid) == -1) {\n\t\tint e = errno;\n\t\tfprintf(stderr, \"ERROR: setgid(%d) failed: %s (errno=%d)\\n\",\n\t\t\t(int) gid, strerror(e), e);\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "char *redisProtocolToLuaType_Aggregate(lua_State *lua, char *reply, int atype) {\n    char *p = strchr(reply+1,'\\r');\n    long long mbulklen;\n    int j = 0;\n    string2ll(reply+1,p-reply-1,&mbulklen);\n    if (server.lua_client->resp == 2 || atype == '*') {\n        p += 2;\n        if (mbulklen == -1) {\n            lua_pushboolean(lua,0);\n            return p;\n        }\n        lua_newtable(lua);\n        for (j = 0; j < mbulklen; j++) {\n            lua_pushnumber(lua,j+1);\n            p = redisProtocolToLuaType(lua,p);\n            lua_settable(lua,-3);\n        }\n    } else if (server.lua_client->resp == 3) {\n        p += 2;\n        lua_newtable(lua);\n        lua_pushstring(lua,atype == '%' ? \"map\" : \"set\");\n        lua_newtable(lua);\n        for (j = 0; j < mbulklen; j++) {\n            p = redisProtocolToLuaType(lua,p);\n            if (atype == '%') {\n                p = redisProtocolToLuaType(lua,p);\n            } else {\n                if (!lua_checkstack(lua, 1)) {\n                    serverPanic(\"lua stack limit reach when parsing redis.call reply\");\n                }\n                lua_pushboolean(lua,1);\n            }\n            lua_settable(lua,-3);\n        }\n        lua_settable(lua,-3);\n    }\n    return p;\n}", "target": 0}
{"code": "WM_SYMBOL midi *WildMidi_Open(const char *midifile) {\n    uint8_t *mididata = NULL;\n    uint32_t midisize = 0;\n    uint8_t mus_hdr[] = { 'M', 'U', 'S', 0x1A };\n    uint8_t xmi_hdr[] = { 'F', 'O', 'R', 'M' };\n    midi * ret = NULL;\n    if (!WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (NULL);\n    }\n    if (midifile == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL filename)\", 0);\n        return (NULL);\n    }\n    if ((mididata = (uint8_t *) _WM_BufferFile(midifile, &midisize)) == NULL) {\n        return (NULL);\n    }\n    if (midisize < 18) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n        return (NULL);\n    }\n    if (memcmp(mididata,\"HMIMIDIP\", 8) == 0) {\n        ret = (void *) _WM_ParseNewHmp(mididata, midisize);\n    } else if (memcmp(mididata, \"HMI-MIDISONG061595\", 18) == 0) {\n        ret = (void *) _WM_ParseNewHmi(mididata, midisize);\n    } else if (memcmp(mididata, mus_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewMus(mididata, midisize);\n    } else if (memcmp(mididata, xmi_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewXmi(mididata, midisize);\n    } else {\n        ret = (void *) _WM_ParseNewMidi(mididata, midisize);\n    }\n    free(mididata);\n    if (ret) {\n        if (add_handle(ret) != 0) {\n            WildMidi_Close(ret);\n            ret = NULL;\n        }\n    }\n    return (ret);\n}", "target": 0}
{"code": "static void check_hostalias(request_rec *r)\n{\n    const char *host = r->hostname;\n    apr_port_t port;\n    server_rec *s;\n    server_rec *virthost_s;\n    server_rec *last_s;\n    name_chain *src;\n    virthost_s = NULL;\n    last_s = NULL;\n    port = r->connection->local_addr->port;\n    for (src = r->connection->vhost_lookup_data; src; src = src->next) {\n        server_addr_rec *sar;\n        sar = src->sar;\n        if (sar->host_port != 0 && port != sar->host_port) {\n            continue;\n        }\n        s = src->server;\n        if (s != last_s) {\n            if (matches_aliases(s, host)) {\n                goto found;\n            }\n        }\n        if (!strcasecmp(host, sar->virthost)) {\n            if (virthost_s == NULL) {\n                virthost_s = s;\n            }\n        }\n        last_s = s;\n    }\n    if (virthost_s) {\n        s = virthost_s;\n        goto found;\n    }\n    return;\nfound:\n    r->server = s;\n}", "target": 1}
{"code": "    void appendCDATABlockCallback(const xmlChar* s, int len)\n    {\n        PendingCDATABlockCallback* callback = new PendingCDATABlockCallback;\n        callback->s = xmlStrndup(s, len);\n        callback->len = len;\n        m_callbacks.append(callback);        \n    }", "target": 0}
{"code": "sshpam_cleanup(void *arg)\n{\n\t(void)arg;\n\tdebug(\"PAM: cleanup\");\n\tpam_set_item(sshpam_handle, PAM_CONV, (const void *)&null_conv);\n\tif (sshpam_cred_established) {\n\t\tpam_setcred(sshpam_handle, PAM_DELETE_CRED);\n\t\tsshpam_cred_established = 0;\n\t}\n\tif (sshpam_session_open) {\n\t\tpam_close_session(sshpam_handle, PAM_SILENT);\n\t\tsshpam_session_open = 0;\n\t}\n\tsshpam_authenticated = sshpam_new_authtok_reqd = 0;\n\tpam_end(sshpam_handle, sshpam_err);\n\tsshpam_handle = NULL;\n}", "target": 0}
{"code": "bool allowed_new_user_problem_entry(uid_t uid, const char *name, const char *value)\n{\n    if (uid == 0)\n        return true;\n    if (strcmp(name, FILENAME_ANALYZER) != 0\n     && strcmp(name, FILENAME_TYPE) != 0\n     && strcmp(name, \"basename\") != 0)\n        return true;\n     if (strcmp(value, \"CCpp\") != 0\n      && strcmp(value, \"Kerneloops\") != 0\n      && strcmp(value, \"vmcore\") != 0\n      && strcmp(value, \"xorg\") != 0)\n        return true;\n    error_msg(\"Only root is permitted to create element '%s' containing '%s'\", name, value);\n    return false;\n}", "target": 0}
{"code": "ssh_packet_set_postauth(struct ssh *ssh)\n{\n\tstruct sshcomp *comp;\n\tint r, mode;\n\tdebug(\"%s: called\", __func__);\n\tssh->state->after_authentication = 1;\n\tssh->state->rekeying = 0;\n\tfor (mode = 0; mode < MODE_MAX; mode++) {\n\t\tif (ssh->state->newkeys[mode] == NULL)\n\t\t\tcontinue;\n\t\tcomp = &ssh->state->newkeys[mode]->comp;\n\t\tif (comp && comp->enabled &&\n\t\t    (r = ssh_packet_init_compression(ssh)) != 0)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static bool ieee80211_validate_radiotap_len(struct sk_buff *skb)\n{\n\tstruct ieee80211_radiotap_header *rthdr =\n\t\t(struct ieee80211_radiotap_header *)skb->data;\n\tif (unlikely(skb->len < sizeof(struct ieee80211_radiotap_header)))\n\t\treturn false; \n\tif (unlikely(rthdr->it_version))\n\t\treturn false; \n\tif (unlikely(skb->len < ieee80211_get_radiotap_len(skb->data)))\n\t\treturn false; \n\treturn true;\n}", "target": 0}
{"code": "init_ctx_cont(OM_uint32 *minor_status, gss_ctx_id_t *ctx, gss_buffer_t buf,\n\t      gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,\n\t      OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 ret, tmpmin, acc_negState;\n\tunsigned char *ptr;\n\tspnego_gss_ctx_id_t sc;\n\tgss_OID supportedMech = GSS_C_NO_OID;\n\tsc = (spnego_gss_ctx_id_t)*ctx;\n\t*negState = REJECT;\n\t*tokflag = ERROR_TOKEN_SEND;\n\tptr = buf->value;\n\tret = get_negTokenResp(minor_status, ptr, buf->length,\n\t\t\t       &acc_negState, &supportedMech,\n\t\t\t       responseToken, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\tif (acc_negState == REJECT) {\n\t\t*minor_status = ERR_SPNEGO_NEGOTIATION_FAILED;\n\t\tmap_errcode(minor_status);\n\t\t*tokflag = NO_TOKEN_SEND;\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tif (!sc->nego_done) {\n\t\tret = init_ctx_nego(minor_status, sc,\n\t\t\t\t    acc_negState,\n\t\t\t\t    supportedMech, responseToken,\n\t\t\t\t    mechListMIC,\n\t\t\t\t    negState, tokflag);\n\t} else if ((!sc->mech_complete && *responseToken == GSS_C_NO_BUFFER) ||\n\t\t   (sc->mech_complete && *responseToken != GSS_C_NO_BUFFER)) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t} else if (!sc->mech_complete ||\n\t\t   (sc->mic_reqd &&\n\t\t    (sc->ctx_flags & GSS_C_INTEG_FLAG))) {\n\t\t*negState = ACCEPT_INCOMPLETE;\n\t\t*tokflag = CONT_TOKEN_SEND;\n\t\tret = GSS_S_CONTINUE_NEEDED;\n\t} else {\n\t\t*negState = ACCEPT_COMPLETE;\n\t\t*tokflag = NO_TOKEN_SEND;\n\t\tret = GSS_S_COMPLETE;\n\t}\ncleanup:\n\tif (supportedMech != GSS_C_NO_OID)\n\t\tgeneric_gss_release_oid(&tmpmin, &supportedMech);\n\treturn ret;\n}", "target": 0}
{"code": "static int tls_construct_cke_dhe(SSL *s, unsigned char **p, int *len, int *al)\n{\n#ifndef OPENSSL_NO_DH\n    DH *dh_clnt = NULL;\n    const BIGNUM *pub_key;\n    EVP_PKEY *ckey = NULL, *skey = NULL;\n    skey = s->s3->peer_tmp;\n    if (skey == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n    ckey = ssl_generate_pkey(skey);\n    if (ckey == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n    dh_clnt = EVP_PKEY_get0_DH(ckey);\n    if (dh_clnt == NULL || ssl_derive(s, ckey, skey) == 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);\n        EVP_PKEY_free(ckey);\n        return 0;\n    }\n    DH_get0_key(dh_clnt, &pub_key, NULL);\n    *len = BN_num_bytes(pub_key);\n    s2n(*len, *p);\n    BN_bn2bin(pub_key, *p);\n    *len += 2;\n    EVP_PKEY_free(ckey);\n    return 1;\n#else\n    SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);\n    *al = SSL_AD_INTERNAL_ERROR;\n    return 0;\n#endif\n}", "target": 0}
{"code": "    const std::unordered_map<std::string, std::string> &parameters()\n        const override\n    {\n        parseParametersOnce();\n        return parameters_;\n    }", "target": 1}
{"code": "dup_dest_constraints(const struct dest_constraint *dcs, size_t ndcs)\n{\n\tsize_t i;\n\tstruct dest_constraint *ret;\n\tif (ndcs == 0)\n\t\treturn NULL;\n\tret = xcalloc(ndcs, sizeof(*ret));\n\tfor (i = 0; i < ndcs; i++) {\n\t\tdup_dest_constraint_hop(&dcs[i].from, &ret[i].from);\n\t\tdup_dest_constraint_hop(&dcs[i].to, &ret[i].to);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "TfLiteStatus GenericPrepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLitePoolParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  int batches = input->dims->data[0];\n  int height = input->dims->data[1];\n  int width = input->dims->data[2];\n  int channels_out = input->dims->data[3];\n  auto padding = params->padding;\n  int out_width, out_height;\n  TF_LITE_ENSURE(context, params->stride_height > 0);\n  TF_LITE_ENSURE(context, params->stride_width > 0);\n  data->padding = ComputePaddingHeightWidth(\n      params->stride_height, params->stride_width, 1, 1, height, width,\n      params->filter_height, params->filter_width, padding, &out_height,\n      &out_width);\n  if (input->type == kTfLiteUInt8 || input->type == kTfLiteInt8) {\n    if (pool_type == kAverage || pool_type == kMax) {\n      TFLITE_DCHECK_LE(std::abs(input->params.scale - output->params.scale),\n                       1.0e-6);\n      TFLITE_DCHECK_EQ(input->params.zero_point, output->params.zero_point);\n    }\n    if (pool_type == kL2) {\n      TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteFloat32);\n    }\n  }\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(4);\n  output_size->data[0] = batches;\n  output_size->data[1] = out_height;\n  output_size->data[2] = out_width;\n  output_size->data[3] = channels_out;\n  return context->ResizeTensor(context, output, output_size);\n}", "target": 0}
{"code": "static void setup_test_dir(char *tmp_dir, const char *files, ...) {\n        va_list ap;\n        assert_se(mkdtemp(tmp_dir) != NULL);\n        va_start(ap, files);\n        while (files != NULL) {\n                _cleanup_free_ char *path = strappend(tmp_dir, files);\n                assert_se(touch_file(path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, 0) == 0);\n                files = va_arg(ap, const char *);\n        }\n        va_end(ap);\n}", "target": 1}
{"code": "static void ssl_reset_sock_state(pj_ssl_sock_t *ssock)\n{\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n    if (ossock->ossl_ssl) {\n\tSSL_set_ex_data(ossock->ossl_ssl, sslsock_idx, NULL);\n    }\n    if (ossock->ossl_ssl && SSL_in_init(ossock->ossl_ssl) == 0) {\n\tint ret = SSL_shutdown(ossock->ossl_ssl);\n\tif (ret == 0) {\n\t    flush_circ_buf_output(ssock, &ssock->shutdown_op_key, 0, 0);\n\t}\n    }\n    pj_lock_acquire(ssock->write_mutex);\n    ssock->ssl_state = SSL_STATE_NULL;\n    pj_lock_release(ssock->write_mutex);\n    ssl_close_sockets(ssock);\n    ERR_clear_error();\n}", "target": 0}
{"code": "void SecurityManager::notify_participant_authorized(\n        const ParticipantProxyData& participant_data)\n{\n    participant_->pdp()->notifyAboveRemoteEndpoints(participant_data);\n    EPROSIMA_LOG_INFO(SECURITY, \"Participant \" << participant_data.m_guid << \" authenticated\");\n    if (participant_->getListener() != nullptr)\n    {\n        ParticipantAuthenticationInfo info;\n        info.status = ParticipantAuthenticationInfo::AUTHORIZED_PARTICIPANT;\n        info.guid = participant_data.m_guid;\n        participant_->getListener()->onParticipantAuthentication(\n            participant_->getUserRTPSParticipant(), std::move(info));\n    }\n}", "target": 1}
{"code": "static void veth_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tdev->netdev_ops = &veth_netdev_ops;\n\tdev->ethtool_ops = &veth_ethtool_ops;\n\tdev->features |= NETIF_F_LLTX;\n\tdev->destructor = veth_dev_free;\n\tdev->hw_features = NETIF_F_NO_CSUM | NETIF_F_SG | NETIF_F_RXCSUM;\n}", "target": 0}
{"code": "iasecc_chv_verify(struct sc_card *card, struct sc_pin_cmd_data *pin_cmd,\n\t\tint *tries_left)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_acl_entry acl = pin_cmd->pin1.acls[IASECC_ACLS_CHV_VERIFY];\n\tstruct sc_apdu apdu;\n\tint rv;\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"Verify CHV PIN(ref:%i,len:%i,acl:%X:%X)\", pin_cmd->pin_reference, pin_cmd->pin1.len,\n\t\t\tacl.method, acl.key_ref);\n\tif (acl.method & IASECC_SCB_METHOD_SM)   {\n\t\trv = iasecc_sm_pin_verify(card, acl.key_ref, pin_cmd, tries_left);\n\t\tLOG_FUNC_RETURN(ctx, rv);\n\t}\n\tif (pin_cmd->pin1.data && !pin_cmd->pin1.len)   {\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_1, 0x20, 0, pin_cmd->pin_reference);\n\t}\n\telse if (pin_cmd->pin1.data && pin_cmd->pin1.len)   {\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x20, 0, pin_cmd->pin_reference);\n\t\tapdu.data = pin_cmd->pin1.data;\n\t\tapdu.datalen = pin_cmd->pin1.len;\n\t\tapdu.lc = pin_cmd->pin1.len;\n\t}\n\telse if ((card->reader->capabilities & SC_READER_CAP_PIN_PAD) && !pin_cmd->pin1.data && !pin_cmd->pin1.len)   {\n\t\trv = iasecc_chv_verify_pinpad(card, pin_cmd, tries_left);\n\t\tsc_log(ctx, \"Result of verifying CHV with PIN pad %i\", rv);\n\t\tLOG_FUNC_RETURN(ctx, rv);\n\t}\n\telse   {\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);\n\t}\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\tif (tries_left && apdu.sw1 == 0x63 && (apdu.sw2 & 0xF0) == 0xC0)\n\t\t*tries_left = apdu.sw2 & 0x0F;\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_FUNC_RETURN(ctx, rv);\n}", "target": 0}
{"code": "std::unique_ptr<cql_server::response> cql_server::connection::make_supported(int16_t stream, const tracing::trace_state_ptr& tr_state) const\n{\n    std::multimap<sstring, sstring> opts;\n    opts.insert({\"CQL_VERSION\", cql3::query_processor::CQL_VERSION});\n    opts.insert({\"COMPRESSION\", \"lz4\"});\n    opts.insert({\"COMPRESSION\", \"snappy\"});\n    if (_server._config.allow_shard_aware_drivers) {\n        opts.insert({\"SCYLLA_SHARD\", format(\"{:d}\", this_shard_id())});\n        opts.insert({\"SCYLLA_NR_SHARDS\", format(\"{:d}\", smp::count)});\n        opts.insert({\"SCYLLA_SHARDING_ALGORITHM\", dht::cpu_sharding_algorithm_name()});\n        if (_server._config.shard_aware_transport_port) {\n            opts.insert({\"SCYLLA_SHARD_AWARE_PORT\", format(\"{:d}\", *_server._config.shard_aware_transport_port)});\n        }\n        if (_server._config.shard_aware_transport_port_ssl) {\n            opts.insert({\"SCYLLA_SHARD_AWARE_PORT_SSL\", format(\"{:d}\", *_server._config.shard_aware_transport_port_ssl)});\n        }\n        opts.insert({\"SCYLLA_SHARDING_IGNORE_MSB\", format(\"{:d}\", _server._config.sharding_ignore_msb)});\n        opts.insert({\"SCYLLA_PARTITIONER\", _server._config.partitioner_name});\n    }\n    for (cql_protocol_extension ext : supported_cql_protocol_extensions()) {\n        const sstring ext_key_name = protocol_extension_name(ext);\n        std::vector<sstring> params = additional_options_for_proto_ext(ext);\n        if (params.empty()) {\n            opts.emplace(ext_key_name, \"\");\n        } else {\n            for (sstring val : params) {\n                opts.emplace(ext_key_name, std::move(val));\n            }\n        }\n    }\n    auto response = std::make_unique<cql_server::response>(stream, cql_binary_opcode::SUPPORTED, tr_state);\n    response->write_string_multimap(std::move(opts));\n    return response;\n}", "target": 0}
{"code": "CACHE_BITMAP_V2_ORDER* copy_cache_bitmap_v2_order(rdpContext* context,\n                                                  const CACHE_BITMAP_V2_ORDER* order)\n{\n\tCACHE_BITMAP_V2_ORDER* dst = calloc(1, sizeof(CACHE_BITMAP_V2_ORDER));\n\tif (!dst || !order)\n\t\tgoto fail;\n\t*dst = *order;\n\tif (order->bitmapLength > 0)\n\t{\n\t\tdst->bitmapDataStream = malloc(order->bitmapLength);\n\t\tif (!dst->bitmapDataStream)\n\t\t\tgoto fail;\n\t\tmemcpy(dst->bitmapDataStream, order->bitmapDataStream, order->bitmapLength);\n\t}\n\treturn dst;\nfail:\n\tfree_cache_bitmap_v2_order(context, dst);\n\treturn NULL;\n}", "target": 0}
{"code": "ServerSecurityFeature::ServerSecurityFeature(\n    application_features::ApplicationServer& server)\n    : ApplicationFeature(server, \"ServerSecurity\"),\n      _enableFoxxApi(true),\n      _enableFoxxStore(true),\n      _hardenedRestApi(false) {\n  setOptional(false);\n  startsAfter<application_features::GreetingsFeaturePhase>();\n}", "target": 1}
{"code": "static int __init net_secret_init(void)\n{\n\tget_random_bytes(net_secret, sizeof(net_secret));\n\treturn 0;\n}", "target": 0}
{"code": "static int changedline (const Proto *p, int oldpc, int newpc) {\n  while (oldpc++ < newpc) {\n    if (p->lineinfo[oldpc] != 0)\n      return (luaG_getfuncline(p, oldpc - 1) != luaG_getfuncline(p, newpc));\n  }\n  return 0;  \n}", "target": 1}
{"code": "void btrfs_assign_next_active_device(struct btrfs_device *device,\n\t\t\t\t     struct btrfs_device *this_dev)\n{\n\tstruct btrfs_fs_info *fs_info = device->fs_info;\n\tstruct btrfs_device *next_device;\n\tif (this_dev)\n\t\tnext_device = this_dev;\n\telse\n\t\tnext_device = btrfs_find_next_active_device(fs_info->fs_devices,\n\t\t\t\t\t\t\t\tdevice);\n\tASSERT(next_device);\n\tif (fs_info->sb->s_bdev &&\n\t\t\t(fs_info->sb->s_bdev == device->bdev))\n\t\tfs_info->sb->s_bdev = next_device->bdev;\n\tif (fs_info->fs_devices->latest_bdev == device->bdev)\n\t\tfs_info->fs_devices->latest_bdev = next_device->bdev;\n}", "target": 0}
{"code": "static int stv06xx_isoc_nego(struct gspca_dev *gspca_dev)\n{\n\tint ret, packet_size, min_packet_size;\n\tstruct usb_host_interface *alt;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\talt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\tmin_packet_size = sd->sensor->min_packet_size[gspca_dev->curr_mode];\n\tif (packet_size <= min_packet_size)\n\t\treturn -EIO;\n\tpacket_size -= 100;\n\tif (packet_size < min_packet_size)\n\t\tpacket_size = min_packet_size;\n\talt->endpoint[0].desc.wMaxPacketSize = cpu_to_le16(packet_size);\n\tret = usb_set_interface(gspca_dev->dev, gspca_dev->iface, 1);\n\tif (ret < 0)\n\t\tgspca_err(gspca_dev, \"set alt 1 err %d\\n\", ret);\n\treturn ret;\n}", "target": 0}
{"code": "TfLiteStatus PrepareHashtableFind(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 3);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputResourceIdTensor);\n  TF_LITE_ENSURE_EQ(context, input_resource_id_tensor->type, kTfLiteInt32);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input_resource_id_tensor), 1);\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(input_resource_id_tensor, 0), 1);\n  const TfLiteTensor* default_value_tensor =\n      GetInput(context, node, kDefaultValueTensor);\n  const TfLiteTensor* key_tensor = GetInput(context, node, kKeyTensor);\n  TfLiteTensor* output_tensor = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE_EQ(context, default_value_tensor->type, output_tensor->type);\n  TF_LITE_ENSURE(context, (key_tensor->type == kTfLiteInt64 &&\n                           output_tensor->type == kTfLiteString) ||\n                              (key_tensor->type == kTfLiteString &&\n                               output_tensor->type == kTfLiteInt64));\n  return context->ResizeTensor(context, output_tensor,\n                               TfLiteIntArrayCopy(key_tensor->dims));\n}", "target": 1}
{"code": "static int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)\n{\n\tstruct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\treturn aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);\n}", "target": 0}
{"code": "void dhcps_deinit(void)\n{\n\tif (dhcps_pcb != NULL) {\n\t\tudp_remove(dhcps_pcb);\n\t\tdhcps_pcb = NULL;\t\n\t}\n\tif (dhcps_ip_table_semaphore != NULL) {\t\n\t\tvSemaphoreDelete(dhcps_ip_table_semaphore);\n\t\tdhcps_ip_table_semaphore = NULL;\n\t}\t\t\n}", "target": 1}
{"code": "free_link_refs(struct link_ref **references)\n{\n\tsize_t i;\n\tfor (i = 0; i < REF_TABLE_SIZE; ++i) {\n\t\tstruct link_ref *r = references[i];\n\t\tstruct link_ref *next;\n\t\twhile (r) {\n\t\t\tnext = r->next;\n\t\t\tbufrelease(r->label);\n\t\t\tbufrelease(r->link);\n\t\t\tbufrelease(r->title);\n\t\t\tfree(r);\n\t\t\tr = next;\n\t\t}\n\t}\n}", "target": 0}
{"code": "date_s_jisx0301(int argc, VALUE *argv, VALUE klass)\n{\n    VALUE str, sg, opt;\n    rb_scan_args(argc, argv, \"02:\", &str, &sg, &opt);\n    if (!NIL_P(opt)) argc--;\n    switch (argc) {\n      case 0:\n\tstr = rb_str_new2(\"-4712-01-01\");\n      case 1:\n\tsg = INT2FIX(DEFAULT_SG);\n    }\n    {\n        int argc2 = 1;\n        VALUE argv2[2];\n        argv2[0] = str;\n        if (!NIL_P(opt)) argv2[argc2++] = opt;\n\tVALUE hash = date_s__jisx0301(argc2, argv2, klass);\n\treturn d_new_by_frags(klass, hash, sg);\n    }\n}", "target": 0}
{"code": "static int read_tfra(MOVContext *mov, AVIOContext *f)\n{\n    MOVFragmentIndex* index = NULL;\n    int version, fieldlength, i, j;\n    int64_t pos = avio_tell(f);\n    uint32_t size = avio_rb32(f);\n    void *tmp;\n    if (avio_rb32(f) != MKBETAG('t', 'f', 'r', 'a')) {\n        return 1;\n    }\n    av_log(mov->fc, AV_LOG_VERBOSE, \"found tfra\\n\");\n    index = av_mallocz(sizeof(MOVFragmentIndex));\n    if (!index) {\n        return AVERROR(ENOMEM);\n    }\n    tmp = av_realloc_array(mov->fragment_index_data,\n                           mov->fragment_index_count + 1,\n                           sizeof(MOVFragmentIndex*));\n    if (!tmp) {\n        av_freep(&index);\n        return AVERROR(ENOMEM);\n    }\n    mov->fragment_index_data = tmp;\n    mov->fragment_index_data[mov->fragment_index_count++] = index;\n    version = avio_r8(f);\n    avio_rb24(f);\n    index->track_id = avio_rb32(f);\n    fieldlength = avio_rb32(f);\n    index->item_count = avio_rb32(f);\n    index->items = av_mallocz_array(\n            index->item_count, sizeof(MOVFragmentIndexItem));\n    if (!index->items) {\n        index->item_count = 0;\n        return AVERROR(ENOMEM);\n    }\n    for (i = 0; i < index->item_count; i++) {\n        int64_t time, offset;\n        if (avio_feof(f)) {\n            index->item_count = 0;\n            av_freep(&index->items);\n            return AVERROR_INVALIDDATA;\n        }\n        if (version == 1) {\n            time   = avio_rb64(f);\n            offset = avio_rb64(f);\n        } else {\n            time   = avio_rb32(f);\n            offset = avio_rb32(f);\n        }\n        index->items[i].time = time;\n        index->items[i].moof_offset = offset;\n        for (j = 0; j < ((fieldlength >> 4) & 3) + 1; j++)\n            avio_r8(f);\n        for (j = 0; j < ((fieldlength >> 2) & 3) + 1; j++)\n            avio_r8(f);\n        for (j = 0; j < ((fieldlength >> 0) & 3) + 1; j++)\n            avio_r8(f);\n    }\n    avio_seek(f, pos + size, SEEK_SET);\n    return 0;\n}", "target": 0}
{"code": "\t\tSetRunner(\n\t\t\tReferenceHandle& that,\n\t\t\tLocal<Value> key_handle,\n\t\t\tLocal<Value> val_handle,\n\t\t\tMaybeLocal<Object> maybe_options\n\t\t) :\n\t\t\t\tkey{ExternalCopy::CopyIfPrimitive(key_handle)},\n\t\t\t\tval{TransferOut(val_handle, TransferOptions{maybe_options})},\n\t\t\t\tcontext{that.context},\n\t\t\t\treference{that.reference} {\n\t\t\tthat.CheckDisposed();\n\t\t\tif (!key) {\n\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n\t\t\t}\n\t\t}", "target": 1}
{"code": "TfLiteStatus StoreAllDecodedSequences(\n    TfLiteContext* context,\n    const std::vector<std::vector<std::vector<int>>>& sequences,\n    TfLiteNode* node, int top_paths) {\n  const int32_t batch_size = sequences.size();\n  std::vector<int32_t> num_entries(top_paths, 0);\n  for (const auto& batch_s : sequences) {\n    TF_LITE_ENSURE_EQ(context, batch_s.size(), top_paths);\n    for (int p = 0; p < top_paths; ++p) {\n      num_entries[p] += batch_s[p].size();\n    }\n  }\n  for (int p = 0; p < top_paths; ++p) {\n    const int32_t p_num = num_entries[p];\n    TfLiteTensor* indices = GetOutput(context, node, p);\n    TF_LITE_ENSURE_OK(context, Resize(context, {p_num, 2}, indices));\n    TfLiteTensor* values = GetOutput(context, node, p + top_paths);\n    TF_LITE_ENSURE_OK(context, Resize(context, {p_num}, values));\n    TfLiteTensor* decoded_shape = GetOutput(context, node, p + 2 * top_paths);\n    TF_LITE_ENSURE_OK(context, Resize(context, {2}, decoded_shape));\n    int32_t max_decoded = 0;\n    int32_t offset = 0;\n    int32_t* indices_data = GetTensorData<int32_t>(indices);\n    int32_t* values_data = GetTensorData<int32_t>(values);\n    int32_t* decoded_shape_data = GetTensorData<int32_t>(decoded_shape);\n    for (int b = 0; b < batch_size; ++b) {\n      auto& p_batch = sequences[b][p];\n      int32_t num_decoded = p_batch.size();\n      max_decoded = std::max(max_decoded, num_decoded);\n      std::copy_n(p_batch.begin(), num_decoded, values_data + offset);\n      for (int32_t t = 0; t < num_decoded; ++t, ++offset) {\n        indices_data[offset * 2] = b;\n        indices_data[offset * 2 + 1] = t;\n      }\n    }\n    decoded_shape_data[0] = batch_size;\n    decoded_shape_data[1] = max_decoded;\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "xfs_attr3_leaf_clearflag(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen;\n\tchar *name;\n#endif \n\ttrace_xfs_attr_leaf_clearflag(args);\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn(error);\n\tleaf = bp->b_addr;\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tASSERT(entry->flags & XFS_ATTR_INCOMPLETE);\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index < ichdr.count);\n\tASSERT(args->index >= 0);\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tnamelen = name_loc->namelen;\n\t\tname = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tnamelen = name_rmt->namelen;\n\t\tname = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry->hashval) == args->hashval);\n\tASSERT(namelen == args->namelen);\n\tASSERT(memcmp(name, args->name, namelen) == 0);\n#endif \n\tentry->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\tif (args->rmtblkno) {\n\t\tASSERT((entry->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->valuelen);\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n\t}\n\treturn xfs_trans_roll(&args->trans, args->dp);\n}", "target": 0}
{"code": "Status ShapeRefiner::InferShapesForFunctionSubNode(\n    const Node* node, InferenceContext* outer_context) {\n  TF_RETURN_IF_ERROR(AddNodeInternal(node, outer_context));\n  InferenceContext* node_context = CHECK_NOTNULL(GetContext(node));\n  if (StringPiece(node->type_string()) == kArgOp) {\n    int index;\n    TF_RETURN_IF_ERROR(GetNodeAttr(AttrSlice(node->def()), \"index\", &index));\n    if (index < 0 || outer_context->num_inputs() <= index) {\n      return errors::Internal(\n          \"Function instantiation included invalid input index: \", index,\n          \" not in [0, \", outer_context->num_inputs(), \").\");\n    }\n    if (outer_context->input(index).SameHandle(ShapeHandle())) {\n      VLOG(1) << \"Function instantiation has undefined input shape at \"\n              << \"index: \" << index << \" in the outer inference context.\";\n      node_context->set_output(0, node_context->UnknownShape());\n    } else {\n      node_context->set_output(0, outer_context->input(index));\n    }\n    auto* resource = outer_context->input_handle_shapes_and_types(index);\n    if (resource) {\n      node_context->set_output_handle_shapes_and_types(0, *resource);\n    }\n  } else if (StringPiece(node->type_string()) == kRetvalOp) {\n    int index;\n    TF_RETURN_IF_ERROR(GetNodeAttr(AttrSlice(node->def()), \"index\", &index));\n    if (index < 0 || outer_context->num_outputs() <= index) {\n      return errors::Internal(\n          \"Function instantiation included invalid output index: \", index,\n          \" not in [0, \", outer_context->num_outputs(), \").\");\n    }\n    ShapeHandle handle;\n    TensorShapeProto proto;\n    node_context->ShapeHandleToProto(node_context->input(0), &proto);\n    TF_RETURN_IF_ERROR(outer_context->MakeShapeFromShapeProto(proto, &handle));\n    outer_context->set_output(index, handle);\n    auto* resource = node_context->input_handle_shapes_and_types(0);\n    if (resource) {\n      outer_context->set_output_handle_shapes_and_types(index, *resource);\n    }\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "BufferedRandomDevice::BufferedRandomDevice(size_t bufferSize)\n  : bufferSize_(bufferSize),\n    buffer_(new unsigned char[bufferSize]),\n    ptr_(buffer_.get() + bufferSize) {  \n  call_once(flag, [this]() {\n    detail::AtFork::registerHandler(\n        this,\n         []() { return true; },\n         []() {},\n        []() {\n          using Single = SingletonThreadLocal<BufferedRandomDevice, RandomTag>;\n          auto& t = Single::get();\n          t.ptr_ = t.buffer_.get() + t.bufferSize_;\n        });\n  });\n}", "target": 0}
{"code": "im_vips2dz( IMAGE *in, const char *filename )\n{\n\tchar *p, *q;\n\tchar name[FILENAME_MAX];\n\tchar mode[FILENAME_MAX];\n\tchar buf[FILENAME_MAX];\n\tint i;\n\tVipsForeignDzLayout layout = VIPS_FOREIGN_DZ_LAYOUT_DZ; \n\tchar *suffix = \".jpeg\";\n\tint overlap = 0;\n\tint tile_size = 256;\n\tVipsForeignDzDepth depth = VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL; \n\tgboolean centre = FALSE;\n\tVipsAngle angle = VIPS_ANGLE_D0; \n\tim_strncpy( name, filename, FILENAME_MAX ); \n\tif( (p = strchr( name, ':' )) ) {\n\t\t*p = '\\0';\n\t\tim_strncpy( mode, p + 1, FILENAME_MAX ); \n\t}\n\telse \n\t\tstrcpy( mode, \"\" ); \n\tstrcpy( buf, mode ); \n\tp = &buf[0];\n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( (i = vips_enum_from_nick( \"im_vips2dz\", \n\t\t\tVIPS_TYPE_FOREIGN_DZ_LAYOUT, q )) < 0 ) \n\t\t\treturn( -1 );\n\t\tlayout = i;\n\t}\n\tif( (q = im_getnextoption( &p )) ) \n\t\tsuffix = g_strdup( q );\n\tif( (q = im_getnextoption( &p )) ) \n\t\toverlap = atoi( q ); \n\tif( (q = im_getnextoption( &p )) ) \n\t\ttile_size = atoi( q ); \n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( (i = vips_enum_from_nick( \"im_vips2dz\", \n\t\t\tVIPS_TYPE_FOREIGN_DZ_DEPTH, q )) < 0 )\n\t\t\treturn( -1 );\n\t\tdepth = i;\n\t}\n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( im_isprefix( \"cen\", q ) ) \n\t\t\tcentre = TRUE;\n\t}\n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( (i = vips_enum_from_nick( \"im_vips2dz\", \n\t\t\tVIPS_TYPE_ANGLE, q )) < 0 )\n\t\t\treturn( -1 );\n\t\tangle = i;\n\t}\n\tif( vips_dzsave( in, name,\n\t\t\"layout\", layout,\n\t\t\"suffix\", suffix,\n\t\t\"overlap\", overlap,\n\t\t\"tile_size\", tile_size,\n\t\t\"depth\", depth,\n\t\t\"centre\", centre,\n\t\t\"angle\", angle,\n\t\tNULL ) )\n\t\treturn( -1 );\n\treturn( 0 );\n}", "target": 0}
{"code": "void bio_advance(struct bio *bio, unsigned bytes)\n{\n\tif (bio_integrity(bio))\n\t\tbio_integrity_advance(bio, bytes);\n\tbio_advance_iter(bio, &bio->bi_iter, bytes);\n}", "target": 0}
{"code": "static void pptp_ctx_switch(struct triton_context_t *ctx, void *arg)\n{\n\tif (arg) {\n\t\tstruct ap_session *s = arg;\n\t\tnet = s->net;\n\t} else\n\t\tnet = def_net;\n\tlog_switch(ctx, arg);\n}", "target": 0}
{"code": "    inline bool match(const EndpointSecurityAttributesMask remoteMask,\n        const PluginEndpointSecurityAttributesMask remotePluginMask) const\n    {\n        return security_mask_matches(mask(), remoteMask) &&\n            security_mask_matches(plugin_endpoint_attributes, remotePluginMask);\n    }", "target": 1}
{"code": "static int compat_setdrvprm(int drive,\n\t\t\t    struct compat_floppy_drive_params __user *arg)\n{\n\tstruct compat_floppy_drive_params v;\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (copy_from_user(&v, arg, sizeof(struct compat_floppy_drive_params)))\n\t\treturn -EFAULT;\n\tmutex_lock(&floppy_mutex);\n\tUDP->cmos = v.cmos;\n\tUDP->max_dtr = v.max_dtr;\n\tUDP->hlt = v.hlt;\n\tUDP->hut = v.hut;\n\tUDP->srt = v.srt;\n\tUDP->spinup = v.spinup;\n\tUDP->spindown = v.spindown;\n\tUDP->spindown_offset = v.spindown_offset;\n\tUDP->select_delay = v.select_delay;\n\tUDP->rps = v.rps;\n\tUDP->tracks = v.tracks;\n\tUDP->timeout = v.timeout;\n\tUDP->interleave_sect = v.interleave_sect;\n\tUDP->max_errors = v.max_errors;\n\tUDP->flags = v.flags;\n\tUDP->read_track = v.read_track;\n\tmemcpy(UDP->autodetect, v.autodetect, sizeof(v.autodetect));\n\tUDP->checkfreq = v.checkfreq;\n\tUDP->native_format = v.native_format;\n\tmutex_unlock(&floppy_mutex);\n\treturn 0;\n}", "target": 0}
{"code": "void generic_pipe_buf_get(struct pipe_inode_info *pipe, struct pipe_buffer *buf)\n{\n\tget_page(buf->page);\n}", "target": 1}
{"code": "hash_link_ref(const uint8_t *link_ref, size_t length)\n{\n\tsize_t i;\n\tunsigned int hash = 0;\n\tfor (i = 0; i < length; ++i)\n\t\thash = tolower(link_ref[i]) + (hash << 6) + (hash << 16) - hash;\n\treturn hash;\n}", "target": 1}
{"code": "static uint8_t search_next_ip(void)\n{       \n\tuint8_t range_count, offset_count;\n\tuint8_t start, end;\n\tuint8_t max_count;\n\tif(dhcps_addr_pool_set){\n#if LWIP_VERSION_MAJOR >= 2\n\t\tstart = (uint8_t)ip4_addr4(ip_2_ip4(&dhcps_addr_pool_start));\n\t\tend = (uint8_t)ip4_addr4(ip_2_ip4(&dhcps_addr_pool_end));\n#else\n\t\tstart = (uint8_t)ip4_addr4(&dhcps_addr_pool_start);\n\t\tend = (uint8_t)ip4_addr4(&dhcps_addr_pool_end);\n#endif\n\t}else{\n\t\tstart = 0;\n\t\tend = 255;\n\t}\n\txSemaphoreTake(dhcps_ip_table_semaphore, portMAX_DELAY);\n\tfor (range_count = 0; range_count < (max_count = 8); range_count++) {\n\t\tfor (offset_count = 0;offset_count < 32; offset_count++) {\n\t\t\tif ((((ip_table.ip_range[range_count] >> offset_count) & 0x01) == 0) \n\t\t\t\t&&(((range_count * 32) + (offset_count + 1)) >= start)\n\t\t\t\t&&(((range_count * 32) + (offset_count + 1)) <= end)) {\n\t\t\t\txSemaphoreGive(dhcps_ip_table_semaphore); \n\t\t\t\treturn ((range_count * 32) + (offset_count + 1));\n\t\t\t}\n\t\t}\n\t}\n\txSemaphoreGive(dhcps_ip_table_semaphore); \n\treturn 0;\n}", "target": 0}
{"code": "date_s_rfc3339(int argc, VALUE *argv, VALUE klass)\n{\n    VALUE str, sg, opt;\n    rb_scan_args(argc, argv, \"02:\", &str, &sg, &opt);\n    if (!NIL_P(opt)) argc--;\n    switch (argc) {\n      case 0:\n\tstr = rb_str_new2(\"-4712-01-01T00:00:00+00:00\");\n      case 1:\n\tsg = INT2FIX(DEFAULT_SG);\n    }\n    {\n        int argc2 = 1;\n        VALUE argv2[2];\n        argv2[0] = str;\n        if (!NIL_P(opt)) argv2[argc2++] = opt;\n\tVALUE hash = date_s__rfc3339(argc2, argv2, klass);\n\treturn d_new_by_frags(klass, hash, sg);\n    }\n}", "target": 0}
{"code": "struct bpf_prog *bpf_prog_get(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_prog *prog;\n\tprog = __bpf_prog_get(f);\n\tif (IS_ERR(prog))\n\t\treturn prog;\n\tatomic_inc(&prog->aux->refcnt);\n\tfdput(f);\n\treturn prog;\n}", "target": 1}
{"code": "static inline void *nvme_addr_to_cmb(NvmeCtrl *n, hwaddr addr)\n{\n    hwaddr base = n->params.legacy_cmb ? n->cmb.mem.addr : n->cmb.cba;\n    return &n->cmb.buf[addr - base];\n}", "target": 0}
{"code": "CallResult<bool> isConstructor(Runtime &runtime, Callable *callable) {\n  if (!callable) {\n    return false;\n  }\n  while (BoundFunction *b = dyn_vmcast<BoundFunction>(callable)) {\n    callable = b->getTarget(runtime);\n  }\n  if (auto *func = dyn_vmcast<JSFunction>(callable)) {\n    auto *cb = func->getCodeBlock(runtime);\n    cb->lazyCompile(runtime);\n    return !func->getCodeBlock(runtime)->getHeaderFlags().isCallProhibited(\n        true);\n  }\n  if (!vmisa<NativeFunction>(callable) || vmisa<NativeConstructor>(callable)) {\n    return true;\n  }\n  if (auto *cproxy = dyn_vmcast<JSCallableProxy>(callable)) {\n    return cproxy->isConstructor(runtime);\n  }\n  return false;\n}", "target": 1}
{"code": "static void urlParsePostBody(struct URL *url,\n                             const struct HttpConnection *http,\n                             const char *buf, int len) {\n  struct HashMap contentType;\n  initHashMap(&contentType, urlDestroyHashMapEntry, NULL);\n  const char *ctHeader     = getFromHashMap(&http->header, \"content-type\");\n  urlParseHeaderLine(&contentType, ctHeader, ctHeader ? strlen(ctHeader) : 0);\n  if (getRefFromHashMap(&contentType, \"application/x-www-form-urlencoded\")) {\n    urlParseQueryString(&url->args, buf, len);\n  } else if (getRefFromHashMap(&contentType, \"multipart/form-data\")) {\n    const char *boundary   = getFromHashMap(&contentType, \"boundary\");\n    if (boundary && *boundary) {\n      const char *lastPart = NULL;\n      for (const char *part = buf; len > 0; ) {\n        const char *ptr;\n        if ((part == buf && (ptr = urlMemstr(part, len, \"--\")) != NULL) ||\n            (ptr = urlMemstr(part, len, \"\\r\\n--\")) != NULL) {\n          len             -= ptr - part + (part == buf ? 2 : 4);\n          part             = ptr + (part == buf ? 2 : 4);\n          if (!urlMemcmp(part, len, boundary)) {\n            int i          = strlen(boundary);\n            len           -= i;\n            part          += i;\n            if (!urlMemcmp(part, len, \"\\r\\n\")) {\n              len         -= 2;\n              part        += 2;\n              if (lastPart) {\n                urlParsePart(url, lastPart, ptr - lastPart);\n              } else {\n                if (ptr != buf) {\n                  info(\"[http] Ignoring prologue before \\\"multipart/form-data\\\"!\");\n                }\n              }\n              lastPart     = part;\n            } else if (!urlMemcmp(part, len, \"--\\r\\n\")) {\n              len         -= 4;\n              part        += 4;\n              urlParsePart(url, lastPart, ptr - lastPart);\n              lastPart     = NULL;\n              if (len > 0) {\n                info(\"[http] Ignoring epilogue past end of \\\"multipart/\"\n\t\t\t\t     \"form-data\\\"!\");\n              }\n            }\n          }\n        }\n        else {\n          warn (\"[http] Ignorning broken multipart/form-data\");\n          break;\n        }\n      }\n      if (lastPart) {\n        warn(\"[http] Missing final \\\"boundary\\\" for \\\"multipart/form-data\\\"!\");\n      }\n    } else {\n      warn(\"[http] Missing \\\"boundary\\\" information for \\\"multipart/form-data\\\"!\");\n    }\n  }\n  destroyHashMap(&contentType);\n}", "target": 0}
{"code": "const TfLiteTensor* GetOptionalInputTensor(const TfLiteContext* context,\n                                           const TfLiteNode* node, int index) {\n  const bool use_tensor = index < node->inputs->size &&\n                          node->inputs->data[index] != kTfLiteOptionalTensor;\n  if (use_tensor) {\n    return GetMutableInput(context, node, index);\n  }\n  return nullptr;\n}", "target": 1}
{"code": "\t__releases(&keyring_serialise_link_sem)\n{\n\tBUG_ON(index_key->type == NULL);\n\tkenter(\"%d,%s,\", keyring->serial, index_key->type->name);\n\tif (index_key->type == &key_type_keyring)\n\t\tup_write(&keyring_serialise_link_sem);\n\tif (edit && !edit->dead_leaf) {\n\t\tkey_payload_reserve(keyring,\n\t\t\t\t    keyring->datalen - KEYQUOTA_LINK_BYTES);\n\t\tassoc_array_cancel_edit(edit);\n\t}\n\tup_write(&keyring->sem);\n}", "target": 1}
{"code": "ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,\n               const char **elem_rtrn, const char **field_rtrn,\n               ExprDef **index_rtrn)\n{\n    switch (expr->expr.op) {\n    case EXPR_IDENT:\n        *elem_rtrn = NULL;\n        *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);\n        *index_rtrn = NULL;\n        return true;\n    case EXPR_FIELD_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);\n        *index_rtrn = NULL;\n        return true;\n    case EXPR_ARRAY_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);\n        *index_rtrn = expr->array_ref.entry;\n        return true;\n    default:\n        break;\n    }\n    log_wsgo(ctx, \"Unexpected operator %d in ResolveLhs\\n\", expr->expr.op);\n    return false;\n}", "target": 1}
{"code": "ble_hs_conn_timer(void)\n{\n#if MYNEWT_VAL(BLE_L2CAP_RX_FRAG_TIMEOUT) == 0 && \\\n    BLE_HS_ATT_SVR_QUEUED_WRITE_TMO == 0\n    return BLE_HS_FOREVER;\n#endif\n    struct ble_hs_conn *conn;\n    ble_npl_time_t now;\n    int32_t next_exp_in;\n    int32_t time_diff;\n    uint16_t conn_handle;\n    for (;;) {\n        conn_handle = BLE_HS_CONN_HANDLE_NONE;\n        next_exp_in = BLE_HS_FOREVER;\n        now = ble_npl_time_get();\n        ble_hs_lock();\n        SLIST_FOREACH(conn, &ble_hs_conns, bhc_next) {\n            if (!(conn->bhc_flags & BLE_HS_CONN_F_TERMINATING)) {\n#if MYNEWT_VAL(BLE_L2CAP_RX_FRAG_TIMEOUT) != 0\n                if (conn->bhc_rx_chan != NULL) {\n                    time_diff = conn->bhc_rx_timeout - now;\n                    if (time_diff <= 0) {\n                        conn_handle = conn->bhc_handle;\n                        break;\n                    }\n                    if (time_diff < next_exp_in) {\n                        next_exp_in = time_diff;\n                    }\n                }\n#endif\n#if BLE_HS_ATT_SVR_QUEUED_WRITE_TMO\n                time_diff = ble_att_svr_ticks_until_tmo(&conn->bhc_att_svr, now);\n                if (time_diff <= 0) {\n                    conn_handle = conn->bhc_handle;\n                    break;\n                }\n                if (time_diff < next_exp_in) {\n                    next_exp_in = time_diff;\n                }\n#endif\n            }\n        }\n        ble_hs_unlock();\n        if (conn_handle != BLE_HS_CONN_HANDLE_NONE) {\n            ble_gap_terminate(conn_handle, BLE_ERR_REM_USER_CONN_TERM);\n            continue;\n        }\n        return next_exp_in;\n    }\n}", "target": 1}
{"code": "static ssize_t nr_hugepages_show_common(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct hstate *h;\n\tunsigned long nr_huge_pages;\n\tint nid;\n\th = kobj_to_hstate(kobj, &nid);\n\tif (nid == NUMA_NO_NODE)\n\t\tnr_huge_pages = h->nr_huge_pages;\n\telse\n\t\tnr_huge_pages = h->nr_huge_pages_node[nid];\n\treturn sysfs_emit(buf, \"%lu\\n\", nr_huge_pages);\n}", "target": 0}
{"code": "Curves16Data* CurvesAlloc(cmsContext ContextID, int nCurves, int nElements, cmsToneCurve** G)\n{\n    int i, j;\n    Curves16Data* c16;\n    c16 = _cmsMallocZero(ContextID, sizeof(Curves16Data));\n    if (c16 == NULL) return NULL;\n    c16 ->nCurves = nCurves;\n    c16 ->nElements = nElements;\n    c16 ->Curves = _cmsCalloc(ContextID, nCurves, sizeof(cmsUInt16Number*));\n    if (c16 ->Curves == NULL) return NULL;\n    for (i=0; i < nCurves; i++) {\n        c16->Curves[i] = _cmsCalloc(ContextID, nElements, sizeof(cmsUInt16Number));\n        if (c16->Curves[i] == NULL) {\n            for (j=0; j < i; j++) {\n                _cmsFree(ContextID, c16->Curves[j]);\n            }\n            _cmsFree(ContextID, c16->Curves);\n            _cmsFree(ContextID, c16);\n            return NULL;\n        }\n        if (nElements == 256) {\n            for (j=0; j < nElements; j++) {\n                c16 ->Curves[i][j] = cmsEvalToneCurve16(G[i], FROM_8_TO_16(j));\n            }\n        }\n        else {\n            for (j=0; j < nElements; j++) {\n                c16 ->Curves[i][j] = cmsEvalToneCurve16(G[i], (cmsUInt16Number) j);\n            }\n        }\n    }\n    return c16;\n}", "target": 0}
{"code": "static void ext4_journal_commit_callback(journal_t *journal, transaction_t *txn)\n{\n\tstruct super_block\t\t*sb = journal->j_private;\n\tstruct ext4_sb_info\t\t*sbi = EXT4_SB(sb);\n\tint\t\t\t\terror = is_journal_aborted(journal);\n\tstruct ext4_journal_cb_entry\t*jce, *tmp;\n\tspin_lock(&sbi->s_md_lock);\n\tlist_for_each_entry_safe(jce, tmp, &txn->t_private_list, jce_list) {\n\t\tlist_del_init(&jce->jce_list);\n\t\tspin_unlock(&sbi->s_md_lock);\n\t\tjce->jce_func(sb, jce, error);\n\t\tspin_lock(&sbi->s_md_lock);\n\t}\n\tspin_unlock(&sbi->s_md_lock);\n}", "target": 0}
{"code": "  static TfLiteRegistration DynamicCopyOpRegistration() {\n    TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n    reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n      TfLiteTensor* output0 = GetOutput(context, node, 0);\n      SetTensorToDynamic(output0);\n      const TfLiteTensor* input = GetInput(context, node, 0);\n      TfLiteTensor* output1 = GetOutput(context, node, 1);\n      TF_LITE_ENSURE_STATUS(context->ResizeTensor(\n          context, output1, TfLiteIntArrayCopy(input->dims)));\n      return kTfLiteOk;\n    };\n    reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n      return kTfLiteOk;\n    };\n    return reg;\n  }", "target": 1}
{"code": "int ext4_change_inode_journal_flag(struct inode *inode, int val)\n{\n\tjournal_t *journal;\n\thandle_t *handle;\n\tint err;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tjournal = EXT4_JOURNAL(inode);\n\tif (!journal)\n\t\treturn 0;\n\tif (is_journal_aborted(journal))\n\t\treturn -EROFS;\n\tinode_dio_wait(inode);\n\tif (val) {\n\t\tdown_write(&EXT4_I(inode)->i_mmap_sem);\n\t\terr = filemap_write_and_wait(inode->i_mapping);\n\t\tif (err < 0) {\n\t\t\tup_write(&EXT4_I(inode)->i_mmap_sem);\n\t\t\treturn err;\n\t\t}\n\t}\n\tpercpu_down_write(&sbi->s_journal_flag_rwsem);\n\tjbd2_journal_lock_updates(journal);\n\tif (val)\n\t\text4_set_inode_flag(inode, EXT4_INODE_JOURNAL_DATA);\n\telse {\n\t\terr = jbd2_journal_flush(journal);\n\t\tif (err < 0) {\n\t\t\tjbd2_journal_unlock_updates(journal);\n\t\t\tpercpu_up_write(&sbi->s_journal_flag_rwsem);\n\t\t\treturn err;\n\t\t}\n\t\text4_clear_inode_flag(inode, EXT4_INODE_JOURNAL_DATA);\n\t}\n\text4_set_aops(inode);\n\tjbd2_journal_unlock_updates(journal);\n\tpercpu_up_write(&sbi->s_journal_flag_rwsem);\n\tif (val)\n\t\tup_write(&EXT4_I(inode)->i_mmap_sem);\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\terr = ext4_mark_inode_dirty(handle, inode);\n\text4_handle_sync(handle);\n\text4_journal_stop(handle);\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n}", "target": 0}
{"code": "av_cold int ff_vc2enc_init_transforms(VC2TransformContext *s, int p_width, int p_height)\n{\n    s->vc2_subband_dwt[VC2_TRANSFORM_9_7]    = vc2_subband_dwt_97;\n    s->vc2_subband_dwt[VC2_TRANSFORM_5_3]    = vc2_subband_dwt_53;\n    s->buffer = av_malloc(2*p_width*p_height*sizeof(dwtcoef));\n    if (!s->buffer)\n        return 1;\n    return 0;\n}", "target": 1}
{"code": "void lzxd_free(struct lzxd_stream *lzx) {\n  struct mspack_system *sys;\n  if (lzx) {\n    sys = lzx->sys;\n    sys->free(lzx->inbuf);\n    sys->free(lzx->window);\n    sys->free(lzx);\n  }\n}", "target": 1}
{"code": "static struct dentry *aio_mount(struct file_system_type *fs_type,\n\t\t\t\tint flags, const char *dev_name, void *data)\n{\n\tstatic const struct dentry_operations ops = {\n\t\t.d_dname\t= simple_dname,\n\t};\n\treturn mount_pseudo(fs_type, \"aio:\", NULL, &ops, AIO_RING_MAGIC);\n}", "target": 1}
{"code": "int nbd_init(int fd, QIOChannelSocket *sioc, uint16_t flags, off_t size)\n{\n    unsigned long sectors = size / BDRV_SECTOR_SIZE;\n    if (size / BDRV_SECTOR_SIZE != sectors) {\n        LOG(\"Export size %lld too large for 32-bit kernel\", (long long) size);\n        return -E2BIG;\n    }\n    TRACE(\"Setting NBD socket\");\n    if (ioctl(fd, NBD_SET_SOCK, (unsigned long) sioc->fd) < 0) {\n        int serrno = errno;\n        LOG(\"Failed to set NBD socket\");\n        return -serrno;\n    }\n    TRACE(\"Setting block size to %lu\", (unsigned long)BDRV_SECTOR_SIZE);\n    if (ioctl(fd, NBD_SET_BLKSIZE, (unsigned long)BDRV_SECTOR_SIZE) < 0) {\n        int serrno = errno;\n        LOG(\"Failed setting NBD block size\");\n        return -serrno;\n    }\n    TRACE(\"Setting size to %lu block(s)\", sectors);\n    if (size % BDRV_SECTOR_SIZE) {\n        TRACE(\"Ignoring trailing %d bytes of export\",\n              (int) (size % BDRV_SECTOR_SIZE));\n    }\n    if (ioctl(fd, NBD_SET_SIZE_BLOCKS, sectors) < 0) {\n        int serrno = errno;\n        LOG(\"Failed setting size (in blocks)\");\n        return -serrno;\n    }\n    if (ioctl(fd, NBD_SET_FLAGS, (unsigned long) flags) < 0) {\n        if (errno == ENOTTY) {\n            int read_only = (flags & NBD_FLAG_READ_ONLY) != 0;\n            TRACE(\"Setting readonly attribute\");\n            if (ioctl(fd, BLKROSET, (unsigned long) &read_only) < 0) {\n                int serrno = errno;\n                LOG(\"Failed setting read-only attribute\");\n                return -serrno;\n            }\n        } else {\n            int serrno = errno;\n            LOG(\"Failed setting flags\");\n            return -serrno;\n        }\n    }\n    TRACE(\"Negotiation ended\");\n    return 0;\n}", "target": 0}
{"code": "static void rpc_init_task(struct rpc_task *task, const struct rpc_task_setup *task_setup_data)\n{\n\tmemset(task, 0, sizeof(*task));\n\tatomic_set(&task->tk_count, 1);\n\ttask->tk_flags  = task_setup_data->flags;\n\ttask->tk_ops = task_setup_data->callback_ops;\n\ttask->tk_calldata = task_setup_data->callback_data;\n\tINIT_LIST_HEAD(&task->tk_task);\n\ttask->tk_garb_retry = 2;\n\ttask->tk_cred_retry = 2;\n\ttask->tk_rebind_retry = 2;\n\ttask->tk_priority = task_setup_data->priority - RPC_PRIORITY_LOW;\n\ttask->tk_owner = current->tgid;\n\ttask->tk_workqueue = task_setup_data->workqueue;\n\tif (task->tk_ops->rpc_call_prepare != NULL)\n\t\ttask->tk_action = rpc_prepare_task;\n\ttask->tk_start = ktime_get();\n\tdprintk(\"RPC:       new task initialized, procpid %u\\n\",\n\t\t\t\ttask_pid_nr(current));\n}", "target": 0}
{"code": "integerify(void * B, size_t r)\n{\n  uint32_t * X = (uint32_t *)((uintptr_t)(B) + (2 * r - 1) * 64);\n  return (((uint64_t)(X[1]) << 32) + X[0]);\n}", "target": 1}
{"code": "void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick)\n{\n  const char *quote = \"`\\\"\\\\\";\n  if (!quote_backtick)\n    quote++;\n  char *pt = dest;\n  const char *s = src;\n  *pt++ = '\"';\n  dlen -= 2;\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      if (dlen < 2)\n        break;\n      dlen -= 2;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = '\\0';\n}", "target": 0}
{"code": "static void zipfileDequote(char *zIn){\n  char q = zIn[0];\n  if( q=='\"' || q=='\\'' || q=='`' || q=='[' ){\n    int iIn = 1;\n    int iOut = 0;\n    if( q=='[' ) q = ']';\n    while( ALWAYS(zIn[iIn]) ){\n      char c = zIn[iIn++];\n      if( c==q && zIn[iIn++]!=q ) break;\n      zIn[iOut++] = c;\n    }\n    zIn[iOut] = '\\0';\n  }\n}", "target": 0}
{"code": "u32 GetHintFormat(GF_TrackBox *trak)\n{\n\tGF_HintMediaHeaderBox *hmhd = (GF_HintMediaHeaderBox *)trak->Media->information->InfoHeader;\n\tif (hmhd->type != GF_ISOM_BOX_TYPE_HMHD)\n\t\treturn 0;\n\tif (!hmhd || !hmhd->subType) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t\tif (!hmhd) return a ? a->type : 0;\n\t\tif (a) hmhd->subType = a->type;\n\t\treturn hmhd->subType;\n\t}\n\treturn hmhd->subType;\n}", "target": 1}
{"code": "rb_reg_prepare_enc(VALUE re, VALUE str, int warn)\n{\n    rb_encoding *enc = 0;\n    int cr = str_coderange(str);\n    if (cr == ENC_CODERANGE_BROKEN) {\n        rb_raise(rb_eArgError,\n            \"invalid byte sequence in %s\",\n            rb_enc_name(rb_enc_get(str)));\n    }\n    rb_reg_check(re);\n    enc = rb_enc_get(str);\n    if (RREGEXP_PTR(re)->enc == enc) {\n    }\n    else if (cr == ENC_CODERANGE_7BIT &&\n\t    RREGEXP_PTR(re)->enc == rb_usascii_encoding()) {\n\tenc = RREGEXP_PTR(re)->enc;\n    }\n    else if (!rb_enc_asciicompat(enc)) {\n\treg_enc_error(re, str);\n    }\n    else if (rb_reg_fixed_encoding_p(re)) {\n        if ((!rb_enc_asciicompat(RREGEXP_PTR(re)->enc) ||\n\t     cr != ENC_CODERANGE_7BIT)) {\n\t    reg_enc_error(re, str);\n\t}\n\tenc = RREGEXP_PTR(re)->enc;\n    }\n    else if (warn && (RBASIC(re)->flags & REG_ENCODING_NONE) &&\n\tenc != rb_ascii8bit_encoding() &&\n\tcr != ENC_CODERANGE_7BIT) {\n\trb_warn(\"regexp match /.../n against to %s string\",\n\t\trb_enc_name(enc));\n    }\n    return enc;\n}", "target": 0}
{"code": "static int zerocopy_sg_from_iovec(struct sk_buff *skb, const struct iovec *from,\n\t\t\t\t  int offset, size_t count)\n{\n\tint len = iov_length(from, count) - offset;\n\tint copy = skb_headlen(skb);\n\tint size, offset1 = 0;\n\tint i = 0;\n\twhile (count && (offset >= from->iov_len)) {\n\t\toffset -= from->iov_len;\n\t\t++from;\n\t\t--count;\n\t}\n\twhile (count && (copy > 0)) {\n\t\tsize = min_t(unsigned int, copy, from->iov_len - offset);\n\t\tif (copy_from_user(skb->data + offset1, from->iov_base + offset,\n\t\t\t\t   size))\n\t\t\treturn -EFAULT;\n\t\tif (copy > size) {\n\t\t\t++from;\n\t\t\t--count;\n\t\t\toffset = 0;\n\t\t} else\n\t\t\toffset += size;\n\t\tcopy -= size;\n\t\toffset1 += size;\n\t}\n\tif (len == offset1)\n\t\treturn 0;\n\twhile (count--) {\n\t\tstruct page *page[MAX_SKB_FRAGS];\n\t\tint num_pages;\n\t\tunsigned long base;\n\t\tunsigned long truesize;\n\t\tlen = from->iov_len - offset;\n\t\tif (!len) {\n\t\t\toffset = 0;\n\t\t\t++from;\n\t\t\tcontinue;\n\t\t}\n\t\tbase = (unsigned long)from->iov_base + offset;\n\t\tsize = ((base & ~PAGE_MASK) + len + ~PAGE_MASK) >> PAGE_SHIFT;\n\t\tnum_pages = get_user_pages_fast(base, size, 0, &page[i]);\n\t\tif ((num_pages != size) ||\n\t\t    (num_pages > MAX_SKB_FRAGS - skb_shinfo(skb)->nr_frags)) {\n\t\t\tfor (i = 0; i < num_pages; i++)\n\t\t\t\tput_page(page[i]);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\ttruesize = size * PAGE_SIZE;\n\t\tskb->data_len += len;\n\t\tskb->len += len;\n\t\tskb->truesize += truesize;\n\t\tatomic_add(truesize, &skb->sk->sk_wmem_alloc);\n\t\twhile (len) {\n\t\t\tint off = base & ~PAGE_MASK;\n\t\t\tint size = min_t(int, len, PAGE_SIZE - off);\n\t\t\t__skb_fill_page_desc(skb, i, page[i], off, size);\n\t\t\tskb_shinfo(skb)->nr_frags++;\n\t\t\tbase += size;\n\t\t\tlen -= size;\n\t\t\ti++;\n\t\t}\n\t\toffset = 0;\n\t\t++from;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "PHP_FUNCTION(imagegammacorrect)\n{\n\tzval *IM;\n\tgdImagePtr im;\n\tint i;\n\tdouble input, output;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rdd\", &IM, &input, &output) == FAILURE) {\n\t\treturn;\n\t}\n\tif ( input <= 0.0 || output <= 0.0 ) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Gamma values should be positive\");\n\t\tRETURN_FALSE;\n\t}\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tif (gdImageTrueColor(im))\t{\n\t\tint x, y, c;\n\t\tfor (y = 0; y < gdImageSY(im); y++)\t{\n\t\t\tfor (x = 0; x < gdImageSX(im); x++)\t{\n\t\t\t\tc = gdImageGetPixel(im, x, y);\n\t\t\t\tgdImageSetPixel(im, x, y,\n\t\t\t\t\tgdTrueColorAlpha(\n\t\t\t\t\t\t(int) ((pow((pow((gdTrueColorGetRed(c)   / 255.0), input)), 1.0 / output) * 255) + .5),\n\t\t\t\t\t\t(int) ((pow((pow((gdTrueColorGetGreen(c) / 255.0), input)), 1.0 / output) * 255) + .5),\n\t\t\t\t\t\t(int) ((pow((pow((gdTrueColorGetBlue(c)  / 255.0), input)), 1.0 / output) * 255) + .5),\n\t\t\t\t\t\tgdTrueColorGetAlpha(c)\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tRETURN_TRUE;\n\t}\n\tfor (i = 0; i < gdImageColorsTotal(im); i++) {\n\t\tim->red[i]   = (int)((pow((pow((im->red[i]   / 255.0), input)), 1.0 / output) * 255) + .5);\n\t\tim->green[i] = (int)((pow((pow((im->green[i] / 255.0), input)), 1.0 / output) * 255) + .5);\n\t\tim->blue[i]  = (int)((pow((pow((im->blue[i]  / 255.0), input)), 1.0 / output) * 255) + .5);\n\t}\n\tRETURN_TRUE;\n}", "target": 0}
{"code": "static gboolean key_value_ok(gchar *key, gchar *value)\n{\n    char *i;\n    for (i = key; *i != 0; i++)\n    {\n        if (!isalpha(*i) && (*i != '-') && (*i != '_') && (*i != ' '))\n            return FALSE;\n    }\n    if (strcmp(key, \"basename\") == 0\n     || strcmp(key, FILENAME_TYPE) == 0\n    )\n    {\n        if (!is_correct_filename(value))\n        {\n            error_msg(\"Value of '%s' ('%s') is not a valid directory name\",\n                      key, value);\n            return FALSE;\n        }\n    }\n    return TRUE;\n}", "target": 1}
{"code": "static void handle_irq_for_port(evtchn_port_t port)\n{\n\tint irq;\n\tirq = get_evtchn_to_irq(port);\n\tif (irq != -1)\n\t\tgeneric_handle_irq(irq);\n}", "target": 1}
{"code": "static void ikev2_parent_outI1_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\tstruct pluto_crypto_req *r,\n\t\t\t\t\terr_t ugh)\n{\n\tstruct ke_continuation *ke = (struct ke_continuation *)pcrc;\n\tstruct msg_digest *md = ke->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent outI1: calculated ke+nonce, sending I1\"));\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t\treturn;\n\t}\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\tpassert(st->st_suspended_md == ke->md);\n\tset_suspended(st, NULL); \n\tset_cur_state(st);\n\tst->st_calculating = FALSE;\n\te = ikev2_parent_outI1_tail(pcrc, r);\n\tif (ke->md != NULL) {\n\t\tcomplete_v2_state_transition(&ke->md, e);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t}\n\treset_cur_state();\n\treset_globals();\n\tpassert(GLOBALS_ARE_RESET());\n}", "target": 1}
{"code": "static void stellaris_enet_save(QEMUFile *f, void *opaque)\n{\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n    int i;\n    qemu_put_be32(f, s->ris);\n    qemu_put_be32(f, s->im);\n    qemu_put_be32(f, s->rctl);\n    qemu_put_be32(f, s->tctl);\n    qemu_put_be32(f, s->thr);\n    qemu_put_be32(f, s->mctl);\n    qemu_put_be32(f, s->mdv);\n    qemu_put_be32(f, s->mtxd);\n    qemu_put_be32(f, s->mrxd);\n    qemu_put_be32(f, s->np);\n    qemu_put_be32(f, s->tx_fifo_len);\n    qemu_put_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));\n    for (i = 0; i < 31; i++) {\n        qemu_put_be32(f, s->rx[i].len);\n        qemu_put_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));\n    }\n    qemu_put_be32(f, s->next_packet);\n    qemu_put_be32(f, s->rx_fifo_offset);\n}", "target": 1}
{"code": "static int orinoco_ioctl_setrate(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t struct iw_param *rrq,\n\t\t\t\t char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint ratemode;\n\tint bitrate; \n\tunsigned long flags;\n\tif (rrq->value == -1)\n\t\tbitrate = 110;\n\telse {\n\t\tif (rrq->value % 100000)\n\t\t\treturn -EINVAL;\n\t\tbitrate = rrq->value / 100000;\n\t}\n\tratemode = orinoco_get_bitratemode(bitrate, !rrq->fixed);\n\tif (ratemode == -1)\n\t\treturn -EINVAL;\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\tpriv->bitratemode = ratemode;\n\torinoco_unlock(priv, &flags);\n\treturn -EINPROGRESS;\n}", "target": 0}
{"code": "uint64_t countBytesForTest(const HeaderMapImpl& headers) {\n  uint64_t byte_size = 0;\n  headers.iterate(\n      [](const Http::HeaderEntry& header, void* context) -> Http::HeaderMap::Iterate {\n        auto* byte_size = static_cast<uint64_t*>(context);\n        *byte_size += header.key().getStringView().size() + header.value().getStringView().size();\n        return Http::HeaderMap::Iterate::Continue;\n      },\n      &byte_size);\n  return byte_size;\n}", "target": 0}
{"code": "krb5_gss_export_sec_context(minor_status, context_handle, interprocess_token)\n    OM_uint32           *minor_status;\n    gss_ctx_id_t        *context_handle;\n    gss_buffer_t        interprocess_token;\n{\n    krb5_context        context = NULL;\n    krb5_error_code     kret;\n    OM_uint32           retval;\n    size_t              bufsize, blen;\n    krb5_gss_ctx_id_t   ctx;\n    krb5_octet          *obuffer, *obp;\n    obuffer = (krb5_octet *) NULL;\n    retval = GSS_S_FAILURE;\n    *minor_status = 0;\n    ctx = (krb5_gss_ctx_id_t) *context_handle;\n    if (ctx->terminated) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return (GSS_S_NO_CONTEXT);\n    }\n    context = ctx->k5_context;\n    kret = krb5_gss_ser_init(context);\n    if (kret)\n        goto error_out;\n    bufsize = 0;\n    if ((kret = kg_ctx_size(context, (krb5_pointer) ctx,\n                            &bufsize)))\n        goto error_out;\n    if ((obuffer = gssalloc_malloc(bufsize)) == NULL) {\n        kret = ENOMEM;\n        goto error_out;\n    }\n    obp = obuffer;\n    blen = bufsize;\n    if ((kret = kg_ctx_externalize(context,\n                                   (krb5_pointer) ctx, &obp, &blen)))\n        goto error_out;\n    interprocess_token->length = bufsize - blen;\n    interprocess_token->value = obuffer;\n    *minor_status = 0;\n    retval = GSS_S_COMPLETE;\n    (void)krb5_gss_delete_sec_context(minor_status, context_handle, NULL);\n    *context_handle = GSS_C_NO_CONTEXT;\n    return (GSS_S_COMPLETE);\nerror_out:\n    if (retval != GSS_S_COMPLETE)\n        if (kret != 0 && context != 0)\n            save_error_info((OM_uint32)kret, context);\n    if (obuffer && bufsize) {\n        memset(obuffer, 0, bufsize);\n        xfree(obuffer);\n    }\n    if (*minor_status == 0)\n        *minor_status = (OM_uint32) kret;\n    return(retval);\n}", "target": 0}
{"code": "static int checkStringLength(client *c, long long size) {\n    if (!mustObeyClient(c) && size > server.proto_max_bulk_len) {\n        addReplyError(c,\"string exceeds maximum allowed size (proto-max-bulk-len)\");\n        return C_ERR;\n    }\n    return C_OK;\n}", "target": 1}
{"code": "xps_parse_digits(char *s, int *digit)\n{\n    *digit = 0;\n    while (*s >= '0' && *s <= '9')\n    {\n        *digit = *digit * 10 + (*s - '0');\n        s ++;\n    }\n    return s;\n}", "target": 0}
{"code": "doc_data_init(struct doc_data *data)\n{\n\tdata->hash = NULL;\n\tdata->hash_len = 0;\n\tdata->uri = NULL;\n}", "target": 1}
{"code": "delta_head_destroy(struct delta_head *delta_head)\n{\n\tif (delta_head) {\n\t\tdoc_data_cleanup(&delta_head->doc_data);\n\t\tfree(delta_head);\n\t}\n}", "target": 1}
{"code": "int mongo_env_read_socket( mongo *conn, void *buf, int len ) {\n    char *cbuf = buf;\n    while ( len ) {\n        int sent = recv( conn->sock, cbuf, len, 0 );\n        if ( sent == 0 || sent == -1 ) {\n            __mongo_set_error( conn, MONGO_IO_ERROR, NULL, WSAGetLastError() );\n            return MONGO_ERROR;\n        }\n        cbuf += sent;\n        len -= sent;\n    }\n    return MONGO_OK;\n}", "target": 1}
{"code": "scrypt_SHA256_Final(unsigned char digest[32], struct SHA256_CTX * ctx)\n{\n  SHA256_Pad(ctx);\n  be32enc_vect(digest, ctx->state, 32);\n  memset((void *)ctx, 0, sizeof(*ctx));\n}", "target": 1}
{"code": "  static TfLiteRegistration DelegateRegistration() {\n    TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n    reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n      TfLiteTensor* output0 = GetOutput(context, node, 0);\n      TF_LITE_ENSURE(context, IsDynamicTensor(output0));\n      const TfLiteTensor* input = GetInput(context, node, 0);\n      TfLiteTensor* output1 = GetOutput(context, node, 1);\n      TF_LITE_ENSURE(context, input->dims->size == output1->dims->size);\n      TF_LITE_ENSURE(context, input->dims->data[0] == output1->dims->data[0]);\n      return kTfLiteOk;\n    };\n    return reg;\n  }", "target": 1}
{"code": "TfLiteStatus SimpleStatefulOp::Prepare(TfLiteContext* context,\n                                       TfLiteNode* node) {\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n  const TfLiteTensor* input = tflite::GetInput(context, node, kInputTensor);\n  if (input->type != kTfLiteUInt8) return kTfLiteError;\n  if (NumElements(input->dims) == 0) return kTfLiteError;\n  TF_LITE_ENSURE_STATUS(context->RequestScratchBufferInArena(\n      context, sizeof(uint8_t) * NumElements(input->dims),\n      &data->sorting_buffer));\n  data->invoke_count = reinterpret_cast<int*>(\n      context->AllocatePersistentBuffer(context, sizeof(int)));\n  *data->invoke_count = 0;\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static int __net_init sit_init_net(struct net *net)\n{\n\tstruct sit_net *sitn = net_generic(net, sit_net_id);\n\tstruct ip_tunnel *t;\n\tint err;\n\tsitn->tunnels[0] = sitn->tunnels_wc;\n\tsitn->tunnels[1] = sitn->tunnels_l;\n\tsitn->tunnels[2] = sitn->tunnels_r;\n\tsitn->tunnels[3] = sitn->tunnels_r_l;\n\tif (!net_has_fallback_tunnels(net))\n\t\treturn 0;\n\tsitn->fb_tunnel_dev = alloc_netdev(sizeof(struct ip_tunnel), \"sit0\",\n\t\t\t\t\t   NET_NAME_UNKNOWN,\n\t\t\t\t\t   ipip6_tunnel_setup);\n\tif (!sitn->fb_tunnel_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_dev;\n\t}\n\tdev_net_set(sitn->fb_tunnel_dev, net);\n\tsitn->fb_tunnel_dev->rtnl_link_ops = &sit_link_ops;\n\tsitn->fb_tunnel_dev->features |= NETIF_F_NETNS_LOCAL;\n\terr = register_netdev(sitn->fb_tunnel_dev);\n\tif (err)\n\t\tgoto err_reg_dev;\n\tipip6_tunnel_clone_6rd(sitn->fb_tunnel_dev, sitn);\n\tipip6_fb_tunnel_init(sitn->fb_tunnel_dev);\n\tt = netdev_priv(sitn->fb_tunnel_dev);\n\tstrcpy(t->parms.name, sitn->fb_tunnel_dev->name);\n\treturn 0;\nerr_reg_dev:\n\tipip6_dev_free(sitn->fb_tunnel_dev);\n\tfree_netdev(sitn->fb_tunnel_dev);\nerr_alloc_dev:\n\treturn err;\n}", "target": 0}
{"code": "ReadReason(rfbClient* client)\n{\n    uint32_t reasonLen;\n    char *reason;\n    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;\n    reasonLen = rfbClientSwap32IfLE(reasonLen);\n    reason = malloc((uint64_t)reasonLen+1);\n    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }\n    reason[reasonLen]=0;\n    rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n    free(reason);\n}", "target": 1}
{"code": "static void oidc_scrub_headers(request_rec *r) {\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\tif (cfg->scrub_request_headers != 0) {\n\t\toidc_scrub_request_headers(r, OIDC_DEFAULT_HEADER_PREFIX,\n\t\t\t\toidc_cfg_dir_authn_header(r));\n\t\tif ((strstr(cfg->claim_prefix, OIDC_DEFAULT_HEADER_PREFIX)\n\t\t\t\t!= cfg->claim_prefix)) {\n\t\t\toidc_scrub_request_headers(r, cfg->claim_prefix, NULL);\n\t\t}\n\t}\n}", "target": 1}
{"code": "void usb_sg_cancel(struct usb_sg_request *io)\n{\n\tunsigned long flags;\n\tint i, retval;\n\tspin_lock_irqsave(&io->lock, flags);\n\tif (io->status) {\n\t\tspin_unlock_irqrestore(&io->lock, flags);\n\t\treturn;\n\t}\n\tio->status = -ECONNRESET;\n\tspin_unlock_irqrestore(&io->lock, flags);\n\tfor (i = io->entries - 1; i >= 0; --i) {\n\t\tusb_block_urb(io->urbs[i]);\n\t\tretval = usb_unlink_urb(io->urbs[i]);\n\t\tif (retval != -EINPROGRESS\n\t\t    && retval != -ENODEV\n\t\t    && retval != -EBUSY\n\t\t    && retval != -EIDRM)\n\t\t\tdev_warn(&io->dev->dev, \"%s, unlink --> %d\\n\",\n\t\t\t\t __func__, retval);\n\t}\n}", "target": 1}
{"code": "force_removal (Device *device,\n               ForceRemovalCompleteFunc callback,\n               gpointer user_data)\n{\n  if (device->priv->device_is_mounted && device->priv->device_mount_paths->len > 0)\n    {\n      gboolean remove_dir_on_unmount;\n      if (mount_file_has_device (device->priv->device_file, NULL, &remove_dir_on_unmount) ||\n          is_device_in_fstab (device, NULL))\n        {\n          g_print (\"**** NOTE: Force unmounting device %s\\n\", device->priv->device_file);\n          force_unmount (device, callback, user_data);\n          goto pending;\n        }\n    }\n  if (device->priv->id_usage != NULL && strcmp (device->priv->id_usage, \"crypto\") == 0)\n    {\n      GList *devices;\n      GList *l;\n      devices = daemon_local_get_all_devices (device->priv->daemon);\n      for (l = devices; l != NULL; l = l->next)\n        {\n          Device *d = DEVICE (l->data);\n          if (d->priv->device_is_luks_cleartext && d->priv->luks_cleartext_slave != NULL\n              && strcmp (d->priv->luks_cleartext_slave, device->priv->object_path) == 0)\n            {\n              if (d->priv->dm_name != NULL && g_str_has_prefix (d->priv->dm_name, \"udisks-luks-uuid-\"))\n                {\n                  g_print (\"**** NOTE: Force luks teardown device %s (cleartext %s)\\n\",\n                           device->priv->device_file,\n                           d->priv->device_file);\n                  force_luks_teardown (device, d, callback, user_data);\n                  goto pending;\n                }\n            }\n        }\n    }\n  if (callback != NULL)\n    callback (device, TRUE, user_data);\n pending:\n  ;\n}", "target": 0}
{"code": "static inline int ccid_hc_rx_getsockopt(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\tconst int optname, int len,\n\t\t\t\t\tu32 __user *optval, int __user *optlen)\n{\n\tint rc = -ENOPROTOOPT;\n\tif (ccid->ccid_ops->ccid_hc_rx_getsockopt != NULL)\n\t\trc = ccid->ccid_ops->ccid_hc_rx_getsockopt(sk, optname, len,\n\t\t\t\t\t\t optval, optlen);\n\treturn rc;\n}", "target": 1}
{"code": "  void encode(bufferlist& bl) const {\n    __u8 struct_v = 1;\n    ::encode(struct_v, bl);\n    ::encode(server_challenge, bl);\n  }", "target": 0}
{"code": "TEE_Result syscall_cryp_state_copy(unsigned long dst, unsigned long src)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs_dst;\n\tstruct tee_cryp_state *cs_src;\n\tstruct tee_ta_session *sess;\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(dst), &cs_dst);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(src), &cs_src);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (cs_dst->algo != cs_src->algo || cs_dst->mode != cs_src->mode)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\tswitch (TEE_ALG_GET_CLASS(cs_src->algo)) {\n\tcase TEE_OPERATION_CIPHER:\n\t\tcrypto_cipher_copy_state(cs_dst->ctx, cs_src->ctx,\n\t\t\t\t\t cs_src->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_AE:\n\t\tcrypto_authenc_copy_state(cs_dst->ctx, cs_src->ctx,\n\t\t\t\t\t  cs_src->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_DIGEST:\n\t\tcrypto_hash_copy_state(cs_dst->ctx, cs_src->ctx, cs_src->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tcrypto_mac_copy_state(cs_dst->ctx, cs_src->ctx, cs_src->algo);\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_STATE;\n\t}\n\tcs_dst->state = cs_src->state;\n\treturn TEE_SUCCESS;\n}", "target": 0}
{"code": "void mt_init(mtrand *mt, uint32_t seed) {\n  int i;\n  mt->mt_buffer_[0] = seed;\n  mt->mt_index_ = MT_LEN;\n  for (i = 1; i < MT_LEN; i++) {\n    mt->mt_buffer_[i] =\n\t(1812433253UL * (mt->mt_buffer_[i-1] ^ \n\t\t\t (mt->mt_buffer_[i-1] >> 30)) + i);\n  }\n}", "target": 1}
{"code": "void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen) {\n    if (zobj->encoding == OBJ_ENCODING_ZIPLIST) return;\n    zset *zset = zobj->ptr;\n    if (zset->zsl->length <= server.zset_max_ziplist_entries &&\n        maxelelen <= server.zset_max_ziplist_value)\n            zsetConvert(zobj,OBJ_ENCODING_ZIPLIST);\n}", "target": 1}
{"code": "static int perf_trace_event_perm(struct ftrace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n{\n\tif (ftrace_event_is_function(tp_event) &&\n\t    perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))\n\t\treturn 0;\n\tif (p_event->attach_state == PERF_ATTACH_TASK) {\n\t\tif (tp_event->flags & TRACE_EVENT_FL_CAP_ANY)\n\t\t\treturn 0;\n\t}\n\tif (perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\treturn 0;\n}", "target": 1}
{"code": "static int dn_create(struct net *net, struct socket *sock, int protocol,\n\t\t     int kern)\n{\n\tstruct sock *sk;\n\tif (protocol < 0 || protocol > SK_PROTOCOL_MAX)\n\t\treturn -EINVAL;\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\tswitch (sock->type) {\n\tcase SOCK_SEQPACKET:\n\t\tif (protocol != DNPROTO_NSP)\n\t\t\treturn -EPROTONOSUPPORT;\n\t\tbreak;\n\tcase SOCK_STREAM:\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\tif ((sk = dn_alloc_sock(net, sock, GFP_KERNEL, kern)) == NULL)\n\t\treturn -ENOBUFS;\n\tsk->sk_protocol = protocol;\n\treturn 0;\n}", "target": 0}
{"code": "checkContentType(Buffer *buf)\n{\n    char *p;\n    Str r;\n    p = checkHeader(buf, \"Content-Type:\");\n    if (p == NULL)\n\treturn NULL;\n    r = Strnew();\n    while (*p && *p != ';' && !IS_SPACE(*p))\n\tStrcat_char(r, *p++);\n#ifdef USE_M17N\n    if ((p = strcasestr(p, \"charset\")) != NULL) {\n\tp += 7;\n\tSKIP_BLANKS(p);\n\tif (*p == '=') {\n\t    p++;\n\t    SKIP_BLANKS(p);\n\t    if (*p == '\"')\n\t\tp++;\n\t    content_charset = wc_guess_charset(p, 0);\n\t}\n    }\n#endif\n    return r->ptr;\n}", "target": 0}
{"code": "getFileTypeNoFollowSymlinks(const StaticString &filename) {\n\tstruct stat buf;\n\tint ret;\n\tret = lstat(filename.c_str(), &buf);\n\tif (ret == 0) {\n\t\tif (S_ISREG(buf.st_mode)) {\n\t\t\treturn FT_REGULAR;\n\t\t} else if (S_ISDIR(buf.st_mode)) {\n\t\t\treturn FT_DIRECTORY;\n\t\t} else if (S_ISLNK(buf.st_mode)) {\n\t\t\treturn FT_SYMLINK;\n\t\t} else {\n\t\t\treturn FT_OTHER;\n\t\t}\n\t} else {\n\t\tif (errno == ENOENT) {\n\t\t\treturn FT_NONEXISTANT;\n\t\t} else {\n\t\t\tint e = errno;\n\t\t\tstring message(\"Cannot lstat '\");\n\t\t\tmessage.append(filename);\n\t\t\tmessage.append(\"'\");\n\t\t\tthrow FileSystemException(message, e, filename);\n\t\t}\n\t}\n}", "target": 1}
{"code": "static int fetch_uidl(char *line, void *data)\n{\n  int i, index;\n  struct Context *ctx = (struct Context *) data;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  char *endp = NULL;\n  errno = 0;\n  index = strtol(line, &endp, 10);\n  if (errno)\n    return -1;\n  while (*endp == ' ')\n    endp++;\n  memmove(line, endp, strlen(endp) + 1);\n  if (strlen(line) == 0)\n    return -1;\n  for (i = 0; i < ctx->msgcount; i++)\n    if (mutt_str_strcmp(line, ctx->hdrs[i]->data) == 0)\n      break;\n  if (i == ctx->msgcount)\n  {\n    mutt_debug(1, \"new header %d %s\\n\", index, line);\n    if (i >= ctx->hdrmax)\n      mx_alloc_memory(ctx);\n    ctx->msgcount++;\n    ctx->hdrs[i] = mutt_header_new();\n    ctx->hdrs[i]->data = mutt_str_strdup(line);\n  }\n  else if (ctx->hdrs[i]->index != index - 1)\n    pop_data->clear_cache = true;\n  ctx->hdrs[i]->refno = index;\n  ctx->hdrs[i]->index = index - 1;\n  return 0;\n}", "target": 0}
{"code": "lzw_result lzw_decode(struct lzw_ctx *ctx,\n\t\tconst uint8_t ** const stack_pos_out)\n{\n\tlzw_result res;\n\tuint32_t code_new;\n\tuint32_t code_out;\n\tuint8_t last_value;\n\tuint8_t *stack_pos = ctx->stack_base;\n\tuint32_t clear_code = ctx->clear_code;\n\tuint32_t current_entry = ctx->current_entry;\n\tstruct lzw_dictionary_entry * const table = ctx->table;\n\tres = lzw__next_code(&ctx->input, ctx->current_code_size, &code_new);\n\tif (res != LZW_OK) {\n\t\treturn res;\n\t}\n\tif (code_new == clear_code) {\n\t\treturn lzw__clear_codes(ctx, stack_pos_out);\n\t} else if (code_new == ctx->eoi_code) {\n\t\treturn LZW_EOI_CODE;\n\t} else if (code_new > current_entry) {\n\t\treturn LZW_BAD_CODE;\n\t} else if (code_new >= 1 << LZW_CODE_MAX) {\n\t\treturn LZW_BAD_CODE;\n\t} else if (code_new < current_entry) {\n\t\tcode_out = code_new;\n\t\tlast_value = table[code_new].first_value;\n\t} else {\n\t\t*stack_pos++ = ctx->previous_code_first;\n\t\tcode_out = ctx->previous_code;\n\t\tlast_value = ctx->previous_code_first;\n\t}\n\tif (current_entry < (1 << LZW_CODE_MAX)) {\n\t\tstruct lzw_dictionary_entry *entry = table + current_entry;\n\t\tentry->last_value     = last_value;\n\t\tentry->first_value    = ctx->previous_code_first;\n\t\tentry->previous_entry = ctx->previous_code;\n\t\tctx->current_entry++;\n\t}\n\tif (current_entry == ctx->current_code_size_max) {\n\t\tif (ctx->current_code_size < LZW_CODE_MAX) {\n\t\t\tctx->current_code_size++;\n\t\t\tctx->current_code_size_max =\n\t\t\t\t\t(1 << ctx->current_code_size) - 1;\n\t\t}\n\t}\n\tctx->previous_code_first = table[code_new].first_value;\n\tctx->previous_code = code_new;\n\twhile (code_out > clear_code) {\n\t\tstruct lzw_dictionary_entry *entry = table + code_out;\n\t\t*stack_pos++ = entry->last_value;\n\t\tcode_out = entry->previous_entry;\n\t}\n\t*stack_pos++ = table[code_out].last_value;\n\t*stack_pos_out = stack_pos;\n\treturn LZW_OK;\n}", "target": 0}
{"code": "int ossl_dsa_check_priv_key(const DSA *dsa, const BIGNUM *priv_key, int *ret)\n{\n    *ret = 0;\n    return (dsa->params.q != NULL\n            && ossl_ffc_validate_private_key(dsa->params.q, priv_key, ret));\n}", "target": 1}
{"code": "static void HeaderMapImplGetByteSize(benchmark::State& state) {\n  HeaderMapImpl headers;\n  addDummyHeaders(headers, state.range(0));\n  uint64_t size = 0;\n  for (auto _ : state) {\n    size += headers.byteSize();\n  }\n  benchmark::DoNotOptimize(size);\n}", "target": 1}
{"code": "gboolean session_info_session_is_locked(struct session_info *si)\n{\n    gboolean locked;\n    g_return_val_if_fail (si != NULL, FALSE);\n    si_dbus_read_signals(si);\n    si_dbus_read_properties(si);\n    locked = (si->session_is_locked || si->session_locked_hint);\n    if (si->verbose) {\n        syslog(LOG_DEBUG, \"(systemd-login) session is locked: %s\",\n               locked ? \"yes\" : \"no\");\n    }\n    return locked;\n}", "target": 0}
{"code": "static void perf_adjust_freq_unthr_context(struct perf_event_context *ctx,\n\t\t\t\t\t   int needs_unthr)\n{\n\tstruct perf_event *event;\n\tstruct hw_perf_event *hwc;\n\tu64 now, period = TICK_NSEC;\n\ts64 delta;\n\tif (!(ctx->nr_freq || needs_unthr))\n\t\treturn;\n\traw_spin_lock(&ctx->lock);\n\tperf_pmu_disable(ctx->pmu);\n\tlist_for_each_entry_rcu(event, &ctx->event_list, event_entry) {\n\t\tif (event->state != PERF_EVENT_STATE_ACTIVE)\n\t\t\tcontinue;\n\t\tif (!event_filter_match(event))\n\t\t\tcontinue;\n\t\thwc = &event->hw;\n\t\tif (needs_unthr && hwc->interrupts == MAX_INTERRUPTS) {\n\t\t\thwc->interrupts = 0;\n\t\t\tperf_log_throttle(event, 1);\n\t\t\tevent->pmu->start(event, 0);\n\t\t}\n\t\tif (!event->attr.freq || !event->attr.sample_freq)\n\t\t\tcontinue;\n\t\tevent->pmu->stop(event, PERF_EF_UPDATE);\n\t\tnow = local64_read(&event->count);\n\t\tdelta = now - hwc->freq_count_stamp;\n\t\thwc->freq_count_stamp = now;\n\t\tif (delta > 0)\n\t\t\tperf_adjust_period(event, period, delta, false);\n\t\tevent->pmu->start(event, delta > 0 ? PERF_EF_RELOAD : 0);\n\t}\n\tperf_pmu_enable(ctx->pmu);\n\traw_spin_unlock(&ctx->lock);\n}", "target": 0}
{"code": "void __skb_tstamp_tx(struct sk_buff *orig_skb,\n\t\t     struct skb_shared_hwtstamps *hwtstamps,\n\t\t     struct sock *sk, int tstype)\n{\n\tstruct sk_buff *skb;\n\tbool tsonly;\n\tif (!sk)\n\t\treturn;\n\ttsonly = sk->sk_tsflags & SOF_TIMESTAMPING_OPT_TSONLY;\n\tif (!skb_may_tx_timestamp(sk, tsonly))\n\t\treturn;\n\tif (tsonly) {\n#ifdef CONFIG_INET\n\t\tif ((sk->sk_tsflags & SOF_TIMESTAMPING_OPT_STATS) &&\n\t\t    sk->sk_protocol == IPPROTO_TCP &&\n\t\t    sk->sk_type == SOCK_STREAM)\n\t\t\tskb = tcp_get_timestamping_opt_stats(sk);\n\t\telse\n#endif\n\t\t\tskb = alloc_skb(0, GFP_ATOMIC);\n\t} else {\n\t\tskb = skb_clone(orig_skb, GFP_ATOMIC);\n\t}\n\tif (!skb)\n\t\treturn;\n\tif (tsonly) {\n\t\tskb_shinfo(skb)->tx_flags = skb_shinfo(orig_skb)->tx_flags;\n\t\tskb_shinfo(skb)->tskey = skb_shinfo(orig_skb)->tskey;\n\t}\n\tif (hwtstamps)\n\t\t*skb_hwtstamps(skb) = *hwtstamps;\n\telse\n\t\tskb->tstamp = ktime_get_real();\n\t__skb_complete_tx_timestamp(skb, sk, tstype);", "target": 1}
{"code": "static void free_todo_entries(TodoEntry **todos) {\n        for (TodoEntry *x = *todos; x && x->dir; x++) {\n                closedir(x->dir);\n                free(x->dirname);\n        }\n        freep(todos);\n}", "target": 0}
{"code": "static int nfc_genl_llc_set_params(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\tu8 rw = 0;\n\tu16 miux = 0;\n\tu32 idx;\n\tint rc = 0;\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    (!info->attrs[NFC_ATTR_LLC_PARAM_LTO] &&\n\t     !info->attrs[NFC_ATTR_LLC_PARAM_RW] &&\n\t     !info->attrs[NFC_ATTR_LLC_PARAM_MIUX]))\n\t\treturn -EINVAL;\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_RW]) {\n\t\trw = nla_get_u8(info->attrs[NFC_ATTR_LLC_PARAM_RW]);\n\t\tif (rw > LLCP_MAX_RW)\n\t\t\treturn -EINVAL;\n\t}\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_MIUX]) {\n\t\tmiux = nla_get_u16(info->attrs[NFC_ATTR_LLC_PARAM_MIUX]);\n\t\tif (miux > LLCP_MAX_MIUX)\n\t\t\treturn -EINVAL;\n\t}\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\tdevice_lock(&dev->dev);\n\tlocal = nfc_llcp_find_local(dev);\n\tif (!local) {\n\t\trc = -ENODEV;\n\t\tgoto exit;\n\t}\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_LTO]) {\n\t\tif (dev->dep_link_up) {\n\t\t\trc = -EINPROGRESS;\n\t\t\tgoto exit;\n\t\t}\n\t\tlocal->lto = nla_get_u8(info->attrs[NFC_ATTR_LLC_PARAM_LTO]);\n\t}\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_RW])\n\t\tlocal->rw = rw;\n\tif (info->attrs[NFC_ATTR_LLC_PARAM_MIUX])\n\t\tlocal->miux = cpu_to_be16(miux);\nexit:\n\tdevice_unlock(&dev->dev);\n\tnfc_put_device(dev);\n\treturn rc;\n}", "target": 1}
{"code": "bool Tensor::FromProto(Allocator* a, const TensorProto& proto) {\n  CHECK_NOTNULL(a);\n  TensorBuffer* p = nullptr;\n  if (!TensorShape::IsValid(proto.tensor_shape())) return false;\n  if (proto.dtype() == DT_INVALID) return false;\n  TensorShape shape(proto.tensor_shape());\n  const int64_t N = shape.num_elements();\n  if (N > 0 && proto.dtype()) {\n    bool dtype_error = false;\n    if (!proto.tensor_content().empty()) {\n      const auto& content = proto.tensor_content();\n      CASES_WITH_DEFAULT(proto.dtype(), p = Helper<T>::Decode(a, content, N),\n                         dtype_error = true, dtype_error = true);\n    } else {\n      CASES_WITH_DEFAULT(proto.dtype(), p = FromProtoField<T>(a, proto, N),\n                         dtype_error = true, dtype_error = true);\n    }\n    if (dtype_error || p == nullptr) return false;\n  } else {\n    bool dtype_error = false;\n    CASES_WITH_DEFAULT(proto.dtype(), break, dtype_error = true,\n                       dtype_error = true);\n    if (dtype_error) return false;\n  }\n  shape_ = shape;\n  set_dtype(proto.dtype());\n  UnrefIfNonNull(buf_);\n  buf_ = p;\n  if (MemoryLoggingEnabled() && buf_ != nullptr && buf_->data() != nullptr) {\n    LogMemory::RecordTensorAllocation(\"Unknown (from Proto)\",\n                                      LogMemory::UNKNOWN_STEP_ID, *this);\n  }\n  return true;\n}", "target": 0}
{"code": "alloc_limit_assert (char *fn_name, size_t size)\n{\n    if (alloc_limit && size > alloc_limit)\n    {\n\talloc_limit_failure (fn_name, size);\n\texit (-1);\n    }\n}", "target": 1}
{"code": "void nfc_llcp_mac_is_up(struct nfc_dev *dev, u32 target_idx,\n\t\t\tu8 comm_mode, u8 rf_mode)\n{\n\tstruct nfc_llcp_local *local;\n\tpr_debug(\"rf mode %d\\n\", rf_mode);\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL)\n\t\treturn;\n\tlocal->target_idx = target_idx;\n\tlocal->comm_mode = comm_mode;\n\tlocal->rf_mode = rf_mode;\n\tif (rf_mode == NFC_RF_INITIATOR) {\n\t\tpr_debug(\"Queueing Tx work\\n\");\n\t\tschedule_work(&local->tx_work);\n\t} else {\n\t\tmod_timer(&local->link_timer,\n\t\t\t  jiffies + msecs_to_jiffies(local->remote_lto));\n\t}\n\tnfc_llcp_local_put(local);\n}", "target": 0}
{"code": "int key_default_cmp(const struct key *key,\n\t\t    const struct key_match_data *match_data)\n{\n\treturn strcmp(key->description, match_data->raw_data) == 0;\n}", "target": 0}
{"code": "static void sas_eh_finish_cmd(struct scsi_cmnd *cmd)\n{\n\tstruct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(cmd->device->host);\n\tstruct domain_device *dev = cmd_to_domain_dev(cmd);\n\tstruct sas_task *task = TO_SAS_TASK(cmd);\n\tsas_end_task(cmd, task);\n\tif (dev_is_sata(dev)) {\n\t\tlist_move_tail(&cmd->eh_entry, &sas_ha->eh_ata_q);\n\t\treturn;\n\t}\n\tscsi_eh_finish_cmd(cmd, &sas_ha->eh_done_q);\n}", "target": 0}
{"code": "static void initialize_typed_array_from_array_buffer(GlobalObject& global_object, TypedArrayBase& typed_array, ArrayBuffer& array_buffer, Value byte_offset, Value length)\n{\n    auto& vm = global_object.vm();\n    auto element_size = typed_array.element_size();\n    auto offset = byte_offset.to_index(global_object);\n    if (vm.exception())\n        return;\n    if (offset % element_size != 0) {\n        vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayInvalidByteOffset, typed_array.class_name(), element_size, offset);\n        return;\n    }\n    size_t new_length { 0 };\n    if (!length.is_undefined()) {\n        new_length = length.to_index(global_object);\n        if (vm.exception())\n            return;\n    }\n    auto buffer_byte_length = array_buffer.byte_length();\n    size_t new_byte_length;\n    if (length.is_undefined()) {\n        if (buffer_byte_length % element_size != 0) {\n            vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayInvalidBufferLength, typed_array.class_name(), element_size, buffer_byte_length);\n            return;\n        }\n        if (offset > buffer_byte_length) {\n            vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayOutOfRangeByteOffset, offset, buffer_byte_length);\n            return;\n        }\n        new_byte_length = buffer_byte_length - offset;\n    } else {\n        new_byte_length = new_length * element_size;\n        if (offset + new_byte_length > buffer_byte_length) {\n            vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayOutOfRangeByteOffsetOrLength, offset, offset + new_byte_length, buffer_byte_length);\n            return;\n        }\n    }\n    typed_array.set_viewed_array_buffer(&array_buffer);\n    typed_array.set_byte_length(new_byte_length);\n    typed_array.set_byte_offset(offset);\n    typed_array.set_array_length(new_byte_length / element_size);\n}", "target": 1}
{"code": "void luaD_shrinkstack (lua_State *L) {\n  int inuse = stackinuse(L);\n  int goodsize = inuse + (inuse / 8) + 2*EXTRA_STACK;\n  if (goodsize > LUAI_MAXSTACK)\n    goodsize = LUAI_MAXSTACK;  \n  if (inuse <= (LUAI_MAXSTACK - EXTRA_STACK) &&\n      goodsize < L->stacksize)\n    luaD_reallocstack(L, goodsize, 0);  \n  else  \n    condmovestack(L,{},{});  \n  luaE_shrinkCI(L);  \n}", "target": 1}
{"code": "TfLiteStatus ScatterNd(const TfLiteTensor* indices, const TfLiteTensor* updates,\n                       TfLiteTensor* output) {\n  reference_ops::ScatterNd(\n      GetTensorShape(indices), GetTensorData<IndicesT>(indices),\n      GetTensorShape(updates), GetTensorData<UpdatesT>(updates),\n      GetTensorShape(output), GetTensorData<UpdatesT>(output));\n  return kTfLiteOk;\n}", "target": 1}
{"code": "gss_complete_auth_token (OM_uint32 *minor_status,\n\t                 const gss_ctx_id_t context_handle,\n\t                 gss_buffer_t input_message_buffer)\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech != NULL) {\n\tif (mech->gss_complete_auth_token != NULL) {\n\t    status = mech->gss_complete_auth_token(minor_status,\n\t\t\t\t\t\t   ctx->internal_ctx_id,\n\t\t\t\t\t\t   input_message_buffer);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_COMPLETE;\n    } else\n\tstatus = GSS_S_BAD_MECH;\n    return status;\n}", "target": 0}
{"code": "void __init acpi_debugfs_init(void)\n{\n\tacpi_debugfs_dir = debugfs_create_dir(\"acpi\", NULL);\n\tacpi_custom_method_init();\n}", "target": 1}
{"code": "void AverageEvalQuantizedInt16(TfLiteContext* context, TfLiteNode* node,\n                               TfLitePoolParams* params, OpData* data,\n                               const TfLiteTensor* input,\n                               TfLiteTensor* output) {\n  int32_t activation_min;\n  int32_t activation_max;\n  CalculateActivationRangeQuantized(context, params->activation, output,\n                                    &activation_min, &activation_max);\n#define TF_LITE_AVERAGE_POOL(type)                                         \\\n  tflite::PoolParams op_params;                                            \\\n  op_params.stride_height = params->stride_height;                         \\\n  op_params.stride_width = params->stride_width;                           \\\n  op_params.filter_height = params->filter_height;                         \\\n  op_params.filter_width = params->filter_width;                           \\\n  op_params.padding_values.height = data->padding.height;                  \\\n  op_params.padding_values.width = data->padding.width;                    \\\n  op_params.quantized_activation_min = activation_min;                     \\\n  op_params.quantized_activation_max = activation_max;                     \\\n  type::AveragePool(op_params, GetTensorShape(input),                      \\\n                    GetTensorData<int16_t>(input), GetTensorShape(output), \\\n                    GetTensorData<int16_t>(output))\n  TF_LITE_AVERAGE_POOL(reference_integer_ops);\n#undef TF_LITE_AVERAGE_POOL\n}", "target": 1}
{"code": "static struct mnt_namespace *create_mnt_ns(struct vfsmount *m)\n{\n\tstruct mnt_namespace *new_ns = alloc_mnt_ns(&init_user_ns);\n\tif (!IS_ERR(new_ns)) {\n\t\tstruct mount *mnt = real_mount(m);\n\t\tmnt->mnt_ns = new_ns;\n\t\tnew_ns->root = mnt;\n\t\tnew_ns->mounts++;\n\t\tlist_add(&mnt->mnt_list, &new_ns->list);\n\t} else {\n\t\tmntput(m);\n\t}\n\treturn new_ns;\n}", "target": 0}
{"code": "  void getReadBuffer(void** bufReturn, size_t* lenReturn) override {\n    *bufReturn = buf_.data();\n    *lenReturn = buf_.size();\n  }", "target": 0}
{"code": "static struct ip_options *ip_options_get_alloc(const int optlen)\n{\n\treturn kzalloc(sizeof(struct ip_options) + ((optlen + 3) & ~3),\n\t\t       GFP_KERNEL);\n}", "target": 1}
{"code": "file_transfer_t *imcb_file_send_start(struct im_connection *ic, char *handle, char *file_name, size_t file_size)\n{\n\tbee_t *bee = ic->bee;\n\tbee_user_t *bu = bee_user_by_handle(bee, ic, handle);\n\tif (bee->ui->ft_in_start) {\n\t\treturn bee->ui->ft_in_start(bee, bu, file_name, file_size);\n\t} else {\n\t\treturn NULL;\n\t}\n}", "target": 1}
{"code": "inline typename V::VectorType FBUnserializer<V>::unserializeVector() {\n  p_ += CODE_SIZE;\n  typename V::VectorType ret = V::createVector();\n  size_t code = nextCode();\n  while (code != FB_SERIALIZE_STOP) {\n    V::vectorAppend(ret, unserializeThing());\n    code = nextCode();\n  }\n  p_ += CODE_SIZE;\n  return ret;\n}", "target": 1}
{"code": "CbrDetectorRemote::Result CbrDetectorRemote::Decrypt(cricket::MediaType media_type,\n\t\t\t\t\t\tconst std::vector<uint32_t>& csrcs,\n\t\t\t\t\t\trtc::ArrayView<const uint8_t> additional_data,\n\t\t\t\t\t\trtc::ArrayView<const uint8_t> encrypted_frame,\n\t\t\t\t\t\trtc::ArrayView<uint8_t> frame)\n{\n\tconst uint8_t *src = encrypted_frame.data();\n\tuint8_t *dst = frame.data();\n\tuint32_t data_len = encrypted_frame.size();\n\tif (media_type == cricket::MEDIA_TYPE_AUDIO) {\n\t\tif (data_len == frame_size && frame_size >= 40) {\n\t\t\tframe_count++;\n\t\t\tif (frame_count > 200 && !detected) {\n\t\t\t\tinfo(\"CBR detector: remote cbr detected\\n\");\n\t\t\t\tdetected = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tframe_count = 0;\n\t\t\tframe_size = data_len;\n\t\t\tif (detected) {\n\t\t\t\tinfo(\"CBR detector: remote cbr detected disabled\\n\");\n\t\t\t\tdetected = false;\n\t\t\t}\n\t\t}\n\t}\n\tmemcpy(dst, src, data_len);\nout:\n\treturn CbrDetectorRemote::Result(CbrDetectorRemote::Status::kOk, data_len);\n}", "target": 1}
{"code": "static ssize_t aio_setup_single_vector(struct kiocb *kiocb)\n{\n\tkiocb->ki_iovec = &kiocb->ki_inline_vec;\n\tkiocb->ki_iovec->iov_base = kiocb->ki_buf;\n\tkiocb->ki_iovec->iov_len = kiocb->ki_left;\n\tkiocb->ki_nr_segs = 1;\n\tkiocb->ki_cur_seg = 0;\n\treturn 0;\n}", "target": 1}
{"code": "completion_glob_pattern (string)\n     char *string;\n{\n  register int c;\n  char *send;\n  int open;\n  DECLARE_MBSTATE;\n  open = 0;\n  send = string + strlen (string);\n  while (c = *string++)\n    {\n      switch (c)\n\t{\n\tcase '?':\n\tcase '*':\n\t  return (1);\n\tcase '[':\n\t  open++;\n\t  continue;\n\tcase ']':\n\t  if (open)\n\t    return (1);\n\t  continue;\n\tcase '+':\n\tcase '@':\n\tcase '!':\n\t  if (*string == '(')\t\n\t    return (1);\n\t  continue;\n\tcase '\\\\':\n\t  if (*string++ == 0)\n\t    return (0);\n\t}\n#ifdef HANDLE_MULTIBYTE\n      string--;\n      ADVANCE_CHAR_P (string, send - string);\n      string++;\n#else\n      ADVANCE_CHAR_P (string, send - string);\n#endif\n    }\n  return (0);\n}", "target": 1}
{"code": "static bool vtable_is_value_in_text_section(RVTableContext *context, ut64 curAddress, ut64 *value) {\n\tut64 curAddressValue;\n\tif (!context->read_addr (context->anal, curAddress, &curAddressValue)) {\n\t\treturn false;\n\t}\n\tbool ret = vtable_addr_in_text_section (context, curAddressValue);\n\tif (value) {\n\t\t*value = curAddressValue;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "option_persist_cb (const gchar *option_name,\n                   const gchar *value,\n                   gpointer     data,\n                   GError     **error)\n{\n  FlatpakContext *context = data;\n  flatpak_context_set_persistent (context, value);\n  return TRUE;\n}", "target": 1}
{"code": "static int do_video_set_spu_palette(unsigned int fd, unsigned int cmd,\n\t\tstruct compat_video_spu_palette __user *up)\n{\n\tstruct video_spu_palette __user *up_native;\n\tcompat_uptr_t palp;\n\tint length, err;\n\terr  = get_user(palp, &up->palette);\n\terr |= get_user(length, &up->length);\n\tif (err)\n\t\treturn -EFAULT;\n\tup_native = compat_alloc_user_space(sizeof(struct video_spu_palette));\n\terr  = put_user(compat_ptr(palp), &up_native->palette);\n\terr |= put_user(length, &up_native->length);\n\tif (err)\n\t\treturn -EFAULT;\n\terr = sys_ioctl(fd, cmd, (unsigned long) up_native);\n\treturn err;\n}", "target": 0}
{"code": "static zend_always_inline zend_string* __zval_get_string_func(zval *op, zend_bool try) \n{\ntry_again:\n\tswitch (Z_TYPE_P(op)) {\n\t\tcase IS_UNDEF:\n\t\tcase IS_NULL:\n\t\tcase IS_FALSE:\n\t\t\treturn ZSTR_EMPTY_ALLOC();\n\t\tcase IS_TRUE:\n\t\t\treturn ZSTR_CHAR('1');\n\t\tcase IS_RESOURCE: {\n\t\t\treturn zend_strpprintf(0, \"Resource id #\" ZEND_LONG_FMT, (zend_long)Z_RES_HANDLE_P(op));\n\t\t}\n\t\tcase IS_LONG: {\n\t\t\treturn zend_long_to_str(Z_LVAL_P(op));\n\t\t}\n\t\tcase IS_DOUBLE: {\n\t\t\treturn zend_strpprintf(0, \"%.*G\", (int) EG(precision), Z_DVAL_P(op));\n\t\t}\n\t\tcase IS_ARRAY:\n\t\t\tzend_error(E_NOTICE, \"Array to string conversion\");\n\t\t\treturn (try && UNEXPECTED(EG(exception))) ?\n\t\t\t\tNULL : ZSTR_KNOWN(ZEND_STR_ARRAY_CAPITALIZED);\n\t\tcase IS_OBJECT: {\n\t\t\tzval tmp;\n\t\t\tif (Z_OBJ_HT_P(op)->cast_object) {\n\t\t\t\tif (Z_OBJ_HT_P(op)->cast_object(op, &tmp, IS_STRING) == SUCCESS) {\n\t\t\t\t\treturn Z_STR(tmp);\n\t\t\t\t}\n\t\t\t} else if (Z_OBJ_HT_P(op)->get) {\n\t\t\t\tzval *z = Z_OBJ_HT_P(op)->get(op, &tmp);\n\t\t\t\tif (Z_TYPE_P(z) != IS_OBJECT) {\n\t\t\t\t\tzend_string *str = try ? zval_try_get_string(z) : zval_get_string(z);\n\t\t\t\t\tzval_ptr_dtor(z);\n\t\t\t\t\treturn str;\n\t\t\t\t}\n\t\t\t\tzval_ptr_dtor(z);\n\t\t\t}\n\t\t\tif (!EG(exception)) {\n\t\t\t\tzend_throw_error(NULL, \"Object of class %s could not be converted to string\", ZSTR_VAL(Z_OBJCE_P(op)->name));\n\t\t\t}\n\t\t\treturn try ? NULL : ZSTR_EMPTY_ALLOC();\n\t\t}\n\t\tcase IS_REFERENCE:\n\t\t\top = Z_REFVAL_P(op);\n\t\t\tgoto try_again;\n\t\tcase IS_STRING:\n\t\t\treturn zend_string_copy(Z_STR_P(op));\n\t\tEMPTY_SWITCH_DEFAULT_CASE()\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "GF_Err stsz_box_size(GF_Box *s)\n{\n\tu32 i, fieldSize, size;\n\tGF_SampleSizeBox *ptr = (GF_SampleSizeBox *)s;\n\tptr->size += 8;\n\tif (!ptr->sampleCount) return GF_OK;\n\tif (ptr->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tif (ptr->sampleSize) return GF_OK;\n\t\tptr->size += (4 * ptr->sampleCount);\n\t\treturn GF_OK;\n\t}\n\tif (!ptr->sizes) return GF_ISOM_INVALID_FILE;\n\tfieldSize = 4;\n\tsize = ptr->sizes[0];\n\tfor (i=0; i < ptr->sampleCount; i++) {\n\t\tif (ptr->sizes[i] <= 0xF) {\n\t\t}\n\t\telse if (ptr->sizes[i] <= 0xFF) {\n\t\t\tfieldSize = 8;\n\t\t}\n\t\telse if (ptr->sizes[i] <= 0xFFFF) {\n\t\t\tfieldSize = 16;\n\t\t}\n\t\telse {\n\t\t\tfieldSize = 32;\n\t\t}\n\t\tif (size != ptr->sizes[i]) size = 0;\n\t}\n\tif (size) {\n\t\tptr->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\tptr->sampleSize = size;\n\t\tgf_free(ptr->sizes);\n\t\tptr->sizes = NULL;\n\t\treturn GF_OK;\n\t}\n\tif (fieldSize == 32) {\n\t\tptr->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\tptr->size += (4 * ptr->sampleCount);\n\t\treturn GF_OK;\n\t}\n\tptr->type = GF_ISOM_BOX_TYPE_STZ2;\n\tptr->sampleSize = fieldSize;\n\tif (fieldSize == 4) {\n\t\tptr->size += (ptr->sampleCount + 1) / 2;\n\t} else {\n\t\tptr->size += (ptr->sampleCount) * (fieldSize/8);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "int task_statm(struct mm_struct *mm, int *shared, int *text,\n\t       int *data, int *resident)\n{\n\t*shared = get_mm_counter(mm, file_rss);\n\t*text = (PAGE_ALIGN(mm->end_code) - (mm->start_code & PAGE_MASK))\n\t\t\t\t\t\t\t\t>> PAGE_SHIFT;\n\t*data = mm->total_vm - mm->shared_vm;\n\t*resident = *shared + get_mm_counter(mm, anon_rss);\n\treturn mm->total_vm;\n}", "target": 0}
{"code": "void blog_post(char post_path[]) {\n\tif(strlen(post_path) != 0 || post_path[0] == '.'\n\t\t\t|| strchr(post_path, '/') == NULL) {\n\t\tsend_header(\"Content-type\", \"text/plain\");\n\t\tterminate_headers();\n\t\tprintf(\"No, my dear h4xxx0r :)\\nYou won\\'t do that :p\\n\");\n\t\treturn;\n\t}\n\tif(file_exists(post_path) > 0) {\n\t\tstruct blogpost post = make_blogpost(post_path);\n\t\tsend_header(\"Content-type\", \"text/html\");\n\t\tterminate_headers();\n\t\ttemplate_header();\n\t\ttemplate_post_single_entry(post);\n\t} else {\n\t\tsend_header(\"Content-type\", \"text/html\");\n\t\tsend_header(\"Status\", \"404 Not Found\");\n\t\tterminate_headers();\n\t\ttemplate_header();\n\t\ttemplate_error_404();\n\t}\n\ttemplate_footer();\n}", "target": 0}
{"code": "static inline int xrstor_state(struct xsave_struct *fx, u64 mask)\n{\n\tint err = 0;\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\talternative_input(\n\t\t\"1: \" XRSTOR,\n\t\t\"1: \" XRSTORS,\n\t\tX86_FEATURE_XSAVES,\n\t\t\"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t: \"memory\");\n\tasm volatile(\"2:\\n\"\n\t\t     xstate_fault\n\t\t     : \"0\" (0)\n\t\t     : \"memory\");\n\treturn err;\n}", "target": 1}
{"code": "inline TfLiteTensor* GetTensorAtIndex(const TfLiteContext* context,\n                                      int tensor_index) {\n  if (context->tensors != nullptr) {\n    return &context->tensors[tensor_index];\n  } else {\n    return context->GetTensor(context, tensor_index);\n  }\n}", "target": 0}
{"code": "static int db_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\tif (!(svm->vcpu.guest_debug &\n\t      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) &&\n\t\t!svm->nmi_singlestep) {\n\t\tkvm_queue_exception(&svm->vcpu, DB_VECTOR);\n\t\treturn 1;\n\t}\n\tif (svm->nmi_singlestep) {\n\t\tsvm->nmi_singlestep = false;\n\t\tif (!(svm->vcpu.guest_debug & KVM_GUESTDBG_SINGLESTEP))\n\t\t\tsvm->vmcb->save.rflags &=\n\t\t\t\t~(X86_EFLAGS_TF | X86_EFLAGS_RF);\n\t\tupdate_db_bp_intercept(&svm->vcpu);\n\t}\n\tif (svm->vcpu.guest_debug &\n\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) {\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\tkvm_run->debug.arch.pc =\n\t\t\tsvm->vmcb->save.cs.base + svm->vmcb->save.rip;\n\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "static inline const void *choose_neigh_daddr(struct rt6_info *rt,\n\t\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t\t     const void *daddr)\n{\n\tstruct in6_addr *p = &rt->rt6i_gateway;\n\tif (!ipv6_addr_any(p))\n\t\treturn (const void *) p;\n\telse if (skb)\n\t\treturn &ipv6_hdr(skb)->daddr;\n\treturn daddr;\n}", "target": 0}
{"code": "hstore_recv(PG_FUNCTION_ARGS)\n{\n\tint32\t\tbuflen;\n\tHStore\t   *out;\n\tPairs\t   *pairs;\n\tint32\t\ti;\n\tint32\t\tpcount;\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tpcount = pq_getmsgint(buf, 4);\n\tif (pcount == 0)\n\t{\n\t\tout = hstorePairs(NULL, 0, 0);\n\t\tPG_RETURN_POINTER(out);\n\t}\n\tif (pcount < 0 || pcount > MaxAllocSize / sizeof(Pairs))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t  errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t pcount, (int) (MaxAllocSize / sizeof(Pairs)))));\n\tpairs = palloc(pcount * sizeof(Pairs));\n\tfor (i = 0; i < pcount; ++i)\n\t{\n\t\tint\t\t\trawlen = pq_getmsgint(buf, 4);\n\t\tint\t\t\tlen;\n\t\tif (rawlen < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"null value not allowed for hstore key\")));\n\t\tpairs[i].key = pq_getmsgtext(buf, rawlen, &len);\n\t\tpairs[i].keylen = hstoreCheckKeyLen(len);\n\t\tpairs[i].needfree = true;\n\t\trawlen = pq_getmsgint(buf, 4);\n\t\tif (rawlen < 0)\n\t\t{\n\t\t\tpairs[i].val = NULL;\n\t\t\tpairs[i].vallen = 0;\n\t\t\tpairs[i].isnull = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpairs[i].val = pq_getmsgtext(buf, rawlen, &len);\n\t\t\tpairs[i].vallen = hstoreCheckValLen(len);\n\t\t\tpairs[i].isnull = false;\n\t\t}\n\t}\n\tpcount = hstoreUniquePairs(pairs, pcount, &buflen);\n\tout = hstorePairs(pairs, pcount, buflen);\n\tPG_RETURN_POINTER(out);\n}", "target": 0}
{"code": "mrb_class_real(struct RClass* cl)\n{\n  if (cl == 0)\n    return NULL;\n  while ((cl->tt == MRB_TT_SCLASS) || (cl->tt == MRB_TT_ICLASS)) {\n    cl = cl->super;\n  }\n  return cl;\n}", "target": 1}
{"code": "static int __init ipip_init(void)\n{\n\tint err;\n\tprintk(banner);\n\tif (xfrm4_tunnel_register(&ipip_handler, AF_INET)) {\n\t\tprintk(KERN_INFO \"ipip init: can't register tunnel\\n\");\n\t\treturn -EAGAIN;\n\t}\n\terr = register_pernet_device(&ipip_net_ops);\n\tif (err)\n\t\txfrm4_tunnel_deregister(&ipip_handler, AF_INET);\n\treturn err;\n}", "target": 1}
{"code": "void BezierOval(double w, double h, char *action)\n{\n    char *outpos = outputbuffer;\n    outpos +=\n    sprintf(outpos,\" %12.3f 0 m %12.3f %12.3f %12.3f %12.3f 0 %12.3f c\\n\",-w,-w,h*BzK,-w*BzK,h,h);\n    outpos +=\n    sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f %12.3f 0 c\\n\",w*BzK,h,w,h*BzK,w);\n    outpos +=\n    sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f 0 %12.3f c\\n\",w,-h*BzK,w*BzK,-h,-h);\n    outpos +=\n    sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f %12.3f 0 c %s\\n\",-w*BzK,-h,-w,-h*BzK,-w,action);\n    sendClean(outputbuffer);\n}", "target": 0}
{"code": "static int fsmDoMkDir(rpmPlugins plugins, int dirfd, const char *dn,\n\t\t\tint owned, mode_t mode)\n{\n    int rc;\n    rpmFsmOp op = (FA_CREATE);\n    if (!owned)\n\top |= FAF_UNOWNED;\n    rc = rpmpluginsCallFsmFilePre(plugins, NULL, dn, mode, op);\n    if (!rc)\n\trc = fsmMkdir(dirfd, dn, mode);\n    if (!rc) {\n\trc = rpmpluginsCallFsmFilePrepare(plugins, NULL, dn, dn, mode, op);\n    }\n    rpmpluginsCallFsmFilePost(plugins, NULL, dn, mode, op, rc);\n    if (!rc) {\n\trpmlog(RPMLOG_DEBUG,\n\t\t\"%s directory created with perms %04o\\n\",\n\t\tdn, (unsigned)(mode & 07777));\n    }\n    return rc;\n}", "target": 0}
{"code": "void PropertiesWidget::loadTorrentInfos(BitTorrent::TorrentHandle *const torrent)\n{\n    clear();\n    m_torrent = torrent;\n    downloaded_pieces->setTorrent(m_torrent);\n    pieces_availability->setTorrent(m_torrent);\n    if (!m_torrent) return;\n    updateSavePath(m_torrent);\n    hash_lbl->setText(m_torrent->hash());\n    PropListModel->model()->clear();\n    if (m_torrent->hasMetadata()) {\n        lbl_creationDate->setText(m_torrent->creationDate().toString(Qt::DefaultLocaleShortDate));\n        label_total_size_val->setText(Utils::Misc::friendlyUnit(m_torrent->totalSize()));\n        comment_text->setText(Utils::Misc::parseHtmlLinks(m_torrent->comment()));\n        loadUrlSeeds();\n        label_created_by_val->setText(m_torrent->creator());\n        PropListModel->model()->setupModelData(m_torrent->info());\n        filesList->setExpanded(PropListModel->index(0, 0), true);\n        PropListModel->model()->updateFilesPriorities(m_torrent->filePriorities());\n    }\n    loadDynamicData();\n}", "target": 1}
{"code": "tlb_update_vma_flags(struct mmu_gather *tlb, struct vm_area_struct *vma) { }", "target": 1}
{"code": "static struct inode *ext4_alloc_inode(struct super_block *sb)\n{\n\tstruct ext4_inode_info *ei;\n\tei = kmem_cache_alloc(ext4_inode_cachep, GFP_NOFS);\n\tif (!ei)\n\t\treturn NULL;\n\tei->vfs_inode.i_version = 1;\n\tei->vfs_inode.i_data.writeback_index = 0;\n\tmemset(&ei->i_cached_extent, 0, sizeof(struct ext4_ext_cache));\n\tINIT_LIST_HEAD(&ei->i_prealloc_list);\n\tspin_lock_init(&ei->i_prealloc_lock);\n\tjbd2_journal_init_jbd_inode(&ei->jinode, &ei->vfs_inode);\n\tei->i_reserved_data_blocks = 0;\n\tei->i_reserved_meta_blocks = 0;\n\tei->i_allocated_meta_blocks = 0;\n\tei->i_da_metadata_calc_len = 0;\n\tei->i_delalloc_reserved_flag = 0;\n\tspin_lock_init(&(ei->i_block_reservation_lock));\n#ifdef CONFIG_QUOTA\n\tei->i_reserved_quota = 0;\n#endif\n\tINIT_LIST_HEAD(&ei->i_completed_io_list);\n\tspin_lock_init(&ei->i_completed_io_lock);\n\tei->cur_aio_dio = NULL;\n\tei->i_sync_tid = 0;\n\tei->i_datasync_tid = 0;\n\treturn &ei->vfs_inode;\n}", "target": 0}
{"code": "raw_copy_from_user(void *to, const void __user *from, unsigned long n)\n{\n\tif (__builtin_constant_p(n)) {\n\t\tunsigned long ret;\n\t\tswitch (n) {\n\t\tcase 1:\n\t\t\tret = 0;\n\t\t\t__uaccess_begin_nospec();\n\t\t\t__get_user_asm_nozero(*(u8 *)to, from, ret,\n\t\t\t\t\t      \"b\", \"b\", \"=q\", 1);\n\t\t\t__uaccess_end();\n\t\t\treturn ret;\n\t\tcase 2:\n\t\t\tret = 0;\n\t\t\t__uaccess_begin_nospec();\n\t\t\t__get_user_asm_nozero(*(u16 *)to, from, ret,\n\t\t\t\t\t      \"w\", \"w\", \"=r\", 2);\n\t\t\t__uaccess_end();\n\t\t\treturn ret;\n\t\tcase 4:\n\t\t\tret = 0;\n\t\t\t__uaccess_begin_nospec();\n\t\t\t__get_user_asm_nozero(*(u32 *)to, from, ret,\n\t\t\t\t\t      \"l\", \"k\", \"=r\", 4);\n\t\t\t__uaccess_end();\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn __copy_user_ll(to, (__force const void *)from, n);\n}", "target": 1}
{"code": "static void sample_to_timespec(const clockid_t which_clock,\n\t\t\t       union cpu_time_count cpu,\n\t\t\t       struct timespec *tp)\n{\n\tif (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED) {\n\t\ttp->tv_sec = div_long_long_rem(cpu.sched,\n\t\t\t\t\t       NSEC_PER_SEC, &tp->tv_nsec);\n\t} else {\n\t\tcputime_to_timespec(cpu.cpu, tp);\n\t}\n}", "target": 1}
{"code": "static BOOL rectangle_contained_in_band(const RECTANGLE_16* band, const RECTANGLE_16* endPtr,\n                                        const RECTANGLE_16* rect)\n{\n\tUINT16 refY = band->top;\n\tif ((band->top > rect->top) || (rect->bottom > band->bottom))\n\t\treturn FALSE;\n\twhile ((band < endPtr) && (band->top == refY) && (band->left <= rect->left))\n\t{\n\t\tif (rect->right <= band->right)\n\t\t\treturn TRUE;\n\t\tband++;\n\t}\n\treturn FALSE;\n}", "target": 0}
{"code": "static void ResetPixelList(PixelList *pixel_list)\n{\n  int\n    level;\n  register SkipNode\n    *root;\n  register SkipList\n    *p;\n  p=(&pixel_list->skip_list);\n  root=p->nodes+65536UL;\n  p->level=0;\n  for (level=0; level < 9; level++)\n    root->next[level]=65536UL;\n  pixel_list->seed=pixel_list->signature++;\n}", "target": 0}
{"code": "  bool ms_verify_authorizer(Connection *con, int peer_type,\n\t\t\t\t    int protocol, bufferlist& authorizer,\n\t\t\t\t    bufferlist& authorizer_reply,\n\t\t\t\t    bool& isvalid, CryptoKey& session_key) override {\n    isvalid = true;\n    return true;\n  };", "target": 1}
{"code": "static void ToPropertyDescriptor(js_State *J, js_Object *obj, const char *name, js_Object *desc)\n{\n\tint haswritable = 0;\n\tint hasvalue = 0;\n\tint enumerable = 0;\n\tint configurable = 0;\n\tint writable = 0;\n\tint atts = 0;\n\tjs_pushobject(J, obj);\n\tjs_pushobject(J, desc);\n\tif (js_hasproperty(J, -1, \"writable\")) {\n\t\thaswritable = 1;\n\t\twritable = js_toboolean(J, -1);\n\t\tjs_pop(J, 1);\n\t}\n\tif (js_hasproperty(J, -1, \"enumerable\")) {\n\t\tenumerable = js_toboolean(J, -1);\n\t\tjs_pop(J, 1);\n\t}\n\tif (js_hasproperty(J, -1, \"configurable\")) {\n\t\tconfigurable = js_toboolean(J, -1);\n\t\tjs_pop(J, 1);\n\t}\n\tif (js_hasproperty(J, -1, \"value\")) {\n\t\thasvalue = 1;\n\t\tjs_setproperty(J, -3, name);\n\t}\n\tif (!writable) atts |= JS_READONLY;\n\tif (!enumerable) atts |= JS_DONTENUM;\n\tif (!configurable) atts |= JS_DONTCONF;\n\tif (js_hasproperty(J, -1, \"get\")) {\n\t\tif (haswritable || hasvalue)\n\t\t\tjs_typeerror(J, \"value/writable and get/set attributes are exclusive\");\n\t} else {\n\t\tjs_pushundefined(J);\n\t}\n\tif (js_hasproperty(J, -2, \"set\")) {\n\t\tif (haswritable || hasvalue)\n\t\t\tjs_typeerror(J, \"value/writable and get/set attributes are exclusive\");\n\t} else {\n\t\tjs_pushundefined(J);\n\t}\n\tjs_defaccessor(J, -4, name, atts);\n\tjs_pop(J, 2);\n}", "target": 1}
{"code": "static void hugetlb_vm_op_close(struct vm_area_struct *vma)\n{\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct resv_map *reservations = vma_resv_map(vma);\n\tstruct hugepage_subpool *spool = subpool_vma(vma);\n\tunsigned long reserve;\n\tunsigned long start;\n\tunsigned long end;\n\tif (reservations) {\n\t\tstart = vma_hugecache_offset(h, vma, vma->vm_start);\n\t\tend = vma_hugecache_offset(h, vma, vma->vm_end);\n\t\treserve = (end - start) -\n\t\t\tregion_count(&reservations->regions, start, end);\n\t\tresv_map_put(vma);\n\t\tif (reserve) {\n\t\t\thugetlb_acct_memory(h, -reserve);\n\t\t\thugepage_subpool_put_pages(spool, reserve);\n\t\t}\n\t}\n}", "target": 0}
{"code": "bool CMerkleTx::AcceptToMemoryPool(CTxDB &txdb, bool fCheckInputs) {\n    return(CTransaction::AcceptToMemoryPool(txdb, fCheckInputs));\n}", "target": 1}
{"code": "validate_group(struct perf_event *event)\n{\n\tstruct perf_event *sibling, *leader = event->group_leader;\n\tstruct pmu_hw_events fake_pmu;\n\tDECLARE_BITMAP(fake_used_mask, ARMPMU_MAX_HWEVENTS);\n\tmemset(fake_used_mask, 0, sizeof(fake_used_mask));\n\tfake_pmu.used_mask = fake_used_mask;\n\tif (!validate_event(&fake_pmu, leader))\n\t\treturn -EINVAL;\n\tlist_for_each_entry(sibling, &leader->sibling_list, group_entry) {\n\t\tif (!validate_event(&fake_pmu, sibling))\n\t\t\treturn -EINVAL;\n\t}\n\tif (!validate_event(&fake_pmu, event))\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "static int mon_bin_mmap(struct file *filp, struct vm_area_struct *vma)\n{\n\tvma->vm_ops = &mon_bin_vm_ops;\n\tif (vma->vm_flags & VM_WRITE)\n\t\treturn -EPERM;\n\tvma->vm_flags &= ~VM_MAYWRITE;\n\tvma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;\n\tvma->vm_private_data = filp->private_data;\n\tmon_bin_vma_open(vma);\n\treturn 0;\n}", "target": 0}
{"code": "krb5_gss_inquire_sec_context_by_oid (OM_uint32 *minor_status,\n                                     const gss_ctx_id_t context_handle,\n                                     const gss_OID desired_object,\n                                     gss_buffer_set_t *data_set)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    size_t i;\n    if (minor_status == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n    *minor_status = 0;\n    if (desired_object == GSS_C_NO_OID)\n        return GSS_S_CALL_INACCESSIBLE_READ;\n    if (data_set == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n    *data_set = GSS_C_NO_BUFFER_SET;\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n    if (!ctx->established)\n        return GSS_S_NO_CONTEXT;\n    for (i = 0; i < sizeof(krb5_gss_inquire_sec_context_by_oid_ops)/\n             sizeof(krb5_gss_inquire_sec_context_by_oid_ops[0]); i++) {\n        if (g_OID_prefix_equal(desired_object, &krb5_gss_inquire_sec_context_by_oid_ops[i].oid)) {\n            return (*krb5_gss_inquire_sec_context_by_oid_ops[i].func)(minor_status,\n                                                                      context_handle,\n                                                                      desired_object,\n                                                                      data_set);\n        }\n    }\n    *minor_status = EINVAL;\n    return GSS_S_UNAVAILABLE;\n}", "target": 1}
{"code": "atmarp_tpaddr_print(netdissect_options *ndo,\n\t\t    const struct atmarp_pkthdr *ap, u_short pro)\n{\n\tif (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)\n\t\tND_PRINT((ndo, \"<wrong proto type>\"));\n\telse if (ATMTPROTO_LEN(ap) != 4)\n\t\tND_PRINT((ndo, \"<wrong tplen>\"));\n\telse\n\t\tND_PRINT((ndo, \"%s\", ipaddr_string(ndo, ATMTPA(ap))));\n}", "target": 0}
{"code": "CString CZNC::FixupEncoding(const CString& sEncoding) const {\n    if (sEncoding.empty() && m_uiForceEncoding) {\n        return \"UTF-8\";\n    }\n    return sEncoding;\n}", "target": 1}
{"code": "v8::Local<v8::Object> CreateNativeEvent(\n    v8::Isolate* isolate,\n    v8::Local<v8::Object> sender,\n    content::RenderFrameHost* frame,\n    electron::mojom::ElectronBrowser::MessageSyncCallback callback) {\n  v8::Local<v8::Object> event;\n  if (frame && callback) {\n    gin::Handle<Event> native_event = Event::Create(isolate);\n    native_event->SetCallback(std::move(callback));\n    event = v8::Local<v8::Object>::Cast(native_event.ToV8());\n  } else {\n    event = CreateEvent(isolate);\n  }\n  Dictionary dict(isolate, event);\n  dict.Set(\"sender\", sender);\n  if (frame)\n    dict.Set(\"frameId\", frame->GetRoutingID());\n  return event;\n}", "target": 1}
{"code": "static CACHE_BITMAP_V3_ORDER* update_read_cache_bitmap_v3_order(rdpUpdate* update, wStream* s,\n                                                                UINT16 flags)\n{\n\tBOOL rc;\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\tUINT32 new_len;\n\tBYTE* new_data;\n\tCACHE_BITMAP_V3_ORDER* cache_bitmap_v3;\n\tif (!update || !s)\n\t\treturn NULL;\n\tcache_bitmap_v3 = calloc(1, sizeof(CACHE_BITMAP_V3_ORDER));\n\tif (!cache_bitmap_v3)\n\t\tgoto fail;\n\tcache_bitmap_v3->cacheId = flags & 0x00000003;\n\tcache_bitmap_v3->flags = (flags & 0x0000FF80) >> 7;\n\tbitsPerPixelId = (flags & 0x00000078) >> 3;\n\tcache_bitmap_v3->bpp = get_cbr2_bpp(bitsPerPixelId, &rc);\n\tif (!rc)\n\t\tgoto fail;\n\tif (Stream_GetRemainingLength(s) < 21)\n\t\tgoto fail;\n\tStream_Read_UINT16(s, cache_bitmap_v3->cacheIndex); \n\tStream_Read_UINT32(s, cache_bitmap_v3->key1);       \n\tStream_Read_UINT32(s, cache_bitmap_v3->key2);       \n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tStream_Read_UINT8(s, bitmapData->bpp);\n\tif ((bitmapData->bpp < 1) || (bitmapData->bpp > 32))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"invalid bpp value %\" PRIu32 \"\", bitmapData->bpp);\n\t\tgoto fail;\n\t}\n\tStream_Seek_UINT8(s);                      \n\tStream_Seek_UINT8(s);                      \n\tStream_Read_UINT8(s, bitmapData->codecID); \n\tStream_Read_UINT16(s, bitmapData->width);  \n\tStream_Read_UINT16(s, bitmapData->height); \n\tStream_Read_UINT32(s, new_len);            \n\tif ((new_len == 0) || (Stream_GetRemainingLength(s) < new_len))\n\t\tgoto fail;\n\tnew_data = (BYTE*)realloc(bitmapData->data, new_len);\n\tif (!new_data)\n\t\tgoto fail;\n\tbitmapData->data = new_data;\n\tbitmapData->length = new_len;\n\tStream_Read(s, bitmapData->data, bitmapData->length);\n\treturn cache_bitmap_v3;\nfail:\n\tfree_cache_bitmap_v3_order(update->context, cache_bitmap_v3);\n\treturn NULL;\n}", "target": 0}
{"code": "void mk_request_free(struct session_request *sr)\n{\n    if (sr->fd_file > 0) {\n        mk_vhost_close(sr);\n    }\n    if (sr->headers.location) {\n        mk_mem_free(sr->headers.location);\n    }\n    if (sr->uri_processed.data != sr->uri.data) {\n        mk_ptr_free(&sr->uri_processed);\n    }\n    if (sr->real_path.data != sr->real_path_static) {\n        mk_ptr_free(&sr->real_path);\n    }\n}", "target": 1}
{"code": "\t\tvoid Phase2() final {\n\t\t\tLocal<Context> context_handle = Deref(context);\n\t\t\tContext::Scope context_scope{context_handle};\n\t\t\tLocal<Object> object = Local<Object>::Cast(Deref(reference));\n\t\t\tresult = Unmaybe(object->Delete(context_handle, key->CopyInto()));\n\t\t}", "target": 1}
{"code": "static void context__cleanup_out_packets(struct mosquitto *context)\n{\n\tstruct mosquitto__packet *packet;\n\tif(!context) return;\n\tif(context->current_out_packet){\n\t\tpacket__cleanup(context->current_out_packet);\n\t\tmosquitto__free(context->current_out_packet);\n\t\tcontext->current_out_packet = NULL;\n\t}\n\twhile(context->out_packet){\n\t\tpacket__cleanup(context->out_packet);\n\t\tpacket = context->out_packet;\n\t\tcontext->out_packet = context->out_packet->next;\n\t\tmosquitto__free(packet);\n\t}\n\tcontext->out_packet_count = 0;\n}", "target": 0}
{"code": "  void readEOF() noexcept override {\n    LOG(INFO) << \"Got EOF\";\n    auto chain = IOBuf::create(0);\n    for (size_t i = 0; i < 1000 * 1000; i++) {\n      auto buf = IOBuf::create(10);\n      buf->append(10);\n      memset(buf->writableData(), 'x', 10);\n      chain->prependChain(std::move(buf));\n    }\n    socket_->writeChain(&writeCallback_, std::move(chain));\n  }", "target": 0}
{"code": "lys_restr_dup(struct lys_module *mod, struct lys_restr *old, int size, int shallow, struct unres_schema *unres)\n{\n    struct lys_restr *result;\n    int i;\n    if (!size) {\n        return NULL;\n    }\n    result = calloc(size, sizeof *result);\n    LY_CHECK_ERR_RETURN(!result, LOGMEM(mod->ctx), NULL);\n    for (i = 0; i < size; i++) {\n        result[i].ext_size = old[i].ext_size;\n        lys_ext_dup(mod->ctx, mod, old[i].ext, old[i].ext_size, &result[i], LYEXT_PAR_RESTR, &result[i].ext, shallow, unres);\n        result[i].expr = lydict_insert(mod->ctx, old[i].expr, 0);\n        result[i].dsc = lydict_insert(mod->ctx, old[i].dsc, 0);\n        result[i].ref = lydict_insert(mod->ctx, old[i].ref, 0);\n        result[i].eapptag = lydict_insert(mod->ctx, old[i].eapptag, 0);\n        result[i].emsg = lydict_insert(mod->ctx, old[i].emsg, 0);\n    }\n    return result;\n}", "target": 1}
{"code": "static void unbound_resolver_callback(void *data, int err, struct ub_result *ub_result)\n{\n\tstruct ast_dns_query *query = data;\n\tif (!ub_result) {\n\t\tast_debug(3, \"Badly formatted DNS query '%s'\\n\", ast_dns_query_get_name(query));\n\t\tast_dns_resolver_set_result(query, 0, 0, ns_r_formerr, ast_dns_query_get_name(query), \"\", 0);\n\t\tast_dns_resolver_completed(query);\n\t\tao2_ref(query, -1);\n\t\treturn;\n\t}\n\tif (!ast_dns_resolver_set_result(query, ub_result->secure, ub_result->bogus, ub_result->rcode,\n\t\tS_OR(ub_result->canonname, ast_dns_query_get_name(query)), ub_result->answer_packet, ub_result->answer_len)) {\n\t\tint i;\n\t\tchar *result_data;\n\t\tfor (i = 0; (result_data = ub_result->data[i]); i++) {\n\t\t\tif (ast_dns_resolver_add_record(query, ub_result->qtype, ub_result->qclass, ub_result->ttl,\n\t\t\t\tresult_data, ub_result->len[i])) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tast_dns_resolver_completed(query);\n\tao2_ref(query, -1);\n\tub_resolve_free(ub_result);\n}", "target": 0}
{"code": "static void naldmx_switch_timestamps(GF_NALUDmxCtx *ctx, GF_FilterPacket *pck)\n{\n\tif (!ctx->notime) {\n\t\tu64 ts = gf_filter_pck_get_cts(pck);\n\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\tctx->prev_cts = ctx->cts;\n\t\t\tctx->cts = ts;\n\t\t}\n\t\tts = gf_filter_pck_get_dts(pck);\n\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\tif (ctx->full_au_source) {\n\t\t\t\tctx->prev_dts = ctx->dts;\n\t\t\t\tctx->dts = ts;\n\t\t\t} else {\n\t\t\t\tGF_FilterClockType ck_type = gf_filter_pid_get_clock_info(ctx->ipid, NULL, NULL);\n\t\t\t\tif (ck_type==GF_FILTER_CLOCK_PCR_DISC)\n\t\t\t\t\tctx->dts = ts;\n\t\t\t\telse if (ctx->dts<ts)\n\t\t\t\t\tctx->dts=ts;\n\t\t\t\tif (!ctx->prev_dts) ctx->prev_dts = ts;\n\t\t\t\telse if (ctx->prev_dts != ts) {\n\t\t\t\t\tu64 diff = ts;\n\t\t\t\t\tdiff -= ctx->prev_dts;\n\t\t\t\t\tif (!ctx->cur_fps.den)\n\t\t\t\t\t\tctx->cur_fps.den = (u32) diff;\n\t\t\t\t\telse if (ctx->cur_fps.den > diff)\n\t\t\t\t\t\tctx->cur_fps.den = (u32) diff;\n\t\t\t\t\tctx->prev_dts = ts;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tctx->pck_duration = gf_filter_pck_get_duration(pck);\n\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\tctx->src_pck = pck;\n\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t\tgf_filter_pck_get_framing(pck, &ctx->input_is_au_start, NULL);\n\t}\n}", "target": 0}
{"code": "int nfc_dev_down(struct nfc_dev *dev)\n{\n\tint rc = 0;\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->dev_up) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\tif (dev->polling || dev->active_target) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (dev->ops->dev_down)\n\t\tdev->ops->dev_down(dev);\n\tdev->dev_up = false;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "static pj_status_t get_name(int rec_counter, const pj_uint8_t *pkt, \n                            const pj_uint8_t *start, const pj_uint8_t *max,\n                            pj_str_t *name)\n{\n    const pj_uint8_t *p;\n    pj_status_t status;\n    if (rec_counter > 10) {\n        return PJLIB_UTIL_EDNSINNAMEPTR;\n    }\n    if (start >= max)\n        return PJLIB_UTIL_EDNSINNAMEPTR;\n    p = start;\n    while (*p) {\n        if ((*p & 0xc0) == 0xc0) {\n            pj_uint16_t offset;\n            pj_memcpy(&offset, p, 2);\n            offset ^= pj_htons((pj_uint16_t)(0xc0 << 8));\n            offset = pj_ntohs(offset);\n            if (offset >= max - pkt)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n            status = get_name(rec_counter+1, pkt, pkt + offset, max, name);\n            if (status != PJ_SUCCESS)\n                return status;\n            return PJ_SUCCESS;\n        } else {\n            unsigned label_len = *p;\n            if (p+1+label_len+1 > max)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n            pj_memcpy(name->ptr + name->slen, p+1, label_len);\n            name->slen += label_len;\n            p += label_len + 1;\n            if (*p != 0) {\n                *(name->ptr + name->slen) = '.';\n                ++name->slen;\n            }\n        }\n    }\n    return PJ_SUCCESS;\n}", "target": 0}
{"code": "device_linux_md_stop_authorized_cb (Daemon *daemon,\n                                    Device *device,\n                                    DBusGMethodInvocation *context,\n                                    const gchar *action_id,\n                                    guint num_user_data,\n                                    gpointer *user_data_elements)\n{\n  int n;\n  char *argv[10];\n  GError *error;\n  n = 0;\n  argv[n++] = \"mdadm\";\n  argv[n++] = \"--stop\";\n  argv[n++] = device->priv->device_file;\n  argv[n++] = NULL;\n  error = NULL;\n  if (!job_new (context, \"LinuxMdStop\", TRUE, device, argv, NULL, linux_md_stop_completed_cb, FALSE, NULL, NULL))\n    {\n      goto out;\n    }\n out:\n  ;\n}", "target": 0}
{"code": "static int __init acpi_custom_method_init(void)\n{\n\tif (acpi_debugfs_dir == NULL)\n\t\treturn -ENOENT;\n\tcm_dentry = debugfs_create_file(\"custom_method\", S_IWUSR,\n\t\t\t\t\tacpi_debugfs_dir, NULL, &cm_fops);\n\tif (cm_dentry == NULL)\n\t\treturn -ENODEV;\n\treturn 0;\n}", "target": 0}
{"code": "int mb2_cache_entry_create(struct mb2_cache *cache, gfp_t mask, u32 key,\n\t\t\t   sector_t block)\n{\n\tstruct mb2_cache_entry *entry, *dup;\n\tstruct hlist_bl_node *dup_node;\n\tstruct hlist_bl_head *head;\n\tentry = kmem_cache_alloc(mb2_entry_cache, mask);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\tINIT_LIST_HEAD(&entry->e_lru_list);\n\tatomic_set(&entry->e_refcnt, 1);\n\tentry->e_key = key;\n\tentry->e_block = block;\n\thead = &cache->c_hash[hash_32(key, cache->c_bucket_bits)];\n\tentry->e_hash_list_head = head;\n\thlist_bl_lock(head);\n\thlist_bl_for_each_entry(dup, dup_node, head, e_hash_list) {\n\t\tif (dup->e_key == key && dup->e_block == block) {\n\t\t\thlist_bl_unlock(head);\n\t\t\tkmem_cache_free(mb2_entry_cache, entry);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\thlist_bl_add_head(&entry->e_hash_list, head);\n\thlist_bl_unlock(head);\n\tspin_lock(&cache->c_lru_list_lock);\n\tlist_add_tail(&entry->e_lru_list, &cache->c_lru_list);\n\tatomic_inc(&entry->e_refcnt);\n\tcache->c_entry_count++;\n\tspin_unlock(&cache->c_lru_list_lock);\n\treturn 0;\n}", "target": 0}
{"code": "static void lwp_write(FILE *fout, const std::string &buf) {\n  size_t len = buf.length();\n  fwrite(&len, sizeof(len), 1, fout);\n  fwrite(buf.c_str(), sizeof(buf[0]), len, fout);\n  fflush(fout);\n}", "target": 0}
{"code": "int dns_HTTPS_add_ipv4hint(struct dns_rr_nested *svcparam, unsigned char addr[][DNS_RR_A_LEN], int addr_num)\n{\n\tif (_dns_left_len(&svcparam->context) < 4 + addr_num * DNS_RR_A_LEN) {\n\t\treturn -1;\n\t}\n\tunsigned short value = DNS_HTTPS_T_IPV4HINT;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tvalue = addr_num * DNS_RR_A_LEN;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tfor (int i = 0; i < addr_num; i++) {\n\t\tdns_add_rr_nested_memcpy(svcparam, addr[i], DNS_RR_A_LEN);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "bfad_im_get_stats(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tstruct bfad_hal_comp fcomp;\n\tunion bfa_port_stats_u *fcstats;\n\tstruct fc_host_statistics *hstats;\n\tbfa_status_t    rc;\n\tunsigned long   flags;\n\tfcstats = kzalloc(sizeof(union bfa_port_stats_u), GFP_KERNEL);\n\tif (fcstats == NULL)\n\t\treturn NULL;\n\thstats = &bfad->link_stats;\n\tinit_completion(&fcomp.comp);\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tmemset(hstats, 0, sizeof(struct fc_host_statistics));\n\trc = bfa_port_get_stats(BFA_FCPORT(&bfad->bfa),\n\t\t\t\tfcstats, bfad_hcb_comp, &fcomp);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\tif (rc != BFA_STATUS_OK)\n\t\treturn NULL;\n\twait_for_completion(&fcomp.comp);\n\thstats->seconds_since_last_reset = fcstats->fc.secs_reset;\n\thstats->tx_frames = fcstats->fc.tx_frames;\n\thstats->tx_words  = fcstats->fc.tx_words;\n\thstats->rx_frames = fcstats->fc.rx_frames;\n\thstats->rx_words  = fcstats->fc.rx_words;\n\thstats->lip_count = fcstats->fc.lip_count;\n\thstats->nos_count = fcstats->fc.nos_count;\n\thstats->error_frames = fcstats->fc.error_frames;\n\thstats->dumped_frames = fcstats->fc.dropped_frames;\n\thstats->link_failure_count = fcstats->fc.link_failures;\n\thstats->loss_of_sync_count = fcstats->fc.loss_of_syncs;\n\thstats->loss_of_signal_count = fcstats->fc.loss_of_signals;\n\thstats->prim_seq_protocol_err_count = fcstats->fc.primseq_errs;\n\thstats->invalid_crc_count = fcstats->fc.invalid_crcs;\n\tkfree(fcstats);\n\treturn hstats;\n}", "target": 1}
{"code": "socket_accept(const int sock)\n{\n        struct sockaddr_storage addrin;\n        socklen_t addrinlen = sizeof(addrin);\n        int net;\n        net = accept(sock, (struct sockaddr *) &addrin, &addrinlen);\n        if (net < 0) {\n                err_nonfatal(\"Failed to accept socket connection: %m\");\n        }\n        return net;\n}", "target": 0}
{"code": "QPDFWriter::enqueueObject(QPDFObjectHandle object)\n{\n    if (object.isIndirect())\n    {\n        if (object.getOwningQPDF() != &(this->pdf))\n        {\n            QTC::TC(\"qpdf\", \"QPDFWriter foreign object\");\n            throw std::logic_error(\n                \"QPDFObjectHandle from different QPDF found while writing.\"\n                \"  Use QPDF::copyForeignObject to add objects from\"\n                \" another file.\");\n        }\n\tQPDFObjGen og = object.getObjGen();\n\tif (obj_renumber.count(og) == 0)\n\t{\n\t    if (this->object_to_object_stream.count(og))\n\t    {\n\t\tint stream_id = this->object_to_object_stream[og];\n                obj_renumber[og] = 0;\n\t\tenqueueObject(this->pdf.getObjectByID(stream_id, 0));\n\t    }\n\t    else\n\t    {\n\t\tobject_queue.push_back(object);\n\t\tobj_renumber[og] = next_objid++;\n\t\tif ((og.getGen() == 0) &&\n                    this->object_stream_to_objects.count(og.getObj()))\n\t\t{\n\t\t    if (! this->linearized)\n\t\t    {\n\t\t\tassignCompressedObjectNumbers(og);\n\t\t    }\n\t\t}\n\t\telse if ((! this->direct_stream_lengths) && object.isStream())\n\t\t{\n\t\t    ++next_objid;\n\t\t}\n\t    }\n\t}\n        else if (obj_renumber[og] == 0)\n        {\n            QTC::TC(\"qpdf\", \"QPDFWriter ignore self-referential object stream\");\n        }\n    }\n    else if (object.isArray())\n    {\n\tint n = object.getArrayNItems();\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t    if (! this->linearized)\n\t    {\n\t\tenqueueObject(object.getArrayItem(i));\n\t    }\n\t}\n    }\n    else if (object.isDictionary())\n    {\n\tstd::set<std::string> keys = object.getKeys();\n\tfor (std::set<std::string>::iterator iter = keys.begin();\n\t     iter != keys.end(); ++iter)\n\t{\n\t    if (! this->linearized)\n\t    {\n\t\tenqueueObject(object.getKey(*iter));\n\t    }\n\t}\n    }\n    else\n    {\n    }\n}", "target": 0}
{"code": "static void prep_write_cb(struct bt_att_chan *chan, uint8_t opcode,\n\t\t\t\t\tconst void *pdu, uint16_t length,\n\t\t\t\t\tvoid *user_data)\n{\n\tstruct bt_gatt_server *server = user_data;\n\tuint16_t handle = 0;\n\tuint16_t offset;\n\tstruct gatt_db_attribute *attr;\n\tstruct prep_write_complete_data *pwcd;\n\tuint8_t ecode, status;\n\tif (length < 4) {\n\t\tecode = BT_ATT_ERROR_INVALID_PDU;\n\t\tgoto error;\n\t}\n\tif (queue_length(server->prep_queue) >= server->max_prep_queue_len) {\n\t\tecode = BT_ATT_ERROR_PREPARE_QUEUE_FULL;\n\t\tgoto error;\n\t}\n\thandle = get_le16(pdu);\n\toffset = get_le16(pdu + 2);\n\tattr = gatt_db_get_attribute(server->db, handle);\n\tif (!attr) {\n\t\tecode = BT_ATT_ERROR_INVALID_HANDLE;\n\t\tgoto error;\n\t}\n\tutil_debug(server->debug_callback, server->debug_data,\n\t\t\t\t\"Prep Write Req - handle: 0x%04x\", handle);\n\tecode = check_length(length, offset);\n\tif (ecode)\n\t\tgoto error;\n\tecode = check_permissions(server, attr, BT_ATT_PERM_WRITE_MASK);\n\tif (ecode)\n\t\tgoto error;\n\tpwcd = new0(struct prep_write_complete_data, 1);\n\tpwcd->chan = chan;\n\tpwcd->pdu = malloc(length);\n\tmemcpy(pwcd->pdu, pdu, length);\n\tpwcd->length = length;\n\tpwcd->server = server;\n\tstatus = gatt_db_attribute_write(attr, offset, NULL, 0,\n\t\t\t\t\t\tBT_ATT_OP_PREP_WRITE_REQ,\n\t\t\t\t\t\tserver->att,\n\t\t\t\t\t\tprep_write_complete_cb, pwcd);\n\tif (status)\n\t\treturn;\n\tecode = BT_ATT_ERROR_UNLIKELY;\nerror:\n\tbt_att_chan_send_error_rsp(chan, opcode, handle, ecode);\n}", "target": 0}
{"code": "static int __poke_user(struct task_struct *child, addr_t addr, addr_t data)\n{\n\tstruct user *dummy = NULL;\n\taddr_t offset;\n\tif (addr < (addr_t) &dummy->regs.acrs) {\n\t\tif (addr == (addr_t) &dummy->regs.psw.mask) {\n\t\t\tunsigned long mask = PSW_MASK_USER;\n\t\t\tmask |= is_ri_task(child) ? PSW_MASK_RI : 0;\n\t\t\tif ((data & ~mask) != PSW_USER_BITS)\n\t\t\t\treturn -EINVAL;\n\t\t\tif ((data & PSW_MASK_EA) && !(data & PSW_MASK_BA))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\t*(addr_t *)((addr_t) &task_pt_regs(child)->psw + addr) = data;\n\t} else if (addr < (addr_t) (&dummy->regs.orig_gpr2)) {\n\t\toffset = addr - (addr_t) &dummy->regs.acrs;\n#ifdef CONFIG_64BIT\n\t\tif (addr == (addr_t) &dummy->regs.acrs[15])\n\t\t\tchild->thread.acrs[15] = (unsigned int) (data >> 32);\n\t\telse\n#endif\n\t\t*(addr_t *)((addr_t) &child->thread.acrs + offset) = data;\n\t} else if (addr == (addr_t) &dummy->regs.orig_gpr2) {\n\t\ttask_pt_regs(child)->orig_gpr2 = data;\n\t} else if (addr < (addr_t) &dummy->regs.fp_regs) {\n\t\treturn 0;\n\t} else if (addr < (addr_t) (&dummy->regs.fp_regs + 1)) {\n\t\tif (addr == (addr_t) &dummy->regs.fp_regs.fpc)\n\t\t\tif ((unsigned int) data != 0 ||\n\t\t\t    test_fp_ctl(data >> (BITS_PER_LONG - 32)))\n\t\t\t\treturn -EINVAL;\n\t\toffset = addr - (addr_t) &dummy->regs.fp_regs;\n\t\t*(addr_t *)((addr_t) &child->thread.fp_regs + offset) = data;\n\t} else if (addr < (addr_t) (&dummy->regs.per_info + 1)) {\n\t\taddr -= (addr_t) &dummy->regs.per_info;\n\t\t__poke_user_per(child, addr, data);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static uint8_t nvme_sq_empty(NvmeSQueue *sq)\n{\n    return sq->head == sq->tail;\n}", "target": 0}
{"code": "cib_remote_dispatch(gpointer user_data)\n{\n    cib_t *cib = user_data;\n    cib_remote_opaque_t *private = cib->variant_opaque;\n    xmlNode *msg = NULL;\n    const char *type = NULL;\n    crm_info(\"Message on callback channel\");\n    msg = crm_recv_remote_msg(private->callback.session, private->callback.encrypted);\n    type = crm_element_value(msg, F_TYPE);\n    crm_trace(\"Activating %s callbacks...\", type);\n    if (safe_str_eq(type, T_CIB)) {\n        cib_native_callback(cib, msg, 0, 0);\n    } else if (safe_str_eq(type, T_CIB_NOTIFY)) {\n        g_list_foreach(cib->notify_list, cib_native_notify, msg);\n    } else {\n        crm_err(\"Unknown message type: %s\", type);\n    }\n    if (msg != NULL) {\n        free_xml(msg);\n        return 0;\n    }\n    return -1;\n}", "target": 1}
{"code": "  static Status Compute(OpKernelContext* context,\n                        const typename TTypes<T, 1>::ConstTensor& values,\n                        const typename TTypes<T, 1>::ConstTensor& value_range,\n                        int32_t nbins, typename TTypes<Tout, 1>::Tensor& out) {\n    const CPUDevice& d = context->eigen_device<CPUDevice>();\n    Tensor index_to_bin_tensor;\n    TF_RETURN_IF_ERROR(context->forward_input_or_allocate_temp(\n        {0}, DataTypeToEnum<int32>::value, TensorShape({values.size()}),\n        &index_to_bin_tensor));\n    auto index_to_bin = index_to_bin_tensor.flat<int32>();\n    const double step = static_cast<double>(value_range(1) - value_range(0)) /\n                        static_cast<double>(nbins);\n    const double nbins_minus_1 = static_cast<double>(nbins - 1);\n    const Eigen::Tensor<int32, 1, 1> nans_tensor =\n        values.isnan().template cast<int32>();\n    const Eigen::Tensor<int32, 0, 1> reduced_tensor = nans_tensor.sum();\n    const int num_nans = reduced_tensor(0);\n    if (num_nans > 0) {\n      return errors::InvalidArgument(\"Histogram values must not contain NaN\");\n    }\n    index_to_bin.device(d) =\n        ((values.cwiseMax(value_range(0)) - values.constant(value_range(0)))\n             .template cast<double>() /\n         step)\n            .cwiseMin(nbins_minus_1)\n            .template cast<int32>();\n    out.setZero();\n    for (int32_t i = 0; i < index_to_bin.size(); i++) {\n      out(index_to_bin(i)) += Tout(1);\n    }\n    return Status::OK();\n  }", "target": 0}
{"code": "acpi_os_create_cache(char *name, u16 size, u16 depth, acpi_cache_t ** cache)\n{\n\t*cache = kmem_cache_create(name, size, 0, 0, NULL);\n\tif (*cache == NULL)\n\t\treturn AE_ERROR;\n\telse\n\t\treturn AE_OK;\n}", "target": 0}
{"code": "long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)\n{\n\tif (pid <= 0 || tgid <= 0)\n\t\treturn -EINVAL;\n\tif (info->si_code >= 0)\n\t\treturn -EPERM;\n\tinfo->si_signo = sig;\n\treturn do_send_specific(tgid, pid, sig, info);\n}", "target": 1}
{"code": "int TS_OBJ_print_bio(BIO *bio, const ASN1_OBJECT *obj)\n{\n    char obj_txt[128];\n    int len = OBJ_obj2txt(obj_txt, sizeof(obj_txt), obj, 0);\n    BIO_write(bio, obj_txt, len);\n    BIO_write(bio, \"\\n\", 1);\n    return 1;\n}", "target": 1}
{"code": "void cql_server::response::write_short_bytes(bytes b)\n{\n    write_short(cast_if_fits<uint16_t>(b.size()));\n    _body.write(b);\n}", "target": 0}
{"code": "int pkey_gost_decrypt(EVP_PKEY_CTX *pctx, unsigned char *key,\n                      size_t *key_len, const unsigned char *in, size_t in_len)\n{\n    struct gost_pmeth_data *gctx = EVP_PKEY_CTX_get_data(pctx);\n    if (key == NULL) {\n        *key_len = 32;\n        return 1;\n    }\n    if (key != NULL && *key_len < 32) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_INVALID_BUFFER_SIZE);\n        return 0;\n    }\n    switch (gctx->cipher_nid)\n    {\n        case NID_id_Gost28147_89:\n        case NID_undef: \n            return pkey_GOST_ECcp_decrypt(pctx, key, key_len, in, in_len);\n        case NID_kuznyechik_ctr:\n        case NID_magma_ctr:\n            return pkey_gost2018_decrypt(pctx, key, key_len, in, in_len);\n        default:\n      GOSTerr(GOST_F_PKEY_GOST_DECRYPT, ERR_R_INTERNAL_ERROR);\n      return -1;\n    }\n}", "target": 0}
{"code": "static void perf_event_task_event(struct perf_task_event *task_event)\n{\n\tstruct perf_cpu_context *cpuctx;\n\tstruct perf_event_context *ctx;\n\tstruct pmu *pmu;\n\tint ctxn;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pmu, &pmus, entry) {\n\t\tcpuctx = get_cpu_ptr(pmu->pmu_cpu_context);\n\t\tif (cpuctx->unique_pmu != pmu)\n\t\t\tgoto next;\n\t\tperf_event_task_ctx(&cpuctx->ctx, task_event);\n\t\tctx = task_event->task_ctx;\n\t\tif (!ctx) {\n\t\t\tctxn = pmu->task_ctx_nr;\n\t\t\tif (ctxn < 0)\n\t\t\t\tgoto next;\n\t\t\tctx = rcu_dereference(current->perf_event_ctxp[ctxn]);\n\t\t\tif (ctx)\n\t\t\t\tperf_event_task_ctx(ctx, task_event);\n\t\t}\nnext:\n\t\tput_cpu_ptr(pmu->pmu_cpu_context);\n\t}\n\tif (task_event->task_ctx)\n\t\tperf_event_task_ctx(task_event->task_ctx, task_event);\n\trcu_read_unlock();\n}", "target": 0}
{"code": "static inline void flush(Encoder *encoder)\n{\n    if (encoder->io_available_bits > 0 && encoder->io_available_bits != 32) {\n        encode(encoder, 0, encoder->io_available_bits);\n    }\n    encode_32(encoder, 0);\n    encode(encoder, 0, 1);\n}", "target": 0}
{"code": "bool may_move_pid(pid_t r, uid_t r_uid, pid_t v)\n{\n\tuid_t v_uid, tmpuid;\n\tgid_t v_gid;\n\tif (r == v)\n\t\treturn true;\n\tif (r_uid == 0)\n\t\treturn true;\n\tget_pid_creds(v, &v_uid, &v_gid);\n\tif (r_uid == v_uid)\n\t\treturn true;\n\tif (hostuid_to_ns(r_uid, r, &tmpuid) && tmpuid == 0\n\t\t\t&& hostuid_to_ns(v_uid, r, &tmpuid))\n\t\treturn true;\n\treturn false;\n}", "target": 0}
{"code": "BGD_DECLARE(void) gdImageXbmCtx(gdImagePtr image, char* file_name, int fg, gdIOCtx * out)\n{\n\tint x, y, c, b, sx, sy, p;\n\tchar *name, *f;\n\tsize_t i, l;\n\tname = file_name;\n\tif ((f = strrchr(name, '/')) != NULL) name = f+1;\n\tif ((f = strrchr(name, '\\\\')) != NULL) name = f+1;\n\tname = strdup(name);\n\tif ((f = strrchr(name, '.')) != NULL && !strcasecmp(f, \".XBM\")) *f = '\\0';\n\tif ((l = strlen(name)) == 0) {\n\t\tfree(name);\n\t\tname = strdup(\"image\");\n\t} else {\n\t\tfor (i=0; i<l; i++) {\n\t\t\tif (!isupper(name[i]) && !islower(name[i]) && !isdigit(name[i])) {\n\t\t\t\tname[i] = '_';\n\t\t\t}\n\t\t}\n\t}\n\tgdCtxPrintf(out, \"#define %s_width %d\\n\", name, gdImageSX(image));\n\tgdCtxPrintf(out, \"#define %s_height %d\\n\", name, gdImageSY(image));\n\tgdCtxPrintf(out, \"static unsigned char %s_bits[] = {\\n  \", name);\n\tfree(name);\n\tb = 1;\n\tp = 0;\n\tc = 0;\n\tsx = gdImageSX(image);\n\tsy = gdImageSY(image);\n\tfor (y = 0; y < sy; y++) {\n\t\tfor (x = 0; x < sx; x++) {\n\t\t\tif (gdImageGetPixel(image, x, y) == fg) {\n\t\t\t\tc |= b;\n\t\t\t}\n\t\t\tif ((b == 128) || (x == sx && y == sy)) {\n\t\t\t\tb = 1;\n\t\t\t\tif (p) {\n\t\t\t\t\tgdCtxPrintf(out, \", \");\n\t\t\t\t\tif (!(p%12)) {\n\t\t\t\t\t\tgdCtxPrintf(out, \"\\n  \");\n\t\t\t\t\t\tp = 12;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t\tgdCtxPrintf(out, \"0x%02X\", c);\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\tb <<= 1;\n\t\t\t}\n\t\t}\n\t}\n\tgdCtxPrintf(out, \"};\\n\");\n}", "target": 1}
{"code": "ssize_t uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n  const char* si;\n  const char* st;\n  unsigned c;\n  char* ds;\n  int rc;\n  if (s == se)\n    return UV_EINVAL;\n  ds = d;\n  si = s;\n  while (si < se) {\n    st = si;\n    c = uv__utf8_decode1(&si, se);\n    if (c == UINT_MAX)\n      return UV_EINVAL;\n    if (c != '.')\n      if (c != 0x3002)  \n        if (c != 0xFF0E)  \n          if (c != 0xFF61)  \n            continue;\n    rc = uv__idna_toascii_label(s, st, &d, de);\n    if (rc < 0)\n      return rc;\n    if (d < de)\n      *d++ = '.';\n    s = si;\n  }\n  if (s < se) {\n    rc = uv__idna_toascii_label(s, se, &d, de);\n    if (rc < 0)\n      return rc;\n  }\n  if (d >= de)\n    return UV_EINVAL;\n  *d++ = '\\0';\n  return d - ds;  \n}", "target": 0}
{"code": "snmp_ber_decode_type(unsigned char *buff, uint32_t *buff_len, uint8_t *type)\n{\n  if(*buff_len == 0) {\n    return NULL;\n  }\n  *type = *buff++;\n  (*buff_len)--;\n  return buff;\n}", "target": 1}
{"code": "static WERROR dnsserver_complex_operate_zone(struct dnsserver_state *dsstate,\n\t\t\t\t\tTALLOC_CTX *mem_ctx,\n\t\t\t\t\tstruct dnsserver_zone *z,\n\t\t\t\t\tconst char *operation,\n\t\t\t\t\tconst unsigned int client_version,\n\t\t\t\t\tenum DNS_RPC_TYPEID typeid_in,\n\t\t\t\t\tunion DNSSRV_RPC_UNION *rin,\n\t\t\t\t\tenum DNS_RPC_TYPEID *typeid_out,\n\t\t\t\t\tunion DNSSRV_RPC_UNION *rout)\n{\n\tif (strcasecmp(operation, \"QueryDwordProperty\") == 0) {\n\t\tif (typeid_in == DNSSRV_TYPEID_LPSTR) {\n\t\t\treturn dnsserver_query_zone(dsstate, mem_ctx, z,\n\t\t\t\t\t\trin->String,\n\t\t\t\t\t\tclient_version,\n\t\t\t\t\t\ttypeid_out,\n\t\t\t\t\t\trout);\n\t\t}\n\t}\n\tDEBUG(0,(\"dnsserver: Invalid zone operation %s\", operation));\n\treturn WERR_DNS_ERROR_INVALID_PROPERTY;\n}", "target": 0}
{"code": "static void do_iccprofile_item(deark *c, lctx *d, i64 pos, i64 len)\n{\n\ti64 selector;\n\ti64 data_len;\n\tif(len<4) return;\n\tselector = de_getu32be(pos);\n\tdata_len = len-4;\n\tde_dbg(c, \"ICC profile segment, selector=%d, data len=%d\", (int)selector,\n\t\t(int)data_len);\n\tif(selector!=1) {\n\t\tdbuf_close(d->iccprofile_file);\n\t\td->iccprofile_file = NULL;\n\t}\n\tif(selector==0) { \n\t\td->iccprofile_file = dbuf_create_output_file(c, \"icc\", NULL, DE_CREATEFLAG_IS_AUX);\n\t}\n\tif(selector==0 || selector==1) {\n\t\tif(!d->iccprofile_file) {\n\t\t\tde_warn(c, \"Bad ICC profile segment\");\n\t\t\treturn;\n\t\t}\n\t\tdbuf_copy(c->infile, pos+4, data_len, d->iccprofile_file);\n\t}\n}", "target": 0}
{"code": "ServerSecurityFeature::ServerSecurityFeature(application_features::ApplicationServer& server)\n    : ApplicationFeature(server, \"ServerSecurity\"),\n      _enableFoxxApi(true),\n      _enableFoxxStore(true),\n      _hardenedRestApi(false) {\n  setOptional(false);\n  startsAfter<application_features::GreetingsFeaturePhase>();\n}", "target": 1}
{"code": "void test_rename(const char *path)\n{\n\tchar *d = strdupa(path), *tmpname;\n\td = dirname(d);\n\tsize_t len = strlen(path) + 30;\n\ttmpname = alloca(len);\n\tsnprintf(tmpname, len, \"%s/%d\", d, (int)getpid());\n\tif (rename(path, tmpname) == 0 || errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at rename of %s\\n\", path);\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& input = ctx->input(0);\n    OP_REQUIRES(ctx, ctx->input(1).NumElements() > 0,\n                errors::InvalidArgument(\"Input min must not be empty.\"));\n    OP_REQUIRES(ctx, ctx->input(2).NumElements() > 0,\n                errors::InvalidArgument(\"Input max must not be empty.\"));\n    const float input_min_float = ctx->input(1).flat<float>()(0);\n    const float input_max_float = ctx->input(2).flat<float>()(0);\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({}), &output_min));\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(1, TensorShape({}), &output_max));\n    qint32 used_min_quantized;\n    qint32 used_max_quantized;\n    CalculateUsedRange(input, &used_min_quantized, &used_max_quantized);\n    const float used_min_float = std::min(\n        0.0f,\n        QuantizedToFloat(used_min_quantized, input_min_float, input_max_float));\n    const float used_max_float =\n        QuantizedToFloat(used_max_quantized, input_min_float, input_max_float);\n    output_min->flat<float>().setConstant(used_min_float);\n    output_max->flat<float>().setConstant(used_max_float);\n  }", "target": 0}
{"code": "static bool em_syscall_is_enabled(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\tu32 eax, ebx, ecx, edx;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn true;\n\teax = 0x00000000;\n\tecx = 0x00000000;\n\tif (ops->get_cpuid(ctxt, &eax, &ebx, &ecx, &edx)) {\n\t\tif (ebx == X86EMUL_CPUID_VENDOR_GenuineIntel_ebx &&\n\t\t    ecx == X86EMUL_CPUID_VENDOR_GenuineIntel_ecx &&\n\t\t    edx == X86EMUL_CPUID_VENDOR_GenuineIntel_edx)\n\t\t\treturn false;\n\t\tif (ebx == X86EMUL_CPUID_VENDOR_AuthenticAMD_ebx &&\n\t\t    ecx == X86EMUL_CPUID_VENDOR_AuthenticAMD_ecx &&\n\t\t    edx == X86EMUL_CPUID_VENDOR_AuthenticAMD_edx)\n\t\t\treturn true;\n\t\tif (ebx == X86EMUL_CPUID_VENDOR_AMDisbetterI_ebx &&\n\t\t    ecx == X86EMUL_CPUID_VENDOR_AMDisbetterI_ecx &&\n\t\t    edx == X86EMUL_CPUID_VENDOR_AMDisbetterI_edx)\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "target": 0}
{"code": "_asn1_set_default_tag (asn1_node node)\n{\n  asn1_node p;\n  if ((node == NULL) || (type_field (node->type) != ASN1_ETYPE_DEFINITIONS))\n    return ASN1_ELEMENT_NOT_FOUND;\n  p = node;\n  while (p)\n    {\n      if ((type_field (p->type) == ASN1_ETYPE_TAG) &&\n\t  !(p->type & CONST_EXPLICIT) && !(p->type & CONST_IMPLICIT))\n\t{\n\t  if (node->type & CONST_EXPLICIT)\n\t    p->type |= CONST_EXPLICIT;\n\t  else\n\t    p->type |= CONST_IMPLICIT;\n\t}\n      if (p->down)\n\t{\n\t  p = p->down;\n\t}\n      else if (p->right)\n\tp = p->right;\n      else\n\t{\n\t  while (1)\n\t    {\n\t      p = _asn1_get_up (p);\n\t      if (p == node)\n\t\t{\n\t\t  p = NULL;\n\t\t  break;\n\t\t}\n\t      if (p->right)\n\t\t{\n\t\t  p = p->right;\n\t\t  break;\n\t\t}\n\t    }\n\t}\n    }\n  return ASN1_SUCCESS;\n}", "target": 0}
{"code": "RecordFlushAllContexts(CallbackListPtr *pcbl,\n                       void *nulldata, void *calldata)\n{\n    int eci;                    \n    RecordContextPtr pContext;\n    for (eci = 0; eci < numEnabledContexts; eci++) {\n        pContext = ppAllContexts[eci];\n        if (pContext->numBufBytes)\n            RecordFlushReplyBuffer(ppAllContexts[eci], NULL, 0, NULL, 0);\n    }\n}                               ", "target": 0}
{"code": "int megasas_alloc_cmds(struct megasas_instance *instance)\n{\n\tint i;\n\tint j;\n\tu16 max_cmd;\n\tstruct megasas_cmd *cmd;\n\tmax_cmd = instance->max_mfi_cmds;\n\tinstance->cmd_list = kcalloc(max_cmd, sizeof(struct megasas_cmd*), GFP_KERNEL);\n\tif (!instance->cmd_list) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tmemset(instance->cmd_list, 0, sizeof(struct megasas_cmd *) *max_cmd);\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tinstance->cmd_list[i] = kmalloc(sizeof(struct megasas_cmd),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!instance->cmd_list[i]) {\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tkfree(instance->cmd_list[j]);\n\t\t\tkfree(instance->cmd_list);\n\t\t\tinstance->cmd_list = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tcmd = instance->cmd_list[i];\n\t\tmemset(cmd, 0, sizeof(struct megasas_cmd));\n\t\tcmd->index = i;\n\t\tcmd->scmd = NULL;\n\t\tcmd->instance = instance;\n\t\tlist_add_tail(&cmd->list, &instance->cmd_pool);\n\t}\n\tif (megasas_create_frame_pool(instance)) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Error creating frame DMA pool\\n\");\n\t\tmegasas_free_cmds(instance);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static u32 rd_release_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,\n\t\t\t\t u32 sg_table_count)\n{\n\tstruct page *pg;\n\tstruct scatterlist *sg;\n\tu32 i, j, page_count = 0, sg_per_table;\n\tfor (i = 0; i < sg_table_count; i++) {\n\t\tsg = sg_table[i].sg_table;\n\t\tsg_per_table = sg_table[i].rd_sg_count;\n\t\tfor (j = 0; j < sg_per_table; j++) {\n\t\t\tpg = sg_page(&sg[j]);\n\t\t\tif (pg) {\n\t\t\t\t__free_page(pg);\n\t\t\t\tpage_count++;\n\t\t\t}\n\t\t}\n\t\tkfree(sg);\n\t}\n\tkfree(sg_table);\n\treturn page_count;\n}", "target": 0}
{"code": "hb_map_clear (hb_map_t *map)\n{\n  if (unlikely (hb_object_is_immutable (map)))\n    return;\n  return map->clear ();\n}", "target": 1}
{"code": "Status OpLevelCostEstimator::PredictMaxPool(const OpContext& op_context,\n                                            NodeCosts* node_costs) const {\n  bool found_unknown_shapes = false;\n  const auto& op_info = op_context.op_info;\n  ConvolutionDimensions dims = OpDimensionsFromInputs(\n      op_info.inputs(0).shape(), op_info, &found_unknown_shapes);\n  int per_output_ops = dims.kx * dims.ky == 1 ? 1 : dims.kx * dims.ky - 1;\n  int64_t ops = dims.batch * dims.ox * dims.oy * dims.oz * per_output_ops;\n  node_costs->num_compute_ops = ops;\n  int64_t input_size = 0;\n  if (dims.ky >= dims.sy) {\n    input_size = CalculateTensorSize(op_info.inputs(0), &found_unknown_shapes);\n  } else {  \n    const auto data_size = DataTypeSize(BaseType(op_info.inputs(0).dtype()));\n    input_size = data_size * dims.batch * dims.ix * dims.ky * dims.oy * dims.iz;\n  }\n  node_costs->num_input_bytes_accessed = {input_size};\n  const int64_t output_size =\n      CalculateOutputSize(op_info, &found_unknown_shapes);\n  node_costs->num_output_bytes_accessed = {output_size};\n  node_costs->max_memory = output_size;\n  if (found_unknown_shapes) {\n    node_costs->inaccurate = true;\n    node_costs->num_nodes_with_unknown_shapes = 1;\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "long join_session_keyring(const char *name)\n{\n\tconst struct cred *old;\n\tstruct cred *new;\n\tstruct key *keyring;\n\tlong ret, serial;\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\told = current_cred();\n\tif (!name) {\n\t\tret = install_session_keyring_to_cred(new, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tserial = new->session_keyring->serial;\n\t\tret = commit_creds(new);\n\t\tif (ret == 0)\n\t\t\tret = serial;\n\t\tgoto okay;\n\t}\n\tmutex_lock(&key_session_mutex);\n\tkeyring = find_keyring_by_name(name, false);\n\tif (PTR_ERR(keyring) == -ENOKEY) {\n\t\tkeyring = keyring_alloc(\n\t\t\tname, old->uid, old->gid, old,\n\t\t\tKEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK,\n\t\t\tKEY_ALLOC_IN_QUOTA, NULL);\n\t\tif (IS_ERR(keyring)) {\n\t\t\tret = PTR_ERR(keyring);\n\t\t\tgoto error2;\n\t\t}\n\t} else if (IS_ERR(keyring)) {\n\t\tret = PTR_ERR(keyring);\n\t\tgoto error2;\n\t} else if (keyring == new->session_keyring) {\n\t\tkey_put(keyring);\n\t\tret = 0;\n\t\tgoto error2;\n\t}\n\tret = install_session_keyring_to_cred(new, keyring);\n\tif (ret < 0)\n\t\tgoto error2;\n\tcommit_creds(new);\n\tmutex_unlock(&key_session_mutex);\n\tret = keyring->serial;\n\tkey_put(keyring);\nokay:\n\treturn ret;\nerror2:\n\tmutex_unlock(&key_session_mutex);\nerror:\n\tabort_creds(new);\n\treturn ret;\n}", "target": 0}
{"code": "GF_AV1Config *gf_isom_av1_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tif (gf_isom_get_reference_count(the_file, trackNumber, GF_ISOM_REF_TBAS)) {\n\t\tu32 ref_track;\n\t\tGF_Err e = gf_isom_get_reference(the_file, trackNumber, GF_ISOM_REF_TBAS, 1, &ref_track);\n\t\tif (e == GF_OK) {\n\t\t\ttrackNumber = ref_track;\n\t\t}\n\t}\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex - 1);\n\tif (!entry || !entry->av1_config) return NULL;\n\treturn AV1_DuplicateConfig(entry->av1_config->config);\n}", "target": 1}
{"code": "void GfxImageColorMap::getGrayLine(unsigned char *in, unsigned char *out, int length)\n{\n    int i, j;\n    unsigned char *inp, *tmp_line;\n    if ((colorSpace2 && !colorSpace2->useGetGrayLine()) || (!colorSpace2 && !colorSpace->useGetGrayLine())) {\n        GfxGray gray;\n        inp = in;\n        for (i = 0; i < length; i++) {\n            getGray(inp, &gray);\n            out[i] = colToByte(gray);\n            inp += nComps;\n        }\n        return;\n    }\n    switch (colorSpace->getMode()) {\n    case csIndexed:\n    case csSeparation:\n        tmp_line = (unsigned char *)gmallocn(length, nComps2);\n        for (i = 0; i < length; i++) {\n            for (j = 0; j < nComps2; j++) {\n                unsigned char c = in[i];\n                if (byte_lookup)\n                    c = byte_lookup[c * nComps2 + j];\n                tmp_line[i * nComps2 + j] = c;\n            }\n        }\n        colorSpace2->getGrayLine(tmp_line, out, length);\n        gfree(tmp_line);\n        break;\n    default:\n        if (byte_lookup) {\n            inp = in;\n            for (j = 0; j < length; j++)\n                for (i = 0; i < nComps; i++) {\n                    *inp = byte_lookup[*inp * nComps + i];\n                    inp++;\n                }\n        }\n        colorSpace->getGrayLine(in, out, length);\n        break;\n    }\n}", "target": 0}
{"code": "static inline void mcryptd_check_internal(struct rtattr **tb, u32 *type,\n\t\t\t\t\t  u32 *mask)\n{\n\tstruct crypto_attr_type *algt;\n\talgt = crypto_get_attr_type(tb);\n\tif (IS_ERR(algt))\n\t\treturn;\n\tif ((algt->type & CRYPTO_ALG_INTERNAL))\n\t\t*type |= CRYPTO_ALG_INTERNAL;\n\tif ((algt->mask & CRYPTO_ALG_INTERNAL))\n\t\t*mask |= CRYPTO_ALG_INTERNAL;\n}", "target": 1}
{"code": "static void vc_uniscr_delete(struct vc_data *vc, unsigned int nr)\n{\n\tstruct uni_screen *uniscr = get_vc_uniscr(vc);\n\tif (uniscr) {\n\t\tchar32_t *ln = uniscr->lines[vc->vc_y];\n\t\tunsigned int x = vc->vc_x, cols = vc->vc_cols;\n\t\tmemcpy(&ln[x], &ln[x + nr], (cols - x - nr) * sizeof(*ln));\n\t\tmemset32(&ln[cols - nr], ' ', nr);\n\t}\n}", "target": 0}
{"code": "static int check_swap_activate(struct file *swap_file, unsigned int max)\n{\n\tstruct address_space *mapping = swap_file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tunsigned blocks_per_page;\n\tunsigned long page_no;\n\tunsigned blkbits;\n\tsector_t probe_block;\n\tsector_t last_block;\n\tsector_t lowest_block = -1;\n\tsector_t highest_block = 0;\n\tblkbits = inode->i_blkbits;\n\tblocks_per_page = PAGE_SIZE >> blkbits;\n\tprobe_block = 0;\n\tpage_no = 0;\n\tlast_block = i_size_read(inode) >> blkbits;\n\twhile ((probe_block + blocks_per_page) <= last_block && page_no < max) {\n\t\tunsigned block_in_page;\n\t\tsector_t first_block;\n\t\tcond_resched();\n\t\tfirst_block = bmap(inode, probe_block);\n\t\tif (first_block == 0)\n\t\t\tgoto bad_bmap;\n\t\tif (first_block & (blocks_per_page - 1)) {\n\t\t\tprobe_block++;\n\t\t\tgoto reprobe;\n\t\t}\n\t\tfor (block_in_page = 1; block_in_page < blocks_per_page;\n\t\t\t\t\tblock_in_page++) {\n\t\t\tsector_t block;\n\t\t\tblock = bmap(inode, probe_block + block_in_page);\n\t\t\tif (block == 0)\n\t\t\t\tgoto bad_bmap;\n\t\t\tif (block != first_block + block_in_page) {\n\t\t\t\tprobe_block++;\n\t\t\t\tgoto reprobe;\n\t\t\t}\n\t\t}\n\t\tfirst_block >>= (PAGE_SHIFT - blkbits);\n\t\tif (page_no) {\t\n\t\t\tif (first_block < lowest_block)\n\t\t\t\tlowest_block = first_block;\n\t\t\tif (first_block > highest_block)\n\t\t\t\thighest_block = first_block;\n\t\t}\n\t\tpage_no++;\n\t\tprobe_block += blocks_per_page;\nreprobe:\n\t\tcontinue;\n\t}\n\treturn 0;\nbad_bmap:\n\tpr_err(\"swapon: swapfile has holes\\n\");\n\treturn -EINVAL;\n}", "target": 0}
{"code": "static void unix_dgram_peer_wake_disconnect(struct sock *sk,\n\t\t\t\t\t    struct sock *other)\n{\n\tstruct unix_sock *u, *u_other;\n\tu = unix_sk(sk);\n\tu_other = unix_sk(other);\n\tspin_lock(&u_other->peer_wait.lock);\n\tif (u->peer_wake.private == other) {\n\t\t__remove_wait_queue(&u_other->peer_wait, &u->peer_wake);\n\t\tu->peer_wake.private = NULL;\n\t}\n\tspin_unlock(&u_other->peer_wait.lock);\n}", "target": 0}
{"code": "static inline void sem_lock_and_putref(struct sem_array *sma)\n{\n\tipc_lock_by_ptr(&sma->sem_perm);\n\tipc_rcu_putref(sma);\n}", "target": 1}
{"code": "static int em_bt(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.type = OP_NONE;\n\tctxt->src.val &= (ctxt->dst.bytes << 3) - 1;\n\temulate_2op_SrcV_nobyte(ctxt, \"bt\");\n\treturn X86EMUL_CONTINUE;\n}", "target": 0}
{"code": "absl::Span<const std::string> ConnectionInfoImplBase::ipSansPeerCertificate() const {\n  if (!cached_ip_san_peer_certificate_.empty()) {\n    return cached_ip_san_peer_certificate_;\n  }\n  bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl()));\n  if (!cert) {\n    ASSERT(cached_ip_san_peer_certificate_.empty());\n    return cached_ip_san_peer_certificate_;\n  }\n  cached_ip_san_peer_certificate_ = Utility::getSubjectAltNames(*cert, GEN_IPADD);\n  return cached_ip_san_peer_certificate_;\n}", "target": 1}
{"code": "xmlNodePtr SimpleXMLElement_exportNode(const Object& sxe) {\n  assert(sxe->instanceof(SimpleXMLElement_classof()));\n  auto data = Native::data<SimpleXMLElement>(sxe.get());\n  return php_sxe_get_first_node(data, data->nodep());\n}", "target": 1}
{"code": "LibRaw_byte_buffer *LibRaw_buffer_datastream::make_byte_buffer(unsigned int sz)\n{\n  if(INT64(sz)>size())\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n    LibRaw_byte_buffer *ret = new LibRaw_byte_buffer(0);\n    if(!ret) \n      throw LIBRAW_EXCEPTION_ALLOC;\n    if(streampos + sz > streamsize)\n        sz = streamsize - streampos;\n    ret->set_buffer(buf+streampos,sz);\n    return ret;\n}", "target": 0}
{"code": "findoprnd(ITEM *ptr, int32 *pos)\n{\n\tcheck_stack_depth();\n#ifdef BS_DEBUG\n\telog(DEBUG3, (ptr[*pos].type == OPR) ?\n\t\t \"%d  %c\" : \"%d  %d\", *pos, ptr[*pos].val);\n#endif\n\tif (ptr[*pos].type == VAL)\n\t{\n\t\tptr[*pos].left = 0;\n\t\t(*pos)--;\n\t}\n\telse if (ptr[*pos].val == (int32) '!')\n\t{\n\t\tptr[*pos].left = -1;\n\t\t(*pos)--;\n\t\tfindoprnd(ptr, pos);\n\t}\n\telse\n\t{\n\t\tITEM\t   *curitem = &ptr[*pos];\n\t\tint32\t\ttmp = *pos;\n\t\t(*pos)--;\n\t\tfindoprnd(ptr, pos);\n\t\tcuritem->left = *pos - tmp;\n\t\tfindoprnd(ptr, pos);\n\t}\n}", "target": 0}
{"code": "inline typename V::VariantType FBUnserializer<V>::unserialize(\n  folly::StringPiece serialized) {\n  FBUnserializer<V> unserializer(serialized);\n  return unserializer.unserializeThing();\n}", "target": 1}
{"code": "static void nfs4_open_confirm_release(void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state *state = NULL;\n\tif (data->cancelled == 0)\n\t\tgoto out_free;\n\tif (!data->rpc_done)\n\t\tgoto out_free;\n\tstate = nfs4_opendata_to_nfs4_state(data);\n\tif (!IS_ERR(state))\n\t\tnfs4_close_state(&data->path, state, data->o_arg.open_flags);\nout_free:\n\tnfs4_opendata_put(data);\n}", "target": 1}
{"code": "static int nlmsg_populate_mdb_fill(struct sk_buff *skb,\n\t\t\t\t   struct net_device *dev,\n\t\t\t\t   struct br_mdb_entry *entry, u32 pid,\n\t\t\t\t   u32 seq, int type, unsigned int flags)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct br_port_msg *bpm;\n\tstruct nlattr *nest, *nest2;\n\tnlh = nlmsg_put(skb, pid, seq, type, sizeof(*bpm), NLM_F_MULTI);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\tbpm = nlmsg_data(nlh);\n\tmemset(bpm, 0, sizeof(*bpm));\n\tbpm->family  = AF_BRIDGE;\n\tbpm->ifindex = dev->ifindex;\n\tnest = nla_nest_start(skb, MDBA_MDB);\n\tif (nest == NULL)\n\t\tgoto cancel;\n\tnest2 = nla_nest_start(skb, MDBA_MDB_ENTRY);\n\tif (nest2 == NULL)\n\t\tgoto end;\n\tif (nla_put(skb, MDBA_MDB_ENTRY_INFO, sizeof(*entry), entry))\n\t\tgoto end;\n\tnla_nest_end(skb, nest2);\n\tnla_nest_end(skb, nest);\n\treturn nlmsg_end(skb, nlh);\nend:\n\tnla_nest_end(skb, nest);\ncancel:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}", "target": 0}
{"code": "l2tp_framing_type_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint32_t *ptr = (const uint32_t *)dat;\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_TYPE_ASYNC_MASK) {\n\t\tND_PRINT((ndo, \"A\"));\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_TYPE_SYNC_MASK) {\n\t\tND_PRINT((ndo, \"S\"));\n\t}\n}", "target": 1}
{"code": "Function *ESTreeIRGen::genGeneratorFunction(\n    Identifier originalName,\n    Variable *lazyClosureAlias,\n    ESTree::FunctionLikeNode *functionNode) {\n  assert(functionNode && \"Function AST cannot be null\");\n  auto *outerFn = Builder.createGeneratorFunction(\n      originalName,\n      Function::DefinitionKind::ES5Function,\n      ESTree::isStrict(functionNode->strictness),\n       nullptr);\n  auto *innerFn = genES5Function(\n      genAnonymousLabelName(originalName.isValid() ? originalName.str() : \"\"),\n      lazyClosureAlias,\n      functionNode,\n      true);\n  {\n    FunctionContext outerFnContext{this, outerFn, functionNode->getSemInfo()};\n    emitFunctionPrologue(\n        functionNode,\n        Builder.createBasicBlock(outerFn),\n        InitES5CaptureState::Yes,\n        DoEmitParameters::No);\n    auto *gen = Builder.createCreateGeneratorInst(innerFn);\n    if (!hasSimpleParams(functionNode)) {\n      Value *next = Builder.createLoadPropertyInst(gen, \"next\");\n      Builder.createCallInst(next, gen, {});\n    }\n    emitFunctionEpilogue(gen);\n  }\n  return outerFn;\n}", "target": 1}
{"code": "static int cdrom_ioctl_select_disc(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_SELECT_DISC\\n\");\n\tif (!CDROM_CAN(CDC_SELECT_DISC))\n\t\treturn -ENOSYS;\n\tif (arg != CDSL_CURRENT && arg != CDSL_NONE) {\n\t\tif ((int)arg >= cdi->capacity)\n\t\t\treturn -EINVAL;\n\t}\n\tif (cdi->ops->select_disc)\n\t\treturn cdi->ops->select_disc(cdi, arg);\n\tcd_dbg(CD_CHANGER, \"Using generic cdrom_select_disc()\\n\");\n\treturn cdrom_select_disc(cdi, arg);\n}", "target": 1}
{"code": "evtchn_port_t evtchn_from_irq(unsigned irq)\n{\n\tif (WARN(irq >= nr_irqs, \"Invalid irq %d!\\n\", irq))\n\t\treturn 0;\n\treturn info_for_irq(irq)->evtchn;\n}", "target": 1}
{"code": "static const char *cmd_hash_engine(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n    if (strcasecmp(p1, \"on\") == 0)  {\n        dcfg->hash_is_enabled = HASH_ENABLED;\n        dcfg->hash_enforcement = HASH_ENABLED;\n    }\n    else if (strcasecmp(p1, \"off\") == 0)    {\n        dcfg->hash_is_enabled = HASH_DISABLED;\n        dcfg->hash_enforcement = HASH_DISABLED;\n    }\n    else return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecRuleEngine: %s\", p1);\n    return NULL;\n}", "target": 1}
{"code": "resolve_op_end (FlatpakTransaction *self,\n                FlatpakTransactionOperation *op,\n                const char *checksum,\n                GFile *sideload_path,\n                GBytes *metadata_bytes)\n{\n  g_autoptr(GBytes) old_metadata_bytes = NULL;\n  old_metadata_bytes = load_deployed_metadata (self, op->ref, NULL, NULL);\n  mark_op_resolved (op, checksum, sideload_path, metadata_bytes, old_metadata_bytes);\n  emit_eol_and_maybe_skip (self, op);\n }", "target": 1}
{"code": "static int __d_unalias(struct inode *inode,\n\t\tstruct dentry *dentry, struct dentry *alias)\n{\n\tstruct mutex *m1 = NULL, *m2 = NULL;\n\tint ret = -ESTALE;\n\tif (alias->d_parent == dentry->d_parent)\n\t\tgoto out_unalias;\n\tif (!mutex_trylock(&dentry->d_sb->s_vfs_rename_mutex))\n\t\tgoto out_err;\n\tm1 = &dentry->d_sb->s_vfs_rename_mutex;\n\tif (!mutex_trylock(&alias->d_parent->d_inode->i_mutex))\n\t\tgoto out_err;\n\tm2 = &alias->d_parent->d_inode->i_mutex;\nout_unalias:\n\t__d_move(alias, dentry, false);\n\tret = 0;\nout_err:\n\tspin_unlock(&inode->i_lock);\n\tif (m2)\n\t\tmutex_unlock(m2);\n\tif (m1)\n\t\tmutex_unlock(m1);\n\treturn ret;\n}", "target": 0}
{"code": "static int openssl_push_check_result(lua_State *L, int ret, const char* name)\n{\n  switch (ret)\n  {\n  case 1:\n    lua_pushboolean(L, 1);\n    if (name)\n    {\n      lua_pushstring(L, name);\n      ret = 2;\n    }\n    break;\n  case 0:\n    lua_pushboolean(L, 0);\n    ret = 1;\n    break;\n  case -1:\n    lua_pushnil(L);\n    lua_pushliteral(L, \"internal\");\n    ret = 2;\n  case -2:\n    lua_pushnil(L);\n    lua_pushliteral(L, \"malformed\");\n    ret = 2;\n  default:\n    lua_pushnil(L);\n    lua_pushinteger(L, ret);\n    ret = 2;\n  }\n  return ret;\n}", "target": 0}
{"code": "void ConnPoolImplBase::checkForIdleAndCloseIdleConnsIfDraining() {\n  if (is_draining_for_deletion_) {\n    closeIdleConnectionsForDrainingPool();\n  }\n  if (isIdleImpl()) {\n    ENVOY_LOG(debug, \"invoking idle callbacks - is_draining_for_deletion_={}\",\n              is_draining_for_deletion_);\n    for (const Instance::IdleCb& cb : idle_callbacks_) {\n      cb();\n    }\n  }\n}", "target": 1}
{"code": "void gf_bs_skip_bytes(GF_BitStream *bs, u64 nbBytes)\n{\n\tif (!bs || !nbBytes) return;\n\tgf_bs_align(bs);\n\tif ((bs->bsmode == GF_BITSTREAM_FILE_WRITE) || (bs->bsmode == GF_BITSTREAM_FILE_READ)) {\n\t\tif (bs->cache_write)\n\t\t\tbs_flush_write_cache(bs);\n\t\tif (bs->cache_read) {\n\t\t\tu32 csize = bs->cache_read_size - bs->cache_read_pos;\n\t\t\tif (csize>=nbBytes) {\n\t\t\t\tbs->cache_read_pos += (u32) nbBytes;\n\t\t\t\tbs->position += nbBytes;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnbBytes -= csize;\n\t\t\tbs->position += csize;\n\t\t\tbs->cache_read_pos = bs->cache_read_size;\n\t\t}\n\t\tbs->position += nbBytes;\n\t\tif (bs->bsmode == GF_BITSTREAM_FILE_READ) {\n\t\t\tif (bs->position > bs->size) bs->position = bs->size;\n\t\t}\n\t\tgf_fseek(bs->stream, bs->position, SEEK_SET);\n\t\treturn;\n\t}\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\twhile (nbBytes) {\n\t\t\t\tgf_bs_read_u8(bs);\n\t\t\t\tnbBytes--;\n\t\t\t}\n\t\t} else {\n\t\t\tbs->position += nbBytes;\n\t\t\tif (bs->position>bs->size) {\n\t\t\t\tbs->position = bs->size;\n\t\t\t\tbs->overflow_state = 1;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\twhile (nbBytes) {\n\t\tgf_bs_write_int(bs, 0, 8);\n\t\tnbBytes--;\n\t}\n}", "target": 0}
{"code": "rndr_quote(struct buf *ob, const struct buf *text, void *opaque)\n{\n\tif (!text || !text->size)\n\t\treturn 0;\n\tBUFPUTSL(ob, \"<q>\");\n\tbufput(ob, text->data, text->size);\n\tBUFPUTSL(ob, \"</q>\");\n\treturn 1;\n}", "target": 1}
{"code": "static int http1_on_response(http1_parser_s *parser) {\n  http1pr_s *p = parser2http(parser);\n  http_on_response_handler______internal(&http1_pr2handle(p), p->p.settings);\n  if (p->request.status_str && !p->stop)\n    http_finish(&p->request);\n  h1_reset(p);\n  return !p->close && fio_is_closed(p->p.uuid);\n}", "target": 1}
{"code": "TfLiteStatus CalculateArithmeticOpData(TfLiteContext* context, TfLiteNode* node,\n                                       OpData* data) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  if (input->type == kTfLiteUInt8 || input->type == kTfLiteInt8) {\n    static constexpr int kInputIntegerBits = 4;\n    const double input_real_multiplier =\n        static_cast<double>(input->params.scale) *\n        static_cast<double>(1 << (31 - kInputIntegerBits));\n    const double q = std::frexp(input_real_multiplier, &data->input_left_shift);\n    data->input_multiplier = static_cast<int32_t>(TfLiteRound(q * (1ll << 31)));\n    data->input_range_radius =\n        CalculateInputRadius(kInputIntegerBits, data->input_left_shift, 31);\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "int luaD_pretailcall (lua_State *L, CallInfo *ci, StkId func,\n                                    int narg1, int delta) {\n retry:\n  switch (ttypetag(s2v(func))) {\n    case LUA_VCCL:  \n      return precallC(L, func, LUA_MULTRET, clCvalue(s2v(func))->f);\n    case LUA_VLCF:  \n      return precallC(L, func, LUA_MULTRET, fvalue(s2v(func)));\n    case LUA_VLCL: {  \n      Proto *p = clLvalue(s2v(func))->p;\n      int fsize = p->maxstacksize;  \n      int nfixparams = p->numparams;\n      int i;\n      ci->func -= delta;  \n      for (i = 0; i < narg1; i++)  \n        setobjs2s(L, ci->func + i, func + i);\n      checkstackGC(L, fsize);\n      func = ci->func;  \n      for (; narg1 <= nfixparams; narg1++)\n        setnilvalue(s2v(func + narg1));  \n      ci->top = func + 1 + fsize;  \n      lua_assert(ci->top <= L->stack_last);\n      ci->u.l.savedpc = p->code;  \n      ci->callstatus |= CIST_TAIL;\n      L->top = func + narg1;  \n      return -1;\n    }\n    default: {  \n      func = luaD_tryfuncTM(L, func);  \n      narg1++;\n      goto retry;  \n    }\n  }\n}", "target": 1}
{"code": "static int rfcomm_sock_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct bt_security sec;\n\tint len, err = 0;\n\tBT_DBG(\"sk %p\", sk);\n\tif (level == SOL_RFCOMM)\n\t\treturn rfcomm_sock_getsockopt_old(sock, optname, optval, optlen);\n\tif (level != SOL_BLUETOOTH)\n\t\treturn -ENOPROTOOPT;\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tlock_sock(sk);\n\tswitch (optname) {\n\tcase BT_SECURITY:\n\t\tif (sk->sk_type != SOCK_STREAM) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tsec.level = rfcomm_pi(sk)->sec_level;\n\t\tsec.key_size = 0;\n\t\tlen = min_t(unsigned int, len, sizeof(sec));\n\t\tif (copy_to_user(optval, (char *) &sec, len))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (put_user(test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags),\n\t\t\t     (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const CTCBeamSearchDecoderParams* option =\n      reinterpret_cast<CTCBeamSearchDecoderParams*>(node->user_data);\n  const int top_paths = option->top_paths;\n  TF_LITE_ENSURE(context, option->beam_width >= top_paths);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 3 * top_paths + 1);\n  const TfLiteTensor* inputs = GetInput(context, node, kInputsTensor);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(inputs), 3);\n  TF_LITE_ENSURE_EQ(context, inputs->type, kTfLiteFloat32);\n  const int batch_size = SizeOfDimension(inputs, 1);\n  const TfLiteTensor* sequence_length =\n      GetInput(context, node, kSequenceLengthTensor);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(sequence_length), 1);\n  TF_LITE_ENSURE_EQ(context, NumElements(sequence_length), batch_size);\n  TF_LITE_ENSURE_EQ(context, sequence_length->type, kTfLiteInt32);\n  for (int i = 0; i < top_paths; ++i) {\n    TfLiteTensor* indices = GetOutput(context, node, i);\n    SetTensorToDynamic(indices);\n    TfLiteTensor* values = GetOutput(context, node, i + top_paths);\n    SetTensorToDynamic(values);\n    TfLiteTensor* output_shape = GetOutput(context, node, i + 2 * top_paths);\n    SetTensorToDynamic(output_shape);\n  }\n  TfLiteTensor* log_probability_output =\n      GetOutput(context, node, top_paths * 3);\n  TfLiteIntArray* log_probability_output_shape_array = TfLiteIntArrayCreate(2);\n  log_probability_output_shape_array->data[0] = batch_size;\n  log_probability_output_shape_array->data[1] = top_paths;\n  return context->ResizeTensor(context, log_probability_output,\n                               log_probability_output_shape_array);\n}", "target": 1}
{"code": "\t\tvoid Phase2() final {\n\t\t\tLocal<Context> context_handle = Deref(context);\n\t\t\tContext::Scope context_scope{context_handle};\n\t\t\tLocal<Value> key_inner = key->CopyInto();\n\t\t\tLocal<Object> object = Local<Object>::Cast(Deref(reference));\n\t\t\tUnmaybe(object->Delete(context_handle, key_inner));\n\t\t\tLocal<Value> val_inner = val->TransferIn();\n\t\t\tdid_set = Unmaybe(object->Set(context_handle, key_inner, val_inner));\n\t\t}", "target": 1}
{"code": "Pl_ASCIIHexDecoder::flush()\n{\n    if (this->pos == 0)\n    {\n\tQTC::TC(\"libtests\", \"Pl_ASCIIHexDecoder no-op flush\");\n\treturn;\n    }\n    int b[2];\n    for (int i = 0; i < 2; ++i)\n    {\n\tif (this->inbuf[i] >= 'A')\n\t{\n\t    b[i] = this->inbuf[i] - 'A' + 10;\n\t}\n\telse\n\t{\n\t    b[i] = this->inbuf[i] - '0';\n\t}\n    }\n    unsigned char ch = static_cast<unsigned char>((b[0] << 4) + b[1]);\n    QTC::TC(\"libtests\", \"Pl_ASCIIHexDecoder partial flush\",\n\t    (this->pos == 2) ? 0 : 1);\n    getNext()->write(&ch, 1);\n    this->pos = 0;\n    this->inbuf[0] = '0';\n    this->inbuf[1] = '0';\n    this->inbuf[2] = '\\0';\n}", "target": 1}
{"code": "static void frag_kfree_skb(struct netns_frags *nf, struct sk_buff *skb)\n{\n\tatomic_sub(skb->truesize, &nf->mem);\n\tkfree_skb(skb);\n}", "target": 1}
{"code": "static ssize_t attr_show_buffers(struct device *cd,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_cd2dev(cd);\n\treturn sprintf(buf, \"%d\\n\", dev->used_buffers);\n}", "target": 0}
{"code": "u32 smm_get_cpu_smbase(unsigned int cpu_num)\n{\n\tif (cpu_num < CONFIG_MAX_CPUS) {\n\t\tif (cpus[cpu_num].active)\n\t\t\treturn cpus[cpu_num].smbase;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "alt_merge_opt_map_info(OnigEncoding enc, OptMapInfo* to, OptMapInfo* add)\n{\n  int i, val;\n  if (to->value == 0) return ;\n  if (add->value == 0 || to->mmd.max < add->mmd.min) {\n    clear_opt_map_info(to);\n    return ;\n  }\n  alt_merge_mml(&to->mmd, &add->mmd);\n  val = 0;\n  for (i = 0; i < ONIG_CHAR_TABLE_SIZE; i++) {\n    if (add->map[i])\n      to->map[i] = 1;\n    if (to->map[i])\n      val += map_position_value(enc, i);\n  }\n  to->value = val;\n  alt_merge_opt_anc_info(&to->anc, &add->anc);\n}", "target": 0}
{"code": "      ECDSA_Signature_Operation(const ECDSA_PrivateKey& ecdsa,\n                                const std::string& emsa) :\n         PK_Ops::Signature_with_EMSA(emsa),\n         m_group(ecdsa.domain()),\n         m_x(ecdsa.private_value())\n         {\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n         m_rfc6979_hash = hash_for_emsa(emsa);\n#endif\n         }", "target": 1}
{"code": "init_remote_listener(int port, gboolean encrypted)\n{\n    int rc;\n    int *ssock = NULL;\n    struct sockaddr_in saddr;\n    int optval;\n    static struct mainloop_fd_callbacks remote_listen_fd_callbacks = \n        {\n            .dispatch = cib_remote_listen,\n            .destroy = remote_connection_destroy,\n        };\n    if (port <= 0) {\n        return 0;\n    }\n    if (encrypted) {\n#ifndef HAVE_GNUTLS_GNUTLS_H\n        crm_warn(\"TLS support is not available\");\n        return 0;\n#else\n        crm_notice(\"Starting a tls listener on port %d.\", port);\n        gnutls_global_init();\n        gnutls_global_set_log_function(debug_log);\n        gnutls_dh_params_init(&dh_params);\n        gnutls_dh_params_generate2(dh_params, DH_BITS);\n        gnutls_anon_allocate_server_credentials(&anon_cred_s);\n        gnutls_anon_set_server_dh_params(anon_cred_s, dh_params);\n#endif\n    } else {\n        crm_warn(\"Starting a plain_text listener on port %d.\", port);\n    }\n#ifndef HAVE_PAM\n    crm_warn(\"PAM is _not_ enabled!\");\n#endif\n    ssock = malloc(sizeof(int));\n    *ssock = socket(AF_INET, SOCK_STREAM, 0);\n    if (*ssock == -1) {\n        crm_perror(LOG_ERR, \"Can not create server socket.\" ERROR_SUFFIX);\n        free(ssock);\n        return -1;\n    }\n    optval = 1;\n    rc = setsockopt(*ssock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));\n    if(rc < 0) {\n        crm_perror(LOG_INFO, \"Couldn't allow the reuse of local addresses by our remote listener\");\n    }\n    memset(&saddr, '\\0', sizeof(saddr));\n    saddr.sin_family = AF_INET;\n    saddr.sin_addr.s_addr = INADDR_ANY;\n    saddr.sin_port = htons(port);\n    if (bind(*ssock, (struct sockaddr *)&saddr, sizeof(saddr)) == -1) {\n        crm_perror(LOG_ERR, \"Can not bind server socket.\" ERROR_SUFFIX);\n        close(*ssock);\n        free(ssock);\n        return -2;\n    }\n    if (listen(*ssock, 10) == -1) {\n        crm_perror(LOG_ERR, \"Can not start listen.\" ERROR_SUFFIX);\n        close(*ssock);\n        free(ssock);\n        return -3;\n    }\n    mainloop_add_fd(\"cib-remote\", G_PRIORITY_DEFAULT, *ssock, ssock, &remote_listen_fd_callbacks);\n    return *ssock;\n}", "target": 1}
{"code": "Java_org_tensorflow_lite_InterpreterTest_getNativeHandleForDelegate(\n    JNIEnv* env, jclass clazz) {\n  static TfLiteRegistration registration = {\n      .init = nullptr,\n      .free = nullptr,\n      .prepare =\n          [](TfLiteContext* context, TfLiteNode* node) {\n            const TfLiteTensor* input = tflite::GetInput(context, node, 0);\n            TfLiteTensor* output = tflite::GetOutput(context, node, 0);\n            TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input->dims);\n            output->type = kTfLiteFloat32;\n            return context->ResizeTensor(context, output, output_dims);\n          },\n      .invoke =\n          [](TfLiteContext* context, TfLiteNode* node) {\n            TfLiteTensor* output = tflite::GetOutput(context, node, 0);\n            std::fill(output->data.f,\n                      output->data.f + tflite::NumElements(output), 7.0f);\n            return kTfLiteOk;\n          },\n      .profiling_string = nullptr,\n      .builtin_code = 0,\n      .custom_name = \"\",\n      .version = 1,\n  };\n  static TfLiteDelegate delegate = {\n      .data_ = nullptr,\n      .Prepare = [](TfLiteContext* context,\n                    TfLiteDelegate* delegate) -> TfLiteStatus {\n        TfLiteIntArray* execution_plan;\n        TF_LITE_ENSURE_STATUS(\n            context->GetExecutionPlan(context, &execution_plan));\n        context->ReplaceNodeSubsetsWithDelegateKernels(\n            context, registration, execution_plan, delegate);\n        for (size_t i = 0; i < context->tensors_size; ++i) {\n          context->tensors[i].delegate = delegate;\n          context->tensors[i].buffer_handle = static_cast<int>(i);\n        }\n        return kTfLiteOk;\n      },\n      .CopyFromBufferHandle = nullptr,\n      .CopyToBufferHandle = nullptr,\n      .FreeBufferHandle = nullptr,\n      .flags = kTfLiteDelegateFlagsAllowDynamicTensors,\n  };\n  return reinterpret_cast<jlong>(&delegate);\n}", "target": 1}
{"code": "ikev2_vid_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep _U_,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tconst u_char *vid;\n\tint i, len;\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tikev2_pay_print(ndo, NPSTR(tpay), e.critical);\n\tND_PRINT((ndo,\" len=%d vid=\", ntohs(e.len) - 4));\n\tvid = (const u_char *)(ext+1);\n\tlen = ntohs(e.len) - 4;\n\tND_TCHECK2(*vid, len);\n\tfor(i=0; i<len; i++) {\n\t\tif(ND_ISPRINT(vid[i])) ND_PRINT((ndo, \"%c\", vid[i]));\n\t\telse ND_PRINT((ndo, \".\"));\n\t}\n\tif (2 < ndo->ndo_vflag && 4 < len) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 0}
{"code": "void unix_notinflight(struct user_struct *user, struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\tspin_lock(&unix_gc_lock);\n\tif (s) {\n\t\tstruct unix_sock *u = unix_sk(s);\n\t\tBUG_ON(list_empty(&u->link));\n\t\tif (atomic_long_dec_and_test(&u->inflight))\n\t\t\tlist_del_init(&u->link);\n\t\tunix_tot_inflight--;\n\t}\n\tuser->unix_inflight--;\n\tspin_unlock(&unix_gc_lock);\n}", "target": 0}
{"code": "static void sctp_auto_asconf_init(struct sctp_sock *sp)\n{\n\tstruct net *net = sock_net(&sp->inet.sk);\n\tif (net->sctp.default_auto_asconf) {\n\t\tspin_lock(&net->sctp.addr_wq_lock);\n\t\tlist_add_tail(&sp->auto_asconf_list, &net->sctp.auto_asconf_splist);\n\t\tspin_unlock(&net->sctp.addr_wq_lock);\n\t\tsp->do_auto_asconf = 1;\n\t}\n}", "target": 1}
{"code": "pthread_mutex_lock(pthread_mutex_t *mutex)\n{\n\tEnterCriticalSection(mutex);\n\treturn 0;\n}", "target": 1}
{"code": "int ptrace_setxregs(struct task_struct *child, void __user *uregs)\n{\n\tstruct thread_info *ti = task_thread_info(child);\n\tstruct pt_regs *regs = task_pt_regs(child);\n\telf_xtregs_t *xtregs = uregs;\n\tint ret = 0;\n\tif (!access_ok(VERIFY_READ, uregs, sizeof(elf_xtregs_t)))\n\t\treturn -EFAULT;\n#if XTENSA_HAVE_COPROCESSORS\n\tcoprocessor_flush_all(ti);\n\tcoprocessor_release_all(ti);\n\tret |= __copy_from_user(&ti->xtregs_cp, &xtregs->cp0, \n\t\t\t\tsizeof(xtregs_coprocessor_t));\n#endif\n\tret |= __copy_from_user(&regs->xtregs_opt, &xtregs->opt,\n\t\t\t\tsizeof(xtregs->opt));\n\tret |= __copy_from_user(&ti->xtregs_user, &xtregs->user,\n\t\t\t\tsizeof(xtregs->user));\n\treturn ret ? -EFAULT : 0;\n}", "target": 0}
{"code": "static int amd_gpio_remove(struct platform_device *pdev)\n{\n\tstruct amd_gpio *gpio_dev;\n\tgpio_dev = platform_get_drvdata(pdev);\n\tgpiochip_remove(&gpio_dev->gc);\n\tpinctrl_unregister(gpio_dev->pctrl);\n\treturn 0;\n}", "target": 1}
{"code": "static void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps)\n{\n\tint i;\n\tint j;\n\tint thresh;\n\tjpc_fix_t val;\n\tjpc_fix_t mag;\n\tbool warn;\n\tuint_fast32_t mask;\n\tif (roishift == 0 && bgshift == 0) {\n\t\treturn;\n\t}\n\tthresh = 1 << roishift;\n\twarn = false;\n\tfor (i = 0; i < jas_matrix_numrows(x); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(x); ++j) {\n\t\t\tval = jas_matrix_get(x, i, j);\n\t\t\tmag = JAS_ABS(val);\n\t\t\tif (mag >= thresh) {\n\t\t\t\tmag >>= roishift;\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t} else {\n\t\t\t\tmag <<= bgshift;\n\t\t\t\tmask = (1 << numbps) - 1;\n\t\t\t\tif (mag & (~mask)) {\n\t\t\t\t\tif (!warn) {\n\t\t\t\t\t\tjas_eprintf(\"warning: possibly corrupt code stream\\n\");\n\t\t\t\t\t\twarn = true;\n\t\t\t\t\t}\n\t\t\t\t\tmag &= mask;\n\t\t\t\t}\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t}\n\t\t}\n\t}\n}", "target": 1}
{"code": "cib_remote_auth(xmlNode *login)\n{\n    const char *user = NULL;\n    const char *pass = NULL;\n    const char *tmp = NULL;\n    crm_log_xml_info(login, \"Login: \");\n    if (login == NULL) {\n        return FALSE;\n    }\n    tmp = crm_element_name(login);\n    if (safe_str_neq(tmp, \"cib_command\")) {\n        crm_err(\"Wrong tag: %s\", tmp);\n        return FALSE;\n    }\n    tmp = crm_element_value(login, \"op\");\n    if (safe_str_neq(tmp, \"authenticate\")) {\n        crm_err(\"Wrong operation: %s\", tmp);\n        return FALSE;\n    }\n    user = crm_element_value(login, \"user\");\n    pass = crm_element_value(login, \"password\");\n    if (!user || !pass) {\n        crm_err(\"missing auth credentials\");\n        return FALSE;\n    }\n    if (check_group_membership(user, CRM_DAEMON_GROUP) == FALSE) {\n        crm_err(\"User is not a member of the required group\");\n        return FALSE;\n    } else if (authenticate_user(user, pass) == FALSE) {\n        crm_err(\"PAM auth failed\");\n        return FALSE;\n    }\n    return TRUE;\n}", "target": 0}
{"code": "int mp_unpack_full(lua_State *L, int limit, int offset) {\n    size_t len;\n    const char *s;\n    mp_cur c;\n    int cnt; \n    int decode_all = (!limit && !offset);\n    s = luaL_checklstring(L,1,&len); \n    if (offset < 0 || limit < 0) \n        return luaL_error(L,\n            \"Invalid request to unpack with offset of %d and limit of %d.\",\n            offset, len);\n    else if (offset > len)\n        return luaL_error(L,\n            \"Start offset %d greater than input length %d.\", offset, len);\n    if (decode_all) limit = INT_MAX;\n    mp_cur_init(&c,(const unsigned char *)s+offset,len-offset);\n    for(cnt = 0; c.left > 0 && cnt < limit; cnt++) {\n        mp_decode_to_lua_type(L,&c);\n        if (c.err == MP_CUR_ERROR_EOF) {\n            return luaL_error(L,\"Missing bytes in input.\");\n        } else if (c.err == MP_CUR_ERROR_BADFMT) {\n            return luaL_error(L,\"Bad data format in input.\");\n        }\n    }\n    if (!decode_all) {\n        int offset = len - c.left;\n        luaL_checkstack(L, 1, \"in function mp_unpack_full\");\n        lua_pushinteger(L, c.left == 0 ? -1 : offset);\n        lua_insert(L, 2);\n        cnt += 1; \n    }\n    return cnt;\n}", "target": 0}
{"code": "jp2_box_t *jp2_box_create(int type)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\treturn 0;\n\t}\n\tmemset(box, 0, sizeof(jp2_box_t));\n\tbox->type = type;\n\tbox->len = 0;\n\tif (!(boxinfo = jp2_boxinfolookup(type))) {\n\t\treturn 0;\n\t}\n\tbox->info = boxinfo;\n\tbox->ops = &boxinfo->ops;\n\treturn box;\n}", "target": 1}
{"code": "static GF_Err gf_isom_set_root_iod(GF_ISOFile *movie)\n{\n\tGF_IsomInitialObjectDescriptor *iod;\n\tGF_IsomObjectDescriptor *od;\n\tGF_Err e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\tif (!movie->moov->iods) {\n\t\tAddMovieIOD(movie->moov, 1);\n\t\treturn GF_OK;\n\t}\n\tif (movie->moov->iods->descriptor->tag == GF_ODF_ISOM_IOD_TAG) return GF_OK;\n\tod = (GF_IsomObjectDescriptor *) movie->moov->iods->descriptor;\n\tiod = (GF_IsomInitialObjectDescriptor*)gf_malloc(sizeof(GF_IsomInitialObjectDescriptor));\n\tif (!iod) return GF_OUT_OF_MEM;\n\tmemset(iod, 0, sizeof(GF_IsomInitialObjectDescriptor));\n\tiod->ES_ID_IncDescriptors = od->ES_ID_IncDescriptors;\n\tod->ES_ID_IncDescriptors = NULL;\n\tiod->ES_ID_RefDescriptors = NULL;\n\tiod->extensionDescriptors = od->extensionDescriptors;\n\tod->extensionDescriptors = NULL;\n\tiod->IPMP_Descriptors = od->IPMP_Descriptors;\n\tod->IPMP_Descriptors = NULL;\n\tiod->objectDescriptorID = od->objectDescriptorID;\n\tiod->OCIDescriptors = od->OCIDescriptors;\n\tod->OCIDescriptors = NULL;\n\tiod->tag = GF_ODF_ISOM_IOD_TAG;\n\tiod->URLString = od->URLString;\n\tod->URLString = NULL;\n\tgf_odf_desc_del((GF_Descriptor *) od);\n\tmovie->moov->iods->descriptor = (GF_Descriptor *)iod;\n\treturn GF_OK;\n}", "target": 1}
{"code": "static int send_release(uint32_t server, uint32_t ciaddr)\n{\n\tstruct dhcp_packet packet;\n\tinit_packet(&packet, DHCPRELEASE);\n\tpacket.ciaddr = ciaddr;\n\tudhcp_add_simple_option(&packet, DHCP_SERVER_ID, server);\n\tbb_info_msg(\"Sending release...\");\n\treturn bcast_or_ucast(&packet, ciaddr, server);\n}", "target": 0}
{"code": "u64 gf_net_get_ntp_ts()\n{\n\tu64 res;\n\tu32 sec, frac;\n\tgf_net_get_ntp(&sec, &frac);\n\tres = sec;\n\tres<<= 32;\n\tres |= frac;\n\treturn res;\n}", "target": 0}
{"code": "receive_carbon(void **state)\n{\n    prof_input(\"/carbons on\");\n    prof_connect();\n    assert_true(stbbr_received(\n        \"<iq id='*' type='set'><enable xmlns='urn:xmpp:carbons:2'/></iq>\"\n    ));\n    stbbr_send(\n        \"<presence to='stabber@localhost' from='buddy1@localhost/mobile'>\"\n            \"<priority>10</priority>\"\n            \"<status>On my mobile</status>\"\n        \"</presence>\"\n    );\n    assert_true(prof_output_exact(\"Buddy1 (mobile) is online, \\\"On my mobile\\\"\"));\n    prof_input(\"/msg Buddy1\");\n    assert_true(prof_output_exact(\"unencrypted\"));\n    stbbr_send(\n        \"<message type='chat' to='stabber@localhost/profanity' from='buddy1@localhost'>\"\n            \"<received xmlns='urn:xmpp:carbons:2'>\"\n                \"<forwarded xmlns='urn:xmpp:forward:0'>\"\n                    \"<message id='prof_msg_7' xmlns='jabber:client' type='chat' lang='en' to='stabber@localhost/profanity' from='buddy1@localhost/mobile'>\"\n                        \"<body>test carbon from recipient</body>\"\n                    \"</message>\"\n                \"</forwarded>\"\n            \"</received>\"\n        \"</message>\"\n    );\n    assert_true(prof_output_regex(\"Buddy1/mobile: .+test carbon from recipient\"));\n}", "target": 1}
{"code": "static void mq_flush_data_end_io(struct request *rq, int error)\n{\n\tstruct request_queue *q = rq->q;\n\tstruct blk_mq_hw_ctx *hctx;\n\tstruct blk_mq_ctx *ctx = rq->mq_ctx;\n\tunsigned long flags;\n\tstruct blk_flush_queue *fq = blk_get_flush_queue(q, ctx);\n\thctx = q->mq_ops->map_queue(q, ctx->cpu);\n\tspin_lock_irqsave(&fq->mq_flush_lock, flags);\n\tif (blk_flush_complete_seq(rq, fq, REQ_FSEQ_DATA, error))\n\t\tblk_mq_run_hw_queue(hctx, true);\n\tspin_unlock_irqrestore(&fq->mq_flush_lock, flags);\n}", "target": 0}
{"code": "daemon_linux_lvm2_lv_remove_authorized_cb (Daemon *daemon,\n                                           Device *device,\n                                           DBusGMethodInvocation *context,\n                                           const gchar *action_id,\n                                           guint num_user_data,\n                                           gpointer *user_data_elements)\n{\n  const gchar *group_uuid = user_data_elements[0];\n  const gchar *uuid = user_data_elements[1];\n  gchar *lv_name;\n  guint n;\n  gchar *argv[10];\n  lv_name = find_lvm2_lv_name_for_uuids (daemon, group_uuid, uuid);\n  if (lv_name == NULL)\n    {\n      throw_error (context, ERROR_FAILED, \"Cannot find LV with UUID `%s'\", uuid);\n      goto out;\n    }\n  n = 0;\n  argv[n++] = \"lvremove\";\n  argv[n++] = lv_name;\n  argv[n++] = \"--force\";\n  argv[n++] = NULL;\n  if (!job_new (context, \"LinuxLvm2LVRemove\", TRUE, NULL, argv, NULL, linux_lvm2_lv_remove_completed_cb, FALSE, NULL, NULL))\n    {\n      goto out;\n    }\n out:\n  g_free (lv_name);\n}", "target": 0}
{"code": "int av_reallocp_array(void *ptr, size_t nmemb, size_t size)\n{\n    void **ptrptr = ptr;\n    *ptrptr = av_realloc_f(*ptrptr, nmemb, size);\n    if (!*ptrptr && !(nmemb && size))\n        return AVERROR(ENOMEM);\n    return 0;\n}", "target": 1}
{"code": "    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,\n                                       const UBaseType_t uxItemSize,\n                                       const uint8_t ucQueueType )\n    {\n        Queue_t * pxNewQueue;\n        size_t xQueueSizeInBytes;\n        uint8_t * pucQueueStorage;\n        configASSERT( uxQueueLength > ( UBaseType_t ) 0 );\n        xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); \n        configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );\n        configASSERT( ( sizeof( Queue_t ) + xQueueSizeInBytes ) >  xQueueSizeInBytes );\n        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); \n        if( pxNewQueue != NULL )\n        {\n            pucQueueStorage = ( uint8_t * ) pxNewQueue;\n            pucQueueStorage += sizeof( Queue_t ); \n            #if ( configSUPPORT_STATIC_ALLOCATION == 1 )\n                {\n                    pxNewQueue->ucStaticallyAllocated = pdFALSE;\n                }\n            #endif \n            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );\n        }\n        else\n        {\n            traceQUEUE_CREATE_FAILED( ucQueueType );\n            mtCOVERAGE_TEST_MARKER();\n        }\n        return pxNewQueue;\n    }", "target": 0}
{"code": "static void nfs4_open_release(void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state *state = NULL;\n\tif (data->cancelled == 0)\n\t\tgoto out_free;\n\tif (data->rpc_status != 0 || !data->rpc_done)\n\t\tgoto out_free;\n\tif (data->o_res.rflags & NFS4_OPEN_RESULT_CONFIRM)\n\t\tgoto out_free;\n\tstate = nfs4_opendata_to_nfs4_state(data);\n\tif (!IS_ERR(state))\n\t\tnfs4_close_state(&data->path, state, data->o_arg.open_flags);\nout_free:\n\tnfs4_opendata_put(data);\n}", "target": 1}
{"code": "static void vgacon_scrollback_reset(int vc_num, size_t reset_size)\n{\n\tstruct vgacon_scrollback_info *scrollback = &vgacon_scrollbacks[vc_num];\n\tif (scrollback->data && reset_size > 0)\n\t\tmemset(scrollback->data, 0, reset_size);\n\tscrollback->cnt  = 0;\n\tscrollback->tail = 0;\n\tscrollback->cur  = 0;\n}", "target": 1}
{"code": "pte_t *huge_pmd_share(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t      unsigned long addr, pud_t *pud)\n{\n\tstruct address_space *mapping = vma->vm_file->f_mapping;\n\tpgoff_t idx = ((addr - vma->vm_start) >> PAGE_SHIFT) +\n\t\t\tvma->vm_pgoff;\n\tstruct vm_area_struct *svma;\n\tunsigned long saddr;\n\tpte_t *spte = NULL;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\ti_mmap_assert_locked(mapping);\n\tvma_interval_tree_foreach(svma, &mapping->i_mmap, idx, idx) {\n\t\tif (svma == vma)\n\t\t\tcontinue;\n\t\tsaddr = page_table_shareable(svma, vma, addr, idx);\n\t\tif (saddr) {\n\t\t\tspte = huge_pte_offset(svma->vm_mm, saddr,\n\t\t\t\t\t       vma_mmu_pagesize(svma));\n\t\t\tif (spte) {\n\t\t\t\tget_page(virt_to_page(spte));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!spte)\n\t\tgoto out;\n\tptl = huge_pte_lock(hstate_vma(vma), mm, spte);\n\tif (pud_none(*pud)) {\n\t\tpud_populate(mm, pud,\n\t\t\t\t(pmd_t *)((unsigned long)spte & PAGE_MASK));\n\t\tmm_inc_nr_pmds(mm);\n\t} else {\n\t\tput_page(virt_to_page(spte));\n\t}\n\tspin_unlock(ptl);\nout:\n\tpte = (pte_t *)pmd_alloc(mm, pud, addr);\n\treturn pte;\n}", "target": 0}
{"code": "bool ZlibInStream::decompress(bool wait)\n{\n  if (!underlying)\n    throw Exception(\"ZlibInStream overrun: no underlying stream\");\n  zs->next_out = (U8*)end;\n  zs->avail_out = start + bufSize - end;\n  int n = underlying->check(1, 1, wait);\n  if (n == 0) return false;\n  zs->next_in = (U8*)underlying->getptr();\n  zs->avail_in = underlying->getend() - underlying->getptr();\n  if ((int)zs->avail_in > bytesIn)\n    zs->avail_in = bytesIn;\n  int rc = inflate(zs, Z_SYNC_FLUSH);\n  if (rc != Z_OK) {\n    throw Exception(\"ZlibInStream: inflate failed\");\n  }\n  bytesIn -= zs->next_in - underlying->getptr();\n  end = zs->next_out;\n  underlying->setptr(zs->next_in);\n  return true;\n}", "target": 0}
{"code": "static int bcm_delete_rx_op(struct list_head *ops, struct bcm_msg_head *mh,\n\t\t\t    int ifindex)\n{\n\tstruct bcm_op *op, *n;\n\tlist_for_each_entry_safe(op, n, ops, list) {\n\t\tif ((op->can_id == mh->can_id) && (op->ifindex == ifindex) &&\n\t\t    (op->flags & CAN_FD_FRAME) == (mh->flags & CAN_FD_FRAME)) {\n\t\t\tif (op->ifindex) {\n\t\t\t\tif (op->rx_reg_dev) {\n\t\t\t\t\tstruct net_device *dev;\n\t\t\t\t\tdev = dev_get_by_index(sock_net(op->sk),\n\t\t\t\t\t\t\t       op->ifindex);\n\t\t\t\t\tif (dev) {\n\t\t\t\t\t\tbcm_rx_unreg(dev, op);\n\t\t\t\t\t\tdev_put(dev);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tcan_rx_unregister(sock_net(op->sk), NULL,\n\t\t\t\t\t\t  op->can_id,\n\t\t\t\t\t\t  REGMASK(op->can_id),\n\t\t\t\t\t\t  bcm_rx_handler, op);\n\t\t\tlist_del(&op->list);\n\t\t\tsynchronize_rcu();\n\t\t\tbcm_remove_op(op);\n\t\t\treturn 1; \n\t\t}\n\t}\n\treturn 0; \n}", "target": 0}
{"code": "IW_IMPL(unsigned int) iw_get_ui16be(const iw_byte *b)\n{\n\treturn (b[0]<<8) | b[1];\n}", "target": 1}
{"code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* data =\n      reinterpret_cast<TfLiteAudioMicrofrontendParams*>(node->user_data);\n  FrontendReset(data->state);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  if (data->out_float) {\n    GenerateFeatures<float>(data, input, output);\n  } else {\n    GenerateFeatures<int32>(data, input, output);\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static inline int ldsem_cmpxchg(long *old, long new, struct ld_semaphore *sem)\n{\n\tlong tmp = *old;\n\t*old = atomic_long_cmpxchg(&sem->count, *old, new);\n\treturn *old == tmp;\n}", "target": 1}
{"code": "struct task_struct * __cpuinit fork_idle(int cpu)\n{\n\tstruct task_struct *task;\n\tstruct pt_regs regs;\n\ttask = copy_process(CLONE_VM, 0, idle_regs(&regs), 0, NULL,\n\t\t\t    &init_struct_pid, 0);\n\tif (!IS_ERR(task))\n\t\tinit_idle(task, cpu);\n\treturn task;\n}", "target": 1}
{"code": "TypeAttr CastQuantizedTypeAttrFromExpressedType(Builder builder,\n                                                TypeAttr source, Type target,\n                                                int axis) {\n  auto source_type = source.getValue().dyn_cast_or_null<ShapedType>();\n  if (!source_type) return {};\n  auto src_ele_type = source_type.getElementType();\n  auto qtype = src_ele_type.dyn_cast<quant::QuantizedType>();\n  if (auto per_axis =\n          qtype.dyn_cast_or_null<quant::UniformQuantizedPerAxisType>()) {\n    if (axis == -1) return {};\n    qtype =\n        ResetAxisAndBroadcast(source_type.getShape(), per_axis, target, axis);\n  }\n  if (!qtype) return {};\n  Type final_type = qtype.castFromExpressedType(target);\n  if (!final_type) return {};\n  return TypeAttr::get(final_type);\n}", "target": 0}
{"code": "static int do_siocgstampns(struct net *net, struct socket *sock,\n\t\t\t   unsigned int cmd, void __user *up)\n{\n\tmm_segment_t old_fs = get_fs();\n\tstruct timespec kts;\n\tint err;\n\tset_fs(KERNEL_DS);\n\terr = sock_do_ioctl(net, sock, cmd, (unsigned long)&kts);\n\tset_fs(old_fs);\n\tif (!err)\n\t\terr = compat_put_timespec(up, &kts);\n\treturn err;\n}", "target": 1}
{"code": "CoreBasicHandler::CoreBasicHandler(CoreNetwork *parent)\n    : BasicHandler(parent),\n    _network(parent)\n{\n    connect(this, SIGNAL(displayMsg(Message::Type, BufferInfo::Type, const QString &, const QString &, const QString &, Message::Flags)),\n        network(), SLOT(displayMsg(Message::Type, BufferInfo::Type, const QString &, const QString &, const QString &, Message::Flags)));\n    connect(this, SIGNAL(putCmd(QString, const QList<QByteArray> &, const QByteArray &)),\n        network(), SLOT(putCmd(QString, const QList<QByteArray> &, const QByteArray &)));\n    connect(this, SIGNAL(putCmd(QString, const QList<QList<QByteArray>> &, const QByteArray &)),\n        network(), SLOT(putCmd(QString, const QList<QList<QByteArray>> &, const QByteArray &)));\n    connect(this, SIGNAL(putRawLine(const QByteArray &)),\n        network(), SLOT(putRawLine(const QByteArray &)));\n}", "target": 0}
{"code": "static void __net_init sctp_ctrlsock_exit(struct net *net)\n{\n\tinet_ctl_sock_destroy(net->sctp.ctl_sock);\n}", "target": 0}
{"code": "snmp_ber_decode_oid(snmp_packet_t *snmp_packet, snmp_oid_t *oid)\n{\n  uint8_t *buf_end, type;\n  uint8_t len, j;\n  div_t first;\n  if(!snmp_ber_decode_type(snmp_packet, &type)) {\n    return 0;\n  }\n  if(type != BER_DATA_TYPE_OBJECT_IDENTIFIER) {\n    return 0;\n  }\n  if(!snmp_ber_decode_length(snmp_packet, &len)) {\n    return 0;\n  }\n  buf_end = snmp_packet->in + len;\n  if(snmp_packet->used == 0) {\n    return 0;\n  }\n  snmp_packet->used--;\n  first = div(*snmp_packet->in++, 40);\n  oid->length = 0;\n  oid->data[oid->length++] = (uint32_t)first.quot;\n  oid->data[oid->length++] = (uint32_t)first.rem;\n  while(snmp_packet->in != buf_end) {\n    if(oid->length >= SNMP_MSG_OID_MAX_LEN) {\n      return 0;\n    }\n    if(snmp_packet->used == 0) {\n      return 0;\n    }\n    oid->data[oid->length] = (uint32_t)(*snmp_packet->in & 0x7F);\n    for(j = 0; j < 4; j++) {\n      snmp_packet->used--;\n      if((*snmp_packet->in++ & 0x80) == 0) {\n        break;\n      }\n      if(snmp_packet->used == 0) {\n        return 0;\n      }\n      oid->data[oid->length] <<= 7;\n      oid->data[oid->length] |= (*snmp_packet->in & 0x7F);\n    }\n    oid->length++;\n  }\n  return 1;\n}", "target": 0}
{"code": "static char *stibp_state(void)\n{\n\tif (spectre_v2_in_ibrs_mode(spectre_v2_enabled))\n\t\treturn \"\";\n\tswitch (spectre_v2_user_stibp) {\n\tcase SPECTRE_V2_USER_NONE:\n\t\treturn \", STIBP: disabled\";\n\tcase SPECTRE_V2_USER_STRICT:\n\t\treturn \", STIBP: forced\";\n\tcase SPECTRE_V2_USER_STRICT_PREFERRED:\n\t\treturn \", STIBP: always-on\";\n\tcase SPECTRE_V2_USER_PRCTL:\n\tcase SPECTRE_V2_USER_SECCOMP:\n\t\tif (static_key_enabled(&switch_to_cond_stibp))\n\t\t\treturn \", STIBP: conditional\";\n\t}\n\treturn \"\";\n}", "target": 1}
{"code": "inline int NumDimensions(const TfLiteTensor* t) { return t->dims->size; }", "target": 1}
{"code": "static int ras_getdatastd(jas_stream_t *in, ras_hdr_t *hdr, ras_cmap_t *cmap,\n  jas_image_t *image)\n{\n\tint pad;\n\tint nz;\n\tint z;\n\tint c;\n\tint y;\n\tint x;\n\tint v;\n\tint i;\n\tjas_matrix_t *data[3];\n\tcmap = 0;\n\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\tdata[i] = jas_matrix_create(1, jas_image_width(image));\n\t\tassert(data[i]);\n\t}\n\tpad = RAS_ROWSIZE(hdr) - (hdr->width * hdr->depth + 7) / 8;\n\tfor (y = 0; y < hdr->height; y++) {\n\t\tnz = 0;\n\t\tz = 0;\n\t\tfor (x = 0; x < hdr->width; x++) {\n\t\t\twhile (nz < hdr->depth) {\n\t\t\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tz = (z << 8) | c;\n\t\t\t\tnz += 8;\n\t\t\t}\n\t\t\tv = (z >> (nz - hdr->depth)) & RAS_ONES(hdr->depth);\n\t\t\tz &= RAS_ONES(nz - hdr->depth);\n\t\t\tnz -= hdr->depth;\n\t\t\tif (jas_image_numcmpts(image) == 3) {\n\t\t\t\tjas_matrix_setv(data[0], x, (RAS_GETRED(v)));\n\t\t\t\tjas_matrix_setv(data[1], x, (RAS_GETGREEN(v)));\n\t\t\t\tjas_matrix_setv(data[2], x, (RAS_GETBLUE(v)));\n\t\t\t} else {\n\t\t\t\tjas_matrix_setv(data[0], x, (v));\n\t\t\t}\n\t\t}\n\t\tif (pad) {\n\t\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\t\tif (jas_image_writecmpt(image, i, 0, y, hdr->width, 1,\n\t\t\t  data[i])) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\tjas_matrix_destroy(data[i]);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void m_stop(struct seq_file *m, void *v)\n{\n\tstruct proc_maps_private *priv = m->private;\n\tstruct vm_area_struct *vma = v;\n\tvma_stop(priv, vma);\n\tif (priv->task)\n\t\tput_task_struct(priv->task);\n}", "target": 1}
{"code": "static int security_context_to_sid_core(const char *scontext, u32 scontext_len,\n\t\t\t\t\tu32 *sid, u32 def_sid, gfp_t gfp_flags,\n\t\t\t\t\tint force)\n{\n\tchar *scontext2, *str = NULL;\n\tstruct context context;\n\tint rc = 0;\n\tif (!scontext_len)\n\t\treturn -EINVAL;\n\tif (!ss_initialized) {\n\t\tint i;\n\t\tfor (i = 1; i < SECINITSID_NUM; i++) {\n\t\t\tif (!strcmp(initial_sid_to_string[i], scontext)) {\n\t\t\t\t*sid = i;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t*sid = SECINITSID_KERNEL;\n\t\treturn 0;\n\t}\n\t*sid = SECSID_NULL;\n\tscontext2 = kmalloc(scontext_len + 1, gfp_flags);\n\tif (!scontext2)\n\t\treturn -ENOMEM;\n\tmemcpy(scontext2, scontext, scontext_len);\n\tscontext2[scontext_len] = 0;\n\tif (force) {\n\t\trc = -ENOMEM;\n\t\tstr = kstrdup(scontext2, gfp_flags);\n\t\tif (!str)\n\t\t\tgoto out;\n\t}\n\tread_lock(&policy_rwlock);\n\trc = string_to_context_struct(&policydb, &sidtab, scontext2,\n\t\t\t\t      scontext_len, &context, def_sid);\n\tif (rc == -EINVAL && force) {\n\t\tcontext.str = str;\n\t\tcontext.len = scontext_len;\n\t\tstr = NULL;\n\t} else if (rc)\n\t\tgoto out_unlock;\n\trc = sidtab_context_to_sid(&sidtab, &context, sid);\n\tcontext_destroy(&context);\nout_unlock:\n\tread_unlock(&policy_rwlock);\nout:\n\tkfree(scontext2);\n\tkfree(str);\n\treturn rc;\n}", "target": 0}
{"code": "      DSA_Signature_Operation(const DSA_PrivateKey& dsa, const std::string& emsa) :\n         PK_Ops::Signature_with_EMSA(emsa),\n         m_group(dsa.get_group()),\n         m_x(dsa.get_x()),\n         m_mod_q(dsa.group_q())\n         {\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n         m_rfc6979_hash = hash_for_emsa(emsa);\n#endif\n         }", "target": 1}
{"code": "comics_document_render (EvDocument      *document,\n\t\t\tEvRenderContext *rc)\n{\n\tGdkPixbuf       *pixbuf;\n\tcairo_surface_t *surface;\n\tpixbuf = comics_document_render_pixbuf (document, rc);\n\tsurface = ev_document_misc_surface_from_pixbuf (pixbuf);\n\tg_object_unref (pixbuf);\n\treturn surface;\n}", "target": 1}
{"code": "MagickExport MagickBooleanType RegisterStaticModule(const char *module,\n  ExceptionInfo *exception)\n{\n  char\n    module_name[MagickPathExtent];\n  PolicyRights\n    rights;\n  const CoderInfo\n    *p;\n  size_t\n    extent;\n  ssize_t\n    i;\n  assert(module != (const char *) NULL);\n  (void) CopyMagickString(module_name,module,MagickPathExtent);\n  p=GetCoderInfo(module,exception);\n  if (p != (CoderInfo *) NULL)\n    (void) CopyMagickString(module_name,p->name,MagickPathExtent);\n  rights=ReadPolicyRights|WritePolicyRights;\n  if (IsRightsAuthorized(ModulePolicyDomain,rights,module_name) == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",module);\n      return(MagickFalse);\n    }\n  extent=sizeof(MagickModules)/sizeof(MagickModules[0]);\n  for (i=0; i < (ssize_t) extent; i++)\n    if (LocaleCompare(MagickModules[i].module,module_name) == 0)\n      {\n        if (MagickModules[i].registered == MagickFalse)\n          {\n            (void) (MagickModules[i].register_module)();\n            MagickModules[i].registered=MagickTrue;\n          }\n        return(MagickTrue);\n      }\n  return(MagickFalse);\n}", "target": 0}
{"code": "dirserv_get_bandwidth_for_router_kb(const routerinfo_t *ri)\n{\n  uint32_t bw_kb = 0;\n  long mbw_kb = 0;\n  if (ri) {\n    if (dirserv_query_measured_bw_cache_kb(ri->cache_info.identity_digest,\n                                        &mbw_kb, NULL)) {\n      bw_kb = (uint32_t)mbw_kb;\n    } else {\n      bw_kb = router_get_advertised_bandwidth(ri) / 1000;\n    }\n  }\n  return bw_kb;\n}", "target": 0}
{"code": "dhcpv4_print(netdissect_options *ndo,\n             const u_char *cp, u_int length, int indent)\n{\n    u_int i, t;\n    const u_char *tlv, *value;\n    uint8_t type, optlen;\n    i = 0;\n    while (i < length) {\n        if (i + 2 > length)\n            return -1;\n        tlv = cp + i;\n        type = (uint8_t)tlv[0];\n        optlen = (uint8_t)tlv[1];\n        value = tlv + 2;\n        ND_PRINT((ndo, \"\\n\"));\n        for (t = indent; t > 0; t--)\n            ND_PRINT((ndo, \"\\t\"));\n        ND_PRINT((ndo, \"%s\", tok2str(dh4opt_str, \"Unknown\", type)));\n        ND_PRINT((ndo,\" (%u)\", optlen + 2 ));\n        if (i + 2 + optlen > length)\n            return -1;\n        switch (type) {\n        case DH4OPT_DNS_SERVERS:\n        case DH4OPT_NTP_SERVERS: {\n            if (optlen < 4 || optlen % 4 != 0) {\n                return -1;\n            }\n            for (t = 0; t < optlen; t += 4)\n                ND_PRINT((ndo, \" %s\", ipaddr_string(ndo, value + t)));\n        }\n            break;\n        case DH4OPT_DOMAIN_SEARCH: {\n            const u_char *tp = value;\n            while (tp < value + optlen) {\n                ND_PRINT((ndo, \" \"));\n                if ((tp = ns_nprint(ndo, tp, value + optlen)) == NULL)\n                    return -1;\n            }\n        }\n            break;\n        }\n        i += 2 + optlen;\n    }\n    return 0;\n}", "target": 0}
{"code": "print_bacp_config_options(netdissect_options *ndo,\n                          const u_char *p, int length)\n{\n\tint len, opt;\n\tif (length < 2)\n\t\treturn 0;\n\tND_TCHECK2(*p, 2);\n\tlen = p[1];\n\topt = p[0];\n\tif (length < len)\n\t\treturn 0;\n\tif (len < 2) {\n\t\tND_PRINT((ndo, \"\\n\\t  %s Option (0x%02x), length %u (length bogus, should be >= 2)\",\n\t\t          tok2str(bacconfopts_values, \"Unknown\", opt),\n\t\t          opt,\n\t\t          len));\n\t\treturn 0;\n\t}\n\tND_PRINT((ndo, \"\\n\\t  %s Option (0x%02x), length %u\",\n\t          tok2str(bacconfopts_values, \"Unknown\", opt),\n\t          opt,\n\t          len));\n\tswitch (opt) {\n\tcase BACPOPT_FPEER:\n\t\tif (len != 6) {\n\t\t\tND_PRINT((ndo, \" (length bogus, should be = 6)\"));\n\t\t\treturn len;\n\t\t}\n\t\tND_TCHECK2(*(p + 2), 4);\n\t\tND_PRINT((ndo, \": Magic-Num 0x%08x\", EXTRACT_32BITS(p + 2)));\n\t\tbreak;\n\tdefault:\n\t\tif (ndo->ndo_vflag < 2)\n\t\t\tprint_unknown_data(ndo, &p[2], \"\\n\\t    \", len - 2);\n\t\tbreak;\n\t}\n\tif (ndo->ndo_vflag > 1)\n\t\tprint_unknown_data(ndo, &p[2], \"\\n\\t    \", len - 2); \n\treturn len;\ntrunc:\n\tND_PRINT((ndo, \"[|bacp]\"));\n\treturn 0;\n}", "target": 1}
{"code": "decode_definite_long_string(CBORDecoderObject *self, Py_ssize_t length)\n{\n    PyObject *ret = NULL, *chunk = NULL, *string = NULL;\n    Py_ssize_t left = length;\n    Py_ssize_t consumed;\n    Py_ssize_t buffer_size = 0;  \n    Py_ssize_t buffer_length = 0;  \n    char *buffer = NULL;\n    while (left) {\n        Py_ssize_t chunk_length = 65536 - buffer_size;\n        if (left < chunk_length)\n            chunk_length = left;\n        PyObject *chunk = fp_read_object(self, chunk_length);\n        left -= chunk_length;\n        if (!chunk)\n            goto error;\n        char *bytes_buffer = PyBytes_AsString(chunk);\n        if (!bytes_buffer)\n            goto error;\n        char *source_buffer;\n        if (buffer) {\n            if (buffer_length + chunk_length > buffer_size) {\n                buffer_size = buffer_length + chunk_length;\n                char *new_buffer = PyMem_Realloc(buffer, buffer_size);\n                if (!new_buffer)\n                    goto error;\n                buffer = new_buffer;\n            }\n            memcpy(buffer + buffer_length, bytes_buffer, chunk_length);\n            buffer_length += chunk_length;\n            source_buffer = buffer;\n            chunk_length = buffer_length;\n        } else {\n            source_buffer = bytes_buffer;\n        }\n        string = PyUnicode_DecodeUTF8Stateful(source_buffer, chunk_length, NULL, &consumed);\n        if (!string)\n            goto error;\n        if (ret) {\n            PyObject *joined = PyUnicode_Concat(ret, string);\n            if (!joined)\n                goto error;\n            Py_DECREF(string);\n            string = NULL;\n            ret = joined;\n        } else {\n            ret = string;\n        }\n        Py_ssize_t unconsumed = chunk_length - consumed;\n        if (consumed != chunk_length) {\n            if (buffer) {\n                memmove(buffer, buffer + consumed, unconsumed);\n            } else {\n                buffer = PyMem_Malloc(unconsumed);\n                if (!buffer)\n                    goto error;\n                memcpy(buffer, bytes_buffer + consumed, unconsumed);\n            }\n            buffer_length = unconsumed;\n        }\n    }\n    if (ret && string_namespace_add(self, ret, length) == -1)\n        goto error;\n    return ret;\nerror:\n    Py_XDECREF(ret);\n    Py_XDECREF(chunk);\n    Py_XDECREF(string);\n    if (buffer)\n        PyMem_Free(buffer);\n    return NULL;\n}", "target": 0}
{"code": "deltas_head_values_set(struct deltas_head *deltas)\n{\n\treturn deltas->len == deltas->capacity;\n}", "target": 1}
{"code": "static Bool leap_year(u32 year) {\n\tyear += 1900;\n\treturn (year % 4) == 0 && ((year % 100) != 0 || (year % 400) == 0) ? GF_TRUE : GF_FALSE;\n}", "target": 0}
{"code": "yy_location_print_ (FILE *yyo, YYLTYPE const * const yylocp)\n{\n  int res = 0;\n  int end_col = 0 != yylocp->last_column ? yylocp->last_column - 1 : 0;\n  if (0 <= yylocp->first_line)\n    {\n      res += YYFPRINTF (yyo, \"%d\", yylocp->first_line);\n      if (0 <= yylocp->first_column)\n        res += YYFPRINTF (yyo, \".%d\", yylocp->first_column);\n    }\n  if (0 <= yylocp->last_line)\n    {\n      if (yylocp->first_line < yylocp->last_line)\n        {\n          res += YYFPRINTF (yyo, \"-%d\", yylocp->last_line);\n          if (0 <= end_col)\n            res += YYFPRINTF (yyo, \".%d\", end_col);\n        }\n      else if (0 <= end_col && yylocp->first_column < end_col)\n        res += YYFPRINTF (yyo, \"-%d\", end_col);\n    }\n  return res;\n }", "target": 1}
{"code": "void aio_complete(struct kiocb *iocb, long res, long res2)\n{\n\tstruct kioctx\t*ctx = iocb->ki_ctx;\n\tstruct aio_ring\t*ring;\n\tstruct io_event\t*ev_page, *event;\n\tunsigned tail, pos, head;\n\tunsigned long\tflags;\n\tif (is_sync_kiocb(iocb)) {\n\t\tiocb->ki_user_data = res;\n\t\tsmp_wmb();\n\t\tiocb->ki_ctx = ERR_PTR(-EXDEV);\n\t\twake_up_process(iocb->ki_obj.tsk);\n\t\treturn;\n\t}\n\tif (iocb->ki_list.next) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&ctx->ctx_lock, flags);\n\t\tlist_del(&iocb->ki_list);\n\t\tspin_unlock_irqrestore(&ctx->ctx_lock, flags);\n\t}\n\tspin_lock_irqsave(&ctx->completion_lock, flags);\n\ttail = ctx->tail;\n\tpos = tail + AIO_EVENTS_OFFSET;\n\tif (++tail >= ctx->nr_events)\n\t\ttail = 0;\n\tev_page = kmap_atomic(ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE]);\n\tevent = ev_page + pos % AIO_EVENTS_PER_PAGE;\n\tevent->obj = (u64)(unsigned long)iocb->ki_obj.user;\n\tevent->data = iocb->ki_user_data;\n\tevent->res = res;\n\tevent->res2 = res2;\n\tkunmap_atomic(ev_page);\n\tflush_dcache_page(ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE]);\n\tpr_debug(\"%p[%u]: %p: %p %Lx %lx %lx\\n\",\n\t\t ctx, tail, iocb, iocb->ki_obj.user, iocb->ki_user_data,\n\t\t res, res2);\n\tsmp_wmb();\t\n\tctx->tail = tail;\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\thead = ring->head;\n\tring->tail = tail;\n\tkunmap_atomic(ring);\n\tflush_dcache_page(ctx->ring_pages[0]);\n\tctx->completed_events++;\n\tif (ctx->completed_events > 1)\n\t\trefill_reqs_available(ctx, head, tail);\n\tspin_unlock_irqrestore(&ctx->completion_lock, flags);\n\tpr_debug(\"added to ring %p at [%u]\\n\", iocb, tail);\n\tif (iocb->ki_eventfd != NULL)\n\t\teventfd_signal(iocb->ki_eventfd, 1);\n\tkiocb_free(iocb);\n\tsmp_mb();\n\tif (waitqueue_active(&ctx->wait))\n\t\twake_up(&ctx->wait);\n\tpercpu_ref_put(&ctx->reqs);\n}", "target": 0}
{"code": "int hns_rcb_get_ring_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn HNS_RING_STATIC_REG_NUM;\n\treturn 0;\n}", "target": 1}
{"code": "static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)\n{\n    return primes[hashtable->num_buckets];\n}", "target": 1}
{"code": "static void _ltc_ecc_free_public_key(struct ecc_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\tcrypto_bignum_free(s->x);\n\tcrypto_bignum_free(s->y);\n}", "target": 1}
{"code": "TEE_Result syscall_cryp_obj_populate(unsigned long obj,\n\t\t\tstruct utee_attribute *usr_attrs,\n\t\t\tunsigned long attr_count)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tTEE_Attribute *attrs = NULL;\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\tattrs = malloc(sizeof(TEE_Attribute) * attr_count);\n\tif (!attrs)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_attrs, attr_count,\n\t\t\t    attrs);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_POPULATE, type_props,\n\t\t\t\t      attrs, attr_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\tres = tee_svc_cryp_obj_populate_type(o, type_props, attrs, attr_count);\n\tif (res == TEE_SUCCESS)\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\nout:\n\tfree(attrs);\n\treturn res;\n}", "target": 1}
{"code": "static u32 rgb_48_to_32(char *val)\n{\n\tu32 res = 0x0;\n\tu32 i;\n\tfor (i=0; i<3; i++) {\n\t\tu32 v = val[2*i];\n\t\tv<<=8;\n\t\tv|=val[2*i + 1];\n\t\tv/=0xFF;\n\t\tres <<= 8;\n\t\tres |= v;\n\t}\n\treturn res;\n}", "target": 0}
{"code": "static inline pmd_t pmdp_get_and_clear(struct mm_struct *mm,\n\t\t\t\t       unsigned long address,\n\t\t\t\t       pmd_t *pmdp)\n{\n\tpmd_t pmd = *pmdp;\n\tpmd_clear(pmdp);\n\treturn pmd;\n}", "target": 0}
{"code": "njs_array_convert_to_slow_array(njs_vm_t *vm, njs_array_t *array)\n{\n    uint32_t           i, length;\n    njs_value_t        index, value;\n    njs_object_prop_t  *prop;\n    if (njs_slow_path(!array->object.fast_array)) {\n        return NJS_OK;\n    }\n    njs_set_array(&value, array);\n    array->object.fast_array = 0;\n    length = array->length;\n    for (i = 0; i < length; i++) {\n        if (njs_is_valid(&array->start[i])) {\n            njs_uint32_to_string(&index, i);\n            prop = njs_object_property_add(vm, &value, &index, 0);\n            if (njs_slow_path(prop == NULL)) {\n                return NJS_ERROR;\n            }\n            prop->value = array->start[i];\n        }\n    }\n    njs_mp_free(vm->mem_pool, array->start);\n    array->start = NULL;\n    return NJS_OK;\n}", "target": 0}
{"code": "int DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g) {\n    if(!p || !g) \n        return 0;\n    BN_free(dh->p);\n    BN_free(dh->q);\n    BN_free(dh->g);\n    dh->p = p;\n    dh->q = q;\n    dh->g = g;\n    if(q)\n        dh->length = BN_num_bits(q);\n    return 1;\n}", "target": 1}
{"code": "SYSCALL_DEFINE2(clock_adjtime, const clockid_t, which_clock,\n\t\tstruct timex __user *, utx)\n{\n\tconst struct k_clock *kc = clockid_to_kclock(which_clock);\n\tstruct timex ktx;\n\tint err;\n\tif (!kc)\n\t\treturn -EINVAL;\n\tif (!kc->clock_adj)\n\t\treturn -EOPNOTSUPP;\n\tif (copy_from_user(&ktx, utx, sizeof(ktx)))\n\t\treturn -EFAULT;\n\terr = kc->clock_adj(which_clock, &ktx);\n\tif (err >= 0 && copy_to_user(utx, &ktx, sizeof(ktx)))\n\t\treturn -EFAULT;\n\treturn err;\n}", "target": 0}
{"code": "void ida_free(struct ida *ida, unsigned int id)\n{\n\tXA_STATE(xas, &ida->xa, id / IDA_BITMAP_BITS);\n\tunsigned bit = id % IDA_BITMAP_BITS;\n\tstruct ida_bitmap *bitmap;\n\tunsigned long flags;\n\tif ((int)id < 0)\n\t\treturn;\n\txas_lock_irqsave(&xas, flags);\n\tbitmap = xas_load(&xas);\n\tif (xa_is_value(bitmap)) {\n\t\tunsigned long v = xa_to_value(bitmap);\n\t\tif (bit >= BITS_PER_XA_VALUE)\n\t\t\tgoto err;\n\t\tif (!(v & (1UL << bit)))\n\t\t\tgoto err;\n\t\tv &= ~(1UL << bit);\n\t\tif (!v)\n\t\t\tgoto delete;\n\t\txas_store(&xas, xa_mk_value(v));\n\t} else {\n\t\tif (!test_bit(bit, bitmap->bitmap))\n\t\t\tgoto err;\n\t\t__clear_bit(bit, bitmap->bitmap);\n\t\txas_set_mark(&xas, XA_FREE_MARK);\n\t\tif (bitmap_empty(bitmap->bitmap, IDA_BITMAP_BITS)) {\n\t\t\tkfree(bitmap);\ndelete:\n\t\t\txas_store(&xas, NULL);\n\t\t}\n\t}\n\txas_unlock_irqrestore(&xas, flags);\n\treturn;\n err:\n\txas_unlock_irqrestore(&xas, flags);\n\tWARN(1, \"ida_free called for id=%d which is not allocated.\\n\", id);\n}", "target": 1}
{"code": "void PDPClient::notifyAboveRemoteEndpoints(\n        const ParticipantProxyData& pdata)\n{\n#if HAVE_SECURITY\n    if (mp_RTPSParticipant->is_secure())\n    {\n        eprosima::shared_lock<eprosima::shared_mutex> disc_lock(mp_builtin->getDiscoveryMutex());\n        for (auto& svr : mp_builtin->m_DiscoveryServers)\n        {\n            if (data_matches_with_prefix(svr.guidPrefix, pdata))\n            {\n                if (nullptr == svr.proxy)\n                {\n                    svr.proxy = get_participant_proxy_data(svr.guidPrefix);\n                }\n                match_pdp_reader_nts_(svr, pdata.m_guid.guidPrefix);\n                match_pdp_writer_nts_(svr, pdata.m_guid.guidPrefix);\n                break;\n            }\n        }\n    }\n#endif \n    perform_builtin_endpoints_matching(pdata);\n}", "target": 1}
{"code": "bool RequestParser::OnHeadersEnd() {\n  bool matched = view_matcher_(request_->method(), request_->url().path(),\n                               &stream_);\n  if (!matched) {\n    LOG_WARN(\"No view matches the request: %s %s\", request_->method().c_str(),\n             request_->url().path().c_str());\n  }\n  return matched;\n}", "target": 1}
{"code": "find_alternate_tgs(kdc_realm_t *kdc_active_realm, krb5_principal princ,\n                   krb5_db_entry **server_ptr, const char **status)\n{\n    krb5_error_code retval;\n    krb5_principal *plist = NULL, *pl2;\n    krb5_data tmp;\n    krb5_db_entry *server = NULL;\n    *server_ptr = NULL;\n    assert(is_cross_tgs_principal(princ));\n    if ((retval = krb5_walk_realm_tree(kdc_context,\n                                       krb5_princ_realm(kdc_context, princ),\n                                       krb5_princ_component(kdc_context, princ, 1),\n                                       &plist, KRB5_REALM_BRANCH_CHAR))) {\n        goto cleanup;\n    }\n    for (pl2 = plist; *pl2; pl2++);\n    while (--pl2 > plist) {\n        tmp = *krb5_princ_realm(kdc_context, *pl2);\n        krb5_princ_set_realm(kdc_context, *pl2,\n                             krb5_princ_realm(kdc_context, tgs_server));\n        retval = db_get_svc_princ(kdc_context, *pl2, 0, &server, status);\n        krb5_princ_set_realm(kdc_context, *pl2, &tmp);\n        if (retval == KRB5_KDB_NOENTRY)\n            continue;\n        else if (retval)\n            goto cleanup;\n        log_tgs_alt_tgt(kdc_context, server->princ);\n        *server_ptr = server;\n        server = NULL;\n        goto cleanup;\n    }\ncleanup:\n    if (retval == 0 && server_ptr == NULL)\n        retval = KRB5_KDB_NOENTRY;\n    if (retval != 0)\n        *status = \"UNKNOWN_SERVER\";\n    krb5_free_realm_tree(kdc_context, plist);\n    krb5_db_free_principal(kdc_context, server);\n    return retval;\n}", "target": 0}
{"code": "static int pf_detect(void)\n{\n\tstruct pf_unit *pf = units;\n\tint k, unit;\n\tprintk(\"%s: %s version %s, major %d, cluster %d, nice %d\\n\",\n\t       name, name, PF_VERSION, major, cluster, nice);\n\tpar_drv = pi_register_driver(name);\n\tif (!par_drv) {\n\t\tpr_err(\"failed to register %s driver\\n\", name);\n\t\treturn -1;\n\t}\n\tk = 0;\n\tif (pf_drive_count == 0) {\n\t\tif (pi_init(pf->pi, 1, -1, -1, -1, -1, -1, pf_scratch, PI_PF,\n\t\t\t    verbose, pf->name)) {\n\t\t\tif (!pf_probe(pf) && pf->disk) {\n\t\t\t\tpf->present = 1;\n\t\t\t\tk++;\n\t\t\t} else\n\t\t\t\tpi_release(pf->pi);\n\t\t}\n\t} else\n\t\tfor (unit = 0; unit < PF_UNITS; unit++, pf++) {\n\t\t\tint *conf = *drives[unit];\n\t\t\tif (!conf[D_PRT])\n\t\t\t\tcontinue;\n\t\t\tif (pi_init(pf->pi, 0, conf[D_PRT], conf[D_MOD],\n\t\t\t\t    conf[D_UNI], conf[D_PRO], conf[D_DLY],\n\t\t\t\t    pf_scratch, PI_PF, verbose, pf->name)) {\n\t\t\t\tif (pf->disk && !pf_probe(pf)) {\n\t\t\t\t\tpf->present = 1;\n\t\t\t\t\tk++;\n\t\t\t\t} else\n\t\t\t\t\tpi_release(pf->pi);\n\t\t\t}\n\t\t}\n\tif (k)\n\t\treturn 0;\n\tprintk(\"%s: No ATAPI disk detected\\n\", name);\n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tif (!pf->disk)\n\t\t\tcontinue;\n\t\tblk_cleanup_queue(pf->disk->queue);\n\t\tpf->disk->queue = NULL;\n\t\tblk_mq_free_tag_set(&pf->tag_set);\n\t\tput_disk(pf->disk);\n\t}\n\tpi_unregister_driver(par_drv);\n\treturn -1;\n}", "target": 0}
{"code": "inline FIO_FUNC ssize_t fio_sendfile(intptr_t uuid, intptr_t source_fd,\n                                     off_t offset, size_t length) {\n  return fio_write2(uuid, .data.fd = source_fd, .length = length, .is_fd = 1,\n                    .offset = offset);\n}", "target": 1}
{"code": "int LibarchivePlugin::extractionFlags() const\n{\n    int result = ARCHIVE_EXTRACT_TIME;\n    result |= ARCHIVE_EXTRACT_SECURE_NODOTDOT;\n    return result;\n}", "target": 1}
{"code": "static int __init xfrm6_tunnel_init(void)\n{\n\tint rv;\n\trv = xfrm_register_type(&xfrm6_tunnel_type, AF_INET6);\n\tif (rv < 0)\n\t\tgoto err;\n\trv = xfrm6_tunnel_register(&xfrm6_tunnel_handler, AF_INET6);\n\tif (rv < 0)\n\t\tgoto unreg;\n\trv = xfrm6_tunnel_register(&xfrm46_tunnel_handler, AF_INET);\n\tif (rv < 0)\n\t\tgoto dereg6;\n\trv = xfrm6_tunnel_spi_init();\n\tif (rv < 0)\n\t\tgoto dereg46;\n\trv = register_pernet_subsys(&xfrm6_tunnel_net_ops);\n\tif (rv < 0)\n\t\tgoto deregspi;\n\treturn 0;\nderegspi:\n\txfrm6_tunnel_spi_fini();\ndereg46:\n\txfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);\ndereg6:\n\txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\nunreg:\n\txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\nerr:\n\treturn rv;\n}", "target": 1}
{"code": "void nego_process_negotiation_failure(rdpNego* nego, wStream* s)\n{\n\tBYTE flags;\n\tUINT16 length;\n\tUINT32 failureCode;\n\tWLog_DBG(TAG, \"RDP_NEG_FAILURE\");\n\tStream_Read_UINT8(s, flags);\n\tStream_Read_UINT16(s, length);\n\tStream_Read_UINT32(s, failureCode);\n\tswitch (failureCode)\n\t{\n\t\tcase SSL_REQUIRED_BY_SERVER:\n\t\t\tWLog_WARN(TAG, \"Error: SSL_REQUIRED_BY_SERVER\");\n\t\t\tbreak;\n\t\tcase SSL_NOT_ALLOWED_BY_SERVER:\n\t\t\tWLog_WARN(TAG, \"Error: SSL_NOT_ALLOWED_BY_SERVER\");\n\t\t\tnego->sendNegoData = TRUE;\n\t\t\tbreak;\n\t\tcase SSL_CERT_NOT_ON_SERVER:\n\t\t\tWLog_ERR(TAG, \"Error: SSL_CERT_NOT_ON_SERVER\");\n\t\t\tnego->sendNegoData = TRUE;\n\t\t\tbreak;\n\t\tcase INCONSISTENT_FLAGS:\n\t\t\tWLog_ERR(TAG, \"Error: INCONSISTENT_FLAGS\");\n\t\t\tbreak;\n\t\tcase HYBRID_REQUIRED_BY_SERVER:\n\t\t\tWLog_WARN(TAG, \"Error: HYBRID_REQUIRED_BY_SERVER\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"Error: Unknown protocol security error %\" PRIu32 \"\", failureCode);\n\t\t\tbreak;\n\t}\n\tnego->state = NEGO_STATE_FAIL;\n}", "target": 1}
{"code": "vhost_user_check_and_alloc_queue_pair(struct virtio_net *dev,\n\t\t\tstruct vhu_msg_context *ctx)\n{\n\tuint32_t vring_idx;\n\tswitch (ctx->msg.request.master) {\n\tcase VHOST_USER_SET_VRING_KICK:\n\tcase VHOST_USER_SET_VRING_CALL:\n\tcase VHOST_USER_SET_VRING_ERR:\n\t\tvring_idx = ctx->msg.payload.u64 & VHOST_USER_VRING_IDX_MASK;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_NUM:\n\tcase VHOST_USER_SET_VRING_BASE:\n\tcase VHOST_USER_GET_VRING_BASE:\n\tcase VHOST_USER_SET_VRING_ENABLE:\n\t\tvring_idx = ctx->msg.payload.state.index;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_ADDR:\n\t\tvring_idx = ctx->msg.payload.addr.index;\n\t\tbreak;\n\tcase VHOST_USER_SET_INFLIGHT_FD:\n\t\tvring_idx = ctx->msg.payload.inflight.num_queues - 1;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (vring_idx >= VHOST_MAX_VRING) {\n\t\tVHOST_LOG_CONFIG(ERR, \"(%s) invalid vring index: %u\\n\", dev->ifname, vring_idx);\n\t\treturn -1;\n\t}\n\tif (dev->virtqueue[vring_idx])\n\t\treturn 0;\n\treturn alloc_vring_queue(dev, vring_idx);\n}", "target": 0}
{"code": "static void sas_probe_devices(struct work_struct *work)\n{\n\tstruct domain_device *dev, *n;\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev->port;\n\tclear_bit(DISCE_PROBE, &port->disc.pending);\n\tlist_for_each_entry(dev, &port->disco_list, disco_list_node) {\n\t\tspin_lock_irq(&port->dev_list_lock);\n\t\tlist_add_tail(&dev->dev_list_node, &port->dev_list);\n\t\tspin_unlock_irq(&port->dev_list_lock);\n\t}\n\tsas_probe_sata(port);\n\tlist_for_each_entry_safe(dev, n, &port->disco_list, disco_list_node) {\n\t\tint err;\n\t\terr = sas_rphy_add(dev->rphy);\n\t\tif (err)\n\t\t\tsas_fail_probe(dev, __func__, err);\n\t\telse\n\t\t\tlist_del_init(&dev->disco_list_node);\n\t}\n}", "target": 1}
{"code": "R_API void r_anal_bb_free(RAnalBlock *bb) {\n\tif (!bb) {\n\t\treturn;\n\t}\n\tr_anal_cond_free (bb->cond);\n\tR_FREE (bb->fingerprint);\n\tr_anal_diff_free (bb->diff);\n\tbb->diff = NULL;\n\tR_FREE (bb->op_bytes);\n\tr_anal_switch_op_free (bb->switch_op);\n\tbb->switch_op = NULL;\n\tbb->fingerprint = NULL;\n\tbb->cond = NULL;\n\tR_FREE (bb->label);\n\tR_FREE (bb->op_pos);\n\tR_FREE (bb->parent_reg_arena);\n\tif (bb->prev) {\n\t\tif (bb->prev->jumpbb == bb) {\n\t\t\tbb->prev->jumpbb = NULL;\n\t\t}\n\t\tif (bb->prev->failbb == bb) {\n\t\t\tbb->prev->failbb = NULL;\n\t\t}\n\t\tbb->prev = NULL;\n\t}\n\tif (bb->jumpbb) {\n\t\tbb->jumpbb->prev = NULL;\n\t\tbb->jumpbb = NULL;\n\t}\n\tif (bb->failbb) {\n\t\tbb->failbb->prev = NULL;\n\t\tbb->failbb = NULL;\n\t}\n\tR_FREE (bb);\n}", "target": 1}
{"code": "int mlx4_register_mac(struct mlx4_dev *dev, u8 port, u64 mac, int *index)\n{\n\tstruct mlx4_mac_table *table = &mlx4_priv(dev)->port[port].mac_table;\n\tint i, err = 0;\n\tint free = -1;\n\tmlx4_dbg(dev, \"Registering MAC: 0x%llx\\n\", (unsigned long long) mac);\n\tmutex_lock(&table->mutex);\n\tfor (i = 0; i < MLX4_MAX_MAC_NUM - 1; i++) {\n\t\tif (free < 0 && !table->refs[i]) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (mac == (MLX4_MAC_MASK & be64_to_cpu(table->entries[i]))) {\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (free < 0) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmlx4_dbg(dev, \"Free MAC index is %d\\n\", free);\n\tif (table->total == table->max) {\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be64(mac | MLX4_MAC_VALID);\n\terr = mlx4_set_port_mac_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_err(dev, \"Failed adding MAC: 0x%llx\\n\", (unsigned long long) mac);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}", "target": 0}
{"code": "  void initialize() override {\n    use_lds_ = false;\n    test_skipped_ = false;\n    setUpstreamCount(1);                         \n    setUpstreamProtocol(Http::CodecType::HTTP2); \n    defer_listener_finalization_ = true;\n    HttpIntegrationTest::initialize();\n    addFakeUpstream(Http::CodecType::HTTP2);\n    addFakeUpstream(Http::CodecType::HTTP2);\n    cluster1_ = ConfigHelper::buildStaticCluster(\n        ClusterName1, fake_upstreams_[UpstreamIndex1]->localAddress()->ip()->port(),\n        Network::Test::getLoopbackAddressString(ipVersion()));\n    cluster2_ = ConfigHelper::buildStaticCluster(\n        ClusterName2, fake_upstreams_[UpstreamIndex2]->localAddress()->ip()->port(),\n        Network::Test::getLoopbackAddressString(ipVersion()));\n    acceptXdsConnection();\n    EXPECT_TRUE(compareDiscoveryRequest(Config::TypeUrl::get().Cluster, \"\", {}, {}, {}, true));\n    sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(Config::TypeUrl::get().Cluster,\n                                                               {cluster1_}, {cluster1_}, {}, \"55\");\n    test_server_->waitForGaugeGe(\"cluster_manager.active_clusters\", 2);\n    test_server_->waitUntilListenersReady();\n    registerTestServerPorts({\"http\"});\n  }", "target": 1}
{"code": "cmndlist_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct member_list *list, const char *runchroot,\n    struct cmnd_info *info)\n{\n    struct member *m;\n    int matched = UNSPEC;\n    debug_decl(cmndlist_matches, SUDOERS_DEBUG_MATCH);\n    TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {\n\tmatched = cmnd_matches(parse_tree, m, runchroot, info);\n\tif (matched != UNSPEC)\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 1}
{"code": "xfs_attr_shortform_addname(xfs_da_args_t *args)\n{\n\tint newsize, forkoff, retval;\n\ttrace_xfs_attr_sf_addname(args);\n\tretval = xfs_attr_shortform_lookup(args);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\treturn retval;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE)\n\t\t\treturn retval;\n\t\tretval = xfs_attr_shortform_remove(args);\n\t\tASSERT(retval == 0);\n\t}\n\tif (args->namelen >= XFS_ATTR_SF_ENTSIZE_MAX ||\n\t    args->valuelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\treturn -ENOSPC;\n\tnewsize = XFS_ATTR_SF_TOTSIZE(args->dp);\n\tnewsize += XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);\n\tforkoff = xfs_attr_shortform_bytesfit(args->dp, newsize);\n\tif (!forkoff)\n\t\treturn -ENOSPC;\n\txfs_attr_shortform_add(args, forkoff);\n\treturn 0;\n}", "target": 1}
{"code": "static inline struct futex_hash_bucket *queue_lock(struct futex_q *q)\n{\n\tstruct futex_hash_bucket *hb;\n\tget_futex_key_refs(&q->key);\n\thb = hash_futex(&q->key);\n\tq->lock_ptr = &hb->lock;\n\tspin_lock(&hb->lock);\n\treturn hb;\n}", "target": 1}
{"code": "static int command_read(struct pci_dev *dev, int offset, u16 *value, void *data)\n{\n\tint i;\n\tint ret;\n\tret = xen_pcibk_read_config_word(dev, offset, value, data);\n\tif (!pci_is_enabled(dev))\n\t\treturn ret;\n\tfor (i = 0; i < PCI_ROM_RESOURCE; i++) {\n\t\tif (dev->resource[i].flags & IORESOURCE_IO)\n\t\t\t*value |= PCI_COMMAND_IO;\n\t\tif (dev->resource[i].flags & IORESOURCE_MEM)\n\t\t\t*value |= PCI_COMMAND_MEMORY;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "struct page *alloc_huge_page_nodemask(struct hstate *h, int preferred_nid,\n\t\tnodemask_t *nmask, gfp_t gfp_mask)\n{\n\tspin_lock_irq(&hugetlb_lock);\n\tif (h->free_huge_pages - h->resv_huge_pages > 0) {\n\t\tstruct page *page;\n\t\tpage = dequeue_huge_page_nodemask(h, gfp_mask, preferred_nid, nmask);\n\t\tif (page) {\n\t\t\tspin_unlock_irq(&hugetlb_lock);\n\t\t\treturn page;\n\t\t}\n\t}\n\tspin_unlock_irq(&hugetlb_lock);\n\treturn alloc_migrate_huge_page(h, gfp_mask, preferred_nid, nmask);\n}", "target": 0}
{"code": "static bool MR_primality_test(UnsignedBigInteger n, const Vector<UnsignedBigInteger, 256>& tests)\n{\n    ASSERT(!(n < 4));\n    auto predecessor = n.minus({ 1 });\n    auto d = predecessor;\n    size_t r = 0;\n    {\n        auto div_result = d.divided_by(2);\n        while (div_result.remainder == 0) {\n            d = div_result.quotient;\n            div_result = d.divided_by(2);\n            ++r;\n        }\n    }\n    if (r == 0) {\n        return n == 2;\n    }\n    for (auto a : tests) {\n        ASSERT(a < n);\n        auto x = ModularPower(a, d, n);\n        if (x == 1 || x == predecessor)\n            continue;\n        bool skip_this_witness = false;\n        for (size_t i = 0; i < r - 1; ++i) {\n            x = ModularPower(x, 2, n);\n            if (x == predecessor) {\n                skip_this_witness = true;\n                break;\n            }\n        }\n        if (skip_this_witness)\n            continue;\n        return false; \n    }\n    return true; \n}", "target": 1}
{"code": "static MagickBooleanType SkipDXTMipmaps(Image *image,DDSInfo *dds_info,\n  int texel_size,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    offset;\n  register ssize_t\n    i;\n  size_t\n    h,\n    w;\n  if (EOFBlob(image) != MagickFalse)\n    {\n      ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n        image->filename);\n      return(MagickFalse);\n    }\n  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP\n      && (dds_info->ddscaps1 & DDSCAPS_TEXTURE\n          || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))\n    {\n      w = DIV2(dds_info->width);\n      h = DIV2(dds_info->height);\n      for (i = 1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n      {\n        offset = (MagickOffsetType) ((w + 3) / 4) * ((h + 3) / 4) * texel_size;\n        (void) SeekBlob(image, offset, SEEK_CUR);\n        w = DIV2(w);\n        h = DIV2(h);\n      }\n    }\n  return(MagickTrue);\n}", "target": 1}
{"code": "static int __dwc3_gadget_kick_transfer(struct dwc3_ep *dep)\n{\n\tstruct dwc3_gadget_ep_cmd_params params;\n\tstruct dwc3_request\t\t*req;\n\tint\t\t\t\tstarting;\n\tint\t\t\t\tret;\n\tu32\t\t\t\tcmd;\n\tif (!dwc3_calc_trbs_left(dep))\n\t\treturn 0;\n\tstarting = !(dep->flags & DWC3_EP_BUSY);\n\tdwc3_prepare_trbs(dep);\n\treq = next_request(&dep->started_list);\n\tif (!req) {\n\t\tdep->flags |= DWC3_EP_PENDING_REQUEST;\n\t\treturn 0;\n\t}\n\tmemset(&params, 0, sizeof(params));\n\tif (starting) {\n\t\tparams.param0 = upper_32_bits(req->trb_dma);\n\t\tparams.param1 = lower_32_bits(req->trb_dma);\n\t\tcmd = DWC3_DEPCMD_STARTTRANSFER;\n\t\tif (usb_endpoint_xfer_isoc(dep->endpoint.desc))\n\t\t\tcmd |= DWC3_DEPCMD_PARAM(dep->frame_number);\n\t} else {\n\t\tcmd = DWC3_DEPCMD_UPDATETRANSFER |\n\t\t\tDWC3_DEPCMD_PARAM(dep->resource_index);\n\t}\n\tret = dwc3_send_gadget_ep_cmd(dep, cmd, &params);\n\tif (ret < 0) {\n\t\tif (req->trb)\n\t\t\tmemset(req->trb, 0, sizeof(struct dwc3_trb));\n\t\tdep->queued_requests--;\n\t\tdwc3_gadget_giveback(dep, req, ret);\n\t\treturn ret;\n\t}\n\tdep->flags |= DWC3_EP_BUSY;\n\tif (starting) {\n\t\tdep->resource_index = dwc3_gadget_ep_get_transfer_index(dep);\n\t\tWARN_ON_ONCE(!dep->resource_index);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "        int          GetS8    (int nPos, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            int nRes = m_sFile[ nPos ];\n            if ( nRes & 0x80 )\n                nRes |= ~0xff;\n            return nRes;\n        }", "target": 1}
{"code": "static void edge_break(struct tty_struct *tty, int break_state)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tint status;\n\tint bv = 0;\t\n\tif (break_state == -1)\n\t\tbv = 1;\t\n\tstatus = ti_do_config(edge_port, UMPC_SET_CLR_BREAK, bv);\n\tif (status)\n\t\tdev_dbg(&port->dev, \"%s - error %d sending break set/clear command.\\n\",\n\t\t\t__func__, status);\n}", "target": 0}
{"code": "int touch(const char *path) {\n        return touch_file(path, false, USEC_INFINITY, UID_INVALID, GID_INVALID, 0);\n}", "target": 1}
{"code": "static inline bool kvm_apic_has_events(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic->pending_events;\n}", "target": 1}
{"code": "int qemu_ram_resize(ram_addr_t base, ram_addr_t newsize, Error **errp)\n{\n    RAMBlock *block = find_ram_block(base);\n    assert(block);\n    newsize = TARGET_PAGE_ALIGN(newsize);\n    if (block->used_length == newsize) {\n        return 0;\n    }\n    if (!(block->flags & RAM_RESIZEABLE)) {\n        error_setg_errno(errp, EINVAL,\n                         \"Length mismatch: %s: 0x\" RAM_ADDR_FMT\n                         \" in != 0x\" RAM_ADDR_FMT, block->idstr,\n                         newsize, block->used_length);\n        return -EINVAL;\n    }\n    if (block->max_length < newsize) {\n        error_setg_errno(errp, EINVAL,\n                         \"Length too large: %s: 0x\" RAM_ADDR_FMT\n                         \" > 0x\" RAM_ADDR_FMT, block->idstr,\n                         newsize, block->max_length);\n        return -EINVAL;\n    }\n    cpu_physical_memory_clear_dirty_range(block->offset, block->used_length);\n    block->used_length = newsize;\n    cpu_physical_memory_set_dirty_range(block->offset, block->used_length,\n                                        DIRTY_CLIENTS_ALL);\n    memory_region_set_size(block->mr, newsize);\n    if (block->resized) {\n        block->resized(block->idstr, newsize, block->host);\n    }\n    return 0;\n}", "target": 0}
{"code": "int HTPFileOpenWithRange(HtpState *s, HtpTxUserData *txud, const uint8_t *filename,\n        uint16_t filename_len, const uint8_t *data, uint32_t data_len, uint64_t txid,\n        bstr *rawvalue, HtpTxUserData *htud)\n{\n    SCEnter();\n    uint16_t flags;\n    DEBUG_VALIDATE_BUG_ON(s == NULL);\n    HTTPContentRange crparsed;\n    if (HTPParseAndCheckContentRange(rawvalue, &crparsed, s, htud) != 0) {\n        return HTPFileOpen(s, txud, filename, filename_len, data, data_len, txid, STREAM_TOCLIENT);\n    }\n    flags = FileFlowToFlags(s->f, STREAM_TOCLIENT);\n    FileContainer *files = &txud->files_tc;\n    if (FileOpenFileWithId(files, &htp_sbcfg, s->file_track_id++, filename, filename_len, data,\n                data_len, flags) != 0) {\n        SCReturnInt(-1);\n    } else {\n        const HTPCfgDir *cfg = &s->cfg->response;\n        FileSetInspectSizes(files->tail, cfg->inspect_window, cfg->inspect_min_size);\n    }\n    txud->tx_data.files_opened++;\n    if (FileSetRange(files, crparsed.start, crparsed.end) < 0) {\n        SCLogDebug(\"set range failed\");\n    }\n    htp_tx_t *tx = htp_list_get(s->conn->transactions, txid);\n    if (!tx) {\n        SCReturnInt(-1);\n    }\n    uint8_t *keyurl;\n    uint32_t keylen;\n    if (tx->request_hostname != NULL) {\n        keylen = bstr_len(tx->request_hostname) + filename_len;\n        keyurl = SCMalloc(keylen);\n        if (keyurl == NULL) {\n            SCReturnInt(-1);\n        }\n        memcpy(keyurl, bstr_ptr(tx->request_hostname), bstr_len(tx->request_hostname));\n        memcpy(keyurl + bstr_len(tx->request_hostname), filename, filename_len);\n    } else {\n        SCReturnInt(0);\n    }\n    DEBUG_VALIDATE_BUG_ON(htud->file_range);\n    htud->file_range = HttpRangeContainerOpenFile(keyurl, keylen, s->f, &crparsed, &htp_sbcfg,\n            filename, filename_len, flags, data, data_len);\n    SCFree(keyurl);\n    if (htud->file_range == NULL) {\n        SCReturnInt(-1);\n    }\n    SCReturnInt(0);\n}", "target": 1}
{"code": "BOOL freerdp_image_copy(BYTE* pDstData, DWORD DstFormat, UINT32 nDstStep, UINT32 nXDst,\n                        UINT32 nYDst, UINT32 nWidth, UINT32 nHeight, const BYTE* pSrcData,\n                        DWORD SrcFormat, UINT32 nSrcStep, UINT32 nXSrc, UINT32 nYSrc,\n                        const gdiPalette* palette, UINT32 flags)\n{\n\tconst UINT32 dstByte = FreeRDPGetBytesPerPixel(DstFormat);\n\tconst UINT32 srcByte = FreeRDPGetBytesPerPixel(SrcFormat);\n\tif ((nHeight > INT32_MAX) || (nWidth > INT32_MAX))\n\t\treturn FALSE;\n\tif (!pDstData || !pSrcData)\n\t\treturn FALSE;\n\tif ((nWidth == 0) || (nHeight == 0))\n\t\treturn TRUE;\n\tif (nDstStep == 0)\n\t\tnDstStep = nWidth * FreeRDPGetBytesPerPixel(DstFormat);\n\tif (nSrcStep == 0)\n\t\tnSrcStep = nWidth * FreeRDPGetBytesPerPixel(SrcFormat);\n\tconst BOOL ovl = overlapping(pDstData, nXDst, nYDst, nDstStep, dstByte, pSrcData, nXSrc, nYSrc,\n\t                             nSrcStep, srcByte, nWidth, nHeight);\n\tif (ovl)\n\t\treturn freerdp_image_copy_overlap(pDstData, DstFormat, nDstStep, nXDst, nYDst, nWidth,\n\t\t                                  nHeight, pSrcData, SrcFormat, nSrcStep, nXSrc, nYSrc,\n\t\t                                  palette, flags);\n\treturn freerdp_image_copy_no_overlap(pDstData, DstFormat, nDstStep, nXDst, nYDst, nWidth,\n\t                                     nHeight, pSrcData, SrcFormat, nSrcStep, nXSrc, nYSrc,\n\t                                     palette, flags);\n}", "target": 0}
{"code": "bool current_chrooted(void)\n{\n\tstruct path ns_root;\n\tstruct path fs_root;\n\tbool chrooted;\n\tns_root.mnt = &current->nsproxy->mnt_ns->root->mnt;\n\tns_root.dentry = ns_root.mnt->mnt_root;\n\tpath_get(&ns_root);\n\twhile (d_mountpoint(ns_root.dentry) && follow_down_one(&ns_root))\n\t\t;\n\tget_fs_root(current->fs, &fs_root);\n\tchrooted = !path_equal(&fs_root, &ns_root);\n\tpath_put(&fs_root);\n\tpath_put(&ns_root);\n\treturn chrooted;\n}", "target": 0}
{"code": "static inline int sem_lock(struct sem_array *sma, struct sembuf *sops,\n\t\t\t      int nsops)\n{\n\tint locknum;\n again:\n\tif (nsops == 1 && !sma->complex_count) {\n\t\tstruct sem *sem = sma->sem_base + sops->sem_num;\n\t\tspin_lock(&sem->lock);\n\t\tif (unlikely(sma->complex_count)) {\n\t\t\tspin_unlock(&sem->lock);\n\t\t\tgoto lock_array;\n\t\t}\n\t\tif (unlikely(spin_is_locked(&sma->sem_perm.lock))) {\n\t\t\tspin_unlock(&sem->lock);\n\t\t\tspin_unlock_wait(&sma->sem_perm.lock);\n\t\t\tgoto again;\n\t\t}\n\t\tlocknum = sops->sem_num;\n\t} else {\n\t\tint i;\n lock_array:\n\t\tspin_lock(&sma->sem_perm.lock);\n\t\tfor (i = 0; i < sma->sem_nsems; i++) {\n\t\t\tstruct sem *sem = sma->sem_base + i;\n\t\t\tspin_unlock_wait(&sem->lock);\n\t\t}\n\t\tlocknum = -1;\n\t}\n\treturn locknum;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    auto x = ctx->input(0);\n    auto i = ctx->input(1);\n    auto v = ctx->input(2);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(i.shape()),\n                errors::InvalidArgument(\"i must be a vector. \",\n                                        i.shape().DebugString()));\n    OP_REQUIRES(ctx, x.dims() == v.dims(),\n                errors::InvalidArgument(\n                    \"x and v shape doesn't match (ranks differ): \",\n                    x.shape().DebugString(), \" vs. \", v.shape().DebugString()));\n    for (int i = 1; i < x.dims(); ++i) {\n      OP_REQUIRES(\n          ctx, x.dim_size(i) == v.dim_size(i),\n          errors::InvalidArgument(\"x and v shape doesn't match at index \", i,\n                                  \" : \", x.shape().DebugString(), \" vs. \",\n                                  v.shape().DebugString()));\n    }\n    OP_REQUIRES(ctx, i.dim_size(0) == v.dim_size(0),\n                errors::InvalidArgument(\n                    \"i and x shape doesn't match at index 0: \",\n                    i.shape().DebugString(), \" vs. \", v.shape().DebugString()));\n    Tensor y = x;  \n    if (x.NumElements() > 0 || v.NumElements() > 0) {\n      OP_REQUIRES_OK(ctx, DoCompute(ctx, i, v, &y));\n    }\n    ctx->set_output(0, y);\n  }", "target": 1}
{"code": "ssize_t tcp_splice_read(struct socket *sock, loff_t *ppos,\n\t\t\tstruct pipe_inode_info *pipe, size_t len,\n\t\t\tunsigned int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct tcp_splice_state tss = {\n\t\t.pipe = pipe,\n\t\t.len = len,\n\t\t.flags = flags,\n\t};\n\tlong timeo;\n\tssize_t spliced;\n\tint ret;\n\tsock_rps_record_flow(sk);\n\tif (unlikely(*ppos))\n\t\treturn -ESPIPE;\n\tret = spliced = 0;\n\tlock_sock(sk);\n\ttimeo = sock_rcvtimeo(sk, sock->file->f_flags & O_NONBLOCK);\n\twhile (tss.len) {\n\t\tret = __tcp_splice_read(sk, &tss);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\telse if (!ret) {\n\t\t\tif (spliced)\n\t\t\t\tbreak;\n\t\t\tif (sock_flag(sk, SOCK_DONE))\n\t\t\t\tbreak;\n\t\t\tif (sk->sk_err) {\n\t\t\t\tret = sock_error(sk);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\t\tbreak;\n\t\t\tif (sk->sk_state == TCP_CLOSE) {\n\t\t\t\tif (!sock_flag(sk, SOCK_DONE))\n\t\t\t\t\tret = -ENOTCONN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!timeo) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!skb_queue_empty(&sk->sk_receive_queue))\n\t\t\t\tbreak;\n\t\t\tsk_wait_data(sk, &timeo, NULL);\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tret = sock_intr_errno(timeo);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\ttss.len -= ret;\n\t\tspliced += ret;\n\t\tif (!timeo)\n\t\t\tbreak;\n\t\trelease_sock(sk);\n\t\tlock_sock(sk);\n\t\tif (sk->sk_err || sk->sk_state == TCP_CLOSE ||\n\t\t    (sk->sk_shutdown & RCV_SHUTDOWN) ||\n\t\t    signal_pending(current))\n\t\t\tbreak;\n\t}\n\trelease_sock(sk);\n\tif (spliced)\n\t\treturn spliced;\n\treturn ret;\n}", "target": 0}
{"code": "mysql_list_processes(MYSQL *mysql)\n{\n  MYSQL_DATA *fields;\n  uint field_count;\n  uchar *pos;\n  DBUG_ENTER(\"mysql_list_processes\");\n  LINT_INIT(fields);\n  if (simple_command(mysql,COM_PROCESS_INFO,0,0,0))\n    DBUG_RETURN(0);\n  free_old_query(mysql);\n  pos=(uchar*) mysql->net.read_pos;\n  field_count=(uint) net_field_length(&pos);\n  if (!(fields = (*mysql->methods->read_rows)(mysql,(MYSQL_FIELD*) 0,\n\t\t\t\t\t      protocol_41(mysql) ? 7 : 5)))\n    DBUG_RETURN(NULL);\n  if (!(mysql->fields=unpack_fields(mysql, fields,&mysql->field_alloc,field_count,0,\n\t\t\t\t    mysql->server_capabilities)))\n    DBUG_RETURN(0);\n  mysql->status=MYSQL_STATUS_GET_RESULT;\n  mysql->field_count=field_count;\n  DBUG_RETURN(mysql_store_result(mysql));\n}", "target": 0}
{"code": "int main(int argc, char *argv[]) {\n  try {\n    for (int i = 1; i < argc; i++) {\n      string arg = argv[i];\n      if (arg == \"--extract\" && i < argc - 1) {\n        TarFileReader reader(argv[++i]);\n        while (reader.hasMore())\n          cout << reader.extract() << endl;\n      } else THROWS(\"Invalid arg '\" << arg << \"'\");\n    }\n    return 0;\n  } catch (const Exception &e) {cerr << e.getMessage();}\n  return 1;\n}", "target": 0}
{"code": "TEST_F(ZNCTest, Modpython) {\n    if (QProcessEnvironment::systemEnvironment().value(\n            \"DISABLED_ZNC_PERL_PYTHON_TEST\") == \"1\") {\n        return;\n    }\n    auto znc = Run();\n    znc->CanLeak();\n    auto ircd = ConnectIRCd();\n    auto client = LoginClient();\n    client.Write(\"znc loadmod modpython\");\n    client.Write(\"znc loadmod pyeval\");\n    client.Write(\"PRIVMSG *pyeval :2+2\");\n    client.ReadUntil(\":*pyeval!znc@znc.in PRIVMSG nick :4\");\n    client.Write(\"PRIVMSG *pyeval :module.GetUser().GetUserName()\");\n    client.ReadUntil(\"nick :'user'\");\n    ircd.Write(\":server 001 nick :Hello\");\n    ircd.Write(\":n!u@h PRIVMSG nick :Hi\\xF0, github issue #1229\");\n    client.ReadUntil(\"Hi\\xEF\\xBF\\xBD, github issue\");\n    client.Write(\"PRIVMSG *controlpanel :Set ClientEncoding $me Western\");\n    client.Write(\"JOIN #a\\342\");\n    client.ReadUntil(\n        \":*controlpanel!znc@znc.in PRIVMSG nick :ClientEncoding = UTF-8\");\n    ircd.ReadUntil(\"JOIN #a\\xEF\\xBF\\xBD\");\n}", "target": 0}
{"code": "asmlinkage long compat_sys_ptrace(compat_long_t request, compat_long_t pid,\n\t\t\t\t  compat_long_t addr, compat_long_t data)\n{\n\tstruct task_struct *child;\n\tlong ret;\n\tif (request == PTRACE_TRACEME) {\n\t\tret = ptrace_traceme();\n\t\tgoto out;\n\t}\n\tchild = ptrace_get_task_struct(pid);\n\tif (IS_ERR(child)) {\n\t\tret = PTR_ERR(child);\n\t\tgoto out;\n\t}\n\tif (request == PTRACE_ATTACH || request == PTRACE_SEIZE) {\n\t\tret = ptrace_attach(child, request, addr, data);\n\t\tif (!ret)\n\t\t\tarch_ptrace_attach(child);\n\t\tgoto out_put_task_struct;\n\t}\n\tret = ptrace_check_attach(child, request == PTRACE_KILL ||\n\t\t\t\t  request == PTRACE_INTERRUPT);\n\tif (!ret)\n\t\tret = compat_arch_ptrace(child, request, addr, data);\n out_put_task_struct:\n\tput_task_struct(child);\n out:\n\treturn ret;\n}", "target": 1}
{"code": "char *Elf_(r_bin_elf_get_rpath)(ELFOBJ *bin) {\n\tchar *ret = NULL;\n\tint j;\n\tif (!bin || !bin->phdr || !bin->dyn_buf || !bin->strtab) {\n\t\treturn NULL;\n\t}\n\tfor (j = 0; j< bin->dyn_entries; j++) {\n\t\tif (bin->dyn_buf[j].d_tag == DT_RPATH || bin->dyn_buf[j].d_tag == DT_RUNPATH) {\n\t\t\tif (!(ret = calloc (1, ELF_STRING_LENGTH))) {\n\t\t\t\tperror (\"malloc (rpath)\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (bin->dyn_buf[j].d_un.d_val > bin->strtab_size) {\n\t\t\t\tfree (ret);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tstrncpy (ret, bin->strtab + bin->dyn_buf[j].d_un.d_val, ELF_STRING_LENGTH);\n\t\t\tret[ELF_STRING_LENGTH - 1] = '\\0';\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "int ovl_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tint err;\n\tstruct dentry *upperdentry;\n\terr = ovl_want_write(dentry);\n\tif (err)\n\t\tgoto out;\n\tupperdentry = ovl_dentry_upper(dentry);\n\tif (upperdentry) {\n\t\tmutex_lock(&upperdentry->d_inode->i_mutex);\n\t\terr = notify_change(upperdentry, attr, NULL);\n\t\tmutex_unlock(&upperdentry->d_inode->i_mutex);\n\t} else {\n\t\terr = ovl_copy_up_last(dentry, attr, false);\n\t}\n\tovl_drop_write(dentry);\nout:\n\treturn err;\n}", "target": 1}
{"code": "static int update_server_from_aliases(request_rec *r)\n{\n    const char *host = r->hostname;\n    apr_port_t port;\n    server_rec *s;\n    server_rec *virthost_s;\n    server_rec *last_s;\n    name_chain *src;\n    virthost_s = NULL;\n    last_s = NULL;\n    port = r->connection->local_addr->port;\n    for (src = r->connection->vhost_lookup_data; src; src = src->next) {\n        server_addr_rec *sar;\n        sar = src->sar;\n        if (sar->host_port != 0 && port != sar->host_port) {\n            continue;\n        }\n        s = src->server;\n        if (s != last_s) {\n            if (matches_aliases(s, host)) {\n                goto found;\n            }\n        }\n        if (!strcasecmp(host, sar->virthost)) {\n            if (virthost_s == NULL) {\n                virthost_s = s;\n            }\n        }\n        last_s = s;\n    }\n    if (virthost_s) {\n        s = virthost_s;\n        goto found;\n    }\n    if (!r->connection->vhost_lookup_data) { \n        if (matches_aliases(r->server, host)) {\n            s = r->server;\n            goto found;\n        }\n    }\n    return HTTP_BAD_REQUEST;\nfound:\n    r->server = s;\n    return HTTP_OK;\n}", "target": 0}
{"code": "void sas_unregister_dev(struct asd_sas_port *port, struct domain_device *dev)\n{\n\tif (!test_bit(SAS_DEV_DESTROY, &dev->state) &&\n\t    !list_empty(&dev->disco_list_node)) {\n\t\tlist_del_init(&dev->disco_list_node);\n\t\tsas_rphy_free(dev->rphy);\n\t\tsas_unregister_common_dev(port, dev);\n\t\treturn;\n\t}\n\tif (!test_and_set_bit(SAS_DEV_DESTROY, &dev->state)) {\n\t\tsas_rphy_unlink(dev->rphy);\n\t\tlist_move_tail(&dev->disco_list_node, &port->destroy_list);\n\t\tsas_discover_event(dev->port, DISCE_DESTRUCT);\n\t}\n}", "target": 1}
{"code": "  Status BuildFeatureReaders(const OpInputList& ragged_values_list,\n                             const OpInputList& ragged_splits_list,\n                             const OpInputList& sparse_indices_list,\n                             const OpInputList& sparse_values_list,\n                             const OpInputList& dense_list, int64 batch_size,\n                             FeatureReaders* features) {\n    features->reserve(input_order_.size());\n    int next_ragged = 0;\n    int next_sparse = 0;\n    int next_dense = 0;\n    for (char c : input_order_) {\n      if (c == 'R') {\n        if (next_ragged >= ragged_values_list.size())\n          return errors::InvalidArgument(\n              \"input_order \\\"\", input_order_,\n              \"\\\" specifies reading a ragged tensor value at index \",\n              next_ragged, \" from a list of \", ragged_values_list.size(),\n              \" values.\");\n        if (next_ragged >= ragged_splits_list.size())\n          return errors::InvalidArgument(\n              \"input_order \\\"\", input_order_,\n              \"\\\" specifies reading a ragged tensor split at index \",\n              next_ragged, \" from a list of \", ragged_splits_list.size(),\n              \" splits.\");\n        TF_RETURN_IF_ERROR(BuildRaggedFeatureReader(\n            ragged_values_list[next_ragged], ragged_splits_list[next_ragged],\n            features));\n        next_ragged++;\n      } else if (c == 'S') {\n        if (next_sparse >= sparse_values_list.size())\n          return errors::InvalidArgument(\n              \"input_order \\\"\", input_order_,\n              \"\\\" specifies reading a sparse tensor value at index \",\n              next_sparse, \" from a list of \", sparse_values_list.size(),\n              \" values.\");\n        if (next_sparse >= sparse_indices_list.size())\n          return errors::InvalidArgument(\n              \"input_order \\\"\", input_order_,\n              \"\\\" specifies reading a sparse tensor index at index \",\n              next_sparse, \" from a list of \", sparse_indices_list.size(),\n              \" indices.\");\n        TF_RETURN_IF_ERROR(BuildSparseFeatureReader(\n            sparse_indices_list[next_sparse], sparse_values_list[next_sparse],\n            batch_size, features));\n        next_sparse++;\n      } else if (c == 'D') {\n        if (next_dense >= dense_list.size())\n          return errors::InvalidArgument(\n              \"input_order \\\"\", input_order_,\n              \"\\\" specifies reading a dense tensor at index \", next_dense,\n              \" from a list of \", dense_list.size(), \" tensors.\");\n        TF_RETURN_IF_ERROR(\n            BuildDenseFeatureReader(dense_list[next_dense++], features));\n      } else {\n        return errors::InvalidArgument(\"Unexpected input_order value.\");\n      }\n    }\n    return Status::OK();\n  }", "target": 0}
{"code": "static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)\n{\n\tif (timr->it.mmtimer.clock == TIMER_OFF) {\n\t\tcur_setting->it_interval.tv_nsec = 0;\n\t\tcur_setting->it_interval.tv_sec = 0;\n\t\tcur_setting->it_value.tv_nsec = 0;\n\t\tcur_setting->it_value.tv_sec =0;\n\t\treturn;\n\t}\n\tns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);\n\tns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);\n\treturn;\n}", "target": 1}
{"code": "utf16le_mbc_to_code(const UChar* p, const UChar* end)\n{\n  OnigCodePoint code;\n  UChar c0 = *p;\n  UChar c1 = *(p+1);\n  if (UTF16_IS_SURROGATE_FIRST(c1)) {\n    if (end - p < 4) return 0;\n    code = ((((c1 - 0xd8) << 2) + ((c0  & 0xc0) >> 6) + 1) << 16)\n         + ((((c0 & 0x3f) << 2) + (p[3] - 0xdc)) << 8)\n         + p[2];\n  }\n  else {\n    code = c1 * 256 + p[0];\n  }\n  return code;\n}", "target": 0}
{"code": "PROCESS_THREAD(snmp_process, ev, data)\n{\n  PROCESS_BEGIN();\n  snmp_udp_conn = udp_new(NULL, 0, NULL);\n  udp_bind(snmp_udp_conn, SNMP_SERVER_PORT);\n  LOG_DBG(\"Listening on port %u\\n\", uip_ntohs(snmp_udp_conn->lport));\n  while(1) {\n    PROCESS_YIELD();\n    if(ev == tcpip_event) {\n      if(uip_newdata()) {\n        snmp_process_data();\n      }\n    }\n  } \n  PROCESS_END();\n}", "target": 1}
{"code": "static int nft_del_setelem(struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t   const struct nlattr *attr)\n{\n\tstruct nlattr *nla[NFTA_SET_ELEM_MAX + 1];\n\tstruct nft_data_desc desc;\n\tstruct nft_set_elem elem;\n\tstruct nft_trans *trans;\n\tint err;\n\terr = nla_parse_nested(nla, NFTA_SET_ELEM_MAX, attr,\n\t\t\t       nft_set_elem_policy);\n\tif (err < 0)\n\t\tgoto err1;\n\terr = -EINVAL;\n\tif (nla[NFTA_SET_ELEM_KEY] == NULL)\n\t\tgoto err1;\n\terr = nft_data_init(ctx, &elem.key, &desc, nla[NFTA_SET_ELEM_KEY]);\n\tif (err < 0)\n\t\tgoto err1;\n\terr = -EINVAL;\n\tif (desc.type != NFT_DATA_VALUE || desc.len != set->klen)\n\t\tgoto err2;\n\terr = set->ops->get(set, &elem);\n\tif (err < 0)\n\t\tgoto err2;\n\ttrans = nft_trans_elem_alloc(ctx, NFT_MSG_DELSETELEM, set);\n\tif (trans == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto err2;\n\t}\n\tnft_trans_elem(trans) = elem;\n\tlist_add_tail(&trans->list, &ctx->net->nft.commit_list);\n\treturn 0;\nerr2:\n\tnft_data_uninit(&elem.key, desc.type);\nerr1:\n\treturn err;\n}", "target": 0}
{"code": "int __cil_build_ast_last_child_helper(struct cil_tree_node *parse_current, void *extra_args)\n{\n\tstruct cil_args_build *args = extra_args;\n\tstruct cil_tree_node *ast = args->ast;\n\tif (ast->flavor == CIL_ROOT) {\n\t\treturn SEPOL_OK;\n\t}\n\targs->ast = ast->parent;\n\tif (ast->flavor == CIL_TUNABLEIF) {\n\t\targs->tunif = NULL;\n\t}\n\tif (ast->flavor == CIL_IN) {\n\t\targs->in = NULL;\n\t}\n\tif (ast->flavor == CIL_MACRO) {\n\t\targs->macro = NULL;\n\t}\n\tif (ast->flavor == CIL_OPTIONAL) {\n\t\tstruct cil_tree_node *n = ast->parent;\n\t\targs->optional = NULL;\n\t\twhile (n && n->flavor != CIL_ROOT) {\n\t\t\tif (n->flavor == CIL_OPTIONAL) {\n\t\t\t\targs->optional = n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn = n->parent;\n\t\t}\n\t}\n\tif (ast->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = NULL;\n\t}\n\tcil_tree_children_destroy(parse_current->parent);\n\treturn SEPOL_OK;\n}", "target": 0}
{"code": "HeaderEntry* HeaderMapImpl::get(const LowerCaseString& key) {\n  for (HeaderEntryImpl& header : headers_) {\n    if (header.key() == key.get().c_str()) {\n      cached_byte_size_.reset();\n      return &header;\n    }\n  }\n  return nullptr;\n}", "target": 0}
{"code": "lyd_new_output(struct lyd_node *parent, const struct lys_module *module, const char *name)\n{\n    const struct lys_node *snode = NULL, *siblings;\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n    siblings = lyd_new_find_schema(parent, module, 1);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_CONTAINER | LYS_LIST | LYS_NOTIF\n                         | LYS_RPC | LYS_ACTION, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n    return _lyd_new(parent, snode, 0);\n}", "target": 1}
{"code": "GF_Err dinf_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = gf_isom_box_array_read(s, bs, dinf_AddBox);\n\tif (e) {\n\t\treturn e;\n\t}\n\tif (!((GF_DataInformationBox *)s)->dref) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing dref box in dinf\\n\"));\n\t\t((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "  static const char* ConvertScalar(PyObject* v, Eigen::half* out) {\n    Safe_PyObjectPtr as_float = make_safe(PyNumber_Float(v));\n    double v_double = PyFloat_AS_DOUBLE(as_float.get());\n    *out = Eigen::half(v_double);\n    return nullptr;\n  }", "target": 1}
{"code": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\tif (!arp_checkentry(&e->arp))\n\t\treturn -EINVAL;\n\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1}
{"code": "  QUInt16() {}", "target": 1}
{"code": "update_notification_destroy(struct update_notification *file)\n{\n\tdoc_data_cleanup(&file->snapshot);\n\tglobal_data_cleanup(&file->global_data);\n\tdeltas_head_destroy(file->deltas_list);\n\tfree(file->uri);\n\tfree(file);\n}", "target": 1}
{"code": "static int midi_setup_noteon(struct _mdi *mdi, uint8_t channel,\n                             uint8_t note, uint8_t velocity) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,channel, note);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_note_on;\n    mdi->events[mdi->event_count].event_data.channel = channel;\n    mdi->events[mdi->event_count].event_data.data.value = (note << 8) | velocity;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    if (mdi->channel[channel].isdrum)\n        _WM_load_patch(mdi, ((mdi->channel[channel].bank << 8) | (note | 0x80)));\n    return (0);\n}", "target": 0}
{"code": "static BOOL recurse_check_bit(compiler_common *common, sljit_sw bit_index)\n{\nuint8_t *byte;\nuint8_t mask;\nSLJIT_ASSERT((bit_index & (sizeof(sljit_sw) - 1)) == 0);\nbit_index >>= SLJIT_WORD_SHIFT;\nmask = 1 << (bit_index & 0x7);\nbyte = common->recurse_bitset + (bit_index >> 3);\nif (*byte & mask)\n  return FALSE;\n*byte |= mask;\nreturn TRUE;\n}", "target": 0}
{"code": "chdlc_if_print(netdissect_options *ndo, const struct pcap_pkthdr *h, register const u_char *p)\n{\n\tregister u_int length = h->len;\n\tregister u_int caplen = h->caplen;\n\tif (caplen < CHDLC_HDRLEN) {\n\t\tND_PRINT((ndo, \"[|chdlc]\"));\n\t\treturn (caplen);\n\t}\n        return (chdlc_print(ndo, p,length));\n}", "target": 1}
{"code": "DownloadResult downloadFile(string url, string expectedETag)\n{\n    DownloadResult res;\n    Curl curl;\n    if (curl.fetch(url, expectedETag)) {\n        res.cached = false;\n        res.data = curl.data;\n    } else\n        res.cached = true;\n    res.etag = curl.etag;\n    return res;\n}", "target": 1}
{"code": "int key_reject_and_link(struct key *key,\n\t\t\tunsigned timeout,\n\t\t\tunsigned error,\n\t\t\tstruct key *keyring,\n\t\t\tstruct key *authkey)\n{\n\tstruct assoc_array_edit *edit;\n\tstruct timespec now;\n\tint ret, awaken, link_ret = 0;\n\tkey_check(key);\n\tkey_check(keyring);\n\tawaken = 0;\n\tret = -EBUSY;\n\tif (keyring) {\n\t\tif (keyring->restrict_link)\n\t\t\treturn -EPERM;\n\t\tlink_ret = __key_link_begin(keyring, &key->index_key, &edit);\n\t}\n\tmutex_lock(&key_construction_mutex);\n\tif (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n\t\tatomic_inc(&key->user->nikeys);\n\t\tkey->reject_error = -error;\n\t\tsmp_wmb();\n\t\tset_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\t\tset_bit(KEY_FLAG_INSTANTIATED, &key->flags);\n\t\tnow = current_kernel_time();\n\t\tkey->expiry = now.tv_sec + timeout;\n\t\tkey_schedule_gc(key->expiry + key_gc_delay);\n\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\tawaken = 1;\n\t\tret = 0;\n\t\tif (keyring && link_ret == 0)\n\t\t\t__key_link(key, &edit);\n\t\tif (authkey)\n\t\t\tkey_revoke(authkey);\n\t}\n\tmutex_unlock(&key_construction_mutex);\n\tif (keyring)\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\tif (awaken)\n\t\twake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT);\n\treturn ret == 0 ? link_ret : ret;\n}", "target": 1}
{"code": "static char *get_header(FILE *fp)\n{\n    long start;\n    char *header;\n    header = calloc(1, 1024);\n    start = ftell(fp);\n    fseek(fp, 0, SEEK_SET);\n    SAFE_E(fread(header, 1, 1023, fp), 1023, \"Failed to load PDF header.\\n\");\n    fseek(fp, start, SEEK_SET);\n    return header;\n}", "target": 1}
{"code": "static int wanxl_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tconst size_t size = sizeof(sync_serial_settings);\n\tsync_serial_settings line;\n\tport_t *port = dev_to_port(dev);\n\tif (cmd != SIOCWANDEV)\n\t\treturn hdlc_ioctl(dev, ifr, cmd);\n\tswitch (ifr->ifr_settings.type) {\n\tcase IF_GET_IFACE:\n\t\tifr->ifr_settings.type = IF_IFACE_SYNC_SERIAL;\n\t\tif (ifr->ifr_settings.size < size) {\n\t\t\tifr->ifr_settings.size = size; \n\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tmemset(&line, 0, sizeof(line));\n\t\tline.clock_type = get_status(port)->clocking;\n\t\tline.clock_rate = 0;\n\t\tline.loopback = 0;\n\t\tif (copy_to_user(ifr->ifr_settings.ifs_ifsu.sync, &line, size))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase IF_IFACE_SYNC_SERIAL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (dev->flags & IFF_UP)\n\t\t\treturn -EBUSY;\n\t\tif (copy_from_user(&line, ifr->ifr_settings.ifs_ifsu.sync,\n\t\t\t\t   size))\n\t\t\treturn -EFAULT;\n\t\tif (line.clock_type != CLOCK_EXT &&\n\t\t    line.clock_type != CLOCK_TXFROMRX)\n\t\t\treturn -EINVAL; \n\t\tif (line.loopback != 0)\n\t\t\treturn -EINVAL;\n\t\tget_status(port)->clocking = line.clock_type;\n\t\treturn 0;\n\tdefault:\n\t\treturn hdlc_ioctl(dev, ifr, cmd);\n        }\n}", "target": 0}
{"code": "match_expr(struct search_node_list *head, struct eventlog *evlog, bool last_match)\n{\n    struct search_node *sn;\n    bool res = false, matched = last_match;\n    int rc;\n    debug_decl(match_expr, SUDO_DEBUG_UTIL);\n    STAILQ_FOREACH(sn, head, entries) {\n\tswitch (sn->type) {\n\tcase ST_EXPR:\n\t    res = match_expr(&sn->u.expr, evlog, matched);\n\t    break;\n\tcase ST_CWD:\n\t    if (evlog->cwd != NULL)\n\t\tres = strcmp(sn->u.cwd, evlog->cwd) == 0;\n\t    break;\n\tcase ST_HOST:\n\t    if (evlog->submithost != NULL)\n\t\tres = strcmp(sn->u.host, evlog->submithost) == 0;\n\t    break;\n\tcase ST_TTY:\n\t    if (evlog->ttyname != NULL)\n\t\tres = strcmp(sn->u.tty, evlog->ttyname) == 0;\n\t    break;\n\tcase ST_RUNASGROUP:\n\t    if (evlog->rungroup != NULL)\n\t\tres = strcmp(sn->u.runas_group, evlog->rungroup) == 0;\n\t    break;\n\tcase ST_RUNASUSER:\n\t    if (evlog->runuser != NULL)\n\t\tres = strcmp(sn->u.runas_user, evlog->runuser) == 0;\n\t    break;\n\tcase ST_USER:\n\t    if (evlog->submituser != NULL)\n\t\tres = strcmp(sn->u.user, evlog->submituser) == 0;\n\t    break;\n\tcase ST_PATTERN:\n\t    rc = regexec(&sn->u.cmdre, evlog->command, 0, NULL, 0);\n\t    if (rc && rc != REG_NOMATCH) {\n\t\tchar buf[BUFSIZ];\n\t\tregerror(rc, &sn->u.cmdre, buf, sizeof(buf));\n\t\tsudo_fatalx(\"%s\", buf);\n\t    }\n\t    res = rc == REG_NOMATCH ? 0 : 1;\n\t    break;\n\tcase ST_FROMDATE:\n\t    res = sudo_timespeccmp(&evlog->submit_time, &sn->u.tstamp, >=);\n\t    break;\n\tcase ST_TODATE:\n\t    res = sudo_timespeccmp(&evlog->submit_time, &sn->u.tstamp, <=);\n\t    break;\n\tdefault:\n\t    sudo_fatalx(U_(\"unknown search type %d\"), sn->type);\n\t}\n\tif (sn->negated)\n\t    res = !res;\n\tmatched = sn->or ? (res || last_match) : (res && last_match);\n\tlast_match = matched;\n    }\n    debug_return_bool(matched);\n}", "target": 1}
{"code": "void my_output_message( j_common_ptr ) {} ", "target": 1}
{"code": "int TfLiteIntArrayGetSizeInBytes(int size) {\n  static TfLiteIntArray dummy;\n  int computed_size = sizeof(dummy) + sizeof(dummy.data[0]) * size;\n#if defined(_MSC_VER)\n  computed_size -= sizeof(dummy.data[0]);\n#endif\n  return computed_size;\n}", "target": 1}
{"code": "static void gsm_cleanup_mux(struct gsm_mux *gsm, bool disc)\n{\n\tint i;\n\tstruct gsm_dlci *dlci = gsm->dlci[0];\n\tstruct gsm_msg *txq, *ntxq;\n\tgsm->dead = true;\n\tmutex_lock(&gsm->mutex);\n\tif (dlci) {\n\t\tif (disc && dlci->state != DLCI_CLOSED) {\n\t\t\tgsm_dlci_begin_close(dlci);\n\t\t\twait_event(gsm->event, dlci->state == DLCI_CLOSED);\n\t\t}\n\t\tdlci->dead = true;\n\t}\n\tdel_timer_sync(&gsm->kick_timer);\n\tdel_timer_sync(&gsm->t2_timer);\n\tdel_timer_sync(&gsm->ka_timer);\n\tflush_work(&gsm->tx_work);\n\tif (gsm->has_devices) {\n\t\tgsm_unregister_devices(gsm_tty_driver, gsm->num);\n\t\tgsm->has_devices = false;\n\t}\n\tfor (i = NUM_DLCI - 1; i >= 0; i--)\n\t\tif (gsm->dlci[i]) {\n\t\t\tgsm_dlci_release(gsm->dlci[i]);\n\t\t\tgsm->dlci[i] = NULL;\n\t\t}\n\tmutex_unlock(&gsm->mutex);\n\ttty_ldisc_flush(gsm->tty);\n\tlist_for_each_entry_safe(txq, ntxq, &gsm->tx_ctrl_list, list)\n\t\tkfree(txq);\n\tINIT_LIST_HEAD(&gsm->tx_ctrl_list);\n\tlist_for_each_entry_safe(txq, ntxq, &gsm->tx_data_list, list)\n\t\tkfree(txq);\n\tINIT_LIST_HEAD(&gsm->tx_data_list);\n}", "target": 1}
{"code": "int yr_re_match(\n    RE* re,\n    const char* target)\n{\n  return yr_re_exec(\n      re->code,\n      (uint8_t*) target,\n      strlen(target),\n      0,\n      re->flags | RE_FLAGS_SCAN,\n      NULL,\n      NULL);\n}", "target": 0}
{"code": "test_function (char * (*my_asnprintf) (char *, size_t *, const char *, ...))\n{\n  char buf[8];\n  int size;\n  for (size = 0; size <= 8; size++)\n    {\n      size_t length = size;\n      char *result = my_asnprintf (NULL, &length, \"%d\", 12345);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"12345\") == 0);\n      ASSERT (length == 5);\n      free (result);\n    }\n  for (size = 0; size <= 8; size++)\n    {\n      size_t length;\n      char *result;\n      memcpy (buf, \"DEADBEEF\", 8);\n      length = size;\n      result = my_asnprintf (buf, &length, \"%d\", 12345);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"12345\") == 0);\n      ASSERT (length == 5);\n      if (size < 6)\n        ASSERT (result != buf);\n      ASSERT (memcmp (buf + size, &\"DEADBEEF\"[size], 8 - size) == 0);\n      if (result != buf)\n        free (result);\n    }\n}", "target": 1}
{"code": "u16 inverse_translate(struct vc_data *conp, int glyph, int use_unicode)\n{\n\tstruct uni_pagedir *p;\n\tint m;\n\tif (glyph < 0 || glyph >= MAX_GLYPH)\n\t\treturn 0;\n\telse {\n\t\tp = *conp->vc_uni_pagedir_loc;\n\t\tif (!p)\n\t\t\treturn glyph;\n\t\telse if (use_unicode) {\n\t\t\tif (!p->inverse_trans_unicode)\n\t\t\t\treturn glyph;\n\t\t\telse\n\t\t\t\treturn p->inverse_trans_unicode[glyph];\n\t\t\t} else {\n\t\t\tm = inv_translate[conp->vc_num];\n\t\t\tif (!p->inverse_translations[m])\n\t\t\t\treturn glyph;\n\t\t\telse\n\t\t\t\treturn p->inverse_translations[m][glyph];\n\t\t\t}\n\t}\n}", "target": 0}
{"code": "void init_xml_schema()\n{\n  VALUE nokogiri = rb_define_module(\"Nokogiri\");\n  VALUE xml = rb_define_module_under(nokogiri, \"XML\");\n  VALUE klass = rb_define_class_under(xml, \"Schema\", rb_cObject);\n  cNokogiriXmlSchema = klass;\n  rb_define_singleton_method(klass, \"read_memory\", read_memory, 1);\n  rb_define_singleton_method(klass, \"from_document\", from_document, 1);\n  rb_define_private_method(klass, \"validate_document\", validate_document, 1);\n  rb_define_private_method(klass, \"validate_file\",     validate_file, 1);\n}", "target": 1}
{"code": "NOEXPORT void print_cipher(CLI *c) { \n    SSL_CIPHER *cipher;\n#ifndef OPENSSL_NO_COMP\n    const COMP_METHOD *compression, *expansion;\n#endif\n    if(c->opt->log_level<LOG_INFO) \n        return;\n    s_log(LOG_INFO, \"TLS %s: %s\",\n        c->opt->option.client ? \"connected\" : \"accepted\",\n        SSL_session_reused(c->ssl) && !c->flag.psk ?\n            \"previous session reused\" : \"new session negotiated\");\n    cipher=(SSL_CIPHER *)SSL_get_current_cipher(c->ssl);\n    s_log(LOG_INFO, \"%s ciphersuite: %s (%d-bit encryption)\",\n        SSL_get_version(c->ssl), SSL_CIPHER_get_name(cipher),\n        SSL_CIPHER_get_bits(cipher, NULL));\n#if OPENSSL_VERSION_NUMBER >= 0x10101000L\n    print_tmp_key(c->ssl);\n#endif\n#ifndef OPENSSL_NO_COMP\n    compression=SSL_get_current_compression(c->ssl);\n    expansion=SSL_get_current_expansion(c->ssl);\n    s_log(compression||expansion ? LOG_INFO : LOG_DEBUG,\n        \"Compression: %s, expansion: %s\",\n        compression ? SSL_COMP_get_name(compression) : \"null\",\n        expansion ? SSL_COMP_get_name(expansion) : \"null\");\n#endif\n}", "target": 0}
{"code": "static int proc_pid_schedstat(struct task_struct *task, char *buffer)\n{\n\treturn sprintf(buffer, \"%llu %llu %lu\\n\",\n\t\t\ttask->sched_info.cpu_time,\n\t\t\ttask->sched_info.run_delay,\n\t\t\ttask->sched_info.pcount);\n}", "target": 0}
{"code": "static int ntlm_read_ntlm_v2_client_challenge(wStream* s, NTLMv2_CLIENT_CHALLENGE* challenge)\n{\n\tsize_t size;\n\tif (Stream_GetRemainingLength(s) < 28)\n\t\treturn -1;\n\tStream_Read_UINT8(s, challenge->RespType);\n\tStream_Read_UINT8(s, challenge->HiRespType);\n\tStream_Read_UINT16(s, challenge->Reserved1);\n\tStream_Read_UINT32(s, challenge->Reserved2);\n\tStream_Read(s, challenge->Timestamp, 8);\n\tStream_Read(s, challenge->ClientChallenge, 8);\n\tStream_Read_UINT32(s, challenge->Reserved3);\n\tsize = Stream_Length(s) - Stream_GetPosition(s);\n\tif (size > UINT32_MAX)\n\t\treturn -1;\n\tchallenge->cbAvPairs = size;\n\tchallenge->AvPairs = (NTLM_AV_PAIR*)malloc(challenge->cbAvPairs);\n\tif (!challenge->AvPairs)\n\t\treturn -1;\n\tStream_Read(s, challenge->AvPairs, size);\n\treturn 1;\n}", "target": 0}
{"code": "static struct sk_buff *tcp_sacktag_walk(struct sk_buff *skb, struct sock *sk,\n\t\t\t\t\tstruct tcp_sack_block *next_dup,\n\t\t\t\t\tstruct tcp_sacktag_state *state,\n\t\t\t\t\tu32 start_seq, u32 end_seq,\n\t\t\t\t\tint dup_sack_in)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *tmp;\n\ttcp_for_write_queue_from(skb, sk) {\n\t\tint in_sack = 0;\n\t\tint dup_sack = dup_sack_in;\n\t\tif (skb == tcp_send_head(sk))\n\t\t\tbreak;\n\t\tif (!before(TCP_SKB_CB(skb)->seq, end_seq))\n\t\t\tbreak;\n\t\tif ((next_dup != NULL) &&\n\t\t    before(TCP_SKB_CB(skb)->seq, next_dup->end_seq)) {\n\t\t\tin_sack = tcp_match_skb_to_sack(sk, skb,\n\t\t\t\t\t\t\tnext_dup->start_seq,\n\t\t\t\t\t\t\tnext_dup->end_seq);\n\t\t\tif (in_sack > 0)\n\t\t\t\tdup_sack = 1;\n\t\t}\n\t\tif (in_sack <= 0) {\n\t\t\ttmp = tcp_shift_skb_data(sk, skb, state,\n\t\t\t\t\t\t start_seq, end_seq, dup_sack);\n\t\t\tif (tmp != NULL) {\n\t\t\t\tif (tmp != skb) {\n\t\t\t\t\tskb = tmp;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tin_sack = 0;\n\t\t\t} else {\n\t\t\t\tin_sack = tcp_match_skb_to_sack(sk, skb,\n\t\t\t\t\t\t\t\tstart_seq,\n\t\t\t\t\t\t\t\tend_seq);\n\t\t\t}\n\t\t}\n\t\tif (unlikely(in_sack < 0))\n\t\t\tbreak;\n\t\tif (in_sack) {\n\t\t\tTCP_SKB_CB(skb)->sacked = tcp_sacktag_one(skb, sk,\n\t\t\t\t\t\t\t\t  state,\n\t\t\t\t\t\t\t\t  dup_sack,\n\t\t\t\t\t\t\t\t  tcp_skb_pcount(skb));\n\t\t\tif (!before(TCP_SKB_CB(skb)->seq,\n\t\t\t\t    tcp_highest_sack_seq(tp)))\n\t\t\t\ttcp_advance_highest_sack(sk, skb);\n\t\t}\n\t\tstate->fack_count += tcp_skb_pcount(skb);\n\t}\n\treturn skb;\n}", "target": 0}
{"code": "nfs4_state_set_mode_locked(struct nfs4_state *state, mode_t mode)\n{\n\tif (state->state == mode)\n\t\treturn;\n\tif ((mode & FMODE_WRITE) != (state->state & FMODE_WRITE)) {\n\t\tif (mode & FMODE_WRITE)\n\t\t\tlist_move(&state->open_states, &state->owner->so_states);\n\t\telse\n\t\t\tlist_move_tail(&state->open_states, &state->owner->so_states);\n\t}\n\tstate->state = mode;\n}", "target": 1}
{"code": "static gboolean match_hostname(const char *cert_hostname, const char *hostname)\n{\n\tconst char *hostname_left;\n\tif (!strcasecmp(cert_hostname, hostname)) { \n\t\treturn TRUE;\n\t} else if (cert_hostname[0] == '*' && cert_hostname[1] == '.' && cert_hostname[2] != 0) { \n\t\thostname_left = strchr(hostname, '.');\n\t\tif (hostname_left != NULL && ! strcasecmp(hostname_left + 1, cert_hostname + 2)) {\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}", "target": 0}
{"code": "auth_iochannel_watch (GIOChannel   *source,\n                      GIOCondition  condition,\n                      IceConn       ice_conn)\n{\n        GsmIceConnectionWatch *data;\n        gboolean               keep_going;\n        data = ice_conn->context;\n        switch (IceProcessMessages (ice_conn, NULL, NULL)) {\n        case IceProcessMessagesSuccess:\n                keep_going = TRUE;\n                break;\n        case IceProcessMessagesIOError:\n                g_debug (\"GsmXsmpServer: IceProcessMessages returned IceProcessMessagesIOError\");\n                free_ice_connection_watch (data);\n                disconnect_ice_connection (ice_conn);\n                keep_going = FALSE;\n                break;\n        case IceProcessMessagesConnectionClosed:\n                g_debug (\"GsmXsmpServer: IceProcessMessages returned IceProcessMessagesConnectionClosed\");\n                free_ice_connection_watch (data);\n                keep_going = FALSE;\n                break;\n        default:\n                g_assert_not_reached ();\n        }\n        return keep_going;\n}", "target": 0}
{"code": "static int bmpr_read_rle(struct iwbmprcontext *rctx)\n{\n\tint retval = 0;\n\tif(!(rctx->compression==IWBMP_BI_RLE8 && rctx->bitcount==8) &&\n\t\t!(rctx->compression==IWBMP_BI_RLE4 && rctx->bitcount==4))\n\t{\n\t\tiw_set_error(rctx->ctx,\"Compression type incompatible with image type\");\n\t\tgoto done;\n\t}\n\tif(rctx->topdown) {\n\t\tiw_set_error(rctx->ctx,\"Compression not allowed with top-down images\");\n\t\tgoto done;\n\t}\n\trctx->img->imgtype = IW_IMGTYPE_RGBA;\n\trctx->img->bit_depth = 8;\n\trctx->img->bpr = iw_calc_bytesperrow(rctx->width,32);\n\trctx->img->pixels = (iw_byte*)iw_malloc_large(rctx->ctx,rctx->img->bpr,rctx->img->height);\n\tif(!rctx->img->pixels) goto done;\n\tif(!bmpr_read_rle_internal(rctx)) goto done;\n\tif(!bmpr_has_transparency(rctx->img)) {\n\t\tbmpr_strip_alpha(rctx->img);\n\t}\n\tretval = 1;\ndone:\n\treturn retval;\n}", "target": 0}
{"code": "static void _php_pgsql_notice_handler(void *resource_id, const char *message)\n{\n\tphp_pgsql_notice *notice;\n\tTSRMLS_FETCH();\n\tif (! PGG(ignore_notices)) {\n\t\tnotice = (php_pgsql_notice *)emalloc(sizeof(php_pgsql_notice));\n\t\tnotice->message = _php_pgsql_trim_message(message, (int *)&notice->len);\n\t\tif (PGG(log_notices)) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_NOTICE, \"%s\", notice->message);\n\t\t}\n\t\tzend_hash_index_update(&PGG(notices), (ulong)resource_id, (void **)&notice, sizeof(php_pgsql_notice *), NULL);\n\t}\n}", "target": 0}
{"code": "int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)\n{\n\tgfn_t gfn, end_gfn;\n\tpfn_t pfn;\n\tint r = 0;\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\tint flags;\n\tif (!domain)\n\t\treturn 0;\n\tgfn     = slot->base_gfn;\n\tend_gfn = gfn + slot->npages;\n\tflags = IOMMU_READ;\n\tif (!(slot->flags & KVM_MEM_READONLY))\n\t\tflags |= IOMMU_WRITE;\n\tif (!kvm->arch.iommu_noncoherent)\n\t\tflags |= IOMMU_CACHE;\n\twhile (gfn < end_gfn) {\n\t\tunsigned long page_size;\n\t\tif (iommu_iova_to_phys(domain, gfn_to_gpa(gfn))) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\t\tpage_size = kvm_host_page_size(kvm, gfn);\n\t\twhile ((gfn + (page_size >> PAGE_SHIFT)) > end_gfn)\n\t\t\tpage_size >>= 1;\n\t\twhile ((gfn << PAGE_SHIFT) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\t\twhile (__gfn_to_hva_memslot(slot, gfn) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\t\tpfn = kvm_pin_pages(slot, gfn, page_size >> PAGE_SHIFT);\n\t\tif (is_error_noslot_pfn(pfn)) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\t\tr = iommu_map(domain, gfn_to_gpa(gfn), pfn_to_hpa(pfn),\n\t\t\t      page_size, flags);\n\t\tif (r) {\n\t\t\tprintk(KERN_ERR \"kvm_iommu_map_address:\"\n\t\t\t       \"iommu failed to map pfn=%llx\\n\", pfn);\n\t\t\tkvm_unpin_pages(kvm, pfn, page_size >> PAGE_SHIFT);\n\t\t\tgoto unmap_pages;\n\t\t}\n\t\tgfn += page_size >> PAGE_SHIFT;\n\t}\n\treturn 0;\nunmap_pages:\n\tkvm_iommu_put_pages(kvm, slot->base_gfn, gfn - slot->base_gfn);\n\treturn r;\n}", "target": 0}
{"code": "static int rtnl_bridge_setlink(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct ifinfomsg *ifm;\n\tstruct net_device *dev;\n\tstruct nlattr *br_spec, *attr = NULL;\n\tint rem, err = -EOPNOTSUPP;\n\tu16 flags = 0;\n\tbool have_flags = false;\n\tif (nlmsg_len(nlh) < sizeof(*ifm))\n\t\treturn -EINVAL;\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifi_family != AF_BRIDGE)\n\t\treturn -EPFNOSUPPORT;\n\tdev = __dev_get_by_index(net, ifm->ifi_index);\n\tif (!dev) {\n\t\tpr_info(\"PF_BRIDGE: RTM_SETLINK with unknown ifindex\\n\");\n\t\treturn -ENODEV;\n\t}\n\tbr_spec = nlmsg_find_attr(nlh, sizeof(struct ifinfomsg), IFLA_AF_SPEC);\n\tif (br_spec) {\n\t\tnla_for_each_nested(attr, br_spec, rem) {\n\t\t\tif (nla_type(attr) == IFLA_BRIDGE_FLAGS) {\n\t\t\t\tif (nla_len(attr) < sizeof(flags))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\thave_flags = true;\n\t\t\t\tflags = nla_get_u16(attr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!flags || (flags & BRIDGE_FLAGS_MASTER)) {\n\t\tstruct net_device *br_dev = netdev_master_upper_dev_get(dev);\n\t\tif (!br_dev || !br_dev->netdev_ops->ndo_bridge_setlink) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\terr = br_dev->netdev_ops->ndo_bridge_setlink(dev, nlh, flags);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tflags &= ~BRIDGE_FLAGS_MASTER;\n\t}\n\tif ((flags & BRIDGE_FLAGS_SELF)) {\n\t\tif (!dev->netdev_ops->ndo_bridge_setlink)\n\t\t\terr = -EOPNOTSUPP;\n\t\telse\n\t\t\terr = dev->netdev_ops->ndo_bridge_setlink(dev, nlh,\n\t\t\t\t\t\t\t\t  flags);\n\t\tif (!err) {\n\t\t\tflags &= ~BRIDGE_FLAGS_SELF;\n\t\t\terr = rtnl_bridge_notify(dev);\n\t\t}\n\t}\n\tif (have_flags)\n\t\tmemcpy(nla_data(attr), &flags, sizeof(flags));\nout:\n\treturn err;\n}", "target": 0}
{"code": "int btrfs_init_dev_stats(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_root *dev_root = fs_info->dev_root;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tint ret = 0;\n\tstruct btrfs_device *device;\n\tstruct btrfs_path *path = NULL;\n\tint i;\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlist_for_each_entry(device, &fs_devices->devices, dev_list) {\n\t\tint item_size;\n\t\tstruct btrfs_dev_stats_item *ptr;\n\t\tkey.objectid = BTRFS_DEV_STATS_OBJECTID;\n\t\tkey.type = BTRFS_PERSISTENT_ITEM_KEY;\n\t\tkey.offset = device->devid;\n\t\tret = btrfs_search_slot(NULL, dev_root, &key, path, 0, 0);\n\t\tif (ret) {\n\t\t\t__btrfs_reset_dev_stats(device);\n\t\t\tdevice->dev_stats_valid = 1;\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\t\tslot = path->slots[0];\n\t\teb = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\t\titem_size = btrfs_item_size_nr(eb, slot);\n\t\tptr = btrfs_item_ptr(eb, slot,\n\t\t\t\t     struct btrfs_dev_stats_item);\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++) {\n\t\t\tif (item_size >= (1 + i) * sizeof(__le64))\n\t\t\t\tbtrfs_dev_stat_set(device, i,\n\t\t\t\t\tbtrfs_dev_stats_value(eb, ptr, i));\n\t\t\telse\n\t\t\t\tbtrfs_dev_stat_reset(device, i);\n\t\t}\n\t\tdevice->dev_stats_valid = 1;\n\t\tbtrfs_dev_stat_print_on_load(device);\n\t\tbtrfs_release_path(path);\n\t}\n\tmutex_unlock(&fs_devices->device_list_mutex);\nout:\n\tbtrfs_free_path(path);\n\treturn ret < 0 ? ret : 0;\n}", "target": 0}
{"code": "static int ptrace_attach(struct task_struct *task, long request,\n\t\t\t unsigned long addr,\n\t\t\t unsigned long flags)\n{\n\tbool seize = (request == PTRACE_SEIZE);\n\tint retval;\n\tretval = -EIO;\n\tif (seize) {\n\t\tif (addr != 0)\n\t\t\tgoto out;\n\t\tif (flags & ~(unsigned long)PTRACE_O_MASK)\n\t\t\tgoto out;\n\t\tretval = check_ptrace_options(flags);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tflags = PT_PTRACED | PT_SEIZED | (flags << PT_OPT_FLAG_SHIFT);\n\t} else {\n\t\tflags = PT_PTRACED;\n\t}\n\taudit_ptrace(task);\n\tretval = -EPERM;\n\tif (unlikely(task->flags & PF_KTHREAD))\n\t\tgoto out;\n\tif (same_thread_group(task, current))\n\t\tgoto out;\n\tretval = -ERESTARTNOINTR;\n\tif (mutex_lock_interruptible(&task->signal->cred_guard_mutex))\n\t\tgoto out;\n\ttask_lock(task);\n\tretval = __ptrace_may_access(task, PTRACE_MODE_ATTACH_REALCREDS);\n\ttask_unlock(task);\n\tif (retval)\n\t\tgoto unlock_creds;\n\twrite_lock_irq(&tasklist_lock);\n\tretval = -EPERM;\n\tif (unlikely(task->exit_state))\n\t\tgoto unlock_tasklist;\n\tif (task->ptrace)\n\t\tgoto unlock_tasklist;\n\ttask->ptrace = flags;\n\tptrace_link(task, current);\n\tif (!seize)\n\t\tsend_sig_info(SIGSTOP, SEND_SIG_PRIV, task);\n\tspin_lock(&task->sighand->siglock);\n\tif (task_is_stopped(task) &&\n\t    task_set_jobctl_pending(task, JOBCTL_TRAP_STOP | JOBCTL_TRAPPING))\n\t\tsignal_wake_up_state(task, __TASK_STOPPED);\n\tspin_unlock(&task->sighand->siglock);\n\tretval = 0;\nunlock_tasklist:\n\twrite_unlock_irq(&tasklist_lock);\nunlock_creds:\n\tmutex_unlock(&task->signal->cred_guard_mutex);\nout:\n\tif (!retval) {\n\t\twait_on_bit(&task->jobctl, JOBCTL_TRAPPING_BIT, TASK_KILLABLE);\n\t\tproc_ptrace_connector(task, PTRACE_ATTACH);\n\t}\n\treturn retval;\n}", "target": 0}
{"code": "static int attach_recursive_mnt(struct mount *source_mnt,\n\t\t\tstruct mount *dest_mnt,\n\t\t\tstruct mountpoint *dest_mp,\n\t\t\tstruct path *parent_path)\n{\n\tHLIST_HEAD(tree_list);\n\tstruct mnt_namespace *ns = dest_mnt->mnt_ns;\n\tstruct mount *child, *p;\n\tstruct hlist_node *n;\n\tint err;\n\tif (!parent_path) {\n\t\terr = count_mounts(ns, source_mnt);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\tif (IS_MNT_SHARED(dest_mnt)) {\n\t\terr = invent_group_ids(source_mnt, true);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = propagate_mnt(dest_mnt, dest_mp, source_mnt, &tree_list);\n\t\tlock_mount_hash();\n\t\tif (err)\n\t\t\tgoto out_cleanup_ids;\n\t\tfor (p = source_mnt; p; p = next_mnt(p, source_mnt))\n\t\t\tset_mnt_shared(p);\n\t} else {\n\t\tlock_mount_hash();\n\t}\n\tif (parent_path) {\n\t\tdetach_mnt(source_mnt, parent_path);\n\t\tattach_mnt(source_mnt, dest_mnt, dest_mp);\n\t\ttouch_mnt_namespace(source_mnt->mnt_ns);\n\t} else {\n\t\tmnt_set_mountpoint(dest_mnt, dest_mp, source_mnt);\n\t\tcommit_tree(source_mnt, NULL);\n\t}\n\thlist_for_each_entry_safe(child, n, &tree_list, mnt_hash) {\n\t\tstruct mount *q;\n\t\thlist_del_init(&child->mnt_hash);\n\t\tq = __lookup_mnt_last(&child->mnt_parent->mnt,\n\t\t\t\t      child->mnt_mountpoint);\n\t\tcommit_tree(child, q);\n\t}\n\tunlock_mount_hash();\n\treturn 0;\n out_cleanup_ids:\n\twhile (!hlist_empty(&tree_list)) {\n\t\tchild = hlist_entry(tree_list.first, struct mount, mnt_hash);\n\t\tchild->mnt_parent->mnt_ns->pending_mounts = 0;\n\t\tumount_tree(child, UMOUNT_SYNC);\n\t}\n\tunlock_mount_hash();\n\tcleanup_group_ids(source_mnt, NULL);\n out:\n\tns->pending_mounts = 0;\n\treturn err;\n}", "target": 0}
{"code": "read_and_discard_scanlines(j_decompress_ptr cinfo, JDIMENSION num_lines)\n{\n  JDIMENSION n;\n  my_master_ptr master = (my_master_ptr)cinfo->master;\n  void (*color_convert) (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                         JDIMENSION input_row, JSAMPARRAY output_buf,\n                         int num_rows) = NULL;\n  void (*color_quantize) (j_decompress_ptr cinfo, JSAMPARRAY input_buf,\n                          JSAMPARRAY output_buf, int num_rows) = NULL;\n  void (*post_process_data) (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                             JDIMENSION *in_row_group_ctr,\n                             JDIMENSION in_row_groups_avail,\n                             JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,\n                             JDIMENSION out_rows_avail) = NULL;\n  if (cinfo->cconvert && cinfo->cconvert->color_convert) {\n    color_convert = cinfo->cconvert->color_convert;\n    cinfo->cconvert->color_convert = noop_convert;\n  }\n  if (cinfo->cquantize && cinfo->cquantize->color_quantize) {\n    color_quantize = cinfo->cquantize->color_quantize;\n    cinfo->cquantize->color_quantize = noop_quantize;\n  }\n  if (master->using_merged_upsample && cinfo->post &&\n      cinfo->post->post_process_data) {\n    post_process_data = cinfo->post->post_process_data;\n    cinfo->post->post_process_data = noop_post_process;\n  }\n  for (n = 0; n < num_lines; n++)\n    jpeg_read_scanlines(cinfo, NULL, 1);\n  if (color_convert)\n    cinfo->cconvert->color_convert = color_convert;\n  if (color_quantize)\n    cinfo->cquantize->color_quantize = color_quantize;\n  if (post_process_data)\n    cinfo->post->post_process_data = post_process_data;\n}", "target": 0}
{"code": "libarchive_read_next_header (EvArchive *archive,\n\t\t\t     GError   **error)\n{\n\twhile (1) {\n\t\tint r;\n\t\tr = archive_read_next_header (archive->libar, &archive->libar_entry);\n\t\tif (r != ARCHIVE_OK) {\n\t\t\tif (r != ARCHIVE_EOF)\n\t\t\t\tg_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,\n\t\t\t\t\t     \"Error reading archive: %s\", archive_error_string (archive->libar));\n\t\t\treturn FALSE;\n\t\t}\n\t\tif (archive_entry_filetype (archive->libar_entry) != AE_IFREG) {\n\t\t\tg_debug (\"Skipping '%s' as it's not a regular file\",\n\t\t\t\t archive_entry_pathname (archive->libar_entry));\n\t\t\tcontinue;\n\t\t}\n\t\tg_debug (\"At header for file '%s'\", archive_entry_pathname (archive->libar_entry));\n\t\tbreak;\n\t}\n\treturn TRUE;\n}", "target": 0}
{"code": "static void vhost_net_ubuf_put_wait_and_free(struct vhost_net_ubuf_ref *ubufs)\n{\n\tvhost_net_ubuf_put_and_wait(ubufs);\n\tkfree(ubufs);\n}", "target": 0}
{"code": "bgp_auth_parse (struct peer *peer, u_char *pnt, size_t length)\n{\n  bgp_notify_send (peer, \n\t\t   BGP_NOTIFY_OPEN_ERR, \n\t\t   BGP_NOTIFY_OPEN_AUTH_FAILURE); \n  return -1;\n}", "target": 1}
{"code": "static int dns_resolver_cmp(const struct key *key,\n\t\t\t    const struct key_match_data *match_data)\n{\n\tint slen, dlen, ret = 0;\n\tconst char *src = key->description, *dsp = match_data->raw_data;\n\tkenter(\"%s,%s\", src, dsp);\n\tif (!src || !dsp)\n\t\tgoto no_match;\n\tif (strcasecmp(src, dsp) == 0)\n\t\tgoto matched;\n\tslen = strlen(src);\n\tdlen = strlen(dsp);\n\tif (slen <= 0 || dlen <= 0)\n\t\tgoto no_match;\n\tif (src[slen - 1] == '.')\n\t\tslen--;\n\tif (dsp[dlen - 1] == '.')\n\t\tdlen--;\n\tif (slen != dlen || strncasecmp(src, dsp, slen) != 0)\n\t\tgoto no_match;\nmatched:\n\tret = 1;\nno_match:\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}", "target": 0}
{"code": "FileInformation ImageReadJPEGInfo( String const& filename ) {\n   JpegInput jpeg( filename );\n   FileInformation info = GetJPEGInfo( jpeg );\n   return info;\n}", "target": 1}
{"code": "static int f2fs_set_data_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = mapping->host;\n\ttrace_f2fs_set_page_dirty(page, DATA);\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\tif (f2fs_is_atomic_file(inode) && !f2fs_is_commit_atomic_write(inode)) {\n\t\tif (!IS_ATOMIC_WRITTEN_PAGE(page)) {\n\t\t\tf2fs_register_inmem_page(inode, page);\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (!PageDirty(page)) {\n\t\t__set_page_dirty_nobuffers(page);\n\t\tf2fs_update_dirty_page(inode, page);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "__perf_event_ctx_lock_double(struct perf_event *group_leader,\n\t\t\t     struct perf_event_context *ctx)\n{\n\tstruct perf_event_context *gctx;\nagain:\n\trcu_read_lock();\n\tgctx = READ_ONCE(group_leader->ctx);\n\tif (!atomic_inc_not_zero(&gctx->refcount)) {\n\t\trcu_read_unlock();\n\t\tgoto again;\n\t}\n\trcu_read_unlock();\n\tmutex_lock_double(&gctx->mutex, &ctx->mutex);\n\tif (group_leader->ctx != gctx) {\n\t\tmutex_unlock(&ctx->mutex);\n\t\tmutex_unlock(&gctx->mutex);\n\t\tput_ctx(gctx);\n\t\tgoto again;\n\t}\n\treturn gctx;\n}", "target": 0}
{"code": "static void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EACCES;\n\tpath_put(&nd->path);\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\terror = PROC_I(inode)->op.proc_get_link(inode, &nd->path);\n\tnd->last_type = LAST_BIND;\nout:\n\treturn ERR_PTR(error);\n}", "target": 1}
{"code": "static __init int seqgen_init(void)\n{\n\trekey_seq_generator(NULL);\n\treturn 0;\n}", "target": 1}
{"code": "PHP_FUNCTION( msgfmt_format_message )\n{\n\tzval       *args;\n\tUChar      *spattern = NULL;\n\tint         spattern_len = 0;\n\tchar       *pattern = NULL;\n\tint         pattern_len = 0;\n\tconst char *slocale = NULL;\n\tint         slocale_len = 0;\n\tMessageFormatter_object mf = {0};\n\tMessageFormatter_object *mfo = &mf;\n\tif( zend_parse_method_parameters( ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"ssa\",\n\t\t  &slocale, &slocale_len, &pattern, &pattern_len, &args ) == FAILURE )\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t\"msgfmt_format_message: unable to parse input params\", 0 TSRMLS_CC );\n\t\tRETURN_FALSE;\n\t}\n\tINTL_CHECK_LOCALE_LEN(slocale_len);\n\tmsgformat_data_init(&mfo->mf_data TSRMLS_CC);\n\tif(pattern && pattern_len) {\n\t\tintl_convert_utf8_to_utf16(&spattern, &spattern_len, pattern, pattern_len, &INTL_DATA_ERROR_CODE(mfo));\n\t\tif( U_FAILURE(INTL_DATA_ERROR_CODE((mfo))) )\n\t\t{\n\t\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t\t\"msgfmt_format_message: error converting pattern to UTF-16\", 0 TSRMLS_CC );\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tspattern_len = 0;\n\t\tspattern = NULL;\n\t}\n\tif(slocale_len == 0) {\n\t\tslocale = intl_locale_get_default(TSRMLS_C);\n\t}\n#ifdef MSG_FORMAT_QUOTE_APOS\n\tif(msgformat_fix_quotes(&spattern, &spattern_len, &INTL_DATA_ERROR_CODE(mfo)) != SUCCESS) {\n\t\tintl_error_set( NULL, U_INVALID_FORMAT_ERROR,\n\t\t\t\"msgfmt_format_message: error converting pattern to quote-friendly format\", 0 TSRMLS_CC );\n\t\tRETURN_FALSE;\n\t}\n#endif\n\tMSG_FORMAT_OBJECT(mfo) = umsg_open(spattern, spattern_len, slocale, NULL, &INTL_DATA_ERROR_CODE(mfo));\n\tif(spattern && spattern_len) {\n\t\tefree(spattern);\n\t}\n\tINTL_METHOD_CHECK_STATUS(mfo, \"Creating message formatter failed\");\n\tmsgfmt_do_format(mfo, args, return_value TSRMLS_CC);\n\tmsgformat_data_free(&mfo->mf_data TSRMLS_CC);\n}", "target": 0}
{"code": "void context__cleanup(struct mosquitto *context, bool force_free)\n{\n\tstruct mosquitto__packet *packet;\n\tif(!context) return;\n\tif(force_free){\n\t\tcontext->clean_start = true;\n\t}\n#ifdef WITH_BRIDGE\n\tif(context->bridge){\n\t\tbridge__cleanup(context);\n\t}\n#endif\n\talias__free_all(context);\n\tmosquitto__free(context->auth_method);\n\tcontext->auth_method = NULL;\n\tmosquitto__free(context->username);\n\tcontext->username = NULL;\n\tmosquitto__free(context->password);\n\tcontext->password = NULL;\n\tnet__socket_close(context);\n\tif(force_free){\n\t\tsub__clean_session(context);\n\t}\n\tdb__messages_delete(context, force_free);\n\tmosquitto__free(context->address);\n\tcontext->address = NULL;\n\tcontext__send_will(context);\n\tif(context->id){\n\t\tcontext__remove_from_by_id(context);\n\t\tmosquitto__free(context->id);\n\t\tcontext->id = NULL;\n\t}\n\tpacket__cleanup(&(context->in_packet));\n\tif(context->current_out_packet){\n\t\tpacket__cleanup(context->current_out_packet);\n\t\tmosquitto__free(context->current_out_packet);\n\t\tcontext->current_out_packet = NULL;\n\t}\n\twhile(context->out_packet){\n\t\tpacket__cleanup(context->out_packet);\n\t\tpacket = context->out_packet;\n\t\tcontext->out_packet = context->out_packet->next;\n\t\tmosquitto__free(packet);\n\t}\n\tcontext->out_packet_count = 0;\n#if defined(WITH_BROKER) && defined(__GLIBC__) && defined(WITH_ADNS)\n\tif(context->adns){\n\t\tgai_cancel(context->adns);\n\t\tmosquitto__free((struct addrinfo *)context->adns->ar_request);\n\t\tmosquitto__free(context->adns);\n\t}\n#endif\n\tif(force_free){\n\t\tmosquitto__free(context);\n\t}\n}", "target": 1}
{"code": "void Huff_offsetReceive (node_t *node, int *ch, byte *fin, int *offset) {\n\tbloc = *offset;\n\twhile (node && node->symbol == INTERNAL_NODE) {\n\t\tif (get_bit(fin)) {\n\t\t\tnode = node->right;\n\t\t} else {\n\t\t\tnode = node->left;\n\t\t}\n\t}\n\tif (!node) {\n\t\t*ch = 0;\n\t\treturn;\n\t}\n\t*ch = node->symbol;\n\t*offset = bloc;\n}", "target": 1}
{"code": "static bool caller_may_see_dir(pid_t pid, const char *contrl, const char *cg)\n{\n\tbool answer = false;\n\tchar *c2, *task_cg;\n\tsize_t target_len, task_len;\n\tif (strcmp(cg, \"/\") == 0)\n\t\treturn true;\n\tc2 = get_pid_cgroup(pid, contrl);\n\tif (!c2)\n\t\treturn false;\n\ttask_cg = c2 + 1;\n\ttarget_len = strlen(cg);\n\ttask_len = strlen(task_cg);\n\tif (strcmp(cg, task_cg) == 0) {\n\t\tanswer = true;\n\t\tgoto out;\n\t}\n\tif (target_len < task_len) {\n\t\tif (strncmp(task_cg, cg, target_len) == 0 && task_cg[target_len] == '/')\n\t\t\tanswer = true;\n\t\tgoto out;\n\t}\n\tif (target_len > task_len) {\n\t\tif (strncmp(task_cg, cg, task_len) == 0 && cg[task_len] == '/')\n\t\t\tanswer = true;\n\t\tgoto out;\n\t}\nout:\n\tfree(c2);\n\treturn answer;\n}", "target": 0}
{"code": "libarchive_set_archive_type (EvArchive *archive,\n\t\t\t     EvArchiveType archive_type)\n{\n\tarchive->type = archive_type;\n\tarchive->libar = archive_read_new ();\n\tif (archive_type == EV_ARCHIVE_TYPE_ZIP)\n\t\tarchive_read_support_format_zip (archive->libar);\n\telse if (archive_type == EV_ARCHIVE_TYPE_7Z)\n\t\tarchive_read_support_format_7zip (archive->libar);\n\telse if (archive_type == EV_ARCHIVE_TYPE_TAR)\n\t\tarchive_read_support_format_tar (archive->libar);\n\telse if (archive_type == EV_ARCHIVE_TYPE_RAR) {\n\t\tarchive_read_support_format_rar (archive->libar);\n\t\tarchive_read_support_format_rar5 (archive->libar);\n\t} else\n\t\tg_assert_not_reached ();\n}", "target": 0}
{"code": "static void *etm_setup_aux(int event_cpu, void **pages,\n\t\t\t   int nr_pages, bool overwrite)\n{\n\tint cpu;\n\tcpumask_t *mask;\n\tstruct coresight_device *sink;\n\tstruct etm_event_data *event_data = NULL;\n\tevent_data = alloc_event_data(event_cpu);\n\tif (!event_data)\n\t\treturn NULL;\n\tsink = coresight_get_enabled_sink(true);\n\tif (!sink)\n\t\tgoto err;\n\tINIT_WORK(&event_data->work, free_event_data);\n\tmask = &event_data->mask;\n\tfor_each_cpu(cpu, mask) {\n\t\tstruct coresight_device *csdev;\n\t\tcsdev = per_cpu(csdev_src, cpu);\n\t\tif (!csdev)\n\t\t\tgoto err;\n\t\tevent_data->path[cpu] = coresight_build_path(csdev, sink);\n\t\tif (IS_ERR(event_data->path[cpu]))\n\t\t\tgoto err;\n\t}\n\tif (!sink_ops(sink)->alloc_buffer)\n\t\tgoto err;\n\tcpu = cpumask_first(mask);\n\tevent_data->snk_config =\n\t\t\tsink_ops(sink)->alloc_buffer(sink, cpu, pages,\n\t\t\t\t\t\t     nr_pages, overwrite);\n\tif (!event_data->snk_config)\n\t\tgoto err;\nout:\n\treturn event_data;\nerr:\n\tetm_free_aux(event_data);\n\tevent_data = NULL;\n\tgoto out;\n}", "target": 0}
{"code": "static inline void pipe_truncate(struct iov_iter *i)\n{\n\tstruct pipe_inode_info *pipe = i->pipe;\n\tif (pipe->nrbufs) {\n\t\tsize_t off = i->iov_offset;\n\t\tint idx = i->idx;\n\t\tint nrbufs = (idx - pipe->curbuf) & (pipe->buffers - 1);\n\t\tif (off) {\n\t\t\tpipe->bufs[idx].len = off - pipe->bufs[idx].offset;\n\t\t\tidx = next_idx(idx, pipe);\n\t\t\tnrbufs++;\n\t\t}\n\t\twhile (pipe->nrbufs > nrbufs) {\n\t\t\tpipe_buf_release(pipe, &pipe->bufs[idx]);\n\t\t\tidx = next_idx(idx, pipe);\n\t\t\tpipe->nrbufs--;\n\t\t}\n\t}\n}", "target": 0}
{"code": "parse_ranges(struct client *clt, char *str, size_t file_sz)\n{\n\tint\t\t\t i = 0;\n\tchar\t\t\t*p, *q;\n\tstruct range_data\t*r = &clt->clt_ranges;\n\tmemset(r, 0, sizeof(*r));\n\tif ((p = strchr(str, '=')) == NULL)\n\t\treturn (-1);\n\t*p++ = '\\0';\n\tif (strcmp(str, \"bytes\") != 0)\n\t\treturn (-1);\n\twhile ((q = strchr(p, ',')) != NULL) {\n\t\t*q++ = '\\0';\n\t\tif (parse_range_spec(p, file_sz, &r->range[i]) == 0)\n\t\t\tcontinue;\n\t\ti++;\n\t\tif (i == SERVER_MAX_RANGES)\n\t\t\treturn (-1);\n\t\tp = q;\n\t}\n\tif (parse_range_spec(p, file_sz, &r->range[i]) != 0)\n\t\ti++;\n\tr->range_total = file_sz;\n\tr->range_count = i;\n\treturn (i);\n}", "target": 0}
{"code": "static void test_show_object(struct object *object,\n\t\t\t     struct strbuf *path,\n\t\t\t     const char *last, void *data)\n{\n\tstruct bitmap_test_data *tdata = data;\n\tint bitmap_pos;\n\tbitmap_pos = bitmap_position(object->oid.hash);\n\tif (bitmap_pos < 0)\n\t\tdie(\"Object not in bitmap: %s\\n\", oid_to_hex(&object->oid));\n\tbitmap_set(tdata->base, bitmap_pos);\n\tdisplay_progress(tdata->prg, ++tdata->seen);\n}", "target": 1}
{"code": "static int getStrrtokenPos(char* str, int savedPos)\n{\n\tint result =-1;\n\tint i;\n\tfor(i=savedPos-1; i>=0; i--) {\n\t\tif(isIDSeparator(*(str+i)) ){\n\t\t\tif(i>=2 && isIDSeparator(*(str+i-2)) ){\n\t\t\t\tresult = i-2;\n\t\t\t} else {\n\t\t\t\tresult = i;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(result < 1){\n\t\tresult =-1;\n\t}\n\treturn result;\n}", "target": 1}
{"code": "int count_mounts(struct mnt_namespace *ns, struct mount *mnt)\n{\n\tunsigned int max = READ_ONCE(sysctl_mount_max);\n\tunsigned int mounts = 0, old, pending, sum;\n\tstruct mount *p;\n\tfor (p = mnt; p; p = next_mnt(p, mnt))\n\t\tmounts++;\n\told = ns->mounts;\n\tpending = ns->pending_mounts;\n\tsum = old + pending;\n\tif ((old > sum) ||\n\t    (pending > sum) ||\n\t    (max < sum) ||\n\t    (mounts > (max - sum)))\n\t\treturn -ENOSPC;\n\tns->pending_mounts = pending + mounts;\n\treturn 0;\n}", "target": 0}
{"code": "bool CModules::GetModPathInfo(CModInfo& ModInfo, const CString& sModule,\n                              const CString& sModPath, CString& sRetMsg) {\n    if (!ValidateModuleName(sModule, sRetMsg)) {\n        return false;\n    }\n    ModInfo.SetName(sModule);\n    ModInfo.SetPath(sModPath);\n    ModHandle p = OpenModule(sModule, sModPath, ModInfo, sRetMsg);\n    if (!p) return false;\n    dlclose(p);\n    return true;\n}", "target": 0}
{"code": "static struct dentry *proc_pid_instantiate(struct inode *dir,\n\t\t\t\t\t   struct dentry * dentry,\n\t\t\t\t\t   struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *error = ERR_PTR(-ENOENT);\n\tstruct inode *inode;\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\tinode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;\n\tinode->i_op = &proc_tgid_base_inode_operations;\n\tinode->i_fop = &proc_tgid_base_operations;\n\tinode->i_flags|=S_IMMUTABLE;\n\tinode->i_nlink = 5;\n#ifdef CONFIG_SECURITY\n\tinode->i_nlink += 1;\n#endif\n\tdentry->d_op = &pid_dentry_operations;\n\td_add(dentry, inode);\n\tif (pid_revalidate(dentry, NULL))\n\t\terror = NULL;\nout:\n\treturn error;\n}", "target": 0}
{"code": "static inline int copy_regset_from_user(struct task_struct *target,\n\t\t\t\t\tconst struct user_regset_view *view,\n\t\t\t\t\tunsigned int setno,\n\t\t\t\t\tunsigned int offset, unsigned int size,\n\t\t\t\t\tconst void __user *data)\n{\n\tconst struct user_regset *regset = &view->regsets[setno];\n\tif (!regset->set)\n\t\treturn -EOPNOTSUPP;\n\tif (!access_ok(VERIFY_READ, data, size))\n\t\treturn -EIO;\n\treturn regset->set(target, regset, offset, size, NULL, data);\n}", "target": 0}
{"code": "        int          GetS16BE (int nPos, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos + 1 >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            int nRes = m_sFile[nPos];\n            nRes = (nRes << 8) + m_sFile[ nPos + 1 ];\n            if ( nRes & 0x8000 )\n                nRes |= ~0xffff;\n            return nRes;\n        }", "target": 1}
{"code": "static int turn_dns_lookup(struct zapi_ice_server *turn,\n\t\t\t   struct stun_uri *uri)\n{\n\tstruct lookup_entry *lent;\n\tint err = 0;\n\tlent = mem_zalloc(sizeof(*lent), lent_destructor);\n\tif (!lent)\n\t\treturn ENOMEM;\n\tlent->turn = *turn;\n\tlent->ts = tmr_jiffies();\n\tlent->proto = uri->proto;\n\tlent->secure = uri->secure;\n\tlent->port = uri->port;\n\terr = str_dup(&lent->host, uri->host);\n\tif (err)\n\t\tgoto out;\n\tre_printf(\"dns_lookup for: %s:%d\\n\", lent->host, lent->port);\n\terr = dns_lookup(lent->host, dns_handler, lent);\n\tif (err) {\n\t\twarning(\"dns_lookup: failed: %m\\n\", err);\n\t\tgoto out;\n\t}\n out:\n\tif (err)\n\t\tmem_deref(lent);\n\treturn err;\n}", "target": 0}
{"code": "mark_op_resolved (FlatpakTransactionOperation *op,\n                  const char                  *commit,\n                  GFile                       *sideload_path,\n                  GBytes                      *metadata,\n                  GBytes                      *old_metadata)\n{\n  g_debug (\"marking op %s:%s resolved to %s\", kind_to_str (op->kind), flatpak_decomposed_get_ref (op->ref), commit ? commit : \"-\");\n  g_assert (op != NULL);\n  g_assert (commit != NULL);\n  op->resolved = TRUE;\n  if (op->resolved_commit != commit)\n    {\n      g_free (op->resolved_commit); \n      op->resolved_commit = g_strdup (commit);\n    }\n  if (sideload_path)\n    op->resolved_sideload_path = g_object_ref (sideload_path);\n  if (metadata)\n    {\n      g_autoptr(GKeyFile) metakey = g_key_file_new ();\n      if (g_key_file_load_from_bytes (metakey, metadata, G_KEY_FILE_NONE, NULL))\n        {\n          op->resolved_metadata = g_bytes_ref (metadata);\n          op->resolved_metakey = g_steal_pointer (&metakey);\n        }\n      else\n        g_message (\"Warning: Failed to parse metadata for %s\\n\", flatpak_decomposed_get_ref (op->ref));\n    }\n  if (old_metadata)\n    {\n      g_autoptr(GKeyFile) metakey = g_key_file_new ();\n      if (g_key_file_load_from_bytes (metakey, old_metadata, G_KEY_FILE_NONE, NULL))\n        {\n          op->resolved_old_metadata = g_bytes_ref (old_metadata);\n          op->resolved_old_metakey = g_steal_pointer (&metakey);\n        }\n      else\n        g_message (\"Warning: Failed to parse old metadata for %s\\n\", flatpak_decomposed_get_ref (op->ref));\n    }\n}", "target": 1}
{"code": "void __init proc_root_init(void)\n{\n\tstruct vfsmount *mnt;\n\tint err;\n\tproc_init_inodecache();\n\terr = register_filesystem(&proc_fs_type);\n\tif (err)\n\t\treturn;\n\tmnt = kern_mount_data(&proc_fs_type, &init_pid_ns);\n\tif (IS_ERR(mnt)) {\n\t\tunregister_filesystem(&proc_fs_type);\n\t\treturn;\n\t}\n\tinit_pid_ns.proc_mnt = mnt;\n\tproc_symlink(\"mounts\", NULL, \"self/mounts\");\n\tproc_net_init();\n#ifdef CONFIG_SYSVIPC\n\tproc_mkdir(\"sysvipc\", NULL);\n#endif\n\tproc_mkdir(\"fs\", NULL);\n\tproc_mkdir(\"driver\", NULL);\n\tproc_mkdir(\"fs/nfsd\", NULL); \n#if defined(CONFIG_SUN_OPENPROMFS) || defined(CONFIG_SUN_OPENPROMFS_MODULE)\n\tproc_mkdir(\"openprom\", NULL);\n#endif\n\tproc_tty_init();\n#ifdef CONFIG_PROC_DEVICETREE\n\tproc_device_tree_init();\n#endif\n\tproc_mkdir(\"bus\", NULL);\n\tproc_sys_init();\n}", "target": 1}
{"code": "char *path_name(struct strbuf *path, const char *name)\n{\n\tstruct strbuf ret = STRBUF_INIT;\n\tif (path)\n\t\tstrbuf_addbuf(&ret, path);\n\tstrbuf_addstr(&ret, name);\n\treturn strbuf_detach(&ret, NULL);\n}", "target": 1}
{"code": "void _modinit(module_t *m)\n{\n\tservice_named_bind_command(\"chanserv\", &cs_flags);\n\tadd_bool_conf_item(\"ANOPE_FLAGS_COMPAT\", &chansvs.me->conf_table, 0, &anope_flags_compat, true);\n\thook_add_event(\"nick_can_register\");\n\thook_add_nick_can_register(check_registration_keywords);\n\thook_add_event(\"user_can_register\");\n\thook_add_user_can_register(check_registration_keywords);\n}", "target": 0}
{"code": "static BOOL update_gdi_cache_bitmap_v2(rdpContext* context, CACHE_BITMAP_V2_ORDER* cacheBitmapV2)\n{\n\trdpBitmap* bitmap;\n\trdpBitmap* prevBitmap;\n\trdpCache* cache = context->cache;\n\trdpSettings* settings = context->settings;\n\tbitmap = Bitmap_Alloc(context);\n\tif (!bitmap)\n\t\treturn FALSE;\n\tif (!cacheBitmapV2->bitmapBpp)\n\t\tcacheBitmapV2->bitmapBpp = settings->ColorDepth;\n\tif ((settings->ColorDepth == 15) && (cacheBitmapV2->bitmapBpp == 16))\n\t\tcacheBitmapV2->bitmapBpp = settings->ColorDepth;\n\tBitmap_SetDimensions(bitmap, cacheBitmapV2->bitmapWidth, cacheBitmapV2->bitmapHeight);\n\tif (!bitmap->Decompress(context, bitmap, cacheBitmapV2->bitmapDataStream,\n\t                        cacheBitmapV2->bitmapWidth, cacheBitmapV2->bitmapHeight,\n\t                        cacheBitmapV2->bitmapBpp, cacheBitmapV2->bitmapLength,\n\t                        cacheBitmapV2->compressed, RDP_CODEC_ID_NONE))\n\t{\n\t\tBitmap_Free(context, bitmap);\n\t\treturn FALSE;\n\t}\n\tprevBitmap = bitmap_cache_get(cache->bitmap, cacheBitmapV2->cacheId, cacheBitmapV2->cacheIndex);\n\tif (!bitmap->New(context, bitmap))\n\t{\n\t\tBitmap_Free(context, bitmap);\n\t\treturn FALSE;\n\t}\n\tBitmap_Free(context, prevBitmap);\n\treturn bitmap_cache_put(cache->bitmap, cacheBitmapV2->cacheId, cacheBitmapV2->cacheIndex,\n\t                        bitmap);\n}", "target": 0}
{"code": "static void *createArrayObject(const redisReadTask *task, size_t elements) {\n    redisReply *r, *parent;\n    r = createReplyObject(task->type);\n    if (r == NULL)\n        return NULL;\n    if (elements > 0) {\n        if (SIZE_MAX / sizeof(redisReply*) < elements) return NULL;  \n        r->element = hi_calloc(elements,sizeof(redisReply*));\n        if (r->element == NULL) {\n            freeReplyObject(r);\n            return NULL;\n        }\n    }\n    r->elements = elements;\n    if (task->parent) {\n        parent = task->parent->obj;\n        assert(parent->type == REDIS_REPLY_ARRAY ||\n               parent->type == REDIS_REPLY_MAP ||\n               parent->type == REDIS_REPLY_SET ||\n               parent->type == REDIS_REPLY_PUSH);\n        parent->element[task->idx] = r;\n    }\n    return r;\n}", "target": 0}
{"code": "static int __init adpt_init(void)\n{\n\tint\t\terror;\n\tadpt_hba\t*pHba, *next;\n\tprintk(\"Loading Adaptec I2O RAID: Version \" DPT_I2O_VERSION \"\\n\");\n\terror = adpt_detect(&driver_template);\n\tif (error < 0)\n\t\treturn error;\n\tif (hba_chain == NULL)\n\t\treturn -ENODEV;\n\tfor (pHba = hba_chain; pHba; pHba = pHba->next) {\n\t\terror = scsi_add_host(pHba->host, &pHba->pDev->dev);\n\t\tif (error)\n\t\t\tgoto fail;\n\t\tscsi_scan_host(pHba->host);\n\t}\n\treturn 0;\nfail:\n\tfor (pHba = hba_chain; pHba; pHba = next) {\n\t\tnext = pHba->next;\n\t\tscsi_remove_host(pHba->host);\n\t}\n\treturn error;\n}", "target": 1}
{"code": "int nfc_enable_se(struct nfc_dev *dev, u32 se_idx)\n{\n\tstruct nfc_se *se;\n\tint rc;\n\tpr_debug(\"%s se index %d\\n\", dev_name(&dev->dev), se_idx);\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->dev_up) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->polling) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (!dev->ops->enable_se || !dev->ops->disable_se) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto error;\n\t}\n\tse = nfc_find_se(dev, se_idx);\n\tif (!se) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\tif (se->state == NFC_SE_ENABLED) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\trc = dev->ops->enable_se(dev, se_idx);\n\tif (rc >= 0)\n\t\tse->state = NFC_SE_ENABLED;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "static MagickBooleanType ReadPSDChannelPixels(Image *image,\n  const size_t channels,const size_t row,const ssize_t type,\n  const unsigned char *pixels,ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n  register const unsigned char\n    *p;\n  register Quantum\n    *q;\n  register ssize_t\n    x;\n  size_t\n    packet_size;\n  unsigned short\n    nibble;\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (Quantum *) NULL)\n    return MagickFalse;\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      {\n        p=PushShortPixel(MSBEndian,p,&nibble);\n        pixel=ScaleShortToQuantum(nibble);\n      }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channels,type,packet_size,pixel,q,exception);\n        q+=GetPixelChannels(image);\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n        number_bits=image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit = 0; bit < number_bits; bit++)\n        {\n          SetPSDPixel(image,channels,type,packet_size,(((unsigned char) pixel)\n            & (0x01 << (7-bit))) != 0 ? 0 : 255,q,exception);\n          q+=GetPixelChannels(image);\n          x++;\n        }\n        if (x != image->columns)\n          x--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}", "target": 0}
{"code": "static struct timespec fio_timer_calc_due(size_t interval) {\n  struct timespec now = fio_last_tick();\n  if (interval > 1000) {\n    now.tv_sec += interval / 1000;\n    interval -= interval / 1000;\n  }\n  now.tv_nsec += (interval * 1000000UL);\n  if (now.tv_nsec > 1000000000L) {\n    now.tv_nsec -= 1000000000L;\n    now.tv_sec += 1;\n  }\n  return now;\n}", "target": 1}
{"code": "void ServerSecurityFeature::collectOptions(std::shared_ptr<ProgramOptions> options) {\n  options->addOption(\"--server.harden\",\n                     \"lock down REST APIs that reveal version information or server \"\n                     \"internals for non-admin users\",\n                     new BooleanParameter(&_hardenedRestApi))\n                     .setIntroducedIn(30500);\n  options->addOption(\"--foxx.api\", \"enables Foxx management REST APIs\",\n                     new BooleanParameter(&_enableFoxxApi),\n                     arangodb::options::makeFlags(\n                     arangodb::options::Flags::DefaultNoComponents,\n                     arangodb::options::Flags::OnCoordinator,\n                     arangodb::options::Flags::OnSingle))\n                     .setIntroducedIn(30500);\n  options->addOption(\"--foxx.store\", \"enables Foxx store in web interface\",\n                     new BooleanParameter(&_enableFoxxStore),\n                     arangodb::options::makeFlags(\n                     arangodb::options::Flags::DefaultNoComponents,\n                     arangodb::options::Flags::OnCoordinator,\n                     arangodb::options::Flags::OnSingle))\n                     .setIntroducedIn(30500);\n}", "target": 1}
{"code": "check_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 0}
{"code": "void hashTypeTryConversion(robj *o, robj **argv, int start, int end) {\n    int i;\n    if (o->encoding != OBJ_ENCODING_ZIPLIST) return;\n    for (i = start; i <= end; i++) {\n        if (sdsEncodedObject(argv[i]) &&\n            sdslen(argv[i]->ptr) > server.hash_max_ziplist_value)\n        {\n            hashTypeConvert(o, OBJ_ENCODING_HT);\n            break;\n        }\n    }\n}", "target": 1}
{"code": "hb_set_subtract (hb_set_t       *set,\n\t\t const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->subtract (*other);\n}", "target": 1}
{"code": "GetIoStats(Mgr::IoActionData& stats)\n{\n    int i;\n    stats.http_reads = IOStats.Http.reads;\n    for (i = 0; i < IoStats::histSize; ++i) {\n        stats.http_read_hist[i] = IOStats.Http.read_hist[i];\n    }\n    stats.ftp_reads = IOStats.Ftp.reads;\n    for (i = 0; i < IoStats::histSize; ++i) {\n        stats.ftp_read_hist[i] = IOStats.Ftp.read_hist[i];\n    }\n    stats.gopher_reads = IOStats.Gopher.reads;\n    for (i = 0; i < IoStats::histSize; ++i) {\n        stats.gopher_read_hist[i] = IOStats.Gopher.read_hist[i];\n    }\n}", "target": 1}
{"code": "exit_ext2_xattr(void)\n{\n}", "target": 1}
{"code": "void CxImage::Startup(uint32_t imagetype)\n{\n\tpDib = pSelection = pAlpha = NULL;\n\tppLayers = ppFrames = NULL;\n\tmemset(&head,0,sizeof(BITMAPINFOHEADER));\n\tmemset(&info,0,sizeof(CXIMAGEINFO));\n    info.dwType = imagetype;\n\tinfo.fQuality = 90.0f;\n\tinfo.nAlphaMax = 255;\n\tinfo.nBkgndIndex = -1;\n\tinfo.bEnabled = true;\n\tinfo.nJpegScale = 1;\n\tSetXDPI(CXIMAGE_DEFAULT_DPI);\n\tSetYDPI(CXIMAGE_DEFAULT_DPI);\n\tint16_t test = 1;\n\tinfo.bLittleEndianHost = (*((char *) &test) == 1);\n}", "target": 1}
{"code": "static struct sock *__udp4_lib_mcast_demux_lookup(struct net *net,\n\t\t\t\t\t\t  __be16 loc_port, __be32 loc_addr,\n\t\t\t\t\t\t  __be16 rmt_port, __be32 rmt_addr,\n\t\t\t\t\t\t  int dif)\n{\n\tstruct sock *sk, *result;\n\tstruct hlist_nulls_node *node;\n\tunsigned short hnum = ntohs(loc_port);\n\tunsigned int count, slot = udp_hashfn(net, hnum, udp_table.mask);\n\tstruct udp_hslot *hslot = &udp_table.hash[slot];\n\tif (hslot->count > 10)\n\t\treturn NULL;\n\trcu_read_lock();\nbegin:\n\tcount = 0;\n\tresult = NULL;\n\tsk_nulls_for_each_rcu(sk, node, &hslot->head) {\n\t\tif (__udp_is_mcast_sock(net, sk,\n\t\t\t\t\tloc_port, loc_addr,\n\t\t\t\t\trmt_port, rmt_addr,\n\t\t\t\t\tdif, hnum)) {\n\t\t\tresult = sk;\n\t\t\t++count;\n\t\t}\n\t}\n\tif (get_nulls_value(node) != slot)\n\t\tgoto begin;\n\tif (result) {\n\t\tif (count != 1 ||\n\t\t    unlikely(!atomic_inc_not_zero_hint(&result->sk_refcnt, 2)))\n\t\t\tresult = NULL;\n\t\telse if (unlikely(!__udp_is_mcast_sock(net, result,\n\t\t\t\t\t\t       loc_port, loc_addr,\n\t\t\t\t\t\t       rmt_port, rmt_addr,\n\t\t\t\t\t\t       dif, hnum))) {\n\t\t\tsock_put(result);\n\t\t\tresult = NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn result;\n}", "target": 0}
{"code": "void kvm_define_shared_msr(unsigned slot, u32 msr)\n{\n\tif (slot >= shared_msrs_global.nr)\n\t\tshared_msrs_global.nr = slot + 1;\n\tshared_msrs_global.msrs[slot] = msr;\n\tsmp_wmb();\n}", "target": 0}
{"code": "static void queue_delete(struct snd_seq_queue *q)\n{\n\tmutex_lock(&q->timer_mutex);\n\tsnd_seq_timer_stop(q->timer);\n\tsnd_seq_timer_close(q);\n\tmutex_unlock(&q->timer_mutex);\n\tsnd_use_lock_sync(&q->use_lock);\n\tsnd_seq_prioq_delete(&q->tickq);\n\tsnd_seq_prioq_delete(&q->timeq);\n\tsnd_seq_timer_delete(&q->timer);\n\tkfree(q);\n}", "target": 0}
{"code": "gen_hash(codegen_scope *s, node *tree, int val, int limit)\n{\n  int slimit = GEN_VAL_STACK_MAX;\n  if (cursp() >= GEN_LIT_ARY_MAX) slimit = INT16_MAX;\n  int len = 0;\n  mrb_bool update = FALSE;\n  while (tree) {\n    if (nint(tree->car->car->car) == NODE_KW_REST_ARGS) {\n      if (val && len > 0) {\n        pop_n(len*2);\n        if (!update) {\n          genop_2(s, OP_HASH, cursp(), len);\n        }\n        else {\n          pop();\n          genop_2(s, OP_HASHADD, cursp(), len);\n        }\n        push();\n      }\n      codegen(s, tree->car->cdr, val);\n      if (val && (len > 0 || update)) {\n        pop(); pop();\n        genop_1(s, OP_HASHCAT, cursp());\n        push();\n      }\n      update = TRUE;\n      len = 0;\n    }\n    else {\n      codegen(s, tree->car->car, val);\n      codegen(s, tree->car->cdr, val);\n      len++;\n    }\n    tree = tree->cdr;\n    if (val && cursp() >= slimit) {\n      pop_n(len*2);\n      if (!update) {\n        genop_2(s, OP_HASH, cursp(), len);\n      }\n      else {\n        pop();\n        genop_2(s, OP_HASHADD, cursp(), len);\n      }\n      push();\n      update = TRUE;\n      len = 0;\n    }\n  }\n  if (update) {\n    if (val && len > 0) {\n      pop_n(len*2+1);\n      genop_2(s, OP_HASHADD, cursp(), len);\n      push();\n    }\n    return -1;                  \n  }\n  return len;\n}", "target": 0}
{"code": "GopherStateData::~GopherStateData()\n{\n    if (entry)\n        entry->unlock(\"gopherState\");\n    if (buf)\n        memFree(buf, MEM_4K_BUF);\n}", "target": 1}
{"code": "static int __init ip6_tunnel_init(void)\n{\n\tint  err;\n\tif (xfrm6_tunnel_register(&ip4ip6_handler, AF_INET)) {\n\t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip4ip6\\n\");\n\t\terr = -EAGAIN;\n\t\tgoto out;\n\t}\n\tif (xfrm6_tunnel_register(&ip6ip6_handler, AF_INET6)) {\n\t\tprintk(KERN_ERR \"ip6_tunnel init: can't register ip6ip6\\n\");\n\t\terr = -EAGAIN;\n\t\tgoto unreg_ip4ip6;\n\t}\n\terr = register_pernet_device(&ip6_tnl_net_ops);\n\tif (err < 0)\n\t\tgoto err_pernet;\n\treturn 0;\nerr_pernet:\n\txfrm6_tunnel_deregister(&ip6ip6_handler, AF_INET6);\nunreg_ip4ip6:\n\txfrm6_tunnel_deregister(&ip4ip6_handler, AF_INET);\nout:\n\treturn err;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& filter = context->input(1);\n    const TensorShape& filter_shape = filter.shape();\n    const Tensor& out_backprop = context->input(2);\n    const TensorShape& out_backprop_shape = out_backprop.shape();\n    TensorShape input_shape;\n    if (takes_shape_) {\n      const Tensor& input_sizes = context->input(0);\n      OP_REQUIRES_OK(context, tensor::MakeShape(input_sizes, &input_shape));\n    } else {\n      input_shape = context->input(0).shape();\n    }\n    OP_REQUIRES(context, input_shape.dims() == 5,\n                errors::InvalidArgument(\"input tensor must have 5 dimensions\"));\n    OP_REQUIRES(\n        context, filter_shape.dims() == 5,\n        errors::InvalidArgument(\"filter_sizes tensor must have 5 dimensions\"));\n    OP_REQUIRES(\n        context, out_backprop_shape.dims() == 5,\n        errors::InvalidArgument(\"out_backprop tensor must have 5 dimensions\"));\n    OP_REQUIRES(\n        context, input_shape.dim_size(4) == filter_shape.dim_size(3),\n        errors::InvalidArgument(\"input and filter_sizes must have the same \"\n                                \"number of channels. Got \",\n                                input_shape.dim_size(4), \" for input and \",\n                                filter_shape.dim_size(3), \" for filter_sizes\"));\n    OP_REQUIRES(\n        context, out_backprop_shape.dim_size(4) == filter_shape.dim_size(4),\n        errors::InvalidArgument(\"out_backprop and filter_sizes must have the \"\n                                \"same number of channels. Got \",\n                                out_backprop_shape.dim_size(4),\n                                \" for out_backprop and \",\n                                filter_shape.dim_size(4), \" for filter_sizes\"));\n    ConvBackpropDimensions dims;\n    OP_REQUIRES_OK(context, ConvBackpropComputeDimensions(\n                                \"Conv3DBackpropInputOp\", 3,\n                                input_shape, filter_shape, out_backprop_shape,\n                                stride_, padding_, data_format_, &dims));\n    Tensor* in_backprop;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input_shape, &in_backprop));\n    functor::CuboidConvolutionBackwardInput<Device, T>()(\n        context->eigen_device<Device>(),\n        in_backprop->tensor<T, 5>(),                     \n        filter.tensor<T, 5>(),                           \n        out_backprop.tensor<T, 5>(),                     \n        static_cast<int>(dims.spatial_dims[0].stride),   \n        static_cast<int>(dims.spatial_dims[1].stride),   \n        static_cast<int>(dims.spatial_dims[2].stride));  \n  }", "target": 0}
{"code": "void svhandler_flash_erase_sector(void) {\n  uint32_t sector = _param_1;\n  if ((sector == FLASH_BOOTSTRAP_SECTOR) ||\n      (sector >= FLASH_BOOT_SECTOR_FIRST && sector <= FLASH_BOOT_SECTOR_LAST)) {\n    return;\n  }\n  flash_clear_status_flags();\n  flash_unlock();\n  flash_erase_sector(sector, FLASH_CR_PROGRAM_X32);\n  _param_1 = !!flash_chk_status();\n  _param_2 = 0;\n  _param_3 = 0;\n  flash_wait_for_last_operation();\n  FLASH_CR &= ~FLASH_CR_PG;\n  FLASH_CR |= FLASH_CR_LOCK;\n}", "target": 1}
{"code": "    LoaderExifDataJpeg::LoaderExifDataJpeg(PreviewId id, const Image &image, int parIdx)\n        : Loader(id, image),\n          dataKey_(param_[parIdx].dataKey_)\n    {\n        ExifData::const_iterator pos = image_.exifData().findKey(dataKey_);\n        if (pos != image_.exifData().end()) {\n            size_ = pos->sizeDataArea(); \n            if (size_ == 0 && pos->typeId() == undefined)\n                size_ = pos->size(); \n        }\n        if (size_ == 0) return;\n        valid_ = true;\n    }", "target": 0}
{"code": "StatusOr<unsigned> GraphDefImporter::ArgNumType(const NamedAttrList &attrs,\n                                                const OpDef::ArgDef &arg_def,\n                                                SmallVectorImpl<Type> &types) {\n  if (!arg_def.type_list_attr().empty()) {\n    if (auto v = attrs.get(arg_def.type_list_attr()).dyn_cast<ArrayAttr>()) {\n      for (Attribute attr : v) {\n        if (auto dtype = attr.dyn_cast<TypeAttr>()) {\n          types.push_back(UnrankedTensorType::get(dtype.getValue()));\n        } else {\n          return InvalidArgument(\"Expected '\", arg_def.type_list_attr(),\n                                 \"' to be a list of types\");\n        }\n      }\n      return v.size();\n    }\n    return NotFound(\"Type attr not found: \", arg_def.type_list_attr());\n  }\n  unsigned num = 1;\n  if (!arg_def.number_attr().empty()) {\n    if (auto v = attrs.get(arg_def.number_attr()).dyn_cast<IntegerAttr>()) {\n      num = v.getValue().getZExtValue();\n    } else {\n      return NotFound(\"Type attr not found: \", arg_def.number_attr());\n    }\n  }\n  Type dtype;\n  if (arg_def.type() != DataType::DT_INVALID) {\n    TF_RETURN_IF_ERROR(ConvertDataType(arg_def.type(), b_, &dtype));\n  } else if (arg_def.type_attr().empty()) {\n    return InvalidArgument(\"Arg '\", arg_def.name(),\n                           \"' has invalid type and no type attribute\");\n  } else {\n    if (auto v = attrs.get(arg_def.type_attr()).dyn_cast<TypeAttr>()) {\n      dtype = v.getValue();\n    } else {\n      return NotFound(\"Type attr not found: \", arg_def.type_attr());\n    }\n  }\n  types.append(num, UnrankedTensorType::get(dtype));\n  return num;\n}", "target": 1}
{"code": "EncryptingStream::Create(const AP4_UI08* key, const AP4_UI08* iv, AP4_ByteStream* output, EncryptingStream*& stream) {\n    stream = NULL;\n    AP4_BlockCipher* block_cipher = NULL;\n    AP4_Result result = AP4_DefaultBlockCipherFactory::Instance.CreateCipher(AP4_BlockCipher::AES_128,\n                                                                             AP4_BlockCipher::ENCRYPT,\n                                                                             AP4_BlockCipher::CBC,\n                                                                             NULL,\n                                                                             key,\n                                                                             16,\n                                                                             block_cipher);\n    if (AP4_FAILED(result)) return result;\n    AP4_CbcStreamCipher* stream_cipher = new AP4_CbcStreamCipher(block_cipher);\n    stream_cipher->SetIV(iv);\n    stream = new EncryptingStream(stream_cipher, output);\n    return AP4_SUCCESS;\n}", "target": 0}
{"code": "Status InferenceContext::Multiply(DimensionHandle first,\n                                  DimensionOrConstant second,\n                                  DimensionHandle* out) {\n  const int64_t first_value = Value(first);\n  const int64_t second_value = Value(second);\n  if (first_value == 0) {\n    *out = first;\n  } else if (second_value == 0) {\n    *out = MakeDim(second);\n  } else if (first_value == 1) {\n    *out = MakeDim(second);\n  } else if (second_value == 1) {\n    *out = first;\n  } else if (first_value == kUnknownDim || second_value == kUnknownDim) {\n    *out = UnknownDim();\n  } else {\n    const int64_t product = first_value * second_value;\n    if (product < 0) {\n      return errors::InvalidArgument(\n          \"Negative dimension size caused by overflow when multiplying \",\n          first_value, \" and \", second_value);\n    }\n    *out = MakeDim(product);\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "  Status ValidateInputsGenerateOutputs(\n      OpKernelContext* ctx, const Tensor** inputs, const Tensor** seq_len,\n      Tensor** log_prob, OpOutputList* decoded_indices,\n      OpOutputList* decoded_values, OpOutputList* decoded_shape) const {\n    Status status = ctx->input(\"inputs\", inputs);\n    if (!status.ok()) return status;\n    status = ctx->input(\"sequence_length\", seq_len);\n    if (!status.ok()) return status;\n    const TensorShape& inputs_shape = (*inputs)->shape();\n    if (inputs_shape.dims() != 3) {\n      return errors::InvalidArgument(\"inputs is not a 3-Tensor\");\n    }\n    if (inputs_shape.num_elements() == 0) {\n      return errors::InvalidArgument(\"inputs must not be empty\");\n    }\n    const int64 max_time = inputs_shape.dim_size(0);\n    const int64 batch_size = inputs_shape.dim_size(1);\n    if (max_time == 0) {\n      return errors::InvalidArgument(\"max_time is 0\");\n    }\n    if (!TensorShapeUtils::IsVector((*seq_len)->shape())) {\n      return errors::InvalidArgument(\"sequence_length is not a vector\");\n    }\n    if (!(batch_size == (*seq_len)->dim_size(0))) {\n      return errors::FailedPrecondition(\n          \"len(sequence_length) != batch_size.  \",\n          \"len(sequence_length):  \", (*seq_len)->dim_size(0),\n          \" batch_size: \", batch_size);\n    }\n    auto seq_len_t = (*seq_len)->vec<int32>();\n    for (int b = 0; b < batch_size; ++b) {\n      if (!(seq_len_t(b) <= max_time)) {\n        return errors::FailedPrecondition(\"sequence_length(\", b,\n                                          \") <= \", max_time);\n      }\n    }\n    Status s = ctx->allocate_output(\n        \"log_probability\", TensorShape({batch_size, top_paths_}), log_prob);\n    if (!s.ok()) return s;\n    s = ctx->output_list(\"decoded_indices\", decoded_indices);\n    if (!s.ok()) return s;\n    s = ctx->output_list(\"decoded_values\", decoded_values);\n    if (!s.ok()) return s;\n    s = ctx->output_list(\"decoded_shape\", decoded_shape);\n    if (!s.ok()) return s;\n    return Status::OK();\n  }", "target": 0}
{"code": "void put_filp(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tsecurity_file_free(file);\n\t\tfile_sb_list_del(file);\n\t\tfile_free(file);\n\t}\n}", "target": 1}
{"code": "GF_Err text_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu16 pSize;\n\tGF_TextSampleEntryBox *ptr = (GF_TextSampleEntryBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\tgf_bs_write_u32(bs, ptr->displayFlags);\t\t\t\n\tgf_bs_write_u32(bs, ptr->textJustification);\t\n\tgf_bs_write_data(bs, ptr->background_color, 6);\t\n\tgpp_write_box(bs, &ptr->default_box);\t\t\t\n\tgf_bs_write_data(bs, ptr->reserved1, 8);\t\t\n\tgf_bs_write_u16(bs, ptr->fontNumber);\t\t\t\n\tgf_bs_write_u16(bs, ptr->fontFace);\t\t\t\t\n\tgf_bs_write_u8(bs, ptr->reserved2);\t\t\t\t\n\tgf_bs_write_u16(bs, ptr->reserved3);\t\t\t\n\tgf_bs_write_data(bs, ptr->foreground_color, 6);\t\n\tif (ptr->textName && (pSize = (u16) strlen(ptr->textName))) {\n\t\tgf_bs_write_u8(bs, pSize);\t\t\t\t\t\n\t\tgf_bs_write_data(bs, ptr->textName, pSize);\t\n\t} else {\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "static int filter_frame(AVFilterLink *inlink, AVFrame *in)\n{\n    GradFunContext *s = inlink->dst->priv;\n    AVFilterLink *outlink = inlink->dst->outputs[0];\n    AVFrame *out;\n    int p, direct;\n    if (av_frame_is_writable(in)) {\n        direct = 1;\n        out = in;\n    } else {\n        direct = 0;\n        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n        if (!out) {\n            av_frame_free(&in);\n            return AVERROR(ENOMEM);\n        }\n        av_frame_copy_props(out, in);\n    }\n    for (p = 0; p < 4 && in->data[p]; p++) {\n        int w = inlink->w;\n        int h = inlink->h;\n        int r = s->radius;\n        if (p) {\n            w = s->chroma_w;\n            h = s->chroma_h;\n            r = s->chroma_r;\n        }\n        if (FFMIN(w, h) > 2 * r)\n            filter(s, out->data[p], in->data[p], w, h, out->linesize[p], in->linesize[p], r);\n        else if (out->data[p] != in->data[p])\n            av_image_copy_plane(out->data[p], out->linesize[p], in->data[p], in->linesize[p], w, h);\n    }\n    if (!direct)\n        av_frame_free(&in);\n    return ff_filter_frame(outlink, out);\n}", "target": 1}
{"code": "int X509_REQ_add1_attr_by_OBJ(X509_REQ *req,\n                              const ASN1_OBJECT *obj, int type,\n                              const unsigned char *bytes, int len)\n{\n    if (X509at_add1_attr_by_OBJ(&req->req_info->attributes, obj,\n                                type, bytes, len))\n        return 1;\n    return 0;\n}", "target": 0}
{"code": "M_bool M_fs_path_ishidden(const char *path, M_fs_info_t *info)\n{\n\tM_list_str_t *path_parts;\n\tsize_t        len;\n\tM_bool        ret        = M_FALSE;\n\t(void)info;\n\tif (path == NULL || *path == '\\0') {\n\t\treturn M_FALSE;\n\t}\n\tpath_parts = M_fs_path_componentize_path(path, M_FS_SYSTEM_UNIX);\n\tlen = M_list_str_len(path_parts);\n\tif (len > 0) {\n\t\tif (*M_list_str_at(path_parts, len-1) == '.') {\n\t\t\tret = M_TRUE;\n\t\t}\n\t}\n\tM_list_str_destroy(path_parts);\n\treturn ret;\n}", "target": 1}
{"code": "void mp_encode_lua_table_as_array(lua_State *L, mp_buf *buf, int level) {\n#if LUA_VERSION_NUM < 502\n    size_t len = lua_objlen(L,-1), j;\n#else\n    size_t len = lua_rawlen(L,-1), j;\n#endif\n    mp_encode_array(L,buf,len);\n    luaL_checkstack(L, 1, \"in function mp_encode_lua_table_as_array\");\n    for (j = 1; j <= len; j++) {\n        lua_pushnumber(L,j);\n        lua_gettable(L,-2);\n        mp_encode_lua_type(L,buf,level+1);\n    }\n}", "target": 0}
{"code": "bool SignedData::verify_signature() const {\n  STACK_OF(X509) *certs = nullptr;\n  switch (OBJ_obj2nid(p7_->type)) {\n    case NID_pkcs7_signed: {\n      certs = p7_->d.sign->cert;\n      break;\n    }\n    case NID_pkcs7_signedAndEnveloped: {\n      certs = p7_->d.signed_and_enveloped->cert;\n      break;\n    }\n  }\n  if (certs == nullptr) {\n    return false;\n  }\n  auto *signers_stack_ptr = PKCS7_get0_signers(p7_, nullptr, 0);\n  if (signers_stack_ptr == nullptr) {\n    return false;\n  }\n  auto signers_stack = impl::STACK_OF_X509_ptr(signers_stack_ptr, impl::SK_X509_free);\n  for (auto i = 0; i < sk_X509_num(signers_stack.get()); ++i) {\n    auto *signer = sk_X509_value(signers_stack.get(), i);\n    auto xku_flags = X509_get_extended_key_usage(signer);\n    if (!(xku_flags & XKU_CODE_SIGN)) {\n      return false;\n    }\n  }\n  std::uint8_t *indirect_data_buf = nullptr;\n  auto buf_size = impl::i2d_Authenticode_SpcIndirectDataContent(indirect_data_, &indirect_data_buf);\n  if (buf_size < 0 || indirect_data_buf == nullptr) {\n    return false;\n  }\n  auto indirect_data_ptr =\n      impl::OpenSSL_ptr(reinterpret_cast<char *>(indirect_data_buf), impl::OpenSSL_free);\n  const auto *signed_data_seq = reinterpret_cast<std::uint8_t *>(indirect_data_ptr.get());\n  long length = 0;\n  int tag = 0, tag_class = 0;\n  ASN1_get_object(&signed_data_seq, &length, &tag, &tag_class, buf_size);\n  if (tag != V_ASN1_SEQUENCE) {\n    return false;\n  }\n  auto *signed_data_ptr = BIO_new_mem_buf(signed_data_seq, length);\n  if (signed_data_ptr == nullptr) {\n    return false;\n  }\n  impl::BIO_ptr signed_data(signed_data_ptr, BIO_free);\n  auto status = PKCS7_verify(p7_, certs, nullptr, signed_data.get(), nullptr, PKCS7_NOVERIFY);\n  return status == 1;\n}", "target": 0}
{"code": "\t\tGetRunner(\n\t\t\tconst ReferenceHandle& that,\n\t\t\tLocal<Value> key_handle,\n\t\t\tMaybeLocal<Object> maybe_options,\n\t\t\tbool inherit\n\t\t) :\n\t\t\t\tcontext{that.context},\n\t\t\t\treference{that.reference},\n\t\t\t\toptions{maybe_options, inherit ?\n\t\t\t\t\tTransferOptions::Type::DeepReference : TransferOptions::Type::Reference},\n\t\t\t\tinherit{inherit} {\n\t\t\tthat.CheckDisposed();\n\t\t\tkey = ExternalCopy::CopyIfPrimitive(key_handle);\n\t\t\tif (!key) {\n\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n\t\t\t}\n\t\t}", "target": 1}
{"code": "static bool find_andx_cmd_ofs(uint8_t *buf, size_t *pofs)\n{\n\tuint8_t cmd;\n\tsize_t ofs;\n\tcmd = CVAL(buf, smb_com);\n\tSMB_ASSERT(is_andx_req(cmd));\n\tofs = smb_vwv0;\n\twhile (CVAL(buf, ofs) != 0xff) {\n\t\tif (!is_andx_req(CVAL(buf, ofs))) {\n\t\t\treturn false;\n\t\t}\n\t\tofs = SVAL(buf, ofs+2) + 4 + 1;\n\t\tSMB_ASSERT(ofs+4 < talloc_get_size(buf));\n\t}\n\t*pofs = ofs;\n\treturn true;\n}", "target": 0}
{"code": "  TestCertificateValidationContextConfig(\n      envoy::config::core::v3::TypedExtensionConfig config, bool allow_expired_certificate = false,\n      std::vector<envoy::type::matcher::v3::StringMatcher> san_matchers = {})\n      : allow_expired_certificate_(allow_expired_certificate), api_(Api::createApiForTest()),\n        custom_validator_config_(config), san_matchers_(san_matchers){};", "target": 1}
{"code": "static Jsi_RC SysVerConvertCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_Value *flag = Jsi_ValueArrayIndex(interp, args, 1);\n    if (!val) goto bail;\n    if (Jsi_ValueIsNumber(interp, val)) {\n        char buf[200];\n        Jsi_Number n;\n        if (Jsi_GetNumberFromValue(interp, val, &n) != JSI_OK)\n            goto bail;\n        jsi_VersionNormalize(n, buf, sizeof(buf));\n        int trunc = 0;\n        if (flag && (Jsi_GetIntFromValue(interp, flag, &trunc) != JSI_OK\n            || trunc<0 || trunc>2))\n            return Jsi_LogError(\"arg2: bad trunc: expected int between 0 and 2\");\n        if (trunc) {\n            int len = Jsi_Strlen(buf)-1;\n            while (trunc>0 && len>1) {\n                if (buf[len] == '0' && buf[len-1] == '.')\n                    buf[len-1] = 0;\n                len -= 2;\n                trunc--;\n            }\n        }\n        Jsi_ValueMakeStringDup(interp, ret, buf);\n        return JSI_OK;\n    }\n    if (Jsi_ValueIsString(interp, val)) {\n        Jsi_Number n;\n        if (jsi_GetVerFromVal(interp, val, &n, 0) == JSI_OK) {\n            Jsi_ValueMakeNumber(interp, ret, n);\n            return JSI_OK;\n        }\n    }\nbail:\n    Jsi_ValueMakeNull(interp, ret);\n    return JSI_OK;\n}", "target": 1}
{"code": "static __u8 *cp_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tunsigned long quirks = (unsigned long)hid_get_drvdata(hdev);\n\tunsigned int i;\n\tif (!(quirks & CP_RDESC_SWAPPED_MIN_MAX))\n\t\treturn rdesc;\n\tif (*rsize < 4)\n\t\treturn rdesc;\n\tfor (i = 0; i < *rsize - 4; i++)\n\t\tif (rdesc[i] == 0x29 && rdesc[i + 2] == 0x19) {\n\t\t\trdesc[i] = 0x19;\n\t\t\trdesc[i + 2] = 0x29;\n\t\t\tswap(rdesc[i + 3], rdesc[i + 1]);\n\t\t}\n\treturn rdesc;\n}", "target": 0}
{"code": "xfs_ilock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\ttrace_xfs_ilock(ip, lock_flags, _RET_IP_);\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_MMAPLOCK_SHARED | XFS_MMAPLOCK_EXCL)) !=\n\t       (XFS_MMAPLOCK_SHARED | XFS_MMAPLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_SUBCLASS_MASK)) == 0);\n\tif (lock_flags & XFS_IOLOCK_EXCL) {\n\t\tdown_write_nested(&VFS_I(ip)->i_rwsem,\n\t\t\t\t  XFS_IOLOCK_DEP(lock_flags));\n\t} else if (lock_flags & XFS_IOLOCK_SHARED) {\n\t\tdown_read_nested(&VFS_I(ip)->i_rwsem,\n\t\t\t\t XFS_IOLOCK_DEP(lock_flags));\n\t}\n\tif (lock_flags & XFS_MMAPLOCK_EXCL)\n\t\tmrupdate_nested(&ip->i_mmaplock, XFS_MMAPLOCK_DEP(lock_flags));\n\telse if (lock_flags & XFS_MMAPLOCK_SHARED)\n\t\tmraccess_nested(&ip->i_mmaplock, XFS_MMAPLOCK_DEP(lock_flags));\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrupdate_nested(&ip->i_lock, XFS_ILOCK_DEP(lock_flags));\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmraccess_nested(&ip->i_lock, XFS_ILOCK_DEP(lock_flags));\n}", "target": 0}
{"code": "long ZEXPORT inflateMark(strm)\nz_streamp strm;\n{\n    struct inflate_state FAR *state;\n    if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;\n    state = (struct inflate_state FAR *)strm->state;\n    return ((long)(state->back) << 16) +\n        (state->mode == COPY ? state->length :\n            (state->mode == MATCH ? state->was - state->length : 0));\n}", "target": 1}
{"code": "static int bpf_adj_delta_to_imm(struct bpf_insn *insn, u32 pos, u32 delta,\n\t\t\t\tu32 curr, const bool probe_pass)\n{\n\tconst s64 imm_min = S32_MIN, imm_max = S32_MAX;\n\ts64 imm = insn->imm;\n\tif (curr < pos && curr + imm + 1 > pos)\n\t\timm += delta;\n\telse if (curr > pos + delta && curr + imm + 1 <= pos + delta)\n\t\timm -= delta;\n\tif (imm < imm_min || imm > imm_max)\n\t\treturn -ERANGE;\n\tif (!probe_pass)\n\t\tinsn->imm = imm;\n\treturn 0;\n}", "target": 0}
{"code": "void nfs4_close_state(struct path *path, struct nfs4_state *state, mode_t mode)\n{\n\t__nfs4_close(path, state, mode, 0);\n}", "target": 1}
{"code": "  Status BuildInputArgIndex(const OpDef::ArgDef& arg_def, AttrSlice attr_values,\n                            const FunctionDef::ArgAttrs* arg_attrs,\n                            bool ints_on_device,\n                            int64_t resource_arg_unique_id) {\n    bool is_type_list;\n    DataTypeVector dtypes;\n    TF_RETURN_IF_ERROR(\n        ArgNumType(attr_values, arg_def, &is_type_list, &dtypes));\n    if (dtypes.size() < size_t{1}) {\n      return errors::Internal(\"Expected a list of at least one dtype\");\n    }\n    int arg_index = result_.nodes.size();\n    TF_RETURN_IF_ERROR(\n        AddItem(arg_def.name(), {true, arg_index, 0, is_type_list, dtypes}));\n    for (size_t i = 0; i < dtypes.size(); ++i) {\n      TF_RETURN_IF_ERROR(AddItem(strings::StrCat(arg_def.name(), \":\", i),\n                                 {true, arg_index, 0, false, {dtypes[i]}}));\n      if (arg_index != result_.nodes.size()) {\n        return errors::Internal(\n            \"Expected arg_index to be equal to the number of nodes in result.\",\n            \" Got \", arg_index, \" and \", result_.nodes.size());\n      }\n      string name = arg_def.name();\n      if (dtypes.size() > 1) {\n        strings::StrAppend(&name, \"_\", i);\n      }\n      NodeDef* gnode = AddNode(name);\n      if (ints_on_device && dtypes[i] == DataType::DT_INT32) {\n        gnode->set_op(FunctionLibraryDefinition::kDeviceArgOp);\n      } else {\n        gnode->set_op(FunctionLibraryDefinition::kArgOp);\n      }\n      DataType dtype = arg_def.is_ref() ? MakeRefType(dtypes[i]) : dtypes[i];\n      AddAttr(\"T\", dtype, gnode);\n      AddAttr(\"index\", arg_index, gnode);\n      if (resource_arg_unique_id >= 0) {\n        AddAttr(\"_resource_arg_unique_id\", resource_arg_unique_id, gnode);\n      }\n      if (arg_attrs) {\n        for (const auto& arg_attr : arg_attrs->attr()) {\n          AddAttr(arg_attr.first, arg_attr.second, gnode->mutable_attr());\n        }\n      }\n      result_.arg_types.push_back(dtypes[i]);\n      ++arg_index;\n    }\n    return Status::OK();\n  }", "target": 0}
{"code": "void vmacache_flush_all(struct mm_struct *mm)\n{\n\tstruct task_struct *g, *p;\n\tcount_vm_vmacache_event(VMACACHE_FULL_FLUSHES);\n\tif (atomic_read(&mm->mm_users) == 1)\n\t\treturn;\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (mm == p->mm)\n\t\t\tvmacache_flush(p);\n\t}\n\trcu_read_unlock();\n}", "target": 1}
{"code": "void LibRaw::Canon_WBpresets(int skip1, int skip2)\n{\n  int c;\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Daylight][c ^ (c >> 1)] = get2();\n  if (skip1)\n    fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Shade][c ^ (c >> 1)] = get2();\n  if (skip1)\n    fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Cloudy][c ^ (c >> 1)] = get2();\n  if (skip1)\n    fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Tungsten][c ^ (c >> 1)] = get2();\n  if (skip1)\n    fseek(ifp, skip1, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_FL_W][c ^ (c >> 1)] = get2();\n  if (skip2)\n    fseek(ifp, skip2, SEEK_CUR);\n  FORC4 imgdata.color.WB_Coeffs[LIBRAW_WBI_Flash][c ^ (c >> 1)] = get2();\n  return;\n}", "target": 0}
{"code": "inline typename V::MapType FBUnserializer<V>::unserializeMap() {\n  p_ += CODE_SIZE;\n  typename V::MapType ret = V::createMap();\n  size_t code = nextCode();\n  while (code != FB_SERIALIZE_STOP) {\n    switch (code) {\n      case FB_SERIALIZE_VARCHAR:\n      case FB_SERIALIZE_STRING:\n        {\n          auto key = unserializeString();\n          auto value = unserializeThing();\n          V::mapSet(ret, std::move(key), std::move(value));\n        }\n        break;\n      default:\n        {\n          auto key = unserializeInt64();\n          auto value = unserializeThing();\n          V::mapSet(ret, std::move(key), std::move(value));\n        }\n    }\n    code = nextCode();\n  }\n  p_ += CODE_SIZE;\n  return ret;\n}", "target": 1}
{"code": "CephXAuthorizer *CephXTicketHandler::build_authorizer(uint64_t global_id) const\n{\n  CephXAuthorizer *a = new CephXAuthorizer(cct);\n  a->session_key = session_key;\n  a->nonce = ((uint64_t)rand() << 32) + rand();\n  __u8 authorizer_v = 1;\n  ::encode(authorizer_v, a->bl);\n  ::encode(global_id, a->bl);\n  ::encode(service_id, a->bl);\n  ::encode(ticket, a->bl);\n  a->base_bl = a->bl;\n  CephXAuthorize msg;\n  msg.nonce = a->nonce;\n  std::string error;\n  if (encode_encrypt(cct, msg, session_key, a->bl, error)) {\n    ldout(cct, 0) << \"failed to encrypt authorizer: \" << error << dendl;\n    delete a;\n    return 0;\n  }\n  return a;\n}", "target": 0}
{"code": "static int ext4_split_extent(handle_t *handle,\n\t\t\t      struct inode *inode,\n\t\t\t      struct ext4_ext_path *path,\n\t\t\t      struct ext4_map_blocks *map,\n\t\t\t      int split_flag,\n\t\t\t      int flags)\n{\n\text4_lblk_t ee_block;\n\tstruct ext4_extent *ex;\n\tunsigned int ee_len, depth;\n\tint err = 0;\n\tint uninitialized;\n\tint split_flag1, flags1;\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tee_block = le32_to_cpu(ex->ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n\tuninitialized = ext4_ext_is_uninitialized(ex);\n\tif (map->m_lblk + map->m_len < ee_block + ee_len) {\n\t\tsplit_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ?\n\t\t\t      EXT4_EXT_MAY_ZEROOUT : 0;\n\t\tflags1 = flags | EXT4_GET_BLOCKS_PRE_IO;\n\t\tif (uninitialized)\n\t\t\tsplit_flag1 |= EXT4_EXT_MARK_UNINIT1 |\n\t\t\t\t       EXT4_EXT_MARK_UNINIT2;\n\t\terr = ext4_split_extent_at(handle, inode, path,\n\t\t\t\tmap->m_lblk + map->m_len, split_flag1, flags1);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\text4_ext_drop_refs(path);\n\tpath = ext4_ext_find_extent(inode, map->m_lblk, path);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\tif (map->m_lblk >= ee_block) {\n\t\tsplit_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ?\n\t\t\t      EXT4_EXT_MAY_ZEROOUT : 0;\n\t\tif (uninitialized)\n\t\t\tsplit_flag1 |= EXT4_EXT_MARK_UNINIT1;\n\t\tif (split_flag & EXT4_EXT_MARK_UNINIT2)\n\t\t\tsplit_flag1 |= EXT4_EXT_MARK_UNINIT2;\n\t\terr = ext4_split_extent_at(handle, inode, path,\n\t\t\t\tmap->m_lblk, split_flag1, flags);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\text4_ext_show_leaf(inode, path);\nout:\n\treturn err ? err : map->m_len;\n}", "target": 1}
{"code": "Status OpLevelCostEstimator::PredictAvgPoolGrad(const OpContext& op_context,\n                                                NodeCosts* node_costs) const {\n  bool found_unknown_shapes = false;\n  const auto& op_info = op_context.op_info;\n  bool shape_found = false;\n  TensorShapeProto x_shape;\n  if (op_info.inputs_size() >= 1 && op_info.inputs(0).has_value()) {\n    const TensorProto& value = op_info.inputs(0).value();\n    shape_found = GetTensorShapeProtoFromTensorProto(value, &x_shape);\n  }\n  if (!shape_found && op_info.outputs_size() > 0) {\n    x_shape = op_info.outputs(0).shape();\n    shape_found = true;\n  }\n  if (!shape_found) {\n    x_shape.Clear();\n    for (int i = 0; i < 4; ++i) {\n      x_shape.add_dim()->set_size(1);\n    }\n    found_unknown_shapes = true;\n  }\n  ConvolutionDimensions dims =\n      OpDimensionsFromInputs(x_shape, op_info, &found_unknown_shapes);\n  int64_t ops = 0;\n  if (dims.kx <= dims.sx && dims.ky <= dims.sy) {\n    ops = dims.batch * dims.iz * (dims.ix * dims.iy + dims.ox * dims.oy);\n  } else {\n    ops = dims.batch * dims.iz *\n          (dims.ix * dims.iy + dims.ox * dims.oy * (dims.kx * dims.ky + 1));\n  }\n  auto s = PredictDefaultNodeCosts(ops, op_context, &found_unknown_shapes,\n                                   node_costs);\n  node_costs->max_memory = node_costs->num_total_output_bytes();\n  return s;\n}", "target": 1}
{"code": "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\tkey = key_ref_to_ptr(key_ref);\n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error;\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\ncan_read_key:\n\tret = key_validate(key);\n\tif (ret == 0) {\n\t\tret = -EOPNOTSUPP;\n\t\tif (key->type->read) {\n\t\t\tdown_read(&key->sem);\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\t\tup_read(&key->sem);\n\t\t}\n\t}\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}", "target": 1}
{"code": "static int shash_no_setkey(struct crypto_shash *tfm, const u8 *key,\n\t\t\t   unsigned int keylen)\n{\n\treturn -ENOSYS;\n}", "target": 1}
{"code": "mrb_ary_shift_m(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a = mrb_ary_ptr(self);\n  mrb_int len = ARY_LEN(a);\n  mrb_int n;\n  mrb_value val;\n  if (mrb_get_args(mrb, \"|i\", &n) == 0) {\n    return mrb_ary_shift(mrb, self);\n  };\n  ary_modify_check(mrb, a);\n  if (len == 0 || n == 0) return mrb_ary_new(mrb);\n  if (n < 0) mrb_raise(mrb, E_ARGUMENT_ERROR, \"negative array shift\");\n  if (n > len) n = len;\n  val = mrb_ary_new_from_values(mrb, n, ARY_PTR(a));\n  if (ARY_SHARED_P(a)) {\n  L_SHIFT:\n    a->as.heap.ptr+=n;\n    a->as.heap.len-=n;\n    return val;\n  }\n  if (len > ARY_SHIFT_SHARED_MIN) {\n    ary_make_shared(mrb, a);\n    goto L_SHIFT;\n  }\n  else if (len == n) {\n    ARY_SET_LEN(a, 0);\n  }\n  else {\n    mrb_value *ptr = ARY_PTR(a);\n    mrb_int size = len-n;\n    while (size--) {\n      *ptr = *(ptr+n);\n      ++ptr;\n    }\n    ARY_SET_LEN(a, len-n);\n  }\n  return val;\n}", "target": 1}
{"code": "int writeToFile(PlatformFileHandle handle, const char* data, int length)\n{\n    if (!isHandleValid(handle))\n        return -1;\n    DWORD bytesWritten;\n    bool success = WriteFile(handle, data, length, &bytesWritten, 0);\n    if (!success)\n        return -1;\n    return static_cast<int>(bytesWritten);\n}", "target": 0}
{"code": "static void evdev_queue_syn_dropped(struct evdev_client *client)\n{\n\tunsigned long flags;\n\tstruct input_event ev;\n\tktime_t time;\n\ttime = ktime_get();\n\tif (client->clkid != CLOCK_MONOTONIC)\n\t\ttime = ktime_sub(time, ktime_get_monotonic_offset());\n\tev.time = ktime_to_timeval(time);\n\tev.type = EV_SYN;\n\tev.code = SYN_DROPPED;\n\tev.value = 0;\n\tspin_lock_irqsave(&client->buffer_lock, flags);\n\tclient->buffer[client->head++] = ev;\n\tclient->head &= client->bufsize - 1;\n\tif (unlikely(client->head == client->tail)) {\n\t\tclient->tail = (client->head - 1) & (client->bufsize - 1);\n\t\tclient->packet_head = client->tail;\n\t}\n\tspin_unlock_irqrestore(&client->buffer_lock, flags);\n}", "target": 0}
{"code": "  const hbc::DebugOffsets *getDebugOffsets(uint32_t) const override {\n    llvm_unreachable(\"Accessing debug offsets from a lazy module\");\n  }", "target": 1}
{"code": "static void destroy_super(struct super_block *s)\n{\n\tint i;\n\tlist_lru_destroy(&s->s_dentry_lru);\n\tlist_lru_destroy(&s->s_inode_lru);\n#ifdef CONFIG_SMP\n\tfree_percpu(s->s_files);\n#endif\n\tfor (i = 0; i < SB_FREEZE_LEVELS; i++)\n\t\tpercpu_counter_destroy(&s->s_writers.counter[i]);\n\tsecurity_sb_free(s);\n\tWARN_ON(!list_empty(&s->s_mounts));\n\tkfree(s->s_subtype);\n\tkfree(s->s_options);\n\tkfree_rcu(s, rcu);\n}", "target": 1}
{"code": "  DeletionConfirmationDlg(QWidget *parent, const int &size, const QString &name, bool defaultDeleteFiles): QDialog(parent) {\n    setupUi(this);\n    if (size == 1)\n      label->setText(tr(\"Are you sure you want to delete '%1' from the transfer list?\", \"Are you sure you want to delete 'ubuntu-linux-iso' from the transfer list?\").arg(name));\n    else\n      label->setText(tr(\"Are you sure you want to delete these %1 torrents from the transfer list?\", \"Are you sure you want to delete these 5 torrents from the transfer list?\").arg(QString::number(size)));\n    lbl_warn->setPixmap(GuiIconProvider::instance()->getIcon(\"dialog-warning\").pixmap(lbl_warn->height()));\n    lbl_warn->setFixedWidth(lbl_warn->height());\n    rememberBtn->setIcon(GuiIconProvider::instance()->getIcon(\"object-locked\"));\n    move(Utils::Misc::screenCenter(this));\n    checkPermDelete->setChecked(defaultDeleteFiles || Preferences::instance()->deleteTorrentFilesAsDefault());\n    connect(checkPermDelete, SIGNAL(clicked()), this, SLOT(updateRememberButtonState()));\n    buttonBox->button(QDialogButtonBox::Cancel)->setFocus();\n  }", "target": 1}
{"code": "static VALUE from_document(VALUE klass, VALUE document)\n{\n  xmlDocPtr doc;\n  xmlSchemaParserCtxtPtr ctx;\n  xmlSchemaPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n  Data_Get_Struct(document, xmlDoc, doc);\n  doc = doc->doc;\n  if (has_blank_nodes_p(DOC_NODE_CACHE(doc))) {\n    rb_raise(rb_eArgError, \"Creating a schema from a document that has blank nodes exposed to Ruby is dangerous\");\n  }\n  ctx = xmlSchemaNewDocParserCtxt(doc);\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n#ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS\n  xmlSchemaSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n  schema = xmlSchemaParse(ctx);\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlSchemaFreeParserCtxt(ctx);\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n    return Qnil;\n  }\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n  return rb_schema;\n  return Qnil;\n}", "target": 1}
{"code": "void LibRaw::nikon_14bit_load_raw()\n{\n  const unsigned linelen =\n      (unsigned)(ceilf((float)(S.raw_width * 7 / 4) / 16.0)) *\n      16; \n  const unsigned pitch = S.raw_pitch ? S.raw_pitch / 2 : S.raw_width;\n  unsigned char *buf = (unsigned char *)malloc(linelen);\n  merror(buf, \"nikon_14bit_load_raw()\");\n  for (int row = 0; row < S.raw_height; row++)\n  {\n    unsigned bytesread =\n        libraw_internal_data.internal_data.input->read(buf, 1, linelen);\n    unsigned short *dest = &imgdata.rawdata.raw_image[pitch * row];\n    for (int sp = 0, dp = 0;\n         dp < pitch - 3 && sp < linelen - 6 && sp < bytesread - 6;\n         sp += 7, dp += 4)\n      unpack7bytesto4x16_nikon(buf + sp, dest + dp);\n  }\n  free(buf);\n}", "target": 0}
{"code": "bool MemoryManager::validate_user_read(const Process& process, VirtualAddress vaddr) const\n{\n    auto* region = region_from_vaddr(process, vaddr);\n    return region && region->is_readable();\n}", "target": 1}
{"code": "static void perf_event_init_cpu(int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\tmutex_lock(&swhash->hlist_mutex);\n\tswhash->online = true;\n\tif (swhash->hlist_refcount > 0) {\n\t\tstruct swevent_hlist *hlist;\n\t\thlist = kzalloc_node(sizeof(*hlist), GFP_KERNEL, cpu_to_node(cpu));\n\t\tWARN_ON(!hlist);\n\t\trcu_assign_pointer(swhash->swevent_hlist, hlist);\n\t}\n\tmutex_unlock(&swhash->hlist_mutex);\n}", "target": 1}
{"code": "static void vmx_set_msr_bitmap(struct kvm_vcpu *vcpu)\n{\n\tunsigned long *msr_bitmap;\n\tif (is_guest_mode(vcpu))\n\t\tmsr_bitmap = vmx_msr_bitmap_nested;\n\telse if (vcpu->arch.apic_base & X2APIC_ENABLE) {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode_x2apic;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy_x2apic;\n\t} else {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy;\n\t}\n\tvmcs_write64(MSR_BITMAP, __pa(msr_bitmap));\n}", "target": 1}
{"code": "  bool ms_verify_authorizer(Connection *con, int peer_type, int protocol,\n                            bufferlist& authorizer, bufferlist& authorizer_reply,\n                            bool& isvalid, CryptoKey& session_key) override {\n    isvalid = true;\n    return true;\n  }", "target": 1}
{"code": "CompileResult generateBytecodeForExecution(\n    Module &M,\n    const BytecodeGenerationOptions &genOptions) {\n  std::shared_ptr<Context> context = M.shareContext();\n  CompileResult result{Success};\n  if (cl::BytecodeFormat == cl::BytecodeFormatKind::HBC) {\n    result.bytecodeProvider = hbc::BCProviderFromSrc::createBCProviderFromSrc(\n        hbc::generateBytecodeModule(&M, M.getTopLevelFunction(), genOptions));\n  } else {\n    llvm_unreachable(\"Invalid bytecode kind for execution\");\n    result = InvalidFlags;\n  }\n  return result;\n}", "target": 1}
{"code": "static int32_t virtio_net_rsc_sanity_check4(VirtioNetRscChain *chain,\n                                            struct ip_header *ip,\n                                            const uint8_t *buf, size_t size)\n{\n    uint16_t ip_len;\n    if (((ip->ip_ver_len & 0xF0) >> 4) != IP_HEADER_VERSION_4) {\n        chain->stat.ip_option++;\n        return RSC_BYPASS;\n    }\n    if ((ip->ip_ver_len & 0xF) != VIRTIO_NET_IP4_HEADER_LENGTH) {\n        chain->stat.ip_option++;\n        return RSC_BYPASS;\n    }\n    if (ip->ip_p != IPPROTO_TCP) {\n        chain->stat.bypass_not_tcp++;\n        return RSC_BYPASS;\n    }\n    if (!(htons(ip->ip_off) & IP_DF)) {\n        chain->stat.ip_frag++;\n        return RSC_BYPASS;\n    }\n    if (IPTOS_ECN(ip->ip_tos)) {\n        chain->stat.ip_ecn++;\n        return RSC_BYPASS;\n    }\n    ip_len = htons(ip->ip_len);\n    if (ip_len < (sizeof(struct ip_header) + sizeof(struct tcp_header))\n        || ip_len > (size - chain->n->guest_hdr_len -\n                     sizeof(struct eth_header))) {\n        chain->stat.ip_hacked++;\n        return RSC_BYPASS;\n    }\n    return RSC_CANDIDATE;\n}", "target": 0}
{"code": "void addReply(redisClient *c, robj *obj) {\n    if (_installWriteEvent(c) != REDIS_OK) return;\n    redisAssert(!server.vm_enabled || obj->storage == REDIS_VM_MEMORY);\n    if (obj->encoding == REDIS_ENCODING_RAW) {\n        if (_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != REDIS_OK)\n            _addReplyObjectToList(c,obj);\n    } else {\n        obj = getDecodedObject(obj);\n        if (_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != REDIS_OK)\n            _addReplyObjectToList(c,obj);\n        decrRefCount(obj);\n    }\n}", "target": 1}
{"code": "static int iwl_process_add_sta_resp(struct iwl_priv *priv,\n\t\t\t\t    struct iwl_addsta_cmd *addsta,\n\t\t\t\t    struct iwl_rx_packet *pkt)\n{\n\tu8 sta_id = addsta->sta.sta_id;\n\tunsigned long flags;\n\tint ret = -EIO;\n\tif (pkt->hdr.flags & IWL_CMD_FAILED_MSK) {\n\t\tIWL_ERR(priv, \"Bad return from REPLY_ADD_STA (0x%08X)\\n\",\n\t\t\tpkt->hdr.flags);\n\t\treturn ret;\n\t}\n\tIWL_DEBUG_INFO(priv, \"Processing response for adding station %u\\n\",\n\t\t       sta_id);\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\tswitch (pkt->u.add_sta.status) {\n\tcase ADD_STA_SUCCESS_MSK:\n\t\tIWL_DEBUG_INFO(priv, \"REPLY_ADD_STA PASSED\\n\");\n\t\tiwl_sta_ucode_activate(priv, sta_id);\n\t\tret = 0;\n\t\tbreak;\n\tcase ADD_STA_NO_ROOM_IN_TABLE:\n\t\tIWL_ERR(priv, \"Adding station %d failed, no room in table.\\n\",\n\t\t\tsta_id);\n\t\tbreak;\n\tcase ADD_STA_NO_BLOCK_ACK_RESOURCE:\n\t\tIWL_ERR(priv, \"Adding station %d failed, no block ack \"\n\t\t\t\"resource.\\n\", sta_id);\n\t\tbreak;\n\tcase ADD_STA_MODIFY_NON_EXIST_STA:\n\t\tIWL_ERR(priv, \"Attempting to modify non-existing station %d\\n\",\n\t\t\tsta_id);\n\t\tbreak;\n\tdefault:\n\t\tIWL_DEBUG_ASSOC(priv, \"Received REPLY_ADD_STA:(0x%08X)\\n\",\n\t\t\t\tpkt->u.add_sta.status);\n\t\tbreak;\n\t}\n\tIWL_DEBUG_INFO(priv, \"%s station id %u addr %pM\\n\",\n\t\t       priv->stations[sta_id].sta.mode ==\n\t\t       STA_CONTROL_MODIFY_MSK ?  \"Modified\" : \"Added\",\n\t\t       sta_id, priv->stations[sta_id].sta.sta.addr);\n\tIWL_DEBUG_INFO(priv, \"%s station according to cmd buffer %pM\\n\",\n\t\t       priv->stations[sta_id].sta.mode ==\n\t\t       STA_CONTROL_MODIFY_MSK ? \"Modified\" : \"Added\",\n\t\t       addsta->sta.addr);\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\treturn ret;\n}", "target": 1}
{"code": "ev_archive_read_data (EvArchive *archive,\n\t\t      void      *buf,\n\t\t      gsize      count,\n\t\t      GError   **error)\n{\n\tgssize r = -1;\n\tg_return_val_if_fail (EV_IS_ARCHIVE (archive), -1);\n\tg_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, -1);\n\tswitch (archive->type) {\n\tcase EV_ARCHIVE_TYPE_NONE:\n\t\tg_assert_not_reached ();\n\tcase EV_ARCHIVE_TYPE_RAR:\n\tcase EV_ARCHIVE_TYPE_ZIP:\n\tcase EV_ARCHIVE_TYPE_7Z:\n\tcase EV_ARCHIVE_TYPE_TAR:\n\t\tg_return_val_if_fail (archive->libar_entry != NULL, -1);\n\t\tr = archive_read_data (archive->libar, buf, count);\n\t\tif (r < 0) {\n\t\t\tg_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,\n\t\t\t\t     \"Failed to decompress data: %s\", archive_error_string (archive->libar));\n\t\t}\n\t\tbreak;\n\t}\n\treturn r;\n}", "target": 0}
{"code": "  void Messageheader::Parser::checkHeaderspace(unsigned chars) const\n  {\n    if (headerdataPtr + chars >= header.rawdata + sizeof(header.rawdata))\n    {\n      header.rawdata[sizeof(header.rawdata) - 1] = '\\0';\n      throw HttpError(HTTP_REQUEST_ENTITY_TOO_LARGE, \"header too large\");\n    }\n  }", "target": 0}
{"code": "static void scalar32_min_max_or(struct bpf_reg_state *dst_reg,\n\t\t\t\tstruct bpf_reg_state *src_reg)\n{\n\tbool src_known = tnum_subreg_is_const(src_reg->var_off);\n\tbool dst_known = tnum_subreg_is_const(dst_reg->var_off);\n\tstruct tnum var32_off = tnum_subreg(dst_reg->var_off);\n\ts32 smin_val = src_reg->smin_value;\n\tu32 umin_val = src_reg->umin_value;\n\tif (src_known && dst_known)\n\t\treturn;\n\tdst_reg->u32_min_value = max(dst_reg->u32_min_value, umin_val);\n\tdst_reg->u32_max_value = var32_off.value | var32_off.mask;\n\tif (dst_reg->s32_min_value < 0 || smin_val < 0) {\n\t\tdst_reg->s32_min_value = S32_MIN;\n\t\tdst_reg->s32_max_value = S32_MAX;\n\t} else {\n\t\tdst_reg->s32_min_value = dst_reg->umin_value;\n\t\tdst_reg->s32_max_value = dst_reg->umax_value;\n\t}\n}", "target": 1}
{"code": "de265_error decoder_context::decode_some(bool* did_work)\n{\n  de265_error err = DE265_OK;\n  *did_work = false;\n  if (image_units.empty()) { return DE265_OK; }  \n  if ( ! image_units.empty() ) { \n    image_unit* imgunit = image_units[0];\n    slice_unit* sliceunit = imgunit->get_next_unprocessed_slice_segment();\n    if (sliceunit != NULL) {\n      if (sliceunit->flush_reorder_buffer) {\n        dpb.flush_reorder_buffer();\n      }\n      *did_work = true;\n      err = decode_slice_unit_parallel(imgunit, sliceunit);\n      if (err) {\n        return err;\n      }\n    }\n  }\n  if ( ( image_units.size()>=2 && image_units[0]->all_slice_segments_processed()) ||\n       ( image_units.size()>=1 && image_units[0]->all_slice_segments_processed() &&\n         nal_parser.number_of_NAL_units_pending()==0 &&\n         (nal_parser.is_end_of_stream() || nal_parser.is_end_of_frame()) )) {\n    image_unit* imgunit = image_units[0];\n    *did_work=true;\n    imgunit->img->mark_all_CTB_progress(CTB_PROGRESS_PREFILTER);\n    if (img->decctx->num_worker_threads)\n      run_postprocessing_filters_parallel(imgunit);\n    else\n      run_postprocessing_filters_sequential(imgunit->img);\n    for (int i=0;i<imgunit->suffix_SEIs.size();i++) {\n      const sei_message& sei = imgunit->suffix_SEIs[i];\n      err = process_sei(&sei, imgunit->img);\n      if (err != DE265_OK)\n        break;\n    }\n    push_picture_to_output_queue(imgunit);\n    delete imgunit;\n    pop_front(image_units);\n  }\n  return err;\n}", "target": 0}
{"code": "void freeClient(redisClient *c) {\n    listNode *ln;\n    sdsfree(c->querybuf);\n    c->querybuf = NULL;\n    if (c->flags & REDIS_BLOCKED)\n        unblockClientWaitingData(c);\n    unwatchAllKeys(c);\n    listRelease(c->watched_keys);\n    pubsubUnsubscribeAllChannels(c,0);\n    pubsubUnsubscribeAllPatterns(c,0);\n    dictRelease(c->pubsub_channels);\n    listRelease(c->pubsub_patterns);\n    aeDeleteFileEvent(server.el,c->fd,AE_READABLE);\n    aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);\n    listRelease(c->reply);\n    freeClientArgv(c);\n    close(c->fd);\n    ln = listSearchKey(server.clients,c);\n    redisAssert(ln != NULL);\n    listDelNode(server.clients,ln);\n    if (c->flags & REDIS_IO_WAIT) {\n        redisAssert(server.vm_enabled);\n        if (listLength(c->io_keys) == 0) {\n            ln = listSearchKey(server.io_ready_clients,c);\n            redisAssert(ln != NULL);\n            listDelNode(server.io_ready_clients,ln);\n        } else {\n            while (listLength(c->io_keys)) {\n                ln = listFirst(c->io_keys);\n                dontWaitForSwappedKey(c,ln->value);\n            }\n        }\n        server.vm_blocked_clients--;\n    }\n    listRelease(c->io_keys);\n    if (c->flags & REDIS_SLAVE) {\n        if (c->replstate == REDIS_REPL_SEND_BULK && c->repldbfd != -1)\n            close(c->repldbfd);\n        list *l = (c->flags & REDIS_MONITOR) ? server.monitors : server.slaves;\n        ln = listSearchKey(l,c);\n        redisAssert(ln != NULL);\n        listDelNode(l,ln);\n    }\n    if (c->flags & REDIS_MASTER) {\n        server.master = NULL;\n        server.replstate = REDIS_REPL_CONNECT;\n        while (listLength(server.slaves)) {\n            ln = listFirst(server.slaves);\n            freeClient((redisClient*)ln->value);\n        }\n    }\n    zfree(c->argv);\n    freeClientMultiState(c);\n    zfree(c);\n}", "target": 1}
{"code": "static int sco_sock_getsockopt_old(struct socket *sock, int optname, char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sco_options opts;\n\tstruct sco_conninfo cinfo;\n\tint len, err = 0;\n\tBT_DBG(\"sk %p\", sk);\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tlock_sock(sk);\n\tswitch (optname) {\n\tcase SCO_OPTIONS:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\t\topts.mtu = sco_pi(sk)->conn->mtu;\n\t\tBT_DBG(\"mtu %d\", opts.mtu);\n\t\tlen = min_t(unsigned int, len, sizeof(opts));\n\t\tif (copy_to_user(optval, (char *)&opts, len))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase SCO_CONNINFO:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\t\tmemset(&cinfo, 0, sizeof(cinfo));\n\t\tcinfo.hci_handle = sco_pi(sk)->conn->hcon->handle;\n\t\tmemcpy(cinfo.dev_class, sco_pi(sk)->conn->hcon->dev_class, 3);\n\t\tlen = min_t(unsigned int, len, sizeof(cinfo));\n\t\tif (copy_to_user(optval, (char *)&cinfo, len))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "bool Sampler::operator==(const Sampler &other) const {\n  return this->extensions == other.extensions && this->extras == other.extras &&\n         this->magFilter == other.magFilter &&\n         this->minFilter == other.minFilter && this->name == other.name &&\n         this->wrapS == other.wrapS &&\n         this->wrapT == other.wrapT;\n}", "target": 1}
{"code": "void ComparisonQuantized(const TfLiteTensor* input1, const TfLiteTensor* input2,\n                         TfLiteTensor* output, bool requires_broadcast) {\n  if (input1->type == kTfLiteUInt8 || input1->type == kTfLiteInt8) {\n    auto input1_offset = -input1->params.zero_point;\n    auto input2_offset = -input2->params.zero_point;\n    const int left_shift = 8;\n    int32 input1_multiplier;\n    int input1_shift;\n    QuantizeMultiplierSmallerThanOneExp(input1->params.scale,\n                                        &input1_multiplier, &input1_shift);\n    int32 input2_multiplier;\n    int input2_shift;\n    QuantizeMultiplierSmallerThanOneExp(input2->params.scale,\n                                        &input2_multiplier, &input2_shift);\n    ComparisonParams op_params;\n    op_params.left_shift = left_shift;\n    op_params.input1_offset = input1_offset;\n    op_params.input1_multiplier = input1_multiplier;\n    op_params.input1_shift = input1_shift;\n    op_params.input2_offset = input2_offset;\n    op_params.input2_multiplier = input2_multiplier;\n    op_params.input2_shift = input2_shift;\n    if (requires_broadcast) {\n      reference_ops::BroadcastComparison4DSlowWithScaling<input_dtype, opname>(\n          op_params, GetTensorShape(input1), GetTensorData<input_dtype>(input1),\n          GetTensorShape(input2), GetTensorData<input_dtype>(input2),\n          GetTensorShape(output), GetTensorData<bool>(output));\n    } else {\n      reference_ops::ComparisonWithScaling<input_dtype, opname>(\n          op_params, GetTensorShape(input1), GetTensorData<input_dtype>(input1),\n          GetTensorShape(input2), GetTensorData<input_dtype>(input2),\n          GetTensorShape(output), GetTensorData<bool>(output));\n    }\n  }\n}", "target": 1}
{"code": "LookupModMask(struct xkb_context *ctx, const void *priv, xkb_atom_t field,\n              enum expr_value_type type, xkb_mod_mask_t *val_rtrn)\n{\n    const char *str;\n    xkb_mod_index_t ndx;\n    const LookupModMaskPriv *arg = priv;\n    const struct xkb_mod_set *mods = arg->mods;\n    enum mod_type mod_type = arg->mod_type;\n    if (type != EXPR_TYPE_INT)\n        return false;\n    str = xkb_atom_text(ctx, field);\n    if (!str)\n        return false;\n    if (istreq(str, \"all\")) {\n        *val_rtrn  = MOD_REAL_MASK_ALL;\n        return true;\n    }\n    if (istreq(str, \"none\")) {\n        *val_rtrn = 0;\n        return true;\n    }\n    ndx = XkbModNameToIndex(mods, field, mod_type);\n    if (ndx == XKB_MOD_INVALID)\n        return false;\n    *val_rtrn = (1u << ndx);\n    return true;\n}", "target": 0}
{"code": "static bool tailmatch(const char *little, const char *bigone)\n{\n  size_t littlelen = strlen(little);\n  size_t biglen = strlen(bigone);\n  if(littlelen > biglen)\n    return FALSE;\n  return Curl_raw_equal(little, bigone+biglen-littlelen) ? TRUE : FALSE;\n}", "target": 1}
{"code": "static void mark_object(struct object *obj, struct strbuf *path,\n\t\t\tconst char *name, void *data)\n{\n\tupdate_progress(data);\n}", "target": 1}
